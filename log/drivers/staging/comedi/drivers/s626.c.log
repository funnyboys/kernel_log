commit 073e0be325aea170da43084b8b0270a54f6a691b
Author: Deepak R Varma <mh12gx2825@gmail.com>
Date:   Sun Mar 15 03:09:00 2020 +0530

    staging: comedi: s626: Reformat function arguments
    
    Reformat function call arguments to comedi_check_trigger_arg_min
    as per coding style guideline. Problem detected by checkpatch script.
    
    Signed-off-by: Deepak R Varma <mh12gx2825@gmail.com>
    Link: https://lore.kernel.org/r/20200314213856.GA3874@deeUbuntu
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 39049d3c56d7..084a8e7b9fc2 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1892,8 +1892,7 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 		if (cmd->scan_begin_src == TRIG_TIMER) {
 			arg = cmd->convert_arg * cmd->scan_end_arg;
 			err |= comedi_check_trigger_arg_min(
-				&cmd->scan_begin_arg,
-				arg);
+					&cmd->scan_begin_arg, arg);
 		}
 	}
 

commit fb24ea52f78e0d595852e09e3a55697c8f442189
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Feb 22 17:14:59 2019 +0000

    drivers: Remove explicit invocations of mmiowb()
    
    mmiowb() is now implied by spin_unlock() on architectures that require
    it, so there is no reason to call it from driver code. This patch was
    generated using coccinelle:
    
            @mmiowb@
            @@
            - mmiowb();
    
    and invoked as:
    
    $ for d in drivers include/linux/qed sound; do \
    spatch --include-headers --sp-file mmiowb.cocci --dir $d --in-place; done
    
    NOTE: mmiowb() has only ever guaranteed ordering in conjunction with
    spin_unlock(). However, pairing each mmiowb() removal in this patch with
    the corresponding call to spin_unlock() is not at all trivial, so there
    is a small chance that this change may regress any drivers incorrectly
    relying on mmiowb() to order MMIO writes between CPUs using lock-free
    synchronisation. If you've ended up bisecting to this commit, you can
    reintroduce the mmiowb() calls using wmb() instead, which should restore
    the old behaviour on all architectures other than some esoteric ia64
    systems.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index f5af6f4069dc..39049d3c56d7 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -108,7 +108,6 @@ static void s626_mc_enable(struct comedi_device *dev,
 {
 	unsigned int val = (cmd << 16) | cmd;
 
-	mmiowb();
 	writel(val, dev->mmio + reg);
 }
 
@@ -116,7 +115,6 @@ static void s626_mc_disable(struct comedi_device *dev,
 			    unsigned int cmd, unsigned int reg)
 {
 	writel(cmd << 16, dev->mmio + reg);
-	mmiowb();
 }
 
 static bool s626_mc_test(struct comedi_device *dev,

commit e10b178176f7d1ee9b3cdab223061d8764c5c17f
Author: Paul McQuade <paulmcquad@gmail.com>
Date:   Tue Mar 27 20:07:24 2018 +0100

    staging: comedi: s626: Use Preferred kernel type
    
    Change to kenel type u8 or u16 instead of uint8_t or uint16_t
    
    Signed-off-by: Paul McQuade <paulmcquad@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index ec54dc3e9ad6..f5af6f4069dc 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2268,10 +2268,10 @@ static int s626_initialize(struct comedi_device *dev)
 	 */
 	{
 		struct comedi_subdevice *s = dev->read_subdev;
-		uint8_t poll_list;
-		uint16_t adc_data;
-		uint16_t start_val;
-		uint16_t index;
+		u8 poll_list;
+		u16 adc_data;
+		u16 start_val;
+		u16 index;
 		unsigned int data[16];
 
 		/* Create a simple polling list for analog input channel 0 */

commit c318bb0835ca7c744892ed5881c04862b771b3cf
Author: Eisha Chen-yen-su <chenyensu0@gmail.com>
Date:   Sun Feb 18 14:27:07 2018 +0100

    staging: comedi: Use '"%s:", __func__' instead of function name
    
    Replace an occurrence of the function name in a string by a reference
    to __func__, to improve robustness. Problem found with checkpatch.
    
    Signed-off-by: Eisha Chen-yen-su <chenyensu0@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 0b3cfe934e14..ec54dc3e9ad6 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1700,7 +1700,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (devpriv->ai_cmd_running) {
 		dev_err(dev->class_dev,
-			"s626_ai_cmd: Another ai_cmd is running\n");
+			"%s: Another ai_cmd is running\n", __func__);
 		return -EBUSY;
 	}
 	/* disable interrupt */

commit e9f14f1954ef73ef17b90651d653c67cd79715be
Author: Roman Lakeev <sunnyddayss@gmail.com>
Date:   Wed Dec 13 20:39:53 2017 -0800

    staging: comedi: s626.c - fix multiline dereference
    
    staging: comedi: s626.c - fix the following checkpatch issues:
    WARNING: Avoid multiple line dereference - prefer 'devpriv->rps_buf.logical_base'
    #1380: FILE: drivers/s626.c:1380:
    +                                  (unsigned long)devpriv->
    +                                                 rps_buf.logical_base);
    
    WARNING: Avoid multiple line dereference - prefer 'cmd->scan_begin_arg'
    #1898: FILE: drivers/s626.c:1898:
    +                       err |= comedi_check_trigger_arg_min(&cmd->
    +                                                           scan_begin_arg,
    
    Signed-off-by: Roman Lakeev <sunnyddayss@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 8d9187025d51..0b3cfe934e14 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1376,8 +1376,7 @@ static void s626_reset_adc(struct comedi_device *dev, u8 *ppl)
 		jmp_adrs =
 			(u32)devpriv->rps_buf.physical_base +
 			(u32)((unsigned long)rps -
-				   (unsigned long)devpriv->
-						  rps_buf.logical_base);
+			      (unsigned long)devpriv->rps_buf.logical_base);
 		for (i = 0; i < (10 * S626_RPSCLK_PER_US / 2); i++) {
 			jmp_adrs += 8;	/* Repeat to implement time delay: */
 			/* Jump to next RPS instruction. */
@@ -1894,9 +1893,9 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 
 		if (cmd->scan_begin_src == TRIG_TIMER) {
 			arg = cmd->convert_arg * cmd->scan_end_arg;
-			err |= comedi_check_trigger_arg_min(&cmd->
-							    scan_begin_arg,
-							    arg);
+			err |= comedi_check_trigger_arg_min(
+				&cmd->scan_begin_arg,
+				arg);
 		}
 	}
 

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 24e8191e4d74..8d9187025d51 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -8,16 +8,6 @@
  *
  * Based on Sensoray Model 626 Linux driver Version 0.2
  * Copyright (C) 2002-2004 Sensoray Co., Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index c906c9a5d944..24e8191e4d74 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * comedi/drivers/s626.c
  * Sensoray s626 Comedi driver

commit 3137139a65822f331d4cce195da1440c1dc0a071
Author: edcarter <edcarter@ualberta.ca>
Date:   Fri Jun 2 18:18:24 2017 -0700

    Staging: comedi: s626.c: fixed trailing */ style issue
    
    Fixed coding style issue where trailing */ in block comments
    were not on separate lines.
    
    Signed-off-by: Elias Carter <edcarter@ualberta.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4b9c22665748..c906c9a5d944 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -580,11 +580,14 @@ static int s626_set_dac(struct comedi_device *dev,
 	 * running after the packet has been sent to the target DAC.
 	 */
 	val = 0x0F000000;	/* Continue clock after target DAC data
-				 * (write to non-existent trimdac). */
+				 * (write to non-existent trimdac).
+				 */
 	val |= 0x00004000;	/* Address the two main dual-DAC devices
-				 * (TSL's chip select enables target device). */
+				 * (TSL's chip select enables target device).
+				 */
 	val |= ((u32)(chan & 1) << 15);	/* Address the DAC channel
-						 * within the device. */
+					 * within the device.
+					 */
 	val |= (u32)dacdata;	/* Include DAC setpoint data. */
 	return s626_send_dac(dev, val);
 }

commit e45c2379125c00a1c6fcda5211418970a1d89d31
Author: Andrea della Porta <sfaragnaus@gmail.com>
Date:   Fri Apr 7 01:16:37 2017 +0100

    staging: comedi: drivers: s626.c - fixed checkpatch issue about data type
    
    staging: comedi: drivers: s626.c - fixed the following checkpatch issue:
    CHECK: Prefer kernel type 's16' over 'int16_t'
    #1939: FILE: drivers/staging/comedi/drivers/s626.c:1939:
    +               int16_t dacdata = (int16_t)data[i];
    
    Signed-off-by: Andrea della Porta <sfaragnaus@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 0b189c5b62d3..4b9c22665748 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1936,7 +1936,7 @@ static int s626_ao_insn_write(struct comedi_device *dev,
 	int i;
 
 	for (i = 0; i < insn->n; i++) {
-		int16_t dacdata = (int16_t)data[i];
+		s16 dacdata = (s16)data[i];
 		int ret;
 
 		dacdata -= (0x1fff);

commit a2be06266b65c17df7ec5d1331670eb61b848993
Author: Varsha Rao <rvarsha016@gmail.com>
Date:   Thu Mar 9 19:49:01 2017 +0530

    staging: comedi: Remove useless cast.
    
    Variable dac_data is already declared as of type u8. Again explicit type
    casting of dac_data to u8, is not required. Hence this patch removes it
    by using the following coccinelle script.
    
    @@
    type T;
    T *ptr;
    T p;
    @@
    (
    - (T *)(&p)
    + &p
    |
    - (T *)ptr
    + ptr
    |
    - (T *)(ptr)
    + ptr
    |
    - (T)(p)
    + p
    )
    
    Signed-off-by: Varsha Rao <rvarsha016@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 452337814da5..0b189c5b62d3 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -599,7 +599,7 @@ static int s626_write_trim_dac(struct comedi_device *dev,
 	 * Save the new setpoint in case the application needs to read it back
 	 * later.
 	 */
-	devpriv->trim_setpoint[logical_chan] = (u8)dac_data;
+	devpriv->trim_setpoint[logical_chan] = dac_data;
 
 	/* Map logical channel number to physical channel number. */
 	chan = s626_trimchan[logical_chan];

commit 427fda4e5c3406fcca5ab87aabccdbb2840b7544
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Feb 22 09:45:41 2017 +1100

    staging: comedi: s626: Kernel doc format comments
    
    Checkpatch emits WARNING: Block comments use a trailing */ on a
    separate line. Offending comments are commenting variables within
    the main data structure of s626 driver. We can move these comments
    to kernel doc format with the benefit of clearing the warning and
    improving the documentation for the driver.
    
    Remove comments on structure members. Add original comments to the
    head of the structure definition in kernel doc format.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 97939b42cc00..452337814da5 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -74,26 +74,34 @@ struct s626_buffer_dma {
 	void *logical_base;
 };
 
+/**
+ * struct s626_private - Working data for s626 driver.
+ * @ai_cmd_running: non-zero if ai_cmd is running.
+ * @ai_sample_timer: time between samples in units of the timer.
+ * @ai_convert_count: conversion counter.
+ * @ai_convert_timer: time between conversion in units of the timer.
+ * @counter_int_enabs: counter interrupt enable mask for MISC2 register.
+ * @adc_items: number of items in ADC poll list.
+ * @rps_buf: DMA buffer used to hold ADC (RPS1) program.
+ * @ana_buf:  DMA buffer used to receive ADC data and hold DAC data.
+ * @dac_wbuf: pointer to logical adrs of DMA buffer used to hold DAC data.
+ * @dacpol: image of DAC polarity register.
+ * @trim_setpoint: images of TrimDAC setpoints.
+ * @i2c_adrs: I2C device address for onboard EEPROM (board rev dependent)
+ */
 struct s626_private {
-	u8 ai_cmd_running;		/* ai_cmd is running */
-	unsigned int ai_sample_timer;	/* time between samples in
-					 * units of the timer */
-	int ai_convert_count;		/* conversion counter */
-	unsigned int ai_convert_timer;	/* time between conversion in
-					 * units of the timer */
-	u16 counter_int_enabs;	        /* counter interrupt enable mask
-					 * for MISC2 register */
-	u8 adc_items;		        /* number of items in ADC poll list */
-	struct s626_buffer_dma rps_buf;	/* DMA buffer used to hold ADC (RPS1)
-					 * program */
-	struct s626_buffer_dma ana_buf;	/* DMA buffer used to receive ADC data
-					 * and hold DAC data */
-	u32 *dac_wbuf;		        /* pointer to logical adrs of DMA buffer
-					 * used to hold DAC data */
-	u16 dacpol;		        /* image of DAC polarity register */
-	u8 trim_setpoint[12];	        /* images of TrimDAC setpoints */
-	u32 i2c_adrs;		        /* I2C device address for onboard EEPROM
-					 * (board rev dependent) */
+	u8 ai_cmd_running;
+	unsigned int ai_sample_timer;
+	int ai_convert_count;
+	unsigned int ai_convert_timer;
+	u16 counter_int_enabs;
+	u8 adc_items;
+	struct s626_buffer_dma rps_buf;
+	struct s626_buffer_dma ana_buf;
+	u32 *dac_wbuf;
+	u16 dacpol;
+	u8 trim_setpoint[12];
+	u32 i2c_adrs;
 };
 
 /* Counter overflow/index event flag masks for RDMISC2. */

commit df6ff8a1ee3c6cfd7957cb26357ddcbbe9c25348
Author: Saber Rezvani <irsaber@gmail.com>
Date:   Fri Feb 10 21:44:49 2017 +0330

    staging: comedi: s626: usleep_range is preferred over udelay
    
    Fix the checkpatch.pl issue:
    CHECK: usleep_range is preferred over udelay
    
    Signed-off-by: Saber Rezvani <irsaber@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 0dd5fe286855..97939b42cc00 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1513,7 +1513,7 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 
 	for (n = 0; n < insn->n; n++) {
 		/* Delay 10 microseconds for analog input settling. */
-		udelay(10);
+		usleep_range(10, 20);
 
 		/* Start ADC by pulsing GPIO1 low */
 		gpio_image = readl(dev->mmio + S626_P_GPIO);

commit b13db6bf539dce9dd5d0128c42269334e5e2d17e
Author: Saber Rezvani <irsaber@gmail.com>
Date:   Fri Dec 2 01:35:42 2016 +0330

    staging: comedi: s626: use preferred kernel type u32
    
    Fix the checkpatch.pl issue:
    CHECK: Prefer kernel type 'u32' over 'uint32_t'
    
    Signed-off-by: Saber Rezvani <irsaber@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index baf997d25af8..0dd5fe286855 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -88,11 +88,11 @@ struct s626_private {
 					 * program */
 	struct s626_buffer_dma ana_buf;	/* DMA buffer used to receive ADC data
 					 * and hold DAC data */
-	uint32_t *dac_wbuf;		/* pointer to logical adrs of DMA buffer
+	u32 *dac_wbuf;		        /* pointer to logical adrs of DMA buffer
 					 * used to hold DAC data */
 	u16 dacpol;		        /* image of DAC polarity register */
 	u8 trim_setpoint[12];	        /* images of TrimDAC setpoints */
-	uint32_t i2c_adrs;		/* I2C device address for onboard EEPROM
+	u32 i2c_adrs;		        /* I2C device address for onboard EEPROM
 					 * (board rev dependent) */
 };
 
@@ -241,7 +241,7 @@ static int s626_i2c_handshake_eoc(struct comedi_device *dev,
 	return -EBUSY;
 }
 
-static int s626_i2c_handshake(struct comedi_device *dev, uint32_t val)
+static int s626_i2c_handshake(struct comedi_device *dev, u32 val)
 {
 	unsigned int ctrl;
 	int ret;
@@ -357,7 +357,7 @@ static int s626_send_dac_eoc(struct comedi_device *dev,
  * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
  * dacpol contains valid target image.
  */
-static int s626_send_dac(struct comedi_device *dev, uint32_t val)
+static int s626_send_dac(struct comedi_device *dev, u32 val)
 {
 	struct s626_private *devpriv = dev->private;
 	int ret;
@@ -520,8 +520,8 @@ static int s626_set_dac(struct comedi_device *dev,
 {
 	struct s626_private *devpriv = dev->private;
 	u16 signmask;
-	uint32_t ws_image;
-	uint32_t val;
+	u32 ws_image;
+	u32 val;
 
 	/*
 	 * Adjust DAC data polarity and set up Polarity Control Register image.
@@ -575,9 +575,9 @@ static int s626_set_dac(struct comedi_device *dev,
 				 * (write to non-existent trimdac). */
 	val |= 0x00004000;	/* Address the two main dual-DAC devices
 				 * (TSL's chip select enables target device). */
-	val |= ((uint32_t)(chan & 1) << 15);	/* Address the DAC channel
+	val |= ((u32)(chan & 1) << 15);	/* Address the DAC channel
 						 * within the device. */
-	val |= (uint32_t)dacdata;	/* Include DAC setpoint data. */
+	val |= (u32)dacdata;	/* Include DAC setpoint data. */
 	return s626_send_dac(dev, val);
 }
 
@@ -585,7 +585,7 @@ static int s626_write_trim_dac(struct comedi_device *dev,
 			       u8 logical_chan, u8 dac_data)
 {
 	struct s626_private *devpriv = dev->private;
-	uint32_t chan;
+	u32 chan;
 
 	/*
 	 * Save the new setpoint in case the application needs to read it back
@@ -672,7 +672,7 @@ static void s626_set_latch_source(struct comedi_device *dev,
  * Write value into counter preload register.
  */
 static void s626_preload(struct comedi_device *dev,
-			 unsigned int chan, uint32_t value)
+			 unsigned int chan, u32 value)
 {
 	s626_debi_write(dev, S626_LP_CNTR(chan), value);
 	s626_debi_write(dev, S626_LP_CNTR(chan) + 2, value >> 16);
@@ -1196,7 +1196,7 @@ static bool s626_handle_eos_interrupt(struct comedi_device *dev)
 	 * first uint16_t in the buffer because it contains junk data
 	 * from the final ADC of the previous poll list scan.
 	 */
-	uint32_t *readaddr = (uint32_t *)devpriv->ana_buf.logical_base + 1;
+	u32 *readaddr = (u32 *)devpriv->ana_buf.logical_base + 1;
 	int i;
 
 	/* get the data and hand it over to comedi */
@@ -1231,7 +1231,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	unsigned long flags;
-	uint32_t irqtype, irqstatus;
+	u32 irqtype, irqstatus;
 
 	if (!dev->attached)
 		return IRQ_NONE;
@@ -1277,20 +1277,20 @@ static void s626_reset_adc(struct comedi_device *dev, u8 *ppl)
 	struct s626_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	uint32_t *rps;
-	uint32_t jmp_adrs;
+	u32 *rps;
+	u32 jmp_adrs;
 	u16 i;
 	u16 n;
-	uint32_t local_ppl;
+	u32 local_ppl;
 
 	/* Stop RPS program in case it is currently running */
 	s626_mc_disable(dev, S626_MC1_ERPS1, S626_P_MC1);
 
 	/* Set starting logical address to write RPS commands. */
-	rps = (uint32_t *)devpriv->rps_buf.logical_base;
+	rps = (u32 *)devpriv->rps_buf.logical_base;
 
 	/* Initialize RPS instruction pointer */
-	writel((uint32_t)devpriv->rps_buf.physical_base,
+	writel((u32)devpriv->rps_buf.physical_base,
 	       dev->mmio + S626_P_RPSADDR1);
 
 	/* Construct RPS program in rps_buf DMA buffer */
@@ -1372,8 +1372,8 @@ static void s626_reset_adc(struct comedi_device *dev, u8 *ppl)
 		 * flushes the RPS' instruction prefetch pipeline.
 		 */
 		jmp_adrs =
-			(uint32_t)devpriv->rps_buf.physical_base +
-			(uint32_t)((unsigned long)rps -
+			(u32)devpriv->rps_buf.physical_base +
+			(u32)((unsigned long)rps -
 				   (unsigned long)devpriv->
 						  rps_buf.logical_base);
 		for (i = 0; i < (10 * S626_RPSCLK_PER_US / 2); i++) {
@@ -1408,7 +1408,7 @@ static void s626_reset_adc(struct comedi_device *dev, u8 *ppl)
 		/* Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
 		*rps++ = S626_RPS_STREG |
 			 (S626_BUGFIX_STREG(S626_P_FB_BUFFER1) >> 2);
-		*rps++ = (uint32_t)devpriv->ana_buf.physical_base +
+		*rps++ = (u32)devpriv->ana_buf.physical_base +
 			 (devpriv->adc_items << 2);
 
 		/*
@@ -1452,7 +1452,7 @@ static void s626_reset_adc(struct comedi_device *dev, u8 *ppl)
 
 	/* Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
 	*rps++ = S626_RPS_STREG | (S626_BUGFIX_STREG(S626_P_FB_BUFFER1) >> 2);
-	*rps++ = (uint32_t)devpriv->ana_buf.physical_base +
+	*rps++ = (u32)devpriv->ana_buf.physical_base +
 		 (devpriv->adc_items << 2);
 
 	/* Indicate ADC scan loop is finished. */
@@ -1465,7 +1465,7 @@ static void s626_reset_adc(struct comedi_device *dev, u8 *ppl)
 
 	/* Restart RPS program at its beginning. */
 	*rps++ = S626_RPS_JUMP;	/* Branch to start of RPS program. */
-	*rps++ = (uint32_t)devpriv->rps_buf.physical_base;
+	*rps++ = (u32)devpriv->rps_buf.physical_base;
 
 	/* End of RPS program build */
 }
@@ -1491,8 +1491,8 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	u16 chan = CR_CHAN(insn->chanspec);
 	u16 range = CR_RANGE(insn->chanspec);
 	u16 adc_spec = 0;
-	uint32_t gpio_image;
-	uint32_t tmp;
+	u32 gpio_image;
+	u32 tmp;
 	int ret;
 	int n;
 
@@ -2248,7 +2248,7 @@ static int s626_initialize(struct comedi_device *dev)
 	 */
 
 	/* Physical start of RPS program */
-	writel((uint32_t)devpriv->rps_buf.physical_base,
+	writel((u32)devpriv->rps_buf.physical_base,
 	       dev->mmio + S626_P_RPSADDR1);
 	/* RPS program performs no explicit mem writes */
 	writel(0, dev->mmio + S626_P_RPSPAGE1);
@@ -2318,16 +2318,16 @@ static int s626_initialize(struct comedi_device *dev)
 	 * enabled.
 	 */
 	phys_buf = devpriv->ana_buf.physical_base +
-		   (S626_DAC_WDMABUF_OS * sizeof(uint32_t));
-	writel((uint32_t)phys_buf, dev->mmio + S626_P_BASEA2_OUT);
-	writel((uint32_t)(phys_buf + sizeof(uint32_t)),
+		   (S626_DAC_WDMABUF_OS * sizeof(u32));
+	writel((u32)phys_buf, dev->mmio + S626_P_BASEA2_OUT);
+	writel((u32)(phys_buf + sizeof(u32)),
 	       dev->mmio + S626_P_PROTA2_OUT);
 
 	/*
 	 * Cache Audio2's output DMA buffer logical address.  This is
 	 * where DAC data is buffered for A2 output DMA transfers.
 	 */
-	devpriv->dac_wbuf = (uint32_t *)devpriv->ana_buf.logical_base +
+	devpriv->dac_wbuf = (u32 *)devpriv->ana_buf.logical_base +
 			    S626_DAC_WDMABUF_OS;
 
 	/*

commit 0bc45380096dce67319676d880e039f2d9e0af85
Author: Saber Rezvani <irsaber@gmail.com>
Date:   Fri Dec 2 01:35:41 2016 +0330

    staging: comedi: s626: use preferred kernel type u16
    
    Fix the checkpatch.pl issue:
    CHECK: Prefer kernel type 'u16' over 'uint16_t'
    
    Signed-off-by: Saber Rezvani <irsaber@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 59a4aebbfa08..baf997d25af8 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -81,7 +81,7 @@ struct s626_private {
 	int ai_convert_count;		/* conversion counter */
 	unsigned int ai_convert_timer;	/* time between conversion in
 					 * units of the timer */
-	uint16_t counter_int_enabs;	/* counter interrupt enable mask
+	u16 counter_int_enabs;	        /* counter interrupt enable mask
 					 * for MISC2 register */
 	u8 adc_items;		        /* number of items in ADC poll list */
 	struct s626_buffer_dma rps_buf;	/* DMA buffer used to hold ADC (RPS1)
@@ -90,7 +90,7 @@ struct s626_private {
 					 * and hold DAC data */
 	uint32_t *dac_wbuf;		/* pointer to logical adrs of DMA buffer
 					 * used to hold DAC data */
-	uint16_t dacpol;		/* image of DAC polarity register */
+	u16 dacpol;		        /* image of DAC polarity register */
 	u8 trim_setpoint[12];	        /* images of TrimDAC setpoints */
 	uint32_t i2c_adrs;		/* I2C device address for onboard EEPROM
 					 * (board rev dependent) */
@@ -179,7 +179,7 @@ static void s626_debi_transfer(struct comedi_device *dev)
 /*
  * Read a value from a gate array register.
  */
-static uint16_t s626_debi_read(struct comedi_device *dev, uint16_t addr)
+static u16 s626_debi_read(struct comedi_device *dev, u16 addr)
 {
 	/* Set up DEBI control register value in shadow RAM */
 	writel(S626_DEBI_CMD_RDWORD | addr, dev->mmio + S626_P_DEBICMD);
@@ -193,8 +193,8 @@ static uint16_t s626_debi_read(struct comedi_device *dev, uint16_t addr)
 /*
  * Write a value to a gate array register.
  */
-static void s626_debi_write(struct comedi_device *dev, uint16_t addr,
-			    uint16_t wdata)
+static void s626_debi_write(struct comedi_device *dev, u16 addr,
+			    u16 wdata)
 {
 	/* Set up DEBI control register value in shadow RAM */
 	writel(S626_DEBI_CMD_WRWORD | addr, dev->mmio + S626_P_DEBICMD);
@@ -516,10 +516,10 @@ static int s626_send_dac(struct comedi_device *dev, uint32_t val)
  * Private helper function: Write setpoint to an application DAC channel.
  */
 static int s626_set_dac(struct comedi_device *dev,
-			uint16_t chan, int16_t dacdata)
+			u16 chan, int16_t dacdata)
 {
 	struct s626_private *devpriv = dev->private;
-	uint16_t signmask;
+	u16 signmask;
 	uint32_t ws_image;
 	uint32_t val;
 
@@ -535,7 +535,7 @@ static int s626_set_dac(struct comedi_device *dev,
 	}
 
 	/* Limit DAC setpoint value to valid range. */
-	if ((uint16_t)dacdata > 0x1FFF)
+	if ((u16)dacdata > 0x1FFF)
 		dacdata = 0x1FFF;
 
 	/*
@@ -661,7 +661,7 @@ static int s626_load_trim_dacs(struct comedi_device *dev)
  * latches B.
  */
 static void s626_set_latch_source(struct comedi_device *dev,
-				  unsigned int chan, uint16_t value)
+				  unsigned int chan, u16 value)
 {
 	s626_debi_replace(dev, S626_LP_CRB(chan),
 			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_LATCHSRC),
@@ -686,7 +686,7 @@ static void s626_preload(struct comedi_device *dev,
 static void s626_reset_cap_flags(struct comedi_device *dev,
 				 unsigned int chan)
 {
-	uint16_t set;
+	u16 set;
 
 	set = S626_SET_CRB_INTRESETCMD(1);
 	if (chan < 3)
@@ -704,12 +704,12 @@ static void s626_reset_cap_flags(struct comedi_device *dev,
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
 static void s626_set_mode_a(struct comedi_device *dev,
-			    unsigned int chan, uint16_t setup,
-			    uint16_t disable_int_src)
+			    unsigned int chan, u16 setup,
+			    u16 disable_int_src)
 {
 	struct s626_private *devpriv = dev->private;
-	uint16_t cra;
-	uint16_t crb;
+	u16 cra;
+	u16 crb;
 	unsigned int cntsrc, clkmult, clkpol;
 
 	/* Initialize CRA and CRB images. */
@@ -782,12 +782,12 @@ static void s626_set_mode_a(struct comedi_device *dev,
 }
 
 static void s626_set_mode_b(struct comedi_device *dev,
-			    unsigned int chan, uint16_t setup,
-			    uint16_t disable_int_src)
+			    unsigned int chan, u16 setup,
+			    u16 disable_int_src)
 {
 	struct s626_private *devpriv = dev->private;
-	uint16_t cra;
-	uint16_t crb;
+	u16 cra;
+	u16 crb;
 	unsigned int cntsrc, clkmult, clkpol;
 
 	/* Initialize CRA and CRB images. */
@@ -868,7 +868,7 @@ static void s626_set_mode_b(struct comedi_device *dev,
 
 static void s626_set_mode(struct comedi_device *dev,
 			  unsigned int chan,
-			  uint16_t setup, uint16_t disable_int_src)
+			  u16 setup, u16 disable_int_src)
 {
 	if (chan < 3)
 		s626_set_mode_a(dev, chan, setup, disable_int_src);
@@ -880,7 +880,7 @@ static void s626_set_mode(struct comedi_device *dev,
  * Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
  */
 static void s626_set_enable(struct comedi_device *dev,
-			    unsigned int chan, uint16_t enab)
+			    unsigned int chan, u16 enab)
 {
 	unsigned int mask = S626_CRBMSK_INTCTRL;
 	unsigned int set;
@@ -901,11 +901,11 @@ static void s626_set_enable(struct comedi_device *dev,
  * 2=OverflowA (B counters only), 3=disabled.
  */
 static void s626_set_load_trig(struct comedi_device *dev,
-			       unsigned int chan, uint16_t trig)
+			       unsigned int chan, u16 trig)
 {
-	uint16_t reg;
-	uint16_t mask;
-	uint16_t set;
+	u16 reg;
+	u16 mask;
+	u16 set;
 
 	if (chan < 3) {
 		reg = S626_LP_CRA(chan);
@@ -925,11 +925,11 @@ static void s626_set_load_trig(struct comedi_device *dev,
  * 2=IndexOnly, 3=IndexAndOverflow.
  */
 static void s626_set_int_src(struct comedi_device *dev,
-			     unsigned int chan, uint16_t int_source)
+			     unsigned int chan, u16 int_source)
 {
 	struct s626_private *devpriv = dev->private;
-	uint16_t cra_reg = S626_LP_CRA(chan);
-	uint16_t crb_reg = S626_LP_CRB(chan);
+	u16 cra_reg = S626_LP_CRA(chan);
+	u16 crb_reg = S626_LP_CRB(chan);
 
 	if (chan < 3) {
 		/* Reset any pending counter overflow or index captures */
@@ -941,7 +941,7 @@ static void s626_set_int_src(struct comedi_device *dev,
 		s626_debi_replace(dev, cra_reg, ~S626_CRAMSK_INTSRC_A,
 				  S626_SET_CRA_INTSRC_A(int_source));
 	} else {
-		uint16_t crb;
+		u16 crb;
 
 		/* Cache writeable CRB register image */
 		crb = s626_debi_read(dev, crb_reg);
@@ -985,7 +985,7 @@ static void s626_pulse_index(struct comedi_device *dev,
 			     unsigned int chan)
 {
 	if (chan < 3) {
-		uint16_t cra;
+		u16 cra;
 
 		cra = s626_debi_read(dev, S626_LP_CRA(chan));
 
@@ -994,7 +994,7 @@ static void s626_pulse_index(struct comedi_device *dev,
 				(cra ^ S626_CRAMSK_INDXPOL_A));
 		s626_debi_write(dev, S626_LP_CRA(chan), cra);
 	} else {
-		uint16_t crb;
+		u16 crb;
 
 		crb = s626_debi_read(dev, S626_LP_CRB(chan));
 		crb &= ~S626_CRBMSK_INTCTRL;
@@ -1062,7 +1062,7 @@ static int s626_dio_clear_irq(struct comedi_device *dev)
 }
 
 static void s626_handle_dio_interrupt(struct comedi_device *dev,
-				      uint16_t irqbit, u8 group)
+				      u16 irqbit, u8 group)
 {
 	struct s626_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
@@ -1110,7 +1110,7 @@ static void s626_handle_dio_interrupt(struct comedi_device *dev,
 
 static void s626_check_dio_interrupts(struct comedi_device *dev)
 {
-	uint16_t irqbit;
+	u16 irqbit;
 	u8 group;
 
 	for (group = 0; group < S626_DIO_BANKS; group++) {
@@ -1131,7 +1131,7 @@ static void s626_check_counter_interrupts(struct comedi_device *dev)
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	uint16_t irqbit;
+	u16 irqbit;
 
 	/* read interrupt type */
 	irqbit = s626_debi_read(dev, S626_LP_RDMISC2);
@@ -1279,8 +1279,8 @@ static void s626_reset_adc(struct comedi_device *dev, u8 *ppl)
 	struct comedi_cmd *cmd = &s->async->cmd;
 	uint32_t *rps;
 	uint32_t jmp_adrs;
-	uint16_t i;
-	uint16_t n;
+	u16 i;
+	u16 n;
 	uint32_t local_ppl;
 
 	/* Stop RPS program in case it is currently running */
@@ -1488,9 +1488,9 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 			     struct comedi_insn *insn,
 			     unsigned int *data)
 {
-	uint16_t chan = CR_CHAN(insn->chanspec);
-	uint16_t range = CR_RANGE(insn->chanspec);
-	uint16_t adc_spec = 0;
+	u16 chan = CR_CHAN(insn->chanspec);
+	u16 range = CR_RANGE(insn->chanspec);
+	u16 adc_spec = 0;
 	uint32_t gpio_image;
 	uint32_t tmp;
 	int ret;
@@ -1651,7 +1651,7 @@ static int s626_ns_to_timer(unsigned int *nanosec, unsigned int flags)
 static void s626_timer_load(struct comedi_device *dev,
 			    unsigned int chan, int tick)
 {
-	uint16_t setup =
+	u16 setup =
 		/* Preload upon index. */
 		S626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |
 		/* Disable hardware index. */
@@ -1664,7 +1664,7 @@ static void s626_timer_load(struct comedi_device *dev,
 		S626_SET_STD_CLKMULT(S626_CLKMULT_1X) |
 		/* Enabled by index */
 		S626_SET_STD_CLKENAB(S626_CLKENAB_INDEX);
-	uint16_t value_latchsrc = S626_LATCHSRC_A_INDXA;
+	u16 value_latchsrc = S626_LATCHSRC_A_INDXA;
 	/* uint16_t enab = S626_CLKENAB_ALWAYS; */
 
 	s626_set_mode(dev, chan, setup, false);
@@ -1953,7 +1953,7 @@ static int s626_ao_insn_write(struct comedi_device *dev,
 
 static void s626_dio_init(struct comedi_device *dev)
 {
-	uint16_t group;
+	u16 group;
 
 	/* Prepare to treat writes to WRCapSel as capture disables. */
 	s626_debi_write(dev, S626_LP_MISC1, S626_MISC1_NOEDCAP);
@@ -2017,7 +2017,7 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 				struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	uint16_t setup =
+	u16 setup =
 		/* Preload upon index. */
 		S626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |
 		/* Disable hardware index. */
@@ -2032,8 +2032,8 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 		S626_SET_STD_CLKENAB(S626_CLKENAB_INDEX);
 	/* uint16_t disable_int_src = true; */
 	/* uint32_t Preloadvalue;              //Counter initial value */
-	uint16_t value_latchsrc = S626_LATCHSRC_AB_READ;
-	uint16_t enab = S626_CLKENAB_ALWAYS;
+	u16 value_latchsrc = S626_LATCHSRC_AB_READ;
+	u16 enab = S626_CLKENAB_ALWAYS;
 
 	/* (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
@@ -2052,7 +2052,7 @@ static int s626_enc_insn_read(struct comedi_device *dev,
 			      unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	uint16_t cntr_latch_reg = S626_LP_CNTR(chan);
+	u16 cntr_latch_reg = S626_LP_CNTR(chan);
 	int i;
 
 	for (i = 0; i < insn->n; i++) {
@@ -2090,7 +2090,7 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 	return 1;
 }
 
-static void s626_write_misc2(struct comedi_device *dev, uint16_t new_image)
+static void s626_write_misc2(struct comedi_device *dev, u16 new_image)
 {
 	s626_debi_write(dev, S626_LP_MISC1, S626_MISC1_WENABLE);
 	s626_debi_write(dev, S626_LP_WRMISC2, new_image);
@@ -2100,7 +2100,7 @@ static void s626_write_misc2(struct comedi_device *dev, uint16_t new_image)
 static void s626_counters_init(struct comedi_device *dev)
 {
 	int chan;
-	uint16_t setup =
+	u16 setup =
 		/* Preload upon index. */
 		S626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |
 		/* Disable hardware index. */
@@ -2169,7 +2169,7 @@ static int s626_initialize(struct comedi_device *dev)
 {
 	struct s626_private *devpriv = dev->private;
 	dma_addr_t phys_buf;
-	uint16_t chan;
+	u16 chan;
 	int i;
 	int ret;
 

commit d9f9600b8b1cc166e70519257061ddec4e0d7e39
Author: Saber Rezvani <irsaber@gmail.com>
Date:   Fri Dec 2 01:35:40 2016 +0330

    staging: comedi: s626: use preferred kernel type u8
    
    Fix the checkpatch.pl issue:
    CHECK: Prefer kernel type 'u8' over 'uint8_t'
    
    Signed-off-by: Saber Rezvani <irsaber@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index c14a02564432..59a4aebbfa08 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -75,7 +75,7 @@ struct s626_buffer_dma {
 };
 
 struct s626_private {
-	uint8_t ai_cmd_running;		/* ai_cmd is running */
+	u8 ai_cmd_running;		/* ai_cmd is running */
 	unsigned int ai_sample_timer;	/* time between samples in
 					 * units of the timer */
 	int ai_convert_count;		/* conversion counter */
@@ -83,7 +83,7 @@ struct s626_private {
 					 * units of the timer */
 	uint16_t counter_int_enabs;	/* counter interrupt enable mask
 					 * for MISC2 register */
-	uint8_t adc_items;		/* number of items in ADC poll list */
+	u8 adc_items;		        /* number of items in ADC poll list */
 	struct s626_buffer_dma rps_buf;	/* DMA buffer used to hold ADC (RPS1)
 					 * program */
 	struct s626_buffer_dma ana_buf;	/* DMA buffer used to receive ADC data
@@ -91,7 +91,7 @@ struct s626_private {
 	uint32_t *dac_wbuf;		/* pointer to logical adrs of DMA buffer
 					 * used to hold DAC data */
 	uint16_t dacpol;		/* image of DAC polarity register */
-	uint8_t trim_setpoint[12];	/* images of TrimDAC setpoints */
+	u8 trim_setpoint[12];	        /* images of TrimDAC setpoints */
 	uint32_t i2c_adrs;		/* I2C device address for onboard EEPROM
 					 * (board rev dependent) */
 };
@@ -267,8 +267,8 @@ static int s626_i2c_handshake(struct comedi_device *dev, uint32_t val)
 	return ctrl & S626_I2C_ERR;
 }
 
-/* Read uint8_t from EEPROM. */
-static uint8_t s626_i2c_read(struct comedi_device *dev, uint8_t addr)
+/* Read u8 from EEPROM. */
+static u8 s626_i2c_read(struct comedi_device *dev, u8 addr)
 {
 	struct s626_private *devpriv = dev->private;
 
@@ -304,10 +304,10 @@ static uint8_t s626_i2c_read(struct comedi_device *dev, uint8_t addr)
 /* ***********  DAC FUNCTIONS *********** */
 
 /* TrimDac LogicalChan-to-PhysicalChan mapping table. */
-static const uint8_t s626_trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
+static const u8 s626_trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 
 /* TrimDac LogicalChan-to-EepromAdrs mapping table. */
-static const uint8_t s626_trimadrs[] = {
+static const u8 s626_trimadrs[] = {
 	0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63
 };
 
@@ -582,7 +582,7 @@ static int s626_set_dac(struct comedi_device *dev,
 }
 
 static int s626_write_trim_dac(struct comedi_device *dev,
-			       uint8_t logical_chan, uint8_t dac_data)
+			       u8 logical_chan, u8 dac_data)
 {
 	struct s626_private *devpriv = dev->private;
 	uint32_t chan;
@@ -591,7 +591,7 @@ static int s626_write_trim_dac(struct comedi_device *dev,
 	 * Save the new setpoint in case the application needs to read it back
 	 * later.
 	 */
-	devpriv->trim_setpoint[logical_chan] = (uint8_t)dac_data;
+	devpriv->trim_setpoint[logical_chan] = (u8)dac_data;
 
 	/* Map logical channel number to physical channel number. */
 	chan = s626_trimchan[logical_chan];
@@ -633,7 +633,7 @@ static int s626_write_trim_dac(struct comedi_device *dev,
 
 static int s626_load_trim_dacs(struct comedi_device *dev)
 {
-	uint8_t i;
+	u8 i;
 	int ret;
 
 	/* Copy TrimDac setpoint values from EEPROM to TrimDacs. */
@@ -1062,7 +1062,7 @@ static int s626_dio_clear_irq(struct comedi_device *dev)
 }
 
 static void s626_handle_dio_interrupt(struct comedi_device *dev,
-				      uint16_t irqbit, uint8_t group)
+				      uint16_t irqbit, u8 group)
 {
 	struct s626_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
@@ -1111,7 +1111,7 @@ static void s626_handle_dio_interrupt(struct comedi_device *dev,
 static void s626_check_dio_interrupts(struct comedi_device *dev)
 {
 	uint16_t irqbit;
-	uint8_t group;
+	u8 group;
 
 	for (group = 0; group < S626_DIO_BANKS; group++) {
 		/* read interrupt type */
@@ -1272,7 +1272,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 /*
  * This function builds the RPS program for hardware driven acquisition.
  */
-static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
+static void s626_reset_adc(struct comedi_device *dev, u8 *ppl)
 {
 	struct s626_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
@@ -1585,7 +1585,7 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	return n;
 }
 
-static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)
+static int s626_ai_load_polllist(u8 *ppl, struct comedi_cmd *cmd)
 {
 	int n;
 
@@ -1693,7 +1693,7 @@ static void s626_timer_load(struct comedi_device *dev,
 static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct s626_private *devpriv = dev->private;
-	uint8_t ppl[16];
+	u8 ppl[16];
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int tick;
 

commit 521865a8c9a8d4a189355339457d96b62699eb35
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Fri Sep 16 02:09:08 2016 +0530

    Staging: comedi: s626: Remove all unused functions
    
    Remove all #ifdef'ed static functions as they are not used anywhere
    in the kernel. Some functions were detected using Coccinelle but removed by
    hand and some were removed as the functions in which they were getting
    used were also unused functions.
    Script:
    
    @initialize:python@
    @@
    def display(name,p):
            print(name,p[0].file)
    
    @r1@
    identifier func;
    type T;
    position p;
    @@
    static T func@p(...)
    {
    ...
    }
    
    @r@
    identifier r1.func;
    @@
    func
    
    @script:python depends on !r@
    func << r1.func;
    p << r1.p;
    @@
    display(func,p)
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6d89ca0b9cfc..c14a02564432 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -697,134 +697,6 @@ static void s626_reset_cap_flags(struct comedi_device *dev,
 	s626_debi_replace(dev, S626_LP_CRB(chan), ~S626_CRBMSK_INTCTRL, set);
 }
 
-#ifdef unused
-/*
- * Return counter setup in a format (COUNTER_SETUP) that is consistent
- * for both A and B counters.
- */
-static uint16_t s626_get_mode_a(struct comedi_device *dev,
-				unsigned int chan)
-{
-	uint16_t cra;
-	uint16_t crb;
-	uint16_t setup;
-	unsigned int cntsrc, clkmult, clkpol, encmode;
-
-	/* Fetch CRA and CRB register images. */
-	cra = s626_debi_read(dev, S626_LP_CRA(chan));
-	crb = s626_debi_read(dev, S626_LP_CRB(chan));
-
-	/*
-	 * Populate the standardized counter setup bit fields.
-	 */
-	setup =
-		/* LoadSrc  = LoadSrcA. */
-		S626_SET_STD_LOADSRC(S626_GET_CRA_LOADSRC_A(cra)) |
-		/* LatchSrc = LatchSrcA. */
-		S626_SET_STD_LATCHSRC(S626_GET_CRB_LATCHSRC(crb)) |
-		/* IntSrc   = IntSrcA. */
-		S626_SET_STD_INTSRC(S626_GET_CRA_INTSRC_A(cra)) |
-		/* IndxSrc  = IndxSrcA. */
-		S626_SET_STD_INDXSRC(S626_GET_CRA_INDXSRC_A(cra)) |
-		/* IndxPol  = IndxPolA. */
-		S626_SET_STD_INDXPOL(S626_GET_CRA_INDXPOL_A(cra)) |
-		/* ClkEnab  = ClkEnabA. */
-		S626_SET_STD_CLKENAB(S626_GET_CRB_CLKENAB_A(crb));
-
-	/* Adjust mode-dependent parameters. */
-	cntsrc = S626_GET_CRA_CNTSRC_A(cra);
-	if (cntsrc & S626_CNTSRC_SYSCLK) {
-		/* Timer mode (CntSrcA<1> == 1): */
-		encmode = S626_ENCMODE_TIMER;
-		/* Set ClkPol to indicate count direction (CntSrcA<0>). */
-		clkpol = cntsrc & 1;
-		/* ClkMult must be 1x in Timer mode. */
-		clkmult = S626_CLKMULT_1X;
-	} else {
-		/* Counter mode (CntSrcA<1> == 0): */
-		encmode = S626_ENCMODE_COUNTER;
-		/* Pass through ClkPol. */
-		clkpol = S626_GET_CRA_CLKPOL_A(cra);
-		/* Force ClkMult to 1x if not legal, else pass through. */
-		clkmult = S626_GET_CRA_CLKMULT_A(cra);
-		if (clkmult == S626_CLKMULT_SPECIAL)
-			clkmult = S626_CLKMULT_1X;
-	}
-	setup |= S626_SET_STD_ENCMODE(encmode) | S626_SET_STD_CLKMULT(clkmult) |
-		 S626_SET_STD_CLKPOL(clkpol);
-
-	/* Return adjusted counter setup. */
-	return setup;
-}
-
-static uint16_t s626_get_mode_b(struct comedi_device *dev,
-				unsigned int chan)
-{
-	uint16_t cra;
-	uint16_t crb;
-	uint16_t setup;
-	unsigned int cntsrc, clkmult, clkpol, encmode;
-
-	/* Fetch CRA and CRB register images. */
-	cra = s626_debi_read(dev, S626_LP_CRA(chan));
-	crb = s626_debi_read(dev, S626_LP_CRB(chan));
-
-	/*
-	 * Populate the standardized counter setup bit fields.
-	 */
-	setup =
-		/* IntSrc   = IntSrcB. */
-		S626_SET_STD_INTSRC(S626_GET_CRB_INTSRC_B(crb)) |
-		/* LatchSrc = LatchSrcB. */
-		S626_SET_STD_LATCHSRC(S626_GET_CRB_LATCHSRC(crb)) |
-		/* LoadSrc  = LoadSrcB. */
-		S626_SET_STD_LOADSRC(S626_GET_CRB_LOADSRC_B(crb)) |
-		/* IndxPol  = IndxPolB. */
-		S626_SET_STD_INDXPOL(S626_GET_CRB_INDXPOL_B(crb)) |
-		/* ClkEnab  = ClkEnabB. */
-		S626_SET_STD_CLKENAB(S626_GET_CRB_CLKENAB_B(crb)) |
-		/* IndxSrc  = IndxSrcB. */
-		S626_SET_STD_INDXSRC(S626_GET_CRA_INDXSRC_B(cra));
-
-	/* Adjust mode-dependent parameters. */
-	cntsrc = S626_GET_CRA_CNTSRC_B(cra);
-	clkmult = S626_GET_CRB_CLKMULT_B(crb);
-	if (clkmult == S626_CLKMULT_SPECIAL) {
-		/* Extender mode (ClkMultB == S626_CLKMULT_SPECIAL): */
-		encmode = S626_ENCMODE_EXTENDER;
-		/* Indicate multiplier is 1x. */
-		clkmult = S626_CLKMULT_1X;
-		/* Set ClkPol equal to Timer count direction (CntSrcB<0>). */
-		clkpol = cntsrc & 1;
-	} else if (cntsrc & S626_CNTSRC_SYSCLK) {
-		/* Timer mode (CntSrcB<1> == 1): */
-		encmode = S626_ENCMODE_TIMER;
-		/* Indicate multiplier is 1x. */
-		clkmult = S626_CLKMULT_1X;
-		/* Set ClkPol equal to Timer count direction (CntSrcB<0>). */
-		clkpol = cntsrc & 1;
-	} else {
-		/* If Counter mode (CntSrcB<1> == 0): */
-		encmode = S626_ENCMODE_COUNTER;
-		/* Clock multiplier is passed through. */
-		/* Clock polarity is passed through. */
-		clkpol = S626_GET_CRB_CLKPOL_B(crb);
-	}
-	setup |= S626_SET_STD_ENCMODE(encmode) | S626_SET_STD_CLKMULT(clkmult) |
-		 S626_SET_STD_CLKPOL(clkpol);
-
-	/* Return adjusted counter setup. */
-	return setup;
-}
-
-static uint16_t s626_get_mode(struct comedi_device *dev,
-			      unsigned int chan)
-{
-	return (chan < 3) ? s626_get_mode_a(dev, chan)
-			  : s626_get_mode_b(dev, chan);
-}
-#endif
-
 /*
  * Set the operating mode for the specified counter.  The setup
  * parameter is treated as a COUNTER_SETUP data type.  The following
@@ -1023,25 +895,6 @@ static void s626_set_enable(struct comedi_device *dev,
 	s626_debi_replace(dev, S626_LP_CRB(chan), ~mask, set);
 }
 
-#ifdef unused
-static uint16_t s626_get_enable(struct comedi_device *dev,
-				unsigned int chan)
-{
-	uint16_t crb = s626_debi_read(dev, S626_LP_CRB(chan));
-
-	return (chan < 3) ? S626_GET_CRB_CLKENAB_A(crb)
-			  : S626_GET_CRB_CLKENAB_B(crb);
-}
-#endif
-
-#ifdef unused
-static uint16_t s626_get_latch_source(struct comedi_device *dev,
-				      unsigned int chan)
-{
-	return S626_GET_CRB_LATCHSRC(s626_debi_read(dev, S626_LP_CRB(chan)));
-}
-#endif
-
 /*
  * Return/set the event that will trigger transfer of the preload
  * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
@@ -1066,19 +919,6 @@ static void s626_set_load_trig(struct comedi_device *dev,
 	s626_debi_replace(dev, reg, ~mask, set);
 }
 
-#ifdef unused
-static uint16_t s626_get_load_trig(struct comedi_device *dev,
-				   unsigned int chan)
-{
-	if (chan < 3)
-		return S626_GET_CRA_LOADSRC_A(s626_debi_read(dev,
-							S626_LP_CRA(chan)));
-	else
-		return S626_GET_CRB_LOADSRC_B(s626_debi_read(dev,
-							S626_LP_CRB(chan)));
-}
-#endif
-
 /*
  * Return/set counter interrupt source and clear any captured
  * index/overflow events.  int_source: 0=Disabled, 1=OverflowOnly,
@@ -1138,93 +978,6 @@ static void s626_set_int_src(struct comedi_device *dev,
 	}
 }
 
-#ifdef unused
-static uint16_t s626_get_int_src(struct comedi_device *dev,
-				 unsigned int chan)
-{
-	if (chan < 3)
-		return S626_GET_CRA_INTSRC_A(s626_debi_read(dev,
-							S626_LP_CRA(chan)));
-	else
-		return S626_GET_CRB_INTSRC_B(s626_debi_read(dev,
-							S626_LP_CRB(chan)));
-}
-#endif
-
-#ifdef unused
-/*
- * Return/set the clock multiplier.
- */
-static void s626_set_clk_mult(struct comedi_device *dev,
-			      unsigned int chan, uint16_t value)
-{
-	uint16_t mode;
-
-	mode = s626_get_mode(dev, chan);
-	mode &= ~S626_STDMSK_CLKMULT;
-	mode |= S626_SET_STD_CLKMULT(value);
-
-	s626_set_mode(dev, chan, mode, false);
-}
-
-/*
- * Return/set the clock polarity.
- */
-static void s626_set_clk_pol(struct comedi_device *dev,
-			     unsigned int chan, uint16_t value)
-{
-	uint16_t mode;
-
-	mode = s626_get_mode(dev, chan);
-	mode &= ~S626_STDMSK_CLKPOL;
-	mode |= S626_SET_STD_CLKPOL(value);
-
-	s626_set_mode(dev, chan, mode, false);
-}
-
-/*
- * Return/set the encoder mode.
- */
-static void s626_set_enc_mode(struct comedi_device *dev,
-			      unsigned int chan, uint16_t value)
-{
-	uint16_t mode;
-
-	mode = s626_get_mode(dev, chan);
-	mode &= ~S626_STDMSK_ENCMODE;
-	mode |= S626_SET_STD_ENCMODE(value);
-
-	s626_set_mode(dev, chan, mode, false);
-}
-
-static uint16_t s626_get_index_pol(struct comedi_device *dev,
-				   unsigned int chan)
-{
-	return S626_GET_STD_INDXPOL(s626_get_mode(dev, chan));
-}
-
-/*
- * Return/set the index source.
- */
-static void s626_set_index_src(struct comedi_device *dev,
-			       unsigned int chan, uint16_t value)
-{
-	uint16_t mode;
-
-	mode = s626_get_mode(dev, chan);
-	mode &= ~S626_STDMSK_INDXSRC;
-	mode |= S626_SET_STD_INDXSRC(value != 0);
-
-	s626_set_mode(dev, chan, mode, false);
-}
-
-static uint16_t s626_get_index_src(struct comedi_device *dev,
-				   unsigned int chan)
-{
-	return S626_GET_STD_INDXSRC(s626_get_mode(dev, chan));
-}
-#endif
-
 /*
  * Generate an index pulse.
  */
@@ -1717,43 +1470,6 @@ static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
 	/* End of RPS program build */
 }
 
-#ifdef unused_code
-static int s626_ai_rinsn(struct comedi_device *dev,
-			 struct comedi_subdevice *s,
-			 struct comedi_insn *insn,
-			 unsigned int *data)
-{
-	struct s626_private *devpriv = dev->private;
-	uint8_t i;
-	int32_t *readaddr;
-
-	/* Trigger ADC scan loop start */
-	s626_mc_enable(dev, S626_MC2_ADC_RPS, S626_P_MC2);
-
-	/* Wait until ADC scan loop is finished (RPS Signal 0 reset) */
-	while (s626_mc_test(dev, S626_MC2_ADC_RPS, S626_P_MC2))
-		;
-
-	/*
-	 * Init ptr to DMA buffer that holds new ADC data.  We skip the
-	 * first uint16_t in the buffer because it contains junk data from
-	 * the final ADC of the previous poll list scan.
-	 */
-	readaddr = (uint32_t *)devpriv->ana_buf.logical_base + 1;
-
-	/*
-	 * Convert ADC data to 16-bit integer values and
-	 * copy to application buffer.
-	 */
-	for (i = 0; i < devpriv->adc_items; i++) {
-		*data = s626_ai_reg_to_uint(*readaddr++);
-		data++;
-	}
-
-	return i;
-}
-#endif
-
 static int s626_ai_eoc(struct comedi_device *dev,
 		       struct comedi_subdevice *s,
 		       struct comedi_insn *insn,

commit 2061d410616785e68c3f53d48f3df3ad7564d2cb
Author: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
Date:   Tue Jun 21 12:14:44 2016 +0530

    Staging: comedi: s626: fix line over 80 characters issue
    
    This fixes up a line over 80 characters issues found by
    the checkpatch.pl tool.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4a87b4b52400..6d89ca0b9cfc 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2500,7 +2500,8 @@ static int s626_initialize(struct comedi_device *dev)
 	for (i = 0; i < 2; i++) {
 		writel(S626_I2C_CLKSEL, dev->mmio + S626_P_I2CSTAT);
 		s626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);
-		ret = comedi_timeout(dev, NULL, NULL, s626_i2c_handshake_eoc, 0);
+		ret = comedi_timeout(dev, NULL,
+				     NULL, s626_i2c_handshake_eoc, 0);
 		if (ret)
 			return ret;
 	}

commit f7ede00d609d24dae6ef47d294630e81b8ce3091
Author: Nikita Eshkeev <kastolom@gmail.com>
Date:   Tue May 3 18:22:23 2016 +0300

    staging:comedi:Use unsigned int instead of unsigned
    
    This patch fixed the checkpatch.pl warning:
    
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Signed-off-by: Nikita Eshkeev <kastolom@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index c5e08635e01e..4a87b4b52400 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -708,7 +708,7 @@ static uint16_t s626_get_mode_a(struct comedi_device *dev,
 	uint16_t cra;
 	uint16_t crb;
 	uint16_t setup;
-	unsigned cntsrc, clkmult, clkpol, encmode;
+	unsigned int cntsrc, clkmult, clkpol, encmode;
 
 	/* Fetch CRA and CRB register images. */
 	cra = s626_debi_read(dev, S626_LP_CRA(chan));
@@ -763,7 +763,7 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 	uint16_t cra;
 	uint16_t crb;
 	uint16_t setup;
-	unsigned cntsrc, clkmult, clkpol, encmode;
+	unsigned int cntsrc, clkmult, clkpol, encmode;
 
 	/* Fetch CRA and CRB register images. */
 	cra = s626_debi_read(dev, S626_LP_CRA(chan));
@@ -838,7 +838,7 @@ static void s626_set_mode_a(struct comedi_device *dev,
 	struct s626_private *devpriv = dev->private;
 	uint16_t cra;
 	uint16_t crb;
-	unsigned cntsrc, clkmult, clkpol;
+	unsigned int cntsrc, clkmult, clkpol;
 
 	/* Initialize CRA and CRB images. */
 	/* Preload trigger is passed through. */
@@ -916,7 +916,7 @@ static void s626_set_mode_b(struct comedi_device *dev,
 	struct s626_private *devpriv = dev->private;
 	uint16_t cra;
 	uint16_t crb;
-	unsigned cntsrc, clkmult, clkpol;
+	unsigned int cntsrc, clkmult, clkpol;
 
 	/* Initialize CRA and CRB images. */
 	/* IndexSrc is passed through. */

commit dda68765d757c7da878b093a87f24d6a1d4cfb64
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sun Feb 28 13:28:47 2016 +0530

    Staging: comedi: s626.c: Remove unused functions
    
    The functions s626_get_clk_mult, s626_get_clk_mult, s626_get_enc_mode,
    s626_set_index_pol are not used anywhere in the kernel so they can be
    removed. This also cleans the code. Grepped to find the occurences.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 35f0f676eb28..c5e08635e01e 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1167,12 +1167,6 @@ static void s626_set_clk_mult(struct comedi_device *dev,
 	s626_set_mode(dev, chan, mode, false);
 }
 
-static uint16_t s626_get_clk_mult(struct comedi_device *dev,
-				  unsigned int chan)
-{
-	return S626_GET_STD_CLKMULT(s626_get_mode(dev, chan));
-}
-
 /*
  * Return/set the clock polarity.
  */
@@ -1188,12 +1182,6 @@ static void s626_set_clk_pol(struct comedi_device *dev,
 	s626_set_mode(dev, chan, mode, false);
 }
 
-static uint16_t s626_get_clk_pol(struct comedi_device *dev,
-				 unsigned int chan)
-{
-	return S626_GET_STD_CLKPOL(s626_get_mode(dev, chan));
-}
-
 /*
  * Return/set the encoder mode.
  */
@@ -1209,27 +1197,6 @@ static void s626_set_enc_mode(struct comedi_device *dev,
 	s626_set_mode(dev, chan, mode, false);
 }
 
-static uint16_t s626_get_enc_mode(struct comedi_device *dev,
-				  unsigned int chan)
-{
-	return S626_GET_STD_ENCMODE(s626_get_mode(dev, chan));
-}
-
-/*
- * Return/set the index polarity.
- */
-static void s626_set_index_pol(struct comedi_device *dev,
-			       unsigned int chan, uint16_t value)
-{
-	uint16_t mode;
-
-	mode = s626_get_mode(dev, chan);
-	mode &= ~S626_STDMSK_INDXPOL;
-	mode |= S626_SET_STD_INDXPOL(value != 0);
-
-	s626_set_mode(dev, chan, mode, false);
-}
-
 static uint16_t s626_get_index_pol(struct comedi_device *dev,
 				   unsigned int chan)
 {

commit 71b9f42eac9722d8dc39a5b2771255e2a6214eee
Author: Abdul Hussain <habdul@visteon.com>
Date:   Mon Jun 22 06:11:13 2015 +0000

    Staging: comedi: s626: Simplify a trivial if-return sequence
    
    This patch simplify a trivial if-return sequence. Possibly combine with
    a preceding function call.
    
    Signed-off-by: Abdul Hussain <habdul@visteon.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 781918d8d85f..35f0f676eb28 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2852,11 +2852,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->insn_read	= s626_enc_insn_read;
 	s->insn_write	= s626_enc_insn_write;
 
-	ret = s626_initialize(dev);
-	if (ret)
-		return ret;
-
-	return 0;
+	return s626_initialize(dev);
 }
 
 static void s626_detach(struct comedi_device *dev)

commit d044e28f38dcc5b9de460eb0ce8a68df5cc2707b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:36 2015 +0000

    staging: comedi: s626: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 53a248bc9d80..781918d8d85f 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -67,7 +67,6 @@
 
 #include "../comedi_pci.h"
 
-#include "comedi_fc.h"
 #include "s626.h"
 
 struct s626_buffer_dma {
@@ -2115,24 +2114,24 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src,
-				     TRIG_NOW | TRIG_INT | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
-				     TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW);
-	err |= cfc_check_trigger_src(&cmd->convert_src,
-				     TRIG_TIMER | TRIG_EXT | TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src,
+					TRIG_NOW | TRIG_INT | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW);
+	err |= comedi_check_trigger_src(&cmd->convert_src,
+					TRIG_TIMER | TRIG_EXT | TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -2144,49 +2143,53 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 	switch (cmd->start_src) {
 	case TRIG_NOW:
 	case TRIG_INT:
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 		break;
 	case TRIG_EXT:
-		err |= cfc_check_trigger_arg_max(&cmd->start_arg, 39);
+		err |= comedi_check_trigger_arg_max(&cmd->start_arg, 39);
 		break;
 	}
 
 	if (cmd->scan_begin_src == TRIG_EXT)
-		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 39);
+		err |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg, 39);
 	if (cmd->convert_src == TRIG_EXT)
-		err |= cfc_check_trigger_arg_max(&cmd->convert_arg, 39);
+		err |= comedi_check_trigger_arg_max(&cmd->convert_arg, 39);
 
 #define S626_MAX_SPEED	200000	/* in nanoseconds */
 #define S626_MIN_SPEED	2000000000	/* in nanoseconds */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 S626_MAX_SPEED);
-		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
-						 S626_MIN_SPEED);
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    S626_MAX_SPEED);
+		err |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,
+						    S626_MIN_SPEED);
 	} else {
-		/* external trigger */
-		/* should be level/edge, hi/lo specification here */
-		/* should specify multiple external triggers */
-		/* err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 9); */
+		/*
+		 * external trigger
+		 * should be level/edge, hi/lo specification here
+		 * should specify multiple external triggers
+		 * err |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg, 9);
+		 */
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 S626_MAX_SPEED);
-		err |= cfc_check_trigger_arg_max(&cmd->convert_arg,
-						 S626_MIN_SPEED);
+		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
+						    S626_MAX_SPEED);
+		err |= comedi_check_trigger_arg_max(&cmd->convert_arg,
+						    S626_MIN_SPEED);
 	} else {
-		/* external trigger */
-		/* see above */
-		/* err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 9); */
+		/*
+		 * external trigger - see above
+		 * err |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg, 9);
+		 */
 	}
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -2196,18 +2199,19 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		arg = cmd->scan_begin_arg;
 		s626_ns_to_timer(&arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		arg = cmd->convert_arg;
 		s626_ns_to_timer(&arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
 
 		if (cmd->scan_begin_src == TRIG_TIMER) {
 			arg = cmd->convert_arg * cmd->scan_end_arg;
-			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-							 arg);
+			err |= comedi_check_trigger_arg_min(&cmd->
+							    scan_begin_arg,
+							    arg);
 		}
 	}
 

commit 6ab38b050fa69092aa1de0106800571ae2b753fa
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 10 16:11:14 2015 +0000

    staging: comedi: s626: include new "comedi_pci.h" header
    
    Include the new "../comedi_pci.h" header instead of <linux/pci.h> and
    "../comedidev.h", which will now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 3b9ef9a6918b..53a248bc9d80 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -61,12 +61,11 @@
 
 #include <linux/module.h>
 #include <linux/delay.h>
-#include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
 
-#include "../comedidev.h"
+#include "../comedi_pci.h"
 
 #include "comedi_fc.h"
 #include "s626.h"

commit 6c7d2c8b5230272b394d51462c8cae46df09f126
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:16 2015 -0700

    staging: comedi: drivers/*.c: alignment should match open parenthesis
    
    Fix the alignment issues in all the comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 422ea9c73706..3b9ef9a6918b 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -231,9 +231,9 @@ static void s626_debi_replace(struct comedi_device *dev, unsigned int addr,
 /* **************  EEPROM ACCESS FUNCTIONS  ************** */
 
 static int s626_i2c_handshake_eoc(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn,
-				 unsigned long context)
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn,
+				  unsigned long context)
 {
 	bool status;
 
@@ -294,7 +294,7 @@ static uint8_t s626_i2c_read(struct comedi_device *dev, uint8_t addr)
 	 *  Byte0 = Not sent.
 	 */
 	if (s626_i2c_handshake(dev, S626_I2C_B2(S626_I2C_ATTRSTART,
-					   (devpriv->i2c_adrs | 1)) |
+						(devpriv->i2c_adrs | 1)) |
 				    S626_I2C_B1(S626_I2C_ATTRSTOP, 0) |
 				    S626_I2C_B0(S626_I2C_ATTRNOP, 0)))
 		/* Abort function and declare error if handshake failed. */
@@ -517,8 +517,8 @@ static int s626_send_dac(struct comedi_device *dev, uint32_t val)
 /*
  * Private helper function: Write setpoint to an application DAC channel.
  */
-static int s626_set_dac(struct comedi_device *dev, uint16_t chan,
-			 int16_t dacdata)
+static int s626_set_dac(struct comedi_device *dev,
+			uint16_t chan, int16_t dacdata)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t signmask;
@@ -583,8 +583,8 @@ static int s626_set_dac(struct comedi_device *dev, uint16_t chan,
 	return s626_send_dac(dev, val);
 }
 
-static int s626_write_trim_dac(struct comedi_device *dev, uint8_t logical_chan,
-				uint8_t dac_data)
+static int s626_write_trim_dac(struct comedi_device *dev,
+			       uint8_t logical_chan, uint8_t dac_data)
 {
 	struct s626_private *devpriv = dev->private;
 	uint32_t chan;
@@ -641,7 +641,7 @@ static int s626_load_trim_dacs(struct comedi_device *dev)
 	/* Copy TrimDac setpoint values from EEPROM to TrimDacs. */
 	for (i = 0; i < ARRAY_SIZE(s626_trimchan); i++) {
 		ret = s626_write_trim_dac(dev, i,
-				    s626_i2c_read(dev, s626_trimadrs[i]));
+					  s626_i2c_read(dev, s626_trimadrs[i]));
 		if (ret)
 			return ret;
 	}
@@ -2729,7 +2729,7 @@ static int s626_initialize(struct comedi_device *dev)
 }
 
 static int s626_auto_attach(struct comedi_device *dev,
-				      unsigned long context_unused)
+			    unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct s626_private *devpriv;

commit 857ced45a548c3f8196d6e45079678ab3c9f3581
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 4 12:15:42 2015 -0700

    staging: comedi: s626: remove unnecessary 'cmd' pointer checks
    
    The local variable 'cmd' is a pointer to the address of a member variable
    of a struct. It will always be valid. Remove the unnecessary checks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index fc497dd92021..422ea9c73706 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1576,7 +1576,7 @@ static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
 	       dev->mmio + S626_P_RPSADDR1);
 
 	/* Construct RPS program in rps_buf DMA buffer */
-	if (cmd != NULL && cmd->scan_begin_src != TRIG_FOLLOW) {
+	if (cmd->scan_begin_src != TRIG_FOLLOW) {
 		/* Wait for Start trigger. */
 		*rps++ = S626_RPS_PAUSE | S626_RPS_SIGADC;
 		*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_SIGADC;
@@ -1665,7 +1665,7 @@ static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
 			*rps++ = jmp_adrs;
 		}
 
-		if (cmd != NULL && cmd->convert_src != TRIG_NOW) {
+		if (cmd->convert_src != TRIG_NOW) {
 			/* Wait for Start trigger. */
 			*rps++ = S626_RPS_PAUSE | S626_RPS_SIGADC;
 			*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_SIGADC;
@@ -2034,10 +2034,6 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* reset ai_cmd_running flag */
 	devpriv->ai_cmd_running = 0;
 
-	/* test if cmd is valid */
-	if (cmd == NULL)
-		return -EINVAL;
-
 	s626_ai_load_polllist(ppl, cmd);
 	devpriv->ai_cmd_running = 1;
 	devpriv->ai_convert_count = 0;

commit ddd54d6518ea613d0d73326daf5eb7c950d303dc
Author: drumber-1 <drumber01@gmail.com>
Date:   Wed Dec 3 13:33:57 2014 +0000

    Staging: comedi: fix spacing coding style issue in s626.c
    
     This is a patch to the s626.c file that fixes a spacing error found by the checkpatch.pl tool
     Signed-off-by: Jacob L Close <drumber01@gmail.com>
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 14932c5f3798..fc497dd92021 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -118,7 +118,7 @@ static void s626_mc_enable(struct comedi_device *dev,
 static void s626_mc_disable(struct comedi_device *dev,
 			    unsigned int cmd, unsigned int reg)
 {
-	writel(cmd << 16 , dev->mmio + reg);
+	writel(cmd << 16, dev->mmio + reg);
 	mmiowb();
 }
 

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index fc7d8a572bf3..14932c5f3798 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2801,7 +2801,6 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->maxdata	= 0x3fff;
 	s->range_table	= &range_bipolar10;
 	s->insn_write	= s626_ao_insn_write;
-	s->insn_read	= comedi_readback_insn_read;
 
 	ret = comedi_alloc_subdev_readback(s);
 	if (ret)

commit aee15aea0d8e879ec22142491611d98ab987d2ba
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:21:03 2014 -0700

    staging: comedi: s626: use comedi_async 'scans_done' to detect EOA
    
    Remove the private data member 'ai_sample_count' and use the comedi_async
    'scans_done' member to detect the end-of-acquisition.
    
    Also, remove the unnecessary COMEDI_CB_EOS event. The core automatically
    detects and adds that event.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6976bb098f54..fc7d8a572bf3 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -78,7 +78,6 @@ struct s626_buffer_dma {
 
 struct s626_private {
 	uint8_t ai_cmd_running;		/* ai_cmd is running */
-	int ai_sample_count;		/* number of samples to acquire */
 	unsigned int ai_sample_timer;	/* time between samples in
 					 * units of the timer */
 	int ai_convert_count;		/* conversion counter */
@@ -1496,16 +1495,11 @@ static bool s626_handle_eos_interrupt(struct comedi_device *dev)
 		comedi_buf_write_samples(s, &tempdata, 1);
 	}
 
-	/* end of scan occurs */
-	async->events |= COMEDI_CB_EOS;
+	if (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)
+		async->events |= COMEDI_CB_EOA;
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		devpriv->ai_sample_count--;
-		if (devpriv->ai_sample_count <= 0) {
-			devpriv->ai_cmd_running = 0;
-			async->events |= COMEDI_CB_EOA;
-		}
-	}
+	if (async->events & COMEDI_CB_CANCEL_MASK)
+		devpriv->ai_cmd_running = 0;
 
 	if (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT)
 		s626_dio_set_irq(dev, cmd->scan_begin_arg);
@@ -2091,8 +2085,6 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	}
 
-	devpriv->ai_sample_count = cmd->stop_arg;
-
 	s626_reset_adc(dev, ppl);
 
 	switch (cmd->start_src) {

commit 0e017a4bbee454df42d1fc983c3c9eea0981fb30
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:29 2014 -0700

    staging: comedi: s626: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() instead of cfc_write_to_buffer() to add the
    single sample to the async buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index efd438f0ca62..6976bb098f54 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1493,8 +1493,7 @@ static bool s626_handle_eos_interrupt(struct comedi_device *dev)
 		tempdata = s626_ai_reg_to_uint(*readaddr);
 		readaddr++;
 
-		/* put data into read buffer */
-		cfc_write_to_buffer(s, tempdata);
+		comedi_buf_write_samples(s, &tempdata, 1);
 	}
 
 	/* end of scan occurs */

commit 365dae93f72fdb281cf04cc43b93d4e044f3c70d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:35:39 2014 -0700

    staging: comedi: s626: use comedi_handle_events()
    
    Use comedi_handle_events() to automatically (*cancel) the async command
    for an end-of-acquisition or if an error/overflow occurs.
    
    The s626_mc_disable() call when the end-of-acquisition is detected can
    then be removed. The (*cancel) does the same thing.
    
    For aesthetics, also remove the 'finished' local variable and just return
    the ai_cmd_running state.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 11a12d787e4c..efd438f0ca62 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1480,7 +1480,6 @@ static bool s626_handle_eos_interrupt(struct comedi_device *dev)
 	 * from the final ADC of the previous poll list scan.
 	 */
 	uint32_t *readaddr = (uint32_t *)devpriv->ana_buf.logical_base + 1;
-	bool finished = false;
 	int i;
 
 	/* get the data and hand it over to comedi */
@@ -1505,25 +1504,16 @@ static bool s626_handle_eos_interrupt(struct comedi_device *dev)
 		devpriv->ai_sample_count--;
 		if (devpriv->ai_sample_count <= 0) {
 			devpriv->ai_cmd_running = 0;
-
-			/* Stop RPS program */
-			s626_mc_disable(dev, S626_MC1_ERPS1, S626_P_MC1);
-
-			/* send end of acquisition */
 			async->events |= COMEDI_CB_EOA;
-
-			/* disable master interrupt */
-			finished = true;
 		}
 	}
 
 	if (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT)
 		s626_dio_set_irq(dev, cmd->scan_begin_arg);
 
-	/* tell comedi that data is there */
-	comedi_event(dev, s);
+	comedi_handle_events(dev, s);
 
-	return finished;
+	return !devpriv->ai_cmd_running;
 }
 
 static irqreturn_t s626_irq_handler(int irq, void *d)

commit d9798aa6c33b4da68d9f798e71dca138c9501f74
Author: Tapasweni Pathak <tapaswenipathak@gmail.com>
Date:   Wed Oct 8 23:13:47 2014 +0530

    staging: comedi: drivers: Use DIV_ROUND_CLOSEST
    
    The kernel.h macro DIV_ROUND_CLOSEST performs the computation (x + d/2)/d
    but is perhaps more readable.
    
    The Coccinelle script used:
    // <smpl>
    @haskernel@
    @@
    @depends on haskernel@
    expression x,__divisor;
    @@
    - (((x) + ((__divisor) / 2)) / (__divisor))
    + DIV_ROUND_CLOSEST(x,__divisor)
    // </smpl>
    
    Signed-off-by: Tapasweni Pathak <tapaswenipathak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index bc0745058057..11a12d787e4c 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1970,7 +1970,7 @@ static int s626_ns_to_timer(unsigned int *nanosec, unsigned int flags)
 	switch (flags & CMDF_ROUND_MASK) {
 	case CMDF_ROUND_NEAREST:
 	default:
-		divider = (*nanosec + base / 2) / base;
+		divider = DIV_ROUND_CLOSEST(*nanosec, base);
 		break;
 	case CMDF_ROUND_DOWN:
 		divider = (*nanosec) / base;

commit 97996da1787d55cda95fd4209a4affbef9346c53
Author: Tapasweni Pathak <tapaswenipathak@gmail.com>
Date:   Wed Oct 8 22:56:01 2014 +0530

    staging: comedi: drivers: use DIV_ROUND_UP
    
    The kernel.h macro DIV_ROUND_UP performs the computation (((n) + (d) - 1) /
    (d)) but is perhaps more readable.
    
    Coccinelle script used :
    
    // <smpl>
    @haskernel@
    @@
    @depends on haskernel@
    expression n,d;
    @@
    (
    - (n + d - 1) / d
    + DIV_ROUND_UP(n,d)
    |
    - (n + (d - 1)) / d
    + DIV_ROUND_UP(n,d)
    )
    @depends on haskernel@
    expression n,d;
    @@
    - DIV_ROUND_UP((n),d)
    + DIV_ROUND_UP(n,d)
    @depends on haskernel@
    expression n,d;
    @@
    - DIV_ROUND_UP(n,(d))
    + DIV_ROUND_UP(n,d)
    // </smpl>
    
    Signed-off-by: Tapasweni Pathak <tapaswenipathak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 0e7621e890c3..bc0745058057 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1976,7 +1976,7 @@ static int s626_ns_to_timer(unsigned int *nanosec, unsigned int flags)
 		divider = (*nanosec) / base;
 		break;
 	case CMDF_ROUND_UP:
-		divider = (*nanosec + base - 1) / base;
+		divider = DIV_ROUND_UP(*nanosec, base);
 		break;
 	}
 

commit 32f9ff7039eb59eaef0c153328601ac6164b746a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:16:04 2014 -0700

    staging: comedi: s626: fix cmd->stop_arg validation for stop_src == TRIG_COUNT
    
    The only limit for the stop_arg with a stop_src == TRIG_COUNT is that there is at
    least 1 scan in order to prevent an empty acquisition. The max test is bogus.
    
    Fix the validation.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index a474670b6693..0e7621e890c3 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2208,7 +2208,7 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 

commit 8b9505527e5560297be00094fb4819b0e91e4138
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:16:03 2014 -0700

    staging: comedi: s626: 'ai_sample_count' is always 'stop_arg'
    
    When the cmd->stop_src == TRIG_COUNT, the 'ai_sample_count' is the cmd->stop_arg.
    For a stop_src == TRIG_NONE the 'ai_sample_count' is currently set to 1 but the
    driver never actually uses the value.
    
    Simplify the 'stop_count' initialization by just setting it to the cmd->stop_arg.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 8b4823ece682..a474670b6693 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2102,16 +2102,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	}
 
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
-		/* data arrives as one packet */
-		devpriv->ai_sample_count = cmd->stop_arg;
-		break;
-	case TRIG_NONE:
-		/* continuous acquisition */
-		devpriv->ai_sample_count = 1;
-		break;
-	}
+	devpriv->ai_sample_count = cmd->stop_arg;
 
 	s626_reset_adc(dev, ppl);
 

commit 27cb98142f42432733ac0a0cb2a35330756d5c19
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:16:02 2014 -0700

    staging: comedi: s626: clarify COMEDI_CB_EOA code
    
    The end-of-acquisition only applies when the cmd->stop_src == TRIG_COUNT.
    
    Refactor the code in s626_handle_eos_interrupt() that detects the end-of-
    acquisition to clarify this.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index aac661790dc4..8b4823ece682 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1501,19 +1501,20 @@ static bool s626_handle_eos_interrupt(struct comedi_device *dev)
 	/* end of scan occurs */
 	async->events |= COMEDI_CB_EOS;
 
-	if (cmd->stop_src == TRIG_COUNT)
+	if (cmd->stop_src == TRIG_COUNT) {
 		devpriv->ai_sample_count--;
-	if (devpriv->ai_sample_count <= 0) {
-		devpriv->ai_cmd_running = 0;
+		if (devpriv->ai_sample_count <= 0) {
+			devpriv->ai_cmd_running = 0;
 
-		/* Stop RPS program */
-		s626_mc_disable(dev, S626_MC1_ERPS1, S626_P_MC1);
+			/* Stop RPS program */
+			s626_mc_disable(dev, S626_MC1_ERPS1, S626_P_MC1);
 
-		/* send end of acquisition */
-		async->events |= COMEDI_CB_EOA;
+			/* send end of acquisition */
+			async->events |= COMEDI_CB_EOA;
 
-		/* disable master interrupt */
-		finished = true;
+			/* disable master interrupt */
+			finished = true;
+		}
 	}
 
 	if (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT)

commit e37b20aa58d8b6e4df41222f4aacf2b055c973b2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:16:01 2014 -0700

    staging: comedi: s626: remove 'ai_continuous' from private data
    
    This member of the private data is set based on the cmd->stop_src. Just use the
    cmd->stop_src directly and remove the member.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 051a727a87e9..aac661790dc4 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -78,7 +78,6 @@ struct s626_buffer_dma {
 
 struct s626_private {
 	uint8_t ai_cmd_running;		/* ai_cmd is running */
-	uint8_t ai_continuous;		/* continuous acquisition */
 	int ai_sample_count;		/* number of samples to acquire */
 	unsigned int ai_sample_timer;	/* time between samples in
 					 * units of the timer */
@@ -1502,7 +1501,7 @@ static bool s626_handle_eos_interrupt(struct comedi_device *dev)
 	/* end of scan occurs */
 	async->events |= COMEDI_CB_EOS;
 
-	if (!devpriv->ai_continuous)
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ai_sample_count--;
 	if (devpriv->ai_sample_count <= 0) {
 		devpriv->ai_cmd_running = 0;
@@ -2106,11 +2105,9 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	case TRIG_COUNT:
 		/* data arrives as one packet */
 		devpriv->ai_sample_count = cmd->stop_arg;
-		devpriv->ai_continuous = 0;
 		break;
 	case TRIG_NONE:
 		/* continuous acquisition */
-		devpriv->ai_continuous = 1;
 		devpriv->ai_sample_count = 1;
 		break;
 	}

commit 889277b93b3d94e8166554eb06c6ae0543a3a3ef
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:46:00 2014 +0100

    staging: comedi: s626: use CMDF_ROUND_...
    
    Replace use of the `TRIG_ROUND_...` macros with the new names
    `CMDF_ROUND_...`.  The numeric values are unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index a868d73f86a3..051a727a87e9 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1967,15 +1967,15 @@ static int s626_ns_to_timer(unsigned int *nanosec, unsigned int flags)
 
 	base = 500;		/* 2MHz internal clock */
 
-	switch (flags & TRIG_ROUND_MASK) {
-	case TRIG_ROUND_NEAREST:
+	switch (flags & CMDF_ROUND_MASK) {
+	case CMDF_ROUND_NEAREST:
 	default:
 		divider = (*nanosec + base / 2) / base;
 		break;
-	case TRIG_ROUND_DOWN:
+	case CMDF_ROUND_DOWN:
 		divider = (*nanosec) / base;
 		break;
-	case TRIG_ROUND_UP:
+	case CMDF_ROUND_UP:
 		divider = (*nanosec + base - 1) / base;
 		break;
 	}

commit 8075bfb67566376f706baa7cbc6b5b0e3eb99318
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 17:55:52 2014 -0700

    staging: comedi: s626: use comedi_pci_detach()
    
    Use comedi_pci_detach() to handle the boilerplate part of the (*detach)
    for this PCI driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 8778bb88d74d..a868d73f86a3 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2914,13 +2914,8 @@ static void s626_detach(struct comedi_device *dev)
 			writel(S626_MC1_SHUTDOWN, dev->mmio + S626_P_MC1);
 			writel(S626_ACON1_BASE, dev->mmio + S626_P_ACON1);
 		}
-
-		if (dev->irq)
-			free_irq(dev->irq, dev);
-		if (dev->mmio)
-			iounmap(dev->mmio);
 	}
-	comedi_pci_disable(dev);
+	comedi_pci_detach(dev);
 	s626_free_dma_buffers(dev);
 }
 

commit 3757e79559534e722df93e184078a141dc0bcfa7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 17:55:51 2014 -0700

    staging: comedi: s626: tidy up freeing of the dma buffers
    
    Currently the dma buffers are freed during the detach of the driver using
    the function s626_close_dma_b(). The buffers are also freed while the
    interrupt handler is still attached. This could result in a race condition.
    
    Refactor the code so that the buffers are freed after the interrupt handler
    is released and the PCI device is disabled.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 800121949ff4..8778bb88d74d 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2445,26 +2445,6 @@ static void s626_write_misc2(struct comedi_device *dev, uint16_t new_image)
 	s626_debi_write(dev, S626_LP_MISC1, S626_MISC1_WDISABLE);
 }
 
-static void s626_close_dma_b(struct comedi_device *dev,
-			     struct s626_buffer_dma *pdma, size_t bsize)
-{
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	void *vbptr;
-	dma_addr_t vpptr;
-
-	if (pdma == NULL)
-		return;
-
-	/* find the matching allocation from the board struct */
-	vbptr = pdma->logical_base;
-	vpptr = pdma->physical_base;
-	if (vbptr) {
-		pci_free_consistent(pcidev, bsize, vbptr, vpptr);
-		pdma->logical_base = NULL;
-		pdma->physical_base = 0;
-	}
-}
-
 static void s626_counters_init(struct comedi_device *dev)
 {
 	int chan;
@@ -2515,6 +2495,24 @@ static int s626_allocate_dma_buffers(struct comedi_device *dev)
 	return 0;
 }
 
+static void s626_free_dma_buffers(struct comedi_device *dev)
+{
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct s626_private *devpriv = dev->private;
+
+	if (!devpriv)
+		return;
+
+	if (devpriv->rps_buf.logical_base)
+		pci_free_consistent(pcidev, S626_DMABUF_SIZE,
+				    devpriv->rps_buf.logical_base,
+				    devpriv->rps_buf.physical_base);
+	if (devpriv->ana_buf.logical_base)
+		pci_free_consistent(pcidev, S626_DMABUF_SIZE,
+				    devpriv->ana_buf.logical_base,
+				    devpriv->ana_buf.physical_base);
+}
+
 static int s626_initialize(struct comedi_device *dev)
 {
 	struct s626_private *devpriv = dev->private;
@@ -2915,11 +2913,6 @@ static void s626_detach(struct comedi_device *dev)
 			/* Close all interfaces on 7146 device */
 			writel(S626_MC1_SHUTDOWN, dev->mmio + S626_P_MC1);
 			writel(S626_ACON1_BASE, dev->mmio + S626_P_ACON1);
-
-			s626_close_dma_b(dev, &devpriv->rps_buf,
-					 S626_DMABUF_SIZE);
-			s626_close_dma_b(dev, &devpriv->ana_buf,
-					 S626_DMABUF_SIZE);
 		}
 
 		if (dev->irq)
@@ -2928,6 +2921,7 @@ static void s626_detach(struct comedi_device *dev)
 			iounmap(dev->mmio);
 	}
 	comedi_pci_disable(dev);
+	s626_free_dma_buffers(dev);
 }
 
 static struct comedi_driver s626_driver = {

commit 18259ffcbccad9917342ebafab5f22a54dfba8c9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:09 2014 -0700

    staging: comedi: s626: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index e42720c9b774..800121949ff4 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -98,7 +98,6 @@ struct s626_private {
 	uint8_t trim_setpoint[12];	/* images of TrimDAC setpoints */
 	uint32_t i2c_adrs;		/* I2C device address for onboard EEPROM
 					 * (board rev dependent) */
-	unsigned int ao_readback[S626_DAC_CHANNELS];
 };
 
 /* Counter overflow/index event flag masks for RDMISC2. */
@@ -2268,38 +2267,28 @@ static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_insn *insn, unsigned int *data)
+static int s626_ao_insn_write(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
-	struct s626_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	int i;
-	int ret;
-	uint16_t chan = CR_CHAN(insn->chanspec);
-	int16_t dacdata;
 
 	for (i = 0; i < insn->n; i++) {
-		dacdata = (int16_t) data[i];
-		devpriv->ao_readback[CR_CHAN(insn->chanspec)] = data[i];
+		int16_t dacdata = (int16_t)data[i];
+		int ret;
+
 		dacdata -= (0x1fff);
 
 		ret = s626_set_dac(dev, chan, dacdata);
 		if (ret)
 			return ret;
-	}
-
-	return i;
-}
-
-static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_insn *insn, unsigned int *data)
-{
-	struct s626_private *devpriv = dev->private;
-	int i;
 
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->ao_readback[CR_CHAN(insn->chanspec)];
+		s->readback[chan] = data[i];
+	}
 
-	return i;
+	return insn->n;
 }
 
 /* *************** DIGITAL I/O FUNCTIONS *************** */
@@ -2843,8 +2832,12 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->n_chan	= S626_DAC_CHANNELS;
 	s->maxdata	= 0x3fff;
 	s->range_table	= &range_bipolar10;
-	s->insn_write	= s626_ao_winsn;
-	s->insn_read	= s626_ao_rinsn;
+	s->insn_write	= s626_ao_insn_write;
+	s->insn_read	= comedi_readback_insn_read;
+
+	ret = comedi_alloc_subdev_readback(s);
+	if (ret)
+		return ret;
 
 	s = &dev->subdevices[2];
 	/* digital I/O subdevice */

commit ea2e3182686e2df95e432fdaae66d6b0d1547720
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sun Aug 17 22:43:44 2014 -0500

    staging: comedi: s626: remove unnecessary variable initialization
    
    We initialize 'irqbit' to 0, only to properly set it immediately
    afterwards.  Just remove the zero-initialization.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 080608a840ac..e42720c9b774 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1399,7 +1399,6 @@ static void s626_check_dio_interrupts(struct comedi_device *dev)
 	uint8_t group;
 
 	for (group = 0; group < S626_DIO_BANKS; group++) {
-		irqbit = 0;
 		/* read interrupt type */
 		irqbit = s626_debi_read(dev, S626_LP_RDCAPFLG(group));
 

commit de9cd5ca0246e53933c580a893ac0144548e9394
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jul 29 15:01:35 2014 -0700

    staging: comedi: s626: use the comedi_device 'mmio' member
    
    Use the new 'mmio' member in the comedi_device for the ioremap'ed
    base address.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 0b18d24ddb69..080608a840ac 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -77,7 +77,6 @@ struct s626_buffer_dma {
 };
 
 struct s626_private {
-	void __iomem *mmio;
 	uint8_t ai_cmd_running;		/* ai_cmd is running */
 	uint8_t ai_continuous;		/* continuous acquisition */
 	int ai_sample_count;		/* number of samples to acquire */
@@ -113,29 +112,25 @@ struct s626_private {
 static void s626_mc_enable(struct comedi_device *dev,
 			   unsigned int cmd, unsigned int reg)
 {
-	struct s626_private *devpriv = dev->private;
 	unsigned int val = (cmd << 16) | cmd;
 
 	mmiowb();
-	writel(val, devpriv->mmio + reg);
+	writel(val, dev->mmio + reg);
 }
 
 static void s626_mc_disable(struct comedi_device *dev,
 			    unsigned int cmd, unsigned int reg)
 {
-	struct s626_private *devpriv = dev->private;
-
-	writel(cmd << 16 , devpriv->mmio + reg);
+	writel(cmd << 16 , dev->mmio + reg);
 	mmiowb();
 }
 
 static bool s626_mc_test(struct comedi_device *dev,
 			 unsigned int cmd, unsigned int reg)
 {
-	struct s626_private *devpriv = dev->private;
 	unsigned int val;
 
-	val = readl(devpriv->mmio + reg);
+	val = readl(dev->mmio + reg);
 
 	return (val & cmd) ? true : false;
 }
@@ -157,7 +152,6 @@ static const struct comedi_lrange s626_range_table = {
  */
 static void s626_debi_transfer(struct comedi_device *dev)
 {
-	struct s626_private *devpriv = dev->private;
 	static const int timeout = 10000;
 	int i;
 
@@ -179,7 +173,7 @@ static void s626_debi_transfer(struct comedi_device *dev)
 
 	/* Wait until DEBI transfer is done */
 	for (i = 0; i < timeout; i++) {
-		if (!(readl(devpriv->mmio + S626_P_PSR) & S626_PSR_DEBI_S))
+		if (!(readl(dev->mmio + S626_P_PSR) & S626_PSR_DEBI_S))
 			break;
 		udelay(1);
 	}
@@ -192,15 +186,13 @@ static void s626_debi_transfer(struct comedi_device *dev)
  */
 static uint16_t s626_debi_read(struct comedi_device *dev, uint16_t addr)
 {
-	struct s626_private *devpriv = dev->private;
-
 	/* Set up DEBI control register value in shadow RAM */
-	writel(S626_DEBI_CMD_RDWORD | addr, devpriv->mmio + S626_P_DEBICMD);
+	writel(S626_DEBI_CMD_RDWORD | addr, dev->mmio + S626_P_DEBICMD);
 
 	/*  Execute the DEBI transfer. */
 	s626_debi_transfer(dev);
 
-	return readl(devpriv->mmio + S626_P_DEBIAD);
+	return readl(dev->mmio + S626_P_DEBIAD);
 }
 
 /*
@@ -209,11 +201,9 @@ static uint16_t s626_debi_read(struct comedi_device *dev, uint16_t addr)
 static void s626_debi_write(struct comedi_device *dev, uint16_t addr,
 			    uint16_t wdata)
 {
-	struct s626_private *devpriv = dev->private;
-
 	/* Set up DEBI control register value in shadow RAM */
-	writel(S626_DEBI_CMD_WRWORD | addr, devpriv->mmio + S626_P_DEBICMD);
-	writel(wdata, devpriv->mmio + S626_P_DEBIAD);
+	writel(S626_DEBI_CMD_WRWORD | addr, dev->mmio + S626_P_DEBICMD);
+	writel(wdata, dev->mmio + S626_P_DEBIAD);
 
 	/*  Execute the DEBI transfer. */
 	s626_debi_transfer(dev);
@@ -227,18 +217,17 @@ static void s626_debi_write(struct comedi_device *dev, uint16_t addr,
 static void s626_debi_replace(struct comedi_device *dev, unsigned int addr,
 			      unsigned int mask, unsigned int wdata)
 {
-	struct s626_private *devpriv = dev->private;
 	unsigned int val;
 
 	addr &= 0xffff;
-	writel(S626_DEBI_CMD_RDWORD | addr, devpriv->mmio + S626_P_DEBICMD);
+	writel(S626_DEBI_CMD_RDWORD | addr, dev->mmio + S626_P_DEBICMD);
 	s626_debi_transfer(dev);
 
-	writel(S626_DEBI_CMD_WRWORD | addr, devpriv->mmio + S626_P_DEBICMD);
-	val = readl(devpriv->mmio + S626_P_DEBIAD);
+	writel(S626_DEBI_CMD_WRWORD | addr, dev->mmio + S626_P_DEBICMD);
+	val = readl(dev->mmio + S626_P_DEBIAD);
 	val &= mask;
 	val |= wdata;
-	writel(val & 0xffff, devpriv->mmio + S626_P_DEBIAD);
+	writel(val & 0xffff, dev->mmio + S626_P_DEBIAD);
 	s626_debi_transfer(dev);
 }
 
@@ -259,12 +248,11 @@ static int s626_i2c_handshake_eoc(struct comedi_device *dev,
 
 static int s626_i2c_handshake(struct comedi_device *dev, uint32_t val)
 {
-	struct s626_private *devpriv = dev->private;
 	unsigned int ctrl;
 	int ret;
 
 	/* Write I2C command to I2C Transfer Control shadow register */
-	writel(val, devpriv->mmio + S626_P_I2CCTRL);
+	writel(val, dev->mmio + S626_P_I2CCTRL);
 
 	/*
 	 * Upload I2C shadow registers into working registers and
@@ -277,7 +265,7 @@ static int s626_i2c_handshake(struct comedi_device *dev, uint32_t val)
 
 	/* Wait until I2C bus transfer is finished or an error occurs */
 	do {
-		ctrl = readl(devpriv->mmio + S626_P_I2CCTRL);
+		ctrl = readl(dev->mmio + S626_P_I2CCTRL);
 	} while ((ctrl & (S626_I2C_BUSY | S626_I2C_ERR)) == S626_I2C_BUSY);
 
 	/* Return non-zero if I2C error occurred */
@@ -315,7 +303,7 @@ static uint8_t s626_i2c_read(struct comedi_device *dev, uint8_t addr)
 		/* Abort function and declare error if handshake failed. */
 		return 0;
 
-	return (readl(devpriv->mmio + S626_P_I2CCTRL) >> 16) & 0xff;
+	return (readl(dev->mmio + S626_P_I2CCTRL) >> 16) & 0xff;
 }
 
 /* ***********  DAC FUNCTIONS *********** */
@@ -340,27 +328,26 @@ static int s626_send_dac_eoc(struct comedi_device *dev,
 			     struct comedi_insn *insn,
 			     unsigned long context)
 {
-	struct s626_private *devpriv = dev->private;
 	unsigned int status;
 
 	switch (context) {
 	case s626_send_dac_wait_not_mc1_a2out:
-		status = readl(devpriv->mmio + S626_P_MC1);
+		status = readl(dev->mmio + S626_P_MC1);
 		if (!(status & S626_MC1_A2OUT))
 			return 0;
 		break;
 	case s626_send_dac_wait_ssr_af2_out:
-		status = readl(devpriv->mmio + S626_P_SSR);
+		status = readl(dev->mmio + S626_P_SSR);
 		if (status & S626_SSR_AF2_OUT)
 			return 0;
 		break;
 	case s626_send_dac_wait_fb_buffer2_msb_00:
-		status = readl(devpriv->mmio + S626_P_FB_BUFFER2);
+		status = readl(dev->mmio + S626_P_FB_BUFFER2);
 		if (!(status & 0xff000000))
 			return 0;
 		break;
 	case s626_send_dac_wait_fb_buffer2_msb_ff:
-		status = readl(devpriv->mmio + S626_P_FB_BUFFER2);
+		status = readl(dev->mmio + S626_P_FB_BUFFER2);
 		if (status & 0xff000000)
 			return 0;
 		break;
@@ -397,7 +384,7 @@ static int s626_send_dac(struct comedi_device *dev, uint32_t val)
 	/* TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- */
 
 	/* Copy DAC setpoint value to DAC's output DMA buffer. */
-	/* writel(val, devpriv->mmio + (uint32_t)devpriv->dac_wbuf); */
+	/* writel(val, dev->mmio + (uint32_t)devpriv->dac_wbuf); */
 	*devpriv->dac_wbuf = val;
 
 	/*
@@ -415,7 +402,7 @@ static int s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * other FIFO underflow/overflow flags). When set, this flag
 	 * will indicate that we have emerged from slot 0.
 	 */
-	writel(S626_ISR_AFOU, devpriv->mmio + S626_P_ISR);
+	writel(S626_ISR_AFOU, dev->mmio + S626_P_ISR);
 
 	/*
 	 * Wait for the DMA transfer to finish so that there will be data
@@ -440,7 +427,7 @@ static int s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * detection.
 	 */
 	writel(S626_XSD2 | S626_RSD3 | S626_SIB_A2,
-	       devpriv->mmio + S626_VECTPORT(0));
+	       dev->mmio + S626_VECTPORT(0));
 
 	/*
 	 * Wait for slot 1 to execute to ensure that the Packet will be
@@ -465,7 +452,7 @@ static int s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * buffer register.
 	 */
 	writel(S626_XSD2 | S626_XFIFO_2 | S626_RSD2 | S626_SIB_A2 | S626_EOS,
-	       devpriv->mmio + S626_VECTPORT(0));
+	       dev->mmio + S626_VECTPORT(0));
 
 	/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */
 
@@ -487,7 +474,7 @@ static int s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 *    we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
 	 *    the TSL has not yet finished executing slot 5 ...
 	 */
-	if (readl(devpriv->mmio + S626_P_FB_BUFFER2) & 0xff000000) {
+	if (readl(dev->mmio + S626_P_FB_BUFFER2) & 0xff000000) {
 		/*
 		 * The trap was set on time and we are still executing somewhere
 		 * in slots 2-5, so we now wait for slot 0 to execute and trap
@@ -513,7 +500,7 @@ static int s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * SD3, which is driven only by a pull-up resistor.
 	 */
 	writel(S626_RSD3 | S626_SIB_A2 | S626_EOS,
-	       devpriv->mmio + S626_VECTPORT(0));
+	       dev->mmio + S626_VECTPORT(0));
 
 	/*
 	 * Wait for slot 0 to execute, at which time the TSL is setup for
@@ -571,16 +558,16 @@ static int s626_set_dac(struct comedi_device *dev, uint16_t chan,
 	ws_image = (chan & 2) ? S626_WS1 : S626_WS2;
 	/* Slot 2: Transmit high data byte to target DAC */
 	writel(S626_XSD2 | S626_XFIFO_1 | ws_image,
-	       devpriv->mmio + S626_VECTPORT(2));
+	       dev->mmio + S626_VECTPORT(2));
 	/* Slot 3: Transmit low data byte to target DAC */
 	writel(S626_XSD2 | S626_XFIFO_0 | ws_image,
-	       devpriv->mmio + S626_VECTPORT(3));
+	       dev->mmio + S626_VECTPORT(3));
 	/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */
 	writel(S626_XSD2 | S626_XFIFO_3 | S626_WS3,
-	       devpriv->mmio + S626_VECTPORT(4));
+	       dev->mmio + S626_VECTPORT(4));
 	/* Slot 5: running after writing target DAC's low data byte */
 	writel(S626_XSD2 | S626_XFIFO_2 | S626_WS3 | S626_EOS,
-	       devpriv->mmio + S626_VECTPORT(5));
+	       dev->mmio + S626_VECTPORT(5));
 
 	/*
 	 * Construct and transmit target DAC's serial packet:
@@ -622,16 +609,16 @@ static int s626_write_trim_dac(struct comedi_device *dev, uint8_t logical_chan,
 
 	/* Slot 2: Send high uint8_t to target TrimDac */
 	writel(S626_XSD2 | S626_XFIFO_1 | S626_WS3,
-	       devpriv->mmio + S626_VECTPORT(2));
+	       dev->mmio + S626_VECTPORT(2));
 	/* Slot 3: Send low uint8_t to target TrimDac */
 	writel(S626_XSD2 | S626_XFIFO_0 | S626_WS3,
-	       devpriv->mmio + S626_VECTPORT(3));
+	       dev->mmio + S626_VECTPORT(3));
 	/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running */
 	writel(S626_XSD2 | S626_XFIFO_3 | S626_WS1,
-	       devpriv->mmio + S626_VECTPORT(4));
+	       dev->mmio + S626_VECTPORT(4));
 	/* Slot 5: Send NOP low  uint8_t to DAC0 */
 	writel(S626_XSD2 | S626_XFIFO_2 | S626_WS1 | S626_EOS,
-	       devpriv->mmio + S626_VECTPORT(5));
+	       dev->mmio + S626_VECTPORT(5));
 
 	/*
 	 * Construct and transmit target DAC's serial packet:
@@ -1544,7 +1531,6 @@ static bool s626_handle_eos_interrupt(struct comedi_device *dev)
 static irqreturn_t s626_irq_handler(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct s626_private *devpriv = dev->private;
 	unsigned long flags;
 	uint32_t irqtype, irqstatus;
 
@@ -1554,16 +1540,16 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	spin_lock_irqsave(&dev->spinlock, flags);
 
 	/* save interrupt enable register state */
-	irqstatus = readl(devpriv->mmio + S626_P_IER);
+	irqstatus = readl(dev->mmio + S626_P_IER);
 
 	/* read interrupt type */
-	irqtype = readl(devpriv->mmio + S626_P_ISR);
+	irqtype = readl(dev->mmio + S626_P_ISR);
 
 	/* disable master interrupt */
-	writel(0, devpriv->mmio + S626_P_IER);
+	writel(0, dev->mmio + S626_P_IER);
 
 	/* clear interrupt */
-	writel(irqtype, devpriv->mmio + S626_P_ISR);
+	writel(irqtype, dev->mmio + S626_P_ISR);
 
 	switch (irqtype) {
 	case S626_IRQ_RPS1:	/* end_of_scan occurs */
@@ -1578,7 +1564,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	}
 
 	/* enable interrupt */
-	writel(irqstatus, devpriv->mmio + S626_P_IER);
+	writel(irqstatus, dev->mmio + S626_P_IER);
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 	return IRQ_HANDLED;
@@ -1606,7 +1592,7 @@ static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
 
 	/* Initialize RPS instruction pointer */
 	writel((uint32_t)devpriv->rps_buf.physical_base,
-	       devpriv->mmio + S626_P_RPSADDR1);
+	       dev->mmio + S626_P_RPSADDR1);
 
 	/* Construct RPS program in rps_buf DMA buffer */
 	if (cmd != NULL && cmd->scan_begin_src != TRIG_FOLLOW) {
@@ -1827,10 +1813,9 @@ static int s626_ai_eoc(struct comedi_device *dev,
 		       struct comedi_insn *insn,
 		       unsigned long context)
 {
-	struct s626_private *devpriv = dev->private;
 	unsigned int status;
 
-	status = readl(devpriv->mmio + S626_P_PSR);
+	status = readl(dev->mmio + S626_P_PSR);
 	if (status & S626_PSR_GPIO2)
 		return 0;
 	return -EBUSY;
@@ -1838,9 +1823,9 @@ static int s626_ai_eoc(struct comedi_device *dev,
 
 static int s626_ai_insn_read(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
+			     struct comedi_insn *insn,
+			     unsigned int *data)
 {
-	struct s626_private *devpriv = dev->private;
 	uint16_t chan = CR_CHAN(insn->chanspec);
 	uint16_t range = CR_RANGE(insn->chanspec);
 	uint16_t adc_spec = 0;
@@ -1869,17 +1854,14 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 		udelay(10);
 
 		/* Start ADC by pulsing GPIO1 low */
-		gpio_image = readl(devpriv->mmio + S626_P_GPIO);
+		gpio_image = readl(dev->mmio + S626_P_GPIO);
 		/* Assert ADC Start command */
-		writel(gpio_image & ~S626_GPIO1_HI,
-		       devpriv->mmio + S626_P_GPIO);
+		writel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);
 		/* and stretch it out */
-		writel(gpio_image & ~S626_GPIO1_HI,
-		       devpriv->mmio + S626_P_GPIO);
-		writel(gpio_image & ~S626_GPIO1_HI,
-		       devpriv->mmio + S626_P_GPIO);
+		writel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);
+		writel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);
 		/* Negate ADC Start command */
-		writel(gpio_image | S626_GPIO1_HI, devpriv->mmio + S626_P_GPIO);
+		writel(gpio_image | S626_GPIO1_HI, dev->mmio + S626_P_GPIO);
 
 		/*
 		 * Wait for ADC to complete (GPIO2 is asserted high when
@@ -1894,7 +1876,7 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 
 		/* Fetch ADC data */
 		if (n != 0) {
-			tmp = readl(devpriv->mmio + S626_P_FB_BUFFER1);
+			tmp = readl(dev->mmio + S626_P_FB_BUFFER1);
 			data[n - 1] = s626_ai_reg_to_uint(tmp);
 		}
 
@@ -1914,14 +1896,14 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	 * Start a dummy conversion to cause the data from the
 	 * previous conversion to be shifted in.
 	 */
-	gpio_image = readl(devpriv->mmio + S626_P_GPIO);
+	gpio_image = readl(dev->mmio + S626_P_GPIO);
 	/* Assert ADC Start command */
-	writel(gpio_image & ~S626_GPIO1_HI, devpriv->mmio + S626_P_GPIO);
+	writel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);
 	/* and stretch it out */
-	writel(gpio_image & ~S626_GPIO1_HI, devpriv->mmio + S626_P_GPIO);
-	writel(gpio_image & ~S626_GPIO1_HI, devpriv->mmio + S626_P_GPIO);
+	writel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);
+	writel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);
 	/* Negate ADC Start command */
-	writel(gpio_image | S626_GPIO1_HI, devpriv->mmio + S626_P_GPIO);
+	writel(gpio_image | S626_GPIO1_HI, dev->mmio + S626_P_GPIO);
 
 	/* Wait for the data to arrive in FB BUFFER 1 register. */
 
@@ -1934,7 +1916,7 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 
 	/* Fetch ADC data */
 	if (n != 0) {
-		tmp = readl(devpriv->mmio + S626_P_FB_BUFFER1);
+		tmp = readl(dev->mmio + S626_P_FB_BUFFER1);
 		data[n - 1] = s626_ai_reg_to_uint(tmp);
 	}
 
@@ -2059,10 +2041,10 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EBUSY;
 	}
 	/* disable interrupt */
-	writel(0, devpriv->mmio + S626_P_IER);
+	writel(0, dev->mmio + S626_P_IER);
 
 	/* clear interrupt request */
-	writel(S626_IRQ_RPS1 | S626_IRQ_GPIO3, devpriv->mmio + S626_P_ISR);
+	writel(S626_IRQ_RPS1 | S626_IRQ_GPIO3, dev->mmio + S626_P_ISR);
 
 	/* clear any pending interrupt */
 	s626_dio_clear_irq(dev);
@@ -2157,7 +2139,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* enable interrupt */
-	writel(S626_IRQ_GPIO3 | S626_IRQ_RPS1, devpriv->mmio + S626_P_IER);
+	writel(S626_IRQ_GPIO3 | S626_IRQ_RPS1, dev->mmio + S626_P_IER);
 
 	return 0;
 }
@@ -2280,7 +2262,7 @@ static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	s626_mc_disable(dev, S626_MC1_ERPS1, S626_P_MC1);
 
 	/* disable master interrupt */
-	writel(0, devpriv->mmio + S626_P_IER);
+	writel(0, dev->mmio + S626_P_IER);
 
 	devpriv->ai_cmd_running = 0;
 
@@ -2567,13 +2549,13 @@ static int s626_initialize(struct comedi_device *dev)
 	 */
 	writel(S626_DEBI_CFG_SLAVE16 |
 	       (S626_DEBI_TOUT << S626_DEBI_CFG_TOUT_BIT) | S626_DEBI_SWAP |
-	       S626_DEBI_CFG_INTEL, devpriv->mmio + S626_P_DEBICFG);
+	       S626_DEBI_CFG_INTEL, dev->mmio + S626_P_DEBICFG);
 
 	/* Disable MMU paging */
-	writel(S626_DEBI_PAGE_DISABLE, devpriv->mmio + S626_P_DEBIPAGE);
+	writel(S626_DEBI_PAGE_DISABLE, dev->mmio + S626_P_DEBIPAGE);
 
 	/* Init GPIO so that ADC Start* is negated */
-	writel(S626_GPIO_BASE | S626_GPIO1_HI, devpriv->mmio + S626_P_GPIO);
+	writel(S626_GPIO_BASE | S626_GPIO1_HI, dev->mmio + S626_P_GPIO);
 
 	/* I2C device address for onboard eeprom (revb) */
 	devpriv->i2c_adrs = 0xA0;
@@ -2583,7 +2565,7 @@ static int s626_initialize(struct comedi_device *dev)
 	 * operation in progress and reset BUSY flag.
 	 */
 	writel(S626_I2C_CLKSEL | S626_I2C_ABORT,
-	       devpriv->mmio + S626_P_I2CSTAT);
+	       dev->mmio + S626_P_I2CSTAT);
 	s626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);
 	ret = comedi_timeout(dev, NULL, NULL, s626_i2c_handshake_eoc, 0);
 	if (ret)
@@ -2594,7 +2576,7 @@ static int s626_initialize(struct comedi_device *dev)
 	 * reg twice to reset all  I2C error flags.
 	 */
 	for (i = 0; i < 2; i++) {
-		writel(S626_I2C_CLKSEL, devpriv->mmio + S626_P_I2CSTAT);
+		writel(S626_I2C_CLKSEL, dev->mmio + S626_P_I2CSTAT);
 		s626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);
 		ret = comedi_timeout(dev, NULL, NULL, s626_i2c_handshake_eoc, 0);
 		if (ret)
@@ -2607,7 +2589,7 @@ static int s626_initialize(struct comedi_device *dev)
 	 * DAC data setup times are satisfied, enable DAC serial
 	 * clock out.
 	 */
-	writel(S626_ACON2_INIT, devpriv->mmio + S626_P_ACON2);
+	writel(S626_ACON2_INIT, dev->mmio + S626_P_ACON2);
 
 	/*
 	 * Set up TSL1 slot list, which is used to control the
@@ -2615,12 +2597,12 @@ static int s626_initialize(struct comedi_device *dev)
 	 * S626_SIB_A1  = store data uint8_t at next available location
 	 * in FB BUFFER1 register.
 	 */
-	writel(S626_RSD1 | S626_SIB_A1, devpriv->mmio + S626_P_TSL1);
+	writel(S626_RSD1 | S626_SIB_A1, dev->mmio + S626_P_TSL1);
 	writel(S626_RSD1 | S626_SIB_A1 | S626_EOS,
-	       devpriv->mmio + S626_P_TSL1 + 4);
+	       dev->mmio + S626_P_TSL1 + 4);
 
 	/* Enable TSL1 slot list so that it executes all the time */
-	writel(S626_ACON1_ADCSTART, devpriv->mmio + S626_P_ACON1);
+	writel(S626_ACON1_ADCSTART, dev->mmio + S626_P_ACON1);
 
 	/*
 	 * Initialize RPS registers used for ADC
@@ -2628,11 +2610,11 @@ static int s626_initialize(struct comedi_device *dev)
 
 	/* Physical start of RPS program */
 	writel((uint32_t)devpriv->rps_buf.physical_base,
-	       devpriv->mmio + S626_P_RPSADDR1);
+	       dev->mmio + S626_P_RPSADDR1);
 	/* RPS program performs no explicit mem writes */
-	writel(0, devpriv->mmio + S626_P_RPSPAGE1);
+	writel(0, dev->mmio + S626_P_RPSPAGE1);
 	/* Disable RPS timeouts */
-	writel(0, devpriv->mmio + S626_P_RPS1_TOUT);
+	writel(0, dev->mmio + S626_P_RPS1_TOUT);
 
 #if 0
 	/*
@@ -2688,7 +2670,7 @@ static int s626_initialize(struct comedi_device *dev)
 	 *   burst length = 1 DWORD
 	 *   threshold = 1 DWORD.
 	 */
-	writel(0, devpriv->mmio + S626_P_PCI_BT_A);
+	writel(0, dev->mmio + S626_P_PCI_BT_A);
 
 	/*
 	 * Init Audio2's output DMA physical addresses.  The protection
@@ -2698,9 +2680,9 @@ static int s626_initialize(struct comedi_device *dev)
 	 */
 	phys_buf = devpriv->ana_buf.physical_base +
 		   (S626_DAC_WDMABUF_OS * sizeof(uint32_t));
-	writel((uint32_t)phys_buf, devpriv->mmio + S626_P_BASEA2_OUT);
+	writel((uint32_t)phys_buf, dev->mmio + S626_P_BASEA2_OUT);
 	writel((uint32_t)(phys_buf + sizeof(uint32_t)),
-	       devpriv->mmio + S626_P_PROTA2_OUT);
+	       dev->mmio + S626_P_PROTA2_OUT);
 
 	/*
 	 * Cache Audio2's output DMA buffer logical address.  This is
@@ -2715,7 +2697,7 @@ static int s626_initialize(struct comedi_device *dev)
 	 * DMAC will automatically halt and its PCI address pointer
 	 * will be reset when the protection address is reached.
 	 */
-	writel(8, devpriv->mmio + S626_P_PAGEA2_OUT);
+	writel(8, dev->mmio + S626_P_PAGEA2_OUT);
 
 	/*
 	 * Initialize time slot list 2 (TSL2), which is used to control
@@ -2731,7 +2713,7 @@ static int s626_initialize(struct comedi_device *dev)
 
 	/* Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2 */
 	writel(S626_XSD2 | S626_RSD3 | S626_SIB_A2 | S626_EOS,
-	       devpriv->mmio + S626_VECTPORT(0));
+	       dev->mmio + S626_VECTPORT(0));
 
 	/*
 	 * Initialize slot 1, which is constant.  Slot 1 causes a
@@ -2743,10 +2725,10 @@ static int s626_initialize(struct comedi_device *dev)
 	 */
 
 	/* Slot 1: Fetch DWORD from Audio2's output FIFO */
-	writel(S626_LF_A2, devpriv->mmio + S626_VECTPORT(1));
+	writel(S626_LF_A2, dev->mmio + S626_VECTPORT(1));
 
 	/* Start DAC's audio interface (TSL2) running */
-	writel(S626_ACON1_DACSTART, devpriv->mmio + S626_P_ACON1);
+	writel(S626_ACON1_DACSTART, dev->mmio + S626_P_ACON1);
 
 	/*
 	 * Init Trim DACs to calibrated values.  Do it twice because the
@@ -2810,15 +2792,15 @@ static int s626_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	devpriv->mmio = pci_ioremap_bar(pcidev, 0);
-	if (!devpriv->mmio)
+	dev->mmio = pci_ioremap_bar(pcidev, 0);
+	if (!dev->mmio)
 		return -ENOMEM;
 
 	/* disable master interrupt */
-	writel(0, devpriv->mmio + S626_P_IER);
+	writel(0, dev->mmio + S626_P_IER);
 
 	/* soft reset */
-	writel(S626_MC1_SOFT_RESET, devpriv->mmio + S626_P_MC1);
+	writel(S626_MC1_SOFT_RESET, dev->mmio + S626_P_MC1);
 
 	/* DMA FIXME DMA// */
 
@@ -2927,20 +2909,20 @@ static void s626_detach(struct comedi_device *dev)
 		/* stop ai_command */
 		devpriv->ai_cmd_running = 0;
 
-		if (devpriv->mmio) {
+		if (dev->mmio) {
 			/* interrupt mask */
 			/* Disable master interrupt */
-			writel(0, devpriv->mmio + S626_P_IER);
+			writel(0, dev->mmio + S626_P_IER);
 			/* Clear board's IRQ status flag */
 			writel(S626_IRQ_GPIO3 | S626_IRQ_RPS1,
-			       devpriv->mmio + S626_P_ISR);
+			       dev->mmio + S626_P_ISR);
 
 			/* Disable the watchdog timer and battery charger. */
 			s626_write_misc2(dev, 0);
 
 			/* Close all interfaces on 7146 device */
-			writel(S626_MC1_SHUTDOWN, devpriv->mmio + S626_P_MC1);
-			writel(S626_ACON1_BASE, devpriv->mmio + S626_P_ACON1);
+			writel(S626_MC1_SHUTDOWN, dev->mmio + S626_P_MC1);
+			writel(S626_ACON1_BASE, dev->mmio + S626_P_ACON1);
 
 			s626_close_dma_b(dev, &devpriv->rps_buf,
 					 S626_DMABUF_SIZE);
@@ -2950,8 +2932,8 @@ static void s626_detach(struct comedi_device *dev)
 
 		if (dev->irq)
 			free_irq(dev->irq, dev);
-		if (devpriv->mmio)
-			iounmap(devpriv->mmio);
+		if (dev->mmio)
+			iounmap(dev->mmio);
 	}
 	comedi_pci_disable(dev);
 }

commit a207c12f62e8b53e1e1600ca384b13a39a9feed2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:16 2014 -0700

    staging: comedi: drivers: cleanup cmd->flags use
    
    Most of the comedi drivers that support async commands have some sort
    of timer to control the acquisition timing. For these drivers, Step 4
    of the (*do_cmdtest) operations calls a ns_to_timer() function that
    converts the desired ns time of the command into a value used to set
    the timer. These ns_to_timer() functions also typically pass the
    cmd->flags in order to determine the desired rounding mode.
    
    Some of the drivers mask the cmd->flags with TRIG_ROUND_MASK when
    calling the ns_to_timer() functions. Move all the masking into the
    ns_to_timer() functions and just pass the cmd->flags directly.
    
    The cmd->flags member is an unsigned int, change the parameter type
    in the the ns_to_timer() functions to match.
    
    For aesthetics, rename the parameter in all the ns_to_timer()
    functions to 'flags'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index b7c5d8168e98..0b18d24ddb69 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1981,13 +1981,13 @@ static int s626_ai_inttrig(struct comedi_device *dev,
  * Also, it should adjust ns so that it cooresponds to the actual time
  * that the device will use.
  */
-static int s626_ns_to_timer(unsigned int *nanosec, int round_mode)
+static int s626_ns_to_timer(unsigned int *nanosec, unsigned int flags)
 {
 	int divider, base;
 
 	base = 500;		/* 2MHz internal clock */
 
-	switch (round_mode) {
+	switch (flags & TRIG_ROUND_MASK) {
 	case TRIG_ROUND_NEAREST:
 	default:
 		divider = (*nanosec + base / 2) / base;
@@ -2087,8 +2087,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * set a counter to generate adc trigger at scan_begin_arg
 		 * interval
 		 */
-		tick = s626_ns_to_timer(&cmd->scan_begin_arg,
-					cmd->flags & TRIG_ROUND_MASK);
+		tick = s626_ns_to_timer(&cmd->scan_begin_arg, cmd->flags);
 
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, 5, tick);
@@ -2109,8 +2108,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * set a counter to generate adc trigger at convert_arg
 		 * interval
 		 */
-		tick = s626_ns_to_timer(&cmd->convert_arg,
-					cmd->flags & TRIG_ROUND_MASK);
+		tick = s626_ns_to_timer(&cmd->convert_arg, cmd->flags);
 
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, 4, tick);
@@ -2252,13 +2250,13 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		arg = cmd->scan_begin_arg;
-		s626_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+		s626_ns_to_timer(&arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		arg = cmd->convert_arg;
-		s626_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+		s626_ns_to_timer(&arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 
 		if (cmd->scan_begin_src == TRIG_TIMER) {

commit cefe93362efa05937eeefa165008863145e0194e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:28 2014 -0700

    staging: comedi: s626: remove use of comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character. The addition of the driver_name is just added noise
    and some of the users of comedi_error() add unnecessary additional new-line
    characters.
    
    Use dev_err() directly instead of comedi_error() to avoid any confusion
    and so that all the comedi generated kernel messages have the same format.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index b276ce485c5f..b7c5d8168e98 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -174,8 +174,8 @@ static void s626_debi_transfer(struct comedi_device *dev)
 		udelay(1);
 	}
 	if (i == timeout)
-		comedi_error(dev,
-			"Timeout while uploading to DEBI control register.");
+		dev_err(dev->class_dev,
+			"Timeout while uploading to DEBI control register\n");
 
 	/* Wait until DEBI transfer is done */
 	for (i = 0; i < timeout; i++) {
@@ -184,7 +184,7 @@ static void s626_debi_transfer(struct comedi_device *dev)
 		udelay(1);
 	}
 	if (i == timeout)
-		comedi_error(dev, "DEBI transfer timeout.");
+		dev_err(dev->class_dev, "DEBI transfer timeout\n");
 }
 
 /*
@@ -427,7 +427,7 @@ static int s626_send_dac(struct comedi_device *dev, uint32_t val)
 	ret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,
 			     s626_send_dac_wait_not_mc1_a2out);
 	if (ret) {
-		comedi_error(dev, "DMA transfer timeout.");
+		dev_err(dev->class_dev, "DMA transfer timeout\n");
 		return ret;
 	}
 
@@ -452,7 +452,8 @@ static int s626_send_dac(struct comedi_device *dev, uint32_t val)
 	ret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,
 			     s626_send_dac_wait_ssr_af2_out);
 	if (ret) {
-		comedi_error(dev, "TSL timeout waiting for slot 1 to execute.");
+		dev_err(dev->class_dev,
+			"TSL timeout waiting for slot 1 to execute\n");
 		return ret;
 	}
 
@@ -497,8 +498,8 @@ static int s626_send_dac(struct comedi_device *dev, uint32_t val)
 		ret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,
 				     s626_send_dac_wait_fb_buffer2_msb_00);
 		if (ret) {
-			comedi_error(dev,
-				"TSL timeout waiting for slot 0 to execute.");
+			dev_err(dev->class_dev,
+				"TSL timeout waiting for slot 0 to execute\n");
 			return ret;
 		}
 	}
@@ -522,7 +523,8 @@ static int s626_send_dac(struct comedi_device *dev, uint32_t val)
 	ret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,
 			     s626_send_dac_wait_fb_buffer2_msb_ff);
 	if (ret) {
-		comedi_error(dev, "TSL timeout waiting for slot 0 to execute.");
+		dev_err(dev->class_dev,
+			"TSL timeout waiting for slot 0 to execute\n");
 		return ret;
 	}
 	return 0;

commit 193725ba3f99ea1d2d8870769be231bf2c3be74a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:32 2014 -0700

    staging: comedi: s626: checkpatch.pl cleanup (else not useful)
    
    Fix the checkpatch.pl warning:
    
    WARNING: else is not generally useful after a break or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 9da68225469e..b276ce485c5f 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -836,10 +836,8 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 static uint16_t s626_get_mode(struct comedi_device *dev,
 			      unsigned int chan)
 {
-	if (chan < 3)
-		return s626_get_mode_a(dev, chan);
-	else
-		return s626_get_mode_b(dev, chan);
+	return (chan < 3) ? s626_get_mode_a(dev, chan)
+			  : s626_get_mode_b(dev, chan);
 }
 #endif
 
@@ -1047,10 +1045,8 @@ static uint16_t s626_get_enable(struct comedi_device *dev,
 {
 	uint16_t crb = s626_debi_read(dev, S626_LP_CRB(chan));
 
-	if (chan < 3)
-		return S626_GET_CRB_CLKENAB_A(crb);
-	else
-		return S626_GET_CRB_CLKENAB_B(crb);
+	return (chan < 3) ? S626_GET_CRB_CLKENAB_A(crb)
+			  : S626_GET_CRB_CLKENAB_B(crb);
 }
 #endif
 

commit 0c9a057cebe4fbcd4be87d1f5a722113a4ba8d49
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:29:03 2014 -0700

    staging: comedi: s626: remove struct s626_enc_info
    
    The only member left in this struct is the 'chan' which is the
    comedi channel of the encoder.
    
    Remove the struct and refactor the code to pass/use the comedi
    channel instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6e2cab0086e9..9da68225469e 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -102,11 +102,6 @@ struct s626_private {
 	unsigned int ao_readback[S626_DAC_CHANNELS];
 };
 
-/* COUNTER OBJECT ------------------------------------------------ */
-struct s626_enc_info {
-	int chan;
-};
-
 /* Counter overflow/index event flag masks for RDMISC2. */
 #define S626_INDXMASK(C) (1 << (((C) > 2) ? ((C) * 2 - 1) : ((C) * 2 +  4)))
 #define S626_OVERMASK(C) (1 << (((C) > 2) ? ((C) * 2 + 5) : ((C) * 2 + 10)))
@@ -682,9 +677,9 @@ static int s626_load_trim_dacs(struct comedi_device *dev)
  * latches B.
  */
 static void s626_set_latch_source(struct comedi_device *dev,
-				  const struct s626_enc_info *k, uint16_t value)
+				  unsigned int chan, uint16_t value)
 {
-	s626_debi_replace(dev, S626_LP_CRB(k->chan),
+	s626_debi_replace(dev, S626_LP_CRB(chan),
 			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_LATCHSRC),
 			  S626_SET_CRB_LATCHSRC(value));
 }
@@ -693,10 +688,10 @@ static void s626_set_latch_source(struct comedi_device *dev,
  * Write value into counter preload register.
  */
 static void s626_preload(struct comedi_device *dev,
-			 const struct s626_enc_info *k, uint32_t value)
+			 unsigned int chan, uint32_t value)
 {
-	s626_debi_write(dev, S626_LP_CNTR(k->chan), value);
-	s626_debi_write(dev, S626_LP_CNTR(k->chan) + 2, value >> 16);
+	s626_debi_write(dev, S626_LP_CNTR(chan), value);
+	s626_debi_write(dev, S626_LP_CNTR(chan) + 2, value >> 16);
 }
 
 /* ******  PRIVATE COUNTER FUNCTIONS ****** */
@@ -705,17 +700,17 @@ static void s626_preload(struct comedi_device *dev,
  * Reset a counter's index and overflow event capture flags.
  */
 static void s626_reset_cap_flags(struct comedi_device *dev,
-				 const struct s626_enc_info *k)
+				 unsigned int chan)
 {
 	uint16_t set;
 
 	set = S626_SET_CRB_INTRESETCMD(1);
-	if (k->chan < 3)
+	if (chan < 3)
 		set |= S626_SET_CRB_INTRESET_A(1);
 	else
 		set |= S626_SET_CRB_INTRESET_B(1);
 
-	s626_debi_replace(dev, S626_LP_CRB(k->chan), ~S626_CRBMSK_INTCTRL, set);
+	s626_debi_replace(dev, S626_LP_CRB(chan), ~S626_CRBMSK_INTCTRL, set);
 }
 
 #ifdef unused
@@ -724,7 +719,7 @@ static void s626_reset_cap_flags(struct comedi_device *dev,
  * for both A and B counters.
  */
 static uint16_t s626_get_mode_a(struct comedi_device *dev,
-				const struct s626_enc_info *k)
+				unsigned int chan)
 {
 	uint16_t cra;
 	uint16_t crb;
@@ -732,8 +727,8 @@ static uint16_t s626_get_mode_a(struct comedi_device *dev,
 	unsigned cntsrc, clkmult, clkpol, encmode;
 
 	/* Fetch CRA and CRB register images. */
-	cra = s626_debi_read(dev, S626_LP_CRA(k->chan));
-	crb = s626_debi_read(dev, S626_LP_CRB(k->chan));
+	cra = s626_debi_read(dev, S626_LP_CRA(chan));
+	crb = s626_debi_read(dev, S626_LP_CRB(chan));
 
 	/*
 	 * Populate the standardized counter setup bit fields.
@@ -779,7 +774,7 @@ static uint16_t s626_get_mode_a(struct comedi_device *dev,
 }
 
 static uint16_t s626_get_mode_b(struct comedi_device *dev,
-				const struct s626_enc_info *k)
+				unsigned int chan)
 {
 	uint16_t cra;
 	uint16_t crb;
@@ -787,8 +782,8 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 	unsigned cntsrc, clkmult, clkpol, encmode;
 
 	/* Fetch CRA and CRB register images. */
-	cra = s626_debi_read(dev, S626_LP_CRA(k->chan));
-	crb = s626_debi_read(dev, S626_LP_CRB(k->chan));
+	cra = s626_debi_read(dev, S626_LP_CRA(chan));
+	crb = s626_debi_read(dev, S626_LP_CRB(chan));
 
 	/*
 	 * Populate the standardized counter setup bit fields.
@@ -839,12 +834,12 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 }
 
 static uint16_t s626_get_mode(struct comedi_device *dev,
-			      const struct s626_enc_info *k)
+			      unsigned int chan)
 {
-	if (k->chan < 3)
-		return s626_get_mode_a(dev, k);
+	if (chan < 3)
+		return s626_get_mode_a(dev, chan);
 	else
-		return s626_get_mode_b(dev, k);
+		return s626_get_mode_b(dev, chan);
 }
 #endif
 
@@ -855,7 +850,7 @@ static uint16_t s626_get_mode(struct comedi_device *dev,
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
 static void s626_set_mode_a(struct comedi_device *dev,
-			    const struct s626_enc_info *k, uint16_t setup,
+			    unsigned int chan, uint16_t setup,
 			    uint16_t disable_int_src)
 {
 	struct s626_private *devpriv = dev->private;
@@ -919,21 +914,21 @@ static void s626_set_mode_a(struct comedi_device *dev,
 	 * enable mask to indicate the counter interrupt is disabled.
 	 */
 	if (disable_int_src)
-		devpriv->counter_int_enabs &= ~(S626_OVERMASK(k->chan) |
-						S626_INDXMASK(k->chan));
+		devpriv->counter_int_enabs &= ~(S626_OVERMASK(chan) |
+						S626_INDXMASK(chan));
 
 	/*
 	 * While retaining CounterB and LatchSrc configurations, program the
 	 * new counter operating mode.
 	 */
-	s626_debi_replace(dev, S626_LP_CRA(k->chan),
+	s626_debi_replace(dev, S626_LP_CRA(chan),
 			  S626_CRAMSK_INDXSRC_B | S626_CRAMSK_CNTSRC_B, cra);
-	s626_debi_replace(dev, S626_LP_CRB(k->chan),
+	s626_debi_replace(dev, S626_LP_CRB(chan),
 			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_A), crb);
 }
 
 static void s626_set_mode_b(struct comedi_device *dev,
-			    const struct s626_enc_info *k, uint16_t setup,
+			    unsigned int chan, uint16_t setup,
 			    uint16_t disable_int_src)
 {
 	struct s626_private *devpriv = dev->private;
@@ -1004,55 +999,55 @@ static void s626_set_mode_b(struct comedi_device *dev,
 	 * enable mask to indicate the counter interrupt is disabled.
 	 */
 	if (disable_int_src)
-		devpriv->counter_int_enabs &= ~(S626_OVERMASK(k->chan) |
-						S626_INDXMASK(k->chan));
+		devpriv->counter_int_enabs &= ~(S626_OVERMASK(chan) |
+						S626_INDXMASK(chan));
 
 	/*
 	 * While retaining CounterA and LatchSrc configurations, program the
 	 * new counter operating mode.
 	 */
-	s626_debi_replace(dev, S626_LP_CRA(k->chan),
+	s626_debi_replace(dev, S626_LP_CRA(chan),
 			  ~(S626_CRAMSK_INDXSRC_B | S626_CRAMSK_CNTSRC_B), cra);
-	s626_debi_replace(dev, S626_LP_CRB(k->chan),
+	s626_debi_replace(dev, S626_LP_CRB(chan),
 			  S626_CRBMSK_CLKENAB_A | S626_CRBMSK_LATCHSRC, crb);
 }
 
 static void s626_set_mode(struct comedi_device *dev,
-			  const struct s626_enc_info *k,
+			  unsigned int chan,
 			  uint16_t setup, uint16_t disable_int_src)
 {
-	if (k->chan < 3)
-		s626_set_mode_a(dev, k, setup, disable_int_src);
+	if (chan < 3)
+		s626_set_mode_a(dev, chan, setup, disable_int_src);
 	else
-		s626_set_mode_b(dev, k, setup, disable_int_src);
+		s626_set_mode_b(dev, chan, setup, disable_int_src);
 }
 
 /*
  * Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
  */
 static void s626_set_enable(struct comedi_device *dev,
-			    const struct s626_enc_info *k, uint16_t enab)
+			    unsigned int chan, uint16_t enab)
 {
 	unsigned int mask = S626_CRBMSK_INTCTRL;
 	unsigned int set;
 
-	if (k->chan < 3) {
+	if (chan < 3) {
 		mask |= S626_CRBMSK_CLKENAB_A;
 		set = S626_SET_CRB_CLKENAB_A(enab);
 	} else {
 		mask |= S626_CRBMSK_CLKENAB_B;
 		set = S626_SET_CRB_CLKENAB_B(enab);
 	}
-	s626_debi_replace(dev, S626_LP_CRB(k->chan), ~mask, set);
+	s626_debi_replace(dev, S626_LP_CRB(chan), ~mask, set);
 }
 
 #ifdef unused
 static uint16_t s626_get_enable(struct comedi_device *dev,
-				const struct s626_enc_info *k)
+				unsigned int chan)
 {
-	uint16_t crb = s626_debi_read(dev, S626_LP_CRB(k->chan));
+	uint16_t crb = s626_debi_read(dev, S626_LP_CRB(chan));
 
-	if (k->chan < 3)
+	if (chan < 3)
 		return S626_GET_CRB_CLKENAB_A(crb);
 	else
 		return S626_GET_CRB_CLKENAB_B(crb);
@@ -1061,10 +1056,9 @@ static uint16_t s626_get_enable(struct comedi_device *dev,
 
 #ifdef unused
 static uint16_t s626_get_latch_source(struct comedi_device *dev,
-				      const struct s626_enc_info *k)
+				      unsigned int chan)
 {
-	return S626_GET_CRB_LATCHSRC(s626_debi_read(dev,
-						    S626_LP_CRB(k->chan)));
+	return S626_GET_CRB_LATCHSRC(s626_debi_read(dev, S626_LP_CRB(chan)));
 }
 #endif
 
@@ -1074,18 +1068,18 @@ static uint16_t s626_get_latch_source(struct comedi_device *dev,
  * 2=OverflowA (B counters only), 3=disabled.
  */
 static void s626_set_load_trig(struct comedi_device *dev,
-			       const struct s626_enc_info *k, uint16_t trig)
+			       unsigned int chan, uint16_t trig)
 {
 	uint16_t reg;
 	uint16_t mask;
 	uint16_t set;
 
-	if (k->chan < 3) {
-		reg = S626_LP_CRA(k->chan);
+	if (chan < 3) {
+		reg = S626_LP_CRA(chan);
 		mask = S626_CRAMSK_LOADSRC_A;
 		set = S626_SET_CRA_LOADSRC_A(trig);
 	} else {
-		reg = S626_LP_CRB(k->chan);
+		reg = S626_LP_CRB(chan);
 		mask = S626_CRBMSK_LOADSRC_B | S626_CRBMSK_INTCTRL;
 		set = S626_SET_CRB_LOADSRC_B(trig);
 	}
@@ -1094,14 +1088,14 @@ static void s626_set_load_trig(struct comedi_device *dev,
 
 #ifdef unused
 static uint16_t s626_get_load_trig(struct comedi_device *dev,
-				   const struct s626_enc_info *k)
+				   unsigned int chan)
 {
-	if (k->chan < 3)
+	if (chan < 3)
 		return S626_GET_CRA_LOADSRC_A(s626_debi_read(dev,
-							S626_LP_CRA(k->chan)));
+							S626_LP_CRA(chan)));
 	else
 		return S626_GET_CRB_LOADSRC_B(s626_debi_read(dev,
-							S626_LP_CRB(k->chan)));
+							S626_LP_CRB(chan)));
 }
 #endif
 
@@ -1111,14 +1105,13 @@ static uint16_t s626_get_load_trig(struct comedi_device *dev,
  * 2=IndexOnly, 3=IndexAndOverflow.
  */
 static void s626_set_int_src(struct comedi_device *dev,
-			     const struct s626_enc_info *k,
-			     uint16_t int_source)
+			     unsigned int chan, uint16_t int_source)
 {
 	struct s626_private *devpriv = dev->private;
-	uint16_t cra_reg = S626_LP_CRA(k->chan);
-	uint16_t crb_reg = S626_LP_CRB(k->chan);
+	uint16_t cra_reg = S626_LP_CRA(chan);
+	uint16_t crb_reg = S626_LP_CRB(chan);
 
-	if (k->chan < 3) {
+	if (chan < 3) {
 		/* Reset any pending counter overflow or index captures */
 		s626_debi_replace(dev, crb_reg, ~S626_CRBMSK_INTCTRL,
 				  S626_SET_CRB_INTRESETCMD(1) |
@@ -1146,35 +1139,35 @@ static void s626_set_int_src(struct comedi_device *dev,
 	}
 
 	/* Update MISC2 interrupt enable mask. */
-	devpriv->counter_int_enabs &= ~(S626_OVERMASK(k->chan) |
-					S626_INDXMASK(k->chan));
+	devpriv->counter_int_enabs &= ~(S626_OVERMASK(chan) |
+					S626_INDXMASK(chan));
 	switch (int_source) {
 	case 0:
 	default:
 		break;
 	case 1:
-		devpriv->counter_int_enabs |= S626_OVERMASK(k->chan);
+		devpriv->counter_int_enabs |= S626_OVERMASK(chan);
 		break;
 	case 2:
-		devpriv->counter_int_enabs |= S626_INDXMASK(k->chan);
+		devpriv->counter_int_enabs |= S626_INDXMASK(chan);
 		break;
 	case 3:
-		devpriv->counter_int_enabs |= (S626_OVERMASK(k->chan) |
-					       S626_INDXMASK(k->chan));
+		devpriv->counter_int_enabs |= (S626_OVERMASK(chan) |
+					       S626_INDXMASK(chan));
 		break;
 	}
 }
 
 #ifdef unused
 static uint16_t s626_get_int_src(struct comedi_device *dev,
-				 const struct s626_enc_info *k)
+				 unsigned int chan)
 {
 	if (chan < 3)
 		return S626_GET_CRA_INTSRC_A(s626_debi_read(dev,
-							S626_LP_CRA(k->chan)));
+							S626_LP_CRA(chan)));
 	else
 		return S626_GET_CRB_INTSRC_B(s626_debi_read(dev,
-							S626_LP_CRB(k->chan)));
+							S626_LP_CRB(chan)));
 }
 #endif
 
@@ -1183,80 +1176,105 @@ static uint16_t s626_get_int_src(struct comedi_device *dev,
  * Return/set the clock multiplier.
  */
 static void s626_set_clk_mult(struct comedi_device *dev,
-			      const struct s626_enc_info *k, uint16_t value)
+			      unsigned int chan, uint16_t value)
 {
-	s626_set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_CLKMULT) |
-		      S626_SET_STD_CLKMULT(value)), false);
+	uint16_t mode;
+
+	mode = s626_get_mode(dev, chan);
+	mode &= ~S626_STDMSK_CLKMULT;
+	mode |= S626_SET_STD_CLKMULT(value);
+
+	s626_set_mode(dev, chan, mode, false);
 }
 
 static uint16_t s626_get_clk_mult(struct comedi_device *dev,
-				  const struct s626_enc_info *k)
+				  unsigned int chan)
 {
-	return S626_GET_STD_CLKMULT(s626_get_mode(dev, k));
+	return S626_GET_STD_CLKMULT(s626_get_mode(dev, chan));
 }
 
 /*
  * Return/set the clock polarity.
  */
 static void s626_set_clk_pol(struct comedi_device *dev,
-			     const struct s626_enc_info *k, uint16_t value)
+			     unsigned int chan, uint16_t value)
 {
-	s626_set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_CLKPOL) |
-		      S626_SET_STD_CLKPOL(value)), false);
+	uint16_t mode;
+
+	mode = s626_get_mode(dev, chan);
+	mode &= ~S626_STDMSK_CLKPOL;
+	mode |= S626_SET_STD_CLKPOL(value);
+
+	s626_set_mode(dev, chan, mode, false);
 }
 
 static uint16_t s626_get_clk_pol(struct comedi_device *dev,
-				 const struct s626_enc_info *k)
+				 unsigned int chan)
 {
-	return S626_GET_STD_CLKPOL(s626_get_mode(dev, k));
+	return S626_GET_STD_CLKPOL(s626_get_mode(dev, chan));
 }
 
 /*
  * Return/set the encoder mode.
  */
 static void s626_set_enc_mode(struct comedi_device *dev,
-			      const struct s626_enc_info *k, uint16_t value)
+			      unsigned int chan, uint16_t value)
 {
-	s626_set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_ENCMODE) |
-		      S626_SET_STD_ENCMODE(value)), false);
+	uint16_t mode;
+
+	mode = s626_get_mode(dev, chan);
+	mode &= ~S626_STDMSK_ENCMODE;
+	mode |= S626_SET_STD_ENCMODE(value);
+
+	s626_set_mode(dev, chan, mode, false);
 }
 
 static uint16_t s626_get_enc_mode(struct comedi_device *dev,
-				  const struct s626_enc_info *k)
+				  unsigned int chan)
 {
-	return S626_GET_STD_ENCMODE(s626_get_mode(dev, k));
+	return S626_GET_STD_ENCMODE(s626_get_mode(dev, chan));
 }
 
 /*
  * Return/set the index polarity.
  */
 static void s626_set_index_pol(struct comedi_device *dev,
-			       const struct s626_enc_info *k, uint16_t value)
+			       unsigned int chan, uint16_t value)
 {
-	s626_set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_INDXPOL) |
-		      S626_SET_STD_INDXPOL(value != 0)), false);
+	uint16_t mode;
+
+	mode = s626_get_mode(dev, chan);
+	mode &= ~S626_STDMSK_INDXPOL;
+	mode |= S626_SET_STD_INDXPOL(value != 0);
+
+	s626_set_mode(dev, chan, mode, false);
 }
 
 static uint16_t s626_get_index_pol(struct comedi_device *dev,
-				   const struct s626_enc_info *k)
+				   unsigned int chan)
 {
-	return S626_GET_STD_INDXPOL(s626_get_mode(dev, k));
+	return S626_GET_STD_INDXPOL(s626_get_mode(dev, chan));
 }
 
 /*
  * Return/set the index source.
  */
 static void s626_set_index_src(struct comedi_device *dev,
-			       const struct s626_enc_info *k, uint16_t value)
+			       unsigned int chan, uint16_t value)
 {
-	s626_set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_INDXSRC) |
-		      S626_SET_STD_INDXSRC(value != 0)), false);
+	uint16_t mode;
+
+	mode = s626_get_mode(dev, chan);
+	mode &= ~S626_STDMSK_INDXSRC;
+	mode |= S626_SET_STD_INDXSRC(value != 0);
+
+	s626_set_mode(dev, chan, mode, false);
 }
 
 static uint16_t s626_get_index_src(struct comedi_device *dev,
-				   const struct s626_enc_info *k)
+				   unsigned int chan)
 {
-	return S626_GET_STD_INDXSRC(s626_get_mode(dev, k));
+	return S626_GET_STD_INDXSRC(s626_get_mode(dev, chan));
 }
 #endif
 
@@ -1264,46 +1282,30 @@ static uint16_t s626_get_index_src(struct comedi_device *dev,
  * Generate an index pulse.
  */
 static void s626_pulse_index(struct comedi_device *dev,
-			     const struct s626_enc_info *k)
+			     unsigned int chan)
 {
-	if (k->chan < 3) {
+	if (chan < 3) {
 		uint16_t cra;
 
-		cra = s626_debi_read(dev, S626_LP_CRA(k->chan));
+		cra = s626_debi_read(dev, S626_LP_CRA(chan));
 
 		/* Pulse index */
-		s626_debi_write(dev, S626_LP_CRA(k->chan),
+		s626_debi_write(dev, S626_LP_CRA(chan),
 				(cra ^ S626_CRAMSK_INDXPOL_A));
-		s626_debi_write(dev, S626_LP_CRA(k->chan), cra);
+		s626_debi_write(dev, S626_LP_CRA(chan), cra);
 	} else {
 		uint16_t crb;
 
-		crb = s626_debi_read(dev, S626_LP_CRB(k->chan));
+		crb = s626_debi_read(dev, S626_LP_CRB(chan));
 		crb &= ~S626_CRBMSK_INTCTRL;
 
 		/* Pulse index */
-		s626_debi_write(dev, S626_LP_CRB(k->chan),
+		s626_debi_write(dev, S626_LP_CRB(chan),
 				(crb ^ S626_CRBMSK_INDXPOL_B));
-		s626_debi_write(dev, S626_LP_CRB(k->chan), crb);
+		s626_debi_write(dev, S626_LP_CRB(chan), crb);
 	}
 }
 
-static const struct s626_enc_info s626_enc_chan_info[] = {
-	{
-		.chan			= 0,
-	}, {
-		.chan			= 1,
-	}, {
-		.chan			= 2,
-	}, {
-		.chan			= 3,
-	}, {
-		.chan			= 4,
-	}, {
-		.chan			= 5,
-	},
-};
-
 static unsigned int s626_ai_reg_to_uint(unsigned int data)
 {
 	return ((data >> 18) & 0x3fff) ^ 0x2000;
@@ -1390,11 +1392,8 @@ static void s626_handle_dio_interrupt(struct comedi_device *dev,
 			}
 
 			if (cmd->convert_src == TRIG_TIMER) {
-				const struct s626_enc_info *k =
-					&s626_enc_chan_info[5];
-
 				devpriv->ai_convert_count = cmd->chanlist_len;
-				s626_set_enable(dev, k, S626_CLKENAB_ALWAYS);
+				s626_set_enable(dev, 5, S626_CLKENAB_ALWAYS);
 			}
 		}
 		if ((irqbit >> (cmd->convert_arg - (16 * group))) == 1 &&
@@ -1433,7 +1432,6 @@ static void s626_check_counter_interrupts(struct comedi_device *dev)
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	const struct s626_enc_info *k;
 	uint16_t irqbit;
 
 	/* read interrupt type */
@@ -1441,39 +1439,29 @@ static void s626_check_counter_interrupts(struct comedi_device *dev)
 
 	/* check interrupt on counters */
 	if (irqbit & S626_IRQ_COINT1A) {
-		k = &s626_enc_chan_info[0];
-
 		/* clear interrupt capture flag */
-		s626_reset_cap_flags(dev, k);
+		s626_reset_cap_flags(dev, 0);
 	}
 	if (irqbit & S626_IRQ_COINT2A) {
-		k = &s626_enc_chan_info[1];
-
 		/* clear interrupt capture flag */
-		s626_reset_cap_flags(dev, k);
+		s626_reset_cap_flags(dev, 1);
 	}
 	if (irqbit & S626_IRQ_COINT3A) {
-		k = &s626_enc_chan_info[2];
-
 		/* clear interrupt capture flag */
-		s626_reset_cap_flags(dev, k);
+		s626_reset_cap_flags(dev, 2);
 	}
 	if (irqbit & S626_IRQ_COINT1B) {
-		k = &s626_enc_chan_info[3];
-
 		/* clear interrupt capture flag */
-		s626_reset_cap_flags(dev, k);
+		s626_reset_cap_flags(dev, 3);
 	}
 	if (irqbit & S626_IRQ_COINT2B) {
-		k = &s626_enc_chan_info[4];
-
 		/* clear interrupt capture flag */
-		s626_reset_cap_flags(dev, k);
+		s626_reset_cap_flags(dev, 4);
 
 		if (devpriv->ai_convert_count > 0) {
 			devpriv->ai_convert_count--;
 			if (devpriv->ai_convert_count == 0)
-				s626_set_enable(dev, k, S626_CLKENAB_INDEX);
+				s626_set_enable(dev, 4, S626_CLKENAB_INDEX);
 
 			if (cmd->convert_src == TRIG_TIMER) {
 				/* Trigger ADC scan loop start */
@@ -1483,10 +1471,8 @@ static void s626_check_counter_interrupts(struct comedi_device *dev)
 		}
 	}
 	if (irqbit & S626_IRQ_COINT3B) {
-		k = &s626_enc_chan_info[5];
-
 		/* clear interrupt capture flag */
-		s626_reset_cap_flags(dev, k);
+		s626_reset_cap_flags(dev, 5);
 
 		if (cmd->scan_begin_src == TRIG_TIMER) {
 			/* Trigger ADC scan loop start */
@@ -1494,9 +1480,8 @@ static void s626_check_counter_interrupts(struct comedi_device *dev)
 		}
 
 		if (cmd->convert_src == TRIG_TIMER) {
-			k = &s626_enc_chan_info[4];
 			devpriv->ai_convert_count = cmd->chanlist_len;
-			s626_set_enable(dev, k, S626_CLKENAB_ALWAYS);
+			s626_set_enable(dev, 4, S626_CLKENAB_ALWAYS);
 		}
 	}
 }
@@ -2022,7 +2007,7 @@ static int s626_ns_to_timer(unsigned int *nanosec, int round_mode)
 }
 
 static void s626_timer_load(struct comedi_device *dev,
-			    const struct s626_enc_info *k, int tick)
+			    unsigned int chan, int tick)
 {
 	uint16_t setup =
 		/* Preload upon index. */
@@ -2040,26 +2025,26 @@ static void s626_timer_load(struct comedi_device *dev,
 	uint16_t value_latchsrc = S626_LATCHSRC_A_INDXA;
 	/* uint16_t enab = S626_CLKENAB_ALWAYS; */
 
-	s626_set_mode(dev, k, setup, false);
+	s626_set_mode(dev, chan, setup, false);
 
 	/* Set the preload register */
-	s626_preload(dev, k, tick);
+	s626_preload(dev, chan, tick);
 
 	/*
 	 * Software index pulse forces the preload register to load
 	 * into the counter
 	 */
-	s626_set_load_trig(dev, k, 0);
-	s626_pulse_index(dev, k);
+	s626_set_load_trig(dev, chan, 0);
+	s626_pulse_index(dev, chan);
 
 	/* set reload on counter overflow */
-	s626_set_load_trig(dev, k, 1);
+	s626_set_load_trig(dev, chan, 1);
 
 	/* set interrupt on overflow */
-	s626_set_int_src(dev, k, S626_INTSRC_OVER);
+	s626_set_int_src(dev, chan, S626_INTSRC_OVER);
 
-	s626_set_latch_source(dev, k, value_latchsrc);
-	/* s626_set_enable(dev, k, (uint16_t)(enab != 0)); */
+	s626_set_latch_source(dev, chan, value_latchsrc);
+	/* s626_set_enable(dev, chan, (uint16_t)(enab != 0)); */
 }
 
 /* TO COMPLETE  */
@@ -2068,7 +2053,6 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct s626_private *devpriv = dev->private;
 	uint8_t ppl[16];
 	struct comedi_cmd *cmd = &s->async->cmd;
-	const struct s626_enc_info *k;
 	int tick;
 
 	if (devpriv->ai_cmd_running) {
@@ -2105,13 +2089,12 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * set a counter to generate adc trigger at scan_begin_arg
 		 * interval
 		 */
-		k = &s626_enc_chan_info[5];
 		tick = s626_ns_to_timer(&cmd->scan_begin_arg,
 					cmd->flags & TRIG_ROUND_MASK);
 
 		/* load timer value and enable interrupt */
-		s626_timer_load(dev, k, tick);
-		s626_set_enable(dev, k, S626_CLKENAB_ALWAYS);
+		s626_timer_load(dev, 5, tick);
+		s626_set_enable(dev, 5, S626_CLKENAB_ALWAYS);
 		break;
 	case TRIG_EXT:
 		/* set the digital line and interrupt for scan trigger */
@@ -2128,13 +2111,12 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * set a counter to generate adc trigger at convert_arg
 		 * interval
 		 */
-		k = &s626_enc_chan_info[4];
 		tick = s626_ns_to_timer(&cmd->convert_arg,
 					cmd->flags & TRIG_ROUND_MASK);
 
 		/* load timer value and enable interrupt */
-		s626_timer_load(dev, k, tick);
-		s626_set_enable(dev, k, S626_CLKENAB_INDEX);
+		s626_timer_load(dev, 4, tick);
+		s626_set_enable(dev, 4, S626_CLKENAB_INDEX);
 		break;
 	case TRIG_EXT:
 		/* set the digital line and interrupt for convert trigger */
@@ -2416,6 +2398,7 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	uint16_t setup =
 		/* Preload upon index. */
 		S626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |
@@ -2433,16 +2416,14 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 	/* uint32_t Preloadvalue;              //Counter initial value */
 	uint16_t value_latchsrc = S626_LATCHSRC_AB_READ;
 	uint16_t enab = S626_CLKENAB_ALWAYS;
-	const struct s626_enc_info *k =
-		&s626_enc_chan_info[CR_CHAN(insn->chanspec)];
 
 	/* (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
-	s626_set_mode(dev, k, setup, true);
-	s626_preload(dev, k, data[0]);
-	s626_pulse_index(dev, k);
-	s626_set_latch_source(dev, k, value_latchsrc);
-	s626_set_enable(dev, k, (enab != 0));
+	s626_set_mode(dev, chan, setup, true);
+	s626_preload(dev, chan, data[0]);
+	s626_pulse_index(dev, chan);
+	s626_set_latch_source(dev, chan, value_latchsrc);
+	s626_set_enable(dev, chan, (enab != 0));
 
 	return insn->n;
 }
@@ -2475,19 +2456,18 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
-	const struct s626_enc_info *k =
-		&s626_enc_chan_info[CR_CHAN(insn->chanspec)];
+	unsigned int chan = CR_CHAN(insn->chanspec);
 
 	/* Set the preload register */
-	s626_preload(dev, k, data[0]);
+	s626_preload(dev, chan, data[0]);
 
 	/*
 	 * Software index pulse forces the preload register to load
 	 * into the counter
 	 */
-	s626_set_load_trig(dev, k, 0);
-	s626_pulse_index(dev, k);
-	s626_set_load_trig(dev, k, 2);
+	s626_set_load_trig(dev, chan, 0);
+	s626_pulse_index(dev, chan);
+	s626_set_load_trig(dev, chan, 2);
 
 	return 1;
 }
@@ -2522,7 +2502,6 @@ static void s626_close_dma_b(struct comedi_device *dev,
 static void s626_counters_init(struct comedi_device *dev)
 {
 	int chan;
-	const struct s626_enc_info *k;
 	uint16_t setup =
 		/* Preload upon index. */
 		S626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |
@@ -2541,11 +2520,10 @@ static void s626_counters_init(struct comedi_device *dev)
 	 * Disable all counter interrupts and clear any captured counter events.
 	 */
 	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
-		k = &s626_enc_chan_info[chan];
-		s626_set_mode(dev, k, setup, true);
-		s626_set_int_src(dev, k, 0);
-		s626_reset_cap_flags(dev, k);
-		s626_set_enable(dev, k, S626_CLKENAB_ALWAYS);
+		s626_set_mode(dev, chan, setup, true);
+		s626_set_int_src(dev, chan, 0);
+		s626_reset_cap_flags(dev, chan);
+		s626_set_enable(dev, chan, S626_CLKENAB_ALWAYS);
 	}
 }
 

commit 81202ecffc4fe1afbc2ca57cd6fe36fefa69acba
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:29:02 2014 -0700

    staging: comedi: s626: tidy up s626_enc_insn_read()
    
    Abosorb the s626_read_latch() helper and tidy up this function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 13dac54af003..6e2cab0086e9 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -676,25 +676,6 @@ static int s626_load_trim_dacs(struct comedi_device *dev)
  * 2=2A, 3=0B, 4=1B, 5=2B.
  */
 
-/*
- * Read a counter's output latch.
- */
-static uint32_t s626_read_latch(struct comedi_device *dev,
-				const struct s626_enc_info *k)
-{
-	uint32_t value;
-
-	/* Latch counts and fetch LSW of latched counts value. */
-	value = s626_debi_read(dev, S626_LP_CNTR(k->chan));
-
-	/* Fetch MSW of latched counts and combine with LSW. */
-	value |= ((uint32_t)s626_debi_read(dev,
-					   S626_LP_CNTR(k->chan) + 2) << 16);
-
-	/* Return latched counts. */
-	return value;
-}
-
 /*
  * Return/set a counter pair's latch trigger source.  0: On read
  * access, 1: A index latches A, 2: B index latches B, 3: A overflow
@@ -2468,16 +2449,26 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 
 static int s626_enc_insn_read(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
-	int n;
-	const struct s626_enc_info *k =
-		&s626_enc_chan_info[CR_CHAN(insn->chanspec)];
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	uint16_t cntr_latch_reg = S626_LP_CNTR(chan);
+	int i;
 
-	for (n = 0; n < insn->n; n++)
-		data[n] = s626_read_latch(dev, k);
+	for (i = 0; i < insn->n; i++) {
+		unsigned int val;
 
-	return n;
+		/*
+		 * Read the counter's output latch LSW/MSW.
+		 * Latches on LSW read.
+		 */
+		val = s626_debi_read(dev, cntr_latch_reg);
+		val |= (s626_debi_read(dev, cntr_latch_reg + 2) << 16);
+		data[i] = val;
+	}
+
+	return insn->n;
 }
 
 static int s626_enc_insn_write(struct comedi_device *dev,

commit f76d02f81f82b92831f54eaaccabf8608040d493
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:29:01 2014 -0700

    staging: comedi: s626: remove 'my_event_bits' from encoder private data
    
    This array in the encoder private data just makes the driver harder to
    follow.
    
    The S626_EVBITS() macro is used to initialize the member in the declaration.
    This macro creates a array of four values, based on the encoder channel, that
    are used to mask and set the private data 'counter_int_enabs' member. The
    values are created using the S626_OVERMASK() and S626_INDXMASK() macros using
    the encoder channel number.
    
    Remove the 'my_event_bits' member from the encoder private data as well
    as the S626_EVBITS() macro. Refactor the code to use the S626_OVERMASK() and
    S626_INDXMASK() macros directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6a322e39d5fa..13dac54af003 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -105,22 +105,11 @@ struct s626_private {
 /* COUNTER OBJECT ------------------------------------------------ */
 struct s626_enc_info {
 	int chan;
-
-	uint16_t my_event_bits[4]; /* bit translations for IntSrc -->RDMISC2 */
 };
 
 /* Counter overflow/index event flag masks for RDMISC2. */
 #define S626_INDXMASK(C) (1 << (((C) > 2) ? ((C) * 2 - 1) : ((C) * 2 +  4)))
 #define S626_OVERMASK(C) (1 << (((C) > 2) ? ((C) * 2 + 5) : ((C) * 2 + 10)))
-#define S626_EVBITS(C)	{ 0, S626_OVERMASK(C), S626_INDXMASK(C), \
-			  S626_OVERMASK(C) | S626_INDXMASK(C) }
-
-/*
- * Translation table to map IntSrc into equivalent RDMISC2 event flag  bits.
- * static const uint16_t s626_event_bits[][4] =
- *     { S626_EVBITS(0), S626_EVBITS(1), S626_EVBITS(2), S626_EVBITS(3),
- *       S626_EVBITS(4), S626_EVBITS(5) };
- */
 
 /*
  * Enable/disable a function or test status bit(s) that are accessed
@@ -949,7 +938,8 @@ static void s626_set_mode_a(struct comedi_device *dev,
 	 * enable mask to indicate the counter interrupt is disabled.
 	 */
 	if (disable_int_src)
-		devpriv->counter_int_enabs &= ~k->my_event_bits[3];
+		devpriv->counter_int_enabs &= ~(S626_OVERMASK(k->chan) |
+						S626_INDXMASK(k->chan));
 
 	/*
 	 * While retaining CounterB and LatchSrc configurations, program the
@@ -1033,7 +1023,8 @@ static void s626_set_mode_b(struct comedi_device *dev,
 	 * enable mask to indicate the counter interrupt is disabled.
 	 */
 	if (disable_int_src)
-		devpriv->counter_int_enabs &= ~k->my_event_bits[3];
+		devpriv->counter_int_enabs &= ~(S626_OVERMASK(k->chan) |
+						S626_INDXMASK(k->chan));
 
 	/*
 	 * While retaining CounterA and LatchSrc configurations, program the
@@ -1174,8 +1165,23 @@ static void s626_set_int_src(struct comedi_device *dev,
 	}
 
 	/* Update MISC2 interrupt enable mask. */
-	devpriv->counter_int_enabs &= ~k->my_event_bits[3];
-	devpriv->counter_int_enabs |= k->my_event_bits[int_source];
+	devpriv->counter_int_enabs &= ~(S626_OVERMASK(k->chan) |
+					S626_INDXMASK(k->chan));
+	switch (int_source) {
+	case 0:
+	default:
+		break;
+	case 1:
+		devpriv->counter_int_enabs |= S626_OVERMASK(k->chan);
+		break;
+	case 2:
+		devpriv->counter_int_enabs |= S626_INDXMASK(k->chan);
+		break;
+	case 3:
+		devpriv->counter_int_enabs |= (S626_OVERMASK(k->chan) |
+					       S626_INDXMASK(k->chan));
+		break;
+	}
 }
 
 #ifdef unused
@@ -1304,22 +1310,16 @@ static void s626_pulse_index(struct comedi_device *dev,
 static const struct s626_enc_info s626_enc_chan_info[] = {
 	{
 		.chan			= 0,
-		.my_event_bits		= S626_EVBITS(0),
 	}, {
 		.chan			= 1,
-		.my_event_bits		= S626_EVBITS(1),
 	}, {
 		.chan			= 2,
-		.my_event_bits		= S626_EVBITS(2),
 	}, {
 		.chan			= 3,
-		.my_event_bits		= S626_EVBITS(3),
 	}, {
 		.chan			= 4,
-		.my_event_bits		= S626_EVBITS(4),
 	}, {
 		.chan			= 5,
-		.my_event_bits		= S626_EVBITS(5),
 	},
 };
 

commit b35d6a38be9a5454e946ffea42cef92f25ca10de
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:29:00 2014 -0700

    staging: comedi: s626: remove 'set_mode' callback from encoder private data
    
    There are two functions used for the 'set_mode' callback. One is used for
    the channel 0-2 encoders and the other for the channel 3-5 encoders.
    
    Add a helper function, s626_set_mode(), that uses the encoder channel number
    to determine which function to call.
    
    Remove the then unnecessary 'set_mode' member and just call s626_set_mode()
    directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 348b28f92e42..6a322e39d5fa 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -106,12 +106,6 @@ struct s626_private {
 struct s626_enc_info {
 	int chan;
 
-	/* Pointers to functions that differ for A and B counters: */
-	/* Program standardized operating mode. */
-	void (*set_mode)(struct comedi_device *dev,
-			 const struct s626_enc_info *k, uint16_t setup,
-			 uint16_t disable_int_src);
-
 	uint16_t my_event_bits[4]; /* bit translations for IntSrc -->RDMISC2 */
 };
 
@@ -1051,6 +1045,16 @@ static void s626_set_mode_b(struct comedi_device *dev,
 			  S626_CRBMSK_CLKENAB_A | S626_CRBMSK_LATCHSRC, crb);
 }
 
+static void s626_set_mode(struct comedi_device *dev,
+			  const struct s626_enc_info *k,
+			  uint16_t setup, uint16_t disable_int_src)
+{
+	if (k->chan < 3)
+		s626_set_mode_a(dev, k, setup, disable_int_src);
+	else
+		s626_set_mode_b(dev, k, setup, disable_int_src);
+}
+
 /*
  * Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
  */
@@ -1194,8 +1198,8 @@ static uint16_t s626_get_int_src(struct comedi_device *dev,
 static void s626_set_clk_mult(struct comedi_device *dev,
 			      const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_CLKMULT) |
-			     S626_SET_STD_CLKMULT(value)), false);
+	s626_set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_CLKMULT) |
+		      S626_SET_STD_CLKMULT(value)), false);
 }
 
 static uint16_t s626_get_clk_mult(struct comedi_device *dev,
@@ -1210,8 +1214,8 @@ static uint16_t s626_get_clk_mult(struct comedi_device *dev,
 static void s626_set_clk_pol(struct comedi_device *dev,
 			     const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_CLKPOL) |
-			     S626_SET_STD_CLKPOL(value)), false);
+	s626_set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_CLKPOL) |
+		      S626_SET_STD_CLKPOL(value)), false);
 }
 
 static uint16_t s626_get_clk_pol(struct comedi_device *dev,
@@ -1226,8 +1230,8 @@ static uint16_t s626_get_clk_pol(struct comedi_device *dev,
 static void s626_set_enc_mode(struct comedi_device *dev,
 			      const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_ENCMODE) |
-			     S626_SET_STD_ENCMODE(value)), false);
+	s626_set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_ENCMODE) |
+		      S626_SET_STD_ENCMODE(value)), false);
 }
 
 static uint16_t s626_get_enc_mode(struct comedi_device *dev,
@@ -1242,8 +1246,8 @@ static uint16_t s626_get_enc_mode(struct comedi_device *dev,
 static void s626_set_index_pol(struct comedi_device *dev,
 			       const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_INDXPOL) |
-			     S626_SET_STD_INDXPOL(value != 0)), false);
+	s626_set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_INDXPOL) |
+		      S626_SET_STD_INDXPOL(value != 0)), false);
 }
 
 static uint16_t s626_get_index_pol(struct comedi_device *dev,
@@ -1258,8 +1262,8 @@ static uint16_t s626_get_index_pol(struct comedi_device *dev,
 static void s626_set_index_src(struct comedi_device *dev,
 			       const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_INDXSRC) |
-			     S626_SET_STD_INDXSRC(value != 0)), false);
+	s626_set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_INDXSRC) |
+		      S626_SET_STD_INDXSRC(value != 0)), false);
 }
 
 static uint16_t s626_get_index_src(struct comedi_device *dev,
@@ -1300,27 +1304,21 @@ static void s626_pulse_index(struct comedi_device *dev,
 static const struct s626_enc_info s626_enc_chan_info[] = {
 	{
 		.chan			= 0,
-		.set_mode		= s626_set_mode_a,
 		.my_event_bits		= S626_EVBITS(0),
 	}, {
 		.chan			= 1,
-		.set_mode		= s626_set_mode_a,
 		.my_event_bits		= S626_EVBITS(1),
 	}, {
 		.chan			= 2,
-		.set_mode		= s626_set_mode_a,
 		.my_event_bits		= S626_EVBITS(2),
 	}, {
 		.chan			= 3,
-		.set_mode		= s626_set_mode_b,
 		.my_event_bits		= S626_EVBITS(3),
 	}, {
 		.chan			= 4,
-		.set_mode		= s626_set_mode_b,
 		.my_event_bits		= S626_EVBITS(4),
 	}, {
 		.chan			= 5,
-		.set_mode		= s626_set_mode_b,
 		.my_event_bits		= S626_EVBITS(5),
 	},
 };
@@ -2061,7 +2059,7 @@ static void s626_timer_load(struct comedi_device *dev,
 	uint16_t value_latchsrc = S626_LATCHSRC_A_INDXA;
 	/* uint16_t enab = S626_CLKENAB_ALWAYS; */
 
-	k->set_mode(dev, k, setup, false);
+	s626_set_mode(dev, k, setup, false);
 
 	/* Set the preload register */
 	s626_preload(dev, k, tick);
@@ -2459,7 +2457,7 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 
 	/* (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
-	k->set_mode(dev, k, setup, true);
+	s626_set_mode(dev, k, setup, true);
 	s626_preload(dev, k, data[0]);
 	s626_pulse_index(dev, k);
 	s626_set_latch_source(dev, k, value_latchsrc);
@@ -2553,7 +2551,7 @@ static void s626_counters_init(struct comedi_device *dev)
 	 */
 	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
 		k = &s626_enc_chan_info[chan];
-		k->set_mode(dev, k, setup, true);
+		s626_set_mode(dev, k, setup, true);
 		s626_set_int_src(dev, k, 0);
 		s626_reset_cap_flags(dev, k);
 		s626_set_enable(dev, k, S626_CLKENAB_ALWAYS);

commit 0a9844910c7dd5e6dfc630a69f7efc9ba261efcf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:59 2014 -0700

    staging: comedi: s626: remove 'get_mode' callback from encoder private data
    
    There are two functions used for the 'get_mode' callback. One is used for
    the channel 0-2 encoders and the other for the channel 3-5 encoders.
    
    Add a helper function, s626_get_mode(), that uses the encoder channel number
    to determine which function to call.
    
    Remove the then unnecessary 'get_mode' member from the encoder private data.
    
    The 'get_mode' callbacks were not being used by the driver in any of the enabled
    code. For now block the s626_get_mode() functions with '#ifdef unused' to prevent
    a compiler warning.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 776868b16353..348b28f92e42 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -107,9 +107,6 @@ struct s626_enc_info {
 	int chan;
 
 	/* Pointers to functions that differ for A and B counters: */
-	/* Return standardized operating mode. */
-	uint16_t (*get_mode)(struct comedi_device *dev,
-			    const struct s626_enc_info *k);
 	/* Program standardized operating mode. */
 	void (*set_mode)(struct comedi_device *dev,
 			 const struct s626_enc_info *k, uint16_t setup,
@@ -757,6 +754,7 @@ static void s626_reset_cap_flags(struct comedi_device *dev,
 	s626_debi_replace(dev, S626_LP_CRB(k->chan), ~S626_CRBMSK_INTCTRL, set);
 }
 
+#ifdef unused
 /*
  * Return counter setup in a format (COUNTER_SETUP) that is consistent
  * for both A and B counters.
@@ -876,6 +874,16 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 	return setup;
 }
 
+static uint16_t s626_get_mode(struct comedi_device *dev,
+			      const struct s626_enc_info *k)
+{
+	if (k->chan < 3)
+		return s626_get_mode_a(dev, k);
+	else
+		return s626_get_mode_b(dev, k);
+}
+#endif
+
 /*
  * Set the operating mode for the specified counter.  The setup
  * parameter is treated as a COUNTER_SETUP data type.  The following
@@ -1186,14 +1194,14 @@ static uint16_t s626_get_int_src(struct comedi_device *dev,
 static void s626_set_clk_mult(struct comedi_device *dev,
 			      const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_CLKMULT) |
+	k->set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_CLKMULT) |
 			     S626_SET_STD_CLKMULT(value)), false);
 }
 
 static uint16_t s626_get_clk_mult(struct comedi_device *dev,
 				  const struct s626_enc_info *k)
 {
-	return S626_GET_STD_CLKMULT(k->get_mode(dev, k));
+	return S626_GET_STD_CLKMULT(s626_get_mode(dev, k));
 }
 
 /*
@@ -1202,14 +1210,14 @@ static uint16_t s626_get_clk_mult(struct comedi_device *dev,
 static void s626_set_clk_pol(struct comedi_device *dev,
 			     const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_CLKPOL) |
+	k->set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_CLKPOL) |
 			     S626_SET_STD_CLKPOL(value)), false);
 }
 
 static uint16_t s626_get_clk_pol(struct comedi_device *dev,
 				 const struct s626_enc_info *k)
 {
-	return S626_GET_STD_CLKPOL(k->get_mode(dev, k));
+	return S626_GET_STD_CLKPOL(s626_get_mode(dev, k));
 }
 
 /*
@@ -1218,14 +1226,14 @@ static uint16_t s626_get_clk_pol(struct comedi_device *dev,
 static void s626_set_enc_mode(struct comedi_device *dev,
 			      const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_ENCMODE) |
+	k->set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_ENCMODE) |
 			     S626_SET_STD_ENCMODE(value)), false);
 }
 
 static uint16_t s626_get_enc_mode(struct comedi_device *dev,
 				  const struct s626_enc_info *k)
 {
-	return S626_GET_STD_ENCMODE(k->get_mode(dev, k));
+	return S626_GET_STD_ENCMODE(s626_get_mode(dev, k));
 }
 
 /*
@@ -1234,14 +1242,14 @@ static uint16_t s626_get_enc_mode(struct comedi_device *dev,
 static void s626_set_index_pol(struct comedi_device *dev,
 			       const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_INDXPOL) |
+	k->set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_INDXPOL) |
 			     S626_SET_STD_INDXPOL(value != 0)), false);
 }
 
 static uint16_t s626_get_index_pol(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	return S626_GET_STD_INDXPOL(k->get_mode(dev, k));
+	return S626_GET_STD_INDXPOL(s626_get_mode(dev, k));
 }
 
 /*
@@ -1250,14 +1258,14 @@ static uint16_t s626_get_index_pol(struct comedi_device *dev,
 static void s626_set_index_src(struct comedi_device *dev,
 			       const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_INDXSRC) |
+	k->set_mode(dev, k, ((s626_get_mode(dev, k) & ~S626_STDMSK_INDXSRC) |
 			     S626_SET_STD_INDXSRC(value != 0)), false);
 }
 
 static uint16_t s626_get_index_src(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	return S626_GET_STD_INDXSRC(k->get_mode(dev, k));
+	return S626_GET_STD_INDXSRC(s626_get_mode(dev, k));
 }
 #endif
 
@@ -1292,32 +1300,26 @@ static void s626_pulse_index(struct comedi_device *dev,
 static const struct s626_enc_info s626_enc_chan_info[] = {
 	{
 		.chan			= 0,
-		.get_mode		= s626_get_mode_a,
 		.set_mode		= s626_set_mode_a,
 		.my_event_bits		= S626_EVBITS(0),
 	}, {
 		.chan			= 1,
-		.get_mode		= s626_get_mode_a,
 		.set_mode		= s626_set_mode_a,
 		.my_event_bits		= S626_EVBITS(1),
 	}, {
 		.chan			= 2,
-		.get_mode		= s626_get_mode_a,
 		.set_mode		= s626_set_mode_a,
 		.my_event_bits		= S626_EVBITS(2),
 	}, {
 		.chan			= 3,
-		.get_mode		= s626_get_mode_b,
 		.set_mode		= s626_set_mode_b,
 		.my_event_bits		= S626_EVBITS(3),
 	}, {
 		.chan			= 4,
-		.get_mode		= s626_get_mode_b,
 		.set_mode		= s626_set_mode_b,
 		.my_event_bits		= S626_EVBITS(4),
 	}, {
 		.chan			= 5,
-		.get_mode		= s626_get_mode_b,
 		.set_mode		= s626_set_mode_b,
 		.my_event_bits		= S626_EVBITS(5),
 	},

commit 26499b8bce111f5c33329de3a5af68f6044bdcb2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:58 2014 -0700

    staging: comedi: s626: remove 'reset_cap_flags' callback from encoder private data
    
    There are two functions used for the 'reset_cap_flags' callback, One is used for
    the channel 0-2 encoders and the other for the channel 3-5 encoders.
    
    Refactor the two callbacks into a single s626_reset_cap_flags() function and use
    the encoder channel number to handle the differences.
    
    Remove the then unnecessary 'reset_cap_flags' member and just call s626_reset_cap_flags()
    directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4ec7ba1d3627..776868b16353 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -114,9 +114,6 @@ struct s626_enc_info {
 	void (*set_mode)(struct comedi_device *dev,
 			 const struct s626_enc_info *k, uint16_t setup,
 			 uint16_t disable_int_src);
-	/* Reset event capture flags. */
-	void (*reset_cap_flags)(struct comedi_device *dev,
-				const struct s626_enc_info *k);
 
 	uint16_t my_event_bits[4]; /* bit translations for IntSrc -->RDMISC2 */
 };
@@ -746,20 +743,18 @@ static void s626_preload(struct comedi_device *dev,
 /*
  * Reset a counter's index and overflow event capture flags.
  */
-static void s626_reset_cap_flags_a(struct comedi_device *dev,
-				   const struct s626_enc_info *k)
+static void s626_reset_cap_flags(struct comedi_device *dev,
+				 const struct s626_enc_info *k)
 {
-	s626_debi_replace(dev, S626_LP_CRB(k->chan), ~S626_CRBMSK_INTCTRL,
-			  (S626_SET_CRB_INTRESETCMD(1) |
-			   S626_SET_CRB_INTRESET_A(1)));
-}
+	uint16_t set;
 
-static void s626_reset_cap_flags_b(struct comedi_device *dev,
-				   const struct s626_enc_info *k)
-{
-	s626_debi_replace(dev, S626_LP_CRB(k->chan), ~S626_CRBMSK_INTCTRL,
-			  (S626_SET_CRB_INTRESETCMD(1) |
-			   S626_SET_CRB_INTRESET_B(1)));
+	set = S626_SET_CRB_INTRESETCMD(1);
+	if (k->chan < 3)
+		set |= S626_SET_CRB_INTRESET_A(1);
+	else
+		set |= S626_SET_CRB_INTRESET_B(1);
+
+	s626_debi_replace(dev, S626_LP_CRB(k->chan), ~S626_CRBMSK_INTCTRL, set);
 }
 
 /*
@@ -1299,37 +1294,31 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.chan			= 0,
 		.get_mode		= s626_get_mode_a,
 		.set_mode		= s626_set_mode_a,
-		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_event_bits		= S626_EVBITS(0),
 	}, {
 		.chan			= 1,
 		.get_mode		= s626_get_mode_a,
 		.set_mode		= s626_set_mode_a,
-		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_event_bits		= S626_EVBITS(1),
 	}, {
 		.chan			= 2,
 		.get_mode		= s626_get_mode_a,
 		.set_mode		= s626_set_mode_a,
-		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_event_bits		= S626_EVBITS(2),
 	}, {
 		.chan			= 3,
 		.get_mode		= s626_get_mode_b,
 		.set_mode		= s626_set_mode_b,
-		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_event_bits		= S626_EVBITS(3),
 	}, {
 		.chan			= 4,
 		.get_mode		= s626_get_mode_b,
 		.set_mode		= s626_set_mode_b,
-		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_event_bits		= S626_EVBITS(4),
 	}, {
 		.chan			= 5,
 		.get_mode		= s626_get_mode_b,
 		.set_mode		= s626_set_mode_b,
-		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_event_bits		= S626_EVBITS(5),
 	},
 };
@@ -1474,31 +1463,31 @@ static void s626_check_counter_interrupts(struct comedi_device *dev)
 		k = &s626_enc_chan_info[0];
 
 		/* clear interrupt capture flag */
-		k->reset_cap_flags(dev, k);
+		s626_reset_cap_flags(dev, k);
 	}
 	if (irqbit & S626_IRQ_COINT2A) {
 		k = &s626_enc_chan_info[1];
 
 		/* clear interrupt capture flag */
-		k->reset_cap_flags(dev, k);
+		s626_reset_cap_flags(dev, k);
 	}
 	if (irqbit & S626_IRQ_COINT3A) {
 		k = &s626_enc_chan_info[2];
 
 		/* clear interrupt capture flag */
-		k->reset_cap_flags(dev, k);
+		s626_reset_cap_flags(dev, k);
 	}
 	if (irqbit & S626_IRQ_COINT1B) {
 		k = &s626_enc_chan_info[3];
 
 		/* clear interrupt capture flag */
-		k->reset_cap_flags(dev, k);
+		s626_reset_cap_flags(dev, k);
 	}
 	if (irqbit & S626_IRQ_COINT2B) {
 		k = &s626_enc_chan_info[4];
 
 		/* clear interrupt capture flag */
-		k->reset_cap_flags(dev, k);
+		s626_reset_cap_flags(dev, k);
 
 		if (devpriv->ai_convert_count > 0) {
 			devpriv->ai_convert_count--;
@@ -1516,7 +1505,7 @@ static void s626_check_counter_interrupts(struct comedi_device *dev)
 		k = &s626_enc_chan_info[5];
 
 		/* clear interrupt capture flag */
-		k->reset_cap_flags(dev, k);
+		s626_reset_cap_flags(dev, k);
 
 		if (cmd->scan_begin_src == TRIG_TIMER) {
 			/* Trigger ADC scan loop start */
@@ -2564,7 +2553,7 @@ static void s626_counters_init(struct comedi_device *dev)
 		k = &s626_enc_chan_info[chan];
 		k->set_mode(dev, k, setup, true);
 		s626_set_int_src(dev, k, 0);
-		k->reset_cap_flags(dev, k);
+		s626_reset_cap_flags(dev, k);
 		s626_set_enable(dev, k, S626_CLKENAB_ALWAYS);
 	}
 }

commit 92249e1f792621505894ec81e3f8bafa88caeb35
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:57 2014 -0700

    staging: comedi: s626: remove 'pulse_index' callback from encoder private data
    
    There are two functions used for the 'pulse_index' callback, One is used for
    the channel 0-2 encoders and the other for the channel 3-5 encoders.
    
    Refactor the two callbacks into a single s626_pulse_index() function and use
    the encoder channel number to handle the differences.
    
    Remove the then unnecessary 'pulse_index' member and just call s626_pulse_index()
    drectly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 232b9fc5e5f6..4ec7ba1d3627 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -110,9 +110,6 @@ struct s626_enc_info {
 	/* Return standardized operating mode. */
 	uint16_t (*get_mode)(struct comedi_device *dev,
 			    const struct s626_enc_info *k);
-	/* Generate soft index strobe. */
-	void (*pulse_index)(struct comedi_device *dev,
-			    const struct s626_enc_info *k);
 	/* Program standardized operating mode. */
 	void (*set_mode)(struct comedi_device *dev,
 			 const struct s626_enc_info *k, uint16_t setup,
@@ -1272,70 +1269,65 @@ static uint16_t s626_get_index_src(struct comedi_device *dev,
 /*
  * Generate an index pulse.
  */
-static void s626_pulse_index_a(struct comedi_device *dev,
-			       const struct s626_enc_info *k)
+static void s626_pulse_index(struct comedi_device *dev,
+			     const struct s626_enc_info *k)
 {
-	uint16_t cra;
+	if (k->chan < 3) {
+		uint16_t cra;
 
-	cra = s626_debi_read(dev, S626_LP_CRA(k->chan));
-	/* Pulse index. */
-	s626_debi_write(dev, S626_LP_CRA(k->chan),
-			(cra ^ S626_CRAMSK_INDXPOL_A));
-	s626_debi_write(dev, S626_LP_CRA(k->chan), cra);
-}
+		cra = s626_debi_read(dev, S626_LP_CRA(k->chan));
 
-static void s626_pulse_index_b(struct comedi_device *dev,
-			       const struct s626_enc_info *k)
-{
-	uint16_t crb;
+		/* Pulse index */
+		s626_debi_write(dev, S626_LP_CRA(k->chan),
+				(cra ^ S626_CRAMSK_INDXPOL_A));
+		s626_debi_write(dev, S626_LP_CRA(k->chan), cra);
+	} else {
+		uint16_t crb;
 
-	crb = s626_debi_read(dev, S626_LP_CRB(k->chan)) & ~S626_CRBMSK_INTCTRL;
-	/* Pulse index. */
-	s626_debi_write(dev, S626_LP_CRB(k->chan),
-			(crb ^ S626_CRBMSK_INDXPOL_B));
-	s626_debi_write(dev, S626_LP_CRB(k->chan), crb);
+		crb = s626_debi_read(dev, S626_LP_CRB(k->chan));
+		crb &= ~S626_CRBMSK_INTCTRL;
+
+		/* Pulse index */
+		s626_debi_write(dev, S626_LP_CRB(k->chan),
+				(crb ^ S626_CRBMSK_INDXPOL_B));
+		s626_debi_write(dev, S626_LP_CRB(k->chan), crb);
+	}
 }
 
 static const struct s626_enc_info s626_enc_chan_info[] = {
 	{
 		.chan			= 0,
 		.get_mode		= s626_get_mode_a,
-		.pulse_index		= s626_pulse_index_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_event_bits		= S626_EVBITS(0),
 	}, {
 		.chan			= 1,
 		.get_mode		= s626_get_mode_a,
-		.pulse_index		= s626_pulse_index_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_event_bits		= S626_EVBITS(1),
 	}, {
 		.chan			= 2,
 		.get_mode		= s626_get_mode_a,
-		.pulse_index		= s626_pulse_index_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_event_bits		= S626_EVBITS(2),
 	}, {
 		.chan			= 3,
 		.get_mode		= s626_get_mode_b,
-		.pulse_index		= s626_pulse_index_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_event_bits		= S626_EVBITS(3),
 	}, {
 		.chan			= 4,
 		.get_mode		= s626_get_mode_b,
-		.pulse_index		= s626_pulse_index_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_event_bits		= S626_EVBITS(4),
 	}, {
 		.chan			= 5,
 		.get_mode		= s626_get_mode_b,
-		.pulse_index		= s626_pulse_index_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_event_bits		= S626_EVBITS(5),
@@ -2088,7 +2080,7 @@ static void s626_timer_load(struct comedi_device *dev,
 	 * into the counter
 	 */
 	s626_set_load_trig(dev, k, 0);
-	k->pulse_index(dev, k);
+	s626_pulse_index(dev, k);
 
 	/* set reload on counter overflow */
 	s626_set_load_trig(dev, k, 1);
@@ -2478,7 +2470,7 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 
 	k->set_mode(dev, k, setup, true);
 	s626_preload(dev, k, data[0]);
-	k->pulse_index(dev, k);
+	s626_pulse_index(dev, k);
 	s626_set_latch_source(dev, k, value_latchsrc);
 	s626_set_enable(dev, k, (enab != 0));
 
@@ -2514,7 +2506,7 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 	 * into the counter
 	 */
 	s626_set_load_trig(dev, k, 0);
-	k->pulse_index(dev, k);
+	s626_pulse_index(dev, k);
 	s626_set_load_trig(dev, k, 2);
 
 	return 1;

commit 13f2609da8c92f9e3022dbce3766404d9c8da533
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:56 2014 -0700

    staging: comedi: s626: remove 'get_int_src' callback from encoder private data
    
    There are two functions used for the 'get_int_src' callback. One is used for
    the channel 0-2 encoders and the other for the channel 3-5 encoders.
    
    Refactor the two callbacks into a single s626_get_int_srsc() function and use
    the encoder channel number to handle the differences.
    
    Remove the then unnecessary 'get_int_src' member from the encoder private data.
    
    The 'get_int_src' callbacks were not being used by the driver. For now block
    the s626_get_int_src() function with '#ifdef unused' to prevent a compiler
    warning.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4c53d36c84d9..232b9fc5e5f6 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -107,9 +107,6 @@ struct s626_enc_info {
 	int chan;
 
 	/* Pointers to functions that differ for A and B counters: */
-	/* Return interrupt source. */
-	uint16_t (*get_int_src)(struct comedi_device *dev,
-			       const struct s626_enc_info *k);
 	/* Return standardized operating mode. */
 	uint16_t (*get_mode)(struct comedi_device *dev,
 			    const struct s626_enc_info *k);
@@ -1177,19 +1174,18 @@ static void s626_set_int_src(struct comedi_device *dev,
 	devpriv->counter_int_enabs |= k->my_event_bits[int_source];
 }
 
-static uint16_t s626_get_int_src_a(struct comedi_device *dev,
-				   const struct s626_enc_info *k)
-{
-	return S626_GET_CRA_INTSRC_A(s626_debi_read(dev,
-						    S626_LP_CRA(k->chan)));
-}
-
-static uint16_t s626_get_int_src_b(struct comedi_device *dev,
-				   const struct s626_enc_info *k)
+#ifdef unused
+static uint16_t s626_get_int_src(struct comedi_device *dev,
+				 const struct s626_enc_info *k)
 {
-	return S626_GET_CRB_INTSRC_B(s626_debi_read(dev,
-						    S626_LP_CRB(k->chan)));
+	if (chan < 3)
+		return S626_GET_CRA_INTSRC_A(s626_debi_read(dev,
+							S626_LP_CRA(k->chan)));
+	else
+		return S626_GET_CRB_INTSRC_B(s626_debi_read(dev,
+							S626_LP_CRB(k->chan)));
 }
+#endif
 
 #ifdef unused
 /*
@@ -1303,7 +1299,6 @@ static void s626_pulse_index_b(struct comedi_device *dev,
 static const struct s626_enc_info s626_enc_chan_info[] = {
 	{
 		.chan			= 0,
-		.get_int_src		= s626_get_int_src_a,
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
 		.set_mode		= s626_set_mode_a,
@@ -1311,7 +1306,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_event_bits		= S626_EVBITS(0),
 	}, {
 		.chan			= 1,
-		.get_int_src		= s626_get_int_src_a,
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
 		.set_mode		= s626_set_mode_a,
@@ -1319,7 +1313,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_event_bits		= S626_EVBITS(1),
 	}, {
 		.chan			= 2,
-		.get_int_src		= s626_get_int_src_a,
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
 		.set_mode		= s626_set_mode_a,
@@ -1327,7 +1320,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_event_bits		= S626_EVBITS(2),
 	}, {
 		.chan			= 3,
-		.get_int_src		= s626_get_int_src_b,
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
 		.set_mode		= s626_set_mode_b,
@@ -1335,7 +1327,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_event_bits		= S626_EVBITS(3),
 	}, {
 		.chan			= 4,
-		.get_int_src		= s626_get_int_src_b,
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
 		.set_mode		= s626_set_mode_b,
@@ -1343,7 +1334,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_event_bits		= S626_EVBITS(4),
 	}, {
 		.chan			= 5,
-		.get_int_src		= s626_get_int_src_b,
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
 		.set_mode		= s626_set_mode_b,

commit 253e2ee4b2924a4ca2f092e41318741f86a533d9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:55 2014 -0700

    staging: comedi: s626: remove 'set_int_src' callback from encoder private data
    
    There are two functions used for the 'set_int_src' callback, One is used for
    the channel 0-2 encoders and the other for the channel 3-5 encoders.
    
    Refactor the two callbacks into a single s626_set_int_src() function and use
    the encoder channel number to handle the differences.
    
    Remove the then unnecessary 'set_int_src' member and just call s626_set_int_src()
    drectly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 614e1a96a713..4c53d36c84d9 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -116,9 +116,6 @@ struct s626_enc_info {
 	/* Generate soft index strobe. */
 	void (*pulse_index)(struct comedi_device *dev,
 			    const struct s626_enc_info *k);
-	/* Program interrupt source. */
-	void (*set_int_src)(struct comedi_device *dev,
-			    const struct s626_enc_info *k, uint16_t int_source);
 	/* Program standardized operating mode. */
 	void (*set_mode)(struct comedi_device *dev,
 			 const struct s626_enc_info *k, uint16_t setup,
@@ -1140,51 +1137,44 @@ static uint16_t s626_get_load_trig(struct comedi_device *dev,
  * index/overflow events.  int_source: 0=Disabled, 1=OverflowOnly,
  * 2=IndexOnly, 3=IndexAndOverflow.
  */
-static void s626_set_int_src_a(struct comedi_device *dev,
-			       const struct s626_enc_info *k,
-			       uint16_t int_source)
+static void s626_set_int_src(struct comedi_device *dev,
+			     const struct s626_enc_info *k,
+			     uint16_t int_source)
 {
 	struct s626_private *devpriv = dev->private;
+	uint16_t cra_reg = S626_LP_CRA(k->chan);
+	uint16_t crb_reg = S626_LP_CRB(k->chan);
 
-	/* Reset any pending counter overflow or index captures. */
-	s626_debi_replace(dev, S626_LP_CRB(k->chan), ~S626_CRBMSK_INTCTRL,
-			  (S626_SET_CRB_INTRESETCMD(1) |
-			   S626_SET_CRB_INTRESET_A(1)));
-
-	/* Program counter interrupt source. */
-	s626_debi_replace(dev, S626_LP_CRA(k->chan), ~S626_CRAMSK_INTSRC_A,
-			  S626_SET_CRA_INTSRC_A(int_source));
-
-	/* Update MISC2 interrupt enable mask. */
-	devpriv->counter_int_enabs =
-	    (devpriv->counter_int_enabs & ~k->my_event_bits[3]) |
-	    k->my_event_bits[int_source];
-}
-
-static void s626_set_int_src_b(struct comedi_device *dev,
-			       const struct s626_enc_info *k,
-			       uint16_t int_source)
-{
-	struct s626_private *devpriv = dev->private;
-	uint16_t crb;
+	if (k->chan < 3) {
+		/* Reset any pending counter overflow or index captures */
+		s626_debi_replace(dev, crb_reg, ~S626_CRBMSK_INTCTRL,
+				  S626_SET_CRB_INTRESETCMD(1) |
+				  S626_SET_CRB_INTRESET_A(1));
+
+		/* Program counter interrupt source */
+		s626_debi_replace(dev, cra_reg, ~S626_CRAMSK_INTSRC_A,
+				  S626_SET_CRA_INTSRC_A(int_source));
+	} else {
+		uint16_t crb;
 
-	/* Cache writeable CRB register image. */
-	crb = s626_debi_read(dev, S626_LP_CRB(k->chan)) & ~S626_CRBMSK_INTCTRL;
+		/* Cache writeable CRB register image */
+		crb = s626_debi_read(dev, crb_reg);
+		crb &= ~S626_CRBMSK_INTCTRL;
 
-	/* Reset any pending counter overflow or index captures. */
-	s626_debi_write(dev, S626_LP_CRB(k->chan),
-			(crb | S626_SET_CRB_INTRESETCMD(1) |
-			S626_SET_CRB_INTRESET_B(1)));
+		/* Reset any pending counter overflow or index captures */
+		s626_debi_write(dev, crb_reg,
+				crb | S626_SET_CRB_INTRESETCMD(1) |
+				S626_SET_CRB_INTRESET_B(1));
 
-	/* Program counter interrupt source. */
-	s626_debi_write(dev, S626_LP_CRB(k->chan),
-			((crb & ~S626_CRBMSK_INTSRC_B) |
-			S626_SET_CRB_INTSRC_B(int_source)));
+		/* Program counter interrupt source */
+		s626_debi_write(dev, crb_reg,
+				(crb & ~S626_CRBMSK_INTSRC_B) |
+				S626_SET_CRB_INTSRC_B(int_source));
+	}
 
 	/* Update MISC2 interrupt enable mask. */
-	devpriv->counter_int_enabs =
-		(devpriv->counter_int_enabs & ~k->my_event_bits[3]) |
-		k->my_event_bits[int_source];
+	devpriv->counter_int_enabs &= ~k->my_event_bits[3];
+	devpriv->counter_int_enabs |= k->my_event_bits[int_source];
 }
 
 static uint16_t s626_get_int_src_a(struct comedi_device *dev,
@@ -1316,7 +1306,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_int_src		= s626_get_int_src_a,
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
-		.set_int_src		= s626_set_int_src_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_event_bits		= S626_EVBITS(0),
@@ -1325,7 +1314,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_int_src		= s626_get_int_src_a,
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
-		.set_int_src		= s626_set_int_src_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_event_bits		= S626_EVBITS(1),
@@ -1334,7 +1322,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_int_src		= s626_get_int_src_a,
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
-		.set_int_src		= s626_set_int_src_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_event_bits		= S626_EVBITS(2),
@@ -1343,7 +1330,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_int_src		= s626_get_int_src_b,
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
-		.set_int_src		= s626_set_int_src_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_event_bits		= S626_EVBITS(3),
@@ -1352,7 +1338,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_int_src		= s626_get_int_src_b,
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
-		.set_int_src		= s626_set_int_src_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_event_bits		= S626_EVBITS(4),
@@ -1361,7 +1346,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_int_src		= s626_get_int_src_b,
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
-		.set_int_src		= s626_set_int_src_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_event_bits		= S626_EVBITS(5),
@@ -2120,7 +2104,7 @@ static void s626_timer_load(struct comedi_device *dev,
 	s626_set_load_trig(dev, k, 1);
 
 	/* set interrupt on overflow */
-	k->set_int_src(dev, k, S626_INTSRC_OVER);
+	s626_set_int_src(dev, k, S626_INTSRC_OVER);
 
 	s626_set_latch_source(dev, k, value_latchsrc);
 	/* s626_set_enable(dev, k, (uint16_t)(enab != 0)); */
@@ -2597,7 +2581,7 @@ static void s626_counters_init(struct comedi_device *dev)
 	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
 		k = &s626_enc_chan_info[chan];
 		k->set_mode(dev, k, setup, true);
-		k->set_int_src(dev, k, 0);
+		s626_set_int_src(dev, k, 0);
 		k->reset_cap_flags(dev, k);
 		s626_set_enable(dev, k, S626_CLKENAB_ALWAYS);
 	}

commit c35b86a7cca34c0021c7751729e0db58477d735c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:54 2014 -0700

    staging: comedi: s626: remove 'get_load_trig' callback from encoder private data
    
    There are two functions used for the 'get_load_trig' callback. One is used for
    the channel 0-2 encoders and the other for the channel 3-5 encoders.
    
    Refactor the two callbacks into a single s626_get_load_trig() function and use
    the encoder channel number to handle the differences.
    
    Remove the then unnecessary 'get_enable' member from the encoder private data.
    
    The 'get_load_trig' callbacks were not being used by the driver. For now block
    the s626_get_load_trig() function with '#ifdef unused' to prevent a compiler
    warning.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 49b6d5941f3e..614e1a96a713 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -110,9 +110,6 @@ struct s626_enc_info {
 	/* Return interrupt source. */
 	uint16_t (*get_int_src)(struct comedi_device *dev,
 			       const struct s626_enc_info *k);
-	/* Return preload trigger source. */
-	uint16_t (*get_load_trig)(struct comedi_device *dev,
-				 const struct s626_enc_info *k);
 	/* Return standardized operating mode. */
 	uint16_t (*get_mode)(struct comedi_device *dev,
 			    const struct s626_enc_info *k);
@@ -1125,19 +1122,18 @@ static void s626_set_load_trig(struct comedi_device *dev,
 	s626_debi_replace(dev, reg, ~mask, set);
 }
 
-static uint16_t s626_get_load_trig_a(struct comedi_device *dev,
-				     const struct s626_enc_info *k)
-{
-	return S626_GET_CRA_LOADSRC_A(s626_debi_read(dev,
-						     S626_LP_CRA(k->chan)));
-}
-
-static uint16_t s626_get_load_trig_b(struct comedi_device *dev,
-				     const struct s626_enc_info *k)
+#ifdef unused
+static uint16_t s626_get_load_trig(struct comedi_device *dev,
+				   const struct s626_enc_info *k)
 {
-	return S626_GET_CRB_LOADSRC_B(s626_debi_read(dev,
-						     S626_LP_CRB(k->chan)));
+	if (k->chan < 3)
+		return S626_GET_CRA_LOADSRC_A(s626_debi_read(dev,
+							S626_LP_CRA(k->chan)));
+	else
+		return S626_GET_CRB_LOADSRC_B(s626_debi_read(dev,
+							S626_LP_CRB(k->chan)));
 }
+#endif
 
 /*
  * Return/set counter interrupt source and clear any captured
@@ -1318,7 +1314,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 	{
 		.chan			= 0,
 		.get_int_src		= s626_get_int_src_a,
-		.get_load_trig		= s626_get_load_trig_a,
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
 		.set_int_src		= s626_set_int_src_a,
@@ -1328,7 +1323,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 	}, {
 		.chan			= 1,
 		.get_int_src		= s626_get_int_src_a,
-		.get_load_trig		= s626_get_load_trig_a,
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
 		.set_int_src		= s626_set_int_src_a,
@@ -1338,7 +1332,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 	}, {
 		.chan			= 2,
 		.get_int_src		= s626_get_int_src_a,
-		.get_load_trig		= s626_get_load_trig_a,
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
 		.set_int_src		= s626_set_int_src_a,
@@ -1348,7 +1341,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 	}, {
 		.chan			= 3,
 		.get_int_src		= s626_get_int_src_b,
-		.get_load_trig		= s626_get_load_trig_b,
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
 		.set_int_src		= s626_set_int_src_b,
@@ -1358,7 +1350,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 	}, {
 		.chan			= 4,
 		.get_int_src		= s626_get_int_src_b,
-		.get_load_trig		= s626_get_load_trig_b,
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
 		.set_int_src		= s626_set_int_src_b,
@@ -1368,7 +1359,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 	}, {
 		.chan			= 5,
 		.get_int_src		= s626_get_int_src_b,
-		.get_load_trig		= s626_get_load_trig_b,
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
 		.set_int_src		= s626_set_int_src_b,

commit 7f03b749990cbc3be67f6eabcd0814b89abae0f6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:53 2014 -0700

    staging: comedi: s626: remove 'set_load_trig' callback from encoder private data
    
    There are two functions used for the 'set_load_trig' callback, One is used for
    the channel 0-2 encoders and the other for the channel 3-5 encoders.
    
    Refactor the two callbacks into a single s626_set_load_trig() function and use
    the encoder channel number to handle the differences.
    
    Remove the then unnecessary 'set_load_trig' member and just call s626_set_load_trig()
    drectly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4f93d6c19e48..49b6d5941f3e 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -122,9 +122,6 @@ struct s626_enc_info {
 	/* Program interrupt source. */
 	void (*set_int_src)(struct comedi_device *dev,
 			    const struct s626_enc_info *k, uint16_t int_source);
-	/* Program preload trigger source. */
-	void (*set_load_trig)(struct comedi_device *dev,
-			      const struct s626_enc_info *k, uint16_t trig);
 	/* Program standardized operating mode. */
 	void (*set_mode)(struct comedi_device *dev,
 			 const struct s626_enc_info *k, uint16_t setup,
@@ -1109,19 +1106,23 @@ static uint16_t s626_get_latch_source(struct comedi_device *dev,
  * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
  * 2=OverflowA (B counters only), 3=disabled.
  */
-static void s626_set_load_trig_a(struct comedi_device *dev,
-				 const struct s626_enc_info *k, uint16_t trig)
+static void s626_set_load_trig(struct comedi_device *dev,
+			       const struct s626_enc_info *k, uint16_t trig)
 {
-	s626_debi_replace(dev, S626_LP_CRA(k->chan), ~S626_CRAMSK_LOADSRC_A,
-			  S626_SET_CRA_LOADSRC_A(trig));
-}
+	uint16_t reg;
+	uint16_t mask;
+	uint16_t set;
 
-static void s626_set_load_trig_b(struct comedi_device *dev,
-				 const struct s626_enc_info *k, uint16_t trig)
-{
-	s626_debi_replace(dev, S626_LP_CRB(k->chan),
-			  ~(S626_CRBMSK_LOADSRC_B | S626_CRBMSK_INTCTRL),
-			  S626_SET_CRB_LOADSRC_B(trig));
+	if (k->chan < 3) {
+		reg = S626_LP_CRA(k->chan);
+		mask = S626_CRAMSK_LOADSRC_A;
+		set = S626_SET_CRA_LOADSRC_A(trig);
+	} else {
+		reg = S626_LP_CRB(k->chan);
+		mask = S626_CRBMSK_LOADSRC_B | S626_CRBMSK_INTCTRL;
+		set = S626_SET_CRB_LOADSRC_B(trig);
+	}
+	s626_debi_replace(dev, reg, ~mask, set);
 }
 
 static uint16_t s626_get_load_trig_a(struct comedi_device *dev,
@@ -1321,7 +1322,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
 		.set_int_src		= s626_set_int_src_a,
-		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_event_bits		= S626_EVBITS(0),
@@ -1332,7 +1332,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
 		.set_int_src		= s626_set_int_src_a,
-		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_event_bits		= S626_EVBITS(1),
@@ -1343,7 +1342,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
 		.set_int_src		= s626_set_int_src_a,
-		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_event_bits		= S626_EVBITS(2),
@@ -1354,7 +1352,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
 		.set_int_src		= s626_set_int_src_b,
-		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_event_bits		= S626_EVBITS(3),
@@ -1365,7 +1362,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
 		.set_int_src		= s626_set_int_src_b,
-		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_event_bits		= S626_EVBITS(4),
@@ -1376,7 +1372,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
 		.set_int_src		= s626_set_int_src_b,
-		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_event_bits		= S626_EVBITS(5),
@@ -2128,11 +2123,11 @@ static void s626_timer_load(struct comedi_device *dev,
 	 * Software index pulse forces the preload register to load
 	 * into the counter
 	 */
-	k->set_load_trig(dev, k, 0);
+	s626_set_load_trig(dev, k, 0);
 	k->pulse_index(dev, k);
 
 	/* set reload on counter overflow */
-	k->set_load_trig(dev, k, 1);
+	s626_set_load_trig(dev, k, 1);
 
 	/* set interrupt on overflow */
 	k->set_int_src(dev, k, S626_INTSRC_OVER);
@@ -2554,9 +2549,9 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 	 * Software index pulse forces the preload register to load
 	 * into the counter
 	 */
-	k->set_load_trig(dev, k, 0);
+	s626_set_load_trig(dev, k, 0);
 	k->pulse_index(dev, k);
-	k->set_load_trig(dev, k, 2);
+	s626_set_load_trig(dev, k, 2);
 
 	return 1;
 }

commit 4487502e8478b939445c15fffc836bdb44317a93
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:52 2014 -0700

    staging: comedi: s626: remove 'get_enable' callback from encoder private data
    
    There are two functions used for the 'get_enable' callback, s626_get_enable_a()
    function is used for the channel 0-2 encoders and s626_get_enable_b() is used
    for the channel 3-5 encoders.
    
    Refactor the two callbacks into a single s626_get_enable() function and use the
    encoder channel number to handle the differenced.
    
    Remove the then unnecessary 'get_enable' member and just call s626_set_enable()
    directly.
    
    The 'get_enable' callbacks were not being used by the driver. For now block the
    s626_get_enable() function with '#ifdef unused' to prevent a compiler warning.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 55ac04b24e57..4f93d6c19e48 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -107,9 +107,6 @@ struct s626_enc_info {
 	int chan;
 
 	/* Pointers to functions that differ for A and B counters: */
-	/* Return clock enable. */
-	uint16_t (*get_enable)(struct comedi_device *dev,
-			      const struct s626_enc_info *k);
 	/* Return interrupt source. */
 	uint16_t (*get_int_src)(struct comedi_device *dev,
 			       const struct s626_enc_info *k);
@@ -1085,19 +1082,18 @@ static void s626_set_enable(struct comedi_device *dev,
 	s626_debi_replace(dev, S626_LP_CRB(k->chan), ~mask, set);
 }
 
-static uint16_t s626_get_enable_a(struct comedi_device *dev,
-				  const struct s626_enc_info *k)
+#ifdef unused
+static uint16_t s626_get_enable(struct comedi_device *dev,
+				const struct s626_enc_info *k)
 {
-	return S626_GET_CRB_CLKENAB_A(s626_debi_read(dev,
-						     S626_LP_CRB(k->chan)));
-}
+	uint16_t crb = s626_debi_read(dev, S626_LP_CRB(k->chan));
 
-static uint16_t s626_get_enable_b(struct comedi_device *dev,
-				  const struct s626_enc_info *k)
-{
-	return S626_GET_CRB_CLKENAB_B(s626_debi_read(dev,
-						     S626_LP_CRB(k->chan)));
+	if (k->chan < 3)
+		return S626_GET_CRB_CLKENAB_A(crb);
+	else
+		return S626_GET_CRB_CLKENAB_B(crb);
 }
+#endif
 
 #ifdef unused
 static uint16_t s626_get_latch_source(struct comedi_device *dev,
@@ -1320,7 +1316,6 @@ static void s626_pulse_index_b(struct comedi_device *dev,
 static const struct s626_enc_info s626_enc_chan_info[] = {
 	{
 		.chan			= 0,
-		.get_enable		= s626_get_enable_a,
 		.get_int_src		= s626_get_int_src_a,
 		.get_load_trig		= s626_get_load_trig_a,
 		.get_mode		= s626_get_mode_a,
@@ -1332,7 +1327,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_event_bits		= S626_EVBITS(0),
 	}, {
 		.chan			= 1,
-		.get_enable		= s626_get_enable_a,
 		.get_int_src		= s626_get_int_src_a,
 		.get_load_trig		= s626_get_load_trig_a,
 		.get_mode		= s626_get_mode_a,
@@ -1344,7 +1338,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_event_bits		= S626_EVBITS(1),
 	}, {
 		.chan			= 2,
-		.get_enable		= s626_get_enable_a,
 		.get_int_src		= s626_get_int_src_a,
 		.get_load_trig		= s626_get_load_trig_a,
 		.get_mode		= s626_get_mode_a,
@@ -1356,7 +1349,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_event_bits		= S626_EVBITS(2),
 	}, {
 		.chan			= 3,
-		.get_enable		= s626_get_enable_b,
 		.get_int_src		= s626_get_int_src_b,
 		.get_load_trig		= s626_get_load_trig_b,
 		.get_mode		= s626_get_mode_b,
@@ -1368,7 +1360,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_event_bits		= S626_EVBITS(3),
 	}, {
 		.chan			= 4,
-		.get_enable		= s626_get_enable_b,
 		.get_int_src		= s626_get_int_src_b,
 		.get_load_trig		= s626_get_load_trig_b,
 		.get_mode		= s626_get_mode_b,
@@ -1380,7 +1371,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_event_bits		= S626_EVBITS(4),
 	}, {
 		.chan			= 5,
-		.get_enable		= s626_get_enable_b,
 		.get_int_src		= s626_get_int_src_b,
 		.get_load_trig		= s626_get_load_trig_b,
 		.get_mode		= s626_get_mode_b,

commit c718f4a14f0cbc60eb72d8d6f39d0e3c5d1465d7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:51 2014 -0700

    staging: comedi: s626: remove 'set_enable' callback from encoder private data
    
    There are two functions used for the 'set_enable' callback, s626_set_enable_a()
    function is used for the channel 0-2 encoders and s626_set_enable_b() is used
    for the channel 3-5 encoders.
    
    Refactor the two callbacks into a single s626_set_enable() function and use the
    encoder channel number to handle the differenced.
    
    Remove the then unnecessary 'set_enable' member and just call s626_set_enable()
    directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 7eef58e63f12..55ac04b24e57 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -122,9 +122,6 @@ struct s626_enc_info {
 	/* Generate soft index strobe. */
 	void (*pulse_index)(struct comedi_device *dev,
 			    const struct s626_enc_info *k);
-	/* Program clock enable. */
-	void (*set_enable)(struct comedi_device *dev,
-			   const struct s626_enc_info *k, uint16_t enab);
 	/* Program interrupt source. */
 	void (*set_int_src)(struct comedi_device *dev,
 			    const struct s626_enc_info *k, uint16_t int_source);
@@ -1072,20 +1069,20 @@ static void s626_set_mode_b(struct comedi_device *dev,
 /*
  * Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
  */
-static void s626_set_enable_a(struct comedi_device *dev,
-			      const struct s626_enc_info *k, uint16_t enab)
+static void s626_set_enable(struct comedi_device *dev,
+			    const struct s626_enc_info *k, uint16_t enab)
 {
-	s626_debi_replace(dev, S626_LP_CRB(k->chan),
-			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_A),
-			  S626_SET_CRB_CLKENAB_A(enab));
-}
+	unsigned int mask = S626_CRBMSK_INTCTRL;
+	unsigned int set;
 
-static void s626_set_enable_b(struct comedi_device *dev,
-			      const struct s626_enc_info *k, uint16_t enab)
-{
-	s626_debi_replace(dev, S626_LP_CRB(k->chan),
-			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_B),
-			  S626_SET_CRB_CLKENAB_B(enab));
+	if (k->chan < 3) {
+		mask |= S626_CRBMSK_CLKENAB_A;
+		set = S626_SET_CRB_CLKENAB_A(enab);
+	} else {
+		mask |= S626_CRBMSK_CLKENAB_B;
+		set = S626_SET_CRB_CLKENAB_B(enab);
+	}
+	s626_debi_replace(dev, S626_LP_CRB(k->chan), ~mask, set);
 }
 
 static uint16_t s626_get_enable_a(struct comedi_device *dev,
@@ -1328,7 +1325,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_load_trig		= s626_get_load_trig_a,
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
-		.set_enable		= s626_set_enable_a,
 		.set_int_src		= s626_set_int_src_a,
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
@@ -1341,7 +1337,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_load_trig		= s626_get_load_trig_a,
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
-		.set_enable		= s626_set_enable_a,
 		.set_int_src		= s626_set_int_src_a,
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
@@ -1354,7 +1349,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_load_trig		= s626_get_load_trig_a,
 		.get_mode		= s626_get_mode_a,
 		.pulse_index		= s626_pulse_index_a,
-		.set_enable		= s626_set_enable_a,
 		.set_int_src		= s626_set_int_src_a,
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
@@ -1367,7 +1361,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_load_trig		= s626_get_load_trig_b,
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
-		.set_enable		= s626_set_enable_b,
 		.set_int_src		= s626_set_int_src_b,
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
@@ -1380,7 +1373,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_load_trig		= s626_get_load_trig_b,
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
-		.set_enable		= s626_set_enable_b,
 		.set_int_src		= s626_set_int_src_b,
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
@@ -1393,7 +1385,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.get_load_trig		= s626_get_load_trig_b,
 		.get_mode		= s626_get_mode_b,
 		.pulse_index		= s626_pulse_index_b,
-		.set_enable		= s626_set_enable_b,
 		.set_int_src		= s626_set_int_src_b,
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
@@ -1492,7 +1483,7 @@ static void s626_handle_dio_interrupt(struct comedi_device *dev,
 					&s626_enc_chan_info[5];
 
 				devpriv->ai_convert_count = cmd->chanlist_len;
-				k->set_enable(dev, k, S626_CLKENAB_ALWAYS);
+				s626_set_enable(dev, k, S626_CLKENAB_ALWAYS);
 			}
 		}
 		if ((irqbit >> (cmd->convert_arg - (16 * group))) == 1 &&
@@ -1571,7 +1562,7 @@ static void s626_check_counter_interrupts(struct comedi_device *dev)
 		if (devpriv->ai_convert_count > 0) {
 			devpriv->ai_convert_count--;
 			if (devpriv->ai_convert_count == 0)
-				k->set_enable(dev, k, S626_CLKENAB_INDEX);
+				s626_set_enable(dev, k, S626_CLKENAB_INDEX);
 
 			if (cmd->convert_src == TRIG_TIMER) {
 				/* Trigger ADC scan loop start */
@@ -1594,7 +1585,7 @@ static void s626_check_counter_interrupts(struct comedi_device *dev)
 		if (cmd->convert_src == TRIG_TIMER) {
 			k = &s626_enc_chan_info[4];
 			devpriv->ai_convert_count = cmd->chanlist_len;
-			k->set_enable(dev, k, S626_CLKENAB_ALWAYS);
+			s626_set_enable(dev, k, S626_CLKENAB_ALWAYS);
 		}
 	}
 }
@@ -2157,7 +2148,7 @@ static void s626_timer_load(struct comedi_device *dev,
 	k->set_int_src(dev, k, S626_INTSRC_OVER);
 
 	s626_set_latch_source(dev, k, value_latchsrc);
-	/* k->set_enable(dev, k, (uint16_t)(enab != 0)); */
+	/* s626_set_enable(dev, k, (uint16_t)(enab != 0)); */
 }
 
 /* TO COMPLETE  */
@@ -2209,7 +2200,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
-		k->set_enable(dev, k, S626_CLKENAB_ALWAYS);
+		s626_set_enable(dev, k, S626_CLKENAB_ALWAYS);
 		break;
 	case TRIG_EXT:
 		/* set the digital line and interrupt for scan trigger */
@@ -2232,7 +2223,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
-		k->set_enable(dev, k, S626_CLKENAB_INDEX);
+		s626_set_enable(dev, k, S626_CLKENAB_INDEX);
 		break;
 	case TRIG_EXT:
 		/* set the digital line and interrupt for convert trigger */
@@ -2540,7 +2531,7 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 	s626_preload(dev, k, data[0]);
 	k->pulse_index(dev, k);
 	s626_set_latch_source(dev, k, value_latchsrc);
-	k->set_enable(dev, k, (enab != 0));
+	s626_set_enable(dev, k, (enab != 0));
 
 	return insn->n;
 }
@@ -2633,7 +2624,7 @@ static void s626_counters_init(struct comedi_device *dev)
 		k->set_mode(dev, k, setup, true);
 		k->set_int_src(dev, k, 0);
 		k->reset_cap_flags(dev, k);
-		k->set_enable(dev, k, S626_CLKENAB_ALWAYS);
+		s626_set_enable(dev, k, S626_CLKENAB_ALWAYS);
 	}
 }
 

commit 23201ebb151993bb8212c5f12a3dcec6993e938b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:50 2014 -0700

    staging: comedi: s626: remove my_latch_lsw from encoder private data
    
    This member of the encoder private data can be calculated based on
    the comedi channel stored in the 'chan' member of the private data.
    Do that instead and remove the unnecessary member.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index bbf8e26b29bf..7eef58e63f12 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -139,8 +139,6 @@ struct s626_enc_info {
 	void (*reset_cap_flags)(struct comedi_device *dev,
 				const struct s626_enc_info *k);
 
-	uint16_t my_latch_lsw;	/* address of Latch least-significant-word
-				 * register */
 	uint16_t my_event_bits[4]; /* bit translations for IntSrc -->RDMISC2 */
 };
 
@@ -731,10 +729,11 @@ static uint32_t s626_read_latch(struct comedi_device *dev,
 	uint32_t value;
 
 	/* Latch counts and fetch LSW of latched counts value. */
-	value = s626_debi_read(dev, k->my_latch_lsw);
+	value = s626_debi_read(dev, S626_LP_CNTR(k->chan));
 
 	/* Fetch MSW of latched counts and combine with LSW. */
-	value |= ((uint32_t)s626_debi_read(dev, k->my_latch_lsw + 2) << 16);
+	value |= ((uint32_t)s626_debi_read(dev,
+					   S626_LP_CNTR(k->chan) + 2) << 16);
 
 	/* Return latched counts. */
 	return value;
@@ -759,8 +758,8 @@ static void s626_set_latch_source(struct comedi_device *dev,
 static void s626_preload(struct comedi_device *dev,
 			 const struct s626_enc_info *k, uint32_t value)
 {
-	s626_debi_write(dev, k->my_latch_lsw, value);
-	s626_debi_write(dev, k->my_latch_lsw + 2, value >> 16);
+	s626_debi_write(dev, S626_LP_CNTR(k->chan), value);
+	s626_debi_write(dev, S626_LP_CNTR(k->chan) + 2, value >> 16);
 }
 
 /* ******  PRIVATE COUNTER FUNCTIONS ****** */
@@ -1334,7 +1333,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_latch_lsw		= S626_LP_CNTR(0),
 		.my_event_bits		= S626_EVBITS(0),
 	}, {
 		.chan			= 1,
@@ -1348,7 +1346,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_latch_lsw		= S626_LP_CNTR(1),
 		.my_event_bits		= S626_EVBITS(1),
 	}, {
 		.chan			= 2,
@@ -1362,7 +1359,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_latch_lsw		= S626_LP_CNTR(2),
 		.my_event_bits		= S626_EVBITS(2),
 	}, {
 		.chan			= 3,
@@ -1376,7 +1372,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_latch_lsw		= S626_LP_CNTR(3),
 		.my_event_bits		= S626_EVBITS(3),
 	}, {
 		.chan			= 4,
@@ -1390,7 +1385,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_latch_lsw		= S626_LP_CNTR(4),
 		.my_event_bits		= S626_EVBITS(4),
 	}, {
 		.chan			= 5,
@@ -1404,7 +1398,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_latch_lsw		= S626_LP_CNTR(5),
 		.my_event_bits		= S626_EVBITS(5),
 	},
 };

commit 2ffe88f67fbef05b337ba53ae05c0b37a9a376bf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:49 2014 -0700

    staging: comedi: s626: define S626_LP_CNTR* registers based on channel number
    
    Redefining the Counter Preload/Latch registers as a macro that calculates
    the register offset based on the comedi channel number.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 68f677ac14ba..bbf8e26b29bf 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1334,7 +1334,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_latch_lsw		= S626_LP_CNTR0ALSW,
+		.my_latch_lsw		= S626_LP_CNTR(0),
 		.my_event_bits		= S626_EVBITS(0),
 	}, {
 		.chan			= 1,
@@ -1348,7 +1348,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_latch_lsw		= S626_LP_CNTR1ALSW,
+		.my_latch_lsw		= S626_LP_CNTR(1),
 		.my_event_bits		= S626_EVBITS(1),
 	}, {
 		.chan			= 2,
@@ -1362,7 +1362,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_latch_lsw		= S626_LP_CNTR2ALSW,
+		.my_latch_lsw		= S626_LP_CNTR(2),
 		.my_event_bits		= S626_EVBITS(2),
 	}, {
 		.chan			= 3,
@@ -1376,7 +1376,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_latch_lsw		= S626_LP_CNTR0BLSW,
+		.my_latch_lsw		= S626_LP_CNTR(3),
 		.my_event_bits		= S626_EVBITS(3),
 	}, {
 		.chan			= 4,
@@ -1390,7 +1390,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_latch_lsw		= S626_LP_CNTR1BLSW,
+		.my_latch_lsw		= S626_LP_CNTR(4),
 		.my_event_bits		= S626_EVBITS(4),
 	}, {
 		.chan			= 5,
@@ -1404,7 +1404,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_latch_lsw		= S626_LP_CNTR2BLSW,
+		.my_latch_lsw		= S626_LP_CNTR(5),
 		.my_event_bits		= S626_EVBITS(5),
 	},
 };

commit de151452999fe48a67f9073f8903567bfc6d3ef3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:48 2014 -0700

    staging: comedi: s626: remove my_cr[ab] from encoder private data
    
    These members of the encoder private data can be calculated based on
    the comedi channel stored in the 'chan' member of the private data.
    Do that instead and remove the unnecessary members.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 1785aae39ff6..68f677ac14ba 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -139,8 +139,6 @@ struct s626_enc_info {
 	void (*reset_cap_flags)(struct comedi_device *dev,
 				const struct s626_enc_info *k);
 
-	uint16_t my_cra;	/* address of CRA register */
-	uint16_t my_crb;	/* address of CRB register */
 	uint16_t my_latch_lsw;	/* address of Latch least-significant-word
 				 * register */
 	uint16_t my_event_bits[4]; /* bit translations for IntSrc -->RDMISC2 */
@@ -750,7 +748,7 @@ static uint32_t s626_read_latch(struct comedi_device *dev,
 static void s626_set_latch_source(struct comedi_device *dev,
 				  const struct s626_enc_info *k, uint16_t value)
 {
-	s626_debi_replace(dev, k->my_crb,
+	s626_debi_replace(dev, S626_LP_CRB(k->chan),
 			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_LATCHSRC),
 			  S626_SET_CRB_LATCHSRC(value));
 }
@@ -773,7 +771,7 @@ static void s626_preload(struct comedi_device *dev,
 static void s626_reset_cap_flags_a(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	s626_debi_replace(dev, k->my_crb, ~S626_CRBMSK_INTCTRL,
+	s626_debi_replace(dev, S626_LP_CRB(k->chan), ~S626_CRBMSK_INTCTRL,
 			  (S626_SET_CRB_INTRESETCMD(1) |
 			   S626_SET_CRB_INTRESET_A(1)));
 }
@@ -781,7 +779,7 @@ static void s626_reset_cap_flags_a(struct comedi_device *dev,
 static void s626_reset_cap_flags_b(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	s626_debi_replace(dev, k->my_crb, ~S626_CRBMSK_INTCTRL,
+	s626_debi_replace(dev, S626_LP_CRB(k->chan), ~S626_CRBMSK_INTCTRL,
 			  (S626_SET_CRB_INTRESETCMD(1) |
 			   S626_SET_CRB_INTRESET_B(1)));
 }
@@ -799,8 +797,8 @@ static uint16_t s626_get_mode_a(struct comedi_device *dev,
 	unsigned cntsrc, clkmult, clkpol, encmode;
 
 	/* Fetch CRA and CRB register images. */
-	cra = s626_debi_read(dev, k->my_cra);
-	crb = s626_debi_read(dev, k->my_crb);
+	cra = s626_debi_read(dev, S626_LP_CRA(k->chan));
+	crb = s626_debi_read(dev, S626_LP_CRB(k->chan));
 
 	/*
 	 * Populate the standardized counter setup bit fields.
@@ -854,8 +852,8 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 	unsigned cntsrc, clkmult, clkpol, encmode;
 
 	/* Fetch CRA and CRB register images. */
-	cra = s626_debi_read(dev, k->my_cra);
-	crb = s626_debi_read(dev, k->my_crb);
+	cra = s626_debi_read(dev, S626_LP_CRA(k->chan));
+	crb = s626_debi_read(dev, S626_LP_CRB(k->chan));
 
 	/*
 	 * Populate the standardized counter setup bit fields.
@@ -982,9 +980,9 @@ static void s626_set_mode_a(struct comedi_device *dev,
 	 * While retaining CounterB and LatchSrc configurations, program the
 	 * new counter operating mode.
 	 */
-	s626_debi_replace(dev, k->my_cra,
+	s626_debi_replace(dev, S626_LP_CRA(k->chan),
 			  S626_CRAMSK_INDXSRC_B | S626_CRAMSK_CNTSRC_B, cra);
-	s626_debi_replace(dev, k->my_crb,
+	s626_debi_replace(dev, S626_LP_CRB(k->chan),
 			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_A), crb);
 }
 
@@ -1066,9 +1064,9 @@ static void s626_set_mode_b(struct comedi_device *dev,
 	 * While retaining CounterA and LatchSrc configurations, program the
 	 * new counter operating mode.
 	 */
-	s626_debi_replace(dev, k->my_cra,
+	s626_debi_replace(dev, S626_LP_CRA(k->chan),
 			  ~(S626_CRAMSK_INDXSRC_B | S626_CRAMSK_CNTSRC_B), cra);
-	s626_debi_replace(dev, k->my_crb,
+	s626_debi_replace(dev, S626_LP_CRB(k->chan),
 			  S626_CRBMSK_CLKENAB_A | S626_CRBMSK_LATCHSRC, crb);
 }
 
@@ -1078,7 +1076,7 @@ static void s626_set_mode_b(struct comedi_device *dev,
 static void s626_set_enable_a(struct comedi_device *dev,
 			      const struct s626_enc_info *k, uint16_t enab)
 {
-	s626_debi_replace(dev, k->my_crb,
+	s626_debi_replace(dev, S626_LP_CRB(k->chan),
 			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_A),
 			  S626_SET_CRB_CLKENAB_A(enab));
 }
@@ -1086,7 +1084,7 @@ static void s626_set_enable_a(struct comedi_device *dev,
 static void s626_set_enable_b(struct comedi_device *dev,
 			      const struct s626_enc_info *k, uint16_t enab)
 {
-	s626_debi_replace(dev, k->my_crb,
+	s626_debi_replace(dev, S626_LP_CRB(k->chan),
 			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_B),
 			  S626_SET_CRB_CLKENAB_B(enab));
 }
@@ -1094,20 +1092,23 @@ static void s626_set_enable_b(struct comedi_device *dev,
 static uint16_t s626_get_enable_a(struct comedi_device *dev,
 				  const struct s626_enc_info *k)
 {
-	return S626_GET_CRB_CLKENAB_A(s626_debi_read(dev, k->my_crb));
+	return S626_GET_CRB_CLKENAB_A(s626_debi_read(dev,
+						     S626_LP_CRB(k->chan)));
 }
 
 static uint16_t s626_get_enable_b(struct comedi_device *dev,
 				  const struct s626_enc_info *k)
 {
-	return S626_GET_CRB_CLKENAB_B(s626_debi_read(dev, k->my_crb));
+	return S626_GET_CRB_CLKENAB_B(s626_debi_read(dev,
+						     S626_LP_CRB(k->chan)));
 }
 
 #ifdef unused
 static uint16_t s626_get_latch_source(struct comedi_device *dev,
 				      const struct s626_enc_info *k)
 {
-	return S626_GET_CRB_LATCHSRC(s626_debi_read(dev, k->my_crb));
+	return S626_GET_CRB_LATCHSRC(s626_debi_read(dev,
+						    S626_LP_CRB(k->chan)));
 }
 #endif
 
@@ -1119,14 +1120,14 @@ static uint16_t s626_get_latch_source(struct comedi_device *dev,
 static void s626_set_load_trig_a(struct comedi_device *dev,
 				 const struct s626_enc_info *k, uint16_t trig)
 {
-	s626_debi_replace(dev, k->my_cra, ~S626_CRAMSK_LOADSRC_A,
+	s626_debi_replace(dev, S626_LP_CRA(k->chan), ~S626_CRAMSK_LOADSRC_A,
 			  S626_SET_CRA_LOADSRC_A(trig));
 }
 
 static void s626_set_load_trig_b(struct comedi_device *dev,
 				 const struct s626_enc_info *k, uint16_t trig)
 {
-	s626_debi_replace(dev, k->my_crb,
+	s626_debi_replace(dev, S626_LP_CRB(k->chan),
 			  ~(S626_CRBMSK_LOADSRC_B | S626_CRBMSK_INTCTRL),
 			  S626_SET_CRB_LOADSRC_B(trig));
 }
@@ -1134,13 +1135,15 @@ static void s626_set_load_trig_b(struct comedi_device *dev,
 static uint16_t s626_get_load_trig_a(struct comedi_device *dev,
 				     const struct s626_enc_info *k)
 {
-	return S626_GET_CRA_LOADSRC_A(s626_debi_read(dev, k->my_cra));
+	return S626_GET_CRA_LOADSRC_A(s626_debi_read(dev,
+						     S626_LP_CRA(k->chan)));
 }
 
 static uint16_t s626_get_load_trig_b(struct comedi_device *dev,
 				     const struct s626_enc_info *k)
 {
-	return S626_GET_CRB_LOADSRC_B(s626_debi_read(dev, k->my_crb));
+	return S626_GET_CRB_LOADSRC_B(s626_debi_read(dev,
+						     S626_LP_CRB(k->chan)));
 }
 
 /*
@@ -1155,12 +1158,12 @@ static void s626_set_int_src_a(struct comedi_device *dev,
 	struct s626_private *devpriv = dev->private;
 
 	/* Reset any pending counter overflow or index captures. */
-	s626_debi_replace(dev, k->my_crb, ~S626_CRBMSK_INTCTRL,
+	s626_debi_replace(dev, S626_LP_CRB(k->chan), ~S626_CRBMSK_INTCTRL,
 			  (S626_SET_CRB_INTRESETCMD(1) |
 			   S626_SET_CRB_INTRESET_A(1)));
 
 	/* Program counter interrupt source. */
-	s626_debi_replace(dev, k->my_cra, ~S626_CRAMSK_INTSRC_A,
+	s626_debi_replace(dev, S626_LP_CRA(k->chan), ~S626_CRAMSK_INTSRC_A,
 			  S626_SET_CRA_INTSRC_A(int_source));
 
 	/* Update MISC2 interrupt enable mask. */
@@ -1177,15 +1180,17 @@ static void s626_set_int_src_b(struct comedi_device *dev,
 	uint16_t crb;
 
 	/* Cache writeable CRB register image. */
-	crb = s626_debi_read(dev, k->my_crb) & ~S626_CRBMSK_INTCTRL;
+	crb = s626_debi_read(dev, S626_LP_CRB(k->chan)) & ~S626_CRBMSK_INTCTRL;
 
 	/* Reset any pending counter overflow or index captures. */
-	s626_debi_write(dev, k->my_crb, (crb | S626_SET_CRB_INTRESETCMD(1) |
-					 S626_SET_CRB_INTRESET_B(1)));
+	s626_debi_write(dev, S626_LP_CRB(k->chan),
+			(crb | S626_SET_CRB_INTRESETCMD(1) |
+			S626_SET_CRB_INTRESET_B(1)));
 
 	/* Program counter interrupt source. */
-	s626_debi_write(dev, k->my_crb, ((crb & ~S626_CRBMSK_INTSRC_B) |
-					 S626_SET_CRB_INTSRC_B(int_source)));
+	s626_debi_write(dev, S626_LP_CRB(k->chan),
+			((crb & ~S626_CRBMSK_INTSRC_B) |
+			S626_SET_CRB_INTSRC_B(int_source)));
 
 	/* Update MISC2 interrupt enable mask. */
 	devpriv->counter_int_enabs =
@@ -1196,13 +1201,15 @@ static void s626_set_int_src_b(struct comedi_device *dev,
 static uint16_t s626_get_int_src_a(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	return S626_GET_CRA_INTSRC_A(s626_debi_read(dev, k->my_cra));
+	return S626_GET_CRA_INTSRC_A(s626_debi_read(dev,
+						    S626_LP_CRA(k->chan)));
 }
 
 static uint16_t s626_get_int_src_b(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	return S626_GET_CRB_INTSRC_B(s626_debi_read(dev, k->my_crb));
+	return S626_GET_CRB_INTSRC_B(s626_debi_read(dev,
+						    S626_LP_CRB(k->chan)));
 }
 
 #ifdef unused
@@ -1295,10 +1302,11 @@ static void s626_pulse_index_a(struct comedi_device *dev,
 {
 	uint16_t cra;
 
-	cra = s626_debi_read(dev, k->my_cra);
+	cra = s626_debi_read(dev, S626_LP_CRA(k->chan));
 	/* Pulse index. */
-	s626_debi_write(dev, k->my_cra, (cra ^ S626_CRAMSK_INDXPOL_A));
-	s626_debi_write(dev, k->my_cra, cra);
+	s626_debi_write(dev, S626_LP_CRA(k->chan),
+			(cra ^ S626_CRAMSK_INDXPOL_A));
+	s626_debi_write(dev, S626_LP_CRA(k->chan), cra);
 }
 
 static void s626_pulse_index_b(struct comedi_device *dev,
@@ -1306,10 +1314,11 @@ static void s626_pulse_index_b(struct comedi_device *dev,
 {
 	uint16_t crb;
 
-	crb = s626_debi_read(dev, k->my_crb) & ~S626_CRBMSK_INTCTRL;
+	crb = s626_debi_read(dev, S626_LP_CRB(k->chan)) & ~S626_CRBMSK_INTCTRL;
 	/* Pulse index. */
-	s626_debi_write(dev, k->my_crb, (crb ^ S626_CRBMSK_INDXPOL_B));
-	s626_debi_write(dev, k->my_crb, crb);
+	s626_debi_write(dev, S626_LP_CRB(k->chan),
+			(crb ^ S626_CRBMSK_INDXPOL_B));
+	s626_debi_write(dev, S626_LP_CRB(k->chan), crb);
 }
 
 static const struct s626_enc_info s626_enc_chan_info[] = {
@@ -1325,8 +1334,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_cra			= S626_LP_CRA(0),
-		.my_crb			= S626_LP_CRB(0),
 		.my_latch_lsw		= S626_LP_CNTR0ALSW,
 		.my_event_bits		= S626_EVBITS(0),
 	}, {
@@ -1341,8 +1348,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_cra			= S626_LP_CRA(1),
-		.my_crb			= S626_LP_CRB(1),
 		.my_latch_lsw		= S626_LP_CNTR1ALSW,
 		.my_event_bits		= S626_EVBITS(1),
 	}, {
@@ -1357,8 +1362,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_cra			= S626_LP_CRA(2),
-		.my_crb			= S626_LP_CRB(2),
 		.my_latch_lsw		= S626_LP_CNTR2ALSW,
 		.my_event_bits		= S626_EVBITS(2),
 	}, {
@@ -1373,8 +1376,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_cra			= S626_LP_CRA(3),
-		.my_crb			= S626_LP_CRB(3),
 		.my_latch_lsw		= S626_LP_CNTR0BLSW,
 		.my_event_bits		= S626_EVBITS(3),
 	}, {
@@ -1389,8 +1390,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_cra			= S626_LP_CRA(4),
-		.my_crb			= S626_LP_CRB(4),
 		.my_latch_lsw		= S626_LP_CNTR1BLSW,
 		.my_event_bits		= S626_EVBITS(4),
 	}, {
@@ -1405,8 +1404,6 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_cra			= S626_LP_CRA(5),
-		.my_crb			= S626_LP_CRB(5),
 		.my_latch_lsw		= S626_LP_CNTR2BLSW,
 		.my_event_bits		= S626_EVBITS(5),
 	},

commit 71961c93a1748cf11e678ec55799a55a93bfb727
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:47 2014 -0700

    staging: comedi: s626: add comedi "chan" number to struct s626_enc_info
    
    Add the comedi "chan" number to the encoder private data so we can then
    remove some of the members of the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 91f96e30ab48..1785aae39ff6 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -104,6 +104,8 @@ struct s626_private {
 
 /* COUNTER OBJECT ------------------------------------------------ */
 struct s626_enc_info {
+	int chan;
+
 	/* Pointers to functions that differ for A and B counters: */
 	/* Return clock enable. */
 	uint16_t (*get_enable)(struct comedi_device *dev,
@@ -1312,6 +1314,7 @@ static void s626_pulse_index_b(struct comedi_device *dev,
 
 static const struct s626_enc_info s626_enc_chan_info[] = {
 	{
+		.chan			= 0,
 		.get_enable		= s626_get_enable_a,
 		.get_int_src		= s626_get_int_src_a,
 		.get_load_trig		= s626_get_load_trig_a,
@@ -1327,6 +1330,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_latch_lsw		= S626_LP_CNTR0ALSW,
 		.my_event_bits		= S626_EVBITS(0),
 	}, {
+		.chan			= 1,
 		.get_enable		= s626_get_enable_a,
 		.get_int_src		= s626_get_int_src_a,
 		.get_load_trig		= s626_get_load_trig_a,
@@ -1342,6 +1346,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_latch_lsw		= S626_LP_CNTR1ALSW,
 		.my_event_bits		= S626_EVBITS(1),
 	}, {
+		.chan			= 2,
 		.get_enable		= s626_get_enable_a,
 		.get_int_src		= s626_get_int_src_a,
 		.get_load_trig		= s626_get_load_trig_a,
@@ -1357,6 +1362,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_latch_lsw		= S626_LP_CNTR2ALSW,
 		.my_event_bits		= S626_EVBITS(2),
 	}, {
+		.chan			= 3,
 		.get_enable		= s626_get_enable_b,
 		.get_int_src		= s626_get_int_src_b,
 		.get_load_trig		= s626_get_load_trig_b,
@@ -1372,6 +1378,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_latch_lsw		= S626_LP_CNTR0BLSW,
 		.my_event_bits		= S626_EVBITS(3),
 	}, {
+		.chan			= 4,
 		.get_enable		= s626_get_enable_b,
 		.get_int_src		= s626_get_int_src_b,
 		.get_load_trig		= s626_get_load_trig_b,
@@ -1387,6 +1394,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_latch_lsw		= S626_LP_CNTR1BLSW,
 		.my_event_bits		= S626_EVBITS(4),
 	}, {
+		.chan			= 5,
 		.get_enable		= s626_get_enable_b,
 		.get_int_src		= s626_get_int_src_b,
 		.get_load_trig		= s626_get_load_trig_b,

commit f114b45a6b14682c55e8c2709e07b1ccf4d727a2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:46 2014 -0700

    staging: comedi: s626: define CRA/CRB registers based on channel number
    
    Start cleaning up the 'struct s626_enc_info' by redefining the my_cra
    and my_crb members based on the comedi channel number.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 0838f8aa6951..91f96e30ab48 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1322,8 +1322,8 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_cra			= S626_LP_CR0A,
-		.my_crb			= S626_LP_CR0B,
+		.my_cra			= S626_LP_CRA(0),
+		.my_crb			= S626_LP_CRB(0),
 		.my_latch_lsw		= S626_LP_CNTR0ALSW,
 		.my_event_bits		= S626_EVBITS(0),
 	}, {
@@ -1337,8 +1337,8 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_cra			= S626_LP_CR1A,
-		.my_crb			= S626_LP_CR1B,
+		.my_cra			= S626_LP_CRA(1),
+		.my_crb			= S626_LP_CRB(1),
 		.my_latch_lsw		= S626_LP_CNTR1ALSW,
 		.my_event_bits		= S626_EVBITS(1),
 	}, {
@@ -1352,8 +1352,8 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_cra			= S626_LP_CR2A,
-		.my_crb			= S626_LP_CR2B,
+		.my_cra			= S626_LP_CRA(2),
+		.my_crb			= S626_LP_CRB(2),
 		.my_latch_lsw		= S626_LP_CNTR2ALSW,
 		.my_event_bits		= S626_EVBITS(2),
 	}, {
@@ -1367,8 +1367,8 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_cra			= S626_LP_CR0A,
-		.my_crb			= S626_LP_CR0B,
+		.my_cra			= S626_LP_CRA(3),
+		.my_crb			= S626_LP_CRB(3),
 		.my_latch_lsw		= S626_LP_CNTR0BLSW,
 		.my_event_bits		= S626_EVBITS(3),
 	}, {
@@ -1382,8 +1382,8 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_cra			= S626_LP_CR1A,
-		.my_crb			= S626_LP_CR1B,
+		.my_cra			= S626_LP_CRA(4),
+		.my_crb			= S626_LP_CRB(4),
 		.my_latch_lsw		= S626_LP_CNTR1BLSW,
 		.my_event_bits		= S626_EVBITS(4),
 	}, {
@@ -1397,8 +1397,8 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_cra			= S626_LP_CR2A,
-		.my_crb			= S626_LP_CR2B,
+		.my_cra			= S626_LP_CRA(5),
+		.my_crb			= S626_LP_CRB(5),
 		.my_latch_lsw		= S626_LP_CNTR2BLSW,
 		.my_event_bits		= S626_EVBITS(5),
 	},

commit c646efe13fd1e76d00b25d1c4ebc7d8053ae907b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:12:59 2014 -0700

    staging: comedi: s626: use comedi_fc helpers to validate timer args
    
    Use the comedi_fc helper cfc_check_trigger_arg_is() to validate the
    trigger arguments when the source is TRIG_TIMER.
    
    Use cfc_check_trigger_arg_min() to vaidate the scan_begin_arg when the
    scan_begin_src and convert_src are both TRIG_TIMER.
    
    All the arguments are unsigned int, change the local variable to an
    unsigned int and rename it for aesthetic reasons.
    
    Change the type of the first parameter to s626_ns_to_timer() to remove
    the need for the casts.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 33b4d027a5cb..0838f8aa6951 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2098,7 +2098,7 @@ static int s626_ai_inttrig(struct comedi_device *dev,
  * Also, it should adjust ns so that it cooresponds to the actual time
  * that the device will use.
  */
-static int s626_ns_to_timer(int *nanosec, int round_mode)
+static int s626_ns_to_timer(unsigned int *nanosec, int round_mode)
 {
 	int divider, base;
 
@@ -2206,7 +2206,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * interval
 		 */
 		k = &s626_enc_chan_info[5];
-		tick = s626_ns_to_timer((int *)&cmd->scan_begin_arg,
+		tick = s626_ns_to_timer(&cmd->scan_begin_arg,
 					cmd->flags & TRIG_ROUND_MASK);
 
 		/* load timer value and enable interrupt */
@@ -2229,7 +2229,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * interval
 		 */
 		k = &s626_enc_chan_info[4];
-		tick = s626_ns_to_timer((int *)&cmd->convert_arg,
+		tick = s626_ns_to_timer(&cmd->convert_arg,
 					cmd->flags & TRIG_ROUND_MASK);
 
 		/* load timer value and enable interrupt */
@@ -2288,7 +2288,7 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int tmp;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -2371,24 +2371,20 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		tmp = cmd->scan_begin_arg;
-		s626_ns_to_timer((int *)&cmd->scan_begin_arg,
-				 cmd->flags & TRIG_ROUND_MASK);
-		if (tmp != cmd->scan_begin_arg)
-			err++;
+		arg = cmd->scan_begin_arg;
+		s626_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
+
 	if (cmd->convert_src == TRIG_TIMER) {
-		tmp = cmd->convert_arg;
-		s626_ns_to_timer((int *)&cmd->convert_arg,
-				 cmd->flags & TRIG_ROUND_MASK);
-		if (tmp != cmd->convert_arg)
-			err++;
-		if (cmd->scan_begin_src == TRIG_TIMER &&
-		    cmd->scan_begin_arg < cmd->convert_arg *
-					  cmd->scan_end_arg) {
-			cmd->scan_begin_arg = cmd->convert_arg *
-					      cmd->scan_end_arg;
-			err++;
+		arg = cmd->convert_arg;
+		s626_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+
+		if (cmd->scan_begin_src == TRIG_TIMER) {
+			arg = cmd->convert_arg * cmd->scan_end_arg;
+			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+							 arg);
 		}
 	}
 

commit 3672effdeae5395d661a2103f69082146ef949fc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:11:59 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_put()
    
    Change the parameters of `comedi_buf_put()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function puts a sample value in the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 647b9e50bd74..33b4d027a5cb 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1628,7 +1628,6 @@ static bool s626_handle_eos_interrupt(struct comedi_device *dev)
 		readaddr++;
 
 		/* put data into read buffer */
-		/* comedi_buf_put(async, tempdata); */
 		cfc_write_to_buffer(s, tempdata);
 	}
 

commit 478da5c9ad51c48653b395b64d4c62a616dfb872
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:08:07 2014 -0700

    staging: comedi: s626: clarify the cmd->start_arg validation and use
    
    This driver supports a cmd->start_src of TRIG_NOW, TRIG_INT or TRIG_EXT.
    
    Clarify the cmd->start_arg validation in Step 3 of the (*do_cmdtest).
    
    For a TRIG_INT source, the cmd->start_arg is actually the valid
    trig_num that is used by the async (*inttrig) callback.
    
    Refactor the (*inttrig) function so that the cmd->start_arg is used
    to check the trig_num instead of the open coded value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6da43de51eb3..647b9e50bd74 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2076,9 +2076,12 @@ static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)
 }
 
 static int s626_ai_inttrig(struct comedi_device *dev,
-			   struct comedi_subdevice *s, unsigned int trignum)
+			   struct comedi_subdevice *s,
+			   unsigned int trig_num)
 {
-	if (trignum != 0)
+	struct comedi_cmd *cmd = &s->async->cmd;
+
+	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
 	/* Start executing the RPS program */
@@ -2314,12 +2317,18 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_src != TRIG_EXT)
+	switch (cmd->start_src) {
+	case TRIG_NOW:
+	case TRIG_INT:
 		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
-	if (cmd->start_src == TRIG_EXT)
+		break;
+	case TRIG_EXT:
 		err |= cfc_check_trigger_arg_max(&cmd->start_arg, 39);
+		break;
+	}
+
 	if (cmd->scan_begin_src == TRIG_EXT)
 		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 39);
 	if (cmd->convert_src == TRIG_EXT)

commit 571845c6f47de51a41ab7964a144b22d297d06ce
Author: Chase Southwood <chase.southwood@yahoo.com>
Date:   Thu Apr 3 18:43:27 2014 -0500

    staging: comedi: s626: use comedi_timeout() on remaining loops
    
    There were just a handful of more while loops in this file that needed
    timeouts, and this patch takes care of them.  One new callback is
    introduced, and all of the proper comedi_timeout() calls are then used.
    The return type of s626_i2c_handshake() has been changed from uint32_t to
    int so that a negative error code from comedi_timeout() can be propagated
    if necessary.
    
    Signed-off-by: Chase Southwood <chase.southwood@yahoo.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 95fadf343f27..6da43de51eb3 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -295,10 +295,24 @@ static void s626_debi_replace(struct comedi_device *dev, unsigned int addr,
 
 /* **************  EEPROM ACCESS FUNCTIONS  ************** */
 
-static uint32_t s626_i2c_handshake(struct comedi_device *dev, uint32_t val)
+static int s626_i2c_handshake_eoc(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned long context)
+{
+	bool status;
+
+	status = s626_mc_test(dev, S626_MC2_UPLD_IIC, S626_P_MC2);
+	if (status)
+		return 0;
+	return -EBUSY;
+}
+
+static int s626_i2c_handshake(struct comedi_device *dev, uint32_t val)
 {
 	struct s626_private *devpriv = dev->private;
 	unsigned int ctrl;
+	int ret;
 
 	/* Write I2C command to I2C Transfer Control shadow register */
 	writel(val, devpriv->mmio + S626_P_I2CCTRL);
@@ -308,8 +322,9 @@ static uint32_t s626_i2c_handshake(struct comedi_device *dev, uint32_t val)
 	 * wait for upload confirmation.
 	 */
 	s626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);
-	while (!s626_mc_test(dev, S626_MC2_UPLD_IIC, S626_P_MC2))
-		;
+	ret = comedi_timeout(dev, NULL, NULL, s626_i2c_handshake_eoc, 0);
+	if (ret)
+		return ret;
 
 	/* Wait until I2C bus transfer is finished or an error occurs */
 	do {
@@ -2029,8 +2044,9 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	/* Wait for the data to arrive in FB BUFFER 1 register. */
 
 	/* Wait for ADC done */
-	while (!(readl(devpriv->mmio + S626_P_PSR) & S626_PSR_GPIO2))
-		;
+	ret = comedi_timeout(dev, s, insn, s626_ai_eoc, 0);
+	if (ret)
+		return ret;
 
 	/* Fetch ADC data from audio interface's input shift register. */
 
@@ -2681,8 +2697,9 @@ static int s626_initialize(struct comedi_device *dev)
 	writel(S626_I2C_CLKSEL | S626_I2C_ABORT,
 	       devpriv->mmio + S626_P_I2CSTAT);
 	s626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);
-	while (!(readl(devpriv->mmio + S626_P_MC2) & S626_MC2_UPLD_IIC))
-		;
+	ret = comedi_timeout(dev, NULL, NULL, s626_i2c_handshake_eoc, 0);
+	if (ret)
+		return ret;
 
 	/*
 	 * Per SAA7146 data sheet, write to STATUS
@@ -2691,8 +2708,9 @@ static int s626_initialize(struct comedi_device *dev)
 	for (i = 0; i < 2; i++) {
 		writel(S626_I2C_CLKSEL, devpriv->mmio + S626_P_I2CSTAT);
 		s626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);
-		while (!s626_mc_test(dev, S626_MC2_UPLD_IIC, S626_P_MC2))
-			;
+		ret = comedi_timeout(dev, NULL, NULL, s626_i2c_handshake_eoc, 0);
+		if (ret)
+			return ret;
 	}
 
 	/*

commit 3df1d9bddf64031e3196b912f3f37828f045565b
Author: Ebru Akagunduz <ebru.akagunduz@gmail.com>
Date:   Wed Mar 19 00:13:58 2014 +0200

    Staging: comedi: Fix line over 80 characters in s626.c
    
    Fix checkpatch.pl issues line over 80 characters
    in s626.c
    
    Signed-off-by: Ebru Akagunduz <ebru.akagunduz@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 282d8d393353..95fadf343f27 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -225,7 +225,8 @@ static void s626_debi_transfer(struct comedi_device *dev)
 		udelay(1);
 	}
 	if (i == timeout)
-		comedi_error(dev, "Timeout while uploading to DEBI control register.");
+		comedi_error(dev,
+			"Timeout while uploading to DEBI control register.");
 
 	/* Wait until DEBI transfer is done */
 	for (i = 0; i < timeout; i++) {
@@ -532,7 +533,8 @@ static int s626_send_dac(struct comedi_device *dev, uint32_t val)
 		ret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,
 				     s626_send_dac_wait_fb_buffer2_msb_00);
 		if (ret) {
-			comedi_error(dev, "TSL timeout waiting for slot 0 to execute.");
+			comedi_error(dev,
+				"TSL timeout waiting for slot 0 to execute.");
 			return ret;
 		}
 	}

commit fbdc4001e3dc9e5bec86828654c9c8fe653abf0a
Author: Ebru Akagunduz <ebru.akagunduz@gmail.com>
Date:   Wed Mar 19 00:13:57 2014 +0200

    Staging: comedi: Fix missing space after return type in s626.c
    
    Fix checkpatch.pl issues with missing space after
    return type in s626.c
    
    Signed-off-by: Ebru Akagunduz <ebru.akagunduz@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6518a4c8ade3..282d8d393353 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -106,16 +106,16 @@ struct s626_private {
 struct s626_enc_info {
 	/* Pointers to functions that differ for A and B counters: */
 	/* Return clock enable. */
-	uint16_t(*get_enable)(struct comedi_device *dev,
+	uint16_t (*get_enable)(struct comedi_device *dev,
 			      const struct s626_enc_info *k);
 	/* Return interrupt source. */
-	uint16_t(*get_int_src)(struct comedi_device *dev,
+	uint16_t (*get_int_src)(struct comedi_device *dev,
 			       const struct s626_enc_info *k);
 	/* Return preload trigger source. */
-	uint16_t(*get_load_trig)(struct comedi_device *dev,
+	uint16_t (*get_load_trig)(struct comedi_device *dev,
 				 const struct s626_enc_info *k);
 	/* Return standardized operating mode. */
-	uint16_t(*get_mode)(struct comedi_device *dev,
+	uint16_t (*get_mode)(struct comedi_device *dev,
 			    const struct s626_enc_info *k);
 	/* Generate soft index strobe. */
 	void (*pulse_index)(struct comedi_device *dev,

commit a7aa94ce7982d31b8e67efdc765923c19ed3cc8b
Author: Chase Southwood <chase.southwood@yahoo.com>
Date:   Fri Mar 7 19:43:17 2014 -0600

    Staging: comedi: propagate timeout errors in s626.c
    
    This patch for s626.c propagates the errors from the newly introduced
    calls to comedi_timeout() as far as possible.
    
    Signed-off-by: Chase Southwood <chase.southwood@yahoo.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index fab8ccfa16a9..6518a4c8ade3 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -410,7 +410,7 @@ static int s626_send_dac_eoc(struct comedi_device *dev,
  * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
  * dacpol contains valid target image.
  */
-static void s626_send_dac(struct comedi_device *dev, uint32_t val)
+static int s626_send_dac(struct comedi_device *dev, uint32_t val)
 {
 	struct s626_private *devpriv = dev->private;
 	int ret;
@@ -461,8 +461,10 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 */
 	ret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,
 			     s626_send_dac_wait_not_mc1_a2out);
-	if (ret)
+	if (ret) {
 		comedi_error(dev, "DMA transfer timeout.");
+		return ret;
+	}
 
 	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
 
@@ -484,8 +486,10 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 */
 	ret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,
 			     s626_send_dac_wait_ssr_af2_out);
-	if (ret)
+	if (ret) {
 		comedi_error(dev, "TSL timeout waiting for slot 1 to execute.");
+		return ret;
+	}
 
 	/*
 	 * Set up to trap execution at slot 0 when the TSL sequencer cycles
@@ -527,8 +531,10 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 		 */
 		ret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,
 				     s626_send_dac_wait_fb_buffer2_msb_00);
-		if (ret)
+		if (ret) {
 			comedi_error(dev, "TSL timeout waiting for slot 0 to execute.");
+			return ret;
+		}
 	}
 	/*
 	 * Either (1) we were too late setting the slot 0 trap; the TSL
@@ -549,14 +555,17 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 */
 	ret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,
 			     s626_send_dac_wait_fb_buffer2_msb_ff);
-	if (ret)
+	if (ret) {
 		comedi_error(dev, "TSL timeout waiting for slot 0 to execute.");
+		return ret;
+	}
+	return 0;
 }
 
 /*
  * Private helper function: Write setpoint to an application DAC channel.
  */
-static void s626_set_dac(struct comedi_device *dev, uint16_t chan,
+static int s626_set_dac(struct comedi_device *dev, uint16_t chan,
 			 int16_t dacdata)
 {
 	struct s626_private *devpriv = dev->private;
@@ -619,10 +628,10 @@ static void s626_set_dac(struct comedi_device *dev, uint16_t chan,
 	val |= ((uint32_t)(chan & 1) << 15);	/* Address the DAC channel
 						 * within the device. */
 	val |= (uint32_t)dacdata;	/* Include DAC setpoint data. */
-	s626_send_dac(dev, val);
+	return s626_send_dac(dev, val);
 }
 
-static void s626_write_trim_dac(struct comedi_device *dev, uint8_t logical_chan,
+static int s626_write_trim_dac(struct comedi_device *dev, uint8_t logical_chan,
 				uint8_t dac_data)
 {
 	struct s626_private *devpriv = dev->private;
@@ -669,17 +678,22 @@ static void s626_write_trim_dac(struct comedi_device *dev, uint8_t logical_chan,
 	 * Address the DAC channel within the trimdac device.
 	 * Include DAC setpoint data.
 	 */
-	s626_send_dac(dev, (chan << 8) | dac_data);
+	return s626_send_dac(dev, (chan << 8) | dac_data);
 }
 
-static void s626_load_trim_dacs(struct comedi_device *dev)
+static int s626_load_trim_dacs(struct comedi_device *dev)
 {
 	uint8_t i;
+	int ret;
 
 	/* Copy TrimDac setpoint values from EEPROM to TrimDacs. */
-	for (i = 0; i < ARRAY_SIZE(s626_trimchan); i++)
-		s626_write_trim_dac(dev, i,
+	for (i = 0; i < ARRAY_SIZE(s626_trimchan); i++) {
+		ret = s626_write_trim_dac(dev, i,
 				    s626_i2c_read(dev, s626_trimadrs[i]));
+		if (ret)
+			return ret;
+	}
+	return 0;
 }
 
 /* ******  COUNTER FUNCTIONS  ******* */
@@ -2378,6 +2392,7 @@ static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 {
 	struct s626_private *devpriv = dev->private;
 	int i;
+	int ret;
 	uint16_t chan = CR_CHAN(insn->chanspec);
 	int16_t dacdata;
 
@@ -2386,7 +2401,9 @@ static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		devpriv->ao_readback[CR_CHAN(insn->chanspec)] = data[i];
 		dacdata -= (0x1fff);
 
-		s626_set_dac(dev, chan, dacdata);
+		ret = s626_set_dac(dev, chan, dacdata);
+		if (ret)
+			return ret;
 	}
 
 	return i;
@@ -2622,12 +2639,13 @@ static int s626_allocate_dma_buffers(struct comedi_device *dev)
 	return 0;
 }
 
-static void s626_initialize(struct comedi_device *dev)
+static int s626_initialize(struct comedi_device *dev)
 {
 	struct s626_private *devpriv = dev->private;
 	dma_addr_t phys_buf;
 	uint16_t chan;
 	int i;
+	int ret;
 
 	/* Enable DEBI and audio pins, enable I2C interface */
 	s626_mc_enable(dev, S626_MC1_DEBI | S626_MC1_AUDIO | S626_MC1_I2C,
@@ -2828,7 +2846,9 @@ static void s626_initialize(struct comedi_device *dev)
 	 * sometimes causes the first few TrimDAC writes to malfunction.
 	 */
 	s626_load_trim_dacs(dev);
-	s626_load_trim_dacs(dev);
+	ret = s626_load_trim_dacs(dev);
+	if (ret)
+		return ret;
 
 	/*
 	 * Manually init all gate array hardware in case this is a soft
@@ -2842,8 +2862,11 @@ static void s626_initialize(struct comedi_device *dev)
 	 * Init all DAC outputs to 0V and init all DAC setpoint and
 	 * polarity images.
 	 */
-	for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
-		s626_set_dac(dev, chan, 0);
+	for (chan = 0; chan < S626_DAC_CHANNELS; chan++) {
+		ret = s626_set_dac(dev, chan, 0);
+		if (ret)
+			return ret;
+	}
 
 	/* Init counters */
 	s626_counters_init(dev);
@@ -2859,6 +2882,8 @@ static void s626_initialize(struct comedi_device *dev)
 
 	/* Initialize the digital I/O subsystem */
 	s626_dio_init(dev);
+
+	return 0;
 }
 
 static int s626_auto_attach(struct comedi_device *dev,
@@ -2979,7 +3004,9 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->insn_read	= s626_enc_insn_read;
 	s->insn_write	= s626_enc_insn_write;
 
-	s626_initialize(dev);
+	ret = s626_initialize(dev);
+	if (ret)
+		return ret;
 
 	return 0;
 }

commit 59a32a4624d81a014fecbeb31e63946984dbbc01
Author: Chase Southwood <chase.southwood@yahoo.com>
Date:   Sat Mar 8 22:00:54 2014 -0600

    Staging: comedi: convert while loops to timeouts in s626.c
    
    This patch changes a handful of while loops to timeouts to prevent
    infinite looping on hardware failure. A couple such loops are in a
    function (s626_debi_transfer()) which is called from critical sections,
    so comedi_timeout() is unusable for them, and an iterative timeout is
    used instead. For the while loops in a context where comedi_timeout() is
    allowed, a new callback function, s626_send_dac_eoc(), has been defined
    to evaluate the conditions that the while loops are testing.  The new
    callback employs a switch statement based on a simple new enum so that
    it is usable for all of the different conditions tested in while loops
    in s626_send_dac().  The proper comedi_timeout() calls are then used.
    
    Signed-off-by: Chase Southwood <chase.southwood@yahoo.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 5ba4b4ae6507..fab8ccfa16a9 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -209,6 +209,8 @@ static const struct comedi_lrange s626_range_table = {
 static void s626_debi_transfer(struct comedi_device *dev)
 {
 	struct s626_private *devpriv = dev->private;
+	static const int timeout = 10000;
+	int i;
 
 	/* Initiate upload of shadow RAM to DEBI control register */
 	s626_mc_enable(dev, S626_MC2_UPLD_DEBI, S626_P_MC2);
@@ -217,12 +219,22 @@ static void s626_debi_transfer(struct comedi_device *dev)
 	 * Wait for completion of upload from shadow RAM to
 	 * DEBI control register.
 	 */
-	while (!s626_mc_test(dev, S626_MC2_UPLD_DEBI, S626_P_MC2))
-		;
+	for (i = 0; i < timeout; i++) {
+		if (s626_mc_test(dev, S626_MC2_UPLD_DEBI, S626_P_MC2))
+			break;
+		udelay(1);
+	}
+	if (i == timeout)
+		comedi_error(dev, "Timeout while uploading to DEBI control register.");
 
 	/* Wait until DEBI transfer is done */
-	while (readl(devpriv->mmio + S626_P_PSR) & S626_PSR_DEBI_S)
-		;
+	for (i = 0; i < timeout; i++) {
+		if (!(readl(devpriv->mmio + S626_P_PSR) & S626_PSR_DEBI_S))
+			break;
+		udelay(1);
+	}
+	if (i == timeout)
+		comedi_error(dev, "DEBI transfer timeout.");
 }
 
 /*
@@ -351,6 +363,48 @@ static const uint8_t s626_trimadrs[] = {
 	0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63
 };
 
+enum {
+	s626_send_dac_wait_not_mc1_a2out,
+	s626_send_dac_wait_ssr_af2_out,
+	s626_send_dac_wait_fb_buffer2_msb_00,
+	s626_send_dac_wait_fb_buffer2_msb_ff
+};
+
+static int s626_send_dac_eoc(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn,
+			     unsigned long context)
+{
+	struct s626_private *devpriv = dev->private;
+	unsigned int status;
+
+	switch (context) {
+	case s626_send_dac_wait_not_mc1_a2out:
+		status = readl(devpriv->mmio + S626_P_MC1);
+		if (!(status & S626_MC1_A2OUT))
+			return 0;
+		break;
+	case s626_send_dac_wait_ssr_af2_out:
+		status = readl(devpriv->mmio + S626_P_SSR);
+		if (status & S626_SSR_AF2_OUT)
+			return 0;
+		break;
+	case s626_send_dac_wait_fb_buffer2_msb_00:
+		status = readl(devpriv->mmio + S626_P_FB_BUFFER2);
+		if (!(status & 0xff000000))
+			return 0;
+		break;
+	case s626_send_dac_wait_fb_buffer2_msb_ff:
+		status = readl(devpriv->mmio + S626_P_FB_BUFFER2);
+		if (status & 0xff000000)
+			return 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return -EBUSY;
+}
+
 /*
  * Private helper function: Transmit serial data to DAC via Audio
  * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
@@ -359,6 +413,7 @@ static const uint8_t s626_trimadrs[] = {
 static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 {
 	struct s626_private *devpriv = dev->private;
+	int ret;
 
 	/* START THE SERIAL CLOCK RUNNING ------------- */
 
@@ -404,8 +459,10 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * Done by polling the DMAC enable flag; this flag is automatically
 	 * cleared when the transfer has finished.
 	 */
-	while (readl(devpriv->mmio + S626_P_MC1) & S626_MC1_A2OUT)
-		;
+	ret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,
+			     s626_send_dac_wait_not_mc1_a2out);
+	if (ret)
+		comedi_error(dev, "DMA transfer timeout.");
 
 	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
 
@@ -425,8 +482,10 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * finished transferring the DAC's data DWORD from the output FIFO
 	 * to the output buffer register.
 	 */
-	while (!(readl(devpriv->mmio + S626_P_SSR) & S626_SSR_AF2_OUT))
-		;
+	ret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,
+			     s626_send_dac_wait_ssr_af2_out);
+	if (ret)
+		comedi_error(dev, "TSL timeout waiting for slot 1 to execute.");
 
 	/*
 	 * Set up to trap execution at slot 0 when the TSL sequencer cycles
@@ -466,8 +525,10 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
 		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
 		 */
-		while (readl(devpriv->mmio + S626_P_FB_BUFFER2) & 0xff000000)
-			;
+		ret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,
+				     s626_send_dac_wait_fb_buffer2_msb_00);
+		if (ret)
+			comedi_error(dev, "TSL timeout waiting for slot 0 to execute.");
 	}
 	/*
 	 * Either (1) we were too late setting the slot 0 trap; the TSL
@@ -486,8 +547,10 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
 	 * from 0x00 to 0xFF.
 	 */
-	while (!(readl(devpriv->mmio + S626_P_FB_BUFFER2) & 0xff000000))
-		;
+	ret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,
+			     s626_send_dac_wait_fb_buffer2_msb_ff);
+	if (ret)
+		comedi_error(dev, "TSL timeout waiting for slot 0 to execute.");
 }
 
 /*

commit 45b281e457dc5e80650ca6808fb08df49b677f03
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:37 2014 -0700

    staging: comedi: s626: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input end-of-conversion.
    
    This prevents a deadlock condition that could occur by providing a
    timeout in case the end-of-conversion does not happen.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 9e711ee13bb7..5ba4b4ae6507 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1846,6 +1846,20 @@ static int s626_ai_rinsn(struct comedi_device *dev,
 }
 #endif
 
+static int s626_ai_eoc(struct comedi_device *dev,
+		       struct comedi_subdevice *s,
+		       struct comedi_insn *insn,
+		       unsigned long context)
+{
+	struct s626_private *devpriv = dev->private;
+	unsigned int status;
+
+	status = readl(devpriv->mmio + S626_P_PSR);
+	if (status & S626_PSR_GPIO2)
+		return 0;
+	return -EBUSY;
+}
+
 static int s626_ai_insn_read(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
@@ -1856,6 +1870,7 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	uint16_t adc_spec = 0;
 	uint32_t gpio_image;
 	uint32_t tmp;
+	int ret;
 	int n;
 
 	/*
@@ -1897,8 +1912,9 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 		 */
 
 		/* Wait for ADC done */
-		while (!(readl(devpriv->mmio + S626_P_PSR) & S626_PSR_GPIO2))
-			;
+		ret = comedi_timeout(dev, s, insn, s626_ai_eoc, 0);
+		if (ret)
+			return ret;
 
 		/* Fetch ADC data */
 		if (n != 0) {

commit c93999c21319439c4fe2da85f2ec40ed477379ac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 3 11:26:50 2014 -0700

    staging: comedi: drivers: remove final 'attach' messages
    
    These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 19da1dbea494..9e711ee13bb7 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2902,8 +2902,6 @@ static int s626_auto_attach(struct comedi_device *dev,
 
 	s626_initialize(dev);
 
-	dev_info(dev->class_dev, "%s attached\n", dev->board_name);
-
 	return 0;
 }
 

commit 481ac510257eee7c258d19021f750ab0ead7cab4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:31:28 2013 -0700

    staging: comedi: s626: tidy up comedi_lrange table
    
    The comedi_lrange tables are fixed length based on the 'length' value
    before the array of comedi_krange 'range' values. For aesthetics, remove
    the trailing comma from last 'range' value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index ae13b0ee725b..19da1dbea494 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -199,7 +199,7 @@ static bool s626_mc_test(struct comedi_device *dev,
 static const struct comedi_lrange s626_range_table = {
 	2, {
 		BIP_RANGE(5),
-		BIP_RANGE(10),
+		BIP_RANGE(10)
 	}
 };
 

commit 9c9ab3c1a477aa3f8bdb91f51061e567867d4c60
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 13:43:39 2013 -0700

    staging: comedi: s626: use dev->read_subdev
    
    Use the dev->read_subdev that was setup in the device attach instead
    of accessing the dev->subdevices array directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 583583854dca..ae13b0ee725b 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1614,12 +1614,13 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
 {
 	struct s626_private *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	uint32_t *rps;
 	uint32_t jmp_adrs;
 	uint16_t i;
 	uint16_t n;
 	uint32_t local_ppl;
-	struct comedi_cmd *cmd = &dev->subdevices->async->cmd;
 
 	/* Stop RPS program in case it is currently running */
 	s626_mc_disable(dev, S626_MC1_ERPS1, S626_P_MC1);
@@ -2639,6 +2640,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * a defined state after a PCI reset.
 	 */
 	{
+		struct comedi_subdevice *s = dev->read_subdev;
 		uint8_t poll_list;
 		uint16_t adc_data;
 		uint16_t start_val;
@@ -2650,7 +2652,7 @@ static void s626_initialize(struct comedi_device *dev)
 		s626_reset_adc(dev, &poll_list);
 
 		/* Get initial ADC value */
-		s626_ai_rinsn(dev, dev->subdevices, NULL, data);
+		s626_ai_rinsn(dev, s, NULL, data);
 		start_val = data[0];
 
 		/*
@@ -2664,7 +2666,7 @@ static void s626_initialize(struct comedi_device *dev)
 		 * being unusually quiet or at the rail.
 		 */
 		for (index = 0; index < 500; index++) {
-			s626_ai_rinsn(dev, dev->subdevices, NULL, data);
+			s626_ai_rinsn(dev, s, NULL, data);
 			adc_data = data[0];
 			if (adc_data != start_val)
 				break;

commit f95321f33af8b75cce171ba18e5fa04ed1fcb88f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Dec 3 12:07:10 2013 -0700

    staging: comedi: s626: fix async command hookup
    
    Only set the SDF_CMD_READ subdev_flag if the irq was sucessfully
    requested.
    
    Remove the unnecessary sanity check of dev->irq in s626_ai_cmd().
    This callback is only hooked up if the irq is available.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6d266235ae4f..583583854dca 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2079,12 +2079,6 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd == NULL)
 		return -EINVAL;
 
-	if (dev->irq == 0) {
-		comedi_error(dev,
-			     "s626_ai_cmd: cannot run command without an irq");
-		return -EIO;
-	}
-
 	s626_ai_load_polllist(ppl, cmd);
 	devpriv->ai_cmd_running = 1;
 	devpriv->ai_convert_count = 0;
@@ -2833,7 +2827,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s = &dev->subdevices[0];
 	/* analog input subdevice */
 	s->type		= COMEDI_SUBD_AI;
-	s->subdev_flags	= SDF_READABLE | SDF_DIFF | SDF_CMD_READ;
+	s->subdev_flags	= SDF_READABLE | SDF_DIFF;
 	s->n_chan	= S626_ADC_CHANNELS;
 	s->maxdata	= 0x3fff;
 	s->range_table	= &s626_range_table;
@@ -2841,6 +2835,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->insn_read	= s626_ai_insn_read;
 	if (dev->irq) {
 		dev->read_subdev = s;
+		s->subdev_flags	|= SDF_CMD_READ;
 		s->do_cmd	= s626_ai_cmd;
 		s->do_cmdtest	= s626_ai_cmdtest;
 		s->cancel	= s626_ai_cancel;

commit 41e043fcfa2236bb2c4a8335eb09f4c8cee224b3
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Dec 3 08:26:00 2013 +0900

    staging: remove DEFINE_PCI_DEVICE_TABLE macro
    
    Don't use DEFINE_PCI_DEVICE_TABLE macro, because this macro
    is not preferred.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index b486099b543d..6d266235ae4f 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2965,7 +2965,7 @@ static int s626_pci_probe(struct pci_dev *dev,
  * also subvendor:subdevice ids, because otherwise it will conflict with
  * Philips SAA7146 media/dvb based cards.
  */
-static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
+static const struct pci_device_id s626_pci_table[] = {
 	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_PHILIPS, PCI_DEVICE_ID_PHILIPS_SAA7146,
 			 0x6000, 0x0272) },
 	{ 0 }

commit 3de00ee4ce6a61ce7b72fd50a8af47957a7b53a8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Nov 6 20:45:59 2013 +0000

    staging: comedi: s626: fix value written by s626_set_dac()
    
    I broke `s626_set_dac()` by changing the type of the `dacdata` parameter
    from `short` to `unsigned short`.  It's actually designed to take a
    signed value in the range -0x1fff to +0x2000 although values above
    0x1fff get clamped to 0x1fff.  (We could change the `maxdata` value to
    0x1ffe to avoid the clamping, but `maxdata` values are usually a power
    of 2 minus 1.)  The bug results in all negative values passed to the
    function being changed to +0x1fff by the clamp.  Change the parameter
    type to `int16_t` to fix the problem.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6815cfe2664e..b486099b543d 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -494,7 +494,7 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
  * Private helper function: Write setpoint to an application DAC channel.
  */
 static void s626_set_dac(struct comedi_device *dev, uint16_t chan,
-			 unsigned short dacdata)
+			 int16_t dacdata)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t signmask;

commit 7a1046e5c0fdce80ba075c2edd8a97b7485693ce
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 21 10:10:39 2013 +0100

    staging: comedi: s626: replace S626_MULT_X? values
    
    Replace the use of the `S626_MULT_X1`, `S626_MULT_X2` and `S626_MULT_X4`
    clock multiplier values with the equivalent `S626_CLKMULT_1X`,
    `S626_CLKMULT_2X` and `S626_CLKMULT_4X` values to avoid duplication.
    Replace the use of `S626_MULT_X0` with a new macro
    `S626_CLKMULT_SPECIAL` (this is treated specially by the
    'ClkMultA'/'ClkMultB' field of the 'CRA'/'CRB' register).  Remove the
    now unused `S626_MULT_X?` macros.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index c2837da862db..6815cfe2664e 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -731,7 +731,7 @@ static uint16_t s626_get_mode_a(struct comedi_device *dev,
 		/* Set ClkPol to indicate count direction (CntSrcA<0>). */
 		clkpol = cntsrc & 1;
 		/* ClkMult must be 1x in Timer mode. */
-		clkmult = S626_MULT_X1;
+		clkmult = S626_CLKMULT_1X;
 	} else {
 		/* Counter mode (CntSrcA<1> == 0): */
 		encmode = S626_ENCMODE_COUNTER;
@@ -739,8 +739,8 @@ static uint16_t s626_get_mode_a(struct comedi_device *dev,
 		clkpol = S626_GET_CRA_CLKPOL_A(cra);
 		/* Force ClkMult to 1x if not legal, else pass through. */
 		clkmult = S626_GET_CRA_CLKMULT_A(cra);
-		if (clkmult == S626_MULT_X0)
-			clkmult = S626_MULT_X1;
+		if (clkmult == S626_CLKMULT_SPECIAL)
+			clkmult = S626_CLKMULT_1X;
 	}
 	setup |= S626_SET_STD_ENCMODE(encmode) | S626_SET_STD_CLKMULT(clkmult) |
 		 S626_SET_STD_CLKPOL(clkpol);
@@ -781,18 +781,18 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 	/* Adjust mode-dependent parameters. */
 	cntsrc = S626_GET_CRA_CNTSRC_B(cra);
 	clkmult = S626_GET_CRB_CLKMULT_B(crb);
-	if (clkmult == S626_MULT_X0) {
-		/* Extender mode (ClkMultB == S626_MULT_X0): */
+	if (clkmult == S626_CLKMULT_SPECIAL) {
+		/* Extender mode (ClkMultB == S626_CLKMULT_SPECIAL): */
 		encmode = S626_ENCMODE_EXTENDER;
 		/* Indicate multiplier is 1x. */
-		clkmult = S626_MULT_X1;
+		clkmult = S626_CLKMULT_1X;
 		/* Set ClkPol equal to Timer count direction (CntSrcB<0>). */
 		clkpol = cntsrc & 1;
 	} else if (cntsrc & S626_CNTSRC_SYSCLK) {
 		/* Timer mode (CntSrcB<1> == 1): */
 		encmode = S626_ENCMODE_TIMER;
 		/* Indicate multiplier is 1x. */
-		clkmult = S626_MULT_X1;
+		clkmult = S626_CLKMULT_1X;
 		/* Set ClkPol equal to Timer count direction (CntSrcB<0>). */
 		clkpol = cntsrc & 1;
 	} else {
@@ -853,7 +853,7 @@ static void s626_set_mode_a(struct comedi_device *dev,
 		/* ClkPolA behaves as always-on clock enable. */
 		clkpol = 1;
 		/* ClkMult must be 1x. */
-		clkmult = S626_MULT_X1;
+		clkmult = S626_CLKMULT_1X;
 		break;
 	default:		/* Counter Mode: */
 		/* Select ENC_C and ENC_D as clock/direction inputs. */
@@ -861,8 +861,8 @@ static void s626_set_mode_a(struct comedi_device *dev,
 		/* Clock polarity is passed through. */
 		/* Force multiplier to x1 if not legal, else pass through. */
 		clkmult = S626_GET_STD_CLKMULT(setup);
-		if (clkmult == S626_MULT_X0)
-			clkmult = S626_MULT_X1;
+		if (clkmult == S626_CLKMULT_SPECIAL)
+			clkmult = S626_CLKMULT_1X;
 		break;
 	}
 	cra |= S626_SET_CRA_CNTSRC_A(cntsrc) | S626_SET_CRA_CLKPOL_A(clkpol) |
@@ -927,7 +927,7 @@ static void s626_set_mode_b(struct comedi_device *dev,
 		/* ClkPolB behaves as always-on clock enable. */
 		clkpol = 1;
 		/* ClkMultB must be 1x. */
-		clkmult = S626_MULT_X1;
+		clkmult = S626_CLKMULT_1X;
 		break;
 	case S626_ENCMODE_EXTENDER:	/* Extender Mode: */
 		/* CntSrcB source is OverflowA (same as "timer") */
@@ -937,7 +937,7 @@ static void s626_set_mode_b(struct comedi_device *dev,
 		/* ClkPolB controls IndexB -- always set to active. */
 		clkpol = 1;
 		/* ClkMultB selects OverflowA as the clock source. */
-		clkmult = S626_MULT_X0;
+		clkmult = S626_CLKMULT_SPECIAL;
 		break;
 	default:		/* Counter Mode: */
 		/* Select ENC_C and ENC_D as clock/direction inputs. */
@@ -945,8 +945,8 @@ static void s626_set_mode_b(struct comedi_device *dev,
 		/* ClkPol is passed through. */
 		/* Force ClkMult to x1 if not legal, otherwise pass through. */
 		clkmult = S626_GET_STD_CLKMULT(setup);
-		if (clkmult == S626_MULT_X0)
-			clkmult = S626_MULT_X1;
+		if (clkmult == S626_CLKMULT_SPECIAL)
+			clkmult = S626_CLKMULT_1X;
 		break;
 	}
 	cra |= S626_SET_CRA_CNTSRC_B(cntsrc);

commit 2cea19faf16304125ce12e4b5518110ef77f32a1
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 21 10:10:37 2013 +0100

    staging: comedi: s626: expand standardized IndxSrc values
    
    The 'IndxSrc' value for the standardized encoder setup is currently 1
    bit wide and takes one of the following values:
    
      S626_INDXSRC_HARD = 0 // index source from hardware encoder
      S626_INDXSRC_SOFT = 1 // index source software controlled by IndxPol
    
    However the hardware 'IndxSrcA' and 'IndxSrcB' values for the 'A' and
    'B' counters are 2 bits wide.  The above standardized values 0 and 1
    correspond to the hardware values 0 and 2.
    
    In order to simplify conversions between the standardized values and
    hardware values, expand the range of standardized values to cover all
    four possible values.  The new values are as follows:
    
      S626_INDXSRC_ENCODER = 0  // index source from hardware encoder
      S626_INDXSRC_DIGIN = 1    // index source from digital inputs
      S626_INDXSRC_SOFT = 2     // index source s/w controlled by IndxPol
      S626_INDXSRC_DISABLED = 2 // index source disabled
    
    (Note the change in value for `S626_INDXSRC_SOFT` and the replacement of
    `S626_INDXSRC_HARD` with `S626_INDXSRC_ENCODER` for consistency with the
    `CntSrc` values.)
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 3fd544777abd..c2837da862db 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -708,7 +708,6 @@ static uint16_t s626_get_mode_a(struct comedi_device *dev,
 
 	/*
 	 * Populate the standardized counter setup bit fields.
-	 * Note: IndexSrc is restricted to ENC_X or IndxPol.
 	 */
 	setup =
 		/* LoadSrc  = LoadSrcA. */
@@ -717,8 +716,8 @@ static uint16_t s626_get_mode_a(struct comedi_device *dev,
 		S626_SET_STD_LATCHSRC(S626_GET_CRB_LATCHSRC(crb)) |
 		/* IntSrc   = IntSrcA. */
 		S626_SET_STD_INTSRC(S626_GET_CRA_INTSRC_A(cra)) |
-		/* IndxSrc  = IndxSrcA<1>. */
-		S626_SET_STD_INDXSRC(S626_GET_CRA_INDXSRC_A(cra) >> 1) |
+		/* IndxSrc  = IndxSrcA. */
+		S626_SET_STD_INDXSRC(S626_GET_CRA_INDXSRC_A(cra)) |
 		/* IndxPol  = IndxPolA. */
 		S626_SET_STD_INDXPOL(S626_GET_CRA_INDXPOL_A(cra)) |
 		/* ClkEnab  = ClkEnabA. */
@@ -764,7 +763,6 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 
 	/*
 	 * Populate the standardized counter setup bit fields.
-	 * Note: IndexSrc is restricted to ENC_X or IndxPol.
 	 */
 	setup =
 		/* IntSrc   = IntSrcB. */
@@ -777,8 +775,8 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 		S626_SET_STD_INDXPOL(S626_GET_CRB_INDXPOL_B(crb)) |
 		/* ClkEnab  = ClkEnabB. */
 		S626_SET_STD_CLKENAB(S626_GET_CRB_CLKENAB_B(crb)) |
-		/* IndxSrc  = IndxSrcB<1>. */
-		S626_SET_STD_INDXSRC(S626_GET_CRA_INDXSRC_B(cra) >> 1);
+		/* IndxSrc  = IndxSrcB. */
+		S626_SET_STD_INDXSRC(S626_GET_CRA_INDXSRC_B(cra));
 
 	/* Adjust mode-dependent parameters. */
 	cntsrc = S626_GET_CRA_CNTSRC_B(cra);
@@ -829,8 +827,8 @@ static void s626_set_mode_a(struct comedi_device *dev,
 	/* Initialize CRA and CRB images. */
 	/* Preload trigger is passed through. */
 	cra = S626_SET_CRA_LOADSRC_A(S626_GET_STD_LOADSRC(setup));
-	/* IndexSrc is restricted to ENC_X or IndxPol. */
-	cra |= S626_SET_CRA_INDXSRC_A(S626_GET_STD_INDXSRC(setup) << 1);
+	/* IndexSrc is passed through. */
+	cra |= S626_SET_CRA_INDXSRC_A(S626_GET_STD_INDXSRC(setup));
 
 	/* Reset any pending CounterA event captures. */
 	crb = S626_SET_CRB_INTRESETCMD(1) | S626_SET_CRB_INTRESET_A(1);
@@ -874,7 +872,7 @@ static void s626_set_mode_a(struct comedi_device *dev,
 	 * Force positive index polarity if IndxSrc is software-driven only,
 	 * otherwise pass it through.
 	 */
-	if (S626_GET_STD_INDXSRC(setup) == S626_INDXSRC_HARD)
+	if (S626_GET_STD_INDXSRC(setup) != S626_INDXSRC_SOFT)
 		cra |= S626_SET_CRA_INDXPOL_A(S626_GET_STD_INDXPOL(setup));
 
 	/*
@@ -904,8 +902,8 @@ static void s626_set_mode_b(struct comedi_device *dev,
 	unsigned cntsrc, clkmult, clkpol;
 
 	/* Initialize CRA and CRB images. */
-	/* IndexSrc field is restricted to ENC_X or IndxPol. */
-	cra = S626_SET_CRA_INDXSRC_B(S626_GET_STD_INDXSRC(setup) << 1);
+	/* IndexSrc is passed through. */
+	cra = S626_SET_CRA_INDXSRC_B(S626_GET_STD_INDXSRC(setup));
 
 	/* Reset event captures and disable interrupts. */
 	crb = S626_SET_CRB_INTRESETCMD(1) | S626_SET_CRB_INTRESET_B(1);
@@ -958,7 +956,7 @@ static void s626_set_mode_b(struct comedi_device *dev,
 	 * Force positive index polarity if IndxSrc is software-driven only,
 	 * otherwise pass it through.
 	 */
-	if (S626_GET_STD_INDXSRC(setup) == S626_INDXSRC_HARD)
+	if (S626_GET_STD_INDXSRC(setup) != S626_INDXSRC_SOFT)
 		crb |= S626_SET_CRB_INDXPOL_B(S626_GET_STD_INDXPOL(setup));
 
 	/*

commit 0830ada537ae50db3b2184df423e886b538989fa
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 21 10:10:36 2013 +0100

    staging: comedi: s626: make CRA and CRB setup conversions more readable
    
    Use the new macros defined in "s626.h" for constructing and decomposing
    'CRA', 'CRB' and standardized encoder setup values to make the
    conversions between standardized encoder setup values, and CRA/CRB
    register values easier to follow.
    
    There is some messing about with the 'IndxSrc' values which are 1-bit
    wide in the standardized encoder setup, and 2-bit wide in the 'CRA' and
    'CRB' register values.  This will be addressed by a later patch.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 92062ed0ac20..3fd544777abd 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -656,7 +656,7 @@ static void s626_set_latch_source(struct comedi_device *dev,
 {
 	s626_debi_replace(dev, k->my_crb,
 			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_LATCHSRC),
-			  value << S626_CRBBIT_LATCHSRC);
+			  S626_SET_CRB_LATCHSRC(value));
 }
 
 /*
@@ -678,14 +678,16 @@ static void s626_reset_cap_flags_a(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
 	s626_debi_replace(dev, k->my_crb, ~S626_CRBMSK_INTCTRL,
-			  S626_CRBMSK_INTRESETCMD | S626_CRBMSK_INTRESET_A);
+			  (S626_SET_CRB_INTRESETCMD(1) |
+			   S626_SET_CRB_INTRESET_A(1)));
 }
 
 static void s626_reset_cap_flags_b(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
 	s626_debi_replace(dev, k->my_crb, ~S626_CRBMSK_INTCTRL,
-			  S626_CRBMSK_INTRESETCMD | S626_CRBMSK_INTRESET_B);
+			  (S626_SET_CRB_INTRESETCMD(1) |
+			   S626_SET_CRB_INTRESET_B(1)));
 }
 
 /*
@@ -698,6 +700,7 @@ static uint16_t s626_get_mode_a(struct comedi_device *dev,
 	uint16_t cra;
 	uint16_t crb;
 	uint16_t setup;
+	unsigned cntsrc, clkmult, clkpol, encmode;
 
 	/* Fetch CRA and CRB register images. */
 	cra = s626_debi_read(dev, k->my_cra);
@@ -707,44 +710,41 @@ static uint16_t s626_get_mode_a(struct comedi_device *dev,
 	 * Populate the standardized counter setup bit fields.
 	 * Note: IndexSrc is restricted to ENC_X or IndxPol.
 	 */
-	setup = (cra & S626_STDMSK_LOADSRC) |	/* LoadSrc  = LoadSrcA. */
-		((crb << (S626_STDBIT_LATCHSRC - S626_CRBBIT_LATCHSRC)) &
-		 S626_STDMSK_LATCHSRC) |	/* LatchSrc = LatchSrcA. */
-		((cra << (S626_STDBIT_INTSRC - S626_CRABIT_INTSRC_A)) &
-		 S626_STDMSK_INTSRC) |		/* IntSrc   = IntSrcA. */
-		((cra << (S626_STDBIT_INDXSRC - (S626_CRABIT_INDXSRC_A + 1))) &
-		 S626_STDMSK_INDXSRC) |		/* IndxSrc  = IndxSrcA<1>. */
-		((cra >> (S626_CRABIT_INDXPOL_A - S626_STDBIT_INDXPOL)) &
-		 S626_STDMSK_INDXPOL) |		/* IndxPol  = IndxPolA. */
-		((crb >> (S626_CRBBIT_CLKENAB_A - S626_STDBIT_CLKENAB)) &
-		 S626_STDMSK_CLKENAB);		/* ClkEnab  = ClkEnabA. */
+	setup =
+		/* LoadSrc  = LoadSrcA. */
+		S626_SET_STD_LOADSRC(S626_GET_CRA_LOADSRC_A(cra)) |
+		/* LatchSrc = LatchSrcA. */
+		S626_SET_STD_LATCHSRC(S626_GET_CRB_LATCHSRC(crb)) |
+		/* IntSrc   = IntSrcA. */
+		S626_SET_STD_INTSRC(S626_GET_CRA_INTSRC_A(cra)) |
+		/* IndxSrc  = IndxSrcA<1>. */
+		S626_SET_STD_INDXSRC(S626_GET_CRA_INDXSRC_A(cra) >> 1) |
+		/* IndxPol  = IndxPolA. */
+		S626_SET_STD_INDXPOL(S626_GET_CRA_INDXPOL_A(cra)) |
+		/* ClkEnab  = ClkEnabA. */
+		S626_SET_STD_CLKENAB(S626_GET_CRB_CLKENAB_A(crb));
 
 	/* Adjust mode-dependent parameters. */
-	if (cra & (S626_CNTSRC_SYSCLK << S626_CRABIT_CNTSRC_A)) {
+	cntsrc = S626_GET_CRA_CNTSRC_A(cra);
+	if (cntsrc & S626_CNTSRC_SYSCLK) {
 		/* Timer mode (CntSrcA<1> == 1): */
-		/* Indicate Timer mode. */
-		setup |= S626_ENCMODE_TIMER << S626_STDBIT_ENCMODE;
+		encmode = S626_ENCMODE_TIMER;
 		/* Set ClkPol to indicate count direction (CntSrcA<0>). */
-		setup |= (cra << (S626_STDBIT_CLKPOL - S626_CRABIT_CNTSRC_A)) &
-			 S626_STDMSK_CLKPOL;
+		clkpol = cntsrc & 1;
 		/* ClkMult must be 1x in Timer mode. */
-		setup |= S626_MULT_X1 << S626_STDBIT_CLKMULT;
+		clkmult = S626_MULT_X1;
 	} else {
 		/* Counter mode (CntSrcA<1> == 0): */
-		/* Indicate Counter mode. */
-		setup |= S626_ENCMODE_COUNTER << S626_STDBIT_ENCMODE;
+		encmode = S626_ENCMODE_COUNTER;
 		/* Pass through ClkPol. */
-		setup |= (cra >> (S626_CRABIT_CLKPOL_A - S626_STDBIT_CLKPOL)) &
-			 S626_STDMSK_CLKPOL;
+		clkpol = S626_GET_CRA_CLKPOL_A(cra);
 		/* Force ClkMult to 1x if not legal, else pass through. */
-		if ((cra & S626_CRAMSK_CLKMULT_A) ==
-		    (S626_MULT_X0 << S626_CRABIT_CLKMULT_A))
-			setup |= S626_MULT_X1 << S626_STDBIT_CLKMULT;
-		else
-			setup |= (cra >> (S626_CRABIT_CLKMULT_A -
-					  S626_STDBIT_CLKMULT)) &
-				 S626_STDMSK_CLKMULT;
+		clkmult = S626_GET_CRA_CLKMULT_A(cra);
+		if (clkmult == S626_MULT_X0)
+			clkmult = S626_MULT_X1;
 	}
+	setup |= S626_SET_STD_ENCMODE(encmode) | S626_SET_STD_CLKMULT(clkmult) |
+		 S626_SET_STD_CLKPOL(clkpol);
 
 	/* Return adjusted counter setup. */
 	return setup;
@@ -756,6 +756,7 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 	uint16_t cra;
 	uint16_t crb;
 	uint16_t setup;
+	unsigned cntsrc, clkmult, clkpol, encmode;
 
 	/* Fetch CRA and CRB register images. */
 	cra = s626_debi_read(dev, k->my_cra);
@@ -765,50 +766,46 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 	 * Populate the standardized counter setup bit fields.
 	 * Note: IndexSrc is restricted to ENC_X or IndxPol.
 	 */
-	setup = ((crb << (S626_STDBIT_INTSRC - S626_CRBBIT_INTSRC_B)) &
-		 S626_STDMSK_INTSRC) |		/* IntSrc   = IntSrcB. */
-		((crb << (S626_STDBIT_LATCHSRC - S626_CRBBIT_LATCHSRC)) &
-		 S626_STDMSK_LATCHSRC) |	/* LatchSrc = LatchSrcB. */
-		((crb << (S626_STDBIT_LOADSRC - S626_CRBBIT_LOADSRC_B)) &
-		 S626_STDMSK_LOADSRC) |		/* LoadSrc  = LoadSrcB. */
-		((crb << (S626_STDBIT_INDXPOL - S626_CRBBIT_INDXPOL_B)) &
-		 S626_STDMSK_INDXPOL) |		/* IndxPol  = IndxPolB. */
-		((crb >> (S626_CRBBIT_CLKENAB_B - S626_STDBIT_CLKENAB)) &
-		 S626_STDMSK_CLKENAB) |		/* ClkEnab  = ClkEnabB. */
-		((cra >> ((S626_CRABIT_INDXSRC_B + 1) - S626_STDBIT_INDXSRC)) &
-		 S626_STDMSK_INDXSRC);		/* IndxSrc  = IndxSrcB<1>. */
+	setup =
+		/* IntSrc   = IntSrcB. */
+		S626_SET_STD_INTSRC(S626_GET_CRB_INTSRC_B(crb)) |
+		/* LatchSrc = LatchSrcB. */
+		S626_SET_STD_LATCHSRC(S626_GET_CRB_LATCHSRC(crb)) |
+		/* LoadSrc  = LoadSrcB. */
+		S626_SET_STD_LOADSRC(S626_GET_CRB_LOADSRC_B(crb)) |
+		/* IndxPol  = IndxPolB. */
+		S626_SET_STD_INDXPOL(S626_GET_CRB_INDXPOL_B(crb)) |
+		/* ClkEnab  = ClkEnabB. */
+		S626_SET_STD_CLKENAB(S626_GET_CRB_CLKENAB_B(crb)) |
+		/* IndxSrc  = IndxSrcB<1>. */
+		S626_SET_STD_INDXSRC(S626_GET_CRA_INDXSRC_B(cra) >> 1);
 
 	/* Adjust mode-dependent parameters. */
-	if ((crb & S626_CRBMSK_CLKMULT_B) ==
-	    (S626_MULT_X0 << S626_CRBBIT_CLKMULT_B)) {
+	cntsrc = S626_GET_CRA_CNTSRC_B(cra);
+	clkmult = S626_GET_CRB_CLKMULT_B(crb);
+	if (clkmult == S626_MULT_X0) {
 		/* Extender mode (ClkMultB == S626_MULT_X0): */
-		/* Indicate Extender mode. */
-		setup |= S626_ENCMODE_EXTENDER << S626_STDBIT_ENCMODE;
+		encmode = S626_ENCMODE_EXTENDER;
 		/* Indicate multiplier is 1x. */
-		setup |= S626_MULT_X1 << S626_STDBIT_CLKMULT;
+		clkmult = S626_MULT_X1;
 		/* Set ClkPol equal to Timer count direction (CntSrcB<0>). */
-		setup |= (cra >> (S626_CRABIT_CNTSRC_B - S626_STDBIT_CLKPOL)) &
-			 S626_STDMSK_CLKPOL;
-	} else if (cra & (S626_CNTSRC_SYSCLK << S626_CRABIT_CNTSRC_B)) {
+		clkpol = cntsrc & 1;
+	} else if (cntsrc & S626_CNTSRC_SYSCLK) {
 		/* Timer mode (CntSrcB<1> == 1): */
-		/* Indicate Timer mode. */
-		setup |= S626_ENCMODE_TIMER << S626_STDBIT_ENCMODE;
+		encmode = S626_ENCMODE_TIMER;
 		/* Indicate multiplier is 1x. */
-		setup |= S626_MULT_X1 << S626_STDBIT_CLKMULT;
+		clkmult = S626_MULT_X1;
 		/* Set ClkPol equal to Timer count direction (CntSrcB<0>). */
-		setup |= (cra >> (S626_CRABIT_CNTSRC_B - S626_STDBIT_CLKPOL)) &
-			 S626_STDMSK_CLKPOL;
+		clkpol = cntsrc & 1;
 	} else {
 		/* If Counter mode (CntSrcB<1> == 0): */
-		/* Indicate Counter mode. */
-		setup |= S626_ENCMODE_COUNTER << S626_STDBIT_ENCMODE;
+		encmode = S626_ENCMODE_COUNTER;
 		/* Clock multiplier is passed through. */
-		setup |= (crb >> (S626_CRBBIT_CLKMULT_B -
-				  S626_STDBIT_CLKMULT)) & S626_STDMSK_CLKMULT;
 		/* Clock polarity is passed through. */
-		setup |= (crb << (S626_STDBIT_CLKPOL - S626_CRBBIT_CLKPOL_B)) &
-			 S626_STDMSK_CLKPOL;
+		clkpol = S626_GET_CRB_CLKPOL_B(crb);
 	}
+	setup |= S626_SET_STD_ENCMODE(encmode) | S626_SET_STD_CLKMULT(clkmult) |
+		 S626_SET_STD_CLKPOL(clkpol);
 
 	/* Return adjusted counter setup. */
 	return setup;
@@ -827,64 +824,58 @@ static void s626_set_mode_a(struct comedi_device *dev,
 	struct s626_private *devpriv = dev->private;
 	uint16_t cra;
 	uint16_t crb;
+	unsigned cntsrc, clkmult, clkpol;
 
 	/* Initialize CRA and CRB images. */
 	/* Preload trigger is passed through. */
-	cra = setup & S626_CRAMSK_LOADSRC_A;
+	cra = S626_SET_CRA_LOADSRC_A(S626_GET_STD_LOADSRC(setup));
 	/* IndexSrc is restricted to ENC_X or IndxPol. */
-	cra |= (setup & S626_STDMSK_INDXSRC) >>
-	       (S626_STDBIT_INDXSRC - (S626_CRABIT_INDXSRC_A + 1));
+	cra |= S626_SET_CRA_INDXSRC_A(S626_GET_STD_INDXSRC(setup) << 1);
 
 	/* Reset any pending CounterA event captures. */
-	crb = S626_CRBMSK_INTRESETCMD | S626_CRBMSK_INTRESET_A;
+	crb = S626_SET_CRB_INTRESETCMD(1) | S626_SET_CRB_INTRESET_A(1);
 	/* Clock enable is passed through. */
-	crb |= (setup & S626_STDMSK_CLKENAB) <<
-	       (S626_CRBBIT_CLKENAB_A - S626_STDBIT_CLKENAB);
+	crb |= S626_SET_CRB_CLKENAB_A(S626_GET_STD_CLKENAB(setup));
 
 	/* Force IntSrc to Disabled if disable_int_src is asserted. */
 	if (!disable_int_src)
-		cra |= (setup & S626_STDMSK_INTSRC) >>
-		       (S626_STDBIT_INTSRC - S626_CRABIT_INTSRC_A);
+		cra |= S626_SET_CRA_INTSRC_A(S626_GET_STD_INTSRC(setup));
 
 	/* Populate all mode-dependent attributes of CRA & CRB images. */
-	switch ((setup & S626_STDMSK_ENCMODE) >> S626_STDBIT_ENCMODE) {
+	clkpol = S626_GET_STD_CLKPOL(setup);
+	switch (S626_GET_STD_ENCMODE(setup)) {
 	case S626_ENCMODE_EXTENDER: /* Extender Mode: */
 		/* Force to Timer mode (Extender valid only for B counters). */
 		/* Fall through to case S626_ENCMODE_TIMER: */
 	case S626_ENCMODE_TIMER:	/* Timer Mode: */
 		/* CntSrcA<1> selects system clock */
-		cra |= S626_CNTSRC_SYSCLK << S626_CRABIT_CNTSRC_A;
+		cntsrc = S626_CNTSRC_SYSCLK;
 		/* Count direction (CntSrcA<0>) obtained from ClkPol. */
-		cra |= (setup & S626_STDMSK_CLKPOL) >>
-		       (S626_STDBIT_CLKPOL - S626_CRABIT_CNTSRC_A);
+		cntsrc |= clkpol;
 		/* ClkPolA behaves as always-on clock enable. */
-		cra |= 1 << S626_CRABIT_CLKPOL_A;
+		clkpol = 1;
 		/* ClkMult must be 1x. */
-		cra |= S626_MULT_X1 << S626_CRABIT_CLKMULT_A;
+		clkmult = S626_MULT_X1;
 		break;
 	default:		/* Counter Mode: */
 		/* Select ENC_C and ENC_D as clock/direction inputs. */
-		cra |= S626_CNTSRC_ENCODER << S626_CRABIT_CNTSRC_A;
+		cntsrc = S626_CNTSRC_ENCODER;
 		/* Clock polarity is passed through. */
-		cra |= (setup & S626_STDMSK_CLKPOL) <<
-		       (S626_CRABIT_CLKPOL_A - S626_STDBIT_CLKPOL);
 		/* Force multiplier to x1 if not legal, else pass through. */
-		if ((setup & S626_STDMSK_CLKMULT) ==
-		    (S626_MULT_X0 << S626_STDBIT_CLKMULT))
-			cra |= S626_MULT_X1 << S626_CRABIT_CLKMULT_A;
-		else
-			cra |= (setup & S626_STDMSK_CLKMULT) <<
-			       (S626_CRABIT_CLKMULT_A - S626_STDBIT_CLKMULT);
+		clkmult = S626_GET_STD_CLKMULT(setup);
+		if (clkmult == S626_MULT_X0)
+			clkmult = S626_MULT_X1;
 		break;
 	}
+	cra |= S626_SET_CRA_CNTSRC_A(cntsrc) | S626_SET_CRA_CLKPOL_A(clkpol) |
+	       S626_SET_CRA_CLKMULT_A(clkmult);
 
 	/*
 	 * Force positive index polarity if IndxSrc is software-driven only,
 	 * otherwise pass it through.
 	 */
-	if (~setup & S626_STDMSK_INDXSRC)
-		cra |= (setup & S626_STDMSK_INDXPOL) <<
-		       (S626_CRABIT_INDXPOL_A - S626_STDBIT_INDXPOL);
+	if (S626_GET_STD_INDXSRC(setup) == S626_INDXSRC_HARD)
+		cra |= S626_SET_CRA_INDXPOL_A(S626_GET_STD_INDXPOL(setup));
 
 	/*
 	 * If IntSrc has been forced to Disabled, update the MISC2 interrupt
@@ -910,73 +901,65 @@ static void s626_set_mode_b(struct comedi_device *dev,
 	struct s626_private *devpriv = dev->private;
 	uint16_t cra;
 	uint16_t crb;
+	unsigned cntsrc, clkmult, clkpol;
 
 	/* Initialize CRA and CRB images. */
 	/* IndexSrc field is restricted to ENC_X or IndxPol. */
-	cra = (setup & S626_STDMSK_INDXSRC) <<
-	      (S626_CRABIT_INDXSRC_B + 1 - S626_STDBIT_INDXSRC);
+	cra = S626_SET_CRA_INDXSRC_B(S626_GET_STD_INDXSRC(setup) << 1);
 
 	/* Reset event captures and disable interrupts. */
-	crb = S626_CRBMSK_INTRESETCMD | S626_CRBMSK_INTRESET_B;
+	crb = S626_SET_CRB_INTRESETCMD(1) | S626_SET_CRB_INTRESET_B(1);
 	/* Clock enable is passed through. */
-	crb |= (setup & S626_STDMSK_CLKENAB) <<
-	       (S626_CRBBIT_CLKENAB_B - S626_STDBIT_CLKENAB);
+	crb |= S626_SET_CRB_CLKENAB_B(S626_GET_STD_CLKENAB(setup));
 	/* Preload trigger source is passed through. */
-	crb |= (setup & S626_STDMSK_LOADSRC) >>
-	       (S626_STDBIT_LOADSRC - S626_CRBBIT_LOADSRC_B);
+	crb |= S626_SET_CRB_LOADSRC_B(S626_GET_STD_LOADSRC(setup));
 
 	/* Force IntSrc to Disabled if disable_int_src is asserted. */
 	if (!disable_int_src)
-		crb |= (setup & S626_STDMSK_INTSRC) >>
-		       (S626_STDBIT_INTSRC - S626_CRBBIT_INTSRC_B);
+		crb |= S626_SET_CRB_INTSRC_B(S626_GET_STD_INTSRC(setup));
 
 	/* Populate all mode-dependent attributes of CRA & CRB images. */
-	switch ((setup & S626_STDMSK_ENCMODE) >> S626_STDBIT_ENCMODE) {
+	clkpol = S626_GET_STD_CLKPOL(setup);
+	switch (S626_GET_STD_ENCMODE(setup)) {
 	case S626_ENCMODE_TIMER:	/* Timer Mode: */
 		/* CntSrcB<1> selects system clock */
-		cra |= S626_CNTSRC_SYSCLK << S626_CRABIT_CNTSRC_B;
+		cntsrc = S626_CNTSRC_SYSCLK;
 		/* with direction (CntSrcB<0>) obtained from ClkPol. */
-		cra |= (setup & S626_STDMSK_CLKPOL) <<
-		       (S626_CRABIT_CNTSRC_B - S626_STDBIT_CLKPOL);
+		cntsrc |= clkpol;
 		/* ClkPolB behaves as always-on clock enable. */
-		crb |= 1 << S626_CRBBIT_CLKPOL_B;
+		clkpol = 1;
 		/* ClkMultB must be 1x. */
-		crb |= S626_MULT_X1 << S626_CRBBIT_CLKMULT_B;
+		clkmult = S626_MULT_X1;
 		break;
 	case S626_ENCMODE_EXTENDER:	/* Extender Mode: */
 		/* CntSrcB source is OverflowA (same as "timer") */
-		cra |= S626_CNTSRC_SYSCLK << S626_CRABIT_CNTSRC_B;
+		cntsrc = S626_CNTSRC_SYSCLK;
 		/* with direction obtained from ClkPol. */
-		cra |= (setup & S626_STDMSK_CLKPOL) <<
-		       (S626_CRABIT_CNTSRC_B - S626_STDBIT_CLKPOL);
+		cntsrc |= clkpol;
 		/* ClkPolB controls IndexB -- always set to active. */
-		crb |= 1 << S626_CRBBIT_CLKPOL_B;
+		clkpol = 1;
 		/* ClkMultB selects OverflowA as the clock source. */
-		crb |= S626_MULT_X0 << S626_CRBBIT_CLKMULT_B;
+		clkmult = S626_MULT_X0;
 		break;
 	default:		/* Counter Mode: */
 		/* Select ENC_C and ENC_D as clock/direction inputs. */
-		cra |= S626_CNTSRC_ENCODER << S626_CRABIT_CNTSRC_B;
+		cntsrc = S626_CNTSRC_ENCODER;
 		/* ClkPol is passed through. */
-		crb |= (setup & S626_STDMSK_CLKPOL) >>
-		       (S626_STDBIT_CLKPOL - S626_CRBBIT_CLKPOL_B);
 		/* Force ClkMult to x1 if not legal, otherwise pass through. */
-		if ((setup & S626_STDMSK_CLKMULT) ==
-		    (S626_MULT_X0 << S626_STDBIT_CLKMULT))
-			crb |= S626_MULT_X1 << S626_CRBBIT_CLKMULT_B;
-		else
-			crb |= (setup & S626_STDMSK_CLKMULT) <<
-			       (S626_CRBBIT_CLKMULT_B - S626_STDBIT_CLKMULT);
+		clkmult = S626_GET_STD_CLKMULT(setup);
+		if (clkmult == S626_MULT_X0)
+			clkmult = S626_MULT_X1;
 		break;
 	}
+	cra |= S626_SET_CRA_CNTSRC_B(cntsrc);
+	crb |= S626_SET_CRB_CLKPOL_B(clkpol) | S626_SET_CRB_CLKMULT_B(clkmult);
 
 	/*
 	 * Force positive index polarity if IndxSrc is software-driven only,
 	 * otherwise pass it through.
 	 */
-	if (~setup & S626_STDMSK_INDXSRC)
-		crb |= (setup & S626_STDMSK_INDXPOL) >>
-		       (S626_STDBIT_INDXPOL - S626_CRBBIT_INDXPOL_B);
+	if (S626_GET_STD_INDXSRC(setup) == S626_INDXSRC_HARD)
+		crb |= S626_SET_CRB_INDXPOL_B(S626_GET_STD_INDXPOL(setup));
 
 	/*
 	 * If IntSrc has been forced to Disabled, update the MISC2 interrupt
@@ -1003,7 +986,7 @@ static void s626_set_enable_a(struct comedi_device *dev,
 {
 	s626_debi_replace(dev, k->my_crb,
 			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_A),
-			  enab << S626_CRBBIT_CLKENAB_A);
+			  S626_SET_CRB_CLKENAB_A(enab));
 }
 
 static void s626_set_enable_b(struct comedi_device *dev,
@@ -1011,26 +994,26 @@ static void s626_set_enable_b(struct comedi_device *dev,
 {
 	s626_debi_replace(dev, k->my_crb,
 			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_B),
-			  enab << S626_CRBBIT_CLKENAB_B);
+			  S626_SET_CRB_CLKENAB_B(enab));
 }
 
 static uint16_t s626_get_enable_a(struct comedi_device *dev,
 				  const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_crb) >> S626_CRBBIT_CLKENAB_A) & 1;
+	return S626_GET_CRB_CLKENAB_A(s626_debi_read(dev, k->my_crb));
 }
 
 static uint16_t s626_get_enable_b(struct comedi_device *dev,
 				  const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_crb) >> S626_CRBBIT_CLKENAB_B) & 1;
+	return S626_GET_CRB_CLKENAB_B(s626_debi_read(dev, k->my_crb));
 }
 
 #ifdef unused
 static uint16_t s626_get_latch_source(struct comedi_device *dev,
 				      const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_crb) >> S626_CRBBIT_LATCHSRC) & 3;
+	return S626_GET_CRB_LATCHSRC(s626_debi_read(dev, k->my_crb));
 }
 #endif
 
@@ -1043,7 +1026,7 @@ static void s626_set_load_trig_a(struct comedi_device *dev,
 				 const struct s626_enc_info *k, uint16_t trig)
 {
 	s626_debi_replace(dev, k->my_cra, ~S626_CRAMSK_LOADSRC_A,
-			  trig << S626_CRABIT_LOADSRC_A);
+			  S626_SET_CRA_LOADSRC_A(trig));
 }
 
 static void s626_set_load_trig_b(struct comedi_device *dev,
@@ -1051,19 +1034,19 @@ static void s626_set_load_trig_b(struct comedi_device *dev,
 {
 	s626_debi_replace(dev, k->my_crb,
 			  ~(S626_CRBMSK_LOADSRC_B | S626_CRBMSK_INTCTRL),
-			  trig << S626_CRBBIT_LOADSRC_B);
+			  S626_SET_CRB_LOADSRC_B(trig));
 }
 
 static uint16_t s626_get_load_trig_a(struct comedi_device *dev,
 				     const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_cra) >> S626_CRABIT_LOADSRC_A) & 3;
+	return S626_GET_CRA_LOADSRC_A(s626_debi_read(dev, k->my_cra));
 }
 
 static uint16_t s626_get_load_trig_b(struct comedi_device *dev,
 				     const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_crb) >> S626_CRBBIT_LOADSRC_B) & 3;
+	return S626_GET_CRB_LOADSRC_B(s626_debi_read(dev, k->my_crb));
 }
 
 /*
@@ -1079,11 +1062,12 @@ static void s626_set_int_src_a(struct comedi_device *dev,
 
 	/* Reset any pending counter overflow or index captures. */
 	s626_debi_replace(dev, k->my_crb, ~S626_CRBMSK_INTCTRL,
-			  S626_CRBMSK_INTRESETCMD | S626_CRBMSK_INTRESET_A);
+			  (S626_SET_CRB_INTRESETCMD(1) |
+			   S626_SET_CRB_INTRESET_A(1)));
 
 	/* Program counter interrupt source. */
 	s626_debi_replace(dev, k->my_cra, ~S626_CRAMSK_INTSRC_A,
-			  int_source << S626_CRABIT_INTSRC_A);
+			  S626_SET_CRA_INTSRC_A(int_source));
 
 	/* Update MISC2 interrupt enable mask. */
 	devpriv->counter_int_enabs =
@@ -1102,13 +1086,12 @@ static void s626_set_int_src_b(struct comedi_device *dev,
 	crb = s626_debi_read(dev, k->my_crb) & ~S626_CRBMSK_INTCTRL;
 
 	/* Reset any pending counter overflow or index captures. */
-	s626_debi_write(dev, k->my_crb, (crb | S626_CRBMSK_INTRESETCMD |
-					 S626_CRBMSK_INTRESET_B));
+	s626_debi_write(dev, k->my_crb, (crb | S626_SET_CRB_INTRESETCMD(1) |
+					 S626_SET_CRB_INTRESET_B(1)));
 
 	/* Program counter interrupt source. */
-	s626_debi_write(dev, k->my_crb,
-			((crb & ~S626_CRBMSK_INTSRC_B) |
-			 (int_source << S626_CRBBIT_INTSRC_B)));
+	s626_debi_write(dev, k->my_crb, ((crb & ~S626_CRBMSK_INTSRC_B) |
+					 S626_SET_CRB_INTSRC_B(int_source)));
 
 	/* Update MISC2 interrupt enable mask. */
 	devpriv->counter_int_enabs =
@@ -1119,13 +1102,13 @@ static void s626_set_int_src_b(struct comedi_device *dev,
 static uint16_t s626_get_int_src_a(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_cra) >> S626_CRABIT_INTSRC_A) & 3;
+	return S626_GET_CRA_INTSRC_A(s626_debi_read(dev, k->my_cra));
 }
 
 static uint16_t s626_get_int_src_b(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_crb) >> S626_CRBBIT_INTSRC_B) & 3;
+	return S626_GET_CRB_INTSRC_B(s626_debi_read(dev, k->my_crb));
 }
 
 #ifdef unused
@@ -1136,13 +1119,13 @@ static void s626_set_clk_mult(struct comedi_device *dev,
 			      const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_CLKMULT) |
-			    (value << S626_STDBIT_CLKMULT)), false);
+			     S626_SET_STD_CLKMULT(value)), false);
 }
 
 static uint16_t s626_get_clk_mult(struct comedi_device *dev,
 				  const struct s626_enc_info *k)
 {
-	return (k->get_mode(dev, k) >> S626_STDBIT_CLKMULT) & 3;
+	return S626_GET_STD_CLKMULT(k->get_mode(dev, k));
 }
 
 /*
@@ -1152,13 +1135,13 @@ static void s626_set_clk_pol(struct comedi_device *dev,
 			     const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_CLKPOL) |
-			    (value << S626_STDBIT_CLKPOL)), false);
+			     S626_SET_STD_CLKPOL(value)), false);
 }
 
 static uint16_t s626_get_clk_pol(struct comedi_device *dev,
 				 const struct s626_enc_info *k)
 {
-	return (k->get_mode(dev, k) >> S626_STDBIT_CLKPOL) & 1;
+	return S626_GET_STD_CLKPOL(k->get_mode(dev, k));
 }
 
 /*
@@ -1168,13 +1151,13 @@ static void s626_set_enc_mode(struct comedi_device *dev,
 			      const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_ENCMODE) |
-			    (value << S626_STDBIT_ENCMODE)), false);
+			     S626_SET_STD_ENCMODE(value)), false);
 }
 
 static uint16_t s626_get_enc_mode(struct comedi_device *dev,
 				  const struct s626_enc_info *k)
 {
-	return (k->get_mode(dev, k) >> S626_STDBIT_ENCMODE) & 3;
+	return S626_GET_STD_ENCMODE(k->get_mode(dev, k));
 }
 
 /*
@@ -1184,13 +1167,13 @@ static void s626_set_index_pol(struct comedi_device *dev,
 			       const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_INDXPOL) |
-			    ((value != 0) << S626_STDBIT_INDXPOL)), false);
+			     S626_SET_STD_INDXPOL(value != 0)), false);
 }
 
 static uint16_t s626_get_index_pol(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	return (k->get_mode(dev, k) >> S626_STDBIT_INDXPOL) & 1;
+	return S626_GET_STD_INDXPOL(k->get_mode(dev, k));
 }
 
 /*
@@ -1200,13 +1183,13 @@ static void s626_set_index_src(struct comedi_device *dev,
 			       const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_INDXSRC) |
-			    ((value != 0) << S626_STDBIT_INDXSRC)), false);
+			     S626_SET_STD_INDXSRC(value != 0)), false);
 }
 
 static uint16_t s626_get_index_src(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	return (k->get_mode(dev, k) >> S626_STDBIT_INDXSRC) & 1;
+	return S626_GET_STD_INDXSRC(k->get_mode(dev, k));
 }
 #endif
 
@@ -2031,16 +2014,17 @@ static void s626_timer_load(struct comedi_device *dev,
 {
 	uint16_t setup =
 		/* Preload upon index. */
-		(S626_LOADSRC_INDX << S626_BF_LOADSRC) |
+		S626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |
 		/* Disable hardware index. */
-		(S626_INDXSRC_SOFT << S626_BF_INDXSRC) |
+		S626_SET_STD_INDXSRC(S626_INDXSRC_SOFT) |
 		/* Operating mode is Timer. */
-		(S626_ENCMODE_TIMER << S626_BF_ENCMODE) |
+		S626_SET_STD_ENCMODE(S626_ENCMODE_TIMER) |
 		/* Count direction is Down. */
-		(S626_CNTDIR_DOWN << S626_BF_CLKPOL) |
+		S626_SET_STD_CLKPOL(S626_CNTDIR_DOWN) |
 		/* Clock multiplier is 1x. */
-		(S626_CLKMULT_1X << S626_BF_CLKMULT) |
-		(S626_CLKENAB_INDEX << S626_BF_CLKENAB);
+		S626_SET_STD_CLKMULT(S626_CLKMULT_1X) |
+		/* Enabled by index */
+		S626_SET_STD_CLKENAB(S626_CLKENAB_INDEX);
 	uint16_t value_latchsrc = S626_LATCHSRC_A_INDXA;
 	/* uint16_t enab = S626_CLKENAB_ALWAYS; */
 
@@ -2423,16 +2407,17 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 {
 	uint16_t setup =
 		/* Preload upon index. */
-		(S626_LOADSRC_INDX << S626_BF_LOADSRC) |
+		S626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |
 		/* Disable hardware index. */
-		(S626_INDXSRC_SOFT << S626_BF_INDXSRC) |
+		S626_SET_STD_INDXSRC(S626_INDXSRC_SOFT) |
 		/* Operating mode is Counter. */
-		(S626_ENCMODE_COUNTER << S626_BF_ENCMODE) |
+		S626_SET_STD_ENCMODE(S626_ENCMODE_COUNTER) |
 		/* Active high clock. */
-		(S626_CLKPOL_POS << S626_BF_CLKPOL) |
+		S626_SET_STD_CLKPOL(S626_CLKPOL_POS) |
 		/* Clock multiplier is 1x. */
-		(S626_CLKMULT_1X << S626_BF_CLKMULT) |
-		(S626_CLKENAB_INDEX << S626_BF_CLKENAB);
+		S626_SET_STD_CLKMULT(S626_CLKMULT_1X) |
+		/* Enabled by index */
+		S626_SET_STD_CLKENAB(S626_CLKENAB_INDEX);
 	/* uint16_t disable_int_src = true; */
 	/* uint32_t Preloadvalue;              //Counter initial value */
 	uint16_t value_latchsrc = S626_LATCHSRC_AB_READ;
@@ -2519,17 +2504,17 @@ static void s626_counters_init(struct comedi_device *dev)
 	const struct s626_enc_info *k;
 	uint16_t setup =
 		/* Preload upon index. */
-		(S626_LOADSRC_INDX << S626_BF_LOADSRC) |
+		S626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |
 		/* Disable hardware index. */
-		(S626_INDXSRC_SOFT << S626_BF_INDXSRC) |
+		S626_SET_STD_INDXSRC(S626_INDXSRC_SOFT) |
 		/* Operating mode is counter. */
-		(S626_ENCMODE_COUNTER << S626_BF_ENCMODE) |
+		S626_SET_STD_ENCMODE(S626_ENCMODE_COUNTER) |
 		/* Active high clock. */
-		(S626_CLKPOL_POS << S626_BF_CLKPOL) |
+		S626_SET_STD_CLKPOL(S626_CLKPOL_POS) |
 		/* Clock multiplier is 1x. */
-		(S626_CLKMULT_1X << S626_BF_CLKMULT) |
+		S626_SET_STD_CLKMULT(S626_CLKMULT_1X) |
 		/* Enabled by index */
-		(S626_CLKENAB_INDEX << S626_BF_CLKENAB);
+		S626_SET_STD_CLKENAB(S626_CLKENAB_INDEX);
 
 	/*
 	 * Disable all counter interrupts and clear any captured counter events.

commit 622ec01ab9e19729c43eb994003783cf5094fc09
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Oct 18 14:40:52 2013 +0100

    staging: comedi: s626: distinguish counter src from encoder mode
    
    The macros `S626_CLKSRC_COUNTER`, `S626_CLKSRC_TIMER` and
    `S626_CLKSRC_EXTENDER` are used logically to set the operating mode of
    an encoder channel.  `S626_CLKSRC_COUNTER` (0) is also used as a 2-bit
    physical value to set the counter source of an encoder channel to
    "encoder".
    
    Rename the macros to `S626_ENCMODE_COUNTER`, `S626_ENCMODE_TIMER` and
    `S626_ENCMODE_EXTENDER` and rename some other macros and (unused)
    functions relating to the encoder mode for consistency.
    
    Define new macros to specify the physical counter source values for the
    'CRA' register and rename the corresponding bitshift and mask macros
    accordingly.  The physical values for the counter source are:
    
      S626_CNTSRC_ENCODER = 0      // encoder
      S626_CNTSRC_DIGIN = 1        // digital inputs
      S626_CNTSRC_SYSCLK = 2       // system clock up
      S626_CNTSRC_SYSCLK_DOWN = 3  // system clock down
    
    Also use the `S626_CNTSRC_SYSCLK` value as a bitmask (bit 1) to indicate
    either of the system clock values, with the direction (bit 0) indicated
    separately in this case.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index e7e60aa9ff5a..92062ed0ac20 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -720,19 +720,19 @@ static uint16_t s626_get_mode_a(struct comedi_device *dev,
 		 S626_STDMSK_CLKENAB);		/* ClkEnab  = ClkEnabA. */
 
 	/* Adjust mode-dependent parameters. */
-	if (cra & (2 << S626_CRABIT_CLKSRC_A)) {
-		/* Timer mode (ClkSrcA<1> == 1): */
+	if (cra & (S626_CNTSRC_SYSCLK << S626_CRABIT_CNTSRC_A)) {
+		/* Timer mode (CntSrcA<1> == 1): */
 		/* Indicate Timer mode. */
-		setup |= S626_CLKSRC_TIMER << S626_STDBIT_CLKSRC;
-		/* Set ClkPol to indicate count direction (ClkSrcA<0>). */
-		setup |= (cra << (S626_STDBIT_CLKPOL - S626_CRABIT_CLKSRC_A)) &
+		setup |= S626_ENCMODE_TIMER << S626_STDBIT_ENCMODE;
+		/* Set ClkPol to indicate count direction (CntSrcA<0>). */
+		setup |= (cra << (S626_STDBIT_CLKPOL - S626_CRABIT_CNTSRC_A)) &
 			 S626_STDMSK_CLKPOL;
 		/* ClkMult must be 1x in Timer mode. */
 		setup |= S626_MULT_X1 << S626_STDBIT_CLKMULT;
 	} else {
-		/* Counter mode (ClkSrcA<1> == 0): */
+		/* Counter mode (CntSrcA<1> == 0): */
 		/* Indicate Counter mode. */
-		setup |= S626_CLKSRC_COUNTER << S626_STDBIT_CLKSRC;
+		setup |= S626_ENCMODE_COUNTER << S626_STDBIT_ENCMODE;
 		/* Pass through ClkPol. */
 		setup |= (cra >> (S626_CRABIT_CLKPOL_A - S626_STDBIT_CLKPOL)) &
 			 S626_STDMSK_CLKPOL;
@@ -783,25 +783,25 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 	    (S626_MULT_X0 << S626_CRBBIT_CLKMULT_B)) {
 		/* Extender mode (ClkMultB == S626_MULT_X0): */
 		/* Indicate Extender mode. */
-		setup |= S626_CLKSRC_EXTENDER << S626_STDBIT_CLKSRC;
+		setup |= S626_ENCMODE_EXTENDER << S626_STDBIT_ENCMODE;
 		/* Indicate multiplier is 1x. */
 		setup |= S626_MULT_X1 << S626_STDBIT_CLKMULT;
-		/* Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
-		setup |= (cra >> (S626_CRABIT_CLKSRC_B - S626_STDBIT_CLKPOL)) &
+		/* Set ClkPol equal to Timer count direction (CntSrcB<0>). */
+		setup |= (cra >> (S626_CRABIT_CNTSRC_B - S626_STDBIT_CLKPOL)) &
 			 S626_STDMSK_CLKPOL;
-	} else if (cra & (2 << S626_CRABIT_CLKSRC_B)) {
-		/* Timer mode (ClkSrcB<1> == 1): */
+	} else if (cra & (S626_CNTSRC_SYSCLK << S626_CRABIT_CNTSRC_B)) {
+		/* Timer mode (CntSrcB<1> == 1): */
 		/* Indicate Timer mode. */
-		setup |= S626_CLKSRC_TIMER << S626_STDBIT_CLKSRC;
+		setup |= S626_ENCMODE_TIMER << S626_STDBIT_ENCMODE;
 		/* Indicate multiplier is 1x. */
 		setup |= S626_MULT_X1 << S626_STDBIT_CLKMULT;
-		/* Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
-		setup |= (cra >> (S626_CRABIT_CLKSRC_B - S626_STDBIT_CLKPOL)) &
+		/* Set ClkPol equal to Timer count direction (CntSrcB<0>). */
+		setup |= (cra >> (S626_CRABIT_CNTSRC_B - S626_STDBIT_CLKPOL)) &
 			 S626_STDMSK_CLKPOL;
 	} else {
-		/* If Counter mode (ClkSrcB<1> == 0): */
+		/* If Counter mode (CntSrcB<1> == 0): */
 		/* Indicate Counter mode. */
-		setup |= S626_CLKSRC_COUNTER << S626_STDBIT_CLKSRC;
+		setup |= S626_ENCMODE_COUNTER << S626_STDBIT_ENCMODE;
 		/* Clock multiplier is passed through. */
 		setup |= (crb >> (S626_CRBBIT_CLKMULT_B -
 				  S626_STDBIT_CLKMULT)) & S626_STDMSK_CLKMULT;
@@ -847,16 +847,16 @@ static void s626_set_mode_a(struct comedi_device *dev,
 		       (S626_STDBIT_INTSRC - S626_CRABIT_INTSRC_A);
 
 	/* Populate all mode-dependent attributes of CRA & CRB images. */
-	switch ((setup & S626_STDMSK_CLKSRC) >> S626_STDBIT_CLKSRC) {
-	case S626_CLKSRC_EXTENDER: /* Extender Mode: */
+	switch ((setup & S626_STDMSK_ENCMODE) >> S626_STDBIT_ENCMODE) {
+	case S626_ENCMODE_EXTENDER: /* Extender Mode: */
 		/* Force to Timer mode (Extender valid only for B counters). */
-		/* Fall through to case S626_CLKSRC_TIMER: */
-	case S626_CLKSRC_TIMER:	/* Timer Mode: */
-		/* ClkSrcA<1> selects system clock */
-		cra |= 2 << S626_CRABIT_CLKSRC_A;
-		/* Count direction (ClkSrcA<0>) obtained from ClkPol. */
+		/* Fall through to case S626_ENCMODE_TIMER: */
+	case S626_ENCMODE_TIMER:	/* Timer Mode: */
+		/* CntSrcA<1> selects system clock */
+		cra |= S626_CNTSRC_SYSCLK << S626_CRABIT_CNTSRC_A;
+		/* Count direction (CntSrcA<0>) obtained from ClkPol. */
 		cra |= (setup & S626_STDMSK_CLKPOL) >>
-		       (S626_STDBIT_CLKPOL - S626_CRABIT_CLKSRC_A);
+		       (S626_STDBIT_CLKPOL - S626_CRABIT_CNTSRC_A);
 		/* ClkPolA behaves as always-on clock enable. */
 		cra |= 1 << S626_CRABIT_CLKPOL_A;
 		/* ClkMult must be 1x. */
@@ -864,7 +864,7 @@ static void s626_set_mode_a(struct comedi_device *dev,
 		break;
 	default:		/* Counter Mode: */
 		/* Select ENC_C and ENC_D as clock/direction inputs. */
-		cra |= S626_CLKSRC_COUNTER << S626_CRABIT_CLKSRC_A;
+		cra |= S626_CNTSRC_ENCODER << S626_CRABIT_CNTSRC_A;
 		/* Clock polarity is passed through. */
 		cra |= (setup & S626_STDMSK_CLKPOL) <<
 		       (S626_CRABIT_CLKPOL_A - S626_STDBIT_CLKPOL);
@@ -898,7 +898,7 @@ static void s626_set_mode_a(struct comedi_device *dev,
 	 * new counter operating mode.
 	 */
 	s626_debi_replace(dev, k->my_cra,
-			  S626_CRAMSK_INDXSRC_B | S626_CRAMSK_CLKSRC_B, cra);
+			  S626_CRAMSK_INDXSRC_B | S626_CRAMSK_CNTSRC_B, cra);
 	s626_debi_replace(dev, k->my_crb,
 			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_A), crb);
 }
@@ -931,24 +931,24 @@ static void s626_set_mode_b(struct comedi_device *dev,
 		       (S626_STDBIT_INTSRC - S626_CRBBIT_INTSRC_B);
 
 	/* Populate all mode-dependent attributes of CRA & CRB images. */
-	switch ((setup & S626_STDMSK_CLKSRC) >> S626_STDBIT_CLKSRC) {
-	case S626_CLKSRC_TIMER:	/* Timer Mode: */
-		/* ClkSrcB<1> selects system clock */
-		cra |= 2 << S626_CRABIT_CLKSRC_B;
-		/* with direction (ClkSrcB<0>) obtained from ClkPol. */
+	switch ((setup & S626_STDMSK_ENCMODE) >> S626_STDBIT_ENCMODE) {
+	case S626_ENCMODE_TIMER:	/* Timer Mode: */
+		/* CntSrcB<1> selects system clock */
+		cra |= S626_CNTSRC_SYSCLK << S626_CRABIT_CNTSRC_B;
+		/* with direction (CntSrcB<0>) obtained from ClkPol. */
 		cra |= (setup & S626_STDMSK_CLKPOL) <<
-		       (S626_CRABIT_CLKSRC_B - S626_STDBIT_CLKPOL);
+		       (S626_CRABIT_CNTSRC_B - S626_STDBIT_CLKPOL);
 		/* ClkPolB behaves as always-on clock enable. */
 		crb |= 1 << S626_CRBBIT_CLKPOL_B;
 		/* ClkMultB must be 1x. */
 		crb |= S626_MULT_X1 << S626_CRBBIT_CLKMULT_B;
 		break;
-	case S626_CLKSRC_EXTENDER:	/* Extender Mode: */
-		/* ClkSrcB source is OverflowA (same as "timer") */
-		cra |= 2 << S626_CRABIT_CLKSRC_B;
+	case S626_ENCMODE_EXTENDER:	/* Extender Mode: */
+		/* CntSrcB source is OverflowA (same as "timer") */
+		cra |= S626_CNTSRC_SYSCLK << S626_CRABIT_CNTSRC_B;
 		/* with direction obtained from ClkPol. */
 		cra |= (setup & S626_STDMSK_CLKPOL) <<
-		       (S626_CRABIT_CLKSRC_B - S626_STDBIT_CLKPOL);
+		       (S626_CRABIT_CNTSRC_B - S626_STDBIT_CLKPOL);
 		/* ClkPolB controls IndexB -- always set to active. */
 		crb |= 1 << S626_CRBBIT_CLKPOL_B;
 		/* ClkMultB selects OverflowA as the clock source. */
@@ -956,7 +956,7 @@ static void s626_set_mode_b(struct comedi_device *dev,
 		break;
 	default:		/* Counter Mode: */
 		/* Select ENC_C and ENC_D as clock/direction inputs. */
-		cra |= S626_CLKSRC_COUNTER << S626_CRABIT_CLKSRC_B;
+		cra |= S626_CNTSRC_ENCODER << S626_CRABIT_CNTSRC_B;
 		/* ClkPol is passed through. */
 		crb |= (setup & S626_STDMSK_CLKPOL) >>
 		       (S626_STDBIT_CLKPOL - S626_CRBBIT_CLKPOL_B);
@@ -990,7 +990,7 @@ static void s626_set_mode_b(struct comedi_device *dev,
 	 * new counter operating mode.
 	 */
 	s626_debi_replace(dev, k->my_cra,
-			  ~(S626_CRAMSK_INDXSRC_B | S626_CRAMSK_CLKSRC_B), cra);
+			  ~(S626_CRAMSK_INDXSRC_B | S626_CRAMSK_CNTSRC_B), cra);
 	s626_debi_replace(dev, k->my_crb,
 			  S626_CRBMSK_CLKENAB_A | S626_CRBMSK_LATCHSRC, crb);
 }
@@ -1162,19 +1162,19 @@ static uint16_t s626_get_clk_pol(struct comedi_device *dev,
 }
 
 /*
- * Return/set the clock source.
+ * Return/set the encoder mode.
  */
-static void s626_set_clk_src(struct comedi_device *dev,
-			     const struct s626_enc_info *k, uint16_t value)
+static void s626_set_enc_mode(struct comedi_device *dev,
+			      const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_CLKSRC) |
-			    (value << S626_STDBIT_CLKSRC)), false);
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_ENCMODE) |
+			    (value << S626_STDBIT_ENCMODE)), false);
 }
 
-static uint16_t s626_get_clk_src(struct comedi_device *dev,
-				 const struct s626_enc_info *k)
+static uint16_t s626_get_enc_mode(struct comedi_device *dev,
+				  const struct s626_enc_info *k)
 {
-	return (k->get_mode(dev, k) >> S626_STDBIT_CLKSRC) & 3;
+	return (k->get_mode(dev, k) >> S626_STDBIT_ENCMODE) & 3;
 }
 
 /*
@@ -2035,7 +2035,7 @@ static void s626_timer_load(struct comedi_device *dev,
 		/* Disable hardware index. */
 		(S626_INDXSRC_SOFT << S626_BF_INDXSRC) |
 		/* Operating mode is Timer. */
-		(S626_CLKSRC_TIMER << S626_BF_CLKSRC) |
+		(S626_ENCMODE_TIMER << S626_BF_ENCMODE) |
 		/* Count direction is Down. */
 		(S626_CNTDIR_DOWN << S626_BF_CLKPOL) |
 		/* Clock multiplier is 1x. */
@@ -2427,7 +2427,7 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 		/* Disable hardware index. */
 		(S626_INDXSRC_SOFT << S626_BF_INDXSRC) |
 		/* Operating mode is Counter. */
-		(S626_CLKSRC_COUNTER << S626_BF_CLKSRC) |
+		(S626_ENCMODE_COUNTER << S626_BF_ENCMODE) |
 		/* Active high clock. */
 		(S626_CLKPOL_POS << S626_BF_CLKPOL) |
 		/* Clock multiplier is 1x. */
@@ -2523,7 +2523,7 @@ static void s626_counters_init(struct comedi_device *dev)
 		/* Disable hardware index. */
 		(S626_INDXSRC_SOFT << S626_BF_INDXSRC) |
 		/* Operating mode is counter. */
-		(S626_CLKSRC_COUNTER << S626_BF_CLKSRC) |
+		(S626_ENCMODE_COUNTER << S626_BF_ENCMODE) |
 		/* Active high clock. */
 		(S626_CLKPOL_POS << S626_BF_CLKPOL) |
 		/* Clock multiplier is 1x. */

commit 72938088749fe17c322c60d85f79b41f6142c635
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Oct 18 14:40:51 2013 +0100

    staging: comedi: s626: correct a comment in s626_get_mode_b()
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 770c1d5065c9..e7e60aa9ff5a 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -800,7 +800,7 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 			 S626_STDMSK_CLKPOL;
 	} else {
 		/* If Counter mode (ClkSrcB<1> == 0): */
-		/* Indicate Timer mode. */
+		/* Indicate Counter mode. */
 		setup |= S626_CLKSRC_COUNTER << S626_STDBIT_CLKSRC;
 		/* Clock multiplier is passed through. */
 		setup |= (crb >> (S626_CRBBIT_CLKMULT_B -

commit 2e179e428ce47c3988eead1944b5043de07731ae
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Oct 18 14:40:50 2013 +0100

    staging: comedi: s626: specify bitshift for encoder A clock source
    
    When setting the clock source for one of the 'A' encoders to operate in
    "counter" mode in `s626_set_mode_a()`, bitshift the clock source value by
    `S626_CRABIT_CLKSRC_A` for consistency with the other modes.  This has
    no effect on the value since `S626_CRABIT_CLKSRC_A` is 0.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index dd138a095624..770c1d5065c9 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -864,7 +864,7 @@ static void s626_set_mode_a(struct comedi_device *dev,
 		break;
 	default:		/* Counter Mode: */
 		/* Select ENC_C and ENC_D as clock/direction inputs. */
-		cra |= S626_CLKSRC_COUNTER;
+		cra |= S626_CLKSRC_COUNTER << S626_CRABIT_CLKSRC_A;
 		/* Clock polarity is passed through. */
 		cra |= (setup & S626_STDMSK_CLKPOL) <<
 		       (S626_CRABIT_CLKPOL_A - S626_STDBIT_CLKPOL);

commit 6c661434f98dfe0ad301a4910b6209b0541c0239
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Oct 18 14:40:49 2013 +0100

    staging: comedi: s626: clock polarity and direction are the same
    
    When setting up an encoder channel, the setup value includes a polarity
    and direction, but these are the same bit of the setup value:
    
      S626_CLKPOL_POS = S626_CNTDIR_UP = 0
    
      S626_CLKPOL_NEG = S626_CNTDIR_DOWN = 1
    
    In the construction of the setup value, both the CLKPOL and the CNTDIR
    constants are shifted by the same amount `S626_BF_CLKPOL`.  Only the
    following combinations are set up currently (this may change if user
    configuration of the encoder is implemented properly):
    
      (S626_CLKPOL_POS << S626_BF_CLKPOL)
    
      (S626_CLKPOL_POS << S626_BF_CLKPOL) |
      (S626_CNTDIR_UP << S626_BF_CLKPOL)
    
      (S626_CLKPOL_POS << S626_BF_CLKPOL) |
      (S626_CNTDIR_DOWN << S626_BF_CLKPOL)
    
    The first two are used in "counter" mode and is equivalent to:
    
      (S626_CLKPOL_POS << S626_BF_CLKPOL)
    
    The last one is used in "timer" mode and is equivalent to:
    
      (S626_CNTDIR_DOWN << S626_BF_CLKPOL)
    
    Use the shorter equivalents.  The comments in "s626.h" indicate that the
    'CLKPOL' constants make more sense for the "counter" mode (when the
    encoders operate as up/down counters) and the 'CNTDIR' constants make
    more sense for the "timer" mode.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index d9aba7ce862d..dd138a095624 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2036,8 +2036,6 @@ static void s626_timer_load(struct comedi_device *dev,
 		(S626_INDXSRC_SOFT << S626_BF_INDXSRC) |
 		/* Operating mode is Timer. */
 		(S626_CLKSRC_TIMER << S626_BF_CLKSRC) |
-		/* Active high clock. */
-		(S626_CLKPOL_POS << S626_BF_CLKPOL) |
 		/* Count direction is Down. */
 		(S626_CNTDIR_DOWN << S626_BF_CLKPOL) |
 		/* Clock multiplier is 1x. */
@@ -2528,8 +2526,6 @@ static void s626_counters_init(struct comedi_device *dev)
 		(S626_CLKSRC_COUNTER << S626_BF_CLKSRC) |
 		/* Active high clock. */
 		(S626_CLKPOL_POS << S626_BF_CLKPOL) |
-		/* Count direction is up. */
-		(S626_CNTDIR_UP << S626_BF_CLKPOL) |
 		/* Clock multiplier is 1x. */
 		(S626_CLKMULT_1X << S626_BF_CLKMULT) |
 		/* Enabled by index */

commit 5fd4b711be4859e58b7b78dd3ac60497e1b294ab
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:36 2013 +0100

    staging: comedi: s626: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Use unsigned types consistently in the "s626" module when dealing with
    sample values.
    
    Rewrite `s626_reg_to_uint()` as it can be done with a one-liner.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index a34e70757922..d9aba7ce862d 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -494,7 +494,7 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
  * Private helper function: Write setpoint to an application DAC channel.
  */
 static void s626_set_dac(struct comedi_device *dev, uint16_t chan,
-			 short dacdata)
+			 unsigned short dacdata)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t signmask;
@@ -1329,17 +1329,9 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 	},
 };
 
-static unsigned int s626_ai_reg_to_uint(int data)
+static unsigned int s626_ai_reg_to_uint(unsigned int data)
 {
-	unsigned int tempdata;
-
-	tempdata = (data >> 18);
-	if (tempdata & 0x2000)
-		tempdata &= 0x1fff;
-	else
-		tempdata += (1 << 13);
-
-	return tempdata;
+	return ((data >> 18) & 0x3fff) ^ 0x2000;
 }
 
 static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
@@ -1545,19 +1537,19 @@ static bool s626_handle_eos_interrupt(struct comedi_device *dev)
 	 * first uint16_t in the buffer because it contains junk data
 	 * from the final ADC of the previous poll list scan.
 	 */
-	int32_t *readaddr = (int32_t *)devpriv->ana_buf.logical_base + 1;
+	uint32_t *readaddr = (uint32_t *)devpriv->ana_buf.logical_base + 1;
 	bool finished = false;
 	int i;
 
 	/* get the data and hand it over to comedi */
 	for (i = 0; i < cmd->chanlist_len; i++) {
-		short tempdata;
+		unsigned short tempdata;
 
 		/*
 		 * Convert ADC data to 16-bit integer values and copy
 		 * to application buffer.
 		 */
-		tempdata = s626_ai_reg_to_uint((int)*readaddr);
+		tempdata = s626_ai_reg_to_uint(*readaddr);
 		readaddr++;
 
 		/* put data into read buffer */
@@ -1881,7 +1873,7 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	uint16_t range = CR_RANGE(insn->chanspec);
 	uint16_t adc_spec = 0;
 	uint32_t gpio_image;
-	int tmp;
+	uint32_t tmp;
 	int n;
 
 	/*

commit d8515652ef01afb323dbdd87499c2c950ec9d324
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:42 2013 +0100

    staging: comedi: s626: prefix macros in s626.h
    
    Prefix the names of all the macros defined in "s626.h" with `S626_`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index e8d615f83dee..a34e70757922 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -194,7 +194,7 @@ static bool s626_mc_test(struct comedi_device *dev,
 #define S626_BUGFIX_STREG(REGADRS)   ((REGADRS) - 4)
 
 /* Write a time slot control record to TSL2. */
-#define S626_VECTPORT(VECTNUM)		(P_TSL2 + ((VECTNUM) << 2))
+#define S626_VECTPORT(VECTNUM)		(S626_P_TSL2 + ((VECTNUM) << 2))
 
 static const struct comedi_lrange s626_range_table = {
 	2, {
@@ -211,17 +211,17 @@ static void s626_debi_transfer(struct comedi_device *dev)
 	struct s626_private *devpriv = dev->private;
 
 	/* Initiate upload of shadow RAM to DEBI control register */
-	s626_mc_enable(dev, MC2_UPLD_DEBI, P_MC2);
+	s626_mc_enable(dev, S626_MC2_UPLD_DEBI, S626_P_MC2);
 
 	/*
 	 * Wait for completion of upload from shadow RAM to
 	 * DEBI control register.
 	 */
-	while (!s626_mc_test(dev, MC2_UPLD_DEBI, P_MC2))
+	while (!s626_mc_test(dev, S626_MC2_UPLD_DEBI, S626_P_MC2))
 		;
 
 	/* Wait until DEBI transfer is done */
-	while (readl(devpriv->mmio + P_PSR) & PSR_DEBI_S)
+	while (readl(devpriv->mmio + S626_P_PSR) & S626_PSR_DEBI_S)
 		;
 }
 
@@ -233,12 +233,12 @@ static uint16_t s626_debi_read(struct comedi_device *dev, uint16_t addr)
 	struct s626_private *devpriv = dev->private;
 
 	/* Set up DEBI control register value in shadow RAM */
-	writel(DEBI_CMD_RDWORD | addr, devpriv->mmio + P_DEBICMD);
+	writel(S626_DEBI_CMD_RDWORD | addr, devpriv->mmio + S626_P_DEBICMD);
 
 	/*  Execute the DEBI transfer. */
 	s626_debi_transfer(dev);
 
-	return readl(devpriv->mmio + P_DEBIAD);
+	return readl(devpriv->mmio + S626_P_DEBIAD);
 }
 
 /*
@@ -250,8 +250,8 @@ static void s626_debi_write(struct comedi_device *dev, uint16_t addr,
 	struct s626_private *devpriv = dev->private;
 
 	/* Set up DEBI control register value in shadow RAM */
-	writel(DEBI_CMD_WRWORD | addr, devpriv->mmio + P_DEBICMD);
-	writel(wdata, devpriv->mmio + P_DEBIAD);
+	writel(S626_DEBI_CMD_WRWORD | addr, devpriv->mmio + S626_P_DEBICMD);
+	writel(wdata, devpriv->mmio + S626_P_DEBIAD);
 
 	/*  Execute the DEBI transfer. */
 	s626_debi_transfer(dev);
@@ -269,14 +269,14 @@ static void s626_debi_replace(struct comedi_device *dev, unsigned int addr,
 	unsigned int val;
 
 	addr &= 0xffff;
-	writel(DEBI_CMD_RDWORD | addr, devpriv->mmio + P_DEBICMD);
+	writel(S626_DEBI_CMD_RDWORD | addr, devpriv->mmio + S626_P_DEBICMD);
 	s626_debi_transfer(dev);
 
-	writel(DEBI_CMD_WRWORD | addr, devpriv->mmio + P_DEBICMD);
-	val = readl(devpriv->mmio + P_DEBIAD);
+	writel(S626_DEBI_CMD_WRWORD | addr, devpriv->mmio + S626_P_DEBICMD);
+	val = readl(devpriv->mmio + S626_P_DEBIAD);
 	val &= mask;
 	val |= wdata;
-	writel(val & 0xffff, devpriv->mmio + P_DEBIAD);
+	writel(val & 0xffff, devpriv->mmio + S626_P_DEBIAD);
 	s626_debi_transfer(dev);
 }
 
@@ -288,23 +288,23 @@ static uint32_t s626_i2c_handshake(struct comedi_device *dev, uint32_t val)
 	unsigned int ctrl;
 
 	/* Write I2C command to I2C Transfer Control shadow register */
-	writel(val, devpriv->mmio + P_I2CCTRL);
+	writel(val, devpriv->mmio + S626_P_I2CCTRL);
 
 	/*
 	 * Upload I2C shadow registers into working registers and
 	 * wait for upload confirmation.
 	 */
-	s626_mc_enable(dev, MC2_UPLD_IIC, P_MC2);
-	while (!s626_mc_test(dev, MC2_UPLD_IIC, P_MC2))
+	s626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);
+	while (!s626_mc_test(dev, S626_MC2_UPLD_IIC, S626_P_MC2))
 		;
 
 	/* Wait until I2C bus transfer is finished or an error occurs */
 	do {
-		ctrl = readl(devpriv->mmio + P_I2CCTRL);
-	} while ((ctrl & (I2C_BUSY | I2C_ERR)) == I2C_BUSY);
+		ctrl = readl(devpriv->mmio + S626_P_I2CCTRL);
+	} while ((ctrl & (S626_I2C_BUSY | S626_I2C_ERR)) == S626_I2C_BUSY);
 
 	/* Return non-zero if I2C error occurred */
-	return ctrl & I2C_ERR;
+	return ctrl & S626_I2C_ERR;
 }
 
 /* Read uint8_t from EEPROM. */
@@ -318,9 +318,10 @@ static uint8_t s626_i2c_read(struct comedi_device *dev, uint8_t addr)
 	 *  Byte1 = EEPROM internal target address.
 	 *  Byte0 = Not sent.
 	 */
-	if (s626_i2c_handshake(dev, I2C_B2(I2C_ATTRSTART, devpriv->i2c_adrs) |
-				    I2C_B1(I2C_ATTRSTOP, addr) |
-				    I2C_B0(I2C_ATTRNOP, 0)))
+	if (s626_i2c_handshake(dev, S626_I2C_B2(S626_I2C_ATTRSTART,
+						devpriv->i2c_adrs) |
+				    S626_I2C_B1(S626_I2C_ATTRSTOP, addr) |
+				    S626_I2C_B0(S626_I2C_ATTRNOP, 0)))
 		/* Abort function and declare error if handshake failed. */
 		return 0;
 
@@ -330,14 +331,14 @@ static uint8_t s626_i2c_read(struct comedi_device *dev, uint8_t addr)
 	 *  Byte1 receives uint8_t from EEPROM.
 	 *  Byte0 = Not sent.
 	 */
-	if (s626_i2c_handshake(dev, I2C_B2(I2C_ATTRSTART,
+	if (s626_i2c_handshake(dev, S626_I2C_B2(S626_I2C_ATTRSTART,
 					   (devpriv->i2c_adrs | 1)) |
-				    I2C_B1(I2C_ATTRSTOP, 0) |
-				    I2C_B0(I2C_ATTRNOP, 0)))
+				    S626_I2C_B1(S626_I2C_ATTRSTOP, 0) |
+				    S626_I2C_B0(S626_I2C_ATTRNOP, 0)))
 		/* Abort function and declare error if handshake failed. */
 		return 0;
 
-	return (readl(devpriv->mmio + P_I2CCTRL) >> 16) & 0xff;
+	return (readl(devpriv->mmio + S626_P_I2CCTRL) >> 16) & 0xff;
 }
 
 /* ***********  DAC FUNCTIONS *********** */
@@ -371,7 +372,7 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * the trailing edge of WS1/WS3 (which turns off the signals), thus
 	 * causing the signals to be inactive during the DAC write.
 	 */
-	s626_debi_write(dev, LP_DACPOL, devpriv->dacpol);
+	s626_debi_write(dev, S626_LP_DACPOL, devpriv->dacpol);
 
 	/* TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- */
 
@@ -385,7 +386,7 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * then immediately terminate because the protection address is
 	 * reached upon transfer of the first DWORD value.
 	 */
-	s626_mc_enable(dev, MC1_A2OUT, P_MC1);
+	s626_mc_enable(dev, S626_MC1_A2OUT, S626_P_MC1);
 
 	/* While the DMA transfer is executing ... */
 
@@ -394,7 +395,7 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * other FIFO underflow/overflow flags). When set, this flag
 	 * will indicate that we have emerged from slot 0.
 	 */
-	writel(ISR_AFOU, devpriv->mmio + P_ISR);
+	writel(S626_ISR_AFOU, devpriv->mmio + S626_P_ISR);
 
 	/*
 	 * Wait for the DMA transfer to finish so that there will be data
@@ -403,7 +404,7 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * Done by polling the DMAC enable flag; this flag is automatically
 	 * cleared when the transfer has finished.
 	 */
-	while (readl(devpriv->mmio + P_MC1) & MC1_A2OUT)
+	while (readl(devpriv->mmio + S626_P_MC1) & S626_MC1_A2OUT)
 		;
 
 	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
@@ -414,7 +415,8 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
 	 * detection.
 	 */
-	writel(XSD2 | RSD3 | SIB_A2, devpriv->mmio + S626_VECTPORT(0));
+	writel(S626_XSD2 | S626_RSD3 | S626_SIB_A2,
+	       devpriv->mmio + S626_VECTPORT(0));
 
 	/*
 	 * Wait for slot 1 to execute to ensure that the Packet will be
@@ -423,7 +425,7 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * finished transferring the DAC's data DWORD from the output FIFO
 	 * to the output buffer register.
 	 */
-	while (!(readl(devpriv->mmio + P_SSR) & SSR_AF2_OUT))
+	while (!(readl(devpriv->mmio + S626_P_SSR) & S626_SSR_AF2_OUT))
 		;
 
 	/*
@@ -433,7 +435,7 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * stored in the last byte to be shifted out of the FIFO's DWORD
 	 * buffer register.
 	 */
-	writel(XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS,
+	writel(S626_XSD2 | S626_XFIFO_2 | S626_RSD2 | S626_SIB_A2 | S626_EOS,
 	       devpriv->mmio + S626_VECTPORT(0));
 
 	/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */
@@ -456,7 +458,7 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 *    we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
 	 *    the TSL has not yet finished executing slot 5 ...
 	 */
-	if (readl(devpriv->mmio + P_FB_BUFFER2) & 0xff000000) {
+	if (readl(devpriv->mmio + S626_P_FB_BUFFER2) & 0xff000000) {
 		/*
 		 * The trap was set on time and we are still executing somewhere
 		 * in slots 2-5, so we now wait for slot 0 to execute and trap
@@ -464,7 +466,7 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
 		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
 		 */
-		while (readl(devpriv->mmio + P_FB_BUFFER2) & 0xff000000)
+		while (readl(devpriv->mmio + S626_P_FB_BUFFER2) & 0xff000000)
 			;
 	}
 	/*
@@ -476,14 +478,15 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * In order to do this, we reprogram slot 0 so that it will shift in
 	 * SD3, which is driven only by a pull-up resistor.
 	 */
-	writel(RSD3 | SIB_A2 | EOS, devpriv->mmio + S626_VECTPORT(0));
+	writel(S626_RSD3 | S626_SIB_A2 | S626_EOS,
+	       devpriv->mmio + S626_VECTPORT(0));
 
 	/*
 	 * Wait for slot 0 to execute, at which time the TSL is setup for
 	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
 	 * from 0x00 to 0xFF.
 	 */
-	while (!(readl(devpriv->mmio + P_FB_BUFFER2) & 0xff000000))
+	while (!(readl(devpriv->mmio + S626_P_FB_BUFFER2) & 0xff000000))
 		;
 }
 
@@ -525,15 +528,19 @@ static void s626_set_dac(struct comedi_device *dev, uint16_t chan,
 	 */
 
 	/* Choose DAC chip select to be asserted */
-	ws_image = (chan & 2) ? WS1 : WS2;
+	ws_image = (chan & 2) ? S626_WS1 : S626_WS2;
 	/* Slot 2: Transmit high data byte to target DAC */
-	writel(XSD2 | XFIFO_1 | ws_image, devpriv->mmio + S626_VECTPORT(2));
+	writel(S626_XSD2 | S626_XFIFO_1 | ws_image,
+	       devpriv->mmio + S626_VECTPORT(2));
 	/* Slot 3: Transmit low data byte to target DAC */
-	writel(XSD2 | XFIFO_0 | ws_image, devpriv->mmio + S626_VECTPORT(3));
+	writel(S626_XSD2 | S626_XFIFO_0 | ws_image,
+	       devpriv->mmio + S626_VECTPORT(3));
 	/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */
-	writel(XSD2 | XFIFO_3 | WS3, devpriv->mmio + S626_VECTPORT(4));
+	writel(S626_XSD2 | S626_XFIFO_3 | S626_WS3,
+	       devpriv->mmio + S626_VECTPORT(4));
 	/* Slot 5: running after writing target DAC's low data byte */
-	writel(XSD2 | XFIFO_2 | WS3 | EOS, devpriv->mmio + S626_VECTPORT(5));
+	writel(S626_XSD2 | S626_XFIFO_2 | S626_WS3 | S626_EOS,
+	       devpriv->mmio + S626_VECTPORT(5));
 
 	/*
 	 * Construct and transmit target DAC's serial packet:
@@ -574,13 +581,17 @@ static void s626_write_trim_dac(struct comedi_device *dev, uint8_t logical_chan,
 	 */
 
 	/* Slot 2: Send high uint8_t to target TrimDac */
-	writel(XSD2 | XFIFO_1 | WS3, devpriv->mmio + S626_VECTPORT(2));
+	writel(S626_XSD2 | S626_XFIFO_1 | S626_WS3,
+	       devpriv->mmio + S626_VECTPORT(2));
 	/* Slot 3: Send low uint8_t to target TrimDac */
-	writel(XSD2 | XFIFO_0 | WS3, devpriv->mmio + S626_VECTPORT(3));
+	writel(S626_XSD2 | S626_XFIFO_0 | S626_WS3,
+	       devpriv->mmio + S626_VECTPORT(3));
 	/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running */
-	writel(XSD2 | XFIFO_3 | WS1, devpriv->mmio + S626_VECTPORT(4));
+	writel(S626_XSD2 | S626_XFIFO_3 | S626_WS1,
+	       devpriv->mmio + S626_VECTPORT(4));
 	/* Slot 5: Send NOP low  uint8_t to DAC0 */
-	writel(XSD2 | XFIFO_2 | WS1 | EOS, devpriv->mmio + S626_VECTPORT(5));
+	writel(S626_XSD2 | S626_XFIFO_2 | S626_WS1 | S626_EOS,
+	       devpriv->mmio + S626_VECTPORT(5));
 
 	/*
 	 * Construct and transmit target DAC's serial packet:
@@ -643,8 +654,9 @@ static uint32_t s626_read_latch(struct comedi_device *dev,
 static void s626_set_latch_source(struct comedi_device *dev,
 				  const struct s626_enc_info *k, uint16_t value)
 {
-	s626_debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC),
-			  value << CRBBIT_LATCHSRC);
+	s626_debi_replace(dev, k->my_crb,
+			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_LATCHSRC),
+			  value << S626_CRBBIT_LATCHSRC);
 }
 
 /*
@@ -665,15 +677,15 @@ static void s626_preload(struct comedi_device *dev,
 static void s626_reset_cap_flags_a(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	s626_debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
-			  CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+	s626_debi_replace(dev, k->my_crb, ~S626_CRBMSK_INTCTRL,
+			  S626_CRBMSK_INTRESETCMD | S626_CRBMSK_INTRESET_A);
 }
 
 static void s626_reset_cap_flags_b(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	s626_debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
-			  CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
+	s626_debi_replace(dev, k->my_crb, ~S626_CRBMSK_INTCTRL,
+			  S626_CRBMSK_INTRESETCMD | S626_CRBMSK_INTRESET_B);
 }
 
 /*
@@ -695,41 +707,43 @@ static uint16_t s626_get_mode_a(struct comedi_device *dev,
 	 * Populate the standardized counter setup bit fields.
 	 * Note: IndexSrc is restricted to ENC_X or IndxPol.
 	 */
-	setup = (cra & STDMSK_LOADSRC) |	/* LoadSrc  = LoadSrcA. */
-		((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) &
-		 STDMSK_LATCHSRC) |		/* LatchSrc = LatchSrcA. */
-		((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) &
-		 STDMSK_INTSRC) |		/* IntSrc   = IntSrcA. */
-		((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) &
-		 STDMSK_INDXSRC) |		/* IndxSrc  = IndxSrcA<1>. */
-		((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) &
-		 STDMSK_INDXPOL) |		/* IndxPol  = IndxPolA. */
-		((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) &
-		 STDMSK_CLKENAB);		/* ClkEnab  = ClkEnabA. */
+	setup = (cra & S626_STDMSK_LOADSRC) |	/* LoadSrc  = LoadSrcA. */
+		((crb << (S626_STDBIT_LATCHSRC - S626_CRBBIT_LATCHSRC)) &
+		 S626_STDMSK_LATCHSRC) |	/* LatchSrc = LatchSrcA. */
+		((cra << (S626_STDBIT_INTSRC - S626_CRABIT_INTSRC_A)) &
+		 S626_STDMSK_INTSRC) |		/* IntSrc   = IntSrcA. */
+		((cra << (S626_STDBIT_INDXSRC - (S626_CRABIT_INDXSRC_A + 1))) &
+		 S626_STDMSK_INDXSRC) |		/* IndxSrc  = IndxSrcA<1>. */
+		((cra >> (S626_CRABIT_INDXPOL_A - S626_STDBIT_INDXPOL)) &
+		 S626_STDMSK_INDXPOL) |		/* IndxPol  = IndxPolA. */
+		((crb >> (S626_CRBBIT_CLKENAB_A - S626_STDBIT_CLKENAB)) &
+		 S626_STDMSK_CLKENAB);		/* ClkEnab  = ClkEnabA. */
 
 	/* Adjust mode-dependent parameters. */
-	if (cra & (2 << CRABIT_CLKSRC_A)) {
+	if (cra & (2 << S626_CRABIT_CLKSRC_A)) {
 		/* Timer mode (ClkSrcA<1> == 1): */
 		/* Indicate Timer mode. */
-		setup |= CLKSRC_TIMER << STDBIT_CLKSRC;
+		setup |= S626_CLKSRC_TIMER << S626_STDBIT_CLKSRC;
 		/* Set ClkPol to indicate count direction (ClkSrcA<0>). */
-		setup |= (cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) &
-			 STDMSK_CLKPOL;
+		setup |= (cra << (S626_STDBIT_CLKPOL - S626_CRABIT_CLKSRC_A)) &
+			 S626_STDMSK_CLKPOL;
 		/* ClkMult must be 1x in Timer mode. */
-		setup |= MULT_X1 << STDBIT_CLKMULT;
+		setup |= S626_MULT_X1 << S626_STDBIT_CLKMULT;
 	} else {
 		/* Counter mode (ClkSrcA<1> == 0): */
 		/* Indicate Counter mode. */
-		setup |= CLKSRC_COUNTER << STDBIT_CLKSRC;
+		setup |= S626_CLKSRC_COUNTER << S626_STDBIT_CLKSRC;
 		/* Pass through ClkPol. */
-		setup |= (cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) &
-			 STDMSK_CLKPOL;
+		setup |= (cra >> (S626_CRABIT_CLKPOL_A - S626_STDBIT_CLKPOL)) &
+			 S626_STDMSK_CLKPOL;
 		/* Force ClkMult to 1x if not legal, else pass through. */
-		if ((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A))
-			setup |= MULT_X1 << STDBIT_CLKMULT;
+		if ((cra & S626_CRAMSK_CLKMULT_A) ==
+		    (S626_MULT_X0 << S626_CRABIT_CLKMULT_A))
+			setup |= S626_MULT_X1 << S626_STDBIT_CLKMULT;
 		else
-			setup |= (cra >> (CRABIT_CLKMULT_A - STDBIT_CLKMULT)) &
-				 STDMSK_CLKMULT;
+			setup |= (cra >> (S626_CRABIT_CLKMULT_A -
+					  S626_STDBIT_CLKMULT)) &
+				 S626_STDMSK_CLKMULT;
 	}
 
 	/* Return adjusted counter setup. */
@@ -751,48 +765,49 @@ static uint16_t s626_get_mode_b(struct comedi_device *dev,
 	 * Populate the standardized counter setup bit fields.
 	 * Note: IndexSrc is restricted to ENC_X or IndxPol.
 	 */
-	setup = ((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) &
-		 STDMSK_INTSRC) |		/* IntSrc   = IntSrcB. */
-		((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) &
-		 STDMSK_LATCHSRC) |		/* LatchSrc = LatchSrcB. */
-		((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) &
-		 STDMSK_LOADSRC) |		/* LoadSrc  = LoadSrcB. */
-		((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) &
-		 STDMSK_INDXPOL) |		/* IndxPol  = IndxPolB. */
-		((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) &
-		 STDMSK_CLKENAB) |		/* ClkEnab  = ClkEnabB. */
-		((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) &
-		 STDMSK_INDXSRC);		/* IndxSrc  = IndxSrcB<1>. */
+	setup = ((crb << (S626_STDBIT_INTSRC - S626_CRBBIT_INTSRC_B)) &
+		 S626_STDMSK_INTSRC) |		/* IntSrc   = IntSrcB. */
+		((crb << (S626_STDBIT_LATCHSRC - S626_CRBBIT_LATCHSRC)) &
+		 S626_STDMSK_LATCHSRC) |	/* LatchSrc = LatchSrcB. */
+		((crb << (S626_STDBIT_LOADSRC - S626_CRBBIT_LOADSRC_B)) &
+		 S626_STDMSK_LOADSRC) |		/* LoadSrc  = LoadSrcB. */
+		((crb << (S626_STDBIT_INDXPOL - S626_CRBBIT_INDXPOL_B)) &
+		 S626_STDMSK_INDXPOL) |		/* IndxPol  = IndxPolB. */
+		((crb >> (S626_CRBBIT_CLKENAB_B - S626_STDBIT_CLKENAB)) &
+		 S626_STDMSK_CLKENAB) |		/* ClkEnab  = ClkEnabB. */
+		((cra >> ((S626_CRABIT_INDXSRC_B + 1) - S626_STDBIT_INDXSRC)) &
+		 S626_STDMSK_INDXSRC);		/* IndxSrc  = IndxSrcB<1>. */
 
 	/* Adjust mode-dependent parameters. */
-	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B)) {
-		/* Extender mode (ClkMultB == MULT_X0): */
+	if ((crb & S626_CRBMSK_CLKMULT_B) ==
+	    (S626_MULT_X0 << S626_CRBBIT_CLKMULT_B)) {
+		/* Extender mode (ClkMultB == S626_MULT_X0): */
 		/* Indicate Extender mode. */
-		setup |= CLKSRC_EXTENDER << STDBIT_CLKSRC;
+		setup |= S626_CLKSRC_EXTENDER << S626_STDBIT_CLKSRC;
 		/* Indicate multiplier is 1x. */
-		setup |= MULT_X1 << STDBIT_CLKMULT;
+		setup |= S626_MULT_X1 << S626_STDBIT_CLKMULT;
 		/* Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
-		setup |= (cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) &
-			 STDMSK_CLKPOL;
-	} else if (cra & (2 << CRABIT_CLKSRC_B)) {
+		setup |= (cra >> (S626_CRABIT_CLKSRC_B - S626_STDBIT_CLKPOL)) &
+			 S626_STDMSK_CLKPOL;
+	} else if (cra & (2 << S626_CRABIT_CLKSRC_B)) {
 		/* Timer mode (ClkSrcB<1> == 1): */
 		/* Indicate Timer mode. */
-		setup |= CLKSRC_TIMER << STDBIT_CLKSRC;
+		setup |= S626_CLKSRC_TIMER << S626_STDBIT_CLKSRC;
 		/* Indicate multiplier is 1x. */
-		setup |= MULT_X1 << STDBIT_CLKMULT;
+		setup |= S626_MULT_X1 << S626_STDBIT_CLKMULT;
 		/* Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
-		setup |= (cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) &
-			 STDMSK_CLKPOL;
+		setup |= (cra >> (S626_CRABIT_CLKSRC_B - S626_STDBIT_CLKPOL)) &
+			 S626_STDMSK_CLKPOL;
 	} else {
 		/* If Counter mode (ClkSrcB<1> == 0): */
 		/* Indicate Timer mode. */
-		setup |= CLKSRC_COUNTER << STDBIT_CLKSRC;
+		setup |= S626_CLKSRC_COUNTER << S626_STDBIT_CLKSRC;
 		/* Clock multiplier is passed through. */
-		setup |= (crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) &
-			 STDMSK_CLKMULT;
+		setup |= (crb >> (S626_CRBBIT_CLKMULT_B -
+				  S626_STDBIT_CLKMULT)) & S626_STDMSK_CLKMULT;
 		/* Clock polarity is passed through. */
-		setup |= (crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) &
-			 STDMSK_CLKPOL;
+		setup |= (crb << (S626_STDBIT_CLKPOL - S626_CRBBIT_CLKPOL_B)) &
+			 S626_STDMSK_CLKPOL;
 	}
 
 	/* Return adjusted counter setup. */
@@ -815,49 +830,51 @@ static void s626_set_mode_a(struct comedi_device *dev,
 
 	/* Initialize CRA and CRB images. */
 	/* Preload trigger is passed through. */
-	cra = setup & CRAMSK_LOADSRC_A;
+	cra = setup & S626_CRAMSK_LOADSRC_A;
 	/* IndexSrc is restricted to ENC_X or IndxPol. */
-	cra |= ((setup & STDMSK_INDXSRC) >>
-		(STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1)));
+	cra |= (setup & S626_STDMSK_INDXSRC) >>
+	       (S626_STDBIT_INDXSRC - (S626_CRABIT_INDXSRC_A + 1));
 
 	/* Reset any pending CounterA event captures. */
-	crb = CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A;
+	crb = S626_CRBMSK_INTRESETCMD | S626_CRBMSK_INTRESET_A;
 	/* Clock enable is passed through. */
-	crb |= (setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB);
+	crb |= (setup & S626_STDMSK_CLKENAB) <<
+	       (S626_CRBBIT_CLKENAB_A - S626_STDBIT_CLKENAB);
 
 	/* Force IntSrc to Disabled if disable_int_src is asserted. */
 	if (!disable_int_src)
-		cra |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
-						    CRABIT_INTSRC_A));
+		cra |= (setup & S626_STDMSK_INTSRC) >>
+		       (S626_STDBIT_INTSRC - S626_CRABIT_INTSRC_A);
 
 	/* Populate all mode-dependent attributes of CRA & CRB images. */
-	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
-	case CLKSRC_EXTENDER:	/* Extender Mode: Force to Timer mode
-				 * (Extender valid only for B counters). */
-		/* Fall through to case CLKSRC_TIMER: */
-	case CLKSRC_TIMER:	/* Timer Mode: */
+	switch ((setup & S626_STDMSK_CLKSRC) >> S626_STDBIT_CLKSRC) {
+	case S626_CLKSRC_EXTENDER: /* Extender Mode: */
+		/* Force to Timer mode (Extender valid only for B counters). */
+		/* Fall through to case S626_CLKSRC_TIMER: */
+	case S626_CLKSRC_TIMER:	/* Timer Mode: */
 		/* ClkSrcA<1> selects system clock */
-		cra |= 2 << CRABIT_CLKSRC_A;
+		cra |= 2 << S626_CRABIT_CLKSRC_A;
 		/* Count direction (ClkSrcA<0>) obtained from ClkPol. */
-		cra |= (setup & STDMSK_CLKPOL) >>
-		       (STDBIT_CLKPOL - CRABIT_CLKSRC_A);
+		cra |= (setup & S626_STDMSK_CLKPOL) >>
+		       (S626_STDBIT_CLKPOL - S626_CRABIT_CLKSRC_A);
 		/* ClkPolA behaves as always-on clock enable. */
-		cra |= 1 << CRABIT_CLKPOL_A;
+		cra |= 1 << S626_CRABIT_CLKPOL_A;
 		/* ClkMult must be 1x. */
-		cra |= MULT_X1 << CRABIT_CLKMULT_A;
+		cra |= S626_MULT_X1 << S626_CRABIT_CLKMULT_A;
 		break;
 	default:		/* Counter Mode: */
 		/* Select ENC_C and ENC_D as clock/direction inputs. */
-		cra |= CLKSRC_COUNTER;
+		cra |= S626_CLKSRC_COUNTER;
 		/* Clock polarity is passed through. */
-		cra |= (setup & STDMSK_CLKPOL) <<
-		       (CRABIT_CLKPOL_A - STDBIT_CLKPOL);
+		cra |= (setup & S626_STDMSK_CLKPOL) <<
+		       (S626_CRABIT_CLKPOL_A - S626_STDBIT_CLKPOL);
 		/* Force multiplier to x1 if not legal, else pass through. */
-		if ((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT))
-			cra |= MULT_X1 << CRABIT_CLKMULT_A;
+		if ((setup & S626_STDMSK_CLKMULT) ==
+		    (S626_MULT_X0 << S626_STDBIT_CLKMULT))
+			cra |= S626_MULT_X1 << S626_CRABIT_CLKMULT_A;
 		else
-			cra |= (setup & STDMSK_CLKMULT) <<
-			       (CRABIT_CLKMULT_A - STDBIT_CLKMULT);
+			cra |= (setup & S626_STDMSK_CLKMULT) <<
+			       (S626_CRABIT_CLKMULT_A - S626_STDBIT_CLKMULT);
 		break;
 	}
 
@@ -865,9 +882,9 @@ static void s626_set_mode_a(struct comedi_device *dev,
 	 * Force positive index polarity if IndxSrc is software-driven only,
 	 * otherwise pass it through.
 	 */
-	if (~setup & STDMSK_INDXSRC)
-		cra |= (setup & STDMSK_INDXPOL) <<
-		       (CRABIT_INDXPOL_A - STDBIT_INDXPOL);
+	if (~setup & S626_STDMSK_INDXSRC)
+		cra |= (setup & S626_STDMSK_INDXPOL) <<
+		       (S626_CRABIT_INDXPOL_A - S626_STDBIT_INDXPOL);
 
 	/*
 	 * If IntSrc has been forced to Disabled, update the MISC2 interrupt
@@ -880,10 +897,10 @@ static void s626_set_mode_a(struct comedi_device *dev,
 	 * While retaining CounterB and LatchSrc configurations, program the
 	 * new counter operating mode.
 	 */
-	s626_debi_replace(dev, k->my_cra, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B,
-			  cra);
-	s626_debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A),
-			  crb);
+	s626_debi_replace(dev, k->my_cra,
+			  S626_CRAMSK_INDXSRC_B | S626_CRAMSK_CLKSRC_B, cra);
+	s626_debi_replace(dev, k->my_crb,
+			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_A), crb);
 }
 
 static void s626_set_mode_b(struct comedi_device *dev,
@@ -896,57 +913,60 @@ static void s626_set_mode_b(struct comedi_device *dev,
 
 	/* Initialize CRA and CRB images. */
 	/* IndexSrc field is restricted to ENC_X or IndxPol. */
-	cra = (setup & STDMSK_INDXSRC) <<
-	      (CRABIT_INDXSRC_B + 1 - STDBIT_INDXSRC);
+	cra = (setup & S626_STDMSK_INDXSRC) <<
+	      (S626_CRABIT_INDXSRC_B + 1 - S626_STDBIT_INDXSRC);
 
 	/* Reset event captures and disable interrupts. */
-	crb = CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B;
+	crb = S626_CRBMSK_INTRESETCMD | S626_CRBMSK_INTRESET_B;
 	/* Clock enable is passed through. */
-	crb |= (setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB);
+	crb |= (setup & S626_STDMSK_CLKENAB) <<
+	       (S626_CRBBIT_CLKENAB_B - S626_STDBIT_CLKENAB);
 	/* Preload trigger source is passed through. */
-	crb |= (setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B);
+	crb |= (setup & S626_STDMSK_LOADSRC) >>
+	       (S626_STDBIT_LOADSRC - S626_CRBBIT_LOADSRC_B);
 
 	/* Force IntSrc to Disabled if disable_int_src is asserted. */
 	if (!disable_int_src)
-		crb |= (setup & STDMSK_INTSRC) >>
-		       (STDBIT_INTSRC - CRBBIT_INTSRC_B);
+		crb |= (setup & S626_STDMSK_INTSRC) >>
+		       (S626_STDBIT_INTSRC - S626_CRBBIT_INTSRC_B);
 
 	/* Populate all mode-dependent attributes of CRA & CRB images. */
-	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
-	case CLKSRC_TIMER:	/* Timer Mode: */
+	switch ((setup & S626_STDMSK_CLKSRC) >> S626_STDBIT_CLKSRC) {
+	case S626_CLKSRC_TIMER:	/* Timer Mode: */
 		/* ClkSrcB<1> selects system clock */
-		cra |= 2 << CRABIT_CLKSRC_B;
+		cra |= 2 << S626_CRABIT_CLKSRC_B;
 		/* with direction (ClkSrcB<0>) obtained from ClkPol. */
-		cra |= (setup & STDMSK_CLKPOL) <<
-		       (CRABIT_CLKSRC_B - STDBIT_CLKPOL);
+		cra |= (setup & S626_STDMSK_CLKPOL) <<
+		       (S626_CRABIT_CLKSRC_B - S626_STDBIT_CLKPOL);
 		/* ClkPolB behaves as always-on clock enable. */
-		crb |= 1 << CRBBIT_CLKPOL_B;
+		crb |= 1 << S626_CRBBIT_CLKPOL_B;
 		/* ClkMultB must be 1x. */
-		crb |= MULT_X1 << CRBBIT_CLKMULT_B;
+		crb |= S626_MULT_X1 << S626_CRBBIT_CLKMULT_B;
 		break;
-	case CLKSRC_EXTENDER:	/* Extender Mode: */
+	case S626_CLKSRC_EXTENDER:	/* Extender Mode: */
 		/* ClkSrcB source is OverflowA (same as "timer") */
-		cra |= 2 << CRABIT_CLKSRC_B;
+		cra |= 2 << S626_CRABIT_CLKSRC_B;
 		/* with direction obtained from ClkPol. */
-		cra |= (setup & STDMSK_CLKPOL) <<
-		       (CRABIT_CLKSRC_B - STDBIT_CLKPOL);
+		cra |= (setup & S626_STDMSK_CLKPOL) <<
+		       (S626_CRABIT_CLKSRC_B - S626_STDBIT_CLKPOL);
 		/* ClkPolB controls IndexB -- always set to active. */
-		crb |= 1 << CRBBIT_CLKPOL_B;
+		crb |= 1 << S626_CRBBIT_CLKPOL_B;
 		/* ClkMultB selects OverflowA as the clock source. */
-		crb |= MULT_X0 << CRBBIT_CLKMULT_B;
+		crb |= S626_MULT_X0 << S626_CRBBIT_CLKMULT_B;
 		break;
 	default:		/* Counter Mode: */
 		/* Select ENC_C and ENC_D as clock/direction inputs. */
-		cra |= CLKSRC_COUNTER << CRABIT_CLKSRC_B;
+		cra |= S626_CLKSRC_COUNTER << S626_CRABIT_CLKSRC_B;
 		/* ClkPol is passed through. */
-		crb |= (setup & STDMSK_CLKPOL) >>
-		       (STDBIT_CLKPOL - CRBBIT_CLKPOL_B);
+		crb |= (setup & S626_STDMSK_CLKPOL) >>
+		       (S626_STDBIT_CLKPOL - S626_CRBBIT_CLKPOL_B);
 		/* Force ClkMult to x1 if not legal, otherwise pass through. */
-		if ((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT))
-			crb |= MULT_X1 << CRBBIT_CLKMULT_B;
+		if ((setup & S626_STDMSK_CLKMULT) ==
+		    (S626_MULT_X0 << S626_STDBIT_CLKMULT))
+			crb |= S626_MULT_X1 << S626_CRBBIT_CLKMULT_B;
 		else
-			crb |= (setup & STDMSK_CLKMULT) <<
-			       (CRBBIT_CLKMULT_B - STDBIT_CLKMULT);
+			crb |= (setup & S626_STDMSK_CLKMULT) <<
+			       (S626_CRBBIT_CLKMULT_B - S626_STDBIT_CLKMULT);
 		break;
 	}
 
@@ -954,9 +974,9 @@ static void s626_set_mode_b(struct comedi_device *dev,
 	 * Force positive index polarity if IndxSrc is software-driven only,
 	 * otherwise pass it through.
 	 */
-	if (~setup & STDMSK_INDXSRC)
-		crb |= (setup & STDMSK_INDXPOL) >>
-		       (STDBIT_INDXPOL - CRBBIT_INDXPOL_B);
+	if (~setup & S626_STDMSK_INDXSRC)
+		crb |= (setup & S626_STDMSK_INDXPOL) >>
+		       (S626_STDBIT_INDXPOL - S626_CRBBIT_INDXPOL_B);
 
 	/*
 	 * If IntSrc has been forced to Disabled, update the MISC2 interrupt
@@ -969,10 +989,10 @@ static void s626_set_mode_b(struct comedi_device *dev,
 	 * While retaining CounterA and LatchSrc configurations, program the
 	 * new counter operating mode.
 	 */
-	s626_debi_replace(dev, k->my_cra, ~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B),
-			  cra);
-	s626_debi_replace(dev, k->my_crb, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC,
-			  crb);
+	s626_debi_replace(dev, k->my_cra,
+			  ~(S626_CRAMSK_INDXSRC_B | S626_CRAMSK_CLKSRC_B), cra);
+	s626_debi_replace(dev, k->my_crb,
+			  S626_CRBMSK_CLKENAB_A | S626_CRBMSK_LATCHSRC, crb);
 }
 
 /*
@@ -981,34 +1001,36 @@ static void s626_set_mode_b(struct comedi_device *dev,
 static void s626_set_enable_a(struct comedi_device *dev,
 			      const struct s626_enc_info *k, uint16_t enab)
 {
-	s626_debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A),
-			  enab << CRBBIT_CLKENAB_A);
+	s626_debi_replace(dev, k->my_crb,
+			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_A),
+			  enab << S626_CRBBIT_CLKENAB_A);
 }
 
 static void s626_set_enable_b(struct comedi_device *dev,
 			      const struct s626_enc_info *k, uint16_t enab)
 {
-	s626_debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B),
-			  enab << CRBBIT_CLKENAB_B);
+	s626_debi_replace(dev, k->my_crb,
+			  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_B),
+			  enab << S626_CRBBIT_CLKENAB_B);
 }
 
 static uint16_t s626_get_enable_a(struct comedi_device *dev,
 				  const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_A) & 1;
+	return (s626_debi_read(dev, k->my_crb) >> S626_CRBBIT_CLKENAB_A) & 1;
 }
 
 static uint16_t s626_get_enable_b(struct comedi_device *dev,
 				  const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_B) & 1;
+	return (s626_debi_read(dev, k->my_crb) >> S626_CRBBIT_CLKENAB_B) & 1;
 }
 
 #ifdef unused
 static uint16_t s626_get_latch_source(struct comedi_device *dev,
 				      const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_crb) >> CRBBIT_LATCHSRC) & 3;
+	return (s626_debi_read(dev, k->my_crb) >> S626_CRBBIT_LATCHSRC) & 3;
 }
 #endif
 
@@ -1020,27 +1042,28 @@ static uint16_t s626_get_latch_source(struct comedi_device *dev,
 static void s626_set_load_trig_a(struct comedi_device *dev,
 				 const struct s626_enc_info *k, uint16_t trig)
 {
-	s626_debi_replace(dev, k->my_cra, ~CRAMSK_LOADSRC_A,
-			  trig << CRABIT_LOADSRC_A);
+	s626_debi_replace(dev, k->my_cra, ~S626_CRAMSK_LOADSRC_A,
+			  trig << S626_CRABIT_LOADSRC_A);
 }
 
 static void s626_set_load_trig_b(struct comedi_device *dev,
 				 const struct s626_enc_info *k, uint16_t trig)
 {
-	s626_debi_replace(dev, k->my_crb, ~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL),
-			  trig << CRBBIT_LOADSRC_B);
+	s626_debi_replace(dev, k->my_crb,
+			  ~(S626_CRBMSK_LOADSRC_B | S626_CRBMSK_INTCTRL),
+			  trig << S626_CRBBIT_LOADSRC_B);
 }
 
 static uint16_t s626_get_load_trig_a(struct comedi_device *dev,
 				     const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_cra) >> CRABIT_LOADSRC_A) & 3;
+	return (s626_debi_read(dev, k->my_cra) >> S626_CRABIT_LOADSRC_A) & 3;
 }
 
 static uint16_t s626_get_load_trig_b(struct comedi_device *dev,
 				     const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_crb) >> CRBBIT_LOADSRC_B) & 3;
+	return (s626_debi_read(dev, k->my_crb) >> S626_CRBBIT_LOADSRC_B) & 3;
 }
 
 /*
@@ -1055,12 +1078,12 @@ static void s626_set_int_src_a(struct comedi_device *dev,
 	struct s626_private *devpriv = dev->private;
 
 	/* Reset any pending counter overflow or index captures. */
-	s626_debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
-			  CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+	s626_debi_replace(dev, k->my_crb, ~S626_CRBMSK_INTCTRL,
+			  S626_CRBMSK_INTRESETCMD | S626_CRBMSK_INTRESET_A);
 
 	/* Program counter interrupt source. */
-	s626_debi_replace(dev, k->my_cra, ~CRAMSK_INTSRC_A,
-			  int_source << CRABIT_INTSRC_A);
+	s626_debi_replace(dev, k->my_cra, ~S626_CRAMSK_INTSRC_A,
+			  int_source << S626_CRABIT_INTSRC_A);
 
 	/* Update MISC2 interrupt enable mask. */
 	devpriv->counter_int_enabs =
@@ -1076,16 +1099,16 @@ static void s626_set_int_src_b(struct comedi_device *dev,
 	uint16_t crb;
 
 	/* Cache writeable CRB register image. */
-	crb = s626_debi_read(dev, k->my_crb) & ~CRBMSK_INTCTRL;
+	crb = s626_debi_read(dev, k->my_crb) & ~S626_CRBMSK_INTCTRL;
 
 	/* Reset any pending counter overflow or index captures. */
-	s626_debi_write(dev, k->my_crb,
-			(crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
+	s626_debi_write(dev, k->my_crb, (crb | S626_CRBMSK_INTRESETCMD |
+					 S626_CRBMSK_INTRESET_B));
 
 	/* Program counter interrupt source. */
 	s626_debi_write(dev, k->my_crb,
-			((crb & ~CRBMSK_INTSRC_B) |
-			 (int_source << CRBBIT_INTSRC_B)));
+			((crb & ~S626_CRBMSK_INTSRC_B) |
+			 (int_source << S626_CRBBIT_INTSRC_B)));
 
 	/* Update MISC2 interrupt enable mask. */
 	devpriv->counter_int_enabs =
@@ -1096,13 +1119,13 @@ static void s626_set_int_src_b(struct comedi_device *dev,
 static uint16_t s626_get_int_src_a(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_cra) >> CRABIT_INTSRC_A) & 3;
+	return (s626_debi_read(dev, k->my_cra) >> S626_CRABIT_INTSRC_A) & 3;
 }
 
 static uint16_t s626_get_int_src_b(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	return (s626_debi_read(dev, k->my_crb) >> CRBBIT_INTSRC_B) & 3;
+	return (s626_debi_read(dev, k->my_crb) >> S626_CRBBIT_INTSRC_B) & 3;
 }
 
 #ifdef unused
@@ -1112,14 +1135,14 @@ static uint16_t s626_get_int_src_b(struct comedi_device *dev,
 static void s626_set_clk_mult(struct comedi_device *dev,
 			      const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKMULT) |
-			    (value << STDBIT_CLKMULT)), false);
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_CLKMULT) |
+			    (value << S626_STDBIT_CLKMULT)), false);
 }
 
 static uint16_t s626_get_clk_mult(struct comedi_device *dev,
 				  const struct s626_enc_info *k)
 {
-	return (k->get_mode(dev, k) >> STDBIT_CLKMULT) & 3;
+	return (k->get_mode(dev, k) >> S626_STDBIT_CLKMULT) & 3;
 }
 
 /*
@@ -1128,14 +1151,14 @@ static uint16_t s626_get_clk_mult(struct comedi_device *dev,
 static void s626_set_clk_pol(struct comedi_device *dev,
 			     const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKPOL) |
-			    (value << STDBIT_CLKPOL)), false);
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_CLKPOL) |
+			    (value << S626_STDBIT_CLKPOL)), false);
 }
 
 static uint16_t s626_get_clk_pol(struct comedi_device *dev,
 				 const struct s626_enc_info *k)
 {
-	return (k->get_mode(dev, k) >> STDBIT_CLKPOL) & 1;
+	return (k->get_mode(dev, k) >> S626_STDBIT_CLKPOL) & 1;
 }
 
 /*
@@ -1144,14 +1167,14 @@ static uint16_t s626_get_clk_pol(struct comedi_device *dev,
 static void s626_set_clk_src(struct comedi_device *dev,
 			     const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKSRC) |
-			    (value << STDBIT_CLKSRC)), false);
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_CLKSRC) |
+			    (value << S626_STDBIT_CLKSRC)), false);
 }
 
 static uint16_t s626_get_clk_src(struct comedi_device *dev,
 				 const struct s626_enc_info *k)
 {
-	return (k->get_mode(dev, k) >> STDBIT_CLKSRC) & 3;
+	return (k->get_mode(dev, k) >> S626_STDBIT_CLKSRC) & 3;
 }
 
 /*
@@ -1160,14 +1183,14 @@ static uint16_t s626_get_clk_src(struct comedi_device *dev,
 static void s626_set_index_pol(struct comedi_device *dev,
 			       const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXPOL) |
-			    ((value != 0) << STDBIT_INDXPOL)), false);
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_INDXPOL) |
+			    ((value != 0) << S626_STDBIT_INDXPOL)), false);
 }
 
 static uint16_t s626_get_index_pol(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	return (k->get_mode(dev, k) >> STDBIT_INDXPOL) & 1;
+	return (k->get_mode(dev, k) >> S626_STDBIT_INDXPOL) & 1;
 }
 
 /*
@@ -1176,14 +1199,14 @@ static uint16_t s626_get_index_pol(struct comedi_device *dev,
 static void s626_set_index_src(struct comedi_device *dev,
 			       const struct s626_enc_info *k, uint16_t value)
 {
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXSRC) |
-			    ((value != 0) << STDBIT_INDXSRC)), false);
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~S626_STDMSK_INDXSRC) |
+			    ((value != 0) << S626_STDBIT_INDXSRC)), false);
 }
 
 static uint16_t s626_get_index_src(struct comedi_device *dev,
 				   const struct s626_enc_info *k)
 {
-	return (k->get_mode(dev, k) >> STDBIT_INDXSRC) & 1;
+	return (k->get_mode(dev, k) >> S626_STDBIT_INDXSRC) & 1;
 }
 #endif
 
@@ -1197,7 +1220,7 @@ static void s626_pulse_index_a(struct comedi_device *dev,
 
 	cra = s626_debi_read(dev, k->my_cra);
 	/* Pulse index. */
-	s626_debi_write(dev, k->my_cra, (cra ^ CRAMSK_INDXPOL_A));
+	s626_debi_write(dev, k->my_cra, (cra ^ S626_CRAMSK_INDXPOL_A));
 	s626_debi_write(dev, k->my_cra, cra);
 }
 
@@ -1206,9 +1229,9 @@ static void s626_pulse_index_b(struct comedi_device *dev,
 {
 	uint16_t crb;
 
-	crb = s626_debi_read(dev, k->my_crb) & ~CRBMSK_INTCTRL;
+	crb = s626_debi_read(dev, k->my_crb) & ~S626_CRBMSK_INTCTRL;
 	/* Pulse index. */
-	s626_debi_write(dev, k->my_crb, (crb ^ CRBMSK_INDXPOL_B));
+	s626_debi_write(dev, k->my_crb, (crb ^ S626_CRBMSK_INDXPOL_B));
 	s626_debi_write(dev, k->my_crb, crb);
 }
 
@@ -1224,9 +1247,9 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_cra			= LP_CR0A,
-		.my_crb			= LP_CR0B,
-		.my_latch_lsw		= LP_CNTR0ALSW,
+		.my_cra			= S626_LP_CR0A,
+		.my_crb			= S626_LP_CR0B,
+		.my_latch_lsw		= S626_LP_CNTR0ALSW,
 		.my_event_bits		= S626_EVBITS(0),
 	}, {
 		.get_enable		= s626_get_enable_a,
@@ -1239,9 +1262,9 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_cra			= LP_CR1A,
-		.my_crb			= LP_CR1B,
-		.my_latch_lsw		= LP_CNTR1ALSW,
+		.my_cra			= S626_LP_CR1A,
+		.my_crb			= S626_LP_CR1B,
+		.my_latch_lsw		= S626_LP_CNTR1ALSW,
 		.my_event_bits		= S626_EVBITS(1),
 	}, {
 		.get_enable		= s626_get_enable_a,
@@ -1254,9 +1277,9 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_a,
 		.set_mode		= s626_set_mode_a,
 		.reset_cap_flags	= s626_reset_cap_flags_a,
-		.my_cra			= LP_CR2A,
-		.my_crb			= LP_CR2B,
-		.my_latch_lsw		= LP_CNTR2ALSW,
+		.my_cra			= S626_LP_CR2A,
+		.my_crb			= S626_LP_CR2B,
+		.my_latch_lsw		= S626_LP_CNTR2ALSW,
 		.my_event_bits		= S626_EVBITS(2),
 	}, {
 		.get_enable		= s626_get_enable_b,
@@ -1269,9 +1292,9 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_cra			= LP_CR0A,
-		.my_crb			= LP_CR0B,
-		.my_latch_lsw		= LP_CNTR0BLSW,
+		.my_cra			= S626_LP_CR0A,
+		.my_crb			= S626_LP_CR0B,
+		.my_latch_lsw		= S626_LP_CNTR0BLSW,
 		.my_event_bits		= S626_EVBITS(3),
 	}, {
 		.get_enable		= s626_get_enable_b,
@@ -1284,9 +1307,9 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_cra			= LP_CR1A,
-		.my_crb			= LP_CR1B,
-		.my_latch_lsw		= LP_CNTR1BLSW,
+		.my_cra			= S626_LP_CR1A,
+		.my_crb			= S626_LP_CR1B,
+		.my_latch_lsw		= S626_LP_CNTR1BLSW,
 		.my_event_bits		= S626_EVBITS(4),
 	}, {
 		.get_enable		= s626_get_enable_b,
@@ -1299,9 +1322,9 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.set_load_trig		= s626_set_load_trig_b,
 		.set_mode		= s626_set_mode_b,
 		.reset_cap_flags	= s626_reset_cap_flags_b,
-		.my_cra			= LP_CR2A,
-		.my_crb			= LP_CR2B,
-		.my_latch_lsw		= LP_CNTR2BLSW,
+		.my_cra			= S626_LP_CR2A,
+		.my_crb			= S626_LP_CR2B,
+		.my_latch_lsw		= S626_LP_CNTR2BLSW,
 		.my_event_bits		= S626_EVBITS(5),
 	},
 };
@@ -1326,19 +1349,19 @@ static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
 	unsigned int status;
 
 	/* set channel to capture positive edge */
-	status = s626_debi_read(dev, LP_RDEDGSEL(group));
-	s626_debi_write(dev, LP_WREDGSEL(group), mask | status);
+	status = s626_debi_read(dev, S626_LP_RDEDGSEL(group));
+	s626_debi_write(dev, S626_LP_WREDGSEL(group), mask | status);
 
 	/* enable interrupt on selected channel */
-	status = s626_debi_read(dev, LP_RDINTSEL(group));
-	s626_debi_write(dev, LP_WRINTSEL(group), mask | status);
+	status = s626_debi_read(dev, S626_LP_RDINTSEL(group));
+	s626_debi_write(dev, S626_LP_WRINTSEL(group), mask | status);
 
 	/* enable edge capture write command */
-	s626_debi_write(dev, LP_MISC1, MISC1_EDCAP);
+	s626_debi_write(dev, S626_LP_MISC1, S626_MISC1_EDCAP);
 
 	/* enable edge capture on selected channel */
-	status = s626_debi_read(dev, LP_RDCAPSEL(group));
-	s626_debi_write(dev, LP_WRCAPSEL(group), mask | status);
+	status = s626_debi_read(dev, S626_LP_RDCAPSEL(group));
+	s626_debi_write(dev, S626_LP_WRCAPSEL(group), mask | status);
 
 	return 0;
 }
@@ -1347,10 +1370,10 @@ static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,
 			      unsigned int mask)
 {
 	/* disable edge capture write command */
-	s626_debi_write(dev, LP_MISC1, MISC1_NOEDCAP);
+	s626_debi_write(dev, S626_LP_MISC1, S626_MISC1_NOEDCAP);
 
 	/* enable edge capture on selected channel */
-	s626_debi_write(dev, LP_WRCAPSEL(group), mask);
+	s626_debi_write(dev, S626_LP_WRCAPSEL(group), mask);
 
 	return 0;
 }
@@ -1360,11 +1383,11 @@ static int s626_dio_clear_irq(struct comedi_device *dev)
 	unsigned int group;
 
 	/* disable edge capture write command */
-	s626_debi_write(dev, LP_MISC1, MISC1_NOEDCAP);
+	s626_debi_write(dev, S626_LP_MISC1, S626_MISC1_NOEDCAP);
 
 	/* clear all dio pending events and interrupt */
 	for (group = 0; group < S626_DIO_BANKS; group++)
-		s626_debi_write(dev, LP_WRCAPSEL(group), 0xffff);
+		s626_debi_write(dev, S626_LP_WRCAPSEL(group), 0xffff);
 
 	return 0;
 }
@@ -1383,7 +1406,7 @@ static void s626_handle_dio_interrupt(struct comedi_device *dev,
 		if ((irqbit >> (cmd->start_arg - (16 * group))) == 1 &&
 		    cmd->start_src == TRIG_EXT) {
 			/* Start executing the RPS program */
-			s626_mc_enable(dev, MC1_ERPS1, P_MC1);
+			s626_mc_enable(dev, S626_MC1_ERPS1, S626_P_MC1);
 
 			if (cmd->scan_begin_src == TRIG_EXT)
 				s626_dio_set_irq(dev, cmd->scan_begin_arg);
@@ -1391,7 +1414,7 @@ static void s626_handle_dio_interrupt(struct comedi_device *dev,
 		if ((irqbit >> (cmd->scan_begin_arg - (16 * group))) == 1 &&
 		    cmd->scan_begin_src == TRIG_EXT) {
 			/* Trigger ADC scan loop start */
-			s626_mc_enable(dev, MC2_ADC_RPS, P_MC2);
+			s626_mc_enable(dev, S626_MC2_ADC_RPS, S626_P_MC2);
 
 			if (cmd->convert_src == TRIG_EXT) {
 				devpriv->ai_convert_count = cmd->chanlist_len;
@@ -1404,13 +1427,13 @@ static void s626_handle_dio_interrupt(struct comedi_device *dev,
 					&s626_enc_chan_info[5];
 
 				devpriv->ai_convert_count = cmd->chanlist_len;
-				k->set_enable(dev, k, CLKENAB_ALWAYS);
+				k->set_enable(dev, k, S626_CLKENAB_ALWAYS);
 			}
 		}
 		if ((irqbit >> (cmd->convert_arg - (16 * group))) == 1 &&
 		    cmd->convert_src == TRIG_EXT) {
 			/* Trigger ADC scan loop start */
-			s626_mc_enable(dev, MC2_ADC_RPS, P_MC2);
+			s626_mc_enable(dev, S626_MC2_ADC_RPS, S626_P_MC2);
 
 			devpriv->ai_convert_count--;
 			if (devpriv->ai_convert_count > 0)
@@ -1427,7 +1450,7 @@ static void s626_check_dio_interrupts(struct comedi_device *dev)
 	for (group = 0; group < S626_DIO_BANKS; group++) {
 		irqbit = 0;
 		/* read interrupt type */
-		irqbit = s626_debi_read(dev, LP_RDCAPFLG(group));
+		irqbit = s626_debi_read(dev, S626_LP_RDCAPFLG(group));
 
 		/* check if interrupt is generated from dio channels */
 		if (irqbit) {
@@ -1447,34 +1470,34 @@ static void s626_check_counter_interrupts(struct comedi_device *dev)
 	uint16_t irqbit;
 
 	/* read interrupt type */
-	irqbit = s626_debi_read(dev, LP_RDMISC2);
+	irqbit = s626_debi_read(dev, S626_LP_RDMISC2);
 
 	/* check interrupt on counters */
-	if (irqbit & IRQ_COINT1A) {
+	if (irqbit & S626_IRQ_COINT1A) {
 		k = &s626_enc_chan_info[0];
 
 		/* clear interrupt capture flag */
 		k->reset_cap_flags(dev, k);
 	}
-	if (irqbit & IRQ_COINT2A) {
+	if (irqbit & S626_IRQ_COINT2A) {
 		k = &s626_enc_chan_info[1];
 
 		/* clear interrupt capture flag */
 		k->reset_cap_flags(dev, k);
 	}
-	if (irqbit & IRQ_COINT3A) {
+	if (irqbit & S626_IRQ_COINT3A) {
 		k = &s626_enc_chan_info[2];
 
 		/* clear interrupt capture flag */
 		k->reset_cap_flags(dev, k);
 	}
-	if (irqbit & IRQ_COINT1B) {
+	if (irqbit & S626_IRQ_COINT1B) {
 		k = &s626_enc_chan_info[3];
 
 		/* clear interrupt capture flag */
 		k->reset_cap_flags(dev, k);
 	}
-	if (irqbit & IRQ_COINT2B) {
+	if (irqbit & S626_IRQ_COINT2B) {
 		k = &s626_enc_chan_info[4];
 
 		/* clear interrupt capture flag */
@@ -1483,15 +1506,16 @@ static void s626_check_counter_interrupts(struct comedi_device *dev)
 		if (devpriv->ai_convert_count > 0) {
 			devpriv->ai_convert_count--;
 			if (devpriv->ai_convert_count == 0)
-				k->set_enable(dev, k, CLKENAB_INDEX);
+				k->set_enable(dev, k, S626_CLKENAB_INDEX);
 
 			if (cmd->convert_src == TRIG_TIMER) {
 				/* Trigger ADC scan loop start */
-				s626_mc_enable(dev, MC2_ADC_RPS, P_MC2);
+				s626_mc_enable(dev, S626_MC2_ADC_RPS,
+					       S626_P_MC2);
 			}
 		}
 	}
-	if (irqbit & IRQ_COINT3B) {
+	if (irqbit & S626_IRQ_COINT3B) {
 		k = &s626_enc_chan_info[5];
 
 		/* clear interrupt capture flag */
@@ -1499,13 +1523,13 @@ static void s626_check_counter_interrupts(struct comedi_device *dev)
 
 		if (cmd->scan_begin_src == TRIG_TIMER) {
 			/* Trigger ADC scan loop start */
-			s626_mc_enable(dev, MC2_ADC_RPS, P_MC2);
+			s626_mc_enable(dev, S626_MC2_ADC_RPS, S626_P_MC2);
 		}
 
 		if (cmd->convert_src == TRIG_TIMER) {
 			k = &s626_enc_chan_info[4];
 			devpriv->ai_convert_count = cmd->chanlist_len;
-			k->set_enable(dev, k, CLKENAB_ALWAYS);
+			k->set_enable(dev, k, S626_CLKENAB_ALWAYS);
 		}
 	}
 }
@@ -1550,7 +1574,7 @@ static bool s626_handle_eos_interrupt(struct comedi_device *dev)
 		devpriv->ai_cmd_running = 0;
 
 		/* Stop RPS program */
-		s626_mc_disable(dev, MC1_ERPS1, P_MC1);
+		s626_mc_disable(dev, S626_MC1_ERPS1, S626_P_MC1);
 
 		/* send end of acquisition */
 		async->events |= COMEDI_CB_EOA;
@@ -1581,23 +1605,23 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	spin_lock_irqsave(&dev->spinlock, flags);
 
 	/* save interrupt enable register state */
-	irqstatus = readl(devpriv->mmio + P_IER);
+	irqstatus = readl(devpriv->mmio + S626_P_IER);
 
 	/* read interrupt type */
-	irqtype = readl(devpriv->mmio + P_ISR);
+	irqtype = readl(devpriv->mmio + S626_P_ISR);
 
 	/* disable master interrupt */
-	writel(0, devpriv->mmio + P_IER);
+	writel(0, devpriv->mmio + S626_P_IER);
 
 	/* clear interrupt */
-	writel(irqtype, devpriv->mmio + P_ISR);
+	writel(irqtype, devpriv->mmio + S626_P_ISR);
 
 	switch (irqtype) {
-	case IRQ_RPS1:	/* end_of_scan occurs */
+	case S626_IRQ_RPS1:	/* end_of_scan occurs */
 		if (s626_handle_eos_interrupt(dev))
 			irqstatus = 0;
 		break;
-	case IRQ_GPIO3:	/* check dio and counter interrupt */
+	case S626_IRQ_GPIO3:	/* check dio and counter interrupt */
 		/* s626_dio_clear_irq(dev); */
 		s626_check_dio_interrupts(dev);
 		s626_check_counter_interrupts(dev);
@@ -1605,7 +1629,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	}
 
 	/* enable interrupt */
-	writel(irqstatus, devpriv->mmio + P_IER);
+	writel(irqstatus, devpriv->mmio + S626_P_IER);
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 	return IRQ_HANDLED;
@@ -1625,20 +1649,20 @@ static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
 	struct comedi_cmd *cmd = &dev->subdevices->async->cmd;
 
 	/* Stop RPS program in case it is currently running */
-	s626_mc_disable(dev, MC1_ERPS1, P_MC1);
+	s626_mc_disable(dev, S626_MC1_ERPS1, S626_P_MC1);
 
 	/* Set starting logical address to write RPS commands. */
 	rps = (uint32_t *)devpriv->rps_buf.logical_base;
 
 	/* Initialize RPS instruction pointer */
 	writel((uint32_t)devpriv->rps_buf.physical_base,
-	       devpriv->mmio + P_RPSADDR1);
+	       devpriv->mmio + S626_P_RPSADDR1);
 
 	/* Construct RPS program in rps_buf DMA buffer */
 	if (cmd != NULL && cmd->scan_begin_src != TRIG_FOLLOW) {
 		/* Wait for Start trigger. */
-		*rps++ = RPS_PAUSE | RPS_SIGADC;
-		*rps++ = RPS_CLRSIGNAL | RPS_SIGADC;
+		*rps++ = S626_RPS_PAUSE | S626_RPS_SIGADC;
+		*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_SIGADC;
 	}
 
 	/*
@@ -1650,20 +1674,22 @@ static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
 	 * the previously programmed value.
 	 */
 	/* Write DEBI Write command and address to shadow RAM. */
-	*rps++ = RPS_LDREG | (P_DEBICMD >> 2);
-	*rps++ = DEBI_CMD_WRWORD | LP_GSEL;
-	*rps++ = RPS_LDREG | (P_DEBIAD >> 2);
+	*rps++ = S626_RPS_LDREG | (S626_P_DEBICMD >> 2);
+	*rps++ = S626_DEBI_CMD_WRWORD | S626_LP_GSEL;
+	*rps++ = S626_RPS_LDREG | (S626_P_DEBIAD >> 2);
 	/* Write DEBI immediate data  to shadow RAM: */
-	*rps++ = GSEL_BIPOLAR5V;	/* arbitrary immediate data  value. */
-	*rps++ = RPS_CLRSIGNAL | RPS_DEBI;
+	*rps++ = S626_GSEL_BIPOLAR5V;	/* arbitrary immediate data  value. */
+	*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_DEBI;
 	/* Reset "shadow RAM  uploaded" flag. */
-	*rps++ = RPS_UPLOAD | RPS_DEBI;	/* Invoke shadow RAM upload. */
-	*rps++ = RPS_PAUSE | RPS_DEBI;	/* Wait for shadow upload to finish. */
+	/* Invoke shadow RAM upload. */
+	*rps++ = S626_RPS_UPLOAD | S626_RPS_DEBI;
+	/* Wait for shadow upload to finish. */
+	*rps++ = S626_RPS_PAUSE | S626_RPS_DEBI;
 
 	/*
 	 * Digitize all slots in the poll list. This is implemented as a
 	 * for loop to limit the slot count to 16 in case the application
-	 * forgot to set the EOPL flag in the final slot.
+	 * forgot to set the S626_EOPL flag in the final slot.
 	 */
 	for (devpriv->adc_items = 0; devpriv->adc_items < 16;
 	     devpriv->adc_items++) {
@@ -1673,77 +1699,80 @@ static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
 		 * (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
 		 * +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
 		 */
-		local_ppl = (*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
-					   GSEL_BIPOLAR10V);
+		local_ppl = (*ppl << 8) | (*ppl & 0x10 ? S626_GSEL_BIPOLAR5V :
+					   S626_GSEL_BIPOLAR10V);
 
 		/* Switch ADC analog gain. */
 		/* Write DEBI command and address to shadow RAM. */
-		*rps++ = RPS_LDREG | (P_DEBICMD >> 2);
-		*rps++ = DEBI_CMD_WRWORD | LP_GSEL;
+		*rps++ = S626_RPS_LDREG | (S626_P_DEBICMD >> 2);
+		*rps++ = S626_DEBI_CMD_WRWORD | S626_LP_GSEL;
 		/* Write DEBI immediate data to shadow RAM. */
-		*rps++ = RPS_LDREG | (P_DEBIAD >> 2);
+		*rps++ = S626_RPS_LDREG | (S626_P_DEBIAD >> 2);
 		*rps++ = local_ppl;
 		/* Reset "shadow RAM uploaded" flag. */
-		*rps++ = RPS_CLRSIGNAL | RPS_DEBI;
+		*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_DEBI;
 		/* Invoke shadow RAM upload. */
-		*rps++ = RPS_UPLOAD | RPS_DEBI;
+		*rps++ = S626_RPS_UPLOAD | S626_RPS_DEBI;
 		/* Wait for shadow upload to finish. */
-		*rps++ = RPS_PAUSE | RPS_DEBI;
+		*rps++ = S626_RPS_PAUSE | S626_RPS_DEBI;
 		/* Select ADC analog input channel. */
-		*rps++ = RPS_LDREG | (P_DEBICMD >> 2);
+		*rps++ = S626_RPS_LDREG | (S626_P_DEBICMD >> 2);
 		/* Write DEBI command and address to shadow RAM. */
-		*rps++ = DEBI_CMD_WRWORD | LP_ISEL;
-		*rps++ = RPS_LDREG | (P_DEBIAD >> 2);
+		*rps++ = S626_DEBI_CMD_WRWORD | S626_LP_ISEL;
+		*rps++ = S626_RPS_LDREG | (S626_P_DEBIAD >> 2);
 		/* Write DEBI immediate data to shadow RAM. */
 		*rps++ = local_ppl;
 		/* Reset "shadow RAM uploaded" flag. */
-		*rps++ = RPS_CLRSIGNAL | RPS_DEBI;
+		*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_DEBI;
 		/* Invoke shadow RAM upload. */
-		*rps++ = RPS_UPLOAD | RPS_DEBI;
+		*rps++ = S626_RPS_UPLOAD | S626_RPS_DEBI;
 		/* Wait for shadow upload to finish. */
-		*rps++ = RPS_PAUSE | RPS_DEBI;
+		*rps++ = S626_RPS_PAUSE | S626_RPS_DEBI;
 
 		/*
 		 * Delay at least 10 microseconds for analog input settling.
-		 * Instead of padding with NOPs, we use RPS_JUMP instructions
-		 * here; this allows us to produce a longer delay than is
-		 * possible with NOPs because each RPS_JUMP flushes the RPS'
-		 * instruction prefetch pipeline.
+		 * Instead of padding with NOPs, we use S626_RPS_JUMP
+		 * instructions here; this allows us to produce a longer delay
+		 * than is possible with NOPs because each S626_RPS_JUMP
+		 * flushes the RPS' instruction prefetch pipeline.
 		 */
 		jmp_adrs =
 			(uint32_t)devpriv->rps_buf.physical_base +
 			(uint32_t)((unsigned long)rps -
 				   (unsigned long)devpriv->
 						  rps_buf.logical_base);
-		for (i = 0; i < (10 * RPSCLK_PER_US / 2); i++) {
+		for (i = 0; i < (10 * S626_RPSCLK_PER_US / 2); i++) {
 			jmp_adrs += 8;	/* Repeat to implement time delay: */
-			*rps++ = RPS_JUMP; /* Jump to next RPS instruction. */
+			/* Jump to next RPS instruction. */
+			*rps++ = S626_RPS_JUMP;
 			*rps++ = jmp_adrs;
 		}
 
 		if (cmd != NULL && cmd->convert_src != TRIG_NOW) {
 			/* Wait for Start trigger. */
-			*rps++ = RPS_PAUSE | RPS_SIGADC;
-			*rps++ = RPS_CLRSIGNAL | RPS_SIGADC;
+			*rps++ = S626_RPS_PAUSE | S626_RPS_SIGADC;
+			*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_SIGADC;
 		}
 		/* Start ADC by pulsing GPIO1. */
 		/* Begin ADC Start pulse. */
-		*rps++ = RPS_LDREG | (P_GPIO >> 2);
-		*rps++ = GPIO_BASE | GPIO1_LO;
-		*rps++ = RPS_NOP;
+		*rps++ = S626_RPS_LDREG | (S626_P_GPIO >> 2);
+		*rps++ = S626_GPIO_BASE | S626_GPIO1_LO;
+		*rps++ = S626_RPS_NOP;
 		/* VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
 		/* End ADC Start pulse. */
-		*rps++ = RPS_LDREG | (P_GPIO >> 2);
-		*rps++ = GPIO_BASE | GPIO1_HI;
+		*rps++ = S626_RPS_LDREG | (S626_P_GPIO >> 2);
+		*rps++ = S626_GPIO_BASE | S626_GPIO1_HI;
 		/*
 		 * Wait for ADC to complete (GPIO2 is asserted high when ADC not
 		 * busy) and for data from previous conversion to shift into FB
 		 * BUFFER 1 register.
 		 */
-		*rps++ = RPS_PAUSE | RPS_GPIO2;	/* Wait for ADC done. */
+		/* Wait for ADC done. */
+		*rps++ = S626_RPS_PAUSE | S626_RPS_GPIO2;
 
 		/* Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
-		*rps++ = RPS_STREG | (S626_BUGFIX_STREG(P_FB_BUFFER1) >> 2);
+		*rps++ = S626_RPS_STREG |
+			 (S626_BUGFIX_STREG(S626_P_FB_BUFFER1) >> 2);
 		*rps++ = (uint32_t)devpriv->ana_buf.physical_base +
 			 (devpriv->adc_items << 2);
 
@@ -1751,7 +1780,7 @@ static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
 		 * If this slot's EndOfPollList flag is set, all channels have
 		 * now been processed.
 		 */
-		if (*ppl++ & EOPL) {
+		if (*ppl++ & S626_EOPL) {
 			devpriv->adc_items++; /* Adjust poll list item count. */
 			break;	/* Exit poll list processing loop. */
 		}
@@ -1765,41 +1794,42 @@ static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
 	 * conversion.  Without this delay, the last conversion's data value
 	 * is sometimes set to the previous conversion's data value.
 	 */
-	for (n = 0; n < (2 * RPSCLK_PER_US); n++)
-		*rps++ = RPS_NOP;
+	for (n = 0; n < (2 * S626_RPSCLK_PER_US); n++)
+		*rps++ = S626_RPS_NOP;
 
 	/*
 	 * Start a dummy conversion to cause the data from the last
 	 * conversion of interest to be shifted in.
 	 */
-	*rps++ = RPS_LDREG | (P_GPIO >> 2);	/* Begin ADC Start pulse. */
-	*rps++ = GPIO_BASE | GPIO1_LO;
-	*rps++ = RPS_NOP;
+	/* Begin ADC Start pulse. */
+	*rps++ = S626_RPS_LDREG | (S626_P_GPIO >> 2);
+	*rps++ = S626_GPIO_BASE | S626_GPIO1_LO;
+	*rps++ = S626_RPS_NOP;
 	/* VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
-	*rps++ = RPS_LDREG | (P_GPIO >> 2);	/* End ADC Start pulse. */
-	*rps++ = GPIO_BASE | GPIO1_HI;
+	*rps++ = S626_RPS_LDREG | (S626_P_GPIO >> 2); /* End ADC Start pulse. */
+	*rps++ = S626_GPIO_BASE | S626_GPIO1_HI;
 
 	/*
 	 * Wait for the data from the last conversion of interest to arrive
 	 * in FB BUFFER 1 register.
 	 */
-	*rps++ = RPS_PAUSE | RPS_GPIO2;	/* Wait for ADC done. */
+	*rps++ = S626_RPS_PAUSE | S626_RPS_GPIO2;	/* Wait for ADC done. */
 
 	/* Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
-	*rps++ = RPS_STREG | (S626_BUGFIX_STREG(P_FB_BUFFER1) >> 2);
+	*rps++ = S626_RPS_STREG | (S626_BUGFIX_STREG(S626_P_FB_BUFFER1) >> 2);
 	*rps++ = (uint32_t)devpriv->ana_buf.physical_base +
 		 (devpriv->adc_items << 2);
 
 	/* Indicate ADC scan loop is finished. */
 	/* Signal ReadADC() that scan is done. */
-	/* *rps++= RPS_CLRSIGNAL | RPS_SIGADC; */
+	/* *rps++= S626_RPS_CLRSIGNAL | S626_RPS_SIGADC; */
 
 	/* invoke interrupt */
 	if (devpriv->ai_cmd_running == 1)
-		*rps++ = RPS_IRQ;
+		*rps++ = S626_RPS_IRQ;
 
 	/* Restart RPS program at its beginning. */
-	*rps++ = RPS_JUMP;	/* Branch to start of RPS program. */
+	*rps++ = S626_RPS_JUMP;	/* Branch to start of RPS program. */
 	*rps++ = (uint32_t)devpriv->rps_buf.physical_base;
 
 	/* End of RPS program build */
@@ -1816,10 +1846,10 @@ static int s626_ai_rinsn(struct comedi_device *dev,
 	int32_t *readaddr;
 
 	/* Trigger ADC scan loop start */
-	s626_mc_enable(dev, MC2_ADC_RPS, P_MC2);
+	s626_mc_enable(dev, S626_MC2_ADC_RPS, S626_P_MC2);
 
 	/* Wait until ADC scan loop is finished (RPS Signal 0 reset) */
-	while (s626_mc_test(dev, MC2_ADC_RPS, P_MC2))
+	while (s626_mc_test(dev, S626_MC2_ADC_RPS, S626_P_MC2))
 		;
 
 	/*
@@ -1859,29 +1889,32 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	 *  appropriate for register programming.
 	 */
 	if (range == 0)
-		adc_spec = (chan << 8) | (GSEL_BIPOLAR5V);
+		adc_spec = (chan << 8) | (S626_GSEL_BIPOLAR5V);
 	else
-		adc_spec = (chan << 8) | (GSEL_BIPOLAR10V);
+		adc_spec = (chan << 8) | (S626_GSEL_BIPOLAR10V);
 
 	/* Switch ADC analog gain. */
-	s626_debi_write(dev, LP_GSEL, adc_spec);	/* Set gain. */
+	s626_debi_write(dev, S626_LP_GSEL, adc_spec);	/* Set gain. */
 
 	/* Select ADC analog input channel. */
-	s626_debi_write(dev, LP_ISEL, adc_spec);	/* Select channel. */
+	s626_debi_write(dev, S626_LP_ISEL, adc_spec);	/* Select channel. */
 
 	for (n = 0; n < insn->n; n++) {
 		/* Delay 10 microseconds for analog input settling. */
 		udelay(10);
 
 		/* Start ADC by pulsing GPIO1 low */
-		gpio_image = readl(devpriv->mmio + P_GPIO);
+		gpio_image = readl(devpriv->mmio + S626_P_GPIO);
 		/* Assert ADC Start command */
-		writel(gpio_image & ~GPIO1_HI, devpriv->mmio + P_GPIO);
+		writel(gpio_image & ~S626_GPIO1_HI,
+		       devpriv->mmio + S626_P_GPIO);
 		/* and stretch it out */
-		writel(gpio_image & ~GPIO1_HI, devpriv->mmio + P_GPIO);
-		writel(gpio_image & ~GPIO1_HI, devpriv->mmio + P_GPIO);
+		writel(gpio_image & ~S626_GPIO1_HI,
+		       devpriv->mmio + S626_P_GPIO);
+		writel(gpio_image & ~S626_GPIO1_HI,
+		       devpriv->mmio + S626_P_GPIO);
 		/* Negate ADC Start command */
-		writel(gpio_image | GPIO1_HI, devpriv->mmio + P_GPIO);
+		writel(gpio_image | S626_GPIO1_HI, devpriv->mmio + S626_P_GPIO);
 
 		/*
 		 * Wait for ADC to complete (GPIO2 is asserted high when
@@ -1890,12 +1923,12 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 		 */
 
 		/* Wait for ADC done */
-		while (!(readl(devpriv->mmio + P_PSR) & PSR_GPIO2))
+		while (!(readl(devpriv->mmio + S626_P_PSR) & S626_PSR_GPIO2))
 			;
 
 		/* Fetch ADC data */
 		if (n != 0) {
-			tmp = readl(devpriv->mmio + P_FB_BUFFER1);
+			tmp = readl(devpriv->mmio + S626_P_FB_BUFFER1);
 			data[n - 1] = s626_ai_reg_to_uint(tmp);
 		}
 
@@ -1915,26 +1948,26 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	 * Start a dummy conversion to cause the data from the
 	 * previous conversion to be shifted in.
 	 */
-	gpio_image = readl(devpriv->mmio + P_GPIO);
+	gpio_image = readl(devpriv->mmio + S626_P_GPIO);
 	/* Assert ADC Start command */
-	writel(gpio_image & ~GPIO1_HI, devpriv->mmio + P_GPIO);
+	writel(gpio_image & ~S626_GPIO1_HI, devpriv->mmio + S626_P_GPIO);
 	/* and stretch it out */
-	writel(gpio_image & ~GPIO1_HI, devpriv->mmio + P_GPIO);
-	writel(gpio_image & ~GPIO1_HI, devpriv->mmio + P_GPIO);
+	writel(gpio_image & ~S626_GPIO1_HI, devpriv->mmio + S626_P_GPIO);
+	writel(gpio_image & ~S626_GPIO1_HI, devpriv->mmio + S626_P_GPIO);
 	/* Negate ADC Start command */
-	writel(gpio_image | GPIO1_HI, devpriv->mmio + P_GPIO);
+	writel(gpio_image | S626_GPIO1_HI, devpriv->mmio + S626_P_GPIO);
 
 	/* Wait for the data to arrive in FB BUFFER 1 register. */
 
 	/* Wait for ADC done */
-	while (!(readl(devpriv->mmio + P_PSR) & PSR_GPIO2))
+	while (!(readl(devpriv->mmio + S626_P_PSR) & S626_PSR_GPIO2))
 		;
 
 	/* Fetch ADC data from audio interface's input shift register. */
 
 	/* Fetch ADC data */
 	if (n != 0) {
-		tmp = readl(devpriv->mmio + P_FB_BUFFER1);
+		tmp = readl(devpriv->mmio + S626_P_FB_BUFFER1);
 		data[n - 1] = s626_ai_reg_to_uint(tmp);
 	}
 
@@ -1947,12 +1980,12 @@ static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)
 
 	for (n = 0; n < cmd->chanlist_len; n++) {
 		if (CR_RANGE(cmd->chanlist[n]) == 0)
-			ppl[n] = CR_CHAN(cmd->chanlist[n]) | RANGE_5V;
+			ppl[n] = CR_CHAN(cmd->chanlist[n]) | S626_RANGE_5V;
 		else
-			ppl[n] = CR_CHAN(cmd->chanlist[n]) | RANGE_10V;
+			ppl[n] = CR_CHAN(cmd->chanlist[n]) | S626_RANGE_10V;
 	}
 	if (n != 0)
-		ppl[n - 1] |= EOPL;
+		ppl[n - 1] |= S626_EOPL;
 
 	return n;
 }
@@ -1964,7 +1997,7 @@ static int s626_ai_inttrig(struct comedi_device *dev,
 		return -EINVAL;
 
 	/* Start executing the RPS program */
-	s626_mc_enable(dev, MC1_ERPS1, P_MC1);
+	s626_mc_enable(dev, S626_MC1_ERPS1, S626_P_MC1);
 
 	s->async->inttrig = NULL;
 
@@ -2005,15 +2038,21 @@ static void s626_timer_load(struct comedi_device *dev,
 			    const struct s626_enc_info *k, int tick)
 {
 	uint16_t setup =
-		(LOADSRC_INDX << BF_LOADSRC) |	/* Preload upon index. */
-		(INDXSRC_SOFT << BF_INDXSRC) |	/* Disable hardware index. */
-		(CLKSRC_TIMER << BF_CLKSRC) |	/* Operating mode is Timer. */
-		(CLKPOL_POS << BF_CLKPOL) |	/* Active high clock. */
-		(CNTDIR_DOWN << BF_CLKPOL) |	/* Count direction is Down. */
-		(CLKMULT_1X << BF_CLKMULT) |	/* Clock multiplier is 1x. */
-		(CLKENAB_INDEX << BF_CLKENAB);
-	uint16_t value_latchsrc = LATCHSRC_A_INDXA;
-	/* uint16_t enab = CLKENAB_ALWAYS; */
+		/* Preload upon index. */
+		(S626_LOADSRC_INDX << S626_BF_LOADSRC) |
+		/* Disable hardware index. */
+		(S626_INDXSRC_SOFT << S626_BF_INDXSRC) |
+		/* Operating mode is Timer. */
+		(S626_CLKSRC_TIMER << S626_BF_CLKSRC) |
+		/* Active high clock. */
+		(S626_CLKPOL_POS << S626_BF_CLKPOL) |
+		/* Count direction is Down. */
+		(S626_CNTDIR_DOWN << S626_BF_CLKPOL) |
+		/* Clock multiplier is 1x. */
+		(S626_CLKMULT_1X << S626_BF_CLKMULT) |
+		(S626_CLKENAB_INDEX << S626_BF_CLKENAB);
+	uint16_t value_latchsrc = S626_LATCHSRC_A_INDXA;
+	/* uint16_t enab = S626_CLKENAB_ALWAYS; */
 
 	k->set_mode(dev, k, setup, false);
 
@@ -2031,7 +2070,7 @@ static void s626_timer_load(struct comedi_device *dev,
 	k->set_load_trig(dev, k, 1);
 
 	/* set interrupt on overflow */
-	k->set_int_src(dev, k, INTSRC_OVER);
+	k->set_int_src(dev, k, S626_INTSRC_OVER);
 
 	s626_set_latch_source(dev, k, value_latchsrc);
 	/* k->set_enable(dev, k, (uint16_t)(enab != 0)); */
@@ -2052,10 +2091,10 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EBUSY;
 	}
 	/* disable interrupt */
-	writel(0, devpriv->mmio + P_IER);
+	writel(0, devpriv->mmio + S626_P_IER);
 
 	/* clear interrupt request */
-	writel(IRQ_RPS1 | IRQ_GPIO3, devpriv->mmio + P_ISR);
+	writel(S626_IRQ_RPS1 | S626_IRQ_GPIO3, devpriv->mmio + S626_P_ISR);
 
 	/* clear any pending interrupt */
 	s626_dio_clear_irq(dev);
@@ -2092,7 +2131,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
-		k->set_enable(dev, k, CLKENAB_ALWAYS);
+		k->set_enable(dev, k, S626_CLKENAB_ALWAYS);
 		break;
 	case TRIG_EXT:
 		/* set the digital line and interrupt for scan trigger */
@@ -2115,7 +2154,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
-		k->set_enable(dev, k, CLKENAB_INDEX);
+		k->set_enable(dev, k, S626_CLKENAB_INDEX);
 		break;
 	case TRIG_EXT:
 		/* set the digital line and interrupt for convert trigger */
@@ -2143,10 +2182,10 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	switch (cmd->start_src) {
 	case TRIG_NOW:
 		/* Trigger ADC scan loop start */
-		/* s626_mc_enable(dev, MC2_ADC_RPS, P_MC2); */
+		/* s626_mc_enable(dev, S626_MC2_ADC_RPS, S626_P_MC2); */
 
 		/* Start executing the RPS program */
-		s626_mc_enable(dev, MC1_ERPS1, P_MC1);
+		s626_mc_enable(dev, S626_MC1_ERPS1, S626_P_MC1);
 		s->async->inttrig = NULL;
 		break;
 	case TRIG_EXT:
@@ -2160,7 +2199,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* enable interrupt */
-	writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->mmio + P_IER);
+	writel(S626_IRQ_GPIO3 | S626_IRQ_RPS1, devpriv->mmio + S626_P_IER);
 
 	return 0;
 }
@@ -2278,10 +2317,10 @@ static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct s626_private *devpriv = dev->private;
 
 	/* Stop RPS program in case it is currently running */
-	s626_mc_disable(dev, MC1_ERPS1, P_MC1);
+	s626_mc_disable(dev, S626_MC1_ERPS1, S626_P_MC1);
 
 	/* disable master interrupt */
-	writel(0, devpriv->mmio + P_IER);
+	writel(0, devpriv->mmio + S626_P_IER);
 
 	devpriv->ai_cmd_running = 0;
 
@@ -2332,18 +2371,18 @@ static void s626_dio_init(struct comedi_device *dev)
 	uint16_t group;
 
 	/* Prepare to treat writes to WRCapSel as capture disables. */
-	s626_debi_write(dev, LP_MISC1, MISC1_NOEDCAP);
+	s626_debi_write(dev, S626_LP_MISC1, S626_MISC1_NOEDCAP);
 
 	/* For each group of sixteen channels ... */
 	for (group = 0; group < S626_DIO_BANKS; group++) {
 		/* Disable all interrupts */
-		s626_debi_write(dev, LP_WRINTSEL(group), 0);
+		s626_debi_write(dev, S626_LP_WRINTSEL(group), 0);
 		/* Disable all event captures */
-		s626_debi_write(dev, LP_WRCAPSEL(group), 0xffff);
+		s626_debi_write(dev, S626_LP_WRCAPSEL(group), 0xffff);
 		/* Init all DIOs to default edge polarity */
-		s626_debi_write(dev, LP_WREDGSEL(group), 0);
+		s626_debi_write(dev, S626_LP_WREDGSEL(group), 0);
 		/* Program all outputs to inactive state */
-		s626_debi_write(dev, LP_WRDOUT(group), 0);
+		s626_debi_write(dev, S626_LP_WRDOUT(group), 0);
 	}
 }
 
@@ -2355,9 +2394,9 @@ static int s626_dio_insn_bits(struct comedi_device *dev,
 	unsigned long group = (unsigned long)s->private;
 
 	if (comedi_dio_update_state(s, data))
-		s626_debi_write(dev, LP_WRDOUT(group), s->state);
+		s626_debi_write(dev, S626_LP_WRDOUT(group), s->state);
 
-	data[1] = s626_debi_read(dev, LP_RDDIN(group));
+	data[1] = s626_debi_read(dev, S626_LP_RDDIN(group));
 
 	return insn->n;
 }
@@ -2374,7 +2413,7 @@ static int s626_dio_insn_config(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	s626_debi_write(dev, LP_WRDOUT(group), s->io_bits);
+	s626_debi_write(dev, S626_LP_WRDOUT(group), s->io_bits);
 
 	return insn->n;
 }
@@ -2393,16 +2432,21 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 				struct comedi_insn *insn, unsigned int *data)
 {
 	uint16_t setup =
-		(LOADSRC_INDX << BF_LOADSRC) |	/* Preload upon index. */
-		(INDXSRC_SOFT << BF_INDXSRC) |	/* Disable hardware index. */
-		(CLKSRC_COUNTER << BF_CLKSRC) |	/* Operating mode is Counter. */
-		(CLKPOL_POS << BF_CLKPOL) |	/* Active high clock. */
-		(CLKMULT_1X << BF_CLKMULT) |	/* Clock multiplier is 1x. */
-		(CLKENAB_INDEX << BF_CLKENAB);
+		/* Preload upon index. */
+		(S626_LOADSRC_INDX << S626_BF_LOADSRC) |
+		/* Disable hardware index. */
+		(S626_INDXSRC_SOFT << S626_BF_INDXSRC) |
+		/* Operating mode is Counter. */
+		(S626_CLKSRC_COUNTER << S626_BF_CLKSRC) |
+		/* Active high clock. */
+		(S626_CLKPOL_POS << S626_BF_CLKPOL) |
+		/* Clock multiplier is 1x. */
+		(S626_CLKMULT_1X << S626_BF_CLKMULT) |
+		(S626_CLKENAB_INDEX << S626_BF_CLKENAB);
 	/* uint16_t disable_int_src = true; */
 	/* uint32_t Preloadvalue;              //Counter initial value */
-	uint16_t value_latchsrc = LATCHSRC_AB_READ;
-	uint16_t enab = CLKENAB_ALWAYS;
+	uint16_t value_latchsrc = S626_LATCHSRC_AB_READ;
+	uint16_t enab = S626_CLKENAB_ALWAYS;
 	const struct s626_enc_info *k =
 		&s626_enc_chan_info[CR_CHAN(insn->chanspec)];
 
@@ -2454,9 +2498,9 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 
 static void s626_write_misc2(struct comedi_device *dev, uint16_t new_image)
 {
-	s626_debi_write(dev, LP_MISC1, MISC1_WENABLE);
-	s626_debi_write(dev, LP_WRMISC2, new_image);
-	s626_debi_write(dev, LP_MISC1, MISC1_WDISABLE);
+	s626_debi_write(dev, S626_LP_MISC1, S626_MISC1_WENABLE);
+	s626_debi_write(dev, S626_LP_WRMISC2, new_image);
+	s626_debi_write(dev, S626_LP_MISC1, S626_MISC1_WDISABLE);
 }
 
 static void s626_close_dma_b(struct comedi_device *dev,
@@ -2484,13 +2528,20 @@ static void s626_counters_init(struct comedi_device *dev)
 	int chan;
 	const struct s626_enc_info *k;
 	uint16_t setup =
-		(LOADSRC_INDX << BF_LOADSRC) |	/* Preload upon index. */
-		(INDXSRC_SOFT << BF_INDXSRC) |	/* Disable hardware index. */
-		(CLKSRC_COUNTER << BF_CLKSRC) |	/* Operating mode is counter. */
-		(CLKPOL_POS << BF_CLKPOL) |	/* Active high clock. */
-		(CNTDIR_UP << BF_CLKPOL) |	/* Count direction is up. */
-		(CLKMULT_1X << BF_CLKMULT) |	/* Clock multiplier is 1x. */
-		(CLKENAB_INDEX << BF_CLKENAB);	/* Enabled by index */
+		/* Preload upon index. */
+		(S626_LOADSRC_INDX << S626_BF_LOADSRC) |
+		/* Disable hardware index. */
+		(S626_INDXSRC_SOFT << S626_BF_INDXSRC) |
+		/* Operating mode is counter. */
+		(S626_CLKSRC_COUNTER << S626_BF_CLKSRC) |
+		/* Active high clock. */
+		(S626_CLKPOL_POS << S626_BF_CLKPOL) |
+		/* Count direction is up. */
+		(S626_CNTDIR_UP << S626_BF_CLKPOL) |
+		/* Clock multiplier is 1x. */
+		(S626_CLKMULT_1X << S626_BF_CLKMULT) |
+		/* Enabled by index */
+		(S626_CLKENAB_INDEX << S626_BF_CLKENAB);
 
 	/*
 	 * Disable all counter interrupts and clear any captured counter events.
@@ -2500,7 +2551,7 @@ static void s626_counters_init(struct comedi_device *dev)
 		k->set_mode(dev, k, setup, true);
 		k->set_int_src(dev, k, 0);
 		k->reset_cap_flags(dev, k);
-		k->set_enable(dev, k, CLKENAB_ALWAYS);
+		k->set_enable(dev, k, S626_CLKENAB_ALWAYS);
 	}
 }
 
@@ -2511,13 +2562,13 @@ static int s626_allocate_dma_buffers(struct comedi_device *dev)
 	void *addr;
 	dma_addr_t appdma;
 
-	addr = pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
+	addr = pci_alloc_consistent(pcidev, S626_DMABUF_SIZE, &appdma);
 	if (!addr)
 		return -ENOMEM;
 	devpriv->ana_buf.logical_base = addr;
 	devpriv->ana_buf.physical_base = appdma;
 
-	addr = pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
+	addr = pci_alloc_consistent(pcidev, S626_DMABUF_SIZE, &appdma);
 	if (!addr)
 		return -ENOMEM;
 	devpriv->rps_buf.logical_base = addr;
@@ -2534,7 +2585,8 @@ static void s626_initialize(struct comedi_device *dev)
 	int i;
 
 	/* Enable DEBI and audio pins, enable I2C interface */
-	s626_mc_enable(dev, MC1_DEBI | MC1_AUDIO | MC1_I2C, P_MC1);
+	s626_mc_enable(dev, S626_MC1_DEBI | S626_MC1_AUDIO | S626_MC1_I2C,
+		       S626_P_MC1);
 
 	/*
 	 * Configure DEBI operating mode
@@ -2544,14 +2596,15 @@ static void s626_initialize(struct comedi_device *dev)
 	 *  Set up byte lane steering
 	 *  Intel-compatible local bus (DEBI never times out)
 	 */
-	writel(DEBI_CFG_SLAVE16 | (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
-	       DEBI_SWAP | DEBI_CFG_INTEL, devpriv->mmio + P_DEBICFG);
+	writel(S626_DEBI_CFG_SLAVE16 |
+	       (S626_DEBI_TOUT << S626_DEBI_CFG_TOUT_BIT) | S626_DEBI_SWAP |
+	       S626_DEBI_CFG_INTEL, devpriv->mmio + S626_P_DEBICFG);
 
 	/* Disable MMU paging */
-	writel(DEBI_PAGE_DISABLE, devpriv->mmio + P_DEBIPAGE);
+	writel(S626_DEBI_PAGE_DISABLE, devpriv->mmio + S626_P_DEBIPAGE);
 
 	/* Init GPIO so that ADC Start* is negated */
-	writel(GPIO_BASE | GPIO1_HI, devpriv->mmio + P_GPIO);
+	writel(S626_GPIO_BASE | S626_GPIO1_HI, devpriv->mmio + S626_P_GPIO);
 
 	/* I2C device address for onboard eeprom (revb) */
 	devpriv->i2c_adrs = 0xA0;
@@ -2560,9 +2613,10 @@ static void s626_initialize(struct comedi_device *dev)
 	 * Issue an I2C ABORT command to halt any I2C
 	 * operation in progress and reset BUSY flag.
 	 */
-	writel(I2C_CLKSEL | I2C_ABORT, devpriv->mmio + P_I2CSTAT);
-	s626_mc_enable(dev, MC2_UPLD_IIC, P_MC2);
-	while (!(readl(devpriv->mmio + P_MC2) & MC2_UPLD_IIC))
+	writel(S626_I2C_CLKSEL | S626_I2C_ABORT,
+	       devpriv->mmio + S626_P_I2CSTAT);
+	s626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);
+	while (!(readl(devpriv->mmio + S626_P_MC2) & S626_MC2_UPLD_IIC))
 		;
 
 	/*
@@ -2570,9 +2624,9 @@ static void s626_initialize(struct comedi_device *dev)
 	 * reg twice to reset all  I2C error flags.
 	 */
 	for (i = 0; i < 2; i++) {
-		writel(I2C_CLKSEL, devpriv->mmio + P_I2CSTAT);
-		s626_mc_enable(dev, MC2_UPLD_IIC, P_MC2);
-		while (!s626_mc_test(dev, MC2_UPLD_IIC, P_MC2))
+		writel(S626_I2C_CLKSEL, devpriv->mmio + S626_P_I2CSTAT);
+		s626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);
+		while (!s626_mc_test(dev, S626_MC2_UPLD_IIC, S626_P_MC2))
 			;
 	}
 
@@ -2582,19 +2636,20 @@ static void s626_initialize(struct comedi_device *dev)
 	 * DAC data setup times are satisfied, enable DAC serial
 	 * clock out.
 	 */
-	writel(ACON2_INIT, devpriv->mmio + P_ACON2);
+	writel(S626_ACON2_INIT, devpriv->mmio + S626_P_ACON2);
 
 	/*
 	 * Set up TSL1 slot list, which is used to control the
-	 * accumulation of ADC data: RSD1 = shift data in on SD1.
-	 * SIB_A1  = store data uint8_t at next available location
+	 * accumulation of ADC data: S626_RSD1 = shift data in on SD1.
+	 * S626_SIB_A1  = store data uint8_t at next available location
 	 * in FB BUFFER1 register.
 	 */
-	writel(RSD1 | SIB_A1, devpriv->mmio + P_TSL1);
-	writel(RSD1 | SIB_A1 | EOS, devpriv->mmio + P_TSL1 + 4);
+	writel(S626_RSD1 | S626_SIB_A1, devpriv->mmio + S626_P_TSL1);
+	writel(S626_RSD1 | S626_SIB_A1 | S626_EOS,
+	       devpriv->mmio + S626_P_TSL1 + 4);
 
 	/* Enable TSL1 slot list so that it executes all the time */
-	writel(ACON1_ADCSTART, devpriv->mmio + P_ACON1);
+	writel(S626_ACON1_ADCSTART, devpriv->mmio + S626_P_ACON1);
 
 	/*
 	 * Initialize RPS registers used for ADC
@@ -2602,11 +2657,11 @@ static void s626_initialize(struct comedi_device *dev)
 
 	/* Physical start of RPS program */
 	writel((uint32_t)devpriv->rps_buf.physical_base,
-	       devpriv->mmio + P_RPSADDR1);
+	       devpriv->mmio + S626_P_RPSADDR1);
 	/* RPS program performs no explicit mem writes */
-	writel(0, devpriv->mmio + P_RPSPAGE1);
+	writel(0, devpriv->mmio + S626_P_RPSPAGE1);
 	/* Disable RPS timeouts */
-	writel(0, devpriv->mmio + P_RPS1_TOUT);
+	writel(0, devpriv->mmio + S626_P_RPS1_TOUT);
 
 #if 0
 	/*
@@ -2626,7 +2681,7 @@ static void s626_initialize(struct comedi_device *dev)
 		unsigned int data[16];
 
 		/* Create a simple polling list for analog input channel 0 */
-		poll_list = EOPL;
+		poll_list = S626_EOPL;
 		s626_reset_adc(dev, &poll_list);
 
 		/* Get initial ADC value */
@@ -2661,7 +2716,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 *   burst length = 1 DWORD
 	 *   threshold = 1 DWORD.
 	 */
-	writel(0, devpriv->mmio + P_PCI_BT_A);
+	writel(0, devpriv->mmio + S626_P_PCI_BT_A);
 
 	/*
 	 * Init Audio2's output DMA physical addresses.  The protection
@@ -2670,17 +2725,17 @@ static void s626_initialize(struct comedi_device *dev)
 	 * enabled.
 	 */
 	phys_buf = devpriv->ana_buf.physical_base +
-		   (DAC_WDMABUF_OS * sizeof(uint32_t));
-	writel((uint32_t)phys_buf, devpriv->mmio + P_BASEA2_OUT);
+		   (S626_DAC_WDMABUF_OS * sizeof(uint32_t));
+	writel((uint32_t)phys_buf, devpriv->mmio + S626_P_BASEA2_OUT);
 	writel((uint32_t)(phys_buf + sizeof(uint32_t)),
-	       devpriv->mmio + P_PROTA2_OUT);
+	       devpriv->mmio + S626_P_PROTA2_OUT);
 
 	/*
 	 * Cache Audio2's output DMA buffer logical address.  This is
 	 * where DAC data is buffered for A2 output DMA transfers.
 	 */
 	devpriv->dac_wbuf = (uint32_t *)devpriv->ana_buf.logical_base +
-			    DAC_WDMABUF_OS;
+			    S626_DAC_WDMABUF_OS;
 
 	/*
 	 * Audio2's output channels does not use paging.  The
@@ -2688,7 +2743,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * DMAC will automatically halt and its PCI address pointer
 	 * will be reset when the protection address is reached.
 	 */
-	writel(8, devpriv->mmio + P_PAGEA2_OUT);
+	writel(8, devpriv->mmio + S626_P_PAGEA2_OUT);
 
 	/*
 	 * Initialize time slot list 2 (TSL2), which is used to control
@@ -2703,7 +2758,8 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 
 	/* Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2 */
-	writel(XSD2 | RSD3 | SIB_A2 | EOS, devpriv->mmio + S626_VECTPORT(0));
+	writel(S626_XSD2 | S626_RSD3 | S626_SIB_A2 | S626_EOS,
+	       devpriv->mmio + S626_VECTPORT(0));
 
 	/*
 	 * Initialize slot 1, which is constant.  Slot 1 causes a
@@ -2715,10 +2771,10 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 
 	/* Slot 1: Fetch DWORD from Audio2's output FIFO */
-	writel(LF_A2, devpriv->mmio + S626_VECTPORT(1));
+	writel(S626_LF_A2, devpriv->mmio + S626_VECTPORT(1));
 
 	/* Start DAC's audio interface (TSL2) running */
-	writel(ACON1_DACSTART, devpriv->mmio + P_ACON1);
+	writel(S626_ACON1_DACSTART, devpriv->mmio + S626_P_ACON1);
 
 	/*
 	 * Init Trim DACs to calibrated values.  Do it twice because the
@@ -2752,8 +2808,8 @@ static void s626_initialize(struct comedi_device *dev)
 	 * standard DIO (vs. counter overflow) mode, disable the battery
 	 * charger, and reset the watchdog interval selector to zero.
 	 */
-	s626_write_misc2(dev, (s626_debi_read(dev, LP_RDMISC2) &
-			       MISC2_BATT_ENABLE));
+	s626_write_misc2(dev, (s626_debi_read(dev, S626_LP_RDMISC2) &
+			       S626_MISC2_BATT_ENABLE));
 
 	/* Initialize the digital I/O subsystem */
 	s626_dio_init(dev);
@@ -2780,10 +2836,10 @@ static int s626_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 
 	/* disable master interrupt */
-	writel(0, devpriv->mmio + P_IER);
+	writel(0, devpriv->mmio + S626_P_IER);
 
 	/* soft reset */
-	writel(MC1_SOFT_RESET, devpriv->mmio + P_MC1);
+	writel(S626_MC1_SOFT_RESET, devpriv->mmio + S626_P_MC1);
 
 	/* DMA FIXME DMA// */
 
@@ -2894,20 +2950,22 @@ static void s626_detach(struct comedi_device *dev)
 		if (devpriv->mmio) {
 			/* interrupt mask */
 			/* Disable master interrupt */
-			writel(0, devpriv->mmio + P_IER);
+			writel(0, devpriv->mmio + S626_P_IER);
 			/* Clear board's IRQ status flag */
-			writel(IRQ_GPIO3 | IRQ_RPS1,
-			       devpriv->mmio + P_ISR);
+			writel(S626_IRQ_GPIO3 | S626_IRQ_RPS1,
+			       devpriv->mmio + S626_P_ISR);
 
 			/* Disable the watchdog timer and battery charger. */
 			s626_write_misc2(dev, 0);
 
 			/* Close all interfaces on 7146 device */
-			writel(MC1_SHUTDOWN, devpriv->mmio + P_MC1);
-			writel(ACON1_BASE, devpriv->mmio + P_ACON1);
+			writel(S626_MC1_SHUTDOWN, devpriv->mmio + S626_P_MC1);
+			writel(S626_ACON1_BASE, devpriv->mmio + S626_P_ACON1);
 
-			s626_close_dma_b(dev, &devpriv->rps_buf, DMABUF_SIZE);
-			s626_close_dma_b(dev, &devpriv->ana_buf, DMABUF_SIZE);
+			s626_close_dma_b(dev, &devpriv->rps_buf,
+					 S626_DMABUF_SIZE);
+			s626_close_dma_b(dev, &devpriv->ana_buf,
+					 S626_DMABUF_SIZE);
 		}
 
 		if (dev->irq)

commit 676921c9d2ea2bdfeb13a2ca18724e1005242874
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:41 2013 +0100

    staging: comedi: s626: prefix macros in s626.c
    
    Prefix the macros defined in "s626.c" with `S626_`.  Macro `VECT0` is
    unused, so remove it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 38f129aa09d2..e8d615f83dee 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -145,15 +145,16 @@ struct s626_enc_info {
 };
 
 /* Counter overflow/index event flag masks for RDMISC2. */
-#define INDXMASK(C)	(1 << (((C) > 2) ? ((C) * 2 - 1) : ((C) * 2 +  4)))
-#define OVERMASK(C)	(1 << (((C) > 2) ? ((C) * 2 + 5) : ((C) * 2 + 10)))
-#define EVBITS(C)	{ 0, OVERMASK(C), INDXMASK(C), \
-			  OVERMASK(C) | INDXMASK(C) }
+#define S626_INDXMASK(C) (1 << (((C) > 2) ? ((C) * 2 - 1) : ((C) * 2 +  4)))
+#define S626_OVERMASK(C) (1 << (((C) > 2) ? ((C) * 2 + 5) : ((C) * 2 + 10)))
+#define S626_EVBITS(C)	{ 0, S626_OVERMASK(C), S626_INDXMASK(C), \
+			  S626_OVERMASK(C) | S626_INDXMASK(C) }
 
 /*
  * Translation table to map IntSrc into equivalent RDMISC2 event flag  bits.
  * static const uint16_t s626_event_bits[][4] =
- *     { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) };
+ *     { S626_EVBITS(0), S626_EVBITS(1), S626_EVBITS(2), S626_EVBITS(3),
+ *       S626_EVBITS(4), S626_EVBITS(5) };
  */
 
 /*
@@ -190,10 +191,10 @@ static bool s626_mc_test(struct comedi_device *dev,
 	return (val & cmd) ? true : false;
 }
 
-#define BUGFIX_STREG(REGADRS)   (REGADRS - 4)
+#define S626_BUGFIX_STREG(REGADRS)   ((REGADRS) - 4)
 
 /* Write a time slot control record to TSL2. */
-#define VECTPORT(VECTNUM)		(P_TSL2 + ((VECTNUM) << 2))
+#define S626_VECTPORT(VECTNUM)		(P_TSL2 + ((VECTNUM) << 2))
 
 static const struct comedi_lrange s626_range_table = {
 	2, {
@@ -341,10 +342,6 @@ static uint8_t s626_i2c_read(struct comedi_device *dev, uint8_t addr)
 
 /* ***********  DAC FUNCTIONS *********** */
 
-/* Slot 0 base settings. */
-#define VECT0	(XSD2 | RSD3 | SIB_A2)
-/* Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
-
 /* TrimDac LogicalChan-to-PhysicalChan mapping table. */
 static const uint8_t s626_trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 
@@ -417,7 +414,7 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
 	 * detection.
 	 */
-	writel(XSD2 | RSD3 | SIB_A2, devpriv->mmio + VECTPORT(0));
+	writel(XSD2 | RSD3 | SIB_A2, devpriv->mmio + S626_VECTPORT(0));
 
 	/*
 	 * Wait for slot 1 to execute to ensure that the Packet will be
@@ -437,7 +434,7 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * buffer register.
 	 */
 	writel(XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS,
-	       devpriv->mmio + VECTPORT(0));
+	       devpriv->mmio + S626_VECTPORT(0));
 
 	/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */
 
@@ -479,7 +476,7 @@ static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 	 * In order to do this, we reprogram slot 0 so that it will shift in
 	 * SD3, which is driven only by a pull-up resistor.
 	 */
-	writel(RSD3 | SIB_A2 | EOS, devpriv->mmio + VECTPORT(0));
+	writel(RSD3 | SIB_A2 | EOS, devpriv->mmio + S626_VECTPORT(0));
 
 	/*
 	 * Wait for slot 0 to execute, at which time the TSL is setup for
@@ -530,13 +527,13 @@ static void s626_set_dac(struct comedi_device *dev, uint16_t chan,
 	/* Choose DAC chip select to be asserted */
 	ws_image = (chan & 2) ? WS1 : WS2;
 	/* Slot 2: Transmit high data byte to target DAC */
-	writel(XSD2 | XFIFO_1 | ws_image, devpriv->mmio + VECTPORT(2));
+	writel(XSD2 | XFIFO_1 | ws_image, devpriv->mmio + S626_VECTPORT(2));
 	/* Slot 3: Transmit low data byte to target DAC */
-	writel(XSD2 | XFIFO_0 | ws_image, devpriv->mmio + VECTPORT(3));
+	writel(XSD2 | XFIFO_0 | ws_image, devpriv->mmio + S626_VECTPORT(3));
 	/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */
-	writel(XSD2 | XFIFO_3 | WS3, devpriv->mmio + VECTPORT(4));
+	writel(XSD2 | XFIFO_3 | WS3, devpriv->mmio + S626_VECTPORT(4));
 	/* Slot 5: running after writing target DAC's low data byte */
-	writel(XSD2 | XFIFO_2 | WS3 | EOS, devpriv->mmio + VECTPORT(5));
+	writel(XSD2 | XFIFO_2 | WS3 | EOS, devpriv->mmio + S626_VECTPORT(5));
 
 	/*
 	 * Construct and transmit target DAC's serial packet:
@@ -577,13 +574,13 @@ static void s626_write_trim_dac(struct comedi_device *dev, uint8_t logical_chan,
 	 */
 
 	/* Slot 2: Send high uint8_t to target TrimDac */
-	writel(XSD2 | XFIFO_1 | WS3, devpriv->mmio + VECTPORT(2));
+	writel(XSD2 | XFIFO_1 | WS3, devpriv->mmio + S626_VECTPORT(2));
 	/* Slot 3: Send low uint8_t to target TrimDac */
-	writel(XSD2 | XFIFO_0 | WS3, devpriv->mmio + VECTPORT(3));
+	writel(XSD2 | XFIFO_0 | WS3, devpriv->mmio + S626_VECTPORT(3));
 	/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running */
-	writel(XSD2 | XFIFO_3 | WS1, devpriv->mmio + VECTPORT(4));
+	writel(XSD2 | XFIFO_3 | WS1, devpriv->mmio + S626_VECTPORT(4));
 	/* Slot 5: Send NOP low  uint8_t to DAC0 */
-	writel(XSD2 | XFIFO_2 | WS1 | EOS, devpriv->mmio + VECTPORT(5));
+	writel(XSD2 | XFIFO_2 | WS1 | EOS, devpriv->mmio + S626_VECTPORT(5));
 
 	/*
 	 * Construct and transmit target DAC's serial packet:
@@ -1230,7 +1227,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_cra			= LP_CR0A,
 		.my_crb			= LP_CR0B,
 		.my_latch_lsw		= LP_CNTR0ALSW,
-		.my_event_bits		= EVBITS(0),
+		.my_event_bits		= S626_EVBITS(0),
 	}, {
 		.get_enable		= s626_get_enable_a,
 		.get_int_src		= s626_get_int_src_a,
@@ -1245,7 +1242,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_cra			= LP_CR1A,
 		.my_crb			= LP_CR1B,
 		.my_latch_lsw		= LP_CNTR1ALSW,
-		.my_event_bits		= EVBITS(1),
+		.my_event_bits		= S626_EVBITS(1),
 	}, {
 		.get_enable		= s626_get_enable_a,
 		.get_int_src		= s626_get_int_src_a,
@@ -1260,7 +1257,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_cra			= LP_CR2A,
 		.my_crb			= LP_CR2B,
 		.my_latch_lsw		= LP_CNTR2ALSW,
-		.my_event_bits		= EVBITS(2),
+		.my_event_bits		= S626_EVBITS(2),
 	}, {
 		.get_enable		= s626_get_enable_b,
 		.get_int_src		= s626_get_int_src_b,
@@ -1275,7 +1272,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_cra			= LP_CR0A,
 		.my_crb			= LP_CR0B,
 		.my_latch_lsw		= LP_CNTR0BLSW,
-		.my_event_bits		= EVBITS(3),
+		.my_event_bits		= S626_EVBITS(3),
 	}, {
 		.get_enable		= s626_get_enable_b,
 		.get_int_src		= s626_get_int_src_b,
@@ -1290,7 +1287,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_cra			= LP_CR1A,
 		.my_crb			= LP_CR1B,
 		.my_latch_lsw		= LP_CNTR1BLSW,
-		.my_event_bits		= EVBITS(4),
+		.my_event_bits		= S626_EVBITS(4),
 	}, {
 		.get_enable		= s626_get_enable_b,
 		.get_int_src		= s626_get_int_src_b,
@@ -1305,7 +1302,7 @@ static const struct s626_enc_info s626_enc_chan_info[] = {
 		.my_cra			= LP_CR2A,
 		.my_crb			= LP_CR2B,
 		.my_latch_lsw		= LP_CNTR2BLSW,
-		.my_event_bits		= EVBITS(5),
+		.my_event_bits		= S626_EVBITS(5),
 	},
 };
 
@@ -1746,7 +1743,7 @@ static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
 		*rps++ = RPS_PAUSE | RPS_GPIO2;	/* Wait for ADC done. */
 
 		/* Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
-		*rps++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
+		*rps++ = RPS_STREG | (S626_BUGFIX_STREG(P_FB_BUFFER1) >> 2);
 		*rps++ = (uint32_t)devpriv->ana_buf.physical_base +
 			 (devpriv->adc_items << 2);
 
@@ -1789,7 +1786,7 @@ static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
 	*rps++ = RPS_PAUSE | RPS_GPIO2;	/* Wait for ADC done. */
 
 	/* Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
-	*rps++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
+	*rps++ = RPS_STREG | (S626_BUGFIX_STREG(P_FB_BUFFER1) >> 2);
 	*rps++ = (uint32_t)devpriv->ana_buf.physical_base +
 		 (devpriv->adc_items << 2);
 
@@ -2211,14 +2208,14 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 	if (cmd->convert_src == TRIG_EXT)
 		err |= cfc_check_trigger_arg_max(&cmd->convert_arg, 39);
 
-#define MAX_SPEED	200000	/* in nanoseconds */
-#define MIN_SPEED	2000000000	/* in nanoseconds */
+#define S626_MAX_SPEED	200000	/* in nanoseconds */
+#define S626_MIN_SPEED	2000000000	/* in nanoseconds */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 MAX_SPEED);
+						 S626_MAX_SPEED);
 		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
-						 MIN_SPEED);
+						 S626_MIN_SPEED);
 	} else {
 		/* external trigger */
 		/* should be level/edge, hi/lo specification here */
@@ -2226,8 +2223,10 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 		/* err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 9); */
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg, MAX_SPEED);
-		err |= cfc_check_trigger_arg_max(&cmd->convert_arg, MIN_SPEED);
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+						 S626_MAX_SPEED);
+		err |= cfc_check_trigger_arg_max(&cmd->convert_arg,
+						 S626_MIN_SPEED);
 	} else {
 		/* external trigger */
 		/* see above */
@@ -2704,7 +2703,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 
 	/* Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2 */
-	writel(XSD2 | RSD3 | SIB_A2 | EOS, devpriv->mmio + VECTPORT(0));
+	writel(XSD2 | RSD3 | SIB_A2 | EOS, devpriv->mmio + S626_VECTPORT(0));
 
 	/*
 	 * Initialize slot 1, which is constant.  Slot 1 causes a
@@ -2716,7 +2715,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 
 	/* Slot 1: Fetch DWORD from Audio2's output FIFO */
-	writel(LF_A2, devpriv->mmio + VECTPORT(1));
+	writel(LF_A2, devpriv->mmio + S626_VECTPORT(1));
 
 	/* Start DAC's audio interface (TSL2) running */
 	writel(ACON1_DACSTART, devpriv->mmio + P_ACON1);

commit 31de1948d84ae3af2bdab366991433b718095957
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:40 2013 +0100

    staging: comedi: s626: prefix function and variable names
    
    Add the prefix `s626_` to all the static variables and functions that
    don't already have it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 3d476e32f38c..38f129aa09d2 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -152,7 +152,7 @@ struct s626_enc_info {
 
 /*
  * Translation table to map IntSrc into equivalent RDMISC2 event flag  bits.
- * static const uint16_t event_bits[][4] =
+ * static const uint16_t s626_event_bits[][4] =
  *     { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) };
  */
 
@@ -205,7 +205,7 @@ static const struct comedi_lrange s626_range_table = {
 /*
  * Execute a DEBI transfer.  This must be called from within a critical section.
  */
-static void debi_transfer(struct comedi_device *dev)
+static void s626_debi_transfer(struct comedi_device *dev)
 {
 	struct s626_private *devpriv = dev->private;
 
@@ -227,7 +227,7 @@ static void debi_transfer(struct comedi_device *dev)
 /*
  * Read a value from a gate array register.
  */
-static uint16_t debi_read(struct comedi_device *dev, uint16_t addr)
+static uint16_t s626_debi_read(struct comedi_device *dev, uint16_t addr)
 {
 	struct s626_private *devpriv = dev->private;
 
@@ -235,7 +235,7 @@ static uint16_t debi_read(struct comedi_device *dev, uint16_t addr)
 	writel(DEBI_CMD_RDWORD | addr, devpriv->mmio + P_DEBICMD);
 
 	/*  Execute the DEBI transfer. */
-	debi_transfer(dev);
+	s626_debi_transfer(dev);
 
 	return readl(devpriv->mmio + P_DEBIAD);
 }
@@ -243,7 +243,8 @@ static uint16_t debi_read(struct comedi_device *dev, uint16_t addr)
 /*
  * Write a value to a gate array register.
  */
-static void debi_write(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
+static void s626_debi_write(struct comedi_device *dev, uint16_t addr,
+			    uint16_t wdata)
 {
 	struct s626_private *devpriv = dev->private;
 
@@ -252,7 +253,7 @@ static void debi_write(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
 	writel(wdata, devpriv->mmio + P_DEBIAD);
 
 	/*  Execute the DEBI transfer. */
-	debi_transfer(dev);
+	s626_debi_transfer(dev);
 }
 
 /*
@@ -260,27 +261,27 @@ static void debi_write(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
  * specifies bits that are to be preserved, wdata is new value to be
  * or'd with the masked original.
  */
-static void debi_replace(struct comedi_device *dev, unsigned int addr,
-			 unsigned int mask, unsigned int wdata)
+static void s626_debi_replace(struct comedi_device *dev, unsigned int addr,
+			      unsigned int mask, unsigned int wdata)
 {
 	struct s626_private *devpriv = dev->private;
 	unsigned int val;
 
 	addr &= 0xffff;
 	writel(DEBI_CMD_RDWORD | addr, devpriv->mmio + P_DEBICMD);
-	debi_transfer(dev);
+	s626_debi_transfer(dev);
 
 	writel(DEBI_CMD_WRWORD | addr, devpriv->mmio + P_DEBICMD);
 	val = readl(devpriv->mmio + P_DEBIAD);
 	val &= mask;
 	val |= wdata;
 	writel(val & 0xffff, devpriv->mmio + P_DEBIAD);
-	debi_transfer(dev);
+	s626_debi_transfer(dev);
 }
 
 /* **************  EEPROM ACCESS FUNCTIONS  ************** */
 
-static uint32_t i2c_handshake(struct comedi_device *dev, uint32_t val)
+static uint32_t s626_i2c_handshake(struct comedi_device *dev, uint32_t val)
 {
 	struct s626_private *devpriv = dev->private;
 	unsigned int ctrl;
@@ -306,7 +307,7 @@ static uint32_t i2c_handshake(struct comedi_device *dev, uint32_t val)
 }
 
 /* Read uint8_t from EEPROM. */
-static uint8_t i2c_read(struct comedi_device *dev, uint8_t addr)
+static uint8_t s626_i2c_read(struct comedi_device *dev, uint8_t addr)
 {
 	struct s626_private *devpriv = dev->private;
 
@@ -316,9 +317,9 @@ static uint8_t i2c_read(struct comedi_device *dev, uint8_t addr)
 	 *  Byte1 = EEPROM internal target address.
 	 *  Byte0 = Not sent.
 	 */
-	if (i2c_handshake(dev, I2C_B2(I2C_ATTRSTART, devpriv->i2c_adrs) |
-			       I2C_B1(I2C_ATTRSTOP, addr) |
-			       I2C_B0(I2C_ATTRNOP, 0)))
+	if (s626_i2c_handshake(dev, I2C_B2(I2C_ATTRSTART, devpriv->i2c_adrs) |
+				    I2C_B1(I2C_ATTRSTOP, addr) |
+				    I2C_B0(I2C_ATTRNOP, 0)))
 		/* Abort function and declare error if handshake failed. */
 		return 0;
 
@@ -328,9 +329,10 @@ static uint8_t i2c_read(struct comedi_device *dev, uint8_t addr)
 	 *  Byte1 receives uint8_t from EEPROM.
 	 *  Byte0 = Not sent.
 	 */
-	if (i2c_handshake(dev, I2C_B2(I2C_ATTRSTART, (devpriv->i2c_adrs | 1)) |
-			       I2C_B1(I2C_ATTRSTOP, 0) |
-			       I2C_B0(I2C_ATTRNOP, 0)))
+	if (s626_i2c_handshake(dev, I2C_B2(I2C_ATTRSTART,
+					   (devpriv->i2c_adrs | 1)) |
+				    I2C_B1(I2C_ATTRSTOP, 0) |
+				    I2C_B0(I2C_ATTRNOP, 0)))
 		/* Abort function and declare error if handshake failed. */
 		return 0;
 
@@ -344,10 +346,10 @@ static uint8_t i2c_read(struct comedi_device *dev, uint8_t addr)
 /* Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
 
 /* TrimDac LogicalChan-to-PhysicalChan mapping table. */
-static const uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
+static const uint8_t s626_trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 
 /* TrimDac LogicalChan-to-EepromAdrs mapping table. */
-static const uint8_t trimadrs[] = {
+static const uint8_t s626_trimadrs[] = {
 	0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63
 };
 
@@ -356,7 +358,7 @@ static const uint8_t trimadrs[] = {
  * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
  * dacpol contains valid target image.
  */
-static void send_dac(struct comedi_device *dev, uint32_t val)
+static void s626_send_dac(struct comedi_device *dev, uint32_t val)
 {
 	struct s626_private *devpriv = dev->private;
 
@@ -367,12 +369,12 @@ static void send_dac(struct comedi_device *dev, uint32_t val)
 	 * and audio bit stream signals.  At this point in time we must be
 	 * assured of being in time slot 0.  If we are not in slot 0, the
 	 * serial clock and audio stream signals will be disabled; this is
-	 * because the following debi_write statement (which enables signals
-	 * to be passed through the gate array) would execute before the
-	 * trailing edge of WS1/WS3 (which turns off the signals), thus
+	 * because the following s626_debi_write statement (which enables
+	 * signals to be passed through the gate array) would execute before
+	 * the trailing edge of WS1/WS3 (which turns off the signals), thus
 	 * causing the signals to be inactive during the DAC write.
 	 */
-	debi_write(dev, LP_DACPOL, devpriv->dacpol);
+	s626_debi_write(dev, LP_DACPOL, devpriv->dacpol);
 
 	/* TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- */
 
@@ -491,7 +493,8 @@ static void send_dac(struct comedi_device *dev, uint32_t val)
 /*
  * Private helper function: Write setpoint to an application DAC channel.
  */
-static void set_dac(struct comedi_device *dev, uint16_t chan, short dacdata)
+static void s626_set_dac(struct comedi_device *dev, uint16_t chan,
+			 short dacdata)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t signmask;
@@ -549,11 +552,11 @@ static void set_dac(struct comedi_device *dev, uint16_t chan, short dacdata)
 	val |= ((uint32_t)(chan & 1) << 15);	/* Address the DAC channel
 						 * within the device. */
 	val |= (uint32_t)dacdata;	/* Include DAC setpoint data. */
-	send_dac(dev, val);
+	s626_send_dac(dev, val);
 }
 
-static void write_trim_dac(struct comedi_device *dev, uint8_t logical_chan,
-			   uint8_t dac_data)
+static void s626_write_trim_dac(struct comedi_device *dev, uint8_t logical_chan,
+				uint8_t dac_data)
 {
 	struct s626_private *devpriv = dev->private;
 	uint32_t chan;
@@ -565,7 +568,7 @@ static void write_trim_dac(struct comedi_device *dev, uint8_t logical_chan,
 	devpriv->trim_setpoint[logical_chan] = (uint8_t)dac_data;
 
 	/* Map logical channel number to physical channel number. */
-	chan = trimchan[logical_chan];
+	chan = s626_trimchan[logical_chan];
 
 	/*
 	 * Set up TSL2 records for TrimDac write operation.  All slots shift
@@ -595,16 +598,17 @@ static void write_trim_dac(struct comedi_device *dev, uint8_t logical_chan,
 	 * Address the DAC channel within the trimdac device.
 	 * Include DAC setpoint data.
 	 */
-	send_dac(dev, (chan << 8) | dac_data);
+	s626_send_dac(dev, (chan << 8) | dac_data);
 }
 
-static void load_trim_dacs(struct comedi_device *dev)
+static void s626_load_trim_dacs(struct comedi_device *dev)
 {
 	uint8_t i;
 
 	/* Copy TrimDac setpoint values from EEPROM to TrimDacs. */
-	for (i = 0; i < ARRAY_SIZE(trimchan); i++)
-		write_trim_dac(dev, i, i2c_read(dev, trimadrs[i]));
+	for (i = 0; i < ARRAY_SIZE(s626_trimchan); i++)
+		s626_write_trim_dac(dev, i,
+				    s626_i2c_read(dev, s626_trimadrs[i]));
 }
 
 /* ******  COUNTER FUNCTIONS  ******* */
@@ -619,16 +623,16 @@ static void load_trim_dacs(struct comedi_device *dev)
 /*
  * Read a counter's output latch.
  */
-static uint32_t read_latch(struct comedi_device *dev,
-			   const struct s626_enc_info *k)
+static uint32_t s626_read_latch(struct comedi_device *dev,
+				const struct s626_enc_info *k)
 {
 	uint32_t value;
 
 	/* Latch counts and fetch LSW of latched counts value. */
-	value = debi_read(dev, k->my_latch_lsw);
+	value = s626_debi_read(dev, k->my_latch_lsw);
 
 	/* Fetch MSW of latched counts and combine with LSW. */
-	value |= ((uint32_t)debi_read(dev, k->my_latch_lsw + 2) << 16);
+	value |= ((uint32_t)s626_debi_read(dev, k->my_latch_lsw + 2) << 16);
 
 	/* Return latched counts. */
 	return value;
@@ -639,21 +643,21 @@ static uint32_t read_latch(struct comedi_device *dev,
  * access, 1: A index latches A, 2: B index latches B, 3: A overflow
  * latches B.
  */
-static void set_latch_source(struct comedi_device *dev,
-			     const struct s626_enc_info *k, uint16_t value)
+static void s626_set_latch_source(struct comedi_device *dev,
+				  const struct s626_enc_info *k, uint16_t value)
 {
-	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC),
-		     value << CRBBIT_LATCHSRC);
+	s626_debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC),
+			  value << CRBBIT_LATCHSRC);
 }
 
 /*
  * Write value into counter preload register.
  */
-static void preload(struct comedi_device *dev, const struct s626_enc_info *k,
-		    uint32_t value)
+static void s626_preload(struct comedi_device *dev,
+			 const struct s626_enc_info *k, uint32_t value)
 {
-	debi_write(dev, k->my_latch_lsw, value);
-	debi_write(dev, k->my_latch_lsw + 2, value >> 16);
+	s626_debi_write(dev, k->my_latch_lsw, value);
+	s626_debi_write(dev, k->my_latch_lsw + 2, value >> 16);
 }
 
 /* ******  PRIVATE COUNTER FUNCTIONS ****** */
@@ -661,34 +665,34 @@ static void preload(struct comedi_device *dev, const struct s626_enc_info *k,
 /*
  * Reset a counter's index and overflow event capture flags.
  */
-static void reset_cap_flags_a(struct comedi_device *dev,
-			      const struct s626_enc_info *k)
+static void s626_reset_cap_flags_a(struct comedi_device *dev,
+				   const struct s626_enc_info *k)
 {
-	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
-		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+	s626_debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
+			  CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 }
 
-static void reset_cap_flags_b(struct comedi_device *dev,
-			      const struct s626_enc_info *k)
+static void s626_reset_cap_flags_b(struct comedi_device *dev,
+				   const struct s626_enc_info *k)
 {
-	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
-		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
+	s626_debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
+			  CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
 }
 
 /*
  * Return counter setup in a format (COUNTER_SETUP) that is consistent
  * for both A and B counters.
  */
-static uint16_t get_mode_a(struct comedi_device *dev,
-			   const struct s626_enc_info *k)
+static uint16_t s626_get_mode_a(struct comedi_device *dev,
+				const struct s626_enc_info *k)
 {
 	uint16_t cra;
 	uint16_t crb;
 	uint16_t setup;
 
 	/* Fetch CRA and CRB register images. */
-	cra = debi_read(dev, k->my_cra);
-	crb = debi_read(dev, k->my_crb);
+	cra = s626_debi_read(dev, k->my_cra);
+	crb = s626_debi_read(dev, k->my_crb);
 
 	/*
 	 * Populate the standardized counter setup bit fields.
@@ -735,16 +739,16 @@ static uint16_t get_mode_a(struct comedi_device *dev,
 	return setup;
 }
 
-static uint16_t get_mode_b(struct comedi_device *dev,
-			   const struct s626_enc_info *k)
+static uint16_t s626_get_mode_b(struct comedi_device *dev,
+				const struct s626_enc_info *k)
 {
 	uint16_t cra;
 	uint16_t crb;
 	uint16_t setup;
 
 	/* Fetch CRA and CRB register images. */
-	cra = debi_read(dev, k->my_cra);
-	crb = debi_read(dev, k->my_crb);
+	cra = s626_debi_read(dev, k->my_cra);
+	crb = s626_debi_read(dev, k->my_crb);
 
 	/*
 	 * Populate the standardized counter setup bit fields.
@@ -804,8 +808,9 @@ static uint16_t get_mode_b(struct comedi_device *dev,
  * parameters are programmable (all other parms are ignored): ClkMult,
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
-static void set_mode_a(struct comedi_device *dev, const struct s626_enc_info *k,
-		       uint16_t setup, uint16_t disable_int_src)
+static void s626_set_mode_a(struct comedi_device *dev,
+			    const struct s626_enc_info *k, uint16_t setup,
+			    uint16_t disable_int_src)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t cra;
@@ -878,12 +883,15 @@ static void set_mode_a(struct comedi_device *dev, const struct s626_enc_info *k,
 	 * While retaining CounterB and LatchSrc configurations, program the
 	 * new counter operating mode.
 	 */
-	debi_replace(dev, k->my_cra, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
-	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A), crb);
+	s626_debi_replace(dev, k->my_cra, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B,
+			  cra);
+	s626_debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A),
+			  crb);
 }
 
-static void set_mode_b(struct comedi_device *dev, const struct s626_enc_info *k,
-		       uint16_t setup, uint16_t disable_int_src)
+static void s626_set_mode_b(struct comedi_device *dev,
+			    const struct s626_enc_info *k, uint16_t setup,
+			    uint16_t disable_int_src)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t cra;
@@ -964,45 +972,46 @@ static void set_mode_b(struct comedi_device *dev, const struct s626_enc_info *k,
 	 * While retaining CounterA and LatchSrc configurations, program the
 	 * new counter operating mode.
 	 */
-	debi_replace(dev, k->my_cra, ~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B),
-		     cra);
-	debi_replace(dev, k->my_crb, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
+	s626_debi_replace(dev, k->my_cra, ~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B),
+			  cra);
+	s626_debi_replace(dev, k->my_crb, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC,
+			  crb);
 }
 
 /*
  * Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
  */
-static void set_enable_a(struct comedi_device *dev,
-			 const struct s626_enc_info *k, uint16_t enab)
+static void s626_set_enable_a(struct comedi_device *dev,
+			      const struct s626_enc_info *k, uint16_t enab)
 {
-	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A),
-		     enab << CRBBIT_CLKENAB_A);
+	s626_debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A),
+			  enab << CRBBIT_CLKENAB_A);
 }
 
-static void set_enable_b(struct comedi_device *dev,
-			 const struct s626_enc_info *k, uint16_t enab)
+static void s626_set_enable_b(struct comedi_device *dev,
+			      const struct s626_enc_info *k, uint16_t enab)
 {
-	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B),
-		     enab << CRBBIT_CLKENAB_B);
+	s626_debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B),
+			  enab << CRBBIT_CLKENAB_B);
 }
 
-static uint16_t get_enable_a(struct comedi_device *dev,
-			     const struct s626_enc_info *k)
+static uint16_t s626_get_enable_a(struct comedi_device *dev,
+				  const struct s626_enc_info *k)
 {
-	return (debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_A) & 1;
+	return (s626_debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_A) & 1;
 }
 
-static uint16_t get_enable_b(struct comedi_device *dev,
-			     const struct s626_enc_info *k)
+static uint16_t s626_get_enable_b(struct comedi_device *dev,
+				  const struct s626_enc_info *k)
 {
-	return (debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_B) & 1;
+	return (s626_debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_B) & 1;
 }
 
 #ifdef unused
-static uint16_t get_latch_source(struct comedi_device *dev,
-				 const struct s626_enc_info *k)
+static uint16_t s626_get_latch_source(struct comedi_device *dev,
+				      const struct s626_enc_info *k)
 {
-	return (debi_read(dev, k->my_crb) >> CRBBIT_LATCHSRC) & 3;
+	return (s626_debi_read(dev, k->my_crb) >> CRBBIT_LATCHSRC) & 3;
 }
 #endif
 
@@ -1011,30 +1020,30 @@ static uint16_t get_latch_source(struct comedi_device *dev,
  * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
  * 2=OverflowA (B counters only), 3=disabled.
  */
-static void set_load_trig_a(struct comedi_device *dev,
-			    const struct s626_enc_info *k, uint16_t trig)
+static void s626_set_load_trig_a(struct comedi_device *dev,
+				 const struct s626_enc_info *k, uint16_t trig)
 {
-	debi_replace(dev, k->my_cra, ~CRAMSK_LOADSRC_A,
-		     trig << CRABIT_LOADSRC_A);
+	s626_debi_replace(dev, k->my_cra, ~CRAMSK_LOADSRC_A,
+			  trig << CRABIT_LOADSRC_A);
 }
 
-static void set_load_trig_b(struct comedi_device *dev,
-			    const struct s626_enc_info *k, uint16_t trig)
+static void s626_set_load_trig_b(struct comedi_device *dev,
+				 const struct s626_enc_info *k, uint16_t trig)
 {
-	debi_replace(dev, k->my_crb, ~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL),
-		     trig << CRBBIT_LOADSRC_B);
+	s626_debi_replace(dev, k->my_crb, ~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL),
+			  trig << CRBBIT_LOADSRC_B);
 }
 
-static uint16_t get_load_trig_a(struct comedi_device *dev,
-				const struct s626_enc_info *k)
+static uint16_t s626_get_load_trig_a(struct comedi_device *dev,
+				     const struct s626_enc_info *k)
 {
-	return (debi_read(dev, k->my_cra) >> CRABIT_LOADSRC_A) & 3;
+	return (s626_debi_read(dev, k->my_cra) >> CRABIT_LOADSRC_A) & 3;
 }
 
-static uint16_t get_load_trig_b(struct comedi_device *dev,
-				const struct s626_enc_info *k)
+static uint16_t s626_get_load_trig_b(struct comedi_device *dev,
+				     const struct s626_enc_info *k)
 {
-	return (debi_read(dev, k->my_crb) >> CRBBIT_LOADSRC_B) & 3;
+	return (s626_debi_read(dev, k->my_crb) >> CRBBIT_LOADSRC_B) & 3;
 }
 
 /*
@@ -1042,18 +1051,19 @@ static uint16_t get_load_trig_b(struct comedi_device *dev,
  * index/overflow events.  int_source: 0=Disabled, 1=OverflowOnly,
  * 2=IndexOnly, 3=IndexAndOverflow.
  */
-static void set_int_src_a(struct comedi_device *dev,
-			  const struct s626_enc_info *k, uint16_t int_source)
+static void s626_set_int_src_a(struct comedi_device *dev,
+			       const struct s626_enc_info *k,
+			       uint16_t int_source)
 {
 	struct s626_private *devpriv = dev->private;
 
 	/* Reset any pending counter overflow or index captures. */
-	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
-		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+	s626_debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
+			  CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 
 	/* Program counter interrupt source. */
-	debi_replace(dev, k->my_cra, ~CRAMSK_INTSRC_A,
-		     int_source << CRABIT_INTSRC_A);
+	s626_debi_replace(dev, k->my_cra, ~CRAMSK_INTSRC_A,
+			  int_source << CRABIT_INTSRC_A);
 
 	/* Update MISC2 interrupt enable mask. */
 	devpriv->counter_int_enabs =
@@ -1061,23 +1071,24 @@ static void set_int_src_a(struct comedi_device *dev,
 	    k->my_event_bits[int_source];
 }
 
-static void set_int_src_b(struct comedi_device *dev,
-			  const struct s626_enc_info *k, uint16_t int_source)
+static void s626_set_int_src_b(struct comedi_device *dev,
+			       const struct s626_enc_info *k,
+			       uint16_t int_source)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t crb;
 
 	/* Cache writeable CRB register image. */
-	crb = debi_read(dev, k->my_crb) & ~CRBMSK_INTCTRL;
+	crb = s626_debi_read(dev, k->my_crb) & ~CRBMSK_INTCTRL;
 
 	/* Reset any pending counter overflow or index captures. */
-	debi_write(dev, k->my_crb,
-		   (uint16_t)(crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
+	s626_debi_write(dev, k->my_crb,
+			(crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
 
 	/* Program counter interrupt source. */
-	debi_write(dev, k->my_crb,
-		   (uint16_t)((crb & ~CRBMSK_INTSRC_B) |
-			      (int_source << CRBBIT_INTSRC_B)));
+	s626_debi_write(dev, k->my_crb,
+			((crb & ~CRBMSK_INTSRC_B) |
+			 (int_source << CRBBIT_INTSRC_B)));
 
 	/* Update MISC2 interrupt enable mask. */
 	devpriv->counter_int_enabs =
@@ -1085,31 +1096,31 @@ static void set_int_src_b(struct comedi_device *dev,
 		k->my_event_bits[int_source];
 }
 
-static uint16_t get_int_src_a(struct comedi_device *dev,
-			      const struct s626_enc_info *k)
+static uint16_t s626_get_int_src_a(struct comedi_device *dev,
+				   const struct s626_enc_info *k)
 {
-	return (debi_read(dev, k->my_cra) >> CRABIT_INTSRC_A) & 3;
+	return (s626_debi_read(dev, k->my_cra) >> CRABIT_INTSRC_A) & 3;
 }
 
-static uint16_t get_int_src_b(struct comedi_device *dev,
-			      const struct s626_enc_info *k)
+static uint16_t s626_get_int_src_b(struct comedi_device *dev,
+				   const struct s626_enc_info *k)
 {
-	return (debi_read(dev, k->my_crb) >> CRBBIT_INTSRC_B) & 3;
+	return (s626_debi_read(dev, k->my_crb) >> CRBBIT_INTSRC_B) & 3;
 }
 
 #ifdef unused
 /*
  * Return/set the clock multiplier.
  */
-static void set_clk_mult(struct comedi_device *dev,
-			 const struct s626_enc_info *k, uint16_t value)
+static void s626_set_clk_mult(struct comedi_device *dev,
+			      const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKMULT) |
 			    (value << STDBIT_CLKMULT)), false);
 }
 
-static uint16_t get_clk_mult(struct comedi_device *dev,
-			     const struct s626_enc_info *k)
+static uint16_t s626_get_clk_mult(struct comedi_device *dev,
+				  const struct s626_enc_info *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_CLKMULT) & 3;
 }
@@ -1117,15 +1128,15 @@ static uint16_t get_clk_mult(struct comedi_device *dev,
 /*
  * Return/set the clock polarity.
  */
-static void set_clk_pol(struct comedi_device *dev,
-			const struct s626_enc_info *k, uint16_t value)
+static void s626_set_clk_pol(struct comedi_device *dev,
+			     const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKPOL) |
 			    (value << STDBIT_CLKPOL)), false);
 }
 
-static uint16_t get_clk_pol(struct comedi_device *dev,
-			    const struct s626_enc_info *k)
+static uint16_t s626_get_clk_pol(struct comedi_device *dev,
+				 const struct s626_enc_info *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_CLKPOL) & 1;
 }
@@ -1133,15 +1144,15 @@ static uint16_t get_clk_pol(struct comedi_device *dev,
 /*
  * Return/set the clock source.
  */
-static void set_clk_src(struct comedi_device *dev,
-			const struct s626_enc_info *k, uint16_t value)
+static void s626_set_clk_src(struct comedi_device *dev,
+			     const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKSRC) |
 			    (value << STDBIT_CLKSRC)), false);
 }
 
-static uint16_t get_clk_src(struct comedi_device *dev,
-			    const struct s626_enc_info *k)
+static uint16_t s626_get_clk_src(struct comedi_device *dev,
+				 const struct s626_enc_info *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_CLKSRC) & 3;
 }
@@ -1149,15 +1160,15 @@ static uint16_t get_clk_src(struct comedi_device *dev,
 /*
  * Return/set the index polarity.
  */
-static void set_index_pol(struct comedi_device *dev,
-			  const struct s626_enc_info *k, uint16_t value)
+static void s626_set_index_pol(struct comedi_device *dev,
+			       const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXPOL) |
 			    ((value != 0) << STDBIT_INDXPOL)), false);
 }
 
-static uint16_t get_index_pol(struct comedi_device *dev,
-			      const struct s626_enc_info *k)
+static uint16_t s626_get_index_pol(struct comedi_device *dev,
+				   const struct s626_enc_info *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_INDXPOL) & 1;
 }
@@ -1165,15 +1176,15 @@ static uint16_t get_index_pol(struct comedi_device *dev,
 /*
  * Return/set the index source.
  */
-static void set_index_src(struct comedi_device *dev,
-			  const struct s626_enc_info *k, uint16_t value)
+static void s626_set_index_src(struct comedi_device *dev,
+			       const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXSRC) |
 			    ((value != 0) << STDBIT_INDXSRC)), false);
 }
 
-static uint16_t get_index_src(struct comedi_device *dev,
-			      const struct s626_enc_info *k)
+static uint16_t s626_get_index_src(struct comedi_device *dev,
+				   const struct s626_enc_info *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_INDXSRC) & 1;
 }
@@ -1182,115 +1193,115 @@ static uint16_t get_index_src(struct comedi_device *dev,
 /*
  * Generate an index pulse.
  */
-static void pulse_index_a(struct comedi_device *dev,
-			  const struct s626_enc_info *k)
+static void s626_pulse_index_a(struct comedi_device *dev,
+			       const struct s626_enc_info *k)
 {
 	uint16_t cra;
 
-	cra = debi_read(dev, k->my_cra);
+	cra = s626_debi_read(dev, k->my_cra);
 	/* Pulse index. */
-	debi_write(dev, k->my_cra, (cra ^ CRAMSK_INDXPOL_A));
-	debi_write(dev, k->my_cra, cra);
+	s626_debi_write(dev, k->my_cra, (cra ^ CRAMSK_INDXPOL_A));
+	s626_debi_write(dev, k->my_cra, cra);
 }
 
-static void pulse_index_b(struct comedi_device *dev,
-			  const struct s626_enc_info *k)
+static void s626_pulse_index_b(struct comedi_device *dev,
+			       const struct s626_enc_info *k)
 {
 	uint16_t crb;
 
-	crb = debi_read(dev, k->my_crb) & ~CRBMSK_INTCTRL;
+	crb = s626_debi_read(dev, k->my_crb) & ~CRBMSK_INTCTRL;
 	/* Pulse index. */
-	debi_write(dev, k->my_crb, (crb ^ CRBMSK_INDXPOL_B));
-	debi_write(dev, k->my_crb, crb);
+	s626_debi_write(dev, k->my_crb, (crb ^ CRBMSK_INDXPOL_B));
+	s626_debi_write(dev, k->my_crb, crb);
 }
 
 static const struct s626_enc_info s626_enc_chan_info[] = {
 	{
-		.get_enable		= get_enable_a,
-		.get_int_src		= get_int_src_a,
-		.get_load_trig		= get_load_trig_a,
-		.get_mode		= get_mode_a,
-		.pulse_index		= pulse_index_a,
-		.set_enable		= set_enable_a,
-		.set_int_src		= set_int_src_a,
-		.set_load_trig		= set_load_trig_a,
-		.set_mode		= set_mode_a,
-		.reset_cap_flags	= reset_cap_flags_a,
+		.get_enable		= s626_get_enable_a,
+		.get_int_src		= s626_get_int_src_a,
+		.get_load_trig		= s626_get_load_trig_a,
+		.get_mode		= s626_get_mode_a,
+		.pulse_index		= s626_pulse_index_a,
+		.set_enable		= s626_set_enable_a,
+		.set_int_src		= s626_set_int_src_a,
+		.set_load_trig		= s626_set_load_trig_a,
+		.set_mode		= s626_set_mode_a,
+		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_cra			= LP_CR0A,
 		.my_crb			= LP_CR0B,
 		.my_latch_lsw		= LP_CNTR0ALSW,
 		.my_event_bits		= EVBITS(0),
 	}, {
-		.get_enable		= get_enable_a,
-		.get_int_src		= get_int_src_a,
-		.get_load_trig		= get_load_trig_a,
-		.get_mode		= get_mode_a,
-		.pulse_index		= pulse_index_a,
-		.set_enable		= set_enable_a,
-		.set_int_src		= set_int_src_a,
-		.set_load_trig		= set_load_trig_a,
-		.set_mode		= set_mode_a,
-		.reset_cap_flags	= reset_cap_flags_a,
+		.get_enable		= s626_get_enable_a,
+		.get_int_src		= s626_get_int_src_a,
+		.get_load_trig		= s626_get_load_trig_a,
+		.get_mode		= s626_get_mode_a,
+		.pulse_index		= s626_pulse_index_a,
+		.set_enable		= s626_set_enable_a,
+		.set_int_src		= s626_set_int_src_a,
+		.set_load_trig		= s626_set_load_trig_a,
+		.set_mode		= s626_set_mode_a,
+		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_cra			= LP_CR1A,
 		.my_crb			= LP_CR1B,
 		.my_latch_lsw		= LP_CNTR1ALSW,
 		.my_event_bits		= EVBITS(1),
 	}, {
-		.get_enable		= get_enable_a,
-		.get_int_src		= get_int_src_a,
-		.get_load_trig		= get_load_trig_a,
-		.get_mode		= get_mode_a,
-		.pulse_index		= pulse_index_a,
-		.set_enable		= set_enable_a,
-		.set_int_src		= set_int_src_a,
-		.set_load_trig		= set_load_trig_a,
-		.set_mode		= set_mode_a,
-		.reset_cap_flags	= reset_cap_flags_a,
+		.get_enable		= s626_get_enable_a,
+		.get_int_src		= s626_get_int_src_a,
+		.get_load_trig		= s626_get_load_trig_a,
+		.get_mode		= s626_get_mode_a,
+		.pulse_index		= s626_pulse_index_a,
+		.set_enable		= s626_set_enable_a,
+		.set_int_src		= s626_set_int_src_a,
+		.set_load_trig		= s626_set_load_trig_a,
+		.set_mode		= s626_set_mode_a,
+		.reset_cap_flags	= s626_reset_cap_flags_a,
 		.my_cra			= LP_CR2A,
 		.my_crb			= LP_CR2B,
 		.my_latch_lsw		= LP_CNTR2ALSW,
 		.my_event_bits		= EVBITS(2),
 	}, {
-		.get_enable		= get_enable_b,
-		.get_int_src		= get_int_src_b,
-		.get_load_trig		= get_load_trig_b,
-		.get_mode		= get_mode_b,
-		.pulse_index		= pulse_index_b,
-		.set_enable		= set_enable_b,
-		.set_int_src		= set_int_src_b,
-		.set_load_trig		= set_load_trig_b,
-		.set_mode		= set_mode_b,
-		.reset_cap_flags	= reset_cap_flags_b,
+		.get_enable		= s626_get_enable_b,
+		.get_int_src		= s626_get_int_src_b,
+		.get_load_trig		= s626_get_load_trig_b,
+		.get_mode		= s626_get_mode_b,
+		.pulse_index		= s626_pulse_index_b,
+		.set_enable		= s626_set_enable_b,
+		.set_int_src		= s626_set_int_src_b,
+		.set_load_trig		= s626_set_load_trig_b,
+		.set_mode		= s626_set_mode_b,
+		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_cra			= LP_CR0A,
 		.my_crb			= LP_CR0B,
 		.my_latch_lsw		= LP_CNTR0BLSW,
 		.my_event_bits		= EVBITS(3),
 	}, {
-		.get_enable		= get_enable_b,
-		.get_int_src		= get_int_src_b,
-		.get_load_trig		= get_load_trig_b,
-		.get_mode		= get_mode_b,
-		.pulse_index		= pulse_index_b,
-		.set_enable		= set_enable_b,
-		.set_int_src		= set_int_src_b,
-		.set_load_trig		= set_load_trig_b,
-		.set_mode		= set_mode_b,
-		.reset_cap_flags	= reset_cap_flags_b,
+		.get_enable		= s626_get_enable_b,
+		.get_int_src		= s626_get_int_src_b,
+		.get_load_trig		= s626_get_load_trig_b,
+		.get_mode		= s626_get_mode_b,
+		.pulse_index		= s626_pulse_index_b,
+		.set_enable		= s626_set_enable_b,
+		.set_int_src		= s626_set_int_src_b,
+		.set_load_trig		= s626_set_load_trig_b,
+		.set_mode		= s626_set_mode_b,
+		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_cra			= LP_CR1A,
 		.my_crb			= LP_CR1B,
 		.my_latch_lsw		= LP_CNTR1BLSW,
 		.my_event_bits		= EVBITS(4),
 	}, {
-		.get_enable		= get_enable_b,
-		.get_int_src		= get_int_src_b,
-		.get_load_trig		= get_load_trig_b,
-		.get_mode		= get_mode_b,
-		.pulse_index		= pulse_index_b,
-		.set_enable		= set_enable_b,
-		.set_int_src		= set_int_src_b,
-		.set_load_trig		= set_load_trig_b,
-		.set_mode		= set_mode_b,
-		.reset_cap_flags	= reset_cap_flags_b,
+		.get_enable		= s626_get_enable_b,
+		.get_int_src		= s626_get_int_src_b,
+		.get_load_trig		= s626_get_load_trig_b,
+		.get_mode		= s626_get_mode_b,
+		.pulse_index		= s626_pulse_index_b,
+		.set_enable		= s626_set_enable_b,
+		.set_int_src		= s626_set_int_src_b,
+		.set_load_trig		= s626_set_load_trig_b,
+		.set_mode		= s626_set_mode_b,
+		.reset_cap_flags	= s626_reset_cap_flags_b,
 		.my_cra			= LP_CR2A,
 		.my_crb			= LP_CR2B,
 		.my_latch_lsw		= LP_CNTR2BLSW,
@@ -1318,19 +1329,19 @@ static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
 	unsigned int status;
 
 	/* set channel to capture positive edge */
-	status = debi_read(dev, LP_RDEDGSEL(group));
-	debi_write(dev, LP_WREDGSEL(group), mask | status);
+	status = s626_debi_read(dev, LP_RDEDGSEL(group));
+	s626_debi_write(dev, LP_WREDGSEL(group), mask | status);
 
 	/* enable interrupt on selected channel */
-	status = debi_read(dev, LP_RDINTSEL(group));
-	debi_write(dev, LP_WRINTSEL(group), mask | status);
+	status = s626_debi_read(dev, LP_RDINTSEL(group));
+	s626_debi_write(dev, LP_WRINTSEL(group), mask | status);
 
 	/* enable edge capture write command */
-	debi_write(dev, LP_MISC1, MISC1_EDCAP);
+	s626_debi_write(dev, LP_MISC1, MISC1_EDCAP);
 
 	/* enable edge capture on selected channel */
-	status = debi_read(dev, LP_RDCAPSEL(group));
-	debi_write(dev, LP_WRCAPSEL(group), mask | status);
+	status = s626_debi_read(dev, LP_RDCAPSEL(group));
+	s626_debi_write(dev, LP_WRCAPSEL(group), mask | status);
 
 	return 0;
 }
@@ -1339,10 +1350,10 @@ static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,
 			      unsigned int mask)
 {
 	/* disable edge capture write command */
-	debi_write(dev, LP_MISC1, MISC1_NOEDCAP);
+	s626_debi_write(dev, LP_MISC1, MISC1_NOEDCAP);
 
 	/* enable edge capture on selected channel */
-	debi_write(dev, LP_WRCAPSEL(group), mask);
+	s626_debi_write(dev, LP_WRCAPSEL(group), mask);
 
 	return 0;
 }
@@ -1352,17 +1363,17 @@ static int s626_dio_clear_irq(struct comedi_device *dev)
 	unsigned int group;
 
 	/* disable edge capture write command */
-	debi_write(dev, LP_MISC1, MISC1_NOEDCAP);
+	s626_debi_write(dev, LP_MISC1, MISC1_NOEDCAP);
 
 	/* clear all dio pending events and interrupt */
 	for (group = 0; group < S626_DIO_BANKS; group++)
-		debi_write(dev, LP_WRCAPSEL(group), 0xffff);
+		s626_debi_write(dev, LP_WRCAPSEL(group), 0xffff);
 
 	return 0;
 }
 
-static void handle_dio_interrupt(struct comedi_device *dev,
-				 uint16_t irqbit, uint8_t group)
+static void s626_handle_dio_interrupt(struct comedi_device *dev,
+				      uint16_t irqbit, uint8_t group)
 {
 	struct s626_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
@@ -1411,7 +1422,7 @@ static void handle_dio_interrupt(struct comedi_device *dev,
 	}
 }
 
-static void check_dio_interrupts(struct comedi_device *dev)
+static void s626_check_dio_interrupts(struct comedi_device *dev)
 {
 	uint16_t irqbit;
 	uint8_t group;
@@ -1419,17 +1430,17 @@ static void check_dio_interrupts(struct comedi_device *dev)
 	for (group = 0; group < S626_DIO_BANKS; group++) {
 		irqbit = 0;
 		/* read interrupt type */
-		irqbit = debi_read(dev, LP_RDCAPFLG(group));
+		irqbit = s626_debi_read(dev, LP_RDCAPFLG(group));
 
 		/* check if interrupt is generated from dio channels */
 		if (irqbit) {
-			handle_dio_interrupt(dev, irqbit, group);
+			s626_handle_dio_interrupt(dev, irqbit, group);
 			return;
 		}
 	}
 }
 
-static void check_counter_interrupts(struct comedi_device *dev)
+static void s626_check_counter_interrupts(struct comedi_device *dev)
 {
 	struct s626_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
@@ -1439,7 +1450,7 @@ static void check_counter_interrupts(struct comedi_device *dev)
 	uint16_t irqbit;
 
 	/* read interrupt type */
-	irqbit = debi_read(dev, LP_RDMISC2);
+	irqbit = s626_debi_read(dev, LP_RDMISC2);
 
 	/* check interrupt on counters */
 	if (irqbit & IRQ_COINT1A) {
@@ -1502,7 +1513,7 @@ static void check_counter_interrupts(struct comedi_device *dev)
 	}
 }
 
-static bool handle_eos_interrupt(struct comedi_device *dev)
+static bool s626_handle_eos_interrupt(struct comedi_device *dev)
 {
 	struct s626_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
@@ -1586,13 +1597,13 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 
 	switch (irqtype) {
 	case IRQ_RPS1:	/* end_of_scan occurs */
-		if (handle_eos_interrupt(dev))
+		if (s626_handle_eos_interrupt(dev))
 			irqstatus = 0;
 		break;
 	case IRQ_GPIO3:	/* check dio and counter interrupt */
 		/* s626_dio_clear_irq(dev); */
-		check_dio_interrupts(dev);
-		check_counter_interrupts(dev);
+		s626_check_dio_interrupts(dev);
+		s626_check_counter_interrupts(dev);
 		break;
 	}
 
@@ -1606,7 +1617,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 /*
  * This function builds the RPS program for hardware driven acquisition.
  */
-static void reset_adc(struct comedi_device *dev, uint8_t *ppl)
+static void s626_reset_adc(struct comedi_device *dev, uint8_t *ppl)
 {
 	struct s626_private *devpriv = dev->private;
 	uint32_t *rps;
@@ -1856,10 +1867,10 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 		adc_spec = (chan << 8) | (GSEL_BIPOLAR10V);
 
 	/* Switch ADC analog gain. */
-	debi_write(dev, LP_GSEL, adc_spec);	/* Set gain. */
+	s626_debi_write(dev, LP_GSEL, adc_spec);	/* Set gain. */
 
 	/* Select ADC analog input channel. */
-	debi_write(dev, LP_ISEL, adc_spec);	/* Select channel. */
+	s626_debi_write(dev, LP_ISEL, adc_spec);	/* Select channel. */
 
 	for (n = 0; n < insn->n; n++) {
 		/* Delay 10 microseconds for analog input settling. */
@@ -2010,7 +2021,7 @@ static void s626_timer_load(struct comedi_device *dev,
 	k->set_mode(dev, k, setup, false);
 
 	/* Set the preload register */
-	preload(dev, k, tick);
+	s626_preload(dev, k, tick);
 
 	/*
 	 * Software index pulse forces the preload register to load
@@ -2025,7 +2036,7 @@ static void s626_timer_load(struct comedi_device *dev,
 	/* set interrupt on overflow */
 	k->set_int_src(dev, k, INTSRC_OVER);
 
-	set_latch_source(dev, k, value_latchsrc);
+	s626_set_latch_source(dev, k, value_latchsrc);
 	/* k->set_enable(dev, k, (uint16_t)(enab != 0)); */
 }
 
@@ -2130,7 +2141,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	}
 
-	reset_adc(dev, ppl);
+	s626_reset_adc(dev, ppl);
 
 	switch (cmd->start_src) {
 	case TRIG_NOW:
@@ -2291,7 +2302,7 @@ static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		devpriv->ao_readback[CR_CHAN(insn->chanspec)] = data[i];
 		dacdata -= (0x1fff);
 
-		set_dac(dev, chan, dacdata);
+		s626_set_dac(dev, chan, dacdata);
 	}
 
 	return i;
@@ -2322,18 +2333,18 @@ static void s626_dio_init(struct comedi_device *dev)
 	uint16_t group;
 
 	/* Prepare to treat writes to WRCapSel as capture disables. */
-	debi_write(dev, LP_MISC1, MISC1_NOEDCAP);
+	s626_debi_write(dev, LP_MISC1, MISC1_NOEDCAP);
 
 	/* For each group of sixteen channels ... */
 	for (group = 0; group < S626_DIO_BANKS; group++) {
 		/* Disable all interrupts */
-		debi_write(dev, LP_WRINTSEL(group), 0);
+		s626_debi_write(dev, LP_WRINTSEL(group), 0);
 		/* Disable all event captures */
-		debi_write(dev, LP_WRCAPSEL(group), 0xffff);
+		s626_debi_write(dev, LP_WRCAPSEL(group), 0xffff);
 		/* Init all DIOs to default edge polarity */
-		debi_write(dev, LP_WREDGSEL(group), 0);
+		s626_debi_write(dev, LP_WREDGSEL(group), 0);
 		/* Program all outputs to inactive state */
-		debi_write(dev, LP_WRDOUT(group), 0);
+		s626_debi_write(dev, LP_WRDOUT(group), 0);
 	}
 }
 
@@ -2345,9 +2356,9 @@ static int s626_dio_insn_bits(struct comedi_device *dev,
 	unsigned long group = (unsigned long)s->private;
 
 	if (comedi_dio_update_state(s, data))
-		debi_write(dev, LP_WRDOUT(group), s->state);
+		s626_debi_write(dev, LP_WRDOUT(group), s->state);
 
-	data[1] = debi_read(dev, LP_RDDIN(group));
+	data[1] = s626_debi_read(dev, LP_RDDIN(group));
 
 	return insn->n;
 }
@@ -2364,7 +2375,7 @@ static int s626_dio_insn_config(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	debi_write(dev, LP_WRDOUT(group), s->io_bits);
+	s626_debi_write(dev, LP_WRDOUT(group), s->io_bits);
 
 	return insn->n;
 }
@@ -2399,9 +2410,9 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 	/* (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
 	k->set_mode(dev, k, setup, true);
-	preload(dev, k, data[0]);
+	s626_preload(dev, k, data[0]);
 	k->pulse_index(dev, k);
-	set_latch_source(dev, k, value_latchsrc);
+	s626_set_latch_source(dev, k, value_latchsrc);
 	k->set_enable(dev, k, (enab != 0));
 
 	return insn->n;
@@ -2416,7 +2427,7 @@ static int s626_enc_insn_read(struct comedi_device *dev,
 		&s626_enc_chan_info[CR_CHAN(insn->chanspec)];
 
 	for (n = 0; n < insn->n; n++)
-		data[n] = read_latch(dev, k);
+		data[n] = s626_read_latch(dev, k);
 
 	return n;
 }
@@ -2429,7 +2440,7 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 		&s626_enc_chan_info[CR_CHAN(insn->chanspec)];
 
 	/* Set the preload register */
-	preload(dev, k, data[0]);
+	s626_preload(dev, k, data[0]);
 
 	/*
 	 * Software index pulse forces the preload register to load
@@ -2442,15 +2453,15 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 	return 1;
 }
 
-static void write_misc2(struct comedi_device *dev, uint16_t new_image)
+static void s626_write_misc2(struct comedi_device *dev, uint16_t new_image)
 {
-	debi_write(dev, LP_MISC1, MISC1_WENABLE); /* Enable writes to MISC2. */
-	debi_write(dev, LP_WRMISC2, new_image);	/* Write new image to MISC2. */
-	debi_write(dev, LP_MISC1, MISC1_WDISABLE); /* Disable writes to MISC2 */
+	s626_debi_write(dev, LP_MISC1, MISC1_WENABLE);
+	s626_debi_write(dev, LP_WRMISC2, new_image);
+	s626_debi_write(dev, LP_MISC1, MISC1_WDISABLE);
 }
 
-static void close_dma_b(struct comedi_device *dev, struct s626_buffer_dma *pdma,
-			size_t bsize)
+static void s626_close_dma_b(struct comedi_device *dev,
+			     struct s626_buffer_dma *pdma, size_t bsize)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	void *vbptr;
@@ -2469,7 +2480,7 @@ static void close_dma_b(struct comedi_device *dev, struct s626_buffer_dma *pdma,
 	}
 }
 
-static void counters_init(struct comedi_device *dev)
+static void s626_counters_init(struct comedi_device *dev)
 {
 	int chan;
 	const struct s626_enc_info *k;
@@ -2617,7 +2628,7 @@ static void s626_initialize(struct comedi_device *dev)
 
 		/* Create a simple polling list for analog input channel 0 */
 		poll_list = EOPL;
-		reset_adc(dev, &poll_list);
+		s626_reset_adc(dev, &poll_list);
 
 		/* Get initial ADC value */
 		s626_ai_rinsn(dev, dev->subdevices, NULL, data);
@@ -2715,8 +2726,8 @@ static void s626_initialize(struct comedi_device *dev)
 	 * SAA7146 audio channel does not always reset properly and
 	 * sometimes causes the first few TrimDAC writes to malfunction.
 	 */
-	load_trim_dacs(dev);
-	load_trim_dacs(dev);
+	s626_load_trim_dacs(dev);
+	s626_load_trim_dacs(dev);
 
 	/*
 	 * Manually init all gate array hardware in case this is a soft
@@ -2731,10 +2742,10 @@ static void s626_initialize(struct comedi_device *dev)
 	 * polarity images.
 	 */
 	for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
-		set_dac(dev, chan, 0);
+		s626_set_dac(dev, chan, 0);
 
 	/* Init counters */
-	counters_init(dev);
+	s626_counters_init(dev);
 
 	/*
 	 * Without modifying the state of the Battery Backup enab, disable
@@ -2742,8 +2753,8 @@ static void s626_initialize(struct comedi_device *dev)
 	 * standard DIO (vs. counter overflow) mode, disable the battery
 	 * charger, and reset the watchdog interval selector to zero.
 	 */
-	write_misc2(dev, (uint16_t)(debi_read(dev, LP_RDMISC2) &
-				    MISC2_BATT_ENABLE));
+	s626_write_misc2(dev, (s626_debi_read(dev, LP_RDMISC2) &
+			       MISC2_BATT_ENABLE));
 
 	/* Initialize the digital I/O subsystem */
 	s626_dio_init(dev);
@@ -2890,14 +2901,14 @@ static void s626_detach(struct comedi_device *dev)
 			       devpriv->mmio + P_ISR);
 
 			/* Disable the watchdog timer and battery charger. */
-			write_misc2(dev, 0);
+			s626_write_misc2(dev, 0);
 
 			/* Close all interfaces on 7146 device */
 			writel(MC1_SHUTDOWN, devpriv->mmio + P_MC1);
 			writel(ACON1_BASE, devpriv->mmio + P_ACON1);
 
-			close_dma_b(dev, &devpriv->rps_buf, DMABUF_SIZE);
-			close_dma_b(dev, &devpriv->ana_buf, DMABUF_SIZE);
+			s626_close_dma_b(dev, &devpriv->rps_buf, DMABUF_SIZE);
+			s626_close_dma_b(dev, &devpriv->ana_buf, DMABUF_SIZE);
 		}
 
 		if (dev->irq)

commit dbb263f5bd685c1794b065a34bf3d9e6a0b5f8de
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:39 2013 +0100

    staging: comedi: s626: rename struct buffer_dma
    
    Re-tag `struct buffer_dma` to `struct s626_buffer_dma` to avoid
    potential namespace clashes.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 34c4eb0a44f2..3d476e32f38c 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -71,7 +71,7 @@
 #include "comedi_fc.h"
 #include "s626.h"
 
-struct buffer_dma {
+struct s626_buffer_dma {
 	dma_addr_t physical_base;
 	void *logical_base;
 };
@@ -89,9 +89,9 @@ struct s626_private {
 	uint16_t counter_int_enabs;	/* counter interrupt enable mask
 					 * for MISC2 register */
 	uint8_t adc_items;		/* number of items in ADC poll list */
-	struct buffer_dma rps_buf;	/* DMA buffer used to hold ADC (RPS1)
+	struct s626_buffer_dma rps_buf;	/* DMA buffer used to hold ADC (RPS1)
 					 * program */
-	struct buffer_dma ana_buf;	/* DMA buffer used to receive ADC data
+	struct s626_buffer_dma ana_buf;	/* DMA buffer used to receive ADC data
 					 * and hold DAC data */
 	uint32_t *dac_wbuf;		/* pointer to logical adrs of DMA buffer
 					 * used to hold DAC data */
@@ -2449,7 +2449,7 @@ static void write_misc2(struct comedi_device *dev, uint16_t new_image)
 	debi_write(dev, LP_MISC1, MISC1_WDISABLE); /* Disable writes to MISC2 */
 }
 
-static void close_dma_b(struct comedi_device *dev, struct buffer_dma *pdma,
+static void close_dma_b(struct comedi_device *dev, struct s626_buffer_dma *pdma,
 			size_t bsize)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);

commit 8e06d662871c0e13f856d9e30bdd2693032fb136
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:38 2013 +0100

    staging: comedi: s626: move struct buffer_dma
    
    Move the declaration of `struct buffer_dma` from "s626.h" to "s626.c" as
    it seems more at home there.  After this move, "s626.h" just contains
    macros related to hardware registers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 529ba3194adf..34c4eb0a44f2 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -71,6 +71,11 @@
 #include "comedi_fc.h"
 #include "s626.h"
 
+struct buffer_dma {
+	dma_addr_t physical_base;
+	void *logical_base;
+};
+
 struct s626_private {
 	void __iomem *mmio;
 	uint8_t ai_cmd_running;		/* ai_cmd is running */

commit a3ae88f83b21126540fff0ae39fd2b641ce9709a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:37 2013 +0100

    staging: comedi: s626: make trimchan[] and trimadrs[] const
    
    Declare the static variables `trimchan[]` and `trimadrs[]` as constant
    data.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 7c51754d8a79..529ba3194adf 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -339,10 +339,10 @@ static uint8_t i2c_read(struct comedi_device *dev, uint8_t addr)
 /* Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
 
 /* TrimDac LogicalChan-to-PhysicalChan mapping table. */
-static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
+static const uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 
 /* TrimDac LogicalChan-to-EepromAdrs mapping table. */
-static uint8_t trimadrs[] = {
+static const uint8_t trimadrs[] = {
 	0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63
 };
 

commit bb49cddc02697b2e9d9c849488833055998ec863
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:36 2013 +0100

    staging: comedi: s626: add mmiowb() calls
    
    `s626_mc_enable()` is often called to enable some function in a control
    register after setting up some other registers.  Precede the write to
    the control register with a call to `mmiowb()` to preserve mmio write
    ordering.
    
    `s626_mc_disable()` is called to disable some function in a control
    register and is often followed up by writes to other registers.  Follow
    the write to the control register with a call to `mmiowb()` to preserve
    mmio write ordering.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 733e62ba7984..7c51754d8a79 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -161,6 +161,7 @@ static void s626_mc_enable(struct comedi_device *dev,
 	struct s626_private *devpriv = dev->private;
 	unsigned int val = (cmd << 16) | cmd;
 
+	mmiowb();
 	writel(val, devpriv->mmio + reg);
 }
 
@@ -170,6 +171,7 @@ static void s626_mc_disable(struct comedi_device *dev,
 	struct s626_private *devpriv = dev->private;
 
 	writel(cmd << 16 , devpriv->mmio + reg);
+	mmiowb();
 }
 
 static bool s626_mc_test(struct comedi_device *dev,

commit c3e3a56d40c451271b1be4d6d3ec3b62af879228
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:35 2013 +0100

    staging: comedi: s626: remove TRUE and FALSE macros
    
    "s626.h" defines the macros `TRUE` and `FALSE` if they are not already
    defined, yielding the expected numeric values.  Remove the macros and
    replace their usage with the values `true` and `false`, respectively.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 9216e9a02b25..733e62ba7984 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1098,7 +1098,7 @@ static void set_clk_mult(struct comedi_device *dev,
 			 const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKMULT) |
-			    (value << STDBIT_CLKMULT)), FALSE);
+			    (value << STDBIT_CLKMULT)), false);
 }
 
 static uint16_t get_clk_mult(struct comedi_device *dev,
@@ -1114,7 +1114,7 @@ static void set_clk_pol(struct comedi_device *dev,
 			const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKPOL) |
-			    (value << STDBIT_CLKPOL)), FALSE);
+			    (value << STDBIT_CLKPOL)), false);
 }
 
 static uint16_t get_clk_pol(struct comedi_device *dev,
@@ -1130,7 +1130,7 @@ static void set_clk_src(struct comedi_device *dev,
 			const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKSRC) |
-			    (value << STDBIT_CLKSRC)), FALSE);
+			    (value << STDBIT_CLKSRC)), false);
 }
 
 static uint16_t get_clk_src(struct comedi_device *dev,
@@ -1146,7 +1146,7 @@ static void set_index_pol(struct comedi_device *dev,
 			  const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXPOL) |
-			    ((value != 0) << STDBIT_INDXPOL)), FALSE);
+			    ((value != 0) << STDBIT_INDXPOL)), false);
 }
 
 static uint16_t get_index_pol(struct comedi_device *dev,
@@ -1162,7 +1162,7 @@ static void set_index_src(struct comedi_device *dev,
 			  const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXSRC) |
-			    ((value != 0) << STDBIT_INDXSRC)), FALSE);
+			    ((value != 0) << STDBIT_INDXSRC)), false);
 }
 
 static uint16_t get_index_src(struct comedi_device *dev,
@@ -2000,7 +2000,7 @@ static void s626_timer_load(struct comedi_device *dev,
 	uint16_t value_latchsrc = LATCHSRC_A_INDXA;
 	/* uint16_t enab = CLKENAB_ALWAYS; */
 
-	k->set_mode(dev, k, setup, FALSE);
+	k->set_mode(dev, k, setup, false);
 
 	/* Set the preload register */
 	preload(dev, k, tick);
@@ -2382,7 +2382,7 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 		(CLKPOL_POS << BF_CLKPOL) |	/* Active high clock. */
 		(CLKMULT_1X << BF_CLKMULT) |	/* Clock multiplier is 1x. */
 		(CLKENAB_INDEX << BF_CLKENAB);
-	/* uint16_t disable_int_src = TRUE; */
+	/* uint16_t disable_int_src = true; */
 	/* uint32_t Preloadvalue;              //Counter initial value */
 	uint16_t value_latchsrc = LATCHSRC_AB_READ;
 	uint16_t enab = CLKENAB_ALWAYS;
@@ -2391,7 +2391,7 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 
 	/* (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
-	k->set_mode(dev, k, setup, TRUE);
+	k->set_mode(dev, k, setup, true);
 	preload(dev, k, data[0]);
 	k->pulse_index(dev, k);
 	set_latch_source(dev, k, value_latchsrc);
@@ -2480,7 +2480,7 @@ static void counters_init(struct comedi_device *dev)
 	 */
 	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
 		k = &s626_enc_chan_info[chan];
-		k->set_mode(dev, k, setup, TRUE);
+		k->set_mode(dev, k, setup, true);
 		k->set_int_src(dev, k, 0);
 		k->reset_cap_flags(dev, k);
 		k->set_enable(dev, k, CLKENAB_ALWAYS);

commit 3f1f219ce1f814976a3e435b4e6fa963252d7581
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:34 2013 +0100

    staging: comedi: s626: move s626_enc_chan_info[]
    
    Move `s626_enc_chan_info[]` and remove its forward declaration.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 05c856c725c9..9216e9a02b25 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -139,8 +139,6 @@ struct s626_enc_info {
 	uint16_t my_event_bits[4]; /* bit translations for IntSrc -->RDMISC2 */
 };
 
-static const struct s626_enc_info s626_enc_chan_info[];
-
 /* Counter overflow/index event flag masks for RDMISC2. */
 #define INDXMASK(C)	(1 << (((C) > 2) ? ((C) * 2 - 1) : ((C) * 2 +  4)))
 #define OVERMASK(C)	(1 << (((C) > 2) ? ((C) * 2 + 5) : ((C) * 2 + 10)))
@@ -1199,6 +1197,100 @@ static void pulse_index_b(struct comedi_device *dev,
 	debi_write(dev, k->my_crb, crb);
 }
 
+static const struct s626_enc_info s626_enc_chan_info[] = {
+	{
+		.get_enable		= get_enable_a,
+		.get_int_src		= get_int_src_a,
+		.get_load_trig		= get_load_trig_a,
+		.get_mode		= get_mode_a,
+		.pulse_index		= pulse_index_a,
+		.set_enable		= set_enable_a,
+		.set_int_src		= set_int_src_a,
+		.set_load_trig		= set_load_trig_a,
+		.set_mode		= set_mode_a,
+		.reset_cap_flags	= reset_cap_flags_a,
+		.my_cra			= LP_CR0A,
+		.my_crb			= LP_CR0B,
+		.my_latch_lsw		= LP_CNTR0ALSW,
+		.my_event_bits		= EVBITS(0),
+	}, {
+		.get_enable		= get_enable_a,
+		.get_int_src		= get_int_src_a,
+		.get_load_trig		= get_load_trig_a,
+		.get_mode		= get_mode_a,
+		.pulse_index		= pulse_index_a,
+		.set_enable		= set_enable_a,
+		.set_int_src		= set_int_src_a,
+		.set_load_trig		= set_load_trig_a,
+		.set_mode		= set_mode_a,
+		.reset_cap_flags	= reset_cap_flags_a,
+		.my_cra			= LP_CR1A,
+		.my_crb			= LP_CR1B,
+		.my_latch_lsw		= LP_CNTR1ALSW,
+		.my_event_bits		= EVBITS(1),
+	}, {
+		.get_enable		= get_enable_a,
+		.get_int_src		= get_int_src_a,
+		.get_load_trig		= get_load_trig_a,
+		.get_mode		= get_mode_a,
+		.pulse_index		= pulse_index_a,
+		.set_enable		= set_enable_a,
+		.set_int_src		= set_int_src_a,
+		.set_load_trig		= set_load_trig_a,
+		.set_mode		= set_mode_a,
+		.reset_cap_flags	= reset_cap_flags_a,
+		.my_cra			= LP_CR2A,
+		.my_crb			= LP_CR2B,
+		.my_latch_lsw		= LP_CNTR2ALSW,
+		.my_event_bits		= EVBITS(2),
+	}, {
+		.get_enable		= get_enable_b,
+		.get_int_src		= get_int_src_b,
+		.get_load_trig		= get_load_trig_b,
+		.get_mode		= get_mode_b,
+		.pulse_index		= pulse_index_b,
+		.set_enable		= set_enable_b,
+		.set_int_src		= set_int_src_b,
+		.set_load_trig		= set_load_trig_b,
+		.set_mode		= set_mode_b,
+		.reset_cap_flags	= reset_cap_flags_b,
+		.my_cra			= LP_CR0A,
+		.my_crb			= LP_CR0B,
+		.my_latch_lsw		= LP_CNTR0BLSW,
+		.my_event_bits		= EVBITS(3),
+	}, {
+		.get_enable		= get_enable_b,
+		.get_int_src		= get_int_src_b,
+		.get_load_trig		= get_load_trig_b,
+		.get_mode		= get_mode_b,
+		.pulse_index		= pulse_index_b,
+		.set_enable		= set_enable_b,
+		.set_int_src		= set_int_src_b,
+		.set_load_trig		= set_load_trig_b,
+		.set_mode		= set_mode_b,
+		.reset_cap_flags	= reset_cap_flags_b,
+		.my_cra			= LP_CR1A,
+		.my_crb			= LP_CR1B,
+		.my_latch_lsw		= LP_CNTR1BLSW,
+		.my_event_bits		= EVBITS(4),
+	}, {
+		.get_enable		= get_enable_b,
+		.get_int_src		= get_int_src_b,
+		.get_load_trig		= get_load_trig_b,
+		.get_mode		= get_mode_b,
+		.pulse_index		= pulse_index_b,
+		.set_enable		= set_enable_b,
+		.set_int_src		= set_int_src_b,
+		.set_load_trig		= set_load_trig_b,
+		.set_mode		= set_mode_b,
+		.reset_cap_flags	= reset_cap_flags_b,
+		.my_cra			= LP_CR2A,
+		.my_crb			= LP_CR2B,
+		.my_latch_lsw		= LP_CNTR2BLSW,
+		.my_event_bits		= EVBITS(5),
+	},
+};
+
 static unsigned int s626_ai_reg_to_uint(int data)
 {
 	unsigned int tempdata;
@@ -2370,100 +2462,6 @@ static void close_dma_b(struct comedi_device *dev, struct buffer_dma *pdma,
 	}
 }
 
-static const struct s626_enc_info s626_enc_chan_info[] = {
-	{
-		.get_enable		= get_enable_a,
-		.get_int_src		= get_int_src_a,
-		.get_load_trig		= get_load_trig_a,
-		.get_mode		= get_mode_a,
-		.pulse_index		= pulse_index_a,
-		.set_enable		= set_enable_a,
-		.set_int_src		= set_int_src_a,
-		.set_load_trig		= set_load_trig_a,
-		.set_mode		= set_mode_a,
-		.reset_cap_flags	= reset_cap_flags_a,
-		.my_cra			= LP_CR0A,
-		.my_crb			= LP_CR0B,
-		.my_latch_lsw		= LP_CNTR0ALSW,
-		.my_event_bits		= EVBITS(0),
-	}, {
-		.get_enable		= get_enable_a,
-		.get_int_src		= get_int_src_a,
-		.get_load_trig		= get_load_trig_a,
-		.get_mode		= get_mode_a,
-		.pulse_index		= pulse_index_a,
-		.set_enable		= set_enable_a,
-		.set_int_src		= set_int_src_a,
-		.set_load_trig		= set_load_trig_a,
-		.set_mode		= set_mode_a,
-		.reset_cap_flags	= reset_cap_flags_a,
-		.my_cra			= LP_CR1A,
-		.my_crb			= LP_CR1B,
-		.my_latch_lsw		= LP_CNTR1ALSW,
-		.my_event_bits		= EVBITS(1),
-	}, {
-		.get_enable		= get_enable_a,
-		.get_int_src		= get_int_src_a,
-		.get_load_trig		= get_load_trig_a,
-		.get_mode		= get_mode_a,
-		.pulse_index		= pulse_index_a,
-		.set_enable		= set_enable_a,
-		.set_int_src		= set_int_src_a,
-		.set_load_trig		= set_load_trig_a,
-		.set_mode		= set_mode_a,
-		.reset_cap_flags	= reset_cap_flags_a,
-		.my_cra			= LP_CR2A,
-		.my_crb			= LP_CR2B,
-		.my_latch_lsw		= LP_CNTR2ALSW,
-		.my_event_bits		= EVBITS(2),
-	}, {
-		.get_enable		= get_enable_b,
-		.get_int_src		= get_int_src_b,
-		.get_load_trig		= get_load_trig_b,
-		.get_mode		= get_mode_b,
-		.pulse_index		= pulse_index_b,
-		.set_enable		= set_enable_b,
-		.set_int_src		= set_int_src_b,
-		.set_load_trig		= set_load_trig_b,
-		.set_mode		= set_mode_b,
-		.reset_cap_flags	= reset_cap_flags_b,
-		.my_cra			= LP_CR0A,
-		.my_crb			= LP_CR0B,
-		.my_latch_lsw		= LP_CNTR0BLSW,
-		.my_event_bits		= EVBITS(3),
-	}, {
-		.get_enable		= get_enable_b,
-		.get_int_src		= get_int_src_b,
-		.get_load_trig		= get_load_trig_b,
-		.get_mode		= get_mode_b,
-		.pulse_index		= pulse_index_b,
-		.set_enable		= set_enable_b,
-		.set_int_src		= set_int_src_b,
-		.set_load_trig		= set_load_trig_b,
-		.set_mode		= set_mode_b,
-		.reset_cap_flags	= reset_cap_flags_b,
-		.my_cra			= LP_CR1A,
-		.my_crb			= LP_CR1B,
-		.my_latch_lsw		= LP_CNTR1BLSW,
-		.my_event_bits		= EVBITS(4),
-	}, {
-		.get_enable		= get_enable_b,
-		.get_int_src		= get_int_src_b,
-		.get_load_trig		= get_load_trig_b,
-		.get_mode		= get_mode_b,
-		.pulse_index		= pulse_index_b,
-		.set_enable		= set_enable_b,
-		.set_int_src		= set_int_src_b,
-		.set_load_trig		= set_load_trig_b,
-		.set_mode		= set_mode_b,
-		.reset_cap_flags	= reset_cap_flags_b,
-		.my_cra			= LP_CR2A,
-		.my_crb			= LP_CR2B,
-		.my_latch_lsw		= LP_CNTR2BLSW,
-		.my_event_bits		= EVBITS(5),
-	},
-};
-
 static void counters_init(struct comedi_device *dev)
 {
 	int chan;

commit bc284a2aa5f255597e1c23e4d6daa9aa274fc290
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:33 2013 +0100

    staging: comedi: s626: move encoder functions part 3
    
    Move the final lot of encoder functions to help avoid the forward
    declaration of `s626_enc_chan_info[]`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 1af053619189..05c856c725c9 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1032,6 +1032,173 @@ static uint16_t get_load_trig_b(struct comedi_device *dev,
 	return (debi_read(dev, k->my_crb) >> CRBBIT_LOADSRC_B) & 3;
 }
 
+/*
+ * Return/set counter interrupt source and clear any captured
+ * index/overflow events.  int_source: 0=Disabled, 1=OverflowOnly,
+ * 2=IndexOnly, 3=IndexAndOverflow.
+ */
+static void set_int_src_a(struct comedi_device *dev,
+			  const struct s626_enc_info *k, uint16_t int_source)
+{
+	struct s626_private *devpriv = dev->private;
+
+	/* Reset any pending counter overflow or index captures. */
+	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
+		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+
+	/* Program counter interrupt source. */
+	debi_replace(dev, k->my_cra, ~CRAMSK_INTSRC_A,
+		     int_source << CRABIT_INTSRC_A);
+
+	/* Update MISC2 interrupt enable mask. */
+	devpriv->counter_int_enabs =
+	    (devpriv->counter_int_enabs & ~k->my_event_bits[3]) |
+	    k->my_event_bits[int_source];
+}
+
+static void set_int_src_b(struct comedi_device *dev,
+			  const struct s626_enc_info *k, uint16_t int_source)
+{
+	struct s626_private *devpriv = dev->private;
+	uint16_t crb;
+
+	/* Cache writeable CRB register image. */
+	crb = debi_read(dev, k->my_crb) & ~CRBMSK_INTCTRL;
+
+	/* Reset any pending counter overflow or index captures. */
+	debi_write(dev, k->my_crb,
+		   (uint16_t)(crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
+
+	/* Program counter interrupt source. */
+	debi_write(dev, k->my_crb,
+		   (uint16_t)((crb & ~CRBMSK_INTSRC_B) |
+			      (int_source << CRBBIT_INTSRC_B)));
+
+	/* Update MISC2 interrupt enable mask. */
+	devpriv->counter_int_enabs =
+		(devpriv->counter_int_enabs & ~k->my_event_bits[3]) |
+		k->my_event_bits[int_source];
+}
+
+static uint16_t get_int_src_a(struct comedi_device *dev,
+			      const struct s626_enc_info *k)
+{
+	return (debi_read(dev, k->my_cra) >> CRABIT_INTSRC_A) & 3;
+}
+
+static uint16_t get_int_src_b(struct comedi_device *dev,
+			      const struct s626_enc_info *k)
+{
+	return (debi_read(dev, k->my_crb) >> CRBBIT_INTSRC_B) & 3;
+}
+
+#ifdef unused
+/*
+ * Return/set the clock multiplier.
+ */
+static void set_clk_mult(struct comedi_device *dev,
+			 const struct s626_enc_info *k, uint16_t value)
+{
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKMULT) |
+			    (value << STDBIT_CLKMULT)), FALSE);
+}
+
+static uint16_t get_clk_mult(struct comedi_device *dev,
+			     const struct s626_enc_info *k)
+{
+	return (k->get_mode(dev, k) >> STDBIT_CLKMULT) & 3;
+}
+
+/*
+ * Return/set the clock polarity.
+ */
+static void set_clk_pol(struct comedi_device *dev,
+			const struct s626_enc_info *k, uint16_t value)
+{
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKPOL) |
+			    (value << STDBIT_CLKPOL)), FALSE);
+}
+
+static uint16_t get_clk_pol(struct comedi_device *dev,
+			    const struct s626_enc_info *k)
+{
+	return (k->get_mode(dev, k) >> STDBIT_CLKPOL) & 1;
+}
+
+/*
+ * Return/set the clock source.
+ */
+static void set_clk_src(struct comedi_device *dev,
+			const struct s626_enc_info *k, uint16_t value)
+{
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKSRC) |
+			    (value << STDBIT_CLKSRC)), FALSE);
+}
+
+static uint16_t get_clk_src(struct comedi_device *dev,
+			    const struct s626_enc_info *k)
+{
+	return (k->get_mode(dev, k) >> STDBIT_CLKSRC) & 3;
+}
+
+/*
+ * Return/set the index polarity.
+ */
+static void set_index_pol(struct comedi_device *dev,
+			  const struct s626_enc_info *k, uint16_t value)
+{
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXPOL) |
+			    ((value != 0) << STDBIT_INDXPOL)), FALSE);
+}
+
+static uint16_t get_index_pol(struct comedi_device *dev,
+			      const struct s626_enc_info *k)
+{
+	return (k->get_mode(dev, k) >> STDBIT_INDXPOL) & 1;
+}
+
+/*
+ * Return/set the index source.
+ */
+static void set_index_src(struct comedi_device *dev,
+			  const struct s626_enc_info *k, uint16_t value)
+{
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXSRC) |
+			    ((value != 0) << STDBIT_INDXSRC)), FALSE);
+}
+
+static uint16_t get_index_src(struct comedi_device *dev,
+			      const struct s626_enc_info *k)
+{
+	return (k->get_mode(dev, k) >> STDBIT_INDXSRC) & 1;
+}
+#endif
+
+/*
+ * Generate an index pulse.
+ */
+static void pulse_index_a(struct comedi_device *dev,
+			  const struct s626_enc_info *k)
+{
+	uint16_t cra;
+
+	cra = debi_read(dev, k->my_cra);
+	/* Pulse index. */
+	debi_write(dev, k->my_cra, (cra ^ CRAMSK_INDXPOL_A));
+	debi_write(dev, k->my_cra, cra);
+}
+
+static void pulse_index_b(struct comedi_device *dev,
+			  const struct s626_enc_info *k)
+{
+	uint16_t crb;
+
+	crb = debi_read(dev, k->my_crb) & ~CRBMSK_INTCTRL;
+	/* Pulse index. */
+	debi_write(dev, k->my_crb, (crb ^ CRBMSK_INDXPOL_B));
+	debi_write(dev, k->my_crb, crb);
+}
+
 static unsigned int s626_ai_reg_to_uint(int data)
 {
 	unsigned int tempdata;
@@ -2203,173 +2370,6 @@ static void close_dma_b(struct comedi_device *dev, struct buffer_dma *pdma,
 	}
 }
 
-/*
- * Return/set counter interrupt source and clear any captured
- * index/overflow events.  int_source: 0=Disabled, 1=OverflowOnly,
- * 2=IndexOnly, 3=IndexAndOverflow.
- */
-static void set_int_src_a(struct comedi_device *dev,
-			  const struct s626_enc_info *k, uint16_t int_source)
-{
-	struct s626_private *devpriv = dev->private;
-
-	/* Reset any pending counter overflow or index captures. */
-	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
-		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
-
-	/* Program counter interrupt source. */
-	debi_replace(dev, k->my_cra, ~CRAMSK_INTSRC_A,
-		     int_source << CRABIT_INTSRC_A);
-
-	/* Update MISC2 interrupt enable mask. */
-	devpriv->counter_int_enabs =
-	    (devpriv->counter_int_enabs & ~k->my_event_bits[3]) |
-	    k->my_event_bits[int_source];
-}
-
-static void set_int_src_b(struct comedi_device *dev,
-			  const struct s626_enc_info *k, uint16_t int_source)
-{
-	struct s626_private *devpriv = dev->private;
-	uint16_t crb;
-
-	/* Cache writeable CRB register image. */
-	crb = debi_read(dev, k->my_crb) & ~CRBMSK_INTCTRL;
-
-	/* Reset any pending counter overflow or index captures. */
-	debi_write(dev, k->my_crb,
-		   (uint16_t)(crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
-
-	/* Program counter interrupt source. */
-	debi_write(dev, k->my_crb,
-		   (uint16_t)((crb & ~CRBMSK_INTSRC_B) |
-			      (int_source << CRBBIT_INTSRC_B)));
-
-	/* Update MISC2 interrupt enable mask. */
-	devpriv->counter_int_enabs =
-		(devpriv->counter_int_enabs & ~k->my_event_bits[3]) |
-		k->my_event_bits[int_source];
-}
-
-static uint16_t get_int_src_a(struct comedi_device *dev,
-			      const struct s626_enc_info *k)
-{
-	return (debi_read(dev, k->my_cra) >> CRABIT_INTSRC_A) & 3;
-}
-
-static uint16_t get_int_src_b(struct comedi_device *dev,
-			      const struct s626_enc_info *k)
-{
-	return (debi_read(dev, k->my_crb) >> CRBBIT_INTSRC_B) & 3;
-}
-
-#ifdef unused
-/*
- * Return/set the clock multiplier.
- */
-static void set_clk_mult(struct comedi_device *dev,
-			 const struct s626_enc_info *k, uint16_t value)
-{
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKMULT) |
-			    (value << STDBIT_CLKMULT)), FALSE);
-}
-
-static uint16_t get_clk_mult(struct comedi_device *dev,
-			     const struct s626_enc_info *k)
-{
-	return (k->get_mode(dev, k) >> STDBIT_CLKMULT) & 3;
-}
-
-/*
- * Return/set the clock polarity.
- */
-static void set_clk_pol(struct comedi_device *dev,
-			const struct s626_enc_info *k, uint16_t value)
-{
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKPOL) |
-			    (value << STDBIT_CLKPOL)), FALSE);
-}
-
-static uint16_t get_clk_pol(struct comedi_device *dev,
-			    const struct s626_enc_info *k)
-{
-	return (k->get_mode(dev, k) >> STDBIT_CLKPOL) & 1;
-}
-
-/*
- * Return/set the clock source.
- */
-static void set_clk_src(struct comedi_device *dev,
-			const struct s626_enc_info *k, uint16_t value)
-{
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKSRC) |
-			    (value << STDBIT_CLKSRC)), FALSE);
-}
-
-static uint16_t get_clk_src(struct comedi_device *dev,
-			    const struct s626_enc_info *k)
-{
-	return (k->get_mode(dev, k) >> STDBIT_CLKSRC) & 3;
-}
-
-/*
- * Return/set the index polarity.
- */
-static void set_index_pol(struct comedi_device *dev,
-			  const struct s626_enc_info *k, uint16_t value)
-{
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXPOL) |
-			    ((value != 0) << STDBIT_INDXPOL)), FALSE);
-}
-
-static uint16_t get_index_pol(struct comedi_device *dev,
-			      const struct s626_enc_info *k)
-{
-	return (k->get_mode(dev, k) >> STDBIT_INDXPOL) & 1;
-}
-
-/*
- * Return/set the index source.
- */
-static void set_index_src(struct comedi_device *dev,
-			  const struct s626_enc_info *k, uint16_t value)
-{
-	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXSRC) |
-			    ((value != 0) << STDBIT_INDXSRC)), FALSE);
-}
-
-static uint16_t get_index_src(struct comedi_device *dev,
-			      const struct s626_enc_info *k)
-{
-	return (k->get_mode(dev, k) >> STDBIT_INDXSRC) & 1;
-}
-#endif
-
-/*
- * Generate an index pulse.
- */
-static void pulse_index_a(struct comedi_device *dev,
-			  const struct s626_enc_info *k)
-{
-	uint16_t cra;
-
-	cra = debi_read(dev, k->my_cra);
-	/* Pulse index. */
-	debi_write(dev, k->my_cra, (cra ^ CRAMSK_INDXPOL_A));
-	debi_write(dev, k->my_cra, cra);
-}
-
-static void pulse_index_b(struct comedi_device *dev,
-			  const struct s626_enc_info *k)
-{
-	uint16_t crb;
-
-	crb = debi_read(dev, k->my_crb) & ~CRBMSK_INTCTRL;
-	/* Pulse index. */
-	debi_write(dev, k->my_crb, (crb ^ CRBMSK_INDXPOL_B));
-	debi_write(dev, k->my_crb, crb);
-}
-
 static const struct s626_enc_info s626_enc_chan_info[] = {
 	{
 		.get_enable		= get_enable_a,

commit 17afeac2fd33d6e438e43736659f5e60ec4857a9
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:32 2013 +0100

    staging: comedi: s626: move encoder functions part 2
    
    Move some more functions to help avoid the forward declaration of
    `s626_enc_chan_info[]`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 17a0cd7a7786..1af053619189 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -793,6 +793,245 @@ static uint16_t get_mode_b(struct comedi_device *dev,
 	return setup;
 }
 
+/*
+ * Set the operating mode for the specified counter.  The setup
+ * parameter is treated as a COUNTER_SETUP data type.  The following
+ * parameters are programmable (all other parms are ignored): ClkMult,
+ * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
+ */
+static void set_mode_a(struct comedi_device *dev, const struct s626_enc_info *k,
+		       uint16_t setup, uint16_t disable_int_src)
+{
+	struct s626_private *devpriv = dev->private;
+	uint16_t cra;
+	uint16_t crb;
+
+	/* Initialize CRA and CRB images. */
+	/* Preload trigger is passed through. */
+	cra = setup & CRAMSK_LOADSRC_A;
+	/* IndexSrc is restricted to ENC_X or IndxPol. */
+	cra |= ((setup & STDMSK_INDXSRC) >>
+		(STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1)));
+
+	/* Reset any pending CounterA event captures. */
+	crb = CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A;
+	/* Clock enable is passed through. */
+	crb |= (setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB);
+
+	/* Force IntSrc to Disabled if disable_int_src is asserted. */
+	if (!disable_int_src)
+		cra |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
+						    CRABIT_INTSRC_A));
+
+	/* Populate all mode-dependent attributes of CRA & CRB images. */
+	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
+	case CLKSRC_EXTENDER:	/* Extender Mode: Force to Timer mode
+				 * (Extender valid only for B counters). */
+		/* Fall through to case CLKSRC_TIMER: */
+	case CLKSRC_TIMER:	/* Timer Mode: */
+		/* ClkSrcA<1> selects system clock */
+		cra |= 2 << CRABIT_CLKSRC_A;
+		/* Count direction (ClkSrcA<0>) obtained from ClkPol. */
+		cra |= (setup & STDMSK_CLKPOL) >>
+		       (STDBIT_CLKPOL - CRABIT_CLKSRC_A);
+		/* ClkPolA behaves as always-on clock enable. */
+		cra |= 1 << CRABIT_CLKPOL_A;
+		/* ClkMult must be 1x. */
+		cra |= MULT_X1 << CRABIT_CLKMULT_A;
+		break;
+	default:		/* Counter Mode: */
+		/* Select ENC_C and ENC_D as clock/direction inputs. */
+		cra |= CLKSRC_COUNTER;
+		/* Clock polarity is passed through. */
+		cra |= (setup & STDMSK_CLKPOL) <<
+		       (CRABIT_CLKPOL_A - STDBIT_CLKPOL);
+		/* Force multiplier to x1 if not legal, else pass through. */
+		if ((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT))
+			cra |= MULT_X1 << CRABIT_CLKMULT_A;
+		else
+			cra |= (setup & STDMSK_CLKMULT) <<
+			       (CRABIT_CLKMULT_A - STDBIT_CLKMULT);
+		break;
+	}
+
+	/*
+	 * Force positive index polarity if IndxSrc is software-driven only,
+	 * otherwise pass it through.
+	 */
+	if (~setup & STDMSK_INDXSRC)
+		cra |= (setup & STDMSK_INDXPOL) <<
+		       (CRABIT_INDXPOL_A - STDBIT_INDXPOL);
+
+	/*
+	 * If IntSrc has been forced to Disabled, update the MISC2 interrupt
+	 * enable mask to indicate the counter interrupt is disabled.
+	 */
+	if (disable_int_src)
+		devpriv->counter_int_enabs &= ~k->my_event_bits[3];
+
+	/*
+	 * While retaining CounterB and LatchSrc configurations, program the
+	 * new counter operating mode.
+	 */
+	debi_replace(dev, k->my_cra, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
+	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A), crb);
+}
+
+static void set_mode_b(struct comedi_device *dev, const struct s626_enc_info *k,
+		       uint16_t setup, uint16_t disable_int_src)
+{
+	struct s626_private *devpriv = dev->private;
+	uint16_t cra;
+	uint16_t crb;
+
+	/* Initialize CRA and CRB images. */
+	/* IndexSrc field is restricted to ENC_X or IndxPol. */
+	cra = (setup & STDMSK_INDXSRC) <<
+	      (CRABIT_INDXSRC_B + 1 - STDBIT_INDXSRC);
+
+	/* Reset event captures and disable interrupts. */
+	crb = CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B;
+	/* Clock enable is passed through. */
+	crb |= (setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB);
+	/* Preload trigger source is passed through. */
+	crb |= (setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B);
+
+	/* Force IntSrc to Disabled if disable_int_src is asserted. */
+	if (!disable_int_src)
+		crb |= (setup & STDMSK_INTSRC) >>
+		       (STDBIT_INTSRC - CRBBIT_INTSRC_B);
+
+	/* Populate all mode-dependent attributes of CRA & CRB images. */
+	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
+	case CLKSRC_TIMER:	/* Timer Mode: */
+		/* ClkSrcB<1> selects system clock */
+		cra |= 2 << CRABIT_CLKSRC_B;
+		/* with direction (ClkSrcB<0>) obtained from ClkPol. */
+		cra |= (setup & STDMSK_CLKPOL) <<
+		       (CRABIT_CLKSRC_B - STDBIT_CLKPOL);
+		/* ClkPolB behaves as always-on clock enable. */
+		crb |= 1 << CRBBIT_CLKPOL_B;
+		/* ClkMultB must be 1x. */
+		crb |= MULT_X1 << CRBBIT_CLKMULT_B;
+		break;
+	case CLKSRC_EXTENDER:	/* Extender Mode: */
+		/* ClkSrcB source is OverflowA (same as "timer") */
+		cra |= 2 << CRABIT_CLKSRC_B;
+		/* with direction obtained from ClkPol. */
+		cra |= (setup & STDMSK_CLKPOL) <<
+		       (CRABIT_CLKSRC_B - STDBIT_CLKPOL);
+		/* ClkPolB controls IndexB -- always set to active. */
+		crb |= 1 << CRBBIT_CLKPOL_B;
+		/* ClkMultB selects OverflowA as the clock source. */
+		crb |= MULT_X0 << CRBBIT_CLKMULT_B;
+		break;
+	default:		/* Counter Mode: */
+		/* Select ENC_C and ENC_D as clock/direction inputs. */
+		cra |= CLKSRC_COUNTER << CRABIT_CLKSRC_B;
+		/* ClkPol is passed through. */
+		crb |= (setup & STDMSK_CLKPOL) >>
+		       (STDBIT_CLKPOL - CRBBIT_CLKPOL_B);
+		/* Force ClkMult to x1 if not legal, otherwise pass through. */
+		if ((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT))
+			crb |= MULT_X1 << CRBBIT_CLKMULT_B;
+		else
+			crb |= (setup & STDMSK_CLKMULT) <<
+			       (CRBBIT_CLKMULT_B - STDBIT_CLKMULT);
+		break;
+	}
+
+	/*
+	 * Force positive index polarity if IndxSrc is software-driven only,
+	 * otherwise pass it through.
+	 */
+	if (~setup & STDMSK_INDXSRC)
+		crb |= (setup & STDMSK_INDXPOL) >>
+		       (STDBIT_INDXPOL - CRBBIT_INDXPOL_B);
+
+	/*
+	 * If IntSrc has been forced to Disabled, update the MISC2 interrupt
+	 * enable mask to indicate the counter interrupt is disabled.
+	 */
+	if (disable_int_src)
+		devpriv->counter_int_enabs &= ~k->my_event_bits[3];
+
+	/*
+	 * While retaining CounterA and LatchSrc configurations, program the
+	 * new counter operating mode.
+	 */
+	debi_replace(dev, k->my_cra, ~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B),
+		     cra);
+	debi_replace(dev, k->my_crb, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
+}
+
+/*
+ * Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
+ */
+static void set_enable_a(struct comedi_device *dev,
+			 const struct s626_enc_info *k, uint16_t enab)
+{
+	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A),
+		     enab << CRBBIT_CLKENAB_A);
+}
+
+static void set_enable_b(struct comedi_device *dev,
+			 const struct s626_enc_info *k, uint16_t enab)
+{
+	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B),
+		     enab << CRBBIT_CLKENAB_B);
+}
+
+static uint16_t get_enable_a(struct comedi_device *dev,
+			     const struct s626_enc_info *k)
+{
+	return (debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_A) & 1;
+}
+
+static uint16_t get_enable_b(struct comedi_device *dev,
+			     const struct s626_enc_info *k)
+{
+	return (debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_B) & 1;
+}
+
+#ifdef unused
+static uint16_t get_latch_source(struct comedi_device *dev,
+				 const struct s626_enc_info *k)
+{
+	return (debi_read(dev, k->my_crb) >> CRBBIT_LATCHSRC) & 3;
+}
+#endif
+
+/*
+ * Return/set the event that will trigger transfer of the preload
+ * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
+ * 2=OverflowA (B counters only), 3=disabled.
+ */
+static void set_load_trig_a(struct comedi_device *dev,
+			    const struct s626_enc_info *k, uint16_t trig)
+{
+	debi_replace(dev, k->my_cra, ~CRAMSK_LOADSRC_A,
+		     trig << CRABIT_LOADSRC_A);
+}
+
+static void set_load_trig_b(struct comedi_device *dev,
+			    const struct s626_enc_info *k, uint16_t trig)
+{
+	debi_replace(dev, k->my_crb, ~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL),
+		     trig << CRBBIT_LOADSRC_B);
+}
+
+static uint16_t get_load_trig_a(struct comedi_device *dev,
+				const struct s626_enc_info *k)
+{
+	return (debi_read(dev, k->my_cra) >> CRABIT_LOADSRC_A) & 3;
+}
+
+static uint16_t get_load_trig_b(struct comedi_device *dev,
+				const struct s626_enc_info *k)
+{
+	return (debi_read(dev, k->my_crb) >> CRBBIT_LOADSRC_B) & 3;
+}
+
 static unsigned int s626_ai_reg_to_uint(int data)
 {
 	unsigned int tempdata;
@@ -1964,245 +2203,6 @@ static void close_dma_b(struct comedi_device *dev, struct buffer_dma *pdma,
 	}
 }
 
-/*
- * Set the operating mode for the specified counter.  The setup
- * parameter is treated as a COUNTER_SETUP data type.  The following
- * parameters are programmable (all other parms are ignored): ClkMult,
- * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
- */
-static void set_mode_a(struct comedi_device *dev, const struct s626_enc_info *k,
-		       uint16_t setup, uint16_t disable_int_src)
-{
-	struct s626_private *devpriv = dev->private;
-	uint16_t cra;
-	uint16_t crb;
-
-	/* Initialize CRA and CRB images. */
-	/* Preload trigger is passed through. */
-	cra = setup & CRAMSK_LOADSRC_A;
-	/* IndexSrc is restricted to ENC_X or IndxPol. */
-	cra |= ((setup & STDMSK_INDXSRC) >>
-		(STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1)));
-
-	/* Reset any pending CounterA event captures. */
-	crb = CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A;
-	/* Clock enable is passed through. */
-	crb |= (setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB);
-
-	/* Force IntSrc to Disabled if disable_int_src is asserted. */
-	if (!disable_int_src)
-		cra |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
-						    CRABIT_INTSRC_A));
-
-	/* Populate all mode-dependent attributes of CRA & CRB images. */
-	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
-	case CLKSRC_EXTENDER:	/* Extender Mode: Force to Timer mode
-				 * (Extender valid only for B counters). */
-		/* Fall through to case CLKSRC_TIMER: */
-	case CLKSRC_TIMER:	/* Timer Mode: */
-		/* ClkSrcA<1> selects system clock */
-		cra |= 2 << CRABIT_CLKSRC_A;
-		/* Count direction (ClkSrcA<0>) obtained from ClkPol. */
-		cra |= (setup & STDMSK_CLKPOL) >>
-		       (STDBIT_CLKPOL - CRABIT_CLKSRC_A);
-		/* ClkPolA behaves as always-on clock enable. */
-		cra |= 1 << CRABIT_CLKPOL_A;
-		/* ClkMult must be 1x. */
-		cra |= MULT_X1 << CRABIT_CLKMULT_A;
-		break;
-	default:		/* Counter Mode: */
-		/* Select ENC_C and ENC_D as clock/direction inputs. */
-		cra |= CLKSRC_COUNTER;
-		/* Clock polarity is passed through. */
-		cra |= (setup & STDMSK_CLKPOL) <<
-		       (CRABIT_CLKPOL_A - STDBIT_CLKPOL);
-		/* Force multiplier to x1 if not legal, else pass through. */
-		if ((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT))
-			cra |= MULT_X1 << CRABIT_CLKMULT_A;
-		else
-			cra |= (setup & STDMSK_CLKMULT) <<
-			       (CRABIT_CLKMULT_A - STDBIT_CLKMULT);
-		break;
-	}
-
-	/*
-	 * Force positive index polarity if IndxSrc is software-driven only,
-	 * otherwise pass it through.
-	 */
-	if (~setup & STDMSK_INDXSRC)
-		cra |= (setup & STDMSK_INDXPOL) <<
-		       (CRABIT_INDXPOL_A - STDBIT_INDXPOL);
-
-	/*
-	 * If IntSrc has been forced to Disabled, update the MISC2 interrupt
-	 * enable mask to indicate the counter interrupt is disabled.
-	 */
-	if (disable_int_src)
-		devpriv->counter_int_enabs &= ~k->my_event_bits[3];
-
-	/*
-	 * While retaining CounterB and LatchSrc configurations, program the
-	 * new counter operating mode.
-	 */
-	debi_replace(dev, k->my_cra, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
-	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A), crb);
-}
-
-static void set_mode_b(struct comedi_device *dev, const struct s626_enc_info *k,
-		       uint16_t setup, uint16_t disable_int_src)
-{
-	struct s626_private *devpriv = dev->private;
-	uint16_t cra;
-	uint16_t crb;
-
-	/* Initialize CRA and CRB images. */
-	/* IndexSrc field is restricted to ENC_X or IndxPol. */
-	cra = (setup & STDMSK_INDXSRC) <<
-	      (CRABIT_INDXSRC_B + 1 - STDBIT_INDXSRC);
-
-	/* Reset event captures and disable interrupts. */
-	crb = CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B;
-	/* Clock enable is passed through. */
-	crb |= (setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB);
-	/* Preload trigger source is passed through. */
-	crb |= (setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B);
-
-	/* Force IntSrc to Disabled if disable_int_src is asserted. */
-	if (!disable_int_src)
-		crb |= (setup & STDMSK_INTSRC) >>
-		       (STDBIT_INTSRC - CRBBIT_INTSRC_B);
-
-	/* Populate all mode-dependent attributes of CRA & CRB images. */
-	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
-	case CLKSRC_TIMER:	/* Timer Mode: */
-		/* ClkSrcB<1> selects system clock */
-		cra |= 2 << CRABIT_CLKSRC_B;
-		/* with direction (ClkSrcB<0>) obtained from ClkPol. */
-		cra |= (setup & STDMSK_CLKPOL) <<
-		       (CRABIT_CLKSRC_B - STDBIT_CLKPOL);
-		/* ClkPolB behaves as always-on clock enable. */
-		crb |= 1 << CRBBIT_CLKPOL_B;
-		/* ClkMultB must be 1x. */
-		crb |= MULT_X1 << CRBBIT_CLKMULT_B;
-		break;
-	case CLKSRC_EXTENDER:	/* Extender Mode: */
-		/* ClkSrcB source is OverflowA (same as "timer") */
-		cra |= 2 << CRABIT_CLKSRC_B;
-		/* with direction obtained from ClkPol. */
-		cra |= (setup & STDMSK_CLKPOL) <<
-		       (CRABIT_CLKSRC_B - STDBIT_CLKPOL);
-		/* ClkPolB controls IndexB -- always set to active. */
-		crb |= 1 << CRBBIT_CLKPOL_B;
-		/* ClkMultB selects OverflowA as the clock source. */
-		crb |= MULT_X0 << CRBBIT_CLKMULT_B;
-		break;
-	default:		/* Counter Mode: */
-		/* Select ENC_C and ENC_D as clock/direction inputs. */
-		cra |= CLKSRC_COUNTER << CRABIT_CLKSRC_B;
-		/* ClkPol is passed through. */
-		crb |= (setup & STDMSK_CLKPOL) >>
-		       (STDBIT_CLKPOL - CRBBIT_CLKPOL_B);
-		/* Force ClkMult to x1 if not legal, otherwise pass through. */
-		if ((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT))
-			crb |= MULT_X1 << CRBBIT_CLKMULT_B;
-		else
-			crb |= (setup & STDMSK_CLKMULT) <<
-			       (CRBBIT_CLKMULT_B - STDBIT_CLKMULT);
-		break;
-	}
-
-	/*
-	 * Force positive index polarity if IndxSrc is software-driven only,
-	 * otherwise pass it through.
-	 */
-	if (~setup & STDMSK_INDXSRC)
-		crb |= (setup & STDMSK_INDXPOL) >>
-		       (STDBIT_INDXPOL - CRBBIT_INDXPOL_B);
-
-	/*
-	 * If IntSrc has been forced to Disabled, update the MISC2 interrupt
-	 * enable mask to indicate the counter interrupt is disabled.
-	 */
-	if (disable_int_src)
-		devpriv->counter_int_enabs &= ~k->my_event_bits[3];
-
-	/*
-	 * While retaining CounterA and LatchSrc configurations, program the
-	 * new counter operating mode.
-	 */
-	debi_replace(dev, k->my_cra, ~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B),
-		     cra);
-	debi_replace(dev, k->my_crb, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
-}
-
-/*
- * Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
- */
-static void set_enable_a(struct comedi_device *dev,
-			 const struct s626_enc_info *k, uint16_t enab)
-{
-	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A),
-		     enab << CRBBIT_CLKENAB_A);
-}
-
-static void set_enable_b(struct comedi_device *dev, const
-			 struct s626_enc_info *k, uint16_t enab)
-{
-	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B),
-		     enab << CRBBIT_CLKENAB_B);
-}
-
-static uint16_t get_enable_a(struct comedi_device *dev,
-			     const struct s626_enc_info *k)
-{
-	return (debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_A) & 1;
-}
-
-static uint16_t get_enable_b(struct comedi_device *dev,
-			     const struct s626_enc_info *k)
-{
-	return (debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_B) & 1;
-}
-
-#ifdef unused
-static uint16_t get_latch_source(struct comedi_device *dev,
-				 const struct s626_enc_info *k)
-{
-	return (debi_read(dev, k->my_crb) >> CRBBIT_LATCHSRC) & 3;
-}
-#endif
-
-/*
- * Return/set the event that will trigger transfer of the preload
- * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
- * 2=OverflowA (B counters only), 3=disabled.
- */
-static void set_load_trig_a(struct comedi_device *dev,
-			    const struct s626_enc_info *k, uint16_t trig)
-{
-	debi_replace(dev, k->my_cra, ~CRAMSK_LOADSRC_A,
-		     trig << CRABIT_LOADSRC_A);
-}
-
-static void set_load_trig_b(struct comedi_device *dev,
-			    const struct s626_enc_info *k, uint16_t trig)
-{
-	debi_replace(dev, k->my_crb, ~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL),
-		     trig << CRBBIT_LOADSRC_B);
-}
-
-static uint16_t get_load_trig_a(struct comedi_device *dev,
-				const struct s626_enc_info *k)
-{
-	return (debi_read(dev, k->my_cra) >> CRABIT_LOADSRC_A) & 3;
-}
-
-static uint16_t get_load_trig_b(struct comedi_device *dev,
-				const struct s626_enc_info *k)
-{
-	return (debi_read(dev, k->my_crb) >> CRBBIT_LOADSRC_B) & 3;
-}
-
 /*
  * Return/set counter interrupt source and clear any captured
  * index/overflow events.  int_source: 0=Disabled, 1=OverflowOnly,

commit 010be96fb611cf4b697dc6990e4d8dc83f0f2c83
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:31 2013 +0100

    staging: comedi: s626: move encoder functions part 1
    
    Move some functions to help avoid the forward declaration of
    `s626_enc_chan_info[]`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 689e2e2b0b15..17a0cd7a7786 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -651,6 +651,148 @@ static void preload(struct comedi_device *dev, const struct s626_enc_info *k,
 	debi_write(dev, k->my_latch_lsw + 2, value >> 16);
 }
 
+/* ******  PRIVATE COUNTER FUNCTIONS ****** */
+
+/*
+ * Reset a counter's index and overflow event capture flags.
+ */
+static void reset_cap_flags_a(struct comedi_device *dev,
+			      const struct s626_enc_info *k)
+{
+	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
+		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+}
+
+static void reset_cap_flags_b(struct comedi_device *dev,
+			      const struct s626_enc_info *k)
+{
+	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
+		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
+}
+
+/*
+ * Return counter setup in a format (COUNTER_SETUP) that is consistent
+ * for both A and B counters.
+ */
+static uint16_t get_mode_a(struct comedi_device *dev,
+			   const struct s626_enc_info *k)
+{
+	uint16_t cra;
+	uint16_t crb;
+	uint16_t setup;
+
+	/* Fetch CRA and CRB register images. */
+	cra = debi_read(dev, k->my_cra);
+	crb = debi_read(dev, k->my_crb);
+
+	/*
+	 * Populate the standardized counter setup bit fields.
+	 * Note: IndexSrc is restricted to ENC_X or IndxPol.
+	 */
+	setup = (cra & STDMSK_LOADSRC) |	/* LoadSrc  = LoadSrcA. */
+		((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) &
+		 STDMSK_LATCHSRC) |		/* LatchSrc = LatchSrcA. */
+		((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) &
+		 STDMSK_INTSRC) |		/* IntSrc   = IntSrcA. */
+		((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) &
+		 STDMSK_INDXSRC) |		/* IndxSrc  = IndxSrcA<1>. */
+		((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) &
+		 STDMSK_INDXPOL) |		/* IndxPol  = IndxPolA. */
+		((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) &
+		 STDMSK_CLKENAB);		/* ClkEnab  = ClkEnabA. */
+
+	/* Adjust mode-dependent parameters. */
+	if (cra & (2 << CRABIT_CLKSRC_A)) {
+		/* Timer mode (ClkSrcA<1> == 1): */
+		/* Indicate Timer mode. */
+		setup |= CLKSRC_TIMER << STDBIT_CLKSRC;
+		/* Set ClkPol to indicate count direction (ClkSrcA<0>). */
+		setup |= (cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) &
+			 STDMSK_CLKPOL;
+		/* ClkMult must be 1x in Timer mode. */
+		setup |= MULT_X1 << STDBIT_CLKMULT;
+	} else {
+		/* Counter mode (ClkSrcA<1> == 0): */
+		/* Indicate Counter mode. */
+		setup |= CLKSRC_COUNTER << STDBIT_CLKSRC;
+		/* Pass through ClkPol. */
+		setup |= (cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) &
+			 STDMSK_CLKPOL;
+		/* Force ClkMult to 1x if not legal, else pass through. */
+		if ((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A))
+			setup |= MULT_X1 << STDBIT_CLKMULT;
+		else
+			setup |= (cra >> (CRABIT_CLKMULT_A - STDBIT_CLKMULT)) &
+				 STDMSK_CLKMULT;
+	}
+
+	/* Return adjusted counter setup. */
+	return setup;
+}
+
+static uint16_t get_mode_b(struct comedi_device *dev,
+			   const struct s626_enc_info *k)
+{
+	uint16_t cra;
+	uint16_t crb;
+	uint16_t setup;
+
+	/* Fetch CRA and CRB register images. */
+	cra = debi_read(dev, k->my_cra);
+	crb = debi_read(dev, k->my_crb);
+
+	/*
+	 * Populate the standardized counter setup bit fields.
+	 * Note: IndexSrc is restricted to ENC_X or IndxPol.
+	 */
+	setup = ((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) &
+		 STDMSK_INTSRC) |		/* IntSrc   = IntSrcB. */
+		((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) &
+		 STDMSK_LATCHSRC) |		/* LatchSrc = LatchSrcB. */
+		((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) &
+		 STDMSK_LOADSRC) |		/* LoadSrc  = LoadSrcB. */
+		((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) &
+		 STDMSK_INDXPOL) |		/* IndxPol  = IndxPolB. */
+		((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) &
+		 STDMSK_CLKENAB) |		/* ClkEnab  = ClkEnabB. */
+		((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) &
+		 STDMSK_INDXSRC);		/* IndxSrc  = IndxSrcB<1>. */
+
+	/* Adjust mode-dependent parameters. */
+	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B)) {
+		/* Extender mode (ClkMultB == MULT_X0): */
+		/* Indicate Extender mode. */
+		setup |= CLKSRC_EXTENDER << STDBIT_CLKSRC;
+		/* Indicate multiplier is 1x. */
+		setup |= MULT_X1 << STDBIT_CLKMULT;
+		/* Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+		setup |= (cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) &
+			 STDMSK_CLKPOL;
+	} else if (cra & (2 << CRABIT_CLKSRC_B)) {
+		/* Timer mode (ClkSrcB<1> == 1): */
+		/* Indicate Timer mode. */
+		setup |= CLKSRC_TIMER << STDBIT_CLKSRC;
+		/* Indicate multiplier is 1x. */
+		setup |= MULT_X1 << STDBIT_CLKMULT;
+		/* Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+		setup |= (cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) &
+			 STDMSK_CLKPOL;
+	} else {
+		/* If Counter mode (ClkSrcB<1> == 0): */
+		/* Indicate Timer mode. */
+		setup |= CLKSRC_COUNTER << STDBIT_CLKSRC;
+		/* Clock multiplier is passed through. */
+		setup |= (crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) &
+			 STDMSK_CLKMULT;
+		/* Clock polarity is passed through. */
+		setup |= (crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) &
+			 STDMSK_CLKPOL;
+	}
+
+	/* Return adjusted counter setup. */
+	return setup;
+}
+
 static unsigned int s626_ai_reg_to_uint(int data)
 {
 	unsigned int tempdata;
@@ -1822,148 +1964,6 @@ static void close_dma_b(struct comedi_device *dev, struct buffer_dma *pdma,
 	}
 }
 
-/* ******  PRIVATE COUNTER FUNCTIONS ****** */
-
-/*
- * Reset a counter's index and overflow event capture flags.
- */
-static void reset_cap_flags_a(struct comedi_device *dev,
-			      const struct s626_enc_info *k)
-{
-	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
-		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
-}
-
-static void reset_cap_flags_b(struct comedi_device *dev,
-			      const struct s626_enc_info *k)
-{
-	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
-		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
-}
-
-/*
- * Return counter setup in a format (COUNTER_SETUP) that is consistent
- * for both A and B counters.
- */
-static uint16_t get_mode_a(struct comedi_device *dev,
-			   const struct s626_enc_info *k)
-{
-	uint16_t cra;
-	uint16_t crb;
-	uint16_t setup;
-
-	/* Fetch CRA and CRB register images. */
-	cra = debi_read(dev, k->my_cra);
-	crb = debi_read(dev, k->my_crb);
-
-	/*
-	 * Populate the standardized counter setup bit fields.
-	 * Note: IndexSrc is restricted to ENC_X or IndxPol.
-	 */
-	setup = (cra & STDMSK_LOADSRC) |	/* LoadSrc  = LoadSrcA. */
-		((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) &
-		 STDMSK_LATCHSRC) |		/* LatchSrc = LatchSrcA. */
-		((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) &
-		 STDMSK_INTSRC) |		/* IntSrc   = IntSrcA. */
-		((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) &
-		 STDMSK_INDXSRC) |		/* IndxSrc  = IndxSrcA<1>. */
-		((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) &
-		 STDMSK_INDXPOL) |		/* IndxPol  = IndxPolA. */
-		((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) &
-		 STDMSK_CLKENAB);		/* ClkEnab  = ClkEnabA. */
-
-	/* Adjust mode-dependent parameters. */
-	if (cra & (2 << CRABIT_CLKSRC_A)) {
-		/* Timer mode (ClkSrcA<1> == 1): */
-		/* Indicate Timer mode. */
-		setup |= CLKSRC_TIMER << STDBIT_CLKSRC;
-		/* Set ClkPol to indicate count direction (ClkSrcA<0>). */
-		setup |= (cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) &
-			 STDMSK_CLKPOL;
-		/* ClkMult must be 1x in Timer mode. */
-		setup |= MULT_X1 << STDBIT_CLKMULT;
-	} else {
-		/* Counter mode (ClkSrcA<1> == 0): */
-		/* Indicate Counter mode. */
-		setup |= CLKSRC_COUNTER << STDBIT_CLKSRC;
-		/* Pass through ClkPol. */
-		setup |= (cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) &
-			 STDMSK_CLKPOL;
-		/* Force ClkMult to 1x if not legal, else pass through. */
-		if ((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A))
-			setup |= MULT_X1 << STDBIT_CLKMULT;
-		else
-			setup |= (cra >> (CRABIT_CLKMULT_A - STDBIT_CLKMULT)) &
-				 STDMSK_CLKMULT;
-	}
-
-	/* Return adjusted counter setup. */
-	return setup;
-}
-
-static uint16_t get_mode_b(struct comedi_device *dev,
-			   const struct s626_enc_info *k)
-{
-	uint16_t cra;
-	uint16_t crb;
-	uint16_t setup;
-
-	/* Fetch CRA and CRB register images. */
-	cra = debi_read(dev, k->my_cra);
-	crb = debi_read(dev, k->my_crb);
-
-	/*
-	 * Populate the standardized counter setup bit fields.
-	 * Note: IndexSrc is restricted to ENC_X or IndxPol.
-	 */
-	setup = ((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) &
-		 STDMSK_INTSRC) |		/* IntSrc   = IntSrcB. */
-		((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) &
-		 STDMSK_LATCHSRC) |		/* LatchSrc = LatchSrcB. */
-		((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) &
-		 STDMSK_LOADSRC) |		/* LoadSrc  = LoadSrcB. */
-		((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) &
-		 STDMSK_INDXPOL) |		/* IndxPol  = IndxPolB. */
-		((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) &
-		 STDMSK_CLKENAB) |		/* ClkEnab  = ClkEnabB. */
-		((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) &
-		 STDMSK_INDXSRC);		/* IndxSrc  = IndxSrcB<1>. */
-
-	/* Adjust mode-dependent parameters. */
-	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B)) {
-		/* Extender mode (ClkMultB == MULT_X0): */
-		/* Indicate Extender mode. */
-		setup |= CLKSRC_EXTENDER << STDBIT_CLKSRC;
-		/* Indicate multiplier is 1x. */
-		setup |= MULT_X1 << STDBIT_CLKMULT;
-		/* Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
-		setup |= (cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) &
-			 STDMSK_CLKPOL;
-	} else if (cra & (2 << CRABIT_CLKSRC_B)) {
-		/* Timer mode (ClkSrcB<1> == 1): */
-		/* Indicate Timer mode. */
-		setup |= CLKSRC_TIMER << STDBIT_CLKSRC;
-		/* Indicate multiplier is 1x. */
-		setup |= MULT_X1 << STDBIT_CLKMULT;
-		/* Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
-		setup |= (cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) &
-			 STDMSK_CLKPOL;
-	} else {
-		/* If Counter mode (ClkSrcB<1> == 0): */
-		/* Indicate Timer mode. */
-		setup |= CLKSRC_COUNTER << STDBIT_CLKSRC;
-		/* Clock multiplier is passed through. */
-		setup |= (crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) &
-			 STDMSK_CLKMULT;
-		/* Clock polarity is passed through. */
-		setup |= (crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) &
-			 STDMSK_CLKPOL;
-	}
-
-	/* Return adjusted counter setup. */
-	return setup;
-}
-
 /*
  * Set the operating mode for the specified counter.  The setup
  * parameter is treated as a COUNTER_SETUP data type.  The following

commit 3a305a66bb11dca492701db9aa9a48de4e29193e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:30 2013 +0100

    staging: comedi: s626: remove encpriv macro
    
    The `encpriv` macro relies on a local variable `dev` (of type `struct
    comedi_device *`) being set correctly.  By a convoluted path involving
    the `private` data pointer of subdevice 5 (the encoder (counter)
    subdevice), the macro always yields a pointer to the first element of
    the static array `enc_private_data[]`.  That holds statically constant
    data for each of 6 encoder channels.
    
    Instead of using the `encpriv` macro, just access the array it points to
    directly and get rid of the macro.  Don't bother initializing the
    `private` member of the encoder subdevice any more.  Since
    `enc_private_data[]` now has nothing to so with subdevice private data,
    rename `enc_private_data[]` to `s626_enc_chan_info[]` and rename its
    type from `struct enc_private` to `struct s626_enc_info`.  Since the
    array contains unchanging, static information, declare it `const` and
    declare all the variables that point to it `const`.
    
    A forward declaration of `s626_enc_chan_info[]` has been added
    temporarily and will be removed by a later patch.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index e4340e3929f2..689e2e2b0b15 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -98,35 +98,39 @@ struct s626_private {
 };
 
 /* COUNTER OBJECT ------------------------------------------------ */
-struct enc_private {
+struct s626_enc_info {
 	/* Pointers to functions that differ for A and B counters: */
 	/* Return clock enable. */
-	uint16_t(*get_enable)(struct comedi_device *dev, struct enc_private *k);
+	uint16_t(*get_enable)(struct comedi_device *dev,
+			      const struct s626_enc_info *k);
 	/* Return interrupt source. */
 	uint16_t(*get_int_src)(struct comedi_device *dev,
-			       struct enc_private *k);
+			       const struct s626_enc_info *k);
 	/* Return preload trigger source. */
 	uint16_t(*get_load_trig)(struct comedi_device *dev,
-				 struct enc_private *k);
+				 const struct s626_enc_info *k);
 	/* Return standardized operating mode. */
-	uint16_t(*get_mode)(struct comedi_device *dev, struct enc_private *k);
+	uint16_t(*get_mode)(struct comedi_device *dev,
+			    const struct s626_enc_info *k);
 	/* Generate soft index strobe. */
-	void (*pulse_index)(struct comedi_device *dev, struct enc_private *k);
+	void (*pulse_index)(struct comedi_device *dev,
+			    const struct s626_enc_info *k);
 	/* Program clock enable. */
-	void (*set_enable)(struct comedi_device *dev, struct enc_private *k,
-			   uint16_t enab);
+	void (*set_enable)(struct comedi_device *dev,
+			   const struct s626_enc_info *k, uint16_t enab);
 	/* Program interrupt source. */
-	void (*set_int_src)(struct comedi_device *dev, struct enc_private *k,
-			    uint16_t int_source);
+	void (*set_int_src)(struct comedi_device *dev,
+			    const struct s626_enc_info *k, uint16_t int_source);
 	/* Program preload trigger source. */
-	void (*set_load_trig)(struct comedi_device *dev, struct enc_private *k,
-			      uint16_t trig);
+	void (*set_load_trig)(struct comedi_device *dev,
+			      const struct s626_enc_info *k, uint16_t trig);
 	/* Program standardized operating mode. */
-	void (*set_mode)(struct comedi_device *dev, struct enc_private *k,
-			 uint16_t setup, uint16_t disable_int_src);
+	void (*set_mode)(struct comedi_device *dev,
+			 const struct s626_enc_info *k, uint16_t setup,
+			 uint16_t disable_int_src);
 	/* Reset event capture flags. */
 	void (*reset_cap_flags)(struct comedi_device *dev,
-				struct enc_private *k);
+				const struct s626_enc_info *k);
 
 	uint16_t my_cra;	/* address of CRA register */
 	uint16_t my_crb;	/* address of CRB register */
@@ -135,7 +139,7 @@ struct enc_private {
 	uint16_t my_event_bits[4]; /* bit translations for IntSrc -->RDMISC2 */
 };
 
-#define encpriv ((struct enc_private *)(dev->subdevices+5)->private)
+static const struct s626_enc_info s626_enc_chan_info[];
 
 /* Counter overflow/index event flag masks for RDMISC2. */
 #define INDXMASK(C)	(1 << (((C) > 2) ? ((C) * 2 - 1) : ((C) * 2 +  4)))
@@ -610,7 +614,8 @@ static void load_trim_dacs(struct comedi_device *dev)
 /*
  * Read a counter's output latch.
  */
-static uint32_t read_latch(struct comedi_device *dev, struct enc_private *k)
+static uint32_t read_latch(struct comedi_device *dev,
+			   const struct s626_enc_info *k)
 {
 	uint32_t value;
 
@@ -629,8 +634,8 @@ static uint32_t read_latch(struct comedi_device *dev, struct enc_private *k)
  * access, 1: A index latches A, 2: B index latches B, 3: A overflow
  * latches B.
  */
-static void set_latch_source(struct comedi_device *dev, struct enc_private *k,
-			     uint16_t value)
+static void set_latch_source(struct comedi_device *dev,
+			     const struct s626_enc_info *k, uint16_t value)
 {
 	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC),
 		     value << CRBBIT_LATCHSRC);
@@ -639,7 +644,7 @@ static void set_latch_source(struct comedi_device *dev, struct enc_private *k,
 /*
  * Write value into counter preload register.
  */
-static void preload(struct comedi_device *dev, struct enc_private *k,
+static void preload(struct comedi_device *dev, const struct s626_enc_info *k,
 		    uint32_t value)
 {
 	debi_write(dev, k->my_latch_lsw, value);
@@ -740,7 +745,8 @@ static void handle_dio_interrupt(struct comedi_device *dev,
 			}
 
 			if (cmd->convert_src == TRIG_TIMER) {
-				struct enc_private *k = &encpriv[5];
+				const struct s626_enc_info *k =
+					&s626_enc_chan_info[5];
 
 				devpriv->ai_convert_count = cmd->chanlist_len;
 				k->set_enable(dev, k, CLKENAB_ALWAYS);
@@ -782,7 +788,7 @@ static void check_counter_interrupts(struct comedi_device *dev)
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	struct enc_private *k;
+	const struct s626_enc_info *k;
 	uint16_t irqbit;
 
 	/* read interrupt type */
@@ -790,31 +796,31 @@ static void check_counter_interrupts(struct comedi_device *dev)
 
 	/* check interrupt on counters */
 	if (irqbit & IRQ_COINT1A) {
-		k = &encpriv[0];
+		k = &s626_enc_chan_info[0];
 
 		/* clear interrupt capture flag */
 		k->reset_cap_flags(dev, k);
 	}
 	if (irqbit & IRQ_COINT2A) {
-		k = &encpriv[1];
+		k = &s626_enc_chan_info[1];
 
 		/* clear interrupt capture flag */
 		k->reset_cap_flags(dev, k);
 	}
 	if (irqbit & IRQ_COINT3A) {
-		k = &encpriv[2];
+		k = &s626_enc_chan_info[2];
 
 		/* clear interrupt capture flag */
 		k->reset_cap_flags(dev, k);
 	}
 	if (irqbit & IRQ_COINT1B) {
-		k = &encpriv[3];
+		k = &s626_enc_chan_info[3];
 
 		/* clear interrupt capture flag */
 		k->reset_cap_flags(dev, k);
 	}
 	if (irqbit & IRQ_COINT2B) {
-		k = &encpriv[4];
+		k = &s626_enc_chan_info[4];
 
 		/* clear interrupt capture flag */
 		k->reset_cap_flags(dev, k);
@@ -831,7 +837,7 @@ static void check_counter_interrupts(struct comedi_device *dev)
 		}
 	}
 	if (irqbit & IRQ_COINT3B) {
-		k = &encpriv[5];
+		k = &s626_enc_chan_info[5];
 
 		/* clear interrupt capture flag */
 		k->reset_cap_flags(dev, k);
@@ -842,7 +848,7 @@ static void check_counter_interrupts(struct comedi_device *dev)
 		}
 
 		if (cmd->convert_src == TRIG_TIMER) {
-			k = &encpriv[4];
+			k = &s626_enc_chan_info[4];
 			devpriv->ai_convert_count = cmd->chanlist_len;
 			k->set_enable(dev, k, CLKENAB_ALWAYS);
 		}
@@ -1340,8 +1346,8 @@ static int s626_ns_to_timer(int *nanosec, int round_mode)
 	return divider - 1;
 }
 
-static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
-			    int tick)
+static void s626_timer_load(struct comedi_device *dev,
+			    const struct s626_enc_info *k, int tick)
 {
 	uint16_t setup =
 		(LOADSRC_INDX << BF_LOADSRC) |	/* Preload upon index. */
@@ -1382,7 +1388,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct s626_private *devpriv = dev->private;
 	uint8_t ppl[16];
 	struct comedi_cmd *cmd = &s->async->cmd;
-	struct enc_private *k;
+	const struct s626_enc_info *k;
 	int tick;
 
 	if (devpriv->ai_cmd_running) {
@@ -1425,7 +1431,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * set a counter to generate adc trigger at scan_begin_arg
 		 * interval
 		 */
-		k = &encpriv[5];
+		k = &s626_enc_chan_info[5];
 		tick = s626_ns_to_timer((int *)&cmd->scan_begin_arg,
 					cmd->flags & TRIG_ROUND_MASK);
 
@@ -1448,7 +1454,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * set a counter to generate adc trigger at convert_arg
 		 * interval
 		 */
-		k = &encpriv[4];
+		k = &s626_enc_chan_info[4];
 		tick = s626_ns_to_timer((int *)&cmd->convert_arg,
 					cmd->flags & TRIG_ROUND_MASK);
 
@@ -1740,7 +1746,8 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 	/* uint32_t Preloadvalue;              //Counter initial value */
 	uint16_t value_latchsrc = LATCHSRC_AB_READ;
 	uint16_t enab = CLKENAB_ALWAYS;
-	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
+	const struct s626_enc_info *k =
+		&s626_enc_chan_info[CR_CHAN(insn->chanspec)];
 
 	/* (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
@@ -1758,7 +1765,8 @@ static int s626_enc_insn_read(struct comedi_device *dev,
 			      struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
-	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
+	const struct s626_enc_info *k =
+		&s626_enc_chan_info[CR_CHAN(insn->chanspec)];
 
 	for (n = 0; n < insn->n; n++)
 		data[n] = read_latch(dev, k);
@@ -1770,7 +1778,8 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
-	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
+	const struct s626_enc_info *k =
+		&s626_enc_chan_info[CR_CHAN(insn->chanspec)];
 
 	/* Set the preload register */
 	preload(dev, k, data[0]);
@@ -1818,13 +1827,15 @@ static void close_dma_b(struct comedi_device *dev, struct buffer_dma *pdma,
 /*
  * Reset a counter's index and overflow event capture flags.
  */
-static void reset_cap_flags_a(struct comedi_device *dev, struct enc_private *k)
+static void reset_cap_flags_a(struct comedi_device *dev,
+			      const struct s626_enc_info *k)
 {
 	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
 		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 }
 
-static void reset_cap_flags_b(struct comedi_device *dev, struct enc_private *k)
+static void reset_cap_flags_b(struct comedi_device *dev,
+			      const struct s626_enc_info *k)
 {
 	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
 		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
@@ -1834,7 +1845,8 @@ static void reset_cap_flags_b(struct comedi_device *dev, struct enc_private *k)
  * Return counter setup in a format (COUNTER_SETUP) that is consistent
  * for both A and B counters.
  */
-static uint16_t get_mode_a(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_mode_a(struct comedi_device *dev,
+			   const struct s626_enc_info *k)
 {
 	uint16_t cra;
 	uint16_t crb;
@@ -1889,7 +1901,8 @@ static uint16_t get_mode_a(struct comedi_device *dev, struct enc_private *k)
 	return setup;
 }
 
-static uint16_t get_mode_b(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_mode_b(struct comedi_device *dev,
+			   const struct s626_enc_info *k)
 {
 	uint16_t cra;
 	uint16_t crb;
@@ -1957,7 +1970,7 @@ static uint16_t get_mode_b(struct comedi_device *dev, struct enc_private *k)
  * parameters are programmable (all other parms are ignored): ClkMult,
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
-static void set_mode_a(struct comedi_device *dev, struct enc_private *k,
+static void set_mode_a(struct comedi_device *dev, const struct s626_enc_info *k,
 		       uint16_t setup, uint16_t disable_int_src)
 {
 	struct s626_private *devpriv = dev->private;
@@ -2035,7 +2048,7 @@ static void set_mode_a(struct comedi_device *dev, struct enc_private *k,
 	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A), crb);
 }
 
-static void set_mode_b(struct comedi_device *dev, struct enc_private *k,
+static void set_mode_b(struct comedi_device *dev, const struct s626_enc_info *k,
 		       uint16_t setup, uint16_t disable_int_src)
 {
 	struct s626_private *devpriv = dev->private;
@@ -2125,33 +2138,35 @@ static void set_mode_b(struct comedi_device *dev, struct enc_private *k,
 /*
  * Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
  */
-static void set_enable_a(struct comedi_device *dev, struct enc_private *k,
-			 uint16_t enab)
+static void set_enable_a(struct comedi_device *dev,
+			 const struct s626_enc_info *k, uint16_t enab)
 {
 	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A),
 		     enab << CRBBIT_CLKENAB_A);
 }
 
-static void set_enable_b(struct comedi_device *dev, struct enc_private *k,
-			 uint16_t enab)
+static void set_enable_b(struct comedi_device *dev, const
+			 struct s626_enc_info *k, uint16_t enab)
 {
 	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B),
 		     enab << CRBBIT_CLKENAB_B);
 }
 
-static uint16_t get_enable_a(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_enable_a(struct comedi_device *dev,
+			     const struct s626_enc_info *k)
 {
 	return (debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_A) & 1;
 }
 
-static uint16_t get_enable_b(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_enable_b(struct comedi_device *dev,
+			     const struct s626_enc_info *k)
 {
 	return (debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_B) & 1;
 }
 
 #ifdef unused
 static uint16_t get_latch_source(struct comedi_device *dev,
-				 struct enc_private *k)
+				 const struct s626_enc_info *k)
 {
 	return (debi_read(dev, k->my_crb) >> CRBBIT_LATCHSRC) & 3;
 }
@@ -2162,28 +2177,28 @@ static uint16_t get_latch_source(struct comedi_device *dev,
  * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
  * 2=OverflowA (B counters only), 3=disabled.
  */
-static void set_load_trig_a(struct comedi_device *dev, struct enc_private *k,
-			    uint16_t trig)
+static void set_load_trig_a(struct comedi_device *dev,
+			    const struct s626_enc_info *k, uint16_t trig)
 {
 	debi_replace(dev, k->my_cra, ~CRAMSK_LOADSRC_A,
 		     trig << CRABIT_LOADSRC_A);
 }
 
-static void set_load_trig_b(struct comedi_device *dev, struct enc_private *k,
-			    uint16_t trig)
+static void set_load_trig_b(struct comedi_device *dev,
+			    const struct s626_enc_info *k, uint16_t trig)
 {
 	debi_replace(dev, k->my_crb, ~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL),
 		     trig << CRBBIT_LOADSRC_B);
 }
 
 static uint16_t get_load_trig_a(struct comedi_device *dev,
-				struct enc_private *k)
+				const struct s626_enc_info *k)
 {
 	return (debi_read(dev, k->my_cra) >> CRABIT_LOADSRC_A) & 3;
 }
 
 static uint16_t get_load_trig_b(struct comedi_device *dev,
-				struct enc_private *k)
+				const struct s626_enc_info *k)
 {
 	return (debi_read(dev, k->my_crb) >> CRBBIT_LOADSRC_B) & 3;
 }
@@ -2193,8 +2208,8 @@ static uint16_t get_load_trig_b(struct comedi_device *dev,
  * index/overflow events.  int_source: 0=Disabled, 1=OverflowOnly,
  * 2=IndexOnly, 3=IndexAndOverflow.
  */
-static void set_int_src_a(struct comedi_device *dev, struct enc_private *k,
-			  uint16_t int_source)
+static void set_int_src_a(struct comedi_device *dev,
+			  const struct s626_enc_info *k, uint16_t int_source)
 {
 	struct s626_private *devpriv = dev->private;
 
@@ -2212,8 +2227,8 @@ static void set_int_src_a(struct comedi_device *dev, struct enc_private *k,
 	    k->my_event_bits[int_source];
 }
 
-static void set_int_src_b(struct comedi_device *dev, struct enc_private *k,
-			  uint16_t int_source)
+static void set_int_src_b(struct comedi_device *dev,
+			  const struct s626_enc_info *k, uint16_t int_source)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t crb;
@@ -2236,12 +2251,14 @@ static void set_int_src_b(struct comedi_device *dev, struct enc_private *k,
 		k->my_event_bits[int_source];
 }
 
-static uint16_t get_int_src_a(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_int_src_a(struct comedi_device *dev,
+			      const struct s626_enc_info *k)
 {
 	return (debi_read(dev, k->my_cra) >> CRABIT_INTSRC_A) & 3;
 }
 
-static uint16_t get_int_src_b(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_int_src_b(struct comedi_device *dev,
+			      const struct s626_enc_info *k)
 {
 	return (debi_read(dev, k->my_crb) >> CRBBIT_INTSRC_B) & 3;
 }
@@ -2250,14 +2267,15 @@ static uint16_t get_int_src_b(struct comedi_device *dev, struct enc_private *k)
 /*
  * Return/set the clock multiplier.
  */
-static void set_clk_mult(struct comedi_device *dev, struct enc_private *k,
-			 uint16_t value)
+static void set_clk_mult(struct comedi_device *dev,
+			 const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKMULT) |
 			    (value << STDBIT_CLKMULT)), FALSE);
 }
 
-static uint16_t get_clk_mult(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_clk_mult(struct comedi_device *dev,
+			     const struct s626_enc_info *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_CLKMULT) & 3;
 }
@@ -2265,14 +2283,15 @@ static uint16_t get_clk_mult(struct comedi_device *dev, struct enc_private *k)
 /*
  * Return/set the clock polarity.
  */
-static void set_clk_pol(struct comedi_device *dev, struct enc_private *k,
-			uint16_t value)
+static void set_clk_pol(struct comedi_device *dev,
+			const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKPOL) |
 			    (value << STDBIT_CLKPOL)), FALSE);
 }
 
-static uint16_t get_clk_pol(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_clk_pol(struct comedi_device *dev,
+			    const struct s626_enc_info *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_CLKPOL) & 1;
 }
@@ -2280,14 +2299,15 @@ static uint16_t get_clk_pol(struct comedi_device *dev, struct enc_private *k)
 /*
  * Return/set the clock source.
  */
-static void set_clk_src(struct comedi_device *dev, struct enc_private *k,
-			uint16_t value)
+static void set_clk_src(struct comedi_device *dev,
+			const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKSRC) |
 			    (value << STDBIT_CLKSRC)), FALSE);
 }
 
-static uint16_t get_clk_src(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_clk_src(struct comedi_device *dev,
+			    const struct s626_enc_info *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_CLKSRC) & 3;
 }
@@ -2295,14 +2315,15 @@ static uint16_t get_clk_src(struct comedi_device *dev, struct enc_private *k)
 /*
  * Return/set the index polarity.
  */
-static void set_index_pol(struct comedi_device *dev, struct enc_private *k,
-			  uint16_t value)
+static void set_index_pol(struct comedi_device *dev,
+			  const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXPOL) |
 			    ((value != 0) << STDBIT_INDXPOL)), FALSE);
 }
 
-static uint16_t get_index_pol(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_index_pol(struct comedi_device *dev,
+			      const struct s626_enc_info *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_INDXPOL) & 1;
 }
@@ -2310,14 +2331,15 @@ static uint16_t get_index_pol(struct comedi_device *dev, struct enc_private *k)
 /*
  * Return/set the index source.
  */
-static void set_index_src(struct comedi_device *dev, struct enc_private *k,
-			  uint16_t value)
+static void set_index_src(struct comedi_device *dev,
+			  const struct s626_enc_info *k, uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXSRC) |
 			    ((value != 0) << STDBIT_INDXSRC)), FALSE);
 }
 
-static uint16_t get_index_src(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_index_src(struct comedi_device *dev,
+			      const struct s626_enc_info *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_INDXSRC) & 1;
 }
@@ -2326,7 +2348,8 @@ static uint16_t get_index_src(struct comedi_device *dev, struct enc_private *k)
 /*
  * Generate an index pulse.
  */
-static void pulse_index_a(struct comedi_device *dev, struct enc_private *k)
+static void pulse_index_a(struct comedi_device *dev,
+			  const struct s626_enc_info *k)
 {
 	uint16_t cra;
 
@@ -2336,7 +2359,8 @@ static void pulse_index_a(struct comedi_device *dev, struct enc_private *k)
 	debi_write(dev, k->my_cra, cra);
 }
 
-static void pulse_index_b(struct comedi_device *dev, struct enc_private *k)
+static void pulse_index_b(struct comedi_device *dev,
+			  const struct s626_enc_info *k)
 {
 	uint16_t crb;
 
@@ -2346,7 +2370,7 @@ static void pulse_index_b(struct comedi_device *dev, struct enc_private *k)
 	debi_write(dev, k->my_crb, crb);
 }
 
-static struct enc_private enc_private_data[] = {
+static const struct s626_enc_info s626_enc_chan_info[] = {
 	{
 		.get_enable		= get_enable_a,
 		.get_int_src		= get_int_src_a,
@@ -2443,7 +2467,7 @@ static struct enc_private enc_private_data[] = {
 static void counters_init(struct comedi_device *dev)
 {
 	int chan;
-	struct enc_private *k;
+	const struct s626_enc_info *k;
 	uint16_t setup =
 		(LOADSRC_INDX << BF_LOADSRC) |	/* Preload upon index. */
 		(INDXSRC_SOFT << BF_INDXSRC) |	/* Disable hardware index. */
@@ -2457,7 +2481,7 @@ static void counters_init(struct comedi_device *dev)
 	 * Disable all counter interrupts and clear any captured counter events.
 	 */
 	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
-		k = &encpriv[chan];
+		k = &s626_enc_chan_info[chan];
 		k->set_mode(dev, k, setup, TRUE);
 		k->set_int_src(dev, k, 0);
 		k->reset_cap_flags(dev, k);
@@ -2832,7 +2856,6 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;
 	s->n_chan	= S626_ENCODER_CHANNELS;
 	s->maxdata	= 0xffffff;
-	s->private	= enc_private_data;
 	s->range_table	= &range_unknown;
 	s->insn_config	= s626_enc_insn_config;
 	s->insn_read	= s626_enc_insn_read;

commit f1f7efce3b875126a817b8d6c0a49a4a025831a3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:29 2013 +0100

    staging: comedi: s626: rename CamelCase variables
    
    Rename the remaining CamelCase parameters and variables.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6093ca3af5d3..e4340e3929f2 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -145,7 +145,7 @@ struct enc_private {
 
 /*
  * Translation table to map IntSrc into equivalent RDMISC2 event flag  bits.
- * static const uint16_t EventBits[][4] =
+ * static const uint16_t event_bits[][4] =
  *     { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) };
  */
 
@@ -486,7 +486,7 @@ static void set_dac(struct comedi_device *dev, uint16_t chan, short dacdata)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t signmask;
-	uint32_t WSImage;
+	uint32_t ws_image;
 	uint32_t val;
 
 	/*
@@ -516,11 +516,11 @@ static void set_dac(struct comedi_device *dev, uint16_t chan, short dacdata)
 	 */
 
 	/* Choose DAC chip select to be asserted */
-	WSImage = (chan & 2) ? WS1 : WS2;
+	ws_image = (chan & 2) ? WS1 : WS2;
 	/* Slot 2: Transmit high data byte to target DAC */
-	writel(XSD2 | XFIFO_1 | WSImage, devpriv->mmio + VECTPORT(2));
+	writel(XSD2 | XFIFO_1 | ws_image, devpriv->mmio + VECTPORT(2));
 	/* Slot 3: Transmit low data byte to target DAC */
-	writel(XSD2 | XFIFO_0 | WSImage, devpriv->mmio + VECTPORT(3));
+	writel(XSD2 | XFIFO_0 | ws_image, devpriv->mmio + VECTPORT(3));
 	/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */
 	writel(XSD2 | XFIFO_3 | WS3, devpriv->mmio + VECTPORT(4));
 	/* Slot 5: running after writing target DAC's low data byte */
@@ -543,8 +543,8 @@ static void set_dac(struct comedi_device *dev, uint16_t chan, short dacdata)
 	send_dac(dev, val);
 }
 
-static void write_trim_dac(struct comedi_device *dev, uint8_t LogicalChan,
-			   uint8_t DacData)
+static void write_trim_dac(struct comedi_device *dev, uint8_t logical_chan,
+			   uint8_t dac_data)
 {
 	struct s626_private *devpriv = dev->private;
 	uint32_t chan;
@@ -553,10 +553,10 @@ static void write_trim_dac(struct comedi_device *dev, uint8_t LogicalChan,
 	 * Save the new setpoint in case the application needs to read it back
 	 * later.
 	 */
-	devpriv->trim_setpoint[LogicalChan] = (uint8_t)DacData;
+	devpriv->trim_setpoint[logical_chan] = (uint8_t)dac_data;
 
 	/* Map logical channel number to physical channel number. */
-	chan = trimchan[LogicalChan];
+	chan = trimchan[logical_chan];
 
 	/*
 	 * Set up TSL2 records for TrimDac write operation.  All slots shift
@@ -586,7 +586,7 @@ static void write_trim_dac(struct comedi_device *dev, uint8_t LogicalChan,
 	 * Address the DAC channel within the trimdac device.
 	 * Include DAC setpoint data.
 	 */
-	send_dac(dev, (chan << 8) | DacData);
+	send_dac(dev, (chan << 8) | dac_data);
 }
 
 static void load_trim_dacs(struct comedi_device *dev)
@@ -956,18 +956,18 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 static void reset_adc(struct comedi_device *dev, uint8_t *ppl)
 {
 	struct s626_private *devpriv = dev->private;
-	uint32_t *pRPS;
-	uint32_t JmpAdrs;
+	uint32_t *rps;
+	uint32_t jmp_adrs;
 	uint16_t i;
 	uint16_t n;
-	uint32_t LocalPPL;
+	uint32_t local_ppl;
 	struct comedi_cmd *cmd = &dev->subdevices->async->cmd;
 
 	/* Stop RPS program in case it is currently running */
 	s626_mc_disable(dev, MC1_ERPS1, P_MC1);
 
 	/* Set starting logical address to write RPS commands. */
-	pRPS = (uint32_t *)devpriv->rps_buf.logical_base;
+	rps = (uint32_t *)devpriv->rps_buf.logical_base;
 
 	/* Initialize RPS instruction pointer */
 	writel((uint32_t)devpriv->rps_buf.physical_base,
@@ -976,8 +976,8 @@ static void reset_adc(struct comedi_device *dev, uint8_t *ppl)
 	/* Construct RPS program in rps_buf DMA buffer */
 	if (cmd != NULL && cmd->scan_begin_src != TRIG_FOLLOW) {
 		/* Wait for Start trigger. */
-		*pRPS++ = RPS_PAUSE | RPS_SIGADC;
-		*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
+		*rps++ = RPS_PAUSE | RPS_SIGADC;
+		*rps++ = RPS_CLRSIGNAL | RPS_SIGADC;
 	}
 
 	/*
@@ -989,15 +989,15 @@ static void reset_adc(struct comedi_device *dev, uint8_t *ppl)
 	 * the previously programmed value.
 	 */
 	/* Write DEBI Write command and address to shadow RAM. */
-	*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
-	*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
-	*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
+	*rps++ = RPS_LDREG | (P_DEBICMD >> 2);
+	*rps++ = DEBI_CMD_WRWORD | LP_GSEL;
+	*rps++ = RPS_LDREG | (P_DEBIAD >> 2);
 	/* Write DEBI immediate data  to shadow RAM: */
-	*pRPS++ = GSEL_BIPOLAR5V;	/* arbitrary immediate data  value. */
-	*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
+	*rps++ = GSEL_BIPOLAR5V;	/* arbitrary immediate data  value. */
+	*rps++ = RPS_CLRSIGNAL | RPS_DEBI;
 	/* Reset "shadow RAM  uploaded" flag. */
-	*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/* Invoke shadow RAM upload. */
-	*pRPS++ = RPS_PAUSE | RPS_DEBI;	/* Wait for shadow upload to finish. */
+	*rps++ = RPS_UPLOAD | RPS_DEBI;	/* Invoke shadow RAM upload. */
+	*rps++ = RPS_PAUSE | RPS_DEBI;	/* Wait for shadow upload to finish. */
 
 	/*
 	 * Digitize all slots in the poll list. This is implemented as a
@@ -1012,35 +1012,35 @@ static void reset_adc(struct comedi_device *dev, uint8_t *ppl)
 		 * (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
 		 * +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
 		 */
-		LocalPPL = (*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
-					  GSEL_BIPOLAR10V);
+		local_ppl = (*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
+					   GSEL_BIPOLAR10V);
 
 		/* Switch ADC analog gain. */
 		/* Write DEBI command and address to shadow RAM. */
-		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
-		*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
+		*rps++ = RPS_LDREG | (P_DEBICMD >> 2);
+		*rps++ = DEBI_CMD_WRWORD | LP_GSEL;
 		/* Write DEBI immediate data to shadow RAM. */
-		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
-		*pRPS++ = LocalPPL;
+		*rps++ = RPS_LDREG | (P_DEBIAD >> 2);
+		*rps++ = local_ppl;
 		/* Reset "shadow RAM uploaded" flag. */
-		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
+		*rps++ = RPS_CLRSIGNAL | RPS_DEBI;
 		/* Invoke shadow RAM upload. */
-		*pRPS++ = RPS_UPLOAD | RPS_DEBI;
+		*rps++ = RPS_UPLOAD | RPS_DEBI;
 		/* Wait for shadow upload to finish. */
-		*pRPS++ = RPS_PAUSE | RPS_DEBI;
+		*rps++ = RPS_PAUSE | RPS_DEBI;
 		/* Select ADC analog input channel. */
-		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
+		*rps++ = RPS_LDREG | (P_DEBICMD >> 2);
 		/* Write DEBI command and address to shadow RAM. */
-		*pRPS++ = DEBI_CMD_WRWORD | LP_ISEL;
-		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
+		*rps++ = DEBI_CMD_WRWORD | LP_ISEL;
+		*rps++ = RPS_LDREG | (P_DEBIAD >> 2);
 		/* Write DEBI immediate data to shadow RAM. */
-		*pRPS++ = LocalPPL;
+		*rps++ = local_ppl;
 		/* Reset "shadow RAM uploaded" flag. */
-		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
+		*rps++ = RPS_CLRSIGNAL | RPS_DEBI;
 		/* Invoke shadow RAM upload. */
-		*pRPS++ = RPS_UPLOAD | RPS_DEBI;
+		*rps++ = RPS_UPLOAD | RPS_DEBI;
 		/* Wait for shadow upload to finish. */
-		*pRPS++ = RPS_PAUSE | RPS_DEBI;
+		*rps++ = RPS_PAUSE | RPS_DEBI;
 
 		/*
 		 * Delay at least 10 microseconds for analog input settling.
@@ -1049,42 +1049,42 @@ static void reset_adc(struct comedi_device *dev, uint8_t *ppl)
 		 * possible with NOPs because each RPS_JUMP flushes the RPS'
 		 * instruction prefetch pipeline.
 		 */
-		JmpAdrs =
+		jmp_adrs =
 			(uint32_t)devpriv->rps_buf.physical_base +
-			(uint32_t)((unsigned long)pRPS -
+			(uint32_t)((unsigned long)rps -
 				   (unsigned long)devpriv->
 						  rps_buf.logical_base);
 		for (i = 0; i < (10 * RPSCLK_PER_US / 2); i++) {
-			JmpAdrs += 8;	/* Repeat to implement time delay: */
-			*pRPS++ = RPS_JUMP; /* Jump to next RPS instruction. */
-			*pRPS++ = JmpAdrs;
+			jmp_adrs += 8;	/* Repeat to implement time delay: */
+			*rps++ = RPS_JUMP; /* Jump to next RPS instruction. */
+			*rps++ = jmp_adrs;
 		}
 
 		if (cmd != NULL && cmd->convert_src != TRIG_NOW) {
 			/* Wait for Start trigger. */
-			*pRPS++ = RPS_PAUSE | RPS_SIGADC;
-			*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
+			*rps++ = RPS_PAUSE | RPS_SIGADC;
+			*rps++ = RPS_CLRSIGNAL | RPS_SIGADC;
 		}
 		/* Start ADC by pulsing GPIO1. */
 		/* Begin ADC Start pulse. */
-		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);
-		*pRPS++ = GPIO_BASE | GPIO1_LO;
-		*pRPS++ = RPS_NOP;
+		*rps++ = RPS_LDREG | (P_GPIO >> 2);
+		*rps++ = GPIO_BASE | GPIO1_LO;
+		*rps++ = RPS_NOP;
 		/* VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
 		/* End ADC Start pulse. */
-		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);
-		*pRPS++ = GPIO_BASE | GPIO1_HI;
+		*rps++ = RPS_LDREG | (P_GPIO >> 2);
+		*rps++ = GPIO_BASE | GPIO1_HI;
 		/*
 		 * Wait for ADC to complete (GPIO2 is asserted high when ADC not
 		 * busy) and for data from previous conversion to shift into FB
 		 * BUFFER 1 register.
 		 */
-		*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/* Wait for ADC done. */
+		*rps++ = RPS_PAUSE | RPS_GPIO2;	/* Wait for ADC done. */
 
 		/* Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
-		*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
-		*pRPS++ = (uint32_t)devpriv->ana_buf.physical_base +
-			  (devpriv->adc_items << 2);
+		*rps++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
+		*rps++ = (uint32_t)devpriv->ana_buf.physical_base +
+			 (devpriv->adc_items << 2);
 
 		/*
 		 * If this slot's EndOfPollList flag is set, all channels have
@@ -1105,41 +1105,41 @@ static void reset_adc(struct comedi_device *dev, uint8_t *ppl)
 	 * is sometimes set to the previous conversion's data value.
 	 */
 	for (n = 0; n < (2 * RPSCLK_PER_US); n++)
-		*pRPS++ = RPS_NOP;
+		*rps++ = RPS_NOP;
 
 	/*
 	 * Start a dummy conversion to cause the data from the last
 	 * conversion of interest to be shifted in.
 	 */
-	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/* Begin ADC Start pulse. */
-	*pRPS++ = GPIO_BASE | GPIO1_LO;
-	*pRPS++ = RPS_NOP;
+	*rps++ = RPS_LDREG | (P_GPIO >> 2);	/* Begin ADC Start pulse. */
+	*rps++ = GPIO_BASE | GPIO1_LO;
+	*rps++ = RPS_NOP;
 	/* VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
-	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/* End ADC Start pulse. */
-	*pRPS++ = GPIO_BASE | GPIO1_HI;
+	*rps++ = RPS_LDREG | (P_GPIO >> 2);	/* End ADC Start pulse. */
+	*rps++ = GPIO_BASE | GPIO1_HI;
 
 	/*
 	 * Wait for the data from the last conversion of interest to arrive
 	 * in FB BUFFER 1 register.
 	 */
-	*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/* Wait for ADC done. */
+	*rps++ = RPS_PAUSE | RPS_GPIO2;	/* Wait for ADC done. */
 
 	/* Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
-	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
-	*pRPS++ = (uint32_t)devpriv->ana_buf.physical_base +
-		  (devpriv->adc_items << 2);
+	*rps++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
+	*rps++ = (uint32_t)devpriv->ana_buf.physical_base +
+		 (devpriv->adc_items << 2);
 
 	/* Indicate ADC scan loop is finished. */
 	/* Signal ReadADC() that scan is done. */
-	/* *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC; */
+	/* *rps++= RPS_CLRSIGNAL | RPS_SIGADC; */
 
 	/* invoke interrupt */
 	if (devpriv->ai_cmd_running == 1)
-		*pRPS++ = RPS_IRQ;
+		*rps++ = RPS_IRQ;
 
 	/* Restart RPS program at its beginning. */
-	*pRPS++ = RPS_JUMP;	/* Branch to start of RPS program. */
-	*pRPS++ = (uint32_t)devpriv->rps_buf.physical_base;
+	*rps++ = RPS_JUMP;	/* Branch to start of RPS program. */
+	*rps++ = (uint32_t)devpriv->rps_buf.physical_base;
 
 	/* End of RPS program build */
 }
@@ -1188,8 +1188,8 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	struct s626_private *devpriv = dev->private;
 	uint16_t chan = CR_CHAN(insn->chanspec);
 	uint16_t range = CR_RANGE(insn->chanspec);
-	uint16_t AdcSpec = 0;
-	uint32_t GpioImage;
+	uint16_t adc_spec = 0;
+	uint32_t gpio_image;
 	int tmp;
 	int n;
 
@@ -1198,29 +1198,29 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	 *  appropriate for register programming.
 	 */
 	if (range == 0)
-		AdcSpec = (chan << 8) | (GSEL_BIPOLAR5V);
+		adc_spec = (chan << 8) | (GSEL_BIPOLAR5V);
 	else
-		AdcSpec = (chan << 8) | (GSEL_BIPOLAR10V);
+		adc_spec = (chan << 8) | (GSEL_BIPOLAR10V);
 
 	/* Switch ADC analog gain. */
-	debi_write(dev, LP_GSEL, AdcSpec);	/* Set gain. */
+	debi_write(dev, LP_GSEL, adc_spec);	/* Set gain. */
 
 	/* Select ADC analog input channel. */
-	debi_write(dev, LP_ISEL, AdcSpec);	/* Select channel. */
+	debi_write(dev, LP_ISEL, adc_spec);	/* Select channel. */
 
 	for (n = 0; n < insn->n; n++) {
 		/* Delay 10 microseconds for analog input settling. */
 		udelay(10);
 
 		/* Start ADC by pulsing GPIO1 low */
-		GpioImage = readl(devpriv->mmio + P_GPIO);
+		gpio_image = readl(devpriv->mmio + P_GPIO);
 		/* Assert ADC Start command */
-		writel(GpioImage & ~GPIO1_HI, devpriv->mmio + P_GPIO);
+		writel(gpio_image & ~GPIO1_HI, devpriv->mmio + P_GPIO);
 		/* and stretch it out */
-		writel(GpioImage & ~GPIO1_HI, devpriv->mmio + P_GPIO);
-		writel(GpioImage & ~GPIO1_HI, devpriv->mmio + P_GPIO);
+		writel(gpio_image & ~GPIO1_HI, devpriv->mmio + P_GPIO);
+		writel(gpio_image & ~GPIO1_HI, devpriv->mmio + P_GPIO);
 		/* Negate ADC Start command */
-		writel(GpioImage | GPIO1_HI, devpriv->mmio + P_GPIO);
+		writel(gpio_image | GPIO1_HI, devpriv->mmio + P_GPIO);
 
 		/*
 		 * Wait for ADC to complete (GPIO2 is asserted high when
@@ -1254,14 +1254,14 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	 * Start a dummy conversion to cause the data from the
 	 * previous conversion to be shifted in.
 	 */
-	GpioImage = readl(devpriv->mmio + P_GPIO);
+	gpio_image = readl(devpriv->mmio + P_GPIO);
 	/* Assert ADC Start command */
-	writel(GpioImage & ~GPIO1_HI, devpriv->mmio + P_GPIO);
+	writel(gpio_image & ~GPIO1_HI, devpriv->mmio + P_GPIO);
 	/* and stretch it out */
-	writel(GpioImage & ~GPIO1_HI, devpriv->mmio + P_GPIO);
-	writel(GpioImage & ~GPIO1_HI, devpriv->mmio + P_GPIO);
+	writel(gpio_image & ~GPIO1_HI, devpriv->mmio + P_GPIO);
+	writel(gpio_image & ~GPIO1_HI, devpriv->mmio + P_GPIO);
 	/* Negate ADC Start command */
-	writel(GpioImage | GPIO1_HI, devpriv->mmio + P_GPIO);
+	writel(gpio_image | GPIO1_HI, devpriv->mmio + P_GPIO);
 
 	/* Wait for the data to arrive in FB BUFFER 1 register. */
 
@@ -1343,7 +1343,7 @@ static int s626_ns_to_timer(int *nanosec, int round_mode)
 static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 			    int tick)
 {
-	uint16_t Setup =
+	uint16_t setup =
 		(LOADSRC_INDX << BF_LOADSRC) |	/* Preload upon index. */
 		(INDXSRC_SOFT << BF_INDXSRC) |	/* Disable hardware index. */
 		(CLKSRC_TIMER << BF_CLKSRC) |	/* Operating mode is Timer. */
@@ -1351,10 +1351,10 @@ static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 		(CNTDIR_DOWN << BF_CLKPOL) |	/* Count direction is Down. */
 		(CLKMULT_1X << BF_CLKMULT) |	/* Clock multiplier is 1x. */
 		(CLKENAB_INDEX << BF_CLKENAB);
-	uint16_t valueSrclatch = LATCHSRC_A_INDXA;
+	uint16_t value_latchsrc = LATCHSRC_A_INDXA;
 	/* uint16_t enab = CLKENAB_ALWAYS; */
 
-	k->set_mode(dev, k, Setup, FALSE);
+	k->set_mode(dev, k, setup, FALSE);
 
 	/* Set the preload register */
 	preload(dev, k, tick);
@@ -1372,7 +1372,7 @@ static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 	/* set interrupt on overflow */
 	k->set_int_src(dev, k, INTSRC_OVER);
 
-	set_latch_source(dev, k, valueSrclatch);
+	set_latch_source(dev, k, value_latchsrc);
 	/* k->set_enable(dev, k, (uint16_t)(enab != 0)); */
 }
 
@@ -1729,25 +1729,25 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
-	uint16_t Setup =
+	uint16_t setup =
 		(LOADSRC_INDX << BF_LOADSRC) |	/* Preload upon index. */
 		(INDXSRC_SOFT << BF_INDXSRC) |	/* Disable hardware index. */
 		(CLKSRC_COUNTER << BF_CLKSRC) |	/* Operating mode is Counter. */
 		(CLKPOL_POS << BF_CLKPOL) |	/* Active high clock. */
 		(CLKMULT_1X << BF_CLKMULT) |	/* Clock multiplier is 1x. */
 		(CLKENAB_INDEX << BF_CLKENAB);
-	/* uint16_t DisableIntSrc = TRUE; */
+	/* uint16_t disable_int_src = TRUE; */
 	/* uint32_t Preloadvalue;              //Counter initial value */
-	uint16_t valueSrclatch = LATCHSRC_AB_READ;
+	uint16_t value_latchsrc = LATCHSRC_AB_READ;
 	uint16_t enab = CLKENAB_ALWAYS;
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
 	/* (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
-	k->set_mode(dev, k, Setup, TRUE);
+	k->set_mode(dev, k, setup, TRUE);
 	preload(dev, k, data[0]);
 	k->pulse_index(dev, k);
-	set_latch_source(dev, k, valueSrclatch);
+	set_latch_source(dev, k, value_latchsrc);
 	k->set_enable(dev, k, (enab != 0));
 
 	return insn->n;
@@ -1786,10 +1786,10 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 	return 1;
 }
 
-static void write_misc2(struct comedi_device *dev, uint16_t NewImage)
+static void write_misc2(struct comedi_device *dev, uint16_t new_image)
 {
 	debi_write(dev, LP_MISC1, MISC1_WENABLE); /* Enable writes to MISC2. */
-	debi_write(dev, LP_WRMISC2, NewImage);	/* Write new image to MISC2. */
+	debi_write(dev, LP_WRMISC2, new_image);	/* Write new image to MISC2. */
 	debi_write(dev, LP_MISC1, MISC1_WDISABLE); /* Disable writes to MISC2 */
 }
 
@@ -1958,7 +1958,7 @@ static uint16_t get_mode_b(struct comedi_device *dev, struct enc_private *k)
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
 static void set_mode_a(struct comedi_device *dev, struct enc_private *k,
-		       uint16_t setup, uint16_t DisableIntSrc)
+		       uint16_t setup, uint16_t disable_int_src)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t cra;
@@ -1976,8 +1976,8 @@ static void set_mode_a(struct comedi_device *dev, struct enc_private *k,
 	/* Clock enable is passed through. */
 	crb |= (setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB);
 
-	/* Force IntSrc to Disabled if DisableIntSrc is asserted. */
-	if (!DisableIntSrc)
+	/* Force IntSrc to Disabled if disable_int_src is asserted. */
+	if (!disable_int_src)
 		cra |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
 						    CRABIT_INTSRC_A));
 
@@ -2024,7 +2024,7 @@ static void set_mode_a(struct comedi_device *dev, struct enc_private *k,
 	 * If IntSrc has been forced to Disabled, update the MISC2 interrupt
 	 * enable mask to indicate the counter interrupt is disabled.
 	 */
-	if (DisableIntSrc)
+	if (disable_int_src)
 		devpriv->counter_int_enabs &= ~k->my_event_bits[3];
 
 	/*
@@ -2036,7 +2036,7 @@ static void set_mode_a(struct comedi_device *dev, struct enc_private *k,
 }
 
 static void set_mode_b(struct comedi_device *dev, struct enc_private *k,
-		       uint16_t setup, uint16_t DisableIntSrc)
+		       uint16_t setup, uint16_t disable_int_src)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t cra;
@@ -2054,8 +2054,8 @@ static void set_mode_b(struct comedi_device *dev, struct enc_private *k,
 	/* Preload trigger source is passed through. */
 	crb |= (setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B);
 
-	/* Force IntSrc to Disabled if DisableIntSrc is asserted. */
-	if (!DisableIntSrc)
+	/* Force IntSrc to Disabled if disable_int_src is asserted. */
+	if (!disable_int_src)
 		crb |= (setup & STDMSK_INTSRC) >>
 		       (STDBIT_INTSRC - CRBBIT_INTSRC_B);
 
@@ -2110,7 +2110,7 @@ static void set_mode_b(struct comedi_device *dev, struct enc_private *k,
 	 * If IntSrc has been forced to Disabled, update the MISC2 interrupt
 	 * enable mask to indicate the counter interrupt is disabled.
 	 */
-	if (DisableIntSrc)
+	if (disable_int_src)
 		devpriv->counter_int_enabs &= ~k->my_event_bits[3];
 
 	/*
@@ -2163,17 +2163,17 @@ static uint16_t get_latch_source(struct comedi_device *dev,
  * 2=OverflowA (B counters only), 3=disabled.
  */
 static void set_load_trig_a(struct comedi_device *dev, struct enc_private *k,
-			    uint16_t Trig)
+			    uint16_t trig)
 {
 	debi_replace(dev, k->my_cra, ~CRAMSK_LOADSRC_A,
-		     Trig << CRABIT_LOADSRC_A);
+		     trig << CRABIT_LOADSRC_A);
 }
 
 static void set_load_trig_b(struct comedi_device *dev, struct enc_private *k,
-			    uint16_t Trig)
+			    uint16_t trig)
 {
 	debi_replace(dev, k->my_crb, ~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL),
-		     Trig << CRBBIT_LOADSRC_B);
+		     trig << CRBBIT_LOADSRC_B);
 }
 
 static uint16_t get_load_trig_a(struct comedi_device *dev,
@@ -2190,11 +2190,11 @@ static uint16_t get_load_trig_b(struct comedi_device *dev,
 
 /*
  * Return/set counter interrupt source and clear any captured
- * index/overflow events.  IntSource: 0=Disabled, 1=OverflowOnly,
+ * index/overflow events.  int_source: 0=Disabled, 1=OverflowOnly,
  * 2=IndexOnly, 3=IndexAndOverflow.
  */
 static void set_int_src_a(struct comedi_device *dev, struct enc_private *k,
-			  uint16_t IntSource)
+			  uint16_t int_source)
 {
 	struct s626_private *devpriv = dev->private;
 
@@ -2204,16 +2204,16 @@ static void set_int_src_a(struct comedi_device *dev, struct enc_private *k,
 
 	/* Program counter interrupt source. */
 	debi_replace(dev, k->my_cra, ~CRAMSK_INTSRC_A,
-		     IntSource << CRABIT_INTSRC_A);
+		     int_source << CRABIT_INTSRC_A);
 
 	/* Update MISC2 interrupt enable mask. */
 	devpriv->counter_int_enabs =
 	    (devpriv->counter_int_enabs & ~k->my_event_bits[3]) |
-	    k->my_event_bits[IntSource];
+	    k->my_event_bits[int_source];
 }
 
 static void set_int_src_b(struct comedi_device *dev, struct enc_private *k,
-			  uint16_t IntSource)
+			  uint16_t int_source)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t crb;
@@ -2228,12 +2228,12 @@ static void set_int_src_b(struct comedi_device *dev, struct enc_private *k,
 	/* Program counter interrupt source. */
 	debi_write(dev, k->my_crb,
 		   (uint16_t)((crb & ~CRBMSK_INTSRC_B) |
-			      (IntSource << CRBBIT_INTSRC_B)));
+			      (int_source << CRBBIT_INTSRC_B)));
 
 	/* Update MISC2 interrupt enable mask. */
 	devpriv->counter_int_enabs =
 		(devpriv->counter_int_enabs & ~k->my_event_bits[3]) |
-		k->my_event_bits[IntSource];
+		k->my_event_bits[int_source];
 }
 
 static uint16_t get_int_src_a(struct comedi_device *dev, struct enc_private *k)
@@ -2444,7 +2444,7 @@ static void counters_init(struct comedi_device *dev)
 {
 	int chan;
 	struct enc_private *k;
-	uint16_t Setup =
+	uint16_t setup =
 		(LOADSRC_INDX << BF_LOADSRC) |	/* Preload upon index. */
 		(INDXSRC_SOFT << BF_INDXSRC) |	/* Disable hardware index. */
 		(CLKSRC_COUNTER << BF_CLKSRC) |	/* Operating mode is counter. */
@@ -2458,7 +2458,7 @@ static void counters_init(struct comedi_device *dev)
 	 */
 	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
 		k = &encpriv[chan];
-		k->set_mode(dev, k, Setup, TRUE);
+		k->set_mode(dev, k, setup, TRUE);
 		k->set_int_src(dev, k, 0);
 		k->reset_cap_flags(dev, k);
 		k->set_enable(dev, k, CLKENAB_ALWAYS);
@@ -2490,7 +2490,7 @@ static int s626_allocate_dma_buffers(struct comedi_device *dev)
 static void s626_initialize(struct comedi_device *dev)
 {
 	struct s626_private *devpriv = dev->private;
-	dma_addr_t pPhysBuf;
+	dma_addr_t phys_buf;
 	uint16_t chan;
 	int i;
 
@@ -2580,19 +2580,19 @@ static void s626_initialize(struct comedi_device *dev)
 	 * a defined state after a PCI reset.
 	 */
 	{
-		uint8_t PollList;
-		uint16_t AdcData;
-		uint16_t StartVal;
+		uint8_t poll_list;
+		uint16_t adc_data;
+		uint16_t start_val;
 		uint16_t index;
 		unsigned int data[16];
 
 		/* Create a simple polling list for analog input channel 0 */
-		PollList = EOPL;
-		reset_adc(dev, &PollList);
+		poll_list = EOPL;
+		reset_adc(dev, &poll_list);
 
 		/* Get initial ADC value */
 		s626_ai_rinsn(dev, dev->subdevices, NULL, data);
-		StartVal = data[0];
+		start_val = data[0];
 
 		/*
 		 * VERSION 2.01 CHANGE: TIMEOUT ADDED TO PREVENT HANGED
@@ -2606,8 +2606,8 @@ static void s626_initialize(struct comedi_device *dev)
 		 */
 		for (index = 0; index < 500; index++) {
 			s626_ai_rinsn(dev, dev->subdevices, NULL, data);
-			AdcData = data[0];
-			if (AdcData != StartVal)
+			adc_data = data[0];
+			if (adc_data != start_val)
 				break;
 		}
 	}
@@ -2630,10 +2630,10 @@ static void s626_initialize(struct comedi_device *dev)
 	 * single DWORD will be transferred each time a DMA transfer is
 	 * enabled.
 	 */
-	pPhysBuf = devpriv->ana_buf.physical_base +
+	phys_buf = devpriv->ana_buf.physical_base +
 		   (DAC_WDMABUF_OS * sizeof(uint32_t));
-	writel((uint32_t)pPhysBuf, devpriv->mmio + P_BASEA2_OUT);
-	writel((uint32_t)(pPhysBuf + sizeof(uint32_t)),
+	writel((uint32_t)phys_buf, devpriv->mmio + P_BASEA2_OUT);
+	writel((uint32_t)(phys_buf + sizeof(uint32_t)),
 	       devpriv->mmio + P_PROTA2_OUT);
 
 	/*

commit 19436a0dd7f4b20d736ec8e7c5d4d926de92d760
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:28 2013 +0100

    staging: comedi: s626: rename CamelCase functions
    
    Rename the remaining non-lower-case functions.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 12ebc85f85d3..6093ca3af5d3 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -196,7 +196,7 @@ static const struct comedi_lrange s626_range_table = {
 /*
  * Execute a DEBI transfer.  This must be called from within a critical section.
  */
-static void DEBItransfer(struct comedi_device *dev)
+static void debi_transfer(struct comedi_device *dev)
 {
 	struct s626_private *devpriv = dev->private;
 
@@ -218,7 +218,7 @@ static void DEBItransfer(struct comedi_device *dev)
 /*
  * Read a value from a gate array register.
  */
-static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
+static uint16_t debi_read(struct comedi_device *dev, uint16_t addr)
 {
 	struct s626_private *devpriv = dev->private;
 
@@ -226,7 +226,7 @@ static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
 	writel(DEBI_CMD_RDWORD | addr, devpriv->mmio + P_DEBICMD);
 
 	/*  Execute the DEBI transfer. */
-	DEBItransfer(dev);
+	debi_transfer(dev);
 
 	return readl(devpriv->mmio + P_DEBIAD);
 }
@@ -234,7 +234,7 @@ static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
 /*
  * Write a value to a gate array register.
  */
-static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
+static void debi_write(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
 {
 	struct s626_private *devpriv = dev->private;
 
@@ -243,7 +243,7 @@ static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
 	writel(wdata, devpriv->mmio + P_DEBIAD);
 
 	/*  Execute the DEBI transfer. */
-	DEBItransfer(dev);
+	debi_transfer(dev);
 }
 
 /*
@@ -251,27 +251,27 @@ static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
  * specifies bits that are to be preserved, wdata is new value to be
  * or'd with the masked original.
  */
-static void DEBIreplace(struct comedi_device *dev, unsigned int addr,
-			unsigned int mask, unsigned int wdata)
+static void debi_replace(struct comedi_device *dev, unsigned int addr,
+			 unsigned int mask, unsigned int wdata)
 {
 	struct s626_private *devpriv = dev->private;
 	unsigned int val;
 
 	addr &= 0xffff;
 	writel(DEBI_CMD_RDWORD | addr, devpriv->mmio + P_DEBICMD);
-	DEBItransfer(dev);
+	debi_transfer(dev);
 
 	writel(DEBI_CMD_WRWORD | addr, devpriv->mmio + P_DEBICMD);
 	val = readl(devpriv->mmio + P_DEBIAD);
 	val &= mask;
 	val |= wdata;
 	writel(val & 0xffff, devpriv->mmio + P_DEBIAD);
-	DEBItransfer(dev);
+	debi_transfer(dev);
 }
 
 /* **************  EEPROM ACCESS FUNCTIONS  ************** */
 
-static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
+static uint32_t i2c_handshake(struct comedi_device *dev, uint32_t val)
 {
 	struct s626_private *devpriv = dev->private;
 	unsigned int ctrl;
@@ -297,7 +297,7 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 }
 
 /* Read uint8_t from EEPROM. */
-static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
+static uint8_t i2c_read(struct comedi_device *dev, uint8_t addr)
 {
 	struct s626_private *devpriv = dev->private;
 
@@ -307,9 +307,9 @@ static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 	 *  Byte1 = EEPROM internal target address.
 	 *  Byte0 = Not sent.
 	 */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, devpriv->i2c_adrs) |
-			      I2C_B1(I2C_ATTRSTOP, addr) |
-			      I2C_B0(I2C_ATTRNOP, 0)))
+	if (i2c_handshake(dev, I2C_B2(I2C_ATTRSTART, devpriv->i2c_adrs) |
+			       I2C_B1(I2C_ATTRSTOP, addr) |
+			       I2C_B0(I2C_ATTRNOP, 0)))
 		/* Abort function and declare error if handshake failed. */
 		return 0;
 
@@ -319,9 +319,9 @@ static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 	 *  Byte1 receives uint8_t from EEPROM.
 	 *  Byte0 = Not sent.
 	 */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, (devpriv->i2c_adrs | 1)) |
-			      I2C_B1(I2C_ATTRSTOP, 0) |
-			      I2C_B0(I2C_ATTRNOP, 0)))
+	if (i2c_handshake(dev, I2C_B2(I2C_ATTRSTART, (devpriv->i2c_adrs | 1)) |
+			       I2C_B1(I2C_ATTRSTOP, 0) |
+			       I2C_B0(I2C_ATTRNOP, 0)))
 		/* Abort function and declare error if handshake failed. */
 		return 0;
 
@@ -347,7 +347,7 @@ static uint8_t trimadrs[] = {
  * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
  * dacpol contains valid target image.
  */
-static void SendDAC(struct comedi_device *dev, uint32_t val)
+static void send_dac(struct comedi_device *dev, uint32_t val)
 {
 	struct s626_private *devpriv = dev->private;
 
@@ -358,12 +358,12 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * and audio bit stream signals.  At this point in time we must be
 	 * assured of being in time slot 0.  If we are not in slot 0, the
 	 * serial clock and audio stream signals will be disabled; this is
-	 * because the following DEBIwrite statement (which enables signals
+	 * because the following debi_write statement (which enables signals
 	 * to be passed through the gate array) would execute before the
 	 * trailing edge of WS1/WS3 (which turns off the signals), thus
 	 * causing the signals to be inactive during the DAC write.
 	 */
-	DEBIwrite(dev, LP_DACPOL, devpriv->dacpol);
+	debi_write(dev, LP_DACPOL, devpriv->dacpol);
 
 	/* TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- */
 
@@ -482,7 +482,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 /*
  * Private helper function: Write setpoint to an application DAC channel.
  */
-static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
+static void set_dac(struct comedi_device *dev, uint16_t chan, short dacdata)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t signmask;
@@ -540,11 +540,11 @@ static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
 	val |= ((uint32_t)(chan & 1) << 15);	/* Address the DAC channel
 						 * within the device. */
 	val |= (uint32_t)dacdata;	/* Include DAC setpoint data. */
-	SendDAC(dev, val);
+	send_dac(dev, val);
 }
 
-static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
-			 uint8_t DacData)
+static void write_trim_dac(struct comedi_device *dev, uint8_t LogicalChan,
+			   uint8_t DacData)
 {
 	struct s626_private *devpriv = dev->private;
 	uint32_t chan;
@@ -586,16 +586,16 @@ static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
 	 * Address the DAC channel within the trimdac device.
 	 * Include DAC setpoint data.
 	 */
-	SendDAC(dev, (chan << 8) | DacData);
+	send_dac(dev, (chan << 8) | DacData);
 }
 
-static void LoadTrimDACs(struct comedi_device *dev)
+static void load_trim_dacs(struct comedi_device *dev)
 {
 	uint8_t i;
 
 	/* Copy TrimDac setpoint values from EEPROM to TrimDacs. */
 	for (i = 0; i < ARRAY_SIZE(trimchan); i++)
-		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
+		write_trim_dac(dev, i, i2c_read(dev, trimadrs[i]));
 }
 
 /* ******  COUNTER FUNCTIONS  ******* */
@@ -610,15 +610,15 @@ static void LoadTrimDACs(struct comedi_device *dev)
 /*
  * Read a counter's output latch.
  */
-static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
+static uint32_t read_latch(struct comedi_device *dev, struct enc_private *k)
 {
 	uint32_t value;
 
 	/* Latch counts and fetch LSW of latched counts value. */
-	value = DEBIread(dev, k->my_latch_lsw);
+	value = debi_read(dev, k->my_latch_lsw);
 
 	/* Fetch MSW of latched counts and combine with LSW. */
-	value |= ((uint32_t)DEBIread(dev, k->my_latch_lsw + 2) << 16);
+	value |= ((uint32_t)debi_read(dev, k->my_latch_lsw + 2) << 16);
 
 	/* Return latched counts. */
 	return value;
@@ -629,21 +629,21 @@ static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
  * access, 1: A index latches A, 2: B index latches B, 3: A overflow
  * latches B.
  */
-static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
-			   uint16_t value)
+static void set_latch_source(struct comedi_device *dev, struct enc_private *k,
+			     uint16_t value)
 {
-	DEBIreplace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC),
-		    value << CRBBIT_LATCHSRC);
+	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC),
+		     value << CRBBIT_LATCHSRC);
 }
 
 /*
  * Write value into counter preload register.
  */
-static void Preload(struct comedi_device *dev, struct enc_private *k,
+static void preload(struct comedi_device *dev, struct enc_private *k,
 		    uint32_t value)
 {
-	DEBIwrite(dev, k->my_latch_lsw, value);
-	DEBIwrite(dev, k->my_latch_lsw + 2, value >> 16);
+	debi_write(dev, k->my_latch_lsw, value);
+	debi_write(dev, k->my_latch_lsw + 2, value >> 16);
 }
 
 static unsigned int s626_ai_reg_to_uint(int data)
@@ -666,19 +666,19 @@ static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
 	unsigned int status;
 
 	/* set channel to capture positive edge */
-	status = DEBIread(dev, LP_RDEDGSEL(group));
-	DEBIwrite(dev, LP_WREDGSEL(group), mask | status);
+	status = debi_read(dev, LP_RDEDGSEL(group));
+	debi_write(dev, LP_WREDGSEL(group), mask | status);
 
 	/* enable interrupt on selected channel */
-	status = DEBIread(dev, LP_RDINTSEL(group));
-	DEBIwrite(dev, LP_WRINTSEL(group), mask | status);
+	status = debi_read(dev, LP_RDINTSEL(group));
+	debi_write(dev, LP_WRINTSEL(group), mask | status);
 
 	/* enable edge capture write command */
-	DEBIwrite(dev, LP_MISC1, MISC1_EDCAP);
+	debi_write(dev, LP_MISC1, MISC1_EDCAP);
 
 	/* enable edge capture on selected channel */
-	status = DEBIread(dev, LP_RDCAPSEL(group));
-	DEBIwrite(dev, LP_WRCAPSEL(group), mask | status);
+	status = debi_read(dev, LP_RDCAPSEL(group));
+	debi_write(dev, LP_WRCAPSEL(group), mask | status);
 
 	return 0;
 }
@@ -687,10 +687,10 @@ static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,
 			      unsigned int mask)
 {
 	/* disable edge capture write command */
-	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
+	debi_write(dev, LP_MISC1, MISC1_NOEDCAP);
 
 	/* enable edge capture on selected channel */
-	DEBIwrite(dev, LP_WRCAPSEL(group), mask);
+	debi_write(dev, LP_WRCAPSEL(group), mask);
 
 	return 0;
 }
@@ -700,11 +700,11 @@ static int s626_dio_clear_irq(struct comedi_device *dev)
 	unsigned int group;
 
 	/* disable edge capture write command */
-	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
+	debi_write(dev, LP_MISC1, MISC1_NOEDCAP);
 
 	/* clear all dio pending events and interrupt */
 	for (group = 0; group < S626_DIO_BANKS; group++)
-		DEBIwrite(dev, LP_WRCAPSEL(group), 0xffff);
+		debi_write(dev, LP_WRCAPSEL(group), 0xffff);
 
 	return 0;
 }
@@ -766,7 +766,7 @@ static void check_dio_interrupts(struct comedi_device *dev)
 	for (group = 0; group < S626_DIO_BANKS; group++) {
 		irqbit = 0;
 		/* read interrupt type */
-		irqbit = DEBIread(dev, LP_RDCAPFLG(group));
+		irqbit = debi_read(dev, LP_RDCAPFLG(group));
 
 		/* check if interrupt is generated from dio channels */
 		if (irqbit) {
@@ -786,7 +786,7 @@ static void check_counter_interrupts(struct comedi_device *dev)
 	uint16_t irqbit;
 
 	/* read interrupt type */
-	irqbit = DEBIread(dev, LP_RDMISC2);
+	irqbit = debi_read(dev, LP_RDMISC2);
 
 	/* check interrupt on counters */
 	if (irqbit & IRQ_COINT1A) {
@@ -953,7 +953,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 /*
  * This function builds the RPS program for hardware driven acquisition.
  */
-static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
+static void reset_adc(struct comedi_device *dev, uint8_t *ppl)
 {
 	struct s626_private *devpriv = dev->private;
 	uint32_t *pRPS;
@@ -1203,10 +1203,10 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 		AdcSpec = (chan << 8) | (GSEL_BIPOLAR10V);
 
 	/* Switch ADC analog gain. */
-	DEBIwrite(dev, LP_GSEL, AdcSpec);	/* Set gain. */
+	debi_write(dev, LP_GSEL, AdcSpec);	/* Set gain. */
 
 	/* Select ADC analog input channel. */
-	DEBIwrite(dev, LP_ISEL, AdcSpec);	/* Select channel. */
+	debi_write(dev, LP_ISEL, AdcSpec);	/* Select channel. */
 
 	for (n = 0; n < insn->n; n++) {
 		/* Delay 10 microseconds for analog input settling. */
@@ -1357,7 +1357,7 @@ static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 	k->set_mode(dev, k, Setup, FALSE);
 
 	/* Set the preload register */
-	Preload(dev, k, tick);
+	preload(dev, k, tick);
 
 	/*
 	 * Software index pulse forces the preload register to load
@@ -1372,7 +1372,7 @@ static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 	/* set interrupt on overflow */
 	k->set_int_src(dev, k, INTSRC_OVER);
 
-	SetLatchSource(dev, k, valueSrclatch);
+	set_latch_source(dev, k, valueSrclatch);
 	/* k->set_enable(dev, k, (uint16_t)(enab != 0)); */
 }
 
@@ -1477,7 +1477,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	}
 
-	ResetADC(dev, ppl);
+	reset_adc(dev, ppl);
 
 	switch (cmd->start_src) {
 	case TRIG_NOW:
@@ -1638,7 +1638,7 @@ static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		devpriv->ao_readback[CR_CHAN(insn->chanspec)] = data[i];
 		dacdata -= (0x1fff);
 
-		SetDAC(dev, chan, dacdata);
+		set_dac(dev, chan, dacdata);
 	}
 
 	return i;
@@ -1669,18 +1669,18 @@ static void s626_dio_init(struct comedi_device *dev)
 	uint16_t group;
 
 	/* Prepare to treat writes to WRCapSel as capture disables. */
-	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
+	debi_write(dev, LP_MISC1, MISC1_NOEDCAP);
 
 	/* For each group of sixteen channels ... */
 	for (group = 0; group < S626_DIO_BANKS; group++) {
 		/* Disable all interrupts */
-		DEBIwrite(dev, LP_WRINTSEL(group), 0);
+		debi_write(dev, LP_WRINTSEL(group), 0);
 		/* Disable all event captures */
-		DEBIwrite(dev, LP_WRCAPSEL(group), 0xffff);
+		debi_write(dev, LP_WRCAPSEL(group), 0xffff);
 		/* Init all DIOs to default edge polarity */
-		DEBIwrite(dev, LP_WREDGSEL(group), 0);
+		debi_write(dev, LP_WREDGSEL(group), 0);
 		/* Program all outputs to inactive state */
-		DEBIwrite(dev, LP_WRDOUT(group), 0);
+		debi_write(dev, LP_WRDOUT(group), 0);
 	}
 }
 
@@ -1692,9 +1692,9 @@ static int s626_dio_insn_bits(struct comedi_device *dev,
 	unsigned long group = (unsigned long)s->private;
 
 	if (comedi_dio_update_state(s, data))
-		DEBIwrite(dev, LP_WRDOUT(group), s->state);
+		debi_write(dev, LP_WRDOUT(group), s->state);
 
-	data[1] = DEBIread(dev, LP_RDDIN(group));
+	data[1] = debi_read(dev, LP_RDDIN(group));
 
 	return insn->n;
 }
@@ -1711,7 +1711,7 @@ static int s626_dio_insn_config(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	DEBIwrite(dev, LP_WRDOUT(group), s->io_bits);
+	debi_write(dev, LP_WRDOUT(group), s->io_bits);
 
 	return insn->n;
 }
@@ -1745,9 +1745,9 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 	/* (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
 	k->set_mode(dev, k, Setup, TRUE);
-	Preload(dev, k, data[0]);
+	preload(dev, k, data[0]);
 	k->pulse_index(dev, k);
-	SetLatchSource(dev, k, valueSrclatch);
+	set_latch_source(dev, k, valueSrclatch);
 	k->set_enable(dev, k, (enab != 0));
 
 	return insn->n;
@@ -1761,7 +1761,7 @@ static int s626_enc_insn_read(struct comedi_device *dev,
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
 	for (n = 0; n < insn->n; n++)
-		data[n] = ReadLatch(dev, k);
+		data[n] = read_latch(dev, k);
 
 	return n;
 }
@@ -1773,7 +1773,7 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
 	/* Set the preload register */
-	Preload(dev, k, data[0]);
+	preload(dev, k, data[0]);
 
 	/*
 	 * Software index pulse forces the preload register to load
@@ -1786,15 +1786,15 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 	return 1;
 }
 
-static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
+static void write_misc2(struct comedi_device *dev, uint16_t NewImage)
 {
-	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE); /* Enab writes to MISC2. */
-	DEBIwrite(dev, LP_WRMISC2, NewImage);	/* Write new image to MISC2. */
-	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE); /* Disable writes to MISC2. */
+	debi_write(dev, LP_MISC1, MISC1_WENABLE); /* Enable writes to MISC2. */
+	debi_write(dev, LP_WRMISC2, NewImage);	/* Write new image to MISC2. */
+	debi_write(dev, LP_MISC1, MISC1_WDISABLE); /* Disable writes to MISC2 */
 }
 
-static void CloseDMAB(struct comedi_device *dev, struct buffer_dma *pdma,
-		      size_t bsize)
+static void close_dma_b(struct comedi_device *dev, struct buffer_dma *pdma,
+			size_t bsize)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	void *vbptr;
@@ -1820,14 +1820,14 @@ static void CloseDMAB(struct comedi_device *dev, struct buffer_dma *pdma,
  */
 static void reset_cap_flags_a(struct comedi_device *dev, struct enc_private *k)
 {
-	DEBIreplace(dev, k->my_crb, ~CRBMSK_INTCTRL,
-		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
+		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 }
 
 static void reset_cap_flags_b(struct comedi_device *dev, struct enc_private *k)
 {
-	DEBIreplace(dev, k->my_crb, ~CRBMSK_INTCTRL,
-		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
+	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
+		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
 }
 
 /*
@@ -1841,8 +1841,8 @@ static uint16_t get_mode_a(struct comedi_device *dev, struct enc_private *k)
 	uint16_t setup;
 
 	/* Fetch CRA and CRB register images. */
-	cra = DEBIread(dev, k->my_cra);
-	crb = DEBIread(dev, k->my_crb);
+	cra = debi_read(dev, k->my_cra);
+	crb = debi_read(dev, k->my_crb);
 
 	/*
 	 * Populate the standardized counter setup bit fields.
@@ -1896,8 +1896,8 @@ static uint16_t get_mode_b(struct comedi_device *dev, struct enc_private *k)
 	uint16_t setup;
 
 	/* Fetch CRA and CRB register images. */
-	cra = DEBIread(dev, k->my_cra);
-	crb = DEBIread(dev, k->my_crb);
+	cra = debi_read(dev, k->my_cra);
+	crb = debi_read(dev, k->my_crb);
 
 	/*
 	 * Populate the standardized counter setup bit fields.
@@ -2031,8 +2031,8 @@ static void set_mode_a(struct comedi_device *dev, struct enc_private *k,
 	 * While retaining CounterB and LatchSrc configurations, program the
 	 * new counter operating mode.
 	 */
-	DEBIreplace(dev, k->my_cra, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
-	DEBIreplace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A), crb);
+	debi_replace(dev, k->my_cra, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
+	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A), crb);
 }
 
 static void set_mode_b(struct comedi_device *dev, struct enc_private *k,
@@ -2117,8 +2117,9 @@ static void set_mode_b(struct comedi_device *dev, struct enc_private *k,
 	 * While retaining CounterA and LatchSrc configurations, program the
 	 * new counter operating mode.
 	 */
-	DEBIreplace(dev, k->my_cra, ~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B), cra);
-	DEBIreplace(dev, k->my_crb, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
+	debi_replace(dev, k->my_cra, ~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B),
+		     cra);
+	debi_replace(dev, k->my_crb, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
 }
 
 /*
@@ -2127,32 +2128,32 @@ static void set_mode_b(struct comedi_device *dev, struct enc_private *k,
 static void set_enable_a(struct comedi_device *dev, struct enc_private *k,
 			 uint16_t enab)
 {
-	DEBIreplace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A),
-		    enab << CRBBIT_CLKENAB_A);
+	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A),
+		     enab << CRBBIT_CLKENAB_A);
 }
 
 static void set_enable_b(struct comedi_device *dev, struct enc_private *k,
 			 uint16_t enab)
 {
-	DEBIreplace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B),
-		    enab << CRBBIT_CLKENAB_B);
+	debi_replace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B),
+		     enab << CRBBIT_CLKENAB_B);
 }
 
 static uint16_t get_enable_a(struct comedi_device *dev, struct enc_private *k)
 {
-	return (DEBIread(dev, k->my_crb) >> CRBBIT_CLKENAB_A) & 1;
+	return (debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_A) & 1;
 }
 
 static uint16_t get_enable_b(struct comedi_device *dev, struct enc_private *k)
 {
-	return (DEBIread(dev, k->my_crb) >> CRBBIT_CLKENAB_B) & 1;
+	return (debi_read(dev, k->my_crb) >> CRBBIT_CLKENAB_B) & 1;
 }
 
 #ifdef unused
-static uint16_t GetLatchSource(struct comedi_device *dev,
-			       struct enc_private *k)
+static uint16_t get_latch_source(struct comedi_device *dev,
+				 struct enc_private *k)
 {
-	return (DEBIread(dev, k->my_crb) >> CRBBIT_LATCHSRC) & 3;
+	return (debi_read(dev, k->my_crb) >> CRBBIT_LATCHSRC) & 3;
 }
 #endif
 
@@ -2164,27 +2165,27 @@ static uint16_t GetLatchSource(struct comedi_device *dev,
 static void set_load_trig_a(struct comedi_device *dev, struct enc_private *k,
 			    uint16_t Trig)
 {
-	DEBIreplace(dev, k->my_cra, ~CRAMSK_LOADSRC_A,
-		    Trig << CRABIT_LOADSRC_A);
+	debi_replace(dev, k->my_cra, ~CRAMSK_LOADSRC_A,
+		     Trig << CRABIT_LOADSRC_A);
 }
 
 static void set_load_trig_b(struct comedi_device *dev, struct enc_private *k,
 			    uint16_t Trig)
 {
-	DEBIreplace(dev, k->my_crb, ~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL),
-		    Trig << CRBBIT_LOADSRC_B);
+	debi_replace(dev, k->my_crb, ~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL),
+		     Trig << CRBBIT_LOADSRC_B);
 }
 
 static uint16_t get_load_trig_a(struct comedi_device *dev,
 				struct enc_private *k)
 {
-	return (DEBIread(dev, k->my_cra) >> CRABIT_LOADSRC_A) & 3;
+	return (debi_read(dev, k->my_cra) >> CRABIT_LOADSRC_A) & 3;
 }
 
 static uint16_t get_load_trig_b(struct comedi_device *dev,
 				struct enc_private *k)
 {
-	return (DEBIread(dev, k->my_crb) >> CRBBIT_LOADSRC_B) & 3;
+	return (debi_read(dev, k->my_crb) >> CRBBIT_LOADSRC_B) & 3;
 }
 
 /*
@@ -2198,12 +2199,12 @@ static void set_int_src_a(struct comedi_device *dev, struct enc_private *k,
 	struct s626_private *devpriv = dev->private;
 
 	/* Reset any pending counter overflow or index captures. */
-	DEBIreplace(dev, k->my_crb, ~CRBMSK_INTCTRL,
-		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+	debi_replace(dev, k->my_crb, ~CRBMSK_INTCTRL,
+		     CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 
 	/* Program counter interrupt source. */
-	DEBIreplace(dev, k->my_cra, ~CRAMSK_INTSRC_A,
-		    IntSource << CRABIT_INTSRC_A);
+	debi_replace(dev, k->my_cra, ~CRAMSK_INTSRC_A,
+		     IntSource << CRABIT_INTSRC_A);
 
 	/* Update MISC2 interrupt enable mask. */
 	devpriv->counter_int_enabs =
@@ -2218,16 +2219,16 @@ static void set_int_src_b(struct comedi_device *dev, struct enc_private *k,
 	uint16_t crb;
 
 	/* Cache writeable CRB register image. */
-	crb = DEBIread(dev, k->my_crb) & ~CRBMSK_INTCTRL;
+	crb = debi_read(dev, k->my_crb) & ~CRBMSK_INTCTRL;
 
 	/* Reset any pending counter overflow or index captures. */
-	DEBIwrite(dev, k->my_crb,
-		  (uint16_t)(crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
+	debi_write(dev, k->my_crb,
+		   (uint16_t)(crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
 
 	/* Program counter interrupt source. */
-	DEBIwrite(dev, k->my_crb,
-		  (uint16_t)((crb & ~CRBMSK_INTSRC_B) |
-			     (IntSource << CRBBIT_INTSRC_B)));
+	debi_write(dev, k->my_crb,
+		   (uint16_t)((crb & ~CRBMSK_INTSRC_B) |
+			      (IntSource << CRBBIT_INTSRC_B)));
 
 	/* Update MISC2 interrupt enable mask. */
 	devpriv->counter_int_enabs =
@@ -2237,26 +2238,26 @@ static void set_int_src_b(struct comedi_device *dev, struct enc_private *k,
 
 static uint16_t get_int_src_a(struct comedi_device *dev, struct enc_private *k)
 {
-	return (DEBIread(dev, k->my_cra) >> CRABIT_INTSRC_A) & 3;
+	return (debi_read(dev, k->my_cra) >> CRABIT_INTSRC_A) & 3;
 }
 
 static uint16_t get_int_src_b(struct comedi_device *dev, struct enc_private *k)
 {
-	return (DEBIread(dev, k->my_crb) >> CRBBIT_INTSRC_B) & 3;
+	return (debi_read(dev, k->my_crb) >> CRBBIT_INTSRC_B) & 3;
 }
 
 #ifdef unused
 /*
  * Return/set the clock multiplier.
  */
-static void SetClkMult(struct comedi_device *dev, struct enc_private *k,
-		       uint16_t value)
+static void set_clk_mult(struct comedi_device *dev, struct enc_private *k,
+			 uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKMULT) |
 			    (value << STDBIT_CLKMULT)), FALSE);
 }
 
-static uint16_t GetClkMult(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_clk_mult(struct comedi_device *dev, struct enc_private *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_CLKMULT) & 3;
 }
@@ -2264,14 +2265,14 @@ static uint16_t GetClkMult(struct comedi_device *dev, struct enc_private *k)
 /*
  * Return/set the clock polarity.
  */
-static void SetClkPol(struct comedi_device *dev, struct enc_private *k,
-		      uint16_t value)
+static void set_clk_pol(struct comedi_device *dev, struct enc_private *k,
+			uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKPOL) |
 			    (value << STDBIT_CLKPOL)), FALSE);
 }
 
-static uint16_t GetClkPol(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_clk_pol(struct comedi_device *dev, struct enc_private *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_CLKPOL) & 1;
 }
@@ -2279,14 +2280,14 @@ static uint16_t GetClkPol(struct comedi_device *dev, struct enc_private *k)
 /*
  * Return/set the clock source.
  */
-static void SetClkSrc(struct comedi_device *dev, struct enc_private *k,
-		      uint16_t value)
+static void set_clk_src(struct comedi_device *dev, struct enc_private *k,
+			uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKSRC) |
 			    (value << STDBIT_CLKSRC)), FALSE);
 }
 
-static uint16_t GetClkSrc(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_clk_src(struct comedi_device *dev, struct enc_private *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_CLKSRC) & 3;
 }
@@ -2294,14 +2295,14 @@ static uint16_t GetClkSrc(struct comedi_device *dev, struct enc_private *k)
 /*
  * Return/set the index polarity.
  */
-static void SetIndexPol(struct comedi_device *dev, struct enc_private *k,
-			uint16_t value)
+static void set_index_pol(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXPOL) |
 			    ((value != 0) << STDBIT_INDXPOL)), FALSE);
 }
 
-static uint16_t GetIndexPol(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_index_pol(struct comedi_device *dev, struct enc_private *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_INDXPOL) & 1;
 }
@@ -2309,14 +2310,14 @@ static uint16_t GetIndexPol(struct comedi_device *dev, struct enc_private *k)
 /*
  * Return/set the index source.
  */
-static void SetIndexSrc(struct comedi_device *dev, struct enc_private *k,
-			uint16_t value)
+static void set_index_src(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t value)
 {
 	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXSRC) |
 			    ((value != 0) << STDBIT_INDXSRC)), FALSE);
 }
 
-static uint16_t GetIndexSrc(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_index_src(struct comedi_device *dev, struct enc_private *k)
 {
 	return (k->get_mode(dev, k) >> STDBIT_INDXSRC) & 1;
 }
@@ -2329,20 +2330,20 @@ static void pulse_index_a(struct comedi_device *dev, struct enc_private *k)
 {
 	uint16_t cra;
 
-	cra = DEBIread(dev, k->my_cra);
+	cra = debi_read(dev, k->my_cra);
 	/* Pulse index. */
-	DEBIwrite(dev, k->my_cra, (cra ^ CRAMSK_INDXPOL_A));
-	DEBIwrite(dev, k->my_cra, cra);
+	debi_write(dev, k->my_cra, (cra ^ CRAMSK_INDXPOL_A));
+	debi_write(dev, k->my_cra, cra);
 }
 
 static void pulse_index_b(struct comedi_device *dev, struct enc_private *k)
 {
 	uint16_t crb;
 
-	crb = DEBIread(dev, k->my_crb) & ~CRBMSK_INTCTRL;
+	crb = debi_read(dev, k->my_crb) & ~CRBMSK_INTCTRL;
 	/* Pulse index. */
-	DEBIwrite(dev, k->my_crb, (crb ^ CRBMSK_INDXPOL_B));
-	DEBIwrite(dev, k->my_crb, crb);
+	debi_write(dev, k->my_crb, (crb ^ CRBMSK_INDXPOL_B));
+	debi_write(dev, k->my_crb, crb);
 }
 
 static struct enc_private enc_private_data[] = {
@@ -2439,7 +2440,7 @@ static struct enc_private enc_private_data[] = {
 	},
 };
 
-static void CountersInit(struct comedi_device *dev)
+static void counters_init(struct comedi_device *dev)
 {
 	int chan;
 	struct enc_private *k;
@@ -2587,7 +2588,7 @@ static void s626_initialize(struct comedi_device *dev)
 
 		/* Create a simple polling list for analog input channel 0 */
 		PollList = EOPL;
-		ResetADC(dev, &PollList);
+		reset_adc(dev, &PollList);
 
 		/* Get initial ADC value */
 		s626_ai_rinsn(dev, dev->subdevices, NULL, data);
@@ -2685,8 +2686,8 @@ static void s626_initialize(struct comedi_device *dev)
 	 * SAA7146 audio channel does not always reset properly and
 	 * sometimes causes the first few TrimDAC writes to malfunction.
 	 */
-	LoadTrimDACs(dev);
-	LoadTrimDACs(dev);
+	load_trim_dacs(dev);
+	load_trim_dacs(dev);
 
 	/*
 	 * Manually init all gate array hardware in case this is a soft
@@ -2701,10 +2702,10 @@ static void s626_initialize(struct comedi_device *dev)
 	 * polarity images.
 	 */
 	for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
-		SetDAC(dev, chan, 0);
+		set_dac(dev, chan, 0);
 
 	/* Init counters */
-	CountersInit(dev);
+	counters_init(dev);
 
 	/*
 	 * Without modifying the state of the Battery Backup enab, disable
@@ -2712,8 +2713,8 @@ static void s626_initialize(struct comedi_device *dev)
 	 * standard DIO (vs. counter overflow) mode, disable the battery
 	 * charger, and reset the watchdog interval selector to zero.
 	 */
-	WriteMISC2(dev, (uint16_t)(DEBIread(dev, LP_RDMISC2) &
-				   MISC2_BATT_ENABLE));
+	write_misc2(dev, (uint16_t)(debi_read(dev, LP_RDMISC2) &
+				    MISC2_BATT_ENABLE));
 
 	/* Initialize the digital I/O subsystem */
 	s626_dio_init(dev);
@@ -2861,14 +2862,14 @@ static void s626_detach(struct comedi_device *dev)
 			       devpriv->mmio + P_ISR);
 
 			/* Disable the watchdog timer and battery charger. */
-			WriteMISC2(dev, 0);
+			write_misc2(dev, 0);
 
 			/* Close all interfaces on 7146 device */
 			writel(MC1_SHUTDOWN, devpriv->mmio + P_MC1);
 			writel(ACON1_BASE, devpriv->mmio + P_ACON1);
 
-			CloseDMAB(dev, &devpriv->rps_buf, DMABUF_SIZE);
-			CloseDMAB(dev, &devpriv->ana_buf, DMABUF_SIZE);
+			close_dma_b(dev, &devpriv->rps_buf, DMABUF_SIZE);
+			close_dma_b(dev, &devpriv->ana_buf, DMABUF_SIZE);
 		}
 
 		if (dev->irq)

commit cffd7ab94613d2ec818b64ef8dd7f56b625e1aa2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:27 2013 +0100

    staging: comedi: s626: remove a variable from set_mode_a() and _b()
    
    The `set_mode_a()` and `set_mode_b()` functions use a local variable
    `setup` which is initialized to the value of parameter `Setup` which is
    not used further.  Get rid of the local variable and rename the
    parameter to `setup`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index fcbeb2859923..12ebc85f85d3 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1958,12 +1958,11 @@ static uint16_t get_mode_b(struct comedi_device *dev, struct enc_private *k)
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
 static void set_mode_a(struct comedi_device *dev, struct enc_private *k,
-		       uint16_t Setup, uint16_t DisableIntSrc)
+		       uint16_t setup, uint16_t DisableIntSrc)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t cra;
 	uint16_t crb;
-	uint16_t setup = Setup;	/*  Cache the Standard Setup. */
 
 	/* Initialize CRA and CRB images. */
 	/* Preload trigger is passed through. */
@@ -2037,12 +2036,11 @@ static void set_mode_a(struct comedi_device *dev, struct enc_private *k,
 }
 
 static void set_mode_b(struct comedi_device *dev, struct enc_private *k,
-		       uint16_t Setup, uint16_t DisableIntSrc)
+		       uint16_t setup, uint16_t DisableIntSrc)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t cra;
 	uint16_t crb;
-	uint16_t setup = Setup;	/* Cache the Standard Setup. */
 
 	/* Initialize CRA and CRB images. */
 	/* IndexSrc field is restricted to ENC_X or IndxPol. */

commit b075ac8e9361b309eb12fc7b4e91a2f5f156909f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:26 2013 +0100

    staging: comedi: s626: rename CamelCase in struct enc_private
    
    Rename the CamelCase members of `struct enc_private`.  Since most of
    those are function pointers pointing to functions with similar names as
    the members, rename the functions they point to as well.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 45b2c65d58c0..fcbeb2859923 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -101,35 +101,38 @@ struct s626_private {
 struct enc_private {
 	/* Pointers to functions that differ for A and B counters: */
 	/* Return clock enable. */
-	uint16_t(*GetEnable)(struct comedi_device *dev, struct enc_private *);
+	uint16_t(*get_enable)(struct comedi_device *dev, struct enc_private *k);
 	/* Return interrupt source. */
-	uint16_t(*GetIntSrc)(struct comedi_device *dev, struct enc_private *);
+	uint16_t(*get_int_src)(struct comedi_device *dev,
+			       struct enc_private *k);
 	/* Return preload trigger source. */
-	uint16_t(*GetLoadTrig)(struct comedi_device *dev, struct enc_private *);
+	uint16_t(*get_load_trig)(struct comedi_device *dev,
+				 struct enc_private *k);
 	/* Return standardized operating mode. */
-	uint16_t(*GetMode)(struct comedi_device *dev, struct enc_private *);
+	uint16_t(*get_mode)(struct comedi_device *dev, struct enc_private *k);
 	/* Generate soft index strobe. */
-	void (*PulseIndex)(struct comedi_device *dev, struct enc_private *);
+	void (*pulse_index)(struct comedi_device *dev, struct enc_private *k);
 	/* Program clock enable. */
-	void (*SetEnable)(struct comedi_device *dev, struct enc_private *,
-			  uint16_t enab);
+	void (*set_enable)(struct comedi_device *dev, struct enc_private *k,
+			   uint16_t enab);
 	/* Program interrupt source. */
-	void (*SetIntSrc)(struct comedi_device *dev, struct enc_private *,
-			  uint16_t IntSource);
+	void (*set_int_src)(struct comedi_device *dev, struct enc_private *k,
+			    uint16_t int_source);
 	/* Program preload trigger source. */
-	void (*SetLoadTrig)(struct comedi_device *dev, struct enc_private *,
-			    uint16_t Trig);
+	void (*set_load_trig)(struct comedi_device *dev, struct enc_private *k,
+			      uint16_t trig);
 	/* Program standardized operating mode. */
-	void (*SetMode)(struct comedi_device *dev, struct enc_private *,
-			uint16_t Setup, uint16_t DisableIntSrc);
+	void (*set_mode)(struct comedi_device *dev, struct enc_private *k,
+			 uint16_t setup, uint16_t disable_int_src);
 	/* Reset event capture flags. */
-	void (*ResetCapFlags)(struct comedi_device *dev, struct enc_private *);
+	void (*reset_cap_flags)(struct comedi_device *dev,
+				struct enc_private *k);
 
-	uint16_t MyCRA;		/* address of CRA register */
-	uint16_t MyCRB;		/* address of CRB register */
-	uint16_t MyLatchLsw;	/* address of Latch least-significant-word
+	uint16_t my_cra;	/* address of CRA register */
+	uint16_t my_crb;	/* address of CRB register */
+	uint16_t my_latch_lsw;	/* address of Latch least-significant-word
 				 * register */
-	uint16_t MyEventBits[4]; /* bit translations for IntSrc -->RDMISC2 */
+	uint16_t my_event_bits[4]; /* bit translations for IntSrc -->RDMISC2 */
 };
 
 #define encpriv ((struct enc_private *)(dev->subdevices+5)->private)
@@ -612,10 +615,10 @@ static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
 	uint32_t value;
 
 	/* Latch counts and fetch LSW of latched counts value. */
-	value = DEBIread(dev, k->MyLatchLsw);
+	value = DEBIread(dev, k->my_latch_lsw);
 
 	/* Fetch MSW of latched counts and combine with LSW. */
-	value |= ((uint32_t)DEBIread(dev, k->MyLatchLsw + 2) << 16);
+	value |= ((uint32_t)DEBIread(dev, k->my_latch_lsw + 2) << 16);
 
 	/* Return latched counts. */
 	return value;
@@ -629,7 +632,7 @@ static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
 static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
 			   uint16_t value)
 {
-	DEBIreplace(dev, k->MyCRB, ~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC),
+	DEBIreplace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC),
 		    value << CRBBIT_LATCHSRC);
 }
 
@@ -639,8 +642,8 @@ static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
 static void Preload(struct comedi_device *dev, struct enc_private *k,
 		    uint32_t value)
 {
-	DEBIwrite(dev, k->MyLatchLsw, value);
-	DEBIwrite(dev, k->MyLatchLsw + 2, value >> 16);
+	DEBIwrite(dev, k->my_latch_lsw, value);
+	DEBIwrite(dev, k->my_latch_lsw + 2, value >> 16);
 }
 
 static unsigned int s626_ai_reg_to_uint(int data)
@@ -740,7 +743,7 @@ static void handle_dio_interrupt(struct comedi_device *dev,
 				struct enc_private *k = &encpriv[5];
 
 				devpriv->ai_convert_count = cmd->chanlist_len;
-				k->SetEnable(dev, k, CLKENAB_ALWAYS);
+				k->set_enable(dev, k, CLKENAB_ALWAYS);
 			}
 		}
 		if ((irqbit >> (cmd->convert_arg - (16 * group))) == 1 &&
@@ -790,36 +793,36 @@ static void check_counter_interrupts(struct comedi_device *dev)
 		k = &encpriv[0];
 
 		/* clear interrupt capture flag */
-		k->ResetCapFlags(dev, k);
+		k->reset_cap_flags(dev, k);
 	}
 	if (irqbit & IRQ_COINT2A) {
 		k = &encpriv[1];
 
 		/* clear interrupt capture flag */
-		k->ResetCapFlags(dev, k);
+		k->reset_cap_flags(dev, k);
 	}
 	if (irqbit & IRQ_COINT3A) {
 		k = &encpriv[2];
 
 		/* clear interrupt capture flag */
-		k->ResetCapFlags(dev, k);
+		k->reset_cap_flags(dev, k);
 	}
 	if (irqbit & IRQ_COINT1B) {
 		k = &encpriv[3];
 
 		/* clear interrupt capture flag */
-		k->ResetCapFlags(dev, k);
+		k->reset_cap_flags(dev, k);
 	}
 	if (irqbit & IRQ_COINT2B) {
 		k = &encpriv[4];
 
 		/* clear interrupt capture flag */
-		k->ResetCapFlags(dev, k);
+		k->reset_cap_flags(dev, k);
 
 		if (devpriv->ai_convert_count > 0) {
 			devpriv->ai_convert_count--;
 			if (devpriv->ai_convert_count == 0)
-				k->SetEnable(dev, k, CLKENAB_INDEX);
+				k->set_enable(dev, k, CLKENAB_INDEX);
 
 			if (cmd->convert_src == TRIG_TIMER) {
 				/* Trigger ADC scan loop start */
@@ -831,7 +834,7 @@ static void check_counter_interrupts(struct comedi_device *dev)
 		k = &encpriv[5];
 
 		/* clear interrupt capture flag */
-		k->ResetCapFlags(dev, k);
+		k->reset_cap_flags(dev, k);
 
 		if (cmd->scan_begin_src == TRIG_TIMER) {
 			/* Trigger ADC scan loop start */
@@ -841,7 +844,7 @@ static void check_counter_interrupts(struct comedi_device *dev)
 		if (cmd->convert_src == TRIG_TIMER) {
 			k = &encpriv[4];
 			devpriv->ai_convert_count = cmd->chanlist_len;
-			k->SetEnable(dev, k, CLKENAB_ALWAYS);
+			k->set_enable(dev, k, CLKENAB_ALWAYS);
 		}
 	}
 }
@@ -1351,7 +1354,7 @@ static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 	uint16_t valueSrclatch = LATCHSRC_A_INDXA;
 	/* uint16_t enab = CLKENAB_ALWAYS; */
 
-	k->SetMode(dev, k, Setup, FALSE);
+	k->set_mode(dev, k, Setup, FALSE);
 
 	/* Set the preload register */
 	Preload(dev, k, tick);
@@ -1360,17 +1363,17 @@ static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 	 * Software index pulse forces the preload register to load
 	 * into the counter
 	 */
-	k->SetLoadTrig(dev, k, 0);
-	k->PulseIndex(dev, k);
+	k->set_load_trig(dev, k, 0);
+	k->pulse_index(dev, k);
 
 	/* set reload on counter overflow */
-	k->SetLoadTrig(dev, k, 1);
+	k->set_load_trig(dev, k, 1);
 
 	/* set interrupt on overflow */
-	k->SetIntSrc(dev, k, INTSRC_OVER);
+	k->set_int_src(dev, k, INTSRC_OVER);
 
 	SetLatchSource(dev, k, valueSrclatch);
-	/* k->SetEnable(dev, k, (uint16_t)(enab != 0)); */
+	/* k->set_enable(dev, k, (uint16_t)(enab != 0)); */
 }
 
 /* TO COMPLETE  */
@@ -1428,7 +1431,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
-		k->SetEnable(dev, k, CLKENAB_ALWAYS);
+		k->set_enable(dev, k, CLKENAB_ALWAYS);
 		break;
 	case TRIG_EXT:
 		/* set the digital line and interrupt for scan trigger */
@@ -1451,7 +1454,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
-		k->SetEnable(dev, k, CLKENAB_INDEX);
+		k->set_enable(dev, k, CLKENAB_INDEX);
 		break;
 	case TRIG_EXT:
 		/* set the digital line and interrupt for convert trigger */
@@ -1741,11 +1744,11 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 
 	/* (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
-	k->SetMode(dev, k, Setup, TRUE);
+	k->set_mode(dev, k, Setup, TRUE);
 	Preload(dev, k, data[0]);
-	k->PulseIndex(dev, k);
+	k->pulse_index(dev, k);
 	SetLatchSource(dev, k, valueSrclatch);
-	k->SetEnable(dev, k, (enab != 0));
+	k->set_enable(dev, k, (enab != 0));
 
 	return insn->n;
 }
@@ -1776,9 +1779,9 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 	 * Software index pulse forces the preload register to load
 	 * into the counter
 	 */
-	k->SetLoadTrig(dev, k, 0);
-	k->PulseIndex(dev, k);
-	k->SetLoadTrig(dev, k, 2);
+	k->set_load_trig(dev, k, 0);
+	k->pulse_index(dev, k);
+	k->set_load_trig(dev, k, 2);
 
 	return 1;
 }
@@ -1815,15 +1818,15 @@ static void CloseDMAB(struct comedi_device *dev, struct buffer_dma *pdma,
 /*
  * Reset a counter's index and overflow event capture flags.
  */
-static void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k)
+static void reset_cap_flags_a(struct comedi_device *dev, struct enc_private *k)
 {
-	DEBIreplace(dev, k->MyCRB, ~CRBMSK_INTCTRL,
+	DEBIreplace(dev, k->my_crb, ~CRBMSK_INTCTRL,
 		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 }
 
-static void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k)
+static void reset_cap_flags_b(struct comedi_device *dev, struct enc_private *k)
 {
-	DEBIreplace(dev, k->MyCRB, ~CRBMSK_INTCTRL,
+	DEBIreplace(dev, k->my_crb, ~CRBMSK_INTCTRL,
 		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
 }
 
@@ -1831,15 +1834,15 @@ static void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k)
  * Return counter setup in a format (COUNTER_SETUP) that is consistent
  * for both A and B counters.
  */
-static uint16_t GetMode_A(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_mode_a(struct comedi_device *dev, struct enc_private *k)
 {
 	uint16_t cra;
 	uint16_t crb;
 	uint16_t setup;
 
 	/* Fetch CRA and CRB register images. */
-	cra = DEBIread(dev, k->MyCRA);
-	crb = DEBIread(dev, k->MyCRB);
+	cra = DEBIread(dev, k->my_cra);
+	crb = DEBIread(dev, k->my_crb);
 
 	/*
 	 * Populate the standardized counter setup bit fields.
@@ -1886,15 +1889,15 @@ static uint16_t GetMode_A(struct comedi_device *dev, struct enc_private *k)
 	return setup;
 }
 
-static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_mode_b(struct comedi_device *dev, struct enc_private *k)
 {
 	uint16_t cra;
 	uint16_t crb;
 	uint16_t setup;
 
 	/* Fetch CRA and CRB register images. */
-	cra = DEBIread(dev, k->MyCRA);
-	crb = DEBIread(dev, k->MyCRB);
+	cra = DEBIread(dev, k->my_cra);
+	crb = DEBIread(dev, k->my_crb);
 
 	/*
 	 * Populate the standardized counter setup bit fields.
@@ -1954,8 +1957,8 @@ static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k)
  * parameters are programmable (all other parms are ignored): ClkMult,
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
-static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
-		      uint16_t Setup, uint16_t DisableIntSrc)
+static void set_mode_a(struct comedi_device *dev, struct enc_private *k,
+		       uint16_t Setup, uint16_t DisableIntSrc)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t cra;
@@ -2023,18 +2026,18 @@ static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
 	 * enable mask to indicate the counter interrupt is disabled.
 	 */
 	if (DisableIntSrc)
-		devpriv->counter_int_enabs &= ~k->MyEventBits[3];
+		devpriv->counter_int_enabs &= ~k->my_event_bits[3];
 
 	/*
 	 * While retaining CounterB and LatchSrc configurations, program the
 	 * new counter operating mode.
 	 */
-	DEBIreplace(dev, k->MyCRA, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
-	DEBIreplace(dev, k->MyCRB, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A), crb);
+	DEBIreplace(dev, k->my_cra, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
+	DEBIreplace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A), crb);
 }
 
-static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
-		      uint16_t Setup, uint16_t DisableIntSrc)
+static void set_mode_b(struct comedi_device *dev, struct enc_private *k,
+		       uint16_t Setup, uint16_t DisableIntSrc)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t cra;
@@ -2110,48 +2113,48 @@ static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
 	 * enable mask to indicate the counter interrupt is disabled.
 	 */
 	if (DisableIntSrc)
-		devpriv->counter_int_enabs &= ~k->MyEventBits[3];
+		devpriv->counter_int_enabs &= ~k->my_event_bits[3];
 
 	/*
 	 * While retaining CounterA and LatchSrc configurations, program the
 	 * new counter operating mode.
 	 */
-	DEBIreplace(dev, k->MyCRA, ~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B), cra);
-	DEBIreplace(dev, k->MyCRB, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
+	DEBIreplace(dev, k->my_cra, ~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B), cra);
+	DEBIreplace(dev, k->my_crb, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
 }
 
 /*
  * Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
  */
-static void SetEnable_A(struct comedi_device *dev, struct enc_private *k,
-			uint16_t enab)
+static void set_enable_a(struct comedi_device *dev, struct enc_private *k,
+			 uint16_t enab)
 {
-	DEBIreplace(dev, k->MyCRB, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A),
+	DEBIreplace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A),
 		    enab << CRBBIT_CLKENAB_A);
 }
 
-static void SetEnable_B(struct comedi_device *dev, struct enc_private *k,
-			uint16_t enab)
+static void set_enable_b(struct comedi_device *dev, struct enc_private *k,
+			 uint16_t enab)
 {
-	DEBIreplace(dev, k->MyCRB, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B),
+	DEBIreplace(dev, k->my_crb, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B),
 		    enab << CRBBIT_CLKENAB_B);
 }
 
-static uint16_t GetEnable_A(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_enable_a(struct comedi_device *dev, struct enc_private *k)
 {
-	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_A) & 1;
+	return (DEBIread(dev, k->my_crb) >> CRBBIT_CLKENAB_A) & 1;
 }
 
-static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_enable_b(struct comedi_device *dev, struct enc_private *k)
 {
-	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_B) & 1;
+	return (DEBIread(dev, k->my_crb) >> CRBBIT_CLKENAB_B) & 1;
 }
 
 #ifdef unused
 static uint16_t GetLatchSource(struct comedi_device *dev,
 			       struct enc_private *k)
 {
-	return (DEBIread(dev, k->MyCRB) >> CRBBIT_LATCHSRC) & 3;
+	return (DEBIread(dev, k->my_crb) >> CRBBIT_LATCHSRC) & 3;
 }
 #endif
 
@@ -2160,28 +2163,30 @@ static uint16_t GetLatchSource(struct comedi_device *dev,
  * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
  * 2=OverflowA (B counters only), 3=disabled.
  */
-static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k,
-			  uint16_t Trig)
+static void set_load_trig_a(struct comedi_device *dev, struct enc_private *k,
+			    uint16_t Trig)
 {
-	DEBIreplace(dev, k->MyCRA, ~CRAMSK_LOADSRC_A,
+	DEBIreplace(dev, k->my_cra, ~CRAMSK_LOADSRC_A,
 		    Trig << CRABIT_LOADSRC_A);
 }
 
-static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k,
-			  uint16_t Trig)
+static void set_load_trig_b(struct comedi_device *dev, struct enc_private *k,
+			    uint16_t Trig)
 {
-	DEBIreplace(dev, k->MyCRB, ~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL),
+	DEBIreplace(dev, k->my_crb, ~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL),
 		    Trig << CRBBIT_LOADSRC_B);
 }
 
-static uint16_t GetLoadTrig_A(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_load_trig_a(struct comedi_device *dev,
+				struct enc_private *k)
 {
-	return (DEBIread(dev, k->MyCRA) >> CRABIT_LOADSRC_A) & 3;
+	return (DEBIread(dev, k->my_cra) >> CRABIT_LOADSRC_A) & 3;
 }
 
-static uint16_t GetLoadTrig_B(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_load_trig_b(struct comedi_device *dev,
+				struct enc_private *k)
 {
-	return (DEBIread(dev, k->MyCRB) >> CRBBIT_LOADSRC_B) & 3;
+	return (DEBIread(dev, k->my_crb) >> CRBBIT_LOADSRC_B) & 3;
 }
 
 /*
@@ -2189,57 +2194,57 @@ static uint16_t GetLoadTrig_B(struct comedi_device *dev, struct enc_private *k)
  * index/overflow events.  IntSource: 0=Disabled, 1=OverflowOnly,
  * 2=IndexOnly, 3=IndexAndOverflow.
  */
-static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
-			uint16_t IntSource)
+static void set_int_src_a(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t IntSource)
 {
 	struct s626_private *devpriv = dev->private;
 
 	/* Reset any pending counter overflow or index captures. */
-	DEBIreplace(dev, k->MyCRB, ~CRBMSK_INTCTRL,
+	DEBIreplace(dev, k->my_crb, ~CRBMSK_INTCTRL,
 		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 
 	/* Program counter interrupt source. */
-	DEBIreplace(dev, k->MyCRA, ~CRAMSK_INTSRC_A,
+	DEBIreplace(dev, k->my_cra, ~CRAMSK_INTSRC_A,
 		    IntSource << CRABIT_INTSRC_A);
 
 	/* Update MISC2 interrupt enable mask. */
 	devpriv->counter_int_enabs =
-	    (devpriv->counter_int_enabs & ~k->
-	     MyEventBits[3]) | k->MyEventBits[IntSource];
+	    (devpriv->counter_int_enabs & ~k->my_event_bits[3]) |
+	    k->my_event_bits[IntSource];
 }
 
-static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
-			uint16_t IntSource)
+static void set_int_src_b(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t IntSource)
 {
 	struct s626_private *devpriv = dev->private;
 	uint16_t crb;
 
 	/* Cache writeable CRB register image. */
-	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;
+	crb = DEBIread(dev, k->my_crb) & ~CRBMSK_INTCTRL;
 
 	/* Reset any pending counter overflow or index captures. */
-	DEBIwrite(dev, k->MyCRB,
+	DEBIwrite(dev, k->my_crb,
 		  (uint16_t)(crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
 
 	/* Program counter interrupt source. */
-	DEBIwrite(dev, k->MyCRB,
+	DEBIwrite(dev, k->my_crb,
 		  (uint16_t)((crb & ~CRBMSK_INTSRC_B) |
 			     (IntSource << CRBBIT_INTSRC_B)));
 
 	/* Update MISC2 interrupt enable mask. */
 	devpriv->counter_int_enabs =
-		(devpriv->counter_int_enabs & ~k->MyEventBits[3]) |
-		k->MyEventBits[IntSource];
+		(devpriv->counter_int_enabs & ~k->my_event_bits[3]) |
+		k->my_event_bits[IntSource];
 }
 
-static uint16_t GetIntSrc_A(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_int_src_a(struct comedi_device *dev, struct enc_private *k)
 {
-	return (DEBIread(dev, k->MyCRA) >> CRABIT_INTSRC_A) & 3;
+	return (DEBIread(dev, k->my_cra) >> CRABIT_INTSRC_A) & 3;
 }
 
-static uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k)
+static uint16_t get_int_src_b(struct comedi_device *dev, struct enc_private *k)
 {
-	return (DEBIread(dev, k->MyCRB) >> CRBBIT_INTSRC_B) & 3;
+	return (DEBIread(dev, k->my_crb) >> CRBBIT_INTSRC_B) & 3;
 }
 
 #ifdef unused
@@ -2249,13 +2254,13 @@ static uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k)
 static void SetClkMult(struct comedi_device *dev, struct enc_private *k,
 		       uint16_t value)
 {
-	k->SetMode(dev, k, ((k->GetMode(dev, k) & ~STDMSK_CLKMULT) |
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKMULT) |
 			    (value << STDBIT_CLKMULT)), FALSE);
 }
 
 static uint16_t GetClkMult(struct comedi_device *dev, struct enc_private *k)
 {
-	return (k->GetMode(dev, k) >> STDBIT_CLKMULT) & 3;
+	return (k->get_mode(dev, k) >> STDBIT_CLKMULT) & 3;
 }
 
 /*
@@ -2264,13 +2269,13 @@ static uint16_t GetClkMult(struct comedi_device *dev, struct enc_private *k)
 static void SetClkPol(struct comedi_device *dev, struct enc_private *k,
 		      uint16_t value)
 {
-	k->SetMode(dev, k, ((k->GetMode(dev, k) & ~STDMSK_CLKPOL) |
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKPOL) |
 			    (value << STDBIT_CLKPOL)), FALSE);
 }
 
 static uint16_t GetClkPol(struct comedi_device *dev, struct enc_private *k)
 {
-	return (k->GetMode(dev, k) >> STDBIT_CLKPOL) & 1;
+	return (k->get_mode(dev, k) >> STDBIT_CLKPOL) & 1;
 }
 
 /*
@@ -2279,13 +2284,13 @@ static uint16_t GetClkPol(struct comedi_device *dev, struct enc_private *k)
 static void SetClkSrc(struct comedi_device *dev, struct enc_private *k,
 		      uint16_t value)
 {
-	k->SetMode(dev, k, ((k->GetMode(dev, k) & ~STDMSK_CLKSRC) |
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_CLKSRC) |
 			    (value << STDBIT_CLKSRC)), FALSE);
 }
 
 static uint16_t GetClkSrc(struct comedi_device *dev, struct enc_private *k)
 {
-	return (k->GetMode(dev, k) >> STDBIT_CLKSRC) & 3;
+	return (k->get_mode(dev, k) >> STDBIT_CLKSRC) & 3;
 }
 
 /*
@@ -2294,13 +2299,13 @@ static uint16_t GetClkSrc(struct comedi_device *dev, struct enc_private *k)
 static void SetIndexPol(struct comedi_device *dev, struct enc_private *k,
 			uint16_t value)
 {
-	k->SetMode(dev, k, ((k->GetMode(dev, k) & ~STDMSK_INDXPOL) |
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXPOL) |
 			    ((value != 0) << STDBIT_INDXPOL)), FALSE);
 }
 
 static uint16_t GetIndexPol(struct comedi_device *dev, struct enc_private *k)
 {
-	return (k->GetMode(dev, k) >> STDBIT_INDXPOL) & 1;
+	return (k->get_mode(dev, k) >> STDBIT_INDXPOL) & 1;
 }
 
 /*
@@ -2309,130 +2314,130 @@ static uint16_t GetIndexPol(struct comedi_device *dev, struct enc_private *k)
 static void SetIndexSrc(struct comedi_device *dev, struct enc_private *k,
 			uint16_t value)
 {
-	k->SetMode(dev, k, ((k->GetMode(dev, k) & ~STDMSK_INDXSRC) |
+	k->set_mode(dev, k, ((k->get_mode(dev, k) & ~STDMSK_INDXSRC) |
 			    ((value != 0) << STDBIT_INDXSRC)), FALSE);
 }
 
 static uint16_t GetIndexSrc(struct comedi_device *dev, struct enc_private *k)
 {
-	return (k->GetMode(dev, k) >> STDBIT_INDXSRC) & 1;
+	return (k->get_mode(dev, k) >> STDBIT_INDXSRC) & 1;
 }
 #endif
 
 /*
  * Generate an index pulse.
  */
-static void PulseIndex_A(struct comedi_device *dev, struct enc_private *k)
+static void pulse_index_a(struct comedi_device *dev, struct enc_private *k)
 {
 	uint16_t cra;
 
-	cra = DEBIread(dev, k->MyCRA);
+	cra = DEBIread(dev, k->my_cra);
 	/* Pulse index. */
-	DEBIwrite(dev, k->MyCRA, (cra ^ CRAMSK_INDXPOL_A));
-	DEBIwrite(dev, k->MyCRA, cra);
+	DEBIwrite(dev, k->my_cra, (cra ^ CRAMSK_INDXPOL_A));
+	DEBIwrite(dev, k->my_cra, cra);
 }
 
-static void PulseIndex_B(struct comedi_device *dev, struct enc_private *k)
+static void pulse_index_b(struct comedi_device *dev, struct enc_private *k)
 {
 	uint16_t crb;
 
-	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;
+	crb = DEBIread(dev, k->my_crb) & ~CRBMSK_INTCTRL;
 	/* Pulse index. */
-	DEBIwrite(dev, k->MyCRB, (crb ^ CRBMSK_INDXPOL_B));
-	DEBIwrite(dev, k->MyCRB, crb);
+	DEBIwrite(dev, k->my_crb, (crb ^ CRBMSK_INDXPOL_B));
+	DEBIwrite(dev, k->my_crb, crb);
 }
 
 static struct enc_private enc_private_data[] = {
 	{
-		.GetEnable	= GetEnable_A,
-		.GetIntSrc	= GetIntSrc_A,
-		.GetLoadTrig	= GetLoadTrig_A,
-		.GetMode	= GetMode_A,
-		.PulseIndex	= PulseIndex_A,
-		.SetEnable	= SetEnable_A,
-		.SetIntSrc	= SetIntSrc_A,
-		.SetLoadTrig	= SetLoadTrig_A,
-		.SetMode	= SetMode_A,
-		.ResetCapFlags	= ResetCapFlags_A,
-		.MyCRA		= LP_CR0A,
-		.MyCRB		= LP_CR0B,
-		.MyLatchLsw	= LP_CNTR0ALSW,
-		.MyEventBits	= EVBITS(0),
+		.get_enable		= get_enable_a,
+		.get_int_src		= get_int_src_a,
+		.get_load_trig		= get_load_trig_a,
+		.get_mode		= get_mode_a,
+		.pulse_index		= pulse_index_a,
+		.set_enable		= set_enable_a,
+		.set_int_src		= set_int_src_a,
+		.set_load_trig		= set_load_trig_a,
+		.set_mode		= set_mode_a,
+		.reset_cap_flags	= reset_cap_flags_a,
+		.my_cra			= LP_CR0A,
+		.my_crb			= LP_CR0B,
+		.my_latch_lsw		= LP_CNTR0ALSW,
+		.my_event_bits		= EVBITS(0),
 	}, {
-		.GetEnable	= GetEnable_A,
-		.GetIntSrc	= GetIntSrc_A,
-		.GetLoadTrig	= GetLoadTrig_A,
-		.GetMode	= GetMode_A,
-		.PulseIndex	= PulseIndex_A,
-		.SetEnable	= SetEnable_A,
-		.SetIntSrc	= SetIntSrc_A,
-		.SetLoadTrig	= SetLoadTrig_A,
-		.SetMode	= SetMode_A,
-		.ResetCapFlags	= ResetCapFlags_A,
-		.MyCRA		= LP_CR1A,
-		.MyCRB		= LP_CR1B,
-		.MyLatchLsw	= LP_CNTR1ALSW,
-		.MyEventBits	= EVBITS(1),
+		.get_enable		= get_enable_a,
+		.get_int_src		= get_int_src_a,
+		.get_load_trig		= get_load_trig_a,
+		.get_mode		= get_mode_a,
+		.pulse_index		= pulse_index_a,
+		.set_enable		= set_enable_a,
+		.set_int_src		= set_int_src_a,
+		.set_load_trig		= set_load_trig_a,
+		.set_mode		= set_mode_a,
+		.reset_cap_flags	= reset_cap_flags_a,
+		.my_cra			= LP_CR1A,
+		.my_crb			= LP_CR1B,
+		.my_latch_lsw		= LP_CNTR1ALSW,
+		.my_event_bits		= EVBITS(1),
 	}, {
-		.GetEnable	= GetEnable_A,
-		.GetIntSrc	= GetIntSrc_A,
-		.GetLoadTrig	= GetLoadTrig_A,
-		.GetMode	= GetMode_A,
-		.PulseIndex	= PulseIndex_A,
-		.SetEnable	= SetEnable_A,
-		.SetIntSrc	= SetIntSrc_A,
-		.SetLoadTrig	= SetLoadTrig_A,
-		.SetMode	= SetMode_A,
-		.ResetCapFlags	= ResetCapFlags_A,
-		.MyCRA		= LP_CR2A,
-		.MyCRB		= LP_CR2B,
-		.MyLatchLsw	= LP_CNTR2ALSW,
-		.MyEventBits	= EVBITS(2),
+		.get_enable		= get_enable_a,
+		.get_int_src		= get_int_src_a,
+		.get_load_trig		= get_load_trig_a,
+		.get_mode		= get_mode_a,
+		.pulse_index		= pulse_index_a,
+		.set_enable		= set_enable_a,
+		.set_int_src		= set_int_src_a,
+		.set_load_trig		= set_load_trig_a,
+		.set_mode		= set_mode_a,
+		.reset_cap_flags	= reset_cap_flags_a,
+		.my_cra			= LP_CR2A,
+		.my_crb			= LP_CR2B,
+		.my_latch_lsw		= LP_CNTR2ALSW,
+		.my_event_bits		= EVBITS(2),
 	}, {
-		.GetEnable	= GetEnable_B,
-		.GetIntSrc	= GetIntSrc_B,
-		.GetLoadTrig	= GetLoadTrig_B,
-		.GetMode	= GetMode_B,
-		.PulseIndex	= PulseIndex_B,
-		.SetEnable	= SetEnable_B,
-		.SetIntSrc	= SetIntSrc_B,
-		.SetLoadTrig	= SetLoadTrig_B,
-		.SetMode	= SetMode_B,
-		.ResetCapFlags	= ResetCapFlags_B,
-		.MyCRA		= LP_CR0A,
-		.MyCRB		= LP_CR0B,
-		.MyLatchLsw	= LP_CNTR0BLSW,
-		.MyEventBits	= EVBITS(3),
+		.get_enable		= get_enable_b,
+		.get_int_src		= get_int_src_b,
+		.get_load_trig		= get_load_trig_b,
+		.get_mode		= get_mode_b,
+		.pulse_index		= pulse_index_b,
+		.set_enable		= set_enable_b,
+		.set_int_src		= set_int_src_b,
+		.set_load_trig		= set_load_trig_b,
+		.set_mode		= set_mode_b,
+		.reset_cap_flags	= reset_cap_flags_b,
+		.my_cra			= LP_CR0A,
+		.my_crb			= LP_CR0B,
+		.my_latch_lsw		= LP_CNTR0BLSW,
+		.my_event_bits		= EVBITS(3),
 	}, {
-		.GetEnable	= GetEnable_B,
-		.GetIntSrc	= GetIntSrc_B,
-		.GetLoadTrig	= GetLoadTrig_B,
-		.GetMode	= GetMode_B,
-		.PulseIndex	= PulseIndex_B,
-		.SetEnable	= SetEnable_B,
-		.SetIntSrc	= SetIntSrc_B,
-		.SetLoadTrig	= SetLoadTrig_B,
-		.SetMode	= SetMode_B,
-		.ResetCapFlags	= ResetCapFlags_B,
-		.MyCRA		= LP_CR1A,
-		.MyCRB		= LP_CR1B,
-		.MyLatchLsw	= LP_CNTR1BLSW,
-		.MyEventBits	= EVBITS(4),
+		.get_enable		= get_enable_b,
+		.get_int_src		= get_int_src_b,
+		.get_load_trig		= get_load_trig_b,
+		.get_mode		= get_mode_b,
+		.pulse_index		= pulse_index_b,
+		.set_enable		= set_enable_b,
+		.set_int_src		= set_int_src_b,
+		.set_load_trig		= set_load_trig_b,
+		.set_mode		= set_mode_b,
+		.reset_cap_flags	= reset_cap_flags_b,
+		.my_cra			= LP_CR1A,
+		.my_crb			= LP_CR1B,
+		.my_latch_lsw		= LP_CNTR1BLSW,
+		.my_event_bits		= EVBITS(4),
 	}, {
-		.GetEnable	= GetEnable_B,
-		.GetIntSrc	= GetIntSrc_B,
-		.GetLoadTrig	= GetLoadTrig_B,
-		.GetMode	= GetMode_B,
-		.PulseIndex	= PulseIndex_B,
-		.SetEnable	= SetEnable_B,
-		.SetIntSrc	= SetIntSrc_B,
-		.SetLoadTrig	= SetLoadTrig_B,
-		.SetMode	= SetMode_B,
-		.ResetCapFlags	= ResetCapFlags_B,
-		.MyCRA		= LP_CR2A,
-		.MyCRB		= LP_CR2B,
-		.MyLatchLsw	= LP_CNTR2BLSW,
-		.MyEventBits	= EVBITS(5),
+		.get_enable		= get_enable_b,
+		.get_int_src		= get_int_src_b,
+		.get_load_trig		= get_load_trig_b,
+		.get_mode		= get_mode_b,
+		.pulse_index		= pulse_index_b,
+		.set_enable		= set_enable_b,
+		.set_int_src		= set_int_src_b,
+		.set_load_trig		= set_load_trig_b,
+		.set_mode		= set_mode_b,
+		.reset_cap_flags	= reset_cap_flags_b,
+		.my_cra			= LP_CR2A,
+		.my_crb			= LP_CR2B,
+		.my_latch_lsw		= LP_CNTR2BLSW,
+		.my_event_bits		= EVBITS(5),
 	},
 };
 
@@ -2454,10 +2459,10 @@ static void CountersInit(struct comedi_device *dev)
 	 */
 	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
 		k = &encpriv[chan];
-		k->SetMode(dev, k, Setup, TRUE);
-		k->SetIntSrc(dev, k, 0);
-		k->ResetCapFlags(dev, k);
-		k->SetEnable(dev, k, CLKENAB_ALWAYS);
+		k->set_mode(dev, k, Setup, TRUE);
+		k->set_int_src(dev, k, 0);
+		k->reset_cap_flags(dev, k);
+		k->set_enable(dev, k, CLKENAB_ALWAYS);
 	}
 }
 

commit 07a36d66fa013d01b97ac5c72b54ea1d7670f425
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:25 2013 +0100

    staging: comedi: s626: rename CamelCase in struct s626_private
    
    Rename the CamelCase members of `struct s626_private`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 23bc419b47bf..45b2c65d58c0 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -81,18 +81,18 @@ struct s626_private {
 	int ai_convert_count;		/* conversion counter */
 	unsigned int ai_convert_timer;	/* time between conversion in
 					 * units of the timer */
-	uint16_t CounterIntEnabs;	/* counter interrupt enable mask
+	uint16_t counter_int_enabs;	/* counter interrupt enable mask
 					 * for MISC2 register */
-	uint8_t AdcItems;		/* number of items in ADC poll list */
-	struct buffer_dma RPSBuf;	/* DMA buffer used to hold ADC (RPS1)
+	uint8_t adc_items;		/* number of items in ADC poll list */
+	struct buffer_dma rps_buf;	/* DMA buffer used to hold ADC (RPS1)
 					 * program */
-	struct buffer_dma ANABuf;	/* DMA buffer used to receive ADC data
+	struct buffer_dma ana_buf;	/* DMA buffer used to receive ADC data
 					 * and hold DAC data */
-	uint32_t *pDacWBuf;		/* pointer to logical adrs of DMA buffer
+	uint32_t *dac_wbuf;		/* pointer to logical adrs of DMA buffer
 					 * used to hold DAC data */
-	uint16_t Dacpol;		/* image of DAC polarity register */
-	uint8_t TrimSetpoint[12];	/* images of TrimDAC setpoints */
-	uint32_t I2CAdrs;		/* I2C device address for onboard EEPROM
+	uint16_t dacpol;		/* image of DAC polarity register */
+	uint8_t trim_setpoint[12];	/* images of TrimDAC setpoints */
+	uint32_t i2c_adrs;		/* I2C device address for onboard EEPROM
 					 * (board rev dependent) */
 	unsigned int ao_readback[S626_DAC_CHANNELS];
 };
@@ -304,7 +304,7 @@ static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 	 *  Byte1 = EEPROM internal target address.
 	 *  Byte0 = Not sent.
 	 */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, devpriv->I2CAdrs) |
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, devpriv->i2c_adrs) |
 			      I2C_B1(I2C_ATTRSTOP, addr) |
 			      I2C_B0(I2C_ATTRNOP, 0)))
 		/* Abort function and declare error if handshake failed. */
@@ -316,7 +316,7 @@ static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 	 *  Byte1 receives uint8_t from EEPROM.
 	 *  Byte0 = Not sent.
 	 */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, (devpriv->I2CAdrs | 1)) |
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, (devpriv->i2c_adrs | 1)) |
 			      I2C_B1(I2C_ATTRSTOP, 0) |
 			      I2C_B0(I2C_ATTRNOP, 0)))
 		/* Abort function and declare error if handshake failed. */
@@ -342,7 +342,7 @@ static uint8_t trimadrs[] = {
 /*
  * Private helper function: Transmit serial data to DAC via Audio
  * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
- * Dacpol contains valid target image.
+ * dacpol contains valid target image.
  */
 static void SendDAC(struct comedi_device *dev, uint32_t val)
 {
@@ -360,13 +360,13 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * trailing edge of WS1/WS3 (which turns off the signals), thus
 	 * causing the signals to be inactive during the DAC write.
 	 */
-	DEBIwrite(dev, LP_DACPOL, devpriv->Dacpol);
+	DEBIwrite(dev, LP_DACPOL, devpriv->dacpol);
 
 	/* TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- */
 
 	/* Copy DAC setpoint value to DAC's output DMA buffer. */
-	/* writel(val, devpriv->mmio + (uint32_t)devpriv->pDacWBuf); */
-	*devpriv->pDacWBuf = val;
+	/* writel(val, devpriv->mmio + (uint32_t)devpriv->dac_wbuf); */
+	*devpriv->dac_wbuf = val;
 
 	/*
 	 * Enable the output DMA transfer. This will cause the DMAC to copy
@@ -492,9 +492,9 @@ static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
 	signmask = 1 << chan;
 	if (dacdata < 0) {
 		dacdata = -dacdata;
-		devpriv->Dacpol |= signmask;
+		devpriv->dacpol |= signmask;
 	} else {
-		devpriv->Dacpol &= ~signmask;
+		devpriv->dacpol &= ~signmask;
 	}
 
 	/* Limit DAC setpoint value to valid range. */
@@ -550,7 +550,7 @@ static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
 	 * Save the new setpoint in case the application needs to read it back
 	 * later.
 	 */
-	devpriv->TrimSetpoint[LogicalChan] = (uint8_t)DacData;
+	devpriv->trim_setpoint[LogicalChan] = (uint8_t)DacData;
 
 	/* Map logical channel number to physical channel number. */
 	chan = trimchan[LogicalChan];
@@ -857,7 +857,7 @@ static bool handle_eos_interrupt(struct comedi_device *dev)
 	 * first uint16_t in the buffer because it contains junk data
 	 * from the final ADC of the previous poll list scan.
 	 */
-	int32_t *readaddr = (int32_t *)devpriv->ANABuf.logical_base + 1;
+	int32_t *readaddr = (int32_t *)devpriv->ana_buf.logical_base + 1;
 	bool finished = false;
 	int i;
 
@@ -964,13 +964,13 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 	s626_mc_disable(dev, MC1_ERPS1, P_MC1);
 
 	/* Set starting logical address to write RPS commands. */
-	pRPS = (uint32_t *)devpriv->RPSBuf.logical_base;
+	pRPS = (uint32_t *)devpriv->rps_buf.logical_base;
 
 	/* Initialize RPS instruction pointer */
-	writel((uint32_t)devpriv->RPSBuf.physical_base,
+	writel((uint32_t)devpriv->rps_buf.physical_base,
 	       devpriv->mmio + P_RPSADDR1);
 
-	/* Construct RPS program in RPSBuf DMA buffer */
+	/* Construct RPS program in rps_buf DMA buffer */
 	if (cmd != NULL && cmd->scan_begin_src != TRIG_FOLLOW) {
 		/* Wait for Start trigger. */
 		*pRPS++ = RPS_PAUSE | RPS_SIGADC;
@@ -1001,8 +1001,8 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 	 * for loop to limit the slot count to 16 in case the application
 	 * forgot to set the EOPL flag in the final slot.
 	 */
-	for (devpriv->AdcItems = 0; devpriv->AdcItems < 16;
-	     devpriv->AdcItems++) {
+	for (devpriv->adc_items = 0; devpriv->adc_items < 16;
+	     devpriv->adc_items++) {
 		/*
 		 * Convert application's poll list item to private board class
 		 * format.  Each app poll list item is an uint8_t with form
@@ -1047,9 +1047,10 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 		 * instruction prefetch pipeline.
 		 */
 		JmpAdrs =
-			(uint32_t)devpriv->RPSBuf.physical_base +
+			(uint32_t)devpriv->rps_buf.physical_base +
 			(uint32_t)((unsigned long)pRPS -
-				   (unsigned long)devpriv->RPSBuf.logical_base);
+				   (unsigned long)devpriv->
+						  rps_buf.logical_base);
 		for (i = 0; i < (10 * RPSCLK_PER_US / 2); i++) {
 			JmpAdrs += 8;	/* Repeat to implement time delay: */
 			*pRPS++ = RPS_JUMP; /* Jump to next RPS instruction. */
@@ -1079,15 +1080,15 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 
 		/* Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
 		*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
-		*pRPS++ = (uint32_t)devpriv->ANABuf.physical_base +
-			  (devpriv->AdcItems << 2);
+		*pRPS++ = (uint32_t)devpriv->ana_buf.physical_base +
+			  (devpriv->adc_items << 2);
 
 		/*
 		 * If this slot's EndOfPollList flag is set, all channels have
 		 * now been processed.
 		 */
 		if (*ppl++ & EOPL) {
-			devpriv->AdcItems++; /* Adjust poll list item count. */
+			devpriv->adc_items++; /* Adjust poll list item count. */
 			break;	/* Exit poll list processing loop. */
 		}
 	}
@@ -1122,8 +1123,8 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 
 	/* Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
 	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
-	*pRPS++ = (uint32_t)devpriv->ANABuf.physical_base +
-		  (devpriv->AdcItems << 2);
+	*pRPS++ = (uint32_t)devpriv->ana_buf.physical_base +
+		  (devpriv->adc_items << 2);
 
 	/* Indicate ADC scan loop is finished. */
 	/* Signal ReadADC() that scan is done. */
@@ -1135,7 +1136,7 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 
 	/* Restart RPS program at its beginning. */
 	*pRPS++ = RPS_JUMP;	/* Branch to start of RPS program. */
-	*pRPS++ = (uint32_t)devpriv->RPSBuf.physical_base;
+	*pRPS++ = (uint32_t)devpriv->rps_buf.physical_base;
 
 	/* End of RPS program build */
 }
@@ -1162,13 +1163,13 @@ static int s626_ai_rinsn(struct comedi_device *dev,
 	 * first uint16_t in the buffer because it contains junk data from
 	 * the final ADC of the previous poll list scan.
 	 */
-	readaddr = (uint32_t *)devpriv->ANABuf.logical_base + 1;
+	readaddr = (uint32_t *)devpriv->ana_buf.logical_base + 1;
 
 	/*
 	 * Convert ADC data to 16-bit integer values and
 	 * copy to application buffer.
 	 */
-	for (i = 0; i < devpriv->AdcItems; i++) {
+	for (i = 0; i < devpriv->adc_items; i++) {
 		*data = s626_ai_reg_to_uint(*readaddr++);
 		data++;
 	}
@@ -2022,7 +2023,7 @@ static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
 	 * enable mask to indicate the counter interrupt is disabled.
 	 */
 	if (DisableIntSrc)
-		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
+		devpriv->counter_int_enabs &= ~k->MyEventBits[3];
 
 	/*
 	 * While retaining CounterB and LatchSrc configurations, program the
@@ -2109,7 +2110,7 @@ static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
 	 * enable mask to indicate the counter interrupt is disabled.
 	 */
 	if (DisableIntSrc)
-		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
+		devpriv->counter_int_enabs &= ~k->MyEventBits[3];
 
 	/*
 	 * While retaining CounterA and LatchSrc configurations, program the
@@ -2202,8 +2203,8 @@ static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
 		    IntSource << CRABIT_INTSRC_A);
 
 	/* Update MISC2 interrupt enable mask. */
-	devpriv->CounterIntEnabs =
-	    (devpriv->CounterIntEnabs & ~k->
+	devpriv->counter_int_enabs =
+	    (devpriv->counter_int_enabs & ~k->
 	     MyEventBits[3]) | k->MyEventBits[IntSource];
 }
 
@@ -2226,8 +2227,8 @@ static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
 			     (IntSource << CRBBIT_INTSRC_B)));
 
 	/* Update MISC2 interrupt enable mask. */
-	devpriv->CounterIntEnabs =
-		(devpriv->CounterIntEnabs & ~k->MyEventBits[3]) |
+	devpriv->counter_int_enabs =
+		(devpriv->counter_int_enabs & ~k->MyEventBits[3]) |
 		k->MyEventBits[IntSource];
 }
 
@@ -2470,14 +2471,14 @@ static int s626_allocate_dma_buffers(struct comedi_device *dev)
 	addr = pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
 	if (!addr)
 		return -ENOMEM;
-	devpriv->ANABuf.logical_base = addr;
-	devpriv->ANABuf.physical_base = appdma;
+	devpriv->ana_buf.logical_base = addr;
+	devpriv->ana_buf.physical_base = appdma;
 
 	addr = pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
 	if (!addr)
 		return -ENOMEM;
-	devpriv->RPSBuf.logical_base = addr;
-	devpriv->RPSBuf.physical_base = appdma;
+	devpriv->rps_buf.logical_base = addr;
+	devpriv->rps_buf.physical_base = appdma;
 
 	return 0;
 }
@@ -2510,7 +2511,7 @@ static void s626_initialize(struct comedi_device *dev)
 	writel(GPIO_BASE | GPIO1_HI, devpriv->mmio + P_GPIO);
 
 	/* I2C device address for onboard eeprom (revb) */
-	devpriv->I2CAdrs = 0xA0;
+	devpriv->i2c_adrs = 0xA0;
 
 	/*
 	 * Issue an I2C ABORT command to halt any I2C
@@ -2557,7 +2558,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 
 	/* Physical start of RPS program */
-	writel((uint32_t)devpriv->RPSBuf.physical_base,
+	writel((uint32_t)devpriv->rps_buf.physical_base,
 	       devpriv->mmio + P_RPSADDR1);
 	/* RPS program performs no explicit mem writes */
 	writel(0, devpriv->mmio + P_RPSPAGE1);
@@ -2625,7 +2626,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * single DWORD will be transferred each time a DMA transfer is
 	 * enabled.
 	 */
-	pPhysBuf = devpriv->ANABuf.physical_base +
+	pPhysBuf = devpriv->ana_buf.physical_base +
 		   (DAC_WDMABUF_OS * sizeof(uint32_t));
 	writel((uint32_t)pPhysBuf, devpriv->mmio + P_BASEA2_OUT);
 	writel((uint32_t)(pPhysBuf + sizeof(uint32_t)),
@@ -2635,7 +2636,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * Cache Audio2's output DMA buffer logical address.  This is
 	 * where DAC data is buffered for A2 output DMA transfers.
 	 */
-	devpriv->pDacWBuf = (uint32_t *)devpriv->ANABuf.logical_base +
+	devpriv->dac_wbuf = (uint32_t *)devpriv->ana_buf.logical_base +
 			    DAC_WDMABUF_OS;
 
 	/*
@@ -2863,8 +2864,8 @@ static void s626_detach(struct comedi_device *dev)
 			writel(MC1_SHUTDOWN, devpriv->mmio + P_MC1);
 			writel(ACON1_BASE, devpriv->mmio + P_ACON1);
 
-			CloseDMAB(dev, &devpriv->RPSBuf, DMABUF_SIZE);
-			CloseDMAB(dev, &devpriv->ANABuf, DMABUF_SIZE);
+			CloseDMAB(dev, &devpriv->rps_buf, DMABUF_SIZE);
+			CloseDMAB(dev, &devpriv->ana_buf, DMABUF_SIZE);
 		}
 
 		if (dev->irq)

commit 3a3875067e25d9f7dae02c3858010310adc3a317
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:24 2013 +0100

    staging: comedi: s626: replace CamelCase struct bufferDMA
    
    Rename `struct bufferDMA` and its members to avoid CamelCase.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index c74b2f779cec..23bc419b47bf 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -84,9 +84,9 @@ struct s626_private {
 	uint16_t CounterIntEnabs;	/* counter interrupt enable mask
 					 * for MISC2 register */
 	uint8_t AdcItems;		/* number of items in ADC poll list */
-	struct bufferDMA RPSBuf;	/* DMA buffer used to hold ADC (RPS1)
+	struct buffer_dma RPSBuf;	/* DMA buffer used to hold ADC (RPS1)
 					 * program */
-	struct bufferDMA ANABuf;	/* DMA buffer used to receive ADC data
+	struct buffer_dma ANABuf;	/* DMA buffer used to receive ADC data
 					 * and hold DAC data */
 	uint32_t *pDacWBuf;		/* pointer to logical adrs of DMA buffer
 					 * used to hold DAC data */
@@ -857,7 +857,7 @@ static bool handle_eos_interrupt(struct comedi_device *dev)
 	 * first uint16_t in the buffer because it contains junk data
 	 * from the final ADC of the previous poll list scan.
 	 */
-	int32_t *readaddr = (int32_t *)devpriv->ANABuf.LogicalBase + 1;
+	int32_t *readaddr = (int32_t *)devpriv->ANABuf.logical_base + 1;
 	bool finished = false;
 	int i;
 
@@ -964,10 +964,10 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 	s626_mc_disable(dev, MC1_ERPS1, P_MC1);
 
 	/* Set starting logical address to write RPS commands. */
-	pRPS = (uint32_t *)devpriv->RPSBuf.LogicalBase;
+	pRPS = (uint32_t *)devpriv->RPSBuf.logical_base;
 
 	/* Initialize RPS instruction pointer */
-	writel((uint32_t)devpriv->RPSBuf.PhysicalBase,
+	writel((uint32_t)devpriv->RPSBuf.physical_base,
 	       devpriv->mmio + P_RPSADDR1);
 
 	/* Construct RPS program in RPSBuf DMA buffer */
@@ -1047,9 +1047,9 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 		 * instruction prefetch pipeline.
 		 */
 		JmpAdrs =
-			(uint32_t)devpriv->RPSBuf.PhysicalBase +
+			(uint32_t)devpriv->RPSBuf.physical_base +
 			(uint32_t)((unsigned long)pRPS -
-				   (unsigned long)devpriv->RPSBuf.LogicalBase);
+				   (unsigned long)devpriv->RPSBuf.logical_base);
 		for (i = 0; i < (10 * RPSCLK_PER_US / 2); i++) {
 			JmpAdrs += 8;	/* Repeat to implement time delay: */
 			*pRPS++ = RPS_JUMP; /* Jump to next RPS instruction. */
@@ -1079,7 +1079,7 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 
 		/* Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
 		*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
-		*pRPS++ = (uint32_t)devpriv->ANABuf.PhysicalBase +
+		*pRPS++ = (uint32_t)devpriv->ANABuf.physical_base +
 			  (devpriv->AdcItems << 2);
 
 		/*
@@ -1122,7 +1122,7 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 
 	/* Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
 	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
-	*pRPS++ = (uint32_t)devpriv->ANABuf.PhysicalBase +
+	*pRPS++ = (uint32_t)devpriv->ANABuf.physical_base +
 		  (devpriv->AdcItems << 2);
 
 	/* Indicate ADC scan loop is finished. */
@@ -1135,7 +1135,7 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 
 	/* Restart RPS program at its beginning. */
 	*pRPS++ = RPS_JUMP;	/* Branch to start of RPS program. */
-	*pRPS++ = (uint32_t)devpriv->RPSBuf.PhysicalBase;
+	*pRPS++ = (uint32_t)devpriv->RPSBuf.physical_base;
 
 	/* End of RPS program build */
 }
@@ -1162,7 +1162,7 @@ static int s626_ai_rinsn(struct comedi_device *dev,
 	 * first uint16_t in the buffer because it contains junk data from
 	 * the final ADC of the previous poll list scan.
 	 */
-	readaddr = (uint32_t *)devpriv->ANABuf.LogicalBase + 1;
+	readaddr = (uint32_t *)devpriv->ANABuf.logical_base + 1;
 
 	/*
 	 * Convert ADC data to 16-bit integer values and
@@ -1789,7 +1789,7 @@ static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
 	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE); /* Disable writes to MISC2. */
 }
 
-static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
+static void CloseDMAB(struct comedi_device *dev, struct buffer_dma *pdma,
 		      size_t bsize)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
@@ -1800,12 +1800,12 @@ static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
 		return;
 
 	/* find the matching allocation from the board struct */
-	vbptr = pdma->LogicalBase;
-	vpptr = pdma->PhysicalBase;
+	vbptr = pdma->logical_base;
+	vpptr = pdma->physical_base;
 	if (vbptr) {
 		pci_free_consistent(pcidev, bsize, vbptr, vpptr);
-		pdma->LogicalBase = NULL;
-		pdma->PhysicalBase = 0;
+		pdma->logical_base = NULL;
+		pdma->physical_base = 0;
 	}
 }
 
@@ -2470,14 +2470,14 @@ static int s626_allocate_dma_buffers(struct comedi_device *dev)
 	addr = pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
 	if (!addr)
 		return -ENOMEM;
-	devpriv->ANABuf.LogicalBase = addr;
-	devpriv->ANABuf.PhysicalBase = appdma;
+	devpriv->ANABuf.logical_base = addr;
+	devpriv->ANABuf.physical_base = appdma;
 
 	addr = pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
 	if (!addr)
 		return -ENOMEM;
-	devpriv->RPSBuf.LogicalBase = addr;
-	devpriv->RPSBuf.PhysicalBase = appdma;
+	devpriv->RPSBuf.logical_base = addr;
+	devpriv->RPSBuf.physical_base = appdma;
 
 	return 0;
 }
@@ -2557,7 +2557,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 
 	/* Physical start of RPS program */
-	writel((uint32_t)devpriv->RPSBuf.PhysicalBase,
+	writel((uint32_t)devpriv->RPSBuf.physical_base,
 	       devpriv->mmio + P_RPSADDR1);
 	/* RPS program performs no explicit mem writes */
 	writel(0, devpriv->mmio + P_RPSPAGE1);
@@ -2625,7 +2625,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * single DWORD will be transferred each time a DMA transfer is
 	 * enabled.
 	 */
-	pPhysBuf = devpriv->ANABuf.PhysicalBase +
+	pPhysBuf = devpriv->ANABuf.physical_base +
 		   (DAC_WDMABUF_OS * sizeof(uint32_t));
 	writel((uint32_t)pPhysBuf, devpriv->mmio + P_BASEA2_OUT);
 	writel((uint32_t)(pPhysBuf + sizeof(uint32_t)),
@@ -2635,7 +2635,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * Cache Audio2's output DMA buffer logical address.  This is
 	 * where DAC data is buffered for A2 output DMA transfers.
 	 */
-	devpriv->pDacWBuf = (uint32_t *)devpriv->ANABuf.LogicalBase +
+	devpriv->pDacWBuf = (uint32_t *)devpriv->ANABuf.logical_base +
 			    DAC_WDMABUF_OS;
 
 	/*

commit 6e3fc69d4cc034b12be487cbd93d19b9807dc7b5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:23 2013 +0100

    staging: comedi: s626: remove duplicate macros I2C_B0, I2C_B1, I2C_B2
    
    The `I2C_B0(ATTR, VAL)`, `I2C_B1(ATTR, VAL)` and `I2C_B2(ATTR, VAL)`
    macros are defined identically in "s626.h" and "s626.c".  Remove the
    duplicates from "s626.c".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 443e954719cf..c74b2f779cec 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -183,11 +183,6 @@ static bool s626_mc_test(struct comedi_device *dev,
 /* Write a time slot control record to TSL2. */
 #define VECTPORT(VECTNUM)		(P_TSL2 + ((VECTNUM) << 2))
 
-/* Code macros used for constructing I2C command bytes. */
-#define I2C_B2(ATTR, VAL)	(((ATTR) << 6) | ((VAL) << 24))
-#define I2C_B1(ATTR, VAL)	(((ATTR) << 4) | ((VAL) << 16))
-#define I2C_B0(ATTR, VAL)	(((ATTR) << 2) | ((VAL) <<  8))
-
 static const struct comedi_lrange s626_range_table = {
 	2, {
 		BIP_RANGE(5),

commit d5512f5b5b58e7ae47045315ade7df8873617992
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:22 2013 +0100

    staging: comedi: s626: remove I2CR and I2CW macros
    
    The `I2CR` and `I2CW` macros expand to the I2C read and write addresses,
    respectively.  They are only used in one place each and include the name
    of a local variable `devpriv` in their expansion.
    
    Get rid of the macros and expand them in place.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 58f2208bf56a..443e954719cf 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -309,7 +309,7 @@ static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 	 *  Byte1 = EEPROM internal target address.
 	 *  Byte0 = Not sent.
 	 */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW) |
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, devpriv->I2CAdrs) |
 			      I2C_B1(I2C_ATTRSTOP, addr) |
 			      I2C_B0(I2C_ATTRNOP, 0)))
 		/* Abort function and declare error if handshake failed. */
@@ -321,7 +321,7 @@ static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 	 *  Byte1 receives uint8_t from EEPROM.
 	 *  Byte0 = Not sent.
 	 */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR) |
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, (devpriv->I2CAdrs | 1)) |
 			      I2C_B1(I2C_ATTRSTOP, 0) |
 			      I2C_B0(I2C_ATTRNOP, 0)))
 		/* Abort function and declare error if handshake failed. */

commit e6132fc9ad90045f676f1838360af5a6bd789ecd
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:21 2013 +0100

    staging: comedi: s626: rename ai_continous
    
    Rename the `ai_continous` member of `struct s626_private` to
    `ai_continuous`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index acd3b94a5339..58f2208bf56a 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -74,7 +74,7 @@
 struct s626_private {
 	void __iomem *mmio;
 	uint8_t ai_cmd_running;		/* ai_cmd is running */
-	uint8_t ai_continous;		/* continuous acquisition */
+	uint8_t ai_continuous;		/* continuous acquisition */
 	int ai_sample_count;		/* number of samples to acquire */
 	unsigned int ai_sample_timer;	/* time between samples in
 					 * units of the timer */
@@ -885,7 +885,7 @@ static bool handle_eos_interrupt(struct comedi_device *dev)
 	/* end of scan occurs */
 	async->events |= COMEDI_CB_EOS;
 
-	if (!devpriv->ai_continous)
+	if (!devpriv->ai_continuous)
 		devpriv->ai_sample_count--;
 	if (devpriv->ai_sample_count <= 0) {
 		devpriv->ai_cmd_running = 0;
@@ -1469,11 +1469,11 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	case TRIG_COUNT:
 		/* data arrives as one packet */
 		devpriv->ai_sample_count = cmd->stop_arg;
-		devpriv->ai_continous = 0;
+		devpriv->ai_continuous = 0;
 		break;
 	case TRIG_NONE:
 		/* continuous acquisition */
-		devpriv->ai_continous = 1;
+		devpriv->ai_continuous = 1;
 		devpriv->ai_sample_count = 1;
 		break;
 	}

commit 498c5070cf4ee12b3b8ad7f47660d71ef089527e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:20 2013 +0100

    staging: comedi: s626: remove PCI ID defines
    
    The Sensoray 626 is based on the Philips SAA7146 chip using the Philips
    vendor and device ID for the chip, but with custom subdevice and
    subvendor IDs.  Use the Philips IDs in the PCI device table and replace
    the macros for the subvendor and subdevice IDs with open-coded values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index e59769d5b219..acd3b94a5339 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -71,11 +71,6 @@
 #include "comedi_fc.h"
 #include "s626.h"
 
-#define PCI_VENDOR_ID_S626 0x1131
-#define PCI_DEVICE_ID_S626 0x7146
-#define PCI_SUBVENDOR_ID_S626 0x6000
-#define PCI_SUBDEVICE_ID_S626 0x0272
-
 struct s626_private {
 	void __iomem *mmio;
 	uint8_t ai_cmd_running;		/* ai_cmd is running */
@@ -2904,8 +2899,8 @@ static int s626_pci_probe(struct pci_dev *dev,
  * Philips SAA7146 media/dvb based cards.
  */
 static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
-	{ PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626,
-	  PCI_SUBVENDOR_ID_S626, PCI_SUBDEVICE_ID_S626, 0, 0, 0, },
+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_PHILIPS, PCI_DEVICE_ID_PHILIPS_SAA7146,
+			 0x6000, 0x0272) },
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, s626_pci_table);

commit 730b8e15574687f03b9cf84b1ea5134648e6929b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:18 2013 +0100

    staging: comedi: s626: convert a printk()
    
    Convert a printk() to a dev_err().
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 99d1bed395ec..e59769d5b219 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1392,8 +1392,8 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int tick;
 
 	if (devpriv->ai_cmd_running) {
-		printk(KERN_ERR "s626_ai_cmd: Another ai_cmd is running %d\n",
-		       dev->minor);
+		dev_err(dev->class_dev,
+			"s626_ai_cmd: Another ai_cmd is running\n");
 		return -EBUSY;
 	}
 	/* disable interrupt */

commit 8ee52611415320d86f45c1d9c5f510bc8beffcf9
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:17 2013 +0100

    staging: comedi: s626: tidy up main source code file
    
    Tidy up the source code in "s626.c" and make it (slightly) more
    readable.  It's mostly whitespace changes although some large statements
    have been split into smaller statements.  It fixes most of the
    checkpatch errors and warnings.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4ac30ad7f1be..99d1bed395ec 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -78,61 +78,78 @@
 
 struct s626_private {
 	void __iomem *mmio;
-	uint8_t ai_cmd_running;	/*  ai_cmd is running */
-	uint8_t ai_continous;	/*  continous acquisition */
-	int ai_sample_count;	/*  number of samples to acquire */
-	unsigned int ai_sample_timer;
-	/*  time between samples in  units of the timer */
-	int ai_convert_count;	/*  conversion counter */
-	unsigned int ai_convert_timer;
-	/*  time between conversion in  units of the timer */
-	uint16_t CounterIntEnabs;
-	/* Counter interrupt enable  mask for MISC2 register. */
-	uint8_t AdcItems;	/* Number of items in ADC poll  list. */
-	struct bufferDMA RPSBuf;	/* DMA buffer used to hold ADC (RPS1) program. */
-	struct bufferDMA ANABuf;
-	/* DMA buffer used to receive ADC data and hold DAC data. */
-	uint32_t *pDacWBuf;
-	/* Pointer to logical adrs of DMA buffer used to hold DAC  data. */
-	uint16_t Dacpol;	/* Image of DAC polarity register. */
-	uint8_t TrimSetpoint[12];	/* Images of TrimDAC setpoints */
-	/* Charge Enabled (0 or WRMISC2_CHARGE_ENABLE). */
-	uint32_t I2CAdrs;
-	/* I2C device address for onboard EEPROM (board rev dependent). */
-	/*   short         I2Cards; */
+	uint8_t ai_cmd_running;		/* ai_cmd is running */
+	uint8_t ai_continous;		/* continuous acquisition */
+	int ai_sample_count;		/* number of samples to acquire */
+	unsigned int ai_sample_timer;	/* time between samples in
+					 * units of the timer */
+	int ai_convert_count;		/* conversion counter */
+	unsigned int ai_convert_timer;	/* time between conversion in
+					 * units of the timer */
+	uint16_t CounterIntEnabs;	/* counter interrupt enable mask
+					 * for MISC2 register */
+	uint8_t AdcItems;		/* number of items in ADC poll list */
+	struct bufferDMA RPSBuf;	/* DMA buffer used to hold ADC (RPS1)
+					 * program */
+	struct bufferDMA ANABuf;	/* DMA buffer used to receive ADC data
+					 * and hold DAC data */
+	uint32_t *pDacWBuf;		/* pointer to logical adrs of DMA buffer
+					 * used to hold DAC data */
+	uint16_t Dacpol;		/* image of DAC polarity register */
+	uint8_t TrimSetpoint[12];	/* images of TrimDAC setpoints */
+	uint32_t I2CAdrs;		/* I2C device address for onboard EEPROM
+					 * (board rev dependent) */
 	unsigned int ao_readback[S626_DAC_CHANNELS];
 };
 
-/*  COUNTER OBJECT ------------------------------------------------ */
+/* COUNTER OBJECT ------------------------------------------------ */
 struct enc_private {
-	/*  Pointers to functions that differ for A and B counters: */
-	uint16_t(*GetEnable) (struct comedi_device *dev, struct enc_private *);	/* Return clock enable. */
-	uint16_t(*GetIntSrc) (struct comedi_device *dev, struct enc_private *);	/* Return interrupt source. */
-	uint16_t(*GetLoadTrig) (struct comedi_device *dev, struct enc_private *);	/* Return preload trigger source. */
-	uint16_t(*GetMode) (struct comedi_device *dev, struct enc_private *);	/* Return standardized operating mode. */
-	void (*PulseIndex) (struct comedi_device *dev, struct enc_private *);	/* Generate soft index strobe. */
-	void (*SetEnable) (struct comedi_device *dev, struct enc_private *, uint16_t enab);	/* Program clock enable. */
-	void (*SetIntSrc) (struct comedi_device *dev, struct enc_private *, uint16_t IntSource);	/* Program interrupt source. */
-	void (*SetLoadTrig) (struct comedi_device *dev, struct enc_private *, uint16_t Trig);	/* Program preload trigger source. */
-	void (*SetMode) (struct comedi_device *dev, struct enc_private *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
-	void (*ResetCapFlags) (struct comedi_device *dev, struct enc_private *);	/* Reset event capture flags. */
-
-	uint16_t MyCRA;		/*    Address of CRA register. */
-	uint16_t MyCRB;		/*    Address of CRB register. */
-	uint16_t MyLatchLsw;	/*    Address of Latch least-significant-word */
-	/*    register. */
-	uint16_t MyEventBits[4];	/*    Bit translations for IntSrc -->RDMISC2. */
+	/* Pointers to functions that differ for A and B counters: */
+	/* Return clock enable. */
+	uint16_t(*GetEnable)(struct comedi_device *dev, struct enc_private *);
+	/* Return interrupt source. */
+	uint16_t(*GetIntSrc)(struct comedi_device *dev, struct enc_private *);
+	/* Return preload trigger source. */
+	uint16_t(*GetLoadTrig)(struct comedi_device *dev, struct enc_private *);
+	/* Return standardized operating mode. */
+	uint16_t(*GetMode)(struct comedi_device *dev, struct enc_private *);
+	/* Generate soft index strobe. */
+	void (*PulseIndex)(struct comedi_device *dev, struct enc_private *);
+	/* Program clock enable. */
+	void (*SetEnable)(struct comedi_device *dev, struct enc_private *,
+			  uint16_t enab);
+	/* Program interrupt source. */
+	void (*SetIntSrc)(struct comedi_device *dev, struct enc_private *,
+			  uint16_t IntSource);
+	/* Program preload trigger source. */
+	void (*SetLoadTrig)(struct comedi_device *dev, struct enc_private *,
+			    uint16_t Trig);
+	/* Program standardized operating mode. */
+	void (*SetMode)(struct comedi_device *dev, struct enc_private *,
+			uint16_t Setup, uint16_t DisableIntSrc);
+	/* Reset event capture flags. */
+	void (*ResetCapFlags)(struct comedi_device *dev, struct enc_private *);
+
+	uint16_t MyCRA;		/* address of CRA register */
+	uint16_t MyCRB;		/* address of CRB register */
+	uint16_t MyLatchLsw;	/* address of Latch least-significant-word
+				 * register */
+	uint16_t MyEventBits[4]; /* bit translations for IntSrc -->RDMISC2 */
 };
 
 #define encpriv ((struct enc_private *)(dev->subdevices+5)->private)
 
-/*  Counter overflow/index event flag masks for RDMISC2. */
-#define INDXMASK(C)		(1 << (((C) > 2) ? ((C) * 2 - 1) : ((C) * 2 +  4)))
-#define OVERMASK(C)		(1 << (((C) > 2) ? ((C) * 2 + 5) : ((C) * 2 + 10)))
-#define EVBITS(C)		{ 0, OVERMASK(C), INDXMASK(C), OVERMASK(C) | INDXMASK(C) }
+/* Counter overflow/index event flag masks for RDMISC2. */
+#define INDXMASK(C)	(1 << (((C) > 2) ? ((C) * 2 - 1) : ((C) * 2 +  4)))
+#define OVERMASK(C)	(1 << (((C) > 2) ? ((C) * 2 + 5) : ((C) * 2 + 10)))
+#define EVBITS(C)	{ 0, OVERMASK(C), INDXMASK(C), \
+			  OVERMASK(C) | INDXMASK(C) }
 
-/*  Translation table to map IntSrc into equivalent RDMISC2 event flag  bits. */
-/* static const uint16_t EventBits[][4] = { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) }; */
+/*
+ * Translation table to map IntSrc into equivalent RDMISC2 event flag  bits.
+ * static const uint16_t EventBits[][4] =
+ *     { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) };
+ */
 
 /*
  * Enable/disable a function or test status bit(s) that are accessed
@@ -168,10 +185,10 @@ static bool s626_mc_test(struct comedi_device *dev,
 
 #define BUGFIX_STREG(REGADRS)   (REGADRS - 4)
 
-/*  Write a time slot control record to TSL2. */
+/* Write a time slot control record to TSL2. */
 #define VECTPORT(VECTNUM)		(P_TSL2 + ((VECTNUM) << 2))
 
-/*  Code macros used for constructing I2C command bytes. */
+/* Code macros used for constructing I2C command bytes. */
 #define I2C_B2(ATTR, VAL)	(((ATTR) << 6) | ((VAL) << 24))
 #define I2C_B1(ATTR, VAL)	(((ATTR) << 4) | ((VAL) << 16))
 #define I2C_B0(ATTR, VAL)	(((ATTR) << 2) | ((VAL) <<  8))
@@ -183,8 +200,9 @@ static const struct comedi_lrange s626_range_table = {
 	}
 };
 
-/*  Execute a DEBI transfer.  This must be called from within a */
-/*  critical section. */
+/*
+ * Execute a DEBI transfer.  This must be called from within a critical section.
+ */
 static void DEBItransfer(struct comedi_device *dev)
 {
 	struct s626_private *devpriv = dev->private;
@@ -204,8 +222,9 @@ static void DEBItransfer(struct comedi_device *dev)
 		;
 }
 
-/*  Initialize the DEBI interface for all transfers. */
-
+/*
+ * Read a value from a gate array register.
+ */
 static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
 {
 	struct s626_private *devpriv = dev->private;
@@ -219,7 +238,9 @@ static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
 	return readl(devpriv->mmio + P_DEBIAD);
 }
 
-/*  Write a value to a gate array register. */
+/*
+ * Write a value to a gate array register.
+ */
 static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
 {
 	struct s626_private *devpriv = dev->private;
@@ -232,7 +253,8 @@ static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
 	DEBItransfer(dev);
 }
 
-/* Replace the specified bits in a gate array register.  Imports: mask
+/*
+ * Replace the specified bits in a gate array register.  Imports: mask
  * specifies bits that are to be preserved, wdata is new value to be
  * or'd with the masked original.
  */
@@ -281,54 +303,54 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 	return ctrl & I2C_ERR;
 }
 
-/*  Read uint8_t from EEPROM. */
+/* Read uint8_t from EEPROM. */
 static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 {
 	struct s626_private *devpriv = dev->private;
 
-	/*  Send EEPROM target address. */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)
-			 /* Byte2 = I2C command: write to I2C EEPROM  device. */
-			 | I2C_B1(I2C_ATTRSTOP, addr)
-			 /* Byte1 = EEPROM internal target address. */
-			 | I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not sent. */
-		/*  Abort function and declare error if handshake failed. */
+	/*
+	 * Send EEPROM target address:
+	 *  Byte2 = I2C command: write to I2C EEPROM device.
+	 *  Byte1 = EEPROM internal target address.
+	 *  Byte0 = Not sent.
+	 */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW) |
+			      I2C_B1(I2C_ATTRSTOP, addr) |
+			      I2C_B0(I2C_ATTRNOP, 0)))
+		/* Abort function and declare error if handshake failed. */
 		return 0;
-	}
-	/*  Execute EEPROM read. */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)
-
-			 /*  Byte2 = I2C */
-			 /*  command: read */
-			 /*  from I2C EEPROM */
-			 /*  device. */
-			 |I2C_B1(I2C_ATTRSTOP, 0)
 
-			 /*  Byte1 receives */
-			 /*  uint8_t from */
-			 /*  EEPROM. */
-			 |I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not  sent. */
-
-		/*  Abort function and declare error if handshake failed. */
+	/*
+	 * Execute EEPROM read:
+	 *  Byte2 = I2C command: read from I2C EEPROM device.
+	 *  Byte1 receives uint8_t from EEPROM.
+	 *  Byte0 = Not sent.
+	 */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR) |
+			      I2C_B1(I2C_ATTRSTOP, 0) |
+			      I2C_B0(I2C_ATTRNOP, 0)))
+		/* Abort function and declare error if handshake failed. */
 		return 0;
-	}
 
 	return (readl(devpriv->mmio + P_I2CCTRL) >> 16) & 0xff;
 }
 
 /* ***********  DAC FUNCTIONS *********** */
 
-/*  Slot 0 base settings. */
+/* Slot 0 base settings. */
 #define VECT0	(XSD2 | RSD3 | SIB_A2)
-/*  Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
+/* Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
 
-/*  TrimDac LogicalChan-to-PhysicalChan mapping table. */
+/* TrimDac LogicalChan-to-PhysicalChan mapping table. */
 static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 
-/*  TrimDac LogicalChan-to-EepromAdrs mapping table. */
-static uint8_t trimadrs[] = { 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
+/* TrimDac LogicalChan-to-EepromAdrs mapping table. */
+static uint8_t trimadrs[] = {
+	0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63
+};
 
-/* Private helper function: Transmit serial data to DAC via Audio
+/*
+ * Private helper function: Transmit serial data to DAC via Audio
  * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
  * Dacpol contains valid target image.
  */
@@ -338,7 +360,8 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 
 	/* START THE SERIAL CLOCK RUNNING ------------- */
 
-	/* Assert DAC polarity control and enable gating of DAC serial clock
+	/*
+	 * Assert DAC polarity control and enable gating of DAC serial clock
 	 * and audio bit stream signals.  At this point in time we must be
 	 * assured of being in time slot 0.  If we are not in slot 0, the
 	 * serial clock and audio stream signals will be disabled; this is
@@ -352,7 +375,6 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	/* TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- */
 
 	/* Copy DAC setpoint value to DAC's output DMA buffer. */
-
 	/* writel(val, devpriv->mmio + (uint32_t)devpriv->pDacWBuf); */
 	*devpriv->pDacWBuf = val;
 
@@ -364,7 +386,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 */
 	s626_mc_enable(dev, MC1_A2OUT, P_MC1);
 
-	/*  While the DMA transfer is executing ... */
+	/* While the DMA transfer is executing ... */
 
 	/*
 	 * Reset Audio2 output FIFO's underflow flag (along with any
@@ -373,7 +395,8 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 */
 	writel(ISR_AFOU, devpriv->mmio + P_ISR);
 
-	/* Wait for the DMA transfer to finish so that there will be data
+	/*
+	 * Wait for the DMA transfer to finish so that there will be data
 	 * available in the FIFO when time slot 1 tries to transfer a DWORD
 	 * from the FIFO to the output buffer register.  We test for DMA
 	 * Done by polling the DMAC enable flag; this flag is automatically
@@ -384,14 +407,16 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 
 	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
 
-	/* FIFO data is now available, so we enable execution of time slots
+	/*
+	 * FIFO data is now available, so we enable execution of time slots
 	 * 1 and higher by clearing the EOS flag in slot 0.  Note that SD3
 	 * will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
 	 * detection.
 	 */
 	writel(XSD2 | RSD3 | SIB_A2, devpriv->mmio + VECTPORT(0));
 
-	/* Wait for slot 1 to execute to ensure that the Packet will be
+	/*
+	 * Wait for slot 1 to execute to ensure that the Packet will be
 	 * transmitted.  This is detected by polling the Audio2 output FIFO
 	 * underflow flag, which will be set when slot 1 execution has
 	 * finished transferring the DAC's data DWORD from the output FIFO
@@ -400,7 +425,8 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	while (!(readl(devpriv->mmio + P_SSR) & SSR_AF2_OUT))
 		;
 
-	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
+	/*
+	 * Set up to trap execution at slot 0 when the TSL sequencer cycles
 	 * back to slot 0 after executing the EOS in slot 5.  Also,
 	 * simultaneously shift out and in the 0x00 that is ALWAYS the value
 	 * stored in the last byte to be shifted out of the FIFO's DWORD
@@ -411,7 +437,8 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 
 	/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */
 
-	/* Wait for the TSL to finish executing all time slots before
+	/*
+	 * Wait for the TSL to finish executing all time slots before
 	 * exiting this function.  We must do this so that the next DAC
 	 * write doesn't start, thereby enabling clock/chip select signals:
 	 *
@@ -429,7 +456,8 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 *    the TSL has not yet finished executing slot 5 ...
 	 */
 	if (readl(devpriv->mmio + P_FB_BUFFER2) & 0xff000000) {
-		/* The trap was set on time and we are still executing somewhere
+		/*
+		 * The trap was set on time and we are still executing somewhere
 		 * in slots 2-5, so we now wait for slot 0 to execute and trap
 		 * TSL execution.  This is detected when FB_BUFFER2 MSB changes
 		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
@@ -438,7 +466,8 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 		while (readl(devpriv->mmio + P_FB_BUFFER2) & 0xff000000)
 			;
 	}
-	/* Either (1) we were too late setting the slot 0 trap; the TSL
+	/*
+	 * Either (1) we were too late setting the slot 0 trap; the TSL
 	 * sequencer restarted slot 0 before we could set the EOS trap flag,
 	 * or (2) we were not late and execution is now trapped at slot 0.
 	 * In either case, we must now change slot 0 so that it will store
@@ -448,7 +477,8 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 */
 	writel(RSD3 | SIB_A2 | EOS, devpriv->mmio + VECTPORT(0));
 
-	/* Wait for slot 0 to execute, at which time the TSL is setup for
+	/*
+	 * Wait for slot 0 to execute, at which time the TSL is setup for
 	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
 	 * from 0x00 to 0xFF.
 	 */
@@ -456,27 +486,33 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 		;
 }
 
-/*  Private helper function: Write setpoint to an application DAC channel. */
+/*
+ * Private helper function: Write setpoint to an application DAC channel.
+ */
 static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
 {
 	struct s626_private *devpriv = dev->private;
-	register uint16_t signmask;
-	register uint32_t WSImage;
+	uint16_t signmask;
+	uint32_t WSImage;
+	uint32_t val;
 
-	/*  Adjust DAC data polarity and set up Polarity Control Register */
-	/*  image. */
+	/*
+	 * Adjust DAC data polarity and set up Polarity Control Register image.
+	 */
 	signmask = 1 << chan;
 	if (dacdata < 0) {
 		dacdata = -dacdata;
 		devpriv->Dacpol |= signmask;
-	} else
+	} else {
 		devpriv->Dacpol &= ~signmask;
+	}
 
-	/*  Limit DAC setpoint value to valid range. */
-	if ((uint16_t) dacdata > 0x1FFF)
+	/* Limit DAC setpoint value to valid range. */
+	if ((uint16_t)dacdata > 0x1FFF)
 		dacdata = 0x1FFF;
 
-	/* Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
+	/*
+	 * Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
 	 * and V3 transmit the setpoint to the target DAC.  V4 and V5 send
 	 * data to a non-existent TrimDac channel just to keep the clock
 	 * running after sending data to the target DAC.  This is necessary
@@ -497,21 +533,21 @@ static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
 	/* Slot 5: running after writing target DAC's low data byte */
 	writel(XSD2 | XFIFO_2 | WS3 | EOS, devpriv->mmio + VECTPORT(5));
 
-	/*  Construct and transmit target DAC's serial packet:
-	 * ( A10D DDDD ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan<0>,
+	/*
+	 * Construct and transmit target DAC's serial packet:
+	 * (A10D DDDD), (DDDD DDDD), (0x0F), (0x00) where A is chan<0>,
 	 * and D<12:0> is the DAC setpoint.  Append a WORD value (that writes
 	 * to a  non-existent TrimDac channel) that serves to keep the clock
 	 * running after the packet has been sent to the target DAC.
 	 */
-	SendDAC(dev, 0x0F000000
-		/* Continue clock after target DAC data (write to non-existent trimdac). */
-		| 0x00004000
-		/* Address the two main dual-DAC devices (TSL's chip select enables
-		 * target device). */
-		| ((uint32_t) (chan & 1) << 15)
-		/*  Address the DAC channel within the  device. */
-		| (uint32_t) dacdata);	/*  Include DAC setpoint data. */
-
+	val = 0x0F000000;	/* Continue clock after target DAC data
+				 * (write to non-existent trimdac). */
+	val |= 0x00004000;	/* Address the two main dual-DAC devices
+				 * (TSL's chip select enables target device). */
+	val |= ((uint32_t)(chan & 1) << 15);	/* Address the DAC channel
+						 * within the device. */
+	val |= (uint32_t)dacdata;	/* Include DAC setpoint data. */
+	SendDAC(dev, val);
 }
 
 static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
@@ -520,13 +556,17 @@ static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
 	struct s626_private *devpriv = dev->private;
 	uint32_t chan;
 
-	/*  Save the new setpoint in case the application needs to read it back later. */
-	devpriv->TrimSetpoint[LogicalChan] = (uint8_t) DacData;
+	/*
+	 * Save the new setpoint in case the application needs to read it back
+	 * later.
+	 */
+	devpriv->TrimSetpoint[LogicalChan] = (uint8_t)DacData;
 
-	/*  Map logical channel number to physical channel number. */
-	chan = (uint32_t) trimchan[LogicalChan];
+	/* Map logical channel number to physical channel number. */
+	chan = trimchan[LogicalChan];
 
-	/* Set up TSL2 records for TrimDac write operation.  All slots shift
+	/*
+	 * Set up TSL2 records for TrimDac write operation.  All slots shift
 	 * 0xFF in from pulled-up SD3 so that the end of the slot sequence
 	 * can be detected.
 	 */
@@ -540,69 +580,77 @@ static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
 	/* Slot 5: Send NOP low  uint8_t to DAC0 */
 	writel(XSD2 | XFIFO_2 | WS1 | EOS, devpriv->mmio + VECTPORT(5));
 
-	/* Construct and transmit target DAC's serial packet:
-	 * ( 0000 AAAA ), ( DDDD DDDD ),( 0x00 ),( 0x00 ) where A<3:0> is the
+	/*
+	 * Construct and transmit target DAC's serial packet:
+	 * (0000 AAAA), (DDDD DDDD), (0x00), (0x00) where A<3:0> is the
 	 * DAC channel's address, and D<7:0> is the DAC setpoint.  Append a
 	 * WORD value (that writes a channel 0 NOP command to a non-existent
 	 * main DAC channel) that serves to keep the clock running after the
 	 * packet has been sent to the target DAC.
 	 */
 
-	/*  Address the DAC channel within the trimdac device. */
-	SendDAC(dev, ((uint32_t) chan << 8)
-		| (uint32_t) DacData);	/*  Include DAC setpoint data. */
+	/*
+	 * Address the DAC channel within the trimdac device.
+	 * Include DAC setpoint data.
+	 */
+	SendDAC(dev, (chan << 8) | DacData);
 }
 
 static void LoadTrimDACs(struct comedi_device *dev)
 {
-	register uint8_t i;
+	uint8_t i;
 
-	/*  Copy TrimDac setpoint values from EEPROM to TrimDacs. */
+	/* Copy TrimDac setpoint values from EEPROM to TrimDacs. */
 	for (i = 0; i < ARRAY_SIZE(trimchan); i++)
 		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
 }
 
 /* ******  COUNTER FUNCTIONS  ******* */
-/* All counter functions address a specific counter by means of the
+
+/*
+ * All counter functions address a specific counter by means of the
  * "Counter" argument, which is a logical counter number.  The Counter
  * argument may have any of the following legal values: 0=0A, 1=1A,
  * 2=2A, 3=0B, 4=1B, 5=2B.
  */
 
-/*  Read a counter's output latch. */
+/*
+ * Read a counter's output latch.
+ */
 static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
 {
-	register uint32_t value;
+	uint32_t value;
 
-	/*  Latch counts and fetch LSW of latched counts value. */
-	value = (uint32_t) DEBIread(dev, k->MyLatchLsw);
+	/* Latch counts and fetch LSW of latched counts value. */
+	value = DEBIread(dev, k->MyLatchLsw);
 
-	/*  Fetch MSW of latched counts and combine with LSW. */
-	value |= ((uint32_t) DEBIread(dev, k->MyLatchLsw + 2) << 16);
+	/* Fetch MSW of latched counts and combine with LSW. */
+	value |= ((uint32_t)DEBIread(dev, k->MyLatchLsw + 2) << 16);
 
-	/*  Return latched counts. */
+	/* Return latched counts. */
 	return value;
 }
 
-/* Return/set a counter pair's latch trigger source.  0: On read
+/*
+ * Return/set a counter pair's latch trigger source.  0: On read
  * access, 1: A index latches A, 2: B index latches B, 3: A overflow
  * latches B.
  */
 static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
 			   uint16_t value)
 {
-	DEBIreplace(dev, k->MyCRB,
-		    ~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC),
+	DEBIreplace(dev, k->MyCRB, ~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC),
 		    value << CRBBIT_LATCHSRC);
 }
 
-/*  Write value into counter preload register. */
+/*
+ * Write value into counter preload register.
+ */
 static void Preload(struct comedi_device *dev, struct enc_private *k,
 		    uint32_t value)
 {
-	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);
-	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw + 2),
-		  (uint16_t) (value >> 16));
+	DEBIwrite(dev, k->MyLatchLsw, value);
+	DEBIwrite(dev, k->MyLatchLsw + 2, value >> 16);
 }
 
 static unsigned int s626_ai_reg_to_uint(int data)
@@ -618,10 +666,6 @@ static unsigned int s626_ai_reg_to_uint(int data)
 	return tempdata;
 }
 
-/* static unsigned int s626_uint_to_reg(struct comedi_subdevice *s, int data){ */
-/*   return 0; */
-/* } */
-
 static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
 {
 	unsigned int group = chan / 16;
@@ -879,7 +923,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 
 	if (!dev->attached)
 		return IRQ_NONE;
-	/*  lock to avoid race with comedi_poll */
+	/* lock to avoid race with comedi_poll */
 	spin_lock_irqsave(&dev->spinlock, flags);
 
 	/* save interrupt enable register state */
@@ -895,11 +939,11 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	writel(irqtype, devpriv->mmio + P_ISR);
 
 	switch (irqtype) {
-	case IRQ_RPS1:		/*  end_of_scan occurs */
+	case IRQ_RPS1:	/* end_of_scan occurs */
 		if (handle_eos_interrupt(dev))
 			irqstatus = 0;
 		break;
-	case IRQ_GPIO3:	/* check dio and conter interrupt */
+	case IRQ_GPIO3:	/* check dio and counter interrupt */
 		/* s626_dio_clear_irq(dev); */
 		check_dio_interrupts(dev);
 		check_counter_interrupts(dev);
@@ -914,153 +958,152 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 }
 
 /*
- * this functions build the RPS program for hardware driven acquistion
+ * This function builds the RPS program for hardware driven acquisition.
  */
 static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 {
 	struct s626_private *devpriv = dev->private;
-	register uint32_t *pRPS;
+	uint32_t *pRPS;
 	uint32_t JmpAdrs;
 	uint16_t i;
 	uint16_t n;
 	uint32_t LocalPPL;
-	struct comedi_cmd *cmd = &(dev->subdevices->async->cmd);
+	struct comedi_cmd *cmd = &dev->subdevices->async->cmd;
 
 	/* Stop RPS program in case it is currently running */
 	s626_mc_disable(dev, MC1_ERPS1, P_MC1);
 
-	/*  Set starting logical address to write RPS commands. */
-	pRPS = (uint32_t *) devpriv->RPSBuf.LogicalBase;
+	/* Set starting logical address to write RPS commands. */
+	pRPS = (uint32_t *)devpriv->RPSBuf.LogicalBase;
 
 	/* Initialize RPS instruction pointer */
 	writel((uint32_t)devpriv->RPSBuf.PhysicalBase,
 	       devpriv->mmio + P_RPSADDR1);
 
-	/*  Construct RPS program in RPSBuf DMA buffer */
-
+	/* Construct RPS program in RPSBuf DMA buffer */
 	if (cmd != NULL && cmd->scan_begin_src != TRIG_FOLLOW) {
-		/*  Wait for Start trigger. */
+		/* Wait for Start trigger. */
 		*pRPS++ = RPS_PAUSE | RPS_SIGADC;
 		*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
 	}
 
-	/* SAA7146 BUG WORKAROUND Do a dummy DEBI Write.  This is necessary
+	/*
+	 * SAA7146 BUG WORKAROUND Do a dummy DEBI Write.  This is necessary
 	 * because the first RPS DEBI Write following a non-RPS DEBI write
 	 * seems to always fail.  If we don't do this dummy write, the ADC
 	 * gain might not be set to the value required for the first slot in
 	 * the poll list; the ADC gain would instead remain unchanged from
 	 * the previously programmed value.
 	 */
-	*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
 	/* Write DEBI Write command and address to shadow RAM. */
-
+	*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
 	*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
 	*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
-	/*  Write DEBI immediate data  to shadow RAM: */
-
-	*pRPS++ = GSEL_BIPOLAR5V;
-	/*  arbitrary immediate data  value. */
-
+	/* Write DEBI immediate data  to shadow RAM: */
+	*pRPS++ = GSEL_BIPOLAR5V;	/* arbitrary immediate data  value. */
 	*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
-	/*  Reset "shadow RAM  uploaded" flag. */
-	*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/*  Invoke shadow RAM upload. */
-	*pRPS++ = RPS_PAUSE | RPS_DEBI;	/*  Wait for shadow upload to finish. */
+	/* Reset "shadow RAM  uploaded" flag. */
+	*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/* Invoke shadow RAM upload. */
+	*pRPS++ = RPS_PAUSE | RPS_DEBI;	/* Wait for shadow upload to finish. */
 
-	/* Digitize all slots in the poll list. This is implemented as a
+	/*
+	 * Digitize all slots in the poll list. This is implemented as a
 	 * for loop to limit the slot count to 16 in case the application
 	 * forgot to set the EOPL flag in the final slot.
 	 */
-	for (devpriv->AdcItems = 0; devpriv->AdcItems < 16; devpriv->AdcItems++) {
-		/* Convert application's poll list item to private board class
+	for (devpriv->AdcItems = 0; devpriv->AdcItems < 16;
+	     devpriv->AdcItems++) {
+		/*
+		 * Convert application's poll list item to private board class
 		 * format.  Each app poll list item is an uint8_t with form
 		 * (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
 		 * +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
 		 */
-		LocalPPL =
-		    (*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
-				   GSEL_BIPOLAR10V);
-
-		/*  Switch ADC analog gain. */
-		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	/*  Write DEBI command */
-		/*  and address to */
-		/*  shadow RAM. */
+		LocalPPL = (*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
+					  GSEL_BIPOLAR10V);
+
+		/* Switch ADC analog gain. */
+		/* Write DEBI command and address to shadow RAM. */
+		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
 		*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
-		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	/*  Write DEBI */
-		/*  immediate data to */
-		/*  shadow RAM. */
+		/* Write DEBI immediate data to shadow RAM. */
+		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
 		*pRPS++ = LocalPPL;
-		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	/*  Reset "shadow RAM uploaded" */
-		/*  flag. */
-		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/*  Invoke shadow RAM upload. */
-		*pRPS++ = RPS_PAUSE | RPS_DEBI;	/*  Wait for shadow upload to */
-		/*  finish. */
-
-		/*  Select ADC analog input channel. */
+		/* Reset "shadow RAM uploaded" flag. */
+		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
+		/* Invoke shadow RAM upload. */
+		*pRPS++ = RPS_UPLOAD | RPS_DEBI;
+		/* Wait for shadow upload to finish. */
+		*pRPS++ = RPS_PAUSE | RPS_DEBI;
+		/* Select ADC analog input channel. */
 		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
-		/*  Write DEBI command and address to  shadow RAM. */
+		/* Write DEBI command and address to shadow RAM. */
 		*pRPS++ = DEBI_CMD_WRWORD | LP_ISEL;
 		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
-		/*  Write DEBI immediate data to shadow RAM. */
+		/* Write DEBI immediate data to shadow RAM. */
 		*pRPS++ = LocalPPL;
+		/* Reset "shadow RAM uploaded" flag. */
 		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
-		/*  Reset "shadow RAM uploaded"  flag. */
-
+		/* Invoke shadow RAM upload. */
 		*pRPS++ = RPS_UPLOAD | RPS_DEBI;
-		/*  Invoke shadow RAM upload. */
-
+		/* Wait for shadow upload to finish. */
 		*pRPS++ = RPS_PAUSE | RPS_DEBI;
-		/*  Wait for shadow upload to finish. */
 
-		/* Delay at least 10 microseconds for analog input settling.
+		/*
+		 * Delay at least 10 microseconds for analog input settling.
 		 * Instead of padding with NOPs, we use RPS_JUMP instructions
 		 * here; this allows us to produce a longer delay than is
 		 * possible with NOPs because each RPS_JUMP flushes the RPS'
 		 * instruction prefetch pipeline.
 		 */
 		JmpAdrs =
-		    (uint32_t) devpriv->RPSBuf.PhysicalBase +
-		    (uint32_t) ((unsigned long)pRPS -
-				(unsigned long)devpriv->RPSBuf.LogicalBase);
+			(uint32_t)devpriv->RPSBuf.PhysicalBase +
+			(uint32_t)((unsigned long)pRPS -
+				   (unsigned long)devpriv->RPSBuf.LogicalBase);
 		for (i = 0; i < (10 * RPSCLK_PER_US / 2); i++) {
-			JmpAdrs += 8;	/*  Repeat to implement time delay: */
-			*pRPS++ = RPS_JUMP;	/*  Jump to next RPS instruction. */
+			JmpAdrs += 8;	/* Repeat to implement time delay: */
+			*pRPS++ = RPS_JUMP; /* Jump to next RPS instruction. */
 			*pRPS++ = JmpAdrs;
 		}
 
 		if (cmd != NULL && cmd->convert_src != TRIG_NOW) {
-			/*  Wait for Start trigger. */
+			/* Wait for Start trigger. */
 			*pRPS++ = RPS_PAUSE | RPS_SIGADC;
 			*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
 		}
-		/*  Start ADC by pulsing GPIO1. */
-		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  Begin ADC Start pulse. */
+		/* Start ADC by pulsing GPIO1. */
+		/* Begin ADC Start pulse. */
+		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);
 		*pRPS++ = GPIO_BASE | GPIO1_LO;
 		*pRPS++ = RPS_NOP;
-		/*  VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
-		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  End ADC Start pulse. */
+		/* VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
+		/* End ADC Start pulse. */
+		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);
 		*pRPS++ = GPIO_BASE | GPIO1_HI;
-
-		/* Wait for ADC to complete (GPIO2 is asserted high when ADC not
+		/*
+		 * Wait for ADC to complete (GPIO2 is asserted high when ADC not
 		 * busy) and for data from previous conversion to shift into FB
 		 * BUFFER 1 register.
 		 */
-		*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/*  Wait for ADC done. */
+		*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/* Wait for ADC done. */
 
-		/*  Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
+		/* Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
 		*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
-		*pRPS++ =
-		    (uint32_t) devpriv->ANABuf.PhysicalBase +
-		    (devpriv->AdcItems << 2);
+		*pRPS++ = (uint32_t)devpriv->ANABuf.PhysicalBase +
+			  (devpriv->AdcItems << 2);
 
-		/*  If this slot's EndOfPollList flag is set, all channels have */
-		/*  now been processed. */
+		/*
+		 * If this slot's EndOfPollList flag is set, all channels have
+		 * now been processed.
+		 */
 		if (*ppl++ & EOPL) {
-			devpriv->AdcItems++;	/*  Adjust poll list item count. */
-			break;	/*  Exit poll list processing loop. */
+			devpriv->AdcItems++; /* Adjust poll list item count. */
+			break;	/* Exit poll list processing loop. */
 		}
 	}
 
-	/* VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
+	/*
+	 * VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
 	 * ADC to stabilize for 2 microseconds before starting the final
 	 * (dummy) conversion.  This delay is necessary to allow sufficient
 	 * time between last conversion finished and the start of the dummy
@@ -1070,38 +1113,41 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 	for (n = 0; n < (2 * RPSCLK_PER_US); n++)
 		*pRPS++ = RPS_NOP;
 
-	/* Start a dummy conversion to cause the data from the last
+	/*
+	 * Start a dummy conversion to cause the data from the last
 	 * conversion of interest to be shifted in.
 	 */
-	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  Begin ADC Start pulse. */
+	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/* Begin ADC Start pulse. */
 	*pRPS++ = GPIO_BASE | GPIO1_LO;
 	*pRPS++ = RPS_NOP;
 	/* VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
-	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  End ADC Start pulse. */
+	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/* End ADC Start pulse. */
 	*pRPS++ = GPIO_BASE | GPIO1_HI;
 
-	/* Wait for the data from the last conversion of interest to arrive
+	/*
+	 * Wait for the data from the last conversion of interest to arrive
 	 * in FB BUFFER 1 register.
 	 */
-	*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/*  Wait for ADC done. */
+	*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/* Wait for ADC done. */
 
-	/*  Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
-	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);	/*  */
-	*pRPS++ =
-	    (uint32_t) devpriv->ANABuf.PhysicalBase + (devpriv->AdcItems << 2);
+	/* Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
+	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
+	*pRPS++ = (uint32_t)devpriv->ANABuf.PhysicalBase +
+		  (devpriv->AdcItems << 2);
 
-	/*  Indicate ADC scan loop is finished. */
-	/*  *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC ;  // Signal ReadADC() that scan is done. */
+	/* Indicate ADC scan loop is finished. */
+	/* Signal ReadADC() that scan is done. */
+	/* *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC; */
 
 	/* invoke interrupt */
-	if (devpriv->ai_cmd_running == 1) {
+	if (devpriv->ai_cmd_running == 1)
 		*pRPS++ = RPS_IRQ;
-	}
-	/*  Restart RPS program at its beginning. */
-	*pRPS++ = RPS_JUMP;	/*  Branch to start of RPS program. */
-	*pRPS++ = (uint32_t) devpriv->RPSBuf.PhysicalBase;
 
-	/*  End of RPS program build */
+	/* Restart RPS program at its beginning. */
+	*pRPS++ = RPS_JUMP;	/* Branch to start of RPS program. */
+	*pRPS++ = (uint32_t)devpriv->RPSBuf.PhysicalBase;
+
+	/* End of RPS program build */
 }
 
 #ifdef unused_code
@@ -1111,8 +1157,8 @@ static int s626_ai_rinsn(struct comedi_device *dev,
 			 unsigned int *data)
 {
 	struct s626_private *devpriv = dev->private;
-	register uint8_t i;
-	register int32_t *readaddr;
+	uint8_t i;
+	int32_t *readaddr;
 
 	/* Trigger ADC scan loop start */
 	s626_mc_enable(dev, MC2_ADC_RPS, P_MC2);
@@ -1153,7 +1199,8 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	int tmp;
 	int n;
 
-	/* Convert application's ADC specification into form
+	/*
+	 * Convert application's ADC specification into form
 	 *  appropriate for register programming.
 	 */
 	if (range == 0)
@@ -1161,15 +1208,14 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	else
 		AdcSpec = (chan << 8) | (GSEL_BIPOLAR10V);
 
-	/*  Switch ADC analog gain. */
-	DEBIwrite(dev, LP_GSEL, AdcSpec);	/*  Set gain. */
+	/* Switch ADC analog gain. */
+	DEBIwrite(dev, LP_GSEL, AdcSpec);	/* Set gain. */
 
-	/*  Select ADC analog input channel. */
-	DEBIwrite(dev, LP_ISEL, AdcSpec);	/*  Select channel. */
+	/* Select ADC analog input channel. */
+	DEBIwrite(dev, LP_ISEL, AdcSpec);	/* Select channel. */
 
 	for (n = 0; n < insn->n; n++) {
-
-		/*  Delay 10 microseconds for analog input settling. */
+		/* Delay 10 microseconds for analog input settling. */
 		udelay(10);
 
 		/* Start ADC by pulsing GPIO1 low */
@@ -1182,9 +1228,11 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 		/* Negate ADC Start command */
 		writel(GpioImage | GPIO1_HI, devpriv->mmio + P_GPIO);
 
-		/*  Wait for ADC to complete (GPIO2 is asserted high when */
-		/*  ADC not busy) and for data from previous conversion to */
-		/*  shift into FB BUFFER 1 register. */
+		/*
+		 * Wait for ADC to complete (GPIO2 is asserted high when
+		 * ADC not busy) and for data from previous conversion to
+		 * shift into FB BUFFER 1 register.
+		 */
 
 		/* Wait for ADC done */
 		while (!(readl(devpriv->mmio + P_PSR) & PSR_GPIO2))
@@ -1196,7 +1244,8 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 			data[n - 1] = s626_ai_reg_to_uint(tmp);
 		}
 
-		/* Allow the ADC to stabilize for 4 microseconds before
+		/*
+		 * Allow the ADC to stabilize for 4 microseconds before
 		 * starting the next (final) conversion.  This delay is
 		 * necessary to allow sufficient time between last
 		 * conversion finished and the start of the next
@@ -1207,8 +1256,10 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 		udelay(4);
 	}
 
-	/* Start a dummy conversion to cause the data from the
-	 * previous conversion to be shifted in. */
+	/*
+	 * Start a dummy conversion to cause the data from the
+	 * previous conversion to be shifted in.
+	 */
 	GpioImage = readl(devpriv->mmio + P_GPIO);
 	/* Assert ADC Start command */
 	writel(GpioImage & ~GPIO1_HI, devpriv->mmio + P_GPIO);
@@ -1218,13 +1269,13 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	/* Negate ADC Start command */
 	writel(GpioImage | GPIO1_HI, devpriv->mmio + P_GPIO);
 
-	/*  Wait for the data to arrive in FB BUFFER 1 register. */
+	/* Wait for the data to arrive in FB BUFFER 1 register. */
 
 	/* Wait for ADC done */
 	while (!(readl(devpriv->mmio + P_PSR) & PSR_GPIO2))
 		;
 
-	/*  Fetch ADC data from audio interface's input shift register. */
+	/* Fetch ADC data from audio interface's input shift register. */
 
 	/* Fetch ADC data */
 	if (n != 0) {
@@ -1237,14 +1288,13 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 
 static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)
 {
-
 	int n;
 
 	for (n = 0; n < cmd->chanlist_len; n++) {
-		if (CR_RANGE((cmd->chanlist)[n]) == 0)
-			ppl[n] = (CR_CHAN((cmd->chanlist)[n])) | (RANGE_5V);
+		if (CR_RANGE(cmd->chanlist[n]) == 0)
+			ppl[n] = CR_CHAN(cmd->chanlist[n]) | RANGE_5V;
 		else
-			ppl[n] = (CR_CHAN((cmd->chanlist)[n])) | (RANGE_10V);
+			ppl[n] = CR_CHAN(cmd->chanlist[n]) | RANGE_10V;
 	}
 	if (n != 0)
 		ppl[n - 1] |= EOPL;
@@ -1266,11 +1316,13 @@ static int s626_ai_inttrig(struct comedi_device *dev,
 	return 1;
 }
 
-/* This function doesn't require a particular form, this is just what
+/*
+ * This function doesn't require a particular form, this is just what
  * happens to be used in some of the drivers.  It should convert ns
  * nanoseconds to a counter value suitable for programming the device.
  * Also, it should adjust ns so that it cooresponds to the actual time
- * that the device will use. */
+ * that the device will use.
+ */
 static int s626_ns_to_timer(int *nanosec, int round_mode)
 {
 	int divider, base;
@@ -1297,24 +1349,26 @@ static int s626_ns_to_timer(int *nanosec, int round_mode)
 static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 			    int tick)
 {
-	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
-	    /*  index. */
-	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
-	    (CLKSRC_TIMER << BF_CLKSRC) |	/*  Operating mode is Timer. */
-	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
-	    (CNTDIR_DOWN << BF_CLKPOL) |	/*  Count direction is Down. */
-	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
-	    (CLKENAB_INDEX << BF_CLKENAB);
+	uint16_t Setup =
+		(LOADSRC_INDX << BF_LOADSRC) |	/* Preload upon index. */
+		(INDXSRC_SOFT << BF_INDXSRC) |	/* Disable hardware index. */
+		(CLKSRC_TIMER << BF_CLKSRC) |	/* Operating mode is Timer. */
+		(CLKPOL_POS << BF_CLKPOL) |	/* Active high clock. */
+		(CNTDIR_DOWN << BF_CLKPOL) |	/* Count direction is Down. */
+		(CLKMULT_1X << BF_CLKMULT) |	/* Clock multiplier is 1x. */
+		(CLKENAB_INDEX << BF_CLKENAB);
 	uint16_t valueSrclatch = LATCHSRC_A_INDXA;
-	/*   uint16_t enab=CLKENAB_ALWAYS; */
+	/* uint16_t enab = CLKENAB_ALWAYS; */
 
 	k->SetMode(dev, k, Setup, FALSE);
 
-	/*  Set the preload register */
+	/* Set the preload register */
 	Preload(dev, k, tick);
 
-	/*  Software index pulse forces the preload register to load */
-	/*  into the counter */
+	/*
+	 * Software index pulse forces the preload register to load
+	 * into the counter
+	 */
 	k->SetLoadTrig(dev, k, 0);
 	k->PulseIndex(dev, k);
 
@@ -1325,10 +1379,10 @@ static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 	k->SetIntSrc(dev, k, INTSRC_OVER);
 
 	SetLatchSource(dev, k, valueSrclatch);
-	/*   k->SetEnable(dev,k,(uint16_t)(enab != 0)); */
+	/* k->SetEnable(dev, k, (uint16_t)(enab != 0)); */
 }
 
-/*  TO COMPLETE  */
+/* TO COMPLETE  */
 static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct s626_private *devpriv = dev->private;
@@ -1350,12 +1404,12 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* clear any pending interrupt */
 	s626_dio_clear_irq(dev);
-	/*   s626_enc_clear_irq(dev); */
+	/* s626_enc_clear_irq(dev); */
 
 	/* reset ai_cmd_running flag */
 	devpriv->ai_cmd_running = 0;
 
-	/*  test if cmd is valid */
+	/* test if cmd is valid */
 	if (cmd == NULL)
 		return -EINVAL;
 
@@ -1373,7 +1427,10 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	case TRIG_FOLLOW:
 		break;
 	case TRIG_TIMER:
-		/*  set a conter to generate adc trigger at scan_begin_arg interval */
+		/*
+		 * set a counter to generate adc trigger at scan_begin_arg
+		 * interval
+		 */
 		k = &encpriv[5];
 		tick = s626_ns_to_timer((int *)&cmd->scan_begin_arg,
 					cmd->flags & TRIG_ROUND_MASK);
@@ -1383,7 +1440,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		k->SetEnable(dev, k, CLKENAB_ALWAYS);
 		break;
 	case TRIG_EXT:
-		/*  set the digital line and interrupt for scan trigger */
+		/* set the digital line and interrupt for scan trigger */
 		if (cmd->start_src != TRIG_EXT)
 			s626_dio_set_irq(dev, cmd->scan_begin_arg);
 		break;
@@ -1393,7 +1450,10 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	case TRIG_NOW:
 		break;
 	case TRIG_TIMER:
-		/*  set a conter to generate adc trigger at convert_arg interval */
+		/*
+		 * set a counter to generate adc trigger at convert_arg
+		 * interval
+		 */
 		k = &encpriv[4];
 		tick = s626_ns_to_timer((int *)&cmd->convert_arg,
 					cmd->flags & TRIG_ROUND_MASK);
@@ -1403,21 +1463,21 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		k->SetEnable(dev, k, CLKENAB_INDEX);
 		break;
 	case TRIG_EXT:
-		/*  set the digital line and interrupt for convert trigger */
-		if (cmd->scan_begin_src != TRIG_EXT
-		    && cmd->start_src == TRIG_EXT)
+		/* set the digital line and interrupt for convert trigger */
+		if (cmd->scan_begin_src != TRIG_EXT &&
+		    cmd->start_src == TRIG_EXT)
 			s626_dio_set_irq(dev, cmd->convert_arg);
 		break;
 	}
 
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		/*  data arrives as one packet */
+		/* data arrives as one packet */
 		devpriv->ai_sample_count = cmd->stop_arg;
 		devpriv->ai_continous = 0;
 		break;
 	case TRIG_NONE:
-		/*  continous acquisition */
+		/* continuous acquisition */
 		devpriv->ai_continous = 1;
 		devpriv->ai_sample_count = 1;
 		break;
@@ -1432,13 +1492,11 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		/* Start executing the RPS program */
 		s626_mc_enable(dev, MC1_ERPS1, P_MC1);
-
 		s->async->inttrig = NULL;
 		break;
 	case TRIG_EXT:
 		/* configure DIO channel for acquisition trigger */
 		s626_dio_set_irq(dev, cmd->start_arg);
-
 		s->async->inttrig = NULL;
 		break;
 	case TRIG_INT:
@@ -1461,11 +1519,11 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src,
-					TRIG_NOW | TRIG_INT | TRIG_EXT);
+				     TRIG_NOW | TRIG_INT | TRIG_EXT);
 	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
-					TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW);
+				     TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW);
 	err |= cfc_check_trigger_src(&cmd->convert_src,
-					TRIG_TIMER | TRIG_EXT | TRIG_NOW);
+				     TRIG_TIMER | TRIG_EXT | TRIG_NOW);
 	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
@@ -1490,10 +1548,8 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 	if (cmd->start_src == TRIG_EXT)
 		err |= cfc_check_trigger_arg_max(&cmd->start_arg, 39);
-
 	if (cmd->scan_begin_src == TRIG_EXT)
 		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 39);
-
 	if (cmd->convert_src == TRIG_EXT)
 		err |= cfc_check_trigger_arg_max(&cmd->convert_arg, 39);
 
@@ -1509,7 +1565,7 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 		/* external trigger */
 		/* should be level/edge, hi/lo specification here */
 		/* should specify multiple external triggers */
-/*		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 9); */
+		/* err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 9); */
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		err |= cfc_check_trigger_arg_min(&cmd->convert_arg, MAX_SPEED);
@@ -1517,7 +1573,7 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 	} else {
 		/* external trigger */
 		/* see above */
-/*		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 9); */
+		/* err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 9); */
 	}
 
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
@@ -1546,10 +1602,10 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 		if (tmp != cmd->convert_arg)
 			err++;
 		if (cmd->scan_begin_src == TRIG_TIMER &&
-		    cmd->scan_begin_arg <
-		    cmd->convert_arg * cmd->scan_end_arg) {
-			cmd->scan_begin_arg =
-			    cmd->convert_arg * cmd->scan_end_arg;
+		    cmd->scan_begin_arg < cmd->convert_arg *
+					  cmd->scan_end_arg) {
+			cmd->scan_begin_arg = cmd->convert_arg *
+					      cmd->scan_end_arg;
 			err++;
 		}
 	}
@@ -1606,7 +1662,9 @@ static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return i;
 }
 
-/* *************** DIGITAL I/O FUNCTIONS ***************
+/* *************** DIGITAL I/O FUNCTIONS *************** */
+
+/*
  * All DIO functions address a group of DIO channels by means of
  * "group" argument.  group may be 0, 1 or 2, which correspond to DIO
  * ports A, B and C, respectively.
@@ -1616,10 +1674,10 @@ static void s626_dio_init(struct comedi_device *dev)
 {
 	uint16_t group;
 
-	/*  Prepare to treat writes to WRCapSel as capture disables. */
+	/* Prepare to treat writes to WRCapSel as capture disables. */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
-	/*  For each group of sixteen channels ... */
+	/* For each group of sixteen channels ... */
 	for (group = 0; group < S626_DIO_BANKS; group++) {
 		/* Disable all interrupts */
 		DEBIwrite(dev, LP_WRINTSEL(group), 0);
@@ -1664,37 +1722,39 @@ static int s626_dio_insn_config(struct comedi_device *dev,
 	return insn->n;
 }
 
-/* Now this function initializes the value of the counter (data[0])
-   and set the subdevice. To complete with trigger and interrupt
-   configuration */
-/* FIXME: data[0] is supposed to be an INSN_CONFIG_xxx constant indicating
+/*
+ * Now this function initializes the value of the counter (data[0])
+ * and set the subdevice. To complete with trigger and interrupt
+ * configuration.
+ *
+ * FIXME: data[0] is supposed to be an INSN_CONFIG_xxx constant indicating
  * what is being configured, but this function appears to be using data[0]
- * as a variable. */
+ * as a variable.
+ */
 static int s626_enc_insn_config(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
-	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
-	    /*  index. */
-	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
-	    (CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is Counter. */
-	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
-	    /* ( CNTDIR_UP << BF_CLKPOL ) |      // Count direction is Down. */
-	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
-	    (CLKENAB_INDEX << BF_CLKENAB);
-	/*   uint16_t DisableIntSrc=TRUE; */
-	/*  uint32_t Preloadvalue;              //Counter initial value */
+	uint16_t Setup =
+		(LOADSRC_INDX << BF_LOADSRC) |	/* Preload upon index. */
+		(INDXSRC_SOFT << BF_INDXSRC) |	/* Disable hardware index. */
+		(CLKSRC_COUNTER << BF_CLKSRC) |	/* Operating mode is Counter. */
+		(CLKPOL_POS << BF_CLKPOL) |	/* Active high clock. */
+		(CLKMULT_1X << BF_CLKMULT) |	/* Clock multiplier is 1x. */
+		(CLKENAB_INDEX << BF_CLKENAB);
+	/* uint16_t DisableIntSrc = TRUE; */
+	/* uint32_t Preloadvalue;              //Counter initial value */
 	uint16_t valueSrclatch = LATCHSRC_AB_READ;
 	uint16_t enab = CLKENAB_ALWAYS;
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
-	/*   (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
+	/* (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
 	k->SetMode(dev, k, Setup, TRUE);
 	Preload(dev, k, data[0]);
 	k->PulseIndex(dev, k);
 	SetLatchSource(dev, k, valueSrclatch);
-	k->SetEnable(dev, k, (uint16_t) (enab != 0));
+	k->SetEnable(dev, k, (enab != 0));
 
 	return insn->n;
 }
@@ -1703,7 +1763,6 @@ static int s626_enc_insn_read(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
-
 	int n;
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
@@ -1717,14 +1776,15 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
-
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
-	/*  Set the preload register */
+	/* Set the preload register */
 	Preload(dev, k, data[0]);
 
-	/*  Software index pulse forces the preload register to load */
-	/*  into the counter */
+	/*
+	 * Software index pulse forces the preload register to load
+	 * into the counter
+	 */
 	k->SetLoadTrig(dev, k, 0);
 	k->PulseIndex(dev, k);
 	k->SetLoadTrig(dev, k, 2);
@@ -1734,10 +1794,9 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 
 static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
 {
-	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	/*  enab writes to */
-	/*  MISC2 register. */
-	DEBIwrite(dev, LP_WRMISC2, NewImage);	/*  Write new image to MISC2. */
-	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE);	/*  Disable writes to MISC2. */
+	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE); /* Enab writes to MISC2. */
+	DEBIwrite(dev, LP_WRMISC2, NewImage);	/* Write new image to MISC2. */
+	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE); /* Disable writes to MISC2. */
 }
 
 static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
@@ -1749,8 +1808,8 @@ static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
 
 	if (pdma == NULL)
 		return;
-	/* find the matching allocation from the board struct */
 
+	/* find the matching allocation from the board struct */
 	vbptr = pdma->LogicalBase;
 	vpptr = pdma->PhysicalBase;
 	if (vbptr) {
@@ -1762,8 +1821,9 @@ static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
 
 /* ******  PRIVATE COUNTER FUNCTIONS ****** */
 
-/*  Reset a counter's index and overflow event capture flags. */
-
+/*
+ * Reset a counter's index and overflow event capture flags.
+ */
 static void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k)
 {
 	DEBIreplace(dev, k->MyCRB, ~CRBMSK_INTCTRL,
@@ -1776,82 +1836,124 @@ static void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k)
 		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
 }
 
-/*  Return counter setup in a format (COUNTER_SETUP) that is consistent */
-/*  for both A and B counters. */
-
+/*
+ * Return counter setup in a format (COUNTER_SETUP) that is consistent
+ * for both A and B counters.
+ */
 static uint16_t GetMode_A(struct comedi_device *dev, struct enc_private *k)
 {
-	register uint16_t cra;
-	register uint16_t crb;
-	register uint16_t setup;
+	uint16_t cra;
+	uint16_t crb;
+	uint16_t setup;
 
-	/*  Fetch CRA and CRB register images. */
+	/* Fetch CRA and CRB register images. */
 	cra = DEBIread(dev, k->MyCRA);
 	crb = DEBIread(dev, k->MyCRB);
 
-	/*  Populate the standardized counter setup bit fields.  Note: */
-	/*  IndexSrc is restricted to ENC_X or IndxPol. */
-	setup = ((cra & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcA. */
-		 |((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcA. */
-		 |((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcA. */
-		 |((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) & STDMSK_INDXSRC)	/*  IndxSrc  = IndxSrcA<1>. */
-		 |((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolA. */
-		 |((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) & STDMSK_CLKENAB));	/*  ClkEnab  = ClkEnabA. */
-
-	/*  Adjust mode-dependent parameters. */
-	if (cra & (2 << CRABIT_CLKSRC_A))	/*  If Timer mode (ClkSrcA<1> == 1): */
-		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
-			  |((cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) & STDMSK_CLKPOL)	/*    Set ClkPol to indicate count direction (ClkSrcA<0>). */
-			  |(MULT_X1 << STDBIT_CLKMULT));	/*    ClkMult must be 1x in Timer mode. */
-
-	else			/*  If Counter mode (ClkSrcA<1> == 0): */
-		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Counter mode. */
-			  |((cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) & STDMSK_CLKPOL)	/*    Pass through ClkPol. */
-			  |(((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A)) ?	/*    Force ClkMult to 1x if not legal, else pass through. */
-			    (MULT_X1 << STDBIT_CLKMULT) :
-			    ((cra >> (CRABIT_CLKMULT_A -
-				      STDBIT_CLKMULT)) & STDMSK_CLKMULT)));
-
-	/*  Return adjusted counter setup. */
+	/*
+	 * Populate the standardized counter setup bit fields.
+	 * Note: IndexSrc is restricted to ENC_X or IndxPol.
+	 */
+	setup = (cra & STDMSK_LOADSRC) |	/* LoadSrc  = LoadSrcA. */
+		((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) &
+		 STDMSK_LATCHSRC) |		/* LatchSrc = LatchSrcA. */
+		((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) &
+		 STDMSK_INTSRC) |		/* IntSrc   = IntSrcA. */
+		((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) &
+		 STDMSK_INDXSRC) |		/* IndxSrc  = IndxSrcA<1>. */
+		((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) &
+		 STDMSK_INDXPOL) |		/* IndxPol  = IndxPolA. */
+		((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) &
+		 STDMSK_CLKENAB);		/* ClkEnab  = ClkEnabA. */
+
+	/* Adjust mode-dependent parameters. */
+	if (cra & (2 << CRABIT_CLKSRC_A)) {
+		/* Timer mode (ClkSrcA<1> == 1): */
+		/* Indicate Timer mode. */
+		setup |= CLKSRC_TIMER << STDBIT_CLKSRC;
+		/* Set ClkPol to indicate count direction (ClkSrcA<0>). */
+		setup |= (cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) &
+			 STDMSK_CLKPOL;
+		/* ClkMult must be 1x in Timer mode. */
+		setup |= MULT_X1 << STDBIT_CLKMULT;
+	} else {
+		/* Counter mode (ClkSrcA<1> == 0): */
+		/* Indicate Counter mode. */
+		setup |= CLKSRC_COUNTER << STDBIT_CLKSRC;
+		/* Pass through ClkPol. */
+		setup |= (cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) &
+			 STDMSK_CLKPOL;
+		/* Force ClkMult to 1x if not legal, else pass through. */
+		if ((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A))
+			setup |= MULT_X1 << STDBIT_CLKMULT;
+		else
+			setup |= (cra >> (CRABIT_CLKMULT_A - STDBIT_CLKMULT)) &
+				 STDMSK_CLKMULT;
+	}
+
+	/* Return adjusted counter setup. */
 	return setup;
 }
 
 static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k)
 {
-	register uint16_t cra;
-	register uint16_t crb;
-	register uint16_t setup;
+	uint16_t cra;
+	uint16_t crb;
+	uint16_t setup;
 
-	/*  Fetch CRA and CRB register images. */
+	/* Fetch CRA and CRB register images. */
 	cra = DEBIread(dev, k->MyCRA);
 	crb = DEBIread(dev, k->MyCRB);
 
-	/*  Populate the standardized counter setup bit fields.  Note: */
-	/*  IndexSrc is restricted to ENC_X or IndxPol. */
-	setup = (((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcB. */
-		 |((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcB. */
-		 |((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcB. */
-		 |((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolB. */
-		 |((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) & STDMSK_CLKENAB)	/*  ClkEnab  = ClkEnabB. */
-		 |((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) & STDMSK_INDXSRC));	/*  IndxSrc  = IndxSrcB<1>. */
-
-	/*  Adjust mode-dependent parameters. */
-	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B))	/*  If Extender mode (ClkMultB == MULT_X0): */
-		setup |= ((CLKSRC_EXTENDER << STDBIT_CLKSRC)	/*    Indicate Extender mode. */
-			  |(MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
-			  |((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
-
-	else if (cra & (2 << CRABIT_CLKSRC_B))	/*  If Timer mode (ClkSrcB<1> == 1): */
-		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
-			  |(MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
-			  |((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
-
-	else			/*  If Counter mode (ClkSrcB<1> == 0): */
-		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
-			  |((crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) & STDMSK_CLKMULT)	/*    Clock multiplier is passed through. */
-			  |((crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) & STDMSK_CLKPOL));	/*    Clock polarity is passed through. */
-
-	/*  Return adjusted counter setup. */
+	/*
+	 * Populate the standardized counter setup bit fields.
+	 * Note: IndexSrc is restricted to ENC_X or IndxPol.
+	 */
+	setup = ((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) &
+		 STDMSK_INTSRC) |		/* IntSrc   = IntSrcB. */
+		((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) &
+		 STDMSK_LATCHSRC) |		/* LatchSrc = LatchSrcB. */
+		((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) &
+		 STDMSK_LOADSRC) |		/* LoadSrc  = LoadSrcB. */
+		((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) &
+		 STDMSK_INDXPOL) |		/* IndxPol  = IndxPolB. */
+		((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) &
+		 STDMSK_CLKENAB) |		/* ClkEnab  = ClkEnabB. */
+		((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) &
+		 STDMSK_INDXSRC);		/* IndxSrc  = IndxSrcB<1>. */
+
+	/* Adjust mode-dependent parameters. */
+	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B)) {
+		/* Extender mode (ClkMultB == MULT_X0): */
+		/* Indicate Extender mode. */
+		setup |= CLKSRC_EXTENDER << STDBIT_CLKSRC;
+		/* Indicate multiplier is 1x. */
+		setup |= MULT_X1 << STDBIT_CLKMULT;
+		/* Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+		setup |= (cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) &
+			 STDMSK_CLKPOL;
+	} else if (cra & (2 << CRABIT_CLKSRC_B)) {
+		/* Timer mode (ClkSrcB<1> == 1): */
+		/* Indicate Timer mode. */
+		setup |= CLKSRC_TIMER << STDBIT_CLKSRC;
+		/* Indicate multiplier is 1x. */
+		setup |= MULT_X1 << STDBIT_CLKMULT;
+		/* Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+		setup |= (cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) &
+			 STDMSK_CLKPOL;
+	} else {
+		/* If Counter mode (ClkSrcB<1> == 0): */
+		/* Indicate Timer mode. */
+		setup |= CLKSRC_COUNTER << STDBIT_CLKSRC;
+		/* Clock multiplier is passed through. */
+		setup |= (crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) &
+			 STDMSK_CLKMULT;
+		/* Clock polarity is passed through. */
+		setup |= (crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) &
+			 STDMSK_CLKPOL;
+	}
+
+	/* Return adjusted counter setup. */
 	return setup;
 }
 
@@ -1861,61 +1963,81 @@ static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k)
  * parameters are programmable (all other parms are ignored): ClkMult,
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
-
 static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
 		      uint16_t Setup, uint16_t DisableIntSrc)
 {
 	struct s626_private *devpriv = dev->private;
-	register uint16_t cra;
-	register uint16_t crb;
-	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
+	uint16_t cra;
+	uint16_t crb;
+	uint16_t setup = Setup;	/*  Cache the Standard Setup. */
 
-	/*  Initialize CRA and CRB images. */
-	cra = ((setup & CRAMSK_LOADSRC_A)	/*  Preload trigger is passed through. */
-	       |((setup & STDMSK_INDXSRC) >> (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	/*  IndexSrc is restricted to ENC_X or IndxPol. */
+	/* Initialize CRA and CRB images. */
+	/* Preload trigger is passed through. */
+	cra = setup & CRAMSK_LOADSRC_A;
+	/* IndexSrc is restricted to ENC_X or IndxPol. */
+	cra |= ((setup & STDMSK_INDXSRC) >>
+		(STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1)));
 
-	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A	/*  Reset any pending CounterA event captures. */
-	       | ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	/*  Clock enable is passed through. */
+	/* Reset any pending CounterA event captures. */
+	crb = CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A;
+	/* Clock enable is passed through. */
+	crb |= (setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB);
 
-	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
+	/* Force IntSrc to Disabled if DisableIntSrc is asserted. */
 	if (!DisableIntSrc)
 		cra |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
 						    CRABIT_INTSRC_A));
 
-	/*  Populate all mode-dependent attributes of CRA & CRB images. */
+	/* Populate all mode-dependent attributes of CRA & CRB images. */
 	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
-	case CLKSRC_EXTENDER:	/*  Extender Mode: Force to Timer mode */
-		/*  (Extender valid only for B counters). */
-
-	case CLKSRC_TIMER:	/*  Timer Mode: */
-		cra |= ((2 << CRABIT_CLKSRC_A)	/*    ClkSrcA<1> selects system clock */
-			|((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	/*      with count direction (ClkSrcA<0>) obtained from ClkPol. */
-			|(1 << CRABIT_CLKPOL_A)	/*    ClkPolA behaves as always-on clock enable. */
-			|(MULT_X1 << CRABIT_CLKMULT_A));	/*    ClkMult must be 1x. */
+	case CLKSRC_EXTENDER:	/* Extender Mode: Force to Timer mode
+				 * (Extender valid only for B counters). */
+		/* Fall through to case CLKSRC_TIMER: */
+	case CLKSRC_TIMER:	/* Timer Mode: */
+		/* ClkSrcA<1> selects system clock */
+		cra |= 2 << CRABIT_CLKSRC_A;
+		/* Count direction (ClkSrcA<0>) obtained from ClkPol. */
+		cra |= (setup & STDMSK_CLKPOL) >>
+		       (STDBIT_CLKPOL - CRABIT_CLKSRC_A);
+		/* ClkPolA behaves as always-on clock enable. */
+		cra |= 1 << CRABIT_CLKPOL_A;
+		/* ClkMult must be 1x. */
+		cra |= MULT_X1 << CRABIT_CLKMULT_A;
+		break;
+	default:		/* Counter Mode: */
+		/* Select ENC_C and ENC_D as clock/direction inputs. */
+		cra |= CLKSRC_COUNTER;
+		/* Clock polarity is passed through. */
+		cra |= (setup & STDMSK_CLKPOL) <<
+		       (CRABIT_CLKPOL_A - STDBIT_CLKPOL);
+		/* Force multiplier to x1 if not legal, else pass through. */
+		if ((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT))
+			cra |= MULT_X1 << CRABIT_CLKMULT_A;
+		else
+			cra |= (setup & STDMSK_CLKMULT) <<
+			       (CRABIT_CLKMULT_A - STDBIT_CLKMULT);
 		break;
-
-	default:		/*  Counter Mode: */
-		cra |= (CLKSRC_COUNTER	/*    Select ENC_C and ENC_D as clock/direction inputs. */
-			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKPOL_A - STDBIT_CLKPOL))	/*    Clock polarity is passed through. */
-			|(((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force multiplier to x1 if not legal, otherwise pass through. */
-			  (MULT_X1 << CRABIT_CLKMULT_A) :
-			  ((setup & STDMSK_CLKMULT) << (CRABIT_CLKMULT_A -
-							STDBIT_CLKMULT))));
 	}
 
-	/*  Force positive index polarity if IndxSrc is software-driven only, */
-	/*  otherwise pass it through. */
+	/*
+	 * Force positive index polarity if IndxSrc is software-driven only,
+	 * otherwise pass it through.
+	 */
 	if (~setup & STDMSK_INDXSRC)
-		cra |= ((setup & STDMSK_INDXPOL) << (CRABIT_INDXPOL_A -
-						     STDBIT_INDXPOL));
+		cra |= (setup & STDMSK_INDXPOL) <<
+		       (CRABIT_INDXPOL_A - STDBIT_INDXPOL);
 
-	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
-	/*  enable mask to indicate the counter interrupt is disabled. */
+	/*
+	 * If IntSrc has been forced to Disabled, update the MISC2 interrupt
+	 * enable mask to indicate the counter interrupt is disabled.
+	 */
 	if (DisableIntSrc)
 		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
 
-	/*  While retaining CounterB and LatchSrc configurations, program the */
-	/*  new counter operating mode. */
+	/*
+	 * While retaining CounterB and LatchSrc configurations, program the
+	 * new counter operating mode.
+	 */
 	DEBIreplace(dev, k->MyCRA, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
 	DEBIreplace(dev, k->MyCRB, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A), crb);
 }
@@ -1924,66 +2046,92 @@ static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
 		      uint16_t Setup, uint16_t DisableIntSrc)
 {
 	struct s626_private *devpriv = dev->private;
-	register uint16_t cra;
-	register uint16_t crb;
-	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
+	uint16_t cra;
+	uint16_t crb;
+	uint16_t setup = Setup;	/* Cache the Standard Setup. */
 
-	/*  Initialize CRA and CRB images. */
-	cra = ((setup & STDMSK_INDXSRC) << ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC));	/*  IndexSrc field is restricted to ENC_X or IndxPol. */
+	/* Initialize CRA and CRB images. */
+	/* IndexSrc field is restricted to ENC_X or IndxPol. */
+	cra = (setup & STDMSK_INDXSRC) <<
+	      (CRABIT_INDXSRC_B + 1 - STDBIT_INDXSRC);
 
-	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B	/*  Reset event captures and disable interrupts. */
-	       | ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	/*  Clock enable is passed through. */
-	       |((setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	/*  Preload trigger source is passed through. */
+	/* Reset event captures and disable interrupts. */
+	crb = CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B;
+	/* Clock enable is passed through. */
+	crb |= (setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB);
+	/* Preload trigger source is passed through. */
+	crb |= (setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B);
 
-	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
+	/* Force IntSrc to Disabled if DisableIntSrc is asserted. */
 	if (!DisableIntSrc)
-		crb |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
-						    CRBBIT_INTSRC_B));
+		crb |= (setup & STDMSK_INTSRC) >>
+		       (STDBIT_INTSRC - CRBBIT_INTSRC_B);
 
-	/*  Populate all mode-dependent attributes of CRA & CRB images. */
+	/* Populate all mode-dependent attributes of CRA & CRB images. */
 	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
-	case CLKSRC_TIMER:	/*  Timer Mode: */
-		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB<1> selects system clock */
-			|((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction (ClkSrcB<0>) obtained from ClkPol. */
-		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB behaves as always-on clock enable. */
-			|(MULT_X1 << CRBBIT_CLKMULT_B));	/*    ClkMultB must be 1x. */
+	case CLKSRC_TIMER:	/* Timer Mode: */
+		/* ClkSrcB<1> selects system clock */
+		cra |= 2 << CRABIT_CLKSRC_B;
+		/* with direction (ClkSrcB<0>) obtained from ClkPol. */
+		cra |= (setup & STDMSK_CLKPOL) <<
+		       (CRABIT_CLKSRC_B - STDBIT_CLKPOL);
+		/* ClkPolB behaves as always-on clock enable. */
+		crb |= 1 << CRBBIT_CLKPOL_B;
+		/* ClkMultB must be 1x. */
+		crb |= MULT_X1 << CRBBIT_CLKMULT_B;
 		break;
-
-	case CLKSRC_EXTENDER:	/*  Extender Mode: */
-		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB source is OverflowA (same as "timer") */
-			|((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction obtained from ClkPol. */
-		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB controls IndexB -- always set to active. */
-			|(MULT_X0 << CRBBIT_CLKMULT_B));	/*    ClkMultB selects OverflowA as the clock source. */
+	case CLKSRC_EXTENDER:	/* Extender Mode: */
+		/* ClkSrcB source is OverflowA (same as "timer") */
+		cra |= 2 << CRABIT_CLKSRC_B;
+		/* with direction obtained from ClkPol. */
+		cra |= (setup & STDMSK_CLKPOL) <<
+		       (CRABIT_CLKSRC_B - STDBIT_CLKPOL);
+		/* ClkPolB controls IndexB -- always set to active. */
+		crb |= 1 << CRBBIT_CLKPOL_B;
+		/* ClkMultB selects OverflowA as the clock source. */
+		crb |= MULT_X0 << CRBBIT_CLKMULT_B;
+		break;
+	default:		/* Counter Mode: */
+		/* Select ENC_C and ENC_D as clock/direction inputs. */
+		cra |= CLKSRC_COUNTER << CRABIT_CLKSRC_B;
+		/* ClkPol is passed through. */
+		crb |= (setup & STDMSK_CLKPOL) >>
+		       (STDBIT_CLKPOL - CRBBIT_CLKPOL_B);
+		/* Force ClkMult to x1 if not legal, otherwise pass through. */
+		if ((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT))
+			crb |= MULT_X1 << CRBBIT_CLKMULT_B;
+		else
+			crb |= (setup & STDMSK_CLKMULT) <<
+			       (CRBBIT_CLKMULT_B - STDBIT_CLKMULT);
 		break;
-
-	default:		/*  Counter Mode: */
-		cra |= (CLKSRC_COUNTER << CRABIT_CLKSRC_B);	/*    Select ENC_C and ENC_D as clock/direction inputs. */
-		crb |= (((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRBBIT_CLKPOL_B))	/*    ClkPol is passed through. */
-			|(((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force ClkMult to x1 if not legal, otherwise pass through. */
-			  (MULT_X1 << CRBBIT_CLKMULT_B) :
-			  ((setup & STDMSK_CLKMULT) << (CRBBIT_CLKMULT_B -
-							STDBIT_CLKMULT))));
 	}
 
-	/*  Force positive index polarity if IndxSrc is software-driven only, */
-	/*  otherwise pass it through. */
+	/*
+	 * Force positive index polarity if IndxSrc is software-driven only,
+	 * otherwise pass it through.
+	 */
 	if (~setup & STDMSK_INDXSRC)
-		crb |= ((setup & STDMSK_INDXPOL) >> (STDBIT_INDXPOL -
-						     CRBBIT_INDXPOL_B));
+		crb |= (setup & STDMSK_INDXPOL) >>
+		       (STDBIT_INDXPOL - CRBBIT_INDXPOL_B);
 
-	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
-	/*  enable mask to indicate the counter interrupt is disabled. */
+	/*
+	 * If IntSrc has been forced to Disabled, update the MISC2 interrupt
+	 * enable mask to indicate the counter interrupt is disabled.
+	 */
 	if (DisableIntSrc)
 		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
 
-	/*  While retaining CounterA and LatchSrc configurations, program the */
-	/*  new counter operating mode. */
+	/*
+	 * While retaining CounterA and LatchSrc configurations, program the
+	 * new counter operating mode.
+	 */
 	DEBIreplace(dev, k->MyCRA, ~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B), cra);
 	DEBIreplace(dev, k->MyCRB, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
 }
 
-/*  Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index. */
-
+/*
+ * Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
+ */
 static void SetEnable_A(struct comedi_device *dev, struct enc_private *k,
 			uint16_t enab)
 {
@@ -2008,19 +2156,19 @@ static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k)
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_B) & 1;
 }
 
-/*
- * static uint16_t GetLatchSource(struct comedi_device *dev, struct enc_private *k )
- * {
- *	return ( DEBIread( dev, k->MyCRB) >> CRBBIT_LATCHSRC ) & 3;
- * }
- */
+#ifdef unused
+static uint16_t GetLatchSource(struct comedi_device *dev,
+			       struct enc_private *k)
+{
+	return (DEBIread(dev, k->MyCRB) >> CRBBIT_LATCHSRC) & 3;
+}
+#endif
 
 /*
  * Return/set the event that will trigger transfer of the preload
  * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
  * 2=OverflowA (B counters only), 3=disabled.
  */
-
 static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k,
 			  uint16_t Trig)
 {
@@ -2045,25 +2193,25 @@ static uint16_t GetLoadTrig_B(struct comedi_device *dev, struct enc_private *k)
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_LOADSRC_B) & 3;
 }
 
-/* Return/set counter interrupt source and clear any captured
+/*
+ * Return/set counter interrupt source and clear any captured
  * index/overflow events.  IntSource: 0=Disabled, 1=OverflowOnly,
  * 2=IndexOnly, 3=IndexAndOverflow.
  */
-
 static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
 			uint16_t IntSource)
 {
 	struct s626_private *devpriv = dev->private;
 
-	/*  Reset any pending counter overflow or index captures. */
+	/* Reset any pending counter overflow or index captures. */
 	DEBIreplace(dev, k->MyCRB, ~CRBMSK_INTCTRL,
 		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 
-	/*  Program counter interrupt source. */
+	/* Program counter interrupt source. */
 	DEBIreplace(dev, k->MyCRA, ~CRAMSK_INTSRC_A,
 		    IntSource << CRABIT_INTSRC_A);
 
-	/*  Update MISC2 interrupt enable mask. */
+	/* Update MISC2 interrupt enable mask. */
 	devpriv->CounterIntEnabs =
 	    (devpriv->CounterIntEnabs & ~k->
 	     MyEventBits[3]) | k->MyEventBits[IntSource];
@@ -2075,22 +2223,22 @@ static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
 	struct s626_private *devpriv = dev->private;
 	uint16_t crb;
 
-	/*  Cache writeable CRB register image. */
+	/* Cache writeable CRB register image. */
 	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;
 
-	/*  Reset any pending counter overflow or index captures. */
+	/* Reset any pending counter overflow or index captures. */
 	DEBIwrite(dev, k->MyCRB,
-		  (uint16_t) (crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
+		  (uint16_t)(crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
 
-	/*  Program counter interrupt source. */
+	/* Program counter interrupt source. */
 	DEBIwrite(dev, k->MyCRB,
-		  (uint16_t) ((crb & ~CRBMSK_INTSRC_B) | (IntSource <<
-							  CRBBIT_INTSRC_B)));
+		  (uint16_t)((crb & ~CRBMSK_INTSRC_B) |
+			     (IntSource << CRBBIT_INTSRC_B)));
 
-	/*  Update MISC2 interrupt enable mask. */
+	/* Update MISC2 interrupt enable mask. */
 	devpriv->CounterIntEnabs =
-	    (devpriv->CounterIntEnabs & ~k->
-	     MyEventBits[3]) | k->MyEventBits[IntSource];
+		(devpriv->CounterIntEnabs & ~k->MyEventBits[3]) |
+		k->MyEventBits[IntSource];
 }
 
 static uint16_t GetIntSrc_A(struct comedi_device *dev, struct enc_private *k)
@@ -2103,83 +2251,103 @@ static uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k)
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_INTSRC_B) & 3;
 }
 
-/*  Return/set the clock multiplier. */
-
-/* static void SetClkMult(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */
-/* { */
-/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKMULT ) | ( value << STDBIT_CLKMULT ) ), FALSE ); */
-/* } */
-
-/* static uint16_t GetClkMult(struct comedi_device *dev, struct enc_private *k )  */
-/* { */
-/*   return ( k->GetMode(dev, k ) >> STDBIT_CLKMULT ) & 3; */
-/* } */
-
-/* Return/set the clock polarity. */
-
-/* static void SetClkPol( struct comedi_device *dev,struct enc_private *k, uint16_t value )  */
-/* { */
-/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKPOL ) | ( value << STDBIT_CLKPOL ) ), FALSE ); */
-/* } */
-
-/* static uint16_t GetClkPol(struct comedi_device *dev, struct enc_private *k )  */
-/* { */
-/*   return ( k->GetMode(dev, k ) >> STDBIT_CLKPOL ) & 1; */
-/* } */
-
-/* Return/set the clock source.  */
+#ifdef unused
+/*
+ * Return/set the clock multiplier.
+ */
+static void SetClkMult(struct comedi_device *dev, struct enc_private *k,
+		       uint16_t value)
+{
+	k->SetMode(dev, k, ((k->GetMode(dev, k) & ~STDMSK_CLKMULT) |
+			    (value << STDBIT_CLKMULT)), FALSE);
+}
 
-/* static void SetClkSrc( struct comedi_device *dev,struct enc_private *k, uint16_t value )  */
-/* { */
-/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKSRC ) | ( value << STDBIT_CLKSRC ) ), FALSE ); */
-/* } */
+static uint16_t GetClkMult(struct comedi_device *dev, struct enc_private *k)
+{
+	return (k->GetMode(dev, k) >> STDBIT_CLKMULT) & 3;
+}
 
-/* static uint16_t GetClkSrc( struct comedi_device *dev,struct enc_private *k )  */
-/* { */
-/*   return ( k->GetMode(dev, k ) >> STDBIT_CLKSRC ) & 3; */
-/* } */
+/*
+ * Return/set the clock polarity.
+ */
+static void SetClkPol(struct comedi_device *dev, struct enc_private *k,
+		      uint16_t value)
+{
+	k->SetMode(dev, k, ((k->GetMode(dev, k) & ~STDMSK_CLKPOL) |
+			    (value << STDBIT_CLKPOL)), FALSE);
+}
 
-/* Return/set the index polarity. */
+static uint16_t GetClkPol(struct comedi_device *dev, struct enc_private *k)
+{
+	return (k->GetMode(dev, k) >> STDBIT_CLKPOL) & 1;
+}
 
-/* static void SetIndexPol(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */
-/* { */
-/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_INDXPOL ) | ( (value != 0) << STDBIT_INDXPOL ) ), FALSE ); */
-/* } */
+/*
+ * Return/set the clock source.
+ */
+static void SetClkSrc(struct comedi_device *dev, struct enc_private *k,
+		      uint16_t value)
+{
+	k->SetMode(dev, k, ((k->GetMode(dev, k) & ~STDMSK_CLKSRC) |
+			    (value << STDBIT_CLKSRC)), FALSE);
+}
 
-/* static uint16_t GetIndexPol(struct comedi_device *dev, struct enc_private *k )  */
-/* { */
-/*   return ( k->GetMode(dev, k ) >> STDBIT_INDXPOL ) & 1; */
-/* } */
+static uint16_t GetClkSrc(struct comedi_device *dev, struct enc_private *k)
+{
+	return (k->GetMode(dev, k) >> STDBIT_CLKSRC) & 3;
+}
 
-/*  Return/set the index source. */
+/*
+ * Return/set the index polarity.
+ */
+static void SetIndexPol(struct comedi_device *dev, struct enc_private *k,
+			uint16_t value)
+{
+	k->SetMode(dev, k, ((k->GetMode(dev, k) & ~STDMSK_INDXPOL) |
+			    ((value != 0) << STDBIT_INDXPOL)), FALSE);
+}
 
-/* static void SetIndexSrc(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */
-/* { */
-/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_INDXSRC ) | ( (value != 0) << STDBIT_INDXSRC ) ), FALSE ); */
-/* } */
+static uint16_t GetIndexPol(struct comedi_device *dev, struct enc_private *k)
+{
+	return (k->GetMode(dev, k) >> STDBIT_INDXPOL) & 1;
+}
 
-/* static uint16_t GetIndexSrc(struct comedi_device *dev, struct enc_private *k )  */
-/* { */
-/*   return ( k->GetMode(dev, k ) >> STDBIT_INDXSRC ) & 1; */
-/* } */
+/*
+ * Return/set the index source.
+ */
+static void SetIndexSrc(struct comedi_device *dev, struct enc_private *k,
+			uint16_t value)
+{
+	k->SetMode(dev, k, ((k->GetMode(dev, k) & ~STDMSK_INDXSRC) |
+			    ((value != 0) << STDBIT_INDXSRC)), FALSE);
+}
 
-/*  Generate an index pulse. */
+static uint16_t GetIndexSrc(struct comedi_device *dev, struct enc_private *k)
+{
+	return (k->GetMode(dev, k) >> STDBIT_INDXSRC) & 1;
+}
+#endif
 
+/*
+ * Generate an index pulse.
+ */
 static void PulseIndex_A(struct comedi_device *dev, struct enc_private *k)
 {
-	register uint16_t cra;
+	uint16_t cra;
 
-	cra = DEBIread(dev, k->MyCRA);	/*  Pulse index. */
-	DEBIwrite(dev, k->MyCRA, (uint16_t) (cra ^ CRAMSK_INDXPOL_A));
+	cra = DEBIread(dev, k->MyCRA);
+	/* Pulse index. */
+	DEBIwrite(dev, k->MyCRA, (cra ^ CRAMSK_INDXPOL_A));
 	DEBIwrite(dev, k->MyCRA, cra);
 }
 
 static void PulseIndex_B(struct comedi_device *dev, struct enc_private *k)
 {
-	register uint16_t crb;
+	uint16_t crb;
 
-	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;	/*  Pulse index. */
-	DEBIwrite(dev, k->MyCRB, (uint16_t) (crb ^ CRBMSK_INDXPOL_B));
+	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;
+	/* Pulse index. */
+	DEBIwrite(dev, k->MyCRB, (crb ^ CRBMSK_INDXPOL_B));
 	DEBIwrite(dev, k->MyCRB, crb);
 }
 
@@ -2281,16 +2449,18 @@ static void CountersInit(struct comedi_device *dev)
 {
 	int chan;
 	struct enc_private *k;
-	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
-	    /*  index. */
-	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
-	    (CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is counter. */
-	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
-	    (CNTDIR_UP << BF_CLKPOL) |	/*  Count direction is up. */
-	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
-	    (CLKENAB_INDEX << BF_CLKENAB);	/*  Enabled by index */
-
-	/*  Disable all counter interrupts and clear any captured counter events. */
+	uint16_t Setup =
+		(LOADSRC_INDX << BF_LOADSRC) |	/* Preload upon index. */
+		(INDXSRC_SOFT << BF_INDXSRC) |	/* Disable hardware index. */
+		(CLKSRC_COUNTER << BF_CLKSRC) |	/* Operating mode is counter. */
+		(CLKPOL_POS << BF_CLKPOL) |	/* Active high clock. */
+		(CNTDIR_UP << BF_CLKPOL) |	/* Count direction is up. */
+		(CLKMULT_1X << BF_CLKMULT) |	/* Clock multiplier is 1x. */
+		(CLKENAB_INDEX << BF_CLKENAB);	/* Enabled by index */
+
+	/*
+	 * Disable all counter interrupts and clear any captured counter events.
+	 */
 	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
 		k = &encpriv[chan];
 		k->SetMode(dev, k, Setup, TRUE);
@@ -2333,17 +2503,15 @@ static void s626_initialize(struct comedi_device *dev)
 	s626_mc_enable(dev, MC1_DEBI | MC1_AUDIO | MC1_I2C, P_MC1);
 
 	/*
-	 *  Configure DEBI operating mode
+	 * Configure DEBI operating mode
 	 *
-	 *   Local bus is 16 bits wide
-	 *   Declare DEBI transfer timeout interval
-	 *   Set up byte lane steering
-	 *   Intel-compatible local bus (DEBI never times out)
+	 *  Local bus is 16 bits wide
+	 *  Declare DEBI transfer timeout interval
+	 *  Set up byte lane steering
+	 *  Intel-compatible local bus (DEBI never times out)
 	 */
-	writel(DEBI_CFG_SLAVE16 |
-	       (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
-	       DEBI_SWAP | DEBI_CFG_INTEL,
-	       devpriv->mmio + P_DEBICFG);
+	writel(DEBI_CFG_SLAVE16 | (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
+	       DEBI_SWAP | DEBI_CFG_INTEL, devpriv->mmio + P_DEBICFG);
 
 	/* Disable MMU paging */
 	writel(DEBI_PAGE_DISABLE, devpriv->mmio + P_DEBIPAGE);
@@ -2416,38 +2584,37 @@ static void s626_initialize(struct comedi_device *dev)
 	 * because the SAA7146 ADC interface does not start up in
 	 * a defined state after a PCI reset.
 	 */
-
 	{
-	uint8_t PollList;
-	uint16_t AdcData;
-	uint16_t StartVal;
-	uint16_t index;
-	unsigned int data[16];
+		uint8_t PollList;
+		uint16_t AdcData;
+		uint16_t StartVal;
+		uint16_t index;
+		unsigned int data[16];
 
-	/* Create a simple polling list for analog input channel 0 */
-	PollList = EOPL;
-	ResetADC(dev, &PollList);
+		/* Create a simple polling list for analog input channel 0 */
+		PollList = EOPL;
+		ResetADC(dev, &PollList);
 
-	/* Get initial ADC value */
-	s626_ai_rinsn(dev, dev->subdevices, NULL, data);
-	StartVal = data[0];
-
-	/*
-	 * VERSION 2.01 CHANGE: TIMEOUT ADDED TO PREVENT HANGED EXECUTION.
-	 *
-	 * Invoke ADCs until the new ADC value differs from the initial
-	 * value or a timeout occurs.  The timeout protects against the
-	 * possibility that the driver is restarting and the ADC data is a
-	 * fixed value resulting from the applied ADC analog input being
-	 * unusually quiet or at the rail.
-	 */
-	for (index = 0; index < 500; index++) {
+		/* Get initial ADC value */
 		s626_ai_rinsn(dev, dev->subdevices, NULL, data);
-		AdcData = data[0];
-		if (AdcData != StartVal)
-			break;
-	}
+		StartVal = data[0];
 
+		/*
+		 * VERSION 2.01 CHANGE: TIMEOUT ADDED TO PREVENT HANGED
+		 * EXECUTION.
+		 *
+		 * Invoke ADCs until the new ADC value differs from the initial
+		 * value or a timeout occurs.  The timeout protects against the
+		 * possibility that the driver is restarting and the ADC data is
+		 * a fixed value resulting from the applied ADC analog input
+		 * being unusually quiet or at the rail.
+		 */
+		for (index = 0; index < 500; index++) {
+			s626_ai_rinsn(dev, dev->subdevices, NULL, data);
+			AdcData = data[0];
+			if (AdcData != StartVal)
+				break;
+		}
 	}
 #endif	/* SAA7146 BUG WORKAROUND */
 
@@ -2661,7 +2828,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->io_bits	= 0xffff;
 	s->private	= (void *)2;	/* DIO group 2 */
 	s->range_table	= &range_digital;
-	s->insn_config 	= s626_dio_insn_config;
+	s->insn_config	= s626_dio_insn_config;
 	s->insn_bits	= s626_dio_insn_bits;
 
 	s = &dev->subdevices[5];
@@ -2699,7 +2866,7 @@ static void s626_detach(struct comedi_device *dev)
 			writel(IRQ_GPIO3 | IRQ_RPS1,
 			       devpriv->mmio + P_ISR);
 
-			/*  Disable the watchdog timer and battery charger. */
+			/* Disable the watchdog timer and battery charger. */
 			WriteMISC2(dev, 0);
 
 			/* Close all interfaces on 7146 device */
@@ -2738,7 +2905,7 @@ static int s626_pci_probe(struct pci_dev *dev,
  */
 static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
 	{ PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626,
-		PCI_SUBVENDOR_ID_S626, PCI_SUBDEVICE_ID_S626, 0, 0, 0 },
+	  PCI_SUBVENDOR_ID_S626, PCI_SUBDEVICE_ID_S626, 0, 0, 0, },
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, s626_pci_table);

commit 7f32c7c4444222f786bd052d02f5fb545820b8df
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:16 2013 +0100

    staging: comedi: s626: tidy up comments at top of file
    
    Make the comments at the top of the file conform to the CodingStyle.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4eb4e7160bc3..4ac30ad7f1be 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1,63 +1,63 @@
 /*
-  comedi/drivers/s626.c
-  Sensoray s626 Comedi driver
-
-  COMEDI - Linux Control and Measurement Device Interface
-  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
-
-  Based on Sensoray Model 626 Linux driver Version 0.2
-  Copyright (C) 2002-2004 Sensoray Co., Inc.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-*/
+ * comedi/drivers/s626.c
+ * Sensoray s626 Comedi driver
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+ *
+ * Based on Sensoray Model 626 Linux driver Version 0.2
+ * Copyright (C) 2002-2004 Sensoray Co., Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
 /*
-Driver: s626
-Description: Sensoray 626 driver
-Devices: [Sensoray] 626 (s626)
-Authors: Gianluca Palli <gpalli@deis.unibo.it>,
-Updated: Fri, 15 Feb 2008 10:28:42 +0000
-Status: experimental
-
-Configuration options: not applicable, uses PCI auto config
-
-INSN_CONFIG instructions:
-  analog input:
-   none
-
-  analog output:
-   none
-
-  digital channel:
-   s626 has 3 dio subdevices (2,3 and 4) each with 16 i/o channels
-   supported configuration options:
-   INSN_CONFIG_DIO_QUERY
-   COMEDI_INPUT
-   COMEDI_OUTPUT
-
-  encoder:
-   Every channel must be configured before reading.
-
-   Example code
-
-   insn.insn=INSN_CONFIG;   //configuration instruction
-   insn.n=1;                //number of operation (must be 1)
-   insn.data=&initialvalue; //initial value loaded into encoder
-				//during configuration
-   insn.subdev=5;           //encoder subdevice
-   insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); //encoder_channel
-							//to configure
-
-   comedi_do_insn(cf,&insn); //executing configuration
-*/
+ * Driver: s626
+ * Description: Sensoray 626 driver
+ * Devices: [Sensoray] 626 (s626)
+ * Authors: Gianluca Palli <gpalli@deis.unibo.it>,
+ * Updated: Fri, 15 Feb 2008 10:28:42 +0000
+ * Status: experimental
+
+ * Configuration options: not applicable, uses PCI auto config
+
+ * INSN_CONFIG instructions:
+ *   analog input:
+ *    none
+ *
+ *   analog output:
+ *    none
+ *
+ *   digital channel:
+ *    s626 has 3 dio subdevices (2,3 and 4) each with 16 i/o channels
+ *    supported configuration options:
+ *    INSN_CONFIG_DIO_QUERY
+ *    COMEDI_INPUT
+ *    COMEDI_OUTPUT
+ *
+ *   encoder:
+ *    Every channel must be configured before reading.
+ *
+ *   Example code
+ *
+ *    insn.insn=INSN_CONFIG;   //configuration instruction
+ *    insn.n=1;                //number of operation (must be 1)
+ *    insn.data=&initialvalue; //initial value loaded into encoder
+ *                             //during configuration
+ *    insn.subdev=5;           //encoder subdevice
+ *    insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); //encoder_channel
+ *                                                         //to configure
+ *
+ *    comedi_do_insn(cf,&insn); //executing configuration
+ */
 
 #include <linux/module.h>
 #include <linux/delay.h>

commit 6ea79c1d8005aedfe53ad040c7bd6aa67a767031
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:10:56 2013 -0700

    staging: comedi: s626: use comedi_dio_update_state()
    
    The extra mask used to only update the channels configured as outputs is
    not necessary in this driver. Remove it and use comedi_dio_update_state()
    to handle the boilerplate code to update the subdevice s->state.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index d22b95dcb9bd..4eb4e7160bc3 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1638,19 +1638,10 @@ static int s626_dio_insn_bits(struct comedi_device *dev,
 			      unsigned int *data)
 {
 	unsigned long group = (unsigned long)s->private;
-	unsigned long mask = data[0];
-	unsigned long bits = data[1];
-
-	if (mask) {
-		/* Check if requested channels are configured for output */
-		if ((s->io_bits & mask) != mask)
-			return -EIO;
-
-		s->state &= ~mask;
-		s->state |= (bits & mask);
 
+	if (comedi_dio_update_state(s, data))
 		DEBIwrite(dev, LP_WRDOUT(group), s->state);
-	}
+
 	data[1] = DEBIread(dev, LP_RDDIN(group));
 
 	return insn->n;

commit ddf62f2c7bd041d35095b525ab33e3a3e0829aaa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 6 09:32:33 2013 -0700

    staging: comedi: drivers: use comedi_dio_insn_config() for simple cases
    
    Convert the drivers with simple, per channel programmable i/o, to use the
    comedi_dio_insn_config() helper function.
    
    All of these pass a 'mask' of '0' to comedi_dio_insn_config() this causes
    the per channel mask to be used to configure the i/o direction.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index b0ba9b9b433b..d22b95dcb9bd 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1662,24 +1662,12 @@ static int s626_dio_insn_config(struct comedi_device *dev,
 				unsigned int *data)
 {
 	unsigned long group = (unsigned long)s->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int mask = 1 << chan;
+	int ret;
+
+	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
+	if (ret)
+		return ret;
 
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
-		return insn->n;
-		break;
-	case COMEDI_INPUT:
-		s->io_bits &= ~mask;
-		break;
-	case COMEDI_OUTPUT:
-		s->io_bits |= mask;
-		break;
-	default:
-		return -EINVAL;
-		break;
-	}
 	DEBIwrite(dev, LP_WRDOUT(group), s->io_bits);
 
 	return insn->n;

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index f5ef91f39bbf..b0ba9b9b433b 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -59,6 +59,8 @@ INSN_CONFIG instructions:
    comedi_do_insn(cf,&insn); //executing configuration
 */
 
+#include <linux/module.h>
+#include <linux/delay.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/kernel.h>

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 48c4b70b736a..f5ef91f39bbf 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2585,10 +2585,9 @@ static int s626_auto_attach(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	int ret;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	ret = comedi_pci_enable(dev);
 	if (ret)

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 0cf4b3d1279a..48c4b70b736a 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -17,11 +17,6 @@
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
 */
 
 /*

commit 5970b1021dba511850976117e5948fda7be6300e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 10 11:27:50 2013 -0700

    staging: comedi: s626: use pci_ioremap_bar()
    
    Use pci_ioremap_bar() to ioremap the PCI resources. That function
    just takes the pci device and a bar number. It also has some
    additional sanity checks to make sure the bar is actually a
    memory resource.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index b6c7cb980d33..0cf4b3d1279a 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2599,8 +2599,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	devpriv->mmio = ioremap(pci_resource_start(pcidev, 0),
-				pci_resource_len(pcidev, 0));
+	devpriv->mmio = pci_ioremap_bar(pcidev, 0);
 	if (!devpriv->mmio)
 		return -ENOMEM;
 

commit 5993f3a2692eed3c74c86882155b8703a0060ad5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 8 10:57:35 2013 -0700

    staging: comedi: remove unnecessary dev->board_name initialization
    
    The dev->board_name is now initialized by the comedi core before calling
    the(*attach) or (*auto_attach) function in a driver. As long as the driver
    does no additional probing, it's no longer necessary initialize the board_name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 02f9406f8f09..b6c7cb980d33 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2590,8 +2590,6 @@ static int s626_auto_attach(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	int ret;
 
-	dev->board_name = dev->driver->driver_name;
-
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
 		return -ENOMEM;

commit b43f9b59e65e1d4ff06474885b44515817868fdd
Merge: c37b95eeefee 07961ac7c0ee
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Apr 1 11:46:45 2013 -0700

    Merge 3.9-rc5 into staging-next
    
    This pulls in all of the good fixes we need here.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 77c08dbcf4ea177548ad7d506718c85b5a2be9ae
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 15:45:30 2013 -0700

    staging: comedi: s626: remove the "interrupt call test"
    
    This commented out code in s626_ai_insn_read() is just left over
    development test code. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4cb2b2d66fb5..d84e3f436df2 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1156,12 +1156,6 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	int tmp;
 	int n;
 
-	/* interrupt call test  */
-/*   writel(IRQ_GPIO3,devpriv->mmio+P_PSR); */
-	/* Writing a logical 1 into any of the RPS_PSR bits causes the
-	 * corresponding interrupt to be generated if enabled
-	 */
-
 	/* Convert application's ADC specification into form
 	 *  appropriate for register programming.
 	 */
@@ -2586,9 +2580,6 @@ static void s626_initialize(struct comedi_device *dev)
 
 	/* Initialize the digital I/O subsystem */
 	s626_dio_init(dev);
-
-	/* enable interrupt test */
-	/* writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->mmio + P_IER); */
 }
 
 static int s626_auto_attach(struct comedi_device *dev,

commit 2281befd94082e788353fc8b094b4297d72181ba
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 15:45:04 2013 -0700

    staging: comedi: s626: async commands require an interrupt
    
    Only hook up the analog input command support if the interrupt is
    available.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 528a40b072ae..4cb2b2d66fb5 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2641,7 +2641,6 @@ static int s626_auto_attach(struct comedi_device *dev,
 
 	s = &dev->subdevices[0];
 	/* analog input subdevice */
-	dev->read_subdev = s;
 	s->type		= COMEDI_SUBD_AI;
 	s->subdev_flags	= SDF_READABLE | SDF_DIFF | SDF_CMD_READ;
 	s->n_chan	= S626_ADC_CHANNELS;
@@ -2649,9 +2648,12 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->range_table	= &s626_range_table;
 	s->len_chanlist	= S626_ADC_CHANNELS;
 	s->insn_read	= s626_ai_insn_read;
-	s->do_cmd	= s626_ai_cmd;
-	s->do_cmdtest	= s626_ai_cmdtest;
-	s->cancel	= s626_ai_cancel;
+	if (dev->irq) {
+		dev->read_subdev = s;
+		s->do_cmd	= s626_ai_cmd;
+		s->do_cmdtest	= s626_ai_cmdtest;
+		s->cancel	= s626_ai_cancel;
+	}
 
 	s = &dev->subdevices[1];
 	/* analog output subdevice */

commit d3796f7410852ed687952fd5d4fd8457c0c4063a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 15:44:43 2013 -0700

    staging: comedi: s626: remove the ai (*insn_config) function
    
    This subdevice function is not implemented in the driver. Just
    remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 085b50d6ed07..528a40b072ae 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1107,15 +1107,6 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 	/*  End of RPS program build */
 }
 
-/* TO COMPLETE, IF NECESSARY */
-static int s626_ai_insn_config(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
-{
-
-	return -EINVAL;
-}
-
 #ifdef unused_code
 static int s626_ai_rinsn(struct comedi_device *dev,
 			 struct comedi_subdevice *s,
@@ -2657,7 +2648,6 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->maxdata	= 0x3fff;
 	s->range_table	= &s626_range_table;
 	s->len_chanlist	= S626_ADC_CHANNELS;
-	s->insn_config	= s626_ai_insn_config;
 	s->insn_read	= s626_ai_insn_read;
 	s->do_cmd	= s626_ai_cmd;
 	s->do_cmdtest	= s626_ai_cmdtest;

commit ca2f109179659420fd25f53e144ba2f23371970e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 15:44:27 2013 -0700

    staging: comedi: s626: cleanup subdevice init
    
    For aesthetic reasons, add some whitespace to the subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index b6093c2b2444..085b50d6ed07 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2651,76 +2651,75 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s = &dev->subdevices[0];
 	/* analog input subdevice */
 	dev->read_subdev = s;
-	/* we support single-ended (ground) and differential */
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_CMD_READ;
-	s->n_chan = S626_ADC_CHANNELS;
-	s->maxdata = (0xffff >> 2);
-	s->range_table = &s626_range_table;
-	s->len_chanlist = S626_ADC_CHANNELS;
-	s->insn_config = s626_ai_insn_config;
-	s->insn_read = s626_ai_insn_read;
-	s->do_cmd = s626_ai_cmd;
-	s->do_cmdtest = s626_ai_cmdtest;
-	s->cancel = s626_ai_cancel;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_DIFF | SDF_CMD_READ;
+	s->n_chan	= S626_ADC_CHANNELS;
+	s->maxdata	= 0x3fff;
+	s->range_table	= &s626_range_table;
+	s->len_chanlist	= S626_ADC_CHANNELS;
+	s->insn_config	= s626_ai_insn_config;
+	s->insn_read	= s626_ai_insn_read;
+	s->do_cmd	= s626_ai_cmd;
+	s->do_cmdtest	= s626_ai_cmdtest;
+	s->cancel	= s626_ai_cancel;
 
 	s = &dev->subdevices[1];
 	/* analog output subdevice */
-	s->type = COMEDI_SUBD_AO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = S626_DAC_CHANNELS;
-	s->maxdata = (0x3fff);
-	s->range_table = &range_bipolar10;
-	s->insn_write = s626_ao_winsn;
-	s->insn_read = s626_ao_rinsn;
+	s->type		= COMEDI_SUBD_AO;
+	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE;
+	s->n_chan	= S626_DAC_CHANNELS;
+	s->maxdata	= 0x3fff;
+	s->range_table	= &range_bipolar10;
+	s->insn_write	= s626_ao_winsn;
+	s->insn_read	= s626_ao_rinsn;
 
 	s = &dev->subdevices[2];
 	/* digital I/O subdevice */
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = 16;
-	s->maxdata = 1;
-	s->io_bits = 0xffff;
-	s->private = (void *)0;		/* DIO group 0 */
-	s->range_table = &range_digital;
-	s->insn_config = s626_dio_insn_config;
-	s->insn_bits = s626_dio_insn_bits;
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE;
+	s->n_chan	= 16;
+	s->maxdata	= 1;
+	s->io_bits	= 0xffff;
+	s->private	= (void *)0;	/* DIO group 0 */
+	s->range_table	= &range_digital;
+	s->insn_config	= s626_dio_insn_config;
+	s->insn_bits	= s626_dio_insn_bits;
 
 	s = &dev->subdevices[3];
 	/* digital I/O subdevice */
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = 16;
-	s->maxdata = 1;
-	s->io_bits = 0xffff;
-	s->private = (void *)1;		/* DIO group 1 */
-	s->range_table = &range_digital;
-	s->insn_config = s626_dio_insn_config;
-	s->insn_bits = s626_dio_insn_bits;
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE;
+	s->n_chan	= 16;
+	s->maxdata	= 1;
+	s->io_bits	= 0xffff;
+	s->private	= (void *)1;	/* DIO group 1 */
+	s->range_table	= &range_digital;
+	s->insn_config	= s626_dio_insn_config;
+	s->insn_bits	= s626_dio_insn_bits;
 
 	s = &dev->subdevices[4];
 	/* digital I/O subdevice */
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = 16;
-	s->maxdata = 1;
-	s->io_bits = 0xffff;
-	s->private = (void *)2;		/* DIO group 2 */
-	s->range_table = &range_digital;
-	s->insn_config = s626_dio_insn_config;
-	s->insn_bits = s626_dio_insn_bits;
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE;
+	s->n_chan	= 16;
+	s->maxdata	= 1;
+	s->io_bits	= 0xffff;
+	s->private	= (void *)2;	/* DIO group 2 */
+	s->range_table	= &range_digital;
+	s->insn_config 	= s626_dio_insn_config;
+	s->insn_bits	= s626_dio_insn_bits;
 
 	s = &dev->subdevices[5];
 	/* encoder (counter) subdevice */
-	s->type = COMEDI_SUBD_COUNTER;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;
-	s->n_chan = S626_ENCODER_CHANNELS;
-	s->private = enc_private_data;
-	s->insn_config = s626_enc_insn_config;
-	s->insn_read = s626_enc_insn_read;
-	s->insn_write = s626_enc_insn_write;
-	s->maxdata = 0xffffff;
-	s->range_table = &range_unknown;
+	s->type		= COMEDI_SUBD_COUNTER;
+	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;
+	s->n_chan	= S626_ENCODER_CHANNELS;
+	s->maxdata	= 0xffffff;
+	s->private	= enc_private_data;
+	s->range_table	= &range_unknown;
+	s->insn_config	= s626_enc_insn_config;
+	s->insn_read	= s626_enc_insn_read;
+	s->insn_write	= s626_enc_insn_write;
 
 	s626_initialize(dev);
 

commit f0717f5dea01128abbcc158063050821802d31d9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 15:43:51 2013 -0700

    staging: comedi: s626: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer match to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index f0ea5b94b314..b6093c2b2444 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2648,7 +2648,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	/* analog input subdevice */
 	dev->read_subdev = s;
 	/* we support single-ended (ground) and differential */
@@ -2664,7 +2664,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->do_cmdtest = s626_ai_cmdtest;
 	s->cancel = s626_ai_cancel;
 
-	s = dev->subdevices + 1;
+	s = &dev->subdevices[1];
 	/* analog output subdevice */
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
@@ -2674,7 +2674,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->insn_write = s626_ao_winsn;
 	s->insn_read = s626_ao_rinsn;
 
-	s = dev->subdevices + 2;
+	s = &dev->subdevices[2];
 	/* digital I/O subdevice */
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
@@ -2686,7 +2686,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->insn_config = s626_dio_insn_config;
 	s->insn_bits = s626_dio_insn_bits;
 
-	s = dev->subdevices + 3;
+	s = &dev->subdevices[3];
 	/* digital I/O subdevice */
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
@@ -2698,7 +2698,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->insn_config = s626_dio_insn_config;
 	s->insn_bits = s626_dio_insn_bits;
 
-	s = dev->subdevices + 4;
+	s = &dev->subdevices[4];
 	/* digital I/O subdevice */
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
@@ -2710,7 +2710,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->insn_config = s626_dio_insn_config;
 	s->insn_bits = s626_dio_insn_bits;
 
-	s = dev->subdevices + 5;
+	s = &dev->subdevices[5];
 	/* encoder (counter) subdevice */
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;

commit 1515e5222658efa29523a5c794827303113246dd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 15:43:33 2013 -0700

    staging: comedi: s626: cleanup s626_dio_insn_bits()
    
    Add some local variables to make this function a bit clearer and
    remove the unnecessary comments.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 9d1e6edefd95..f0ea5b94b314 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1650,33 +1650,22 @@ static void s626_dio_init(struct comedi_device *dev)
 	}
 }
 
-/* DIO devices are slightly special.  Although it is possible to
- * implement the insn_read/insn_write interface, it is much more
- * useful to applications if you implement the insn_bits interface.
- * This allows packed reading/writing of the DIO channels.  The comedi
- * core can convert between insn_bits and insn_read/write */
-
 static int s626_dio_insn_bits(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
 	unsigned long group = (unsigned long)s->private;
+	unsigned long mask = data[0];
+	unsigned long bits = data[1];
 
-	/*
-	 * The insn data consists of a mask in data[0] and the new data in
-	 * data[1]. The mask defines which bits we are concerning about.
-	 * The new data must be anded with the mask.  Each channel
-	 * corresponds to a bit.
-	 */
-	if (data[0]) {
-		/* Check if requested ports are configured for output */
-		if ((s->io_bits & data[0]) != data[0])
+	if (mask) {
+		/* Check if requested channels are configured for output */
+		if ((s->io_bits & mask) != mask)
 			return -EIO;
 
-		s->state &= ~data[0];
-		s->state |= data[0] & data[1];
-
-		/* Write out the new digital output lines */
+		s->state &= ~mask;
+		s->state |= (bits & mask);
 
 		DEBIwrite(dev, LP_WRDOUT(group), s->state);
 	}

commit e920fad281e9d5168f8d10a5ced11c719b05233a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 15:43:15 2013 -0700

    staging: comedi: s626: cleanup s626_dio_insn_config()
    
    Add some local variables to make this function a bit cleaner.
    
    The comedi core expects this function to return the number of
    data parameters used. Change the return from '1' to insn->n to
    make this more aparent.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index b03088b4726f..9d1e6edefd95 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1687,23 +1687,23 @@ static int s626_dio_insn_bits(struct comedi_device *dev,
 
 static int s626_dio_insn_config(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	unsigned long group = (unsigned long)s->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int mask = 1 << chan;
 
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_QUERY:
-		data[1] =
-		    (s->
-		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
-		    COMEDI_INPUT;
+		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 	case COMEDI_INPUT:
-		s->io_bits &= ~(1 << CR_CHAN(insn->chanspec));
+		s->io_bits &= ~mask;
 		break;
 	case COMEDI_OUTPUT:
-		s->io_bits |= 1 << CR_CHAN(insn->chanspec);
+		s->io_bits |= mask;
 		break;
 	default:
 		return -EINVAL;
@@ -1711,7 +1711,7 @@ static int s626_dio_insn_config(struct comedi_device *dev,
 	}
 	DEBIwrite(dev, LP_WRDOUT(group), s->io_bits);
 
-	return 1;
+	return insn->n;
 }
 
 /* Now this function initializes the value of the counter (data[0])

commit 12f4e2f280f99c967c2848e99f14e02b3c1cb209
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 15:42:58 2013 -0700

    staging: comedi: s626: remove the uint16_t casts of the bit values
    
    There are a number of uint16_t casts used in the #define's of the
    constant bit field values as well as the calls to DEBIreplace().
    These cause a number of sparse warnings of the type:
    
    warning: cast truncates bits from constant value (ffff1cff becomes 1cff)
    
    Remove all of the casts and change the types of the parameters to
    DEBIreplace from uin16_t to unsigned int. This fixes all the warnings.
    
    Mask the addr that is or'ed with DEBI_CMD_RDWORD then written to the
    P_DEBICMD register as well as the val written to the P_DEBIAD register
    with 0xffff. The addr and val are only 16-bits but the registers are
    32-bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 520a5cc90343..b03088b4726f 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -239,12 +239,13 @@ static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
  * specifies bits that are to be preserved, wdata is new value to be
  * or'd with the masked original.
  */
-static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
-			uint16_t wdata)
+static void DEBIreplace(struct comedi_device *dev, unsigned int addr,
+			unsigned int mask, unsigned int wdata)
 {
 	struct s626_private *devpriv = dev->private;
 	unsigned int val;
 
+	addr &= 0xffff;
 	writel(DEBI_CMD_RDWORD | addr, devpriv->mmio + P_DEBICMD);
 	DEBItransfer(dev);
 
@@ -252,7 +253,7 @@ static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
 	val = readl(devpriv->mmio + P_DEBIAD);
 	val &= mask;
 	val |= wdata;
-	writel(val, devpriv->mmio + P_DEBIAD);
+	writel(val & 0xffff, devpriv->mmio + P_DEBIAD);
 	DEBItransfer(dev);
 }
 
@@ -594,8 +595,8 @@ static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
 			   uint16_t value)
 {
 	DEBIreplace(dev, k->MyCRB,
-		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC)),
-		    (uint16_t) (value << CRBBIT_LATCHSRC));
+		    ~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC),
+		    value << CRBBIT_LATCHSRC);
 }
 
 /*  Write value into counter preload register. */
@@ -1815,13 +1816,13 @@ static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
 
 static void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k)
 {
-	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
+	DEBIreplace(dev, k->MyCRB, ~CRBMSK_INTCTRL,
 		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 }
 
 static void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k)
 {
-	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
+	DEBIreplace(dev, k->MyCRB, ~CRBMSK_INTCTRL,
 		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
 }
 
@@ -1966,8 +1967,7 @@ static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
 	/*  While retaining CounterB and LatchSrc configurations, program the */
 	/*  new counter operating mode. */
 	DEBIreplace(dev, k->MyCRA, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
-	DEBIreplace(dev, k->MyCRB,
-		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
+	DEBIreplace(dev, k->MyCRB, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A), crb);
 }
 
 static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
@@ -2028,8 +2028,7 @@ static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
 
 	/*  While retaining CounterA and LatchSrc configurations, program the */
 	/*  new counter operating mode. */
-	DEBIreplace(dev, k->MyCRA,
-		    (uint16_t) (~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B)), cra);
+	DEBIreplace(dev, k->MyCRA, ~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B), cra);
 	DEBIreplace(dev, k->MyCRB, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
 }
 
@@ -2038,17 +2037,15 @@ static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
 static void SetEnable_A(struct comedi_device *dev, struct enc_private *k,
 			uint16_t enab)
 {
-	DEBIreplace(dev, k->MyCRB,
-		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)),
-		    (uint16_t) (enab << CRBBIT_CLKENAB_A));
+	DEBIreplace(dev, k->MyCRB, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A),
+		    enab << CRBBIT_CLKENAB_A);
 }
 
 static void SetEnable_B(struct comedi_device *dev, struct enc_private *k,
 			uint16_t enab)
 {
-	DEBIreplace(dev, k->MyCRB,
-		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),
-		    (uint16_t) (enab << CRBBIT_CLKENAB_B));
+	DEBIreplace(dev, k->MyCRB, ~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B),
+		    enab << CRBBIT_CLKENAB_B);
 }
 
 static uint16_t GetEnable_A(struct comedi_device *dev, struct enc_private *k)
@@ -2077,16 +2074,15 @@ static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k)
 static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k,
 			  uint16_t Trig)
 {
-	DEBIreplace(dev, k->MyCRA, (uint16_t) (~CRAMSK_LOADSRC_A),
-		    (uint16_t) (Trig << CRABIT_LOADSRC_A));
+	DEBIreplace(dev, k->MyCRA, ~CRAMSK_LOADSRC_A,
+		    Trig << CRABIT_LOADSRC_A);
 }
 
 static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k,
 			  uint16_t Trig)
 {
-	DEBIreplace(dev, k->MyCRB,
-		    (uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),
-		    (uint16_t) (Trig << CRBBIT_LOADSRC_B));
+	DEBIreplace(dev, k->MyCRB, ~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL),
+		    Trig << CRBBIT_LOADSRC_B);
 }
 
 static uint16_t GetLoadTrig_A(struct comedi_device *dev, struct enc_private *k)
@@ -2110,12 +2106,12 @@ static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
 	struct s626_private *devpriv = dev->private;
 
 	/*  Reset any pending counter overflow or index captures. */
-	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
+	DEBIreplace(dev, k->MyCRB, ~CRBMSK_INTCTRL,
 		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 
 	/*  Program counter interrupt source. */
 	DEBIreplace(dev, k->MyCRA, ~CRAMSK_INTSRC_A,
-		    (uint16_t) (IntSource << CRABIT_INTSRC_A));
+		    IntSource << CRABIT_INTSRC_A);
 
 	/*  Update MISC2 interrupt enable mask. */
 	devpriv->CounterIntEnabs =

commit 7d856da216c536972dbcd3ce77774b202fd0755f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 15:42:38 2013 -0700

    staging: comedi: s626: rename private data 'base_addr' variable
    
    The base_address variable in the private data is the ioremap'ed
    PCI bar 0 resource.
    
    For aesthetic reasons, and to shorten some of the lines, rename
    this variable to 'mmio'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 96600f36a13d..520a5cc90343 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -80,7 +80,7 @@ INSN_CONFIG instructions:
 #define PCI_SUBDEVICE_ID_S626 0x0272
 
 struct s626_private {
-	void __iomem *base_addr;
+	void __iomem *mmio;
 	uint8_t ai_cmd_running;	/*  ai_cmd is running */
 	uint8_t ai_continous;	/*  continous acquisition */
 	int ai_sample_count;	/*  number of samples to acquire */
@@ -147,7 +147,7 @@ static void s626_mc_enable(struct comedi_device *dev,
 	struct s626_private *devpriv = dev->private;
 	unsigned int val = (cmd << 16) | cmd;
 
-	writel(val, devpriv->base_addr + reg);
+	writel(val, devpriv->mmio + reg);
 }
 
 static void s626_mc_disable(struct comedi_device *dev,
@@ -155,7 +155,7 @@ static void s626_mc_disable(struct comedi_device *dev,
 {
 	struct s626_private *devpriv = dev->private;
 
-	writel(cmd << 16 , devpriv->base_addr + reg);
+	writel(cmd << 16 , devpriv->mmio + reg);
 }
 
 static bool s626_mc_test(struct comedi_device *dev,
@@ -164,7 +164,7 @@ static bool s626_mc_test(struct comedi_device *dev,
 	struct s626_private *devpriv = dev->private;
 	unsigned int val;
 
-	val = readl(devpriv->base_addr + reg);
+	val = readl(devpriv->mmio + reg);
 
 	return (val & cmd) ? true : false;
 }
@@ -203,7 +203,7 @@ static void DEBItransfer(struct comedi_device *dev)
 		;
 
 	/* Wait until DEBI transfer is done */
-	while (readl(devpriv->base_addr + P_PSR) & PSR_DEBI_S)
+	while (readl(devpriv->mmio + P_PSR) & PSR_DEBI_S)
 		;
 }
 
@@ -214,12 +214,12 @@ static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
 	struct s626_private *devpriv = dev->private;
 
 	/* Set up DEBI control register value in shadow RAM */
-	writel(DEBI_CMD_RDWORD | addr, devpriv->base_addr + P_DEBICMD);
+	writel(DEBI_CMD_RDWORD | addr, devpriv->mmio + P_DEBICMD);
 
 	/*  Execute the DEBI transfer. */
 	DEBItransfer(dev);
 
-	return readl(devpriv->base_addr + P_DEBIAD);
+	return readl(devpriv->mmio + P_DEBIAD);
 }
 
 /*  Write a value to a gate array register. */
@@ -228,8 +228,8 @@ static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
 	struct s626_private *devpriv = dev->private;
 
 	/* Set up DEBI control register value in shadow RAM */
-	writel(DEBI_CMD_WRWORD | addr, devpriv->base_addr + P_DEBICMD);
-	writel(wdata, devpriv->base_addr + P_DEBIAD);
+	writel(DEBI_CMD_WRWORD | addr, devpriv->mmio + P_DEBICMD);
+	writel(wdata, devpriv->mmio + P_DEBIAD);
 
 	/*  Execute the DEBI transfer. */
 	DEBItransfer(dev);
@@ -245,14 +245,14 @@ static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
 	struct s626_private *devpriv = dev->private;
 	unsigned int val;
 
-	writel(DEBI_CMD_RDWORD | addr, devpriv->base_addr + P_DEBICMD);
+	writel(DEBI_CMD_RDWORD | addr, devpriv->mmio + P_DEBICMD);
 	DEBItransfer(dev);
 
-	writel(DEBI_CMD_WRWORD | addr, devpriv->base_addr + P_DEBICMD);
-	val = readl(devpriv->base_addr + P_DEBIAD);
+	writel(DEBI_CMD_WRWORD | addr, devpriv->mmio + P_DEBICMD);
+	val = readl(devpriv->mmio + P_DEBIAD);
 	val &= mask;
 	val |= wdata;
-	writel(val, devpriv->base_addr + P_DEBIAD);
+	writel(val, devpriv->mmio + P_DEBIAD);
 	DEBItransfer(dev);
 }
 
@@ -264,7 +264,7 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 	unsigned int ctrl;
 
 	/* Write I2C command to I2C Transfer Control shadow register */
-	writel(val, devpriv->base_addr + P_I2CCTRL);
+	writel(val, devpriv->mmio + P_I2CCTRL);
 
 	/*
 	 * Upload I2C shadow registers into working registers and
@@ -276,7 +276,7 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 
 	/* Wait until I2C bus transfer is finished or an error occurs */
 	do {
-		ctrl = readl(devpriv->base_addr + P_I2CCTRL);
+		ctrl = readl(devpriv->mmio + P_I2CCTRL);
 	} while ((ctrl & (I2C_BUSY | I2C_ERR)) == I2C_BUSY);
 
 	/* Return non-zero if I2C error occurred */
@@ -315,7 +315,7 @@ static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 		return 0;
 	}
 
-	return (readl(devpriv->base_addr + P_I2CCTRL) >> 16) & 0xff;
+	return (readl(devpriv->mmio + P_I2CCTRL) >> 16) & 0xff;
 }
 
 /* ***********  DAC FUNCTIONS *********** */
@@ -355,7 +355,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 
 	/* Copy DAC setpoint value to DAC's output DMA buffer. */
 
-	/* writel(val, devpriv->base_addr + (uint32_t)devpriv->pDacWBuf); */
+	/* writel(val, devpriv->mmio + (uint32_t)devpriv->pDacWBuf); */
 	*devpriv->pDacWBuf = val;
 
 	/*
@@ -373,7 +373,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * other FIFO underflow/overflow flags). When set, this flag
 	 * will indicate that we have emerged from slot 0.
 	 */
-	writel(ISR_AFOU, devpriv->base_addr + P_ISR);
+	writel(ISR_AFOU, devpriv->mmio + P_ISR);
 
 	/* Wait for the DMA transfer to finish so that there will be data
 	 * available in the FIFO when time slot 1 tries to transfer a DWORD
@@ -381,7 +381,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * Done by polling the DMAC enable flag; this flag is automatically
 	 * cleared when the transfer has finished.
 	 */
-	while (readl(devpriv->base_addr + P_MC1) & MC1_A2OUT)
+	while (readl(devpriv->mmio + P_MC1) & MC1_A2OUT)
 		;
 
 	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
@@ -391,7 +391,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
 	 * detection.
 	 */
-	writel(XSD2 | RSD3 | SIB_A2, devpriv->base_addr + VECTPORT(0));
+	writel(XSD2 | RSD3 | SIB_A2, devpriv->mmio + VECTPORT(0));
 
 	/* Wait for slot 1 to execute to ensure that the Packet will be
 	 * transmitted.  This is detected by polling the Audio2 output FIFO
@@ -399,7 +399,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * finished transferring the DAC's data DWORD from the output FIFO
 	 * to the output buffer register.
 	 */
-	while (!(readl(devpriv->base_addr + P_SSR) & SSR_AF2_OUT))
+	while (!(readl(devpriv->mmio + P_SSR) & SSR_AF2_OUT))
 		;
 
 	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
@@ -409,7 +409,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * buffer register.
 	 */
 	writel(XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS,
-	       devpriv->base_addr + VECTPORT(0));
+	       devpriv->mmio + VECTPORT(0));
 
 	/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */
 
@@ -430,14 +430,14 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 *    we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
 	 *    the TSL has not yet finished executing slot 5 ...
 	 */
-	if (readl(devpriv->base_addr + P_FB_BUFFER2) & 0xff000000) {
+	if (readl(devpriv->mmio + P_FB_BUFFER2) & 0xff000000) {
 		/* The trap was set on time and we are still executing somewhere
 		 * in slots 2-5, so we now wait for slot 0 to execute and trap
 		 * TSL execution.  This is detected when FB_BUFFER2 MSB changes
 		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
 		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
 		 */
-		while (readl(devpriv->base_addr + P_FB_BUFFER2) & 0xff000000)
+		while (readl(devpriv->mmio + P_FB_BUFFER2) & 0xff000000)
 			;
 	}
 	/* Either (1) we were too late setting the slot 0 trap; the TSL
@@ -448,13 +448,13 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * In order to do this, we reprogram slot 0 so that it will shift in
 	 * SD3, which is driven only by a pull-up resistor.
 	 */
-	writel(RSD3 | SIB_A2 | EOS, devpriv->base_addr + VECTPORT(0));
+	writel(RSD3 | SIB_A2 | EOS, devpriv->mmio + VECTPORT(0));
 
 	/* Wait for slot 0 to execute, at which time the TSL is setup for
 	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
 	 * from 0x00 to 0xFF.
 	 */
-	while (!(readl(devpriv->base_addr + P_FB_BUFFER2) & 0xff000000))
+	while (!(readl(devpriv->mmio + P_FB_BUFFER2) & 0xff000000))
 		;
 }
 
@@ -491,13 +491,13 @@ static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
 	/* Choose DAC chip select to be asserted */
 	WSImage = (chan & 2) ? WS1 : WS2;
 	/* Slot 2: Transmit high data byte to target DAC */
-	writel(XSD2 | XFIFO_1 | WSImage, devpriv->base_addr + VECTPORT(2));
+	writel(XSD2 | XFIFO_1 | WSImage, devpriv->mmio + VECTPORT(2));
 	/* Slot 3: Transmit low data byte to target DAC */
-	writel(XSD2 | XFIFO_0 | WSImage, devpriv->base_addr + VECTPORT(3));
+	writel(XSD2 | XFIFO_0 | WSImage, devpriv->mmio + VECTPORT(3));
 	/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */
-	writel(XSD2 | XFIFO_3 | WS3, devpriv->base_addr + VECTPORT(4));
+	writel(XSD2 | XFIFO_3 | WS3, devpriv->mmio + VECTPORT(4));
 	/* Slot 5: running after writing target DAC's low data byte */
-	writel(XSD2 | XFIFO_2 | WS3 | EOS, devpriv->base_addr + VECTPORT(5));
+	writel(XSD2 | XFIFO_2 | WS3 | EOS, devpriv->mmio + VECTPORT(5));
 
 	/*  Construct and transmit target DAC's serial packet:
 	 * ( A10D DDDD ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan<0>,
@@ -534,13 +534,13 @@ static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
 	 */
 
 	/* Slot 2: Send high uint8_t to target TrimDac */
-	writel(XSD2 | XFIFO_1 | WS3, devpriv->base_addr + VECTPORT(2));
+	writel(XSD2 | XFIFO_1 | WS3, devpriv->mmio + VECTPORT(2));
 	/* Slot 3: Send low uint8_t to target TrimDac */
-	writel(XSD2 | XFIFO_0 | WS3, devpriv->base_addr + VECTPORT(3));
+	writel(XSD2 | XFIFO_0 | WS3, devpriv->mmio + VECTPORT(3));
 	/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running */
-	writel(XSD2 | XFIFO_3 | WS1, devpriv->base_addr + VECTPORT(4));
+	writel(XSD2 | XFIFO_3 | WS1, devpriv->mmio + VECTPORT(4));
 	/* Slot 5: Send NOP low  uint8_t to DAC0 */
-	writel(XSD2 | XFIFO_2 | WS1 | EOS, devpriv->base_addr + VECTPORT(5));
+	writel(XSD2 | XFIFO_2 | WS1 | EOS, devpriv->mmio + VECTPORT(5));
 
 	/* Construct and transmit target DAC's serial packet:
 	 * ( 0000 AAAA ), ( DDDD DDDD ),( 0x00 ),( 0x00 ) where A<3:0> is the
@@ -885,16 +885,16 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	spin_lock_irqsave(&dev->spinlock, flags);
 
 	/* save interrupt enable register state */
-	irqstatus = readl(devpriv->base_addr + P_IER);
+	irqstatus = readl(devpriv->mmio + P_IER);
 
 	/* read interrupt type */
-	irqtype = readl(devpriv->base_addr + P_ISR);
+	irqtype = readl(devpriv->mmio + P_ISR);
 
 	/* disable master interrupt */
-	writel(0, devpriv->base_addr + P_IER);
+	writel(0, devpriv->mmio + P_IER);
 
 	/* clear interrupt */
-	writel(irqtype, devpriv->base_addr + P_ISR);
+	writel(irqtype, devpriv->mmio + P_ISR);
 
 	switch (irqtype) {
 	case IRQ_RPS1:		/*  end_of_scan occurs */
@@ -909,7 +909,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	}
 
 	/* enable interrupt */
-	writel(irqstatus, devpriv->base_addr + P_IER);
+	writel(irqstatus, devpriv->mmio + P_IER);
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 	return IRQ_HANDLED;
@@ -936,7 +936,7 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 
 	/* Initialize RPS instruction pointer */
 	writel((uint32_t)devpriv->RPSBuf.PhysicalBase,
-	       devpriv->base_addr + P_RPSADDR1);
+	       devpriv->mmio + P_RPSADDR1);
 
 	/*  Construct RPS program in RPSBuf DMA buffer */
 
@@ -1165,7 +1165,7 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	int n;
 
 	/* interrupt call test  */
-/*   writel(IRQ_GPIO3,devpriv->base_addr+P_PSR); */
+/*   writel(IRQ_GPIO3,devpriv->mmio+P_PSR); */
 	/* Writing a logical 1 into any of the RPS_PSR bits causes the
 	 * corresponding interrupt to be generated if enabled
 	 */
@@ -1190,26 +1190,26 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 		udelay(10);
 
 		/* Start ADC by pulsing GPIO1 low */
-		GpioImage = readl(devpriv->base_addr + P_GPIO);
+		GpioImage = readl(devpriv->mmio + P_GPIO);
 		/* Assert ADC Start command */
-		writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
+		writel(GpioImage & ~GPIO1_HI, devpriv->mmio + P_GPIO);
 		/* and stretch it out */
-		writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
-		writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
+		writel(GpioImage & ~GPIO1_HI, devpriv->mmio + P_GPIO);
+		writel(GpioImage & ~GPIO1_HI, devpriv->mmio + P_GPIO);
 		/* Negate ADC Start command */
-		writel(GpioImage | GPIO1_HI, devpriv->base_addr + P_GPIO);
+		writel(GpioImage | GPIO1_HI, devpriv->mmio + P_GPIO);
 
 		/*  Wait for ADC to complete (GPIO2 is asserted high when */
 		/*  ADC not busy) and for data from previous conversion to */
 		/*  shift into FB BUFFER 1 register. */
 
 		/* Wait for ADC done */
-		while (!(readl(devpriv->base_addr + P_PSR) & PSR_GPIO2))
+		while (!(readl(devpriv->mmio + P_PSR) & PSR_GPIO2))
 			;
 
 		/* Fetch ADC data */
 		if (n != 0) {
-			tmp = readl(devpriv->base_addr + P_FB_BUFFER1);
+			tmp = readl(devpriv->mmio + P_FB_BUFFER1);
 			data[n - 1] = s626_ai_reg_to_uint(tmp);
 		}
 
@@ -1226,26 +1226,26 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 
 	/* Start a dummy conversion to cause the data from the
 	 * previous conversion to be shifted in. */
-	GpioImage = readl(devpriv->base_addr + P_GPIO);
+	GpioImage = readl(devpriv->mmio + P_GPIO);
 	/* Assert ADC Start command */
-	writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
+	writel(GpioImage & ~GPIO1_HI, devpriv->mmio + P_GPIO);
 	/* and stretch it out */
-	writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
-	writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
+	writel(GpioImage & ~GPIO1_HI, devpriv->mmio + P_GPIO);
+	writel(GpioImage & ~GPIO1_HI, devpriv->mmio + P_GPIO);
 	/* Negate ADC Start command */
-	writel(GpioImage | GPIO1_HI, devpriv->base_addr + P_GPIO);
+	writel(GpioImage | GPIO1_HI, devpriv->mmio + P_GPIO);
 
 	/*  Wait for the data to arrive in FB BUFFER 1 register. */
 
 	/* Wait for ADC done */
-	while (!(readl(devpriv->base_addr + P_PSR) & PSR_GPIO2))
+	while (!(readl(devpriv->mmio + P_PSR) & PSR_GPIO2))
 		;
 
 	/*  Fetch ADC data from audio interface's input shift register. */
 
 	/* Fetch ADC data */
 	if (n != 0) {
-		tmp = readl(devpriv->base_addr + P_FB_BUFFER1);
+		tmp = readl(devpriv->mmio + P_FB_BUFFER1);
 		data[n - 1] = s626_ai_reg_to_uint(tmp);
 	}
 
@@ -1360,10 +1360,10 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EBUSY;
 	}
 	/* disable interrupt */
-	writel(0, devpriv->base_addr + P_IER);
+	writel(0, devpriv->mmio + P_IER);
 
 	/* clear interrupt request */
-	writel(IRQ_RPS1 | IRQ_GPIO3, devpriv->base_addr + P_ISR);
+	writel(IRQ_RPS1 | IRQ_GPIO3, devpriv->mmio + P_ISR);
 
 	/* clear any pending interrupt */
 	s626_dio_clear_irq(dev);
@@ -1464,7 +1464,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* enable interrupt */
-	writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->base_addr + P_IER);
+	writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->mmio + P_IER);
 
 	return 0;
 }
@@ -1585,7 +1585,7 @@ static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	s626_mc_disable(dev, MC1_ERPS1, P_MC1);
 
 	/* disable master interrupt */
-	writel(0, devpriv->base_addr + P_IER);
+	writel(0, devpriv->mmio + P_IER);
 
 	devpriv->ai_cmd_running = 0;
 
@@ -2397,13 +2397,13 @@ static void s626_initialize(struct comedi_device *dev)
 	writel(DEBI_CFG_SLAVE16 |
 	       (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
 	       DEBI_SWAP | DEBI_CFG_INTEL,
-	       devpriv->base_addr + P_DEBICFG);
+	       devpriv->mmio + P_DEBICFG);
 
 	/* Disable MMU paging */
-	writel(DEBI_PAGE_DISABLE, devpriv->base_addr + P_DEBIPAGE);
+	writel(DEBI_PAGE_DISABLE, devpriv->mmio + P_DEBIPAGE);
 
 	/* Init GPIO so that ADC Start* is negated */
-	writel(GPIO_BASE | GPIO1_HI, devpriv->base_addr + P_GPIO);
+	writel(GPIO_BASE | GPIO1_HI, devpriv->mmio + P_GPIO);
 
 	/* I2C device address for onboard eeprom (revb) */
 	devpriv->I2CAdrs = 0xA0;
@@ -2412,9 +2412,9 @@ static void s626_initialize(struct comedi_device *dev)
 	 * Issue an I2C ABORT command to halt any I2C
 	 * operation in progress and reset BUSY flag.
 	 */
-	writel(I2C_CLKSEL | I2C_ABORT, devpriv->base_addr + P_I2CSTAT);
+	writel(I2C_CLKSEL | I2C_ABORT, devpriv->mmio + P_I2CSTAT);
 	s626_mc_enable(dev, MC2_UPLD_IIC, P_MC2);
-	while (!(readl(devpriv->base_addr + P_MC2) & MC2_UPLD_IIC))
+	while (!(readl(devpriv->mmio + P_MC2) & MC2_UPLD_IIC))
 		;
 
 	/*
@@ -2422,7 +2422,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * reg twice to reset all  I2C error flags.
 	 */
 	for (i = 0; i < 2; i++) {
-		writel(I2C_CLKSEL, devpriv->base_addr + P_I2CSTAT);
+		writel(I2C_CLKSEL, devpriv->mmio + P_I2CSTAT);
 		s626_mc_enable(dev, MC2_UPLD_IIC, P_MC2);
 		while (!s626_mc_test(dev, MC2_UPLD_IIC, P_MC2))
 			;
@@ -2434,7 +2434,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * DAC data setup times are satisfied, enable DAC serial
 	 * clock out.
 	 */
-	writel(ACON2_INIT, devpriv->base_addr + P_ACON2);
+	writel(ACON2_INIT, devpriv->mmio + P_ACON2);
 
 	/*
 	 * Set up TSL1 slot list, which is used to control the
@@ -2442,11 +2442,11 @@ static void s626_initialize(struct comedi_device *dev)
 	 * SIB_A1  = store data uint8_t at next available location
 	 * in FB BUFFER1 register.
 	 */
-	writel(RSD1 | SIB_A1, devpriv->base_addr + P_TSL1);
-	writel(RSD1 | SIB_A1 | EOS, devpriv->base_addr + P_TSL1 + 4);
+	writel(RSD1 | SIB_A1, devpriv->mmio + P_TSL1);
+	writel(RSD1 | SIB_A1 | EOS, devpriv->mmio + P_TSL1 + 4);
 
 	/* Enable TSL1 slot list so that it executes all the time */
-	writel(ACON1_ADCSTART, devpriv->base_addr + P_ACON1);
+	writel(ACON1_ADCSTART, devpriv->mmio + P_ACON1);
 
 	/*
 	 * Initialize RPS registers used for ADC
@@ -2454,11 +2454,11 @@ static void s626_initialize(struct comedi_device *dev)
 
 	/* Physical start of RPS program */
 	writel((uint32_t)devpriv->RPSBuf.PhysicalBase,
-	       devpriv->base_addr + P_RPSADDR1);
+	       devpriv->mmio + P_RPSADDR1);
 	/* RPS program performs no explicit mem writes */
-	writel(0, devpriv->base_addr + P_RPSPAGE1);
+	writel(0, devpriv->mmio + P_RPSPAGE1);
 	/* Disable RPS timeouts */
-	writel(0, devpriv->base_addr + P_RPS1_TOUT);
+	writel(0, devpriv->mmio + P_RPS1_TOUT);
 
 #if 0
 	/*
@@ -2514,7 +2514,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 *   burst length = 1 DWORD
 	 *   threshold = 1 DWORD.
 	 */
-	writel(0, devpriv->base_addr + P_PCI_BT_A);
+	writel(0, devpriv->mmio + P_PCI_BT_A);
 
 	/*
 	 * Init Audio2's output DMA physical addresses.  The protection
@@ -2524,9 +2524,9 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 	pPhysBuf = devpriv->ANABuf.PhysicalBase +
 		   (DAC_WDMABUF_OS * sizeof(uint32_t));
-	writel((uint32_t)pPhysBuf, devpriv->base_addr + P_BASEA2_OUT);
+	writel((uint32_t)pPhysBuf, devpriv->mmio + P_BASEA2_OUT);
 	writel((uint32_t)(pPhysBuf + sizeof(uint32_t)),
-	       devpriv->base_addr + P_PROTA2_OUT);
+	       devpriv->mmio + P_PROTA2_OUT);
 
 	/*
 	 * Cache Audio2's output DMA buffer logical address.  This is
@@ -2541,7 +2541,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * DMAC will automatically halt and its PCI address pointer
 	 * will be reset when the protection address is reached.
 	 */
-	writel(8, devpriv->base_addr + P_PAGEA2_OUT);
+	writel(8, devpriv->mmio + P_PAGEA2_OUT);
 
 	/*
 	 * Initialize time slot list 2 (TSL2), which is used to control
@@ -2556,7 +2556,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 
 	/* Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2 */
-	writel(XSD2 | RSD3 | SIB_A2 | EOS, devpriv->base_addr + VECTPORT(0));
+	writel(XSD2 | RSD3 | SIB_A2 | EOS, devpriv->mmio + VECTPORT(0));
 
 	/*
 	 * Initialize slot 1, which is constant.  Slot 1 causes a
@@ -2568,10 +2568,10 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 
 	/* Slot 1: Fetch DWORD from Audio2's output FIFO */
-	writel(LF_A2, devpriv->base_addr + VECTPORT(1));
+	writel(LF_A2, devpriv->mmio + VECTPORT(1));
 
 	/* Start DAC's audio interface (TSL2) running */
-	writel(ACON1_DACSTART, devpriv->base_addr + P_ACON1);
+	writel(ACON1_DACSTART, devpriv->mmio + P_ACON1);
 
 	/*
 	 * Init Trim DACs to calibrated values.  Do it twice because the
@@ -2612,7 +2612,7 @@ static void s626_initialize(struct comedi_device *dev)
 	s626_dio_init(dev);
 
 	/* enable interrupt test */
-	/* writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->base_addr + P_IER); */
+	/* writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->mmio + P_IER); */
 }
 
 static int s626_auto_attach(struct comedi_device *dev,
@@ -2634,16 +2634,16 @@ static int s626_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	devpriv->base_addr = ioremap(pci_resource_start(pcidev, 0),
-				     pci_resource_len(pcidev, 0));
-	if (!devpriv->base_addr)
+	devpriv->mmio = ioremap(pci_resource_start(pcidev, 0),
+				pci_resource_len(pcidev, 0));
+	if (!devpriv->mmio)
 		return -ENOMEM;
 
 	/* disable master interrupt */
-	writel(0, devpriv->base_addr + P_IER);
+	writel(0, devpriv->mmio + P_IER);
 
 	/* soft reset */
-	writel(MC1_SOFT_RESET, devpriv->base_addr + P_MC1);
+	writel(MC1_SOFT_RESET, devpriv->mmio + P_MC1);
 
 	/* DMA FIXME DMA// */
 
@@ -2752,20 +2752,20 @@ static void s626_detach(struct comedi_device *dev)
 		/* stop ai_command */
 		devpriv->ai_cmd_running = 0;
 
-		if (devpriv->base_addr) {
+		if (devpriv->mmio) {
 			/* interrupt mask */
 			/* Disable master interrupt */
-			writel(0, devpriv->base_addr + P_IER);
+			writel(0, devpriv->mmio + P_IER);
 			/* Clear board's IRQ status flag */
 			writel(IRQ_GPIO3 | IRQ_RPS1,
-			       devpriv->base_addr + P_ISR);
+			       devpriv->mmio + P_ISR);
 
 			/*  Disable the watchdog timer and battery charger. */
 			WriteMISC2(dev, 0);
 
 			/* Close all interfaces on 7146 device */
-			writel(MC1_SHUTDOWN, devpriv->base_addr + P_MC1);
-			writel(ACON1_BASE, devpriv->base_addr + P_ACON1);
+			writel(MC1_SHUTDOWN, devpriv->mmio + P_MC1);
+			writel(ACON1_BASE, devpriv->mmio + P_ACON1);
 
 			CloseDMAB(dev, &devpriv->RPSBuf, DMABUF_SIZE);
 			CloseDMAB(dev, &devpriv->ANABuf, DMABUF_SIZE);
@@ -2773,8 +2773,8 @@ static void s626_detach(struct comedi_device *dev)
 
 		if (dev->irq)
 			free_irq(dev->irq, dev);
-		if (devpriv->base_addr)
-			iounmap(devpriv->base_addr);
+		if (devpriv->mmio)
+			iounmap(devpriv->mmio);
 	}
 	comedi_pci_disable(dev);
 }

commit be008602e677c3837c9a8b8fb3cbaa1ebd76f08f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 15:42:21 2013 -0700

    staging: comedi: s626: remove RR7146 macro
    
    This macro relies on a local variable having a specific name its
    also just a wrapper around a readl() call. Remove the macro and
    just call readl() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 3add9eab4be8..96600f36a13d 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -169,10 +169,6 @@ static bool s626_mc_test(struct comedi_device *dev,
 	return (val & cmd) ? true : false;
 }
 
-/* #define RR7146(REGARDS)
-    readl((uint32_t)(devpriv->base_addr+(REGARDS))) */
-#define RR7146(REGARDS)		readl(devpriv->base_addr+(REGARDS))
-
 #define BUGFIX_STREG(REGADRS)   (REGADRS - 4)
 
 /*  Write a time slot control record to TSL2. */
@@ -206,8 +202,8 @@ static void DEBItransfer(struct comedi_device *dev)
 	while (!s626_mc_test(dev, MC2_UPLD_DEBI, P_MC2))
 		;
 
-	/*  Wait until DEBI transfer is done. */
-	while (RR7146(P_PSR) & PSR_DEBI_S)
+	/* Wait until DEBI transfer is done */
+	while (readl(devpriv->base_addr + P_PSR) & PSR_DEBI_S)
 		;
 }
 
@@ -216,7 +212,6 @@ static void DEBItransfer(struct comedi_device *dev)
 static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
 {
 	struct s626_private *devpriv = dev->private;
-	uint16_t retval;
 
 	/* Set up DEBI control register value in shadow RAM */
 	writel(DEBI_CMD_RDWORD | addr, devpriv->base_addr + P_DEBICMD);
@@ -224,11 +219,7 @@ static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
 	/*  Execute the DEBI transfer. */
 	DEBItransfer(dev);
 
-	/*  Fetch target register value. */
-	retval = (uint16_t) RR7146(P_DEBIAD);
-
-	/*  Return register value. */
-	return retval;
+	return readl(devpriv->base_addr + P_DEBIAD);
 }
 
 /*  Write a value to a gate array register. */
@@ -252,19 +243,17 @@ static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
 			uint16_t wdata)
 {
 	struct s626_private *devpriv = dev->private;
+	unsigned int val;
 
-	/* Copy target gate array register into P_DEBIAD register */
 	writel(DEBI_CMD_RDWORD | addr, devpriv->base_addr + P_DEBICMD);
-	/* Set up DEBI control reg value in shadow RAM. */
-	DEBItransfer(dev);	/*  Execute the DEBI Read transfer. */
+	DEBItransfer(dev);
 
-	/* Write back the modified image */
 	writel(DEBI_CMD_WRWORD | addr, devpriv->base_addr + P_DEBICMD);
-	/* Set up DEBI control reg value in shadow RAM */
-	writel(wdata | ((uint16_t) RR7146(P_DEBIAD) & mask),
-	       devpriv->base_addr + P_DEBIAD);
-	/* Modify the register image. */
-	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
+	val = readl(devpriv->base_addr + P_DEBIAD);
+	val &= mask;
+	val |= wdata;
+	writel(val, devpriv->base_addr + P_DEBIAD);
+	DEBItransfer(dev);
 }
 
 /* **************  EEPROM ACCESS FUNCTIONS  ************** */
@@ -272,6 +261,7 @@ static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
 static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 {
 	struct s626_private *devpriv = dev->private;
+	unsigned int ctrl;
 
 	/* Write I2C command to I2C Transfer Control shadow register */
 	writel(val, devpriv->base_addr + P_I2CCTRL);
@@ -284,20 +274,19 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 	while (!s626_mc_test(dev, MC2_UPLD_IIC, P_MC2))
 		;
 
-	/*  Wait until I2C bus transfer is finished or an error occurs. */
-	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY)
-		;
-
-	/*  Return non-zero if I2C error occurred. */
-	return RR7146(P_I2CCTRL) & I2C_ERR;
+	/* Wait until I2C bus transfer is finished or an error occurs */
+	do {
+		ctrl = readl(devpriv->base_addr + P_I2CCTRL);
+	} while ((ctrl & (I2C_BUSY | I2C_ERR)) == I2C_BUSY);
 
+	/* Return non-zero if I2C error occurred */
+	return ctrl & I2C_ERR;
 }
 
 /*  Read uint8_t from EEPROM. */
 static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 {
 	struct s626_private *devpriv = dev->private;
-	uint8_t rtnval;
 
 	/*  Send EEPROM target address. */
 	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)
@@ -325,9 +314,8 @@ static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 		/*  Abort function and declare error if handshake failed. */
 		return 0;
 	}
-	/*  Return copy of EEPROM value. */
-	rtnval = (uint8_t) (RR7146(P_I2CCTRL) >> 16);
-	return rtnval;
+
+	return (readl(devpriv->base_addr + P_I2CCTRL) >> 16) & 0xff;
 }
 
 /* ***********  DAC FUNCTIONS *********** */
@@ -393,7 +381,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * Done by polling the DMAC enable flag; this flag is automatically
 	 * cleared when the transfer has finished.
 	 */
-	while ((RR7146(P_MC1) & MC1_A2OUT) != 0)
+	while (readl(devpriv->base_addr + P_MC1) & MC1_A2OUT)
 		;
 
 	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
@@ -411,7 +399,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * finished transferring the DAC's data DWORD from the output FIFO
 	 * to the output buffer register.
 	 */
-	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0)
+	while (!(readl(devpriv->base_addr + P_SSR) & SSR_AF2_OUT))
 		;
 
 	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
@@ -442,14 +430,14 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 *    we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
 	 *    the TSL has not yet finished executing slot 5 ...
 	 */
-	if ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) {
+	if (readl(devpriv->base_addr + P_FB_BUFFER2) & 0xff000000) {
 		/* The trap was set on time and we are still executing somewhere
 		 * in slots 2-5, so we now wait for slot 0 to execute and trap
 		 * TSL execution.  This is detected when FB_BUFFER2 MSB changes
 		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
 		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
 		 */
-		while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0)
+		while (readl(devpriv->base_addr + P_FB_BUFFER2) & 0xff000000)
 			;
 	}
 	/* Either (1) we were too late setting the slot 0 trap; the TSL
@@ -466,7 +454,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
 	 * from 0x00 to 0xFF.
 	 */
-	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0)
+	while (!(readl(devpriv->base_addr + P_FB_BUFFER2) & 0xff000000))
 		;
 }
 
@@ -1173,6 +1161,7 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	uint16_t range = CR_RANGE(insn->chanspec);
 	uint16_t AdcSpec = 0;
 	uint32_t GpioImage;
+	int tmp;
 	int n;
 
 	/* interrupt call test  */
@@ -1200,8 +1189,8 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 		/*  Delay 10 microseconds for analog input settling. */
 		udelay(10);
 
-		/*  Start ADC by pulsing GPIO1 low. */
-		GpioImage = RR7146(P_GPIO);
+		/* Start ADC by pulsing GPIO1 low */
+		GpioImage = readl(devpriv->base_addr + P_GPIO);
 		/* Assert ADC Start command */
 		writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
 		/* and stretch it out */
@@ -1214,13 +1203,15 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 		/*  ADC not busy) and for data from previous conversion to */
 		/*  shift into FB BUFFER 1 register. */
 
-		/*  Wait for ADC done. */
-		while (!(RR7146(P_PSR) & PSR_GPIO2))
+		/* Wait for ADC done */
+		while (!(readl(devpriv->base_addr + P_PSR) & PSR_GPIO2))
 			;
 
-		/*  Fetch ADC data. */
-		if (n != 0)
-			data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
+		/* Fetch ADC data */
+		if (n != 0) {
+			tmp = readl(devpriv->base_addr + P_FB_BUFFER1);
+			data[n - 1] = s626_ai_reg_to_uint(tmp);
+		}
 
 		/* Allow the ADC to stabilize for 4 microseconds before
 		 * starting the next (final) conversion.  This delay is
@@ -1235,8 +1226,7 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 
 	/* Start a dummy conversion to cause the data from the
 	 * previous conversion to be shifted in. */
-	GpioImage = RR7146(P_GPIO);
-
+	GpioImage = readl(devpriv->base_addr + P_GPIO);
 	/* Assert ADC Start command */
 	writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
 	/* and stretch it out */
@@ -1247,15 +1237,17 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 
 	/*  Wait for the data to arrive in FB BUFFER 1 register. */
 
-	/*  Wait for ADC done. */
-	while (!(RR7146(P_PSR) & PSR_GPIO2))
+	/* Wait for ADC done */
+	while (!(readl(devpriv->base_addr + P_PSR) & PSR_GPIO2))
 		;
 
 	/*  Fetch ADC data from audio interface's input shift register. */
 
-	/*  Fetch ADC data. */
-	if (n != 0)
-		data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
+	/* Fetch ADC data */
+	if (n != 0) {
+		tmp = readl(devpriv->base_addr + P_FB_BUFFER1);
+		data[n - 1] = s626_ai_reg_to_uint(tmp);
+	}
 
 	return n;
 }
@@ -2422,7 +2414,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 	writel(I2C_CLKSEL | I2C_ABORT, devpriv->base_addr + P_I2CSTAT);
 	s626_mc_enable(dev, MC2_UPLD_IIC, P_MC2);
-	while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)
+	while (!(readl(devpriv->base_addr + P_MC2) & MC2_UPLD_IIC))
 		;
 
 	/*

commit 25f8fd5e11d6859867660679f9b12c10fd4f0789
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 15:41:59 2013 -0700

    staging: comedi: s626: remove WR7146 and SETVECT macros
    
    The WR7146 macro relies on a local variable having a specific name.
    This macro is a wrapper around a writel() call. Remove the macro and
    just call writel() directly.
    
    The SETVEC macro uses the WR7146 macro so remove it as well and just
    do the writel() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index f73c8c0bd923..3add9eab4be8 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -169,10 +169,6 @@ static bool s626_mc_test(struct comedi_device *dev,
 	return (val & cmd) ? true : false;
 }
 
-/* #define WR7146(REGARDS,CTRLWORD)
-    writel(CTRLWORD,(uint32_t)(devpriv->base_addr+(REGARDS))) */
-#define WR7146(REGARDS, CTRLWORD) writel(CTRLWORD, devpriv->base_addr+(REGARDS))
-
 /* #define RR7146(REGARDS)
     readl((uint32_t)(devpriv->base_addr+(REGARDS))) */
 #define RR7146(REGARDS)		readl(devpriv->base_addr+(REGARDS))
@@ -181,7 +177,6 @@ static bool s626_mc_test(struct comedi_device *dev,
 
 /*  Write a time slot control record to TSL2. */
 #define VECTPORT(VECTNUM)		(P_TSL2 + ((VECTNUM) << 2))
-#define SETVECT(VECTNUM, VECTVAL)	WR7146(VECTPORT(VECTNUM), (VECTVAL))
 
 /*  Code macros used for constructing I2C command bytes. */
 #define I2C_B2(ATTR, VAL)	(((ATTR) << 6) | ((VAL) << 24))
@@ -223,8 +218,8 @@ static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
 	struct s626_private *devpriv = dev->private;
 	uint16_t retval;
 
-	/*  Set up DEBI control register value in shadow RAM. */
-	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
+	/* Set up DEBI control register value in shadow RAM */
+	writel(DEBI_CMD_RDWORD | addr, devpriv->base_addr + P_DEBICMD);
 
 	/*  Execute the DEBI transfer. */
 	DEBItransfer(dev);
@@ -241,9 +236,9 @@ static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
 {
 	struct s626_private *devpriv = dev->private;
 
-	/*  Set up DEBI control register value in shadow RAM. */
-	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
-	WR7146(P_DEBIAD, wdata);
+	/* Set up DEBI control register value in shadow RAM */
+	writel(DEBI_CMD_WRWORD | addr, devpriv->base_addr + P_DEBICMD);
+	writel(wdata, devpriv->base_addr + P_DEBIAD);
 
 	/*  Execute the DEBI transfer. */
 	DEBItransfer(dev);
@@ -258,16 +253,16 @@ static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
 {
 	struct s626_private *devpriv = dev->private;
 
-	/*  Copy target gate array register into P_DEBIAD register. */
-	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
+	/* Copy target gate array register into P_DEBIAD register */
+	writel(DEBI_CMD_RDWORD | addr, devpriv->base_addr + P_DEBICMD);
 	/* Set up DEBI control reg value in shadow RAM. */
 	DEBItransfer(dev);	/*  Execute the DEBI Read transfer. */
 
-	/*  Write back the modified image. */
-	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
-	/* Set up DEBI control reg value in shadow  RAM. */
-
-	WR7146(P_DEBIAD, wdata | ((uint16_t) RR7146(P_DEBIAD) & mask));
+	/* Write back the modified image */
+	writel(DEBI_CMD_WRWORD | addr, devpriv->base_addr + P_DEBICMD);
+	/* Set up DEBI control reg value in shadow RAM */
+	writel(wdata | ((uint16_t) RR7146(P_DEBIAD) & mask),
+	       devpriv->base_addr + P_DEBIAD);
 	/* Modify the register image. */
 	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
 }
@@ -278,8 +273,8 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 {
 	struct s626_private *devpriv = dev->private;
 
-	/*  Write I2C command to I2C Transfer Control shadow register. */
-	WR7146(P_I2CCTRL, val);
+	/* Write I2C command to I2C Transfer Control shadow register */
+	writel(val, devpriv->base_addr + P_I2CCTRL);
 
 	/*
 	 * Upload I2C shadow registers into working registers and
@@ -372,7 +367,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 
 	/* Copy DAC setpoint value to DAC's output DMA buffer. */
 
-	/* WR7146( (uint32_t)devpriv->pDacWBuf, val ); */
+	/* writel(val, devpriv->base_addr + (uint32_t)devpriv->pDacWBuf); */
 	*devpriv->pDacWBuf = val;
 
 	/*
@@ -385,11 +380,12 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 
 	/*  While the DMA transfer is executing ... */
 
-	/* Reset Audio2 output FIFO's underflow flag (along with any other
-	 * FIFO underflow/overflow flags).  When set, this flag will
-	 * indicate that we have emerged from slot 0.
+	/*
+	 * Reset Audio2 output FIFO's underflow flag (along with any
+	 * other FIFO underflow/overflow flags). When set, this flag
+	 * will indicate that we have emerged from slot 0.
 	 */
-	WR7146(P_ISR, ISR_AFOU);
+	writel(ISR_AFOU, devpriv->base_addr + P_ISR);
 
 	/* Wait for the DMA transfer to finish so that there will be data
 	 * available in the FIFO when time slot 1 tries to transfer a DWORD
@@ -407,7 +403,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
 	 * detection.
 	 */
-	SETVECT(0, XSD2 | RSD3 | SIB_A2);
+	writel(XSD2 | RSD3 | SIB_A2, devpriv->base_addr + VECTPORT(0));
 
 	/* Wait for slot 1 to execute to ensure that the Packet will be
 	 * transmitted.  This is detected by polling the Audio2 output FIFO
@@ -424,7 +420,8 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * stored in the last byte to be shifted out of the FIFO's DWORD
 	 * buffer register.
 	 */
-	SETVECT(0, XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS);
+	writel(XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS,
+	       devpriv->base_addr + VECTPORT(0));
 
 	/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */
 
@@ -463,7 +460,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * In order to do this, we reprogram slot 0 so that it will shift in
 	 * SD3, which is driven only by a pull-up resistor.
 	 */
-	SETVECT(0, RSD3 | SIB_A2 | EOS);
+	writel(RSD3 | SIB_A2 | EOS, devpriv->base_addr + VECTPORT(0));
 
 	/* Wait for slot 0 to execute, at which time the TSL is setup for
 	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
@@ -503,16 +500,16 @@ static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
 	 * disables gating for the DAC clock and all DAC chip selects.
 	 */
 
+	/* Choose DAC chip select to be asserted */
 	WSImage = (chan & 2) ? WS1 : WS2;
-	/* Choose DAC chip select to be asserted. */
-	SETVECT(2, XSD2 | XFIFO_1 | WSImage);
-	/* Slot 2: Transmit high data byte to target DAC. */
-	SETVECT(3, XSD2 | XFIFO_0 | WSImage);
-	/* Slot 3: Transmit low data byte to target DAC. */
-	SETVECT(4, XSD2 | XFIFO_3 | WS3);
+	/* Slot 2: Transmit high data byte to target DAC */
+	writel(XSD2 | XFIFO_1 | WSImage, devpriv->base_addr + VECTPORT(2));
+	/* Slot 3: Transmit low data byte to target DAC */
+	writel(XSD2 | XFIFO_0 | WSImage, devpriv->base_addr + VECTPORT(3));
 	/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */
-	SETVECT(5, XSD2 | XFIFO_2 | WS3 | EOS);
-	/* Slot 5: running after writing target DAC's low data byte. */
+	writel(XSD2 | XFIFO_3 | WS3, devpriv->base_addr + VECTPORT(4));
+	/* Slot 5: running after writing target DAC's low data byte */
+	writel(XSD2 | XFIFO_2 | WS3 | EOS, devpriv->base_addr + VECTPORT(5));
 
 	/*  Construct and transmit target DAC's serial packet:
 	 * ( A10D DDDD ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan<0>,
@@ -548,14 +545,14 @@ static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
 	 * can be detected.
 	 */
 
-	SETVECT(2, XSD2 | XFIFO_1 | WS3);
-	/* Slot 2: Send high uint8_t to target TrimDac. */
-	SETVECT(3, XSD2 | XFIFO_0 | WS3);
-	/* Slot 3: Send low uint8_t to target TrimDac. */
-	SETVECT(4, XSD2 | XFIFO_3 | WS1);
-	/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running. */
-	SETVECT(5, XSD2 | XFIFO_2 | WS1 | EOS);
-	/* Slot 5: Send NOP low  uint8_t to DAC0. */
+	/* Slot 2: Send high uint8_t to target TrimDac */
+	writel(XSD2 | XFIFO_1 | WS3, devpriv->base_addr + VECTPORT(2));
+	/* Slot 3: Send low uint8_t to target TrimDac */
+	writel(XSD2 | XFIFO_0 | WS3, devpriv->base_addr + VECTPORT(3));
+	/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running */
+	writel(XSD2 | XFIFO_3 | WS1, devpriv->base_addr + VECTPORT(4));
+	/* Slot 5: Send NOP low  uint8_t to DAC0 */
+	writel(XSD2 | XFIFO_2 | WS1 | EOS, devpriv->base_addr + VECTPORT(5));
 
 	/* Construct and transmit target DAC's serial packet:
 	 * ( 0000 AAAA ), ( DDDD DDDD ),( 0x00 ),( 0x00 ) where A<3:0> is the
@@ -949,8 +946,9 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 	/*  Set starting logical address to write RPS commands. */
 	pRPS = (uint32_t *) devpriv->RPSBuf.LogicalBase;
 
-	/*  Initialize RPS instruction pointer. */
-	WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
+	/* Initialize RPS instruction pointer */
+	writel((uint32_t)devpriv->RPSBuf.PhysicalBase,
+	       devpriv->base_addr + P_RPSADDR1);
 
 	/*  Construct RPS program in RPSBuf DMA buffer */
 
@@ -1204,13 +1202,13 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 
 		/*  Start ADC by pulsing GPIO1 low. */
 		GpioImage = RR7146(P_GPIO);
-		/*  Assert ADC Start command */
-		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-		/*    and stretch it out. */
-		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-		/*  Negate ADC Start command. */
-		WR7146(P_GPIO, GpioImage | GPIO1_HI);
+		/* Assert ADC Start command */
+		writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
+		/* and stretch it out */
+		writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
+		writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
+		/* Negate ADC Start command */
+		writel(GpioImage | GPIO1_HI, devpriv->base_addr + P_GPIO);
 
 		/*  Wait for ADC to complete (GPIO2 is asserted high when */
 		/*  ADC not busy) and for data from previous conversion to */
@@ -1240,12 +1238,12 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	GpioImage = RR7146(P_GPIO);
 
 	/* Assert ADC Start command */
-	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-	/*    and stretch it out. */
-	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-	/*  Negate ADC Start command. */
-	WR7146(P_GPIO, GpioImage | GPIO1_HI);
+	writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
+	/* and stretch it out */
+	writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
+	writel(GpioImage & ~GPIO1_HI, devpriv->base_addr + P_GPIO);
+	/* Negate ADC Start command */
+	writel(GpioImage | GPIO1_HI, devpriv->base_addr + P_GPIO);
 
 	/*  Wait for the data to arrive in FB BUFFER 1 register. */
 
@@ -2404,15 +2402,16 @@ static void s626_initialize(struct comedi_device *dev)
 	 *   Set up byte lane steering
 	 *   Intel-compatible local bus (DEBI never times out)
 	 */
-	WR7146(P_DEBICFG, DEBI_CFG_SLAVE16 |
-			  (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
-			  DEBI_SWAP | DEBI_CFG_INTEL);
+	writel(DEBI_CFG_SLAVE16 |
+	       (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
+	       DEBI_SWAP | DEBI_CFG_INTEL,
+	       devpriv->base_addr + P_DEBICFG);
 
 	/* Disable MMU paging */
-	WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);
+	writel(DEBI_PAGE_DISABLE, devpriv->base_addr + P_DEBIPAGE);
 
 	/* Init GPIO so that ADC Start* is negated */
-	WR7146(P_GPIO, GPIO_BASE | GPIO1_HI);
+	writel(GPIO_BASE | GPIO1_HI, devpriv->base_addr + P_GPIO);
 
 	/* I2C device address for onboard eeprom (revb) */
 	devpriv->I2CAdrs = 0xA0;
@@ -2421,7 +2420,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * Issue an I2C ABORT command to halt any I2C
 	 * operation in progress and reset BUSY flag.
 	 */
-	WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);
+	writel(I2C_CLKSEL | I2C_ABORT, devpriv->base_addr + P_I2CSTAT);
 	s626_mc_enable(dev, MC2_UPLD_IIC, P_MC2);
 	while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)
 		;
@@ -2431,7 +2430,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * reg twice to reset all  I2C error flags.
 	 */
 	for (i = 0; i < 2; i++) {
-		WR7146(P_I2CSTAT, I2C_CLKSEL);
+		writel(I2C_CLKSEL, devpriv->base_addr + P_I2CSTAT);
 		s626_mc_enable(dev, MC2_UPLD_IIC, P_MC2);
 		while (!s626_mc_test(dev, MC2_UPLD_IIC, P_MC2))
 			;
@@ -2443,7 +2442,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * DAC data setup times are satisfied, enable DAC serial
 	 * clock out.
 	 */
-	WR7146(P_ACON2, ACON2_INIT);
+	writel(ACON2_INIT, devpriv->base_addr + P_ACON2);
 
 	/*
 	 * Set up TSL1 slot list, which is used to control the
@@ -2451,22 +2450,23 @@ static void s626_initialize(struct comedi_device *dev)
 	 * SIB_A1  = store data uint8_t at next available location
 	 * in FB BUFFER1 register.
 	 */
-	WR7146(P_TSL1, RSD1 | SIB_A1);
-	WR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);
+	writel(RSD1 | SIB_A1, devpriv->base_addr + P_TSL1);
+	writel(RSD1 | SIB_A1 | EOS, devpriv->base_addr + P_TSL1 + 4);
 
 	/* Enable TSL1 slot list so that it executes all the time */
-	WR7146(P_ACON1, ACON1_ADCSTART);
+	writel(ACON1_ADCSTART, devpriv->base_addr + P_ACON1);
 
 	/*
 	 * Initialize RPS registers used for ADC
 	 */
 
 	/* Physical start of RPS program */
-	WR7146(P_RPSADDR1, (uint32_t)devpriv->RPSBuf.PhysicalBase);
+	writel((uint32_t)devpriv->RPSBuf.PhysicalBase,
+	       devpriv->base_addr + P_RPSADDR1);
 	/* RPS program performs no explicit mem writes */
-	WR7146(P_RPSPAGE1, 0);
+	writel(0, devpriv->base_addr + P_RPSPAGE1);
 	/* Disable RPS timeouts */
-	WR7146(P_RPS1_TOUT, 0);
+	writel(0, devpriv->base_addr + P_RPS1_TOUT);
 
 #if 0
 	/*
@@ -2522,7 +2522,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 *   burst length = 1 DWORD
 	 *   threshold = 1 DWORD.
 	 */
-	WR7146(P_PCI_BT_A, 0);
+	writel(0, devpriv->base_addr + P_PCI_BT_A);
 
 	/*
 	 * Init Audio2's output DMA physical addresses.  The protection
@@ -2532,8 +2532,9 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 	pPhysBuf = devpriv->ANABuf.PhysicalBase +
 		   (DAC_WDMABUF_OS * sizeof(uint32_t));
-	WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);
-	WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));
+	writel((uint32_t)pPhysBuf, devpriv->base_addr + P_BASEA2_OUT);
+	writel((uint32_t)(pPhysBuf + sizeof(uint32_t)),
+	       devpriv->base_addr + P_PROTA2_OUT);
 
 	/*
 	 * Cache Audio2's output DMA buffer logical address.  This is
@@ -2548,7 +2549,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * DMAC will automatically halt and its PCI address pointer
 	 * will be reset when the protection address is reached.
 	 */
-	WR7146(P_PAGEA2_OUT, 8);
+	writel(8, devpriv->base_addr + P_PAGEA2_OUT);
 
 	/*
 	 * Initialize time slot list 2 (TSL2), which is used to control
@@ -2563,7 +2564,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 
 	/* Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2 */
-	SETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);
+	writel(XSD2 | RSD3 | SIB_A2 | EOS, devpriv->base_addr + VECTPORT(0));
 
 	/*
 	 * Initialize slot 1, which is constant.  Slot 1 causes a
@@ -2575,10 +2576,10 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 
 	/* Slot 1: Fetch DWORD from Audio2's output FIFO */
-	SETVECT(1, LF_A2);
+	writel(LF_A2, devpriv->base_addr + VECTPORT(1));
 
 	/* Start DAC's audio interface (TSL2) running */
-	WR7146(P_ACON1, ACON1_DACSTART);
+	writel(ACON1_DACSTART, devpriv->base_addr + P_ACON1);
 
 	/*
 	 * Init Trim DACs to calibrated values.  Do it twice because the
@@ -2761,15 +2762,18 @@ static void s626_detach(struct comedi_device *dev)
 
 		if (devpriv->base_addr) {
 			/* interrupt mask */
-			WR7146(P_IER, 0);	/*  Disable master interrupt. */
-			WR7146(P_ISR, IRQ_GPIO3 | IRQ_RPS1);	/*  Clear board's IRQ status flag. */
+			/* Disable master interrupt */
+			writel(0, devpriv->base_addr + P_IER);
+			/* Clear board's IRQ status flag */
+			writel(IRQ_GPIO3 | IRQ_RPS1,
+			       devpriv->base_addr + P_ISR);
 
 			/*  Disable the watchdog timer and battery charger. */
 			WriteMISC2(dev, 0);
 
-			/*  Close all interfaces on 7146 device. */
-			WR7146(P_MC1, MC1_SHUTDOWN);
-			WR7146(P_ACON1, ACON1_BASE);
+			/* Close all interfaces on 7146 device */
+			writel(MC1_SHUTDOWN, devpriv->base_addr + P_MC1);
+			writel(ACON1_BASE, devpriv->base_addr + P_ACON1);
 
 			CloseDMAB(dev, &devpriv->RPSBuf, DMABUF_SIZE);
 			CloseDMAB(dev, &devpriv->ANABuf, DMABUF_SIZE);

commit 95bb7982759f75f47f23af2e0209f1b39f6dd3d2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 15:41:41 2013 -0700

    staging: comedi: s626: remove MC_TEST macro
    
    This macro relies on a local variable having a specific name. Replace
    it with a new helper function, s626_mc_test().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 138a943c57e5..f73c8c0bd923 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -158,7 +158,16 @@ static void s626_mc_disable(struct comedi_device *dev,
 	writel(cmd << 16 , devpriv->base_addr + reg);
 }
 
-#define MC_TEST(REGADRS, CTRLWORD)	((readl(devpriv->base_addr+(REGADRS)) & CTRLWORD) != 0)
+static bool s626_mc_test(struct comedi_device *dev,
+			 unsigned int cmd, unsigned int reg)
+{
+	struct s626_private *devpriv = dev->private;
+	unsigned int val;
+
+	val = readl(devpriv->base_addr + reg);
+
+	return (val & cmd) ? true : false;
+}
 
 /* #define WR7146(REGARDS,CTRLWORD)
     writel(CTRLWORD,(uint32_t)(devpriv->base_addr+(REGARDS))) */
@@ -195,9 +204,11 @@ static void DEBItransfer(struct comedi_device *dev)
 	/* Initiate upload of shadow RAM to DEBI control register */
 	s626_mc_enable(dev, MC2_UPLD_DEBI, P_MC2);
 
-	/*  Wait for completion of upload from shadow RAM to DEBI control */
-	/*  register. */
-	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI))
+	/*
+	 * Wait for completion of upload from shadow RAM to
+	 * DEBI control register.
+	 */
+	while (!s626_mc_test(dev, MC2_UPLD_DEBI, P_MC2))
 		;
 
 	/*  Wait until DEBI transfer is done. */
@@ -275,7 +286,7 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 	 * wait for upload confirmation.
 	 */
 	s626_mc_enable(dev, MC2_UPLD_IIC, P_MC2);
-	while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
+	while (!s626_mc_test(dev, MC2_UPLD_IIC, P_MC2))
 		;
 
 	/*  Wait until I2C bus transfer is finished or an error occurs. */
@@ -1132,7 +1143,7 @@ static int s626_ai_rinsn(struct comedi_device *dev,
 	s626_mc_enable(dev, MC2_ADC_RPS, P_MC2);
 
 	/* Wait until ADC scan loop is finished (RPS Signal 0 reset) */
-	while (MC_TEST(P_MC2, MC2_ADC_RPS))
+	while (s626_mc_test(dev, MC2_ADC_RPS, P_MC2))
 		;
 
 	/*
@@ -2422,7 +2433,7 @@ static void s626_initialize(struct comedi_device *dev)
 	for (i = 0; i < 2; i++) {
 		WR7146(P_I2CSTAT, I2C_CLKSEL);
 		s626_mc_enable(dev, MC2_UPLD_IIC, P_MC2);
-		while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
+		while (!s626_mc_test(dev, MC2_UPLD_IIC, P_MC2))
 			;
 	}
 

commit c5cf4606b6659e711258b6e567415ab83a3b646c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 15:57:40 2013 -0700

    staging: comedi: s626: remove MC_DISABLE macro
    
    This macro relies on a local variable having a specific name. Replace
    it with a new helper function, s626_mc_disable().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index a6450ffb7efe..138a943c57e5 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -150,7 +150,13 @@ static void s626_mc_enable(struct comedi_device *dev,
 	writel(val, devpriv->base_addr + reg);
 }
 
-#define MC_DISABLE(REGADRS, CTRLWORD)	writel((uint32_t)(CTRLWORD) << 16 , devpriv->base_addr+(REGADRS))
+static void s626_mc_disable(struct comedi_device *dev,
+			    unsigned int cmd, unsigned int reg)
+{
+	struct s626_private *devpriv = dev->private;
+
+	writel(cmd << 16 , devpriv->base_addr + reg);
+}
 
 #define MC_TEST(REGADRS, CTRLWORD)	((readl(devpriv->base_addr+(REGADRS)) & CTRLWORD) != 0)
 
@@ -851,8 +857,8 @@ static bool handle_eos_interrupt(struct comedi_device *dev)
 	if (devpriv->ai_sample_count <= 0) {
 		devpriv->ai_cmd_running = 0;
 
-		/* Stop RPS program. */
-		MC_DISABLE(P_MC1, MC1_ERPS1);
+		/* Stop RPS program */
+		s626_mc_disable(dev, MC1_ERPS1, P_MC1);
 
 		/* send end of acquisition */
 		async->events |= COMEDI_CB_EOA;
@@ -926,8 +932,8 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 	uint32_t LocalPPL;
 	struct comedi_cmd *cmd = &(dev->subdevices->async->cmd);
 
-	/*  Stop RPS program in case it is currently running. */
-	MC_DISABLE(P_MC1, MC1_ERPS1);
+	/* Stop RPS program in case it is currently running */
+	s626_mc_disable(dev, MC1_ERPS1, P_MC1);
 
 	/*  Set starting logical address to write RPS commands. */
 	pRPS = (uint32_t *) devpriv->RPSBuf.LogicalBase;
@@ -1574,8 +1580,8 @@ static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct s626_private *devpriv = dev->private;
 
-	/*  Stop RPS program in case it is currently running. */
-	MC_DISABLE(P_MC1, MC1_ERPS1);
+	/* Stop RPS program in case it is currently running */
+	s626_mc_disable(dev, MC1_ERPS1, P_MC1);
 
 	/* disable master interrupt */
 	writel(0, devpriv->base_addr + P_IER);

commit ddd9813e75c54cd41d561af8f35aa023839155b1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 15:57:21 2013 -0700

    staging: comedi: s626: remove MC_ENABLE macro
    
    This macro relies on a local variable having a specific name. Replace
    it with a new helper function, s626_mc_enable().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 0a9638bcbcda..a6450ffb7efe 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -137,9 +137,18 @@ struct enc_private {
 /*  Translation table to map IntSrc into equivalent RDMISC2 event flag  bits. */
 /* static const uint16_t EventBits[][4] = { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) }; */
 
-/*  enab/disable a function or test status bit(s) that are accessed */
-/*  through Main Control Registers 1 or 2. */
-#define MC_ENABLE(REGADRS, CTRLWORD)	writel(((uint32_t)(CTRLWORD) << 16) | (uint32_t)(CTRLWORD), devpriv->base_addr+(REGADRS))
+/*
+ * Enable/disable a function or test status bit(s) that are accessed
+ * through Main Control Registers 1 or 2.
+ */
+static void s626_mc_enable(struct comedi_device *dev,
+			   unsigned int cmd, unsigned int reg)
+{
+	struct s626_private *devpriv = dev->private;
+	unsigned int val = (cmd << 16) | cmd;
+
+	writel(val, devpriv->base_addr + reg);
+}
 
 #define MC_DISABLE(REGADRS, CTRLWORD)	writel((uint32_t)(CTRLWORD) << 16 , devpriv->base_addr+(REGADRS))
 
@@ -177,8 +186,8 @@ static void DEBItransfer(struct comedi_device *dev)
 {
 	struct s626_private *devpriv = dev->private;
 
-	/*  Initiate upload of shadow RAM to DEBI control register. */
-	MC_ENABLE(P_MC2, MC2_UPLD_DEBI);
+	/* Initiate upload of shadow RAM to DEBI control register */
+	s626_mc_enable(dev, MC2_UPLD_DEBI, P_MC2);
 
 	/*  Wait for completion of upload from shadow RAM to DEBI control */
 	/*  register. */
@@ -255,10 +264,11 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 	/*  Write I2C command to I2C Transfer Control shadow register. */
 	WR7146(P_I2CCTRL, val);
 
-	/*  Upload I2C shadow registers into working registers and wait for */
-	/*  upload confirmation. */
-
-	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
+	/*
+	 * Upload I2C shadow registers into working registers and
+	 * wait for upload confirmation.
+	 */
+	s626_mc_enable(dev, MC2_UPLD_IIC, P_MC2);
 	while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
 		;
 
@@ -348,12 +358,13 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	/* WR7146( (uint32_t)devpriv->pDacWBuf, val ); */
 	*devpriv->pDacWBuf = val;
 
-	/* enab the output DMA transfer.  This will cause the DMAC to copy
-	 * the DAC's data value to A2's output FIFO.  The DMA transfer will
+	/*
+	 * Enable the output DMA transfer. This will cause the DMAC to copy
+	 * the DAC's data value to A2's output FIFO. The DMA transfer will
 	 * then immediately terminate because the protection address is
 	 * reached upon transfer of the first DWORD value.
 	 */
-	MC_ENABLE(P_MC1, MC1_A2OUT);
+	s626_mc_enable(dev, MC1_A2OUT, P_MC1);
 
 	/*  While the DMA transfer is executing ... */
 
@@ -675,15 +686,15 @@ static void handle_dio_interrupt(struct comedi_device *dev,
 		if ((irqbit >> (cmd->start_arg - (16 * group))) == 1 &&
 		    cmd->start_src == TRIG_EXT) {
 			/* Start executing the RPS program */
-			MC_ENABLE(P_MC1, MC1_ERPS1);
+			s626_mc_enable(dev, MC1_ERPS1, P_MC1);
 
 			if (cmd->scan_begin_src == TRIG_EXT)
 				s626_dio_set_irq(dev, cmd->scan_begin_arg);
 		}
 		if ((irqbit >> (cmd->scan_begin_arg - (16 * group))) == 1 &&
 		    cmd->scan_begin_src == TRIG_EXT) {
-			/* Trigger ADC scan loop start (set RPS Signal 0) */
-			MC_ENABLE(P_MC2, MC2_ADC_RPS);
+			/* Trigger ADC scan loop start */
+			s626_mc_enable(dev, MC2_ADC_RPS, P_MC2);
 
 			if (cmd->convert_src == TRIG_EXT) {
 				devpriv->ai_convert_count = cmd->chanlist_len;
@@ -700,8 +711,8 @@ static void handle_dio_interrupt(struct comedi_device *dev,
 		}
 		if ((irqbit >> (cmd->convert_arg - (16 * group))) == 1 &&
 		    cmd->convert_src == TRIG_EXT) {
-			/* Trigger ADC scan loop start (set RPS Signal 0) */
-			MC_ENABLE(P_MC2, MC2_ADC_RPS);
+			/* Trigger ADC scan loop start */
+			s626_mc_enable(dev, MC2_ADC_RPS, P_MC2);
 
 			devpriv->ai_convert_count--;
 			if (devpriv->ai_convert_count > 0)
@@ -777,8 +788,8 @@ static void check_counter_interrupts(struct comedi_device *dev)
 				k->SetEnable(dev, k, CLKENAB_INDEX);
 
 			if (cmd->convert_src == TRIG_TIMER) {
-				/*  Trigger ADC scan loop start by setting RPS Signal 0. */
-				MC_ENABLE(P_MC2, MC2_ADC_RPS);
+				/* Trigger ADC scan loop start */
+				s626_mc_enable(dev, MC2_ADC_RPS, P_MC2);
 			}
 		}
 	}
@@ -789,8 +800,8 @@ static void check_counter_interrupts(struct comedi_device *dev)
 		k->ResetCapFlags(dev, k);
 
 		if (cmd->scan_begin_src == TRIG_TIMER) {
-			/*  Trigger ADC scan loop start by setting RPS Signal 0. */
-			MC_ENABLE(P_MC2, MC2_ADC_RPS);
+			/* Trigger ADC scan loop start */
+			s626_mc_enable(dev, MC2_ADC_RPS, P_MC2);
 		}
 
 		if (cmd->convert_src == TRIG_TIMER) {
@@ -1111,8 +1122,8 @@ static int s626_ai_rinsn(struct comedi_device *dev,
 	register uint8_t i;
 	register int32_t *readaddr;
 
-	/* Trigger ADC scan loop start (set RPS Signal 0) */
-	MC_ENABLE(P_MC2, MC2_ADC_RPS);
+	/* Trigger ADC scan loop start */
+	s626_mc_enable(dev, MC2_ADC_RPS, P_MC2);
 
 	/* Wait until ADC scan loop is finished (RPS Signal 0 reset) */
 	while (MC_TEST(P_MC2, MC2_ADC_RPS))
@@ -1254,13 +1265,11 @@ static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)
 static int s626_ai_inttrig(struct comedi_device *dev,
 			   struct comedi_subdevice *s, unsigned int trignum)
 {
-	struct s626_private *devpriv = dev->private;
-
 	if (trignum != 0)
 		return -EINVAL;
 
-	/*  Start executing the RPS program. */
-	MC_ENABLE(P_MC1, MC1_ERPS1);
+	/* Start executing the RPS program */
+	s626_mc_enable(dev, MC1_ERPS1, P_MC1);
 
 	s->async->inttrig = NULL;
 
@@ -1428,11 +1437,11 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	switch (cmd->start_src) {
 	case TRIG_NOW:
-		/*  Trigger ADC scan loop start by setting RPS Signal 0. */
-		/*  MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
+		/* Trigger ADC scan loop start */
+		/* s626_mc_enable(dev, MC2_ADC_RPS, P_MC2); */
 
-		/*  Start executing the RPS program. */
-		MC_ENABLE(P_MC1, MC1_ERPS1);
+		/* Start executing the RPS program */
+		s626_mc_enable(dev, MC1_ERPS1, P_MC1);
 
 		s->async->inttrig = NULL;
 		break;
@@ -2368,7 +2377,7 @@ static void s626_initialize(struct comedi_device *dev)
 	int i;
 
 	/* Enable DEBI and audio pins, enable I2C interface */
-	MC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);
+	s626_mc_enable(dev, MC1_DEBI | MC1_AUDIO | MC1_I2C, P_MC1);
 
 	/*
 	 *  Configure DEBI operating mode
@@ -2396,7 +2405,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 * operation in progress and reset BUSY flag.
 	 */
 	WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);
-	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
+	s626_mc_enable(dev, MC2_UPLD_IIC, P_MC2);
 	while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)
 		;
 
@@ -2406,7 +2415,7 @@ static void s626_initialize(struct comedi_device *dev)
 	 */
 	for (i = 0; i < 2; i++) {
 		WR7146(P_I2CSTAT, I2C_CLKSEL);
-		MC_ENABLE(P_MC2, MC2_UPLD_IIC);
+		s626_mc_enable(dev, MC2_UPLD_IIC, P_MC2);
 		while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
 			;
 	}

commit e4632a71faed3bcb0c77b19560e7369db0f5182e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 15:57:02 2013 -0700

    staging: comedi: s626: #ifdef out a block of unused code
    
    Currently the unused s626_ai_rinsn() function is commented out with
    /* ... */ on every line of the function. Remove those by using an
    
    This block will be removed once it is determined that it really
    is not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index d5bf8c8d35d5..0a9638bcbcda 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1101,32 +1101,42 @@ static int s626_ai_insn_config(struct comedi_device *dev,
 	return -EINVAL;
 }
 
-/* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data) */
-/* { */
-/*   struct s626_private *devpriv = dev->private; */
-/*   register uint8_t	i; */
-/*   register int32_t	*readaddr; */
+#ifdef unused_code
+static int s626_ai_rinsn(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 struct comedi_insn *insn,
+			 unsigned int *data)
+{
+	struct s626_private *devpriv = dev->private;
+	register uint8_t i;
+	register int32_t *readaddr;
 
-/*   Trigger ADC scan loop start by setting RPS Signal 0. */
-/*   MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
+	/* Trigger ADC scan loop start (set RPS Signal 0) */
+	MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
-/*   Wait until ADC scan loop is finished (RPS Signal 0 reset). */
-/*   while ( MC_TEST( P_MC2, MC2_ADC_RPS ) ); */
+	/* Wait until ADC scan loop is finished (RPS Signal 0 reset) */
+	while (MC_TEST(P_MC2, MC2_ADC_RPS))
+		;
 
-/* Init ptr to DMA buffer that holds new ADC data.  We skip the
- * first uint16_t in the buffer because it contains junk data from
- * the final ADC of the previous poll list scan.
- */
-/*   readaddr = (uint32_t *)devpriv->ANABuf.LogicalBase + 1; */
+	/*
+	 * Init ptr to DMA buffer that holds new ADC data.  We skip the
+	 * first uint16_t in the buffer because it contains junk data from
+	 * the final ADC of the previous poll list scan.
+	 */
+	readaddr = (uint32_t *)devpriv->ANABuf.LogicalBase + 1;
 
-/*  Convert ADC data to 16-bit integer values and copy to application buffer. */
-/*   for ( i = 0; i < devpriv->AdcItems; i++ ) { */
-/*     *data = s626_ai_reg_to_uint( *readaddr++ ); */
-/*     data++; */
-/*   } */
+	/*
+	 * Convert ADC data to 16-bit integer values and
+	 * copy to application buffer.
+	 */
+	for (i = 0; i < devpriv->AdcItems; i++) {
+		*data = s626_ai_reg_to_uint(*readaddr++);
+		data++;
+	}
 
-/*   return i; */
-/* } */
+	return i;
+}
+#endif
 
 static int s626_ai_insn_read(struct comedi_device *dev,
 			     struct comedi_subdevice *s,

commit 90d54ff27e5d5cf0df6eb3cf351a8b2e26d94367
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 15:56:32 2013 -0700

    staging: comedi: s626: cleanup comedi_lrange table
    
    Reformat the whitespace in the comedi_lrange table and use the
    BIP_RANGE() macro instead of generic RANGE() macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index fe768e79c6bf..d5bf8c8d35d5 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -164,10 +164,11 @@ struct enc_private {
 #define I2C_B1(ATTR, VAL)	(((ATTR) << 4) | ((VAL) << 16))
 #define I2C_B0(ATTR, VAL)	(((ATTR) << 2) | ((VAL) <<  8))
 
-static const struct comedi_lrange s626_range_table = { 2, {
-							   RANGE(-5, 5),
-							   RANGE(-10, 10),
-							   }
+static const struct comedi_lrange s626_range_table = {
+	2, {
+		BIP_RANGE(5),
+		BIP_RANGE(10),
+	}
 };
 
 /*  Execute a DEBI transfer.  This must be called from within a */

commit 0b9675d565db334390f5aa97f3c8825682127288
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 15:56:13 2013 -0700

    staging: comedi: s626: factor counter interrupt handling from s626_irq_handler()
    
    Factor the code that handles the counter interrupt out of s626_irq_handler().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 0e4ce52cb800..fe768e79c6bf 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -727,6 +727,79 @@ static void check_dio_interrupts(struct comedi_device *dev)
 	}
 }
 
+static void check_counter_interrupts(struct comedi_device *dev)
+{
+	struct s626_private *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+	struct enc_private *k;
+	uint16_t irqbit;
+
+	/* read interrupt type */
+	irqbit = DEBIread(dev, LP_RDMISC2);
+
+	/* check interrupt on counters */
+	if (irqbit & IRQ_COINT1A) {
+		k = &encpriv[0];
+
+		/* clear interrupt capture flag */
+		k->ResetCapFlags(dev, k);
+	}
+	if (irqbit & IRQ_COINT2A) {
+		k = &encpriv[1];
+
+		/* clear interrupt capture flag */
+		k->ResetCapFlags(dev, k);
+	}
+	if (irqbit & IRQ_COINT3A) {
+		k = &encpriv[2];
+
+		/* clear interrupt capture flag */
+		k->ResetCapFlags(dev, k);
+	}
+	if (irqbit & IRQ_COINT1B) {
+		k = &encpriv[3];
+
+		/* clear interrupt capture flag */
+		k->ResetCapFlags(dev, k);
+	}
+	if (irqbit & IRQ_COINT2B) {
+		k = &encpriv[4];
+
+		/* clear interrupt capture flag */
+		k->ResetCapFlags(dev, k);
+
+		if (devpriv->ai_convert_count > 0) {
+			devpriv->ai_convert_count--;
+			if (devpriv->ai_convert_count == 0)
+				k->SetEnable(dev, k, CLKENAB_INDEX);
+
+			if (cmd->convert_src == TRIG_TIMER) {
+				/*  Trigger ADC scan loop start by setting RPS Signal 0. */
+				MC_ENABLE(P_MC2, MC2_ADC_RPS);
+			}
+		}
+	}
+	if (irqbit & IRQ_COINT3B) {
+		k = &encpriv[5];
+
+		/* clear interrupt capture flag */
+		k->ResetCapFlags(dev, k);
+
+		if (cmd->scan_begin_src == TRIG_TIMER) {
+			/*  Trigger ADC scan loop start by setting RPS Signal 0. */
+			MC_ENABLE(P_MC2, MC2_ADC_RPS);
+		}
+
+		if (cmd->convert_src == TRIG_TIMER) {
+			k = &encpriv[4];
+			devpriv->ai_convert_count = cmd->chanlist_len;
+			k->SetEnable(dev, k, CLKENAB_ALWAYS);
+		}
+	}
+}
+
 static bool handle_eos_interrupt(struct comedi_device *dev)
 {
 	struct s626_private *devpriv = dev->private;
@@ -789,13 +862,8 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct s626_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
-	struct enc_private *k;
 	unsigned long flags;
 	uint32_t irqtype, irqstatus;
-	uint16_t irqbit;
 
 	if (!dev->attached)
 		return IRQ_NONE;
@@ -821,71 +889,9 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 		break;
 	case IRQ_GPIO3:	/* check dio and conter interrupt */
 		/* s626_dio_clear_irq(dev); */
-
 		check_dio_interrupts(dev);
-
-		/* read interrupt type */
-		irqbit = DEBIread(dev, LP_RDMISC2);
-
-		/* check interrupt on counters */
-		if (irqbit & IRQ_COINT1A) {
-			k = &encpriv[0];
-
-			/* clear interrupt capture flag */
-			k->ResetCapFlags(dev, k);
-		}
-		if (irqbit & IRQ_COINT2A) {
-			k = &encpriv[1];
-
-			/* clear interrupt capture flag */
-			k->ResetCapFlags(dev, k);
-		}
-		if (irqbit & IRQ_COINT3A) {
-			k = &encpriv[2];
-
-			/* clear interrupt capture flag */
-			k->ResetCapFlags(dev, k);
-		}
-		if (irqbit & IRQ_COINT1B) {
-			k = &encpriv[3];
-
-			/* clear interrupt capture flag */
-			k->ResetCapFlags(dev, k);
-		}
-		if (irqbit & IRQ_COINT2B) {
-			k = &encpriv[4];
-
-			/* clear interrupt capture flag */
-			k->ResetCapFlags(dev, k);
-
-			if (devpriv->ai_convert_count > 0) {
-				devpriv->ai_convert_count--;
-				if (devpriv->ai_convert_count == 0)
-					k->SetEnable(dev, k, CLKENAB_INDEX);
-
-				if (cmd->convert_src == TRIG_TIMER) {
-					/*  Trigger ADC scan loop start by setting RPS Signal 0. */
-					MC_ENABLE(P_MC2, MC2_ADC_RPS);
-				}
-			}
-		}
-		if (irqbit & IRQ_COINT3B) {
-			k = &encpriv[5];
-
-			/* clear interrupt capture flag */
-			k->ResetCapFlags(dev, k);
-
-			if (cmd->scan_begin_src == TRIG_TIMER) {
-				/*  Trigger ADC scan loop start by setting RPS Signal 0. */
-				MC_ENABLE(P_MC2, MC2_ADC_RPS);
-			}
-
-			if (cmd->convert_src == TRIG_TIMER) {
-				k = &encpriv[4];
-				devpriv->ai_convert_count = cmd->chanlist_len;
-				k->SetEnable(dev, k, CLKENAB_ALWAYS);
-			}
-		}
+		check_counter_interrupts(dev);
+		break;
 	}
 
 	/* enable interrupt */

commit 4c2d13e07ddb97cf6d614f4f1db1a0ad655e8a14
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 15:55:51 2013 -0700

    staging: comedi: s626: factor eos interrupt handling from s626_irq_handler()
    
    Factor the code that handles the end of scan interrupt out of
    s626_irq_handler().
    
    Remove the printk noise when cfc_write_to_buffer() fails. The user
    can't do anything about it anyway.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 24fc5cc06603..0e4ce52cb800 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -727,6 +727,64 @@ static void check_dio_interrupts(struct comedi_device *dev)
 	}
 }
 
+static bool handle_eos_interrupt(struct comedi_device *dev)
+{
+	struct s626_private *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+	/*
+	 * Init ptr to DMA buffer that holds new ADC data.  We skip the
+	 * first uint16_t in the buffer because it contains junk data
+	 * from the final ADC of the previous poll list scan.
+	 */
+	int32_t *readaddr = (int32_t *)devpriv->ANABuf.LogicalBase + 1;
+	bool finished = false;
+	int i;
+
+	/* get the data and hand it over to comedi */
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		short tempdata;
+
+		/*
+		 * Convert ADC data to 16-bit integer values and copy
+		 * to application buffer.
+		 */
+		tempdata = s626_ai_reg_to_uint((int)*readaddr);
+		readaddr++;
+
+		/* put data into read buffer */
+		/* comedi_buf_put(async, tempdata); */
+		cfc_write_to_buffer(s, tempdata);
+	}
+
+	/* end of scan occurs */
+	async->events |= COMEDI_CB_EOS;
+
+	if (!devpriv->ai_continous)
+		devpriv->ai_sample_count--;
+	if (devpriv->ai_sample_count <= 0) {
+		devpriv->ai_cmd_running = 0;
+
+		/* Stop RPS program. */
+		MC_DISABLE(P_MC1, MC1_ERPS1);
+
+		/* send end of acquisition */
+		async->events |= COMEDI_CB_EOA;
+
+		/* disable master interrupt */
+		finished = true;
+	}
+
+	if (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT)
+		s626_dio_set_irq(dev, cmd->scan_begin_arg);
+
+	/* tell comedi that data is there */
+	comedi_event(dev, s);
+
+	return finished;
+}
+
 static irqreturn_t s626_irq_handler(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -736,10 +794,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	struct comedi_cmd *cmd = &async->cmd;
 	struct enc_private *k;
 	unsigned long flags;
-	int32_t *readaddr;
 	uint32_t irqtype, irqstatus;
-	int i = 0;
-	short tempdata;
 	uint16_t irqbit;
 
 	if (!dev->attached)
@@ -761,48 +816,8 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 
 	switch (irqtype) {
 	case IRQ_RPS1:		/*  end_of_scan occurs */
-		/* Init ptr to DMA buffer that holds new ADC data.  We skip the
-		 * first uint16_t in the buffer because it contains junk data from
-		 * the final ADC of the previous poll list scan.
-		 */
-		readaddr = (int32_t *) devpriv->ANABuf.LogicalBase + 1;
-
-		/*  get the data and hand it over to comedi */
-		for (i = 0; i < cmd->chanlist_len; i++) {
-			/*  Convert ADC data to 16-bit integer values and copy to application */
-			/*  buffer. */
-			tempdata = s626_ai_reg_to_uint((int)*readaddr);
-			readaddr++;
-
-			/* put data into read buffer */
-			/*  comedi_buf_put(async, tempdata); */
-			if (cfc_write_to_buffer(s, tempdata) == 0)
-				printk
-				    ("s626_irq_handler: cfc_write_to_buffer error!\n");
-		}
-
-		/* end of scan occurs */
-		async->events |= COMEDI_CB_EOS;
-
-		if (!(devpriv->ai_continous))
-			devpriv->ai_sample_count--;
-		if (devpriv->ai_sample_count <= 0) {
-			devpriv->ai_cmd_running = 0;
-
-			/*  Stop RPS program. */
-			MC_DISABLE(P_MC1, MC1_ERPS1);
-
-			/* send end of acquisition */
-			async->events |= COMEDI_CB_EOA;
-
-			/* disable master interrupt */
+		if (handle_eos_interrupt(dev))
 			irqstatus = 0;
-		}
-
-		if (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT)
-			s626_dio_set_irq(dev, cmd->scan_begin_arg);
-		/*  tell comedi that data is there */
-		comedi_event(dev, s);
 		break;
 	case IRQ_GPIO3:	/* check dio and conter interrupt */
 		/* s626_dio_clear_irq(dev); */

commit 3b00b8570a17b31292d04e41691548fb6d1c2d75
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 15:55:29 2013 -0700

    staging: comedi: s626: use a local var for the s->async in s626_irq_handler()
    
    The comedi_async pointer is used a number of times in this function.
    For aesthetic reasons, use a local variable for the pointer.
    
    Also, since was already have a pointer to the "cmd" use that in the
    for loop instead of s->async->cmd (or even async->cmd).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index b655437b31b0..24fc5cc06603 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -732,7 +732,8 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct s626_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
 	struct enc_private *k;
 	unsigned long flags;
 	int32_t *readaddr;
@@ -767,21 +768,21 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 		readaddr = (int32_t *) devpriv->ANABuf.LogicalBase + 1;
 
 		/*  get the data and hand it over to comedi */
-		for (i = 0; i < (s->async->cmd.chanlist_len); i++) {
+		for (i = 0; i < cmd->chanlist_len; i++) {
 			/*  Convert ADC data to 16-bit integer values and copy to application */
 			/*  buffer. */
 			tempdata = s626_ai_reg_to_uint((int)*readaddr);
 			readaddr++;
 
 			/* put data into read buffer */
-			/*  comedi_buf_put(s->async, tempdata); */
+			/*  comedi_buf_put(async, tempdata); */
 			if (cfc_write_to_buffer(s, tempdata) == 0)
 				printk
 				    ("s626_irq_handler: cfc_write_to_buffer error!\n");
 		}
 
 		/* end of scan occurs */
-		s->async->events |= COMEDI_CB_EOS;
+		async->events |= COMEDI_CB_EOS;
 
 		if (!(devpriv->ai_continous))
 			devpriv->ai_sample_count--;
@@ -792,7 +793,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 			MC_DISABLE(P_MC1, MC1_ERPS1);
 
 			/* send end of acquisition */
-			s->async->events |= COMEDI_CB_EOA;
+			async->events |= COMEDI_CB_EOA;
 
 			/* disable master interrupt */
 			irqstatus = 0;

commit abafc9e851c2319be0f3244af944cc0fa0dd4d6d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 15:55:07 2013 -0700

    staging: comedi: s626: cleanup "subdevice" and "cmd" in s626_irq_handler()
    
    The comedi_subdevice in this function is actually the dev->read_subdev
    that was initialized during the attach of the board. Use that instead
    of accessing the dev->subdevices array directly.
    
    Also, get the comedi_cmd used in s626_irq_handler() when the function
    is first entered.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index ec146679506e..b655437b31b0 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -731,8 +731,8 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct s626_private *devpriv = dev->private;
-	struct comedi_subdevice *s;
-	struct comedi_cmd *cmd;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	struct enc_private *k;
 	unsigned long flags;
 	int32_t *readaddr;
@@ -760,10 +760,6 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 
 	switch (irqtype) {
 	case IRQ_RPS1:		/*  end_of_scan occurs */
-		/*  manage ai subdevice */
-		s = dev->subdevices;
-		cmd = &(s->async->cmd);
-
 		/* Init ptr to DMA buffer that holds new ADC data.  We skip the
 		 * first uint16_t in the buffer because it contains junk data from
 		 * the final ADC of the previous poll list scan.
@@ -808,10 +804,6 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 		comedi_event(dev, s);
 		break;
 	case IRQ_GPIO3:	/* check dio and conter interrupt */
-		/*  manage ai subdevice */
-		s = dev->subdevices;
-		cmd = &(s->async->cmd);
-
 		/* s626_dio_clear_irq(dev); */
 
 		check_dio_interrupts(dev);

commit 65a17c29135190c63f375abaf091b04a99b2631b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 15:54:45 2013 -0700

    staging: comedi: s626: factor dio interrupt handling from s626_irq_handler()
    
    Factor the code that checks and handles the dio interrupts out of
    s626_irq_handler().
    
    This allows reducing the number of indents in the code and makes it
    easier to follow.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 104594bca254..ec146679506e 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -660,6 +660,73 @@ static int s626_dio_clear_irq(struct comedi_device *dev)
 	return 0;
 }
 
+static void handle_dio_interrupt(struct comedi_device *dev,
+				 uint16_t irqbit, uint8_t group)
+{
+	struct s626_private *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
+
+	s626_dio_reset_irq(dev, group, irqbit);
+
+	if (devpriv->ai_cmd_running) {
+		/* check if interrupt is an ai acquisition start trigger */
+		if ((irqbit >> (cmd->start_arg - (16 * group))) == 1 &&
+		    cmd->start_src == TRIG_EXT) {
+			/* Start executing the RPS program */
+			MC_ENABLE(P_MC1, MC1_ERPS1);
+
+			if (cmd->scan_begin_src == TRIG_EXT)
+				s626_dio_set_irq(dev, cmd->scan_begin_arg);
+		}
+		if ((irqbit >> (cmd->scan_begin_arg - (16 * group))) == 1 &&
+		    cmd->scan_begin_src == TRIG_EXT) {
+			/* Trigger ADC scan loop start (set RPS Signal 0) */
+			MC_ENABLE(P_MC2, MC2_ADC_RPS);
+
+			if (cmd->convert_src == TRIG_EXT) {
+				devpriv->ai_convert_count = cmd->chanlist_len;
+
+				s626_dio_set_irq(dev, cmd->convert_arg);
+			}
+
+			if (cmd->convert_src == TRIG_TIMER) {
+				struct enc_private *k = &encpriv[5];
+
+				devpriv->ai_convert_count = cmd->chanlist_len;
+				k->SetEnable(dev, k, CLKENAB_ALWAYS);
+			}
+		}
+		if ((irqbit >> (cmd->convert_arg - (16 * group))) == 1 &&
+		    cmd->convert_src == TRIG_EXT) {
+			/* Trigger ADC scan loop start (set RPS Signal 0) */
+			MC_ENABLE(P_MC2, MC2_ADC_RPS);
+
+			devpriv->ai_convert_count--;
+			if (devpriv->ai_convert_count > 0)
+				s626_dio_set_irq(dev, cmd->convert_arg);
+		}
+	}
+}
+
+static void check_dio_interrupts(struct comedi_device *dev)
+{
+	uint16_t irqbit;
+	uint8_t group;
+
+	for (group = 0; group < S626_DIO_BANKS; group++) {
+		irqbit = 0;
+		/* read interrupt type */
+		irqbit = DEBIread(dev, LP_RDCAPFLG(group));
+
+		/* check if interrupt is generated from dio channels */
+		if (irqbit) {
+			handle_dio_interrupt(dev, irqbit, group);
+			return;
+		}
+	}
+}
+
 static irqreturn_t s626_irq_handler(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -672,7 +739,6 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	uint32_t irqtype, irqstatus;
 	int i = 0;
 	short tempdata;
-	uint8_t group;
 	uint16_t irqbit;
 
 	if (!dev->attached)
@@ -748,73 +814,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 
 		/* s626_dio_clear_irq(dev); */
 
-		for (group = 0; group < S626_DIO_BANKS; group++) {
-			irqbit = 0;
-			/* read interrupt type */
-			irqbit = DEBIread(dev, LP_RDCAPFLG(group));
-
-			/* check if interrupt is generated from dio channels */
-			if (irqbit) {
-				s626_dio_reset_irq(dev, group, irqbit);
-				if (devpriv->ai_cmd_running) {
-					/* check if interrupt is an ai acquisition start trigger */
-					if ((irqbit >> (cmd->start_arg -
-							(16 * group)))
-					    == 1 && cmd->start_src == TRIG_EXT) {
-						/*  Start executing the RPS program. */
-						MC_ENABLE(P_MC1, MC1_ERPS1);
-
-						if (cmd->scan_begin_src ==
-						    TRIG_EXT) {
-							s626_dio_set_irq(dev,
-									 cmd->scan_begin_arg);
-						}
-					}
-					if ((irqbit >> (cmd->scan_begin_arg -
-							(16 * group)))
-					    == 1
-					    && cmd->scan_begin_src ==
-					    TRIG_EXT) {
-						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
-						MC_ENABLE(P_MC2, MC2_ADC_RPS);
-
-						if (cmd->convert_src ==
-						    TRIG_EXT) {
-							devpriv->ai_convert_count
-							    = cmd->chanlist_len;
-
-							s626_dio_set_irq(dev,
-									 cmd->convert_arg);
-						}
-
-						if (cmd->convert_src ==
-						    TRIG_TIMER) {
-							k = &encpriv[5];
-							devpriv->ai_convert_count
-							    = cmd->chanlist_len;
-							k->SetEnable(dev, k,
-								     CLKENAB_ALWAYS);
-						}
-					}
-					if ((irqbit >> (cmd->convert_arg -
-							(16 * group)))
-					    == 1
-					    && cmd->convert_src == TRIG_EXT) {
-						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
-						MC_ENABLE(P_MC2, MC2_ADC_RPS);
-
-						devpriv->ai_convert_count--;
-
-						if (devpriv->ai_convert_count >
-						    0) {
-							s626_dio_set_irq(dev,
-									 cmd->convert_arg);
-						}
-					}
-				}
-				break;
-			}
-		}
+		check_dio_interrupts(dev);
 
 		/* read interrupt type */
 		irqbit = DEBIread(dev, LP_RDMISC2);

commit 100b4edcad71cea9cd815c3519bfe2e93811bd44
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 15:54:20 2013 -0700

    staging: comedi: s626: simplify dio register access
    
    This driver has three dio subdevices, each with 16 channels. These
    subdevices use hardware registers that are spaced 0x10 bytes apart
    for each "group" of 16 channels.
    
    Create new macros to get the correct addresses for each register
    based on the dio "group". Use the s->private (void *) to hold the
    "group" number to use in the subdevice functions.
    
    This allows removing struct dio_private and all its uses. It also
    removes the ugly casts used to get the register address.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 7d009463b92d..104594bca254 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -106,64 +106,6 @@ struct s626_private {
 	unsigned int ao_readback[S626_DAC_CHANNELS];
 };
 
-struct dio_private {
-	uint16_t RDDIn;
-	uint16_t WRDOut;
-	uint16_t RDEdgSel;
-	uint16_t WREdgSel;
-	uint16_t RDCapSel;
-	uint16_t WRCapSel;
-	uint16_t RDCapFlg;
-	uint16_t RDIntSel;
-	uint16_t WRIntSel;
-};
-
-static struct dio_private dio_private_A = {
-	.RDDIn = LP_RDDINA,
-	.WRDOut = LP_WRDOUTA,
-	.RDEdgSel = LP_RDEDGSELA,
-	.WREdgSel = LP_WREDGSELA,
-	.RDCapSel = LP_RDCAPSELA,
-	.WRCapSel = LP_WRCAPSELA,
-	.RDCapFlg = LP_RDCAPFLGA,
-	.RDIntSel = LP_RDINTSELA,
-	.WRIntSel = LP_WRINTSELA,
-};
-
-static struct dio_private dio_private_B = {
-	.RDDIn = LP_RDDINB,
-	.WRDOut = LP_WRDOUTB,
-	.RDEdgSel = LP_RDEDGSELB,
-	.WREdgSel = LP_WREDGSELB,
-	.RDCapSel = LP_RDCAPSELB,
-	.WRCapSel = LP_WRCAPSELB,
-	.RDCapFlg = LP_RDCAPFLGB,
-	.RDIntSel = LP_RDINTSELB,
-	.WRIntSel = LP_WRINTSELB,
-};
-
-static struct dio_private dio_private_C = {
-	.RDDIn = LP_RDDINC,
-	.WRDOut = LP_WRDOUTC,
-	.RDEdgSel = LP_RDEDGSELC,
-	.WREdgSel = LP_WREDGSELC,
-	.RDCapSel = LP_RDCAPSELC,
-	.WRCapSel = LP_WRCAPSELC,
-	.RDCapFlg = LP_RDCAPFLGC,
-	.RDIntSel = LP_RDINTSELC,
-	.WRIntSel = LP_WRINTSELC,
-};
-
-/* to group dio devices (48 bits mask and data are not allowed ???)
-static struct dio_private *dio_private_word[]={
-  &dio_private_A,
-  &dio_private_B,
-  &dio_private_C,
-};
-*/
-
-#define diopriv ((struct dio_private *)s->private)
-
 /*  COUNTER OBJECT ------------------------------------------------ */
 struct enc_private {
 	/*  Pointers to functions that differ for A and B counters: */
@@ -670,43 +612,24 @@ static unsigned int s626_ai_reg_to_uint(int data)
 
 static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
 {
-	unsigned int group;
-	unsigned int bitmask;
+	unsigned int group = chan / 16;
+	unsigned int mask = 1 << (chan - (16 * group));
 	unsigned int status;
 
-	/* select dio bank */
-	group = chan / 16;
-	bitmask = 1 << (chan - (16 * group));
-
 	/* set channel to capture positive edge */
-	status = DEBIread(dev,
-			  ((struct dio_private *)(dev->subdevices + 2 +
-						  group)->private)->RDEdgSel);
-	DEBIwrite(dev,
-		  ((struct dio_private *)(dev->subdevices + 2 +
-					  group)->private)->WREdgSel,
-		  bitmask | status);
+	status = DEBIread(dev, LP_RDEDGSEL(group));
+	DEBIwrite(dev, LP_WREDGSEL(group), mask | status);
 
 	/* enable interrupt on selected channel */
-	status = DEBIread(dev,
-			  ((struct dio_private *)(dev->subdevices + 2 +
-						  group)->private)->RDIntSel);
-	DEBIwrite(dev,
-		  ((struct dio_private *)(dev->subdevices + 2 +
-					  group)->private)->WRIntSel,
-		  bitmask | status);
+	status = DEBIread(dev, LP_RDINTSEL(group));
+	DEBIwrite(dev, LP_WRINTSEL(group), mask | status);
 
 	/* enable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_EDCAP);
 
 	/* enable edge capture on selected channel */
-	status = DEBIread(dev,
-			  ((struct dio_private *)(dev->subdevices + 2 +
-						  group)->private)->RDCapSel);
-	DEBIwrite(dev,
-		  ((struct dio_private *)(dev->subdevices + 2 +
-					  group)->private)->WRCapSel,
-		  bitmask | status);
+	status = DEBIread(dev, LP_RDCAPSEL(group));
+	DEBIwrite(dev, LP_WRCAPSEL(group), mask | status);
 
 	return 0;
 }
@@ -718,9 +641,7 @@ static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
 	/* enable edge capture on selected channel */
-	DEBIwrite(dev,
-		  ((struct dio_private *)(dev->subdevices + 2 +
-					  group)->private)->WRCapSel, mask);
+	DEBIwrite(dev, LP_WRCAPSEL(group), mask);
 
 	return 0;
 }
@@ -732,13 +653,9 @@ static int s626_dio_clear_irq(struct comedi_device *dev)
 	/* disable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
-	for (group = 0; group < S626_DIO_BANKS; group++) {
-		/* clear pending events and interrupt */
-		DEBIwrite(dev,
-			  ((struct dio_private *)(dev->subdevices + 2 +
-						  group)->private)->WRCapSel,
-			  0xffff);
-	}
+	/* clear all dio pending events and interrupt */
+	for (group = 0; group < S626_DIO_BANKS; group++)
+		DEBIwrite(dev, LP_WRCAPSEL(group), 0xffff);
 
 	return 0;
 }
@@ -834,12 +751,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 		for (group = 0; group < S626_DIO_BANKS; group++) {
 			irqbit = 0;
 			/* read interrupt type */
-			irqbit = DEBIread(dev,
-					  ((struct dio_private *)(dev->
-								  subdevices +
-								  2 +
-								  group)->
-					   private)->RDCapFlg);
+			irqbit = DEBIread(dev, LP_RDCAPFLG(group));
 
 			/* check if interrupt is generated from dio channels */
 			if (irqbit) {
@@ -1679,22 +1591,20 @@ static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 static void s626_dio_init(struct comedi_device *dev)
 {
 	uint16_t group;
-	struct comedi_subdevice *s;
 
 	/*  Prepare to treat writes to WRCapSel as capture disables. */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
 	/*  For each group of sixteen channels ... */
 	for (group = 0; group < S626_DIO_BANKS; group++) {
-		s = dev->subdevices + 2 + group;
-		DEBIwrite(dev, diopriv->WRIntSel, 0);	/*  Disable all interrupts. */
-		DEBIwrite(dev, diopriv->WRCapSel, 0xFFFF);	/*  Disable all event */
-		/*  captures. */
-		DEBIwrite(dev, diopriv->WREdgSel, 0);	/*  Init all DIOs to */
-		/*  default edge */
-		/*  polarity. */
-		DEBIwrite(dev, diopriv->WRDOut, 0);	/*  Program all outputs */
-		/*  to inactive state. */
+		/* Disable all interrupts */
+		DEBIwrite(dev, LP_WRINTSEL(group), 0);
+		/* Disable all event captures */
+		DEBIwrite(dev, LP_WRCAPSEL(group), 0xffff);
+		/* Init all DIOs to default edge polarity */
+		DEBIwrite(dev, LP_WREDGSEL(group), 0);
+		/* Program all outputs to inactive state */
+		DEBIwrite(dev, LP_WRDOUT(group), 0);
 	}
 }
 
@@ -1708,6 +1618,8 @@ static int s626_dio_insn_bits(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
+	unsigned long group = (unsigned long)s->private;
+
 	/*
 	 * The insn data consists of a mask in data[0] and the new data in
 	 * data[1]. The mask defines which bits we are concerning about.
@@ -1724,9 +1636,9 @@ static int s626_dio_insn_bits(struct comedi_device *dev,
 
 		/* Write out the new digital output lines */
 
-		DEBIwrite(dev, diopriv->WRDOut, s->state);
+		DEBIwrite(dev, LP_WRDOUT(group), s->state);
 	}
-	data[1] = DEBIread(dev, diopriv->RDDIn);
+	data[1] = DEBIread(dev, LP_RDDIN(group));
 
 	return insn->n;
 }
@@ -1735,6 +1647,7 @@ static int s626_dio_insn_config(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
+	unsigned long group = (unsigned long)s->private;
 
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_QUERY:
@@ -1754,7 +1667,7 @@ static int s626_dio_insn_config(struct comedi_device *dev,
 		return -EINVAL;
 		break;
 	}
-	DEBIwrite(dev, diopriv->WRDOut, s->io_bits);
+	DEBIwrite(dev, LP_WRDOUT(group), s->io_bits);
 
 	return 1;
 }
@@ -2739,7 +2652,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->n_chan = 16;
 	s->maxdata = 1;
 	s->io_bits = 0xffff;
-	s->private = &dio_private_A;
+	s->private = (void *)0;		/* DIO group 0 */
 	s->range_table = &range_digital;
 	s->insn_config = s626_dio_insn_config;
 	s->insn_bits = s626_dio_insn_bits;
@@ -2751,7 +2664,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->n_chan = 16;
 	s->maxdata = 1;
 	s->io_bits = 0xffff;
-	s->private = &dio_private_B;
+	s->private = (void *)1;		/* DIO group 1 */
 	s->range_table = &range_digital;
 	s->insn_config = s626_dio_insn_config;
 	s->insn_bits = s626_dio_insn_bits;
@@ -2763,7 +2676,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 	s->n_chan = 16;
 	s->maxdata = 1;
 	s->io_bits = 0xffff;
-	s->private = &dio_private_C;
+	s->private = (void *)2;		/* DIO group 2 */
 	s->range_table = &range_digital;
 	s->insn_config = s626_dio_insn_config;
 	s->insn_bits = s626_dio_insn_bits;

commit e4317ce877a31dbb9d96375391c1c4ad2210d637
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 22 15:16:29 2013 +0000

    staging: comedi: s626: fix continuous acquisition
    
    For the s626 driver, there is a bug in the handling of asynchronous
    commands on the AI subdevice when the stop source is `TRIG_NONE`.  The
    command should run continuously until cancelled, but the interrupt
    handler stops the command running after the first scan.
    
    The command set-up function `s626_ai_cmd()` contains this code:
    
            switch (cmd->stop_src) {
            case TRIG_COUNT:
                    /*  data arrives as one packet */
                    devpriv->ai_sample_count = cmd->stop_arg;
                    devpriv->ai_continous = 0;
                    break;
            case TRIG_NONE:
                    /*  continous acquisition */
                    devpriv->ai_continous = 1;
                    devpriv->ai_sample_count = 0;
                    break;
            }
    
    The interrupt handler `s626_irq_handler()` contains this code:
    
                    if (!(devpriv->ai_continous))
                            devpriv->ai_sample_count--;
                    if (devpriv->ai_sample_count <= 0) {
                            devpriv->ai_cmd_running = 0;
                            /* ... */
                    }
    
    So `devpriv->ai_sample_count` is only decremented for the `TRIG_COUNT`
    case, but `devpriv->ai_cmd_running` is set to 0 (and the command
    stopped) regardless.
    
    Fix this in `s626_ai_cmd()` by setting `devpriv->ai_sample_count = 1`
    for the `TRIG_NONE` case.  The interrupt handler will not decrement it
    so it will remain greater than 0 and the check for stopping the
    acquisition will fail.
    
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 81a1fe661579..71a73ec5af8d 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1483,7 +1483,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	case TRIG_NONE:
 		/*  continous acquisition */
 		devpriv->ai_continous = 1;
-		devpriv->ai_sample_count = 0;
+		devpriv->ai_sample_count = 1;
 		break;
 	}
 

commit 84b44d08993ffe762d9a86ee2243239350b871a4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:36 2013 +0000

    staging: comedi: remove unneeded settings of `dev->iobase`
    
    Some PCI drivers use the "spare" `iobase` member of `struct
    comedi_device` as a flag to indicate that the call to
    `comedi_pci_enable()` was successful.  This is no longer necessary now
    that `comedi_pci_enable()` and `comedi_pci_disable()` use the
    `ioenabled` member of `struct comedi_device` themselves to keep track of
    what needs to be done.
    
    Remove the unnecessary assignments to the `iobase` member in the
    relevant drivers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index d1560524fc14..7d009463b92d 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2676,7 +2676,6 @@ static int s626_auto_attach(struct comedi_device *dev,
 	ret = comedi_pci_enable(dev);
 	if (ret)
 		return ret;
-	dev->iobase = 1;	/* detach needs this */
 
 	devpriv->base_addr = ioremap(pci_resource_start(pcidev, 0),
 				     pci_resource_len(pcidev, 0));

commit a7401cddcdf739d3cb9598c9b3787a732fc87809
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:33 2013 +0000

    staging: comedi: make 'dev->attached' a bool bit-field
    
    Change the `attached` member of `struct comedi_device` to a 1-bit
    bit-field of type `bool`.  Change assigned values to `true` and `false`
    and replace or remove comparison operations with simple boolean tests.
    
    We'll put some extra bit-fields in the gap later to save space.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index cd164ee3a5e1..d1560524fc14 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -758,7 +758,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	uint8_t group;
 	uint16_t irqbit;
 
-	if (dev->attached == 0)
+	if (!dev->attached)
 		return IRQ_NONE;
 	/*  lock to avoid race with comedi_poll */
 	spin_lock_irqsave(&dev->spinlock, flags);

commit 818f569fe930c5b8a05d1a44ece3c63c99c13c88
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:36:31 2013 -0700

    staging: comedi_pci: pass comedi_device to comedi_pci_enable()
    
    Make comedi_pci_enable() use the same parameter type as
    comedi_pci_disable(). This also allows comedi_pci_enable
    to automatically determine the resource name passed to
    pci_request_regions().
    
    Make sure the errno value returned is passed on instead of
    assuming an errno. Also, remove any kernel noise that is
    generated when the call fails.
    
    The National Instruments drivers that use the mite module
    currently enable the PCI device in the mite module. For
    those drivers move the call to comedi_pci_enable into the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 92338791f4a2..cd164ee3a5e1 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2673,7 +2673,7 @@ static int s626_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	ret = comedi_pci_enable(pcidev, dev->board_name);
+	ret = comedi_pci_enable(dev);
 	if (ret)
 		return ret;
 	dev->iobase = 1;	/* detach needs this */

commit 7f072f54ae5dc9965cbe450419b1389d13e2b849
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:35:51 2013 -0700

    staging: comedi_pci: make comedi_pci_disable() safe to call
    
    Currently all the comedi PCI drivers need to do some checking in
    their (*detach) before calling comedi_pci_disable() in order to
    make sure the PCI device has actually be enabled.
    
    Change the parameter passed to comedi_pci_disable() from a struct
    pci_dev pointer to a comedi_device pointer and have comedi_pci_disable()
    handle all the checking.
    
    For most comedi PCI drivers this also allows removing the local
    variable holding the pointer to the pci_dev. For some of the drivers
    comedi_pci_disable can now be used directly as the (*detach) function.
    
    The National Instruments drivers that use the mite module currently
    enable/disable the PCI device in the mite module. For those drivers
    move the call to comedi_pci_disable into the driver and make sure
    dev->iobase is set to a non-zero value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4fec6d6a04ab..92338791f4a2 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2790,7 +2790,6 @@ static int s626_auto_attach(struct comedi_device *dev,
 
 static void s626_detach(struct comedi_device *dev)
 {
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct s626_private *devpriv = dev->private;
 
 	if (devpriv) {
@@ -2818,10 +2817,7 @@ static void s626_detach(struct comedi_device *dev)
 		if (devpriv->base_addr)
 			iounmap(devpriv->base_addr);
 	}
-	if (pcidev) {
-		if (dev->iobase)
-			comedi_pci_disable(pcidev);
-	}
+	comedi_pci_disable(dev);
 }
 
 static struct comedi_driver s626_driver = {

commit b8f4ac237e382accd4b30c75043939f7ed9e79a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 09:53:41 2013 -0700

    staging: comedi: comedi_pci: change the comedi_pci_auto_config() 'context'
    
    The comedi_pci_auto_config() function is used to allow the PCI driver
    (*probe) function to automatically call the comedi driver (*auto_attach).
    This allows the comedi driver to be part of the PnP process when the
    PCI device is detected.
    
    Currently the comedi_pci_auto_config() always passes a 'context' of '0'
    to comedi_auto_config(). This makes the 'context' a bit useless.
    
    Modify comedi_pci_auto_config() to allow the comedi pci drivers to pass
    a 'context' from the PCI driver.
    
    Make all the comedi pci drivers pass the pci_device_id 'driver_data' as
    the 'context'. Since none of the comedi pci drivers currently set the
    'driver_data' the 'context' will still be '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 81a1fe661579..4fec6d6a04ab 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2832,9 +2832,9 @@ static struct comedi_driver s626_driver = {
 };
 
 static int s626_pci_probe(struct pci_dev *dev,
-				    const struct pci_device_id *ent)
+			  const struct pci_device_id *id)
 {
-	return comedi_pci_auto_config(dev, &s626_driver);
+	return comedi_pci_auto_config(dev, &s626_driver, id->driver_data);
 }
 
 /*

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 0c7221c6dfea..81a1fe661579 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -64,6 +64,7 @@ INSN_CONFIG instructions:
    comedi_do_insn(cf,&insn); //executing configuration
 */
 
+#include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/types.h>

commit 9901a4d75d007686e8f6473189cafc4b216b7449
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Tue Jan 22 23:40:03 2013 +0100

    staging/comedi: Use comedi_pci_auto_unconfig directly for pci_driver.remove
    
    (Almost) all comedi pci drivers have some wrapper for their
    pci_driver.remove function which simply calls comedi_pci_auto_unconfig
    which has the same function prototype as the wrapper.
    
    -> we can remove these wrappers and call comedi_pci_auto_unconfig
    directly. This removes a lot some boilerplate code and saves some bytes.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6dc1d2812865..0c7221c6dfea 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2836,11 +2836,6 @@ static int s626_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &s626_driver);
 }
 
-static void s626_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
 /*
  * For devices with vendor:device id == 0x1131:0x7146 you must specify
  * also subvendor:subdevice ids, because otherwise it will conflict with
@@ -2857,7 +2852,7 @@ static struct pci_driver s626_pci_driver = {
 	.name		= "s626",
 	.id_table	= s626_pci_table,
 	.probe		= s626_pci_probe,
-	.remove		= s626_pci_remove,
+	.remove		= comedi_pci_auto_unconfig,
 };
 module_comedi_pci_driver(s626_driver, s626_pci_driver);
 

commit 53b800198592b0ff96577ecc5f116f7d902a4362
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:36 2012 -0500

    staging: comedi: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 18f3b18a8c5b..6dc1d2812865 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2836,7 +2836,7 @@ static int s626_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &s626_driver);
 }
 
-static void __devexit s626_pci_remove(struct pci_dev *dev)
+static void s626_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }

commit a690b7e535f2f97a3a05ee570715abeb60a8910f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:58 2012 -0500

    staging: comedi: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 30686e2b8a71..18f3b18a8c5b 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2657,7 +2657,7 @@ static void s626_initialize(struct comedi_device *dev)
 	/* writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->base_addr + P_IER); */
 }
 
-static int __devinit s626_auto_attach(struct comedi_device *dev,
+static int s626_auto_attach(struct comedi_device *dev,
 				      unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
@@ -2830,7 +2830,7 @@ static struct comedi_driver s626_driver = {
 	.detach		= s626_detach,
 };
 
-static int __devinit s626_pci_probe(struct pci_dev *dev,
+static int s626_pci_probe(struct pci_dev *dev,
 				    const struct pci_device_id *ent)
 {
 	return comedi_pci_auto_config(dev, &s626_driver);

commit a471eace7baa40cdf16d3f26b2f78ddce613ca8f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:37 2012 -0500

    staging: comedi: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index e32b54f4bfc2..30686e2b8a71 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2857,7 +2857,7 @@ static struct pci_driver s626_pci_driver = {
 	.name		= "s626",
 	.id_table	= s626_pci_table,
 	.probe		= s626_pci_probe,
-	.remove		= __devexit_p(s626_pci_remove),
+	.remove		= s626_pci_remove,
 };
 module_comedi_pci_driver(s626_driver, s626_pci_driver);
 

commit 53a254b92cad920941cf8225dbe805bf9b57ca11
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:59:18 2012 -0700

    staging: comedi: s626: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of s626_ai_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 686ee0e8713a..e32b54f4bfc2 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1549,80 +1549,46 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 
 	/* step 3: make sure arguments are trivially compatible */
 
-	if (cmd->start_src != TRIG_EXT && cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
+	if (cmd->start_src != TRIG_EXT)
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	if (cmd->start_src == TRIG_EXT)
+		err |= cfc_check_trigger_arg_max(&cmd->start_arg, 39);
 
-	if (cmd->start_src == TRIG_EXT && cmd->start_arg > 39) {
-		cmd->start_arg = 39;
-		err++;
-	}
+	if (cmd->scan_begin_src == TRIG_EXT)
+		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 39);
 
-	if (cmd->scan_begin_src == TRIG_EXT && cmd->scan_begin_arg > 39) {
-		cmd->scan_begin_arg = 39;
-		err++;
-	}
+	if (cmd->convert_src == TRIG_EXT)
+		err |= cfc_check_trigger_arg_max(&cmd->convert_arg, 39);
 
-	if (cmd->convert_src == TRIG_EXT && cmd->convert_arg > 39) {
-		cmd->convert_arg = 39;
-		err++;
-	}
 #define MAX_SPEED	200000	/* in nanoseconds */
 #define MIN_SPEED	2000000000	/* in nanoseconds */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		if (cmd->scan_begin_arg < MAX_SPEED) {
-			cmd->scan_begin_arg = MAX_SPEED;
-			err++;
-		}
-		if (cmd->scan_begin_arg > MIN_SPEED) {
-			cmd->scan_begin_arg = MIN_SPEED;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+						 MAX_SPEED);
+		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
+						 MIN_SPEED);
 	} else {
 		/* external trigger */
 		/* should be level/edge, hi/lo specification here */
 		/* should specify multiple external triggers */
-/*     if(cmd->scan_begin_arg>9){ */
-/*       cmd->scan_begin_arg=9; */
-/*       err++; */
-/*     } */
+/*		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 9); */
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < MAX_SPEED) {
-			cmd->convert_arg = MAX_SPEED;
-			err++;
-		}
-		if (cmd->convert_arg > MIN_SPEED) {
-			cmd->convert_arg = MIN_SPEED;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg, MAX_SPEED);
+		err |= cfc_check_trigger_arg_max(&cmd->convert_arg, MIN_SPEED);
 	} else {
 		/* external trigger */
 		/* see above */
-/*     if(cmd->convert_arg>9){ */
-/*       cmd->convert_arg=9; */
-/*       err++; */
-/*     } */
+/*		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 9); */
 	}
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-	if (cmd->stop_src == TRIG_COUNT) {
-		if (cmd->stop_arg > 0x00ffffff) {
-			cmd->stop_arg = 0x00ffffff;
-			err++;
-		}
-	} else {
-		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);
+	else	/* TRIG_NONE */
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit 750af5e568d060ec6994cdcb4e86cdddfcd473c0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 30 13:30:04 2012 +0000

    staging: comedi/drivers: use auto_attach instead of attach_pci
    
    Change comedi drivers for PCI boards to use the new `auto_attach()`
    method instead of the `attach_pci()` method.  I plan to remove the
    `attach_pci()` and `attach_usb()` methods from `struct comedi_driver`
    once nothing is using them.
    
    Tag the functions with `__devinit` where they are not already so tagged,
    as they are only called during PCI probe.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 15755325121d..686ee0e8713a 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2691,8 +2691,10 @@ static void s626_initialize(struct comedi_device *dev)
 	/* writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->base_addr + P_IER); */
 }
 
-static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
+static int __devinit s626_auto_attach(struct comedi_device *dev,
+				      unsigned long context_unused)
 {
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct s626_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
@@ -2858,7 +2860,7 @@ static void s626_detach(struct comedi_device *dev)
 static struct comedi_driver s626_driver = {
 	.driver_name	= "s626",
 	.module		= THIS_MODULE,
-	.attach_pci	= s626_attach_pci,
+	.auto_attach	= s626_auto_attach,
 	.detach		= s626_detach,
 };
 

commit 7fc465b106b40a598d83a0c98d0e8c2a1b4653ff
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:43:11 2012 -0700

    staging: comedi: auto-config drivers do not need to set hw_dev
    
    The comedi core now sets the 'hw_dev' pointer in the function
    comedi_auto_config_helper() before calling the auto attach
    function in the driver.
    
    Remove the now unnecessary call to comedi_set_hw_dev() in the
    drivers that use the auto-config attach mechanism.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 7c50b01f6a6f..15755325121d 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2697,7 +2697,6 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 	struct comedi_subdevice *s;
 	int ret;
 
-	comedi_set_hw_dev(dev, &pcidev->dev);
 	dev->board_name = dev->driver->driver_name;
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 511183da0eec..7c50b01f6a6f 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2700,10 +2700,10 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 	comedi_set_hw_dev(dev, &pcidev->dev);
 	dev->board_name = dev->driver->driver_name;
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	ret = comedi_pci_enable(pcidev, dev->board_name);
 	if (ret)

commit 7f2f7e050bea242735880b7876d9771efb580213
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:16:38 2012 -0700

    staging: comedi: s626: remove devpriv macro
    
    Missed one... This macro relies on a local variable having
    a specific name. Remove its use by replacing it with a local
    variable where used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 551d68b7837c..511183da0eec 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -161,7 +161,6 @@ static struct dio_private *dio_private_word[]={
 };
 */
 
-#define devpriv ((struct s626_private *)dev->private)
 #define diopriv ((struct dio_private *)s->private)
 
 /*  COUNTER OBJECT ------------------------------------------------ */
@@ -232,6 +231,8 @@ static const struct comedi_lrange s626_range_table = { 2, {
 /*  critical section. */
 static void DEBItransfer(struct comedi_device *dev)
 {
+	struct s626_private *devpriv = dev->private;
+
 	/*  Initiate upload of shadow RAM to DEBI control register. */
 	MC_ENABLE(P_MC2, MC2_UPLD_DEBI);
 
@@ -249,6 +250,7 @@ static void DEBItransfer(struct comedi_device *dev)
 
 static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
 {
+	struct s626_private *devpriv = dev->private;
 	uint16_t retval;
 
 	/*  Set up DEBI control register value in shadow RAM. */
@@ -267,6 +269,7 @@ static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
 /*  Write a value to a gate array register. */
 static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
 {
+	struct s626_private *devpriv = dev->private;
 
 	/*  Set up DEBI control register value in shadow RAM. */
 	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
@@ -283,6 +286,7 @@ static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
 static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
 			uint16_t wdata)
 {
+	struct s626_private *devpriv = dev->private;
 
 	/*  Copy target gate array register into P_DEBIAD register. */
 	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
@@ -302,6 +306,8 @@ static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
 
 static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 {
+	struct s626_private *devpriv = dev->private;
+
 	/*  Write I2C command to I2C Transfer Control shadow register. */
 	WR7146(P_I2CCTRL, val);
 
@@ -324,6 +330,7 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 /*  Read uint8_t from EEPROM. */
 static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 {
+	struct s626_private *devpriv = dev->private;
 	uint8_t rtnval;
 
 	/*  Send EEPROM target address. */
@@ -375,6 +382,7 @@ static uint8_t trimadrs[] = { 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x
  */
 static void SendDAC(struct comedi_device *dev, uint32_t val)
 {
+	struct s626_private *devpriv = dev->private;
 
 	/* START THE SERIAL CLOCK RUNNING ------------- */
 
@@ -496,6 +504,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 /*  Private helper function: Write setpoint to an application DAC channel. */
 static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
 {
+	struct s626_private *devpriv = dev->private;
 	register uint16_t signmask;
 	register uint32_t WSImage;
 
@@ -553,6 +562,7 @@ static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
 static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
 			 uint8_t DacData)
 {
+	struct s626_private *devpriv = dev->private;
 	uint32_t chan;
 
 	/*  Save the new setpoint in case the application needs to read it back later. */
@@ -735,6 +745,7 @@ static int s626_dio_clear_irq(struct comedi_device *dev)
 static irqreturn_t s626_irq_handler(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct s626_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	struct comedi_cmd *cmd;
 	struct enc_private *k;
@@ -968,6 +979,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
  */
 static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 {
+	struct s626_private *devpriv = dev->private;
 	register uint32_t *pRPS;
 	uint32_t JmpAdrs;
 	uint16_t i;
@@ -1163,6 +1175,7 @@ static int s626_ai_insn_config(struct comedi_device *dev,
 
 /* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data) */
 /* { */
+/*   struct s626_private *devpriv = dev->private; */
 /*   register uint8_t	i; */
 /*   register int32_t	*readaddr; */
 
@@ -1191,6 +1204,7 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
+	struct s626_private *devpriv = dev->private;
 	uint16_t chan = CR_CHAN(insn->chanspec);
 	uint16_t range = CR_RANGE(insn->chanspec);
 	uint16_t AdcSpec = 0;
@@ -1302,6 +1316,8 @@ static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)
 static int s626_ai_inttrig(struct comedi_device *dev,
 			   struct comedi_subdevice *s, unsigned int trignum)
 {
+	struct s626_private *devpriv = dev->private;
+
 	if (trignum != 0)
 		return -EINVAL;
 
@@ -1378,7 +1394,7 @@ static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 /*  TO COMPLETE  */
 static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-
+	struct s626_private *devpriv = dev->private;
 	uint8_t ppl[16];
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct enc_private *k;
@@ -1643,6 +1659,8 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 
 static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct s626_private *devpriv = dev->private;
+
 	/*  Stop RPS program in case it is currently running. */
 	MC_DISABLE(P_MC1, MC1_ERPS1);
 
@@ -1657,7 +1675,7 @@ static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_insn *insn, unsigned int *data)
 {
-
+	struct s626_private *devpriv = dev->private;
 	int i;
 	uint16_t chan = CR_CHAN(insn->chanspec);
 	int16_t dacdata;
@@ -1676,6 +1694,7 @@ static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_insn *insn, unsigned int *data)
 {
+	struct s626_private *devpriv = dev->private;
 	int i;
 
 	for (i = 0; i < insn->n; i++)
@@ -1974,6 +1993,7 @@ static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k)
 static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
 		      uint16_t Setup, uint16_t DisableIntSrc)
 {
+	struct s626_private *devpriv = dev->private;
 	register uint16_t cra;
 	register uint16_t crb;
 	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
@@ -2032,6 +2052,7 @@ static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
 static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
 		      uint16_t Setup, uint16_t DisableIntSrc)
 {
+	struct s626_private *devpriv = dev->private;
 	register uint16_t cra;
 	register uint16_t crb;
 	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
@@ -2165,6 +2186,8 @@ static uint16_t GetLoadTrig_B(struct comedi_device *dev, struct enc_private *k)
 static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
 			uint16_t IntSource)
 {
+	struct s626_private *devpriv = dev->private;
+
 	/*  Reset any pending counter overflow or index captures. */
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
 		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
@@ -2182,6 +2205,7 @@ static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
 static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
 			uint16_t IntSource)
 {
+	struct s626_private *devpriv = dev->private;
 	uint16_t crb;
 
 	/*  Cache writeable CRB register image. */
@@ -2412,6 +2436,7 @@ static void CountersInit(struct comedi_device *dev)
 static int s626_allocate_dma_buffers(struct comedi_device *dev)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct s626_private *devpriv = dev->private;
 	void *addr;
 	dma_addr_t appdma;
 
@@ -2432,6 +2457,7 @@ static int s626_allocate_dma_buffers(struct comedi_device *dev)
 
 static void s626_initialize(struct comedi_device *dev)
 {
+	struct s626_private *devpriv = dev->private;
 	dma_addr_t pPhysBuf;
 	uint16_t chan;
 	int i;
@@ -2667,14 +2693,17 @@ static void s626_initialize(struct comedi_device *dev)
 
 static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 {
+	struct s626_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
 
 	comedi_set_hw_dev(dev, &pcidev->dev);
 	dev->board_name = dev->driver->driver_name;
 
-	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
-		return -ENOMEM;
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
+		return ret;
+	devpriv = dev->private;
 
 	ret = comedi_pci_enable(pcidev, dev->board_name);
 	if (ret)
@@ -2794,6 +2823,7 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 static void s626_detach(struct comedi_device *dev)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct s626_private *devpriv = dev->private;
 
 	if (devpriv) {
 		/* stop ai_command */

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 24878c815fd7..551d68b7837c 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1505,56 +1505,28 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 	int err = 0;
 	int tmp;
 
-	/* cmdtest tests a particular command to see if it is valid.  Using
-	 * the cmdtest ioctl, a user can create a valid cmd and then have it
-	 * executes by the cmd ioctl.
-	 *
-	 * cmdtest returns 1,2,3,4 or 0, depending on which tests the
-	 * command passes. */
-
-	/* step 1: make sure trigger sources are trivially valid */
-
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_INT | TRIG_EXT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_TIMER | TRIG_EXT | TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src,
+					TRIG_NOW | TRIG_INT | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW);
+	err |= cfc_check_trigger_src(&cmd->convert_src,
+					TRIG_TIMER | TRIG_EXT | TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually
-	   compatible */
+	/* Step 2a : make sure trigger sources are unique */
 
-	/* note that mutual compatibility is not an issue here */
-	if (cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_EXT
-	    && cmd->scan_begin_src != TRIG_FOLLOW)
-		err++;
-	if (cmd->convert_src != TRIG_TIMER &&
-	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit affdc230d7d328d2b602113e459a57d9de5ded08
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 24 17:20:53 2012 +0100

    staging: comedi: s626: add FIXME comment
    
    `s626_enc_insn_config()` is the `insn_config()` handler for a counter
    subdevice.  The `data[0]` value is supposed to be one of the
    `INSN_CONFIG_...` constants defined in "comedi.h" indicating the type of
    configuration instruction, but this function seems to be using it as a
    variable value to preload the counter with.  Various values of `data[0]`
    are going to cause `check_insn_config_length()` in the comedi core
    ("comedi_fops.c") to return an error, and this function won't be called
    in those cases.  Most other values will log a warning to the kernel log.
    
    It's not entirely clear what constant should be checked for in
    `data[0]`, so add a "FIXME" comment for now.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 430e26b9e344..24878c815fd7 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1804,6 +1804,9 @@ static int s626_dio_insn_config(struct comedi_device *dev,
 /* Now this function initializes the value of the counter (data[0])
    and set the subdevice. To complete with trigger and interrupt
    configuration */
+/* FIXME: data[0] is supposed to be an INSN_CONFIG_xxx constant indicating
+ * what is being configured, but this function appears to be using data[0]
+ * as a variable. */
 static int s626_enc_insn_config(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)

commit b655c2c4782ed3e2e71d2608154e295a3e860311
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 24 17:20:52 2012 +0100

    staging: comedi: s626: don't dereference insn->data
    
    `s626_enc_insn_config()` is incorrectly dereferencing `insn->data` which
    is a pointer to user memory.  It should be dereferencing the separate
    `data` parameter that points to a copy of the data in kernel memory.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index e1d10f366c2f..430e26b9e344 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1825,7 +1825,7 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 	/*   (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
 	k->SetMode(dev, k, Setup, TRUE);
-	Preload(dev, k, *(insn->data));
+	Preload(dev, k, data[0]);
 	k->PulseIndex(dev, k);
 	SetLatchSource(dev, k, valueSrclatch);
 	k->SetEnable(dev, k, (uint16_t) (enab != 0));

commit 54a2a02ea51f606ba37f800c5e5eebb049ca6fb8
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:39:14 2012 -0700

    staging: comedi: s626: cleanup comments in s626_initialize()
    
    Cleanup the comments to follow the coding style of the kernel.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6f1705ba60e2..e1d10f366c2f 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2461,83 +2461,80 @@ static void s626_initialize(struct comedi_device *dev)
 	uint16_t chan;
 	int i;
 
-	/*  enab DEBI and audio pins, enable I2C interface. */
+	/* Enable DEBI and audio pins, enable I2C interface */
 	MC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);
-	/*  Configure DEBI operating mode. */
-	WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	/*  Local bus is 16 */
-	       /*  bits wide. */
-	       | (DEBI_TOUT << DEBI_CFG_TOUT_BIT)
-
-	       /*  Declare DEBI */
-	       /*  transfer timeout */
-	       /*  interval. */
-	       |DEBI_SWAP	/*  Set up byte lane */
-	       /*  steering. */
-	       | DEBI_CFG_INTEL);	/*  Intel-compatible */
-	/*  local bus (DEBI */
-	/*  never times out). */
-
-	/* DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ */
-	/* | DEBI_CFG_INCQ| DEBI_CFG_16Q); //end */
-
-	/*  Paging is disabled. */
-	WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);	/*  Disable MMU paging. */
-
-	/*  Init GPIO so that ADC Start* is negated. */
+
+	/*
+	 *  Configure DEBI operating mode
+	 *
+	 *   Local bus is 16 bits wide
+	 *   Declare DEBI transfer timeout interval
+	 *   Set up byte lane steering
+	 *   Intel-compatible local bus (DEBI never times out)
+	 */
+	WR7146(P_DEBICFG, DEBI_CFG_SLAVE16 |
+			  (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
+			  DEBI_SWAP | DEBI_CFG_INTEL);
+
+	/* Disable MMU paging */
+	WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);
+
+	/* Init GPIO so that ADC Start* is negated */
 	WR7146(P_GPIO, GPIO_BASE | GPIO1_HI);
 
 	/* I2C device address for onboard eeprom (revb) */
 	devpriv->I2CAdrs = 0xA0;
 
-	/*  Issue an I2C ABORT command to halt any I2C operation in */
-	/* progress and reset BUSY flag. */
+	/*
+	 * Issue an I2C ABORT command to halt any I2C
+	 * operation in progress and reset BUSY flag.
+	 */
 	WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);
-	/*  Write I2C control: abort any I2C activity. */
 	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
-	/*  Invoke command  upload */
 	while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)
 		;
-	/*  and wait for upload to complete. */
 
-	/* Per SAA7146 data sheet, write to STATUS reg twice to
-	 * reset all  I2C error flags. */
+	/*
+	 * Per SAA7146 data sheet, write to STATUS
+	 * reg twice to reset all  I2C error flags.
+	 */
 	for (i = 0; i < 2; i++) {
 		WR7146(P_I2CSTAT, I2C_CLKSEL);
-		/*  Write I2C control: reset  error flags. */
-		MC_ENABLE(P_MC2, MC2_UPLD_IIC);	/*  Invoke command upload */
+		MC_ENABLE(P_MC2, MC2_UPLD_IIC);
 		while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
 			;
-		/* and wait for upload to complete. */
 	}
 
-	/* Init audio interface functional attributes: set DAC/ADC
+	/*
+	 * Init audio interface functional attributes: set DAC/ADC
 	 * serial clock rates, invert DAC serial clock so that
 	 * DAC data setup times are satisfied, enable DAC serial
 	 * clock out.
 	 */
-
 	WR7146(P_ACON2, ACON2_INIT);
 
-	/* Set up TSL1 slot list, which is used to control the
+	/*
+	 * Set up TSL1 slot list, which is used to control the
 	 * accumulation of ADC data: RSD1 = shift data in on SD1.
-	 * SIB_A1  = store data uint8_t at next available location in
-	 * FB BUFFER1  register. */
+	 * SIB_A1  = store data uint8_t at next available location
+	 * in FB BUFFER1 register.
+	 */
 	WR7146(P_TSL1, RSD1 | SIB_A1);
-	/*  Fetch ADC high data uint8_t. */
 	WR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);
-	/*  Fetch ADC low data uint8_t; end of TSL1. */
 
-	/*  enab TSL1 slot list so that it executes all the time. */
+	/* Enable TSL1 slot list so that it executes all the time */
 	WR7146(P_ACON1, ACON1_ADCSTART);
 
-	/*  Initialize RPS registers used for ADC. */
-
-	/* Physical start of RPS program. */
-	WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
+	/*
+	 * Initialize RPS registers used for ADC
+	 */
 
+	/* Physical start of RPS program */
+	WR7146(P_RPSADDR1, (uint32_t)devpriv->RPSBuf.PhysicalBase);
+	/* RPS program performs no explicit mem writes */
 	WR7146(P_RPSPAGE1, 0);
-	/*  RPS program performs no explicit mem writes. */
-	WR7146(P_RPS1_TOUT, 0);	/*  Disable RPS timeouts. */
+	/* Disable RPS timeouts */
+	WR7146(P_RPS1_TOUT, 0);
 
 #if 0
 	/*
@@ -2584,39 +2581,45 @@ static void s626_initialize(struct comedi_device *dev)
 	}
 #endif	/* SAA7146 BUG WORKAROUND */
 
-	/*  end initADC */
-
-	/*  init the DAC interface */
+	/*
+	 * Initialize the DAC interface
+	 */
 
-	/* Init Audio2's output DMAC attributes: burst length = 1
-	 * DWORD,  threshold = 1 DWORD.
+	/*
+	 * Init Audio2's output DMAC attributes:
+	 *   burst length = 1 DWORD
+	 *   threshold = 1 DWORD.
 	 */
 	WR7146(P_PCI_BT_A, 0);
 
-	/* Init Audio2's output DMA physical addresses.  The protection
+	/*
+	 * Init Audio2's output DMA physical addresses.  The protection
 	 * address is set to 1 DWORD past the base address so that a
 	 * single DWORD will be transferred each time a DMA transfer is
-	 * enabled. */
-
+	 * enabled.
+	 */
 	pPhysBuf = devpriv->ANABuf.PhysicalBase +
 		   (DAC_WDMABUF_OS * sizeof(uint32_t));
+	WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);
+	WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));
 
-	WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	/*  Buffer base adrs. */
-	WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	/*  Protection address. */
-
-	/* Cache Audio2's output DMA buffer logical address.  This is
-	 * where DAC data is buffered for A2 output DMA transfers. */
+	/*
+	 * Cache Audio2's output DMA buffer logical address.  This is
+	 * where DAC data is buffered for A2 output DMA transfers.
+	 */
 	devpriv->pDacWBuf = (uint32_t *)devpriv->ANABuf.LogicalBase +
 			    DAC_WDMABUF_OS;
 
-	/* Audio2's output channels does not use paging.  The protection
-	 * violation handling bit is set so that the DMAC will
-	 * automatically halt and its PCI address pointer will be reset
-	 * when the protection address is reached. */
-
+	/*
+	 * Audio2's output channels does not use paging.  The
+	 * protection violation handling bit is set so that the
+	 * DMAC will automatically halt and its PCI address pointer
+	 * will be reset when the protection address is reached.
+	 */
 	WR7146(P_PAGEA2_OUT, 8);
 
-	/* Initialize time slot list 2 (TSL2), which is used to control
+	/*
+	 * Initialize time slot list 2 (TSL2), which is used to control
 	 * the clock generation for and serialization of data to be sent
 	 * to the DAC devices.  Slot 0 is a NOP that is used to trap TSL
 	 * execution; this permits other slots to be safely modified
@@ -2627,48 +2630,52 @@ static void s626_initialize(struct comedi_device *dev)
 	 * not yet finished executing.
 	 */
 
+	/* Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2 */
 	SETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);
-	/*  Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2. */
 
-	/* Initialize slot 1, which is constant.  Slot 1 causes a
+	/*
+	 * Initialize slot 1, which is constant.  Slot 1 causes a
 	 * DWORD to be transferred from audio channel 2's output FIFO
 	 * to the FIFO's output buffer so that it can be serialized
 	 * and sent to the DAC during subsequent slots.  All remaining
 	 * slots are dynamically populated as required by the target
 	 * DAC device.
 	 */
+
+	/* Slot 1: Fetch DWORD from Audio2's output FIFO */
 	SETVECT(1, LF_A2);
-	/*  Slot 1: Fetch DWORD from Audio2's output FIFO. */
 
-	/*  Start DAC's audio interface (TSL2) running. */
+	/* Start DAC's audio interface (TSL2) running */
 	WR7146(P_ACON1, ACON1_DACSTART);
 
-	/* end init DAC interface */
-
-	/* Init Trim DACs to calibrated values.  Do it twice because the
+	/*
+	 * Init Trim DACs to calibrated values.  Do it twice because the
 	 * SAA7146 audio channel does not always reset properly and
 	 * sometimes causes the first few TrimDAC writes to malfunction.
 	 */
-
 	LoadTrimDACs(dev);
-	LoadTrimDACs(dev);	/*  Insurance. */
+	LoadTrimDACs(dev);
 
-	/* Manually init all gate array hardware in case this is a soft
+	/*
+	 * Manually init all gate array hardware in case this is a soft
 	 * reset (we have no way of determining whether this is a warm
 	 * or cold start).  This is necessary because the gate array will
 	 * reset only in response to a PCI hard reset; there is no soft
-	 * reset function. */
+	 * reset function.
+	 */
 
-	/* Init all DAC outputs to 0V and init all DAC setpoint and
+	/*
+	 * Init all DAC outputs to 0V and init all DAC setpoint and
 	 * polarity images.
 	 */
 	for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
 		SetDAC(dev, chan, 0);
 
-	/*  Init counters. */
+	/* Init counters */
 	CountersInit(dev);
 
-	/* Without modifying the state of the Battery Backup enab, disable
+	/*
+	 * Without modifying the state of the Battery Backup enab, disable
 	 * the watchdog timer, set DIO channels 0-5 to operate in the
 	 * standard DIO (vs. counter overflow) mode, disable the battery
 	 * charger, and reset the watchdog interval selector to zero.
@@ -2676,11 +2683,11 @@ static void s626_initialize(struct comedi_device *dev)
 	WriteMISC2(dev, (uint16_t)(DEBIread(dev, LP_RDMISC2) &
 				   MISC2_BATT_ENABLE));
 
-	/*  Initialize the digital I/O subsystem. */
+	/* Initialize the digital I/O subsystem */
 	s626_dio_init(dev);
 
 	/* enable interrupt test */
-	/*  writel(IRQ_GPIO3 | IRQ_RPS1,devpriv->base_addr+P_IER); */
+	/* writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->base_addr + P_IER); */
 }
 
 static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)

commit 98667bf7cc930c56f9257a8296d27a78eebac43f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:38:53 2012 -0700

    staging: comedi: s626: remove clear of kzalloc'ed data
    
    The private data is kzalloc'ed. There is no need to set any
    of the initial data to '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 0b897375eda6..6f1705ba60e2 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2665,12 +2665,6 @@ static void s626_initialize(struct comedi_device *dev)
 	for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
 		SetDAC(dev, chan, 0);
 
-	/* Init Counter Interrupt enab mask for RDMISC2.  This mask is
-	 * applied against MISC2 when testing to determine which timer
-	 * events are requesting interrupt service.
-	 */
-	devpriv->CounterIntEnabs = 0;
-
 	/*  Init counters. */
 	CountersInit(dev);
 

commit dc598176bbd7dfbcfcd6177d14b10768c59effae
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:38:39 2012 -0700

    staging: comedi: s626: remove 'WDInterval' from private data
    
    This variable is never used in the driver. Just remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4eb1a6708bdf..0b897375eda6 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -99,7 +99,6 @@ struct s626_private {
 	uint16_t Dacpol;	/* Image of DAC polarity register. */
 	uint8_t TrimSetpoint[12];	/* Images of TrimDAC setpoints */
 	/* Charge Enabled (0 or WRMISC2_CHARGE_ENABLE). */
-	uint16_t WDInterval;	/* Image of MISC2 watchdog interval control bits. */
 	uint32_t I2CAdrs;
 	/* I2C device address for onboard EEPROM (board rev dependent). */
 	/*   short         I2Cards; */
@@ -2666,12 +2665,6 @@ static void s626_initialize(struct comedi_device *dev)
 	for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
 		SetDAC(dev, chan, 0);
 
-	/* Init image of watchdog timer interval in WRMISC2.  This image
-	 * maintains the value of the control bits of MISC2 are
-	 * continuously reset to zero as long as the WD timer is disabled.
-	 */
-	devpriv->WDInterval = 0;
-
 	/* Init Counter Interrupt enab mask for RDMISC2.  This mask is
 	 * applied against MISC2 when testing to determine which timer
 	 * events are requesting interrupt service.

commit 7f98961c0d4bdebc4508c59cead7f349e47feb7f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:38:22 2012 -0700

    staging: comedi: s626: remove 'ChargeEnabled' from private data
    
    This variable is never used in the driver. Just remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index e67e1299d604..4eb1a6708bdf 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -98,7 +98,6 @@ struct s626_private {
 	/* Pointer to logical adrs of DMA buffer used to hold DAC  data. */
 	uint16_t Dacpol;	/* Image of DAC polarity register. */
 	uint8_t TrimSetpoint[12];	/* Images of TrimDAC setpoints */
-	uint16_t ChargeEnabled;	/* Image of MISC2 Battery */
 	/* Charge Enabled (0 or WRMISC2_CHARGE_ENABLE). */
 	uint16_t WDInterval;	/* Image of MISC2 watchdog interval control bits. */
 	uint32_t I2CAdrs;
@@ -2667,12 +2666,6 @@ static void s626_initialize(struct comedi_device *dev)
 	for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
 		SetDAC(dev, chan, 0);
 
-	/* Init image of WRMISC2 Battery Charger Enabled control bit.
-	 * This image is used when the state of the charger control bit,
-	 * which has no direct hardware readback mechanism, is queried.
-	 */
-	devpriv->ChargeEnabled = 0;
-
 	/* Init image of watchdog timer interval in WRMISC2.  This image
 	 * maintains the value of the control bits of MISC2 are
 	 * continuously reset to zero as long as the WD timer is disabled.

commit 17553c88a21866333f4dfe15fe75591d80f02f76
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:38:07 2012 -0700

    staging: comedi: s626: remove 'IsBoardRevA' comment
    
    IsBoardRevA is not defined in the driver. Remove the comment
    about it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4315892740c9..e67e1299d604 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2488,29 +2488,8 @@ static void s626_initialize(struct comedi_device *dev)
 	/*  Init GPIO so that ADC Start* is negated. */
 	WR7146(P_GPIO, GPIO_BASE | GPIO1_HI);
 
-	/* IsBoardRevA is a boolean that indicates whether the board is RevA.
-	 *
-	 * VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
-	 * EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
-	 * is used to access the onboard serial EEPROM.  The EEPROM's I2C
-	 * DeviceAddress is hardwired to a value that is dependent on the
-	 * 626 board revision.  On all board revisions, the EEPROM stores
-	 * TrimDAC calibration constants for analog I/O.  On RevB and
-	 * higher boards, the DeviceAddress is hardwired to 0 to enable
-	 * the EEPROM to also store the PCI SubVendorID and SubDeviceID;
-	 * this is the address at which the SAA7146 expects a
-	 * configuration EEPROM to reside.  On RevA boards, the EEPROM
-	 * device address, which is hardwired to 4, prevents the SAA7146
-	 * from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
-	 * default values, instead.
-	 */
-
-	/*     devpriv->I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM */
-	/*  DeviceType (0xA0) */
-	/*  and DeviceAddress<<1. */
-
-	devpriv->I2CAdrs = 0xA0;	/*  I2C device address for onboard */
-	/*  eeprom(revb) */
+	/* I2C device address for onboard eeprom (revb) */
+	devpriv->I2CAdrs = 0xA0;
 
 	/*  Issue an I2C ABORT command to halt any I2C operation in */
 	/* progress and reset BUSY flag. */

commit 597478473a172213ce396a799f65089bf4e75517
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:37:52 2012 -0700

    staging: comedi: s626: #if 0 out the "SAA7146 BUG WORKAROUND"
    
    Until it's determined if this workaround can be removed, block
    out the code with an #if 0/#endif and remove the individual
    comments on each line.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index cd09c37570bc..4315892740c9 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2459,16 +2459,10 @@ static int s626_allocate_dma_buffers(struct comedi_device *dev)
 
 static void s626_initialize(struct comedi_device *dev)
 {
-/*   uint8_t	PollList; */
-/*   uint16_t	AdcData; */
-/*   uint16_t	StartVal; */
-/*   uint16_t	index; */
-/*   unsigned int data[16]; */
 	dma_addr_t pPhysBuf;
 	uint16_t chan;
 	int i;
 
-
 	/*  enab DEBI and audio pins, enable I2C interface. */
 	MC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);
 	/*  Configure DEBI operating mode. */
@@ -2568,38 +2562,50 @@ static void s626_initialize(struct comedi_device *dev)
 	/*  RPS program performs no explicit mem writes. */
 	WR7146(P_RPS1_TOUT, 0);	/*  Disable RPS timeouts. */
 
-	/* SAA7146 BUG WORKAROUND.  Initialize SAA7146 ADC interface
-	 * to a known state by invoking ADCs until FB BUFFER 1
-	 * register shows that it is correctly receiving ADC data.
-	 * This is necessary because the SAA7146 ADC interface does
-	 * not start up in a defined state after a PCI reset.
+#if 0
+	/*
+	 * SAA7146 BUG WORKAROUND
+	 *
+	 * Initialize SAA7146 ADC interface to a known state by
+	 * invoking ADCs until FB BUFFER 1 register shows that it
+	 * is correctly receiving ADC data. This is necessary
+	 * because the SAA7146 ADC interface does not start up in
+	 * a defined state after a PCI reset.
 	 */
 
-/*     PollList = EOPL;		// Create a simple polling */
-/*				// list for analog input */
-/*				// channel 0. */
-/*     ResetADC( dev, &PollList ); */
-
-/*     s626_ai_rinsn(dev,dev->subdevices,NULL,data); //( &AdcData ); // */
-/*							//Get initial ADC */
-/*							//value. */
-
-/*     StartVal = data[0]; */
-
-/*     // VERSION 2.01 CHANGE: TIMEOUT ADDED TO PREVENT HANGED EXECUTION. */
-/*     // Invoke ADCs until the new ADC value differs from the initial */
-/*     // value or a timeout occurs.  The timeout protects against the */
-/*     // possibility that the driver is restarting and the ADC data is a */
-/*     // fixed value resulting from the applied ADC analog input being */
-/*     // unusually quiet or at the rail. */
-
-/*     for ( index = 0; index < 500; index++ ) */
-/*       { */
-/*	s626_ai_rinsn(dev,dev->subdevices,NULL,data); */
-/*	AdcData = data[0];	//ReadADC(  &AdcData ); */
-/*	if ( AdcData != StartVal ) */
-/*		break; */
-/*       } */
+	{
+	uint8_t PollList;
+	uint16_t AdcData;
+	uint16_t StartVal;
+	uint16_t index;
+	unsigned int data[16];
+
+	/* Create a simple polling list for analog input channel 0 */
+	PollList = EOPL;
+	ResetADC(dev, &PollList);
+
+	/* Get initial ADC value */
+	s626_ai_rinsn(dev, dev->subdevices, NULL, data);
+	StartVal = data[0];
+
+	/*
+	 * VERSION 2.01 CHANGE: TIMEOUT ADDED TO PREVENT HANGED EXECUTION.
+	 *
+	 * Invoke ADCs until the new ADC value differs from the initial
+	 * value or a timeout occurs.  The timeout protects against the
+	 * possibility that the driver is restarting and the ADC data is a
+	 * fixed value resulting from the applied ADC analog input being
+	 * unusually quiet or at the rail.
+	 */
+	for (index = 0; index < 500; index++) {
+		s626_ai_rinsn(dev, dev->subdevices, NULL, data);
+		AdcData = data[0];
+		if (AdcData != StartVal)
+			break;
+	}
+
+	}
+#endif	/* SAA7146 BUG WORKAROUND */
 
 	/*  end initADC */
 

commit 68ad0ae0eac07911e6749e28da75d77d25524864
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:37:36 2012 -0700

    staging: comedi: s626: remove 'allocatedBuf' from private data
    
    This variable is only used to count the number of dma buffers
    allocated during the attach. If an allocation fails, the attach
    function exits with -ENOMEM. When this variable is checked later
    it will always be == 2. Just remove the variable and the check.
    
    This allows bringing the code back an indent level in
    s626_initialize(). Note, coding style issues in this function
    are not addressed yet.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 07ff93b996c0..cd09c37570bc 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -80,7 +80,6 @@ INSN_CONFIG instructions:
 
 struct s626_private {
 	void __iomem *base_addr;
-	short allocatedBuf;
 	uint8_t ai_cmd_running;	/*  ai_cmd is running */
 	uint8_t ai_continous;	/*  continous acquisition */
 	int ai_sample_count;	/*  number of samples to acquire */
@@ -2443,24 +2442,18 @@ static int s626_allocate_dma_buffers(struct comedi_device *dev)
 	void *addr;
 	dma_addr_t appdma;
 
-	devpriv->allocatedBuf = 0;
-
 	addr = pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
 	if (!addr)
 		return -ENOMEM;
 	devpriv->ANABuf.LogicalBase = addr;
 	devpriv->ANABuf.PhysicalBase = appdma;
 
-	devpriv->allocatedBuf++;
-
 	addr = pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
 	if (!addr)
 		return -ENOMEM;
 	devpriv->RPSBuf.LogicalBase = addr;
 	devpriv->RPSBuf.PhysicalBase = appdma;
 
-	devpriv->allocatedBuf++;
-
 	return 0;
 }
 
@@ -2471,117 +2464,116 @@ static void s626_initialize(struct comedi_device *dev)
 /*   uint16_t	StartVal; */
 /*   uint16_t	index; */
 /*   unsigned int data[16]; */
+	dma_addr_t pPhysBuf;
+	uint16_t chan;
 	int i;
 
-	if (devpriv->allocatedBuf == 2) {
-		dma_addr_t pPhysBuf;
-		uint16_t chan;
-
-		/*  enab DEBI and audio pins, enable I2C interface. */
-		MC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);
-		/*  Configure DEBI operating mode. */
-		WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	/*  Local bus is 16 */
-		       /*  bits wide. */
-		       | (DEBI_TOUT << DEBI_CFG_TOUT_BIT)
-
-		       /*  Declare DEBI */
-		       /*  transfer timeout */
-		       /*  interval. */
-		       |DEBI_SWAP	/*  Set up byte lane */
-		       /*  steering. */
-		       | DEBI_CFG_INTEL);	/*  Intel-compatible */
-		/*  local bus (DEBI */
-		/*  never times out). */
-
-		/* DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ */
-		/* | DEBI_CFG_INCQ| DEBI_CFG_16Q); //end */
-
-		/*  Paging is disabled. */
-		WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);	/*  Disable MMU paging. */
-
-		/*  Init GPIO so that ADC Start* is negated. */
-		WR7146(P_GPIO, GPIO_BASE | GPIO1_HI);
-
-		/* IsBoardRevA is a boolean that indicates whether the board is RevA.
-		 *
-		 * VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
-		 * EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
-		 * is used to access the onboard serial EEPROM.  The EEPROM's I2C
-		 * DeviceAddress is hardwired to a value that is dependent on the
-		 * 626 board revision.  On all board revisions, the EEPROM stores
-		 * TrimDAC calibration constants for analog I/O.  On RevB and
-		 * higher boards, the DeviceAddress is hardwired to 0 to enable
-		 * the EEPROM to also store the PCI SubVendorID and SubDeviceID;
-		 * this is the address at which the SAA7146 expects a
-		 * configuration EEPROM to reside.  On RevA boards, the EEPROM
-		 * device address, which is hardwired to 4, prevents the SAA7146
-		 * from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
-		 * default values, instead.
-		 */
 
-		/*     devpriv->I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM */
-		/*  DeviceType (0xA0) */
-		/*  and DeviceAddress<<1. */
+	/*  enab DEBI and audio pins, enable I2C interface. */
+	MC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);
+	/*  Configure DEBI operating mode. */
+	WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	/*  Local bus is 16 */
+	       /*  bits wide. */
+	       | (DEBI_TOUT << DEBI_CFG_TOUT_BIT)
+
+	       /*  Declare DEBI */
+	       /*  transfer timeout */
+	       /*  interval. */
+	       |DEBI_SWAP	/*  Set up byte lane */
+	       /*  steering. */
+	       | DEBI_CFG_INTEL);	/*  Intel-compatible */
+	/*  local bus (DEBI */
+	/*  never times out). */
+
+	/* DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ */
+	/* | DEBI_CFG_INCQ| DEBI_CFG_16Q); //end */
+
+	/*  Paging is disabled. */
+	WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);	/*  Disable MMU paging. */
+
+	/*  Init GPIO so that ADC Start* is negated. */
+	WR7146(P_GPIO, GPIO_BASE | GPIO1_HI);
+
+	/* IsBoardRevA is a boolean that indicates whether the board is RevA.
+	 *
+	 * VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
+	 * EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
+	 * is used to access the onboard serial EEPROM.  The EEPROM's I2C
+	 * DeviceAddress is hardwired to a value that is dependent on the
+	 * 626 board revision.  On all board revisions, the EEPROM stores
+	 * TrimDAC calibration constants for analog I/O.  On RevB and
+	 * higher boards, the DeviceAddress is hardwired to 0 to enable
+	 * the EEPROM to also store the PCI SubVendorID and SubDeviceID;
+	 * this is the address at which the SAA7146 expects a
+	 * configuration EEPROM to reside.  On RevA boards, the EEPROM
+	 * device address, which is hardwired to 4, prevents the SAA7146
+	 * from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
+	 * default values, instead.
+	 */
+
+	/*     devpriv->I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM */
+	/*  DeviceType (0xA0) */
+	/*  and DeviceAddress<<1. */
 
-		devpriv->I2CAdrs = 0xA0;	/*  I2C device address for onboard */
-		/*  eeprom(revb) */
+	devpriv->I2CAdrs = 0xA0;	/*  I2C device address for onboard */
+	/*  eeprom(revb) */
 
-		/*  Issue an I2C ABORT command to halt any I2C operation in */
-		/* progress and reset BUSY flag. */
-		WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);
-		/*  Write I2C control: abort any I2C activity. */
-		MC_ENABLE(P_MC2, MC2_UPLD_IIC);
-		/*  Invoke command  upload */
-		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)
+	/*  Issue an I2C ABORT command to halt any I2C operation in */
+	/* progress and reset BUSY flag. */
+	WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);
+	/*  Write I2C control: abort any I2C activity. */
+	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
+	/*  Invoke command  upload */
+	while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)
+		;
+	/*  and wait for upload to complete. */
+
+	/* Per SAA7146 data sheet, write to STATUS reg twice to
+	 * reset all  I2C error flags. */
+	for (i = 0; i < 2; i++) {
+		WR7146(P_I2CSTAT, I2C_CLKSEL);
+		/*  Write I2C control: reset  error flags. */
+		MC_ENABLE(P_MC2, MC2_UPLD_IIC);	/*  Invoke command upload */
+		while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
 			;
-		/*  and wait for upload to complete. */
-
-		/* Per SAA7146 data sheet, write to STATUS reg twice to
-		 * reset all  I2C error flags. */
-		for (i = 0; i < 2; i++) {
-			WR7146(P_I2CSTAT, I2C_CLKSEL);
-			/*  Write I2C control: reset  error flags. */
-			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	/*  Invoke command upload */
-			while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
-				;
-			/* and wait for upload to complete. */
-		}
+		/* and wait for upload to complete. */
+	}
 
-		/* Init audio interface functional attributes: set DAC/ADC
-		 * serial clock rates, invert DAC serial clock so that
-		 * DAC data setup times are satisfied, enable DAC serial
-		 * clock out.
-		 */
+	/* Init audio interface functional attributes: set DAC/ADC
+	 * serial clock rates, invert DAC serial clock so that
+	 * DAC data setup times are satisfied, enable DAC serial
+	 * clock out.
+	 */
 
-		WR7146(P_ACON2, ACON2_INIT);
+	WR7146(P_ACON2, ACON2_INIT);
 
-		/* Set up TSL1 slot list, which is used to control the
-		 * accumulation of ADC data: RSD1 = shift data in on SD1.
-		 * SIB_A1  = store data uint8_t at next available location in
-		 * FB BUFFER1  register. */
-		WR7146(P_TSL1, RSD1 | SIB_A1);
-		/*  Fetch ADC high data uint8_t. */
-		WR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);
-		/*  Fetch ADC low data uint8_t; end of TSL1. */
+	/* Set up TSL1 slot list, which is used to control the
+	 * accumulation of ADC data: RSD1 = shift data in on SD1.
+	 * SIB_A1  = store data uint8_t at next available location in
+	 * FB BUFFER1  register. */
+	WR7146(P_TSL1, RSD1 | SIB_A1);
+	/*  Fetch ADC high data uint8_t. */
+	WR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);
+	/*  Fetch ADC low data uint8_t; end of TSL1. */
 
-		/*  enab TSL1 slot list so that it executes all the time. */
-		WR7146(P_ACON1, ACON1_ADCSTART);
+	/*  enab TSL1 slot list so that it executes all the time. */
+	WR7146(P_ACON1, ACON1_ADCSTART);
 
-		/*  Initialize RPS registers used for ADC. */
+	/*  Initialize RPS registers used for ADC. */
 
-		/* Physical start of RPS program. */
-		WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
+	/* Physical start of RPS program. */
+	WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
 
-		WR7146(P_RPSPAGE1, 0);
-		/*  RPS program performs no explicit mem writes. */
-		WR7146(P_RPS1_TOUT, 0);	/*  Disable RPS timeouts. */
+	WR7146(P_RPSPAGE1, 0);
+	/*  RPS program performs no explicit mem writes. */
+	WR7146(P_RPS1_TOUT, 0);	/*  Disable RPS timeouts. */
 
-		/* SAA7146 BUG WORKAROUND.  Initialize SAA7146 ADC interface
-		 * to a known state by invoking ADCs until FB BUFFER 1
-		 * register shows that it is correctly receiving ADC data.
-		 * This is necessary because the SAA7146 ADC interface does
-		 * not start up in a defined state after a PCI reset.
-		 */
+	/* SAA7146 BUG WORKAROUND.  Initialize SAA7146 ADC interface
+	 * to a known state by invoking ADCs until FB BUFFER 1
+	 * register shows that it is correctly receiving ADC data.
+	 * This is necessary because the SAA7146 ADC interface does
+	 * not start up in a defined state after a PCI reset.
+	 */
 
 /*     PollList = EOPL;		// Create a simple polling */
 /*				// list for analog input */
@@ -2609,124 +2601,121 @@ static void s626_initialize(struct comedi_device *dev)
 /*		break; */
 /*       } */
 
-		/*  end initADC */
+	/*  end initADC */
 
-		/*  init the DAC interface */
+	/*  init the DAC interface */
 
-		/* Init Audio2's output DMAC attributes: burst length = 1
-		 * DWORD,  threshold = 1 DWORD.
-		 */
-		WR7146(P_PCI_BT_A, 0);
-
-		/* Init Audio2's output DMA physical addresses.  The protection
-		 * address is set to 1 DWORD past the base address so that a
-		 * single DWORD will be transferred each time a DMA transfer is
-		 * enabled. */
-
-		pPhysBuf =
-		    devpriv->ANABuf.PhysicalBase +
-		    (DAC_WDMABUF_OS * sizeof(uint32_t));
-
-		WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	/*  Buffer base adrs. */
-		WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	/*  Protection address. */
-
-		/* Cache Audio2's output DMA buffer logical address.  This is
-		 * where DAC data is buffered for A2 output DMA transfers. */
-		devpriv->pDacWBuf =
-		    (uint32_t *) devpriv->ANABuf.LogicalBase + DAC_WDMABUF_OS;
-
-		/* Audio2's output channels does not use paging.  The protection
-		 * violation handling bit is set so that the DMAC will
-		 * automatically halt and its PCI address pointer will be reset
-		 * when the protection address is reached. */
-
-		WR7146(P_PAGEA2_OUT, 8);
-
-		/* Initialize time slot list 2 (TSL2), which is used to control
-		 * the clock generation for and serialization of data to be sent
-		 * to the DAC devices.  Slot 0 is a NOP that is used to trap TSL
-		 * execution; this permits other slots to be safely modified
-		 * without first turning off the TSL sequencer (which is
-		 * apparently impossible to do).  Also, SD3 (which is driven by a
-		 * pull-up resistor) is shifted in and stored to the MSB of
-		 * FB_BUFFER2 to be used as evidence that the slot sequence has
-		 * not yet finished executing.
-		 */
+	/* Init Audio2's output DMAC attributes: burst length = 1
+	 * DWORD,  threshold = 1 DWORD.
+	 */
+	WR7146(P_PCI_BT_A, 0);
+
+	/* Init Audio2's output DMA physical addresses.  The protection
+	 * address is set to 1 DWORD past the base address so that a
+	 * single DWORD will be transferred each time a DMA transfer is
+	 * enabled. */
+
+	pPhysBuf = devpriv->ANABuf.PhysicalBase +
+		   (DAC_WDMABUF_OS * sizeof(uint32_t));
+
+	WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	/*  Buffer base adrs. */
+	WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	/*  Protection address. */
+
+	/* Cache Audio2's output DMA buffer logical address.  This is
+	 * where DAC data is buffered for A2 output DMA transfers. */
+	devpriv->pDacWBuf = (uint32_t *)devpriv->ANABuf.LogicalBase +
+			    DAC_WDMABUF_OS;
+
+	/* Audio2's output channels does not use paging.  The protection
+	 * violation handling bit is set so that the DMAC will
+	 * automatically halt and its PCI address pointer will be reset
+	 * when the protection address is reached. */
+
+	WR7146(P_PAGEA2_OUT, 8);
+
+	/* Initialize time slot list 2 (TSL2), which is used to control
+	 * the clock generation for and serialization of data to be sent
+	 * to the DAC devices.  Slot 0 is a NOP that is used to trap TSL
+	 * execution; this permits other slots to be safely modified
+	 * without first turning off the TSL sequencer (which is
+	 * apparently impossible to do).  Also, SD3 (which is driven by a
+	 * pull-up resistor) is shifted in and stored to the MSB of
+	 * FB_BUFFER2 to be used as evidence that the slot sequence has
+	 * not yet finished executing.
+	 */
 
-		SETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);
-		/*  Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2. */
+	SETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);
+	/*  Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2. */
 
-		/* Initialize slot 1, which is constant.  Slot 1 causes a
-		 * DWORD to be transferred from audio channel 2's output FIFO
-		 * to the FIFO's output buffer so that it can be serialized
-		 * and sent to the DAC during subsequent slots.  All remaining
-		 * slots are dynamically populated as required by the target
-		 * DAC device.
-		 */
-		SETVECT(1, LF_A2);
-		/*  Slot 1: Fetch DWORD from Audio2's output FIFO. */
+	/* Initialize slot 1, which is constant.  Slot 1 causes a
+	 * DWORD to be transferred from audio channel 2's output FIFO
+	 * to the FIFO's output buffer so that it can be serialized
+	 * and sent to the DAC during subsequent slots.  All remaining
+	 * slots are dynamically populated as required by the target
+	 * DAC device.
+	 */
+	SETVECT(1, LF_A2);
+	/*  Slot 1: Fetch DWORD from Audio2's output FIFO. */
 
-		/*  Start DAC's audio interface (TSL2) running. */
-		WR7146(P_ACON1, ACON1_DACSTART);
+	/*  Start DAC's audio interface (TSL2) running. */
+	WR7146(P_ACON1, ACON1_DACSTART);
 
-		/* end init DAC interface */
+	/* end init DAC interface */
 
-		/* Init Trim DACs to calibrated values.  Do it twice because the
-		 * SAA7146 audio channel does not always reset properly and
-		 * sometimes causes the first few TrimDAC writes to malfunction.
-		 */
+	/* Init Trim DACs to calibrated values.  Do it twice because the
+	 * SAA7146 audio channel does not always reset properly and
+	 * sometimes causes the first few TrimDAC writes to malfunction.
+	 */
 
-		LoadTrimDACs(dev);
-		LoadTrimDACs(dev);	/*  Insurance. */
+	LoadTrimDACs(dev);
+	LoadTrimDACs(dev);	/*  Insurance. */
 
-		/* Manually init all gate array hardware in case this is a soft
-		 * reset (we have no way of determining whether this is a warm
-		 * or cold start).  This is necessary because the gate array will
-		 * reset only in response to a PCI hard reset; there is no soft
-		 * reset function. */
+	/* Manually init all gate array hardware in case this is a soft
+	 * reset (we have no way of determining whether this is a warm
+	 * or cold start).  This is necessary because the gate array will
+	 * reset only in response to a PCI hard reset; there is no soft
+	 * reset function. */
 
-		/* Init all DAC outputs to 0V and init all DAC setpoint and
-		 * polarity images.
-		 */
-		for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
-			SetDAC(dev, chan, 0);
+	/* Init all DAC outputs to 0V and init all DAC setpoint and
+	 * polarity images.
+	 */
+	for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
+		SetDAC(dev, chan, 0);
 
-		/* Init image of WRMISC2 Battery Charger Enabled control bit.
-		 * This image is used when the state of the charger control bit,
-		 * which has no direct hardware readback mechanism, is queried.
-		 */
-		devpriv->ChargeEnabled = 0;
+	/* Init image of WRMISC2 Battery Charger Enabled control bit.
+	 * This image is used when the state of the charger control bit,
+	 * which has no direct hardware readback mechanism, is queried.
+	 */
+	devpriv->ChargeEnabled = 0;
 
-		/* Init image of watchdog timer interval in WRMISC2.  This image
-		 * maintains the value of the control bits of MISC2 are
-		 * continuously reset to zero as long as the WD timer is disabled.
-		 */
-		devpriv->WDInterval = 0;
+	/* Init image of watchdog timer interval in WRMISC2.  This image
+	 * maintains the value of the control bits of MISC2 are
+	 * continuously reset to zero as long as the WD timer is disabled.
+	 */
+	devpriv->WDInterval = 0;
 
-		/* Init Counter Interrupt enab mask for RDMISC2.  This mask is
-		 * applied against MISC2 when testing to determine which timer
-		 * events are requesting interrupt service.
-		 */
-		devpriv->CounterIntEnabs = 0;
+	/* Init Counter Interrupt enab mask for RDMISC2.  This mask is
+	 * applied against MISC2 when testing to determine which timer
+	 * events are requesting interrupt service.
+	 */
+	devpriv->CounterIntEnabs = 0;
 
-		/*  Init counters. */
-		CountersInit(dev);
+	/*  Init counters. */
+	CountersInit(dev);
 
-		/* Without modifying the state of the Battery Backup enab, disable
-		 * the watchdog timer, set DIO channels 0-5 to operate in the
-		 * standard DIO (vs. counter overflow) mode, disable the battery
-		 * charger, and reset the watchdog interval selector to zero.
-		 */
-		WriteMISC2(dev, (uint16_t) (DEBIread(dev,
-						     LP_RDMISC2) &
-					    MISC2_BATT_ENABLE));
+	/* Without modifying the state of the Battery Backup enab, disable
+	 * the watchdog timer, set DIO channels 0-5 to operate in the
+	 * standard DIO (vs. counter overflow) mode, disable the battery
+	 * charger, and reset the watchdog interval selector to zero.
+	 */
+	WriteMISC2(dev, (uint16_t)(DEBIread(dev, LP_RDMISC2) &
+				   MISC2_BATT_ENABLE));
 
-		/*  Initialize the digital I/O subsystem. */
-		s626_dio_init(dev);
+	/*  Initialize the digital I/O subsystem. */
+	s626_dio_init(dev);
 
-		/* enable interrupt test */
-		/*  writel(IRQ_GPIO3 | IRQ_RPS1,devpriv->base_addr+P_IER); */
-	}
+	/* enable interrupt test */
+	/*  writel(IRQ_GPIO3 | IRQ_RPS1,devpriv->base_addr+P_IER); */
 }
 
 static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)

commit f996ab29e9dd1ed607ea9ba708dff6fa4d253859
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:37:19 2012 -0700

    staging: comedi: s626: add final attach message
    
    Add a simple dev_info() message after a successfull attach.
    Change the final return to '0' to indicate success.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index f4251acd9cc9..07ff93b996c0 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2850,7 +2850,9 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 
 	s626_initialize(dev);
 
-	return 1;
+	dev_info(dev->class_dev, "%s attached\n", dev->board_name);
+
+	return 0;
 }
 
 static void s626_detach(struct comedi_device *dev)

commit b7eaf21a6709fb1dd1659dd0e56ce665375ba538
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:24:42 2012 -0700

    staging: comedi: s626: remove unneeded clear of private data
    
    The private data is kzalloc'ed. All the variables in it are
    initially '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index cbae8e4ba2e2..f4251acd9cc9 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2848,9 +2848,6 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 	s->maxdata = 0xffffff;
 	s->range_table = &range_unknown;
 
-	/* stop ai_command */
-	devpriv->ai_cmd_running = 0;
-
 	s626_initialize(dev);
 
 	return 1;

commit 80ec9510296224048021793b644eb9057c59df5a
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:24:27 2012 -0700

    staging: comedi: s626: factor out the board init code
    
    To make the attach a bit cleaner, factor the board init code
    out of attach_pci() into a new function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4ad3f27b07c4..cbae8e4ba2e2 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2464,7 +2464,7 @@ static int s626_allocate_dma_buffers(struct comedi_device *dev)
 	return 0;
 }
 
-static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
+static void s626_initialize(struct comedi_device *dev)
 {
 /*   uint8_t	PollList; */
 /*   uint16_t	AdcData; */
@@ -2472,125 +2472,6 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 /*   uint16_t	index; */
 /*   unsigned int data[16]; */
 	int i;
-	int ret;
-	struct comedi_subdevice *s;
-
-	comedi_set_hw_dev(dev, &pcidev->dev);
-	dev->board_name = dev->driver->driver_name;
-
-	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
-		return -ENOMEM;
-
-	ret = comedi_pci_enable(pcidev, dev->board_name);
-	if (ret)
-		return ret;
-	dev->iobase = 1;	/* detach needs this */
-
-	devpriv->base_addr = ioremap(pci_resource_start(pcidev, 0),
-				     pci_resource_len(pcidev, 0));
-	if (!devpriv->base_addr)
-		return -ENOMEM;
-
-	/* disable master interrupt */
-	writel(0, devpriv->base_addr + P_IER);
-
-	/* soft reset */
-	writel(MC1_SOFT_RESET, devpriv->base_addr + P_MC1);
-
-	/* DMA FIXME DMA// */
-
-	ret = s626_allocate_dma_buffers(dev);
-	if (ret)
-		return ret;
-
-	if (pcidev->irq) {
-		ret = request_irq(pcidev->irq, s626_irq_handler, IRQF_SHARED,
-				  dev->board_name, dev);
-
-		if (ret == 0)
-			dev->irq = pcidev->irq;
-	}
-
-	ret = comedi_alloc_subdevices(dev, 6);
-	if (ret)
-		return ret;
-
-	s = dev->subdevices + 0;
-	/* analog input subdevice */
-	dev->read_subdev = s;
-	/* we support single-ended (ground) and differential */
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_CMD_READ;
-	s->n_chan = S626_ADC_CHANNELS;
-	s->maxdata = (0xffff >> 2);
-	s->range_table = &s626_range_table;
-	s->len_chanlist = S626_ADC_CHANNELS;
-	s->insn_config = s626_ai_insn_config;
-	s->insn_read = s626_ai_insn_read;
-	s->do_cmd = s626_ai_cmd;
-	s->do_cmdtest = s626_ai_cmdtest;
-	s->cancel = s626_ai_cancel;
-
-	s = dev->subdevices + 1;
-	/* analog output subdevice */
-	s->type = COMEDI_SUBD_AO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = S626_DAC_CHANNELS;
-	s->maxdata = (0x3fff);
-	s->range_table = &range_bipolar10;
-	s->insn_write = s626_ao_winsn;
-	s->insn_read = s626_ao_rinsn;
-
-	s = dev->subdevices + 2;
-	/* digital I/O subdevice */
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = 16;
-	s->maxdata = 1;
-	s->io_bits = 0xffff;
-	s->private = &dio_private_A;
-	s->range_table = &range_digital;
-	s->insn_config = s626_dio_insn_config;
-	s->insn_bits = s626_dio_insn_bits;
-
-	s = dev->subdevices + 3;
-	/* digital I/O subdevice */
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = 16;
-	s->maxdata = 1;
-	s->io_bits = 0xffff;
-	s->private = &dio_private_B;
-	s->range_table = &range_digital;
-	s->insn_config = s626_dio_insn_config;
-	s->insn_bits = s626_dio_insn_bits;
-
-	s = dev->subdevices + 4;
-	/* digital I/O subdevice */
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = 16;
-	s->maxdata = 1;
-	s->io_bits = 0xffff;
-	s->private = &dio_private_C;
-	s->range_table = &range_digital;
-	s->insn_config = s626_dio_insn_config;
-	s->insn_bits = s626_dio_insn_bits;
-
-	s = dev->subdevices + 5;
-	/* encoder (counter) subdevice */
-	s->type = COMEDI_SUBD_COUNTER;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;
-	s->n_chan = S626_ENCODER_CHANNELS;
-	s->private = enc_private_data;
-	s->insn_config = s626_enc_insn_config;
-	s->insn_read = s626_enc_insn_read;
-	s->insn_write = s626_enc_insn_write;
-	s->maxdata = 0xffffff;
-	s->range_table = &range_unknown;
-
-	/* stop ai_command */
-	devpriv->ai_cmd_running = 0;
 
 	if (devpriv->allocatedBuf == 2) {
 		dma_addr_t pPhysBuf;
@@ -2846,6 +2727,131 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 		/* enable interrupt test */
 		/*  writel(IRQ_GPIO3 | IRQ_RPS1,devpriv->base_addr+P_IER); */
 	}
+}
+
+static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
+{
+	struct comedi_subdevice *s;
+	int ret;
+
+	comedi_set_hw_dev(dev, &pcidev->dev);
+	dev->board_name = dev->driver->driver_name;
+
+	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
+		return -ENOMEM;
+
+	ret = comedi_pci_enable(pcidev, dev->board_name);
+	if (ret)
+		return ret;
+	dev->iobase = 1;	/* detach needs this */
+
+	devpriv->base_addr = ioremap(pci_resource_start(pcidev, 0),
+				     pci_resource_len(pcidev, 0));
+	if (!devpriv->base_addr)
+		return -ENOMEM;
+
+	/* disable master interrupt */
+	writel(0, devpriv->base_addr + P_IER);
+
+	/* soft reset */
+	writel(MC1_SOFT_RESET, devpriv->base_addr + P_MC1);
+
+	/* DMA FIXME DMA// */
+
+	ret = s626_allocate_dma_buffers(dev);
+	if (ret)
+		return ret;
+
+	if (pcidev->irq) {
+		ret = request_irq(pcidev->irq, s626_irq_handler, IRQF_SHARED,
+				  dev->board_name, dev);
+
+		if (ret == 0)
+			dev->irq = pcidev->irq;
+	}
+
+	ret = comedi_alloc_subdevices(dev, 6);
+	if (ret)
+		return ret;
+
+	s = dev->subdevices + 0;
+	/* analog input subdevice */
+	dev->read_subdev = s;
+	/* we support single-ended (ground) and differential */
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_CMD_READ;
+	s->n_chan = S626_ADC_CHANNELS;
+	s->maxdata = (0xffff >> 2);
+	s->range_table = &s626_range_table;
+	s->len_chanlist = S626_ADC_CHANNELS;
+	s->insn_config = s626_ai_insn_config;
+	s->insn_read = s626_ai_insn_read;
+	s->do_cmd = s626_ai_cmd;
+	s->do_cmdtest = s626_ai_cmdtest;
+	s->cancel = s626_ai_cancel;
+
+	s = dev->subdevices + 1;
+	/* analog output subdevice */
+	s->type = COMEDI_SUBD_AO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = S626_DAC_CHANNELS;
+	s->maxdata = (0x3fff);
+	s->range_table = &range_bipolar10;
+	s->insn_write = s626_ao_winsn;
+	s->insn_read = s626_ao_rinsn;
+
+	s = dev->subdevices + 2;
+	/* digital I/O subdevice */
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = 16;
+	s->maxdata = 1;
+	s->io_bits = 0xffff;
+	s->private = &dio_private_A;
+	s->range_table = &range_digital;
+	s->insn_config = s626_dio_insn_config;
+	s->insn_bits = s626_dio_insn_bits;
+
+	s = dev->subdevices + 3;
+	/* digital I/O subdevice */
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = 16;
+	s->maxdata = 1;
+	s->io_bits = 0xffff;
+	s->private = &dio_private_B;
+	s->range_table = &range_digital;
+	s->insn_config = s626_dio_insn_config;
+	s->insn_bits = s626_dio_insn_bits;
+
+	s = dev->subdevices + 4;
+	/* digital I/O subdevice */
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = 16;
+	s->maxdata = 1;
+	s->io_bits = 0xffff;
+	s->private = &dio_private_C;
+	s->range_table = &range_digital;
+	s->insn_config = s626_dio_insn_config;
+	s->insn_bits = s626_dio_insn_bits;
+
+	s = dev->subdevices + 5;
+	/* encoder (counter) subdevice */
+	s->type = COMEDI_SUBD_COUNTER;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;
+	s->n_chan = S626_ENCODER_CHANNELS;
+	s->private = enc_private_data;
+	s->insn_config = s626_enc_insn_config;
+	s->insn_read = s626_enc_insn_read;
+	s->insn_write = s626_enc_insn_write;
+	s->maxdata = 0xffffff;
+	s->range_table = &range_unknown;
+
+	/* stop ai_command */
+	devpriv->ai_cmd_running = 0;
+
+	s626_initialize(dev);
 
 	return 1;
 }

commit 8c7e4277c1197d31c0b34dbaf23e6edddb5978f7
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:24:12 2012 -0700

    staging: comedi: s626: cleanup request_irq in s626_attach_pci()
    
    Only set dev->irq if request_irq is successfull.
    
    Remove the kernel message noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 61bb8ab05786..4ad3f27b07c4 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2503,25 +2503,18 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 	if (ret)
 		return ret;
 
-	ret = comedi_alloc_subdevices(dev, 6);
-	if (ret)
-		return ret;
-
-	dev->irq = pcidev->irq;
-
-	/* set up interrupt handler */
-	if (dev->irq == 0) {
-		printk(KERN_ERR " unknown irq (bad)\n");
-	} else {
-		ret = request_irq(dev->irq, s626_irq_handler, IRQF_SHARED,
+	if (pcidev->irq) {
+		ret = request_irq(pcidev->irq, s626_irq_handler, IRQF_SHARED,
 				  dev->board_name, dev);
 
-		if (ret < 0) {
-			printk(KERN_ERR " irq not available\n");
-			dev->irq = 0;
-		}
+		if (ret == 0)
+			dev->irq = pcidev->irq;
 	}
 
+	ret = comedi_alloc_subdevices(dev, 6);
+	if (ret)
+		return ret;
+
 	s = dev->subdevices + 0;
 	/* analog input subdevice */
 	dev->read_subdev = s;

commit b7047895b9c9deee0b0f4cb2a0a788c189f985f2
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:23:57 2012 -0700

    staging: comedi: s626: factor out the dma buffer allocation
    
    To make the attach a bit cleaner, factor the dma buffer allocation
    out of attach_pci() into a new function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index a9d78c721403..61bb8ab05786 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2437,6 +2437,33 @@ static void CountersInit(struct comedi_device *dev)
 	}
 }
 
+static int s626_allocate_dma_buffers(struct comedi_device *dev)
+{
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	void *addr;
+	dma_addr_t appdma;
+
+	devpriv->allocatedBuf = 0;
+
+	addr = pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
+	if (!addr)
+		return -ENOMEM;
+	devpriv->ANABuf.LogicalBase = addr;
+	devpriv->ANABuf.PhysicalBase = appdma;
+
+	devpriv->allocatedBuf++;
+
+	addr = pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
+	if (!addr)
+		return -ENOMEM;
+	devpriv->RPSBuf.LogicalBase = addr;
+	devpriv->RPSBuf.PhysicalBase = appdma;
+
+	devpriv->allocatedBuf++;
+
+	return 0;
+}
+
 static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 {
 /*   uint8_t	PollList; */
@@ -2446,7 +2473,6 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 /*   unsigned int data[16]; */
 	int i;
 	int ret;
-	dma_addr_t appdma;
 	struct comedi_subdevice *s;
 
 	comedi_set_hw_dev(dev, &pcidev->dev);
@@ -2473,32 +2499,9 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 
 	/* DMA FIXME DMA// */
 
-	/* adc buffer allocation */
-	devpriv->allocatedBuf = 0;
-
-	devpriv->ANABuf.LogicalBase =
-		pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
-
-	if (devpriv->ANABuf.LogicalBase == NULL) {
-		printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
-		return -ENOMEM;
-	}
-
-	devpriv->ANABuf.PhysicalBase = appdma;
-
-	devpriv->allocatedBuf++;
-
-	devpriv->RPSBuf.LogicalBase =
-		pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
-
-	if (devpriv->RPSBuf.LogicalBase == NULL) {
-		printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
-		return -ENOMEM;
-	}
-
-	devpriv->RPSBuf.PhysicalBase = appdma;
-
-	devpriv->allocatedBuf++;
+	ret = s626_allocate_dma_buffers(dev);
+	if (ret)
+		return ret;
 
 	ret = comedi_alloc_subdevices(dev, 6);
 	if (ret)

commit 97d87e00e3d6bdc8f3de606dd7cc5aa149709435
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:23:40 2012 -0700

    staging: comedi: s626: remove unnecessary checks of 'devpriv->base_addr'
    
    'devpriv->base_addr' is valid from this point on in the attach_pci()
    function. Remove the unnecessary checks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6f6c808509cd..a9d78c721403 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2465,43 +2465,40 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 	if (!devpriv->base_addr)
 		return -ENOMEM;
 
-	if (devpriv->base_addr) {
-		/* disable master interrupt */
-		writel(0, devpriv->base_addr + P_IER);
+	/* disable master interrupt */
+	writel(0, devpriv->base_addr + P_IER);
 
-		/* soft reset */
-		writel(MC1_SOFT_RESET, devpriv->base_addr + P_MC1);
+	/* soft reset */
+	writel(MC1_SOFT_RESET, devpriv->base_addr + P_MC1);
 
-		/* DMA FIXME DMA// */
+	/* DMA FIXME DMA// */
 
-		/* adc buffer allocation */
-		devpriv->allocatedBuf = 0;
+	/* adc buffer allocation */
+	devpriv->allocatedBuf = 0;
 
-		devpriv->ANABuf.LogicalBase =
-		    pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
+	devpriv->ANABuf.LogicalBase =
+		pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
 
-		if (devpriv->ANABuf.LogicalBase == NULL) {
-			printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
-			return -ENOMEM;
-		}
-
-		devpriv->ANABuf.PhysicalBase = appdma;
+	if (devpriv->ANABuf.LogicalBase == NULL) {
+		printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
+		return -ENOMEM;
+	}
 
-		devpriv->allocatedBuf++;
+	devpriv->ANABuf.PhysicalBase = appdma;
 
-		devpriv->RPSBuf.LogicalBase =
-		    pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
+	devpriv->allocatedBuf++;
 
-		if (devpriv->RPSBuf.LogicalBase == NULL) {
-			printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
-			return -ENOMEM;
-		}
+	devpriv->RPSBuf.LogicalBase =
+		pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
 
-		devpriv->RPSBuf.PhysicalBase = appdma;
+	if (devpriv->RPSBuf.LogicalBase == NULL) {
+		printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
+		return -ENOMEM;
+	}
 
-		devpriv->allocatedBuf++;
+	devpriv->RPSBuf.PhysicalBase = appdma;
 
-	}
+	devpriv->allocatedBuf++;
 
 	ret = comedi_alloc_subdevices(dev, 6);
 	if (ret)
@@ -2599,7 +2596,7 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 	/* stop ai_command */
 	devpriv->ai_cmd_running = 0;
 
-	if (devpriv->base_addr && (devpriv->allocatedBuf == 2)) {
+	if (devpriv->allocatedBuf == 2) {
 		dma_addr_t pPhysBuf;
 		uint16_t chan;
 

commit 4f6c7bf992bc6f1bbf38b08e9b3c8a21865888f2
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:23:22 2012 -0700

    staging: comedi: s626: cleanup ioremap()
    
    The local variable 'resourceStart' is only used in the ioremap()
    to hold the PCI bar 0 base address. Just use the pci_resource_start()
    directly in the ioremap().
    
    Also, instead of assuming the resource size for the ioremap, use
    pci_resource_len() to get the actual size.
    
    Remove the kernel noise when the ioremap fails and change the error
    code from -ENODEV to -ENOMEM.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 12709b0bbba1..6f6c808509cd 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2446,7 +2446,6 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 /*   unsigned int data[16]; */
 	int i;
 	int ret;
-	resource_size_t resourceStart;
 	dma_addr_t appdma;
 	struct comedi_subdevice *s;
 
@@ -2461,13 +2460,10 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 		return ret;
 	dev->iobase = 1;	/* detach needs this */
 
-	resourceStart = pci_resource_start(pcidev, 0);
-
-	devpriv->base_addr = ioremap(resourceStart, SIZEOF_ADDRESS_SPACE);
-	if (devpriv->base_addr == NULL) {
-		printk(KERN_ERR "s626_attach: IOREMAP failed\n");
-		return -ENODEV;
-	}
+	devpriv->base_addr = ioremap(pci_resource_start(pcidev, 0),
+				     pci_resource_len(pcidev, 0));
+	if (!devpriv->base_addr)
+		return -ENOMEM;
 
 	if (devpriv->base_addr) {
 		/* disable master interrupt */

commit 58f4a8fce1d6f1e42543376c85839576992e6100
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:23:07 2012 -0700

    staging: comedi: s626: remove 'got_regions' from private data
    
    This variable is only used as a flag to indicate that the pci device
    has been enabled and needs to be disabled in the detach. Use the
    comedi_device 'iobase' for this and remove the private data variable.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 93e55c314598..12709b0bbba1 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -80,7 +80,6 @@ INSN_CONFIG instructions:
 
 struct s626_private {
 	void __iomem *base_addr;
-	int got_regions;
 	short allocatedBuf;
 	uint8_t ai_cmd_running;	/*  ai_cmd is running */
 	uint8_t ai_continous;	/*  continous acquisition */
@@ -2460,7 +2459,7 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 	ret = comedi_pci_enable(pcidev, dev->board_name);
 	if (ret)
 		return ret;
-	devpriv->got_regions = 1;
+	dev->iobase = 1;	/* detach needs this */
 
 	resourceStart = pci_resource_start(pcidev, 0);
 
@@ -2512,7 +2511,6 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 	if (ret)
 		return ret;
 
-	dev->iobase = (unsigned long)devpriv->base_addr;
 	dev->irq = pcidev->irq;
 
 	/* set up interrupt handler */
@@ -2893,7 +2891,7 @@ static void s626_detach(struct comedi_device *dev)
 			iounmap(devpriv->base_addr);
 	}
 	if (pcidev) {
-		if (devpriv->got_regions)
+		if (dev->iobase)
 			comedi_pci_disable(pcidev);
 	}
 }

commit 41f821d07729d1c3d59d1ebebf4c57e2ffe0a37c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:22:50 2012 -0700

    staging: comedi: s626: remove unneeded local variable in attach_pci()
    
    The 'result' variable is only used to check the return from
    comedi_pci_enable(). Just reuse the 'ret' variable.
    
    Also, remove the kernel noise and use the error code from
    comedi_pci_enable() instead of returning -ENODEV.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index fb215b24fce8..93e55c314598 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2445,7 +2445,6 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 /*   uint16_t	StartVal; */
 /*   uint16_t	index; */
 /*   unsigned int data[16]; */
-	int result;
 	int i;
 	int ret;
 	resource_size_t resourceStart;
@@ -2458,11 +2457,9 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
 		return -ENOMEM;
 
-	result = comedi_pci_enable(pcidev, dev->board_name);
-	if (result < 0) {
-		printk(KERN_ERR "s626_attach: comedi_pci_enable fails\n");
-		return -ENODEV;
-	}
+	ret = comedi_pci_enable(pcidev, dev->board_name);
+	if (ret)
+		return ret;
 	devpriv->got_regions = 1;
 
 	resourceStart = pci_resource_start(pcidev, 0);

commit 7c843aa7731c774a78a31b6dab371024c4756d38
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:22:31 2012 -0700

    staging: comedi: s626: use dev->board_name for resource name
    
    Instead of the literal string "s626", use the dev->board_name for
    the resource name when enabling the PCI device and requesting the
    irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index e30833f4178c..fb215b24fce8 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2453,11 +2453,12 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 	struct comedi_subdevice *s;
 
 	comedi_set_hw_dev(dev, &pcidev->dev);
+	dev->board_name = dev->driver->driver_name;
 
 	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
 		return -ENOMEM;
 
-	result = comedi_pci_enable(pcidev, "s626");
+	result = comedi_pci_enable(pcidev, dev->board_name);
 	if (result < 0) {
 		printk(KERN_ERR "s626_attach: comedi_pci_enable fails\n");
 		return -ENODEV;
@@ -2510,8 +2511,6 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 
 	}
 
-	dev->board_name = dev->driver->driver_name;
-
 	ret = comedi_alloc_subdevices(dev, 6);
 	if (ret)
 		return ret;
@@ -2524,7 +2523,7 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 		printk(KERN_ERR " unknown irq (bad)\n");
 	} else {
 		ret = request_irq(dev->irq, s626_irq_handler, IRQF_SHARED,
-				  "s626", dev);
+				  dev->board_name, dev);
 
 		if (ret < 0) {
 			printk(KERN_ERR " irq not available\n");

commit f574af6d268240a68f99fac9f2f42ce38b26eae9
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:22:10 2012 -0700

    staging: comedi: s626: store the pci_dev in the comedi_device
    
    Use the hw_dev pointer in the comedi_device struct to hold the
    pci_dev instead of carrying it in the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index eff7e962b9b5..e30833f4178c 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -79,7 +79,6 @@ INSN_CONFIG instructions:
 #define PCI_SUBDEVICE_ID_S626 0x0272
 
 struct s626_private {
-	struct pci_dev *pdev;
 	void __iomem *base_addr;
 	int got_regions;
 	short allocatedBuf;
@@ -1882,6 +1881,7 @@ static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
 static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
 		      size_t bsize)
 {
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	void *vbptr;
 	dma_addr_t vpptr;
 
@@ -1892,7 +1892,7 @@ static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
 	vbptr = pdma->LogicalBase;
 	vpptr = pdma->PhysicalBase;
 	if (vbptr) {
-		pci_free_consistent(devpriv->pdev, bsize, vbptr, vpptr);
+		pci_free_consistent(pcidev, bsize, vbptr, vpptr);
 		pdma->LogicalBase = NULL;
 		pdma->PhysicalBase = 0;
 	}
@@ -2452,19 +2452,19 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 	dma_addr_t appdma;
 	struct comedi_subdevice *s;
 
+	comedi_set_hw_dev(dev, &pcidev->dev);
+
 	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
 		return -ENOMEM;
 
-	devpriv->pdev = pcidev;
-
-	result = comedi_pci_enable(devpriv->pdev, "s626");
+	result = comedi_pci_enable(pcidev, "s626");
 	if (result < 0) {
 		printk(KERN_ERR "s626_attach: comedi_pci_enable fails\n");
 		return -ENODEV;
 	}
 	devpriv->got_regions = 1;
 
-	resourceStart = pci_resource_start(devpriv->pdev, 0);
+	resourceStart = pci_resource_start(pcidev, 0);
 
 	devpriv->base_addr = ioremap(resourceStart, SIZEOF_ADDRESS_SPACE);
 	if (devpriv->base_addr == NULL) {
@@ -2485,7 +2485,7 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 		devpriv->allocatedBuf = 0;
 
 		devpriv->ANABuf.LogicalBase =
-		    pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
+		    pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
 
 		if (devpriv->ANABuf.LogicalBase == NULL) {
 			printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
@@ -2497,7 +2497,7 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 		devpriv->allocatedBuf++;
 
 		devpriv->RPSBuf.LogicalBase =
-		    pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
+		    pci_alloc_consistent(pcidev, DMABUF_SIZE, &appdma);
 
 		if (devpriv->RPSBuf.LogicalBase == NULL) {
 			printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
@@ -2517,7 +2517,7 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 		return ret;
 
 	dev->iobase = (unsigned long)devpriv->base_addr;
-	dev->irq = devpriv->pdev->irq;
+	dev->irq = pcidev->irq;
 
 	/* set up interrupt handler */
 	if (dev->irq == 0) {
@@ -2869,6 +2869,8 @@ static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 
 static void s626_detach(struct comedi_device *dev)
 {
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+
 	if (devpriv) {
 		/* stop ai_command */
 		devpriv->ai_cmd_running = 0;
@@ -2893,10 +2895,10 @@ static void s626_detach(struct comedi_device *dev)
 			free_irq(dev->irq, dev);
 		if (devpriv->base_addr)
 			iounmap(devpriv->base_addr);
-		if (devpriv->pdev) {
-			if (devpriv->got_regions)
-				comedi_pci_disable(devpriv->pdev);
-		}
+	}
+	if (pcidev) {
+		if (devpriv->got_regions)
+			comedi_pci_disable(pcidev);
 	}
 }
 

commit 91e674e83c530d5902e482ede1af0115989c4fe6
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:21:53 2012 -0700

    staging: comedi: s626: use attach_pci callback
    
    Convert this PCI driver to use the comedi PCI auto config attach
    mechanism by adding an 'attach_pci' callback function. Since the
    driver does not require any external configuration options, and
    the legacy 'attach' callback is not optional, remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index bac14458536e..eff7e962b9b5 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -32,11 +32,7 @@ Authors: Gianluca Palli <gpalli@deis.unibo.it>,
 Updated: Fri, 15 Feb 2008 10:28:42 +0000
 Status: experimental
 
-Configuration options:
-  [0] - PCI bus of device (optional)
-  [1] - PCI slot of device (optional)
-  If bus/slot is not specified, the first supported
-  PCI device found will be used.
+Configuration options: not applicable, uses PCI auto config
 
 INSN_CONFIG instructions:
   analog input:
@@ -2442,35 +2438,7 @@ static void CountersInit(struct comedi_device *dev)
 	}
 }
 
-static struct pci_dev *s626_find_pci(struct comedi_device *dev,
-				     struct comedi_devconfig *it)
-{
-	struct pci_dev *pcidev = NULL;
-	int bus = it->options[0];
-	int slot = it->options[1];
-	int i;
-
-	do {
-		pcidev = pci_get_subsys(PCI_VENDOR_ID_S626,
-					PCI_DEVICE_ID_S626,
-					PCI_SUBVENDOR_ID_S626,
-					PCI_SUBDEVICE_ID_S626,
-					pcidev);
-
-		if ((bus || slot) && pcidev) {
-			/* matches requested bus/slot */
-			if (pcidev->bus->number == bus &&
-				PCI_SLOT(pcidev->devfn) == slot)
-				break;
-		} else {
-			break;
-		}
-	} while (1);
-
-	return pcidev;
-}
-
-static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int s626_attach_pci(struct comedi_device *dev, struct pci_dev *pcidev)
 {
 /*   uint8_t	PollList; */
 /*   uint16_t	AdcData; */
@@ -2487,11 +2455,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
 		return -ENOMEM;
 
-	devpriv->pdev = s626_find_pci(dev, it);
-	if (!devpriv->pdev) {
-		printk(KERN_ERR "s626_attach: Board not present!!!\n");
-		return -ENODEV;
-	}
+	devpriv->pdev = pcidev;
 
 	result = comedi_pci_enable(devpriv->pdev, "s626");
 	if (result < 0) {
@@ -2932,7 +2896,6 @@ static void s626_detach(struct comedi_device *dev)
 		if (devpriv->pdev) {
 			if (devpriv->got_regions)
 				comedi_pci_disable(devpriv->pdev);
-			pci_dev_put(devpriv->pdev);
 		}
 	}
 }
@@ -2940,7 +2903,7 @@ static void s626_detach(struct comedi_device *dev)
 static struct comedi_driver s626_driver = {
 	.driver_name	= "s626",
 	.module		= THIS_MODULE,
-	.attach		= s626_attach,
+	.attach_pci	= s626_attach_pci,
 	.detach		= s626_detach,
 };
 

commit 832defbb58061fedb7a5c43aab7d762afaac2cc9
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:21:30 2012 -0700

    staging: comedi: s626: remove boardinfo
    
    This driver only supports one board type. Move the used board info
    out of the boardinfo struct and remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index f90578e5e727..bac14458536e 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -82,40 +82,6 @@ INSN_CONFIG instructions:
 #define PCI_SUBVENDOR_ID_S626 0x6000
 #define PCI_SUBDEVICE_ID_S626 0x0272
 
-struct s626_board {
-	const char *name;
-	int vendor_id;
-	int device_id;
-	int subvendor_id;
-	int subdevice_id;
-	int ai_chans;
-	int ai_bits;
-	int ao_chans;
-	int ao_bits;
-	int dio_chans;
-	int dio_banks;
-	int enc_chans;
-};
-
-static const struct s626_board s626_boards[] = {
-	{
-	 .name = "s626",
-	 .vendor_id = PCI_VENDOR_ID_S626,
-	 .device_id = PCI_DEVICE_ID_S626,
-	 .subvendor_id = PCI_SUBVENDOR_ID_S626,
-	 .subdevice_id = PCI_SUBDEVICE_ID_S626,
-	 .ai_chans = S626_ADC_CHANNELS,
-	 .ai_bits = 14,
-	 .ao_chans = S626_DAC_CHANNELS,
-	 .ao_bits = 13,
-	 .dio_chans = S626_DIO_CHANNELS,
-	 .dio_banks = S626_DIO_BANKS,
-	 .enc_chans = S626_ENCODER_CHANNELS,
-	 }
-};
-
-#define thisboard ((const struct s626_board *)dev->board_ptr)
-
 struct s626_private {
 	struct pci_dev *pdev;
 	void __iomem *base_addr;
@@ -2484,24 +2450,23 @@ static struct pci_dev *s626_find_pci(struct comedi_device *dev,
 	int slot = it->options[1];
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(s626_boards) && !pcidev; i++) {
-		do {
-			pcidev = pci_get_subsys(s626_boards[i].vendor_id,
-						s626_boards[i].device_id,
-						s626_boards[i].subvendor_id,
-						s626_boards[i].subdevice_id,
-						pcidev);
-
-			if ((bus || slot) && pcidev) {
-				/* matches requested bus/slot */
-				if (pcidev->bus->number == bus &&
-				    PCI_SLOT(pcidev->devfn) == slot)
-					break;
-			} else {
+	do {
+		pcidev = pci_get_subsys(PCI_VENDOR_ID_S626,
+					PCI_DEVICE_ID_S626,
+					PCI_SUBVENDOR_ID_S626,
+					PCI_SUBDEVICE_ID_S626,
+					pcidev);
+
+		if ((bus || slot) && pcidev) {
+			/* matches requested bus/slot */
+			if (pcidev->bus->number == bus &&
+				PCI_SLOT(pcidev->devfn) == slot)
 				break;
-			}
-		} while (1);
-	}
+		} else {
+			break;
+		}
+	} while (1);
+
 	return pcidev;
 }
 
@@ -2581,8 +2546,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	}
 
-	dev->board_ptr = s626_boards;
-	dev->board_name = thisboard->name;
+	dev->board_name = dev->driver->driver_name;
 
 	ret = comedi_alloc_subdevices(dev, 6);
 	if (ret)
@@ -2610,12 +2574,10 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* we support single-ended (ground) and differential */
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_CMD_READ;
-	s->n_chan = thisboard->ai_chans;
+	s->n_chan = S626_ADC_CHANNELS;
 	s->maxdata = (0xffff >> 2);
 	s->range_table = &s626_range_table;
-	s->len_chanlist = thisboard->ai_chans;	/* This is the maximum chanlist
-						   length that the board can
-						   handle */
+	s->len_chanlist = S626_ADC_CHANNELS;
 	s->insn_config = s626_ai_insn_config;
 	s->insn_read = s626_ai_insn_read;
 	s->do_cmd = s626_ai_cmd;
@@ -2626,7 +2588,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* analog output subdevice */
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = thisboard->ao_chans;
+	s->n_chan = S626_DAC_CHANNELS;
 	s->maxdata = (0x3fff);
 	s->range_table = &range_bipolar10;
 	s->insn_write = s626_ao_winsn;
@@ -2672,7 +2634,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* encoder (counter) subdevice */
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;
-	s->n_chan = thisboard->enc_chans;
+	s->n_chan = S626_ENCODER_CHANNELS;
 	s->private = enc_private_data;
 	s->insn_config = s626_enc_insn_config;
 	s->insn_read = s626_enc_insn_read;

commit c14d1769ba81ed084adb450d2fa1bacaee3cd2c7
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jul 2 14:26:24 2012 -0700

    staging: comedi: s626: fix the number of dio channels
    
    The first digital i/o subdevice has its n_chan set to S626_DIO_CHANNELS
    which is defined as 48. This is actually the total number of channels
    provided by all three digital i/o subdevices. Each subdevice only has
    16 channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index bef9649960b8..f90578e5e727 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2636,7 +2636,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* digital I/O subdevice */
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = S626_DIO_CHANNELS;
+	s->n_chan = 16;
 	s->maxdata = 1;
 	s->io_bits = 0xffff;
 	s->private = &dio_private_A;

commit 9c1f1f12472c5b9808e4465cdf882892b19f2f10
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 19:28:01 2012 -0700

    staging: comedi: s626: factor out the find PCI device code
    
    Factor out the code that finds a matching PCI device from attach
    function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 779ae7a104f6..bef9649960b8 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2476,6 +2476,35 @@ static void CountersInit(struct comedi_device *dev)
 	}
 }
 
+static struct pci_dev *s626_find_pci(struct comedi_device *dev,
+				     struct comedi_devconfig *it)
+{
+	struct pci_dev *pcidev = NULL;
+	int bus = it->options[0];
+	int slot = it->options[1];
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(s626_boards) && !pcidev; i++) {
+		do {
+			pcidev = pci_get_subsys(s626_boards[i].vendor_id,
+						s626_boards[i].device_id,
+						s626_boards[i].subvendor_id,
+						s626_boards[i].subdevice_id,
+						pcidev);
+
+			if ((bus || slot) && pcidev) {
+				/* matches requested bus/slot */
+				if (pcidev->bus->number == bus &&
+				    PCI_SLOT(pcidev->devfn) == slot)
+					break;
+			} else {
+				break;
+			}
+		} while (1);
+	}
+	return pcidev;
+}
+
 static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 /*   uint8_t	PollList; */
@@ -2489,36 +2518,17 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	resource_size_t resourceStart;
 	dma_addr_t appdma;
 	struct comedi_subdevice *s;
-	struct pci_dev *pdev = NULL;
 
 	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
 		return -ENOMEM;
 
-	for (i = 0; i < ARRAY_SIZE(s626_boards) && !pdev; i++) {
-		do {
-			pdev = pci_get_subsys(s626_boards[i].vendor_id,
-					      s626_boards[i].device_id,
-					      s626_boards[i].subvendor_id,
-					      s626_boards[i].subdevice_id,
-					      pdev);
-
-			if ((it->options[0] || it->options[1]) && pdev) {
-				/* matches requested bus/slot */
-				if (pdev->bus->number == it->options[0] &&
-				    PCI_SLOT(pdev->devfn) == it->options[1])
-					break;
-			} else
-				break;
-		} while (1);
-	}
-	devpriv->pdev = pdev;
-
-	if (pdev == NULL) {
+	devpriv->pdev = s626_find_pci(dev, it);
+	if (!devpriv->pdev) {
 		printk(KERN_ERR "s626_attach: Board not present!!!\n");
 		return -ENODEV;
 	}
 
-	result = comedi_pci_enable(pdev, "s626");
+	result = comedi_pci_enable(devpriv->pdev, "s626");
 	if (result < 0) {
 		printk(KERN_ERR "s626_attach: comedi_pci_enable fails\n");
 		return -ENODEV;

commit bdf5aa39f7a42fc49903d456baaba11efc4d4243
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 19:27:25 2012 -0700

    staging: comedi: s626: remove private DEBUG macro
    
    The private DEBUG macro defined in this driver outputs a lot
    of function tracing noise. This information might be useful
    when first developing the driver but should not be in the
    mainlined code.
    
    If any of this is needed in the future it should be added back
    using the proper dev_printk interface.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 50656a78b263..779ae7a104f6 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -376,7 +376,6 @@ static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 			 /* Byte1 = EEPROM internal target address. */
 			 | I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not sent. */
 		/*  Abort function and declare error if handshake failed. */
-		DEBUG("I2Cread: error handshake I2Cread  a\n");
 		return 0;
 	}
 	/*  Execute EEPROM read. */
@@ -394,7 +393,6 @@ static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 			 |I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not  sent. */
 
 		/*  Abort function and declare error if handshake failed. */
-		DEBUG("I2Cread: error handshake I2Cread b\n");
 		return 0;
 	}
 	/*  Return copy of EEPROM value. */
@@ -653,7 +651,6 @@ static void LoadTrimDACs(struct comedi_device *dev)
 static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
 {
 	register uint32_t value;
-	/* DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n"); */
 
 	/*  Latch counts and fetch LSW of latched counts value. */
 	value = (uint32_t) DEBIread(dev, k->MyLatchLsw);
@@ -661,8 +658,6 @@ static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
 	/*  Fetch MSW of latched counts and combine with LSW. */
 	value |= ((uint32_t) DEBIread(dev, k->MyLatchLsw + 2) << 16);
 
-	/*  DEBUG FIXME DEBUG("ReadLatch: Read Latch exit\n"); */
-
 	/*  Return latched counts. */
 	return value;
 }
@@ -674,21 +669,16 @@ static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
 static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
 			   uint16_t value)
 {
-	DEBUG("SetLatchSource: SetLatchSource enter 3550\n");
 	DEBIreplace(dev, k->MyCRB,
 		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC)),
 		    (uint16_t) (value << CRBBIT_LATCHSRC));
-
-	DEBUG("SetLatchSource: SetLatchSource exit\n");
 }
 
 /*  Write value into counter preload register. */
 static void Preload(struct comedi_device *dev, struct enc_private *k,
 		    uint32_t value)
 {
-	DEBUG("Preload: preload enter\n");
-	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
-	DEBUG("Preload: preload step 1\n");
+	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);
 	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw + 2),
 		  (uint16_t) (value >> 16));
 }
@@ -719,8 +709,6 @@ static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
 	/* select dio bank */
 	group = chan / 16;
 	bitmask = 1 << (chan - (16 * group));
-	DEBUG("s626_dio_set_irq: enable interrupt on dio channel %d group %d\n",
-	      chan - (16 * group), group);
 
 	/* set channel to capture positive edge */
 	status = DEBIread(dev,
@@ -758,10 +746,6 @@ static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
 static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,
 			      unsigned int mask)
 {
-	DEBUG
-	    ("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n",
-	     mask, group);
-
 	/* disable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
@@ -805,8 +789,6 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	uint8_t group;
 	uint16_t irqbit;
 
-	DEBUG("s626_irq_handler: interrupt request received!!!\n");
-
 	if (dev->attached == 0)
 		return IRQ_NONE;
 	/*  lock to avoid race with comedi_poll */
@@ -824,14 +806,8 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	/* clear interrupt */
 	writel(irqtype, devpriv->base_addr + P_ISR);
 
-	/* do somethings */
-	DEBUG("s626_irq_handler: interrupt type %d\n", irqtype);
-
 	switch (irqtype) {
 	case IRQ_RPS1:		/*  end_of_scan occurs */
-
-		DEBUG("s626_irq_handler: RPS1 irq detected\n");
-
 		/*  manage ai subdevice */
 		s = dev->subdevices;
 		cmd = &(s->async->cmd);
@@ -854,9 +830,6 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 			if (cfc_write_to_buffer(s, tempdata) == 0)
 				printk
 				    ("s626_irq_handler: cfc_write_to_buffer error!\n");
-
-			DEBUG("s626_irq_handler: ai channel %d acquired: %d\n",
-			      i, tempdata);
 		}
 
 		/* end of scan occurs */
@@ -877,23 +850,12 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 			irqstatus = 0;
 		}
 
-		if (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT) {
-			DEBUG
-			    ("s626_irq_handler: enable interrupt on dio channel %d\n",
-			     cmd->scan_begin_arg);
-
+		if (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT)
 			s626_dio_set_irq(dev, cmd->scan_begin_arg);
-
-			DEBUG("s626_irq_handler: External trigger is set!!!\n");
-		}
 		/*  tell comedi that data is there */
-		DEBUG("s626_irq_handler: events %d\n", s->async->events);
 		comedi_event(dev, s);
 		break;
 	case IRQ_GPIO3:	/* check dio and conter interrupt */
-
-		DEBUG("s626_irq_handler: GPIO3 irq detected\n");
-
 		/*  manage ai subdevice */
 		s = dev->subdevices;
 		cmd = &(s->async->cmd);
@@ -913,36 +875,18 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 			/* check if interrupt is generated from dio channels */
 			if (irqbit) {
 				s626_dio_reset_irq(dev, group, irqbit);
-				DEBUG
-				    ("s626_irq_handler: check interrupt on dio group %d %d\n",
-				     group, i);
 				if (devpriv->ai_cmd_running) {
 					/* check if interrupt is an ai acquisition start trigger */
 					if ((irqbit >> (cmd->start_arg -
 							(16 * group)))
 					    == 1 && cmd->start_src == TRIG_EXT) {
-						DEBUG
-						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
-						     cmd->start_arg);
-
 						/*  Start executing the RPS program. */
 						MC_ENABLE(P_MC1, MC1_ERPS1);
 
-						DEBUG
-						    ("s626_irq_handler: acquisition start triggered!!!\n");
-
 						if (cmd->scan_begin_src ==
 						    TRIG_EXT) {
-							DEBUG
-							    ("s626_ai_cmd: enable interrupt on dio channel %d\n",
-							     cmd->
-							     scan_begin_arg);
-
 							s626_dio_set_irq(dev,
 									 cmd->scan_begin_arg);
-
-							DEBUG
-							    ("s626_irq_handler: External scan trigger is set!!!\n");
 						}
 					}
 					if ((irqbit >> (cmd->scan_begin_arg -
@@ -950,33 +894,16 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 					    == 1
 					    && cmd->scan_begin_src ==
 					    TRIG_EXT) {
-						DEBUG
-						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
-						     cmd->scan_begin_arg);
-
 						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
-						DEBUG
-						    ("s626_irq_handler: scan triggered!!! %d\n",
-						     devpriv->ai_sample_count);
 						if (cmd->convert_src ==
 						    TRIG_EXT) {
-
-							DEBUG
-							    ("s626_ai_cmd: enable interrupt on dio channel %d group %d\n",
-							     cmd->convert_arg -
-							     (16 * group),
-							     group);
-
 							devpriv->ai_convert_count
 							    = cmd->chanlist_len;
 
 							s626_dio_set_irq(dev,
 									 cmd->convert_arg);
-
-							DEBUG
-							    ("s626_irq_handler: External convert trigger is set!!!\n");
 						}
 
 						if (cmd->convert_src ==
@@ -992,32 +919,15 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 							(16 * group)))
 					    == 1
 					    && cmd->convert_src == TRIG_EXT) {
-						DEBUG
-						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
-						     cmd->convert_arg);
-
 						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
-						DEBUG
-						    ("s626_irq_handler: adc convert triggered!!!\n");
-
 						devpriv->ai_convert_count--;
 
 						if (devpriv->ai_convert_count >
 						    0) {
-
-							DEBUG
-							    ("s626_ai_cmd: enable interrupt on dio channel %d group %d\n",
-							     cmd->convert_arg -
-							     (16 * group),
-							     group);
-
 							s626_dio_set_irq(dev,
 									 cmd->convert_arg);
-
-							DEBUG
-							    ("s626_irq_handler: External trigger is set!!!\n");
 						}
 					}
 				}
@@ -1029,44 +939,31 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 		irqbit = DEBIread(dev, LP_RDMISC2);
 
 		/* check interrupt on counters */
-		DEBUG("s626_irq_handler: check counters interrupt %d\n",
-		      irqbit);
-
 		if (irqbit & IRQ_COINT1A) {
-			DEBUG
-			    ("s626_irq_handler: interrupt on counter 1A overflow\n");
 			k = &encpriv[0];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT2A) {
-			DEBUG
-			    ("s626_irq_handler: interrupt on counter 2A overflow\n");
 			k = &encpriv[1];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT3A) {
-			DEBUG
-			    ("s626_irq_handler: interrupt on counter 3A overflow\n");
 			k = &encpriv[2];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT1B) {
-			DEBUG
-			    ("s626_irq_handler: interrupt on counter 1B overflow\n");
 			k = &encpriv[3];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT2B) {
-			DEBUG
-			    ("s626_irq_handler: interrupt on counter 2B overflow\n");
 			k = &encpriv[4];
 
 			/* clear interrupt capture flag */
@@ -1078,34 +975,23 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 					k->SetEnable(dev, k, CLKENAB_INDEX);
 
 				if (cmd->convert_src == TRIG_TIMER) {
-					DEBUG
-					    ("s626_irq_handler: conver timer trigger!!! %d\n",
-					     devpriv->ai_convert_count);
-
 					/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 					MC_ENABLE(P_MC2, MC2_ADC_RPS);
 				}
 			}
 		}
 		if (irqbit & IRQ_COINT3B) {
-			DEBUG
-			    ("s626_irq_handler: interrupt on counter 3B overflow\n");
 			k = &encpriv[5];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 
 			if (cmd->scan_begin_src == TRIG_TIMER) {
-				DEBUG
-				    ("s626_irq_handler: scan timer trigger!!!\n");
-
 				/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 				MC_ENABLE(P_MC2, MC2_ADC_RPS);
 			}
 
 			if (cmd->convert_src == TRIG_TIMER) {
-				DEBUG
-				    ("s626_irq_handler: convert timer trigger is set\n");
 				k = &encpriv[4];
 				devpriv->ai_convert_count = cmd->chanlist_len;
 				k->SetEnable(dev, k, CLKENAB_ALWAYS);
@@ -1116,8 +1002,6 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	/* enable interrupt */
 	writel(irqstatus, devpriv->base_addr + P_IER);
 
-	DEBUG("s626_irq_handler: exit interrupt service routine.\n");
-
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 	return IRQ_HANDLED;
 }
@@ -1146,7 +1030,6 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 	/*  Construct RPS program in RPSBuf DMA buffer */
 
 	if (cmd != NULL && cmd->scan_begin_src != TRIG_FOLLOW) {
-		DEBUG("ResetADC: scan_begin pause inserted\n");
 		/*  Wait for Start trigger. */
 		*pRPS++ = RPS_PAUSE | RPS_SIGADC;
 		*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
@@ -1236,7 +1119,6 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 		}
 
 		if (cmd != NULL && cmd->convert_src != TRIG_NOW) {
-			DEBUG("ResetADC: convert pause inserted\n");
 			/*  Wait for Start trigger. */
 			*pRPS++ = RPS_PAUSE | RPS_SIGADC;
 			*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
@@ -1268,7 +1150,6 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 			break;	/*  Exit poll list processing loop. */
 		}
 	}
-	DEBUG("ResetADC: ADC items %d\n", devpriv->AdcItems);
 
 	/* VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
 	 * ADC to stabilize for 2 microseconds before starting the final
@@ -1305,7 +1186,6 @@ static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 
 	/* invoke interrupt */
 	if (devpriv->ai_cmd_running == 1) {
-		DEBUG("ResetADC: insert irq in ADC RPS task\n");
 		*pRPS++ = RPS_IRQ;
 	}
 	/*  Restart RPS program at its beginning. */
@@ -1329,8 +1209,6 @@ static int s626_ai_insn_config(struct comedi_device *dev,
 /*   register uint8_t	i; */
 /*   register int32_t	*readaddr; */
 
-/*   DEBUG("as626_ai_rinsn: ai_rinsn enter\n");  */
-
 /*   Trigger ADC scan loop start by setting RPS Signal 0. */
 /*   MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
 
@@ -1346,11 +1224,9 @@ static int s626_ai_insn_config(struct comedi_device *dev,
 /*  Convert ADC data to 16-bit integer values and copy to application buffer. */
 /*   for ( i = 0; i < devpriv->AdcItems; i++ ) { */
 /*     *data = s626_ai_reg_to_uint( *readaddr++ ); */
-/*     DEBUG("s626_ai_rinsn: data %d\n",*data); */
 /*     data++; */
 /*   } */
 
-/*   DEBUG("s626_ai_rinsn: ai_rinsn escape\n"); */
 /*   return i; */
 /* } */
 
@@ -1370,8 +1246,6 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	 * corresponding interrupt to be generated if enabled
 	 */
 
-	DEBUG("s626_ai_insn_read: entering\n");
-
 	/* Convert application's ADC specification into form
 	 *  appropriate for register programming.
 	 */
@@ -1448,8 +1322,6 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	if (n != 0)
 		data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
 
-	DEBUG("s626_ai_insn_read: samples %d, data %d\n", n, data[n - 1]);
-
 	return n;
 }
 
@@ -1476,15 +1348,11 @@ static int s626_ai_inttrig(struct comedi_device *dev,
 	if (trignum != 0)
 		return -EINVAL;
 
-	DEBUG("s626_ai_inttrig: trigger adc start...");
-
 	/*  Start executing the RPS program. */
 	MC_ENABLE(P_MC1, MC1_ERPS1);
 
 	s->async->inttrig = NULL;
 
-	DEBUG(" done\n");
-
 	return 1;
 }
 
@@ -1559,8 +1427,6 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct enc_private *k;
 	int tick;
 
-	DEBUG("s626_ai_cmd: entering command function\n");
-
 	if (devpriv->ai_cmd_running) {
 		printk(KERN_ERR "s626_ai_cmd: Another ai_cmd is running %d\n",
 		       dev->minor);
@@ -1580,12 +1446,8 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_cmd_running = 0;
 
 	/*  test if cmd is valid */
-	if (cmd == NULL) {
-		DEBUG("s626_ai_cmd: NULL command\n");
+	if (cmd == NULL)
 		return -EINVAL;
-	} else {
-		DEBUG("s626_ai_cmd: command received!!!\n");
-	}
 
 	if (dev->irq == 0) {
 		comedi_error(dev,
@@ -1609,18 +1471,11 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
 		k->SetEnable(dev, k, CLKENAB_ALWAYS);
-
-		DEBUG("s626_ai_cmd: scan trigger timer is set with value %d\n",
-		      tick);
-
 		break;
 	case TRIG_EXT:
 		/*  set the digital line and interrupt for scan trigger */
 		if (cmd->start_src != TRIG_EXT)
 			s626_dio_set_irq(dev, cmd->scan_begin_arg);
-
-		DEBUG("s626_ai_cmd: External scan trigger is set!!!\n");
-
 		break;
 	}
 
@@ -1636,19 +1491,12 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
 		k->SetEnable(dev, k, CLKENAB_INDEX);
-
-		DEBUG
-		    ("s626_ai_cmd: convert trigger timer is set with value %d\n",
-		     tick);
 		break;
 	case TRIG_EXT:
 		/*  set the digital line and interrupt for convert trigger */
 		if (cmd->scan_begin_src != TRIG_EXT
 		    && cmd->start_src == TRIG_EXT)
 			s626_dio_set_irq(dev, cmd->convert_arg);
-
-		DEBUG("s626_ai_cmd: External convert trigger is set!!!\n");
-
 		break;
 	}
 
@@ -1675,15 +1523,12 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/*  Start executing the RPS program. */
 		MC_ENABLE(P_MC1, MC1_ERPS1);
 
-		DEBUG("s626_ai_cmd: ADC triggered\n");
 		s->async->inttrig = NULL;
 		break;
 	case TRIG_EXT:
 		/* configure DIO channel for acquisition trigger */
 		s626_dio_set_irq(dev, cmd->start_arg);
 
-		DEBUG("s626_ai_cmd: External start trigger is set!!!\n");
-
 		s->async->inttrig = NULL;
 		break;
 	case TRIG_INT:
@@ -1694,8 +1539,6 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* enable interrupt */
 	writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->base_addr + P_IER);
 
-	DEBUG("s626_ai_cmd: command function terminated\n");
-
 	return 0;
 }
 
@@ -1938,7 +1781,6 @@ static void s626_dio_init(struct comedi_device *dev)
 		DEBIwrite(dev, diopriv->WRDOut, 0);	/*  Program all outputs */
 		/*  to inactive state. */
 	}
-	DEBUG("s626_dio_init: DIO initialized\n");
 }
 
 /* DIO devices are slightly special.  Although it is possible to
@@ -2023,8 +1865,6 @@ static int s626_enc_insn_config(struct comedi_device *dev,
 	uint16_t enab = CLKENAB_ALWAYS;
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
-	DEBUG("s626_enc_insn_config: encoder config\n");
-
 	/*   (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
 	k->SetMode(dev, k, Setup, TRUE);
@@ -2044,14 +1884,9 @@ static int s626_enc_insn_read(struct comedi_device *dev,
 	int n;
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
-	DEBUG("s626_enc_insn_read: encoder read channel %d\n",
-	      CR_CHAN(insn->chanspec));
-
 	for (n = 0; n < insn->n; n++)
 		data[n] = ReadLatch(dev, k);
 
-	DEBUG("s626_enc_insn_read: encoder sample %d\n", data[n]);
-
 	return n;
 }
 
@@ -2062,9 +1897,6 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
-	DEBUG("s626_enc_insn_write: encoder write channel %d\n",
-	      CR_CHAN(insn->chanspec));
-
 	/*  Set the preload register */
 	Preload(dev, k, data[0]);
 
@@ -2074,8 +1906,6 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 	k->PulseIndex(dev, k);
 	k->SetLoadTrig(dev, k, 2);
 
-	DEBUG("s626_enc_insn_write: End encoder write\n");
-
 	return 1;
 }
 
@@ -2093,7 +1923,6 @@ static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
 	void *vbptr;
 	dma_addr_t vpptr;
 
-	DEBUG("CloseDMAB: Entering S626DRV_CloseDMAB():\n");
 	if (pdma == NULL)
 		return;
 	/* find the matching allocation from the board struct */
@@ -2104,9 +1933,6 @@ static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
 		pci_free_consistent(devpriv->pdev, bsize, vbptr, vpptr);
 		pdma->LogicalBase = NULL;
 		pdma->PhysicalBase = 0;
-
-		DEBUG("CloseDMAB(): Logical=%p, bsize=%d, Physical=0x%x\n",
-		      vbptr, bsize, (uint32_t) vpptr);
 	}
 }
 
@@ -2337,7 +2163,6 @@ static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
 static void SetEnable_A(struct comedi_device *dev, struct enc_private *k,
 			uint16_t enab)
 {
-	DEBUG("SetEnable_A: SetEnable_A enter 3541\n");
 	DEBIreplace(dev, k->MyCRB,
 		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)),
 		    (uint16_t) (enab << CRBBIT_CLKENAB_A));
@@ -2506,7 +2331,6 @@ static uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k)
 
 /* static void SetIndexSrc(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */
 /* { */
-/*   DEBUG("SetIndexSrc: set index src enter 3700\n"); */
 /*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_INDXSRC ) | ( (value != 0) << STDBIT_INDXSRC ) ), FALSE ); */
 /* } */
 
@@ -2521,11 +2345,8 @@ static void PulseIndex_A(struct comedi_device *dev, struct enc_private *k)
 {
 	register uint16_t cra;
 
-	DEBUG("PulseIndex_A: pulse index enter\n");
-
 	cra = DEBIread(dev, k->MyCRA);	/*  Pulse index. */
 	DEBIwrite(dev, k->MyCRA, (uint16_t) (cra ^ CRAMSK_INDXPOL_A));
-	DEBUG("PulseIndex_A: pulse index step1\n");
 	DEBIwrite(dev, k->MyCRA, cra);
 }
 
@@ -2653,8 +2474,6 @@ static void CountersInit(struct comedi_device *dev)
 		k->ResetCapFlags(dev, k);
 		k->SetEnable(dev, k, CLKENAB_ALWAYS);
 	}
-	DEBUG("CountersInit: counters initialized\n");
-
 }
 
 static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -2722,7 +2541,6 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		writel(MC1_SOFT_RESET, devpriv->base_addr + P_MC1);
 
 		/* DMA FIXME DMA// */
-		DEBUG("s626_attach: DMA ALLOCATION\n");
 
 		/* adc buffer allocation */
 		devpriv->allocatedBuf = 0;
@@ -2737,11 +2555,6 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		devpriv->ANABuf.PhysicalBase = appdma;
 
-		DEBUG
-		    ("s626_attach: AllocDMAB ADC Logical=%p, bsize=%d, Physical=0x%x\n",
-		     devpriv->ANABuf.LogicalBase, DMABUF_SIZE,
-		     (uint32_t) devpriv->ANABuf.PhysicalBase);
-
 		devpriv->allocatedBuf++;
 
 		devpriv->RPSBuf.LogicalBase =
@@ -2754,11 +2567,6 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		devpriv->RPSBuf.PhysicalBase = appdma;
 
-		DEBUG
-		    ("s626_attach: AllocDMAB RPS Logical=%p, bsize=%d, Physical=0x%x\n",
-		     devpriv->RPSBuf.LogicalBase, DMABUF_SIZE,
-		     (uint32_t) devpriv->RPSBuf.PhysicalBase);
-
 		devpriv->allocatedBuf++;
 
 	}
@@ -2786,9 +2594,6 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	}
 
-	DEBUG("s626_attach: -- it opts  %d,%d --\n",
-	      it->options[0], it->options[1]);
-
 	s = dev->subdevices + 0;
 	/* analog input subdevice */
 	dev->read_subdev = s;
@@ -2887,11 +2692,6 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		       | DEBI_CFG_INTEL);	/*  Intel-compatible */
 		/*  local bus (DEBI */
 		/*  never times out). */
-		DEBUG("s626_attach: %d debi init -- %d\n",
-		      DEBI_CFG_SLAVE16 | (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
-		      DEBI_SWAP | DEBI_CFG_INTEL,
-		      DEBI_CFG_INTEL | DEBI_CFG_TOQ | DEBI_CFG_INCQ |
-		      DEBI_CFG_16Q);
 
 		/* DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ */
 		/* | DEBI_CFG_INCQ| DEBI_CFG_16Q); //end */
@@ -3128,9 +2928,6 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		/*  writel(IRQ_GPIO3 | IRQ_RPS1,devpriv->base_addr+P_IER); */
 	}
 
-	DEBUG("s626_attach: comedi%d s626 attached %04x\n", dev->minor,
-	      (uint32_t) devpriv->base_addr);
-
 	return 1;
 }
 

commit e3eb08d0f91ff6afab323fa5e3342f3c4a3e4a73
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 19:26:56 2012 -0700

    staging: comedi: s626: remove forward declarations 7
    
    Move up the remaining functions needed to remove the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index d7d72ac16457..50656a78b263 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -230,16 +230,6 @@ struct enc_private {
 
 #define encpriv ((struct enc_private *)(dev->subdevices+5)->private)
 
-static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
-			    int tick);
-static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k);
-static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
-			   uint16_t value);
-static void Preload(struct comedi_device *dev, struct enc_private *k,
-		    uint32_t value);
-
-/*  Counter objects constructor. */
-
 /*  Counter overflow/index event flag masks for RDMISC2. */
 #define INDXMASK(C)		(1 << (((C) > 2) ? ((C) * 2 - 1) : ((C) * 2 +  4)))
 #define OVERMASK(C)		(1 << (((C) > 2) ? ((C) * 2 + 5) : ((C) * 2 + 10)))
@@ -652,6 +642,57 @@ static void LoadTrimDACs(struct comedi_device *dev)
 		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
 }
 
+/* ******  COUNTER FUNCTIONS  ******* */
+/* All counter functions address a specific counter by means of the
+ * "Counter" argument, which is a logical counter number.  The Counter
+ * argument may have any of the following legal values: 0=0A, 1=1A,
+ * 2=2A, 3=0B, 4=1B, 5=2B.
+ */
+
+/*  Read a counter's output latch. */
+static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
+{
+	register uint32_t value;
+	/* DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n"); */
+
+	/*  Latch counts and fetch LSW of latched counts value. */
+	value = (uint32_t) DEBIread(dev, k->MyLatchLsw);
+
+	/*  Fetch MSW of latched counts and combine with LSW. */
+	value |= ((uint32_t) DEBIread(dev, k->MyLatchLsw + 2) << 16);
+
+	/*  DEBUG FIXME DEBUG("ReadLatch: Read Latch exit\n"); */
+
+	/*  Return latched counts. */
+	return value;
+}
+
+/* Return/set a counter pair's latch trigger source.  0: On read
+ * access, 1: A index latches A, 2: B index latches B, 3: A overflow
+ * latches B.
+ */
+static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
+			   uint16_t value)
+{
+	DEBUG("SetLatchSource: SetLatchSource enter 3550\n");
+	DEBIreplace(dev, k->MyCRB,
+		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC)),
+		    (uint16_t) (value << CRBBIT_LATCHSRC));
+
+	DEBUG("SetLatchSource: SetLatchSource exit\n");
+}
+
+/*  Write value into counter preload register. */
+static void Preload(struct comedi_device *dev, struct enc_private *k,
+		    uint32_t value)
+{
+	DEBUG("Preload: preload enter\n");
+	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
+	DEBUG("Preload: preload step 1\n");
+	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw + 2),
+		  (uint16_t) (value >> 16));
+}
+
 static unsigned int s626_ai_reg_to_uint(int data)
 {
 	unsigned int tempdata;
@@ -1475,6 +1516,40 @@ static int s626_ns_to_timer(int *nanosec, int round_mode)
 	return divider - 1;
 }
 
+static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
+			    int tick)
+{
+	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
+	    /*  index. */
+	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+	    (CLKSRC_TIMER << BF_CLKSRC) |	/*  Operating mode is Timer. */
+	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+	    (CNTDIR_DOWN << BF_CLKPOL) |	/*  Count direction is Down. */
+	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
+	    (CLKENAB_INDEX << BF_CLKENAB);
+	uint16_t valueSrclatch = LATCHSRC_A_INDXA;
+	/*   uint16_t enab=CLKENAB_ALWAYS; */
+
+	k->SetMode(dev, k, Setup, FALSE);
+
+	/*  Set the preload register */
+	Preload(dev, k, tick);
+
+	/*  Software index pulse forces the preload register to load */
+	/*  into the counter */
+	k->SetLoadTrig(dev, k, 0);
+	k->PulseIndex(dev, k);
+
+	/* set reload on counter overflow */
+	k->SetLoadTrig(dev, k, 1);
+
+	/* set interrupt on overflow */
+	k->SetIntSrc(dev, k, INTSRC_OVER);
+
+	SetLatchSource(dev, k, valueSrclatch);
+	/*   k->SetEnable(dev,k,(uint16_t)(enab != 0)); */
+}
+
 /*  TO COMPLETE  */
 static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
@@ -2004,40 +2079,6 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 	return 1;
 }
 
-static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
-			    int tick)
-{
-	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
-	    /*  index. */
-	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
-	    (CLKSRC_TIMER << BF_CLKSRC) |	/*  Operating mode is Timer. */
-	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
-	    (CNTDIR_DOWN << BF_CLKPOL) |	/*  Count direction is Down. */
-	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
-	    (CLKENAB_INDEX << BF_CLKENAB);
-	uint16_t valueSrclatch = LATCHSRC_A_INDXA;
-	/*   uint16_t enab=CLKENAB_ALWAYS; */
-
-	k->SetMode(dev, k, Setup, FALSE);
-
-	/*  Set the preload register */
-	Preload(dev, k, tick);
-
-	/*  Software index pulse forces the preload register to load */
-	/*  into the counter */
-	k->SetLoadTrig(dev, k, 0);
-	k->PulseIndex(dev, k);
-
-	/* set reload on counter overflow */
-	k->SetLoadTrig(dev, k, 1);
-
-	/* set interrupt on overflow */
-	k->SetIntSrc(dev, k, INTSRC_OVER);
-
-	SetLatchSource(dev, k, valueSrclatch);
-	/*   k->SetEnable(dev,k,(uint16_t)(enab != 0)); */
-}
-
 static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
 {
 	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	/*  enab writes to */
@@ -2069,36 +2110,8 @@ static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
 	}
 }
 
-/* ******  COUNTER FUNCTIONS  ******* */
-/* All counter functions address a specific counter by means of the
- * "Counter" argument, which is a logical counter number.  The Counter
- * argument may have any of the following legal values: 0=0A, 1=1A,
- * 2=2A, 3=0B, 4=1B, 5=2B.
- */
-
-/* Forward declarations for functions that are common to both A and B counters: */
-
 /* ******  PRIVATE COUNTER FUNCTIONS ****** */
 
-/*  Read a counter's output latch. */
-
-static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
-{
-	register uint32_t value;
-	/* DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n"); */
-
-	/*  Latch counts and fetch LSW of latched counts value. */
-	value = (uint32_t) DEBIread(dev, k->MyLatchLsw);
-
-	/*  Fetch MSW of latched counts and combine with LSW. */
-	value |= ((uint32_t) DEBIread(dev, k->MyLatchLsw + 2) << 16);
-
-	/*  DEBUG FIXME DEBUG("ReadLatch: Read Latch exit\n"); */
-
-	/*  Return latched counts. */
-	return value;
-}
-
 /*  Reset a counter's index and overflow event capture flags. */
 
 static void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k)
@@ -2348,22 +2361,6 @@ static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k)
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_B) & 1;
 }
 
-/* Return/set a counter pair's latch trigger source.  0: On read
- * access, 1: A index latches A, 2: B index latches B, 3: A overflow
- * latches B.
- */
-
-static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
-			   uint16_t value)
-{
-	DEBUG("SetLatchSource: SetLatchSource enter 3550\n");
-	DEBIreplace(dev, k->MyCRB,
-		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC)),
-		    (uint16_t) (value << CRBBIT_LATCHSRC));
-
-	DEBUG("SetLatchSource: SetLatchSource exit\n");
-}
-
 /*
  * static uint16_t GetLatchSource(struct comedi_device *dev, struct enc_private *k )
  * {
@@ -2541,18 +2538,6 @@ static void PulseIndex_B(struct comedi_device *dev, struct enc_private *k)
 	DEBIwrite(dev, k->MyCRB, crb);
 }
 
-/*  Write value into counter preload register. */
-
-static void Preload(struct comedi_device *dev, struct enc_private *k,
-		    uint32_t value)
-{
-	DEBUG("Preload: preload enter\n");
-	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
-	DEBUG("Preload: preload step 1\n");
-	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw + 2),
-		  (uint16_t) (value >> 16));
-}
-
 static struct enc_private enc_private_data[] = {
 	{
 		.GetEnable	= GetEnable_A,

commit 878cf9547f7985dd260dec4a4247840ecb4ba225
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 19:26:31 2012 -0700

    staging: comedi: s626: remove forward declarations 6
    
    Move the enc_private_data definition down to remove the need
    for the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index cc18bf06a243..d7d72ac16457 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -233,36 +233,8 @@ struct enc_private {
 static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 			    int tick);
 static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k);
-static void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k);
-static void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k);
-static uint16_t GetMode_A(struct comedi_device *dev, struct enc_private *k);
-static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k);
-static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
-		      uint16_t Setup, uint16_t DisableIntSrc);
-static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
-		      uint16_t Setup, uint16_t DisableIntSrc);
-static void SetEnable_A(struct comedi_device *dev, struct enc_private *k,
-			uint16_t enab);
-static void SetEnable_B(struct comedi_device *dev, struct enc_private *k,
-			uint16_t enab);
-static uint16_t GetEnable_A(struct comedi_device *dev, struct enc_private *k);
-static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k);
 static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
 			   uint16_t value);
-static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k,
-			  uint16_t Trig);
-static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k,
-			  uint16_t Trig);
-static uint16_t GetLoadTrig_A(struct comedi_device *dev, struct enc_private *k);
-static uint16_t GetLoadTrig_B(struct comedi_device *dev, struct enc_private *k);
-static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
-			uint16_t IntSource);
-static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
-			uint16_t IntSource);
-static uint16_t GetIntSrc_A(struct comedi_device *dev, struct enc_private *k);
-static uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k);
-static void PulseIndex_A(struct comedi_device *dev, struct enc_private *k);
-static void PulseIndex_B(struct comedi_device *dev, struct enc_private *k);
 static void Preload(struct comedi_device *dev, struct enc_private *k,
 		    uint32_t value);
 
@@ -276,106 +248,6 @@ static void Preload(struct comedi_device *dev, struct enc_private *k,
 /*  Translation table to map IntSrc into equivalent RDMISC2 event flag  bits. */
 /* static const uint16_t EventBits[][4] = { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) }; */
 
-/* struct enc_private; */
-static struct enc_private enc_private_data[] = {
-	{
-	 .GetEnable = GetEnable_A,
-	 .GetIntSrc = GetIntSrc_A,
-	 .GetLoadTrig = GetLoadTrig_A,
-	 .GetMode = GetMode_A,
-	 .PulseIndex = PulseIndex_A,
-	 .SetEnable = SetEnable_A,
-	 .SetIntSrc = SetIntSrc_A,
-	 .SetLoadTrig = SetLoadTrig_A,
-	 .SetMode = SetMode_A,
-	 .ResetCapFlags = ResetCapFlags_A,
-	 .MyCRA = LP_CR0A,
-	 .MyCRB = LP_CR0B,
-	 .MyLatchLsw = LP_CNTR0ALSW,
-	 .MyEventBits = EVBITS(0),
-	 },
-	{
-	 .GetEnable = GetEnable_A,
-	 .GetIntSrc = GetIntSrc_A,
-	 .GetLoadTrig = GetLoadTrig_A,
-	 .GetMode = GetMode_A,
-	 .PulseIndex = PulseIndex_A,
-	 .SetEnable = SetEnable_A,
-	 .SetIntSrc = SetIntSrc_A,
-	 .SetLoadTrig = SetLoadTrig_A,
-	 .SetMode = SetMode_A,
-	 .ResetCapFlags = ResetCapFlags_A,
-	 .MyCRA = LP_CR1A,
-	 .MyCRB = LP_CR1B,
-	 .MyLatchLsw = LP_CNTR1ALSW,
-	 .MyEventBits = EVBITS(1),
-	 },
-	{
-	 .GetEnable = GetEnable_A,
-	 .GetIntSrc = GetIntSrc_A,
-	 .GetLoadTrig = GetLoadTrig_A,
-	 .GetMode = GetMode_A,
-	 .PulseIndex = PulseIndex_A,
-	 .SetEnable = SetEnable_A,
-	 .SetIntSrc = SetIntSrc_A,
-	 .SetLoadTrig = SetLoadTrig_A,
-	 .SetMode = SetMode_A,
-	 .ResetCapFlags = ResetCapFlags_A,
-	 .MyCRA = LP_CR2A,
-	 .MyCRB = LP_CR2B,
-	 .MyLatchLsw = LP_CNTR2ALSW,
-	 .MyEventBits = EVBITS(2),
-	 },
-	{
-	 .GetEnable = GetEnable_B,
-	 .GetIntSrc = GetIntSrc_B,
-	 .GetLoadTrig = GetLoadTrig_B,
-	 .GetMode = GetMode_B,
-	 .PulseIndex = PulseIndex_B,
-	 .SetEnable = SetEnable_B,
-	 .SetIntSrc = SetIntSrc_B,
-	 .SetLoadTrig = SetLoadTrig_B,
-	 .SetMode = SetMode_B,
-	 .ResetCapFlags = ResetCapFlags_B,
-	 .MyCRA = LP_CR0A,
-	 .MyCRB = LP_CR0B,
-	 .MyLatchLsw = LP_CNTR0BLSW,
-	 .MyEventBits = EVBITS(3),
-	 },
-	{
-	 .GetEnable = GetEnable_B,
-	 .GetIntSrc = GetIntSrc_B,
-	 .GetLoadTrig = GetLoadTrig_B,
-	 .GetMode = GetMode_B,
-	 .PulseIndex = PulseIndex_B,
-	 .SetEnable = SetEnable_B,
-	 .SetIntSrc = SetIntSrc_B,
-	 .SetLoadTrig = SetLoadTrig_B,
-	 .SetMode = SetMode_B,
-	 .ResetCapFlags = ResetCapFlags_B,
-	 .MyCRA = LP_CR1A,
-	 .MyCRB = LP_CR1B,
-	 .MyLatchLsw = LP_CNTR1BLSW,
-	 .MyEventBits = EVBITS(4),
-	 },
-	{
-	 .GetEnable = GetEnable_B,
-	 .GetIntSrc = GetIntSrc_B,
-	 .GetLoadTrig = GetLoadTrig_B,
-	 .GetMode = GetMode_B,
-	 .PulseIndex = PulseIndex_B,
-	 .SetEnable = SetEnable_B,
-	 .SetIntSrc = SetIntSrc_B,
-	 .SetLoadTrig = SetLoadTrig_B,
-	 .SetMode = SetMode_B,
-	 .ResetCapFlags = ResetCapFlags_B,
-	 .MyCRA = LP_CR2A,
-	 .MyCRB = LP_CR2B,
-	 .MyLatchLsw = LP_CNTR2BLSW,
-	 .MyEventBits = EVBITS(5),
-	 },
-};
-
 /*  enab/disable a function or test status bit(s) that are accessed */
 /*  through Main Control Registers 1 or 2. */
 #define MC_ENABLE(REGADRS, CTRLWORD)	writel(((uint32_t)(CTRLWORD) << 16) | (uint32_t)(CTRLWORD), devpriv->base_addr+(REGADRS))
@@ -2681,6 +2553,100 @@ static void Preload(struct comedi_device *dev, struct enc_private *k,
 		  (uint16_t) (value >> 16));
 }
 
+static struct enc_private enc_private_data[] = {
+	{
+		.GetEnable	= GetEnable_A,
+		.GetIntSrc	= GetIntSrc_A,
+		.GetLoadTrig	= GetLoadTrig_A,
+		.GetMode	= GetMode_A,
+		.PulseIndex	= PulseIndex_A,
+		.SetEnable	= SetEnable_A,
+		.SetIntSrc	= SetIntSrc_A,
+		.SetLoadTrig	= SetLoadTrig_A,
+		.SetMode	= SetMode_A,
+		.ResetCapFlags	= ResetCapFlags_A,
+		.MyCRA		= LP_CR0A,
+		.MyCRB		= LP_CR0B,
+		.MyLatchLsw	= LP_CNTR0ALSW,
+		.MyEventBits	= EVBITS(0),
+	}, {
+		.GetEnable	= GetEnable_A,
+		.GetIntSrc	= GetIntSrc_A,
+		.GetLoadTrig	= GetLoadTrig_A,
+		.GetMode	= GetMode_A,
+		.PulseIndex	= PulseIndex_A,
+		.SetEnable	= SetEnable_A,
+		.SetIntSrc	= SetIntSrc_A,
+		.SetLoadTrig	= SetLoadTrig_A,
+		.SetMode	= SetMode_A,
+		.ResetCapFlags	= ResetCapFlags_A,
+		.MyCRA		= LP_CR1A,
+		.MyCRB		= LP_CR1B,
+		.MyLatchLsw	= LP_CNTR1ALSW,
+		.MyEventBits	= EVBITS(1),
+	}, {
+		.GetEnable	= GetEnable_A,
+		.GetIntSrc	= GetIntSrc_A,
+		.GetLoadTrig	= GetLoadTrig_A,
+		.GetMode	= GetMode_A,
+		.PulseIndex	= PulseIndex_A,
+		.SetEnable	= SetEnable_A,
+		.SetIntSrc	= SetIntSrc_A,
+		.SetLoadTrig	= SetLoadTrig_A,
+		.SetMode	= SetMode_A,
+		.ResetCapFlags	= ResetCapFlags_A,
+		.MyCRA		= LP_CR2A,
+		.MyCRB		= LP_CR2B,
+		.MyLatchLsw	= LP_CNTR2ALSW,
+		.MyEventBits	= EVBITS(2),
+	}, {
+		.GetEnable	= GetEnable_B,
+		.GetIntSrc	= GetIntSrc_B,
+		.GetLoadTrig	= GetLoadTrig_B,
+		.GetMode	= GetMode_B,
+		.PulseIndex	= PulseIndex_B,
+		.SetEnable	= SetEnable_B,
+		.SetIntSrc	= SetIntSrc_B,
+		.SetLoadTrig	= SetLoadTrig_B,
+		.SetMode	= SetMode_B,
+		.ResetCapFlags	= ResetCapFlags_B,
+		.MyCRA		= LP_CR0A,
+		.MyCRB		= LP_CR0B,
+		.MyLatchLsw	= LP_CNTR0BLSW,
+		.MyEventBits	= EVBITS(3),
+	}, {
+		.GetEnable	= GetEnable_B,
+		.GetIntSrc	= GetIntSrc_B,
+		.GetLoadTrig	= GetLoadTrig_B,
+		.GetMode	= GetMode_B,
+		.PulseIndex	= PulseIndex_B,
+		.SetEnable	= SetEnable_B,
+		.SetIntSrc	= SetIntSrc_B,
+		.SetLoadTrig	= SetLoadTrig_B,
+		.SetMode	= SetMode_B,
+		.ResetCapFlags	= ResetCapFlags_B,
+		.MyCRA		= LP_CR1A,
+		.MyCRB		= LP_CR1B,
+		.MyLatchLsw	= LP_CNTR1BLSW,
+		.MyEventBits	= EVBITS(4),
+	}, {
+		.GetEnable	= GetEnable_B,
+		.GetIntSrc	= GetIntSrc_B,
+		.GetLoadTrig	= GetLoadTrig_B,
+		.GetMode	= GetMode_B,
+		.PulseIndex	= PulseIndex_B,
+		.SetEnable	= SetEnable_B,
+		.SetIntSrc	= SetIntSrc_B,
+		.SetLoadTrig	= SetLoadTrig_B,
+		.SetMode	= SetMode_B,
+		.ResetCapFlags	= ResetCapFlags_B,
+		.MyCRA		= LP_CR2A,
+		.MyCRB		= LP_CR2B,
+		.MyLatchLsw	= LP_CNTR2BLSW,
+		.MyEventBits	= EVBITS(5),
+	},
+};
+
 static void CountersInit(struct comedi_device *dev)
 {
 	int chan;

commit 6baffbc2a4a11d78325f338a5e4731207ab9ca7d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 19:26:11 2012 -0700

    staging: comedi: s626: remove forward declarations 5
    
    Move the irq set/reset/clear and ns_to_timer helper functions
    up to remove the need for the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 3cdb29323ca3..cc18bf06a243 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -207,12 +207,6 @@ static struct dio_private *dio_private_word[]={
 #define devpriv ((struct s626_private *)dev->private)
 #define diopriv ((struct dio_private *)s->private)
 
-static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan);
-static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int gruop,
-			      unsigned int mask);
-static int s626_dio_clear_irq(struct comedi_device *dev);
-static int s626_ns_to_timer(int *nanosec, int round_mode);
-
 /*  COUNTER OBJECT ------------------------------------------------ */
 struct enc_private {
 	/*  Pointers to functions that differ for A and B counters: */
@@ -803,6 +797,87 @@ static unsigned int s626_ai_reg_to_uint(int data)
 /*   return 0; */
 /* } */
 
+static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
+{
+	unsigned int group;
+	unsigned int bitmask;
+	unsigned int status;
+
+	/* select dio bank */
+	group = chan / 16;
+	bitmask = 1 << (chan - (16 * group));
+	DEBUG("s626_dio_set_irq: enable interrupt on dio channel %d group %d\n",
+	      chan - (16 * group), group);
+
+	/* set channel to capture positive edge */
+	status = DEBIread(dev,
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->RDEdgSel);
+	DEBIwrite(dev,
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WREdgSel,
+		  bitmask | status);
+
+	/* enable interrupt on selected channel */
+	status = DEBIread(dev,
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->RDIntSel);
+	DEBIwrite(dev,
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WRIntSel,
+		  bitmask | status);
+
+	/* enable edge capture write command */
+	DEBIwrite(dev, LP_MISC1, MISC1_EDCAP);
+
+	/* enable edge capture on selected channel */
+	status = DEBIread(dev,
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->RDCapSel);
+	DEBIwrite(dev,
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WRCapSel,
+		  bitmask | status);
+
+	return 0;
+}
+
+static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,
+			      unsigned int mask)
+{
+	DEBUG
+	    ("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n",
+	     mask, group);
+
+	/* disable edge capture write command */
+	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
+
+	/* enable edge capture on selected channel */
+	DEBIwrite(dev,
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WRCapSel, mask);
+
+	return 0;
+}
+
+static int s626_dio_clear_irq(struct comedi_device *dev)
+{
+	unsigned int group;
+
+	/* disable edge capture write command */
+	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
+
+	for (group = 0; group < S626_DIO_BANKS; group++) {
+		/* clear pending events and interrupt */
+		DEBIwrite(dev,
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->WRCapSel,
+			  0xffff);
+	}
+
+	return 0;
+}
+
 static irqreturn_t s626_irq_handler(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -1500,6 +1575,34 @@ static int s626_ai_inttrig(struct comedi_device *dev,
 	return 1;
 }
 
+/* This function doesn't require a particular form, this is just what
+ * happens to be used in some of the drivers.  It should convert ns
+ * nanoseconds to a counter value suitable for programming the device.
+ * Also, it should adjust ns so that it cooresponds to the actual time
+ * that the device will use. */
+static int s626_ns_to_timer(int *nanosec, int round_mode)
+{
+	int divider, base;
+
+	base = 500;		/* 2MHz internal clock */
+
+	switch (round_mode) {
+	case TRIG_ROUND_NEAREST:
+	default:
+		divider = (*nanosec + base / 2) / base;
+		break;
+	case TRIG_ROUND_DOWN:
+		divider = (*nanosec) / base;
+		break;
+	case TRIG_ROUND_UP:
+		divider = (*nanosec + base - 1) / base;
+		break;
+	}
+
+	*nanosec = base * divider;
+	return divider - 1;
+}
+
 /*  TO COMPLETE  */
 static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
@@ -1832,34 +1935,6 @@ static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-/* This function doesn't require a particular form, this is just what
- * happens to be used in some of the drivers.  It should convert ns
- * nanoseconds to a counter value suitable for programming the device.
- * Also, it should adjust ns so that it cooresponds to the actual time
- * that the device will use. */
-static int s626_ns_to_timer(int *nanosec, int round_mode)
-{
-	int divider, base;
-
-	base = 500;		/* 2MHz internal clock */
-
-	switch (round_mode) {
-	case TRIG_ROUND_NEAREST:
-	default:
-		divider = (*nanosec + base / 2) / base;
-		break;
-	case TRIG_ROUND_DOWN:
-		divider = (*nanosec) / base;
-		break;
-	case TRIG_ROUND_UP:
-		divider = (*nanosec + base - 1) / base;
-		break;
-	}
-
-	*nanosec = base * divider;
-	return divider - 1;
-}
-
 static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_insn *insn, unsigned int *data)
 {
@@ -1980,87 +2055,6 @@ static int s626_dio_insn_config(struct comedi_device *dev,
 	return 1;
 }
 
-static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
-{
-	unsigned int group;
-	unsigned int bitmask;
-	unsigned int status;
-
-	/* select dio bank */
-	group = chan / 16;
-	bitmask = 1 << (chan - (16 * group));
-	DEBUG("s626_dio_set_irq: enable interrupt on dio channel %d group %d\n",
-	      chan - (16 * group), group);
-
-	/* set channel to capture positive edge */
-	status = DEBIread(dev,
-			  ((struct dio_private *)(dev->subdevices + 2 +
-						  group)->private)->RDEdgSel);
-	DEBIwrite(dev,
-		  ((struct dio_private *)(dev->subdevices + 2 +
-					  group)->private)->WREdgSel,
-		  bitmask | status);
-
-	/* enable interrupt on selected channel */
-	status = DEBIread(dev,
-			  ((struct dio_private *)(dev->subdevices + 2 +
-						  group)->private)->RDIntSel);
-	DEBIwrite(dev,
-		  ((struct dio_private *)(dev->subdevices + 2 +
-					  group)->private)->WRIntSel,
-		  bitmask | status);
-
-	/* enable edge capture write command */
-	DEBIwrite(dev, LP_MISC1, MISC1_EDCAP);
-
-	/* enable edge capture on selected channel */
-	status = DEBIread(dev,
-			  ((struct dio_private *)(dev->subdevices + 2 +
-						  group)->private)->RDCapSel);
-	DEBIwrite(dev,
-		  ((struct dio_private *)(dev->subdevices + 2 +
-					  group)->private)->WRCapSel,
-		  bitmask | status);
-
-	return 0;
-}
-
-static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,
-			      unsigned int mask)
-{
-	DEBUG
-	    ("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n",
-	     mask, group);
-
-	/* disable edge capture write command */
-	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
-
-	/* enable edge capture on selected channel */
-	DEBIwrite(dev,
-		  ((struct dio_private *)(dev->subdevices + 2 +
-					  group)->private)->WRCapSel, mask);
-
-	return 0;
-}
-
-static int s626_dio_clear_irq(struct comedi_device *dev)
-{
-	unsigned int group;
-
-	/* disable edge capture write command */
-	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
-
-	for (group = 0; group < S626_DIO_BANKS; group++) {
-		/* clear pending events and interrupt */
-		DEBIwrite(dev,
-			  ((struct dio_private *)(dev->subdevices + 2 +
-						  group)->private)->WRCapSel,
-			  0xffff);
-	}
-
-	return 0;
-}
-
 /* Now this function initializes the value of the counter (data[0])
    and set the subdevice. To complete with trigger and interrupt
    configuration */

commit 954147296993e1c369f8e1d68d488724e7040dea
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 19:25:49 2012 -0700

    staging: comedi: s626: remove forward declarations 4
    
    Move the DAC functions up to remove the need for the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 5fcb43ae5471..3cdb29323ca3 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -213,12 +213,6 @@ static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int gruop,
 static int s626_dio_clear_irq(struct comedi_device *dev);
 static int s626_ns_to_timer(int *nanosec, int round_mode);
 
-/* internal routines */
-static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
-			 uint8_t DacData);
-static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata);
-static void SendDAC(struct comedi_device *dev, uint32_t val);
-
 /*  COUNTER OBJECT ------------------------------------------------ */
 struct enc_private {
 	/*  Pointers to functions that differ for A and B counters: */
@@ -552,6 +546,246 @@ static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 	return rtnval;
 }
 
+/* ***********  DAC FUNCTIONS *********** */
+
+/*  Slot 0 base settings. */
+#define VECT0	(XSD2 | RSD3 | SIB_A2)
+/*  Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
+
+/*  TrimDac LogicalChan-to-PhysicalChan mapping table. */
+static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
+
+/*  TrimDac LogicalChan-to-EepromAdrs mapping table. */
+static uint8_t trimadrs[] = { 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
+
+/* Private helper function: Transmit serial data to DAC via Audio
+ * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
+ * Dacpol contains valid target image.
+ */
+static void SendDAC(struct comedi_device *dev, uint32_t val)
+{
+
+	/* START THE SERIAL CLOCK RUNNING ------------- */
+
+	/* Assert DAC polarity control and enable gating of DAC serial clock
+	 * and audio bit stream signals.  At this point in time we must be
+	 * assured of being in time slot 0.  If we are not in slot 0, the
+	 * serial clock and audio stream signals will be disabled; this is
+	 * because the following DEBIwrite statement (which enables signals
+	 * to be passed through the gate array) would execute before the
+	 * trailing edge of WS1/WS3 (which turns off the signals), thus
+	 * causing the signals to be inactive during the DAC write.
+	 */
+	DEBIwrite(dev, LP_DACPOL, devpriv->Dacpol);
+
+	/* TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- */
+
+	/* Copy DAC setpoint value to DAC's output DMA buffer. */
+
+	/* WR7146( (uint32_t)devpriv->pDacWBuf, val ); */
+	*devpriv->pDacWBuf = val;
+
+	/* enab the output DMA transfer.  This will cause the DMAC to copy
+	 * the DAC's data value to A2's output FIFO.  The DMA transfer will
+	 * then immediately terminate because the protection address is
+	 * reached upon transfer of the first DWORD value.
+	 */
+	MC_ENABLE(P_MC1, MC1_A2OUT);
+
+	/*  While the DMA transfer is executing ... */
+
+	/* Reset Audio2 output FIFO's underflow flag (along with any other
+	 * FIFO underflow/overflow flags).  When set, this flag will
+	 * indicate that we have emerged from slot 0.
+	 */
+	WR7146(P_ISR, ISR_AFOU);
+
+	/* Wait for the DMA transfer to finish so that there will be data
+	 * available in the FIFO when time slot 1 tries to transfer a DWORD
+	 * from the FIFO to the output buffer register.  We test for DMA
+	 * Done by polling the DMAC enable flag; this flag is automatically
+	 * cleared when the transfer has finished.
+	 */
+	while ((RR7146(P_MC1) & MC1_A2OUT) != 0)
+		;
+
+	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
+
+	/* FIFO data is now available, so we enable execution of time slots
+	 * 1 and higher by clearing the EOS flag in slot 0.  Note that SD3
+	 * will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
+	 * detection.
+	 */
+	SETVECT(0, XSD2 | RSD3 | SIB_A2);
+
+	/* Wait for slot 1 to execute to ensure that the Packet will be
+	 * transmitted.  This is detected by polling the Audio2 output FIFO
+	 * underflow flag, which will be set when slot 1 execution has
+	 * finished transferring the DAC's data DWORD from the output FIFO
+	 * to the output buffer register.
+	 */
+	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0)
+		;
+
+	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
+	 * back to slot 0 after executing the EOS in slot 5.  Also,
+	 * simultaneously shift out and in the 0x00 that is ALWAYS the value
+	 * stored in the last byte to be shifted out of the FIFO's DWORD
+	 * buffer register.
+	 */
+	SETVECT(0, XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS);
+
+	/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */
+
+	/* Wait for the TSL to finish executing all time slots before
+	 * exiting this function.  We must do this so that the next DAC
+	 * write doesn't start, thereby enabling clock/chip select signals:
+	 *
+	 * 1. Before the TSL sequence cycles back to slot 0, which disables
+	 *    the clock/cs signal gating and traps slot // list execution.
+	 *    we have not yet finished slot 5 then the clock/cs signals are
+	 *    still gated and we have not finished transmitting the stream.
+	 *
+	 * 2. While slots 2-5 are executing due to a late slot 0 trap.  In
+	 *    this case, the slot sequence is currently repeating, but with
+	 *    clock/cs signals disabled.  We must wait for slot 0 to trap
+	 *    execution before setting up the next DAC setpoint DMA transfer
+	 *    and enabling the clock/cs signals.  To detect the end of slot 5,
+	 *    we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
+	 *    the TSL has not yet finished executing slot 5 ...
+	 */
+	if ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) {
+		/* The trap was set on time and we are still executing somewhere
+		 * in slots 2-5, so we now wait for slot 0 to execute and trap
+		 * TSL execution.  This is detected when FB_BUFFER2 MSB changes
+		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
+		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
+		 */
+		while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0)
+			;
+	}
+	/* Either (1) we were too late setting the slot 0 trap; the TSL
+	 * sequencer restarted slot 0 before we could set the EOS trap flag,
+	 * or (2) we were not late and execution is now trapped at slot 0.
+	 * In either case, we must now change slot 0 so that it will store
+	 * value 0xFF (instead of 0x00) to FB_BUFFER2 next time it executes.
+	 * In order to do this, we reprogram slot 0 so that it will shift in
+	 * SD3, which is driven only by a pull-up resistor.
+	 */
+	SETVECT(0, RSD3 | SIB_A2 | EOS);
+
+	/* Wait for slot 0 to execute, at which time the TSL is setup for
+	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
+	 * from 0x00 to 0xFF.
+	 */
+	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0)
+		;
+}
+
+/*  Private helper function: Write setpoint to an application DAC channel. */
+static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
+{
+	register uint16_t signmask;
+	register uint32_t WSImage;
+
+	/*  Adjust DAC data polarity and set up Polarity Control Register */
+	/*  image. */
+	signmask = 1 << chan;
+	if (dacdata < 0) {
+		dacdata = -dacdata;
+		devpriv->Dacpol |= signmask;
+	} else
+		devpriv->Dacpol &= ~signmask;
+
+	/*  Limit DAC setpoint value to valid range. */
+	if ((uint16_t) dacdata > 0x1FFF)
+		dacdata = 0x1FFF;
+
+	/* Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
+	 * and V3 transmit the setpoint to the target DAC.  V4 and V5 send
+	 * data to a non-existent TrimDac channel just to keep the clock
+	 * running after sending data to the target DAC.  This is necessary
+	 * to eliminate the clock glitch that would otherwise occur at the
+	 * end of the target DAC's serial data stream.  When the sequence
+	 * restarts at V0 (after executing V5), the gate array automatically
+	 * disables gating for the DAC clock and all DAC chip selects.
+	 */
+
+	WSImage = (chan & 2) ? WS1 : WS2;
+	/* Choose DAC chip select to be asserted. */
+	SETVECT(2, XSD2 | XFIFO_1 | WSImage);
+	/* Slot 2: Transmit high data byte to target DAC. */
+	SETVECT(3, XSD2 | XFIFO_0 | WSImage);
+	/* Slot 3: Transmit low data byte to target DAC. */
+	SETVECT(4, XSD2 | XFIFO_3 | WS3);
+	/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */
+	SETVECT(5, XSD2 | XFIFO_2 | WS3 | EOS);
+	/* Slot 5: running after writing target DAC's low data byte. */
+
+	/*  Construct and transmit target DAC's serial packet:
+	 * ( A10D DDDD ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan<0>,
+	 * and D<12:0> is the DAC setpoint.  Append a WORD value (that writes
+	 * to a  non-existent TrimDac channel) that serves to keep the clock
+	 * running after the packet has been sent to the target DAC.
+	 */
+	SendDAC(dev, 0x0F000000
+		/* Continue clock after target DAC data (write to non-existent trimdac). */
+		| 0x00004000
+		/* Address the two main dual-DAC devices (TSL's chip select enables
+		 * target device). */
+		| ((uint32_t) (chan & 1) << 15)
+		/*  Address the DAC channel within the  device. */
+		| (uint32_t) dacdata);	/*  Include DAC setpoint data. */
+
+}
+
+static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
+			 uint8_t DacData)
+{
+	uint32_t chan;
+
+	/*  Save the new setpoint in case the application needs to read it back later. */
+	devpriv->TrimSetpoint[LogicalChan] = (uint8_t) DacData;
+
+	/*  Map logical channel number to physical channel number. */
+	chan = (uint32_t) trimchan[LogicalChan];
+
+	/* Set up TSL2 records for TrimDac write operation.  All slots shift
+	 * 0xFF in from pulled-up SD3 so that the end of the slot sequence
+	 * can be detected.
+	 */
+
+	SETVECT(2, XSD2 | XFIFO_1 | WS3);
+	/* Slot 2: Send high uint8_t to target TrimDac. */
+	SETVECT(3, XSD2 | XFIFO_0 | WS3);
+	/* Slot 3: Send low uint8_t to target TrimDac. */
+	SETVECT(4, XSD2 | XFIFO_3 | WS1);
+	/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running. */
+	SETVECT(5, XSD2 | XFIFO_2 | WS1 | EOS);
+	/* Slot 5: Send NOP low  uint8_t to DAC0. */
+
+	/* Construct and transmit target DAC's serial packet:
+	 * ( 0000 AAAA ), ( DDDD DDDD ),( 0x00 ),( 0x00 ) where A<3:0> is the
+	 * DAC channel's address, and D<7:0> is the DAC setpoint.  Append a
+	 * WORD value (that writes a channel 0 NOP command to a non-existent
+	 * main DAC channel) that serves to keep the clock running after the
+	 * packet has been sent to the target DAC.
+	 */
+
+	/*  Address the DAC channel within the trimdac device. */
+	SendDAC(dev, ((uint32_t) chan << 8)
+		| (uint32_t) DacData);	/*  Include DAC setpoint data. */
+}
+
+static void LoadTrimDACs(struct comedi_device *dev)
+{
+	register uint8_t i;
+
+	/*  Copy TrimDac setpoint values from EEPROM to TrimDacs. */
+	for (i = 0; i < ARRAY_SIZE(trimchan); i++)
+		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
+}
+
 static unsigned int s626_ai_reg_to_uint(int data)
 {
 	unsigned int tempdata;
@@ -1938,248 +2172,6 @@ static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 	/*   k->SetEnable(dev,k,(uint16_t)(enab != 0)); */
 }
 
-/* ***********  DAC FUNCTIONS *********** */
-
-/*  Slot 0 base settings. */
-#define VECT0	(XSD2 | RSD3 | SIB_A2)
-/*  Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
-
-/*  TrimDac LogicalChan-to-PhysicalChan mapping table. */
-static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
-
-/*  TrimDac LogicalChan-to-EepromAdrs mapping table. */
-static uint8_t trimadrs[] = { 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
-
-static void LoadTrimDACs(struct comedi_device *dev)
-{
-	register uint8_t i;
-
-	/*  Copy TrimDac setpoint values from EEPROM to TrimDacs. */
-	for (i = 0; i < ARRAY_SIZE(trimchan); i++)
-		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
-}
-
-static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
-			 uint8_t DacData)
-{
-	uint32_t chan;
-
-	/*  Save the new setpoint in case the application needs to read it back later. */
-	devpriv->TrimSetpoint[LogicalChan] = (uint8_t) DacData;
-
-	/*  Map logical channel number to physical channel number. */
-	chan = (uint32_t) trimchan[LogicalChan];
-
-	/* Set up TSL2 records for TrimDac write operation.  All slots shift
-	 * 0xFF in from pulled-up SD3 so that the end of the slot sequence
-	 * can be detected.
-	 */
-
-	SETVECT(2, XSD2 | XFIFO_1 | WS3);
-	/* Slot 2: Send high uint8_t to target TrimDac. */
-	SETVECT(3, XSD2 | XFIFO_0 | WS3);
-	/* Slot 3: Send low uint8_t to target TrimDac. */
-	SETVECT(4, XSD2 | XFIFO_3 | WS1);
-	/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running. */
-	SETVECT(5, XSD2 | XFIFO_2 | WS1 | EOS);
-	/* Slot 5: Send NOP low  uint8_t to DAC0. */
-
-	/* Construct and transmit target DAC's serial packet:
-	 * ( 0000 AAAA ), ( DDDD DDDD ),( 0x00 ),( 0x00 ) where A<3:0> is the
-	 * DAC channel's address, and D<7:0> is the DAC setpoint.  Append a
-	 * WORD value (that writes a channel 0 NOP command to a non-existent
-	 * main DAC channel) that serves to keep the clock running after the
-	 * packet has been sent to the target DAC.
-	 */
-
-	/*  Address the DAC channel within the trimdac device. */
-	SendDAC(dev, ((uint32_t) chan << 8)
-		| (uint32_t) DacData);	/*  Include DAC setpoint data. */
-}
-
-/*  Private helper function: Write setpoint to an application DAC channel. */
-
-static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
-{
-	register uint16_t signmask;
-	register uint32_t WSImage;
-
-	/*  Adjust DAC data polarity and set up Polarity Control Register */
-	/*  image. */
-	signmask = 1 << chan;
-	if (dacdata < 0) {
-		dacdata = -dacdata;
-		devpriv->Dacpol |= signmask;
-	} else
-		devpriv->Dacpol &= ~signmask;
-
-	/*  Limit DAC setpoint value to valid range. */
-	if ((uint16_t) dacdata > 0x1FFF)
-		dacdata = 0x1FFF;
-
-	/* Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
-	 * and V3 transmit the setpoint to the target DAC.  V4 and V5 send
-	 * data to a non-existent TrimDac channel just to keep the clock
-	 * running after sending data to the target DAC.  This is necessary
-	 * to eliminate the clock glitch that would otherwise occur at the
-	 * end of the target DAC's serial data stream.  When the sequence
-	 * restarts at V0 (after executing V5), the gate array automatically
-	 * disables gating for the DAC clock and all DAC chip selects.
-	 */
-
-	WSImage = (chan & 2) ? WS1 : WS2;
-	/* Choose DAC chip select to be asserted. */
-	SETVECT(2, XSD2 | XFIFO_1 | WSImage);
-	/* Slot 2: Transmit high data byte to target DAC. */
-	SETVECT(3, XSD2 | XFIFO_0 | WSImage);
-	/* Slot 3: Transmit low data byte to target DAC. */
-	SETVECT(4, XSD2 | XFIFO_3 | WS3);
-	/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */
-	SETVECT(5, XSD2 | XFIFO_2 | WS3 | EOS);
-	/* Slot 5: running after writing target DAC's low data byte. */
-
-	/*  Construct and transmit target DAC's serial packet:
-	 * ( A10D DDDD ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan<0>,
-	 * and D<12:0> is the DAC setpoint.  Append a WORD value (that writes
-	 * to a  non-existent TrimDac channel) that serves to keep the clock
-	 * running after the packet has been sent to the target DAC.
-	 */
-	SendDAC(dev, 0x0F000000
-		/* Continue clock after target DAC data (write to non-existent trimdac). */
-		| 0x00004000
-		/* Address the two main dual-DAC devices (TSL's chip select enables
-		 * target device). */
-		| ((uint32_t) (chan & 1) << 15)
-		/*  Address the DAC channel within the  device. */
-		| (uint32_t) dacdata);	/*  Include DAC setpoint data. */
-
-}
-
-/* Private helper function: Transmit serial data to DAC via Audio
- * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
- * Dacpol contains valid target image.
- */
-
-static void SendDAC(struct comedi_device *dev, uint32_t val)
-{
-
-	/* START THE SERIAL CLOCK RUNNING ------------- */
-
-	/* Assert DAC polarity control and enable gating of DAC serial clock
-	 * and audio bit stream signals.  At this point in time we must be
-	 * assured of being in time slot 0.  If we are not in slot 0, the
-	 * serial clock and audio stream signals will be disabled; this is
-	 * because the following DEBIwrite statement (which enables signals
-	 * to be passed through the gate array) would execute before the
-	 * trailing edge of WS1/WS3 (which turns off the signals), thus
-	 * causing the signals to be inactive during the DAC write.
-	 */
-	DEBIwrite(dev, LP_DACPOL, devpriv->Dacpol);
-
-	/* TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- */
-
-	/* Copy DAC setpoint value to DAC's output DMA buffer. */
-
-	/* WR7146( (uint32_t)devpriv->pDacWBuf, val ); */
-	*devpriv->pDacWBuf = val;
-
-	/* enab the output DMA transfer.  This will cause the DMAC to copy
-	 * the DAC's data value to A2's output FIFO.  The DMA transfer will
-	 * then immediately terminate because the protection address is
-	 * reached upon transfer of the first DWORD value.
-	 */
-	MC_ENABLE(P_MC1, MC1_A2OUT);
-
-	/*  While the DMA transfer is executing ... */
-
-	/* Reset Audio2 output FIFO's underflow flag (along with any other
-	 * FIFO underflow/overflow flags).  When set, this flag will
-	 * indicate that we have emerged from slot 0.
-	 */
-	WR7146(P_ISR, ISR_AFOU);
-
-	/* Wait for the DMA transfer to finish so that there will be data
-	 * available in the FIFO when time slot 1 tries to transfer a DWORD
-	 * from the FIFO to the output buffer register.  We test for DMA
-	 * Done by polling the DMAC enable flag; this flag is automatically
-	 * cleared when the transfer has finished.
-	 */
-	while ((RR7146(P_MC1) & MC1_A2OUT) != 0)
-		;
-
-	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
-
-	/* FIFO data is now available, so we enable execution of time slots
-	 * 1 and higher by clearing the EOS flag in slot 0.  Note that SD3
-	 * will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
-	 * detection.
-	 */
-	SETVECT(0, XSD2 | RSD3 | SIB_A2);
-
-	/* Wait for slot 1 to execute to ensure that the Packet will be
-	 * transmitted.  This is detected by polling the Audio2 output FIFO
-	 * underflow flag, which will be set when slot 1 execution has
-	 * finished transferring the DAC's data DWORD from the output FIFO
-	 * to the output buffer register.
-	 */
-	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0)
-		;
-
-	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
-	 * back to slot 0 after executing the EOS in slot 5.  Also,
-	 * simultaneously shift out and in the 0x00 that is ALWAYS the value
-	 * stored in the last byte to be shifted out of the FIFO's DWORD
-	 * buffer register.
-	 */
-	SETVECT(0, XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS);
-
-	/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */
-
-	/* Wait for the TSL to finish executing all time slots before
-	 * exiting this function.  We must do this so that the next DAC
-	 * write doesn't start, thereby enabling clock/chip select signals:
-	 *
-	 * 1. Before the TSL sequence cycles back to slot 0, which disables
-	 *    the clock/cs signal gating and traps slot // list execution.
-	 *    we have not yet finished slot 5 then the clock/cs signals are
-	 *    still gated and we have not finished transmitting the stream.
-	 *
-	 * 2. While slots 2-5 are executing due to a late slot 0 trap.  In
-	 *    this case, the slot sequence is currently repeating, but with
-	 *    clock/cs signals disabled.  We must wait for slot 0 to trap
-	 *    execution before setting up the next DAC setpoint DMA transfer
-	 *    and enabling the clock/cs signals.  To detect the end of slot 5,
-	 *    we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
-	 *    the TSL has not yet finished executing slot 5 ...
-	 */
-	if ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) {
-		/* The trap was set on time and we are still executing somewhere
-		 * in slots 2-5, so we now wait for slot 0 to execute and trap
-		 * TSL execution.  This is detected when FB_BUFFER2 MSB changes
-		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
-		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
-		 */
-		while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0)
-			;
-	}
-	/* Either (1) we were too late setting the slot 0 trap; the TSL
-	 * sequencer restarted slot 0 before we could set the EOS trap flag,
-	 * or (2) we were not late and execution is now trapped at slot 0.
-	 * In either case, we must now change slot 0 so that it will store
-	 * value 0xFF (instead of 0x00) to FB_BUFFER2 next time it executes.
-	 * In order to do this, we reprogram slot 0 so that it will shift in
-	 * SD3, which is driven only by a pull-up resistor.
-	 */
-	SETVECT(0, RSD3 | SIB_A2 | EOS);
-
-	/* Wait for slot 0 to execute, at which time the TSL is setup for
-	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
-	 * from 0x00 to 0xFF.
-	 */
-	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0)
-		;
-}
-
 static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
 {
 	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	/*  enab writes to */

commit 982e3d11ed2b7a96ee93ef62ab37826da1e75a32
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 19:25:32 2012 -0700

    staging: comedi: s626: remove forward declarations 3
    
    Move the I2C functions up to remove the need for the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 1efa2f021647..5fcb43ae5471 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -216,8 +216,6 @@ static int s626_ns_to_timer(int *nanosec, int round_mode);
 /* internal routines */
 static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
 			 uint8_t DacData);
-static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr);
-static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val);
 static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata);
 static void SendDAC(struct comedi_device *dev, uint32_t val);
 
@@ -493,6 +491,67 @@ static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
 	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
 }
 
+/* **************  EEPROM ACCESS FUNCTIONS  ************** */
+
+static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
+{
+	/*  Write I2C command to I2C Transfer Control shadow register. */
+	WR7146(P_I2CCTRL, val);
+
+	/*  Upload I2C shadow registers into working registers and wait for */
+	/*  upload confirmation. */
+
+	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
+	while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
+		;
+
+	/*  Wait until I2C bus transfer is finished or an error occurs. */
+	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY)
+		;
+
+	/*  Return non-zero if I2C error occurred. */
+	return RR7146(P_I2CCTRL) & I2C_ERR;
+
+}
+
+/*  Read uint8_t from EEPROM. */
+static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
+{
+	uint8_t rtnval;
+
+	/*  Send EEPROM target address. */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)
+			 /* Byte2 = I2C command: write to I2C EEPROM  device. */
+			 | I2C_B1(I2C_ATTRSTOP, addr)
+			 /* Byte1 = EEPROM internal target address. */
+			 | I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not sent. */
+		/*  Abort function and declare error if handshake failed. */
+		DEBUG("I2Cread: error handshake I2Cread  a\n");
+		return 0;
+	}
+	/*  Execute EEPROM read. */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)
+
+			 /*  Byte2 = I2C */
+			 /*  command: read */
+			 /*  from I2C EEPROM */
+			 /*  device. */
+			 |I2C_B1(I2C_ATTRSTOP, 0)
+
+			 /*  Byte1 receives */
+			 /*  uint8_t from */
+			 /*  EEPROM. */
+			 |I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not  sent. */
+
+		/*  Abort function and declare error if handshake failed. */
+		DEBUG("I2Cread: error handshake I2Cread b\n");
+		return 0;
+	}
+	/*  Return copy of EEPROM value. */
+	rtnval = (uint8_t) (RR7146(P_I2CCTRL) >> 16);
+	return rtnval;
+}
+
 static unsigned int s626_ai_reg_to_uint(int data)
 {
 	unsigned int tempdata;
@@ -1938,67 +1997,6 @@ static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
 		| (uint32_t) DacData);	/*  Include DAC setpoint data. */
 }
 
-/* **************  EEPROM ACCESS FUNCTIONS  ************** */
-/*  Read uint8_t from EEPROM. */
-
-static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
-{
-	uint8_t rtnval;
-
-	/*  Send EEPROM target address. */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)
-			 /* Byte2 = I2C command: write to I2C EEPROM  device. */
-			 | I2C_B1(I2C_ATTRSTOP, addr)
-			 /* Byte1 = EEPROM internal target address. */
-			 | I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not sent. */
-		/*  Abort function and declare error if handshake failed. */
-		DEBUG("I2Cread: error handshake I2Cread  a\n");
-		return 0;
-	}
-	/*  Execute EEPROM read. */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)
-
-			 /*  Byte2 = I2C */
-			 /*  command: read */
-			 /*  from I2C EEPROM */
-			 /*  device. */
-			 |I2C_B1(I2C_ATTRSTOP, 0)
-
-			 /*  Byte1 receives */
-			 /*  uint8_t from */
-			 /*  EEPROM. */
-			 |I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not  sent. */
-
-		/*  Abort function and declare error if handshake failed. */
-		DEBUG("I2Cread: error handshake I2Cread b\n");
-		return 0;
-	}
-	/*  Return copy of EEPROM value. */
-	rtnval = (uint8_t) (RR7146(P_I2CCTRL) >> 16);
-	return rtnval;
-}
-
-static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
-{
-	/*  Write I2C command to I2C Transfer Control shadow register. */
-	WR7146(P_I2CCTRL, val);
-
-	/*  Upload I2C shadow registers into working registers and wait for */
-	/*  upload confirmation. */
-
-	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
-	while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
-		;
-
-	/*  Wait until I2C bus transfer is finished or an error occurs. */
-	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY)
-		;
-
-	/*  Return non-zero if I2C error occurred. */
-	return RR7146(P_I2CCTRL) & I2C_ERR;
-
-}
-
 /*  Private helper function: Write setpoint to an application DAC channel. */
 
 static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)

commit 6b387b7095cabbb8bd31c936ed3d47ef758cc595
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 19:25:16 2012 -0700

    staging: comedi: s626: remove forward declarations 2
    
    Move the DEBI* i/o functions up to remove the need for the
    forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 08868066a4d9..1efa2f021647 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -220,9 +220,6 @@ static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr);
 static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val);
 static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata);
 static void SendDAC(struct comedi_device *dev, uint32_t val);
-static void DEBItransfer(struct comedi_device *dev);
-static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr);
-static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata);
 
 /*  COUNTER OBJECT ------------------------------------------------ */
 struct enc_private {
@@ -426,6 +423,76 @@ static const struct comedi_lrange s626_range_table = { 2, {
 							   }
 };
 
+/*  Execute a DEBI transfer.  This must be called from within a */
+/*  critical section. */
+static void DEBItransfer(struct comedi_device *dev)
+{
+	/*  Initiate upload of shadow RAM to DEBI control register. */
+	MC_ENABLE(P_MC2, MC2_UPLD_DEBI);
+
+	/*  Wait for completion of upload from shadow RAM to DEBI control */
+	/*  register. */
+	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI))
+		;
+
+	/*  Wait until DEBI transfer is done. */
+	while (RR7146(P_PSR) & PSR_DEBI_S)
+		;
+}
+
+/*  Initialize the DEBI interface for all transfers. */
+
+static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
+{
+	uint16_t retval;
+
+	/*  Set up DEBI control register value in shadow RAM. */
+	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
+
+	/*  Execute the DEBI transfer. */
+	DEBItransfer(dev);
+
+	/*  Fetch target register value. */
+	retval = (uint16_t) RR7146(P_DEBIAD);
+
+	/*  Return register value. */
+	return retval;
+}
+
+/*  Write a value to a gate array register. */
+static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
+{
+
+	/*  Set up DEBI control register value in shadow RAM. */
+	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
+	WR7146(P_DEBIAD, wdata);
+
+	/*  Execute the DEBI transfer. */
+	DEBItransfer(dev);
+}
+
+/* Replace the specified bits in a gate array register.  Imports: mask
+ * specifies bits that are to be preserved, wdata is new value to be
+ * or'd with the masked original.
+ */
+static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
+			uint16_t wdata)
+{
+
+	/*  Copy target gate array register into P_DEBIAD register. */
+	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
+	/* Set up DEBI control reg value in shadow RAM. */
+	DEBItransfer(dev);	/*  Execute the DEBI Read transfer. */
+
+	/*  Write back the modified image. */
+	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
+	/* Set up DEBI control reg value in shadow  RAM. */
+
+	WR7146(P_DEBIAD, wdata | ((uint16_t) RR7146(P_DEBIAD) & mask));
+	/* Modify the register image. */
+	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
+}
+
 static unsigned int s626_ai_reg_to_uint(int data)
 {
 	unsigned int tempdata;
@@ -2123,76 +2190,6 @@ static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
 	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE);	/*  Disable writes to MISC2. */
 }
 
-/*  Initialize the DEBI interface for all transfers. */
-
-static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
-{
-	uint16_t retval;
-
-	/*  Set up DEBI control register value in shadow RAM. */
-	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
-
-	/*  Execute the DEBI transfer. */
-	DEBItransfer(dev);
-
-	/*  Fetch target register value. */
-	retval = (uint16_t) RR7146(P_DEBIAD);
-
-	/*  Return register value. */
-	return retval;
-}
-
-/*  Execute a DEBI transfer.  This must be called from within a */
-/*  critical section. */
-static void DEBItransfer(struct comedi_device *dev)
-{
-	/*  Initiate upload of shadow RAM to DEBI control register. */
-	MC_ENABLE(P_MC2, MC2_UPLD_DEBI);
-
-	/*  Wait for completion of upload from shadow RAM to DEBI control */
-	/*  register. */
-	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI))
-		;
-
-	/*  Wait until DEBI transfer is done. */
-	while (RR7146(P_PSR) & PSR_DEBI_S)
-		;
-}
-
-/*  Write a value to a gate array register. */
-static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
-{
-
-	/*  Set up DEBI control register value in shadow RAM. */
-	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
-	WR7146(P_DEBIAD, wdata);
-
-	/*  Execute the DEBI transfer. */
-	DEBItransfer(dev);
-}
-
-/* Replace the specified bits in a gate array register.  Imports: mask
- * specifies bits that are to be preserved, wdata is new value to be
- * or'd with the masked original.
- */
-static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
-			uint16_t wdata)
-{
-
-	/*  Copy target gate array register into P_DEBIAD register. */
-	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
-	/* Set up DEBI control reg value in shadow RAM. */
-	DEBItransfer(dev);	/*  Execute the DEBI Read transfer. */
-
-	/*  Write back the modified image. */
-	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
-	/* Set up DEBI control reg value in shadow  RAM. */
-
-	WR7146(P_DEBIAD, wdata | ((uint16_t) RR7146(P_DEBIAD) & mask));
-	/* Modify the register image. */
-	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
-}
-
 static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
 		      size_t bsize)
 {

commit 020c44f3ad91b334f907a66eedba68f46dd39d25
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 19:24:47 2012 -0700

    staging: comedi: s626: remove forward declarations 1
    
    Move the s626_attach and s626_detach functions down to match
    the coding style of the other comedi drivers. Then remove
    the forward declarations that are no longer needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 58c9e40f6126..08868066a4d9 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -207,70 +207,22 @@ static struct dio_private *dio_private_word[]={
 #define devpriv ((struct s626_private *)dev->private)
 #define diopriv ((struct dio_private *)s->private)
 
-/* ioctl routines */
-static int s626_ai_insn_config(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data);
-/* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data); */
-static int s626_ai_insn_read(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data);
-static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int s626_ai_cmdtest(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_cmd *cmd);
-static int s626_ai_cancel(struct comedi_device *dev,
-			  struct comedi_subdevice *s);
-static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_insn *insn, unsigned int *data);
-static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_insn *insn, unsigned int *data);
-static int s626_dio_insn_bits(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data);
-static int s626_dio_insn_config(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data);
 static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan);
 static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int gruop,
 			      unsigned int mask);
 static int s626_dio_clear_irq(struct comedi_device *dev);
-static int s626_enc_insn_config(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data);
-static int s626_enc_insn_read(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data);
-static int s626_enc_insn_write(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data);
 static int s626_ns_to_timer(int *nanosec, int round_mode);
-static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd);
-static int s626_ai_inttrig(struct comedi_device *dev,
-			   struct comedi_subdevice *s, unsigned int trignum);
-static irqreturn_t s626_irq_handler(int irq, void *d);
-static unsigned int s626_ai_reg_to_uint(int data);
-/* static unsigned int s626_uint_to_reg(struct comedi_subdevice *s, int data); */
-
-/* end ioctl routines */
 
 /* internal routines */
-static void s626_dio_init(struct comedi_device *dev);
-static void ResetADC(struct comedi_device *dev, uint8_t * ppl);
-static void LoadTrimDACs(struct comedi_device *dev);
 static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
 			 uint8_t DacData);
 static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr);
 static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val);
 static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata);
 static void SendDAC(struct comedi_device *dev, uint32_t val);
-static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage);
 static void DEBItransfer(struct comedi_device *dev);
 static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr);
 static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata);
-static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
-			uint16_t wdata);
-static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
-		      size_t bsize);
 
 /*  COUNTER OBJECT ------------------------------------------------ */
 struct enc_private {
@@ -295,7 +247,6 @@ struct enc_private {
 
 #define encpriv ((struct enc_private *)(dev->subdevices+5)->private)
 
-/* counters routines */
 static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 			    int tick);
 static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k);
@@ -315,7 +266,6 @@ static uint16_t GetEnable_A(struct comedi_device *dev, struct enc_private *k);
 static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k);
 static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
 			   uint16_t value);
-/* static uint16_t GetLatchSource(struct comedi_device *dev, struct enc_private *k ); */
 static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k,
 			  uint16_t Trig);
 static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k,
@@ -328,20 +278,10 @@ static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
 			uint16_t IntSource);
 static uint16_t GetIntSrc_A(struct comedi_device *dev, struct enc_private *k);
 static uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k);
-/* static void SetClkMult(struct comedi_device *dev, struct enc_private *k, uint16_t value ) ; */
-/* static uint16_t GetClkMult(struct comedi_device *dev, struct enc_private *k ) ; */
-/* static void SetIndexPol(struct comedi_device *dev, struct enc_private *k, uint16_t value ); */
-/* static uint16_t GetClkPol(struct comedi_device *dev, struct enc_private *k ) ; */
-/* static void SetIndexSrc( struct comedi_device *dev,struct enc_private *k, uint16_t value );  */
-/* static uint16_t GetClkSrc( struct comedi_device *dev,struct enc_private *k );  */
-/* static void SetIndexSrc( struct comedi_device *dev,struct enc_private *k, uint16_t value );  */
-/* static uint16_t GetIndexSrc( struct comedi_device *dev,struct enc_private *k );  */
 static void PulseIndex_A(struct comedi_device *dev, struct enc_private *k);
 static void PulseIndex_B(struct comedi_device *dev, struct enc_private *k);
 static void Preload(struct comedi_device *dev, struct enc_private *k,
 		    uint32_t value);
-static void CountersInit(struct comedi_device *dev);
-/* end internal routines */
 
 /*  Counter objects constructor. */
 
@@ -486,2814 +426,2814 @@ static const struct comedi_lrange s626_range_table = { 2, {
 							   }
 };
 
-static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static unsigned int s626_ai_reg_to_uint(int data)
 {
-/*   uint8_t	PollList; */
-/*   uint16_t	AdcData; */
-/*   uint16_t	StartVal; */
-/*   uint16_t	index; */
-/*   unsigned int data[16]; */
-	int result;
-	int i;
-	int ret;
-	resource_size_t resourceStart;
-	dma_addr_t appdma;
-	struct comedi_subdevice *s;
-	struct pci_dev *pdev = NULL;
+	unsigned int tempdata;
 
-	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
-		return -ENOMEM;
+	tempdata = (data >> 18);
+	if (tempdata & 0x2000)
+		tempdata &= 0x1fff;
+	else
+		tempdata += (1 << 13);
 
-	for (i = 0; i < ARRAY_SIZE(s626_boards) && !pdev; i++) {
-		do {
-			pdev = pci_get_subsys(s626_boards[i].vendor_id,
-					      s626_boards[i].device_id,
-					      s626_boards[i].subvendor_id,
-					      s626_boards[i].subdevice_id,
-					      pdev);
+	return tempdata;
+}
 
-			if ((it->options[0] || it->options[1]) && pdev) {
-				/* matches requested bus/slot */
-				if (pdev->bus->number == it->options[0] &&
-				    PCI_SLOT(pdev->devfn) == it->options[1])
-					break;
-			} else
-				break;
-		} while (1);
-	}
-	devpriv->pdev = pdev;
+/* static unsigned int s626_uint_to_reg(struct comedi_subdevice *s, int data){ */
+/*   return 0; */
+/* } */
 
-	if (pdev == NULL) {
-		printk(KERN_ERR "s626_attach: Board not present!!!\n");
-		return -ENODEV;
-	}
+static irqreturn_t s626_irq_handler(int irq, void *d)
+{
+	struct comedi_device *dev = d;
+	struct comedi_subdevice *s;
+	struct comedi_cmd *cmd;
+	struct enc_private *k;
+	unsigned long flags;
+	int32_t *readaddr;
+	uint32_t irqtype, irqstatus;
+	int i = 0;
+	short tempdata;
+	uint8_t group;
+	uint16_t irqbit;
 
-	result = comedi_pci_enable(pdev, "s626");
-	if (result < 0) {
-		printk(KERN_ERR "s626_attach: comedi_pci_enable fails\n");
-		return -ENODEV;
-	}
-	devpriv->got_regions = 1;
+	DEBUG("s626_irq_handler: interrupt request received!!!\n");
 
-	resourceStart = pci_resource_start(devpriv->pdev, 0);
+	if (dev->attached == 0)
+		return IRQ_NONE;
+	/*  lock to avoid race with comedi_poll */
+	spin_lock_irqsave(&dev->spinlock, flags);
 
-	devpriv->base_addr = ioremap(resourceStart, SIZEOF_ADDRESS_SPACE);
-	if (devpriv->base_addr == NULL) {
-		printk(KERN_ERR "s626_attach: IOREMAP failed\n");
-		return -ENODEV;
-	}
+	/* save interrupt enable register state */
+	irqstatus = readl(devpriv->base_addr + P_IER);
 
-	if (devpriv->base_addr) {
-		/* disable master interrupt */
-		writel(0, devpriv->base_addr + P_IER);
+	/* read interrupt type */
+	irqtype = readl(devpriv->base_addr + P_ISR);
 
-		/* soft reset */
-		writel(MC1_SOFT_RESET, devpriv->base_addr + P_MC1);
+	/* disable master interrupt */
+	writel(0, devpriv->base_addr + P_IER);
 
-		/* DMA FIXME DMA// */
-		DEBUG("s626_attach: DMA ALLOCATION\n");
+	/* clear interrupt */
+	writel(irqtype, devpriv->base_addr + P_ISR);
 
-		/* adc buffer allocation */
-		devpriv->allocatedBuf = 0;
+	/* do somethings */
+	DEBUG("s626_irq_handler: interrupt type %d\n", irqtype);
 
-		devpriv->ANABuf.LogicalBase =
-		    pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
+	switch (irqtype) {
+	case IRQ_RPS1:		/*  end_of_scan occurs */
 
-		if (devpriv->ANABuf.LogicalBase == NULL) {
-			printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
-			return -ENOMEM;
-		}
+		DEBUG("s626_irq_handler: RPS1 irq detected\n");
 
-		devpriv->ANABuf.PhysicalBase = appdma;
+		/*  manage ai subdevice */
+		s = dev->subdevices;
+		cmd = &(s->async->cmd);
 
-		DEBUG
-		    ("s626_attach: AllocDMAB ADC Logical=%p, bsize=%d, Physical=0x%x\n",
-		     devpriv->ANABuf.LogicalBase, DMABUF_SIZE,
-		     (uint32_t) devpriv->ANABuf.PhysicalBase);
+		/* Init ptr to DMA buffer that holds new ADC data.  We skip the
+		 * first uint16_t in the buffer because it contains junk data from
+		 * the final ADC of the previous poll list scan.
+		 */
+		readaddr = (int32_t *) devpriv->ANABuf.LogicalBase + 1;
 
-		devpriv->allocatedBuf++;
+		/*  get the data and hand it over to comedi */
+		for (i = 0; i < (s->async->cmd.chanlist_len); i++) {
+			/*  Convert ADC data to 16-bit integer values and copy to application */
+			/*  buffer. */
+			tempdata = s626_ai_reg_to_uint((int)*readaddr);
+			readaddr++;
 
-		devpriv->RPSBuf.LogicalBase =
-		    pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
+			/* put data into read buffer */
+			/*  comedi_buf_put(s->async, tempdata); */
+			if (cfc_write_to_buffer(s, tempdata) == 0)
+				printk
+				    ("s626_irq_handler: cfc_write_to_buffer error!\n");
 
-		if (devpriv->RPSBuf.LogicalBase == NULL) {
-			printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
-			return -ENOMEM;
+			DEBUG("s626_irq_handler: ai channel %d acquired: %d\n",
+			      i, tempdata);
 		}
 
-		devpriv->RPSBuf.PhysicalBase = appdma;
-
-		DEBUG
-		    ("s626_attach: AllocDMAB RPS Logical=%p, bsize=%d, Physical=0x%x\n",
-		     devpriv->RPSBuf.LogicalBase, DMABUF_SIZE,
-		     (uint32_t) devpriv->RPSBuf.PhysicalBase);
+		/* end of scan occurs */
+		s->async->events |= COMEDI_CB_EOS;
 
-		devpriv->allocatedBuf++;
+		if (!(devpriv->ai_continous))
+			devpriv->ai_sample_count--;
+		if (devpriv->ai_sample_count <= 0) {
+			devpriv->ai_cmd_running = 0;
 
-	}
+			/*  Stop RPS program. */
+			MC_DISABLE(P_MC1, MC1_ERPS1);
 
-	dev->board_ptr = s626_boards;
-	dev->board_name = thisboard->name;
+			/* send end of acquisition */
+			s->async->events |= COMEDI_CB_EOA;
 
-	ret = comedi_alloc_subdevices(dev, 6);
-	if (ret)
-		return ret;
+			/* disable master interrupt */
+			irqstatus = 0;
+		}
 
-	dev->iobase = (unsigned long)devpriv->base_addr;
-	dev->irq = devpriv->pdev->irq;
+		if (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT) {
+			DEBUG
+			    ("s626_irq_handler: enable interrupt on dio channel %d\n",
+			     cmd->scan_begin_arg);
 
-	/* set up interrupt handler */
-	if (dev->irq == 0) {
-		printk(KERN_ERR " unknown irq (bad)\n");
-	} else {
-		ret = request_irq(dev->irq, s626_irq_handler, IRQF_SHARED,
-				  "s626", dev);
+			s626_dio_set_irq(dev, cmd->scan_begin_arg);
 
-		if (ret < 0) {
-			printk(KERN_ERR " irq not available\n");
-			dev->irq = 0;
+			DEBUG("s626_irq_handler: External trigger is set!!!\n");
 		}
-	}
-
-	DEBUG("s626_attach: -- it opts  %d,%d --\n",
-	      it->options[0], it->options[1]);
+		/*  tell comedi that data is there */
+		DEBUG("s626_irq_handler: events %d\n", s->async->events);
+		comedi_event(dev, s);
+		break;
+	case IRQ_GPIO3:	/* check dio and conter interrupt */
 
-	s = dev->subdevices + 0;
-	/* analog input subdevice */
-	dev->read_subdev = s;
-	/* we support single-ended (ground) and differential */
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_CMD_READ;
-	s->n_chan = thisboard->ai_chans;
-	s->maxdata = (0xffff >> 2);
-	s->range_table = &s626_range_table;
-	s->len_chanlist = thisboard->ai_chans;	/* This is the maximum chanlist
-						   length that the board can
-						   handle */
-	s->insn_config = s626_ai_insn_config;
-	s->insn_read = s626_ai_insn_read;
-	s->do_cmd = s626_ai_cmd;
-	s->do_cmdtest = s626_ai_cmdtest;
-	s->cancel = s626_ai_cancel;
+		DEBUG("s626_irq_handler: GPIO3 irq detected\n");
 
-	s = dev->subdevices + 1;
-	/* analog output subdevice */
-	s->type = COMEDI_SUBD_AO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = thisboard->ao_chans;
-	s->maxdata = (0x3fff);
-	s->range_table = &range_bipolar10;
-	s->insn_write = s626_ao_winsn;
-	s->insn_read = s626_ao_rinsn;
+		/*  manage ai subdevice */
+		s = dev->subdevices;
+		cmd = &(s->async->cmd);
 
-	s = dev->subdevices + 2;
-	/* digital I/O subdevice */
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = S626_DIO_CHANNELS;
-	s->maxdata = 1;
-	s->io_bits = 0xffff;
-	s->private = &dio_private_A;
-	s->range_table = &range_digital;
-	s->insn_config = s626_dio_insn_config;
-	s->insn_bits = s626_dio_insn_bits;
+		/* s626_dio_clear_irq(dev); */
 
-	s = dev->subdevices + 3;
-	/* digital I/O subdevice */
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = 16;
-	s->maxdata = 1;
-	s->io_bits = 0xffff;
-	s->private = &dio_private_B;
-	s->range_table = &range_digital;
-	s->insn_config = s626_dio_insn_config;
-	s->insn_bits = s626_dio_insn_bits;
+		for (group = 0; group < S626_DIO_BANKS; group++) {
+			irqbit = 0;
+			/* read interrupt type */
+			irqbit = DEBIread(dev,
+					  ((struct dio_private *)(dev->
+								  subdevices +
+								  2 +
+								  group)->
+					   private)->RDCapFlg);
 
-	s = dev->subdevices + 4;
-	/* digital I/O subdevice */
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = 16;
-	s->maxdata = 1;
-	s->io_bits = 0xffff;
-	s->private = &dio_private_C;
-	s->range_table = &range_digital;
-	s->insn_config = s626_dio_insn_config;
-	s->insn_bits = s626_dio_insn_bits;
+			/* check if interrupt is generated from dio channels */
+			if (irqbit) {
+				s626_dio_reset_irq(dev, group, irqbit);
+				DEBUG
+				    ("s626_irq_handler: check interrupt on dio group %d %d\n",
+				     group, i);
+				if (devpriv->ai_cmd_running) {
+					/* check if interrupt is an ai acquisition start trigger */
+					if ((irqbit >> (cmd->start_arg -
+							(16 * group)))
+					    == 1 && cmd->start_src == TRIG_EXT) {
+						DEBUG
+						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
+						     cmd->start_arg);
 
-	s = dev->subdevices + 5;
-	/* encoder (counter) subdevice */
-	s->type = COMEDI_SUBD_COUNTER;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;
-	s->n_chan = thisboard->enc_chans;
-	s->private = enc_private_data;
-	s->insn_config = s626_enc_insn_config;
-	s->insn_read = s626_enc_insn_read;
-	s->insn_write = s626_enc_insn_write;
-	s->maxdata = 0xffffff;
-	s->range_table = &range_unknown;
+						/*  Start executing the RPS program. */
+						MC_ENABLE(P_MC1, MC1_ERPS1);
 
-	/* stop ai_command */
-	devpriv->ai_cmd_running = 0;
+						DEBUG
+						    ("s626_irq_handler: acquisition start triggered!!!\n");
 
-	if (devpriv->base_addr && (devpriv->allocatedBuf == 2)) {
-		dma_addr_t pPhysBuf;
-		uint16_t chan;
+						if (cmd->scan_begin_src ==
+						    TRIG_EXT) {
+							DEBUG
+							    ("s626_ai_cmd: enable interrupt on dio channel %d\n",
+							     cmd->
+							     scan_begin_arg);
 
-		/*  enab DEBI and audio pins, enable I2C interface. */
-		MC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);
-		/*  Configure DEBI operating mode. */
-		WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	/*  Local bus is 16 */
-		       /*  bits wide. */
-		       | (DEBI_TOUT << DEBI_CFG_TOUT_BIT)
+							s626_dio_set_irq(dev,
+									 cmd->scan_begin_arg);
 
-		       /*  Declare DEBI */
-		       /*  transfer timeout */
-		       /*  interval. */
-		       |DEBI_SWAP	/*  Set up byte lane */
-		       /*  steering. */
-		       | DEBI_CFG_INTEL);	/*  Intel-compatible */
-		/*  local bus (DEBI */
-		/*  never times out). */
-		DEBUG("s626_attach: %d debi init -- %d\n",
-		      DEBI_CFG_SLAVE16 | (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
-		      DEBI_SWAP | DEBI_CFG_INTEL,
-		      DEBI_CFG_INTEL | DEBI_CFG_TOQ | DEBI_CFG_INCQ |
-		      DEBI_CFG_16Q);
+							DEBUG
+							    ("s626_irq_handler: External scan trigger is set!!!\n");
+						}
+					}
+					if ((irqbit >> (cmd->scan_begin_arg -
+							(16 * group)))
+					    == 1
+					    && cmd->scan_begin_src ==
+					    TRIG_EXT) {
+						DEBUG
+						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
+						     cmd->scan_begin_arg);
 
-		/* DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ */
-		/* | DEBI_CFG_INCQ| DEBI_CFG_16Q); //end */
+						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
+						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
-		/*  Paging is disabled. */
-		WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);	/*  Disable MMU paging. */
+						DEBUG
+						    ("s626_irq_handler: scan triggered!!! %d\n",
+						     devpriv->ai_sample_count);
+						if (cmd->convert_src ==
+						    TRIG_EXT) {
 
-		/*  Init GPIO so that ADC Start* is negated. */
-		WR7146(P_GPIO, GPIO_BASE | GPIO1_HI);
+							DEBUG
+							    ("s626_ai_cmd: enable interrupt on dio channel %d group %d\n",
+							     cmd->convert_arg -
+							     (16 * group),
+							     group);
 
-		/* IsBoardRevA is a boolean that indicates whether the board is RevA.
-		 *
-		 * VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
-		 * EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
-		 * is used to access the onboard serial EEPROM.  The EEPROM's I2C
-		 * DeviceAddress is hardwired to a value that is dependent on the
-		 * 626 board revision.  On all board revisions, the EEPROM stores
-		 * TrimDAC calibration constants for analog I/O.  On RevB and
-		 * higher boards, the DeviceAddress is hardwired to 0 to enable
-		 * the EEPROM to also store the PCI SubVendorID and SubDeviceID;
-		 * this is the address at which the SAA7146 expects a
-		 * configuration EEPROM to reside.  On RevA boards, the EEPROM
-		 * device address, which is hardwired to 4, prevents the SAA7146
-		 * from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
-		 * default values, instead.
-		 */
+							devpriv->ai_convert_count
+							    = cmd->chanlist_len;
 
-		/*     devpriv->I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM */
-		/*  DeviceType (0xA0) */
-		/*  and DeviceAddress<<1. */
+							s626_dio_set_irq(dev,
+									 cmd->convert_arg);
 
-		devpriv->I2CAdrs = 0xA0;	/*  I2C device address for onboard */
-		/*  eeprom(revb) */
+							DEBUG
+							    ("s626_irq_handler: External convert trigger is set!!!\n");
+						}
 
-		/*  Issue an I2C ABORT command to halt any I2C operation in */
-		/* progress and reset BUSY flag. */
-		WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);
-		/*  Write I2C control: abort any I2C activity. */
-		MC_ENABLE(P_MC2, MC2_UPLD_IIC);
-		/*  Invoke command  upload */
-		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)
-			;
-		/*  and wait for upload to complete. */
+						if (cmd->convert_src ==
+						    TRIG_TIMER) {
+							k = &encpriv[5];
+							devpriv->ai_convert_count
+							    = cmd->chanlist_len;
+							k->SetEnable(dev, k,
+								     CLKENAB_ALWAYS);
+						}
+					}
+					if ((irqbit >> (cmd->convert_arg -
+							(16 * group)))
+					    == 1
+					    && cmd->convert_src == TRIG_EXT) {
+						DEBUG
+						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
+						     cmd->convert_arg);
 
-		/* Per SAA7146 data sheet, write to STATUS reg twice to
-		 * reset all  I2C error flags. */
-		for (i = 0; i < 2; i++) {
-			WR7146(P_I2CSTAT, I2C_CLKSEL);
-			/*  Write I2C control: reset  error flags. */
-			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	/*  Invoke command upload */
-			while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
-				;
-			/* and wait for upload to complete. */
-		}
+						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
+						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
-		/* Init audio interface functional attributes: set DAC/ADC
-		 * serial clock rates, invert DAC serial clock so that
-		 * DAC data setup times are satisfied, enable DAC serial
-		 * clock out.
-		 */
+						DEBUG
+						    ("s626_irq_handler: adc convert triggered!!!\n");
 
-		WR7146(P_ACON2, ACON2_INIT);
+						devpriv->ai_convert_count--;
 
-		/* Set up TSL1 slot list, which is used to control the
-		 * accumulation of ADC data: RSD1 = shift data in on SD1.
-		 * SIB_A1  = store data uint8_t at next available location in
-		 * FB BUFFER1  register. */
-		WR7146(P_TSL1, RSD1 | SIB_A1);
-		/*  Fetch ADC high data uint8_t. */
-		WR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);
-		/*  Fetch ADC low data uint8_t; end of TSL1. */
+						if (devpriv->ai_convert_count >
+						    0) {
 
-		/*  enab TSL1 slot list so that it executes all the time. */
-		WR7146(P_ACON1, ACON1_ADCSTART);
+							DEBUG
+							    ("s626_ai_cmd: enable interrupt on dio channel %d group %d\n",
+							     cmd->convert_arg -
+							     (16 * group),
+							     group);
 
-		/*  Initialize RPS registers used for ADC. */
+							s626_dio_set_irq(dev,
+									 cmd->convert_arg);
 
-		/* Physical start of RPS program. */
-		WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
+							DEBUG
+							    ("s626_irq_handler: External trigger is set!!!\n");
+						}
+					}
+				}
+				break;
+			}
+		}
 
-		WR7146(P_RPSPAGE1, 0);
-		/*  RPS program performs no explicit mem writes. */
-		WR7146(P_RPS1_TOUT, 0);	/*  Disable RPS timeouts. */
+		/* read interrupt type */
+		irqbit = DEBIread(dev, LP_RDMISC2);
 
-		/* SAA7146 BUG WORKAROUND.  Initialize SAA7146 ADC interface
-		 * to a known state by invoking ADCs until FB BUFFER 1
-		 * register shows that it is correctly receiving ADC data.
-		 * This is necessary because the SAA7146 ADC interface does
-		 * not start up in a defined state after a PCI reset.
-		 */
+		/* check interrupt on counters */
+		DEBUG("s626_irq_handler: check counters interrupt %d\n",
+		      irqbit);
 
-/*     PollList = EOPL;		// Create a simple polling */
-/*				// list for analog input */
-/*				// channel 0. */
-/*     ResetADC( dev, &PollList ); */
+		if (irqbit & IRQ_COINT1A) {
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 1A overflow\n");
+			k = &encpriv[0];
 
-/*     s626_ai_rinsn(dev,dev->subdevices,NULL,data); //( &AdcData ); // */
-/*							//Get initial ADC */
-/*							//value. */
+			/* clear interrupt capture flag */
+			k->ResetCapFlags(dev, k);
+		}
+		if (irqbit & IRQ_COINT2A) {
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 2A overflow\n");
+			k = &encpriv[1];
 
-/*     StartVal = data[0]; */
-
-/*     // VERSION 2.01 CHANGE: TIMEOUT ADDED TO PREVENT HANGED EXECUTION. */
-/*     // Invoke ADCs until the new ADC value differs from the initial */
-/*     // value or a timeout occurs.  The timeout protects against the */
-/*     // possibility that the driver is restarting and the ADC data is a */
-/*     // fixed value resulting from the applied ADC analog input being */
-/*     // unusually quiet or at the rail. */
+			/* clear interrupt capture flag */
+			k->ResetCapFlags(dev, k);
+		}
+		if (irqbit & IRQ_COINT3A) {
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 3A overflow\n");
+			k = &encpriv[2];
 
-/*     for ( index = 0; index < 500; index++ ) */
-/*       { */
-/*	s626_ai_rinsn(dev,dev->subdevices,NULL,data); */
-/*	AdcData = data[0];	//ReadADC(  &AdcData ); */
-/*	if ( AdcData != StartVal ) */
-/*		break; */
-/*       } */
+			/* clear interrupt capture flag */
+			k->ResetCapFlags(dev, k);
+		}
+		if (irqbit & IRQ_COINT1B) {
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 1B overflow\n");
+			k = &encpriv[3];
 
-		/*  end initADC */
+			/* clear interrupt capture flag */
+			k->ResetCapFlags(dev, k);
+		}
+		if (irqbit & IRQ_COINT2B) {
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 2B overflow\n");
+			k = &encpriv[4];
 
-		/*  init the DAC interface */
+			/* clear interrupt capture flag */
+			k->ResetCapFlags(dev, k);
 
-		/* Init Audio2's output DMAC attributes: burst length = 1
-		 * DWORD,  threshold = 1 DWORD.
-		 */
-		WR7146(P_PCI_BT_A, 0);
+			if (devpriv->ai_convert_count > 0) {
+				devpriv->ai_convert_count--;
+				if (devpriv->ai_convert_count == 0)
+					k->SetEnable(dev, k, CLKENAB_INDEX);
 
-		/* Init Audio2's output DMA physical addresses.  The protection
-		 * address is set to 1 DWORD past the base address so that a
-		 * single DWORD will be transferred each time a DMA transfer is
-		 * enabled. */
+				if (cmd->convert_src == TRIG_TIMER) {
+					DEBUG
+					    ("s626_irq_handler: conver timer trigger!!! %d\n",
+					     devpriv->ai_convert_count);
 
-		pPhysBuf =
-		    devpriv->ANABuf.PhysicalBase +
-		    (DAC_WDMABUF_OS * sizeof(uint32_t));
+					/*  Trigger ADC scan loop start by setting RPS Signal 0. */
+					MC_ENABLE(P_MC2, MC2_ADC_RPS);
+				}
+			}
+		}
+		if (irqbit & IRQ_COINT3B) {
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 3B overflow\n");
+			k = &encpriv[5];
 
-		WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	/*  Buffer base adrs. */
-		WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	/*  Protection address. */
+			/* clear interrupt capture flag */
+			k->ResetCapFlags(dev, k);
 
-		/* Cache Audio2's output DMA buffer logical address.  This is
-		 * where DAC data is buffered for A2 output DMA transfers. */
-		devpriv->pDacWBuf =
-		    (uint32_t *) devpriv->ANABuf.LogicalBase + DAC_WDMABUF_OS;
+			if (cmd->scan_begin_src == TRIG_TIMER) {
+				DEBUG
+				    ("s626_irq_handler: scan timer trigger!!!\n");
 
-		/* Audio2's output channels does not use paging.  The protection
-		 * violation handling bit is set so that the DMAC will
-		 * automatically halt and its PCI address pointer will be reset
-		 * when the protection address is reached. */
+				/*  Trigger ADC scan loop start by setting RPS Signal 0. */
+				MC_ENABLE(P_MC2, MC2_ADC_RPS);
+			}
 
-		WR7146(P_PAGEA2_OUT, 8);
+			if (cmd->convert_src == TRIG_TIMER) {
+				DEBUG
+				    ("s626_irq_handler: convert timer trigger is set\n");
+				k = &encpriv[4];
+				devpriv->ai_convert_count = cmd->chanlist_len;
+				k->SetEnable(dev, k, CLKENAB_ALWAYS);
+			}
+		}
+	}
 
-		/* Initialize time slot list 2 (TSL2), which is used to control
-		 * the clock generation for and serialization of data to be sent
-		 * to the DAC devices.  Slot 0 is a NOP that is used to trap TSL
-		 * execution; this permits other slots to be safely modified
-		 * without first turning off the TSL sequencer (which is
-		 * apparently impossible to do).  Also, SD3 (which is driven by a
-		 * pull-up resistor) is shifted in and stored to the MSB of
-		 * FB_BUFFER2 to be used as evidence that the slot sequence has
-		 * not yet finished executing.
-		 */
+	/* enable interrupt */
+	writel(irqstatus, devpriv->base_addr + P_IER);
 
-		SETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);
-		/*  Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2. */
+	DEBUG("s626_irq_handler: exit interrupt service routine.\n");
 
-		/* Initialize slot 1, which is constant.  Slot 1 causes a
-		 * DWORD to be transferred from audio channel 2's output FIFO
-		 * to the FIFO's output buffer so that it can be serialized
-		 * and sent to the DAC during subsequent slots.  All remaining
-		 * slots are dynamically populated as required by the target
-		 * DAC device.
-		 */
-		SETVECT(1, LF_A2);
-		/*  Slot 1: Fetch DWORD from Audio2's output FIFO. */
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+	return IRQ_HANDLED;
+}
 
-		/*  Start DAC's audio interface (TSL2) running. */
-		WR7146(P_ACON1, ACON1_DACSTART);
+/*
+ * this functions build the RPS program for hardware driven acquistion
+ */
+static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
+{
+	register uint32_t *pRPS;
+	uint32_t JmpAdrs;
+	uint16_t i;
+	uint16_t n;
+	uint32_t LocalPPL;
+	struct comedi_cmd *cmd = &(dev->subdevices->async->cmd);
 
-		/* end init DAC interface */
+	/*  Stop RPS program in case it is currently running. */
+	MC_DISABLE(P_MC1, MC1_ERPS1);
 
-		/* Init Trim DACs to calibrated values.  Do it twice because the
-		 * SAA7146 audio channel does not always reset properly and
-		 * sometimes causes the first few TrimDAC writes to malfunction.
-		 */
+	/*  Set starting logical address to write RPS commands. */
+	pRPS = (uint32_t *) devpriv->RPSBuf.LogicalBase;
 
-		LoadTrimDACs(dev);
-		LoadTrimDACs(dev);	/*  Insurance. */
+	/*  Initialize RPS instruction pointer. */
+	WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
 
-		/* Manually init all gate array hardware in case this is a soft
-		 * reset (we have no way of determining whether this is a warm
-		 * or cold start).  This is necessary because the gate array will
-		 * reset only in response to a PCI hard reset; there is no soft
-		 * reset function. */
+	/*  Construct RPS program in RPSBuf DMA buffer */
 
-		/* Init all DAC outputs to 0V and init all DAC setpoint and
-		 * polarity images.
-		 */
-		for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
-			SetDAC(dev, chan, 0);
+	if (cmd != NULL && cmd->scan_begin_src != TRIG_FOLLOW) {
+		DEBUG("ResetADC: scan_begin pause inserted\n");
+		/*  Wait for Start trigger. */
+		*pRPS++ = RPS_PAUSE | RPS_SIGADC;
+		*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
+	}
 
-		/* Init image of WRMISC2 Battery Charger Enabled control bit.
-		 * This image is used when the state of the charger control bit,
-		 * which has no direct hardware readback mechanism, is queried.
-		 */
-		devpriv->ChargeEnabled = 0;
+	/* SAA7146 BUG WORKAROUND Do a dummy DEBI Write.  This is necessary
+	 * because the first RPS DEBI Write following a non-RPS DEBI write
+	 * seems to always fail.  If we don't do this dummy write, the ADC
+	 * gain might not be set to the value required for the first slot in
+	 * the poll list; the ADC gain would instead remain unchanged from
+	 * the previously programmed value.
+	 */
+	*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
+	/* Write DEBI Write command and address to shadow RAM. */
 
-		/* Init image of watchdog timer interval in WRMISC2.  This image
-		 * maintains the value of the control bits of MISC2 are
-		 * continuously reset to zero as long as the WD timer is disabled.
-		 */
-		devpriv->WDInterval = 0;
+	*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
+	*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
+	/*  Write DEBI immediate data  to shadow RAM: */
 
-		/* Init Counter Interrupt enab mask for RDMISC2.  This mask is
-		 * applied against MISC2 when testing to determine which timer
-		 * events are requesting interrupt service.
-		 */
-		devpriv->CounterIntEnabs = 0;
+	*pRPS++ = GSEL_BIPOLAR5V;
+	/*  arbitrary immediate data  value. */
 
-		/*  Init counters. */
-		CountersInit(dev);
+	*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
+	/*  Reset "shadow RAM  uploaded" flag. */
+	*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/*  Invoke shadow RAM upload. */
+	*pRPS++ = RPS_PAUSE | RPS_DEBI;	/*  Wait for shadow upload to finish. */
 
-		/* Without modifying the state of the Battery Backup enab, disable
-		 * the watchdog timer, set DIO channels 0-5 to operate in the
-		 * standard DIO (vs. counter overflow) mode, disable the battery
-		 * charger, and reset the watchdog interval selector to zero.
+	/* Digitize all slots in the poll list. This is implemented as a
+	 * for loop to limit the slot count to 16 in case the application
+	 * forgot to set the EOPL flag in the final slot.
+	 */
+	for (devpriv->AdcItems = 0; devpriv->AdcItems < 16; devpriv->AdcItems++) {
+		/* Convert application's poll list item to private board class
+		 * format.  Each app poll list item is an uint8_t with form
+		 * (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
+		 * +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
 		 */
-		WriteMISC2(dev, (uint16_t) (DEBIread(dev,
-						     LP_RDMISC2) &
-					    MISC2_BATT_ENABLE));
+		LocalPPL =
+		    (*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
+				   GSEL_BIPOLAR10V);
 
-		/*  Initialize the digital I/O subsystem. */
-		s626_dio_init(dev);
+		/*  Switch ADC analog gain. */
+		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	/*  Write DEBI command */
+		/*  and address to */
+		/*  shadow RAM. */
+		*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
+		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	/*  Write DEBI */
+		/*  immediate data to */
+		/*  shadow RAM. */
+		*pRPS++ = LocalPPL;
+		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	/*  Reset "shadow RAM uploaded" */
+		/*  flag. */
+		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/*  Invoke shadow RAM upload. */
+		*pRPS++ = RPS_PAUSE | RPS_DEBI;	/*  Wait for shadow upload to */
+		/*  finish. */
 
-		/* enable interrupt test */
-		/*  writel(IRQ_GPIO3 | IRQ_RPS1,devpriv->base_addr+P_IER); */
-	}
+		/*  Select ADC analog input channel. */
+		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
+		/*  Write DEBI command and address to  shadow RAM. */
+		*pRPS++ = DEBI_CMD_WRWORD | LP_ISEL;
+		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
+		/*  Write DEBI immediate data to shadow RAM. */
+		*pRPS++ = LocalPPL;
+		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
+		/*  Reset "shadow RAM uploaded"  flag. */
 
-	DEBUG("s626_attach: comedi%d s626 attached %04x\n", dev->minor,
-	      (uint32_t) devpriv->base_addr);
+		*pRPS++ = RPS_UPLOAD | RPS_DEBI;
+		/*  Invoke shadow RAM upload. */
 
-	return 1;
-}
+		*pRPS++ = RPS_PAUSE | RPS_DEBI;
+		/*  Wait for shadow upload to finish. */
 
-static unsigned int s626_ai_reg_to_uint(int data)
-{
-	unsigned int tempdata;
+		/* Delay at least 10 microseconds for analog input settling.
+		 * Instead of padding with NOPs, we use RPS_JUMP instructions
+		 * here; this allows us to produce a longer delay than is
+		 * possible with NOPs because each RPS_JUMP flushes the RPS'
+		 * instruction prefetch pipeline.
+		 */
+		JmpAdrs =
+		    (uint32_t) devpriv->RPSBuf.PhysicalBase +
+		    (uint32_t) ((unsigned long)pRPS -
+				(unsigned long)devpriv->RPSBuf.LogicalBase);
+		for (i = 0; i < (10 * RPSCLK_PER_US / 2); i++) {
+			JmpAdrs += 8;	/*  Repeat to implement time delay: */
+			*pRPS++ = RPS_JUMP;	/*  Jump to next RPS instruction. */
+			*pRPS++ = JmpAdrs;
+		}
 
-	tempdata = (data >> 18);
-	if (tempdata & 0x2000)
-		tempdata &= 0x1fff;
-	else
-		tempdata += (1 << 13);
+		if (cmd != NULL && cmd->convert_src != TRIG_NOW) {
+			DEBUG("ResetADC: convert pause inserted\n");
+			/*  Wait for Start trigger. */
+			*pRPS++ = RPS_PAUSE | RPS_SIGADC;
+			*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
+		}
+		/*  Start ADC by pulsing GPIO1. */
+		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  Begin ADC Start pulse. */
+		*pRPS++ = GPIO_BASE | GPIO1_LO;
+		*pRPS++ = RPS_NOP;
+		/*  VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
+		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  End ADC Start pulse. */
+		*pRPS++ = GPIO_BASE | GPIO1_HI;
 
-	return tempdata;
-}
+		/* Wait for ADC to complete (GPIO2 is asserted high when ADC not
+		 * busy) and for data from previous conversion to shift into FB
+		 * BUFFER 1 register.
+		 */
+		*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/*  Wait for ADC done. */
 
-/* static unsigned int s626_uint_to_reg(struct comedi_subdevice *s, int data){ */
-/*   return 0; */
-/* } */
+		/*  Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
+		*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
+		*pRPS++ =
+		    (uint32_t) devpriv->ANABuf.PhysicalBase +
+		    (devpriv->AdcItems << 2);
 
-static irqreturn_t s626_irq_handler(int irq, void *d)
-{
-	struct comedi_device *dev = d;
-	struct comedi_subdevice *s;
-	struct comedi_cmd *cmd;
-	struct enc_private *k;
-	unsigned long flags;
-	int32_t *readaddr;
-	uint32_t irqtype, irqstatus;
-	int i = 0;
-	short tempdata;
-	uint8_t group;
-	uint16_t irqbit;
+		/*  If this slot's EndOfPollList flag is set, all channels have */
+		/*  now been processed. */
+		if (*ppl++ & EOPL) {
+			devpriv->AdcItems++;	/*  Adjust poll list item count. */
+			break;	/*  Exit poll list processing loop. */
+		}
+	}
+	DEBUG("ResetADC: ADC items %d\n", devpriv->AdcItems);
 
-	DEBUG("s626_irq_handler: interrupt request received!!!\n");
+	/* VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
+	 * ADC to stabilize for 2 microseconds before starting the final
+	 * (dummy) conversion.  This delay is necessary to allow sufficient
+	 * time between last conversion finished and the start of the dummy
+	 * conversion.  Without this delay, the last conversion's data value
+	 * is sometimes set to the previous conversion's data value.
+	 */
+	for (n = 0; n < (2 * RPSCLK_PER_US); n++)
+		*pRPS++ = RPS_NOP;
 
-	if (dev->attached == 0)
-		return IRQ_NONE;
-	/*  lock to avoid race with comedi_poll */
-	spin_lock_irqsave(&dev->spinlock, flags);
+	/* Start a dummy conversion to cause the data from the last
+	 * conversion of interest to be shifted in.
+	 */
+	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  Begin ADC Start pulse. */
+	*pRPS++ = GPIO_BASE | GPIO1_LO;
+	*pRPS++ = RPS_NOP;
+	/* VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
+	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  End ADC Start pulse. */
+	*pRPS++ = GPIO_BASE | GPIO1_HI;
 
-	/* save interrupt enable register state */
-	irqstatus = readl(devpriv->base_addr + P_IER);
+	/* Wait for the data from the last conversion of interest to arrive
+	 * in FB BUFFER 1 register.
+	 */
+	*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/*  Wait for ADC done. */
 
-	/* read interrupt type */
-	irqtype = readl(devpriv->base_addr + P_ISR);
+	/*  Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
+	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);	/*  */
+	*pRPS++ =
+	    (uint32_t) devpriv->ANABuf.PhysicalBase + (devpriv->AdcItems << 2);
 
-	/* disable master interrupt */
-	writel(0, devpriv->base_addr + P_IER);
+	/*  Indicate ADC scan loop is finished. */
+	/*  *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC ;  // Signal ReadADC() that scan is done. */
 
-	/* clear interrupt */
-	writel(irqtype, devpriv->base_addr + P_ISR);
+	/* invoke interrupt */
+	if (devpriv->ai_cmd_running == 1) {
+		DEBUG("ResetADC: insert irq in ADC RPS task\n");
+		*pRPS++ = RPS_IRQ;
+	}
+	/*  Restart RPS program at its beginning. */
+	*pRPS++ = RPS_JUMP;	/*  Branch to start of RPS program. */
+	*pRPS++ = (uint32_t) devpriv->RPSBuf.PhysicalBase;
 
-	/* do somethings */
-	DEBUG("s626_irq_handler: interrupt type %d\n", irqtype);
+	/*  End of RPS program build */
+}
 
-	switch (irqtype) {
-	case IRQ_RPS1:		/*  end_of_scan occurs */
+/* TO COMPLETE, IF NECESSARY */
+static int s626_ai_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
+{
 
-		DEBUG("s626_irq_handler: RPS1 irq detected\n");
+	return -EINVAL;
+}
 
-		/*  manage ai subdevice */
-		s = dev->subdevices;
-		cmd = &(s->async->cmd);
+/* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data) */
+/* { */
+/*   register uint8_t	i; */
+/*   register int32_t	*readaddr; */
 
-		/* Init ptr to DMA buffer that holds new ADC data.  We skip the
-		 * first uint16_t in the buffer because it contains junk data from
-		 * the final ADC of the previous poll list scan.
-		 */
-		readaddr = (int32_t *) devpriv->ANABuf.LogicalBase + 1;
+/*   DEBUG("as626_ai_rinsn: ai_rinsn enter\n");  */
 
-		/*  get the data and hand it over to comedi */
-		for (i = 0; i < (s->async->cmd.chanlist_len); i++) {
-			/*  Convert ADC data to 16-bit integer values and copy to application */
-			/*  buffer. */
-			tempdata = s626_ai_reg_to_uint((int)*readaddr);
-			readaddr++;
+/*   Trigger ADC scan loop start by setting RPS Signal 0. */
+/*   MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
 
-			/* put data into read buffer */
-			/*  comedi_buf_put(s->async, tempdata); */
-			if (cfc_write_to_buffer(s, tempdata) == 0)
-				printk
-				    ("s626_irq_handler: cfc_write_to_buffer error!\n");
+/*   Wait until ADC scan loop is finished (RPS Signal 0 reset). */
+/*   while ( MC_TEST( P_MC2, MC2_ADC_RPS ) ); */
 
-			DEBUG("s626_irq_handler: ai channel %d acquired: %d\n",
-			      i, tempdata);
-		}
+/* Init ptr to DMA buffer that holds new ADC data.  We skip the
+ * first uint16_t in the buffer because it contains junk data from
+ * the final ADC of the previous poll list scan.
+ */
+/*   readaddr = (uint32_t *)devpriv->ANABuf.LogicalBase + 1; */
 
-		/* end of scan occurs */
-		s->async->events |= COMEDI_CB_EOS;
+/*  Convert ADC data to 16-bit integer values and copy to application buffer. */
+/*   for ( i = 0; i < devpriv->AdcItems; i++ ) { */
+/*     *data = s626_ai_reg_to_uint( *readaddr++ ); */
+/*     DEBUG("s626_ai_rinsn: data %d\n",*data); */
+/*     data++; */
+/*   } */
 
-		if (!(devpriv->ai_continous))
-			devpriv->ai_sample_count--;
-		if (devpriv->ai_sample_count <= 0) {
-			devpriv->ai_cmd_running = 0;
+/*   DEBUG("s626_ai_rinsn: ai_rinsn escape\n"); */
+/*   return i; */
+/* } */
 
-			/*  Stop RPS program. */
-			MC_DISABLE(P_MC1, MC1_ERPS1);
+static int s626_ai_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
+{
+	uint16_t chan = CR_CHAN(insn->chanspec);
+	uint16_t range = CR_RANGE(insn->chanspec);
+	uint16_t AdcSpec = 0;
+	uint32_t GpioImage;
+	int n;
 
-			/* send end of acquisition */
-			s->async->events |= COMEDI_CB_EOA;
+	/* interrupt call test  */
+/*   writel(IRQ_GPIO3,devpriv->base_addr+P_PSR); */
+	/* Writing a logical 1 into any of the RPS_PSR bits causes the
+	 * corresponding interrupt to be generated if enabled
+	 */
 
-			/* disable master interrupt */
-			irqstatus = 0;
-		}
+	DEBUG("s626_ai_insn_read: entering\n");
 
-		if (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT) {
-			DEBUG
-			    ("s626_irq_handler: enable interrupt on dio channel %d\n",
-			     cmd->scan_begin_arg);
+	/* Convert application's ADC specification into form
+	 *  appropriate for register programming.
+	 */
+	if (range == 0)
+		AdcSpec = (chan << 8) | (GSEL_BIPOLAR5V);
+	else
+		AdcSpec = (chan << 8) | (GSEL_BIPOLAR10V);
 
-			s626_dio_set_irq(dev, cmd->scan_begin_arg);
+	/*  Switch ADC analog gain. */
+	DEBIwrite(dev, LP_GSEL, AdcSpec);	/*  Set gain. */
 
-			DEBUG("s626_irq_handler: External trigger is set!!!\n");
-		}
-		/*  tell comedi that data is there */
-		DEBUG("s626_irq_handler: events %d\n", s->async->events);
-		comedi_event(dev, s);
-		break;
-	case IRQ_GPIO3:	/* check dio and conter interrupt */
+	/*  Select ADC analog input channel. */
+	DEBIwrite(dev, LP_ISEL, AdcSpec);	/*  Select channel. */
 
-		DEBUG("s626_irq_handler: GPIO3 irq detected\n");
+	for (n = 0; n < insn->n; n++) {
 
-		/*  manage ai subdevice */
-		s = dev->subdevices;
-		cmd = &(s->async->cmd);
+		/*  Delay 10 microseconds for analog input settling. */
+		udelay(10);
 
-		/* s626_dio_clear_irq(dev); */
+		/*  Start ADC by pulsing GPIO1 low. */
+		GpioImage = RR7146(P_GPIO);
+		/*  Assert ADC Start command */
+		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
+		/*    and stretch it out. */
+		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
+		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
+		/*  Negate ADC Start command. */
+		WR7146(P_GPIO, GpioImage | GPIO1_HI);
 
-		for (group = 0; group < S626_DIO_BANKS; group++) {
-			irqbit = 0;
-			/* read interrupt type */
-			irqbit = DEBIread(dev,
-					  ((struct dio_private *)(dev->
-								  subdevices +
-								  2 +
-								  group)->
-					   private)->RDCapFlg);
-
-			/* check if interrupt is generated from dio channels */
-			if (irqbit) {
-				s626_dio_reset_irq(dev, group, irqbit);
-				DEBUG
-				    ("s626_irq_handler: check interrupt on dio group %d %d\n",
-				     group, i);
-				if (devpriv->ai_cmd_running) {
-					/* check if interrupt is an ai acquisition start trigger */
-					if ((irqbit >> (cmd->start_arg -
-							(16 * group)))
-					    == 1 && cmd->start_src == TRIG_EXT) {
-						DEBUG
-						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
-						     cmd->start_arg);
+		/*  Wait for ADC to complete (GPIO2 is asserted high when */
+		/*  ADC not busy) and for data from previous conversion to */
+		/*  shift into FB BUFFER 1 register. */
 
-						/*  Start executing the RPS program. */
-						MC_ENABLE(P_MC1, MC1_ERPS1);
+		/*  Wait for ADC done. */
+		while (!(RR7146(P_PSR) & PSR_GPIO2))
+			;
 
-						DEBUG
-						    ("s626_irq_handler: acquisition start triggered!!!\n");
+		/*  Fetch ADC data. */
+		if (n != 0)
+			data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
 
-						if (cmd->scan_begin_src ==
-						    TRIG_EXT) {
-							DEBUG
-							    ("s626_ai_cmd: enable interrupt on dio channel %d\n",
-							     cmd->
-							     scan_begin_arg);
+		/* Allow the ADC to stabilize for 4 microseconds before
+		 * starting the next (final) conversion.  This delay is
+		 * necessary to allow sufficient time between last
+		 * conversion finished and the start of the next
+		 * conversion.  Without this delay, the last conversion's
+		 * data value is sometimes set to the previous
+		 * conversion's data value.
+		 */
+		udelay(4);
+	}
 
-							s626_dio_set_irq(dev,
-									 cmd->scan_begin_arg);
+	/* Start a dummy conversion to cause the data from the
+	 * previous conversion to be shifted in. */
+	GpioImage = RR7146(P_GPIO);
 
-							DEBUG
-							    ("s626_irq_handler: External scan trigger is set!!!\n");
-						}
-					}
-					if ((irqbit >> (cmd->scan_begin_arg -
-							(16 * group)))
-					    == 1
-					    && cmd->scan_begin_src ==
-					    TRIG_EXT) {
-						DEBUG
-						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
-						     cmd->scan_begin_arg);
+	/* Assert ADC Start command */
+	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
+	/*    and stretch it out. */
+	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
+	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
+	/*  Negate ADC Start command. */
+	WR7146(P_GPIO, GpioImage | GPIO1_HI);
 
-						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
-						MC_ENABLE(P_MC2, MC2_ADC_RPS);
+	/*  Wait for the data to arrive in FB BUFFER 1 register. */
 
-						DEBUG
-						    ("s626_irq_handler: scan triggered!!! %d\n",
-						     devpriv->ai_sample_count);
-						if (cmd->convert_src ==
-						    TRIG_EXT) {
+	/*  Wait for ADC done. */
+	while (!(RR7146(P_PSR) & PSR_GPIO2))
+		;
 
-							DEBUG
-							    ("s626_ai_cmd: enable interrupt on dio channel %d group %d\n",
-							     cmd->convert_arg -
-							     (16 * group),
-							     group);
+	/*  Fetch ADC data from audio interface's input shift register. */
 
-							devpriv->ai_convert_count
-							    = cmd->chanlist_len;
+	/*  Fetch ADC data. */
+	if (n != 0)
+		data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
 
-							s626_dio_set_irq(dev,
-									 cmd->convert_arg);
+	DEBUG("s626_ai_insn_read: samples %d, data %d\n", n, data[n - 1]);
 
-							DEBUG
-							    ("s626_irq_handler: External convert trigger is set!!!\n");
-						}
+	return n;
+}
 
-						if (cmd->convert_src ==
-						    TRIG_TIMER) {
-							k = &encpriv[5];
-							devpriv->ai_convert_count
-							    = cmd->chanlist_len;
-							k->SetEnable(dev, k,
-								     CLKENAB_ALWAYS);
-						}
-					}
-					if ((irqbit >> (cmd->convert_arg -
-							(16 * group)))
-					    == 1
-					    && cmd->convert_src == TRIG_EXT) {
-						DEBUG
-						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
-						     cmd->convert_arg);
+static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)
+{
 
-						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
-						MC_ENABLE(P_MC2, MC2_ADC_RPS);
+	int n;
 
-						DEBUG
-						    ("s626_irq_handler: adc convert triggered!!!\n");
+	for (n = 0; n < cmd->chanlist_len; n++) {
+		if (CR_RANGE((cmd->chanlist)[n]) == 0)
+			ppl[n] = (CR_CHAN((cmd->chanlist)[n])) | (RANGE_5V);
+		else
+			ppl[n] = (CR_CHAN((cmd->chanlist)[n])) | (RANGE_10V);
+	}
+	if (n != 0)
+		ppl[n - 1] |= EOPL;
 
-						devpriv->ai_convert_count--;
+	return n;
+}
 
-						if (devpriv->ai_convert_count >
-						    0) {
+static int s626_ai_inttrig(struct comedi_device *dev,
+			   struct comedi_subdevice *s, unsigned int trignum)
+{
+	if (trignum != 0)
+		return -EINVAL;
 
-							DEBUG
-							    ("s626_ai_cmd: enable interrupt on dio channel %d group %d\n",
-							     cmd->convert_arg -
-							     (16 * group),
-							     group);
+	DEBUG("s626_ai_inttrig: trigger adc start...");
 
-							s626_dio_set_irq(dev,
-									 cmd->convert_arg);
+	/*  Start executing the RPS program. */
+	MC_ENABLE(P_MC1, MC1_ERPS1);
 
-							DEBUG
-							    ("s626_irq_handler: External trigger is set!!!\n");
-						}
-					}
-				}
-				break;
-			}
-		}
+	s->async->inttrig = NULL;
 
-		/* read interrupt type */
-		irqbit = DEBIread(dev, LP_RDMISC2);
+	DEBUG(" done\n");
 
-		/* check interrupt on counters */
-		DEBUG("s626_irq_handler: check counters interrupt %d\n",
-		      irqbit);
+	return 1;
+}
 
-		if (irqbit & IRQ_COINT1A) {
-			DEBUG
-			    ("s626_irq_handler: interrupt on counter 1A overflow\n");
-			k = &encpriv[0];
+/*  TO COMPLETE  */
+static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+{
 
-			/* clear interrupt capture flag */
-			k->ResetCapFlags(dev, k);
-		}
-		if (irqbit & IRQ_COINT2A) {
-			DEBUG
-			    ("s626_irq_handler: interrupt on counter 2A overflow\n");
-			k = &encpriv[1];
+	uint8_t ppl[16];
+	struct comedi_cmd *cmd = &s->async->cmd;
+	struct enc_private *k;
+	int tick;
 
-			/* clear interrupt capture flag */
-			k->ResetCapFlags(dev, k);
-		}
-		if (irqbit & IRQ_COINT3A) {
-			DEBUG
-			    ("s626_irq_handler: interrupt on counter 3A overflow\n");
-			k = &encpriv[2];
+	DEBUG("s626_ai_cmd: entering command function\n");
 
-			/* clear interrupt capture flag */
-			k->ResetCapFlags(dev, k);
-		}
-		if (irqbit & IRQ_COINT1B) {
-			DEBUG
-			    ("s626_irq_handler: interrupt on counter 1B overflow\n");
-			k = &encpriv[3];
+	if (devpriv->ai_cmd_running) {
+		printk(KERN_ERR "s626_ai_cmd: Another ai_cmd is running %d\n",
+		       dev->minor);
+		return -EBUSY;
+	}
+	/* disable interrupt */
+	writel(0, devpriv->base_addr + P_IER);
 
-			/* clear interrupt capture flag */
-			k->ResetCapFlags(dev, k);
-		}
-		if (irqbit & IRQ_COINT2B) {
-			DEBUG
-			    ("s626_irq_handler: interrupt on counter 2B overflow\n");
-			k = &encpriv[4];
+	/* clear interrupt request */
+	writel(IRQ_RPS1 | IRQ_GPIO3, devpriv->base_addr + P_ISR);
 
-			/* clear interrupt capture flag */
-			k->ResetCapFlags(dev, k);
+	/* clear any pending interrupt */
+	s626_dio_clear_irq(dev);
+	/*   s626_enc_clear_irq(dev); */
 
-			if (devpriv->ai_convert_count > 0) {
-				devpriv->ai_convert_count--;
-				if (devpriv->ai_convert_count == 0)
-					k->SetEnable(dev, k, CLKENAB_INDEX);
+	/* reset ai_cmd_running flag */
+	devpriv->ai_cmd_running = 0;
 
-				if (cmd->convert_src == TRIG_TIMER) {
-					DEBUG
-					    ("s626_irq_handler: conver timer trigger!!! %d\n",
-					     devpriv->ai_convert_count);
+	/*  test if cmd is valid */
+	if (cmd == NULL) {
+		DEBUG("s626_ai_cmd: NULL command\n");
+		return -EINVAL;
+	} else {
+		DEBUG("s626_ai_cmd: command received!!!\n");
+	}
 
-					/*  Trigger ADC scan loop start by setting RPS Signal 0. */
-					MC_ENABLE(P_MC2, MC2_ADC_RPS);
-				}
-			}
-		}
-		if (irqbit & IRQ_COINT3B) {
-			DEBUG
-			    ("s626_irq_handler: interrupt on counter 3B overflow\n");
-			k = &encpriv[5];
+	if (dev->irq == 0) {
+		comedi_error(dev,
+			     "s626_ai_cmd: cannot run command without an irq");
+		return -EIO;
+	}
 
-			/* clear interrupt capture flag */
-			k->ResetCapFlags(dev, k);
+	s626_ai_load_polllist(ppl, cmd);
+	devpriv->ai_cmd_running = 1;
+	devpriv->ai_convert_count = 0;
 
-			if (cmd->scan_begin_src == TRIG_TIMER) {
-				DEBUG
-				    ("s626_irq_handler: scan timer trigger!!!\n");
+	switch (cmd->scan_begin_src) {
+	case TRIG_FOLLOW:
+		break;
+	case TRIG_TIMER:
+		/*  set a conter to generate adc trigger at scan_begin_arg interval */
+		k = &encpriv[5];
+		tick = s626_ns_to_timer((int *)&cmd->scan_begin_arg,
+					cmd->flags & TRIG_ROUND_MASK);
 
-				/*  Trigger ADC scan loop start by setting RPS Signal 0. */
-				MC_ENABLE(P_MC2, MC2_ADC_RPS);
-			}
+		/* load timer value and enable interrupt */
+		s626_timer_load(dev, k, tick);
+		k->SetEnable(dev, k, CLKENAB_ALWAYS);
 
-			if (cmd->convert_src == TRIG_TIMER) {
-				DEBUG
-				    ("s626_irq_handler: convert timer trigger is set\n");
-				k = &encpriv[4];
-				devpriv->ai_convert_count = cmd->chanlist_len;
-				k->SetEnable(dev, k, CLKENAB_ALWAYS);
-			}
-		}
-	}
+		DEBUG("s626_ai_cmd: scan trigger timer is set with value %d\n",
+		      tick);
 
-	/* enable interrupt */
-	writel(irqstatus, devpriv->base_addr + P_IER);
+		break;
+	case TRIG_EXT:
+		/*  set the digital line and interrupt for scan trigger */
+		if (cmd->start_src != TRIG_EXT)
+			s626_dio_set_irq(dev, cmd->scan_begin_arg);
 
-	DEBUG("s626_irq_handler: exit interrupt service routine.\n");
+		DEBUG("s626_ai_cmd: External scan trigger is set!!!\n");
 
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-	return IRQ_HANDLED;
-}
+		break;
+	}
 
-static void s626_detach(struct comedi_device *dev)
-{
-	if (devpriv) {
-		/* stop ai_command */
-		devpriv->ai_cmd_running = 0;
+	switch (cmd->convert_src) {
+	case TRIG_NOW:
+		break;
+	case TRIG_TIMER:
+		/*  set a conter to generate adc trigger at convert_arg interval */
+		k = &encpriv[4];
+		tick = s626_ns_to_timer((int *)&cmd->convert_arg,
+					cmd->flags & TRIG_ROUND_MASK);
 
-		if (devpriv->base_addr) {
-			/* interrupt mask */
-			WR7146(P_IER, 0);	/*  Disable master interrupt. */
-			WR7146(P_ISR, IRQ_GPIO3 | IRQ_RPS1);	/*  Clear board's IRQ status flag. */
+		/* load timer value and enable interrupt */
+		s626_timer_load(dev, k, tick);
+		k->SetEnable(dev, k, CLKENAB_INDEX);
 
-			/*  Disable the watchdog timer and battery charger. */
-			WriteMISC2(dev, 0);
+		DEBUG
+		    ("s626_ai_cmd: convert trigger timer is set with value %d\n",
+		     tick);
+		break;
+	case TRIG_EXT:
+		/*  set the digital line and interrupt for convert trigger */
+		if (cmd->scan_begin_src != TRIG_EXT
+		    && cmd->start_src == TRIG_EXT)
+			s626_dio_set_irq(dev, cmd->convert_arg);
 
-			/*  Close all interfaces on 7146 device. */
-			WR7146(P_MC1, MC1_SHUTDOWN);
-			WR7146(P_ACON1, ACON1_BASE);
+		DEBUG("s626_ai_cmd: External convert trigger is set!!!\n");
 
-			CloseDMAB(dev, &devpriv->RPSBuf, DMABUF_SIZE);
-			CloseDMAB(dev, &devpriv->ANABuf, DMABUF_SIZE);
-		}
+		break;
+	}
 
-		if (dev->irq)
-			free_irq(dev->irq, dev);
-		if (devpriv->base_addr)
-			iounmap(devpriv->base_addr);
-		if (devpriv->pdev) {
-			if (devpriv->got_regions)
-				comedi_pci_disable(devpriv->pdev);
-			pci_dev_put(devpriv->pdev);
-		}
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		/*  data arrives as one packet */
+		devpriv->ai_sample_count = cmd->stop_arg;
+		devpriv->ai_continous = 0;
+		break;
+	case TRIG_NONE:
+		/*  continous acquisition */
+		devpriv->ai_continous = 1;
+		devpriv->ai_sample_count = 0;
+		break;
 	}
-}
 
-/*
- * this functions build the RPS program for hardware driven acquistion
- */
-static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
-{
-	register uint32_t *pRPS;
-	uint32_t JmpAdrs;
-	uint16_t i;
-	uint16_t n;
-	uint32_t LocalPPL;
-	struct comedi_cmd *cmd = &(dev->subdevices->async->cmd);
+	ResetADC(dev, ppl);
 
-	/*  Stop RPS program in case it is currently running. */
-	MC_DISABLE(P_MC1, MC1_ERPS1);
+	switch (cmd->start_src) {
+	case TRIG_NOW:
+		/*  Trigger ADC scan loop start by setting RPS Signal 0. */
+		/*  MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
 
-	/*  Set starting logical address to write RPS commands. */
-	pRPS = (uint32_t *) devpriv->RPSBuf.LogicalBase;
+		/*  Start executing the RPS program. */
+		MC_ENABLE(P_MC1, MC1_ERPS1);
 
-	/*  Initialize RPS instruction pointer. */
-	WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
+		DEBUG("s626_ai_cmd: ADC triggered\n");
+		s->async->inttrig = NULL;
+		break;
+	case TRIG_EXT:
+		/* configure DIO channel for acquisition trigger */
+		s626_dio_set_irq(dev, cmd->start_arg);
 
-	/*  Construct RPS program in RPSBuf DMA buffer */
+		DEBUG("s626_ai_cmd: External start trigger is set!!!\n");
 
-	if (cmd != NULL && cmd->scan_begin_src != TRIG_FOLLOW) {
-		DEBUG("ResetADC: scan_begin pause inserted\n");
-		/*  Wait for Start trigger. */
-		*pRPS++ = RPS_PAUSE | RPS_SIGADC;
-		*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
+		s->async->inttrig = NULL;
+		break;
+	case TRIG_INT:
+		s->async->inttrig = s626_ai_inttrig;
+		break;
 	}
 
-	/* SAA7146 BUG WORKAROUND Do a dummy DEBI Write.  This is necessary
-	 * because the first RPS DEBI Write following a non-RPS DEBI write
-	 * seems to always fail.  If we don't do this dummy write, the ADC
-	 * gain might not be set to the value required for the first slot in
-	 * the poll list; the ADC gain would instead remain unchanged from
-	 * the previously programmed value.
-	 */
-	*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
-	/* Write DEBI Write command and address to shadow RAM. */
+	/* enable interrupt */
+	writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->base_addr + P_IER);
 
-	*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
-	*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
-	/*  Write DEBI immediate data  to shadow RAM: */
+	DEBUG("s626_ai_cmd: command function terminated\n");
 
-	*pRPS++ = GSEL_BIPOLAR5V;
-	/*  arbitrary immediate data  value. */
+	return 0;
+}
 
-	*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
-	/*  Reset "shadow RAM  uploaded" flag. */
-	*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/*  Invoke shadow RAM upload. */
-	*pRPS++ = RPS_PAUSE | RPS_DEBI;	/*  Wait for shadow upload to finish. */
+static int s626_ai_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
+{
+	int err = 0;
+	int tmp;
 
-	/* Digitize all slots in the poll list. This is implemented as a
-	 * for loop to limit the slot count to 16 in case the application
-	 * forgot to set the EOPL flag in the final slot.
-	 */
-	for (devpriv->AdcItems = 0; devpriv->AdcItems < 16; devpriv->AdcItems++) {
-		/* Convert application's poll list item to private board class
-		 * format.  Each app poll list item is an uint8_t with form
-		 * (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
-		 * +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
-		 */
-		LocalPPL =
-		    (*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
-				   GSEL_BIPOLAR10V);
+	/* cmdtest tests a particular command to see if it is valid.  Using
+	 * the cmdtest ioctl, a user can create a valid cmd and then have it
+	 * executes by the cmd ioctl.
+	 *
+	 * cmdtest returns 1,2,3,4 or 0, depending on which tests the
+	 * command passes. */
 
-		/*  Switch ADC analog gain. */
-		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	/*  Write DEBI command */
-		/*  and address to */
-		/*  shadow RAM. */
-		*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
-		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	/*  Write DEBI */
-		/*  immediate data to */
-		/*  shadow RAM. */
-		*pRPS++ = LocalPPL;
-		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	/*  Reset "shadow RAM uploaded" */
-		/*  flag. */
-		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/*  Invoke shadow RAM upload. */
-		*pRPS++ = RPS_PAUSE | RPS_DEBI;	/*  Wait for shadow upload to */
-		/*  finish. */
+	/* step 1: make sure trigger sources are trivially valid */
 
-		/*  Select ADC analog input channel. */
-		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
-		/*  Write DEBI command and address to  shadow RAM. */
-		*pRPS++ = DEBI_CMD_WRWORD | LP_ISEL;
-		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
-		/*  Write DEBI immediate data to shadow RAM. */
-		*pRPS++ = LocalPPL;
-		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
-		/*  Reset "shadow RAM uploaded"  flag. */
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_INT | TRIG_EXT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
 
-		*pRPS++ = RPS_UPLOAD | RPS_DEBI;
-		/*  Invoke shadow RAM upload. */
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
 
-		*pRPS++ = RPS_PAUSE | RPS_DEBI;
-		/*  Wait for shadow upload to finish. */
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_TIMER | TRIG_EXT | TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
 
-		/* Delay at least 10 microseconds for analog input settling.
-		 * Instead of padding with NOPs, we use RPS_JUMP instructions
-		 * here; this allows us to produce a longer delay than is
-		 * possible with NOPs because each RPS_JUMP flushes the RPS'
-		 * instruction prefetch pipeline.
-		 */
-		JmpAdrs =
-		    (uint32_t) devpriv->RPSBuf.PhysicalBase +
-		    (uint32_t) ((unsigned long)pRPS -
-				(unsigned long)devpriv->RPSBuf.LogicalBase);
-		for (i = 0; i < (10 * RPSCLK_PER_US / 2); i++) {
-			JmpAdrs += 8;	/*  Repeat to implement time delay: */
-			*pRPS++ = RPS_JUMP;	/*  Jump to next RPS instruction. */
-			*pRPS++ = JmpAdrs;
-		}
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
 
-		if (cmd != NULL && cmd->convert_src != TRIG_NOW) {
-			DEBUG("ResetADC: convert pause inserted\n");
-			/*  Wait for Start trigger. */
-			*pRPS++ = RPS_PAUSE | RPS_SIGADC;
-			*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
-		}
-		/*  Start ADC by pulsing GPIO1. */
-		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  Begin ADC Start pulse. */
-		*pRPS++ = GPIO_BASE | GPIO1_LO;
-		*pRPS++ = RPS_NOP;
-		/*  VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
-		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  End ADC Start pulse. */
-		*pRPS++ = GPIO_BASE | GPIO1_HI;
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
 
-		/* Wait for ADC to complete (GPIO2 is asserted high when ADC not
-		 * busy) and for data from previous conversion to shift into FB
-		 * BUFFER 1 register.
-		 */
-		*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/*  Wait for ADC done. */
+	if (err)
+		return 1;
 
-		/*  Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
-		*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
-		*pRPS++ =
-		    (uint32_t) devpriv->ANABuf.PhysicalBase +
-		    (devpriv->AdcItems << 2);
+	/* step 2: make sure trigger sources are unique and mutually
+	   compatible */
 
-		/*  If this slot's EndOfPollList flag is set, all channels have */
-		/*  now been processed. */
-		if (*ppl++ & EOPL) {
-			devpriv->AdcItems++;	/*  Adjust poll list item count. */
-			break;	/*  Exit poll list processing loop. */
-		}
+	/* note that mutual compatibility is not an issue here */
+	if (cmd->scan_begin_src != TRIG_TIMER &&
+	    cmd->scan_begin_src != TRIG_EXT
+	    && cmd->scan_begin_src != TRIG_FOLLOW)
+		err++;
+	if (cmd->convert_src != TRIG_TIMER &&
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_src != TRIG_EXT && cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
 	}
-	DEBUG("ResetADC: ADC items %d\n", devpriv->AdcItems);
 
-	/* VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
-	 * ADC to stabilize for 2 microseconds before starting the final
-	 * (dummy) conversion.  This delay is necessary to allow sufficient
-	 * time between last conversion finished and the start of the dummy
-	 * conversion.  Without this delay, the last conversion's data value
-	 * is sometimes set to the previous conversion's data value.
-	 */
-	for (n = 0; n < (2 * RPSCLK_PER_US); n++)
-		*pRPS++ = RPS_NOP;
+	if (cmd->start_src == TRIG_EXT && cmd->start_arg > 39) {
+		cmd->start_arg = 39;
+		err++;
+	}
 
-	/* Start a dummy conversion to cause the data from the last
-	 * conversion of interest to be shifted in.
-	 */
-	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  Begin ADC Start pulse. */
-	*pRPS++ = GPIO_BASE | GPIO1_LO;
-	*pRPS++ = RPS_NOP;
-	/* VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
-	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  End ADC Start pulse. */
-	*pRPS++ = GPIO_BASE | GPIO1_HI;
+	if (cmd->scan_begin_src == TRIG_EXT && cmd->scan_begin_arg > 39) {
+		cmd->scan_begin_arg = 39;
+		err++;
+	}
 
-	/* Wait for the data from the last conversion of interest to arrive
-	 * in FB BUFFER 1 register.
-	 */
-	*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/*  Wait for ADC done. */
+	if (cmd->convert_src == TRIG_EXT && cmd->convert_arg > 39) {
+		cmd->convert_arg = 39;
+		err++;
+	}
+#define MAX_SPEED	200000	/* in nanoseconds */
+#define MIN_SPEED	2000000000	/* in nanoseconds */
 
-	/*  Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
-	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);	/*  */
-	*pRPS++ =
-	    (uint32_t) devpriv->ANABuf.PhysicalBase + (devpriv->AdcItems << 2);
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		if (cmd->scan_begin_arg < MAX_SPEED) {
+			cmd->scan_begin_arg = MAX_SPEED;
+			err++;
+		}
+		if (cmd->scan_begin_arg > MIN_SPEED) {
+			cmd->scan_begin_arg = MIN_SPEED;
+			err++;
+		}
+	} else {
+		/* external trigger */
+		/* should be level/edge, hi/lo specification here */
+		/* should specify multiple external triggers */
+/*     if(cmd->scan_begin_arg>9){ */
+/*       cmd->scan_begin_arg=9; */
+/*       err++; */
+/*     } */
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg < MAX_SPEED) {
+			cmd->convert_arg = MAX_SPEED;
+			err++;
+		}
+		if (cmd->convert_arg > MIN_SPEED) {
+			cmd->convert_arg = MIN_SPEED;
+			err++;
+		}
+	} else {
+		/* external trigger */
+		/* see above */
+/*     if(cmd->convert_arg>9){ */
+/*       cmd->convert_arg=9; */
+/*       err++; */
+/*     } */
+	}
 
-	/*  Indicate ADC scan loop is finished. */
-	/*  *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC ;  // Signal ReadADC() that scan is done. */
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_COUNT) {
+		if (cmd->stop_arg > 0x00ffffff) {
+			cmd->stop_arg = 0x00ffffff;
+			err++;
+		}
+	} else {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
 
-	/* invoke interrupt */
-	if (devpriv->ai_cmd_running == 1) {
-		DEBUG("ResetADC: insert irq in ADC RPS task\n");
-		*pRPS++ = RPS_IRQ;
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		tmp = cmd->scan_begin_arg;
+		s626_ns_to_timer((int *)&cmd->scan_begin_arg,
+				 cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->scan_begin_arg)
+			err++;
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		tmp = cmd->convert_arg;
+		s626_ns_to_timer((int *)&cmd->convert_arg,
+				 cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->convert_arg)
+			err++;
+		if (cmd->scan_begin_src == TRIG_TIMER &&
+		    cmd->scan_begin_arg <
+		    cmd->convert_arg * cmd->scan_end_arg) {
+			cmd->scan_begin_arg =
+			    cmd->convert_arg * cmd->scan_end_arg;
+			err++;
+		}
 	}
-	/*  Restart RPS program at its beginning. */
-	*pRPS++ = RPS_JUMP;	/*  Branch to start of RPS program. */
-	*pRPS++ = (uint32_t) devpriv->RPSBuf.PhysicalBase;
 
-	/*  End of RPS program build */
+	if (err)
+		return 4;
+
+	return 0;
 }
 
-/* TO COMPLETE, IF NECESSARY */
-static int s626_ai_insn_config(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
+static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	/*  Stop RPS program in case it is currently running. */
+	MC_DISABLE(P_MC1, MC1_ERPS1);
 
-	return -EINVAL;
-}
-
-/* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data) */
-/* { */
-/*   register uint8_t	i; */
-/*   register int32_t	*readaddr; */
+	/* disable master interrupt */
+	writel(0, devpriv->base_addr + P_IER);
 
-/*   DEBUG("as626_ai_rinsn: ai_rinsn enter\n");  */
+	devpriv->ai_cmd_running = 0;
 
-/*   Trigger ADC scan loop start by setting RPS Signal 0. */
-/*   MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
+	return 0;
+}
 
-/*   Wait until ADC scan loop is finished (RPS Signal 0 reset). */
-/*   while ( MC_TEST( P_MC2, MC2_ADC_RPS ) ); */
+/* This function doesn't require a particular form, this is just what
+ * happens to be used in some of the drivers.  It should convert ns
+ * nanoseconds to a counter value suitable for programming the device.
+ * Also, it should adjust ns so that it cooresponds to the actual time
+ * that the device will use. */
+static int s626_ns_to_timer(int *nanosec, int round_mode)
+{
+	int divider, base;
 
-/* Init ptr to DMA buffer that holds new ADC data.  We skip the
- * first uint16_t in the buffer because it contains junk data from
- * the final ADC of the previous poll list scan.
- */
-/*   readaddr = (uint32_t *)devpriv->ANABuf.LogicalBase + 1; */
+	base = 500;		/* 2MHz internal clock */
 
-/*  Convert ADC data to 16-bit integer values and copy to application buffer. */
-/*   for ( i = 0; i < devpriv->AdcItems; i++ ) { */
-/*     *data = s626_ai_reg_to_uint( *readaddr++ ); */
-/*     DEBUG("s626_ai_rinsn: data %d\n",*data); */
-/*     data++; */
-/*   } */
+	switch (round_mode) {
+	case TRIG_ROUND_NEAREST:
+	default:
+		divider = (*nanosec + base / 2) / base;
+		break;
+	case TRIG_ROUND_DOWN:
+		divider = (*nanosec) / base;
+		break;
+	case TRIG_ROUND_UP:
+		divider = (*nanosec + base - 1) / base;
+		break;
+	}
 
-/*   DEBUG("s626_ai_rinsn: ai_rinsn escape\n"); */
-/*   return i; */
-/* } */
+	*nanosec = base * divider;
+	return divider - 1;
+}
 
-static int s626_ai_insn_read(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
+static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+			 struct comedi_insn *insn, unsigned int *data)
 {
+
+	int i;
 	uint16_t chan = CR_CHAN(insn->chanspec);
-	uint16_t range = CR_RANGE(insn->chanspec);
-	uint16_t AdcSpec = 0;
-	uint32_t GpioImage;
-	int n;
+	int16_t dacdata;
 
-	/* interrupt call test  */
-/*   writel(IRQ_GPIO3,devpriv->base_addr+P_PSR); */
-	/* Writing a logical 1 into any of the RPS_PSR bits causes the
-	 * corresponding interrupt to be generated if enabled
-	 */
-
-	DEBUG("s626_ai_insn_read: entering\n");
-
-	/* Convert application's ADC specification into form
-	 *  appropriate for register programming.
-	 */
-	if (range == 0)
-		AdcSpec = (chan << 8) | (GSEL_BIPOLAR5V);
-	else
-		AdcSpec = (chan << 8) | (GSEL_BIPOLAR10V);
+	for (i = 0; i < insn->n; i++) {
+		dacdata = (int16_t) data[i];
+		devpriv->ao_readback[CR_CHAN(insn->chanspec)] = data[i];
+		dacdata -= (0x1fff);
 
-	/*  Switch ADC analog gain. */
-	DEBIwrite(dev, LP_GSEL, AdcSpec);	/*  Set gain. */
+		SetDAC(dev, chan, dacdata);
+	}
 
-	/*  Select ADC analog input channel. */
-	DEBIwrite(dev, LP_ISEL, AdcSpec);	/*  Select channel. */
+	return i;
+}
 
-	for (n = 0; n < insn->n; n++) {
+static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+			 struct comedi_insn *insn, unsigned int *data)
+{
+	int i;
 
-		/*  Delay 10 microseconds for analog input settling. */
-		udelay(10);
+	for (i = 0; i < insn->n; i++)
+		data[i] = devpriv->ao_readback[CR_CHAN(insn->chanspec)];
 
-		/*  Start ADC by pulsing GPIO1 low. */
-		GpioImage = RR7146(P_GPIO);
-		/*  Assert ADC Start command */
-		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-		/*    and stretch it out. */
-		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-		/*  Negate ADC Start command. */
-		WR7146(P_GPIO, GpioImage | GPIO1_HI);
+	return i;
+}
 
-		/*  Wait for ADC to complete (GPIO2 is asserted high when */
-		/*  ADC not busy) and for data from previous conversion to */
-		/*  shift into FB BUFFER 1 register. */
+/* *************** DIGITAL I/O FUNCTIONS ***************
+ * All DIO functions address a group of DIO channels by means of
+ * "group" argument.  group may be 0, 1 or 2, which correspond to DIO
+ * ports A, B and C, respectively.
+ */
 
-		/*  Wait for ADC done. */
-		while (!(RR7146(P_PSR) & PSR_GPIO2))
-			;
+static void s626_dio_init(struct comedi_device *dev)
+{
+	uint16_t group;
+	struct comedi_subdevice *s;
 
-		/*  Fetch ADC data. */
-		if (n != 0)
-			data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
+	/*  Prepare to treat writes to WRCapSel as capture disables. */
+	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
-		/* Allow the ADC to stabilize for 4 microseconds before
-		 * starting the next (final) conversion.  This delay is
-		 * necessary to allow sufficient time between last
-		 * conversion finished and the start of the next
-		 * conversion.  Without this delay, the last conversion's
-		 * data value is sometimes set to the previous
-		 * conversion's data value.
-		 */
-		udelay(4);
+	/*  For each group of sixteen channels ... */
+	for (group = 0; group < S626_DIO_BANKS; group++) {
+		s = dev->subdevices + 2 + group;
+		DEBIwrite(dev, diopriv->WRIntSel, 0);	/*  Disable all interrupts. */
+		DEBIwrite(dev, diopriv->WRCapSel, 0xFFFF);	/*  Disable all event */
+		/*  captures. */
+		DEBIwrite(dev, diopriv->WREdgSel, 0);	/*  Init all DIOs to */
+		/*  default edge */
+		/*  polarity. */
+		DEBIwrite(dev, diopriv->WRDOut, 0);	/*  Program all outputs */
+		/*  to inactive state. */
 	}
+	DEBUG("s626_dio_init: DIO initialized\n");
+}
 
-	/* Start a dummy conversion to cause the data from the
-	 * previous conversion to be shifted in. */
-	GpioImage = RR7146(P_GPIO);
-
-	/* Assert ADC Start command */
-	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-	/*    and stretch it out. */
-	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-	/*  Negate ADC Start command. */
-	WR7146(P_GPIO, GpioImage | GPIO1_HI);
-
-	/*  Wait for the data to arrive in FB BUFFER 1 register. */
+/* DIO devices are slightly special.  Although it is possible to
+ * implement the insn_read/insn_write interface, it is much more
+ * useful to applications if you implement the insn_bits interface.
+ * This allows packed reading/writing of the DIO channels.  The comedi
+ * core can convert between insn_bits and insn_read/write */
 
-	/*  Wait for ADC done. */
-	while (!(RR7146(P_PSR) & PSR_GPIO2))
-		;
+static int s626_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
+{
+	/*
+	 * The insn data consists of a mask in data[0] and the new data in
+	 * data[1]. The mask defines which bits we are concerning about.
+	 * The new data must be anded with the mask.  Each channel
+	 * corresponds to a bit.
+	 */
+	if (data[0]) {
+		/* Check if requested ports are configured for output */
+		if ((s->io_bits & data[0]) != data[0])
+			return -EIO;
 
-	/*  Fetch ADC data from audio interface's input shift register. */
+		s->state &= ~data[0];
+		s->state |= data[0] & data[1];
 
-	/*  Fetch ADC data. */
-	if (n != 0)
-		data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
+		/* Write out the new digital output lines */
 
-	DEBUG("s626_ai_insn_read: samples %d, data %d\n", n, data[n - 1]);
+		DEBIwrite(dev, diopriv->WRDOut, s->state);
+	}
+	data[1] = DEBIread(dev, diopriv->RDDIn);
 
-	return n;
+	return insn->n;
 }
 
-static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)
+static int s626_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 
-	int n;
-
-	for (n = 0; n < cmd->chanlist_len; n++) {
-		if (CR_RANGE((cmd->chanlist)[n]) == 0)
-			ppl[n] = (CR_CHAN((cmd->chanlist)[n])) | (RANGE_5V);
-		else
-			ppl[n] = (CR_CHAN((cmd->chanlist)[n])) | (RANGE_10V);
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] =
+		    (s->
+		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
+		    COMEDI_INPUT;
+		return insn->n;
+		break;
+	case COMEDI_INPUT:
+		s->io_bits &= ~(1 << CR_CHAN(insn->chanspec));
+		break;
+	case COMEDI_OUTPUT:
+		s->io_bits |= 1 << CR_CHAN(insn->chanspec);
+		break;
+	default:
+		return -EINVAL;
+		break;
 	}
-	if (n != 0)
-		ppl[n - 1] |= EOPL;
+	DEBIwrite(dev, diopriv->WRDOut, s->io_bits);
 
-	return n;
+	return 1;
 }
 
-static int s626_ai_inttrig(struct comedi_device *dev,
-			   struct comedi_subdevice *s, unsigned int trignum)
+static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
 {
-	if (trignum != 0)
-		return -EINVAL;
+	unsigned int group;
+	unsigned int bitmask;
+	unsigned int status;
 
-	DEBUG("s626_ai_inttrig: trigger adc start...");
+	/* select dio bank */
+	group = chan / 16;
+	bitmask = 1 << (chan - (16 * group));
+	DEBUG("s626_dio_set_irq: enable interrupt on dio channel %d group %d\n",
+	      chan - (16 * group), group);
 
-	/*  Start executing the RPS program. */
-	MC_ENABLE(P_MC1, MC1_ERPS1);
+	/* set channel to capture positive edge */
+	status = DEBIread(dev,
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->RDEdgSel);
+	DEBIwrite(dev,
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WREdgSel,
+		  bitmask | status);
 
-	s->async->inttrig = NULL;
+	/* enable interrupt on selected channel */
+	status = DEBIread(dev,
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->RDIntSel);
+	DEBIwrite(dev,
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WRIntSel,
+		  bitmask | status);
 
-	DEBUG(" done\n");
+	/* enable edge capture write command */
+	DEBIwrite(dev, LP_MISC1, MISC1_EDCAP);
 
-	return 1;
+	/* enable edge capture on selected channel */
+	status = DEBIread(dev,
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->RDCapSel);
+	DEBIwrite(dev,
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WRCapSel,
+		  bitmask | status);
+
+	return 0;
 }
 
-/*  TO COMPLETE  */
-static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,
+			      unsigned int mask)
 {
+	DEBUG
+	    ("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n",
+	     mask, group);
 
-	uint8_t ppl[16];
-	struct comedi_cmd *cmd = &s->async->cmd;
-	struct enc_private *k;
-	int tick;
+	/* disable edge capture write command */
+	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
-	DEBUG("s626_ai_cmd: entering command function\n");
+	/* enable edge capture on selected channel */
+	DEBIwrite(dev,
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WRCapSel, mask);
 
-	if (devpriv->ai_cmd_running) {
-		printk(KERN_ERR "s626_ai_cmd: Another ai_cmd is running %d\n",
-		       dev->minor);
-		return -EBUSY;
-	}
-	/* disable interrupt */
-	writel(0, devpriv->base_addr + P_IER);
+	return 0;
+}
 
-	/* clear interrupt request */
-	writel(IRQ_RPS1 | IRQ_GPIO3, devpriv->base_addr + P_ISR);
+static int s626_dio_clear_irq(struct comedi_device *dev)
+{
+	unsigned int group;
 
-	/* clear any pending interrupt */
-	s626_dio_clear_irq(dev);
-	/*   s626_enc_clear_irq(dev); */
+	/* disable edge capture write command */
+	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
-	/* reset ai_cmd_running flag */
-	devpriv->ai_cmd_running = 0;
-
-	/*  test if cmd is valid */
-	if (cmd == NULL) {
-		DEBUG("s626_ai_cmd: NULL command\n");
-		return -EINVAL;
-	} else {
-		DEBUG("s626_ai_cmd: command received!!!\n");
-	}
-
-	if (dev->irq == 0) {
-		comedi_error(dev,
-			     "s626_ai_cmd: cannot run command without an irq");
-		return -EIO;
+	for (group = 0; group < S626_DIO_BANKS; group++) {
+		/* clear pending events and interrupt */
+		DEBIwrite(dev,
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->WRCapSel,
+			  0xffff);
 	}
 
-	s626_ai_load_polllist(ppl, cmd);
-	devpriv->ai_cmd_running = 1;
-	devpriv->ai_convert_count = 0;
-
-	switch (cmd->scan_begin_src) {
-	case TRIG_FOLLOW:
-		break;
-	case TRIG_TIMER:
-		/*  set a conter to generate adc trigger at scan_begin_arg interval */
-		k = &encpriv[5];
-		tick = s626_ns_to_timer((int *)&cmd->scan_begin_arg,
-					cmd->flags & TRIG_ROUND_MASK);
-
-		/* load timer value and enable interrupt */
-		s626_timer_load(dev, k, tick);
-		k->SetEnable(dev, k, CLKENAB_ALWAYS);
-
-		DEBUG("s626_ai_cmd: scan trigger timer is set with value %d\n",
-		      tick);
+	return 0;
+}
 
-		break;
-	case TRIG_EXT:
-		/*  set the digital line and interrupt for scan trigger */
-		if (cmd->start_src != TRIG_EXT)
-			s626_dio_set_irq(dev, cmd->scan_begin_arg);
+/* Now this function initializes the value of the counter (data[0])
+   and set the subdevice. To complete with trigger and interrupt
+   configuration */
+static int s626_enc_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
+{
+	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
+	    /*  index. */
+	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+	    (CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is Counter. */
+	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+	    /* ( CNTDIR_UP << BF_CLKPOL ) |      // Count direction is Down. */
+	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
+	    (CLKENAB_INDEX << BF_CLKENAB);
+	/*   uint16_t DisableIntSrc=TRUE; */
+	/*  uint32_t Preloadvalue;              //Counter initial value */
+	uint16_t valueSrclatch = LATCHSRC_AB_READ;
+	uint16_t enab = CLKENAB_ALWAYS;
+	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
-		DEBUG("s626_ai_cmd: External scan trigger is set!!!\n");
+	DEBUG("s626_enc_insn_config: encoder config\n");
 
-		break;
-	}
+	/*   (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
-	switch (cmd->convert_src) {
-	case TRIG_NOW:
-		break;
-	case TRIG_TIMER:
-		/*  set a conter to generate adc trigger at convert_arg interval */
-		k = &encpriv[4];
-		tick = s626_ns_to_timer((int *)&cmd->convert_arg,
-					cmd->flags & TRIG_ROUND_MASK);
+	k->SetMode(dev, k, Setup, TRUE);
+	Preload(dev, k, *(insn->data));
+	k->PulseIndex(dev, k);
+	SetLatchSource(dev, k, valueSrclatch);
+	k->SetEnable(dev, k, (uint16_t) (enab != 0));
 
-		/* load timer value and enable interrupt */
-		s626_timer_load(dev, k, tick);
-		k->SetEnable(dev, k, CLKENAB_INDEX);
+	return insn->n;
+}
 
-		DEBUG
-		    ("s626_ai_cmd: convert trigger timer is set with value %d\n",
-		     tick);
-		break;
-	case TRIG_EXT:
-		/*  set the digital line and interrupt for convert trigger */
-		if (cmd->scan_begin_src != TRIG_EXT
-		    && cmd->start_src == TRIG_EXT)
-			s626_dio_set_irq(dev, cmd->convert_arg);
+static int s626_enc_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
+{
 
-		DEBUG("s626_ai_cmd: External convert trigger is set!!!\n");
+	int n;
+	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
-		break;
-	}
+	DEBUG("s626_enc_insn_read: encoder read channel %d\n",
+	      CR_CHAN(insn->chanspec));
 
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
-		/*  data arrives as one packet */
-		devpriv->ai_sample_count = cmd->stop_arg;
-		devpriv->ai_continous = 0;
-		break;
-	case TRIG_NONE:
-		/*  continous acquisition */
-		devpriv->ai_continous = 1;
-		devpriv->ai_sample_count = 0;
-		break;
-	}
+	for (n = 0; n < insn->n; n++)
+		data[n] = ReadLatch(dev, k);
 
-	ResetADC(dev, ppl);
+	DEBUG("s626_enc_insn_read: encoder sample %d\n", data[n]);
 
-	switch (cmd->start_src) {
-	case TRIG_NOW:
-		/*  Trigger ADC scan loop start by setting RPS Signal 0. */
-		/*  MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
+	return n;
+}
 
-		/*  Start executing the RPS program. */
-		MC_ENABLE(P_MC1, MC1_ERPS1);
+static int s626_enc_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
+{
 
-		DEBUG("s626_ai_cmd: ADC triggered\n");
-		s->async->inttrig = NULL;
-		break;
-	case TRIG_EXT:
-		/* configure DIO channel for acquisition trigger */
-		s626_dio_set_irq(dev, cmd->start_arg);
+	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
-		DEBUG("s626_ai_cmd: External start trigger is set!!!\n");
+	DEBUG("s626_enc_insn_write: encoder write channel %d\n",
+	      CR_CHAN(insn->chanspec));
 
-		s->async->inttrig = NULL;
-		break;
-	case TRIG_INT:
-		s->async->inttrig = s626_ai_inttrig;
-		break;
-	}
+	/*  Set the preload register */
+	Preload(dev, k, data[0]);
 
-	/* enable interrupt */
-	writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->base_addr + P_IER);
+	/*  Software index pulse forces the preload register to load */
+	/*  into the counter */
+	k->SetLoadTrig(dev, k, 0);
+	k->PulseIndex(dev, k);
+	k->SetLoadTrig(dev, k, 2);
 
-	DEBUG("s626_ai_cmd: command function terminated\n");
+	DEBUG("s626_enc_insn_write: End encoder write\n");
 
-	return 0;
+	return 1;
 }
 
-static int s626_ai_cmdtest(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
+static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
+			    int tick)
 {
-	int err = 0;
-	int tmp;
+	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
+	    /*  index. */
+	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+	    (CLKSRC_TIMER << BF_CLKSRC) |	/*  Operating mode is Timer. */
+	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+	    (CNTDIR_DOWN << BF_CLKPOL) |	/*  Count direction is Down. */
+	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
+	    (CLKENAB_INDEX << BF_CLKENAB);
+	uint16_t valueSrclatch = LATCHSRC_A_INDXA;
+	/*   uint16_t enab=CLKENAB_ALWAYS; */
 
-	/* cmdtest tests a particular command to see if it is valid.  Using
-	 * the cmdtest ioctl, a user can create a valid cmd and then have it
-	 * executes by the cmd ioctl.
-	 *
-	 * cmdtest returns 1,2,3,4 or 0, depending on which tests the
-	 * command passes. */
+	k->SetMode(dev, k, Setup, FALSE);
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/*  Set the preload register */
+	Preload(dev, k, tick);
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_INT | TRIG_EXT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
+	/*  Software index pulse forces the preload register to load */
+	/*  into the counter */
+	k->SetLoadTrig(dev, k, 0);
+	k->PulseIndex(dev, k);
 
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
+	/* set reload on counter overflow */
+	k->SetLoadTrig(dev, k, 1);
 
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_TIMER | TRIG_EXT | TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
+	/* set interrupt on overflow */
+	k->SetIntSrc(dev, k, INTSRC_OVER);
 
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
+	SetLatchSource(dev, k, valueSrclatch);
+	/*   k->SetEnable(dev,k,(uint16_t)(enab != 0)); */
+}
 
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+/* ***********  DAC FUNCTIONS *********** */
 
-	if (err)
-		return 1;
+/*  Slot 0 base settings. */
+#define VECT0	(XSD2 | RSD3 | SIB_A2)
+/*  Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
 
-	/* step 2: make sure trigger sources are unique and mutually
-	   compatible */
+/*  TrimDac LogicalChan-to-PhysicalChan mapping table. */
+static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 
-	/* note that mutual compatibility is not an issue here */
-	if (cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_EXT
-	    && cmd->scan_begin_src != TRIG_FOLLOW)
-		err++;
-	if (cmd->convert_src != TRIG_TIMER &&
-	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+/*  TrimDac LogicalChan-to-EepromAdrs mapping table. */
+static uint8_t trimadrs[] = { 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
 
-	if (err)
-		return 2;
+static void LoadTrimDACs(struct comedi_device *dev)
+{
+	register uint8_t i;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/*  Copy TrimDac setpoint values from EEPROM to TrimDacs. */
+	for (i = 0; i < ARRAY_SIZE(trimchan); i++)
+		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
+}
 
-	if (cmd->start_src != TRIG_EXT && cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
-
-	if (cmd->start_src == TRIG_EXT && cmd->start_arg > 39) {
-		cmd->start_arg = 39;
-		err++;
-	}
-
-	if (cmd->scan_begin_src == TRIG_EXT && cmd->scan_begin_arg > 39) {
-		cmd->scan_begin_arg = 39;
-		err++;
-	}
-
-	if (cmd->convert_src == TRIG_EXT && cmd->convert_arg > 39) {
-		cmd->convert_arg = 39;
-		err++;
-	}
-#define MAX_SPEED	200000	/* in nanoseconds */
-#define MIN_SPEED	2000000000	/* in nanoseconds */
-
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		if (cmd->scan_begin_arg < MAX_SPEED) {
-			cmd->scan_begin_arg = MAX_SPEED;
-			err++;
-		}
-		if (cmd->scan_begin_arg > MIN_SPEED) {
-			cmd->scan_begin_arg = MIN_SPEED;
-			err++;
-		}
-	} else {
-		/* external trigger */
-		/* should be level/edge, hi/lo specification here */
-		/* should specify multiple external triggers */
-/*     if(cmd->scan_begin_arg>9){ */
-/*       cmd->scan_begin_arg=9; */
-/*       err++; */
-/*     } */
-	}
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < MAX_SPEED) {
-			cmd->convert_arg = MAX_SPEED;
-			err++;
-		}
-		if (cmd->convert_arg > MIN_SPEED) {
-			cmd->convert_arg = MIN_SPEED;
-			err++;
-		}
-	} else {
-		/* external trigger */
-		/* see above */
-/*     if(cmd->convert_arg>9){ */
-/*       cmd->convert_arg=9; */
-/*       err++; */
-/*     } */
-	}
+static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
+			 uint8_t DacData)
+{
+	uint32_t chan;
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-	if (cmd->stop_src == TRIG_COUNT) {
-		if (cmd->stop_arg > 0x00ffffff) {
-			cmd->stop_arg = 0x00ffffff;
-			err++;
-		}
-	} else {
-		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
+	/*  Save the new setpoint in case the application needs to read it back later. */
+	devpriv->TrimSetpoint[LogicalChan] = (uint8_t) DacData;
 
-	if (err)
-		return 3;
+	/*  Map logical channel number to physical channel number. */
+	chan = (uint32_t) trimchan[LogicalChan];
 
-	/* step 4: fix up any arguments */
+	/* Set up TSL2 records for TrimDac write operation.  All slots shift
+	 * 0xFF in from pulled-up SD3 so that the end of the slot sequence
+	 * can be detected.
+	 */
 
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		tmp = cmd->scan_begin_arg;
-		s626_ns_to_timer((int *)&cmd->scan_begin_arg,
-				 cmd->flags & TRIG_ROUND_MASK);
-		if (tmp != cmd->scan_begin_arg)
-			err++;
-	}
-	if (cmd->convert_src == TRIG_TIMER) {
-		tmp = cmd->convert_arg;
-		s626_ns_to_timer((int *)&cmd->convert_arg,
-				 cmd->flags & TRIG_ROUND_MASK);
-		if (tmp != cmd->convert_arg)
-			err++;
-		if (cmd->scan_begin_src == TRIG_TIMER &&
-		    cmd->scan_begin_arg <
-		    cmd->convert_arg * cmd->scan_end_arg) {
-			cmd->scan_begin_arg =
-			    cmd->convert_arg * cmd->scan_end_arg;
-			err++;
-		}
-	}
+	SETVECT(2, XSD2 | XFIFO_1 | WS3);
+	/* Slot 2: Send high uint8_t to target TrimDac. */
+	SETVECT(3, XSD2 | XFIFO_0 | WS3);
+	/* Slot 3: Send low uint8_t to target TrimDac. */
+	SETVECT(4, XSD2 | XFIFO_3 | WS1);
+	/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running. */
+	SETVECT(5, XSD2 | XFIFO_2 | WS1 | EOS);
+	/* Slot 5: Send NOP low  uint8_t to DAC0. */
 
-	if (err)
-		return 4;
+	/* Construct and transmit target DAC's serial packet:
+	 * ( 0000 AAAA ), ( DDDD DDDD ),( 0x00 ),( 0x00 ) where A<3:0> is the
+	 * DAC channel's address, and D<7:0> is the DAC setpoint.  Append a
+	 * WORD value (that writes a channel 0 NOP command to a non-existent
+	 * main DAC channel) that serves to keep the clock running after the
+	 * packet has been sent to the target DAC.
+	 */
 
-	return 0;
+	/*  Address the DAC channel within the trimdac device. */
+	SendDAC(dev, ((uint32_t) chan << 8)
+		| (uint32_t) DacData);	/*  Include DAC setpoint data. */
 }
 
-static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	/*  Stop RPS program in case it is currently running. */
-	MC_DISABLE(P_MC1, MC1_ERPS1);
-
-	/* disable master interrupt */
-	writel(0, devpriv->base_addr + P_IER);
+/* **************  EEPROM ACCESS FUNCTIONS  ************** */
+/*  Read uint8_t from EEPROM. */
 
-	devpriv->ai_cmd_running = 0;
+static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
+{
+	uint8_t rtnval;
 
-	return 0;
-}
+	/*  Send EEPROM target address. */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)
+			 /* Byte2 = I2C command: write to I2C EEPROM  device. */
+			 | I2C_B1(I2C_ATTRSTOP, addr)
+			 /* Byte1 = EEPROM internal target address. */
+			 | I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not sent. */
+		/*  Abort function and declare error if handshake failed. */
+		DEBUG("I2Cread: error handshake I2Cread  a\n");
+		return 0;
+	}
+	/*  Execute EEPROM read. */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)
 
-/* This function doesn't require a particular form, this is just what
- * happens to be used in some of the drivers.  It should convert ns
- * nanoseconds to a counter value suitable for programming the device.
- * Also, it should adjust ns so that it cooresponds to the actual time
- * that the device will use. */
-static int s626_ns_to_timer(int *nanosec, int round_mode)
-{
-	int divider, base;
+			 /*  Byte2 = I2C */
+			 /*  command: read */
+			 /*  from I2C EEPROM */
+			 /*  device. */
+			 |I2C_B1(I2C_ATTRSTOP, 0)
 
-	base = 500;		/* 2MHz internal clock */
+			 /*  Byte1 receives */
+			 /*  uint8_t from */
+			 /*  EEPROM. */
+			 |I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not  sent. */
 
-	switch (round_mode) {
-	case TRIG_ROUND_NEAREST:
-	default:
-		divider = (*nanosec + base / 2) / base;
-		break;
-	case TRIG_ROUND_DOWN:
-		divider = (*nanosec) / base;
-		break;
-	case TRIG_ROUND_UP:
-		divider = (*nanosec + base - 1) / base;
-		break;
+		/*  Abort function and declare error if handshake failed. */
+		DEBUG("I2Cread: error handshake I2Cread b\n");
+		return 0;
 	}
-
-	*nanosec = base * divider;
-	return divider - 1;
+	/*  Return copy of EEPROM value. */
+	rtnval = (uint8_t) (RR7146(P_I2CCTRL) >> 16);
+	return rtnval;
 }
 
-static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_insn *insn, unsigned int *data)
+static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 {
+	/*  Write I2C command to I2C Transfer Control shadow register. */
+	WR7146(P_I2CCTRL, val);
 
-	int i;
-	uint16_t chan = CR_CHAN(insn->chanspec);
-	int16_t dacdata;
-
-	for (i = 0; i < insn->n; i++) {
-		dacdata = (int16_t) data[i];
-		devpriv->ao_readback[CR_CHAN(insn->chanspec)] = data[i];
-		dacdata -= (0x1fff);
-
-		SetDAC(dev, chan, dacdata);
-	}
+	/*  Upload I2C shadow registers into working registers and wait for */
+	/*  upload confirmation. */
 
-	return i;
-}
+	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
+	while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
+		;
 
-static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_insn *insn, unsigned int *data)
-{
-	int i;
+	/*  Wait until I2C bus transfer is finished or an error occurs. */
+	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY)
+		;
 
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->ao_readback[CR_CHAN(insn->chanspec)];
+	/*  Return non-zero if I2C error occurred. */
+	return RR7146(P_I2CCTRL) & I2C_ERR;
 
-	return i;
 }
 
-/* *************** DIGITAL I/O FUNCTIONS ***************
- * All DIO functions address a group of DIO channels by means of
- * "group" argument.  group may be 0, 1 or 2, which correspond to DIO
- * ports A, B and C, respectively.
- */
+/*  Private helper function: Write setpoint to an application DAC channel. */
 
-static void s626_dio_init(struct comedi_device *dev)
+static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
 {
-	uint16_t group;
-	struct comedi_subdevice *s;
+	register uint16_t signmask;
+	register uint32_t WSImage;
 
-	/*  Prepare to treat writes to WRCapSel as capture disables. */
-	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
+	/*  Adjust DAC data polarity and set up Polarity Control Register */
+	/*  image. */
+	signmask = 1 << chan;
+	if (dacdata < 0) {
+		dacdata = -dacdata;
+		devpriv->Dacpol |= signmask;
+	} else
+		devpriv->Dacpol &= ~signmask;
 
-	/*  For each group of sixteen channels ... */
-	for (group = 0; group < S626_DIO_BANKS; group++) {
-		s = dev->subdevices + 2 + group;
-		DEBIwrite(dev, diopriv->WRIntSel, 0);	/*  Disable all interrupts. */
-		DEBIwrite(dev, diopriv->WRCapSel, 0xFFFF);	/*  Disable all event */
-		/*  captures. */
-		DEBIwrite(dev, diopriv->WREdgSel, 0);	/*  Init all DIOs to */
-		/*  default edge */
-		/*  polarity. */
-		DEBIwrite(dev, diopriv->WRDOut, 0);	/*  Program all outputs */
-		/*  to inactive state. */
-	}
-	DEBUG("s626_dio_init: DIO initialized\n");
-}
-
-/* DIO devices are slightly special.  Although it is possible to
- * implement the insn_read/insn_write interface, it is much more
- * useful to applications if you implement the insn_bits interface.
- * This allows packed reading/writing of the DIO channels.  The comedi
- * core can convert between insn_bits and insn_read/write */
+	/*  Limit DAC setpoint value to valid range. */
+	if ((uint16_t) dacdata > 0x1FFF)
+		dacdata = 0x1FFF;
 
-static int s626_dio_insn_bits(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
-{
-	/*
-	 * The insn data consists of a mask in data[0] and the new data in
-	 * data[1]. The mask defines which bits we are concerning about.
-	 * The new data must be anded with the mask.  Each channel
-	 * corresponds to a bit.
+	/* Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
+	 * and V3 transmit the setpoint to the target DAC.  V4 and V5 send
+	 * data to a non-existent TrimDac channel just to keep the clock
+	 * running after sending data to the target DAC.  This is necessary
+	 * to eliminate the clock glitch that would otherwise occur at the
+	 * end of the target DAC's serial data stream.  When the sequence
+	 * restarts at V0 (after executing V5), the gate array automatically
+	 * disables gating for the DAC clock and all DAC chip selects.
 	 */
-	if (data[0]) {
-		/* Check if requested ports are configured for output */
-		if ((s->io_bits & data[0]) != data[0])
-			return -EIO;
 
-		s->state &= ~data[0];
-		s->state |= data[0] & data[1];
-
-		/* Write out the new digital output lines */
+	WSImage = (chan & 2) ? WS1 : WS2;
+	/* Choose DAC chip select to be asserted. */
+	SETVECT(2, XSD2 | XFIFO_1 | WSImage);
+	/* Slot 2: Transmit high data byte to target DAC. */
+	SETVECT(3, XSD2 | XFIFO_0 | WSImage);
+	/* Slot 3: Transmit low data byte to target DAC. */
+	SETVECT(4, XSD2 | XFIFO_3 | WS3);
+	/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */
+	SETVECT(5, XSD2 | XFIFO_2 | WS3 | EOS);
+	/* Slot 5: running after writing target DAC's low data byte. */
 
-		DEBIwrite(dev, diopriv->WRDOut, s->state);
-	}
-	data[1] = DEBIread(dev, diopriv->RDDIn);
+	/*  Construct and transmit target DAC's serial packet:
+	 * ( A10D DDDD ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan<0>,
+	 * and D<12:0> is the DAC setpoint.  Append a WORD value (that writes
+	 * to a  non-existent TrimDac channel) that serves to keep the clock
+	 * running after the packet has been sent to the target DAC.
+	 */
+	SendDAC(dev, 0x0F000000
+		/* Continue clock after target DAC data (write to non-existent trimdac). */
+		| 0x00004000
+		/* Address the two main dual-DAC devices (TSL's chip select enables
+		 * target device). */
+		| ((uint32_t) (chan & 1) << 15)
+		/*  Address the DAC channel within the  device. */
+		| (uint32_t) dacdata);	/*  Include DAC setpoint data. */
 
-	return insn->n;
 }
 
-static int s626_dio_insn_config(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
-{
+/* Private helper function: Transmit serial data to DAC via Audio
+ * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
+ * Dacpol contains valid target image.
+ */
 
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] =
-		    (s->
-		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
-		    COMEDI_INPUT;
-		return insn->n;
-		break;
-	case COMEDI_INPUT:
-		s->io_bits &= ~(1 << CR_CHAN(insn->chanspec));
-		break;
-	case COMEDI_OUTPUT:
-		s->io_bits |= 1 << CR_CHAN(insn->chanspec);
-		break;
-	default:
-		return -EINVAL;
-		break;
-	}
-	DEBIwrite(dev, diopriv->WRDOut, s->io_bits);
+static void SendDAC(struct comedi_device *dev, uint32_t val)
+{
 
-	return 1;
-}
+	/* START THE SERIAL CLOCK RUNNING ------------- */
 
-static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
-{
-	unsigned int group;
-	unsigned int bitmask;
-	unsigned int status;
+	/* Assert DAC polarity control and enable gating of DAC serial clock
+	 * and audio bit stream signals.  At this point in time we must be
+	 * assured of being in time slot 0.  If we are not in slot 0, the
+	 * serial clock and audio stream signals will be disabled; this is
+	 * because the following DEBIwrite statement (which enables signals
+	 * to be passed through the gate array) would execute before the
+	 * trailing edge of WS1/WS3 (which turns off the signals), thus
+	 * causing the signals to be inactive during the DAC write.
+	 */
+	DEBIwrite(dev, LP_DACPOL, devpriv->Dacpol);
 
-	/* select dio bank */
-	group = chan / 16;
-	bitmask = 1 << (chan - (16 * group));
-	DEBUG("s626_dio_set_irq: enable interrupt on dio channel %d group %d\n",
-	      chan - (16 * group), group);
+	/* TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- */
 
-	/* set channel to capture positive edge */
-	status = DEBIread(dev,
-			  ((struct dio_private *)(dev->subdevices + 2 +
-						  group)->private)->RDEdgSel);
-	DEBIwrite(dev,
-		  ((struct dio_private *)(dev->subdevices + 2 +
-					  group)->private)->WREdgSel,
-		  bitmask | status);
+	/* Copy DAC setpoint value to DAC's output DMA buffer. */
 
-	/* enable interrupt on selected channel */
-	status = DEBIread(dev,
-			  ((struct dio_private *)(dev->subdevices + 2 +
-						  group)->private)->RDIntSel);
-	DEBIwrite(dev,
-		  ((struct dio_private *)(dev->subdevices + 2 +
-					  group)->private)->WRIntSel,
-		  bitmask | status);
+	/* WR7146( (uint32_t)devpriv->pDacWBuf, val ); */
+	*devpriv->pDacWBuf = val;
 
-	/* enable edge capture write command */
-	DEBIwrite(dev, LP_MISC1, MISC1_EDCAP);
+	/* enab the output DMA transfer.  This will cause the DMAC to copy
+	 * the DAC's data value to A2's output FIFO.  The DMA transfer will
+	 * then immediately terminate because the protection address is
+	 * reached upon transfer of the first DWORD value.
+	 */
+	MC_ENABLE(P_MC1, MC1_A2OUT);
 
-	/* enable edge capture on selected channel */
-	status = DEBIread(dev,
-			  ((struct dio_private *)(dev->subdevices + 2 +
-						  group)->private)->RDCapSel);
-	DEBIwrite(dev,
-		  ((struct dio_private *)(dev->subdevices + 2 +
-					  group)->private)->WRCapSel,
-		  bitmask | status);
+	/*  While the DMA transfer is executing ... */
 
-	return 0;
-}
+	/* Reset Audio2 output FIFO's underflow flag (along with any other
+	 * FIFO underflow/overflow flags).  When set, this flag will
+	 * indicate that we have emerged from slot 0.
+	 */
+	WR7146(P_ISR, ISR_AFOU);
 
-static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,
-			      unsigned int mask)
-{
-	DEBUG
-	    ("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n",
-	     mask, group);
+	/* Wait for the DMA transfer to finish so that there will be data
+	 * available in the FIFO when time slot 1 tries to transfer a DWORD
+	 * from the FIFO to the output buffer register.  We test for DMA
+	 * Done by polling the DMAC enable flag; this flag is automatically
+	 * cleared when the transfer has finished.
+	 */
+	while ((RR7146(P_MC1) & MC1_A2OUT) != 0)
+		;
 
-	/* disable edge capture write command */
-	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
+	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
 
-	/* enable edge capture on selected channel */
-	DEBIwrite(dev,
-		  ((struct dio_private *)(dev->subdevices + 2 +
-					  group)->private)->WRCapSel, mask);
+	/* FIFO data is now available, so we enable execution of time slots
+	 * 1 and higher by clearing the EOS flag in slot 0.  Note that SD3
+	 * will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
+	 * detection.
+	 */
+	SETVECT(0, XSD2 | RSD3 | SIB_A2);
 
-	return 0;
-}
+	/* Wait for slot 1 to execute to ensure that the Packet will be
+	 * transmitted.  This is detected by polling the Audio2 output FIFO
+	 * underflow flag, which will be set when slot 1 execution has
+	 * finished transferring the DAC's data DWORD from the output FIFO
+	 * to the output buffer register.
+	 */
+	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0)
+		;
 
-static int s626_dio_clear_irq(struct comedi_device *dev)
-{
-	unsigned int group;
+	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
+	 * back to slot 0 after executing the EOS in slot 5.  Also,
+	 * simultaneously shift out and in the 0x00 that is ALWAYS the value
+	 * stored in the last byte to be shifted out of the FIFO's DWORD
+	 * buffer register.
+	 */
+	SETVECT(0, XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS);
 
-	/* disable edge capture write command */
-	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
+	/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */
 
-	for (group = 0; group < S626_DIO_BANKS; group++) {
-		/* clear pending events and interrupt */
-		DEBIwrite(dev,
-			  ((struct dio_private *)(dev->subdevices + 2 +
-						  group)->private)->WRCapSel,
-			  0xffff);
+	/* Wait for the TSL to finish executing all time slots before
+	 * exiting this function.  We must do this so that the next DAC
+	 * write doesn't start, thereby enabling clock/chip select signals:
+	 *
+	 * 1. Before the TSL sequence cycles back to slot 0, which disables
+	 *    the clock/cs signal gating and traps slot // list execution.
+	 *    we have not yet finished slot 5 then the clock/cs signals are
+	 *    still gated and we have not finished transmitting the stream.
+	 *
+	 * 2. While slots 2-5 are executing due to a late slot 0 trap.  In
+	 *    this case, the slot sequence is currently repeating, but with
+	 *    clock/cs signals disabled.  We must wait for slot 0 to trap
+	 *    execution before setting up the next DAC setpoint DMA transfer
+	 *    and enabling the clock/cs signals.  To detect the end of slot 5,
+	 *    we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
+	 *    the TSL has not yet finished executing slot 5 ...
+	 */
+	if ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) {
+		/* The trap was set on time and we are still executing somewhere
+		 * in slots 2-5, so we now wait for slot 0 to execute and trap
+		 * TSL execution.  This is detected when FB_BUFFER2 MSB changes
+		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
+		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
+		 */
+		while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0)
+			;
 	}
+	/* Either (1) we were too late setting the slot 0 trap; the TSL
+	 * sequencer restarted slot 0 before we could set the EOS trap flag,
+	 * or (2) we were not late and execution is now trapped at slot 0.
+	 * In either case, we must now change slot 0 so that it will store
+	 * value 0xFF (instead of 0x00) to FB_BUFFER2 next time it executes.
+	 * In order to do this, we reprogram slot 0 so that it will shift in
+	 * SD3, which is driven only by a pull-up resistor.
+	 */
+	SETVECT(0, RSD3 | SIB_A2 | EOS);
 
-	return 0;
+	/* Wait for slot 0 to execute, at which time the TSL is setup for
+	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
+	 * from 0x00 to 0xFF.
+	 */
+	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0)
+		;
 }
 
-/* Now this function initializes the value of the counter (data[0])
-   and set the subdevice. To complete with trigger and interrupt
-   configuration */
-static int s626_enc_insn_config(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
 {
-	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
-	    /*  index. */
-	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
-	    (CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is Counter. */
-	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
-	    /* ( CNTDIR_UP << BF_CLKPOL ) |      // Count direction is Down. */
-	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
-	    (CLKENAB_INDEX << BF_CLKENAB);
-	/*   uint16_t DisableIntSrc=TRUE; */
-	/*  uint32_t Preloadvalue;              //Counter initial value */
-	uint16_t valueSrclatch = LATCHSRC_AB_READ;
-	uint16_t enab = CLKENAB_ALWAYS;
-	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
+	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	/*  enab writes to */
+	/*  MISC2 register. */
+	DEBIwrite(dev, LP_WRMISC2, NewImage);	/*  Write new image to MISC2. */
+	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE);	/*  Disable writes to MISC2. */
+}
 
-	DEBUG("s626_enc_insn_config: encoder config\n");
+/*  Initialize the DEBI interface for all transfers. */
 
-	/*   (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
+static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
+{
+	uint16_t retval;
 
-	k->SetMode(dev, k, Setup, TRUE);
-	Preload(dev, k, *(insn->data));
-	k->PulseIndex(dev, k);
-	SetLatchSource(dev, k, valueSrclatch);
-	k->SetEnable(dev, k, (uint16_t) (enab != 0));
+	/*  Set up DEBI control register value in shadow RAM. */
+	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
 
-	return insn->n;
+	/*  Execute the DEBI transfer. */
+	DEBItransfer(dev);
+
+	/*  Fetch target register value. */
+	retval = (uint16_t) RR7146(P_DEBIAD);
+
+	/*  Return register value. */
+	return retval;
 }
 
-static int s626_enc_insn_read(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
+/*  Execute a DEBI transfer.  This must be called from within a */
+/*  critical section. */
+static void DEBItransfer(struct comedi_device *dev)
 {
+	/*  Initiate upload of shadow RAM to DEBI control register. */
+	MC_ENABLE(P_MC2, MC2_UPLD_DEBI);
 
-	int n;
-	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
+	/*  Wait for completion of upload from shadow RAM to DEBI control */
+	/*  register. */
+	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI))
+		;
 
-	DEBUG("s626_enc_insn_read: encoder read channel %d\n",
-	      CR_CHAN(insn->chanspec));
+	/*  Wait until DEBI transfer is done. */
+	while (RR7146(P_PSR) & PSR_DEBI_S)
+		;
+}
 
-	for (n = 0; n < insn->n; n++)
-		data[n] = ReadLatch(dev, k);
+/*  Write a value to a gate array register. */
+static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
+{
 
-	DEBUG("s626_enc_insn_read: encoder sample %d\n", data[n]);
+	/*  Set up DEBI control register value in shadow RAM. */
+	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
+	WR7146(P_DEBIAD, wdata);
 
-	return n;
+	/*  Execute the DEBI transfer. */
+	DEBItransfer(dev);
 }
 
-static int s626_enc_insn_write(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
+/* Replace the specified bits in a gate array register.  Imports: mask
+ * specifies bits that are to be preserved, wdata is new value to be
+ * or'd with the masked original.
+ */
+static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
+			uint16_t wdata)
 {
 
-	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
+	/*  Copy target gate array register into P_DEBIAD register. */
+	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
+	/* Set up DEBI control reg value in shadow RAM. */
+	DEBItransfer(dev);	/*  Execute the DEBI Read transfer. */
 
-	DEBUG("s626_enc_insn_write: encoder write channel %d\n",
-	      CR_CHAN(insn->chanspec));
+	/*  Write back the modified image. */
+	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
+	/* Set up DEBI control reg value in shadow  RAM. */
 
-	/*  Set the preload register */
-	Preload(dev, k, data[0]);
+	WR7146(P_DEBIAD, wdata | ((uint16_t) RR7146(P_DEBIAD) & mask));
+	/* Modify the register image. */
+	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
+}
 
-	/*  Software index pulse forces the preload register to load */
-	/*  into the counter */
-	k->SetLoadTrig(dev, k, 0);
-	k->PulseIndex(dev, k);
-	k->SetLoadTrig(dev, k, 2);
+static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
+		      size_t bsize)
+{
+	void *vbptr;
+	dma_addr_t vpptr;
 
-	DEBUG("s626_enc_insn_write: End encoder write\n");
+	DEBUG("CloseDMAB: Entering S626DRV_CloseDMAB():\n");
+	if (pdma == NULL)
+		return;
+	/* find the matching allocation from the board struct */
 
-	return 1;
+	vbptr = pdma->LogicalBase;
+	vpptr = pdma->PhysicalBase;
+	if (vbptr) {
+		pci_free_consistent(devpriv->pdev, bsize, vbptr, vpptr);
+		pdma->LogicalBase = NULL;
+		pdma->PhysicalBase = 0;
+
+		DEBUG("CloseDMAB(): Logical=%p, bsize=%d, Physical=0x%x\n",
+		      vbptr, bsize, (uint32_t) vpptr);
+	}
 }
 
-static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
-			    int tick)
+/* ******  COUNTER FUNCTIONS  ******* */
+/* All counter functions address a specific counter by means of the
+ * "Counter" argument, which is a logical counter number.  The Counter
+ * argument may have any of the following legal values: 0=0A, 1=1A,
+ * 2=2A, 3=0B, 4=1B, 5=2B.
+ */
+
+/* Forward declarations for functions that are common to both A and B counters: */
+
+/* ******  PRIVATE COUNTER FUNCTIONS ****** */
+
+/*  Read a counter's output latch. */
+
+static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
 {
-	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
-	    /*  index. */
-	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
-	    (CLKSRC_TIMER << BF_CLKSRC) |	/*  Operating mode is Timer. */
-	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
-	    (CNTDIR_DOWN << BF_CLKPOL) |	/*  Count direction is Down. */
-	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
-	    (CLKENAB_INDEX << BF_CLKENAB);
-	uint16_t valueSrclatch = LATCHSRC_A_INDXA;
-	/*   uint16_t enab=CLKENAB_ALWAYS; */
+	register uint32_t value;
+	/* DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n"); */
 
-	k->SetMode(dev, k, Setup, FALSE);
+	/*  Latch counts and fetch LSW of latched counts value. */
+	value = (uint32_t) DEBIread(dev, k->MyLatchLsw);
 
-	/*  Set the preload register */
-	Preload(dev, k, tick);
+	/*  Fetch MSW of latched counts and combine with LSW. */
+	value |= ((uint32_t) DEBIread(dev, k->MyLatchLsw + 2) << 16);
 
-	/*  Software index pulse forces the preload register to load */
-	/*  into the counter */
-	k->SetLoadTrig(dev, k, 0);
-	k->PulseIndex(dev, k);
+	/*  DEBUG FIXME DEBUG("ReadLatch: Read Latch exit\n"); */
+
+	/*  Return latched counts. */
+	return value;
+}
 
-	/* set reload on counter overflow */
-	k->SetLoadTrig(dev, k, 1);
+/*  Reset a counter's index and overflow event capture flags. */
 
-	/* set interrupt on overflow */
-	k->SetIntSrc(dev, k, INTSRC_OVER);
+static void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k)
+{
+	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
+		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+}
 
-	SetLatchSource(dev, k, valueSrclatch);
-	/*   k->SetEnable(dev,k,(uint16_t)(enab != 0)); */
+static void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k)
+{
+	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
+		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
 }
 
-/* ***********  DAC FUNCTIONS *********** */
+/*  Return counter setup in a format (COUNTER_SETUP) that is consistent */
+/*  for both A and B counters. */
 
-/*  Slot 0 base settings. */
-#define VECT0	(XSD2 | RSD3 | SIB_A2)
-/*  Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
+static uint16_t GetMode_A(struct comedi_device *dev, struct enc_private *k)
+{
+	register uint16_t cra;
+	register uint16_t crb;
+	register uint16_t setup;
 
-/*  TrimDac LogicalChan-to-PhysicalChan mapping table. */
-static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
+	/*  Fetch CRA and CRB register images. */
+	cra = DEBIread(dev, k->MyCRA);
+	crb = DEBIread(dev, k->MyCRB);
 
-/*  TrimDac LogicalChan-to-EepromAdrs mapping table. */
-static uint8_t trimadrs[] = { 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
+	/*  Populate the standardized counter setup bit fields.  Note: */
+	/*  IndexSrc is restricted to ENC_X or IndxPol. */
+	setup = ((cra & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcA. */
+		 |((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcA. */
+		 |((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcA. */
+		 |((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) & STDMSK_INDXSRC)	/*  IndxSrc  = IndxSrcA<1>. */
+		 |((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolA. */
+		 |((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) & STDMSK_CLKENAB));	/*  ClkEnab  = ClkEnabA. */
 
-static void LoadTrimDACs(struct comedi_device *dev)
-{
-	register uint8_t i;
+	/*  Adjust mode-dependent parameters. */
+	if (cra & (2 << CRABIT_CLKSRC_A))	/*  If Timer mode (ClkSrcA<1> == 1): */
+		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
+			  |((cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) & STDMSK_CLKPOL)	/*    Set ClkPol to indicate count direction (ClkSrcA<0>). */
+			  |(MULT_X1 << STDBIT_CLKMULT));	/*    ClkMult must be 1x in Timer mode. */
 
-	/*  Copy TrimDac setpoint values from EEPROM to TrimDacs. */
-	for (i = 0; i < ARRAY_SIZE(trimchan); i++)
-		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
+	else			/*  If Counter mode (ClkSrcA<1> == 0): */
+		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Counter mode. */
+			  |((cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) & STDMSK_CLKPOL)	/*    Pass through ClkPol. */
+			  |(((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A)) ?	/*    Force ClkMult to 1x if not legal, else pass through. */
+			    (MULT_X1 << STDBIT_CLKMULT) :
+			    ((cra >> (CRABIT_CLKMULT_A -
+				      STDBIT_CLKMULT)) & STDMSK_CLKMULT)));
+
+	/*  Return adjusted counter setup. */
+	return setup;
 }
 
-static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
-			 uint8_t DacData)
+static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k)
 {
-	uint32_t chan;
+	register uint16_t cra;
+	register uint16_t crb;
+	register uint16_t setup;
 
-	/*  Save the new setpoint in case the application needs to read it back later. */
-	devpriv->TrimSetpoint[LogicalChan] = (uint8_t) DacData;
+	/*  Fetch CRA and CRB register images. */
+	cra = DEBIread(dev, k->MyCRA);
+	crb = DEBIread(dev, k->MyCRB);
 
-	/*  Map logical channel number to physical channel number. */
-	chan = (uint32_t) trimchan[LogicalChan];
+	/*  Populate the standardized counter setup bit fields.  Note: */
+	/*  IndexSrc is restricted to ENC_X or IndxPol. */
+	setup = (((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcB. */
+		 |((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcB. */
+		 |((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcB. */
+		 |((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolB. */
+		 |((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) & STDMSK_CLKENAB)	/*  ClkEnab  = ClkEnabB. */
+		 |((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) & STDMSK_INDXSRC));	/*  IndxSrc  = IndxSrcB<1>. */
 
-	/* Set up TSL2 records for TrimDac write operation.  All slots shift
-	 * 0xFF in from pulled-up SD3 so that the end of the slot sequence
-	 * can be detected.
-	 */
+	/*  Adjust mode-dependent parameters. */
+	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B))	/*  If Extender mode (ClkMultB == MULT_X0): */
+		setup |= ((CLKSRC_EXTENDER << STDBIT_CLKSRC)	/*    Indicate Extender mode. */
+			  |(MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
+			  |((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
 
-	SETVECT(2, XSD2 | XFIFO_1 | WS3);
-	/* Slot 2: Send high uint8_t to target TrimDac. */
-	SETVECT(3, XSD2 | XFIFO_0 | WS3);
-	/* Slot 3: Send low uint8_t to target TrimDac. */
-	SETVECT(4, XSD2 | XFIFO_3 | WS1);
-	/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running. */
-	SETVECT(5, XSD2 | XFIFO_2 | WS1 | EOS);
-	/* Slot 5: Send NOP low  uint8_t to DAC0. */
+	else if (cra & (2 << CRABIT_CLKSRC_B))	/*  If Timer mode (ClkSrcB<1> == 1): */
+		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
+			  |(MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
+			  |((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
 
-	/* Construct and transmit target DAC's serial packet:
-	 * ( 0000 AAAA ), ( DDDD DDDD ),( 0x00 ),( 0x00 ) where A<3:0> is the
-	 * DAC channel's address, and D<7:0> is the DAC setpoint.  Append a
-	 * WORD value (that writes a channel 0 NOP command to a non-existent
-	 * main DAC channel) that serves to keep the clock running after the
-	 * packet has been sent to the target DAC.
-	 */
+	else			/*  If Counter mode (ClkSrcB<1> == 0): */
+		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
+			  |((crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) & STDMSK_CLKMULT)	/*    Clock multiplier is passed through. */
+			  |((crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) & STDMSK_CLKPOL));	/*    Clock polarity is passed through. */
 
-	/*  Address the DAC channel within the trimdac device. */
-	SendDAC(dev, ((uint32_t) chan << 8)
-		| (uint32_t) DacData);	/*  Include DAC setpoint data. */
+	/*  Return adjusted counter setup. */
+	return setup;
 }
 
-/* **************  EEPROM ACCESS FUNCTIONS  ************** */
-/*  Read uint8_t from EEPROM. */
+/*
+ * Set the operating mode for the specified counter.  The setup
+ * parameter is treated as a COUNTER_SETUP data type.  The following
+ * parameters are programmable (all other parms are ignored): ClkMult,
+ * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
+ */
 
-static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
+static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
+		      uint16_t Setup, uint16_t DisableIntSrc)
 {
-	uint8_t rtnval;
-
-	/*  Send EEPROM target address. */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)
-			 /* Byte2 = I2C command: write to I2C EEPROM  device. */
-			 | I2C_B1(I2C_ATTRSTOP, addr)
-			 /* Byte1 = EEPROM internal target address. */
-			 | I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not sent. */
-		/*  Abort function and declare error if handshake failed. */
-		DEBUG("I2Cread: error handshake I2Cread  a\n");
-		return 0;
-	}
-	/*  Execute EEPROM read. */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)
+	register uint16_t cra;
+	register uint16_t crb;
+	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
 
-			 /*  Byte2 = I2C */
-			 /*  command: read */
-			 /*  from I2C EEPROM */
-			 /*  device. */
-			 |I2C_B1(I2C_ATTRSTOP, 0)
+	/*  Initialize CRA and CRB images. */
+	cra = ((setup & CRAMSK_LOADSRC_A)	/*  Preload trigger is passed through. */
+	       |((setup & STDMSK_INDXSRC) >> (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	/*  IndexSrc is restricted to ENC_X or IndxPol. */
 
-			 /*  Byte1 receives */
-			 /*  uint8_t from */
-			 /*  EEPROM. */
-			 |I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not  sent. */
+	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A	/*  Reset any pending CounterA event captures. */
+	       | ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	/*  Clock enable is passed through. */
 
-		/*  Abort function and declare error if handshake failed. */
-		DEBUG("I2Cread: error handshake I2Cread b\n");
-		return 0;
-	}
-	/*  Return copy of EEPROM value. */
-	rtnval = (uint8_t) (RR7146(P_I2CCTRL) >> 16);
-	return rtnval;
-}
+	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
+	if (!DisableIntSrc)
+		cra |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
+						    CRABIT_INTSRC_A));
 
-static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
-{
-	/*  Write I2C command to I2C Transfer Control shadow register. */
-	WR7146(P_I2CCTRL, val);
+	/*  Populate all mode-dependent attributes of CRA & CRB images. */
+	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
+	case CLKSRC_EXTENDER:	/*  Extender Mode: Force to Timer mode */
+		/*  (Extender valid only for B counters). */
 
-	/*  Upload I2C shadow registers into working registers and wait for */
-	/*  upload confirmation. */
+	case CLKSRC_TIMER:	/*  Timer Mode: */
+		cra |= ((2 << CRABIT_CLKSRC_A)	/*    ClkSrcA<1> selects system clock */
+			|((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	/*      with count direction (ClkSrcA<0>) obtained from ClkPol. */
+			|(1 << CRABIT_CLKPOL_A)	/*    ClkPolA behaves as always-on clock enable. */
+			|(MULT_X1 << CRABIT_CLKMULT_A));	/*    ClkMult must be 1x. */
+		break;
 
-	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
-	while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
-		;
+	default:		/*  Counter Mode: */
+		cra |= (CLKSRC_COUNTER	/*    Select ENC_C and ENC_D as clock/direction inputs. */
+			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKPOL_A - STDBIT_CLKPOL))	/*    Clock polarity is passed through. */
+			|(((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force multiplier to x1 if not legal, otherwise pass through. */
+			  (MULT_X1 << CRABIT_CLKMULT_A) :
+			  ((setup & STDMSK_CLKMULT) << (CRABIT_CLKMULT_A -
+							STDBIT_CLKMULT))));
+	}
 
-	/*  Wait until I2C bus transfer is finished or an error occurs. */
-	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY)
-		;
+	/*  Force positive index polarity if IndxSrc is software-driven only, */
+	/*  otherwise pass it through. */
+	if (~setup & STDMSK_INDXSRC)
+		cra |= ((setup & STDMSK_INDXPOL) << (CRABIT_INDXPOL_A -
+						     STDBIT_INDXPOL));
 
-	/*  Return non-zero if I2C error occurred. */
-	return RR7146(P_I2CCTRL) & I2C_ERR;
+	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
+	/*  enable mask to indicate the counter interrupt is disabled. */
+	if (DisableIntSrc)
+		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
 
+	/*  While retaining CounterB and LatchSrc configurations, program the */
+	/*  new counter operating mode. */
+	DEBIreplace(dev, k->MyCRA, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
+	DEBIreplace(dev, k->MyCRB,
+		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
 }
 
-/*  Private helper function: Write setpoint to an application DAC channel. */
-
-static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
+static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
+		      uint16_t Setup, uint16_t DisableIntSrc)
 {
-	register uint16_t signmask;
-	register uint32_t WSImage;
+	register uint16_t cra;
+	register uint16_t crb;
+	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
 
-	/*  Adjust DAC data polarity and set up Polarity Control Register */
-	/*  image. */
-	signmask = 1 << chan;
-	if (dacdata < 0) {
-		dacdata = -dacdata;
-		devpriv->Dacpol |= signmask;
-	} else
-		devpriv->Dacpol &= ~signmask;
+	/*  Initialize CRA and CRB images. */
+	cra = ((setup & STDMSK_INDXSRC) << ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC));	/*  IndexSrc field is restricted to ENC_X or IndxPol. */
+
+	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B	/*  Reset event captures and disable interrupts. */
+	       | ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	/*  Clock enable is passed through. */
+	       |((setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	/*  Preload trigger source is passed through. */
+
+	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
+	if (!DisableIntSrc)
+		crb |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
+						    CRBBIT_INTSRC_B));
+
+	/*  Populate all mode-dependent attributes of CRA & CRB images. */
+	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
+	case CLKSRC_TIMER:	/*  Timer Mode: */
+		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB<1> selects system clock */
+			|((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction (ClkSrcB<0>) obtained from ClkPol. */
+		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB behaves as always-on clock enable. */
+			|(MULT_X1 << CRBBIT_CLKMULT_B));	/*    ClkMultB must be 1x. */
+		break;
 
-	/*  Limit DAC setpoint value to valid range. */
-	if ((uint16_t) dacdata > 0x1FFF)
-		dacdata = 0x1FFF;
+	case CLKSRC_EXTENDER:	/*  Extender Mode: */
+		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB source is OverflowA (same as "timer") */
+			|((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction obtained from ClkPol. */
+		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB controls IndexB -- always set to active. */
+			|(MULT_X0 << CRBBIT_CLKMULT_B));	/*    ClkMultB selects OverflowA as the clock source. */
+		break;
 
-	/* Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
-	 * and V3 transmit the setpoint to the target DAC.  V4 and V5 send
-	 * data to a non-existent TrimDac channel just to keep the clock
-	 * running after sending data to the target DAC.  This is necessary
-	 * to eliminate the clock glitch that would otherwise occur at the
-	 * end of the target DAC's serial data stream.  When the sequence
-	 * restarts at V0 (after executing V5), the gate array automatically
-	 * disables gating for the DAC clock and all DAC chip selects.
-	 */
+	default:		/*  Counter Mode: */
+		cra |= (CLKSRC_COUNTER << CRABIT_CLKSRC_B);	/*    Select ENC_C and ENC_D as clock/direction inputs. */
+		crb |= (((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRBBIT_CLKPOL_B))	/*    ClkPol is passed through. */
+			|(((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force ClkMult to x1 if not legal, otherwise pass through. */
+			  (MULT_X1 << CRBBIT_CLKMULT_B) :
+			  ((setup & STDMSK_CLKMULT) << (CRBBIT_CLKMULT_B -
+							STDBIT_CLKMULT))));
+	}
 
-	WSImage = (chan & 2) ? WS1 : WS2;
-	/* Choose DAC chip select to be asserted. */
-	SETVECT(2, XSD2 | XFIFO_1 | WSImage);
-	/* Slot 2: Transmit high data byte to target DAC. */
-	SETVECT(3, XSD2 | XFIFO_0 | WSImage);
-	/* Slot 3: Transmit low data byte to target DAC. */
-	SETVECT(4, XSD2 | XFIFO_3 | WS3);
-	/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */
-	SETVECT(5, XSD2 | XFIFO_2 | WS3 | EOS);
-	/* Slot 5: running after writing target DAC's low data byte. */
+	/*  Force positive index polarity if IndxSrc is software-driven only, */
+	/*  otherwise pass it through. */
+	if (~setup & STDMSK_INDXSRC)
+		crb |= ((setup & STDMSK_INDXPOL) >> (STDBIT_INDXPOL -
+						     CRBBIT_INDXPOL_B));
 
-	/*  Construct and transmit target DAC's serial packet:
-	 * ( A10D DDDD ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan<0>,
-	 * and D<12:0> is the DAC setpoint.  Append a WORD value (that writes
-	 * to a  non-existent TrimDac channel) that serves to keep the clock
-	 * running after the packet has been sent to the target DAC.
-	 */
-	SendDAC(dev, 0x0F000000
-		/* Continue clock after target DAC data (write to non-existent trimdac). */
-		| 0x00004000
-		/* Address the two main dual-DAC devices (TSL's chip select enables
-		 * target device). */
-		| ((uint32_t) (chan & 1) << 15)
-		/*  Address the DAC channel within the  device. */
-		| (uint32_t) dacdata);	/*  Include DAC setpoint data. */
+	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
+	/*  enable mask to indicate the counter interrupt is disabled. */
+	if (DisableIntSrc)
+		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
 
+	/*  While retaining CounterA and LatchSrc configurations, program the */
+	/*  new counter operating mode. */
+	DEBIreplace(dev, k->MyCRA,
+		    (uint16_t) (~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B)), cra);
+	DEBIreplace(dev, k->MyCRB, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
 }
 
-/* Private helper function: Transmit serial data to DAC via Audio
- * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
- * Dacpol contains valid target image.
- */
+/*  Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index. */
 
-static void SendDAC(struct comedi_device *dev, uint32_t val)
+static void SetEnable_A(struct comedi_device *dev, struct enc_private *k,
+			uint16_t enab)
 {
+	DEBUG("SetEnable_A: SetEnable_A enter 3541\n");
+	DEBIreplace(dev, k->MyCRB,
+		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)),
+		    (uint16_t) (enab << CRBBIT_CLKENAB_A));
+}
 
-	/* START THE SERIAL CLOCK RUNNING ------------- */
-
-	/* Assert DAC polarity control and enable gating of DAC serial clock
-	 * and audio bit stream signals.  At this point in time we must be
-	 * assured of being in time slot 0.  If we are not in slot 0, the
-	 * serial clock and audio stream signals will be disabled; this is
-	 * because the following DEBIwrite statement (which enables signals
-	 * to be passed through the gate array) would execute before the
-	 * trailing edge of WS1/WS3 (which turns off the signals), thus
-	 * causing the signals to be inactive during the DAC write.
-	 */
-	DEBIwrite(dev, LP_DACPOL, devpriv->Dacpol);
+static void SetEnable_B(struct comedi_device *dev, struct enc_private *k,
+			uint16_t enab)
+{
+	DEBIreplace(dev, k->MyCRB,
+		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),
+		    (uint16_t) (enab << CRBBIT_CLKENAB_B));
+}
 
-	/* TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- */
+static uint16_t GetEnable_A(struct comedi_device *dev, struct enc_private *k)
+{
+	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_A) & 1;
+}
 
-	/* Copy DAC setpoint value to DAC's output DMA buffer. */
+static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k)
+{
+	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_B) & 1;
+}
 
-	/* WR7146( (uint32_t)devpriv->pDacWBuf, val ); */
-	*devpriv->pDacWBuf = val;
+/* Return/set a counter pair's latch trigger source.  0: On read
+ * access, 1: A index latches A, 2: B index latches B, 3: A overflow
+ * latches B.
+ */
 
-	/* enab the output DMA transfer.  This will cause the DMAC to copy
-	 * the DAC's data value to A2's output FIFO.  The DMA transfer will
-	 * then immediately terminate because the protection address is
-	 * reached upon transfer of the first DWORD value.
-	 */
-	MC_ENABLE(P_MC1, MC1_A2OUT);
+static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
+			   uint16_t value)
+{
+	DEBUG("SetLatchSource: SetLatchSource enter 3550\n");
+	DEBIreplace(dev, k->MyCRB,
+		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC)),
+		    (uint16_t) (value << CRBBIT_LATCHSRC));
 
-	/*  While the DMA transfer is executing ... */
+	DEBUG("SetLatchSource: SetLatchSource exit\n");
+}
 
-	/* Reset Audio2 output FIFO's underflow flag (along with any other
-	 * FIFO underflow/overflow flags).  When set, this flag will
-	 * indicate that we have emerged from slot 0.
-	 */
-	WR7146(P_ISR, ISR_AFOU);
+/*
+ * static uint16_t GetLatchSource(struct comedi_device *dev, struct enc_private *k )
+ * {
+ *	return ( DEBIread( dev, k->MyCRB) >> CRBBIT_LATCHSRC ) & 3;
+ * }
+ */
 
-	/* Wait for the DMA transfer to finish so that there will be data
-	 * available in the FIFO when time slot 1 tries to transfer a DWORD
-	 * from the FIFO to the output buffer register.  We test for DMA
-	 * Done by polling the DMAC enable flag; this flag is automatically
-	 * cleared when the transfer has finished.
-	 */
-	while ((RR7146(P_MC1) & MC1_A2OUT) != 0)
-		;
+/*
+ * Return/set the event that will trigger transfer of the preload
+ * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
+ * 2=OverflowA (B counters only), 3=disabled.
+ */
 
-	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
+static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t Trig)
+{
+	DEBIreplace(dev, k->MyCRA, (uint16_t) (~CRAMSK_LOADSRC_A),
+		    (uint16_t) (Trig << CRABIT_LOADSRC_A));
+}
 
-	/* FIFO data is now available, so we enable execution of time slots
-	 * 1 and higher by clearing the EOS flag in slot 0.  Note that SD3
-	 * will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
-	 * detection.
-	 */
-	SETVECT(0, XSD2 | RSD3 | SIB_A2);
+static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t Trig)
+{
+	DEBIreplace(dev, k->MyCRB,
+		    (uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),
+		    (uint16_t) (Trig << CRBBIT_LOADSRC_B));
+}
 
-	/* Wait for slot 1 to execute to ensure that the Packet will be
-	 * transmitted.  This is detected by polling the Audio2 output FIFO
-	 * underflow flag, which will be set when slot 1 execution has
-	 * finished transferring the DAC's data DWORD from the output FIFO
-	 * to the output buffer register.
-	 */
-	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0)
-		;
+static uint16_t GetLoadTrig_A(struct comedi_device *dev, struct enc_private *k)
+{
+	return (DEBIread(dev, k->MyCRA) >> CRABIT_LOADSRC_A) & 3;
+}
 
-	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
-	 * back to slot 0 after executing the EOS in slot 5.  Also,
-	 * simultaneously shift out and in the 0x00 that is ALWAYS the value
-	 * stored in the last byte to be shifted out of the FIFO's DWORD
-	 * buffer register.
-	 */
-	SETVECT(0, XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS);
+static uint16_t GetLoadTrig_B(struct comedi_device *dev, struct enc_private *k)
+{
+	return (DEBIread(dev, k->MyCRB) >> CRBBIT_LOADSRC_B) & 3;
+}
 
-	/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */
+/* Return/set counter interrupt source and clear any captured
+ * index/overflow events.  IntSource: 0=Disabled, 1=OverflowOnly,
+ * 2=IndexOnly, 3=IndexAndOverflow.
+ */
 
-	/* Wait for the TSL to finish executing all time slots before
-	 * exiting this function.  We must do this so that the next DAC
-	 * write doesn't start, thereby enabling clock/chip select signals:
-	 *
-	 * 1. Before the TSL sequence cycles back to slot 0, which disables
-	 *    the clock/cs signal gating and traps slot // list execution.
-	 *    we have not yet finished slot 5 then the clock/cs signals are
-	 *    still gated and we have not finished transmitting the stream.
-	 *
-	 * 2. While slots 2-5 are executing due to a late slot 0 trap.  In
-	 *    this case, the slot sequence is currently repeating, but with
-	 *    clock/cs signals disabled.  We must wait for slot 0 to trap
-	 *    execution before setting up the next DAC setpoint DMA transfer
-	 *    and enabling the clock/cs signals.  To detect the end of slot 5,
-	 *    we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
-	 *    the TSL has not yet finished executing slot 5 ...
-	 */
-	if ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) {
-		/* The trap was set on time and we are still executing somewhere
-		 * in slots 2-5, so we now wait for slot 0 to execute and trap
-		 * TSL execution.  This is detected when FB_BUFFER2 MSB changes
-		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
-		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
-		 */
-		while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0)
-			;
-	}
-	/* Either (1) we were too late setting the slot 0 trap; the TSL
-	 * sequencer restarted slot 0 before we could set the EOS trap flag,
-	 * or (2) we were not late and execution is now trapped at slot 0.
-	 * In either case, we must now change slot 0 so that it will store
-	 * value 0xFF (instead of 0x00) to FB_BUFFER2 next time it executes.
-	 * In order to do this, we reprogram slot 0 so that it will shift in
-	 * SD3, which is driven only by a pull-up resistor.
-	 */
-	SETVECT(0, RSD3 | SIB_A2 | EOS);
+static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
+			uint16_t IntSource)
+{
+	/*  Reset any pending counter overflow or index captures. */
+	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
+		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 
-	/* Wait for slot 0 to execute, at which time the TSL is setup for
-	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
-	 * from 0x00 to 0xFF.
-	 */
-	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0)
-		;
+	/*  Program counter interrupt source. */
+	DEBIreplace(dev, k->MyCRA, ~CRAMSK_INTSRC_A,
+		    (uint16_t) (IntSource << CRABIT_INTSRC_A));
+
+	/*  Update MISC2 interrupt enable mask. */
+	devpriv->CounterIntEnabs =
+	    (devpriv->CounterIntEnabs & ~k->
+	     MyEventBits[3]) | k->MyEventBits[IntSource];
 }
 
-static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
+static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
+			uint16_t IntSource)
 {
-	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	/*  enab writes to */
-	/*  MISC2 register. */
-	DEBIwrite(dev, LP_WRMISC2, NewImage);	/*  Write new image to MISC2. */
-	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE);	/*  Disable writes to MISC2. */
+	uint16_t crb;
+
+	/*  Cache writeable CRB register image. */
+	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;
+
+	/*  Reset any pending counter overflow or index captures. */
+	DEBIwrite(dev, k->MyCRB,
+		  (uint16_t) (crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
+
+	/*  Program counter interrupt source. */
+	DEBIwrite(dev, k->MyCRB,
+		  (uint16_t) ((crb & ~CRBMSK_INTSRC_B) | (IntSource <<
+							  CRBBIT_INTSRC_B)));
+
+	/*  Update MISC2 interrupt enable mask. */
+	devpriv->CounterIntEnabs =
+	    (devpriv->CounterIntEnabs & ~k->
+	     MyEventBits[3]) | k->MyEventBits[IntSource];
 }
 
-/*  Initialize the DEBI interface for all transfers. */
+static uint16_t GetIntSrc_A(struct comedi_device *dev, struct enc_private *k)
+{
+	return (DEBIread(dev, k->MyCRA) >> CRABIT_INTSRC_A) & 3;
+}
 
-static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
+static uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k)
 {
-	uint16_t retval;
+	return (DEBIread(dev, k->MyCRB) >> CRBBIT_INTSRC_B) & 3;
+}
 
-	/*  Set up DEBI control register value in shadow RAM. */
-	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
+/*  Return/set the clock multiplier. */
 
-	/*  Execute the DEBI transfer. */
-	DEBItransfer(dev);
+/* static void SetClkMult(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */
+/* { */
+/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKMULT ) | ( value << STDBIT_CLKMULT ) ), FALSE ); */
+/* } */
 
-	/*  Fetch target register value. */
-	retval = (uint16_t) RR7146(P_DEBIAD);
+/* static uint16_t GetClkMult(struct comedi_device *dev, struct enc_private *k )  */
+/* { */
+/*   return ( k->GetMode(dev, k ) >> STDBIT_CLKMULT ) & 3; */
+/* } */
 
-	/*  Return register value. */
-	return retval;
-}
+/* Return/set the clock polarity. */
 
-/*  Execute a DEBI transfer.  This must be called from within a */
-/*  critical section. */
-static void DEBItransfer(struct comedi_device *dev)
-{
-	/*  Initiate upload of shadow RAM to DEBI control register. */
-	MC_ENABLE(P_MC2, MC2_UPLD_DEBI);
+/* static void SetClkPol( struct comedi_device *dev,struct enc_private *k, uint16_t value )  */
+/* { */
+/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKPOL ) | ( value << STDBIT_CLKPOL ) ), FALSE ); */
+/* } */
 
-	/*  Wait for completion of upload from shadow RAM to DEBI control */
-	/*  register. */
-	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI))
-		;
+/* static uint16_t GetClkPol(struct comedi_device *dev, struct enc_private *k )  */
+/* { */
+/*   return ( k->GetMode(dev, k ) >> STDBIT_CLKPOL ) & 1; */
+/* } */
 
-	/*  Wait until DEBI transfer is done. */
-	while (RR7146(P_PSR) & PSR_DEBI_S)
-		;
-}
+/* Return/set the clock source.  */
 
-/*  Write a value to a gate array register. */
-static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
-{
+/* static void SetClkSrc( struct comedi_device *dev,struct enc_private *k, uint16_t value )  */
+/* { */
+/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKSRC ) | ( value << STDBIT_CLKSRC ) ), FALSE ); */
+/* } */
 
-	/*  Set up DEBI control register value in shadow RAM. */
-	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
-	WR7146(P_DEBIAD, wdata);
+/* static uint16_t GetClkSrc( struct comedi_device *dev,struct enc_private *k )  */
+/* { */
+/*   return ( k->GetMode(dev, k ) >> STDBIT_CLKSRC ) & 3; */
+/* } */
 
-	/*  Execute the DEBI transfer. */
-	DEBItransfer(dev);
-}
+/* Return/set the index polarity. */
 
-/* Replace the specified bits in a gate array register.  Imports: mask
- * specifies bits that are to be preserved, wdata is new value to be
- * or'd with the masked original.
- */
-static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
-			uint16_t wdata)
-{
+/* static void SetIndexPol(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */
+/* { */
+/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_INDXPOL ) | ( (value != 0) << STDBIT_INDXPOL ) ), FALSE ); */
+/* } */
 
-	/*  Copy target gate array register into P_DEBIAD register. */
-	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
-	/* Set up DEBI control reg value in shadow RAM. */
-	DEBItransfer(dev);	/*  Execute the DEBI Read transfer. */
+/* static uint16_t GetIndexPol(struct comedi_device *dev, struct enc_private *k )  */
+/* { */
+/*   return ( k->GetMode(dev, k ) >> STDBIT_INDXPOL ) & 1; */
+/* } */
 
-	/*  Write back the modified image. */
-	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
-	/* Set up DEBI control reg value in shadow  RAM. */
+/*  Return/set the index source. */
 
-	WR7146(P_DEBIAD, wdata | ((uint16_t) RR7146(P_DEBIAD) & mask));
-	/* Modify the register image. */
-	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
-}
+/* static void SetIndexSrc(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */
+/* { */
+/*   DEBUG("SetIndexSrc: set index src enter 3700\n"); */
+/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_INDXSRC ) | ( (value != 0) << STDBIT_INDXSRC ) ), FALSE ); */
+/* } */
 
-static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
-		      size_t bsize)
-{
-	void *vbptr;
-	dma_addr_t vpptr;
+/* static uint16_t GetIndexSrc(struct comedi_device *dev, struct enc_private *k )  */
+/* { */
+/*   return ( k->GetMode(dev, k ) >> STDBIT_INDXSRC ) & 1; */
+/* } */
 
-	DEBUG("CloseDMAB: Entering S626DRV_CloseDMAB():\n");
-	if (pdma == NULL)
-		return;
-	/* find the matching allocation from the board struct */
+/*  Generate an index pulse. */
 
-	vbptr = pdma->LogicalBase;
-	vpptr = pdma->PhysicalBase;
-	if (vbptr) {
-		pci_free_consistent(devpriv->pdev, bsize, vbptr, vpptr);
-		pdma->LogicalBase = NULL;
-		pdma->PhysicalBase = 0;
+static void PulseIndex_A(struct comedi_device *dev, struct enc_private *k)
+{
+	register uint16_t cra;
 
-		DEBUG("CloseDMAB(): Logical=%p, bsize=%d, Physical=0x%x\n",
-		      vbptr, bsize, (uint32_t) vpptr);
-	}
+	DEBUG("PulseIndex_A: pulse index enter\n");
+
+	cra = DEBIread(dev, k->MyCRA);	/*  Pulse index. */
+	DEBIwrite(dev, k->MyCRA, (uint16_t) (cra ^ CRAMSK_INDXPOL_A));
+	DEBUG("PulseIndex_A: pulse index step1\n");
+	DEBIwrite(dev, k->MyCRA, cra);
 }
 
-/* ******  COUNTER FUNCTIONS  ******* */
-/* All counter functions address a specific counter by means of the
- * "Counter" argument, which is a logical counter number.  The Counter
- * argument may have any of the following legal values: 0=0A, 1=1A,
- * 2=2A, 3=0B, 4=1B, 5=2B.
- */
+static void PulseIndex_B(struct comedi_device *dev, struct enc_private *k)
+{
+	register uint16_t crb;
 
-/* Forward declarations for functions that are common to both A and B counters: */
+	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;	/*  Pulse index. */
+	DEBIwrite(dev, k->MyCRB, (uint16_t) (crb ^ CRBMSK_INDXPOL_B));
+	DEBIwrite(dev, k->MyCRB, crb);
+}
 
-/* ******  PRIVATE COUNTER FUNCTIONS ****** */
+/*  Write value into counter preload register. */
 
-/*  Read a counter's output latch. */
+static void Preload(struct comedi_device *dev, struct enc_private *k,
+		    uint32_t value)
+{
+	DEBUG("Preload: preload enter\n");
+	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
+	DEBUG("Preload: preload step 1\n");
+	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw + 2),
+		  (uint16_t) (value >> 16));
+}
 
-static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
+static void CountersInit(struct comedi_device *dev)
 {
-	register uint32_t value;
-	/* DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n"); */
+	int chan;
+	struct enc_private *k;
+	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
+	    /*  index. */
+	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+	    (CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is counter. */
+	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+	    (CNTDIR_UP << BF_CLKPOL) |	/*  Count direction is up. */
+	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
+	    (CLKENAB_INDEX << BF_CLKENAB);	/*  Enabled by index */
 
-	/*  Latch counts and fetch LSW of latched counts value. */
-	value = (uint32_t) DEBIread(dev, k->MyLatchLsw);
+	/*  Disable all counter interrupts and clear any captured counter events. */
+	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
+		k = &encpriv[chan];
+		k->SetMode(dev, k, Setup, TRUE);
+		k->SetIntSrc(dev, k, 0);
+		k->ResetCapFlags(dev, k);
+		k->SetEnable(dev, k, CLKENAB_ALWAYS);
+	}
+	DEBUG("CountersInit: counters initialized\n");
 
-	/*  Fetch MSW of latched counts and combine with LSW. */
-	value |= ((uint32_t) DEBIread(dev, k->MyLatchLsw + 2) << 16);
+}
 
-	/*  DEBUG FIXME DEBUG("ReadLatch: Read Latch exit\n"); */
+static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+{
+/*   uint8_t	PollList; */
+/*   uint16_t	AdcData; */
+/*   uint16_t	StartVal; */
+/*   uint16_t	index; */
+/*   unsigned int data[16]; */
+	int result;
+	int i;
+	int ret;
+	resource_size_t resourceStart;
+	dma_addr_t appdma;
+	struct comedi_subdevice *s;
+	struct pci_dev *pdev = NULL;
 
-	/*  Return latched counts. */
-	return value;
-}
+	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
+		return -ENOMEM;
 
-/*  Reset a counter's index and overflow event capture flags. */
+	for (i = 0; i < ARRAY_SIZE(s626_boards) && !pdev; i++) {
+		do {
+			pdev = pci_get_subsys(s626_boards[i].vendor_id,
+					      s626_boards[i].device_id,
+					      s626_boards[i].subvendor_id,
+					      s626_boards[i].subdevice_id,
+					      pdev);
+
+			if ((it->options[0] || it->options[1]) && pdev) {
+				/* matches requested bus/slot */
+				if (pdev->bus->number == it->options[0] &&
+				    PCI_SLOT(pdev->devfn) == it->options[1])
+					break;
+			} else
+				break;
+		} while (1);
+	}
+	devpriv->pdev = pdev;
 
-static void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k)
-{
-	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
-		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
-}
+	if (pdev == NULL) {
+		printk(KERN_ERR "s626_attach: Board not present!!!\n");
+		return -ENODEV;
+	}
 
-static void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k)
-{
-	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
-		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
-}
+	result = comedi_pci_enable(pdev, "s626");
+	if (result < 0) {
+		printk(KERN_ERR "s626_attach: comedi_pci_enable fails\n");
+		return -ENODEV;
+	}
+	devpriv->got_regions = 1;
 
-/*  Return counter setup in a format (COUNTER_SETUP) that is consistent */
-/*  for both A and B counters. */
+	resourceStart = pci_resource_start(devpriv->pdev, 0);
 
-static uint16_t GetMode_A(struct comedi_device *dev, struct enc_private *k)
-{
-	register uint16_t cra;
-	register uint16_t crb;
-	register uint16_t setup;
+	devpriv->base_addr = ioremap(resourceStart, SIZEOF_ADDRESS_SPACE);
+	if (devpriv->base_addr == NULL) {
+		printk(KERN_ERR "s626_attach: IOREMAP failed\n");
+		return -ENODEV;
+	}
 
-	/*  Fetch CRA and CRB register images. */
-	cra = DEBIread(dev, k->MyCRA);
-	crb = DEBIread(dev, k->MyCRB);
+	if (devpriv->base_addr) {
+		/* disable master interrupt */
+		writel(0, devpriv->base_addr + P_IER);
 
-	/*  Populate the standardized counter setup bit fields.  Note: */
-	/*  IndexSrc is restricted to ENC_X or IndxPol. */
-	setup = ((cra & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcA. */
-		 |((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcA. */
-		 |((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcA. */
-		 |((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) & STDMSK_INDXSRC)	/*  IndxSrc  = IndxSrcA<1>. */
-		 |((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolA. */
-		 |((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) & STDMSK_CLKENAB));	/*  ClkEnab  = ClkEnabA. */
+		/* soft reset */
+		writel(MC1_SOFT_RESET, devpriv->base_addr + P_MC1);
 
-	/*  Adjust mode-dependent parameters. */
-	if (cra & (2 << CRABIT_CLKSRC_A))	/*  If Timer mode (ClkSrcA<1> == 1): */
-		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
-			  |((cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) & STDMSK_CLKPOL)	/*    Set ClkPol to indicate count direction (ClkSrcA<0>). */
-			  |(MULT_X1 << STDBIT_CLKMULT));	/*    ClkMult must be 1x in Timer mode. */
+		/* DMA FIXME DMA// */
+		DEBUG("s626_attach: DMA ALLOCATION\n");
 
-	else			/*  If Counter mode (ClkSrcA<1> == 0): */
-		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Counter mode. */
-			  |((cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) & STDMSK_CLKPOL)	/*    Pass through ClkPol. */
-			  |(((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A)) ?	/*    Force ClkMult to 1x if not legal, else pass through. */
-			    (MULT_X1 << STDBIT_CLKMULT) :
-			    ((cra >> (CRABIT_CLKMULT_A -
-				      STDBIT_CLKMULT)) & STDMSK_CLKMULT)));
+		/* adc buffer allocation */
+		devpriv->allocatedBuf = 0;
 
-	/*  Return adjusted counter setup. */
-	return setup;
-}
+		devpriv->ANABuf.LogicalBase =
+		    pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
 
-static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k)
-{
-	register uint16_t cra;
-	register uint16_t crb;
-	register uint16_t setup;
+		if (devpriv->ANABuf.LogicalBase == NULL) {
+			printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
+			return -ENOMEM;
+		}
 
-	/*  Fetch CRA and CRB register images. */
-	cra = DEBIread(dev, k->MyCRA);
-	crb = DEBIread(dev, k->MyCRB);
+		devpriv->ANABuf.PhysicalBase = appdma;
 
-	/*  Populate the standardized counter setup bit fields.  Note: */
-	/*  IndexSrc is restricted to ENC_X or IndxPol. */
-	setup = (((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcB. */
-		 |((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcB. */
-		 |((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcB. */
-		 |((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolB. */
-		 |((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) & STDMSK_CLKENAB)	/*  ClkEnab  = ClkEnabB. */
-		 |((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) & STDMSK_INDXSRC));	/*  IndxSrc  = IndxSrcB<1>. */
+		DEBUG
+		    ("s626_attach: AllocDMAB ADC Logical=%p, bsize=%d, Physical=0x%x\n",
+		     devpriv->ANABuf.LogicalBase, DMABUF_SIZE,
+		     (uint32_t) devpriv->ANABuf.PhysicalBase);
 
-	/*  Adjust mode-dependent parameters. */
-	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B))	/*  If Extender mode (ClkMultB == MULT_X0): */
-		setup |= ((CLKSRC_EXTENDER << STDBIT_CLKSRC)	/*    Indicate Extender mode. */
-			  |(MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
-			  |((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+		devpriv->allocatedBuf++;
 
-	else if (cra & (2 << CRABIT_CLKSRC_B))	/*  If Timer mode (ClkSrcB<1> == 1): */
-		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
-			  |(MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
-			  |((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+		devpriv->RPSBuf.LogicalBase =
+		    pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
 
-	else			/*  If Counter mode (ClkSrcB<1> == 0): */
-		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
-			  |((crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) & STDMSK_CLKMULT)	/*    Clock multiplier is passed through. */
-			  |((crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) & STDMSK_CLKPOL));	/*    Clock polarity is passed through. */
+		if (devpriv->RPSBuf.LogicalBase == NULL) {
+			printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
+			return -ENOMEM;
+		}
 
-	/*  Return adjusted counter setup. */
-	return setup;
-}
+		devpriv->RPSBuf.PhysicalBase = appdma;
 
-/*
- * Set the operating mode for the specified counter.  The setup
- * parameter is treated as a COUNTER_SETUP data type.  The following
- * parameters are programmable (all other parms are ignored): ClkMult,
- * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
- */
+		DEBUG
+		    ("s626_attach: AllocDMAB RPS Logical=%p, bsize=%d, Physical=0x%x\n",
+		     devpriv->RPSBuf.LogicalBase, DMABUF_SIZE,
+		     (uint32_t) devpriv->RPSBuf.PhysicalBase);
 
-static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
-		      uint16_t Setup, uint16_t DisableIntSrc)
-{
-	register uint16_t cra;
-	register uint16_t crb;
-	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
+		devpriv->allocatedBuf++;
 
-	/*  Initialize CRA and CRB images. */
-	cra = ((setup & CRAMSK_LOADSRC_A)	/*  Preload trigger is passed through. */
-	       |((setup & STDMSK_INDXSRC) >> (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	/*  IndexSrc is restricted to ENC_X or IndxPol. */
+	}
 
-	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A	/*  Reset any pending CounterA event captures. */
-	       | ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	/*  Clock enable is passed through. */
+	dev->board_ptr = s626_boards;
+	dev->board_name = thisboard->name;
 
-	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
-	if (!DisableIntSrc)
-		cra |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
-						    CRABIT_INTSRC_A));
+	ret = comedi_alloc_subdevices(dev, 6);
+	if (ret)
+		return ret;
 
-	/*  Populate all mode-dependent attributes of CRA & CRB images. */
-	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
-	case CLKSRC_EXTENDER:	/*  Extender Mode: Force to Timer mode */
-		/*  (Extender valid only for B counters). */
+	dev->iobase = (unsigned long)devpriv->base_addr;
+	dev->irq = devpriv->pdev->irq;
 
-	case CLKSRC_TIMER:	/*  Timer Mode: */
-		cra |= ((2 << CRABIT_CLKSRC_A)	/*    ClkSrcA<1> selects system clock */
-			|((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	/*      with count direction (ClkSrcA<0>) obtained from ClkPol. */
-			|(1 << CRABIT_CLKPOL_A)	/*    ClkPolA behaves as always-on clock enable. */
-			|(MULT_X1 << CRABIT_CLKMULT_A));	/*    ClkMult must be 1x. */
-		break;
+	/* set up interrupt handler */
+	if (dev->irq == 0) {
+		printk(KERN_ERR " unknown irq (bad)\n");
+	} else {
+		ret = request_irq(dev->irq, s626_irq_handler, IRQF_SHARED,
+				  "s626", dev);
 
-	default:		/*  Counter Mode: */
-		cra |= (CLKSRC_COUNTER	/*    Select ENC_C and ENC_D as clock/direction inputs. */
-			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKPOL_A - STDBIT_CLKPOL))	/*    Clock polarity is passed through. */
-			|(((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force multiplier to x1 if not legal, otherwise pass through. */
-			  (MULT_X1 << CRABIT_CLKMULT_A) :
-			  ((setup & STDMSK_CLKMULT) << (CRABIT_CLKMULT_A -
-							STDBIT_CLKMULT))));
+		if (ret < 0) {
+			printk(KERN_ERR " irq not available\n");
+			dev->irq = 0;
+		}
 	}
 
-	/*  Force positive index polarity if IndxSrc is software-driven only, */
-	/*  otherwise pass it through. */
-	if (~setup & STDMSK_INDXSRC)
-		cra |= ((setup & STDMSK_INDXPOL) << (CRABIT_INDXPOL_A -
-						     STDBIT_INDXPOL));
+	DEBUG("s626_attach: -- it opts  %d,%d --\n",
+	      it->options[0], it->options[1]);
 
-	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
-	/*  enable mask to indicate the counter interrupt is disabled. */
-	if (DisableIntSrc)
-		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
+	s = dev->subdevices + 0;
+	/* analog input subdevice */
+	dev->read_subdev = s;
+	/* we support single-ended (ground) and differential */
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_CMD_READ;
+	s->n_chan = thisboard->ai_chans;
+	s->maxdata = (0xffff >> 2);
+	s->range_table = &s626_range_table;
+	s->len_chanlist = thisboard->ai_chans;	/* This is the maximum chanlist
+						   length that the board can
+						   handle */
+	s->insn_config = s626_ai_insn_config;
+	s->insn_read = s626_ai_insn_read;
+	s->do_cmd = s626_ai_cmd;
+	s->do_cmdtest = s626_ai_cmdtest;
+	s->cancel = s626_ai_cancel;
 
-	/*  While retaining CounterB and LatchSrc configurations, program the */
-	/*  new counter operating mode. */
-	DEBIreplace(dev, k->MyCRA, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
-	DEBIreplace(dev, k->MyCRB,
-		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
-}
+	s = dev->subdevices + 1;
+	/* analog output subdevice */
+	s->type = COMEDI_SUBD_AO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = thisboard->ao_chans;
+	s->maxdata = (0x3fff);
+	s->range_table = &range_bipolar10;
+	s->insn_write = s626_ao_winsn;
+	s->insn_read = s626_ao_rinsn;
 
-static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
-		      uint16_t Setup, uint16_t DisableIntSrc)
-{
-	register uint16_t cra;
-	register uint16_t crb;
-	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
+	s = dev->subdevices + 2;
+	/* digital I/O subdevice */
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = S626_DIO_CHANNELS;
+	s->maxdata = 1;
+	s->io_bits = 0xffff;
+	s->private = &dio_private_A;
+	s->range_table = &range_digital;
+	s->insn_config = s626_dio_insn_config;
+	s->insn_bits = s626_dio_insn_bits;
+
+	s = dev->subdevices + 3;
+	/* digital I/O subdevice */
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = 16;
+	s->maxdata = 1;
+	s->io_bits = 0xffff;
+	s->private = &dio_private_B;
+	s->range_table = &range_digital;
+	s->insn_config = s626_dio_insn_config;
+	s->insn_bits = s626_dio_insn_bits;
+
+	s = dev->subdevices + 4;
+	/* digital I/O subdevice */
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = 16;
+	s->maxdata = 1;
+	s->io_bits = 0xffff;
+	s->private = &dio_private_C;
+	s->range_table = &range_digital;
+	s->insn_config = s626_dio_insn_config;
+	s->insn_bits = s626_dio_insn_bits;
 
-	/*  Initialize CRA and CRB images. */
-	cra = ((setup & STDMSK_INDXSRC) << ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC));	/*  IndexSrc field is restricted to ENC_X or IndxPol. */
+	s = dev->subdevices + 5;
+	/* encoder (counter) subdevice */
+	s->type = COMEDI_SUBD_COUNTER;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;
+	s->n_chan = thisboard->enc_chans;
+	s->private = enc_private_data;
+	s->insn_config = s626_enc_insn_config;
+	s->insn_read = s626_enc_insn_read;
+	s->insn_write = s626_enc_insn_write;
+	s->maxdata = 0xffffff;
+	s->range_table = &range_unknown;
 
-	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B	/*  Reset event captures and disable interrupts. */
-	       | ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	/*  Clock enable is passed through. */
-	       |((setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	/*  Preload trigger source is passed through. */
+	/* stop ai_command */
+	devpriv->ai_cmd_running = 0;
 
-	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
-	if (!DisableIntSrc)
-		crb |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
-						    CRBBIT_INTSRC_B));
+	if (devpriv->base_addr && (devpriv->allocatedBuf == 2)) {
+		dma_addr_t pPhysBuf;
+		uint16_t chan;
 
-	/*  Populate all mode-dependent attributes of CRA & CRB images. */
-	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
-	case CLKSRC_TIMER:	/*  Timer Mode: */
-		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB<1> selects system clock */
-			|((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction (ClkSrcB<0>) obtained from ClkPol. */
-		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB behaves as always-on clock enable. */
-			|(MULT_X1 << CRBBIT_CLKMULT_B));	/*    ClkMultB must be 1x. */
-		break;
+		/*  enab DEBI and audio pins, enable I2C interface. */
+		MC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);
+		/*  Configure DEBI operating mode. */
+		WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	/*  Local bus is 16 */
+		       /*  bits wide. */
+		       | (DEBI_TOUT << DEBI_CFG_TOUT_BIT)
 
-	case CLKSRC_EXTENDER:	/*  Extender Mode: */
-		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB source is OverflowA (same as "timer") */
-			|((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction obtained from ClkPol. */
-		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB controls IndexB -- always set to active. */
-			|(MULT_X0 << CRBBIT_CLKMULT_B));	/*    ClkMultB selects OverflowA as the clock source. */
-		break;
+		       /*  Declare DEBI */
+		       /*  transfer timeout */
+		       /*  interval. */
+		       |DEBI_SWAP	/*  Set up byte lane */
+		       /*  steering. */
+		       | DEBI_CFG_INTEL);	/*  Intel-compatible */
+		/*  local bus (DEBI */
+		/*  never times out). */
+		DEBUG("s626_attach: %d debi init -- %d\n",
+		      DEBI_CFG_SLAVE16 | (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
+		      DEBI_SWAP | DEBI_CFG_INTEL,
+		      DEBI_CFG_INTEL | DEBI_CFG_TOQ | DEBI_CFG_INCQ |
+		      DEBI_CFG_16Q);
 
-	default:		/*  Counter Mode: */
-		cra |= (CLKSRC_COUNTER << CRABIT_CLKSRC_B);	/*    Select ENC_C and ENC_D as clock/direction inputs. */
-		crb |= (((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRBBIT_CLKPOL_B))	/*    ClkPol is passed through. */
-			|(((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force ClkMult to x1 if not legal, otherwise pass through. */
-			  (MULT_X1 << CRBBIT_CLKMULT_B) :
-			  ((setup & STDMSK_CLKMULT) << (CRBBIT_CLKMULT_B -
-							STDBIT_CLKMULT))));
-	}
+		/* DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ */
+		/* | DEBI_CFG_INCQ| DEBI_CFG_16Q); //end */
 
-	/*  Force positive index polarity if IndxSrc is software-driven only, */
-	/*  otherwise pass it through. */
-	if (~setup & STDMSK_INDXSRC)
-		crb |= ((setup & STDMSK_INDXPOL) >> (STDBIT_INDXPOL -
-						     CRBBIT_INDXPOL_B));
+		/*  Paging is disabled. */
+		WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);	/*  Disable MMU paging. */
 
-	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
-	/*  enable mask to indicate the counter interrupt is disabled. */
-	if (DisableIntSrc)
-		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
+		/*  Init GPIO so that ADC Start* is negated. */
+		WR7146(P_GPIO, GPIO_BASE | GPIO1_HI);
 
-	/*  While retaining CounterA and LatchSrc configurations, program the */
-	/*  new counter operating mode. */
-	DEBIreplace(dev, k->MyCRA,
-		    (uint16_t) (~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B)), cra);
-	DEBIreplace(dev, k->MyCRB, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
-}
+		/* IsBoardRevA is a boolean that indicates whether the board is RevA.
+		 *
+		 * VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
+		 * EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
+		 * is used to access the onboard serial EEPROM.  The EEPROM's I2C
+		 * DeviceAddress is hardwired to a value that is dependent on the
+		 * 626 board revision.  On all board revisions, the EEPROM stores
+		 * TrimDAC calibration constants for analog I/O.  On RevB and
+		 * higher boards, the DeviceAddress is hardwired to 0 to enable
+		 * the EEPROM to also store the PCI SubVendorID and SubDeviceID;
+		 * this is the address at which the SAA7146 expects a
+		 * configuration EEPROM to reside.  On RevA boards, the EEPROM
+		 * device address, which is hardwired to 4, prevents the SAA7146
+		 * from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
+		 * default values, instead.
+		 */
 
-/*  Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index. */
+		/*     devpriv->I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM */
+		/*  DeviceType (0xA0) */
+		/*  and DeviceAddress<<1. */
 
-static void SetEnable_A(struct comedi_device *dev, struct enc_private *k,
-			uint16_t enab)
-{
-	DEBUG("SetEnable_A: SetEnable_A enter 3541\n");
-	DEBIreplace(dev, k->MyCRB,
-		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)),
-		    (uint16_t) (enab << CRBBIT_CLKENAB_A));
-}
+		devpriv->I2CAdrs = 0xA0;	/*  I2C device address for onboard */
+		/*  eeprom(revb) */
 
-static void SetEnable_B(struct comedi_device *dev, struct enc_private *k,
-			uint16_t enab)
-{
-	DEBIreplace(dev, k->MyCRB,
-		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),
-		    (uint16_t) (enab << CRBBIT_CLKENAB_B));
-}
+		/*  Issue an I2C ABORT command to halt any I2C operation in */
+		/* progress and reset BUSY flag. */
+		WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);
+		/*  Write I2C control: abort any I2C activity. */
+		MC_ENABLE(P_MC2, MC2_UPLD_IIC);
+		/*  Invoke command  upload */
+		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)
+			;
+		/*  and wait for upload to complete. */
 
-static uint16_t GetEnable_A(struct comedi_device *dev, struct enc_private *k)
-{
-	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_A) & 1;
-}
+		/* Per SAA7146 data sheet, write to STATUS reg twice to
+		 * reset all  I2C error flags. */
+		for (i = 0; i < 2; i++) {
+			WR7146(P_I2CSTAT, I2C_CLKSEL);
+			/*  Write I2C control: reset  error flags. */
+			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	/*  Invoke command upload */
+			while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
+				;
+			/* and wait for upload to complete. */
+		}
 
-static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k)
-{
-	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_B) & 1;
-}
+		/* Init audio interface functional attributes: set DAC/ADC
+		 * serial clock rates, invert DAC serial clock so that
+		 * DAC data setup times are satisfied, enable DAC serial
+		 * clock out.
+		 */
 
-/* Return/set a counter pair's latch trigger source.  0: On read
- * access, 1: A index latches A, 2: B index latches B, 3: A overflow
- * latches B.
- */
+		WR7146(P_ACON2, ACON2_INIT);
 
-static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
-			   uint16_t value)
-{
-	DEBUG("SetLatchSource: SetLatchSource enter 3550\n");
-	DEBIreplace(dev, k->MyCRB,
-		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC)),
-		    (uint16_t) (value << CRBBIT_LATCHSRC));
+		/* Set up TSL1 slot list, which is used to control the
+		 * accumulation of ADC data: RSD1 = shift data in on SD1.
+		 * SIB_A1  = store data uint8_t at next available location in
+		 * FB BUFFER1  register. */
+		WR7146(P_TSL1, RSD1 | SIB_A1);
+		/*  Fetch ADC high data uint8_t. */
+		WR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);
+		/*  Fetch ADC low data uint8_t; end of TSL1. */
 
-	DEBUG("SetLatchSource: SetLatchSource exit\n");
-}
+		/*  enab TSL1 slot list so that it executes all the time. */
+		WR7146(P_ACON1, ACON1_ADCSTART);
 
-/*
- * static uint16_t GetLatchSource(struct comedi_device *dev, struct enc_private *k )
- * {
- *	return ( DEBIread( dev, k->MyCRB) >> CRBBIT_LATCHSRC ) & 3;
- * }
- */
+		/*  Initialize RPS registers used for ADC. */
 
-/*
- * Return/set the event that will trigger transfer of the preload
- * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
- * 2=OverflowA (B counters only), 3=disabled.
- */
+		/* Physical start of RPS program. */
+		WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
 
-static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k,
-			  uint16_t Trig)
-{
-	DEBIreplace(dev, k->MyCRA, (uint16_t) (~CRAMSK_LOADSRC_A),
-		    (uint16_t) (Trig << CRABIT_LOADSRC_A));
-}
+		WR7146(P_RPSPAGE1, 0);
+		/*  RPS program performs no explicit mem writes. */
+		WR7146(P_RPS1_TOUT, 0);	/*  Disable RPS timeouts. */
 
-static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k,
-			  uint16_t Trig)
-{
-	DEBIreplace(dev, k->MyCRB,
-		    (uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),
-		    (uint16_t) (Trig << CRBBIT_LOADSRC_B));
-}
+		/* SAA7146 BUG WORKAROUND.  Initialize SAA7146 ADC interface
+		 * to a known state by invoking ADCs until FB BUFFER 1
+		 * register shows that it is correctly receiving ADC data.
+		 * This is necessary because the SAA7146 ADC interface does
+		 * not start up in a defined state after a PCI reset.
+		 */
 
-static uint16_t GetLoadTrig_A(struct comedi_device *dev, struct enc_private *k)
-{
-	return (DEBIread(dev, k->MyCRA) >> CRABIT_LOADSRC_A) & 3;
-}
+/*     PollList = EOPL;		// Create a simple polling */
+/*				// list for analog input */
+/*				// channel 0. */
+/*     ResetADC( dev, &PollList ); */
 
-static uint16_t GetLoadTrig_B(struct comedi_device *dev, struct enc_private *k)
-{
-	return (DEBIread(dev, k->MyCRB) >> CRBBIT_LOADSRC_B) & 3;
-}
+/*     s626_ai_rinsn(dev,dev->subdevices,NULL,data); //( &AdcData ); // */
+/*							//Get initial ADC */
+/*							//value. */
 
-/* Return/set counter interrupt source and clear any captured
- * index/overflow events.  IntSource: 0=Disabled, 1=OverflowOnly,
- * 2=IndexOnly, 3=IndexAndOverflow.
- */
+/*     StartVal = data[0]; */
 
-static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
-			uint16_t IntSource)
-{
-	/*  Reset any pending counter overflow or index captures. */
-	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
-		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+/*     // VERSION 2.01 CHANGE: TIMEOUT ADDED TO PREVENT HANGED EXECUTION. */
+/*     // Invoke ADCs until the new ADC value differs from the initial */
+/*     // value or a timeout occurs.  The timeout protects against the */
+/*     // possibility that the driver is restarting and the ADC data is a */
+/*     // fixed value resulting from the applied ADC analog input being */
+/*     // unusually quiet or at the rail. */
 
-	/*  Program counter interrupt source. */
-	DEBIreplace(dev, k->MyCRA, ~CRAMSK_INTSRC_A,
-		    (uint16_t) (IntSource << CRABIT_INTSRC_A));
+/*     for ( index = 0; index < 500; index++ ) */
+/*       { */
+/*	s626_ai_rinsn(dev,dev->subdevices,NULL,data); */
+/*	AdcData = data[0];	//ReadADC(  &AdcData ); */
+/*	if ( AdcData != StartVal ) */
+/*		break; */
+/*       } */
 
-	/*  Update MISC2 interrupt enable mask. */
-	devpriv->CounterIntEnabs =
-	    (devpriv->CounterIntEnabs & ~k->
-	     MyEventBits[3]) | k->MyEventBits[IntSource];
-}
+		/*  end initADC */
 
-static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
-			uint16_t IntSource)
-{
-	uint16_t crb;
+		/*  init the DAC interface */
 
-	/*  Cache writeable CRB register image. */
-	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;
+		/* Init Audio2's output DMAC attributes: burst length = 1
+		 * DWORD,  threshold = 1 DWORD.
+		 */
+		WR7146(P_PCI_BT_A, 0);
 
-	/*  Reset any pending counter overflow or index captures. */
-	DEBIwrite(dev, k->MyCRB,
-		  (uint16_t) (crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
+		/* Init Audio2's output DMA physical addresses.  The protection
+		 * address is set to 1 DWORD past the base address so that a
+		 * single DWORD will be transferred each time a DMA transfer is
+		 * enabled. */
 
-	/*  Program counter interrupt source. */
-	DEBIwrite(dev, k->MyCRB,
-		  (uint16_t) ((crb & ~CRBMSK_INTSRC_B) | (IntSource <<
-							  CRBBIT_INTSRC_B)));
+		pPhysBuf =
+		    devpriv->ANABuf.PhysicalBase +
+		    (DAC_WDMABUF_OS * sizeof(uint32_t));
 
-	/*  Update MISC2 interrupt enable mask. */
-	devpriv->CounterIntEnabs =
-	    (devpriv->CounterIntEnabs & ~k->
-	     MyEventBits[3]) | k->MyEventBits[IntSource];
-}
+		WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	/*  Buffer base adrs. */
+		WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	/*  Protection address. */
 
-static uint16_t GetIntSrc_A(struct comedi_device *dev, struct enc_private *k)
-{
-	return (DEBIread(dev, k->MyCRA) >> CRABIT_INTSRC_A) & 3;
-}
+		/* Cache Audio2's output DMA buffer logical address.  This is
+		 * where DAC data is buffered for A2 output DMA transfers. */
+		devpriv->pDacWBuf =
+		    (uint32_t *) devpriv->ANABuf.LogicalBase + DAC_WDMABUF_OS;
 
-static uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k)
-{
-	return (DEBIread(dev, k->MyCRB) >> CRBBIT_INTSRC_B) & 3;
-}
+		/* Audio2's output channels does not use paging.  The protection
+		 * violation handling bit is set so that the DMAC will
+		 * automatically halt and its PCI address pointer will be reset
+		 * when the protection address is reached. */
 
-/*  Return/set the clock multiplier. */
+		WR7146(P_PAGEA2_OUT, 8);
 
-/* static void SetClkMult(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */
-/* { */
-/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKMULT ) | ( value << STDBIT_CLKMULT ) ), FALSE ); */
-/* } */
+		/* Initialize time slot list 2 (TSL2), which is used to control
+		 * the clock generation for and serialization of data to be sent
+		 * to the DAC devices.  Slot 0 is a NOP that is used to trap TSL
+		 * execution; this permits other slots to be safely modified
+		 * without first turning off the TSL sequencer (which is
+		 * apparently impossible to do).  Also, SD3 (which is driven by a
+		 * pull-up resistor) is shifted in and stored to the MSB of
+		 * FB_BUFFER2 to be used as evidence that the slot sequence has
+		 * not yet finished executing.
+		 */
 
-/* static uint16_t GetClkMult(struct comedi_device *dev, struct enc_private *k )  */
-/* { */
-/*   return ( k->GetMode(dev, k ) >> STDBIT_CLKMULT ) & 3; */
-/* } */
+		SETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);
+		/*  Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2. */
 
-/* Return/set the clock polarity. */
+		/* Initialize slot 1, which is constant.  Slot 1 causes a
+		 * DWORD to be transferred from audio channel 2's output FIFO
+		 * to the FIFO's output buffer so that it can be serialized
+		 * and sent to the DAC during subsequent slots.  All remaining
+		 * slots are dynamically populated as required by the target
+		 * DAC device.
+		 */
+		SETVECT(1, LF_A2);
+		/*  Slot 1: Fetch DWORD from Audio2's output FIFO. */
 
-/* static void SetClkPol( struct comedi_device *dev,struct enc_private *k, uint16_t value )  */
-/* { */
-/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKPOL ) | ( value << STDBIT_CLKPOL ) ), FALSE ); */
-/* } */
+		/*  Start DAC's audio interface (TSL2) running. */
+		WR7146(P_ACON1, ACON1_DACSTART);
 
-/* static uint16_t GetClkPol(struct comedi_device *dev, struct enc_private *k )  */
-/* { */
-/*   return ( k->GetMode(dev, k ) >> STDBIT_CLKPOL ) & 1; */
-/* } */
+		/* end init DAC interface */
 
-/* Return/set the clock source.  */
+		/* Init Trim DACs to calibrated values.  Do it twice because the
+		 * SAA7146 audio channel does not always reset properly and
+		 * sometimes causes the first few TrimDAC writes to malfunction.
+		 */
 
-/* static void SetClkSrc( struct comedi_device *dev,struct enc_private *k, uint16_t value )  */
-/* { */
-/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKSRC ) | ( value << STDBIT_CLKSRC ) ), FALSE ); */
-/* } */
+		LoadTrimDACs(dev);
+		LoadTrimDACs(dev);	/*  Insurance. */
 
-/* static uint16_t GetClkSrc( struct comedi_device *dev,struct enc_private *k )  */
-/* { */
-/*   return ( k->GetMode(dev, k ) >> STDBIT_CLKSRC ) & 3; */
-/* } */
+		/* Manually init all gate array hardware in case this is a soft
+		 * reset (we have no way of determining whether this is a warm
+		 * or cold start).  This is necessary because the gate array will
+		 * reset only in response to a PCI hard reset; there is no soft
+		 * reset function. */
 
-/* Return/set the index polarity. */
+		/* Init all DAC outputs to 0V and init all DAC setpoint and
+		 * polarity images.
+		 */
+		for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
+			SetDAC(dev, chan, 0);
 
-/* static void SetIndexPol(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */
-/* { */
-/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_INDXPOL ) | ( (value != 0) << STDBIT_INDXPOL ) ), FALSE ); */
-/* } */
+		/* Init image of WRMISC2 Battery Charger Enabled control bit.
+		 * This image is used when the state of the charger control bit,
+		 * which has no direct hardware readback mechanism, is queried.
+		 */
+		devpriv->ChargeEnabled = 0;
 
-/* static uint16_t GetIndexPol(struct comedi_device *dev, struct enc_private *k )  */
-/* { */
-/*   return ( k->GetMode(dev, k ) >> STDBIT_INDXPOL ) & 1; */
-/* } */
+		/* Init image of watchdog timer interval in WRMISC2.  This image
+		 * maintains the value of the control bits of MISC2 are
+		 * continuously reset to zero as long as the WD timer is disabled.
+		 */
+		devpriv->WDInterval = 0;
 
-/*  Return/set the index source. */
+		/* Init Counter Interrupt enab mask for RDMISC2.  This mask is
+		 * applied against MISC2 when testing to determine which timer
+		 * events are requesting interrupt service.
+		 */
+		devpriv->CounterIntEnabs = 0;
 
-/* static void SetIndexSrc(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */
-/* { */
-/*   DEBUG("SetIndexSrc: set index src enter 3700\n"); */
-/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_INDXSRC ) | ( (value != 0) << STDBIT_INDXSRC ) ), FALSE ); */
-/* } */
+		/*  Init counters. */
+		CountersInit(dev);
 
-/* static uint16_t GetIndexSrc(struct comedi_device *dev, struct enc_private *k )  */
-/* { */
-/*   return ( k->GetMode(dev, k ) >> STDBIT_INDXSRC ) & 1; */
-/* } */
+		/* Without modifying the state of the Battery Backup enab, disable
+		 * the watchdog timer, set DIO channels 0-5 to operate in the
+		 * standard DIO (vs. counter overflow) mode, disable the battery
+		 * charger, and reset the watchdog interval selector to zero.
+		 */
+		WriteMISC2(dev, (uint16_t) (DEBIread(dev,
+						     LP_RDMISC2) &
+					    MISC2_BATT_ENABLE));
 
-/*  Generate an index pulse. */
+		/*  Initialize the digital I/O subsystem. */
+		s626_dio_init(dev);
 
-static void PulseIndex_A(struct comedi_device *dev, struct enc_private *k)
-{
-	register uint16_t cra;
+		/* enable interrupt test */
+		/*  writel(IRQ_GPIO3 | IRQ_RPS1,devpriv->base_addr+P_IER); */
+	}
 
-	DEBUG("PulseIndex_A: pulse index enter\n");
+	DEBUG("s626_attach: comedi%d s626 attached %04x\n", dev->minor,
+	      (uint32_t) devpriv->base_addr);
 
-	cra = DEBIread(dev, k->MyCRA);	/*  Pulse index. */
-	DEBIwrite(dev, k->MyCRA, (uint16_t) (cra ^ CRAMSK_INDXPOL_A));
-	DEBUG("PulseIndex_A: pulse index step1\n");
-	DEBIwrite(dev, k->MyCRA, cra);
+	return 1;
 }
 
-static void PulseIndex_B(struct comedi_device *dev, struct enc_private *k)
+static void s626_detach(struct comedi_device *dev)
 {
-	register uint16_t crb;
+	if (devpriv) {
+		/* stop ai_command */
+		devpriv->ai_cmd_running = 0;
 
-	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;	/*  Pulse index. */
-	DEBIwrite(dev, k->MyCRB, (uint16_t) (crb ^ CRBMSK_INDXPOL_B));
-	DEBIwrite(dev, k->MyCRB, crb);
-}
+		if (devpriv->base_addr) {
+			/* interrupt mask */
+			WR7146(P_IER, 0);	/*  Disable master interrupt. */
+			WR7146(P_ISR, IRQ_GPIO3 | IRQ_RPS1);	/*  Clear board's IRQ status flag. */
 
-/*  Write value into counter preload register. */
+			/*  Disable the watchdog timer and battery charger. */
+			WriteMISC2(dev, 0);
 
-static void Preload(struct comedi_device *dev, struct enc_private *k,
-		    uint32_t value)
-{
-	DEBUG("Preload: preload enter\n");
-	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
-	DEBUG("Preload: preload step 1\n");
-	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw + 2),
-		  (uint16_t) (value >> 16));
-}
+			/*  Close all interfaces on 7146 device. */
+			WR7146(P_MC1, MC1_SHUTDOWN);
+			WR7146(P_ACON1, ACON1_BASE);
 
-static void CountersInit(struct comedi_device *dev)
-{
-	int chan;
-	struct enc_private *k;
-	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
-	    /*  index. */
-	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
-	    (CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is counter. */
-	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
-	    (CNTDIR_UP << BF_CLKPOL) |	/*  Count direction is up. */
-	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
-	    (CLKENAB_INDEX << BF_CLKENAB);	/*  Enabled by index */
+			CloseDMAB(dev, &devpriv->RPSBuf, DMABUF_SIZE);
+			CloseDMAB(dev, &devpriv->ANABuf, DMABUF_SIZE);
+		}
 
-	/*  Disable all counter interrupts and clear any captured counter events. */
-	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
-		k = &encpriv[chan];
-		k->SetMode(dev, k, Setup, TRUE);
-		k->SetIntSrc(dev, k, 0);
-		k->ResetCapFlags(dev, k);
-		k->SetEnable(dev, k, CLKENAB_ALWAYS);
+		if (dev->irq)
+			free_irq(dev->irq, dev);
+		if (devpriv->base_addr)
+			iounmap(devpriv->base_addr);
+		if (devpriv->pdev) {
+			if (devpriv->got_regions)
+				comedi_pci_disable(devpriv->pdev);
+			pci_dev_put(devpriv->pdev);
+		}
 	}
-	DEBUG("CountersInit: counters initialized\n");
-
 }
 
 static struct comedi_driver s626_driver = {

commit 0588ea3467e8773ddc98dfccb67b646ead2abd31
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 19:24:19 2012 -0700

    staging: comedi: s626: pointers should be cleared with NULL not 0
    
    pdma->LogicalBase is a void *, NULL should be used to clear it not 0.
    
    This quiets a sparse warning about:
    
    warning: Using plain integer as NULL pointer
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 440060b6f629..58c9e40f6126 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2779,7 +2779,7 @@ static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
 	vpptr = pdma->PhysicalBase;
 	if (vbptr) {
 		pci_free_consistent(devpriv->pdev, bsize, vbptr, vpptr);
-		pdma->LogicalBase = 0;
+		pdma->LogicalBase = NULL;
 		pdma->PhysicalBase = 0;
 
 		DEBUG("CloseDMAB(): Logical=%p, bsize=%d, Physical=0x%x\n",

commit cc4fce7f1f3e3aa9fb6b3b242ba268ba3c6272d0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 19:23:54 2012 -0700

    staging: comedi: s626: local functions should not be exposed globally
    
    The 'ResetADC' function is prototyped as a static but is missing
    the static tag in it's definition. The function is only referenced
    in this file so add the static tag to the definition.
    
    This quiets a sparse warning about:
    
    warning: symbol 'ResetADC' was not declared. Should it be static?
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index d5edd9c091e6..440060b6f629 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1348,7 +1348,7 @@ static void s626_detach(struct comedi_device *dev)
 /*
  * this functions build the RPS program for hardware driven acquistion
  */
-void ResetADC(struct comedi_device *dev, uint8_t * ppl)
+static void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 {
 	register uint32_t *pRPS;
 	uint32_t JmpAdrs;

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 182074c5f78b..d5edd9c091e6 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2160,7 +2160,7 @@ static int s626_dio_insn_bits(struct comedi_device *dev,
 	}
 	data[1] = DEBIread(dev, diopriv->RDDIn);
 
-	return 2;
+	return insn->n;
 }
 
 static int s626_dio_insn_config(struct comedi_device *dev,

commit 520706607befd1f5c20ec14db35d6be45791bc41
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 11:18:25 2012 -0700

    staging: comedi: remove unneeded sanity check in insn_bits functions
    
    The comedi core does the sanity check to make sure that the data length
    the INSN_BITS instruction is 2. There is no need for the drivers to do
    this check. Remove all the sanity checks in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 32e03bc247b3..182074c5f78b 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2140,18 +2140,6 @@ static int s626_dio_insn_bits(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
-
-	/* Length of data must be 2 (mask and new data, see below) */
-	if (insn->n == 0)
-		return 0;
-
-	if (insn->n != 2) {
-		printk
-		    ("comedi%d: s626: s626_dio_insn_bits(): Invalid instruction length\n",
-		     dev->minor);
-		return -EINVAL;
-	}
-
 	/*
 	 * The insn data consists of a mask in data[0] and the new data in
 	 * data[1]. The mask defines which bits we are concerning about.

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index f2eeca51ebfa..32e03bc247b3 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -595,8 +595,9 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->board_ptr = s626_boards;
 	dev->board_name = thisboard->name;
 
-	if (comedi_alloc_subdevices(dev, 6) < 0)
-		return -ENOMEM;
+	ret = comedi_alloc_subdevices(dev, 6);
+	if (ret)
+		return ret;
 
 	dev->iobase = (unsigned long)devpriv->base_addr;
 	dev->irq = devpriv->pdev->irq;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index d6dc3381205a..f2eeca51ebfa 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -595,7 +595,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->board_ptr = s626_boards;
 	dev->board_name = thisboard->name;
 
-	if (alloc_subdevices(dev, 6) < 0)
+	if (comedi_alloc_subdevices(dev, 6) < 0)
 		return -ENOMEM;
 
 	dev->iobase = (unsigned long)devpriv->base_addr;

commit 42caa910f286e2be0763a6fb8aa7a998e10c6e02
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon May 21 18:21:39 2012 -0700

    staging: comedi: s626: base_addr is a void __iomem *
    
    The base_addr variable in struct s626_private is an ioremap'ed pci
    resource and should be void __iomem * not a void *.
    
    This quiets a lot of sparse warings for the writel and readl calls
    like:
    
    warning: incorrect type in argument 1 (different address spaces)
     expected void const volatile [noderef] <asn:2>*addr
     got void *<noident>
    
    warning: incorrect type in argument 2 (different address spaces)
     expected void volatile [noderef] <asn:2>*addr
     got void *
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 516037009dcd..d6dc3381205a 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -118,7 +118,7 @@ static const struct s626_board s626_boards[] = {
 
 struct s626_private {
 	struct pci_dev *pdev;
-	void *base_addr;
+	void __iomem *base_addr;
 	int got_regions;
 	short allocatedBuf;
 	uint8_t ai_cmd_running;	/*  ai_cmd is running */

commit 55c03cff7fd73349473cc0a964df9d55b312dbbc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon May 21 17:12:12 2012 -0700

    staging: comedi: remove private header comedi_pci.h
    
    Remove the private header, comedi_pci.h, by moving the two
    helper functions into divers.c and providing the prototypes
    in comedidev.h.
    
    This allows the comedi_pci_enable/disable helper functions
    to be shared instead of having an inline version in every
    comedi pci driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 7beb8f6853af..516037009dcd 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -74,8 +74,6 @@ INSN_CONFIG instructions:
 
 #include "../comedidev.h"
 
-#include "comedi_pci.h"
-
 #include "comedi_fc.h"
 #include "s626.h"
 

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 56b111f3eccc..7beb8f6853af 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1312,7 +1312,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static int s626_detach(struct comedi_device *dev)
+static void s626_detach(struct comedi_device *dev)
 {
 	if (devpriv) {
 		/* stop ai_command */
@@ -1336,20 +1336,14 @@ static int s626_detach(struct comedi_device *dev)
 
 		if (dev->irq)
 			free_irq(dev->irq, dev);
-
 		if (devpriv->base_addr)
 			iounmap(devpriv->base_addr);
-
 		if (devpriv->pdev) {
 			if (devpriv->got_regions)
 				comedi_pci_disable(devpriv->pdev);
 			pci_dev_put(devpriv->pdev);
 		}
 	}
-
-	DEBUG("s626_detach: S626 detached!\n");
-
-	return 0;
 }
 
 /*

commit 75e6301baa78b2dff00e2cc3051301c32618acd7
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri May 11 16:16:20 2012 -0700

    staging: comedi: Use module_comedi_pci_driver and standardize drivers
    
    Convert the refactored comedi pci drivers to use the
    module_comedi_pci_driver() macro which makes the code
    smaller and a bit simpler.
    
    In the process, rename some of the symbols in the driver
    to standardize the comedi pci drivers.
    
    Based on the driver {name}:
    1) Rename the comedi_driver to {name}_driver.
    2) Use a static string {name} for the comedi_driver.driver_name.
    3) Rename the pci probe/remove functions to {name)_pci_probe/remove.
    4) Rename the pci id_table to {name}_pci_table.
    5) Add the static string {name} for the pci_driver.name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index ad4d2f66677f..56b111f3eccc 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -3315,20 +3315,20 @@ static void CountersInit(struct comedi_device *dev)
 
 }
 
-static struct comedi_driver driver_s626 = {
+static struct comedi_driver s626_driver = {
 	.driver_name	= "s626",
 	.module		= THIS_MODULE,
 	.attach		= s626_attach,
 	.detach		= s626_detach,
 };
 
-static int __devinit driver_s626_pci_probe(struct pci_dev *dev,
-					   const struct pci_device_id *ent)
+static int __devinit s626_pci_probe(struct pci_dev *dev,
+				    const struct pci_device_id *ent)
 {
-	return comedi_pci_auto_config(dev, &driver_s626);
+	return comedi_pci_auto_config(dev, &s626_driver);
 }
 
-static void __devexit driver_s626_pci_remove(struct pci_dev *dev)
+static void __devexit s626_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }
@@ -3345,31 +3345,13 @@ static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
 };
 MODULE_DEVICE_TABLE(pci, s626_pci_table);
 
-static struct pci_driver driver_s626_pci_driver = {
+static struct pci_driver s626_pci_driver = {
+	.name		= "s626",
 	.id_table	= s626_pci_table,
-	.probe		= driver_s626_pci_probe,
-	.remove		= __devexit_p(driver_s626_pci_remove),
+	.probe		= s626_pci_probe,
+	.remove		= __devexit_p(s626_pci_remove),
 };
-
-static int __init driver_s626_init_module(void)
-{
-	int retval;
-
-	retval = comedi_driver_register(&driver_s626);
-	if (retval < 0)
-		return retval;
-
-	driver_s626_pci_driver.name = (char *)driver_s626.driver_name;
-	return pci_register_driver(&driver_s626_pci_driver);
-}
-module_init(driver_s626_init_module);
-
-static void __exit driver_s626_cleanup_module(void)
-{
-	pci_unregister_driver(&driver_s626_pci_driver);
-	comedi_driver_unregister(&driver_s626);
-}
-module_exit(driver_s626_cleanup_module);
+module_comedi_pci_driver(s626_driver, s626_pci_driver);
 
 MODULE_AUTHOR("Gianluca Palli <gpalli@deis.unibo.it>");
 MODULE_DESCRIPTION("Sensoray 626 Comedi driver module");

commit 7122b76de9ac87be45e8de1041d81d9ea0bf9e48
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri May 4 14:37:36 2012 -0700

    staging: comedi: partial refactor of s626 driver to remove forward declarations
    
    Move the module_init/module_exit routines and the associated
    struct comedi_driver and other variables to the end of the source.
    This is more typical of how other drivers are written and removes
    the need for the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index a0b7c713367f..ad4d2f66677f 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -79,10 +79,6 @@ INSN_CONFIG instructions:
 #include "comedi_fc.h"
 #include "s626.h"
 
-MODULE_AUTHOR("Gianluca Palli <gpalli@deis.unibo.it>");
-MODULE_DESCRIPTION("Sensoray 626 Comedi driver module");
-MODULE_LICENSE("GPL");
-
 #define PCI_VENDOR_ID_S626 0x1131
 #define PCI_DEVICE_ID_S626 0x7146
 #define PCI_SUBVENDOR_ID_S626 0x6000
@@ -122,28 +118,6 @@ static const struct s626_board s626_boards[] = {
 
 #define thisboard ((const struct s626_board *)dev->board_ptr)
 
-/*
- * For devices with vendor:device id == 0x1131:0x7146 you must specify
- * also subvendor:subdevice ids, because otherwise it will conflict with
- * Philips SAA7146 media/dvb based cards.
- */
-static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
-	{PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626, PCI_SUBVENDOR_ID_S626, PCI_SUBDEVICE_ID_S626, 0, 0, 0},
-	{0}
-};
-
-MODULE_DEVICE_TABLE(pci, s626_pci_table);
-
-static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it);
-static int s626_detach(struct comedi_device *dev);
-
-static struct comedi_driver driver_s626 = {
-	.driver_name = "s626",
-	.module = THIS_MODULE,
-	.attach = s626_attach,
-	.detach = s626_detach,
-};
-
 struct s626_private {
 	struct pci_dev *pdev;
 	void *base_addr;
@@ -235,44 +209,6 @@ static struct dio_private *dio_private_word[]={
 #define devpriv ((struct s626_private *)dev->private)
 #define diopriv ((struct dio_private *)s->private)
 
-static int __devinit driver_s626_pci_probe(struct pci_dev *dev,
-					   const struct pci_device_id *ent)
-{
-	return comedi_pci_auto_config(dev, &driver_s626);
-}
-
-static void __devexit driver_s626_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
-static struct pci_driver driver_s626_pci_driver = {
-	.id_table = s626_pci_table,
-	.probe = &driver_s626_pci_probe,
-	.remove = __devexit_p(&driver_s626_pci_remove)
-};
-
-static int __init driver_s626_init_module(void)
-{
-	int retval;
-
-	retval = comedi_driver_register(&driver_s626);
-	if (retval < 0)
-		return retval;
-
-	driver_s626_pci_driver.name = (char *)driver_s626.driver_name;
-	return pci_register_driver(&driver_s626_pci_driver);
-}
-
-static void __exit driver_s626_cleanup_module(void)
-{
-	pci_unregister_driver(&driver_s626_pci_driver);
-	comedi_driver_unregister(&driver_s626);
-}
-
-module_init(driver_s626_init_module);
-module_exit(driver_s626_cleanup_module);
-
 /* ioctl routines */
 static int s626_ai_insn_config(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
@@ -3378,3 +3314,63 @@ static void CountersInit(struct comedi_device *dev)
 	DEBUG("CountersInit: counters initialized\n");
 
 }
+
+static struct comedi_driver driver_s626 = {
+	.driver_name	= "s626",
+	.module		= THIS_MODULE,
+	.attach		= s626_attach,
+	.detach		= s626_detach,
+};
+
+static int __devinit driver_s626_pci_probe(struct pci_dev *dev,
+					   const struct pci_device_id *ent)
+{
+	return comedi_pci_auto_config(dev, &driver_s626);
+}
+
+static void __devexit driver_s626_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+/*
+ * For devices with vendor:device id == 0x1131:0x7146 you must specify
+ * also subvendor:subdevice ids, because otherwise it will conflict with
+ * Philips SAA7146 media/dvb based cards.
+ */
+static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
+	{ PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626,
+		PCI_SUBVENDOR_ID_S626, PCI_SUBDEVICE_ID_S626, 0, 0, 0 },
+	{ 0 }
+};
+MODULE_DEVICE_TABLE(pci, s626_pci_table);
+
+static struct pci_driver driver_s626_pci_driver = {
+	.id_table	= s626_pci_table,
+	.probe		= driver_s626_pci_probe,
+	.remove		= __devexit_p(driver_s626_pci_remove),
+};
+
+static int __init driver_s626_init_module(void)
+{
+	int retval;
+
+	retval = comedi_driver_register(&driver_s626);
+	if (retval < 0)
+		return retval;
+
+	driver_s626_pci_driver.name = (char *)driver_s626.driver_name;
+	return pci_register_driver(&driver_s626_pci_driver);
+}
+module_init(driver_s626_init_module);
+
+static void __exit driver_s626_cleanup_module(void)
+{
+	pci_unregister_driver(&driver_s626_pci_driver);
+	comedi_driver_unregister(&driver_s626);
+}
+module_exit(driver_s626_cleanup_module);
+
+MODULE_AUTHOR("Gianluca Palli <gpalli@deis.unibo.it>");
+MODULE_DESCRIPTION("Sensoray 626 Comedi driver module");
+MODULE_LICENSE("GPL");

commit e17b8e484d429134b9693405e0f9b0936e007885
Author: Gerard Snitselaar <dev@snitselaar.org>
Date:   Mon Apr 23 18:30:06 2012 -0700

    staging: comedi: resolve section mismatch in s626
    
    s626_attach is referencing s626_pci_table which is annotated
    __devinitconst. Put pci vendor/device ids in the s626_board struct and
    use s626_boards instead similar to what is done in gsc_hpdi.
    
    v2: I had moved the PCI id defines to s626.h earlier, but later
    decided to leave them in s626.c and forgot to move them up above where
    they are being used in s626_boards.
    
    Signed-off-by: Gerard Snitselaar <dev@snitselaar.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 5e04d6ae25b8..a0b7c713367f 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -83,8 +83,17 @@ MODULE_AUTHOR("Gianluca Palli <gpalli@deis.unibo.it>");
 MODULE_DESCRIPTION("Sensoray 626 Comedi driver module");
 MODULE_LICENSE("GPL");
 
+#define PCI_VENDOR_ID_S626 0x1131
+#define PCI_DEVICE_ID_S626 0x7146
+#define PCI_SUBVENDOR_ID_S626 0x6000
+#define PCI_SUBDEVICE_ID_S626 0x0272
+
 struct s626_board {
 	const char *name;
+	int vendor_id;
+	int device_id;
+	int subvendor_id;
+	int subdevice_id;
 	int ai_chans;
 	int ai_bits;
 	int ao_chans;
@@ -97,6 +106,10 @@ struct s626_board {
 static const struct s626_board s626_boards[] = {
 	{
 	 .name = "s626",
+	 .vendor_id = PCI_VENDOR_ID_S626,
+	 .device_id = PCI_DEVICE_ID_S626,
+	 .subvendor_id = PCI_SUBVENDOR_ID_S626,
+	 .subdevice_id = PCI_SUBDEVICE_ID_S626,
 	 .ai_chans = S626_ADC_CHANNELS,
 	 .ai_bits = 14,
 	 .ao_chans = S626_DAC_CHANNELS,
@@ -108,8 +121,6 @@ static const struct s626_board s626_boards[] = {
 };
 
 #define thisboard ((const struct s626_board *)dev->board_ptr)
-#define PCI_VENDOR_ID_S626 0x1131
-#define PCI_DEVICE_ID_S626 0x7146
 
 /*
  * For devices with vendor:device id == 0x1131:0x7146 you must specify
@@ -117,7 +128,7 @@ static const struct s626_board s626_boards[] = {
  * Philips SAA7146 media/dvb based cards.
  */
 static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
-	{PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626, 0x6000, 0x0272, 0, 0, 0},
+	{PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626, PCI_SUBVENDOR_ID_S626, PCI_SUBDEVICE_ID_S626, 0, 0, 0},
 	{0}
 };
 
@@ -554,17 +565,17 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	resource_size_t resourceStart;
 	dma_addr_t appdma;
 	struct comedi_subdevice *s;
-	const struct pci_device_id *ids;
 	struct pci_dev *pdev = NULL;
 
 	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
 		return -ENOMEM;
 
-	for (i = 0; i < (ARRAY_SIZE(s626_pci_table) - 1) && !pdev; i++) {
-		ids = &s626_pci_table[i];
+	for (i = 0; i < ARRAY_SIZE(s626_boards) && !pdev; i++) {
 		do {
-			pdev = pci_get_subsys(ids->vendor, ids->device,
-					      ids->subvendor, ids->subdevice,
+			pdev = pci_get_subsys(s626_boards[i].vendor_id,
+					      s626_boards[i].device_id,
+					      s626_boards[i].subvendor_id,
+					      s626_boards[i].subdevice_id,
 					      pdev);
 
 			if ((it->options[0] || it->options[1]) && pdev) {

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 23fc64b9988e..5e04d6ae25b8 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -227,7 +227,7 @@ static struct dio_private *dio_private_word[]={
 static int __devinit driver_s626_pci_probe(struct pci_dev *dev,
 					   const struct pci_device_id *ent)
 {
-	return comedi_pci_auto_config(dev, driver_s626.driver_name);
+	return comedi_pci_auto_config(dev, &driver_s626);
 }
 
 static void __devexit driver_s626_pci_remove(struct pci_dev *dev)

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index d5ba3ab357a3..23fc64b9988e 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -139,7 +139,7 @@ struct s626_private {
 	int got_regions;
 	short allocatedBuf;
 	uint8_t ai_cmd_running;	/*  ai_cmd is running */
-	uint8_t ai_continous;	/*  continous aquisition */
+	uint8_t ai_continous;	/*  continous acquisition */
 	int ai_sample_count;	/*  number of samples to acquire */
 	unsigned int ai_sample_timer;
 	/*  time between samples in  units of the timer */
@@ -1048,7 +1048,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	uint8_t group;
 	uint16_t irqbit;
 
-	DEBUG("s626_irq_handler: interrupt request recieved!!!\n");
+	DEBUG("s626_irq_handler: interrupt request received!!!\n");
 
 	if (dev->attached == 0)
 		return IRQ_NONE;
@@ -1165,14 +1165,14 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 							(16 * group)))
 					    == 1 && cmd->start_src == TRIG_EXT) {
 						DEBUG
-						    ("s626_irq_handler: Edge capture interrupt recieved from channel %d\n",
+						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
 						     cmd->start_arg);
 
 						/*  Start executing the RPS program. */
 						MC_ENABLE(P_MC1, MC1_ERPS1);
 
 						DEBUG
-						    ("s626_irq_handler: aquisition start triggered!!!\n");
+						    ("s626_irq_handler: acquisition start triggered!!!\n");
 
 						if (cmd->scan_begin_src ==
 						    TRIG_EXT) {
@@ -1194,7 +1194,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 					    && cmd->scan_begin_src ==
 					    TRIG_EXT) {
 						DEBUG
-						    ("s626_irq_handler: Edge capture interrupt recieved from channel %d\n",
+						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
 						     cmd->scan_begin_arg);
 
 						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
@@ -1236,7 +1236,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 					    == 1
 					    && cmd->convert_src == TRIG_EXT) {
 						DEBUG
-						    ("s626_irq_handler: Edge capture interrupt recieved from channel %d\n",
+						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
 						     cmd->convert_arg);
 
 						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
@@ -1805,7 +1805,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		DEBUG("s626_ai_cmd: NULL command\n");
 		return -EINVAL;
 	} else {
-		DEBUG("s626_ai_cmd: command recieved!!!\n");
+		DEBUG("s626_ai_cmd: command received!!!\n");
 	}
 
 	if (dev->irq == 0) {
@@ -1880,7 +1880,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_continous = 0;
 		break;
 	case TRIG_NONE:
-		/*  continous aquisition */
+		/*  continous acquisition */
 		devpriv->ai_continous = 1;
 		devpriv->ai_sample_count = 0;
 		break;
@@ -2570,7 +2570,7 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY)
 		;
 
-	/*  Return non-zero if I2C error occured. */
+	/*  Return non-zero if I2C error occurred. */
 	return RR7146(P_I2CCTRL) & I2C_ERR;
 
 }

commit ae6eb75c63bcc21ffdb8c617a09d35b4a4ef11fe
Author: John Sheehan <john.d.sheehan@gmail.com>
Date:   Fri Jun 18 18:39:15 2010 +0100

    Staging: comedi: fix code warnings in s626.c
    
    A patch for s626.c to fix some of the warnings
    reported by the checkpatch.pl tool, namely,
    -suspect code indent for conditional statements
    -please, no space before tabs
    
    Signed-off-by: John Sheehan <john.d.sheehan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index b78d7adc8e4c..d5ba3ab357a3 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -816,7 +816,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		MC_ENABLE(P_MC2, MC2_UPLD_IIC);
 		/*  Invoke command  upload */
 		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)
-		    ;
+			;
 		/*  and wait for upload to complete. */
 
 		/* Per SAA7146 data sheet, write to STATUS reg twice to
@@ -826,7 +826,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			/*  Write I2C control: reset  error flags. */
 			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	/*  Invoke command upload */
 			while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
-			    ;
+				;
 			/* and wait for upload to complete. */
 		}
 
@@ -866,14 +866,14 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		 * not start up in a defined state after a PCI reset.
 		 */
 
-/*     PollList = EOPL;			// Create a simple polling */
-/* 					// list for analog input */
-/* 					// channel 0. */
+/*     PollList = EOPL;		// Create a simple polling */
+/*				// list for analog input */
+/*				// channel 0. */
 /*     ResetADC( dev, &PollList ); */
 
 /*     s626_ai_rinsn(dev,dev->subdevices,NULL,data); //( &AdcData ); // */
-/* 						  //Get initial ADC */
-/* 						  //value. */
+/*							//Get initial ADC */
+/*							//value. */
 
 /*     StartVal = data[0]; */
 
@@ -886,10 +886,10 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 /*     for ( index = 0; index < 500; index++ ) */
 /*       { */
-/* 	s626_ai_rinsn(dev,dev->subdevices,NULL,data); */
-/* 	AdcData = data[0];	//ReadADC(  &AdcData ); */
-/* 	if ( AdcData != StartVal ) */
-/* 	  break; */
+/*	s626_ai_rinsn(dev,dev->subdevices,NULL,data); */
+/*	AdcData = data[0];	//ReadADC(  &AdcData ); */
+/*	if ( AdcData != StartVal ) */
+/*		break; */
 /*       } */
 
 		/*  end initADC */
@@ -1690,7 +1690,7 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 
 		/*  Wait for ADC done. */
 		while (!(RR7146(P_PSR) & PSR_GPIO2))
-		    ;
+			;
 
 		/*  Fetch ADC data. */
 		if (n != 0)
@@ -1723,7 +1723,7 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 
 	/*  Wait for ADC done. */
 	while (!(RR7146(P_PSR) & PSR_GPIO2))
-	    ;
+		;
 
 	/*  Fetch ADC data from audio interface's input shift register. */
 
@@ -2564,11 +2564,11 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 
 	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
 	while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
-	    ;
+		;
 
 	/*  Wait until I2C bus transfer is finished or an error occurs. */
 	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY)
-	    ;
+		;
 
 	/*  Return non-zero if I2C error occured. */
 	return RR7146(P_I2CCTRL) & I2C_ERR;
@@ -2683,7 +2683,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * cleared when the transfer has finished.
 	 */
 	while ((RR7146(P_MC1) & MC1_A2OUT) != 0)
-	    ;
+		;
 
 	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
 
@@ -2701,7 +2701,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * to the output buffer register.
 	 */
 	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0)
-	    ;
+		;
 
 	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
 	 * back to slot 0 after executing the EOS in slot 5.  Also,
@@ -2738,7 +2738,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
 		 */
 		while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0)
-		    ;
+			;
 	}
 	/* Either (1) we were too late setting the slot 0 trap; the TSL
 	 * sequencer restarted slot 0 before we could set the EOS trap flag,
@@ -2755,7 +2755,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * from 0x00 to 0xFF.
 	 */
 	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0)
-	    ;
+		;
 }
 
 static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
@@ -2795,11 +2795,11 @@ static void DEBItransfer(struct comedi_device *dev)
 	/*  Wait for completion of upload from shadow RAM to DEBI control */
 	/*  register. */
 	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI))
-	    ;
+		;
 
 	/*  Wait until DEBI transfer is done. */
 	while (RR7146(P_PSR) & PSR_DEBI_S)
-	    ;
+		;
 }
 
 /*  Write a value to a gate array register. */
@@ -3157,7 +3157,7 @@ static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
 /*
  * static uint16_t GetLatchSource(struct comedi_device *dev, struct enc_private *k )
  * {
- * 	return ( DEBIread( dev, k->MyCRB) >> CRBBIT_LATCHSRC ) & 3;
+ *	return ( DEBIread( dev, k->MyCRB) >> CRBBIT_LATCHSRC ) & 3;
  * }
  */
 

commit add74595e500d0b008a48a898d0dbe99e648c64b
Author: John Sheehan <john.d.sheehan@gmail.com>
Date:   Fri Jun 18 18:38:01 2010 +0100

    Staging: comedi: fix code style errors in s626.c
    
    A patch for s626.c to fix errors reported by
    checkpatch.pl tool, namely,
    -code indent should use tabs where possible
    -"foo * bar" should be "foo *bar"
    -trailing statements should be on next line
    
    Signed-off-by: John Sheehan <john.d.sheehan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index f775ee6171ab..b78d7adc8e4c 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -60,10 +60,10 @@ INSN_CONFIG instructions:
    insn.insn=INSN_CONFIG;   //configuration instruction
    insn.n=1;                //number of operation (must be 1)
    insn.data=&initialvalue; //initial value loaded into encoder
-                            //during configuration
+				//during configuration
    insn.subdev=5;           //encoder subdevice
    insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); //encoder_channel
-                                                        //to configure
+							//to configure
 
    comedi_do_insn(cf,&insn); //executing configuration
 */
@@ -299,7 +299,7 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data);
 static int s626_ns_to_timer(int *nanosec, int round_mode);
-static int s626_ai_load_polllist(uint8_t * ppl, struct comedi_cmd *cmd);
+static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd);
 static int s626_ai_inttrig(struct comedi_device *dev,
 			   struct comedi_subdevice *s, unsigned int trignum);
 static irqreturn_t s626_irq_handler(int irq, void *d);
@@ -330,16 +330,16 @@ static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
 /*  COUNTER OBJECT ------------------------------------------------ */
 struct enc_private {
 	/*  Pointers to functions that differ for A and B counters: */
-	uint16_t(*GetEnable) (struct comedi_device * dev, struct enc_private *);	/* Return clock enable. */
-	uint16_t(*GetIntSrc) (struct comedi_device * dev, struct enc_private *);	/* Return interrupt source. */
-	uint16_t(*GetLoadTrig) (struct comedi_device * dev, struct enc_private *);	/* Return preload trigger source. */
-	uint16_t(*GetMode) (struct comedi_device * dev, struct enc_private *);	/* Return standardized operating mode. */
-	void (*PulseIndex) (struct comedi_device * dev, struct enc_private *);	/* Generate soft index strobe. */
-	void (*SetEnable) (struct comedi_device * dev, struct enc_private *, uint16_t enab);	/* Program clock enable. */
-	void (*SetIntSrc) (struct comedi_device * dev, struct enc_private *, uint16_t IntSource);	/* Program interrupt source. */
-	void (*SetLoadTrig) (struct comedi_device * dev, struct enc_private *, uint16_t Trig);	/* Program preload trigger source. */
-	void (*SetMode) (struct comedi_device * dev, struct enc_private *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
-	void (*ResetCapFlags) (struct comedi_device * dev, struct enc_private *);	/* Reset event capture flags. */
+	uint16_t(*GetEnable) (struct comedi_device *dev, struct enc_private *);	/* Return clock enable. */
+	uint16_t(*GetIntSrc) (struct comedi_device *dev, struct enc_private *);	/* Return interrupt source. */
+	uint16_t(*GetLoadTrig) (struct comedi_device *dev, struct enc_private *);	/* Return preload trigger source. */
+	uint16_t(*GetMode) (struct comedi_device *dev, struct enc_private *);	/* Return standardized operating mode. */
+	void (*PulseIndex) (struct comedi_device *dev, struct enc_private *);	/* Generate soft index strobe. */
+	void (*SetEnable) (struct comedi_device *dev, struct enc_private *, uint16_t enab);	/* Program clock enable. */
+	void (*SetIntSrc) (struct comedi_device *dev, struct enc_private *, uint16_t IntSource);	/* Program interrupt source. */
+	void (*SetLoadTrig) (struct comedi_device *dev, struct enc_private *, uint16_t Trig);	/* Program preload trigger source. */
+	void (*SetMode) (struct comedi_device *dev, struct enc_private *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
+	void (*ResetCapFlags) (struct comedi_device *dev, struct enc_private *);	/* Reset event capture flags. */
 
 	uint16_t MyCRA;		/*    Address of CRA register. */
 	uint16_t MyCRB;		/*    Address of CRB register. */
@@ -815,7 +815,8 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		/*  Write I2C control: abort any I2C activity. */
 		MC_ENABLE(P_MC2, MC2_UPLD_IIC);
 		/*  Invoke command  upload */
-		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0) ;
+		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)
+		    ;
 		/*  and wait for upload to complete. */
 
 		/* Per SAA7146 data sheet, write to STATUS reg twice to
@@ -824,7 +825,8 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			WR7146(P_I2CSTAT, I2C_CLKSEL);
 			/*  Write I2C control: reset  error flags. */
 			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	/*  Invoke command upload */
-			while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;
+			while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
+			    ;
 			/* and wait for upload to complete. */
 		}
 
@@ -1687,7 +1689,8 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 		/*  shift into FB BUFFER 1 register. */
 
 		/*  Wait for ADC done. */
-		while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
+		while (!(RR7146(P_PSR) & PSR_GPIO2))
+		    ;
 
 		/*  Fetch ADC data. */
 		if (n != 0)
@@ -1719,7 +1722,8 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	/*  Wait for the data to arrive in FB BUFFER 1 register. */
 
 	/*  Wait for ADC done. */
-	while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
+	while (!(RR7146(P_PSR) & PSR_GPIO2))
+	    ;
 
 	/*  Fetch ADC data from audio interface's input shift register. */
 
@@ -1732,7 +1736,7 @@ static int s626_ai_insn_read(struct comedi_device *dev,
 	return n;
 }
 
-static int s626_ai_load_polllist(uint8_t * ppl, struct comedi_cmd *cmd)
+static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)
 {
 
 	int n;
@@ -2461,8 +2465,7 @@ static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
 static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 
 /*  TrimDac LogicalChan-to-EepromAdrs mapping table. */
-static uint8_t trimadrs[] =
-    { 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
+static uint8_t trimadrs[] = { 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
 
 static void LoadTrimDACs(struct comedi_device *dev)
 {
@@ -2560,10 +2563,12 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 	/*  upload confirmation. */
 
 	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
-	while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;
+	while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
+	    ;
 
 	/*  Wait until I2C bus transfer is finished or an error occurs. */
-	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY) ;
+	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY)
+	    ;
 
 	/*  Return non-zero if I2C error occured. */
 	return RR7146(P_I2CCTRL) & I2C_ERR;
@@ -2677,7 +2682,8 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * Done by polling the DMAC enable flag; this flag is automatically
 	 * cleared when the transfer has finished.
 	 */
-	while ((RR7146(P_MC1) & MC1_A2OUT) != 0) ;
+	while ((RR7146(P_MC1) & MC1_A2OUT) != 0)
+	    ;
 
 	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
 
@@ -2694,7 +2700,8 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * finished transferring the DAC's data DWORD from the output FIFO
 	 * to the output buffer register.
 	 */
-	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0) ;
+	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0)
+	    ;
 
 	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
 	 * back to slot 0 after executing the EOS in slot 5.  Also,
@@ -2730,7 +2737,8 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
 		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
 		 */
-		while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) ;
+		while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0)
+		    ;
 	}
 	/* Either (1) we were too late setting the slot 0 trap; the TSL
 	 * sequencer restarted slot 0 before we could set the EOS trap flag,
@@ -2746,7 +2754,8 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
 	 * from 0x00 to 0xFF.
 	 */
-	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0) ;
+	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0)
+	    ;
 }
 
 static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
@@ -2785,10 +2794,12 @@ static void DEBItransfer(struct comedi_device *dev)
 
 	/*  Wait for completion of upload from shadow RAM to DEBI control */
 	/*  register. */
-	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI)) ;
+	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI))
+	    ;
 
 	/*  Wait until DEBI transfer is done. */
-	while (RR7146(P_PSR) & PSR_DEBI_S) ;
+	while (RR7146(P_PSR) & PSR_DEBI_S)
+	    ;
 }
 
 /*  Write a value to a gate array register. */

commit 727b286b44ea359d66f47d241cc2cdad36ed7bdc
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:31 2010 +0200

    Staging: comedi: Remove COMEDI_PCI_INITCLEANUP macro
    
    Move the PCI devinit/devexit routines to the respective C source files
    instead of calling COMEDI_PCI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index febb62e86ec3..f775ee6171ab 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -224,7 +224,43 @@ static struct dio_private *dio_private_word[]={
 #define devpriv ((struct s626_private *)dev->private)
 #define diopriv ((struct dio_private *)s->private)
 
-COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
+static int __devinit driver_s626_pci_probe(struct pci_dev *dev,
+					   const struct pci_device_id *ent)
+{
+	return comedi_pci_auto_config(dev, driver_s626.driver_name);
+}
+
+static void __devexit driver_s626_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static struct pci_driver driver_s626_pci_driver = {
+	.id_table = s626_pci_table,
+	.probe = &driver_s626_pci_probe,
+	.remove = __devexit_p(&driver_s626_pci_remove)
+};
+
+static int __init driver_s626_init_module(void)
+{
+	int retval;
+
+	retval = comedi_driver_register(&driver_s626);
+	if (retval < 0)
+		return retval;
+
+	driver_s626_pci_driver.name = (char *)driver_s626.driver_name;
+	return pci_register_driver(&driver_s626_pci_driver);
+}
+
+static void __exit driver_s626_cleanup_module(void)
+{
+	pci_unregister_driver(&driver_s626_pci_driver);
+	comedi_driver_unregister(&driver_s626);
+}
+
+module_init(driver_s626_init_module);
+module_exit(driver_s626_cleanup_module);
 
 /* ioctl routines */
 static int s626_ai_insn_config(struct comedi_device *dev,

commit daca497d8035cdb649b37ef1c962f1f0de8f16d9
Author: John Sheehan <john.d.sheehan@gmail.com>
Date:   Fri May 28 16:33:25 2010 +0100

    Staging: comedi: fix code warnings in s626.c
    
    A patch for s626.c to fix some of the warnings
    reported by the checkpatch.pl tool, namely,
    printk() should include KERN_ facility level
    unnecessary whitespace before a quoted newline
    
    Signed-off-by: John Sheehan <john.d.sheehan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index a3cc93362ec2..febb62e86ec3 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -543,13 +543,13 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->pdev = pdev;
 
 	if (pdev == NULL) {
-		printk("s626_attach: Board not present!!!\n");
+		printk(KERN_ERR "s626_attach: Board not present!!!\n");
 		return -ENODEV;
 	}
 
 	result = comedi_pci_enable(pdev, "s626");
 	if (result < 0) {
-		printk("s626_attach: comedi_pci_enable fails\n");
+		printk(KERN_ERR "s626_attach: comedi_pci_enable fails\n");
 		return -ENODEV;
 	}
 	devpriv->got_regions = 1;
@@ -558,7 +558,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	devpriv->base_addr = ioremap(resourceStart, SIZEOF_ADDRESS_SPACE);
 	if (devpriv->base_addr == NULL) {
-		printk("s626_attach: IOREMAP failed\n");
+		printk(KERN_ERR "s626_attach: IOREMAP failed\n");
 		return -ENODEV;
 	}
 
@@ -579,7 +579,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		    pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
 
 		if (devpriv->ANABuf.LogicalBase == NULL) {
-			printk("s626_attach: DMA Memory mapping error\n");
+			printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
 			return -ENOMEM;
 		}
 
@@ -596,7 +596,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		    pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
 
 		if (devpriv->RPSBuf.LogicalBase == NULL) {
-			printk("s626_attach: DMA Memory mapping error\n");
+			printk(KERN_ERR "s626_attach: DMA Memory mapping error\n");
 			return -ENOMEM;
 		}
 
@@ -622,18 +622,18 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* set up interrupt handler */
 	if (dev->irq == 0) {
-		printk(" unknown irq (bad)\n");
+		printk(KERN_ERR " unknown irq (bad)\n");
 	} else {
 		ret = request_irq(dev->irq, s626_irq_handler, IRQF_SHARED,
 				  "s626", dev);
 
 		if (ret < 0) {
-			printk(" irq not available\n");
+			printk(KERN_ERR " irq not available\n");
 			dev->irq = 0;
 		}
 	}
 
-	DEBUG("s626_attach: -- it opts  %d,%d -- \n",
+	DEBUG("s626_attach: -- it opts  %d,%d --\n",
 	      it->options[0], it->options[1]);
 
 	s = dev->subdevices + 0;
@@ -1513,7 +1513,7 @@ void ResetADC(struct comedi_device *dev, uint8_t * ppl)
 			break;	/*  Exit poll list processing loop. */
 		}
 	}
-	DEBUG("ResetADC: ADC items %d \n", devpriv->AdcItems);
+	DEBUG("ResetADC: ADC items %d\n", devpriv->AdcItems);
 
 	/* VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
 	 * ADC to stabilize for 2 microseconds before starting the final
@@ -1574,7 +1574,7 @@ static int s626_ai_insn_config(struct comedi_device *dev,
 /*   register uint8_t	i; */
 /*   register int32_t	*readaddr; */
 
-/*   DEBUG("as626_ai_rinsn: ai_rinsn enter \n");  */
+/*   DEBUG("as626_ai_rinsn: ai_rinsn enter\n");  */
 
 /*   Trigger ADC scan loop start by setting RPS Signal 0. */
 /*   MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
@@ -1591,11 +1591,11 @@ static int s626_ai_insn_config(struct comedi_device *dev,
 /*  Convert ADC data to 16-bit integer values and copy to application buffer. */
 /*   for ( i = 0; i < devpriv->AdcItems; i++ ) { */
 /*     *data = s626_ai_reg_to_uint( *readaddr++ ); */
-/*     DEBUG("s626_ai_rinsn: data %d \n",*data); */
+/*     DEBUG("s626_ai_rinsn: data %d\n",*data); */
 /*     data++; */
 /*   } */
 
-/*   DEBUG("s626_ai_rinsn: ai_rinsn escape \n"); */
+/*   DEBUG("s626_ai_rinsn: ai_rinsn escape\n"); */
 /*   return i; */
 /* } */
 
@@ -1743,7 +1743,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	DEBUG("s626_ai_cmd: entering command function\n");
 
 	if (devpriv->ai_cmd_running) {
-		printk("s626_ai_cmd: Another ai_cmd is running %d\n",
+		printk(KERN_ERR "s626_ai_cmd: Another ai_cmd is running %d\n",
 		       dev->minor);
 		return -EBUSY;
 	}
@@ -2147,7 +2147,7 @@ static void s626_dio_init(struct comedi_device *dev)
 		DEBIwrite(dev, diopriv->WRDOut, 0);	/*  Program all outputs */
 		/*  to inactive state. */
 	}
-	DEBUG("s626_dio_init: DIO initialized \n");
+	DEBUG("s626_dio_init: DIO initialized\n");
 }
 
 /* DIO devices are slightly special.  Although it is possible to
@@ -2346,7 +2346,7 @@ static int s626_enc_insn_read(struct comedi_device *dev,
 	int n;
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
-	DEBUG("s626_enc_insn_read: encoder read channel %d \n",
+	DEBUG("s626_enc_insn_read: encoder read channel %d\n",
 	      CR_CHAN(insn->chanspec));
 
 	for (n = 0; n < insn->n; n++)
@@ -2364,7 +2364,7 @@ static int s626_enc_insn_write(struct comedi_device *dev,
 
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
-	DEBUG("s626_enc_insn_write: encoder write channel %d \n",
+	DEBUG("s626_enc_insn_write: encoder write channel %d\n",
 	      CR_CHAN(insn->chanspec));
 
 	/*  Set the preload register */
@@ -3099,12 +3099,12 @@ static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k)
 static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
 			   uint16_t value)
 {
-	DEBUG("SetLatchSource: SetLatchSource enter 3550 \n");
+	DEBUG("SetLatchSource: SetLatchSource enter 3550\n");
 	DEBIreplace(dev, k->MyCRB,
 		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC)),
 		    (uint16_t) (value << CRBBIT_LATCHSRC));
 
-	DEBUG("SetLatchSource: SetLatchSource exit \n");
+	DEBUG("SetLatchSource: SetLatchSource exit\n");
 }
 
 /*
@@ -3317,6 +3317,6 @@ static void CountersInit(struct comedi_device *dev)
 		k->ResetCapFlags(dev, k);
 		k->SetEnable(dev, k, CLKENAB_ALWAYS);
 	}
-	DEBUG("CountersInit: counters initialized \n");
+	DEBUG("CountersInit: counters initialized\n");
 
 }

commit 9d220c6b54f3d0b141846321814ec1c4e4fbdc67
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Tue Jan 12 15:57:58 2010 +0100

    staging: fix typos "aquire" -> "acquire"
    
    This patch was generated by
    
        git grep -E -i -l '[Aa]quire' drivers/staging | xargs -r perl -p -i -e 's/([Aa])quire/$1cquire/'
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index fdd7ab954d8c..a3cc93362ec2 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -140,7 +140,7 @@ struct s626_private {
 	short allocatedBuf;
 	uint8_t ai_cmd_running;	/*  ai_cmd is running */
 	uint8_t ai_continous;	/*  continous aquisition */
-	int ai_sample_count;	/*  number of samples to aquire */
+	int ai_sample_count;	/*  number of samples to acquire */
 	unsigned int ai_sample_timer;
 	/*  time between samples in  units of the timer */
 	int ai_convert_count;	/*  conversion counter */

commit 828684f9a6e096f9150bad523c43b75d74b9badd
Author: Dirk Hohndel <hohndel@infradead.org>
Date:   Tue Sep 29 11:23:44 2009 +0200

    Staging: comedi: trivial fix of a very frequent spelling mistake
    
    something-bility is spelled as something-blity so a grep for 'blit'
    would find these lines
    
    this is so trivial that I didn't split it by subsystem / copy additional
    maintainers - all changes are to comments The only purpose is to get
    fewer false positives when grepping around the kernel sources.
    
    Signed-off-by: Dirk Hohndel <hohndel@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 80d2787d1063..fdd7ab954d8c 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1926,7 +1926,7 @@ static int s626_ai_cmdtest(struct comedi_device *dev,
 	/* step 2: make sure trigger sources are unique and mutually
 	   compatible */
 
-	/* note that mutual compatiblity is not an issue here */
+	/* note that mutual compatibility is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
 	    cmd->scan_begin_src != TRIG_EXT
 	    && cmd->scan_begin_src != TRIG_FOLLOW)

commit 4ff863b1db411481971de481002aa644057b1fa6
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Sat Aug 8 00:14:20 2009 +0200

    Staging: comedi: s626: Possible read buffer overflow fix
    
    If `cmd->chanlist_len' is 0, then we write ppl[-1].
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6549d116f2e6..80d2787d1063 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1707,7 +1707,8 @@ static int s626_ai_load_polllist(uint8_t * ppl, struct comedi_cmd *cmd)
 		else
 			ppl[n] = (CR_CHAN((cmd->chanlist)[n])) | (RANGE_10V);
 	}
-	ppl[n - 1] |= EOPL;
+	if (n != 0)
+		ppl[n - 1] |= EOPL;
 
 	return n;
 }

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 5d9bab352c1d..6549d116f2e6 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -96,15 +96,15 @@ struct s626_board {
 
 static const struct s626_board s626_boards[] = {
 	{
-	.name = "s626",
-	.ai_chans = S626_ADC_CHANNELS,
-	.ai_bits = 14,
-	.ao_chans = S626_DAC_CHANNELS,
-	.ao_bits = 13,
-	.dio_chans = S626_DIO_CHANNELS,
-	.dio_banks = S626_DIO_BANKS,
-	.enc_chans = S626_ENCODER_CHANNELS,
-		}
+	 .name = "s626",
+	 .ai_chans = S626_ADC_CHANNELS,
+	 .ai_bits = 14,
+	 .ao_chans = S626_DAC_CHANNELS,
+	 .ao_bits = 13,
+	 .dio_chans = S626_DIO_CHANNELS,
+	 .dio_banks = S626_DIO_BANKS,
+	 .enc_chans = S626_ENCODER_CHANNELS,
+	 }
 };
 
 #define thisboard ((const struct s626_board *)dev->board_ptr)
@@ -149,7 +149,7 @@ struct s626_private {
 	uint16_t CounterIntEnabs;
 	/* Counter interrupt enable  mask for MISC2 register. */
 	uint8_t AdcItems;	/* Number of items in ADC poll  list. */
-	struct bufferDMA RPSBuf;		/* DMA buffer used to hold ADC (RPS1) program. */
+	struct bufferDMA RPSBuf;	/* DMA buffer used to hold ADC (RPS1) program. */
 	struct bufferDMA ANABuf;
 	/* DMA buffer used to receive ADC data and hold DAC data. */
 	uint32_t *pDacWBuf;
@@ -227,37 +227,45 @@ static struct dio_private *dio_private_word[]={
 COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
 
 /* ioctl routines */
-static int s626_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int s626_ai_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 /* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data); */
-static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int s626_ai_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
 static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int s626_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int s626_ai_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd);
+static int s626_ai_cancel(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
 static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
 static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s626_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s626_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
+static int s626_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int s626_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
 static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan);
 static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int gruop,
-	unsigned int mask);
+			      unsigned int mask);
 static int s626_dio_clear_irq(struct comedi_device *dev);
-static int s626_enc_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s626_enc_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s626_enc_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int s626_enc_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
+static int s626_enc_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int s626_enc_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 static int s626_ns_to_timer(int *nanosec, int round_mode);
-static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd);
-static int s626_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum);
+static int s626_ai_load_polllist(uint8_t * ppl, struct comedi_cmd *cmd);
+static int s626_ai_inttrig(struct comedi_device *dev,
+			   struct comedi_subdevice *s, unsigned int trignum);
 static irqreturn_t s626_irq_handler(int irq, void *d);
 static unsigned int s626_ai_reg_to_uint(int data);
 /* static unsigned int s626_uint_to_reg(struct comedi_subdevice *s, int data); */
@@ -266,10 +274,10 @@ static unsigned int s626_ai_reg_to_uint(int data);
 
 /* internal routines */
 static void s626_dio_init(struct comedi_device *dev);
-static void ResetADC(struct comedi_device *dev, uint8_t *ppl);
+static void ResetADC(struct comedi_device *dev, uint8_t * ppl);
 static void LoadTrimDACs(struct comedi_device *dev);
 static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
-	uint8_t DacData);
+			 uint8_t DacData);
 static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr);
 static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val);
 static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata);
@@ -279,22 +287,23 @@ static void DEBItransfer(struct comedi_device *dev);
 static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr);
 static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata);
 static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
-	uint16_t wdata);
-static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma, size_t bsize);
+			uint16_t wdata);
+static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
+		      size_t bsize);
 
 /*  COUNTER OBJECT ------------------------------------------------ */
 struct enc_private {
 	/*  Pointers to functions that differ for A and B counters: */
-	uint16_t(*GetEnable) (struct comedi_device *dev, struct enc_private *);	/* Return clock enable. */
-	uint16_t(*GetIntSrc) (struct comedi_device *dev, struct enc_private *);	/* Return interrupt source. */
-	uint16_t(*GetLoadTrig) (struct comedi_device *dev, struct enc_private *);	/* Return preload trigger source. */
-	uint16_t(*GetMode) (struct comedi_device *dev, struct enc_private *);	/* Return standardized operating mode. */
-	void (*PulseIndex) (struct comedi_device *dev, struct enc_private *);	/* Generate soft index strobe. */
-	void (*SetEnable) (struct comedi_device *dev, struct enc_private *, uint16_t enab);	/* Program clock enable. */
-	void (*SetIntSrc) (struct comedi_device *dev, struct enc_private *, uint16_t IntSource);	/* Program interrupt source. */
-	void (*SetLoadTrig) (struct comedi_device *dev, struct enc_private *, uint16_t Trig);	/* Program preload trigger source. */
-	void (*SetMode) (struct comedi_device *dev, struct enc_private *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
-	void (*ResetCapFlags) (struct comedi_device *dev, struct enc_private *);	/* Reset event capture flags. */
+	uint16_t(*GetEnable) (struct comedi_device * dev, struct enc_private *);	/* Return clock enable. */
+	uint16_t(*GetIntSrc) (struct comedi_device * dev, struct enc_private *);	/* Return interrupt source. */
+	uint16_t(*GetLoadTrig) (struct comedi_device * dev, struct enc_private *);	/* Return preload trigger source. */
+	uint16_t(*GetMode) (struct comedi_device * dev, struct enc_private *);	/* Return standardized operating mode. */
+	void (*PulseIndex) (struct comedi_device * dev, struct enc_private *);	/* Generate soft index strobe. */
+	void (*SetEnable) (struct comedi_device * dev, struct enc_private *, uint16_t enab);	/* Program clock enable. */
+	void (*SetIntSrc) (struct comedi_device * dev, struct enc_private *, uint16_t IntSource);	/* Program interrupt source. */
+	void (*SetLoadTrig) (struct comedi_device * dev, struct enc_private *, uint16_t Trig);	/* Program preload trigger source. */
+	void (*SetMode) (struct comedi_device * dev, struct enc_private *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
+	void (*ResetCapFlags) (struct comedi_device * dev, struct enc_private *);	/* Reset event capture flags. */
 
 	uint16_t MyCRA;		/*    Address of CRA register. */
 	uint16_t MyCRB;		/*    Address of CRB register. */
@@ -306,31 +315,36 @@ struct enc_private {
 #define encpriv ((struct enc_private *)(dev->subdevices+5)->private)
 
 /* counters routines */
-static void s626_timer_load(struct comedi_device *dev, struct enc_private *k, int tick);
+static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
+			    int tick);
 static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k);
 static void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k);
 static void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k);
 static uint16_t GetMode_A(struct comedi_device *dev, struct enc_private *k);
 static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k);
-static void SetMode_A(struct comedi_device *dev, struct enc_private *k, uint16_t Setup,
-	uint16_t DisableIntSrc);
-static void SetMode_B(struct comedi_device *dev, struct enc_private *k, uint16_t Setup,
-	uint16_t DisableIntSrc);
-static void SetEnable_A(struct comedi_device *dev, struct enc_private *k, uint16_t enab);
-static void SetEnable_B(struct comedi_device *dev, struct enc_private *k, uint16_t enab);
+static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
+		      uint16_t Setup, uint16_t DisableIntSrc);
+static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
+		      uint16_t Setup, uint16_t DisableIntSrc);
+static void SetEnable_A(struct comedi_device *dev, struct enc_private *k,
+			uint16_t enab);
+static void SetEnable_B(struct comedi_device *dev, struct enc_private *k,
+			uint16_t enab);
 static uint16_t GetEnable_A(struct comedi_device *dev, struct enc_private *k);
 static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k);
 static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
-	uint16_t value);
+			   uint16_t value);
 /* static uint16_t GetLatchSource(struct comedi_device *dev, struct enc_private *k ); */
-static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k, uint16_t Trig);
-static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k, uint16_t Trig);
+static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t Trig);
+static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t Trig);
 static uint16_t GetLoadTrig_A(struct comedi_device *dev, struct enc_private *k);
 static uint16_t GetLoadTrig_B(struct comedi_device *dev, struct enc_private *k);
 static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
-	uint16_t IntSource);
+			uint16_t IntSource);
 static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
-	uint16_t IntSource);
+			uint16_t IntSource);
 static uint16_t GetIntSrc_A(struct comedi_device *dev, struct enc_private *k);
 static uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k);
 /* static void SetClkMult(struct comedi_device *dev, struct enc_private *k, uint16_t value ) ; */
@@ -343,7 +357,8 @@ static uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k);
 /* static uint16_t GetIndexSrc( struct comedi_device *dev,struct enc_private *k );  */
 static void PulseIndex_A(struct comedi_device *dev, struct enc_private *k);
 static void PulseIndex_B(struct comedi_device *dev, struct enc_private *k);
-static void Preload(struct comedi_device *dev, struct enc_private *k, uint32_t value);
+static void Preload(struct comedi_device *dev, struct enc_private *k,
+		    uint32_t value);
 static void CountersInit(struct comedi_device *dev);
 /* end internal routines */
 
@@ -360,101 +375,101 @@ static void CountersInit(struct comedi_device *dev);
 /* struct enc_private; */
 static struct enc_private enc_private_data[] = {
 	{
-	.GetEnable = GetEnable_A,
-	.GetIntSrc = GetIntSrc_A,
-	.GetLoadTrig = GetLoadTrig_A,
-	.GetMode = GetMode_A,
-	.PulseIndex = PulseIndex_A,
-	.SetEnable = SetEnable_A,
-	.SetIntSrc = SetIntSrc_A,
-	.SetLoadTrig = SetLoadTrig_A,
-	.SetMode = SetMode_A,
-	.ResetCapFlags = ResetCapFlags_A,
-	.MyCRA = LP_CR0A,
-	.MyCRB = LP_CR0B,
-	.MyLatchLsw = LP_CNTR0ALSW,
-	.MyEventBits = EVBITS(0),
-		},
+	 .GetEnable = GetEnable_A,
+	 .GetIntSrc = GetIntSrc_A,
+	 .GetLoadTrig = GetLoadTrig_A,
+	 .GetMode = GetMode_A,
+	 .PulseIndex = PulseIndex_A,
+	 .SetEnable = SetEnable_A,
+	 .SetIntSrc = SetIntSrc_A,
+	 .SetLoadTrig = SetLoadTrig_A,
+	 .SetMode = SetMode_A,
+	 .ResetCapFlags = ResetCapFlags_A,
+	 .MyCRA = LP_CR0A,
+	 .MyCRB = LP_CR0B,
+	 .MyLatchLsw = LP_CNTR0ALSW,
+	 .MyEventBits = EVBITS(0),
+	 },
 	{
-	.GetEnable = GetEnable_A,
-	.GetIntSrc = GetIntSrc_A,
-	.GetLoadTrig = GetLoadTrig_A,
-	.GetMode = GetMode_A,
-	.PulseIndex = PulseIndex_A,
-	.SetEnable = SetEnable_A,
-	.SetIntSrc = SetIntSrc_A,
-	.SetLoadTrig = SetLoadTrig_A,
-	.SetMode = SetMode_A,
-	.ResetCapFlags = ResetCapFlags_A,
-	.MyCRA = LP_CR1A,
-	.MyCRB = LP_CR1B,
-	.MyLatchLsw = LP_CNTR1ALSW,
-	.MyEventBits = EVBITS(1),
-		},
+	 .GetEnable = GetEnable_A,
+	 .GetIntSrc = GetIntSrc_A,
+	 .GetLoadTrig = GetLoadTrig_A,
+	 .GetMode = GetMode_A,
+	 .PulseIndex = PulseIndex_A,
+	 .SetEnable = SetEnable_A,
+	 .SetIntSrc = SetIntSrc_A,
+	 .SetLoadTrig = SetLoadTrig_A,
+	 .SetMode = SetMode_A,
+	 .ResetCapFlags = ResetCapFlags_A,
+	 .MyCRA = LP_CR1A,
+	 .MyCRB = LP_CR1B,
+	 .MyLatchLsw = LP_CNTR1ALSW,
+	 .MyEventBits = EVBITS(1),
+	 },
 	{
-	.GetEnable = GetEnable_A,
-	.GetIntSrc = GetIntSrc_A,
-	.GetLoadTrig = GetLoadTrig_A,
-	.GetMode = GetMode_A,
-	.PulseIndex = PulseIndex_A,
-	.SetEnable = SetEnable_A,
-	.SetIntSrc = SetIntSrc_A,
-	.SetLoadTrig = SetLoadTrig_A,
-	.SetMode = SetMode_A,
-	.ResetCapFlags = ResetCapFlags_A,
-	.MyCRA = LP_CR2A,
-	.MyCRB = LP_CR2B,
-	.MyLatchLsw = LP_CNTR2ALSW,
-	.MyEventBits = EVBITS(2),
-		},
+	 .GetEnable = GetEnable_A,
+	 .GetIntSrc = GetIntSrc_A,
+	 .GetLoadTrig = GetLoadTrig_A,
+	 .GetMode = GetMode_A,
+	 .PulseIndex = PulseIndex_A,
+	 .SetEnable = SetEnable_A,
+	 .SetIntSrc = SetIntSrc_A,
+	 .SetLoadTrig = SetLoadTrig_A,
+	 .SetMode = SetMode_A,
+	 .ResetCapFlags = ResetCapFlags_A,
+	 .MyCRA = LP_CR2A,
+	 .MyCRB = LP_CR2B,
+	 .MyLatchLsw = LP_CNTR2ALSW,
+	 .MyEventBits = EVBITS(2),
+	 },
 	{
-	.GetEnable = GetEnable_B,
-	.GetIntSrc = GetIntSrc_B,
-	.GetLoadTrig = GetLoadTrig_B,
-	.GetMode = GetMode_B,
-	.PulseIndex = PulseIndex_B,
-	.SetEnable = SetEnable_B,
-	.SetIntSrc = SetIntSrc_B,
-	.SetLoadTrig = SetLoadTrig_B,
-	.SetMode = SetMode_B,
-	.ResetCapFlags = ResetCapFlags_B,
-	.MyCRA = LP_CR0A,
-	.MyCRB = LP_CR0B,
-	.MyLatchLsw = LP_CNTR0BLSW,
-	.MyEventBits = EVBITS(3),
-		},
+	 .GetEnable = GetEnable_B,
+	 .GetIntSrc = GetIntSrc_B,
+	 .GetLoadTrig = GetLoadTrig_B,
+	 .GetMode = GetMode_B,
+	 .PulseIndex = PulseIndex_B,
+	 .SetEnable = SetEnable_B,
+	 .SetIntSrc = SetIntSrc_B,
+	 .SetLoadTrig = SetLoadTrig_B,
+	 .SetMode = SetMode_B,
+	 .ResetCapFlags = ResetCapFlags_B,
+	 .MyCRA = LP_CR0A,
+	 .MyCRB = LP_CR0B,
+	 .MyLatchLsw = LP_CNTR0BLSW,
+	 .MyEventBits = EVBITS(3),
+	 },
 	{
-	.GetEnable = GetEnable_B,
-	.GetIntSrc = GetIntSrc_B,
-	.GetLoadTrig = GetLoadTrig_B,
-	.GetMode = GetMode_B,
-	.PulseIndex = PulseIndex_B,
-	.SetEnable = SetEnable_B,
-	.SetIntSrc = SetIntSrc_B,
-	.SetLoadTrig = SetLoadTrig_B,
-	.SetMode = SetMode_B,
-	.ResetCapFlags = ResetCapFlags_B,
-	.MyCRA = LP_CR1A,
-	.MyCRB = LP_CR1B,
-	.MyLatchLsw = LP_CNTR1BLSW,
-	.MyEventBits = EVBITS(4),
-		},
+	 .GetEnable = GetEnable_B,
+	 .GetIntSrc = GetIntSrc_B,
+	 .GetLoadTrig = GetLoadTrig_B,
+	 .GetMode = GetMode_B,
+	 .PulseIndex = PulseIndex_B,
+	 .SetEnable = SetEnable_B,
+	 .SetIntSrc = SetIntSrc_B,
+	 .SetLoadTrig = SetLoadTrig_B,
+	 .SetMode = SetMode_B,
+	 .ResetCapFlags = ResetCapFlags_B,
+	 .MyCRA = LP_CR1A,
+	 .MyCRB = LP_CR1B,
+	 .MyLatchLsw = LP_CNTR1BLSW,
+	 .MyEventBits = EVBITS(4),
+	 },
 	{
-	.GetEnable = GetEnable_B,
-	.GetIntSrc = GetIntSrc_B,
-	.GetLoadTrig = GetLoadTrig_B,
-	.GetMode = GetMode_B,
-	.PulseIndex = PulseIndex_B,
-	.SetEnable = SetEnable_B,
-	.SetIntSrc = SetIntSrc_B,
-	.SetLoadTrig = SetLoadTrig_B,
-	.SetMode = SetMode_B,
-	.ResetCapFlags = ResetCapFlags_B,
-	.MyCRA = LP_CR2A,
-	.MyCRB = LP_CR2B,
-	.MyLatchLsw = LP_CNTR2BLSW,
-	.MyEventBits = EVBITS(5),
-		},
+	 .GetEnable = GetEnable_B,
+	 .GetIntSrc = GetIntSrc_B,
+	 .GetLoadTrig = GetLoadTrig_B,
+	 .GetMode = GetMode_B,
+	 .PulseIndex = PulseIndex_B,
+	 .SetEnable = SetEnable_B,
+	 .SetIntSrc = SetIntSrc_B,
+	 .SetLoadTrig = SetLoadTrig_B,
+	 .SetMode = SetMode_B,
+	 .ResetCapFlags = ResetCapFlags_B,
+	 .MyCRA = LP_CR2A,
+	 .MyCRB = LP_CR2B,
+	 .MyLatchLsw = LP_CNTR2BLSW,
+	 .MyEventBits = EVBITS(5),
+	 },
 };
 
 /*  enab/disable a function or test status bit(s) that are accessed */
@@ -485,9 +500,9 @@ static struct enc_private enc_private_data[] = {
 #define I2C_B0(ATTR, VAL)	(((ATTR) << 2) | ((VAL) <<  8))
 
 static const struct comedi_lrange s626_range_table = { 2, {
-			RANGE(-5, 5),
-			RANGE(-10, 10),
-	}
+							   RANGE(-5, 5),
+							   RANGE(-10, 10),
+							   }
 };
 
 static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -512,8 +527,9 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (i = 0; i < (ARRAY_SIZE(s626_pci_table) - 1) && !pdev; i++) {
 		ids = &s626_pci_table[i];
 		do {
-			pdev = pci_get_subsys(ids->vendor, ids->device, ids->subvendor,
-					      ids->subdevice, pdev);
+			pdev = pci_get_subsys(ids->vendor, ids->device,
+					      ids->subvendor, ids->subdevice,
+					      pdev);
 
 			if ((it->options[0] || it->options[1]) && pdev) {
 				/* matches requested bus/slot */
@@ -560,7 +576,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->allocatedBuf = 0;
 
 		devpriv->ANABuf.LogicalBase =
-			pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
+		    pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
 
 		if (devpriv->ANABuf.LogicalBase == NULL) {
 			printk("s626_attach: DMA Memory mapping error\n");
@@ -569,12 +585,15 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		devpriv->ANABuf.PhysicalBase = appdma;
 
-		DEBUG("s626_attach: AllocDMAB ADC Logical=%p, bsize=%d, Physical=0x%x\n", devpriv->ANABuf.LogicalBase, DMABUF_SIZE, (uint32_t) devpriv->ANABuf.PhysicalBase);
+		DEBUG
+		    ("s626_attach: AllocDMAB ADC Logical=%p, bsize=%d, Physical=0x%x\n",
+		     devpriv->ANABuf.LogicalBase, DMABUF_SIZE,
+		     (uint32_t) devpriv->ANABuf.PhysicalBase);
 
 		devpriv->allocatedBuf++;
 
 		devpriv->RPSBuf.LogicalBase =
-			pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE,  &appdma);
+		    pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
 
 		if (devpriv->RPSBuf.LogicalBase == NULL) {
 			printk("s626_attach: DMA Memory mapping error\n");
@@ -583,7 +602,10 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		devpriv->RPSBuf.PhysicalBase = appdma;
 
-		DEBUG("s626_attach: AllocDMAB RPS Logical=%p, bsize=%d, Physical=0x%x\n", devpriv->RPSBuf.LogicalBase, DMABUF_SIZE, (uint32_t) devpriv->RPSBuf.PhysicalBase);
+		DEBUG
+		    ("s626_attach: AllocDMAB RPS Logical=%p, bsize=%d, Physical=0x%x\n",
+		     devpriv->RPSBuf.LogicalBase, DMABUF_SIZE,
+		     (uint32_t) devpriv->RPSBuf.PhysicalBase);
 
 		devpriv->allocatedBuf++;
 
@@ -612,7 +634,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	DEBUG("s626_attach: -- it opts  %d,%d -- \n",
-		it->options[0], it->options[1]);
+	      it->options[0], it->options[1]);
 
 	s = dev->subdevices + 0;
 	/* analog input subdevice */
@@ -701,20 +723,22 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		MC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);
 		/*  Configure DEBI operating mode. */
 		WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	/*  Local bus is 16 */
-			/*  bits wide. */
-			| (DEBI_TOUT << DEBI_CFG_TOUT_BIT)	/*  Declare DEBI */
-			/*  transfer timeout */
-			/*  interval. */
-			| DEBI_SWAP	/*  Set up byte lane */
-			/*  steering. */
-			| DEBI_CFG_INTEL);	/*  Intel-compatible */
+		       /*  bits wide. */
+		       | (DEBI_TOUT << DEBI_CFG_TOUT_BIT)
+
+		       /*  Declare DEBI */
+		       /*  transfer timeout */
+		       /*  interval. */
+		       |DEBI_SWAP	/*  Set up byte lane */
+		       /*  steering. */
+		       | DEBI_CFG_INTEL);	/*  Intel-compatible */
 		/*  local bus (DEBI */
 		/*  never times out). */
 		DEBUG("s626_attach: %d debi init -- %d\n",
-			DEBI_CFG_SLAVE16 | (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
-			DEBI_SWAP | DEBI_CFG_INTEL,
-			DEBI_CFG_INTEL | DEBI_CFG_TOQ | DEBI_CFG_INCQ |
-			DEBI_CFG_16Q);
+		      DEBI_CFG_SLAVE16 | (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
+		      DEBI_SWAP | DEBI_CFG_INTEL,
+		      DEBI_CFG_INTEL | DEBI_CFG_TOQ | DEBI_CFG_INCQ |
+		      DEBI_CFG_16Q);
 
 		/* DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ */
 		/* | DEBI_CFG_INCQ| DEBI_CFG_16Q); //end */
@@ -725,22 +749,22 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		/*  Init GPIO so that ADC Start* is negated. */
 		WR7146(P_GPIO, GPIO_BASE | GPIO1_HI);
 
-    /* IsBoardRevA is a boolean that indicates whether the board is RevA.
-     *
-     * VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
-     * EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
-     * is used to access the onboard serial EEPROM.  The EEPROM's I2C
-     * DeviceAddress is hardwired to a value that is dependent on the
-     * 626 board revision.  On all board revisions, the EEPROM stores
-     * TrimDAC calibration constants for analog I/O.  On RevB and
-     * higher boards, the DeviceAddress is hardwired to 0 to enable
-     * the EEPROM to also store the PCI SubVendorID and SubDeviceID;
-     * this is the address at which the SAA7146 expects a
-     * configuration EEPROM to reside.  On RevA boards, the EEPROM
-     * device address, which is hardwired to 4, prevents the SAA7146
-     * from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
-     * default values, instead.
-     */
+		/* IsBoardRevA is a boolean that indicates whether the board is RevA.
+		 *
+		 * VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
+		 * EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
+		 * is used to access the onboard serial EEPROM.  The EEPROM's I2C
+		 * DeviceAddress is hardwired to a value that is dependent on the
+		 * 626 board revision.  On all board revisions, the EEPROM stores
+		 * TrimDAC calibration constants for analog I/O.  On RevB and
+		 * higher boards, the DeviceAddress is hardwired to 0 to enable
+		 * the EEPROM to also store the PCI SubVendorID and SubDeviceID;
+		 * this is the address at which the SAA7146 expects a
+		 * configuration EEPROM to reside.  On RevA boards, the EEPROM
+		 * device address, which is hardwired to 4, prevents the SAA7146
+		 * from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
+		 * default values, instead.
+		 */
 
 		/*     devpriv->I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM */
 		/*  DeviceType (0xA0) */
@@ -755,8 +779,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		/*  Write I2C control: abort any I2C activity. */
 		MC_ENABLE(P_MC2, MC2_UPLD_IIC);
 		/*  Invoke command  upload */
-		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)
-			;
+		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0) ;
 		/*  and wait for upload to complete. */
 
 		/* Per SAA7146 data sheet, write to STATUS reg twice to
@@ -765,8 +788,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			WR7146(P_I2CSTAT, I2C_CLKSEL);
 			/*  Write I2C control: reset  error flags. */
 			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	/*  Invoke command upload */
-			while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
-				;
+			while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;
 			/* and wait for upload to complete. */
 		}
 
@@ -847,8 +869,8 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		 * enabled. */
 
 		pPhysBuf =
-			devpriv->ANABuf.PhysicalBase +
-			(DAC_WDMABUF_OS * sizeof(uint32_t));
+		    devpriv->ANABuf.PhysicalBase +
+		    (DAC_WDMABUF_OS * sizeof(uint32_t));
 
 		WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	/*  Buffer base adrs. */
 		WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	/*  Protection address. */
@@ -856,8 +878,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		/* Cache Audio2's output DMA buffer logical address.  This is
 		 * where DAC data is buffered for A2 output DMA transfers. */
 		devpriv->pDacWBuf =
-			(uint32_t *) devpriv->ANABuf.LogicalBase +
-			DAC_WDMABUF_OS;
+		    (uint32_t *) devpriv->ANABuf.LogicalBase + DAC_WDMABUF_OS;
 
 		/* Audio2's output channels does not use paging.  The protection
 		 * violation handling bit is set so that the DMAC will
@@ -942,7 +963,8 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		 * charger, and reset the watchdog interval selector to zero.
 		 */
 		WriteMISC2(dev, (uint16_t) (DEBIread(dev,
-					LP_RDMISC2) & MISC2_BATT_ENABLE));
+						     LP_RDMISC2) &
+					    MISC2_BATT_ENABLE));
 
 		/*  Initialize the digital I/O subsystem. */
 		s626_dio_init(dev);
@@ -952,7 +974,7 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	DEBUG("s626_attach: comedi%d s626 attached %04x\n", dev->minor,
-		(uint32_t) devpriv->base_addr);
+	      (uint32_t) devpriv->base_addr);
 
 	return 1;
 }
@@ -1035,10 +1057,11 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 			/* put data into read buffer */
 			/*  comedi_buf_put(s->async, tempdata); */
 			if (cfc_write_to_buffer(s, tempdata) == 0)
-				printk("s626_irq_handler: cfc_write_to_buffer error!\n");
+				printk
+				    ("s626_irq_handler: cfc_write_to_buffer error!\n");
 
 			DEBUG("s626_irq_handler: ai channel %d acquired: %d\n",
-				i, tempdata);
+			      i, tempdata);
 		}
 
 		/* end of scan occurs */
@@ -1060,7 +1083,9 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 		}
 
 		if (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT) {
-			DEBUG("s626_irq_handler: enable interrupt on dio channel %d\n", cmd->scan_begin_arg);
+			DEBUG
+			    ("s626_irq_handler: enable interrupt on dio channel %d\n",
+			     cmd->scan_begin_arg);
 
 			s626_dio_set_irq(dev, cmd->scan_begin_arg);
 
@@ -1084,102 +1109,120 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 			irqbit = 0;
 			/* read interrupt type */
 			irqbit = DEBIread(dev,
-				((struct dio_private *) (dev->subdevices + 2 +
-						group)->private)->RDCapFlg);
+					  ((struct dio_private *)(dev->
+								  subdevices +
+								  2 +
+								  group)->
+					   private)->RDCapFlg);
 
 			/* check if interrupt is generated from dio channels */
 			if (irqbit) {
 				s626_dio_reset_irq(dev, group, irqbit);
-				DEBUG("s626_irq_handler: check interrupt on dio group %d %d\n", group, i);
+				DEBUG
+				    ("s626_irq_handler: check interrupt on dio group %d %d\n",
+				     group, i);
 				if (devpriv->ai_cmd_running) {
 					/* check if interrupt is an ai acquisition start trigger */
 					if ((irqbit >> (cmd->start_arg -
-								(16 * group)))
-						== 1
-						&& cmd->start_src == TRIG_EXT) {
-						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->start_arg);
+							(16 * group)))
+					    == 1 && cmd->start_src == TRIG_EXT) {
+						DEBUG
+						    ("s626_irq_handler: Edge capture interrupt recieved from channel %d\n",
+						     cmd->start_arg);
 
 						/*  Start executing the RPS program. */
 						MC_ENABLE(P_MC1, MC1_ERPS1);
 
-						DEBUG("s626_irq_handler: aquisition start triggered!!!\n");
+						DEBUG
+						    ("s626_irq_handler: aquisition start triggered!!!\n");
 
 						if (cmd->scan_begin_src ==
-							TRIG_EXT) {
-							DEBUG("s626_ai_cmd: enable interrupt on dio channel %d\n", cmd->scan_begin_arg);
+						    TRIG_EXT) {
+							DEBUG
+							    ("s626_ai_cmd: enable interrupt on dio channel %d\n",
+							     cmd->
+							     scan_begin_arg);
 
 							s626_dio_set_irq(dev,
-								cmd->
-								scan_begin_arg);
+									 cmd->scan_begin_arg);
 
-							DEBUG("s626_irq_handler: External scan trigger is set!!!\n");
+							DEBUG
+							    ("s626_irq_handler: External scan trigger is set!!!\n");
 						}
 					}
 					if ((irqbit >> (cmd->scan_begin_arg -
-								(16 * group)))
-						== 1
-						&& cmd->scan_begin_src ==
-						TRIG_EXT) {
-						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->scan_begin_arg);
+							(16 * group)))
+					    == 1
+					    && cmd->scan_begin_src ==
+					    TRIG_EXT) {
+						DEBUG
+						    ("s626_irq_handler: Edge capture interrupt recieved from channel %d\n",
+						     cmd->scan_begin_arg);
 
 						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
-						DEBUG("s626_irq_handler: scan triggered!!! %d\n", devpriv->ai_sample_count);
+						DEBUG
+						    ("s626_irq_handler: scan triggered!!! %d\n",
+						     devpriv->ai_sample_count);
 						if (cmd->convert_src ==
-							TRIG_EXT) {
+						    TRIG_EXT) {
 
-							DEBUG("s626_ai_cmd: enable interrupt on dio channel %d group %d\n", cmd->convert_arg - (16 * group), group);
+							DEBUG
+							    ("s626_ai_cmd: enable interrupt on dio channel %d group %d\n",
+							     cmd->convert_arg -
+							     (16 * group),
+							     group);
 
-							devpriv->
-								ai_convert_count
-								=
-								cmd->
-								chanlist_len;
+							devpriv->ai_convert_count
+							    = cmd->chanlist_len;
 
 							s626_dio_set_irq(dev,
-								cmd->
-								convert_arg);
+									 cmd->convert_arg);
 
-							DEBUG("s626_irq_handler: External convert trigger is set!!!\n");
+							DEBUG
+							    ("s626_irq_handler: External convert trigger is set!!!\n");
 						}
 
 						if (cmd->convert_src ==
-							TRIG_TIMER) {
+						    TRIG_TIMER) {
 							k = &encpriv[5];
-							devpriv->
-								ai_convert_count
-								=
-								cmd->
-								chanlist_len;
+							devpriv->ai_convert_count
+							    = cmd->chanlist_len;
 							k->SetEnable(dev, k,
-								CLKENAB_ALWAYS);
+								     CLKENAB_ALWAYS);
 						}
 					}
 					if ((irqbit >> (cmd->convert_arg -
-								(16 * group)))
-						== 1
-						&& cmd->convert_src ==
-						TRIG_EXT) {
-						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->convert_arg);
+							(16 * group)))
+					    == 1
+					    && cmd->convert_src == TRIG_EXT) {
+						DEBUG
+						    ("s626_irq_handler: Edge capture interrupt recieved from channel %d\n",
+						     cmd->convert_arg);
 
 						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
-						DEBUG("s626_irq_handler: adc convert triggered!!!\n");
+						DEBUG
+						    ("s626_irq_handler: adc convert triggered!!!\n");
 
 						devpriv->ai_convert_count--;
 
 						if (devpriv->ai_convert_count >
-							0) {
+						    0) {
 
-							DEBUG("s626_ai_cmd: enable interrupt on dio channel %d group %d\n", cmd->convert_arg - (16 * group), group);
+							DEBUG
+							    ("s626_ai_cmd: enable interrupt on dio channel %d group %d\n",
+							     cmd->convert_arg -
+							     (16 * group),
+							     group);
 
 							s626_dio_set_irq(dev,
-								cmd->
-								convert_arg);
+									 cmd->convert_arg);
 
-							DEBUG("s626_irq_handler: External trigger is set!!!\n");
+							DEBUG
+							    ("s626_irq_handler: External trigger is set!!!\n");
 						}
 					}
 				}
@@ -1192,38 +1235,43 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 
 		/* check interrupt on counters */
 		DEBUG("s626_irq_handler: check counters interrupt %d\n",
-			irqbit);
+		      irqbit);
 
 		if (irqbit & IRQ_COINT1A) {
-			DEBUG("s626_irq_handler: interrupt on counter 1A overflow\n");
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 1A overflow\n");
 			k = &encpriv[0];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT2A) {
-			DEBUG("s626_irq_handler: interrupt on counter 2A overflow\n");
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 2A overflow\n");
 			k = &encpriv[1];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT3A) {
-			DEBUG("s626_irq_handler: interrupt on counter 3A overflow\n");
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 3A overflow\n");
 			k = &encpriv[2];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT1B) {
-			DEBUG("s626_irq_handler: interrupt on counter 1B overflow\n");
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 1B overflow\n");
 			k = &encpriv[3];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT2B) {
-			DEBUG("s626_irq_handler: interrupt on counter 2B overflow\n");
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 2B overflow\n");
 			k = &encpriv[4];
 
 			/* clear interrupt capture flag */
@@ -1235,7 +1283,9 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 					k->SetEnable(dev, k, CLKENAB_INDEX);
 
 				if (cmd->convert_src == TRIG_TIMER) {
-					DEBUG("s626_irq_handler: conver timer trigger!!! %d\n", devpriv->ai_convert_count);
+					DEBUG
+					    ("s626_irq_handler: conver timer trigger!!! %d\n",
+					     devpriv->ai_convert_count);
 
 					/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 					MC_ENABLE(P_MC2, MC2_ADC_RPS);
@@ -1243,21 +1293,24 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 			}
 		}
 		if (irqbit & IRQ_COINT3B) {
-			DEBUG("s626_irq_handler: interrupt on counter 3B overflow\n");
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 3B overflow\n");
 			k = &encpriv[5];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 
 			if (cmd->scan_begin_src == TRIG_TIMER) {
-				DEBUG("s626_irq_handler: scan timer trigger!!!\n");
+				DEBUG
+				    ("s626_irq_handler: scan timer trigger!!!\n");
 
 				/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 				MC_ENABLE(P_MC2, MC2_ADC_RPS);
 			}
 
 			if (cmd->convert_src == TRIG_TIMER) {
-				DEBUG("s626_irq_handler: convert timer trigger is set\n");
+				DEBUG
+				    ("s626_irq_handler: convert timer trigger is set\n");
 				k = &encpriv[4];
 				devpriv->ai_convert_count = cmd->chanlist_len;
 				k->SetEnable(dev, k, CLKENAB_ALWAYS);
@@ -1317,7 +1370,7 @@ static int s626_detach(struct comedi_device *dev)
 /*
  * this functions build the RPS program for hardware driven acquistion
  */
-void ResetADC(struct comedi_device *dev, uint8_t *ppl)
+void ResetADC(struct comedi_device *dev, uint8_t * ppl)
 {
 	register uint32_t *pRPS;
 	uint32_t JmpAdrs;
@@ -1371,14 +1424,14 @@ void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 	 * forgot to set the EOPL flag in the final slot.
 	 */
 	for (devpriv->AdcItems = 0; devpriv->AdcItems < 16; devpriv->AdcItems++) {
-	 /* Convert application's poll list item to private board class
-	  * format.  Each app poll list item is an uint8_t with form
-	  * (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
-	  * +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
-	  */
+		/* Convert application's poll list item to private board class
+		 * format.  Each app poll list item is an uint8_t with form
+		 * (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
+		 * +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
+		 */
 		LocalPPL =
-			(*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
-			GSEL_BIPOLAR10V);
+		    (*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
+				   GSEL_BIPOLAR10V);
 
 		/*  Switch ADC analog gain. */
 		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	/*  Write DEBI command */
@@ -1418,9 +1471,9 @@ void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 		 * instruction prefetch pipeline.
 		 */
 		JmpAdrs =
-			(uint32_t) devpriv->RPSBuf.PhysicalBase +
-			(uint32_t) ((unsigned long)pRPS -
-			(unsigned long)devpriv->RPSBuf.LogicalBase);
+		    (uint32_t) devpriv->RPSBuf.PhysicalBase +
+		    (uint32_t) ((unsigned long)pRPS -
+				(unsigned long)devpriv->RPSBuf.LogicalBase);
 		for (i = 0; i < (10 * RPSCLK_PER_US / 2); i++) {
 			JmpAdrs += 8;	/*  Repeat to implement time delay: */
 			*pRPS++ = RPS_JUMP;	/*  Jump to next RPS instruction. */
@@ -1450,8 +1503,8 @@ void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 		/*  Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
 		*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
 		*pRPS++ =
-			(uint32_t) devpriv->ANABuf.PhysicalBase +
-			(devpriv->AdcItems << 2);
+		    (uint32_t) devpriv->ANABuf.PhysicalBase +
+		    (devpriv->AdcItems << 2);
 
 		/*  If this slot's EndOfPollList flag is set, all channels have */
 		/*  now been processed. */
@@ -1490,8 +1543,7 @@ void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 	/*  Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
 	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);	/*  */
 	*pRPS++ =
-		(uint32_t) devpriv->ANABuf.PhysicalBase +
-		(devpriv->AdcItems << 2);
+	    (uint32_t) devpriv->ANABuf.PhysicalBase + (devpriv->AdcItems << 2);
 
 	/*  Indicate ADC scan loop is finished. */
 	/*  *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC ;  // Signal ReadADC() that scan is done. */
@@ -1509,8 +1561,9 @@ void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 }
 
 /* TO COMPLETE, IF NECESSARY */
-static int s626_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_ai_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 
 	return -EINVAL;
@@ -1546,8 +1599,9 @@ static int s626_ai_insn_config(struct comedi_device *dev, struct comedi_subdevic
 /*   return i; */
 /* } */
 
-static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_ai_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	uint16_t chan = CR_CHAN(insn->chanspec);
 	uint16_t range = CR_RANGE(insn->chanspec);
@@ -1555,7 +1609,7 @@ static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice
 	uint32_t GpioImage;
 	int n;
 
- /* interrupt call test  */
+	/* interrupt call test  */
 /*   writel(IRQ_GPIO3,devpriv->base_addr+P_PSR); */
 	/* Writing a logical 1 into any of the RPS_PSR bits causes the
 	 * corresponding interrupt to be generated if enabled
@@ -1597,8 +1651,7 @@ static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice
 		/*  shift into FB BUFFER 1 register. */
 
 		/*  Wait for ADC done. */
-		while (!(RR7146(P_PSR) & PSR_GPIO2))
-			;
+		while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
 
 		/*  Fetch ADC data. */
 		if (n != 0)
@@ -1630,8 +1683,7 @@ static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice
 	/*  Wait for the data to arrive in FB BUFFER 1 register. */
 
 	/*  Wait for ADC done. */
-	while (!(RR7146(P_PSR) & PSR_GPIO2))
-		;
+	while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
 
 	/*  Fetch ADC data from audio interface's input shift register. */
 
@@ -1644,7 +1696,7 @@ static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice
 	return n;
 }
 
-static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)
+static int s626_ai_load_polllist(uint8_t * ppl, struct comedi_cmd *cmd)
 {
 
 	int n;
@@ -1660,8 +1712,8 @@ static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)
 	return n;
 }
 
-static int s626_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+static int s626_ai_inttrig(struct comedi_device *dev,
+			   struct comedi_subdevice *s, unsigned int trignum)
 {
 	if (trignum != 0)
 		return -EINVAL;
@@ -1691,7 +1743,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (devpriv->ai_cmd_running) {
 		printk("s626_ai_cmd: Another ai_cmd is running %d\n",
-			dev->minor);
+		       dev->minor);
 		return -EBUSY;
 	}
 	/* disable interrupt */
@@ -1717,7 +1769,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (dev->irq == 0) {
 		comedi_error(dev,
-			"s626_ai_cmd: cannot run command without an irq");
+			     "s626_ai_cmd: cannot run command without an irq");
 		return -EIO;
 	}
 
@@ -1732,14 +1784,14 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/*  set a conter to generate adc trigger at scan_begin_arg interval */
 		k = &encpriv[5];
 		tick = s626_ns_to_timer((int *)&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					cmd->flags & TRIG_ROUND_MASK);
 
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
 		k->SetEnable(dev, k, CLKENAB_ALWAYS);
 
 		DEBUG("s626_ai_cmd: scan trigger timer is set with value %d\n",
-			tick);
+		      tick);
 
 		break;
 	case TRIG_EXT:
@@ -1759,18 +1811,20 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/*  set a conter to generate adc trigger at convert_arg interval */
 		k = &encpriv[4];
 		tick = s626_ns_to_timer((int *)&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					cmd->flags & TRIG_ROUND_MASK);
 
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
 		k->SetEnable(dev, k, CLKENAB_INDEX);
 
-		DEBUG("s626_ai_cmd: convert trigger timer is set with value %d\n", tick);
+		DEBUG
+		    ("s626_ai_cmd: convert trigger timer is set with value %d\n",
+		     tick);
 		break;
 	case TRIG_EXT:
 		/*  set the digital line and interrupt for convert trigger */
 		if (cmd->scan_begin_src != TRIG_EXT
-			&& cmd->start_src == TRIG_EXT)
+		    && cmd->start_src == TRIG_EXT)
 			s626_dio_set_irq(dev, cmd->convert_arg);
 
 		DEBUG("s626_ai_cmd: External convert trigger is set!!!\n");
@@ -1825,8 +1879,8 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int s626_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int s626_ai_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1873,11 +1927,11 @@ static int s626_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s
 
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT
-		&& cmd->scan_begin_src != TRIG_FOLLOW)
+	    cmd->scan_begin_src != TRIG_EXT
+	    && cmd->scan_begin_src != TRIG_FOLLOW)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -1970,21 +2024,21 @@ static int s626_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		s626_ns_to_timer((int *)&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				 cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		s626_ns_to_timer((int *)&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				 cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 		if (cmd->scan_begin_src == TRIG_TIMER &&
-			cmd->scan_begin_arg <
-			cmd->convert_arg * cmd->scan_end_arg) {
+		    cmd->scan_begin_arg <
+		    cmd->convert_arg * cmd->scan_end_arg) {
 			cmd->scan_begin_arg =
-				cmd->convert_arg * cmd->scan_end_arg;
+			    cmd->convert_arg * cmd->scan_end_arg;
 			err++;
 		}
 	}
@@ -2037,7 +2091,7 @@ static int s626_ns_to_timer(int *nanosec, int round_mode)
 }
 
 static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 
 	int i;
@@ -2056,7 +2110,7 @@ static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 
@@ -2101,8 +2155,9 @@ static void s626_dio_init(struct comedi_device *dev)
  * This allows packed reading/writing of the DIO channels.  The comedi
  * core can convert between insn_bits and insn_read/write */
 
-static int s626_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 
 	/* Length of data must be 2 (mask and new data, see below) */
@@ -2110,7 +2165,9 @@ static int s626_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice
 		return 0;
 
 	if (insn->n != 2) {
-		printk("comedi%d: s626: s626_dio_insn_bits(): Invalid instruction length\n", dev->minor);
+		printk
+		    ("comedi%d: s626: s626_dio_insn_bits(): Invalid instruction length\n",
+		     dev->minor);
 		return -EINVAL;
 	}
 
@@ -2137,16 +2194,17 @@ static int s626_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice
 	return 2;
 }
 
-static int s626_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->io_bits & (1 << CR_CHAN(insn->
-					chanspec))) ? COMEDI_OUTPUT :
-			COMEDI_INPUT;
+		    (s->
+		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
+		    COMEDI_INPUT;
 		return insn->n;
 		break;
 	case COMEDI_INPUT:
@@ -2174,50 +2232,55 @@ static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
 	group = chan / 16;
 	bitmask = 1 << (chan - (16 * group));
 	DEBUG("s626_dio_set_irq: enable interrupt on dio channel %d group %d\n",
-		chan - (16 * group), group);
+	      chan - (16 * group), group);
 
 	/* set channel to capture positive edge */
 	status = DEBIread(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->RDEdgSel);
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->RDEdgSel);
 	DEBIwrite(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->WREdgSel, bitmask | status);
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WREdgSel,
+		  bitmask | status);
 
 	/* enable interrupt on selected channel */
 	status = DEBIread(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->RDIntSel);
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->RDIntSel);
 	DEBIwrite(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->WRIntSel, bitmask | status);
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WRIntSel,
+		  bitmask | status);
 
 	/* enable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_EDCAP);
 
 	/* enable edge capture on selected channel */
 	status = DEBIread(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->RDCapSel);
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->RDCapSel);
 	DEBIwrite(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->WRCapSel, bitmask | status);
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WRCapSel,
+		  bitmask | status);
 
 	return 0;
 }
 
 static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,
-	unsigned int mask)
+			      unsigned int mask)
 {
-	DEBUG("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n", mask, group);
+	DEBUG
+	    ("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n",
+	     mask, group);
 
 	/* disable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
 	/* enable edge capture on selected channel */
 	DEBIwrite(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->WRCapSel, mask);
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WRCapSel, mask);
 
 	return 0;
 }
@@ -2232,8 +2295,9 @@ static int s626_dio_clear_irq(struct comedi_device *dev)
 	for (group = 0; group < S626_DIO_BANKS; group++) {
 		/* clear pending events and interrupt */
 		DEBIwrite(dev,
-			((struct dio_private *) (dev->subdevices + 2 +
-					group)->private)->WRCapSel, 0xffff);
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->WRCapSel,
+			  0xffff);
 	}
 
 	return 0;
@@ -2242,17 +2306,18 @@ static int s626_dio_clear_irq(struct comedi_device *dev)
 /* Now this function initializes the value of the counter (data[0])
    and set the subdevice. To complete with trigger and interrupt
    configuration */
-static int s626_enc_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_enc_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
-		/*  index. */
-		(INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
-		(CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is Counter. */
-		(CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
-		/* ( CNTDIR_UP << BF_CLKPOL ) |      // Count direction is Down. */
-		(CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
-		(CLKENAB_INDEX << BF_CLKENAB);
+	    /*  index. */
+	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+	    (CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is Counter. */
+	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+	    /* ( CNTDIR_UP << BF_CLKPOL ) |      // Count direction is Down. */
+	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
+	    (CLKENAB_INDEX << BF_CLKENAB);
 	/*   uint16_t DisableIntSrc=TRUE; */
 	/*  uint32_t Preloadvalue;              //Counter initial value */
 	uint16_t valueSrclatch = LATCHSRC_AB_READ;
@@ -2272,15 +2337,16 @@ static int s626_enc_insn_config(struct comedi_device *dev, struct comedi_subdevi
 	return insn->n;
 }
 
-static int s626_enc_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_enc_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 
 	int n;
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
 	DEBUG("s626_enc_insn_read: encoder read channel %d \n",
-		CR_CHAN(insn->chanspec));
+	      CR_CHAN(insn->chanspec));
 
 	for (n = 0; n < insn->n; n++)
 		data[n] = ReadLatch(dev, k);
@@ -2290,14 +2356,15 @@ static int s626_enc_insn_read(struct comedi_device *dev, struct comedi_subdevice
 	return n;
 }
 
-static int s626_enc_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_enc_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
 	DEBUG("s626_enc_insn_write: encoder write channel %d \n",
-		CR_CHAN(insn->chanspec));
+	      CR_CHAN(insn->chanspec));
 
 	/*  Set the preload register */
 	Preload(dev, k, data[0]);
@@ -2313,16 +2380,17 @@ static int s626_enc_insn_write(struct comedi_device *dev, struct comedi_subdevic
 	return 1;
 }
 
-static void s626_timer_load(struct comedi_device *dev, struct enc_private *k, int tick)
+static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
+			    int tick)
 {
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
-		/*  index. */
-		(INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
-		(CLKSRC_TIMER << BF_CLKSRC) |	/*  Operating mode is Timer. */
-		(CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
-		(CNTDIR_DOWN << BF_CLKPOL) |	/*  Count direction is Down. */
-		(CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
-		(CLKENAB_INDEX << BF_CLKENAB);
+	    /*  index. */
+	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+	    (CLKSRC_TIMER << BF_CLKSRC) |	/*  Operating mode is Timer. */
+	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+	    (CNTDIR_DOWN << BF_CLKPOL) |	/*  Count direction is Down. */
+	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
+	    (CLKENAB_INDEX << BF_CLKENAB);
 	uint16_t valueSrclatch = LATCHSRC_A_INDXA;
 	/*   uint16_t enab=CLKENAB_ALWAYS; */
 
@@ -2357,7 +2425,7 @@ static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 
 /*  TrimDac LogicalChan-to-EepromAdrs mapping table. */
 static uint8_t trimadrs[] =
-	{ 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
+    { 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
 
 static void LoadTrimDACs(struct comedi_device *dev)
 {
@@ -2369,7 +2437,7 @@ static void LoadTrimDACs(struct comedi_device *dev)
 }
 
 static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
-	uint8_t DacData)
+			 uint8_t DacData)
 {
 	uint32_t chan;
 
@@ -2416,22 +2484,26 @@ static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 	/*  Send EEPROM target address. */
 	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)
 			 /* Byte2 = I2C command: write to I2C EEPROM  device. */
-			| I2C_B1(I2C_ATTRSTOP, addr)
+			 | I2C_B1(I2C_ATTRSTOP, addr)
 			 /* Byte1 = EEPROM internal target address. */
-			| I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not sent. */
+			 | I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not sent. */
 		/*  Abort function and declare error if handshake failed. */
 		DEBUG("I2Cread: error handshake I2Cread  a\n");
 		return 0;
 	}
 	/*  Execute EEPROM read. */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)	/*  Byte2 = I2C */
-			/*  command: read */
-			/*  from I2C EEPROM */
-			/*  device. */
-			| I2C_B1(I2C_ATTRSTOP, 0)	/*  Byte1 receives */
-			/*  uint8_t from */
-			/*  EEPROM. */
-			| I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not  sent. */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)
+
+			 /*  Byte2 = I2C */
+			 /*  command: read */
+			 /*  from I2C EEPROM */
+			 /*  device. */
+			 |I2C_B1(I2C_ATTRSTOP, 0)
+
+			 /*  Byte1 receives */
+			 /*  uint8_t from */
+			 /*  EEPROM. */
+			 |I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not  sent. */
 
 		/*  Abort function and declare error if handshake failed. */
 		DEBUG("I2Cread: error handshake I2Cread b\n");
@@ -2451,12 +2523,10 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 	/*  upload confirmation. */
 
 	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
-	while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
-		;
+	while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;
 
 	/*  Wait until I2C bus transfer is finished or an error occurs. */
-	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY)
-		;
+	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY) ;
 
 	/*  Return non-zero if I2C error occured. */
 	return RR7146(P_I2CCTRL) & I2C_ERR;
@@ -2570,8 +2640,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * Done by polling the DMAC enable flag; this flag is automatically
 	 * cleared when the transfer has finished.
 	 */
-	while ((RR7146(P_MC1) & MC1_A2OUT) != 0)
-		;
+	while ((RR7146(P_MC1) & MC1_A2OUT) != 0) ;
 
 	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
 
@@ -2588,8 +2657,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * finished transferring the DAC's data DWORD from the output FIFO
 	 * to the output buffer register.
 	 */
-	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0)
-		;
+	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0) ;
 
 	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
 	 * back to slot 0 after executing the EOS in slot 5.  Also,
@@ -2625,8 +2693,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
 		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
 		 */
-		 while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0)
-			;
+		while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) ;
 	}
 	/* Either (1) we were too late setting the slot 0 trap; the TSL
 	 * sequencer restarted slot 0 before we could set the EOS trap flag,
@@ -2642,8 +2709,7 @@ static void SendDAC(struct comedi_device *dev, uint32_t val)
 	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
 	 * from 0x00 to 0xFF.
 	 */
-	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0)
-		;
+	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0) ;
 }
 
 static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
@@ -2682,12 +2748,10 @@ static void DEBItransfer(struct comedi_device *dev)
 
 	/*  Wait for completion of upload from shadow RAM to DEBI control */
 	/*  register. */
-	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI))
-		;
+	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI)) ;
 
 	/*  Wait until DEBI transfer is done. */
-	while (RR7146(P_PSR) & PSR_DEBI_S)
-		;
+	while (RR7146(P_PSR) & PSR_DEBI_S) ;
 }
 
 /*  Write a value to a gate array register. */
@@ -2707,7 +2771,7 @@ static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
  * or'd with the masked original.
  */
 static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
-	uint16_t wdata)
+			uint16_t wdata)
 {
 
 	/*  Copy target gate array register into P_DEBIAD register. */
@@ -2724,7 +2788,8 @@ static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
 	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
 }
 
-static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma, size_t bsize)
+static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
+		      size_t bsize)
 {
 	void *vbptr;
 	dma_addr_t vpptr;
@@ -2742,7 +2807,7 @@ static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma, size_t
 		pdma->PhysicalBase = 0;
 
 		DEBUG("CloseDMAB(): Logical=%p, bsize=%d, Physical=0x%x\n",
-			vbptr, bsize, (uint32_t) vpptr);
+		      vbptr, bsize, (uint32_t) vpptr);
 	}
 }
 
@@ -2781,13 +2846,13 @@ static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
 static void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k)
 {
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
-		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 }
 
 static void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k)
 {
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
-		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
+		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
 }
 
 /*  Return counter setup in a format (COUNTER_SETUP) that is consistent */
@@ -2806,26 +2871,25 @@ static uint16_t GetMode_A(struct comedi_device *dev, struct enc_private *k)
 	/*  Populate the standardized counter setup bit fields.  Note: */
 	/*  IndexSrc is restricted to ENC_X or IndxPol. */
 	setup = ((cra & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcA. */
-		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcA. */
-		| ((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcA. */
-		| ((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) & STDMSK_INDXSRC)	/*  IndxSrc  = IndxSrcA<1>. */
-		| ((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolA. */
-		| ((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) & STDMSK_CLKENAB));	/*  ClkEnab  = ClkEnabA. */
+		 |((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcA. */
+		 |((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcA. */
+		 |((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) & STDMSK_INDXSRC)	/*  IndxSrc  = IndxSrcA<1>. */
+		 |((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolA. */
+		 |((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) & STDMSK_CLKENAB));	/*  ClkEnab  = ClkEnabA. */
 
 	/*  Adjust mode-dependent parameters. */
 	if (cra & (2 << CRABIT_CLKSRC_A))	/*  If Timer mode (ClkSrcA<1> == 1): */
 		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
-			| ((cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) & STDMSK_CLKPOL)	/*    Set ClkPol to indicate count direction (ClkSrcA<0>). */
-			| (MULT_X1 << STDBIT_CLKMULT));	/*    ClkMult must be 1x in Timer mode. */
+			  |((cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) & STDMSK_CLKPOL)	/*    Set ClkPol to indicate count direction (ClkSrcA<0>). */
+			  |(MULT_X1 << STDBIT_CLKMULT));	/*    ClkMult must be 1x in Timer mode. */
 
 	else			/*  If Counter mode (ClkSrcA<1> == 0): */
 		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Counter mode. */
-			| ((cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) & STDMSK_CLKPOL)	/*    Pass through ClkPol. */
-			| (((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A)) ?	/*    Force ClkMult to 1x if not legal, else pass through. */
-				(MULT_X1 << STDBIT_CLKMULT) :
-				((cra >> (CRABIT_CLKMULT_A -
-							STDBIT_CLKMULT)) &
-					STDMSK_CLKMULT)));
+			  |((cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) & STDMSK_CLKPOL)	/*    Pass through ClkPol. */
+			  |(((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A)) ?	/*    Force ClkMult to 1x if not legal, else pass through. */
+			    (MULT_X1 << STDBIT_CLKMULT) :
+			    ((cra >> (CRABIT_CLKMULT_A -
+				      STDBIT_CLKMULT)) & STDMSK_CLKMULT)));
 
 	/*  Return adjusted counter setup. */
 	return setup;
@@ -2844,27 +2908,27 @@ static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k)
 	/*  Populate the standardized counter setup bit fields.  Note: */
 	/*  IndexSrc is restricted to ENC_X or IndxPol. */
 	setup = (((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcB. */
-		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcB. */
-		| ((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcB. */
-		| ((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolB. */
-		| ((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) & STDMSK_CLKENAB)	/*  ClkEnab  = ClkEnabB. */
-		| ((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) & STDMSK_INDXSRC));	/*  IndxSrc  = IndxSrcB<1>. */
+		 |((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcB. */
+		 |((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcB. */
+		 |((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolB. */
+		 |((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) & STDMSK_CLKENAB)	/*  ClkEnab  = ClkEnabB. */
+		 |((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) & STDMSK_INDXSRC));	/*  IndxSrc  = IndxSrcB<1>. */
 
 	/*  Adjust mode-dependent parameters. */
 	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B))	/*  If Extender mode (ClkMultB == MULT_X0): */
 		setup |= ((CLKSRC_EXTENDER << STDBIT_CLKSRC)	/*    Indicate Extender mode. */
-			| (MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
-			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+			  |(MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
+			  |((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
 
 	else if (cra & (2 << CRABIT_CLKSRC_B))	/*  If Timer mode (ClkSrcB<1> == 1): */
 		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
-			| (MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
-			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+			  |(MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
+			  |((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
 
 	else			/*  If Counter mode (ClkSrcB<1> == 0): */
 		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
-			| ((crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) & STDMSK_CLKMULT)	/*    Clock multiplier is passed through. */
-			| ((crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) & STDMSK_CLKPOL));	/*    Clock polarity is passed through. */
+			  |((crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) & STDMSK_CLKMULT)	/*    Clock multiplier is passed through. */
+			  |((crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) & STDMSK_CLKPOL));	/*    Clock polarity is passed through. */
 
 	/*  Return adjusted counter setup. */
 	return setup;
@@ -2877,8 +2941,8 @@ static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k)
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
 
-static void SetMode_A(struct comedi_device *dev, struct enc_private *k, uint16_t Setup,
-	uint16_t DisableIntSrc)
+static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
+		      uint16_t Setup, uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
 	register uint16_t crb;
@@ -2886,15 +2950,15 @@ static void SetMode_A(struct comedi_device *dev, struct enc_private *k, uint16_t
 
 	/*  Initialize CRA and CRB images. */
 	cra = ((setup & CRAMSK_LOADSRC_A)	/*  Preload trigger is passed through. */
-		| ((setup & STDMSK_INDXSRC) >> (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	/*  IndexSrc is restricted to ENC_X or IndxPol. */
+	       |((setup & STDMSK_INDXSRC) >> (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	/*  IndexSrc is restricted to ENC_X or IndxPol. */
 
 	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A	/*  Reset any pending CounterA event captures. */
-		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	/*  Clock enable is passed through. */
+	       | ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	/*  Clock enable is passed through. */
 
 	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
 	if (!DisableIntSrc)
 		cra |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
-				CRABIT_INTSRC_A));
+						    CRABIT_INTSRC_A));
 
 	/*  Populate all mode-dependent attributes of CRA & CRB images. */
 	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
@@ -2903,25 +2967,25 @@ static void SetMode_A(struct comedi_device *dev, struct enc_private *k, uint16_t
 
 	case CLKSRC_TIMER:	/*  Timer Mode: */
 		cra |= ((2 << CRABIT_CLKSRC_A)	/*    ClkSrcA<1> selects system clock */
-			| ((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	/*      with count direction (ClkSrcA<0>) obtained from ClkPol. */
-			| (1 << CRABIT_CLKPOL_A)	/*    ClkPolA behaves as always-on clock enable. */
-			| (MULT_X1 << CRABIT_CLKMULT_A));	/*    ClkMult must be 1x. */
+			|((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	/*      with count direction (ClkSrcA<0>) obtained from ClkPol. */
+			|(1 << CRABIT_CLKPOL_A)	/*    ClkPolA behaves as always-on clock enable. */
+			|(MULT_X1 << CRABIT_CLKMULT_A));	/*    ClkMult must be 1x. */
 		break;
 
 	default:		/*  Counter Mode: */
 		cra |= (CLKSRC_COUNTER	/*    Select ENC_C and ENC_D as clock/direction inputs. */
 			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKPOL_A - STDBIT_CLKPOL))	/*    Clock polarity is passed through. */
-			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force multiplier to x1 if not legal, otherwise pass through. */
-				(MULT_X1 << CRABIT_CLKMULT_A) :
-				((setup & STDMSK_CLKMULT) << (CRABIT_CLKMULT_A -
-						STDBIT_CLKMULT))));
+			|(((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force multiplier to x1 if not legal, otherwise pass through. */
+			  (MULT_X1 << CRABIT_CLKMULT_A) :
+			  ((setup & STDMSK_CLKMULT) << (CRABIT_CLKMULT_A -
+							STDBIT_CLKMULT))));
 	}
 
 	/*  Force positive index polarity if IndxSrc is software-driven only, */
 	/*  otherwise pass it through. */
 	if (~setup & STDMSK_INDXSRC)
 		cra |= ((setup & STDMSK_INDXPOL) << (CRABIT_INDXPOL_A -
-				STDBIT_INDXPOL));
+						     STDBIT_INDXPOL));
 
 	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
 	/*  enable mask to indicate the counter interrupt is disabled. */
@@ -2932,11 +2996,11 @@ static void SetMode_A(struct comedi_device *dev, struct enc_private *k, uint16_t
 	/*  new counter operating mode. */
 	DEBIreplace(dev, k->MyCRA, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
 	DEBIreplace(dev, k->MyCRB,
-		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
+		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
 }
 
-static void SetMode_B(struct comedi_device *dev, struct enc_private *k, uint16_t Setup,
-	uint16_t DisableIntSrc)
+static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
+		      uint16_t Setup, uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
 	register uint16_t crb;
@@ -2946,44 +3010,44 @@ static void SetMode_B(struct comedi_device *dev, struct enc_private *k, uint16_t
 	cra = ((setup & STDMSK_INDXSRC) << ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC));	/*  IndexSrc field is restricted to ENC_X or IndxPol. */
 
 	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B	/*  Reset event captures and disable interrupts. */
-		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	/*  Clock enable is passed through. */
-		| ((setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	/*  Preload trigger source is passed through. */
+	       | ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	/*  Clock enable is passed through. */
+	       |((setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	/*  Preload trigger source is passed through. */
 
 	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
 	if (!DisableIntSrc)
 		crb |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
-				CRBBIT_INTSRC_B));
+						    CRBBIT_INTSRC_B));
 
 	/*  Populate all mode-dependent attributes of CRA & CRB images. */
 	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
 	case CLKSRC_TIMER:	/*  Timer Mode: */
 		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB<1> selects system clock */
-			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction (ClkSrcB<0>) obtained from ClkPol. */
+			|((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction (ClkSrcB<0>) obtained from ClkPol. */
 		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB behaves as always-on clock enable. */
-			| (MULT_X1 << CRBBIT_CLKMULT_B));	/*    ClkMultB must be 1x. */
+			|(MULT_X1 << CRBBIT_CLKMULT_B));	/*    ClkMultB must be 1x. */
 		break;
 
 	case CLKSRC_EXTENDER:	/*  Extender Mode: */
 		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB source is OverflowA (same as "timer") */
-			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction obtained from ClkPol. */
+			|((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction obtained from ClkPol. */
 		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB controls IndexB -- always set to active. */
-			| (MULT_X0 << CRBBIT_CLKMULT_B));	/*    ClkMultB selects OverflowA as the clock source. */
+			|(MULT_X0 << CRBBIT_CLKMULT_B));	/*    ClkMultB selects OverflowA as the clock source. */
 		break;
 
 	default:		/*  Counter Mode: */
 		cra |= (CLKSRC_COUNTER << CRABIT_CLKSRC_B);	/*    Select ENC_C and ENC_D as clock/direction inputs. */
 		crb |= (((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRBBIT_CLKPOL_B))	/*    ClkPol is passed through. */
-			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force ClkMult to x1 if not legal, otherwise pass through. */
-				(MULT_X1 << CRBBIT_CLKMULT_B) :
-				((setup & STDMSK_CLKMULT) << (CRBBIT_CLKMULT_B -
-						STDBIT_CLKMULT))));
+			|(((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force ClkMult to x1 if not legal, otherwise pass through. */
+			  (MULT_X1 << CRBBIT_CLKMULT_B) :
+			  ((setup & STDMSK_CLKMULT) << (CRBBIT_CLKMULT_B -
+							STDBIT_CLKMULT))));
 	}
 
 	/*  Force positive index polarity if IndxSrc is software-driven only, */
 	/*  otherwise pass it through. */
 	if (~setup & STDMSK_INDXSRC)
 		crb |= ((setup & STDMSK_INDXPOL) >> (STDBIT_INDXPOL -
-				CRBBIT_INDXPOL_B));
+						     CRBBIT_INDXPOL_B));
 
 	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
 	/*  enable mask to indicate the counter interrupt is disabled. */
@@ -2993,25 +3057,27 @@ static void SetMode_B(struct comedi_device *dev, struct enc_private *k, uint16_t
 	/*  While retaining CounterA and LatchSrc configurations, program the */
 	/*  new counter operating mode. */
 	DEBIreplace(dev, k->MyCRA,
-		(uint16_t) (~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B)), cra);
+		    (uint16_t) (~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B)), cra);
 	DEBIreplace(dev, k->MyCRB, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
 }
 
 /*  Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index. */
 
-static void SetEnable_A(struct comedi_device *dev, struct enc_private *k, uint16_t enab)
+static void SetEnable_A(struct comedi_device *dev, struct enc_private *k,
+			uint16_t enab)
 {
 	DEBUG("SetEnable_A: SetEnable_A enter 3541\n");
 	DEBIreplace(dev, k->MyCRB,
-		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)),
-		(uint16_t) (enab << CRBBIT_CLKENAB_A));
+		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)),
+		    (uint16_t) (enab << CRBBIT_CLKENAB_A));
 }
 
-static void SetEnable_B(struct comedi_device *dev, struct enc_private *k, uint16_t enab)
+static void SetEnable_B(struct comedi_device *dev, struct enc_private *k,
+			uint16_t enab)
 {
 	DEBIreplace(dev, k->MyCRB,
-		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),
-		(uint16_t) (enab << CRBBIT_CLKENAB_B));
+		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),
+		    (uint16_t) (enab << CRBBIT_CLKENAB_B));
 }
 
 static uint16_t GetEnable_A(struct comedi_device *dev, struct enc_private *k)
@@ -3029,12 +3095,13 @@ static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k)
  * latches B.
  */
 
-static void SetLatchSource(struct comedi_device *dev, struct enc_private *k, uint16_t value)
+static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
+			   uint16_t value)
 {
 	DEBUG("SetLatchSource: SetLatchSource enter 3550 \n");
 	DEBIreplace(dev, k->MyCRB,
-		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC)),
-		(uint16_t) (value << CRBBIT_LATCHSRC));
+		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC)),
+		    (uint16_t) (value << CRBBIT_LATCHSRC));
 
 	DEBUG("SetLatchSource: SetLatchSource exit \n");
 }
@@ -3052,17 +3119,19 @@ static void SetLatchSource(struct comedi_device *dev, struct enc_private *k, uin
  * 2=OverflowA (B counters only), 3=disabled.
  */
 
-static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k, uint16_t Trig)
+static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t Trig)
 {
 	DEBIreplace(dev, k->MyCRA, (uint16_t) (~CRAMSK_LOADSRC_A),
-		(uint16_t) (Trig << CRABIT_LOADSRC_A));
+		    (uint16_t) (Trig << CRABIT_LOADSRC_A));
 }
 
-static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k, uint16_t Trig)
+static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t Trig)
 {
 	DEBIreplace(dev, k->MyCRB,
-		(uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),
-		(uint16_t) (Trig << CRBBIT_LOADSRC_B));
+		    (uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),
+		    (uint16_t) (Trig << CRBBIT_LOADSRC_B));
 }
 
 static uint16_t GetLoadTrig_A(struct comedi_device *dev, struct enc_private *k)
@@ -3081,24 +3150,24 @@ static uint16_t GetLoadTrig_B(struct comedi_device *dev, struct enc_private *k)
  */
 
 static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
-	uint16_t IntSource)
+			uint16_t IntSource)
 {
 	/*  Reset any pending counter overflow or index captures. */
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
-		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 
 	/*  Program counter interrupt source. */
 	DEBIreplace(dev, k->MyCRA, ~CRAMSK_INTSRC_A,
-		(uint16_t) (IntSource << CRABIT_INTSRC_A));
+		    (uint16_t) (IntSource << CRABIT_INTSRC_A));
 
 	/*  Update MISC2 interrupt enable mask. */
 	devpriv->CounterIntEnabs =
-		(devpriv->CounterIntEnabs & ~k->MyEventBits[3]) | k->
-		MyEventBits[IntSource];
+	    (devpriv->CounterIntEnabs & ~k->
+	     MyEventBits[3]) | k->MyEventBits[IntSource];
 }
 
 static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
-	uint16_t IntSource)
+			uint16_t IntSource)
 {
 	uint16_t crb;
 
@@ -3107,17 +3176,17 @@ static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
 
 	/*  Reset any pending counter overflow or index captures. */
 	DEBIwrite(dev, k->MyCRB,
-		(uint16_t) (crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
+		  (uint16_t) (crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
 
 	/*  Program counter interrupt source. */
 	DEBIwrite(dev, k->MyCRB,
-		(uint16_t) ((crb & ~CRBMSK_INTSRC_B) | (IntSource <<
-				CRBBIT_INTSRC_B)));
+		  (uint16_t) ((crb & ~CRBMSK_INTSRC_B) | (IntSource <<
+							  CRBBIT_INTSRC_B)));
 
 	/*  Update MISC2 interrupt enable mask. */
 	devpriv->CounterIntEnabs =
-		(devpriv->CounterIntEnabs & ~k->MyEventBits[3]) | k->
-		MyEventBits[IntSource];
+	    (devpriv->CounterIntEnabs & ~k->
+	     MyEventBits[3]) | k->MyEventBits[IntSource];
 }
 
 static uint16_t GetIntSrc_A(struct comedi_device *dev, struct enc_private *k)
@@ -3216,13 +3285,14 @@ static void PulseIndex_B(struct comedi_device *dev, struct enc_private *k)
 
 /*  Write value into counter preload register. */
 
-static void Preload(struct comedi_device *dev, struct enc_private *k, uint32_t value)
+static void Preload(struct comedi_device *dev, struct enc_private *k,
+		    uint32_t value)
 {
 	DEBUG("Preload: preload enter\n");
 	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
 	DEBUG("Preload: preload step 1\n");
 	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw + 2),
-		(uint16_t) (value >> 16));
+		  (uint16_t) (value >> 16));
 }
 
 static void CountersInit(struct comedi_device *dev)
@@ -3230,13 +3300,13 @@ static void CountersInit(struct comedi_device *dev)
 	int chan;
 	struct enc_private *k;
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
-		/*  index. */
-		(INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
-		(CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is counter. */
-		(CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
-		(CNTDIR_UP << BF_CLKPOL) |	/*  Count direction is up. */
-		(CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
-		(CLKENAB_INDEX << BF_CLKENAB);	/*  Enabled by index */
+	    /*  index. */
+	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+	    (CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is counter. */
+	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+	    (CNTDIR_UP << BF_CLKPOL) |	/*  Count direction is up. */
+	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
+	    (CLKENAB_INDEX << BF_CLKENAB);	/*  Enabled by index */
 
 	/*  Disable all counter interrupts and clear any captured counter events. */
 	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {

commit 8231eb5672e7a020174eb7ce0436766eea57cae8
Author: Herton Ronaldo Krzesinski <herton@mandriva.com.br>
Date:   Thu Jun 18 14:43:56 2009 -0300

    Staging: comedi: s626: use subvendor:subdevice ids for SAA7146 board
    
    The current s626 comedi driver in staging conflicts with philips SAA7146
    media/dvb based cards, because it claims the same vendor:device pci id
    for all subdevice/subvendor ids. What happens is that for people that have a
    philips SAA7146 media/dvb based card, s626 if available gets loaded by udev
    and makes system freeze (https://qa.mandriva.com/show_bug.cgi?id=51445).
    
    The s626 driver shouldn't claim all 1131:7146 devices. Fix this by
    specifying specific known subvendor:subdevice ids in its pci id table
    list.
    
    Also s626_attach is modified to use now pci_get_subsys instead of
    pci_get_device as reported by Ian Abbott, and now we loop over pci id
    table entries in case more ids are added in the future.
    
    Reference: http://lkml.org/lkml/2009/6/16/552
    
    Signed-off-by: Herton Ronaldo Krzesinski <herton@mandriva.com.br>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 92121cf8c45c..5d9bab352c1d 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -111,9 +111,13 @@ static const struct s626_board s626_boards[] = {
 #define PCI_VENDOR_ID_S626 0x1131
 #define PCI_DEVICE_ID_S626 0x7146
 
+/*
+ * For devices with vendor:device id == 0x1131:0x7146 you must specify
+ * also subvendor:subdevice ids, because otherwise it will conflict with
+ * Philips SAA7146 media/dvb based cards.
+ */
 static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
-	{PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
-		0},
+	{PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626, 0x6000, 0x0272, 0, 0, 0},
 	{0}
 };
 
@@ -499,25 +503,26 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	resource_size_t resourceStart;
 	dma_addr_t appdma;
 	struct comedi_subdevice *s;
-	struct pci_dev *pdev;
+	const struct pci_device_id *ids;
+	struct pci_dev *pdev = NULL;
 
 	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
 		return -ENOMEM;
 
-	for (pdev = pci_get_device(PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626,
-			NULL); pdev != NULL;
-		pdev = pci_get_device(PCI_VENDOR_ID_S626,
-			PCI_DEVICE_ID_S626, pdev)) {
-		if (it->options[0] || it->options[1]) {
-			if (pdev->bus->number == it->options[0] &&
-				PCI_SLOT(pdev->devfn) == it->options[1]) {
+	for (i = 0; i < (ARRAY_SIZE(s626_pci_table) - 1) && !pdev; i++) {
+		ids = &s626_pci_table[i];
+		do {
+			pdev = pci_get_subsys(ids->vendor, ids->device, ids->subvendor,
+					      ids->subdevice, pdev);
+
+			if ((it->options[0] || it->options[1]) && pdev) {
 				/* matches requested bus/slot */
+				if (pdev->bus->number == it->options[0] &&
+				    PCI_SLOT(pdev->devfn) == it->options[1])
+					break;
+			} else
 				break;
-			}
-		} else {
-			/* no bus/slot specified */
-			break;
-		}
+		} while (1);
 	}
 	devpriv->pdev = pdev;
 

commit 25436dc9d84f1be60ff549c9ab712bba2835f284
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 15:14:34 2009 -0700

    Staging: comedi: remove RT code
    
    This removes the unused RT code from the comedi subsystem.
    
    A lot of drivers needed to then include interrupt.h on their own, as they
    were picking it up through the comedi_rt.h inclusion.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index bebc12bf3891..92121cf8c45c 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -68,6 +68,7 @@ INSN_CONFIG instructions:
    comedi_do_insn(cf,&insn); //executing configuration
 */
 
+#include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
 

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index ff8ec589298c..bebc12bf3891 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -596,8 +596,8 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (dev->irq == 0) {
 		printk(" unknown irq (bad)\n");
 	} else {
-		ret = comedi_request_irq(dev->irq, s626_irq_handler,
-					 IRQF_SHARED, "s626", dev);
+		ret = request_irq(dev->irq, s626_irq_handler, IRQF_SHARED,
+				  "s626", dev);
 
 		if (ret < 0) {
 			printk(" irq not available\n");
@@ -987,7 +987,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	if (dev->attached == 0)
 		return IRQ_NONE;
 	/*  lock to avoid race with comedi_poll */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 
 	/* save interrupt enable register state */
 	irqstatus = readl(devpriv->base_addr + P_IER);
@@ -1264,7 +1264,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 
 	DEBUG("s626_irq_handler: exit interrupt service routine.\n");
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 	return IRQ_HANDLED;
 }
 
@@ -1291,7 +1291,7 @@ static int s626_detach(struct comedi_device *dev)
 		}
 
 		if (dev->irq)
-			comedi_free_irq(dev->irq, dev);
+			free_irq(dev->irq, dev);
 
 		if (devpriv->base_addr)
 			iounmap(devpriv->base_addr);
@@ -1574,7 +1574,7 @@ static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice
 	for (n = 0; n < insn->n; n++) {
 
 		/*  Delay 10 microseconds for analog input settling. */
-		comedi_udelay(10);
+		udelay(10);
 
 		/*  Start ADC by pulsing GPIO1 low. */
 		GpioImage = RR7146(P_GPIO);
@@ -1606,7 +1606,7 @@ static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice
 		 * data value is sometimes set to the previous
 		 * conversion's data value.
 		 */
-		comedi_udelay(4);
+		udelay(4);
 	}
 
 	/* Start a dummy conversion to cause the data from the

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 6e78194fe551..ff8ec589298c 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2358,7 +2358,7 @@ static void LoadTrimDACs(struct comedi_device *dev)
 	register uint8_t i;
 
 	/*  Copy TrimDac setpoint values from EEPROM to TrimDacs. */
-	for (i = 0; i < (sizeof(trimchan) / sizeof(trimchan[0])); i++)
+	for (i = 0; i < ARRAY_SIZE(trimchan); i++)
 		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
 }
 

commit b4918808debc62daaa189ecbdfca489c00b1061d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:55 2009 -0400

    Staging: comedi: more fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index d8f014563c1e..6e78194fe551 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -95,14 +95,14 @@ struct s626_board {
 
 static const struct s626_board s626_boards[] = {
 	{
-	      name:	"s626",
-	      ai_chans : S626_ADC_CHANNELS,
-	      ai_bits:	14,
-	      ao_chans : S626_DAC_CHANNELS,
-	      ao_bits:	13,
-	      dio_chans : S626_DIO_CHANNELS,
-	      dio_banks : S626_DIO_BANKS,
-	      enc_chans : S626_ENCODER_CHANNELS,
+	.name = "s626",
+	.ai_chans = S626_ADC_CHANNELS,
+	.ai_bits = 14,
+	.ao_chans = S626_DAC_CHANNELS,
+	.ao_bits = 13,
+	.dio_chans = S626_DIO_CHANNELS,
+	.dio_banks = S626_DIO_BANKS,
+	.enc_chans = S626_ENCODER_CHANNELS,
 		}
 };
 
@@ -122,10 +122,10 @@ static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int s626_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver_s626 = {
-      driver_name:"s626",
-      module : THIS_MODULE,
-      attach : s626_attach,
-      detach : s626_detach,
+	.driver_name = "s626",
+	.module = THIS_MODULE,
+	.attach = s626_attach,
+	.detach = s626_detach,
 };
 
 struct s626_private {
@@ -173,39 +173,39 @@ struct dio_private {
 };
 
 static struct dio_private dio_private_A = {
-      RDDIn:LP_RDDINA,
-      WRDOut : LP_WRDOUTA,
-      RDEdgSel : LP_RDEDGSELA,
-      WREdgSel : LP_WREDGSELA,
-      RDCapSel : LP_RDCAPSELA,
-      WRCapSel : LP_WRCAPSELA,
-      RDCapFlg : LP_RDCAPFLGA,
-      RDIntSel : LP_RDINTSELA,
-      WRIntSel : LP_WRINTSELA,
+	.RDDIn = LP_RDDINA,
+	.WRDOut = LP_WRDOUTA,
+	.RDEdgSel = LP_RDEDGSELA,
+	.WREdgSel = LP_WREDGSELA,
+	.RDCapSel = LP_RDCAPSELA,
+	.WRCapSel = LP_WRCAPSELA,
+	.RDCapFlg = LP_RDCAPFLGA,
+	.RDIntSel = LP_RDINTSELA,
+	.WRIntSel = LP_WRINTSELA,
 };
 
 static struct dio_private dio_private_B = {
-      RDDIn:LP_RDDINB,
-      WRDOut : LP_WRDOUTB,
-      RDEdgSel : LP_RDEDGSELB,
-      WREdgSel : LP_WREDGSELB,
-      RDCapSel : LP_RDCAPSELB,
-      WRCapSel : LP_WRCAPSELB,
-      RDCapFlg : LP_RDCAPFLGB,
-      RDIntSel : LP_RDINTSELB,
-      WRIntSel : LP_WRINTSELB,
+	.RDDIn = LP_RDDINB,
+	.WRDOut = LP_WRDOUTB,
+	.RDEdgSel = LP_RDEDGSELB,
+	.WREdgSel = LP_WREDGSELB,
+	.RDCapSel = LP_RDCAPSELB,
+	.WRCapSel = LP_WRCAPSELB,
+	.RDCapFlg = LP_RDCAPFLGB,
+	.RDIntSel = LP_RDINTSELB,
+	.WRIntSel = LP_WRINTSELB,
 };
 
 static struct dio_private dio_private_C = {
-      RDDIn:LP_RDDINC,
-      WRDOut : LP_WRDOUTC,
-      RDEdgSel : LP_RDEDGSELC,
-      WREdgSel : LP_WREDGSELC,
-      RDCapSel : LP_RDCAPSELC,
-      WRCapSel : LP_WRCAPSELC,
-      RDCapFlg : LP_RDCAPFLGC,
-      RDIntSel : LP_RDINTSELC,
-      WRIntSel : LP_WRINTSELC,
+	.RDDIn = LP_RDDINC,
+	.WRDOut = LP_WRDOUTC,
+	.RDEdgSel = LP_RDEDGSELC,
+	.WREdgSel = LP_WREDGSELC,
+	.RDCapSel = LP_RDCAPSELC,
+	.WRCapSel = LP_WRCAPSELC,
+	.RDCapFlg = LP_RDCAPFLGC,
+	.RDIntSel = LP_RDINTSELC,
+	.WRIntSel = LP_WRINTSELC,
 };
 
 /* to group dio devices (48 bits mask and data are not allowed ???)
@@ -355,100 +355,100 @@ static void CountersInit(struct comedi_device *dev);
 /* struct enc_private; */
 static struct enc_private enc_private_data[] = {
 	{
-	      GetEnable:GetEnable_A,
-	      GetIntSrc : GetIntSrc_A,
-	      GetLoadTrig : GetLoadTrig_A,
-	      GetMode :	GetMode_A,
-	      PulseIndex : PulseIndex_A,
-	      SetEnable : SetEnable_A,
-	      SetIntSrc : SetIntSrc_A,
-	      SetLoadTrig : SetLoadTrig_A,
-	      SetMode :	SetMode_A,
-	      ResetCapFlags : ResetCapFlags_A,
-	      MyCRA :	LP_CR0A,
-	      MyCRB :	LP_CR0B,
-	      MyLatchLsw : LP_CNTR0ALSW,
-	      MyEventBits : EVBITS(0),
+	.GetEnable = GetEnable_A,
+	.GetIntSrc = GetIntSrc_A,
+	.GetLoadTrig = GetLoadTrig_A,
+	.GetMode = GetMode_A,
+	.PulseIndex = PulseIndex_A,
+	.SetEnable = SetEnable_A,
+	.SetIntSrc = SetIntSrc_A,
+	.SetLoadTrig = SetLoadTrig_A,
+	.SetMode = SetMode_A,
+	.ResetCapFlags = ResetCapFlags_A,
+	.MyCRA = LP_CR0A,
+	.MyCRB = LP_CR0B,
+	.MyLatchLsw = LP_CNTR0ALSW,
+	.MyEventBits = EVBITS(0),
 		},
 	{
-	      GetEnable:GetEnable_A,
-	      GetIntSrc : GetIntSrc_A,
-	      GetLoadTrig : GetLoadTrig_A,
-	      GetMode :	GetMode_A,
-	      PulseIndex : PulseIndex_A,
-	      SetEnable : SetEnable_A,
-	      SetIntSrc : SetIntSrc_A,
-	      SetLoadTrig : SetLoadTrig_A,
-	      SetMode :	SetMode_A,
-	      ResetCapFlags : ResetCapFlags_A,
-	      MyCRA :	LP_CR1A,
-	      MyCRB :	LP_CR1B,
-	      MyLatchLsw : LP_CNTR1ALSW,
-	      MyEventBits : EVBITS(1),
+	.GetEnable = GetEnable_A,
+	.GetIntSrc = GetIntSrc_A,
+	.GetLoadTrig = GetLoadTrig_A,
+	.GetMode = GetMode_A,
+	.PulseIndex = PulseIndex_A,
+	.SetEnable = SetEnable_A,
+	.SetIntSrc = SetIntSrc_A,
+	.SetLoadTrig = SetLoadTrig_A,
+	.SetMode = SetMode_A,
+	.ResetCapFlags = ResetCapFlags_A,
+	.MyCRA = LP_CR1A,
+	.MyCRB = LP_CR1B,
+	.MyLatchLsw = LP_CNTR1ALSW,
+	.MyEventBits = EVBITS(1),
 		},
 	{
-	      GetEnable:GetEnable_A,
-	      GetIntSrc : GetIntSrc_A,
-	      GetLoadTrig : GetLoadTrig_A,
-	      GetMode :	GetMode_A,
-	      PulseIndex : PulseIndex_A,
-	      SetEnable : SetEnable_A,
-	      SetIntSrc : SetIntSrc_A,
-	      SetLoadTrig : SetLoadTrig_A,
-	      SetMode :	SetMode_A,
-	      ResetCapFlags : ResetCapFlags_A,
-	      MyCRA :	LP_CR2A,
-	      MyCRB :	LP_CR2B,
-	      MyLatchLsw : LP_CNTR2ALSW,
-	      MyEventBits : EVBITS(2),
+	.GetEnable = GetEnable_A,
+	.GetIntSrc = GetIntSrc_A,
+	.GetLoadTrig = GetLoadTrig_A,
+	.GetMode = GetMode_A,
+	.PulseIndex = PulseIndex_A,
+	.SetEnable = SetEnable_A,
+	.SetIntSrc = SetIntSrc_A,
+	.SetLoadTrig = SetLoadTrig_A,
+	.SetMode = SetMode_A,
+	.ResetCapFlags = ResetCapFlags_A,
+	.MyCRA = LP_CR2A,
+	.MyCRB = LP_CR2B,
+	.MyLatchLsw = LP_CNTR2ALSW,
+	.MyEventBits = EVBITS(2),
 		},
 	{
-	      GetEnable:GetEnable_B,
-	      GetIntSrc : GetIntSrc_B,
-	      GetLoadTrig : GetLoadTrig_B,
-	      GetMode :	GetMode_B,
-	      PulseIndex : PulseIndex_B,
-	      SetEnable : SetEnable_B,
-	      SetIntSrc : SetIntSrc_B,
-	      SetLoadTrig : SetLoadTrig_B,
-	      SetMode :	SetMode_B,
-	      ResetCapFlags : ResetCapFlags_B,
-	      MyCRA :	LP_CR0A,
-	      MyCRB :	LP_CR0B,
-	      MyLatchLsw : LP_CNTR0BLSW,
-	      MyEventBits : EVBITS(3),
+	.GetEnable = GetEnable_B,
+	.GetIntSrc = GetIntSrc_B,
+	.GetLoadTrig = GetLoadTrig_B,
+	.GetMode = GetMode_B,
+	.PulseIndex = PulseIndex_B,
+	.SetEnable = SetEnable_B,
+	.SetIntSrc = SetIntSrc_B,
+	.SetLoadTrig = SetLoadTrig_B,
+	.SetMode = SetMode_B,
+	.ResetCapFlags = ResetCapFlags_B,
+	.MyCRA = LP_CR0A,
+	.MyCRB = LP_CR0B,
+	.MyLatchLsw = LP_CNTR0BLSW,
+	.MyEventBits = EVBITS(3),
 		},
 	{
-	      GetEnable:GetEnable_B,
-	      GetIntSrc : GetIntSrc_B,
-	      GetLoadTrig : GetLoadTrig_B,
-	      GetMode :	GetMode_B,
-	      PulseIndex : PulseIndex_B,
-	      SetEnable : SetEnable_B,
-	      SetIntSrc : SetIntSrc_B,
-	      SetLoadTrig : SetLoadTrig_B,
-	      SetMode :	SetMode_B,
-	      ResetCapFlags : ResetCapFlags_B,
-	      MyCRA :	LP_CR1A,
-	      MyCRB :	LP_CR1B,
-	      MyLatchLsw : LP_CNTR1BLSW,
-	      MyEventBits : EVBITS(4),
+	.GetEnable = GetEnable_B,
+	.GetIntSrc = GetIntSrc_B,
+	.GetLoadTrig = GetLoadTrig_B,
+	.GetMode = GetMode_B,
+	.PulseIndex = PulseIndex_B,
+	.SetEnable = SetEnable_B,
+	.SetIntSrc = SetIntSrc_B,
+	.SetLoadTrig = SetLoadTrig_B,
+	.SetMode = SetMode_B,
+	.ResetCapFlags = ResetCapFlags_B,
+	.MyCRA = LP_CR1A,
+	.MyCRB = LP_CR1B,
+	.MyLatchLsw = LP_CNTR1BLSW,
+	.MyEventBits = EVBITS(4),
 		},
 	{
-	      GetEnable:GetEnable_B,
-	      GetIntSrc : GetIntSrc_B,
-	      GetLoadTrig : GetLoadTrig_B,
-	      GetMode :	GetMode_B,
-	      PulseIndex : PulseIndex_B,
-	      SetEnable : SetEnable_B,
-	      SetIntSrc : SetIntSrc_B,
-	      SetLoadTrig : SetLoadTrig_B,
-	      SetMode :	SetMode_B,
-	      ResetCapFlags : ResetCapFlags_B,
-	      MyCRA :	LP_CR2A,
-	      MyCRB :	LP_CR2B,
-	      MyLatchLsw : LP_CNTR2BLSW,
-	      MyEventBits : EVBITS(5),
+	.GetEnable = GetEnable_B,
+	.GetIntSrc = GetIntSrc_B,
+	.GetLoadTrig = GetLoadTrig_B,
+	.GetMode = GetMode_B,
+	.PulseIndex = PulseIndex_B,
+	.SetEnable = SetEnable_B,
+	.SetIntSrc = SetIntSrc_B,
+	.SetLoadTrig = SetLoadTrig_B,
+	.SetMode = SetMode_B,
+	.ResetCapFlags = ResetCapFlags_B,
+	.MyCRA = LP_CR2A,
+	.MyCRB = LP_CR2B,
+	.MyLatchLsw = LP_CNTR2BLSW,
+	.MyEventBits = EVBITS(5),
 		},
 };
 

commit 46dbd1486e6c75f8cd136e3899015906f83cd8de
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Thu Apr 23 12:23:14 2009 +0200

    Staging: comedi: non working tests on unsigned cmd->convert_arg
    
    Remove tests for negative unsigned.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index bf7e20492b28..d8f014563c1e 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1886,31 +1886,16 @@ static int s626_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s
 		err++;
 	}
 
-	if (cmd->start_src == TRIG_EXT && cmd->start_arg < 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
-
 	if (cmd->start_src == TRIG_EXT && cmd->start_arg > 39) {
 		cmd->start_arg = 39;
 		err++;
 	}
 
-	if (cmd->scan_begin_src == TRIG_EXT && cmd->scan_begin_arg < 0) {
-		cmd->scan_begin_arg = 0;
-		err++;
-	}
-
 	if (cmd->scan_begin_src == TRIG_EXT && cmd->scan_begin_arg > 39) {
 		cmd->scan_begin_arg = 39;
 		err++;
 	}
 
-	if (cmd->convert_src == TRIG_EXT && cmd->convert_arg < 0) {
-		cmd->convert_arg = 0;
-		err++;
-	}
-
 	if (cmd->convert_src == TRIG_EXT && cmd->convert_arg > 39) {
 		cmd->convert_arg = 39;
 		err++;

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 30dec9dab19b..bf7e20492b28 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -253,7 +253,7 @@ static int s626_ns_to_timer(int *nanosec, int round_mode);
 static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd);
 static int s626_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum);
-static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG);
+static irqreturn_t s626_irq_handler(int irq, void *d);
 static unsigned int s626_ai_reg_to_uint(int data);
 /* static unsigned int s626_uint_to_reg(struct comedi_subdevice *s, int data); */
 
@@ -968,7 +968,7 @@ static unsigned int s626_ai_reg_to_uint(int data)
 /*   return 0; */
 /* } */
 
-static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
+static irqreturn_t s626_irq_handler(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s;

commit 4753d235e76b14c9f4585d569795a4ccb51485f8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:47 2009 -0400

    Staging: comedi: Remove DMABUF typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 3e6f1f0d99e5..30dec9dab19b 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -144,8 +144,8 @@ struct s626_private {
 	uint16_t CounterIntEnabs;
 	/* Counter interrupt enable  mask for MISC2 register. */
 	uint8_t AdcItems;	/* Number of items in ADC poll  list. */
-	DMABUF RPSBuf;		/* DMA buffer used to hold ADC (RPS1) program. */
-	DMABUF ANABuf;
+	struct bufferDMA RPSBuf;		/* DMA buffer used to hold ADC (RPS1) program. */
+	struct bufferDMA ANABuf;
 	/* DMA buffer used to receive ADC data and hold DAC data. */
 	uint32_t *pDacWBuf;
 	/* Pointer to logical adrs of DMA buffer used to hold DAC  data. */
@@ -275,7 +275,7 @@ static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr);
 static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata);
 static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
 	uint16_t wdata);
-static void CloseDMAB(struct comedi_device *dev, DMABUF *pdma, size_t bsize);
+static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma, size_t bsize);
 
 /*  COUNTER OBJECT ------------------------------------------------ */
 struct enc_private {
@@ -2733,7 +2733,7 @@ static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
 	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
 }
 
-static void CloseDMAB(struct comedi_device *dev, DMABUF *pdma, size_t bsize)
+static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma, size_t bsize)
 {
 	void *vbptr;
 	dma_addr_t vpptr;

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 7385031f2b8b..3e6f1f0d99e5 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -118,7 +118,7 @@ static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
 
 MODULE_DEVICE_TABLE(pci, s626_pci_table);
 
-static int s626_attach(struct comedi_device *dev, comedi_devconfig *it);
+static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int s626_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver_s626 = {
@@ -485,7 +485,7 @@ static const struct comedi_lrange s626_range_table = { 2, {
 	}
 };
 
-static int s626_attach(struct comedi_device *dev, comedi_devconfig *it)
+static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 /*   uint8_t	PollList; */
 /*   uint16_t	AdcData; */

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 80fedbb47b76..7385031f2b8b 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -223,32 +223,32 @@ COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
 
 /* ioctl routines */
 static int s626_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data);
-/* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,comedi_insn *insn,unsigned int *data); */
+	struct comedi_insn *insn, unsigned int *data);
+/* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data); */
 static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data);
+	struct comedi_insn *insn, unsigned int *data);
 static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int s626_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	struct comedi_cmd *cmd);
 static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data);
+	struct comedi_insn *insn, unsigned int *data);
 static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data);
+	struct comedi_insn *insn, unsigned int *data);
 static int s626_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data);
+	struct comedi_insn *insn, unsigned int *data);
 static int s626_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data);
+	struct comedi_insn *insn, unsigned int *data);
 static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan);
 static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int gruop,
 	unsigned int mask);
 static int s626_dio_clear_irq(struct comedi_device *dev);
 static int s626_enc_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data);
+	struct comedi_insn *insn, unsigned int *data);
 static int s626_enc_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data);
+	struct comedi_insn *insn, unsigned int *data);
 static int s626_enc_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data);
+	struct comedi_insn *insn, unsigned int *data);
 static int s626_ns_to_timer(int *nanosec, int round_mode);
 static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd);
 static int s626_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -1504,13 +1504,13 @@ void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 
 /* TO COMPLETE, IF NECESSARY */
 static int s626_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data)
+	struct comedi_insn *insn, unsigned int *data)
 {
 
 	return -EINVAL;
 }
 
-/* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,comedi_insn *insn,unsigned int *data) */
+/* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data) */
 /* { */
 /*   register uint8_t	i; */
 /*   register int32_t	*readaddr; */
@@ -1541,7 +1541,7 @@ static int s626_ai_insn_config(struct comedi_device *dev, struct comedi_subdevic
 /* } */
 
 static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data)
+	struct comedi_insn *insn, unsigned int *data)
 {
 	uint16_t chan = CR_CHAN(insn->chanspec);
 	uint16_t range = CR_RANGE(insn->chanspec);
@@ -2046,7 +2046,7 @@ static int s626_ns_to_timer(int *nanosec, int round_mode)
 }
 
 static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data)
+	struct comedi_insn *insn, unsigned int *data)
 {
 
 	int i;
@@ -2065,7 +2065,7 @@ static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data)
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 
@@ -2111,7 +2111,7 @@ static void s626_dio_init(struct comedi_device *dev)
  * core can convert between insn_bits and insn_read/write */
 
 static int s626_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data)
+	struct comedi_insn *insn, unsigned int *data)
 {
 
 	/* Length of data must be 2 (mask and new data, see below) */
@@ -2147,7 +2147,7 @@ static int s626_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice
 }
 
 static int s626_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data)
+	struct comedi_insn *insn, unsigned int *data)
 {
 
 	switch (data[0]) {
@@ -2252,7 +2252,7 @@ static int s626_dio_clear_irq(struct comedi_device *dev)
    and set the subdevice. To complete with trigger and interrupt
    configuration */
 static int s626_enc_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data)
+	struct comedi_insn *insn, unsigned int *data)
 {
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
 		/*  index. */
@@ -2282,7 +2282,7 @@ static int s626_enc_insn_config(struct comedi_device *dev, struct comedi_subdevi
 }
 
 static int s626_enc_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data)
+	struct comedi_insn *insn, unsigned int *data)
 {
 
 	int n;
@@ -2300,7 +2300,7 @@ static int s626_enc_insn_read(struct comedi_device *dev, struct comedi_subdevice
 }
 
 static int s626_enc_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_insn *insn, unsigned int *data)
+	struct comedi_insn *insn, unsigned int *data)
 {
 
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4f7068fb2bc0..80fedbb47b76 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -229,7 +229,7 @@ static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice
 	comedi_insn *insn, unsigned int *data);
 static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int s626_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_cmd *cmd);
+	struct comedi_cmd *cmd);
 static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
@@ -250,7 +250,7 @@ static int s626_enc_insn_read(struct comedi_device *dev, struct comedi_subdevice
 static int s626_enc_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
 static int s626_ns_to_timer(int *nanosec, int round_mode);
-static int s626_ai_load_polllist(uint8_t *ppl, comedi_cmd *cmd);
+static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd);
 static int s626_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum);
 static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG);
@@ -972,7 +972,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 {
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s;
-	comedi_cmd *cmd;
+	struct comedi_cmd *cmd;
 	struct enc_private *k;
 	unsigned long flags;
 	int32_t *readaddr;
@@ -1318,7 +1318,7 @@ void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 	uint16_t i;
 	uint16_t n;
 	uint32_t LocalPPL;
-	comedi_cmd *cmd = &(dev->subdevices->async->cmd);
+	struct comedi_cmd *cmd = &(dev->subdevices->async->cmd);
 
 	/*  Stop RPS program in case it is currently running. */
 	MC_DISABLE(P_MC1, MC1_ERPS1);
@@ -1638,7 +1638,7 @@ static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice
 	return n;
 }
 
-static int s626_ai_load_polllist(uint8_t *ppl, comedi_cmd *cmd)
+static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)
 {
 
 	int n;
@@ -1677,7 +1677,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 
 	uint8_t ppl[16];
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	struct enc_private *k;
 	int tick;
 
@@ -1820,7 +1820,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static int s626_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_cmd *cmd)
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index ac6424ca25da..4f7068fb2bc0 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -479,7 +479,7 @@ static struct enc_private enc_private_data[] = {
 #define I2C_B1(ATTR, VAL)	(((ATTR) << 4) | ((VAL) << 16))
 #define I2C_B0(ATTR, VAL)	(((ATTR) << 2) | ((VAL) <<  8))
 
-static const comedi_lrange s626_range_table = { 2, {
+static const struct comedi_lrange s626_range_table = { 2, {
 			RANGE(-5, 5),
 			RANGE(-10, 10),
 	}

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 4bba963cd537..ac6424ca25da 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -121,7 +121,7 @@ MODULE_DEVICE_TABLE(pci, s626_pci_table);
 static int s626_attach(struct comedi_device *dev, comedi_devconfig *it);
 static int s626_detach(struct comedi_device *dev);
 
-static comedi_driver driver_s626 = {
+static struct comedi_driver driver_s626 = {
       driver_name:"s626",
       module : THIS_MODULE,
       attach : s626_attach,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 7a9e4544f00a..4bba963cd537 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -222,40 +222,40 @@ static struct dio_private *dio_private_word[]={
 COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
 
 /* ioctl routines */
-static int s626_ai_insn_config(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-/* static int s626_ai_rinsn(struct comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,unsigned int *data); */
-static int s626_ai_insn_read(struct comedi_device *dev, comedi_subdevice *s,
+/* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,comedi_insn *insn,unsigned int *data); */
+static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static int s626_ai_cmd(struct comedi_device *dev, comedi_subdevice *s);
-static int s626_ai_cmdtest(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int s626_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_cmd *cmd);
-static int s626_ai_cancel(struct comedi_device *dev, comedi_subdevice *s);
-static int s626_ao_winsn(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static int s626_ao_rinsn(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static int s626_dio_insn_bits(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static int s626_dio_insn_config(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
 static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan);
 static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int gruop,
 	unsigned int mask);
 static int s626_dio_clear_irq(struct comedi_device *dev);
-static int s626_enc_insn_config(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_enc_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static int s626_enc_insn_read(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_enc_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static int s626_enc_insn_write(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_enc_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
 static int s626_ns_to_timer(int *nanosec, int round_mode);
 static int s626_ai_load_polllist(uint8_t *ppl, comedi_cmd *cmd);
-static int s626_ai_inttrig(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum);
 static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG);
 static unsigned int s626_ai_reg_to_uint(int data);
-/* static unsigned int s626_uint_to_reg(comedi_subdevice *s, int data); */
+/* static unsigned int s626_uint_to_reg(struct comedi_subdevice *s, int data); */
 
 /* end ioctl routines */
 
@@ -497,7 +497,7 @@ static int s626_attach(struct comedi_device *dev, comedi_devconfig *it)
 	int ret;
 	resource_size_t resourceStart;
 	dma_addr_t appdma;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	struct pci_dev *pdev;
 
 	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
@@ -964,14 +964,14 @@ static unsigned int s626_ai_reg_to_uint(int data)
 	return tempdata;
 }
 
-/* static unsigned int s626_uint_to_reg(comedi_subdevice *s, int data){ */
+/* static unsigned int s626_uint_to_reg(struct comedi_subdevice *s, int data){ */
 /*   return 0; */
 /* } */
 
 static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 {
 	struct comedi_device *dev = d;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	comedi_cmd *cmd;
 	struct enc_private *k;
 	unsigned long flags;
@@ -1503,14 +1503,14 @@ void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 }
 
 /* TO COMPLETE, IF NECESSARY */
-static int s626_ai_insn_config(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 
 	return -EINVAL;
 }
 
-/* static int s626_ai_rinsn(struct comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,unsigned int *data) */
+/* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,comedi_insn *insn,unsigned int *data) */
 /* { */
 /*   register uint8_t	i; */
 /*   register int32_t	*readaddr; */
@@ -1540,7 +1540,7 @@ static int s626_ai_insn_config(struct comedi_device *dev, comedi_subdevice *s,
 /*   return i; */
 /* } */
 
-static int s626_ai_insn_read(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 	uint16_t chan = CR_CHAN(insn->chanspec);
@@ -1654,7 +1654,7 @@ static int s626_ai_load_polllist(uint8_t *ppl, comedi_cmd *cmd)
 	return n;
 }
 
-static int s626_ai_inttrig(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum)
 {
 	if (trignum != 0)
@@ -1673,7 +1673,7 @@ static int s626_ai_inttrig(struct comedi_device *dev, comedi_subdevice *s,
 }
 
 /*  TO COMPLETE  */
-static int s626_ai_cmd(struct comedi_device *dev, comedi_subdevice *s)
+static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 
 	uint8_t ppl[16];
@@ -1819,7 +1819,7 @@ static int s626_ai_cmd(struct comedi_device *dev, comedi_subdevice *s)
 	return 0;
 }
 
-static int s626_ai_cmdtest(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_cmd *cmd)
 {
 	int err = 0;
@@ -2004,7 +2004,7 @@ static int s626_ai_cmdtest(struct comedi_device *dev, comedi_subdevice *s,
 	return 0;
 }
 
-static int s626_ai_cancel(struct comedi_device *dev, comedi_subdevice *s)
+static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	/*  Stop RPS program in case it is currently running. */
 	MC_DISABLE(P_MC1, MC1_ERPS1);
@@ -2045,7 +2045,7 @@ static int s626_ns_to_timer(int *nanosec, int round_mode)
 	return divider - 1;
 }
 
-static int s626_ao_winsn(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 
@@ -2064,7 +2064,7 @@ static int s626_ao_winsn(struct comedi_device *dev, comedi_subdevice *s,
 	return i;
 }
 
-static int s626_ao_rinsn(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 	int i;
@@ -2084,7 +2084,7 @@ static int s626_ao_rinsn(struct comedi_device *dev, comedi_subdevice *s,
 static void s626_dio_init(struct comedi_device *dev)
 {
 	uint16_t group;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	/*  Prepare to treat writes to WRCapSel as capture disables. */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
@@ -2110,7 +2110,7 @@ static void s626_dio_init(struct comedi_device *dev)
  * This allows packed reading/writing of the DIO channels.  The comedi
  * core can convert between insn_bits and insn_read/write */
 
-static int s626_dio_insn_bits(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 
@@ -2146,7 +2146,7 @@ static int s626_dio_insn_bits(struct comedi_device *dev, comedi_subdevice *s,
 	return 2;
 }
 
-static int s626_dio_insn_config(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 
@@ -2251,7 +2251,7 @@ static int s626_dio_clear_irq(struct comedi_device *dev)
 /* Now this function initializes the value of the counter (data[0])
    and set the subdevice. To complete with trigger and interrupt
    configuration */
-static int s626_enc_insn_config(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_enc_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
@@ -2281,7 +2281,7 @@ static int s626_enc_insn_config(struct comedi_device *dev, comedi_subdevice *s,
 	return insn->n;
 }
 
-static int s626_enc_insn_read(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_enc_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 
@@ -2299,7 +2299,7 @@ static int s626_enc_insn_read(struct comedi_device *dev, comedi_subdevice *s,
 	return n;
 }
 
-static int s626_enc_insn_write(struct comedi_device *dev, comedi_subdevice *s,
+static int s626_enc_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index a4f4de69da76..7a9e4544f00a 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -118,8 +118,8 @@ static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
 
 MODULE_DEVICE_TABLE(pci, s626_pci_table);
 
-static int s626_attach(comedi_device *dev, comedi_devconfig *it);
-static int s626_detach(comedi_device *dev);
+static int s626_attach(struct comedi_device *dev, comedi_devconfig *it);
+static int s626_detach(struct comedi_device *dev);
 
 static comedi_driver driver_s626 = {
       driver_name:"s626",
@@ -222,36 +222,36 @@ static struct dio_private *dio_private_word[]={
 COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
 
 /* ioctl routines */
-static int s626_ai_insn_config(comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_insn_config(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-/* static int s626_ai_rinsn(comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,unsigned int *data); */
-static int s626_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
+/* static int s626_ai_rinsn(struct comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,unsigned int *data); */
+static int s626_ai_insn_read(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static int s626_ai_cmd(comedi_device *dev, comedi_subdevice *s);
-static int s626_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_cmd(struct comedi_device *dev, comedi_subdevice *s);
+static int s626_ai_cmdtest(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_cmd *cmd);
-static int s626_ai_cancel(comedi_device *dev, comedi_subdevice *s);
-static int s626_ao_winsn(comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_cancel(struct comedi_device *dev, comedi_subdevice *s);
+static int s626_ao_winsn(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static int s626_ao_rinsn(comedi_device *dev, comedi_subdevice *s,
+static int s626_ao_rinsn(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static int s626_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
+static int s626_dio_insn_bits(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static int s626_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
+static int s626_dio_insn_config(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static int s626_dio_set_irq(comedi_device *dev, unsigned int chan);
-static int s626_dio_reset_irq(comedi_device *dev, unsigned int gruop,
+static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan);
+static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int gruop,
 	unsigned int mask);
-static int s626_dio_clear_irq(comedi_device *dev);
-static int s626_enc_insn_config(comedi_device *dev, comedi_subdevice *s,
+static int s626_dio_clear_irq(struct comedi_device *dev);
+static int s626_enc_insn_config(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static int s626_enc_insn_read(comedi_device *dev, comedi_subdevice *s,
+static int s626_enc_insn_read(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
-static int s626_enc_insn_write(comedi_device *dev, comedi_subdevice *s,
+static int s626_enc_insn_write(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data);
 static int s626_ns_to_timer(int *nanosec, int round_mode);
 static int s626_ai_load_polllist(uint8_t *ppl, comedi_cmd *cmd);
-static int s626_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_inttrig(struct comedi_device *dev, comedi_subdevice *s,
 	unsigned int trignum);
 static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG);
 static unsigned int s626_ai_reg_to_uint(int data);
@@ -260,36 +260,36 @@ static unsigned int s626_ai_reg_to_uint(int data);
 /* end ioctl routines */
 
 /* internal routines */
-static void s626_dio_init(comedi_device *dev);
-static void ResetADC(comedi_device *dev, uint8_t *ppl);
-static void LoadTrimDACs(comedi_device *dev);
-static void WriteTrimDAC(comedi_device *dev, uint8_t LogicalChan,
+static void s626_dio_init(struct comedi_device *dev);
+static void ResetADC(struct comedi_device *dev, uint8_t *ppl);
+static void LoadTrimDACs(struct comedi_device *dev);
+static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
 	uint8_t DacData);
-static uint8_t I2Cread(comedi_device *dev, uint8_t addr);
-static uint32_t I2Chandshake(comedi_device *dev, uint32_t val);
-static void SetDAC(comedi_device *dev, uint16_t chan, short dacdata);
-static void SendDAC(comedi_device *dev, uint32_t val);
-static void WriteMISC2(comedi_device *dev, uint16_t NewImage);
-static void DEBItransfer(comedi_device *dev);
-static uint16_t DEBIread(comedi_device *dev, uint16_t addr);
-static void DEBIwrite(comedi_device *dev, uint16_t addr, uint16_t wdata);
-static void DEBIreplace(comedi_device *dev, uint16_t addr, uint16_t mask,
+static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr);
+static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val);
+static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata);
+static void SendDAC(struct comedi_device *dev, uint32_t val);
+static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage);
+static void DEBItransfer(struct comedi_device *dev);
+static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr);
+static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata);
+static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
 	uint16_t wdata);
-static void CloseDMAB(comedi_device *dev, DMABUF *pdma, size_t bsize);
+static void CloseDMAB(struct comedi_device *dev, DMABUF *pdma, size_t bsize);
 
 /*  COUNTER OBJECT ------------------------------------------------ */
 struct enc_private {
 	/*  Pointers to functions that differ for A and B counters: */
-	uint16_t(*GetEnable) (comedi_device *dev, struct enc_private *);	/* Return clock enable. */
-	uint16_t(*GetIntSrc) (comedi_device *dev, struct enc_private *);	/* Return interrupt source. */
-	uint16_t(*GetLoadTrig) (comedi_device *dev, struct enc_private *);	/* Return preload trigger source. */
-	uint16_t(*GetMode) (comedi_device *dev, struct enc_private *);	/* Return standardized operating mode. */
-	void (*PulseIndex) (comedi_device *dev, struct enc_private *);	/* Generate soft index strobe. */
-	void (*SetEnable) (comedi_device *dev, struct enc_private *, uint16_t enab);	/* Program clock enable. */
-	void (*SetIntSrc) (comedi_device *dev, struct enc_private *, uint16_t IntSource);	/* Program interrupt source. */
-	void (*SetLoadTrig) (comedi_device *dev, struct enc_private *, uint16_t Trig);	/* Program preload trigger source. */
-	void (*SetMode) (comedi_device *dev, struct enc_private *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
-	void (*ResetCapFlags) (comedi_device *dev, struct enc_private *);	/* Reset event capture flags. */
+	uint16_t(*GetEnable) (struct comedi_device *dev, struct enc_private *);	/* Return clock enable. */
+	uint16_t(*GetIntSrc) (struct comedi_device *dev, struct enc_private *);	/* Return interrupt source. */
+	uint16_t(*GetLoadTrig) (struct comedi_device *dev, struct enc_private *);	/* Return preload trigger source. */
+	uint16_t(*GetMode) (struct comedi_device *dev, struct enc_private *);	/* Return standardized operating mode. */
+	void (*PulseIndex) (struct comedi_device *dev, struct enc_private *);	/* Generate soft index strobe. */
+	void (*SetEnable) (struct comedi_device *dev, struct enc_private *, uint16_t enab);	/* Program clock enable. */
+	void (*SetIntSrc) (struct comedi_device *dev, struct enc_private *, uint16_t IntSource);	/* Program interrupt source. */
+	void (*SetLoadTrig) (struct comedi_device *dev, struct enc_private *, uint16_t Trig);	/* Program preload trigger source. */
+	void (*SetMode) (struct comedi_device *dev, struct enc_private *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
+	void (*ResetCapFlags) (struct comedi_device *dev, struct enc_private *);	/* Reset event capture flags. */
 
 	uint16_t MyCRA;		/*    Address of CRA register. */
 	uint16_t MyCRB;		/*    Address of CRB register. */
@@ -301,45 +301,45 @@ struct enc_private {
 #define encpriv ((struct enc_private *)(dev->subdevices+5)->private)
 
 /* counters routines */
-static void s626_timer_load(comedi_device *dev, struct enc_private *k, int tick);
-static uint32_t ReadLatch(comedi_device *dev, struct enc_private *k);
-static void ResetCapFlags_A(comedi_device *dev, struct enc_private *k);
-static void ResetCapFlags_B(comedi_device *dev, struct enc_private *k);
-static uint16_t GetMode_A(comedi_device *dev, struct enc_private *k);
-static uint16_t GetMode_B(comedi_device *dev, struct enc_private *k);
-static void SetMode_A(comedi_device *dev, struct enc_private *k, uint16_t Setup,
+static void s626_timer_load(struct comedi_device *dev, struct enc_private *k, int tick);
+static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k);
+static void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k);
+static void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k);
+static uint16_t GetMode_A(struct comedi_device *dev, struct enc_private *k);
+static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k);
+static void SetMode_A(struct comedi_device *dev, struct enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc);
-static void SetMode_B(comedi_device *dev, struct enc_private *k, uint16_t Setup,
+static void SetMode_B(struct comedi_device *dev, struct enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc);
-static void SetEnable_A(comedi_device *dev, struct enc_private *k, uint16_t enab);
-static void SetEnable_B(comedi_device *dev, struct enc_private *k, uint16_t enab);
-static uint16_t GetEnable_A(comedi_device *dev, struct enc_private *k);
-static uint16_t GetEnable_B(comedi_device *dev, struct enc_private *k);
-static void SetLatchSource(comedi_device *dev, struct enc_private *k,
+static void SetEnable_A(struct comedi_device *dev, struct enc_private *k, uint16_t enab);
+static void SetEnable_B(struct comedi_device *dev, struct enc_private *k, uint16_t enab);
+static uint16_t GetEnable_A(struct comedi_device *dev, struct enc_private *k);
+static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k);
+static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
 	uint16_t value);
-/* static uint16_t GetLatchSource(comedi_device *dev, struct enc_private *k ); */
-static void SetLoadTrig_A(comedi_device *dev, struct enc_private *k, uint16_t Trig);
-static void SetLoadTrig_B(comedi_device *dev, struct enc_private *k, uint16_t Trig);
-static uint16_t GetLoadTrig_A(comedi_device *dev, struct enc_private *k);
-static uint16_t GetLoadTrig_B(comedi_device *dev, struct enc_private *k);
-static void SetIntSrc_B(comedi_device *dev, struct enc_private *k,
+/* static uint16_t GetLatchSource(struct comedi_device *dev, struct enc_private *k ); */
+static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k, uint16_t Trig);
+static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k, uint16_t Trig);
+static uint16_t GetLoadTrig_A(struct comedi_device *dev, struct enc_private *k);
+static uint16_t GetLoadTrig_B(struct comedi_device *dev, struct enc_private *k);
+static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
 	uint16_t IntSource);
-static void SetIntSrc_A(comedi_device *dev, struct enc_private *k,
+static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
 	uint16_t IntSource);
-static uint16_t GetIntSrc_A(comedi_device *dev, struct enc_private *k);
-static uint16_t GetIntSrc_B(comedi_device *dev, struct enc_private *k);
-/* static void SetClkMult(comedi_device *dev, struct enc_private *k, uint16_t value ) ; */
-/* static uint16_t GetClkMult(comedi_device *dev, struct enc_private *k ) ; */
-/* static void SetIndexPol(comedi_device *dev, struct enc_private *k, uint16_t value ); */
-/* static uint16_t GetClkPol(comedi_device *dev, struct enc_private *k ) ; */
-/* static void SetIndexSrc( comedi_device *dev,struct enc_private *k, uint16_t value );  */
-/* static uint16_t GetClkSrc( comedi_device *dev,struct enc_private *k );  */
-/* static void SetIndexSrc( comedi_device *dev,struct enc_private *k, uint16_t value );  */
-/* static uint16_t GetIndexSrc( comedi_device *dev,struct enc_private *k );  */
-static void PulseIndex_A(comedi_device *dev, struct enc_private *k);
-static void PulseIndex_B(comedi_device *dev, struct enc_private *k);
-static void Preload(comedi_device *dev, struct enc_private *k, uint32_t value);
-static void CountersInit(comedi_device *dev);
+static uint16_t GetIntSrc_A(struct comedi_device *dev, struct enc_private *k);
+static uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k);
+/* static void SetClkMult(struct comedi_device *dev, struct enc_private *k, uint16_t value ) ; */
+/* static uint16_t GetClkMult(struct comedi_device *dev, struct enc_private *k ) ; */
+/* static void SetIndexPol(struct comedi_device *dev, struct enc_private *k, uint16_t value ); */
+/* static uint16_t GetClkPol(struct comedi_device *dev, struct enc_private *k ) ; */
+/* static void SetIndexSrc( struct comedi_device *dev,struct enc_private *k, uint16_t value );  */
+/* static uint16_t GetClkSrc( struct comedi_device *dev,struct enc_private *k );  */
+/* static void SetIndexSrc( struct comedi_device *dev,struct enc_private *k, uint16_t value );  */
+/* static uint16_t GetIndexSrc( struct comedi_device *dev,struct enc_private *k );  */
+static void PulseIndex_A(struct comedi_device *dev, struct enc_private *k);
+static void PulseIndex_B(struct comedi_device *dev, struct enc_private *k);
+static void Preload(struct comedi_device *dev, struct enc_private *k, uint32_t value);
+static void CountersInit(struct comedi_device *dev);
 /* end internal routines */
 
 /*  Counter objects constructor. */
@@ -485,7 +485,7 @@ static const comedi_lrange s626_range_table = { 2, {
 	}
 };
 
-static int s626_attach(comedi_device *dev, comedi_devconfig *it)
+static int s626_attach(struct comedi_device *dev, comedi_devconfig *it)
 {
 /*   uint8_t	PollList; */
 /*   uint16_t	AdcData; */
@@ -970,7 +970,7 @@ static unsigned int s626_ai_reg_to_uint(int data)
 
 static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	comedi_subdevice *s;
 	comedi_cmd *cmd;
 	struct enc_private *k;
@@ -1268,7 +1268,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-static int s626_detach(comedi_device *dev)
+static int s626_detach(struct comedi_device *dev)
 {
 	if (devpriv) {
 		/* stop ai_command */
@@ -1311,7 +1311,7 @@ static int s626_detach(comedi_device *dev)
 /*
  * this functions build the RPS program for hardware driven acquistion
  */
-void ResetADC(comedi_device *dev, uint8_t *ppl)
+void ResetADC(struct comedi_device *dev, uint8_t *ppl)
 {
 	register uint32_t *pRPS;
 	uint32_t JmpAdrs;
@@ -1503,14 +1503,14 @@ void ResetADC(comedi_device *dev, uint8_t *ppl)
 }
 
 /* TO COMPLETE, IF NECESSARY */
-static int s626_ai_insn_config(comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_insn_config(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 
 	return -EINVAL;
 }
 
-/* static int s626_ai_rinsn(comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,unsigned int *data) */
+/* static int s626_ai_rinsn(struct comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,unsigned int *data) */
 /* { */
 /*   register uint8_t	i; */
 /*   register int32_t	*readaddr; */
@@ -1540,7 +1540,7 @@ static int s626_ai_insn_config(comedi_device *dev, comedi_subdevice *s,
 /*   return i; */
 /* } */
 
-static int s626_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_insn_read(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 	uint16_t chan = CR_CHAN(insn->chanspec);
@@ -1654,7 +1654,7 @@ static int s626_ai_load_polllist(uint8_t *ppl, comedi_cmd *cmd)
 	return n;
 }
 
-static int s626_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_inttrig(struct comedi_device *dev, comedi_subdevice *s,
 	unsigned int trignum)
 {
 	if (trignum != 0)
@@ -1673,7 +1673,7 @@ static int s626_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
 }
 
 /*  TO COMPLETE  */
-static int s626_ai_cmd(comedi_device *dev, comedi_subdevice *s)
+static int s626_ai_cmd(struct comedi_device *dev, comedi_subdevice *s)
 {
 
 	uint8_t ppl[16];
@@ -1819,7 +1819,7 @@ static int s626_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 	return 0;
 }
 
-static int s626_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
+static int s626_ai_cmdtest(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_cmd *cmd)
 {
 	int err = 0;
@@ -2004,7 +2004,7 @@ static int s626_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 	return 0;
 }
 
-static int s626_ai_cancel(comedi_device *dev, comedi_subdevice *s)
+static int s626_ai_cancel(struct comedi_device *dev, comedi_subdevice *s)
 {
 	/*  Stop RPS program in case it is currently running. */
 	MC_DISABLE(P_MC1, MC1_ERPS1);
@@ -2045,7 +2045,7 @@ static int s626_ns_to_timer(int *nanosec, int round_mode)
 	return divider - 1;
 }
 
-static int s626_ao_winsn(comedi_device *dev, comedi_subdevice *s,
+static int s626_ao_winsn(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 
@@ -2064,7 +2064,7 @@ static int s626_ao_winsn(comedi_device *dev, comedi_subdevice *s,
 	return i;
 }
 
-static int s626_ao_rinsn(comedi_device *dev, comedi_subdevice *s,
+static int s626_ao_rinsn(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 	int i;
@@ -2081,7 +2081,7 @@ static int s626_ao_rinsn(comedi_device *dev, comedi_subdevice *s,
  * ports A, B and C, respectively.
  */
 
-static void s626_dio_init(comedi_device *dev)
+static void s626_dio_init(struct comedi_device *dev)
 {
 	uint16_t group;
 	comedi_subdevice *s;
@@ -2110,7 +2110,7 @@ static void s626_dio_init(comedi_device *dev)
  * This allows packed reading/writing of the DIO channels.  The comedi
  * core can convert between insn_bits and insn_read/write */
 
-static int s626_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
+static int s626_dio_insn_bits(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 
@@ -2146,7 +2146,7 @@ static int s626_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
 	return 2;
 }
 
-static int s626_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
+static int s626_dio_insn_config(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 
@@ -2173,7 +2173,7 @@ static int s626_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
 	return 1;
 }
 
-static int s626_dio_set_irq(comedi_device *dev, unsigned int chan)
+static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)
 {
 	unsigned int group;
 	unsigned int bitmask;
@@ -2215,7 +2215,7 @@ static int s626_dio_set_irq(comedi_device *dev, unsigned int chan)
 	return 0;
 }
 
-static int s626_dio_reset_irq(comedi_device *dev, unsigned int group,
+static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,
 	unsigned int mask)
 {
 	DEBUG("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n", mask, group);
@@ -2231,7 +2231,7 @@ static int s626_dio_reset_irq(comedi_device *dev, unsigned int group,
 	return 0;
 }
 
-static int s626_dio_clear_irq(comedi_device *dev)
+static int s626_dio_clear_irq(struct comedi_device *dev)
 {
 	unsigned int group;
 
@@ -2251,7 +2251,7 @@ static int s626_dio_clear_irq(comedi_device *dev)
 /* Now this function initializes the value of the counter (data[0])
    and set the subdevice. To complete with trigger and interrupt
    configuration */
-static int s626_enc_insn_config(comedi_device *dev, comedi_subdevice *s,
+static int s626_enc_insn_config(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
@@ -2281,7 +2281,7 @@ static int s626_enc_insn_config(comedi_device *dev, comedi_subdevice *s,
 	return insn->n;
 }
 
-static int s626_enc_insn_read(comedi_device *dev, comedi_subdevice *s,
+static int s626_enc_insn_read(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 
@@ -2299,7 +2299,7 @@ static int s626_enc_insn_read(comedi_device *dev, comedi_subdevice *s,
 	return n;
 }
 
-static int s626_enc_insn_write(comedi_device *dev, comedi_subdevice *s,
+static int s626_enc_insn_write(struct comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, unsigned int *data)
 {
 
@@ -2322,7 +2322,7 @@ static int s626_enc_insn_write(comedi_device *dev, comedi_subdevice *s,
 	return 1;
 }
 
-static void s626_timer_load(comedi_device *dev, struct enc_private *k, int tick)
+static void s626_timer_load(struct comedi_device *dev, struct enc_private *k, int tick)
 {
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
 		/*  index. */
@@ -2368,7 +2368,7 @@ static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 static uint8_t trimadrs[] =
 	{ 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
 
-static void LoadTrimDACs(comedi_device *dev)
+static void LoadTrimDACs(struct comedi_device *dev)
 {
 	register uint8_t i;
 
@@ -2377,7 +2377,7 @@ static void LoadTrimDACs(comedi_device *dev)
 		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
 }
 
-static void WriteTrimDAC(comedi_device *dev, uint8_t LogicalChan,
+static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
 	uint8_t DacData)
 {
 	uint32_t chan;
@@ -2418,7 +2418,7 @@ static void WriteTrimDAC(comedi_device *dev, uint8_t LogicalChan,
 /* **************  EEPROM ACCESS FUNCTIONS  ************** */
 /*  Read uint8_t from EEPROM. */
 
-static uint8_t I2Cread(comedi_device *dev, uint8_t addr)
+static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)
 {
 	uint8_t rtnval;
 
@@ -2451,7 +2451,7 @@ static uint8_t I2Cread(comedi_device *dev, uint8_t addr)
 	return rtnval;
 }
 
-static uint32_t I2Chandshake(comedi_device *dev, uint32_t val)
+static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 {
 	/*  Write I2C command to I2C Transfer Control shadow register. */
 	WR7146(P_I2CCTRL, val);
@@ -2474,7 +2474,7 @@ static uint32_t I2Chandshake(comedi_device *dev, uint32_t val)
 
 /*  Private helper function: Write setpoint to an application DAC channel. */
 
-static void SetDAC(comedi_device *dev, uint16_t chan, short dacdata)
+static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)
 {
 	register uint16_t signmask;
 	register uint32_t WSImage;
@@ -2535,7 +2535,7 @@ static void SetDAC(comedi_device *dev, uint16_t chan, short dacdata)
  * Dacpol contains valid target image.
  */
 
-static void SendDAC(comedi_device *dev, uint32_t val)
+static void SendDAC(struct comedi_device *dev, uint32_t val)
 {
 
 	/* START THE SERIAL CLOCK RUNNING ------------- */
@@ -2655,7 +2655,7 @@ static void SendDAC(comedi_device *dev, uint32_t val)
 		;
 }
 
-static void WriteMISC2(comedi_device *dev, uint16_t NewImage)
+static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
 {
 	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	/*  enab writes to */
 	/*  MISC2 register. */
@@ -2665,7 +2665,7 @@ static void WriteMISC2(comedi_device *dev, uint16_t NewImage)
 
 /*  Initialize the DEBI interface for all transfers. */
 
-static uint16_t DEBIread(comedi_device *dev, uint16_t addr)
+static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)
 {
 	uint16_t retval;
 
@@ -2684,7 +2684,7 @@ static uint16_t DEBIread(comedi_device *dev, uint16_t addr)
 
 /*  Execute a DEBI transfer.  This must be called from within a */
 /*  critical section. */
-static void DEBItransfer(comedi_device *dev)
+static void DEBItransfer(struct comedi_device *dev)
 {
 	/*  Initiate upload of shadow RAM to DEBI control register. */
 	MC_ENABLE(P_MC2, MC2_UPLD_DEBI);
@@ -2700,7 +2700,7 @@ static void DEBItransfer(comedi_device *dev)
 }
 
 /*  Write a value to a gate array register. */
-static void DEBIwrite(comedi_device *dev, uint16_t addr, uint16_t wdata)
+static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)
 {
 
 	/*  Set up DEBI control register value in shadow RAM. */
@@ -2715,7 +2715,7 @@ static void DEBIwrite(comedi_device *dev, uint16_t addr, uint16_t wdata)
  * specifies bits that are to be preserved, wdata is new value to be
  * or'd with the masked original.
  */
-static void DEBIreplace(comedi_device *dev, uint16_t addr, uint16_t mask,
+static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
 	uint16_t wdata)
 {
 
@@ -2733,7 +2733,7 @@ static void DEBIreplace(comedi_device *dev, uint16_t addr, uint16_t mask,
 	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
 }
 
-static void CloseDMAB(comedi_device *dev, DMABUF *pdma, size_t bsize)
+static void CloseDMAB(struct comedi_device *dev, DMABUF *pdma, size_t bsize)
 {
 	void *vbptr;
 	dma_addr_t vpptr;
@@ -2768,7 +2768,7 @@ static void CloseDMAB(comedi_device *dev, DMABUF *pdma, size_t bsize)
 
 /*  Read a counter's output latch. */
 
-static uint32_t ReadLatch(comedi_device *dev, struct enc_private *k)
+static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)
 {
 	register uint32_t value;
 	/* DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n"); */
@@ -2787,13 +2787,13 @@ static uint32_t ReadLatch(comedi_device *dev, struct enc_private *k)
 
 /*  Reset a counter's index and overflow event capture flags. */
 
-static void ResetCapFlags_A(comedi_device *dev, struct enc_private *k)
+static void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k)
 {
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 }
 
-static void ResetCapFlags_B(comedi_device *dev, struct enc_private *k)
+static void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k)
 {
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
@@ -2802,7 +2802,7 @@ static void ResetCapFlags_B(comedi_device *dev, struct enc_private *k)
 /*  Return counter setup in a format (COUNTER_SETUP) that is consistent */
 /*  for both A and B counters. */
 
-static uint16_t GetMode_A(comedi_device *dev, struct enc_private *k)
+static uint16_t GetMode_A(struct comedi_device *dev, struct enc_private *k)
 {
 	register uint16_t cra;
 	register uint16_t crb;
@@ -2840,7 +2840,7 @@ static uint16_t GetMode_A(comedi_device *dev, struct enc_private *k)
 	return setup;
 }
 
-static uint16_t GetMode_B(comedi_device *dev, struct enc_private *k)
+static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k)
 {
 	register uint16_t cra;
 	register uint16_t crb;
@@ -2886,7 +2886,7 @@ static uint16_t GetMode_B(comedi_device *dev, struct enc_private *k)
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
 
-static void SetMode_A(comedi_device *dev, struct enc_private *k, uint16_t Setup,
+static void SetMode_A(struct comedi_device *dev, struct enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
@@ -2944,7 +2944,7 @@ static void SetMode_A(comedi_device *dev, struct enc_private *k, uint16_t Setup,
 		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
 }
 
-static void SetMode_B(comedi_device *dev, struct enc_private *k, uint16_t Setup,
+static void SetMode_B(struct comedi_device *dev, struct enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
@@ -3008,7 +3008,7 @@ static void SetMode_B(comedi_device *dev, struct enc_private *k, uint16_t Setup,
 
 /*  Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index. */
 
-static void SetEnable_A(comedi_device *dev, struct enc_private *k, uint16_t enab)
+static void SetEnable_A(struct comedi_device *dev, struct enc_private *k, uint16_t enab)
 {
 	DEBUG("SetEnable_A: SetEnable_A enter 3541\n");
 	DEBIreplace(dev, k->MyCRB,
@@ -3016,19 +3016,19 @@ static void SetEnable_A(comedi_device *dev, struct enc_private *k, uint16_t enab
 		(uint16_t) (enab << CRBBIT_CLKENAB_A));
 }
 
-static void SetEnable_B(comedi_device *dev, struct enc_private *k, uint16_t enab)
+static void SetEnable_B(struct comedi_device *dev, struct enc_private *k, uint16_t enab)
 {
 	DEBIreplace(dev, k->MyCRB,
 		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),
 		(uint16_t) (enab << CRBBIT_CLKENAB_B));
 }
 
-static uint16_t GetEnable_A(comedi_device *dev, struct enc_private *k)
+static uint16_t GetEnable_A(struct comedi_device *dev, struct enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_A) & 1;
 }
 
-static uint16_t GetEnable_B(comedi_device *dev, struct enc_private *k)
+static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_B) & 1;
 }
@@ -3038,7 +3038,7 @@ static uint16_t GetEnable_B(comedi_device *dev, struct enc_private *k)
  * latches B.
  */
 
-static void SetLatchSource(comedi_device *dev, struct enc_private *k, uint16_t value)
+static void SetLatchSource(struct comedi_device *dev, struct enc_private *k, uint16_t value)
 {
 	DEBUG("SetLatchSource: SetLatchSource enter 3550 \n");
 	DEBIreplace(dev, k->MyCRB,
@@ -3049,7 +3049,7 @@ static void SetLatchSource(comedi_device *dev, struct enc_private *k, uint16_t v
 }
 
 /*
- * static uint16_t GetLatchSource(comedi_device *dev, struct enc_private *k )
+ * static uint16_t GetLatchSource(struct comedi_device *dev, struct enc_private *k )
  * {
  * 	return ( DEBIread( dev, k->MyCRB) >> CRBBIT_LATCHSRC ) & 3;
  * }
@@ -3061,25 +3061,25 @@ static void SetLatchSource(comedi_device *dev, struct enc_private *k, uint16_t v
  * 2=OverflowA (B counters only), 3=disabled.
  */
 
-static void SetLoadTrig_A(comedi_device *dev, struct enc_private *k, uint16_t Trig)
+static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k, uint16_t Trig)
 {
 	DEBIreplace(dev, k->MyCRA, (uint16_t) (~CRAMSK_LOADSRC_A),
 		(uint16_t) (Trig << CRABIT_LOADSRC_A));
 }
 
-static void SetLoadTrig_B(comedi_device *dev, struct enc_private *k, uint16_t Trig)
+static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k, uint16_t Trig)
 {
 	DEBIreplace(dev, k->MyCRB,
 		(uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),
 		(uint16_t) (Trig << CRBBIT_LOADSRC_B));
 }
 
-static uint16_t GetLoadTrig_A(comedi_device *dev, struct enc_private *k)
+static uint16_t GetLoadTrig_A(struct comedi_device *dev, struct enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRA) >> CRABIT_LOADSRC_A) & 3;
 }
 
-static uint16_t GetLoadTrig_B(comedi_device *dev, struct enc_private *k)
+static uint16_t GetLoadTrig_B(struct comedi_device *dev, struct enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_LOADSRC_B) & 3;
 }
@@ -3089,7 +3089,7 @@ static uint16_t GetLoadTrig_B(comedi_device *dev, struct enc_private *k)
  * 2=IndexOnly, 3=IndexAndOverflow.
  */
 
-static void SetIntSrc_A(comedi_device *dev, struct enc_private *k,
+static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
 	uint16_t IntSource)
 {
 	/*  Reset any pending counter overflow or index captures. */
@@ -3106,7 +3106,7 @@ static void SetIntSrc_A(comedi_device *dev, struct enc_private *k,
 		MyEventBits[IntSource];
 }
 
-static void SetIntSrc_B(comedi_device *dev, struct enc_private *k,
+static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
 	uint16_t IntSource)
 {
 	uint16_t crb;
@@ -3129,80 +3129,80 @@ static void SetIntSrc_B(comedi_device *dev, struct enc_private *k,
 		MyEventBits[IntSource];
 }
 
-static uint16_t GetIntSrc_A(comedi_device *dev, struct enc_private *k)
+static uint16_t GetIntSrc_A(struct comedi_device *dev, struct enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRA) >> CRABIT_INTSRC_A) & 3;
 }
 
-static uint16_t GetIntSrc_B(comedi_device *dev, struct enc_private *k)
+static uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_INTSRC_B) & 3;
 }
 
 /*  Return/set the clock multiplier. */
 
-/* static void SetClkMult(comedi_device *dev, struct enc_private *k, uint16_t value )  */
+/* static void SetClkMult(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */
 /* { */
 /*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKMULT ) | ( value << STDBIT_CLKMULT ) ), FALSE ); */
 /* } */
 
-/* static uint16_t GetClkMult(comedi_device *dev, struct enc_private *k )  */
+/* static uint16_t GetClkMult(struct comedi_device *dev, struct enc_private *k )  */
 /* { */
 /*   return ( k->GetMode(dev, k ) >> STDBIT_CLKMULT ) & 3; */
 /* } */
 
 /* Return/set the clock polarity. */
 
-/* static void SetClkPol( comedi_device *dev,struct enc_private *k, uint16_t value )  */
+/* static void SetClkPol( struct comedi_device *dev,struct enc_private *k, uint16_t value )  */
 /* { */
 /*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKPOL ) | ( value << STDBIT_CLKPOL ) ), FALSE ); */
 /* } */
 
-/* static uint16_t GetClkPol(comedi_device *dev, struct enc_private *k )  */
+/* static uint16_t GetClkPol(struct comedi_device *dev, struct enc_private *k )  */
 /* { */
 /*   return ( k->GetMode(dev, k ) >> STDBIT_CLKPOL ) & 1; */
 /* } */
 
 /* Return/set the clock source.  */
 
-/* static void SetClkSrc( comedi_device *dev,struct enc_private *k, uint16_t value )  */
+/* static void SetClkSrc( struct comedi_device *dev,struct enc_private *k, uint16_t value )  */
 /* { */
 /*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKSRC ) | ( value << STDBIT_CLKSRC ) ), FALSE ); */
 /* } */
 
-/* static uint16_t GetClkSrc( comedi_device *dev,struct enc_private *k )  */
+/* static uint16_t GetClkSrc( struct comedi_device *dev,struct enc_private *k )  */
 /* { */
 /*   return ( k->GetMode(dev, k ) >> STDBIT_CLKSRC ) & 3; */
 /* } */
 
 /* Return/set the index polarity. */
 
-/* static void SetIndexPol(comedi_device *dev, struct enc_private *k, uint16_t value )  */
+/* static void SetIndexPol(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */
 /* { */
 /*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_INDXPOL ) | ( (value != 0) << STDBIT_INDXPOL ) ), FALSE ); */
 /* } */
 
-/* static uint16_t GetIndexPol(comedi_device *dev, struct enc_private *k )  */
+/* static uint16_t GetIndexPol(struct comedi_device *dev, struct enc_private *k )  */
 /* { */
 /*   return ( k->GetMode(dev, k ) >> STDBIT_INDXPOL ) & 1; */
 /* } */
 
 /*  Return/set the index source. */
 
-/* static void SetIndexSrc(comedi_device *dev, struct enc_private *k, uint16_t value )  */
+/* static void SetIndexSrc(struct comedi_device *dev, struct enc_private *k, uint16_t value )  */
 /* { */
 /*   DEBUG("SetIndexSrc: set index src enter 3700\n"); */
 /*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_INDXSRC ) | ( (value != 0) << STDBIT_INDXSRC ) ), FALSE ); */
 /* } */
 
-/* static uint16_t GetIndexSrc(comedi_device *dev, struct enc_private *k )  */
+/* static uint16_t GetIndexSrc(struct comedi_device *dev, struct enc_private *k )  */
 /* { */
 /*   return ( k->GetMode(dev, k ) >> STDBIT_INDXSRC ) & 1; */
 /* } */
 
 /*  Generate an index pulse. */
 
-static void PulseIndex_A(comedi_device *dev, struct enc_private *k)
+static void PulseIndex_A(struct comedi_device *dev, struct enc_private *k)
 {
 	register uint16_t cra;
 
@@ -3214,7 +3214,7 @@ static void PulseIndex_A(comedi_device *dev, struct enc_private *k)
 	DEBIwrite(dev, k->MyCRA, cra);
 }
 
-static void PulseIndex_B(comedi_device *dev, struct enc_private *k)
+static void PulseIndex_B(struct comedi_device *dev, struct enc_private *k)
 {
 	register uint16_t crb;
 
@@ -3225,7 +3225,7 @@ static void PulseIndex_B(comedi_device *dev, struct enc_private *k)
 
 /*  Write value into counter preload register. */
 
-static void Preload(comedi_device *dev, struct enc_private *k, uint32_t value)
+static void Preload(struct comedi_device *dev, struct enc_private *k, uint32_t value)
 {
 	DEBUG("Preload: preload enter\n");
 	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
@@ -3234,7 +3234,7 @@ static void Preload(comedi_device *dev, struct enc_private *k, uint32_t value)
 		(uint16_t) (value >> 16));
 }
 
-static void CountersInit(comedi_device *dev)
+static void CountersInit(struct comedi_device *dev)
 {
 	int chan;
 	struct enc_private *k;

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 9323fa00fbb8..a4f4de69da76 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -157,7 +157,7 @@ struct s626_private {
 	uint32_t I2CAdrs;
 	/* I2C device address for onboard EEPROM (board rev dependent). */
 	/*   short         I2Cards; */
-	lsampl_t ao_readback[S626_DAC_CHANNELS];
+	unsigned int ao_readback[S626_DAC_CHANNELS];
 };
 
 struct dio_private {
@@ -223,39 +223,39 @@ COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
 
 /* ioctl routines */
 static int s626_ai_insn_config(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data);
-/* static int s626_ai_rinsn(comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,lsampl_t *data); */
+	comedi_insn *insn, unsigned int *data);
+/* static int s626_ai_rinsn(comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,unsigned int *data); */
 static int s626_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data);
+	comedi_insn *insn, unsigned int *data);
 static int s626_ai_cmd(comedi_device *dev, comedi_subdevice *s);
 static int s626_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 	comedi_cmd *cmd);
 static int s626_ai_cancel(comedi_device *dev, comedi_subdevice *s);
 static int s626_ao_winsn(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data);
+	comedi_insn *insn, unsigned int *data);
 static int s626_ao_rinsn(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data);
+	comedi_insn *insn, unsigned int *data);
 static int s626_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data);
+	comedi_insn *insn, unsigned int *data);
 static int s626_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data);
+	comedi_insn *insn, unsigned int *data);
 static int s626_dio_set_irq(comedi_device *dev, unsigned int chan);
 static int s626_dio_reset_irq(comedi_device *dev, unsigned int gruop,
 	unsigned int mask);
 static int s626_dio_clear_irq(comedi_device *dev);
 static int s626_enc_insn_config(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data);
+	comedi_insn *insn, unsigned int *data);
 static int s626_enc_insn_read(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data);
+	comedi_insn *insn, unsigned int *data);
 static int s626_enc_insn_write(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data);
+	comedi_insn *insn, unsigned int *data);
 static int s626_ns_to_timer(int *nanosec, int round_mode);
 static int s626_ai_load_polllist(uint8_t *ppl, comedi_cmd *cmd);
 static int s626_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
 	unsigned int trignum);
 static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG);
-static lsampl_t s626_ai_reg_to_uint(int data);
-/* static lsampl_t s626_uint_to_reg(comedi_subdevice *s, int data); */
+static unsigned int s626_ai_reg_to_uint(int data);
+/* static unsigned int s626_uint_to_reg(comedi_subdevice *s, int data); */
 
 /* end ioctl routines */
 
@@ -951,9 +951,9 @@ static int s626_attach(comedi_device *dev, comedi_devconfig *it)
 	return 1;
 }
 
-static lsampl_t s626_ai_reg_to_uint(int data)
+static unsigned int s626_ai_reg_to_uint(int data)
 {
-	lsampl_t tempdata;
+	unsigned int tempdata;
 
 	tempdata = (data >> 18);
 	if (tempdata & 0x2000)
@@ -964,7 +964,7 @@ static lsampl_t s626_ai_reg_to_uint(int data)
 	return tempdata;
 }
 
-/* static lsampl_t s626_uint_to_reg(comedi_subdevice *s, int data){ */
+/* static unsigned int s626_uint_to_reg(comedi_subdevice *s, int data){ */
 /*   return 0; */
 /* } */
 
@@ -978,7 +978,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 	int32_t *readaddr;
 	uint32_t irqtype, irqstatus;
 	int i = 0;
-	sampl_t tempdata;
+	short tempdata;
 	uint8_t group;
 	uint16_t irqbit;
 
@@ -1504,13 +1504,13 @@ void ResetADC(comedi_device *dev, uint8_t *ppl)
 
 /* TO COMPLETE, IF NECESSARY */
 static int s626_ai_insn_config(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data)
+	comedi_insn *insn, unsigned int *data)
 {
 
 	return -EINVAL;
 }
 
-/* static int s626_ai_rinsn(comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,lsampl_t *data) */
+/* static int s626_ai_rinsn(comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,unsigned int *data) */
 /* { */
 /*   register uint8_t	i; */
 /*   register int32_t	*readaddr; */
@@ -1541,7 +1541,7 @@ static int s626_ai_insn_config(comedi_device *dev, comedi_subdevice *s,
 /* } */
 
 static int s626_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data)
+	comedi_insn *insn, unsigned int *data)
 {
 	uint16_t chan = CR_CHAN(insn->chanspec);
 	uint16_t range = CR_RANGE(insn->chanspec);
@@ -2046,7 +2046,7 @@ static int s626_ns_to_timer(int *nanosec, int round_mode)
 }
 
 static int s626_ao_winsn(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data)
+	comedi_insn *insn, unsigned int *data)
 {
 
 	int i;
@@ -2065,7 +2065,7 @@ static int s626_ao_winsn(comedi_device *dev, comedi_subdevice *s,
 }
 
 static int s626_ao_rinsn(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data)
+	comedi_insn *insn, unsigned int *data)
 {
 	int i;
 
@@ -2111,7 +2111,7 @@ static void s626_dio_init(comedi_device *dev)
  * core can convert between insn_bits and insn_read/write */
 
 static int s626_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data)
+	comedi_insn *insn, unsigned int *data)
 {
 
 	/* Length of data must be 2 (mask and new data, see below) */
@@ -2147,7 +2147,7 @@ static int s626_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
 }
 
 static int s626_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data)
+	comedi_insn *insn, unsigned int *data)
 {
 
 	switch (data[0]) {
@@ -2252,7 +2252,7 @@ static int s626_dio_clear_irq(comedi_device *dev)
    and set the subdevice. To complete with trigger and interrupt
    configuration */
 static int s626_enc_insn_config(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data)
+	comedi_insn *insn, unsigned int *data)
 {
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
 		/*  index. */
@@ -2282,7 +2282,7 @@ static int s626_enc_insn_config(comedi_device *dev, comedi_subdevice *s,
 }
 
 static int s626_enc_insn_read(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data)
+	comedi_insn *insn, unsigned int *data)
 {
 
 	int n;
@@ -2300,7 +2300,7 @@ static int s626_enc_insn_read(comedi_device *dev, comedi_subdevice *s,
 }
 
 static int s626_enc_insn_write(comedi_device *dev, comedi_subdevice *s,
-	comedi_insn *insn, lsampl_t *data)
+	comedi_insn *insn, unsigned int *data)
 {
 
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];

commit eb5e029ebacf37ccdcd25b804e005f7e69cd0a24
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:04:45 2009 -0400

    Staging: comedi: Remove s626_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index d447f466d333..9323fa00fbb8 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -82,7 +82,7 @@ MODULE_AUTHOR("Gianluca Palli <gpalli@deis.unibo.it>");
 MODULE_DESCRIPTION("Sensoray 626 Comedi driver module");
 MODULE_LICENSE("GPL");
 
-typedef struct s626_board_struct {
+struct s626_board {
 	const char *name;
 	int ai_chans;
 	int ai_bits;
@@ -91,9 +91,9 @@ typedef struct s626_board_struct {
 	int dio_chans;
 	int dio_banks;
 	int enc_chans;
-} s626_board;
+};
 
-static const s626_board s626_boards[] = {
+static const struct s626_board s626_boards[] = {
 	{
 	      name:	"s626",
 	      ai_chans : S626_ADC_CHANNELS,
@@ -106,7 +106,7 @@ static const s626_board s626_boards[] = {
 		}
 };
 
-#define thisboard ((const s626_board *)dev->board_ptr)
+#define thisboard ((const struct s626_board *)dev->board_ptr)
 #define PCI_VENDOR_ID_S626 0x1131
 #define PCI_DEVICE_ID_S626 0x7146
 
@@ -128,7 +128,7 @@ static comedi_driver driver_s626 = {
       detach : s626_detach,
 };
 
-typedef struct {
+struct s626_private {
 	struct pci_dev *pdev;
 	void *base_addr;
 	int got_regions;
@@ -158,9 +158,9 @@ typedef struct {
 	/* I2C device address for onboard EEPROM (board rev dependent). */
 	/*   short         I2Cards; */
 	lsampl_t ao_readback[S626_DAC_CHANNELS];
-} s626_private;
+};
 
-typedef struct {
+struct dio_private {
 	uint16_t RDDIn;
 	uint16_t WRDOut;
 	uint16_t RDEdgSel;
@@ -170,9 +170,9 @@ typedef struct {
 	uint16_t RDCapFlg;
 	uint16_t RDIntSel;
 	uint16_t WRIntSel;
-} dio_private;
+};
 
-static dio_private dio_private_A = {
+static struct dio_private dio_private_A = {
       RDDIn:LP_RDDINA,
       WRDOut : LP_WRDOUTA,
       RDEdgSel : LP_RDEDGSELA,
@@ -184,7 +184,7 @@ static dio_private dio_private_A = {
       WRIntSel : LP_WRINTSELA,
 };
 
-static dio_private dio_private_B = {
+static struct dio_private dio_private_B = {
       RDDIn:LP_RDDINB,
       WRDOut : LP_WRDOUTB,
       RDEdgSel : LP_RDEDGSELB,
@@ -196,7 +196,7 @@ static dio_private dio_private_B = {
       WRIntSel : LP_WRINTSELB,
 };
 
-static dio_private dio_private_C = {
+static struct dio_private dio_private_C = {
       RDDIn:LP_RDDINC,
       WRDOut : LP_WRDOUTC,
       RDEdgSel : LP_RDEDGSELC,
@@ -209,15 +209,15 @@ static dio_private dio_private_C = {
 };
 
 /* to group dio devices (48 bits mask and data are not allowed ???)
-static dio_private *dio_private_word[]={
+static struct dio_private *dio_private_word[]={
   &dio_private_A,
   &dio_private_B,
   &dio_private_C,
 };
 */
 
-#define devpriv ((s626_private *)dev->private)
-#define diopriv ((dio_private *)s->private)
+#define devpriv ((struct s626_private *)dev->private)
+#define diopriv ((struct dio_private *)s->private)
 
 COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
 
@@ -278,67 +278,67 @@ static void DEBIreplace(comedi_device *dev, uint16_t addr, uint16_t mask,
 static void CloseDMAB(comedi_device *dev, DMABUF *pdma, size_t bsize);
 
 /*  COUNTER OBJECT ------------------------------------------------ */
-typedef struct enc_private_struct {
+struct enc_private {
 	/*  Pointers to functions that differ for A and B counters: */
-	uint16_t(*GetEnable) (comedi_device *dev, struct enc_private_struct *);	/* Return clock enable. */
-	uint16_t(*GetIntSrc) (comedi_device *dev, struct enc_private_struct *);	/* Return interrupt source. */
-	uint16_t(*GetLoadTrig) (comedi_device *dev, struct enc_private_struct *);	/* Return preload trigger source. */
-	uint16_t(*GetMode) (comedi_device *dev, struct enc_private_struct *);	/* Return standardized operating mode. */
-	void (*PulseIndex) (comedi_device *dev, struct enc_private_struct *);	/* Generate soft index strobe. */
-	void (*SetEnable) (comedi_device *dev, struct enc_private_struct *, uint16_t enab);	/* Program clock enable. */
-	void (*SetIntSrc) (comedi_device *dev, struct enc_private_struct *, uint16_t IntSource);	/* Program interrupt source. */
-	void (*SetLoadTrig) (comedi_device *dev, struct enc_private_struct *, uint16_t Trig);	/* Program preload trigger source. */
-	void (*SetMode) (comedi_device *dev, struct enc_private_struct *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
-	void (*ResetCapFlags) (comedi_device *dev, struct enc_private_struct *);	/* Reset event capture flags. */
+	uint16_t(*GetEnable) (comedi_device *dev, struct enc_private *);	/* Return clock enable. */
+	uint16_t(*GetIntSrc) (comedi_device *dev, struct enc_private *);	/* Return interrupt source. */
+	uint16_t(*GetLoadTrig) (comedi_device *dev, struct enc_private *);	/* Return preload trigger source. */
+	uint16_t(*GetMode) (comedi_device *dev, struct enc_private *);	/* Return standardized operating mode. */
+	void (*PulseIndex) (comedi_device *dev, struct enc_private *);	/* Generate soft index strobe. */
+	void (*SetEnable) (comedi_device *dev, struct enc_private *, uint16_t enab);	/* Program clock enable. */
+	void (*SetIntSrc) (comedi_device *dev, struct enc_private *, uint16_t IntSource);	/* Program interrupt source. */
+	void (*SetLoadTrig) (comedi_device *dev, struct enc_private *, uint16_t Trig);	/* Program preload trigger source. */
+	void (*SetMode) (comedi_device *dev, struct enc_private *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
+	void (*ResetCapFlags) (comedi_device *dev, struct enc_private *);	/* Reset event capture flags. */
 
 	uint16_t MyCRA;		/*    Address of CRA register. */
 	uint16_t MyCRB;		/*    Address of CRB register. */
 	uint16_t MyLatchLsw;	/*    Address of Latch least-significant-word */
 	/*    register. */
 	uint16_t MyEventBits[4];	/*    Bit translations for IntSrc -->RDMISC2. */
-} enc_private;			/* counter object */
+};
 
-#define encpriv ((enc_private *)(dev->subdevices+5)->private)
+#define encpriv ((struct enc_private *)(dev->subdevices+5)->private)
 
 /* counters routines */
-static void s626_timer_load(comedi_device *dev, enc_private *k, int tick);
-static uint32_t ReadLatch(comedi_device *dev, enc_private *k);
-static void ResetCapFlags_A(comedi_device *dev, enc_private *k);
-static void ResetCapFlags_B(comedi_device *dev, enc_private *k);
-static uint16_t GetMode_A(comedi_device *dev, enc_private *k);
-static uint16_t GetMode_B(comedi_device *dev, enc_private *k);
-static void SetMode_A(comedi_device *dev, enc_private *k, uint16_t Setup,
+static void s626_timer_load(comedi_device *dev, struct enc_private *k, int tick);
+static uint32_t ReadLatch(comedi_device *dev, struct enc_private *k);
+static void ResetCapFlags_A(comedi_device *dev, struct enc_private *k);
+static void ResetCapFlags_B(comedi_device *dev, struct enc_private *k);
+static uint16_t GetMode_A(comedi_device *dev, struct enc_private *k);
+static uint16_t GetMode_B(comedi_device *dev, struct enc_private *k);
+static void SetMode_A(comedi_device *dev, struct enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc);
-static void SetMode_B(comedi_device *dev, enc_private *k, uint16_t Setup,
+static void SetMode_B(comedi_device *dev, struct enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc);
-static void SetEnable_A(comedi_device *dev, enc_private *k, uint16_t enab);
-static void SetEnable_B(comedi_device *dev, enc_private *k, uint16_t enab);
-static uint16_t GetEnable_A(comedi_device *dev, enc_private *k);
-static uint16_t GetEnable_B(comedi_device *dev, enc_private *k);
-static void SetLatchSource(comedi_device *dev, enc_private *k,
+static void SetEnable_A(comedi_device *dev, struct enc_private *k, uint16_t enab);
+static void SetEnable_B(comedi_device *dev, struct enc_private *k, uint16_t enab);
+static uint16_t GetEnable_A(comedi_device *dev, struct enc_private *k);
+static uint16_t GetEnable_B(comedi_device *dev, struct enc_private *k);
+static void SetLatchSource(comedi_device *dev, struct enc_private *k,
 	uint16_t value);
-/* static uint16_t GetLatchSource(comedi_device *dev, enc_private *k ); */
-static void SetLoadTrig_A(comedi_device *dev, enc_private *k, uint16_t Trig);
-static void SetLoadTrig_B(comedi_device *dev, enc_private *k, uint16_t Trig);
-static uint16_t GetLoadTrig_A(comedi_device *dev, enc_private *k);
-static uint16_t GetLoadTrig_B(comedi_device *dev, enc_private *k);
-static void SetIntSrc_B(comedi_device *dev, enc_private *k,
+/* static uint16_t GetLatchSource(comedi_device *dev, struct enc_private *k ); */
+static void SetLoadTrig_A(comedi_device *dev, struct enc_private *k, uint16_t Trig);
+static void SetLoadTrig_B(comedi_device *dev, struct enc_private *k, uint16_t Trig);
+static uint16_t GetLoadTrig_A(comedi_device *dev, struct enc_private *k);
+static uint16_t GetLoadTrig_B(comedi_device *dev, struct enc_private *k);
+static void SetIntSrc_B(comedi_device *dev, struct enc_private *k,
 	uint16_t IntSource);
-static void SetIntSrc_A(comedi_device *dev, enc_private *k,
+static void SetIntSrc_A(comedi_device *dev, struct enc_private *k,
 	uint16_t IntSource);
-static uint16_t GetIntSrc_A(comedi_device *dev, enc_private *k);
-static uint16_t GetIntSrc_B(comedi_device *dev, enc_private *k);
-/* static void SetClkMult(comedi_device *dev, enc_private *k, uint16_t value ) ; */
-/* static uint16_t GetClkMult(comedi_device *dev, enc_private *k ) ; */
-/* static void SetIndexPol(comedi_device *dev, enc_private *k, uint16_t value ); */
-/* static uint16_t GetClkPol(comedi_device *dev, enc_private *k ) ; */
-/* static void SetIndexSrc( comedi_device *dev,enc_private *k, uint16_t value );  */
-/* static uint16_t GetClkSrc( comedi_device *dev,enc_private *k );  */
-/* static void SetIndexSrc( comedi_device *dev,enc_private *k, uint16_t value );  */
-/* static uint16_t GetIndexSrc( comedi_device *dev,enc_private *k );  */
-static void PulseIndex_A(comedi_device *dev, enc_private *k);
-static void PulseIndex_B(comedi_device *dev, enc_private *k);
-static void Preload(comedi_device *dev, enc_private *k, uint32_t value);
+static uint16_t GetIntSrc_A(comedi_device *dev, struct enc_private *k);
+static uint16_t GetIntSrc_B(comedi_device *dev, struct enc_private *k);
+/* static void SetClkMult(comedi_device *dev, struct enc_private *k, uint16_t value ) ; */
+/* static uint16_t GetClkMult(comedi_device *dev, struct enc_private *k ) ; */
+/* static void SetIndexPol(comedi_device *dev, struct enc_private *k, uint16_t value ); */
+/* static uint16_t GetClkPol(comedi_device *dev, struct enc_private *k ) ; */
+/* static void SetIndexSrc( comedi_device *dev,struct enc_private *k, uint16_t value );  */
+/* static uint16_t GetClkSrc( comedi_device *dev,struct enc_private *k );  */
+/* static void SetIndexSrc( comedi_device *dev,struct enc_private *k, uint16_t value );  */
+/* static uint16_t GetIndexSrc( comedi_device *dev,struct enc_private *k );  */
+static void PulseIndex_A(comedi_device *dev, struct enc_private *k);
+static void PulseIndex_B(comedi_device *dev, struct enc_private *k);
+static void Preload(comedi_device *dev, struct enc_private *k, uint32_t value);
 static void CountersInit(comedi_device *dev);
 /* end internal routines */
 
@@ -352,8 +352,8 @@ static void CountersInit(comedi_device *dev);
 /*  Translation table to map IntSrc into equivalent RDMISC2 event flag  bits. */
 /* static const uint16_t EventBits[][4] = { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) }; */
 
-/* enc_private; */
-static enc_private enc_private_data[] = {
+/* struct enc_private; */
+static struct enc_private enc_private_data[] = {
 	{
 	      GetEnable:GetEnable_A,
 	      GetIntSrc : GetIntSrc_A,
@@ -500,7 +500,7 @@ static int s626_attach(comedi_device *dev, comedi_devconfig *it)
 	comedi_subdevice *s;
 	struct pci_dev *pdev;
 
-	if (alloc_private(dev, sizeof(s626_private)) < 0)
+	if (alloc_private(dev, sizeof(struct s626_private)) < 0)
 		return -ENOMEM;
 
 	for (pdev = pci_get_device(PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626,
@@ -973,7 +973,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 	comedi_device *dev = d;
 	comedi_subdevice *s;
 	comedi_cmd *cmd;
-	enc_private *k;
+	struct enc_private *k;
 	unsigned long flags;
 	int32_t *readaddr;
 	uint32_t irqtype, irqstatus;
@@ -1078,7 +1078,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 			irqbit = 0;
 			/* read interrupt type */
 			irqbit = DEBIread(dev,
-				((dio_private *) (dev->subdevices + 2 +
+				((struct dio_private *) (dev->subdevices + 2 +
 						group)->private)->RDCapFlg);
 
 			/* check if interrupt is generated from dio channels */
@@ -1678,7 +1678,7 @@ static int s626_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 
 	uint8_t ppl[16];
 	comedi_cmd *cmd = &s->async->cmd;
-	enc_private *k;
+	struct enc_private *k;
 	int tick;
 
 	DEBUG("s626_ai_cmd: entering command function\n");
@@ -2187,18 +2187,18 @@ static int s626_dio_set_irq(comedi_device *dev, unsigned int chan)
 
 	/* set channel to capture positive edge */
 	status = DEBIread(dev,
-		((dio_private *) (dev->subdevices + 2 +
+		((struct dio_private *) (dev->subdevices + 2 +
 				group)->private)->RDEdgSel);
 	DEBIwrite(dev,
-		((dio_private *) (dev->subdevices + 2 +
+		((struct dio_private *) (dev->subdevices + 2 +
 				group)->private)->WREdgSel, bitmask | status);
 
 	/* enable interrupt on selected channel */
 	status = DEBIread(dev,
-		((dio_private *) (dev->subdevices + 2 +
+		((struct dio_private *) (dev->subdevices + 2 +
 				group)->private)->RDIntSel);
 	DEBIwrite(dev,
-		((dio_private *) (dev->subdevices + 2 +
+		((struct dio_private *) (dev->subdevices + 2 +
 				group)->private)->WRIntSel, bitmask | status);
 
 	/* enable edge capture write command */
@@ -2206,10 +2206,10 @@ static int s626_dio_set_irq(comedi_device *dev, unsigned int chan)
 
 	/* enable edge capture on selected channel */
 	status = DEBIread(dev,
-		((dio_private *) (dev->subdevices + 2 +
+		((struct dio_private *) (dev->subdevices + 2 +
 				group)->private)->RDCapSel);
 	DEBIwrite(dev,
-		((dio_private *) (dev->subdevices + 2 +
+		((struct dio_private *) (dev->subdevices + 2 +
 				group)->private)->WRCapSel, bitmask | status);
 
 	return 0;
@@ -2225,7 +2225,7 @@ static int s626_dio_reset_irq(comedi_device *dev, unsigned int group,
 
 	/* enable edge capture on selected channel */
 	DEBIwrite(dev,
-		((dio_private *) (dev->subdevices + 2 +
+		((struct dio_private *) (dev->subdevices + 2 +
 				group)->private)->WRCapSel, mask);
 
 	return 0;
@@ -2241,7 +2241,7 @@ static int s626_dio_clear_irq(comedi_device *dev)
 	for (group = 0; group < S626_DIO_BANKS; group++) {
 		/* clear pending events and interrupt */
 		DEBIwrite(dev,
-			((dio_private *) (dev->subdevices + 2 +
+			((struct dio_private *) (dev->subdevices + 2 +
 					group)->private)->WRCapSel, 0xffff);
 	}
 
@@ -2266,7 +2266,7 @@ static int s626_enc_insn_config(comedi_device *dev, comedi_subdevice *s,
 	/*  uint32_t Preloadvalue;              //Counter initial value */
 	uint16_t valueSrclatch = LATCHSRC_AB_READ;
 	uint16_t enab = CLKENAB_ALWAYS;
-	enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
+	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
 	DEBUG("s626_enc_insn_config: encoder config\n");
 
@@ -2286,7 +2286,7 @@ static int s626_enc_insn_read(comedi_device *dev, comedi_subdevice *s,
 {
 
 	int n;
-	enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
+	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
 	DEBUG("s626_enc_insn_read: encoder read channel %d \n",
 		CR_CHAN(insn->chanspec));
@@ -2303,7 +2303,7 @@ static int s626_enc_insn_write(comedi_device *dev, comedi_subdevice *s,
 	comedi_insn *insn, lsampl_t *data)
 {
 
-	enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
+	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
 	DEBUG("s626_enc_insn_write: encoder write channel %d \n",
 		CR_CHAN(insn->chanspec));
@@ -2322,7 +2322,7 @@ static int s626_enc_insn_write(comedi_device *dev, comedi_subdevice *s,
 	return 1;
 }
 
-static void s626_timer_load(comedi_device *dev, enc_private *k, int tick)
+static void s626_timer_load(comedi_device *dev, struct enc_private *k, int tick)
 {
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
 		/*  index. */
@@ -2768,7 +2768,7 @@ static void CloseDMAB(comedi_device *dev, DMABUF *pdma, size_t bsize)
 
 /*  Read a counter's output latch. */
 
-static uint32_t ReadLatch(comedi_device *dev, enc_private *k)
+static uint32_t ReadLatch(comedi_device *dev, struct enc_private *k)
 {
 	register uint32_t value;
 	/* DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n"); */
@@ -2787,13 +2787,13 @@ static uint32_t ReadLatch(comedi_device *dev, enc_private *k)
 
 /*  Reset a counter's index and overflow event capture flags. */
 
-static void ResetCapFlags_A(comedi_device *dev, enc_private *k)
+static void ResetCapFlags_A(comedi_device *dev, struct enc_private *k)
 {
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 }
 
-static void ResetCapFlags_B(comedi_device *dev, enc_private *k)
+static void ResetCapFlags_B(comedi_device *dev, struct enc_private *k)
 {
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
@@ -2802,7 +2802,7 @@ static void ResetCapFlags_B(comedi_device *dev, enc_private *k)
 /*  Return counter setup in a format (COUNTER_SETUP) that is consistent */
 /*  for both A and B counters. */
 
-static uint16_t GetMode_A(comedi_device *dev, enc_private *k)
+static uint16_t GetMode_A(comedi_device *dev, struct enc_private *k)
 {
 	register uint16_t cra;
 	register uint16_t crb;
@@ -2840,7 +2840,7 @@ static uint16_t GetMode_A(comedi_device *dev, enc_private *k)
 	return setup;
 }
 
-static uint16_t GetMode_B(comedi_device *dev, enc_private *k)
+static uint16_t GetMode_B(comedi_device *dev, struct enc_private *k)
 {
 	register uint16_t cra;
 	register uint16_t crb;
@@ -2886,7 +2886,7 @@ static uint16_t GetMode_B(comedi_device *dev, enc_private *k)
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
 
-static void SetMode_A(comedi_device *dev, enc_private *k, uint16_t Setup,
+static void SetMode_A(comedi_device *dev, struct enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
@@ -2944,7 +2944,7 @@ static void SetMode_A(comedi_device *dev, enc_private *k, uint16_t Setup,
 		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
 }
 
-static void SetMode_B(comedi_device *dev, enc_private *k, uint16_t Setup,
+static void SetMode_B(comedi_device *dev, struct enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
@@ -3008,7 +3008,7 @@ static void SetMode_B(comedi_device *dev, enc_private *k, uint16_t Setup,
 
 /*  Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index. */
 
-static void SetEnable_A(comedi_device *dev, enc_private *k, uint16_t enab)
+static void SetEnable_A(comedi_device *dev, struct enc_private *k, uint16_t enab)
 {
 	DEBUG("SetEnable_A: SetEnable_A enter 3541\n");
 	DEBIreplace(dev, k->MyCRB,
@@ -3016,19 +3016,19 @@ static void SetEnable_A(comedi_device *dev, enc_private *k, uint16_t enab)
 		(uint16_t) (enab << CRBBIT_CLKENAB_A));
 }
 
-static void SetEnable_B(comedi_device *dev, enc_private *k, uint16_t enab)
+static void SetEnable_B(comedi_device *dev, struct enc_private *k, uint16_t enab)
 {
 	DEBIreplace(dev, k->MyCRB,
 		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),
 		(uint16_t) (enab << CRBBIT_CLKENAB_B));
 }
 
-static uint16_t GetEnable_A(comedi_device *dev, enc_private *k)
+static uint16_t GetEnable_A(comedi_device *dev, struct enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_A) & 1;
 }
 
-static uint16_t GetEnable_B(comedi_device *dev, enc_private *k)
+static uint16_t GetEnable_B(comedi_device *dev, struct enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_B) & 1;
 }
@@ -3038,7 +3038,7 @@ static uint16_t GetEnable_B(comedi_device *dev, enc_private *k)
  * latches B.
  */
 
-static void SetLatchSource(comedi_device *dev, enc_private *k, uint16_t value)
+static void SetLatchSource(comedi_device *dev, struct enc_private *k, uint16_t value)
 {
 	DEBUG("SetLatchSource: SetLatchSource enter 3550 \n");
 	DEBIreplace(dev, k->MyCRB,
@@ -3049,7 +3049,7 @@ static void SetLatchSource(comedi_device *dev, enc_private *k, uint16_t value)
 }
 
 /*
- * static uint16_t GetLatchSource(comedi_device *dev, enc_private *k )
+ * static uint16_t GetLatchSource(comedi_device *dev, struct enc_private *k )
  * {
  * 	return ( DEBIread( dev, k->MyCRB) >> CRBBIT_LATCHSRC ) & 3;
  * }
@@ -3061,25 +3061,25 @@ static void SetLatchSource(comedi_device *dev, enc_private *k, uint16_t value)
  * 2=OverflowA (B counters only), 3=disabled.
  */
 
-static void SetLoadTrig_A(comedi_device *dev, enc_private *k, uint16_t Trig)
+static void SetLoadTrig_A(comedi_device *dev, struct enc_private *k, uint16_t Trig)
 {
 	DEBIreplace(dev, k->MyCRA, (uint16_t) (~CRAMSK_LOADSRC_A),
 		(uint16_t) (Trig << CRABIT_LOADSRC_A));
 }
 
-static void SetLoadTrig_B(comedi_device *dev, enc_private *k, uint16_t Trig)
+static void SetLoadTrig_B(comedi_device *dev, struct enc_private *k, uint16_t Trig)
 {
 	DEBIreplace(dev, k->MyCRB,
 		(uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),
 		(uint16_t) (Trig << CRBBIT_LOADSRC_B));
 }
 
-static uint16_t GetLoadTrig_A(comedi_device *dev, enc_private *k)
+static uint16_t GetLoadTrig_A(comedi_device *dev, struct enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRA) >> CRABIT_LOADSRC_A) & 3;
 }
 
-static uint16_t GetLoadTrig_B(comedi_device *dev, enc_private *k)
+static uint16_t GetLoadTrig_B(comedi_device *dev, struct enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_LOADSRC_B) & 3;
 }
@@ -3089,7 +3089,7 @@ static uint16_t GetLoadTrig_B(comedi_device *dev, enc_private *k)
  * 2=IndexOnly, 3=IndexAndOverflow.
  */
 
-static void SetIntSrc_A(comedi_device *dev, enc_private *k,
+static void SetIntSrc_A(comedi_device *dev, struct enc_private *k,
 	uint16_t IntSource)
 {
 	/*  Reset any pending counter overflow or index captures. */
@@ -3106,7 +3106,7 @@ static void SetIntSrc_A(comedi_device *dev, enc_private *k,
 		MyEventBits[IntSource];
 }
 
-static void SetIntSrc_B(comedi_device *dev, enc_private *k,
+static void SetIntSrc_B(comedi_device *dev, struct enc_private *k,
 	uint16_t IntSource)
 {
 	uint16_t crb;
@@ -3129,80 +3129,80 @@ static void SetIntSrc_B(comedi_device *dev, enc_private *k,
 		MyEventBits[IntSource];
 }
 
-static uint16_t GetIntSrc_A(comedi_device *dev, enc_private *k)
+static uint16_t GetIntSrc_A(comedi_device *dev, struct enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRA) >> CRABIT_INTSRC_A) & 3;
 }
 
-static uint16_t GetIntSrc_B(comedi_device *dev, enc_private *k)
+static uint16_t GetIntSrc_B(comedi_device *dev, struct enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_INTSRC_B) & 3;
 }
 
 /*  Return/set the clock multiplier. */
 
-/* static void SetClkMult(comedi_device *dev, enc_private *k, uint16_t value )  */
+/* static void SetClkMult(comedi_device *dev, struct enc_private *k, uint16_t value )  */
 /* { */
 /*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKMULT ) | ( value << STDBIT_CLKMULT ) ), FALSE ); */
 /* } */
 
-/* static uint16_t GetClkMult(comedi_device *dev, enc_private *k )  */
+/* static uint16_t GetClkMult(comedi_device *dev, struct enc_private *k )  */
 /* { */
 /*   return ( k->GetMode(dev, k ) >> STDBIT_CLKMULT ) & 3; */
 /* } */
 
 /* Return/set the clock polarity. */
 
-/* static void SetClkPol( comedi_device *dev,enc_private *k, uint16_t value )  */
+/* static void SetClkPol( comedi_device *dev,struct enc_private *k, uint16_t value )  */
 /* { */
 /*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKPOL ) | ( value << STDBIT_CLKPOL ) ), FALSE ); */
 /* } */
 
-/* static uint16_t GetClkPol(comedi_device *dev, enc_private *k )  */
+/* static uint16_t GetClkPol(comedi_device *dev, struct enc_private *k )  */
 /* { */
 /*   return ( k->GetMode(dev, k ) >> STDBIT_CLKPOL ) & 1; */
 /* } */
 
 /* Return/set the clock source.  */
 
-/* static void SetClkSrc( comedi_device *dev,enc_private *k, uint16_t value )  */
+/* static void SetClkSrc( comedi_device *dev,struct enc_private *k, uint16_t value )  */
 /* { */
 /*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKSRC ) | ( value << STDBIT_CLKSRC ) ), FALSE ); */
 /* } */
 
-/* static uint16_t GetClkSrc( comedi_device *dev,enc_private *k )  */
+/* static uint16_t GetClkSrc( comedi_device *dev,struct enc_private *k )  */
 /* { */
 /*   return ( k->GetMode(dev, k ) >> STDBIT_CLKSRC ) & 3; */
 /* } */
 
 /* Return/set the index polarity. */
 
-/* static void SetIndexPol(comedi_device *dev, enc_private *k, uint16_t value )  */
+/* static void SetIndexPol(comedi_device *dev, struct enc_private *k, uint16_t value )  */
 /* { */
 /*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_INDXPOL ) | ( (value != 0) << STDBIT_INDXPOL ) ), FALSE ); */
 /* } */
 
-/* static uint16_t GetIndexPol(comedi_device *dev, enc_private *k )  */
+/* static uint16_t GetIndexPol(comedi_device *dev, struct enc_private *k )  */
 /* { */
 /*   return ( k->GetMode(dev, k ) >> STDBIT_INDXPOL ) & 1; */
 /* } */
 
 /*  Return/set the index source. */
 
-/* static void SetIndexSrc(comedi_device *dev, enc_private *k, uint16_t value )  */
+/* static void SetIndexSrc(comedi_device *dev, struct enc_private *k, uint16_t value )  */
 /* { */
 /*   DEBUG("SetIndexSrc: set index src enter 3700\n"); */
 /*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_INDXSRC ) | ( (value != 0) << STDBIT_INDXSRC ) ), FALSE ); */
 /* } */
 
-/* static uint16_t GetIndexSrc(comedi_device *dev, enc_private *k )  */
+/* static uint16_t GetIndexSrc(comedi_device *dev, struct enc_private *k )  */
 /* { */
 /*   return ( k->GetMode(dev, k ) >> STDBIT_INDXSRC ) & 1; */
 /* } */
 
 /*  Generate an index pulse. */
 
-static void PulseIndex_A(comedi_device *dev, enc_private *k)
+static void PulseIndex_A(comedi_device *dev, struct enc_private *k)
 {
 	register uint16_t cra;
 
@@ -3214,7 +3214,7 @@ static void PulseIndex_A(comedi_device *dev, enc_private *k)
 	DEBIwrite(dev, k->MyCRA, cra);
 }
 
-static void PulseIndex_B(comedi_device *dev, enc_private *k)
+static void PulseIndex_B(comedi_device *dev, struct enc_private *k)
 {
 	register uint16_t crb;
 
@@ -3225,7 +3225,7 @@ static void PulseIndex_B(comedi_device *dev, enc_private *k)
 
 /*  Write value into counter preload register. */
 
-static void Preload(comedi_device *dev, enc_private *k, uint32_t value)
+static void Preload(comedi_device *dev, struct enc_private *k, uint32_t value)
 {
 	DEBUG("Preload: preload enter\n");
 	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
@@ -3237,7 +3237,7 @@ static void Preload(comedi_device *dev, enc_private *k, uint32_t value)
 static void CountersInit(comedi_device *dev)
 {
 	int chan;
-	enc_private *k;
+	struct enc_private *k;
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
 		/*  index. */
 		(INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */

commit 82675f3547ba2a0732beabd9bb4393535f74408c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:04:23 2009 -0400

    Staging: comedi: Remove curly braces where they are not needed
    
    Changes as suggested by checkpatch.pl.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 22b1e72a9f71..d447f466d333 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -1290,18 +1290,15 @@ static int s626_detach(comedi_device *dev)
 			CloseDMAB(dev, &devpriv->ANABuf, DMABUF_SIZE);
 		}
 
-		if (dev->irq) {
+		if (dev->irq)
 			comedi_free_irq(dev->irq, dev);
-		}
 
-		if (devpriv->base_addr) {
+		if (devpriv->base_addr)
 			iounmap(devpriv->base_addr);
-		}
 
 		if (devpriv->pdev) {
-			if (devpriv->got_regions) {
+			if (devpriv->got_regions)
 				comedi_pci_disable(devpriv->pdev);
-			}
 			pci_dev_put(devpriv->pdev);
 		}
 	}
@@ -2072,9 +2069,8 @@ static int s626_ao_rinsn(comedi_device *dev, comedi_subdevice *s,
 {
 	int i;
 
-	for (i = 0; i < insn->n; i++) {
+	for (i = 0; i < insn->n; i++)
 		data[i] = devpriv->ao_readback[CR_CHAN(insn->chanspec)];
-	}
 
 	return i;
 }
@@ -2119,9 +2115,9 @@ static int s626_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
 {
 
 	/* Length of data must be 2 (mask and new data, see below) */
-	if (insn->n == 0) {
+	if (insn->n == 0)
 		return 0;
-	}
+
 	if (insn->n != 2) {
 		printk("comedi%d: s626: s626_dio_insn_bits(): Invalid instruction length\n", dev->minor);
 		return -EINVAL;

commit a87e4f5a4a7be43e610399ebcbb09ba3da021094
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:04:07 2009 -0400

    Staging: comedi: Add spaces around colons as requested by checkpatch
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index ff6118e8ad4a..22b1e72a9f71 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -358,15 +358,15 @@ static enc_private enc_private_data[] = {
 	      GetEnable:GetEnable_A,
 	      GetIntSrc : GetIntSrc_A,
 	      GetLoadTrig : GetLoadTrig_A,
-	      GetMode:	GetMode_A,
+	      GetMode :	GetMode_A,
 	      PulseIndex : PulseIndex_A,
 	      SetEnable : SetEnable_A,
 	      SetIntSrc : SetIntSrc_A,
 	      SetLoadTrig : SetLoadTrig_A,
-	      SetMode:	SetMode_A,
+	      SetMode :	SetMode_A,
 	      ResetCapFlags : ResetCapFlags_A,
-	      MyCRA:	LP_CR0A,
-	      MyCRB:	LP_CR0B,
+	      MyCRA :	LP_CR0A,
+	      MyCRB :	LP_CR0B,
 	      MyLatchLsw : LP_CNTR0ALSW,
 	      MyEventBits : EVBITS(0),
 		},
@@ -374,15 +374,15 @@ static enc_private enc_private_data[] = {
 	      GetEnable:GetEnable_A,
 	      GetIntSrc : GetIntSrc_A,
 	      GetLoadTrig : GetLoadTrig_A,
-	      GetMode:	GetMode_A,
+	      GetMode :	GetMode_A,
 	      PulseIndex : PulseIndex_A,
 	      SetEnable : SetEnable_A,
 	      SetIntSrc : SetIntSrc_A,
 	      SetLoadTrig : SetLoadTrig_A,
-	      SetMode:	SetMode_A,
+	      SetMode :	SetMode_A,
 	      ResetCapFlags : ResetCapFlags_A,
-	      MyCRA:	LP_CR1A,
-	      MyCRB:	LP_CR1B,
+	      MyCRA :	LP_CR1A,
+	      MyCRB :	LP_CR1B,
 	      MyLatchLsw : LP_CNTR1ALSW,
 	      MyEventBits : EVBITS(1),
 		},
@@ -390,15 +390,15 @@ static enc_private enc_private_data[] = {
 	      GetEnable:GetEnable_A,
 	      GetIntSrc : GetIntSrc_A,
 	      GetLoadTrig : GetLoadTrig_A,
-	      GetMode:	GetMode_A,
+	      GetMode :	GetMode_A,
 	      PulseIndex : PulseIndex_A,
 	      SetEnable : SetEnable_A,
 	      SetIntSrc : SetIntSrc_A,
 	      SetLoadTrig : SetLoadTrig_A,
-	      SetMode:	SetMode_A,
+	      SetMode :	SetMode_A,
 	      ResetCapFlags : ResetCapFlags_A,
-	      MyCRA:	LP_CR2A,
-	      MyCRB:	LP_CR2B,
+	      MyCRA :	LP_CR2A,
+	      MyCRB :	LP_CR2B,
 	      MyLatchLsw : LP_CNTR2ALSW,
 	      MyEventBits : EVBITS(2),
 		},
@@ -406,15 +406,15 @@ static enc_private enc_private_data[] = {
 	      GetEnable:GetEnable_B,
 	      GetIntSrc : GetIntSrc_B,
 	      GetLoadTrig : GetLoadTrig_B,
-	      GetMode:	GetMode_B,
+	      GetMode :	GetMode_B,
 	      PulseIndex : PulseIndex_B,
 	      SetEnable : SetEnable_B,
 	      SetIntSrc : SetIntSrc_B,
 	      SetLoadTrig : SetLoadTrig_B,
-	      SetMode:	SetMode_B,
+	      SetMode :	SetMode_B,
 	      ResetCapFlags : ResetCapFlags_B,
-	      MyCRA:	LP_CR0A,
-	      MyCRB:	LP_CR0B,
+	      MyCRA :	LP_CR0A,
+	      MyCRB :	LP_CR0B,
 	      MyLatchLsw : LP_CNTR0BLSW,
 	      MyEventBits : EVBITS(3),
 		},
@@ -422,15 +422,15 @@ static enc_private enc_private_data[] = {
 	      GetEnable:GetEnable_B,
 	      GetIntSrc : GetIntSrc_B,
 	      GetLoadTrig : GetLoadTrig_B,
-	      GetMode:	GetMode_B,
+	      GetMode :	GetMode_B,
 	      PulseIndex : PulseIndex_B,
 	      SetEnable : SetEnable_B,
 	      SetIntSrc : SetIntSrc_B,
 	      SetLoadTrig : SetLoadTrig_B,
-	      SetMode:	SetMode_B,
+	      SetMode :	SetMode_B,
 	      ResetCapFlags : ResetCapFlags_B,
-	      MyCRA:	LP_CR1A,
-	      MyCRB:	LP_CR1B,
+	      MyCRA :	LP_CR1A,
+	      MyCRB :	LP_CR1B,
 	      MyLatchLsw : LP_CNTR1BLSW,
 	      MyEventBits : EVBITS(4),
 		},
@@ -438,15 +438,15 @@ static enc_private enc_private_data[] = {
 	      GetEnable:GetEnable_B,
 	      GetIntSrc : GetIntSrc_B,
 	      GetLoadTrig : GetLoadTrig_B,
-	      GetMode:	GetMode_B,
+	      GetMode :	GetMode_B,
 	      PulseIndex : PulseIndex_B,
 	      SetEnable : SetEnable_B,
 	      SetIntSrc : SetIntSrc_B,
 	      SetLoadTrig : SetLoadTrig_B,
-	      SetMode:	SetMode_B,
+	      SetMode :	SetMode_B,
 	      ResetCapFlags : ResetCapFlags_B,
-	      MyCRA:	LP_CR2A,
-	      MyCRB:	LP_CR2B,
+	      MyCRA :	LP_CR2A,
+	      MyCRB :	LP_CR2B,
 	      MyLatchLsw : LP_CNTR2BLSW,
 	      MyEventBits : EVBITS(5),
 		},

commit f10fe5742ba6ad6a2219cbe774e1b9d3db0ef23d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:04:02 2009 -0400

    Staging: comedi: Fix cases of open curly on wrong line
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 26cc41073b0b..ff6118e8ad4a 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -2431,8 +2431,7 @@ static uint8_t I2Cread(comedi_device *dev, uint8_t addr)
 			 /* Byte2 = I2C command: write to I2C EEPROM  device. */
 			| I2C_B1(I2C_ATTRSTOP, addr)
 			 /* Byte1 = EEPROM internal target address. */
-			| I2C_B0(I2C_ATTRNOP, 0)))	/*  Byte0 = Not sent. */
-	{
+			| I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not sent. */
 		/*  Abort function and declare error if handshake failed. */
 		DEBUG("I2Cread: error handshake I2Cread  a\n");
 		return 0;
@@ -2445,9 +2444,8 @@ static uint8_t I2Cread(comedi_device *dev, uint8_t addr)
 			| I2C_B1(I2C_ATTRSTOP, 0)	/*  Byte1 receives */
 			/*  uint8_t from */
 			/*  EEPROM. */
-			| I2C_B0(I2C_ATTRNOP, 0)))	/*  Byte0 = Not */
-		/*  sent. */
-	{
+			| I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not  sent. */
+
 		/*  Abort function and declare error if handshake failed. */
 		DEBUG("I2Cread: error handshake I2Cread b\n");
 		return 0;

commit c7427409cd071a34c4a13c5c24531b7a10334e31
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:03:56 2009 -0400

    Staging: comedi: Move trailing statements to next line as requested by checkpatch
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 9110ae3c7fec..26cc41073b0b 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -749,7 +749,8 @@ static int s626_attach(comedi_device *dev, comedi_devconfig *it)
 		/*  Write I2C control: abort any I2C activity. */
 		MC_ENABLE(P_MC2, MC2_UPLD_IIC);
 		/*  Invoke command  upload */
-		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0);
+		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)
+			;
 		/*  and wait for upload to complete. */
 
 		/* Per SAA7146 data sheet, write to STATUS reg twice to
@@ -758,7 +759,8 @@ static int s626_attach(comedi_device *dev, comedi_devconfig *it)
 			WR7146(P_I2CSTAT, I2C_CLKSEL);
 			/*  Write I2C control: reset  error flags. */
 			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	/*  Invoke command upload */
-			while (!MC_TEST(P_MC2, MC2_UPLD_IIC));
+			while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
+				;
 			/* and wait for upload to complete. */
 		}
 
@@ -1592,7 +1594,8 @@ static int s626_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
 		/*  shift into FB BUFFER 1 register. */
 
 		/*  Wait for ADC done. */
-		while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
+		while (!(RR7146(P_PSR) & PSR_GPIO2))
+			;
 
 		/*  Fetch ADC data. */
 		if (n != 0)
@@ -1624,7 +1627,8 @@ static int s626_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
 	/*  Wait for the data to arrive in FB BUFFER 1 register. */
 
 	/*  Wait for ADC done. */
-	while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
+	while (!(RR7146(P_PSR) & PSR_GPIO2))
+		;
 
 	/*  Fetch ADC data from audio interface's input shift register. */
 
@@ -2462,10 +2466,12 @@ static uint32_t I2Chandshake(comedi_device *dev, uint32_t val)
 	/*  upload confirmation. */
 
 	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
-	while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;
+	while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
+		;
 
 	/*  Wait until I2C bus transfer is finished or an error occurs. */
-	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY) ;
+	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY)
+		;
 
 	/*  Return non-zero if I2C error occured. */
 	return RR7146(P_I2CCTRL) & I2C_ERR;
@@ -2579,7 +2585,8 @@ static void SendDAC(comedi_device *dev, uint32_t val)
 	 * Done by polling the DMAC enable flag; this flag is automatically
 	 * cleared when the transfer has finished.
 	 */
-	while ((RR7146(P_MC1) & MC1_A2OUT) != 0) ;
+	while ((RR7146(P_MC1) & MC1_A2OUT) != 0)
+		;
 
 	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
 
@@ -2596,7 +2603,8 @@ static void SendDAC(comedi_device *dev, uint32_t val)
 	 * finished transferring the DAC's data DWORD from the output FIFO
 	 * to the output buffer register.
 	 */
-	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0) ;
+	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0)
+		;
 
 	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
 	 * back to slot 0 after executing the EOS in slot 5.  Also,
@@ -2632,7 +2640,8 @@ static void SendDAC(comedi_device *dev, uint32_t val)
 		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
 		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
 		 */
-		 while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) ;
+		 while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0)
+			;
 	}
 	/* Either (1) we were too late setting the slot 0 trap; the TSL
 	 * sequencer restarted slot 0 before we could set the EOS trap flag,
@@ -2648,7 +2657,8 @@ static void SendDAC(comedi_device *dev, uint32_t val)
 	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
 	 * from 0x00 to 0xFF.
 	 */
-	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0) ;
+	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0)
+		;
 }
 
 static void WriteMISC2(comedi_device *dev, uint16_t NewImage)
@@ -2687,10 +2697,12 @@ static void DEBItransfer(comedi_device *dev)
 
 	/*  Wait for completion of upload from shadow RAM to DEBI control */
 	/*  register. */
-	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI)) ;
+	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI))
+		;
 
 	/*  Wait until DEBI transfer is done. */
-	while (RR7146(P_PSR) & PSR_DEBI_S) ;
+	while (RR7146(P_PSR) & PSR_DEBI_S)
+		;
 }
 
 /*  Write a value to a gate array register. */

commit 197c82bf25b9e379cb5646561be1a727ab9e84a7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:03:51 2009 -0400

    Staging: comedi: Remove instances of assignments in conditionals
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 71309d3e1227..9110ae3c7fec 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -525,7 +525,8 @@ static int s626_attach(comedi_device *dev, comedi_devconfig *it)
 		return -ENODEV;
 	}
 
-	if ((result = comedi_pci_enable(pdev, "s626")) < 0) {
+	result = comedi_pci_enable(pdev, "s626");
+	if (result < 0) {
 		printk("s626_attach: comedi_pci_enable fails\n");
 		return -ENODEV;
 	}
@@ -552,9 +553,10 @@ static int s626_attach(comedi_device *dev, comedi_devconfig *it)
 		/* adc buffer allocation */
 		devpriv->allocatedBuf = 0;
 
-		if ((devpriv->ANABuf.LogicalBase =
-				pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE,
-					&appdma)) == NULL) {
+		devpriv->ANABuf.LogicalBase =
+			pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
+
+		if (devpriv->ANABuf.LogicalBase == NULL) {
 			printk("s626_attach: DMA Memory mapping error\n");
 			return -ENOMEM;
 		}
@@ -565,9 +567,10 @@ static int s626_attach(comedi_device *dev, comedi_devconfig *it)
 
 		devpriv->allocatedBuf++;
 
-		if ((devpriv->RPSBuf.LogicalBase =
-				pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE,
-					&appdma)) == NULL) {
+		devpriv->RPSBuf.LogicalBase =
+			pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE,  &appdma);
+
+		if (devpriv->RPSBuf.LogicalBase == NULL) {
 			printk("s626_attach: DMA Memory mapping error\n");
 			return -ENOMEM;
 		}
@@ -593,8 +596,10 @@ static int s626_attach(comedi_device *dev, comedi_devconfig *it)
 	if (dev->irq == 0) {
 		printk(" unknown irq (bad)\n");
 	} else {
-		if ((ret = comedi_request_irq(dev->irq, s626_irq_handler,
-					IRQF_SHARED, "s626", dev)) < 0) {
+		ret = comedi_request_irq(dev->irq, s626_irq_handler,
+					 IRQF_SHARED, "s626", dev);
+
+		if (ret < 0) {
 			printk(" irq not available\n");
 			dev->irq = 0;
 		}

commit 6a98d36e87a0b38d711d580b5fc9dbba17f68dfc
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:03:45 2009 -0400

    Staging: comedi: Add spaces around parens as requested by checkpatch.pl
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index a3763ade9c96..71309d3e1227 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -345,8 +345,8 @@ static void CountersInit(comedi_device *dev);
 /*  Counter objects constructor. */
 
 /*  Counter overflow/index event flag masks for RDMISC2. */
-#define INDXMASK(C)		( 1 << ( ( (C) > 2 ) ? ( (C) * 2 - 1 ) : ( (C) * 2 +  4 ) ) )
-#define OVERMASK(C)		( 1 << ( ( (C) > 2 ) ? ( (C) * 2 + 5 ) : ( (C) * 2 + 10 ) ) )
+#define INDXMASK(C)		(1 << (((C) > 2) ? ((C) * 2 - 1) : ((C) * 2 +  4)))
+#define OVERMASK(C)		(1 << (((C) > 2) ? ((C) * 2 + 5) : ((C) * 2 + 10)))
 #define EVBITS(C)		{ 0, OVERMASK(C), INDXMASK(C), OVERMASK(C) | INDXMASK(C) }
 
 /*  Translation table to map IntSrc into equivalent RDMISC2 event flag  bits. */
@@ -454,11 +454,11 @@ static enc_private enc_private_data[] = {
 
 /*  enab/disable a function or test status bit(s) that are accessed */
 /*  through Main Control Registers 1 or 2. */
-#define MC_ENABLE( REGADRS, CTRLWORD )	writel(  ( (uint32_t)( CTRLWORD ) << 16 ) | (uint32_t)( CTRLWORD ), devpriv->base_addr+( REGADRS ) )
+#define MC_ENABLE(REGADRS, CTRLWORD)	writel(((uint32_t)(CTRLWORD) << 16) | (uint32_t)(CTRLWORD), devpriv->base_addr+(REGADRS))
 
-#define MC_DISABLE( REGADRS, CTRLWORD )	writel(  (uint32_t)( CTRLWORD ) << 16 , devpriv->base_addr+( REGADRS ) )
+#define MC_DISABLE(REGADRS, CTRLWORD)	writel((uint32_t)(CTRLWORD) << 16 , devpriv->base_addr+(REGADRS))
 
-#define MC_TEST( REGADRS, CTRLWORD )	( ( readl(devpriv->base_addr+( REGADRS )) & CTRLWORD ) != 0 )
+#define MC_TEST(REGADRS, CTRLWORD)	((readl(devpriv->base_addr+(REGADRS)) & CTRLWORD) != 0)
 
 /* #define WR7146(REGARDS,CTRLWORD)
     writel(CTRLWORD,(uint32_t)(devpriv->base_addr+(REGARDS))) */
@@ -468,16 +468,16 @@ static enc_private enc_private_data[] = {
     readl((uint32_t)(devpriv->base_addr+(REGARDS))) */
 #define RR7146(REGARDS)		readl(devpriv->base_addr+(REGARDS))
 
-#define BUGFIX_STREG(REGADRS)   ( REGADRS - 4 )
+#define BUGFIX_STREG(REGADRS)   (REGADRS - 4)
 
 /*  Write a time slot control record to TSL2. */
-#define VECTPORT( VECTNUM )		(P_TSL2 + ( (VECTNUM) << 2 ))
-#define SETVECT( VECTNUM, VECTVAL )	WR7146(VECTPORT( VECTNUM ), (VECTVAL))
+#define VECTPORT(VECTNUM)		(P_TSL2 + ((VECTNUM) << 2))
+#define SETVECT(VECTNUM, VECTVAL)	WR7146(VECTPORT(VECTNUM), (VECTVAL))
 
 /*  Code macros used for constructing I2C command bytes. */
-#define I2C_B2(ATTR, VAL)	( ( (ATTR) << 6 ) | ( (VAL) << 24 ) )
-#define I2C_B1(ATTR, VAL)	( ( (ATTR) << 4 ) | ( (VAL) << 16 ) )
-#define I2C_B0(ATTR, VAL)	( ( (ATTR) << 2 ) | ( (VAL) <<  8 ) )
+#define I2C_B2(ATTR, VAL)	(((ATTR) << 6) | ((VAL) << 24))
+#define I2C_B1(ATTR, VAL)	(((ATTR) << 4) | ((VAL) << 16))
+#define I2C_B0(ATTR, VAL)	(((ATTR) << 2) | ((VAL) <<  8))
 
 static const comedi_lrange s626_range_table = { 2, {
 			RANGE(-5, 5),
@@ -2353,7 +2353,7 @@ static void s626_timer_load(comedi_device *dev, enc_private *k, int tick)
 /* ***********  DAC FUNCTIONS *********** */
 
 /*  Slot 0 base settings. */
-#define VECT0	( XSD2 | RSD3 | SIB_A2 )
+#define VECT0	(XSD2 | RSD3 | SIB_A2)
 /*  Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
 
 /*  TrimDac LogicalChan-to-PhysicalChan mapping table. */

commit f7266a48a10d76ff512d5eb44aa18364ee203da4
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:03:40 2009 -0400

    Staging: comedi: Add spaces around colons as needed
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 0c1f5297fe2f..a3763ade9c96 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -96,13 +96,13 @@ typedef struct s626_board_struct {
 static const s626_board s626_boards[] = {
 	{
 	      name:	"s626",
-	      ai_chans:S626_ADC_CHANNELS,
+	      ai_chans : S626_ADC_CHANNELS,
 	      ai_bits:	14,
-	      ao_chans:S626_DAC_CHANNELS,
+	      ao_chans : S626_DAC_CHANNELS,
 	      ao_bits:	13,
-	      dio_chans:S626_DIO_CHANNELS,
-	      dio_banks:S626_DIO_BANKS,
-	      enc_chans:S626_ENCODER_CHANNELS,
+	      dio_chans : S626_DIO_CHANNELS,
+	      dio_banks : S626_DIO_BANKS,
+	      enc_chans : S626_ENCODER_CHANNELS,
 		}
 };
 
@@ -123,9 +123,9 @@ static int s626_detach(comedi_device *dev);
 
 static comedi_driver driver_s626 = {
       driver_name:"s626",
-      module:THIS_MODULE,
-      attach:s626_attach,
-      detach:s626_detach,
+      module : THIS_MODULE,
+      attach : s626_attach,
+      detach : s626_detach,
 };
 
 typedef struct {
@@ -174,38 +174,38 @@ typedef struct {
 
 static dio_private dio_private_A = {
       RDDIn:LP_RDDINA,
-      WRDOut:LP_WRDOUTA,
-      RDEdgSel:LP_RDEDGSELA,
-      WREdgSel:LP_WREDGSELA,
-      RDCapSel:LP_RDCAPSELA,
-      WRCapSel:LP_WRCAPSELA,
-      RDCapFlg:LP_RDCAPFLGA,
-      RDIntSel:LP_RDINTSELA,
-      WRIntSel:LP_WRINTSELA,
+      WRDOut : LP_WRDOUTA,
+      RDEdgSel : LP_RDEDGSELA,
+      WREdgSel : LP_WREDGSELA,
+      RDCapSel : LP_RDCAPSELA,
+      WRCapSel : LP_WRCAPSELA,
+      RDCapFlg : LP_RDCAPFLGA,
+      RDIntSel : LP_RDINTSELA,
+      WRIntSel : LP_WRINTSELA,
 };
 
 static dio_private dio_private_B = {
       RDDIn:LP_RDDINB,
-      WRDOut:LP_WRDOUTB,
-      RDEdgSel:LP_RDEDGSELB,
-      WREdgSel:LP_WREDGSELB,
-      RDCapSel:LP_RDCAPSELB,
-      WRCapSel:LP_WRCAPSELB,
-      RDCapFlg:LP_RDCAPFLGB,
-      RDIntSel:LP_RDINTSELB,
-      WRIntSel:LP_WRINTSELB,
+      WRDOut : LP_WRDOUTB,
+      RDEdgSel : LP_RDEDGSELB,
+      WREdgSel : LP_WREDGSELB,
+      RDCapSel : LP_RDCAPSELB,
+      WRCapSel : LP_WRCAPSELB,
+      RDCapFlg : LP_RDCAPFLGB,
+      RDIntSel : LP_RDINTSELB,
+      WRIntSel : LP_WRINTSELB,
 };
 
 static dio_private dio_private_C = {
       RDDIn:LP_RDDINC,
-      WRDOut:LP_WRDOUTC,
-      RDEdgSel:LP_RDEDGSELC,
-      WREdgSel:LP_WREDGSELC,
-      RDCapSel:LP_RDCAPSELC,
-      WRCapSel:LP_WRCAPSELC,
-      RDCapFlg:LP_RDCAPFLGC,
-      RDIntSel:LP_RDINTSELC,
-      WRIntSel:LP_WRINTSELC,
+      WRDOut : LP_WRDOUTC,
+      RDEdgSel : LP_RDEDGSELC,
+      WREdgSel : LP_WREDGSELC,
+      RDCapSel : LP_RDCAPSELC,
+      WRCapSel : LP_WRCAPSELC,
+      RDCapFlg : LP_RDCAPFLGC,
+      RDIntSel : LP_RDINTSELC,
+      WRIntSel : LP_WRINTSELC,
 };
 
 /* to group dio devices (48 bits mask and data are not allowed ???)
@@ -356,99 +356,99 @@ static void CountersInit(comedi_device *dev);
 static enc_private enc_private_data[] = {
 	{
 	      GetEnable:GetEnable_A,
-	      GetIntSrc:GetIntSrc_A,
-	      GetLoadTrig:GetLoadTrig_A,
+	      GetIntSrc : GetIntSrc_A,
+	      GetLoadTrig : GetLoadTrig_A,
 	      GetMode:	GetMode_A,
-	      PulseIndex:PulseIndex_A,
-	      SetEnable:SetEnable_A,
-	      SetIntSrc:SetIntSrc_A,
-	      SetLoadTrig:SetLoadTrig_A,
+	      PulseIndex : PulseIndex_A,
+	      SetEnable : SetEnable_A,
+	      SetIntSrc : SetIntSrc_A,
+	      SetLoadTrig : SetLoadTrig_A,
 	      SetMode:	SetMode_A,
-	      ResetCapFlags:ResetCapFlags_A,
+	      ResetCapFlags : ResetCapFlags_A,
 	      MyCRA:	LP_CR0A,
 	      MyCRB:	LP_CR0B,
-	      MyLatchLsw:LP_CNTR0ALSW,
-	      MyEventBits:EVBITS(0),
+	      MyLatchLsw : LP_CNTR0ALSW,
+	      MyEventBits : EVBITS(0),
 		},
 	{
 	      GetEnable:GetEnable_A,
-	      GetIntSrc:GetIntSrc_A,
-	      GetLoadTrig:GetLoadTrig_A,
+	      GetIntSrc : GetIntSrc_A,
+	      GetLoadTrig : GetLoadTrig_A,
 	      GetMode:	GetMode_A,
-	      PulseIndex:PulseIndex_A,
-	      SetEnable:SetEnable_A,
-	      SetIntSrc:SetIntSrc_A,
-	      SetLoadTrig:SetLoadTrig_A,
+	      PulseIndex : PulseIndex_A,
+	      SetEnable : SetEnable_A,
+	      SetIntSrc : SetIntSrc_A,
+	      SetLoadTrig : SetLoadTrig_A,
 	      SetMode:	SetMode_A,
-	      ResetCapFlags:ResetCapFlags_A,
+	      ResetCapFlags : ResetCapFlags_A,
 	      MyCRA:	LP_CR1A,
 	      MyCRB:	LP_CR1B,
-	      MyLatchLsw:LP_CNTR1ALSW,
-	      MyEventBits:EVBITS(1),
+	      MyLatchLsw : LP_CNTR1ALSW,
+	      MyEventBits : EVBITS(1),
 		},
 	{
 	      GetEnable:GetEnable_A,
-	      GetIntSrc:GetIntSrc_A,
-	      GetLoadTrig:GetLoadTrig_A,
+	      GetIntSrc : GetIntSrc_A,
+	      GetLoadTrig : GetLoadTrig_A,
 	      GetMode:	GetMode_A,
-	      PulseIndex:PulseIndex_A,
-	      SetEnable:SetEnable_A,
-	      SetIntSrc:SetIntSrc_A,
-	      SetLoadTrig:SetLoadTrig_A,
+	      PulseIndex : PulseIndex_A,
+	      SetEnable : SetEnable_A,
+	      SetIntSrc : SetIntSrc_A,
+	      SetLoadTrig : SetLoadTrig_A,
 	      SetMode:	SetMode_A,
-	      ResetCapFlags:ResetCapFlags_A,
+	      ResetCapFlags : ResetCapFlags_A,
 	      MyCRA:	LP_CR2A,
 	      MyCRB:	LP_CR2B,
-	      MyLatchLsw:LP_CNTR2ALSW,
-	      MyEventBits:EVBITS(2),
+	      MyLatchLsw : LP_CNTR2ALSW,
+	      MyEventBits : EVBITS(2),
 		},
 	{
 	      GetEnable:GetEnable_B,
-	      GetIntSrc:GetIntSrc_B,
-	      GetLoadTrig:GetLoadTrig_B,
+	      GetIntSrc : GetIntSrc_B,
+	      GetLoadTrig : GetLoadTrig_B,
 	      GetMode:	GetMode_B,
-	      PulseIndex:PulseIndex_B,
-	      SetEnable:SetEnable_B,
-	      SetIntSrc:SetIntSrc_B,
-	      SetLoadTrig:SetLoadTrig_B,
+	      PulseIndex : PulseIndex_B,
+	      SetEnable : SetEnable_B,
+	      SetIntSrc : SetIntSrc_B,
+	      SetLoadTrig : SetLoadTrig_B,
 	      SetMode:	SetMode_B,
-	      ResetCapFlags:ResetCapFlags_B,
+	      ResetCapFlags : ResetCapFlags_B,
 	      MyCRA:	LP_CR0A,
 	      MyCRB:	LP_CR0B,
-	      MyLatchLsw:LP_CNTR0BLSW,
-	      MyEventBits:EVBITS(3),
+	      MyLatchLsw : LP_CNTR0BLSW,
+	      MyEventBits : EVBITS(3),
 		},
 	{
 	      GetEnable:GetEnable_B,
-	      GetIntSrc:GetIntSrc_B,
-	      GetLoadTrig:GetLoadTrig_B,
+	      GetIntSrc : GetIntSrc_B,
+	      GetLoadTrig : GetLoadTrig_B,
 	      GetMode:	GetMode_B,
-	      PulseIndex:PulseIndex_B,
-	      SetEnable:SetEnable_B,
-	      SetIntSrc:SetIntSrc_B,
-	      SetLoadTrig:SetLoadTrig_B,
+	      PulseIndex : PulseIndex_B,
+	      SetEnable : SetEnable_B,
+	      SetIntSrc : SetIntSrc_B,
+	      SetLoadTrig : SetLoadTrig_B,
 	      SetMode:	SetMode_B,
-	      ResetCapFlags:ResetCapFlags_B,
+	      ResetCapFlags : ResetCapFlags_B,
 	      MyCRA:	LP_CR1A,
 	      MyCRB:	LP_CR1B,
-	      MyLatchLsw:LP_CNTR1BLSW,
-	      MyEventBits:EVBITS(4),
+	      MyLatchLsw : LP_CNTR1BLSW,
+	      MyEventBits : EVBITS(4),
 		},
 	{
 	      GetEnable:GetEnable_B,
-	      GetIntSrc:GetIntSrc_B,
-	      GetLoadTrig:GetLoadTrig_B,
+	      GetIntSrc : GetIntSrc_B,
+	      GetLoadTrig : GetLoadTrig_B,
 	      GetMode:	GetMode_B,
-	      PulseIndex:PulseIndex_B,
-	      SetEnable:SetEnable_B,
-	      SetIntSrc:SetIntSrc_B,
-	      SetLoadTrig:SetLoadTrig_B,
+	      PulseIndex : PulseIndex_B,
+	      SetEnable : SetEnable_B,
+	      SetIntSrc : SetIntSrc_B,
+	      SetLoadTrig : SetLoadTrig_B,
 	      SetMode:	SetMode_B,
-	      ResetCapFlags:ResetCapFlags_B,
+	      ResetCapFlags : ResetCapFlags_B,
 	      MyCRA:	LP_CR2A,
 	      MyCRB:	LP_CR2B,
-	      MyLatchLsw:LP_CNTR2BLSW,
-	      MyEventBits:EVBITS(5),
+	      MyLatchLsw : LP_CNTR2BLSW,
+	      MyEventBits : EVBITS(5),
 		},
 };
 

commit 8086fff871940e6a348a733a303f39c086e4b3c5
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:03:35 2009 -0400

    Staging: comedi: Add spaces after commas where suggested by checkpatch.pl
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 41f3736efa3b..0c1f5297fe2f 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -454,7 +454,7 @@ static enc_private enc_private_data[] = {
 
 /*  enab/disable a function or test status bit(s) that are accessed */
 /*  through Main Control Registers 1 or 2. */
-#define MC_ENABLE( REGADRS, CTRLWORD )	writel(  ( (uint32_t)( CTRLWORD ) << 16 ) | (uint32_t)( CTRLWORD ),devpriv->base_addr+( REGADRS ) )
+#define MC_ENABLE( REGADRS, CTRLWORD )	writel(  ( (uint32_t)( CTRLWORD ) << 16 ) | (uint32_t)( CTRLWORD ), devpriv->base_addr+( REGADRS ) )
 
 #define MC_DISABLE( REGADRS, CTRLWORD )	writel(  (uint32_t)( CTRLWORD ) << 16 , devpriv->base_addr+( REGADRS ) )
 
@@ -462,7 +462,7 @@ static enc_private enc_private_data[] = {
 
 /* #define WR7146(REGARDS,CTRLWORD)
     writel(CTRLWORD,(uint32_t)(devpriv->base_addr+(REGARDS))) */
-#define WR7146(REGARDS,CTRLWORD) writel(CTRLWORD,devpriv->base_addr+(REGARDS))
+#define WR7146(REGARDS, CTRLWORD) writel(CTRLWORD, devpriv->base_addr+(REGARDS))
 
 /* #define RR7146(REGARDS)
     readl((uint32_t)(devpriv->base_addr+(REGARDS))) */
@@ -475,9 +475,9 @@ static enc_private enc_private_data[] = {
 #define SETVECT( VECTNUM, VECTVAL )	WR7146(VECTPORT( VECTNUM ), (VECTVAL))
 
 /*  Code macros used for constructing I2C command bytes. */
-#define I2C_B2(ATTR,VAL)	( ( (ATTR) << 6 ) | ( (VAL) << 24 ) )
-#define I2C_B1(ATTR,VAL)	( ( (ATTR) << 4 ) | ( (VAL) << 16 ) )
-#define I2C_B0(ATTR,VAL)	( ( (ATTR) << 2 ) | ( (VAL) <<  8 ) )
+#define I2C_B2(ATTR, VAL)	( ( (ATTR) << 6 ) | ( (VAL) << 24 ) )
+#define I2C_B1(ATTR, VAL)	( ( (ATTR) << 4 ) | ( (VAL) << 16 ) )
+#define I2C_B0(ATTR, VAL)	( ( (ATTR) << 2 ) | ( (VAL) <<  8 ) )
 
 static const comedi_lrange s626_range_table = { 2, {
 			RANGE(-5, 5),

commit e473e9120b0a2d7252aca1ed9db5adadee36c0fa
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:03:29 2009 -0400

    Staging: comedi: Change "foo * bar" to "foo *bar"
    
    Removes checkpatch.pl errors
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 24577a9a16b1..41f3736efa3b 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -118,8 +118,8 @@ static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
 
 MODULE_DEVICE_TABLE(pci, s626_pci_table);
 
-static int s626_attach(comedi_device * dev, comedi_devconfig * it);
-static int s626_detach(comedi_device * dev);
+static int s626_attach(comedi_device *dev, comedi_devconfig *it);
+static int s626_detach(comedi_device *dev);
 
 static comedi_driver driver_s626 = {
       driver_name:"s626",
@@ -222,36 +222,36 @@ static dio_private *dio_private_word[]={
 COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
 
 /* ioctl routines */
-static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+static int s626_ai_insn_config(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
 /* static int s626_ai_rinsn(comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,lsampl_t *data); */
-static int s626_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s);
-static int s626_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
-	comedi_cmd * cmd);
-static int s626_ai_cancel(comedi_device * dev, comedi_subdevice * s);
-static int s626_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_dio_set_irq(comedi_device * dev, unsigned int chan);
-static int s626_dio_reset_irq(comedi_device * dev, unsigned int gruop,
+static int s626_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_ai_cmd(comedi_device *dev, comedi_subdevice *s);
+static int s626_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
+	comedi_cmd *cmd);
+static int s626_ai_cancel(comedi_device *dev, comedi_subdevice *s);
+static int s626_ao_winsn(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_ao_rinsn(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_dio_set_irq(comedi_device *dev, unsigned int chan);
+static int s626_dio_reset_irq(comedi_device *dev, unsigned int gruop,
 	unsigned int mask);
-static int s626_dio_clear_irq(comedi_device * dev);
-static int s626_enc_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_enc_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_enc_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+static int s626_dio_clear_irq(comedi_device *dev);
+static int s626_enc_insn_config(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_enc_insn_read(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_enc_insn_write(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
 static int s626_ns_to_timer(int *nanosec, int round_mode);
-static int s626_ai_load_polllist(uint8_t * ppl, comedi_cmd * cmd);
-static int s626_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int s626_ai_load_polllist(uint8_t *ppl, comedi_cmd *cmd);
+static int s626_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
 	unsigned int trignum);
 static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG);
 static lsampl_t s626_ai_reg_to_uint(int data);
@@ -260,36 +260,36 @@ static lsampl_t s626_ai_reg_to_uint(int data);
 /* end ioctl routines */
 
 /* internal routines */
-static void s626_dio_init(comedi_device * dev);
-static void ResetADC(comedi_device * dev, uint8_t * ppl);
-static void LoadTrimDACs(comedi_device * dev);
-static void WriteTrimDAC(comedi_device * dev, uint8_t LogicalChan,
+static void s626_dio_init(comedi_device *dev);
+static void ResetADC(comedi_device *dev, uint8_t *ppl);
+static void LoadTrimDACs(comedi_device *dev);
+static void WriteTrimDAC(comedi_device *dev, uint8_t LogicalChan,
 	uint8_t DacData);
-static uint8_t I2Cread(comedi_device * dev, uint8_t addr);
-static uint32_t I2Chandshake(comedi_device * dev, uint32_t val);
-static void SetDAC(comedi_device * dev, uint16_t chan, short dacdata);
-static void SendDAC(comedi_device * dev, uint32_t val);
-static void WriteMISC2(comedi_device * dev, uint16_t NewImage);
-static void DEBItransfer(comedi_device * dev);
-static uint16_t DEBIread(comedi_device * dev, uint16_t addr);
-static void DEBIwrite(comedi_device * dev, uint16_t addr, uint16_t wdata);
-static void DEBIreplace(comedi_device * dev, uint16_t addr, uint16_t mask,
+static uint8_t I2Cread(comedi_device *dev, uint8_t addr);
+static uint32_t I2Chandshake(comedi_device *dev, uint32_t val);
+static void SetDAC(comedi_device *dev, uint16_t chan, short dacdata);
+static void SendDAC(comedi_device *dev, uint32_t val);
+static void WriteMISC2(comedi_device *dev, uint16_t NewImage);
+static void DEBItransfer(comedi_device *dev);
+static uint16_t DEBIread(comedi_device *dev, uint16_t addr);
+static void DEBIwrite(comedi_device *dev, uint16_t addr, uint16_t wdata);
+static void DEBIreplace(comedi_device *dev, uint16_t addr, uint16_t mask,
 	uint16_t wdata);
-static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize);
+static void CloseDMAB(comedi_device *dev, DMABUF *pdma, size_t bsize);
 
 /*  COUNTER OBJECT ------------------------------------------------ */
 typedef struct enc_private_struct {
 	/*  Pointers to functions that differ for A and B counters: */
-	uint16_t(*GetEnable) (comedi_device * dev, struct enc_private_struct *);	/* Return clock enable. */
-	uint16_t(*GetIntSrc) (comedi_device * dev, struct enc_private_struct *);	/* Return interrupt source. */
-	uint16_t(*GetLoadTrig) (comedi_device * dev, struct enc_private_struct *);	/* Return preload trigger source. */
-	uint16_t(*GetMode) (comedi_device * dev, struct enc_private_struct *);	/* Return standardized operating mode. */
-	void (*PulseIndex) (comedi_device * dev, struct enc_private_struct *);	/* Generate soft index strobe. */
-	void (*SetEnable) (comedi_device * dev, struct enc_private_struct *, uint16_t enab);	/* Program clock enable. */
-	void (*SetIntSrc) (comedi_device * dev, struct enc_private_struct *, uint16_t IntSource);	/* Program interrupt source. */
-	void (*SetLoadTrig) (comedi_device * dev, struct enc_private_struct *, uint16_t Trig);	/* Program preload trigger source. */
-	void (*SetMode) (comedi_device * dev, struct enc_private_struct *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
-	void (*ResetCapFlags) (comedi_device * dev, struct enc_private_struct *);	/* Reset event capture flags. */
+	uint16_t(*GetEnable) (comedi_device *dev, struct enc_private_struct *);	/* Return clock enable. */
+	uint16_t(*GetIntSrc) (comedi_device *dev, struct enc_private_struct *);	/* Return interrupt source. */
+	uint16_t(*GetLoadTrig) (comedi_device *dev, struct enc_private_struct *);	/* Return preload trigger source. */
+	uint16_t(*GetMode) (comedi_device *dev, struct enc_private_struct *);	/* Return standardized operating mode. */
+	void (*PulseIndex) (comedi_device *dev, struct enc_private_struct *);	/* Generate soft index strobe. */
+	void (*SetEnable) (comedi_device *dev, struct enc_private_struct *, uint16_t enab);	/* Program clock enable. */
+	void (*SetIntSrc) (comedi_device *dev, struct enc_private_struct *, uint16_t IntSource);	/* Program interrupt source. */
+	void (*SetLoadTrig) (comedi_device *dev, struct enc_private_struct *, uint16_t Trig);	/* Program preload trigger source. */
+	void (*SetMode) (comedi_device *dev, struct enc_private_struct *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
+	void (*ResetCapFlags) (comedi_device *dev, struct enc_private_struct *);	/* Reset event capture flags. */
 
 	uint16_t MyCRA;		/*    Address of CRA register. */
 	uint16_t MyCRB;		/*    Address of CRB register. */
@@ -301,33 +301,33 @@ typedef struct enc_private_struct {
 #define encpriv ((enc_private *)(dev->subdevices+5)->private)
 
 /* counters routines */
-static void s626_timer_load(comedi_device * dev, enc_private * k, int tick);
-static uint32_t ReadLatch(comedi_device * dev, enc_private * k);
-static void ResetCapFlags_A(comedi_device * dev, enc_private * k);
-static void ResetCapFlags_B(comedi_device * dev, enc_private * k);
-static uint16_t GetMode_A(comedi_device * dev, enc_private * k);
-static uint16_t GetMode_B(comedi_device * dev, enc_private * k);
-static void SetMode_A(comedi_device * dev, enc_private * k, uint16_t Setup,
+static void s626_timer_load(comedi_device *dev, enc_private *k, int tick);
+static uint32_t ReadLatch(comedi_device *dev, enc_private *k);
+static void ResetCapFlags_A(comedi_device *dev, enc_private *k);
+static void ResetCapFlags_B(comedi_device *dev, enc_private *k);
+static uint16_t GetMode_A(comedi_device *dev, enc_private *k);
+static uint16_t GetMode_B(comedi_device *dev, enc_private *k);
+static void SetMode_A(comedi_device *dev, enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc);
-static void SetMode_B(comedi_device * dev, enc_private * k, uint16_t Setup,
+static void SetMode_B(comedi_device *dev, enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc);
-static void SetEnable_A(comedi_device * dev, enc_private * k, uint16_t enab);
-static void SetEnable_B(comedi_device * dev, enc_private * k, uint16_t enab);
-static uint16_t GetEnable_A(comedi_device * dev, enc_private * k);
-static uint16_t GetEnable_B(comedi_device * dev, enc_private * k);
-static void SetLatchSource(comedi_device * dev, enc_private * k,
+static void SetEnable_A(comedi_device *dev, enc_private *k, uint16_t enab);
+static void SetEnable_B(comedi_device *dev, enc_private *k, uint16_t enab);
+static uint16_t GetEnable_A(comedi_device *dev, enc_private *k);
+static uint16_t GetEnable_B(comedi_device *dev, enc_private *k);
+static void SetLatchSource(comedi_device *dev, enc_private *k,
 	uint16_t value);
 /* static uint16_t GetLatchSource(comedi_device *dev, enc_private *k ); */
-static void SetLoadTrig_A(comedi_device * dev, enc_private * k, uint16_t Trig);
-static void SetLoadTrig_B(comedi_device * dev, enc_private * k, uint16_t Trig);
-static uint16_t GetLoadTrig_A(comedi_device * dev, enc_private * k);
-static uint16_t GetLoadTrig_B(comedi_device * dev, enc_private * k);
-static void SetIntSrc_B(comedi_device * dev, enc_private * k,
+static void SetLoadTrig_A(comedi_device *dev, enc_private *k, uint16_t Trig);
+static void SetLoadTrig_B(comedi_device *dev, enc_private *k, uint16_t Trig);
+static uint16_t GetLoadTrig_A(comedi_device *dev, enc_private *k);
+static uint16_t GetLoadTrig_B(comedi_device *dev, enc_private *k);
+static void SetIntSrc_B(comedi_device *dev, enc_private *k,
 	uint16_t IntSource);
-static void SetIntSrc_A(comedi_device * dev, enc_private * k,
+static void SetIntSrc_A(comedi_device *dev, enc_private *k,
 	uint16_t IntSource);
-static uint16_t GetIntSrc_A(comedi_device * dev, enc_private * k);
-static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k);
+static uint16_t GetIntSrc_A(comedi_device *dev, enc_private *k);
+static uint16_t GetIntSrc_B(comedi_device *dev, enc_private *k);
 /* static void SetClkMult(comedi_device *dev, enc_private *k, uint16_t value ) ; */
 /* static uint16_t GetClkMult(comedi_device *dev, enc_private *k ) ; */
 /* static void SetIndexPol(comedi_device *dev, enc_private *k, uint16_t value ); */
@@ -336,10 +336,10 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k);
 /* static uint16_t GetClkSrc( comedi_device *dev,enc_private *k );  */
 /* static void SetIndexSrc( comedi_device *dev,enc_private *k, uint16_t value );  */
 /* static uint16_t GetIndexSrc( comedi_device *dev,enc_private *k );  */
-static void PulseIndex_A(comedi_device * dev, enc_private * k);
-static void PulseIndex_B(comedi_device * dev, enc_private * k);
-static void Preload(comedi_device * dev, enc_private * k, uint32_t value);
-static void CountersInit(comedi_device * dev);
+static void PulseIndex_A(comedi_device *dev, enc_private *k);
+static void PulseIndex_B(comedi_device *dev, enc_private *k);
+static void Preload(comedi_device *dev, enc_private *k, uint32_t value);
+static void CountersInit(comedi_device *dev);
 /* end internal routines */
 
 /*  Counter objects constructor. */
@@ -485,7 +485,7 @@ static const comedi_lrange s626_range_table = { 2, {
 	}
 };
 
-static int s626_attach(comedi_device * dev, comedi_devconfig * it)
+static int s626_attach(comedi_device *dev, comedi_devconfig *it)
 {
 /*   uint8_t	PollList; */
 /*   uint16_t	AdcData; */
@@ -1261,7 +1261,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-static int s626_detach(comedi_device * dev)
+static int s626_detach(comedi_device *dev)
 {
 	if (devpriv) {
 		/* stop ai_command */
@@ -1307,7 +1307,7 @@ static int s626_detach(comedi_device * dev)
 /*
  * this functions build the RPS program for hardware driven acquistion
  */
-void ResetADC(comedi_device * dev, uint8_t * ppl)
+void ResetADC(comedi_device *dev, uint8_t *ppl)
 {
 	register uint32_t *pRPS;
 	uint32_t JmpAdrs;
@@ -1499,8 +1499,8 @@ void ResetADC(comedi_device * dev, uint8_t * ppl)
 }
 
 /* TO COMPLETE, IF NECESSARY */
-static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_ai_insn_config(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 
 	return -EINVAL;
@@ -1536,8 +1536,8 @@ static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
 /*   return i; */
 /* } */
 
-static int s626_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	uint16_t chan = CR_CHAN(insn->chanspec);
 	uint16_t range = CR_RANGE(insn->chanspec);
@@ -1632,7 +1632,7 @@ static int s626_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int s626_ai_load_polllist(uint8_t * ppl, comedi_cmd * cmd)
+static int s626_ai_load_polllist(uint8_t *ppl, comedi_cmd *cmd)
 {
 
 	int n;
@@ -1648,7 +1648,7 @@ static int s626_ai_load_polllist(uint8_t * ppl, comedi_cmd * cmd)
 	return n;
 }
 
-static int s626_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int s626_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
 	unsigned int trignum)
 {
 	if (trignum != 0)
@@ -1667,7 +1667,7 @@ static int s626_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
 }
 
 /*  TO COMPLETE  */
-static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int s626_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 {
 
 	uint8_t ppl[16];
@@ -1813,8 +1813,8 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int s626_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
-	comedi_cmd * cmd)
+static int s626_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
+	comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1998,7 +1998,7 @@ static int s626_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int s626_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+static int s626_ai_cancel(comedi_device *dev, comedi_subdevice *s)
 {
 	/*  Stop RPS program in case it is currently running. */
 	MC_DISABLE(P_MC1, MC1_ERPS1);
@@ -2039,8 +2039,8 @@ static int s626_ns_to_timer(int *nanosec, int round_mode)
 	return divider - 1;
 }
 
-static int s626_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_ao_winsn(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 
 	int i;
@@ -2058,8 +2058,8 @@ static int s626_ao_winsn(comedi_device * dev, comedi_subdevice * s,
 	return i;
 }
 
-static int s626_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_ao_rinsn(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	int i;
 
@@ -2076,7 +2076,7 @@ static int s626_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
  * ports A, B and C, respectively.
  */
 
-static void s626_dio_init(comedi_device * dev)
+static void s626_dio_init(comedi_device *dev)
 {
 	uint16_t group;
 	comedi_subdevice *s;
@@ -2105,8 +2105,8 @@ static void s626_dio_init(comedi_device * dev)
  * This allows packed reading/writing of the DIO channels.  The comedi
  * core can convert between insn_bits and insn_read/write */
 
-static int s626_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 
 	/* Length of data must be 2 (mask and new data, see below) */
@@ -2141,8 +2141,8 @@ static int s626_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int s626_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 
 	switch (data[0]) {
@@ -2168,7 +2168,7 @@ static int s626_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int s626_dio_set_irq(comedi_device * dev, unsigned int chan)
+static int s626_dio_set_irq(comedi_device *dev, unsigned int chan)
 {
 	unsigned int group;
 	unsigned int bitmask;
@@ -2210,7 +2210,7 @@ static int s626_dio_set_irq(comedi_device * dev, unsigned int chan)
 	return 0;
 }
 
-static int s626_dio_reset_irq(comedi_device * dev, unsigned int group,
+static int s626_dio_reset_irq(comedi_device *dev, unsigned int group,
 	unsigned int mask)
 {
 	DEBUG("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n", mask, group);
@@ -2226,7 +2226,7 @@ static int s626_dio_reset_irq(comedi_device * dev, unsigned int group,
 	return 0;
 }
 
-static int s626_dio_clear_irq(comedi_device * dev)
+static int s626_dio_clear_irq(comedi_device *dev)
 {
 	unsigned int group;
 
@@ -2246,8 +2246,8 @@ static int s626_dio_clear_irq(comedi_device * dev)
 /* Now this function initializes the value of the counter (data[0])
    and set the subdevice. To complete with trigger and interrupt
    configuration */
-static int s626_enc_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_enc_insn_config(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
 		/*  index. */
@@ -2276,8 +2276,8 @@ static int s626_enc_insn_config(comedi_device * dev, comedi_subdevice * s,
 	return insn->n;
 }
 
-static int s626_enc_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_enc_insn_read(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 
 	int n;
@@ -2294,8 +2294,8 @@ static int s626_enc_insn_read(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int s626_enc_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_enc_insn_write(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 
 	enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
@@ -2317,7 +2317,7 @@ static int s626_enc_insn_write(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static void s626_timer_load(comedi_device * dev, enc_private * k, int tick)
+static void s626_timer_load(comedi_device *dev, enc_private *k, int tick)
 {
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
 		/*  index. */
@@ -2363,7 +2363,7 @@ static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 static uint8_t trimadrs[] =
 	{ 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
 
-static void LoadTrimDACs(comedi_device * dev)
+static void LoadTrimDACs(comedi_device *dev)
 {
 	register uint8_t i;
 
@@ -2372,7 +2372,7 @@ static void LoadTrimDACs(comedi_device * dev)
 		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
 }
 
-static void WriteTrimDAC(comedi_device * dev, uint8_t LogicalChan,
+static void WriteTrimDAC(comedi_device *dev, uint8_t LogicalChan,
 	uint8_t DacData)
 {
 	uint32_t chan;
@@ -2413,7 +2413,7 @@ static void WriteTrimDAC(comedi_device * dev, uint8_t LogicalChan,
 /* **************  EEPROM ACCESS FUNCTIONS  ************** */
 /*  Read uint8_t from EEPROM. */
 
-static uint8_t I2Cread(comedi_device * dev, uint8_t addr)
+static uint8_t I2Cread(comedi_device *dev, uint8_t addr)
 {
 	uint8_t rtnval;
 
@@ -2448,7 +2448,7 @@ static uint8_t I2Cread(comedi_device * dev, uint8_t addr)
 	return rtnval;
 }
 
-static uint32_t I2Chandshake(comedi_device * dev, uint32_t val)
+static uint32_t I2Chandshake(comedi_device *dev, uint32_t val)
 {
 	/*  Write I2C command to I2C Transfer Control shadow register. */
 	WR7146(P_I2CCTRL, val);
@@ -2469,7 +2469,7 @@ static uint32_t I2Chandshake(comedi_device * dev, uint32_t val)
 
 /*  Private helper function: Write setpoint to an application DAC channel. */
 
-static void SetDAC(comedi_device * dev, uint16_t chan, short dacdata)
+static void SetDAC(comedi_device *dev, uint16_t chan, short dacdata)
 {
 	register uint16_t signmask;
 	register uint32_t WSImage;
@@ -2530,7 +2530,7 @@ static void SetDAC(comedi_device * dev, uint16_t chan, short dacdata)
  * Dacpol contains valid target image.
  */
 
-static void SendDAC(comedi_device * dev, uint32_t val)
+static void SendDAC(comedi_device *dev, uint32_t val)
 {
 
 	/* START THE SERIAL CLOCK RUNNING ------------- */
@@ -2646,7 +2646,7 @@ static void SendDAC(comedi_device * dev, uint32_t val)
 	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0) ;
 }
 
-static void WriteMISC2(comedi_device * dev, uint16_t NewImage)
+static void WriteMISC2(comedi_device *dev, uint16_t NewImage)
 {
 	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	/*  enab writes to */
 	/*  MISC2 register. */
@@ -2656,7 +2656,7 @@ static void WriteMISC2(comedi_device * dev, uint16_t NewImage)
 
 /*  Initialize the DEBI interface for all transfers. */
 
-static uint16_t DEBIread(comedi_device * dev, uint16_t addr)
+static uint16_t DEBIread(comedi_device *dev, uint16_t addr)
 {
 	uint16_t retval;
 
@@ -2675,7 +2675,7 @@ static uint16_t DEBIread(comedi_device * dev, uint16_t addr)
 
 /*  Execute a DEBI transfer.  This must be called from within a */
 /*  critical section. */
-static void DEBItransfer(comedi_device * dev)
+static void DEBItransfer(comedi_device *dev)
 {
 	/*  Initiate upload of shadow RAM to DEBI control register. */
 	MC_ENABLE(P_MC2, MC2_UPLD_DEBI);
@@ -2689,7 +2689,7 @@ static void DEBItransfer(comedi_device * dev)
 }
 
 /*  Write a value to a gate array register. */
-static void DEBIwrite(comedi_device * dev, uint16_t addr, uint16_t wdata)
+static void DEBIwrite(comedi_device *dev, uint16_t addr, uint16_t wdata)
 {
 
 	/*  Set up DEBI control register value in shadow RAM. */
@@ -2704,7 +2704,7 @@ static void DEBIwrite(comedi_device * dev, uint16_t addr, uint16_t wdata)
  * specifies bits that are to be preserved, wdata is new value to be
  * or'd with the masked original.
  */
-static void DEBIreplace(comedi_device * dev, uint16_t addr, uint16_t mask,
+static void DEBIreplace(comedi_device *dev, uint16_t addr, uint16_t mask,
 	uint16_t wdata)
 {
 
@@ -2722,7 +2722,7 @@ static void DEBIreplace(comedi_device * dev, uint16_t addr, uint16_t mask,
 	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
 }
 
-static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize)
+static void CloseDMAB(comedi_device *dev, DMABUF *pdma, size_t bsize)
 {
 	void *vbptr;
 	dma_addr_t vpptr;
@@ -2757,7 +2757,7 @@ static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize)
 
 /*  Read a counter's output latch. */
 
-static uint32_t ReadLatch(comedi_device * dev, enc_private * k)
+static uint32_t ReadLatch(comedi_device *dev, enc_private *k)
 {
 	register uint32_t value;
 	/* DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n"); */
@@ -2776,13 +2776,13 @@ static uint32_t ReadLatch(comedi_device * dev, enc_private * k)
 
 /*  Reset a counter's index and overflow event capture flags. */
 
-static void ResetCapFlags_A(comedi_device * dev, enc_private * k)
+static void ResetCapFlags_A(comedi_device *dev, enc_private *k)
 {
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 }
 
-static void ResetCapFlags_B(comedi_device * dev, enc_private * k)
+static void ResetCapFlags_B(comedi_device *dev, enc_private *k)
 {
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
@@ -2791,7 +2791,7 @@ static void ResetCapFlags_B(comedi_device * dev, enc_private * k)
 /*  Return counter setup in a format (COUNTER_SETUP) that is consistent */
 /*  for both A and B counters. */
 
-static uint16_t GetMode_A(comedi_device * dev, enc_private * k)
+static uint16_t GetMode_A(comedi_device *dev, enc_private *k)
 {
 	register uint16_t cra;
 	register uint16_t crb;
@@ -2829,7 +2829,7 @@ static uint16_t GetMode_A(comedi_device * dev, enc_private * k)
 	return setup;
 }
 
-static uint16_t GetMode_B(comedi_device * dev, enc_private * k)
+static uint16_t GetMode_B(comedi_device *dev, enc_private *k)
 {
 	register uint16_t cra;
 	register uint16_t crb;
@@ -2875,7 +2875,7 @@ static uint16_t GetMode_B(comedi_device * dev, enc_private * k)
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
 
-static void SetMode_A(comedi_device * dev, enc_private * k, uint16_t Setup,
+static void SetMode_A(comedi_device *dev, enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
@@ -2933,7 +2933,7 @@ static void SetMode_A(comedi_device * dev, enc_private * k, uint16_t Setup,
 		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
 }
 
-static void SetMode_B(comedi_device * dev, enc_private * k, uint16_t Setup,
+static void SetMode_B(comedi_device *dev, enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
@@ -2997,7 +2997,7 @@ static void SetMode_B(comedi_device * dev, enc_private * k, uint16_t Setup,
 
 /*  Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index. */
 
-static void SetEnable_A(comedi_device * dev, enc_private * k, uint16_t enab)
+static void SetEnable_A(comedi_device *dev, enc_private *k, uint16_t enab)
 {
 	DEBUG("SetEnable_A: SetEnable_A enter 3541\n");
 	DEBIreplace(dev, k->MyCRB,
@@ -3005,19 +3005,19 @@ static void SetEnable_A(comedi_device * dev, enc_private * k, uint16_t enab)
 		(uint16_t) (enab << CRBBIT_CLKENAB_A));
 }
 
-static void SetEnable_B(comedi_device * dev, enc_private * k, uint16_t enab)
+static void SetEnable_B(comedi_device *dev, enc_private *k, uint16_t enab)
 {
 	DEBIreplace(dev, k->MyCRB,
 		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),
 		(uint16_t) (enab << CRBBIT_CLKENAB_B));
 }
 
-static uint16_t GetEnable_A(comedi_device * dev, enc_private * k)
+static uint16_t GetEnable_A(comedi_device *dev, enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_A) & 1;
 }
 
-static uint16_t GetEnable_B(comedi_device * dev, enc_private * k)
+static uint16_t GetEnable_B(comedi_device *dev, enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_B) & 1;
 }
@@ -3027,7 +3027,7 @@ static uint16_t GetEnable_B(comedi_device * dev, enc_private * k)
  * latches B.
  */
 
-static void SetLatchSource(comedi_device * dev, enc_private * k, uint16_t value)
+static void SetLatchSource(comedi_device *dev, enc_private *k, uint16_t value)
 {
 	DEBUG("SetLatchSource: SetLatchSource enter 3550 \n");
 	DEBIreplace(dev, k->MyCRB,
@@ -3050,25 +3050,25 @@ static void SetLatchSource(comedi_device * dev, enc_private * k, uint16_t value)
  * 2=OverflowA (B counters only), 3=disabled.
  */
 
-static void SetLoadTrig_A(comedi_device * dev, enc_private * k, uint16_t Trig)
+static void SetLoadTrig_A(comedi_device *dev, enc_private *k, uint16_t Trig)
 {
 	DEBIreplace(dev, k->MyCRA, (uint16_t) (~CRAMSK_LOADSRC_A),
 		(uint16_t) (Trig << CRABIT_LOADSRC_A));
 }
 
-static void SetLoadTrig_B(comedi_device * dev, enc_private * k, uint16_t Trig)
+static void SetLoadTrig_B(comedi_device *dev, enc_private *k, uint16_t Trig)
 {
 	DEBIreplace(dev, k->MyCRB,
 		(uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),
 		(uint16_t) (Trig << CRBBIT_LOADSRC_B));
 }
 
-static uint16_t GetLoadTrig_A(comedi_device * dev, enc_private * k)
+static uint16_t GetLoadTrig_A(comedi_device *dev, enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRA) >> CRABIT_LOADSRC_A) & 3;
 }
 
-static uint16_t GetLoadTrig_B(comedi_device * dev, enc_private * k)
+static uint16_t GetLoadTrig_B(comedi_device *dev, enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_LOADSRC_B) & 3;
 }
@@ -3078,7 +3078,7 @@ static uint16_t GetLoadTrig_B(comedi_device * dev, enc_private * k)
  * 2=IndexOnly, 3=IndexAndOverflow.
  */
 
-static void SetIntSrc_A(comedi_device * dev, enc_private * k,
+static void SetIntSrc_A(comedi_device *dev, enc_private *k,
 	uint16_t IntSource)
 {
 	/*  Reset any pending counter overflow or index captures. */
@@ -3095,7 +3095,7 @@ static void SetIntSrc_A(comedi_device * dev, enc_private * k,
 		MyEventBits[IntSource];
 }
 
-static void SetIntSrc_B(comedi_device * dev, enc_private * k,
+static void SetIntSrc_B(comedi_device *dev, enc_private *k,
 	uint16_t IntSource)
 {
 	uint16_t crb;
@@ -3118,12 +3118,12 @@ static void SetIntSrc_B(comedi_device * dev, enc_private * k,
 		MyEventBits[IntSource];
 }
 
-static uint16_t GetIntSrc_A(comedi_device * dev, enc_private * k)
+static uint16_t GetIntSrc_A(comedi_device *dev, enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRA) >> CRABIT_INTSRC_A) & 3;
 }
 
-static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
+static uint16_t GetIntSrc_B(comedi_device *dev, enc_private *k)
 {
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_INTSRC_B) & 3;
 }
@@ -3191,7 +3191,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 
 /*  Generate an index pulse. */
 
-static void PulseIndex_A(comedi_device * dev, enc_private * k)
+static void PulseIndex_A(comedi_device *dev, enc_private *k)
 {
 	register uint16_t cra;
 
@@ -3203,7 +3203,7 @@ static void PulseIndex_A(comedi_device * dev, enc_private * k)
 	DEBIwrite(dev, k->MyCRA, cra);
 }
 
-static void PulseIndex_B(comedi_device * dev, enc_private * k)
+static void PulseIndex_B(comedi_device *dev, enc_private *k)
 {
 	register uint16_t crb;
 
@@ -3214,7 +3214,7 @@ static void PulseIndex_B(comedi_device * dev, enc_private * k)
 
 /*  Write value into counter preload register. */
 
-static void Preload(comedi_device * dev, enc_private * k, uint32_t value)
+static void Preload(comedi_device *dev, enc_private *k, uint32_t value)
 {
 	DEBUG("Preload: preload enter\n");
 	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
@@ -3223,7 +3223,7 @@ static void Preload(comedi_device * dev, enc_private * k, uint32_t value)
 		(uint16_t) (value >> 16));
 }
 
-static void CountersInit(comedi_device * dev)
+static void CountersInit(comedi_device *dev)
 {
 	int chan;
 	enc_private *k;

commit b6c777571b8d387d3add91170826f32a379e4313
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:03:24 2009 -0400

    Staging: comedi: Convert C99 style comments to traditional style comments
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 469ee8c474c9..24577a9a16b1 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -133,38 +133,30 @@ typedef struct {
 	void *base_addr;
 	int got_regions;
 	short allocatedBuf;
-	uint8_t ai_cmd_running;	// ai_cmd is running
-	uint8_t ai_continous;	// continous aquisition
-	int ai_sample_count;	// number of samples to aquire
-	unsigned int ai_sample_timer;	// time between samples in
-	// units of the timer
-	int ai_convert_count;	// conversion counter
-	unsigned int ai_convert_timer;	// time between conversion in
-	// units of the timer
-	uint16_t CounterIntEnabs;	//Counter interrupt enable
-	//mask for MISC2 register.
-	uint8_t AdcItems;	//Number of items in ADC poll
-	//list.
-	DMABUF RPSBuf;		//DMA buffer used to hold ADC
-	//(RPS1) program.
-	DMABUF ANABuf;		//DMA buffer used to receive
-	//ADC data and hold DAC data.
-	uint32_t *pDacWBuf;	//Pointer to logical adrs of
-	//DMA buffer used to hold DAC
-	//data.
-	uint16_t Dacpol;	//Image of DAC polarity
-	//register.
-	uint8_t TrimSetpoint[12];	//Images of TrimDAC setpoints.
-	//registers.
-	uint16_t ChargeEnabled;	//Image of MISC2 Battery
-	//Charge Enabled (0 or
-	//WRMISC2_CHARGE_ENABLE).
-	uint16_t WDInterval;	//Image of MISC2 watchdog
-	//interval control bits.
-	uint32_t I2CAdrs;	//I2C device address for
-	//onboard EEPROM (board rev
-	//dependent).
-	//  short         I2Cards;
+	uint8_t ai_cmd_running;	/*  ai_cmd is running */
+	uint8_t ai_continous;	/*  continous aquisition */
+	int ai_sample_count;	/*  number of samples to aquire */
+	unsigned int ai_sample_timer;
+	/*  time between samples in  units of the timer */
+	int ai_convert_count;	/*  conversion counter */
+	unsigned int ai_convert_timer;
+	/*  time between conversion in  units of the timer */
+	uint16_t CounterIntEnabs;
+	/* Counter interrupt enable  mask for MISC2 register. */
+	uint8_t AdcItems;	/* Number of items in ADC poll  list. */
+	DMABUF RPSBuf;		/* DMA buffer used to hold ADC (RPS1) program. */
+	DMABUF ANABuf;
+	/* DMA buffer used to receive ADC data and hold DAC data. */
+	uint32_t *pDacWBuf;
+	/* Pointer to logical adrs of DMA buffer used to hold DAC  data. */
+	uint16_t Dacpol;	/* Image of DAC polarity register. */
+	uint8_t TrimSetpoint[12];	/* Images of TrimDAC setpoints */
+	uint16_t ChargeEnabled;	/* Image of MISC2 Battery */
+	/* Charge Enabled (0 or WRMISC2_CHARGE_ENABLE). */
+	uint16_t WDInterval;	/* Image of MISC2 watchdog interval control bits. */
+	uint32_t I2CAdrs;
+	/* I2C device address for onboard EEPROM (board rev dependent). */
+	/*   short         I2Cards; */
 	lsampl_t ao_readback[S626_DAC_CHANNELS];
 } s626_private;
 
@@ -229,7 +221,7 @@ static dio_private *dio_private_word[]={
 
 COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
 
-//ioctl routines
+/* ioctl routines */
 static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, lsampl_t * data);
 /* static int s626_ai_rinsn(comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,lsampl_t *data); */
@@ -265,9 +257,9 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG);
 static lsampl_t s626_ai_reg_to_uint(int data);
 /* static lsampl_t s626_uint_to_reg(comedi_subdevice *s, int data); */
 
-//end ioctl routines
+/* end ioctl routines */
 
-//internal routines
+/* internal routines */
 static void s626_dio_init(comedi_device * dev);
 static void ResetADC(comedi_device * dev, uint8_t * ppl);
 static void LoadTrimDACs(comedi_device * dev);
@@ -285,30 +277,30 @@ static void DEBIreplace(comedi_device * dev, uint16_t addr, uint16_t mask,
 	uint16_t wdata);
 static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize);
 
-// COUNTER OBJECT ------------------------------------------------
+/*  COUNTER OBJECT ------------------------------------------------ */
 typedef struct enc_private_struct {
-	// Pointers to functions that differ for A and B counters:
-	uint16_t(*GetEnable) (comedi_device * dev, struct enc_private_struct *);	//Return clock enable.
-	uint16_t(*GetIntSrc) (comedi_device * dev, struct enc_private_struct *);	//Return interrupt source.
-	uint16_t(*GetLoadTrig) (comedi_device * dev, struct enc_private_struct *);	//Return preload trigger source.
-	uint16_t(*GetMode) (comedi_device * dev, struct enc_private_struct *);	//Return standardized operating mode.
-	void (*PulseIndex) (comedi_device * dev, struct enc_private_struct *);	//Generate soft index strobe.
-	void (*SetEnable) (comedi_device * dev, struct enc_private_struct *, uint16_t enab);	//Program clock enable.
-	void (*SetIntSrc) (comedi_device * dev, struct enc_private_struct *, uint16_t IntSource);	//Program interrupt source.
-	void (*SetLoadTrig) (comedi_device * dev, struct enc_private_struct *, uint16_t Trig);	//Program preload trigger source.
-	void (*SetMode) (comedi_device * dev, struct enc_private_struct *, uint16_t Setup, uint16_t DisableIntSrc);	//Program standardized operating mode.
-	void (*ResetCapFlags) (comedi_device * dev, struct enc_private_struct *);	//Reset event capture flags.
-
-	uint16_t MyCRA;		//   Address of CRA register.
-	uint16_t MyCRB;		//   Address of CRB register.
-	uint16_t MyLatchLsw;	//   Address of Latch least-significant-word
-	//   register.
-	uint16_t MyEventBits[4];	//   Bit translations for IntSrc -->RDMISC2.
-} enc_private;			//counter object
+	/*  Pointers to functions that differ for A and B counters: */
+	uint16_t(*GetEnable) (comedi_device * dev, struct enc_private_struct *);	/* Return clock enable. */
+	uint16_t(*GetIntSrc) (comedi_device * dev, struct enc_private_struct *);	/* Return interrupt source. */
+	uint16_t(*GetLoadTrig) (comedi_device * dev, struct enc_private_struct *);	/* Return preload trigger source. */
+	uint16_t(*GetMode) (comedi_device * dev, struct enc_private_struct *);	/* Return standardized operating mode. */
+	void (*PulseIndex) (comedi_device * dev, struct enc_private_struct *);	/* Generate soft index strobe. */
+	void (*SetEnable) (comedi_device * dev, struct enc_private_struct *, uint16_t enab);	/* Program clock enable. */
+	void (*SetIntSrc) (comedi_device * dev, struct enc_private_struct *, uint16_t IntSource);	/* Program interrupt source. */
+	void (*SetLoadTrig) (comedi_device * dev, struct enc_private_struct *, uint16_t Trig);	/* Program preload trigger source. */
+	void (*SetMode) (comedi_device * dev, struct enc_private_struct *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
+	void (*ResetCapFlags) (comedi_device * dev, struct enc_private_struct *);	/* Reset event capture flags. */
+
+	uint16_t MyCRA;		/*    Address of CRA register. */
+	uint16_t MyCRB;		/*    Address of CRB register. */
+	uint16_t MyLatchLsw;	/*    Address of Latch least-significant-word */
+	/*    register. */
+	uint16_t MyEventBits[4];	/*    Bit translations for IntSrc -->RDMISC2. */
+} enc_private;			/* counter object */
 
 #define encpriv ((enc_private *)(dev->subdevices+5)->private)
 
-//counters routines
+/* counters routines */
 static void s626_timer_load(comedi_device * dev, enc_private * k, int tick);
 static uint32_t ReadLatch(comedi_device * dev, enc_private * k);
 static void ResetCapFlags_A(comedi_device * dev, enc_private * k);
@@ -348,19 +340,17 @@ static void PulseIndex_A(comedi_device * dev, enc_private * k);
 static void PulseIndex_B(comedi_device * dev, enc_private * k);
 static void Preload(comedi_device * dev, enc_private * k, uint32_t value);
 static void CountersInit(comedi_device * dev);
-//end internal routines
+/* end internal routines */
 
-/////////////////////////////////////////////////////////////////////////
-// Counter objects constructor.
+/*  Counter objects constructor. */
 
-// Counter overflow/index event flag masks for RDMISC2.
+/*  Counter overflow/index event flag masks for RDMISC2. */
 #define INDXMASK(C)		( 1 << ( ( (C) > 2 ) ? ( (C) * 2 - 1 ) : ( (C) * 2 +  4 ) ) )
 #define OVERMASK(C)		( 1 << ( ( (C) > 2 ) ? ( (C) * 2 + 5 ) : ( (C) * 2 + 10 ) ) )
 #define EVBITS(C)		{ 0, OVERMASK(C), INDXMASK(C), OVERMASK(C) | INDXMASK(C) }
 
-// Translation table to map IntSrc into equivalent RDMISC2 event flag
-// bits.
-//static const uint16_t EventBits[][4] = { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) };
+/*  Translation table to map IntSrc into equivalent RDMISC2 event flag  bits. */
+/* static const uint16_t EventBits[][4] = { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) }; */
 
 /* enc_private; */
 static enc_private enc_private_data[] = {
@@ -462,8 +452,8 @@ static enc_private enc_private_data[] = {
 		},
 };
 
-// enab/disable a function or test status bit(s) that are accessed
-// through Main Control Registers 1 or 2.
+/*  enab/disable a function or test status bit(s) that are accessed */
+/*  through Main Control Registers 1 or 2. */
 #define MC_ENABLE( REGADRS, CTRLWORD )	writel(  ( (uint32_t)( CTRLWORD ) << 16 ) | (uint32_t)( CTRLWORD ),devpriv->base_addr+( REGADRS ) )
 
 #define MC_DISABLE( REGADRS, CTRLWORD )	writel(  (uint32_t)( CTRLWORD ) << 16 , devpriv->base_addr+( REGADRS ) )
@@ -480,11 +470,11 @@ static enc_private enc_private_data[] = {
 
 #define BUGFIX_STREG(REGADRS)   ( REGADRS - 4 )
 
-// Write a time slot control record to TSL2.
+/*  Write a time slot control record to TSL2. */
 #define VECTPORT( VECTNUM )		(P_TSL2 + ( (VECTNUM) << 2 ))
 #define SETVECT( VECTNUM, VECTVAL )	WR7146(VECTPORT( VECTNUM ), (VECTVAL))
 
-// Code macros used for constructing I2C command bytes.
+/*  Code macros used for constructing I2C command bytes. */
 #define I2C_B2(ATTR,VAL)	( ( (ATTR) << 6 ) | ( (VAL) << 24 ) )
 #define I2C_B1(ATTR,VAL)	( ( (ATTR) << 4 ) | ( (VAL) << 16 ) )
 #define I2C_B0(ATTR,VAL)	( ( (ATTR) << 2 ) | ( (VAL) <<  8 ) )
@@ -550,16 +540,16 @@ static int s626_attach(comedi_device * dev, comedi_devconfig * it)
 	}
 
 	if (devpriv->base_addr) {
-		//disable master interrupt
+		/* disable master interrupt */
 		writel(0, devpriv->base_addr + P_IER);
 
-		//soft reset
+		/* soft reset */
 		writel(MC1_SOFT_RESET, devpriv->base_addr + P_MC1);
 
-		//DMA FIXME DMA//
+		/* DMA FIXME DMA// */
 		DEBUG("s626_attach: DMA ALLOCATION\n");
 
-		//adc buffer allocation
+		/* adc buffer allocation */
 		devpriv->allocatedBuf = 0;
 
 		if ((devpriv->ANABuf.LogicalBase =
@@ -599,7 +589,7 @@ static int s626_attach(comedi_device * dev, comedi_devconfig * it)
 	dev->iobase = (unsigned long)devpriv->base_addr;
 	dev->irq = devpriv->pdev->irq;
 
-	//set up interrupt handler
+	/* set up interrupt handler */
 	if (dev->irq == 0) {
 		printk(" unknown irq (bad)\n");
 	} else {
@@ -689,119 +679,119 @@ static int s626_attach(comedi_device * dev, comedi_devconfig * it)
 	s->maxdata = 0xffffff;
 	s->range_table = &range_unknown;
 
-	//stop ai_command
+	/* stop ai_command */
 	devpriv->ai_cmd_running = 0;
 
 	if (devpriv->base_addr && (devpriv->allocatedBuf == 2)) {
 		dma_addr_t pPhysBuf;
 		uint16_t chan;
 
-		// enab DEBI and audio pins, enable I2C interface.
+		/*  enab DEBI and audio pins, enable I2C interface. */
 		MC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);
-		// Configure DEBI operating mode.
-		WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	// Local bus is 16
-			// bits wide.
-			| (DEBI_TOUT << DEBI_CFG_TOUT_BIT)	// Declare DEBI
-			// transfer timeout
-			// interval.
-			| DEBI_SWAP	// Set up byte lane
-			// steering.
-			| DEBI_CFG_INTEL);	// Intel-compatible
-		// local bus (DEBI
-		// never times out).
+		/*  Configure DEBI operating mode. */
+		WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	/*  Local bus is 16 */
+			/*  bits wide. */
+			| (DEBI_TOUT << DEBI_CFG_TOUT_BIT)	/*  Declare DEBI */
+			/*  transfer timeout */
+			/*  interval. */
+			| DEBI_SWAP	/*  Set up byte lane */
+			/*  steering. */
+			| DEBI_CFG_INTEL);	/*  Intel-compatible */
+		/*  local bus (DEBI */
+		/*  never times out). */
 		DEBUG("s626_attach: %d debi init -- %d\n",
 			DEBI_CFG_SLAVE16 | (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
 			DEBI_SWAP | DEBI_CFG_INTEL,
 			DEBI_CFG_INTEL | DEBI_CFG_TOQ | DEBI_CFG_INCQ |
 			DEBI_CFG_16Q);
 
-		//DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ
-		//| DEBI_CFG_INCQ| DEBI_CFG_16Q); //end
+		/* DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ */
+		/* | DEBI_CFG_INCQ| DEBI_CFG_16Q); //end */
 
-		// Paging is disabled.
-		WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);	// Disable MMU paging.
+		/*  Paging is disabled. */
+		WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);	/*  Disable MMU paging. */
 
-		// Init GPIO so that ADC Start* is negated.
+		/*  Init GPIO so that ADC Start* is negated. */
 		WR7146(P_GPIO, GPIO_BASE | GPIO1_HI);
 
-		//IsBoardRevA is a boolean that indicates whether the board is
-		//RevA.
-
-		// VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
-		// EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
-		// is used to access the onboard serial EEPROM.  The EEPROM's I2C
-		// DeviceAddress is hardwired to a value that is dependent on the
-		// 626 board revision.  On all board revisions, the EEPROM stores
-		// TrimDAC calibration constants for analog I/O.  On RevB and
-		// higher boards, the DeviceAddress is hardwired to 0 to enable
-		// the EEPROM to also store the PCI SubVendorID and SubDeviceID;
-		// this is the address at which the SAA7146 expects a
-		// configuration EEPROM to reside.  On RevA boards, the EEPROM
-		// device address, which is hardwired to 4, prevents the SAA7146
-		// from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
-		// default values, instead.
-
-		//    devpriv->I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM
-		// DeviceType (0xA0)
-		// and DeviceAddress<<1.
-
-		devpriv->I2CAdrs = 0xA0;	// I2C device address for onboard
-		// eeprom(revb)
-
-		// Issue an I2C ABORT command to halt any I2C operation in
-		//progress and reset BUSY flag.
-		WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);	// Write I2C control:
-		// abort any I2C
-		// activity.
-		MC_ENABLE(P_MC2, MC2_UPLD_IIC);	// Invoke command
-		// upload
-		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0) ;	// and wait for
-		// upload to
-		// complete.
-
-		// Per SAA7146 data sheet, write to STATUS reg twice to reset all
-		// I2C error flags.
+    /* IsBoardRevA is a boolean that indicates whether the board is RevA.
+     *
+     * VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
+     * EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
+     * is used to access the onboard serial EEPROM.  The EEPROM's I2C
+     * DeviceAddress is hardwired to a value that is dependent on the
+     * 626 board revision.  On all board revisions, the EEPROM stores
+     * TrimDAC calibration constants for analog I/O.  On RevB and
+     * higher boards, the DeviceAddress is hardwired to 0 to enable
+     * the EEPROM to also store the PCI SubVendorID and SubDeviceID;
+     * this is the address at which the SAA7146 expects a
+     * configuration EEPROM to reside.  On RevA boards, the EEPROM
+     * device address, which is hardwired to 4, prevents the SAA7146
+     * from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
+     * default values, instead.
+     */
+
+		/*     devpriv->I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM */
+		/*  DeviceType (0xA0) */
+		/*  and DeviceAddress<<1. */
+
+		devpriv->I2CAdrs = 0xA0;	/*  I2C device address for onboard */
+		/*  eeprom(revb) */
+
+		/*  Issue an I2C ABORT command to halt any I2C operation in */
+		/* progress and reset BUSY flag. */
+		WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);
+		/*  Write I2C control: abort any I2C activity. */
+		MC_ENABLE(P_MC2, MC2_UPLD_IIC);
+		/*  Invoke command  upload */
+		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0);
+		/*  and wait for upload to complete. */
+
+		/* Per SAA7146 data sheet, write to STATUS reg twice to
+		 * reset all  I2C error flags. */
 		for (i = 0; i < 2; i++) {
-			WR7146(P_I2CSTAT, I2C_CLKSEL);	// Write I2C control: reset
-			// error flags.
-			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	// Invoke command upload
-			while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;	//   and wait for
-			//   upload to
-			//   complete.
+			WR7146(P_I2CSTAT, I2C_CLKSEL);
+			/*  Write I2C control: reset  error flags. */
+			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	/*  Invoke command upload */
+			while (!MC_TEST(P_MC2, MC2_UPLD_IIC));
+			/* and wait for upload to complete. */
 		}
 
-		// Init audio interface functional attributes: set DAC/ADC serial
-		// clock rates, invert DAC serial clock so that DAC data setup
-		// times are satisfied, enable DAC serial clock out.
+		/* Init audio interface functional attributes: set DAC/ADC
+		 * serial clock rates, invert DAC serial clock so that
+		 * DAC data setup times are satisfied, enable DAC serial
+		 * clock out.
+		 */
+
 		WR7146(P_ACON2, ACON2_INIT);
 
-		// Set up TSL1 slot list, which is used to control the
-		// accumulation of ADC data: RSD1 = shift data in on SD1.  SIB_A1
-		// = store data uint8_t at next available location in FB BUFFER1
-		// register.
-		WR7146(P_TSL1, RSD1 | SIB_A1);	// Fetch ADC high data
-		// uint8_t.
-		WR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);	// Fetch ADC low data
-		// uint8_t; end of
-		// TSL1.
-
-		// enab TSL1 slot list so that it executes all the time.
+		/* Set up TSL1 slot list, which is used to control the
+		 * accumulation of ADC data: RSD1 = shift data in on SD1.
+		 * SIB_A1  = store data uint8_t at next available location in
+		 * FB BUFFER1  register. */
+		WR7146(P_TSL1, RSD1 | SIB_A1);
+		/*  Fetch ADC high data uint8_t. */
+		WR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);
+		/*  Fetch ADC low data uint8_t; end of TSL1. */
+
+		/*  enab TSL1 slot list so that it executes all the time. */
 		WR7146(P_ACON1, ACON1_ADCSTART);
 
-		// Initialize RPS registers used for ADC.
+		/*  Initialize RPS registers used for ADC. */
 
-		//Physical start of RPS program.
+		/* Physical start of RPS program. */
 		WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
 
-		WR7146(P_RPSPAGE1, 0);	// RPS program performs no
-		// explicit mem writes.
-		WR7146(P_RPS1_TOUT, 0);	// Disable RPS timeouts.
+		WR7146(P_RPSPAGE1, 0);
+		/*  RPS program performs no explicit mem writes. */
+		WR7146(P_RPS1_TOUT, 0);	/*  Disable RPS timeouts. */
 
-		// SAA7146 BUG WORKAROUND.  Initialize SAA7146 ADC interface to a
-		// known state by invoking ADCs until FB BUFFER 1 register shows
-		// that it is correctly receiving ADC data.  This is necessary
-		// because the SAA7146 ADC interface does not start up in a
-		// defined state after a PCI reset.
+		/* SAA7146 BUG WORKAROUND.  Initialize SAA7146 ADC interface
+		 * to a known state by invoking ADCs until FB BUFFER 1
+		 * register shows that it is correctly receiving ADC data.
+		 * This is necessary because the SAA7146 ADC interface does
+		 * not start up in a defined state after a PCI reset.
+		 */
 
 /*     PollList = EOPL;			// Create a simple polling */
 /* 					// list for analog input */
@@ -829,115 +819,123 @@ static int s626_attach(comedi_device * dev, comedi_devconfig * it)
 /* 	  break; */
 /*       } */
 
-		// end initADC
+		/*  end initADC */
 
-		// init the DAC interface
+		/*  init the DAC interface */
 
-		// Init Audio2's output DMAC attributes: burst length = 1 DWORD,
-		// threshold = 1 DWORD.
+		/* Init Audio2's output DMAC attributes: burst length = 1
+		 * DWORD,  threshold = 1 DWORD.
+		 */
 		WR7146(P_PCI_BT_A, 0);
 
-		// Init Audio2's output DMA physical addresses.  The protection
-		// address is set to 1 DWORD past the base address so that a
-		// single DWORD will be transferred each time a DMA transfer is
-		// enabled.
+		/* Init Audio2's output DMA physical addresses.  The protection
+		 * address is set to 1 DWORD past the base address so that a
+		 * single DWORD will be transferred each time a DMA transfer is
+		 * enabled. */
 
 		pPhysBuf =
 			devpriv->ANABuf.PhysicalBase +
 			(DAC_WDMABUF_OS * sizeof(uint32_t));
 
-		WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	// Buffer base adrs.
-		WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	// Protection address.
+		WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	/*  Buffer base adrs. */
+		WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	/*  Protection address. */
 
-		// Cache Audio2's output DMA buffer logical address.  This is
-		// where DAC data is buffered for A2 output DMA transfers.
+		/* Cache Audio2's output DMA buffer logical address.  This is
+		 * where DAC data is buffered for A2 output DMA transfers. */
 		devpriv->pDacWBuf =
 			(uint32_t *) devpriv->ANABuf.LogicalBase +
 			DAC_WDMABUF_OS;
 
-		// Audio2's output channels does not use paging.  The protection
-		// violation handling bit is set so that the DMAC will
-		// automatically halt and its PCI address pointer will be reset
-		// when the protection address is reached.
+		/* Audio2's output channels does not use paging.  The protection
+		 * violation handling bit is set so that the DMAC will
+		 * automatically halt and its PCI address pointer will be reset
+		 * when the protection address is reached. */
+
 		WR7146(P_PAGEA2_OUT, 8);
 
-		// Initialize time slot list 2 (TSL2), which is used to control
-		// the clock generation for and serialization of data to be sent
-		// to the DAC devices.  Slot 0 is a NOP that is used to trap TSL
-		// execution; this permits other slots to be safely modified
-		// without first turning off the TSL sequencer (which is
-		// apparently impossible to do).  Also, SD3 (which is driven by a
-		// pull-up resistor) is shifted in and stored to the MSB of
-		// FB_BUFFER2 to be used as evidence that the slot sequence has
-		// not yet finished executing.
-		SETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);	// Slot 0: Trap TSL
-		// execution, shift 0xFF
-		// into FB_BUFFER2.
-
-		// Initialize slot 1, which is constant.  Slot 1 causes a DWORD to
-		// be transferred from audio channel 2's output FIFO to the FIFO's
-		// output buffer so that it can be serialized and sent to the DAC
-		// during subsequent slots.  All remaining slots are dynamically
-		// populated as required by the target DAC device.
-		SETVECT(1, LF_A2);	// Slot 1: Fetch DWORD from Audio2's
-		// output FIFO.
-
-		// Start DAC's audio interface (TSL2) running.
+		/* Initialize time slot list 2 (TSL2), which is used to control
+		 * the clock generation for and serialization of data to be sent
+		 * to the DAC devices.  Slot 0 is a NOP that is used to trap TSL
+		 * execution; this permits other slots to be safely modified
+		 * without first turning off the TSL sequencer (which is
+		 * apparently impossible to do).  Also, SD3 (which is driven by a
+		 * pull-up resistor) is shifted in and stored to the MSB of
+		 * FB_BUFFER2 to be used as evidence that the slot sequence has
+		 * not yet finished executing.
+		 */
+
+		SETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);
+		/*  Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2. */
+
+		/* Initialize slot 1, which is constant.  Slot 1 causes a
+		 * DWORD to be transferred from audio channel 2's output FIFO
+		 * to the FIFO's output buffer so that it can be serialized
+		 * and sent to the DAC during subsequent slots.  All remaining
+		 * slots are dynamically populated as required by the target
+		 * DAC device.
+		 */
+		SETVECT(1, LF_A2);
+		/*  Slot 1: Fetch DWORD from Audio2's output FIFO. */
+
+		/*  Start DAC's audio interface (TSL2) running. */
 		WR7146(P_ACON1, ACON1_DACSTART);
 
-		////////////////////////////////////////////////////////
-
-		// end init DAC interface
+		/* end init DAC interface */
 
-		// Init Trim DACs to calibrated values.  Do it twice because the
-		// SAA7146 audio channel does not always reset properly and
-		// sometimes causes the first few TrimDAC writes to malfunction.
+		/* Init Trim DACs to calibrated values.  Do it twice because the
+		 * SAA7146 audio channel does not always reset properly and
+		 * sometimes causes the first few TrimDAC writes to malfunction.
+		 */
 
 		LoadTrimDACs(dev);
-		LoadTrimDACs(dev);	// Insurance.
+		LoadTrimDACs(dev);	/*  Insurance. */
 
-		//////////////////////////////////////////////////////////////////
-		// Manually init all gate array hardware in case this is a soft
-		// reset (we have no way of determining whether this is a warm or
-		// cold start).  This is necessary because the gate array will
-		// reset only in response to a PCI hard reset; there is no soft
-		// reset function.
+		/* Manually init all gate array hardware in case this is a soft
+		 * reset (we have no way of determining whether this is a warm
+		 * or cold start).  This is necessary because the gate array will
+		 * reset only in response to a PCI hard reset; there is no soft
+		 * reset function. */
 
-		// Init all DAC outputs to 0V and init all DAC setpoint and
-		// polarity images.
+		/* Init all DAC outputs to 0V and init all DAC setpoint and
+		 * polarity images.
+		 */
 		for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
 			SetDAC(dev, chan, 0);
 
-		// Init image of WRMISC2 Battery Charger Enabled control bit.
-		// This image is used when the state of the charger control bit,
-		// which has no direct hardware readback mechanism, is queried.
+		/* Init image of WRMISC2 Battery Charger Enabled control bit.
+		 * This image is used when the state of the charger control bit,
+		 * which has no direct hardware readback mechanism, is queried.
+		 */
 		devpriv->ChargeEnabled = 0;
 
-		// Init image of watchdog timer interval in WRMISC2.  This image
-		// maintains the value of the control bits of MISC2 are
-		// continuously reset to zero as long as the WD timer is disabled.
+		/* Init image of watchdog timer interval in WRMISC2.  This image
+		 * maintains the value of the control bits of MISC2 are
+		 * continuously reset to zero as long as the WD timer is disabled.
+		 */
 		devpriv->WDInterval = 0;
 
-		// Init Counter Interrupt enab mask for RDMISC2.  This mask is
-		// applied against MISC2 when testing to determine which timer
-		// events are requesting interrupt service.
+		/* Init Counter Interrupt enab mask for RDMISC2.  This mask is
+		 * applied against MISC2 when testing to determine which timer
+		 * events are requesting interrupt service.
+		 */
 		devpriv->CounterIntEnabs = 0;
 
-		// Init counters.
+		/*  Init counters. */
 		CountersInit(dev);
 
-		// Without modifying the state of the Battery Backup enab, disable
-		// the watchdog timer, set DIO channels 0-5 to operate in the
-		// standard DIO (vs. counter overflow) mode, disable the battery
-		// charger, and reset the watchdog interval selector to zero.
+		/* Without modifying the state of the Battery Backup enab, disable
+		 * the watchdog timer, set DIO channels 0-5 to operate in the
+		 * standard DIO (vs. counter overflow) mode, disable the battery
+		 * charger, and reset the watchdog interval selector to zero.
+		 */
 		WriteMISC2(dev, (uint16_t) (DEBIread(dev,
 					LP_RDMISC2) & MISC2_BATT_ENABLE));
 
-		// Initialize the digital I/O subsystem.
+		/*  Initialize the digital I/O subsystem. */
 		s626_dio_init(dev);
 
-		//enable interrupt test
-		// writel(IRQ_GPIO3 | IRQ_RPS1,devpriv->base_addr+P_IER);
+		/* enable interrupt test */
+		/*  writel(IRQ_GPIO3 | IRQ_RPS1,devpriv->base_addr+P_IER); */
 	}
 
 	DEBUG("s626_attach: comedi%d s626 attached %04x\n", dev->minor,
@@ -981,47 +979,48 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 
 	if (dev->attached == 0)
 		return IRQ_NONE;
-	// lock to avoid race with comedi_poll
+	/*  lock to avoid race with comedi_poll */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 
-	//save interrupt enable register state
+	/* save interrupt enable register state */
 	irqstatus = readl(devpriv->base_addr + P_IER);
 
-	//read interrupt type
+	/* read interrupt type */
 	irqtype = readl(devpriv->base_addr + P_ISR);
 
-	//disable master interrupt
+	/* disable master interrupt */
 	writel(0, devpriv->base_addr + P_IER);
 
-	//clear interrupt
+	/* clear interrupt */
 	writel(irqtype, devpriv->base_addr + P_ISR);
 
-	//do somethings
+	/* do somethings */
 	DEBUG("s626_irq_handler: interrupt type %d\n", irqtype);
 
 	switch (irqtype) {
-	case IRQ_RPS1:		// end_of_scan occurs
+	case IRQ_RPS1:		/*  end_of_scan occurs */
 
 		DEBUG("s626_irq_handler: RPS1 irq detected\n");
 
-		// manage ai subdevice
+		/*  manage ai subdevice */
 		s = dev->subdevices;
 		cmd = &(s->async->cmd);
 
-		// Init ptr to DMA buffer that holds new ADC data.  We skip the
-		// first uint16_t in the buffer because it contains junk data from
-		// the final ADC of the previous poll list scan.
+		/* Init ptr to DMA buffer that holds new ADC data.  We skip the
+		 * first uint16_t in the buffer because it contains junk data from
+		 * the final ADC of the previous poll list scan.
+		 */
 		readaddr = (int32_t *) devpriv->ANABuf.LogicalBase + 1;
 
-		// get the data and hand it over to comedi
+		/*  get the data and hand it over to comedi */
 		for (i = 0; i < (s->async->cmd.chanlist_len); i++) {
-			// Convert ADC data to 16-bit integer values and copy to application
-			// buffer.
+			/*  Convert ADC data to 16-bit integer values and copy to application */
+			/*  buffer. */
 			tempdata = s626_ai_reg_to_uint((int)*readaddr);
 			readaddr++;
 
-			//put data into read buffer
-			// comedi_buf_put(s->async, tempdata);
+			/* put data into read buffer */
+			/*  comedi_buf_put(s->async, tempdata); */
 			if (cfc_write_to_buffer(s, tempdata) == 0)
 				printk("s626_irq_handler: cfc_write_to_buffer error!\n");
 
@@ -1029,7 +1028,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 				i, tempdata);
 		}
 
-		//end of scan occurs
+		/* end of scan occurs */
 		s->async->events |= COMEDI_CB_EOS;
 
 		if (!(devpriv->ai_continous))
@@ -1037,13 +1036,13 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 		if (devpriv->ai_sample_count <= 0) {
 			devpriv->ai_cmd_running = 0;
 
-			// Stop RPS program.
+			/*  Stop RPS program. */
 			MC_DISABLE(P_MC1, MC1_ERPS1);
 
-			//send end of acquisition
+			/* send end of acquisition */
 			s->async->events |= COMEDI_CB_EOA;
 
-			//disable master interrupt
+			/* disable master interrupt */
 			irqstatus = 0;
 		}
 
@@ -1054,40 +1053,40 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 
 			DEBUG("s626_irq_handler: External trigger is set!!!\n");
 		}
-		// tell comedi that data is there
+		/*  tell comedi that data is there */
 		DEBUG("s626_irq_handler: events %d\n", s->async->events);
 		comedi_event(dev, s);
 		break;
-	case IRQ_GPIO3:	//check dio and conter interrupt
+	case IRQ_GPIO3:	/* check dio and conter interrupt */
 
 		DEBUG("s626_irq_handler: GPIO3 irq detected\n");
 
-		// manage ai subdevice
+		/*  manage ai subdevice */
 		s = dev->subdevices;
 		cmd = &(s->async->cmd);
 
-		//s626_dio_clear_irq(dev);
+		/* s626_dio_clear_irq(dev); */
 
 		for (group = 0; group < S626_DIO_BANKS; group++) {
 			irqbit = 0;
-			//read interrupt type
+			/* read interrupt type */
 			irqbit = DEBIread(dev,
 				((dio_private *) (dev->subdevices + 2 +
 						group)->private)->RDCapFlg);
 
-			//check if interrupt is generated from dio channels
+			/* check if interrupt is generated from dio channels */
 			if (irqbit) {
 				s626_dio_reset_irq(dev, group, irqbit);
 				DEBUG("s626_irq_handler: check interrupt on dio group %d %d\n", group, i);
 				if (devpriv->ai_cmd_running) {
-					//check if interrupt is an ai acquisition start trigger
+					/* check if interrupt is an ai acquisition start trigger */
 					if ((irqbit >> (cmd->start_arg -
 								(16 * group)))
 						== 1
 						&& cmd->start_src == TRIG_EXT) {
 						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->start_arg);
 
-						// Start executing the RPS program.
+						/*  Start executing the RPS program. */
 						MC_ENABLE(P_MC1, MC1_ERPS1);
 
 						DEBUG("s626_irq_handler: aquisition start triggered!!!\n");
@@ -1110,7 +1109,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 						TRIG_EXT) {
 						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->scan_begin_arg);
 
-						// Trigger ADC scan loop start by setting RPS Signal 0.
+						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
 						DEBUG("s626_irq_handler: scan triggered!!! %d\n", devpriv->ai_sample_count);
@@ -1151,7 +1150,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 						TRIG_EXT) {
 						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->convert_arg);
 
-						// Trigger ADC scan loop start by setting RPS Signal 0.
+						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
 						DEBUG("s626_irq_handler: adc convert triggered!!!\n");
@@ -1175,10 +1174,10 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 			}
 		}
 
-		//read interrupt type
+		/* read interrupt type */
 		irqbit = DEBIread(dev, LP_RDMISC2);
 
-		//check interrupt on counters
+		/* check interrupt on counters */
 		DEBUG("s626_irq_handler: check counters interrupt %d\n",
 			irqbit);
 
@@ -1186,35 +1185,35 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 			DEBUG("s626_irq_handler: interrupt on counter 1A overflow\n");
 			k = &encpriv[0];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT2A) {
 			DEBUG("s626_irq_handler: interrupt on counter 2A overflow\n");
 			k = &encpriv[1];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT3A) {
 			DEBUG("s626_irq_handler: interrupt on counter 3A overflow\n");
 			k = &encpriv[2];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT1B) {
 			DEBUG("s626_irq_handler: interrupt on counter 1B overflow\n");
 			k = &encpriv[3];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT2B) {
 			DEBUG("s626_irq_handler: interrupt on counter 2B overflow\n");
 			k = &encpriv[4];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 
 			if (devpriv->ai_convert_count > 0) {
@@ -1225,7 +1224,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 				if (cmd->convert_src == TRIG_TIMER) {
 					DEBUG("s626_irq_handler: conver timer trigger!!! %d\n", devpriv->ai_convert_count);
 
-					// Trigger ADC scan loop start by setting RPS Signal 0.
+					/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 					MC_ENABLE(P_MC2, MC2_ADC_RPS);
 				}
 			}
@@ -1234,13 +1233,13 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 			DEBUG("s626_irq_handler: interrupt on counter 3B overflow\n");
 			k = &encpriv[5];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 
 			if (cmd->scan_begin_src == TRIG_TIMER) {
 				DEBUG("s626_irq_handler: scan timer trigger!!!\n");
 
-				// Trigger ADC scan loop start by setting RPS Signal 0.
+				/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 				MC_ENABLE(P_MC2, MC2_ADC_RPS);
 			}
 
@@ -1253,7 +1252,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 		}
 	}
 
-	//enable interrupt
+	/* enable interrupt */
 	writel(irqstatus, devpriv->base_addr + P_IER);
 
 	DEBUG("s626_irq_handler: exit interrupt service routine.\n");
@@ -1265,18 +1264,18 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 static int s626_detach(comedi_device * dev)
 {
 	if (devpriv) {
-		//stop ai_command
+		/* stop ai_command */
 		devpriv->ai_cmd_running = 0;
 
 		if (devpriv->base_addr) {
-			//interrupt mask
-			WR7146(P_IER, 0);	// Disable master interrupt.
-			WR7146(P_ISR, IRQ_GPIO3 | IRQ_RPS1);	// Clear board's IRQ status flag.
+			/* interrupt mask */
+			WR7146(P_IER, 0);	/*  Disable master interrupt. */
+			WR7146(P_ISR, IRQ_GPIO3 | IRQ_RPS1);	/*  Clear board's IRQ status flag. */
 
-			// Disable the watchdog timer and battery charger.
+			/*  Disable the watchdog timer and battery charger. */
 			WriteMISC2(dev, 0);
 
-			// Close all interfaces on 7146 device.
+			/*  Close all interfaces on 7146 device. */
 			WR7146(P_MC1, MC1_SHUTDOWN);
 			WR7146(P_ACON1, ACON1_BASE);
 
@@ -1317,174 +1316,186 @@ void ResetADC(comedi_device * dev, uint8_t * ppl)
 	uint32_t LocalPPL;
 	comedi_cmd *cmd = &(dev->subdevices->async->cmd);
 
-	// Stop RPS program in case it is currently running.
+	/*  Stop RPS program in case it is currently running. */
 	MC_DISABLE(P_MC1, MC1_ERPS1);
 
-	// Set starting logical address to write RPS commands.
+	/*  Set starting logical address to write RPS commands. */
 	pRPS = (uint32_t *) devpriv->RPSBuf.LogicalBase;
 
-	// Initialize RPS instruction pointer.
+	/*  Initialize RPS instruction pointer. */
 	WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
 
-	// Construct RPS program in RPSBuf DMA buffer
+	/*  Construct RPS program in RPSBuf DMA buffer */
 
 	if (cmd != NULL && cmd->scan_begin_src != TRIG_FOLLOW) {
 		DEBUG("ResetADC: scan_begin pause inserted\n");
-		// Wait for Start trigger.
+		/*  Wait for Start trigger. */
 		*pRPS++ = RPS_PAUSE | RPS_SIGADC;
 		*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
 	}
-	// SAA7146 BUG WORKAROUND Do a dummy DEBI Write.  This is necessary
-	// because the first RPS DEBI Write following a non-RPS DEBI write
-	// seems to always fail.  If we don't do this dummy write, the ADC
-	// gain might not be set to the value required for the first slot in
-	// the poll list; the ADC gain would instead remain unchanged from
-	// the previously programmed value.
-	*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	// Write DEBI Write command
-	// and address to shadow RAM.
+
+	/* SAA7146 BUG WORKAROUND Do a dummy DEBI Write.  This is necessary
+	 * because the first RPS DEBI Write following a non-RPS DEBI write
+	 * seems to always fail.  If we don't do this dummy write, the ADC
+	 * gain might not be set to the value required for the first slot in
+	 * the poll list; the ADC gain would instead remain unchanged from
+	 * the previously programmed value.
+	 */
+	*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
+	/* Write DEBI Write command and address to shadow RAM. */
+
 	*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
-	*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	// Write DEBI immediate data
-	// to shadow RAM:
-	*pRPS++ = GSEL_BIPOLAR5V;	// arbitrary immediate data
-	// value.
-	*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	// Reset "shadow RAM
-	// uploaded" flag.
-	*pRPS++ = RPS_UPLOAD | RPS_DEBI;	// Invoke shadow RAM upload.
-	*pRPS++ = RPS_PAUSE | RPS_DEBI;	// Wait for shadow upload to finish.
-
-	// Digitize all slots in the poll list. This is implemented as a
-	// for loop to limit the slot count to 16 in case the application
-	// forgot to set the EOPL flag in the final slot.
+	*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
+	/*  Write DEBI immediate data  to shadow RAM: */
+
+	*pRPS++ = GSEL_BIPOLAR5V;
+	/*  arbitrary immediate data  value. */
+
+	*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
+	/*  Reset "shadow RAM  uploaded" flag. */
+	*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/*  Invoke shadow RAM upload. */
+	*pRPS++ = RPS_PAUSE | RPS_DEBI;	/*  Wait for shadow upload to finish. */
+
+	/* Digitize all slots in the poll list. This is implemented as a
+	 * for loop to limit the slot count to 16 in case the application
+	 * forgot to set the EOPL flag in the final slot.
+	 */
 	for (devpriv->AdcItems = 0; devpriv->AdcItems < 16; devpriv->AdcItems++) {
-		// Convert application's poll list item to private board class
-		// format.  Each app poll list item is an uint8_t with form
-		// (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
-		// +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
+	 /* Convert application's poll list item to private board class
+	  * format.  Each app poll list item is an uint8_t with form
+	  * (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
+	  * +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
+	  */
 		LocalPPL =
 			(*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
 			GSEL_BIPOLAR10V);
 
-		// Switch ADC analog gain.
-		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	// Write DEBI command
-		// and address to
-		// shadow RAM.
+		/*  Switch ADC analog gain. */
+		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	/*  Write DEBI command */
+		/*  and address to */
+		/*  shadow RAM. */
 		*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
-		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	// Write DEBI
-		// immediate data to
-		// shadow RAM.
+		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	/*  Write DEBI */
+		/*  immediate data to */
+		/*  shadow RAM. */
 		*pRPS++ = LocalPPL;
-		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	// Reset "shadow RAM uploaded"
-		// flag.
-		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	// Invoke shadow RAM upload.
-		*pRPS++ = RPS_PAUSE | RPS_DEBI;	// Wait for shadow upload to
-		// finish.
-
-		// Select ADC analog input channel.
-		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	// Write DEBI command
-		// and address to
-		// shadow RAM.
+		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	/*  Reset "shadow RAM uploaded" */
+		/*  flag. */
+		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/*  Invoke shadow RAM upload. */
+		*pRPS++ = RPS_PAUSE | RPS_DEBI;	/*  Wait for shadow upload to */
+		/*  finish. */
+
+		/*  Select ADC analog input channel. */
+		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
+		/*  Write DEBI command and address to  shadow RAM. */
 		*pRPS++ = DEBI_CMD_WRWORD | LP_ISEL;
-		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	// Write DEBI
-		// immediate data to
-		// shadow RAM.
+		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
+		/*  Write DEBI immediate data to shadow RAM. */
 		*pRPS++ = LocalPPL;
-		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	// Reset "shadow RAM uploaded"
-		// flag.
-		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	// Invoke shadow RAM upload.
-		*pRPS++ = RPS_PAUSE | RPS_DEBI;	// Wait for shadow upload to
-		// finish.
-
-		// Delay at least 10 microseconds for analog input settling.
-		// Instead of padding with NOPs, we use RPS_JUMP instructions
-		// here; this allows us to produce a longer delay than is
-		// possible with NOPs because each RPS_JUMP flushes the RPS'
-		// instruction prefetch pipeline.
+		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
+		/*  Reset "shadow RAM uploaded"  flag. */
+
+		*pRPS++ = RPS_UPLOAD | RPS_DEBI;
+		/*  Invoke shadow RAM upload. */
+
+		*pRPS++ = RPS_PAUSE | RPS_DEBI;
+		/*  Wait for shadow upload to finish. */
+
+		/* Delay at least 10 microseconds for analog input settling.
+		 * Instead of padding with NOPs, we use RPS_JUMP instructions
+		 * here; this allows us to produce a longer delay than is
+		 * possible with NOPs because each RPS_JUMP flushes the RPS'
+		 * instruction prefetch pipeline.
+		 */
 		JmpAdrs =
 			(uint32_t) devpriv->RPSBuf.PhysicalBase +
 			(uint32_t) ((unsigned long)pRPS -
 			(unsigned long)devpriv->RPSBuf.LogicalBase);
 		for (i = 0; i < (10 * RPSCLK_PER_US / 2); i++) {
-			JmpAdrs += 8;	// Repeat to implement time delay:
-			*pRPS++ = RPS_JUMP;	// Jump to next RPS instruction.
+			JmpAdrs += 8;	/*  Repeat to implement time delay: */
+			*pRPS++ = RPS_JUMP;	/*  Jump to next RPS instruction. */
 			*pRPS++ = JmpAdrs;
 		}
 
 		if (cmd != NULL && cmd->convert_src != TRIG_NOW) {
 			DEBUG("ResetADC: convert pause inserted\n");
-			// Wait for Start trigger.
+			/*  Wait for Start trigger. */
 			*pRPS++ = RPS_PAUSE | RPS_SIGADC;
 			*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
 		}
-		// Start ADC by pulsing GPIO1.
-		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	// Begin ADC Start pulse.
+		/*  Start ADC by pulsing GPIO1. */
+		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  Begin ADC Start pulse. */
 		*pRPS++ = GPIO_BASE | GPIO1_LO;
 		*pRPS++ = RPS_NOP;
-		// VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE.
-		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	// End ADC Start pulse.
+		/*  VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
+		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  End ADC Start pulse. */
 		*pRPS++ = GPIO_BASE | GPIO1_HI;
 
-		// Wait for ADC to complete (GPIO2 is asserted high when ADC not
-		// busy) and for data from previous conversion to shift into FB
-		// BUFFER 1 register.
-		*pRPS++ = RPS_PAUSE | RPS_GPIO2;	// Wait for ADC done.
+		/* Wait for ADC to complete (GPIO2 is asserted high when ADC not
+		 * busy) and for data from previous conversion to shift into FB
+		 * BUFFER 1 register.
+		 */
+		*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/*  Wait for ADC done. */
 
-		// Transfer ADC data from FB BUFFER 1 register to DMA buffer.
+		/*  Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
 		*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
 		*pRPS++ =
 			(uint32_t) devpriv->ANABuf.PhysicalBase +
 			(devpriv->AdcItems << 2);
 
-		// If this slot's EndOfPollList flag is set, all channels have
-		// now been processed.
+		/*  If this slot's EndOfPollList flag is set, all channels have */
+		/*  now been processed. */
 		if (*ppl++ & EOPL) {
-			devpriv->AdcItems++;	// Adjust poll list item count.
-			break;	// Exit poll list processing loop.
+			devpriv->AdcItems++;	/*  Adjust poll list item count. */
+			break;	/*  Exit poll list processing loop. */
 		}
 	}
 	DEBUG("ResetADC: ADC items %d \n", devpriv->AdcItems);
 
-	// VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
-	// ADC to stabilize for 2 microseconds before starting the final
-	// (dummy) conversion.  This delay is necessary to allow sufficient
-	// time between last conversion finished and the start of the dummy
-	// conversion.  Without this delay, the last conversion's data value
-	// is sometimes set to the previous conversion's data value.
+	/* VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
+	 * ADC to stabilize for 2 microseconds before starting the final
+	 * (dummy) conversion.  This delay is necessary to allow sufficient
+	 * time between last conversion finished and the start of the dummy
+	 * conversion.  Without this delay, the last conversion's data value
+	 * is sometimes set to the previous conversion's data value.
+	 */
 	for (n = 0; n < (2 * RPSCLK_PER_US); n++)
 		*pRPS++ = RPS_NOP;
 
-	// Start a dummy conversion to cause the data from the last
-	// conversion of interest to be shifted in.
-	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	// Begin ADC Start pulse.
+	/* Start a dummy conversion to cause the data from the last
+	 * conversion of interest to be shifted in.
+	 */
+	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  Begin ADC Start pulse. */
 	*pRPS++ = GPIO_BASE | GPIO1_LO;
 	*pRPS++ = RPS_NOP;
-	// VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE.
-	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	// End ADC Start pulse.
+	/* VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
+	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  End ADC Start pulse. */
 	*pRPS++ = GPIO_BASE | GPIO1_HI;
 
-	// Wait for the data from the last conversion of interest to arrive
-	// in FB BUFFER 1 register.
-	*pRPS++ = RPS_PAUSE | RPS_GPIO2;	// Wait for ADC done.
+	/* Wait for the data from the last conversion of interest to arrive
+	 * in FB BUFFER 1 register.
+	 */
+	*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/*  Wait for ADC done. */
 
-	// Transfer final ADC data from FB BUFFER 1 register to DMA buffer.
-	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);	//
+	/*  Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
+	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);	/*  */
 	*pRPS++ =
 		(uint32_t) devpriv->ANABuf.PhysicalBase +
 		(devpriv->AdcItems << 2);
 
-	// Indicate ADC scan loop is finished.
-	// *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC ;  // Signal ReadADC() that scan is done.
+	/*  Indicate ADC scan loop is finished. */
+	/*  *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC ;  // Signal ReadADC() that scan is done. */
 
-	//invoke interrupt
+	/* invoke interrupt */
 	if (devpriv->ai_cmd_running == 1) {
 		DEBUG("ResetADC: insert irq in ADC RPS task\n");
 		*pRPS++ = RPS_IRQ;
 	}
-	// Restart RPS program at its beginning.
-	*pRPS++ = RPS_JUMP;	// Branch to start of RPS program.
+	/*  Restart RPS program at its beginning. */
+	*pRPS++ = RPS_JUMP;	/*  Branch to start of RPS program. */
 	*pRPS++ = (uint32_t) devpriv->RPSBuf.PhysicalBase;
 
-	// End of RPS program build
-	// ------------------------------------------------------------
+	/*  End of RPS program build */
 }
 
 /* TO COMPLETE, IF NECESSARY */
@@ -1502,19 +1513,19 @@ static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
 
 /*   DEBUG("as626_ai_rinsn: ai_rinsn enter \n");  */
 
-/*   // Trigger ADC scan loop start by setting RPS Signal 0. */
+/*   Trigger ADC scan loop start by setting RPS Signal 0. */
 /*   MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
 
-/*   // Wait until ADC scan loop is finished (RPS Signal 0 reset). */
+/*   Wait until ADC scan loop is finished (RPS Signal 0 reset). */
 /*   while ( MC_TEST( P_MC2, MC2_ADC_RPS ) ); */
 
-/*   // Init ptr to DMA buffer that holds new ADC data.  We skip the */
-/*   // first uint16_t in the buffer because it contains junk data from */
-/*   // the final ADC of the previous poll list scan. */
+/* Init ptr to DMA buffer that holds new ADC data.  We skip the
+ * first uint16_t in the buffer because it contains junk data from
+ * the final ADC of the previous poll list scan.
+ */
 /*   readaddr = (uint32_t *)devpriv->ANABuf.LogicalBase + 1; */
 
-/*   // Convert ADC data to 16-bit integer values and copy to application */
-/*   // buffer.	 */
+/*  Convert ADC data to 16-bit integer values and copy to application buffer. */
 /*   for ( i = 0; i < devpriv->AdcItems; i++ ) { */
 /*     *data = s626_ai_reg_to_uint( *readaddr++ ); */
 /*     DEBUG("s626_ai_rinsn: data %d \n",*data); */
@@ -1534,86 +1545,85 @@ static int s626_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
 	uint32_t GpioImage;
 	int n;
 
-/*   //interrupt call test  */
-/*   writel(IRQ_GPIO3,devpriv->base_addr+P_PSR); //Writing a logical 1 */
-/* 					     //into any of the RPS_PSR */
-/* 					     //bits causes the */
-/* 					     //corresponding interrupt */
-/* 					     //to be generated if */
-/* 					     //enabled */
+ /* interrupt call test  */
+/*   writel(IRQ_GPIO3,devpriv->base_addr+P_PSR); */
+	/* Writing a logical 1 into any of the RPS_PSR bits causes the
+	 * corresponding interrupt to be generated if enabled
+	 */
 
 	DEBUG("s626_ai_insn_read: entering\n");
 
-	// Convert application's ADC specification into form
-	// appropriate for register programming.
+	/* Convert application's ADC specification into form
+	 *  appropriate for register programming.
+	 */
 	if (range == 0)
 		AdcSpec = (chan << 8) | (GSEL_BIPOLAR5V);
 	else
 		AdcSpec = (chan << 8) | (GSEL_BIPOLAR10V);
 
-	// Switch ADC analog gain.
-	DEBIwrite(dev, LP_GSEL, AdcSpec);	// Set gain.
+	/*  Switch ADC analog gain. */
+	DEBIwrite(dev, LP_GSEL, AdcSpec);	/*  Set gain. */
 
-	// Select ADC analog input channel.
-	DEBIwrite(dev, LP_ISEL, AdcSpec);	// Select channel.
+	/*  Select ADC analog input channel. */
+	DEBIwrite(dev, LP_ISEL, AdcSpec);	/*  Select channel. */
 
 	for (n = 0; n < insn->n; n++) {
 
-		// Delay 10 microseconds for analog input settling.
+		/*  Delay 10 microseconds for analog input settling. */
 		comedi_udelay(10);
 
-		// Start ADC by pulsing GPIO1 low.
+		/*  Start ADC by pulsing GPIO1 low. */
 		GpioImage = RR7146(P_GPIO);
-		// Assert ADC Start command
+		/*  Assert ADC Start command */
 		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-		//   and stretch it out.
+		/*    and stretch it out. */
 		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
 		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-		// Negate ADC Start command.
+		/*  Negate ADC Start command. */
 		WR7146(P_GPIO, GpioImage | GPIO1_HI);
 
-		// Wait for ADC to complete (GPIO2 is asserted high when
-		// ADC not busy) and for data from previous conversion to
-		// shift into FB BUFFER 1 register.
+		/*  Wait for ADC to complete (GPIO2 is asserted high when */
+		/*  ADC not busy) and for data from previous conversion to */
+		/*  shift into FB BUFFER 1 register. */
 
-		// Wait for ADC done.
+		/*  Wait for ADC done. */
 		while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
 
-		// Fetch ADC data.
+		/*  Fetch ADC data. */
 		if (n != 0)
 			data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
 
-		// Allow the ADC to stabilize for 4 microseconds before
-		// starting the next (final) conversion.  This delay is
-		// necessary to allow sufficient time between last
-		// conversion finished and the start of the next
-		// conversion.  Without this delay, the last conversion's
-		// data value is sometimes set to the previous
-		// conversion's data value.
+		/* Allow the ADC to stabilize for 4 microseconds before
+		 * starting the next (final) conversion.  This delay is
+		 * necessary to allow sufficient time between last
+		 * conversion finished and the start of the next
+		 * conversion.  Without this delay, the last conversion's
+		 * data value is sometimes set to the previous
+		 * conversion's data value.
+		 */
 		comedi_udelay(4);
 	}
 
-	// Start a dummy conversion to cause the data from the
-	// previous conversion to be shifted in.
+	/* Start a dummy conversion to cause the data from the
+	 * previous conversion to be shifted in. */
 	GpioImage = RR7146(P_GPIO);
 
-	//Assert ADC Start command
+	/* Assert ADC Start command */
 	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-	//   and stretch it out.
+	/*    and stretch it out. */
 	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
 	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-	// Negate ADC Start command.
+	/*  Negate ADC Start command. */
 	WR7146(P_GPIO, GpioImage | GPIO1_HI);
 
-	// Wait for the data to arrive in FB BUFFER 1 register.
+	/*  Wait for the data to arrive in FB BUFFER 1 register. */
 
-	// Wait for ADC done.
+	/*  Wait for ADC done. */
 	while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
 
-	// Fetch ADC data from audio interface's input shift
-	// register.
+	/*  Fetch ADC data from audio interface's input shift register. */
 
-	// Fetch ADC data.
+	/*  Fetch ADC data. */
 	if (n != 0)
 		data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
 
@@ -1646,7 +1656,7 @@ static int s626_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
 
 	DEBUG("s626_ai_inttrig: trigger adc start...");
 
-	// Start executing the RPS program.
+	/*  Start executing the RPS program. */
 	MC_ENABLE(P_MC1, MC1_ERPS1);
 
 	s->async->inttrig = NULL;
@@ -1672,20 +1682,20 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 			dev->minor);
 		return -EBUSY;
 	}
-	//disable interrupt
+	/* disable interrupt */
 	writel(0, devpriv->base_addr + P_IER);
 
-	//clear interrupt request
+	/* clear interrupt request */
 	writel(IRQ_RPS1 | IRQ_GPIO3, devpriv->base_addr + P_ISR);
 
-	//clear any pending interrupt
+	/* clear any pending interrupt */
 	s626_dio_clear_irq(dev);
-	//  s626_enc_clear_irq(dev);
+	/*   s626_enc_clear_irq(dev); */
 
-	//reset ai_cmd_running flag
+	/* reset ai_cmd_running flag */
 	devpriv->ai_cmd_running = 0;
 
-	// test if cmd is valid
+	/*  test if cmd is valid */
 	if (cmd == NULL) {
 		DEBUG("s626_ai_cmd: NULL command\n");
 		return -EINVAL;
@@ -1707,12 +1717,12 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 	case TRIG_FOLLOW:
 		break;
 	case TRIG_TIMER:
-		// set a conter to generate adc trigger at scan_begin_arg interval
+		/*  set a conter to generate adc trigger at scan_begin_arg interval */
 		k = &encpriv[5];
 		tick = s626_ns_to_timer((int *)&cmd->scan_begin_arg,
 			cmd->flags & TRIG_ROUND_MASK);
 
-		//load timer value and enable interrupt
+		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
 		k->SetEnable(dev, k, CLKENAB_ALWAYS);
 
@@ -1721,7 +1731,7 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 
 		break;
 	case TRIG_EXT:
-		// set the digital line and interrupt for scan trigger
+		/*  set the digital line and interrupt for scan trigger */
 		if (cmd->start_src != TRIG_EXT)
 			s626_dio_set_irq(dev, cmd->scan_begin_arg);
 
@@ -1734,19 +1744,19 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 	case TRIG_NOW:
 		break;
 	case TRIG_TIMER:
-		// set a conter to generate adc trigger at convert_arg interval
+		/*  set a conter to generate adc trigger at convert_arg interval */
 		k = &encpriv[4];
 		tick = s626_ns_to_timer((int *)&cmd->convert_arg,
 			cmd->flags & TRIG_ROUND_MASK);
 
-		//load timer value and enable interrupt
+		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
 		k->SetEnable(dev, k, CLKENAB_INDEX);
 
 		DEBUG("s626_ai_cmd: convert trigger timer is set with value %d\n", tick);
 		break;
 	case TRIG_EXT:
-		// set the digital line and interrupt for convert trigger
+		/*  set the digital line and interrupt for convert trigger */
 		if (cmd->scan_begin_src != TRIG_EXT
 			&& cmd->start_src == TRIG_EXT)
 			s626_dio_set_irq(dev, cmd->convert_arg);
@@ -1758,12 +1768,12 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		// data arrives as one packet
+		/*  data arrives as one packet */
 		devpriv->ai_sample_count = cmd->stop_arg;
 		devpriv->ai_continous = 0;
 		break;
 	case TRIG_NONE:
-		// continous aquisition
+		/*  continous aquisition */
 		devpriv->ai_continous = 1;
 		devpriv->ai_sample_count = 0;
 		break;
@@ -1773,17 +1783,17 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 
 	switch (cmd->start_src) {
 	case TRIG_NOW:
-		// Trigger ADC scan loop start by setting RPS Signal 0.
-		// MC_ENABLE( P_MC2, MC2_ADC_RPS );
+		/*  Trigger ADC scan loop start by setting RPS Signal 0. */
+		/*  MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
 
-		// Start executing the RPS program.
+		/*  Start executing the RPS program. */
 		MC_ENABLE(P_MC1, MC1_ERPS1);
 
 		DEBUG("s626_ai_cmd: ADC triggered\n");
 		s->async->inttrig = NULL;
 		break;
 	case TRIG_EXT:
-		//configure DIO channel for acquisition trigger
+		/* configure DIO channel for acquisition trigger */
 		s626_dio_set_irq(dev, cmd->start_arg);
 
 		DEBUG("s626_ai_cmd: External start trigger is set!!!\n");
@@ -1795,7 +1805,7 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 		break;
 	}
 
-	//enable interrupt
+	/* enable interrupt */
 	writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->base_addr + P_IER);
 
 	DEBUG("s626_ai_cmd: command function terminated\n");
@@ -1990,10 +2000,10 @@ static int s626_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 
 static int s626_ai_cancel(comedi_device * dev, comedi_subdevice * s)
 {
-	// Stop RPS program in case it is currently running.
+	/*  Stop RPS program in case it is currently running. */
 	MC_DISABLE(P_MC1, MC1_ERPS1);
 
-	//disable master interrupt
+	/* disable master interrupt */
 	writel(0, devpriv->base_addr + P_IER);
 
 	devpriv->ai_cmd_running = 0;
@@ -2010,7 +2020,7 @@ static int s626_ns_to_timer(int *nanosec, int round_mode)
 {
 	int divider, base;
 
-	base = 500;		//2MHz internal clock
+	base = 500;		/* 2MHz internal clock */
 
 	switch (round_mode) {
 	case TRIG_ROUND_NEAREST:
@@ -2060,33 +2070,31 @@ static int s626_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return i;
 }
 
-/////////////////////////////////////////////////////////////////////
-///////////////  DIGITAL I/O FUNCTIONS  /////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// All DIO functions address a group of DIO channels by means of
-// "group" argument.  group may be 0, 1 or 2, which correspond to DIO
-// ports A, B and C, respectively.
-/////////////////////////////////////////////////////////////////////
+/* *************** DIGITAL I/O FUNCTIONS ***************
+ * All DIO functions address a group of DIO channels by means of
+ * "group" argument.  group may be 0, 1 or 2, which correspond to DIO
+ * ports A, B and C, respectively.
+ */
 
 static void s626_dio_init(comedi_device * dev)
 {
 	uint16_t group;
 	comedi_subdevice *s;
 
-	// Prepare to treat writes to WRCapSel as capture disables.
+	/*  Prepare to treat writes to WRCapSel as capture disables. */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
-	// For each group of sixteen channels ...
+	/*  For each group of sixteen channels ... */
 	for (group = 0; group < S626_DIO_BANKS; group++) {
 		s = dev->subdevices + 2 + group;
-		DEBIwrite(dev, diopriv->WRIntSel, 0);	// Disable all interrupts.
-		DEBIwrite(dev, diopriv->WRCapSel, 0xFFFF);	// Disable all event
-		// captures.
-		DEBIwrite(dev, diopriv->WREdgSel, 0);	// Init all DIOs to
-		// default edge
-		// polarity.
-		DEBIwrite(dev, diopriv->WRDOut, 0);	// Program all outputs
-		// to inactive state.
+		DEBIwrite(dev, diopriv->WRIntSel, 0);	/*  Disable all interrupts. */
+		DEBIwrite(dev, diopriv->WRCapSel, 0xFFFF);	/*  Disable all event */
+		/*  captures. */
+		DEBIwrite(dev, diopriv->WREdgSel, 0);	/*  Init all DIOs to */
+		/*  default edge */
+		/*  polarity. */
+		DEBIwrite(dev, diopriv->WRDOut, 0);	/*  Program all outputs */
+		/*  to inactive state. */
 	}
 	DEBUG("s626_dio_init: DIO initialized \n");
 }
@@ -2166,13 +2174,13 @@ static int s626_dio_set_irq(comedi_device * dev, unsigned int chan)
 	unsigned int bitmask;
 	unsigned int status;
 
-	//select dio bank
+	/* select dio bank */
 	group = chan / 16;
 	bitmask = 1 << (chan - (16 * group));
 	DEBUG("s626_dio_set_irq: enable interrupt on dio channel %d group %d\n",
 		chan - (16 * group), group);
 
-	//set channel to capture positive edge
+	/* set channel to capture positive edge */
 	status = DEBIread(dev,
 		((dio_private *) (dev->subdevices + 2 +
 				group)->private)->RDEdgSel);
@@ -2180,7 +2188,7 @@ static int s626_dio_set_irq(comedi_device * dev, unsigned int chan)
 		((dio_private *) (dev->subdevices + 2 +
 				group)->private)->WREdgSel, bitmask | status);
 
-	//enable interrupt on selected channel
+	/* enable interrupt on selected channel */
 	status = DEBIread(dev,
 		((dio_private *) (dev->subdevices + 2 +
 				group)->private)->RDIntSel);
@@ -2188,10 +2196,10 @@ static int s626_dio_set_irq(comedi_device * dev, unsigned int chan)
 		((dio_private *) (dev->subdevices + 2 +
 				group)->private)->WRIntSel, bitmask | status);
 
-	//enable edge capture write command
+	/* enable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_EDCAP);
 
-	//enable edge capture on selected channel
+	/* enable edge capture on selected channel */
 	status = DEBIread(dev,
 		((dio_private *) (dev->subdevices + 2 +
 				group)->private)->RDCapSel);
@@ -2207,10 +2215,10 @@ static int s626_dio_reset_irq(comedi_device * dev, unsigned int group,
 {
 	DEBUG("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n", mask, group);
 
-	//disable edge capture write command
+	/* disable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
-	//enable edge capture on selected channel
+	/* enable edge capture on selected channel */
 	DEBIwrite(dev,
 		((dio_private *) (dev->subdevices + 2 +
 				group)->private)->WRCapSel, mask);
@@ -2222,11 +2230,11 @@ static int s626_dio_clear_irq(comedi_device * dev)
 {
 	unsigned int group;
 
-	//disable edge capture write command
+	/* disable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
 	for (group = 0; group < S626_DIO_BANKS; group++) {
-		//clear pending events and interrupt
+		/* clear pending events and interrupt */
 		DEBIwrite(dev,
 			((dio_private *) (dev->subdevices + 2 +
 					group)->private)->WRCapSel, 0xffff);
@@ -2241,23 +2249,23 @@ static int s626_dio_clear_irq(comedi_device * dev)
 static int s626_enc_insn_config(comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, lsampl_t * data)
 {
-	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	// Preload upon
-		// index.
-		(INDXSRC_SOFT << BF_INDXSRC) |	// Disable hardware index.
-		(CLKSRC_COUNTER << BF_CLKSRC) |	// Operating mode is Counter.
-		(CLKPOL_POS << BF_CLKPOL) |	// Active high clock.
-		//( CNTDIR_UP << BF_CLKPOL ) |      // Count direction is Down.
-		(CLKMULT_1X << BF_CLKMULT) |	// Clock multiplier is 1x.
+	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
+		/*  index. */
+		(INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+		(CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is Counter. */
+		(CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+		/* ( CNTDIR_UP << BF_CLKPOL ) |      // Count direction is Down. */
+		(CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
 		(CLKENAB_INDEX << BF_CLKENAB);
 	/*   uint16_t DisableIntSrc=TRUE; */
-	// uint32_t Preloadvalue;              //Counter initial value
+	/*  uint32_t Preloadvalue;              //Counter initial value */
 	uint16_t valueSrclatch = LATCHSRC_AB_READ;
 	uint16_t enab = CLKENAB_ALWAYS;
 	enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
 	DEBUG("s626_enc_insn_config: encoder config\n");
 
-	//  (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]);
+	/*   (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
 	k->SetMode(dev, k, Setup, TRUE);
 	Preload(dev, k, *(insn->data));
@@ -2295,11 +2303,11 @@ static int s626_enc_insn_write(comedi_device * dev, comedi_subdevice * s,
 	DEBUG("s626_enc_insn_write: encoder write channel %d \n",
 		CR_CHAN(insn->chanspec));
 
-	// Set the preload register
+	/*  Set the preload register */
 	Preload(dev, k, data[0]);
 
-	// Software index pulse forces the preload register to load
-	// into the counter
+	/*  Software index pulse forces the preload register to load */
+	/*  into the counter */
 	k->SetLoadTrig(dev, k, 0);
 	k->PulseIndex(dev, k);
 	k->SetLoadTrig(dev, k, 2);
@@ -2311,50 +2319,47 @@ static int s626_enc_insn_write(comedi_device * dev, comedi_subdevice * s,
 
 static void s626_timer_load(comedi_device * dev, enc_private * k, int tick)
 {
-	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	// Preload upon
-		// index.
-		(INDXSRC_SOFT << BF_INDXSRC) |	// Disable hardware index.
-		(CLKSRC_TIMER << BF_CLKSRC) |	// Operating mode is Timer.
-		(CLKPOL_POS << BF_CLKPOL) |	// Active high clock.
-		(CNTDIR_DOWN << BF_CLKPOL) |	// Count direction is Down.
-		(CLKMULT_1X << BF_CLKMULT) |	// Clock multiplier is 1x.
+	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
+		/*  index. */
+		(INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+		(CLKSRC_TIMER << BF_CLKSRC) |	/*  Operating mode is Timer. */
+		(CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+		(CNTDIR_DOWN << BF_CLKPOL) |	/*  Count direction is Down. */
+		(CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
 		(CLKENAB_INDEX << BF_CLKENAB);
 	uint16_t valueSrclatch = LATCHSRC_A_INDXA;
-	//  uint16_t enab=CLKENAB_ALWAYS;
+	/*   uint16_t enab=CLKENAB_ALWAYS; */
 
 	k->SetMode(dev, k, Setup, FALSE);
 
-	// Set the preload register
+	/*  Set the preload register */
 	Preload(dev, k, tick);
 
-	// Software index pulse forces the preload register to load
-	// into the counter
+	/*  Software index pulse forces the preload register to load */
+	/*  into the counter */
 	k->SetLoadTrig(dev, k, 0);
 	k->PulseIndex(dev, k);
 
-	//set reload on counter overflow
+	/* set reload on counter overflow */
 	k->SetLoadTrig(dev, k, 1);
 
-	//set interrupt on overflow
+	/* set interrupt on overflow */
 	k->SetIntSrc(dev, k, INTSRC_OVER);
 
 	SetLatchSource(dev, k, valueSrclatch);
-	//  k->SetEnable(dev,k,(uint16_t)(enab != 0));
+	/*   k->SetEnable(dev,k,(uint16_t)(enab != 0)); */
 }
 
-///////////////////////////////////////////////////////////////////////
-/////////////////////  DAC FUNCTIONS /////////////////////////////////
-///////////////////////////////////////////////////////////////////////
+/* ***********  DAC FUNCTIONS *********** */
 
-// Slot 0 base settings.
-#define VECT0	( XSD2 | RSD3 | SIB_A2 )	// Slot 0 always shifts in
-					 // 0xFF and store it to
-					 // FB_BUFFER2.
+/*  Slot 0 base settings. */
+#define VECT0	( XSD2 | RSD3 | SIB_A2 )
+/*  Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
 
-// TrimDac LogicalChan-to-PhysicalChan mapping table.
+/*  TrimDac LogicalChan-to-PhysicalChan mapping table. */
 static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 
-// TrimDac LogicalChan-to-EepromAdrs mapping table.
+/*  TrimDac LogicalChan-to-EepromAdrs mapping table. */
 static uint8_t trimadrs[] =
 	{ 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
 
@@ -2362,7 +2367,7 @@ static void LoadTrimDACs(comedi_device * dev)
 {
 	register uint8_t i;
 
-	// Copy TrimDac setpoint values from EEPROM to TrimDacs.
+	/*  Copy TrimDac setpoint values from EEPROM to TrimDacs. */
 	for (i = 0; i < (sizeof(trimchan) / sizeof(trimchan[0])); i++)
 		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
 }
@@ -2372,112 +2377,105 @@ static void WriteTrimDAC(comedi_device * dev, uint8_t LogicalChan,
 {
 	uint32_t chan;
 
-	// Save the new setpoint in case the application needs to read it back later.
+	/*  Save the new setpoint in case the application needs to read it back later. */
 	devpriv->TrimSetpoint[LogicalChan] = (uint8_t) DacData;
 
-	// Map logical channel number to physical channel number.
+	/*  Map logical channel number to physical channel number. */
 	chan = (uint32_t) trimchan[LogicalChan];
 
-	// Set up TSL2 records for TrimDac write operation.  All slots shift
-	// 0xFF in from pulled-up SD3 so that the end of the slot sequence
-	// can be detected.
-	SETVECT(2, XSD2 | XFIFO_1 | WS3);	// Slot 2: Send high uint8_t
-	// to target TrimDac.
-	SETVECT(3, XSD2 | XFIFO_0 | WS3);	// Slot 3: Send low uint8_t to
-	// target TrimDac.
-	SETVECT(4, XSD2 | XFIFO_3 | WS1);	// Slot 4: Send NOP high
-	// uint8_t to DAC0 to keep
-	// clock running.
-	SETVECT(5, XSD2 | XFIFO_2 | WS1 | EOS);	// Slot 5: Send NOP low
-	// uint8_t to DAC0.
-
-	// Construct and transmit target DAC's serial packet: ( 0000 AAAA
-	// ),( DDDD DDDD ),( 0x00 ),( 0x00 ) where A<3:0> is the DAC
-	// channel's address, and D<7:0> is the DAC setpoint.  Append a WORD
-	// value (that writes a channel 0 NOP command to a non-existent main
-	// DAC channel) that serves to keep the clock running after the
-	// packet has been sent to the target DAC.
-
-	SendDAC(dev, ((uint32_t) chan << 8)	// Address the DAC channel
-		// within the trimdac device.
-		| (uint32_t) DacData);	// Include DAC setpoint data.
-}
+	/* Set up TSL2 records for TrimDac write operation.  All slots shift
+	 * 0xFF in from pulled-up SD3 so that the end of the slot sequence
+	 * can be detected.
+	 */
+
+	SETVECT(2, XSD2 | XFIFO_1 | WS3);
+	/* Slot 2: Send high uint8_t to target TrimDac. */
+	SETVECT(3, XSD2 | XFIFO_0 | WS3);
+	/* Slot 3: Send low uint8_t to target TrimDac. */
+	SETVECT(4, XSD2 | XFIFO_3 | WS1);
+	/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running. */
+	SETVECT(5, XSD2 | XFIFO_2 | WS1 | EOS);
+	/* Slot 5: Send NOP low  uint8_t to DAC0. */
+
+	/* Construct and transmit target DAC's serial packet:
+	 * ( 0000 AAAA ), ( DDDD DDDD ),( 0x00 ),( 0x00 ) where A<3:0> is the
+	 * DAC channel's address, and D<7:0> is the DAC setpoint.  Append a
+	 * WORD value (that writes a channel 0 NOP command to a non-existent
+	 * main DAC channel) that serves to keep the clock running after the
+	 * packet has been sent to the target DAC.
+	 */
 
-/////////////////////////////////////////////////////////////////////////
-////////////////  EEPROM ACCESS FUNCTIONS  //////////////////////////////
-/////////////////////////////////////////////////////////////////////////
+	/*  Address the DAC channel within the trimdac device. */
+	SendDAC(dev, ((uint32_t) chan << 8)
+		| (uint32_t) DacData);	/*  Include DAC setpoint data. */
+}
 
-///////////////////////////////////////////
-// Read uint8_t from EEPROM.
+/* **************  EEPROM ACCESS FUNCTIONS  ************** */
+/*  Read uint8_t from EEPROM. */
 
 static uint8_t I2Cread(comedi_device * dev, uint8_t addr)
 {
 	uint8_t rtnval;
 
-	// Send EEPROM target address.
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)	// Byte2 = I2C
-			// command:
-			// write to
-			// I2C EEPROM
-			// device.
-			| I2C_B1(I2C_ATTRSTOP, addr)	// Byte1 = EEPROM
-			// internal target
-			// address.
-			| I2C_B0(I2C_ATTRNOP, 0)))	// Byte0 = Not
-		// sent.
+	/*  Send EEPROM target address. */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)
+			 /* Byte2 = I2C command: write to I2C EEPROM  device. */
+			| I2C_B1(I2C_ATTRSTOP, addr)
+			 /* Byte1 = EEPROM internal target address. */
+			| I2C_B0(I2C_ATTRNOP, 0)))	/*  Byte0 = Not sent. */
 	{
-		// Abort function and declare error if handshake failed.
+		/*  Abort function and declare error if handshake failed. */
 		DEBUG("I2Cread: error handshake I2Cread  a\n");
 		return 0;
 	}
-	// Execute EEPROM read.
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)	// Byte2 = I2C
-			// command: read
-			// from I2C EEPROM
-			// device.
-			| I2C_B1(I2C_ATTRSTOP, 0)	// Byte1 receives
-			// uint8_t from
-			// EEPROM.
-			| I2C_B0(I2C_ATTRNOP, 0)))	// Byte0 = Not
-		// sent.
+	/*  Execute EEPROM read. */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)	/*  Byte2 = I2C */
+			/*  command: read */
+			/*  from I2C EEPROM */
+			/*  device. */
+			| I2C_B1(I2C_ATTRSTOP, 0)	/*  Byte1 receives */
+			/*  uint8_t from */
+			/*  EEPROM. */
+			| I2C_B0(I2C_ATTRNOP, 0)))	/*  Byte0 = Not */
+		/*  sent. */
 	{
-		// Abort function and declare error if handshake failed.
+		/*  Abort function and declare error if handshake failed. */
 		DEBUG("I2Cread: error handshake I2Cread b\n");
 		return 0;
 	}
-	// Return copy of EEPROM value.
+	/*  Return copy of EEPROM value. */
 	rtnval = (uint8_t) (RR7146(P_I2CCTRL) >> 16);
 	return rtnval;
 }
 
 static uint32_t I2Chandshake(comedi_device * dev, uint32_t val)
 {
-	// Write I2C command to I2C Transfer Control shadow register.
+	/*  Write I2C command to I2C Transfer Control shadow register. */
 	WR7146(P_I2CCTRL, val);
 
-	// Upload I2C shadow registers into working registers and wait for
-	// upload confirmation.
+	/*  Upload I2C shadow registers into working registers and wait for */
+	/*  upload confirmation. */
 
 	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
 	while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;
 
-	// Wait until I2C bus transfer is finished or an error occurs.
+	/*  Wait until I2C bus transfer is finished or an error occurs. */
 	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY) ;
 
-	// Return non-zero if I2C error occured.
+	/*  Return non-zero if I2C error occured. */
 	return RR7146(P_I2CCTRL) & I2C_ERR;
 
 }
 
-// Private helper function: Write setpoint to an application DAC channel.
+/*  Private helper function: Write setpoint to an application DAC channel. */
 
 static void SetDAC(comedi_device * dev, uint16_t chan, short dacdata)
 {
 	register uint16_t signmask;
 	register uint32_t WSImage;
 
-	// Adjust DAC data polarity and set up Polarity Control Register
-	// image.
+	/*  Adjust DAC data polarity and set up Polarity Control Register */
+	/*  image. */
 	signmask = 1 << chan;
 	if (dacdata < 0) {
 		dacdata = -dacdata;
@@ -2485,234 +2483,243 @@ static void SetDAC(comedi_device * dev, uint16_t chan, short dacdata)
 	} else
 		devpriv->Dacpol &= ~signmask;
 
-	// Limit DAC setpoint value to valid range.
+	/*  Limit DAC setpoint value to valid range. */
 	if ((uint16_t) dacdata > 0x1FFF)
 		dacdata = 0x1FFF;
 
-	// Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
-	// and V3 transmit the setpoint to the target DAC.  V4 and V5 send
-	// data to a non-existent TrimDac channel just to keep the clock
-	// running after sending data to the target DAC.  This is necessary
-	// to eliminate the clock glitch that would otherwise occur at the
-	// end of the target DAC's serial data stream.  When the sequence
-	// restarts at V0 (after executing V5), the gate array automatically
-	// disables gating for the DAC clock and all DAC chip selects.
-	WSImage = (chan & 2) ? WS1 : WS2;	// Choose DAC chip select to
-	// be asserted.
-	SETVECT(2, XSD2 | XFIFO_1 | WSImage);	// Slot 2: Transmit high
-	// data byte to target DAC.
-	SETVECT(3, XSD2 | XFIFO_0 | WSImage);	// Slot 3: Transmit low data
-	// byte to target DAC.
-	SETVECT(4, XSD2 | XFIFO_3 | WS3);	// Slot 4: Transmit to
-	// non-existent TrimDac
-	// channel to keep clock
-	SETVECT(5, XSD2 | XFIFO_2 | WS3 | EOS);	// Slot 5: running after
-	// writing target DAC's
-	// low data byte.
-
-	// Construct and transmit target DAC's serial packet: ( A10D DDDD
-	// ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan<0>, and D<12:0>
-	// is the DAC setpoint.  Append a WORD value (that writes to a
-	// non-existent TrimDac channel) that serves to keep the clock
-	// running after the packet has been sent to the target DAC.
-	SendDAC(dev, 0x0F000000	//Continue clock after target DAC
-		//data (write to non-existent
-		//trimdac).
-		| 0x00004000	// Address the two main dual-DAC
-		// devices (TSL's chip select enables
-		// target device).
-		| ((uint32_t) (chan & 1) << 15)	// Address the DAC
-		// channel within the
-		// device.
-		| (uint32_t) dacdata);	// Include DAC setpoint data.
+	/* Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
+	 * and V3 transmit the setpoint to the target DAC.  V4 and V5 send
+	 * data to a non-existent TrimDac channel just to keep the clock
+	 * running after sending data to the target DAC.  This is necessary
+	 * to eliminate the clock glitch that would otherwise occur at the
+	 * end of the target DAC's serial data stream.  When the sequence
+	 * restarts at V0 (after executing V5), the gate array automatically
+	 * disables gating for the DAC clock and all DAC chip selects.
+	 */
+
+	WSImage = (chan & 2) ? WS1 : WS2;
+	/* Choose DAC chip select to be asserted. */
+	SETVECT(2, XSD2 | XFIFO_1 | WSImage);
+	/* Slot 2: Transmit high data byte to target DAC. */
+	SETVECT(3, XSD2 | XFIFO_0 | WSImage);
+	/* Slot 3: Transmit low data byte to target DAC. */
+	SETVECT(4, XSD2 | XFIFO_3 | WS3);
+	/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */
+	SETVECT(5, XSD2 | XFIFO_2 | WS3 | EOS);
+	/* Slot 5: running after writing target DAC's low data byte. */
+
+	/*  Construct and transmit target DAC's serial packet:
+	 * ( A10D DDDD ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan<0>,
+	 * and D<12:0> is the DAC setpoint.  Append a WORD value (that writes
+	 * to a  non-existent TrimDac channel) that serves to keep the clock
+	 * running after the packet has been sent to the target DAC.
+	 */
+	SendDAC(dev, 0x0F000000
+		/* Continue clock after target DAC data (write to non-existent trimdac). */
+		| 0x00004000
+		/* Address the two main dual-DAC devices (TSL's chip select enables
+		 * target device). */
+		| ((uint32_t) (chan & 1) << 15)
+		/*  Address the DAC channel within the  device. */
+		| (uint32_t) dacdata);	/*  Include DAC setpoint data. */
 
 }
 
-////////////////////////////////////////////////////////
-// Private helper function: Transmit serial data to DAC via Audio
-// channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
-// Dacpol contains valid target image.
+/* Private helper function: Transmit serial data to DAC via Audio
+ * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
+ * Dacpol contains valid target image.
+ */
 
 static void SendDAC(comedi_device * dev, uint32_t val)
 {
 
-	// START THE SERIAL CLOCK RUNNING -------------
+	/* START THE SERIAL CLOCK RUNNING ------------- */
 
-	// Assert DAC polarity control and enable gating of DAC serial clock
-	// and audio bit stream signals.  At this point in time we must be
-	// assured of being in time slot 0.  If we are not in slot 0, the
-	// serial clock and audio stream signals will be disabled; this is
-	// because the following DEBIwrite statement (which enables signals
-	// to be passed through the gate array) would execute before the
-	// trailing edge of WS1/WS3 (which turns off the signals), thus
-	// causing the signals to be inactive during the DAC write.
+	/* Assert DAC polarity control and enable gating of DAC serial clock
+	 * and audio bit stream signals.  At this point in time we must be
+	 * assured of being in time slot 0.  If we are not in slot 0, the
+	 * serial clock and audio stream signals will be disabled; this is
+	 * because the following DEBIwrite statement (which enables signals
+	 * to be passed through the gate array) would execute before the
+	 * trailing edge of WS1/WS3 (which turns off the signals), thus
+	 * causing the signals to be inactive during the DAC write.
+	 */
 	DEBIwrite(dev, LP_DACPOL, devpriv->Dacpol);
 
-	// TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ----------------
+	/* TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- */
 
-	// Copy DAC setpoint value to DAC's output DMA buffer.
+	/* Copy DAC setpoint value to DAC's output DMA buffer. */
 
-	//WR7146( (uint32_t)devpriv->pDacWBuf, val );
+	/* WR7146( (uint32_t)devpriv->pDacWBuf, val ); */
 	*devpriv->pDacWBuf = val;
 
-	// enab the output DMA transfer.  This will cause the DMAC to copy
-	// the DAC's data value to A2's output FIFO.  The DMA transfer will
-	// then immediately terminate because the protection address is
-	// reached upon transfer of the first DWORD value.
+	/* enab the output DMA transfer.  This will cause the DMAC to copy
+	 * the DAC's data value to A2's output FIFO.  The DMA transfer will
+	 * then immediately terminate because the protection address is
+	 * reached upon transfer of the first DWORD value.
+	 */
 	MC_ENABLE(P_MC1, MC1_A2OUT);
 
-	// While the DMA transfer is executing ...
+	/*  While the DMA transfer is executing ... */
 
-	// Reset Audio2 output FIFO's underflow flag (along with any other
-	// FIFO underflow/overflow flags).  When set, this flag will
-	// indicate that we have emerged from slot 0.
+	/* Reset Audio2 output FIFO's underflow flag (along with any other
+	 * FIFO underflow/overflow flags).  When set, this flag will
+	 * indicate that we have emerged from slot 0.
+	 */
 	WR7146(P_ISR, ISR_AFOU);
 
-	// Wait for the DMA transfer to finish so that there will be data
-	// available in the FIFO when time slot 1 tries to transfer a DWORD
-	// from the FIFO to the output buffer register.  We test for DMA
-	// Done by polling the DMAC enable flag; this flag is automatically
-	// cleared when the transfer has finished.
+	/* Wait for the DMA transfer to finish so that there will be data
+	 * available in the FIFO when time slot 1 tries to transfer a DWORD
+	 * from the FIFO to the output buffer register.  We test for DMA
+	 * Done by polling the DMAC enable flag; this flag is automatically
+	 * cleared when the transfer has finished.
+	 */
 	while ((RR7146(P_MC1) & MC1_A2OUT) != 0) ;
 
-	// START THE OUTPUT STREAM TO THE TARGET DAC --------------------
+	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
 
-	// FIFO data is now available, so we enable execution of time slots
-	// 1 and higher by clearing the EOS flag in slot 0.  Note that SD3
-	// will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
-	// detection.
+	/* FIFO data is now available, so we enable execution of time slots
+	 * 1 and higher by clearing the EOS flag in slot 0.  Note that SD3
+	 * will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
+	 * detection.
+	 */
 	SETVECT(0, XSD2 | RSD3 | SIB_A2);
 
-	// Wait for slot 1 to execute to ensure that the Packet will be
-	// transmitted.  This is detected by polling the Audio2 output FIFO
-	// underflow flag, which will be set when slot 1 execution has
-	// finished transferring the DAC's data DWORD from the output FIFO
-	// to the output buffer register.
+	/* Wait for slot 1 to execute to ensure that the Packet will be
+	 * transmitted.  This is detected by polling the Audio2 output FIFO
+	 * underflow flag, which will be set when slot 1 execution has
+	 * finished transferring the DAC's data DWORD from the output FIFO
+	 * to the output buffer register.
+	 */
 	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0) ;
 
-	// Set up to trap execution at slot 0 when the TSL sequencer cycles
-	// back to slot 0 after executing the EOS in slot 5.  Also,
-	// simultaneously shift out and in the 0x00 that is ALWAYS the value
-	// stored in the last byte to be shifted out of the FIFO's DWORD
-	// buffer register.
+	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
+	 * back to slot 0 after executing the EOS in slot 5.  Also,
+	 * simultaneously shift out and in the 0x00 that is ALWAYS the value
+	 * stored in the last byte to be shifted out of the FIFO's DWORD
+	 * buffer register.
+	 */
 	SETVECT(0, XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS);
 
-	// WAIT FOR THE TRANSACTION TO FINISH -----------------------
-
-	// Wait for the TSL to finish executing all time slots before
-	// exiting this function.  We must do this so that the next DAC
-	// write doesn't start, thereby enabling clock/chip select signals:
-	// 1. Before the TSL sequence cycles back to slot 0, which disables
-	// the clock/cs signal gating and traps slot // list execution.  If
-	// we have not yet finished slot 5 then the clock/cs signals are
-	// still gated and we have // not finished transmitting the stream.
-	// 2. While slots 2-5 are executing due to a late slot 0 trap.  In
-	// this case, the slot sequence is currently // repeating, but with
-	// clock/cs signals disabled.  We must wait for slot 0 to trap
-	// execution before setting // up the next DAC setpoint DMA transfer
-	// and enabling the clock/cs signals.  To detect the end of slot 5,
-	// we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
-	// the TSL has not yet finished executing slot 5 ...
+	/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */
+
+	/* Wait for the TSL to finish executing all time slots before
+	 * exiting this function.  We must do this so that the next DAC
+	 * write doesn't start, thereby enabling clock/chip select signals:
+	 *
+	 * 1. Before the TSL sequence cycles back to slot 0, which disables
+	 *    the clock/cs signal gating and traps slot // list execution.
+	 *    we have not yet finished slot 5 then the clock/cs signals are
+	 *    still gated and we have not finished transmitting the stream.
+	 *
+	 * 2. While slots 2-5 are executing due to a late slot 0 trap.  In
+	 *    this case, the slot sequence is currently repeating, but with
+	 *    clock/cs signals disabled.  We must wait for slot 0 to trap
+	 *    execution before setting up the next DAC setpoint DMA transfer
+	 *    and enabling the clock/cs signals.  To detect the end of slot 5,
+	 *    we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
+	 *    the TSL has not yet finished executing slot 5 ...
+	 */
 	if ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) {
-		// The trap was set on time and we are still executing somewhere
-		// in slots 2-5, so we now wait for slot 0 to execute and trap
-		// TSL execution.  This is detected when FB_BUFFER2 MSB changes
-		// from 0xFF to 0x00, which slot 0 causes to happen by shifting
-		// out/in on SD2 the 0x00 that is always referenced by slot 5.
-		while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) ;
+		/* The trap was set on time and we are still executing somewhere
+		 * in slots 2-5, so we now wait for slot 0 to execute and trap
+		 * TSL execution.  This is detected when FB_BUFFER2 MSB changes
+		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
+		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
+		 */
+		 while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) ;
 	}
-	// Either (1) we were too late setting the slot 0 trap; the TSL
-	// sequencer restarted slot 0 before we could set the EOS trap flag,
-	// or (2) we were not late and execution is now trapped at slot 0.
-	// In either case, we must now change slot 0 so that it will store
-	// value 0xFF (instead of 0x00) to FB_BUFFER2 next time it executes.
-	// In order to do this, we reprogram slot 0 so that it will shift in
-	// SD3, which is driven only by a pull-up resistor.
+	/* Either (1) we were too late setting the slot 0 trap; the TSL
+	 * sequencer restarted slot 0 before we could set the EOS trap flag,
+	 * or (2) we were not late and execution is now trapped at slot 0.
+	 * In either case, we must now change slot 0 so that it will store
+	 * value 0xFF (instead of 0x00) to FB_BUFFER2 next time it executes.
+	 * In order to do this, we reprogram slot 0 so that it will shift in
+	 * SD3, which is driven only by a pull-up resistor.
+	 */
 	SETVECT(0, RSD3 | SIB_A2 | EOS);
 
-	// Wait for slot 0 to execute, at which time the TSL is setup for
-	// the next DAC write.  This is detected when FB_BUFFER2 MSB changes
-	// from 0x00 to 0xFF.
+	/* Wait for slot 0 to execute, at which time the TSL is setup for
+	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
+	 * from 0x00 to 0xFF.
+	 */
 	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0) ;
 }
 
 static void WriteMISC2(comedi_device * dev, uint16_t NewImage)
 {
-	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	// enab writes to
-	// MISC2 register.
-	DEBIwrite(dev, LP_WRMISC2, NewImage);	// Write new image to MISC2.
-	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE);	// Disable writes to MISC2.
+	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	/*  enab writes to */
+	/*  MISC2 register. */
+	DEBIwrite(dev, LP_WRMISC2, NewImage);	/*  Write new image to MISC2. */
+	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE);	/*  Disable writes to MISC2. */
 }
 
-/////////////////////////////////////////////////////////////////////
-// Initialize the DEBI interface for all transfers.
+/*  Initialize the DEBI interface for all transfers. */
 
 static uint16_t DEBIread(comedi_device * dev, uint16_t addr)
 {
 	uint16_t retval;
 
-	// Set up DEBI control register value in shadow RAM.
+	/*  Set up DEBI control register value in shadow RAM. */
 	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
 
-	// Execute the DEBI transfer.
+	/*  Execute the DEBI transfer. */
 	DEBItransfer(dev);
 
-	// Fetch target register value.
+	/*  Fetch target register value. */
 	retval = (uint16_t) RR7146(P_DEBIAD);
 
-	// Return register value.
+	/*  Return register value. */
 	return retval;
 }
 
-// Execute a DEBI transfer.  This must be called from within a
-// critical section.
+/*  Execute a DEBI transfer.  This must be called from within a */
+/*  critical section. */
 static void DEBItransfer(comedi_device * dev)
 {
-	// Initiate upload of shadow RAM to DEBI control register.
+	/*  Initiate upload of shadow RAM to DEBI control register. */
 	MC_ENABLE(P_MC2, MC2_UPLD_DEBI);
 
-	// Wait for completion of upload from shadow RAM to DEBI control
-	// register.
+	/*  Wait for completion of upload from shadow RAM to DEBI control */
+	/*  register. */
 	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI)) ;
 
-	// Wait until DEBI transfer is done.
+	/*  Wait until DEBI transfer is done. */
 	while (RR7146(P_PSR) & PSR_DEBI_S) ;
 }
 
-// Write a value to a gate array register.
+/*  Write a value to a gate array register. */
 static void DEBIwrite(comedi_device * dev, uint16_t addr, uint16_t wdata)
 {
 
-	// Set up DEBI control register value in shadow RAM.
+	/*  Set up DEBI control register value in shadow RAM. */
 	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
 	WR7146(P_DEBIAD, wdata);
 
-	// Execute the DEBI transfer.
+	/*  Execute the DEBI transfer. */
 	DEBItransfer(dev);
 }
 
-/////////////////////////////////////////////////////////////////////////////
-// Replace the specified bits in a gate array register.  Imports: mask
-// specifies bits that are to be preserved, wdata is new value to be
-// or'd with the masked original.
+/* Replace the specified bits in a gate array register.  Imports: mask
+ * specifies bits that are to be preserved, wdata is new value to be
+ * or'd with the masked original.
+ */
 static void DEBIreplace(comedi_device * dev, uint16_t addr, uint16_t mask,
 	uint16_t wdata)
 {
 
-	// Copy target gate array register into P_DEBIAD register.
-	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);	// Set up DEBI control
-	// reg value in shadow
-	// RAM.
-	DEBItransfer(dev);	// Execute the DEBI
-	// Read transfer.
+	/*  Copy target gate array register into P_DEBIAD register. */
+	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
+	/* Set up DEBI control reg value in shadow RAM. */
+	DEBItransfer(dev);	/*  Execute the DEBI Read transfer. */
 
-	// Write back the modified image.
-	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);	// Set up DEBI control
-	// reg value in shadow
-	// RAM.
+	/*  Write back the modified image. */
+	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
+	/* Set up DEBI control reg value in shadow  RAM. */
 
-	WR7146(P_DEBIAD, wdata | ((uint16_t) RR7146(P_DEBIAD) & mask));	// Modify the register image.
-	DEBItransfer(dev);	// Execute the DEBI Write transfer.
+	WR7146(P_DEBIAD, wdata | ((uint16_t) RR7146(P_DEBIAD) & mask));
+	/* Modify the register image. */
+	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
 }
 
 static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize)
@@ -2723,7 +2730,7 @@ static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize)
 	DEBUG("CloseDMAB: Entering S626DRV_CloseDMAB():\n");
 	if (pdma == NULL)
 		return;
-	//find the matching allocation from the board struct
+	/* find the matching allocation from the board struct */
 
 	vbptr = pdma->LogicalBase;
 	vpptr = pdma->PhysicalBase;
@@ -2737,44 +2744,37 @@ static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize)
 	}
 }
 
-////////////////////////////////////////////////////////////////////////
-/////////////////  COUNTER FUNCTIONS  //////////////////////////////////
-////////////////////////////////////////////////////////////////////////
-// All counter functions address a specific counter by means of the
-// "Counter" argument, which is a logical counter number.  The Counter
-// argument may have any of the following legal values: 0=0A, 1=1A,
-// 2=2A, 3=0B, 4=1B, 5=2B.
-////////////////////////////////////////////////////////////////////////
+/* ******  COUNTER FUNCTIONS  ******* */
+/* All counter functions address a specific counter by means of the
+ * "Counter" argument, which is a logical counter number.  The Counter
+ * argument may have any of the following legal values: 0=0A, 1=1A,
+ * 2=2A, 3=0B, 4=1B, 5=2B.
+ */
 
-// Forward declarations for functions that are common to both A and B
-// counters:
+/* Forward declarations for functions that are common to both A and B counters: */
 
-/////////////////////////////////////////////////////////////////////
-//////////////////// PRIVATE COUNTER FUNCTIONS  /////////////////////
-/////////////////////////////////////////////////////////////////////
+/* ******  PRIVATE COUNTER FUNCTIONS ****** */
 
-/////////////////////////////////////////////////////////////////
-// Read a counter's output latch.
+/*  Read a counter's output latch. */
 
 static uint32_t ReadLatch(comedi_device * dev, enc_private * k)
 {
 	register uint32_t value;
-	//DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n");
+	/* DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n"); */
 
-	// Latch counts and fetch LSW of latched counts value.
+	/*  Latch counts and fetch LSW of latched counts value. */
 	value = (uint32_t) DEBIread(dev, k->MyLatchLsw);
 
-	// Fetch MSW of latched counts and combine with LSW.
+	/*  Fetch MSW of latched counts and combine with LSW. */
 	value |= ((uint32_t) DEBIread(dev, k->MyLatchLsw + 2) << 16);
 
-	// DEBUG FIXME DEBUG("ReadLatch: Read Latch exit\n");
+	/*  DEBUG FIXME DEBUG("ReadLatch: Read Latch exit\n"); */
 
-	// Return latched counts.
+	/*  Return latched counts. */
 	return value;
 }
 
-///////////////////////////////////////////////////////////////////
-// Reset a counter's index and overflow event capture flags.
+/*  Reset a counter's index and overflow event capture flags. */
 
 static void ResetCapFlags_A(comedi_device * dev, enc_private * k)
 {
@@ -2788,9 +2788,8 @@ static void ResetCapFlags_B(comedi_device * dev, enc_private * k)
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
 }
 
-/////////////////////////////////////////////////////////////////////////
-// Return counter setup in a format (COUNTER_SETUP) that is consistent
-// for both A and B counters.
+/*  Return counter setup in a format (COUNTER_SETUP) that is consistent */
+/*  for both A and B counters. */
 
 static uint16_t GetMode_A(comedi_device * dev, enc_private * k)
 {
@@ -2798,35 +2797,35 @@ static uint16_t GetMode_A(comedi_device * dev, enc_private * k)
 	register uint16_t crb;
 	register uint16_t setup;
 
-	// Fetch CRA and CRB register images.
+	/*  Fetch CRA and CRB register images. */
 	cra = DEBIread(dev, k->MyCRA);
 	crb = DEBIread(dev, k->MyCRB);
 
-	// Populate the standardized counter setup bit fields.  Note:
-	// IndexSrc is restricted to ENC_X or IndxPol.
-	setup = ((cra & STDMSK_LOADSRC)	// LoadSrc  = LoadSrcA.
-		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	// LatchSrc = LatchSrcA.
-		| ((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) & STDMSK_INTSRC)	// IntSrc   = IntSrcA.
-		| ((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) & STDMSK_INDXSRC)	// IndxSrc  = IndxSrcA<1>.
-		| ((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) & STDMSK_INDXPOL)	// IndxPol  = IndxPolA.
-		| ((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) & STDMSK_CLKENAB));	// ClkEnab  = ClkEnabA.
-
-	// Adjust mode-dependent parameters.
-	if (cra & (2 << CRABIT_CLKSRC_A))	// If Timer mode (ClkSrcA<1> == 1):
-		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	//   Indicate Timer mode.
-			| ((cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) & STDMSK_CLKPOL)	//   Set ClkPol to indicate count direction (ClkSrcA<0>).
-			| (MULT_X1 << STDBIT_CLKMULT));	//   ClkMult must be 1x in Timer mode.
-
-	else			// If Counter mode (ClkSrcA<1> == 0):
-		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	//   Indicate Counter mode.
-			| ((cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) & STDMSK_CLKPOL)	//   Pass through ClkPol.
-			| (((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A)) ?	//   Force ClkMult to 1x if not legal, else pass through.
+	/*  Populate the standardized counter setup bit fields.  Note: */
+	/*  IndexSrc is restricted to ENC_X or IndxPol. */
+	setup = ((cra & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcA. */
+		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcA. */
+		| ((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcA. */
+		| ((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) & STDMSK_INDXSRC)	/*  IndxSrc  = IndxSrcA<1>. */
+		| ((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolA. */
+		| ((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) & STDMSK_CLKENAB));	/*  ClkEnab  = ClkEnabA. */
+
+	/*  Adjust mode-dependent parameters. */
+	if (cra & (2 << CRABIT_CLKSRC_A))	/*  If Timer mode (ClkSrcA<1> == 1): */
+		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
+			| ((cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) & STDMSK_CLKPOL)	/*    Set ClkPol to indicate count direction (ClkSrcA<0>). */
+			| (MULT_X1 << STDBIT_CLKMULT));	/*    ClkMult must be 1x in Timer mode. */
+
+	else			/*  If Counter mode (ClkSrcA<1> == 0): */
+		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Counter mode. */
+			| ((cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) & STDMSK_CLKPOL)	/*    Pass through ClkPol. */
+			| (((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A)) ?	/*    Force ClkMult to 1x if not legal, else pass through. */
 				(MULT_X1 << STDBIT_CLKMULT) :
 				((cra >> (CRABIT_CLKMULT_A -
 							STDBIT_CLKMULT)) &
 					STDMSK_CLKMULT)));
 
-	// Return adjusted counter setup.
+	/*  Return adjusted counter setup. */
 	return setup;
 }
 
@@ -2836,98 +2835,99 @@ static uint16_t GetMode_B(comedi_device * dev, enc_private * k)
 	register uint16_t crb;
 	register uint16_t setup;
 
-	// Fetch CRA and CRB register images.
+	/*  Fetch CRA and CRB register images. */
 	cra = DEBIread(dev, k->MyCRA);
 	crb = DEBIread(dev, k->MyCRB);
 
-	// Populate the standardized counter setup bit fields.  Note:
-	// IndexSrc is restricted to ENC_X or IndxPol.
-	setup = (((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) & STDMSK_INTSRC)	// IntSrc   = IntSrcB.
-		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	// LatchSrc = LatchSrcB.
-		| ((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) & STDMSK_LOADSRC)	// LoadSrc  = LoadSrcB.
-		| ((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) & STDMSK_INDXPOL)	// IndxPol  = IndxPolB.
-		| ((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) & STDMSK_CLKENAB)	// ClkEnab  = ClkEnabB.
-		| ((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) & STDMSK_INDXSRC));	// IndxSrc  = IndxSrcB<1>.
-
-	// Adjust mode-dependent parameters.
-	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B))	// If Extender mode (ClkMultB == MULT_X0):
-		setup |= ((CLKSRC_EXTENDER << STDBIT_CLKSRC)	//   Indicate Extender mode.
-			| (MULT_X1 << STDBIT_CLKMULT)	//   Indicate multiplier is 1x.
-			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	//   Set ClkPol equal to Timer count direction (ClkSrcB<0>).
-
-	else if (cra & (2 << CRABIT_CLKSRC_B))	// If Timer mode (ClkSrcB<1> == 1):
-		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	//   Indicate Timer mode.
-			| (MULT_X1 << STDBIT_CLKMULT)	//   Indicate multiplier is 1x.
-			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	//   Set ClkPol equal to Timer count direction (ClkSrcB<0>).
-
-	else			// If Counter mode (ClkSrcB<1> == 0):
-		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	//   Indicate Timer mode.
-			| ((crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) & STDMSK_CLKMULT)	//   Clock multiplier is passed through.
-			| ((crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) & STDMSK_CLKPOL));	//   Clock polarity is passed through.
-
-	// Return adjusted counter setup.
+	/*  Populate the standardized counter setup bit fields.  Note: */
+	/*  IndexSrc is restricted to ENC_X or IndxPol. */
+	setup = (((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcB. */
+		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcB. */
+		| ((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcB. */
+		| ((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolB. */
+		| ((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) & STDMSK_CLKENAB)	/*  ClkEnab  = ClkEnabB. */
+		| ((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) & STDMSK_INDXSRC));	/*  IndxSrc  = IndxSrcB<1>. */
+
+	/*  Adjust mode-dependent parameters. */
+	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B))	/*  If Extender mode (ClkMultB == MULT_X0): */
+		setup |= ((CLKSRC_EXTENDER << STDBIT_CLKSRC)	/*    Indicate Extender mode. */
+			| (MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
+			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+
+	else if (cra & (2 << CRABIT_CLKSRC_B))	/*  If Timer mode (ClkSrcB<1> == 1): */
+		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
+			| (MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
+			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+
+	else			/*  If Counter mode (ClkSrcB<1> == 0): */
+		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
+			| ((crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) & STDMSK_CLKMULT)	/*    Clock multiplier is passed through. */
+			| ((crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) & STDMSK_CLKPOL));	/*    Clock polarity is passed through. */
+
+	/*  Return adjusted counter setup. */
 	return setup;
 }
 
-/////////////////////////////////////////////////////////////////////////////////////////////
-// Set the operating mode for the specified counter.  The setup
-// parameter is treated as a COUNTER_SETUP data type.  The following
-// parameters are programmable (all other parms are ignored): ClkMult,
-// ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
+/*
+ * Set the operating mode for the specified counter.  The setup
+ * parameter is treated as a COUNTER_SETUP data type.  The following
+ * parameters are programmable (all other parms are ignored): ClkMult,
+ * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
+ */
 
 static void SetMode_A(comedi_device * dev, enc_private * k, uint16_t Setup,
 	uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
 	register uint16_t crb;
-	register uint16_t setup = Setup;	// Cache the Standard Setup.
+	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
 
-	// Initialize CRA and CRB images.
-	cra = ((setup & CRAMSK_LOADSRC_A)	// Preload trigger is passed through.
-		| ((setup & STDMSK_INDXSRC) >> (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	// IndexSrc is restricted to ENC_X or IndxPol.
+	/*  Initialize CRA and CRB images. */
+	cra = ((setup & CRAMSK_LOADSRC_A)	/*  Preload trigger is passed through. */
+		| ((setup & STDMSK_INDXSRC) >> (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	/*  IndexSrc is restricted to ENC_X or IndxPol. */
 
-	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A	// Reset any pending CounterA event captures.
-		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	// Clock enable is passed through.
+	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A	/*  Reset any pending CounterA event captures. */
+		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	/*  Clock enable is passed through. */
 
-	// Force IntSrc to Disabled if DisableIntSrc is asserted.
+	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
 	if (!DisableIntSrc)
 		cra |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
 				CRABIT_INTSRC_A));
 
-	// Populate all mode-dependent attributes of CRA & CRB images.
+	/*  Populate all mode-dependent attributes of CRA & CRB images. */
 	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
-	case CLKSRC_EXTENDER:	// Extender Mode: Force to Timer mode
-		// (Extender valid only for B counters).
-
-	case CLKSRC_TIMER:	// Timer Mode:
-		cra |= ((2 << CRABIT_CLKSRC_A)	//   ClkSrcA<1> selects system clock
-			| ((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	//     with count direction (ClkSrcA<0>) obtained from ClkPol.
-			| (1 << CRABIT_CLKPOL_A)	//   ClkPolA behaves as always-on clock enable.
-			| (MULT_X1 << CRABIT_CLKMULT_A));	//   ClkMult must be 1x.
+	case CLKSRC_EXTENDER:	/*  Extender Mode: Force to Timer mode */
+		/*  (Extender valid only for B counters). */
+
+	case CLKSRC_TIMER:	/*  Timer Mode: */
+		cra |= ((2 << CRABIT_CLKSRC_A)	/*    ClkSrcA<1> selects system clock */
+			| ((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	/*      with count direction (ClkSrcA<0>) obtained from ClkPol. */
+			| (1 << CRABIT_CLKPOL_A)	/*    ClkPolA behaves as always-on clock enable. */
+			| (MULT_X1 << CRABIT_CLKMULT_A));	/*    ClkMult must be 1x. */
 		break;
 
-	default:		// Counter Mode:
-		cra |= (CLKSRC_COUNTER	//   Select ENC_C and ENC_D as clock/direction inputs.
-			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKPOL_A - STDBIT_CLKPOL))	//   Clock polarity is passed through.
-			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	//   Force multiplier to x1 if not legal, otherwise pass through.
+	default:		/*  Counter Mode: */
+		cra |= (CLKSRC_COUNTER	/*    Select ENC_C and ENC_D as clock/direction inputs. */
+			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKPOL_A - STDBIT_CLKPOL))	/*    Clock polarity is passed through. */
+			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force multiplier to x1 if not legal, otherwise pass through. */
 				(MULT_X1 << CRABIT_CLKMULT_A) :
 				((setup & STDMSK_CLKMULT) << (CRABIT_CLKMULT_A -
 						STDBIT_CLKMULT))));
 	}
 
-	// Force positive index polarity if IndxSrc is software-driven only,
-	// otherwise pass it through.
+	/*  Force positive index polarity if IndxSrc is software-driven only, */
+	/*  otherwise pass it through. */
 	if (~setup & STDMSK_INDXSRC)
 		cra |= ((setup & STDMSK_INDXPOL) << (CRABIT_INDXPOL_A -
 				STDBIT_INDXPOL));
 
-	// If IntSrc has been forced to Disabled, update the MISC2 interrupt
-	// enable mask to indicate the counter interrupt is disabled.
+	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
+	/*  enable mask to indicate the counter interrupt is disabled. */
 	if (DisableIntSrc)
 		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
 
-	// While retaining CounterB and LatchSrc configurations, program the
-	// new counter operating mode.
+	/*  While retaining CounterB and LatchSrc configurations, program the */
+	/*  new counter operating mode. */
 	DEBIreplace(dev, k->MyCRA, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
 	DEBIreplace(dev, k->MyCRB,
 		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
@@ -2938,65 +2938,64 @@ static void SetMode_B(comedi_device * dev, enc_private * k, uint16_t Setup,
 {
 	register uint16_t cra;
 	register uint16_t crb;
-	register uint16_t setup = Setup;	// Cache the Standard Setup.
+	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
 
-	// Initialize CRA and CRB images.
-	cra = ((setup & STDMSK_INDXSRC) << ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC));	// IndexSrc field is restricted to ENC_X or IndxPol.
+	/*  Initialize CRA and CRB images. */
+	cra = ((setup & STDMSK_INDXSRC) << ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC));	/*  IndexSrc field is restricted to ENC_X or IndxPol. */
 
-	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B	// Reset event captures and disable interrupts.
-		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	// Clock enable is passed through.
-		| ((setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	// Preload trigger source is passed through.
+	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B	/*  Reset event captures and disable interrupts. */
+		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	/*  Clock enable is passed through. */
+		| ((setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	/*  Preload trigger source is passed through. */
 
-	// Force IntSrc to Disabled if DisableIntSrc is asserted.
+	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
 	if (!DisableIntSrc)
 		crb |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
 				CRBBIT_INTSRC_B));
 
-	// Populate all mode-dependent attributes of CRA & CRB images.
+	/*  Populate all mode-dependent attributes of CRA & CRB images. */
 	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
-	case CLKSRC_TIMER:	// Timer Mode:
-		cra |= ((2 << CRABIT_CLKSRC_B)	//   ClkSrcB<1> selects system clock
-			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	//     with direction (ClkSrcB<0>) obtained from ClkPol.
-		crb |= ((1 << CRBBIT_CLKPOL_B)	//   ClkPolB behaves as always-on clock enable.
-			| (MULT_X1 << CRBBIT_CLKMULT_B));	//   ClkMultB must be 1x.
+	case CLKSRC_TIMER:	/*  Timer Mode: */
+		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB<1> selects system clock */
+			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction (ClkSrcB<0>) obtained from ClkPol. */
+		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB behaves as always-on clock enable. */
+			| (MULT_X1 << CRBBIT_CLKMULT_B));	/*    ClkMultB must be 1x. */
 		break;
 
-	case CLKSRC_EXTENDER:	// Extender Mode:
-		cra |= ((2 << CRABIT_CLKSRC_B)	//   ClkSrcB source is OverflowA (same as "timer")
-			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	//     with direction obtained from ClkPol.
-		crb |= ((1 << CRBBIT_CLKPOL_B)	//   ClkPolB controls IndexB -- always set to active.
-			| (MULT_X0 << CRBBIT_CLKMULT_B));	//   ClkMultB selects OverflowA as the clock source.
+	case CLKSRC_EXTENDER:	/*  Extender Mode: */
+		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB source is OverflowA (same as "timer") */
+			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction obtained from ClkPol. */
+		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB controls IndexB -- always set to active. */
+			| (MULT_X0 << CRBBIT_CLKMULT_B));	/*    ClkMultB selects OverflowA as the clock source. */
 		break;
 
-	default:		// Counter Mode:
-		cra |= (CLKSRC_COUNTER << CRABIT_CLKSRC_B);	//   Select ENC_C and ENC_D as clock/direction inputs.
-		crb |= (((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRBBIT_CLKPOL_B))	//   ClkPol is passed through.
-			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	//   Force ClkMult to x1 if not legal, otherwise pass through.
+	default:		/*  Counter Mode: */
+		cra |= (CLKSRC_COUNTER << CRABIT_CLKSRC_B);	/*    Select ENC_C and ENC_D as clock/direction inputs. */
+		crb |= (((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRBBIT_CLKPOL_B))	/*    ClkPol is passed through. */
+			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force ClkMult to x1 if not legal, otherwise pass through. */
 				(MULT_X1 << CRBBIT_CLKMULT_B) :
 				((setup & STDMSK_CLKMULT) << (CRBBIT_CLKMULT_B -
 						STDBIT_CLKMULT))));
 	}
 
-	// Force positive index polarity if IndxSrc is software-driven only,
-	// otherwise pass it through.
+	/*  Force positive index polarity if IndxSrc is software-driven only, */
+	/*  otherwise pass it through. */
 	if (~setup & STDMSK_INDXSRC)
 		crb |= ((setup & STDMSK_INDXPOL) >> (STDBIT_INDXPOL -
 				CRBBIT_INDXPOL_B));
 
-	// If IntSrc has been forced to Disabled, update the MISC2 interrupt
-	// enable mask to indicate the counter interrupt is disabled.
+	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
+	/*  enable mask to indicate the counter interrupt is disabled. */
 	if (DisableIntSrc)
 		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
 
-	// While retaining CounterA and LatchSrc configurations, program the
-	// new counter operating mode.
+	/*  While retaining CounterA and LatchSrc configurations, program the */
+	/*  new counter operating mode. */
 	DEBIreplace(dev, k->MyCRA,
 		(uint16_t) (~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B)), cra);
 	DEBIreplace(dev, k->MyCRB, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
 }
 
-////////////////////////////////////////////////////////////////////////
-// Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
+/*  Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index. */
 
 static void SetEnable_A(comedi_device * dev, enc_private * k, uint16_t enab)
 {
@@ -3023,10 +3022,10 @@ static uint16_t GetEnable_B(comedi_device * dev, enc_private * k)
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_B) & 1;
 }
 
-////////////////////////////////////////////////////////////////////////
-// Return/set a counter pair's latch trigger source.  0: On read
-// access, 1: A index latches A, 2: B index latches B, 3: A overflow
-// latches B.
+/* Return/set a counter pair's latch trigger source.  0: On read
+ * access, 1: A index latches A, 2: B index latches B, 3: A overflow
+ * latches B.
+ */
 
 static void SetLatchSource(comedi_device * dev, enc_private * k, uint16_t value)
 {
@@ -3038,15 +3037,18 @@ static void SetLatchSource(comedi_device * dev, enc_private * k, uint16_t value)
 	DEBUG("SetLatchSource: SetLatchSource exit \n");
 }
 
-/* static uint16_t GetLatchSource(comedi_device *dev, enc_private *k ) */
-/* { */
-/*   return ( DEBIread( dev, k->MyCRB) >> CRBBIT_LATCHSRC ) & 3; */
-/* } */
+/*
+ * static uint16_t GetLatchSource(comedi_device *dev, enc_private *k )
+ * {
+ * 	return ( DEBIread( dev, k->MyCRB) >> CRBBIT_LATCHSRC ) & 3;
+ * }
+ */
 
-/////////////////////////////////////////////////////////////////////////
-// Return/set the event that will trigger transfer of the preload
-// register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
-// 2=OverflowA (B counters only), 3=disabled.
+/*
+ * Return/set the event that will trigger transfer of the preload
+ * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
+ * 2=OverflowA (B counters only), 3=disabled.
+ */
 
 static void SetLoadTrig_A(comedi_device * dev, enc_private * k, uint16_t Trig)
 {
@@ -3071,23 +3073,23 @@ static uint16_t GetLoadTrig_B(comedi_device * dev, enc_private * k)
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_LOADSRC_B) & 3;
 }
 
-////////////////////
-// Return/set counter interrupt source and clear any captured
-// index/overflow events.  IntSource: 0=Disabled, 1=OverflowOnly,
-// 2=IndexOnly, 3=IndexAndOverflow.
+/* Return/set counter interrupt source and clear any captured
+ * index/overflow events.  IntSource: 0=Disabled, 1=OverflowOnly,
+ * 2=IndexOnly, 3=IndexAndOverflow.
+ */
 
 static void SetIntSrc_A(comedi_device * dev, enc_private * k,
 	uint16_t IntSource)
 {
-	// Reset any pending counter overflow or index captures.
+	/*  Reset any pending counter overflow or index captures. */
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 
-	// Program counter interrupt source.
+	/*  Program counter interrupt source. */
 	DEBIreplace(dev, k->MyCRA, ~CRAMSK_INTSRC_A,
 		(uint16_t) (IntSource << CRABIT_INTSRC_A));
 
-	// Update MISC2 interrupt enable mask.
+	/*  Update MISC2 interrupt enable mask. */
 	devpriv->CounterIntEnabs =
 		(devpriv->CounterIntEnabs & ~k->MyEventBits[3]) | k->
 		MyEventBits[IntSource];
@@ -3098,19 +3100,19 @@ static void SetIntSrc_B(comedi_device * dev, enc_private * k,
 {
 	uint16_t crb;
 
-	// Cache writeable CRB register image.
+	/*  Cache writeable CRB register image. */
 	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;
 
-	// Reset any pending counter overflow or index captures.
+	/*  Reset any pending counter overflow or index captures. */
 	DEBIwrite(dev, k->MyCRB,
 		(uint16_t) (crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
 
-	// Program counter interrupt source.
+	/*  Program counter interrupt source. */
 	DEBIwrite(dev, k->MyCRB,
 		(uint16_t) ((crb & ~CRBMSK_INTSRC_B) | (IntSource <<
 				CRBBIT_INTSRC_B)));
 
-	// Update MISC2 interrupt enable mask.
+	/*  Update MISC2 interrupt enable mask. */
 	devpriv->CounterIntEnabs =
 		(devpriv->CounterIntEnabs & ~k->MyEventBits[3]) | k->
 		MyEventBits[IntSource];
@@ -3126,8 +3128,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_INTSRC_B) & 3;
 }
 
-/////////////////////////////////////////////////////////////////////////
-// Return/set the clock multiplier.
+/*  Return/set the clock multiplier. */
 
 /* static void SetClkMult(comedi_device *dev, enc_private *k, uint16_t value )  */
 /* { */
@@ -3139,8 +3140,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 /*   return ( k->GetMode(dev, k ) >> STDBIT_CLKMULT ) & 3; */
 /* } */
 
-/* ////////////////////////////////////////////////////////////////////////// */
-/* // Return/set the clock polarity. */
+/* Return/set the clock polarity. */
 
 /* static void SetClkPol( comedi_device *dev,enc_private *k, uint16_t value )  */
 /* { */
@@ -3152,8 +3152,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 /*   return ( k->GetMode(dev, k ) >> STDBIT_CLKPOL ) & 1; */
 /* } */
 
-/* /////////////////////////////////////////////////////////////////////// */
-/* // Return/set the clock source. */
+/* Return/set the clock source.  */
 
 /* static void SetClkSrc( comedi_device *dev,enc_private *k, uint16_t value )  */
 /* { */
@@ -3165,8 +3164,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 /*   return ( k->GetMode(dev, k ) >> STDBIT_CLKSRC ) & 3; */
 /* } */
 
-/* //////////////////////////////////////////////////////////////////////// */
-/* // Return/set the index polarity. */
+/* Return/set the index polarity. */
 
 /* static void SetIndexPol(comedi_device *dev, enc_private *k, uint16_t value )  */
 /* { */
@@ -3178,8 +3176,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 /*   return ( k->GetMode(dev, k ) >> STDBIT_INDXPOL ) & 1; */
 /* } */
 
-/* //////////////////////////////////////////////////////////////////////// */
-/* // Return/set the index source. */
+/*  Return/set the index source. */
 
 /* static void SetIndexSrc(comedi_device *dev, enc_private *k, uint16_t value )  */
 /* { */
@@ -3192,8 +3189,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 /*   return ( k->GetMode(dev, k ) >> STDBIT_INDXSRC ) & 1; */
 /* } */
 
-///////////////////////////////////////////////////////////////////
-// Generate an index pulse.
+/*  Generate an index pulse. */
 
 static void PulseIndex_A(comedi_device * dev, enc_private * k)
 {
@@ -3201,7 +3197,7 @@ static void PulseIndex_A(comedi_device * dev, enc_private * k)
 
 	DEBUG("PulseIndex_A: pulse index enter\n");
 
-	cra = DEBIread(dev, k->MyCRA);	// Pulse index.
+	cra = DEBIread(dev, k->MyCRA);	/*  Pulse index. */
 	DEBIwrite(dev, k->MyCRA, (uint16_t) (cra ^ CRAMSK_INDXPOL_A));
 	DEBUG("PulseIndex_A: pulse index step1\n");
 	DEBIwrite(dev, k->MyCRA, cra);
@@ -3211,18 +3207,17 @@ static void PulseIndex_B(comedi_device * dev, enc_private * k)
 {
 	register uint16_t crb;
 
-	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;	// Pulse index.
+	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;	/*  Pulse index. */
 	DEBIwrite(dev, k->MyCRB, (uint16_t) (crb ^ CRBMSK_INDXPOL_B));
 	DEBIwrite(dev, k->MyCRB, crb);
 }
 
-/////////////////////////////////////////////////////////
-// Write value into counter preload register.
+/*  Write value into counter preload register. */
 
 static void Preload(comedi_device * dev, enc_private * k, uint32_t value)
 {
 	DEBUG("Preload: preload enter\n");
-	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	// Write value to preload register.
+	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
 	DEBUG("Preload: preload step 1\n");
 	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw + 2),
 		(uint16_t) (value >> 16));
@@ -3232,16 +3227,16 @@ static void CountersInit(comedi_device * dev)
 {
 	int chan;
 	enc_private *k;
-	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	// Preload upon
-		// index.
-		(INDXSRC_SOFT << BF_INDXSRC) |	// Disable hardware index.
-		(CLKSRC_COUNTER << BF_CLKSRC) |	// Operating mode is counter.
-		(CLKPOL_POS << BF_CLKPOL) |	// Active high clock.
-		(CNTDIR_UP << BF_CLKPOL) |	// Count direction is up.
-		(CLKMULT_1X << BF_CLKMULT) |	// Clock multiplier is 1x.
-		(CLKENAB_INDEX << BF_CLKENAB);	// Enabled by index
-
-	// Disable all counter interrupts and clear any captured counter events.
+	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
+		/*  index. */
+		(INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+		(CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is counter. */
+		(CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+		(CNTDIR_UP << BF_CLKPOL) |	/*  Count direction is up. */
+		(CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
+		(CLKENAB_INDEX << BF_CLKENAB);	/*  Enabled by index */
+
+	/*  Disable all counter interrupts and clear any captured counter events. */
 	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
 		k = &encpriv[chan];
 		k->SetMode(dev, k, Setup, TRUE);

commit 11e865c1dad436d2ce65c7d366030d1b62967a83
Author: Gianluca Palli <gpalli@deis.unibo.it>
Date:   Wed Nov 19 14:10:49 2008 -0800

    Staging: comedi: add s626 driver
    
    This adds the s626 comedi driver to the build.
    
    From: Gianluca Palli <gpalli@deis.unibo.it>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
new file mode 100644
index 000000000000..469ee8c474c9
--- /dev/null
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -0,0 +1,3254 @@
+/*
+  comedi/drivers/s626.c
+  Sensoray s626 Comedi driver
+
+  COMEDI - Linux Control and Measurement Device Interface
+  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+
+  Based on Sensoray Model 626 Linux driver Version 0.2
+  Copyright (C) 2002-2004 Sensoray Co., Inc.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+/*
+Driver: s626
+Description: Sensoray 626 driver
+Devices: [Sensoray] 626 (s626)
+Authors: Gianluca Palli <gpalli@deis.unibo.it>,
+Updated: Fri, 15 Feb 2008 10:28:42 +0000
+Status: experimental
+
+Configuration options:
+  [0] - PCI bus of device (optional)
+  [1] - PCI slot of device (optional)
+  If bus/slot is not specified, the first supported
+  PCI device found will be used.
+
+INSN_CONFIG instructions:
+  analog input:
+   none
+
+  analog output:
+   none
+
+  digital channel:
+   s626 has 3 dio subdevices (2,3 and 4) each with 16 i/o channels
+   supported configuration options:
+   INSN_CONFIG_DIO_QUERY
+   COMEDI_INPUT
+   COMEDI_OUTPUT
+
+  encoder:
+   Every channel must be configured before reading.
+
+   Example code
+
+   insn.insn=INSN_CONFIG;   //configuration instruction
+   insn.n=1;                //number of operation (must be 1)
+   insn.data=&initialvalue; //initial value loaded into encoder
+                            //during configuration
+   insn.subdev=5;           //encoder subdevice
+   insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); //encoder_channel
+                                                        //to configure
+
+   comedi_do_insn(cf,&insn); //executing configuration
+*/
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#include "../comedidev.h"
+
+#include "comedi_pci.h"
+
+#include "comedi_fc.h"
+#include "s626.h"
+
+MODULE_AUTHOR("Gianluca Palli <gpalli@deis.unibo.it>");
+MODULE_DESCRIPTION("Sensoray 626 Comedi driver module");
+MODULE_LICENSE("GPL");
+
+typedef struct s626_board_struct {
+	const char *name;
+	int ai_chans;
+	int ai_bits;
+	int ao_chans;
+	int ao_bits;
+	int dio_chans;
+	int dio_banks;
+	int enc_chans;
+} s626_board;
+
+static const s626_board s626_boards[] = {
+	{
+	      name:	"s626",
+	      ai_chans:S626_ADC_CHANNELS,
+	      ai_bits:	14,
+	      ao_chans:S626_DAC_CHANNELS,
+	      ao_bits:	13,
+	      dio_chans:S626_DIO_CHANNELS,
+	      dio_banks:S626_DIO_BANKS,
+	      enc_chans:S626_ENCODER_CHANNELS,
+		}
+};
+
+#define thisboard ((const s626_board *)dev->board_ptr)
+#define PCI_VENDOR_ID_S626 0x1131
+#define PCI_DEVICE_ID_S626 0x7146
+
+static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
+	{PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+		0},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, s626_pci_table);
+
+static int s626_attach(comedi_device * dev, comedi_devconfig * it);
+static int s626_detach(comedi_device * dev);
+
+static comedi_driver driver_s626 = {
+      driver_name:"s626",
+      module:THIS_MODULE,
+      attach:s626_attach,
+      detach:s626_detach,
+};
+
+typedef struct {
+	struct pci_dev *pdev;
+	void *base_addr;
+	int got_regions;
+	short allocatedBuf;
+	uint8_t ai_cmd_running;	// ai_cmd is running
+	uint8_t ai_continous;	// continous aquisition
+	int ai_sample_count;	// number of samples to aquire
+	unsigned int ai_sample_timer;	// time between samples in
+	// units of the timer
+	int ai_convert_count;	// conversion counter
+	unsigned int ai_convert_timer;	// time between conversion in
+	// units of the timer
+	uint16_t CounterIntEnabs;	//Counter interrupt enable
+	//mask for MISC2 register.
+	uint8_t AdcItems;	//Number of items in ADC poll
+	//list.
+	DMABUF RPSBuf;		//DMA buffer used to hold ADC
+	//(RPS1) program.
+	DMABUF ANABuf;		//DMA buffer used to receive
+	//ADC data and hold DAC data.
+	uint32_t *pDacWBuf;	//Pointer to logical adrs of
+	//DMA buffer used to hold DAC
+	//data.
+	uint16_t Dacpol;	//Image of DAC polarity
+	//register.
+	uint8_t TrimSetpoint[12];	//Images of TrimDAC setpoints.
+	//registers.
+	uint16_t ChargeEnabled;	//Image of MISC2 Battery
+	//Charge Enabled (0 or
+	//WRMISC2_CHARGE_ENABLE).
+	uint16_t WDInterval;	//Image of MISC2 watchdog
+	//interval control bits.
+	uint32_t I2CAdrs;	//I2C device address for
+	//onboard EEPROM (board rev
+	//dependent).
+	//  short         I2Cards;
+	lsampl_t ao_readback[S626_DAC_CHANNELS];
+} s626_private;
+
+typedef struct {
+	uint16_t RDDIn;
+	uint16_t WRDOut;
+	uint16_t RDEdgSel;
+	uint16_t WREdgSel;
+	uint16_t RDCapSel;
+	uint16_t WRCapSel;
+	uint16_t RDCapFlg;
+	uint16_t RDIntSel;
+	uint16_t WRIntSel;
+} dio_private;
+
+static dio_private dio_private_A = {
+      RDDIn:LP_RDDINA,
+      WRDOut:LP_WRDOUTA,
+      RDEdgSel:LP_RDEDGSELA,
+      WREdgSel:LP_WREDGSELA,
+      RDCapSel:LP_RDCAPSELA,
+      WRCapSel:LP_WRCAPSELA,
+      RDCapFlg:LP_RDCAPFLGA,
+      RDIntSel:LP_RDINTSELA,
+      WRIntSel:LP_WRINTSELA,
+};
+
+static dio_private dio_private_B = {
+      RDDIn:LP_RDDINB,
+      WRDOut:LP_WRDOUTB,
+      RDEdgSel:LP_RDEDGSELB,
+      WREdgSel:LP_WREDGSELB,
+      RDCapSel:LP_RDCAPSELB,
+      WRCapSel:LP_WRCAPSELB,
+      RDCapFlg:LP_RDCAPFLGB,
+      RDIntSel:LP_RDINTSELB,
+      WRIntSel:LP_WRINTSELB,
+};
+
+static dio_private dio_private_C = {
+      RDDIn:LP_RDDINC,
+      WRDOut:LP_WRDOUTC,
+      RDEdgSel:LP_RDEDGSELC,
+      WREdgSel:LP_WREDGSELC,
+      RDCapSel:LP_RDCAPSELC,
+      WRCapSel:LP_WRCAPSELC,
+      RDCapFlg:LP_RDCAPFLGC,
+      RDIntSel:LP_RDINTSELC,
+      WRIntSel:LP_WRINTSELC,
+};
+
+/* to group dio devices (48 bits mask and data are not allowed ???)
+static dio_private *dio_private_word[]={
+  &dio_private_A,
+  &dio_private_B,
+  &dio_private_C,
+};
+*/
+
+#define devpriv ((s626_private *)dev->private)
+#define diopriv ((dio_private *)s->private)
+
+COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
+
+//ioctl routines
+static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+/* static int s626_ai_rinsn(comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,lsampl_t *data); */
+static int s626_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s);
+static int s626_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int s626_ai_cancel(comedi_device * dev, comedi_subdevice * s);
+static int s626_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s626_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s626_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s626_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s626_dio_set_irq(comedi_device * dev, unsigned int chan);
+static int s626_dio_reset_irq(comedi_device * dev, unsigned int gruop,
+	unsigned int mask);
+static int s626_dio_clear_irq(comedi_device * dev);
+static int s626_enc_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s626_enc_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s626_enc_insn_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s626_ns_to_timer(int *nanosec, int round_mode);
+static int s626_ai_load_polllist(uint8_t * ppl, comedi_cmd * cmd);
+static int s626_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum);
+static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG);
+static lsampl_t s626_ai_reg_to_uint(int data);
+/* static lsampl_t s626_uint_to_reg(comedi_subdevice *s, int data); */
+
+//end ioctl routines
+
+//internal routines
+static void s626_dio_init(comedi_device * dev);
+static void ResetADC(comedi_device * dev, uint8_t * ppl);
+static void LoadTrimDACs(comedi_device * dev);
+static void WriteTrimDAC(comedi_device * dev, uint8_t LogicalChan,
+	uint8_t DacData);
+static uint8_t I2Cread(comedi_device * dev, uint8_t addr);
+static uint32_t I2Chandshake(comedi_device * dev, uint32_t val);
+static void SetDAC(comedi_device * dev, uint16_t chan, short dacdata);
+static void SendDAC(comedi_device * dev, uint32_t val);
+static void WriteMISC2(comedi_device * dev, uint16_t NewImage);
+static void DEBItransfer(comedi_device * dev);
+static uint16_t DEBIread(comedi_device * dev, uint16_t addr);
+static void DEBIwrite(comedi_device * dev, uint16_t addr, uint16_t wdata);
+static void DEBIreplace(comedi_device * dev, uint16_t addr, uint16_t mask,
+	uint16_t wdata);
+static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize);
+
+// COUNTER OBJECT ------------------------------------------------
+typedef struct enc_private_struct {
+	// Pointers to functions that differ for A and B counters:
+	uint16_t(*GetEnable) (comedi_device * dev, struct enc_private_struct *);	//Return clock enable.
+	uint16_t(*GetIntSrc) (comedi_device * dev, struct enc_private_struct *);	//Return interrupt source.
+	uint16_t(*GetLoadTrig) (comedi_device * dev, struct enc_private_struct *);	//Return preload trigger source.
+	uint16_t(*GetMode) (comedi_device * dev, struct enc_private_struct *);	//Return standardized operating mode.
+	void (*PulseIndex) (comedi_device * dev, struct enc_private_struct *);	//Generate soft index strobe.
+	void (*SetEnable) (comedi_device * dev, struct enc_private_struct *, uint16_t enab);	//Program clock enable.
+	void (*SetIntSrc) (comedi_device * dev, struct enc_private_struct *, uint16_t IntSource);	//Program interrupt source.
+	void (*SetLoadTrig) (comedi_device * dev, struct enc_private_struct *, uint16_t Trig);	//Program preload trigger source.
+	void (*SetMode) (comedi_device * dev, struct enc_private_struct *, uint16_t Setup, uint16_t DisableIntSrc);	//Program standardized operating mode.
+	void (*ResetCapFlags) (comedi_device * dev, struct enc_private_struct *);	//Reset event capture flags.
+
+	uint16_t MyCRA;		//   Address of CRA register.
+	uint16_t MyCRB;		//   Address of CRB register.
+	uint16_t MyLatchLsw;	//   Address of Latch least-significant-word
+	//   register.
+	uint16_t MyEventBits[4];	//   Bit translations for IntSrc -->RDMISC2.
+} enc_private;			//counter object
+
+#define encpriv ((enc_private *)(dev->subdevices+5)->private)
+
+//counters routines
+static void s626_timer_load(comedi_device * dev, enc_private * k, int tick);
+static uint32_t ReadLatch(comedi_device * dev, enc_private * k);
+static void ResetCapFlags_A(comedi_device * dev, enc_private * k);
+static void ResetCapFlags_B(comedi_device * dev, enc_private * k);
+static uint16_t GetMode_A(comedi_device * dev, enc_private * k);
+static uint16_t GetMode_B(comedi_device * dev, enc_private * k);
+static void SetMode_A(comedi_device * dev, enc_private * k, uint16_t Setup,
+	uint16_t DisableIntSrc);
+static void SetMode_B(comedi_device * dev, enc_private * k, uint16_t Setup,
+	uint16_t DisableIntSrc);
+static void SetEnable_A(comedi_device * dev, enc_private * k, uint16_t enab);
+static void SetEnable_B(comedi_device * dev, enc_private * k, uint16_t enab);
+static uint16_t GetEnable_A(comedi_device * dev, enc_private * k);
+static uint16_t GetEnable_B(comedi_device * dev, enc_private * k);
+static void SetLatchSource(comedi_device * dev, enc_private * k,
+	uint16_t value);
+/* static uint16_t GetLatchSource(comedi_device *dev, enc_private *k ); */
+static void SetLoadTrig_A(comedi_device * dev, enc_private * k, uint16_t Trig);
+static void SetLoadTrig_B(comedi_device * dev, enc_private * k, uint16_t Trig);
+static uint16_t GetLoadTrig_A(comedi_device * dev, enc_private * k);
+static uint16_t GetLoadTrig_B(comedi_device * dev, enc_private * k);
+static void SetIntSrc_B(comedi_device * dev, enc_private * k,
+	uint16_t IntSource);
+static void SetIntSrc_A(comedi_device * dev, enc_private * k,
+	uint16_t IntSource);
+static uint16_t GetIntSrc_A(comedi_device * dev, enc_private * k);
+static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k);
+/* static void SetClkMult(comedi_device *dev, enc_private *k, uint16_t value ) ; */
+/* static uint16_t GetClkMult(comedi_device *dev, enc_private *k ) ; */
+/* static void SetIndexPol(comedi_device *dev, enc_private *k, uint16_t value ); */
+/* static uint16_t GetClkPol(comedi_device *dev, enc_private *k ) ; */
+/* static void SetIndexSrc( comedi_device *dev,enc_private *k, uint16_t value );  */
+/* static uint16_t GetClkSrc( comedi_device *dev,enc_private *k );  */
+/* static void SetIndexSrc( comedi_device *dev,enc_private *k, uint16_t value );  */
+/* static uint16_t GetIndexSrc( comedi_device *dev,enc_private *k );  */
+static void PulseIndex_A(comedi_device * dev, enc_private * k);
+static void PulseIndex_B(comedi_device * dev, enc_private * k);
+static void Preload(comedi_device * dev, enc_private * k, uint32_t value);
+static void CountersInit(comedi_device * dev);
+//end internal routines
+
+/////////////////////////////////////////////////////////////////////////
+// Counter objects constructor.
+
+// Counter overflow/index event flag masks for RDMISC2.
+#define INDXMASK(C)		( 1 << ( ( (C) > 2 ) ? ( (C) * 2 - 1 ) : ( (C) * 2 +  4 ) ) )
+#define OVERMASK(C)		( 1 << ( ( (C) > 2 ) ? ( (C) * 2 + 5 ) : ( (C) * 2 + 10 ) ) )
+#define EVBITS(C)		{ 0, OVERMASK(C), INDXMASK(C), OVERMASK(C) | INDXMASK(C) }
+
+// Translation table to map IntSrc into equivalent RDMISC2 event flag
+// bits.
+//static const uint16_t EventBits[][4] = { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) };
+
+/* enc_private; */
+static enc_private enc_private_data[] = {
+	{
+	      GetEnable:GetEnable_A,
+	      GetIntSrc:GetIntSrc_A,
+	      GetLoadTrig:GetLoadTrig_A,
+	      GetMode:	GetMode_A,
+	      PulseIndex:PulseIndex_A,
+	      SetEnable:SetEnable_A,
+	      SetIntSrc:SetIntSrc_A,
+	      SetLoadTrig:SetLoadTrig_A,
+	      SetMode:	SetMode_A,
+	      ResetCapFlags:ResetCapFlags_A,
+	      MyCRA:	LP_CR0A,
+	      MyCRB:	LP_CR0B,
+	      MyLatchLsw:LP_CNTR0ALSW,
+	      MyEventBits:EVBITS(0),
+		},
+	{
+	      GetEnable:GetEnable_A,
+	      GetIntSrc:GetIntSrc_A,
+	      GetLoadTrig:GetLoadTrig_A,
+	      GetMode:	GetMode_A,
+	      PulseIndex:PulseIndex_A,
+	      SetEnable:SetEnable_A,
+	      SetIntSrc:SetIntSrc_A,
+	      SetLoadTrig:SetLoadTrig_A,
+	      SetMode:	SetMode_A,
+	      ResetCapFlags:ResetCapFlags_A,
+	      MyCRA:	LP_CR1A,
+	      MyCRB:	LP_CR1B,
+	      MyLatchLsw:LP_CNTR1ALSW,
+	      MyEventBits:EVBITS(1),
+		},
+	{
+	      GetEnable:GetEnable_A,
+	      GetIntSrc:GetIntSrc_A,
+	      GetLoadTrig:GetLoadTrig_A,
+	      GetMode:	GetMode_A,
+	      PulseIndex:PulseIndex_A,
+	      SetEnable:SetEnable_A,
+	      SetIntSrc:SetIntSrc_A,
+	      SetLoadTrig:SetLoadTrig_A,
+	      SetMode:	SetMode_A,
+	      ResetCapFlags:ResetCapFlags_A,
+	      MyCRA:	LP_CR2A,
+	      MyCRB:	LP_CR2B,
+	      MyLatchLsw:LP_CNTR2ALSW,
+	      MyEventBits:EVBITS(2),
+		},
+	{
+	      GetEnable:GetEnable_B,
+	      GetIntSrc:GetIntSrc_B,
+	      GetLoadTrig:GetLoadTrig_B,
+	      GetMode:	GetMode_B,
+	      PulseIndex:PulseIndex_B,
+	      SetEnable:SetEnable_B,
+	      SetIntSrc:SetIntSrc_B,
+	      SetLoadTrig:SetLoadTrig_B,
+	      SetMode:	SetMode_B,
+	      ResetCapFlags:ResetCapFlags_B,
+	      MyCRA:	LP_CR0A,
+	      MyCRB:	LP_CR0B,
+	      MyLatchLsw:LP_CNTR0BLSW,
+	      MyEventBits:EVBITS(3),
+		},
+	{
+	      GetEnable:GetEnable_B,
+	      GetIntSrc:GetIntSrc_B,
+	      GetLoadTrig:GetLoadTrig_B,
+	      GetMode:	GetMode_B,
+	      PulseIndex:PulseIndex_B,
+	      SetEnable:SetEnable_B,
+	      SetIntSrc:SetIntSrc_B,
+	      SetLoadTrig:SetLoadTrig_B,
+	      SetMode:	SetMode_B,
+	      ResetCapFlags:ResetCapFlags_B,
+	      MyCRA:	LP_CR1A,
+	      MyCRB:	LP_CR1B,
+	      MyLatchLsw:LP_CNTR1BLSW,
+	      MyEventBits:EVBITS(4),
+		},
+	{
+	      GetEnable:GetEnable_B,
+	      GetIntSrc:GetIntSrc_B,
+	      GetLoadTrig:GetLoadTrig_B,
+	      GetMode:	GetMode_B,
+	      PulseIndex:PulseIndex_B,
+	      SetEnable:SetEnable_B,
+	      SetIntSrc:SetIntSrc_B,
+	      SetLoadTrig:SetLoadTrig_B,
+	      SetMode:	SetMode_B,
+	      ResetCapFlags:ResetCapFlags_B,
+	      MyCRA:	LP_CR2A,
+	      MyCRB:	LP_CR2B,
+	      MyLatchLsw:LP_CNTR2BLSW,
+	      MyEventBits:EVBITS(5),
+		},
+};
+
+// enab/disable a function or test status bit(s) that are accessed
+// through Main Control Registers 1 or 2.
+#define MC_ENABLE( REGADRS, CTRLWORD )	writel(  ( (uint32_t)( CTRLWORD ) << 16 ) | (uint32_t)( CTRLWORD ),devpriv->base_addr+( REGADRS ) )
+
+#define MC_DISABLE( REGADRS, CTRLWORD )	writel(  (uint32_t)( CTRLWORD ) << 16 , devpriv->base_addr+( REGADRS ) )
+
+#define MC_TEST( REGADRS, CTRLWORD )	( ( readl(devpriv->base_addr+( REGADRS )) & CTRLWORD ) != 0 )
+
+/* #define WR7146(REGARDS,CTRLWORD)
+    writel(CTRLWORD,(uint32_t)(devpriv->base_addr+(REGARDS))) */
+#define WR7146(REGARDS,CTRLWORD) writel(CTRLWORD,devpriv->base_addr+(REGARDS))
+
+/* #define RR7146(REGARDS)
+    readl((uint32_t)(devpriv->base_addr+(REGARDS))) */
+#define RR7146(REGARDS)		readl(devpriv->base_addr+(REGARDS))
+
+#define BUGFIX_STREG(REGADRS)   ( REGADRS - 4 )
+
+// Write a time slot control record to TSL2.
+#define VECTPORT( VECTNUM )		(P_TSL2 + ( (VECTNUM) << 2 ))
+#define SETVECT( VECTNUM, VECTVAL )	WR7146(VECTPORT( VECTNUM ), (VECTVAL))
+
+// Code macros used for constructing I2C command bytes.
+#define I2C_B2(ATTR,VAL)	( ( (ATTR) << 6 ) | ( (VAL) << 24 ) )
+#define I2C_B1(ATTR,VAL)	( ( (ATTR) << 4 ) | ( (VAL) << 16 ) )
+#define I2C_B0(ATTR,VAL)	( ( (ATTR) << 2 ) | ( (VAL) <<  8 ) )
+
+static const comedi_lrange s626_range_table = { 2, {
+			RANGE(-5, 5),
+			RANGE(-10, 10),
+	}
+};
+
+static int s626_attach(comedi_device * dev, comedi_devconfig * it)
+{
+/*   uint8_t	PollList; */
+/*   uint16_t	AdcData; */
+/*   uint16_t	StartVal; */
+/*   uint16_t	index; */
+/*   unsigned int data[16]; */
+	int result;
+	int i;
+	int ret;
+	resource_size_t resourceStart;
+	dma_addr_t appdma;
+	comedi_subdevice *s;
+	struct pci_dev *pdev;
+
+	if (alloc_private(dev, sizeof(s626_private)) < 0)
+		return -ENOMEM;
+
+	for (pdev = pci_get_device(PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626,
+			NULL); pdev != NULL;
+		pdev = pci_get_device(PCI_VENDOR_ID_S626,
+			PCI_DEVICE_ID_S626, pdev)) {
+		if (it->options[0] || it->options[1]) {
+			if (pdev->bus->number == it->options[0] &&
+				PCI_SLOT(pdev->devfn) == it->options[1]) {
+				/* matches requested bus/slot */
+				break;
+			}
+		} else {
+			/* no bus/slot specified */
+			break;
+		}
+	}
+	devpriv->pdev = pdev;
+
+	if (pdev == NULL) {
+		printk("s626_attach: Board not present!!!\n");
+		return -ENODEV;
+	}
+
+	if ((result = comedi_pci_enable(pdev, "s626")) < 0) {
+		printk("s626_attach: comedi_pci_enable fails\n");
+		return -ENODEV;
+	}
+	devpriv->got_regions = 1;
+
+	resourceStart = pci_resource_start(devpriv->pdev, 0);
+
+	devpriv->base_addr = ioremap(resourceStart, SIZEOF_ADDRESS_SPACE);
+	if (devpriv->base_addr == NULL) {
+		printk("s626_attach: IOREMAP failed\n");
+		return -ENODEV;
+	}
+
+	if (devpriv->base_addr) {
+		//disable master interrupt
+		writel(0, devpriv->base_addr + P_IER);
+
+		//soft reset
+		writel(MC1_SOFT_RESET, devpriv->base_addr + P_MC1);
+
+		//DMA FIXME DMA//
+		DEBUG("s626_attach: DMA ALLOCATION\n");
+
+		//adc buffer allocation
+		devpriv->allocatedBuf = 0;
+
+		if ((devpriv->ANABuf.LogicalBase =
+				pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE,
+					&appdma)) == NULL) {
+			printk("s626_attach: DMA Memory mapping error\n");
+			return -ENOMEM;
+		}
+
+		devpriv->ANABuf.PhysicalBase = appdma;
+
+		DEBUG("s626_attach: AllocDMAB ADC Logical=%p, bsize=%d, Physical=0x%x\n", devpriv->ANABuf.LogicalBase, DMABUF_SIZE, (uint32_t) devpriv->ANABuf.PhysicalBase);
+
+		devpriv->allocatedBuf++;
+
+		if ((devpriv->RPSBuf.LogicalBase =
+				pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE,
+					&appdma)) == NULL) {
+			printk("s626_attach: DMA Memory mapping error\n");
+			return -ENOMEM;
+		}
+
+		devpriv->RPSBuf.PhysicalBase = appdma;
+
+		DEBUG("s626_attach: AllocDMAB RPS Logical=%p, bsize=%d, Physical=0x%x\n", devpriv->RPSBuf.LogicalBase, DMABUF_SIZE, (uint32_t) devpriv->RPSBuf.PhysicalBase);
+
+		devpriv->allocatedBuf++;
+
+	}
+
+	dev->board_ptr = s626_boards;
+	dev->board_name = thisboard->name;
+
+	if (alloc_subdevices(dev, 6) < 0)
+		return -ENOMEM;
+
+	dev->iobase = (unsigned long)devpriv->base_addr;
+	dev->irq = devpriv->pdev->irq;
+
+	//set up interrupt handler
+	if (dev->irq == 0) {
+		printk(" unknown irq (bad)\n");
+	} else {
+		if ((ret = comedi_request_irq(dev->irq, s626_irq_handler,
+					IRQF_SHARED, "s626", dev)) < 0) {
+			printk(" irq not available\n");
+			dev->irq = 0;
+		}
+	}
+
+	DEBUG("s626_attach: -- it opts  %d,%d -- \n",
+		it->options[0], it->options[1]);
+
+	s = dev->subdevices + 0;
+	/* analog input subdevice */
+	dev->read_subdev = s;
+	/* we support single-ended (ground) and differential */
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_CMD_READ;
+	s->n_chan = thisboard->ai_chans;
+	s->maxdata = (0xffff >> 2);
+	s->range_table = &s626_range_table;
+	s->len_chanlist = thisboard->ai_chans;	/* This is the maximum chanlist
+						   length that the board can
+						   handle */
+	s->insn_config = s626_ai_insn_config;
+	s->insn_read = s626_ai_insn_read;
+	s->do_cmd = s626_ai_cmd;
+	s->do_cmdtest = s626_ai_cmdtest;
+	s->cancel = s626_ai_cancel;
+
+	s = dev->subdevices + 1;
+	/* analog output subdevice */
+	s->type = COMEDI_SUBD_AO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = thisboard->ao_chans;
+	s->maxdata = (0x3fff);
+	s->range_table = &range_bipolar10;
+	s->insn_write = s626_ao_winsn;
+	s->insn_read = s626_ao_rinsn;
+
+	s = dev->subdevices + 2;
+	/* digital I/O subdevice */
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = S626_DIO_CHANNELS;
+	s->maxdata = 1;
+	s->io_bits = 0xffff;
+	s->private = &dio_private_A;
+	s->range_table = &range_digital;
+	s->insn_config = s626_dio_insn_config;
+	s->insn_bits = s626_dio_insn_bits;
+
+	s = dev->subdevices + 3;
+	/* digital I/O subdevice */
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = 16;
+	s->maxdata = 1;
+	s->io_bits = 0xffff;
+	s->private = &dio_private_B;
+	s->range_table = &range_digital;
+	s->insn_config = s626_dio_insn_config;
+	s->insn_bits = s626_dio_insn_bits;
+
+	s = dev->subdevices + 4;
+	/* digital I/O subdevice */
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = 16;
+	s->maxdata = 1;
+	s->io_bits = 0xffff;
+	s->private = &dio_private_C;
+	s->range_table = &range_digital;
+	s->insn_config = s626_dio_insn_config;
+	s->insn_bits = s626_dio_insn_bits;
+
+	s = dev->subdevices + 5;
+	/* encoder (counter) subdevice */
+	s->type = COMEDI_SUBD_COUNTER;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;
+	s->n_chan = thisboard->enc_chans;
+	s->private = enc_private_data;
+	s->insn_config = s626_enc_insn_config;
+	s->insn_read = s626_enc_insn_read;
+	s->insn_write = s626_enc_insn_write;
+	s->maxdata = 0xffffff;
+	s->range_table = &range_unknown;
+
+	//stop ai_command
+	devpriv->ai_cmd_running = 0;
+
+	if (devpriv->base_addr && (devpriv->allocatedBuf == 2)) {
+		dma_addr_t pPhysBuf;
+		uint16_t chan;
+
+		// enab DEBI and audio pins, enable I2C interface.
+		MC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);
+		// Configure DEBI operating mode.
+		WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	// Local bus is 16
+			// bits wide.
+			| (DEBI_TOUT << DEBI_CFG_TOUT_BIT)	// Declare DEBI
+			// transfer timeout
+			// interval.
+			| DEBI_SWAP	// Set up byte lane
+			// steering.
+			| DEBI_CFG_INTEL);	// Intel-compatible
+		// local bus (DEBI
+		// never times out).
+		DEBUG("s626_attach: %d debi init -- %d\n",
+			DEBI_CFG_SLAVE16 | (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
+			DEBI_SWAP | DEBI_CFG_INTEL,
+			DEBI_CFG_INTEL | DEBI_CFG_TOQ | DEBI_CFG_INCQ |
+			DEBI_CFG_16Q);
+
+		//DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ
+		//| DEBI_CFG_INCQ| DEBI_CFG_16Q); //end
+
+		// Paging is disabled.
+		WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);	// Disable MMU paging.
+
+		// Init GPIO so that ADC Start* is negated.
+		WR7146(P_GPIO, GPIO_BASE | GPIO1_HI);
+
+		//IsBoardRevA is a boolean that indicates whether the board is
+		//RevA.
+
+		// VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
+		// EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
+		// is used to access the onboard serial EEPROM.  The EEPROM's I2C
+		// DeviceAddress is hardwired to a value that is dependent on the
+		// 626 board revision.  On all board revisions, the EEPROM stores
+		// TrimDAC calibration constants for analog I/O.  On RevB and
+		// higher boards, the DeviceAddress is hardwired to 0 to enable
+		// the EEPROM to also store the PCI SubVendorID and SubDeviceID;
+		// this is the address at which the SAA7146 expects a
+		// configuration EEPROM to reside.  On RevA boards, the EEPROM
+		// device address, which is hardwired to 4, prevents the SAA7146
+		// from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
+		// default values, instead.
+
+		//    devpriv->I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM
+		// DeviceType (0xA0)
+		// and DeviceAddress<<1.
+
+		devpriv->I2CAdrs = 0xA0;	// I2C device address for onboard
+		// eeprom(revb)
+
+		// Issue an I2C ABORT command to halt any I2C operation in
+		//progress and reset BUSY flag.
+		WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);	// Write I2C control:
+		// abort any I2C
+		// activity.
+		MC_ENABLE(P_MC2, MC2_UPLD_IIC);	// Invoke command
+		// upload
+		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0) ;	// and wait for
+		// upload to
+		// complete.
+
+		// Per SAA7146 data sheet, write to STATUS reg twice to reset all
+		// I2C error flags.
+		for (i = 0; i < 2; i++) {
+			WR7146(P_I2CSTAT, I2C_CLKSEL);	// Write I2C control: reset
+			// error flags.
+			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	// Invoke command upload
+			while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;	//   and wait for
+			//   upload to
+			//   complete.
+		}
+
+		// Init audio interface functional attributes: set DAC/ADC serial
+		// clock rates, invert DAC serial clock so that DAC data setup
+		// times are satisfied, enable DAC serial clock out.
+		WR7146(P_ACON2, ACON2_INIT);
+
+		// Set up TSL1 slot list, which is used to control the
+		// accumulation of ADC data: RSD1 = shift data in on SD1.  SIB_A1
+		// = store data uint8_t at next available location in FB BUFFER1
+		// register.
+		WR7146(P_TSL1, RSD1 | SIB_A1);	// Fetch ADC high data
+		// uint8_t.
+		WR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);	// Fetch ADC low data
+		// uint8_t; end of
+		// TSL1.
+
+		// enab TSL1 slot list so that it executes all the time.
+		WR7146(P_ACON1, ACON1_ADCSTART);
+
+		// Initialize RPS registers used for ADC.
+
+		//Physical start of RPS program.
+		WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
+
+		WR7146(P_RPSPAGE1, 0);	// RPS program performs no
+		// explicit mem writes.
+		WR7146(P_RPS1_TOUT, 0);	// Disable RPS timeouts.
+
+		// SAA7146 BUG WORKAROUND.  Initialize SAA7146 ADC interface to a
+		// known state by invoking ADCs until FB BUFFER 1 register shows
+		// that it is correctly receiving ADC data.  This is necessary
+		// because the SAA7146 ADC interface does not start up in a
+		// defined state after a PCI reset.
+
+/*     PollList = EOPL;			// Create a simple polling */
+/* 					// list for analog input */
+/* 					// channel 0. */
+/*     ResetADC( dev, &PollList ); */
+
+/*     s626_ai_rinsn(dev,dev->subdevices,NULL,data); //( &AdcData ); // */
+/* 						  //Get initial ADC */
+/* 						  //value. */
+
+/*     StartVal = data[0]; */
+
+/*     // VERSION 2.01 CHANGE: TIMEOUT ADDED TO PREVENT HANGED EXECUTION. */
+/*     // Invoke ADCs until the new ADC value differs from the initial */
+/*     // value or a timeout occurs.  The timeout protects against the */
+/*     // possibility that the driver is restarting and the ADC data is a */
+/*     // fixed value resulting from the applied ADC analog input being */
+/*     // unusually quiet or at the rail. */
+
+/*     for ( index = 0; index < 500; index++ ) */
+/*       { */
+/* 	s626_ai_rinsn(dev,dev->subdevices,NULL,data); */
+/* 	AdcData = data[0];	//ReadADC(  &AdcData ); */
+/* 	if ( AdcData != StartVal ) */
+/* 	  break; */
+/*       } */
+
+		// end initADC
+
+		// init the DAC interface
+
+		// Init Audio2's output DMAC attributes: burst length = 1 DWORD,
+		// threshold = 1 DWORD.
+		WR7146(P_PCI_BT_A, 0);
+
+		// Init Audio2's output DMA physical addresses.  The protection
+		// address is set to 1 DWORD past the base address so that a
+		// single DWORD will be transferred each time a DMA transfer is
+		// enabled.
+
+		pPhysBuf =
+			devpriv->ANABuf.PhysicalBase +
+			(DAC_WDMABUF_OS * sizeof(uint32_t));
+
+		WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	// Buffer base adrs.
+		WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	// Protection address.
+
+		// Cache Audio2's output DMA buffer logical address.  This is
+		// where DAC data is buffered for A2 output DMA transfers.
+		devpriv->pDacWBuf =
+			(uint32_t *) devpriv->ANABuf.LogicalBase +
+			DAC_WDMABUF_OS;
+
+		// Audio2's output channels does not use paging.  The protection
+		// violation handling bit is set so that the DMAC will
+		// automatically halt and its PCI address pointer will be reset
+		// when the protection address is reached.
+		WR7146(P_PAGEA2_OUT, 8);
+
+		// Initialize time slot list 2 (TSL2), which is used to control
+		// the clock generation for and serialization of data to be sent
+		// to the DAC devices.  Slot 0 is a NOP that is used to trap TSL
+		// execution; this permits other slots to be safely modified
+		// without first turning off the TSL sequencer (which is
+		// apparently impossible to do).  Also, SD3 (which is driven by a
+		// pull-up resistor) is shifted in and stored to the MSB of
+		// FB_BUFFER2 to be used as evidence that the slot sequence has
+		// not yet finished executing.
+		SETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);	// Slot 0: Trap TSL
+		// execution, shift 0xFF
+		// into FB_BUFFER2.
+
+		// Initialize slot 1, which is constant.  Slot 1 causes a DWORD to
+		// be transferred from audio channel 2's output FIFO to the FIFO's
+		// output buffer so that it can be serialized and sent to the DAC
+		// during subsequent slots.  All remaining slots are dynamically
+		// populated as required by the target DAC device.
+		SETVECT(1, LF_A2);	// Slot 1: Fetch DWORD from Audio2's
+		// output FIFO.
+
+		// Start DAC's audio interface (TSL2) running.
+		WR7146(P_ACON1, ACON1_DACSTART);
+
+		////////////////////////////////////////////////////////
+
+		// end init DAC interface
+
+		// Init Trim DACs to calibrated values.  Do it twice because the
+		// SAA7146 audio channel does not always reset properly and
+		// sometimes causes the first few TrimDAC writes to malfunction.
+
+		LoadTrimDACs(dev);
+		LoadTrimDACs(dev);	// Insurance.
+
+		//////////////////////////////////////////////////////////////////
+		// Manually init all gate array hardware in case this is a soft
+		// reset (we have no way of determining whether this is a warm or
+		// cold start).  This is necessary because the gate array will
+		// reset only in response to a PCI hard reset; there is no soft
+		// reset function.
+
+		// Init all DAC outputs to 0V and init all DAC setpoint and
+		// polarity images.
+		for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
+			SetDAC(dev, chan, 0);
+
+		// Init image of WRMISC2 Battery Charger Enabled control bit.
+		// This image is used when the state of the charger control bit,
+		// which has no direct hardware readback mechanism, is queried.
+		devpriv->ChargeEnabled = 0;
+
+		// Init image of watchdog timer interval in WRMISC2.  This image
+		// maintains the value of the control bits of MISC2 are
+		// continuously reset to zero as long as the WD timer is disabled.
+		devpriv->WDInterval = 0;
+
+		// Init Counter Interrupt enab mask for RDMISC2.  This mask is
+		// applied against MISC2 when testing to determine which timer
+		// events are requesting interrupt service.
+		devpriv->CounterIntEnabs = 0;
+
+		// Init counters.
+		CountersInit(dev);
+
+		// Without modifying the state of the Battery Backup enab, disable
+		// the watchdog timer, set DIO channels 0-5 to operate in the
+		// standard DIO (vs. counter overflow) mode, disable the battery
+		// charger, and reset the watchdog interval selector to zero.
+		WriteMISC2(dev, (uint16_t) (DEBIread(dev,
+					LP_RDMISC2) & MISC2_BATT_ENABLE));
+
+		// Initialize the digital I/O subsystem.
+		s626_dio_init(dev);
+
+		//enable interrupt test
+		// writel(IRQ_GPIO3 | IRQ_RPS1,devpriv->base_addr+P_IER);
+	}
+
+	DEBUG("s626_attach: comedi%d s626 attached %04x\n", dev->minor,
+		(uint32_t) devpriv->base_addr);
+
+	return 1;
+}
+
+static lsampl_t s626_ai_reg_to_uint(int data)
+{
+	lsampl_t tempdata;
+
+	tempdata = (data >> 18);
+	if (tempdata & 0x2000)
+		tempdata &= 0x1fff;
+	else
+		tempdata += (1 << 13);
+
+	return tempdata;
+}
+
+/* static lsampl_t s626_uint_to_reg(comedi_subdevice *s, int data){ */
+/*   return 0; */
+/* } */
+
+static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
+{
+	comedi_device *dev = d;
+	comedi_subdevice *s;
+	comedi_cmd *cmd;
+	enc_private *k;
+	unsigned long flags;
+	int32_t *readaddr;
+	uint32_t irqtype, irqstatus;
+	int i = 0;
+	sampl_t tempdata;
+	uint8_t group;
+	uint16_t irqbit;
+
+	DEBUG("s626_irq_handler: interrupt request recieved!!!\n");
+
+	if (dev->attached == 0)
+		return IRQ_NONE;
+	// lock to avoid race with comedi_poll
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+
+	//save interrupt enable register state
+	irqstatus = readl(devpriv->base_addr + P_IER);
+
+	//read interrupt type
+	irqtype = readl(devpriv->base_addr + P_ISR);
+
+	//disable master interrupt
+	writel(0, devpriv->base_addr + P_IER);
+
+	//clear interrupt
+	writel(irqtype, devpriv->base_addr + P_ISR);
+
+	//do somethings
+	DEBUG("s626_irq_handler: interrupt type %d\n", irqtype);
+
+	switch (irqtype) {
+	case IRQ_RPS1:		// end_of_scan occurs
+
+		DEBUG("s626_irq_handler: RPS1 irq detected\n");
+
+		// manage ai subdevice
+		s = dev->subdevices;
+		cmd = &(s->async->cmd);
+
+		// Init ptr to DMA buffer that holds new ADC data.  We skip the
+		// first uint16_t in the buffer because it contains junk data from
+		// the final ADC of the previous poll list scan.
+		readaddr = (int32_t *) devpriv->ANABuf.LogicalBase + 1;
+
+		// get the data and hand it over to comedi
+		for (i = 0; i < (s->async->cmd.chanlist_len); i++) {
+			// Convert ADC data to 16-bit integer values and copy to application
+			// buffer.
+			tempdata = s626_ai_reg_to_uint((int)*readaddr);
+			readaddr++;
+
+			//put data into read buffer
+			// comedi_buf_put(s->async, tempdata);
+			if (cfc_write_to_buffer(s, tempdata) == 0)
+				printk("s626_irq_handler: cfc_write_to_buffer error!\n");
+
+			DEBUG("s626_irq_handler: ai channel %d acquired: %d\n",
+				i, tempdata);
+		}
+
+		//end of scan occurs
+		s->async->events |= COMEDI_CB_EOS;
+
+		if (!(devpriv->ai_continous))
+			devpriv->ai_sample_count--;
+		if (devpriv->ai_sample_count <= 0) {
+			devpriv->ai_cmd_running = 0;
+
+			// Stop RPS program.
+			MC_DISABLE(P_MC1, MC1_ERPS1);
+
+			//send end of acquisition
+			s->async->events |= COMEDI_CB_EOA;
+
+			//disable master interrupt
+			irqstatus = 0;
+		}
+
+		if (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT) {
+			DEBUG("s626_irq_handler: enable interrupt on dio channel %d\n", cmd->scan_begin_arg);
+
+			s626_dio_set_irq(dev, cmd->scan_begin_arg);
+
+			DEBUG("s626_irq_handler: External trigger is set!!!\n");
+		}
+		// tell comedi that data is there
+		DEBUG("s626_irq_handler: events %d\n", s->async->events);
+		comedi_event(dev, s);
+		break;
+	case IRQ_GPIO3:	//check dio and conter interrupt
+
+		DEBUG("s626_irq_handler: GPIO3 irq detected\n");
+
+		// manage ai subdevice
+		s = dev->subdevices;
+		cmd = &(s->async->cmd);
+
+		//s626_dio_clear_irq(dev);
+
+		for (group = 0; group < S626_DIO_BANKS; group++) {
+			irqbit = 0;
+			//read interrupt type
+			irqbit = DEBIread(dev,
+				((dio_private *) (dev->subdevices + 2 +
+						group)->private)->RDCapFlg);
+
+			//check if interrupt is generated from dio channels
+			if (irqbit) {
+				s626_dio_reset_irq(dev, group, irqbit);
+				DEBUG("s626_irq_handler: check interrupt on dio group %d %d\n", group, i);
+				if (devpriv->ai_cmd_running) {
+					//check if interrupt is an ai acquisition start trigger
+					if ((irqbit >> (cmd->start_arg -
+								(16 * group)))
+						== 1
+						&& cmd->start_src == TRIG_EXT) {
+						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->start_arg);
+
+						// Start executing the RPS program.
+						MC_ENABLE(P_MC1, MC1_ERPS1);
+
+						DEBUG("s626_irq_handler: aquisition start triggered!!!\n");
+
+						if (cmd->scan_begin_src ==
+							TRIG_EXT) {
+							DEBUG("s626_ai_cmd: enable interrupt on dio channel %d\n", cmd->scan_begin_arg);
+
+							s626_dio_set_irq(dev,
+								cmd->
+								scan_begin_arg);
+
+							DEBUG("s626_irq_handler: External scan trigger is set!!!\n");
+						}
+					}
+					if ((irqbit >> (cmd->scan_begin_arg -
+								(16 * group)))
+						== 1
+						&& cmd->scan_begin_src ==
+						TRIG_EXT) {
+						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->scan_begin_arg);
+
+						// Trigger ADC scan loop start by setting RPS Signal 0.
+						MC_ENABLE(P_MC2, MC2_ADC_RPS);
+
+						DEBUG("s626_irq_handler: scan triggered!!! %d\n", devpriv->ai_sample_count);
+						if (cmd->convert_src ==
+							TRIG_EXT) {
+
+							DEBUG("s626_ai_cmd: enable interrupt on dio channel %d group %d\n", cmd->convert_arg - (16 * group), group);
+
+							devpriv->
+								ai_convert_count
+								=
+								cmd->
+								chanlist_len;
+
+							s626_dio_set_irq(dev,
+								cmd->
+								convert_arg);
+
+							DEBUG("s626_irq_handler: External convert trigger is set!!!\n");
+						}
+
+						if (cmd->convert_src ==
+							TRIG_TIMER) {
+							k = &encpriv[5];
+							devpriv->
+								ai_convert_count
+								=
+								cmd->
+								chanlist_len;
+							k->SetEnable(dev, k,
+								CLKENAB_ALWAYS);
+						}
+					}
+					if ((irqbit >> (cmd->convert_arg -
+								(16 * group)))
+						== 1
+						&& cmd->convert_src ==
+						TRIG_EXT) {
+						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->convert_arg);
+
+						// Trigger ADC scan loop start by setting RPS Signal 0.
+						MC_ENABLE(P_MC2, MC2_ADC_RPS);
+
+						DEBUG("s626_irq_handler: adc convert triggered!!!\n");
+
+						devpriv->ai_convert_count--;
+
+						if (devpriv->ai_convert_count >
+							0) {
+
+							DEBUG("s626_ai_cmd: enable interrupt on dio channel %d group %d\n", cmd->convert_arg - (16 * group), group);
+
+							s626_dio_set_irq(dev,
+								cmd->
+								convert_arg);
+
+							DEBUG("s626_irq_handler: External trigger is set!!!\n");
+						}
+					}
+				}
+				break;
+			}
+		}
+
+		//read interrupt type
+		irqbit = DEBIread(dev, LP_RDMISC2);
+
+		//check interrupt on counters
+		DEBUG("s626_irq_handler: check counters interrupt %d\n",
+			irqbit);
+
+		if (irqbit & IRQ_COINT1A) {
+			DEBUG("s626_irq_handler: interrupt on counter 1A overflow\n");
+			k = &encpriv[0];
+
+			//clear interrupt capture flag
+			k->ResetCapFlags(dev, k);
+		}
+		if (irqbit & IRQ_COINT2A) {
+			DEBUG("s626_irq_handler: interrupt on counter 2A overflow\n");
+			k = &encpriv[1];
+
+			//clear interrupt capture flag
+			k->ResetCapFlags(dev, k);
+		}
+		if (irqbit & IRQ_COINT3A) {
+			DEBUG("s626_irq_handler: interrupt on counter 3A overflow\n");
+			k = &encpriv[2];
+
+			//clear interrupt capture flag
+			k->ResetCapFlags(dev, k);
+		}
+		if (irqbit & IRQ_COINT1B) {
+			DEBUG("s626_irq_handler: interrupt on counter 1B overflow\n");
+			k = &encpriv[3];
+
+			//clear interrupt capture flag
+			k->ResetCapFlags(dev, k);
+		}
+		if (irqbit & IRQ_COINT2B) {
+			DEBUG("s626_irq_handler: interrupt on counter 2B overflow\n");
+			k = &encpriv[4];
+
+			//clear interrupt capture flag
+			k->ResetCapFlags(dev, k);
+
+			if (devpriv->ai_convert_count > 0) {
+				devpriv->ai_convert_count--;
+				if (devpriv->ai_convert_count == 0)
+					k->SetEnable(dev, k, CLKENAB_INDEX);
+
+				if (cmd->convert_src == TRIG_TIMER) {
+					DEBUG("s626_irq_handler: conver timer trigger!!! %d\n", devpriv->ai_convert_count);
+
+					// Trigger ADC scan loop start by setting RPS Signal 0.
+					MC_ENABLE(P_MC2, MC2_ADC_RPS);
+				}
+			}
+		}
+		if (irqbit & IRQ_COINT3B) {
+			DEBUG("s626_irq_handler: interrupt on counter 3B overflow\n");
+			k = &encpriv[5];
+
+			//clear interrupt capture flag
+			k->ResetCapFlags(dev, k);
+
+			if (cmd->scan_begin_src == TRIG_TIMER) {
+				DEBUG("s626_irq_handler: scan timer trigger!!!\n");
+
+				// Trigger ADC scan loop start by setting RPS Signal 0.
+				MC_ENABLE(P_MC2, MC2_ADC_RPS);
+			}
+
+			if (cmd->convert_src == TRIG_TIMER) {
+				DEBUG("s626_irq_handler: convert timer trigger is set\n");
+				k = &encpriv[4];
+				devpriv->ai_convert_count = cmd->chanlist_len;
+				k->SetEnable(dev, k, CLKENAB_ALWAYS);
+			}
+		}
+	}
+
+	//enable interrupt
+	writel(irqstatus, devpriv->base_addr + P_IER);
+
+	DEBUG("s626_irq_handler: exit interrupt service routine.\n");
+
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	return IRQ_HANDLED;
+}
+
+static int s626_detach(comedi_device * dev)
+{
+	if (devpriv) {
+		//stop ai_command
+		devpriv->ai_cmd_running = 0;
+
+		if (devpriv->base_addr) {
+			//interrupt mask
+			WR7146(P_IER, 0);	// Disable master interrupt.
+			WR7146(P_ISR, IRQ_GPIO3 | IRQ_RPS1);	// Clear board's IRQ status flag.
+
+			// Disable the watchdog timer and battery charger.
+			WriteMISC2(dev, 0);
+
+			// Close all interfaces on 7146 device.
+			WR7146(P_MC1, MC1_SHUTDOWN);
+			WR7146(P_ACON1, ACON1_BASE);
+
+			CloseDMAB(dev, &devpriv->RPSBuf, DMABUF_SIZE);
+			CloseDMAB(dev, &devpriv->ANABuf, DMABUF_SIZE);
+		}
+
+		if (dev->irq) {
+			comedi_free_irq(dev->irq, dev);
+		}
+
+		if (devpriv->base_addr) {
+			iounmap(devpriv->base_addr);
+		}
+
+		if (devpriv->pdev) {
+			if (devpriv->got_regions) {
+				comedi_pci_disable(devpriv->pdev);
+			}
+			pci_dev_put(devpriv->pdev);
+		}
+	}
+
+	DEBUG("s626_detach: S626 detached!\n");
+
+	return 0;
+}
+
+/*
+ * this functions build the RPS program for hardware driven acquistion
+ */
+void ResetADC(comedi_device * dev, uint8_t * ppl)
+{
+	register uint32_t *pRPS;
+	uint32_t JmpAdrs;
+	uint16_t i;
+	uint16_t n;
+	uint32_t LocalPPL;
+	comedi_cmd *cmd = &(dev->subdevices->async->cmd);
+
+	// Stop RPS program in case it is currently running.
+	MC_DISABLE(P_MC1, MC1_ERPS1);
+
+	// Set starting logical address to write RPS commands.
+	pRPS = (uint32_t *) devpriv->RPSBuf.LogicalBase;
+
+	// Initialize RPS instruction pointer.
+	WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
+
+	// Construct RPS program in RPSBuf DMA buffer
+
+	if (cmd != NULL && cmd->scan_begin_src != TRIG_FOLLOW) {
+		DEBUG("ResetADC: scan_begin pause inserted\n");
+		// Wait for Start trigger.
+		*pRPS++ = RPS_PAUSE | RPS_SIGADC;
+		*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
+	}
+	// SAA7146 BUG WORKAROUND Do a dummy DEBI Write.  This is necessary
+	// because the first RPS DEBI Write following a non-RPS DEBI write
+	// seems to always fail.  If we don't do this dummy write, the ADC
+	// gain might not be set to the value required for the first slot in
+	// the poll list; the ADC gain would instead remain unchanged from
+	// the previously programmed value.
+	*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	// Write DEBI Write command
+	// and address to shadow RAM.
+	*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
+	*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	// Write DEBI immediate data
+	// to shadow RAM:
+	*pRPS++ = GSEL_BIPOLAR5V;	// arbitrary immediate data
+	// value.
+	*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	// Reset "shadow RAM
+	// uploaded" flag.
+	*pRPS++ = RPS_UPLOAD | RPS_DEBI;	// Invoke shadow RAM upload.
+	*pRPS++ = RPS_PAUSE | RPS_DEBI;	// Wait for shadow upload to finish.
+
+	// Digitize all slots in the poll list. This is implemented as a
+	// for loop to limit the slot count to 16 in case the application
+	// forgot to set the EOPL flag in the final slot.
+	for (devpriv->AdcItems = 0; devpriv->AdcItems < 16; devpriv->AdcItems++) {
+		// Convert application's poll list item to private board class
+		// format.  Each app poll list item is an uint8_t with form
+		// (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
+		// +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
+		LocalPPL =
+			(*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
+			GSEL_BIPOLAR10V);
+
+		// Switch ADC analog gain.
+		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	// Write DEBI command
+		// and address to
+		// shadow RAM.
+		*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
+		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	// Write DEBI
+		// immediate data to
+		// shadow RAM.
+		*pRPS++ = LocalPPL;
+		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	// Reset "shadow RAM uploaded"
+		// flag.
+		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	// Invoke shadow RAM upload.
+		*pRPS++ = RPS_PAUSE | RPS_DEBI;	// Wait for shadow upload to
+		// finish.
+
+		// Select ADC analog input channel.
+		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	// Write DEBI command
+		// and address to
+		// shadow RAM.
+		*pRPS++ = DEBI_CMD_WRWORD | LP_ISEL;
+		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	// Write DEBI
+		// immediate data to
+		// shadow RAM.
+		*pRPS++ = LocalPPL;
+		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	// Reset "shadow RAM uploaded"
+		// flag.
+		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	// Invoke shadow RAM upload.
+		*pRPS++ = RPS_PAUSE | RPS_DEBI;	// Wait for shadow upload to
+		// finish.
+
+		// Delay at least 10 microseconds for analog input settling.
+		// Instead of padding with NOPs, we use RPS_JUMP instructions
+		// here; this allows us to produce a longer delay than is
+		// possible with NOPs because each RPS_JUMP flushes the RPS'
+		// instruction prefetch pipeline.
+		JmpAdrs =
+			(uint32_t) devpriv->RPSBuf.PhysicalBase +
+			(uint32_t) ((unsigned long)pRPS -
+			(unsigned long)devpriv->RPSBuf.LogicalBase);
+		for (i = 0; i < (10 * RPSCLK_PER_US / 2); i++) {
+			JmpAdrs += 8;	// Repeat to implement time delay:
+			*pRPS++ = RPS_JUMP;	// Jump to next RPS instruction.
+			*pRPS++ = JmpAdrs;
+		}
+
+		if (cmd != NULL && cmd->convert_src != TRIG_NOW) {
+			DEBUG("ResetADC: convert pause inserted\n");
+			// Wait for Start trigger.
+			*pRPS++ = RPS_PAUSE | RPS_SIGADC;
+			*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
+		}
+		// Start ADC by pulsing GPIO1.
+		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	// Begin ADC Start pulse.
+		*pRPS++ = GPIO_BASE | GPIO1_LO;
+		*pRPS++ = RPS_NOP;
+		// VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE.
+		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	// End ADC Start pulse.
+		*pRPS++ = GPIO_BASE | GPIO1_HI;
+
+		// Wait for ADC to complete (GPIO2 is asserted high when ADC not
+		// busy) and for data from previous conversion to shift into FB
+		// BUFFER 1 register.
+		*pRPS++ = RPS_PAUSE | RPS_GPIO2;	// Wait for ADC done.
+
+		// Transfer ADC data from FB BUFFER 1 register to DMA buffer.
+		*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
+		*pRPS++ =
+			(uint32_t) devpriv->ANABuf.PhysicalBase +
+			(devpriv->AdcItems << 2);
+
+		// If this slot's EndOfPollList flag is set, all channels have
+		// now been processed.
+		if (*ppl++ & EOPL) {
+			devpriv->AdcItems++;	// Adjust poll list item count.
+			break;	// Exit poll list processing loop.
+		}
+	}
+	DEBUG("ResetADC: ADC items %d \n", devpriv->AdcItems);
+
+	// VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
+	// ADC to stabilize for 2 microseconds before starting the final
+	// (dummy) conversion.  This delay is necessary to allow sufficient
+	// time between last conversion finished and the start of the dummy
+	// conversion.  Without this delay, the last conversion's data value
+	// is sometimes set to the previous conversion's data value.
+	for (n = 0; n < (2 * RPSCLK_PER_US); n++)
+		*pRPS++ = RPS_NOP;
+
+	// Start a dummy conversion to cause the data from the last
+	// conversion of interest to be shifted in.
+	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	// Begin ADC Start pulse.
+	*pRPS++ = GPIO_BASE | GPIO1_LO;
+	*pRPS++ = RPS_NOP;
+	// VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE.
+	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	// End ADC Start pulse.
+	*pRPS++ = GPIO_BASE | GPIO1_HI;
+
+	// Wait for the data from the last conversion of interest to arrive
+	// in FB BUFFER 1 register.
+	*pRPS++ = RPS_PAUSE | RPS_GPIO2;	// Wait for ADC done.
+
+	// Transfer final ADC data from FB BUFFER 1 register to DMA buffer.
+	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);	//
+	*pRPS++ =
+		(uint32_t) devpriv->ANABuf.PhysicalBase +
+		(devpriv->AdcItems << 2);
+
+	// Indicate ADC scan loop is finished.
+	// *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC ;  // Signal ReadADC() that scan is done.
+
+	//invoke interrupt
+	if (devpriv->ai_cmd_running == 1) {
+		DEBUG("ResetADC: insert irq in ADC RPS task\n");
+		*pRPS++ = RPS_IRQ;
+	}
+	// Restart RPS program at its beginning.
+	*pRPS++ = RPS_JUMP;	// Branch to start of RPS program.
+	*pRPS++ = (uint32_t) devpriv->RPSBuf.PhysicalBase;
+
+	// End of RPS program build
+	// ------------------------------------------------------------
+}
+
+/* TO COMPLETE, IF NECESSARY */
+static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+
+	return -EINVAL;
+}
+
+/* static int s626_ai_rinsn(comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,lsampl_t *data) */
+/* { */
+/*   register uint8_t	i; */
+/*   register int32_t	*readaddr; */
+
+/*   DEBUG("as626_ai_rinsn: ai_rinsn enter \n");  */
+
+/*   // Trigger ADC scan loop start by setting RPS Signal 0. */
+/*   MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
+
+/*   // Wait until ADC scan loop is finished (RPS Signal 0 reset). */
+/*   while ( MC_TEST( P_MC2, MC2_ADC_RPS ) ); */
+
+/*   // Init ptr to DMA buffer that holds new ADC data.  We skip the */
+/*   // first uint16_t in the buffer because it contains junk data from */
+/*   // the final ADC of the previous poll list scan. */
+/*   readaddr = (uint32_t *)devpriv->ANABuf.LogicalBase + 1; */
+
+/*   // Convert ADC data to 16-bit integer values and copy to application */
+/*   // buffer.	 */
+/*   for ( i = 0; i < devpriv->AdcItems; i++ ) { */
+/*     *data = s626_ai_reg_to_uint( *readaddr++ ); */
+/*     DEBUG("s626_ai_rinsn: data %d \n",*data); */
+/*     data++; */
+/*   } */
+
+/*   DEBUG("s626_ai_rinsn: ai_rinsn escape \n"); */
+/*   return i; */
+/* } */
+
+static int s626_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	uint16_t chan = CR_CHAN(insn->chanspec);
+	uint16_t range = CR_RANGE(insn->chanspec);
+	uint16_t AdcSpec = 0;
+	uint32_t GpioImage;
+	int n;
+
+/*   //interrupt call test  */
+/*   writel(IRQ_GPIO3,devpriv->base_addr+P_PSR); //Writing a logical 1 */
+/* 					     //into any of the RPS_PSR */
+/* 					     //bits causes the */
+/* 					     //corresponding interrupt */
+/* 					     //to be generated if */
+/* 					     //enabled */
+
+	DEBUG("s626_ai_insn_read: entering\n");
+
+	// Convert application's ADC specification into form
+	// appropriate for register programming.
+	if (range == 0)
+		AdcSpec = (chan << 8) | (GSEL_BIPOLAR5V);
+	else
+		AdcSpec = (chan << 8) | (GSEL_BIPOLAR10V);
+
+	// Switch ADC analog gain.
+	DEBIwrite(dev, LP_GSEL, AdcSpec);	// Set gain.
+
+	// Select ADC analog input channel.
+	DEBIwrite(dev, LP_ISEL, AdcSpec);	// Select channel.
+
+	for (n = 0; n < insn->n; n++) {
+
+		// Delay 10 microseconds for analog input settling.
+		comedi_udelay(10);
+
+		// Start ADC by pulsing GPIO1 low.
+		GpioImage = RR7146(P_GPIO);
+		// Assert ADC Start command
+		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
+		//   and stretch it out.
+		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
+		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
+		// Negate ADC Start command.
+		WR7146(P_GPIO, GpioImage | GPIO1_HI);
+
+		// Wait for ADC to complete (GPIO2 is asserted high when
+		// ADC not busy) and for data from previous conversion to
+		// shift into FB BUFFER 1 register.
+
+		// Wait for ADC done.
+		while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
+
+		// Fetch ADC data.
+		if (n != 0)
+			data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
+
+		// Allow the ADC to stabilize for 4 microseconds before
+		// starting the next (final) conversion.  This delay is
+		// necessary to allow sufficient time between last
+		// conversion finished and the start of the next
+		// conversion.  Without this delay, the last conversion's
+		// data value is sometimes set to the previous
+		// conversion's data value.
+		comedi_udelay(4);
+	}
+
+	// Start a dummy conversion to cause the data from the
+	// previous conversion to be shifted in.
+	GpioImage = RR7146(P_GPIO);
+
+	//Assert ADC Start command
+	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
+	//   and stretch it out.
+	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
+	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
+	// Negate ADC Start command.
+	WR7146(P_GPIO, GpioImage | GPIO1_HI);
+
+	// Wait for the data to arrive in FB BUFFER 1 register.
+
+	// Wait for ADC done.
+	while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
+
+	// Fetch ADC data from audio interface's input shift
+	// register.
+
+	// Fetch ADC data.
+	if (n != 0)
+		data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
+
+	DEBUG("s626_ai_insn_read: samples %d, data %d\n", n, data[n - 1]);
+
+	return n;
+}
+
+static int s626_ai_load_polllist(uint8_t * ppl, comedi_cmd * cmd)
+{
+
+	int n;
+
+	for (n = 0; n < cmd->chanlist_len; n++) {
+		if (CR_RANGE((cmd->chanlist)[n]) == 0)
+			ppl[n] = (CR_CHAN((cmd->chanlist)[n])) | (RANGE_5V);
+		else
+			ppl[n] = (CR_CHAN((cmd->chanlist)[n])) | (RANGE_10V);
+	}
+	ppl[n - 1] |= EOPL;
+
+	return n;
+}
+
+static int s626_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum)
+{
+	if (trignum != 0)
+		return -EINVAL;
+
+	DEBUG("s626_ai_inttrig: trigger adc start...");
+
+	// Start executing the RPS program.
+	MC_ENABLE(P_MC1, MC1_ERPS1);
+
+	s->async->inttrig = NULL;
+
+	DEBUG(" done\n");
+
+	return 1;
+}
+
+/*  TO COMPLETE  */
+static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+
+	uint8_t ppl[16];
+	comedi_cmd *cmd = &s->async->cmd;
+	enc_private *k;
+	int tick;
+
+	DEBUG("s626_ai_cmd: entering command function\n");
+
+	if (devpriv->ai_cmd_running) {
+		printk("s626_ai_cmd: Another ai_cmd is running %d\n",
+			dev->minor);
+		return -EBUSY;
+	}
+	//disable interrupt
+	writel(0, devpriv->base_addr + P_IER);
+
+	//clear interrupt request
+	writel(IRQ_RPS1 | IRQ_GPIO3, devpriv->base_addr + P_ISR);
+
+	//clear any pending interrupt
+	s626_dio_clear_irq(dev);
+	//  s626_enc_clear_irq(dev);
+
+	//reset ai_cmd_running flag
+	devpriv->ai_cmd_running = 0;
+
+	// test if cmd is valid
+	if (cmd == NULL) {
+		DEBUG("s626_ai_cmd: NULL command\n");
+		return -EINVAL;
+	} else {
+		DEBUG("s626_ai_cmd: command recieved!!!\n");
+	}
+
+	if (dev->irq == 0) {
+		comedi_error(dev,
+			"s626_ai_cmd: cannot run command without an irq");
+		return -EIO;
+	}
+
+	s626_ai_load_polllist(ppl, cmd);
+	devpriv->ai_cmd_running = 1;
+	devpriv->ai_convert_count = 0;
+
+	switch (cmd->scan_begin_src) {
+	case TRIG_FOLLOW:
+		break;
+	case TRIG_TIMER:
+		// set a conter to generate adc trigger at scan_begin_arg interval
+		k = &encpriv[5];
+		tick = s626_ns_to_timer((int *)&cmd->scan_begin_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+
+		//load timer value and enable interrupt
+		s626_timer_load(dev, k, tick);
+		k->SetEnable(dev, k, CLKENAB_ALWAYS);
+
+		DEBUG("s626_ai_cmd: scan trigger timer is set with value %d\n",
+			tick);
+
+		break;
+	case TRIG_EXT:
+		// set the digital line and interrupt for scan trigger
+		if (cmd->start_src != TRIG_EXT)
+			s626_dio_set_irq(dev, cmd->scan_begin_arg);
+
+		DEBUG("s626_ai_cmd: External scan trigger is set!!!\n");
+
+		break;
+	}
+
+	switch (cmd->convert_src) {
+	case TRIG_NOW:
+		break;
+	case TRIG_TIMER:
+		// set a conter to generate adc trigger at convert_arg interval
+		k = &encpriv[4];
+		tick = s626_ns_to_timer((int *)&cmd->convert_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+
+		//load timer value and enable interrupt
+		s626_timer_load(dev, k, tick);
+		k->SetEnable(dev, k, CLKENAB_INDEX);
+
+		DEBUG("s626_ai_cmd: convert trigger timer is set with value %d\n", tick);
+		break;
+	case TRIG_EXT:
+		// set the digital line and interrupt for convert trigger
+		if (cmd->scan_begin_src != TRIG_EXT
+			&& cmd->start_src == TRIG_EXT)
+			s626_dio_set_irq(dev, cmd->convert_arg);
+
+		DEBUG("s626_ai_cmd: External convert trigger is set!!!\n");
+
+		break;
+	}
+
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		// data arrives as one packet
+		devpriv->ai_sample_count = cmd->stop_arg;
+		devpriv->ai_continous = 0;
+		break;
+	case TRIG_NONE:
+		// continous aquisition
+		devpriv->ai_continous = 1;
+		devpriv->ai_sample_count = 0;
+		break;
+	}
+
+	ResetADC(dev, ppl);
+
+	switch (cmd->start_src) {
+	case TRIG_NOW:
+		// Trigger ADC scan loop start by setting RPS Signal 0.
+		// MC_ENABLE( P_MC2, MC2_ADC_RPS );
+
+		// Start executing the RPS program.
+		MC_ENABLE(P_MC1, MC1_ERPS1);
+
+		DEBUG("s626_ai_cmd: ADC triggered\n");
+		s->async->inttrig = NULL;
+		break;
+	case TRIG_EXT:
+		//configure DIO channel for acquisition trigger
+		s626_dio_set_irq(dev, cmd->start_arg);
+
+		DEBUG("s626_ai_cmd: External start trigger is set!!!\n");
+
+		s->async->inttrig = NULL;
+		break;
+	case TRIG_INT:
+		s->async->inttrig = s626_ai_inttrig;
+		break;
+	}
+
+	//enable interrupt
+	writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->base_addr + P_IER);
+
+	DEBUG("s626_ai_cmd: command function terminated\n");
+
+	return 0;
+}
+
+static int s626_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+
+	/* cmdtest tests a particular command to see if it is valid.  Using
+	 * the cmdtest ioctl, a user can create a valid cmd and then have it
+	 * executes by the cmd ioctl.
+	 *
+	 * cmdtest returns 1,2,3,4 or 0, depending on which tests the
+	 * command passes. */
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_INT | TRIG_EXT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_TIMER | TRIG_EXT | TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually
+	   compatible */
+
+	/* note that mutual compatiblity is not an issue here */
+	if (cmd->scan_begin_src != TRIG_TIMER &&
+		cmd->scan_begin_src != TRIG_EXT
+		&& cmd->scan_begin_src != TRIG_FOLLOW)
+		err++;
+	if (cmd->convert_src != TRIG_TIMER &&
+		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_src != TRIG_EXT && cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	if (cmd->start_src == TRIG_EXT && cmd->start_arg < 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	if (cmd->start_src == TRIG_EXT && cmd->start_arg > 39) {
+		cmd->start_arg = 39;
+		err++;
+	}
+
+	if (cmd->scan_begin_src == TRIG_EXT && cmd->scan_begin_arg < 0) {
+		cmd->scan_begin_arg = 0;
+		err++;
+	}
+
+	if (cmd->scan_begin_src == TRIG_EXT && cmd->scan_begin_arg > 39) {
+		cmd->scan_begin_arg = 39;
+		err++;
+	}
+
+	if (cmd->convert_src == TRIG_EXT && cmd->convert_arg < 0) {
+		cmd->convert_arg = 0;
+		err++;
+	}
+
+	if (cmd->convert_src == TRIG_EXT && cmd->convert_arg > 39) {
+		cmd->convert_arg = 39;
+		err++;
+	}
+#define MAX_SPEED	200000	/* in nanoseconds */
+#define MIN_SPEED	2000000000	/* in nanoseconds */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		if (cmd->scan_begin_arg < MAX_SPEED) {
+			cmd->scan_begin_arg = MAX_SPEED;
+			err++;
+		}
+		if (cmd->scan_begin_arg > MIN_SPEED) {
+			cmd->scan_begin_arg = MIN_SPEED;
+			err++;
+		}
+	} else {
+		/* external trigger */
+		/* should be level/edge, hi/lo specification here */
+		/* should specify multiple external triggers */
+/*     if(cmd->scan_begin_arg>9){ */
+/*       cmd->scan_begin_arg=9; */
+/*       err++; */
+/*     } */
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg < MAX_SPEED) {
+			cmd->convert_arg = MAX_SPEED;
+			err++;
+		}
+		if (cmd->convert_arg > MIN_SPEED) {
+			cmd->convert_arg = MIN_SPEED;
+			err++;
+		}
+	} else {
+		/* external trigger */
+		/* see above */
+/*     if(cmd->convert_arg>9){ */
+/*       cmd->convert_arg=9; */
+/*       err++; */
+/*     } */
+	}
+
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_COUNT) {
+		if (cmd->stop_arg > 0x00ffffff) {
+			cmd->stop_arg = 0x00ffffff;
+			err++;
+		}
+	} else {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		tmp = cmd->scan_begin_arg;
+		s626_ns_to_timer((int *)&cmd->scan_begin_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->scan_begin_arg)
+			err++;
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		tmp = cmd->convert_arg;
+		s626_ns_to_timer((int *)&cmd->convert_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->convert_arg)
+			err++;
+		if (cmd->scan_begin_src == TRIG_TIMER &&
+			cmd->scan_begin_arg <
+			cmd->convert_arg * cmd->scan_end_arg) {
+			cmd->scan_begin_arg =
+				cmd->convert_arg * cmd->scan_end_arg;
+			err++;
+		}
+	}
+
+	if (err)
+		return 4;
+
+	return 0;
+}
+
+static int s626_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	// Stop RPS program in case it is currently running.
+	MC_DISABLE(P_MC1, MC1_ERPS1);
+
+	//disable master interrupt
+	writel(0, devpriv->base_addr + P_IER);
+
+	devpriv->ai_cmd_running = 0;
+
+	return 0;
+}
+
+/* This function doesn't require a particular form, this is just what
+ * happens to be used in some of the drivers.  It should convert ns
+ * nanoseconds to a counter value suitable for programming the device.
+ * Also, it should adjust ns so that it cooresponds to the actual time
+ * that the device will use. */
+static int s626_ns_to_timer(int *nanosec, int round_mode)
+{
+	int divider, base;
+
+	base = 500;		//2MHz internal clock
+
+	switch (round_mode) {
+	case TRIG_ROUND_NEAREST:
+	default:
+		divider = (*nanosec + base / 2) / base;
+		break;
+	case TRIG_ROUND_DOWN:
+		divider = (*nanosec) / base;
+		break;
+	case TRIG_ROUND_UP:
+		divider = (*nanosec + base - 1) / base;
+		break;
+	}
+
+	*nanosec = base * divider;
+	return divider - 1;
+}
+
+static int s626_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+
+	int i;
+	uint16_t chan = CR_CHAN(insn->chanspec);
+	int16_t dacdata;
+
+	for (i = 0; i < insn->n; i++) {
+		dacdata = (int16_t) data[i];
+		devpriv->ao_readback[CR_CHAN(insn->chanspec)] = data[i];
+		dacdata -= (0x1fff);
+
+		SetDAC(dev, chan, dacdata);
+	}
+
+	return i;
+}
+
+static int s626_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i;
+
+	for (i = 0; i < insn->n; i++) {
+		data[i] = devpriv->ao_readback[CR_CHAN(insn->chanspec)];
+	}
+
+	return i;
+}
+
+/////////////////////////////////////////////////////////////////////
+///////////////  DIGITAL I/O FUNCTIONS  /////////////////////////////
+/////////////////////////////////////////////////////////////////////
+// All DIO functions address a group of DIO channels by means of
+// "group" argument.  group may be 0, 1 or 2, which correspond to DIO
+// ports A, B and C, respectively.
+/////////////////////////////////////////////////////////////////////
+
+static void s626_dio_init(comedi_device * dev)
+{
+	uint16_t group;
+	comedi_subdevice *s;
+
+	// Prepare to treat writes to WRCapSel as capture disables.
+	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
+
+	// For each group of sixteen channels ...
+	for (group = 0; group < S626_DIO_BANKS; group++) {
+		s = dev->subdevices + 2 + group;
+		DEBIwrite(dev, diopriv->WRIntSel, 0);	// Disable all interrupts.
+		DEBIwrite(dev, diopriv->WRCapSel, 0xFFFF);	// Disable all event
+		// captures.
+		DEBIwrite(dev, diopriv->WREdgSel, 0);	// Init all DIOs to
+		// default edge
+		// polarity.
+		DEBIwrite(dev, diopriv->WRDOut, 0);	// Program all outputs
+		// to inactive state.
+	}
+	DEBUG("s626_dio_init: DIO initialized \n");
+}
+
+/* DIO devices are slightly special.  Although it is possible to
+ * implement the insn_read/insn_write interface, it is much more
+ * useful to applications if you implement the insn_bits interface.
+ * This allows packed reading/writing of the DIO channels.  The comedi
+ * core can convert between insn_bits and insn_read/write */
+
+static int s626_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+
+	/* Length of data must be 2 (mask and new data, see below) */
+	if (insn->n == 0) {
+		return 0;
+	}
+	if (insn->n != 2) {
+		printk("comedi%d: s626: s626_dio_insn_bits(): Invalid instruction length\n", dev->minor);
+		return -EINVAL;
+	}
+
+	/*
+	 * The insn data consists of a mask in data[0] and the new data in
+	 * data[1]. The mask defines which bits we are concerning about.
+	 * The new data must be anded with the mask.  Each channel
+	 * corresponds to a bit.
+	 */
+	if (data[0]) {
+		/* Check if requested ports are configured for output */
+		if ((s->io_bits & data[0]) != data[0])
+			return -EIO;
+
+		s->state &= ~data[0];
+		s->state |= data[0] & data[1];
+
+		/* Write out the new digital output lines */
+
+		DEBIwrite(dev, diopriv->WRDOut, s->state);
+	}
+	data[1] = DEBIread(dev, diopriv->RDDIn);
+
+	return 2;
+}
+
+static int s626_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] =
+			(s->io_bits & (1 << CR_CHAN(insn->
+					chanspec))) ? COMEDI_OUTPUT :
+			COMEDI_INPUT;
+		return insn->n;
+		break;
+	case COMEDI_INPUT:
+		s->io_bits &= ~(1 << CR_CHAN(insn->chanspec));
+		break;
+	case COMEDI_OUTPUT:
+		s->io_bits |= 1 << CR_CHAN(insn->chanspec);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	DEBIwrite(dev, diopriv->WRDOut, s->io_bits);
+
+	return 1;
+}
+
+static int s626_dio_set_irq(comedi_device * dev, unsigned int chan)
+{
+	unsigned int group;
+	unsigned int bitmask;
+	unsigned int status;
+
+	//select dio bank
+	group = chan / 16;
+	bitmask = 1 << (chan - (16 * group));
+	DEBUG("s626_dio_set_irq: enable interrupt on dio channel %d group %d\n",
+		chan - (16 * group), group);
+
+	//set channel to capture positive edge
+	status = DEBIread(dev,
+		((dio_private *) (dev->subdevices + 2 +
+				group)->private)->RDEdgSel);
+	DEBIwrite(dev,
+		((dio_private *) (dev->subdevices + 2 +
+				group)->private)->WREdgSel, bitmask | status);
+
+	//enable interrupt on selected channel
+	status = DEBIread(dev,
+		((dio_private *) (dev->subdevices + 2 +
+				group)->private)->RDIntSel);
+	DEBIwrite(dev,
+		((dio_private *) (dev->subdevices + 2 +
+				group)->private)->WRIntSel, bitmask | status);
+
+	//enable edge capture write command
+	DEBIwrite(dev, LP_MISC1, MISC1_EDCAP);
+
+	//enable edge capture on selected channel
+	status = DEBIread(dev,
+		((dio_private *) (dev->subdevices + 2 +
+				group)->private)->RDCapSel);
+	DEBIwrite(dev,
+		((dio_private *) (dev->subdevices + 2 +
+				group)->private)->WRCapSel, bitmask | status);
+
+	return 0;
+}
+
+static int s626_dio_reset_irq(comedi_device * dev, unsigned int group,
+	unsigned int mask)
+{
+	DEBUG("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n", mask, group);
+
+	//disable edge capture write command
+	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
+
+	//enable edge capture on selected channel
+	DEBIwrite(dev,
+		((dio_private *) (dev->subdevices + 2 +
+				group)->private)->WRCapSel, mask);
+
+	return 0;
+}
+
+static int s626_dio_clear_irq(comedi_device * dev)
+{
+	unsigned int group;
+
+	//disable edge capture write command
+	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
+
+	for (group = 0; group < S626_DIO_BANKS; group++) {
+		//clear pending events and interrupt
+		DEBIwrite(dev,
+			((dio_private *) (dev->subdevices + 2 +
+					group)->private)->WRCapSel, 0xffff);
+	}
+
+	return 0;
+}
+
+/* Now this function initializes the value of the counter (data[0])
+   and set the subdevice. To complete with trigger and interrupt
+   configuration */
+static int s626_enc_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	// Preload upon
+		// index.
+		(INDXSRC_SOFT << BF_INDXSRC) |	// Disable hardware index.
+		(CLKSRC_COUNTER << BF_CLKSRC) |	// Operating mode is Counter.
+		(CLKPOL_POS << BF_CLKPOL) |	// Active high clock.
+		//( CNTDIR_UP << BF_CLKPOL ) |      // Count direction is Down.
+		(CLKMULT_1X << BF_CLKMULT) |	// Clock multiplier is 1x.
+		(CLKENAB_INDEX << BF_CLKENAB);
+	/*   uint16_t DisableIntSrc=TRUE; */
+	// uint32_t Preloadvalue;              //Counter initial value
+	uint16_t valueSrclatch = LATCHSRC_AB_READ;
+	uint16_t enab = CLKENAB_ALWAYS;
+	enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
+
+	DEBUG("s626_enc_insn_config: encoder config\n");
+
+	//  (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]);
+
+	k->SetMode(dev, k, Setup, TRUE);
+	Preload(dev, k, *(insn->data));
+	k->PulseIndex(dev, k);
+	SetLatchSource(dev, k, valueSrclatch);
+	k->SetEnable(dev, k, (uint16_t) (enab != 0));
+
+	return insn->n;
+}
+
+static int s626_enc_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+
+	int n;
+	enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
+
+	DEBUG("s626_enc_insn_read: encoder read channel %d \n",
+		CR_CHAN(insn->chanspec));
+
+	for (n = 0; n < insn->n; n++)
+		data[n] = ReadLatch(dev, k);
+
+	DEBUG("s626_enc_insn_read: encoder sample %d\n", data[n]);
+
+	return n;
+}
+
+static int s626_enc_insn_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+
+	enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
+
+	DEBUG("s626_enc_insn_write: encoder write channel %d \n",
+		CR_CHAN(insn->chanspec));
+
+	// Set the preload register
+	Preload(dev, k, data[0]);
+
+	// Software index pulse forces the preload register to load
+	// into the counter
+	k->SetLoadTrig(dev, k, 0);
+	k->PulseIndex(dev, k);
+	k->SetLoadTrig(dev, k, 2);
+
+	DEBUG("s626_enc_insn_write: End encoder write\n");
+
+	return 1;
+}
+
+static void s626_timer_load(comedi_device * dev, enc_private * k, int tick)
+{
+	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	// Preload upon
+		// index.
+		(INDXSRC_SOFT << BF_INDXSRC) |	// Disable hardware index.
+		(CLKSRC_TIMER << BF_CLKSRC) |	// Operating mode is Timer.
+		(CLKPOL_POS << BF_CLKPOL) |	// Active high clock.
+		(CNTDIR_DOWN << BF_CLKPOL) |	// Count direction is Down.
+		(CLKMULT_1X << BF_CLKMULT) |	// Clock multiplier is 1x.
+		(CLKENAB_INDEX << BF_CLKENAB);
+	uint16_t valueSrclatch = LATCHSRC_A_INDXA;
+	//  uint16_t enab=CLKENAB_ALWAYS;
+
+	k->SetMode(dev, k, Setup, FALSE);
+
+	// Set the preload register
+	Preload(dev, k, tick);
+
+	// Software index pulse forces the preload register to load
+	// into the counter
+	k->SetLoadTrig(dev, k, 0);
+	k->PulseIndex(dev, k);
+
+	//set reload on counter overflow
+	k->SetLoadTrig(dev, k, 1);
+
+	//set interrupt on overflow
+	k->SetIntSrc(dev, k, INTSRC_OVER);
+
+	SetLatchSource(dev, k, valueSrclatch);
+	//  k->SetEnable(dev,k,(uint16_t)(enab != 0));
+}
+
+///////////////////////////////////////////////////////////////////////
+/////////////////////  DAC FUNCTIONS /////////////////////////////////
+///////////////////////////////////////////////////////////////////////
+
+// Slot 0 base settings.
+#define VECT0	( XSD2 | RSD3 | SIB_A2 )	// Slot 0 always shifts in
+					 // 0xFF and store it to
+					 // FB_BUFFER2.
+
+// TrimDac LogicalChan-to-PhysicalChan mapping table.
+static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
+
+// TrimDac LogicalChan-to-EepromAdrs mapping table.
+static uint8_t trimadrs[] =
+	{ 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
+
+static void LoadTrimDACs(comedi_device * dev)
+{
+	register uint8_t i;
+
+	// Copy TrimDac setpoint values from EEPROM to TrimDacs.
+	for (i = 0; i < (sizeof(trimchan) / sizeof(trimchan[0])); i++)
+		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
+}
+
+static void WriteTrimDAC(comedi_device * dev, uint8_t LogicalChan,
+	uint8_t DacData)
+{
+	uint32_t chan;
+
+	// Save the new setpoint in case the application needs to read it back later.
+	devpriv->TrimSetpoint[LogicalChan] = (uint8_t) DacData;
+
+	// Map logical channel number to physical channel number.
+	chan = (uint32_t) trimchan[LogicalChan];
+
+	// Set up TSL2 records for TrimDac write operation.  All slots shift
+	// 0xFF in from pulled-up SD3 so that the end of the slot sequence
+	// can be detected.
+	SETVECT(2, XSD2 | XFIFO_1 | WS3);	// Slot 2: Send high uint8_t
+	// to target TrimDac.
+	SETVECT(3, XSD2 | XFIFO_0 | WS3);	// Slot 3: Send low uint8_t to
+	// target TrimDac.
+	SETVECT(4, XSD2 | XFIFO_3 | WS1);	// Slot 4: Send NOP high
+	// uint8_t to DAC0 to keep
+	// clock running.
+	SETVECT(5, XSD2 | XFIFO_2 | WS1 | EOS);	// Slot 5: Send NOP low
+	// uint8_t to DAC0.
+
+	// Construct and transmit target DAC's serial packet: ( 0000 AAAA
+	// ),( DDDD DDDD ),( 0x00 ),( 0x00 ) where A<3:0> is the DAC
+	// channel's address, and D<7:0> is the DAC setpoint.  Append a WORD
+	// value (that writes a channel 0 NOP command to a non-existent main
+	// DAC channel) that serves to keep the clock running after the
+	// packet has been sent to the target DAC.
+
+	SendDAC(dev, ((uint32_t) chan << 8)	// Address the DAC channel
+		// within the trimdac device.
+		| (uint32_t) DacData);	// Include DAC setpoint data.
+}
+
+/////////////////////////////////////////////////////////////////////////
+////////////////  EEPROM ACCESS FUNCTIONS  //////////////////////////////
+/////////////////////////////////////////////////////////////////////////
+
+///////////////////////////////////////////
+// Read uint8_t from EEPROM.
+
+static uint8_t I2Cread(comedi_device * dev, uint8_t addr)
+{
+	uint8_t rtnval;
+
+	// Send EEPROM target address.
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)	// Byte2 = I2C
+			// command:
+			// write to
+			// I2C EEPROM
+			// device.
+			| I2C_B1(I2C_ATTRSTOP, addr)	// Byte1 = EEPROM
+			// internal target
+			// address.
+			| I2C_B0(I2C_ATTRNOP, 0)))	// Byte0 = Not
+		// sent.
+	{
+		// Abort function and declare error if handshake failed.
+		DEBUG("I2Cread: error handshake I2Cread  a\n");
+		return 0;
+	}
+	// Execute EEPROM read.
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)	// Byte2 = I2C
+			// command: read
+			// from I2C EEPROM
+			// device.
+			| I2C_B1(I2C_ATTRSTOP, 0)	// Byte1 receives
+			// uint8_t from
+			// EEPROM.
+			| I2C_B0(I2C_ATTRNOP, 0)))	// Byte0 = Not
+		// sent.
+	{
+		// Abort function and declare error if handshake failed.
+		DEBUG("I2Cread: error handshake I2Cread b\n");
+		return 0;
+	}
+	// Return copy of EEPROM value.
+	rtnval = (uint8_t) (RR7146(P_I2CCTRL) >> 16);
+	return rtnval;
+}
+
+static uint32_t I2Chandshake(comedi_device * dev, uint32_t val)
+{
+	// Write I2C command to I2C Transfer Control shadow register.
+	WR7146(P_I2CCTRL, val);
+
+	// Upload I2C shadow registers into working registers and wait for
+	// upload confirmation.
+
+	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
+	while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;
+
+	// Wait until I2C bus transfer is finished or an error occurs.
+	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY) ;
+
+	// Return non-zero if I2C error occured.
+	return RR7146(P_I2CCTRL) & I2C_ERR;
+
+}
+
+// Private helper function: Write setpoint to an application DAC channel.
+
+static void SetDAC(comedi_device * dev, uint16_t chan, short dacdata)
+{
+	register uint16_t signmask;
+	register uint32_t WSImage;
+
+	// Adjust DAC data polarity and set up Polarity Control Register
+	// image.
+	signmask = 1 << chan;
+	if (dacdata < 0) {
+		dacdata = -dacdata;
+		devpriv->Dacpol |= signmask;
+	} else
+		devpriv->Dacpol &= ~signmask;
+
+	// Limit DAC setpoint value to valid range.
+	if ((uint16_t) dacdata > 0x1FFF)
+		dacdata = 0x1FFF;
+
+	// Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
+	// and V3 transmit the setpoint to the target DAC.  V4 and V5 send
+	// data to a non-existent TrimDac channel just to keep the clock
+	// running after sending data to the target DAC.  This is necessary
+	// to eliminate the clock glitch that would otherwise occur at the
+	// end of the target DAC's serial data stream.  When the sequence
+	// restarts at V0 (after executing V5), the gate array automatically
+	// disables gating for the DAC clock and all DAC chip selects.
+	WSImage = (chan & 2) ? WS1 : WS2;	// Choose DAC chip select to
+	// be asserted.
+	SETVECT(2, XSD2 | XFIFO_1 | WSImage);	// Slot 2: Transmit high
+	// data byte to target DAC.
+	SETVECT(3, XSD2 | XFIFO_0 | WSImage);	// Slot 3: Transmit low data
+	// byte to target DAC.
+	SETVECT(4, XSD2 | XFIFO_3 | WS3);	// Slot 4: Transmit to
+	// non-existent TrimDac
+	// channel to keep clock
+	SETVECT(5, XSD2 | XFIFO_2 | WS3 | EOS);	// Slot 5: running after
+	// writing target DAC's
+	// low data byte.
+
+	// Construct and transmit target DAC's serial packet: ( A10D DDDD
+	// ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan<0>, and D<12:0>
+	// is the DAC setpoint.  Append a WORD value (that writes to a
+	// non-existent TrimDac channel) that serves to keep the clock
+	// running after the packet has been sent to the target DAC.
+	SendDAC(dev, 0x0F000000	//Continue clock after target DAC
+		//data (write to non-existent
+		//trimdac).
+		| 0x00004000	// Address the two main dual-DAC
+		// devices (TSL's chip select enables
+		// target device).
+		| ((uint32_t) (chan & 1) << 15)	// Address the DAC
+		// channel within the
+		// device.
+		| (uint32_t) dacdata);	// Include DAC setpoint data.
+
+}
+
+////////////////////////////////////////////////////////
+// Private helper function: Transmit serial data to DAC via Audio
+// channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
+// Dacpol contains valid target image.
+
+static void SendDAC(comedi_device * dev, uint32_t val)
+{
+
+	// START THE SERIAL CLOCK RUNNING -------------
+
+	// Assert DAC polarity control and enable gating of DAC serial clock
+	// and audio bit stream signals.  At this point in time we must be
+	// assured of being in time slot 0.  If we are not in slot 0, the
+	// serial clock and audio stream signals will be disabled; this is
+	// because the following DEBIwrite statement (which enables signals
+	// to be passed through the gate array) would execute before the
+	// trailing edge of WS1/WS3 (which turns off the signals), thus
+	// causing the signals to be inactive during the DAC write.
+	DEBIwrite(dev, LP_DACPOL, devpriv->Dacpol);
+
+	// TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ----------------
+
+	// Copy DAC setpoint value to DAC's output DMA buffer.
+
+	//WR7146( (uint32_t)devpriv->pDacWBuf, val );
+	*devpriv->pDacWBuf = val;
+
+	// enab the output DMA transfer.  This will cause the DMAC to copy
+	// the DAC's data value to A2's output FIFO.  The DMA transfer will
+	// then immediately terminate because the protection address is
+	// reached upon transfer of the first DWORD value.
+	MC_ENABLE(P_MC1, MC1_A2OUT);
+
+	// While the DMA transfer is executing ...
+
+	// Reset Audio2 output FIFO's underflow flag (along with any other
+	// FIFO underflow/overflow flags).  When set, this flag will
+	// indicate that we have emerged from slot 0.
+	WR7146(P_ISR, ISR_AFOU);
+
+	// Wait for the DMA transfer to finish so that there will be data
+	// available in the FIFO when time slot 1 tries to transfer a DWORD
+	// from the FIFO to the output buffer register.  We test for DMA
+	// Done by polling the DMAC enable flag; this flag is automatically
+	// cleared when the transfer has finished.
+	while ((RR7146(P_MC1) & MC1_A2OUT) != 0) ;
+
+	// START THE OUTPUT STREAM TO THE TARGET DAC --------------------
+
+	// FIFO data is now available, so we enable execution of time slots
+	// 1 and higher by clearing the EOS flag in slot 0.  Note that SD3
+	// will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
+	// detection.
+	SETVECT(0, XSD2 | RSD3 | SIB_A2);
+
+	// Wait for slot 1 to execute to ensure that the Packet will be
+	// transmitted.  This is detected by polling the Audio2 output FIFO
+	// underflow flag, which will be set when slot 1 execution has
+	// finished transferring the DAC's data DWORD from the output FIFO
+	// to the output buffer register.
+	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0) ;
+
+	// Set up to trap execution at slot 0 when the TSL sequencer cycles
+	// back to slot 0 after executing the EOS in slot 5.  Also,
+	// simultaneously shift out and in the 0x00 that is ALWAYS the value
+	// stored in the last byte to be shifted out of the FIFO's DWORD
+	// buffer register.
+	SETVECT(0, XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS);
+
+	// WAIT FOR THE TRANSACTION TO FINISH -----------------------
+
+	// Wait for the TSL to finish executing all time slots before
+	// exiting this function.  We must do this so that the next DAC
+	// write doesn't start, thereby enabling clock/chip select signals:
+	// 1. Before the TSL sequence cycles back to slot 0, which disables
+	// the clock/cs signal gating and traps slot // list execution.  If
+	// we have not yet finished slot 5 then the clock/cs signals are
+	// still gated and we have // not finished transmitting the stream.
+	// 2. While slots 2-5 are executing due to a late slot 0 trap.  In
+	// this case, the slot sequence is currently // repeating, but with
+	// clock/cs signals disabled.  We must wait for slot 0 to trap
+	// execution before setting // up the next DAC setpoint DMA transfer
+	// and enabling the clock/cs signals.  To detect the end of slot 5,
+	// we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
+	// the TSL has not yet finished executing slot 5 ...
+	if ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) {
+		// The trap was set on time and we are still executing somewhere
+		// in slots 2-5, so we now wait for slot 0 to execute and trap
+		// TSL execution.  This is detected when FB_BUFFER2 MSB changes
+		// from 0xFF to 0x00, which slot 0 causes to happen by shifting
+		// out/in on SD2 the 0x00 that is always referenced by slot 5.
+		while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) ;
+	}
+	// Either (1) we were too late setting the slot 0 trap; the TSL
+	// sequencer restarted slot 0 before we could set the EOS trap flag,
+	// or (2) we were not late and execution is now trapped at slot 0.
+	// In either case, we must now change slot 0 so that it will store
+	// value 0xFF (instead of 0x00) to FB_BUFFER2 next time it executes.
+	// In order to do this, we reprogram slot 0 so that it will shift in
+	// SD3, which is driven only by a pull-up resistor.
+	SETVECT(0, RSD3 | SIB_A2 | EOS);
+
+	// Wait for slot 0 to execute, at which time the TSL is setup for
+	// the next DAC write.  This is detected when FB_BUFFER2 MSB changes
+	// from 0x00 to 0xFF.
+	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0) ;
+}
+
+static void WriteMISC2(comedi_device * dev, uint16_t NewImage)
+{
+	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	// enab writes to
+	// MISC2 register.
+	DEBIwrite(dev, LP_WRMISC2, NewImage);	// Write new image to MISC2.
+	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE);	// Disable writes to MISC2.
+}
+
+/////////////////////////////////////////////////////////////////////
+// Initialize the DEBI interface for all transfers.
+
+static uint16_t DEBIread(comedi_device * dev, uint16_t addr)
+{
+	uint16_t retval;
+
+	// Set up DEBI control register value in shadow RAM.
+	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
+
+	// Execute the DEBI transfer.
+	DEBItransfer(dev);
+
+	// Fetch target register value.
+	retval = (uint16_t) RR7146(P_DEBIAD);
+
+	// Return register value.
+	return retval;
+}
+
+// Execute a DEBI transfer.  This must be called from within a
+// critical section.
+static void DEBItransfer(comedi_device * dev)
+{
+	// Initiate upload of shadow RAM to DEBI control register.
+	MC_ENABLE(P_MC2, MC2_UPLD_DEBI);
+
+	// Wait for completion of upload from shadow RAM to DEBI control
+	// register.
+	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI)) ;
+
+	// Wait until DEBI transfer is done.
+	while (RR7146(P_PSR) & PSR_DEBI_S) ;
+}
+
+// Write a value to a gate array register.
+static void DEBIwrite(comedi_device * dev, uint16_t addr, uint16_t wdata)
+{
+
+	// Set up DEBI control register value in shadow RAM.
+	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
+	WR7146(P_DEBIAD, wdata);
+
+	// Execute the DEBI transfer.
+	DEBItransfer(dev);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Replace the specified bits in a gate array register.  Imports: mask
+// specifies bits that are to be preserved, wdata is new value to be
+// or'd with the masked original.
+static void DEBIreplace(comedi_device * dev, uint16_t addr, uint16_t mask,
+	uint16_t wdata)
+{
+
+	// Copy target gate array register into P_DEBIAD register.
+	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);	// Set up DEBI control
+	// reg value in shadow
+	// RAM.
+	DEBItransfer(dev);	// Execute the DEBI
+	// Read transfer.
+
+	// Write back the modified image.
+	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);	// Set up DEBI control
+	// reg value in shadow
+	// RAM.
+
+	WR7146(P_DEBIAD, wdata | ((uint16_t) RR7146(P_DEBIAD) & mask));	// Modify the register image.
+	DEBItransfer(dev);	// Execute the DEBI Write transfer.
+}
+
+static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize)
+{
+	void *vbptr;
+	dma_addr_t vpptr;
+
+	DEBUG("CloseDMAB: Entering S626DRV_CloseDMAB():\n");
+	if (pdma == NULL)
+		return;
+	//find the matching allocation from the board struct
+
+	vbptr = pdma->LogicalBase;
+	vpptr = pdma->PhysicalBase;
+	if (vbptr) {
+		pci_free_consistent(devpriv->pdev, bsize, vbptr, vpptr);
+		pdma->LogicalBase = 0;
+		pdma->PhysicalBase = 0;
+
+		DEBUG("CloseDMAB(): Logical=%p, bsize=%d, Physical=0x%x\n",
+			vbptr, bsize, (uint32_t) vpptr);
+	}
+}
+
+////////////////////////////////////////////////////////////////////////
+/////////////////  COUNTER FUNCTIONS  //////////////////////////////////
+////////////////////////////////////////////////////////////////////////
+// All counter functions address a specific counter by means of the
+// "Counter" argument, which is a logical counter number.  The Counter
+// argument may have any of the following legal values: 0=0A, 1=1A,
+// 2=2A, 3=0B, 4=1B, 5=2B.
+////////////////////////////////////////////////////////////////////////
+
+// Forward declarations for functions that are common to both A and B
+// counters:
+
+/////////////////////////////////////////////////////////////////////
+//////////////////// PRIVATE COUNTER FUNCTIONS  /////////////////////
+/////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////
+// Read a counter's output latch.
+
+static uint32_t ReadLatch(comedi_device * dev, enc_private * k)
+{
+	register uint32_t value;
+	//DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n");
+
+	// Latch counts and fetch LSW of latched counts value.
+	value = (uint32_t) DEBIread(dev, k->MyLatchLsw);
+
+	// Fetch MSW of latched counts and combine with LSW.
+	value |= ((uint32_t) DEBIread(dev, k->MyLatchLsw + 2) << 16);
+
+	// DEBUG FIXME DEBUG("ReadLatch: Read Latch exit\n");
+
+	// Return latched counts.
+	return value;
+}
+
+///////////////////////////////////////////////////////////////////
+// Reset a counter's index and overflow event capture flags.
+
+static void ResetCapFlags_A(comedi_device * dev, enc_private * k)
+{
+	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
+		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+}
+
+static void ResetCapFlags_B(comedi_device * dev, enc_private * k)
+{
+	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
+		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
+}
+
+/////////////////////////////////////////////////////////////////////////
+// Return counter setup in a format (COUNTER_SETUP) that is consistent
+// for both A and B counters.
+
+static uint16_t GetMode_A(comedi_device * dev, enc_private * k)
+{
+	register uint16_t cra;
+	register uint16_t crb;
+	register uint16_t setup;
+
+	// Fetch CRA and CRB register images.
+	cra = DEBIread(dev, k->MyCRA);
+	crb = DEBIread(dev, k->MyCRB);
+
+	// Populate the standardized counter setup bit fields.  Note:
+	// IndexSrc is restricted to ENC_X or IndxPol.
+	setup = ((cra & STDMSK_LOADSRC)	// LoadSrc  = LoadSrcA.
+		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	// LatchSrc = LatchSrcA.
+		| ((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) & STDMSK_INTSRC)	// IntSrc   = IntSrcA.
+		| ((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) & STDMSK_INDXSRC)	// IndxSrc  = IndxSrcA<1>.
+		| ((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) & STDMSK_INDXPOL)	// IndxPol  = IndxPolA.
+		| ((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) & STDMSK_CLKENAB));	// ClkEnab  = ClkEnabA.
+
+	// Adjust mode-dependent parameters.
+	if (cra & (2 << CRABIT_CLKSRC_A))	// If Timer mode (ClkSrcA<1> == 1):
+		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	//   Indicate Timer mode.
+			| ((cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) & STDMSK_CLKPOL)	//   Set ClkPol to indicate count direction (ClkSrcA<0>).
+			| (MULT_X1 << STDBIT_CLKMULT));	//   ClkMult must be 1x in Timer mode.
+
+	else			// If Counter mode (ClkSrcA<1> == 0):
+		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	//   Indicate Counter mode.
+			| ((cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) & STDMSK_CLKPOL)	//   Pass through ClkPol.
+			| (((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A)) ?	//   Force ClkMult to 1x if not legal, else pass through.
+				(MULT_X1 << STDBIT_CLKMULT) :
+				((cra >> (CRABIT_CLKMULT_A -
+							STDBIT_CLKMULT)) &
+					STDMSK_CLKMULT)));
+
+	// Return adjusted counter setup.
+	return setup;
+}
+
+static uint16_t GetMode_B(comedi_device * dev, enc_private * k)
+{
+	register uint16_t cra;
+	register uint16_t crb;
+	register uint16_t setup;
+
+	// Fetch CRA and CRB register images.
+	cra = DEBIread(dev, k->MyCRA);
+	crb = DEBIread(dev, k->MyCRB);
+
+	// Populate the standardized counter setup bit fields.  Note:
+	// IndexSrc is restricted to ENC_X or IndxPol.
+	setup = (((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) & STDMSK_INTSRC)	// IntSrc   = IntSrcB.
+		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	// LatchSrc = LatchSrcB.
+		| ((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) & STDMSK_LOADSRC)	// LoadSrc  = LoadSrcB.
+		| ((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) & STDMSK_INDXPOL)	// IndxPol  = IndxPolB.
+		| ((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) & STDMSK_CLKENAB)	// ClkEnab  = ClkEnabB.
+		| ((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) & STDMSK_INDXSRC));	// IndxSrc  = IndxSrcB<1>.
+
+	// Adjust mode-dependent parameters.
+	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B))	// If Extender mode (ClkMultB == MULT_X0):
+		setup |= ((CLKSRC_EXTENDER << STDBIT_CLKSRC)	//   Indicate Extender mode.
+			| (MULT_X1 << STDBIT_CLKMULT)	//   Indicate multiplier is 1x.
+			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	//   Set ClkPol equal to Timer count direction (ClkSrcB<0>).
+
+	else if (cra & (2 << CRABIT_CLKSRC_B))	// If Timer mode (ClkSrcB<1> == 1):
+		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	//   Indicate Timer mode.
+			| (MULT_X1 << STDBIT_CLKMULT)	//   Indicate multiplier is 1x.
+			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	//   Set ClkPol equal to Timer count direction (ClkSrcB<0>).
+
+	else			// If Counter mode (ClkSrcB<1> == 0):
+		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	//   Indicate Timer mode.
+			| ((crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) & STDMSK_CLKMULT)	//   Clock multiplier is passed through.
+			| ((crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) & STDMSK_CLKPOL));	//   Clock polarity is passed through.
+
+	// Return adjusted counter setup.
+	return setup;
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+// Set the operating mode for the specified counter.  The setup
+// parameter is treated as a COUNTER_SETUP data type.  The following
+// parameters are programmable (all other parms are ignored): ClkMult,
+// ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
+
+static void SetMode_A(comedi_device * dev, enc_private * k, uint16_t Setup,
+	uint16_t DisableIntSrc)
+{
+	register uint16_t cra;
+	register uint16_t crb;
+	register uint16_t setup = Setup;	// Cache the Standard Setup.
+
+	// Initialize CRA and CRB images.
+	cra = ((setup & CRAMSK_LOADSRC_A)	// Preload trigger is passed through.
+		| ((setup & STDMSK_INDXSRC) >> (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	// IndexSrc is restricted to ENC_X or IndxPol.
+
+	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A	// Reset any pending CounterA event captures.
+		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	// Clock enable is passed through.
+
+	// Force IntSrc to Disabled if DisableIntSrc is asserted.
+	if (!DisableIntSrc)
+		cra |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
+				CRABIT_INTSRC_A));
+
+	// Populate all mode-dependent attributes of CRA & CRB images.
+	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
+	case CLKSRC_EXTENDER:	// Extender Mode: Force to Timer mode
+		// (Extender valid only for B counters).
+
+	case CLKSRC_TIMER:	// Timer Mode:
+		cra |= ((2 << CRABIT_CLKSRC_A)	//   ClkSrcA<1> selects system clock
+			| ((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	//     with count direction (ClkSrcA<0>) obtained from ClkPol.
+			| (1 << CRABIT_CLKPOL_A)	//   ClkPolA behaves as always-on clock enable.
+			| (MULT_X1 << CRABIT_CLKMULT_A));	//   ClkMult must be 1x.
+		break;
+
+	default:		// Counter Mode:
+		cra |= (CLKSRC_COUNTER	//   Select ENC_C and ENC_D as clock/direction inputs.
+			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKPOL_A - STDBIT_CLKPOL))	//   Clock polarity is passed through.
+			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	//   Force multiplier to x1 if not legal, otherwise pass through.
+				(MULT_X1 << CRABIT_CLKMULT_A) :
+				((setup & STDMSK_CLKMULT) << (CRABIT_CLKMULT_A -
+						STDBIT_CLKMULT))));
+	}
+
+	// Force positive index polarity if IndxSrc is software-driven only,
+	// otherwise pass it through.
+	if (~setup & STDMSK_INDXSRC)
+		cra |= ((setup & STDMSK_INDXPOL) << (CRABIT_INDXPOL_A -
+				STDBIT_INDXPOL));
+
+	// If IntSrc has been forced to Disabled, update the MISC2 interrupt
+	// enable mask to indicate the counter interrupt is disabled.
+	if (DisableIntSrc)
+		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
+
+	// While retaining CounterB and LatchSrc configurations, program the
+	// new counter operating mode.
+	DEBIreplace(dev, k->MyCRA, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
+	DEBIreplace(dev, k->MyCRB,
+		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
+}
+
+static void SetMode_B(comedi_device * dev, enc_private * k, uint16_t Setup,
+	uint16_t DisableIntSrc)
+{
+	register uint16_t cra;
+	register uint16_t crb;
+	register uint16_t setup = Setup;	// Cache the Standard Setup.
+
+	// Initialize CRA and CRB images.
+	cra = ((setup & STDMSK_INDXSRC) << ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC));	// IndexSrc field is restricted to ENC_X or IndxPol.
+
+	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B	// Reset event captures and disable interrupts.
+		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	// Clock enable is passed through.
+		| ((setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	// Preload trigger source is passed through.
+
+	// Force IntSrc to Disabled if DisableIntSrc is asserted.
+	if (!DisableIntSrc)
+		crb |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
+				CRBBIT_INTSRC_B));
+
+	// Populate all mode-dependent attributes of CRA & CRB images.
+	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
+	case CLKSRC_TIMER:	// Timer Mode:
+		cra |= ((2 << CRABIT_CLKSRC_B)	//   ClkSrcB<1> selects system clock
+			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	//     with direction (ClkSrcB<0>) obtained from ClkPol.
+		crb |= ((1 << CRBBIT_CLKPOL_B)	//   ClkPolB behaves as always-on clock enable.
+			| (MULT_X1 << CRBBIT_CLKMULT_B));	//   ClkMultB must be 1x.
+		break;
+
+	case CLKSRC_EXTENDER:	// Extender Mode:
+		cra |= ((2 << CRABIT_CLKSRC_B)	//   ClkSrcB source is OverflowA (same as "timer")
+			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	//     with direction obtained from ClkPol.
+		crb |= ((1 << CRBBIT_CLKPOL_B)	//   ClkPolB controls IndexB -- always set to active.
+			| (MULT_X0 << CRBBIT_CLKMULT_B));	//   ClkMultB selects OverflowA as the clock source.
+		break;
+
+	default:		// Counter Mode:
+		cra |= (CLKSRC_COUNTER << CRABIT_CLKSRC_B);	//   Select ENC_C and ENC_D as clock/direction inputs.
+		crb |= (((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRBBIT_CLKPOL_B))	//   ClkPol is passed through.
+			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	//   Force ClkMult to x1 if not legal, otherwise pass through.
+				(MULT_X1 << CRBBIT_CLKMULT_B) :
+				((setup & STDMSK_CLKMULT) << (CRBBIT_CLKMULT_B -
+						STDBIT_CLKMULT))));
+	}
+
+	// Force positive index polarity if IndxSrc is software-driven only,
+	// otherwise pass it through.
+	if (~setup & STDMSK_INDXSRC)
+		crb |= ((setup & STDMSK_INDXPOL) >> (STDBIT_INDXPOL -
+				CRBBIT_INDXPOL_B));
+
+	// If IntSrc has been forced to Disabled, update the MISC2 interrupt
+	// enable mask to indicate the counter interrupt is disabled.
+	if (DisableIntSrc)
+		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
+
+	// While retaining CounterA and LatchSrc configurations, program the
+	// new counter operating mode.
+	DEBIreplace(dev, k->MyCRA,
+		(uint16_t) (~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B)), cra);
+	DEBIreplace(dev, k->MyCRB, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
+}
+
+////////////////////////////////////////////////////////////////////////
+// Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
+
+static void SetEnable_A(comedi_device * dev, enc_private * k, uint16_t enab)
+{
+	DEBUG("SetEnable_A: SetEnable_A enter 3541\n");
+	DEBIreplace(dev, k->MyCRB,
+		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)),
+		(uint16_t) (enab << CRBBIT_CLKENAB_A));
+}
+
+static void SetEnable_B(comedi_device * dev, enc_private * k, uint16_t enab)
+{
+	DEBIreplace(dev, k->MyCRB,
+		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),
+		(uint16_t) (enab << CRBBIT_CLKENAB_B));
+}
+
+static uint16_t GetEnable_A(comedi_device * dev, enc_private * k)
+{
+	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_A) & 1;
+}
+
+static uint16_t GetEnable_B(comedi_device * dev, enc_private * k)
+{
+	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_B) & 1;
+}
+
+////////////////////////////////////////////////////////////////////////
+// Return/set a counter pair's latch trigger source.  0: On read
+// access, 1: A index latches A, 2: B index latches B, 3: A overflow
+// latches B.
+
+static void SetLatchSource(comedi_device * dev, enc_private * k, uint16_t value)
+{
+	DEBUG("SetLatchSource: SetLatchSource enter 3550 \n");
+	DEBIreplace(dev, k->MyCRB,
+		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC)),
+		(uint16_t) (value << CRBBIT_LATCHSRC));
+
+	DEBUG("SetLatchSource: SetLatchSource exit \n");
+}
+
+/* static uint16_t GetLatchSource(comedi_device *dev, enc_private *k ) */
+/* { */
+/*   return ( DEBIread( dev, k->MyCRB) >> CRBBIT_LATCHSRC ) & 3; */
+/* } */
+
+/////////////////////////////////////////////////////////////////////////
+// Return/set the event that will trigger transfer of the preload
+// register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
+// 2=OverflowA (B counters only), 3=disabled.
+
+static void SetLoadTrig_A(comedi_device * dev, enc_private * k, uint16_t Trig)
+{
+	DEBIreplace(dev, k->MyCRA, (uint16_t) (~CRAMSK_LOADSRC_A),
+		(uint16_t) (Trig << CRABIT_LOADSRC_A));
+}
+
+static void SetLoadTrig_B(comedi_device * dev, enc_private * k, uint16_t Trig)
+{
+	DEBIreplace(dev, k->MyCRB,
+		(uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),
+		(uint16_t) (Trig << CRBBIT_LOADSRC_B));
+}
+
+static uint16_t GetLoadTrig_A(comedi_device * dev, enc_private * k)
+{
+	return (DEBIread(dev, k->MyCRA) >> CRABIT_LOADSRC_A) & 3;
+}
+
+static uint16_t GetLoadTrig_B(comedi_device * dev, enc_private * k)
+{
+	return (DEBIread(dev, k->MyCRB) >> CRBBIT_LOADSRC_B) & 3;
+}
+
+////////////////////
+// Return/set counter interrupt source and clear any captured
+// index/overflow events.  IntSource: 0=Disabled, 1=OverflowOnly,
+// 2=IndexOnly, 3=IndexAndOverflow.
+
+static void SetIntSrc_A(comedi_device * dev, enc_private * k,
+	uint16_t IntSource)
+{
+	// Reset any pending counter overflow or index captures.
+	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
+		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+
+	// Program counter interrupt source.
+	DEBIreplace(dev, k->MyCRA, ~CRAMSK_INTSRC_A,
+		(uint16_t) (IntSource << CRABIT_INTSRC_A));
+
+	// Update MISC2 interrupt enable mask.
+	devpriv->CounterIntEnabs =
+		(devpriv->CounterIntEnabs & ~k->MyEventBits[3]) | k->
+		MyEventBits[IntSource];
+}
+
+static void SetIntSrc_B(comedi_device * dev, enc_private * k,
+	uint16_t IntSource)
+{
+	uint16_t crb;
+
+	// Cache writeable CRB register image.
+	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;
+
+	// Reset any pending counter overflow or index captures.
+	DEBIwrite(dev, k->MyCRB,
+		(uint16_t) (crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
+
+	// Program counter interrupt source.
+	DEBIwrite(dev, k->MyCRB,
+		(uint16_t) ((crb & ~CRBMSK_INTSRC_B) | (IntSource <<
+				CRBBIT_INTSRC_B)));
+
+	// Update MISC2 interrupt enable mask.
+	devpriv->CounterIntEnabs =
+		(devpriv->CounterIntEnabs & ~k->MyEventBits[3]) | k->
+		MyEventBits[IntSource];
+}
+
+static uint16_t GetIntSrc_A(comedi_device * dev, enc_private * k)
+{
+	return (DEBIread(dev, k->MyCRA) >> CRABIT_INTSRC_A) & 3;
+}
+
+static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
+{
+	return (DEBIread(dev, k->MyCRB) >> CRBBIT_INTSRC_B) & 3;
+}
+
+/////////////////////////////////////////////////////////////////////////
+// Return/set the clock multiplier.
+
+/* static void SetClkMult(comedi_device *dev, enc_private *k, uint16_t value )  */
+/* { */
+/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKMULT ) | ( value << STDBIT_CLKMULT ) ), FALSE ); */
+/* } */
+
+/* static uint16_t GetClkMult(comedi_device *dev, enc_private *k )  */
+/* { */
+/*   return ( k->GetMode(dev, k ) >> STDBIT_CLKMULT ) & 3; */
+/* } */
+
+/* ////////////////////////////////////////////////////////////////////////// */
+/* // Return/set the clock polarity. */
+
+/* static void SetClkPol( comedi_device *dev,enc_private *k, uint16_t value )  */
+/* { */
+/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKPOL ) | ( value << STDBIT_CLKPOL ) ), FALSE ); */
+/* } */
+
+/* static uint16_t GetClkPol(comedi_device *dev, enc_private *k )  */
+/* { */
+/*   return ( k->GetMode(dev, k ) >> STDBIT_CLKPOL ) & 1; */
+/* } */
+
+/* /////////////////////////////////////////////////////////////////////// */
+/* // Return/set the clock source. */
+
+/* static void SetClkSrc( comedi_device *dev,enc_private *k, uint16_t value )  */
+/* { */
+/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_CLKSRC ) | ( value << STDBIT_CLKSRC ) ), FALSE ); */
+/* } */
+
+/* static uint16_t GetClkSrc( comedi_device *dev,enc_private *k )  */
+/* { */
+/*   return ( k->GetMode(dev, k ) >> STDBIT_CLKSRC ) & 3; */
+/* } */
+
+/* //////////////////////////////////////////////////////////////////////// */
+/* // Return/set the index polarity. */
+
+/* static void SetIndexPol(comedi_device *dev, enc_private *k, uint16_t value )  */
+/* { */
+/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_INDXPOL ) | ( (value != 0) << STDBIT_INDXPOL ) ), FALSE ); */
+/* } */
+
+/* static uint16_t GetIndexPol(comedi_device *dev, enc_private *k )  */
+/* { */
+/*   return ( k->GetMode(dev, k ) >> STDBIT_INDXPOL ) & 1; */
+/* } */
+
+/* //////////////////////////////////////////////////////////////////////// */
+/* // Return/set the index source. */
+
+/* static void SetIndexSrc(comedi_device *dev, enc_private *k, uint16_t value )  */
+/* { */
+/*   DEBUG("SetIndexSrc: set index src enter 3700\n"); */
+/*   k->SetMode(dev, k, (uint16_t)( ( k->GetMode(dev, k ) & ~STDMSK_INDXSRC ) | ( (value != 0) << STDBIT_INDXSRC ) ), FALSE ); */
+/* } */
+
+/* static uint16_t GetIndexSrc(comedi_device *dev, enc_private *k )  */
+/* { */
+/*   return ( k->GetMode(dev, k ) >> STDBIT_INDXSRC ) & 1; */
+/* } */
+
+///////////////////////////////////////////////////////////////////
+// Generate an index pulse.
+
+static void PulseIndex_A(comedi_device * dev, enc_private * k)
+{
+	register uint16_t cra;
+
+	DEBUG("PulseIndex_A: pulse index enter\n");
+
+	cra = DEBIread(dev, k->MyCRA);	// Pulse index.
+	DEBIwrite(dev, k->MyCRA, (uint16_t) (cra ^ CRAMSK_INDXPOL_A));
+	DEBUG("PulseIndex_A: pulse index step1\n");
+	DEBIwrite(dev, k->MyCRA, cra);
+}
+
+static void PulseIndex_B(comedi_device * dev, enc_private * k)
+{
+	register uint16_t crb;
+
+	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;	// Pulse index.
+	DEBIwrite(dev, k->MyCRB, (uint16_t) (crb ^ CRBMSK_INDXPOL_B));
+	DEBIwrite(dev, k->MyCRB, crb);
+}
+
+/////////////////////////////////////////////////////////
+// Write value into counter preload register.
+
+static void Preload(comedi_device * dev, enc_private * k, uint32_t value)
+{
+	DEBUG("Preload: preload enter\n");
+	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	// Write value to preload register.
+	DEBUG("Preload: preload step 1\n");
+	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw + 2),
+		(uint16_t) (value >> 16));
+}
+
+static void CountersInit(comedi_device * dev)
+{
+	int chan;
+	enc_private *k;
+	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	// Preload upon
+		// index.
+		(INDXSRC_SOFT << BF_INDXSRC) |	// Disable hardware index.
+		(CLKSRC_COUNTER << BF_CLKSRC) |	// Operating mode is counter.
+		(CLKPOL_POS << BF_CLKPOL) |	// Active high clock.
+		(CNTDIR_UP << BF_CLKPOL) |	// Count direction is up.
+		(CLKMULT_1X << BF_CLKMULT) |	// Clock multiplier is 1x.
+		(CLKENAB_INDEX << BF_CLKENAB);	// Enabled by index
+
+	// Disable all counter interrupts and clear any captured counter events.
+	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
+		k = &encpriv[chan];
+		k->SetMode(dev, k, Setup, TRUE);
+		k->SetIntSrc(dev, k, 0);
+		k->ResetCapFlags(dev, k);
+		k->SetEnable(dev, k, CLKENAB_ALWAYS);
+	}
+	DEBUG("CountersInit: counters initialized \n");
+
+}
