commit 0bc5b2ba455f1b35c7292b393134f249afb03154
Author: Stephen Davies <davo2002@tpg.com.au>
Date:   Thu Nov 29 12:49:18 2018 +1100

    staging: comedi: drivers: Cleanup malformed licence identifier
    
    This patch fixes multiple occurences of the checkpatch.pl warning:
    WARNING: Missing or malformed SPDX-License-Identifier tag in line 1
    
    NB. This is an additional patch and does not overlap the patch sent
    yesterday for 8255.h. Should have sent them all together.
    Newb mistake.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Stephen Davies <davo2002@tpg.com.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 4bdc4fba736f..749252b1d26b 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0+
+/* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * comedi/drivers/s626.h
  * Sensoray s626 Comedi driver, header file

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 924e7d60e713..4bdc4fba736f 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -8,16 +8,6 @@
  *
  * Based on Sensoray Model 626 Linux driver Version 0.2
  * Copyright (C) 2002-2004 Sensoray Co., Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #ifndef S626_H_INCLUDED

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 4cef45263267..924e7d60e713 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * comedi/drivers/s626.h
  * Sensoray s626 Comedi driver, header file

commit 1c454fabc215ec247f540e9b94d6a70cbe469c17
Author: Anson Jacob <ansonjacob.aj@gmail.com>
Date:   Fri Aug 26 19:14:00 2016 -0400

    staging: comedi: s626.h: Fix checkpatch warning
    
    Fix checkpatch.pl warning for
    Comparisons should place the constant on the right side of the test
    Remove extra space after /*
    
    Signed-off-by: Anson Jacob <ansonjacob.aj@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 6a00a64c6f3a..4cef45263267 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -79,7 +79,7 @@
 /* Address offsets, in DWORDS, from base of DMA buffer. */
 #define S626_DAC_WDMABUF_OS	S626_ADC_DMABUF_DWORDS
 
-/*  Interrupt enable bit in ISR and IER. */
+/* Interrupt enable bit in ISR and IER. */
 #define S626_IRQ_GPIO3		0x00000040	/* IRQ enable for GPIO3. */
 #define S626_IRQ_RPS1		0x10000000
 #define S626_ISR_AFOU		0x00000800
@@ -329,7 +329,7 @@
 						 * WS1-WS4 = CS* outputs.
 						 */
 
-#if S626_PLATFORM == S626_INTEL		/*
+#if (S626_PLATFORM == S626_INTEL)	/*
 					 * Base ACON1 config: always run
 					 * A1 based on TSL1.
 					 */

commit 805c5f93286f2e5b5ab53fb23501768b47314aea
Author: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
Date:   Wed Jun 8 15:18:54 2016 +0530

    Staging: comedi: s626: fix comment issue
    
    This fixes up a WARNING: 'Block comments use a trailing */ on a
    separate line'found by the checkpatch.pl tool.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index b83424e7507b..6a00a64c6f3a 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -29,8 +29,10 @@
 #define S626_ENCODER_CHANNELS   6
 #define S626_DIO_CHANNELS       48
 #define S626_DIO_BANKS		3	/* Number of DIO groups. */
-#define S626_DIO_EXTCHANS	40	/* Number of extended-capability
-					 * DIO channels. */
+#define S626_DIO_EXTCHANS	40	/*
+					 * Number of extended-capability
+					 * DIO channels.
+					 */
 
 #define S626_NUM_TRIMDACS	12	/* Number of valid TrimDAC channels. */
 
@@ -48,21 +50,29 @@
 #define S626_GSEL_BIPOLAR10V	0x00A0	/* S626_LP_GSEL setting 10V bipolar. */
 
 /* Error codes that must be visible to this base class. */
-#define S626_ERR_ILLEGAL_PARM	0x00010000	/* Illegal function parameter
-						 * value was specified. */
+#define S626_ERR_ILLEGAL_PARM	0x00010000	/*
+						 * Illegal function parameter
+						 * value was specified.
+						 */
 #define S626_ERR_I2C		0x00020000	/* I2C error. */
-#define S626_ERR_COUNTERSETUP	0x00200000	/* Illegal setup specified for
-						 * counter channel. */
+#define S626_ERR_COUNTERSETUP	0x00200000	/*
+						 * Illegal setup specified for
+						 * counter channel.
+						 */
 #define S626_ERR_DEBI_TIMEOUT	0x00400000	/* DEBI transfer timed out. */
 
 /*
  * Organization (physical order) and size (in DWORDs) of logical DMA buffers
  * contained by ANA_DMABUF.
  */
-#define S626_ADC_DMABUF_DWORDS	40	/* ADC DMA buffer must hold 16 samples,
-					 * plus pre/post garbage samples. */
-#define S626_DAC_WDMABUF_DWORDS	1	/* DAC output DMA buffer holds a single
-					 * sample. */
+#define S626_ADC_DMABUF_DWORDS	40	/*
+					 * ADC DMA buffer must hold 16 samples,
+					 * plus pre/post garbage samples.
+					 */
+#define S626_DAC_WDMABUF_DWORDS	1	/*
+					 * DAC output DMA buffer holds a single
+					 * sample.
+					 */
 
 /* All remaining space in 4KB DMA buffer is available for the RPS1 program. */
 
@@ -95,60 +105,90 @@
 #define S626_RPS_IRQ		0x60000000	/* IRQ */
 
 #define S626_RPS_LOGICAL_OR	0x08000000	/* Logical OR conditionals. */
-#define S626_RPS_INVERT		0x04000000	/* Test for negated
-						 * semaphores. */
+#define S626_RPS_INVERT		0x04000000	/*
+						 * Test for negated
+						 * semaphores.
+						 */
 #define S626_RPS_DEBI		0x00000002	/* DEBI done */
 
-#define S626_RPS_SIG0		0x00200000	/* RPS semaphore 0
-						 * (used by ADC). */
-#define S626_RPS_SIG1		0x00400000	/* RPS semaphore 1
-						 * (used by DAC). */
-#define S626_RPS_SIG2		0x00800000	/* RPS semaphore 2
-						 * (not used). */
+#define S626_RPS_SIG0		0x00200000	/*
+						 * RPS semaphore 0
+						 * (used by ADC).
+						 */
+#define S626_RPS_SIG1		0x00400000	/*
+						 * RPS semaphore 1
+						 * (used by DAC).
+						 */
+#define S626_RPS_SIG2		0x00800000	/*
+						 * RPS semaphore 2
+						 * (not used).
+						 */
 #define S626_RPS_GPIO2		0x00080000	/* RPS GPIO2 */
 #define S626_RPS_GPIO3		0x00100000	/* RPS GPIO3 */
 
-#define S626_RPS_SIGADC		S626_RPS_SIG0	/* Trigger/status for
-						 * ADC's RPS program. */
-#define S626_RPS_SIGDAC		S626_RPS_SIG1	/* Trigger/status for
-						 * DAC's RPS program. */
+#define S626_RPS_SIGADC		S626_RPS_SIG0	/*
+						 * Trigger/status for
+						 * ADC's RPS program.
+						 */
+#define S626_RPS_SIGDAC		S626_RPS_SIG1	/*
+						 * Trigger/status for
+						 * DAC's RPS program.
+						 */
 
 /* RPS clock parameters. */
-#define S626_RPSCLK_SCALAR	8	/* This is apparent ratio of
-					 * PCI/RPS clks (undocumented!!). */
+#define S626_RPSCLK_SCALAR	8	/*
+					 * This is apparent ratio of
+					 * PCI/RPS clks (undocumented!!).
+					 */
 #define S626_RPSCLK_PER_US	(33 / S626_RPSCLK_SCALAR)
-					/* Number of RPS clocks in one
-					 * microsecond. */
+					/*
+					 * Number of RPS clocks in one
+					 * microsecond.
+					 */
 
 /* Event counter source addresses. */
 #define S626_SBA_RPS_A0		0x27	/* Time of RPS0 busy, in PCI clocks. */
 
 /* GPIO constants. */
-#define S626_GPIO_BASE		0x10004000	/* GPIO 0,2,3 = inputs,
-						 * GPIO3 = IRQ; GPIO1 = out. */
+#define S626_GPIO_BASE		0x10004000	/*
+						 * GPIO 0,2,3 = inputs,
+						 * GPIO3 = IRQ; GPIO1 = out.
+						 */
 #define S626_GPIO1_LO		0x00000000	/* GPIO1 set to LOW. */
 #define S626_GPIO1_HI		0x00001000	/* GPIO1 set to HIGH. */
 
 /* Primary Status Register (PSR) constants. */
 #define S626_PSR_DEBI_E		0x00040000	/* DEBI event flag. */
 #define S626_PSR_DEBI_S		0x00080000	/* DEBI status flag. */
-#define S626_PSR_A2_IN		0x00008000	/* Audio output DMA2 protection
-						 * address reached. */
-#define S626_PSR_AFOU		0x00000800	/* Audio FIFO under/overflow
-						 * detected. */
-#define S626_PSR_GPIO2		0x00000020	/* GPIO2 input pin: 0=AdcBusy,
-						 * 1=AdcIdle. */
-#define S626_PSR_EC0S		0x00000001	/* Event counter 0 threshold
-						 * reached. */
+#define S626_PSR_A2_IN		0x00008000	/*
+						 * Audio output DMA2 protection
+						 * address reached.
+						 */
+#define S626_PSR_AFOU		0x00000800	/*
+						 * Audio FIFO under/overflow
+						 * detected.
+						 */
+#define S626_PSR_GPIO2		0x00000020	/*
+						 * GPIO2 input pin: 0=AdcBusy,
+						 * 1=AdcIdle.
+						 */
+#define S626_PSR_EC0S		0x00000001	/*
+						 * Event counter 0 threshold
+						 * reached.
+						 */
 
 /* Secondary Status Register (SSR) constants. */
-#define S626_SSR_AF2_OUT	0x00000200	/* Audio 2 output FIFO
-						 * under/overflow detected. */
+#define S626_SSR_AF2_OUT	0x00000200	/*
+						 * Audio 2 output FIFO
+						 * under/overflow detected.
+						 */
 
 /* Master Control Register 1 (MC1) constants. */
 #define S626_MC1_SOFT_RESET	0x80000000	/* Invoke 7146 soft reset. */
-#define S626_MC1_SHUTDOWN	0x3FFF0000	/* Shut down all MC1-controlled
-						 * enables. */
+#define S626_MC1_SHUTDOWN	0x3FFF0000	/*
+						 * Shut down all MC1-controlled
+						 * enables.
+						 */
 
 #define S626_MC1_ERPS1		0x2000	/* Enab/disable RPS task 1. */
 #define S626_MC1_ERPS0		0x1000	/* Enab/disable RPS task 0. */
@@ -177,15 +217,23 @@
 #define S626_P_DEBIAD		0x0088	/* DEBI target address. */
 #define S626_P_I2CCTRL		0x008C	/* I2C control. */
 #define S626_P_I2CSTAT		0x0090	/* I2C status. */
-#define S626_P_BASEA2_IN	0x00AC	/* Audio input 2 base physical DMAbuf
-					 * address. */
-#define S626_P_PROTA2_IN	0x00B0	/* Audio input 2 physical DMAbuf
-					 * protection address. */
+#define S626_P_BASEA2_IN	0x00AC	/*
+					 * Audio input 2 base physical DMAbuf
+					 * address.
+					 */
+#define S626_P_PROTA2_IN	0x00B0	/*
+					 * Audio input 2 physical DMAbuf
+					 * protection address.
+					 */
 #define S626_P_PAGEA2_IN	0x00B4	/* Audio input 2 paging attributes. */
-#define S626_P_BASEA2_OUT	0x00B8	/* Audio output 2 base physical DMAbuf
-					 * address. */
-#define S626_P_PROTA2_OUT	0x00BC	/* Audio output 2 physical DMAbuf
-					 * protection address. */
+#define S626_P_BASEA2_OUT	0x00B8	/*
+					 * Audio output 2 base physical DMAbuf
+					 * address.
+					 */
+#define S626_P_PROTA2_OUT	0x00BC	/*
+					 * Audio output 2 physical DMAbuf
+					 * protection address.
+					 */
 #define S626_P_PAGEA2_OUT	0x00C0	/* Audio output 2 paging attributes. */
 #define S626_P_RPSPAGE0		0x00C4	/* RPS0 page. */
 #define S626_P_RPSPAGE1		0x00C8	/* RPS1 page. */
@@ -205,8 +253,10 @@
 #define S626_P_PSR		0x0110	/* Primary status. */
 #define S626_P_SSR		0x0114	/* Secondary status. */
 #define S626_P_EC1R		0x0118	/* Event counter set 1. */
-#define S626_P_ADP4		0x0138	/* Logical audio DMA pointer of audio
-					 * input FIFO A2_IN. */
+#define S626_P_ADP4		0x0138	/*
+					 * Logical audio DMA pointer of audio
+					 * input FIFO A2_IN.
+					 */
 #define S626_P_FB_BUFFER1	0x0144	/* Audio feedback buffer 1. */
 #define S626_P_FB_BUFFER2	0x0148	/* Audio feedback buffer 2. */
 #define S626_P_TSL1		0x0180	/* Audio time slot list 1. */
@@ -243,13 +293,19 @@
 #define S626_LP_RDMISC2		0x0082	/* Read Misc2. */
 
 /* Bit masks for MISC1 register that are the same for reads and writes. */
-#define S626_MISC1_WENABLE	0x8000	/* enab writes to MISC2 (except Clear
-					 * Watchdog bit). */
+#define S626_MISC1_WENABLE	0x8000	/*
+					 * enab writes to MISC2 (except Clear
+					 * Watchdog bit).
+					 */
 #define S626_MISC1_WDISABLE	0x0000	/* Disable writes to MISC2. */
-#define S626_MISC1_EDCAP	0x1000	/* Enable edge capture on DIO chans
-					 * specified by S626_LP_WRCAPSELx. */
-#define S626_MISC1_NOEDCAP	0x0000	/* Disable edge capture on specified
-					 * DIO chans. */
+#define S626_MISC1_EDCAP	0x1000	/*
+					 * Enable edge capture on DIO chans
+					 * specified by S626_LP_WRCAPSELx.
+					 */
+#define S626_MISC1_NOEDCAP	0x0000	/*
+					 * Disable edge capture on specified
+					 * DIO chans.
+					 */
 
 /* Bit masks for MISC1 register reads. */
 #define S626_RDMISC1_WDTIMEOUT	0x4000	/* Watchdog timer timed out. */
@@ -268,35 +324,49 @@
 #define S626_A1_RUN		0x20000000	/* Run A1 based on TSL1. */
 #define S626_A1_SWAP		0x00200000	/* Use big-endian for A1. */
 #define S626_A2_SWAP		0x00100000	/* Use big-endian for A2. */
-#define S626_WS_MODES		0x00019999	/* WS0 = TSL1 trigger input,
-						 * WS1-WS4 = CS* outputs. */
-
-#if S626_PLATFORM == S626_INTEL		/* Base ACON1 config: always run
-					 * A1 based on TSL1. */
+#define S626_WS_MODES		0x00019999	/*
+						 * WS0 = TSL1 trigger input,
+						 * WS1-WS4 = CS* outputs.
+						 */
+
+#if S626_PLATFORM == S626_INTEL		/*
+					 * Base ACON1 config: always run
+					 * A1 based on TSL1.
+					 */
 #define S626_ACON1_BASE		(S626_WS_MODES | S626_A1_RUN)
 #elif S626_PLATFORM == S626_MOTOROLA
 #define S626_ACON1_BASE		\
 	(S626_WS_MODES | S626_A1_RUN | S626_A1_SWAP | S626_A2_SWAP)
 #endif
 
-#define S626_ACON1_ADCSTART	S626_ACON1_BASE	/* Start ADC: run A1
-						 * based on TSL1. */
+#define S626_ACON1_ADCSTART	S626_ACON1_BASE	/*
+						 * Start ADC: run A1
+						 * based on TSL1.
+						 */
 #define S626_ACON1_DACSTART	(S626_ACON1_BASE | S626_A2_RUN)
 /* Start transmit to DAC: run A2 based on TSL2. */
 #define S626_ACON1_DACSTOP	S626_ACON1_BASE	/* Halt A2. */
 
 /* Bit masks for ACON2 register. */
 #define S626_A1_CLKSRC_BCLK1	0x00000000	/* A1 bit rate = BCLK1 (ADC). */
-#define S626_A2_CLKSRC_X1	0x00800000	/* A2 bit rate = ACLK/1
-						 * (DACs). */
-#define S626_A2_CLKSRC_X2	0x00C00000	/* A2 bit rate = ACLK/2
-						 * (DACs). */
-#define S626_A2_CLKSRC_X4	0x01400000	/* A2 bit rate = ACLK/4
-						 * (DACs). */
+#define S626_A2_CLKSRC_X1	0x00800000	/*
+						 * A2 bit rate = ACLK/1
+						 * (DACs).
+						 */
+#define S626_A2_CLKSRC_X2	0x00C00000	/*
+						 * A2 bit rate = ACLK/2
+						 * (DACs).
+						 */
+#define S626_A2_CLKSRC_X4	0x01400000	/*
+						 * A2 bit rate = ACLK/4
+						 * (DACs).
+						 */
 #define S626_INVERT_BCLK2	0x00100000	/* Invert BCLK2 (DACs). */
 #define S626_BCLK2_OE		0x00040000	/* Enable BCLK2 (DACs). */
-#define S626_ACON2_XORMASK	0x000C0000	/* XOR mask for ACON2
-						 * active-low bits. */
+#define S626_ACON2_XORMASK	0x000C0000	/*
+						 * XOR mask for ACON2
+						 * active-low bits.
+						 */
 
 #define S626_ACON2_INIT		(S626_ACON2_XORMASK ^ \
 				 (S626_A1_CLKSRC_BCLK1 | S626_A2_CLKSRC_X2 | \
@@ -308,12 +378,18 @@
 #define S626_WS3		0x10000000
 #define S626_WS4		0x08000000
 #define S626_RSD1		0x01000000	/* Shift A1 data in on SD1. */
-#define S626_SDW_A1		0x00800000	/* Store rcv'd char at next char
-						 * slot of DWORD1 buffer. */
-#define S626_SIB_A1		0x00400000	/* Store rcv'd char at next
-						 * char slot of FB1 buffer. */
-#define S626_SF_A1		0x00200000	/* Write unsigned long
-						 * buffer to input FIFO. */
+#define S626_SDW_A1		0x00800000	/*
+						 * Store rcv'd char at next char
+						 * slot of DWORD1 buffer.
+						 */
+#define S626_SIB_A1		0x00400000	/*
+						 * Store rcv'd char at next
+						 * char slot of FB1 buffer.
+						 */
+#define S626_SF_A1		0x00200000	/*
+						 * Write unsigned long
+						 * buffer to input FIFO.
+						 */
 
 /* Select parallel-to-serial converter's data source: */
 #define S626_XFIFO_0		0x00000000	/* Data fifo byte 0. */
@@ -324,31 +400,45 @@
 #define S626_XFB1		0x00000050	/* FB_BUFFER byte 1. */
 #define S626_XFB2		0x00000060	/* FB_BUFFER byte 2. */
 #define S626_XFB3		0x00000070	/* FB_BUFFER byte 3. */
-#define S626_SIB_A2		0x00000200	/* Store next dword from A2's
+#define S626_SIB_A2		0x00000200	/*
+						 * Store next dword from A2's
 						 * input shifter to FB2
-						 * buffer. */
-#define S626_SF_A2		0x00000100	/* Store next dword from A2's
+						 * buffer.
+						 */
+#define S626_SF_A2		0x00000100	/*
+						 * Store next dword from A2's
 						 * input shifter to its input
-						 * fifo. */
-#define S626_LF_A2		0x00000080	/* Load next dword from A2's
+						 * fifo.
+						 */
+#define S626_LF_A2		0x00000080	/*
+						 * Load next dword from A2's
 						 * output fifo into its
-						 * output dword buffer. */
+						 * output dword buffer.
+						 */
 #define S626_XSD2		0x00000008	/* Shift data out on SD2. */
 #define S626_RSD3		0x00001800	/* Shift data in on SD3. */
 #define S626_RSD2		0x00001000	/* Shift data in on SD2. */
-#define S626_LOW_A2		0x00000002	/* Drive last SD low for 7 clks,
-						 * then tri-state. */
+#define S626_LOW_A2		0x00000002	/*
+						 * Drive last SD low for 7 clks,
+						 * then tri-state.
+						 */
 #define S626_EOS		0x00000001	/* End of superframe. */
 
 /* I2C configuration constants. */
-#define S626_I2C_CLKSEL		0x0400		/* I2C bit rate =
-						 * PCIclk/480 = 68.75 KHz. */
-#define S626_I2C_BITRATE	68.75		/* I2C bus data bit rate
+#define S626_I2C_CLKSEL		0x0400		/*
+						 * I2C bit rate =
+						 * PCIclk/480 = 68.75 KHz.
+						 */
+#define S626_I2C_BITRATE	68.75		/*
+						 * I2C bus data bit rate
 						 * (determined by
-						 * S626_I2C_CLKSEL) in KHz. */
-#define S626_I2C_WRTIME		15.0		/* Worst case time, in msec,
+						 * S626_I2C_CLKSEL) in KHz.
+						 */
+#define S626_I2C_WRTIME		15.0		/*
+						 * Worst case time, in msec,
 						 * for EEPROM internal write
-						 * op. */
+						 * op.
+						 */
 
 /* I2C manifest constants. */
 
@@ -368,8 +458,10 @@
 #define S626_I2C_B0(ATTR, VAL)	(((ATTR) << 2) | ((VAL) <<  8))
 
 /* DEBI command constants. */
-#define S626_DEBI_CMD_SIZE16	(2 << 17)	/* Transfer size is always
-						 * 2 bytes. */
+#define S626_DEBI_CMD_SIZE16	(2 << 17)	/*
+						 * Transfer size is always
+						 * 2 bytes.
+						 */
 #define S626_DEBI_CMD_READ	0x00010000	/* Read operation. */
 #define S626_DEBI_CMD_WRITE	0x00000000	/* Write operation. */
 
@@ -380,42 +472,58 @@
 #define S626_DEBI_CMD_WRWORD	(S626_DEBI_CMD_WRITE | S626_DEBI_CMD_SIZE16)
 
 /* DEBI configuration constants. */
-#define S626_DEBI_CFG_XIRQ_EN	0x80000000	/* Enable external interrupt
-						 * on GPIO3. */
+#define S626_DEBI_CFG_XIRQ_EN	0x80000000	/*
+						 * Enable external interrupt
+						 * on GPIO3.
+						 */
 #define S626_DEBI_CFG_XRESUME	0x40000000	/* Resume block */
-						/* Transfer when XIRQ
-						 * deasserted. */
+						/*
+						 * Transfer when XIRQ
+						 * deasserted.
+						 */
 #define S626_DEBI_CFG_TOQ	0x03C00000	/* Timeout (15 PCI cycles). */
 #define S626_DEBI_CFG_FAST	0x10000000	/* Fast mode enable. */
 
 /* 4-bit field that specifies DEBI timeout value in PCI clock cycles: */
-#define S626_DEBI_CFG_TOUT_BIT	22	/* Finish DEBI cycle after this many
-					 * clocks. */
+#define S626_DEBI_CFG_TOUT_BIT	22	/*
+					 * Finish DEBI cycle after this many
+					 * clocks.
+					 */
 
 /* 2-bit field that specifies Endian byte lane steering: */
-#define S626_DEBI_CFG_SWAP_NONE	0x00000000	/* Straight - don't swap any
-						 * bytes (Intel). */
+#define S626_DEBI_CFG_SWAP_NONE	0x00000000	/*
+						 * Straight - don't swap any
+						 * bytes (Intel).
+						 */
 #define S626_DEBI_CFG_SWAP_2	0x00100000	/* 2-byte swap (Motorola). */
 #define S626_DEBI_CFG_SWAP_4	0x00200000	/* 4-byte swap. */
-#define S626_DEBI_CFG_SLAVE16	0x00080000	/* Slave is able to serve
-						 * 16-bit cycles. */
-#define S626_DEBI_CFG_INC	0x00040000	/* Enable address increment
-						 * for block transfers. */
+#define S626_DEBI_CFG_SLAVE16	0x00080000	/*
+						 * Slave is able to serve
+						 * 16-bit cycles.
+						 */
+#define S626_DEBI_CFG_INC	0x00040000	/*
+						 * Enable address increment
+						 * for block transfers.
+						 */
 #define S626_DEBI_CFG_INTEL	0x00020000	/* Intel style local bus. */
 #define S626_DEBI_CFG_TIMEROFF	0x00010000	/* Disable timer. */
 
 #if S626_PLATFORM == S626_INTEL
 
-#define S626_DEBI_TOUT		7	/* Wait 7 PCI clocks (212 ns) before
-					 * polling RDY. */
+#define S626_DEBI_TOUT		7	/*
+					 * Wait 7 PCI clocks (212 ns) before
+					 * polling RDY.
+					 */
 
 /* Intel byte lane steering (pass through all byte lanes). */
 #define S626_DEBI_SWAP		S626_DEBI_CFG_SWAP_NONE
 
 #elif S626_PLATFORM == S626_MOTOROLA
 
-#define S626_DEBI_TOUT		15	/* Wait 15 PCI clocks (454 ns) maximum
-					 * before timing out. */
+#define S626_DEBI_TOUT		15	/*
+					 * Wait 15 PCI clocks (454 ns) maximum
+					 * before timing out.
+					 */
 
 /* Motorola byte lane steering. */
 #define S626_DEBI_SWAP		S626_DEBI_CFG_SWAP_2
@@ -429,10 +537,14 @@
 
 /* LoadSrc values: */
 #define S626_LOADSRC_INDX	0	/* Preload core in response to Index. */
-#define S626_LOADSRC_OVER	1	/* Preload core in response to
-					 * Overflow. */
-#define S626_LOADSRCB_OVERA	2	/* Preload B core in response to
-					 * A Overflow. */
+#define S626_LOADSRC_OVER	1	/*
+					 * Preload core in response to
+					 * Overflow.
+					 */
+#define S626_LOADSRCB_OVERA	2	/*
+					 * Preload B core in response to
+					 * A Overflow.
+					 */
 #define S626_LOADSRC_NONE	3	/* Never preload core. */
 
 /* IntSrc values: */
@@ -469,10 +581,14 @@
 #define S626_CNTSRC_SYSCLK_DOWN	3	/* System clock down */
 
 /* ClkPol values: */
-#define S626_CLKPOL_POS		0	/* Counter/Extender clock is
-					 * active high. */
-#define S626_CLKPOL_NEG		1	/* Counter/Extender clock is
-					 * active low. */
+#define S626_CLKPOL_POS		0	/*
+					 * Counter/Extender clock is
+					 * active high.
+					 */
+#define S626_CLKPOL_NEG		1	/*
+					 * Counter/Extender clock is
+					 * active low.
+					 */
 #define S626_CNTDIR_UP		0	/* Timer counts up. */
 #define S626_CNTDIR_DOWN	1	/* Timer counts down. */
 
@@ -488,8 +604,10 @@
 
 /* Sanity-check limits for parameters. */
 
-#define S626_NUM_COUNTERS	6	/* Maximum valid counter
-					 * logical channel number. */
+#define S626_NUM_COUNTERS	6	/*
+					 * Maximum valid counter
+					 * logical channel number.
+					 */
 #define S626_NUM_INTSOURCES	4
 #define S626_NUM_LATCHSOURCES	4
 #define S626_NUM_CLKMULTS	4

commit 2ffe88f67fbef05b337ba53ae05c0b37a9a376bf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:49 2014 -0700

    staging: comedi: s626: define S626_LP_CNTR* registers based on channel number
    
    Redefining the Counter Preload/Latch registers as a macro that calculates
    the register offset based on the comedi channel number.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 70557a00f88a..b83424e7507b 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -233,19 +233,9 @@
 #define S626_LP_CRA(x)		(0x0000 + (((x) % 3) * 0x4))
 #define S626_LP_CRB(x)		(0x0002 + (((x) % 3) * 0x4))
 
-/* Counter PreLoad (write) and Latch (read) Registers: */
-#define	S626_LP_CNTR0ALSW	0x000C	/* 0A lsw. */
-#define	S626_LP_CNTR0AMSW	0x000E	/* 0A msw. */
-#define	S626_LP_CNTR0BLSW	0x0010	/* 0B lsw. */
-#define	S626_LP_CNTR0BMSW	0x0012	/* 0B msw. */
-#define	S626_LP_CNTR1ALSW	0x0014	/* 1A lsw. */
-#define	S626_LP_CNTR1AMSW	0x0016	/* 1A msw. */
-#define	S626_LP_CNTR1BLSW	0x0018	/* 1B lsw. */
-#define	S626_LP_CNTR1BMSW	0x001A	/* 1B msw. */
-#define	S626_LP_CNTR2ALSW	0x001C	/* 2A lsw. */
-#define	S626_LP_CNTR2AMSW	0x001E	/* 2A msw. */
-#define	S626_LP_CNTR2BLSW	0x0020	/* 2B lsw. */
-#define	S626_LP_CNTR2BMSW	0x0022	/* 2B msw. */
+/* Counter PreLoad (write) and Latch (read) Registers: 0A 1A 2A 0B 1B 2B */
+#define S626_LP_CNTR(x)		(0x000c  + (((x) < 3) ? 0x0 : 0x4) + \
+					   (((x) % 3) * 0x8))
 
 /* Miscellaneous Registers (read/write): */
 #define S626_LP_MISC1		0x0088	/* Read/write Misc1. */

commit f114b45a6b14682c55e8c2709e07b1ccf4d727a2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:28:46 2014 -0700

    staging: comedi: s626: define CRA/CRB registers based on channel number
    
    Start cleaning up the 'struct s626_enc_info' by redefining the my_cra
    and my_crb members based on the comedi channel number.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 33b72739c1cb..70557a00f88a 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -229,13 +229,9 @@
 #define S626_LP_RDEDGSEL(x)	(0x004c + (x) * 0x10)	/* R: edge selection */
 #define S626_LP_RDCAPSEL(x)	(0x004e + (x) * 0x10)	/* R: capture enable */
 
-/* Counter Registers (read/write): */
-#define S626_LP_CR0A		0x0000	/* 0A setup register. */
-#define S626_LP_CR0B		0x0002	/* 0B setup register. */
-#define S626_LP_CR1A		0x0004	/* 1A setup register. */
-#define S626_LP_CR1B		0x0006	/* 1B setup register. */
-#define S626_LP_CR2A		0x0008	/* 2A setup register. */
-#define S626_LP_CR2B		0x000A	/* 2B setup register. */
+/* Counter registers (read/write): 0A 1A 2A 0B 1B 2B */
+#define S626_LP_CRA(x)		(0x0000 + (((x) % 3) * 0x4))
+#define S626_LP_CRB(x)		(0x0002 + (((x) % 3) * 0x4))
 
 /* Counter PreLoad (write) and Latch (read) Registers: */
 #define	S626_LP_CNTR0ALSW	0x000C	/* 0A lsw. */

commit 7a1046e5c0fdce80ba075c2edd8a97b7485693ce
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 21 10:10:39 2013 +0100

    staging: comedi: s626: replace S626_MULT_X? values
    
    Replace the use of the `S626_MULT_X1`, `S626_MULT_X2` and `S626_MULT_X4`
    clock multiplier values with the equivalent `S626_CLKMULT_1X`,
    `S626_CLKMULT_2X` and `S626_CLKMULT_4X` values to avoid duplication.
    Replace the use of `S626_MULT_X0` with a new macro
    `S626_CLKMULT_SPECIAL` (this is treated specially by the
    'ClkMultA'/'ClkMultB' field of the 'CRA'/'CRB' register).  Remove the
    now unused `S626_MULT_X?` macros.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index cbd59eb3fea7..33b72739c1cb 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -498,17 +498,7 @@
 #define S626_CLKMULT_4X		0	/* 4x clock multiplier. */
 #define S626_CLKMULT_2X		1	/* 2x clock multiplier. */
 #define S626_CLKMULT_1X		2	/* 1x clock multiplier. */
-
-/* Enumerated counter clock multipliers. */
-
-#define S626_MULT_X0		0x0003	/* Supports no multipliers;
-					 * fixed physical multiplier = 3. */
-#define S626_MULT_X1		0x0002	/* Supports multiplier x1;
-					 * fixed physical multiplier = 2. */
-#define S626_MULT_X2		0x0001	/* Supports multipliers x1, x2;
-					 * physical multipliers = 1 or 2. */
-#define S626_MULT_X4		0x0000	/* Supports multipliers x1, x2, x4;
-					 * physical multipliers = 0, 1 or 2. */
+#define S626_CLKMULT_SPECIAL	3	/* Special clock multiplier value. */
 
 /* Sanity-check limits for parameters. */
 

commit 43ce748ff283169845af3eb012d22cd14792ce7d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 21 10:10:38 2013 +0100

    staging: comedi: s626: remove S626_BF_* macros
    
    The `S626_BF_*` bitfield position macros are no longer used and are just
    a subset of the corresponding `S626_STDBIT_*` bitfield position macros.
    Remove them.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 8509537bb2d8..cbd59eb3fea7 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -499,15 +499,6 @@
 #define S626_CLKMULT_2X		1	/* 2x clock multiplier. */
 #define S626_CLKMULT_1X		2	/* 1x clock multiplier. */
 
-/* Bit Field positions in COUNTER_SETUP structure: */
-#define S626_BF_LOADSRC		9	/* Preload trigger. */
-#define S626_BF_INDXSRC		7	/* Index source. */
-#define S626_BF_INDXPOL		6	/* Index polarity. */
-#define S626_BF_ENCMODE		4	/* Encoder mode. */
-#define S626_BF_CLKPOL		3	/* Clock polarity/count direction. */
-#define S626_BF_CLKMULT		1	/* Clock multiplier. */
-#define S626_BF_CLKENAB		0	/* Clock enable. */
-
 /* Enumerated counter clock multipliers. */
 
 #define S626_MULT_X0		0x0003	/* Supports no multipliers;

commit 2cea19faf16304125ce12e4b5518110ef77f32a1
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 21 10:10:37 2013 +0100

    staging: comedi: s626: expand standardized IndxSrc values
    
    The 'IndxSrc' value for the standardized encoder setup is currently 1
    bit wide and takes one of the following values:
    
      S626_INDXSRC_HARD = 0 // index source from hardware encoder
      S626_INDXSRC_SOFT = 1 // index source software controlled by IndxPol
    
    However the hardware 'IndxSrcA' and 'IndxSrcB' values for the 'A' and
    'B' counters are 2 bits wide.  The above standardized values 0 and 1
    correspond to the hardware values 0 and 2.
    
    In order to simplify conversions between the standardized values and
    hardware values, expand the range of standardized values to cover all
    four possible values.  The new values are as follows:
    
      S626_INDXSRC_ENCODER = 0  // index source from hardware encoder
      S626_INDXSRC_DIGIN = 1    // index source from digital inputs
      S626_INDXSRC_SOFT = 2     // index source s/w controlled by IndxPol
      S626_INDXSRC_DISABLED = 2 // index source disabled
    
    (Note the change in value for `S626_INDXSRC_SOFT` and the replacement of
    `S626_INDXSRC_HARD` with `S626_INDXSRC_ENCODER` for consistency with the
    `CntSrc` values.)
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index f6b68bf1df3e..8509537bb2d8 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -462,8 +462,10 @@
 #define S626_LATCHSRC_B_OVERA	3	/* Latch B on A Overflow. */
 
 /* IndxSrc values: */
-#define S626_INDXSRC_HARD	0	/* Hardware or software index. */
-#define S626_INDXSRC_SOFT	1	/* Software index only. */
+#define S626_INDXSRC_ENCODER	0	/* Encoder. */
+#define S626_INDXSRC_DIGIN	1	/* Digital inputs. */
+#define S626_INDXSRC_SOFT	2	/* S/w controlled by IndxPol bit. */
+#define S626_INDXSRC_DISABLED	3	/* Index disabled. */
 
 /* IndxPol values: */
 #define S626_INDXPOL_POS	0	/* Index input is active high. */
@@ -730,7 +732,7 @@
 #define S626_STDWID_INTSRC	2
 #define S626_STDWID_LATCHSRC	2
 #define S626_STDWID_LOADSRC	2
-#define S626_STDWID_INDXSRC	1
+#define S626_STDWID_INDXSRC	2
 #define S626_STDWID_INDXPOL	1
 #define S626_STDWID_ENCMODE	2
 #define S626_STDWID_CLKPOL	1

commit 03c1a0b89076fac46766b06a3f15ce89663c30fd
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Oct 18 14:40:55 2013 +0100

    staging: comedi: s626: bitfield manipulation macros for CRA, CRB and setup
    
    Some bits of the 'CRB' register have different functions when read or
    written, so add macros to define the read-only parts.
    
    Add macros to define the widths of the bitfields in the 'CRA' and 'CRB'
    registers and the standard encoder setup value.
    
    Add macros to construct and extract parts of the 'CRA' and 'CRB'
    register values and the standard encoder setup value, along with a
    couple of general helper macros for the above.
    
    Redefine the bitfield mask macros for 'CRA', 'CRB' and standard encoder
    setup using the above.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 7f38de5f07f5..f6b68bf1df3e 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -530,7 +530,9 @@
 #define S626_NUM_INDEXSOURCES	2
 #define S626_NUM_LOADTRIGS	4
 
-/* Bit field positions in CRA and CRB counter control registers. */
+/* General macros for manipulating bitfields: */
+#define S626_MAKE(x, w, p)	(((x) & ((1 << (w)) - 1)) << (p))
+#define S626_UNMAKE(v, w, p)	(((v) >> (p)) & ((1 << (w)) - 1))
 
 /* Bit field positions in CRA: */
 #define S626_CRABIT_INDXSRC_B	14	/* B index source. */
@@ -543,6 +545,68 @@
 #define S626_CRABIT_INDXSRC_A	 2	/* A index source. */
 #define S626_CRABIT_CNTSRC_A	 0	/* A counter source. */
 
+/* Bit field widths in CRA: */
+#define S626_CRAWID_INDXSRC_B	2
+#define S626_CRAWID_CNTSRC_B	2
+#define S626_CRAWID_INDXPOL_A	1
+#define S626_CRAWID_LOADSRC_A	2
+#define S626_CRAWID_CLKMULT_A	2
+#define S626_CRAWID_INTSRC_A	2
+#define S626_CRAWID_CLKPOL_A	1
+#define S626_CRAWID_INDXSRC_A	2
+#define S626_CRAWID_CNTSRC_A	2
+
+/* Bit field masks for CRA: */
+#define S626_CRAMSK_INDXSRC_B	S626_SET_CRA_INDXSRC_B(~0)
+#define S626_CRAMSK_CNTSRC_B	S626_SET_CRA_CNTSRC_B(~0)
+#define S626_CRAMSK_INDXPOL_A	S626_SET_CRA_INDXPOL_A(~0)
+#define S626_CRAMSK_LOADSRC_A	S626_SET_CRA_LOADSRC_A(~0)
+#define S626_CRAMSK_CLKMULT_A	S626_SET_CRA_CLKMULT_A(~0)
+#define S626_CRAMSK_INTSRC_A	S626_SET_CRA_INTSRC_A(~0)
+#define S626_CRAMSK_CLKPOL_A	S626_SET_CRA_CLKPOL_A(~0)
+#define S626_CRAMSK_INDXSRC_A	S626_SET_CRA_INDXSRC_A(~0)
+#define S626_CRAMSK_CNTSRC_A	S626_SET_CRA_CNTSRC_A(~0)
+
+/* Construct parts of the CRA value: */
+#define S626_SET_CRA_INDXSRC_B(x)	\
+	S626_MAKE((x), S626_CRAWID_INDXSRC_B, S626_CRABIT_INDXSRC_B)
+#define S626_SET_CRA_CNTSRC_B(x)	\
+	S626_MAKE((x), S626_CRAWID_CNTSRC_B, S626_CRABIT_CNTSRC_B)
+#define S626_SET_CRA_INDXPOL_A(x)	\
+	S626_MAKE((x), S626_CRAWID_INDXPOL_A, S626_CRABIT_INDXPOL_A)
+#define S626_SET_CRA_LOADSRC_A(x)	\
+	S626_MAKE((x), S626_CRAWID_LOADSRC_A, S626_CRABIT_LOADSRC_A)
+#define S626_SET_CRA_CLKMULT_A(x)	\
+	S626_MAKE((x), S626_CRAWID_CLKMULT_A, S626_CRABIT_CLKMULT_A)
+#define S626_SET_CRA_INTSRC_A(x)	\
+	S626_MAKE((x), S626_CRAWID_INTSRC_A, S626_CRABIT_INTSRC_A)
+#define S626_SET_CRA_CLKPOL_A(x)	\
+	S626_MAKE((x), S626_CRAWID_CLKPOL_A, S626_CRABIT_CLKPOL_A)
+#define S626_SET_CRA_INDXSRC_A(x)	\
+	S626_MAKE((x), S626_CRAWID_INDXSRC_A, S626_CRABIT_INDXSRC_A)
+#define S626_SET_CRA_CNTSRC_A(x)	\
+	S626_MAKE((x), S626_CRAWID_CNTSRC_A, S626_CRABIT_CNTSRC_A)
+
+/* Extract parts of the CRA value: */
+#define S626_GET_CRA_INDXSRC_B(v)	\
+	S626_UNMAKE((v), S626_CRAWID_INDXSRC_B, S626_CRABIT_INDXSRC_B)
+#define S626_GET_CRA_CNTSRC_B(v)	\
+	S626_UNMAKE((v), S626_CRAWID_CNTSRC_B, S626_CRABIT_CNTSRC_B)
+#define S626_GET_CRA_INDXPOL_A(v)	\
+	S626_UNMAKE((v), S626_CRAWID_INDXPOL_A, S626_CRABIT_INDXPOL_A)
+#define S626_GET_CRA_LOADSRC_A(v)	\
+	S626_UNMAKE((v), S626_CRAWID_LOADSRC_A, S626_CRABIT_LOADSRC_A)
+#define S626_GET_CRA_CLKMULT_A(v)	\
+	S626_UNMAKE((v), S626_CRAWID_CLKMULT_A, S626_CRABIT_CLKMULT_A)
+#define S626_GET_CRA_INTSRC_A(v)	\
+	S626_UNMAKE((v), S626_CRAWID_INTSRC_A, S626_CRABIT_INTSRC_A)
+#define S626_GET_CRA_CLKPOL_A(v)	\
+	S626_UNMAKE((v), S626_CRAWID_CLKPOL_A, S626_CRABIT_CLKPOL_A)
+#define S626_GET_CRA_INDXSRC_A(v)	\
+	S626_UNMAKE((v), S626_CRAWID_INDXSRC_A, S626_CRABIT_INDXSRC_A)
+#define S626_GET_CRA_CNTSRC_A(v)	\
+	S626_UNMAKE((v), S626_CRAWID_CNTSRC_A, S626_CRABIT_CNTSRC_A)
+
 /* Bit field positions in CRB: */
 #define S626_CRBBIT_INTRESETCMD	15	/* (w) Interrupt reset command. */
 #define S626_CRBBIT_CNTDIR_B	15	/* (r) B counter direction. */
@@ -560,41 +624,98 @@
 #define S626_CRBBIT_INDXPOL_B	 1	/* B index polarity. */
 #define S626_CRBBIT_CLKPOL_B	 0	/* B clock polarity. */
 
-/* Bit field masks for CRA and CRB. */
-
-#define S626_CRAMSK_INDXSRC_B	(3 << S626_CRABIT_INDXSRC_B)
-#define S626_CRAMSK_CNTSRC_B	(3 << S626_CRABIT_CNTSRC_B)
-#define S626_CRAMSK_INDXPOL_A	(1 << S626_CRABIT_INDXPOL_A)
-#define S626_CRAMSK_LOADSRC_A	(3 << S626_CRABIT_LOADSRC_A)
-#define S626_CRAMSK_CLKMULT_A	(3 << S626_CRABIT_CLKMULT_A)
-#define S626_CRAMSK_INTSRC_A	(3 << S626_CRABIT_INTSRC_A)
-#define S626_CRAMSK_CLKPOL_A	(1 << S626_CRABIT_CLKPOL_A)
-#define S626_CRAMSK_INDXSRC_A	(3 << S626_CRABIT_INDXSRC_A)
-#define S626_CRAMSK_CNTSRC_A	(3 << S626_CRABIT_CNTSRC_A)
-
-#define S626_CRBMSK_INTRESETCMD	(1 << S626_CRBBIT_INTRESETCMD)
-#define S626_CRBMSK_CNTDIR_B	(1 << S626_CRBBIT_CNTDIR_B)
-#define S626_CRBMSK_INTRESET_B	(1 << S626_CRBBIT_INTRESET_B)
-#define S626_CRBMSK_OVERDO_A	(1 << S626_CRBBIT_OVERDO_A)
-#define S626_CRBMSK_INTRESET_A	(1 << S626_CRBBIT_INTRESET_A)
-#define S626_CRBMSK_OVERDO_B	(1 << S626_CRBBIT_OVERDO_B)
-#define S626_CRBMSK_CLKENAB_A	(1 << S626_CRBBIT_CLKENAB_A)
-#define S626_CRBMSK_INTSRC_B	(3 << S626_CRBBIT_INTSRC_B)
-#define S626_CRBMSK_LATCHSRC	(3 << S626_CRBBIT_LATCHSRC)
-#define S626_CRBMSK_LOADSRC_B	(3 << S626_CRBBIT_LOADSRC_B)
-#define S626_CRBMSK_CLEAR_B	(1 << S626_CRBBIT_CLEAR_B)
-#define S626_CRBMSK_CLKMULT_B	(3 << S626_CRBBIT_CLKMULT_B)
-#define S626_CRBMSK_CLKENAB_B	(1 << S626_CRBBIT_CLKENAB_B)
-#define S626_CRBMSK_INDXPOL_B	(1 << S626_CRBBIT_INDXPOL_B)
-#define S626_CRBMSK_CLKPOL_B	(1 << S626_CRBBIT_CLKPOL_B)
+/* Bit field widths in CRB: */
+#define S626_CRBWID_INTRESETCMD	1
+#define S626_CRBWID_CNTDIR_B	1
+#define S626_CRBWID_INTRESET_B	1
+#define S626_CRBWID_OVERDO_A	1
+#define S626_CRBWID_INTRESET_A	1
+#define S626_CRBWID_OVERDO_B	1
+#define S626_CRBWID_CLKENAB_A	1
+#define S626_CRBWID_INTSRC_B	2
+#define S626_CRBWID_LATCHSRC	2
+#define S626_CRBWID_LOADSRC_B	2
+#define S626_CRBWID_CLEAR_B	1
+#define S626_CRBWID_CLKMULT_B	2
+#define S626_CRBWID_CLKENAB_B	1
+#define S626_CRBWID_INDXPOL_B	1
+#define S626_CRBWID_CLKPOL_B	1
+
+/* Bit field masks for CRB: */
+#define S626_CRBMSK_INTRESETCMD	S626_SET_CRB_INTRESETCMD(~0)	/* (w) */
+#define S626_CRBMSK_CNTDIR_B	S626_CRBMSK_INTRESETCMD		/* (r) */
+#define S626_CRBMSK_INTRESET_B	S626_SET_CRB_INTRESET_B(~0)	/* (w) */
+#define S626_CRBMSK_OVERDO_A	S626_CRBMSK_INTRESET_B		/* (r) */
+#define S626_CRBMSK_INTRESET_A	S626_SET_CRB_INTRESET_A(~0)	/* (w) */
+#define S626_CRBMSK_OVERDO_B	S626_CRBMSK_INTRESET_A		/* (r) */
+#define S626_CRBMSK_CLKENAB_A	S626_SET_CRB_CLKENAB_A(~0)
+#define S626_CRBMSK_INTSRC_B	S626_SET_CRB_INTSRC_B(~0)
+#define S626_CRBMSK_LATCHSRC	S626_SET_CRB_LATCHSRC(~0)
+#define S626_CRBMSK_LOADSRC_B	S626_SET_CRB_LOADSRC_B(~0)
+#define S626_CRBMSK_CLEAR_B	S626_SET_CRB_CLEAR_B(~0)
+#define S626_CRBMSK_CLKMULT_B	S626_SET_CRB_CLKMULT_B(~0)
+#define S626_CRBMSK_CLKENAB_B	S626_SET_CRB_CLKENAB_B(~0)
+#define S626_CRBMSK_INDXPOL_B	S626_SET_CRB_INDXPOL_B(~0)
+#define S626_CRBMSK_CLKPOL_B	S626_SET_CRB_CLKPOL_B(~0)
 
 /* Interrupt reset control bits. */
 #define S626_CRBMSK_INTCTRL	(S626_CRBMSK_INTRESETCMD | \
 				 S626_CRBMSK_INTRESET_A | \
 				 S626_CRBMSK_INTRESET_B)
 
-/* Bit field positions for standardized SETUP structure. */
-
+/* Construct parts of the CRB value: */
+#define S626_SET_CRB_INTRESETCMD(x)	\
+	S626_MAKE((x), S626_CRBWID_INTRESETCMD, S626_CRBBIT_INTRESETCMD)
+#define S626_SET_CRB_INTRESET_B(x)	\
+	S626_MAKE((x), S626_CRBWID_INTRESET_B, S626_CRBBIT_INTRESET_B)
+#define S626_SET_CRB_INTRESET_A(x)	\
+	S626_MAKE((x), S626_CRBWID_INTRESET_A, S626_CRBBIT_INTRESET_A)
+#define S626_SET_CRB_CLKENAB_A(x)	\
+	S626_MAKE((x), S626_CRBWID_CLKENAB_A, S626_CRBBIT_CLKENAB_A)
+#define S626_SET_CRB_INTSRC_B(x)	\
+	S626_MAKE((x), S626_CRBWID_INTSRC_B, S626_CRBBIT_INTSRC_B)
+#define S626_SET_CRB_LATCHSRC(x)	\
+	S626_MAKE((x), S626_CRBWID_LATCHSRC, S626_CRBBIT_LATCHSRC)
+#define S626_SET_CRB_LOADSRC_B(x)	\
+	S626_MAKE((x), S626_CRBWID_LOADSRC_B, S626_CRBBIT_LOADSRC_B)
+#define S626_SET_CRB_CLEAR_B(x)	\
+	S626_MAKE((x), S626_CRBWID_CLEAR_B, S626_CRBBIT_CLEAR_B)
+#define S626_SET_CRB_CLKMULT_B(x)	\
+	S626_MAKE((x), S626_CRBWID_CLKMULT_B, S626_CRBBIT_CLKMULT_B)
+#define S626_SET_CRB_CLKENAB_B(x)	\
+	S626_MAKE((x), S626_CRBWID_CLKENAB_B, S626_CRBBIT_CLKENAB_B)
+#define S626_SET_CRB_INDXPOL_B(x)	\
+	S626_MAKE((x), S626_CRBWID_INDXPOL_B, S626_CRBBIT_INDXPOL_B)
+#define S626_SET_CRB_CLKPOL_B(x)	\
+	S626_MAKE((x), S626_CRBWID_CLKPOL_B, S626_CRBBIT_CLKPOL_B)
+
+/* Extract parts of the CRB value: */
+#define S626_GET_CRB_CNTDIR_B(v)	\
+	S626_UNMAKE((v), S626_CRBWID_CNTDIR_B, S626_CRBBIT_CNTDIR_B)
+#define S626_GET_CRB_OVERDO_A(v)	\
+	S626_UNMAKE((v), S626_CRBWID_OVERDO_A, S626_CRBBIT_OVERDO_A)
+#define S626_GET_CRB_OVERDO_B(v)	\
+	S626_UNMAKE((v), S626_CRBWID_OVERDO_B, S626_CRBBIT_OVERDO_B)
+#define S626_GET_CRB_CLKENAB_A(v)	\
+	S626_UNMAKE((v), S626_CRBWID_CLKENAB_A, S626_CRBBIT_CLKENAB_A)
+#define S626_GET_CRB_INTSRC_B(v)	\
+	S626_UNMAKE((v), S626_CRBWID_INTSRC_B, S626_CRBBIT_INTSRC_B)
+#define S626_GET_CRB_LATCHSRC(v)	\
+	S626_UNMAKE((v), S626_CRBWID_LATCHSRC, S626_CRBBIT_LATCHSRC)
+#define S626_GET_CRB_LOADSRC_B(v)	\
+	S626_UNMAKE((v), S626_CRBWID_LOADSRC_B, S626_CRBBIT_LOADSRC_B)
+#define S626_GET_CRB_CLEAR_B(v)	\
+	S626_UNMAKE((v), S626_CRBWID_CLEAR_B, S626_CRBBIT_CLEAR_B)
+#define S626_GET_CRB_CLKMULT_B(v)	\
+	S626_UNMAKE((v), S626_CRBWID_CLKMULT_B, S626_CRBBIT_CLKMULT_B)
+#define S626_GET_CRB_CLKENAB_B(v)	\
+	S626_UNMAKE((v), S626_CRBWID_CLKENAB_B, S626_CRBBIT_CLKENAB_B)
+#define S626_GET_CRB_INDXPOL_B(v)	\
+	S626_UNMAKE((v), S626_CRBWID_INDXPOL_B, S626_CRBBIT_INDXPOL_B)
+#define S626_GET_CRB_CLKPOL_B(v)	\
+	S626_UNMAKE((v), S626_CRBWID_CLKPOL_B, S626_CRBBIT_CLKPOL_B)
+
+/* Bit field positions for standardized SETUP structure: */
 #define S626_STDBIT_INTSRC	13
 #define S626_STDBIT_LATCHSRC	11
 #define S626_STDBIT_LOADSRC	 9
@@ -605,16 +726,66 @@
 #define S626_STDBIT_CLKMULT	 1
 #define S626_STDBIT_CLKENAB	 0
 
-/* Bit field masks for standardized SETUP structure. */
-
-#define S626_STDMSK_INTSRC	(3 << S626_STDBIT_INTSRC)
-#define S626_STDMSK_LATCHSRC	(3 << S626_STDBIT_LATCHSRC)
-#define S626_STDMSK_LOADSRC	(3 << S626_STDBIT_LOADSRC)
-#define S626_STDMSK_INDXSRC	(1 << S626_STDBIT_INDXSRC)
-#define S626_STDMSK_INDXPOL	(1 << S626_STDBIT_INDXPOL)
-#define S626_STDMSK_ENCMODE	(3 << S626_STDBIT_ENCMODE)
-#define S626_STDMSK_CLKPOL	(1 << S626_STDBIT_CLKPOL)
-#define S626_STDMSK_CLKMULT	(3 << S626_STDBIT_CLKMULT)
-#define S626_STDMSK_CLKENAB	(1 << S626_STDBIT_CLKENAB)
+/* Bit field widths for standardized SETUP structure: */
+#define S626_STDWID_INTSRC	2
+#define S626_STDWID_LATCHSRC	2
+#define S626_STDWID_LOADSRC	2
+#define S626_STDWID_INDXSRC	1
+#define S626_STDWID_INDXPOL	1
+#define S626_STDWID_ENCMODE	2
+#define S626_STDWID_CLKPOL	1
+#define S626_STDWID_CLKMULT	2
+#define S626_STDWID_CLKENAB	1
+
+/* Bit field masks for standardized SETUP structure: */
+#define S626_STDMSK_INTSRC	S626_SET_STD_INTSRC(~0)
+#define S626_STDMSK_LATCHSRC	S626_SET_STD_LATCHSRC(~0)
+#define S626_STDMSK_LOADSRC	S626_SET_STD_LOADSRC(~0)
+#define S626_STDMSK_INDXSRC	S626_SET_STD_INDXSRC(~0)
+#define S626_STDMSK_INDXPOL	S626_SET_STD_INDXPOL(~0)
+#define S626_STDMSK_ENCMODE	S626_SET_STD_ENCMODE(~0)
+#define S626_STDMSK_CLKPOL	S626_SET_STD_CLKPOL(~0)
+#define S626_STDMSK_CLKMULT	S626_SET_STD_CLKMULT(~0)
+#define S626_STDMSK_CLKENAB	S626_SET_STD_CLKENAB(~0)
+
+/* Construct parts of standardized SETUP structure: */
+#define S626_SET_STD_INTSRC(x)	\
+	S626_MAKE((x), S626_STDWID_INTSRC, S626_STDBIT_INTSRC)
+#define S626_SET_STD_LATCHSRC(x)	\
+	S626_MAKE((x), S626_STDWID_LATCHSRC, S626_STDBIT_LATCHSRC)
+#define S626_SET_STD_LOADSRC(x)	\
+	S626_MAKE((x), S626_STDWID_LOADSRC, S626_STDBIT_LOADSRC)
+#define S626_SET_STD_INDXSRC(x)	\
+	S626_MAKE((x), S626_STDWID_INDXSRC, S626_STDBIT_INDXSRC)
+#define S626_SET_STD_INDXPOL(x)	\
+	S626_MAKE((x), S626_STDWID_INDXPOL, S626_STDBIT_INDXPOL)
+#define S626_SET_STD_ENCMODE(x)	\
+	S626_MAKE((x), S626_STDWID_ENCMODE, S626_STDBIT_ENCMODE)
+#define S626_SET_STD_CLKPOL(x)	\
+	S626_MAKE((x), S626_STDWID_CLKPOL, S626_STDBIT_CLKPOL)
+#define S626_SET_STD_CLKMULT(x)	\
+	S626_MAKE((x), S626_STDWID_CLKMULT, S626_STDBIT_CLKMULT)
+#define S626_SET_STD_CLKENAB(x)	\
+	S626_MAKE((x), S626_STDWID_CLKENAB, S626_STDBIT_CLKENAB)
+
+/* Extract parts of standardized SETUP structure: */
+#define S626_GET_STD_INTSRC(v)	\
+	S626_UNMAKE((v), S626_STDWID_INTSRC, S626_STDBIT_INTSRC)
+#define S626_GET_STD_LATCHSRC(v)	\
+	S626_UNMAKE((v), S626_STDWID_LATCHSRC, S626_STDBIT_LATCHSRC)
+#define S626_GET_STD_LOADSRC(v)	\
+	S626_UNMAKE((v), S626_STDWID_LOADSRC, S626_STDBIT_LOADSRC)
+#define S626_GET_STD_INDXSRC(v)	\
+	S626_UNMAKE((v), S626_STDWID_INDXSRC, S626_STDBIT_INDXSRC)
+#define S626_GET_STD_INDXPOL(v)	\
+	S626_UNMAKE((v), S626_STDWID_INDXPOL, S626_STDBIT_INDXPOL)
+#define S626_GET_STD_ENCMODE(v)	\
+	S626_UNMAKE((v), S626_STDWID_ENCMODE, S626_STDBIT_ENCMODE)
+#define S626_GET_STD_CLKPOL(v)	\
+	S626_UNMAKE((v), S626_STDWID_CLKPOL, S626_STDBIT_CLKPOL)
+#define S626_GET_STD_CLKMULT(v)	\
+	S626_UNMAKE((v), S626_STDWID_CLKMULT, S626_STDBIT_CLKMULT)
+#define S626_GET_STD_CLKENAB(v)	\
+	S626_UNMAKE((v), S626_STDWID_CLKENAB, S626_STDBIT_CLKENAB)
 
 #endif

commit e0b07b797c8aa820e96f533a9dab33d2e012f563
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Oct 18 14:40:54 2013 +0100

    staging: comedi: s626: add missing bits for 'CRB' register
    
    There are some bits in the 'CRB' register not defined in "s626.h".
    Three of these are read-only bits that overlay the write-only interrupt
    control bits.  Another missing bit controls whether counter 'B' is
    cleared when counter 'A' overflows.  Add the missing bit definitions for
    completeness.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index bdecdfbe6099..7f38de5f07f5 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -544,13 +544,17 @@
 #define S626_CRABIT_CNTSRC_A	 0	/* A counter source. */
 
 /* Bit field positions in CRB: */
-#define S626_CRBBIT_INTRESETCMD	15	/* Interrupt reset command. */
-#define S626_CRBBIT_INTRESET_B	14	/* B interrupt reset enable. */
-#define S626_CRBBIT_INTRESET_A	13	/* A interrupt reset enable. */
+#define S626_CRBBIT_INTRESETCMD	15	/* (w) Interrupt reset command. */
+#define S626_CRBBIT_CNTDIR_B	15	/* (r) B counter direction. */
+#define S626_CRBBIT_INTRESET_B	14	/* (w) B interrupt reset enable. */
+#define S626_CRBBIT_OVERDO_A	14	/* (r) A overflow routed to dig. out. */
+#define S626_CRBBIT_INTRESET_A	13	/* (w) A interrupt reset enable. */
+#define S626_CRBBIT_OVERDO_B	13	/* (r) B overflow routed to dig. out. */
 #define S626_CRBBIT_CLKENAB_A	12	/* A clock enable. */
 #define S626_CRBBIT_INTSRC_B	10	/* B interrupt source. */
 #define S626_CRBBIT_LATCHSRC	 8	/* A/B latch source. */
 #define S626_CRBBIT_LOADSRC_B	 6	/* B preload trigger. */
+#define S626_CRBBIT_CLEAR_B	 7	/* B cleared when A overflows. */
 #define S626_CRBBIT_CLKMULT_B	 3	/* B clock multiplier. */
 #define S626_CRBBIT_CLKENAB_B	 2	/* B clock enable. */
 #define S626_CRBBIT_INDXPOL_B	 1	/* B index polarity. */
@@ -569,12 +573,16 @@
 #define S626_CRAMSK_CNTSRC_A	(3 << S626_CRABIT_CNTSRC_A)
 
 #define S626_CRBMSK_INTRESETCMD	(1 << S626_CRBBIT_INTRESETCMD)
+#define S626_CRBMSK_CNTDIR_B	(1 << S626_CRBBIT_CNTDIR_B)
 #define S626_CRBMSK_INTRESET_B	(1 << S626_CRBBIT_INTRESET_B)
+#define S626_CRBMSK_OVERDO_A	(1 << S626_CRBBIT_OVERDO_A)
 #define S626_CRBMSK_INTRESET_A	(1 << S626_CRBBIT_INTRESET_A)
+#define S626_CRBMSK_OVERDO_B	(1 << S626_CRBBIT_OVERDO_B)
 #define S626_CRBMSK_CLKENAB_A	(1 << S626_CRBBIT_CLKENAB_A)
 #define S626_CRBMSK_INTSRC_B	(3 << S626_CRBBIT_INTSRC_B)
 #define S626_CRBMSK_LATCHSRC	(3 << S626_CRBBIT_LATCHSRC)
 #define S626_CRBMSK_LOADSRC_B	(3 << S626_CRBBIT_LOADSRC_B)
+#define S626_CRBMSK_CLEAR_B	(1 << S626_CRBBIT_CLEAR_B)
 #define S626_CRBMSK_CLKMULT_B	(3 << S626_CRBBIT_CLKMULT_B)
 #define S626_CRBMSK_CLKENAB_B	(1 << S626_CRBBIT_CLKENAB_B)
 #define S626_CRBMSK_INDXPOL_B	(1 << S626_CRBBIT_INDXPOL_B)

commit 9349399333c982396021f861b69355782d4e555e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Oct 18 14:40:53 2013 +0100

    staging: comedi: s626: correct S626_CRAMSK_CLKPOL_A macro (unused)
    
    The counter 'A' clock polarity field in the 'CRA' register is only 1 bit
    wide, but the `S626_CRAMSK_CLKPOL_A` macro shows it as 2 bits wide,
    which would overlap with the counter 'A' interrupt source field.  This
    is harmless as the macro isn't actually used yet, but correct it anyway
    as I want to use it!
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 5cb30afe476a..bdecdfbe6099 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -564,7 +564,7 @@
 #define S626_CRAMSK_LOADSRC_A	(3 << S626_CRABIT_LOADSRC_A)
 #define S626_CRAMSK_CLKMULT_A	(3 << S626_CRABIT_CLKMULT_A)
 #define S626_CRAMSK_INTSRC_A	(3 << S626_CRABIT_INTSRC_A)
-#define S626_CRAMSK_CLKPOL_A	(3 << S626_CRABIT_CLKPOL_A)
+#define S626_CRAMSK_CLKPOL_A	(1 << S626_CRABIT_CLKPOL_A)
 #define S626_CRAMSK_INDXSRC_A	(3 << S626_CRABIT_INDXSRC_A)
 #define S626_CRAMSK_CNTSRC_A	(3 << S626_CRABIT_CNTSRC_A)
 

commit 622ec01ab9e19729c43eb994003783cf5094fc09
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Oct 18 14:40:52 2013 +0100

    staging: comedi: s626: distinguish counter src from encoder mode
    
    The macros `S626_CLKSRC_COUNTER`, `S626_CLKSRC_TIMER` and
    `S626_CLKSRC_EXTENDER` are used logically to set the operating mode of
    an encoder channel.  `S626_CLKSRC_COUNTER` (0) is also used as a 2-bit
    physical value to set the counter source of an encoder channel to
    "encoder".
    
    Rename the macros to `S626_ENCMODE_COUNTER`, `S626_ENCMODE_TIMER` and
    `S626_ENCMODE_EXTENDER` and rename some other macros and (unused)
    functions relating to the encoder mode for consistency.
    
    Define new macros to specify the physical counter source values for the
    'CRA' register and rename the corresponding bitshift and mask macros
    accordingly.  The physical values for the counter source are:
    
      S626_CNTSRC_ENCODER = 0      // encoder
      S626_CNTSRC_DIGIN = 1        // digital inputs
      S626_CNTSRC_SYSCLK = 2       // system clock up
      S626_CNTSRC_SYSCLK_DOWN = 3  // system clock down
    
    Also use the `S626_CNTSRC_SYSCLK` value as a bitmask (bit 1) to indicate
    either of the system clock values, with the direction (bit 0) indicated
    separately in this case.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 9b6ab0d398d6..5cb30afe476a 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -469,10 +469,16 @@
 #define S626_INDXPOL_POS	0	/* Index input is active high. */
 #define S626_INDXPOL_NEG	1	/* Index input is active low. */
 
-/* ClkSrc values: */
-#define S626_CLKSRC_COUNTER	0	/* Counter mode. */
-#define S626_CLKSRC_TIMER	2	/* Timer mode. */
-#define S626_CLKSRC_EXTENDER	3	/* Extender mode. */
+/* Logical encoder mode values: */
+#define S626_ENCMODE_COUNTER	0	/* Counter mode. */
+#define S626_ENCMODE_TIMER	2	/* Timer mode. */
+#define S626_ENCMODE_EXTENDER	3	/* Extender mode. */
+
+/* Physical CntSrc values (for Counter A source and Counter B source): */
+#define S626_CNTSRC_ENCODER	0	/* Encoder */
+#define S626_CNTSRC_DIGIN	1	/* Digital inputs */
+#define S626_CNTSRC_SYSCLK	2	/* System clock up */
+#define S626_CNTSRC_SYSCLK_DOWN	3	/* System clock down */
 
 /* ClkPol values: */
 #define S626_CLKPOL_POS		0	/* Counter/Extender clock is
@@ -495,7 +501,7 @@
 #define S626_BF_LOADSRC		9	/* Preload trigger. */
 #define S626_BF_INDXSRC		7	/* Index source. */
 #define S626_BF_INDXPOL		6	/* Index polarity. */
-#define S626_BF_CLKSRC		4	/* Clock source. */
+#define S626_BF_ENCMODE		4	/* Encoder mode. */
 #define S626_BF_CLKPOL		3	/* Clock polarity/count direction. */
 #define S626_BF_CLKMULT		1	/* Clock multiplier. */
 #define S626_BF_CLKENAB		0	/* Clock enable. */
@@ -528,14 +534,14 @@
 
 /* Bit field positions in CRA: */
 #define S626_CRABIT_INDXSRC_B	14	/* B index source. */
-#define S626_CRABIT_CLKSRC_B	12	/* B clock source. */
+#define S626_CRABIT_CNTSRC_B	12	/* B counter source. */
 #define S626_CRABIT_INDXPOL_A	11	/* A index polarity. */
 #define S626_CRABIT_LOADSRC_A	 9	/* A preload trigger. */
 #define S626_CRABIT_CLKMULT_A	 7	/* A clock multiplier. */
 #define S626_CRABIT_INTSRC_A	 5	/* A interrupt source. */
 #define S626_CRABIT_CLKPOL_A	 4	/* A clock polarity. */
 #define S626_CRABIT_INDXSRC_A	 2	/* A index source. */
-#define S626_CRABIT_CLKSRC_A	 0	/* A clock source. */
+#define S626_CRABIT_CNTSRC_A	 0	/* A counter source. */
 
 /* Bit field positions in CRB: */
 #define S626_CRBBIT_INTRESETCMD	15	/* Interrupt reset command. */
@@ -553,14 +559,14 @@
 /* Bit field masks for CRA and CRB. */
 
 #define S626_CRAMSK_INDXSRC_B	(3 << S626_CRABIT_INDXSRC_B)
-#define S626_CRAMSK_CLKSRC_B	(3 << S626_CRABIT_CLKSRC_B)
+#define S626_CRAMSK_CNTSRC_B	(3 << S626_CRABIT_CNTSRC_B)
 #define S626_CRAMSK_INDXPOL_A	(1 << S626_CRABIT_INDXPOL_A)
 #define S626_CRAMSK_LOADSRC_A	(3 << S626_CRABIT_LOADSRC_A)
 #define S626_CRAMSK_CLKMULT_A	(3 << S626_CRABIT_CLKMULT_A)
 #define S626_CRAMSK_INTSRC_A	(3 << S626_CRABIT_INTSRC_A)
 #define S626_CRAMSK_CLKPOL_A	(3 << S626_CRABIT_CLKPOL_A)
 #define S626_CRAMSK_INDXSRC_A	(3 << S626_CRABIT_INDXSRC_A)
-#define S626_CRAMSK_CLKSRC_A	(3 << S626_CRABIT_CLKSRC_A)
+#define S626_CRAMSK_CNTSRC_A	(3 << S626_CRABIT_CNTSRC_A)
 
 #define S626_CRBMSK_INTRESETCMD	(1 << S626_CRBBIT_INTRESETCMD)
 #define S626_CRBMSK_INTRESET_B	(1 << S626_CRBBIT_INTRESET_B)
@@ -586,7 +592,7 @@
 #define S626_STDBIT_LOADSRC	 9
 #define S626_STDBIT_INDXSRC	 7
 #define S626_STDBIT_INDXPOL	 6
-#define S626_STDBIT_CLKSRC	 4
+#define S626_STDBIT_ENCMODE	 4
 #define S626_STDBIT_CLKPOL	 3
 #define S626_STDBIT_CLKMULT	 1
 #define S626_STDBIT_CLKENAB	 0
@@ -598,7 +604,7 @@
 #define S626_STDMSK_LOADSRC	(3 << S626_STDBIT_LOADSRC)
 #define S626_STDMSK_INDXSRC	(1 << S626_STDBIT_INDXSRC)
 #define S626_STDMSK_INDXPOL	(1 << S626_STDBIT_INDXPOL)
-#define S626_STDMSK_CLKSRC	(3 << S626_STDBIT_CLKSRC)
+#define S626_STDMSK_ENCMODE	(3 << S626_STDBIT_ENCMODE)
 #define S626_STDMSK_CLKPOL	(1 << S626_STDBIT_CLKPOL)
 #define S626_STDMSK_CLKMULT	(3 << S626_STDBIT_CLKMULT)
 #define S626_STDMSK_CLKENAB	(1 << S626_STDBIT_CLKENAB)

commit d8515652ef01afb323dbdd87499c2c950ec9d324
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:42 2013 +0100

    staging: comedi: s626: prefix macros in s626.h
    
    Prefix the names of all the macros defined in "s626.h" with `S626_`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 605926ed861b..9b6ab0d398d6 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -22,8 +22,7 @@
 #ifndef S626_H_INCLUDED
 #define S626_H_INCLUDED
 
-#define S626_SIZE		0x200
-#define DMABUF_SIZE		4096	/* 4k pages */
+#define S626_DMABUF_SIZE	4096	/* 4k pages */
 
 #define S626_ADC_CHANNELS       16
 #define S626_DAC_CHANNELS       4
@@ -33,585 +32,575 @@
 #define S626_DIO_EXTCHANS	40	/* Number of extended-capability
 					 * DIO channels. */
 
-#define NUM_TRIMDACS		12	/* Number of valid TrimDAC channels. */
+#define S626_NUM_TRIMDACS	12	/* Number of valid TrimDAC channels. */
 
 /* PCI bus interface types. */
-#define INTEL			1	/* Intel bus type. */
-#define MOTOROLA		2	/* Motorola bus type. */
+#define S626_INTEL		1	/* Intel bus type. */
+#define S626_MOTOROLA		2	/* Motorola bus type. */
 
-#define PLATFORM		INTEL	/* *** SELECT PLATFORM TYPE *** */
+#define S626_PLATFORM		S626_INTEL /* *** SELECT PLATFORM TYPE *** */
 
-#define RANGE_5V                0x10	/* +/-5V range */
-#define RANGE_10V               0x00	/* +/-10V range */
+#define S626_RANGE_5V		0x10	/* +/-5V range */
+#define S626_RANGE_10V		0x00	/* +/-10V range */
 
-#define EOPL			0x80	/* End of ADC poll list marker. */
-#define GSEL_BIPOLAR5V		0x00F0	/* LP_GSEL setting for 5V bipolar. */
-#define GSEL_BIPOLAR10V		0x00A0	/* LP_GSEL setting for 10V bipolar. */
+#define S626_EOPL		0x80	/* End of ADC poll list marker. */
+#define S626_GSEL_BIPOLAR5V	0x00F0	/* S626_LP_GSEL setting 5V bipolar. */
+#define S626_GSEL_BIPOLAR10V	0x00A0	/* S626_LP_GSEL setting 10V bipolar. */
 
 /* Error codes that must be visible to this base class. */
-#define ERR_ILLEGAL_PARM	0x00010000	/* Illegal function parameter
+#define S626_ERR_ILLEGAL_PARM	0x00010000	/* Illegal function parameter
 						 * value was specified. */
-#define ERR_I2C			0x00020000	/* I2C error. */
-#define ERR_COUNTERSETUP	0x00200000	/* Illegal setup specified for
+#define S626_ERR_I2C		0x00020000	/* I2C error. */
+#define S626_ERR_COUNTERSETUP	0x00200000	/* Illegal setup specified for
 						 * counter channel. */
-#define ERR_DEBI_TIMEOUT	0x00400000	/* DEBI transfer timed out. */
+#define S626_ERR_DEBI_TIMEOUT	0x00400000	/* DEBI transfer timed out. */
 
 /*
  * Organization (physical order) and size (in DWORDs) of logical DMA buffers
  * contained by ANA_DMABUF.
  */
-#define ADC_DMABUF_DWORDS	40	/* ADC DMA buffer must hold 16 samples,
+#define S626_ADC_DMABUF_DWORDS	40	/* ADC DMA buffer must hold 16 samples,
 					 * plus pre/post garbage samples. */
-#define DAC_WDMABUF_DWORDS	1	/* DAC output DMA buffer holds a single
+#define S626_DAC_WDMABUF_DWORDS	1	/* DAC output DMA buffer holds a single
 					 * sample. */
 
 /* All remaining space in 4KB DMA buffer is available for the RPS1 program. */
 
 /* Address offsets, in DWORDS, from base of DMA buffer. */
-#define DAC_WDMABUF_OS		ADC_DMABUF_DWORDS
+#define S626_DAC_WDMABUF_OS	S626_ADC_DMABUF_DWORDS
 
 /*  Interrupt enable bit in ISR and IER. */
-#define IRQ_GPIO3		0x00000040	/* IRQ enable for GPIO3. */
-#define IRQ_RPS1                0x10000000
-#define ISR_AFOU		0x00000800
+#define S626_IRQ_GPIO3		0x00000040	/* IRQ enable for GPIO3. */
+#define S626_IRQ_RPS1		0x10000000
+#define S626_ISR_AFOU		0x00000800
 /* Audio fifo under/overflow  detected. */
 
-#define IRQ_COINT1A             0x0400	/* counter 1A overflow interrupt mask */
-#define IRQ_COINT1B             0x0800	/* counter 1B overflow interrupt mask */
-#define IRQ_COINT2A             0x1000	/* counter 2A overflow interrupt mask */
-#define IRQ_COINT2B             0x2000	/* counter 2B overflow interrupt mask */
-#define IRQ_COINT3A             0x4000	/* counter 3A overflow interrupt mask */
-#define IRQ_COINT3B             0x8000	/* counter 3B overflow interrupt mask */
+#define S626_IRQ_COINT1A	0x0400	/* counter 1A overflow interrupt mask */
+#define S626_IRQ_COINT1B	0x0800	/* counter 1B overflow interrupt mask */
+#define S626_IRQ_COINT2A	0x1000	/* counter 2A overflow interrupt mask */
+#define S626_IRQ_COINT2B	0x2000	/* counter 2B overflow interrupt mask */
+#define S626_IRQ_COINT3A	0x4000	/* counter 3A overflow interrupt mask */
+#define S626_IRQ_COINT3B	0x8000	/* counter 3B overflow interrupt mask */
 
 /* RPS command codes. */
-#define RPS_CLRSIGNAL		0x00000000	/* CLEAR SIGNAL */
-#define RPS_SETSIGNAL		0x10000000	/* SET SIGNAL */
-#define RPS_NOP			0x00000000	/* NOP */
-#define RPS_PAUSE		0x20000000	/* PAUSE */
-#define RPS_UPLOAD		0x40000000	/* UPLOAD */
-#define RPS_JUMP		0x80000000	/* JUMP */
-#define RPS_LDREG		0x90000100	/* LDREG (1 uint32_t only) */
-#define RPS_STREG		0xA0000100	/* STREG (1 uint32_t only) */
-#define RPS_STOP		0x50000000	/* STOP */
-#define RPS_IRQ                 0x60000000	/* IRQ */
-
-#define RPS_LOGICAL_OR		0x08000000	/* Logical OR conditionals. */
-#define RPS_INVERT		0x04000000	/* Test for negated
+#define S626_RPS_CLRSIGNAL	0x00000000	/* CLEAR SIGNAL */
+#define S626_RPS_SETSIGNAL	0x10000000	/* SET SIGNAL */
+#define S626_RPS_NOP		0x00000000	/* NOP */
+#define S626_RPS_PAUSE		0x20000000	/* PAUSE */
+#define S626_RPS_UPLOAD		0x40000000	/* UPLOAD */
+#define S626_RPS_JUMP		0x80000000	/* JUMP */
+#define S626_RPS_LDREG		0x90000100	/* LDREG (1 uint32_t only) */
+#define S626_RPS_STREG		0xA0000100	/* STREG (1 uint32_t only) */
+#define S626_RPS_STOP		0x50000000	/* STOP */
+#define S626_RPS_IRQ		0x60000000	/* IRQ */
+
+#define S626_RPS_LOGICAL_OR	0x08000000	/* Logical OR conditionals. */
+#define S626_RPS_INVERT		0x04000000	/* Test for negated
 						 * semaphores. */
-#define RPS_DEBI		0x00000002	/* DEBI done */
+#define S626_RPS_DEBI		0x00000002	/* DEBI done */
 
-#define RPS_SIG0		0x00200000	/* RPS semaphore 0
+#define S626_RPS_SIG0		0x00200000	/* RPS semaphore 0
 						 * (used by ADC). */
-#define RPS_SIG1		0x00400000	/* RPS semaphore 1
+#define S626_RPS_SIG1		0x00400000	/* RPS semaphore 1
 						 * (used by DAC). */
-#define RPS_SIG2		0x00800000	/* RPS semaphore 2
+#define S626_RPS_SIG2		0x00800000	/* RPS semaphore 2
 						 * (not used). */
-#define RPS_GPIO2		0x00080000	/* RPS GPIO2 */
-#define RPS_GPIO3		0x00100000	/* RPS GPIO3 */
+#define S626_RPS_GPIO2		0x00080000	/* RPS GPIO2 */
+#define S626_RPS_GPIO3		0x00100000	/* RPS GPIO3 */
 
-#define RPS_SIGADC		RPS_SIG0	/* Trigger/status for
+#define S626_RPS_SIGADC		S626_RPS_SIG0	/* Trigger/status for
 						 * ADC's RPS program. */
-#define RPS_SIGDAC		RPS_SIG1	/* Trigger/status for
+#define S626_RPS_SIGDAC		S626_RPS_SIG1	/* Trigger/status for
 						 * DAC's RPS program. */
 
 /* RPS clock parameters. */
-#define RPSCLK_SCALAR		8	/* This is apparent ratio of
+#define S626_RPSCLK_SCALAR	8	/* This is apparent ratio of
 					 * PCI/RPS clks (undocumented!!). */
-#define RPSCLK_PER_US		(33 / RPSCLK_SCALAR)
+#define S626_RPSCLK_PER_US	(33 / S626_RPSCLK_SCALAR)
 					/* Number of RPS clocks in one
 					 * microsecond. */
 
 /* Event counter source addresses. */
-#define SBA_RPS_A0		0x27	/* Time of RPS0 busy, in PCI clocks. */
+#define S626_SBA_RPS_A0		0x27	/* Time of RPS0 busy, in PCI clocks. */
 
 /* GPIO constants. */
-#define GPIO_BASE		0x10004000	/* GPIO 0,2,3 = inputs,
+#define S626_GPIO_BASE		0x10004000	/* GPIO 0,2,3 = inputs,
 						 * GPIO3 = IRQ; GPIO1 = out. */
-#define GPIO1_LO		0x00000000	/* GPIO1 set to LOW. */
-#define GPIO1_HI		0x00001000	/* GPIO1 set to HIGH. */
+#define S626_GPIO1_LO		0x00000000	/* GPIO1 set to LOW. */
+#define S626_GPIO1_HI		0x00001000	/* GPIO1 set to HIGH. */
 
 /* Primary Status Register (PSR) constants. */
-#define PSR_DEBI_E		0x00040000	/* DEBI event flag. */
-#define PSR_DEBI_S		0x00080000	/* DEBI status flag. */
-#define PSR_A2_IN		0x00008000	/* Audio output DMA2 protection
+#define S626_PSR_DEBI_E		0x00040000	/* DEBI event flag. */
+#define S626_PSR_DEBI_S		0x00080000	/* DEBI status flag. */
+#define S626_PSR_A2_IN		0x00008000	/* Audio output DMA2 protection
 						 * address reached. */
-#define PSR_AFOU		0x00000800	/* Audio FIFO under/overflow
+#define S626_PSR_AFOU		0x00000800	/* Audio FIFO under/overflow
 						 * detected. */
-#define PSR_GPIO2		0x00000020	/* GPIO2 input pin: 0=AdcBusy,
+#define S626_PSR_GPIO2		0x00000020	/* GPIO2 input pin: 0=AdcBusy,
 						 * 1=AdcIdle. */
-#define PSR_EC0S		0x00000001	/* Event counter 0 threshold
+#define S626_PSR_EC0S		0x00000001	/* Event counter 0 threshold
 						 * reached. */
 
 /* Secondary Status Register (SSR) constants. */
-#define SSR_AF2_OUT		0x00000200	/* Audio 2 output FIFO
+#define S626_SSR_AF2_OUT	0x00000200	/* Audio 2 output FIFO
 						 * under/overflow detected. */
 
 /* Master Control Register 1 (MC1) constants. */
-#define MC1_SOFT_RESET		0x80000000	/* Invoke 7146 soft reset. */
-#define MC1_SHUTDOWN		0x3FFF0000	/* Shut down all MC1-controlled
+#define S626_MC1_SOFT_RESET	0x80000000	/* Invoke 7146 soft reset. */
+#define S626_MC1_SHUTDOWN	0x3FFF0000	/* Shut down all MC1-controlled
 						 * enables. */
 
-#define MC1_ERPS1		0x2000	/* Enab/disable RPS task 1. */
-#define MC1_ERPS0		0x1000	/* Enab/disable RPS task 0. */
-#define MC1_DEBI		0x0800	/* Enab/disable DEBI pins. */
-#define MC1_AUDIO		0x0200	/* Enab/disable audio port pins. */
-#define MC1_I2C			0x0100	/* Enab/disable I2C interface. */
-#define MC1_A2OUT		0x0008	/* Enab/disable transfer on A2 out. */
-#define MC1_A2IN		0x0004	/* Enab/disable transfer on A2 in. */
-#define MC1_A1IN		0x0001	/* Enab/disable transfer on A1 in. */
+#define S626_MC1_ERPS1		0x2000	/* Enab/disable RPS task 1. */
+#define S626_MC1_ERPS0		0x1000	/* Enab/disable RPS task 0. */
+#define S626_MC1_DEBI		0x0800	/* Enab/disable DEBI pins. */
+#define S626_MC1_AUDIO		0x0200	/* Enab/disable audio port pins. */
+#define S626_MC1_I2C		0x0100	/* Enab/disable I2C interface. */
+#define S626_MC1_A2OUT		0x0008	/* Enab/disable transfer on A2 out. */
+#define S626_MC1_A2IN		0x0004	/* Enab/disable transfer on A2 in. */
+#define S626_MC1_A1IN		0x0001	/* Enab/disable transfer on A1 in. */
 
 /* Master Control Register 2 (MC2) constants. */
-#define MC2_UPLD_DEBI		0x0002	/* Upload DEBI. */
-#define MC2_UPLD_IIC		0x0001	/* Upload I2C. */
-#define MC2_RPSSIG2		0x2000	/* RPS signal 2 (not used). */
-#define MC2_RPSSIG1		0x1000	/* RPS signal 1 (DAC RPS busy). */
-#define MC2_RPSSIG0		0x0800	/* RPS signal 0 (ADC RPS busy). */
+#define S626_MC2_UPLD_DEBI	0x0002	/* Upload DEBI. */
+#define S626_MC2_UPLD_IIC	0x0001	/* Upload I2C. */
+#define S626_MC2_RPSSIG2	0x2000	/* RPS signal 2 (not used). */
+#define S626_MC2_RPSSIG1	0x1000	/* RPS signal 1 (DAC RPS busy). */
+#define S626_MC2_RPSSIG0	0x0800	/* RPS signal 0 (ADC RPS busy). */
 
-#define MC2_ADC_RPS		MC2_RPSSIG0	/* ADC RPS busy. */
-#define MC2_DAC_RPS		MC2_RPSSIG1	/* DAC RPS busy. */
+#define S626_MC2_ADC_RPS	S626_MC2_RPSSIG0	/* ADC RPS busy. */
+#define S626_MC2_DAC_RPS	S626_MC2_RPSSIG1	/* DAC RPS busy. */
 
 /* PCI BUS (SAA7146) REGISTER ADDRESS OFFSETS */
-#define P_PCI_BT_A		0x004C	/* Audio DMA burst/threshold control. */
-#define P_DEBICFG               0x007C	/* DEBI configuration. */
-#define P_DEBICMD               0x0080	/* DEBI command. */
-#define P_DEBIPAGE              0x0084	/* DEBI page. */
-#define P_DEBIAD                0x0088	/* DEBI target address. */
-#define P_I2CCTRL               0x008C	/* I2C control. */
-#define P_I2CSTAT               0x0090	/* I2C status. */
-#define P_BASEA2_IN		0x00AC	/* Audio input 2 base physical DMAbuf
+#define S626_P_PCI_BT_A		0x004C	/* Audio DMA burst/threshold control. */
+#define S626_P_DEBICFG		0x007C	/* DEBI configuration. */
+#define S626_P_DEBICMD		0x0080	/* DEBI command. */
+#define S626_P_DEBIPAGE		0x0084	/* DEBI page. */
+#define S626_P_DEBIAD		0x0088	/* DEBI target address. */
+#define S626_P_I2CCTRL		0x008C	/* I2C control. */
+#define S626_P_I2CSTAT		0x0090	/* I2C status. */
+#define S626_P_BASEA2_IN	0x00AC	/* Audio input 2 base physical DMAbuf
 					 * address. */
-#define P_PROTA2_IN		0x00B0	/* Audio input 2 physical DMAbuf
+#define S626_P_PROTA2_IN	0x00B0	/* Audio input 2 physical DMAbuf
 					 * protection address. */
-#define P_PAGEA2_IN		0x00B4	/* Audio input 2 paging attributes. */
-#define P_BASEA2_OUT		0x00B8	/* Audio output 2 base physical DMAbuf
+#define S626_P_PAGEA2_IN	0x00B4	/* Audio input 2 paging attributes. */
+#define S626_P_BASEA2_OUT	0x00B8	/* Audio output 2 base physical DMAbuf
 					 * address. */
-#define P_PROTA2_OUT		0x00BC	/* Audio output 2 physical DMAbuf
+#define S626_P_PROTA2_OUT	0x00BC	/* Audio output 2 physical DMAbuf
 					 * protection address. */
-#define P_PAGEA2_OUT		0x00C0	/* Audio output 2 paging attributes. */
-#define P_RPSPAGE0              0x00C4	/* RPS0 page. */
-#define P_RPSPAGE1              0x00C8	/* RPS1 page. */
-#define P_RPS0_TOUT		0x00D4	/* RPS0 time-out. */
-#define P_RPS1_TOUT		0x00D8	/* RPS1 time-out. */
-#define P_IER                   0x00DC	/* Interrupt enable. */
-#define P_GPIO                  0x00E0	/* General-purpose I/O. */
-#define P_EC1SSR		0x00E4	/* Event counter set 1 source select. */
-#define P_ECT1R			0x00EC	/* Event counter threshold set 1. */
-#define P_ACON1                 0x00F4	/* Audio control 1. */
-#define P_ACON2                 0x00F8	/* Audio control 2. */
-#define P_MC1                   0x00FC	/* Master control 1. */
-#define P_MC2                   0x0100	/* Master control 2. */
-#define P_RPSADDR0              0x0104	/* RPS0 instruction pointer. */
-#define P_RPSADDR1              0x0108	/* RPS1 instruction pointer. */
-#define P_ISR                   0x010C	/* Interrupt status. */
-#define P_PSR                   0x0110	/* Primary status. */
-#define P_SSR                   0x0114	/* Secondary status. */
-#define P_EC1R			0x0118	/* Event counter set 1. */
-#define P_ADP4			0x0138	/* Logical audio DMA pointer of audio
+#define S626_P_PAGEA2_OUT	0x00C0	/* Audio output 2 paging attributes. */
+#define S626_P_RPSPAGE0		0x00C4	/* RPS0 page. */
+#define S626_P_RPSPAGE1		0x00C8	/* RPS1 page. */
+#define S626_P_RPS0_TOUT	0x00D4	/* RPS0 time-out. */
+#define S626_P_RPS1_TOUT	0x00D8	/* RPS1 time-out. */
+#define S626_P_IER		0x00DC	/* Interrupt enable. */
+#define S626_P_GPIO		0x00E0	/* General-purpose I/O. */
+#define S626_P_EC1SSR		0x00E4	/* Event counter set 1 source select. */
+#define S626_P_ECT1R		0x00EC	/* Event counter threshold set 1. */
+#define S626_P_ACON1		0x00F4	/* Audio control 1. */
+#define S626_P_ACON2		0x00F8	/* Audio control 2. */
+#define S626_P_MC1		0x00FC	/* Master control 1. */
+#define S626_P_MC2		0x0100	/* Master control 2. */
+#define S626_P_RPSADDR0		0x0104	/* RPS0 instruction pointer. */
+#define S626_P_RPSADDR1		0x0108	/* RPS1 instruction pointer. */
+#define S626_P_ISR		0x010C	/* Interrupt status. */
+#define S626_P_PSR		0x0110	/* Primary status. */
+#define S626_P_SSR		0x0114	/* Secondary status. */
+#define S626_P_EC1R		0x0118	/* Event counter set 1. */
+#define S626_P_ADP4		0x0138	/* Logical audio DMA pointer of audio
 					 * input FIFO A2_IN. */
-#define P_FB_BUFFER1            0x0144	/* Audio feedback buffer 1. */
-#define P_FB_BUFFER2            0x0148	/* Audio feedback buffer 2. */
-#define P_TSL1                  0x0180	/* Audio time slot list 1. */
-#define P_TSL2                  0x01C0	/* Audio time slot list 2. */
+#define S626_P_FB_BUFFER1	0x0144	/* Audio feedback buffer 1. */
+#define S626_P_FB_BUFFER2	0x0148	/* Audio feedback buffer 2. */
+#define S626_P_TSL1		0x0180	/* Audio time slot list 1. */
+#define S626_P_TSL2		0x01C0	/* Audio time slot list 2. */
 
 /* LOCAL BUS (GATE ARRAY) REGISTER ADDRESS OFFSETS */
 /* Analog I/O registers: */
-#define LP_DACPOL		0x0082	/* Write DAC polarity. */
-#define LP_GSEL			0x0084	/* Write ADC gain. */
-#define LP_ISEL			0x0086	/* Write ADC channel select. */
+#define S626_LP_DACPOL		0x0082	/* Write DAC polarity. */
+#define S626_LP_GSEL		0x0084	/* Write ADC gain. */
+#define S626_LP_ISEL		0x0086	/* Write ADC channel select. */
 
 /* Digital I/O registers */
-#define LP_RDDIN(x)		(0x0040 + (x) * 0x10)	/* R: digital input */
-#define LP_WRINTSEL(x)		(0x0042 + (x) * 0x10)	/* W: int enable */
-#define LP_WREDGSEL(x)		(0x0044 + (x) * 0x10)	/* W: edge selection */
-#define LP_WRCAPSEL(x)		(0x0046 + (x) * 0x10)	/* W: capture enable */
-#define LP_RDCAPFLG(x)		(0x0048 + (x) * 0x10)	/* R: edges captured */
-#define LP_WRDOUT(x)		(0x0048 + (x) * 0x10)	/* W: digital output */
-#define LP_RDINTSEL(x)		(0x004a + (x) * 0x10)	/* R: int enable */
-#define LP_RDEDGSEL(x)		(0x004c + (x) * 0x10)	/* R: edge selection */
-#define LP_RDCAPSEL(x)		(0x004e + (x) * 0x10)	/* R: capture enable */
+#define S626_LP_RDDIN(x)	(0x0040 + (x) * 0x10)	/* R: digital input */
+#define S626_LP_WRINTSEL(x)	(0x0042 + (x) * 0x10)	/* W: int enable */
+#define S626_LP_WREDGSEL(x)	(0x0044 + (x) * 0x10)	/* W: edge selection */
+#define S626_LP_WRCAPSEL(x)	(0x0046 + (x) * 0x10)	/* W: capture enable */
+#define S626_LP_RDCAPFLG(x)	(0x0048 + (x) * 0x10)	/* R: edges captured */
+#define S626_LP_WRDOUT(x)	(0x0048 + (x) * 0x10)	/* W: digital output */
+#define S626_LP_RDINTSEL(x)	(0x004a + (x) * 0x10)	/* R: int enable */
+#define S626_LP_RDEDGSEL(x)	(0x004c + (x) * 0x10)	/* R: edge selection */
+#define S626_LP_RDCAPSEL(x)	(0x004e + (x) * 0x10)	/* R: capture enable */
 
 /* Counter Registers (read/write): */
-#define LP_CR0A			0x0000	/* 0A setup register. */
-#define LP_CR0B			0x0002	/* 0B setup register. */
-#define LP_CR1A			0x0004	/* 1A setup register. */
-#define LP_CR1B			0x0006	/* 1B setup register. */
-#define LP_CR2A			0x0008	/* 2A setup register. */
-#define LP_CR2B			0x000A	/* 2B setup register. */
+#define S626_LP_CR0A		0x0000	/* 0A setup register. */
+#define S626_LP_CR0B		0x0002	/* 0B setup register. */
+#define S626_LP_CR1A		0x0004	/* 1A setup register. */
+#define S626_LP_CR1B		0x0006	/* 1B setup register. */
+#define S626_LP_CR2A		0x0008	/* 2A setup register. */
+#define S626_LP_CR2B		0x000A	/* 2B setup register. */
 
 /* Counter PreLoad (write) and Latch (read) Registers: */
-#define	LP_CNTR0ALSW		0x000C	/* 0A lsw. */
-#define	LP_CNTR0AMSW		0x000E	/* 0A msw. */
-#define	LP_CNTR0BLSW		0x0010	/* 0B lsw. */
-#define	LP_CNTR0BMSW		0x0012	/* 0B msw. */
-#define	LP_CNTR1ALSW		0x0014	/* 1A lsw. */
-#define	LP_CNTR1AMSW		0x0016	/* 1A msw. */
-#define	LP_CNTR1BLSW		0x0018	/* 1B lsw. */
-#define	LP_CNTR1BMSW		0x001A	/* 1B msw. */
-#define	LP_CNTR2ALSW		0x001C	/* 2A lsw. */
-#define	LP_CNTR2AMSW		0x001E	/* 2A msw. */
-#define	LP_CNTR2BLSW		0x0020	/* 2B lsw. */
-#define	LP_CNTR2BMSW		0x0022	/* 2B msw. */
+#define	S626_LP_CNTR0ALSW	0x000C	/* 0A lsw. */
+#define	S626_LP_CNTR0AMSW	0x000E	/* 0A msw. */
+#define	S626_LP_CNTR0BLSW	0x0010	/* 0B lsw. */
+#define	S626_LP_CNTR0BMSW	0x0012	/* 0B msw. */
+#define	S626_LP_CNTR1ALSW	0x0014	/* 1A lsw. */
+#define	S626_LP_CNTR1AMSW	0x0016	/* 1A msw. */
+#define	S626_LP_CNTR1BLSW	0x0018	/* 1B lsw. */
+#define	S626_LP_CNTR1BMSW	0x001A	/* 1B msw. */
+#define	S626_LP_CNTR2ALSW	0x001C	/* 2A lsw. */
+#define	S626_LP_CNTR2AMSW	0x001E	/* 2A msw. */
+#define	S626_LP_CNTR2BLSW	0x0020	/* 2B lsw. */
+#define	S626_LP_CNTR2BMSW	0x0022	/* 2B msw. */
 
 /* Miscellaneous Registers (read/write): */
-#define LP_MISC1		0x0088	/* Read/write Misc1. */
-#define LP_WRMISC2		0x0090	/* Write Misc2. */
-#define LP_RDMISC2		0x0082	/* Read Misc2. */
+#define S626_LP_MISC1		0x0088	/* Read/write Misc1. */
+#define S626_LP_WRMISC2		0x0090	/* Write Misc2. */
+#define S626_LP_RDMISC2		0x0082	/* Read Misc2. */
 
 /* Bit masks for MISC1 register that are the same for reads and writes. */
-#define MISC1_WENABLE		0x8000	/* enab writes to MISC2 (except Clear
+#define S626_MISC1_WENABLE	0x8000	/* enab writes to MISC2 (except Clear
 					 * Watchdog bit). */
-#define MISC1_WDISABLE		0x0000	/* Disable writes to MISC2. */
-#define MISC1_EDCAP		0x1000	/* Enable edge capture on DIO chans
-					 * specified by  LP_WRCAPSELx. */
-#define MISC1_NOEDCAP		0x0000	/* Disable edge capture on specified
+#define S626_MISC1_WDISABLE	0x0000	/* Disable writes to MISC2. */
+#define S626_MISC1_EDCAP	0x1000	/* Enable edge capture on DIO chans
+					 * specified by S626_LP_WRCAPSELx. */
+#define S626_MISC1_NOEDCAP	0x0000	/* Disable edge capture on specified
 					 * DIO chans. */
 
 /* Bit masks for MISC1 register reads. */
-#define RDMISC1_WDTIMEOUT	0x4000	/* Watchdog timer timed out. */
+#define S626_RDMISC1_WDTIMEOUT	0x4000	/* Watchdog timer timed out. */
 
 /* Bit masks for MISC2 register writes. */
-#define WRMISC2_WDCLEAR		0x8000	/* Reset watchdog timer to zero. */
-#define WRMISC2_CHARGE_ENABLE	0x4000	/* Enable battery trickle charging. */
+#define S626_WRMISC2_WDCLEAR	0x8000	/* Reset watchdog timer to zero. */
+#define S626_WRMISC2_CHARGE_ENABLE 0x4000 /* Enable battery trickle charging. */
 
 /* Bit masks for MISC2 register that are the same for reads and writes. */
-#define MISC2_BATT_ENABLE	0x0008	/* Backup battery enable. */
-#define MISC2_WDENABLE		0x0004	/* Watchdog timer enable. */
-#define MISC2_WDPERIOD_MASK	0x0003	/* Watchdog interval select mask. */
+#define S626_MISC2_BATT_ENABLE	0x0008	/* Backup battery enable. */
+#define S626_MISC2_WDENABLE	0x0004	/* Watchdog timer enable. */
+#define S626_MISC2_WDPERIOD_MASK 0x0003	/* Watchdog interval select mask. */
 
 /* Bit masks for ACON1 register. */
-#define A2_RUN			0x40000000	/* Run A2 based on TSL2. */
-#define A1_RUN			0x20000000	/* Run A1 based on TSL1. */
-#define A1_SWAP			0x00200000	/* Use big-endian for A1. */
-#define A2_SWAP			0x00100000	/* Use big-endian for A2. */
-#define WS_MODES		0x00019999	/* WS0 = TSL1 trigger input,
+#define S626_A2_RUN		0x40000000	/* Run A2 based on TSL2. */
+#define S626_A1_RUN		0x20000000	/* Run A1 based on TSL1. */
+#define S626_A1_SWAP		0x00200000	/* Use big-endian for A1. */
+#define S626_A2_SWAP		0x00100000	/* Use big-endian for A2. */
+#define S626_WS_MODES		0x00019999	/* WS0 = TSL1 trigger input,
 						 * WS1-WS4 = CS* outputs. */
 
-#if PLATFORM == INTEL		/* Base ACON1 config: always run A1 based
-				 * on TSL1. */
-#define ACON1_BASE		(WS_MODES | A1_RUN)
-#elif PLATFORM == MOTOROLA
-#define ACON1_BASE		(WS_MODES | A1_RUN | A1_SWAP | A2_SWAP)
+#if S626_PLATFORM == S626_INTEL		/* Base ACON1 config: always run
+					 * A1 based on TSL1. */
+#define S626_ACON1_BASE		(S626_WS_MODES | S626_A1_RUN)
+#elif S626_PLATFORM == S626_MOTOROLA
+#define S626_ACON1_BASE		\
+	(S626_WS_MODES | S626_A1_RUN | S626_A1_SWAP | S626_A2_SWAP)
 #endif
 
-#define ACON1_ADCSTART		ACON1_BASE	/* Start ADC: run A1
+#define S626_ACON1_ADCSTART	S626_ACON1_BASE	/* Start ADC: run A1
 						 * based on TSL1. */
-#define ACON1_DACSTART		(ACON1_BASE | A2_RUN)
+#define S626_ACON1_DACSTART	(S626_ACON1_BASE | S626_A2_RUN)
 /* Start transmit to DAC: run A2 based on TSL2. */
-#define ACON1_DACSTOP		ACON1_BASE	/* Halt A2. */
+#define S626_ACON1_DACSTOP	S626_ACON1_BASE	/* Halt A2. */
 
 /* Bit masks for ACON2 register. */
-#define A1_CLKSRC_BCLK1		0x00000000	/* A1 bit rate = BCLK1 (ADC). */
-#define A2_CLKSRC_X1		0x00800000	/* A2 bit rate = ACLK/1
+#define S626_A1_CLKSRC_BCLK1	0x00000000	/* A1 bit rate = BCLK1 (ADC). */
+#define S626_A2_CLKSRC_X1	0x00800000	/* A2 bit rate = ACLK/1
 						 * (DACs). */
-#define A2_CLKSRC_X2		0x00C00000	/* A2 bit rate = ACLK/2
+#define S626_A2_CLKSRC_X2	0x00C00000	/* A2 bit rate = ACLK/2
 						 * (DACs). */
-#define A2_CLKSRC_X4		0x01400000	/* A2 bit rate = ACLK/4
+#define S626_A2_CLKSRC_X4	0x01400000	/* A2 bit rate = ACLK/4
 						 * (DACs). */
-#define INVERT_BCLK2		0x00100000	/* Invert BCLK2 (DACs). */
-#define BCLK2_OE		0x00040000	/* Enable BCLK2 (DACs). */
-#define ACON2_XORMASK		0x000C0000	/* XOR mask for ACON2
+#define S626_INVERT_BCLK2	0x00100000	/* Invert BCLK2 (DACs). */
+#define S626_BCLK2_OE		0x00040000	/* Enable BCLK2 (DACs). */
+#define S626_ACON2_XORMASK	0x000C0000	/* XOR mask for ACON2
 						 * active-low bits. */
 
-#define ACON2_INIT		(ACON2_XORMASK ^ \
-				 (A1_CLKSRC_BCLK1 | A2_CLKSRC_X2 | \
-				  INVERT_BCLK2 | BCLK2_OE))
+#define S626_ACON2_INIT		(S626_ACON2_XORMASK ^ \
+				 (S626_A1_CLKSRC_BCLK1 | S626_A2_CLKSRC_X2 | \
+				  S626_INVERT_BCLK2 | S626_BCLK2_OE))
 
 /* Bit masks for timeslot records. */
-#define WS1			0x40000000	/* WS output to assert. */
-#define WS2			0x20000000
-#define WS3			0x10000000
-#define WS4			0x08000000
-#define RSD1			0x01000000	/* Shift A1 data in on SD1. */
-#define SDW_A1			0x00800000	/* Store rcv'd char at next char
+#define S626_WS1		0x40000000	/* WS output to assert. */
+#define S626_WS2		0x20000000
+#define S626_WS3		0x10000000
+#define S626_WS4		0x08000000
+#define S626_RSD1		0x01000000	/* Shift A1 data in on SD1. */
+#define S626_SDW_A1		0x00800000	/* Store rcv'd char at next char
 						 * slot of DWORD1 buffer. */
-#define SIB_A1			0x00400000	/* Store rcv'd char at next
+#define S626_SIB_A1		0x00400000	/* Store rcv'd char at next
 						 * char slot of FB1 buffer. */
-#define SF_A1			0x00200000	/* Write unsigned long
+#define S626_SF_A1		0x00200000	/* Write unsigned long
 						 * buffer to input FIFO. */
 
 /* Select parallel-to-serial converter's data source: */
-#define XFIFO_0			0x00000000	/* Data fifo byte 0. */
-#define XFIFO_1			0x00000010	/* Data fifo byte 1. */
-#define XFIFO_2			0x00000020	/* Data fifo byte 2. */
-#define XFIFO_3			0x00000030	/* Data fifo byte 3. */
-#define XFB0			0x00000040	/* FB_BUFFER byte 0. */
-#define XFB1			0x00000050	/* FB_BUFFER byte 1. */
-#define XFB2			0x00000060	/* FB_BUFFER byte 2. */
-#define XFB3			0x00000070	/* FB_BUFFER byte 3. */
-#define SIB_A2			0x00000200	/* Store next dword from A2's
+#define S626_XFIFO_0		0x00000000	/* Data fifo byte 0. */
+#define S626_XFIFO_1		0x00000010	/* Data fifo byte 1. */
+#define S626_XFIFO_2		0x00000020	/* Data fifo byte 2. */
+#define S626_XFIFO_3		0x00000030	/* Data fifo byte 3. */
+#define S626_XFB0		0x00000040	/* FB_BUFFER byte 0. */
+#define S626_XFB1		0x00000050	/* FB_BUFFER byte 1. */
+#define S626_XFB2		0x00000060	/* FB_BUFFER byte 2. */
+#define S626_XFB3		0x00000070	/* FB_BUFFER byte 3. */
+#define S626_SIB_A2		0x00000200	/* Store next dword from A2's
 						 * input shifter to FB2
 						 * buffer. */
-#define SF_A2			0x00000100	/* Store next dword from A2's
+#define S626_SF_A2		0x00000100	/* Store next dword from A2's
 						 * input shifter to its input
 						 * fifo. */
-#define LF_A2			0x00000080	/* Load next dword from A2's
+#define S626_LF_A2		0x00000080	/* Load next dword from A2's
 						 * output fifo into its
 						 * output dword buffer. */
-#define XSD2			0x00000008	/* Shift data out on SD2. */
-#define RSD3			0x00001800	/* Shift data in on SD3. */
-#define RSD2			0x00001000	/* Shift data in on SD2. */
-#define LOW_A2			0x00000002	/* Drive last SD low for 7 clks,
+#define S626_XSD2		0x00000008	/* Shift data out on SD2. */
+#define S626_RSD3		0x00001800	/* Shift data in on SD3. */
+#define S626_RSD2		0x00001000	/* Shift data in on SD2. */
+#define S626_LOW_A2		0x00000002	/* Drive last SD low for 7 clks,
 						 * then tri-state. */
-#define EOS			0x00000001	/* End of superframe. */
+#define S626_EOS		0x00000001	/* End of superframe. */
 
 /* I2C configuration constants. */
-#define I2C_CLKSEL		0x0400		/* I2C bit rate =
+#define S626_I2C_CLKSEL		0x0400		/* I2C bit rate =
 						 * PCIclk/480 = 68.75 KHz. */
-#define I2C_BITRATE		68.75		/* I2C bus data bit rate
-						 * (determined by I2C_CLKSEL)
-						 * in KHz. */
-#define I2C_WRTIME		15.0		/* Worst case time, in msec,
+#define S626_I2C_BITRATE	68.75		/* I2C bus data bit rate
+						 * (determined by
+						 * S626_I2C_CLKSEL) in KHz. */
+#define S626_I2C_WRTIME		15.0		/* Worst case time, in msec,
 						 * for EEPROM internal write
 						 * op. */
 
 /* I2C manifest constants. */
 
 /* Max retries to wait for EEPROM write. */
-#define I2C_RETRIES		(I2C_WRTIME * I2C_BITRATE / 9.0)
-#define I2C_ERR			0x0002	/* I2C control/status flag ERROR. */
-#define I2C_BUSY		0x0001	/* I2C control/status flag BUSY. */
-#define I2C_ABORT		0x0080	/* I2C status flag ABORT. */
-#define I2C_ATTRSTART		0x3	/* I2C attribute START. */
-#define I2C_ATTRCONT		0x2	/* I2C attribute CONT. */
-#define I2C_ATTRSTOP		0x1	/* I2C attribute STOP. */
-#define I2C_ATTRNOP		0x0	/* I2C attribute NOP. */
+#define S626_I2C_RETRIES	(S626_I2C_WRTIME * S626_I2C_BITRATE / 9.0)
+#define S626_I2C_ERR		0x0002	/* I2C control/status flag ERROR. */
+#define S626_I2C_BUSY		0x0001	/* I2C control/status flag BUSY. */
+#define S626_I2C_ABORT		0x0080	/* I2C status flag ABORT. */
+#define S626_I2C_ATTRSTART	0x3	/* I2C attribute START. */
+#define S626_I2C_ATTRCONT	0x2	/* I2C attribute CONT. */
+#define S626_I2C_ATTRSTOP	0x1	/* I2C attribute STOP. */
+#define S626_I2C_ATTRNOP	0x0	/* I2C attribute NOP. */
 
 /* Code macros used for constructing I2C command bytes. */
-#define I2C_B2(ATTR, VAL)	(((ATTR) << 6) | ((VAL) << 24))
-#define I2C_B1(ATTR, VAL)	(((ATTR) << 4) | ((VAL) << 16))
-#define I2C_B0(ATTR, VAL)	(((ATTR) << 2) | ((VAL) <<  8))
+#define S626_I2C_B2(ATTR, VAL)	(((ATTR) << 6) | ((VAL) << 24))
+#define S626_I2C_B1(ATTR, VAL)	(((ATTR) << 4) | ((VAL) << 16))
+#define S626_I2C_B0(ATTR, VAL)	(((ATTR) << 2) | ((VAL) <<  8))
 
 /* DEBI command constants. */
-#define DEBI_CMD_SIZE16		(2 << 17)	/* Transfer size is always
+#define S626_DEBI_CMD_SIZE16	(2 << 17)	/* Transfer size is always
 						 * 2 bytes. */
-#define DEBI_CMD_READ		0x00010000	/* Read operation. */
-#define DEBI_CMD_WRITE		0x00000000	/* Write operation. */
+#define S626_DEBI_CMD_READ	0x00010000	/* Read operation. */
+#define S626_DEBI_CMD_WRITE	0x00000000	/* Write operation. */
 
 /* Read immediate 2 bytes. */
-#define DEBI_CMD_RDWORD		(DEBI_CMD_READ | DEBI_CMD_SIZE16)
+#define S626_DEBI_CMD_RDWORD	(S626_DEBI_CMD_READ | S626_DEBI_CMD_SIZE16)
 
 /* Write immediate 2 bytes. */
-#define DEBI_CMD_WRWORD		(DEBI_CMD_WRITE | DEBI_CMD_SIZE16)
+#define S626_DEBI_CMD_WRWORD	(S626_DEBI_CMD_WRITE | S626_DEBI_CMD_SIZE16)
 
 /* DEBI configuration constants. */
-#define DEBI_CFG_XIRQ_EN	0x80000000	/* Enable external interrupt
+#define S626_DEBI_CFG_XIRQ_EN	0x80000000	/* Enable external interrupt
 						 * on GPIO3. */
-#define DEBI_CFG_XRESUME	0x40000000	/* Resume block */
+#define S626_DEBI_CFG_XRESUME	0x40000000	/* Resume block */
 						/* Transfer when XIRQ
 						 * deasserted. */
-#define DEBI_CFG_TOQ		0x03C00000	/* Timeout (15 PCI cycles). */
-#define DEBI_CFG_FAST		0x10000000	/* Fast mode enable. */
+#define S626_DEBI_CFG_TOQ	0x03C00000	/* Timeout (15 PCI cycles). */
+#define S626_DEBI_CFG_FAST	0x10000000	/* Fast mode enable. */
 
 /* 4-bit field that specifies DEBI timeout value in PCI clock cycles: */
-#define DEBI_CFG_TOUT_BIT	22	/* Finish DEBI cycle after this many
+#define S626_DEBI_CFG_TOUT_BIT	22	/* Finish DEBI cycle after this many
 					 * clocks. */
 
 /* 2-bit field that specifies Endian byte lane steering: */
-#define DEBI_CFG_SWAP_NONE	0x00000000	/* Straight - don't swap any
+#define S626_DEBI_CFG_SWAP_NONE	0x00000000	/* Straight - don't swap any
 						 * bytes (Intel). */
-#define DEBI_CFG_SWAP_2		0x00100000	/* 2-byte swap (Motorola). */
-#define DEBI_CFG_SWAP_4		0x00200000	/* 4-byte swap. */
-#define DEBI_CFG_SLAVE16	0x00080000	/* Slave is able to serve
+#define S626_DEBI_CFG_SWAP_2	0x00100000	/* 2-byte swap (Motorola). */
+#define S626_DEBI_CFG_SWAP_4	0x00200000	/* 4-byte swap. */
+#define S626_DEBI_CFG_SLAVE16	0x00080000	/* Slave is able to serve
 						 * 16-bit cycles. */
-#define DEBI_CFG_INC		0x00040000	/* Enable address increment
+#define S626_DEBI_CFG_INC	0x00040000	/* Enable address increment
 						 * for block transfers. */
-#define DEBI_CFG_INTEL		0x00020000	/* Intel style local bus. */
-#define DEBI_CFG_TIMEROFF	0x00010000	/* Disable timer. */
+#define S626_DEBI_CFG_INTEL	0x00020000	/* Intel style local bus. */
+#define S626_DEBI_CFG_TIMEROFF	0x00010000	/* Disable timer. */
 
-#if PLATFORM == INTEL
+#if S626_PLATFORM == S626_INTEL
 
-#define DEBI_TOUT		7	/* Wait 7 PCI clocks (212 ns) before
+#define S626_DEBI_TOUT		7	/* Wait 7 PCI clocks (212 ns) before
 					 * polling RDY. */
 
 /* Intel byte lane steering (pass through all byte lanes). */
-#define DEBI_SWAP		DEBI_CFG_SWAP_NONE
+#define S626_DEBI_SWAP		S626_DEBI_CFG_SWAP_NONE
 
-#elif PLATFORM == MOTOROLA
+#elif S626_PLATFORM == S626_MOTOROLA
 
-#define DEBI_TOUT		15	/* Wait 15 PCI clocks (454 ns) maximum
+#define S626_DEBI_TOUT		15	/* Wait 15 PCI clocks (454 ns) maximum
 					 * before timing out. */
 
 /* Motorola byte lane steering. */
-#define DEBI_SWAP		DEBI_CFG_SWAP_2
+#define S626_DEBI_SWAP		S626_DEBI_CFG_SWAP_2
 
 #endif
 
 /* DEBI page table constants. */
-#define DEBI_PAGE_DISABLE	0x00000000	/* Paging disable. */
+#define S626_DEBI_PAGE_DISABLE	0x00000000	/* Paging disable. */
 
 /* ******* EXTRA FROM OTHER SENSORAY  * .h  ******* */
 
 /* LoadSrc values: */
-#define LOADSRC_INDX		0	/* Preload core in response to Index. */
-#define LOADSRC_OVER		1	/* Preload core in response to
+#define S626_LOADSRC_INDX	0	/* Preload core in response to Index. */
+#define S626_LOADSRC_OVER	1	/* Preload core in response to
 					 * Overflow. */
-#define LOADSRCB_OVERA		2	/* Preload B core in response to
+#define S626_LOADSRCB_OVERA	2	/* Preload B core in response to
 					 * A Overflow. */
-#define LOADSRC_NONE		3	/* Never preload core. */
+#define S626_LOADSRC_NONE	3	/* Never preload core. */
 
 /* IntSrc values: */
-#define INTSRC_NONE		0	/* Interrupts disabled. */
-#define INTSRC_OVER		1	/* Interrupt on Overflow. */
-#define INTSRC_INDX		2	/* Interrupt on Index. */
-#define INTSRC_BOTH		3	/* Interrupt on Index or Overflow. */
+#define S626_INTSRC_NONE	0	/* Interrupts disabled. */
+#define S626_INTSRC_OVER	1	/* Interrupt on Overflow. */
+#define S626_INTSRC_INDX	2	/* Interrupt on Index. */
+#define S626_INTSRC_BOTH	3	/* Interrupt on Index or Overflow. */
 
 /* LatchSrc values: */
-#define LATCHSRC_AB_READ	0	/* Latch on read. */
-#define LATCHSRC_A_INDXA	1	/* Latch A on A Index. */
-#define LATCHSRC_B_INDXB	2	/* Latch B on B Index. */
-#define LATCHSRC_B_OVERA	3	/* Latch B on A Overflow. */
+#define S626_LATCHSRC_AB_READ	0	/* Latch on read. */
+#define S626_LATCHSRC_A_INDXA	1	/* Latch A on A Index. */
+#define S626_LATCHSRC_B_INDXB	2	/* Latch B on B Index. */
+#define S626_LATCHSRC_B_OVERA	3	/* Latch B on A Overflow. */
 
 /* IndxSrc values: */
-#define INDXSRC_HARD		0	/* Hardware or software index. */
-#define INDXSRC_SOFT		1	/* Software index only. */
+#define S626_INDXSRC_HARD	0	/* Hardware or software index. */
+#define S626_INDXSRC_SOFT	1	/* Software index only. */
 
 /* IndxPol values: */
-#define INDXPOL_POS		0	/* Index input is active high. */
-#define INDXPOL_NEG		1	/* Index input is active low. */
+#define S626_INDXPOL_POS	0	/* Index input is active high. */
+#define S626_INDXPOL_NEG	1	/* Index input is active low. */
 
 /* ClkSrc values: */
-#define CLKSRC_COUNTER		0	/* Counter mode. */
-#define CLKSRC_TIMER		2	/* Timer mode. */
-#define CLKSRC_EXTENDER		3	/* Extender mode. */
+#define S626_CLKSRC_COUNTER	0	/* Counter mode. */
+#define S626_CLKSRC_TIMER	2	/* Timer mode. */
+#define S626_CLKSRC_EXTENDER	3	/* Extender mode. */
 
 /* ClkPol values: */
-#define CLKPOL_POS		0	/* Counter/Extender clock is
+#define S626_CLKPOL_POS		0	/* Counter/Extender clock is
 					 * active high. */
-#define CLKPOL_NEG		1	/* Counter/Extender clock is
+#define S626_CLKPOL_NEG		1	/* Counter/Extender clock is
 					 * active low. */
-#define CNTDIR_UP		0	/* Timer counts up. */
-#define CNTDIR_DOWN		1	/* Timer counts down. */
+#define S626_CNTDIR_UP		0	/* Timer counts up. */
+#define S626_CNTDIR_DOWN	1	/* Timer counts down. */
 
 /* ClkEnab values: */
-#define CLKENAB_ALWAYS		0	/* Clock always enabled. */
-#define CLKENAB_INDEX		1	/* Clock is enabled by index. */
+#define S626_CLKENAB_ALWAYS	0	/* Clock always enabled. */
+#define S626_CLKENAB_INDEX	1	/* Clock is enabled by index. */
 
 /* ClkMult values: */
-#define CLKMULT_4X		0	/* 4x clock multiplier. */
-#define CLKMULT_2X		1	/* 2x clock multiplier. */
-#define CLKMULT_1X		2	/* 1x clock multiplier. */
+#define S626_CLKMULT_4X		0	/* 4x clock multiplier. */
+#define S626_CLKMULT_2X		1	/* 2x clock multiplier. */
+#define S626_CLKMULT_1X		2	/* 1x clock multiplier. */
 
 /* Bit Field positions in COUNTER_SETUP structure: */
-#define BF_LOADSRC		9	/* Preload trigger. */
-#define BF_INDXSRC		7	/* Index source. */
-#define BF_INDXPOL		6	/* Index polarity. */
-#define BF_CLKSRC		4	/* Clock source. */
-#define BF_CLKPOL		3	/* Clock polarity/count direction. */
-#define BF_CLKMULT		1	/* Clock multiplier. */
-#define BF_CLKENAB		0	/* Clock enable. */
-
-/*
- * Enumerated counter operating modes specified by ClkSrc bit field in
- * a COUNTER_SETUP.
- */
-
-#define CLKSRC_COUNTER		0	/* Counter: ENC_C clock,
-					 * ENC_D direction. */
-#define CLKSRC_TIMER		2	/* Timer: SYS_C clock, direction
-					 * specified by ClkPol. */
-#define CLKSRC_EXTENDER		3	/* Extender: OVR_A clock,
-					 * ENC_D direction. */
+#define S626_BF_LOADSRC		9	/* Preload trigger. */
+#define S626_BF_INDXSRC		7	/* Index source. */
+#define S626_BF_INDXPOL		6	/* Index polarity. */
+#define S626_BF_CLKSRC		4	/* Clock source. */
+#define S626_BF_CLKPOL		3	/* Clock polarity/count direction. */
+#define S626_BF_CLKMULT		1	/* Clock multiplier. */
+#define S626_BF_CLKENAB		0	/* Clock enable. */
 
 /* Enumerated counter clock multipliers. */
 
-#define MULT_X0			0x0003	/* Supports no multipliers;
+#define S626_MULT_X0		0x0003	/* Supports no multipliers;
 					 * fixed physical multiplier = 3. */
-#define MULT_X1			0x0002	/* Supports multiplier x1;
+#define S626_MULT_X1		0x0002	/* Supports multiplier x1;
 					 * fixed physical multiplier = 2. */
-#define MULT_X2			0x0001	/* Supports multipliers x1, x2;
+#define S626_MULT_X2		0x0001	/* Supports multipliers x1, x2;
 					 * physical multipliers = 1 or 2. */
-#define MULT_X4			0x0000	/* Supports multipliers x1, x2, x4;
+#define S626_MULT_X4		0x0000	/* Supports multipliers x1, x2, x4;
 					 * physical multipliers = 0, 1 or 2. */
 
 /* Sanity-check limits for parameters. */
 
-#define NUM_COUNTERS		6	/* Maximum valid counter
+#define S626_NUM_COUNTERS	6	/* Maximum valid counter
 					 * logical channel number. */
-#define NUM_INTSOURCES		4
-#define NUM_LATCHSOURCES	4
-#define NUM_CLKMULTS		4
-#define NUM_CLKSOURCES		4
-#define NUM_CLKPOLS		2
-#define NUM_INDEXPOLS		2
-#define NUM_INDEXSOURCES	2
-#define NUM_LOADTRIGS		4
+#define S626_NUM_INTSOURCES	4
+#define S626_NUM_LATCHSOURCES	4
+#define S626_NUM_CLKMULTS	4
+#define S626_NUM_CLKSOURCES	4
+#define S626_NUM_CLKPOLS	2
+#define S626_NUM_INDEXPOLS	2
+#define S626_NUM_INDEXSOURCES	2
+#define S626_NUM_LOADTRIGS	4
 
 /* Bit field positions in CRA and CRB counter control registers. */
 
 /* Bit field positions in CRA: */
-#define CRABIT_INDXSRC_B	14	/* B index source. */
-#define CRABIT_CLKSRC_B		12	/* B clock source. */
-#define CRABIT_INDXPOL_A	11	/* A index polarity. */
-#define CRABIT_LOADSRC_A	 9	/* A preload trigger. */
-#define CRABIT_CLKMULT_A	 7	/* A clock multiplier. */
-#define CRABIT_INTSRC_A		 5	/* A interrupt source. */
-#define CRABIT_CLKPOL_A		 4	/* A clock polarity. */
-#define CRABIT_INDXSRC_A	 2	/* A index source. */
-#define CRABIT_CLKSRC_A		 0	/* A clock source. */
+#define S626_CRABIT_INDXSRC_B	14	/* B index source. */
+#define S626_CRABIT_CLKSRC_B	12	/* B clock source. */
+#define S626_CRABIT_INDXPOL_A	11	/* A index polarity. */
+#define S626_CRABIT_LOADSRC_A	 9	/* A preload trigger. */
+#define S626_CRABIT_CLKMULT_A	 7	/* A clock multiplier. */
+#define S626_CRABIT_INTSRC_A	 5	/* A interrupt source. */
+#define S626_CRABIT_CLKPOL_A	 4	/* A clock polarity. */
+#define S626_CRABIT_INDXSRC_A	 2	/* A index source. */
+#define S626_CRABIT_CLKSRC_A	 0	/* A clock source. */
 
 /* Bit field positions in CRB: */
-#define CRBBIT_INTRESETCMD	15	/* Interrupt reset command. */
-#define CRBBIT_INTRESET_B	14	/* B interrupt reset enable. */
-#define CRBBIT_INTRESET_A	13	/* A interrupt reset enable. */
-#define CRBBIT_CLKENAB_A	12	/* A clock enable. */
-#define CRBBIT_INTSRC_B		10	/* B interrupt source. */
-#define CRBBIT_LATCHSRC		 8	/* A/B latch source. */
-#define CRBBIT_LOADSRC_B	 6	/* B preload trigger. */
-#define CRBBIT_CLKMULT_B	 3	/* B clock multiplier. */
-#define CRBBIT_CLKENAB_B	 2	/* B clock enable. */
-#define CRBBIT_INDXPOL_B	 1	/* B index polarity. */
-#define CRBBIT_CLKPOL_B		 0	/* B clock polarity. */
+#define S626_CRBBIT_INTRESETCMD	15	/* Interrupt reset command. */
+#define S626_CRBBIT_INTRESET_B	14	/* B interrupt reset enable. */
+#define S626_CRBBIT_INTRESET_A	13	/* A interrupt reset enable. */
+#define S626_CRBBIT_CLKENAB_A	12	/* A clock enable. */
+#define S626_CRBBIT_INTSRC_B	10	/* B interrupt source. */
+#define S626_CRBBIT_LATCHSRC	 8	/* A/B latch source. */
+#define S626_CRBBIT_LOADSRC_B	 6	/* B preload trigger. */
+#define S626_CRBBIT_CLKMULT_B	 3	/* B clock multiplier. */
+#define S626_CRBBIT_CLKENAB_B	 2	/* B clock enable. */
+#define S626_CRBBIT_INDXPOL_B	 1	/* B index polarity. */
+#define S626_CRBBIT_CLKPOL_B	 0	/* B clock polarity. */
 
 /* Bit field masks for CRA and CRB. */
 
-#define CRAMSK_INDXSRC_B	(3 << CRABIT_INDXSRC_B)
-#define CRAMSK_CLKSRC_B		(3 << CRABIT_CLKSRC_B)
-#define CRAMSK_INDXPOL_A	(1 << CRABIT_INDXPOL_A)
-#define CRAMSK_LOADSRC_A	(3 << CRABIT_LOADSRC_A)
-#define CRAMSK_CLKMULT_A	(3 << CRABIT_CLKMULT_A)
-#define CRAMSK_INTSRC_A		(3 << CRABIT_INTSRC_A)
-#define CRAMSK_CLKPOL_A		(3 << CRABIT_CLKPOL_A)
-#define CRAMSK_INDXSRC_A	(3 << CRABIT_INDXSRC_A)
-#define CRAMSK_CLKSRC_A		(3 << CRABIT_CLKSRC_A)
-
-#define CRBMSK_INTRESETCMD	(1 << CRBBIT_INTRESETCMD)
-#define CRBMSK_INTRESET_B	(1 << CRBBIT_INTRESET_B)
-#define CRBMSK_INTRESET_A	(1 << CRBBIT_INTRESET_A)
-#define CRBMSK_CLKENAB_A	(1 << CRBBIT_CLKENAB_A)
-#define CRBMSK_INTSRC_B		(3 << CRBBIT_INTSRC_B)
-#define CRBMSK_LATCHSRC		(3 << CRBBIT_LATCHSRC)
-#define CRBMSK_LOADSRC_B	(3 << CRBBIT_LOADSRC_B)
-#define CRBMSK_CLKMULT_B	(3 << CRBBIT_CLKMULT_B)
-#define CRBMSK_CLKENAB_B	(1 << CRBBIT_CLKENAB_B)
-#define CRBMSK_INDXPOL_B	(1 << CRBBIT_INDXPOL_B)
-#define CRBMSK_CLKPOL_B		(1 << CRBBIT_CLKPOL_B)
+#define S626_CRAMSK_INDXSRC_B	(3 << S626_CRABIT_INDXSRC_B)
+#define S626_CRAMSK_CLKSRC_B	(3 << S626_CRABIT_CLKSRC_B)
+#define S626_CRAMSK_INDXPOL_A	(1 << S626_CRABIT_INDXPOL_A)
+#define S626_CRAMSK_LOADSRC_A	(3 << S626_CRABIT_LOADSRC_A)
+#define S626_CRAMSK_CLKMULT_A	(3 << S626_CRABIT_CLKMULT_A)
+#define S626_CRAMSK_INTSRC_A	(3 << S626_CRABIT_INTSRC_A)
+#define S626_CRAMSK_CLKPOL_A	(3 << S626_CRABIT_CLKPOL_A)
+#define S626_CRAMSK_INDXSRC_A	(3 << S626_CRABIT_INDXSRC_A)
+#define S626_CRAMSK_CLKSRC_A	(3 << S626_CRABIT_CLKSRC_A)
+
+#define S626_CRBMSK_INTRESETCMD	(1 << S626_CRBBIT_INTRESETCMD)
+#define S626_CRBMSK_INTRESET_B	(1 << S626_CRBBIT_INTRESET_B)
+#define S626_CRBMSK_INTRESET_A	(1 << S626_CRBBIT_INTRESET_A)
+#define S626_CRBMSK_CLKENAB_A	(1 << S626_CRBBIT_CLKENAB_A)
+#define S626_CRBMSK_INTSRC_B	(3 << S626_CRBBIT_INTSRC_B)
+#define S626_CRBMSK_LATCHSRC	(3 << S626_CRBBIT_LATCHSRC)
+#define S626_CRBMSK_LOADSRC_B	(3 << S626_CRBBIT_LOADSRC_B)
+#define S626_CRBMSK_CLKMULT_B	(3 << S626_CRBBIT_CLKMULT_B)
+#define S626_CRBMSK_CLKENAB_B	(1 << S626_CRBBIT_CLKENAB_B)
+#define S626_CRBMSK_INDXPOL_B	(1 << S626_CRBBIT_INDXPOL_B)
+#define S626_CRBMSK_CLKPOL_B	(1 << S626_CRBBIT_CLKPOL_B)
 
 /* Interrupt reset control bits. */
-#define CRBMSK_INTCTRL		\
-	(CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B)
+#define S626_CRBMSK_INTCTRL	(S626_CRBMSK_INTRESETCMD | \
+				 S626_CRBMSK_INTRESET_A | \
+				 S626_CRBMSK_INTRESET_B)
 
 /* Bit field positions for standardized SETUP structure. */
 
-#define STDBIT_INTSRC		13
-#define STDBIT_LATCHSRC		11
-#define STDBIT_LOADSRC		 9
-#define STDBIT_INDXSRC		 7
-#define STDBIT_INDXPOL		 6
-#define STDBIT_CLKSRC		 4
-#define STDBIT_CLKPOL		 3
-#define STDBIT_CLKMULT		 1
-#define STDBIT_CLKENAB		 0
+#define S626_STDBIT_INTSRC	13
+#define S626_STDBIT_LATCHSRC	11
+#define S626_STDBIT_LOADSRC	 9
+#define S626_STDBIT_INDXSRC	 7
+#define S626_STDBIT_INDXPOL	 6
+#define S626_STDBIT_CLKSRC	 4
+#define S626_STDBIT_CLKPOL	 3
+#define S626_STDBIT_CLKMULT	 1
+#define S626_STDBIT_CLKENAB	 0
 
 /* Bit field masks for standardized SETUP structure. */
 
-#define STDMSK_INTSRC		(3 << STDBIT_INTSRC)
-#define STDMSK_LATCHSRC		(3 << STDBIT_LATCHSRC)
-#define STDMSK_LOADSRC		(3 << STDBIT_LOADSRC)
-#define STDMSK_INDXSRC		(1 << STDBIT_INDXSRC)
-#define STDMSK_INDXPOL		(1 << STDBIT_INDXPOL)
-#define STDMSK_CLKSRC		(3 << STDBIT_CLKSRC)
-#define STDMSK_CLKPOL		(1 << STDBIT_CLKPOL)
-#define STDMSK_CLKMULT		(3 << STDBIT_CLKMULT)
-#define STDMSK_CLKENAB		(1 << STDBIT_CLKENAB)
+#define S626_STDMSK_INTSRC	(3 << S626_STDBIT_INTSRC)
+#define S626_STDMSK_LATCHSRC	(3 << S626_STDBIT_LATCHSRC)
+#define S626_STDMSK_LOADSRC	(3 << S626_STDBIT_LOADSRC)
+#define S626_STDMSK_INDXSRC	(1 << S626_STDBIT_INDXSRC)
+#define S626_STDMSK_INDXPOL	(1 << S626_STDBIT_INDXPOL)
+#define S626_STDMSK_CLKSRC	(3 << S626_STDBIT_CLKSRC)
+#define S626_STDMSK_CLKPOL	(1 << S626_STDBIT_CLKPOL)
+#define S626_STDMSK_CLKMULT	(3 << S626_STDBIT_CLKMULT)
+#define S626_STDMSK_CLKENAB	(1 << S626_STDBIT_CLKENAB)
 
 #endif

commit 8e06d662871c0e13f856d9e30bdd2693032fb136
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:38 2013 +0100

    staging: comedi: s626: move struct buffer_dma
    
    Move the declaration of `struct buffer_dma` from "s626.h" to "s626.c" as
    it seems more at home there.  After this move, "s626.h" just contains
    macros related to hardware registers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 2d332bf0f1e3..605926ed861b 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -614,9 +614,4 @@
 #define STDMSK_CLKMULT		(3 << STDBIT_CLKMULT)
 #define STDMSK_CLKENAB		(1 << STDBIT_CLKENAB)
 
-struct buffer_dma {
-	dma_addr_t physical_base;
-	void *logical_base;
-};
-
 #endif

commit c3e3a56d40c451271b1be4d6d3ec3b62af879228
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:35 2013 +0100

    staging: comedi: s626: remove TRUE and FALSE macros
    
    "s626.h" defines the macros `TRUE` and `FALSE` if they are not already
    defined, yielding the expected numeric values.  Remove the macros and
    replace their usage with the values `true` and `false`, respectively.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index db16b1861523..2d332bf0f1e3 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -22,14 +22,6 @@
 #ifndef S626_H_INCLUDED
 #define S626_H_INCLUDED
 
-#if !defined(TRUE)
-#define TRUE    (1)
-#endif
-
-#if !defined(FALSE)
-#define FALSE   (0)
-#endif
-
 #define S626_SIZE		0x200
 #define DMABUF_SIZE		4096	/* 4k pages */
 

commit 3a3875067e25d9f7dae02c3858010310adc3a317
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:24 2013 +0100

    staging: comedi: s626: replace CamelCase struct bufferDMA
    
    Rename `struct bufferDMA` and its members to avoid CamelCase.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 939b3592bfcd..db16b1861523 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -622,9 +622,9 @@
 #define STDMSK_CLKMULT		(3 << STDBIT_CLKMULT)
 #define STDMSK_CLKENAB		(1 << STDBIT_CLKENAB)
 
-struct bufferDMA {
-	dma_addr_t PhysicalBase;
-	void *LogicalBase;
+struct buffer_dma {
+	dma_addr_t physical_base;
+	void *logical_base;
 };
 
 #endif

commit d5512f5b5b58e7ae47045315ade7df8873617992
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:22 2013 +0100

    staging: comedi: s626: remove I2CR and I2CW macros
    
    The `I2CR` and `I2CW` macros expand to the I2C read and write addresses,
    respectively.  They are only used in one place each and include the name
    of a local variable `devpriv` in their expansion.
    
    Get rid of the macros and expand them in place.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index f7ed4af51a95..939b3592bfcd 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -384,12 +384,6 @@
 #define I2C_ATTRSTOP		0x1	/* I2C attribute STOP. */
 #define I2C_ATTRNOP		0x0	/* I2C attribute NOP. */
 
-/* I2C read command  | EEPROM address. */
-#define I2CR			(devpriv->I2CAdrs | 1)
-
-/* I2C write command | EEPROM address. */
-#define I2CW			(devpriv->I2CAdrs)
-
 /* Code macros used for constructing I2C command bytes. */
 #define I2C_B2(ATTR, VAL)	(((ATTR) << 6) | ((VAL) << 24))
 #define I2C_B1(ATTR, VAL)	(((ATTR) << 4) | ((VAL) << 16))

commit 869db884c7f191b80964515129e12b03d1006acd
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:19 2013 +0100

    staging: comedi: s626: remove unused DMAHandle
    
    The `DMAHandle` member of `struct bufferDMA` in "s626.h" is unused, so
    remove it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index c4b8078e0c06..f7ed4af51a95 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -631,7 +631,6 @@
 struct bufferDMA {
 	dma_addr_t PhysicalBase;
 	void *LogicalBase;
-	uint32_t DMAHandle;
 };
 
 #endif

commit eb4700edd966c74c0e489b026077abeadffac948
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 8 19:06:15 2013 +0100

    staging: comedi: s626: tidy the header file a bit
    
    Tidy up the "s626.h" header file a bit, cleaning up the whitespace and
    fixing overlength lines.  Add multiple inclusion protection (even though
    it's only included once and only by "s626.c").  Remove unnecessary
    driver comment near the start of the file as it is more or less the same
    as the one in "s626.c".  Remove obviously unused/useless stuff.
    
    I'm not sure what to do about the INTEL/MOTOROLA platform selection in
    the file.  I've left it alone (set to INTEL) for now.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index a85e6bdcad07..c4b8078e0c06 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -1,61 +1,26 @@
 /*
-  comedi/drivers/s626.h
-  Sensoray s626 Comedi driver, header file
-
-  COMEDI - Linux Control and Measurement Device Interface
-  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
-
-  Based on Sensoray Model 626 Linux driver Version 0.2
-  Copyright (C) 2002-2004 Sensoray Co., Inc.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-*/
-
-/*
-  Driver: s626.o (s626.ko)
-  Description: Sensoray 626 driver
-  Devices: Sensoray s626
-  Authors: Gianluca Palli <gpalli@deis.unibo.it>,
-  Updated: Thu, 12 Jul 2005
-  Status: experimental
-
-  Configuration Options:
-  analog input:
-   none
-
-  analog output:
-   none
-
-  digital channel:
-   s626 has 3 dio subdevices (2,3 and 4) each with 16 i/o channels
-   supported configuration options:
-   INSN_CONFIG_DIO_QUERY
-   COMEDI_INPUT
-   COMEDI_OUTPUT
-
-  encoder:
-   Every channel must be configured before reading.
-
-   Example code
-
-   insn.insn=INSN_CONFIG;   // configuration instruction
-   insn.n=1;                // number of operation (must be 1)
-   insn.data=&initialvalue; // initial value loaded into encoder
-                            // during configuration
-   insn.subdev=5;           // encoder subdevice
-   insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); // encoder_channel
-                                                        // to configure
-
-   comedi_do_insn(cf,&insn); // executing configuration
-*/
+ * comedi/drivers/s626.h
+ * Sensoray s626 Comedi driver, header file
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+ *
+ * Based on Sensoray Model 626 Linux driver Version 0.2
+ * Copyright (C) 2002-2004 Sensoray Co., Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef S626_H_INCLUDED
+#define S626_H_INCLUDED
 
 #if !defined(TRUE)
 #define TRUE    (1)
@@ -65,154 +30,155 @@
 #define FALSE   (0)
 #endif
 
-#define S626_SIZE 0x0200
-#define DMABUF_SIZE			4096	/*  4k pages */
+#define S626_SIZE		0x200
+#define DMABUF_SIZE		4096	/* 4k pages */
 
 #define S626_ADC_CHANNELS       16
 #define S626_DAC_CHANNELS       4
 #define S626_ENCODER_CHANNELS   6
 #define S626_DIO_CHANNELS       48
-#define S626_DIO_BANKS		3	/*  Number of DIO groups. */
-#define S626_DIO_EXTCHANS	40	/*  Number of */
-					/*  extended-capability */
-					/*  DIO channels. */
+#define S626_DIO_BANKS		3	/* Number of DIO groups. */
+#define S626_DIO_EXTCHANS	40	/* Number of extended-capability
+					 * DIO channels. */
 
-#define NUM_TRIMDACS	12	/*  Number of valid TrimDAC channels. */
+#define NUM_TRIMDACS		12	/* Number of valid TrimDAC channels. */
 
-/*  PCI bus interface types. */
-#define INTEL				1	/*  Intel bus type. */
-#define MOTOROLA			2	/*  Motorola bus type. */
+/* PCI bus interface types. */
+#define INTEL			1	/* Intel bus type. */
+#define MOTOROLA		2	/* Motorola bus type. */
 
-#define PLATFORM		INTEL	/*  *** SELECT PLATFORM TYPE *** */
+#define PLATFORM		INTEL	/* *** SELECT PLATFORM TYPE *** */
 
-#define RANGE_5V                0x10	/*  +/-5V range */
-#define RANGE_10V               0x00	/*  +/-10V range */
+#define RANGE_5V                0x10	/* +/-5V range */
+#define RANGE_10V               0x00	/* +/-10V range */
 
-#define EOPL			0x80	/*  End of ADC poll list marker. */
-#define GSEL_BIPOLAR5V		0x00F0	/*  LP_GSEL setting for 5V bipolar range. */
-#define GSEL_BIPOLAR10V		0x00A0	/*  LP_GSEL setting for 10V bipolar range. */
+#define EOPL			0x80	/* End of ADC poll list marker. */
+#define GSEL_BIPOLAR5V		0x00F0	/* LP_GSEL setting for 5V bipolar. */
+#define GSEL_BIPOLAR10V		0x00A0	/* LP_GSEL setting for 10V bipolar. */
 
-/*  Error codes that must be visible to this base class. */
-#define ERR_ILLEGAL_PARM	0x00010000	/*  Illegal function parameter value was specified. */
-#define ERR_I2C			0x00020000	/*  I2C error. */
-#define ERR_COUNTERSETUP	0x00200000	/*  Illegal setup specified for counter channel. */
-#define ERR_DEBI_TIMEOUT	0x00400000	/*  DEBI transfer timed out. */
+/* Error codes that must be visible to this base class. */
+#define ERR_ILLEGAL_PARM	0x00010000	/* Illegal function parameter
+						 * value was specified. */
+#define ERR_I2C			0x00020000	/* I2C error. */
+#define ERR_COUNTERSETUP	0x00200000	/* Illegal setup specified for
+						 * counter channel. */
+#define ERR_DEBI_TIMEOUT	0x00400000	/* DEBI transfer timed out. */
 
-/*  Organization (physical order) and size (in DWORDs) of logical DMA buffers contained by ANA_DMABUF. */
-#define ADC_DMABUF_DWORDS	40	/*  ADC DMA buffer must hold 16 samples, plus pre/post garbage samples. */
-#define DAC_WDMABUF_DWORDS	1	/*  DAC output DMA buffer holds a single sample. */
+/*
+ * Organization (physical order) and size (in DWORDs) of logical DMA buffers
+ * contained by ANA_DMABUF.
+ */
+#define ADC_DMABUF_DWORDS	40	/* ADC DMA buffer must hold 16 samples,
+					 * plus pre/post garbage samples. */
+#define DAC_WDMABUF_DWORDS	1	/* DAC output DMA buffer holds a single
+					 * sample. */
 
-/*  All remaining space in 4KB DMA buffer is available for the RPS1 program. */
+/* All remaining space in 4KB DMA buffer is available for the RPS1 program. */
 
-/*  Address offsets, in DWORDS, from base of DMA buffer. */
+/* Address offsets, in DWORDS, from base of DMA buffer. */
 #define DAC_WDMABUF_OS		ADC_DMABUF_DWORDS
 
-/*  Interrupt enab bit in ISR and IER. */
-#define IRQ_GPIO3		0x00000040	/*  IRQ enable for GPIO3. */
+/*  Interrupt enable bit in ISR and IER. */
+#define IRQ_GPIO3		0x00000040	/* IRQ enable for GPIO3. */
 #define IRQ_RPS1                0x10000000
 #define ISR_AFOU		0x00000800
 /* Audio fifo under/overflow  detected. */
 
-#define IRQ_COINT1A             0x0400	/* conter 1A overflow interrupt mask */
-#define IRQ_COINT1B             0x0800	/* conter 1B overflow interrupt mask */
-#define IRQ_COINT2A             0x1000	/* conter 2A overflow interrupt mask */
-#define IRQ_COINT2B             0x2000	/* conter 2B overflow interrupt mask */
-#define IRQ_COINT3A             0x4000	/* conter 3A overflow interrupt mask */
-#define IRQ_COINT3B             0x8000	/* conter 3B overflow interrupt mask */
-
-/*  RPS command codes. */
-#define RPS_CLRSIGNAL		0x00000000	/*  CLEAR SIGNAL */
-#define RPS_SETSIGNAL		0x10000000	/*  SET SIGNAL */
-#define RPS_NOP			0x00000000	/*  NOP */
-#define RPS_PAUSE		0x20000000	/*  PAUSE */
-#define RPS_UPLOAD		0x40000000	/*  UPLOAD */
-#define RPS_JUMP		0x80000000	/*  JUMP */
-#define RPS_LDREG		0x90000100	/*  LDREG (1 uint32_t only) */
-#define RPS_STREG		0xA0000100	/*  STREG (1 uint32_t only) */
-#define RPS_STOP		0x50000000	/*  STOP */
-#define RPS_IRQ                 0x60000000	/*  IRQ */
-
-#define RPS_LOGICAL_OR		0x08000000	/*  Logical OR conditionals. */
-#define RPS_INVERT		0x04000000	/*  Test for negated semaphores. */
-#define RPS_DEBI		0x00000002	/*  DEBI done */
-
-#define RPS_SIG0		0x00200000	/*  RPS semaphore 0 (used by ADC). */
-#define RPS_SIG1		0x00400000	/*  RPS semaphore 1 (used by DAC). */
-#define RPS_SIG2		0x00800000	/*  RPS semaphore 2 (not used). */
-#define RPS_GPIO2		0x00080000	/*  RPS GPIO2 */
-#define RPS_GPIO3		0x00100000	/*  RPS GPIO3 */
-
-#define RPS_SIGADC		RPS_SIG0	/*  Trigger/status for ADC's RPS program. */
-#define RPS_SIGDAC		RPS_SIG1	/*  Trigger/status for DAC's RPS program. */
-
-/*  RPS clock parameters. */
-#define RPSCLK_SCALAR		8	/*  This is apparent ratio of PCI/RPS clks (undocumented!!). */
-#define RPSCLK_PER_US		(33 / RPSCLK_SCALAR)	/*  Number of RPS clocks in one microsecond. */
-
-/*  Event counter source addresses. */
-#define SBA_RPS_A0		0x27	/*  Time of RPS0 busy, in PCI clocks. */
-
-/*  GPIO constants. */
-#define GPIO_BASE		0x10004000	/*  GPIO 0,2,3 = inputs, GPIO3 = IRQ; GPIO1 = out. */
-#define GPIO1_LO		0x00000000	/*  GPIO1 set to LOW. */
-#define GPIO1_HI		0x00001000	/*  GPIO1 set to HIGH. */
-
-/*  Primary Status Register (PSR) constants. */
-#define PSR_DEBI_E		0x00040000	/*  DEBI event flag. */
-#define PSR_DEBI_S		0x00080000	/*  DEBI status flag. */
-#define PSR_A2_IN		0x00008000	/*  Audio output DMA2 protection address reached. */
-#define PSR_AFOU		0x00000800	/*  Audio FIFO under/overflow detected. */
-#define PSR_GPIO2		0x00000020	/*  GPIO2 input pin: 0=AdcBusy, 1=AdcIdle. */
-#define PSR_EC0S		0x00000001	/*  Event counter 0 threshold reached. */
-
-/*  Secondary Status Register (SSR) constants. */
-#define SSR_AF2_OUT		0x00000200	/*  Audio 2 output FIFO under/overflow detected. */
-
-/*  Master Control Register 1 (MC1) constants. */
-#define MC1_SOFT_RESET		0x80000000	/*  Invoke 7146 soft reset. */
-#define MC1_SHUTDOWN		0x3FFF0000	/*  Shut down all MC1-controlled enables. */
-
-#define MC1_ERPS1		0x2000	/*  enab/disable RPS task 1. */
-#define MC1_ERPS0		0x1000	/*  enab/disable RPS task 0. */
-#define MC1_DEBI		0x0800	/*  enab/disable DEBI pins. */
-#define MC1_AUDIO		0x0200	/*  enab/disable audio port pins. */
-#define MC1_I2C			0x0100	/*  enab/disable I2C interface. */
-#define MC1_A2OUT		0x0008	/*  enab/disable transfer on A2 out. */
-#define MC1_A2IN		0x0004	/*  enab/disable transfer on A2 in. */
-#define MC1_A1IN		0x0001	/*  enab/disable transfer on A1 in. */
-
-/*  Master Control Register 2 (MC2) constants. */
-#define MC2_UPLD_DEBIq		0x00020002	/*  Upload DEBI registers. */
-#define MC2_UPLD_IICq		0x00010001	/*  Upload I2C registers. */
-#define MC2_RPSSIG2_ONq		0x20002000	/*  Assert RPS_SIG2. */
-#define MC2_RPSSIG1_ONq		0x10001000	/*  Assert RPS_SIG1. */
-#define MC2_RPSSIG0_ONq		0x08000800	/*  Assert RPS_SIG0. */
-#define MC2_UPLD_DEBI_MASKq	0x00000002	/*  Upload DEBI mask. */
-#define MC2_UPLD_IIC_MASKq	0x00000001	/*  Upload I2C mask. */
-#define MC2_RPSSIG2_MASKq	0x00002000	/*  RPS_SIG2 bit mask. */
-#define MC2_RPSSIG1_MASKq	0x00001000	/*  RPS_SIG1 bit mask. */
-#define MC2_RPSSIG0_MASKq	0x00000800	/*  RPS_SIG0 bit mask. */
-
-#define MC2_DELAYTRIG_4USq	MC2_RPSSIG1_ON
-#define MC2_DELAYBUSY_4USq	MC2_RPSSIG1_MASK
-
-#define	MC2_DELAYTRIG_6USq	MC2_RPSSIG2_ON
-#define MC2_DELAYBUSY_6USq	MC2_RPSSIG2_MASK
-
-#define MC2_UPLD_DEBI		0x0002	/*  Upload DEBI. */
-#define MC2_UPLD_IIC		0x0001	/*  Upload I2C. */
-#define MC2_RPSSIG2		0x2000	/*  RPS signal 2 (not used). */
-#define MC2_RPSSIG1		0x1000	/*  RPS signal 1 (DAC RPS busy). */
-#define MC2_RPSSIG0		0x0800	/*  RPS signal 0 (ADC RPS busy). */
-
-#define MC2_ADC_RPS		MC2_RPSSIG0	/*  ADC RPS busy. */
-#define MC2_DAC_RPS		MC2_RPSSIG1	/*  DAC RPS busy. */
-
-/* ***** oldies ***** */
-#define MC2_UPLD_DEBIQ		0x00020002	/*  Upload DEBI registers. */
-#define MC2_UPLD_IICQ		0x00010001	/*  Upload I2C registers. */
-
-/*  PCI BUS (SAA7146) REGISTER ADDRESS OFFSETS */
+#define IRQ_COINT1A             0x0400	/* counter 1A overflow interrupt mask */
+#define IRQ_COINT1B             0x0800	/* counter 1B overflow interrupt mask */
+#define IRQ_COINT2A             0x1000	/* counter 2A overflow interrupt mask */
+#define IRQ_COINT2B             0x2000	/* counter 2B overflow interrupt mask */
+#define IRQ_COINT3A             0x4000	/* counter 3A overflow interrupt mask */
+#define IRQ_COINT3B             0x8000	/* counter 3B overflow interrupt mask */
+
+/* RPS command codes. */
+#define RPS_CLRSIGNAL		0x00000000	/* CLEAR SIGNAL */
+#define RPS_SETSIGNAL		0x10000000	/* SET SIGNAL */
+#define RPS_NOP			0x00000000	/* NOP */
+#define RPS_PAUSE		0x20000000	/* PAUSE */
+#define RPS_UPLOAD		0x40000000	/* UPLOAD */
+#define RPS_JUMP		0x80000000	/* JUMP */
+#define RPS_LDREG		0x90000100	/* LDREG (1 uint32_t only) */
+#define RPS_STREG		0xA0000100	/* STREG (1 uint32_t only) */
+#define RPS_STOP		0x50000000	/* STOP */
+#define RPS_IRQ                 0x60000000	/* IRQ */
+
+#define RPS_LOGICAL_OR		0x08000000	/* Logical OR conditionals. */
+#define RPS_INVERT		0x04000000	/* Test for negated
+						 * semaphores. */
+#define RPS_DEBI		0x00000002	/* DEBI done */
+
+#define RPS_SIG0		0x00200000	/* RPS semaphore 0
+						 * (used by ADC). */
+#define RPS_SIG1		0x00400000	/* RPS semaphore 1
+						 * (used by DAC). */
+#define RPS_SIG2		0x00800000	/* RPS semaphore 2
+						 * (not used). */
+#define RPS_GPIO2		0x00080000	/* RPS GPIO2 */
+#define RPS_GPIO3		0x00100000	/* RPS GPIO3 */
+
+#define RPS_SIGADC		RPS_SIG0	/* Trigger/status for
+						 * ADC's RPS program. */
+#define RPS_SIGDAC		RPS_SIG1	/* Trigger/status for
+						 * DAC's RPS program. */
+
+/* RPS clock parameters. */
+#define RPSCLK_SCALAR		8	/* This is apparent ratio of
+					 * PCI/RPS clks (undocumented!!). */
+#define RPSCLK_PER_US		(33 / RPSCLK_SCALAR)
+					/* Number of RPS clocks in one
+					 * microsecond. */
+
+/* Event counter source addresses. */
+#define SBA_RPS_A0		0x27	/* Time of RPS0 busy, in PCI clocks. */
+
+/* GPIO constants. */
+#define GPIO_BASE		0x10004000	/* GPIO 0,2,3 = inputs,
+						 * GPIO3 = IRQ; GPIO1 = out. */
+#define GPIO1_LO		0x00000000	/* GPIO1 set to LOW. */
+#define GPIO1_HI		0x00001000	/* GPIO1 set to HIGH. */
+
+/* Primary Status Register (PSR) constants. */
+#define PSR_DEBI_E		0x00040000	/* DEBI event flag. */
+#define PSR_DEBI_S		0x00080000	/* DEBI status flag. */
+#define PSR_A2_IN		0x00008000	/* Audio output DMA2 protection
+						 * address reached. */
+#define PSR_AFOU		0x00000800	/* Audio FIFO under/overflow
+						 * detected. */
+#define PSR_GPIO2		0x00000020	/* GPIO2 input pin: 0=AdcBusy,
+						 * 1=AdcIdle. */
+#define PSR_EC0S		0x00000001	/* Event counter 0 threshold
+						 * reached. */
+
+/* Secondary Status Register (SSR) constants. */
+#define SSR_AF2_OUT		0x00000200	/* Audio 2 output FIFO
+						 * under/overflow detected. */
+
+/* Master Control Register 1 (MC1) constants. */
+#define MC1_SOFT_RESET		0x80000000	/* Invoke 7146 soft reset. */
+#define MC1_SHUTDOWN		0x3FFF0000	/* Shut down all MC1-controlled
+						 * enables. */
+
+#define MC1_ERPS1		0x2000	/* Enab/disable RPS task 1. */
+#define MC1_ERPS0		0x1000	/* Enab/disable RPS task 0. */
+#define MC1_DEBI		0x0800	/* Enab/disable DEBI pins. */
+#define MC1_AUDIO		0x0200	/* Enab/disable audio port pins. */
+#define MC1_I2C			0x0100	/* Enab/disable I2C interface. */
+#define MC1_A2OUT		0x0008	/* Enab/disable transfer on A2 out. */
+#define MC1_A2IN		0x0004	/* Enab/disable transfer on A2 in. */
+#define MC1_A1IN		0x0001	/* Enab/disable transfer on A1 in. */
+
+/* Master Control Register 2 (MC2) constants. */
+#define MC2_UPLD_DEBI		0x0002	/* Upload DEBI. */
+#define MC2_UPLD_IIC		0x0001	/* Upload I2C. */
+#define MC2_RPSSIG2		0x2000	/* RPS signal 2 (not used). */
+#define MC2_RPSSIG1		0x1000	/* RPS signal 1 (DAC RPS busy). */
+#define MC2_RPSSIG0		0x0800	/* RPS signal 0 (ADC RPS busy). */
+
+#define MC2_ADC_RPS		MC2_RPSSIG0	/* ADC RPS busy. */
+#define MC2_DAC_RPS		MC2_RPSSIG1	/* DAC RPS busy. */
+
+/* PCI BUS (SAA7146) REGISTER ADDRESS OFFSETS */
 #define P_PCI_BT_A		0x004C	/* Audio DMA burst/threshold control. */
 #define P_DEBICFG               0x007C	/* DEBI configuration. */
 #define P_DEBICMD               0x0080	/* DEBI command. */
@@ -255,11 +221,11 @@
 #define P_TSL1                  0x0180	/* Audio time slot list 1. */
 #define P_TSL2                  0x01C0	/* Audio time slot list 2. */
 
-/*  LOCAL BUS (GATE ARRAY) REGISTER ADDRESS OFFSETS */
-/*  Analog I/O registers: */
-#define LP_DACPOL		0x0082	/*   Write DAC polarity. */
-#define LP_GSEL			0x0084	/*   Write ADC gain. */
-#define LP_ISEL			0x0086	/*   Write ADC channel select. */
+/* LOCAL BUS (GATE ARRAY) REGISTER ADDRESS OFFSETS */
+/* Analog I/O registers: */
+#define LP_DACPOL		0x0082	/* Write DAC polarity. */
+#define LP_GSEL			0x0084	/* Write ADC gain. */
+#define LP_ISEL			0x0086	/* Write ADC channel select. */
 
 /* Digital I/O registers */
 #define LP_RDDIN(x)		(0x0040 + (x) * 0x10)	/* R: digital input */
@@ -272,63 +238,61 @@
 #define LP_RDEDGSEL(x)		(0x004c + (x) * 0x10)	/* R: edge selection */
 #define LP_RDCAPSEL(x)		(0x004e + (x) * 0x10)	/* R: capture enable */
 
-/*  Counter Registers (read/write): */
-#define LP_CR0A			0x0000	/*   0A setup register. */
-#define LP_CR0B			0x0002	/*   0B setup register. */
-#define LP_CR1A			0x0004	/*   1A setup register. */
-#define LP_CR1B			0x0006	/*   1B setup register. */
-#define LP_CR2A			0x0008	/*   2A setup register. */
-#define LP_CR2B			0x000A	/*   2B setup register. */
-
-/*  Counter PreLoad (write) and Latch (read) Registers: */
-#define	LP_CNTR0ALSW		0x000C	/*   0A lsw. */
-#define	LP_CNTR0AMSW		0x000E	/*   0A msw. */
-#define	LP_CNTR0BLSW		0x0010	/*   0B lsw. */
-#define	LP_CNTR0BMSW		0x0012	/*   0B msw. */
-#define	LP_CNTR1ALSW		0x0014	/*   1A lsw. */
-#define	LP_CNTR1AMSW		0x0016	/*   1A msw. */
-#define	LP_CNTR1BLSW		0x0018	/*   1B lsw. */
-#define	LP_CNTR1BMSW		0x001A	/*   1B msw. */
-#define	LP_CNTR2ALSW		0x001C	/*   2A lsw. */
-#define	LP_CNTR2AMSW		0x001E	/*   2A msw. */
-#define	LP_CNTR2BLSW		0x0020	/*   2B lsw. */
-#define	LP_CNTR2BMSW		0x0022	/*   2B msw. */
-
-/*  Miscellaneous Registers (read/write): */
-#define LP_MISC1		0x0088	/*   Read/write Misc1. */
-#define LP_WRMISC2		0x0090	/*   Write Misc2. */
-#define LP_RDMISC2		0x0082	/*   Read Misc2. */
-
-/*  Bit masks for MISC1 register that are the same for reads and writes. */
+/* Counter Registers (read/write): */
+#define LP_CR0A			0x0000	/* 0A setup register. */
+#define LP_CR0B			0x0002	/* 0B setup register. */
+#define LP_CR1A			0x0004	/* 1A setup register. */
+#define LP_CR1B			0x0006	/* 1B setup register. */
+#define LP_CR2A			0x0008	/* 2A setup register. */
+#define LP_CR2B			0x000A	/* 2B setup register. */
+
+/* Counter PreLoad (write) and Latch (read) Registers: */
+#define	LP_CNTR0ALSW		0x000C	/* 0A lsw. */
+#define	LP_CNTR0AMSW		0x000E	/* 0A msw. */
+#define	LP_CNTR0BLSW		0x0010	/* 0B lsw. */
+#define	LP_CNTR0BMSW		0x0012	/* 0B msw. */
+#define	LP_CNTR1ALSW		0x0014	/* 1A lsw. */
+#define	LP_CNTR1AMSW		0x0016	/* 1A msw. */
+#define	LP_CNTR1BLSW		0x0018	/* 1B lsw. */
+#define	LP_CNTR1BMSW		0x001A	/* 1B msw. */
+#define	LP_CNTR2ALSW		0x001C	/* 2A lsw. */
+#define	LP_CNTR2AMSW		0x001E	/* 2A msw. */
+#define	LP_CNTR2BLSW		0x0020	/* 2B lsw. */
+#define	LP_CNTR2BMSW		0x0022	/* 2B msw. */
+
+/* Miscellaneous Registers (read/write): */
+#define LP_MISC1		0x0088	/* Read/write Misc1. */
+#define LP_WRMISC2		0x0090	/* Write Misc2. */
+#define LP_RDMISC2		0x0082	/* Read Misc2. */
+
+/* Bit masks for MISC1 register that are the same for reads and writes. */
 #define MISC1_WENABLE		0x8000	/* enab writes to MISC2 (except Clear
 					 * Watchdog bit). */
 #define MISC1_WDISABLE		0x0000	/* Disable writes to MISC2. */
-#define MISC1_EDCAP		0x1000	/* enab edge capture on DIO chans
+#define MISC1_EDCAP		0x1000	/* Enable edge capture on DIO chans
 					 * specified by  LP_WRCAPSELx. */
 #define MISC1_NOEDCAP		0x0000	/* Disable edge capture on specified
 					 * DIO chans. */
 
-/*  Bit masks for MISC1 register reads. */
-#define RDMISC1_WDTIMEOUT	0x4000	/*  Watchdog timer timed out. */
+/* Bit masks for MISC1 register reads. */
+#define RDMISC1_WDTIMEOUT	0x4000	/* Watchdog timer timed out. */
 
-/*  Bit masks for MISC2 register writes. */
-#define WRMISC2_WDCLEAR		0x8000	/*  Reset watchdog timer to zero. */
-#define WRMISC2_CHARGE_ENABLE	0x4000	/*  enab battery trickle charging. */
+/* Bit masks for MISC2 register writes. */
+#define WRMISC2_WDCLEAR		0x8000	/* Reset watchdog timer to zero. */
+#define WRMISC2_CHARGE_ENABLE	0x4000	/* Enable battery trickle charging. */
 
-/*  Bit masks for MISC2 register that are the same for reads and writes. */
-#define MISC2_BATT_ENABLE	0x0008	/*  Backup battery enable. */
-#define MISC2_WDENABLE		0x0004	/*  Watchdog timer enable. */
-#define MISC2_WDPERIOD_MASK	0x0003	/*  Watchdog interval */
-						/*  select mask. */
+/* Bit masks for MISC2 register that are the same for reads and writes. */
+#define MISC2_BATT_ENABLE	0x0008	/* Backup battery enable. */
+#define MISC2_WDENABLE		0x0004	/* Watchdog timer enable. */
+#define MISC2_WDPERIOD_MASK	0x0003	/* Watchdog interval select mask. */
 
-/*  Bit masks for ACON1 register. */
-#define A2_RUN			0x40000000	/*  Run A2 based on TSL2. */
-#define A1_RUN			0x20000000	/*  Run A1 based on TSL1. */
-#define A1_SWAP			0x00200000	/*  Use big-endian for A1. */
-#define A2_SWAP			0x00100000	/*  Use big-endian for A2. */
-#define WS_MODES		0x00019999	/*  WS0 = TSL1 trigger */
-						/*  input, WS1-WS4 = */
-						/*  CS* outputs. */
+/* Bit masks for ACON1 register. */
+#define A2_RUN			0x40000000	/* Run A2 based on TSL2. */
+#define A1_RUN			0x20000000	/* Run A1 based on TSL1. */
+#define A1_SWAP			0x00200000	/* Use big-endian for A1. */
+#define A2_SWAP			0x00100000	/* Use big-endian for A2. */
+#define WS_MODES		0x00019999	/* WS0 = TSL1 trigger input,
+						 * WS1-WS4 = CS* outputs. */
 
 #if PLATFORM == INTEL		/* Base ACON1 config: always run A1 based
 				 * on TSL1. */
@@ -338,266 +302,245 @@
 #endif
 
 #define ACON1_ADCSTART		ACON1_BASE	/* Start ADC: run A1
-						 *  based on TSL1. */
+						 * based on TSL1. */
 #define ACON1_DACSTART		(ACON1_BASE | A2_RUN)
 /* Start transmit to DAC: run A2 based on TSL2. */
-#define ACON1_DACSTOP		ACON1_BASE	/*  Halt A2. */
-
-/*  Bit masks for ACON2 register. */
-#define A1_CLKSRC_BCLK1		0x00000000	/*  A1 bit rate = BCLK1 (ADC). */
-#define A2_CLKSRC_X1		0x00800000	/*  A2 bit rate = ACLK/1 (DACs). */
-#define A2_CLKSRC_X2		0x00C00000	/*  A2 bit rate = ACLK/2 (DACs). */
-#define A2_CLKSRC_X4		0x01400000	/*  A2 bit rate = ACLK/4 (DACs). */
-#define INVERT_BCLK2		0x00100000	/*  Invert BCLK2 (DACs). */
-#define BCLK2_OE		0x00040000	/*  enab BCLK2 (DACs). */
-#define ACON2_XORMASK		0x000C0000	/*  XOR mask for ACON2 */
-						/*  active-low bits. */
-
-#define ACON2_INIT		(ACON2_XORMASK ^ (A1_CLKSRC_BCLK1 | A2_CLKSRC_X2 | INVERT_BCLK2 | BCLK2_OE))
-
-/*  Bit masks for timeslot records. */
-#define WS1		     	0x40000000	/*  WS output to assert. */
-#define WS2		     	0x20000000
-#define WS3		     	0x10000000
-#define WS4		     	0x08000000
+#define ACON1_DACSTOP		ACON1_BASE	/* Halt A2. */
+
+/* Bit masks for ACON2 register. */
+#define A1_CLKSRC_BCLK1		0x00000000	/* A1 bit rate = BCLK1 (ADC). */
+#define A2_CLKSRC_X1		0x00800000	/* A2 bit rate = ACLK/1
+						 * (DACs). */
+#define A2_CLKSRC_X2		0x00C00000	/* A2 bit rate = ACLK/2
+						 * (DACs). */
+#define A2_CLKSRC_X4		0x01400000	/* A2 bit rate = ACLK/4
+						 * (DACs). */
+#define INVERT_BCLK2		0x00100000	/* Invert BCLK2 (DACs). */
+#define BCLK2_OE		0x00040000	/* Enable BCLK2 (DACs). */
+#define ACON2_XORMASK		0x000C0000	/* XOR mask for ACON2
+						 * active-low bits. */
+
+#define ACON2_INIT		(ACON2_XORMASK ^ \
+				 (A1_CLKSRC_BCLK1 | A2_CLKSRC_X2 | \
+				  INVERT_BCLK2 | BCLK2_OE))
+
+/* Bit masks for timeslot records. */
+#define WS1			0x40000000	/* WS output to assert. */
+#define WS2			0x20000000
+#define WS3			0x10000000
+#define WS4			0x08000000
 #define RSD1			0x01000000	/* Shift A1 data in on SD1. */
-#define SDW_A1			0x00800000	/* Store rcv'd char at next
-						 * char slot of DWORD1 buffer. */
+#define SDW_A1			0x00800000	/* Store rcv'd char at next char
+						 * slot of DWORD1 buffer. */
 #define SIB_A1			0x00400000	/* Store rcv'd char at next
 						 * char slot of FB1 buffer. */
 #define SF_A1			0x00200000	/* Write unsigned long
 						 * buffer to input FIFO. */
 
 /* Select parallel-to-serial converter's data source: */
-#define XFIFO_0			0x00000000	/*    Data fifo byte 0. */
-#define XFIFO_1			0x00000010	/*    Data fifo byte 1. */
-#define XFIFO_2			0x00000020	/*    Data fifo byte 2. */
-#define XFIFO_3			0x00000030	/*    Data fifo byte 3. */
-#define XFB0			0x00000040	/*    FB_BUFFER byte 0. */
-#define XFB1			0x00000050	/*    FB_BUFFER byte 1. */
-#define XFB2			0x00000060	/*    FB_BUFFER byte 2. */
-#define XFB3			0x00000070	/*    FB_BUFFER byte 3. */
+#define XFIFO_0			0x00000000	/* Data fifo byte 0. */
+#define XFIFO_1			0x00000010	/* Data fifo byte 1. */
+#define XFIFO_2			0x00000020	/* Data fifo byte 2. */
+#define XFIFO_3			0x00000030	/* Data fifo byte 3. */
+#define XFB0			0x00000040	/* FB_BUFFER byte 0. */
+#define XFB1			0x00000050	/* FB_BUFFER byte 1. */
+#define XFB2			0x00000060	/* FB_BUFFER byte 2. */
+#define XFB3			0x00000070	/* FB_BUFFER byte 3. */
 #define SIB_A2			0x00000200	/* Store next dword from A2's
-						 * input shifter to FB2 buffer. */
+						 * input shifter to FB2
+						 * buffer. */
 #define SF_A2			0x00000100	/* Store next dword from A2's
 						 * input shifter to its input
 						 * fifo. */
 #define LF_A2			0x00000080	/* Load next dword from A2's
 						 * output fifo into its
 						 * output dword buffer. */
-#define XSD2			0x00000008	/*  Shift data out on SD2. */
-#define RSD3			0x00001800	/*  Shift data in on SD3. */
-#define RSD2			0x00001000	/*  Shift data in on SD2. */
-#define LOW_A2			0x00000002	/*  Drive last SD low */
-						/*  for 7 clks, then */
-						/*  tri-state. */
-#define EOS		     	0x00000001	/*  End of superframe. */
-
-/*  I2C configuration constants. */
-#define I2C_CLKSEL		0x0400
-/* I2C bit rate = PCIclk/480 = 68.75 KHz. */
-
-#define I2C_BITRATE		68.75
-/* I2C bus data bit rate (determined by I2C_CLKSEL) in KHz. */
-
-#define I2C_WRTIME		15.0
-/* Worst case time, in msec, for EEPROM internal write op. */
-
-/*  I2C manifest constants. */
-
-/*  Max retries to wait for EEPROM write. */
+#define XSD2			0x00000008	/* Shift data out on SD2. */
+#define RSD3			0x00001800	/* Shift data in on SD3. */
+#define RSD2			0x00001000	/* Shift data in on SD2. */
+#define LOW_A2			0x00000002	/* Drive last SD low for 7 clks,
+						 * then tri-state. */
+#define EOS			0x00000001	/* End of superframe. */
+
+/* I2C configuration constants. */
+#define I2C_CLKSEL		0x0400		/* I2C bit rate =
+						 * PCIclk/480 = 68.75 KHz. */
+#define I2C_BITRATE		68.75		/* I2C bus data bit rate
+						 * (determined by I2C_CLKSEL)
+						 * in KHz. */
+#define I2C_WRTIME		15.0		/* Worst case time, in msec,
+						 * for EEPROM internal write
+						 * op. */
+
+/* I2C manifest constants. */
+
+/* Max retries to wait for EEPROM write. */
 #define I2C_RETRIES		(I2C_WRTIME * I2C_BITRATE / 9.0)
-#define I2C_ERR			0x0002	/*  I2C control/status */
-						/*  flag ERROR. */
-#define I2C_BUSY		0x0001	/*  I2C control/status */
-						/*  flag BUSY. */
-#define I2C_ABORT		0x0080	/*  I2C status flag ABORT. */
-#define I2C_ATTRSTART		0x3	/*  I2C attribute START. */
-#define I2C_ATTRCONT		0x2	/*  I2C attribute CONT. */
-#define I2C_ATTRSTOP		0x1	/*  I2C attribute STOP. */
-#define I2C_ATTRNOP		0x0	/*  I2C attribute NOP. */
-
-/*  I2C read command  | EEPROM address. */
+#define I2C_ERR			0x0002	/* I2C control/status flag ERROR. */
+#define I2C_BUSY		0x0001	/* I2C control/status flag BUSY. */
+#define I2C_ABORT		0x0080	/* I2C status flag ABORT. */
+#define I2C_ATTRSTART		0x3	/* I2C attribute START. */
+#define I2C_ATTRCONT		0x2	/* I2C attribute CONT. */
+#define I2C_ATTRSTOP		0x1	/* I2C attribute STOP. */
+#define I2C_ATTRNOP		0x0	/* I2C attribute NOP. */
+
+/* I2C read command  | EEPROM address. */
 #define I2CR			(devpriv->I2CAdrs | 1)
 
-/*  I2C write command | EEPROM address. */
+/* I2C write command | EEPROM address. */
 #define I2CW			(devpriv->I2CAdrs)
 
-/*  Code macros used for constructing I2C command bytes. */
+/* Code macros used for constructing I2C command bytes. */
 #define I2C_B2(ATTR, VAL)	(((ATTR) << 6) | ((VAL) << 24))
 #define I2C_B1(ATTR, VAL)	(((ATTR) << 4) | ((VAL) << 16))
 #define I2C_B0(ATTR, VAL)	(((ATTR) << 2) | ((VAL) <<  8))
 
-/* oldest */
-#define P_DEBICFGq              0x007C	/*  DEBI configuration. */
-#define P_DEBICMDq              0x0080	/*  DEBI command. */
-#define P_DEBIPAGEq             0x0084	/*  DEBI page. */
-#define P_DEBIADq               0x0088	/*  DEBI target address. */
-
-#define DEBI_CFG_TOQ		0x03C00000	/*  timeout (15 PCI cycles) */
-#define DEBI_CFG_FASTQ		0x10000000	/*  fast mode enable */
-#define DEBI_CFG_16Q		0x00080000	/*  16-bit access enable */
-#define DEBI_CFG_INCQ		0x00040000	/*  enable address increment */
-#define DEBI_CFG_TIMEROFFQ	0x00010000	/*  disable timer */
-#define DEBI_CMD_RDQ		0x00050000	/*  read immediate 2 bytes */
-#define DEBI_CMD_WRQ		0x00040000	/*  write immediate 2 bytes */
-#define DEBI_PAGE_DISABLEQ	0x00000000	/*  paging disable */
-
-/*  DEBI command constants. */
-#define DEBI_CMD_SIZE16		(2 << 17)	/*  Transfer size is */
-						/*  always 2 bytes. */
-#define DEBI_CMD_READ		0x00010000	/*  Read operation. */
-#define DEBI_CMD_WRITE		0x00000000	/*  Write operation. */
-
-/*  Read immediate 2 bytes. */
-#define DEBI_CMD_RDWORD		(DEBI_CMD_READ  | DEBI_CMD_SIZE16)
-
-/*  Write immediate 2 bytes. */
+/* DEBI command constants. */
+#define DEBI_CMD_SIZE16		(2 << 17)	/* Transfer size is always
+						 * 2 bytes. */
+#define DEBI_CMD_READ		0x00010000	/* Read operation. */
+#define DEBI_CMD_WRITE		0x00000000	/* Write operation. */
+
+/* Read immediate 2 bytes. */
+#define DEBI_CMD_RDWORD		(DEBI_CMD_READ | DEBI_CMD_SIZE16)
+
+/* Write immediate 2 bytes. */
 #define DEBI_CMD_WRWORD		(DEBI_CMD_WRITE | DEBI_CMD_SIZE16)
 
-/*  DEBI configuration constants. */
-#define DEBI_CFG_XIRQ_EN	0x80000000	/*  enab external */
-						/*  interrupt on GPIO3. */
-#define DEBI_CFG_XRESUME	0x40000000	/*  Resume block */
-						/*  transfer when XIRQ */
-						/*  deasserted. */
-#define DEBI_CFG_FAST		0x10000000	/*  Fast mode enable. */
-
-/*  4-bit field that specifies DEBI timeout value in PCI clock cycles: */
-#define DEBI_CFG_TOUT_BIT	22	/*    Finish DEBI cycle after */
-					/*    this many clocks. */
-
-/*  2-bit field that specifies Endian byte lane steering: */
-#define DEBI_CFG_SWAP_NONE	0x00000000	/*    Straight - don't */
-						/*    swap any bytes */
-						/*    (Intel). */
-#define DEBI_CFG_SWAP_2		0x00100000	/*    2-byte swap (Motorola). */
-#define DEBI_CFG_SWAP_4		0x00200000	/*    4-byte swap. */
-#define DEBI_CFG_16		0x00080000	/*  Slave is able to */
-						/*  serve 16-bit */
-						/*  cycles. */
-
-#define DEBI_CFG_SLAVE16	0x00080000	/*  Slave is able to */
-						/*  serve 16-bit */
-						/*  cycles. */
-#define DEBI_CFG_INC		0x00040000	/*  enab address */
-						/*  increment for block */
-						/*  transfers. */
-#define DEBI_CFG_INTEL		0x00020000	/*  Intel style local bus. */
-#define DEBI_CFG_TIMEROFF	0x00010000	/*  Disable timer. */
+/* DEBI configuration constants. */
+#define DEBI_CFG_XIRQ_EN	0x80000000	/* Enable external interrupt
+						 * on GPIO3. */
+#define DEBI_CFG_XRESUME	0x40000000	/* Resume block */
+						/* Transfer when XIRQ
+						 * deasserted. */
+#define DEBI_CFG_TOQ		0x03C00000	/* Timeout (15 PCI cycles). */
+#define DEBI_CFG_FAST		0x10000000	/* Fast mode enable. */
+
+/* 4-bit field that specifies DEBI timeout value in PCI clock cycles: */
+#define DEBI_CFG_TOUT_BIT	22	/* Finish DEBI cycle after this many
+					 * clocks. */
+
+/* 2-bit field that specifies Endian byte lane steering: */
+#define DEBI_CFG_SWAP_NONE	0x00000000	/* Straight - don't swap any
+						 * bytes (Intel). */
+#define DEBI_CFG_SWAP_2		0x00100000	/* 2-byte swap (Motorola). */
+#define DEBI_CFG_SWAP_4		0x00200000	/* 4-byte swap. */
+#define DEBI_CFG_SLAVE16	0x00080000	/* Slave is able to serve
+						 * 16-bit cycles. */
+#define DEBI_CFG_INC		0x00040000	/* Enable address increment
+						 * for block transfers. */
+#define DEBI_CFG_INTEL		0x00020000	/* Intel style local bus. */
+#define DEBI_CFG_TIMEROFF	0x00010000	/* Disable timer. */
 
 #if PLATFORM == INTEL
 
-#define DEBI_TOUT		7	/*  Wait 7 PCI clocks */
-						/*  (212 ns) before */
-						/*  polling RDY. */
+#define DEBI_TOUT		7	/* Wait 7 PCI clocks (212 ns) before
+					 * polling RDY. */
 
-/*  Intel byte lane steering (pass through all byte lanes). */
+/* Intel byte lane steering (pass through all byte lanes). */
 #define DEBI_SWAP		DEBI_CFG_SWAP_NONE
 
 #elif PLATFORM == MOTOROLA
 
-#define DEBI_TOUT		15	/*  Wait 15 PCI clocks (454 ns) */
-					/*  maximum before timing out. */
-#define DEBI_SWAP		DEBI_CFG_SWAP_2	/*  Motorola byte lane steering. */
+#define DEBI_TOUT		15	/* Wait 15 PCI clocks (454 ns) maximum
+					 * before timing out. */
+
+/* Motorola byte lane steering. */
+#define DEBI_SWAP		DEBI_CFG_SWAP_2
 
 #endif
 
-/*  DEBI page table constants. */
-#define DEBI_PAGE_DISABLE	0x00000000	/*  Paging disable. */
-
-/* ******* EXTRA FROM OTHER SANSORAY  * .h  ******* */
-
-/*  LoadSrc values: */
-#define LOADSRC_INDX		0	/*  Preload core in response to */
-					/*  Index. */
-#define LOADSRC_OVER		1	/*  Preload core in response to */
-					/*  Overflow. */
-#define LOADSRCB_OVERA		2	/*  Preload B core in response */
-					/*  to A Overflow. */
-#define LOADSRC_NONE		3	/*  Never preload core. */
-
-/*  IntSrc values: */
-#define INTSRC_NONE 		0	/*  Interrupts disabled. */
-#define INTSRC_OVER 		1	/*  Interrupt on Overflow. */
-#define INTSRC_INDX 		2	/*  Interrupt on Index. */
-#define INTSRC_BOTH 		3	/*  Interrupt on Index or Overflow. */
-
-/*  LatchSrc values: */
-#define LATCHSRC_AB_READ	0	/*  Latch on read. */
-#define LATCHSRC_A_INDXA	1	/*  Latch A on A Index. */
-#define LATCHSRC_B_INDXB	2	/*  Latch B on B Index. */
-#define LATCHSRC_B_OVERA	3	/*  Latch B on A Overflow. */
-
-/*  IndxSrc values: */
-#define INDXSRC_HARD		0	/*  Hardware or software index. */
-#define INDXSRC_SOFT		1	/*  Software index only. */
-
-/*  IndxPol values: */
-#define INDXPOL_POS 		0	/*  Index input is active high. */
-#define INDXPOL_NEG 		1	/*  Index input is active low. */
-
-/*  ClkSrc values: */
-#define CLKSRC_COUNTER		0	/*  Counter mode. */
-#define CLKSRC_TIMER		2	/*  Timer mode. */
-#define CLKSRC_EXTENDER		3	/*  Extender mode. */
-
-/*  ClkPol values: */
-#define CLKPOL_POS		0	/*  Counter/Extender clock is */
-					/*  active high. */
-#define CLKPOL_NEG		1	/*  Counter/Extender clock is */
-					/*  active low. */
-#define CNTDIR_UP		0	/*  Timer counts up. */
-#define CNTDIR_DOWN 		1	/*  Timer counts down. */
-
-/*  ClkEnab values: */
-#define CLKENAB_ALWAYS		0	/*  Clock always enabled. */
-#define CLKENAB_INDEX		1	/*  Clock is enabled by index. */
-
-/*  ClkMult values: */
-#define CLKMULT_4X 		0	/*  4x clock multiplier. */
-#define CLKMULT_2X 		1	/*  2x clock multiplier. */
-#define CLKMULT_1X 		2	/*  1x clock multiplier. */
-
-/*  Bit Field positions in COUNTER_SETUP structure: */
-#define BF_LOADSRC		9	/*  Preload trigger. */
-#define BF_INDXSRC		7	/*  Index source. */
-#define BF_INDXPOL		6	/*  Index polarity. */
-#define BF_CLKSRC		4	/*  Clock source. */
-#define BF_CLKPOL		3	/*  Clock polarity/count direction. */
-#define BF_CLKMULT		1	/*  Clock multiplier. */
-#define BF_CLKENAB		0	/*  Clock enable. */
-
-/*  Enumerated counter operating modes specified by ClkSrc bit field in */
-/*  a COUNTER_SETUP. */
-
-#define CLKSRC_COUNTER		0	/*  Counter: ENC_C clock, ENC_D */
-					/*  direction. */
-#define CLKSRC_TIMER		2	/*  Timer: SYS_C clock, */
-					/*  direction specified by */
-					/*  ClkPol. */
-#define CLKSRC_EXTENDER		3	/*  Extender: OVR_A clock, */
-					/*  ENC_D direction. */
-
-/*  Enumerated counter clock multipliers. */
-
-#define MULT_X0			0x0003	/*  Supports no multipliers; */
-					/*  fixed physical multiplier = */
-					/*  3. */
-#define MULT_X1			0x0002	/*  Supports multiplier x1; */
-					/*  fixed physical multiplier = */
-					/*  2. */
-#define MULT_X2			0x0001	/*  Supports multipliers x1, */
-					/*  x2; physical multipliers = */
-					/*  1 or 2. */
-#define MULT_X4			0x0000	/*  Supports multipliers x1, */
-					/*  x2, x4; physical */
-					/*  multipliers = 0, 1 or 2. */
-
-/*  Sanity-check limits for parameters. */
-
-#define NUM_COUNTERS		6	/*  Maximum valid counter */
-					/*  logical channel number. */
+/* DEBI page table constants. */
+#define DEBI_PAGE_DISABLE	0x00000000	/* Paging disable. */
+
+/* ******* EXTRA FROM OTHER SENSORAY  * .h  ******* */
+
+/* LoadSrc values: */
+#define LOADSRC_INDX		0	/* Preload core in response to Index. */
+#define LOADSRC_OVER		1	/* Preload core in response to
+					 * Overflow. */
+#define LOADSRCB_OVERA		2	/* Preload B core in response to
+					 * A Overflow. */
+#define LOADSRC_NONE		3	/* Never preload core. */
+
+/* IntSrc values: */
+#define INTSRC_NONE		0	/* Interrupts disabled. */
+#define INTSRC_OVER		1	/* Interrupt on Overflow. */
+#define INTSRC_INDX		2	/* Interrupt on Index. */
+#define INTSRC_BOTH		3	/* Interrupt on Index or Overflow. */
+
+/* LatchSrc values: */
+#define LATCHSRC_AB_READ	0	/* Latch on read. */
+#define LATCHSRC_A_INDXA	1	/* Latch A on A Index. */
+#define LATCHSRC_B_INDXB	2	/* Latch B on B Index. */
+#define LATCHSRC_B_OVERA	3	/* Latch B on A Overflow. */
+
+/* IndxSrc values: */
+#define INDXSRC_HARD		0	/* Hardware or software index. */
+#define INDXSRC_SOFT		1	/* Software index only. */
+
+/* IndxPol values: */
+#define INDXPOL_POS		0	/* Index input is active high. */
+#define INDXPOL_NEG		1	/* Index input is active low. */
+
+/* ClkSrc values: */
+#define CLKSRC_COUNTER		0	/* Counter mode. */
+#define CLKSRC_TIMER		2	/* Timer mode. */
+#define CLKSRC_EXTENDER		3	/* Extender mode. */
+
+/* ClkPol values: */
+#define CLKPOL_POS		0	/* Counter/Extender clock is
+					 * active high. */
+#define CLKPOL_NEG		1	/* Counter/Extender clock is
+					 * active low. */
+#define CNTDIR_UP		0	/* Timer counts up. */
+#define CNTDIR_DOWN		1	/* Timer counts down. */
+
+/* ClkEnab values: */
+#define CLKENAB_ALWAYS		0	/* Clock always enabled. */
+#define CLKENAB_INDEX		1	/* Clock is enabled by index. */
+
+/* ClkMult values: */
+#define CLKMULT_4X		0	/* 4x clock multiplier. */
+#define CLKMULT_2X		1	/* 2x clock multiplier. */
+#define CLKMULT_1X		2	/* 1x clock multiplier. */
+
+/* Bit Field positions in COUNTER_SETUP structure: */
+#define BF_LOADSRC		9	/* Preload trigger. */
+#define BF_INDXSRC		7	/* Index source. */
+#define BF_INDXPOL		6	/* Index polarity. */
+#define BF_CLKSRC		4	/* Clock source. */
+#define BF_CLKPOL		3	/* Clock polarity/count direction. */
+#define BF_CLKMULT		1	/* Clock multiplier. */
+#define BF_CLKENAB		0	/* Clock enable. */
+
+/*
+ * Enumerated counter operating modes specified by ClkSrc bit field in
+ * a COUNTER_SETUP.
+ */
+
+#define CLKSRC_COUNTER		0	/* Counter: ENC_C clock,
+					 * ENC_D direction. */
+#define CLKSRC_TIMER		2	/* Timer: SYS_C clock, direction
+					 * specified by ClkPol. */
+#define CLKSRC_EXTENDER		3	/* Extender: OVR_A clock,
+					 * ENC_D direction. */
+
+/* Enumerated counter clock multipliers. */
+
+#define MULT_X0			0x0003	/* Supports no multipliers;
+					 * fixed physical multiplier = 3. */
+#define MULT_X1			0x0002	/* Supports multiplier x1;
+					 * fixed physical multiplier = 2. */
+#define MULT_X2			0x0001	/* Supports multipliers x1, x2;
+					 * physical multipliers = 1 or 2. */
+#define MULT_X4			0x0000	/* Supports multipliers x1, x2, x4;
+					 * physical multipliers = 0, 1 or 2. */
+
+/* Sanity-check limits for parameters. */
+
+#define NUM_COUNTERS		6	/* Maximum valid counter
+					 * logical channel number. */
 #define NUM_INTSOURCES		4
 #define NUM_LATCHSOURCES	4
 #define NUM_CLKMULTS		4
@@ -607,33 +550,33 @@
 #define NUM_INDEXSOURCES	2
 #define NUM_LOADTRIGS		4
 
-/*  Bit field positions in CRA and CRB counter control registers. */
-
-/*  Bit field positions in CRA: */
-#define CRABIT_INDXSRC_B	14	/*    B index source. */
-#define CRABIT_CLKSRC_B		12	/*    B clock source. */
-#define CRABIT_INDXPOL_A	11	/*    A index polarity. */
-#define CRABIT_LOADSRC_A	 9	/*    A preload trigger. */
-#define CRABIT_CLKMULT_A	 7	/*    A clock multiplier. */
-#define CRABIT_INTSRC_A		 5	/*    A interrupt source. */
-#define CRABIT_CLKPOL_A		 4	/*    A clock polarity. */
-#define CRABIT_INDXSRC_A	 2	/*    A index source. */
-#define CRABIT_CLKSRC_A		 0	/*    A clock source. */
-
-/*  Bit field positions in CRB: */
-#define CRBBIT_INTRESETCMD	15	/*    Interrupt reset command. */
-#define CRBBIT_INTRESET_B	14	/*    B interrupt reset enable. */
-#define CRBBIT_INTRESET_A	13	/*    A interrupt reset enable. */
-#define CRBBIT_CLKENAB_A	12	/*    A clock enable. */
-#define CRBBIT_INTSRC_B		10	/*    B interrupt source. */
-#define CRBBIT_LATCHSRC		 8	/*    A/B latch source. */
-#define CRBBIT_LOADSRC_B	 6	/*    B preload trigger. */
-#define CRBBIT_CLKMULT_B	 3	/*    B clock multiplier. */
-#define CRBBIT_CLKENAB_B	 2	/*    B clock enable. */
-#define CRBBIT_INDXPOL_B	 1	/*    B index polarity. */
-#define CRBBIT_CLKPOL_B		 0	/*    B clock polarity. */
-
-/*  Bit field masks for CRA and CRB. */
+/* Bit field positions in CRA and CRB counter control registers. */
+
+/* Bit field positions in CRA: */
+#define CRABIT_INDXSRC_B	14	/* B index source. */
+#define CRABIT_CLKSRC_B		12	/* B clock source. */
+#define CRABIT_INDXPOL_A	11	/* A index polarity. */
+#define CRABIT_LOADSRC_A	 9	/* A preload trigger. */
+#define CRABIT_CLKMULT_A	 7	/* A clock multiplier. */
+#define CRABIT_INTSRC_A		 5	/* A interrupt source. */
+#define CRABIT_CLKPOL_A		 4	/* A clock polarity. */
+#define CRABIT_INDXSRC_A	 2	/* A index source. */
+#define CRABIT_CLKSRC_A		 0	/* A clock source. */
+
+/* Bit field positions in CRB: */
+#define CRBBIT_INTRESETCMD	15	/* Interrupt reset command. */
+#define CRBBIT_INTRESET_B	14	/* B interrupt reset enable. */
+#define CRBBIT_INTRESET_A	13	/* A interrupt reset enable. */
+#define CRBBIT_CLKENAB_A	12	/* A clock enable. */
+#define CRBBIT_INTSRC_B		10	/* B interrupt source. */
+#define CRBBIT_LATCHSRC		 8	/* A/B latch source. */
+#define CRBBIT_LOADSRC_B	 6	/* B preload trigger. */
+#define CRBBIT_CLKMULT_B	 3	/* B clock multiplier. */
+#define CRBBIT_CLKENAB_B	 2	/* B clock enable. */
+#define CRBBIT_INDXPOL_B	 1	/* B index polarity. */
+#define CRBBIT_CLKPOL_B		 0	/* B clock polarity. */
+
+/* Bit field masks for CRA and CRB. */
 
 #define CRAMSK_INDXSRC_B	(3 << CRABIT_INDXSRC_B)
 #define CRAMSK_CLKSRC_B		(3 << CRABIT_CLKSRC_B)
@@ -657,9 +600,11 @@
 #define CRBMSK_INDXPOL_B	(1 << CRBBIT_INDXPOL_B)
 #define CRBMSK_CLKPOL_B		(1 << CRBBIT_CLKPOL_B)
 
-#define CRBMSK_INTCTRL		(CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B)	/*  Interrupt reset control bits. */
+/* Interrupt reset control bits. */
+#define CRBMSK_INTCTRL		\
+	(CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B)
 
-/*  Bit field positions for standardized SETUP structure. */
+/* Bit field positions for standardized SETUP structure. */
 
 #define STDBIT_INTSRC		13
 #define STDBIT_LATCHSRC		11
@@ -671,7 +616,7 @@
 #define STDBIT_CLKMULT		 1
 #define STDBIT_CLKENAB		 0
 
-/*  Bit field masks for standardized SETUP structure. */
+/* Bit field masks for standardized SETUP structure. */
 
 #define STDMSK_INTSRC		(3 << STDBIT_INTSRC)
 #define STDMSK_LATCHSRC		(3 << STDBIT_LATCHSRC)
@@ -688,3 +633,5 @@ struct bufferDMA {
 	void *LogicalBase;
 	uint32_t DMAHandle;
 };
+
+#endif

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index d2756b83b62d..a85e6bdcad07 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -65,8 +65,6 @@
 #define FALSE   (0)
 #endif
 
-#include <linux/slab.h>
-
 #define S626_SIZE 0x0200
 #define DMABUF_SIZE			4096	/*  4k pages */
 

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 99cd57b092ea..d2756b83b62d 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -17,11 +17,6 @@
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
 */
 
 /*

commit 12f4e2f280f99c967c2848e99f14e02b3c1cb209
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 15:42:58 2013 -0700

    staging: comedi: s626: remove the uint16_t casts of the bit values
    
    There are a number of uint16_t casts used in the #define's of the
    constant bit field values as well as the calls to DEBIreplace().
    These cause a number of sparse warnings of the type:
    
    warning: cast truncates bits from constant value (ffff1cff becomes 1cff)
    
    Remove all of the casts and change the types of the parameters to
    DEBIreplace from uin16_t to unsigned int. This fixes all the warnings.
    
    Mask the addr that is or'ed with DEBI_CMD_RDWORD then written to the
    P_DEBICMD register as well as the val written to the P_DEBIAD register
    with 0xffff. The addr and val are only 16-bits but the registers are
    32-bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 938dcd9f86f6..99cd57b092ea 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -642,27 +642,27 @@
 
 /*  Bit field masks for CRA and CRB. */
 
-#define CRAMSK_INDXSRC_B	((uint16_t)(3 << CRABIT_INDXSRC_B))
-#define CRAMSK_CLKSRC_B		((uint16_t)(3 << CRABIT_CLKSRC_B))
-#define CRAMSK_INDXPOL_A	((uint16_t)(1 << CRABIT_INDXPOL_A))
-#define CRAMSK_LOADSRC_A	((uint16_t)(3 << CRABIT_LOADSRC_A))
-#define CRAMSK_CLKMULT_A	((uint16_t)(3 << CRABIT_CLKMULT_A))
-#define CRAMSK_INTSRC_A		((uint16_t)(3 << CRABIT_INTSRC_A))
-#define CRAMSK_CLKPOL_A		((uint16_t)(3 << CRABIT_CLKPOL_A))
-#define CRAMSK_INDXSRC_A	((uint16_t)(3 << CRABIT_INDXSRC_A))
-#define CRAMSK_CLKSRC_A		((uint16_t)(3 << CRABIT_CLKSRC_A))
-
-#define CRBMSK_INTRESETCMD	((uint16_t)(1 << CRBBIT_INTRESETCMD))
-#define CRBMSK_INTRESET_B	((uint16_t)(1 << CRBBIT_INTRESET_B))
-#define CRBMSK_INTRESET_A	((uint16_t)(1 << CRBBIT_INTRESET_A))
-#define CRBMSK_CLKENAB_A	((uint16_t)(1 << CRBBIT_CLKENAB_A))
-#define CRBMSK_INTSRC_B		((uint16_t)(3 << CRBBIT_INTSRC_B))
-#define CRBMSK_LATCHSRC		((uint16_t)(3 << CRBBIT_LATCHSRC))
-#define CRBMSK_LOADSRC_B	((uint16_t)(3 << CRBBIT_LOADSRC_B))
-#define CRBMSK_CLKMULT_B	((uint16_t)(3 << CRBBIT_CLKMULT_B))
-#define CRBMSK_CLKENAB_B	((uint16_t)(1 << CRBBIT_CLKENAB_B))
-#define CRBMSK_INDXPOL_B	((uint16_t)(1 << CRBBIT_INDXPOL_B))
-#define CRBMSK_CLKPOL_B		((uint16_t)(1 << CRBBIT_CLKPOL_B))
+#define CRAMSK_INDXSRC_B	(3 << CRABIT_INDXSRC_B)
+#define CRAMSK_CLKSRC_B		(3 << CRABIT_CLKSRC_B)
+#define CRAMSK_INDXPOL_A	(1 << CRABIT_INDXPOL_A)
+#define CRAMSK_LOADSRC_A	(3 << CRABIT_LOADSRC_A)
+#define CRAMSK_CLKMULT_A	(3 << CRABIT_CLKMULT_A)
+#define CRAMSK_INTSRC_A		(3 << CRABIT_INTSRC_A)
+#define CRAMSK_CLKPOL_A		(3 << CRABIT_CLKPOL_A)
+#define CRAMSK_INDXSRC_A	(3 << CRABIT_INDXSRC_A)
+#define CRAMSK_CLKSRC_A		(3 << CRABIT_CLKSRC_A)
+
+#define CRBMSK_INTRESETCMD	(1 << CRBBIT_INTRESETCMD)
+#define CRBMSK_INTRESET_B	(1 << CRBBIT_INTRESET_B)
+#define CRBMSK_INTRESET_A	(1 << CRBBIT_INTRESET_A)
+#define CRBMSK_CLKENAB_A	(1 << CRBBIT_CLKENAB_A)
+#define CRBMSK_INTSRC_B		(3 << CRBBIT_INTSRC_B)
+#define CRBMSK_LATCHSRC		(3 << CRBBIT_LATCHSRC)
+#define CRBMSK_LOADSRC_B	(3 << CRBBIT_LOADSRC_B)
+#define CRBMSK_CLKMULT_B	(3 << CRBBIT_CLKMULT_B)
+#define CRBMSK_CLKENAB_B	(1 << CRBBIT_CLKENAB_B)
+#define CRBMSK_INDXPOL_B	(1 << CRBBIT_INDXPOL_B)
+#define CRBMSK_CLKPOL_B		(1 << CRBBIT_CLKPOL_B)
 
 #define CRBMSK_INTCTRL		(CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B)	/*  Interrupt reset control bits. */
 
@@ -680,15 +680,15 @@
 
 /*  Bit field masks for standardized SETUP structure. */
 
-#define STDMSK_INTSRC		((uint16_t)(3 << STDBIT_INTSRC))
-#define STDMSK_LATCHSRC		((uint16_t)(3 << STDBIT_LATCHSRC))
-#define STDMSK_LOADSRC		((uint16_t)(3 << STDBIT_LOADSRC))
-#define STDMSK_INDXSRC		((uint16_t)(1 << STDBIT_INDXSRC))
-#define STDMSK_INDXPOL		((uint16_t)(1 << STDBIT_INDXPOL))
-#define STDMSK_CLKSRC		((uint16_t)(3 << STDBIT_CLKSRC))
-#define STDMSK_CLKPOL		((uint16_t)(1 << STDBIT_CLKPOL))
-#define STDMSK_CLKMULT		((uint16_t)(3 << STDBIT_CLKMULT))
-#define STDMSK_CLKENAB		((uint16_t)(1 << STDBIT_CLKENAB))
+#define STDMSK_INTSRC		(3 << STDBIT_INTSRC)
+#define STDMSK_LATCHSRC		(3 << STDBIT_LATCHSRC)
+#define STDMSK_LOADSRC		(3 << STDBIT_LOADSRC)
+#define STDMSK_INDXSRC		(1 << STDBIT_INDXSRC)
+#define STDMSK_INDXPOL		(1 << STDBIT_INDXPOL)
+#define STDMSK_CLKSRC		(3 << STDBIT_CLKSRC)
+#define STDMSK_CLKPOL		(1 << STDBIT_CLKPOL)
+#define STDMSK_CLKMULT		(3 << STDBIT_CLKMULT)
+#define STDMSK_CLKENAB		(1 << STDBIT_CLKENAB)
 
 struct bufferDMA {
 	dma_addr_t PhysicalBase;

commit 100b4edcad71cea9cd815c3519bfe2e93811bd44
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 15:54:20 2013 -0700

    staging: comedi: s626: simplify dio register access
    
    This driver has three dio subdevices, each with 16 channels. These
    subdevices use hardware registers that are spaced 0x10 bytes apart
    for each "group" of 16 channels.
    
    Create new macros to get the correct addresses for each register
    based on the dio "group". Use the s->private (void *) to hold the
    "group" number to use in the subdevice functions.
    
    This allows removing struct dio_private and all its uses. It also
    removes the ugly casts used to get the register address.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index ff4b3a5e4e5f..938dcd9f86f6 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -267,36 +267,17 @@
 #define LP_DACPOL		0x0082	/*   Write DAC polarity. */
 #define LP_GSEL			0x0084	/*   Write ADC gain. */
 #define LP_ISEL			0x0086	/*   Write ADC channel select. */
-/*  Digital I/O (write only): */
-#define LP_WRINTSELA		0x0042	/*   Write A interrupt enable. */
-#define LP_WREDGSELA		0x0044	/*   Write A edge selection. */
-#define LP_WRCAPSELA		0x0046	/*   Write A capture enable. */
-#define LP_WRDOUTA		0x0048	/*   Write A digital output. */
-#define LP_WRINTSELB		0x0052	/*   Write B interrupt enable. */
-#define LP_WREDGSELB		0x0054	/*   Write B edge selection. */
-#define LP_WRCAPSELB		0x0056	/*   Write B capture enable. */
-#define LP_WRDOUTB		0x0058	/*   Write B digital output. */
-#define LP_WRINTSELC		0x0062	/*   Write C interrupt enable. */
-#define LP_WREDGSELC		0x0064	/*   Write C edge selection. */
-#define LP_WRCAPSELC		0x0066	/*   Write C capture enable. */
-#define LP_WRDOUTC		0x0068	/*   Write C digital output. */
-
-/*  Digital I/O (read only): */
-#define LP_RDDINA		0x0040	/*   Read digital input. */
-#define LP_RDCAPFLGA		0x0048	/*   Read edges captured. */
-#define LP_RDINTSELA		0x004A	/*   Read interrupt enable register. */
-#define LP_RDEDGSELA		0x004C	/*   Read edge selection register. */
-#define LP_RDCAPSELA		0x004E	/*   Read capture enable register. */
-#define LP_RDDINB		0x0050	/*   Read digital input. */
-#define LP_RDCAPFLGB		0x0058	/*   Read edges captured. */
-#define LP_RDINTSELB		0x005A	/*   Read interrupt enable register. */
-#define LP_RDEDGSELB		0x005C	/*   Read edge selection register. */
-#define LP_RDCAPSELB		0x005E	/*   Read capture enable register. */
-#define LP_RDDINC		0x0060	/*   Read digital input. */
-#define LP_RDCAPFLGC		0x0068	/*   Read edges captured. */
-#define LP_RDINTSELC		0x006A	/*   Read interrupt enable register. */
-#define LP_RDEDGSELC		0x006C	/*   Read edge selection register. */
-#define LP_RDCAPSELC		0x006E	/*   Read capture enable register. */
+
+/* Digital I/O registers */
+#define LP_RDDIN(x)		(0x0040 + (x) * 0x10)	/* R: digital input */
+#define LP_WRINTSEL(x)		(0x0042 + (x) * 0x10)	/* W: int enable */
+#define LP_WREDGSEL(x)		(0x0044 + (x) * 0x10)	/* W: edge selection */
+#define LP_WRCAPSEL(x)		(0x0046 + (x) * 0x10)	/* W: capture enable */
+#define LP_RDCAPFLG(x)		(0x0048 + (x) * 0x10)	/* R: edges captured */
+#define LP_WRDOUT(x)		(0x0048 + (x) * 0x10)	/* W: digital output */
+#define LP_RDINTSEL(x)		(0x004a + (x) * 0x10)	/* R: int enable */
+#define LP_RDEDGSEL(x)		(0x004c + (x) * 0x10)	/* R: edge selection */
+#define LP_RDCAPSEL(x)		(0x004e + (x) * 0x10)	/* R: capture enable */
 
 /*  Counter Registers (read/write): */
 #define LP_CR0A			0x0000	/*   0A setup register. */

commit 4f6c7bf992bc6f1bbf38b08e9b3c8a21865888f2
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:23:22 2012 -0700

    staging: comedi: s626: cleanup ioremap()
    
    The local variable 'resourceStart' is only used in the ioremap()
    to hold the PCI bar 0 base address. Just use the pci_resource_start()
    directly in the ioremap().
    
    Also, instead of assuming the resource size for the ioremap, use
    pci_resource_len() to get the actual size.
    
    Remove the kernel noise when the ioremap fails and change the error
    code from -ENODEV to -ENOMEM.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 8a8f196cf153..ff4b3a5e4e5f 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -73,7 +73,6 @@
 #include <linux/slab.h>
 
 #define S626_SIZE 0x0200
-#define SIZEOF_ADDRESS_SPACE		0x0200
 #define DMABUF_SIZE			4096	/*  4k pages */
 
 #define S626_ADC_CHANNELS       16

commit b13bc8dda81c54a66a1c84e66f60b8feba659f28
Merge: 9fc377799bc9 419e9266884f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 26 11:14:49 2012 -0700

    Merge tag 'staging-3.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging tree patches from Greg Kroah-Hartman:
     "Here's the big staging tree merge for the 3.6-rc1 merge window.
    
      There are some patches in here outside of drivers/staging/, notibly
      the iio code (which is still stradeling the staging / not staging
      boundry), the pstore code, and the tracing code.  All of these have
      gotten acks from the various subsystem maintainers to be included in
      this tree.  The pstore and tracing patches are related, and are coming
      here as they replace one of the android staging drivers.
    
      Otherwise, the normal staging mess.  Lots of cleanups and a few new
      drivers (some iio drivers, and the large csr wireless driver
      abomination.)
    
      Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>"
    
    Fixed up trivial conflicts in drivers/staging/comedi/drivers/s626.h and
    drivers/staging/gdm72xx/netlink_k.c
    
    * tag 'staging-3.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (1108 commits)
      staging: csr: delete a bunch of unused library functions
      staging: csr: remove csr_utf16.c
      staging: csr: remove csr_pmem.h
      staging: csr: remove CsrPmemAlloc
      staging: csr: remove CsrPmemFree()
      staging: csr: remove CsrMemAllocDma()
      staging: csr: remove CsrMemCalloc()
      staging: csr: remove CsrMemAlloc()
      staging: csr: remove CsrMemFree() and CsrMemFreeDma()
      staging: csr: remove csr_util.h
      staging: csr: remove CsrOffSetOf()
      stating: csr: remove unneeded #includes in csr_util.c
      staging: csr: make CsrUInt16ToHex static
      staging: csr: remove CsrMemCpy()
      staging: csr: remove CsrStrLen()
      staging: csr: remove CsrVsnprintf()
      staging: csr: remove CsrStrDup
      staging: csr: remove CsrStrChr()
      staging: csr: remove CsrStrNCmp
      staging: csr: remove CsrStrCmp
      ...

commit 6ac7d11527a31d01b566a5c45369180e326ff4f1
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Wed Jun 6 14:17:46 2012 +0200

    treewide: Put a space between #include and FILE
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 2d1afecbbb60..92d3ea5eb44d 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -80,7 +80,7 @@
 #define INLINE static __inline
 #endif
 
-#include<linux/slab.h>
+#include <linux/slab.h>
 
 #define S626_SIZE 0x0200
 #define SIZEOF_ADDRESS_SPACE		0x0200

commit 90fd56af25b7835118657833a52bb4c85a911de7
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 19:27:43 2012 -0700

    staging: comedi: s626: remove private INLINE macro
    
    The INLINE macro is not used in the code. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 82de03fb9c4c..179623634732 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -70,10 +70,6 @@
 #define FALSE   (0)
 #endif
 
-#if !defined(INLINE)
-#define INLINE static __inline
-#endif
-
 #include<linux/slab.h>
 
 #define S626_SIZE 0x0200

commit bdf5aa39f7a42fc49903d456baaba11efc4d4243
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 19:27:25 2012 -0700

    staging: comedi: s626: remove private DEBUG macro
    
    The private DEBUG macro defined in this driver outputs a lot
    of function tracing noise. This information might be useful
    when first developing the driver but should not be in the
    mainlined code.
    
    If any of this is needed in the future it should be added back
    using the proper dev_printk interface.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 2d1afecbbb60..82de03fb9c4c 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -62,12 +62,6 @@
    comedi_do_insn(cf,&insn); // executing configuration
 */
 
-#ifdef _DEBUG_
-#define DEBUG(...);        printk(__VA_ARGS__);
-#else
-#define DEBUG(...)
-#endif
-
 #if !defined(TRUE)
 #define TRUE    (1)
 #endif

commit 56b8421ceef7f2dae95b882034ebf6958bad58f6
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Thu Jun 10 23:38:29 2010 +0200

    Staging: comedi: Remove typedefs
    
    Remove all remaining typedefs from comedi drivers
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index d02742a95294..2d1afecbbb60 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -720,15 +720,6 @@
 #define STDMSK_CLKMULT		((uint16_t)(3 << STDBIT_CLKMULT))
 #define STDMSK_CLKENAB		((uint16_t)(1 << STDBIT_CLKENAB))
 
-/* typedef struct indexCounter */
-/* { */
-/*   unsigned int ao; */
-/*   unsigned int ai; */
-/*   unsigned int digout; */
-/*   unsigned int digin; */
-/*   unsigned int enc; */
-/* }CallCounter; */
-
 struct bufferDMA {
 	dma_addr_t PhysicalBase;
 	void *LogicalBase;

commit d1babfd46609a3380ca4e8df97568e7da9b02eab
Author: Shawn Bohrer <shawn.bohrer@gmail.com>
Date:   Sun Oct 18 15:32:19 2009 -0500

    Staging: comedi: remove EXTERN macro since it is not used
    
    Signed-off-by: Shawn Bohrer <shawn.bohrer@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 1d04922ea16c..d02742a95294 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -76,14 +76,6 @@
 #define FALSE   (0)
 #endif
 
-#if !defined(EXTERN)
-#if defined(__cplusplus)
-#define EXTERN extern "C"
-#else
-#define EXTERN extern
-#endif
-#endif
-
 #if !defined(INLINE)
 #define INLINE static __inline
 #endif

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 27ae02be5300..1d04922ea16c 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -134,17 +134,17 @@
 #define DAC_WDMABUF_OS		ADC_DMABUF_DWORDS
 
 /*  Interrupt enab bit in ISR and IER. */
-#define IRQ_GPIO3		0x00000040  /*  IRQ enable for GPIO3. */
+#define IRQ_GPIO3		0x00000040	/*  IRQ enable for GPIO3. */
 #define IRQ_RPS1                0x10000000
 #define ISR_AFOU		0x00000800
 /* Audio fifo under/overflow  detected. */
 
-#define IRQ_COINT1A             0x0400 /* conter 1A overflow interrupt mask */
-#define IRQ_COINT1B             0x0800 /* conter 1B overflow interrupt mask */
-#define IRQ_COINT2A             0x1000 /* conter 2A overflow interrupt mask */
-#define IRQ_COINT2B             0x2000 /* conter 2B overflow interrupt mask */
-#define IRQ_COINT3A             0x4000 /* conter 3A overflow interrupt mask */
-#define IRQ_COINT3B             0x8000 /* conter 3B overflow interrupt mask */
+#define IRQ_COINT1A             0x0400	/* conter 1A overflow interrupt mask */
+#define IRQ_COINT1B             0x0800	/* conter 1B overflow interrupt mask */
+#define IRQ_COINT2A             0x1000	/* conter 2A overflow interrupt mask */
+#define IRQ_COINT2B             0x2000	/* conter 2B overflow interrupt mask */
+#define IRQ_COINT3A             0x4000	/* conter 3A overflow interrupt mask */
+#define IRQ_COINT3B             0x8000	/* conter 3B overflow interrupt mask */
 
 /*  RPS command codes. */
 #define RPS_CLRSIGNAL		0x00000000	/*  CLEAR SIGNAL */
@@ -438,7 +438,6 @@
 						/*  tri-state. */
 #define EOS		     	0x00000001	/*  End of superframe. */
 
-
 /*  I2C configuration constants. */
 #define I2C_CLKSEL		0x0400
 /* I2C bit rate = PCIclk/480 = 68.75 KHz. */
@@ -729,7 +728,6 @@
 #define STDMSK_CLKMULT		((uint16_t)(3 << STDBIT_CLKMULT))
 #define STDMSK_CLKENAB		((uint16_t)(1 << STDBIT_CLKENAB))
 
-
 /* typedef struct indexCounter */
 /* { */
 /*   unsigned int ao; */

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 891126f25099..27ae02be5300 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -63,7 +63,7 @@
 */
 
 #ifdef _DEBUG_
-#define DEBUG(...);        rt_printk(__VA_ARGS__);
+#define DEBUG(...);        printk(__VA_ARGS__);
 #else
 #define DEBUG(...)
 #endif

commit 4753d235e76b14c9f4585d569795a4ccb51485f8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:47 2009 -0400

    Staging: comedi: Remove DMABUF typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index c48957be2e1c..891126f25099 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -739,8 +739,8 @@
 /*   unsigned int enc; */
 /* }CallCounter; */
 
-typedef struct bufferDMA {
+struct bufferDMA {
 	dma_addr_t PhysicalBase;
 	void *LogicalBase;
 	uint32_t DMAHandle;
-} DMABUF;
+};

commit 6a98d36e87a0b38d711d580b5fc9dbba17f68dfc
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:03:45 2009 -0400

    Staging: comedi: Add spaces around parens as requested by checkpatch.pl
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index c158110aa47c..c48957be2e1c 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -173,7 +173,7 @@
 
 /*  RPS clock parameters. */
 #define RPSCLK_SCALAR		8	/*  This is apparent ratio of PCI/RPS clks (undocumented!!). */
-#define RPSCLK_PER_US		( 33 / RPSCLK_SCALAR )	/*  Number of RPS clocks in one microsecond. */
+#define RPSCLK_PER_US		(33 / RPSCLK_SCALAR)	/*  Number of RPS clocks in one microsecond. */
 
 /*  Event counter source addresses. */
 #define SBA_RPS_A0		0x27	/*  Time of RPS0 busy, in PCI clocks. */
@@ -377,14 +377,14 @@
 
 #if PLATFORM == INTEL		/* Base ACON1 config: always run A1 based
 				 * on TSL1. */
-#define ACON1_BASE		( WS_MODES | A1_RUN )
+#define ACON1_BASE		(WS_MODES | A1_RUN)
 #elif PLATFORM == MOTOROLA
-#define ACON1_BASE		( WS_MODES | A1_RUN | A1_SWAP | A2_SWAP )
+#define ACON1_BASE		(WS_MODES | A1_RUN | A1_SWAP | A2_SWAP)
 #endif
 
 #define ACON1_ADCSTART		ACON1_BASE	/* Start ADC: run A1
 						 *  based on TSL1. */
-#define ACON1_DACSTART		( ACON1_BASE | A2_RUN )
+#define ACON1_DACSTART		(ACON1_BASE | A2_RUN)
 /* Start transmit to DAC: run A2 based on TSL2. */
 #define ACON1_DACSTOP		ACON1_BASE	/*  Halt A2. */
 
@@ -398,7 +398,7 @@
 #define ACON2_XORMASK		0x000C0000	/*  XOR mask for ACON2 */
 						/*  active-low bits. */
 
-#define ACON2_INIT		( ACON2_XORMASK ^ ( A1_CLKSRC_BCLK1 | A2_CLKSRC_X2 | INVERT_BCLK2 | BCLK2_OE ) )
+#define ACON2_INIT		(ACON2_XORMASK ^ (A1_CLKSRC_BCLK1 | A2_CLKSRC_X2 | INVERT_BCLK2 | BCLK2_OE))
 
 /*  Bit masks for timeslot records. */
 #define WS1		     	0x40000000	/*  WS output to assert. */
@@ -452,7 +452,7 @@
 /*  I2C manifest constants. */
 
 /*  Max retries to wait for EEPROM write. */
-#define I2C_RETRIES		( I2C_WRTIME * I2C_BITRATE / 9.0 )
+#define I2C_RETRIES		(I2C_WRTIME * I2C_BITRATE / 9.0)
 #define I2C_ERR			0x0002	/*  I2C control/status */
 						/*  flag ERROR. */
 #define I2C_BUSY		0x0001	/*  I2C control/status */
@@ -464,15 +464,15 @@
 #define I2C_ATTRNOP		0x0	/*  I2C attribute NOP. */
 
 /*  I2C read command  | EEPROM address. */
-#define I2CR			( devpriv->I2CAdrs | 1 )
+#define I2CR			(devpriv->I2CAdrs | 1)
 
 /*  I2C write command | EEPROM address. */
-#define I2CW			( devpriv->I2CAdrs )
+#define I2CW			(devpriv->I2CAdrs)
 
 /*  Code macros used for constructing I2C command bytes. */
-#define I2C_B2(ATTR, VAL)	( ( (ATTR) << 6 ) | ( (VAL) << 24 ) )
-#define I2C_B1(ATTR, VAL)	( ( (ATTR) << 4 ) | ( (VAL) << 16 ) )
-#define I2C_B0(ATTR, VAL)	( ( (ATTR) << 2 ) | ( (VAL) <<  8 ) )
+#define I2C_B2(ATTR, VAL)	(((ATTR) << 6) | ((VAL) << 24))
+#define I2C_B1(ATTR, VAL)	(((ATTR) << 4) | ((VAL) << 16))
+#define I2C_B0(ATTR, VAL)	(((ATTR) << 2) | ((VAL) <<  8))
 
 /* oldest */
 #define P_DEBICFGq              0x007C	/*  DEBI configuration. */
@@ -490,16 +490,16 @@
 #define DEBI_PAGE_DISABLEQ	0x00000000	/*  paging disable */
 
 /*  DEBI command constants. */
-#define DEBI_CMD_SIZE16		( 2 << 17 )	/*  Transfer size is */
+#define DEBI_CMD_SIZE16		(2 << 17)	/*  Transfer size is */
 						/*  always 2 bytes. */
 #define DEBI_CMD_READ		0x00010000	/*  Read operation. */
 #define DEBI_CMD_WRITE		0x00000000	/*  Write operation. */
 
 /*  Read immediate 2 bytes. */
-#define DEBI_CMD_RDWORD		( DEBI_CMD_READ  | DEBI_CMD_SIZE16 )
+#define DEBI_CMD_RDWORD		(DEBI_CMD_READ  | DEBI_CMD_SIZE16)
 
 /*  Write immediate 2 bytes. */
-#define DEBI_CMD_WRWORD		( DEBI_CMD_WRITE | DEBI_CMD_SIZE16 )
+#define DEBI_CMD_WRWORD		(DEBI_CMD_WRITE | DEBI_CMD_SIZE16)
 
 /*  DEBI configuration constants. */
 #define DEBI_CFG_XIRQ_EN	0x80000000	/*  enab external */
@@ -681,29 +681,29 @@
 
 /*  Bit field masks for CRA and CRB. */
 
-#define CRAMSK_INDXSRC_B	( (uint16_t)( 3 << CRABIT_INDXSRC_B) )
-#define CRAMSK_CLKSRC_B		( (uint16_t)( 3 << CRABIT_CLKSRC_B) )
-#define CRAMSK_INDXPOL_A	( (uint16_t)( 1 << CRABIT_INDXPOL_A) )
-#define CRAMSK_LOADSRC_A	( (uint16_t)( 3 << CRABIT_LOADSRC_A) )
-#define CRAMSK_CLKMULT_A	( (uint16_t)( 3 << CRABIT_CLKMULT_A) )
-#define CRAMSK_INTSRC_A		( (uint16_t)( 3 << CRABIT_INTSRC_A) )
-#define CRAMSK_CLKPOL_A		( (uint16_t)( 3 << CRABIT_CLKPOL_A) )
-#define CRAMSK_INDXSRC_A	( (uint16_t)( 3 << CRABIT_INDXSRC_A) )
-#define CRAMSK_CLKSRC_A		( (uint16_t)( 3 << CRABIT_CLKSRC_A) )
-
-#define CRBMSK_INTRESETCMD	( (uint16_t)( 1 << CRBBIT_INTRESETCMD) )
-#define CRBMSK_INTRESET_B	( (uint16_t)( 1 << CRBBIT_INTRESET_B) )
-#define CRBMSK_INTRESET_A	( (uint16_t)( 1 << CRBBIT_INTRESET_A) )
-#define CRBMSK_CLKENAB_A	( (uint16_t)( 1 << CRBBIT_CLKENAB_A) )
-#define CRBMSK_INTSRC_B		( (uint16_t)( 3 << CRBBIT_INTSRC_B) )
-#define CRBMSK_LATCHSRC		( (uint16_t)( 3 << CRBBIT_LATCHSRC) )
-#define CRBMSK_LOADSRC_B	( (uint16_t)( 3 << CRBBIT_LOADSRC_B) )
-#define CRBMSK_CLKMULT_B	( (uint16_t)( 3 << CRBBIT_CLKMULT_B) )
-#define CRBMSK_CLKENAB_B	( (uint16_t)( 1 << CRBBIT_CLKENAB_B) )
-#define CRBMSK_INDXPOL_B	( (uint16_t)( 1 << CRBBIT_INDXPOL_B) )
-#define CRBMSK_CLKPOL_B		( (uint16_t)( 1 << CRBBIT_CLKPOL_B) )
-
-#define CRBMSK_INTCTRL		( CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B )	/*  Interrupt reset control bits. */
+#define CRAMSK_INDXSRC_B	((uint16_t)(3 << CRABIT_INDXSRC_B))
+#define CRAMSK_CLKSRC_B		((uint16_t)(3 << CRABIT_CLKSRC_B))
+#define CRAMSK_INDXPOL_A	((uint16_t)(1 << CRABIT_INDXPOL_A))
+#define CRAMSK_LOADSRC_A	((uint16_t)(3 << CRABIT_LOADSRC_A))
+#define CRAMSK_CLKMULT_A	((uint16_t)(3 << CRABIT_CLKMULT_A))
+#define CRAMSK_INTSRC_A		((uint16_t)(3 << CRABIT_INTSRC_A))
+#define CRAMSK_CLKPOL_A		((uint16_t)(3 << CRABIT_CLKPOL_A))
+#define CRAMSK_INDXSRC_A	((uint16_t)(3 << CRABIT_INDXSRC_A))
+#define CRAMSK_CLKSRC_A		((uint16_t)(3 << CRABIT_CLKSRC_A))
+
+#define CRBMSK_INTRESETCMD	((uint16_t)(1 << CRBBIT_INTRESETCMD))
+#define CRBMSK_INTRESET_B	((uint16_t)(1 << CRBBIT_INTRESET_B))
+#define CRBMSK_INTRESET_A	((uint16_t)(1 << CRBBIT_INTRESET_A))
+#define CRBMSK_CLKENAB_A	((uint16_t)(1 << CRBBIT_CLKENAB_A))
+#define CRBMSK_INTSRC_B		((uint16_t)(3 << CRBBIT_INTSRC_B))
+#define CRBMSK_LATCHSRC		((uint16_t)(3 << CRBBIT_LATCHSRC))
+#define CRBMSK_LOADSRC_B	((uint16_t)(3 << CRBBIT_LOADSRC_B))
+#define CRBMSK_CLKMULT_B	((uint16_t)(3 << CRBBIT_CLKMULT_B))
+#define CRBMSK_CLKENAB_B	((uint16_t)(1 << CRBBIT_CLKENAB_B))
+#define CRBMSK_INDXPOL_B	((uint16_t)(1 << CRBBIT_INDXPOL_B))
+#define CRBMSK_CLKPOL_B		((uint16_t)(1 << CRBBIT_CLKPOL_B))
+
+#define CRBMSK_INTCTRL		(CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B)	/*  Interrupt reset control bits. */
 
 /*  Bit field positions for standardized SETUP structure. */
 
@@ -719,15 +719,15 @@
 
 /*  Bit field masks for standardized SETUP structure. */
 
-#define STDMSK_INTSRC		( (uint16_t)( 3 << STDBIT_INTSRC   ) )
-#define STDMSK_LATCHSRC		( (uint16_t)( 3 << STDBIT_LATCHSRC ) )
-#define STDMSK_LOADSRC		( (uint16_t)( 3 << STDBIT_LOADSRC  ) )
-#define STDMSK_INDXSRC		( (uint16_t)( 1 << STDBIT_INDXSRC  ) )
-#define STDMSK_INDXPOL		( (uint16_t)( 1 << STDBIT_INDXPOL  ) )
-#define STDMSK_CLKSRC		( (uint16_t)( 3 << STDBIT_CLKSRC   ) )
-#define STDMSK_CLKPOL		( (uint16_t)( 1 << STDBIT_CLKPOL   ) )
-#define STDMSK_CLKMULT		( (uint16_t)( 3 << STDBIT_CLKMULT  ) )
-#define STDMSK_CLKENAB		( (uint16_t)( 1 << STDBIT_CLKENAB  ) )
+#define STDMSK_INTSRC		((uint16_t)(3 << STDBIT_INTSRC))
+#define STDMSK_LATCHSRC		((uint16_t)(3 << STDBIT_LATCHSRC))
+#define STDMSK_LOADSRC		((uint16_t)(3 << STDBIT_LOADSRC))
+#define STDMSK_INDXSRC		((uint16_t)(1 << STDBIT_INDXSRC))
+#define STDMSK_INDXPOL		((uint16_t)(1 << STDBIT_INDXPOL))
+#define STDMSK_CLKSRC		((uint16_t)(3 << STDBIT_CLKSRC))
+#define STDMSK_CLKPOL		((uint16_t)(1 << STDBIT_CLKPOL))
+#define STDMSK_CLKMULT		((uint16_t)(3 << STDBIT_CLKMULT))
+#define STDMSK_CLKENAB		((uint16_t)(1 << STDBIT_CLKENAB))
 
 
 /* typedef struct indexCounter */

commit 8086fff871940e6a348a733a303f39c086e4b3c5
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:03:35 2009 -0400

    Staging: comedi: Add spaces after commas where suggested by checkpatch.pl
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 7a88bb35b50b..c158110aa47c 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -470,9 +470,9 @@
 #define I2CW			( devpriv->I2CAdrs )
 
 /*  Code macros used for constructing I2C command bytes. */
-#define I2C_B2(ATTR,VAL)	( ( (ATTR) << 6 ) | ( (VAL) << 24 ) )
-#define I2C_B1(ATTR,VAL)	( ( (ATTR) << 4 ) | ( (VAL) << 16 ) )
-#define I2C_B0(ATTR,VAL)	( ( (ATTR) << 2 ) | ( (VAL) <<  8 ) )
+#define I2C_B2(ATTR, VAL)	( ( (ATTR) << 6 ) | ( (VAL) << 24 ) )
+#define I2C_B1(ATTR, VAL)	( ( (ATTR) << 4 ) | ( (VAL) << 16 ) )
+#define I2C_B0(ATTR, VAL)	( ( (ATTR) << 2 ) | ( (VAL) <<  8 ) )
 
 /* oldest */
 #define P_DEBICFGq              0x007C	/*  DEBI configuration. */

commit b6c777571b8d387d3add91170826f32a379e4313
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:03:24 2009 -0400

    Staging: comedi: Convert C99 style comments to traditional style comments
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 11d8b1ceb0b8..7a88bb35b50b 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -51,15 +51,15 @@
 
    Example code
 
-   insn.insn=INSN_CONFIG;   //configuration instruction
-   insn.n=1;                //number of operation (must be 1)
-   insn.data=&initialvalue; //initial value loaded into encoder
-                            //during configuration
-   insn.subdev=5;           //encoder subdevice
-   insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); //encoder_channel
-                                                        //to configure
-
-   comedi_do_insn(cf,&insn); //executing configuration
+   insn.insn=INSN_CONFIG;   // configuration instruction
+   insn.n=1;                // number of operation (must be 1)
+   insn.data=&initialvalue; // initial value loaded into encoder
+                            // during configuration
+   insn.subdev=5;           // encoder subdevice
+   insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); // encoder_channel
+                                                        // to configure
+
+   comedi_do_insn(cf,&insn); // executing configuration
 */
 
 #ifdef _DEBUG_
@@ -88,147 +88,136 @@
 #define INLINE static __inline
 #endif
 
-/////////////////////////////////////////////////////
 #include<linux/slab.h>
 
 #define S626_SIZE 0x0200
 #define SIZEOF_ADDRESS_SPACE		0x0200
-#define DMABUF_SIZE			4096	// 4k pages
+#define DMABUF_SIZE			4096	/*  4k pages */
 
 #define S626_ADC_CHANNELS       16
 #define S626_DAC_CHANNELS       4
 #define S626_ENCODER_CHANNELS   6
 #define S626_DIO_CHANNELS       48
-#define S626_DIO_BANKS		3	// Number of DIO groups.
-#define S626_DIO_EXTCHANS	40	// Number of
-					// extended-capability
-					// DIO channels.
+#define S626_DIO_BANKS		3	/*  Number of DIO groups. */
+#define S626_DIO_EXTCHANS	40	/*  Number of */
+					/*  extended-capability */
+					/*  DIO channels. */
 
-#define NUM_TRIMDACS	12	// Number of valid TrimDAC channels.
+#define NUM_TRIMDACS	12	/*  Number of valid TrimDAC channels. */
 
-// PCI bus interface types.
-#define INTEL				1	// Intel bus type.
-#define MOTOROLA			2	// Motorola bus type.
+/*  PCI bus interface types. */
+#define INTEL				1	/*  Intel bus type. */
+#define MOTOROLA			2	/*  Motorola bus type. */
 
-//////////////////////////////////////////////////////////
+#define PLATFORM		INTEL	/*  *** SELECT PLATFORM TYPE *** */
 
-//////////////////////////////////////////////////////////
-#define PLATFORM		INTEL	// *** SELECT PLATFORM TYPE ***
-//////////////////////////////////////////////////////////
+#define RANGE_5V                0x10	/*  +/-5V range */
+#define RANGE_10V               0x00	/*  +/-10V range */
 
-#define RANGE_5V                0x10	// +/-5V range
-#define RANGE_10V               0x00	// +/-10V range
+#define EOPL			0x80	/*  End of ADC poll list marker. */
+#define GSEL_BIPOLAR5V		0x00F0	/*  LP_GSEL setting for 5V bipolar range. */
+#define GSEL_BIPOLAR10V		0x00A0	/*  LP_GSEL setting for 10V bipolar range. */
 
-#define EOPL			0x80	// End of ADC poll list marker.
-#define GSEL_BIPOLAR5V		0x00F0	// LP_GSEL setting for 5V bipolar range.
-#define GSEL_BIPOLAR10V		0x00A0	// LP_GSEL setting for 10V bipolar range.
+/*  Error codes that must be visible to this base class. */
+#define ERR_ILLEGAL_PARM	0x00010000	/*  Illegal function parameter value was specified. */
+#define ERR_I2C			0x00020000	/*  I2C error. */
+#define ERR_COUNTERSETUP	0x00200000	/*  Illegal setup specified for counter channel. */
+#define ERR_DEBI_TIMEOUT	0x00400000	/*  DEBI transfer timed out. */
 
-// Error codes that must be visible to this base class.
-#define ERR_ILLEGAL_PARM	0x00010000	// Illegal function parameter value was specified.
-#define ERR_I2C			0x00020000	// I2C error.
-#define ERR_COUNTERSETUP	0x00200000	// Illegal setup specified for counter channel.
-#define ERR_DEBI_TIMEOUT	0x00400000	// DEBI transfer timed out.
+/*  Organization (physical order) and size (in DWORDs) of logical DMA buffers contained by ANA_DMABUF. */
+#define ADC_DMABUF_DWORDS	40	/*  ADC DMA buffer must hold 16 samples, plus pre/post garbage samples. */
+#define DAC_WDMABUF_DWORDS	1	/*  DAC output DMA buffer holds a single sample. */
 
-// Organization (physical order) and size (in DWORDs) of logical DMA buffers contained by ANA_DMABUF.
-#define ADC_DMABUF_DWORDS	40	// ADC DMA buffer must hold 16 samples, plus pre/post garbage samples.
-#define DAC_WDMABUF_DWORDS	1	// DAC output DMA buffer holds a single sample.
+/*  All remaining space in 4KB DMA buffer is available for the RPS1 program. */
 
-// All remaining space in 4KB DMA buffer is available for the RPS1 program.
-
-// Address offsets, in DWORDS, from base of DMA buffer.
+/*  Address offsets, in DWORDS, from base of DMA buffer. */
 #define DAC_WDMABUF_OS		ADC_DMABUF_DWORDS
 
-// Interrupt enab bit in ISR and IER.
-#define IRQ_GPIO3		0x00000040	// IRQ enable for GPIO3.
+/*  Interrupt enab bit in ISR and IER. */
+#define IRQ_GPIO3		0x00000040  /*  IRQ enable for GPIO3. */
 #define IRQ_RPS1                0x10000000
-#define ISR_AFOU		0x00000800	// Audio fifo
-						// under/overflow
-						// detected.
-#define IRQ_COINT1A             0x0400	// conter 1A overflow
-						// interrupt mask
-#define IRQ_COINT1B             0x0800	// conter 1B overflow
-						// interrupt mask
-#define IRQ_COINT2A             0x1000	// conter 2A overflow
-						// interrupt mask
-#define IRQ_COINT2B             0x2000	// conter 2B overflow
-						// interrupt mask
-#define IRQ_COINT3A             0x4000	// conter 3A overflow
-						// interrupt mask
-#define IRQ_COINT3B             0x8000	// conter 3B overflow
-						// interrupt mask
-
-// RPS command codes.
-#define RPS_CLRSIGNAL		0x00000000	// CLEAR SIGNAL
-#define RPS_SETSIGNAL		0x10000000	// SET SIGNAL
-#define RPS_NOP			0x00000000	// NOP
-#define RPS_PAUSE		0x20000000	// PAUSE
-#define RPS_UPLOAD		0x40000000	// UPLOAD
-#define RPS_JUMP		0x80000000	// JUMP
-#define RPS_LDREG		0x90000100	// LDREG (1 uint32_t only)
-#define RPS_STREG		0xA0000100	// STREG (1 uint32_t only)
-#define RPS_STOP		0x50000000	// STOP
-#define RPS_IRQ                 0x60000000	// IRQ
-
-#define RPS_LOGICAL_OR		0x08000000	// Logical OR conditionals.
-#define RPS_INVERT		0x04000000	// Test for negated semaphores.
-#define RPS_DEBI		0x00000002	// DEBI done
-
-#define RPS_SIG0		0x00200000	// RPS semaphore 0 (used by ADC).
-#define RPS_SIG1		0x00400000	// RPS semaphore 1 (used by DAC).
-#define RPS_SIG2		0x00800000	// RPS semaphore 2 (not used).
-#define RPS_GPIO2		0x00080000	// RPS GPIO2
-#define RPS_GPIO3		0x00100000	// RPS GPIO3
-
-#define RPS_SIGADC		RPS_SIG0	// Trigger/status for ADC's RPS program.
-#define RPS_SIGDAC		RPS_SIG1	// Trigger/status for DAC's RPS program.
-
-// RPS clock parameters.
-#define RPSCLK_SCALAR		8	// This is apparent ratio of PCI/RPS clks (undocumented!!).
-#define RPSCLK_PER_US		( 33 / RPSCLK_SCALAR )	// Number of RPS clocks in one microsecond.
-
-// Event counter source addresses.
-#define SBA_RPS_A0		0x27	// Time of RPS0 busy, in PCI clocks.
-
-// GPIO constants.
-#define GPIO_BASE		0x10004000	// GPIO 0,2,3 = inputs, GPIO3 = IRQ; GPIO1 = out.
-#define GPIO1_LO		0x00000000	// GPIO1 set to LOW.
-#define GPIO1_HI		0x00001000	// GPIO1 set to HIGH.
-
-// Primary Status Register (PSR) constants.
-#define PSR_DEBI_E		0x00040000	// DEBI event flag.
-#define PSR_DEBI_S		0x00080000	// DEBI status flag.
-#define PSR_A2_IN		0x00008000	// Audio output DMA2 protection address reached.
-#define PSR_AFOU		0x00000800	// Audio FIFO under/overflow detected.
-#define PSR_GPIO2		0x00000020	// GPIO2 input pin: 0=AdcBusy, 1=AdcIdle.
-#define PSR_EC0S		0x00000001	// Event counter 0 threshold reached.
-
-// Secondary Status Register (SSR) constants.
-#define SSR_AF2_OUT		0x00000200	// Audio 2 output FIFO under/overflow detected.
-
-// Master Control Register 1 (MC1) constants.
-#define MC1_SOFT_RESET		0x80000000	// Invoke 7146 soft reset.
-#define MC1_SHUTDOWN		0x3FFF0000	// Shut down all MC1-controlled enables.
-
-#define MC1_ERPS1		0x2000	// enab/disable RPS task 1.
-#define MC1_ERPS0		0x1000	// enab/disable RPS task 0.
-#define MC1_DEBI		0x0800	// enab/disable DEBI pins.
-#define MC1_AUDIO		0x0200	// enab/disable audio port pins.
-#define MC1_I2C			0x0100	// enab/disable I2C interface.
-#define MC1_A2OUT		0x0008	// enab/disable transfer on A2 out.
-#define MC1_A2IN		0x0004	// enab/disable transfer on A2 in.
-#define MC1_A1IN		0x0001	// enab/disable transfer on A1 in.
-
-// Master Control Register 2 (MC2) constants.
-#define MC2_UPLD_DEBIq		0x00020002	// Upload DEBI registers.
-#define MC2_UPLD_IICq		0x00010001	// Upload I2C registers.
-#define MC2_RPSSIG2_ONq		0x20002000	// Assert RPS_SIG2.
-#define MC2_RPSSIG1_ONq		0x10001000	// Assert RPS_SIG1.
-#define MC2_RPSSIG0_ONq		0x08000800	// Assert RPS_SIG0.
-#define MC2_UPLD_DEBI_MASKq	0x00000002	// Upload DEBI mask.
-#define MC2_UPLD_IIC_MASKq	0x00000001	// Upload I2C mask.
-#define MC2_RPSSIG2_MASKq	0x00002000	// RPS_SIG2 bit mask.
-#define MC2_RPSSIG1_MASKq	0x00001000	// RPS_SIG1 bit mask.
-#define MC2_RPSSIG0_MASKq	0x00000800	// RPS_SIG0 bit mask.
+#define ISR_AFOU		0x00000800
+/* Audio fifo under/overflow  detected. */
+
+#define IRQ_COINT1A             0x0400 /* conter 1A overflow interrupt mask */
+#define IRQ_COINT1B             0x0800 /* conter 1B overflow interrupt mask */
+#define IRQ_COINT2A             0x1000 /* conter 2A overflow interrupt mask */
+#define IRQ_COINT2B             0x2000 /* conter 2B overflow interrupt mask */
+#define IRQ_COINT3A             0x4000 /* conter 3A overflow interrupt mask */
+#define IRQ_COINT3B             0x8000 /* conter 3B overflow interrupt mask */
+
+/*  RPS command codes. */
+#define RPS_CLRSIGNAL		0x00000000	/*  CLEAR SIGNAL */
+#define RPS_SETSIGNAL		0x10000000	/*  SET SIGNAL */
+#define RPS_NOP			0x00000000	/*  NOP */
+#define RPS_PAUSE		0x20000000	/*  PAUSE */
+#define RPS_UPLOAD		0x40000000	/*  UPLOAD */
+#define RPS_JUMP		0x80000000	/*  JUMP */
+#define RPS_LDREG		0x90000100	/*  LDREG (1 uint32_t only) */
+#define RPS_STREG		0xA0000100	/*  STREG (1 uint32_t only) */
+#define RPS_STOP		0x50000000	/*  STOP */
+#define RPS_IRQ                 0x60000000	/*  IRQ */
+
+#define RPS_LOGICAL_OR		0x08000000	/*  Logical OR conditionals. */
+#define RPS_INVERT		0x04000000	/*  Test for negated semaphores. */
+#define RPS_DEBI		0x00000002	/*  DEBI done */
+
+#define RPS_SIG0		0x00200000	/*  RPS semaphore 0 (used by ADC). */
+#define RPS_SIG1		0x00400000	/*  RPS semaphore 1 (used by DAC). */
+#define RPS_SIG2		0x00800000	/*  RPS semaphore 2 (not used). */
+#define RPS_GPIO2		0x00080000	/*  RPS GPIO2 */
+#define RPS_GPIO3		0x00100000	/*  RPS GPIO3 */
+
+#define RPS_SIGADC		RPS_SIG0	/*  Trigger/status for ADC's RPS program. */
+#define RPS_SIGDAC		RPS_SIG1	/*  Trigger/status for DAC's RPS program. */
+
+/*  RPS clock parameters. */
+#define RPSCLK_SCALAR		8	/*  This is apparent ratio of PCI/RPS clks (undocumented!!). */
+#define RPSCLK_PER_US		( 33 / RPSCLK_SCALAR )	/*  Number of RPS clocks in one microsecond. */
+
+/*  Event counter source addresses. */
+#define SBA_RPS_A0		0x27	/*  Time of RPS0 busy, in PCI clocks. */
+
+/*  GPIO constants. */
+#define GPIO_BASE		0x10004000	/*  GPIO 0,2,3 = inputs, GPIO3 = IRQ; GPIO1 = out. */
+#define GPIO1_LO		0x00000000	/*  GPIO1 set to LOW. */
+#define GPIO1_HI		0x00001000	/*  GPIO1 set to HIGH. */
+
+/*  Primary Status Register (PSR) constants. */
+#define PSR_DEBI_E		0x00040000	/*  DEBI event flag. */
+#define PSR_DEBI_S		0x00080000	/*  DEBI status flag. */
+#define PSR_A2_IN		0x00008000	/*  Audio output DMA2 protection address reached. */
+#define PSR_AFOU		0x00000800	/*  Audio FIFO under/overflow detected. */
+#define PSR_GPIO2		0x00000020	/*  GPIO2 input pin: 0=AdcBusy, 1=AdcIdle. */
+#define PSR_EC0S		0x00000001	/*  Event counter 0 threshold reached. */
+
+/*  Secondary Status Register (SSR) constants. */
+#define SSR_AF2_OUT		0x00000200	/*  Audio 2 output FIFO under/overflow detected. */
+
+/*  Master Control Register 1 (MC1) constants. */
+#define MC1_SOFT_RESET		0x80000000	/*  Invoke 7146 soft reset. */
+#define MC1_SHUTDOWN		0x3FFF0000	/*  Shut down all MC1-controlled enables. */
+
+#define MC1_ERPS1		0x2000	/*  enab/disable RPS task 1. */
+#define MC1_ERPS0		0x1000	/*  enab/disable RPS task 0. */
+#define MC1_DEBI		0x0800	/*  enab/disable DEBI pins. */
+#define MC1_AUDIO		0x0200	/*  enab/disable audio port pins. */
+#define MC1_I2C			0x0100	/*  enab/disable I2C interface. */
+#define MC1_A2OUT		0x0008	/*  enab/disable transfer on A2 out. */
+#define MC1_A2IN		0x0004	/*  enab/disable transfer on A2 in. */
+#define MC1_A1IN		0x0001	/*  enab/disable transfer on A1 in. */
+
+/*  Master Control Register 2 (MC2) constants. */
+#define MC2_UPLD_DEBIq		0x00020002	/*  Upload DEBI registers. */
+#define MC2_UPLD_IICq		0x00010001	/*  Upload I2C registers. */
+#define MC2_RPSSIG2_ONq		0x20002000	/*  Assert RPS_SIG2. */
+#define MC2_RPSSIG1_ONq		0x10001000	/*  Assert RPS_SIG1. */
+#define MC2_RPSSIG0_ONq		0x08000800	/*  Assert RPS_SIG0. */
+#define MC2_UPLD_DEBI_MASKq	0x00000002	/*  Upload DEBI mask. */
+#define MC2_UPLD_IIC_MASKq	0x00000001	/*  Upload I2C mask. */
+#define MC2_RPSSIG2_MASKq	0x00002000	/*  RPS_SIG2 bit mask. */
+#define MC2_RPSSIG1_MASKq	0x00001000	/*  RPS_SIG1 bit mask. */
+#define MC2_RPSSIG0_MASKq	0x00000800	/*  RPS_SIG0 bit mask. */
 
 #define MC2_DELAYTRIG_4USq	MC2_RPSSIG1_ON
 #define MC2_DELAYBUSY_4USq	MC2_RPSSIG1_MASK
@@ -236,469 +225,425 @@
 #define	MC2_DELAYTRIG_6USq	MC2_RPSSIG2_ON
 #define MC2_DELAYBUSY_6USq	MC2_RPSSIG2_MASK
 
-#define MC2_UPLD_DEBI		0x0002	// Upload DEBI.
-#define MC2_UPLD_IIC		0x0001	// Upload I2C.
-#define MC2_RPSSIG2		0x2000	// RPS signal 2 (not used).
-#define MC2_RPSSIG1		0x1000	// RPS signal 1 (DAC RPS busy).
-#define MC2_RPSSIG0		0x0800	// RPS signal 0 (ADC RPS busy).
-
-#define MC2_ADC_RPS		MC2_RPSSIG0	// ADC RPS busy.
-#define MC2_DAC_RPS		MC2_RPSSIG1	// DAC RPS busy.
-
-///////////////////oldies///////////
-#define MC2_UPLD_DEBIQ		0x00020002	// Upload DEBI registers.
-#define MC2_UPLD_IICQ		0x00010001	// Upload I2C registers.
-////////////////////////////////////////
-
-// PCI BUS (SAA7146) REGISTER ADDRESS OFFSETS ////////////////////////
-#define P_PCI_BT_A		0x004C	// Audio DMA
-						// burst/threshold
-						// control.
-#define P_DEBICFG               0x007C	// DEBI configuration.
-#define P_DEBICMD               0x0080	// DEBI command.
-#define P_DEBIPAGE              0x0084	// DEBI page.
-#define P_DEBIAD                0x0088	// DEBI target address.
-#define P_I2CCTRL               0x008C	// I2C control.
-#define P_I2CSTAT               0x0090	// I2C status.
-#define P_BASEA2_IN		0x00AC	// Audio input 2 base
-						// physical DMAbuf
-						// address.
-#define P_PROTA2_IN		0x00B0	// Audio input 2
-						// physical DMAbuf
-						// protection address.
-#define P_PAGEA2_IN		0x00B4	// Audio input 2
-						// paging attributes.
-#define P_BASEA2_OUT		0x00B8	// Audio output 2 base
-						// physical DMAbuf
-						// address.
-#define P_PROTA2_OUT		0x00BC	// Audio output 2
-						// physical DMAbuf
-						// protection address.
-#define P_PAGEA2_OUT		0x00C0	// Audio output 2
-						// paging attributes.
-#define P_RPSPAGE0              0x00C4	// RPS0 page.
-#define P_RPSPAGE1              0x00C8	// RPS1 page.
-#define P_RPS0_TOUT		0x00D4	// RPS0 time-out.
-#define P_RPS1_TOUT		0x00D8	// RPS1 time-out.
-#define P_IER                   0x00DC	// Interrupt enable.
-#define P_GPIO                  0x00E0	// General-purpose I/O.
-#define P_EC1SSR		0x00E4	// Event counter set 1
-						// source select.
-#define P_ECT1R			0x00EC	// Event counter
-						// threshold set 1.
-#define P_ACON1                 0x00F4	// Audio control 1.
-#define P_ACON2                 0x00F8	// Audio control 2.
-#define P_MC1                   0x00FC	// Master control 1.
-#define P_MC2                   0x0100	// Master control 2.
-#define P_RPSADDR0              0x0104	// RPS0 instruction pointer.
-#define P_RPSADDR1              0x0108	// RPS1 instruction pointer.
-#define P_ISR                   0x010C	// Interrupt status.
-#define P_PSR                   0x0110	// Primary status.
-#define P_SSR                   0x0114	// Secondary status.
-#define P_EC1R			0x0118	// Event counter set 1.
-#define P_ADP4			0x0138	// Logical audio DMA
-						// pointer of audio
-						// input FIFO A2_IN.
-#define P_FB_BUFFER1            0x0144	// Audio feedback buffer 1.
-#define P_FB_BUFFER2            0x0148	// Audio feedback buffer 2.
-#define P_TSL1                  0x0180	// Audio time slot list 1.
-#define P_TSL2                  0x01C0	// Audio time slot list 2.
-
-// LOCAL BUS (GATE ARRAY) REGISTER ADDRESS OFFSETS /////////////////
-// Analog I/O registers:
-#define LP_DACPOL		0x0082	//  Write DAC polarity.
-#define LP_GSEL			0x0084	//  Write ADC gain.
-#define LP_ISEL			0x0086	//  Write ADC channel select.
-// Digital I/O (write only):
-#define LP_WRINTSELA		0x0042	//  Write A interrupt enable.
-#define LP_WREDGSELA		0x0044	//  Write A edge selection.
-#define LP_WRCAPSELA		0x0046	//  Write A capture enable.
-#define LP_WRDOUTA		0x0048	//  Write A digital output.
-#define LP_WRINTSELB		0x0052	//  Write B interrupt enable.
-#define LP_WREDGSELB		0x0054	//  Write B edge selection.
-#define LP_WRCAPSELB		0x0056	//  Write B capture enable.
-#define LP_WRDOUTB		0x0058	//  Write B digital output.
-#define LP_WRINTSELC		0x0062	//  Write C interrupt enable.
-#define LP_WREDGSELC		0x0064	//  Write C edge selection.
-#define LP_WRCAPSELC		0x0066	//  Write C capture enable.
-#define LP_WRDOUTC		0x0068	//  Write C digital output.
-
-// Digital I/O (read only):
-#define LP_RDDINA		0x0040	//  Read digital input.
-#define LP_RDCAPFLGA		0x0048	//  Read edges captured.
-#define LP_RDINTSELA		0x004A	//  Read interrupt
-						//  enable register.
-#define LP_RDEDGSELA		0x004C	//  Read edge
-						//  selection
-						//  register.
-#define LP_RDCAPSELA		0x004E	//  Read capture
-						//  enable register.
-#define LP_RDDINB		0x0050	//  Read digital input.
-#define LP_RDCAPFLGB		0x0058	//  Read edges captured.
-#define LP_RDINTSELB		0x005A	//  Read interrupt
-						//  enable register.
-#define LP_RDEDGSELB		0x005C	//  Read edge
-						//  selection
-						//  register.
-#define LP_RDCAPSELB		0x005E	//  Read capture
-						//  enable register.
-#define LP_RDDINC		0x0060	//  Read digital input.
-#define LP_RDCAPFLGC		0x0068	//  Read edges captured.
-#define LP_RDINTSELC		0x006A	//  Read interrupt
-						//  enable register.
-#define LP_RDEDGSELC		0x006C	//  Read edge
-						//  selection
-						//  register.
-#define LP_RDCAPSELC		0x006E	//  Read capture
-						//  enable register.
-// Counter Registers (read/write):
-#define LP_CR0A			0x0000	//  0A setup register.
-#define LP_CR0B			0x0002	//  0B setup register.
-#define LP_CR1A			0x0004	//  1A setup register.
-#define LP_CR1B			0x0006	//  1B setup register.
-#define LP_CR2A			0x0008	//  2A setup register.
-#define LP_CR2B			0x000A	//  2B setup register.
-// Counter PreLoad (write) and Latch (read) Registers:
-#define	LP_CNTR0ALSW		0x000C	//  0A lsw.
-#define	LP_CNTR0AMSW		0x000E	//  0A msw.
-#define	LP_CNTR0BLSW		0x0010	//  0B lsw.
-#define	LP_CNTR0BMSW		0x0012	//  0B msw.
-#define	LP_CNTR1ALSW		0x0014	//  1A lsw.
-#define	LP_CNTR1AMSW		0x0016	//  1A msw.
-#define	LP_CNTR1BLSW		0x0018	//  1B lsw.
-#define	LP_CNTR1BMSW		0x001A	//  1B msw.
-#define	LP_CNTR2ALSW		0x001C	//  2A lsw.
-#define	LP_CNTR2AMSW		0x001E	//  2A msw.
-#define	LP_CNTR2BLSW		0x0020	//  2B lsw.
-#define	LP_CNTR2BMSW		0x0022	//  2B msw.
-// Miscellaneous Registers (read/write):
-#define LP_MISC1		0x0088	//  Read/write Misc1.
-#define LP_WRMISC2		0x0090	//  Write Misc2.
-#define LP_RDMISC2		0x0082	//  Read Misc2.
-
-// Bit masks for MISC1 register that are the same for reads and writes.
-#define MISC1_WENABLE		0x8000	// enab writes to
-						// MISC2 (except Clear
-						// Watchdog bit).
-#define MISC1_WDISABLE		0x0000	// Disable writes to MISC2.
-#define MISC1_EDCAP		0x1000	// enab edge capture
-						// on DIO chans
-						// specified by
-						// LP_WRCAPSELx.
-#define MISC1_NOEDCAP		0x0000	// Disable edge
-						// capture on
-						// specified DIO
-						// chans.
-
-// Bit masks for MISC1 register reads.
-#define RDMISC1_WDTIMEOUT	0x4000	// Watchdog timer timed out.
-
-// Bit masks for MISC2 register writes.
-#define WRMISC2_WDCLEAR		0x8000	// Reset watchdog
-						// timer to zero.
-#define WRMISC2_CHARGE_ENABLE	0x4000	// enab battery
-						// trickle charging.
-
-// Bit masks for MISC2 register that are the same for reads and writes.
-#define MISC2_BATT_ENABLE	0x0008	// Backup battery enable.
-#define MISC2_WDENABLE		0x0004	// Watchdog timer enable.
-#define MISC2_WDPERIOD_MASK	0x0003	// Watchdog interval
-						// select mask.
-
-// Bit masks for ACON1 register.
-#define A2_RUN			0x40000000	// Run A2 based on TSL2.
-#define A1_RUN			0x20000000	// Run A1 based on TSL1.
-#define A1_SWAP			0x00200000	// Use big-endian for A1.
-#define A2_SWAP			0x00100000	// Use big-endian for A2.
-#define WS_MODES		0x00019999	// WS0 = TSL1 trigger
-						// input, WS1-WS4 =
-						// CS* outputs.
-
-#if PLATFORM == INTEL		// Base ACON1 config:
-						// always run A1 based
-						// on TSL1.
+#define MC2_UPLD_DEBI		0x0002	/*  Upload DEBI. */
+#define MC2_UPLD_IIC		0x0001	/*  Upload I2C. */
+#define MC2_RPSSIG2		0x2000	/*  RPS signal 2 (not used). */
+#define MC2_RPSSIG1		0x1000	/*  RPS signal 1 (DAC RPS busy). */
+#define MC2_RPSSIG0		0x0800	/*  RPS signal 0 (ADC RPS busy). */
+
+#define MC2_ADC_RPS		MC2_RPSSIG0	/*  ADC RPS busy. */
+#define MC2_DAC_RPS		MC2_RPSSIG1	/*  DAC RPS busy. */
+
+/* ***** oldies ***** */
+#define MC2_UPLD_DEBIQ		0x00020002	/*  Upload DEBI registers. */
+#define MC2_UPLD_IICQ		0x00010001	/*  Upload I2C registers. */
+
+/*  PCI BUS (SAA7146) REGISTER ADDRESS OFFSETS */
+#define P_PCI_BT_A		0x004C	/* Audio DMA burst/threshold control. */
+#define P_DEBICFG               0x007C	/* DEBI configuration. */
+#define P_DEBICMD               0x0080	/* DEBI command. */
+#define P_DEBIPAGE              0x0084	/* DEBI page. */
+#define P_DEBIAD                0x0088	/* DEBI target address. */
+#define P_I2CCTRL               0x008C	/* I2C control. */
+#define P_I2CSTAT               0x0090	/* I2C status. */
+#define P_BASEA2_IN		0x00AC	/* Audio input 2 base physical DMAbuf
+					 * address. */
+#define P_PROTA2_IN		0x00B0	/* Audio input 2 physical DMAbuf
+					 * protection address. */
+#define P_PAGEA2_IN		0x00B4	/* Audio input 2 paging attributes. */
+#define P_BASEA2_OUT		0x00B8	/* Audio output 2 base physical DMAbuf
+					 * address. */
+#define P_PROTA2_OUT		0x00BC	/* Audio output 2 physical DMAbuf
+					 * protection address. */
+#define P_PAGEA2_OUT		0x00C0	/* Audio output 2 paging attributes. */
+#define P_RPSPAGE0              0x00C4	/* RPS0 page. */
+#define P_RPSPAGE1              0x00C8	/* RPS1 page. */
+#define P_RPS0_TOUT		0x00D4	/* RPS0 time-out. */
+#define P_RPS1_TOUT		0x00D8	/* RPS1 time-out. */
+#define P_IER                   0x00DC	/* Interrupt enable. */
+#define P_GPIO                  0x00E0	/* General-purpose I/O. */
+#define P_EC1SSR		0x00E4	/* Event counter set 1 source select. */
+#define P_ECT1R			0x00EC	/* Event counter threshold set 1. */
+#define P_ACON1                 0x00F4	/* Audio control 1. */
+#define P_ACON2                 0x00F8	/* Audio control 2. */
+#define P_MC1                   0x00FC	/* Master control 1. */
+#define P_MC2                   0x0100	/* Master control 2. */
+#define P_RPSADDR0              0x0104	/* RPS0 instruction pointer. */
+#define P_RPSADDR1              0x0108	/* RPS1 instruction pointer. */
+#define P_ISR                   0x010C	/* Interrupt status. */
+#define P_PSR                   0x0110	/* Primary status. */
+#define P_SSR                   0x0114	/* Secondary status. */
+#define P_EC1R			0x0118	/* Event counter set 1. */
+#define P_ADP4			0x0138	/* Logical audio DMA pointer of audio
+					 * input FIFO A2_IN. */
+#define P_FB_BUFFER1            0x0144	/* Audio feedback buffer 1. */
+#define P_FB_BUFFER2            0x0148	/* Audio feedback buffer 2. */
+#define P_TSL1                  0x0180	/* Audio time slot list 1. */
+#define P_TSL2                  0x01C0	/* Audio time slot list 2. */
+
+/*  LOCAL BUS (GATE ARRAY) REGISTER ADDRESS OFFSETS */
+/*  Analog I/O registers: */
+#define LP_DACPOL		0x0082	/*   Write DAC polarity. */
+#define LP_GSEL			0x0084	/*   Write ADC gain. */
+#define LP_ISEL			0x0086	/*   Write ADC channel select. */
+/*  Digital I/O (write only): */
+#define LP_WRINTSELA		0x0042	/*   Write A interrupt enable. */
+#define LP_WREDGSELA		0x0044	/*   Write A edge selection. */
+#define LP_WRCAPSELA		0x0046	/*   Write A capture enable. */
+#define LP_WRDOUTA		0x0048	/*   Write A digital output. */
+#define LP_WRINTSELB		0x0052	/*   Write B interrupt enable. */
+#define LP_WREDGSELB		0x0054	/*   Write B edge selection. */
+#define LP_WRCAPSELB		0x0056	/*   Write B capture enable. */
+#define LP_WRDOUTB		0x0058	/*   Write B digital output. */
+#define LP_WRINTSELC		0x0062	/*   Write C interrupt enable. */
+#define LP_WREDGSELC		0x0064	/*   Write C edge selection. */
+#define LP_WRCAPSELC		0x0066	/*   Write C capture enable. */
+#define LP_WRDOUTC		0x0068	/*   Write C digital output. */
+
+/*  Digital I/O (read only): */
+#define LP_RDDINA		0x0040	/*   Read digital input. */
+#define LP_RDCAPFLGA		0x0048	/*   Read edges captured. */
+#define LP_RDINTSELA		0x004A	/*   Read interrupt enable register. */
+#define LP_RDEDGSELA		0x004C	/*   Read edge selection register. */
+#define LP_RDCAPSELA		0x004E	/*   Read capture enable register. */
+#define LP_RDDINB		0x0050	/*   Read digital input. */
+#define LP_RDCAPFLGB		0x0058	/*   Read edges captured. */
+#define LP_RDINTSELB		0x005A	/*   Read interrupt enable register. */
+#define LP_RDEDGSELB		0x005C	/*   Read edge selection register. */
+#define LP_RDCAPSELB		0x005E	/*   Read capture enable register. */
+#define LP_RDDINC		0x0060	/*   Read digital input. */
+#define LP_RDCAPFLGC		0x0068	/*   Read edges captured. */
+#define LP_RDINTSELC		0x006A	/*   Read interrupt enable register. */
+#define LP_RDEDGSELC		0x006C	/*   Read edge selection register. */
+#define LP_RDCAPSELC		0x006E	/*   Read capture enable register. */
+
+/*  Counter Registers (read/write): */
+#define LP_CR0A			0x0000	/*   0A setup register. */
+#define LP_CR0B			0x0002	/*   0B setup register. */
+#define LP_CR1A			0x0004	/*   1A setup register. */
+#define LP_CR1B			0x0006	/*   1B setup register. */
+#define LP_CR2A			0x0008	/*   2A setup register. */
+#define LP_CR2B			0x000A	/*   2B setup register. */
+
+/*  Counter PreLoad (write) and Latch (read) Registers: */
+#define	LP_CNTR0ALSW		0x000C	/*   0A lsw. */
+#define	LP_CNTR0AMSW		0x000E	/*   0A msw. */
+#define	LP_CNTR0BLSW		0x0010	/*   0B lsw. */
+#define	LP_CNTR0BMSW		0x0012	/*   0B msw. */
+#define	LP_CNTR1ALSW		0x0014	/*   1A lsw. */
+#define	LP_CNTR1AMSW		0x0016	/*   1A msw. */
+#define	LP_CNTR1BLSW		0x0018	/*   1B lsw. */
+#define	LP_CNTR1BMSW		0x001A	/*   1B msw. */
+#define	LP_CNTR2ALSW		0x001C	/*   2A lsw. */
+#define	LP_CNTR2AMSW		0x001E	/*   2A msw. */
+#define	LP_CNTR2BLSW		0x0020	/*   2B lsw. */
+#define	LP_CNTR2BMSW		0x0022	/*   2B msw. */
+
+/*  Miscellaneous Registers (read/write): */
+#define LP_MISC1		0x0088	/*   Read/write Misc1. */
+#define LP_WRMISC2		0x0090	/*   Write Misc2. */
+#define LP_RDMISC2		0x0082	/*   Read Misc2. */
+
+/*  Bit masks for MISC1 register that are the same for reads and writes. */
+#define MISC1_WENABLE		0x8000	/* enab writes to MISC2 (except Clear
+					 * Watchdog bit). */
+#define MISC1_WDISABLE		0x0000	/* Disable writes to MISC2. */
+#define MISC1_EDCAP		0x1000	/* enab edge capture on DIO chans
+					 * specified by  LP_WRCAPSELx. */
+#define MISC1_NOEDCAP		0x0000	/* Disable edge capture on specified
+					 * DIO chans. */
+
+/*  Bit masks for MISC1 register reads. */
+#define RDMISC1_WDTIMEOUT	0x4000	/*  Watchdog timer timed out. */
+
+/*  Bit masks for MISC2 register writes. */
+#define WRMISC2_WDCLEAR		0x8000	/*  Reset watchdog timer to zero. */
+#define WRMISC2_CHARGE_ENABLE	0x4000	/*  enab battery trickle charging. */
+
+/*  Bit masks for MISC2 register that are the same for reads and writes. */
+#define MISC2_BATT_ENABLE	0x0008	/*  Backup battery enable. */
+#define MISC2_WDENABLE		0x0004	/*  Watchdog timer enable. */
+#define MISC2_WDPERIOD_MASK	0x0003	/*  Watchdog interval */
+						/*  select mask. */
+
+/*  Bit masks for ACON1 register. */
+#define A2_RUN			0x40000000	/*  Run A2 based on TSL2. */
+#define A1_RUN			0x20000000	/*  Run A1 based on TSL1. */
+#define A1_SWAP			0x00200000	/*  Use big-endian for A1. */
+#define A2_SWAP			0x00100000	/*  Use big-endian for A2. */
+#define WS_MODES		0x00019999	/*  WS0 = TSL1 trigger */
+						/*  input, WS1-WS4 = */
+						/*  CS* outputs. */
+
+#if PLATFORM == INTEL		/* Base ACON1 config: always run A1 based
+				 * on TSL1. */
 #define ACON1_BASE		( WS_MODES | A1_RUN )
 #elif PLATFORM == MOTOROLA
 #define ACON1_BASE		( WS_MODES | A1_RUN | A1_SWAP | A2_SWAP )
 #endif
 
-#define ACON1_ADCSTART		ACON1_BASE	// Start ADC: run A1
-						// based on TSL1.
-#define ACON1_DACSTART		( ACON1_BASE | A2_RUN )	// Start
-							// transmit to
-							// DAC: run A2
-							// based on
-							// TSL2.
-#define ACON1_DACSTOP		ACON1_BASE	// Halt A2.
-
-// Bit masks for ACON2 register.
-#define A1_CLKSRC_BCLK1		0x00000000	// A1 bit rate = BCLK1 (ADC).
-#define A2_CLKSRC_X1		0x00800000	// A2 bit rate = ACLK/1 (DACs).
-#define A2_CLKSRC_X2		0x00C00000	// A2 bit rate = ACLK/2 (DACs).
-#define A2_CLKSRC_X4		0x01400000	// A2 bit rate = ACLK/4 (DACs).
-#define INVERT_BCLK2		0x00100000	// Invert BCLK2 (DACs).
-#define BCLK2_OE		0x00040000	// enab BCLK2 (DACs).
-#define ACON2_XORMASK		0x000C0000	// XOR mask for ACON2
-						// active-low bits.
+#define ACON1_ADCSTART		ACON1_BASE	/* Start ADC: run A1
+						 *  based on TSL1. */
+#define ACON1_DACSTART		( ACON1_BASE | A2_RUN )
+/* Start transmit to DAC: run A2 based on TSL2. */
+#define ACON1_DACSTOP		ACON1_BASE	/*  Halt A2. */
+
+/*  Bit masks for ACON2 register. */
+#define A1_CLKSRC_BCLK1		0x00000000	/*  A1 bit rate = BCLK1 (ADC). */
+#define A2_CLKSRC_X1		0x00800000	/*  A2 bit rate = ACLK/1 (DACs). */
+#define A2_CLKSRC_X2		0x00C00000	/*  A2 bit rate = ACLK/2 (DACs). */
+#define A2_CLKSRC_X4		0x01400000	/*  A2 bit rate = ACLK/4 (DACs). */
+#define INVERT_BCLK2		0x00100000	/*  Invert BCLK2 (DACs). */
+#define BCLK2_OE		0x00040000	/*  enab BCLK2 (DACs). */
+#define ACON2_XORMASK		0x000C0000	/*  XOR mask for ACON2 */
+						/*  active-low bits. */
 
 #define ACON2_INIT		( ACON2_XORMASK ^ ( A1_CLKSRC_BCLK1 | A2_CLKSRC_X2 | INVERT_BCLK2 | BCLK2_OE ) )
 
-// Bit masks for timeslot records.
-#define WS1		     	0x40000000	// WS output to assert.
+/*  Bit masks for timeslot records. */
+#define WS1		     	0x40000000	/*  WS output to assert. */
 #define WS2		     	0x20000000
 #define WS3		     	0x10000000
 #define WS4		     	0x08000000
-#define RSD1			0x01000000	// Shift A1 data in on SD1.
-#define SDW_A1			0x00800000	// Store rcv'd char at
-						// next char slot of
-						// DWORD1 buffer.
-#define SIB_A1			0x00400000	// Store rcv'd char at
-						// next char slot of
-						// FB1 buffer.
-#define SF_A1			0x00200000	// Write unsigned long
-						// buffer to input
-						// FIFO.
-
-//Select parallel-to-serial converter's data source:
-#define XFIFO_0			0x00000000	//   Data fifo byte 0.
-#define XFIFO_1			0x00000010	//   Data fifo byte 1.
-#define XFIFO_2			0x00000020	//   Data fifo byte 2.
-#define XFIFO_3			0x00000030	//   Data fifo byte 3.
-#define XFB0			0x00000040	//   FB_BUFFER byte 0.
-#define XFB1			0x00000050	//   FB_BUFFER byte 1.
-#define XFB2			0x00000060	//   FB_BUFFER byte 2.
-#define XFB3			0x00000070	//   FB_BUFFER byte 3.
-#define SIB_A2			0x00000200	// Store next dword
-						// from A2's input
-						// shifter to FB2
-						// buffer.
-#define SF_A2			0x00000100	// Store next dword
-						// from A2's input
-						// shifter to its
-						// input fifo.
-#define LF_A2			0x00000080	// Load next dword
-						// from A2's output
-						// fifo into its
-						// output dword
-						// buffer.
-#define XSD2			0x00000008	// Shift data out on SD2.
-#define RSD3			0x00001800	// Shift data in on SD3.
-#define RSD2			0x00001000	// Shift data in on SD2.
-#define LOW_A2			0x00000002	// Drive last SD low
-						// for 7 clks, then
-						// tri-state.
-#define EOS		     	0x00000001	// End of superframe.
-
-//////////////////////
-
-// I2C configuration constants.
-#define I2C_CLKSEL		0x0400	// I2C bit rate =
-						// PCIclk/480 = 68.75
-						// KHz.
-#define I2C_BITRATE		68.75	// I2C bus data bit
-						// rate (determined by
-						// I2C_CLKSEL) in KHz.
-#define I2C_WRTIME		15.0	// Worst case time,in
-						// msec, for EEPROM
-						// internal write op.
-
-// I2C manifest constants.
-
-// Max retries to wait for EEPROM write.
+#define RSD1			0x01000000	/* Shift A1 data in on SD1. */
+#define SDW_A1			0x00800000	/* Store rcv'd char at next
+						 * char slot of DWORD1 buffer. */
+#define SIB_A1			0x00400000	/* Store rcv'd char at next
+						 * char slot of FB1 buffer. */
+#define SF_A1			0x00200000	/* Write unsigned long
+						 * buffer to input FIFO. */
+
+/* Select parallel-to-serial converter's data source: */
+#define XFIFO_0			0x00000000	/*    Data fifo byte 0. */
+#define XFIFO_1			0x00000010	/*    Data fifo byte 1. */
+#define XFIFO_2			0x00000020	/*    Data fifo byte 2. */
+#define XFIFO_3			0x00000030	/*    Data fifo byte 3. */
+#define XFB0			0x00000040	/*    FB_BUFFER byte 0. */
+#define XFB1			0x00000050	/*    FB_BUFFER byte 1. */
+#define XFB2			0x00000060	/*    FB_BUFFER byte 2. */
+#define XFB3			0x00000070	/*    FB_BUFFER byte 3. */
+#define SIB_A2			0x00000200	/* Store next dword from A2's
+						 * input shifter to FB2 buffer. */
+#define SF_A2			0x00000100	/* Store next dword from A2's
+						 * input shifter to its input
+						 * fifo. */
+#define LF_A2			0x00000080	/* Load next dword from A2's
+						 * output fifo into its
+						 * output dword buffer. */
+#define XSD2			0x00000008	/*  Shift data out on SD2. */
+#define RSD3			0x00001800	/*  Shift data in on SD3. */
+#define RSD2			0x00001000	/*  Shift data in on SD2. */
+#define LOW_A2			0x00000002	/*  Drive last SD low */
+						/*  for 7 clks, then */
+						/*  tri-state. */
+#define EOS		     	0x00000001	/*  End of superframe. */
+
+
+/*  I2C configuration constants. */
+#define I2C_CLKSEL		0x0400
+/* I2C bit rate = PCIclk/480 = 68.75 KHz. */
+
+#define I2C_BITRATE		68.75
+/* I2C bus data bit rate (determined by I2C_CLKSEL) in KHz. */
+
+#define I2C_WRTIME		15.0
+/* Worst case time, in msec, for EEPROM internal write op. */
+
+/*  I2C manifest constants. */
+
+/*  Max retries to wait for EEPROM write. */
 #define I2C_RETRIES		( I2C_WRTIME * I2C_BITRATE / 9.0 )
-#define I2C_ERR			0x0002	// I2C control/status
-						// flag ERROR.
-#define I2C_BUSY		0x0001	// I2C control/status
-						// flag BUSY.
-#define I2C_ABORT		0x0080	// I2C status flag ABORT.
-#define I2C_ATTRSTART		0x3	// I2C attribute START.
-#define I2C_ATTRCONT		0x2	// I2C attribute CONT.
-#define I2C_ATTRSTOP		0x1	// I2C attribute STOP.
-#define I2C_ATTRNOP		0x0	// I2C attribute NOP.
-
-// I2C read command  | EEPROM address.
+#define I2C_ERR			0x0002	/*  I2C control/status */
+						/*  flag ERROR. */
+#define I2C_BUSY		0x0001	/*  I2C control/status */
+						/*  flag BUSY. */
+#define I2C_ABORT		0x0080	/*  I2C status flag ABORT. */
+#define I2C_ATTRSTART		0x3	/*  I2C attribute START. */
+#define I2C_ATTRCONT		0x2	/*  I2C attribute CONT. */
+#define I2C_ATTRSTOP		0x1	/*  I2C attribute STOP. */
+#define I2C_ATTRNOP		0x0	/*  I2C attribute NOP. */
+
+/*  I2C read command  | EEPROM address. */
 #define I2CR			( devpriv->I2CAdrs | 1 )
 
-// I2C write command | EEPROM address.
+/*  I2C write command | EEPROM address. */
 #define I2CW			( devpriv->I2CAdrs )
 
-// Code macros used for constructing I2C command bytes.
+/*  Code macros used for constructing I2C command bytes. */
 #define I2C_B2(ATTR,VAL)	( ( (ATTR) << 6 ) | ( (VAL) << 24 ) )
 #define I2C_B1(ATTR,VAL)	( ( (ATTR) << 4 ) | ( (VAL) << 16 ) )
 #define I2C_B0(ATTR,VAL)	( ( (ATTR) << 2 ) | ( (VAL) <<  8 ) )
 
-////////////////////////////////////////////////////////
-//oldest
-#define P_DEBICFGq              0x007C	// DEBI configuration.
-#define P_DEBICMDq              0x0080	// DEBI command.
-#define P_DEBIPAGEq             0x0084	// DEBI page.
-#define P_DEBIADq               0x0088	// DEBI target address.
-
-#define DEBI_CFG_TOQ		0x03C00000	// timeout (15 PCI cycles)
-#define DEBI_CFG_FASTQ		0x10000000	// fast mode enable
-#define DEBI_CFG_16Q		0x00080000	// 16-bit access enable
-#define DEBI_CFG_INCQ		0x00040000	// enable address increment
-#define DEBI_CFG_TIMEROFFQ	0x00010000	// disable timer
-#define DEBI_CMD_RDQ		0x00050000	// read immediate 2 bytes
-#define DEBI_CMD_WRQ		0x00040000	// write immediate 2 bytes
-#define DEBI_PAGE_DISABLEQ	0x00000000	// paging disable
-
-///////////////////////////////////////////
-// DEBI command constants.
-#define DEBI_CMD_SIZE16		( 2 << 17 )	// Transfer size is
-						// always 2 bytes.
-#define DEBI_CMD_READ		0x00010000	// Read operation.
-#define DEBI_CMD_WRITE		0x00000000	// Write operation.
-
-// Read immediate 2 bytes.
+/* oldest */
+#define P_DEBICFGq              0x007C	/*  DEBI configuration. */
+#define P_DEBICMDq              0x0080	/*  DEBI command. */
+#define P_DEBIPAGEq             0x0084	/*  DEBI page. */
+#define P_DEBIADq               0x0088	/*  DEBI target address. */
+
+#define DEBI_CFG_TOQ		0x03C00000	/*  timeout (15 PCI cycles) */
+#define DEBI_CFG_FASTQ		0x10000000	/*  fast mode enable */
+#define DEBI_CFG_16Q		0x00080000	/*  16-bit access enable */
+#define DEBI_CFG_INCQ		0x00040000	/*  enable address increment */
+#define DEBI_CFG_TIMEROFFQ	0x00010000	/*  disable timer */
+#define DEBI_CMD_RDQ		0x00050000	/*  read immediate 2 bytes */
+#define DEBI_CMD_WRQ		0x00040000	/*  write immediate 2 bytes */
+#define DEBI_PAGE_DISABLEQ	0x00000000	/*  paging disable */
+
+/*  DEBI command constants. */
+#define DEBI_CMD_SIZE16		( 2 << 17 )	/*  Transfer size is */
+						/*  always 2 bytes. */
+#define DEBI_CMD_READ		0x00010000	/*  Read operation. */
+#define DEBI_CMD_WRITE		0x00000000	/*  Write operation. */
+
+/*  Read immediate 2 bytes. */
 #define DEBI_CMD_RDWORD		( DEBI_CMD_READ  | DEBI_CMD_SIZE16 )
 
-// Write immediate 2 bytes.
+/*  Write immediate 2 bytes. */
 #define DEBI_CMD_WRWORD		( DEBI_CMD_WRITE | DEBI_CMD_SIZE16 )
 
-// DEBI configuration constants.
-#define DEBI_CFG_XIRQ_EN	0x80000000	// enab external
-						// interrupt on GPIO3.
-#define DEBI_CFG_XRESUME	0x40000000	// Resume block
-						// transfer when XIRQ
-						// deasserted.
-#define DEBI_CFG_FAST		0x10000000	// Fast mode enable.
-
-// 4-bit field that specifies DEBI timeout value in PCI clock cycles:
-#define DEBI_CFG_TOUT_BIT	22	//   Finish DEBI cycle after
-					//   this many clocks.
-
-// 2-bit field that specifies Endian byte lane steering:
-#define DEBI_CFG_SWAP_NONE	0x00000000	//   Straight - don't
-						//   swap any bytes
-						//   (Intel).
-#define DEBI_CFG_SWAP_2		0x00100000	//   2-byte swap (Motorola).
-#define DEBI_CFG_SWAP_4		0x00200000	//   4-byte swap.
-#define DEBI_CFG_16		0x00080000	// Slave is able to
-						// serve 16-bit
-						// cycles.
-
-#define DEBI_CFG_SLAVE16	0x00080000	// Slave is able to
-						// serve 16-bit
-						// cycles.
-#define DEBI_CFG_INC		0x00040000	// enab address
-						// increment for block
-						// transfers.
-#define DEBI_CFG_INTEL		0x00020000	// Intel style local bus.
-#define DEBI_CFG_TIMEROFF	0x00010000	// Disable timer.
+/*  DEBI configuration constants. */
+#define DEBI_CFG_XIRQ_EN	0x80000000	/*  enab external */
+						/*  interrupt on GPIO3. */
+#define DEBI_CFG_XRESUME	0x40000000	/*  Resume block */
+						/*  transfer when XIRQ */
+						/*  deasserted. */
+#define DEBI_CFG_FAST		0x10000000	/*  Fast mode enable. */
+
+/*  4-bit field that specifies DEBI timeout value in PCI clock cycles: */
+#define DEBI_CFG_TOUT_BIT	22	/*    Finish DEBI cycle after */
+					/*    this many clocks. */
+
+/*  2-bit field that specifies Endian byte lane steering: */
+#define DEBI_CFG_SWAP_NONE	0x00000000	/*    Straight - don't */
+						/*    swap any bytes */
+						/*    (Intel). */
+#define DEBI_CFG_SWAP_2		0x00100000	/*    2-byte swap (Motorola). */
+#define DEBI_CFG_SWAP_4		0x00200000	/*    4-byte swap. */
+#define DEBI_CFG_16		0x00080000	/*  Slave is able to */
+						/*  serve 16-bit */
+						/*  cycles. */
+
+#define DEBI_CFG_SLAVE16	0x00080000	/*  Slave is able to */
+						/*  serve 16-bit */
+						/*  cycles. */
+#define DEBI_CFG_INC		0x00040000	/*  enab address */
+						/*  increment for block */
+						/*  transfers. */
+#define DEBI_CFG_INTEL		0x00020000	/*  Intel style local bus. */
+#define DEBI_CFG_TIMEROFF	0x00010000	/*  Disable timer. */
 
 #if PLATFORM == INTEL
 
-#define DEBI_TOUT		7	// Wait 7 PCI clocks
-						// (212 ns) before
-						// polling RDY.
+#define DEBI_TOUT		7	/*  Wait 7 PCI clocks */
+						/*  (212 ns) before */
+						/*  polling RDY. */
 
-// Intel byte lane steering (pass through all byte lanes).
+/*  Intel byte lane steering (pass through all byte lanes). */
 #define DEBI_SWAP		DEBI_CFG_SWAP_NONE
 
 #elif PLATFORM == MOTOROLA
 
-#define DEBI_TOUT		15	// Wait 15 PCI clocks (454 ns)
-					// maximum before timing out.
-#define DEBI_SWAP		DEBI_CFG_SWAP_2	// Motorola byte lane steering.
+#define DEBI_TOUT		15	/*  Wait 15 PCI clocks (454 ns) */
+					/*  maximum before timing out. */
+#define DEBI_SWAP		DEBI_CFG_SWAP_2	/*  Motorola byte lane steering. */
 
 #endif
 
-// DEBI page table constants.
-#define DEBI_PAGE_DISABLE	0x00000000	// Paging disable.
-
-///////////////////EXTRA FROM OTHER SANSORAY  * .h////////
-
-// LoadSrc values:
-#define LOADSRC_INDX		0	// Preload core in response to
-					// Index.
-#define LOADSRC_OVER		1	// Preload core in response to
-					// Overflow.
-#define LOADSRCB_OVERA		2	// Preload B core in response
-					// to A Overflow.
-#define LOADSRC_NONE		3	// Never preload core.
-
-// IntSrc values:
-#define INTSRC_NONE 		0	// Interrupts disabled.
-#define INTSRC_OVER 		1	// Interrupt on Overflow.
-#define INTSRC_INDX 		2	// Interrupt on Index.
-#define INTSRC_BOTH 		3	// Interrupt on Index or Overflow.
-
-// LatchSrc values:
-#define LATCHSRC_AB_READ	0	// Latch on read.
-#define LATCHSRC_A_INDXA	1	// Latch A on A Index.
-#define LATCHSRC_B_INDXB	2	// Latch B on B Index.
-#define LATCHSRC_B_OVERA	3	// Latch B on A Overflow.
-
-// IndxSrc values:
-#define INDXSRC_HARD		0	// Hardware or software index.
-#define INDXSRC_SOFT		1	// Software index only.
-
-// IndxPol values:
-#define INDXPOL_POS 		0	// Index input is active high.
-#define INDXPOL_NEG 		1	// Index input is active low.
-
-// ClkSrc values:
-#define CLKSRC_COUNTER		0	// Counter mode.
-#define CLKSRC_TIMER		2	// Timer mode.
-#define CLKSRC_EXTENDER		3	// Extender mode.
-
-// ClkPol values:
-#define CLKPOL_POS		0	// Counter/Extender clock is
-					// active high.
-#define CLKPOL_NEG		1	// Counter/Extender clock is
-					// active low.
-#define CNTDIR_UP		0	// Timer counts up.
-#define CNTDIR_DOWN 		1	// Timer counts down.
-
-// ClkEnab values:
-#define CLKENAB_ALWAYS		0	// Clock always enabled.
-#define CLKENAB_INDEX		1	// Clock is enabled by index.
-
-// ClkMult values:
-#define CLKMULT_4X 		0	// 4x clock multiplier.
-#define CLKMULT_2X 		1	// 2x clock multiplier.
-#define CLKMULT_1X 		2	// 1x clock multiplier.
-
-// Bit Field positions in COUNTER_SETUP structure:
-#define BF_LOADSRC		9	// Preload trigger.
-#define BF_INDXSRC		7	// Index source.
-#define BF_INDXPOL		6	// Index polarity.
-#define BF_CLKSRC		4	// Clock source.
-#define BF_CLKPOL		3	// Clock polarity/count direction.
-#define BF_CLKMULT		1	// Clock multiplier.
-#define BF_CLKENAB		0	// Clock enable.
-
-// Enumerated counter operating modes specified by ClkSrc bit field in
-// a COUNTER_SETUP.
-
-#define CLKSRC_COUNTER		0	// Counter: ENC_C clock, ENC_D
-					// direction.
-#define CLKSRC_TIMER		2	// Timer: SYS_C clock,
-					// direction specified by
-					// ClkPol.
-#define CLKSRC_EXTENDER		3	// Extender: OVR_A clock,
-					// ENC_D direction.
-
-// Enumerated counter clock multipliers.
-
-#define MULT_X0			0x0003	// Supports no multipliers;
-					// fixed physical multiplier =
-					// 3.
-#define MULT_X1			0x0002	// Supports multiplier x1;
-					// fixed physical multiplier =
-					// 2.
-#define MULT_X2			0x0001	// Supports multipliers x1,
-					// x2; physical multipliers =
-					// 1 or 2.
-#define MULT_X4			0x0000	// Supports multipliers x1,
-					// x2, x4; physical
-					// multipliers = 0, 1 or 2.
-
-// Sanity-check limits for parameters.
-
-#define NUM_COUNTERS		6	// Maximum valid counter
-					// logical channel number.
+/*  DEBI page table constants. */
+#define DEBI_PAGE_DISABLE	0x00000000	/*  Paging disable. */
+
+/* ******* EXTRA FROM OTHER SANSORAY  * .h  ******* */
+
+/*  LoadSrc values: */
+#define LOADSRC_INDX		0	/*  Preload core in response to */
+					/*  Index. */
+#define LOADSRC_OVER		1	/*  Preload core in response to */
+					/*  Overflow. */
+#define LOADSRCB_OVERA		2	/*  Preload B core in response */
+					/*  to A Overflow. */
+#define LOADSRC_NONE		3	/*  Never preload core. */
+
+/*  IntSrc values: */
+#define INTSRC_NONE 		0	/*  Interrupts disabled. */
+#define INTSRC_OVER 		1	/*  Interrupt on Overflow. */
+#define INTSRC_INDX 		2	/*  Interrupt on Index. */
+#define INTSRC_BOTH 		3	/*  Interrupt on Index or Overflow. */
+
+/*  LatchSrc values: */
+#define LATCHSRC_AB_READ	0	/*  Latch on read. */
+#define LATCHSRC_A_INDXA	1	/*  Latch A on A Index. */
+#define LATCHSRC_B_INDXB	2	/*  Latch B on B Index. */
+#define LATCHSRC_B_OVERA	3	/*  Latch B on A Overflow. */
+
+/*  IndxSrc values: */
+#define INDXSRC_HARD		0	/*  Hardware or software index. */
+#define INDXSRC_SOFT		1	/*  Software index only. */
+
+/*  IndxPol values: */
+#define INDXPOL_POS 		0	/*  Index input is active high. */
+#define INDXPOL_NEG 		1	/*  Index input is active low. */
+
+/*  ClkSrc values: */
+#define CLKSRC_COUNTER		0	/*  Counter mode. */
+#define CLKSRC_TIMER		2	/*  Timer mode. */
+#define CLKSRC_EXTENDER		3	/*  Extender mode. */
+
+/*  ClkPol values: */
+#define CLKPOL_POS		0	/*  Counter/Extender clock is */
+					/*  active high. */
+#define CLKPOL_NEG		1	/*  Counter/Extender clock is */
+					/*  active low. */
+#define CNTDIR_UP		0	/*  Timer counts up. */
+#define CNTDIR_DOWN 		1	/*  Timer counts down. */
+
+/*  ClkEnab values: */
+#define CLKENAB_ALWAYS		0	/*  Clock always enabled. */
+#define CLKENAB_INDEX		1	/*  Clock is enabled by index. */
+
+/*  ClkMult values: */
+#define CLKMULT_4X 		0	/*  4x clock multiplier. */
+#define CLKMULT_2X 		1	/*  2x clock multiplier. */
+#define CLKMULT_1X 		2	/*  1x clock multiplier. */
+
+/*  Bit Field positions in COUNTER_SETUP structure: */
+#define BF_LOADSRC		9	/*  Preload trigger. */
+#define BF_INDXSRC		7	/*  Index source. */
+#define BF_INDXPOL		6	/*  Index polarity. */
+#define BF_CLKSRC		4	/*  Clock source. */
+#define BF_CLKPOL		3	/*  Clock polarity/count direction. */
+#define BF_CLKMULT		1	/*  Clock multiplier. */
+#define BF_CLKENAB		0	/*  Clock enable. */
+
+/*  Enumerated counter operating modes specified by ClkSrc bit field in */
+/*  a COUNTER_SETUP. */
+
+#define CLKSRC_COUNTER		0	/*  Counter: ENC_C clock, ENC_D */
+					/*  direction. */
+#define CLKSRC_TIMER		2	/*  Timer: SYS_C clock, */
+					/*  direction specified by */
+					/*  ClkPol. */
+#define CLKSRC_EXTENDER		3	/*  Extender: OVR_A clock, */
+					/*  ENC_D direction. */
+
+/*  Enumerated counter clock multipliers. */
+
+#define MULT_X0			0x0003	/*  Supports no multipliers; */
+					/*  fixed physical multiplier = */
+					/*  3. */
+#define MULT_X1			0x0002	/*  Supports multiplier x1; */
+					/*  fixed physical multiplier = */
+					/*  2. */
+#define MULT_X2			0x0001	/*  Supports multipliers x1, */
+					/*  x2; physical multipliers = */
+					/*  1 or 2. */
+#define MULT_X4			0x0000	/*  Supports multipliers x1, */
+					/*  x2, x4; physical */
+					/*  multipliers = 0, 1 or 2. */
+
+/*  Sanity-check limits for parameters. */
+
+#define NUM_COUNTERS		6	/*  Maximum valid counter */
+					/*  logical channel number. */
 #define NUM_INTSOURCES		4
 #define NUM_LATCHSOURCES	4
 #define NUM_CLKMULTS		4
@@ -708,33 +653,33 @@
 #define NUM_INDEXSOURCES	2
 #define NUM_LOADTRIGS		4
 
-// Bit field positions in CRA and CRB counter control registers.
-
-// Bit field positions in CRA:
-#define CRABIT_INDXSRC_B	14	//   B index source.
-#define CRABIT_CLKSRC_B		12	//   B clock source.
-#define CRABIT_INDXPOL_A	11	//   A index polarity.
-#define CRABIT_LOADSRC_A	 9	//   A preload trigger.
-#define CRABIT_CLKMULT_A	 7	//   A clock multiplier.
-#define CRABIT_INTSRC_A		 5	//   A interrupt source.
-#define CRABIT_CLKPOL_A		 4	//   A clock polarity.
-#define CRABIT_INDXSRC_A	 2	//   A index source.
-#define CRABIT_CLKSRC_A		 0	//   A clock source.
-
-// Bit field positions in CRB:
-#define CRBBIT_INTRESETCMD	15	//   Interrupt reset command.
-#define CRBBIT_INTRESET_B	14	//   B interrupt reset enable.
-#define CRBBIT_INTRESET_A	13	//   A interrupt reset enable.
-#define CRBBIT_CLKENAB_A	12	//   A clock enable.
-#define CRBBIT_INTSRC_B		10	//   B interrupt source.
-#define CRBBIT_LATCHSRC		 8	//   A/B latch source.
-#define CRBBIT_LOADSRC_B	 6	//   B preload trigger.
-#define CRBBIT_CLKMULT_B	 3	//   B clock multiplier.
-#define CRBBIT_CLKENAB_B	 2	//   B clock enable.
-#define CRBBIT_INDXPOL_B	 1	//   B index polarity.
-#define CRBBIT_CLKPOL_B		 0	//   B clock polarity.
-
-// Bit field masks for CRA and CRB.
+/*  Bit field positions in CRA and CRB counter control registers. */
+
+/*  Bit field positions in CRA: */
+#define CRABIT_INDXSRC_B	14	/*    B index source. */
+#define CRABIT_CLKSRC_B		12	/*    B clock source. */
+#define CRABIT_INDXPOL_A	11	/*    A index polarity. */
+#define CRABIT_LOADSRC_A	 9	/*    A preload trigger. */
+#define CRABIT_CLKMULT_A	 7	/*    A clock multiplier. */
+#define CRABIT_INTSRC_A		 5	/*    A interrupt source. */
+#define CRABIT_CLKPOL_A		 4	/*    A clock polarity. */
+#define CRABIT_INDXSRC_A	 2	/*    A index source. */
+#define CRABIT_CLKSRC_A		 0	/*    A clock source. */
+
+/*  Bit field positions in CRB: */
+#define CRBBIT_INTRESETCMD	15	/*    Interrupt reset command. */
+#define CRBBIT_INTRESET_B	14	/*    B interrupt reset enable. */
+#define CRBBIT_INTRESET_A	13	/*    A interrupt reset enable. */
+#define CRBBIT_CLKENAB_A	12	/*    A clock enable. */
+#define CRBBIT_INTSRC_B		10	/*    B interrupt source. */
+#define CRBBIT_LATCHSRC		 8	/*    A/B latch source. */
+#define CRBBIT_LOADSRC_B	 6	/*    B preload trigger. */
+#define CRBBIT_CLKMULT_B	 3	/*    B clock multiplier. */
+#define CRBBIT_CLKENAB_B	 2	/*    B clock enable. */
+#define CRBBIT_INDXPOL_B	 1	/*    B index polarity. */
+#define CRBBIT_CLKPOL_B		 0	/*    B clock polarity. */
+
+/*  Bit field masks for CRA and CRB. */
 
 #define CRAMSK_INDXSRC_B	( (uint16_t)( 3 << CRABIT_INDXSRC_B) )
 #define CRAMSK_CLKSRC_B		( (uint16_t)( 3 << CRABIT_CLKSRC_B) )
@@ -758,9 +703,9 @@
 #define CRBMSK_INDXPOL_B	( (uint16_t)( 1 << CRBBIT_INDXPOL_B) )
 #define CRBMSK_CLKPOL_B		( (uint16_t)( 1 << CRBBIT_CLKPOL_B) )
 
-#define CRBMSK_INTCTRL		( CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B )	// Interrupt reset control bits.
+#define CRBMSK_INTCTRL		( CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B )	/*  Interrupt reset control bits. */
 
-// Bit field positions for standardized SETUP structure.
+/*  Bit field positions for standardized SETUP structure. */
 
 #define STDBIT_INTSRC		13
 #define STDBIT_LATCHSRC		11
@@ -772,7 +717,7 @@
 #define STDBIT_CLKMULT		 1
 #define STDBIT_CLKENAB		 0
 
-// Bit field masks for standardized SETUP structure.
+/*  Bit field masks for standardized SETUP structure. */
 
 #define STDMSK_INTSRC		( (uint16_t)( 3 << STDBIT_INTSRC   ) )
 #define STDMSK_LATCHSRC		( (uint16_t)( 3 << STDBIT_LATCHSRC ) )
@@ -784,7 +729,6 @@
 #define STDMSK_CLKMULT		( (uint16_t)( 3 << STDBIT_CLKMULT  ) )
 #define STDMSK_CLKENAB		( (uint16_t)( 1 << STDBIT_CLKENAB  ) )
 
-//////////////////////////////////////////////////////////
 
 /* typedef struct indexCounter */
 /* { */

commit 11e865c1dad436d2ce65c7d366030d1b62967a83
Author: Gianluca Palli <gpalli@deis.unibo.it>
Date:   Wed Nov 19 14:10:49 2008 -0800

    Staging: comedi: add s626 driver
    
    This adds the s626 comedi driver to the build.
    
    From: Gianluca Palli <gpalli@deis.unibo.it>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
new file mode 100644
index 000000000000..11d8b1ceb0b8
--- /dev/null
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -0,0 +1,802 @@
+/*
+  comedi/drivers/s626.h
+  Sensoray s626 Comedi driver, header file
+
+  COMEDI - Linux Control and Measurement Device Interface
+  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+
+  Based on Sensoray Model 626 Linux driver Version 0.2
+  Copyright (C) 2002-2004 Sensoray Co., Inc.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+/*
+  Driver: s626.o (s626.ko)
+  Description: Sensoray 626 driver
+  Devices: Sensoray s626
+  Authors: Gianluca Palli <gpalli@deis.unibo.it>,
+  Updated: Thu, 12 Jul 2005
+  Status: experimental
+
+  Configuration Options:
+  analog input:
+   none
+
+  analog output:
+   none
+
+  digital channel:
+   s626 has 3 dio subdevices (2,3 and 4) each with 16 i/o channels
+   supported configuration options:
+   INSN_CONFIG_DIO_QUERY
+   COMEDI_INPUT
+   COMEDI_OUTPUT
+
+  encoder:
+   Every channel must be configured before reading.
+
+   Example code
+
+   insn.insn=INSN_CONFIG;   //configuration instruction
+   insn.n=1;                //number of operation (must be 1)
+   insn.data=&initialvalue; //initial value loaded into encoder
+                            //during configuration
+   insn.subdev=5;           //encoder subdevice
+   insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); //encoder_channel
+                                                        //to configure
+
+   comedi_do_insn(cf,&insn); //executing configuration
+*/
+
+#ifdef _DEBUG_
+#define DEBUG(...);        rt_printk(__VA_ARGS__);
+#else
+#define DEBUG(...)
+#endif
+
+#if !defined(TRUE)
+#define TRUE    (1)
+#endif
+
+#if !defined(FALSE)
+#define FALSE   (0)
+#endif
+
+#if !defined(EXTERN)
+#if defined(__cplusplus)
+#define EXTERN extern "C"
+#else
+#define EXTERN extern
+#endif
+#endif
+
+#if !defined(INLINE)
+#define INLINE static __inline
+#endif
+
+/////////////////////////////////////////////////////
+#include<linux/slab.h>
+
+#define S626_SIZE 0x0200
+#define SIZEOF_ADDRESS_SPACE		0x0200
+#define DMABUF_SIZE			4096	// 4k pages
+
+#define S626_ADC_CHANNELS       16
+#define S626_DAC_CHANNELS       4
+#define S626_ENCODER_CHANNELS   6
+#define S626_DIO_CHANNELS       48
+#define S626_DIO_BANKS		3	// Number of DIO groups.
+#define S626_DIO_EXTCHANS	40	// Number of
+					// extended-capability
+					// DIO channels.
+
+#define NUM_TRIMDACS	12	// Number of valid TrimDAC channels.
+
+// PCI bus interface types.
+#define INTEL				1	// Intel bus type.
+#define MOTOROLA			2	// Motorola bus type.
+
+//////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////
+#define PLATFORM		INTEL	// *** SELECT PLATFORM TYPE ***
+//////////////////////////////////////////////////////////
+
+#define RANGE_5V                0x10	// +/-5V range
+#define RANGE_10V               0x00	// +/-10V range
+
+#define EOPL			0x80	// End of ADC poll list marker.
+#define GSEL_BIPOLAR5V		0x00F0	// LP_GSEL setting for 5V bipolar range.
+#define GSEL_BIPOLAR10V		0x00A0	// LP_GSEL setting for 10V bipolar range.
+
+// Error codes that must be visible to this base class.
+#define ERR_ILLEGAL_PARM	0x00010000	// Illegal function parameter value was specified.
+#define ERR_I2C			0x00020000	// I2C error.
+#define ERR_COUNTERSETUP	0x00200000	// Illegal setup specified for counter channel.
+#define ERR_DEBI_TIMEOUT	0x00400000	// DEBI transfer timed out.
+
+// Organization (physical order) and size (in DWORDs) of logical DMA buffers contained by ANA_DMABUF.
+#define ADC_DMABUF_DWORDS	40	// ADC DMA buffer must hold 16 samples, plus pre/post garbage samples.
+#define DAC_WDMABUF_DWORDS	1	// DAC output DMA buffer holds a single sample.
+
+// All remaining space in 4KB DMA buffer is available for the RPS1 program.
+
+// Address offsets, in DWORDS, from base of DMA buffer.
+#define DAC_WDMABUF_OS		ADC_DMABUF_DWORDS
+
+// Interrupt enab bit in ISR and IER.
+#define IRQ_GPIO3		0x00000040	// IRQ enable for GPIO3.
+#define IRQ_RPS1                0x10000000
+#define ISR_AFOU		0x00000800	// Audio fifo
+						// under/overflow
+						// detected.
+#define IRQ_COINT1A             0x0400	// conter 1A overflow
+						// interrupt mask
+#define IRQ_COINT1B             0x0800	// conter 1B overflow
+						// interrupt mask
+#define IRQ_COINT2A             0x1000	// conter 2A overflow
+						// interrupt mask
+#define IRQ_COINT2B             0x2000	// conter 2B overflow
+						// interrupt mask
+#define IRQ_COINT3A             0x4000	// conter 3A overflow
+						// interrupt mask
+#define IRQ_COINT3B             0x8000	// conter 3B overflow
+						// interrupt mask
+
+// RPS command codes.
+#define RPS_CLRSIGNAL		0x00000000	// CLEAR SIGNAL
+#define RPS_SETSIGNAL		0x10000000	// SET SIGNAL
+#define RPS_NOP			0x00000000	// NOP
+#define RPS_PAUSE		0x20000000	// PAUSE
+#define RPS_UPLOAD		0x40000000	// UPLOAD
+#define RPS_JUMP		0x80000000	// JUMP
+#define RPS_LDREG		0x90000100	// LDREG (1 uint32_t only)
+#define RPS_STREG		0xA0000100	// STREG (1 uint32_t only)
+#define RPS_STOP		0x50000000	// STOP
+#define RPS_IRQ                 0x60000000	// IRQ
+
+#define RPS_LOGICAL_OR		0x08000000	// Logical OR conditionals.
+#define RPS_INVERT		0x04000000	// Test for negated semaphores.
+#define RPS_DEBI		0x00000002	// DEBI done
+
+#define RPS_SIG0		0x00200000	// RPS semaphore 0 (used by ADC).
+#define RPS_SIG1		0x00400000	// RPS semaphore 1 (used by DAC).
+#define RPS_SIG2		0x00800000	// RPS semaphore 2 (not used).
+#define RPS_GPIO2		0x00080000	// RPS GPIO2
+#define RPS_GPIO3		0x00100000	// RPS GPIO3
+
+#define RPS_SIGADC		RPS_SIG0	// Trigger/status for ADC's RPS program.
+#define RPS_SIGDAC		RPS_SIG1	// Trigger/status for DAC's RPS program.
+
+// RPS clock parameters.
+#define RPSCLK_SCALAR		8	// This is apparent ratio of PCI/RPS clks (undocumented!!).
+#define RPSCLK_PER_US		( 33 / RPSCLK_SCALAR )	// Number of RPS clocks in one microsecond.
+
+// Event counter source addresses.
+#define SBA_RPS_A0		0x27	// Time of RPS0 busy, in PCI clocks.
+
+// GPIO constants.
+#define GPIO_BASE		0x10004000	// GPIO 0,2,3 = inputs, GPIO3 = IRQ; GPIO1 = out.
+#define GPIO1_LO		0x00000000	// GPIO1 set to LOW.
+#define GPIO1_HI		0x00001000	// GPIO1 set to HIGH.
+
+// Primary Status Register (PSR) constants.
+#define PSR_DEBI_E		0x00040000	// DEBI event flag.
+#define PSR_DEBI_S		0x00080000	// DEBI status flag.
+#define PSR_A2_IN		0x00008000	// Audio output DMA2 protection address reached.
+#define PSR_AFOU		0x00000800	// Audio FIFO under/overflow detected.
+#define PSR_GPIO2		0x00000020	// GPIO2 input pin: 0=AdcBusy, 1=AdcIdle.
+#define PSR_EC0S		0x00000001	// Event counter 0 threshold reached.
+
+// Secondary Status Register (SSR) constants.
+#define SSR_AF2_OUT		0x00000200	// Audio 2 output FIFO under/overflow detected.
+
+// Master Control Register 1 (MC1) constants.
+#define MC1_SOFT_RESET		0x80000000	// Invoke 7146 soft reset.
+#define MC1_SHUTDOWN		0x3FFF0000	// Shut down all MC1-controlled enables.
+
+#define MC1_ERPS1		0x2000	// enab/disable RPS task 1.
+#define MC1_ERPS0		0x1000	// enab/disable RPS task 0.
+#define MC1_DEBI		0x0800	// enab/disable DEBI pins.
+#define MC1_AUDIO		0x0200	// enab/disable audio port pins.
+#define MC1_I2C			0x0100	// enab/disable I2C interface.
+#define MC1_A2OUT		0x0008	// enab/disable transfer on A2 out.
+#define MC1_A2IN		0x0004	// enab/disable transfer on A2 in.
+#define MC1_A1IN		0x0001	// enab/disable transfer on A1 in.
+
+// Master Control Register 2 (MC2) constants.
+#define MC2_UPLD_DEBIq		0x00020002	// Upload DEBI registers.
+#define MC2_UPLD_IICq		0x00010001	// Upload I2C registers.
+#define MC2_RPSSIG2_ONq		0x20002000	// Assert RPS_SIG2.
+#define MC2_RPSSIG1_ONq		0x10001000	// Assert RPS_SIG1.
+#define MC2_RPSSIG0_ONq		0x08000800	// Assert RPS_SIG0.
+#define MC2_UPLD_DEBI_MASKq	0x00000002	// Upload DEBI mask.
+#define MC2_UPLD_IIC_MASKq	0x00000001	// Upload I2C mask.
+#define MC2_RPSSIG2_MASKq	0x00002000	// RPS_SIG2 bit mask.
+#define MC2_RPSSIG1_MASKq	0x00001000	// RPS_SIG1 bit mask.
+#define MC2_RPSSIG0_MASKq	0x00000800	// RPS_SIG0 bit mask.
+
+#define MC2_DELAYTRIG_4USq	MC2_RPSSIG1_ON
+#define MC2_DELAYBUSY_4USq	MC2_RPSSIG1_MASK
+
+#define	MC2_DELAYTRIG_6USq	MC2_RPSSIG2_ON
+#define MC2_DELAYBUSY_6USq	MC2_RPSSIG2_MASK
+
+#define MC2_UPLD_DEBI		0x0002	// Upload DEBI.
+#define MC2_UPLD_IIC		0x0001	// Upload I2C.
+#define MC2_RPSSIG2		0x2000	// RPS signal 2 (not used).
+#define MC2_RPSSIG1		0x1000	// RPS signal 1 (DAC RPS busy).
+#define MC2_RPSSIG0		0x0800	// RPS signal 0 (ADC RPS busy).
+
+#define MC2_ADC_RPS		MC2_RPSSIG0	// ADC RPS busy.
+#define MC2_DAC_RPS		MC2_RPSSIG1	// DAC RPS busy.
+
+///////////////////oldies///////////
+#define MC2_UPLD_DEBIQ		0x00020002	// Upload DEBI registers.
+#define MC2_UPLD_IICQ		0x00010001	// Upload I2C registers.
+////////////////////////////////////////
+
+// PCI BUS (SAA7146) REGISTER ADDRESS OFFSETS ////////////////////////
+#define P_PCI_BT_A		0x004C	// Audio DMA
+						// burst/threshold
+						// control.
+#define P_DEBICFG               0x007C	// DEBI configuration.
+#define P_DEBICMD               0x0080	// DEBI command.
+#define P_DEBIPAGE              0x0084	// DEBI page.
+#define P_DEBIAD                0x0088	// DEBI target address.
+#define P_I2CCTRL               0x008C	// I2C control.
+#define P_I2CSTAT               0x0090	// I2C status.
+#define P_BASEA2_IN		0x00AC	// Audio input 2 base
+						// physical DMAbuf
+						// address.
+#define P_PROTA2_IN		0x00B0	// Audio input 2
+						// physical DMAbuf
+						// protection address.
+#define P_PAGEA2_IN		0x00B4	// Audio input 2
+						// paging attributes.
+#define P_BASEA2_OUT		0x00B8	// Audio output 2 base
+						// physical DMAbuf
+						// address.
+#define P_PROTA2_OUT		0x00BC	// Audio output 2
+						// physical DMAbuf
+						// protection address.
+#define P_PAGEA2_OUT		0x00C0	// Audio output 2
+						// paging attributes.
+#define P_RPSPAGE0              0x00C4	// RPS0 page.
+#define P_RPSPAGE1              0x00C8	// RPS1 page.
+#define P_RPS0_TOUT		0x00D4	// RPS0 time-out.
+#define P_RPS1_TOUT		0x00D8	// RPS1 time-out.
+#define P_IER                   0x00DC	// Interrupt enable.
+#define P_GPIO                  0x00E0	// General-purpose I/O.
+#define P_EC1SSR		0x00E4	// Event counter set 1
+						// source select.
+#define P_ECT1R			0x00EC	// Event counter
+						// threshold set 1.
+#define P_ACON1                 0x00F4	// Audio control 1.
+#define P_ACON2                 0x00F8	// Audio control 2.
+#define P_MC1                   0x00FC	// Master control 1.
+#define P_MC2                   0x0100	// Master control 2.
+#define P_RPSADDR0              0x0104	// RPS0 instruction pointer.
+#define P_RPSADDR1              0x0108	// RPS1 instruction pointer.
+#define P_ISR                   0x010C	// Interrupt status.
+#define P_PSR                   0x0110	// Primary status.
+#define P_SSR                   0x0114	// Secondary status.
+#define P_EC1R			0x0118	// Event counter set 1.
+#define P_ADP4			0x0138	// Logical audio DMA
+						// pointer of audio
+						// input FIFO A2_IN.
+#define P_FB_BUFFER1            0x0144	// Audio feedback buffer 1.
+#define P_FB_BUFFER2            0x0148	// Audio feedback buffer 2.
+#define P_TSL1                  0x0180	// Audio time slot list 1.
+#define P_TSL2                  0x01C0	// Audio time slot list 2.
+
+// LOCAL BUS (GATE ARRAY) REGISTER ADDRESS OFFSETS /////////////////
+// Analog I/O registers:
+#define LP_DACPOL		0x0082	//  Write DAC polarity.
+#define LP_GSEL			0x0084	//  Write ADC gain.
+#define LP_ISEL			0x0086	//  Write ADC channel select.
+// Digital I/O (write only):
+#define LP_WRINTSELA		0x0042	//  Write A interrupt enable.
+#define LP_WREDGSELA		0x0044	//  Write A edge selection.
+#define LP_WRCAPSELA		0x0046	//  Write A capture enable.
+#define LP_WRDOUTA		0x0048	//  Write A digital output.
+#define LP_WRINTSELB		0x0052	//  Write B interrupt enable.
+#define LP_WREDGSELB		0x0054	//  Write B edge selection.
+#define LP_WRCAPSELB		0x0056	//  Write B capture enable.
+#define LP_WRDOUTB		0x0058	//  Write B digital output.
+#define LP_WRINTSELC		0x0062	//  Write C interrupt enable.
+#define LP_WREDGSELC		0x0064	//  Write C edge selection.
+#define LP_WRCAPSELC		0x0066	//  Write C capture enable.
+#define LP_WRDOUTC		0x0068	//  Write C digital output.
+
+// Digital I/O (read only):
+#define LP_RDDINA		0x0040	//  Read digital input.
+#define LP_RDCAPFLGA		0x0048	//  Read edges captured.
+#define LP_RDINTSELA		0x004A	//  Read interrupt
+						//  enable register.
+#define LP_RDEDGSELA		0x004C	//  Read edge
+						//  selection
+						//  register.
+#define LP_RDCAPSELA		0x004E	//  Read capture
+						//  enable register.
+#define LP_RDDINB		0x0050	//  Read digital input.
+#define LP_RDCAPFLGB		0x0058	//  Read edges captured.
+#define LP_RDINTSELB		0x005A	//  Read interrupt
+						//  enable register.
+#define LP_RDEDGSELB		0x005C	//  Read edge
+						//  selection
+						//  register.
+#define LP_RDCAPSELB		0x005E	//  Read capture
+						//  enable register.
+#define LP_RDDINC		0x0060	//  Read digital input.
+#define LP_RDCAPFLGC		0x0068	//  Read edges captured.
+#define LP_RDINTSELC		0x006A	//  Read interrupt
+						//  enable register.
+#define LP_RDEDGSELC		0x006C	//  Read edge
+						//  selection
+						//  register.
+#define LP_RDCAPSELC		0x006E	//  Read capture
+						//  enable register.
+// Counter Registers (read/write):
+#define LP_CR0A			0x0000	//  0A setup register.
+#define LP_CR0B			0x0002	//  0B setup register.
+#define LP_CR1A			0x0004	//  1A setup register.
+#define LP_CR1B			0x0006	//  1B setup register.
+#define LP_CR2A			0x0008	//  2A setup register.
+#define LP_CR2B			0x000A	//  2B setup register.
+// Counter PreLoad (write) and Latch (read) Registers:
+#define	LP_CNTR0ALSW		0x000C	//  0A lsw.
+#define	LP_CNTR0AMSW		0x000E	//  0A msw.
+#define	LP_CNTR0BLSW		0x0010	//  0B lsw.
+#define	LP_CNTR0BMSW		0x0012	//  0B msw.
+#define	LP_CNTR1ALSW		0x0014	//  1A lsw.
+#define	LP_CNTR1AMSW		0x0016	//  1A msw.
+#define	LP_CNTR1BLSW		0x0018	//  1B lsw.
+#define	LP_CNTR1BMSW		0x001A	//  1B msw.
+#define	LP_CNTR2ALSW		0x001C	//  2A lsw.
+#define	LP_CNTR2AMSW		0x001E	//  2A msw.
+#define	LP_CNTR2BLSW		0x0020	//  2B lsw.
+#define	LP_CNTR2BMSW		0x0022	//  2B msw.
+// Miscellaneous Registers (read/write):
+#define LP_MISC1		0x0088	//  Read/write Misc1.
+#define LP_WRMISC2		0x0090	//  Write Misc2.
+#define LP_RDMISC2		0x0082	//  Read Misc2.
+
+// Bit masks for MISC1 register that are the same for reads and writes.
+#define MISC1_WENABLE		0x8000	// enab writes to
+						// MISC2 (except Clear
+						// Watchdog bit).
+#define MISC1_WDISABLE		0x0000	// Disable writes to MISC2.
+#define MISC1_EDCAP		0x1000	// enab edge capture
+						// on DIO chans
+						// specified by
+						// LP_WRCAPSELx.
+#define MISC1_NOEDCAP		0x0000	// Disable edge
+						// capture on
+						// specified DIO
+						// chans.
+
+// Bit masks for MISC1 register reads.
+#define RDMISC1_WDTIMEOUT	0x4000	// Watchdog timer timed out.
+
+// Bit masks for MISC2 register writes.
+#define WRMISC2_WDCLEAR		0x8000	// Reset watchdog
+						// timer to zero.
+#define WRMISC2_CHARGE_ENABLE	0x4000	// enab battery
+						// trickle charging.
+
+// Bit masks for MISC2 register that are the same for reads and writes.
+#define MISC2_BATT_ENABLE	0x0008	// Backup battery enable.
+#define MISC2_WDENABLE		0x0004	// Watchdog timer enable.
+#define MISC2_WDPERIOD_MASK	0x0003	// Watchdog interval
+						// select mask.
+
+// Bit masks for ACON1 register.
+#define A2_RUN			0x40000000	// Run A2 based on TSL2.
+#define A1_RUN			0x20000000	// Run A1 based on TSL1.
+#define A1_SWAP			0x00200000	// Use big-endian for A1.
+#define A2_SWAP			0x00100000	// Use big-endian for A2.
+#define WS_MODES		0x00019999	// WS0 = TSL1 trigger
+						// input, WS1-WS4 =
+						// CS* outputs.
+
+#if PLATFORM == INTEL		// Base ACON1 config:
+						// always run A1 based
+						// on TSL1.
+#define ACON1_BASE		( WS_MODES | A1_RUN )
+#elif PLATFORM == MOTOROLA
+#define ACON1_BASE		( WS_MODES | A1_RUN | A1_SWAP | A2_SWAP )
+#endif
+
+#define ACON1_ADCSTART		ACON1_BASE	// Start ADC: run A1
+						// based on TSL1.
+#define ACON1_DACSTART		( ACON1_BASE | A2_RUN )	// Start
+							// transmit to
+							// DAC: run A2
+							// based on
+							// TSL2.
+#define ACON1_DACSTOP		ACON1_BASE	// Halt A2.
+
+// Bit masks for ACON2 register.
+#define A1_CLKSRC_BCLK1		0x00000000	// A1 bit rate = BCLK1 (ADC).
+#define A2_CLKSRC_X1		0x00800000	// A2 bit rate = ACLK/1 (DACs).
+#define A2_CLKSRC_X2		0x00C00000	// A2 bit rate = ACLK/2 (DACs).
+#define A2_CLKSRC_X4		0x01400000	// A2 bit rate = ACLK/4 (DACs).
+#define INVERT_BCLK2		0x00100000	// Invert BCLK2 (DACs).
+#define BCLK2_OE		0x00040000	// enab BCLK2 (DACs).
+#define ACON2_XORMASK		0x000C0000	// XOR mask for ACON2
+						// active-low bits.
+
+#define ACON2_INIT		( ACON2_XORMASK ^ ( A1_CLKSRC_BCLK1 | A2_CLKSRC_X2 | INVERT_BCLK2 | BCLK2_OE ) )
+
+// Bit masks for timeslot records.
+#define WS1		     	0x40000000	// WS output to assert.
+#define WS2		     	0x20000000
+#define WS3		     	0x10000000
+#define WS4		     	0x08000000
+#define RSD1			0x01000000	// Shift A1 data in on SD1.
+#define SDW_A1			0x00800000	// Store rcv'd char at
+						// next char slot of
+						// DWORD1 buffer.
+#define SIB_A1			0x00400000	// Store rcv'd char at
+						// next char slot of
+						// FB1 buffer.
+#define SF_A1			0x00200000	// Write unsigned long
+						// buffer to input
+						// FIFO.
+
+//Select parallel-to-serial converter's data source:
+#define XFIFO_0			0x00000000	//   Data fifo byte 0.
+#define XFIFO_1			0x00000010	//   Data fifo byte 1.
+#define XFIFO_2			0x00000020	//   Data fifo byte 2.
+#define XFIFO_3			0x00000030	//   Data fifo byte 3.
+#define XFB0			0x00000040	//   FB_BUFFER byte 0.
+#define XFB1			0x00000050	//   FB_BUFFER byte 1.
+#define XFB2			0x00000060	//   FB_BUFFER byte 2.
+#define XFB3			0x00000070	//   FB_BUFFER byte 3.
+#define SIB_A2			0x00000200	// Store next dword
+						// from A2's input
+						// shifter to FB2
+						// buffer.
+#define SF_A2			0x00000100	// Store next dword
+						// from A2's input
+						// shifter to its
+						// input fifo.
+#define LF_A2			0x00000080	// Load next dword
+						// from A2's output
+						// fifo into its
+						// output dword
+						// buffer.
+#define XSD2			0x00000008	// Shift data out on SD2.
+#define RSD3			0x00001800	// Shift data in on SD3.
+#define RSD2			0x00001000	// Shift data in on SD2.
+#define LOW_A2			0x00000002	// Drive last SD low
+						// for 7 clks, then
+						// tri-state.
+#define EOS		     	0x00000001	// End of superframe.
+
+//////////////////////
+
+// I2C configuration constants.
+#define I2C_CLKSEL		0x0400	// I2C bit rate =
+						// PCIclk/480 = 68.75
+						// KHz.
+#define I2C_BITRATE		68.75	// I2C bus data bit
+						// rate (determined by
+						// I2C_CLKSEL) in KHz.
+#define I2C_WRTIME		15.0	// Worst case time,in
+						// msec, for EEPROM
+						// internal write op.
+
+// I2C manifest constants.
+
+// Max retries to wait for EEPROM write.
+#define I2C_RETRIES		( I2C_WRTIME * I2C_BITRATE / 9.0 )
+#define I2C_ERR			0x0002	// I2C control/status
+						// flag ERROR.
+#define I2C_BUSY		0x0001	// I2C control/status
+						// flag BUSY.
+#define I2C_ABORT		0x0080	// I2C status flag ABORT.
+#define I2C_ATTRSTART		0x3	// I2C attribute START.
+#define I2C_ATTRCONT		0x2	// I2C attribute CONT.
+#define I2C_ATTRSTOP		0x1	// I2C attribute STOP.
+#define I2C_ATTRNOP		0x0	// I2C attribute NOP.
+
+// I2C read command  | EEPROM address.
+#define I2CR			( devpriv->I2CAdrs | 1 )
+
+// I2C write command | EEPROM address.
+#define I2CW			( devpriv->I2CAdrs )
+
+// Code macros used for constructing I2C command bytes.
+#define I2C_B2(ATTR,VAL)	( ( (ATTR) << 6 ) | ( (VAL) << 24 ) )
+#define I2C_B1(ATTR,VAL)	( ( (ATTR) << 4 ) | ( (VAL) << 16 ) )
+#define I2C_B0(ATTR,VAL)	( ( (ATTR) << 2 ) | ( (VAL) <<  8 ) )
+
+////////////////////////////////////////////////////////
+//oldest
+#define P_DEBICFGq              0x007C	// DEBI configuration.
+#define P_DEBICMDq              0x0080	// DEBI command.
+#define P_DEBIPAGEq             0x0084	// DEBI page.
+#define P_DEBIADq               0x0088	// DEBI target address.
+
+#define DEBI_CFG_TOQ		0x03C00000	// timeout (15 PCI cycles)
+#define DEBI_CFG_FASTQ		0x10000000	// fast mode enable
+#define DEBI_CFG_16Q		0x00080000	// 16-bit access enable
+#define DEBI_CFG_INCQ		0x00040000	// enable address increment
+#define DEBI_CFG_TIMEROFFQ	0x00010000	// disable timer
+#define DEBI_CMD_RDQ		0x00050000	// read immediate 2 bytes
+#define DEBI_CMD_WRQ		0x00040000	// write immediate 2 bytes
+#define DEBI_PAGE_DISABLEQ	0x00000000	// paging disable
+
+///////////////////////////////////////////
+// DEBI command constants.
+#define DEBI_CMD_SIZE16		( 2 << 17 )	// Transfer size is
+						// always 2 bytes.
+#define DEBI_CMD_READ		0x00010000	// Read operation.
+#define DEBI_CMD_WRITE		0x00000000	// Write operation.
+
+// Read immediate 2 bytes.
+#define DEBI_CMD_RDWORD		( DEBI_CMD_READ  | DEBI_CMD_SIZE16 )
+
+// Write immediate 2 bytes.
+#define DEBI_CMD_WRWORD		( DEBI_CMD_WRITE | DEBI_CMD_SIZE16 )
+
+// DEBI configuration constants.
+#define DEBI_CFG_XIRQ_EN	0x80000000	// enab external
+						// interrupt on GPIO3.
+#define DEBI_CFG_XRESUME	0x40000000	// Resume block
+						// transfer when XIRQ
+						// deasserted.
+#define DEBI_CFG_FAST		0x10000000	// Fast mode enable.
+
+// 4-bit field that specifies DEBI timeout value in PCI clock cycles:
+#define DEBI_CFG_TOUT_BIT	22	//   Finish DEBI cycle after
+					//   this many clocks.
+
+// 2-bit field that specifies Endian byte lane steering:
+#define DEBI_CFG_SWAP_NONE	0x00000000	//   Straight - don't
+						//   swap any bytes
+						//   (Intel).
+#define DEBI_CFG_SWAP_2		0x00100000	//   2-byte swap (Motorola).
+#define DEBI_CFG_SWAP_4		0x00200000	//   4-byte swap.
+#define DEBI_CFG_16		0x00080000	// Slave is able to
+						// serve 16-bit
+						// cycles.
+
+#define DEBI_CFG_SLAVE16	0x00080000	// Slave is able to
+						// serve 16-bit
+						// cycles.
+#define DEBI_CFG_INC		0x00040000	// enab address
+						// increment for block
+						// transfers.
+#define DEBI_CFG_INTEL		0x00020000	// Intel style local bus.
+#define DEBI_CFG_TIMEROFF	0x00010000	// Disable timer.
+
+#if PLATFORM == INTEL
+
+#define DEBI_TOUT		7	// Wait 7 PCI clocks
+						// (212 ns) before
+						// polling RDY.
+
+// Intel byte lane steering (pass through all byte lanes).
+#define DEBI_SWAP		DEBI_CFG_SWAP_NONE
+
+#elif PLATFORM == MOTOROLA
+
+#define DEBI_TOUT		15	// Wait 15 PCI clocks (454 ns)
+					// maximum before timing out.
+#define DEBI_SWAP		DEBI_CFG_SWAP_2	// Motorola byte lane steering.
+
+#endif
+
+// DEBI page table constants.
+#define DEBI_PAGE_DISABLE	0x00000000	// Paging disable.
+
+///////////////////EXTRA FROM OTHER SANSORAY  * .h////////
+
+// LoadSrc values:
+#define LOADSRC_INDX		0	// Preload core in response to
+					// Index.
+#define LOADSRC_OVER		1	// Preload core in response to
+					// Overflow.
+#define LOADSRCB_OVERA		2	// Preload B core in response
+					// to A Overflow.
+#define LOADSRC_NONE		3	// Never preload core.
+
+// IntSrc values:
+#define INTSRC_NONE 		0	// Interrupts disabled.
+#define INTSRC_OVER 		1	// Interrupt on Overflow.
+#define INTSRC_INDX 		2	// Interrupt on Index.
+#define INTSRC_BOTH 		3	// Interrupt on Index or Overflow.
+
+// LatchSrc values:
+#define LATCHSRC_AB_READ	0	// Latch on read.
+#define LATCHSRC_A_INDXA	1	// Latch A on A Index.
+#define LATCHSRC_B_INDXB	2	// Latch B on B Index.
+#define LATCHSRC_B_OVERA	3	// Latch B on A Overflow.
+
+// IndxSrc values:
+#define INDXSRC_HARD		0	// Hardware or software index.
+#define INDXSRC_SOFT		1	// Software index only.
+
+// IndxPol values:
+#define INDXPOL_POS 		0	// Index input is active high.
+#define INDXPOL_NEG 		1	// Index input is active low.
+
+// ClkSrc values:
+#define CLKSRC_COUNTER		0	// Counter mode.
+#define CLKSRC_TIMER		2	// Timer mode.
+#define CLKSRC_EXTENDER		3	// Extender mode.
+
+// ClkPol values:
+#define CLKPOL_POS		0	// Counter/Extender clock is
+					// active high.
+#define CLKPOL_NEG		1	// Counter/Extender clock is
+					// active low.
+#define CNTDIR_UP		0	// Timer counts up.
+#define CNTDIR_DOWN 		1	// Timer counts down.
+
+// ClkEnab values:
+#define CLKENAB_ALWAYS		0	// Clock always enabled.
+#define CLKENAB_INDEX		1	// Clock is enabled by index.
+
+// ClkMult values:
+#define CLKMULT_4X 		0	// 4x clock multiplier.
+#define CLKMULT_2X 		1	// 2x clock multiplier.
+#define CLKMULT_1X 		2	// 1x clock multiplier.
+
+// Bit Field positions in COUNTER_SETUP structure:
+#define BF_LOADSRC		9	// Preload trigger.
+#define BF_INDXSRC		7	// Index source.
+#define BF_INDXPOL		6	// Index polarity.
+#define BF_CLKSRC		4	// Clock source.
+#define BF_CLKPOL		3	// Clock polarity/count direction.
+#define BF_CLKMULT		1	// Clock multiplier.
+#define BF_CLKENAB		0	// Clock enable.
+
+// Enumerated counter operating modes specified by ClkSrc bit field in
+// a COUNTER_SETUP.
+
+#define CLKSRC_COUNTER		0	// Counter: ENC_C clock, ENC_D
+					// direction.
+#define CLKSRC_TIMER		2	// Timer: SYS_C clock,
+					// direction specified by
+					// ClkPol.
+#define CLKSRC_EXTENDER		3	// Extender: OVR_A clock,
+					// ENC_D direction.
+
+// Enumerated counter clock multipliers.
+
+#define MULT_X0			0x0003	// Supports no multipliers;
+					// fixed physical multiplier =
+					// 3.
+#define MULT_X1			0x0002	// Supports multiplier x1;
+					// fixed physical multiplier =
+					// 2.
+#define MULT_X2			0x0001	// Supports multipliers x1,
+					// x2; physical multipliers =
+					// 1 or 2.
+#define MULT_X4			0x0000	// Supports multipliers x1,
+					// x2, x4; physical
+					// multipliers = 0, 1 or 2.
+
+// Sanity-check limits for parameters.
+
+#define NUM_COUNTERS		6	// Maximum valid counter
+					// logical channel number.
+#define NUM_INTSOURCES		4
+#define NUM_LATCHSOURCES	4
+#define NUM_CLKMULTS		4
+#define NUM_CLKSOURCES		4
+#define NUM_CLKPOLS		2
+#define NUM_INDEXPOLS		2
+#define NUM_INDEXSOURCES	2
+#define NUM_LOADTRIGS		4
+
+// Bit field positions in CRA and CRB counter control registers.
+
+// Bit field positions in CRA:
+#define CRABIT_INDXSRC_B	14	//   B index source.
+#define CRABIT_CLKSRC_B		12	//   B clock source.
+#define CRABIT_INDXPOL_A	11	//   A index polarity.
+#define CRABIT_LOADSRC_A	 9	//   A preload trigger.
+#define CRABIT_CLKMULT_A	 7	//   A clock multiplier.
+#define CRABIT_INTSRC_A		 5	//   A interrupt source.
+#define CRABIT_CLKPOL_A		 4	//   A clock polarity.
+#define CRABIT_INDXSRC_A	 2	//   A index source.
+#define CRABIT_CLKSRC_A		 0	//   A clock source.
+
+// Bit field positions in CRB:
+#define CRBBIT_INTRESETCMD	15	//   Interrupt reset command.
+#define CRBBIT_INTRESET_B	14	//   B interrupt reset enable.
+#define CRBBIT_INTRESET_A	13	//   A interrupt reset enable.
+#define CRBBIT_CLKENAB_A	12	//   A clock enable.
+#define CRBBIT_INTSRC_B		10	//   B interrupt source.
+#define CRBBIT_LATCHSRC		 8	//   A/B latch source.
+#define CRBBIT_LOADSRC_B	 6	//   B preload trigger.
+#define CRBBIT_CLKMULT_B	 3	//   B clock multiplier.
+#define CRBBIT_CLKENAB_B	 2	//   B clock enable.
+#define CRBBIT_INDXPOL_B	 1	//   B index polarity.
+#define CRBBIT_CLKPOL_B		 0	//   B clock polarity.
+
+// Bit field masks for CRA and CRB.
+
+#define CRAMSK_INDXSRC_B	( (uint16_t)( 3 << CRABIT_INDXSRC_B) )
+#define CRAMSK_CLKSRC_B		( (uint16_t)( 3 << CRABIT_CLKSRC_B) )
+#define CRAMSK_INDXPOL_A	( (uint16_t)( 1 << CRABIT_INDXPOL_A) )
+#define CRAMSK_LOADSRC_A	( (uint16_t)( 3 << CRABIT_LOADSRC_A) )
+#define CRAMSK_CLKMULT_A	( (uint16_t)( 3 << CRABIT_CLKMULT_A) )
+#define CRAMSK_INTSRC_A		( (uint16_t)( 3 << CRABIT_INTSRC_A) )
+#define CRAMSK_CLKPOL_A		( (uint16_t)( 3 << CRABIT_CLKPOL_A) )
+#define CRAMSK_INDXSRC_A	( (uint16_t)( 3 << CRABIT_INDXSRC_A) )
+#define CRAMSK_CLKSRC_A		( (uint16_t)( 3 << CRABIT_CLKSRC_A) )
+
+#define CRBMSK_INTRESETCMD	( (uint16_t)( 1 << CRBBIT_INTRESETCMD) )
+#define CRBMSK_INTRESET_B	( (uint16_t)( 1 << CRBBIT_INTRESET_B) )
+#define CRBMSK_INTRESET_A	( (uint16_t)( 1 << CRBBIT_INTRESET_A) )
+#define CRBMSK_CLKENAB_A	( (uint16_t)( 1 << CRBBIT_CLKENAB_A) )
+#define CRBMSK_INTSRC_B		( (uint16_t)( 3 << CRBBIT_INTSRC_B) )
+#define CRBMSK_LATCHSRC		( (uint16_t)( 3 << CRBBIT_LATCHSRC) )
+#define CRBMSK_LOADSRC_B	( (uint16_t)( 3 << CRBBIT_LOADSRC_B) )
+#define CRBMSK_CLKMULT_B	( (uint16_t)( 3 << CRBBIT_CLKMULT_B) )
+#define CRBMSK_CLKENAB_B	( (uint16_t)( 1 << CRBBIT_CLKENAB_B) )
+#define CRBMSK_INDXPOL_B	( (uint16_t)( 1 << CRBBIT_INDXPOL_B) )
+#define CRBMSK_CLKPOL_B		( (uint16_t)( 1 << CRBBIT_CLKPOL_B) )
+
+#define CRBMSK_INTCTRL		( CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B )	// Interrupt reset control bits.
+
+// Bit field positions for standardized SETUP structure.
+
+#define STDBIT_INTSRC		13
+#define STDBIT_LATCHSRC		11
+#define STDBIT_LOADSRC		 9
+#define STDBIT_INDXSRC		 7
+#define STDBIT_INDXPOL		 6
+#define STDBIT_CLKSRC		 4
+#define STDBIT_CLKPOL		 3
+#define STDBIT_CLKMULT		 1
+#define STDBIT_CLKENAB		 0
+
+// Bit field masks for standardized SETUP structure.
+
+#define STDMSK_INTSRC		( (uint16_t)( 3 << STDBIT_INTSRC   ) )
+#define STDMSK_LATCHSRC		( (uint16_t)( 3 << STDBIT_LATCHSRC ) )
+#define STDMSK_LOADSRC		( (uint16_t)( 3 << STDBIT_LOADSRC  ) )
+#define STDMSK_INDXSRC		( (uint16_t)( 1 << STDBIT_INDXSRC  ) )
+#define STDMSK_INDXPOL		( (uint16_t)( 1 << STDBIT_INDXPOL  ) )
+#define STDMSK_CLKSRC		( (uint16_t)( 3 << STDBIT_CLKSRC   ) )
+#define STDMSK_CLKPOL		( (uint16_t)( 1 << STDBIT_CLKPOL   ) )
+#define STDMSK_CLKMULT		( (uint16_t)( 3 << STDBIT_CLKMULT  ) )
+#define STDMSK_CLKENAB		( (uint16_t)( 1 << STDBIT_CLKENAB  ) )
+
+//////////////////////////////////////////////////////////
+
+/* typedef struct indexCounter */
+/* { */
+/*   unsigned int ao; */
+/*   unsigned int ai; */
+/*   unsigned int digout; */
+/*   unsigned int digin; */
+/*   unsigned int enc; */
+/* }CallCounter; */
+
+typedef struct bufferDMA {
+	dma_addr_t PhysicalBase;
+	void *LogicalBase;
+	uint32_t DMAHandle;
+} DMABUF;
