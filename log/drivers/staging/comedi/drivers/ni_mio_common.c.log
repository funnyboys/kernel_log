commit f80ac69d32f19cab6e8d97a40c05f755a60fe96c
Author: Deepak R Varma <mh12gx2825@gmail.com>
Date:   Sun Mar 15 02:37:53 2020 +0530

    staging: comedi: ni_mio_common: Code reformat and re-indentation
    
    Resolve general code indentation problems as detected by checkpatch script.
    Implement code reformat and re-indentation as per coding style to
    improve readability.
    
    Signed-off-by: Deepak R Varma <mh12gx2825@gmail.com>
    Link: https://lore.kernel.org/r/20200314210749.GA3393@deeUbuntu
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b72a40a79930..d99f4065b96d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2199,9 +2199,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	case TRIG_EXT:
 		ai_trig |= NISTC_AI_TRIG_START1_SEL(
-			ni_get_reg_value_roffs(CR_CHAN(cmd->start_arg),
-					       NI_AI_StartTrigger,
-					       &devpriv->routing_tables, 1));
+				ni_get_reg_value_roffs(
+					CR_CHAN(cmd->start_arg),
+					NI_AI_StartTrigger,
+					&devpriv->routing_tables, 1));
 
 		if (cmd->start_arg & CR_INVERT)
 			ai_trig |= NISTC_AI_TRIG_START1_POLARITY;
@@ -2311,10 +2312,12 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		    (cmd->scan_begin_arg & ~CR_EDGE) !=
 		    (cmd->convert_arg & ~CR_EDGE))
 			start_stop_select |= NISTC_AI_START_SYNC;
+
 		start_stop_select |= NISTC_AI_START_SEL(
-			ni_get_reg_value_roffs(CR_CHAN(cmd->scan_begin_arg),
-					       NI_AI_SampleClock,
-					       &devpriv->routing_tables, 1));
+					ni_get_reg_value_roffs(
+						CR_CHAN(cmd->scan_begin_arg),
+						NI_AI_SampleClock,
+						&devpriv->routing_tables, 1));
 		ni_stc_writew(dev, start_stop_select, NISTC_AI_START_STOP_REG);
 		break;
 	}
@@ -2343,9 +2346,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	case TRIG_EXT:
 		mode1 |= NISTC_AI_MODE1_CONVERT_SRC(
-			ni_get_reg_value_roffs(CR_CHAN(cmd->convert_arg),
-					       NI_AI_ConvertClock,
-					       &devpriv->routing_tables, 1));
+				ni_get_reg_value_roffs(
+						CR_CHAN(cmd->convert_arg),
+						NI_AI_ConvertClock,
+						&devpriv->routing_tables, 1));
 		if ((cmd->convert_arg & CR_INVERT) == 0)
 			mode1 |= NISTC_AI_MODE1_CONVERT_POLARITY;
 		ni_stc_writew(dev, mode1, NISTC_AI_MODE1_REG);
@@ -2970,9 +2974,11 @@ static void ni_ao_cmd_set_trigger(struct comedi_device *dev,
 			  NISTC_AO_TRIG_START1_SYNC;
 	} else { /* TRIG_EXT */
 		trigsel = NISTC_AO_TRIG_START1_SEL(
-			ni_get_reg_value_roffs(CR_CHAN(cmd->start_arg),
-					       NI_AO_StartTrigger,
-					       &devpriv->routing_tables, 1));
+				ni_get_reg_value_roffs(
+						CR_CHAN(cmd->start_arg),
+						NI_AO_StartTrigger,
+						&devpriv->routing_tables, 1));
+
 		/* 0=active high, 1=active low. see daq-stc 3-24 (p186) */
 		if (cmd->start_arg & CR_INVERT)
 			trigsel |= NISTC_AO_TRIG_START1_POLARITY;
@@ -3079,12 +3085,10 @@ static void ni_ao_cmd_set_update(struct comedi_device *dev,
 	 * zero out these bit fields to be set below. Does an ao-reset do this
 	 * automatically?
 	 */
-	devpriv->ao_mode1 &= ~(
-	  NISTC_AO_MODE1_UI_SRC_MASK         |
-	  NISTC_AO_MODE1_UI_SRC_POLARITY     |
-	  NISTC_AO_MODE1_UPDATE_SRC_MASK     |
-	  NISTC_AO_MODE1_UPDATE_SRC_POLARITY
-	);
+	devpriv->ao_mode1 &=  ~(NISTC_AO_MODE1_UI_SRC_MASK	   |
+				NISTC_AO_MODE1_UI_SRC_POLARITY	   |
+				NISTC_AO_MODE1_UPDATE_SRC_MASK	   |
+				NISTC_AO_MODE1_UPDATE_SRC_POLARITY);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		unsigned int trigvar;
@@ -3134,9 +3138,10 @@ static void ni_ao_cmd_set_update(struct comedi_device *dev,
 		/* FIXME:  assert scan_begin_arg != 0, ret failure otherwise */
 		devpriv->ao_cmd2  |= NISTC_AO_CMD2_BC_GATE_ENA;
 		devpriv->ao_mode1 |= NISTC_AO_MODE1_UPDATE_SRC(
-			ni_get_reg_value(CR_CHAN(cmd->scan_begin_arg),
-					 NI_AO_SampleClock,
-					 &devpriv->routing_tables));
+					ni_get_reg_value(
+						CR_CHAN(cmd->scan_begin_arg),
+						NI_AO_SampleClock,
+						&devpriv->routing_tables));
 		if (cmd->scan_begin_arg & CR_INVERT)
 			devpriv->ao_mode1 |= NISTC_AO_MODE1_UPDATE_SRC_POLARITY;
 	}
@@ -3673,9 +3678,10 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	cdo_mode_bits = NI_M_CDO_MODE_FIFO_MODE |
 			NI_M_CDO_MODE_HALT_ON_ERROR |
 			NI_M_CDO_MODE_SAMPLE_SRC(
-				ni_get_reg_value(CR_CHAN(cmd->scan_begin_arg),
-						 NI_DO_SampleClock,
-						 &devpriv->routing_tables));
+				ni_get_reg_value(
+					CR_CHAN(cmd->scan_begin_arg),
+					NI_DO_SampleClock,
+					&devpriv->routing_tables));
 	if (cmd->scan_begin_arg & CR_INVERT)
 		cdo_mode_bits |= NI_M_CDO_MODE_POLARITY;
 	ni_writel(dev, cdo_mode_bits, NI_M_CDO_MODE_REG);

commit 9bfd8bc5e8bfabdc20eb9b528192f018498cf3db
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 7 15:13:59 2020 +0000

    staging: comedi: ni_mio_common: Allow alternate board name for routes
    
    We do not have or do not provide routing information for all supported
    boards.  Some of the boards for which we do not provide routing
    information actually have routes that are identical to a similar board
    for which we already provide routing information.
    
    To allow boards to share identical routing information, add an
    `alt_route_name` member to `struct ni_board_struct`.  This will be
    initialized to `NULL` for all boards except those that will use make use
    of the identical routing information that has been provided for a
    similar board, in which case it will name that board.  Pass the
    `alt_route_name` member value to `ni_assign_device_routes()` as the
    `alt_board_name` parameter, which it will use if no routing information
    could be found for the actual board name.
    
    Cc: Éric Piel <piel@delmic.com>
    Cc: Spencer E. Olson <olsonse@umich.edu>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Link: https://lore.kernel.org/r/20200207151400.272678-4-abbotti@mev.co.uk
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a1578868ee96..b72a40a79930 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5974,7 +5974,8 @@ static int ni_E_init(struct comedi_device *dev,
 						      : "ni_eseries";
 
 	/* prepare the device for globally-named routes. */
-	if (ni_assign_device_routes(dev_family, board->name, NULL,
+	if (ni_assign_device_routes(dev_family, board->name,
+				    board->alt_route_name,
 				    &devpriv->routing_tables) < 0) {
 		dev_warn(dev->class_dev, "%s: %s device has no signal routing table.\n",
 			 __func__, board->name);

commit e3b7ce73c578b77b592bd3f2da71b90f2c581c87
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 7 15:13:58 2020 +0000

    staging: comedi: ni_routes: Allow alternate board name for routes
    
    We do not have or provide routing information available for all
    supported boards.  Some of the boards for which we do not currently
    provide routing information actually have identical routes to a similar
    board for which we do provide routing information.  To avoid having to
    provide duplicate routing information, add an "alternate board name"
    parameter (possibly `NULl`) to `ni_assign_device_routes()` and
    `ni_find_device_routes()`.  If the routing information cannot be found
    for the actual board name, try finding it using the alternate board
    name.
    
    Cc: Éric Piel <piel@delmic.com>
    Cc: Spencer E. Olson <olsonse@umich.edu>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Link: https://lore.kernel.org/r/20200207151400.272678-3-abbotti@mev.co.uk
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index f98e3ae27bff..a1578868ee96 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5974,7 +5974,7 @@ static int ni_E_init(struct comedi_device *dev,
 						      : "ni_eseries";
 
 	/* prepare the device for globally-named routes. */
-	if (ni_assign_device_routes(dev_family, board->name,
+	if (ni_assign_device_routes(dev_family, board->name, NULL,
 				    &devpriv->routing_tables) < 0) {
 		dev_warn(dev->class_dev, "%s: %s device has no signal routing table.\n",
 			 __func__, board->name);

commit 88db7fc592559226cda373245770d90af0af3b0a
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Wed Aug 21 00:33:56 2019 +0900

    staging: comedi: ni_mio_common: Fix a typo in ni_mio_common.c
    
    This patch fix a spelling typo in ni_mio_common.c
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Link: https://lore.kernel.org/r/20190820153356.25189-1-standby24x7@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c175227009f1..f98e3ae27bff 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -596,7 +596,7 @@ static int ni_request_ao_mite_channel(struct comedi_device *dev)
 	if (!mite_chan) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		dev_err(dev->class_dev,
-			"failed to reserve mite dma channel for analog outut\n");
+			"failed to reserve mite dma channel for analog output\n");
 		return -EBUSY;
 	}
 	mite_chan->dir = COMEDI_OUTPUT;

commit e0dccbdf5ac7ccb9da5612100dedba302f3ebcfe
Merge: cf482a49af56 e2a5be107f52
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 13:31:29 2019 -0700

    Merge tag 'staging-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging / IIO driver updates from Greg KH:
     "Here is the big staging and iio driver update for 5.2-rc1.
    
      Lots of tiny fixes all over the staging and IIO driver trees here,
      along with some new IIO drivers.
    
      The "counter" subsystem was added in here as well, as it is needed by
      the IIO drivers and subsystem.
    
      Also we ended up deleting two drivers, making this pull request remove
      a few hundred thousand lines of code, always a nice thing to see. Both
      of the drivers removed have been replaced with "real" drivers in their
      various subsystem directories, and they will be coming to you from
      those locations during this merge window.
    
      There are some core vt/selection changes in here, that was due to some
      cleanups needed for the speakup fixes. Those have all been acked by
      the various subsystem maintainers (i.e. me), so those are ok.
    
      We also added a few new drivers, for some odd hardware, giving new
      developers plenty to work on with basic coding style cleanups to come
      in the near future.
    
      Other than that, nothing unusual here.
    
      All of these have been in linux-next for a while with no reported
      issues, other than an odd gcc warning for one of the new drivers that
      should be fixed up soon"
    
    [ I fixed up the warning myself  - Linus ]
    
    * tag 'staging-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (663 commits)
      staging: kpc2000: kpc_spi: Fix build error for {read,write}q
      Staging: rtl8192e: Remove extra space before break statement
      Staging: rtl8192u: ieee80211: Fix if-else indentation warning
      Staging: rtl8192u: ieee80211: Fix indentation errors by removing extra spaces
      staging: most: cdev: fix chrdev_region leak in mod_exit
      staging: wlan-ng: Fix improper SPDX comment style
      staging: rtl8192u: ieee80211: Resolve ERROR reported by checkpatch
      staging: vc04_services: bcm2835-camera: Compress two lines into one line
      staging: rtl8723bs: core: Use !x in place of NULL comparison.
      staging: rtl8723bs: core: Prefer using the BIT Macro.
      staging: fieldbus: anybus-s: fix wait_for_completion_timeout return handling
      staging: kpc2000: fix up build problems with readq()
      staging: rtlwifi: move remaining phydm .h files
      staging: rtlwifi: strip down phydm .h files
      staging: rtlwifi: delete the staging driver
      staging: fieldbus: anybus-s: rename bus id field to avoid confusion
      staging: fieldbus: anybus-s: keep device bus id in bus endianness
      Staging: sm750fb: Change *array into *const array
      staging: rtl8192u: ieee80211: Fix spelling mistake
      staging: rtl8192u: ieee80211: Replace bit shifting with BIT macro
      ...

commit fb24ea52f78e0d595852e09e3a55697c8f442189
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Feb 22 17:14:59 2019 +0000

    drivers: Remove explicit invocations of mmiowb()
    
    mmiowb() is now implied by spin_unlock() on architectures that require
    it, so there is no reason to call it from driver code. This patch was
    generated using coccinelle:
    
            @mmiowb@
            @@
            - mmiowb();
    
    and invoked as:
    
    $ for d in drivers include/linux/qed sound; do \
    spatch --include-headers --sp-file mmiowb.cocci --dir $d --in-place; done
    
    NOTE: mmiowb() has only ever guaranteed ordering in conjunction with
    spin_unlock(). However, pairing each mmiowb() removal in this patch with
    the corresponding call to spin_unlock() is not at all trivial, so there
    is a small chance that this change may regress any drivers incorrectly
    relying on mmiowb() to order MMIO writes between CPUs using lock-free
    synchronisation. If you've ended up bisecting to this commit, you can
    reintroduce the mmiowb() calls using wmb() instead, which should restore
    the old behaviour on all architectures other than some esoteric ia64
    systems.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b04dad8c7092..668f2aa16baa 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -547,7 +547,6 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 			reg);
 		break;
 	}
-	mmiowb();
 	spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
 }
 

commit 557e36194ed4052a8767e356784027b545c8a311
Author: Sanjana Sanikommu <sanjana99reddy99@gmail.com>
Date:   Sun Mar 31 16:17:30 2019 +0530

    staging: comedi: Prefer using BIT macro in various files.
    
    Challenge suggested by coccinelle.
    
    Replace bit shifting on 1 with the BIT(x) macro.
    Coccinelle script:
    
    @@
    constant c;
    @@
    
    -(1 << c)
    +BIT(c)
    
    Signed-off-by: Sanjana Sanikommu <sanjana99reddy99@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a9616f136c61..248950cf6d41 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4800,7 +4800,7 @@ static int cs5529_do_conversion(struct comedi_device *dev,
 	if (data) {
 		*data = ni_ao_win_inw(dev, NI67XX_CAL_DATA_REG);
 		/* cs5529 returns 16 bit signed data in bipolar mode */
-		*data ^= (1 << 15);
+		*data ^= BIT(15);
 	}
 	return 0;
 }
@@ -6209,7 +6209,7 @@ static int ni_E_init(struct comedi_device *dev,
 		s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_INTERNAL;
 		/*  one channel for each analog output channel */
 		s->n_chan = board->n_aochan;
-		s->maxdata = (1 << 16) - 1;
+		s->maxdata = BIT(16) - 1;
 		s->range_table = &range_unknown;	/* XXX */
 		s->insn_read = cs5529_ai_insn_read;
 		s->insn_config = NULL;

commit b397f82585c3101dcf92642dd359891e66d00c55
Merge: b60080197af4 79a3aaa7b82e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Apr 1 07:49:24 2019 +0200

    Merge 5.1-rc3 into staging-next
    
    We want those fixes and this resolves an erofs merge conflict.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 83cdfc17a907905fa790f8afe89196d8ee960682
Author: Arash Fotouhi <arash@arashfotouhi.com>
Date:   Thu Mar 21 12:18:12 2019 -0700

    Staging: comedi: ni_mio_common.c: Added blank line after declarations
    
    Added blank line after declarations.
    
    Signed-off-by: Arash Fotouhi <arash@arashfotouhi.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5eef1a63e3eb..8100460d0aff 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2110,6 +2110,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		unsigned int tmp = cmd->scan_begin_arg;
+
 		cmd->scan_begin_arg =
 		    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
 						       cmd->scan_begin_arg,
@@ -2120,6 +2121,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->convert_src == TRIG_TIMER) {
 		if (!devpriv->is_611x && !devpriv->is_6143) {
 			unsigned int tmp = cmd->convert_arg;
+
 			cmd->convert_arg =
 			    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
 							       cmd->convert_arg,

commit 49634aa7d9e65c8973745544ceb0b854e24c08e2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 19 16:54:44 2019 +0000

    staging: comedi: ni_mio_common: use insn->n in ni_m_series_eeprom_insn_read()
    
    The `insn_read` handler for the EEPROM subdevice on M-series boards
    (`ni_m_series_eeprom_insn_read()`) currently ignores `insn->n` (the
    number of samples to read) and assumes a single sample is to be read
    into `data[0]`.  Fortunately, the Comedi core ensures that `data[]` has
    a length of at least 16 so there is no problem with array bounds.
    
    The usual Comedi convention for `insn_read` handlers is to read the same
    channel `insn->n` times into successive elements of `data[]` so let's do
    that.  (Each channel corresponds to a single EEPROM address.)  In this
    case, the data value comes from a local copy of the EEPROM contents.
    
    Also, follow the usual Comedi convention and return `insn->n` from the
    handler to indicate success (although any non-negative value will do).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5b397ad2a604..5eef1a63e3eb 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4524,10 +4524,12 @@ static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
 					unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
+	unsigned int i;
 
-	data[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];
+	for (i = 0; i < insn->n; i++)
+		data[i] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];
 
-	return 1;
+	return insn->n;
 }
 
 static unsigned int ni_old_get_pfi_routing(struct comedi_device *dev,

commit 018768ccc7dc582519b84df593dd8ff1fbd02b55
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 19 16:54:43 2019 +0000

    staging: comedi: ni_mio_common: use insn->n in ni_eeprom_insn_read()
    
    The `insn_read` handler for the EEPROM subdevice on E-series boards
    (`ni_eeprom_insn_read()`) currently ignores `insn->n` (the number of
    samples to read) and assumes a single sample is to be read into
    `data[0]`.  Fortunately, the Comedi core ensures that `data[]` has a
    length of at least 16 so there is no problem with array bounds.
    
    The usual Comedi convention for `insn_read` handlers is to read the same
    channel `insn->n` times into successive elements of `data[]` so let's do
    that.  (Each channel number corresponds to a single EEPROM address.)
    Since we do not expect the EEPROM data at a particular address to change
    between readings, let's just read it once and copy the value `insn->n`
    times.
    
    Also, follow the usual Comedi convention and return `insn->n` from the
    handler to indicate success (although any non-negative value will do).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e008095436d7..5b397ad2a604 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4507,9 +4507,15 @@ static int ni_eeprom_insn_read(struct comedi_device *dev,
 			       struct comedi_insn *insn,
 			       unsigned int *data)
 {
-	data[0] = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));
+	unsigned int val;
+	unsigned int i;
 
-	return 1;
+	if (insn->n) {
+		val = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));
+		for (i = 0; i < insn->n; i++)
+			data[i] = val;
+	}
+	return insn->n;
 }
 
 static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,

commit 776d25ff5b494be280caba9d297477270462e580
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 19 16:54:42 2019 +0000

    staging: comedi: ni_mio_common: use insn->n in ni_calib_insn_read()
    
    The `insn_read` handler for the calibration subdevice
    (`ni_calib_insn_read()`) currently ignores `insn->n` (the number of
    samples to read) and assumes a single sample is to be read into
    `data[0]`.  Fortunately, the Comedi core ensures that `data[]` has a
    length of at least 16, so there is no problem with array bounds.
    
    The usual Comedi convention for `insn_read` handlers is to read the same
    channel `insn->n` times into successive elements of `data[]`, so let's
    do that.
    
    Also, follow the usual Comedi convention and return `insn->n` from the
    handler to indicate success (although any non-negative value will do).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 613b6b2abf7d..e008095436d7 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4409,10 +4409,12 @@ static int ni_calib_insn_read(struct comedi_device *dev,
 			      unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
+	unsigned int i;
 
-	data[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];
+	for (i = 0; i < insn->n; i++)
+		data[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];
 
-	return 1;
+	return insn->n;
 }
 
 static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)

commit fe57d1e113fcaf6af600c4d10168513c05230160
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 19 16:54:41 2019 +0000

    staging: comedi: ni_mio_common: Use insn->n in ni_calib_insn_write()
    
    The `insn_write` handler for the calibration subdevice
    (`ni_calib_insn_write()`) currently ignores `insn->n` (the number of
    samples to write) and assumes a single sample is to be written, but
    `insn->n` could be 0, meaning no samples should be written, in which
    case `data[0]` is invalid.
    
    Change `ni_calib_insn_write()` to only write to the calibration device
    if `insn->n > 0`.  There isn't much point writing all the values when
    `insn->n > 1`, so just write the last one (`data[insn->n - 1]`).
    
    Also follow the usual Comedi convention and return `insn->n` from the
    handler to indicate success (although any non-negative return value will
    do as far as the Comedi core is concerned).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5edf59ac6706..613b6b2abf7d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4394,9 +4394,13 @@ static int ni_calib_insn_write(struct comedi_device *dev,
 			       struct comedi_insn *insn,
 			       unsigned int *data)
 {
-	ni_write_caldac(dev, CR_CHAN(insn->chanspec), data[0]);
+	if (insn->n) {
+		/* only bother writing the last sample to the channel */
+		ni_write_caldac(dev, CR_CHAN(insn->chanspec),
+				data[insn->n - 1]);
+	}
 
-	return 1;
+	return insn->n;
 }
 
 static int ni_calib_insn_read(struct comedi_device *dev,

commit bafd9c64056cd034a1174dcadb65cd3b294ff8f6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 4 14:33:54 2019 +0000

    staging: comedi: ni_mio_common: Fix divide-by-zero for DIO cmdtest
    
    `ni_cdio_cmdtest()` validates Comedi asynchronous commands for the DIO
    subdevice (subdevice 2) of supported National Instruments M-series
    cards.  It is called when handling the `COMEDI_CMD` and `COMEDI_CMDTEST`
    ioctls for this subdevice.  There are two causes for a possible
    divide-by-zero error when validating that the `stop_arg` member of the
    passed-in command is not too large.
    
    The first cause for the divide-by-zero is that calls to
    `comedi_bytes_per_scan()` are only valid once the command has been
    copied to `s->async->cmd`, but that copy is only done for the
    `COMEDI_CMD` ioctl.  For the `COMEDI_CMDTEST` ioctl, it will use
    whatever was left there by the previous `COMEDI_CMD` ioctl, if any.
    (This is very likely, as it is usual for the application to use
    `COMEDI_CMDTEST` before `COMEDI_CMD`.) If there has been no previous,
    valid `COMEDI_CMD` for this subdevice, then `comedi_bytes_per_scan()`
    will return 0, so the subsequent division in `ni_cdio_cmdtest()` of
    `s->async->prealloc_bufsz / comedi_bytes_per_scan(s)` will be a
    divide-by-zero error.  To fix this error, call a new function
    `comedi_bytes_per_scan_cmd(s, cmd)`, based on the existing
    `comedi_bytes_per_scan(s)` but using a specified `struct comedi_cmd` for
    its calculations.  (Also refactor `comedi_bytes_per_scan()` to call the
    new function.)
    
    Once the first cause for the divide-by-zero has been fixed, the second
    cause is that `comedi_bytes_per_scan_cmd()` can legitimately return 0 if
    the `scan_end_arg` member of the `struct comedi_cmd` being tested is 0.
    Fix it by only performing the division (and validating that `stop_arg`
    is no more than the maximum value) if `comedi_bytes_per_scan_cmd()`
    returns a non-zero value.
    
    The problem was reported on the COMEDI mailing list here:
    https://groups.google.com/forum/#!topic/comedi_list/4t9WlHzMhKM
    
    Reported-by: Ivan Vasilyev <grabesstimme@gmail.com>
    Tested-by: Ivan Vasilyev <grabesstimme@gmail.com>
    Fixes: f164cbf98fa8 ("staging: comedi: ni_mio_common: add finite regeneration to dio output")
    Cc: <stable@vger.kernel.org> # 4.6+
    Cc: Spencer E. Olson <olsonse@umich.edu>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5edf59ac6706..b04dad8c7092 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3545,6 +3545,7 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	struct ni_private *devpriv = dev->private;
+	unsigned int bytes_per_scan;
 	int err = 0;
 
 	/* Step 1 : check if triggers are trivially valid */
@@ -3579,9 +3580,12 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
 					   cmd->chanlist_len);
-	err |= comedi_check_trigger_arg_max(&cmd->stop_arg,
-					    s->async->prealloc_bufsz /
-					    comedi_bytes_per_scan(s));
+	bytes_per_scan = comedi_bytes_per_scan_cmd(s, cmd);
+	if (bytes_per_scan) {
+		err |= comedi_check_trigger_arg_max(&cmd->stop_arg,
+						    s->async->prealloc_bufsz /
+						    bytes_per_scan);
+	}
 
 	if (err)
 		return 3;

commit 9a1ec4eb6f3722a65a267bb7d14c371d73f66c5b
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Oct 24 08:46:59 2018 -0600

    staging: comedi: ni_mio_common: scale ao INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS
    
    Fixes implementation of INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS for
    ni_mio devices.  The previous patch should have used the channel
    information passed in to scale the result by the number of channels being
    used.
    
    Fixes: 51fd36738383 ("staging: comedi: ni_mio_common: implement INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS")
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2d1e0325d04d..5edf59ac6706 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2843,7 +2843,8 @@ static int ni_ao_insn_config(struct comedi_device *dev,
 		return ni_ao_arm(dev, s);
 	case INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS:
 		/* we don't care about actual channels */
-		data[1] = board->ao_speed;
+		/* data[3] : chanlist_len */
+		data[1] = board->ao_speed * data[3];
 		data[2] = 0;
 		return 0;
 	default:

commit 713ebc593978e67d9e6d708f34fa6c66470be536
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Oct 3 14:56:09 2018 -0600

    staging: comedi: ni_mio_common: create device-global access to tio
    
    Adds tio sub-devices of ni_mio_common supported hardware to the
    implementation of test_route, connect_route, disconnect_route.  This change
    delegates the actual functionality to the ni_tio module.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index addea2446197..2d1e0325d04d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5644,6 +5644,8 @@ static int get_output_select_source(int dest, struct comedi_device *dev)
 			/* there are only two g_out outputs. */
 			return -EINVAL;
 		reg = ni_get_gout_routing(dest, dev);
+	} else if (channel_is_ctr(dest)) {
+		reg = ni_tio_get_routing(devpriv->counter_dev, dest);
 	} else {
 		dev_dbg(dev->class_dev, "%s: unhandled destination (%d) queried\n",
 			__func__, dest);
@@ -5732,6 +5734,13 @@ static int connect_route(unsigned int src, unsigned int dest,
 			return -EINVAL;
 		if (ni_set_gout_routing(src, dest, dev))
 			return -EINVAL;
+	} else if (channel_is_ctr(dest)) {
+		/*
+		 * we are adding back the channel modifier info to set
+		 * invert/edge info passed by the user
+		 */
+		ni_tio_set_routing(devpriv->counter_dev, dest,
+				   reg | (src & ~CR_CHAN(-1)));
 	} else {
 		return -EINVAL;
 	}
@@ -5790,6 +5799,8 @@ static int disconnect_route(unsigned int src, unsigned int dest,
 			/* there are only two g_out outputs. */
 			return -EINVAL;
 		reg = ni_disable_gout_routing(dest, dev);
+	} else if (channel_is_ctr(dest)) {
+		ni_tio_unset_routing(devpriv->counter_dev, dest);
 	} else {
 		return -EINVAL;
 	}

commit 347e244884c3be1f5bce1d93730f0c32efabba99
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Oct 3 14:56:08 2018 -0600

    staging: comedi: tio: implement global tio/ctr routing
    
    Adds ability to use device-global names in command args, in particular
    cmd->start_arg (for NI_CtrArmStartTrigger), and cmd->scan_begin_arg or
    cmd->convert_arg (either is used to specify NI_CtrGate, with preference
    given to cmd->scan_begin_arg, if it is set).
    
    The actual arguments of cmd->start_arg are not fully checked against known
    register values for the particular devices because these are not documented
    or currently known.  This follows the precedence of prior versions of the
    tio driver.  Should these become known, they should be annotated in the
    route_values tables and the set of lines in ni_tio_cmdtest should be
    uncommented to allow the tests to be made.
    
    This patch also adds interface functions that allow routes for particular
    counter route destinations to be made/queried/unmade.  This allows overseer
    modules to implement test_route, connect_route, and disconnect_route.  As a
    part of these changes, various functions were cleaned up and clarified.
    
    These new interface functions allow direct writing/reading of register
    values.  This is an example of exactly what the new device-global access
    was intended to solve:  the old interface was not consistent with other
    portions of the ni_* drivers--it did not allow full register values to be
    given for various MUXes.  Instead, the old interface _did_ abstract away
    some of the actual hardware from the underlying devices, but it was not
    consistent with any other NI hardware.  Allowing the device-global
    identifiers to be used, the new patch provides for consistency across all
    ni_* drivers.  One final note:  these changes provide for backwards
    compatibility by allowing the older values to still be used in through the
    pre-existing kernel interfaces--though not in the new device-global
    test/dis/connect/route interfaces.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d0c403a9a226..addea2446197 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -6213,7 +6213,9 @@ static int ni_E_init(struct comedi_device *dev,
 					(devpriv->is_m_series)
 						? ni_gpct_variant_m_series
 						: ni_gpct_variant_e_series,
-					NUM_GPCT);
+					NUM_GPCT,
+					NUM_GPCT,
+					&devpriv->routing_tables);
 	if (!devpriv->counter_dev)
 		return -ENOMEM;
 
@@ -6222,8 +6224,6 @@ static int ni_E_init(struct comedi_device *dev,
 		struct ni_gpct *gpct = &devpriv->counter_dev->counters[i];
 
 		/* setup and initialize the counter */
-		gpct->chip_index = 0;
-		gpct->counter_index = i;
 		ni_tio_init_counter(gpct);
 
 		s = &dev->subdevices[NI_GPCT_SUBDEV(i)];

commit 02d1c6e827073ebb65d9f92c169c024ae2d20ddc
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Oct 3 14:56:07 2018 -0600

    staging: comedi: ni_mio_common: implement output selection of GPFO_{0, 1}
    
    Implement the ability to route various signals to NI_CtrOut(x) pin.  This
    pin is also known as GPFO_{0,1} in the DAQ STC.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d4c0fd07059b..d0c403a9a226 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5532,6 +5532,77 @@ static void ni_rtsi_init(struct comedi_device *dev)
 	set_rgout0_reg(0, dev);
 }
 
+/* Get route of GPFO_i/CtrOut pins */
+static inline int ni_get_gout_routing(unsigned int dest,
+				      struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	unsigned int reg = devpriv->an_trig_etc_reg;
+
+	switch (dest) {
+	case 0:
+		if (reg & NISTC_ATRIG_ETC_GPFO_0_ENA)
+			return NISTC_ATRIG_ETC_GPFO_0_SEL_TO_SRC(reg);
+		break;
+	case 1:
+		if (reg & NISTC_ATRIG_ETC_GPFO_1_ENA)
+			return NISTC_ATRIG_ETC_GPFO_1_SEL_TO_SRC(reg);
+		break;
+	}
+
+	return -EINVAL;
+}
+
+/* Set route of GPFO_i/CtrOut pins */
+static inline int ni_disable_gout_routing(unsigned int dest,
+					  struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+
+	switch (dest) {
+	case 0:
+		devpriv->an_trig_etc_reg &= ~NISTC_ATRIG_ETC_GPFO_0_ENA;
+		break;
+	case 1:
+		devpriv->an_trig_etc_reg &= ~NISTC_ATRIG_ETC_GPFO_1_ENA;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ni_stc_writew(dev, devpriv->an_trig_etc_reg, NISTC_ATRIG_ETC_REG);
+	return 0;
+}
+
+/* Set route of GPFO_i/CtrOut pins */
+static inline int ni_set_gout_routing(unsigned int src, unsigned int dest,
+				      struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+
+	switch (dest) {
+	case 0:
+		/* clear reg */
+		devpriv->an_trig_etc_reg &= ~NISTC_ATRIG_ETC_GPFO_0_SEL(-1);
+		/* set reg */
+		devpriv->an_trig_etc_reg |= NISTC_ATRIG_ETC_GPFO_0_ENA
+					 |  NISTC_ATRIG_ETC_GPFO_0_SEL(src);
+		break;
+	case 1:
+		/* clear reg */
+		devpriv->an_trig_etc_reg &= ~NISTC_ATRIG_ETC_GPFO_1_SEL;
+		src = src ? NISTC_ATRIG_ETC_GPFO_1_SEL : 0;
+		/* set reg */
+		devpriv->an_trig_etc_reg |= NISTC_ATRIG_ETC_GPFO_1_ENA | src;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ni_stc_writew(dev, devpriv->an_trig_etc_reg, NISTC_ATRIG_ETC_REG);
+	return 0;
+}
+
 /*
  * Retrieves the current source of the output selector for the given
  * destination.  If the terminal for the destination is not already configured
@@ -5563,6 +5634,16 @@ static int get_output_select_source(int dest, struct comedi_device *dev)
 				reg = get_ith_rtsi_brd_reg(i, dev);
 			}
 		}
+	} else if (dest >= NI_CtrOut(0) && dest <= NI_CtrOut(-1)) {
+		/*
+		 * not handled by ni_tio.  Only available for GPFO registers in
+		 * e/m series.
+		 */
+		dest -= NI_CtrOut(0);
+		if (dest > 1)
+			/* there are only two g_out outputs. */
+			return -EINVAL;
+		reg = ni_get_gout_routing(dest, dev);
 	} else {
 		dev_dbg(dev->class_dev, "%s: unhandled destination (%d) queried\n",
 			__func__, dest);
@@ -5640,6 +5721,17 @@ static int connect_route(unsigned int src, unsigned int dest,
 
 		ni_set_rtsi_direction(dev, dest, COMEDI_OUTPUT);
 		ni_set_rtsi_routing(dev, dest, reg);
+	} else if (dest >= NI_CtrOut(0) && dest <= NI_CtrOut(-1)) {
+		/*
+		 * not handled by ni_tio.  Only available for GPFO registers in
+		 * e/m series.
+		 */
+		dest -= NI_CtrOut(0);
+		if (dest > 1)
+			/* there are only two g_out outputs. */
+			return -EINVAL;
+		if (ni_set_gout_routing(src, dest, dev))
+			return -EINVAL;
 	} else {
 		return -EINVAL;
 	}
@@ -5688,6 +5780,16 @@ static int disconnect_route(unsigned int src, unsigned int dest,
 		reg = default_rtsi_routing[dest - TRIGGER_LINE(0)];
 		ni_set_rtsi_direction(dev, dest, COMEDI_INPUT);
 		ni_set_rtsi_routing(dev, dest, reg);
+	} else if (dest >= NI_CtrOut(0) && dest <= NI_CtrOut(-1)) {
+		/*
+		 * not handled by ni_tio.  Only available for GPFO registers in
+		 * e/m series.
+		 */
+		dest -= NI_CtrOut(0);
+		if (dest > 1)
+			/* there are only two g_out outputs. */
+			return -EINVAL;
+		reg = ni_disable_gout_routing(dest, dev);
 	} else {
 		return -EINVAL;
 	}
@@ -6147,6 +6249,10 @@ static int ni_E_init(struct comedi_device *dev,
 		s->private	= gpct;
 	}
 
+	/* Initialize GPFO_{0,1} to produce output of counters */
+	ni_set_gout_routing(0, 0, dev); /* output of counter 0; DAQ STC, p338 */
+	ni_set_gout_routing(0, 1, dev); /* output of counter 1; DAQ STC, p338 */
+
 	/* Frequency output subdevice */
 	s = &dev->subdevices[NI_FREQ_OUT_SUBDEV];
 	s->type		= COMEDI_SUBD_COUNTER;

commit d4961bb3d99f895fe8cf368b9765405a3f829198
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Oct 3 14:56:06 2018 -0600

    staging: comedi: ni_mio_common: implement global pfi, rtsi routing
    
    Implement device-global config interface for ni_mio devices.  In
    particular, this patch implements:
    INSN_DEVICE_CONFIG_TEST_ROUTE,
    INSN_DEVICE_CONFIG_CONNECT_ROUTE,
    INSN_DEVICE_CONFIG_DISCONNECT_ROUTE,
    INSN_DEVICE_CONFIG_GET_ROUTES
    for the ni mio devices.  This means that the new abstracted signal/terminal
    names can be used to define signal routing with regards to the PFI
    terminals and RTSI trigger bus lines.
    
    This also adds ability to identify PFI and RTSI channels on the PFI and
    RTSI subdevices using the new device-global names.  This does not change
    the values that are set for channel output selections using the subdevice
    interfaces--these still require direct register values.
    
    Annotates and updates tables of register values to reflect this new
    implementation status.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 31a567d593c9..d4c0fd07059b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -351,7 +351,8 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AO_PERSONAL_REG]		= { 0x19c, 2 },
 	[NISTC_RTSI_TRIGA_OUT_REG]	= { 0x19e, 2 },
 	[NISTC_RTSI_TRIGB_OUT_REG]	= { 0x1a0, 2 },
-	[NISTC_RTSI_BOARD_REG]		= { 0, 0 }, /* Unknown */
+	/* doc for following line: mhddk/nimseries/ChipObjects/tMSeries.h */
+	[NISTC_RTSI_BOARD_REG]		= { 0x1a2, 2 },
 	[NISTC_CFG_MEM_CLR_REG]		= { 0x1a4, 2 },
 	[NISTC_ADC_FIFO_CLR_REG]	= { 0x1a6, 2 },
 	[NISTC_DAC_FIFO_CLR_REG]	= { 0x1a8, 2 },
@@ -4590,24 +4591,33 @@ static unsigned int ni_get_pfi_routing(struct comedi_device *dev,
 {
 	struct ni_private *devpriv = dev->private;
 
+	if (chan >= NI_PFI(0)) {
+		/* allow new and old names of pfi channels to work. */
+		chan -= NI_PFI(0);
+	}
 	return (devpriv->is_m_series)
 			? ni_m_series_get_pfi_routing(dev, chan)
 			: ni_old_get_pfi_routing(dev, chan);
 }
 
+/* Sets the output mux for the specified PFI channel. */
 static int ni_set_pfi_routing(struct comedi_device *dev,
 			      unsigned int chan, unsigned int source)
 {
 	struct ni_private *devpriv = dev->private;
 
+	if (chan >= NI_PFI(0)) {
+		/* allow new and old names of pfi channels to work. */
+		chan -= NI_PFI(0);
+	}
 	return (devpriv->is_m_series)
 			? ni_m_series_set_pfi_routing(dev, chan, source)
 			: ni_old_set_pfi_routing(dev, chan, source);
 }
 
-static int ni_config_filter(struct comedi_device *dev,
-			    unsigned int pfi_channel,
-			    enum ni_pfi_filter_select filter)
+static int ni_config_pfi_filter(struct comedi_device *dev,
+				unsigned int chan,
+				enum ni_pfi_filter_select filter)
 {
 	struct ni_private *devpriv = dev->private;
 	unsigned int bits;
@@ -4615,19 +4625,46 @@ static int ni_config_filter(struct comedi_device *dev,
 	if (!devpriv->is_m_series)
 		return -ENOTSUPP;
 
+	if (chan >= NI_PFI(0)) {
+		/* allow new and old names of pfi channels to work. */
+		chan -= NI_PFI(0);
+	}
+
 	bits = ni_readl(dev, NI_M_PFI_FILTER_REG);
-	bits &= ~NI_M_PFI_FILTER_SEL_MASK(pfi_channel);
-	bits |= NI_M_PFI_FILTER_SEL(pfi_channel, filter);
+	bits &= ~NI_M_PFI_FILTER_SEL_MASK(chan);
+	bits |= NI_M_PFI_FILTER_SEL(chan, filter);
 	ni_writel(dev, bits, NI_M_PFI_FILTER_REG);
 	return 0;
 }
 
+static void ni_set_pfi_direction(struct comedi_device *dev, int chan,
+				 unsigned int direction)
+{
+	if (chan >= NI_PFI(0)) {
+		/* allow new and old names of pfi channels to work. */
+		chan -= NI_PFI(0);
+	}
+	direction = (direction == COMEDI_OUTPUT) ? 1u : 0u;
+	ni_set_bits(dev, NISTC_IO_BIDIR_PIN_REG, 1 << chan, direction);
+}
+
+static int ni_get_pfi_direction(struct comedi_device *dev, int chan)
+{
+	struct ni_private *devpriv = dev->private;
+
+	if (chan >= NI_PFI(0)) {
+		/* allow new and old names of pfi channels to work. */
+		chan -= NI_PFI(0);
+	}
+	return devpriv->io_bidirection_pin_reg & (1 << chan) ?
+	       COMEDI_OUTPUT : COMEDI_INPUT;
+}
+
 static int ni_pfi_insn_config(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn,
 			      unsigned int *data)
 {
-	struct ni_private *devpriv = dev->private;
 	unsigned int chan;
 
 	if (insn->n < 1)
@@ -4637,23 +4674,19 @@ static int ni_pfi_insn_config(struct comedi_device *dev,
 
 	switch (data[0]) {
 	case COMEDI_OUTPUT:
-		ni_set_bits(dev, NISTC_IO_BIDIR_PIN_REG, 1 << chan, 1);
-		break;
 	case COMEDI_INPUT:
-		ni_set_bits(dev, NISTC_IO_BIDIR_PIN_REG, 1 << chan, 0);
+		ni_set_pfi_direction(dev, chan, data[0]);
 		break;
 	case INSN_CONFIG_DIO_QUERY:
-		data[1] =
-		    (devpriv->io_bidirection_pin_reg & (1 << chan)) ?
-		    COMEDI_OUTPUT : COMEDI_INPUT;
-		return 0;
+		data[1] = ni_get_pfi_direction(dev, chan);
+		break;
 	case INSN_CONFIG_SET_ROUTING:
 		return ni_set_pfi_routing(dev, chan, data[1]);
 	case INSN_CONFIG_GET_ROUTING:
 		data[1] = ni_get_pfi_routing(dev, chan);
 		break;
 	case INSN_CONFIG_FILTER:
-		return ni_config_filter(dev, chan, data[1]);
+		return ni_config_pfi_filter(dev, chan, data[1]);
 	default:
 		return -EINVAL;
 	}
@@ -5036,6 +5069,10 @@ static int ni_set_rtsi_routing(struct comedi_device *dev,
 {
 	struct ni_private *devpriv = dev->private;
 
+	if (chan >= TRIGGER_LINE(0))
+		/* allow new and old names of rtsi channels to work. */
+		chan -= TRIGGER_LINE(0);
+
 	if (ni_valid_rtsi_output_source(dev, chan, src) == 0)
 		return -EINVAL;
 	if (chan < 4) {
@@ -5064,6 +5101,10 @@ static unsigned int ni_get_rtsi_routing(struct comedi_device *dev,
 {
 	struct ni_private *devpriv = dev->private;
 
+	if (chan >= TRIGGER_LINE(0))
+		/* allow new and old names of rtsi channels to work. */
+		chan -= TRIGGER_LINE(0);
+
 	if (chan < 4) {
 		return NISTC_RTSI_TRIG_TO_SRC(chan,
 					      devpriv->rtsi_trig_a_output_reg);
@@ -5078,17 +5119,17 @@ static unsigned int ni_get_rtsi_routing(struct comedi_device *dev,
 	return -EINVAL;
 }
 
-static int ni_rtsi_insn_config(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn,
-			       unsigned int *data)
+static void ni_set_rtsi_direction(struct comedi_device *dev, int chan,
+				  unsigned int direction)
 {
 	struct ni_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int max_chan = NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series);
 
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_OUTPUT:
+	if (chan >= TRIGGER_LINE(0))
+		/* allow new and old names of rtsi channels to work. */
+		chan -= TRIGGER_LINE(0);
+
+	if (direction == COMEDI_OUTPUT) {
 		if (chan < max_chan) {
 			devpriv->rtsi_trig_direction_reg |=
 			    NISTC_RTSI_TRIG_DIR(chan, devpriv->is_m_series);
@@ -5096,10 +5137,7 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 			devpriv->rtsi_trig_direction_reg |=
 			    NISTC_RTSI_TRIG_DRV_CLK;
 		}
-		ni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-			      NISTC_RTSI_TRIG_DIR_REG);
-		break;
-	case INSN_CONFIG_DIO_INPUT:
+	} else {
 		if (chan < max_chan) {
 			devpriv->rtsi_trig_direction_reg &=
 			    ~NISTC_RTSI_TRIG_DIR(chan, devpriv->is_m_series);
@@ -5107,23 +5145,53 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 			devpriv->rtsi_trig_direction_reg &=
 			    ~NISTC_RTSI_TRIG_DRV_CLK;
 		}
-		ni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-			      NISTC_RTSI_TRIG_DIR_REG);
+	}
+	ni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+		      NISTC_RTSI_TRIG_DIR_REG);
+}
+
+static int ni_get_rtsi_direction(struct comedi_device *dev, int chan)
+{
+	struct ni_private *devpriv = dev->private;
+	unsigned int max_chan = NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series);
+
+	if (chan >= TRIGGER_LINE(0))
+		/* allow new and old names of rtsi channels to work. */
+		chan -= TRIGGER_LINE(0);
+
+	if (chan < max_chan) {
+		return (devpriv->rtsi_trig_direction_reg &
+			NISTC_RTSI_TRIG_DIR(chan, devpriv->is_m_series))
+			   ? COMEDI_OUTPUT : COMEDI_INPUT;
+	} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {
+		return (devpriv->rtsi_trig_direction_reg &
+			NISTC_RTSI_TRIG_DRV_CLK)
+			   ? COMEDI_OUTPUT : COMEDI_INPUT;
+	}
+	return -EINVAL;
+}
+
+static int ni_rtsi_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
+{
+	struct ni_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+
+	switch (data[0]) {
+	case COMEDI_OUTPUT:
+	case COMEDI_INPUT:
+		ni_set_rtsi_direction(dev, chan, data[0]);
 		break;
-	case INSN_CONFIG_DIO_QUERY:
-		if (chan < max_chan) {
-			data[1] =
-			    (devpriv->rtsi_trig_direction_reg &
-			     NISTC_RTSI_TRIG_DIR(chan, devpriv->is_m_series))
-				? INSN_CONFIG_DIO_OUTPUT
-				: INSN_CONFIG_DIO_INPUT;
-		} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {
-			data[1] = (devpriv->rtsi_trig_direction_reg &
-				   NISTC_RTSI_TRIG_DRV_CLK)
-				  ? INSN_CONFIG_DIO_OUTPUT
-				  : INSN_CONFIG_DIO_INPUT;
-		}
+	case INSN_CONFIG_DIO_QUERY: {
+		int ret = ni_get_rtsi_direction(dev, chan);
+
+		if (ret < 0)
+			return ret;
+		data[1] = ret;
 		return 2;
+	}
 	case INSN_CONFIG_SET_CLOCK_SRC:
 		return ni_set_master_clock(dev, data[1], data[2]);
 	case INSN_CONFIG_GET_CLOCK_SRC:
@@ -5132,9 +5200,14 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 		return 3;
 	case INSN_CONFIG_SET_ROUTING:
 		return ni_set_rtsi_routing(dev, chan, data[1]);
-	case INSN_CONFIG_GET_ROUTING:
-		data[1] = ni_get_rtsi_routing(dev, chan);
+	case INSN_CONFIG_GET_ROUTING: {
+		int ret = ni_get_rtsi_routing(dev, chan);
+
+		if (ret < 0)
+			return ret;
+		data[1] = ret;
 		return 2;
+	}
 	default:
 		return -EINVAL;
 	}
@@ -5151,9 +5224,275 @@ static int ni_rtsi_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
+/*
+ * Default routing for RTSI trigger lines.
+ *
+ * These values are used here in the init function, as well as in the
+ * disconnect_route function, after a RTSI route has been disconnected.
+ */
+static const int default_rtsi_routing[] = {
+	[0] = NI_RTSI_OUTPUT_ADR_START1,
+	[1] = NI_RTSI_OUTPUT_ADR_START2,
+	[2] = NI_RTSI_OUTPUT_SCLKG,
+	[3] = NI_RTSI_OUTPUT_DACUPDN,
+	[4] = NI_RTSI_OUTPUT_DA_START1,
+	[5] = NI_RTSI_OUTPUT_G_SRC0,
+	[6] = NI_RTSI_OUTPUT_G_GATE0,
+	[7] = NI_RTSI_OUTPUT_RTSI_OSC,
+};
+
+/*
+ * Route signals through RGOUT0 terminal.
+ * @reg: raw register value of RGOUT0 bits (only bit0 is important).
+ * @dev: comedi device handle.
+ */
+static void set_rgout0_reg(int reg, struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+
+	if (devpriv->is_m_series) {
+		devpriv->rtsi_trig_direction_reg &=
+			~NISTC_RTSI_TRIG_DIR_SUB_SEL1;
+		devpriv->rtsi_trig_direction_reg |=
+			(reg << NISTC_RTSI_TRIG_DIR_SUB_SEL1_SHIFT) &
+			NISTC_RTSI_TRIG_DIR_SUB_SEL1;
+		ni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+			      NISTC_RTSI_TRIG_DIR_REG);
+	} else {
+		devpriv->rtsi_trig_b_output_reg &= ~NISTC_RTSI_TRIGB_SUB_SEL1;
+		devpriv->rtsi_trig_b_output_reg |=
+			(reg << NISTC_RTSI_TRIGB_SUB_SEL1_SHIFT) &
+			NISTC_RTSI_TRIGB_SUB_SEL1;
+		ni_stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
+			      NISTC_RTSI_TRIGB_OUT_REG);
+	}
+}
+
+static int get_rgout0_reg(struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	int reg;
+
+	if (devpriv->is_m_series)
+		reg = (devpriv->rtsi_trig_direction_reg &
+		       NISTC_RTSI_TRIG_DIR_SUB_SEL1)
+		    >> NISTC_RTSI_TRIG_DIR_SUB_SEL1_SHIFT;
+	else
+		reg = (devpriv->rtsi_trig_b_output_reg &
+		       NISTC_RTSI_TRIGB_SUB_SEL1)
+		    >> NISTC_RTSI_TRIGB_SUB_SEL1_SHIFT;
+	return reg;
+}
+
+static inline int get_rgout0_src(struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	int reg = get_rgout0_reg(dev);
+
+	return ni_find_route_source(reg, NI_RGOUT0, &devpriv->routing_tables);
+}
+
+/*
+ * Route signals through RGOUT0 terminal and increment the RGOUT0 use for this
+ * particular route.
+ * @src: device-global signal name
+ * @dev: comedi device handle
+ *
+ * Return: -EINVAL if the source is not valid to route to RGOUT0;
+ *	   -EBUSY if the RGOUT0 is already used;
+ *	   0 if successful.
+ */
+static int incr_rgout0_src_use(int src, struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	s8 reg = ni_lookup_route_register(CR_CHAN(src), NI_RGOUT0,
+					  &devpriv->routing_tables);
+
+	if (reg < 0)
+		return -EINVAL;
+
+	if (devpriv->rgout0_usage > 0 && get_rgout0_reg(dev) != reg)
+		return -EBUSY;
+
+	++devpriv->rgout0_usage;
+	set_rgout0_reg(reg, dev);
+	return 0;
+}
+
+/*
+ * Unroute signals through RGOUT0 terminal and deccrement the RGOUT0 use for
+ * this particular source.  This function does not actually unroute anything
+ * with respect to RGOUT0.  It does, on the other hand, decrement the usage
+ * counter for the current src->RGOUT0 mapping.
+ *
+ * Return: -EINVAL if the source is not already routed to RGOUT0 (or usage is
+ *	already at zero); 0 if successful.
+ */
+static int decr_rgout0_src_use(int src, struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	s8 reg = ni_lookup_route_register(CR_CHAN(src), NI_RGOUT0,
+					  &devpriv->routing_tables);
+
+	if (devpriv->rgout0_usage > 0 && get_rgout0_reg(dev) == reg) {
+		--devpriv->rgout0_usage;
+		if (!devpriv->rgout0_usage)
+			set_rgout0_reg(0, dev); /* ok default? */
+		return 0;
+	}
+	return -EINVAL;
+}
+
+/*
+ * Route signals through given NI_RTSI_BRD mux.
+ * @i: index of mux to route
+ * @reg: raw register value of RTSI_BRD bits
+ * @dev: comedi device handle
+ */
+static void set_ith_rtsi_brd_reg(int i, int reg, struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	int reg_i_sz = 3; /* value for e-series */
+	int reg_i_mask;
+	int reg_i_shift;
+
+	if (devpriv->is_m_series)
+		reg_i_sz = 4;
+	reg_i_mask = ~((~0) << reg_i_sz);
+	reg_i_shift = i * reg_i_sz;
+
+	/* clear out the current reg_i for ith brd */
+	devpriv->rtsi_shared_mux_reg &= ~(reg_i_mask       << reg_i_shift);
+	/* (softcopy) write the new reg_i for ith brd */
+	devpriv->rtsi_shared_mux_reg |= (reg & reg_i_mask) << reg_i_shift;
+	/* (hardcopy) write the new reg_i for ith brd */
+	ni_stc_writew(dev, devpriv->rtsi_shared_mux_reg, NISTC_RTSI_BOARD_REG);
+}
+
+static int get_ith_rtsi_brd_reg(int i, struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	int reg_i_sz = 3; /* value for e-series */
+	int reg_i_mask;
+	int reg_i_shift;
+
+	if (devpriv->is_m_series)
+		reg_i_sz = 4;
+	reg_i_mask = ~((~0) << reg_i_sz);
+	reg_i_shift = i * reg_i_sz;
+
+	return (devpriv->rtsi_shared_mux_reg >> reg_i_shift) & reg_i_mask;
+}
+
+static inline int get_rtsi_brd_src(int brd, struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	int brd_index = brd;
+	int reg;
+
+	if (brd >= NI_RTSI_BRD(0))
+		brd_index = brd - NI_RTSI_BRD(0);
+	else
+		brd = NI_RTSI_BRD(brd);
+	/*
+	 * And now:
+	 * brd : device-global name
+	 * brd_index : index number of RTSI_BRD mux
+	 */
+
+	reg = get_ith_rtsi_brd_reg(brd_index, dev);
+
+	return ni_find_route_source(reg, brd, &devpriv->routing_tables);
+}
+
+/*
+ * Route signals through NI_RTSI_BRD mux and increment the use counter for this
+ * particular route.
+ *
+ * Return: -EINVAL if the source is not valid to route to NI_RTSI_BRD(i);
+ *	   -EBUSY if all NI_RTSI_BRD muxes are already used;
+ *	   NI_RTSI_BRD(i) of allocated ith mux if successful.
+ */
+static int incr_rtsi_brd_src_use(int src, struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	int first_available = -1;
+	int err = -EINVAL;
+	s8 reg;
+	int i;
+
+	/* first look for a mux that is already configured to provide src */
+	for (i = 0; i < NUM_RTSI_SHARED_MUXS; ++i) {
+		reg = ni_lookup_route_register(CR_CHAN(src), NI_RTSI_BRD(i),
+					       &devpriv->routing_tables);
+
+		if (reg < 0)
+			continue; /* invalid route */
+
+		if (!devpriv->rtsi_shared_mux_usage[i]) {
+			if (first_available < 0)
+				/* found the first unused, but usable mux */
+				first_available = i;
+		} else {
+			/*
+			 * we've seen at least one possible route, so change the
+			 * final error to -EBUSY in case there are no muxes
+			 * available.
+			 */
+			err = -EBUSY;
+
+			if (get_ith_rtsi_brd_reg(i, dev) == reg) {
+				/*
+				 * we've found a mux that is already being used
+				 * to provide the requested signal.  Reuse it.
+				 */
+				goto success;
+			}
+		}
+	}
+
+	if (first_available < 0)
+		return err;
+
+	/* we did not find a mux to reuse, but there is at least one usable */
+	i = first_available;
+
+success:
+	++devpriv->rtsi_shared_mux_usage[i];
+	set_ith_rtsi_brd_reg(i, reg, dev);
+	return NI_RTSI_BRD(i);
+}
+
+/*
+ * Unroute signals through NI_RTSI_BRD mux and decrement the user counter for
+ * this particular route.
+ *
+ * Return: -EINVAL if the source is not already routed to rtsi_brd(i) (or usage
+ *	is already at zero); 0 if successful.
+ */
+static int decr_rtsi_brd_src_use(int src, int rtsi_brd,
+				 struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	s8 reg = ni_lookup_route_register(CR_CHAN(src), rtsi_brd,
+					  &devpriv->routing_tables);
+	const int i = rtsi_brd - NI_RTSI_BRD(0);
+
+	if (devpriv->rtsi_shared_mux_usage[i] > 0 &&
+	    get_ith_rtsi_brd_reg(i, dev) == reg) {
+		--devpriv->rtsi_shared_mux_usage[i];
+		if (!devpriv->rtsi_shared_mux_usage[i])
+			set_ith_rtsi_brd_reg(i, 0, dev); /* ok default? */
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
 static void ni_rtsi_init(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
+	int i;
 
 	/*  Initialises the RTSI bus signal switch to a default state */
 
@@ -5166,28 +5505,215 @@ static void ni_rtsi_init(struct comedi_device *dev)
 	/*  Set clock mode to internal */
 	if (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0)
 		dev_err(dev->class_dev, "ni_set_master_clock failed, bug?\n");
-	/*  default internal lines routing to RTSI bus lines */
-	devpriv->rtsi_trig_a_output_reg =
-	    NISTC_RTSI_TRIG(0, NI_RTSI_OUTPUT_ADR_START1) |
-	    NISTC_RTSI_TRIG(1, NI_RTSI_OUTPUT_ADR_START2) |
-	    NISTC_RTSI_TRIG(2, NI_RTSI_OUTPUT_SCLKG) |
-	    NISTC_RTSI_TRIG(3, NI_RTSI_OUTPUT_DACUPDN);
-	ni_stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
-		      NISTC_RTSI_TRIGA_OUT_REG);
-	devpriv->rtsi_trig_b_output_reg =
-	    NISTC_RTSI_TRIG(4, NI_RTSI_OUTPUT_DA_START1) |
-	    NISTC_RTSI_TRIG(5, NI_RTSI_OUTPUT_G_SRC0) |
-	    NISTC_RTSI_TRIG(6, NI_RTSI_OUTPUT_G_GATE0);
-	if (devpriv->is_m_series)
-		devpriv->rtsi_trig_b_output_reg |=
-		    NISTC_RTSI_TRIG(7, NI_RTSI_OUTPUT_RTSI_OSC);
-	ni_stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
-		      NISTC_RTSI_TRIGB_OUT_REG);
+
+	/* default internal lines routing to RTSI bus lines */
+	for (i = 0; i < 8; ++i) {
+		ni_set_rtsi_direction(dev, i, COMEDI_INPUT);
+		ni_set_rtsi_routing(dev, i, default_rtsi_routing[i]);
+	}
 
 	/*
-	 * Sets the source and direction of the 4 on board lines
-	 * ni_stc_writew(dev, 0, NISTC_RTSI_BOARD_REG);
+	 * Sets the source and direction of the 4 on board lines.
+	 * This configures all board lines to be:
+	 * for e-series:
+	 *   1) inputs (not sure what "output" would mean)
+	 *   2) copying TRIGGER_LINE(0) (or RTSI0) output
+	 * for m-series:
+	 *   copying NI_PFI(0) output
 	 */
+	devpriv->rtsi_shared_mux_reg = 0;
+	for (i = 0; i < 4; ++i)
+		set_ith_rtsi_brd_reg(i, 0, dev);
+	memset(devpriv->rtsi_shared_mux_usage, 0,
+	       sizeof(devpriv->rtsi_shared_mux_usage));
+
+	/* initialize rgout0 pin as unused. */
+	devpriv->rgout0_usage = 0;
+	set_rgout0_reg(0, dev);
+}
+
+/*
+ * Retrieves the current source of the output selector for the given
+ * destination.  If the terminal for the destination is not already configured
+ * as an output, this function returns -EINVAL as error.
+ *
+ * Return: the register value of the destination output selector;
+ *	   -EINVAL if terminal is not configured for output.
+ */
+static int get_output_select_source(int dest, struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	int reg = -1;
+
+	if (channel_is_pfi(dest)) {
+		if (ni_get_pfi_direction(dev, dest) == COMEDI_OUTPUT)
+			reg = ni_get_pfi_routing(dev, dest);
+	} else if (channel_is_rtsi(dest)) {
+		if (ni_get_rtsi_direction(dev, dest) == COMEDI_OUTPUT) {
+			reg = ni_get_rtsi_routing(dev, dest);
+
+			if (reg == NI_RTSI_OUTPUT_RGOUT0) {
+				dest = NI_RGOUT0; /* prepare for lookup below */
+				reg = get_rgout0_reg(dev);
+			} else if (reg >= NI_RTSI_OUTPUT_RTSI_BRD(0) &&
+				   reg <= NI_RTSI_OUTPUT_RTSI_BRD(3)) {
+				const int i = reg - NI_RTSI_OUTPUT_RTSI_BRD(0);
+
+				dest = NI_RTSI_BRD(i); /* prepare for lookup */
+				reg = get_ith_rtsi_brd_reg(i, dev);
+			}
+		}
+	} else {
+		dev_dbg(dev->class_dev, "%s: unhandled destination (%d) queried\n",
+			__func__, dest);
+	}
+
+	if (reg >= 0)
+		return ni_find_route_source(CR_CHAN(reg), dest,
+					    &devpriv->routing_tables);
+	return -EINVAL;
+}
+
+/*
+ * Test a route:
+ *
+ * Return: -1 if not connectible;
+ *	    0 if connectible and not connected;
+ *	    1 if connectible and connected.
+ */
+static int test_route(unsigned int src, unsigned int dest,
+		      struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	s8 reg = ni_route_to_register(CR_CHAN(src), dest,
+				      &devpriv->routing_tables);
+
+	if (reg < 0)
+		return -1;
+	if (get_output_select_source(dest, dev) != CR_CHAN(src))
+		return 0;
+	return 1;
+}
+
+/* Connect the actual route.  */
+static int connect_route(unsigned int src, unsigned int dest,
+			 struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	s8 reg = ni_route_to_register(CR_CHAN(src), dest,
+				      &devpriv->routing_tables);
+	s8 current_src;
+
+	if (reg < 0)
+		/* route is not valid */
+		return -EINVAL;
+
+	current_src = get_output_select_source(dest, dev);
+	if (current_src == CR_CHAN(src))
+		return -EALREADY;
+	if (current_src >= 0)
+		/* destination mux is already busy. complain, don't overwrite */
+		return -EBUSY;
+
+	/* The route is valid and available. Now connect... */
+	if (channel_is_pfi(dest)) {
+		/* set routing source, then open output */
+		ni_set_pfi_routing(dev, dest, reg);
+		ni_set_pfi_direction(dev, dest, COMEDI_OUTPUT);
+	} else if (channel_is_rtsi(dest)) {
+		if (reg == NI_RTSI_OUTPUT_RGOUT0) {
+			int ret = incr_rgout0_src_use(src, dev);
+
+			if (ret < 0)
+				return ret;
+		} else if (ni_rtsi_route_requires_mux(reg)) {
+			/* Attempt to allocate and  route (src->brd) */
+			int brd = incr_rtsi_brd_src_use(src, dev);
+
+			if (brd < 0)
+				return brd;
+
+			/* Now lookup the register value for (brd->dest) */
+			reg = ni_lookup_route_register(
+				brd, dest, &devpriv->routing_tables);
+		}
+
+		ni_set_rtsi_direction(dev, dest, COMEDI_OUTPUT);
+		ni_set_rtsi_routing(dev, dest, reg);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int disconnect_route(unsigned int src, unsigned int dest,
+			    struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	s8 reg = ni_route_to_register(CR_CHAN(src), dest,
+				      &devpriv->routing_tables);
+
+	if (reg < 0)
+		/* route is not valid */
+		return -EINVAL;
+	if (get_output_select_source(dest, dev) != src)
+		/* cannot disconnect something not connected */
+		return -EINVAL;
+
+	/* The route is valid and is connected.  Now disconnect... */
+	if (channel_is_pfi(dest)) {
+		/* set the pfi to high impedance, and disconnect */
+		ni_set_pfi_direction(dev, dest, COMEDI_INPUT);
+		ni_set_pfi_routing(dev, dest, NI_PFI_OUTPUT_PFI_DEFAULT);
+	} else if (channel_is_rtsi(dest)) {
+		if (reg == NI_RTSI_OUTPUT_RGOUT0) {
+			int ret = decr_rgout0_src_use(src, dev);
+
+			if (ret < 0)
+				return ret;
+		} else if (ni_rtsi_route_requires_mux(reg)) {
+			/* find which RTSI_BRD line is source for rtsi pin */
+			int brd = ni_find_route_source(
+				ni_get_rtsi_routing(dev, dest), dest,
+				&devpriv->routing_tables);
+
+			if (brd < 0)
+				return brd;
+
+			/* decrement/disconnect RTSI_BRD line from source */
+			decr_rtsi_brd_src_use(src, brd, dev);
+		}
+
+		/* set rtsi output selector to default state */
+		reg = default_rtsi_routing[dest - TRIGGER_LINE(0)];
+		ni_set_rtsi_direction(dev, dest, COMEDI_INPUT);
+		ni_set_rtsi_routing(dev, dest, reg);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int ni_global_insn_config(struct comedi_device *dev,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
+{
+	switch (data[0]) {
+	case INSN_DEVICE_CONFIG_TEST_ROUTE:
+		data[0] = test_route(data[1], data[2], dev);
+		return 2;
+	case INSN_DEVICE_CONFIG_CONNECT_ROUTE:
+		return connect_route(data[1], data[2], dev);
+	case INSN_DEVICE_CONFIG_DISCONNECT_ROUTE:
+		return disconnect_route(data[1], data[2], dev);
+	/*
+	 * This case is already handled one level up.
+	 * case INSN_DEVICE_CONFIG_GET_ROUTES:
+	 */
+	default:
+		return -EINVAL;
+	}
+	return 1;
 }
 
 #ifdef PCIDMA
@@ -5293,6 +5819,16 @@ static int ni_alloc_private(struct comedi_device *dev)
 	return 0;
 }
 
+static unsigned int _ni_get_valid_routes(struct comedi_device *dev,
+					 unsigned int n_pairs,
+					 unsigned int *pair_data)
+{
+	struct ni_private *devpriv = dev->private;
+
+	return ni_get_valid_routes(&devpriv->routing_tables, n_pairs,
+				   pair_data);
+}
+
 static int ni_E_init(struct comedi_device *dev,
 		     unsigned int interrupt_pin, unsigned int irq_polarity)
 {
@@ -5304,6 +5840,22 @@ static int ni_E_init(struct comedi_device *dev,
 	const char *dev_family = devpriv->is_m_series ? "ni_mseries"
 						      : "ni_eseries";
 
+	/* prepare the device for globally-named routes. */
+	if (ni_assign_device_routes(dev_family, board->name,
+				    &devpriv->routing_tables) < 0) {
+		dev_warn(dev->class_dev, "%s: %s device has no signal routing table.\n",
+			 __func__, board->name);
+		dev_warn(dev->class_dev, "%s: High level NI signal names will not be available for this %s board.\n",
+			 __func__, board->name);
+	} else {
+		/*
+		 * only(?) assign insn_device_config if we have global names for
+		 * this device.
+		 */
+		dev->insn_device_config = ni_global_insn_config;
+		dev->get_valid_routes = _ni_get_valid_routes;
+	}
+
 	if (board->n_aochan > MAX_N_AO_CHAN) {
 		dev_err(dev->class_dev, "bug! n_aochan > MAX_N_AO_CHAN\n");
 		return -EINVAL;
@@ -5634,15 +6186,6 @@ static int ni_E_init(struct comedi_device *dev,
 		ni_writeb(dev, 0x0, NI_M_AO_CALIB_REG);
 	}
 
-	/* prepare the device for globally-named routes. */
-	if (ni_assign_device_routes(dev_family, board->name,
-				    &devpriv->routing_tables) < 0) {
-		dev_warn(dev->class_dev, "%s: %s device has no signal routing table.\n",
-			 __func__, board->name);
-		dev_warn(dev->class_dev, "%s: High level NI signal names will not be available for this %s board.\n",
-			 __func__, board->name);
-	}
-
 	return 0;
 }
 

commit 56d0b826d39f5b04dc5df7e270539361627684de
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Oct 3 14:56:05 2018 -0600

    staging: comedi: ni_mio_common: implement new routing for TRIG_EXT
    
    Use new signal routing capability for all comedi command *_src == TRIG_EXT
    options.  This new interface allows the user specify signals and terminals
    as TRIG_EXT sources using a very consistent naming convention. Furthermore,
    the interface allows backwards compatibility to prior behavior of
    specifying register-level (or near register-level) values as *_arg options
    when *_src == TRIG_EXT.
    
    Annotates and updates tables of register values to reflect this new
    implementation status.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 961ea97966f5..31a567d593c9 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2006,7 +2006,6 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 	int err = 0;
-	unsigned int tmp;
 	unsigned int sources;
 
 	/* Step 1 : check if triggers are trivially valid */
@@ -2047,12 +2046,9 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 		break;
 	case TRIG_EXT:
-		tmp = CR_CHAN(cmd->start_arg);
-
-		if (tmp > 16)
-			tmp = 16;
-		tmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));
-		err |= comedi_check_trigger_arg_is(&cmd->start_arg, tmp);
+		err |= ni_check_trigger_arg_roffs(CR_CHAN(cmd->start_arg),
+						  NI_AI_StartTrigger,
+						  &devpriv->routing_tables, 1);
 		break;
 	}
 
@@ -2064,12 +2060,9 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 						    0xffffff);
 	} else if (cmd->scan_begin_src == TRIG_EXT) {
 		/* external trigger */
-		unsigned int tmp = CR_CHAN(cmd->scan_begin_arg);
-
-		if (tmp > 16)
-			tmp = 16;
-		tmp |= (cmd->scan_begin_arg & (CR_INVERT | CR_EDGE));
-		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);
+		err |= ni_check_trigger_arg_roffs(CR_CHAN(cmd->scan_begin_arg),
+						  NI_AI_SampleClock,
+						  &devpriv->routing_tables, 1);
 	} else {		/* TRIG_OTHER */
 		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 	}
@@ -2087,12 +2080,9 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		}
 	} else if (cmd->convert_src == TRIG_EXT) {
 		/* external trigger */
-		unsigned int tmp = CR_CHAN(cmd->convert_arg);
-
-		if (tmp > 16)
-			tmp = 16;
-		tmp |= (cmd->convert_arg & (CR_ALT_FILTER | CR_INVERT));
-		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, tmp);
+		err |= ni_check_trigger_arg_roffs(CR_CHAN(cmd->convert_arg),
+						  NI_AI_ConvertClock,
+						  &devpriv->routing_tables, 1);
 	} else if (cmd->convert_src == TRIG_NOW) {
 		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
 	}
@@ -2118,7 +2108,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* step 4: fix up any arguments */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		tmp = cmd->scan_begin_arg;
+		unsigned int tmp = cmd->scan_begin_arg;
 		cmd->scan_begin_arg =
 		    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
 						       cmd->scan_begin_arg,
@@ -2128,7 +2118,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		if (!devpriv->is_611x && !devpriv->is_6143) {
-			tmp = cmd->convert_arg;
+			unsigned int tmp = cmd->convert_arg;
 			cmd->convert_arg =
 			    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
 							       cmd->convert_arg,
@@ -2206,8 +2196,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			   NISTC_AI_TRIG_START1_SEL(0);
 		break;
 	case TRIG_EXT:
-		ai_trig |= NISTC_AI_TRIG_START1_SEL(CR_CHAN(cmd->start_arg) +
-						    1);
+		ai_trig |= NISTC_AI_TRIG_START1_SEL(
+			ni_get_reg_value_roffs(CR_CHAN(cmd->start_arg),
+					       NI_AI_StartTrigger,
+					       &devpriv->routing_tables, 1));
 
 		if (cmd->start_arg & CR_INVERT)
 			ai_trig |= NISTC_AI_TRIG_START1_POLARITY;
@@ -2317,8 +2309,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		    (cmd->scan_begin_arg & ~CR_EDGE) !=
 		    (cmd->convert_arg & ~CR_EDGE))
 			start_stop_select |= NISTC_AI_START_SYNC;
-		start_stop_select |=
-		    NISTC_AI_START_SEL(1 + CR_CHAN(cmd->scan_begin_arg));
+		start_stop_select |= NISTC_AI_START_SEL(
+			ni_get_reg_value_roffs(CR_CHAN(cmd->scan_begin_arg),
+					       NI_AI_SampleClock,
+					       &devpriv->routing_tables, 1));
 		ni_stc_writew(dev, start_stop_select, NISTC_AI_START_STOP_REG);
 		break;
 	}
@@ -2346,8 +2340,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);
 		break;
 	case TRIG_EXT:
-		mode1 |= NISTC_AI_MODE1_CONVERT_SRC(1 +
-						    CR_CHAN(cmd->convert_arg));
+		mode1 |= NISTC_AI_MODE1_CONVERT_SRC(
+			ni_get_reg_value_roffs(CR_CHAN(cmd->convert_arg),
+					       NI_AI_ConvertClock,
+					       &devpriv->routing_tables, 1));
 		if ((cmd->convert_arg & CR_INVERT) == 0)
 			mode1 |= NISTC_AI_MODE1_CONVERT_POLARITY;
 		ni_stc_writew(dev, mode1, NISTC_AI_MODE1_REG);
@@ -2970,7 +2966,10 @@ static void ni_ao_cmd_set_trigger(struct comedi_device *dev,
 		trigsel = NISTC_AO_TRIG_START1_EDGE |
 			  NISTC_AO_TRIG_START1_SYNC;
 	} else { /* TRIG_EXT */
-		trigsel = NISTC_AO_TRIG_START1_SEL(CR_CHAN(cmd->start_arg) + 1);
+		trigsel = NISTC_AO_TRIG_START1_SEL(
+			ni_get_reg_value_roffs(CR_CHAN(cmd->start_arg),
+					       NI_AO_StartTrigger,
+					       &devpriv->routing_tables, 1));
 		/* 0=active high, 1=active low. see daq-stc 3-24 (p186) */
 		if (cmd->start_arg & CR_INVERT)
 			trigsel |= NISTC_AO_TRIG_START1_POLARITY;
@@ -3132,7 +3131,9 @@ static void ni_ao_cmd_set_update(struct comedi_device *dev,
 		/* FIXME:  assert scan_begin_arg != 0, ret failure otherwise */
 		devpriv->ao_cmd2  |= NISTC_AO_CMD2_BC_GATE_ENA;
 		devpriv->ao_mode1 |= NISTC_AO_MODE1_UPDATE_SRC(
-					CR_CHAN(cmd->scan_begin_arg));
+			ni_get_reg_value(CR_CHAN(cmd->scan_begin_arg),
+					 NI_AO_SampleClock,
+					 &devpriv->routing_tables));
 		if (cmd->scan_begin_arg & CR_INVERT)
 			devpriv->ao_mode1 |= NISTC_AO_MODE1_UPDATE_SRC_POLARITY;
 	}
@@ -3328,12 +3329,9 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 		break;
 	case TRIG_EXT:
-		tmp = CR_CHAN(cmd->start_arg);
-
-		if (tmp > 18)
-			tmp = 18;
-		tmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));
-		err |= comedi_check_trigger_arg_is(&cmd->start_arg, tmp);
+		err |= ni_check_trigger_arg_roffs(CR_CHAN(cmd->start_arg),
+						  NI_AO_StartTrigger,
+						  &devpriv->routing_tables, 1);
 		break;
 	}
 
@@ -3343,6 +3341,10 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		err |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,
 						    devpriv->clock_ns *
 						    0xffffff);
+	} else {		/* TRIG_EXT */
+		err |= ni_check_trigger_arg(CR_CHAN(cmd->scan_begin_arg),
+					    NI_AO_SampleClock,
+					    &devpriv->routing_tables);
 	}
 
 	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
@@ -3540,8 +3542,8 @@ static int ni_cdio_check_chanlist(struct comedi_device *dev,
 static int ni_cdio_cmdtest(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
+	struct ni_private *devpriv = dev->private;
 	int err = 0;
-	int tmp;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -3561,9 +3563,15 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 
 	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	tmp = cmd->scan_begin_arg;
-	tmp &= CR_PACK_FLAGS(NI_M_CDO_MODE_SAMPLE_SRC_MASK, 0, 0, CR_INVERT);
-	if (tmp != cmd->scan_begin_arg)
+	/*
+	 * Although NI_D[IO]_SampleClock are the same, perhaps we should still,
+	 * for completeness, test whether the cmd is output or input?
+	 */
+	err |= ni_check_trigger_arg(CR_CHAN(cmd->scan_begin_arg),
+				    NI_DO_SampleClock,
+				    &devpriv->routing_tables);
+	if (CR_RANGE(cmd->scan_begin_arg) != 0 ||
+	    CR_AREF(cmd->scan_begin_arg) != 0)
 		err |= -EINVAL;
 
 	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
@@ -3651,9 +3659,16 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int retval;
 
 	ni_writel(dev, NI_M_CDO_CMD_RESET, NI_M_CDIO_CMD_REG);
+	/*
+	 * Although NI_D[IO]_SampleClock are the same, perhaps we should still,
+	 * for completeness, test whether the cmd is output or input(?)
+	 */
 	cdo_mode_bits = NI_M_CDO_MODE_FIFO_MODE |
 			NI_M_CDO_MODE_HALT_ON_ERROR |
-			NI_M_CDO_MODE_SAMPLE_SRC(CR_CHAN(cmd->scan_begin_arg));
+			NI_M_CDO_MODE_SAMPLE_SRC(
+				ni_get_reg_value(CR_CHAN(cmd->scan_begin_arg),
+						 NI_DO_SampleClock,
+						 &devpriv->routing_tables));
 	if (cmd->scan_begin_arg & CR_INVERT)
 		cdo_mode_bits |= NI_M_CDO_MODE_POLARITY;
 	ni_writel(dev, cdo_mode_bits, NI_M_CDO_MODE_REG);
@@ -5286,6 +5301,8 @@ static int ni_E_init(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	int ret;
 	int i;
+	const char *dev_family = devpriv->is_m_series ? "ni_mseries"
+						      : "ni_eseries";
 
 	if (board->n_aochan > MAX_N_AO_CHAN) {
 		dev_err(dev->class_dev, "bug! n_aochan > MAX_N_AO_CHAN\n");
@@ -5617,6 +5634,15 @@ static int ni_E_init(struct comedi_device *dev,
 		ni_writeb(dev, 0x0, NI_M_AO_CALIB_REG);
 	}
 
+	/* prepare the device for globally-named routes. */
+	if (ni_assign_device_routes(dev_family, board->name,
+				    &devpriv->routing_tables) < 0) {
+		dev_warn(dev->class_dev, "%s: %s device has no signal routing table.\n",
+			 __func__, board->name);
+		dev_warn(dev->class_dev, "%s: High level NI signal names will not be available for this %s board.\n",
+			 __func__, board->name);
+	}
+
 	return 0;
 }
 

commit 51fd3673838396844f15de0e906be5333bfbbc8d
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Sep 19 10:51:04 2018 -0600

    staging: comedi: ni_mio_common: implement INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS
    
    Adds implementation of the new INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS
    instruction.  This patch also adds data for digital subdevices that are
    streaming capable (within the ni_mio_* family).  Mostly, only the m-series
    devices are capable of digital streaming.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 44fcb3790113..961ea97966f5 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2464,6 +2464,7 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
+	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 
 	if (insn->n < 1)
@@ -2498,6 +2499,15 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 			}
 		}
 		return 2;
+	case INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS:
+		/* we don't care about actual channels */
+		/* data[3] : chanlist_len */
+		data[1] = ni_min_ai_scan_period_ns(dev, data[3]);
+		if (devpriv->is_611x || devpriv->is_6143)
+			data[2] = 0; /* simultaneous output */
+		else
+			data[2] = board->ai_speed;
+		return 0;
 	default:
 		break;
 	}
@@ -2834,6 +2844,11 @@ static int ni_ao_insn_config(struct comedi_device *dev,
 		return 0;
 	case INSN_CONFIG_ARM:
 		return ni_ao_arm(dev, s);
+	case INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS:
+		/* we don't care about actual channels */
+		data[1] = board->ao_speed;
+		data[2] = 0;
+		return 0;
 	default:
 		break;
 	}
@@ -3475,6 +3490,15 @@ static int ni_m_series_dio_insn_config(struct comedi_device *dev,
 {
 	int ret;
 
+	if (data[0] == INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS) {
+		const struct ni_board_struct *board = dev->board_ptr;
+
+		/* we don't care about actual channels */
+		data[1] = board->dio_speed;
+		data[2] = 0;
+		return 0;
+	}
+
 	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
 	if (ret)
 		return ret;

commit 1cbca5852d6c16e85a21487a15d211195aacd4a1
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Oct 3 14:54:16 2018 -0600

    staging: comedi: ni_mio_common: protect register write overflow
    
    Fixes two problems introduced as early as
    commit 03aef4b6dc12  ("Staging: comedi: add ni_mio_common code"):
    (1) Ensures that the last four bits of NISTC_RTSI_TRIGB_OUT_REG register is
        not unduly overwritten on e-series devices.  On e-series devices, the
        first three of the last four bits are reserved.  The last bit defines
        the output selection of the RGOUT0 pin, otherwise known as
        RTSI_Sub_Selection.  For m-series devices, these last four bits are
        indeed used as the output selection of the RTSI7 pin (and the
        RTSI_Sub_Selection bit for the RGOUT0 pin is moved to the
        RTSI_Trig_Direction register.
    (2) Allows all 4 RTSI_BRD lines to be treated as valid sources for RTSI
        lines.
    
    This patch also cleans up the ni_get_rtsi_routing command for readability.
    
    Fixes: 03aef4b6dc12  ("Staging: comedi: add ni_mio_common code")
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 4dee2fc37aed..44fcb3790113 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4980,7 +4980,10 @@ static int ni_valid_rtsi_output_source(struct comedi_device *dev,
 	case NI_RTSI_OUTPUT_G_SRC0:
 	case NI_RTSI_OUTPUT_G_GATE0:
 	case NI_RTSI_OUTPUT_RGOUT0:
-	case NI_RTSI_OUTPUT_RTSI_BRD_0:
+	case NI_RTSI_OUTPUT_RTSI_BRD(0):
+	case NI_RTSI_OUTPUT_RTSI_BRD(1):
+	case NI_RTSI_OUTPUT_RTSI_BRD(2):
+	case NI_RTSI_OUTPUT_RTSI_BRD(3):
 		return 1;
 	case NI_RTSI_OUTPUT_RTSI_OSC:
 		return (devpriv->is_m_series) ? 1 : 0;
@@ -5001,11 +5004,18 @@ static int ni_set_rtsi_routing(struct comedi_device *dev,
 		devpriv->rtsi_trig_a_output_reg |= NISTC_RTSI_TRIG(chan, src);
 		ni_stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
 			      NISTC_RTSI_TRIGA_OUT_REG);
-	} else if (chan < 8) {
+	} else if (chan < NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series)) {
 		devpriv->rtsi_trig_b_output_reg &= ~NISTC_RTSI_TRIG_MASK(chan);
 		devpriv->rtsi_trig_b_output_reg |= NISTC_RTSI_TRIG(chan, src);
 		ni_stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
 			      NISTC_RTSI_TRIGB_OUT_REG);
+	} else if (chan != NISTC_RTSI_TRIG_OLD_CLK_CHAN) {
+		/* probably should never reach this, since the
+		 * ni_valid_rtsi_output_source above errors out if chan is too
+		 * high
+		 */
+		dev_err(dev->class_dev, "%s: unknown rtsi channel\n", __func__);
+		return -EINVAL;
 	}
 	return 2;
 }
@@ -5021,12 +5031,12 @@ static unsigned int ni_get_rtsi_routing(struct comedi_device *dev,
 	} else if (chan < NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series)) {
 		return NISTC_RTSI_TRIG_TO_SRC(chan,
 					      devpriv->rtsi_trig_b_output_reg);
-	} else {
-		if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN)
-			return NI_RTSI_OUTPUT_RTSI_OSC;
-		dev_err(dev->class_dev, "bug! should never get here?\n");
-		return 0;
+	} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {
+		return NI_RTSI_OUTPUT_RTSI_OSC;
 	}
+
+	dev_err(dev->class_dev, "%s: unknown rtsi channel\n", __func__);
+	return -EINVAL;
 }
 
 static int ni_rtsi_insn_config(struct comedi_device *dev,

commit e083926b3e269d4064825dcf2ad50c636fddf8cf
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Aug 6 11:05:13 2018 +0100

    staging: comedi: ni_mio_common: fix subdevice flags for PFI subdevice
    
    The PFI subdevice flags indicate that the subdevice is readable and
    writeable, but that is only true for the supported "M-series" boards,
    not the older "E-series" boards.  Only set the SDF_READABLE and
    SDF_WRITABLE subdevice flags for the M-series boards.  These two flags
    are mainly for informational purposes.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b0b05a96c2f0..4dee2fc37aed 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5446,11 +5446,11 @@ static int ni_E_init(struct comedi_device *dev,
 	/* Digital I/O (PFI) subdevice */
 	s = &dev->subdevices[NI_PFI_DIO_SUBDEV];
 	s->type		= COMEDI_SUBD_DIO;
-	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 	s->maxdata	= 1;
 	if (devpriv->is_m_series) {
 		s->n_chan	= 16;
 		s->insn_bits	= ni_pfi_insn_bits;
+		s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 
 		ni_writew(dev, s->state, NI_M_PFI_DO_REG);
 		for (i = 0; i < NUM_PFI_OUTPUT_SELECT_REGS; ++i) {
@@ -5459,6 +5459,7 @@ static int ni_E_init(struct comedi_device *dev,
 		}
 	} else {
 		s->n_chan	= 10;
+		s->subdev_flags	= SDF_INTERNAL;
 	}
 	s->insn_config	= ni_pfi_insn_config;
 

commit fbe1be81b2840f4f5a25405e92cf67b69bafe9c1
Author: Giulio Benetti <giulio.benetti@micronovasrl.com>
Date:   Tue Jun 12 16:54:09 2018 +0200

    staging: comedi: drivers: ni_mio_common: add names to function pointer parameters.
    
    Checkpatch.pl complains about packbits function pointer that lacks
    parameters name.
    
    Add parameter names to packbits function pointer.
    
    Signed-off-by: Giulio Benetti <giulio.benetti@micronovasrl.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e40a2c0a9543..b0b05a96c2f0 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4294,7 +4294,7 @@ static int pack_ad8842(int addr, int val, int *bitstring)
 struct caldac_struct {
 	int n_chans;
 	int n_bits;
-	int (*packbits)(int, int, int *);
+	int (*packbits)(int address, int value, int *bitstring);
 };
 
 static struct caldac_struct caldacs[] = {

commit e1d9fc04c41840a4688ef6ce90b6dcca157ea4d7
Author: Frank Mori Hess <fmh6jj@gmail.com>
Date:   Thu Mar 15 10:25:44 2018 +0000

    staging: comedi: ni_mio_common: ack ai fifo error interrupts.
    
    Ack ai fifo error interrupts in interrupt handler to clear interrupt
    after fifo overflow.  It should prevent lock-ups after the ai fifo
    overflows.
    
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Frank Mori Hess <fmh6jj@gmail.com>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d6eb55b41814..e40a2c0a9543 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1275,6 +1275,8 @@ static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 		ack |= NISTC_INTA_ACK_AI_START;
 	if (a_status & NISTC_AI_STATUS1_STOP)
 		ack |= NISTC_INTA_ACK_AI_STOP;
+	if (a_status & NISTC_AI_STATUS1_OVER)
+		ack |= NISTC_INTA_ACK_AI_ERR;
 	if (ack)
 		ni_stc_writew(dev, ack, NISTC_INTA_ACK_REG);
 }

commit 38614ed80220f74c08333fb5e9b2c98a2fe9cacc
Author: Eisha Chen-yen-su <chenyensu0@gmail.com>
Date:   Tue Feb 20 10:05:25 2018 +0100

    staging: comedi: Use '"%s:", __func__' instead of function name
    
    Replace all occurrences of functions' names in strings by a reference
    to __func__, to improve robustness. Problem found with checkpatch.
    
    Signed-off-by: Eisha Chen-yen-su <chenyensu0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5d610af6799f..d6eb55b41814 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1965,7 +1965,8 @@ static void ni_cmd_set_mite_transfer(struct mite_ring *ring,
 	if (nbytes > sdev->async->prealloc_bufsz) {
 		if (cmd->stop_arg > 0)
 			dev_err(sdev->device->class_dev,
-				"ni_cmd_set_mite_transfer: tried exact data transfer limits greater than buffer size\n");
+				"%s: tried exact data transfer limits greater than buffer size\n",
+				__func__);
 
 		/*
 		 * we can only transfer up to the size of the buffer.  In this
@@ -1978,7 +1979,8 @@ static void ni_cmd_set_mite_transfer(struct mite_ring *ring,
 	mite_init_ring_descriptors(ring, sdev, nbytes);
 #else
 	dev_err(sdev->device->class_dev,
-		"ni_cmd_set_mite_transfer: exact data transfer limits not implemented yet without DMA\n");
+		"%s: exact data transfer limits not implemented yet without DMA\n",
+		__func__);
 #endif
 }
 
@@ -4687,7 +4689,7 @@ static int cs5529_do_conversion(struct comedi_device *dev,
 	retval = cs5529_wait_for_idle(dev);
 	if (retval) {
 		dev_err(dev->class_dev,
-			"timeout or signal in cs5529_do_conversion()\n");
+			"timeout or signal in %s()\n", __func__);
 		return -ETIME;
 	}
 	status = ni_ao_win_inw(dev, NI67XX_CAL_STATUS_REG);

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 3d043254b280..5d610af6799f 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5,16 +5,6 @@
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 1997-2001 David A. Schleef <ds@schleef.org>
  * Copyright (C) 2002-2006 Frank Mori Hess <fmhess@users.sourceforge.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 398347fedc47..3d043254b280 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Hardware driver for DAQ-STC based boards
  *

commit dc5b02a9087167da602e826801cdf7c8b0dbe32a
Author: Christopher Mårtensson <cribalik@gmail.com>
Date:   Sun Jul 23 13:05:09 2017 +0200

    staging: comedi: ni_mio_common.c: fix coding style issue
    
    "checkpatch.pl -f ..." gave
    ERROR: open brace '{' following function definitions go on the next line
    
    Signed-off-by: Christopher Mårtensson <cribalik@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2f7bfc1c59e5..398347fedc47 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1962,7 +1962,8 @@ static unsigned int ni_timer_to_ns(const struct comedi_device *dev, int timer)
 static void ni_cmd_set_mite_transfer(struct mite_ring *ring,
 				     struct comedi_subdevice *sdev,
 				     const struct comedi_cmd *cmd,
-				     unsigned int max_count) {
+				     unsigned int max_count)
+{
 #ifdef PCIDMA
 	unsigned int nbytes = max_count;
 

commit 15d5193104a457d5151840247e3bce561c42e3e9
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 30 12:02:18 2017 +0100

    staging: comedi: ni_mio_common: fix AO timer off-by-one regression
    
    As reported by Éric Piel on the Comedi mailing list (see
    <https://groups.google.com/forum/#!topic/comedi_list/ueZiR7vTLOU/discussion>),
    the analog output asynchronous commands are running too fast with a
    period 50 ns shorter than it should be.  This affects all boards with AO
    command support that are supported by the "ni_pcimio", "ni_atmio", and
    "ni_mio_cs" drivers.
    
    This is a regression bug introduced by commit 080e6795cba3 ("staging:
    comedi: ni_mio_common: Cleans up/clarifies ni_ao_cmd"), specifically,
    this line in `ni_ao_cmd_set_update()`:
    
                    /* following line: N-1 per STC */
                    ni_stc_writel(dev, trigvar - 1, NISTC_AO_UI_LOADA_REG);
    
    The `trigvar` variable value comes from a call to `ni_ns_to_timer()`
    which converts a timer period in nanoseconds to a hardware divisor
    value. The function already reduces the divisor by 1 as required by the
    hardware, so the above line should not reduce it further by 1.  Fix it
    by replacing `trigvar` by `trigvar - 1` in the above line, and remove
    the misleading comment.
    
    Reported-by: Éric Piel <piel@delmic.com>
    Fixes: 080e6795cba3 ("staging: comedi: ni_mio_common: Cleans up/clarifies ni_ao_cmd")
    Cc: Éric Piel <piel@delmic.com>
    Cc: Spencer E. Olson <olsonse@umich.edu>
    Cc: <stable@vger.kernel.org> # 4.7+
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b2e382888981..2f7bfc1c59e5 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3116,8 +3116,7 @@ static void ni_ao_cmd_set_update(struct comedi_device *dev,
 		/* following line: 2-1 per STC */
 		ni_stc_writel(dev, 1, NISTC_AO_UI_LOADA_REG);
 		ni_stc_writew(dev, NISTC_AO_CMD1_UI_LOAD, NISTC_AO_CMD1_REG);
-		/* following line: N-1 per STC */
-		ni_stc_writel(dev, trigvar - 1, NISTC_AO_UI_LOADA_REG);
+		ni_stc_writel(dev, trigvar, NISTC_AO_UI_LOADA_REG);
 	} else { /* TRIG_EXT */
 		/* FIXME:  assert scan_begin_arg != 0, ret failure otherwise */
 		devpriv->ao_cmd2  |= NISTC_AO_CMD2_BC_GATE_ENA;

commit e3007002f119a72a85981533bde671936a68551b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Nov 14 20:16:23 2016 +0000

    staging: comedi: ni_mio_common: remove variable 'dl' in ni_ai_insn_read()
    
    In `ni_ai_insn_read()`, local variable `dl` is declared as `unsigned
    long`, but `unsigned int` will do.  Get rid of it and use local variable
    `d` instead.  (That used to be `unsigned short`, but has been `unsigned
    int` since kernel version 3.18.)
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a974ab772937..b2e382888981 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1836,7 +1836,6 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 	int i, n;
 	unsigned int signbits;
 	unsigned int d;
-	unsigned long dl;
 
 	ni_load_channelgain_list(dev, s, 1, &insn->chanspec);
 
@@ -1887,15 +1886,15 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			 * bit to move a single 16bit stranded sample into
 			 * the FIFO.
 			 */
-			dl = 0;
+			d = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
 				if (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) &
 				    0x01) {
 					/* Get stranded sample into FIFO */
 					ni_writel(dev, 0x01,
 						  NI6143_AI_FIFO_CTRL_REG);
-					dl = ni_readl(dev,
-						      NI6143_AI_FIFO_DATA_REG);
+					d = ni_readl(dev,
+						     NI6143_AI_FIFO_DATA_REG);
 					break;
 				}
 			}
@@ -1903,7 +1902,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				dev_err(dev->class_dev, "timeout\n");
 				return -ETIME;
 			}
-			data[n] = (((dl >> 16) & 0xFFFF) + signbits) & 0xFFFF;
+			data[n] = (((d >> 16) & 0xFFFF) + signbits) & 0xFFFF;
 		}
 	} else {
 		for (n = 0; n < insn->n; n++) {
@@ -1919,9 +1918,9 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				return -ETIME;
 			}
 			if (devpriv->is_m_series) {
-				dl = ni_readl(dev, NI_M_AI_FIFO_DATA_REG);
-				dl &= mask;
-				data[n] = dl;
+				d = ni_readl(dev, NI_M_AI_FIFO_DATA_REG);
+				d &= mask;
+				data[n] = d;
 			} else {
 				d = ni_readw(dev, NI_E_AI_FIFO_DATA_REG);
 				d += signbits;

commit 857a661020a2de3a0304edf33ad656abee100891
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Nov 14 20:16:22 2016 +0000

    staging: comedi: ni_mio_common: fix E series ni_ai_insn_read() data
    
    Commit 0557344e2149 ("staging: comedi: ni_mio_common: fix local var for
    32-bit read") changed the type of local variable `d` from `unsigned
    short` to `unsigned int` to fix a bug introduced in
    commit 9c340ac934db ("staging: comedi: ni_stc.h: add read/write
    callbacks to struct ni_private") when reading AI data for NI PCI-6110
    and PCI-6111 cards.  Unfortunately, other parts of the function rely on
    the variable being `unsigned short` when an offset value in local
    variable `signbits` is added to `d` before writing the value to the
    `data` array:
    
                            d += signbits;
                            data[n] = d;
    
    The `signbits` variable will be non-zero in bipolar mode, and is used to
    convert the hardware's 2's complement, 16-bit numbers to Comedi's
    straight binary sample format (with 0 representing the most negative
    voltage).  This breaks because `d` is now 32 bits wide instead of 16
    bits wide, so after the addition of `signbits`, `data[n]` ends up being
    set to values above 65536 for negative voltages.  This affects all
    supported "E series" cards except PCI-6143 (and PXI-6143). Fix it by
    ANDing the value written to the `data[n]` with the mask 0xffff.
    
    Fixes: 0557344e2149 ("staging: comedi: ni_mio_common: fix local var for 32-bit read")
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: <stable@vger.kernel.org>
    ----
    Needs backporting to stable kernels 3.18 onwards.
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 95435395c746..a974ab772937 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1875,7 +1875,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				return -ETIME;
 			}
 			d += signbits;
-			data[n] = d;
+			data[n] = d & 0xffff;
 		}
 	} else if (devpriv->is_6143) {
 		for (n = 0; n < insn->n; n++) {
@@ -1924,9 +1924,8 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				data[n] = dl;
 			} else {
 				d = ni_readw(dev, NI_E_AI_FIFO_DATA_REG);
-				/* subtle: needs to be short addition */
 				d += signbits;
-				data[n] = d;
+				data[n] = d & 0xffff;
 			}
 		}
 	}

commit 655c4d442d1213b617926cc6d54e2a9a793fb46b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Nov 14 20:16:21 2016 +0000

    staging: comedi: ni_mio_common: fix M Series ni_ai_insn_read() data mask
    
    For NI M Series cards, the Comedi `insn_read` handler for the AI
    subdevice is broken due to ANDing the value read from the AI FIFO data
    register with an incorrect mask.  The incorrect mask clears all but the
    most significant bit of the sample data.  It should preserve all the
    sample data bits.  Correct it.
    
    Fixes: 817144ae7fda ("staging: comedi: ni_mio_common: remove unnecessary use of 'board->adbits'")
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 9812508fe8d3..95435395c746 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1832,7 +1832,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			   unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
-	unsigned int mask = (s->maxdata + 1) >> 1;
+	unsigned int mask = s->maxdata;
 	int i, n;
 	unsigned int signbits;
 	unsigned int d;

commit 1ffe8bdc09f8bfcaad76d71ae68b623c7e03f20f
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Mon Oct 10 08:14:19 2016 -0600

    staging: comedi: ni_mio_common: split out ao arming from ni_ao_inttrig
    
    AO device arming was previously done as a part of ni_ao_inttrig which is
    called as a result of the user calling comedi_internal_trigger.  For
    start_src == TRIG_EXT, this does not make very much sense since external
    triggers should not conceptually need to be software triggered also.  This
    patch splits out the arming functionality to allow arming to specifically
    and separately be done via the CONFIG_INSN_ARM ioctl command.
    
    In order to provide backwards compatibility, this patch also provides
    automatic arming if ni_ao_inttrig is simply called.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0f97d7b611d7..9812508fe8d3 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2729,66 +2729,36 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int ni_ao_insn_config(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
-{
-	const struct ni_board_struct *board = dev->board_ptr;
-	struct ni_private *devpriv = dev->private;
-	unsigned int nbytes;
-
-	switch (data[0]) {
-	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
-		switch (data[1]) {
-		case COMEDI_OUTPUT:
-			nbytes = comedi_samples_to_bytes(s,
-							 board->ao_fifo_depth);
-			data[2] = 1 + nbytes;
-			if (devpriv->mite)
-				data[2] += devpriv->mite->fifo_size;
-			break;
-		case COMEDI_INPUT:
-			data[2] = 0;
-			break;
-		default:
-			return -EINVAL;
-		}
-		return 0;
-	default:
-		break;
-	}
-
-	return -EINVAL;
-}
-
-static int ni_ao_inttrig(struct comedi_device *dev,
-			 struct comedi_subdevice *s,
-			 unsigned int trig_num)
+/*
+ * Arms the AO device in preparation for a trigger event.
+ * This function also allocates and prepares a DMA channel (or FIFO if DMA is
+ * not used).  As a part of this preparation, this function preloads the DAC
+ * registers with the first values of the output stream.  This ensures that the
+ * first clock cycle after the trigger can be used for output.
+ *
+ * Note that this function _must_ happen after a user has written data to the
+ * output buffers via either mmap or write(fileno,...).
+ */
+static int ni_ao_arm(struct comedi_device *dev,
+		     struct comedi_subdevice *s)
 {
 	struct ni_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
 	int ret;
 	int interrupt_b_bits;
 	int i;
 	static const int timeout = 1000;
 
 	/*
-	 * Require trig_num == cmd->start_arg when cmd->start_src == TRIG_INT.
-	 * For backwards compatibility, also allow trig_num == 0 when
-	 * cmd->start_src != TRIG_INT (i.e. when cmd->start_src == TRIG_EXT);
-	 * in that case, the internal trigger is being used as a pre-trigger
-	 * before the external trigger.
+	 * Prevent ao from doing things like trying to allocate the ao dma
+	 * channel multiple times.
 	 */
-	if (!(trig_num == cmd->start_arg ||
-	      (trig_num == 0 && cmd->start_src != TRIG_INT)))
+	if (!devpriv->ao_needs_arming) {
+		dev_dbg(dev->class_dev, "%s: device does not need arming!\n",
+			__func__);
 		return -EINVAL;
+	}
 
-	/*
-	 * Null trig at beginning prevent ao start trigger from executing more
-	 * than once per command (and doing things like trying to allocate the
-	 * ao dma channel multiple times).
-	 */
-	s->async->inttrig = NULL;
+	devpriv->ao_needs_arming = 0;
 
 	ni_set_bits(dev, NISTC_INTB_ENA_REG,
 		    NISTC_INTB_ENA_AO_FIFO | NISTC_INTB_ENA_AO_ERR, 0);
@@ -2840,6 +2810,75 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 			   devpriv->ao_cmd1,
 		      NISTC_AO_CMD1_REG);
 
+	return 0;
+}
+
+static int ni_ao_insn_config(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
+{
+	const struct ni_board_struct *board = dev->board_ptr;
+	struct ni_private *devpriv = dev->private;
+	unsigned int nbytes;
+
+	switch (data[0]) {
+	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
+		switch (data[1]) {
+		case COMEDI_OUTPUT:
+			nbytes = comedi_samples_to_bytes(s,
+							 board->ao_fifo_depth);
+			data[2] = 1 + nbytes;
+			if (devpriv->mite)
+				data[2] += devpriv->mite->fifo_size;
+			break;
+		case COMEDI_INPUT:
+			data[2] = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+		return 0;
+	case INSN_CONFIG_ARM:
+		return ni_ao_arm(dev, s);
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+
+static int ni_ao_inttrig(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 unsigned int trig_num)
+{
+	struct ni_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	int ret;
+
+	/*
+	 * Require trig_num == cmd->start_arg when cmd->start_src == TRIG_INT.
+	 * For backwards compatibility, also allow trig_num == 0 when
+	 * cmd->start_src != TRIG_INT (i.e. when cmd->start_src == TRIG_EXT);
+	 * in that case, the internal trigger is being used as a pre-trigger
+	 * before the external trigger.
+	 */
+	if (!(trig_num == cmd->start_arg ||
+	      (trig_num == 0 && cmd->start_src != TRIG_INT)))
+		return -EINVAL;
+
+	/*
+	 * Null trig at beginning prevent ao start trigger from executing more
+	 * than once per command.
+	 */
+	s->async->inttrig = NULL;
+
+	if (devpriv->ao_needs_arming) {
+		/* only arm this device if it still needs arming */
+		ret = ni_ao_arm(dev, s);
+		if (ret)
+			return ret;
+	}
+
 	ni_stc_writew(dev, NISTC_AO_CMD2_START1_PULSE | devpriv->ao_cmd2,
 		      NISTC_AO_CMD2_REG);
 
@@ -3227,10 +3266,17 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_ao_cmd_set_interrupts(dev, s);
 
 	/*
-	 * arm(ing) and star(ting) happen in ni_ao_inttrig, which _must_ be
-	 * called for ao commands since 1) TRIG_NOW is not supported and 2) DMA
-	 * must be setup and initially written to before arm/start happen.
+	 * arm(ing) must happen later so that DMA can be setup and DACs
+	 * preloaded with the actual output buffer before starting.
+	 *
+	 * start(ing) must happen _after_ arming is completed.  Starting can be
+	 * done either via ni_ao_inttrig, or via an external trigger.
+	 *
+	 * **Currently, ni_ao_inttrig will automatically attempt a call to
+	 * ni_ao_arm if the device still needs arming at that point.  This
+	 * allows backwards compatibility.
 	 */
+	devpriv->ao_needs_arming = 1;
 	return 0;
 }
 

commit f0f4b0cc3a8cffd983f5940d46cd0227f3f5710a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jul 19 12:17:39 2016 +0100

    staging: comedi: ni_mio_common: fix AO inttrig backwards compatibility
    
    Commit ebb657babfa9 ("staging: comedi: ni_mio_common: clarify the
    cmd->start_arg validation and use") introduced a backwards compatibility
    issue in the use of asynchronous commands on the AO subdevice when
    `start_src` is `TRIG_EXT`.  Valid values for `start_src` are `TRIG_INT`
    (for internal, software trigger), and `TRIG_EXT` (for external trigger).
    When set to `TRIG_EXT`.  In both cases, the driver relies on an
    internal, software trigger to set things up (allowing the user
    application to write sufficient samples to the data buffer before the
    trigger), so it acts as a software "pre-trigger" in the `TRIG_EXT` case.
    The software trigger is handled by `ni_ao_inttrig()`.
    
    Prior to the above change, when `start_src` was `TRIG_INT`, `start_arg`
    was required to be 0, and `ni_ao_inttrig()` checked that the software
    trigger number was also 0.  After the above change, when `start_src` was
    `TRIG_INT`, any value was allowed for `start_arg`, and `ni_ao_inttrig()`
    checked that the software trigger number matched this `start_arg` value.
    The backwards compatibility issue is that the internal trigger number
    now has to match `start_arg` when `start_src` is `TRIG_EXT` when it
    previously had to be 0.
    
    Fix the backwards compatibility issue in `ni_ao_inttrig()` by always
    allowing software trigger number 0 when `start_src` is something other
    than `TRIG_INT`.
    
    Thanks to Spencer Olson for reporting the issue.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reported-by: Spencer Olson <olsonse@umich.edu>
    Fixes: ebb657babfa9 ("staging: comedi: ni_mio_common: clarify the cmd->start_arg validation and use")
    Cc: stable <stable@vger.kernel.org>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 3cf3c05c5ef2..0f97d7b611d7 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2772,7 +2772,15 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 	int i;
 	static const int timeout = 1000;
 
-	if (trig_num != cmd->start_arg)
+	/*
+	 * Require trig_num == cmd->start_arg when cmd->start_src == TRIG_INT.
+	 * For backwards compatibility, also allow trig_num == 0 when
+	 * cmd->start_src != TRIG_INT (i.e. when cmd->start_src == TRIG_EXT);
+	 * in that case, the internal trigger is being used as a pre-trigger
+	 * before the external trigger.
+	 */
+	if (!(trig_num == cmd->start_arg ||
+	      (trig_num == 0 && cmd->start_src != TRIG_INT)))
 		return -EINVAL;
 
 	/*

commit 5ca05345c56cb979e1a25ab6146437002f95cac8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jul 20 17:07:34 2016 +0100

    staging: comedi: ni_mio_common: fix wrong insn_write handler
    
    For counter subdevices, the `s->insn_write` handler is being set to the
    wrong function, `ni_tio_insn_read()`.  It should be
    `ni_tio_insn_write()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reported-by: Éric Piel <piel@delmic.com>
    Fixes: 10f74377eec3 ("staging: comedi: ni_tio: make ni_tio_winsn() a
      proper comedi (*insn_write)"
    Cc: <stable@vger.kernel.org> # 3.17+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8dabb19519a5..3cf3c05c5ef2 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5480,7 +5480,7 @@ static int ni_E_init(struct comedi_device *dev,
 		s->maxdata	= (devpriv->is_m_series) ? 0xffffffff
 							 : 0x00ffffff;
 		s->insn_read	= ni_tio_insn_read;
-		s->insn_write	= ni_tio_insn_read;
+		s->insn_write	= ni_tio_insn_write;
 		s->insn_config	= ni_tio_insn_config;
 #ifdef PCIDMA
 		if (dev->irq && devpriv->mite) {

commit 19d9212ef93fca5be07e6b8554a00dcb82124c7d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 2 10:11:36 2016 -0700

    staging: comedi: mite: rename 'struct mite_dma_descriptor_ring'
    
    Rename this name to 'mite_ring' to help shorten the long lines.
    
    In the ni_660x driver, also shorten the private data member 'mite_rings'
    to simply 'ring'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index dc024f27cc48..8dabb19519a5 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1961,7 +1961,7 @@ static unsigned int ni_timer_to_ns(const struct comedi_device *dev, int timer)
 	return devpriv->clock_ns * (timer + 1);
 }
 
-static void ni_cmd_set_mite_transfer(struct mite_dma_descriptor_ring *ring,
+static void ni_cmd_set_mite_transfer(struct mite_ring *ring,
 				     struct comedi_subdevice *sdev,
 				     const struct comedi_cmd *cmd,
 				     unsigned int max_count) {

commit f7d005c33c109ef034c9480334d3d25d91aa2d6d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 21 12:04:44 2016 -0700

    staging: comedi: mite: make mite_ack_linkc() handle mite_sync_dma()
    
    The mite dma is always synced on a LINKC status. Some of the mite users
    sync the dma regadless of the status.
    
    Add a 'sync' parameter to mite_ack_linkc() to force a dma sync. Then do
    the dma sync as needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a3b93c1adf34..dc024f27cc48 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3632,10 +3632,8 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	if (devpriv->cdo_mite_chan) {
-		mite_ack_linkc(devpriv->cdo_mite_chan, s);
-		mite_sync_dma(devpriv->cdo_mite_chan, s);
-	}
+	if (devpriv->cdo_mite_chan)
+		mite_ack_linkc(devpriv->cdo_mite_chan, s, true);
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 
 	cdio_status = ni_readl(dev, NI_M_CDIO_STATUS_REG);
@@ -5150,21 +5148,12 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 #ifdef PCIDMA
 	if (devpriv->mite) {
 		unsigned long flags_too;
-		unsigned int m_status;
 
 		spin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);
-		if (s_ai && devpriv->ai_mite_chan) {
-			m_status = mite_ack_linkc(devpriv->ai_mite_chan, s_ai);
-			if (m_status & CHSR_LINKC)
-				mite_sync_dma(devpriv->ai_mite_chan, s_ai);
-		}
-
-		if (s_ao && devpriv->ao_mite_chan) {
-			m_status = mite_ack_linkc(devpriv->ao_mite_chan, s_ao);
-			if (m_status & CHSR_LINKC)
-				mite_sync_dma(devpriv->ao_mite_chan, s_ao);
-		}
-
+		if (s_ai && devpriv->ai_mite_chan)
+			mite_ack_linkc(devpriv->ai_mite_chan, s_ai, false);
+		if (s_ao && devpriv->ao_mite_chan)
+			mite_ack_linkc(devpriv->ao_mite_chan, s_ao, false);
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);
 	}
 #endif

commit 3da088cae2a5f2ae6e8192db4b6e36496fd81514
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 21 12:04:43 2016 -0700

    staging: comedi: ni_mio_common: handle_a_interrupt() does not need ai_mite_status
    
    This function only handles the analog input interrupts, the dma was already
    handled.
    
    Remove the unecessary parameter and fix ni_E_interrupts() so that the comedi
    events are properly handled.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 9df1407a5c9d..a3b93c1adf34 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1290,8 +1290,7 @@ static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 
 static void handle_a_interrupt(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
-			       unsigned short status,
-			       unsigned int ai_mite_status)
+			       unsigned short status)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 
@@ -1304,10 +1303,8 @@ static void handle_a_interrupt(struct comedi_device *dev,
 			 * We probably aren't even running a command now,
 			 * so it's a good idea to be careful.
 			 */
-			if (comedi_is_subdevice_running(s)) {
+			if (comedi_is_subdevice_running(s))
 				s->async->events |= COMEDI_CB_ERROR;
-				comedi_handle_events(dev, s);
-			}
 			return;
 		}
 		if (status & NISTC_AI_STATUS1_ERR) {
@@ -1319,8 +1316,6 @@ static void handle_a_interrupt(struct comedi_device *dev,
 			s->async->events |= COMEDI_CB_ERROR;
 			if (status & NISTC_AI_STATUS1_OVER)
 				s->async->events |= COMEDI_CB_OVERFLOW;
-
-			comedi_handle_events(dev, s);
 			return;
 		}
 		if (status & NISTC_AI_STATUS1_SC_TC) {
@@ -1348,8 +1343,6 @@ static void handle_a_interrupt(struct comedi_device *dev,
 
 	if (status & NISTC_AI_STATUS1_STOP)
 		ni_handle_eos(dev, s);
-
-	comedi_handle_events(dev, s);
 }
 
 static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
@@ -5141,7 +5134,6 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 	struct comedi_subdevice *s_ao = dev->write_subdev;
 	unsigned short a_status;
 	unsigned short b_status;
-	unsigned int ai_mite_status = 0;
 	unsigned long flags;
 #ifdef PCIDMA
 	struct ni_private *devpriv = dev->private;
@@ -5162,9 +5154,8 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 
 		spin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);
 		if (s_ai && devpriv->ai_mite_chan) {
-			ai_mite_status = mite_ack_linkc(devpriv->ai_mite_chan,
-							s_ai);
-			if (ai_mite_status & CHSR_LINKC)
+			m_status = mite_ack_linkc(devpriv->ai_mite_chan, s_ai);
+			if (m_status & CHSR_LINKC)
 				mite_sync_dma(devpriv->ai_mite_chan, s_ai);
 		}
 
@@ -5179,9 +5170,12 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 #endif
 	ack_a_interrupt(dev, a_status);
 	ack_b_interrupt(dev, b_status);
-	if (s_ai &&
-	    ((a_status & NISTC_AI_STATUS1_INTA) || (ai_mite_status & CHSR_INT)))
-		handle_a_interrupt(dev, s_ai, a_status, ai_mite_status);
+	if (s_ai) {
+		if (a_status & NISTC_AI_STATUS1_INTA)
+			handle_a_interrupt(dev, s_ai, a_status);
+		/* handle any interrupt or dma events */
+		comedi_handle_events(dev, s_ai);
+	}
 	if (s_ao) {
 		if (b_status & NISTC_AO_STATUS1_INTB)
 			handle_b_interrupt(dev, s_ao, b_status);

commit 7101711ee4706915380bdd103902e864380a6987
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 21 12:04:42 2016 -0700

    staging: comedi: ni_mio_common: simplify AI LINKC handling
    
    Simplfy the LINKC handing for the analog input dma by moving it into
    the main interrupt handler. This function already hold the spinlock
    mite_channel_lock so call mite_sync_dma() directly instead of using
    the helper function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 6e76c95a1e5c..9df1407a5c9d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1295,11 +1295,6 @@ static void handle_a_interrupt(struct comedi_device *dev,
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-#ifdef PCIDMA
-	if (ai_mite_status & CHSR_LINKC)
-		ni_sync_ai_dma(dev);
-#endif
-
 	/* test for all uncommon interrupt events at the same time */
 	if (status & (NISTC_AI_STATUS1_ERR |
 		      NISTC_AI_STATUS1_SC_TC | NISTC_AI_STATUS1_START1)) {
@@ -5166,9 +5161,12 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 		unsigned int m_status;
 
 		spin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);
-		if (s_ai && devpriv->ai_mite_chan)
+		if (s_ai && devpriv->ai_mite_chan) {
 			ai_mite_status = mite_ack_linkc(devpriv->ai_mite_chan,
 							s_ai);
+			if (ai_mite_status & CHSR_LINKC)
+				mite_sync_dma(devpriv->ai_mite_chan, s_ai);
+		}
 
 		if (s_ao && devpriv->ao_mite_chan) {
 			m_status = mite_ack_linkc(devpriv->ao_mite_chan, s_ao);

commit ba5c0da886c5f75f3bf7cab2f1f23a9ba05e04a5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 21 12:04:41 2016 -0700

    staging: comedi: ni_mio_common: fix interrupt handler for dev->read_subdev
    
    There may not be a dev->read_subdev, i.e. an analog input subdevice, that
    supports async commands. If it doesn't exist the interrupt/dma will never
    be enabled.  Fix ni_E_interrupt() so that the analog input subdevice is
    only handled if it exists.
    
    This also fixes minor NULL dereference issue in handle_a_interrupt().
    If the dev->read_subdev is NULL the comedi_async pointer (s->async) will
    not be allocated by the device postconfig so there is no way to get a
    valid comedi_cmd (&s->async->cmd).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 1f661f2f399f..6e76c95a1e5c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1288,19 +1288,13 @@ static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 		ni_stc_writew(dev, ack, NISTC_INTA_ACK_REG);
 }
 
-static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
+static void handle_a_interrupt(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned short status,
 			       unsigned int ai_mite_status)
 {
-	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	/*
-	 * 67xx boards don't have ai subdevice, but their gpct0 might
-	 * generate an a interrupt.
-	 */
-	if (s->type == COMEDI_SUBD_UNUSED)
-		return;
-
 #ifdef PCIDMA
 	if (ai_mite_status & CHSR_LINKC)
 		ni_sync_ai_dma(dev);
@@ -5148,6 +5142,7 @@ static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static irqreturn_t ni_E_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct comedi_subdevice *s_ai = dev->read_subdev;
 	struct comedi_subdevice *s_ao = dev->write_subdev;
 	unsigned short a_status;
 	unsigned short b_status;
@@ -5171,9 +5166,9 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 		unsigned int m_status;
 
 		spin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);
-		if (devpriv->ai_mite_chan)
+		if (s_ai && devpriv->ai_mite_chan)
 			ai_mite_status = mite_ack_linkc(devpriv->ai_mite_chan,
-							dev->read_subdev);
+							s_ai);
 
 		if (s_ao && devpriv->ao_mite_chan) {
 			m_status = mite_ack_linkc(devpriv->ao_mite_chan, s_ao);
@@ -5186,8 +5181,9 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 #endif
 	ack_a_interrupt(dev, a_status);
 	ack_b_interrupt(dev, b_status);
-	if ((a_status & NISTC_AI_STATUS1_INTA) || (ai_mite_status & CHSR_INT))
-		handle_a_interrupt(dev, a_status, ai_mite_status);
+	if (s_ai &&
+	    ((a_status & NISTC_AI_STATUS1_INTA) || (ai_mite_status & CHSR_INT)))
+		handle_a_interrupt(dev, s_ai, a_status, ai_mite_status);
 	if (s_ao) {
 		if (b_status & NISTC_AO_STATUS1_INTB)
 			handle_b_interrupt(dev, s_ao, b_status);

commit 4b2d73898fdd75cc841a2a6fc978fdc7b5f5247a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 21 12:04:40 2016 -0700

    staging: comedi: ni_mio_common: handle_b_interrupt() does not need ao_mite_status
    
    This function only handles the analog input interrupts, the dma was already
    handled.
    
    Remove the unecessary parameter and fix ni_E_interrupts() so that the comedi
    events are properly handled.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5f6eedb422a3..1f661f2f399f 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1387,8 +1387,7 @@ static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
 
 static void handle_b_interrupt(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
-			       unsigned short b_status,
-			       unsigned int ao_mite_status)
+			       unsigned short b_status)
 {
 	if (b_status == 0xffff)
 		return;
@@ -1417,8 +1416,6 @@ static void handle_b_interrupt(struct comedi_device *dev,
 		}
 	}
 #endif
-
-	comedi_handle_events(dev, s);
 }
 
 static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -5155,7 +5152,6 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 	unsigned short a_status;
 	unsigned short b_status;
 	unsigned int ai_mite_status = 0;
-	unsigned int ao_mite_status = 0;
 	unsigned long flags;
 #ifdef PCIDMA
 	struct ni_private *devpriv = dev->private;
@@ -5172,6 +5168,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 #ifdef PCIDMA
 	if (devpriv->mite) {
 		unsigned long flags_too;
+		unsigned int m_status;
 
 		spin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);
 		if (devpriv->ai_mite_chan)
@@ -5179,9 +5176,8 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 							dev->read_subdev);
 
 		if (s_ao && devpriv->ao_mite_chan) {
-			ao_mite_status = mite_ack_linkc(devpriv->ao_mite_chan,
-							s_ao);
-			if (ao_mite_status & CHSR_LINKC)
+			m_status = mite_ack_linkc(devpriv->ao_mite_chan, s_ao);
+			if (m_status & CHSR_LINKC)
 				mite_sync_dma(devpriv->ao_mite_chan, s_ao);
 		}
 
@@ -5192,9 +5188,12 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 	ack_b_interrupt(dev, b_status);
 	if ((a_status & NISTC_AI_STATUS1_INTA) || (ai_mite_status & CHSR_INT))
 		handle_a_interrupt(dev, a_status, ai_mite_status);
-	if (s_ao &&
-	    ((b_status & NISTC_AO_STATUS1_INTB) || (ao_mite_status & CHSR_INT)))
-		handle_b_interrupt(dev, s_ao, b_status, ao_mite_status);
+	if (s_ao) {
+		if (b_status & NISTC_AO_STATUS1_INTB)
+			handle_b_interrupt(dev, s_ao, b_status);
+		/* handle any interrupt or dma events */
+		comedi_handle_events(dev, s_ao);
+	}
 	handle_gpct_interrupt(dev, 0);
 	handle_gpct_interrupt(dev, 1);
 #ifdef PCIDMA

commit 7ef1745f29d12b31361d0cf3a2bc259a396aac10
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 21 12:04:39 2016 -0700

    staging: comedi: ni_mio_common: fix interrupt handler for dev->write_subdev
    
    There may not be a dev->write_subdev, i.e. an analog output subdevice, that
    supports async commands. If it doesn't exist the interrupt/dma will never
    be enabled.  Fix ni_E_interrupt() so that the analog output subdevice is
    only handled if it exists.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b2657de7cca1..5f6eedb422a3 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1386,11 +1386,10 @@ static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
 }
 
 static void handle_b_interrupt(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
 			       unsigned short b_status,
 			       unsigned int ao_mite_status)
 {
-	struct comedi_subdevice *s = dev->write_subdev;
-
 	if (b_status == 0xffff)
 		return;
 	if (b_status & NISTC_AO_STATUS1_OVERRUN) {
@@ -5152,6 +5151,7 @@ static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static irqreturn_t ni_E_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct comedi_subdevice *s_ao = dev->write_subdev;
 	unsigned short a_status;
 	unsigned short b_status;
 	unsigned int ai_mite_status = 0;
@@ -5178,12 +5178,11 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 			ai_mite_status = mite_ack_linkc(devpriv->ai_mite_chan,
 							dev->read_subdev);
 
-		if (devpriv->ao_mite_chan) {
+		if (s_ao && devpriv->ao_mite_chan) {
 			ao_mite_status = mite_ack_linkc(devpriv->ao_mite_chan,
-							dev->write_subdev);
+							s_ao);
 			if (ao_mite_status & CHSR_LINKC)
-				mite_sync_dma(devpriv->ao_mite_chan,
-					      dev->write_subdev);
+				mite_sync_dma(devpriv->ao_mite_chan, s_ao);
 		}
 
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);
@@ -5193,8 +5192,9 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 	ack_b_interrupt(dev, b_status);
 	if ((a_status & NISTC_AI_STATUS1_INTA) || (ai_mite_status & CHSR_INT))
 		handle_a_interrupt(dev, a_status, ai_mite_status);
-	if ((b_status & NISTC_AO_STATUS1_INTB) || (ao_mite_status & CHSR_INT))
-		handle_b_interrupt(dev, b_status, ao_mite_status);
+	if (s_ao &&
+	    ((b_status & NISTC_AO_STATUS1_INTB) || (ao_mite_status & CHSR_INT)))
+		handle_b_interrupt(dev, s_ao, b_status, ao_mite_status);
 	handle_gpct_interrupt(dev, 0);
 	handle_gpct_interrupt(dev, 1);
 #ifdef PCIDMA

commit 72639a16704b10cf5fffaa52715929dc8f081528
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 21 12:04:38 2016 -0700

    staging: comedi: ni_mio_common: absorb mite_handle_b_linkc()
    
    Simplfy the LINKC handing by removing the helper function and moving
    the mite_sync_dma() into the main interrupt handler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2e27815bd632..b2657de7cca1 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -927,19 +927,6 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 	return retval;
 }
 
-static void mite_handle_b_linkc(struct mite_struct *mite,
-				struct comedi_device *dev)
-{
-	struct ni_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->write_subdev;
-	unsigned long flags;
-
-	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	if (devpriv->ao_mite_chan)
-		mite_sync_dma(devpriv->ao_mite_chan, s);
-	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-}
-
 static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 {
 	static const int timeout = 10000;
@@ -1403,16 +1390,6 @@ static void handle_b_interrupt(struct comedi_device *dev,
 			       unsigned int ao_mite_status)
 {
 	struct comedi_subdevice *s = dev->write_subdev;
-	/* unsigned short ack=0; */
-
-#ifdef PCIDMA
-	/* Currently, mite.c requires us to handle LINKC */
-	if (ao_mite_status & CHSR_LINKC) {
-		struct ni_private *devpriv = dev->private;
-
-		mite_handle_b_linkc(devpriv->mite, dev);
-	}
-#endif
 
 	if (b_status == 0xffff)
 		return;
@@ -5200,9 +5177,15 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 		if (devpriv->ai_mite_chan)
 			ai_mite_status = mite_ack_linkc(devpriv->ai_mite_chan,
 							dev->read_subdev);
-		if (devpriv->ao_mite_chan)
+
+		if (devpriv->ao_mite_chan) {
 			ao_mite_status = mite_ack_linkc(devpriv->ao_mite_chan,
 							dev->write_subdev);
+			if (ao_mite_status & CHSR_LINKC)
+				mite_sync_dma(devpriv->ao_mite_chan,
+					      dev->write_subdev);
+		}
+
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);
 	}
 #endif

commit cc38da7287ed4f0f08956351167c31e4e6abc427
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 21 12:04:37 2016 -0700

    staging: comedi: mite: check for transfer errors in mite_ack_linkc()
    
    Currently only some of the users of mite dma check for transfer errors.
    
    The ni_mio_common code does the check for the analog input and analog
    output subdevices. The m-series digital I/O subdevice and the counter
    subdevices (handled by ni_tiocmd) do not check.
    
    The ni_pcidio driver checks for the digital input subdevice.
    
    The ni_660x driver counter subdevices (handled by ni_tiocmd) also do
    not check.
    
    Move the transfer error checking into mite_ack_linkc() so that the
    drivers that use mite don't have to deal with it. This also makes
    sure that all the subdevices that use mite for dma will cancel the
    async command if a transfer error is detected.
    
    Simplfy the transfer error check by just checking the CHSR_XFERR bit.
    This bit will be set if one or more transfer processes terminated with
    an error. The actual error is determined by the LERR, MERR, and DERR
    bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 3312f978754b..2e27815bd632 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1317,16 +1317,6 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 #ifdef PCIDMA
 	if (ai_mite_status & CHSR_LINKC)
 		ni_sync_ai_dma(dev);
-
-	if (ai_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
-			       CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
-			       CHSR_SABORT | CHSR_XFERR | CHSR_LERR_MASK)) {
-		dev_err(dev->class_dev,
-			"unknown mite interrupt (ai_mite_status=%08x)\n",
-			ai_mite_status);
-		s->async->events |= COMEDI_CB_ERROR;
-		/* disable_irq(dev->irq); */
-	}
 #endif
 
 	/* test for all uncommon interrupt events at the same time */
@@ -1422,15 +1412,6 @@ static void handle_b_interrupt(struct comedi_device *dev,
 
 		mite_handle_b_linkc(devpriv->mite, dev);
 	}
-
-	if (ao_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
-			       CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
-			       CHSR_SABORT | CHSR_XFERR | CHSR_LERR_MASK)) {
-		dev_err(dev->class_dev,
-			"unknown mite interrupt (ao_mite_status=%08x)\n",
-			ao_mite_status);
-		s->async->events |= COMEDI_CB_ERROR;
-	}
 #endif
 
 	if (b_status == 0xffff)
@@ -3697,7 +3678,7 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
-		mite_ack_linkc(devpriv->cdo_mite_chan);
+		mite_ack_linkc(devpriv->cdo_mite_chan, s);
 		mite_sync_dma(devpriv->cdo_mite_chan, s);
 	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
@@ -5217,9 +5198,11 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 
 		spin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);
 		if (devpriv->ai_mite_chan)
-			ai_mite_status = mite_ack_linkc(devpriv->ai_mite_chan);
+			ai_mite_status = mite_ack_linkc(devpriv->ai_mite_chan,
+							dev->read_subdev);
 		if (devpriv->ao_mite_chan)
-			ao_mite_status = mite_ack_linkc(devpriv->ao_mite_chan);
+			ao_mite_status = mite_ack_linkc(devpriv->ao_mite_chan,
+							dev->write_subdev);
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);
 	}
 #endif

commit 51d430056c2a695ff7ffc62ae917c413616ec6b2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 20 10:36:39 2016 -0700

    staging: comedi: mite: introduce mite_sync_dma()
    
    The struct mite_channel 'dir' member specifies if the dma is input
    or output. Wrap the mite_sync_input_dma() and mite_sync_output_dma()
    functions with a single mite_sync_dma() so that the drivers don't
    have to worry about the sync direction.
    
    The functions that actually sync the input/output dma currently return
    -1 if an overflow/underrun is detected otherwise they return 0. If an
    overflow/underrun is detected the async->event COMEDI_CB_OVERFLOW is
    also set.
    
    The callers never check the return value anyway so just make the
    functions return void. The async->event can be checked if necessary
    to detect any errors.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7f7296e96b25..3312f978754b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -890,7 +890,7 @@ static void ni_sync_ai_dma(struct comedi_device *dev)
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ai_mite_chan)
-		mite_sync_input_dma(devpriv->ai_mite_chan, s);
+		mite_sync_dma(devpriv->ai_mite_chan, s);
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
@@ -936,7 +936,7 @@ static void mite_handle_b_linkc(struct mite_struct *mite,
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ao_mite_chan)
-		mite_sync_output_dma(devpriv->ao_mite_chan, s);
+		mite_sync_dma(devpriv->ao_mite_chan, s);
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
@@ -3698,7 +3698,7 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
 		mite_ack_linkc(devpriv->cdo_mite_chan);
-		mite_sync_output_dma(devpriv->cdo_mite_chan, s);
+		mite_sync_dma(devpriv->cdo_mite_chan, s);
 	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 

commit 4d88096df9ca49b71381eda90aa770c6db237f54
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 20 10:36:37 2016 -0700

    staging: comedi: mite: introduce mite_ack_linkc()
    
    Introduce a helper function to handle the ack of a LINKC interrupt.
    Tidy up the drivers that use the new helper.
    
    The extra check for CHSR_INT in the ni_pcidio driver is not necessary.
    This bit will be set if any of the interrupt sources, including CHSR_LINKC,
    have generated an interrupt. Remove the extra check.
    
    The mite_get_status() function is now only used by the mite driver.
    Make it static and remove the export.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 081ed3f37817..7f7296e96b25 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3697,13 +3697,7 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
-		unsigned int cdo_mite_status =
-		    mite_get_status(devpriv->cdo_mite_chan);
-		if (cdo_mite_status & CHSR_LINKC) {
-			writel(CHOR_CLRLC,
-			       devpriv->mite->mite_io_addr +
-			       MITE_CHOR(devpriv->cdo_mite_chan->channel));
-		}
+		mite_ack_linkc(devpriv->cdo_mite_chan);
 		mite_sync_output_dma(devpriv->cdo_mite_chan, s);
 	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
@@ -5222,22 +5216,10 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 		unsigned long flags_too;
 
 		spin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);
-		if (devpriv->ai_mite_chan) {
-			ai_mite_status = mite_get_status(devpriv->ai_mite_chan);
-			if (ai_mite_status & CHSR_LINKC)
-				writel(CHOR_CLRLC,
-				       devpriv->mite->mite_io_addr +
-				       MITE_CHOR(devpriv->
-						 ai_mite_chan->channel));
-		}
-		if (devpriv->ao_mite_chan) {
-			ao_mite_status = mite_get_status(devpriv->ao_mite_chan);
-			if (ao_mite_status & CHSR_LINKC)
-				writel(CHOR_CLRLC,
-				       devpriv->mite->mite_io_addr +
-				       MITE_CHOR(devpriv->
-						 ao_mite_chan->channel));
-		}
+		if (devpriv->ai_mite_chan)
+			ai_mite_status = mite_ack_linkc(devpriv->ai_mite_chan);
+		if (devpriv->ao_mite_chan)
+			ao_mite_status = mite_ack_linkc(devpriv->ao_mite_chan);
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);
 	}
 #endif

commit 6f7fa704648e69a295f6b8bcf35538692258fbb3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:58:07 2016 -0700

    staging: comedi: ni_mio_common: introduce NI_STC_DMA_CHAN_SEL()
    
    The inline helper ni_stc_dma_channel_select_bitfield() returns the
    bits needed to select a MITE channel to use for DMA. The MITE code
    is setup to handle up to 8 channels but in reality only channels 0
    to 3 are used by most of the drivers. The PCI-6032E and PCI-6033E
    boards can also use channels 4 and 5.
    
    For aesthetics, convert this inline function into a macro and
    remove the BUG() which will never occur.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d3313866ec09..081ed3f37817 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -560,20 +560,13 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 }
 
 #ifdef PCIDMA
-/* DMA channel setup */
-static inline unsigned int
-ni_stc_dma_channel_select_bitfield(unsigned int channel)
-{
-	if (channel < 4)
-		return 1 << channel;
-	if (channel == 4)
-		return 0x3;
-	if (channel == 5)
-		return 0x5;
-	BUG();
-	return 0;
-}
 
+/* selects the MITE channel to use for DMA */
+#define NI_STC_DMA_CHAN_SEL(x)	(((x) < 4) ? BIT(x) :	\
+				 ((x) == 4) ? 0x3 :	\
+				 ((x) == 5) ? 0x5 : 0x0)
+
+/* DMA channel setup */
 static int ni_request_ai_mite_channel(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
@@ -592,7 +585,7 @@ static int ni_request_ai_mite_channel(struct comedi_device *dev)
 	mite_chan->dir = COMEDI_INPUT;
 	devpriv->ai_mite_chan = mite_chan;
 
-	bits = ni_stc_dma_channel_select_bitfield(mite_chan->channel);
+	bits = NI_STC_DMA_CHAN_SEL(mite_chan->channel);
 	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,
 			NI_E_DMA_AI_SEL_MASK, NI_E_DMA_AI_SEL(bits));
 
@@ -618,7 +611,7 @@ static int ni_request_ao_mite_channel(struct comedi_device *dev)
 	mite_chan->dir = COMEDI_OUTPUT;
 	devpriv->ao_mite_chan = mite_chan;
 
-	bits = ni_stc_dma_channel_select_bitfield(mite_chan->channel);
+	bits = NI_STC_DMA_CHAN_SEL(mite_chan->channel);
 	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,
 			NI_E_DMA_AO_SEL_MASK, NI_E_DMA_AO_SEL(bits));
 
@@ -648,7 +641,7 @@ static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 	mite_chan->dir = direction;
 	ni_tio_set_mite_channel(counter, mite_chan);
 
-	bits = ni_stc_dma_channel_select_bitfield(mite_chan->channel);
+	bits = NI_STC_DMA_CHAN_SEL(mite_chan->channel);
 	ni_set_bitfield(dev, NI_E_DMA_G0_G1_SEL_REG,
 			NI_E_DMA_G0_G1_SEL_MASK(gpct_index),
 			NI_E_DMA_G0_G1_SEL(gpct_index, bits));
@@ -676,12 +669,12 @@ static int ni_request_cdo_mite_channel(struct comedi_device *dev)
 	devpriv->cdo_mite_chan = mite_chan;
 
 	/*
-	 * XXX just guessing ni_stc_dma_channel_select_bitfield()
+	 * XXX just guessing NI_STC_DMA_CHAN_SEL()
 	 * returns the right bits, under the assumption the cdio dma
 	 * selection works just like ai/ao/gpct.
 	 * Definitely works for dma channels 0 and 1.
 	 */
-	bits = ni_stc_dma_channel_select_bitfield(mite_chan->channel);
+	bits = NI_STC_DMA_CHAN_SEL(mite_chan->channel);
 	ni_set_bitfield(dev, NI_M_CDIO_DMA_SEL_REG,
 			NI_M_CDIO_DMA_SEL_CDO_MASK,
 			NI_M_CDIO_DMA_SEL_CDO(bits));

commit bbd962206c6002005a827d34d91005cbfbf9dddc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:58:06 2016 -0700

    staging: comedi: mite.h: rename CHSR_LxERR_mask
    
    Fix the checkpatch.pl issue:
    CHECK: Avoid CamelCase: <CHSR_LxERR_mask>
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d2b359a0e7a3..d3313866ec09 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1327,7 +1327,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 
 	if (ai_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
 			       CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
-			       CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
+			       CHSR_SABORT | CHSR_XFERR | CHSR_LERR_MASK)) {
 		dev_err(dev->class_dev,
 			"unknown mite interrupt (ai_mite_status=%08x)\n",
 			ai_mite_status);
@@ -1432,7 +1432,7 @@ static void handle_b_interrupt(struct comedi_device *dev,
 
 	if (ao_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
 			       CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
-			       CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
+			       CHSR_SABORT | CHSR_XFERR | CHSR_LERR_MASK)) {
 		dev_err(dev->class_dev,
 			"unknown mite interrupt (ao_mite_status=%08x)\n",
 			ao_mite_status);

commit b24a3ecd460689b08c5ffd3f735d4228f8bfffc7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:58:05 2016 -0700

    staging: comedi: ni_mio_common: fix CamelCase in ni_serial_hw_readwrite8()
    
    Fix the checkpatch.pl issue:
    CHECK: Avoid CamelCase: <Error>
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 655a1a1d0c61..d2b359a0e7a3 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3747,7 +3747,7 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 	status1 = ni_stc_readw(dev, NISTC_STATUS1_REG);
 	if (status1 & NISTC_STATUS1_SERIO_IN_PROG) {
 		err = -EBUSY;
-		goto Error;
+		goto error;
 	}
 
 	devpriv->dio_control |= NISTC_DIO_CTRL_HW_SER_START;
@@ -3763,7 +3763,7 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 			dev_err(dev->class_dev,
 				"SPI serial I/O didn't finish in time!\n");
 			err = -ETIME;
-			goto Error;
+			goto error;
 		}
 	}
 
@@ -3776,7 +3776,7 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 	if (data_in)
 		*data_in = ni_stc_readw(dev, NISTC_DIO_SERIAL_IN_REG);
 
-Error:
+error:
 	ni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);
 
 	return err;

commit 68556ffc95771c55843f1be459d13938fac83f77
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:58:04 2016 -0700

    staging: comedi: ni_mio_common: remove 'fudge_factor_80_to_20Mhz'
    
    For aesthetics, remove this local variable to fix the checkpatch.pl issue:
    CHECK: Avoid CamelCase: <fudge_factor_80_to_20Mhz>
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8a8ba26ac222..655a1a1d0c61 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4831,7 +4831,6 @@ static int ni_mseries_get_pll_parameters(unsigned int reference_period_ns,
 	 * divided by 4 to 20 MHz for most timing clocks
 	 */
 	static const unsigned int target_picosec = 12500;
-	static const unsigned int fudge_factor_80_to_20Mhz = 4;
 	int best_period_picosec = 0;
 
 	for (div = 1; div <= NI_M_PLL_MAX_DIVISOR; ++div) {
@@ -4851,8 +4850,8 @@ static int ni_mseries_get_pll_parameters(unsigned int reference_period_ns,
 
 	*freq_divider = best_div;
 	*freq_multiplier = best_mult;
-	*actual_period_ns = DIV_ROUND_CLOSEST(best_period_picosec *
-					      fudge_factor_80_to_20Mhz,
+	/* return the actual period (* fudge factor for 80 to 20 MHz) */
+	*actual_period_ns = DIV_ROUND_CLOSEST(best_period_picosec * 4,
 					      pico_per_nano);
 	return 0;
 }

commit 8a5b817ff7f6c902b478bae1b58c41b4298ae62e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:58:03 2016 -0700

    staging: comedi: ni_mio_common: usleep_range is preferred over udelay
    
    Fix the checkpatch.pl issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 559efb43b971..8a8ba26ac222 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -962,7 +962,7 @@ static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 		 * If we poll too often, the pci bus activity seems
 		 * to slow the dma transfer down.
 		 */
-		udelay(10);
+		usleep_range(10, 100);
 	}
 	if (i == timeout) {
 		dev_err(dev->class_dev, "timed out waiting for dma load\n");
@@ -3629,7 +3629,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 		if (ni_readl(dev, NI_M_CDIO_STATUS_REG) &
 		    NI_M_CDIO_STATUS_CDO_FIFO_FULL)
 			break;
-		udelay(10);
+		usleep_range(10, 100);
 	}
 	if (i == timeout) {
 		dev_err(dev->class_dev, "dma failed to fill cdo fifo!\n");

commit 2e2f7b70374bc420d4695675ccc5b35756badef6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:58:02 2016 -0700

    staging: comedi: ni_mio_common: tidy up ni_gpct_write_register()
    
    The 'bits' value passed to this function is properly set by the callers
    so the BUG_ON() can never occur when writing to the NITIO_G[01]_INT_ENA
    and NITIO_G01_RESET registers. Remove the BUG_ON() checks.
    
    For aesthetic, also remove the static const variables. They don't add
    any additional clarity.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 1e2e89fccb5b..559efb43b971 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3993,10 +3993,6 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned int bits,
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
 	unsigned int stc_register = ni_gpct_to_stc_register(dev, reg);
-	static const unsigned int gpct_interrupt_a_enable_mask =
-	    NISTC_INTA_ENA_G0_GATE | NISTC_INTA_ENA_G0_TC;
-	static const unsigned int gpct_interrupt_b_enable_mask =
-	    NISTC_INTB_ENA_G1_GATE | NISTC_INTB_ENA_G1_TC;
 
 	if (stc_register == 0)
 		return;
@@ -4024,18 +4020,15 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned int bits,
 
 		/* 16 bit registers */
 	case NITIO_G0_INT_ENA:
-		BUG_ON(bits & ~gpct_interrupt_a_enable_mask);
 		ni_set_bitfield(dev, stc_register,
-				gpct_interrupt_a_enable_mask, bits);
+				NISTC_INTA_ENA_G0_GATE | NISTC_INTA_ENA_G0_TC,
+				bits);
 		break;
 	case NITIO_G1_INT_ENA:
-		BUG_ON(bits & ~gpct_interrupt_b_enable_mask);
 		ni_set_bitfield(dev, stc_register,
-				gpct_interrupt_b_enable_mask, bits);
+				NISTC_INTB_ENA_G1_GATE | NISTC_INTB_ENA_G1_TC,
+				bits);
 		break;
-	case NITIO_G01_RESET:
-		BUG_ON(bits & ~(NISTC_RESET_G0 | NISTC_RESET_G1));
-		/* fall-through */
 	default:
 		ni_stc_writew(dev, bits, stc_register);
 	}

commit 1392dccbbd70a064864ac698e2897a22a8ce370c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:58:01 2016 -0700

    staging: comedi: ni_mio_common: tidy up AO scan begin
    
    The (*do_cmdtest) validates that the cmd->scan_begin_src will only be
    TRIG_TIMER or TRIG_EXT. Refactor ni_ao_cmd_set_update() and remove the
    BUG() which can never occur.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c89bd1fbffee..1e2e89fccb5b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3099,8 +3099,9 @@ static void ni_ao_cmd_set_update(struct comedi_device *dev,
 	  NISTC_AO_MODE1_UPDATE_SRC_POLARITY
 	);
 
-	switch (cmd->scan_begin_src) {
-	case TRIG_TIMER:
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		unsigned int trigvar;
+
 		devpriv->ao_cmd2  &= ~NISTC_AO_CMD2_BC_GATE_ENA;
 
 		/*
@@ -3131,35 +3132,25 @@ static void ni_ao_cmd_set_update(struct comedi_device *dev,
 		 * eseries/ni67xx and tMSeries.h for mseries.
 		 */
 
-		{
-			unsigned int trigvar;
-
-			trigvar = ni_ns_to_timer(dev, cmd->scan_begin_arg,
-						 CMDF_ROUND_NEAREST);
+		trigvar = ni_ns_to_timer(dev, cmd->scan_begin_arg,
+					 CMDF_ROUND_NEAREST);
 
-			/*
-			 * Wait N TB3 ticks after the start trigger before
-			 * clocking(N must be >=2).
-			 */
-			/* following line: 2-1 per STC */
-			ni_stc_writel(dev, 1,           NISTC_AO_UI_LOADA_REG);
-			ni_stc_writew(dev, NISTC_AO_CMD1_UI_LOAD,
-				      NISTC_AO_CMD1_REG);
-			/* following line: N-1 per STC */
-			ni_stc_writel(dev, trigvar - 1, NISTC_AO_UI_LOADA_REG);
-		}
-		break;
-	case TRIG_EXT:
+		/*
+		 * Wait N TB3 ticks after the start trigger before
+		 * clocking (N must be >=2).
+		 */
+		/* following line: 2-1 per STC */
+		ni_stc_writel(dev, 1, NISTC_AO_UI_LOADA_REG);
+		ni_stc_writew(dev, NISTC_AO_CMD1_UI_LOAD, NISTC_AO_CMD1_REG);
+		/* following line: N-1 per STC */
+		ni_stc_writel(dev, trigvar - 1, NISTC_AO_UI_LOADA_REG);
+	} else { /* TRIG_EXT */
 		/* FIXME:  assert scan_begin_arg != 0, ret failure otherwise */
 		devpriv->ao_cmd2  |= NISTC_AO_CMD2_BC_GATE_ENA;
 		devpriv->ao_mode1 |= NISTC_AO_MODE1_UPDATE_SRC(
 					CR_CHAN(cmd->scan_begin_arg));
 		if (cmd->scan_begin_arg & CR_INVERT)
 			devpriv->ao_mode1 |= NISTC_AO_MODE1_UPDATE_SRC_POLARITY;
-		break;
-	default:
-		BUG();
-		break;
 	}
 
 	ni_stc_writew(dev, devpriv->ao_cmd2, NISTC_AO_CMD2_REG);

commit 55f9e7d9d35ac681dc899c9874dec35976c27dda
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:58:00 2016 -0700

    staging: comedi: ni_mio_common: tidy up AO trigger selection
    
    The AO subdevice (*cancel), ni_ao_reset(), always sets the private
    data 'ao_trigger_select' to 0. So when a command is started the
    'trigsel' value in ni_ao_cmd_set_trigger() will always start as 0.
    Remove the unnecessary member from the private data.
    
    The (*do_cmdtest) validates that the cmd->start_src will only be
    TRIG_INT or TRIG_EXT. Refactor ni_ao_cmd_set_trigger() and remove
    the BUG() which can never occur.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8c2c4f697587..c89bd1fbffee 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2967,6 +2967,7 @@ static void ni_ao_cmd_set_trigger(struct comedi_device *dev,
 				  const struct comedi_cmd *cmd)
 {
 	struct ni_private *devpriv = dev->private;
+	unsigned int trigsel;
 
 	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
 
@@ -2980,39 +2981,20 @@ static void ni_ao_cmd_set_trigger(struct comedi_device *dev,
 	}
 	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
 
-	{
-		unsigned int trigsel = devpriv->ao_trigger_select;
-
-		switch (cmd->start_src) {
-		case TRIG_INT:
-		case TRIG_NOW:
-			trigsel &= ~(NISTC_AO_TRIG_START1_POLARITY |
-				     NISTC_AO_TRIG_START1_SEL_MASK);
-			trigsel |= NISTC_AO_TRIG_START1_EDGE |
-				   NISTC_AO_TRIG_START1_SYNC;
-			break;
-		case TRIG_EXT:
-			trigsel = NISTC_AO_TRIG_START1_SEL(
-					CR_CHAN(cmd->start_arg) + 1);
-			if (cmd->start_arg & CR_INVERT)
-				/*
-				 * 0=active high, 1=active low.
-				 * see daq-stc 3-24 (p186)
-				 */
-				trigsel |= NISTC_AO_TRIG_START1_POLARITY;
-			if (cmd->start_arg & CR_EDGE)
-				/* 0=edge detection disabled, 1=enabled */
-				trigsel |= NISTC_AO_TRIG_START1_EDGE;
-			break;
-		default:
-			BUG();
-			break;
-		}
-
-		devpriv->ao_trigger_select = trigsel;
-		ni_stc_writew(dev, devpriv->ao_trigger_select,
-			      NISTC_AO_TRIG_SEL_REG);
+	if (cmd->start_src == TRIG_INT) {
+		trigsel = NISTC_AO_TRIG_START1_EDGE |
+			  NISTC_AO_TRIG_START1_SYNC;
+	} else { /* TRIG_EXT */
+		trigsel = NISTC_AO_TRIG_START1_SEL(CR_CHAN(cmd->start_arg) + 1);
+		/* 0=active high, 1=active low. see daq-stc 3-24 (p186) */
+		if (cmd->start_arg & CR_INVERT)
+			trigsel |= NISTC_AO_TRIG_START1_POLARITY;
+		/* 0=edge detection disabled, 1=enabled */
+		if (cmd->start_arg & CR_EDGE)
+			trigsel |= NISTC_AO_TRIG_START1_EDGE;
 	}
+	ni_stc_writew(dev, trigsel, NISTC_AO_TRIG_SEL_REG);
+
 	/* AO_Delayed_START1 = 0, we do not support delayed start...yet */
 
 	/* sync */
@@ -3443,7 +3425,6 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ao_mode3 = NISTC_AO_MODE3_LAST_GATE_DISABLE;
 	else
 		devpriv->ao_mode3 = 0;
-	devpriv->ao_trigger_select = 0;
 
 	ni_stc_writew(dev, 0, NISTC_AO_PERSONAL_REG);
 	ni_stc_writew(dev, 0, NISTC_AO_CMD1_REG);

commit 0b235d5ce4e084535e27e0416449d3c3b0d133ea
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:57:59 2016 -0700

    staging: comedi: ni_mio_common: convert NI_GPCT_SUBDEV to a macro
    
    The 'counter_index' is always in range (0 to < NUM_GPCT, which is 2).
    
    For aesthetics, convert this inline function into a macro and remove
    the BUG() which can never occur.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c56a5187ed7f..8c2c4f697587 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -214,19 +214,7 @@ enum ni_common_subdevices {
 	NI_NUM_SUBDEVICES
 };
 
-static inline unsigned int NI_GPCT_SUBDEV(unsigned int counter_index)
-{
-	switch (counter_index) {
-	case 0:
-		return NI_GPCT0_SUBDEV;
-	case 1:
-		return NI_GPCT1_SUBDEV;
-	default:
-		break;
-	}
-	BUG();
-	return NI_GPCT0_SUBDEV;
-}
+#define NI_GPCT_SUBDEV(x)	(NI_GPCT0_SUBDEV + (x))
 
 enum timebase_nanoseconds {
 	TIMEBASE_1_NS = 50,

commit 73894987d6747f39fe7a08b5b25d33a2883d09e2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:57:58 2016 -0700

    staging: comedi: ni_mio_common: fix logical continuations
    
    Fix the checkpatch.pl issues:
    CHECK: Logical continuations should be on the previous line
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index f5320f266c23..c56a5187ed7f 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -925,9 +925,8 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 	if (devpriv->ai_mite_chan) {
 		for (i = 0; i < timeout; i++) {
 			if ((ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
-			     NISTC_AI_STATUS1_FIFO_E)
-			    && mite_bytes_in_transit(devpriv->ai_mite_chan) ==
-			    0)
+			     NISTC_AI_STATUS1_FIFO_E) &&
+			    mite_bytes_in_transit(devpriv->ai_mite_chan) == 0)
 				break;
 			udelay(5);
 		}
@@ -1809,8 +1808,8 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		return;
 	}
 	if (n_chan == 1 && !devpriv->is_611x && !devpriv->is_6143) {
-		if (devpriv->changain_state
-		    && devpriv->changain_spec == list[0]) {
+		if (devpriv->changain_state &&
+		    devpriv->changain_spec == list[0]) {
 			/*  ready to go. */
 			return;
 		}
@@ -1824,8 +1823,8 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 
 	/*  Set up Calibration mode if required */
 	if (devpriv->is_6143) {
-		if ((list[0] & CR_ALT_SOURCE)
-		    && !devpriv->ai_calib_source_enabled) {
+		if ((list[0] & CR_ALT_SOURCE) &&
+		    !devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay enable bit */
 			ni_writew(dev, devpriv->ai_calib_source |
 				       NI6143_CALIB_CHAN_RELAY_ON,
@@ -1835,8 +1834,8 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 			devpriv->ai_calib_source_enabled = 1;
 			/* Allow relays to change */
 			msleep_interruptible(100);
-		} else if (!(list[0] & CR_ALT_SOURCE)
-			   && devpriv->ai_calib_source_enabled) {
+		} else if (!(list[0] & CR_ALT_SOURCE) &&
+			   devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay disable bit */
 			ni_writew(dev, devpriv->ai_calib_source |
 				       NI6143_CALIB_CHAN_RELAY_OFF,

commit beb1cc1b020e32261fc6c45020501b507ae54d65
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:57:57 2016 -0700

    staging: comedi: ni_mio_common: multiple assignments should be avoided
    
    Fix the checkpatch.pl issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index fa2aad4b3ec8..f5320f266c23 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4478,12 +4478,12 @@ static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 	s->n_chan = n_chans;
 
 	if (diffbits) {
-		unsigned int *maxdata_list;
+		unsigned int *maxdata_list = devpriv->caldac_maxdata_list;
 
 		if (n_chans > MAX_N_CALDACS)
 			dev_err(dev->class_dev,
 				"BUG! MAX_N_CALDACS too small\n");
-		s->maxdata_list = maxdata_list = devpriv->caldac_maxdata_list;
+		s->maxdata_list = maxdata_list;
 		chan = 0;
 		for (i = 0; i < n_dacs; i++) {
 			type = board->caldac[i];

commit b6a0e5b32a206507b21474ad04a4854fbbda2e69
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:57:56 2016 -0700

    staging: comedi: ni_mio_common: fix lines over 80 characters
    
    Fix the checkpatch.pl issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index dce8a864eef6..fa2aad4b3ec8 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -877,16 +877,17 @@ static inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)
 	return data;
 }
 
-/* ni_set_bits( ) allows different parts of the ni_mio_common driver to
-* share registers (such as Interrupt_A_Register) without interfering with
-* each other.
-*
-* NOTE: the switch/case statements are optimized out for a constant argument
-* so this is actually quite fast---  If you must wrap another function around this
-* make it inline to avoid a large speed penalty.
-*
-* value should only be 1 or 0.
-*/
+/*
+ * ni_set_bits( ) allows different parts of the ni_mio_common driver to
+ * share registers (such as Interrupt_A_Register) without interfering with
+ * each other.
+ *
+ * NOTE: the switch/case statements are optimized out for a constant argument
+ * so this is actually quite fast---  If you must wrap another function around
+ * this make it inline to avoid a large speed penalty.
+ *
+ * value should only be 1 or 0.
+ */
 static inline void ni_set_bits(struct comedi_device *dev, int reg,
 			       unsigned int bits, unsigned int value)
 {
@@ -1102,7 +1103,10 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 			comedi_buf_write_samples(s, &data, 1);
 		}
 	} else if (devpriv->is_6143) {
-		/*  This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed */
+		/*
+		 * This just reads the FIFO assuming the data is present,
+		 * no checks on the FIFO status are performed.
+		 */
 		for (i = 0; i < n / 2; i++) {
 			dl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);
 
@@ -1153,7 +1157,6 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int dl;
 	unsigned short data;
-	unsigned short fifo_empty;
 	int i;
 
 	if (devpriv->is_611x) {
@@ -1189,15 +1192,16 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 		}
 
 	} else {
-		fifo_empty = ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
-			     NISTC_AI_STATUS1_FIFO_E;
-		while (fifo_empty == 0) {
+		unsigned short fe;	/* fifo empty */
+
+		fe = ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
+		     NISTC_AI_STATUS1_FIFO_E;
+		while (fe == 0) {
 			for (i = 0;
 			     i < ARRAY_SIZE(devpriv->ai_fifo_buffer); i++) {
-				fifo_empty = ni_stc_readw(dev,
-							  NISTC_AI_STATUS1_REG) &
-						NISTC_AI_STATUS1_FIFO_E;
-				if (fifo_empty)
+				fe = ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
+				     NISTC_AI_STATUS1_FIFO_E;
+				if (fe)
 					break;
 				devpriv->ai_fifo_buffer[i] =
 				    ni_readw(dev, NI_E_AI_FIFO_DATA_REG);
@@ -1323,7 +1327,10 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	/* 67xx boards don't have ai subdevice, but their gpct0 might generate an a interrupt */
+	/*
+	 * 67xx boards don't have ai subdevice, but their gpct0 might
+	 * generate an a interrupt.
+	 */
 	if (s->type == COMEDI_SUBD_UNUSED)
 		return;
 
@@ -1826,7 +1833,8 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 			ni_writew(dev, devpriv->ai_calib_source,
 				  NI6143_CALIB_CHAN_REG);
 			devpriv->ai_calib_source_enabled = 1;
-			msleep_interruptible(100);	/*  Allow relays to change */
+			/* Allow relays to change */
+			msleep_interruptible(100);
 		} else if (!(list[0] & CR_ALT_SOURCE)
 			   && devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay disable bit */
@@ -1836,7 +1844,8 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 			ni_writew(dev, devpriv->ai_calib_source,
 				  NI6143_CALIB_CHAN_REG);
 			devpriv->ai_calib_source_enabled = 0;
-			msleep_interruptible(100);	/*  Allow relays to change */
+			/* Allow relays to change */
+			msleep_interruptible(100);
 		}
 	}
 
@@ -1957,7 +1966,11 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			ni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,
 				      NISTC_AI_CMD1_REG);
 
-			/* The 6143 has 32-bit FIFOs. You need to strobe a bit to move a single 16bit stranded sample into the FIFO */
+			/*
+			 * The 6143 has 32-bit FIFOs. You need to strobe a
+			 * bit to move a single 16bit stranded sample into
+			 * the FIFO.
+			 */
 			dl = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
 				if (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) &
@@ -1995,7 +2008,8 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				data[n] = dl;
 			} else {
 				d = ni_readw(dev, NI_E_AI_FIFO_DATA_REG);
-				d += signbits;	/* subtle: needs to be short addition */
+				/* subtle: needs to be short addition */
+				d += signbits;
 				data[n] = d;
 			}
 		}
@@ -2331,7 +2345,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		if (stop_count == 0) {
 			devpriv->ai_cmd2 |= NISTC_AI_CMD2_END_ON_EOS;
 			interrupt_a_enable |= NISTC_INTA_ENA_AI_STOP;
-			/*  this is required to get the last sample for chanlist_len > 1, not sure why */
+			/*
+			 * This is required to get the last sample for
+			 * chanlist_len > 1, not sure why.
+			 */
 			if (cmd->chanlist_len > 1)
 				start_stop_select |= NISTC_AI_STOP_POLARITY |
 						     NISTC_AI_STOP_EDGE;
@@ -2451,7 +2468,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		switch (devpriv->aimode) {
 		case AIMODE_HALF_FULL:
-			/*generate FIFO interrupts and DMA requests on half-full */
+			/* FIFO interrupts and DMA requests on half-full */
 #ifdef PCIDMA
 			ni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_HF_E,
 				      NISTC_AI_MODE3_REG);
@@ -4905,7 +4922,10 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 
 	if (source == NI_MIO_PLL_PXI10_CLOCK)
 		period_ns = 100;
-	/*  these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that */
+	/*
+	 * These limits are somewhat arbitrary, but NI advertises 1 to 20MHz
+	 * range so we'll use that.
+	 */
 	if (period_ns < min_period_ns || period_ns > max_period_ns) {
 		dev_err(dev->class_dev,
 			"%s: you must specify an input clock frequency between %i and %i nanosec for the phased-lock loop\n",
@@ -4955,7 +4975,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 
 	ni_writew(dev, pll_control_bits, NI_M_PLL_CTRL_REG);
 	devpriv->clock_source = source;
-	/* it seems to typically take a few hundred microseconds for PLL to lock */
+	/* it takes a few hundred microseconds for PLL to lock */
 	for (i = 0; i < timeout; ++i) {
 		if (ni_readw(dev, NI_M_PLL_STATUS_REG) & NI_M_PLL_STATUS_LOCKED)
 			break;
@@ -5247,7 +5267,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 
 	if (!dev->attached)
 		return IRQ_NONE;
-	smp_mb();		/*  make sure dev->attached is checked before handler does anything else. */
+	smp_mb();		/* make sure dev->attached is checked */
 
 	/*  lock to avoid race with comedi_poll */
 	spin_lock_irqsave(&dev->spinlock, flags);

commit bd474a02d3a3cce9086b85d038fc0f37e4b74cef
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:57:55 2016 -0700

    staging: comedi: ni_mio_common: tidy up block comments
    
    Fix the checkpatch.pl issues.
    WARNING: Block comments use * on subsequent lines
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d7d89c656840..dce8a864eef6 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1,56 +1,53 @@
 /*
-    comedi/drivers/ni_mio_common.c
-    Hardware driver for DAQ-STC based boards
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 1997-2001 David A. Schleef <ds@schleef.org>
-    Copyright (C) 2002-2006 Frank Mori Hess <fmhess@users.sourceforge.net>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
+ * Hardware driver for DAQ-STC based boards
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 1997-2001 David A. Schleef <ds@schleef.org>
+ * Copyright (C) 2002-2006 Frank Mori Hess <fmhess@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
 /*
-	This file is meant to be included by another file, e.g.,
-	ni_atmio.c or ni_pcimio.c.
-
-	Interrupt support originally added by Truxton Fulton
-	<trux@truxton.com>
-
-	References (from ftp://ftp.natinst.com/support/manuals):
-
-	   340747b.pdf  AT-MIO E series Register Level Programmer Manual
-	   341079b.pdf  PCI E Series RLPM
-	   340934b.pdf  DAQ-STC reference manual
-	67xx and 611x registers (from ftp://ftp.ni.com/support/daq/mhddk/documentation/)
-	release_ni611x.pdf
-	release_ni67xx.pdf
-	Other possibly relevant info:
-
-	   320517c.pdf  User manual (obsolete)
-	   320517f.pdf  User manual (new)
-	   320889a.pdf  delete
-	   320906c.pdf  maximum signal ratings
-	   321066a.pdf  about 16x
-	   321791a.pdf  discontinuation of at-mio-16e-10 rev. c
-	   321808a.pdf  about at-mio-16e-10 rev P
-	   321837a.pdf  discontinuation of at-mio-16de-10 rev d
-	   321838a.pdf  about at-mio-16de-10 rev N
-
-	ISSUES:
-
-	 - the interrupt routine needs to be cleaned up
-
-	2006-02-07: S-Series PCI-6143: Support has been added but is not
-		fully tested as yet. Terry Barnaby, BEAM Ltd.
-*/
+ * This file is meant to be included by another file, e.g.,
+ * ni_atmio.c or ni_pcimio.c.
+ *
+ * Interrupt support originally added by Truxton Fulton <trux@truxton.com>
+ *
+ * References (ftp://ftp.natinst.com/support/manuals):
+ *   340747b.pdf  AT-MIO E series Register Level Programmer Manual
+ *   341079b.pdf  PCI E Series RLPM
+ *   340934b.pdf  DAQ-STC reference manual
+ *
+ * 67xx and 611x registers (ftp://ftp.ni.com/support/daq/mhddk/documentation/)
+ *   release_ni611x.pdf
+ *   release_ni67xx.pdf
+ *
+ * Other possibly relevant info:
+ *   320517c.pdf  User manual (obsolete)
+ *   320517f.pdf  User manual (new)
+ *   320889a.pdf  delete
+ *   320906c.pdf  maximum signal ratings
+ *   321066a.pdf  about 16x
+ *   321791a.pdf  discontinuation of at-mio-16e-10 rev. c
+ *   321808a.pdf  about at-mio-16e-10 rev P
+ *   321837a.pdf  discontinuation of at-mio-16de-10 rev d
+ *   321838a.pdf  about at-mio-16de-10 rev N
+ *
+ * ISSUES:
+ *   - the interrupt routine needs to be cleaned up
+ *
+ * 2006-02-07: S-Series PCI-6143: Support has been added but is not
+ * fully tested as yet. Terry Barnaby, BEAM Ltd.
+ */
 
 #include <linux/interrupt.h>
 #include <linux/sched.h>
@@ -828,8 +825,10 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 			ni_writeb(dev, 0, NI_M_STATIC_AI_CTRL_REG(0));
 			ni_writeb(dev, 1, NI_M_STATIC_AI_CTRL_REG(0));
 #if 0
-			/* the NI example code does 3 convert pulses for 625x boards,
-			   but that appears to be wrong in practice. */
+			/*
+			 * The NI example code does 3 convert pulses for 625x
+			 * boards, But that appears to be wrong in practice.
+			 */
 			ni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,
 				      NISTC_AI_CMD1_REG);
 			ni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,
@@ -971,8 +970,10 @@ static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 		b_status = ni_stc_readw(dev, NISTC_AO_STATUS1_REG);
 		if (b_status & NISTC_AO_STATUS1_FIFO_HF)
 			break;
-		/* if we poll too often, the pci bus activity seems
-		   to slow the dma transfer down */
+		/*
+		 * If we poll too often, the pci bus activity seems
+		 * to slow the dma transfer down.
+		 */
 		udelay(10);
 	}
 	if (i == timeout) {
@@ -1145,9 +1146,7 @@ static void ni_handle_fifo_half_full(struct comedi_device *dev)
 }
 #endif
 
-/*
-   Empties the AI fifo
-*/
+/* Empties the AI fifo */
 static void ni_handle_fifo_dregs(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
@@ -1348,8 +1347,10 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 		      NISTC_AI_STATUS1_SC_TC | NISTC_AI_STATUS1_START1)) {
 		if (status == 0xffff) {
 			dev_err(dev->class_dev, "Card removed?\n");
-			/* we probably aren't even running a command now,
-			 * so it's a good idea to be careful. */
+			/*
+			 * We probably aren't even running a command now,
+			 * so it's a good idea to be careful.
+			 */
 			if (comedi_is_subdevice_running(s)) {
 				s->async->events |= COMEDI_CB_ERROR;
 				comedi_handle_events(dev, s);
@@ -1378,8 +1379,11 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	if (status & NISTC_AI_STATUS1_FIFO_HF) {
 		int i;
 		static const int timeout = 10;
-		/* pcmcia cards (at least 6036) seem to stop producing interrupts if we
-		 *fail to get the fifo less than half full, so loop to be sure.*/
+		/*
+		 * PCMCIA cards (at least 6036) seem to stop producing
+		 * interrupts if we fail to get the fifo less than half
+		 * full, so loop to be sure.
+		 */
 		for (i = 0; i < timeout; ++i) {
 			ni_handle_fifo_half_full(dev);
 			if ((ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
@@ -1560,8 +1564,11 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 		if (devpriv->is_611x || devpriv->is_6713) {
 			mite_prep_dma(devpriv->ao_mite_chan, 32, 32);
 		} else {
-			/* doing 32 instead of 16 bit wide transfers from memory
-			   makes the mite do 32 bit pci transfers, doubling pci bandwidth. */
+			/*
+			 * Doing 32 instead of 16 bit wide transfers from
+			 * memory makes the mite do 32 bit pci transfers,
+			 * doubling pci bandwidth.
+			 */
 			mite_prep_dma(devpriv->ao_mite_chan, 16, 32);
 		}
 		mite_dma_arm(devpriv->ao_mite_chan);
@@ -1576,11 +1583,10 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 #endif /*  PCIDMA */
 
 /*
-   used for both cancel ioctl and board initialization
-
-   this is pretty harsh for a cancel, but it works...
+ * used for both cancel ioctl and board initialization
+ *
+ * this is pretty harsh for a cancel, but it works...
  */
-
 static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct ni_private *devpriv = dev->private;
@@ -2261,8 +2267,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* start configuration */
 	ni_stc_writew(dev, NISTC_RESET_AI_CFG_START, NISTC_RESET_REG);
 
-	/* disable analog triggering for now, since it
-	 * interferes with the use of pfi0 */
+	/*
+	 * Disable analog triggering for now, since it interferes
+	 * with the use of pfi0.
+	 */
 	devpriv->an_trig_etc_reg &= ~NISTC_ATRIG_ETC_ENA;
 	ni_stc_writew(dev, devpriv->an_trig_etc_reg, NISTC_ATRIG_ETC_REG);
 
@@ -2834,9 +2842,11 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
-	/* Null trig at beginning prevent ao start trigger from executing more than
-	   once per command (and doing things like trying to allocate the ao dma channel
-	   multiple times) */
+	/*
+	 * Null trig at beginning prevent ao start trigger from executing more
+	 * than once per command (and doing things like trying to allocate the
+	 * ao dma channel multiple times).
+	 */
 	s->async->inttrig = NULL;
 
 	ni_set_bits(dev, NISTC_INTB_ENA_REG,
@@ -3808,16 +3818,20 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 	udelay((devpriv->serial_interval_ns + 999) / 1000);
 
 	for (mask = 0x80; mask; mask >>= 1) {
-		/* Output current bit; note that we cannot touch s->state
-		   because it is a per-subdevice field, and serial is
-		   a separate subdevice from DIO. */
+		/*
+		 * Output current bit; note that we cannot touch s->state
+		 * because it is a per-subdevice field, and serial is
+		 * a separate subdevice from DIO.
+		 */
 		devpriv->dio_output &= ~NISTC_DIO_SDOUT;
 		if (data_out & mask)
 			devpriv->dio_output |= NISTC_DIO_SDOUT;
 		ni_stc_writew(dev, devpriv->dio_output, NISTC_DIO_OUT_REG);
 
-		/* Assert SDCLK (active low, inverted), wait for half of
-		   the delay, deassert SDCLK, and wait for the other half. */
+		/*
+		 * Assert SDCLK (active low, inverted), wait for half of
+		 * the delay, deassert SDCLK, and wait for the other half.
+		 */
 		devpriv->dio_control |= NISTC_DIO_SDCLK;
 		ni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);
 
@@ -3864,8 +3878,10 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 			data[1] = SERIAL_DISABLED;
 			devpriv->serial_interval_ns = data[1];
 		} else if (data[1] <= SERIAL_600NS) {
-			/* Warning: this clock speed is too fast to reliably
-			   control SCXI. */
+			/*
+			 * Warning: this clock speed is too fast to reliably
+			 * control SCXI.
+			 */
 			devpriv->dio_control &= ~NISTC_DIO_CTRL_HW_SER_TIMEBASE;
 			clk_fout |= NISTC_CLK_FOUT_SLOW_TIMEBASE;
 			clk_fout &= ~NISTC_CLK_FOUT_DIO_SER_OUT_DIV2;
@@ -3881,10 +3897,12 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 			devpriv->dio_control |= NISTC_DIO_CTRL_HW_SER_TIMEBASE;
 			clk_fout |= NISTC_CLK_FOUT_SLOW_TIMEBASE |
 				    NISTC_CLK_FOUT_DIO_SER_OUT_DIV2;
-			/* Note: NISTC_CLK_FOUT_DIO_SER_OUT_DIV2 only affects
-			   600ns/1.2us. If you turn divide_by_2 off with the
-			   slow clock, you will still get 10us, except then
-			   all your delays are wrong. */
+			/*
+			 * Note: NISTC_CLK_FOUT_DIO_SER_OUT_DIV2 only affects
+			 * 600ns/1.2us. If you turn divide_by_2 off with the
+			 * slow clock, you will still get 10us, except then
+			 * all your delays are wrong.
+			 */
 			data[1] = SERIAL_10US;
 			devpriv->serial_interval_ns = data[1];
 		} else {
@@ -4291,13 +4309,13 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 static int pack_mb88341(int addr, int val, int *bitstring)
 {
 	/*
-	   Fujitsu MB 88341
-	   Note that address bits are reversed.  Thanks to
-	   Ingo Keen for noticing this.
-
-	   Note also that the 88341 expects address values from
-	   1-12, whereas we use channel numbers 0-11.  The NI
-	   docs use 1-12, also, so be careful here.
+	 * Fujitsu MB 88341
+	 * Note that address bits are reversed.  Thanks to
+	 * Ingo Keen for noticing this.
+	 *
+	 * Note also that the 88341 expects address values from
+	 * 1-12, whereas we use channel numbers 0-11.  The NI
+	 * docs use 1-12, also, so be careful here.
 	 */
 	addr++;
 	*bitstring = ((addr & 0x1) << 11) |
@@ -4767,9 +4785,12 @@ static int cs5529_ai_insn_read(struct comedi_device *dev,
 	unsigned int channel_select;
 	const unsigned int INTERNAL_REF = 0x1000;
 
-	/* Set calibration adc source.  Docs lie, reference select bits 8 to 11
+	/*
+	 * Set calibration adc source.  Docs lie, reference select bits 8 to 11
 	 * do nothing. bit 12 seems to chooses internal reference voltage, bit
-	 * 13 causes the adc input to go overrange (maybe reads external reference?) */
+	 * 13 causes the adc input to go overrange (maybe reads external
+	 * reference?)
+	 */
 	if (insn->chanspec & CR_ALT_SOURCE)
 		channel_select = INTERNAL_REF;
 	else
@@ -4836,8 +4857,10 @@ static int ni_mseries_get_pll_parameters(unsigned int reference_period_ns,
 	static const unsigned int pico_per_nano = 1000;
 	const unsigned int reference_picosec = reference_period_ns *
 					       pico_per_nano;
-	/* m-series wants the phased-locked loop to output 80MHz, which is divided by 4 to
-	 * 20 MHz for most timing clocks */
+	/*
+	 * m-series wants the phased-locked loop to output 80MHz, which is
+	 * divided by 4 to 20 MHz for most timing clocks
+	 */
 	static const unsigned int target_picosec = 12500;
 	static const unsigned int fudge_factor_80_to_20Mhz = 4;
 	int best_period_picosec = 0;

commit 546615f9f9c6458b6a2dcdef5f64038858719136
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:57:54 2016 -0700

    staging: comedi: ni_mio_common: use 'unsigned int' instead of kernel types
    
    Generally comedi drivers use 'unsigned int' types instead of the kernel type
    'u32' for unsigned 32-bit values.
    
    For aesthetics, change all the 'u32' and 'uin32_t' types and fix the
    checkpatch.pl issues about:
    CHECK: Prefer kernel type 'u32' over 'uint32_t'
    
    The various i/o helpers use for reading and writing the 32/16/8-bit registers
    all start with an 'unsigned int' value for writing and finally return an
    'unsigned int' value. For aesthetics, change all the 'uint16_t' and 'uint8_t'
    types for insigned int and fix the checkpatch.pl issues about:
    CHECK: Prefer kernel type 'u16' over 'uint16_t'
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c8497ffc100e..d7d89c656840 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -243,7 +243,7 @@ enum timebase_nanoseconds {
 
 static const int num_adc_stages_611x = 3;
 
-static void ni_writel(struct comedi_device *dev, uint32_t data, int reg)
+static void ni_writel(struct comedi_device *dev, unsigned int data, int reg)
 {
 	if (dev->mmio)
 		writel(data, dev->mmio + reg);
@@ -251,7 +251,7 @@ static void ni_writel(struct comedi_device *dev, uint32_t data, int reg)
 		outl(data, dev->iobase + reg);
 }
 
-static void ni_writew(struct comedi_device *dev, uint16_t data, int reg)
+static void ni_writew(struct comedi_device *dev, unsigned int data, int reg)
 {
 	if (dev->mmio)
 		writew(data, dev->mmio + reg);
@@ -259,7 +259,7 @@ static void ni_writew(struct comedi_device *dev, uint16_t data, int reg)
 		outw(data, dev->iobase + reg);
 }
 
-static void ni_writeb(struct comedi_device *dev, uint8_t data, int reg)
+static void ni_writeb(struct comedi_device *dev, unsigned int data, int reg)
 {
 	if (dev->mmio)
 		writeb(data, dev->mmio + reg);
@@ -267,7 +267,7 @@ static void ni_writeb(struct comedi_device *dev, uint8_t data, int reg)
 		outb(data, dev->iobase + reg);
 }
 
-static uint32_t ni_readl(struct comedi_device *dev, int reg)
+static unsigned int ni_readl(struct comedi_device *dev, int reg)
 {
 	if (dev->mmio)
 		return readl(dev->mmio + reg);
@@ -275,7 +275,7 @@ static uint32_t ni_readl(struct comedi_device *dev, int reg)
 	return inl(dev->iobase + reg);
 }
 
-static uint16_t ni_readw(struct comedi_device *dev, int reg)
+static unsigned int ni_readw(struct comedi_device *dev, int reg)
 {
 	if (dev->mmio)
 		return readw(dev->mmio + reg);
@@ -283,7 +283,7 @@ static uint16_t ni_readw(struct comedi_device *dev, int reg)
 	return inw(dev->iobase + reg);
 }
 
-static uint8_t ni_readb(struct comedi_device *dev, int reg)
+static unsigned int ni_readb(struct comedi_device *dev, int reg)
 {
 	if (dev->mmio)
 		return readb(dev->mmio + reg);
@@ -458,7 +458,8 @@ static unsigned int m_series_stc_read(struct comedi_device *dev,
 	}
 }
 
-static void ni_stc_writew(struct comedi_device *dev, uint16_t data, int reg)
+static void ni_stc_writew(struct comedi_device *dev,
+			  unsigned int data, int reg)
 {
 	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
@@ -477,7 +478,8 @@ static void ni_stc_writew(struct comedi_device *dev, uint16_t data, int reg)
 	}
 }
 
-static void ni_stc_writel(struct comedi_device *dev, uint32_t data, int reg)
+static void ni_stc_writel(struct comedi_device *dev,
+			  unsigned int data, int reg)
 {
 	struct ni_private *devpriv = dev->private;
 
@@ -489,11 +491,11 @@ static void ni_stc_writel(struct comedi_device *dev, uint32_t data, int reg)
 	}
 }
 
-static uint16_t ni_stc_readw(struct comedi_device *dev, int reg)
+static unsigned int ni_stc_readw(struct comedi_device *dev, int reg)
 {
 	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
-	uint16_t val;
+	unsigned int val;
 
 	if (devpriv->is_m_series) {
 		val = m_series_stc_read(dev, reg);
@@ -510,10 +512,10 @@ static uint16_t ni_stc_readw(struct comedi_device *dev, int reg)
 	return val;
 }
 
-static uint32_t ni_stc_readl(struct comedi_device *dev, int reg)
+static unsigned int ni_stc_readl(struct comedi_device *dev, int reg)
 {
 	struct ni_private *devpriv = dev->private;
-	uint32_t val;
+	unsigned int val;
 
 	if (devpriv->is_m_series) {
 		val = m_series_stc_read(dev, reg);
@@ -779,7 +781,7 @@ static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 					  unsigned int gpct_index, short enable)
 {
 	struct ni_private *devpriv = dev->private;
-	uint16_t val = 0;
+	unsigned int val = 0;
 	int reg;
 
 	if (devpriv->is_m_series || gpct_index > 1)
@@ -839,8 +841,8 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 	}
 }
 
-static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data,
-				  int addr)
+static inline void ni_ao_win_outw(struct comedi_device *dev,
+				  unsigned int data, int addr)
 {
 	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
@@ -851,8 +853,8 @@ static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data,
 	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
-static inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data,
-				  int addr)
+static inline void ni_ao_win_outl(struct comedi_device *dev,
+				  unsigned int data, int addr)
 {
 	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
@@ -989,7 +991,7 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 	struct ni_private *devpriv = dev->private;
 	int i;
 	unsigned short d;
-	u32 packed_data;
+	unsigned int packed_data;
 
 	for (i = 0; i < n; i++) {
 		comedi_buf_read_samples(s, &d, 1);
@@ -1079,7 +1081,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 {
 	struct ni_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
-	u32 dl;
+	unsigned int dl;
 	unsigned short data;
 	int i;
 
@@ -1150,7 +1152,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	u32 dl;
+	unsigned int dl;
 	unsigned short data;
 	unsigned short fifo_empty;
 	int i;
@@ -1211,7 +1213,7 @@ static void get_last_sample_611x(struct comedi_device *dev)
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned short data;
-	u32 dl;
+	unsigned int dl;
 
 	if (!devpriv->is_611x)
 		return;
@@ -1229,7 +1231,7 @@ static void get_last_sample_6143(struct comedi_device *dev)
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned short data;
-	u32 dl;
+	unsigned int dl;
 
 	if (!devpriv->is_6143)
 		return;

commit fe20a34aff061814da31fa7e2ac5bd4e62c2c328
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:57:53 2016 -0700

    staging: comedi: ni_mio_common: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Fix the checkpatch.pl issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7ba6c6e8ef4b..c8497ffc100e 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -216,7 +216,8 @@ enum ni_common_subdevices {
 	NI_FREQ_OUT_SUBDEV,
 	NI_NUM_SUBDEVICES
 };
-static inline unsigned NI_GPCT_SUBDEV(unsigned counter_index)
+
+static inline unsigned int NI_GPCT_SUBDEV(unsigned int counter_index)
 {
 	switch (counter_index) {
 	case 0:
@@ -524,7 +525,8 @@ static uint32_t ni_stc_readl(struct comedi_device *dev, int reg)
 }
 
 static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
-				   unsigned bit_mask, unsigned bit_values)
+				   unsigned int bit_mask,
+				   unsigned int bit_values)
 {
 	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
@@ -572,7 +574,8 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 
 #ifdef PCIDMA
 /* DMA channel setup */
-static inline unsigned ni_stc_dma_channel_select_bitfield(unsigned channel)
+static inline unsigned int
+ni_stc_dma_channel_select_bitfield(unsigned int channel)
 {
 	if (channel < 4)
 		return 1 << channel;
@@ -637,7 +640,7 @@ static int ni_request_ao_mite_channel(struct comedi_device *dev)
 }
 
 static int ni_request_gpct_mite_channel(struct comedi_device *dev,
-					unsigned gpct_index,
+					unsigned int gpct_index,
 					enum comedi_io_direction direction)
 {
 	struct ni_private *devpriv = dev->private;
@@ -737,7 +740,7 @@ static void ni_release_ao_mite_channel(struct comedi_device *dev)
 
 #ifdef PCIDMA
 static void ni_release_gpct_mite_channel(struct comedi_device *dev,
-					 unsigned gpct_index)
+					 unsigned int gpct_index)
 {
 	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
@@ -773,7 +776,7 @@ static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 }
 
 static void ni_e_series_enable_second_irq(struct comedi_device *dev,
-					  unsigned gpct_index, short enable)
+					  unsigned int gpct_index, short enable)
 {
 	struct ni_private *devpriv = dev->private;
 	uint16_t val = 0;
@@ -884,9 +887,9 @@ static inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)
 * value should only be 1 or 0.
 */
 static inline void ni_set_bits(struct comedi_device *dev, int reg,
-			       unsigned bits, unsigned value)
+			       unsigned int bits, unsigned int value)
 {
-	unsigned bit_values;
+	unsigned int bit_values;
 
 	if (value)
 		bit_values = bits;
@@ -1314,7 +1317,7 @@ static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 }
 
 static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
-			       unsigned ai_mite_status)
+			       unsigned int ai_mite_status)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -1413,7 +1416,8 @@ static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
 }
 
 static void handle_b_interrupt(struct comedi_device *dev,
-			       unsigned short b_status, unsigned ao_mite_status)
+			       unsigned short b_status,
+			       unsigned int ao_mite_status)
 {
 	struct comedi_subdevice *s = dev->write_subdev;
 	/* unsigned short ack=0; */
@@ -1578,8 +1582,8 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct ni_private *devpriv = dev->private;
-	unsigned ai_personal;
-	unsigned ai_out_ctrl;
+	unsigned int ai_personal;
+	unsigned int ai_out_ctrl;
 
 	ni_release_ai_mite_channel(dev);
 	/* ai configuration */
@@ -1684,12 +1688,12 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 	unsigned int chan, range, aref;
 	unsigned int i;
 	unsigned int dither;
-	unsigned range_code;
+	unsigned int range_code;
 
 	ni_stc_writew(dev, 1, NISTC_CFG_MEM_CLR_REG);
 
 	if ((list[0] & CR_ALT_SOURCE)) {
-		unsigned bypass_bits;
+		unsigned int bypass_bits;
 
 		chan = CR_CHAN(list[0]);
 		range = CR_RANGE(list[0]);
@@ -1708,7 +1712,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 		ni_writel(dev, 0, NI_M_CFG_BYPASS_FIFO_REG);
 	}
 	for (i = 0; i < n_chan; i++) {
-		unsigned config_bits = 0;
+		unsigned int config_bits = 0;
 
 		chan = CR_CHAN(list[i]);
 		aref = CR_AREF(list[i]);
@@ -1897,7 +1901,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 	struct ni_private *devpriv = dev->private;
 	unsigned int mask = (s->maxdata + 1) >> 1;
 	int i, n;
-	unsigned signbits;
+	unsigned int signbits;
 	unsigned int d;
 	unsigned long dl;
 
@@ -1991,8 +1995,8 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int ni_ns_to_timer(const struct comedi_device *dev, unsigned nanosec,
-			  unsigned int flags)
+static int ni_ns_to_timer(const struct comedi_device *dev,
+			  unsigned int nanosec, unsigned int flags)
 {
 	struct ni_private *devpriv = dev->private;
 	int divider;
@@ -2012,7 +2016,7 @@ static int ni_ns_to_timer(const struct comedi_device *dev, unsigned nanosec,
 	return divider - 1;
 }
 
-static unsigned ni_timer_to_ns(const struct comedi_device *dev, int timer)
+static unsigned int ni_timer_to_ns(const struct comedi_device *dev, int timer)
 {
 	struct ni_private *devpriv = dev->private;
 
@@ -2050,8 +2054,8 @@ static void ni_cmd_set_mite_transfer(struct mite_dma_descriptor_ring *ring,
 #endif
 }
 
-static unsigned ni_min_ai_scan_period_ns(struct comedi_device *dev,
-					 unsigned num_channels)
+static unsigned int ni_min_ai_scan_period_ns(struct comedi_device *dev,
+					     unsigned int num_channels)
 {
 	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
@@ -2242,7 +2246,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int start_stop_select = 0;
 	unsigned int stop_count;
 	int interrupt_a_enable = 0;
-	unsigned ai_trig;
+	unsigned int ai_trig;
 
 	if (dev->irq == 0) {
 		dev_err(dev->class_dev, "cannot run command without an irq\n");
@@ -2899,7 +2903,7 @@ static void ni_ao_cmd_personalize(struct comedi_device *dev,
 				  const struct comedi_cmd *cmd)
 {
 	const struct ni_board_struct *board = dev->board_ptr;
-	unsigned bits;
+	unsigned int bits;
 
 	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
 
@@ -3130,9 +3134,10 @@ static void ni_ao_cmd_set_update(struct comedi_device *dev,
 		 */
 
 		{
-			unsigned trigvar = ni_ns_to_timer(dev,
-							  cmd->scan_begin_arg,
-							  CMDF_ROUND_NEAREST);
+			unsigned int trigvar;
+
+			trigvar = ni_ns_to_timer(dev, cmd->scan_begin_arg,
+						 CMDF_ROUND_NEAREST);
 
 			/*
 			 * Wait N TB3 ticks after the start trigger before
@@ -3179,7 +3184,7 @@ static void ni_ao_cmd_set_channels(struct comedi_device *dev,
 {
 	struct ni_private *devpriv = dev->private;
 	const struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned bits = 0;
+	unsigned int bits = 0;
 
 	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
 
@@ -3601,9 +3606,9 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 			  unsigned int trig_num)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
-	const unsigned timeout = 1000;
+	const unsigned int timeout = 1000;
 	int retval = 0;
-	unsigned i;
+	unsigned int i;
 	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
@@ -3654,7 +3659,7 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct ni_private *devpriv = dev->private;
 	const struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned cdo_mode_bits;
+	unsigned int cdo_mode_bits;
 	int retval;
 
 	ni_writel(dev, NI_M_CDO_CMD_RESET, NI_M_CDIO_CMD_REG);
@@ -3705,13 +3710,13 @@ static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static void handle_cdio_interrupt(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
-	unsigned cdio_status;
+	unsigned int cdio_status;
 	struct comedi_subdevice *s = &dev->subdevices[NI_DIO_SUBDEV];
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
-		unsigned cdo_mite_status =
+		unsigned int cdo_mite_status =
 		    mite_get_status(devpriv->cdo_mite_chan);
 		if (cdo_mite_status & CHSR_LINKC) {
 			writel(CHOR_CLRLC,
@@ -3838,7 +3843,7 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 				 unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
-	unsigned clk_fout = devpriv->clock_and_fout;
+	unsigned int clk_fout = devpriv->clock_and_fout;
 	int err = insn->n;
 	unsigned char byte_out, byte_in = 0;
 
@@ -3987,14 +3992,14 @@ static unsigned int ni_gpct_to_stc_register(struct comedi_device *dev,
 	return regmap->mio_reg;
 }
 
-static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
+static void ni_gpct_write_register(struct ni_gpct *counter, unsigned int bits,
 				   enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
 	unsigned int stc_register = ni_gpct_to_stc_register(dev, reg);
-	static const unsigned gpct_interrupt_a_enable_mask =
+	static const unsigned int gpct_interrupt_a_enable_mask =
 	    NISTC_INTA_ENA_G0_GATE | NISTC_INTA_ENA_G0_TC;
-	static const unsigned gpct_interrupt_b_enable_mask =
+	static const unsigned int gpct_interrupt_b_enable_mask =
 	    NISTC_INTB_ENA_G1_GATE | NISTC_INTB_ENA_G1_TC;
 
 	if (stc_register == 0)
@@ -4040,8 +4045,8 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 	}
 }
 
-static unsigned ni_gpct_read_register(struct ni_gpct *counter,
-				      enum ni_gpct_register reg)
+static unsigned int ni_gpct_read_register(struct ni_gpct *counter,
+					  enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
 	unsigned int stc_register = ni_gpct_to_stc_register(dev, reg);
@@ -4168,7 +4173,7 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 				  unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
-	unsigned up_count, down_count;
+	unsigned int up_count, down_count;
 
 	switch (data[0]) {
 	case INSN_CONFIG_PWM_OUTPUT:
@@ -4228,7 +4233,7 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 			      unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
-	unsigned up_count, down_count;
+	unsigned int up_count, down_count;
 
 	switch (data[0]) {
 	case INSN_CONFIG_PWM_OUTPUT:
@@ -4515,8 +4520,8 @@ static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
 	return 1;
 }
 
-static unsigned ni_old_get_pfi_routing(struct comedi_device *dev,
-				       unsigned chan)
+static unsigned int ni_old_get_pfi_routing(struct comedi_device *dev,
+					   unsigned int chan)
 {
 	/*  pre-m-series boards have fixed signals on pfi pins */
 	switch (chan) {
@@ -4548,7 +4553,7 @@ static unsigned ni_old_get_pfi_routing(struct comedi_device *dev,
 }
 
 static int ni_old_set_pfi_routing(struct comedi_device *dev,
-				  unsigned chan, unsigned source)
+				  unsigned int chan, unsigned int source)
 {
 	/*  pre-m-series boards have fixed signals on pfi pins */
 	if (source != ni_old_get_pfi_routing(dev, chan))
@@ -4556,21 +4561,21 @@ static int ni_old_set_pfi_routing(struct comedi_device *dev,
 	return 2;
 }
 
-static unsigned ni_m_series_get_pfi_routing(struct comedi_device *dev,
-					    unsigned chan)
+static unsigned int ni_m_series_get_pfi_routing(struct comedi_device *dev,
+						unsigned int chan)
 {
 	struct ni_private *devpriv = dev->private;
-	const unsigned array_offset = chan / 3;
+	const unsigned int array_offset = chan / 3;
 
 	return NI_M_PFI_OUT_SEL_TO_SRC(chan,
 				devpriv->pfi_output_select_reg[array_offset]);
 }
 
 static int ni_m_series_set_pfi_routing(struct comedi_device *dev,
-				       unsigned chan, unsigned source)
+				       unsigned int chan, unsigned int source)
 {
 	struct ni_private *devpriv = dev->private;
-	unsigned index = chan / 3;
+	unsigned int index = chan / 3;
 	unsigned short val = devpriv->pfi_output_select_reg[index];
 
 	if ((source & 0x1f) != source)
@@ -4584,7 +4589,8 @@ static int ni_m_series_set_pfi_routing(struct comedi_device *dev,
 	return 2;
 }
 
-static unsigned ni_get_pfi_routing(struct comedi_device *dev, unsigned chan)
+static unsigned int ni_get_pfi_routing(struct comedi_device *dev,
+				       unsigned int chan)
 {
 	struct ni_private *devpriv = dev->private;
 
@@ -4593,8 +4599,8 @@ static unsigned ni_get_pfi_routing(struct comedi_device *dev, unsigned chan)
 			: ni_old_get_pfi_routing(dev, chan);
 }
 
-static int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,
-			      unsigned source)
+static int ni_set_pfi_routing(struct comedi_device *dev,
+			      unsigned int chan, unsigned int source)
 {
 	struct ni_private *devpriv = dev->private;
 
@@ -4604,11 +4610,11 @@ static int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,
 }
 
 static int ni_config_filter(struct comedi_device *dev,
-			    unsigned pfi_channel,
+			    unsigned int pfi_channel,
 			    enum ni_pfi_filter_select filter)
 {
 	struct ni_private *devpriv = dev->private;
-	unsigned bits;
+	unsigned int bits;
 
 	if (!devpriv->is_m_series)
 		return -ENOTSUPP;
@@ -4816,27 +4822,27 @@ static int init_cs5529(struct comedi_device *dev)
  * Find best multiplier/divider to try and get the PLL running at 80 MHz
  * given an arbitrary frequency input clock.
  */
-static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
-					 unsigned *freq_divider,
-					 unsigned *freq_multiplier,
-					 unsigned *actual_period_ns)
-{
-	unsigned div;
-	unsigned best_div = 1;
-	unsigned mult;
-	unsigned best_mult = 1;
-	static const unsigned pico_per_nano = 1000;
-
-	const unsigned reference_picosec = reference_period_ns * pico_per_nano;
+static int ni_mseries_get_pll_parameters(unsigned int reference_period_ns,
+					 unsigned int *freq_divider,
+					 unsigned int *freq_multiplier,
+					 unsigned int *actual_period_ns)
+{
+	unsigned int div;
+	unsigned int best_div = 1;
+	unsigned int mult;
+	unsigned int best_mult = 1;
+	static const unsigned int pico_per_nano = 1000;
+	const unsigned int reference_picosec = reference_period_ns *
+					       pico_per_nano;
 	/* m-series wants the phased-locked loop to output 80MHz, which is divided by 4 to
 	 * 20 MHz for most timing clocks */
-	static const unsigned target_picosec = 12500;
-	static const unsigned fudge_factor_80_to_20Mhz = 4;
+	static const unsigned int target_picosec = 12500;
+	static const unsigned int fudge_factor_80_to_20Mhz = 4;
 	int best_period_picosec = 0;
 
 	for (div = 1; div <= NI_M_PLL_MAX_DIVISOR; ++div) {
 		for (mult = 1; mult <= NI_M_PLL_MAX_MULTIPLIER; ++mult) {
-			unsigned new_period_ps =
+			unsigned int new_period_ps =
 			    (reference_picosec * div) / mult;
 			if (abs(new_period_ps - target_picosec) <
 			    abs(best_period_picosec - target_picosec)) {
@@ -4858,17 +4864,18 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 }
 
 static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
-					   unsigned source, unsigned period_ns)
+					   unsigned int source,
+					   unsigned int period_ns)
 {
 	struct ni_private *devpriv = dev->private;
-	static const unsigned min_period_ns = 50;
-	static const unsigned max_period_ns = 1000;
-	static const unsigned timeout = 1000;
-	unsigned pll_control_bits;
-	unsigned freq_divider;
-	unsigned freq_multiplier;
-	unsigned rtsi;
-	unsigned i;
+	static const unsigned int min_period_ns = 50;
+	static const unsigned int max_period_ns = 1000;
+	static const unsigned int timeout = 1000;
+	unsigned int pll_control_bits;
+	unsigned int freq_divider;
+	unsigned int freq_multiplier;
+	unsigned int rtsi;
+	unsigned int i;
 	int retval;
 
 	if (source == NI_MIO_PLL_PXI10_CLOCK)
@@ -4939,7 +4946,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 }
 
 static int ni_set_master_clock(struct comedi_device *dev,
-			       unsigned source, unsigned period_ns)
+			       unsigned int source, unsigned int period_ns)
 {
 	struct ni_private *devpriv = dev->private;
 
@@ -4984,7 +4991,7 @@ static int ni_set_master_clock(struct comedi_device *dev,
 }
 
 static int ni_valid_rtsi_output_source(struct comedi_device *dev,
-				       unsigned chan, unsigned source)
+				       unsigned int chan, unsigned int source)
 {
 	struct ni_private *devpriv = dev->private;
 
@@ -5019,7 +5026,7 @@ static int ni_valid_rtsi_output_source(struct comedi_device *dev,
 }
 
 static int ni_set_rtsi_routing(struct comedi_device *dev,
-			       unsigned chan, unsigned src)
+			       unsigned int chan, unsigned int src)
 {
 	struct ni_private *devpriv = dev->private;
 
@@ -5039,7 +5046,8 @@ static int ni_set_rtsi_routing(struct comedi_device *dev,
 	return 2;
 }
 
-static unsigned ni_get_rtsi_routing(struct comedi_device *dev, unsigned chan)
+static unsigned int ni_get_rtsi_routing(struct comedi_device *dev,
+					unsigned int chan)
 {
 	struct ni_private *devpriv = dev->private;
 
@@ -5277,7 +5285,7 @@ static int ni_alloc_private(struct comedi_device *dev)
 }
 
 static int ni_E_init(struct comedi_device *dev,
-		     unsigned interrupt_pin, unsigned irq_polarity)
+		     unsigned int interrupt_pin, unsigned int irq_polarity)
 {
 	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;

commit cf122bb4a641e091b6b5322c907ea3853eef6566
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:57:52 2016 -0700

    staging: comedi: ni_mio_common: tidy up DIO subdevice ifdef'ery
    
    This file is is bit of a mess. It's included by the ni_atmio, ni_mio_cs, and
    ni_pcimio drivers. The ni_pcimio driver is the only one that uses DMA. It
    defines PCIDMA so that the dma code is compiled it. This causes a bunch
    of ifdef'ery in the file.
    
    The DIO subdevice for the ni_pcidio "is_m_series" boards is quite different
    from the standard e-series DIO. Mainly it supports async commands that use
    DMA.
    
    Tidy up some of the ifdef'ery by adding ifdef to the subdevice init. Move
    the is_m_series check to the main interrupt handler so that the unneded
    handle_cdio_interrupt() can be blocked out for the ni_atmio and ni_mio_cs
    drivers.
    
    Consolidate the other ifdef's to block out the affected code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 11a2453de33d..7ba6c6e8ef4b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -667,11 +667,8 @@ static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 	return 0;
 }
 
-#endif /*  PCIDMA */
-
 static int ni_request_cdo_mite_channel(struct comedi_device *dev)
 {
-#ifdef PCIDMA
 	struct ni_private *devpriv = dev->private;
 	struct mite_channel *mite_chan;
 	unsigned long flags;
@@ -700,9 +697,9 @@ static int ni_request_cdo_mite_channel(struct comedi_device *dev)
 			NI_M_CDIO_DMA_SEL_CDO(bits));
 
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif /*  PCIDMA */
 	return 0;
 }
+#endif /*  PCIDMA */
 
 static void ni_release_ai_mite_channel(struct comedi_device *dev)
 {
@@ -759,11 +756,9 @@ static void ni_release_gpct_mite_channel(struct comedi_device *dev,
 	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
-#endif /*  PCIDMA */
 
 static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 {
-#ifdef PCIDMA
 	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
@@ -775,10 +770,8 @@ static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 		devpriv->cdo_mite_chan = NULL;
 	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif /*  PCIDMA */
 }
 
-#ifdef PCIDMA
 static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 					  unsigned gpct_index, short enable)
 {
@@ -3505,6 +3498,7 @@ static int ni_dio_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
+#ifdef PCIDMA
 static int ni_m_series_dio_insn_config(struct comedi_device *dev,
 				       struct comedi_subdevice *s,
 				       struct comedi_insn *insn,
@@ -3610,10 +3604,8 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 	const unsigned timeout = 1000;
 	int retval = 0;
 	unsigned i;
-#ifdef PCIDMA
 	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
-#endif
 
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
@@ -3623,7 +3615,6 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 	/* read alloc the entire buffer */
 	comedi_buf_read_alloc(s, s->async->prealloc_bufsz);
 
-#ifdef PCIDMA
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
 		mite_prep_dma(devpriv->cdo_mite_chan, 32, 32);
@@ -3635,7 +3626,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	if (retval < 0)
 		return retval;
-#endif
+
 	/*
 	 * XXX not sure what interrupt C group does
 	 * wait for dma to fill output fifo
@@ -3716,13 +3707,8 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	struct ni_private *devpriv = dev->private;
 	unsigned cdio_status;
 	struct comedi_subdevice *s = &dev->subdevices[NI_DIO_SUBDEV];
-#ifdef PCIDMA
 	unsigned long flags;
-#endif
 
-	if (!devpriv->is_m_series)
-		return;
-#ifdef PCIDMA
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
 		unsigned cdo_mite_status =
@@ -3735,7 +3721,6 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 		mite_sync_output_dma(devpriv->cdo_mite_chan, s);
 	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif
 
 	cdio_status = ni_readl(dev, NI_M_CDIO_STATUS_REG);
 	if (cdio_status & NI_M_CDIO_STATUS_CDO_ERROR) {
@@ -3751,6 +3736,7 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	}
 	comedi_handle_events(dev, s);
 }
+#endif /*  PCIDMA */
 
 static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
@@ -5266,7 +5252,10 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 		handle_b_interrupt(dev, b_status, ao_mite_status);
 	handle_gpct_interrupt(dev, 0);
 	handle_gpct_interrupt(dev, 1);
-	handle_cdio_interrupt(dev);
+#ifdef PCIDMA
+	if (devpriv->is_m_series)
+		handle_cdio_interrupt(dev);
+#endif
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 	return IRQ_HANDLED;
@@ -5405,6 +5394,7 @@ static int ni_E_init(struct comedi_device *dev,
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
 	if (devpriv->is_m_series) {
+#ifdef PCIDMA
 		s->subdev_flags	|= SDF_LSAMPL;
 		s->insn_bits	= ni_m_series_dio_insn_bits;
 		s->insn_config	= ni_m_series_dio_insn_config;
@@ -5424,6 +5414,7 @@ static int ni_E_init(struct comedi_device *dev,
 			       NI_M_CDI_CMD_RESET,
 			  NI_M_CDIO_CMD_REG);
 		ni_writel(dev, s->io_bits, NI_M_DIO_DIR_REG);
+#endif /* PCIDMA */
 	} else {
 		s->insn_bits	= ni_dio_insn_bits;
 		s->insn_config	= ni_dio_insn_config;

commit b7cd3f604954cac03717b522d0ef02cc7c01f257
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:57:51 2016 -0700

    staging: comedi: ni_mio_common: tidy up mite dma channel releases
    
    Absorb the inline helper functions that call ni_set_bitfield() to clear
    the dma channel selection bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 231cd2c3b6eb..11a2453de33d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -584,29 +584,6 @@ static inline unsigned ni_stc_dma_channel_select_bitfield(unsigned channel)
 	return 0;
 }
 
-static inline void ni_set_ai_dma_no_channel(struct comedi_device *dev)
-{
-	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG, NI_E_DMA_AI_SEL_MASK, 0);
-}
-
-static inline void ni_set_ao_dma_no_channel(struct comedi_device *dev)
-{
-	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG, NI_E_DMA_AO_SEL_MASK, 0);
-}
-
-static inline void ni_set_gpct_dma_no_channel(struct comedi_device *dev,
-					      unsigned gpct_index)
-{
-	ni_set_bitfield(dev, NI_E_DMA_G0_G1_SEL_REG,
-			NI_E_DMA_G0_G1_SEL_MASK(gpct_index), 0);
-}
-
-static inline void ni_set_cdo_dma_no_channel(struct comedi_device *dev)
-{
-	ni_set_bitfield(dev, NI_M_CDIO_DMA_SEL_REG,
-			NI_M_CDIO_DMA_SEL_CDO_MASK, 0);
-}
-
 static int ni_request_ai_mite_channel(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
@@ -735,7 +712,8 @@ static void ni_release_ai_mite_channel(struct comedi_device *dev)
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ai_mite_chan) {
-		ni_set_ai_dma_no_channel(dev);
+		ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,
+				NI_E_DMA_AI_SEL_MASK, 0);
 		mite_release_channel(devpriv->ai_mite_chan);
 		devpriv->ai_mite_chan = NULL;
 	}
@@ -751,7 +729,8 @@ static void ni_release_ao_mite_channel(struct comedi_device *dev)
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ao_mite_chan) {
-		ni_set_ao_dma_no_channel(dev);
+		ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,
+				NI_E_DMA_AO_SEL_MASK, 0);
 		mite_release_channel(devpriv->ao_mite_chan);
 		devpriv->ao_mite_chan = NULL;
 	}
@@ -771,7 +750,8 @@ static void ni_release_gpct_mite_channel(struct comedi_device *dev,
 		struct mite_channel *mite_chan =
 		    devpriv->counter_dev->counters[gpct_index].mite_chan;
 
-		ni_set_gpct_dma_no_channel(dev, gpct_index);
+		ni_set_bitfield(dev, NI_E_DMA_G0_G1_SEL_REG,
+				NI_E_DMA_G0_G1_SEL_MASK(gpct_index), 0);
 		ni_tio_set_mite_channel(&devpriv->
 					counter_dev->counters[gpct_index],
 					NULL);
@@ -789,7 +769,8 @@ static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
-		ni_set_cdo_dma_no_channel(dev);
+		ni_set_bitfield(dev, NI_M_CDIO_DMA_SEL_REG,
+				NI_M_CDIO_DMA_SEL_CDO_MASK, 0);
 		mite_release_channel(devpriv->cdo_mite_chan);
 		devpriv->cdo_mite_chan = NULL;
 	}

commit 38b81a7a41d48e84d71f0b65fa15a684c9ae81da
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:57:50 2016 -0700

    staging: comedi: ni_mio_common: tidy up mite dma channel requests
    
    Tidy up the functions that request the mite dma channels by absorbing the
    inline helper functions that call ni_set_bitfield() to set the channel
    selection bits.
    
    Add support for the NI_M_CDIO_DMA_SEL_REG register to ni_set_bitfield()
    so that all the soft_reg_copy_lock spinlocking is done in one place.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7a326058965c..231cd2c3b6eb 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -556,6 +556,11 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 		devpriv->g0_g1_select_reg |= bit_values & bit_mask;
 		ni_writeb(dev, devpriv->g0_g1_select_reg, reg);
 		break;
+	case NI_M_CDIO_DMA_SEL_REG:
+		devpriv->cdio_dma_select_reg &= ~bit_mask;
+		devpriv->cdio_dma_select_reg |= bit_values & bit_mask;
+		ni_writeb(dev, devpriv->cdio_dma_select_reg, reg);
+		break;
 	default:
 		dev_err(dev->class_dev, "called with invalid register %d\n",
 			reg);
@@ -579,45 +584,16 @@ static inline unsigned ni_stc_dma_channel_select_bitfield(unsigned channel)
 	return 0;
 }
 
-static inline void ni_set_ai_dma_channel(struct comedi_device *dev,
-					 unsigned channel)
-{
-	unsigned bits = ni_stc_dma_channel_select_bitfield(channel);
-
-	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,
-			NI_E_DMA_AI_SEL_MASK, NI_E_DMA_AI_SEL(bits));
-}
-
 static inline void ni_set_ai_dma_no_channel(struct comedi_device *dev)
 {
 	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG, NI_E_DMA_AI_SEL_MASK, 0);
 }
 
-static inline void ni_set_ao_dma_channel(struct comedi_device *dev,
-					 unsigned channel)
-{
-	unsigned bits = ni_stc_dma_channel_select_bitfield(channel);
-
-	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,
-			NI_E_DMA_AO_SEL_MASK, NI_E_DMA_AO_SEL(bits));
-}
-
 static inline void ni_set_ao_dma_no_channel(struct comedi_device *dev)
 {
 	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG, NI_E_DMA_AO_SEL_MASK, 0);
 }
 
-static inline void ni_set_gpct_dma_channel(struct comedi_device *dev,
-					   unsigned gpct_index,
-					   unsigned channel)
-{
-	unsigned bits = ni_stc_dma_channel_select_bitfield(channel);
-
-	ni_set_bitfield(dev, NI_E_DMA_G0_G1_SEL_REG,
-			NI_E_DMA_G0_G1_SEL_MASK(gpct_index),
-			NI_E_DMA_G0_G1_SEL(gpct_index, bits));
-}
-
 static inline void ni_set_gpct_dma_no_channel(struct comedi_device *dev,
 					      unsigned gpct_index)
 {
@@ -625,56 +601,34 @@ static inline void ni_set_gpct_dma_no_channel(struct comedi_device *dev,
 			NI_E_DMA_G0_G1_SEL_MASK(gpct_index), 0);
 }
 
-static inline void ni_set_cdo_dma_channel(struct comedi_device *dev,
-					  unsigned mite_channel)
-{
-	struct ni_private *devpriv = dev->private;
-	unsigned long flags;
-	unsigned bits;
-
-	spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
-	devpriv->cdio_dma_select_reg &= ~NI_M_CDIO_DMA_SEL_CDO_MASK;
-	/*
-	 * XXX just guessing ni_stc_dma_channel_select_bitfield()
-	 * returns the right bits, under the assumption the cdio dma
-	 * selection works just like ai/ao/gpct.
-	 * Definitely works for dma channels 0 and 1.
-	 */
-	bits = ni_stc_dma_channel_select_bitfield(mite_channel);
-	devpriv->cdio_dma_select_reg |= NI_M_CDIO_DMA_SEL_CDO(bits);
-	ni_writeb(dev, devpriv->cdio_dma_select_reg, NI_M_CDIO_DMA_SEL_REG);
-	mmiowb();
-	spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
-}
-
 static inline void ni_set_cdo_dma_no_channel(struct comedi_device *dev)
 {
-	struct ni_private *devpriv = dev->private;
-	unsigned long flags;
-
-	spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
-	devpriv->cdio_dma_select_reg &= ~NI_M_CDIO_DMA_SEL_CDO_MASK;
-	ni_writeb(dev, devpriv->cdio_dma_select_reg, NI_M_CDIO_DMA_SEL_REG);
-	mmiowb();
-	spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
+	ni_set_bitfield(dev, NI_M_CDIO_DMA_SEL_REG,
+			NI_M_CDIO_DMA_SEL_CDO_MASK, 0);
 }
 
 static int ni_request_ai_mite_channel(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
+	struct mite_channel *mite_chan;
 	unsigned long flags;
+	unsigned int bits;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	devpriv->ai_mite_chan =
-	    mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);
-	if (!devpriv->ai_mite_chan) {
+	mite_chan = mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);
+	if (!mite_chan) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		dev_err(dev->class_dev,
 			"failed to reserve mite dma channel for analog input\n");
 		return -EBUSY;
 	}
-	devpriv->ai_mite_chan->dir = COMEDI_INPUT;
-	ni_set_ai_dma_channel(dev, devpriv->ai_mite_chan->channel);
+	mite_chan->dir = COMEDI_INPUT;
+	devpriv->ai_mite_chan = mite_chan;
+
+	bits = ni_stc_dma_channel_select_bitfield(mite_chan->channel);
+	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,
+			NI_E_DMA_AI_SEL_MASK, NI_E_DMA_AI_SEL(bits));
+
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	return 0;
 }
@@ -682,19 +636,25 @@ static int ni_request_ai_mite_channel(struct comedi_device *dev)
 static int ni_request_ao_mite_channel(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
+	struct mite_channel *mite_chan;
 	unsigned long flags;
+	unsigned int bits;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	devpriv->ao_mite_chan =
-	    mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);
-	if (!devpriv->ao_mite_chan) {
+	mite_chan = mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);
+	if (!mite_chan) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		dev_err(dev->class_dev,
 			"failed to reserve mite dma channel for analog outut\n");
 		return -EBUSY;
 	}
-	devpriv->ao_mite_chan->dir = COMEDI_OUTPUT;
-	ni_set_ao_dma_channel(dev, devpriv->ao_mite_chan->channel);
+	mite_chan->dir = COMEDI_OUTPUT;
+	devpriv->ao_mite_chan = mite_chan;
+
+	bits = ni_stc_dma_channel_select_bitfield(mite_chan->channel);
+	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,
+			NI_E_DMA_AO_SEL_MASK, NI_E_DMA_AO_SEL(bits));
+
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	return 0;
 }
@@ -704,13 +664,14 @@ static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 					enum comedi_io_direction direction)
 {
 	struct ni_private *devpriv = dev->private;
-	unsigned long flags;
+	struct ni_gpct *counter = &devpriv->counter_dev->counters[gpct_index];
 	struct mite_channel *mite_chan;
+	unsigned long flags;
+	unsigned int bits;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	mite_chan =
-	    mite_request_channel(devpriv->mite,
-				 devpriv->gpct_mite_ring[gpct_index]);
+	mite_chan = mite_request_channel(devpriv->mite,
+					 devpriv->gpct_mite_ring[gpct_index]);
 	if (!mite_chan) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		dev_err(dev->class_dev,
@@ -718,9 +679,13 @@ static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 		return -EBUSY;
 	}
 	mite_chan->dir = direction;
-	ni_tio_set_mite_channel(&devpriv->counter_dev->counters[gpct_index],
-				mite_chan);
-	ni_set_gpct_dma_channel(dev, gpct_index, mite_chan->channel);
+	ni_tio_set_mite_channel(counter, mite_chan);
+
+	bits = ni_stc_dma_channel_select_bitfield(mite_chan->channel);
+	ni_set_bitfield(dev, NI_E_DMA_G0_G1_SEL_REG,
+			NI_E_DMA_G0_G1_SEL_MASK(gpct_index),
+			NI_E_DMA_G0_G1_SEL(gpct_index, bits));
+
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	return 0;
 }
@@ -731,19 +696,32 @@ static int ni_request_cdo_mite_channel(struct comedi_device *dev)
 {
 #ifdef PCIDMA
 	struct ni_private *devpriv = dev->private;
+	struct mite_channel *mite_chan;
 	unsigned long flags;
+	unsigned int bits;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	devpriv->cdo_mite_chan =
-	    mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);
-	if (!devpriv->cdo_mite_chan) {
+	mite_chan = mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);
+	if (!mite_chan) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		dev_err(dev->class_dev,
 			"failed to reserve mite dma channel for correlated digital output\n");
 		return -EBUSY;
 	}
-	devpriv->cdo_mite_chan->dir = COMEDI_OUTPUT;
-	ni_set_cdo_dma_channel(dev, devpriv->cdo_mite_chan->channel);
+	mite_chan->dir = COMEDI_OUTPUT;
+	devpriv->cdo_mite_chan = mite_chan;
+
+	/*
+	 * XXX just guessing ni_stc_dma_channel_select_bitfield()
+	 * returns the right bits, under the assumption the cdio dma
+	 * selection works just like ai/ao/gpct.
+	 * Definitely works for dma channels 0 and 1.
+	 */
+	bits = ni_stc_dma_channel_select_bitfield(mite_chan->channel);
+	ni_set_bitfield(dev, NI_M_CDIO_DMA_SEL_REG,
+			NI_M_CDIO_DMA_SEL_CDO_MASK,
+			NI_M_CDIO_DMA_SEL_CDO(bits));
+
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif /*  PCIDMA */
 	return 0;

commit bf2388b1eab18018cb469c7c55b837b1da911043
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 14 09:57:49 2016 -0700

    staging: comedi: ni_mio_common: remove some unnecessary BUG_ON()
    
    The mite dma channels are only requested by a subdevice with a (*do_cmd)
    and they are released by a (*cancel). The comedi core will only call the
    (*do_cmd) if the subdevice is not already running a command and all
    commands are terminated by the core with a (*cancel).
    
    Remove the BUG_ON() checks in the request functions which can never
    happen.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 71c8fd2cfff6..7a326058965c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -665,7 +665,6 @@ static int ni_request_ai_mite_channel(struct comedi_device *dev)
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	BUG_ON(devpriv->ai_mite_chan);
 	devpriv->ai_mite_chan =
 	    mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);
 	if (!devpriv->ai_mite_chan) {
@@ -686,7 +685,6 @@ static int ni_request_ao_mite_channel(struct comedi_device *dev)
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	BUG_ON(devpriv->ao_mite_chan);
 	devpriv->ao_mite_chan =
 	    mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);
 	if (!devpriv->ao_mite_chan) {
@@ -710,7 +708,6 @@ static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 	struct mite_channel *mite_chan;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	BUG_ON(devpriv->counter_dev->counters[gpct_index].mite_chan);
 	mite_chan =
 	    mite_request_channel(devpriv->mite,
 				 devpriv->gpct_mite_ring[gpct_index]);
@@ -737,7 +734,6 @@ static int ni_request_cdo_mite_channel(struct comedi_device *dev)
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	BUG_ON(devpriv->cdo_mite_chan);
 	devpriv->cdo_mite_chan =
 	    mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);
 	if (!devpriv->cdo_mite_chan) {

commit 99307a69bf7166325bb8f0b1f1afcb0a0a1aca9a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 22 11:10:42 2016 -0700

    staging: comedi: ni_mio_common: ni_gpct_device_destroy() can handle a NULL pointer
    
    Remove the unnecessary NULL pointer check.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index dcaf7e89f299..71c8fd2cfff6 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5675,8 +5675,6 @@ static void mio_common_detach(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
 
-	if (devpriv) {
-		if (devpriv->counter_dev)
-			ni_gpct_device_destroy(devpriv->counter_dev);
-	}
+	if (devpriv)
+		ni_gpct_device_destroy(devpriv->counter_dev);
 }

commit bd3a3cd6c27b117fb9a43a38c8072c95332beecc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 22 10:04:48 2016 -0700

    staging: comedi: ni_mio_common: fix the ni_write[blw]() functions
    
    Memory mapped io (dev->mmio) should not also be writing to the ioport
    (dev->iobase) registers. Add the missing 'else' to these functions.
    
    Fixes: 0953ee4acca0 ("staging: comedi: ni_mio_common: checkpatch.pl cleanup (else not useful)")
    Cc: <stable@vger.kernel.org> # 3.17+
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d1226c97664b..dcaf7e89f299 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -246,24 +246,24 @@ static void ni_writel(struct comedi_device *dev, uint32_t data, int reg)
 {
 	if (dev->mmio)
 		writel(data, dev->mmio + reg);
-
-	outl(data, dev->iobase + reg);
+	else
+		outl(data, dev->iobase + reg);
 }
 
 static void ni_writew(struct comedi_device *dev, uint16_t data, int reg)
 {
 	if (dev->mmio)
 		writew(data, dev->mmio + reg);
-
-	outw(data, dev->iobase + reg);
+	else
+		outw(data, dev->iobase + reg);
 }
 
 static void ni_writeb(struct comedi_device *dev, uint8_t data, int reg)
 {
 	if (dev->mmio)
 		writeb(data, dev->mmio + reg);
-
-	outb(data, dev->iobase + reg);
+	else
+		outb(data, dev->iobase + reg);
 }
 
 static uint32_t ni_readl(struct comedi_device *dev, int reg)

commit 7f9d2b1ce5f01e76a26ca9dd087c87fd47cb0cfd
Author: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
Date:   Thu Mar 10 00:05:16 2016 +0530

    staging: comedi: drivers: ni_mio_common: Prefer using macro DIV_ROUND_UP
    
    The macro DIV_ROUND_UP performs the computation
    (((n) + (d) - 1) /(d)). It clarifies the divisor calculations.
    This was done using the coccinelle script:
    @@
    expression e1;
    expression e2;
    @@
    (
    - ((e1) + e2 - 1) / (e2)
    + DIV_ROUND_UP(e1,e2)
    |
    - ((e1) + (e2 - 1)) / (e2)
    + DIV_ROUND_UP(e1,e2)
    )
    
    Signed-off-by: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8d8535b1b6ca..d1226c97664b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2058,7 +2058,7 @@ static int ni_ns_to_timer(const struct comedi_device *dev, unsigned nanosec,
 		divider = (nanosec) / devpriv->clock_ns;
 		break;
 	case CMDF_ROUND_UP:
-		divider = (nanosec + devpriv->clock_ns - 1) / devpriv->clock_ns;
+		divider = DIV_ROUND_UP(nanosec, devpriv->clock_ns);
 		break;
 	}
 	return divider - 1;
@@ -4241,8 +4241,7 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 			break;
 		case CMDF_ROUND_UP:
 			up_count =
-			    (data[2] + devpriv->clock_ns -
-			     1) / devpriv->clock_ns;
+			    DIV_ROUND_UP(data[2], devpriv->clock_ns);
 			break;
 		default:
 			return -EINVAL;
@@ -4257,8 +4256,7 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 			break;
 		case CMDF_ROUND_UP:
 			down_count =
-			    (data[4] + devpriv->clock_ns -
-			     1) / devpriv->clock_ns;
+			    DIV_ROUND_UP(data[4], devpriv->clock_ns);
 			break;
 		default:
 			return -EINVAL;
@@ -4303,8 +4301,7 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 			break;
 		case CMDF_ROUND_UP:
 			up_count =
-			    (data[2] + devpriv->clock_ns -
-			     1) / devpriv->clock_ns;
+			    DIV_ROUND_UP(data[2], devpriv->clock_ns);
 			break;
 		default:
 			return -EINVAL;
@@ -4319,8 +4316,7 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 			break;
 		case CMDF_ROUND_UP:
 			down_count =
-			    (data[4] + devpriv->clock_ns -
-			     1) / devpriv->clock_ns;
+			    DIV_ROUND_UP(data[4], devpriv->clock_ns);
 			break;
 		default:
 			return -EINVAL;

commit 1e5a05d57c2a103903e6980c86057870666a9ac8
Author: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
Date:   Sun Feb 21 16:13:01 2016 +0530

    staging: comedi: Use macro DIV_ROUND_CLOSEST
    
    Occurences of the computation (x +d/2)/d can be replaced with
    the macro DIV_ROUND_CLOSEST.
    
    This was detected by the following Coccinelle script.
    
    @@
    expression e1,e2;
    @@
    (
    - ((e1) + e2/2) / (e2)
    + DIV_ROUND_CLOSEST(e1,e2)
    |
    - ((e1) + (e2/2)) / (e2)
    + DIV_ROUND_CLOSEST(e1,e2)
    )
    
    Since some lines exceeded the 80 character limit,
    some changes were made by hand.
    
    Signed-off-by: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 1c2abb3feb42..8d8535b1b6ca 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2052,7 +2052,7 @@ static int ni_ns_to_timer(const struct comedi_device *dev, unsigned nanosec,
 	switch (flags & CMDF_ROUND_MASK) {
 	case CMDF_ROUND_NEAREST:
 	default:
-		divider = (nanosec + devpriv->clock_ns / 2) / devpriv->clock_ns;
+		divider = DIV_ROUND_CLOSEST(nanosec, devpriv->clock_ns);
 		break;
 	case CMDF_ROUND_DOWN:
 		divider = (nanosec) / devpriv->clock_ns;
@@ -4233,9 +4233,8 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 	case INSN_CONFIG_PWM_OUTPUT:
 		switch (data[1]) {
 		case CMDF_ROUND_NEAREST:
-			up_count =
-			    (data[2] +
-			     devpriv->clock_ns / 2) / devpriv->clock_ns;
+			up_count = DIV_ROUND_CLOSEST(data[2],
+						     devpriv->clock_ns);
 			break;
 		case CMDF_ROUND_DOWN:
 			up_count = data[2] / devpriv->clock_ns;
@@ -4250,9 +4249,8 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 		}
 		switch (data[3]) {
 		case CMDF_ROUND_NEAREST:
-			down_count =
-			    (data[4] +
-			     devpriv->clock_ns / 2) / devpriv->clock_ns;
+			down_count = DIV_ROUND_CLOSEST(data[4],
+						       devpriv->clock_ns);
 			break;
 		case CMDF_ROUND_DOWN:
 			down_count = data[4] / devpriv->clock_ns;
@@ -4297,9 +4295,8 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 	case INSN_CONFIG_PWM_OUTPUT:
 		switch (data[1]) {
 		case CMDF_ROUND_NEAREST:
-			up_count =
-			    (data[2] +
-			     devpriv->clock_ns / 2) / devpriv->clock_ns;
+			up_count = DIV_ROUND_CLOSEST(data[2],
+						     devpriv->clock_ns);
 			break;
 		case CMDF_ROUND_DOWN:
 			up_count = data[2] / devpriv->clock_ns;
@@ -4314,9 +4311,8 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 		}
 		switch (data[3]) {
 		case CMDF_ROUND_NEAREST:
-			down_count =
-			    (data[4] +
-			     devpriv->clock_ns / 2) / devpriv->clock_ns;
+			down_count = DIV_ROUND_CLOSEST(data[4],
+						       devpriv->clock_ns);
 			break;
 		case CMDF_ROUND_DOWN:
 			down_count = data[4] / devpriv->clock_ns;
@@ -4918,9 +4914,9 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 
 	*freq_divider = best_div;
 	*freq_multiplier = best_mult;
-	*actual_period_ns =
-	    (best_period_picosec * fudge_factor_80_to_20Mhz +
-	     (pico_per_nano / 2)) / pico_per_nano;
+	*actual_period_ns = DIV_ROUND_CLOSEST(best_period_picosec *
+					      fudge_factor_80_to_20Mhz,
+					      pico_per_nano);
 	return 0;
 }
 

commit e563637b5fef2d1fbcd1efe457d4168fde7b3e0d
Author: Janani Ravichandran <janani.rvchndrn@gmail.com>
Date:   Thu Feb 11 19:07:48 2016 -0500

    staging: comedi: Use ARRAY_SIZE for sizes of arrays
    
    Use ARRAY_SIZE to calculate the size of an array to make code concise.
    The semantic patch used can be found here:
    https://github.com/coccinelle/coccinellery/commit/9cbab452a3a2e18439e8386d6c4a68ee42c3ee2b
    
    Signed-off-by: Janani Ravichandran <janani.rvchndrn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 929389b52572..1c2abb3feb42 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1166,8 +1166,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 			comedi_buf_write_samples(s, &data, 1);
 		}
 	} else {
-		if (n > sizeof(devpriv->ai_fifo_buffer) /
-		    sizeof(devpriv->ai_fifo_buffer[0])) {
+		if (n > ARRAY_SIZE(devpriv->ai_fifo_buffer)) {
 			dev_err(dev->class_dev,
 				"bug! ai_fifo_buffer too small\n");
 			async->events |= COMEDI_CB_ERROR;
@@ -1242,9 +1241,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 			     NISTC_AI_STATUS1_FIFO_E;
 		while (fifo_empty == 0) {
 			for (i = 0;
-			     i <
-			     sizeof(devpriv->ai_fifo_buffer) /
-			     sizeof(devpriv->ai_fifo_buffer[0]); i++) {
+			     i < ARRAY_SIZE(devpriv->ai_fifo_buffer); i++) {
 				fifo_empty = ni_stc_readw(dev,
 							  NISTC_AI_STATUS1_REG) &
 						NISTC_AI_STATUS1_FIFO_E;

commit f164cbf98fa8692ecbe1f870c50522985d34d1c2
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Jan 27 14:28:29 2016 -0700

    staging: comedi: ni_mio_common: add finite regeneration to dio output
    
    This patch continues the implementation of reinterpreting stop_arg when
    stop_src == TRIG_NONE for national instruments cdio output on e/m-series
    devices.  This is part of a series of patches that allow a user to have a
    specific buffer repeated as-is indefinitely.  The contents of the DMA
    buffer can be left static or changed by the user via mmap access to the DMA
    buffer.  If the contents are changed by the user, additional munging is not
    performed by the driver and only a single call to
    comedi_mark_buffer_written should be done.  The original behavior is
    preserved when stop_arg == 0, as would be the prior use case.
    
    As opposed to analog output, this patch is relatively simple.  First, the
    digital output capabilities are much more limited/simple as compared to the
    analog output device on NI e/m-series hardware, and second, this patch
    relies on changes made with the earlier patch to accomplish limiting the
    DMA buffer transfer.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 1a22c79c2817..929389b52572 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3630,7 +3630,9 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
 					   cmd->chanlist_len);
-	err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
+	err |= comedi_check_trigger_arg_max(&cmd->stop_arg,
+					    s->async->prealloc_bufsz /
+					    comedi_bytes_per_scan(s));
 
 	if (err)
 		return 3;
@@ -3707,6 +3709,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 
 static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct ni_private *devpriv = dev->private;
 	const struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned cdo_mode_bits;
 	int retval;
@@ -3731,6 +3734,10 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (retval < 0)
 		return retval;
 
+	ni_cmd_set_mite_transfer(devpriv->cdo_mite_ring, s, cmd,
+				 s->async->prealloc_bufsz /
+				 comedi_bytes_per_scan(s));
+
 	s->async->inttrig = ni_cdo_inttrig;
 
 	return 0;

commit 6aab7fee7a24395db1b556a5e5cf30aa2627c2be
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Jan 27 14:28:28 2016 -0700

    staging: comedi: ni_mio_common: adds finite regeneration to AO output
    
    This patch implements for analog output the reinterpretation of stop_arg
    when stop_src == TRIG_NONE to allow the user to specify the length of the
    buffer that should be repeated.  The intent is to allow a user to have a
    specific buffer repeated as-is indefinitely.  The contents of the DMA
    buffer can be left static or changed by the user via mmap access to the DMA
    buffer.  If the contents are changed by the user, additional munging is not
    performed by the driver and only a single call to
    comedi_mark_buffer_written should be done.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8f0fe3a26c73..1a22c79c2817 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1500,7 +1500,8 @@ static void handle_b_interrupt(struct comedi_device *dev,
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 
-	if (b_status & NISTC_AO_STATUS1_BC_TC)
+	if (s->async->cmd.stop_src != TRIG_NONE &&
+	    b_status & NISTC_AO_STATUS1_BC_TC)
 		s->async->events |= COMEDI_CB_EOA;
 
 #ifndef PCIDMA
@@ -2073,6 +2074,37 @@ static unsigned ni_timer_to_ns(const struct comedi_device *dev, int timer)
 	return devpriv->clock_ns * (timer + 1);
 }
 
+static void ni_cmd_set_mite_transfer(struct mite_dma_descriptor_ring *ring,
+				     struct comedi_subdevice *sdev,
+				     const struct comedi_cmd *cmd,
+				     unsigned int max_count) {
+#ifdef PCIDMA
+	unsigned int nbytes = max_count;
+
+	if (cmd->stop_arg > 0 && cmd->stop_arg < max_count)
+		nbytes = cmd->stop_arg;
+	nbytes *= comedi_bytes_per_scan(sdev);
+
+	if (nbytes > sdev->async->prealloc_bufsz) {
+		if (cmd->stop_arg > 0)
+			dev_err(sdev->device->class_dev,
+				"ni_cmd_set_mite_transfer: tried exact data transfer limits greater than buffer size\n");
+
+		/*
+		 * we can only transfer up to the size of the buffer.  In this
+		 * case, the user is expected to continue to write into the
+		 * comedi buffer (already implemented as a ring buffer).
+		 */
+		nbytes = sdev->async->prealloc_bufsz;
+	}
+
+	mite_init_ring_descriptors(ring, sdev, nbytes);
+#else
+	dev_err(sdev->device->class_dev,
+		"ni_cmd_set_mite_transfer: exact data transfer limits not implemented yet without DMA\n");
+#endif
+}
+
 static unsigned ni_min_ai_scan_period_ns(struct comedi_device *dev,
 					 unsigned num_channels)
 {
@@ -3062,12 +3094,16 @@ static void ni_ao_cmd_set_counters(struct comedi_device *dev,
 	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_UC_INIT_LOAD_SRC;
 	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
 
+	/*
+	 * if a user specifies '0', this automatically assumes the entire 24bit
+	 * address space is available for the (multiple iterations of single
+	 * buffer) MISB.  Otherwise, stop_arg specifies the MISB length that
+	 * will be used, regardless of whether we are in continuous mode or not.
+	 * In continuous mode, the output will just iterate indefinitely over
+	 * the MISB.
+	 */
 	{
-		/*
-		 * Current behavior is to configure the maximum update count
-		 * possible when continuous output mode is requested.
-		 */
-		unsigned int stop_arg = cmd->stop_src == TRIG_COUNT ?
+		unsigned int stop_arg = cmd->stop_arg > 0 ?
 			(cmd->stop_arg & 0xffffff) : 0xffffff;
 
 		if (devpriv->is_m_series) {
@@ -3311,6 +3347,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_ao_cmd_set_channels(dev, s);
 	ni_ao_cmd_set_stop_conditions(dev, cmd);
 	ni_ao_cmd_set_fifo_mode(dev);
+	ni_cmd_set_mite_transfer(devpriv->ao_mite_ring, s, cmd, 0x00ffffff);
 	ni_ao_cmd_set_interrupts(dev, s);
 
 	/*
@@ -3381,11 +3418,7 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
 					   cmd->chanlist_len);
-
-	if (cmd->stop_src == TRIG_COUNT)
-		err |= comedi_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);
-	else	/* TRIG_NONE */
-		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
+	err |= comedi_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);
 
 	if (err)
 		return 3;
@@ -5240,7 +5273,6 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 	unsigned long flags;
 #ifdef PCIDMA
 	struct ni_private *devpriv = dev->private;
-	struct mite_struct *mite = devpriv->mite;
 #endif
 
 	if (!dev->attached)
@@ -5252,8 +5284,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 	a_status = ni_stc_readw(dev, NISTC_AI_STATUS1_REG);
 	b_status = ni_stc_readw(dev, NISTC_AO_STATUS1_REG);
 #ifdef PCIDMA
-	if (mite) {
-		struct ni_private *devpriv = dev->private;
+	if (devpriv->mite) {
 		unsigned long flags_too;
 
 		spin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);
@@ -5269,7 +5300,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 			ao_mite_status = mite_get_status(devpriv->ao_mite_chan);
 			if (ao_mite_status & CHSR_LINKC)
 				writel(CHOR_CLRLC,
-				       mite->mite_io_addr +
+				       devpriv->mite->mite_io_addr +
 				       MITE_CHOR(devpriv->
 						 ao_mite_chan->channel));
 		}

commit 080e6795cba316663a5eb4f49500937eca4f32cd
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Jan 27 14:28:27 2016 -0700

    staging: comedi: ni_mio_common: Cleans up/clarifies ni_ao_cmd
    
    This patch implements ni_ao_cmd much more closely organized like NI MHDDK
    examples and DAQ-STC pseudo-code.  Adds comments with some more specific
    references to the DAQ-STC.
    
    For stop_src==TRIG_NONE (continuous output mode of entire buffer), the
    count for the UC counter was corrected to represent the maximum count
    possible (0xffffff).  Prior behavior for stop_src=TRIG_NONE did not
    actually follow the DAQ-STC.  Furthermore, stop_src==TRIG_NONE now
    correctly uses code specialized for either m-series or e-series devices.
    
    It should be noted that stop_src==TRIG_NONE does _not_ with this patch
    (or with prior behavior in ni_mio_common) actually implement true
    continuous output.  Rather, the output is simply configured to operate as a
    single buffer output, but where the buffer is as large as is possible with
    NI-STC hardware.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 9df20d922d32..8f0fe3a26c73 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2912,42 +2912,68 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 	return 0;
 }
 
-static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+/*
+ * begin ni_ao_cmd.
+ * Organized similar to NI-STC and MHDDK examples.
+ * ni_ao_cmd is broken out into configuration sub-routines for clarity.
+ */
+
+static void ni_ao_cmd_personalize(struct comedi_device *dev,
+				  const struct comedi_cmd *cmd)
 {
 	const struct ni_board_struct *board = dev->board_ptr;
-	struct ni_private *devpriv = dev->private;
-	const struct comedi_cmd *cmd = &s->async->cmd;
-	int bits;
-	int i;
-	unsigned trigvar;
-	unsigned val;
-
-	if (dev->irq == 0) {
-		dev_err(dev->class_dev, "cannot run command without an irq\n");
-		return -EIO;
-	}
+	unsigned bits;
 
 	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
 
-	ni_stc_writew(dev, NISTC_AO_CMD1_DISARM, NISTC_AO_CMD1_REG);
+	bits =
+	  /* fast CPU interface--only eseries */
+	  /* ((slow CPU interface) ? 0 : AO_Fast_CPU) | */
+	  NISTC_AO_PERSONAL_BC_SRC_SEL  |
+	  0 /* (use_original_pulse ? 0 : NISTC_AO_PERSONAL_UPDATE_TIMEBASE) */ |
+	  /*
+	   * FIXME:  start setting following bit when appropriate.  Need to
+	   * determine whether board is E4 or E1.
+	   * FROM MHHDK:
+	   * if board is E4 or E1
+	   *   Set bit "NISTC_AO_PERSONAL_UPDATE_PW" to 0
+	   * else
+	   *   set it to 1
+	   */
+	  NISTC_AO_PERSONAL_UPDATE_PW   |
+	  /* FIXME:  when should we set following bit to zero? */
+	  NISTC_AO_PERSONAL_TMRDACWR_PW |
+	  (board->ao_fifo_depth ?
+	    NISTC_AO_PERSONAL_FIFO_ENA : NISTC_AO_PERSONAL_DMA_PIO_CTRL)
+	  ;
+#if 0
+	/*
+	 * FIXME:
+	 * add something like ".has_individual_dacs = 0" to ni_board_struct
+	 * since, as F Hess pointed out, not all in m series have singles.  not
+	 * sure if e-series all have duals...
+	 */
 
-	if (devpriv->is_6xxx) {
-		ni_ao_win_outw(dev, NI611X_AO_MISC_CLEAR_WG,
-			       NI611X_AO_MISC_REG);
+	/*
+	 * F Hess: windows driver does not set NISTC_AO_PERSONAL_NUM_DAC bit for
+	 * 6281, verified with bus analyzer.
+	 */
+	if (devpriv->is_m_series)
+		bits |= NISTC_AO_PERSONAL_NUM_DAC;
+#endif
+	ni_stc_writew(dev, bits, NISTC_AO_PERSONAL_REG);
 
-		bits = 0;
-		for (i = 0; i < cmd->chanlist_len; i++) {
-			int chan;
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);
+}
 
-			chan = CR_CHAN(cmd->chanlist[i]);
-			bits |= 1 << chan;
-			ni_ao_win_outw(dev, chan, NI611X_AO_WAVEFORM_GEN_REG);
-		}
-		ni_ao_win_outw(dev, bits, NI611X_AO_TIMED_REG);
-	}
+static void ni_ao_cmd_set_trigger(struct comedi_device *dev,
+				  const struct comedi_cmd *cmd)
+{
+	struct ni_private *devpriv = dev->private;
 
-	ni_ao_config_chanlist(dev, s, cmd->chanlist, cmd->chanlist_len, 1);
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
 
+	/* sync */
 	if (cmd->stop_src == TRIG_NONE) {
 		devpriv->ao_mode1 |= NISTC_AO_MODE1_CONTINUOUS;
 		devpriv->ao_mode1 &= ~NISTC_AO_MODE1_TRIGGER_ONCE;
@@ -2957,179 +2983,346 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
 
-	val = devpriv->ao_trigger_select;
-	switch (cmd->start_src) {
-	case TRIG_INT:
-	case TRIG_NOW:
-		val &= ~(NISTC_AO_TRIG_START1_POLARITY |
-			 NISTC_AO_TRIG_START1_SEL_MASK);
-		val |= NISTC_AO_TRIG_START1_EDGE |
-		       NISTC_AO_TRIG_START1_SYNC;
-		break;
-	case TRIG_EXT:
-		val = NISTC_AO_TRIG_START1_SEL(CR_CHAN(cmd->start_arg) + 1);
-		if (cmd->start_arg & CR_INVERT) {
-			/* 0=active high, 1=active low. see daq-stc 3-24 (p186) */
-			val |= NISTC_AO_TRIG_START1_POLARITY;
-		}
-		if (cmd->start_arg & CR_EDGE) {
-			/* 0=edge detection disabled, 1=enabled */
-			val |= NISTC_AO_TRIG_START1_EDGE;
+	{
+		unsigned int trigsel = devpriv->ao_trigger_select;
+
+		switch (cmd->start_src) {
+		case TRIG_INT:
+		case TRIG_NOW:
+			trigsel &= ~(NISTC_AO_TRIG_START1_POLARITY |
+				     NISTC_AO_TRIG_START1_SEL_MASK);
+			trigsel |= NISTC_AO_TRIG_START1_EDGE |
+				   NISTC_AO_TRIG_START1_SYNC;
+			break;
+		case TRIG_EXT:
+			trigsel = NISTC_AO_TRIG_START1_SEL(
+					CR_CHAN(cmd->start_arg) + 1);
+			if (cmd->start_arg & CR_INVERT)
+				/*
+				 * 0=active high, 1=active low.
+				 * see daq-stc 3-24 (p186)
+				 */
+				trigsel |= NISTC_AO_TRIG_START1_POLARITY;
+			if (cmd->start_arg & CR_EDGE)
+				/* 0=edge detection disabled, 1=enabled */
+				trigsel |= NISTC_AO_TRIG_START1_EDGE;
+			break;
+		default:
+			BUG();
+			break;
 		}
+
+		devpriv->ao_trigger_select = trigsel;
 		ni_stc_writew(dev, devpriv->ao_trigger_select,
 			      NISTC_AO_TRIG_SEL_REG);
-		break;
-	default:
-		BUG();
-		break;
 	}
-	devpriv->ao_trigger_select = val;
-	ni_stc_writew(dev, devpriv->ao_trigger_select, NISTC_AO_TRIG_SEL_REG);
+	/* AO_Delayed_START1 = 0, we do not support delayed start...yet */
 
+	/* sync */
+	/* select DA_START1 as PFI6/AO_START1 when configured as an output */
 	devpriv->ao_mode3 &= ~NISTC_AO_MODE3_TRIG_LEN;
 	ni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);
 
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);
+}
+
+static void ni_ao_cmd_set_counters(struct comedi_device *dev,
+				   const struct comedi_cmd *cmd)
+{
+	struct ni_private *devpriv = dev->private;
+	/* Not supporting 'waveform staging' or 'local buffer with pauses' */
+
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
+	/*
+	 * This relies on ao_mode1/(Trigger_Once | Continuous) being set in
+	 * set_trigger above.  It is unclear whether we really need to re-write
+	 * this register with these values.  The mhddk examples for e-series
+	 * show writing this in both places, but the examples for m-series show
+	 * a single write in the set_counters function (here).
+	 */
 	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
+
+	/* sync (upload number of buffer iterations -1) */
+	/* indicate that we want to use BC_Load_A_Register as the source */
 	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_BC_INIT_LOAD_SRC;
 	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
-	if (cmd->stop_src == TRIG_NONE)
-		ni_stc_writel(dev, 0xffffff, NISTC_AO_BC_LOADA_REG);
-	else
-		ni_stc_writel(dev, 0, NISTC_AO_BC_LOADA_REG);
+
+	/*
+	 * if the BC_TC interrupt is still issued in spite of UC, BC, UI
+	 * ignoring BC_TC, then we will need to find a way to ignore that
+	 * interrupt in continuous mode.
+	 */
+	ni_stc_writel(dev, 0, NISTC_AO_BC_LOADA_REG); /* iter once */
+
+	/* sync (issue command to load number of buffer iterations -1) */
 	ni_stc_writew(dev, NISTC_AO_CMD1_BC_LOAD, NISTC_AO_CMD1_REG);
+
+	/* sync (upload number of updates in buffer) */
+	/* indicate that we want to use UC_Load_A_Register as the source */
 	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_UC_INIT_LOAD_SRC;
 	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
+
+	{
+		/*
+		 * Current behavior is to configure the maximum update count
+		 * possible when continuous output mode is requested.
+		 */
+		unsigned int stop_arg = cmd->stop_src == TRIG_COUNT ?
+			(cmd->stop_arg & 0xffffff) : 0xffffff;
+
 		if (devpriv->is_m_series) {
-			/*  this is how the NI example code does it for m-series boards, verified correct with 6259 */
-			ni_stc_writel(dev, cmd->stop_arg - 1,
-				      NISTC_AO_UC_LOADA_REG);
+			/*
+			 * this is how the NI example code does it for m-series
+			 * boards, verified correct with 6259
+			 */
+			ni_stc_writel(dev, stop_arg - 1, NISTC_AO_UC_LOADA_REG);
+
+			/* sync (issue cmd to load number of updates in MISB) */
 			ni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD,
 				      NISTC_AO_CMD1_REG);
 		} else {
-			ni_stc_writel(dev, cmd->stop_arg,
-				      NISTC_AO_UC_LOADA_REG);
+			ni_stc_writel(dev, stop_arg, NISTC_AO_UC_LOADA_REG);
+
+			/* sync (issue cmd to load number of updates in MISB) */
 			ni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD,
 				      NISTC_AO_CMD1_REG);
-			ni_stc_writel(dev, cmd->stop_arg - 1,
-				      NISTC_AO_UC_LOADA_REG);
+
+			/*
+			 * sync (upload number of updates-1 in MISB)
+			 * --eseries only?
+			 */
+			ni_stc_writel(dev, stop_arg - 1, NISTC_AO_UC_LOADA_REG);
 		}
-		break;
-	case TRIG_NONE:
-		ni_stc_writel(dev, 0xffffff, NISTC_AO_UC_LOADA_REG);
-		ni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD, NISTC_AO_CMD1_REG);
-		ni_stc_writel(dev, 0xffffff, NISTC_AO_UC_LOADA_REG);
-		break;
-	default:
-		ni_stc_writel(dev, 0, NISTC_AO_UC_LOADA_REG);
-		ni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD, NISTC_AO_CMD1_REG);
-		ni_stc_writel(dev, cmd->stop_arg, NISTC_AO_UC_LOADA_REG);
 	}
 
-	devpriv->ao_mode1 &= ~(NISTC_AO_MODE1_UPDATE_SRC_MASK |
-			       NISTC_AO_MODE1_UI_SRC_MASK |
-			       NISTC_AO_MODE1_UPDATE_SRC_POLARITY |
-			       NISTC_AO_MODE1_UI_SRC_POLARITY);
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);
+}
+
+static void ni_ao_cmd_set_update(struct comedi_device *dev,
+				 const struct comedi_cmd *cmd)
+{
+	struct ni_private *devpriv = dev->private;
+
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
+
+	/*
+	 * zero out these bit fields to be set below. Does an ao-reset do this
+	 * automatically?
+	 */
+	devpriv->ao_mode1 &= ~(
+	  NISTC_AO_MODE1_UI_SRC_MASK         |
+	  NISTC_AO_MODE1_UI_SRC_POLARITY     |
+	  NISTC_AO_MODE1_UPDATE_SRC_MASK     |
+	  NISTC_AO_MODE1_UPDATE_SRC_POLARITY
+	);
+
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
-		devpriv->ao_cmd2 &= ~NISTC_AO_CMD2_BC_GATE_ENA;
-		trigvar =
-		    ni_ns_to_timer(dev, cmd->scan_begin_arg,
-				   CMDF_ROUND_NEAREST);
-		ni_stc_writel(dev, 1, NISTC_AO_UI_LOADA_REG);
-		ni_stc_writew(dev, NISTC_AO_CMD1_UI_LOAD, NISTC_AO_CMD1_REG);
-		ni_stc_writel(dev, trigvar, NISTC_AO_UI_LOADA_REG);
+		devpriv->ao_cmd2  &= ~NISTC_AO_CMD2_BC_GATE_ENA;
+
+		/*
+		 * NOTE: there are several other ways of configuring internal
+		 * updates, but we'll only support one for now:  using
+		 * AO_IN_TIMEBASE, w/o waveform staging, w/o a delay between
+		 * START1 and first update, and also w/o local buffer mode w/
+		 * pauses.
+		 */
+
+		/*
+		 * This is already done above:
+		 * devpriv->ao_mode1 &= ~(
+		 *   // set UPDATE_Source to UI_TC:
+		 *   NISTC_AO_MODE1_UPDATE_SRC_MASK |
+		 *   // set UPDATE_Source_Polarity to rising (required?)
+		 *   NISTC_AO_MODE1_UPDATE_SRC_POLARITY |
+		 *   // set UI_Source to AO_IN_TIMEBASE1:
+		 *   NISTC_AO_MODE1_UI_SRC_MASK     |
+		 *   // set UI_Source_Polarity to rising (required?)
+		 *   NISTC_AO_MODE1_UI_SRC_POLARITY
+		 * );
+		 */
+
+		/*
+		 * TODO:  use ao_ui_clock_source to allow all possible signals
+		 * to be routed to UI_Source_Select.  See tSTC.h for
+		 * eseries/ni67xx and tMSeries.h for mseries.
+		 */
+
+		{
+			unsigned trigvar = ni_ns_to_timer(dev,
+							  cmd->scan_begin_arg,
+							  CMDF_ROUND_NEAREST);
+
+			/*
+			 * Wait N TB3 ticks after the start trigger before
+			 * clocking(N must be >=2).
+			 */
+			/* following line: 2-1 per STC */
+			ni_stc_writel(dev, 1,           NISTC_AO_UI_LOADA_REG);
+			ni_stc_writew(dev, NISTC_AO_CMD1_UI_LOAD,
+				      NISTC_AO_CMD1_REG);
+			/* following line: N-1 per STC */
+			ni_stc_writel(dev, trigvar - 1, NISTC_AO_UI_LOADA_REG);
+		}
 		break;
 	case TRIG_EXT:
-		devpriv->ao_mode1 |=
-		    NISTC_AO_MODE1_UPDATE_SRC(cmd->scan_begin_arg);
+		/* FIXME:  assert scan_begin_arg != 0, ret failure otherwise */
+		devpriv->ao_cmd2  |= NISTC_AO_CMD2_BC_GATE_ENA;
+		devpriv->ao_mode1 |= NISTC_AO_MODE1_UPDATE_SRC(
+					CR_CHAN(cmd->scan_begin_arg));
 		if (cmd->scan_begin_arg & CR_INVERT)
 			devpriv->ao_mode1 |= NISTC_AO_MODE1_UPDATE_SRC_POLARITY;
-		devpriv->ao_cmd2 |= NISTC_AO_CMD2_BC_GATE_ENA;
 		break;
 	default:
 		BUG();
 		break;
 	}
+
 	ni_stc_writew(dev, devpriv->ao_cmd2, NISTC_AO_CMD2_REG);
 	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
 	devpriv->ao_mode2 &= ~(NISTC_AO_MODE2_UI_RELOAD_MODE(3) |
 			       NISTC_AO_MODE2_UI_INIT_LOAD_SRC);
 	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
 
+	/* Configure DAQ-STC for Timed update mode */
+	devpriv->ao_cmd1 |= NISTC_AO_CMD1_DAC1_UPDATE_MODE |
+			    NISTC_AO_CMD1_DAC0_UPDATE_MODE;
+	/* We are not using UPDATE2-->don't have to set DACx_Source_Select */
+	ni_stc_writew(dev, devpriv->ao_cmd1, NISTC_AO_CMD1_REG);
+
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);
+}
+
+static void ni_ao_cmd_set_channels(struct comedi_device *dev,
+				   struct comedi_subdevice *s)
+{
+	struct ni_private *devpriv = dev->private;
+	const struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned bits = 0;
+
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
+
+	if (devpriv->is_6xxx) {
+		unsigned int i;
+
+		bits = 0;
+		for (i = 0; i < cmd->chanlist_len; ++i) {
+			int chan = CR_CHAN(cmd->chanlist[i]);
+
+			bits |= 1 << chan;
+			ni_ao_win_outw(dev, chan, NI611X_AO_WAVEFORM_GEN_REG);
+		}
+		ni_ao_win_outw(dev, bits, NI611X_AO_TIMED_REG);
+	}
+
+	ni_ao_config_chanlist(dev, s, cmd->chanlist, cmd->chanlist_len, 1);
+
 	if (cmd->scan_end_arg > 1) {
 		devpriv->ao_mode1 |= NISTC_AO_MODE1_MULTI_CHAN;
-		ni_stc_writew(dev,
-			      NISTC_AO_OUT_CTRL_CHANS(cmd->scan_end_arg - 1) |
-			      NISTC_AO_OUT_CTRL_UPDATE_SEL_HIGHZ,
-			      NISTC_AO_OUT_CTRL_REG);
-	} else {
-		unsigned bits;
+		bits = NISTC_AO_OUT_CTRL_CHANS(cmd->scan_end_arg - 1)
+				 | NISTC_AO_OUT_CTRL_UPDATE_SEL_HIGHZ;
 
+	} else {
 		devpriv->ao_mode1 &= ~NISTC_AO_MODE1_MULTI_CHAN;
 		bits = NISTC_AO_OUT_CTRL_UPDATE_SEL_HIGHZ;
-		if (devpriv->is_m_series || devpriv->is_6xxx) {
+		if (devpriv->is_m_series | devpriv->is_6xxx)
 			bits |= NISTC_AO_OUT_CTRL_CHANS(0);
-		} else {
-			bits |=
-			    NISTC_AO_OUT_CTRL_CHANS(CR_CHAN(cmd->chanlist[0]));
-		}
-		ni_stc_writew(dev, bits, NISTC_AO_OUT_CTRL_REG);
+		else
+			bits |= NISTC_AO_OUT_CTRL_CHANS(
+					CR_CHAN(cmd->chanlist[0]));
 	}
+
 	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
+	ni_stc_writew(dev, bits,              NISTC_AO_OUT_CTRL_REG);
 
-	/* Configure DAQ-STC for Timed update mode */
-	devpriv->ao_cmd1 |= NISTC_AO_CMD1_DAC1_UPDATE_MODE |
-			    NISTC_AO_CMD1_DAC0_UPDATE_MODE;
-	/* We are not using UPDATE2-->don't have to set DACx_Source_Select */
-	ni_stc_writew(dev, devpriv->ao_cmd1, NISTC_AO_CMD1_REG);
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);
+}
+
+static void ni_ao_cmd_set_stop_conditions(struct comedi_device *dev,
+					  const struct comedi_cmd *cmd)
+{
+	struct ni_private *devpriv = dev->private;
+
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
 
 	devpriv->ao_mode3 |= NISTC_AO_MODE3_STOP_ON_OVERRUN_ERR;
 	ni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);
 
+	/*
+	 * Since we are not supporting waveform staging, we ignore these errors:
+	 * NISTC_AO_MODE3_STOP_ON_BC_TC_ERR,
+	 * NISTC_AO_MODE3_STOP_ON_BC_TC_TRIG_ERR
+	 */
+
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);
+}
+
+static void ni_ao_cmd_set_fifo_mode(struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
+
 	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_FIFO_MODE_MASK;
 #ifdef PCIDMA
 	devpriv->ao_mode2 |= NISTC_AO_MODE2_FIFO_MODE_HF_F;
 #else
 	devpriv->ao_mode2 |= NISTC_AO_MODE2_FIFO_MODE_HF;
 #endif
+	/* NOTE:  this is where use_onboard_memory=True would be implemented */
 	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_FIFO_REXMIT_ENA;
 	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
 
-	bits = NISTC_AO_PERSONAL_BC_SRC_SEL |
-	       NISTC_AO_PERSONAL_UPDATE_PW |
-	       NISTC_AO_PERSONAL_TMRDACWR_PW;
-	if (board->ao_fifo_depth)
-		bits |= NISTC_AO_PERSONAL_FIFO_ENA;
-	else
-		bits |= NISTC_AO_PERSONAL_DMA_PIO_CTRL;
-#if 0
-	/*
-	 * F Hess: windows driver does not set NISTC_AO_PERSONAL_NUM_DAC bit
-	 * for 6281, verified with bus analyzer.
-	 */
-	if (devpriv->is_m_series)
-		bits |= NISTC_AO_PERSONAL_NUM_DAC;
-#endif
-	ni_stc_writew(dev, bits, NISTC_AO_PERSONAL_REG);
-	/*  enable sending of ao dma requests */
+	/* enable sending of ao fifo requests (dma request) */
 	ni_stc_writew(dev, NISTC_AO_START_AOFREQ_ENA, NISTC_AO_START_SEL_REG);
 
 	ni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		ni_stc_writew(dev, NISTC_INTB_ACK_AO_BC_TC,
-			      NISTC_INTB_ACK_REG);
+	/* we are not supporting boards with virtual fifos */
+}
+
+static void ni_ao_cmd_set_interrupts(struct comedi_device *dev,
+				     struct comedi_subdevice *s)
+{
+	if (s->async->cmd.stop_src == TRIG_COUNT)
 		ni_set_bits(dev, NISTC_INTB_ENA_REG,
 			    NISTC_INTB_ENA_AO_BC_TC, 1);
-	}
 
 	s->async->inttrig = ni_ao_inttrig;
+}
 
+static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+{
+	struct ni_private *devpriv = dev->private;
+	const struct comedi_cmd *cmd = &s->async->cmd;
+
+	if (dev->irq == 0) {
+		dev_err(dev->class_dev, "cannot run command without an irq");
+		return -EIO;
+	}
+
+	/* ni_ao_reset should have already been done */
+	ni_ao_cmd_personalize(dev, cmd);
+	/* clearing fifo and preload happens elsewhere */
+
+	ni_ao_cmd_set_trigger(dev, cmd);
+	ni_ao_cmd_set_counters(dev, cmd);
+	ni_ao_cmd_set_update(dev, cmd);
+	ni_ao_cmd_set_channels(dev, s);
+	ni_ao_cmd_set_stop_conditions(dev, cmd);
+	ni_ao_cmd_set_fifo_mode(dev);
+	ni_ao_cmd_set_interrupts(dev, s);
+
+	/*
+	 * arm(ing) and star(ting) happen in ni_ao_inttrig, which _must_ be
+	 * called for ao commands since 1) TRIG_NOW is not supported and 2) DMA
+	 * must be setup and initially written to before arm/start happen.
+	 */
 	return 0;
 }
 
+/* end ni_ao_cmd */
+
 static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd)
 {

commit d2a6c32a2209ac79cb52b56e46ec37fdc1df6ce1
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Jan 27 14:28:26 2016 -0700

    staging: comedi: ni_mio_common: make more bits in ao_cmd1 reg be stateful
    
    Bits NISTC_AO_CMD1_DAC0_UPDATE_MODE and NISTC_AO_CMD1_DAC1_UPDATE_MODE are
    now saved in the local copy of the AO_CMD1 register.  This is more
    appropriate than prior methods of setting these bits specifically _both_
    in the ni_ao_cmd configuration function _and_ the ni_ao_inttrig trigger
    function.  With this patch, the bits are only specifically called out now
    in the ni_ao_cmd configuration function.  In the ni_ao_inttrig trigger
    function, only the UI_ARM, UC_ARM, BC_ARM bits of the ao_cmd1 register are
    specifically called out.  Each of these bits is a strobe bit, while the
    DAC[0-1]_UPDATE_MODE bits are simple write bits.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7d2091d8b72b..9df20d922d32 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2903,8 +2903,6 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 	ni_stc_writew(dev, NISTC_AO_CMD1_UI_ARM |
 			   NISTC_AO_CMD1_UC_ARM |
 			   NISTC_AO_CMD1_BC_ARM |
-			   NISTC_AO_CMD1_DAC1_UPDATE_MODE |
-			   NISTC_AO_CMD1_DAC0_UPDATE_MODE |
 			   devpriv->ao_cmd1,
 		      NISTC_AO_CMD1_REG);
 
@@ -3081,9 +3079,11 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
 
-	ni_stc_writew(dev, NISTC_AO_CMD1_DAC1_UPDATE_MODE |
-			   NISTC_AO_CMD1_DAC0_UPDATE_MODE,
-		      NISTC_AO_CMD1_REG);
+	/* Configure DAQ-STC for Timed update mode */
+	devpriv->ao_cmd1 |= NISTC_AO_CMD1_DAC1_UPDATE_MODE |
+			    NISTC_AO_CMD1_DAC0_UPDATE_MODE;
+	/* We are not using UPDATE2-->don't have to set DACx_Source_Select */
+	ni_stc_writew(dev, devpriv->ao_cmd1, NISTC_AO_CMD1_REG);
 
 	devpriv->ao_mode3 |= NISTC_AO_MODE3_STOP_ON_OVERRUN_ERR;
 	ni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);

commit 5c93736c208d89c7832624b8f3a2ce616473ab65
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Jan 27 14:28:25 2016 -0700

    staging: comedi: ni_mio_common: Cleans up/clarifies ni_ao_reset
    
    This patch implements ni_ao_reset much more closely organized like NI MHDDK
    examples and DAQ-STC pseudo-code.  Adds comments with some more specific
    references to the DAQ-STC.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 1978d65636fd..7d2091d8b72b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3215,48 +3215,70 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	/* See 3.6.1.2 "Resetting", of DAQ-STC Technical Reference Manual */
+
+	/*
+	 * In the following, the "--sync" comments are meant to denote
+	 * asynchronous boundaries for setting the registers as described in the
+	 * DAQ-STC mostly in the order also described in the DAQ-STC.
+	 */
+
 	struct ni_private *devpriv = dev->private;
 
 	ni_release_ao_mite_channel(dev);
 
+	/* --sync (reset AO) */
+	if (devpriv->is_m_series)
+		/* following example in mhddk for m-series */
+		ni_stc_writew(dev, NISTC_RESET_AO, NISTC_RESET_REG);
+
+	/*--sync (start config) */
 	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
+
+	/*--sync (Disarm) */
 	ni_stc_writew(dev, NISTC_AO_CMD1_DISARM, NISTC_AO_CMD1_REG);
-	ni_set_bits(dev, NISTC_INTB_ENA_REG, ~0, 0);
-	ni_stc_writew(dev, NISTC_AO_PERSONAL_BC_SRC_SEL, NISTC_AO_PERSONAL_REG);
-	ni_stc_writew(dev, NISTC_INTB_ACK_AO_ALL, NISTC_INTB_ACK_REG);
-	ni_stc_writew(dev, NISTC_AO_PERSONAL_BC_SRC_SEL |
-			   NISTC_AO_PERSONAL_UPDATE_PW |
-			   NISTC_AO_PERSONAL_TMRDACWR_PW,
-		      NISTC_AO_PERSONAL_REG);
-	ni_stc_writew(dev, 0, NISTC_AO_OUT_CTRL_REG);
-	ni_stc_writew(dev, 0, NISTC_AO_START_SEL_REG);
-	devpriv->ao_cmd1 = 0;
-	ni_stc_writew(dev, devpriv->ao_cmd1, NISTC_AO_CMD1_REG);
-	devpriv->ao_cmd2 = 0;
-	ni_stc_writew(dev, devpriv->ao_cmd2, NISTC_AO_CMD2_REG);
+
+	/*
+	 * --sync
+	 * (clear bunch of registers--mseries mhddk examples do not include
+	 * this)
+	 */
+	devpriv->ao_cmd1  = 0;
+	devpriv->ao_cmd2  = 0;
 	devpriv->ao_mode1 = 0;
-	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
 	devpriv->ao_mode2 = 0;
-	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
 	if (devpriv->is_m_series)
 		devpriv->ao_mode3 = NISTC_AO_MODE3_LAST_GATE_DISABLE;
 	else
 		devpriv->ao_mode3 = 0;
-	ni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);
 	devpriv->ao_trigger_select = 0;
-	ni_stc_writew(dev, devpriv->ao_trigger_select,
-		      NISTC_AO_TRIG_SEL_REG);
-	if (devpriv->is_6xxx) {
-		unsigned immediate_bits = 0;
-		unsigned i;
 
-		for (i = 0; i < s->n_chan; ++i)
-			immediate_bits |= 1 << i;
-		ni_ao_win_outw(dev, immediate_bits, NI671X_AO_IMMEDIATE_REG);
+	ni_stc_writew(dev, 0, NISTC_AO_PERSONAL_REG);
+	ni_stc_writew(dev, 0, NISTC_AO_CMD1_REG);
+	ni_stc_writew(dev, 0, NISTC_AO_CMD2_REG);
+	ni_stc_writew(dev, 0, NISTC_AO_MODE1_REG);
+	ni_stc_writew(dev, 0, NISTC_AO_MODE2_REG);
+	ni_stc_writew(dev, 0, NISTC_AO_OUT_CTRL_REG);
+	ni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);
+	ni_stc_writew(dev, 0, NISTC_AO_START_SEL_REG);
+	ni_stc_writew(dev, 0, NISTC_AO_TRIG_SEL_REG);
+
+	/*--sync (disable interrupts) */
+	ni_set_bits(dev, NISTC_INTB_ENA_REG, ~0, 0);
+
+	/*--sync (ack) */
+	ni_stc_writew(dev, NISTC_AO_PERSONAL_BC_SRC_SEL, NISTC_AO_PERSONAL_REG);
+	ni_stc_writew(dev, NISTC_INTB_ACK_AO_ALL, NISTC_INTB_ACK_REG);
+
+	/*--not in DAQ-STC.  which doc? */
+	if (devpriv->is_6xxx) {
+		ni_ao_win_outw(dev, (1u << s->n_chan) - 1u,
+			       NI671X_AO_IMMEDIATE_REG);
 		ni_ao_win_outw(dev, NI611X_AO_MISC_CLEAR_WG,
 			       NI611X_AO_MISC_REG);
 	}
 	ni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);
+	/*--end */
 
 	return 0;
 }

commit f08a28e65cbdf80b4b4da7e423c45ee7c3ef35ac
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Tue Jan 12 11:05:10 2016 -0700

    staging: comedi: ni_mio_common: use CR_CHAN more consistently
    
    Generally, the CR_CHAN macro is/should be used to access the relevant bits
    for channel identification in cmd->*_arg when the corresponding
    cmd->*_src==TRIG_EXT, including cmd->convert_arg in this case.
    
    This patch does not fix a bug per se, as NISTC_AI_MODE1_CONVERT_SRC() already
    masks the value sufficiently, but using CR_CHAN() here makes the code clearer as
    it avoids passing some irrelevant bits to NISTC_AI_MODE1_CONVERT_SRC() in the
    first place.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5e8130a7d670..1978d65636fd 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2428,7 +2428,8 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);
 		break;
 	case TRIG_EXT:
-		mode1 |= NISTC_AI_MODE1_CONVERT_SRC(1 + cmd->convert_arg);
+		mode1 |= NISTC_AI_MODE1_CONVERT_SRC(1 +
+						    CR_CHAN(cmd->convert_arg));
 		if ((cmd->convert_arg & CR_INVERT) == 0)
 			mode1 |= NISTC_AI_MODE1_CONVERT_POLARITY;
 		ni_stc_writew(dev, mode1, NISTC_AI_MODE1_REG);

commit c9e5ec256c7af7f1558290b66dd145326c403a18
Author: Andrzej Pietrasiewicz <andrzejtp2010@gmail.com>
Date:   Sat Nov 14 19:19:10 2015 +0100

    staging: comedi: ni_mio_common: add "no_channel" versions of some functions
    
    ni_release_ai_mite_channel(), ni_release_ao_mite_channel(),
    ni_release_gpct_mite_channel() and ni_release_cdo_mite_channel()
    call functions which interpret -1 as a special value meaning "no channel".
    This patch adds explicit "no_channel" versions instead.
    
    On the other hand, after "no_channel" versions are used,
    ni_set_ai_dma_channel(), ni_set_ao_dma_channel(),
    ni_set_gpct_dma_channel(), ni_set_cdo_dma_channel() are called with actual
    "channel" parameter being always unsigned, so their signatures are changed
    accordingly.
    
    A side benefit of the changes is suppressesing 4 sparse warnings:
    "warning: shift too big (4294967295) for type int".
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzejtp2010@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index cbb44fc6940b..5e8130a7d670 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -579,48 +579,54 @@ static inline unsigned ni_stc_dma_channel_select_bitfield(unsigned channel)
 	return 0;
 }
 
-/* negative channel means no channel */
-static inline void ni_set_ai_dma_channel(struct comedi_device *dev, int channel)
+static inline void ni_set_ai_dma_channel(struct comedi_device *dev,
+					 unsigned channel)
 {
-	unsigned bits = 0;
-
-	if (channel >= 0)
-		bits = ni_stc_dma_channel_select_bitfield(channel);
+	unsigned bits = ni_stc_dma_channel_select_bitfield(channel);
 
 	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,
 			NI_E_DMA_AI_SEL_MASK, NI_E_DMA_AI_SEL(bits));
 }
 
-/* negative channel means no channel */
-static inline void ni_set_ao_dma_channel(struct comedi_device *dev, int channel)
+static inline void ni_set_ai_dma_no_channel(struct comedi_device *dev)
 {
-	unsigned bits = 0;
+	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG, NI_E_DMA_AI_SEL_MASK, 0);
+}
 
-	if (channel >= 0)
-		bits = ni_stc_dma_channel_select_bitfield(channel);
+static inline void ni_set_ao_dma_channel(struct comedi_device *dev,
+					 unsigned channel)
+{
+	unsigned bits = ni_stc_dma_channel_select_bitfield(channel);
 
 	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,
 			NI_E_DMA_AO_SEL_MASK, NI_E_DMA_AO_SEL(bits));
 }
 
-/* negative channel means no channel */
+static inline void ni_set_ao_dma_no_channel(struct comedi_device *dev)
+{
+	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG, NI_E_DMA_AO_SEL_MASK, 0);
+}
+
 static inline void ni_set_gpct_dma_channel(struct comedi_device *dev,
 					   unsigned gpct_index,
-					   int channel)
+					   unsigned channel)
 {
-	unsigned bits = 0;
-
-	if (channel >= 0)
-		bits = ni_stc_dma_channel_select_bitfield(channel);
+	unsigned bits = ni_stc_dma_channel_select_bitfield(channel);
 
 	ni_set_bitfield(dev, NI_E_DMA_G0_G1_SEL_REG,
 			NI_E_DMA_G0_G1_SEL_MASK(gpct_index),
 			NI_E_DMA_G0_G1_SEL(gpct_index, bits));
 }
 
-/* negative mite_channel means no channel */
+static inline void ni_set_gpct_dma_no_channel(struct comedi_device *dev,
+					      unsigned gpct_index)
+{
+	ni_set_bitfield(dev, NI_E_DMA_G0_G1_SEL_REG,
+			NI_E_DMA_G0_G1_SEL_MASK(gpct_index), 0);
+}
+
 static inline void ni_set_cdo_dma_channel(struct comedi_device *dev,
-					  int mite_channel)
+					  unsigned mite_channel)
 {
 	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
@@ -628,16 +634,26 @@ static inline void ni_set_cdo_dma_channel(struct comedi_device *dev,
 
 	spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
 	devpriv->cdio_dma_select_reg &= ~NI_M_CDIO_DMA_SEL_CDO_MASK;
-	if (mite_channel >= 0) {
-		/*
-		 * XXX just guessing ni_stc_dma_channel_select_bitfield()
-		 * returns the right bits, under the assumption the cdio dma
-		 * selection works just like ai/ao/gpct.
-		 * Definitely works for dma channels 0 and 1.
-		 */
-		bits = ni_stc_dma_channel_select_bitfield(mite_channel);
-		devpriv->cdio_dma_select_reg |= NI_M_CDIO_DMA_SEL_CDO(bits);
-	}
+	/*
+	 * XXX just guessing ni_stc_dma_channel_select_bitfield()
+	 * returns the right bits, under the assumption the cdio dma
+	 * selection works just like ai/ao/gpct.
+	 * Definitely works for dma channels 0 and 1.
+	 */
+	bits = ni_stc_dma_channel_select_bitfield(mite_channel);
+	devpriv->cdio_dma_select_reg |= NI_M_CDIO_DMA_SEL_CDO(bits);
+	ni_writeb(dev, devpriv->cdio_dma_select_reg, NI_M_CDIO_DMA_SEL_REG);
+	mmiowb();
+	spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
+}
+
+static inline void ni_set_cdo_dma_no_channel(struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	unsigned long flags;
+
+	spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
+	devpriv->cdio_dma_select_reg &= ~NI_M_CDIO_DMA_SEL_CDO_MASK;
 	ni_writeb(dev, devpriv->cdio_dma_select_reg, NI_M_CDIO_DMA_SEL_REG);
 	mmiowb();
 	spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
@@ -745,7 +761,7 @@ static void ni_release_ai_mite_channel(struct comedi_device *dev)
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ai_mite_chan) {
-		ni_set_ai_dma_channel(dev, -1);
+		ni_set_ai_dma_no_channel(dev);
 		mite_release_channel(devpriv->ai_mite_chan);
 		devpriv->ai_mite_chan = NULL;
 	}
@@ -761,7 +777,7 @@ static void ni_release_ao_mite_channel(struct comedi_device *dev)
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ao_mite_chan) {
-		ni_set_ao_dma_channel(dev, -1);
+		ni_set_ao_dma_no_channel(dev);
 		mite_release_channel(devpriv->ao_mite_chan);
 		devpriv->ao_mite_chan = NULL;
 	}
@@ -781,7 +797,7 @@ static void ni_release_gpct_mite_channel(struct comedi_device *dev,
 		struct mite_channel *mite_chan =
 		    devpriv->counter_dev->counters[gpct_index].mite_chan;
 
-		ni_set_gpct_dma_channel(dev, gpct_index, -1);
+		ni_set_gpct_dma_no_channel(dev, gpct_index);
 		ni_tio_set_mite_channel(&devpriv->
 					counter_dev->counters[gpct_index],
 					NULL);
@@ -799,7 +815,7 @@ static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
-		ni_set_cdo_dma_channel(dev, -1);
+		ni_set_cdo_dma_no_channel(dev);
 		mite_release_channel(devpriv->cdo_mite_chan);
 		devpriv->cdo_mite_chan = NULL;
 	}

commit 212efdb1be77ae97e21afc35310f7f9c428f875c
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Sat Oct 31 06:34:29 2015 -0700

    Staging: comedi: ni_mio_common: Fix endian sparse warning
    
    Fix following sparse warnings:
    warning: cast to restricted __le32
    warning: cast to restricted __le16
    warning: incorrect type in assignment (different base types)
    expected unsigned short [unsigned] [assigned] val
    got restricted __le16 [usertype] <noident>
    
    Data is pointer of type void and can be used to store any type of data.
    In function ni_ai_munge:
    barray and array have the same 16 bit offset.
    blarray and larray have the same 32 bit offset.
    
    Signed-off-by: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 6cc304a4c59b..cbb44fc6940b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1516,13 +1516,17 @@ static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned short *array = data;
 	unsigned int *larray = data;
 	unsigned int i;
+#ifdef PCIDMA
+	__le16 *barray = data;
+	__le32 *blarray = data;
+#endif
 
 	for (i = 0; i < nsamples; i++) {
 #ifdef PCIDMA
 		if (s->subdev_flags & SDF_LSAMPL)
-			larray[i] = le32_to_cpu(larray[i]);
+			larray[i] = le32_to_cpu(blarray[i]);
 		else
-			array[i] = le16_to_cpu(array[i]);
+			array[i] = le16_to_cpu(barray[i]);
 #endif
 		if (s->subdev_flags & SDF_LSAMPL)
 			larray[i] += devpriv->ai_offset[chan_index];
@@ -2574,6 +2578,9 @@ static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int nsamples = comedi_bytes_to_samples(s, num_bytes);
 	unsigned short *array = data;
 	unsigned int i;
+#ifdef PCIDMA
+	__le16 buf, *barray = data;
+#endif
 
 	for (i = 0; i < nsamples; i++) {
 		unsigned int range = CR_RANGE(cmd->chanlist[chan_index]);
@@ -2586,10 +2593,11 @@ static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (comedi_range_is_bipolar(s, range))
 			val = comedi_offset_munge(s, val);
 #ifdef PCIDMA
-		val = cpu_to_le16(val);
-#endif
+		buf = cpu_to_le16(val);
+		barray[i] = buf;
+#else
 		array[i] = val;
-
+#endif
 		chan_index++;
 		chan_index %= cmd->chanlist_len;
 	}

commit 71f50e25c0073aa0f1d9274643cb216cfa3094be
Author: Geliang Tang <geliangtang@163.com>
Date:   Mon May 25 14:20:44 2015 +0000

    staging: comedi: keep the consistency
    
    Changed "register 0x%x" to "register=0x%x" to keep the consistency
    of this file.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index f01ef89d91be..6cc304a4c59b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3761,7 +3761,7 @@ static unsigned int ni_gpct_to_stc_register(struct comedi_device *dev,
 	if (reg < ARRAY_SIZE(ni_gpct_to_stc_regmap)) {
 		regmap = &ni_gpct_to_stc_regmap[reg];
 	} else {
-		dev_warn(dev->class_dev, "%s: unhandled register 0x%x\n",
+		dev_warn(dev->class_dev, "%s: unhandled register=0x%x\n",
 			 __func__, reg);
 		return 0;
 	}

commit cdfba23d77b10a4d7a235772fb91787e317a62e6
Author: Geliang Tang <geliangtang@163.com>
Date:   Mon May 25 14:20:43 2015 +0000

    staging: comedi: fix checkpatch error
    
    Fixed an error found by checkpatch.pl.
    ERROR: space required after that ',' (ctx:VxV)
    ./drivers/ni_mio_common.c:3764
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 9dfd4e6e6ced..f01ef89d91be 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3761,7 +3761,7 @@ static unsigned int ni_gpct_to_stc_register(struct comedi_device *dev,
 	if (reg < ARRAY_SIZE(ni_gpct_to_stc_regmap)) {
 		regmap = &ni_gpct_to_stc_regmap[reg];
 	} else {
-		dev_warn(dev->class_dev,"%s: unhandled register 0x%x\n",
+		dev_warn(dev->class_dev, "%s: unhandled register 0x%x\n",
 			 __func__, reg);
 		return 0;
 	}

commit 1645b55b50f032888fef7855e80a23d78dfa067b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 11 10:22:45 2015 -0700

    staging: comedi: ni_mio_common: fix build warning
    
    The kbuild test robot detected a build warning causes by commit f878071a.
    
    >> drivers/staging/comedi/drivers/ni_mio_common.c:2274:34:
       warning: right-hand operand of comma expression has no effect [-Wunused-value]
    
    That line should have been terminated by ';' and the following line removed.
    Not sure why it even builds on my test system...
    
    Reported-by: kbuild test robot
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c741dde9c0bb..9dfd4e6e6ced 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2268,8 +2268,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	case TRIG_INT:
 	case TRIG_NOW:
 		ai_trig |= NISTC_AI_TRIG_START1_EDGE |
-			   NISTC_AI_TRIG_START1_SEL(0),
-			   NISTC_AI_TRIG_SEL_REG;
+			   NISTC_AI_TRIG_START1_SEL(0);
 		break;
 	case TRIG_EXT:
 		ai_trig |= NISTC_AI_TRIG_START1_SEL(CR_CHAN(cmd->start_arg) +

commit ef3915435c587caa24b8840f29102aa49d921216
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 15:00:11 2015 -0700

    staging: comedi: ni_stc.h: tidy up the windowed_regs_67xx_61xx
    
    Rename the CamelCase. For aesthetics, convert the enum into defines.
    Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 33f01e1efb29..c741dde9c0bb 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1091,7 +1091,7 @@ static int ni_ao_prep_fifo(struct comedi_device *dev,
 	/* reset fifo */
 	ni_stc_writew(dev, 1, NISTC_DAC_FIFO_CLR_REG);
 	if (devpriv->is_6xxx)
-		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
+		ni_ao_win_outl(dev, 0x6, NI611X_AO_FIFO_OFFSET_LOAD_REG);
 
 	/* load some data */
 	nbytes = comedi_buf_read_n_available(s);
@@ -2736,9 +2736,9 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 	int i;
 
 	if (devpriv->is_6xxx) {
-		ni_ao_win_outw(dev, 1 << chan, AO_Immediate_671x);
+		ni_ao_win_outw(dev, 1 << chan, NI671X_AO_IMMEDIATE_REG);
 
-		reg = DACx_Direct_Data_671x(chan);
+		reg = NI671X_DAC_DIRECT_DATA_REG(chan);
 	} else if (devpriv->is_m_series) {
 		reg = NI_M_DAC_DIRECT_DATA_REG(chan);
 	} else {
@@ -2838,7 +2838,7 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 #ifdef PCIDMA
 	ni_stc_writew(dev, 1, NISTC_DAC_FIFO_CLR_REG);
 	if (devpriv->is_6xxx)
-		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
+		ni_ao_win_outl(dev, 0x6, NI611X_AO_FIFO_OFFSET_LOAD_REG);
 	ret = ni_ao_setup_MITE_dma(dev);
 	if (ret)
 		return ret;
@@ -2910,7 +2910,8 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_stc_writew(dev, NISTC_AO_CMD1_DISARM, NISTC_AO_CMD1_REG);
 
 	if (devpriv->is_6xxx) {
-		ni_ao_win_outw(dev, CLEAR_WG, AO_Misc_611x);
+		ni_ao_win_outw(dev, NI611X_AO_MISC_CLEAR_WG,
+			       NI611X_AO_MISC_REG);
 
 		bits = 0;
 		for (i = 0; i < cmd->chanlist_len; i++) {
@@ -2918,9 +2919,9 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 			chan = CR_CHAN(cmd->chanlist[i]);
 			bits |= 1 << chan;
-			ni_ao_win_outw(dev, chan, AO_Waveform_Generation_611x);
+			ni_ao_win_outw(dev, chan, NI611X_AO_WAVEFORM_GEN_REG);
 		}
-		ni_ao_win_outw(dev, bits, AO_Timed_611x);
+		ni_ao_win_outw(dev, bits, NI611X_AO_TIMED_REG);
 	}
 
 	ni_ao_config_chanlist(dev, s, cmd->chanlist, cmd->chanlist_len, 1);
@@ -3227,8 +3228,9 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		for (i = 0; i < s->n_chan; ++i)
 			immediate_bits |= 1 << i;
-		ni_ao_win_outw(dev, immediate_bits, AO_Immediate_671x);
-		ni_ao_win_outw(dev, CLEAR_WG, AO_Misc_611x);
+		ni_ao_win_outw(dev, immediate_bits, NI671X_AO_IMMEDIATE_REG);
+		ni_ao_win_outw(dev, NI611X_AO_MISC_CLEAR_WG,
+			       NI611X_AO_MISC_REG);
 	}
 	ni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);
 
@@ -3708,9 +3710,9 @@ static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	for (i = 0; i < s->n_chan; i++) {
 		ni_ao_win_outw(dev, NI_E_AO_DACSEL(i) | 0x0,
-			       AO_Configuration_2_67xx);
+			       NI67XX_AO_CFG2_REG);
 	}
-	ni_ao_win_outw(dev, 0x0, AO_Later_Single_Point_Updates);
+	ni_ao_win_outw(dev, 0x0, NI67XX_AO_SP_UPDATES_REG);
 }
 
 static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
@@ -4472,8 +4474,8 @@ static int cs5529_wait_for_idle(struct comedi_device *dev)
 	int i;
 
 	for (i = 0; i < timeout; i++) {
-		status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
-		if ((status & CSS_ADC_BUSY) == 0)
+		status = ni_ao_win_inw(dev, NI67XX_CAL_STATUS_REG);
+		if ((status & NI67XX_CAL_STATUS_BUSY) == 0)
 			break;
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (schedule_timeout(1))
@@ -4491,13 +4493,14 @@ static void cs5529_command(struct comedi_device *dev, unsigned short value)
 	static const int timeout = 100;
 	int i;
 
-	ni_ao_win_outw(dev, value, CAL_ADC_Command_67xx);
+	ni_ao_win_outw(dev, value, NI67XX_CAL_CMD_REG);
 	/* give time for command to start being serially clocked into cs5529.
-	 * this insures that the CSS_ADC_BUSY bit will get properly
+	 * this insures that the NI67XX_CAL_STATUS_BUSY bit will get properly
 	 * set before we exit this function.
 	 */
 	for (i = 0; i < timeout; i++) {
-		if ((ni_ao_win_inw(dev, CAL_ADC_Status_67xx) & CSS_ADC_BUSY))
+		if (ni_ao_win_inw(dev, NI67XX_CAL_STATUS_REG) &
+		    NI67XX_CAL_STATUS_BUSY)
 			break;
 		udelay(1);
 	}
@@ -4519,18 +4522,18 @@ static int cs5529_do_conversion(struct comedi_device *dev,
 			"timeout or signal in cs5529_do_conversion()\n");
 		return -ETIME;
 	}
-	status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
-	if (status & CSS_OSC_DETECT) {
+	status = ni_ao_win_inw(dev, NI67XX_CAL_STATUS_REG);
+	if (status & NI67XX_CAL_STATUS_OSC_DETECT) {
 		dev_err(dev->class_dev,
 			"cs5529 conversion error, status CSS_OSC_DETECT\n");
 		return -EIO;
 	}
-	if (status & CSS_OVERRANGE) {
+	if (status & NI67XX_CAL_STATUS_OVERRANGE) {
 		dev_err(dev->class_dev,
 			"cs5529 conversion error, overrange (ignoring)\n");
 	}
 	if (data) {
-		*data = ni_ao_win_inw(dev, CAL_ADC_Data_67xx);
+		*data = ni_ao_win_inw(dev, NI67XX_CAL_DATA_REG);
 		/* cs5529 returns 16 bit signed data in bipolar mode */
 		*data ^= (1 << 15);
 	}
@@ -4554,7 +4557,7 @@ static int cs5529_ai_insn_read(struct comedi_device *dev,
 		channel_select = INTERNAL_REF;
 	else
 		channel_select = CR_CHAN(insn->chanspec);
-	ni_ao_win_outw(dev, channel_select, AO_Calibration_Channel_Select_67xx);
+	ni_ao_win_outw(dev, channel_select, NI67XX_AO_CAL_CHAN_SEL_REG);
 
 	for (n = 0; n < insn->n; n++) {
 		retval = cs5529_do_conversion(dev, &sample);
@@ -4568,10 +4571,8 @@ static int cs5529_ai_insn_read(struct comedi_device *dev,
 static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
 				unsigned int reg_select_bits)
 {
-	ni_ao_win_outw(dev, ((value >> 16) & 0xff),
-		       CAL_ADC_Config_Data_High_Word_67xx);
-	ni_ao_win_outw(dev, (value & 0xffff),
-		       CAL_ADC_Config_Data_Low_Word_67xx);
+	ni_ao_win_outw(dev, (value >> 16) & 0xff, NI67XX_CAL_CFG_HI_REG);
+	ni_ao_win_outw(dev, value & 0xffff, NI67XX_CAL_CFG_LO_REG);
 	reg_select_bits &= CS5529_CMD_REG_MASK;
 	cs5529_command(dev, CS5529_CMD_CB | reg_select_bits);
 	if (cs5529_wait_for_idle(dev))

commit 94f0cbb99a040a8aceddb490e4ed08cd4d4a4fde
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 15:00:10 2015 -0700

    staging: comedi: ni_stc.h: tidy up the cs5529_command_bits
    
    For aesthetics, convert the enum into defines. Use the BIT() macro
    to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8a484fb5ea8e..33f01e1efb29 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4512,7 +4512,7 @@ static int cs5529_do_conversion(struct comedi_device *dev,
 	int retval;
 	unsigned short status;
 
-	cs5529_command(dev, CSCMD_COMMAND | CSCMD_SINGLE_CONVERSION);
+	cs5529_command(dev, CS5529_CMD_CB | CS5529_CMD_SINGLE_CONV);
 	retval = cs5529_wait_for_idle(dev);
 	if (retval) {
 		dev_err(dev->class_dev,
@@ -4572,8 +4572,8 @@ static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
 		       CAL_ADC_Config_Data_High_Word_67xx);
 	ni_ao_win_outw(dev, (value & 0xffff),
 		       CAL_ADC_Config_Data_Low_Word_67xx);
-	reg_select_bits &= CSCMD_REGISTER_SELECT_MASK;
-	cs5529_command(dev, CSCMD_COMMAND | reg_select_bits);
+	reg_select_bits &= CS5529_CMD_REG_MASK;
+	cs5529_command(dev, CS5529_CMD_CB | reg_select_bits);
 	if (cs5529_wait_for_idle(dev))
 		dev_err(dev->class_dev,
 			"timeout or signal in %s\n", __func__);
@@ -4587,14 +4587,14 @@ static int init_cs5529(struct comedi_device *dev)
 #if 1
 	/* do self-calibration */
 	cs5529_config_write(dev, config_bits | CS5529_CFG_CALIB_BOTH_SELF,
-			    CSCMD_CONFIG_REGISTER);
+			    CS5529_CFG_REG);
 	/* need to force a conversion for calibration to run */
 	cs5529_do_conversion(dev, NULL);
 #else
 	/* force gain calibration to 1 */
-	cs5529_config_write(dev, 0x400000, CSCMD_GAIN_REGISTER);
+	cs5529_config_write(dev, 0x400000, CS5529_GAIN_REG);
 	cs5529_config_write(dev, config_bits | CS5529_CFG_CALIB_OFFSET_SELF,
-			    CSCMD_CONFIG_REGISTER);
+			    CS5529_CFG_REG);
 	if (cs5529_wait_for_idle(dev))
 		dev_err(dev->class_dev,
 			"timeout or signal in %s\n", __func__);

commit b738aa3a131bdc670191318bebc558629b3f1ed4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 15:00:09 2015 -0700

    staging: comedi: ni_stc.h: tidy up the cs5529_configuration_bits
    
    For aesthetics, convert the enum into defines and the inline functions
    into macros. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 802aabf0deee..8a484fb5ea8e 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4581,19 +4581,19 @@ static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
 
 static int init_cs5529(struct comedi_device *dev)
 {
-	unsigned int config_bits =
-	    CSCFG_PORT_MODE | CSCFG_WORD_RATE_2180_CYCLES;
+	unsigned int config_bits = CS5529_CFG_PORT_FLAG |
+				   CS5529_CFG_WORD_RATE_2180;
 
 #if 1
 	/* do self-calibration */
-	cs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET_GAIN,
+	cs5529_config_write(dev, config_bits | CS5529_CFG_CALIB_BOTH_SELF,
 			    CSCMD_CONFIG_REGISTER);
 	/* need to force a conversion for calibration to run */
 	cs5529_do_conversion(dev, NULL);
 #else
 	/* force gain calibration to 1 */
 	cs5529_config_write(dev, 0x400000, CSCMD_GAIN_REGISTER);
-	cs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET,
+	cs5529_config_write(dev, config_bits | CS5529_CFG_CALIB_OFFSET_SELF,
 			    CSCMD_CONFIG_REGISTER);
 	if (cs5529_wait_for_idle(dev))
 		dev_err(dev->class_dev,

commit ee3e21ac4be697350369bbd1c0b70f4acb909fa0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 15:00:08 2015 -0700

    staging: comedi: ni_stc.h: rename the NI-6143 register defines
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e50eb9ac34bc..802aabf0deee 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -843,11 +843,11 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 
 	if (devpriv->is_6143) {
 		/*  Flush the 6143 data FIFO */
-		ni_writel(dev, 0x10, AIFIFO_Control_6143);
-		ni_writel(dev, 0x00, AIFIFO_Control_6143);
+		ni_writel(dev, 0x10, NI6143_AI_FIFO_CTRL_REG);
+		ni_writel(dev, 0x00, NI6143_AI_FIFO_CTRL_REG);
 		/*  Wait for complete */
 		for (i = 0; i < timeout; i++) {
-			if (!(ni_readl(dev, AIFIFO_Status_6143) & 0x10))
+			if (!(ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) & 0x10))
 				break;
 			udelay(1);
 		}
@@ -1134,7 +1134,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 	} else if (devpriv->is_6143) {
 		/*  This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed */
 		for (i = 0; i < n / 2; i++) {
-			dl = ni_readl(dev, AIFIFO_Data_6143);
+			dl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);
 
 			data = (dl >> 16) & 0xffff;
 			comedi_buf_write_samples(s, &data, 1);
@@ -1144,8 +1144,8 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 		if (n % 2) {
 			/* Assume there is a single sample stuck in the FIFO */
 			/* Get stranded sample into FIFO */
-			ni_writel(dev, 0x01, AIFIFO_Control_6143);
-			dl = ni_readl(dev, AIFIFO_Data_6143);
+			ni_writel(dev, 0x01, NI6143_AI_FIFO_CTRL_REG);
+			dl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);
 			data = (dl >> 16) & 0xffff;
 			comedi_buf_write_samples(s, &data, 1);
 		}
@@ -1202,8 +1202,8 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 		}
 	} else if (devpriv->is_6143) {
 		i = 0;
-		while (ni_readl(dev, AIFIFO_Status_6143) & 0x04) {
-			dl = ni_readl(dev, AIFIFO_Data_6143);
+		while (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) & 0x04) {
+			dl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);
 
 			/* This may get the hi/lo data in the wrong order */
 			data = dl >> 16;
@@ -1213,10 +1213,10 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 			i += 2;
 		}
 		/*  Check if stranded sample is present */
-		if (ni_readl(dev, AIFIFO_Status_6143) & 0x01) {
+		if (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) & 0x01) {
 			/* Get stranded sample into FIFO */
-			ni_writel(dev, 0x01, AIFIFO_Control_6143);
-			dl = ni_readl(dev, AIFIFO_Data_6143);
+			ni_writel(dev, 0x01, NI6143_AI_FIFO_CTRL_REG);
+			dl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);
 			data = (dl >> 16) & 0xffff;
 			comedi_buf_write_samples(s, &data, 1);
 		}
@@ -1271,10 +1271,10 @@ static void get_last_sample_6143(struct comedi_device *dev)
 		return;
 
 	/* Check if there's a single sample stuck in the FIFO */
-	if (ni_readl(dev, AIFIFO_Status_6143) & 0x01) {
+	if (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) & 0x01) {
 		/* Get stranded sample into FIFO */
-		ni_writel(dev, 0x01, AIFIFO_Control_6143);
-		dl = ni_readl(dev, AIFIFO_Data_6143);
+		ni_writel(dev, 0x01, NI6143_AI_FIFO_CTRL_REG);
+		dl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);
 
 		/* This may get the hi/lo data in the wrong order */
 		data = (dl >> 16) & 0xffff;
@@ -1843,20 +1843,20 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		    && !devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay enable bit */
 			ni_writew(dev, devpriv->ai_calib_source |
-				       Calibration_Channel_6143_RelayOn,
-				  Calibration_Channel_6143);
+				       NI6143_CALIB_CHAN_RELAY_ON,
+				  NI6143_CALIB_CHAN_REG);
 			ni_writew(dev, devpriv->ai_calib_source,
-				  Calibration_Channel_6143);
+				  NI6143_CALIB_CHAN_REG);
 			devpriv->ai_calib_source_enabled = 1;
 			msleep_interruptible(100);	/*  Allow relays to change */
 		} else if (!(list[0] & CR_ALT_SOURCE)
 			   && devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay disable bit */
 			ni_writew(dev, devpriv->ai_calib_source |
-				       Calibration_Channel_6143_RelayOff,
-				  Calibration_Channel_6143);
+				       NI6143_CALIB_CHAN_RELAY_OFF,
+				  NI6143_CALIB_CHAN_REG);
 			ni_writew(dev, devpriv->ai_calib_source,
-				  Calibration_Channel_6143);
+				  NI6143_CALIB_CHAN_REG);
 			devpriv->ai_calib_source_enabled = 0;
 			msleep_interruptible(100);	/*  Allow relays to change */
 		}
@@ -1982,11 +1982,13 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			/* The 6143 has 32-bit FIFOs. You need to strobe a bit to move a single 16bit stranded sample into the FIFO */
 			dl = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
-				if (ni_readl(dev, AIFIFO_Status_6143) & 0x01) {
+				if (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) &
+				    0x01) {
 					/* Get stranded sample into FIFO */
 					ni_writel(dev, 0x01,
-						  AIFIFO_Control_6143);
-					dl = ni_readl(dev, AIFIFO_Data_6143);
+						  NI6143_AI_FIFO_CTRL_REG);
+					dl = ni_readl(dev,
+						      NI6143_AI_FIFO_DATA_REG);
 					break;
 				}
 			}
@@ -2541,7 +2543,7 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 			calib_source = data[1] & 0xf;
 
 			devpriv->ai_calib_source = calib_source;
-			ni_writew(dev, calib_source, Calibration_Channel_6143);
+			ni_writew(dev, calib_source, NI6143_CALIB_CHAN_REG);
 		} else {
 			unsigned int calib_source;
 			unsigned int calib_source_adjust;
@@ -4055,9 +4057,9 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 			data[4] = down_count * devpriv->clock_ns;
 			return -EAGAIN;
 		}
-		ni_writel(dev, up_count, Calibration_HighTime_6143);
+		ni_writel(dev, up_count, NI6143_CALIB_HI_TIME_REG);
 		devpriv->pwm_up_count = up_count;
-		ni_writel(dev, down_count, Calibration_LowTime_6143);
+		ni_writel(dev, down_count, NI6143_CALIB_LO_TIME_REG);
 		devpriv->pwm_down_count = down_count;
 		return 5;
 	case INSN_CONFIG_GET_PWM_OUTPUT:

commit 0418da51378e83cde58043cf7a272760a5214a2d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 15:00:07 2015 -0700

    staging: comedi: ni_stc.h: rename the NI-611x register defines
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e2081ea314bf..e50eb9ac34bc 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -879,8 +879,8 @@ static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data,
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->window_lock, flags);
-	ni_writew(dev, addr, AO_Window_Address_611x);
-	ni_writew(dev, data, AO_Window_Data_611x);
+	ni_writew(dev, addr, NI611X_AO_WINDOW_ADDR_REG);
+	ni_writew(dev, data, NI611X_AO_WINDOW_DATA_REG);
 	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
@@ -891,8 +891,8 @@ static inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data,
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->window_lock, flags);
-	ni_writew(dev, addr, AO_Window_Address_611x);
-	ni_writel(dev, data, AO_Window_Data_611x);
+	ni_writew(dev, addr, NI611X_AO_WINDOW_ADDR_REG);
+	ni_writel(dev, data, NI611X_AO_WINDOW_DATA_REG);
 	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
@@ -903,8 +903,8 @@ static inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)
 	unsigned short data;
 
 	spin_lock_irqsave(&devpriv->window_lock, flags);
-	ni_writew(dev, addr, AO_Window_Address_611x);
-	data = ni_readw(dev, AO_Window_Data_611x);
+	ni_writew(dev, addr, NI611X_AO_WINDOW_ADDR_REG);
+	data = ni_readw(dev, NI611X_AO_WINDOW_DATA_REG);
 	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 	return data;
 }
@@ -1035,7 +1035,7 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 				i++;
 				packed_data |= (d << 16) & 0xffff0000;
 			}
-			ni_writel(dev, packed_data, DAC_FIFO_Data_611x);
+			ni_writel(dev, packed_data, NI611X_AO_FIFO_DATA_REG);
 		} else {
 			ni_writew(dev, d, NI_E_AO_FIFO_DATA_REG);
 		}
@@ -1118,7 +1118,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 
 	if (devpriv->is_611x) {
 		for (i = 0; i < n / 2; i++) {
-			dl = ni_readl(dev, ADC_FIFO_Data_611x);
+			dl = ni_readl(dev, NI611X_AI_FIFO_DATA_REG);
 			/* This may get the hi/lo data in the wrong order */
 			data = (dl >> 16) & 0xffff;
 			comedi_buf_write_samples(s, &data, 1);
@@ -1127,7 +1127,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 		}
 		/* Check if there's a single sample stuck in the FIFO */
 		if (n % 2) {
-			dl = ni_readl(dev, ADC_FIFO_Data_611x);
+			dl = ni_readl(dev, NI611X_AI_FIFO_DATA_REG);
 			data = dl & 0xffff;
 			comedi_buf_write_samples(s, &data, 1);
 		}
@@ -1192,7 +1192,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 	if (devpriv->is_611x) {
 		while ((ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
 			NISTC_AI_STATUS1_FIFO_E) == 0) {
-			dl = ni_readl(dev, ADC_FIFO_Data_611x);
+			dl = ni_readl(dev, NI611X_AI_FIFO_DATA_REG);
 
 			/* This may get the hi/lo data in the wrong order */
 			data = dl >> 16;
@@ -1254,7 +1254,7 @@ static void get_last_sample_611x(struct comedi_device *dev)
 
 	/* Check if there's a single sample stuck in the FIFO */
 	if (ni_readb(dev, NI_E_STATUS_REG) & 0x80) {
-		dl = ni_readl(dev, ADC_FIFO_Data_611x);
+		dl = ni_readl(dev, NI611X_AI_FIFO_DATA_REG);
 		data = dl & 0xffff;
 		comedi_buf_write_samples(s, &data, 1);
 	}
@@ -1882,7 +1882,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		if ((list[i] & CR_ALT_SOURCE)) {
 			if (devpriv->is_611x)
 				ni_writew(dev, CR_CHAN(list[i]) & 0x0003,
-					  Calibration_Channel_Select_611x);
+					  NI611X_CALIB_CHAN_SEL_REG);
 		} else {
 			if (devpriv->is_611x)
 				aref = AREF_DIFF;
@@ -1953,14 +1953,16 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			d = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
 				if (ni_readb(dev, NI_E_STATUS_REG) & 0x80) {
-					d = ni_readl(dev, ADC_FIFO_Data_611x);
+					d = ni_readl(dev,
+						     NI611X_AI_FIFO_DATA_REG);
 					d >>= 16;
 					d &= 0xffff;
 					break;
 				}
 				if (!(ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
 				      NISTC_AI_STATUS1_FIFO_E)) {
-					d = ni_readl(dev, ADC_FIFO_Data_611x);
+					d = ni_readl(dev,
+						     NI611X_AI_FIFO_DATA_REG);
 					d &= 0xffff;
 					break;
 				}
@@ -2552,7 +2554,7 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 			devpriv->ai_calib_source = calib_source;
 			if (devpriv->is_611x) {
 				ni_writeb(dev, calib_source_adjust,
-					  Cal_Gain_Select_611x);
+					  NI611X_CAL_GAIN_SEL_REG);
 			}
 		}
 		return 2;
@@ -5384,7 +5386,7 @@ static int ni_E_init(struct comedi_device *dev,
 	ni_writeb(dev, devpriv->g0_g1_select_reg, NI_E_DMA_G0_G1_SEL_REG);
 
 	if (devpriv->is_6xxx) {
-		ni_writeb(dev, 0, Magic_611x);
+		ni_writeb(dev, 0, NI611X_MAGIC_REG);
 	} else if (devpriv->is_m_series) {
 		int channel;
 

commit f78476b4d3939d9aa7299889f9a5066b96b2195f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 15:00:05 2015 -0700

    staging: comedi: ni_mio_common: move ni_stc_dma_channel_select_bitfield()
    
    Move this inline helper function from ni_stc.h. It does not need to be
    exposed outside of this file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index cfb5f34b4937..e2081ea314bf 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -567,6 +567,17 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 
 #ifdef PCIDMA
 /* DMA channel setup */
+static inline unsigned ni_stc_dma_channel_select_bitfield(unsigned channel)
+{
+	if (channel < 4)
+		return 1 << channel;
+	if (channel == 4)
+		return 0x3;
+	if (channel == 5)
+		return 0x5;
+	BUG();
+	return 0;
+}
 
 /* negative channel means no channel */
 static inline void ni_set_ai_dma_channel(struct comedi_device *dev, int channel)

commit 7d6f3aaead3a76e7e12aa2bbfe18d8ed423d1d19
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 15:00:04 2015 -0700

    staging: comedi: ni_stc.h: tidy up G0_G1_Select register and bits
    
    Rename the CamelCase. Convert the inline helper functions into macros.
    
    Tidy up the driver code to use the new macros. For consistency, make
    the ni_set_gpct_dma_channel() helper follow the same style as the
    ni_set_ai_dma_channel() and ni_set_ao_dma_channel() helpers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7dfa38268bdc..cfb5f34b4937 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -551,7 +551,7 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 		devpriv->ai_ao_select_reg |= bit_values & bit_mask;
 		ni_writeb(dev, devpriv->ai_ao_select_reg, reg);
 		break;
-	case G0_G1_Select:
+	case NI_E_DMA_G0_G1_SEL_REG:
 		devpriv->g0_g1_select_reg &= ~bit_mask;
 		devpriv->g0_g1_select_reg |= bit_values & bit_mask;
 		ni_writeb(dev, devpriv->g0_g1_select_reg, reg);
@@ -592,19 +592,19 @@ static inline void ni_set_ao_dma_channel(struct comedi_device *dev, int channel)
 			NI_E_DMA_AO_SEL_MASK, NI_E_DMA_AO_SEL(bits));
 }
 
-/* negative mite_channel means no channel */
+/* negative channel means no channel */
 static inline void ni_set_gpct_dma_channel(struct comedi_device *dev,
 					   unsigned gpct_index,
-					   int mite_channel)
+					   int channel)
 {
-	unsigned bitfield;
+	unsigned bits = 0;
 
-	if (mite_channel >= 0)
-		bitfield = GPCT_DMA_Select_Bits(gpct_index, mite_channel);
-	else
-		bitfield = 0;
-	ni_set_bitfield(dev, G0_G1_Select, GPCT_DMA_Select_Mask(gpct_index),
-			bitfield);
+	if (channel >= 0)
+		bits = ni_stc_dma_channel_select_bitfield(channel);
+
+	ni_set_bitfield(dev, NI_E_DMA_G0_G1_SEL_REG,
+			NI_E_DMA_G0_G1_SEL_MASK(gpct_index),
+			NI_E_DMA_G0_G1_SEL(gpct_index, bits));
 }
 
 /* negative mite_channel means no channel */
@@ -5370,7 +5370,7 @@ static int ni_E_init(struct comedi_device *dev,
 
 	/* DMA setup */
 	ni_writeb(dev, devpriv->ai_ao_select_reg, NI_E_DMA_AI_AO_SEL_REG);
-	ni_writeb(dev, devpriv->g0_g1_select_reg, G0_G1_Select);
+	ni_writeb(dev, devpriv->g0_g1_select_reg, NI_E_DMA_G0_G1_SEL_REG);
 
 	if (devpriv->is_6xxx) {
 		ni_writeb(dev, 0, Magic_611x);

commit a4b7ef9d8eae56f0355d0ee2a762639901d7bef4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 15:00:03 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_AO_Select register and bits
    
    Rename the CamelCase and convert the enum into macros.
    
    Tidy up the driver code to use the new macros.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2e1fde3d843d..7dfa38268bdc 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -546,7 +546,7 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 		devpriv->io_bidirection_pin_reg |= bit_values & bit_mask;
 		ni_stc_writew(dev, devpriv->io_bidirection_pin_reg, reg);
 		break;
-	case AI_AO_Select:
+	case NI_E_DMA_AI_AO_SEL_REG:
 		devpriv->ai_ao_select_reg &= ~bit_mask;
 		devpriv->ai_ao_select_reg |= bit_values & bit_mask;
 		ni_writeb(dev, devpriv->ai_ao_select_reg, reg);
@@ -571,29 +571,25 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 /* negative channel means no channel */
 static inline void ni_set_ai_dma_channel(struct comedi_device *dev, int channel)
 {
-	unsigned bitfield;
+	unsigned bits = 0;
 
 	if (channel >= 0)
-		bitfield =
-		    (ni_stc_dma_channel_select_bitfield(channel) <<
-		     AI_DMA_Select_Shift) & AI_DMA_Select_Mask;
-	else
-		bitfield = 0;
-	ni_set_bitfield(dev, AI_AO_Select, AI_DMA_Select_Mask, bitfield);
+		bits = ni_stc_dma_channel_select_bitfield(channel);
+
+	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,
+			NI_E_DMA_AI_SEL_MASK, NI_E_DMA_AI_SEL(bits));
 }
 
 /* negative channel means no channel */
 static inline void ni_set_ao_dma_channel(struct comedi_device *dev, int channel)
 {
-	unsigned bitfield;
+	unsigned bits = 0;
 
 	if (channel >= 0)
-		bitfield =
-		    (ni_stc_dma_channel_select_bitfield(channel) <<
-		     AO_DMA_Select_Shift) & AO_DMA_Select_Mask;
-	else
-		bitfield = 0;
-	ni_set_bitfield(dev, AI_AO_Select, AO_DMA_Select_Mask, bitfield);
+		bits = ni_stc_dma_channel_select_bitfield(channel);
+
+	ni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,
+			NI_E_DMA_AO_SEL_MASK, NI_E_DMA_AO_SEL(bits));
 }
 
 /* negative mite_channel means no channel */
@@ -5373,7 +5369,7 @@ static int ni_E_init(struct comedi_device *dev,
 	}
 
 	/* DMA setup */
-	ni_writeb(dev, devpriv->ai_ao_select_reg, AI_AO_Select);
+	ni_writeb(dev, devpriv->ai_ao_select_reg, NI_E_DMA_AI_AO_SEL_REG);
 	ni_writeb(dev, devpriv->g0_g1_select_reg, G0_G1_Select);
 
 	if (devpriv->is_6xxx) {

commit 3446b08e83eb152fe97c791d16cbc68523a62bce
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 15:00:02 2015 -0700

    staging: comedi: ni_mio_common: remove BUG_ON(gpct_index ...) checks
    
    The gpct_index will always be 0 or 1. Remove the unnecessary BUG_ON()
    checks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 4a94bc3986ef..2e1fde3d843d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -686,7 +686,6 @@ static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 	unsigned long flags;
 	struct mite_channel *mite_chan;
 
-	BUG_ON(gpct_index >= NUM_GPCT);
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->counter_dev->counters[gpct_index].mite_chan);
 	mite_chan =
@@ -770,7 +769,6 @@ static void ni_release_gpct_mite_channel(struct comedi_device *dev,
 	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
-	BUG_ON(gpct_index >= NUM_GPCT);
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->counter_dev->counters[gpct_index].mite_chan) {
 		struct mite_channel *mite_chan =

commit 25e941affe11e258a213bb12e765dfaabd327c57
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 15:00:01 2015 -0700

    staging: comedi: ni_stc.h: tidy up DAC[01]_Direct_Data registers
    
    Rename the CamelCase and convert the defines into a macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b9e35ead643c..4a94bc3986ef 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2733,7 +2733,7 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 	} else if (devpriv->is_m_series) {
 		reg = NI_M_DAC_DIRECT_DATA_REG(chan);
 	} else {
-		reg = (chan) ? DAC1_Direct_Data : DAC0_Direct_Data;
+		reg = NI_E_DAC_DIRECT_DATA_REG(chan);
 	}
 
 	ni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);

commit 9e0ad6f4d1fe3ff97ca66bde6484c320ce9d80da
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 15:00:00 2015 -0700

    staging: comedi: ni_stc.h: tidy up DAC_FIFO_Data register
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 39e680e12882..b9e35ead643c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1032,7 +1032,7 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 			}
 			ni_writel(dev, packed_data, DAC_FIFO_Data_611x);
 		} else {
-			ni_writew(dev, d, DAC_FIFO_Data);
+			ni_writew(dev, d, NI_E_AO_FIFO_DATA_REG);
 		}
 	}
 }

commit b497b8da801088f380a98851a5c50ffcd7b40c86
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:59 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_Configuration register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 64c44a1a1065..39e680e12882 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2675,27 +2675,27 @@ static int ni_old_ao_config_chanlist(struct comedi_device *dev,
 	for (i = 0; i < n_chans; i++) {
 		chan = CR_CHAN(chanspec[i]);
 		range = CR_RANGE(chanspec[i]);
-		conf = AO_Channel(chan);
+		conf = NI_E_AO_DACSEL(chan);
 
 		if (comedi_range_is_bipolar(s, range)) {
-			conf |= AO_Bipolar;
+			conf |= NI_E_AO_CFG_BIP;
 			invert = (s->maxdata + 1) >> 1;
 		} else {
 			invert = 0;
 		}
 		if (comedi_range_is_external(s, range))
-			conf |= AO_Ext_Ref;
+			conf |= NI_E_AO_EXT_REF;
 
 		/* not all boards can deglitch, but this shouldn't hurt */
 		if (chanspec[i] & CR_DEGLITCH)
-			conf |= AO_Deglitch;
+			conf |= NI_E_AO_DEGLITCH;
 
 		/* analog reference */
 		/* AREF_OTHER connects AO ground to AI ground, i think */
-		conf |= (CR_AREF(chanspec[i]) ==
-			 AREF_OTHER) ? AO_Ground_Ref : 0;
+		if (CR_AREF(chanspec[i]) == AREF_OTHER)
+			conf |= NI_E_AO_GROUND_REF;
 
-		ni_writew(dev, conf, AO_Configuration);
+		ni_writew(dev, conf, NI_E_AO_CFG_REG);
 		devpriv->ao_conf[chan] = conf;
 	}
 	return invert;
@@ -3698,7 +3698,7 @@ static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)
 	int i;
 
 	for (i = 0; i < s->n_chan; i++) {
-		ni_ao_win_outw(dev, AO_Channel(i) | 0x0,
+		ni_ao_win_outw(dev, NI_E_AO_DACSEL(i) | 0x0,
 			       AO_Configuration_2_67xx);
 	}
 	ni_ao_win_outw(dev, 0x0, AO_Later_Single_Point_Updates);

commit d504a6ee3db248e2ec3dc5e4304a381d5ba9bb6f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:58 2015 -0700

    staging: comedi: ni_stc.h: tidy up Configuration_Memory_High register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0fba36dabd5b..64c44a1a1065 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1885,21 +1885,21 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 				aref = AREF_OTHER;
 			switch (aref) {
 			case AREF_DIFF:
-				hi |= AI_DIFFERENTIAL;
+				hi |= NI_E_AI_CFG_HI_TYPE_DIFF;
 				break;
 			case AREF_COMMON:
-				hi |= AI_COMMON;
+				hi |= NI_E_AI_CFG_HI_TYPE_COMMON;
 				break;
 			case AREF_GROUND:
-				hi |= AI_GROUND;
+				hi |= NI_E_AI_CFG_HI_TYPE_GROUND;
 				break;
 			case AREF_OTHER:
 				break;
 			}
 		}
-		hi |= AI_CONFIG_CHANNEL(chan);
+		hi |= NI_E_AI_CFG_HI_CHAN(chan);
 
-		ni_writew(dev, hi, Configuration_Memory_High);
+		ni_writew(dev, hi, NI_E_AI_CFG_HI_REG);
 
 		if (!devpriv->is_6143) {
 			lo = NI_E_AI_CFG_LO_GAIN(range);

commit 76efac7f525f2e9fffe9e751c29cd93aae96c710
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:57 2015 -0700

    staging: comedi: ni_stc.h: tidy up Configuration_Memory_Low register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 74817f8a2728..0fba36dabd5b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1902,13 +1902,14 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		ni_writew(dev, hi, Configuration_Memory_High);
 
 		if (!devpriv->is_6143) {
-			lo = range;
+			lo = NI_E_AI_CFG_LO_GAIN(range);
+
 			if (i == n_chan - 1)
-				lo |= AI_LAST_CHANNEL;
+				lo |= NI_E_AI_CFG_LO_LAST_CHAN;
 			if (dither)
-				lo |= AI_DITHER;
+				lo |= NI_E_AI_CFG_LO_DITHER;
 
-			ni_writew(dev, lo, Configuration_Memory_Low);
+			ni_writew(dev, lo, NI_E_AI_CFG_LO_REG);
 		}
 	}
 

commit 363f570ef0e4a5361e97a1c0632e17c5d4148ec8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:56 2015 -0700

    staging: comedi: ni_stc.h: tidy up ADC_FIFO_Data_Register
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 202957c0c3a7..74817f8a2728 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1154,7 +1154,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 		}
 		for (i = 0; i < n; i++) {
 			devpriv->ai_fifo_buffer[i] =
-			    ni_readw(dev, ADC_FIFO_Data_Register);
+			    ni_readw(dev, NI_E_AI_FIFO_DATA_REG);
 		}
 		comedi_buf_write_samples(s, devpriv->ai_fifo_buffer, n);
 	}
@@ -1230,7 +1230,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 				if (fifo_empty)
 					break;
 				devpriv->ai_fifo_buffer[i] =
-				    ni_readw(dev, ADC_FIFO_Data_Register);
+				    ni_readw(dev, NI_E_AI_FIFO_DATA_REG);
 			}
 			comedi_buf_write_samples(s, devpriv->ai_fifo_buffer, i);
 		}
@@ -2006,7 +2006,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				dl &= mask;
 				data[n] = dl;
 			} else {
-				d = ni_readw(dev, ADC_FIFO_Data_Register);
+				d = ni_readw(dev, NI_E_AI_FIFO_DATA_REG);
 				d += signbits;	/* subtle: needs to be short addition */
 				data[n] = d;
 			}

commit 61260f58496af82593f48f17071da950af500e60
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:55 2015 -0700

    staging: comedi: ni_stc.h: tidy up 8255 register defines
    
    Only the 'Port_A' define is used. Rename the CamelCase and remove the
    unused defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 06c491d4dac3..202957c0c3a7 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5204,7 +5204,8 @@ static int ni_E_init(struct comedi_device *dev,
 	/* 8255 device */
 	s = &dev->subdevices[NI_8255_DIO_SUBDEV];
 	if (board->has_8255) {
-		ret = subdev_8255_init(dev, s, ni_8255_callback, Port_A);
+		ret = subdev_8255_init(dev, s, ni_8255_callback,
+				       NI_E_8255_BASE);
 		if (ret)
 			return ret;
 	} else {

commit 68885d9e00c81c685ebfa3cbb850d065e0eaecf9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:54 2015 -0700

    staging: comedi: ni_stc.h: tidy up Misc_Command register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2f7d64dc9b43..06c491d4dac3 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1620,7 +1620,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_clear_ai_fifo(dev);
 
 	if (!devpriv->is_6143)
-		ni_writeb(dev, 0, Misc_Command);
+		ni_writeb(dev, NI_E_MISC_CMD_EXT_ATRIG, NI_E_MISC_CMD_REG);
 
 	ni_stc_writew(dev, NISTC_AI_CMD1_DISARM, NISTC_AI_CMD1_REG);
 	ni_stc_writew(dev, NISTC_AI_MODE1_START_STOP |

commit 2ed183fff4ce1de272fb1f4e1c1a3fd49a8a969a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:53 2015 -0700

    staging: comedi: ni_stc.h: tidy up Serial_Command register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b4a8a4c835e2..2f7d64dc9b43 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4129,6 +4129,7 @@ static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 	unsigned int loadbit = 0, bits = 0, bit, bitstring = 0;
+	unsigned int cmd;
 	int i;
 	int type;
 
@@ -4142,7 +4143,7 @@ static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 			break;
 		if (addr < caldacs[type].n_chans) {
 			bits = caldacs[type].packbits(addr, val, &bitstring);
-			loadbit = SerDacLd(i);
+			loadbit = NI_E_SERIAL_CMD_DAC_LD(i);
 			break;
 		}
 		addr -= caldacs[type].n_chans;
@@ -4153,15 +4154,15 @@ static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 		return;
 
 	for (bit = 1 << (bits - 1); bit; bit >>= 1) {
-		ni_writeb(dev, ((bit & bitstring) ? 0x02 : 0), Serial_Command);
+		cmd = (bit & bitstring) ? NI_E_SERIAL_CMD_SDATA : 0;
+		ni_writeb(dev, cmd, NI_E_SERIAL_CMD_REG);
 		udelay(1);
-		ni_writeb(dev, 1 | ((bit & bitstring) ? 0x02 : 0),
-			  Serial_Command);
+		ni_writeb(dev, NI_E_SERIAL_CMD_SCLK | cmd, NI_E_SERIAL_CMD_REG);
 		udelay(1);
 	}
-	ni_writeb(dev, loadbit, Serial_Command);
+	ni_writeb(dev, loadbit, NI_E_SERIAL_CMD_REG);
 	udelay(1);
-	ni_writeb(dev, 0, Serial_Command);
+	ni_writeb(dev, 0, NI_E_SERIAL_CMD_REG);
 }
 
 static int ni_calib_insn_write(struct comedi_device *dev,
@@ -4243,25 +4244,30 @@ static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int ni_read_eeprom(struct comedi_device *dev, int addr)
 {
+	unsigned int cmd = NI_E_SERIAL_CMD_EEPROM_CS;
 	int bit;
 	int bitstring;
 
 	bitstring = 0x0300 | ((addr & 0x100) << 3) | (addr & 0xff);
-	ni_writeb(dev, 0x04, Serial_Command);
+	ni_writeb(dev, cmd, NI_E_SERIAL_CMD_REG);
 	for (bit = 0x8000; bit; bit >>= 1) {
-		ni_writeb(dev, 0x04 | ((bit & bitstring) ? 0x02 : 0),
-			  Serial_Command);
-		ni_writeb(dev, 0x05 | ((bit & bitstring) ? 0x02 : 0),
-			  Serial_Command);
+		if (bit & bitstring)
+			cmd |= NI_E_SERIAL_CMD_SDATA;
+		else
+			cmd &= ~NI_E_SERIAL_CMD_SDATA;
+
+		ni_writeb(dev, cmd, NI_E_SERIAL_CMD_REG);
+		ni_writeb(dev, NI_E_SERIAL_CMD_SCLK | cmd, NI_E_SERIAL_CMD_REG);
 	}
+	cmd = NI_E_SERIAL_CMD_EEPROM_CS;
 	bitstring = 0;
 	for (bit = 0x80; bit; bit >>= 1) {
-		ni_writeb(dev, 0x04, Serial_Command);
-		ni_writeb(dev, 0x05, Serial_Command);
+		ni_writeb(dev, cmd, NI_E_SERIAL_CMD_REG);
+		ni_writeb(dev, NI_E_SERIAL_CMD_SCLK | cmd, NI_E_SERIAL_CMD_REG);
 		if (ni_readb(dev, NI_E_STATUS_REG) & NI_E_STATUS_PROMOUT)
 			bitstring |= bit;
 	}
-	ni_writeb(dev, 0x00, Serial_Command);
+	ni_writeb(dev, 0, NI_E_SERIAL_CMD_REG);
 
 	return bitstring;
 }

commit 906170b882b609144d982a732ea9ad9faf1697fc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:52 2015 -0700

    staging: comedi: ni_stc.h: tidy up XXX_Status register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 518c03303c74..b4a8a4c835e2 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1248,7 +1248,7 @@ static void get_last_sample_611x(struct comedi_device *dev)
 		return;
 
 	/* Check if there's a single sample stuck in the FIFO */
-	if (ni_readb(dev, XXX_Status) & 0x80) {
+	if (ni_readb(dev, NI_E_STATUS_REG) & 0x80) {
 		dl = ni_readl(dev, ADC_FIFO_Data_611x);
 		data = dl & 0xffff;
 		comedi_buf_write_samples(s, &data, 1);
@@ -1946,7 +1946,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			/* The 611x has screwy 32-bit FIFOs. */
 			d = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
-				if (ni_readb(dev, XXX_Status) & 0x80) {
+				if (ni_readb(dev, NI_E_STATUS_REG) & 0x80) {
 					d = ni_readl(dev, ADC_FIFO_Data_611x);
 					d >>= 16;
 					d &= 0xffff;
@@ -4258,7 +4258,8 @@ static int ni_read_eeprom(struct comedi_device *dev, int addr)
 	for (bit = 0x80; bit; bit >>= 1) {
 		ni_writeb(dev, 0x04, Serial_Command);
 		ni_writeb(dev, 0x05, Serial_Command);
-		bitstring |= ((ni_readb(dev, XXX_Status) & PROMOUT) ? bit : 0);
+		if (ni_readb(dev, NI_E_STATUS_REG) & NI_E_STATUS_PROMOUT)
+			bitstring |= bit;
 	}
 	ni_writeb(dev, 0x00, Serial_Command);
 

commit 4f809ff5e87fe7f2bb6bb6150d1b3bef4621c2d7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:51 2015 -0700

    staging: comedi: ni_stc.h: tidy up Window_{Address,Data} defines
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8dda682fca10..518c03303c74 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -469,8 +469,8 @@ static void ni_stc_writew(struct comedi_device *dev, uint16_t data, int reg)
 		if (!devpriv->mite && reg < 8) {
 			ni_writew(dev, data, reg * 2);
 		} else {
-			ni_writew(dev, reg, Window_Address);
-			ni_writew(dev, data, Window_Data);
+			ni_writew(dev, reg, NI_E_STC_WINDOW_ADDR_REG);
+			ni_writew(dev, data, NI_E_STC_WINDOW_DATA_REG);
 		}
 		spin_unlock_irqrestore(&devpriv->window_lock, flags);
 	}
@@ -501,8 +501,8 @@ static uint16_t ni_stc_readw(struct comedi_device *dev, int reg)
 		if (!devpriv->mite && reg < 8) {
 			val = ni_readw(dev, reg * 2);
 		} else {
-			ni_writew(dev, reg, Window_Address);
-			val = ni_readw(dev, Window_Data);
+			ni_writew(dev, reg, NI_E_STC_WINDOW_ADDR_REG);
+			val = ni_readw(dev, NI_E_STC_WINDOW_DATA_REG);
 		}
 		spin_unlock_irqrestore(&devpriv->window_lock, flags);
 	}

commit 549835c76a3ab053c4450d23d9c11ae43290196d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:49 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_*_Save_Registers
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 17646a2f55b2..8dda682fca10 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -426,8 +426,8 @@ static const struct mio_regmap m_series_stc_read_regmap[] = {
 	[NISTC_STATUS1_REG]		= { 0x136, 2 },
 	[NISTC_DIO_SERIAL_IN_REG]	= { 0x009, 1 },
 	[NISTC_STATUS2_REG]		= { 0x13a, 2 },
-	[AI_SI_Save_Registers]		= { 0x180, 4 },
-	[AI_SC_Save_Registers]		= { 0x184, 4 },
+	[NISTC_AI_SI_SAVE_REG]		= { 0x180, 4 },
+	[NISTC_AI_SC_SAVE_REG]		= { 0x184, 4 },
 };
 
 static unsigned int m_series_stc_read(struct comedi_device *dev,

commit bab382efa82265d8a13ba111028158adb8f48510
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:48 2015 -0700

    staging: comedi: ni_stc.h: tidy up Joint_Status_2_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index cb4aed174648..17646a2f55b2 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -425,7 +425,7 @@ static const struct mio_regmap m_series_stc_read_regmap[] = {
 	[NISTC_AO_UC_SAVE_REG]		= { 0x128, 4 },
 	[NISTC_STATUS1_REG]		= { 0x136, 2 },
 	[NISTC_DIO_SERIAL_IN_REG]	= { 0x009, 1 },
-	[Joint_Status_2_Register]	= { 0x13a, 2 },
+	[NISTC_STATUS2_REG]		= { 0x13a, 2 },
 	[AI_SI_Save_Registers]		= { 0x180, 4 },
 	[AI_SC_Save_Registers]		= { 0x184, 4 },
 };
@@ -2849,8 +2849,8 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 	/* wait for DACs to be loaded */
 	for (i = 0; i < timeout; i++) {
 		udelay(1);
-		if ((ni_stc_readw(dev, Joint_Status_2_Register) &
-		     AO_TMRDACWRs_In_Progress_St) == 0)
+		if ((ni_stc_readw(dev, NISTC_STATUS2_REG) &
+		     NISTC_STATUS2_AO_TMRDACWRS_IN_PROGRESS) == 0)
 			break;
 	}
 	if (i == timeout) {
@@ -3727,7 +3727,7 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G01_STATUS]	= { NISTC_G01_STATUS_REG, 2 },
 	[NITIO_G01_RESET]	= { NISTC_RESET_REG, 2 },
 	[NITIO_G01_STATUS1]	= { NISTC_STATUS1_REG, 2 },
-	[NITIO_G01_STATUS2]	= { Joint_Status_2_Register, 2 },
+	[NITIO_G01_STATUS2]	= { NISTC_STATUS2_REG, 2 },
 	[NITIO_G0_DMA_CFG]	= { 0x1b8, 2 },	/* M-Series only */
 	[NITIO_G1_DMA_CFG]	= { 0x1ba, 2 },	/* M-Series only */
 	[NITIO_G0_DMA_STATUS]	= { 0x1b8, 2 },	/* M-Series only */

commit 8fbb015484a5d8038ced1d0bb81041e6b7437ccc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:47 2015 -0700

    staging: comedi: ni_stc.h: tidy up DIO_Serial_Input_Register
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 9051477f7ac6..cb4aed174648 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -424,7 +424,7 @@ static const struct mio_regmap m_series_stc_read_regmap[] = {
 	[NISTC_AO_BC_SAVE_REG]		= { 0x124, 4 },
 	[NISTC_AO_UC_SAVE_REG]		= { 0x128, 4 },
 	[NISTC_STATUS1_REG]		= { 0x136, 2 },
-	[DIO_Serial_Input_Register]	= { 0x009, 1 },
+	[NISTC_DIO_SERIAL_IN_REG]	= { 0x009, 1 },
 	[Joint_Status_2_Register]	= { 0x13a, 2 },
 	[AI_SI_Save_Registers]		= { 0x180, 4 },
 	[AI_SC_Save_Registers]		= { 0x184, 4 },
@@ -3552,7 +3552,7 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 	udelay((devpriv->serial_interval_ns + 999) / 1000);
 
 	if (data_in)
-		*data_in = ni_stc_readw(dev, DIO_Serial_Input_Register);
+		*data_in = ni_stc_readw(dev, NISTC_DIO_SERIAL_IN_REG);
 
 Error:
 	ni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);

commit d3fed0813242a2fa6604e627326724d7cae9a068
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:46 2015 -0700

    staging: comedi: ni_stc.h: tidy up Joint_Status_1_Register
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b194d1558463..9051477f7ac6 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -423,7 +423,7 @@ static const struct mio_regmap m_series_stc_read_regmap[] = {
 	[NISTC_AO_UI_SAVE_REG]		= { 0x120, 4 },
 	[NISTC_AO_BC_SAVE_REG]		= { 0x124, 4 },
 	[NISTC_AO_UC_SAVE_REG]		= { 0x128, 4 },
-	[Joint_Status_1_Register]	= { 0x136, 2 },
+	[NISTC_STATUS1_REG]		= { 0x136, 2 },
 	[DIO_Serial_Input_Register]	= { 0x009, 1 },
 	[Joint_Status_2_Register]	= { 0x13a, 2 },
 	[AI_SI_Save_Registers]		= { 0x180, 4 },
@@ -3522,8 +3522,8 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 	devpriv->dio_output |= NISTC_DIO_OUT_SERIAL(data_out);
 	ni_stc_writew(dev, devpriv->dio_output, NISTC_DIO_OUT_REG);
 
-	status1 = ni_stc_readw(dev, Joint_Status_1_Register);
-	if (status1 & DIO_Serial_IO_In_Progress_St) {
+	status1 = ni_stc_readw(dev, NISTC_STATUS1_REG);
+	if (status1 & NISTC_STATUS1_SERIO_IN_PROG) {
 		err = -EBUSY;
 		goto Error;
 	}
@@ -3533,8 +3533,8 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 	devpriv->dio_control &= ~NISTC_DIO_CTRL_HW_SER_START;
 
 	/* Wait until STC says we're done, but don't loop infinitely. */
-	while ((status1 = ni_stc_readw(dev, Joint_Status_1_Register)) &
-	       DIO_Serial_IO_In_Progress_St) {
+	while ((status1 = ni_stc_readw(dev, NISTC_STATUS1_REG)) &
+	       NISTC_STATUS1_SERIO_IN_PROG) {
 		/* Delay one bit per loop */
 		udelay((devpriv->serial_interval_ns + 999) / 1000);
 		if (--count < 0) {
@@ -3545,8 +3545,10 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 		}
 	}
 
-	/* Delay for last bit. This delay is absolutely necessary, because
-	   DIO_Serial_IO_In_Progress_St goes high one bit too early. */
+	/*
+	 * Delay for last bit. This delay is absolutely necessary, because
+	 * NISTC_STATUS1_SERIO_IN_PROG goes high one bit too early.
+	 */
 	udelay((devpriv->serial_interval_ns + 999) / 1000);
 
 	if (data_in)
@@ -3724,7 +3726,7 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G1_GATE2]	= { 0x1b6, 2 },	/* M-Series only */
 	[NITIO_G01_STATUS]	= { NISTC_G01_STATUS_REG, 2 },
 	[NITIO_G01_RESET]	= { NISTC_RESET_REG, 2 },
-	[NITIO_G01_STATUS1]	= { Joint_Status_1_Register, 2 },
+	[NITIO_G01_STATUS1]	= { NISTC_STATUS1_REG, 2 },
 	[NITIO_G01_STATUS2]	= { Joint_Status_2_Register, 2 },
 	[NITIO_G0_DMA_CFG]	= { 0x1b8, 2 },	/* M-Series only */
 	[NITIO_G1_DMA_CFG]	= { 0x1ba, 2 },	/* M-Series only */

commit 2c090acdc981421765becba929d9581511bdbbd0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:45 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_*_Save_Registers
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 9cd796ce1832..b194d1558463 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -420,9 +420,9 @@ static const struct mio_regmap m_series_stc_read_regmap[] = {
 	[NISTC_G1_HW_SAVE_REG]		= { 0x114, 4 },
 	[NISTC_G0_SAVE_REG]		= { 0x118, 4 },
 	[NISTC_G1_SAVE_REG]		= { 0x11c, 4 },
-	[AO_UI_Save_Registers]		= { 0x120, 4 },
-	[AO_BC_Save_Registers]		= { 0x124, 4 },
-	[AO_UC_Save_Registers]		= { 0x128, 4 },
+	[NISTC_AO_UI_SAVE_REG]		= { 0x120, 4 },
+	[NISTC_AO_BC_SAVE_REG]		= { 0x124, 4 },
+	[NISTC_AO_UC_SAVE_REG]		= { 0x128, 4 },
 	[Joint_Status_1_Register]	= { 0x136, 2 },
 	[DIO_Serial_Input_Register]	= { 0x009, 1 },
 	[Joint_Status_2_Register]	= { 0x13a, 2 },

commit d9c4115fcdea6737b72b715736b59bdc5b560835
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:44 2015 -0700

    staging: comedi: ni_stc.h: tidy up G_Save_Register
    
    Rename the CamelCase and define the G0 and G1 registers to add clarity
    to the mio_regmap tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index f0f449c5dce5..9cd796ce1832 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -418,8 +418,8 @@ static const struct mio_regmap m_series_stc_read_regmap[] = {
 	[NISTC_DIO_IN_REG]		= { 0, 0 }, /* Unknown */
 	[NISTC_G0_HW_SAVE_REG]		= { 0x110, 4 },
 	[NISTC_G1_HW_SAVE_REG]		= { 0x114, 4 },
-	[G_Save_Register(0)]		= { 0x118, 4 },
-	[G_Save_Register(1)]		= { 0x11c, 4 },
+	[NISTC_G0_SAVE_REG]		= { 0x118, 4 },
+	[NISTC_G1_SAVE_REG]		= { 0x11c, 4 },
 	[AO_UI_Save_Registers]		= { 0x120, 4 },
 	[AO_BC_Save_Registers]		= { 0x124, 4 },
 	[AO_UC_Save_Registers]		= { 0x128, 4 },
@@ -3708,8 +3708,8 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G1_CMD]		= { NISTC_G1_CMD_REG, 2 },
 	[NITIO_G0_HW_SAVE]	= { NISTC_G0_HW_SAVE_REG, 4 },
 	[NITIO_G1_HW_SAVE]	= { NISTC_G1_HW_SAVE_REG, 4 },
-	[NITIO_G0_SW_SAVE]	= { G_Save_Register(0), 4 },
-	[NITIO_G1_SW_SAVE]	= { G_Save_Register(1), 4 },
+	[NITIO_G0_SW_SAVE]	= { NISTC_G0_SAVE_REG, 4 },
+	[NITIO_G1_SW_SAVE]	= { NISTC_G1_SAVE_REG, 4 },
 	[NITIO_G0_MODE]		= { NISTC_G0_MODE_REG, 2 },
 	[NITIO_G1_MODE]		= { NISTC_G1_MODE_REG, 2 },
 	[NITIO_G0_LOADA]	= { NISTC_G0_LOADA_REG, 4 },

commit 27650d99004d8fc962c56c9c2260af0cb5f2ff7d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:43 2015 -0700

    staging: comedi: ni_stc.h: tidy up G_HW_Save_Register
    
    Rename the CamelCase and define the G0 and G1 registers to add clarity
    to the mio_regmap tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ea30689818d5..f0f449c5dce5 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -416,8 +416,8 @@ static const struct mio_regmap m_series_stc_read_regmap[] = {
 	[NISTC_AI_STATUS2_REG]		= { 0, 0 }, /* Unknown */
 	[NISTC_AO_STATUS2_REG]		= { 0x10c, 2 },
 	[NISTC_DIO_IN_REG]		= { 0, 0 }, /* Unknown */
-	[G_HW_Save_Register(0)]		= { 0x110, 4 },
-	[G_HW_Save_Register(1)]		= { 0x114, 4 },
+	[NISTC_G0_HW_SAVE_REG]		= { 0x110, 4 },
+	[NISTC_G1_HW_SAVE_REG]		= { 0x114, 4 },
 	[G_Save_Register(0)]		= { 0x118, 4 },
 	[G_Save_Register(1)]		= { 0x11c, 4 },
 	[AO_UI_Save_Registers]		= { 0x120, 4 },
@@ -3706,8 +3706,8 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G1_AUTO_INC]	= { NISTC_G1_AUTOINC_REG, 2 },
 	[NITIO_G0_CMD]		= { NISTC_G0_CMD_REG, 2 },
 	[NITIO_G1_CMD]		= { NISTC_G1_CMD_REG, 2 },
-	[NITIO_G0_HW_SAVE]	= { G_HW_Save_Register(0), 4 },
-	[NITIO_G1_HW_SAVE]	= { G_HW_Save_Register(1), 4 },
+	[NITIO_G0_HW_SAVE]	= { NISTC_G0_HW_SAVE_REG, 4 },
+	[NITIO_G1_HW_SAVE]	= { NISTC_G1_HW_SAVE_REG, 4 },
 	[NITIO_G0_SW_SAVE]	= { G_Save_Register(0), 4 },
 	[NITIO_G1_SW_SAVE]	= { G_Save_Register(1), 4 },
 	[NITIO_G0_MODE]		= { NISTC_G0_MODE_REG, 2 },

commit 6f764a47f3311c6f283d050e6630683569e07f33
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:42 2015 -0700

    staging: comedi: ni_stc.h: tidy up DIO_Parallel_Input_Register
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 6b7013831ef7..ea30689818d5 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -415,7 +415,7 @@ static const struct mio_regmap m_series_stc_read_regmap[] = {
 	[NISTC_G01_STATUS_REG]		= { 0x108, 2 },
 	[NISTC_AI_STATUS2_REG]		= { 0, 0 }, /* Unknown */
 	[NISTC_AO_STATUS2_REG]		= { 0x10c, 2 },
-	[DIO_Parallel_Input_Register]	= { 0, 0 }, /* Unknown */
+	[NISTC_DIO_IN_REG]		= { 0, 0 }, /* Unknown */
 	[G_HW_Save_Register(0)]		= { 0x110, 4 },
 	[G_HW_Save_Register(1)]		= { 0x114, 4 },
 	[G_Save_Register(0)]		= { 0x118, 4 },
@@ -3264,7 +3264,7 @@ static int ni_dio_insn_bits(struct comedi_device *dev,
 		ni_stc_writew(dev, devpriv->dio_output, NISTC_DIO_OUT_REG);
 	}
 
-	data[1] = ni_stc_readw(dev, DIO_Parallel_Input_Register);
+	data[1] = ni_stc_readw(dev, NISTC_DIO_IN_REG);
 
 	return insn->n;
 }
@@ -3591,8 +3591,7 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
 		/* Input current bit */
-		if (ni_stc_readw(dev, DIO_Parallel_Input_Register) &
-		    NISTC_DIO_SDIN)
+		if (ni_stc_readw(dev, NISTC_DIO_IN_REG) & NISTC_DIO_SDIN)
 			input |= mask;
 	}
 

commit 63b2bb05e1ac74c309d61d6c0763c5fb75cc8791
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:41 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_Status_2_Register
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7b579376f3ba..6b7013831ef7 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -414,7 +414,7 @@ static const struct mio_regmap m_series_stc_read_regmap[] = {
 	[NISTC_AO_STATUS1_REG]		= { 0x106, 2 },
 	[NISTC_G01_STATUS_REG]		= { 0x108, 2 },
 	[NISTC_AI_STATUS2_REG]		= { 0, 0 }, /* Unknown */
-	[AO_Status_2_Register]		= { 0x10c, 2 },
+	[NISTC_AO_STATUS2_REG]		= { 0x10c, 2 },
 	[DIO_Parallel_Input_Register]	= { 0, 0 }, /* Unknown */
 	[G_HW_Save_Register(0)]		= { 0x110, 4 },
 	[G_HW_Save_Register(1)]		= { 0x114, 4 },
@@ -1475,7 +1475,7 @@ static void handle_b_interrupt(struct comedi_device *dev,
 	if (b_status & NISTC_AO_STATUS1_OVERRUN) {
 		dev_err(dev->class_dev,
 			"AO FIFO underrun status=0x%04x status2=0x%04x\n",
-			b_status, ni_stc_readw(dev, AO_Status_2_Register));
+			b_status, ni_stc_readw(dev, NISTC_AO_STATUS2_REG));
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 

commit 3ca18feff7c4259f3f809575fdb26bdc7828a9bd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:40 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_Status_2_Register
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a71a697f2b9b..7b579376f3ba 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -413,7 +413,7 @@ static const struct mio_regmap m_series_stc_read_regmap[] = {
 	[NISTC_AI_STATUS1_REG]		= { 0x104, 2 },
 	[NISTC_AO_STATUS1_REG]		= { 0x106, 2 },
 	[NISTC_G01_STATUS_REG]		= { 0x108, 2 },
-	[AI_Status_2_Register]		= { 0, 0 }, /* Unknown */
+	[NISTC_AI_STATUS2_REG]		= { 0, 0 }, /* Unknown */
 	[AO_Status_2_Register]		= { 0x10c, 2 },
 	[DIO_Parallel_Input_Register]	= { 0, 0 }, /* Unknown */
 	[G_HW_Save_Register(0)]		= { 0x110, 4 },

commit 7f0e1bac320430cb94316057e91c1f15cc6e19cf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:39 2015 -0700

    staging: comedi: ni_stc.h: tidy up G_Status_Register
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d7a723256e1a..a71a697f2b9b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -412,7 +412,7 @@ static void m_series_stc_write(struct comedi_device *dev,
 static const struct mio_regmap m_series_stc_read_regmap[] = {
 	[NISTC_AI_STATUS1_REG]		= { 0x104, 2 },
 	[NISTC_AO_STATUS1_REG]		= { 0x106, 2 },
-	[G_Status_Register]		= { 0x108, 2 },
+	[NISTC_G01_STATUS_REG]		= { 0x108, 2 },
 	[AI_Status_2_Register]		= { 0, 0 }, /* Unknown */
 	[AO_Status_2_Register]		= { 0x10c, 2 },
 	[DIO_Parallel_Input_Register]	= { 0, 0 }, /* Unknown */
@@ -3723,7 +3723,7 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G1_CNT_MODE]	= { 0x1b2, 2 },	/* M-Series only */
 	[NITIO_G0_GATE2]	= { 0x1b4, 2 },	/* M-Series only */
 	[NITIO_G1_GATE2]	= { 0x1b6, 2 },	/* M-Series only */
-	[NITIO_G01_STATUS]	= { G_Status_Register, 2 },
+	[NITIO_G01_STATUS]	= { NISTC_G01_STATUS_REG, 2 },
 	[NITIO_G01_RESET]	= { NISTC_RESET_REG, 2 },
 	[NITIO_G01_STATUS1]	= { Joint_Status_1_Register, 2 },
 	[NITIO_G01_STATUS2]	= { Joint_Status_2_Register, 2 },

commit d123ee3ce0803e47a477f8efe680d549967e10f0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:38 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_Status_1_Register and bits
    
    Rename the CamelCase. Use the BIT() marco to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 50a14d287613..d7a723256e1a 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -411,7 +411,7 @@ static void m_series_stc_write(struct comedi_device *dev,
 
 static const struct mio_regmap m_series_stc_read_regmap[] = {
 	[NISTC_AI_STATUS1_REG]		= { 0x104, 2 },
-	[AO_Status_1_Register]		= { 0x106, 2 },
+	[NISTC_AO_STATUS1_REG]		= { 0x106, 2 },
 	[G_Status_Register]		= { 0x108, 2 },
 	[AI_Status_2_Register]		= { 0, 0 }, /* Unknown */
 	[AO_Status_2_Register]		= { 0x10c, 2 },
@@ -994,8 +994,8 @@ static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 	for (i = 0; i < timeout; i++) {
 		unsigned short b_status;
 
-		b_status = ni_stc_readw(dev, AO_Status_1_Register);
-		if (b_status & AO_FIFO_Half_Full_St)
+		b_status = ni_stc_readw(dev, NISTC_AO_STATUS1_REG);
+		if (b_status & NISTC_AO_STATUS1_FIFO_HF)
 			break;
 		/* if we poll too often, the pci bus activity seems
 		   to slow the dma transfer down */
@@ -1428,19 +1428,19 @@ static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
 {
 	unsigned short ack = 0;
 
-	if (b_status & AO_BC_TC_St)
+	if (b_status & NISTC_AO_STATUS1_BC_TC)
 		ack |= NISTC_INTB_ACK_AO_BC_TC;
-	if (b_status & AO_Overrun_St)
+	if (b_status & NISTC_AO_STATUS1_OVERRUN)
 		ack |= NISTC_INTB_ACK_AO_ERR;
-	if (b_status & AO_START_St)
+	if (b_status & NISTC_AO_STATUS1_START)
 		ack |= NISTC_INTB_ACK_AO_START;
-	if (b_status & AO_START1_St)
+	if (b_status & NISTC_AO_STATUS1_START1)
 		ack |= NISTC_INTB_ACK_AO_START1;
-	if (b_status & AO_UC_TC_St)
+	if (b_status & NISTC_AO_STATUS1_UC_TC)
 		ack |= NISTC_INTB_ACK_AO_UC_TC;
-	if (b_status & AO_UI2_TC_St)
+	if (b_status & NISTC_AO_STATUS1_UI2_TC)
 		ack |= NISTC_INTB_ACK_AO_UI2_TC;
-	if (b_status & AO_UPDATE_St)
+	if (b_status & NISTC_AO_STATUS1_UPDATE)
 		ack |= NISTC_INTB_ACK_AO_UPDATE;
 	if (ack)
 		ni_stc_writew(dev, ack, NISTC_INTB_ACK_REG);
@@ -1472,18 +1472,18 @@ static void handle_b_interrupt(struct comedi_device *dev,
 
 	if (b_status == 0xffff)
 		return;
-	if (b_status & AO_Overrun_St) {
+	if (b_status & NISTC_AO_STATUS1_OVERRUN) {
 		dev_err(dev->class_dev,
 			"AO FIFO underrun status=0x%04x status2=0x%04x\n",
 			b_status, ni_stc_readw(dev, AO_Status_2_Register));
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 
-	if (b_status & AO_BC_TC_St)
+	if (b_status & NISTC_AO_STATUS1_BC_TC)
 		s->async->events |= COMEDI_CB_EOA;
 
 #ifndef PCIDMA
-	if (b_status & AO_FIFO_Request_St) {
+	if (b_status & NISTC_AO_STATUS1_FIFO_REQ) {
 		int ret;
 
 		ret = ni_ao_fifo_half_empty(dev, s);
@@ -3736,7 +3736,7 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G0_INT_ACK]	= { NISTC_INTA_ACK_REG, 2 },
 	[NITIO_G1_INT_ACK]	= { NISTC_INTB_ACK_REG, 2 },
 	[NITIO_G0_STATUS]	= { NISTC_AI_STATUS1_REG, 2 },
-	[NITIO_G1_STATUS]	= { AO_Status_1_Register, 2 },
+	[NITIO_G1_STATUS]	= { NISTC_AO_STATUS1_REG, 2 },
 	[NITIO_G0_INT_ENA]	= { NISTC_INTA_ENA_REG, 2 },
 	[NITIO_G1_INT_ENA]	= { NISTC_INTB_ENA_REG, 2 },
 };
@@ -4992,7 +4992,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 	/*  lock to avoid race with comedi_poll */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	a_status = ni_stc_readw(dev, NISTC_AI_STATUS1_REG);
-	b_status = ni_stc_readw(dev, AO_Status_1_Register);
+	b_status = ni_stc_readw(dev, NISTC_AO_STATUS1_REG);
 #ifdef PCIDMA
 	if (mite) {
 		struct ni_private *devpriv = dev->private;
@@ -5022,7 +5022,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 	ack_b_interrupt(dev, b_status);
 	if ((a_status & NISTC_AI_STATUS1_INTA) || (ai_mite_status & CHSR_INT))
 		handle_a_interrupt(dev, a_status, ai_mite_status);
-	if ((b_status & Interrupt_B_St) || (ao_mite_status & CHSR_INT))
+	if ((b_status & NISTC_AO_STATUS1_INTB) || (ao_mite_status & CHSR_INT))
 		handle_b_interrupt(dev, b_status, ao_mite_status);
 	handle_gpct_interrupt(dev, 0);
 	handle_gpct_interrupt(dev, 1);

commit 7b14fffd7832dd571a82c18bd0b58319b40d7378
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:37 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_Status_1_Register and bits
    
    Rename the CamelCase. Use the BIT() marco to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c0bd097ac13f..50a14d287613 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -410,7 +410,7 @@ static void m_series_stc_write(struct comedi_device *dev,
 }
 
 static const struct mio_regmap m_series_stc_read_regmap[] = {
-	[AI_Status_1_Register]		= { 0x104, 2 },
+	[NISTC_AI_STATUS1_REG]		= { 0x104, 2 },
 	[AO_Status_1_Register]		= { 0x106, 2 },
 	[G_Status_Register]		= { 0x108, 2 },
 	[AI_Status_2_Register]		= { 0, 0 }, /* Unknown */
@@ -950,8 +950,8 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ai_mite_chan) {
 		for (i = 0; i < timeout; i++) {
-			if ((ni_stc_readw(dev, AI_Status_1_Register) &
-			     AI_FIFO_Empty_St)
+			if ((ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
+			     NISTC_AI_STATUS1_FIFO_E)
 			    && mite_bytes_in_transit(devpriv->ai_mite_chan) ==
 			    0)
 				break;
@@ -962,7 +962,7 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 			dev_err(dev->class_dev,
 				"mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
 				mite_bytes_in_transit(devpriv->ai_mite_chan),
-				ni_stc_readw(dev, AI_Status_1_Register));
+				ni_stc_readw(dev, NISTC_AI_STATUS1_REG));
 			retval = -1;
 		}
 	}
@@ -1185,8 +1185,8 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 	int i;
 
 	if (devpriv->is_611x) {
-		while ((ni_stc_readw(dev, AI_Status_1_Register) &
-			AI_FIFO_Empty_St) == 0) {
+		while ((ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
+			NISTC_AI_STATUS1_FIFO_E) == 0) {
 			dl = ni_readl(dev, ADC_FIFO_Data_611x);
 
 			/* This may get the hi/lo data in the wrong order */
@@ -1217,16 +1217,16 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 		}
 
 	} else {
-		fifo_empty = ni_stc_readw(dev, AI_Status_1_Register) &
-			     AI_FIFO_Empty_St;
+		fifo_empty = ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
+			     NISTC_AI_STATUS1_FIFO_E;
 		while (fifo_empty == 0) {
 			for (i = 0;
 			     i <
 			     sizeof(devpriv->ai_fifo_buffer) /
 			     sizeof(devpriv->ai_fifo_buffer[0]); i++) {
 				fifo_empty = ni_stc_readw(dev,
-							  AI_Status_1_Register) &
-						AI_FIFO_Empty_St;
+							  NISTC_AI_STATUS1_REG) &
+						NISTC_AI_STATUS1_FIFO_E;
 				if (fifo_empty)
 					break;
 				devpriv->ai_fifo_buffer[i] =
@@ -1335,13 +1335,13 @@ static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 {
 	unsigned short ack = 0;
 
-	if (a_status & AI_SC_TC_St)
+	if (a_status & NISTC_AI_STATUS1_SC_TC)
 		ack |= NISTC_INTA_ACK_AI_SC_TC;
-	if (a_status & AI_START1_St)
+	if (a_status & NISTC_AI_STATUS1_START1)
 		ack |= NISTC_INTA_ACK_AI_START1;
-	if (a_status & AI_START_St)
+	if (a_status & NISTC_AI_STATUS1_START)
 		ack |= NISTC_INTA_ACK_AI_START;
-	if (a_status & AI_STOP_St)
+	if (a_status & NISTC_AI_STATUS1_STOP)
 		ack |= NISTC_INTA_ACK_AI_STOP;
 	if (ack)
 		ni_stc_writew(dev, ack, NISTC_INTA_ACK_REG);
@@ -1373,8 +1373,8 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 #endif
 
 	/* test for all uncommon interrupt events at the same time */
-	if (status & (AI_Overrun_St | AI_Overflow_St | AI_SC_TC_Error_St |
-		      AI_SC_TC_St | AI_START1_St)) {
+	if (status & (NISTC_AI_STATUS1_ERR |
+		      NISTC_AI_STATUS1_SC_TC | NISTC_AI_STATUS1_START1)) {
 		if (status == 0xffff) {
 			dev_err(dev->class_dev, "Card removed?\n");
 			/* we probably aren't even running a command now,
@@ -1385,41 +1385,40 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			}
 			return;
 		}
-		if (status & (AI_Overrun_St | AI_Overflow_St |
-			      AI_SC_TC_Error_St)) {
+		if (status & NISTC_AI_STATUS1_ERR) {
 			dev_err(dev->class_dev, "ai error a_status=%04x\n",
 				status);
 
 			shutdown_ai_command(dev);
 
 			s->async->events |= COMEDI_CB_ERROR;
-			if (status & (AI_Overrun_St | AI_Overflow_St))
+			if (status & NISTC_AI_STATUS1_OVER)
 				s->async->events |= COMEDI_CB_OVERFLOW;
 
 			comedi_handle_events(dev, s);
 			return;
 		}
-		if (status & AI_SC_TC_St) {
+		if (status & NISTC_AI_STATUS1_SC_TC) {
 			if (cmd->stop_src == TRIG_COUNT)
 				shutdown_ai_command(dev);
 		}
 	}
 #ifndef PCIDMA
-	if (status & AI_FIFO_Half_Full_St) {
+	if (status & NISTC_AI_STATUS1_FIFO_HF) {
 		int i;
 		static const int timeout = 10;
 		/* pcmcia cards (at least 6036) seem to stop producing interrupts if we
 		 *fail to get the fifo less than half full, so loop to be sure.*/
 		for (i = 0; i < timeout; ++i) {
 			ni_handle_fifo_half_full(dev);
-			if ((ni_stc_readw(dev, AI_Status_1_Register) &
-			     AI_FIFO_Half_Full_St) == 0)
+			if ((ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
+			     NISTC_AI_STATUS1_FIFO_HF) == 0)
 				break;
 		}
 	}
 #endif /*  !PCIDMA */
 
-	if ((status & AI_STOP_St))
+	if (status & NISTC_AI_STATUS1_STOP)
 		ni_handle_eos(dev, s);
 
 	comedi_handle_events(dev, s);
@@ -1695,8 +1694,8 @@ static void ni_prime_channelgain_list(struct comedi_device *dev)
 
 	ni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE, NISTC_AI_CMD1_REG);
 	for (i = 0; i < NI_TIMEOUT; ++i) {
-		if (!(ni_stc_readw(dev, AI_Status_1_Register) &
-		      AI_FIFO_Empty_St)) {
+		if (!(ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
+		      NISTC_AI_STATUS1_FIFO_E)) {
 			ni_stc_writew(dev, 1, NISTC_ADC_FIFO_CLR_REG);
 			return;
 		}
@@ -1953,8 +1952,8 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 					d &= 0xffff;
 					break;
 				}
-				if (!(ni_stc_readw(dev, AI_Status_1_Register) &
-				      AI_FIFO_Empty_St)) {
+				if (!(ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
+				      NISTC_AI_STATUS1_FIFO_E)) {
 					d = ni_readl(dev, ADC_FIFO_Data_611x);
 					d &= 0xffff;
 					break;
@@ -1994,8 +1993,8 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			ni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,
 				      NISTC_AI_CMD1_REG);
 			for (i = 0; i < NI_TIMEOUT; i++) {
-				if (!(ni_stc_readw(dev, AI_Status_1_Register) &
-				      AI_FIFO_Empty_St))
+				if (!(ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &
+				      NISTC_AI_STATUS1_FIFO_E))
 					break;
 			}
 			if (i == NI_TIMEOUT) {
@@ -3736,7 +3735,7 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G1_ABZ]		= { 0x1c2, 2 },	/* M-Series only */
 	[NITIO_G0_INT_ACK]	= { NISTC_INTA_ACK_REG, 2 },
 	[NITIO_G1_INT_ACK]	= { NISTC_INTB_ACK_REG, 2 },
-	[NITIO_G0_STATUS]	= { AI_Status_1_Register, 2 },
+	[NITIO_G0_STATUS]	= { NISTC_AI_STATUS1_REG, 2 },
 	[NITIO_G1_STATUS]	= { AO_Status_1_Register, 2 },
 	[NITIO_G0_INT_ENA]	= { NISTC_INTA_ENA_REG, 2 },
 	[NITIO_G1_INT_ENA]	= { NISTC_INTB_ENA_REG, 2 },
@@ -4992,7 +4991,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 
 	/*  lock to avoid race with comedi_poll */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	a_status = ni_stc_readw(dev, AI_Status_1_Register);
+	a_status = ni_stc_readw(dev, NISTC_AI_STATUS1_REG);
 	b_status = ni_stc_readw(dev, AO_Status_1_Register);
 #ifdef PCIDMA
 	if (mite) {
@@ -5021,7 +5020,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 #endif
 	ack_a_interrupt(dev, a_status);
 	ack_b_interrupt(dev, b_status);
-	if ((a_status & Interrupt_A_St) || (ai_mite_status & CHSR_INT))
+	if ((a_status & NISTC_AI_STATUS1_INTA) || (ai_mite_status & CHSR_INT))
 		handle_a_interrupt(dev, a_status, ai_mite_status);
 	if ((b_status & Interrupt_B_St) || (ao_mite_status & CHSR_INT))
 		handle_b_interrupt(dev, b_status, ao_mite_status);

commit c7edadc10326ec710b01cc1b727a701fcc06bed9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:36 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_Mode_3_Register and bits
    
    Rename the CamelCase. Use the BIT() marco to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 187a26153bd0..c0bd097ac13f 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -379,7 +379,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_ADC_FIFO_CLR_REG]	= { 0x1a6, 2 },
 	[NISTC_DAC_FIFO_CLR_REG]	= { 0x1a8, 2 },
 	[NISTC_AO_OUT_CTRL_REG]		= { 0x1ac, 2 },
-	[AI_Mode_3_Register]		= { 0x1ae, 2 },
+	[NISTC_AI_MODE3_REG]		= { 0x1ae, 2 },
 };
 
 static void m_series_stc_write(struct comedi_device *dev,
@@ -1630,7 +1630,8 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 		      NISTC_AI_MODE1_REG);
 	ni_stc_writew(dev, 0, NISTC_AI_MODE2_REG);
 	/* generate FIFO interrupts on non-empty */
-	ni_stc_writew(dev, (0 << 6) | 0x0000, AI_Mode_3_Register);
+	ni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_NE,
+		      NISTC_AI_MODE3_REG);
 
 	ai_personal = NISTC_AI_PERSONAL_SHIFTIN_PW |
 		      NISTC_AI_PERSONAL_SOC_POLARITY |
@@ -1657,7 +1658,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * are no backup registers in devpriv.  If you want to change
 	 * any of these, add a backup register and other appropriate code:
 	 *      NISTC_AI_MODE1_REG
-	 *      AI_Mode_3_Register
+	 *      NISTC_AI_MODE3_REG
 	 *      NISTC_AI_PERSONAL_REG
 	 *      NISTC_AI_OUT_CTRL_REG
 	 */
@@ -2335,7 +2336,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	case TRIG_TIMER:
 		/*
 		 * stop bits for non 611x boards
-		 * AI_SI_Special_Trigger_Delay=0
+		 * NISTC_AI_MODE3_SI_TRIG_DELAY=0
 		 * NISTC_AI_MODE2_PRE_TRIGGER=0
 		 * NISTC_AI_START_STOP_REG:
 		 * NISTC_AI_START_POLARITY=0	(?) rising edge
@@ -2432,25 +2433,25 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		case AIMODE_HALF_FULL:
 			/*generate FIFO interrupts and DMA requests on half-full */
 #ifdef PCIDMA
-			ni_stc_writew(dev, AI_FIFO_Mode_HF_to_E,
-				      AI_Mode_3_Register);
+			ni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_HF_E,
+				      NISTC_AI_MODE3_REG);
 #else
-			ni_stc_writew(dev, AI_FIFO_Mode_HF,
-				      AI_Mode_3_Register);
+			ni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_HF,
+				      NISTC_AI_MODE3_REG);
 #endif
 			break;
 		case AIMODE_SAMPLE:
 			/*generate FIFO interrupts on non-empty */
-			ni_stc_writew(dev, AI_FIFO_Mode_NE,
-				      AI_Mode_3_Register);
+			ni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_NE,
+				      NISTC_AI_MODE3_REG);
 			break;
 		case AIMODE_SCAN:
 #ifdef PCIDMA
-			ni_stc_writew(dev, AI_FIFO_Mode_NE,
-				      AI_Mode_3_Register);
+			ni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_NE,
+				      NISTC_AI_MODE3_REG);
 #else
-			ni_stc_writew(dev, AI_FIFO_Mode_HF,
-				      AI_Mode_3_Register);
+			ni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_HF,
+				      NISTC_AI_MODE3_REG);
 #endif
 			interrupt_a_enable |= NISTC_INTA_ENA_AI_STOP;
 			break;

commit 5bd1c7283794112234aace1ef679c947d26a841e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:35 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_Output_Control_Register and bits
    
    Rename the CamelCase. Convert the inline helper function into a macro and
    use the BIT() marco to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2229006e71c9..187a26153bd0 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -378,7 +378,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_CFG_MEM_CLR_REG]		= { 0x1a4, 2 },
 	[NISTC_ADC_FIFO_CLR_REG]	= { 0x1a6, 2 },
 	[NISTC_DAC_FIFO_CLR_REG]	= { 0x1a8, 2 },
-	[AO_Output_Control_Register]	= { 0x1ac, 2 },
+	[NISTC_AO_OUT_CTRL_REG]		= { 0x1ac, 2 },
 	[AI_Mode_3_Register]		= { 0x1ae, 2 },
 };
 
@@ -3028,21 +3028,21 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->scan_end_arg > 1) {
 		devpriv->ao_mode1 |= NISTC_AO_MODE1_MULTI_CHAN;
 		ni_stc_writew(dev,
-			      AO_Number_Of_Channels(cmd->scan_end_arg - 1) |
-			      AO_UPDATE_Output_Select(AO_Update_Output_High_Z),
-			      AO_Output_Control_Register);
+			      NISTC_AO_OUT_CTRL_CHANS(cmd->scan_end_arg - 1) |
+			      NISTC_AO_OUT_CTRL_UPDATE_SEL_HIGHZ,
+			      NISTC_AO_OUT_CTRL_REG);
 	} else {
 		unsigned bits;
 
 		devpriv->ao_mode1 &= ~NISTC_AO_MODE1_MULTI_CHAN;
-		bits = AO_UPDATE_Output_Select(AO_Update_Output_High_Z);
+		bits = NISTC_AO_OUT_CTRL_UPDATE_SEL_HIGHZ;
 		if (devpriv->is_m_series || devpriv->is_6xxx) {
-			bits |= AO_Number_Of_Channels(0);
+			bits |= NISTC_AO_OUT_CTRL_CHANS(0);
 		} else {
 			bits |=
-			    AO_Number_Of_Channels(CR_CHAN(cmd->chanlist[0]));
+			    NISTC_AO_OUT_CTRL_CHANS(CR_CHAN(cmd->chanlist[0]));
 		}
-		ni_stc_writew(dev, bits, AO_Output_Control_Register);
+		ni_stc_writew(dev, bits, NISTC_AO_OUT_CTRL_REG);
 	}
 	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
 
@@ -3193,7 +3193,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 			   NISTC_AO_PERSONAL_UPDATE_PW |
 			   NISTC_AO_PERSONAL_TMRDACWR_PW,
 		      NISTC_AO_PERSONAL_REG);
-	ni_stc_writew(dev, 0, AO_Output_Control_Register);
+	ni_stc_writew(dev, 0, NISTC_AO_OUT_CTRL_REG);
 	ni_stc_writew(dev, 0, NISTC_AO_START_SEL_REG);
 	devpriv->ao_cmd1 = 0;
 	ni_stc_writew(dev, devpriv->ao_cmd1, NISTC_AO_CMD1_REG);

commit 8102f3d0c17b11e01e31a01c762867ae44a96d23
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:34 2015 -0700

    staging: comedi: ni_stc.h: tidy up Write_Strobe_*_Register
    
    The Write_Strobe_*_Register defines are noy used. Instead the more
    descriptive Configuration_Memory_Clear, ADC_FIFO_Clear and DAC_FIFO_Clear
    defines are used. Remove the unused defines and rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 3334c54db03c..2229006e71c9 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -375,9 +375,9 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_RTSI_TRIGA_OUT_REG]	= { 0x19e, 2 },
 	[NISTC_RTSI_TRIGB_OUT_REG]	= { 0x1a0, 2 },
 	[NISTC_RTSI_BOARD_REG]		= { 0, 0 }, /* Unknown */
-	[Configuration_Memory_Clear]	= { 0x1a4, 2 },
-	[ADC_FIFO_Clear]		= { 0x1a6, 2 },
-	[DAC_FIFO_Clear]		= { 0x1a8, 2 },
+	[NISTC_CFG_MEM_CLR_REG]		= { 0x1a4, 2 },
+	[NISTC_ADC_FIFO_CLR_REG]	= { 0x1a6, 2 },
+	[NISTC_DAC_FIFO_CLR_REG]	= { 0x1a8, 2 },
 	[AO_Output_Control_Register]	= { 0x1ac, 2 },
 	[AI_Mode_3_Register]		= { 0x1ae, 2 },
 };
@@ -849,7 +849,7 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 		if (i == timeout)
 			dev_err(dev->class_dev, "FIFO flush timeout\n");
 	} else {
-		ni_stc_writew(dev, 1, ADC_FIFO_Clear);
+		ni_stc_writew(dev, 1, NISTC_ADC_FIFO_CLR_REG);
 		if (devpriv->is_625x) {
 			ni_writeb(dev, 0, NI_M_STATIC_AI_CTRL_REG(0));
 			ni_writeb(dev, 1, NI_M_STATIC_AI_CTRL_REG(0));
@@ -1084,7 +1084,7 @@ static int ni_ao_prep_fifo(struct comedi_device *dev,
 	unsigned int nsamples;
 
 	/* reset fifo */
-	ni_stc_writew(dev, 1, DAC_FIFO_Clear);
+	ni_stc_writew(dev, 1, NISTC_DAC_FIFO_CLR_REG);
 	if (devpriv->is_6xxx)
 		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
 
@@ -1696,7 +1696,7 @@ static void ni_prime_channelgain_list(struct comedi_device *dev)
 	for (i = 0; i < NI_TIMEOUT; ++i) {
 		if (!(ni_stc_readw(dev, AI_Status_1_Register) &
 		      AI_FIFO_Empty_St)) {
-			ni_stc_writew(dev, 1, ADC_FIFO_Clear);
+			ni_stc_writew(dev, 1, NISTC_ADC_FIFO_CLR_REG);
 			return;
 		}
 		udelay(1);
@@ -1715,7 +1715,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 	unsigned int dither;
 	unsigned range_code;
 
-	ni_stc_writew(dev, 1, Configuration_Memory_Clear);
+	ni_stc_writew(dev, 1, NISTC_CFG_MEM_CLR_REG);
 
 	if ((list[0] & CR_ALT_SOURCE)) {
 		unsigned bypass_bits;
@@ -1830,7 +1830,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		devpriv->changain_state = 0;
 	}
 
-	ni_stc_writew(dev, 1, Configuration_Memory_Clear);
+	ni_stc_writew(dev, 1, NISTC_CFG_MEM_CLR_REG);
 
 	/*  Set up Calibration mode if required */
 	if (devpriv->is_6143) {
@@ -2826,7 +2826,7 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 		    NISTC_INTB_ENA_AO_FIFO | NISTC_INTB_ENA_AO_ERR, 0);
 	interrupt_b_bits = NISTC_INTB_ENA_AO_ERR;
 #ifdef PCIDMA
-	ni_stc_writew(dev, 1, DAC_FIFO_Clear);
+	ni_stc_writew(dev, 1, NISTC_DAC_FIFO_CLR_REG);
 	if (devpriv->is_6xxx)
 		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
 	ret = ni_ao_setup_MITE_dma(dev);

commit 24a11ba670f79a81ebd99931b9ba863f6db04812
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:33 2015 -0700

    staging: comedi: ni_stc.h: tidy up RTSI_Board_Register
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a29ee9ec8236..3334c54db03c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -374,7 +374,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AO_PERSONAL_REG]		= { 0x19c, 2 },
 	[NISTC_RTSI_TRIGA_OUT_REG]	= { 0x19e, 2 },
 	[NISTC_RTSI_TRIGB_OUT_REG]	= { 0x1a0, 2 },
-	[RTSI_Board_Register]		= { 0, 0 }, /* Unknown */
+	[NISTC_RTSI_BOARD_REG]		= { 0, 0 }, /* Unknown */
 	[Configuration_Memory_Clear]	= { 0x1a4, 2 },
 	[ADC_FIFO_Clear]		= { 0x1a6, 2 },
 	[DAC_FIFO_Clear]		= { 0x1a8, 2 },
@@ -4935,10 +4935,10 @@ static void ni_rtsi_init(struct comedi_device *dev)
 	ni_stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
 		      NISTC_RTSI_TRIGB_OUT_REG);
 
-/*
-* Sets the source and direction of the 4 on board lines
-* ni_stc_writew(dev, 0x0000, RTSI_Board_Register);
-*/
+	/*
+	 * Sets the source and direction of the 4 on board lines
+	 * ni_stc_writew(dev, 0, NISTC_RTSI_BOARD_REG);
+	 */
 }
 
 #ifdef PCIDMA

commit 390bc6ffe797b6b071eeab4628054adc4b9b4751
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:32 2015 -0700

    staging: comedi: ni_stc.h: tidy up RTSI_Trig_[AB]_Output_Register and bits
    
    Rename the CamelCase. Convert the inline helper functions to macros and use
    the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 3d4f876d2f87..a29ee9ec8236 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -372,8 +372,8 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_INTB2_ENA_REG]		= { 0, 0 }, /* E-Series only */
 	[NISTC_AI_PERSONAL_REG]		= { 0x19a, 2 },
 	[NISTC_AO_PERSONAL_REG]		= { 0x19c, 2 },
-	[RTSI_Trig_A_Output_Register]	= { 0x19e, 2 },
-	[RTSI_Trig_B_Output_Register]	= { 0x1a0, 2 },
+	[NISTC_RTSI_TRIGA_OUT_REG]	= { 0x19e, 2 },
+	[NISTC_RTSI_TRIGB_OUT_REG]	= { 0x1a0, 2 },
 	[RTSI_Board_Register]		= { 0, 0 }, /* Unknown */
 	[Configuration_Memory_Clear]	= { 0x1a4, 2 },
 	[ADC_FIFO_Clear]		= { 0x1a6, 2 },
@@ -4791,24 +4791,22 @@ static int ni_valid_rtsi_output_source(struct comedi_device *dev,
 }
 
 static int ni_set_rtsi_routing(struct comedi_device *dev,
-			       unsigned chan, unsigned source)
+			       unsigned chan, unsigned src)
 {
 	struct ni_private *devpriv = dev->private;
 
-	if (ni_valid_rtsi_output_source(dev, chan, source) == 0)
+	if (ni_valid_rtsi_output_source(dev, chan, src) == 0)
 		return -EINVAL;
 	if (chan < 4) {
-		devpriv->rtsi_trig_a_output_reg &= ~RTSI_Trig_Output_Mask(chan);
-		devpriv->rtsi_trig_a_output_reg |=
-		    RTSI_Trig_Output_Bits(chan, source);
+		devpriv->rtsi_trig_a_output_reg &= ~NISTC_RTSI_TRIG_MASK(chan);
+		devpriv->rtsi_trig_a_output_reg |= NISTC_RTSI_TRIG(chan, src);
 		ni_stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
-			      RTSI_Trig_A_Output_Register);
+			      NISTC_RTSI_TRIGA_OUT_REG);
 	} else if (chan < 8) {
-		devpriv->rtsi_trig_b_output_reg &= ~RTSI_Trig_Output_Mask(chan);
-		devpriv->rtsi_trig_b_output_reg |=
-		    RTSI_Trig_Output_Bits(chan, source);
+		devpriv->rtsi_trig_b_output_reg &= ~NISTC_RTSI_TRIG_MASK(chan);
+		devpriv->rtsi_trig_b_output_reg |= NISTC_RTSI_TRIG(chan, src);
 		ni_stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
-			      RTSI_Trig_B_Output_Register);
+			      NISTC_RTSI_TRIGB_OUT_REG);
 	}
 	return 2;
 }
@@ -4818,11 +4816,11 @@ static unsigned ni_get_rtsi_routing(struct comedi_device *dev, unsigned chan)
 	struct ni_private *devpriv = dev->private;
 
 	if (chan < 4) {
-		return RTSI_Trig_Output_Source(chan,
-					       devpriv->rtsi_trig_a_output_reg);
+		return NISTC_RTSI_TRIG_TO_SRC(chan,
+					      devpriv->rtsi_trig_a_output_reg);
 	} else if (chan < NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series)) {
-		return RTSI_Trig_Output_Source(chan,
-					       devpriv->rtsi_trig_b_output_reg);
+		return NISTC_RTSI_TRIG_TO_SRC(chan,
+					      devpriv->rtsi_trig_b_output_reg);
 	} else {
 		if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN)
 			return NI_RTSI_OUTPUT_RTSI_OSC;
@@ -4921,26 +4919,21 @@ static void ni_rtsi_init(struct comedi_device *dev)
 		dev_err(dev->class_dev, "ni_set_master_clock failed, bug?\n");
 	/*  default internal lines routing to RTSI bus lines */
 	devpriv->rtsi_trig_a_output_reg =
-	    RTSI_Trig_Output_Bits(0,
-				  NI_RTSI_OUTPUT_ADR_START1) |
-	    RTSI_Trig_Output_Bits(1,
-				  NI_RTSI_OUTPUT_ADR_START2) |
-	    RTSI_Trig_Output_Bits(2,
-				  NI_RTSI_OUTPUT_SCLKG) |
-	    RTSI_Trig_Output_Bits(3, NI_RTSI_OUTPUT_DACUPDN);
+	    NISTC_RTSI_TRIG(0, NI_RTSI_OUTPUT_ADR_START1) |
+	    NISTC_RTSI_TRIG(1, NI_RTSI_OUTPUT_ADR_START2) |
+	    NISTC_RTSI_TRIG(2, NI_RTSI_OUTPUT_SCLKG) |
+	    NISTC_RTSI_TRIG(3, NI_RTSI_OUTPUT_DACUPDN);
 	ni_stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
-		      RTSI_Trig_A_Output_Register);
+		      NISTC_RTSI_TRIGA_OUT_REG);
 	devpriv->rtsi_trig_b_output_reg =
-	    RTSI_Trig_Output_Bits(4,
-				  NI_RTSI_OUTPUT_DA_START1) |
-	    RTSI_Trig_Output_Bits(5,
-				  NI_RTSI_OUTPUT_G_SRC0) |
-	    RTSI_Trig_Output_Bits(6, NI_RTSI_OUTPUT_G_GATE0);
+	    NISTC_RTSI_TRIG(4, NI_RTSI_OUTPUT_DA_START1) |
+	    NISTC_RTSI_TRIG(5, NI_RTSI_OUTPUT_G_SRC0) |
+	    NISTC_RTSI_TRIG(6, NI_RTSI_OUTPUT_G_GATE0);
 	if (devpriv->is_m_series)
 		devpriv->rtsi_trig_b_output_reg |=
-		    RTSI_Trig_Output_Bits(7, NI_RTSI_OUTPUT_RTSI_OSC);
+		    NISTC_RTSI_TRIG(7, NI_RTSI_OUTPUT_RTSI_OSC);
 	ni_stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
-		      RTSI_Trig_B_Output_Register);
+		      NISTC_RTSI_TRIGB_OUT_REG);
 
 /*
 * Sets the source and direction of the 4 on board lines

commit 63ff3f2c2945adecf6b843c8213ab050ef1326f8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:31 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_Personal_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5e0c527ac557..3d4f876d2f87 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -371,7 +371,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_INTB_ENA_REG]		= { 0x196, 2 },
 	[NISTC_INTB2_ENA_REG]		= { 0, 0 }, /* E-Series only */
 	[NISTC_AI_PERSONAL_REG]		= { 0x19a, 2 },
-	[AO_Personal_Register]		= { 0x19c, 2 },
+	[NISTC_AO_PERSONAL_REG]		= { 0x19c, 2 },
 	[RTSI_Trig_A_Output_Register]	= { 0x19e, 2 },
 	[RTSI_Trig_B_Output_Register]	= { 0x1a0, 2 },
 	[RTSI_Board_Register]		= { 0, 0 }, /* Unknown */
@@ -3062,19 +3062,22 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_FIFO_REXMIT_ENA;
 	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
 
-	bits = AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
-	    AO_TMRDACWR_Pulse_Width;
+	bits = NISTC_AO_PERSONAL_BC_SRC_SEL |
+	       NISTC_AO_PERSONAL_UPDATE_PW |
+	       NISTC_AO_PERSONAL_TMRDACWR_PW;
 	if (board->ao_fifo_depth)
-		bits |= AO_FIFO_Enable;
+		bits |= NISTC_AO_PERSONAL_FIFO_ENA;
 	else
-		bits |= AO_DMA_PIO_Control;
+		bits |= NISTC_AO_PERSONAL_DMA_PIO_CTRL;
 #if 0
-	/* F Hess: windows driver does not set AO_Number_Of_DAC_Packages bit for 6281,
-	   verified with bus analyzer. */
+	/*
+	 * F Hess: windows driver does not set NISTC_AO_PERSONAL_NUM_DAC bit
+	 * for 6281, verified with bus analyzer.
+	 */
 	if (devpriv->is_m_series)
-		bits |= AO_Number_Of_DAC_Packages;
+		bits |= NISTC_AO_PERSONAL_NUM_DAC;
 #endif
-	ni_stc_writew(dev, bits, AO_Personal_Register);
+	ni_stc_writew(dev, bits, NISTC_AO_PERSONAL_REG);
 	/*  enable sending of ao dma requests */
 	ni_stc_writew(dev, NISTC_AO_START_AOFREQ_ENA, NISTC_AO_START_SEL_REG);
 
@@ -3184,10 +3187,12 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
 	ni_stc_writew(dev, NISTC_AO_CMD1_DISARM, NISTC_AO_CMD1_REG);
 	ni_set_bits(dev, NISTC_INTB_ENA_REG, ~0, 0);
-	ni_stc_writew(dev, AO_BC_Source_Select, AO_Personal_Register);
+	ni_stc_writew(dev, NISTC_AO_PERSONAL_BC_SRC_SEL, NISTC_AO_PERSONAL_REG);
 	ni_stc_writew(dev, NISTC_INTB_ACK_AO_ALL, NISTC_INTB_ACK_REG);
-	ni_stc_writew(dev, AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
-		      AO_TMRDACWR_Pulse_Width, AO_Personal_Register);
+	ni_stc_writew(dev, NISTC_AO_PERSONAL_BC_SRC_SEL |
+			   NISTC_AO_PERSONAL_UPDATE_PW |
+			   NISTC_AO_PERSONAL_TMRDACWR_PW,
+		      NISTC_AO_PERSONAL_REG);
 	ni_stc_writew(dev, 0, AO_Output_Control_Register);
 	ni_stc_writew(dev, 0, NISTC_AO_START_SEL_REG);
 	devpriv->ao_cmd1 = 0;

commit c1b74035e1d5da58292448df2351d9334ff36a24
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:30 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_Personal_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Tidy up ni_ai_reset() by using a local var to set the common bits and
    programming the register in the common code path.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 3123fb952dac..5e0c527ac557 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -370,7 +370,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_INTA2_ENA_REG]		= { 0, 0 }, /* E-Series only */
 	[NISTC_INTB_ENA_REG]		= { 0x196, 2 },
 	[NISTC_INTB2_ENA_REG]		= { 0, 0 }, /* E-Series only */
-	[AI_Personal_Register]		= { 0x19a, 2 },
+	[NISTC_AI_PERSONAL_REG]		= { 0x19a, 2 },
 	[AO_Personal_Register]		= { 0x19c, 2 },
 	[RTSI_Trig_A_Output_Register]	= { 0x19e, 2 },
 	[RTSI_Trig_B_Output_Register]	= { 0x1a0, 2 },
@@ -1608,6 +1608,7 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct ni_private *devpriv = dev->private;
+	unsigned ai_personal;
 	unsigned ai_out_ctrl;
 
 	ni_release_ai_mite_channel(dev);
@@ -1631,35 +1632,25 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* generate FIFO interrupts on non-empty */
 	ni_stc_writew(dev, (0 << 6) | 0x0000, AI_Mode_3_Register);
 
+	ai_personal = NISTC_AI_PERSONAL_SHIFTIN_PW |
+		      NISTC_AI_PERSONAL_SOC_POLARITY |
+		      NISTC_AI_PERSONAL_LOCALMUX_CLK_PW;
 	ai_out_ctrl = NISTC_AI_OUT_CTRL_SCAN_IN_PROG_SEL(3) |
 		      NISTC_AI_OUT_CTRL_EXTMUX_CLK_SEL(0) |
 		      NISTC_AI_OUT_CTRL_LOCALMUX_CLK_SEL(2) |
 		      NISTC_AI_OUT_CTRL_SC_TC_SEL(3);
 	if (devpriv->is_611x) {
-		ni_stc_writew(dev,
-			      AI_SHIFTIN_Pulse_Width |
-			      AI_SOC_Polarity |
-			      AI_LOCALMUX_CLK_Pulse_Width,
-			      AI_Personal_Register);
 		ai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_HIGH;
 	} else if (devpriv->is_6143) {
-		ni_stc_writew(dev, AI_SHIFTIN_Pulse_Width |
-				   AI_SOC_Polarity |
-				   AI_LOCALMUX_CLK_Pulse_Width,
-			      AI_Personal_Register);
 		ai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_LOW;
 	} else {
-		ni_stc_writew(dev,
-			      AI_SHIFTIN_Pulse_Width |
-			      AI_SOC_Polarity |
-			      AI_CONVERT_Pulse_Width |
-			      AI_LOCALMUX_CLK_Pulse_Width,
-			      AI_Personal_Register);
+		ai_personal |= NISTC_AI_PERSONAL_CONVERT_PW;
 		if (devpriv->is_622x)
 			ai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_HIGH;
 		else
 			ai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_LOW;
 	}
+	ni_stc_writew(dev, ai_personal, NISTC_AI_PERSONAL_REG);
 	ni_stc_writew(dev, ai_out_ctrl, NISTC_AI_OUT_CTRL_REG);
 
 	/* the following registers should not be changed, because there
@@ -1667,7 +1658,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * any of these, add a backup register and other appropriate code:
 	 *      NISTC_AI_MODE1_REG
 	 *      AI_Mode_3_Register
-	 *      AI_Personal_Register
+	 *      NISTC_AI_PERSONAL_REG
 	 *      NISTC_AI_OUT_CTRL_REG
 	 */
 

commit 04b6846731508684366b1b91a893021c4272da6d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:29 2015 -0700

    staging: comedi: ni_stc.h: tidy up Second_IRQ_B_Enable_Register and bits
    
    Rename the CamelCase. The bit defines are identical to NISTC_INTB_ENA_REG.
    Reuse them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 24d27044f147..3123fb952dac 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -369,7 +369,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_INTA_ENA_REG]		= { 0x192, 2 },
 	[NISTC_INTA2_ENA_REG]		= { 0, 0 }, /* E-Series only */
 	[NISTC_INTB_ENA_REG]		= { 0x196, 2 },
-	[Second_IRQ_B_Enable_Register]	= { 0, 0 }, /* E-Series only */
+	[NISTC_INTB2_ENA_REG]		= { 0, 0 }, /* E-Series only */
 	[AI_Personal_Register]		= { 0x19a, 2 },
 	[AO_Personal_Register]		= { 0x19c, 2 },
 	[RTSI_Trig_A_Output_Register]	= { 0x19e, 2 },
@@ -822,9 +822,9 @@ static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 		if (enable)
 			val = NISTC_INTA_ENA_G0_GATE;
 	} else {
-		reg = Second_IRQ_B_Enable_Register;
+		reg = NISTC_INTB2_ENA_REG;
 		if (enable)
-			val = G1_Gate_Second_Irq_Enable;
+			val = NISTC_INTB_ENA_G1_GATE;
 	}
 	ni_stc_writew(dev, val, reg);
 }

commit 4c9c1d2c52992995b319de5edfe13887b86f8542
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:28 2015 -0700

    staging: comedi: ni_stc.h: tidy up Interrupt_B_Enable_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0e7075dd5109..24d27044f147 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -368,7 +368,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_RESET_REG]		= { 0x190, 2 },
 	[NISTC_INTA_ENA_REG]		= { 0x192, 2 },
 	[NISTC_INTA2_ENA_REG]		= { 0, 0 }, /* E-Series only */
-	[Interrupt_B_Enable_Register]	= { 0x196, 2 },
+	[NISTC_INTB_ENA_REG]		= { 0x196, 2 },
 	[Second_IRQ_B_Enable_Register]	= { 0, 0 }, /* E-Series only */
 	[AI_Personal_Register]		= { 0x19a, 2 },
 	[AO_Personal_Register]		= { 0x19c, 2 },
@@ -536,7 +536,7 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 		devpriv->int_a_enable_reg |= bit_values & bit_mask;
 		ni_stc_writew(dev, devpriv->int_a_enable_reg, reg);
 		break;
-	case Interrupt_B_Enable_Register:
+	case NISTC_INTB_ENA_REG:
 		devpriv->int_b_enable_reg &= ~bit_mask;
 		devpriv->int_b_enable_reg |= bit_values & bit_mask;
 		ni_stc_writew(dev, devpriv->int_b_enable_reg, reg);
@@ -1490,9 +1490,9 @@ static void handle_b_interrupt(struct comedi_device *dev,
 		ret = ni_ao_fifo_half_empty(dev, s);
 		if (!ret) {
 			dev_err(dev->class_dev, "AO buffer underrun\n");
-			ni_set_bits(dev, Interrupt_B_Enable_Register,
-				    AO_FIFO_Interrupt_Enable |
-				    AO_Error_Interrupt_Enable, 0);
+			ni_set_bits(dev, NISTC_INTB_ENA_REG,
+				    NISTC_INTB_ENA_AO_FIFO |
+				    NISTC_INTB_ENA_AO_ERR, 0);
 			s->async->events |= COMEDI_CB_OVERFLOW;
 		}
 	}
@@ -2831,9 +2831,9 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 	   multiple times) */
 	s->async->inttrig = NULL;
 
-	ni_set_bits(dev, Interrupt_B_Enable_Register,
-		    AO_FIFO_Interrupt_Enable | AO_Error_Interrupt_Enable, 0);
-	interrupt_b_bits = AO_Error_Interrupt_Enable;
+	ni_set_bits(dev, NISTC_INTB_ENA_REG,
+		    NISTC_INTB_ENA_AO_FIFO | NISTC_INTB_ENA_AO_ERR, 0);
+	interrupt_b_bits = NISTC_INTB_ENA_AO_ERR;
 #ifdef PCIDMA
 	ni_stc_writew(dev, 1, DAC_FIFO_Clear);
 	if (devpriv->is_6xxx)
@@ -2849,7 +2849,7 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 	if (ret == 0)
 		return -EPIPE;
 
-	interrupt_b_bits |= AO_FIFO_Interrupt_Enable;
+	interrupt_b_bits |= NISTC_INTB_ENA_AO_FIFO;
 #endif
 
 	ni_stc_writew(dev, devpriv->ao_mode3 | NISTC_AO_MODE3_NOT_AN_UPDATE,
@@ -2873,7 +2873,7 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 	 */
 	ni_stc_writew(dev, NISTC_INTB_ACK_AO_ERR, NISTC_INTB_ACK_REG);
 
-	ni_set_bits(dev, Interrupt_B_Enable_Register, interrupt_b_bits, 1);
+	ni_set_bits(dev, NISTC_INTB_ENA_REG, interrupt_b_bits, 1);
 
 	ni_stc_writew(dev, NISTC_AO_CMD1_UI_ARM |
 			   NISTC_AO_CMD1_UC_ARM |
@@ -3092,8 +3092,8 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->stop_src == TRIG_COUNT) {
 		ni_stc_writew(dev, NISTC_INTB_ACK_AO_BC_TC,
 			      NISTC_INTB_ACK_REG);
-		ni_set_bits(dev, Interrupt_B_Enable_Register,
-			    AO_BC_TC_Interrupt_Enable, 1);
+		ni_set_bits(dev, NISTC_INTB_ENA_REG,
+			    NISTC_INTB_ENA_AO_BC_TC, 1);
 	}
 
 	s->async->inttrig = ni_ao_inttrig;
@@ -3192,7 +3192,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
 	ni_stc_writew(dev, NISTC_AO_CMD1_DISARM, NISTC_AO_CMD1_REG);
-	ni_set_bits(dev, Interrupt_B_Enable_Register, ~0, 0);
+	ni_set_bits(dev, NISTC_INTB_ENA_REG, ~0, 0);
 	ni_stc_writew(dev, AO_BC_Source_Select, AO_Personal_Register);
 	ni_stc_writew(dev, NISTC_INTB_ACK_AO_ALL, NISTC_INTB_ACK_REG);
 	ni_stc_writew(dev, AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
@@ -3742,7 +3742,7 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G0_STATUS]	= { AI_Status_1_Register, 2 },
 	[NITIO_G1_STATUS]	= { AO_Status_1_Register, 2 },
 	[NITIO_G0_INT_ENA]	= { NISTC_INTA_ENA_REG, 2 },
-	[NITIO_G1_INT_ENA]	= { Interrupt_B_Enable_Register, 2 },
+	[NITIO_G1_INT_ENA]	= { NISTC_INTB_ENA_REG, 2 },
 };
 
 static unsigned int ni_gpct_to_stc_register(struct comedi_device *dev,
@@ -3769,7 +3769,7 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 	static const unsigned gpct_interrupt_a_enable_mask =
 	    NISTC_INTA_ENA_G0_GATE | NISTC_INTA_ENA_G0_TC;
 	static const unsigned gpct_interrupt_b_enable_mask =
-	    G1_Gate_Interrupt_Enable | G1_TC_Interrupt_Enable;
+	    NISTC_INTB_ENA_G1_GATE | NISTC_INTB_ENA_G1_TC;
 
 	if (stc_register == 0)
 		return;

commit d84e9c348901ee0be9b71e1f9fb7ab32d48a2a82
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:27 2015 -0700

    staging: comedi: ni_stc.h: tidy up Second_IRQ_A_Enable_Register and bits
    
    Rename the CamelCase. The bit defines are identical to NISTC_INTA_ENA_REG.
    Reuse them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0651aed7f4db..0e7075dd5109 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -367,7 +367,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AO_MODE3_REG]		= { 0x18c, 2 },
 	[NISTC_RESET_REG]		= { 0x190, 2 },
 	[NISTC_INTA_ENA_REG]		= { 0x192, 2 },
-	[Second_IRQ_A_Enable_Register]	= { 0, 0 }, /* E-Series only */
+	[NISTC_INTA2_ENA_REG]		= { 0, 0 }, /* E-Series only */
 	[Interrupt_B_Enable_Register]	= { 0x196, 2 },
 	[Second_IRQ_B_Enable_Register]	= { 0, 0 }, /* E-Series only */
 	[AI_Personal_Register]		= { 0x19a, 2 },
@@ -818,9 +818,9 @@ static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 	 * dma requests for their counters
 	 */
 	if (gpct_index == 0) {
-		reg = Second_IRQ_A_Enable_Register;
+		reg = NISTC_INTA2_ENA_REG;
 		if (enable)
-			val = G0_Gate_Second_Irq_Enable;
+			val = NISTC_INTA_ENA_G0_GATE;
 	} else {
 		reg = Second_IRQ_B_Enable_Register;
 		if (enable)

commit 5cca26aaf2305db6bdaae26b2bb814ae93ca1652
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:26 2015 -0700

    staging: comedi: ni_stc.h: tidy up Interrupt_A_Enable_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ea6eabdc6481..0651aed7f4db 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -366,7 +366,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_G1_AUTOINC_REG]		= { 0x18a, 2 },
 	[NISTC_AO_MODE3_REG]		= { 0x18c, 2 },
 	[NISTC_RESET_REG]		= { 0x190, 2 },
-	[Interrupt_A_Enable_Register]	= { 0x192, 2 },
+	[NISTC_INTA_ENA_REG]		= { 0x192, 2 },
 	[Second_IRQ_A_Enable_Register]	= { 0, 0 }, /* E-Series only */
 	[Interrupt_B_Enable_Register]	= { 0x196, 2 },
 	[Second_IRQ_B_Enable_Register]	= { 0, 0 }, /* E-Series only */
@@ -531,7 +531,7 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 
 	spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
 	switch (reg) {
-	case Interrupt_A_Enable_Register:
+	case NISTC_INTA_ENA_REG:
 		devpriv->int_a_enable_reg &= ~bit_mask;
 		devpriv->int_a_enable_reg |= bit_values & bit_mask;
 		ni_stc_writew(dev, devpriv->int_a_enable_reg, reg);
@@ -1615,11 +1615,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_stc_writew(dev, NISTC_RESET_AI_CFG_START | NISTC_RESET_AI,
 		      NISTC_RESET_REG);
 
-	ni_set_bits(dev, Interrupt_A_Enable_Register,
-		    AI_SC_TC_Interrupt_Enable | AI_START1_Interrupt_Enable |
-		    AI_START2_Interrupt_Enable | AI_START_Interrupt_Enable |
-		    AI_STOP_Interrupt_Enable | AI_Error_Interrupt_Enable |
-		    AI_FIFO_Interrupt_Enable, 0);
+	ni_set_bits(dev, NISTC_INTA_ENA_REG, NISTC_INTA_ENA_AI_MASK, 0);
 
 	ni_clear_ai_fifo(dev);
 
@@ -2323,7 +2319,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		if (stop_count == 0) {
 			devpriv->ai_cmd2 |= NISTC_AI_CMD2_END_ON_EOS;
-			interrupt_a_enable |= AI_STOP_Interrupt_Enable;
+			interrupt_a_enable |= NISTC_INTA_ENA_AI_STOP;
 			/*  this is required to get the last sample for chanlist_len > 1, not sure why */
 			if (cmd->chanlist_len > 1)
 				start_stop_select |= NISTC_AI_STOP_POLARITY |
@@ -2426,11 +2422,11 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (dev->irq) {
 		/* interrupt on FIFO, errors, SC_TC */
-		interrupt_a_enable |= AI_Error_Interrupt_Enable |
-		    AI_SC_TC_Interrupt_Enable;
+		interrupt_a_enable |= NISTC_INTA_ENA_AI_ERR |
+				      NISTC_INTA_ENA_AI_SC_TC;
 
 #ifndef PCIDMA
-		interrupt_a_enable |= AI_FIFO_Interrupt_Enable;
+		interrupt_a_enable |= NISTC_INTA_ENA_AI_FIFO;
 #endif
 
 		if ((cmd->flags & CMDF_WAKE_EOS) ||
@@ -2465,7 +2461,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			ni_stc_writew(dev, AI_FIFO_Mode_HF,
 				      AI_Mode_3_Register);
 #endif
-			interrupt_a_enable |= AI_STOP_Interrupt_Enable;
+			interrupt_a_enable |= NISTC_INTA_ENA_AI_STOP;
 			break;
 		default:
 			break;
@@ -2474,11 +2470,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* clear interrupts */
 		ni_stc_writew(dev, NISTC_INTA_ACK_AI_ALL, NISTC_INTA_ACK_REG);
 
-		ni_set_bits(dev, Interrupt_A_Enable_Register,
-			    interrupt_a_enable, 1);
+		ni_set_bits(dev, NISTC_INTA_ENA_REG, interrupt_a_enable, 1);
 	} else {
 		/* interrupt on nothing */
-		ni_set_bits(dev, Interrupt_A_Enable_Register, ~0, 0);
+		ni_set_bits(dev, NISTC_INTA_ENA_REG, ~0, 0);
 
 		/* XXX start polling if necessary */
 	}
@@ -3746,7 +3741,7 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G1_INT_ACK]	= { NISTC_INTB_ACK_REG, 2 },
 	[NITIO_G0_STATUS]	= { AI_Status_1_Register, 2 },
 	[NITIO_G1_STATUS]	= { AO_Status_1_Register, 2 },
-	[NITIO_G0_INT_ENA]	= { Interrupt_A_Enable_Register, 2 },
+	[NITIO_G0_INT_ENA]	= { NISTC_INTA_ENA_REG, 2 },
 	[NITIO_G1_INT_ENA]	= { Interrupt_B_Enable_Register, 2 },
 };
 
@@ -3772,7 +3767,7 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 	struct comedi_device *dev = counter->counter_dev->dev;
 	unsigned int stc_register = ni_gpct_to_stc_register(dev, reg);
 	static const unsigned gpct_interrupt_a_enable_mask =
-	    G0_Gate_Interrupt_Enable | G0_TC_Interrupt_Enable;
+	    NISTC_INTA_ENA_G0_GATE | NISTC_INTA_ENA_G0_TC;
 	static const unsigned gpct_interrupt_b_enable_mask =
 	    G1_Gate_Interrupt_Enable | G1_TC_Interrupt_Enable;
 

commit 707502f3d0f1b07938fb9115971ecce1c9db1a97
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:25 2015 -0700

    staging: comedi: ni_stc.h: tidy up Joint_Reset_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a417ab405a3d..ea6eabdc6481 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -365,7 +365,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_G0_AUTOINC_REG]		= { 0x188, 2 },
 	[NISTC_G1_AUTOINC_REG]		= { 0x18a, 2 },
 	[NISTC_AO_MODE3_REG]		= { 0x18c, 2 },
-	[Joint_Reset_Register]		= { 0x190, 2 },
+	[NISTC_RESET_REG]		= { 0x190, 2 },
 	[Interrupt_A_Enable_Register]	= { 0x192, 2 },
 	[Second_IRQ_A_Enable_Register]	= { 0, 0 }, /* E-Series only */
 	[Interrupt_B_Enable_Register]	= { 0x196, 2 },
@@ -1612,8 +1612,8 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	ni_release_ai_mite_channel(dev);
 	/* ai configuration */
-	ni_stc_writew(dev, AI_Configuration_Start | AI_Reset,
-		      Joint_Reset_Register);
+	ni_stc_writew(dev, NISTC_RESET_AI_CFG_START | NISTC_RESET_AI,
+		      NISTC_RESET_REG);
 
 	ni_set_bits(dev, Interrupt_A_Enable_Register,
 		    AI_SC_TC_Interrupt_Enable | AI_START1_Interrupt_Enable |
@@ -1678,7 +1678,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* clear interrupts */
 	ni_stc_writew(dev, NISTC_INTA_ACK_AI_ALL, NISTC_INTA_ACK_REG);
 
-	ni_stc_writew(dev, AI_Configuration_End, Joint_Reset_Register);
+	ni_stc_writew(dev, NISTC_RESET_AI_CFG_END, NISTC_RESET_REG);
 
 	return 0;
 }
@@ -2259,7 +2259,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_load_channelgain_list(dev, s, cmd->chanlist_len, cmd->chanlist);
 
 	/* start configuration */
-	ni_stc_writew(dev, AI_Configuration_Start, Joint_Reset_Register);
+	ni_stc_writew(dev, NISTC_RESET_AI_CFG_START, NISTC_RESET_REG);
 
 	/* disable analog triggering for now, since it
 	 * interferes with the use of pfi0 */
@@ -2484,7 +2484,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* end configuration */
-	ni_stc_writew(dev, AI_Configuration_End, Joint_Reset_Register);
+	ni_stc_writew(dev, NISTC_RESET_AI_CFG_END, NISTC_RESET_REG);
 
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
@@ -2909,7 +2909,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EIO;
 	}
 
-	ni_stc_writew(dev, AO_Configuration_Start, Joint_Reset_Register);
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
 
 	ni_stc_writew(dev, NISTC_AO_CMD1_DISARM, NISTC_AO_CMD1_REG);
 
@@ -3092,7 +3092,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  enable sending of ao dma requests */
 	ni_stc_writew(dev, NISTC_AO_START_AOFREQ_ENA, NISTC_AO_START_SEL_REG);
 
-	ni_stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		ni_stc_writew(dev, NISTC_INTB_ACK_AO_BC_TC,
@@ -3195,7 +3195,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	ni_release_ao_mite_channel(dev);
 
-	ni_stc_writew(dev, AO_Configuration_Start, Joint_Reset_Register);
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);
 	ni_stc_writew(dev, NISTC_AO_CMD1_DISARM, NISTC_AO_CMD1_REG);
 	ni_set_bits(dev, Interrupt_B_Enable_Register, ~0, 0);
 	ni_stc_writew(dev, AO_BC_Source_Select, AO_Personal_Register);
@@ -3229,7 +3229,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_ao_win_outw(dev, immediate_bits, AO_Immediate_671x);
 		ni_ao_win_outw(dev, CLEAR_WG, AO_Misc_611x);
 	}
-	ni_stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);
+	ni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);
 
 	return 0;
 }
@@ -3733,7 +3733,7 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G0_GATE2]	= { 0x1b4, 2 },	/* M-Series only */
 	[NITIO_G1_GATE2]	= { 0x1b6, 2 },	/* M-Series only */
 	[NITIO_G01_STATUS]	= { G_Status_Register, 2 },
-	[NITIO_G01_RESET]	= { Joint_Reset_Register, 2 },
+	[NITIO_G01_RESET]	= { NISTC_RESET_REG, 2 },
 	[NITIO_G01_STATUS1]	= { Joint_Status_1_Register, 2 },
 	[NITIO_G01_STATUS2]	= { Joint_Status_2_Register, 2 },
 	[NITIO_G0_DMA_CFG]	= { 0x1b8, 2 },	/* M-Series only */
@@ -3771,8 +3771,6 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
 	unsigned int stc_register = ni_gpct_to_stc_register(dev, reg);
-	/* bits in the join reset register which are relevant to counters */
-	static const unsigned gpct_joint_reset_mask = G0_Reset | G1_Reset;
 	static const unsigned gpct_interrupt_a_enable_mask =
 	    G0_Gate_Interrupt_Enable | G0_TC_Interrupt_Enable;
 	static const unsigned gpct_interrupt_b_enable_mask =
@@ -3814,7 +3812,7 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 				gpct_interrupt_b_enable_mask, bits);
 		break;
 	case NITIO_G01_RESET:
-		BUG_ON(bits & ~gpct_joint_reset_mask);
+		BUG_ON(bits & ~(NISTC_RESET_G0 | NISTC_RESET_G1));
 		/* fall-through */
 	default:
 		ni_stc_writew(dev, bits, stc_register);

commit 72bca4f5e2c724120c1aa319f1b3042e3691d6ac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:24 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_Mode_3_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2c85b5715b05..a417ab405a3d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -364,7 +364,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AO_TRIG_SEL_REG]		= { 0x186, 2 },
 	[NISTC_G0_AUTOINC_REG]		= { 0x188, 2 },
 	[NISTC_G1_AUTOINC_REG]		= { 0x18a, 2 },
-	[AO_Mode_3_Register]		= { 0x18c, 2 },
+	[NISTC_AO_MODE3_REG]		= { 0x18c, 2 },
 	[Joint_Reset_Register]		= { 0x190, 2 },
 	[Interrupt_A_Enable_Register]	= { 0x192, 2 },
 	[Second_IRQ_A_Enable_Register]	= { 0, 0 }, /* E-Series only */
@@ -2857,9 +2857,9 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 	interrupt_b_bits |= AO_FIFO_Interrupt_Enable;
 #endif
 
-	ni_stc_writew(dev, devpriv->ao_mode3 | AO_Not_An_UPDATE,
-		      AO_Mode_3_Register);
-	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
+	ni_stc_writew(dev, devpriv->ao_mode3 | NISTC_AO_MODE3_NOT_AN_UPDATE,
+		      NISTC_AO_MODE3_REG);
+	ni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);
 	/* wait for DACs to be loaded */
 	for (i = 0; i < timeout; i++) {
 		udelay(1);
@@ -2967,8 +2967,8 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ao_trigger_select = val;
 	ni_stc_writew(dev, devpriv->ao_trigger_select, NISTC_AO_TRIG_SEL_REG);
 
-	devpriv->ao_mode3 &= ~AO_Trigger_Length;
-	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
+	devpriv->ao_mode3 &= ~NISTC_AO_MODE3_TRIG_LEN;
+	ni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);
 
 	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
 	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_BC_INIT_LOAD_SRC;
@@ -3064,8 +3064,8 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			   NISTC_AO_CMD1_DAC0_UPDATE_MODE,
 		      NISTC_AO_CMD1_REG);
 
-	devpriv->ao_mode3 |= AO_Stop_On_Overrun_Error;
-	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
+	devpriv->ao_mode3 |= NISTC_AO_MODE3_STOP_ON_OVERRUN_ERR;
+	ni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);
 
 	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_FIFO_MODE_MASK;
 #ifdef PCIDMA
@@ -3213,10 +3213,10 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ao_mode2 = 0;
 	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
 	if (devpriv->is_m_series)
-		devpriv->ao_mode3 = AO_Last_Gate_Disable;
+		devpriv->ao_mode3 = NISTC_AO_MODE3_LAST_GATE_DISABLE;
 	else
 		devpriv->ao_mode3 = 0;
-	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
+	ni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);
 	devpriv->ao_trigger_select = 0;
 	ni_stc_writew(dev, devpriv->ao_trigger_select,
 		      NISTC_AO_TRIG_SEL_REG);

commit 38aba4c99498feec862f4b1b588fb6719184b94c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:23 2015 -0700

    staging: comedi: ni_stc.h: tidy up G_Autoincrement_Register
    
    Rename the CamelCase and define the G0 and G1 registers to add clarity
    to the mio_regmap tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0634babd2cf2..2c85b5715b05 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -362,8 +362,8 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AI_DIV_LOADA_REG]	= { 0x180, 4 },
 	[NISTC_AO_START_SEL_REG]	= { 0x184, 2 },
 	[NISTC_AO_TRIG_SEL_REG]		= { 0x186, 2 },
-	[G_Autoincrement_Register(0)]	= { 0x188, 2 },
-	[G_Autoincrement_Register(1)]	= { 0x18a, 2 },
+	[NISTC_G0_AUTOINC_REG]		= { 0x188, 2 },
+	[NISTC_G1_AUTOINC_REG]		= { 0x18a, 2 },
 	[AO_Mode_3_Register]		= { 0x18c, 2 },
 	[Joint_Reset_Register]		= { 0x190, 2 },
 	[Interrupt_A_Enable_Register]	= { 0x192, 2 },
@@ -3712,8 +3712,8 @@ static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
-	[NITIO_G0_AUTO_INC]	= { G_Autoincrement_Register(0), 2 },
-	[NITIO_G1_AUTO_INC]	= { G_Autoincrement_Register(1), 2 },
+	[NITIO_G0_AUTO_INC]	= { NISTC_G0_AUTOINC_REG, 2 },
+	[NITIO_G1_AUTO_INC]	= { NISTC_G1_AUTOINC_REG, 2 },
 	[NITIO_G0_CMD]		= { NISTC_G0_CMD_REG, 2 },
 	[NITIO_G1_CMD]		= { NISTC_G1_CMD_REG, 2 },
 	[NITIO_G0_HW_SAVE]	= { G_HW_Save_Register(0), 4 },

commit f21844d33b6de37aa105de3e2e50dd944dd3d2b0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:22 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_Trigger_Select_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Tidy up the ni_ao_cmd() by using a local var to mask/set the bits then
    programming the register in the common code path.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2522bab8ca13..0634babd2cf2 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -361,7 +361,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AI_TRIG_SEL_REG]		= { 0x17e, 2 },
 	[NISTC_AI_DIV_LOADA_REG]	= { 0x180, 4 },
 	[NISTC_AO_START_SEL_REG]	= { 0x184, 2 },
-	[AO_Trigger_Select_Register]	= { 0x186, 2 },
+	[NISTC_AO_TRIG_SEL_REG]		= { 0x186, 2 },
 	[G_Autoincrement_Register(0)]	= { 0x188, 2 },
 	[G_Autoincrement_Register(1)]	= { 0x18a, 2 },
 	[AO_Mode_3_Register]		= { 0x18c, 2 },
@@ -2902,6 +2902,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int bits;
 	int i;
 	unsigned trigvar;
+	unsigned val;
 
 	if (dev->irq == 0) {
 		dev_err(dev->class_dev, "cannot run command without an irq\n");
@@ -2936,29 +2937,36 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ao_mode1 |= NISTC_AO_MODE1_TRIGGER_ONCE;
 	}
 	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
+
+	val = devpriv->ao_trigger_select;
 	switch (cmd->start_src) {
 	case TRIG_INT:
 	case TRIG_NOW:
-		devpriv->ao_trigger_select &=
-		    ~(AO_START1_Polarity | AO_START1_Select(-1));
-		devpriv->ao_trigger_select |= AO_START1_Edge | AO_START1_Sync;
-		ni_stc_writew(dev, devpriv->ao_trigger_select,
-			      AO_Trigger_Select_Register);
+		val &= ~(NISTC_AO_TRIG_START1_POLARITY |
+			 NISTC_AO_TRIG_START1_SEL_MASK);
+		val |= NISTC_AO_TRIG_START1_EDGE |
+		       NISTC_AO_TRIG_START1_SYNC;
 		break;
 	case TRIG_EXT:
-		devpriv->ao_trigger_select =
-		    AO_START1_Select(CR_CHAN(cmd->start_arg) + 1);
-		if (cmd->start_arg & CR_INVERT)
-			devpriv->ao_trigger_select |= AO_START1_Polarity;	/*  0=active high, 1=active low. see daq-stc 3-24 (p186) */
-		if (cmd->start_arg & CR_EDGE)
-			devpriv->ao_trigger_select |= AO_START1_Edge;	/*  0=edge detection disabled, 1=enabled */
+		val = NISTC_AO_TRIG_START1_SEL(CR_CHAN(cmd->start_arg) + 1);
+		if (cmd->start_arg & CR_INVERT) {
+			/* 0=active high, 1=active low. see daq-stc 3-24 (p186) */
+			val |= NISTC_AO_TRIG_START1_POLARITY;
+		}
+		if (cmd->start_arg & CR_EDGE) {
+			/* 0=edge detection disabled, 1=enabled */
+			val |= NISTC_AO_TRIG_START1_EDGE;
+		}
 		ni_stc_writew(dev, devpriv->ao_trigger_select,
-			      AO_Trigger_Select_Register);
+			      NISTC_AO_TRIG_SEL_REG);
 		break;
 	default:
 		BUG();
 		break;
 	}
+	devpriv->ao_trigger_select = val;
+	ni_stc_writew(dev, devpriv->ao_trigger_select, NISTC_AO_TRIG_SEL_REG);
+
 	devpriv->ao_mode3 &= ~AO_Trigger_Length;
 	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 
@@ -3211,7 +3219,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 	devpriv->ao_trigger_select = 0;
 	ni_stc_writew(dev, devpriv->ao_trigger_select,
-		      AO_Trigger_Select_Register);
+		      NISTC_AO_TRIG_SEL_REG);
 	if (devpriv->is_6xxx) {
 		unsigned immediate_bits = 0;
 		unsigned i;

commit 2b6285dab7ca8ac069f4087172ebb0c1aa908777
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:21 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_Start_Select_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ba1c991408d3..2522bab8ca13 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -360,7 +360,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AI_START_STOP_REG]	= { 0x17c, 2 },
 	[NISTC_AI_TRIG_SEL_REG]		= { 0x17e, 2 },
 	[NISTC_AI_DIV_LOADA_REG]	= { 0x180, 4 },
-	[AO_Start_Select_Register]	= { 0x184, 2 },
+	[NISTC_AO_START_SEL_REG]	= { 0x184, 2 },
 	[AO_Trigger_Select_Register]	= { 0x186, 2 },
 	[G_Autoincrement_Register(0)]	= { 0x188, 2 },
 	[G_Autoincrement_Register(1)]	= { 0x18a, 2 },
@@ -3082,7 +3082,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 #endif
 	ni_stc_writew(dev, bits, AO_Personal_Register);
 	/*  enable sending of ao dma requests */
-	ni_stc_writew(dev, AO_AOFREQ_Enable, AO_Start_Select_Register);
+	ni_stc_writew(dev, NISTC_AO_START_AOFREQ_ENA, NISTC_AO_START_SEL_REG);
 
 	ni_stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);
 
@@ -3195,7 +3195,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_stc_writew(dev, AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
 		      AO_TMRDACWR_Pulse_Width, AO_Personal_Register);
 	ni_stc_writew(dev, 0, AO_Output_Control_Register);
-	ni_stc_writew(dev, 0, AO_Start_Select_Register);
+	ni_stc_writew(dev, 0, NISTC_AO_START_SEL_REG);
 	devpriv->ao_cmd1 = 0;
 	ni_stc_writew(dev, devpriv->ao_cmd1, NISTC_AO_CMD1_REG);
 	devpriv->ao_cmd2 = 0;

commit af5102a77e6ef0d40611f5255faf3cd860180c29
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:20 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_DIV_Load_A_Register
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 880c50f8ec92..ba1c991408d3 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -359,7 +359,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_ATRIG_ETC_REG]		= { 0x17a, 2 },
 	[NISTC_AI_START_STOP_REG]	= { 0x17c, 2 },
 	[NISTC_AI_TRIG_SEL_REG]		= { 0x17e, 2 },
-	[AI_DIV_Load_A_Register]	= { 0x180, 4 },
+	[NISTC_AI_DIV_LOADA_REG]	= { 0x180, 4 },
 	[AO_Start_Select_Register]	= { 0x184, 2 },
 	[AO_Trigger_Select_Register]	= { 0x186, 2 },
 	[G_Autoincrement_Register(0)]	= { 0x188, 2 },

commit f878071a44d61ac52765c7b0c23ddb1170044174
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:19 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_Trigger_Select_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Tidy up ni_ai_cmd() by using a local var to set the common bits and
    programming the register in the common code path.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e2e3535aa77a..880c50f8ec92 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -358,7 +358,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AI_OUT_CTRL_REG]		= { 0x178, 2 },
 	[NISTC_ATRIG_ETC_REG]		= { 0x17a, 2 },
 	[NISTC_AI_START_STOP_REG]	= { 0x17c, 2 },
-	[AI_Trigger_Select_Register]	= { 0x17e, 2 },
+	[NISTC_AI_TRIG_SEL_REG]		= { 0x17e, 2 },
 	[AI_DIV_Load_A_Register]	= { 0x180, 4 },
 	[AO_Start_Select_Register]	= { 0x184, 2 },
 	[AO_Trigger_Select_Register]	= { 0x186, 2 },
@@ -2248,6 +2248,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int start_stop_select = 0;
 	unsigned int stop_count;
 	int interrupt_a_enable = 0;
+	unsigned ai_trig;
 
 	if (dev->irq == 0) {
 		dev_err(dev->class_dev, "cannot run command without an irq\n");
@@ -2265,29 +2266,25 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->an_trig_etc_reg &= ~NISTC_ATRIG_ETC_ENA;
 	ni_stc_writew(dev, devpriv->an_trig_etc_reg, NISTC_ATRIG_ETC_REG);
 
+	ai_trig = NISTC_AI_TRIG_START2_SEL(0) | NISTC_AI_TRIG_START1_SYNC;
 	switch (cmd->start_src) {
 	case TRIG_INT:
 	case TRIG_NOW:
-		ni_stc_writew(dev,
-			      AI_START2_Select(0) |
-			      AI_START1_Sync | AI_START1_Edge |
-			      AI_START1_Select(0),
-			      AI_Trigger_Select_Register);
+		ai_trig |= NISTC_AI_TRIG_START1_EDGE |
+			   NISTC_AI_TRIG_START1_SEL(0),
+			   NISTC_AI_TRIG_SEL_REG;
 		break;
 	case TRIG_EXT:
-		{
-			int chan = CR_CHAN(cmd->start_arg);
-			unsigned int bits = AI_START2_Select(0) |
-			    AI_START1_Sync | AI_START1_Select(chan + 1);
-
-			if (cmd->start_arg & CR_INVERT)
-				bits |= AI_START1_Polarity;
-			if (cmd->start_arg & CR_EDGE)
-				bits |= AI_START1_Edge;
-			ni_stc_writew(dev, bits, AI_Trigger_Select_Register);
-			break;
-		}
+		ai_trig |= NISTC_AI_TRIG_START1_SEL(CR_CHAN(cmd->start_arg) +
+						    1);
+
+		if (cmd->start_arg & CR_INVERT)
+			ai_trig |= NISTC_AI_TRIG_START1_POLARITY;
+		if (cmd->start_arg & CR_EDGE)
+			ai_trig |= NISTC_AI_TRIG_START1_EDGE;
+		break;
 	}
+	ni_stc_writew(dev, ai_trig, NISTC_AI_TRIG_SEL_REG);
 
 	mode2 &= ~NISTC_AI_MODE2_PRE_TRIGGER;
 	mode2 &= ~NISTC_AI_MODE2_SC_INIT_LOAD_SRC;

commit 3e9088929f06a42f2ab4085562caefbd36a8324f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:18 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_START_STOP_Select_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 265f9baffe18..e2e3535aa77a 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -357,7 +357,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_INT_CTRL_REG]		= { 0x176, 2 },
 	[NISTC_AI_OUT_CTRL_REG]		= { 0x178, 2 },
 	[NISTC_ATRIG_ETC_REG]		= { 0x17a, 2 },
-	[AI_START_STOP_Select_Register]	= { 0x17c, 2 },
+	[NISTC_AI_START_STOP_REG]	= { 0x17c, 2 },
 	[AI_Trigger_Select_Register]	= { 0x17e, 2 },
 	[AI_DIV_Load_A_Register]	= { 0x180, 4 },
 	[AO_Start_Select_Register]	= { 0x184, 2 },
@@ -2295,13 +2295,15 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);
 
 	if (cmd->chanlist_len == 1 || devpriv->is_611x || devpriv->is_6143) {
-		start_stop_select |= AI_STOP_Polarity;
-		start_stop_select |= AI_STOP_Select(31);	/*  logic low */
-		start_stop_select |= AI_STOP_Sync;
+		/* logic low */
+		start_stop_select |= NISTC_AI_STOP_POLARITY |
+				     NISTC_AI_STOP_SEL(31) |
+				     NISTC_AI_STOP_SYNC;
 	} else {
-		start_stop_select |= AI_STOP_Select(19);	/*  ai configuration memory */
+		/*  ai configuration memory */
+		start_stop_select |= NISTC_AI_STOP_SEL(19);
 	}
-	ni_stc_writew(dev, start_stop_select, AI_START_STOP_Select_Register);
+	ni_stc_writew(dev, start_stop_select, NISTC_AI_START_STOP_REG);
 
 	devpriv->ai_cmd2 = 0;
 	switch (cmd->stop_src) {
@@ -2327,8 +2329,8 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			interrupt_a_enable |= AI_STOP_Interrupt_Enable;
 			/*  this is required to get the last sample for chanlist_len > 1, not sure why */
 			if (cmd->chanlist_len > 1)
-				start_stop_select |=
-				    AI_STOP_Polarity | AI_STOP_Edge;
+				start_stop_select |= NISTC_AI_STOP_POLARITY |
+						     NISTC_AI_STOP_EDGE;
 		}
 		break;
 	case TRIG_NONE:
@@ -2348,22 +2350,21 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
 		/*
-		   stop bits for non 611x boards
-		   AI_SI_Special_Trigger_Delay=0
-		   NISTC_AI_MODE2_PRE_TRIGGER=0
-		   AI_START_STOP_Select_Register:
-		   AI_START_Polarity=0 (?)      rising edge
-		   AI_START_Edge=1              edge triggered
-		   AI_START_Sync=1 (?)
-		   AI_START_Select=0            SI_TC
-		   AI_STOP_Polarity=0           rising edge
-		   AI_STOP_Edge=0               level
-		   AI_STOP_Sync=1
-		   AI_STOP_Select=19            external pin (configuration mem)
+		 * stop bits for non 611x boards
+		 * AI_SI_Special_Trigger_Delay=0
+		 * NISTC_AI_MODE2_PRE_TRIGGER=0
+		 * NISTC_AI_START_STOP_REG:
+		 * NISTC_AI_START_POLARITY=0	(?) rising edge
+		 * NISTC_AI_START_EDGE=1	edge triggered
+		 * NISTC_AI_START_SYNC=1	(?)
+		 * NISTC_AI_START_SEL=0		SI_TC
+		 * NISTC_AI_STOP_POLARITY=0	rising edge
+		 * NISTC_AI_STOP_EDGE=0		level
+		 * NISTC_AI_STOP_SYNC=1
+		 * NISTC_AI_STOP_SEL=19		external pin (configuration mem)
 		 */
-		start_stop_select |= AI_START_Edge | AI_START_Sync;
-		ni_stc_writew(dev, start_stop_select,
-			      AI_START_STOP_Select_Register);
+		start_stop_select |= NISTC_AI_START_EDGE | NISTC_AI_START_SYNC;
+		ni_stc_writew(dev, start_stop_select, NISTC_AI_START_STOP_REG);
 
 		mode2 &= ~NISTC_AI_MODE2_SI_INIT_LOAD_SRC;	/* A */
 		mode2 |= NISTC_AI_MODE2_SI_RELOAD_MODE(0);
@@ -2378,18 +2379,16 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	case TRIG_EXT:
 		if (cmd->scan_begin_arg & CR_EDGE)
-			start_stop_select |= AI_START_Edge;
-		/* AI_START_Polarity==1 is falling edge */
-		if (cmd->scan_begin_arg & CR_INVERT)
-			start_stop_select |= AI_START_Polarity;
+			start_stop_select |= NISTC_AI_START_EDGE;
+		if (cmd->scan_begin_arg & CR_INVERT)	/* falling edge */
+			start_stop_select |= NISTC_AI_START_POLARITY;
 		if (cmd->scan_begin_src != cmd->convert_src ||
 		    (cmd->scan_begin_arg & ~CR_EDGE) !=
 		    (cmd->convert_arg & ~CR_EDGE))
-			start_stop_select |= AI_START_Sync;
+			start_stop_select |= NISTC_AI_START_SYNC;
 		start_stop_select |=
-		    AI_START_Select(1 + CR_CHAN(cmd->scan_begin_arg));
-		ni_stc_writew(dev, start_stop_select,
-			      AI_START_STOP_Select_Register);
+		    NISTC_AI_START_SEL(1 + CR_CHAN(cmd->scan_begin_arg));
+		ni_stc_writew(dev, start_stop_select, NISTC_AI_START_STOP_REG);
 		break;
 	}
 

commit 27cf6c02abc6788a71c1e939fdab1418eb6c3bcc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:17 2015 -0700

    staging: comedi: ni_stc.h: tidy up Analog_Trigger_Etc_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 20557b5be996..265f9baffe18 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -356,7 +356,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_RTSI_TRIG_DIR_REG]	= { 0x174, 2 },
 	[NISTC_INT_CTRL_REG]		= { 0x176, 2 },
 	[NISTC_AI_OUT_CTRL_REG]		= { 0x178, 2 },
-	[Analog_Trigger_Etc_Register]	= { 0x17a, 2 },
+	[NISTC_ATRIG_ETC_REG]		= { 0x17a, 2 },
 	[AI_START_STOP_Select_Register]	= { 0x17c, 2 },
 	[AI_Trigger_Select_Register]	= { 0x17e, 2 },
 	[AI_DIV_Load_A_Register]	= { 0x180, 4 },
@@ -2262,9 +2262,8 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* disable analog triggering for now, since it
 	 * interferes with the use of pfi0 */
-	devpriv->an_trig_etc_reg &= ~Analog_Trigger_Enable;
-	ni_stc_writew(dev, devpriv->an_trig_etc_reg,
-		      Analog_Trigger_Etc_Register);
+	devpriv->an_trig_etc_reg &= ~NISTC_ATRIG_ETC_ENA;
+	ni_stc_writew(dev, devpriv->an_trig_etc_reg, NISTC_ATRIG_ETC_REG);
 
 	switch (cmd->start_src) {
 	case TRIG_INT:

commit aa9d73ba831eef18624cb7b8288987b3bfd4dac8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:16 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_Output_Control_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Tidy up the programming of this register un ni_ai_reset() by using a
    local variable to set the common bits then writing the register in the
    common code path.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index fcb8362fda80..20557b5be996 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -355,7 +355,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_IO_BIDIR_PIN_REG]	= { 0x172, 2 },
 	[NISTC_RTSI_TRIG_DIR_REG]	= { 0x174, 2 },
 	[NISTC_INT_CTRL_REG]		= { 0x176, 2 },
-	[AI_Output_Control_Register]	= { 0x178, 2 },
+	[NISTC_AI_OUT_CTRL_REG]		= { 0x178, 2 },
 	[Analog_Trigger_Etc_Register]	= { 0x17a, 2 },
 	[AI_START_STOP_Select_Register]	= { 0x17c, 2 },
 	[AI_Trigger_Select_Register]	= { 0x17e, 2 },
@@ -1608,6 +1608,7 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct ni_private *devpriv = dev->private;
+	unsigned ai_out_ctrl;
 
 	ni_release_ai_mite_channel(dev);
 	/* ai configuration */
@@ -1633,65 +1634,45 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_stc_writew(dev, 0, NISTC_AI_MODE2_REG);
 	/* generate FIFO interrupts on non-empty */
 	ni_stc_writew(dev, (0 << 6) | 0x0000, AI_Mode_3_Register);
+
+	ai_out_ctrl = NISTC_AI_OUT_CTRL_SCAN_IN_PROG_SEL(3) |
+		      NISTC_AI_OUT_CTRL_EXTMUX_CLK_SEL(0) |
+		      NISTC_AI_OUT_CTRL_LOCALMUX_CLK_SEL(2) |
+		      NISTC_AI_OUT_CTRL_SC_TC_SEL(3);
 	if (devpriv->is_611x) {
 		ni_stc_writew(dev,
 			      AI_SHIFTIN_Pulse_Width |
 			      AI_SOC_Polarity |
 			      AI_LOCALMUX_CLK_Pulse_Width,
 			      AI_Personal_Register);
-		ni_stc_writew(dev,
-			      AI_SCAN_IN_PROG_Output_Select(3) |
-			      AI_EXTMUX_CLK_Output_Select(0) |
-			      AI_LOCALMUX_CLK_Output_Select(2) |
-			      AI_SC_TC_Output_Select(3) |
-			      AI_CONVERT_Output_Select
-			      (AI_CONVERT_Output_Enable_High),
-			      AI_Output_Control_Register);
+		ai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_HIGH;
 	} else if (devpriv->is_6143) {
 		ni_stc_writew(dev, AI_SHIFTIN_Pulse_Width |
 				   AI_SOC_Polarity |
 				   AI_LOCALMUX_CLK_Pulse_Width,
 			      AI_Personal_Register);
-		ni_stc_writew(dev,
-			      AI_SCAN_IN_PROG_Output_Select(3) |
-			      AI_EXTMUX_CLK_Output_Select(0) |
-			      AI_LOCALMUX_CLK_Output_Select(2) |
-			      AI_SC_TC_Output_Select(3) |
-			      AI_CONVERT_Output_Select
-			      (AI_CONVERT_Output_Enable_Low),
-			      AI_Output_Control_Register);
+		ai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_LOW;
 	} else {
-		unsigned ai_output_control_bits;
-
 		ni_stc_writew(dev,
 			      AI_SHIFTIN_Pulse_Width |
 			      AI_SOC_Polarity |
 			      AI_CONVERT_Pulse_Width |
 			      AI_LOCALMUX_CLK_Pulse_Width,
 			      AI_Personal_Register);
-		ai_output_control_bits =
-		    AI_SCAN_IN_PROG_Output_Select(3) |
-		    AI_EXTMUX_CLK_Output_Select(0) |
-		    AI_LOCALMUX_CLK_Output_Select(2) |
-		    AI_SC_TC_Output_Select(3);
 		if (devpriv->is_622x)
-			ai_output_control_bits |=
-			    AI_CONVERT_Output_Select
-			    (AI_CONVERT_Output_Enable_High);
+			ai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_HIGH;
 		else
-			ai_output_control_bits |=
-			    AI_CONVERT_Output_Select
-			    (AI_CONVERT_Output_Enable_Low);
-		ni_stc_writew(dev, ai_output_control_bits,
-			      AI_Output_Control_Register);
+			ai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_LOW;
 	}
+	ni_stc_writew(dev, ai_out_ctrl, NISTC_AI_OUT_CTRL_REG);
+
 	/* the following registers should not be changed, because there
 	 * are no backup registers in devpriv.  If you want to change
 	 * any of these, add a backup register and other appropriate code:
 	 *      NISTC_AI_MODE1_REG
 	 *      AI_Mode_3_Register
 	 *      AI_Personal_Register
-	 *      AI_Output_Control_Register
+	 *      NISTC_AI_OUT_CTRL_REG
 	 */
 
 	/* clear interrupts */

commit d8f62c463867293ed37fd9ac25dfc2338dc01594
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:15 2015 -0700

    staging: comedi: ni_stc.h: tidy up Interrupt_Control_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5bdfb5f060c6..fcb8362fda80 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -354,7 +354,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_CLK_FOUT_REG]		= { 0x170, 2 },
 	[NISTC_IO_BIDIR_PIN_REG]	= { 0x172, 2 },
 	[NISTC_RTSI_TRIG_DIR_REG]	= { 0x174, 2 },
-	[Interrupt_Control_Register]	= { 0x176, 2 },
+	[NISTC_INT_CTRL_REG]		= { 0x176, 2 },
 	[AI_Output_Control_Register]	= { 0x178, 2 },
 	[Analog_Trigger_Etc_Register]	= { 0x17a, 2 },
 	[AI_START_STOP_Select_Register]	= { 0x17c, 2 },
@@ -5389,12 +5389,13 @@ static int ni_E_init(struct comedi_device *dev,
 
 	if (dev->irq) {
 		ni_stc_writew(dev,
-			      (irq_polarity ? Interrupt_Output_Polarity : 0) |
-			      (Interrupt_Output_On_3_Pins & 0) |
-			      Interrupt_A_Enable | Interrupt_B_Enable |
-			      Interrupt_A_Output_Select(interrupt_pin) |
-			      Interrupt_B_Output_Select(interrupt_pin),
-			      Interrupt_Control_Register);
+			      (irq_polarity ? NISTC_INT_CTRL_INT_POL : 0) |
+			      (NISTC_INT_CTRL_3PIN_INT & 0) |
+			      NISTC_INT_CTRL_INTA_ENA |
+			      NISTC_INT_CTRL_INTB_ENA |
+			      NISTC_INT_CTRL_INTA_SEL(interrupt_pin) |
+			      NISTC_INT_CTRL_INTB_SEL(interrupt_pin),
+			      NISTC_INT_CTRL_REG);
 	}
 
 	/* DMA setup */

commit a4f18b1c40875d199a1f7a77f08642d38c4e6b21
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:14 2015 -0700

    staging: comedi: ni_stc.h: tidy up RTSI_Trig_Direction_Register and bits
    
    Rename the CamelCase and convert the enum and inline function into defines.
    Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index fb1df9fc9d38..5bdfb5f060c6 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -60,7 +60,6 @@
 
 /* A timeout count */
 #define NI_TIMEOUT 1000
-static const unsigned old_RTSI_clock_channel = 7;
 
 /* Note: this table must match the ai_gain_* definitions */
 static const short ni_gainlkup[][16] = {
@@ -354,7 +353,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AO_UC_LOADB_REG]		= { 0x164, 4 },
 	[NISTC_CLK_FOUT_REG]		= { 0x170, 2 },
 	[NISTC_IO_BIDIR_PIN_REG]	= { 0x172, 2 },
-	[RTSI_Trig_Direction_Register]	= { 0x174, 2 },
+	[NISTC_RTSI_TRIG_DIR_REG]	= { 0x174, 2 },
 	[Interrupt_Control_Register]	= { 0x176, 2 },
 	[AI_Output_Control_Register]	= { 0x178, 2 },
 	[Analog_Trigger_Etc_Register]	= { 0x17a, 2 },
@@ -4680,9 +4679,9 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 			__func__, min_period_ns, max_period_ns);
 		return -EINVAL;
 	}
-	devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
+	devpriv->rtsi_trig_direction_reg &= ~NISTC_RTSI_TRIG_USE_CLK;
 	ni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-		      RTSI_Trig_Direction_Register);
+		      NISTC_RTSI_TRIG_DIR_REG);
 	pll_control_bits = NI_M_PLL_CTRL_ENA | NI_M_PLL_CTRL_VCO_MODE_75_150MHZ;
 	devpriv->clock_and_fout2 |= NI_M_CLK_FOUT2_TIMEBASE1_PLL |
 				    NI_M_CLK_FOUT2_TIMEBASE3_PLL;
@@ -4744,9 +4743,9 @@ static int ni_set_master_clock(struct comedi_device *dev,
 	struct ni_private *devpriv = dev->private;
 
 	if (source == NI_MIO_INTERNAL_CLOCK) {
-		devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
+		devpriv->rtsi_trig_direction_reg &= ~NISTC_RTSI_TRIG_USE_CLK;
 		ni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-			      RTSI_Trig_Direction_Register);
+			      NISTC_RTSI_TRIG_DIR_REG);
 		devpriv->clock_ns = TIMEBASE_1_NS;
 		if (devpriv->is_m_series) {
 			devpriv->clock_and_fout2 &=
@@ -4764,10 +4763,10 @@ static int ni_set_master_clock(struct comedi_device *dev,
 		} else {
 			if (source == NI_MIO_RTSI_CLOCK) {
 				devpriv->rtsi_trig_direction_reg |=
-				    Use_RTSI_Clock_Bit;
+				    NISTC_RTSI_TRIG_USE_CLK;
 				ni_stc_writew(dev,
 					      devpriv->rtsi_trig_direction_reg,
-					      RTSI_Trig_Direction_Register);
+					      NISTC_RTSI_TRIG_DIR_REG);
 				if (period_ns == 0) {
 					dev_err(dev->class_dev,
 						"we don't handle an unspecified clock period correctly yet, returning error\n");
@@ -4783,26 +4782,19 @@ static int ni_set_master_clock(struct comedi_device *dev,
 	return 3;
 }
 
-static unsigned num_configurable_rtsi_channels(struct comedi_device *dev)
-{
-	struct ni_private *devpriv = dev->private;
-
-	return (devpriv->is_m_series) ? 8 : 7;
-}
-
 static int ni_valid_rtsi_output_source(struct comedi_device *dev,
 				       unsigned chan, unsigned source)
 {
 	struct ni_private *devpriv = dev->private;
 
-	if (chan >= num_configurable_rtsi_channels(dev)) {
-		if (chan == old_RTSI_clock_channel) {
+	if (chan >= NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series)) {
+		if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {
 			if (source == NI_RTSI_OUTPUT_RTSI_OSC)
 				return 1;
 
 			dev_err(dev->class_dev,
 				"%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards\n",
-				__func__, chan, old_RTSI_clock_channel);
+				__func__, chan, NISTC_RTSI_TRIG_OLD_CLK_CHAN);
 			return 0;
 		}
 		return 0;
@@ -4855,11 +4847,11 @@ static unsigned ni_get_rtsi_routing(struct comedi_device *dev, unsigned chan)
 	if (chan < 4) {
 		return RTSI_Trig_Output_Source(chan,
 					       devpriv->rtsi_trig_a_output_reg);
-	} else if (chan < num_configurable_rtsi_channels(dev)) {
+	} else if (chan < NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series)) {
 		return RTSI_Trig_Output_Source(chan,
 					       devpriv->rtsi_trig_b_output_reg);
 	} else {
-		if (chan == old_RTSI_clock_channel)
+		if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN)
 			return NI_RTSI_OUTPUT_RTSI_OSC;
 		dev_err(dev->class_dev, "bug! should never get here?\n");
 		return 0;
@@ -4873,42 +4865,43 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 {
 	struct ni_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int max_chan = NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series);
 
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
-		if (chan < num_configurable_rtsi_channels(dev)) {
+		if (chan < max_chan) {
 			devpriv->rtsi_trig_direction_reg |=
-			    RTSI_Output_Bit(chan, devpriv->is_m_series);
-		} else if (chan == old_RTSI_clock_channel) {
+			    NISTC_RTSI_TRIG_DIR(chan, devpriv->is_m_series);
+		} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {
 			devpriv->rtsi_trig_direction_reg |=
-			    Drive_RTSI_Clock_Bit;
+			    NISTC_RTSI_TRIG_DRV_CLK;
 		}
 		ni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-			      RTSI_Trig_Direction_Register);
+			      NISTC_RTSI_TRIG_DIR_REG);
 		break;
 	case INSN_CONFIG_DIO_INPUT:
-		if (chan < num_configurable_rtsi_channels(dev)) {
+		if (chan < max_chan) {
 			devpriv->rtsi_trig_direction_reg &=
-			    ~RTSI_Output_Bit(chan, devpriv->is_m_series);
-		} else if (chan == old_RTSI_clock_channel) {
+			    ~NISTC_RTSI_TRIG_DIR(chan, devpriv->is_m_series);
+		} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {
 			devpriv->rtsi_trig_direction_reg &=
-			    ~Drive_RTSI_Clock_Bit;
+			    ~NISTC_RTSI_TRIG_DRV_CLK;
 		}
 		ni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-			      RTSI_Trig_Direction_Register);
+			      NISTC_RTSI_TRIG_DIR_REG);
 		break;
 	case INSN_CONFIG_DIO_QUERY:
-		if (chan < num_configurable_rtsi_channels(dev)) {
+		if (chan < max_chan) {
 			data[1] =
 			    (devpriv->rtsi_trig_direction_reg &
-			     RTSI_Output_Bit(chan, devpriv->is_m_series))
+			     NISTC_RTSI_TRIG_DIR(chan, devpriv->is_m_series))
 				? INSN_CONFIG_DIO_OUTPUT
 				: INSN_CONFIG_DIO_INPUT;
-		} else if (chan == old_RTSI_clock_channel) {
-			data[1] =
-			    (devpriv->rtsi_trig_direction_reg &
-			     Drive_RTSI_Clock_Bit)
-			    ? INSN_CONFIG_DIO_OUTPUT : INSN_CONFIG_DIO_INPUT;
+		} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {
+			data[1] = (devpriv->rtsi_trig_direction_reg &
+				   NISTC_RTSI_TRIG_DRV_CLK)
+				  ? INSN_CONFIG_DIO_OUTPUT
+				  : INSN_CONFIG_DIO_INPUT;
 		}
 		return 2;
 	case INSN_CONFIG_SET_CLOCK_SRC:

commit 5ecadf8c4fb9a634dd20af2d14b588254f336a88
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:12 2015 -0700

    staging: comedi: ni_stc.h: tidy up IO_Bidirection_Pin_Register
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 41eae5c99fee..fb1df9fc9d38 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -353,7 +353,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AO_UC_LOADA_REG]		= { 0x160, 4 },
 	[NISTC_AO_UC_LOADB_REG]		= { 0x164, 4 },
 	[NISTC_CLK_FOUT_REG]		= { 0x170, 2 },
-	[IO_Bidirection_Pin_Register]	= { 0x172, 2 },
+	[NISTC_IO_BIDIR_PIN_REG]	= { 0x172, 2 },
 	[RTSI_Trig_Direction_Register]	= { 0x174, 2 },
 	[Interrupt_Control_Register]	= { 0x176, 2 },
 	[AI_Output_Control_Register]	= { 0x178, 2 },
@@ -542,7 +542,7 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 		devpriv->int_b_enable_reg |= bit_values & bit_mask;
 		ni_stc_writew(dev, devpriv->int_b_enable_reg, reg);
 		break;
-	case IO_Bidirection_Pin_Register:
+	case NISTC_IO_BIDIR_PIN_REG:
 		devpriv->io_bidirection_pin_reg &= ~bit_mask;
 		devpriv->io_bidirection_pin_reg |= bit_values & bit_mask;
 		ni_stc_writew(dev, devpriv->io_bidirection_pin_reg, reg);
@@ -4434,10 +4434,10 @@ static int ni_pfi_insn_config(struct comedi_device *dev,
 
 	switch (data[0]) {
 	case COMEDI_OUTPUT:
-		ni_set_bits(dev, IO_Bidirection_Pin_Register, 1 << chan, 1);
+		ni_set_bits(dev, NISTC_IO_BIDIR_PIN_REG, 1 << chan, 1);
 		break;
 	case COMEDI_INPUT:
-		ni_set_bits(dev, IO_Bidirection_Pin_Register, 1 << chan, 0);
+		ni_set_bits(dev, NISTC_IO_BIDIR_PIN_REG, 1 << chan, 0);
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
@@ -5303,7 +5303,7 @@ static int ni_E_init(struct comedi_device *dev,
 	}
 	s->insn_config	= ni_pfi_insn_config;
 
-	ni_set_bits(dev, IO_Bidirection_Pin_Register, ~0, 0);
+	ni_set_bits(dev, NISTC_IO_BIDIR_PIN_REG, ~0, 0);
 
 	/* cs5529 calibration adc */
 	s = &dev->subdevices[NI_CS5529_CALIBRATION_SUBDEV];

commit f1618db1d9679bba2864cbc5fdc44623817e7016
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:11 2015 -0700

    staging: comedi: ni_mio_common: use 'reg' in ni_set_bitfield()
    
    Use the passed 'reg' parameter to write to the STC registers instead
    of duplicating the case symbol.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 58663a2012f0..41eae5c99fee 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -535,30 +535,27 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 	case Interrupt_A_Enable_Register:
 		devpriv->int_a_enable_reg &= ~bit_mask;
 		devpriv->int_a_enable_reg |= bit_values & bit_mask;
-		ni_stc_writew(dev, devpriv->int_a_enable_reg,
-			      Interrupt_A_Enable_Register);
+		ni_stc_writew(dev, devpriv->int_a_enable_reg, reg);
 		break;
 	case Interrupt_B_Enable_Register:
 		devpriv->int_b_enable_reg &= ~bit_mask;
 		devpriv->int_b_enable_reg |= bit_values & bit_mask;
-		ni_stc_writew(dev, devpriv->int_b_enable_reg,
-			      Interrupt_B_Enable_Register);
+		ni_stc_writew(dev, devpriv->int_b_enable_reg, reg);
 		break;
 	case IO_Bidirection_Pin_Register:
 		devpriv->io_bidirection_pin_reg &= ~bit_mask;
 		devpriv->io_bidirection_pin_reg |= bit_values & bit_mask;
-		ni_stc_writew(dev, devpriv->io_bidirection_pin_reg,
-			      IO_Bidirection_Pin_Register);
+		ni_stc_writew(dev, devpriv->io_bidirection_pin_reg, reg);
 		break;
 	case AI_AO_Select:
 		devpriv->ai_ao_select_reg &= ~bit_mask;
 		devpriv->ai_ao_select_reg |= bit_values & bit_mask;
-		ni_writeb(dev, devpriv->ai_ao_select_reg, AI_AO_Select);
+		ni_writeb(dev, devpriv->ai_ao_select_reg, reg);
 		break;
 	case G0_G1_Select:
 		devpriv->g0_g1_select_reg &= ~bit_mask;
 		devpriv->g0_g1_select_reg |= bit_values & bit_mask;
-		ni_writeb(dev, devpriv->g0_g1_select_reg, G0_G1_Select);
+		ni_writeb(dev, devpriv->g0_g1_select_reg, reg);
 		break;
 	default:
 		dev_err(dev->class_dev, "called with invalid register %d\n",

commit a47fc02b497ec7ed9e1409f5a24fa5c0ea1ee1a7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:10 2015 -0700

    staging: comedi: ni_stc.h: tidy up Clock_and_FOUT_Register and bits
    
    Rename the CamelCase and convert the enum and inline function into defines.
    Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 3035f16c9de5..58663a2012f0 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -352,7 +352,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AO_BC_LOADB_REG]		= { 0x15c, 4 },
 	[NISTC_AO_UC_LOADA_REG]		= { 0x160, 4 },
 	[NISTC_AO_UC_LOADB_REG]		= { 0x164, 4 },
-	[Clock_and_FOUT_Register]	= { 0x170, 2 },
+	[NISTC_CLK_FOUT_REG]		= { 0x170, 2 },
 	[IO_Bidirection_Pin_Register]	= { 0x172, 2 },
 	[RTSI_Trig_Direction_Register]	= { 0x174, 2 },
 	[Interrupt_Control_Register]	= { 0x176, 2 },
@@ -3637,6 +3637,7 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 				 unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
+	unsigned clk_fout = devpriv->clock_and_fout;
 	int err = insn->n;
 	unsigned char byte_out, byte_in = 0;
 
@@ -3658,21 +3659,21 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 			/* Warning: this clock speed is too fast to reliably
 			   control SCXI. */
 			devpriv->dio_control &= ~NISTC_DIO_CTRL_HW_SER_TIMEBASE;
-			devpriv->clock_and_fout |= Slow_Internal_Timebase;
-			devpriv->clock_and_fout &= ~DIO_Serial_Out_Divide_By_2;
+			clk_fout |= NISTC_CLK_FOUT_SLOW_TIMEBASE;
+			clk_fout &= ~NISTC_CLK_FOUT_DIO_SER_OUT_DIV2;
 			data[1] = SERIAL_600NS;
 			devpriv->serial_interval_ns = data[1];
 		} else if (data[1] <= SERIAL_1_2US) {
 			devpriv->dio_control &= ~NISTC_DIO_CTRL_HW_SER_TIMEBASE;
-			devpriv->clock_and_fout |= Slow_Internal_Timebase |
-			    DIO_Serial_Out_Divide_By_2;
+			clk_fout |= NISTC_CLK_FOUT_SLOW_TIMEBASE |
+				    NISTC_CLK_FOUT_DIO_SER_OUT_DIV2;
 			data[1] = SERIAL_1_2US;
 			devpriv->serial_interval_ns = data[1];
 		} else if (data[1] <= SERIAL_10US) {
 			devpriv->dio_control |= NISTC_DIO_CTRL_HW_SER_TIMEBASE;
-			devpriv->clock_and_fout |= Slow_Internal_Timebase |
-			    DIO_Serial_Out_Divide_By_2;
-			/* Note: DIO_Serial_Out_Divide_By_2 only affects
+			clk_fout |= NISTC_CLK_FOUT_SLOW_TIMEBASE |
+				    NISTC_CLK_FOUT_DIO_SER_OUT_DIV2;
+			/* Note: NISTC_CLK_FOUT_DIO_SER_OUT_DIV2 only affects
 			   600ns/1.2us. If you turn divide_by_2 off with the
 			   slow clock, you will still get 10us, except then
 			   all your delays are wrong. */
@@ -3685,10 +3686,10 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 			data[1] = (data[1] / 1000) * 1000;
 			devpriv->serial_interval_ns = data[1];
 		}
+		devpriv->clock_and_fout = clk_fout;
 
 		ni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);
-		ni_stc_writew(dev, devpriv->clock_and_fout,
-			      Clock_and_FOUT_Register);
+		ni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);
 		return 1;
 
 	case INSN_CONFIG_BIDIRECTIONAL_DATA:
@@ -3874,7 +3875,7 @@ static int ni_freq_out_insn_read(struct comedi_device *dev,
 				 unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
-	unsigned int val = devpriv->clock_and_fout & FOUT_Divider_mask;
+	unsigned int val = NISTC_CLK_FOUT_TO_DIVIDER(devpriv->clock_and_fout);
 	int i;
 
 	for (i = 0; i < insn->n; i++)
@@ -3891,17 +3892,17 @@ static int ni_freq_out_insn_write(struct comedi_device *dev,
 	struct ni_private *devpriv = dev->private;
 
 	if (insn->n) {
-		devpriv->clock_and_fout &= ~FOUT_Enable;
-		ni_stc_writew(dev, devpriv->clock_and_fout,
-			      Clock_and_FOUT_Register);
-		devpriv->clock_and_fout &= ~FOUT_Divider_mask;
+		unsigned int val = data[insn->n - 1];
+
+		devpriv->clock_and_fout &= ~NISTC_CLK_FOUT_ENA;
+		ni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);
+		devpriv->clock_and_fout &= ~NISTC_CLK_FOUT_DIVIDER_MASK;
 
 		/* use the last data value to set the fout divider */
-		devpriv->clock_and_fout |= FOUT_Divider(data[insn->n - 1]);
+		devpriv->clock_and_fout |= NISTC_CLK_FOUT_DIVIDER(val);
 
-		devpriv->clock_and_fout |= FOUT_Enable;
-		ni_stc_writew(dev, devpriv->clock_and_fout,
-			      Clock_and_FOUT_Register);
+		devpriv->clock_and_fout |= NISTC_CLK_FOUT_ENA;
+		ni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);
 	}
 	return insn->n;
 }
@@ -3917,19 +3918,18 @@ static int ni_freq_out_insn_config(struct comedi_device *dev,
 	case INSN_CONFIG_SET_CLOCK_SRC:
 		switch (data[1]) {
 		case NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC:
-			devpriv->clock_and_fout &= ~FOUT_Timebase_Select;
+			devpriv->clock_and_fout &= ~NISTC_CLK_FOUT_TIMEBASE_SEL;
 			break;
 		case NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC:
-			devpriv->clock_and_fout |= FOUT_Timebase_Select;
+			devpriv->clock_and_fout |= NISTC_CLK_FOUT_TIMEBASE_SEL;
 			break;
 		default:
 			return -EINVAL;
 		}
-		ni_stc_writew(dev, devpriv->clock_and_fout,
-			      Clock_and_FOUT_Register);
+		ni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);
 		break;
 	case INSN_CONFIG_GET_CLOCK_SRC:
-		if (devpriv->clock_and_fout & FOUT_Timebase_Select) {
+		if (devpriv->clock_and_fout & NISTC_CLK_FOUT_TIMEBASE_SEL) {
 			data[1] = NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC;
 			data[2] = TIMEBASE_2_NS;
 		} else {
@@ -5106,16 +5106,16 @@ static int ni_E_init(struct comedi_device *dev,
 	}
 
 	/* initialize clock dividers */
-	devpriv->clock_and_fout = Slow_Internal_Time_Divide_By_2 |
-				  Slow_Internal_Timebase |
-				  Clock_To_Board_Divide_By_2 |
-				  Clock_To_Board;
+	devpriv->clock_and_fout = NISTC_CLK_FOUT_SLOW_DIV2 |
+				  NISTC_CLK_FOUT_SLOW_TIMEBASE |
+				  NISTC_CLK_FOUT_TO_BOARD_DIV2 |
+				  NISTC_CLK_FOUT_TO_BOARD;
 	if (!devpriv->is_6xxx) {
 		/* BEAM is this needed for PCI-6143 ?? */
-		devpriv->clock_and_fout |= (AI_Output_Divide_By_2 |
-					    AO_Output_Divide_By_2);
+		devpriv->clock_and_fout |= (NISTC_CLK_FOUT_AI_OUT_DIV2 |
+					    NISTC_CLK_FOUT_AO_OUT_DIV2);
 	}
-	ni_stc_writew(dev, devpriv->clock_and_fout, Clock_and_FOUT_Register);
+	ni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);
 
 	ret = comedi_alloc_subdevices(dev, NI_NUM_SUBDEVICES);
 	if (ret)

commit 37e0ecee83a41b08361c33ea627e0d2e0a9ea88d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:09 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_*_Load_[AB]_Register
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ddc7e7612ce5..3035f16c9de5 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -346,12 +346,12 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_G1_INPUT_SEL_REG]	= { 0x14a, 2 },
 	[NISTC_AO_MODE1_REG]		= { 0x14c, 2 },
 	[NISTC_AO_MODE2_REG]		= { 0x14e, 2 },
-	[AO_UI_Load_A_Register]		= { 0x150, 4 },
-	[AO_UI_Load_B_Register]		= { 0x154, 4 },
-	[AO_BC_Load_A_Register]		= { 0x158, 4 },
-	[AO_BC_Load_B_Register]		= { 0x15c, 4 },
-	[AO_UC_Load_A_Register]		= { 0x160, 4 },
-	[AO_UC_Load_B_Register]		= { 0x164, 4 },
+	[NISTC_AO_UI_LOADA_REG]		= { 0x150, 4 },
+	[NISTC_AO_UI_LOADB_REG]		= { 0x154, 4 },
+	[NISTC_AO_BC_LOADA_REG]		= { 0x158, 4 },
+	[NISTC_AO_BC_LOADB_REG]		= { 0x15c, 4 },
+	[NISTC_AO_UC_LOADA_REG]		= { 0x160, 4 },
+	[NISTC_AO_UC_LOADB_REG]		= { 0x164, 4 },
 	[Clock_and_FOUT_Register]	= { 0x170, 2 },
 	[IO_Bidirection_Pin_Register]	= { 0x172, 2 },
 	[RTSI_Trig_Direction_Register]	= { 0x174, 2 },
@@ -2994,9 +2994,9 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_BC_INIT_LOAD_SRC;
 	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
 	if (cmd->stop_src == TRIG_NONE)
-		ni_stc_writel(dev, 0xffffff, AO_BC_Load_A_Register);
+		ni_stc_writel(dev, 0xffffff, NISTC_AO_BC_LOADA_REG);
 	else
-		ni_stc_writel(dev, 0, AO_BC_Load_A_Register);
+		ni_stc_writel(dev, 0, NISTC_AO_BC_LOADA_REG);
 	ni_stc_writew(dev, NISTC_AO_CMD1_BC_LOAD, NISTC_AO_CMD1_REG);
 	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_UC_INIT_LOAD_SRC;
 	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
@@ -3005,27 +3005,27 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		if (devpriv->is_m_series) {
 			/*  this is how the NI example code does it for m-series boards, verified correct with 6259 */
 			ni_stc_writel(dev, cmd->stop_arg - 1,
-				      AO_UC_Load_A_Register);
+				      NISTC_AO_UC_LOADA_REG);
 			ni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD,
 				      NISTC_AO_CMD1_REG);
 		} else {
 			ni_stc_writel(dev, cmd->stop_arg,
-				      AO_UC_Load_A_Register);
+				      NISTC_AO_UC_LOADA_REG);
 			ni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD,
 				      NISTC_AO_CMD1_REG);
 			ni_stc_writel(dev, cmd->stop_arg - 1,
-				      AO_UC_Load_A_Register);
+				      NISTC_AO_UC_LOADA_REG);
 		}
 		break;
 	case TRIG_NONE:
-		ni_stc_writel(dev, 0xffffff, AO_UC_Load_A_Register);
+		ni_stc_writel(dev, 0xffffff, NISTC_AO_UC_LOADA_REG);
 		ni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD, NISTC_AO_CMD1_REG);
-		ni_stc_writel(dev, 0xffffff, AO_UC_Load_A_Register);
+		ni_stc_writel(dev, 0xffffff, NISTC_AO_UC_LOADA_REG);
 		break;
 	default:
-		ni_stc_writel(dev, 0, AO_UC_Load_A_Register);
+		ni_stc_writel(dev, 0, NISTC_AO_UC_LOADA_REG);
 		ni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD, NISTC_AO_CMD1_REG);
-		ni_stc_writel(dev, cmd->stop_arg, AO_UC_Load_A_Register);
+		ni_stc_writel(dev, cmd->stop_arg, NISTC_AO_UC_LOADA_REG);
 	}
 
 	devpriv->ao_mode1 &= ~(NISTC_AO_MODE1_UPDATE_SRC_MASK |
@@ -3038,9 +3038,9 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		trigvar =
 		    ni_ns_to_timer(dev, cmd->scan_begin_arg,
 				   CMDF_ROUND_NEAREST);
-		ni_stc_writel(dev, 1, AO_UI_Load_A_Register);
+		ni_stc_writel(dev, 1, NISTC_AO_UI_LOADA_REG);
 		ni_stc_writew(dev, NISTC_AO_CMD1_UI_LOAD, NISTC_AO_CMD1_REG);
-		ni_stc_writel(dev, trigvar, AO_UI_Load_A_Register);
+		ni_stc_writel(dev, trigvar, NISTC_AO_UI_LOADA_REG);
 		break;
 	case TRIG_EXT:
 		devpriv->ao_mode1 |=

commit ec8bf7250f8156a8ba0d2381046224e66042d83c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:08 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_Mode_2_Register and bits
    
    Rename the CamelCase and convert the enum into defines. Use the BIT()
    macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e4ae9a1445b5..ddc7e7612ce5 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -345,7 +345,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_G0_INPUT_SEL_REG]	= { 0x148, 2 },
 	[NISTC_G1_INPUT_SEL_REG]	= { 0x14a, 2 },
 	[NISTC_AO_MODE1_REG]		= { 0x14c, 2 },
-	[AO_Mode_2_Register]		= { 0x14e, 2 },
+	[NISTC_AO_MODE2_REG]		= { 0x14e, 2 },
 	[AO_UI_Load_A_Register]		= { 0x150, 4 },
 	[AO_UI_Load_B_Register]		= { 0x154, 4 },
 	[AO_BC_Load_A_Register]		= { 0x158, 4 },
@@ -2991,15 +2991,15 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 
 	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
-	devpriv->ao_mode2 &= ~AO_BC_Initial_Load_Source;
-	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_BC_INIT_LOAD_SRC;
+	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
 	if (cmd->stop_src == TRIG_NONE)
 		ni_stc_writel(dev, 0xffffff, AO_BC_Load_A_Register);
 	else
 		ni_stc_writel(dev, 0, AO_BC_Load_A_Register);
 	ni_stc_writew(dev, NISTC_AO_CMD1_BC_LOAD, NISTC_AO_CMD1_REG);
-	devpriv->ao_mode2 &= ~AO_UC_Initial_Load_Source;
-	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_UC_INIT_LOAD_SRC;
+	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
 		if (devpriv->is_m_series) {
@@ -3055,9 +3055,9 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	ni_stc_writew(dev, devpriv->ao_cmd2, NISTC_AO_CMD2_REG);
 	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
-	devpriv->ao_mode2 &=
-	    ~(AO_UI_Reload_Mode(3) | AO_UI_Initial_Load_Source);
-	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+	devpriv->ao_mode2 &= ~(NISTC_AO_MODE2_UI_RELOAD_MODE(3) |
+			       NISTC_AO_MODE2_UI_INIT_LOAD_SRC);
+	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
 
 	if (cmd->scan_end_arg > 1) {
 		devpriv->ao_mode1 |= NISTC_AO_MODE1_MULTI_CHAN;
@@ -3087,14 +3087,14 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ao_mode3 |= AO_Stop_On_Overrun_Error;
 	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 
-	devpriv->ao_mode2 &= ~AO_FIFO_Mode_Mask;
+	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_FIFO_MODE_MASK;
 #ifdef PCIDMA
-	devpriv->ao_mode2 |= AO_FIFO_Mode_HF_to_F;
+	devpriv->ao_mode2 |= NISTC_AO_MODE2_FIFO_MODE_HF_F;
 #else
-	devpriv->ao_mode2 |= AO_FIFO_Mode_HF;
+	devpriv->ao_mode2 |= NISTC_AO_MODE2_FIFO_MODE_HF;
 #endif
-	devpriv->ao_mode2 &= ~AO_FIFO_Retransmit_Enable;
-	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+	devpriv->ao_mode2 &= ~NISTC_AO_MODE2_FIFO_REXMIT_ENA;
+	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
 
 	bits = AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
 	    AO_TMRDACWR_Pulse_Width;
@@ -3231,7 +3231,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ao_mode1 = 0;
 	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
 	devpriv->ao_mode2 = 0;
-	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+	ni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);
 	if (devpriv->is_m_series)
 		devpriv->ao_mode3 = AO_Last_Gate_Disable;
 	else

commit 4e5ce0a8f3a2e59e17b997601947f6863ce69256
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:07 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_Mode_1_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a2049a3d3341..e4ae9a1445b5 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -344,7 +344,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_G1_LOADB_REG]		= { 0x144, 4 },
 	[NISTC_G0_INPUT_SEL_REG]	= { 0x148, 2 },
 	[NISTC_G1_INPUT_SEL_REG]	= { 0x14a, 2 },
-	[AO_Mode_1_Register]		= { 0x14c, 2 },
+	[NISTC_AO_MODE1_REG]		= { 0x14c, 2 },
 	[AO_Mode_2_Register]		= { 0x14e, 2 },
 	[AO_UI_Load_A_Register]		= { 0x150, 4 },
 	[AO_UI_Load_B_Register]		= { 0x154, 4 },
@@ -2957,13 +2957,13 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_ao_config_chanlist(dev, s, cmd->chanlist, cmd->chanlist_len, 1);
 
 	if (cmd->stop_src == TRIG_NONE) {
-		devpriv->ao_mode1 |= AO_Continuous;
-		devpriv->ao_mode1 &= ~AO_Trigger_Once;
+		devpriv->ao_mode1 |= NISTC_AO_MODE1_CONTINUOUS;
+		devpriv->ao_mode1 &= ~NISTC_AO_MODE1_TRIGGER_ONCE;
 	} else {
-		devpriv->ao_mode1 &= ~AO_Continuous;
-		devpriv->ao_mode1 |= AO_Trigger_Once;
+		devpriv->ao_mode1 &= ~NISTC_AO_MODE1_CONTINUOUS;
+		devpriv->ao_mode1 |= NISTC_AO_MODE1_TRIGGER_ONCE;
 	}
-	ni_stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
 	switch (cmd->start_src) {
 	case TRIG_INT:
 	case TRIG_NOW:
@@ -2990,7 +2990,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ao_mode3 &= ~AO_Trigger_Length;
 	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 
-	ni_stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
 	devpriv->ao_mode2 &= ~AO_BC_Initial_Load_Source;
 	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 	if (cmd->stop_src == TRIG_NONE)
@@ -3028,9 +3028,10 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_stc_writel(dev, cmd->stop_arg, AO_UC_Load_A_Register);
 	}
 
-	devpriv->ao_mode1 &=
-	    ~(AO_UI_Source_Select(0x1f) | AO_UI_Source_Polarity |
-	      AO_UPDATE_Source_Select(0x1f) | AO_UPDATE_Source_Polarity);
+	devpriv->ao_mode1 &= ~(NISTC_AO_MODE1_UPDATE_SRC_MASK |
+			       NISTC_AO_MODE1_UI_SRC_MASK |
+			       NISTC_AO_MODE1_UPDATE_SRC_POLARITY |
+			       NISTC_AO_MODE1_UI_SRC_POLARITY);
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
 		devpriv->ao_cmd2 &= ~NISTC_AO_CMD2_BC_GATE_ENA;
@@ -3043,9 +3044,9 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	case TRIG_EXT:
 		devpriv->ao_mode1 |=
-		    AO_UPDATE_Source_Select(cmd->scan_begin_arg);
+		    NISTC_AO_MODE1_UPDATE_SRC(cmd->scan_begin_arg);
 		if (cmd->scan_begin_arg & CR_INVERT)
-			devpriv->ao_mode1 |= AO_UPDATE_Source_Polarity;
+			devpriv->ao_mode1 |= NISTC_AO_MODE1_UPDATE_SRC_POLARITY;
 		devpriv->ao_cmd2 |= NISTC_AO_CMD2_BC_GATE_ENA;
 		break;
 	default:
@@ -3053,13 +3054,13 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	}
 	ni_stc_writew(dev, devpriv->ao_cmd2, NISTC_AO_CMD2_REG);
-	ni_stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
 	devpriv->ao_mode2 &=
 	    ~(AO_UI_Reload_Mode(3) | AO_UI_Initial_Load_Source);
 	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 
 	if (cmd->scan_end_arg > 1) {
-		devpriv->ao_mode1 |= AO_Multiple_Channels;
+		devpriv->ao_mode1 |= NISTC_AO_MODE1_MULTI_CHAN;
 		ni_stc_writew(dev,
 			      AO_Number_Of_Channels(cmd->scan_end_arg - 1) |
 			      AO_UPDATE_Output_Select(AO_Update_Output_High_Z),
@@ -3067,7 +3068,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	} else {
 		unsigned bits;
 
-		devpriv->ao_mode1 &= ~AO_Multiple_Channels;
+		devpriv->ao_mode1 &= ~NISTC_AO_MODE1_MULTI_CHAN;
 		bits = AO_UPDATE_Output_Select(AO_Update_Output_High_Z);
 		if (devpriv->is_m_series || devpriv->is_6xxx) {
 			bits |= AO_Number_Of_Channels(0);
@@ -3077,7 +3078,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		}
 		ni_stc_writew(dev, bits, AO_Output_Control_Register);
 	}
-	ni_stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
 
 	ni_stc_writew(dev, NISTC_AO_CMD1_DAC1_UPDATE_MODE |
 			   NISTC_AO_CMD1_DAC0_UPDATE_MODE,
@@ -3228,7 +3229,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ao_cmd2 = 0;
 	ni_stc_writew(dev, devpriv->ao_cmd2, NISTC_AO_CMD2_REG);
 	devpriv->ao_mode1 = 0;
-	ni_stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	ni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);
 	devpriv->ao_mode2 = 0;
 	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 	if (devpriv->is_m_series)

commit aff27008376a83ee1603e688b68ceed24356c81e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:06 2015 -0700

    staging: comedi: ni_stc.h: tidy up G_{Mode,Load,Input}*_Register
    
    Rename the CamelCase and define he G0 and G1 registers to add clarity
    to the mio_regmap tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 6b63bad12d17..a2049a3d3341 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -336,14 +336,14 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AI_SC_LOADB_REG]		= { 0x128, 4 },
 	[NISTC_AI_SI2_LOADA_REG]	= { 0x12c, 4 },
 	[NISTC_AI_SI2_LOADB_REG]	= { 0x130, 4 },
-	[G_Mode_Register(0)]		= { 0x134, 2 },
-	[G_Mode_Register(1)]		= { 0x136, 2 },
-	[G_Load_A_Register(0)]		= { 0x138, 4 },
-	[G_Load_B_Register(0)]		= { 0x13c, 4 },
-	[G_Load_A_Register(1)]		= { 0x140, 4 },
-	[G_Load_B_Register(1)]		= { 0x144, 4 },
-	[G_Input_Select_Register(0)]	= { 0x148, 2 },
-	[G_Input_Select_Register(1)]	= { 0x14a, 2 },
+	[NISTC_G0_MODE_REG]		= { 0x134, 2 },
+	[NISTC_G1_MODE_REG]		= { 0x136, 2 },
+	[NISTC_G0_LOADA_REG]		= { 0x138, 4 },
+	[NISTC_G0_LOADB_REG]		= { 0x13c, 4 },
+	[NISTC_G1_LOADA_REG]		= { 0x140, 4 },
+	[NISTC_G1_LOADB_REG]		= { 0x144, 4 },
+	[NISTC_G0_INPUT_SEL_REG]	= { 0x148, 2 },
+	[NISTC_G1_INPUT_SEL_REG]	= { 0x14a, 2 },
 	[AO_Mode_1_Register]		= { 0x14c, 2 },
 	[AO_Mode_2_Register]		= { 0x14e, 2 },
 	[AO_UI_Load_A_Register]		= { 0x150, 4 },
@@ -3738,14 +3738,14 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G1_HW_SAVE]	= { G_HW_Save_Register(1), 4 },
 	[NITIO_G0_SW_SAVE]	= { G_Save_Register(0), 4 },
 	[NITIO_G1_SW_SAVE]	= { G_Save_Register(1), 4 },
-	[NITIO_G0_MODE]		= { G_Mode_Register(0), 2 },
-	[NITIO_G1_MODE]		= { G_Mode_Register(1), 2 },
-	[NITIO_G0_LOADA]	= { G_Load_A_Register(0), 4 },
-	[NITIO_G1_LOADA]	= { G_Load_A_Register(1), 4 },
-	[NITIO_G0_LOADB]	= { G_Load_B_Register(0), 4 },
-	[NITIO_G1_LOADB]	= { G_Load_B_Register(1), 4 },
-	[NITIO_G0_INPUT_SEL]	= { G_Input_Select_Register(0), 2 },
-	[NITIO_G1_INPUT_SEL]	= { G_Input_Select_Register(1), 2 },
+	[NITIO_G0_MODE]		= { NISTC_G0_MODE_REG, 2 },
+	[NITIO_G1_MODE]		= { NISTC_G1_MODE_REG, 2 },
+	[NITIO_G0_LOADA]	= { NISTC_G0_LOADA_REG, 4 },
+	[NITIO_G1_LOADA]	= { NISTC_G1_LOADA_REG, 4 },
+	[NITIO_G0_LOADB]	= { NISTC_G0_LOADB_REG, 4 },
+	[NITIO_G1_LOADB]	= { NISTC_G1_LOADB_REG, 4 },
+	[NITIO_G0_INPUT_SEL]	= { NISTC_G0_INPUT_SEL_REG, 2 },
+	[NITIO_G1_INPUT_SEL]	= { NISTC_G1_INPUT_SEL_REG, 2 },
 	[NITIO_G0_CNT_MODE]	= { 0x1b0, 2 },	/* M-Series only */
 	[NITIO_G1_CNT_MODE]	= { 0x1b2, 2 },	/* M-Series only */
 	[NITIO_G0_GATE2]	= { 0x1b4, 2 },	/* M-Series only */

commit a2c537362a7975a7bab1e325872510dbf68b83c6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:05 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_*_Load_[AB]_Registers
    
    Rename the CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7cbe9d9e0bd8..6b63bad12d17 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -330,12 +330,12 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_DIO_CTRL_REG]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
 	[NISTC_AI_MODE1_REG]		= { 0x118, 2 },
 	[NISTC_AI_MODE2_REG]		= { 0x11a, 2 },
-	[AI_SI_Load_A_Registers]	= { 0x11c, 4 },
-	[AI_SI_Load_B_Registers]	= { 0x120, 4 },
-	[AI_SC_Load_A_Registers]	= { 0x124, 4 },
-	[AI_SC_Load_B_Registers]	= { 0x128, 4 },
-	[AI_SI2_Load_A_Register]	= { 0x12c, 4 },
-	[AI_SI2_Load_B_Register]	= { 0x130, 4 },
+	[NISTC_AI_SI_LOADA_REG]		= { 0x11c, 4 },
+	[NISTC_AI_SI_LOADB_REG]		= { 0x120, 4 },
+	[NISTC_AI_SC_LOADA_REG]		= { 0x124, 4 },
+	[NISTC_AI_SC_LOADB_REG]		= { 0x128, 4 },
+	[NISTC_AI_SI2_LOADA_REG]	= { 0x12c, 4 },
+	[NISTC_AI_SI2_LOADB_REG]	= { 0x130, 4 },
 	[G_Mode_Register(0)]		= { 0x134, 2 },
 	[G_Mode_Register(1)]		= { 0x136, 2 },
 	[G_Load_A_Register(0)]		= { 0x138, 4 },
@@ -2337,7 +2337,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			stop_count += num_adc_stages_611x;
 		}
 		/* stage number of scans */
-		ni_stc_writel(dev, stop_count, AI_SC_Load_A_Registers);
+		ni_stc_writel(dev, stop_count, NISTC_AI_SC_LOADA_REG);
 
 		mode1 |= NISTC_AI_MODE1_START_STOP |
 			 NISTC_AI_MODE1_RSVD |
@@ -2357,7 +2357,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	case TRIG_NONE:
 		/* stage number of scans */
-		ni_stc_writel(dev, 0, AI_SC_Load_A_Registers);
+		ni_stc_writel(dev, 0, NISTC_AI_SC_LOADA_REG);
 
 		mode1 |= NISTC_AI_MODE1_START_STOP |
 			 NISTC_AI_MODE1_RSVD |
@@ -2397,7 +2397,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* load SI */
 		timer = ni_ns_to_timer(dev, cmd->scan_begin_arg,
 				       CMDF_ROUND_NEAREST);
-		ni_stc_writel(dev, timer, AI_SI_Load_A_Registers);
+		ni_stc_writel(dev, timer, NISTC_AI_SI_LOADA_REG);
 		ni_stc_writew(dev, NISTC_AI_CMD1_SI_LOAD, NISTC_AI_CMD1_REG);
 		break;
 	case TRIG_EXT:
@@ -2426,8 +2426,8 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			timer = ni_ns_to_timer(dev, cmd->convert_arg,
 					       CMDF_ROUND_NEAREST);
 		/* 0,0 does not work */
-		ni_stc_writew(dev, 1, AI_SI2_Load_A_Register);
-		ni_stc_writew(dev, timer, AI_SI2_Load_B_Register);
+		ni_stc_writew(dev, 1, NISTC_AI_SI2_LOADA_REG);
+		ni_stc_writew(dev, timer, NISTC_AI_SI2_LOADB_REG);
 
 		mode2 &= ~NISTC_AI_MODE2_SI2_INIT_LOAD_SRC;	/* A */
 		mode2 |= NISTC_AI_MODE2_SI2_RELOAD_MODE;	/* alternate */

commit b134cc58b81069ea6e1322a883e4bd66726a9f2d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:04 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_Mode_2_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 01015d76af53..7cbe9d9e0bd8 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -329,7 +329,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_DIO_OUT_REG]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
 	[NISTC_DIO_CTRL_REG]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
 	[NISTC_AI_MODE1_REG]		= { 0x118, 2 },
-	[AI_Mode_2_Register]		= { 0x11a, 2 },
+	[NISTC_AI_MODE2_REG]		= { 0x11a, 2 },
 	[AI_SI_Load_A_Registers]	= { 0x11c, 4 },
 	[AI_SI_Load_B_Registers]	= { 0x120, 4 },
 	[AI_SC_Load_A_Registers]	= { 0x124, 4 },
@@ -1634,7 +1634,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 			   NISTC_AI_MODE1_RSVD
 			    /*| NISTC_AI_MODE1_TRIGGER_ONCE */,
 		      NISTC_AI_MODE1_REG);
-	ni_stc_writew(dev, 0x0000, AI_Mode_2_Register);
+	ni_stc_writew(dev, 0, NISTC_AI_MODE2_REG);
 	/* generate FIFO interrupts on non-empty */
 	ni_stc_writew(dev, (0 << 6) | 0x0000, AI_Mode_3_Register);
 	if (devpriv->is_611x) {
@@ -2313,10 +2313,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		}
 	}
 
-	mode2 &= ~AI_Pre_Trigger;
-	mode2 &= ~AI_SC_Initial_Load_Source;
-	mode2 &= ~AI_SC_Reload_Mode;
-	ni_stc_writew(dev, mode2, AI_Mode_2_Register);
+	mode2 &= ~NISTC_AI_MODE2_PRE_TRIGGER;
+	mode2 &= ~NISTC_AI_MODE2_SC_INIT_LOAD_SRC;
+	mode2 &= ~NISTC_AI_MODE2_SC_RELOAD_MODE;
+	ni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);
 
 	if (cmd->chanlist_len == 1 || devpriv->is_611x || devpriv->is_6143) {
 		start_stop_select |= AI_STOP_Polarity;
@@ -2374,7 +2374,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/*
 		   stop bits for non 611x boards
 		   AI_SI_Special_Trigger_Delay=0
-		   AI_Pre_Trigger=0
+		   NISTC_AI_MODE2_PRE_TRIGGER=0
 		   AI_START_STOP_Select_Register:
 		   AI_START_Polarity=0 (?)      rising edge
 		   AI_START_Edge=1              edge triggered
@@ -2389,11 +2389,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_stc_writew(dev, start_stop_select,
 			      AI_START_STOP_Select_Register);
 
-		mode2 |= AI_SI_Reload_Mode(0);
-		/* AI_SI_Initial_Load_Source=A */
-		mode2 &= ~AI_SI_Initial_Load_Source;
-		/* mode2 |= AI_SC_Reload_Mode; */
-		ni_stc_writew(dev, mode2, AI_Mode_2_Register);
+		mode2 &= ~NISTC_AI_MODE2_SI_INIT_LOAD_SRC;	/* A */
+		mode2 |= NISTC_AI_MODE2_SI_RELOAD_MODE(0);
+		/* mode2 |= NISTC_AI_MODE2_SC_RELOAD_MODE; */
+		ni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);
 
 		/* load SI */
 		timer = ni_ns_to_timer(dev, cmd->scan_begin_arg,
@@ -2430,18 +2429,15 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_stc_writew(dev, 1, AI_SI2_Load_A_Register);
 		ni_stc_writew(dev, timer, AI_SI2_Load_B_Register);
 
-		/* AI_SI2_Reload_Mode = alternate */
-		/* AI_SI2_Initial_Load_Source = A */
-		mode2 &= ~AI_SI2_Initial_Load_Source;
-		mode2 |= AI_SI2_Reload_Mode;
-		ni_stc_writew(dev, mode2, AI_Mode_2_Register);
+		mode2 &= ~NISTC_AI_MODE2_SI2_INIT_LOAD_SRC;	/* A */
+		mode2 |= NISTC_AI_MODE2_SI2_RELOAD_MODE;	/* alternate */
+		ni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);
 
 		ni_stc_writew(dev, NISTC_AI_CMD1_SI2_LOAD, NISTC_AI_CMD1_REG);
 
-		mode2 |= AI_SI2_Reload_Mode;	/*  alternate */
-		mode2 |= AI_SI2_Initial_Load_Source;	/*  B */
-
-		ni_stc_writew(dev, mode2, AI_Mode_2_Register);
+		mode2 |= NISTC_AI_MODE2_SI2_INIT_LOAD_SRC;	/* B */
+		mode2 |= NISTC_AI_MODE2_SI2_RELOAD_MODE;	/* alternate */
+		ni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);
 		break;
 	case TRIG_EXT:
 		mode1 |= NISTC_AI_MODE1_CONVERT_SRC(1 + cmd->convert_arg);
@@ -2449,8 +2445,9 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			mode1 |= NISTC_AI_MODE1_CONVERT_POLARITY;
 		ni_stc_writew(dev, mode1, NISTC_AI_MODE1_REG);
 
-		mode2 |= AI_Start_Stop_Gate_Enable | AI_SC_Gate_Enable;
-		ni_stc_writew(dev, mode2, AI_Mode_2_Register);
+		mode2 |= NISTC_AI_MODE2_SC_GATE_ENA |
+			 NISTC_AI_MODE2_START_STOP_GATE_ENA;
+		ni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);
 
 		break;
 	}

commit bd358f5e2920db00f9c5f6c4267a22b0e6c17960
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:03 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_Mode_1_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 284ce94f9b2a..01015d76af53 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -328,7 +328,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	 */
 	[NISTC_DIO_OUT_REG]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
 	[NISTC_DIO_CTRL_REG]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
-	[AI_Mode_1_Register]		= { 0x118, 2 },
+	[NISTC_AI_MODE1_REG]		= { 0x118, 2 },
 	[AI_Mode_2_Register]		= { 0x11a, 2 },
 	[AI_SI_Load_A_Registers]	= { 0x11c, 4 },
 	[AI_SI_Load_B_Registers]	= { 0x120, 4 },
@@ -1630,9 +1630,10 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_writeb(dev, 0, Misc_Command);
 
 	ni_stc_writew(dev, NISTC_AI_CMD1_DISARM, NISTC_AI_CMD1_REG);
-	ni_stc_writew(dev, AI_Start_Stop | AI_Mode_1_Reserved
-			    /*| AI_Trigger_Once */,
-		      AI_Mode_1_Register);
+	ni_stc_writew(dev, NISTC_AI_MODE1_START_STOP |
+			   NISTC_AI_MODE1_RSVD
+			    /*| NISTC_AI_MODE1_TRIGGER_ONCE */,
+		      NISTC_AI_MODE1_REG);
 	ni_stc_writew(dev, 0x0000, AI_Mode_2_Register);
 	/* generate FIFO interrupts on non-empty */
 	ni_stc_writew(dev, (0 << 6) | 0x0000, AI_Mode_3_Register);
@@ -1691,7 +1692,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* the following registers should not be changed, because there
 	 * are no backup registers in devpriv.  If you want to change
 	 * any of these, add a backup register and other appropriate code:
-	 *      AI_Mode_1_Register
+	 *      NISTC_AI_MODE1_REG
 	 *      AI_Mode_3_Register
 	 *      AI_Personal_Register
 	 *      AI_Output_Control_Register
@@ -2338,8 +2339,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* stage number of scans */
 		ni_stc_writel(dev, stop_count, AI_SC_Load_A_Registers);
 
-		mode1 |= AI_Start_Stop | AI_Mode_1_Reserved | AI_Trigger_Once;
-		ni_stc_writew(dev, mode1, AI_Mode_1_Register);
+		mode1 |= NISTC_AI_MODE1_START_STOP |
+			 NISTC_AI_MODE1_RSVD |
+			 NISTC_AI_MODE1_TRIGGER_ONCE;
+		ni_stc_writew(dev, mode1, NISTC_AI_MODE1_REG);
 		/* load SC (Scan Count) */
 		ni_stc_writew(dev, NISTC_AI_CMD1_SC_LOAD, NISTC_AI_CMD1_REG);
 
@@ -2356,8 +2359,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* stage number of scans */
 		ni_stc_writel(dev, 0, AI_SC_Load_A_Registers);
 
-		mode1 |= AI_Start_Stop | AI_Mode_1_Reserved | AI_Continuous;
-		ni_stc_writew(dev, mode1, AI_Mode_1_Register);
+		mode1 |= NISTC_AI_MODE1_START_STOP |
+			 NISTC_AI_MODE1_RSVD |
+			 NISTC_AI_MODE1_CONTINUOUS;
+		ni_stc_writew(dev, mode1, NISTC_AI_MODE1_REG);
 
 		/* load SC (Scan Count) */
 		ni_stc_writew(dev, NISTC_AI_CMD1_SC_LOAD, NISTC_AI_CMD1_REG);
@@ -2439,10 +2444,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_stc_writew(dev, mode2, AI_Mode_2_Register);
 		break;
 	case TRIG_EXT:
-		mode1 |= AI_CONVERT_Source_Select(1 + cmd->convert_arg);
+		mode1 |= NISTC_AI_MODE1_CONVERT_SRC(1 + cmd->convert_arg);
 		if ((cmd->convert_arg & CR_INVERT) == 0)
-			mode1 |= AI_CONVERT_Source_Polarity;
-		ni_stc_writew(dev, mode1, AI_Mode_1_Register);
+			mode1 |= NISTC_AI_MODE1_CONVERT_POLARITY;
+		ni_stc_writew(dev, mode1, NISTC_AI_MODE1_REG);
 
 		mode2 |= AI_Start_Stop_Gate_Enable | AI_SC_Gate_Enable;
 		ni_stc_writew(dev, mode2, AI_Mode_2_Register);

commit 59a97c3c867797c68bf14ce1620ac8a8f695eef0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:02 2015 -0700

    staging: comedi: ni_stc.h: tidy up DIO_Control_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d8c4d60670b7..284ce94f9b2a 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -327,7 +327,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	 * { NI_M_DIO_REG, 4 } and { NI_M_SCXI_SER_DO_REG, 1 }
 	 */
 	[NISTC_DIO_OUT_REG]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
-	[DIO_Control_Register]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
+	[NISTC_DIO_CTRL_REG]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
 	[AI_Mode_1_Register]		= { 0x118, 2 },
 	[AI_Mode_2_Register]		= { 0x11a, 2 },
 	[AI_SI_Load_A_Registers]	= { 0x11c, 4 },
@@ -3265,9 +3265,9 @@ static int ni_dio_insn_config(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	devpriv->dio_control &= ~DIO_Pins_Dir_Mask;
-	devpriv->dio_control |= DIO_Pins_Dir(s->io_bits);
-	ni_stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
+	devpriv->dio_control &= ~NISTC_DIO_CTRL_DIR_MASK;
+	devpriv->dio_control |= NISTC_DIO_CTRL_DIR(s->io_bits);
+	ni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);
 
 	return insn->n;
 }
@@ -3554,9 +3554,9 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 		goto Error;
 	}
 
-	devpriv->dio_control |= DIO_HW_Serial_Start;
-	ni_stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
-	devpriv->dio_control &= ~DIO_HW_Serial_Start;
+	devpriv->dio_control |= NISTC_DIO_CTRL_HW_SER_START;
+	ni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);
+	devpriv->dio_control &= ~NISTC_DIO_CTRL_HW_SER_START;
 
 	/* Wait until STC says we're done, but don't loop infinitely. */
 	while ((status1 = ni_stc_readw(dev, Joint_Status_1_Register)) &
@@ -3579,7 +3579,7 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 		*data_in = ni_stc_readw(dev, DIO_Serial_Input_Register);
 
 Error:
-	ni_stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
+	ni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);
 
 	return err;
 }
@@ -3606,13 +3606,13 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 
 		/* Assert SDCLK (active low, inverted), wait for half of
 		   the delay, deassert SDCLK, and wait for the other half. */
-		devpriv->dio_control |= DIO_Software_Serial_Control;
-		ni_stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
+		devpriv->dio_control |= NISTC_DIO_SDCLK;
+		ni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);
 
 		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
-		devpriv->dio_control &= ~DIO_Software_Serial_Control;
-		ni_stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
+		devpriv->dio_control &= ~NISTC_DIO_SDCLK;
+		ni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);
 
 		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
@@ -3643,30 +3643,30 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 	switch (data[0]) {
 	case INSN_CONFIG_SERIAL_CLOCK:
 		devpriv->serial_hw_mode = 1;
-		devpriv->dio_control |= DIO_HW_Serial_Enable;
+		devpriv->dio_control |= NISTC_DIO_CTRL_HW_SER_ENA;
 
 		if (data[1] == SERIAL_DISABLED) {
 			devpriv->serial_hw_mode = 0;
-			devpriv->dio_control &= ~(DIO_HW_Serial_Enable |
-						  DIO_Software_Serial_Control);
+			devpriv->dio_control &= ~(NISTC_DIO_CTRL_HW_SER_ENA |
+						  NISTC_DIO_SDCLK);
 			data[1] = SERIAL_DISABLED;
 			devpriv->serial_interval_ns = data[1];
 		} else if (data[1] <= SERIAL_600NS) {
 			/* Warning: this clock speed is too fast to reliably
 			   control SCXI. */
-			devpriv->dio_control &= ~DIO_HW_Serial_Timebase;
+			devpriv->dio_control &= ~NISTC_DIO_CTRL_HW_SER_TIMEBASE;
 			devpriv->clock_and_fout |= Slow_Internal_Timebase;
 			devpriv->clock_and_fout &= ~DIO_Serial_Out_Divide_By_2;
 			data[1] = SERIAL_600NS;
 			devpriv->serial_interval_ns = data[1];
 		} else if (data[1] <= SERIAL_1_2US) {
-			devpriv->dio_control &= ~DIO_HW_Serial_Timebase;
+			devpriv->dio_control &= ~NISTC_DIO_CTRL_HW_SER_TIMEBASE;
 			devpriv->clock_and_fout |= Slow_Internal_Timebase |
 			    DIO_Serial_Out_Divide_By_2;
 			data[1] = SERIAL_1_2US;
 			devpriv->serial_interval_ns = data[1];
 		} else if (data[1] <= SERIAL_10US) {
-			devpriv->dio_control |= DIO_HW_Serial_Timebase;
+			devpriv->dio_control |= NISTC_DIO_CTRL_HW_SER_TIMEBASE;
 			devpriv->clock_and_fout |= Slow_Internal_Timebase |
 			    DIO_Serial_Out_Divide_By_2;
 			/* Note: DIO_Serial_Out_Divide_By_2 only affects
@@ -3676,14 +3676,14 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 			data[1] = SERIAL_10US;
 			devpriv->serial_interval_ns = data[1];
 		} else {
-			devpriv->dio_control &= ~(DIO_HW_Serial_Enable |
-						  DIO_Software_Serial_Control);
+			devpriv->dio_control &= ~(NISTC_DIO_CTRL_HW_SER_ENA |
+						  NISTC_DIO_SDCLK);
 			devpriv->serial_hw_mode = 0;
 			data[1] = (data[1] / 1000) * 1000;
 			devpriv->serial_interval_ns = data[1];
 		}
 
-		ni_stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
+		ni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);
 		ni_stc_writew(dev, devpriv->clock_and_fout,
 			      Clock_and_FOUT_Register);
 		return 1;
@@ -5230,8 +5230,8 @@ static int ni_E_init(struct comedi_device *dev,
 		s->insn_config	= ni_dio_insn_config;
 
 		/* set all channels to inputs */
-		devpriv->dio_control = DIO_Pins_Dir(s->io_bits);
-		ni_writew(dev, devpriv->dio_control, DIO_Control_Register);
+		devpriv->dio_control = NISTC_DIO_CTRL_DIR(s->io_bits);
+		ni_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);
 	}
 
 	/* 8255 device */

commit 05aafeea0c771895c49fb43c00f05a31ff9f2ba2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:01 2015 -0700

    staging: comedi: ni_stc.h: tidy up DIO_Output_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 88fd44aa4c70..d8c4d60670b7 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -323,10 +323,10 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AI_CMD1_REG]		= { 0x110, 2 },
 	[NISTC_AO_CMD1_REG]		= { 0x112, 2 },
 	/*
-	 * DIO_Output_Register maps to:
+	 * NISTC_DIO_OUT_REG maps to:
 	 * { NI_M_DIO_REG, 4 } and { NI_M_SCXI_SER_DO_REG, 1 }
 	 */
-	[DIO_Output_Register]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
+	[NISTC_DIO_OUT_REG]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
 	[DIO_Control_Register]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
 	[AI_Mode_1_Register]		= { 0x118, 2 },
 	[AI_Mode_2_Register]		= { 0x11a, 2 },
@@ -3280,13 +3280,14 @@ static int ni_dio_insn_bits(struct comedi_device *dev,
 	struct ni_private *devpriv = dev->private;
 
 	/* Make sure we're not using the serial part of the dio */
-	if ((data[0] & (DIO_SDIN | DIO_SDOUT)) && devpriv->serial_interval_ns)
+	if ((data[0] & (NISTC_DIO_SDIN | NISTC_DIO_SDOUT)) &&
+	    devpriv->serial_interval_ns)
 		return -EBUSY;
 
 	if (comedi_dio_update_state(s, data)) {
-		devpriv->dio_output &= ~DIO_Parallel_Data_Mask;
-		devpriv->dio_output |= DIO_Parallel_Data_Out(s->state);
-		ni_stc_writew(dev, devpriv->dio_output, DIO_Output_Register);
+		devpriv->dio_output &= ~NISTC_DIO_OUT_PARALLEL_MASK;
+		devpriv->dio_output |= NISTC_DIO_OUT_PARALLEL(s->state);
+		ni_stc_writew(dev, devpriv->dio_output, NISTC_DIO_OUT_REG);
 	}
 
 	data[1] = ni_stc_readw(dev, DIO_Parallel_Input_Register);
@@ -3543,9 +3544,9 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 	unsigned int status1;
 	int err = 0, count = 20;
 
-	devpriv->dio_output &= ~DIO_Serial_Data_Mask;
-	devpriv->dio_output |= DIO_Serial_Data_Out(data_out);
-	ni_stc_writew(dev, devpriv->dio_output, DIO_Output_Register);
+	devpriv->dio_output &= ~NISTC_DIO_OUT_SERIAL_MASK;
+	devpriv->dio_output |= NISTC_DIO_OUT_SERIAL(data_out);
+	ni_stc_writew(dev, devpriv->dio_output, NISTC_DIO_OUT_REG);
 
 	status1 = ni_stc_readw(dev, Joint_Status_1_Register);
 	if (status1 & DIO_Serial_IO_In_Progress_St) {
@@ -3598,10 +3599,10 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 		/* Output current bit; note that we cannot touch s->state
 		   because it is a per-subdevice field, and serial is
 		   a separate subdevice from DIO. */
-		devpriv->dio_output &= ~DIO_SDOUT;
+		devpriv->dio_output &= ~NISTC_DIO_SDOUT;
 		if (data_out & mask)
-			devpriv->dio_output |= DIO_SDOUT;
-		ni_stc_writew(dev, devpriv->dio_output, DIO_Output_Register);
+			devpriv->dio_output |= NISTC_DIO_SDOUT;
+		ni_stc_writew(dev, devpriv->dio_output, NISTC_DIO_OUT_REG);
 
 		/* Assert SDCLK (active low, inverted), wait for half of
 		   the delay, deassert SDCLK, and wait for the other half. */
@@ -3616,7 +3617,8 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
 		/* Input current bit */
-		if (ni_stc_readw(dev, DIO_Parallel_Input_Register) & DIO_SDIN)
+		if (ni_stc_readw(dev, DIO_Parallel_Input_Register) &
+		    NISTC_DIO_SDIN)
 			input |= mask;
 	}
 

commit 7bfcc2d4cd676ec5b29799a1865c25f48489c869
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:59:00 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_Command_1_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2e017dc62af6..88fd44aa4c70 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -321,7 +321,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_G0_CMD_REG]		= { 0x10c, 2 },
 	[NISTC_G1_CMD_REG]		= { 0x10e, 2 },
 	[NISTC_AI_CMD1_REG]		= { 0x110, 2 },
-	[AO_Command_1_Register]		= { 0x112, 2 },
+	[NISTC_AO_CMD1_REG]		= { 0x112, 2 },
 	/*
 	 * DIO_Output_Register maps to:
 	 * { NI_M_DIO_REG, 4 } and { NI_M_SCXI_SER_DO_REG, 1 }
@@ -2906,10 +2906,13 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 
 	ni_set_bits(dev, Interrupt_B_Enable_Register, interrupt_b_bits, 1);
 
-	ni_stc_writew(dev, devpriv->ao_cmd1 |
-		      AO_UI_Arm | AO_UC_Arm | AO_BC_Arm |
-		      AO_DAC1_Update_Mode | AO_DAC0_Update_Mode,
-		      AO_Command_1_Register);
+	ni_stc_writew(dev, NISTC_AO_CMD1_UI_ARM |
+			   NISTC_AO_CMD1_UC_ARM |
+			   NISTC_AO_CMD1_BC_ARM |
+			   NISTC_AO_CMD1_DAC1_UPDATE_MODE |
+			   NISTC_AO_CMD1_DAC0_UPDATE_MODE |
+			   devpriv->ao_cmd1,
+		      NISTC_AO_CMD1_REG);
 
 	ni_stc_writew(dev, NISTC_AO_CMD2_START1_PULSE | devpriv->ao_cmd2,
 		      NISTC_AO_CMD2_REG);
@@ -2933,7 +2936,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	ni_stc_writew(dev, AO_Configuration_Start, Joint_Reset_Register);
 
-	ni_stc_writew(dev, AO_Disarm, AO_Command_1_Register);
+	ni_stc_writew(dev, NISTC_AO_CMD1_DISARM, NISTC_AO_CMD1_REG);
 
 	if (devpriv->is_6xxx) {
 		ni_ao_win_outw(dev, CLEAR_WG, AO_Misc_611x);
@@ -2992,7 +2995,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_stc_writel(dev, 0xffffff, AO_BC_Load_A_Register);
 	else
 		ni_stc_writel(dev, 0, AO_BC_Load_A_Register);
-	ni_stc_writew(dev, AO_BC_Load, AO_Command_1_Register);
+	ni_stc_writew(dev, NISTC_AO_CMD1_BC_LOAD, NISTC_AO_CMD1_REG);
 	devpriv->ao_mode2 &= ~AO_UC_Initial_Load_Source;
 	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 	switch (cmd->stop_src) {
@@ -3001,23 +3004,25 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			/*  this is how the NI example code does it for m-series boards, verified correct with 6259 */
 			ni_stc_writel(dev, cmd->stop_arg - 1,
 				      AO_UC_Load_A_Register);
-			ni_stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
+			ni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD,
+				      NISTC_AO_CMD1_REG);
 		} else {
 			ni_stc_writel(dev, cmd->stop_arg,
 				      AO_UC_Load_A_Register);
-			ni_stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
+			ni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD,
+				      NISTC_AO_CMD1_REG);
 			ni_stc_writel(dev, cmd->stop_arg - 1,
 				      AO_UC_Load_A_Register);
 		}
 		break;
 	case TRIG_NONE:
 		ni_stc_writel(dev, 0xffffff, AO_UC_Load_A_Register);
-		ni_stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
+		ni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD, NISTC_AO_CMD1_REG);
 		ni_stc_writel(dev, 0xffffff, AO_UC_Load_A_Register);
 		break;
 	default:
 		ni_stc_writel(dev, 0, AO_UC_Load_A_Register);
-		ni_stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
+		ni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD, NISTC_AO_CMD1_REG);
 		ni_stc_writel(dev, cmd->stop_arg, AO_UC_Load_A_Register);
 	}
 
@@ -3031,7 +3036,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		    ni_ns_to_timer(dev, cmd->scan_begin_arg,
 				   CMDF_ROUND_NEAREST);
 		ni_stc_writel(dev, 1, AO_UI_Load_A_Register);
-		ni_stc_writew(dev, AO_UI_Load, AO_Command_1_Register);
+		ni_stc_writew(dev, NISTC_AO_CMD1_UI_LOAD, NISTC_AO_CMD1_REG);
 		ni_stc_writel(dev, trigvar, AO_UI_Load_A_Register);
 		break;
 	case TRIG_EXT:
@@ -3072,8 +3077,9 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	ni_stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 
-	ni_stc_writew(dev, AO_DAC0_Update_Mode | AO_DAC1_Update_Mode,
-		      AO_Command_1_Register);
+	ni_stc_writew(dev, NISTC_AO_CMD1_DAC1_UPDATE_MODE |
+			   NISTC_AO_CMD1_DAC0_UPDATE_MODE,
+		      NISTC_AO_CMD1_REG);
 
 	devpriv->ao_mode3 |= AO_Stop_On_Overrun_Error;
 	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
@@ -3207,7 +3213,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_release_ao_mite_channel(dev);
 
 	ni_stc_writew(dev, AO_Configuration_Start, Joint_Reset_Register);
-	ni_stc_writew(dev, AO_Disarm, AO_Command_1_Register);
+	ni_stc_writew(dev, NISTC_AO_CMD1_DISARM, NISTC_AO_CMD1_REG);
 	ni_set_bits(dev, Interrupt_B_Enable_Register, ~0, 0);
 	ni_stc_writew(dev, AO_BC_Source_Select, AO_Personal_Register);
 	ni_stc_writew(dev, NISTC_INTB_ACK_AO_ALL, NISTC_INTB_ACK_REG);
@@ -3216,7 +3222,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_stc_writew(dev, 0, AO_Output_Control_Register);
 	ni_stc_writew(dev, 0, AO_Start_Select_Register);
 	devpriv->ao_cmd1 = 0;
-	ni_stc_writew(dev, devpriv->ao_cmd1, AO_Command_1_Register);
+	ni_stc_writew(dev, devpriv->ao_cmd1, NISTC_AO_CMD1_REG);
 	devpriv->ao_cmd2 = 0;
 	ni_stc_writew(dev, devpriv->ao_cmd2, NISTC_AO_CMD2_REG);
 	devpriv->ao_mode1 = 0;

commit 4c4d715a7d482a8547abf1b1ab6a0fc24846c935
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:59 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_Command_1_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0ac17c88b54a..2e017dc62af6 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -320,7 +320,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_AO_CMD2_REG]		= { 0x10a, 2 },
 	[NISTC_G0_CMD_REG]		= { 0x10c, 2 },
 	[NISTC_G1_CMD_REG]		= { 0x10e, 2 },
-	[AI_Command_1_Register]		= { 0x110, 2 },
+	[NISTC_AI_CMD1_REG]		= { 0x110, 2 },
 	[AO_Command_1_Register]		= { 0x112, 2 },
 	/*
 	 * DIO_Output_Register maps to:
@@ -860,12 +860,12 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 #if 0
 			/* the NI example code does 3 convert pulses for 625x boards,
 			   but that appears to be wrong in practice. */
-			ni_stc_writew(dev, AI_CONVERT_Pulse,
-				      AI_Command_1_Register);
-			ni_stc_writew(dev, AI_CONVERT_Pulse,
-				      AI_Command_1_Register);
-			ni_stc_writew(dev, AI_CONVERT_Pulse,
-				      AI_Command_1_Register);
+			ni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,
+				      NISTC_AI_CMD1_REG);
+			ni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,
+				      NISTC_AI_CMD1_REG);
+			ni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,
+				      NISTC_AI_CMD1_REG);
 #endif
 		}
 	}
@@ -1629,7 +1629,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (!devpriv->is_6143)
 		ni_writeb(dev, 0, Misc_Command);
 
-	ni_stc_writew(dev, AI_Disarm, AI_Command_1_Register); /* reset pulses */
+	ni_stc_writew(dev, NISTC_AI_CMD1_DISARM, NISTC_AI_CMD1_REG);
 	ni_stc_writew(dev, AI_Start_Stop | AI_Mode_1_Reserved
 			    /*| AI_Trigger_Once */,
 		      AI_Mode_1_Register);
@@ -1727,7 +1727,7 @@ static void ni_prime_channelgain_list(struct comedi_device *dev)
 {
 	int i;
 
-	ni_stc_writew(dev, AI_CONVERT_Pulse, AI_Command_1_Register);
+	ni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE, NISTC_AI_CMD1_REG);
 	for (i = 0; i < NI_TIMEOUT; ++i) {
 		if (!(ni_stc_readw(dev, AI_Status_1_Register) &
 		      AI_FIFO_Empty_St)) {
@@ -1971,13 +1971,13 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 	signbits = devpriv->ai_offset[0];
 	if (devpriv->is_611x) {
 		for (n = 0; n < num_adc_stages_611x; n++) {
-			ni_stc_writew(dev, AI_CONVERT_Pulse,
-				      AI_Command_1_Register);
+			ni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,
+				      NISTC_AI_CMD1_REG);
 			udelay(1);
 		}
 		for (n = 0; n < insn->n; n++) {
-			ni_stc_writew(dev, AI_CONVERT_Pulse,
-				      AI_Command_1_Register);
+			ni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,
+				      NISTC_AI_CMD1_REG);
 			/* The 611x has screwy 32-bit FIFOs. */
 			d = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
@@ -2003,8 +2003,8 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 		}
 	} else if (devpriv->is_6143) {
 		for (n = 0; n < insn->n; n++) {
-			ni_stc_writew(dev, AI_CONVERT_Pulse,
-				      AI_Command_1_Register);
+			ni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,
+				      NISTC_AI_CMD1_REG);
 
 			/* The 6143 has 32-bit FIFOs. You need to strobe a bit to move a single 16bit stranded sample into the FIFO */
 			dl = 0;
@@ -2025,8 +2025,8 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 		}
 	} else {
 		for (n = 0; n < insn->n; n++) {
-			ni_stc_writew(dev, AI_CONVERT_Pulse,
-				      AI_Command_1_Register);
+			ni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,
+				      NISTC_AI_CMD1_REG);
 			for (i = 0; i < NI_TIMEOUT; i++) {
 				if (!(ni_stc_readw(dev, AI_Status_1_Register) &
 				      AI_FIFO_Empty_St))
@@ -2341,7 +2341,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		mode1 |= AI_Start_Stop | AI_Mode_1_Reserved | AI_Trigger_Once;
 		ni_stc_writew(dev, mode1, AI_Mode_1_Register);
 		/* load SC (Scan Count) */
-		ni_stc_writew(dev, AI_SC_Load, AI_Command_1_Register);
+		ni_stc_writew(dev, NISTC_AI_CMD1_SC_LOAD, NISTC_AI_CMD1_REG);
 
 		if (stop_count == 0) {
 			devpriv->ai_cmd2 |= NISTC_AI_CMD2_END_ON_EOS;
@@ -2360,7 +2360,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_stc_writew(dev, mode1, AI_Mode_1_Register);
 
 		/* load SC (Scan Count) */
-		ni_stc_writew(dev, AI_SC_Load, AI_Command_1_Register);
+		ni_stc_writew(dev, NISTC_AI_CMD1_SC_LOAD, NISTC_AI_CMD1_REG);
 		break;
 	}
 
@@ -2394,7 +2394,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		timer = ni_ns_to_timer(dev, cmd->scan_begin_arg,
 				       CMDF_ROUND_NEAREST);
 		ni_stc_writel(dev, timer, AI_SI_Load_A_Registers);
-		ni_stc_writew(dev, AI_SI_Load, AI_Command_1_Register);
+		ni_stc_writew(dev, NISTC_AI_CMD1_SI_LOAD, NISTC_AI_CMD1_REG);
 		break;
 	case TRIG_EXT:
 		if (cmd->scan_begin_arg & CR_EDGE)
@@ -2431,8 +2431,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		mode2 |= AI_SI2_Reload_Mode;
 		ni_stc_writew(dev, mode2, AI_Mode_2_Register);
 
-		/* AI_SI2_Load */
-		ni_stc_writew(dev, AI_SI2_Load, AI_Command_1_Register);
+		ni_stc_writew(dev, NISTC_AI_CMD1_SI2_LOAD, NISTC_AI_CMD1_REG);
 
 		mode2 |= AI_SI2_Reload_Mode;	/*  alternate */
 		mode2 |= AI_SI2_Initial_Load_Source;	/*  B */
@@ -2515,15 +2514,18 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
-		ni_stc_writew(dev,
-			      AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm | AI_SC_Arm,
-			      AI_Command_1_Register);
+		ni_stc_writew(dev, NISTC_AI_CMD1_SI2_ARM |
+				   NISTC_AI_CMD1_SI_ARM |
+				   NISTC_AI_CMD1_DIV_ARM |
+				   NISTC_AI_CMD1_SC_ARM,
+			      NISTC_AI_CMD1_REG);
 		break;
 	case TRIG_EXT:
-		/* XXX AI_SI_Arm? */
-		ni_stc_writew(dev,
-			      AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm | AI_SC_Arm,
-			      AI_Command_1_Register);
+		ni_stc_writew(dev, NISTC_AI_CMD1_SI2_ARM |
+				   NISTC_AI_CMD1_SI_ARM |	/* XXX ? */
+				   NISTC_AI_CMD1_DIV_ARM |
+				   NISTC_AI_CMD1_SC_ARM,
+			      NISTC_AI_CMD1_REG);
 		break;
 	}
 

commit 5fa2fa44af1930f1d3f84f8cfbca95a0a80547e7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:58 2015 -0700

    staging: comedi: ni_stc.h: tidy up G_Command_Register
    
    Rename the CamelCase and define the G0 and G1 registers to add clarity
    to the mio_regmap tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 45d16d7bd58f..0ac17c88b54a 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -318,8 +318,8 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_INTB_ACK_REG]		= { 0x106, 2 },
 	[NISTC_AI_CMD2_REG]		= { 0x108, 2 },
 	[NISTC_AO_CMD2_REG]		= { 0x10a, 2 },
-	[G_Command_Register(0)]		= { 0x10c, 2 },
-	[G_Command_Register(1)]		= { 0x10e, 2 },
+	[NISTC_G0_CMD_REG]		= { 0x10c, 2 },
+	[NISTC_G1_CMD_REG]		= { 0x10e, 2 },
 	[AI_Command_1_Register]		= { 0x110, 2 },
 	[AO_Command_1_Register]		= { 0x112, 2 },
 	/*
@@ -3720,8 +3720,8 @@ static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)
 static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G0_AUTO_INC]	= { G_Autoincrement_Register(0), 2 },
 	[NITIO_G1_AUTO_INC]	= { G_Autoincrement_Register(1), 2 },
-	[NITIO_G0_CMD]		= { G_Command_Register(0), 2 },
-	[NITIO_G1_CMD]		= { G_Command_Register(1), 2 },
+	[NITIO_G0_CMD]		= { NISTC_G0_CMD_REG, 2 },
+	[NITIO_G1_CMD]		= { NISTC_G1_CMD_REG, 2 },
 	[NITIO_G0_HW_SAVE]	= { G_HW_Save_Register(0), 4 },
 	[NITIO_G1_HW_SAVE]	= { G_HW_Save_Register(1), 4 },
 	[NITIO_G0_SW_SAVE]	= { G_Save_Register(0), 4 },

commit 382b3c4f9a9ed7ce8b019b41cd3ba505426665c8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:57 2015 -0700

    staging: comedi: ni_stc.h: tidy up AO_Command_2_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 6c545a9de903..45d16d7bd58f 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -317,7 +317,7 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_INTA_ACK_REG]		= { 0x104, 2 },
 	[NISTC_INTB_ACK_REG]		= { 0x106, 2 },
 	[NISTC_AI_CMD2_REG]		= { 0x108, 2 },
-	[AO_Command_2_Register]		= { 0x10a, 2 },
+	[NISTC_AO_CMD2_REG]		= { 0x10a, 2 },
 	[G_Command_Register(0)]		= { 0x10c, 2 },
 	[G_Command_Register(1)]		= { 0x10e, 2 },
 	[AI_Command_1_Register]		= { 0x110, 2 },
@@ -2909,8 +2909,8 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 		      AO_DAC1_Update_Mode | AO_DAC0_Update_Mode,
 		      AO_Command_1_Register);
 
-	ni_stc_writew(dev, devpriv->ao_cmd2 | AO_START1_Pulse,
-		      AO_Command_2_Register);
+	ni_stc_writew(dev, NISTC_AO_CMD2_START1_PULSE | devpriv->ao_cmd2,
+		      NISTC_AO_CMD2_REG);
 
 	return 0;
 }
@@ -3024,7 +3024,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	      AO_UPDATE_Source_Select(0x1f) | AO_UPDATE_Source_Polarity);
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
-		devpriv->ao_cmd2 &= ~AO_BC_Gate_Enable;
+		devpriv->ao_cmd2 &= ~NISTC_AO_CMD2_BC_GATE_ENA;
 		trigvar =
 		    ni_ns_to_timer(dev, cmd->scan_begin_arg,
 				   CMDF_ROUND_NEAREST);
@@ -3037,13 +3037,13 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		    AO_UPDATE_Source_Select(cmd->scan_begin_arg);
 		if (cmd->scan_begin_arg & CR_INVERT)
 			devpriv->ao_mode1 |= AO_UPDATE_Source_Polarity;
-		devpriv->ao_cmd2 |= AO_BC_Gate_Enable;
+		devpriv->ao_cmd2 |= NISTC_AO_CMD2_BC_GATE_ENA;
 		break;
 	default:
 		BUG();
 		break;
 	}
-	ni_stc_writew(dev, devpriv->ao_cmd2, AO_Command_2_Register);
+	ni_stc_writew(dev, devpriv->ao_cmd2, NISTC_AO_CMD2_REG);
 	ni_stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 	devpriv->ao_mode2 &=
 	    ~(AO_UI_Reload_Mode(3) | AO_UI_Initial_Load_Source);
@@ -3216,7 +3216,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ao_cmd1 = 0;
 	ni_stc_writew(dev, devpriv->ao_cmd1, AO_Command_1_Register);
 	devpriv->ao_cmd2 = 0;
-	ni_stc_writew(dev, devpriv->ao_cmd2, AO_Command_2_Register);
+	ni_stc_writew(dev, devpriv->ao_cmd2, NISTC_AO_CMD2_REG);
 	devpriv->ao_mode1 = 0;
 	ni_stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 	devpriv->ao_mode2 = 0;

commit a1da35a5c549b5a75c77dfee289d0a38823e78cf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:56 2015 -0700

    staging: comedi: ni_stc.h: tidy up AI_Command_2_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index db6c6e4cddf4..6c545a9de903 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -316,7 +316,7 @@ struct mio_regmap {
 static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_INTA_ACK_REG]		= { 0x104, 2 },
 	[NISTC_INTB_ACK_REG]		= { 0x106, 2 },
-	[AI_Command_2_Register]		= { 0x108, 2 },
+	[NISTC_AI_CMD2_REG]		= { 0x108, 2 },
 	[AO_Command_2_Register]		= { 0x10a, 2 },
 	[G_Command_Register(0)]		= { 0x10c, 2 },
 	[G_Command_Register(1)]		= { 0x10e, 2 },
@@ -1315,8 +1315,8 @@ static void ni_handle_eos(struct comedi_device *dev, struct comedi_subdevice *s)
 		s->async->events |= COMEDI_CB_EOS;
 #endif
 	}
-	/* handle special case of single scan using AI_End_On_End_Of_Scan */
-	if ((devpriv->ai_cmd2 & AI_End_On_End_Of_Scan))
+	/* handle special case of single scan */
+	if (devpriv->ai_cmd2 & NISTC_AI_CMD2_END_ON_EOS)
 		shutdown_ai_command(dev);
 }
 
@@ -2253,8 +2253,8 @@ static int ni_ai_inttrig(struct comedi_device *dev,
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
-	ni_stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
-		      AI_Command_2_Register);
+	ni_stc_writew(dev, NISTC_AI_CMD2_START1_PULSE | devpriv->ai_cmd2,
+		      NISTC_AI_CMD2_REG);
 	s->async->inttrig = NULL;
 
 	return 1;
@@ -2344,7 +2344,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_stc_writew(dev, AI_SC_Load, AI_Command_1_Register);
 
 		if (stop_count == 0) {
-			devpriv->ai_cmd2 |= AI_End_On_End_Of_Scan;
+			devpriv->ai_cmd2 |= NISTC_AI_CMD2_END_ON_EOS;
 			interrupt_a_enable |= AI_STOP_Interrupt_Enable;
 			/*  this is required to get the last sample for chanlist_len > 1, not sure why */
 			if (cmd->chanlist_len > 1)
@@ -2460,8 +2460,8 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		interrupt_a_enable |= AI_FIFO_Interrupt_Enable;
 #endif
 
-		if (cmd->flags & CMDF_WAKE_EOS
-		    || (devpriv->ai_cmd2 & AI_End_On_End_Of_Scan)) {
+		if ((cmd->flags & CMDF_WAKE_EOS) ||
+		    (devpriv->ai_cmd2 & NISTC_AI_CMD2_END_ON_EOS)) {
 			/* wake on end-of-scan */
 			devpriv->aimode = AIMODE_SCAN;
 		} else {
@@ -2537,9 +2537,9 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 #endif
 
 	if (cmd->start_src == TRIG_NOW) {
-		/* AI_START1_Pulse */
-		ni_stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
-			      AI_Command_2_Register);
+		ni_stc_writew(dev, NISTC_AI_CMD2_START1_PULSE |
+				   devpriv->ai_cmd2,
+			      NISTC_AI_CMD2_REG);
 		s->async->inttrig = NULL;
 	} else if (cmd->start_src == TRIG_EXT) {
 		s->async->inttrig = NULL;

commit 4a6de8327d125158827ad72d6d07d674c98e0387
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:55 2015 -0700

    staging: comedi: ni_stc.h: tidy up Interrupt_B_Ack_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index f0be47ef5347..db6c6e4cddf4 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -315,7 +315,7 @@ struct mio_regmap {
 
 static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[NISTC_INTA_ACK_REG]		= { 0x104, 2 },
-	[Interrupt_B_Ack_Register]	= { 0x106, 2 },
+	[NISTC_INTB_ACK_REG]		= { 0x106, 2 },
 	[AI_Command_2_Register]		= { 0x108, 2 },
 	[AO_Command_2_Register]		= { 0x10a, 2 },
 	[G_Command_Register(0)]		= { 0x10c, 2 },
@@ -1434,21 +1434,21 @@ static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
 	unsigned short ack = 0;
 
 	if (b_status & AO_BC_TC_St)
-		ack |= AO_BC_TC_Interrupt_Ack;
+		ack |= NISTC_INTB_ACK_AO_BC_TC;
 	if (b_status & AO_Overrun_St)
-		ack |= AO_Error_Interrupt_Ack;
+		ack |= NISTC_INTB_ACK_AO_ERR;
 	if (b_status & AO_START_St)
-		ack |= AO_START_Interrupt_Ack;
+		ack |= NISTC_INTB_ACK_AO_START;
 	if (b_status & AO_START1_St)
-		ack |= AO_START1_Interrupt_Ack;
+		ack |= NISTC_INTB_ACK_AO_START1;
 	if (b_status & AO_UC_TC_St)
-		ack |= AO_UC_TC_Interrupt_Ack;
+		ack |= NISTC_INTB_ACK_AO_UC_TC;
 	if (b_status & AO_UI2_TC_St)
-		ack |= AO_UI2_TC_Interrupt_Ack;
+		ack |= NISTC_INTB_ACK_AO_UI2_TC;
 	if (b_status & AO_UPDATE_St)
-		ack |= AO_UPDATE_Interrupt_Ack;
+		ack |= NISTC_INTB_ACK_AO_UPDATE;
 	if (ack)
-		ni_stc_writew(dev, ack, Interrupt_B_Ack_Register);
+		ni_stc_writew(dev, ack, NISTC_INTB_ACK_REG);
 }
 
 static void handle_b_interrupt(struct comedi_device *dev,
@@ -2900,7 +2900,7 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 	 * stc manual says we are need to clear error interrupt after
 	 * AO_TMRDACWRs_In_Progress_St clears
 	 */
-	ni_stc_writew(dev, AO_Error_Interrupt_Ack, Interrupt_B_Ack_Register);
+	ni_stc_writew(dev, NISTC_INTB_ACK_AO_ERR, NISTC_INTB_ACK_REG);
 
 	ni_set_bits(dev, Interrupt_B_Enable_Register, interrupt_b_bits, 1);
 
@@ -3104,8 +3104,8 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		ni_stc_writew(dev, AO_BC_TC_Interrupt_Ack,
-			      Interrupt_B_Ack_Register);
+		ni_stc_writew(dev, NISTC_INTB_ACK_AO_BC_TC,
+			      NISTC_INTB_ACK_REG);
 		ni_set_bits(dev, Interrupt_B_Enable_Register,
 			    AO_BC_TC_Interrupt_Enable, 1);
 	}
@@ -3208,7 +3208,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_stc_writew(dev, AO_Disarm, AO_Command_1_Register);
 	ni_set_bits(dev, Interrupt_B_Enable_Register, ~0, 0);
 	ni_stc_writew(dev, AO_BC_Source_Select, AO_Personal_Register);
-	ni_stc_writew(dev, 0x3f98, Interrupt_B_Ack_Register);
+	ni_stc_writew(dev, NISTC_INTB_ACK_AO_ALL, NISTC_INTB_ACK_REG);
 	ni_stc_writew(dev, AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
 		      AO_TMRDACWR_Pulse_Width, AO_Personal_Register);
 	ni_stc_writew(dev, 0, AO_Output_Control_Register);
@@ -3749,7 +3749,7 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G0_ABZ]		= { 0x1c0, 2 },	/* M-Series only */
 	[NITIO_G1_ABZ]		= { 0x1c2, 2 },	/* M-Series only */
 	[NITIO_G0_INT_ACK]	= { NISTC_INTA_ACK_REG, 2 },
-	[NITIO_G1_INT_ACK]	= { Interrupt_B_Ack_Register, 2 },
+	[NITIO_G1_INT_ACK]	= { NISTC_INTB_ACK_REG, 2 },
 	[NITIO_G0_STATUS]	= { AI_Status_1_Register, 2 },
 	[NITIO_G1_STATUS]	= { AO_Status_1_Register, 2 },
 	[NITIO_G0_INT_ENA]	= { Interrupt_A_Enable_Register, 2 },

commit 480456d3d6f51e09c4a631afa983434ed7e35d15
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:54 2015 -0700

    staging: comedi: ni_stc.h: tidy up Interrupt_A_Ack_Register and bits
    
    Rename the CamelCase. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8a646b816cbb..f0be47ef5347 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -314,7 +314,7 @@ struct mio_regmap {
 };
 
 static const struct mio_regmap m_series_stc_write_regmap[] = {
-	[Interrupt_A_Ack_Register]	= { 0x104, 2 },
+	[NISTC_INTA_ACK_REG]		= { 0x104, 2 },
 	[Interrupt_B_Ack_Register]	= { 0x106, 2 },
 	[AI_Command_2_Register]		= { 0x108, 2 },
 	[AO_Command_2_Register]		= { 0x10a, 2 },
@@ -1340,16 +1340,15 @@ static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 	unsigned short ack = 0;
 
 	if (a_status & AI_SC_TC_St)
-		ack |= AI_SC_TC_Interrupt_Ack;
+		ack |= NISTC_INTA_ACK_AI_SC_TC;
 	if (a_status & AI_START1_St)
-		ack |= AI_START1_Interrupt_Ack;
+		ack |= NISTC_INTA_ACK_AI_START1;
 	if (a_status & AI_START_St)
-		ack |= AI_START_Interrupt_Ack;
+		ack |= NISTC_INTA_ACK_AI_START;
 	if (a_status & AI_STOP_St)
-		/* not sure why we used to ack the START here also, instead of doing it independently. Frank Hess 2007-07-06 */
-		ack |= AI_STOP_Interrupt_Ack /*| AI_START_Interrupt_Ack */;
+		ack |= NISTC_INTA_ACK_AI_STOP;
 	if (ack)
-		ni_stc_writew(dev, ack, Interrupt_A_Ack_Register);
+		ni_stc_writew(dev, ack, NISTC_INTA_ACK_REG);
 }
 
 static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
@@ -1697,15 +1696,9 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	 *      AI_Personal_Register
 	 *      AI_Output_Control_Register
 	 */
-	ni_stc_writew(dev,
-		      AI_SC_TC_Error_Confirm |
-		      AI_START_Interrupt_Ack |
-		      AI_START2_Interrupt_Ack |
-		      AI_START1_Interrupt_Ack |
-		      AI_SC_TC_Interrupt_Ack |
-		      AI_Error_Interrupt_Ack |
-		      AI_STOP_Interrupt_Ack,
-		      Interrupt_A_Ack_Register);	/* clear interrupts */
+
+	/* clear interrupts */
+	ni_stc_writew(dev, NISTC_INTA_ACK_AI_ALL, NISTC_INTA_ACK_REG);
 
 	ni_stc_writew(dev, AI_Configuration_End, Joint_Reset_Register);
 
@@ -2506,15 +2499,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		}
 
 		/* clear interrupts */
-		ni_stc_writew(dev,
-			      AI_Error_Interrupt_Ack |
-			      AI_STOP_Interrupt_Ack |
-			      AI_START_Interrupt_Ack |
-			      AI_START2_Interrupt_Ack |
-			      AI_START1_Interrupt_Ack |
-			      AI_SC_TC_Interrupt_Ack |
-			      AI_SC_TC_Error_Confirm,
-			      Interrupt_A_Ack_Register);
+		ni_stc_writew(dev, NISTC_INTA_ACK_AI_ALL, NISTC_INTA_ACK_REG);
 
 		ni_set_bits(dev, Interrupt_A_Enable_Register,
 			    interrupt_a_enable, 1);
@@ -3763,7 +3748,7 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G1_DMA_STATUS]	= { 0x1ba, 2 },	/* M-Series only */
 	[NITIO_G0_ABZ]		= { 0x1c0, 2 },	/* M-Series only */
 	[NITIO_G1_ABZ]		= { 0x1c2, 2 },	/* M-Series only */
-	[NITIO_G0_INT_ACK]	= { Interrupt_A_Ack_Register, 2 },
+	[NITIO_G0_INT_ACK]	= { NISTC_INTA_ACK_REG, 2 },
 	[NITIO_G1_INT_ACK]	= { Interrupt_B_Ack_Register, 2 },
 	[NITIO_G0_STATUS]	= { AI_Status_1_Register, 2 },
 	[NITIO_G1_STATUS]	= { AO_Status_1_Register, 2 },

commit b81ddcc3c9e09ba73af2b18dfaf910d40125b6cd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:53 2015 -0700

    staging: comedi: ni_mio_common: remove disabled GPCT functions
    
    The GPCT (general purpose counter timer) is handled by the ni_tio and
    ni_tiocmd modules. Remove the old disabled code in this file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 1ecbb3cf7fea..8a646b816cbb 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5018,88 +5018,6 @@ static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 #endif
 
-#if 0
-/*
- *	Read the GPCTs current value.
- */
-static int GPCT_G_Watch(struct comedi_device *dev, int chan)
-{
-	unsigned int hi1, hi2, lo;
-
-	devpriv->gpct_command[chan] &= ~G_Save_Trace;
-	ni_stc_writew(dev, devpriv->gpct_command[chan],
-		      G_Command_Register(chan));
-
-	devpriv->gpct_command[chan] |= G_Save_Trace;
-	ni_stc_writew(dev, devpriv->gpct_command[chan],
-		      G_Command_Register(chan));
-
-	/* This procedure is used because the two registers cannot
-	 * be read atomically. */
-	do {
-		hi1 = ni_stc_readw(dev, G_Save_Register_High(chan));
-		lo = ni_stc_readw(dev, G_Save_Register_Low(chan));
-		hi2 = ni_stc_readw(dev, G_Save_Register_High(chan));
-	} while (hi1 != hi2);
-
-	return (hi1 << 16) | lo;
-}
-
-static void GPCT_Reset(struct comedi_device *dev, int chan)
-{
-	int temp_ack_reg = 0;
-
-	devpriv->gpct_cur_operation[chan] = GPCT_RESET;
-
-	switch (chan) {
-	case 0:
-		ni_stc_writew(dev, G0_Reset, Joint_Reset_Register);
-		ni_set_bits(dev, Interrupt_A_Enable_Register,
-			    G0_TC_Interrupt_Enable, 0);
-		ni_set_bits(dev, Interrupt_A_Enable_Register,
-			    G0_Gate_Interrupt_Enable, 0);
-		temp_ack_reg |= G0_Gate_Error_Confirm;
-		temp_ack_reg |= G0_TC_Error_Confirm;
-		temp_ack_reg |= G0_TC_Interrupt_Ack;
-		temp_ack_reg |= G0_Gate_Interrupt_Ack;
-		ni_stc_writew(dev, temp_ack_reg, Interrupt_A_Ack_Register);
-
-		/* problem...this interferes with the other ctr... */
-		devpriv->an_trig_etc_reg |= GPFO_0_Output_Enable;
-		ni_stc_writew(dev, devpriv->an_trig_etc_reg,
-			      Analog_Trigger_Etc_Register);
-		break;
-	case 1:
-		ni_stc_writew(dev, G1_Reset, Joint_Reset_Register);
-		ni_set_bits(dev, Interrupt_B_Enable_Register,
-			    G1_TC_Interrupt_Enable, 0);
-		ni_set_bits(dev, Interrupt_B_Enable_Register,
-			    G0_Gate_Interrupt_Enable, 0);
-		temp_ack_reg |= G1_Gate_Error_Confirm;
-		temp_ack_reg |= G1_TC_Error_Confirm;
-		temp_ack_reg |= G1_TC_Interrupt_Ack;
-		temp_ack_reg |= G1_Gate_Interrupt_Ack;
-		ni_stc_writew(dev, temp_ack_reg, Interrupt_B_Ack_Register);
-
-		devpriv->an_trig_etc_reg |= GPFO_1_Output_Enable;
-		ni_stc_writew(dev, devpriv->an_trig_etc_reg,
-			      Analog_Trigger_Etc_Register);
-		break;
-	}
-
-	devpriv->gpct_mode[chan] = 0;
-	devpriv->gpct_input_select[chan] = 0;
-	devpriv->gpct_command[chan] = 0;
-
-	devpriv->gpct_command[chan] |= G_Synchronized_Gate;
-
-	ni_stc_writew(dev, devpriv->gpct_mode[chan], G_Mode_Register(chan));
-	ni_stc_writew(dev, devpriv->gpct_input_select[chan],
-		      G_Input_Select_Register(chan));
-	ni_stc_writew(dev, 0, G_Autoincrement_Register(chan));
-}
-#endif
-
 static irqreturn_t ni_E_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;

commit 60f078f974b24c10414b10f518996108a80fd1b1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:51 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_INTC_ENA_REG bits
    
    Rename the CamelCase and convert enums into defines. Use the BIT()
    macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e8c6fff81c40..1ecbb3cf7fea 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3433,7 +3433,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 	/*
 	 * XXX not sure what interrupt C group does
 	 * wait for dma to fill output fifo
-	 * ni_writeb(dev, Interrupt_Group_C_Enable_Bit, NI_M_INTC_ENA_REG);
+	 * ni_writeb(dev, NI_M_INTC_ENA, NI_M_INTC_ENA_REG);
 	 */
 	for (i = 0; i < timeout; ++i) {
 		if (ni_readl(dev, NI_M_CDIO_STATUS_REG) &

commit 258f004754c436c31447123b9f2f8337e35b8037
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:50 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_CDO_MODE_REG bits
    
    Rename the CamelCase and convert enums into defines. Use the BIT()
    macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index cbfbfa5ab752..e8c6fff81c40 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3371,7 +3371,7 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	tmp = cmd->scan_begin_arg;
-	tmp &= CR_PACK_FLAGS(CDO_Sample_Source_Select_Mask, 0, 0, CR_INVERT);
+	tmp &= CR_PACK_FLAGS(NI_M_CDO_MODE_SAMPLE_SRC_MASK, 0, 0, CR_INVERT);
 	if (tmp != cmd->scan_begin_arg)
 		err |= -EINVAL;
 
@@ -3456,14 +3456,15 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;
+	unsigned cdo_mode_bits;
 	int retval;
 
 	ni_writel(dev, NI_M_CDO_CMD_RESET, NI_M_CDIO_CMD_REG);
-	cdo_mode_bits |= CR_CHAN(cmd->scan_begin_arg) &
-			 CDO_Sample_Source_Select_Mask;
+	cdo_mode_bits = NI_M_CDO_MODE_FIFO_MODE |
+			NI_M_CDO_MODE_HALT_ON_ERROR |
+			NI_M_CDO_MODE_SAMPLE_SRC(CR_CHAN(cmd->scan_begin_arg));
 	if (cmd->scan_begin_arg & CR_INVERT)
-		cdo_mode_bits |= CDO_Polarity_Bit;
+		cdo_mode_bits |= NI_M_CDO_MODE_POLARITY;
 	ni_writel(dev, cdo_mode_bits, NI_M_CDO_MODE_REG);
 	if (s->io_bits) {
 		ni_writel(dev, s->state, NI_M_CDO_FIFO_DATA_REG);

commit b9abc4aa75197f48d54092f36576249312dff55a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:49 2015 -0700

    staging: comedi: ni_mio_common: remove BUG() check in ni_cdio_cmd()
    
    The cmd->scan_begin_src was validated in ni_cdio_cmdtest() and can only
    be TRIG_EXT. Remove the switch statement and unnecessary BUG() check.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index acba13847c29..cbfbfa5ab752 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3460,16 +3460,8 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int retval;
 
 	ni_writel(dev, NI_M_CDO_CMD_RESET, NI_M_CDIO_CMD_REG);
-	switch (cmd->scan_begin_src) {
-	case TRIG_EXT:
-		cdo_mode_bits |=
-		    CR_CHAN(cmd->scan_begin_arg) &
-		    CDO_Sample_Source_Select_Mask;
-		break;
-	default:
-		BUG();
-		break;
-	}
+	cdo_mode_bits |= CR_CHAN(cmd->scan_begin_arg) &
+			 CDO_Sample_Source_Select_Mask;
 	if (cmd->scan_begin_arg & CR_INVERT)
 		cdo_mode_bits |= CDO_Polarity_Bit;
 	ni_writel(dev, cdo_mode_bits, NI_M_CDO_MODE_REG);

commit 3c3eb8eaa75fc698f4edb7517830b112f51c11d0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:47 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_CDIO_CMD_REG bits
    
    Rename the CamelCase and convert enums into defines. Use the BIT()
    macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8cdcc1b600f6..acba13847c29 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3446,8 +3446,9 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 		s->cancel(dev, s);
 		return -EIO;
 	}
-	ni_writel(dev, CDO_Arm_Bit | CDO_Error_Interrupt_Enable_Set_Bit |
-		       CDO_Empty_FIFO_Interrupt_Enable_Set_Bit,
+	ni_writel(dev, NI_M_CDO_CMD_ARM |
+		       NI_M_CDO_CMD_ERR_INT_ENA_SET |
+		       NI_M_CDO_CMD_F_E_INT_ENA_SET,
 		  NI_M_CDIO_CMD_REG);
 	return retval;
 }
@@ -3458,7 +3459,7 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;
 	int retval;
 
-	ni_writel(dev, CDO_Reset_Bit, NI_M_CDIO_CMD_REG);
+	ni_writel(dev, NI_M_CDO_CMD_RESET, NI_M_CDIO_CMD_REG);
 	switch (cmd->scan_begin_src) {
 	case TRIG_EXT:
 		cdo_mode_bits |=
@@ -3474,7 +3475,7 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_writel(dev, cdo_mode_bits, NI_M_CDO_MODE_REG);
 	if (s->io_bits) {
 		ni_writel(dev, s->state, NI_M_CDO_FIFO_DATA_REG);
-		ni_writel(dev, CDO_SW_Update_Bit, NI_M_CDIO_CMD_REG);
+		ni_writel(dev, NI_M_CDO_CMD_SW_UPDATE, NI_M_CDIO_CMD_REG);
 		ni_writel(dev, s->io_bits, NI_M_CDO_MASK_ENA_REG);
 	} else {
 		dev_err(dev->class_dev,
@@ -3492,9 +3493,10 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	ni_writel(dev, CDO_Disarm_Bit | CDO_Error_Interrupt_Enable_Clear_Bit |
-		       CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
-		       CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
+	ni_writel(dev, NI_M_CDO_CMD_DISARM |
+		       NI_M_CDO_CMD_ERR_INT_ENA_CLR |
+		       NI_M_CDO_CMD_F_E_INT_ENA_CLR |
+		       NI_M_CDO_CMD_F_REQ_INT_ENA_CLR,
 		  NI_M_CDIO_CMD_REG);
 	/*
 	 * XXX not sure what interrupt C group does
@@ -3534,12 +3536,12 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	cdio_status = ni_readl(dev, NI_M_CDIO_STATUS_REG);
 	if (cdio_status & NI_M_CDIO_STATUS_CDO_ERROR) {
 		/* XXX just guessing this is needed and does something useful */
-		ni_writel(dev, CDO_Error_Interrupt_Confirm_Bit,
+		ni_writel(dev, NI_M_CDO_CMD_ERR_INT_CONFIRM,
 			  NI_M_CDIO_CMD_REG);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 	if (cdio_status & NI_M_CDIO_STATUS_CDO_FIFO_EMPTY) {
-		ni_writel(dev, CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
+		ni_writel(dev, NI_M_CDO_CMD_F_E_INT_ENA_CLR,
 			  NI_M_CDIO_CMD_REG);
 		/* s->async->events |= COMEDI_CB_EOA; */
 	}
@@ -5313,7 +5315,8 @@ static int ni_E_init(struct comedi_device *dev,
 		}
 
 		/* reset DIO and set all channels to inputs */
-		ni_writel(dev, CDO_Reset_Bit | CDI_Reset_Bit,
+		ni_writel(dev, NI_M_CDO_CMD_RESET |
+			       NI_M_CDI_CMD_RESET,
 			  NI_M_CDIO_CMD_REG);
 		ni_writel(dev, s->io_bits, NI_M_DIO_DIR_REG);
 	} else {

commit d53be924c8260266b72244c92399ec68d2eb8871
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:46 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_CDIO_STATUS_REG bits
    
    Rename the CamelCase and convert enums into defines. Use the BIT()
    macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2b9790ed6945..8cdcc1b600f6 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3436,7 +3436,8 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 	 * ni_writeb(dev, Interrupt_Group_C_Enable_Bit, NI_M_INTC_ENA_REG);
 	 */
 	for (i = 0; i < timeout; ++i) {
-		if (ni_readl(dev, NI_M_CDIO_STATUS_REG) & CDO_FIFO_Full_Bit)
+		if (ni_readl(dev, NI_M_CDIO_STATUS_REG) &
+		    NI_M_CDIO_STATUS_CDO_FIFO_FULL)
 			break;
 		udelay(10);
 	}
@@ -3531,13 +3532,13 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 #endif
 
 	cdio_status = ni_readl(dev, NI_M_CDIO_STATUS_REG);
-	if (cdio_status & (CDO_Overrun_Bit | CDO_Underflow_Bit)) {
+	if (cdio_status & NI_M_CDIO_STATUS_CDO_ERROR) {
 		/* XXX just guessing this is needed and does something useful */
 		ni_writel(dev, CDO_Error_Interrupt_Confirm_Bit,
 			  NI_M_CDIO_CMD_REG);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
-	if (cdio_status & CDO_FIFO_Empty_Bit) {
+	if (cdio_status & NI_M_CDIO_STATUS_CDO_FIFO_EMPTY) {
 		ni_writel(dev, CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
 			  NI_M_CDIO_CMD_REG);
 		/* s->async->events |= COMEDI_CB_EOA; */

commit 2dd0825fb4e53ee23f2391cc7c5b4afee8b1c8e1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:45 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_CDIO_DMA_SEL_REG bits
    
    Rename the CamelCase and convert enums into macros to set the
    bits in this register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index f1299aed2850..2b9790ed6945 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -621,16 +621,19 @@ static inline void ni_set_cdo_dma_channel(struct comedi_device *dev,
 {
 	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
+	unsigned bits;
 
 	spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
-	devpriv->cdio_dma_select_reg &= ~CDO_DMA_Select_Mask;
+	devpriv->cdio_dma_select_reg &= ~NI_M_CDIO_DMA_SEL_CDO_MASK;
 	if (mite_channel >= 0) {
-		/*XXX just guessing ni_stc_dma_channel_select_bitfield() returns the right bits,
-		   under the assumption the cdio dma selection works just like ai/ao/gpct.
-		   Definitely works for dma channels 0 and 1. */
-		devpriv->cdio_dma_select_reg |=
-		    (ni_stc_dma_channel_select_bitfield(mite_channel) <<
-		     CDO_DMA_Select_Shift) & CDO_DMA_Select_Mask;
+		/*
+		 * XXX just guessing ni_stc_dma_channel_select_bitfield()
+		 * returns the right bits, under the assumption the cdio dma
+		 * selection works just like ai/ao/gpct.
+		 * Definitely works for dma channels 0 and 1.
+		 */
+		bits = ni_stc_dma_channel_select_bitfield(mite_channel);
+		devpriv->cdio_dma_select_reg |= NI_M_CDIO_DMA_SEL_CDO(bits);
 	}
 	ni_writeb(dev, devpriv->cdio_dma_select_reg, NI_M_CDIO_DMA_SEL_REG);
 	mmiowb();

commit 0dee7ecc4dac113469b42d75f314d94e62c834a5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:44 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_PFI_FILTER_REG bits
    
    Rename the CamelCase and convert the inline helper functions
    that set the bits in this register to macros.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 740a92c4b98f..f1299aed2850 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4419,8 +4419,8 @@ static int ni_config_filter(struct comedi_device *dev,
 		return -ENOTSUPP;
 
 	bits = ni_readl(dev, NI_M_PFI_FILTER_REG);
-	bits &= ~MSeries_PFI_Filter_Select_Mask(pfi_channel);
-	bits |= MSeries_PFI_Filter_Select_Bits(pfi_channel, filter);
+	bits &= ~NI_M_PFI_FILTER_SEL_MASK(pfi_channel);
+	bits |= NI_M_PFI_FILTER_SEL(pfi_channel, filter);
 	ni_writel(dev, bits, NI_M_PFI_FILTER_REG);
 	return 0;
 }

commit 43e9d883f02a57fe989ebd568e2508f7f4da25ef
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:43 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_PFI_OUT_SEL_REG bits
    
    Rename the CamelCase and convert the inline helper functions
    that set/get the bits in this register to macros.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index af095e621e9f..740a92c4b98f 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4367,7 +4367,7 @@ static unsigned ni_m_series_get_pfi_routing(struct comedi_device *dev,
 	struct ni_private *devpriv = dev->private;
 	const unsigned array_offset = chan / 3;
 
-	return MSeries_PFI_Output_Select_Source(chan,
+	return NI_M_PFI_OUT_SEL_TO_SRC(chan,
 				devpriv->pfi_output_select_reg[array_offset]);
 }
 
@@ -4381,8 +4381,8 @@ static int ni_m_series_set_pfi_routing(struct comedi_device *dev,
 	if ((source & 0x1f) != source)
 		return -EINVAL;
 
-	val &= ~MSeries_PFI_Output_Select_Mask(chan);
-	val |= MSeries_PFI_Output_Select_Bits(chan, source);
+	val &= ~NI_M_PFI_OUT_SEL_MASK(chan);
+	val |= NI_M_PFI_OUT_SEL(chan, source);
 	ni_writew(dev, val, NI_M_PFI_OUT_SEL_REG(index));
 	devpriv->pfi_output_select_reg[index] = val;
 

commit cc679f9746ea1fbdc00b53deda3c1dc6edc8d5f3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:42 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_CAL_PWM_REG bits
    
    Rename the CamelCase and convert the inline helper functions
    that set the bits in this register to macros.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c100c0875e75..af095e621e9f 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4016,8 +4016,8 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 			data[4] = down_count * devpriv->clock_ns;
 			return -EAGAIN;
 		}
-		ni_writel(dev, MSeries_Cal_PWM_High_Time_Bits(up_count) |
-			       MSeries_Cal_PWM_Low_Time_Bits(down_count),
+		ni_writel(dev, NI_M_CAL_PWM_HIGH_TIME(up_count) |
+			       NI_M_CAL_PWM_LOW_TIME(down_count),
 			  NI_M_CAL_PWM_REG);
 		devpriv->pwm_up_count = up_count;
 		devpriv->pwm_down_count = down_count;

commit b06afa15400182ee5d46b97462fc179ce36b0107
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:41 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_AO_REF_ATTENUATION_REG bits
    
    Rename the CamelCase and convert the enum into defines. Use the BIT()
    macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7f4e9d6df8fe..c100c0875e75 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2675,12 +2675,12 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 			break;
 		case 4000000:
 			conf |= NI_M_AO_CFG_BANK_REF_INT_10V;
-			ni_writeb(dev, MSeries_Attenuate_x5_Bit,
+			ni_writeb(dev, NI_M_AO_REF_ATTENUATION_X5,
 				  NI_M_AO_REF_ATTENUATION_REG(chan));
 			break;
 		case 2000000:
 			conf |= NI_M_AO_CFG_BANK_REF_INT_5V;
-			ni_writeb(dev, MSeries_Attenuate_x5_Bit,
+			ni_writeb(dev, NI_M_AO_REF_ATTENUATION_X5,
 				  NI_M_AO_REF_ATTENUATION_REG(chan));
 			break;
 		default:

commit bae453048752599aa4acedfc3b0c1244744ec2b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:40 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_AO_CFG_BANK_REG bits
    
    Rename the CamelCase and convert the enum into defines. Use the BIT()
    macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0853f0e2cf2c..7f4e9d6df8fe 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2650,7 +2650,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 
 	if (timed) {
 		for (i = 0; i < s->n_chan; ++i) {
-			devpriv->ao_conf[i] &= ~MSeries_AO_Update_Timed_Bit;
+			devpriv->ao_conf[i] &= ~NI_M_AO_CFG_BANK_UPDATE_TIMED;
 			ni_writeb(dev, devpriv->ao_conf[i],
 				  NI_M_AO_CFG_BANK_REG(i));
 			ni_writeb(dev, 0xf, NI_M_AO_WAVEFORM_ORDER_REG(i));
@@ -2666,20 +2666,20 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 		conf = 0;
 		switch (krange->max - krange->min) {
 		case 20000000:
-			conf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;
+			conf |= NI_M_AO_CFG_BANK_REF_INT_10V;
 			ni_writeb(dev, 0, NI_M_AO_REF_ATTENUATION_REG(chan));
 			break;
 		case 10000000:
-			conf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;
+			conf |= NI_M_AO_CFG_BANK_REF_INT_5V;
 			ni_writeb(dev, 0, NI_M_AO_REF_ATTENUATION_REG(chan));
 			break;
 		case 4000000:
-			conf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;
+			conf |= NI_M_AO_CFG_BANK_REF_INT_10V;
 			ni_writeb(dev, MSeries_Attenuate_x5_Bit,
 				  NI_M_AO_REF_ATTENUATION_REG(chan));
 			break;
 		case 2000000:
-			conf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;
+			conf |= NI_M_AO_CFG_BANK_REF_INT_5V;
 			ni_writeb(dev, MSeries_Attenuate_x5_Bit,
 				  NI_M_AO_REF_ATTENUATION_REG(chan));
 			break;
@@ -2690,10 +2690,10 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 		}
 		switch (krange->max + krange->min) {
 		case 0:
-			conf |= MSeries_AO_DAC_Offset_0V_Bits;
+			conf |= NI_M_AO_CFG_BANK_OFFSET_0V;
 			break;
 		case 10000000:
-			conf |= MSeries_AO_DAC_Offset_5V_Bits;
+			conf |= NI_M_AO_CFG_BANK_OFFSET_5V;
 			break;
 		default:
 			dev_err(dev->class_dev,
@@ -2701,7 +2701,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 			break;
 		}
 		if (timed)
-			conf |= MSeries_AO_Update_Timed_Bit;
+			conf |= NI_M_AO_CFG_BANK_UPDATE_TIMED;
 		ni_writeb(dev, conf, NI_M_AO_CFG_BANK_REG(chan));
 		devpriv->ao_conf[chan] = conf;
 		ni_writeb(dev, i, NI_M_AO_WAVEFORM_ORDER_REG(chan));

commit 41f9f0bfcf7ab2121dfeef0d8928421e214c4dee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:39 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_AI_CFG_BYPASS_FIFO_REG bits
    
    Rename the CamelCase and convert the enum into defines. Use the BIT()
    macro to define the bits. Convert the inline helper functions into
    macros.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index bb4fde0e777c..0853f0e2cf2c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1763,22 +1763,17 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 		range = CR_RANGE(list[0]);
 		range_code = ni_gainlkup[board->gainlkup][range];
 		dither = (list[0] & CR_ALT_FILTER) != 0;
-		bypass_bits = MSeries_AI_Bypass_Config_FIFO_Bit;
-		bypass_bits |= chan;
-		bypass_bits |=
-		    (devpriv->ai_calib_source) &
-		    (MSeries_AI_Bypass_Cal_Sel_Pos_Mask |
-		     MSeries_AI_Bypass_Cal_Sel_Neg_Mask |
-		     MSeries_AI_Bypass_Mode_Mux_Mask |
-		     MSeries_AO_Bypass_AO_Cal_Sel_Mask);
-		bypass_bits |= MSeries_AI_Bypass_Gain_Bits(range_code);
+		bypass_bits = NI_M_CFG_BYPASS_FIFO |
+			      NI_M_CFG_BYPASS_AI_CHAN(chan) |
+			      NI_M_CFG_BYPASS_AI_GAIN(range_code) |
+			      devpriv->ai_calib_source;
 		if (dither)
-			bypass_bits |= MSeries_AI_Bypass_Dither_Bit;
+			bypass_bits |= NI_M_CFG_BYPASS_AI_DITHER;
 		/*  don't use 2's complement encoding */
-		bypass_bits |= MSeries_AI_Bypass_Polarity_Bit;
-		ni_writel(dev, bypass_bits, NI_M_AI_CFG_BYPASS_FIFO_REG);
+		bypass_bits |= NI_M_CFG_BYPASS_AI_POLARITY;
+		ni_writel(dev, bypass_bits, NI_M_CFG_BYPASS_FIFO_REG);
 	} else {
-		ni_writel(dev, 0, NI_M_AI_CFG_BYPASS_FIFO_REG);
+		ni_writel(dev, 0, NI_M_CFG_BYPASS_FIFO_REG);
 	}
 	for (i = 0; i < n_chan; i++) {
 		unsigned config_bits = 0;
@@ -2579,12 +2574,8 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 	switch (data[0]) {
 	case INSN_CONFIG_ALT_SOURCE:
 		if (devpriv->is_m_series) {
-			if (data[1] & ~(MSeries_AI_Bypass_Cal_Sel_Pos_Mask |
-					MSeries_AI_Bypass_Cal_Sel_Neg_Mask |
-					MSeries_AI_Bypass_Mode_Mux_Mask |
-					MSeries_AO_Bypass_AO_Cal_Sel_Mask)) {
+			if (data[1] & ~NI_M_CFG_BYPASS_AI_CAL_MASK)
 				return -EINVAL;
-			}
 			devpriv->ai_calib_source = data[1];
 		} else if (devpriv->is_6143) {
 			unsigned int calib_source;

commit b1c70645286c50e9fb5338b45d388e1176e881d5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:38 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_PLL_STATUS_REG bits
    
    Rename the CamelCase and convert the enum into defines. Use the BIT()
    macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0a1f92e43b5d..bb4fde0e777c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4740,7 +4740,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 	devpriv->clock_source = source;
 	/* it seems to typically take a few hundred microseconds for PLL to lock */
 	for (i = 0; i < timeout; ++i) {
-		if (ni_readw(dev, NI_M_PLL_STATUS_REG) & MSeries_PLL_Locked_Bit)
+		if (ni_readw(dev, NI_M_PLL_STATUS_REG) & NI_M_PLL_STATUS_LOCKED)
 			break;
 		udelay(1);
 	}

commit b965e6a4ab970ae9bdd2517402ea51039b061326
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:37 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_PLL_CTRL_REG bits
    
    Rename the CamelCase and convert the enum into defines. Use the BIT()
    macro to define the bits.
    
    Convert the inline functions MSeries_PLL_Divisor_Bits() and
    MSeries_PLL_Multiplier_Bits() to macros. The helper function
    ni_mseries_get_pll_parameters() always returns valid values for the
    'divisor' and 'multiplier' so the sanity checking can safely be
    removed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 9fef0e938626..0a1f92e43b5d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4638,10 +4638,8 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 {
 	unsigned div;
 	unsigned best_div = 1;
-	static const unsigned max_div = 0x10;
 	unsigned mult;
 	unsigned best_mult = 1;
-	static const unsigned max_mult = 0x100;
 	static const unsigned pico_per_nano = 1000;
 
 	const unsigned reference_picosec = reference_period_ns * pico_per_nano;
@@ -4651,8 +4649,8 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 	static const unsigned fudge_factor_80_to_20Mhz = 4;
 	int best_period_picosec = 0;
 
-	for (div = 1; div <= max_div; ++div) {
-		for (mult = 1; mult <= max_mult; ++mult) {
+	for (div = 1; div <= NI_M_PLL_MAX_DIVISOR; ++div) {
+		for (mult = 1; mult <= NI_M_PLL_MAX_MULTIPLIER; ++mult) {
 			unsigned new_period_ps =
 			    (reference_picosec * div) / mult;
 			if (abs(new_period_ps - target_picosec) <
@@ -4700,8 +4698,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 	devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
 	ni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,
 		      RTSI_Trig_Direction_Register);
-	pll_control_bits =
-	    MSeries_PLL_Enable_Bit | MSeries_PLL_VCO_Mode_75_150MHz_Bits;
+	pll_control_bits = NI_M_PLL_CTRL_ENA | NI_M_PLL_CTRL_VCO_MODE_75_150MHZ;
 	devpriv->clock_and_fout2 |= NI_M_CLK_FOUT2_TIMEBASE1_PLL |
 				    NI_M_CLK_FOUT2_TIMEBASE3_PLL;
 	devpriv->clock_and_fout2 &= ~NI_M_CLK_FOUT2_PLL_SRC_MASK;
@@ -4736,9 +4733,8 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 	}
 
 	ni_writew(dev, devpriv->clock_and_fout2, NI_M_CLK_FOUT2_REG);
-	pll_control_bits |=
-	    MSeries_PLL_Divisor_Bits(freq_divider) |
-	    MSeries_PLL_Multiplier_Bits(freq_multiplier);
+	pll_control_bits |= NI_M_PLL_CTRL_DIVISOR(freq_divider) |
+			    NI_M_PLL_CTRL_MULTIPLIER(freq_multiplier);
 
 	ni_writew(dev, pll_control_bits, NI_M_PLL_CTRL_REG);
 	devpriv->clock_source = source;

commit 40aafd79a8b82ba506e28009cfa7c46bba813ce8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:36 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_CLK_FOUT2_REG bits
    
    Rename the CamelCase and convert the enum into defines. Use the BIT()
    macro to define the bits.
    
    Convert the inline function MSeries_PLL_In_Source_Select_RTSI_Bits()
    to a macro. The caller always passes valid values for 'RTIS_channel'
    so the sanity checking can safely be removed.
    
    Tidy up ni_mseries_set_pll_master_clock() to remove the unnecessary
    extra indent level for the code that sets a RTSI channel for the
    PLL source.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0cd5fc24759b..9fef0e938626 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4684,6 +4684,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 	unsigned pll_control_bits;
 	unsigned freq_divider;
 	unsigned freq_multiplier;
+	unsigned rtsi;
 	unsigned i;
 	int retval;
 
@@ -4701,37 +4702,27 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 		      RTSI_Trig_Direction_Register);
 	pll_control_bits =
 	    MSeries_PLL_Enable_Bit | MSeries_PLL_VCO_Mode_75_150MHz_Bits;
-	devpriv->clock_and_fout2 |=
-	    MSeries_Timebase1_Select_Bit | MSeries_Timebase3_Select_Bit;
-	devpriv->clock_and_fout2 &= ~MSeries_PLL_In_Source_Select_Mask;
+	devpriv->clock_and_fout2 |= NI_M_CLK_FOUT2_TIMEBASE1_PLL |
+				    NI_M_CLK_FOUT2_TIMEBASE3_PLL;
+	devpriv->clock_and_fout2 &= ~NI_M_CLK_FOUT2_PLL_SRC_MASK;
 	switch (source) {
 	case NI_MIO_PLL_PXI_STAR_TRIGGER_CLOCK:
-		devpriv->clock_and_fout2 |=
-		    MSeries_PLL_In_Source_Select_Star_Trigger_Bits;
+		devpriv->clock_and_fout2 |= NI_M_CLK_FOUT2_PLL_SRC_STAR;
 		break;
 	case NI_MIO_PLL_PXI10_CLOCK:
 		/* pxi clock is 10MHz */
-		devpriv->clock_and_fout2 |=
-		    MSeries_PLL_In_Source_Select_PXI_Clock10;
+		devpriv->clock_and_fout2 |= NI_M_CLK_FOUT2_PLL_SRC_PXI10;
 		break;
 	default:
-		{
-			unsigned rtsi_channel;
-			static const unsigned max_rtsi_channel = 7;
-
-			for (rtsi_channel = 0; rtsi_channel <= max_rtsi_channel;
-			     ++rtsi_channel) {
-				if (source ==
-				    NI_MIO_PLL_RTSI_CLOCK(rtsi_channel)) {
-					devpriv->clock_and_fout2 |=
-					    MSeries_PLL_In_Source_Select_RTSI_Bits
-					    (rtsi_channel);
-					break;
-				}
+		for (rtsi = 0; rtsi <= NI_M_MAX_RTSI_CHAN; ++rtsi) {
+			if (source == NI_MIO_PLL_RTSI_CLOCK(rtsi)) {
+				devpriv->clock_and_fout2 |=
+					NI_M_CLK_FOUT2_PLL_SRC_RTSI(rtsi);
+				break;
 			}
-			if (rtsi_channel > max_rtsi_channel)
-				return -EINVAL;
 		}
+		if (rtsi > NI_M_MAX_RTSI_CHAN)
+			return -EINVAL;
 		break;
 	}
 	retval = ni_mseries_get_pll_parameters(period_ns,
@@ -4778,8 +4769,8 @@ static int ni_set_master_clock(struct comedi_device *dev,
 		devpriv->clock_ns = TIMEBASE_1_NS;
 		if (devpriv->is_m_series) {
 			devpriv->clock_and_fout2 &=
-			    ~(MSeries_Timebase1_Select_Bit |
-			      MSeries_Timebase3_Select_Bit);
+			    ~(NI_M_CLK_FOUT2_TIMEBASE1_PLL |
+			      NI_M_CLK_FOUT2_TIMEBASE3_PLL);
 			ni_writew(dev, devpriv->clock_and_fout2,
 				  NI_M_CLK_FOUT2_REG);
 			ni_writew(dev, 0, NI_M_PLL_CTRL_REG);
@@ -4972,8 +4963,13 @@ static void ni_rtsi_init(struct comedi_device *dev)
 
 	/*  Initialises the RTSI bus signal switch to a default state */
 
+	/*
+	 * Use 10MHz instead of 20MHz for RTSI clock frequency. Appears
+	 * to have no effect, at least on pxi-6281, which always uses
+	 * 20MHz rtsi clock frequency
+	 */
+	devpriv->clock_and_fout2 = NI_M_CLK_FOUT2_RTSI_10MHZ;
 	/*  Set clock mode to internal */
-	devpriv->clock_and_fout2 = MSeries_RTSI_10MHz_Bit;
 	if (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0)
 		dev_err(dev->class_dev, "ni_set_master_clock failed, bug?\n");
 	/*  default internal lines routing to RTSI bus lines */

commit 67d2d05859f58a5c591e183a3a89837ee502b1cc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:35 2015 -0700

    staging: comedi: ni_stc.h: tidy up NI_M_AI_CFG_FIFO_DATA_REG bits
    
    Rename all the CamelCase and convert the enum and helper functions
    into defines. Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 93c7b1325f12..0cd5fc24759b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1792,29 +1792,26 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 		devpriv->ai_offset[i] = 0;
 		switch (aref) {
 		case AREF_DIFF:
-			config_bits |=
-			    MSeries_AI_Config_Channel_Type_Differential_Bits;
+			config_bits |= NI_M_AI_CFG_CHAN_TYPE_DIFF;
 			break;
 		case AREF_COMMON:
-			config_bits |=
-			    MSeries_AI_Config_Channel_Type_Common_Ref_Bits;
+			config_bits |= NI_M_AI_CFG_CHAN_TYPE_COMMON;
 			break;
 		case AREF_GROUND:
-			config_bits |=
-			    MSeries_AI_Config_Channel_Type_Ground_Ref_Bits;
+			config_bits |= NI_M_AI_CFG_CHAN_TYPE_GROUND;
 			break;
 		case AREF_OTHER:
 			break;
 		}
-		config_bits |= MSeries_AI_Config_Channel_Bits(chan);
-		config_bits |= MSeries_AI_Config_Bank_Bits(chan);
-		config_bits |= MSeries_AI_Config_Gain_Bits(range_code);
+		config_bits |= NI_M_AI_CFG_CHAN_SEL(chan);
+		config_bits |= NI_M_AI_CFG_BANK_SEL(chan);
+		config_bits |= NI_M_AI_CFG_GAIN(range_code);
 		if (i == n_chan - 1)
-			config_bits |= MSeries_AI_Config_Last_Channel_Bit;
+			config_bits |= NI_M_AI_CFG_LAST_CHAN;
 		if (dither)
-			config_bits |= MSeries_AI_Config_Dither_Bit;
+			config_bits |= NI_M_AI_CFG_DITHER;
 		/*  don't use 2's complement encoding */
-		config_bits |= MSeries_AI_Config_Polarity_Bit;
+		config_bits |= NI_M_AI_CFG_POLARITY;
 		ni_writew(dev, config_bits, NI_M_AI_CFG_FIFO_DATA_REG);
 	}
 	ni_prime_channelgain_list(dev);

commit 975b6d25c00c5bba5dfa77d062bde7f4772d34d7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:34 2015 -0700

    staging: comedi: ni_stc.h: rename M_Offset_* symbols
    
    Renamme these CamelCase symbols.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7e038a27fec0..93c7b1325f12 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -322,12 +322,11 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 	[G_Command_Register(1)]		= { 0x10e, 2 },
 	[AI_Command_1_Register]		= { 0x110, 2 },
 	[AO_Command_1_Register]		= { 0x112, 2 },
+	/*
+	 * DIO_Output_Register maps to:
+	 * { NI_M_DIO_REG, 4 } and { NI_M_SCXI_SER_DO_REG, 1 }
+	 */
 	[DIO_Output_Register]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
-					/*
-					 * DIO_Output_Register maps to:
-					 * { M_Offset_Static_Digital_Output, 4 }
-					 * { M_Offset_SCXI_Serial_Data_Out, 1 }
-					 */
 	[DIO_Control_Register]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
 	[AI_Mode_1_Register]		= { 0x118, 2 },
 	[AI_Mode_2_Register]		= { 0x11a, 2 },
@@ -633,7 +632,7 @@ static inline void ni_set_cdo_dma_channel(struct comedi_device *dev,
 		    (ni_stc_dma_channel_select_bitfield(mite_channel) <<
 		     CDO_DMA_Select_Shift) & CDO_DMA_Select_Mask;
 	}
-	ni_writeb(dev, devpriv->cdio_dma_select_reg, M_Offset_CDIO_DMA_Select);
+	ni_writeb(dev, devpriv->cdio_dma_select_reg, NI_M_CDIO_DMA_SEL_REG);
 	mmiowb();
 	spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
 }
@@ -853,8 +852,8 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 	} else {
 		ni_stc_writew(dev, 1, ADC_FIFO_Clear);
 		if (devpriv->is_625x) {
-			ni_writeb(dev, 0, M_Offset_Static_AI_Control(0));
-			ni_writeb(dev, 1, M_Offset_Static_AI_Control(0));
+			ni_writeb(dev, 0, NI_M_STATIC_AI_CTRL_REG(0));
+			ni_writeb(dev, 1, NI_M_STATIC_AI_CTRL_REG(0));
 #if 0
 			/* the NI example code does 3 convert pulses for 625x boards,
 			   but that appears to be wrong in practice. */
@@ -1777,9 +1776,9 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 			bypass_bits |= MSeries_AI_Bypass_Dither_Bit;
 		/*  don't use 2's complement encoding */
 		bypass_bits |= MSeries_AI_Bypass_Polarity_Bit;
-		ni_writel(dev, bypass_bits, M_Offset_AI_Config_FIFO_Bypass);
+		ni_writel(dev, bypass_bits, NI_M_AI_CFG_BYPASS_FIFO_REG);
 	} else {
-		ni_writel(dev, 0, M_Offset_AI_Config_FIFO_Bypass);
+		ni_writel(dev, 0, NI_M_AI_CFG_BYPASS_FIFO_REG);
 	}
 	for (i = 0; i < n_chan; i++) {
 		unsigned config_bits = 0;
@@ -1816,7 +1815,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 			config_bits |= MSeries_AI_Config_Dither_Bit;
 		/*  don't use 2's complement encoding */
 		config_bits |= MSeries_AI_Config_Polarity_Bit;
-		ni_writew(dev, config_bits, M_Offset_AI_Config_FIFO_Data);
+		ni_writew(dev, config_bits, NI_M_AI_CFG_FIFO_DATA_REG);
 	}
 	ni_prime_channelgain_list(dev);
 }
@@ -2050,7 +2049,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				return -ETIME;
 			}
 			if (devpriv->is_m_series) {
-				dl = ni_readl(dev, M_Offset_AI_FIFO_Data);
+				dl = ni_readl(dev, NI_M_AI_FIFO_DATA_REG);
 				dl &= mask;
 				data[n] = dl;
 			} else {
@@ -2665,8 +2664,8 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 		for (i = 0; i < s->n_chan; ++i) {
 			devpriv->ao_conf[i] &= ~MSeries_AO_Update_Timed_Bit;
 			ni_writeb(dev, devpriv->ao_conf[i],
-				  M_Offset_AO_Config_Bank(i));
-			ni_writeb(dev, 0xf, M_Offset_AO_Waveform_Order(i));
+				  NI_M_AO_CFG_BANK_REG(i));
+			ni_writeb(dev, 0xf, NI_M_AO_WAVEFORM_ORDER_REG(i));
 		}
 	}
 	for (i = 0; i < n_chans; i++) {
@@ -2680,23 +2679,21 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 		switch (krange->max - krange->min) {
 		case 20000000:
 			conf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;
-			ni_writeb(dev, 0,
-				  M_Offset_AO_Reference_Attenuation(chan));
+			ni_writeb(dev, 0, NI_M_AO_REF_ATTENUATION_REG(chan));
 			break;
 		case 10000000:
 			conf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;
-			ni_writeb(dev, 0,
-				  M_Offset_AO_Reference_Attenuation(chan));
+			ni_writeb(dev, 0, NI_M_AO_REF_ATTENUATION_REG(chan));
 			break;
 		case 4000000:
 			conf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;
 			ni_writeb(dev, MSeries_Attenuate_x5_Bit,
-				  M_Offset_AO_Reference_Attenuation(chan));
+				  NI_M_AO_REF_ATTENUATION_REG(chan));
 			break;
 		case 2000000:
 			conf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;
 			ni_writeb(dev, MSeries_Attenuate_x5_Bit,
-				  M_Offset_AO_Reference_Attenuation(chan));
+				  NI_M_AO_REF_ATTENUATION_REG(chan));
 			break;
 		default:
 			dev_err(dev->class_dev,
@@ -2717,9 +2714,9 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 		}
 		if (timed)
 			conf |= MSeries_AO_Update_Timed_Bit;
-		ni_writeb(dev, conf, M_Offset_AO_Config_Bank(chan));
+		ni_writeb(dev, conf, NI_M_AO_CFG_BANK_REG(chan));
 		devpriv->ao_conf[chan] = conf;
-		ni_writeb(dev, i, M_Offset_AO_Waveform_Order(chan));
+		ni_writeb(dev, i, NI_M_AO_WAVEFORM_ORDER_REG(chan));
 	}
 	return invert;
 }
@@ -2795,7 +2792,7 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 
 		reg = DACx_Direct_Data_671x(chan);
 	} else if (devpriv->is_m_series) {
-		reg = M_Offset_DAC_Direct_Data(chan);
+		reg = NI_M_DAC_DIRECT_DATA_REG(chan);
 	} else {
 		reg = (chan) ? DAC1_Direct_Data : DAC0_Direct_Data;
 	}
@@ -3324,7 +3321,7 @@ static int ni_m_series_dio_insn_config(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	ni_writel(dev, s->io_bits, M_Offset_DIO_Direction);
+	ni_writel(dev, s->io_bits, NI_M_DIO_DIR_REG);
 
 	return insn->n;
 }
@@ -3335,9 +3332,9 @@ static int ni_m_series_dio_insn_bits(struct comedi_device *dev,
 				     unsigned int *data)
 {
 	if (comedi_dio_update_state(s, data))
-		ni_writel(dev, s->state, M_Offset_Static_Digital_Output);
+		ni_writel(dev, s->state, NI_M_DIO_REG);
 
-	data[1] = ni_readl(dev, M_Offset_Static_Digital_Input);
+	data[1] = ni_readl(dev, NI_M_DIO_REG);
 
 	return insn->n;
 }
@@ -3442,13 +3439,13 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 	if (retval < 0)
 		return retval;
 #endif
-/*
-* XXX not sure what interrupt C group does
-* ni_writeb(dev, Interrupt_Group_C_Enable_Bit,
-* M_Offset_Interrupt_C_Enable); wait for dma to fill output fifo
-*/
+	/*
+	 * XXX not sure what interrupt C group does
+	 * wait for dma to fill output fifo
+	 * ni_writeb(dev, Interrupt_Group_C_Enable_Bit, NI_M_INTC_ENA_REG);
+	 */
 	for (i = 0; i < timeout; ++i) {
-		if (ni_readl(dev, M_Offset_CDIO_Status) & CDO_FIFO_Full_Bit)
+		if (ni_readl(dev, NI_M_CDIO_STATUS_REG) & CDO_FIFO_Full_Bit)
 			break;
 		udelay(10);
 	}
@@ -3459,7 +3456,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 	}
 	ni_writel(dev, CDO_Arm_Bit | CDO_Error_Interrupt_Enable_Set_Bit |
 		       CDO_Empty_FIFO_Interrupt_Enable_Set_Bit,
-		  M_Offset_CDIO_Command);
+		  NI_M_CDIO_CMD_REG);
 	return retval;
 }
 
@@ -3469,7 +3466,7 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;
 	int retval;
 
-	ni_writel(dev, CDO_Reset_Bit, M_Offset_CDIO_Command);
+	ni_writel(dev, CDO_Reset_Bit, NI_M_CDIO_CMD_REG);
 	switch (cmd->scan_begin_src) {
 	case TRIG_EXT:
 		cdo_mode_bits |=
@@ -3482,11 +3479,11 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	if (cmd->scan_begin_arg & CR_INVERT)
 		cdo_mode_bits |= CDO_Polarity_Bit;
-	ni_writel(dev, cdo_mode_bits, M_Offset_CDO_Mode);
+	ni_writel(dev, cdo_mode_bits, NI_M_CDO_MODE_REG);
 	if (s->io_bits) {
-		ni_writel(dev, s->state, M_Offset_CDO_FIFO_Data);
-		ni_writel(dev, CDO_SW_Update_Bit, M_Offset_CDIO_Command);
-		ni_writel(dev, s->io_bits, M_Offset_CDO_Mask_Enable);
+		ni_writel(dev, s->state, NI_M_CDO_FIFO_DATA_REG);
+		ni_writel(dev, CDO_SW_Update_Bit, NI_M_CDIO_CMD_REG);
+		ni_writel(dev, s->io_bits, NI_M_CDO_MASK_ENA_REG);
 	} else {
 		dev_err(dev->class_dev,
 			"attempted to run digital output command with no lines configured as outputs\n");
@@ -3506,12 +3503,12 @@ static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_writel(dev, CDO_Disarm_Bit | CDO_Error_Interrupt_Enable_Clear_Bit |
 		       CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
 		       CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
-		  M_Offset_CDIO_Command);
-/*
-* XXX not sure what interrupt C group does ni_writeb(dev, 0,
-* M_Offset_Interrupt_C_Enable);
-*/
-	ni_writel(dev, 0, M_Offset_CDO_Mask_Enable);
+		  NI_M_CDIO_CMD_REG);
+	/*
+	 * XXX not sure what interrupt C group does
+	 * ni_writeb(dev, 0, NI_M_INTC_ENA_REG);
+	 */
+	ni_writel(dev, 0, NI_M_CDO_MASK_ENA_REG);
 	ni_release_cdo_mite_channel(dev);
 	return 0;
 }
@@ -3542,16 +3539,16 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif
 
-	cdio_status = ni_readl(dev, M_Offset_CDIO_Status);
+	cdio_status = ni_readl(dev, NI_M_CDIO_STATUS_REG);
 	if (cdio_status & (CDO_Overrun_Bit | CDO_Underflow_Bit)) {
 		/* XXX just guessing this is needed and does something useful */
 		ni_writel(dev, CDO_Error_Interrupt_Confirm_Bit,
-			  M_Offset_CDIO_Command);
+			  NI_M_CDIO_CMD_REG);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 	if (cdio_status & CDO_FIFO_Empty_Bit) {
 		ni_writel(dev, CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
-			  M_Offset_CDIO_Command);
+			  NI_M_CDIO_CMD_REG);
 		/* s->async->events |= COMEDI_CB_EOA; */
 	}
 	comedi_handle_events(dev, s);
@@ -4033,7 +4030,7 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 		}
 		ni_writel(dev, MSeries_Cal_PWM_High_Time_Bits(up_count) |
 			       MSeries_Cal_PWM_Low_Time_Bits(down_count),
-			  M_Offset_Cal_PWM);
+			  NI_M_CAL_PWM_REG);
 		devpriv->pwm_up_count = up_count;
 		devpriv->pwm_down_count = down_count;
 		return 5;
@@ -4398,7 +4395,7 @@ static int ni_m_series_set_pfi_routing(struct comedi_device *dev,
 
 	val &= ~MSeries_PFI_Output_Select_Mask(chan);
 	val |= MSeries_PFI_Output_Select_Bits(chan, source);
-	ni_writew(dev, val, M_Offset_PFI_Output_Select(index));
+	ni_writew(dev, val, NI_M_PFI_OUT_SEL_REG(index));
 	devpriv->pfi_output_select_reg[index] = val;
 
 	return 2;
@@ -4433,10 +4430,10 @@ static int ni_config_filter(struct comedi_device *dev,
 	if (!devpriv->is_m_series)
 		return -ENOTSUPP;
 
-	bits = ni_readl(dev, M_Offset_PFI_Filter);
+	bits = ni_readl(dev, NI_M_PFI_FILTER_REG);
 	bits &= ~MSeries_PFI_Filter_Select_Mask(pfi_channel);
 	bits |= MSeries_PFI_Filter_Select_Bits(pfi_channel, filter);
-	ni_writel(dev, bits, M_Offset_PFI_Filter);
+	ni_writel(dev, bits, NI_M_PFI_FILTER_REG);
 	return 0;
 }
 
@@ -4489,9 +4486,9 @@ static int ni_pfi_insn_bits(struct comedi_device *dev,
 		return -ENOTSUPP;
 
 	if (comedi_dio_update_state(s, data))
-		ni_writew(dev, s->state, M_Offset_PFI_DO);
+		ni_writew(dev, s->state, NI_M_PFI_DO_REG);
 
-	data[1] = ni_readw(dev, M_Offset_PFI_DI);
+	data[1] = ni_readw(dev, NI_M_PFI_DI_REG);
 
 	return insn->n;
 }
@@ -4750,16 +4747,16 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 		return retval;
 	}
 
-	ni_writew(dev, devpriv->clock_and_fout2, M_Offset_Clock_and_Fout2);
+	ni_writew(dev, devpriv->clock_and_fout2, NI_M_CLK_FOUT2_REG);
 	pll_control_bits |=
 	    MSeries_PLL_Divisor_Bits(freq_divider) |
 	    MSeries_PLL_Multiplier_Bits(freq_multiplier);
 
-	ni_writew(dev, pll_control_bits, M_Offset_PLL_Control);
+	ni_writew(dev, pll_control_bits, NI_M_PLL_CTRL_REG);
 	devpriv->clock_source = source;
 	/* it seems to typically take a few hundred microseconds for PLL to lock */
 	for (i = 0; i < timeout; ++i) {
-		if (ni_readw(dev, M_Offset_PLL_Status) & MSeries_PLL_Locked_Bit)
+		if (ni_readw(dev, NI_M_PLL_STATUS_REG) & MSeries_PLL_Locked_Bit)
 			break;
 		udelay(1);
 	}
@@ -4787,8 +4784,8 @@ static int ni_set_master_clock(struct comedi_device *dev,
 			    ~(MSeries_Timebase1_Select_Bit |
 			      MSeries_Timebase3_Select_Bit);
 			ni_writew(dev, devpriv->clock_and_fout2,
-				  M_Offset_Clock_and_Fout2);
-			ni_writew(dev, 0, M_Offset_PLL_Control);
+				  NI_M_CLK_FOUT2_REG);
+			ni_writew(dev, 0, NI_M_PLL_CTRL_REG);
 		}
 		devpriv->clock_source = source;
 	} else {
@@ -5333,8 +5330,8 @@ static int ni_E_init(struct comedi_device *dev,
 
 		/* reset DIO and set all channels to inputs */
 		ni_writel(dev, CDO_Reset_Bit | CDI_Reset_Bit,
-			  M_Offset_CDIO_Command);
-		ni_writel(dev, s->io_bits, M_Offset_DIO_Direction);
+			  NI_M_CDIO_CMD_REG);
+		ni_writel(dev, s->io_bits, NI_M_DIO_DIR_REG);
 	} else {
 		s->insn_bits	= ni_dio_insn_bits;
 		s->insn_config	= ni_dio_insn_config;
@@ -5368,7 +5365,7 @@ static int ni_E_init(struct comedi_device *dev,
 		/* internal PWM output used for AI nonlinearity calibration */
 		s->insn_config	= ni_m_series_pwm_config;
 
-		ni_writel(dev, 0x0, M_Offset_Cal_PWM);
+		ni_writel(dev, 0x0, NI_M_CAL_PWM_REG);
 	} else if (devpriv->is_6143) {
 		/* internal PWM output used for AI nonlinearity calibration */
 		s->insn_config	= ni_6143_pwm_config;
@@ -5403,10 +5400,10 @@ static int ni_E_init(struct comedi_device *dev,
 		s->n_chan	= 16;
 		s->insn_bits	= ni_pfi_insn_bits;
 
-		ni_writew(dev, s->state, M_Offset_PFI_DO);
+		ni_writew(dev, s->state, NI_M_PFI_DO_REG);
 		for (i = 0; i < NUM_PFI_OUTPUT_SELECT_REGS; ++i) {
 			ni_writew(dev, devpriv->pfi_output_select_reg[i],
-				  M_Offset_PFI_Output_Select(i));
+				  NI_M_PFI_OUT_SEL_REG(i));
 		}
 	} else {
 		s->n_chan	= 10;
@@ -5525,11 +5522,11 @@ static int ni_E_init(struct comedi_device *dev,
 
 		for (channel = 0; channel < board->n_aochan; ++channel) {
 			ni_writeb(dev, 0xf,
-				  M_Offset_AO_Waveform_Order(channel));
+				  NI_M_AO_WAVEFORM_ORDER_REG(channel));
 			ni_writeb(dev, 0x0,
-				  M_Offset_AO_Reference_Attenuation(channel));
+				  NI_M_AO_REF_ATTENUATION_REG(channel));
 		}
-		ni_writeb(dev, 0x0, M_Offset_AO_Calibration);
+		ni_writeb(dev, 0x0, NI_M_AO_CALIB_REG);
 	}
 
 	return 0;

commit f496471df95ef0a218d5ad8af9d6954f88c7072f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:32 2015 -0700

    staging: comedi: ni_stc.h: reg_type is not needed by MSeries_AI_Config_Bank_Bits()
    
    This helper function sets the bits in the M_Offset_AI_Config_FIFO_Data register
    to select the correct bank to configure a given analog output channel. The NI
    M Series boards are defined by the boardinfo to have 16, 32, or 80 channels.
    Only 2 of the M Series boards have 80 channels, those boards happen to have a
    reg_type of ni_reg_622x.
    
    The bank for the 16 and 32 channel boards is selected by the 'channel & 0x30'
    calculation (comedi channels 0 to 15 or 31). This also selects the bank for the
    first 64 channels of the 80 channel boards. The additional '|= 0x400' sets the
    bank to access the extra channels (comedi channels >= 63).
    
    Since all the non ni_reg_622x boards have at most 32 channels, the extra check
    of the 'reg_type' is not required in this function. Remove it as well as the
    parameter.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c1b1d7c95982..7e038a27fec0 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1808,8 +1808,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 			break;
 		}
 		config_bits |= MSeries_AI_Config_Channel_Bits(chan);
-		config_bits |=
-		    MSeries_AI_Config_Bank_Bits(board->reg_type, chan);
+		config_bits |= MSeries_AI_Config_Bank_Bits(chan);
 		config_bits |= MSeries_AI_Config_Gain_Bits(range_code);
 		if (i == n_chan - 1)
 			config_bits |= MSeries_AI_Config_Last_Channel_Bit;

commit e0852f6ac1949f2d2612861ab608a5b1c614150c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:30 2015 -0700

    staging: comedi: ni_mio_common: simplify ni_m_series_set_pfi_routing()
    
    This function is overly complex due to the M_Offset_PFI_Output_Select()
    helper using a 1 based index for the registers and the private data using
    a 0 based index for the cached values.
    
    Modify the M_Offset_PFI_Output_Select() helper to use a 0 based index and
    remove the sanity check which can never happen. The 'n' value passed is
    calculated from the subdevice channel which will always be in range.
    
    Tidy up the function by using a local variable to mask/set the pfi output
    select bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 4aa45e083604..c1b1d7c95982 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4391,19 +4391,17 @@ static int ni_m_series_set_pfi_routing(struct comedi_device *dev,
 				       unsigned chan, unsigned source)
 {
 	struct ni_private *devpriv = dev->private;
-	unsigned pfi_reg_index;
-	unsigned array_offset;
+	unsigned index = chan / 3;
+	unsigned short val = devpriv->pfi_output_select_reg[index];
 
 	if ((source & 0x1f) != source)
 		return -EINVAL;
-	pfi_reg_index = 1 + chan / 3;
-	array_offset = pfi_reg_index - 1;
-	devpriv->pfi_output_select_reg[array_offset] &=
-	    ~MSeries_PFI_Output_Select_Mask(chan);
-	devpriv->pfi_output_select_reg[array_offset] |=
-	    MSeries_PFI_Output_Select_Bits(chan, source);
-	ni_writew(dev, devpriv->pfi_output_select_reg[array_offset],
-		  M_Offset_PFI_Output_Select(pfi_reg_index));
+
+	val &= ~MSeries_PFI_Output_Select_Mask(chan);
+	val |= MSeries_PFI_Output_Select_Bits(chan, source);
+	ni_writew(dev, val, M_Offset_PFI_Output_Select(index));
+	devpriv->pfi_output_select_reg[index] = val;
+
 	return 2;
 }
 
@@ -5409,7 +5407,7 @@ static int ni_E_init(struct comedi_device *dev,
 		ni_writew(dev, s->state, M_Offset_PFI_DO);
 		for (i = 0; i < NUM_PFI_OUTPUT_SELECT_REGS; ++i) {
 			ni_writew(dev, devpriv->pfi_output_select_reg[i],
-				  M_Offset_PFI_Output_Select(i + 1));
+				  M_Offset_PFI_Output_Select(i));
 		}
 	} else {
 		s->n_chan	= 10;

commit 0a9752d81a636ccd01f473ee8c85b8a05f06a92b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:29 2015 -0700

    staging: comedi: ni_mio_common: open code the M-Series GPCT register offsets
    
    Remove the enum m_series_register_offsets values that are only used in
    the lookup tables for the GPCT to STC register mapping and just open
    code the values. Having the extra level of indirection does not add any
    additional clarity and it gets rid of some of the CamelCase symbols.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ce7bcd2c05f9..4aa45e083604 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3766,20 +3766,20 @@ static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
 	[NITIO_G1_LOADB]	= { G_Load_B_Register(1), 4 },
 	[NITIO_G0_INPUT_SEL]	= { G_Input_Select_Register(0), 2 },
 	[NITIO_G1_INPUT_SEL]	= { G_Input_Select_Register(1), 2 },
-	[NITIO_G0_CNT_MODE]	= { M_Offset_G0_Counting_Mode, 2 },
-	[NITIO_G1_CNT_MODE]	= { M_Offset_G1_Counting_Mode, 2 },
-	[NITIO_G0_GATE2]	= { M_Offset_G0_Second_Gate, 2 },
-	[NITIO_G1_GATE2]	= { M_Offset_G1_Second_Gate, 2 },
+	[NITIO_G0_CNT_MODE]	= { 0x1b0, 2 },	/* M-Series only */
+	[NITIO_G1_CNT_MODE]	= { 0x1b2, 2 },	/* M-Series only */
+	[NITIO_G0_GATE2]	= { 0x1b4, 2 },	/* M-Series only */
+	[NITIO_G1_GATE2]	= { 0x1b6, 2 },	/* M-Series only */
 	[NITIO_G01_STATUS]	= { G_Status_Register, 2 },
 	[NITIO_G01_RESET]	= { Joint_Reset_Register, 2 },
 	[NITIO_G01_STATUS1]	= { Joint_Status_1_Register, 2 },
 	[NITIO_G01_STATUS2]	= { Joint_Status_2_Register, 2 },
-	[NITIO_G0_DMA_CFG]	= { M_Offset_G0_DMA_Config, 2 },
-	[NITIO_G1_DMA_CFG]	= { M_Offset_G1_DMA_Config, 2 },
-	[NITIO_G0_DMA_STATUS]	= { M_Offset_G0_DMA_Status, 2 },
-	[NITIO_G1_DMA_STATUS]	= { M_Offset_G1_DMA_Status, 2 },
-	[NITIO_G0_ABZ]		= { M_Offset_G0_MSeries_ABZ, 2 },
-	[NITIO_G1_ABZ]		= { M_Offset_G1_MSeries_ABZ, 2 },
+	[NITIO_G0_DMA_CFG]	= { 0x1b8, 2 },	/* M-Series only */
+	[NITIO_G1_DMA_CFG]	= { 0x1ba, 2 },	/* M-Series only */
+	[NITIO_G0_DMA_STATUS]	= { 0x1b8, 2 },	/* M-Series only */
+	[NITIO_G1_DMA_STATUS]	= { 0x1ba, 2 },	/* M-Series only */
+	[NITIO_G0_ABZ]		= { 0x1c0, 2 },	/* M-Series only */
+	[NITIO_G1_ABZ]		= { 0x1c2, 2 },	/* M-Series only */
 	[NITIO_G0_INT_ACK]	= { Interrupt_A_Ack_Register, 2 },
 	[NITIO_G1_INT_ACK]	= { Interrupt_B_Ack_Register, 2 },
 	[NITIO_G0_STATUS]	= { AI_Status_1_Register, 2 },

commit cfdb3429da1c481ea8774588ca9268a447108526
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:28 2015 -0700

    staging: comedi: ni_mio_common: refactor gpct to stc register handling
    
    The NI General Purpose Counter Timer (gpct) registers are mapped to the
    STC registers with a big switch statement. Create a lookup table to handle
    the mapping ot the registers. This is easier to maintain.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index fe7a6a0d06b2..ce7bcd2c05f9 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3749,103 +3749,66 @@ static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_ao_win_outw(dev, 0x0, AO_Later_Single_Point_Updates);
 }
 
-static unsigned ni_gpct_to_stc_register(enum ni_gpct_register reg)
+static const struct mio_regmap ni_gpct_to_stc_regmap[] = {
+	[NITIO_G0_AUTO_INC]	= { G_Autoincrement_Register(0), 2 },
+	[NITIO_G1_AUTO_INC]	= { G_Autoincrement_Register(1), 2 },
+	[NITIO_G0_CMD]		= { G_Command_Register(0), 2 },
+	[NITIO_G1_CMD]		= { G_Command_Register(1), 2 },
+	[NITIO_G0_HW_SAVE]	= { G_HW_Save_Register(0), 4 },
+	[NITIO_G1_HW_SAVE]	= { G_HW_Save_Register(1), 4 },
+	[NITIO_G0_SW_SAVE]	= { G_Save_Register(0), 4 },
+	[NITIO_G1_SW_SAVE]	= { G_Save_Register(1), 4 },
+	[NITIO_G0_MODE]		= { G_Mode_Register(0), 2 },
+	[NITIO_G1_MODE]		= { G_Mode_Register(1), 2 },
+	[NITIO_G0_LOADA]	= { G_Load_A_Register(0), 4 },
+	[NITIO_G1_LOADA]	= { G_Load_A_Register(1), 4 },
+	[NITIO_G0_LOADB]	= { G_Load_B_Register(0), 4 },
+	[NITIO_G1_LOADB]	= { G_Load_B_Register(1), 4 },
+	[NITIO_G0_INPUT_SEL]	= { G_Input_Select_Register(0), 2 },
+	[NITIO_G1_INPUT_SEL]	= { G_Input_Select_Register(1), 2 },
+	[NITIO_G0_CNT_MODE]	= { M_Offset_G0_Counting_Mode, 2 },
+	[NITIO_G1_CNT_MODE]	= { M_Offset_G1_Counting_Mode, 2 },
+	[NITIO_G0_GATE2]	= { M_Offset_G0_Second_Gate, 2 },
+	[NITIO_G1_GATE2]	= { M_Offset_G1_Second_Gate, 2 },
+	[NITIO_G01_STATUS]	= { G_Status_Register, 2 },
+	[NITIO_G01_RESET]	= { Joint_Reset_Register, 2 },
+	[NITIO_G01_STATUS1]	= { Joint_Status_1_Register, 2 },
+	[NITIO_G01_STATUS2]	= { Joint_Status_2_Register, 2 },
+	[NITIO_G0_DMA_CFG]	= { M_Offset_G0_DMA_Config, 2 },
+	[NITIO_G1_DMA_CFG]	= { M_Offset_G1_DMA_Config, 2 },
+	[NITIO_G0_DMA_STATUS]	= { M_Offset_G0_DMA_Status, 2 },
+	[NITIO_G1_DMA_STATUS]	= { M_Offset_G1_DMA_Status, 2 },
+	[NITIO_G0_ABZ]		= { M_Offset_G0_MSeries_ABZ, 2 },
+	[NITIO_G1_ABZ]		= { M_Offset_G1_MSeries_ABZ, 2 },
+	[NITIO_G0_INT_ACK]	= { Interrupt_A_Ack_Register, 2 },
+	[NITIO_G1_INT_ACK]	= { Interrupt_B_Ack_Register, 2 },
+	[NITIO_G0_STATUS]	= { AI_Status_1_Register, 2 },
+	[NITIO_G1_STATUS]	= { AO_Status_1_Register, 2 },
+	[NITIO_G0_INT_ENA]	= { Interrupt_A_Enable_Register, 2 },
+	[NITIO_G1_INT_ENA]	= { Interrupt_B_Enable_Register, 2 },
+};
+
+static unsigned int ni_gpct_to_stc_register(struct comedi_device *dev,
+					    enum ni_gpct_register reg)
 {
-	unsigned stc_register;
+	const struct mio_regmap *regmap;
 
-	switch (reg) {
-	case NITIO_G0_AUTO_INC:
-		stc_register = G_Autoincrement_Register(0);
-		break;
-	case NITIO_G1_AUTO_INC:
-		stc_register = G_Autoincrement_Register(1);
-		break;
-	case NITIO_G0_CMD:
-		stc_register = G_Command_Register(0);
-		break;
-	case NITIO_G1_CMD:
-		stc_register = G_Command_Register(1);
-		break;
-	case NITIO_G0_HW_SAVE:
-		stc_register = G_HW_Save_Register(0);
-		break;
-	case NITIO_G1_HW_SAVE:
-		stc_register = G_HW_Save_Register(1);
-		break;
-	case NITIO_G0_SW_SAVE:
-		stc_register = G_Save_Register(0);
-		break;
-	case NITIO_G1_SW_SAVE:
-		stc_register = G_Save_Register(1);
-		break;
-	case NITIO_G0_MODE:
-		stc_register = G_Mode_Register(0);
-		break;
-	case NITIO_G1_MODE:
-		stc_register = G_Mode_Register(1);
-		break;
-	case NITIO_G0_LOADA:
-		stc_register = G_Load_A_Register(0);
-		break;
-	case NITIO_G1_LOADA:
-		stc_register = G_Load_A_Register(1);
-		break;
-	case NITIO_G0_LOADB:
-		stc_register = G_Load_B_Register(0);
-		break;
-	case NITIO_G1_LOADB:
-		stc_register = G_Load_B_Register(1);
-		break;
-	case NITIO_G0_INPUT_SEL:
-		stc_register = G_Input_Select_Register(0);
-		break;
-	case NITIO_G1_INPUT_SEL:
-		stc_register = G_Input_Select_Register(1);
-		break;
-	case NITIO_G01_STATUS:
-		stc_register = G_Status_Register;
-		break;
-	case NITIO_G01_RESET:
-		stc_register = Joint_Reset_Register;
-		break;
-	case NITIO_G01_STATUS1:
-		stc_register = Joint_Status_1_Register;
-		break;
-	case NITIO_G01_STATUS2:
-		stc_register = Joint_Status_2_Register;
-		break;
-	case NITIO_G0_INT_ACK:
-		stc_register = Interrupt_A_Ack_Register;
-		break;
-	case NITIO_G1_INT_ACK:
-		stc_register = Interrupt_B_Ack_Register;
-		break;
-	case NITIO_G0_STATUS:
-		stc_register = AI_Status_1_Register;
-		break;
-	case NITIO_G1_STATUS:
-		stc_register = AO_Status_1_Register;
-		break;
-	case NITIO_G0_INT_ENA:
-		stc_register = Interrupt_A_Enable_Register;
-		break;
-	case NITIO_G1_INT_ENA:
-		stc_register = Interrupt_B_Enable_Register;
-		break;
-	default:
-		pr_err("%s: unhandled register 0x%x in switch.\n",
-		       __func__, reg);
-		BUG();
+	if (reg < ARRAY_SIZE(ni_gpct_to_stc_regmap)) {
+		regmap = &ni_gpct_to_stc_regmap[reg];
+	} else {
+		dev_warn(dev->class_dev,"%s: unhandled register 0x%x\n",
+			 __func__, reg);
 		return 0;
 	}
-	return stc_register;
+
+	return regmap->mio_reg;
 }
 
 static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 				   enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
-	unsigned stc_register;
+	unsigned int stc_register = ni_gpct_to_stc_register(dev, reg);
 	/* bits in the join reset register which are relevant to counters */
 	static const unsigned gpct_joint_reset_mask = G0_Reset | G1_Reset;
 	static const unsigned gpct_interrupt_a_enable_mask =
@@ -3853,31 +3816,20 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 	static const unsigned gpct_interrupt_b_enable_mask =
 	    G1_Gate_Interrupt_Enable | G1_TC_Interrupt_Enable;
 
+	if (stc_register == 0)
+		return;
+
 	switch (reg) {
-		/* m-series-only registers */
+		/* m-series only registers */
 	case NITIO_G0_CNT_MODE:
-		ni_writew(dev, bits, M_Offset_G0_Counting_Mode);
-		break;
 	case NITIO_G1_CNT_MODE:
-		ni_writew(dev, bits, M_Offset_G1_Counting_Mode);
-		break;
 	case NITIO_G0_GATE2:
-		ni_writew(dev, bits, M_Offset_G0_Second_Gate);
-		break;
 	case NITIO_G1_GATE2:
-		ni_writew(dev, bits, M_Offset_G1_Second_Gate);
-		break;
 	case NITIO_G0_DMA_CFG:
-		ni_writew(dev, bits, M_Offset_G0_DMA_Config);
-		break;
 	case NITIO_G1_DMA_CFG:
-		ni_writew(dev, bits, M_Offset_G1_DMA_Config);
-		break;
 	case NITIO_G0_ABZ:
-		ni_writew(dev, bits, M_Offset_G0_MSeries_ABZ);
-		break;
 	case NITIO_G1_ABZ:
-		ni_writew(dev, bits, M_Offset_G1_MSeries_ABZ);
+		ni_writew(dev, bits, stc_register);
 		break;
 
 		/* 32 bit registers */
@@ -3885,26 +3837,24 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 	case NITIO_G1_LOADA:
 	case NITIO_G0_LOADB:
 	case NITIO_G1_LOADB:
-		stc_register = ni_gpct_to_stc_register(reg);
 		ni_stc_writel(dev, bits, stc_register);
 		break;
 
 		/* 16 bit registers */
 	case NITIO_G0_INT_ENA:
 		BUG_ON(bits & ~gpct_interrupt_a_enable_mask);
-		ni_set_bitfield(dev, Interrupt_A_Enable_Register,
+		ni_set_bitfield(dev, stc_register,
 				gpct_interrupt_a_enable_mask, bits);
 		break;
 	case NITIO_G1_INT_ENA:
 		BUG_ON(bits & ~gpct_interrupt_b_enable_mask);
-		ni_set_bitfield(dev, Interrupt_B_Enable_Register,
+		ni_set_bitfield(dev, stc_register,
 				gpct_interrupt_b_enable_mask, bits);
 		break;
 	case NITIO_G01_RESET:
 		BUG_ON(bits & ~gpct_joint_reset_mask);
 		/* fall-through */
 	default:
-		stc_register = ni_gpct_to_stc_register(reg);
 		ni_stc_writew(dev, bits, stc_register);
 	}
 }
@@ -3913,29 +3863,28 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 				      enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
-	unsigned stc_register;
+	unsigned int stc_register = ni_gpct_to_stc_register(dev, reg);
+
+	if (stc_register == 0)
+		return 0;
 
 	switch (reg) {
 		/* m-series only registers */
 	case NITIO_G0_DMA_STATUS:
-		return ni_readw(dev, M_Offset_G0_DMA_Status);
 	case NITIO_G1_DMA_STATUS:
-		return ni_readw(dev, M_Offset_G1_DMA_Status);
+		return ni_readw(dev, stc_register);
 
 		/* 32 bit registers */
 	case NITIO_G0_HW_SAVE:
 	case NITIO_G1_HW_SAVE:
 	case NITIO_G0_SW_SAVE:
 	case NITIO_G1_SW_SAVE:
-		stc_register = ni_gpct_to_stc_register(reg);
 		return ni_stc_readl(dev, stc_register);
 
 		/* 16 bit registers */
 	default:
-		stc_register = ni_gpct_to_stc_register(reg);
 		return ni_stc_readw(dev, stc_register);
 	}
-	return 0;
 }
 
 static int ni_freq_out_insn_read(struct comedi_device *dev,

commit 2475c548e77dda4b7815bb81f65d04242d46d6fb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:27 2015 -0700

    staging: comedi: ni_mio_common: open code the M-Series regmap offsets
    
    Remove the enum m_series_register_offsets values that are only used in
    the lookup tables for the STC to M-Series register mapping and just open
    code the values. Having the extra level of indirection does not add any
    additional clarity and it gets rid of some of the CamelCase symbols.
    
    Some of the registers are not currently used by the driver so the mappings
    were not present in the original switch code. Add the missing register
    mappings to the lookup tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ecfd0976a776..fe7a6a0d06b2 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -314,14 +314,14 @@ struct mio_regmap {
 };
 
 static const struct mio_regmap m_series_stc_write_regmap[] = {
-	[Interrupt_A_Ack_Register]	= { M_Offset_Interrupt_A_Ack, 2 },
-	[Interrupt_B_Ack_Register]	= { M_Offset_Interrupt_B_Ack, 2 },
-	[AI_Command_2_Register]		= { M_Offset_AI_Command_2, 2 },
-	[AO_Command_2_Register]		= { M_Offset_AO_Command_2, 2 },
-	[G_Command_Register(0)]		= { M_Offset_G0_Command, 2 },
-	[G_Command_Register(1)]		= { M_Offset_G1_Command, 2 },
-	[AI_Command_1_Register]		= { M_Offset_AI_Command_1, 2 },
-	[AO_Command_1_Register]		= { M_Offset_AO_Command_1, 2 },
+	[Interrupt_A_Ack_Register]	= { 0x104, 2 },
+	[Interrupt_B_Ack_Register]	= { 0x106, 2 },
+	[AI_Command_2_Register]		= { 0x108, 2 },
+	[AO_Command_2_Register]		= { 0x10a, 2 },
+	[G_Command_Register(0)]		= { 0x10c, 2 },
+	[G_Command_Register(1)]		= { 0x10e, 2 },
+	[AI_Command_1_Register]		= { 0x110, 2 },
+	[AO_Command_1_Register]		= { 0x112, 2 },
 	[DIO_Output_Register]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
 					/*
 					 * DIO_Output_Register maps to:
@@ -329,51 +329,59 @@ static const struct mio_regmap m_series_stc_write_regmap[] = {
 					 * { M_Offset_SCXI_Serial_Data_Out, 1 }
 					 */
 	[DIO_Control_Register]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
-	[AI_Mode_1_Register]		= { M_Offset_AI_Mode_1, 2 },
-	[AI_Mode_2_Register]		= { M_Offset_AI_Mode_2, 2 },
-	[AI_SI_Load_A_Registers]	= { M_Offset_AI_SI_Load_A, 4 },
-	[AI_SC_Load_A_Registers]	= { M_Offset_AI_SC_Load_A, 4 },
-	[AI_SI2_Load_A_Register]	= { M_Offset_AI_SI2_Load_A, 4 },
-	[AI_SI2_Load_B_Register]	= { M_Offset_AI_SI2_Load_B, 4 },
-	[G_Mode_Register(0)]		= { M_Offset_G0_Mode, 2 },
-	[G_Mode_Register(1)]		= { M_Offset_G1_Mode, 2 },
-	[G_Load_A_Register(0)]		= { M_Offset_G0_Load_A, 4 },
-	[G_Load_B_Register(0)]		= { M_Offset_G0_Load_B, 4 },
-	[G_Load_A_Register(1)]		= { M_Offset_G1_Load_A, 4 },
-	[G_Load_B_Register(1)]		= { M_Offset_G1_Load_B, 4 },
-	[G_Input_Select_Register(0)]	= { M_Offset_G0_Input_Select, 2 },
-	[G_Input_Select_Register(1)]	= { M_Offset_G1_Input_Select, 2 },
-	[AO_Mode_1_Register]		= { M_Offset_AO_Mode_1, 2 },
-	[AO_Mode_2_Register]		= { M_Offset_AO_Mode_2, 2 },
-	[AO_UI_Load_A_Register]		= { M_Offset_AO_UI_Load_A, 4 },
-	[AO_BC_Load_A_Register]		= { M_Offset_AO_BC_Load_A, 4 },
-	[AO_UC_Load_A_Register]		= { M_Offset_AO_UC_Load_A, 4 },
-	[Clock_and_FOUT_Register]	= { M_Offset_Clock_and_FOUT, 2 },
-	[IO_Bidirection_Pin_Register]	= { M_Offset_IO_Bidirection_Pin, 2 },
-	[RTSI_Trig_Direction_Register]	= { M_Offset_RTSI_Trig_Direction, 2 },
-	[Interrupt_Control_Register]	= { M_Offset_Interrupt_Control, 2 },
-	[AI_Output_Control_Register]	= { M_Offset_AI_Output_Control, 2 },
-	[Analog_Trigger_Etc_Register]	= { M_Offset_Analog_Trigger_Etc, 2 },
-	[AI_START_STOP_Select_Register]	= { M_Offset_AI_START_STOP_Select, 2 },
-	[AI_Trigger_Select_Register]	= { M_Offset_AI_Trigger_Select, 2 },
-	[AO_Start_Select_Register]	= { M_Offset_AO_Start_Select, 2 },
-	[AO_Trigger_Select_Register]	= { M_Offset_AO_Trigger_Select, 2 },
-	[G_Autoincrement_Register(0)]	= { M_Offset_G0_Autoincrement, 2 },
-	[G_Autoincrement_Register(1)]	= { M_Offset_G1_Autoincrement, 2 },
-	[AO_Mode_3_Register]		= { M_Offset_AO_Mode_3, 2 },
-	[Joint_Reset_Register]		= { M_Offset_Joint_Reset, 2 },
-	[Interrupt_A_Enable_Register]	= { M_Offset_Interrupt_A_Enable, 2 },
-	[Interrupt_B_Enable_Register]	= { M_Offset_Interrupt_B_Enable, 2 },
-	[AI_Personal_Register]		= { M_Offset_AI_Personal, 2 },
-	[AO_Personal_Register]		= { M_Offset_AO_Personal, 2 },
-	[RTSI_Trig_A_Output_Register]	= { M_Offset_RTSI_Trig_A_Output, 2 },
-	[RTSI_Trig_B_Output_Register]	= { M_Offset_RTSI_Trig_B_Output, 2 },
-	[Configuration_Memory_Clear]	= { M_Offset_Configuration_Memory_Clear,
-					    2 },
-	[ADC_FIFO_Clear]		= { M_Offset_AI_FIFO_Clear, 2 },
-	[DAC_FIFO_Clear]		= { M_Offset_AO_FIFO_Clear, 2 },
-	[AO_Output_Control_Register]	= { M_Offset_AO_Output_Control, 2 },
-	[AI_Mode_3_Register]		= { M_Offset_AI_Mode_3, 2 },
+	[AI_Mode_1_Register]		= { 0x118, 2 },
+	[AI_Mode_2_Register]		= { 0x11a, 2 },
+	[AI_SI_Load_A_Registers]	= { 0x11c, 4 },
+	[AI_SI_Load_B_Registers]	= { 0x120, 4 },
+	[AI_SC_Load_A_Registers]	= { 0x124, 4 },
+	[AI_SC_Load_B_Registers]	= { 0x128, 4 },
+	[AI_SI2_Load_A_Register]	= { 0x12c, 4 },
+	[AI_SI2_Load_B_Register]	= { 0x130, 4 },
+	[G_Mode_Register(0)]		= { 0x134, 2 },
+	[G_Mode_Register(1)]		= { 0x136, 2 },
+	[G_Load_A_Register(0)]		= { 0x138, 4 },
+	[G_Load_B_Register(0)]		= { 0x13c, 4 },
+	[G_Load_A_Register(1)]		= { 0x140, 4 },
+	[G_Load_B_Register(1)]		= { 0x144, 4 },
+	[G_Input_Select_Register(0)]	= { 0x148, 2 },
+	[G_Input_Select_Register(1)]	= { 0x14a, 2 },
+	[AO_Mode_1_Register]		= { 0x14c, 2 },
+	[AO_Mode_2_Register]		= { 0x14e, 2 },
+	[AO_UI_Load_A_Register]		= { 0x150, 4 },
+	[AO_UI_Load_B_Register]		= { 0x154, 4 },
+	[AO_BC_Load_A_Register]		= { 0x158, 4 },
+	[AO_BC_Load_B_Register]		= { 0x15c, 4 },
+	[AO_UC_Load_A_Register]		= { 0x160, 4 },
+	[AO_UC_Load_B_Register]		= { 0x164, 4 },
+	[Clock_and_FOUT_Register]	= { 0x170, 2 },
+	[IO_Bidirection_Pin_Register]	= { 0x172, 2 },
+	[RTSI_Trig_Direction_Register]	= { 0x174, 2 },
+	[Interrupt_Control_Register]	= { 0x176, 2 },
+	[AI_Output_Control_Register]	= { 0x178, 2 },
+	[Analog_Trigger_Etc_Register]	= { 0x17a, 2 },
+	[AI_START_STOP_Select_Register]	= { 0x17c, 2 },
+	[AI_Trigger_Select_Register]	= { 0x17e, 2 },
+	[AI_DIV_Load_A_Register]	= { 0x180, 4 },
+	[AO_Start_Select_Register]	= { 0x184, 2 },
+	[AO_Trigger_Select_Register]	= { 0x186, 2 },
+	[G_Autoincrement_Register(0)]	= { 0x188, 2 },
+	[G_Autoincrement_Register(1)]	= { 0x18a, 2 },
+	[AO_Mode_3_Register]		= { 0x18c, 2 },
+	[Joint_Reset_Register]		= { 0x190, 2 },
+	[Interrupt_A_Enable_Register]	= { 0x192, 2 },
+	[Second_IRQ_A_Enable_Register]	= { 0, 0 }, /* E-Series only */
+	[Interrupt_B_Enable_Register]	= { 0x196, 2 },
+	[Second_IRQ_B_Enable_Register]	= { 0, 0 }, /* E-Series only */
+	[AI_Personal_Register]		= { 0x19a, 2 },
+	[AO_Personal_Register]		= { 0x19c, 2 },
+	[RTSI_Trig_A_Output_Register]	= { 0x19e, 2 },
+	[RTSI_Trig_B_Output_Register]	= { 0x1a0, 2 },
+	[RTSI_Board_Register]		= { 0, 0 }, /* Unknown */
+	[Configuration_Memory_Clear]	= { 0x1a4, 2 },
+	[ADC_FIFO_Clear]		= { 0x1a6, 2 },
+	[DAC_FIFO_Clear]		= { 0x1a8, 2 },
+	[AO_Output_Control_Register]	= { 0x1ac, 2 },
+	[AI_Mode_3_Register]		= { 0x1ae, 2 },
 };
 
 static void m_series_stc_write(struct comedi_device *dev,
@@ -404,17 +412,24 @@ static void m_series_stc_write(struct comedi_device *dev,
 }
 
 static const struct mio_regmap m_series_stc_read_regmap[] = {
-	[AI_Status_1_Register]		= { M_Offset_AI_Status_1, 2 },
-	[AO_Status_1_Register]		= { M_Offset_AO_Status_1, 2 },
-	[G_Status_Register]		= { M_Offset_G01_Status, 2 },
-	[AO_Status_2_Register]		= { M_Offset_AO_Status_2, 2 },
-	[G_HW_Save_Register(0)]		= { M_Offset_G0_HW_Save, 4 },
-	[G_HW_Save_Register(1)]		= { M_Offset_G1_HW_Save, 4 },
-	[G_Save_Register(0)]		= { M_Offset_G0_Save, 4 },
-	[G_Save_Register(1)]		= { M_Offset_G1_Save, 4 },
-	[Joint_Status_1_Register]	= { M_Offset_Joint_Status_1, 2 },
-	[DIO_Serial_Input_Register]	= { M_Offset_SCXI_Serial_Data_In, 1 },
-	[Joint_Status_2_Register]	= { M_Offset_Joint_Status_2, 2 },
+	[AI_Status_1_Register]		= { 0x104, 2 },
+	[AO_Status_1_Register]		= { 0x106, 2 },
+	[G_Status_Register]		= { 0x108, 2 },
+	[AI_Status_2_Register]		= { 0, 0 }, /* Unknown */
+	[AO_Status_2_Register]		= { 0x10c, 2 },
+	[DIO_Parallel_Input_Register]	= { 0, 0 }, /* Unknown */
+	[G_HW_Save_Register(0)]		= { 0x110, 4 },
+	[G_HW_Save_Register(1)]		= { 0x114, 4 },
+	[G_Save_Register(0)]		= { 0x118, 4 },
+	[G_Save_Register(1)]		= { 0x11c, 4 },
+	[AO_UI_Save_Registers]		= { 0x120, 4 },
+	[AO_BC_Save_Registers]		= { 0x124, 4 },
+	[AO_UC_Save_Registers]		= { 0x128, 4 },
+	[Joint_Status_1_Register]	= { 0x136, 2 },
+	[DIO_Serial_Input_Register]	= { 0x009, 1 },
+	[Joint_Status_2_Register]	= { 0x13a, 2 },
+	[AI_SI_Save_Registers]		= { 0x180, 4 },
+	[AI_SC_Save_Registers]		= { 0x184, 4 },
 };
 
 static unsigned int m_series_stc_read(struct comedi_device *dev,

commit 05dd0c9fcb34f8335728a2c4ea7f5bb5829900bc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri May 1 14:58:26 2015 -0700

    staging: comedi: ni_mio_common: refactor m-series stc register handling
    
    For M-Series boards (devpriv->is_m_series), the STC registers need to be
    remapped. This is currently handled with some big switch statements to
    convert the STC register offset to the M-Series offset. Some of the
    registers also need special handling due to differences in the register
    size on the M-Series boards.
    
    Create some lookup tables to handle the remapping of the read and write
    registers. These are easier to maintain and can contain the register size
    so that a common function can be used instead of the separate helpers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 69d71f328006..ecfd0976a776 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -308,262 +308,140 @@ static uint8_t ni_readb(struct comedi_device *dev, int reg)
  * windowed STC registers to the m series register offsets.
  */
 
-static void m_series_stc_writel(struct comedi_device *dev,
-				uint32_t data, int reg)
+struct mio_regmap {
+	unsigned int mio_reg;
+	int size;
+};
+
+static const struct mio_regmap m_series_stc_write_regmap[] = {
+	[Interrupt_A_Ack_Register]	= { M_Offset_Interrupt_A_Ack, 2 },
+	[Interrupt_B_Ack_Register]	= { M_Offset_Interrupt_B_Ack, 2 },
+	[AI_Command_2_Register]		= { M_Offset_AI_Command_2, 2 },
+	[AO_Command_2_Register]		= { M_Offset_AO_Command_2, 2 },
+	[G_Command_Register(0)]		= { M_Offset_G0_Command, 2 },
+	[G_Command_Register(1)]		= { M_Offset_G1_Command, 2 },
+	[AI_Command_1_Register]		= { M_Offset_AI_Command_1, 2 },
+	[AO_Command_1_Register]		= { M_Offset_AO_Command_1, 2 },
+	[DIO_Output_Register]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
+					/*
+					 * DIO_Output_Register maps to:
+					 * { M_Offset_Static_Digital_Output, 4 }
+					 * { M_Offset_SCXI_Serial_Data_Out, 1 }
+					 */
+	[DIO_Control_Register]		= { 0, 0 }, /* DOES NOT MAP CLEANLY */
+	[AI_Mode_1_Register]		= { M_Offset_AI_Mode_1, 2 },
+	[AI_Mode_2_Register]		= { M_Offset_AI_Mode_2, 2 },
+	[AI_SI_Load_A_Registers]	= { M_Offset_AI_SI_Load_A, 4 },
+	[AI_SC_Load_A_Registers]	= { M_Offset_AI_SC_Load_A, 4 },
+	[AI_SI2_Load_A_Register]	= { M_Offset_AI_SI2_Load_A, 4 },
+	[AI_SI2_Load_B_Register]	= { M_Offset_AI_SI2_Load_B, 4 },
+	[G_Mode_Register(0)]		= { M_Offset_G0_Mode, 2 },
+	[G_Mode_Register(1)]		= { M_Offset_G1_Mode, 2 },
+	[G_Load_A_Register(0)]		= { M_Offset_G0_Load_A, 4 },
+	[G_Load_B_Register(0)]		= { M_Offset_G0_Load_B, 4 },
+	[G_Load_A_Register(1)]		= { M_Offset_G1_Load_A, 4 },
+	[G_Load_B_Register(1)]		= { M_Offset_G1_Load_B, 4 },
+	[G_Input_Select_Register(0)]	= { M_Offset_G0_Input_Select, 2 },
+	[G_Input_Select_Register(1)]	= { M_Offset_G1_Input_Select, 2 },
+	[AO_Mode_1_Register]		= { M_Offset_AO_Mode_1, 2 },
+	[AO_Mode_2_Register]		= { M_Offset_AO_Mode_2, 2 },
+	[AO_UI_Load_A_Register]		= { M_Offset_AO_UI_Load_A, 4 },
+	[AO_BC_Load_A_Register]		= { M_Offset_AO_BC_Load_A, 4 },
+	[AO_UC_Load_A_Register]		= { M_Offset_AO_UC_Load_A, 4 },
+	[Clock_and_FOUT_Register]	= { M_Offset_Clock_and_FOUT, 2 },
+	[IO_Bidirection_Pin_Register]	= { M_Offset_IO_Bidirection_Pin, 2 },
+	[RTSI_Trig_Direction_Register]	= { M_Offset_RTSI_Trig_Direction, 2 },
+	[Interrupt_Control_Register]	= { M_Offset_Interrupt_Control, 2 },
+	[AI_Output_Control_Register]	= { M_Offset_AI_Output_Control, 2 },
+	[Analog_Trigger_Etc_Register]	= { M_Offset_Analog_Trigger_Etc, 2 },
+	[AI_START_STOP_Select_Register]	= { M_Offset_AI_START_STOP_Select, 2 },
+	[AI_Trigger_Select_Register]	= { M_Offset_AI_Trigger_Select, 2 },
+	[AO_Start_Select_Register]	= { M_Offset_AO_Start_Select, 2 },
+	[AO_Trigger_Select_Register]	= { M_Offset_AO_Trigger_Select, 2 },
+	[G_Autoincrement_Register(0)]	= { M_Offset_G0_Autoincrement, 2 },
+	[G_Autoincrement_Register(1)]	= { M_Offset_G1_Autoincrement, 2 },
+	[AO_Mode_3_Register]		= { M_Offset_AO_Mode_3, 2 },
+	[Joint_Reset_Register]		= { M_Offset_Joint_Reset, 2 },
+	[Interrupt_A_Enable_Register]	= { M_Offset_Interrupt_A_Enable, 2 },
+	[Interrupt_B_Enable_Register]	= { M_Offset_Interrupt_B_Enable, 2 },
+	[AI_Personal_Register]		= { M_Offset_AI_Personal, 2 },
+	[AO_Personal_Register]		= { M_Offset_AO_Personal, 2 },
+	[RTSI_Trig_A_Output_Register]	= { M_Offset_RTSI_Trig_A_Output, 2 },
+	[RTSI_Trig_B_Output_Register]	= { M_Offset_RTSI_Trig_B_Output, 2 },
+	[Configuration_Memory_Clear]	= { M_Offset_Configuration_Memory_Clear,
+					    2 },
+	[ADC_FIFO_Clear]		= { M_Offset_AI_FIFO_Clear, 2 },
+	[DAC_FIFO_Clear]		= { M_Offset_AO_FIFO_Clear, 2 },
+	[AO_Output_Control_Register]	= { M_Offset_AO_Output_Control, 2 },
+	[AI_Mode_3_Register]		= { M_Offset_AI_Mode_3, 2 },
+};
+
+static void m_series_stc_write(struct comedi_device *dev,
+			       unsigned int data, unsigned int reg)
 {
-	unsigned offset;
+	const struct mio_regmap *regmap;
 
-	switch (reg) {
-	case AI_SC_Load_A_Registers:
-		offset = M_Offset_AI_SC_Load_A;
-		break;
-	case AI_SI_Load_A_Registers:
-		offset = M_Offset_AI_SI_Load_A;
-		break;
-	case AO_BC_Load_A_Register:
-		offset = M_Offset_AO_BC_Load_A;
-		break;
-	case AO_UC_Load_A_Register:
-		offset = M_Offset_AO_UC_Load_A;
-		break;
-	case AO_UI_Load_A_Register:
-		offset = M_Offset_AO_UI_Load_A;
-		break;
-	case G_Load_A_Register(0):
-		offset = M_Offset_G0_Load_A;
-		break;
-	case G_Load_A_Register(1):
-		offset = M_Offset_G1_Load_A;
-		break;
-	case G_Load_B_Register(0):
-		offset = M_Offset_G0_Load_B;
-		break;
-	case G_Load_B_Register(1):
-		offset = M_Offset_G1_Load_B;
-		break;
-	default:
-		dev_warn(dev->class_dev,
-			 "%s: bug! unhandled register=0x%x in switch\n",
+	if (reg < ARRAY_SIZE(m_series_stc_write_regmap)) {
+		regmap = &m_series_stc_write_regmap[reg];
+	} else {
+		dev_warn(dev->class_dev, "%s: unhandled register=0x%x\n",
 			 __func__, reg);
 		return;
 	}
-	ni_writel(dev, data, offset);
-}
-
-static void m_series_stc_writew(struct comedi_device *dev,
-				uint16_t data, int reg)
-{
-	unsigned offset;
 
-	switch (reg) {
-	case ADC_FIFO_Clear:
-		offset = M_Offset_AI_FIFO_Clear;
-		break;
-	case AI_Command_1_Register:
-		offset = M_Offset_AI_Command_1;
-		break;
-	case AI_Command_2_Register:
-		offset = M_Offset_AI_Command_2;
-		break;
-	case AI_Mode_1_Register:
-		offset = M_Offset_AI_Mode_1;
-		break;
-	case AI_Mode_2_Register:
-		offset = M_Offset_AI_Mode_2;
-		break;
-	case AI_Mode_3_Register:
-		offset = M_Offset_AI_Mode_3;
-		break;
-	case AI_Output_Control_Register:
-		offset = M_Offset_AI_Output_Control;
-		break;
-	case AI_Personal_Register:
-		offset = M_Offset_AI_Personal;
-		break;
-	case AI_SI2_Load_A_Register:
-		/* this is a 32 bit register on m series boards */
-		ni_writel(dev, data, M_Offset_AI_SI2_Load_A);
-		return;
-	case AI_SI2_Load_B_Register:
-		/* this is a 32 bit register on m series boards */
-		ni_writel(dev, data, M_Offset_AI_SI2_Load_B);
-		return;
-	case AI_START_STOP_Select_Register:
-		offset = M_Offset_AI_START_STOP_Select;
-		break;
-	case AI_Trigger_Select_Register:
-		offset = M_Offset_AI_Trigger_Select;
-		break;
-	case Analog_Trigger_Etc_Register:
-		offset = M_Offset_Analog_Trigger_Etc;
-		break;
-	case AO_Command_1_Register:
-		offset = M_Offset_AO_Command_1;
-		break;
-	case AO_Command_2_Register:
-		offset = M_Offset_AO_Command_2;
-		break;
-	case AO_Mode_1_Register:
-		offset = M_Offset_AO_Mode_1;
-		break;
-	case AO_Mode_2_Register:
-		offset = M_Offset_AO_Mode_2;
-		break;
-	case AO_Mode_3_Register:
-		offset = M_Offset_AO_Mode_3;
-		break;
-	case AO_Output_Control_Register:
-		offset = M_Offset_AO_Output_Control;
-		break;
-	case AO_Personal_Register:
-		offset = M_Offset_AO_Personal;
-		break;
-	case AO_Start_Select_Register:
-		offset = M_Offset_AO_Start_Select;
-		break;
-	case AO_Trigger_Select_Register:
-		offset = M_Offset_AO_Trigger_Select;
-		break;
-	case Clock_and_FOUT_Register:
-		offset = M_Offset_Clock_and_FOUT;
-		break;
-	case Configuration_Memory_Clear:
-		offset = M_Offset_Configuration_Memory_Clear;
-		break;
-	case DAC_FIFO_Clear:
-		offset = M_Offset_AO_FIFO_Clear;
-		break;
-	case DIO_Control_Register:
-		dev_dbg(dev->class_dev,
-			"%s: FIXME: register 0x%x does not map cleanly on to m-series boards\n",
-			__func__, reg);
-		return;
-	case G_Autoincrement_Register(0):
-		offset = M_Offset_G0_Autoincrement;
-		break;
-	case G_Autoincrement_Register(1):
-		offset = M_Offset_G1_Autoincrement;
-		break;
-	case G_Command_Register(0):
-		offset = M_Offset_G0_Command;
-		break;
-	case G_Command_Register(1):
-		offset = M_Offset_G1_Command;
-		break;
-	case G_Input_Select_Register(0):
-		offset = M_Offset_G0_Input_Select;
-		break;
-	case G_Input_Select_Register(1):
-		offset = M_Offset_G1_Input_Select;
-		break;
-	case G_Mode_Register(0):
-		offset = M_Offset_G0_Mode;
-		break;
-	case G_Mode_Register(1):
-		offset = M_Offset_G1_Mode;
-		break;
-	case Interrupt_A_Ack_Register:
-		offset = M_Offset_Interrupt_A_Ack;
-		break;
-	case Interrupt_A_Enable_Register:
-		offset = M_Offset_Interrupt_A_Enable;
-		break;
-	case Interrupt_B_Ack_Register:
-		offset = M_Offset_Interrupt_B_Ack;
-		break;
-	case Interrupt_B_Enable_Register:
-		offset = M_Offset_Interrupt_B_Enable;
-		break;
-	case Interrupt_Control_Register:
-		offset = M_Offset_Interrupt_Control;
-		break;
-	case IO_Bidirection_Pin_Register:
-		offset = M_Offset_IO_Bidirection_Pin;
-		break;
-	case Joint_Reset_Register:
-		offset = M_Offset_Joint_Reset;
-		break;
-	case RTSI_Trig_A_Output_Register:
-		offset = M_Offset_RTSI_Trig_A_Output;
-		break;
-	case RTSI_Trig_B_Output_Register:
-		offset = M_Offset_RTSI_Trig_B_Output;
+	switch (regmap->size) {
+	case 4:
+		ni_writel(dev, data, regmap->mio_reg);
 		break;
-	case RTSI_Trig_Direction_Register:
-		offset = M_Offset_RTSI_Trig_Direction;
+	case 2:
+		ni_writew(dev, data, regmap->mio_reg);
 		break;
-	/*
-	 * FIXME: DIO_Output_Register (16 bit reg) is replaced by
-	 * M_Offset_Static_Digital_Output (32 bit) and
-	 * M_Offset_SCXI_Serial_Data_Out (8 bit)
-	 */
 	default:
-		dev_warn(dev->class_dev,
-			 "%s: bug! unhandled register=0x%x in switch\n",
+		dev_warn(dev->class_dev, "%s: unmapped register=0x%x\n",
 			 __func__, reg);
-		return;
+		break;
 	}
-	ni_writew(dev, data, offset);
 }
 
-static uint32_t m_series_stc_readl(struct comedi_device *dev, int reg)
+static const struct mio_regmap m_series_stc_read_regmap[] = {
+	[AI_Status_1_Register]		= { M_Offset_AI_Status_1, 2 },
+	[AO_Status_1_Register]		= { M_Offset_AO_Status_1, 2 },
+	[G_Status_Register]		= { M_Offset_G01_Status, 2 },
+	[AO_Status_2_Register]		= { M_Offset_AO_Status_2, 2 },
+	[G_HW_Save_Register(0)]		= { M_Offset_G0_HW_Save, 4 },
+	[G_HW_Save_Register(1)]		= { M_Offset_G1_HW_Save, 4 },
+	[G_Save_Register(0)]		= { M_Offset_G0_Save, 4 },
+	[G_Save_Register(1)]		= { M_Offset_G1_Save, 4 },
+	[Joint_Status_1_Register]	= { M_Offset_Joint_Status_1, 2 },
+	[DIO_Serial_Input_Register]	= { M_Offset_SCXI_Serial_Data_In, 1 },
+	[Joint_Status_2_Register]	= { M_Offset_Joint_Status_2, 2 },
+};
+
+static unsigned int m_series_stc_read(struct comedi_device *dev,
+				      unsigned int reg)
 {
-	unsigned offset;
+	const struct mio_regmap *regmap;
 
-	switch (reg) {
-	case G_HW_Save_Register(0):
-		offset = M_Offset_G0_HW_Save;
-		break;
-	case G_HW_Save_Register(1):
-		offset = M_Offset_G1_HW_Save;
-		break;
-	case G_Save_Register(0):
-		offset = M_Offset_G0_Save;
-		break;
-	case G_Save_Register(1):
-		offset = M_Offset_G1_Save;
-		break;
-	default:
-		dev_warn(dev->class_dev,
-			 "%s: bug! unhandled register=0x%x in switch\n",
+	if (reg < ARRAY_SIZE(m_series_stc_read_regmap)) {
+		regmap = &m_series_stc_read_regmap[reg];
+	} else {
+		dev_warn(dev->class_dev, "%s: unhandled register=0x%x\n",
 			 __func__, reg);
 		return 0;
 	}
-	return ni_readl(dev, offset);
-}
 
-static uint16_t m_series_stc_readw(struct comedi_device *dev, int reg)
-{
-	unsigned offset;
-
-	switch (reg) {
-	case AI_Status_1_Register:
-		offset = M_Offset_AI_Status_1;
-		break;
-	case AO_Status_1_Register:
-		offset = M_Offset_AO_Status_1;
-		break;
-	case AO_Status_2_Register:
-		offset = M_Offset_AO_Status_2;
-		break;
-	case DIO_Serial_Input_Register:
-		return ni_readb(dev, M_Offset_SCXI_Serial_Data_In);
-	case Joint_Status_1_Register:
-		offset = M_Offset_Joint_Status_1;
-		break;
-	case Joint_Status_2_Register:
-		offset = M_Offset_Joint_Status_2;
-		break;
-	case G_Status_Register:
-		offset = M_Offset_G01_Status;
-		break;
+	switch (regmap->size) {
+	case 4:
+		return ni_readl(dev, regmap->mio_reg);
+	case 2:
+		return ni_readw(dev, regmap->mio_reg);
+	case 1:
+		return ni_readb(dev, regmap->mio_reg);
 	default:
-		dev_warn(dev->class_dev,
-			 "%s: bug! unhandled register=0x%x in switch\n",
+		dev_warn(dev->class_dev, "%s: unmapped register=0x%x\n",
 			 __func__, reg);
 		return 0;
 	}
-	return ni_readw(dev, offset);
 }
 
 static void ni_stc_writew(struct comedi_device *dev, uint16_t data, int reg)
@@ -572,7 +450,7 @@ static void ni_stc_writew(struct comedi_device *dev, uint16_t data, int reg)
 	unsigned long flags;
 
 	if (devpriv->is_m_series) {
-		m_series_stc_writew(dev, data, reg);
+		m_series_stc_write(dev, data, reg);
 	} else {
 		spin_lock_irqsave(&devpriv->window_lock, flags);
 		if (!devpriv->mite && reg < 8) {
@@ -590,7 +468,7 @@ static void ni_stc_writel(struct comedi_device *dev, uint32_t data, int reg)
 	struct ni_private *devpriv = dev->private;
 
 	if (devpriv->is_m_series) {
-		m_series_stc_writel(dev, data, reg);
+		m_series_stc_write(dev, data, reg);
 	} else {
 		ni_stc_writew(dev, data >> 16, reg);
 		ni_stc_writew(dev, data & 0xffff, reg + 1);
@@ -604,7 +482,7 @@ static uint16_t ni_stc_readw(struct comedi_device *dev, int reg)
 	uint16_t val;
 
 	if (devpriv->is_m_series) {
-		val = m_series_stc_readw(dev, reg);
+		val = m_series_stc_read(dev, reg);
 	} else {
 		spin_lock_irqsave(&devpriv->window_lock, flags);
 		if (!devpriv->mite && reg < 8) {
@@ -624,7 +502,7 @@ static uint32_t ni_stc_readl(struct comedi_device *dev, int reg)
 	uint32_t val;
 
 	if (devpriv->is_m_series) {
-		val = m_series_stc_readl(dev, reg);
+		val = m_series_stc_read(dev, reg);
 	} else {
 		val = ni_stc_readw(dev, reg) << 16;
 		val |= ni_stc_readw(dev, reg + 1);

commit accb298fb2e3d09a84bd92595b115232f14a5e60
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 20 11:49:05 2015 -0700

    staging: comedi: ni_nio_common: don't write non-existing caldac's
    
    ni_write_caldac() checks the boardinfo 'caldac' array to determine what
    caldac is used for a given 'addr'. It then calculates the 'bitstring' and
    number of 'bits' used to write a value to that caldac address.
    
    After checking the caldac array, if the number of bits is 0 there is no
    caldac associated with the address. If this happens we shouldn't try
    writing to the non-existing caldac.
    
    Reported-by: coverity (CID 1192116)
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c66affd993aa..69d71f328006 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4355,6 +4355,10 @@ static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 		addr -= caldacs[type].n_chans;
 	}
 
+	/* bits will be 0 if there is no caldac for the given addr */
+	if (bits == 0)
+		return;
+
 	for (bit = 1 << (bits - 1); bit; bit >>= 1) {
 		ni_writeb(dev, ((bit & bitstring) ? 0x02 : 0), Serial_Command);
 		udelay(1);

commit 311fd9b2e59fee401c884bb4eca8897a25d5e6d2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:24 2015 +0000

    staging: comedi: ni_mio_common: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ada050eb359c..c66affd993aa 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -57,7 +57,6 @@
 #include <linux/delay.h>
 #include "8255.h"
 #include "mite.h"
-#include "comedi_fc.h"
 
 /* A timeout count */
 #define NI_TIMEOUT 1000
@@ -2225,28 +2224,28 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src,
+	err |= comedi_check_trigger_src(&cmd->start_src,
 					TRIG_NOW | TRIG_INT | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src,
 					TRIG_TIMER | TRIG_EXT);
 
 	sources = TRIG_TIMER | TRIG_EXT;
 	if (devpriv->is_611x || devpriv->is_6143)
 		sources |= TRIG_NOW;
-	err |= cfc_check_trigger_src(&cmd->convert_src, sources);
+	err |= comedi_check_trigger_src(&cmd->convert_src, sources);
 
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -2258,7 +2257,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	switch (cmd->start_src) {
 	case TRIG_NOW:
 	case TRIG_INT:
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 		break;
 	case TRIG_EXT:
 		tmp = CR_CHAN(cmd->start_arg);
@@ -2266,15 +2265,16 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (tmp > 16)
 			tmp = 16;
 		tmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, tmp);
+		err |= comedi_check_trigger_arg_is(&cmd->start_arg, tmp);
 		break;
 	}
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
 			ni_min_ai_scan_period_ns(dev, cmd->chanlist_len));
-		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
-						 devpriv->clock_ns * 0xffffff);
+		err |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,
+						    devpriv->clock_ns *
+						    0xffffff);
 	} else if (cmd->scan_begin_src == TRIG_EXT) {
 		/* external trigger */
 		unsigned int tmp = CR_CHAN(cmd->scan_begin_arg);
@@ -2282,19 +2282,21 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (tmp > 16)
 			tmp = 16;
 		tmp |= (cmd->scan_begin_arg & (CR_INVERT | CR_EDGE));
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);
 	} else {		/* TRIG_OTHER */
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 	}
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		if (devpriv->is_611x || devpriv->is_6143) {
-			err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+			err |= comedi_check_trigger_arg_is(&cmd->convert_arg,
+							   0);
 		} else {
-			err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-							 board->ai_speed);
-			err |= cfc_check_trigger_arg_max(&cmd->convert_arg,
-						devpriv->clock_ns * 0xffff);
+			err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
+							    board->ai_speed);
+			err |= comedi_check_trigger_arg_max(&cmd->convert_arg,
+							    devpriv->clock_ns *
+							    0xffff);
 		}
 	} else if (cmd->convert_src == TRIG_EXT) {
 		/* external trigger */
@@ -2303,23 +2305,24 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (tmp > 16)
 			tmp = 16;
 		tmp |= (cmd->convert_arg & (CR_ALT_FILTER | CR_INVERT));
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, tmp);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, tmp);
 	} else if (cmd->convert_src == TRIG_NOW) {
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
 	}
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		unsigned int max_count = 0x01000000;
 
 		if (devpriv->is_611x)
 			max_count -= num_adc_stages_611x;
-		err |= cfc_check_trigger_arg_max(&cmd->stop_arg, max_count);
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_max(&cmd->stop_arg, max_count);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	} else {
 		/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 	}
 
 	if (err)
@@ -3257,21 +3260,21 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src,
 					TRIG_TIMER | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -3282,7 +3285,7 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	switch (cmd->start_src) {
 	case TRIG_INT:
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 		break;
 	case TRIG_EXT:
 		tmp = CR_CHAN(cmd->start_arg);
@@ -3290,24 +3293,26 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (tmp > 18)
 			tmp = 18;
 		tmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, tmp);
+		err |= comedi_check_trigger_arg_is(&cmd->start_arg, tmp);
 		break;
 	}
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 board->ao_speed);
-		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
-						 devpriv->clock_ns * 0xffffff);
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    board->ao_speed);
+		err |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,
+						    devpriv->clock_ns *
+						    0xffffff);
 	}
 
-	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);
+		err |= comedi_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -3469,11 +3474,11 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE);
 
 	if (err)
 		return 1;
@@ -3483,16 +3488,17 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	tmp = cmd->scan_begin_arg;
 	tmp &= CR_PACK_FLAGS(CDO_Sample_Source_Select_Mask, 0, 0, CR_INVERT);
 	if (tmp != cmd->scan_begin_arg)
 		err |= -EINVAL;
 
-	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
-	err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit 192b3ffc4cd47e021b5160507dd885516f345b7d
Author: Supriya Karanth <iskaranth@gmail.com>
Date:   Fri Mar 13 21:00:20 2015 +0900

    staging: comedi: remove break after return
    
    Remove "break" statement after a "return" statement as
    it does not get executed.
    
    Deadcode found by coccinelle --debug option
    
    Signed-off-by: Supriya Karanth <iskaranth@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ecfd0544cf40..ada050eb359c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3811,8 +3811,6 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 			      Clock_and_FOUT_Register);
 		return 1;
 
-		break;
-
 	case INSN_CONFIG_BIDIRECTIONAL_DATA:
 
 		if (devpriv->serial_interval_ns == 0)

commit f0dff42124d3d312c236c5b934edeac477c818f7
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Fri Mar 13 14:29:30 2015 +0300

    Staging: comedi: Remove parentheses around right side assignment
    
    Parentheses are not needed around the right hand side of an assignment.
    This patch remove parenthese of such occurences. Issue was detected and
    solved using the following coccinelle script:
    
    @rule1@
    identifier x, y, z;
    expression E1, E2;
    @@
    
    (
    x = (y == z);
    |
    x = (E1 == E2);
    |
     x =
    -(
    ...
    -)
     ;
    )
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 42fdedd6943c..ecfd0544cf40 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1360,7 +1360,7 @@ static void get_last_sample_611x(struct comedi_device *dev)
 	/* Check if there's a single sample stuck in the FIFO */
 	if (ni_readb(dev, XXX_Status) & 0x80) {
 		dl = ni_readl(dev, ADC_FIFO_Data_611x);
-		data = (dl & 0xffff);
+		data = dl & 0xffff;
 		comedi_buf_write_samples(s, &data, 1);
 	}
 }
@@ -1871,7 +1871,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 		chan = CR_CHAN(list[0]);
 		range = CR_RANGE(list[0]);
 		range_code = ni_gainlkup[board->gainlkup][range];
-		dither = ((list[0] & CR_ALT_FILTER) != 0);
+		dither = (list[0] & CR_ALT_FILTER) != 0;
 		bypass_bits = MSeries_AI_Bypass_Config_FIFO_Bit;
 		bypass_bits |= chan;
 		bypass_bits |=
@@ -1895,7 +1895,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 		chan = CR_CHAN(list[i]);
 		aref = CR_AREF(list[i]);
 		range = CR_RANGE(list[i]);
-		dither = ((list[i] & CR_ALT_FILTER) != 0);
+		dither = (list[i] & CR_ALT_FILTER) != 0;
 
 		range_code = ni_gainlkup[board->gainlkup][range];
 		devpriv->ai_offset[i] = 0;
@@ -2021,7 +2021,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 			chan = CR_CHAN(list[i]);
 		aref = CR_AREF(list[i]);
 		range = CR_RANGE(list[i]);
-		dither = ((list[i] & CR_ALT_FILTER) != 0);
+		dither = (list[i] & CR_ALT_FILTER) != 0;
 
 		/* fix the external/internal range differences */
 		range = ni_gainlkup[board->gainlkup][range];

commit 6ac986d098ee81b75973a0c2f46a9a4edef2a8c6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:18 2015 -0700

    staging: comedi: drivers/*.c: add missing braces {} to if/else branches
    
    According to the CodingStyle, braces should  be used on all branches
    if thet are used on any branch,
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 4aa8a2cef4d1..42fdedd6943c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1700,8 +1700,9 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 			mite_prep_dma(devpriv->ao_mite_chan, 16, 32);
 		}
 		mite_dma_arm(devpriv->ao_mite_chan);
-	} else
+	} else {
 		retval = -EIO;
+	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 
 	return retval;
@@ -4961,8 +4962,9 @@ static int ni_set_master_clock(struct comedi_device *dev,
 				}
 				devpriv->clock_ns = period_ns;
 				devpriv->clock_source = source;
-			} else
+			} else {
 				return -EINVAL;
+			}
 		}
 	}
 	return 3;

commit c8f4b98f47e498a823d1b82b8f3848d81183ea22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:17 2015 -0700

    staging: comedi: drivers/*.c: remove unnecessary blank lines
    
    Blank lines are not needed before a close brace '}' or after an
    open brace '{'. Also remove any multiple blank lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b6f8cd85c3aa..4aa8a2cef4d1 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2569,7 +2569,6 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	if (dev->irq) {
-
 		/* interrupt on FIFO, errors, SC_TC */
 		interrupt_a_enable |= AI_Error_Interrupt_Enable |
 		    AI_SC_TC_Interrupt_Enable;
@@ -3839,7 +3838,6 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 	default:
 		return -EINVAL;
 	}
-
 }
 
 static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)

commit 6c7d2c8b5230272b394d51462c8cae46df09f126
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:16 2015 -0700

    staging: comedi: drivers/*.c: alignment should match open parenthesis
    
    Fix the alignment issues in all the comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5bb2b5e936bc..b6f8cd85c3aa 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2526,7 +2526,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		start_stop_select |=
 		    AI_START_Select(1 + CR_CHAN(cmd->scan_begin_arg));
 		ni_stc_writew(dev, start_stop_select,
-				    AI_START_STOP_Select_Register);
+			      AI_START_STOP_Select_Register);
 		break;
 	}
 

commit c6be154812114819873e8254c8d89679a11ac21c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 4 12:15:40 2015 -0700

    staging: comedi: ni_mio_common: (!foo) preferred over (foo == NULL)
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 97728d25da53..5bb2b5e936bc 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -755,7 +755,7 @@ static int ni_request_ai_mite_channel(struct comedi_device *dev)
 	BUG_ON(devpriv->ai_mite_chan);
 	devpriv->ai_mite_chan =
 	    mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);
-	if (devpriv->ai_mite_chan == NULL) {
+	if (!devpriv->ai_mite_chan) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		dev_err(dev->class_dev,
 			"failed to reserve mite dma channel for analog input\n");
@@ -776,7 +776,7 @@ static int ni_request_ao_mite_channel(struct comedi_device *dev)
 	BUG_ON(devpriv->ao_mite_chan);
 	devpriv->ao_mite_chan =
 	    mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);
-	if (devpriv->ao_mite_chan == NULL) {
+	if (!devpriv->ao_mite_chan) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		dev_err(dev->class_dev,
 			"failed to reserve mite dma channel for analog outut\n");
@@ -802,7 +802,7 @@ static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 	mite_chan =
 	    mite_request_channel(devpriv->mite,
 				 devpriv->gpct_mite_ring[gpct_index]);
-	if (mite_chan == NULL) {
+	if (!mite_chan) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		dev_err(dev->class_dev,
 			"failed to reserve mite dma channel for counter\n");
@@ -828,7 +828,7 @@ static int ni_request_cdo_mite_channel(struct comedi_device *dev)
 	BUG_ON(devpriv->cdo_mite_chan);
 	devpriv->cdo_mite_chan =
 	    mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);
-	if (devpriv->cdo_mite_chan == NULL) {
+	if (!devpriv->cdo_mite_chan) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		dev_err(dev->class_dev,
 			"failed to reserve mite dma channel for correlated digital output\n");
@@ -1657,7 +1657,7 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 	comedi_buf_write_alloc(s, s->async->prealloc_bufsz);
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	if (devpriv->ai_mite_chan == NULL) {
+	if (!devpriv->ai_mite_chan) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		return -EIO;
 	}
@@ -3699,7 +3699,7 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 	   DIO_Serial_IO_In_Progress_St goes high one bit too early. */
 	udelay((devpriv->serial_interval_ns + 999) / 1000);
 
-	if (data_in != NULL)
+	if (data_in)
 		*data_in = ni_stc_readw(dev, DIO_Serial_Input_Register);
 
 Error:

commit ce82410c76374be44a4dbd60b906e896a5e20687
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Fri Mar 6 22:01:38 2015 +0300

    Staging: comedi: clean dev_err logging
    
    This patch removes  __func__ from dev_err. dev_err includes information about:
    (devcice, driver, specific instance of device, etc) in the log printout.
    This was done using Coccinelle, with the following semantic patch:
    
    @a@
    expression E, R;
    expression  msg;
    @@
    
    dev_err(E, msg, __func__, R);
    
    @script:python b@
    e << a.msg;
    y;
    @@
    
    if(e.find("%s: ") == True):
            m = e.replace("%s: ", "", 1);
            coccinelle.y = m;
    elif(e.find("%s ") == True):
            m = e.replace("%s ", "", 1);
            coccinelle.y = m;
    elif(e.find("%s:") == True):
            m = e.replace("%s:", "", 1);
            coccinelle.y = m;
    else:
            m = e.replace("%s", "",1);
            coccinelle.y = m;
    
    @c@
    expression a.E, a.msg, a.R;
    identifier  b.y;
    @@
    
    - dev_err(E, msg, __func__, R);
    + dev_err(E, y, R);
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 176b64a6b567..97728d25da53 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -670,8 +670,8 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 		ni_writeb(dev, devpriv->g0_g1_select_reg, G0_G1_Select);
 		break;
 	default:
-		dev_err(dev->class_dev,
-			"%s called with invalid register %d\n", __func__, reg);
+		dev_err(dev->class_dev, "called with invalid register %d\n",
+			reg);
 		break;
 	}
 	mmiowb();

commit cd25503f5a6f0b0d6d66185461a358e8218db745
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Thu Mar 5 13:01:49 2015 +0300

    Staging: comedi: Clean dev_err() logging
    
    This patch removes  __func__ from dev_err. dev_err includes information about:
     (devcice, driver, specific instance of device, etc) in the log printout, so there is no need for  __func__.
    This was done using Coccinelle, with the following semantic patch:
    
    @a@
    expression E;
    expression  msg;
    @@
    
    dev_err(E, msg, __func__);
    
    @script:python b@
    e << a.msg;
    y;
    @@
    
    if(e.find("%s: ") == True):
            m = e.replace("%s: ", "");
            coccinelle.y = m;
    elif(e.find("%s ") == True):
            m = e.replace("%s ", "");
            coccinelle.y = m;
    else:
            m = e.replace("%s", "");
    
    @c@
    expression a.E, a.msg;
    identifier  b.y;
    @@
    
    - dev_err(E, msg, __func__);
    + dev_err(E, y);
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b6ddc015dedf..176b64a6b567 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1068,7 +1068,7 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 			udelay(5);
 		}
 		if (i == timeout) {
-			dev_err(dev->class_dev, "%s timed out\n", __func__);
+			dev_err(dev->class_dev, "timed out\n");
 			dev_err(dev->class_dev,
 				"mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
 				mite_bytes_in_transit(devpriv->ai_mite_chan),
@@ -2116,8 +2116,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				}
 			}
 			if (i == NI_TIMEOUT) {
-				dev_err(dev->class_dev, "%s timeout\n",
-					__func__);
+				dev_err(dev->class_dev, "timeout\n");
 				return -ETIME;
 			}
 			d += signbits;
@@ -2140,8 +2139,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				}
 			}
 			if (i == NI_TIMEOUT) {
-				dev_err(dev->class_dev, "%s timeout\n",
-					__func__);
+				dev_err(dev->class_dev, "timeout\n");
 				return -ETIME;
 			}
 			data[n] = (((dl >> 16) & 0xFFFF) + signbits) & 0xFFFF;
@@ -2156,8 +2154,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 					break;
 			}
 			if (i == NI_TIMEOUT) {
-				dev_err(dev->class_dev, "%s timeout\n",
-					__func__);
+				dev_err(dev->class_dev, "timeout\n");
 				return -ETIME;
 			}
 			if (devpriv->is_m_series) {
@@ -2808,8 +2805,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 			break;
 		default:
 			dev_err(dev->class_dev,
-				"%s: bug! unhandled ao reference voltage\n",
-				__func__);
+				"bug! unhandled ao reference voltage\n");
 			break;
 		}
 		switch (krange->max + krange->min) {
@@ -2821,8 +2817,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 			break;
 		default:
 			dev_err(dev->class_dev,
-				"%s: bug! unhandled ao offset voltage\n",
-				__func__);
+				"bug! unhandled ao offset voltage\n");
 			break;
 		}
 		if (timed)
@@ -3694,8 +3689,7 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 		udelay((devpriv->serial_interval_ns + 999) / 1000);
 		if (--count < 0) {
 			dev_err(dev->class_dev,
-				"%s: SPI serial I/O didn't finish in time!\n",
-				__func__);
+				"SPI serial I/O didn't finish in time!\n");
 			err = -ETIME;
 			goto Error;
 		}
@@ -3833,8 +3827,7 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 			err = ni_serial_sw_readwrite8(dev, s, byte_out,
 						      &byte_in);
 		} else {
-			dev_err(dev->class_dev, "%s: serial disabled!\n",
-				__func__);
+			dev_err(dev->class_dev, "serial disabled!\n");
 			return -EINVAL;
 		}
 		if (err < 0)
@@ -4520,8 +4513,7 @@ static unsigned ni_old_get_pfi_routing(struct comedi_device *dev,
 	case 9:
 		return NI_PFI_OUTPUT_G_GATE0;
 	default:
-		dev_err(dev->class_dev,
-			"%s: bug, unhandled case in switch.\n", __func__);
+		dev_err(dev->class_dev, "bug, unhandled case in switch.\n");
 		break;
 	}
 	return 0;
@@ -4673,7 +4665,7 @@ static int cs5529_wait_for_idle(struct comedi_device *dev)
 			return -EIO;
 	}
 	if (i == timeout) {
-		dev_err(dev->class_dev, "%s timeout\n", __func__);
+		dev_err(dev->class_dev, "timeout\n");
 		return -ETIME;
 	}
 	return 0;
@@ -4908,7 +4900,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 					       &devpriv->clock_ns);
 	if (retval < 0) {
 		dev_err(dev->class_dev,
-			"%s: bug, failed to find pll parameters\n", __func__);
+			"bug, failed to find pll parameters\n");
 		return retval;
 	}
 
@@ -4966,8 +4958,7 @@ static int ni_set_master_clock(struct comedi_device *dev,
 					      RTSI_Trig_Direction_Register);
 				if (period_ns == 0) {
 					dev_err(dev->class_dev,
-						"%s: we don't handle an unspecified clock period correctly yet, returning error\n",
-						__func__);
+						"we don't handle an unspecified clock period correctly yet, returning error\n");
 					return -EINVAL;
 				}
 				devpriv->clock_ns = period_ns;
@@ -5057,8 +5048,7 @@ static unsigned ni_get_rtsi_routing(struct comedi_device *dev, unsigned chan)
 	} else {
 		if (chan == old_RTSI_clock_channel)
 			return NI_RTSI_OUTPUT_RTSI_OSC;
-		dev_err(dev->class_dev, "%s: bug! should never get here?\n",
-			__func__);
+		dev_err(dev->class_dev, "bug! should never get here?\n");
 		return 0;
 	}
 }

commit 3e6cb74f5632e1ac2b4209b4d2c64fca43e2838b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:02 2015 -0700

    staging: comedi: drivers: remove inappropriate COMEDI_CB_EOA events
    
    Hardware errors should be reported with the COMEDI_CB_ERROR event. This event
    will cause the async command to cancel. It's not necessary to also set the
    COMEDI_CB_EOA event. Remove these events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 11e70173712d..b6ddc015dedf 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1478,7 +1478,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 		dev_err(dev->class_dev,
 			"unknown mite interrupt (ai_mite_status=%08x)\n",
 			ai_mite_status);
-		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		s->async->events |= COMEDI_CB_ERROR;
 		/* disable_irq(dev->irq); */
 	}
 #endif
@@ -1491,8 +1491,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			/* we probably aren't even running a command now,
 			 * so it's a good idea to be careful. */
 			if (comedi_is_subdevice_running(s)) {
-				s->async->events |=
-				    COMEDI_CB_ERROR | COMEDI_CB_EOA;
+				s->async->events |= COMEDI_CB_ERROR;
 				comedi_handle_events(dev, s);
 			}
 			return;
@@ -1579,7 +1578,7 @@ static void handle_b_interrupt(struct comedi_device *dev,
 		dev_err(dev->class_dev,
 			"unknown mite interrupt (ao_mite_status=%08x)\n",
 			ao_mite_status);
-		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		s->async->events |= COMEDI_CB_ERROR;
 	}
 #endif
 

commit 6c410db7c4305da28107f8b2b650ffe7d010aed1
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sun Nov 30 23:05:56 2014 -0600

    staging: comedi: change some printk calls to pr_err
    
    There are a handful of calls to printk in ni_stc.h without specified log
    levels, as well as one in ni_mio_common.c.  This patch converts these
    calls to pr_err() instead, so that they are now explicitly log level
    ERR.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 353c17bb4325..11e70173712d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3945,7 +3945,7 @@ static unsigned ni_gpct_to_stc_register(enum ni_gpct_register reg)
 		stc_register = Interrupt_B_Enable_Register;
 		break;
 	default:
-		printk("%s: unhandled register 0x%x in switch.\n",
+		pr_err("%s: unhandled register 0x%x in switch.\n",
 		       __func__, reg);
 		BUG();
 		return 0;

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 97869ce463b7..353c17bb4325 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5441,7 +5441,6 @@ static int ni_E_init(struct comedi_device *dev,
 		s->range_table	= board->ao_range_table;
 		s->insn_config	= ni_ao_insn_config;
 		s->insn_write	= ni_ao_insn_write;
-		s->insn_read	= comedi_readback_insn_read;
 
 		ret = comedi_alloc_subdev_readback(s);
 		if (ret)

commit 836b571df7bc0bd921c503d467fd6b6d002457ec
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 12:04:29 2014 -0700

    staging: comedi: ni_mio_common: use sample manipulation helpers
    
    Use the recently added sample manipulation helpers to remove the hardcoded
    assumption of the sample size.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 63312ff42b35..97869ce463b7 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1167,19 +1167,20 @@ static int ni_ao_fifo_half_empty(struct comedi_device *dev,
 				 struct comedi_subdevice *s)
 {
 	const struct ni_board_struct *board = dev->board_ptr;
-	int n;
+	unsigned int nbytes;
+	unsigned int nsamples;
 
-	n = comedi_buf_read_n_available(s);
-	if (n == 0) {
+	nbytes = comedi_buf_read_n_available(s);
+	if (nbytes == 0) {
 		s->async->events |= COMEDI_CB_OVERFLOW;
 		return 0;
 	}
 
-	n /= sizeof(short);
-	if (n > board->ao_fifo_depth / 2)
-		n = board->ao_fifo_depth / 2;
+	nsamples = comedi_bytes_to_samples(s, nbytes);
+	if (nsamples > board->ao_fifo_depth / 2)
+		nsamples = board->ao_fifo_depth / 2;
 
-	ni_ao_fifo_load(dev, s, n);
+	ni_ao_fifo_load(dev, s, nsamples);
 
 	return 1;
 }
@@ -1189,7 +1190,8 @@ static int ni_ao_prep_fifo(struct comedi_device *dev,
 {
 	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
-	int n;
+	unsigned int nbytes;
+	unsigned int nsamples;
 
 	/* reset fifo */
 	ni_stc_writew(dev, 1, DAC_FIFO_Clear);
@@ -1197,17 +1199,17 @@ static int ni_ao_prep_fifo(struct comedi_device *dev,
 		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
 
 	/* load some data */
-	n = comedi_buf_read_n_available(s);
-	if (n == 0)
+	nbytes = comedi_buf_read_n_available(s);
+	if (nbytes == 0)
 		return 0;
 
-	n /= sizeof(short);
-	if (n > board->ao_fifo_depth)
-		n = board->ao_fifo_depth;
+	nsamples = comedi_bytes_to_samples(s, nbytes);
+	if (nsamples > board->ao_fifo_depth)
+		nsamples = board->ao_fifo_depth;
 
-	ni_ao_fifo_load(dev, s, n);
+	ni_ao_fifo_load(dev, s, nsamples);
 
-	return n;
+	return nsamples;
 }
 
 static void ni_ai_fifo_read(struct comedi_device *dev,
@@ -2951,12 +2953,15 @@ static int ni_ao_insn_config(struct comedi_device *dev,
 {
 	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
+	unsigned int nbytes;
 
 	switch (data[0]) {
 	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
 		switch (data[1]) {
 		case COMEDI_OUTPUT:
-			data[2] = 1 + board->ao_fifo_depth * sizeof(short);
+			nbytes = comedi_samples_to_bytes(s,
+							 board->ao_fifo_depth);
+			data[2] = 1 + nbytes;
 			if (devpriv->mite)
 				data[2] += devpriv->mite->fifo_size;
 			break;

commit c39e050d21d107d26183be0f22b89eccccdbe61c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 12:04:28 2014 -0700

    staging: comedi: remove use of 'bytes_per_sample()'
    
    This inline helper function has been replaced with comedi_bytes_per_sample().
    The same commit (bf33eb4b4f57) introduced a couple other related helper
    functions a manipulate the sample size.
    
    Use the new helper functions to remove the use of 'bytes_per_sample()' and
    remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2dfd95126fa3..63312ff42b35 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1618,12 +1618,12 @@ static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	struct ni_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	unsigned int length = num_bytes / bytes_per_sample(s);
+	unsigned int nsamples = comedi_bytes_to_samples(s, num_bytes);
 	unsigned short *array = data;
 	unsigned int *larray = data;
 	unsigned int i;
 
-	for (i = 0; i < length; i++) {
+	for (i = 0; i < nsamples; i++) {
 #ifdef PCIDMA
 		if (s->subdev_flags & SDF_LSAMPL)
 			larray[i] = le32_to_cpu(larray[i]);
@@ -2732,11 +2732,11 @@ static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 			unsigned int chan_index)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int length = num_bytes / bytes_per_sample(s);
+	unsigned int nsamples = comedi_bytes_to_samples(s, num_bytes);
 	unsigned short *array = data;
 	unsigned int i;
 
-	for (i = 0; i < length; i++) {
+	for (i = 0; i < nsamples; i++) {
 		unsigned int range = CR_RANGE(cmd->chanlist[chan_index]);
 		unsigned short val = array[i];
 

commit f8736ca466e2014d6e8bad478fcc5e5cb0105af0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 09:49:31 2014 -0700

    staging: comedi: drivers: move comedi_async 'cur_chan' tracking into the core
    
    The commedi_async 'cur_chan' member is used to track the current position
    in the chanlist for a scan. Currently only a couple comedi drivers use
    this member.
    
    For aeshtetics, move the 'cur_chan' tracking into the core for non-SDF_PACKED
    subdevices. The 'cur_chan' will be updated after reading or writing samples
    to the async buffer by comedi_inc_scan_progress(). All non-SDF_PACKED subdevices
    will then automatiaclly track the 'cur_chan'.
    
    Some of the drivers use the 'cur_chan' to detect the end of scan event when
    counting scans. The COMEDI_CB_EOS event is automatically added by the core
    when the end of scan is detected. The drivers just need to check if the
    'cur_chan' is 0 to count the number of scans completed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 32236ef587f5..2dfd95126fa3 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1125,14 +1125,10 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 			    struct comedi_subdevice *s, int n)
 {
 	struct ni_private *devpriv = dev->private;
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
-	int chan;
 	int i;
 	unsigned short d;
 	u32 packed_data;
 
-	chan = async->cur_chan;
 	for (i = 0; i < n; i++) {
 		comedi_buf_read_samples(s, &d, 1);
 
@@ -1141,7 +1137,6 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 			/* 6711 only has 16 bit wide ao fifo */
 			if (!devpriv->is_6711) {
 				comedi_buf_read_samples(s, &d, 1);
-				chan++;
 				i++;
 				packed_data |= (d << 16) & 0xffff0000;
 			}
@@ -1149,10 +1144,7 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 		} else {
 			ni_writew(dev, d, DAC_FIFO_Data);
 		}
-		chan++;
-		chan %= cmd->chanlist_len;
 	}
-	async->cur_chan = chan;
 }
 
 /*

commit c1b617e017f858505ce639a8dee4d096fbcb7b6b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 09:49:30 2014 -0700

    staging: comedi: ni_mio_common: remove unused variable in ni_ao_fifo_load()
    
    The local variable 'range' is set but never used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index fd61d24bc3a4..32236ef587f5 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1131,14 +1131,11 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 	int i;
 	unsigned short d;
 	u32 packed_data;
-	int range;
 
 	chan = async->cur_chan;
 	for (i = 0; i < n; i++) {
 		comedi_buf_read_samples(s, &d, 1);
 
-		range = CR_RANGE(cmd->chanlist[chan]);
-
 		if (devpriv->is_6xxx) {
 			packed_data = d & 0xffff;
 			/* 6711 only has 16 bit wide ao fifo */

commit fb5a88eb9c2e20e2a68caea7ebebab65d2a13cd1
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Oct 30 12:42:28 2014 +0000

    staging: comedi: ni_mio_common: don't change CMDF_WRITE flag
    
    There is no need for `ni_ai_cmdtest()` or `ni_ao_cmdtest()` to set the
    `CMDF_WRITE` flag to the correct state as it has already been done by
    the core comedi module.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 18e68cd3ac53..fd61d24bc3a4 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2237,9 +2237,6 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	if ((cmd->flags & CMDF_WRITE))
-		cmd->flags &= ~CMDF_WRITE;
-
 	err |= cfc_check_trigger_src(&cmd->start_src,
 					TRIG_NOW | TRIG_INT | TRIG_EXT);
 	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
@@ -3272,9 +3269,6 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	if ((cmd->flags & CMDF_WRITE) == 0)
-		cmd->flags |= CMDF_WRITE;
-
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);
 	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
 					TRIG_TIMER | TRIG_EXT);

commit 9caba3296103f41f90f78aa482f0dfaf89a3f260
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:36 2014 -0700

    staging: comedi: ni_mio_common: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() to add the samples to the async buffer.
    That function will handle single and multi sample writes by determining
    the number of bytes to add based on the bytes_per_sample().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8004e8ac945d..18e68cd3ac53 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1226,44 +1226,42 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 {
 	struct ni_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
+	u32 dl;
+	unsigned short data;
 	int i;
 
 	if (devpriv->is_611x) {
-		unsigned short data[2];
-		u32 dl;
-
 		for (i = 0; i < n / 2; i++) {
 			dl = ni_readl(dev, ADC_FIFO_Data_611x);
 			/* This may get the hi/lo data in the wrong order */
-			data[0] = (dl >> 16) & 0xffff;
-			data[1] = dl & 0xffff;
-			cfc_write_array_to_buffer(s, data, sizeof(data));
+			data = (dl >> 16) & 0xffff;
+			comedi_buf_write_samples(s, &data, 1);
+			data = dl & 0xffff;
+			comedi_buf_write_samples(s, &data, 1);
 		}
 		/* Check if there's a single sample stuck in the FIFO */
 		if (n % 2) {
 			dl = ni_readl(dev, ADC_FIFO_Data_611x);
-			data[0] = dl & 0xffff;
-			cfc_write_to_buffer(s, data[0]);
+			data = dl & 0xffff;
+			comedi_buf_write_samples(s, &data, 1);
 		}
 	} else if (devpriv->is_6143) {
-		unsigned short data[2];
-		u32 dl;
-
 		/*  This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed */
 		for (i = 0; i < n / 2; i++) {
 			dl = ni_readl(dev, AIFIFO_Data_6143);
 
-			data[0] = (dl >> 16) & 0xffff;
-			data[1] = dl & 0xffff;
-			cfc_write_array_to_buffer(s, data, sizeof(data));
+			data = (dl >> 16) & 0xffff;
+			comedi_buf_write_samples(s, &data, 1);
+			data = dl & 0xffff;
+			comedi_buf_write_samples(s, &data, 1);
 		}
 		if (n % 2) {
 			/* Assume there is a single sample stuck in the FIFO */
 			/* Get stranded sample into FIFO */
 			ni_writel(dev, 0x01, AIFIFO_Control_6143);
 			dl = ni_readl(dev, AIFIFO_Data_6143);
-			data[0] = (dl >> 16) & 0xffff;
-			cfc_write_to_buffer(s, data[0]);
+			data = (dl >> 16) & 0xffff;
+			comedi_buf_write_samples(s, &data, 1);
 		}
 	} else {
 		if (n > sizeof(devpriv->ai_fifo_buffer) /
@@ -1277,9 +1275,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 			devpriv->ai_fifo_buffer[i] =
 			    ni_readw(dev, ADC_FIFO_Data_Register);
 		}
-		cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
-					  n *
-					  sizeof(devpriv->ai_fifo_buffer[0]));
+		comedi_buf_write_samples(s, devpriv->ai_fifo_buffer, n);
 	}
 }
 
@@ -1302,8 +1298,8 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	unsigned short data[2];
 	u32 dl;
+	unsigned short data;
 	unsigned short fifo_empty;
 	int i;
 
@@ -1313,9 +1309,10 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 			dl = ni_readl(dev, ADC_FIFO_Data_611x);
 
 			/* This may get the hi/lo data in the wrong order */
-			data[0] = (dl >> 16);
-			data[1] = (dl & 0xffff);
-			cfc_write_array_to_buffer(s, data, sizeof(data));
+			data = dl >> 16;
+			comedi_buf_write_samples(s, &data, 1);
+			data = dl & 0xffff;
+			comedi_buf_write_samples(s, &data, 1);
 		}
 	} else if (devpriv->is_6143) {
 		i = 0;
@@ -1323,9 +1320,10 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 			dl = ni_readl(dev, AIFIFO_Data_6143);
 
 			/* This may get the hi/lo data in the wrong order */
-			data[0] = (dl >> 16);
-			data[1] = (dl & 0xffff);
-			cfc_write_array_to_buffer(s, data, sizeof(data));
+			data = dl >> 16;
+			comedi_buf_write_samples(s, &data, 1);
+			data = dl & 0xffff;
+			comedi_buf_write_samples(s, &data, 1);
 			i += 2;
 		}
 		/*  Check if stranded sample is present */
@@ -1333,8 +1331,8 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 			/* Get stranded sample into FIFO */
 			ni_writel(dev, 0x01, AIFIFO_Control_6143);
 			dl = ni_readl(dev, AIFIFO_Data_6143);
-			data[0] = (dl >> 16) & 0xffff;
-			cfc_write_to_buffer(s, data[0]);
+			data = (dl >> 16) & 0xffff;
+			comedi_buf_write_samples(s, &data, 1);
 		}
 
 	} else {
@@ -1353,10 +1351,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 				devpriv->ai_fifo_buffer[i] =
 				    ni_readw(dev, ADC_FIFO_Data_Register);
 			}
-			cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
-						  i *
-						  sizeof(devpriv->
-							 ai_fifo_buffer[0]));
+			comedi_buf_write_samples(s, devpriv->ai_fifo_buffer, i);
 		}
 	}
 }
@@ -1375,7 +1370,7 @@ static void get_last_sample_611x(struct comedi_device *dev)
 	if (ni_readb(dev, XXX_Status) & 0x80) {
 		dl = ni_readl(dev, ADC_FIFO_Data_611x);
 		data = (dl & 0xffff);
-		cfc_write_to_buffer(s, data);
+		comedi_buf_write_samples(s, &data, 1);
 	}
 }
 
@@ -1397,7 +1392,7 @@ static void get_last_sample_6143(struct comedi_device *dev)
 
 		/* This may get the hi/lo data in the wrong order */
 		data = (dl >> 16) & 0xffff;
-		cfc_write_to_buffer(s, data);
+		comedi_buf_write_samples(s, &data, 1);
 	}
 }
 

commit e14c6a60b51eb53f96a91f4650e16e61b4e9c861
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 14:36:43 2014 -0700

    staging: comedi: ni_mio_common: use comedi_buf_read_samples()
    
    Use comedi_buf_read_samples() to get the single samples from the async
    buffer. The number of samples in the buffer was validated by the callers
    so the error checking can be removed. In addition, the core will set the
    COMEDI_CB_BLOCK event so it can also be removed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index fa5b25063661..8004e8ac945d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1132,13 +1132,10 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 	unsigned short d;
 	u32 packed_data;
 	int range;
-	int err = 1;
 
 	chan = async->cur_chan;
 	for (i = 0; i < n; i++) {
-		err &= comedi_buf_get(s, &d);
-		if (err == 0)
-			break;
+		comedi_buf_read_samples(s, &d, 1);
 
 		range = CR_RANGE(cmd->chanlist[chan]);
 
@@ -1146,9 +1143,7 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 			packed_data = d & 0xffff;
 			/* 6711 only has 16 bit wide ao fifo */
 			if (!devpriv->is_6711) {
-				err &= comedi_buf_get(s, &d);
-				if (err == 0)
-					break;
+				comedi_buf_read_samples(s, &d, 1);
 				chan++;
 				i++;
 				packed_data |= (d << 16) & 0xffff0000;
@@ -1161,8 +1156,6 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 		chan %= cmd->chanlist_len;
 	}
 	async->cur_chan = chan;
-	if (err == 0)
-		async->events |= COMEDI_CB_OVERFLOW;
 }
 
 /*
@@ -1199,8 +1192,6 @@ static int ni_ao_fifo_half_empty(struct comedi_device *dev,
 
 	ni_ao_fifo_load(dev, s, n);
 
-	s->async->events |= COMEDI_CB_BLOCK;
-
 	return 1;
 }
 

commit 60942e707f78b2910444579079ba5426b296cb9e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 20 15:04:30 2014 -0700

    staging: comedi: ni_mio_common: remove deadcode in ni_cdio_cmdtest()
    
    Reported-by: coverity (CID 142967)
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 785ad7004d98..fa5b25063661 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3513,9 +3513,6 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 	/* Step 2a : make sure trigger sources are unique */
 	/* Step 2b : and mutually compatible */
 
-	if (err)
-		return 2;
-
 	/* Step 3: check if arguments are trivially valid */
 
 	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);

commit 4475cf2ebff33bf669661daab4fa6e9eec349552
Author: Surya Seetharaman <surya.seetharaman9@gmail.com>
Date:   Sat Oct 25 01:42:09 2014 +0530

    Staging: comedi: ni_mio_common.c: fixed brace coding style issue in two places
    
    Removed unnecessary braces with the help of  checkpatch.pl tool.
    
    Signed-off-by: Surya Seetharaman <suryaseetharaman.9@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c855787e28f3..785ad7004d98 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -686,13 +686,12 @@ static inline void ni_set_ai_dma_channel(struct comedi_device *dev, int channel)
 {
 	unsigned bitfield;
 
-	if (channel >= 0) {
+	if (channel >= 0)
 		bitfield =
 		    (ni_stc_dma_channel_select_bitfield(channel) <<
 		     AI_DMA_Select_Shift) & AI_DMA_Select_Mask;
-	} else {
+	else
 		bitfield = 0;
-	}
 	ni_set_bitfield(dev, AI_AO_Select, AI_DMA_Select_Mask, bitfield);
 }
 
@@ -701,13 +700,12 @@ static inline void ni_set_ao_dma_channel(struct comedi_device *dev, int channel)
 {
 	unsigned bitfield;
 
-	if (channel >= 0) {
+	if (channel >= 0)
 		bitfield =
 		    (ni_stc_dma_channel_select_bitfield(channel) <<
 		     AO_DMA_Select_Shift) & AO_DMA_Select_Mask;
-	} else {
+	else
 		bitfield = 0;
-	}
 	ni_set_bitfield(dev, AI_AO_Select, AO_DMA_Select_Mask, bitfield);
 }
 

commit b9a69a19c999e43036137b629e80d25e9053386c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:30 2014 -0700

    staging: comedi: ni_mio_common: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 320b080149b6..c855787e28f3 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1462,7 +1462,7 @@ static void handle_gpct_interrupt(struct comedi_device *dev,
 
 	ni_tio_handle_interrupt(&devpriv->counter_dev->counters[counter_index],
 				s);
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 #endif
 }
 
@@ -1518,7 +1518,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			if (comedi_is_subdevice_running(s)) {
 				s->async->events |=
 				    COMEDI_CB_ERROR | COMEDI_CB_EOA;
-				cfc_handle_events(dev, s);
+				comedi_handle_events(dev, s);
 			}
 			return;
 		}
@@ -1533,7 +1533,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			if (status & (AI_Overrun_St | AI_Overflow_St))
 				s->async->events |= COMEDI_CB_OVERFLOW;
 
-			cfc_handle_events(dev, s);
+			comedi_handle_events(dev, s);
 			return;
 		}
 		if (status & AI_SC_TC_St) {
@@ -1559,7 +1559,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	if ((status & AI_STOP_St))
 		ni_handle_eos(dev, s);
 
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 }
 
 static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
@@ -1635,7 +1635,7 @@ static void handle_b_interrupt(struct comedi_device *dev,
 	}
 #endif
 
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 }
 
 static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -3693,7 +3693,7 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 			  M_Offset_CDIO_Command);
 		/* s->async->events |= COMEDI_CB_EOA; */
 	}
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 }
 
 static int ni_serial_hw_readwrite8(struct comedi_device *dev,

commit 7cf94adc51174bdec291a5c6cacb51b93d5cf847
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:44 2014 +0100

    staging: comedi: ni_mio_common: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b34df3a354e3..320b080149b6 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1186,7 +1186,7 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 static int ni_ao_fifo_half_empty(struct comedi_device *dev,
 				 struct comedi_subdevice *s)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	const struct ni_board_struct *board = dev->board_ptr;
 	int n;
 
 	n = comedi_buf_read_n_available(s);
@@ -1209,7 +1209,7 @@ static int ni_ao_fifo_half_empty(struct comedi_device *dev,
 static int ni_ao_prep_fifo(struct comedi_device *dev,
 			   struct comedi_subdevice *s)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 	int n;
 
@@ -1296,7 +1296,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 
 static void ni_handle_fifo_half_full(struct comedi_device *dev)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	const struct ni_board_struct *board = dev->board_ptr;
 	struct comedi_subdevice *s = dev->read_subdev;
 	int n;
 
@@ -1881,7 +1881,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 					      unsigned int n_chan,
 					      unsigned int *list)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 	unsigned int chan, range, aref;
 	unsigned int i;
@@ -1988,7 +1988,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 				     struct comedi_subdevice *s,
 				     unsigned int n_chan, unsigned int *list)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 	unsigned int offset = (s->maxdata + 1) >> 1;
 	unsigned int chan, range, aref;
@@ -2231,7 +2231,7 @@ static unsigned ni_timer_to_ns(const struct comedi_device *dev, int timer)
 static unsigned ni_min_ai_scan_period_ns(struct comedi_device *dev,
 					 unsigned num_channels)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 
 	/* simultaneously-sampled inputs */
@@ -2245,7 +2245,7 @@ static unsigned ni_min_ai_scan_period_ns(struct comedi_device *dev,
 static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int tmp;
@@ -2979,7 +2979,7 @@ static int ni_ao_insn_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 
 	switch (data[0]) {
@@ -3080,7 +3080,7 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 
 static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 	const struct comedi_cmd *cmd = &s->async->cmd;
 	int bits;
@@ -3281,7 +3281,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int tmp;
@@ -4369,7 +4369,7 @@ static struct caldac_struct caldacs[] = {
 
 static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 	unsigned int loadbit = 0, bits = 0, bit, bitstring = 0;
 	int i;
@@ -4427,7 +4427,7 @@ static int ni_calib_insn_read(struct comedi_device *dev,
 
 static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 	int i, j;
 	int n_dacs;
@@ -5397,7 +5397,7 @@ static int ni_alloc_private(struct comedi_device *dev)
 static int ni_E_init(struct comedi_device *dev,
 		     unsigned interrupt_pin, unsigned irq_polarity)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	const struct ni_board_struct *board = dev->board_ptr;
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	int ret;

commit 3280c2d2a6a345848384b9de0c8ed76db6ad0c79
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:57 2014 +0100

    staging: comedi: ni_mio_common: use CMDF_ROUND_...
    
    Replace use of the `TRIG_ROUND_...` macros with the new names
    `CMDF_ROUND_...`.  The numeric values are unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 584de17b04cf..b34df3a354e3 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2206,15 +2206,15 @@ static int ni_ns_to_timer(const struct comedi_device *dev, unsigned nanosec,
 	struct ni_private *devpriv = dev->private;
 	int divider;
 
-	switch (flags & TRIG_ROUND_MASK) {
-	case TRIG_ROUND_NEAREST:
+	switch (flags & CMDF_ROUND_MASK) {
+	case CMDF_ROUND_NEAREST:
 	default:
 		divider = (nanosec + devpriv->clock_ns / 2) / devpriv->clock_ns;
 		break;
-	case TRIG_ROUND_DOWN:
+	case CMDF_ROUND_DOWN:
 		divider = (nanosec) / devpriv->clock_ns;
 		break;
-	case TRIG_ROUND_UP:
+	case CMDF_ROUND_UP:
 		divider = (nanosec + devpriv->clock_ns - 1) / devpriv->clock_ns;
 		break;
 	}
@@ -2541,7 +2541,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		/* load SI */
 		timer = ni_ns_to_timer(dev, cmd->scan_begin_arg,
-				       TRIG_ROUND_NEAREST);
+				       CMDF_ROUND_NEAREST);
 		ni_stc_writel(dev, timer, AI_SI_Load_A_Registers);
 		ni_stc_writew(dev, AI_SI_Load, AI_Command_1_Register);
 		break;
@@ -2569,7 +2569,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			timer = 1;
 		else
 			timer = ni_ns_to_timer(dev, cmd->convert_arg,
-					       TRIG_ROUND_NEAREST);
+					       CMDF_ROUND_NEAREST);
 		/* 0,0 does not work */
 		ni_stc_writew(dev, 1, AI_SI2_Load_A_Register);
 		ni_stc_writew(dev, timer, AI_SI2_Load_B_Register);
@@ -3190,7 +3190,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ao_cmd2 &= ~AO_BC_Gate_Enable;
 		trigvar =
 		    ni_ns_to_timer(dev, cmd->scan_begin_arg,
-				   TRIG_ROUND_NEAREST);
+				   CMDF_ROUND_NEAREST);
 		ni_stc_writel(dev, 1, AO_UI_Load_A_Register);
 		ni_stc_writew(dev, AO_UI_Load, AO_Command_1_Register);
 		ni_stc_writel(dev, trigvar, AO_UI_Load_A_Register);
@@ -4187,15 +4187,15 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 	switch (data[0]) {
 	case INSN_CONFIG_PWM_OUTPUT:
 		switch (data[1]) {
-		case TRIG_ROUND_NEAREST:
+		case CMDF_ROUND_NEAREST:
 			up_count =
 			    (data[2] +
 			     devpriv->clock_ns / 2) / devpriv->clock_ns;
 			break;
-		case TRIG_ROUND_DOWN:
+		case CMDF_ROUND_DOWN:
 			up_count = data[2] / devpriv->clock_ns;
 			break;
-		case TRIG_ROUND_UP:
+		case CMDF_ROUND_UP:
 			up_count =
 			    (data[2] + devpriv->clock_ns -
 			     1) / devpriv->clock_ns;
@@ -4204,15 +4204,15 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 			return -EINVAL;
 		}
 		switch (data[3]) {
-		case TRIG_ROUND_NEAREST:
+		case CMDF_ROUND_NEAREST:
 			down_count =
 			    (data[4] +
 			     devpriv->clock_ns / 2) / devpriv->clock_ns;
 			break;
-		case TRIG_ROUND_DOWN:
+		case CMDF_ROUND_DOWN:
 			down_count = data[4] / devpriv->clock_ns;
 			break;
-		case TRIG_ROUND_UP:
+		case CMDF_ROUND_UP:
 			down_count =
 			    (data[4] + devpriv->clock_ns -
 			     1) / devpriv->clock_ns;
@@ -4251,15 +4251,15 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 	switch (data[0]) {
 	case INSN_CONFIG_PWM_OUTPUT:
 		switch (data[1]) {
-		case TRIG_ROUND_NEAREST:
+		case CMDF_ROUND_NEAREST:
 			up_count =
 			    (data[2] +
 			     devpriv->clock_ns / 2) / devpriv->clock_ns;
 			break;
-		case TRIG_ROUND_DOWN:
+		case CMDF_ROUND_DOWN:
 			up_count = data[2] / devpriv->clock_ns;
 			break;
-		case TRIG_ROUND_UP:
+		case CMDF_ROUND_UP:
 			up_count =
 			    (data[2] + devpriv->clock_ns -
 			     1) / devpriv->clock_ns;
@@ -4268,15 +4268,15 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 			return -EINVAL;
 		}
 		switch (data[3]) {
-		case TRIG_ROUND_NEAREST:
+		case CMDF_ROUND_NEAREST:
 			down_count =
 			    (data[4] +
 			     devpriv->clock_ns / 2) / devpriv->clock_ns;
 			break;
-		case TRIG_ROUND_DOWN:
+		case CMDF_ROUND_DOWN:
 			down_count = data[4] / devpriv->clock_ns;
 			break;
-		case TRIG_ROUND_UP:
+		case CMDF_ROUND_UP:
 			down_count =
 			    (data[4] + devpriv->clock_ns -
 			     1) / devpriv->clock_ns;

commit c97140cb0929938a2a527c31d2ee7929d3779ef6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:39 2014 +0100

    staging: comedi: ni_mio_common: use CMDF_WAKE_EOS
    
    Replace use of `TRIG_WAKE_EOS` command flag with the new name
    `CMDF_WAKE_EOS`.  The numeric value is the same.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 237e3f8f9340..584de17b04cf 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2610,7 +2610,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		interrupt_a_enable |= AI_FIFO_Interrupt_Enable;
 #endif
 
-		if (cmd->flags & TRIG_WAKE_EOS
+		if (cmd->flags & CMDF_WAKE_EOS
 		    || (devpriv->ai_cmd2 & AI_End_On_End_Of_Scan)) {
 			/* wake on end-of-scan */
 			devpriv->aimode = AIMODE_SCAN;

commit b6d977e9fb8c63435ba5dec87e707e088df7e7f8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:15 2014 -0700

    staging: comedi: ni_mio_common: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c4c82d0178f1..237e3f8f9340 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2918,21 +2918,6 @@ static int ni_ao_config_chanlist(struct comedi_device *dev,
 		return ni_old_ao_config_chanlist(dev, s, chanspec, n_chans);
 }
 
-static int ni_ao_insn_read(struct comedi_device *dev,
-			   struct comedi_subdevice *s,
-			   struct comedi_insn *insn,
-			   unsigned int *data)
-{
-	struct ni_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	int i;
-
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->ao[chan];
-
-	return insn->n;
-}
-
 static int ni_ao_insn_write(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn,
@@ -2959,7 +2944,7 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 	for (i = 0; i < insn->n; i++) {
 		unsigned int val = data[i];
 
-		devpriv->ao[chan] = val;
+		s->readback[chan] = val;
 
 		if (devpriv->is_6xxx) {
 			/*
@@ -5485,9 +5470,13 @@ static int ni_E_init(struct comedi_device *dev,
 		s->n_chan	= board->n_aochan;
 		s->maxdata	= board->ao_maxdata;
 		s->range_table	= board->ao_range_table;
-		s->insn_read	= ni_ao_insn_read;
-		s->insn_write	= ni_ao_insn_write;
 		s->insn_config	= ni_ao_insn_config;
+		s->insn_write	= ni_ao_insn_write;
+		s->insn_read	= comedi_readback_insn_read;
+
+		ret = comedi_alloc_subdev_readback(s);
+		if (ret)
+			return ret;
 
 		/*
 		 * Along with the IRQ we need either a FIFO or DMA for

commit b32381c5a8fdf5275f3ea680afe77aac5bc38f6e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 15:23:52 2014 -0700

    staging: comedi: ni_mio_common: remove deadcode in ni_cdio_cmdtest()
    
    Reported by: coverity
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 3c9d747fce8b..c4c82d0178f1 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3549,12 +3549,10 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-	/* step 4: fix up any arguments */
-
-	if (err)
-		return 4;
+	/* Step 4: fix up any arguments */
 
 	/* Step 5: check channel list if it exists */
+
 	if (cmd->chanlist && cmd->chanlist_len > 0)
 		err |= ni_cdio_check_chanlist(dev, s, cmd);
 

commit cad6daded3feed359b73cee8d1e0962bfac3059f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 15:23:51 2014 -0700

    staging: comedi: ni_mio_common: remove deadcode in ni_ai_insn_config()
    
    The previous mask by 0xf ensures that calib_source will not be > 0xf.
    Remove the dead code.
    
    Reported by: coverity
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c42ba22b91d2..3c9d747fce8b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2732,9 +2732,6 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 
 			calib_source = data[1] & 0xf;
 
-			if (calib_source > 0xF)
-				return -EINVAL;
-
 			devpriv->ai_calib_source = calib_source;
 			ni_writew(dev, calib_source, Calibration_Channel_6143);
 		} else {

commit 0557344e21497fce9475dfe3f41fd92d57d8a274
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 15:23:50 2014 -0700

    staging: comedi: ni_mio_common: fix local var for 32-bit read
    
    The local variable 'd' is used to read a 32-bit register. One branch of
    the code shifts the register value 16 bits to the right to get the high
    16-bits. Change the type of the local variable so that this shift works
    correctly.
    
    Reported by: coverity
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8b3ba40cb74c..c42ba22b91d2 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2108,7 +2108,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 	unsigned int mask = (s->maxdata + 1) >> 1;
 	int i, n;
 	unsigned signbits;
-	unsigned short d;
+	unsigned int d;
 	unsigned long dl;
 
 	ni_load_channelgain_list(dev, s, 1, &insn->chanspec);

commit 67393c4fef245f46863f50bc8a553f0608d7a05d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:20 2014 -0700

    staging: comedi: ni_mio_common: tidy up ni_8255_callback()
    
    The 8255 driver (*io) callback now includes the comedi_device pointer.
    
    Instead of passing the (cast) pointer to subdev_8255_init(), pass the
    'iobase' of the 8255 registers (Port_A).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 07659053f4d3..8b3ba40cb74c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4176,17 +4176,15 @@ static int ni_freq_out_insn_config(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int ni_8255_callback(struct comedi_device *cdev,
-			    int dir, int port, int data, unsigned long arg)
+static int ni_8255_callback(struct comedi_device *dev,
+			    int dir, int port, int data, unsigned long iobase)
 {
-	struct comedi_device *dev = (struct comedi_device *)arg;
-
 	if (dir) {
-		ni_writeb(dev, data, Port_A + 2 * port);
+		ni_writeb(dev, data, iobase + 2 * port);
 		return 0;
 	}
 
-	return ni_readb(dev, Port_A + 2 * port);
+	return ni_readb(dev, iobase + 2 * port);
 }
 
 static int ni_get_pwm_config(struct comedi_device *dev, unsigned int *data)
@@ -5561,8 +5559,7 @@ static int ni_E_init(struct comedi_device *dev,
 	/* 8255 device */
 	s = &dev->subdevices[NI_8255_DIO_SUBDEV];
 	if (board->has_8255) {
-		ret = subdev_8255_init(dev, s, ni_8255_callback,
-				       (unsigned long)dev);
+		ret = subdev_8255_init(dev, s, ni_8255_callback, Port_A);
 		if (ret)
 			return ret;
 	} else {

commit 09d6dd7490ee7f1dda926e309df370e28679a71c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:19 2014 -0700

    staging: comedi: 8255: add a comedi_device param to the (*io) callback
    
    The 8255 driver uses an (*io) callback to read/write the registers
    of the 8255 device. The default callback provided by the driver uses
    inb()/outb() calls to access to registers based on an 'iobase' that
    was initialized during the subdev_8255_init() and a 'port' value.
    
    The users of this module can optionally provide a custom (*io) callback
    to handle the read/write in another manner.
    
    Make the (*io) callback a bit more flexible by also passing the
    comedi_device pointer as a parameter.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 297c95d2e0a3..07659053f4d3 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4176,7 +4176,8 @@ static int ni_freq_out_insn_config(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
+static int ni_8255_callback(struct comedi_device *cdev,
+			    int dir, int port, int data, unsigned long arg)
 {
 	struct comedi_device *dev = (struct comedi_device *)arg;
 

commit 5f8a5f4fa4c2c3fa7e66c7b002039a8046e4d99d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jul 29 15:01:38 2014 -0700

    staging: comedi: mite: use the comedi_device 'mmio' member
    
    Use the new 'mmio' member in the comedi_device for the ioremap'ed
    'daq_io_addr'.
    
    Move the iounmap of this address from mite_detach() to the drivers
    that use the mite module.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 888ec8ddf63b..297c95d2e0a3 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -246,60 +246,48 @@ static const int num_adc_stages_611x = 3;
 
 static void ni_writel(struct comedi_device *dev, uint32_t data, int reg)
 {
-	struct ni_private *devpriv = dev->private;
-
-	if (devpriv->mite)
-		writel(data, devpriv->mite->daq_io_addr + reg);
+	if (dev->mmio)
+		writel(data, dev->mmio + reg);
 
 	outl(data, dev->iobase + reg);
 }
 
 static void ni_writew(struct comedi_device *dev, uint16_t data, int reg)
 {
-	struct ni_private *devpriv = dev->private;
-
-	if (devpriv->mite)
-		writew(data, devpriv->mite->daq_io_addr + reg);
+	if (dev->mmio)
+		writew(data, dev->mmio + reg);
 
 	outw(data, dev->iobase + reg);
 }
 
 static void ni_writeb(struct comedi_device *dev, uint8_t data, int reg)
 {
-	struct ni_private *devpriv = dev->private;
-
-	if (devpriv->mite)
-		writeb(data, devpriv->mite->daq_io_addr + reg);
+	if (dev->mmio)
+		writeb(data, dev->mmio + reg);
 
 	outb(data, dev->iobase + reg);
 }
 
 static uint32_t ni_readl(struct comedi_device *dev, int reg)
 {
-	struct ni_private *devpriv = dev->private;
-
-	if (devpriv->mite)
-		return readl(devpriv->mite->daq_io_addr + reg);
+	if (dev->mmio)
+		return readl(dev->mmio + reg);
 
 	return inl(dev->iobase + reg);
 }
 
 static uint16_t ni_readw(struct comedi_device *dev, int reg)
 {
-	struct ni_private *devpriv = dev->private;
-
-	if (devpriv->mite)
-		return readw(devpriv->mite->daq_io_addr + reg);
+	if (dev->mmio)
+		return readw(dev->mmio + reg);
 
 	return inw(dev->iobase + reg);
 }
 
 static uint8_t ni_readb(struct comedi_device *dev, int reg)
 {
-	struct ni_private *devpriv = dev->private;
-
-	if (devpriv->mite)
-		return readb(devpriv->mite->daq_io_addr + reg);
+	if (dev->mmio)
+		return readb(dev->mmio + reg);
 
 	return inb(dev->iobase + reg);
 }

commit f8cfd0eb3c11337844215c5e93937c561858eb13
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:27:04 2014 -0700

    staging: comedi: ni_tiocmd: introduce ni_tio_acknowledge()
    
    The external callers of ni_tio_acknowledge_and_confirm() only call
    this function to ack any pending errors or interrupts before starting
    a new async command. Only the internal code in ni_tiocmd uses the
    data that is optionally returned by this function.
    
    Remove the export from ni_tio_acknowledge_and_confirm() and introduce
    a new exported function that handles passing the NULL params.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 4285f0718012..888ec8ddf63b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5252,7 +5252,7 @@ static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			"no dma channel available for use by counter\n");
 		return retval;
 	}
-	ni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);
+	ni_tio_acknowledge(counter);
 	ni_e_series_enable_second_irq(dev, counter->counter_index, 1);
 
 	return ni_tio_cmd(dev, s);

commit a207c12f62e8b53e1e1600ca384b13a39a9feed2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:16 2014 -0700

    staging: comedi: drivers: cleanup cmd->flags use
    
    Most of the comedi drivers that support async commands have some sort
    of timer to control the acquisition timing. For these drivers, Step 4
    of the (*do_cmdtest) operations calls a ns_to_timer() function that
    converts the desired ns time of the command into a value used to set
    the timer. These ns_to_timer() functions also typically pass the
    cmd->flags in order to determine the desired rounding mode.
    
    Some of the drivers mask the cmd->flags with TRIG_ROUND_MASK when
    calling the ns_to_timer() functions. Move all the masking into the
    ns_to_timer() functions and just pass the cmd->flags directly.
    
    The cmd->flags member is an unsigned int, change the parameter type
    in the the ns_to_timer() functions to match.
    
    For aesthetics, rename the parameter in all the ns_to_timer()
    functions to 'flags'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 551a150685a9..4285f0718012 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2213,12 +2213,12 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 }
 
 static int ni_ns_to_timer(const struct comedi_device *dev, unsigned nanosec,
-			  int round_mode)
+			  unsigned int flags)
 {
 	struct ni_private *devpriv = dev->private;
 	int divider;
 
-	switch (round_mode) {
+	switch (flags & TRIG_ROUND_MASK) {
 	case TRIG_ROUND_NEAREST:
 	default:
 		divider = (nanosec + devpriv->clock_ns / 2) / devpriv->clock_ns;
@@ -2375,9 +2375,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		cmd->scan_begin_arg =
 		    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
 						       cmd->scan_begin_arg,
-						       cmd->
-						       flags &
-						       TRIG_ROUND_MASK));
+						       cmd->flags));
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -2387,9 +2385,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			cmd->convert_arg =
 			    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
 							       cmd->convert_arg,
-							       cmd->
-							       flags &
-							       TRIG_ROUND_MASK));
+							       cmd->flags));
 			if (tmp != cmd->convert_arg)
 				err++;
 			if (cmd->scan_begin_src == TRIG_TIMER &&
@@ -3386,9 +3382,7 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		cmd->scan_begin_arg =
 		    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
 						       cmd->scan_begin_arg,
-						       cmd->
-						       flags &
-						       TRIG_ROUND_MASK));
+						       cmd->flags));
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}

commit 07e6b2e2a89ae6c0b61c270099fa23c06ca08ce6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 13:29:53 2014 -0700

    staging: comedi: ni_mio_common: consolidate call to ni_mseries_get_pll_parameters()
    
    All cases of the switch call ni_mseries_get_pll_parameters() with the same
    parameters. Move the call out of the switch.
    
    Also, move the printk from ni_mseries_get_pll_parameters() so that it can
    be converted into a dev_err().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index efe62affdba1..551a150685a9 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4902,10 +4902,9 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 			}
 		}
 	}
-	if (best_period_picosec == 0) {
-		printk("%s: bug, failed to find pll parameters\n", __func__);
+	if (best_period_picosec == 0)
 		return -EIO;
-	}
+
 	*freq_divider = best_div;
 	*freq_multiplier = best_mult;
 	*actual_period_ns =
@@ -4948,21 +4947,11 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 	case NI_MIO_PLL_PXI_STAR_TRIGGER_CLOCK:
 		devpriv->clock_and_fout2 |=
 		    MSeries_PLL_In_Source_Select_Star_Trigger_Bits;
-		retval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,
-						       &freq_multiplier,
-						       &devpriv->clock_ns);
-		if (retval < 0)
-			return retval;
 		break;
 	case NI_MIO_PLL_PXI10_CLOCK:
 		/* pxi clock is 10MHz */
 		devpriv->clock_and_fout2 |=
 		    MSeries_PLL_In_Source_Select_PXI_Clock10;
-		retval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,
-						       &freq_multiplier,
-						       &devpriv->clock_ns);
-		if (retval < 0)
-			return retval;
 		break;
 	default:
 		{
@@ -4981,16 +4970,19 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 			}
 			if (rtsi_channel > max_rtsi_channel)
 				return -EINVAL;
-			retval = ni_mseries_get_pll_parameters(period_ns,
-							       &freq_divider,
-							       &freq_multiplier,
-							       &devpriv->
-							       clock_ns);
-			if (retval < 0)
-				return retval;
 		}
 		break;
 	}
+	retval = ni_mseries_get_pll_parameters(period_ns,
+					       &freq_divider,
+					       &freq_multiplier,
+					       &devpriv->clock_ns);
+	if (retval < 0) {
+		dev_err(dev->class_dev,
+			"%s: bug, failed to find pll parameters\n", __func__);
+		return retval;
+	}
+
 	ni_writew(dev, devpriv->clock_and_fout2, M_Offset_Clock_and_Fout2);
 	pll_control_bits |=
 	    MSeries_PLL_Divisor_Bits(freq_divider) |

commit 89c4695efd4b7d107a9ddbcf5c58b21051939d98
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 13:29:52 2014 -0700

    staging: comedi: ni_mio_common: convert printk messages to dev_err
    
    Where possible, convert the printk() messages in this file to dev_err().
    
    Remove a couple commented out printk() messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 751a1f418a9c..efe62affdba1 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -682,8 +682,8 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 		ni_writeb(dev, devpriv->g0_g1_select_reg, G0_G1_Select);
 		break;
 	default:
-		printk("Warning %s() called with invalid register\n", __func__);
-		printk("reg is %d\n", reg);
+		dev_err(dev->class_dev,
+			"%s called with invalid register %d\n", __func__, reg);
 		break;
 	}
 	mmiowb();
@@ -1082,11 +1082,11 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 			udelay(5);
 		}
 		if (i == timeout) {
-			printk("ni_mio_common: wait for dma drain timed out\n");
-			printk
-			    ("mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
-			     mite_bytes_in_transit(devpriv->ai_mite_chan),
-			     ni_stc_readw(dev, AI_Status_1_Register));
+			dev_err(dev->class_dev, "%s timed out\n", __func__);
+			dev_err(dev->class_dev,
+				"mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
+				mite_bytes_in_transit(devpriv->ai_mite_chan),
+				ni_stc_readw(dev, AI_Status_1_Register));
 			retval = -1;
 		}
 	}
@@ -1512,9 +1512,9 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	if (ai_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
 			       CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
 			       CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
-		printk
-		    ("unknown mite interrupt, ack! (ai_mite_status=%08x)\n",
-		     ai_mite_status);
+		dev_err(dev->class_dev,
+			"unknown mite interrupt (ai_mite_status=%08x)\n",
+			ai_mite_status);
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		/* disable_irq(dev->irq); */
 	}
@@ -1524,8 +1524,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	if (status & (AI_Overrun_St | AI_Overflow_St | AI_SC_TC_Error_St |
 		      AI_SC_TC_St | AI_START1_St)) {
 		if (status == 0xffff) {
-			printk
-			    ("ni_mio_common: a_status=0xffff.  Card removed?\n");
+			dev_err(dev->class_dev, "Card removed?\n");
 			/* we probably aren't even running a command now,
 			 * so it's a good idea to be careful. */
 			if (comedi_is_subdevice_running(s)) {
@@ -1537,8 +1536,8 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 		}
 		if (status & (AI_Overrun_St | AI_Overflow_St |
 			      AI_SC_TC_Error_St)) {
-			printk("ni_mio_common: ai error a_status=%04x\n",
-			       status);
+			dev_err(dev->class_dev, "ai error a_status=%04x\n",
+				status);
 
 			shutdown_ai_command(dev);
 
@@ -1614,9 +1613,9 @@ static void handle_b_interrupt(struct comedi_device *dev,
 	if (ao_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
 			       CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
 			       CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
-		printk
-		    ("unknown mite interrupt, ack! (ao_mite_status=%08x)\n",
-		     ao_mite_status);
+		dev_err(dev->class_dev,
+			"unknown mite interrupt (ao_mite_status=%08x)\n",
+			ao_mite_status);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
 #endif
@@ -1624,9 +1623,9 @@ static void handle_b_interrupt(struct comedi_device *dev,
 	if (b_status == 0xffff)
 		return;
 	if (b_status & AO_Overrun_St) {
-		printk
-		    ("ni_mio_common: AO FIFO underrun status=0x%04x status2=0x%04x\n",
-		     b_status, ni_stc_readw(dev, AO_Status_2_Register));
+		dev_err(dev->class_dev,
+			"AO FIFO underrun status=0x%04x status2=0x%04x\n",
+			b_status, ni_stc_readw(dev, AO_Status_2_Register));
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 
@@ -1639,7 +1638,7 @@ static void handle_b_interrupt(struct comedi_device *dev,
 
 		ret = ni_ao_fifo_half_empty(dev, s);
 		if (!ret) {
-			printk("ni_mio_common: AO buffer underrun\n");
+			dev_err(dev->class_dev, "AO buffer underrun\n");
 			ni_set_bits(dev, Interrupt_B_Enable_Register,
 				    AO_FIFO_Interrupt_Enable |
 				    AO_Error_Interrupt_Enable, 0);
@@ -1691,7 +1690,6 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 	retval = ni_request_ai_mite_channel(dev);
 	if (retval)
 		return retval;
-/* printk("comedi_debug: using mite channel %i for ai.\n", devpriv->ai_mite_chan->channel); */
 
 	/* write alloc the entire buffer */
 	comedi_buf_write_alloc(s, s->async->prealloc_bufsz);
@@ -1888,7 +1886,7 @@ static void ni_prime_channelgain_list(struct comedi_device *dev)
 		}
 		udelay(1);
 	}
-	printk("ni_mio_common: timeout loading channel/gain list\n");
+	dev_err(dev->class_dev, "timeout loading channel/gain list\n");
 }
 
 static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
@@ -2156,8 +2154,8 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				}
 			}
 			if (i == NI_TIMEOUT) {
-				printk
-				    ("ni_mio_common: timeout in 611x ni_ai_insn_read\n");
+				dev_err(dev->class_dev, "%s timeout\n",
+					__func__);
 				return -ETIME;
 			}
 			d += signbits;
@@ -2180,8 +2178,8 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				}
 			}
 			if (i == NI_TIMEOUT) {
-				printk
-				    ("ni_mio_common: timeout in 6143 ni_ai_insn_read\n");
+				dev_err(dev->class_dev, "%s timeout\n",
+					__func__);
 				return -ETIME;
 			}
 			data[n] = (((dl >> 16) & 0xFFFF) + signbits) & 0xFFFF;
@@ -2196,8 +2194,8 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 					break;
 			}
 			if (i == NI_TIMEOUT) {
-				printk
-				    ("ni_mio_common: timeout in ni_ai_insn_read\n");
+				dev_err(dev->class_dev, "%s timeout\n",
+					__func__);
 				return -ETIME;
 			}
 			if (devpriv->is_m_series) {
@@ -2857,8 +2855,9 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 				  M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		default:
-			printk("%s: bug! unhandled ao reference voltage\n",
-			       __func__);
+			dev_err(dev->class_dev,
+				"%s: bug! unhandled ao reference voltage\n",
+				__func__);
 			break;
 		}
 		switch (krange->max + krange->min) {
@@ -2869,8 +2868,9 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 			conf |= MSeries_AO_DAC_Offset_5V_Bits;
 			break;
 		default:
-			printk("%s: bug! unhandled ao offset voltage\n",
-			       __func__);
+			dev_err(dev->class_dev,
+				"%s: bug! unhandled ao offset voltage\n",
+				__func__);
 			break;
 		}
 		if (timed)
@@ -3721,14 +3721,12 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 
 	cdio_status = ni_readl(dev, M_Offset_CDIO_Status);
 	if (cdio_status & (CDO_Overrun_Bit | CDO_Underflow_Bit)) {
-		/* printk("cdio error: statux=0x%x\n", cdio_status); */
 		/* XXX just guessing this is needed and does something useful */
 		ni_writel(dev, CDO_Error_Interrupt_Confirm_Bit,
 			  M_Offset_CDIO_Command);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 	if (cdio_status & CDO_FIFO_Empty_Bit) {
-		/* printk("cdio fifo empty\n"); */
 		ni_writel(dev, CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
 			  M_Offset_CDIO_Command);
 		/* s->async->events |= COMEDI_CB_EOA; */
@@ -3765,8 +3763,9 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 		/* Delay one bit per loop */
 		udelay((devpriv->serial_interval_ns + 999) / 1000);
 		if (--count < 0) {
-			printk
-			    ("ni_serial_hw_readwrite8: SPI serial I/O didn't finish in time!\n");
+			dev_err(dev->class_dev,
+				"%s: SPI serial I/O didn't finish in time!\n",
+				__func__);
 			err = -ETIME;
 			goto Error;
 		}
@@ -3818,10 +3817,8 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
 		/* Input current bit */
-		if (ni_stc_readw(dev, DIO_Parallel_Input_Register) & DIO_SDIN) {
-			/* printk("DIO_P_I_R: 0x%x\n", ni_stc_readw(dev, DIO_Parallel_Input_Register)); */
+		if (ni_stc_readw(dev, DIO_Parallel_Input_Register) & DIO_SDIN)
 			input |= mask;
-		}
 	}
 
 	if (data_in)
@@ -3906,7 +3903,8 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 			err = ni_serial_sw_readwrite8(dev, s, byte_out,
 						      &byte_in);
 		} else {
-			printk("ni_serial_insn_config: serial disabled!\n");
+			dev_err(dev->class_dev, "%s: serial disabled!\n",
+				__func__);
 			return -EINVAL;
 		}
 		if (err < 0)
@@ -4416,7 +4414,6 @@ static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 	int i;
 	int type;
 
-	/* printk("ni_write_caldac: chan=%d val=%d\n",addr,val); */
 	if (devpriv->caldacs[addr] == val)
 		return;
 	devpriv->caldacs[addr] = val;
@@ -4428,7 +4425,6 @@ static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 		if (addr < caldacs[type].n_chans) {
 			bits = caldacs[type].packbits(addr, val, &bitstring);
 			loadbit = SerDacLd(i);
-			/* printk("caldac: using i=%d addr=%d %x\n",i,addr,bitstring); */
 			break;
 		}
 		addr -= caldacs[type].n_chans;
@@ -4499,7 +4495,8 @@ static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 		unsigned int *maxdata_list;
 
 		if (n_chans > MAX_N_CALDACS)
-			printk("BUG! MAX_N_CALDACS too small\n");
+			dev_err(dev->class_dev,
+				"BUG! MAX_N_CALDACS too small\n");
 		s->maxdata_list = maxdata_list = devpriv->caldac_maxdata_list;
 		chan = 0;
 		for (i = 0; i < n_dacs; i++) {
@@ -4594,7 +4591,8 @@ static unsigned ni_old_get_pfi_routing(struct comedi_device *dev,
 	case 9:
 		return NI_PFI_OUTPUT_G_GATE0;
 	default:
-		printk("%s: bug, unhandled case in switch.\n", __func__);
+		dev_err(dev->class_dev,
+			"%s: bug, unhandled case in switch.\n", __func__);
 		break;
 	}
 	return 0;
@@ -4745,9 +4743,8 @@ static int cs5529_wait_for_idle(struct comedi_device *dev)
 		if (schedule_timeout(1))
 			return -EIO;
 	}
-/* printk("looped %i times waiting for idle\n", i); */
 	if (i == timeout) {
-		printk("%s: %s: timeout\n", __FILE__, __func__);
+		dev_err(dev->class_dev, "%s timeout\n", __func__);
 		return -ETIME;
 	}
 	return 0;
@@ -4768,7 +4765,6 @@ static void cs5529_command(struct comedi_device *dev, unsigned short value)
 			break;
 		udelay(1);
 	}
-/* printk("looped %i times writing command to cs5529\n", i); */
 	if (i == timeout)
 		dev_err(dev->class_dev,
 			"possible problem - never saw adc go busy?\n");
@@ -4789,13 +4785,13 @@ static int cs5529_do_conversion(struct comedi_device *dev,
 	}
 	status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
 	if (status & CSS_OSC_DETECT) {
-		printk
-		    ("ni_mio_common: cs5529 conversion error, status CSS_OSC_DETECT\n");
+		dev_err(dev->class_dev,
+			"cs5529 conversion error, status CSS_OSC_DETECT\n");
 		return -EIO;
 	}
 	if (status & CSS_OVERRANGE) {
-		printk
-		    ("ni_mio_common: cs5529 conversion error, overrange (ignoring)\n");
+		dev_err(dev->class_dev,
+			"cs5529 conversion error, overrange (ignoring)\n");
 	}
 	if (data) {
 		*data = ni_ao_win_inw(dev, CAL_ADC_Data_67xx);
@@ -4935,10 +4931,9 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 		period_ns = 100;
 	/*  these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that */
 	if (period_ns < min_period_ns || period_ns > max_period_ns) {
-		printk
-		    ("%s: you must specify an input clock frequency between %i and %i nanosec "
-		     "for the phased-lock loop.\n", __func__,
-		     min_period_ns, max_period_ns);
+		dev_err(dev->class_dev,
+			"%s: you must specify an input clock frequency between %i and %i nanosec for the phased-lock loop\n",
+			__func__, min_period_ns, max_period_ns);
 		return -EINVAL;
 	}
 	devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
@@ -5001,9 +4996,6 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 	    MSeries_PLL_Divisor_Bits(freq_divider) |
 	    MSeries_PLL_Multiplier_Bits(freq_multiplier);
 
-	/* printk("using divider=%i, multiplier=%i for PLL. pll_control_bits = 0x%x\n",
-	 * freq_divider, freq_multiplier, pll_control_bits); */
-	/* printk("clock_ns=%d\n", devpriv->clock_ns); */
 	ni_writew(dev, pll_control_bits, M_Offset_PLL_Control);
 	devpriv->clock_source = source;
 	/* it seems to typically take a few hundred microseconds for PLL to lock */
@@ -5013,9 +5005,9 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 		udelay(1);
 	}
 	if (i == timeout) {
-		printk
-		    ("%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns.\n",
-		     __func__, source, period_ns);
+		dev_err(dev->class_dev,
+			"%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns\n",
+			__func__, source, period_ns);
 		return -ETIMEDOUT;
 	}
 	return 3;
@@ -5052,9 +5044,9 @@ static int ni_set_master_clock(struct comedi_device *dev,
 					      devpriv->rtsi_trig_direction_reg,
 					      RTSI_Trig_Direction_Register);
 				if (period_ns == 0) {
-					printk
-					    ("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",
-					     __func__);
+					dev_err(dev->class_dev,
+						"%s: we don't handle an unspecified clock period correctly yet, returning error\n",
+						__func__);
 					return -EINVAL;
 				}
 				devpriv->clock_ns = period_ns;
@@ -5083,8 +5075,9 @@ static int ni_valid_rtsi_output_source(struct comedi_device *dev,
 			if (source == NI_RTSI_OUTPUT_RTSI_OSC)
 				return 1;
 
-			printk("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",
-			       __func__, chan, old_RTSI_clock_channel);
+			dev_err(dev->class_dev,
+				"%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards\n",
+				__func__, chan, old_RTSI_clock_channel);
 			return 0;
 		}
 		return 0;
@@ -5143,7 +5136,8 @@ static unsigned ni_get_rtsi_routing(struct comedi_device *dev, unsigned chan)
 	} else {
 		if (chan == old_RTSI_clock_channel)
 			return NI_RTSI_OUTPUT_RTSI_OSC;
-		printk("%s: bug! should never get here?\n", __func__);
+		dev_err(dev->class_dev, "%s: bug! should never get here?\n",
+			__func__);
 		return 0;
 	}
 }
@@ -5229,7 +5223,7 @@ static void ni_rtsi_init(struct comedi_device *dev)
 	/*  Set clock mode to internal */
 	devpriv->clock_and_fout2 = MSeries_RTSI_10MHz_Bit;
 	if (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0)
-		printk("ni_set_master_clock failed, bug?");
+		dev_err(dev->class_dev, "ni_set_master_clock failed, bug?\n");
 	/*  default internal lines routing to RTSI bus lines */
 	devpriv->rtsi_trig_a_output_reg =
 	    RTSI_Trig_Output_Bits(0,
@@ -5321,7 +5315,6 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 {
 	int temp_ack_reg = 0;
 
-	/* printk("GPCT_Reset..."); */
 	devpriv->gpct_cur_operation[chan] = GPCT_RESET;
 
 	switch (chan) {
@@ -5370,8 +5363,6 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 	ni_stc_writew(dev, devpriv->gpct_input_select[chan],
 		      G_Input_Select_Register(chan));
 	ni_stc_writew(dev, 0, G_Autoincrement_Register(chan));
-
-	/* printk("exit GPCT_Reset\n"); */
 }
 #endif
 
@@ -5460,7 +5451,7 @@ static int ni_E_init(struct comedi_device *dev,
 	int i;
 
 	if (board->n_aochan > MAX_N_AO_CHAN) {
-		printk("bug! n_aochan > MAX_N_AO_CHAN\n");
+		dev_err(dev->class_dev, "bug! n_aochan > MAX_N_AO_CHAN\n");
 		return -EINVAL;
 	}
 

commit 5ac1d82bb41942245f6605771a7defb8e931e317
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:33 2014 -0700

    staging: comedi: ni_mio_common: remove use of comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character. The addition of the driver_name is just added noise
    and some of the users of comedi_error() add unnecessary additional new-line
    characters.
    
    Use dev_err() directly instead of comedi_error() to avoid any confusion
    and so that all the comedi generated kernel messages have the same format.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index f00290a93412..751a1f418a9c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -771,8 +771,8 @@ static int ni_request_ai_mite_channel(struct comedi_device *dev)
 	    mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);
 	if (devpriv->ai_mite_chan == NULL) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-		comedi_error(dev,
-			     "failed to reserve mite dma channel for analog input.");
+		dev_err(dev->class_dev,
+			"failed to reserve mite dma channel for analog input\n");
 		return -EBUSY;
 	}
 	devpriv->ai_mite_chan->dir = COMEDI_INPUT;
@@ -792,8 +792,8 @@ static int ni_request_ao_mite_channel(struct comedi_device *dev)
 	    mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);
 	if (devpriv->ao_mite_chan == NULL) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-		comedi_error(dev,
-			     "failed to reserve mite dma channel for analog outut.");
+		dev_err(dev->class_dev,
+			"failed to reserve mite dma channel for analog outut\n");
 		return -EBUSY;
 	}
 	devpriv->ao_mite_chan->dir = COMEDI_OUTPUT;
@@ -818,8 +818,8 @@ static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 				 devpriv->gpct_mite_ring[gpct_index]);
 	if (mite_chan == NULL) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-		comedi_error(dev,
-			     "failed to reserve mite dma channel for counter.");
+		dev_err(dev->class_dev,
+			"failed to reserve mite dma channel for counter\n");
 		return -EBUSY;
 	}
 	mite_chan->dir = direction;
@@ -844,8 +844,8 @@ static int ni_request_cdo_mite_channel(struct comedi_device *dev)
 	    mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);
 	if (devpriv->cdo_mite_chan == NULL) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-		comedi_error(dev,
-			     "failed to reserve mite dma channel for correlated digital outut.");
+		dev_err(dev->class_dev,
+			"failed to reserve mite dma channel for correlated digital output\n");
 		return -EBUSY;
 	}
 	devpriv->cdo_mite_chan->dir = COMEDI_OUTPUT;
@@ -971,7 +971,7 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 			udelay(1);
 		}
 		if (i == timeout)
-			comedi_error(dev, "FIFO flush timeout.");
+			dev_err(dev->class_dev, "FIFO flush timeout\n");
 	} else {
 		ni_stc_writew(dev, 1, ADC_FIFO_Clear);
 		if (devpriv->is_625x) {
@@ -1126,7 +1126,7 @@ static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 		udelay(10);
 	}
 	if (i == timeout) {
-		comedi_error(dev, "timed out waiting for dma load");
+		dev_err(dev->class_dev, "timed out waiting for dma load\n");
 		return -EPIPE;
 	}
 	return 0;
@@ -1291,7 +1291,8 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 	} else {
 		if (n > sizeof(devpriv->ai_fifo_buffer) /
 		    sizeof(devpriv->ai_fifo_buffer[0])) {
-			comedi_error(dev, "bug! ai_fifo_buffer too small");
+			dev_err(dev->class_dev,
+				"bug! ai_fifo_buffer too small\n");
 			async->events |= COMEDI_CB_ERROR;
 			return;
 		}
@@ -2438,7 +2439,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int interrupt_a_enable = 0;
 
 	if (dev->irq == 0) {
-		comedi_error(dev, "cannot run command without an irq");
+		dev_err(dev->class_dev, "cannot run command without an irq\n");
 		return -EIO;
 	}
 	ni_clear_ai_fifo(dev);
@@ -3088,8 +3089,8 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 			break;
 	}
 	if (i == timeout) {
-		comedi_error(dev,
-			     "timed out waiting for AO_TMRDACWRs_In_Progress_St to clear");
+		dev_err(dev->class_dev,
+			"timed out waiting for AO_TMRDACWRs_In_Progress_St to clear\n");
 		return -EIO;
 	}
 	/*
@@ -3121,7 +3122,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned trigvar;
 
 	if (dev->irq == 0) {
-		comedi_error(dev, "cannot run command without an irq");
+		dev_err(dev->class_dev, "cannot run command without an irq\n");
 		return -EIO;
 	}
 
@@ -3611,7 +3612,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 		mite_prep_dma(devpriv->cdo_mite_chan, 32, 32);
 		mite_dma_arm(devpriv->cdo_mite_chan);
 	} else {
-		comedi_error(dev, "BUG: no cdo mite channel?");
+		dev_err(dev->class_dev, "BUG: no cdo mite channel?\n");
 		retval = -EIO;
 	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
@@ -3629,7 +3630,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 		udelay(10);
 	}
 	if (i == timeout) {
-		comedi_error(dev, "dma failed to fill cdo fifo!");
+		dev_err(dev->class_dev, "dma failed to fill cdo fifo!\n");
 		s->cancel(dev, s);
 		return -EIO;
 	}
@@ -3664,8 +3665,8 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_writel(dev, CDO_SW_Update_Bit, M_Offset_CDIO_Command);
 		ni_writel(dev, s->io_bits, M_Offset_CDO_Mask_Enable);
 	} else {
-		comedi_error(dev,
-			     "attempted to run digital output command with no lines configured as outputs");
+		dev_err(dev->class_dev,
+			"attempted to run digital output command with no lines configured as outputs\n");
 		return -EIO;
 	}
 	retval = ni_request_cdo_mite_channel(dev);
@@ -4769,7 +4770,8 @@ static void cs5529_command(struct comedi_device *dev, unsigned short value)
 	}
 /* printk("looped %i times writing command to cs5529\n", i); */
 	if (i == timeout)
-		comedi_error(dev, "possible problem - never saw adc go busy?");
+		dev_err(dev->class_dev,
+			"possible problem - never saw adc go busy?\n");
 }
 
 static int cs5529_do_conversion(struct comedi_device *dev,
@@ -4781,8 +4783,8 @@ static int cs5529_do_conversion(struct comedi_device *dev,
 	cs5529_command(dev, CSCMD_COMMAND | CSCMD_SINGLE_CONVERSION);
 	retval = cs5529_wait_for_idle(dev);
 	if (retval) {
-		comedi_error(dev,
-			     "timeout or signal in cs5529_do_conversion()");
+		dev_err(dev->class_dev,
+			"timeout or signal in cs5529_do_conversion()\n");
 		return -ETIME;
 	}
 	status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
@@ -4841,7 +4843,8 @@ static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
 	reg_select_bits &= CSCMD_REGISTER_SELECT_MASK;
 	cs5529_command(dev, CSCMD_COMMAND | reg_select_bits);
 	if (cs5529_wait_for_idle(dev))
-		comedi_error(dev, "time or signal in cs5529_config_write()");
+		dev_err(dev->class_dev,
+			"timeout or signal in %s\n", __func__);
 }
 
 static int init_cs5529(struct comedi_device *dev)
@@ -4861,7 +4864,8 @@ static int init_cs5529(struct comedi_device *dev)
 	cs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET,
 			    CSCMD_CONFIG_REGISTER);
 	if (cs5529_wait_for_idle(dev))
-		comedi_error(dev, "timeout or signal in init_cs5529()\n");
+		dev_err(dev->class_dev,
+			"timeout or signal in %s\n", __func__);
 #endif
 	return 0;
 }
@@ -5264,8 +5268,8 @@ static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	retval = ni_request_gpct_mite_channel(dev, counter->counter_index,
 					      COMEDI_INPUT);
 	if (retval) {
-		comedi_error(dev,
-			     "no dma channel available for use by counter");
+		dev_err(dev->class_dev,
+			"no dma channel available for use by counter\n");
 		return retval;
 	}
 	ni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);

commit a62669775f4710d5dc72a1ef1b9ea6fe5ce4a73d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:22:56 2014 -0700

    staging: comedi: ni_mio_common: checkpatch.pl cleanup (braces not necessary)
    
    Fix the checkpatch.pl warnings:
    
    WARNING: braces {} are not necessary for single statement blocks
    WARNING: braces {} are not necessary for any arm of this statement
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index af5ee50ef80d..f00290a93412 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -970,9 +970,8 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 				break;
 			udelay(1);
 		}
-		if (i == timeout) {
+		if (i == timeout)
 			comedi_error(dev, "FIFO flush timeout.");
-		}
 	} else {
 		ni_stc_writew(dev, 1, ADC_FIFO_Clear);
 		if (devpriv->is_625x) {
@@ -2054,11 +2053,10 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 	}
 
 	for (i = 0; i < n_chan; i++) {
-		if (!devpriv->is_6143 && (list[i] & CR_ALT_SOURCE)) {
+		if (!devpriv->is_6143 && (list[i] & CR_ALT_SOURCE))
 			chan = devpriv->ai_calib_source;
-		} else {
+		else
 			chan = CR_CHAN(list[i]);
-		}
 		aref = CR_AREF(list[i]);
 		range = CR_RANGE(list[i]);
 		dither = ((list[i] & CR_ALT_FILTER) != 0);

commit f740197959bb7faab0ed1782b0b203d5b5aa8316
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:02:08 2014 -0700

    staging: comedi: ni_mio_common: checkpatch.pl cleanup (missing blank line)
    
    Fix the checkpatch.pl warnings:
    
    WARNING: Missing a blank line after declarations
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b630c66dda4b..af5ee50ef80d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1115,6 +1115,7 @@ static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 {
 	static const int timeout = 10000;
 	int i;
+
 	for (i = 0; i < timeout; i++) {
 		unsigned short b_status;
 
@@ -1810,6 +1811,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 			      AI_Output_Control_Register);
 	} else {
 		unsigned ai_output_control_bits;
+
 		ni_stc_writew(dev,
 			      AI_SHIFTIN_Pulse_Width |
 			      AI_SOC_Polarity |
@@ -1904,6 +1906,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 
 	if ((list[0] & CR_ALT_SOURCE)) {
 		unsigned bypass_bits;
+
 		chan = CR_CHAN(list[0]);
 		range = CR_RANGE(list[0]);
 		range_code = ni_gainlkup[board->gainlkup][range];
@@ -1927,6 +1930,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 	}
 	for (i = 0; i < n_chan; i++) {
 		unsigned config_bits = 0;
+
 		chan = CR_CHAN(list[i]);
 		aref = CR_AREF(list[i]);
 		range = CR_RANGE(list[i]);
@@ -2703,6 +2707,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 #ifdef PCIDMA
 	{
 		int retval = ni_ai_setup_MITE_dma(dev);
+
 		if (retval)
 			return retval;
 	}
@@ -2825,6 +2830,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 	}
 	for (i = 0; i < n_chans; i++) {
 		const struct comedi_krange *krange;
+
 		chan = CR_CHAN(chanspec[i]);
 		range = CR_RANGE(chanspec[i]);
 		krange = s->range_table->range + range;
@@ -3249,6 +3255,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			      AO_Output_Control_Register);
 	} else {
 		unsigned bits;
+
 		devpriv->ao_mode1 &= ~AO_Multiple_Channels;
 		bits = AO_UPDATE_Output_Select(AO_Update_Output_High_Z);
 		if (devpriv->is_m_series || devpriv->is_6xxx) {
@@ -3426,6 +3433,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->is_6xxx) {
 		unsigned immediate_bits = 0;
 		unsigned i;
+
 		for (i = 0; i < s->n_chan; ++i)
 			immediate_bits |= 1 << i;
 		ni_ao_win_outw(dev, immediate_bits, AO_Immediate_671x);
@@ -3928,6 +3936,7 @@ static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)
 static unsigned ni_gpct_to_stc_register(enum ni_gpct_register reg)
 {
 	unsigned stc_register;
+
 	switch (reg) {
 	case NITIO_G0_AUTO_INC:
 		stc_register = G_Autoincrement_Register(0);
@@ -4882,6 +4891,7 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 	static const unsigned target_picosec = 12500;
 	static const unsigned fudge_factor_80_to_20Mhz = 4;
 	int best_period_picosec = 0;
+
 	for (div = 1; div <= max_div; ++div) {
 		for (mult = 1; mult <= max_mult; ++mult) {
 			unsigned new_period_ps =
@@ -4961,6 +4971,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 		{
 			unsigned rtsi_channel;
 			static const unsigned max_rtsi_channel = 7;
+
 			for (rtsi_channel = 0; rtsi_channel <= max_rtsi_channel;
 			     ++rtsi_channel) {
 				if (source ==
@@ -5758,6 +5769,7 @@ static int ni_E_init(struct comedi_device *dev,
 		ni_writeb(dev, 0, Magic_611x);
 	} else if (devpriv->is_m_series) {
 		int channel;
+
 		for (channel = 0; channel < board->n_aochan; ++channel) {
 			ni_writeb(dev, 0xf,
 				  M_Offset_AO_Waveform_Order(channel));

commit 0953ee4acca08f4bfa9857d4156f4282d30f1a10
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:34 2014 -0700

    staging: comedi: ni_mio_common: checkpatch.pl cleanup (else not useful)
    
    Fix the checkpatch.pl warnings:
    
    WARNING: else is not generally useful after a break or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index fe88a1cc0b16..b630c66dda4b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -250,8 +250,8 @@ static void ni_writel(struct comedi_device *dev, uint32_t data, int reg)
 
 	if (devpriv->mite)
 		writel(data, devpriv->mite->daq_io_addr + reg);
-	else
-		outl(data, dev->iobase + reg);
+
+	outl(data, dev->iobase + reg);
 }
 
 static void ni_writew(struct comedi_device *dev, uint16_t data, int reg)
@@ -260,8 +260,8 @@ static void ni_writew(struct comedi_device *dev, uint16_t data, int reg)
 
 	if (devpriv->mite)
 		writew(data, devpriv->mite->daq_io_addr + reg);
-	else
-		outw(data, dev->iobase + reg);
+
+	outw(data, dev->iobase + reg);
 }
 
 static void ni_writeb(struct comedi_device *dev, uint8_t data, int reg)
@@ -270,8 +270,8 @@ static void ni_writeb(struct comedi_device *dev, uint8_t data, int reg)
 
 	if (devpriv->mite)
 		writeb(data, devpriv->mite->daq_io_addr + reg);
-	else
-		outb(data, dev->iobase + reg);
+
+	outb(data, dev->iobase + reg);
 }
 
 static uint32_t ni_readl(struct comedi_device *dev, int reg)
@@ -280,8 +280,8 @@ static uint32_t ni_readl(struct comedi_device *dev, int reg)
 
 	if (devpriv->mite)
 		return readl(devpriv->mite->daq_io_addr + reg);
-	else
-		return inl(dev->iobase + reg);
+
+	return inl(dev->iobase + reg);
 }
 
 static uint16_t ni_readw(struct comedi_device *dev, int reg)
@@ -290,8 +290,8 @@ static uint16_t ni_readw(struct comedi_device *dev, int reg)
 
 	if (devpriv->mite)
 		return readw(devpriv->mite->daq_io_addr + reg);
-	else
-		return inw(dev->iobase + reg);
+
+	return inw(dev->iobase + reg);
 }
 
 static uint8_t ni_readb(struct comedi_device *dev, int reg)
@@ -300,8 +300,8 @@ static uint8_t ni_readb(struct comedi_device *dev, int reg)
 
 	if (devpriv->mite)
 		return readb(devpriv->mite->daq_io_addr + reg);
-	else
-		return inb(dev->iobase + reg);
+
+	return inb(dev->iobase + reg);
 }
 
 /*
@@ -4195,9 +4195,9 @@ static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 	if (dir) {
 		ni_writeb(dev, data, Port_A + 2 * port);
 		return 0;
-	} else {
-		return ni_readb(dev, Port_A + 2 * port);
 	}
+
+	return ni_readb(dev, Port_A + 2 * port);
 }
 
 static int ni_get_pwm_config(struct comedi_device *dev, unsigned int *data)
@@ -4635,10 +4635,9 @@ static unsigned ni_get_pfi_routing(struct comedi_device *dev, unsigned chan)
 {
 	struct ni_private *devpriv = dev->private;
 
-	if (devpriv->is_m_series)
-		return ni_m_series_get_pfi_routing(dev, chan);
-	else
-		return ni_old_get_pfi_routing(dev, chan);
+	return (devpriv->is_m_series)
+			? ni_m_series_get_pfi_routing(dev, chan)
+			: ni_old_get_pfi_routing(dev, chan);
 }
 
 static int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,
@@ -4646,10 +4645,9 @@ static int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,
 {
 	struct ni_private *devpriv = dev->private;
 
-	if (devpriv->is_m_series)
-		return ni_m_series_set_pfi_routing(dev, chan, source);
-	else
-		return ni_old_set_pfi_routing(dev, chan, source);
+	return (devpriv->is_m_series)
+			? ni_m_series_set_pfi_routing(dev, chan, source)
+			: ni_old_set_pfi_routing(dev, chan, source);
 }
 
 static int ni_config_filter(struct comedi_device *dev,
@@ -5045,9 +5043,8 @@ static int ni_set_master_clock(struct comedi_device *dev,
 					    ("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",
 					     __func__);
 					return -EINVAL;
-				} else {
-					devpriv->clock_ns = period_ns;
 				}
+				devpriv->clock_ns = period_ns;
 				devpriv->clock_source = source;
 			} else
 				return -EINVAL;
@@ -5060,10 +5057,7 @@ static unsigned num_configurable_rtsi_channels(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
 
-	if (devpriv->is_m_series)
-		return 8;
-	else
-		return 7;
+	return (devpriv->is_m_series) ? 8 : 7;
 }
 
 static int ni_valid_rtsi_output_source(struct comedi_device *dev,
@@ -5075,12 +5069,10 @@ static int ni_valid_rtsi_output_source(struct comedi_device *dev,
 		if (chan == old_RTSI_clock_channel) {
 			if (source == NI_RTSI_OUTPUT_RTSI_OSC)
 				return 1;
-			else {
-				printk
-				    ("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",
-				     __func__, chan, old_RTSI_clock_channel);
-				return 0;
-			}
+
+			printk("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",
+			       __func__, chan, old_RTSI_clock_channel);
+			return 0;
 		}
 		return 0;
 	}

commit 959409613df8368d394033c1d5ab2eab827d2c51
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:33 2014 -0700

    staging: comedi: ni_mio_common: checkpatch.pl cleanup (break not useful)
    
    Fix the checkpatch.pl warning:
    
    WARNING: break is not useful after a goto or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 01b29d5ec392..fe88a1cc0b16 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -223,10 +223,8 @@ static inline unsigned NI_GPCT_SUBDEV(unsigned counter_index)
 	switch (counter_index) {
 	case 0:
 		return NI_GPCT0_SUBDEV;
-		break;
 	case 1:
 		return NI_GPCT1_SUBDEV;
-		break;
 	default:
 		break;
 	}
@@ -3026,7 +3024,6 @@ static int ni_ao_insn_config(struct comedi_device *dev,
 			break;
 		default:
 			return -EINVAL;
-			break;
 		}
 		return 0;
 	default:
@@ -4015,7 +4012,6 @@ static unsigned ni_gpct_to_stc_register(enum ni_gpct_register reg)
 		       __func__, reg);
 		BUG();
 		return 0;
-		break;
 	}
 	return stc_register;
 }
@@ -4113,7 +4109,6 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 	default:
 		stc_register = ni_gpct_to_stc_register(reg);
 		return ni_stc_readw(dev, stc_register);
-		break;
 	}
 	return 0;
 }
@@ -4240,7 +4235,6 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 			break;
 		default:
 			return -EINVAL;
-			break;
 		}
 		switch (data[3]) {
 		case TRIG_ROUND_NEAREST:
@@ -4258,7 +4252,6 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 			break;
 		default:
 			return -EINVAL;
-			break;
 		}
 		if (up_count * devpriv->clock_ns != data[2] ||
 		    down_count * devpriv->clock_ns != data[4]) {
@@ -4272,13 +4265,10 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 		devpriv->pwm_up_count = up_count;
 		devpriv->pwm_down_count = down_count;
 		return 5;
-		break;
 	case INSN_CONFIG_GET_PWM_OUTPUT:
 		return ni_get_pwm_config(dev, data);
-		break;
 	default:
 		return -EINVAL;
-		break;
 	}
 	return 0;
 }
@@ -4309,7 +4299,6 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 			break;
 		default:
 			return -EINVAL;
-			break;
 		}
 		switch (data[3]) {
 		case TRIG_ROUND_NEAREST:
@@ -4327,7 +4316,6 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 			break;
 		default:
 			return -EINVAL;
-			break;
 		}
 		if (up_count * devpriv->clock_ns != data[2] ||
 		    down_count * devpriv->clock_ns != data[4]) {
@@ -4340,12 +4328,10 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 		ni_writel(dev, down_count, Calibration_LowTime_6143);
 		devpriv->pwm_down_count = down_count;
 		return 5;
-		break;
 	case INSN_CONFIG_GET_PWM_OUTPUT:
 		return ni_get_pwm_config(dev, data);
 	default:
 		return -EINVAL;
-		break;
 	}
 	return 0;
 }
@@ -4581,34 +4567,24 @@ static unsigned ni_old_get_pfi_routing(struct comedi_device *dev,
 	switch (chan) {
 	case 0:
 		return NI_PFI_OUTPUT_AI_START1;
-		break;
 	case 1:
 		return NI_PFI_OUTPUT_AI_START2;
-		break;
 	case 2:
 		return NI_PFI_OUTPUT_AI_CONVERT;
-		break;
 	case 3:
 		return NI_PFI_OUTPUT_G_SRC1;
-		break;
 	case 4:
 		return NI_PFI_OUTPUT_G_GATE1;
-		break;
 	case 5:
 		return NI_PFI_OUTPUT_AO_UPDATE_N;
-		break;
 	case 6:
 		return NI_PFI_OUTPUT_AO_START1;
-		break;
 	case 7:
 		return NI_PFI_OUTPUT_AI_START_PULSE;
-		break;
 	case 8:
 		return NI_PFI_OUTPUT_G_SRC0;
-		break;
 	case 9:
 		return NI_PFI_OUTPUT_G_GATE0;
-		break;
 	default:
 		printk("%s: bug, unhandled case in switch.\n", __func__);
 		break;
@@ -4718,16 +4694,13 @@ static int ni_pfi_insn_config(struct comedi_device *dev,
 		    (devpriv->io_bidirection_pin_reg & (1 << chan)) ?
 		    COMEDI_OUTPUT : COMEDI_INPUT;
 		return 0;
-		break;
 	case INSN_CONFIG_SET_ROUTING:
 		return ni_set_pfi_routing(dev, chan, data[1]);
-		break;
 	case INSN_CONFIG_GET_ROUTING:
 		data[1] = ni_get_pfi_routing(dev, chan);
 		break;
 	case INSN_CONFIG_FILTER:
 		return ni_config_filter(dev, chan, data[1]);
-		break;
 	default:
 		return -EINVAL;
 	}
@@ -5122,16 +5095,10 @@ static int ni_valid_rtsi_output_source(struct comedi_device *dev,
 	case NI_RTSI_OUTPUT_RGOUT0:
 	case NI_RTSI_OUTPUT_RTSI_BRD_0:
 		return 1;
-		break;
 	case NI_RTSI_OUTPUT_RTSI_OSC:
-		if (devpriv->is_m_series)
-			return 1;
-		else
-			return 0;
-		break;
+		return (devpriv->is_m_series) ? 1 : 0;
 	default:
 		return 0;
-		break;
 	}
 }
 
@@ -5221,25 +5188,19 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 			    ? INSN_CONFIG_DIO_OUTPUT : INSN_CONFIG_DIO_INPUT;
 		}
 		return 2;
-		break;
 	case INSN_CONFIG_SET_CLOCK_SRC:
 		return ni_set_master_clock(dev, data[1], data[2]);
-		break;
 	case INSN_CONFIG_GET_CLOCK_SRC:
 		data[1] = devpriv->clock_source;
 		data[2] = devpriv->clock_ns;
 		return 3;
-		break;
 	case INSN_CONFIG_SET_ROUTING:
 		return ni_set_rtsi_routing(dev, chan, data[1]);
-		break;
 	case INSN_CONFIG_GET_ROUTING:
 		data[1] = ni_get_rtsi_routing(dev, chan);
 		return 2;
-		break;
 	default:
 		return -EINVAL;
-		break;
 	}
 	return 1;
 }

commit 4168ac9db7ee98634e7fa15c58ec2165ab80e1a0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:24:05 2014 -0700

    staging: comedi: ni_mio_common: tidy up the frequency output subdevice init
    
    For aesthetics, add some whitespace to the subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 6545f11fe669..01b29d5ec392 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5777,15 +5777,15 @@ static int ni_E_init(struct comedi_device *dev,
 		s->private	= gpct;
 	}
 
-	/* Frequency output */
+	/* Frequency output subdevice */
 	s = &dev->subdevices[NI_FREQ_OUT_SUBDEV];
-	s->type = COMEDI_SUBD_COUNTER;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-	s->n_chan = 1;
-	s->maxdata = 0xf;
-	s->insn_read = &ni_freq_out_insn_read;
-	s->insn_write = &ni_freq_out_insn_write;
-	s->insn_config = &ni_freq_out_insn_config;
+	s->type		= COMEDI_SUBD_COUNTER;
+	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
+	s->n_chan	= 1;
+	s->maxdata	= 0xf;
+	s->insn_read	= ni_freq_out_insn_read;
+	s->insn_write	= ni_freq_out_insn_write;
+	s->insn_config	= ni_freq_out_insn_config;
 
 	if (dev->irq) {
 		ni_stc_writew(dev,

commit c607b3317e562bfe322c98c38e0c9e7852366b35
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:24:04 2014 -0700

    staging: comedi: ni_mio_common: tidy up the gpct counter subdevice init
    
    For aesthetics, add some whitespace to the subdevice init and
    tidy it up a bit.
    
    Unfortunately we can't get rid of the '#ifdef PCIDMA' here yet due
    to other ifdefery in this file. For now just add the correct test
    so that the async command support is not hooked up unless we have
    an IRQ and DMA.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 4932b4db83ad..6545f11fe669 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5490,7 +5490,6 @@ static int ni_E_init(struct comedi_device *dev,
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
-	enum ni_gpct_variant counter_variant;
 	int ret;
 	int i;
 
@@ -5735,44 +5734,47 @@ static int ni_E_init(struct comedi_device *dev,
 	s->insn_config = ni_rtsi_insn_config;
 	ni_rtsi_init(dev);
 
-	if (devpriv->is_m_series)
-		counter_variant = ni_gpct_variant_m_series;
-	else
-		counter_variant = ni_gpct_variant_e_series;
+	/* allocate and initialize the gpct counter device */
 	devpriv->counter_dev = ni_gpct_device_construct(dev,
-							&ni_gpct_write_register,
-							&ni_gpct_read_register,
-							counter_variant,
-							NUM_GPCT);
+					ni_gpct_write_register,
+					ni_gpct_read_register,
+					(devpriv->is_m_series)
+						? ni_gpct_variant_m_series
+						: ni_gpct_variant_e_series,
+					NUM_GPCT);
 	if (!devpriv->counter_dev)
 		return -ENOMEM;
 
-	/* General purpose counters */
+	/* Counter (gpct) subdevices */
 	for (i = 0; i < NUM_GPCT; ++i) {
+		struct ni_gpct *gpct = &devpriv->counter_dev->counters[i];
+
+		/* setup and initialize the counter */
+		gpct->chip_index = 0;
+		gpct->counter_index = i;
+		ni_tio_init_counter(gpct);
+
 		s = &dev->subdevices[NI_GPCT_SUBDEV(i)];
-		s->type = COMEDI_SUBD_COUNTER;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
-		s->n_chan = 3;
-		if (devpriv->is_m_series)
-			s->maxdata = 0xffffffff;
-		else
-			s->maxdata = 0xffffff;
-		s->insn_read = ni_tio_insn_read;
-		s->insn_write = ni_tio_insn_read;
-		s->insn_config = ni_tio_insn_config;
+		s->type		= COMEDI_SUBD_COUNTER;
+		s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
+		s->n_chan	= 3;
+		s->maxdata	= (devpriv->is_m_series) ? 0xffffffff
+							 : 0x00ffffff;
+		s->insn_read	= ni_tio_insn_read;
+		s->insn_write	= ni_tio_insn_read;
+		s->insn_config	= ni_tio_insn_config;
 #ifdef PCIDMA
-		s->subdev_flags |= SDF_CMD_READ /* | SDF_CMD_WRITE */;
-		s->do_cmd = &ni_gpct_cmd;
-		s->len_chanlist = 1;
-		s->do_cmdtest = ni_tio_cmdtest;
-		s->cancel = &ni_gpct_cancel;
-		s->async_dma_dir = DMA_BIDIRECTIONAL;
-#endif
-		s->private = &devpriv->counter_dev->counters[i];
+		if (dev->irq && devpriv->mite) {
+			s->subdev_flags	|= SDF_CMD_READ /* | SDF_CMD_WRITE */;
+			s->len_chanlist	= 1;
+			s->do_cmdtest	= ni_tio_cmdtest;
+			s->do_cmd	= ni_gpct_cmd;
+			s->cancel	= ni_gpct_cancel;
 
-		devpriv->counter_dev->counters[i].chip_index = 0;
-		devpriv->counter_dev->counters[i].counter_index = i;
-		ni_tio_init_counter(&devpriv->counter_dev->counters[i]);
+			s->async_dma_dir = DMA_BIDIRECTIONAL;
+		}
+#endif
+		s->private	= gpct;
 	}
 
 	/* Frequency output */

commit 43f2c8b7defd4e54167773d6de0c23ad55de1686
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:24:03 2014 -0700

    staging: comedi: ni_mio_common: tidy up the PFI subdevice init
    
    For aesthetics, add some whitespace to the subdevice init and
    tidy it up a bit.
    
    Remove the need for the extra local variable.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8f7edcdc1f1d..4932b4db83ad 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5490,9 +5490,9 @@ static int ni_E_init(struct comedi_device *dev,
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
-	unsigned j;
 	enum ni_gpct_variant counter_variant;
 	int ret;
+	int i;
 
 	if (board->n_aochan > MAX_N_AO_CHAN) {
 		printk("bug! n_aochan > MAX_N_AO_CHAN\n");
@@ -5678,25 +5678,25 @@ static int ni_E_init(struct comedi_device *dev,
 		s->insn_read	= ni_eeprom_insn_read;
 	}
 
-	/* PFI */
+	/* Digital I/O (PFI) subdevice */
 	s = &dev->subdevices[NI_PFI_DIO_SUBDEV];
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+	s->maxdata	= 1;
 	if (devpriv->is_m_series) {
-		unsigned i;
-		s->n_chan = 16;
+		s->n_chan	= 16;
+		s->insn_bits	= ni_pfi_insn_bits;
+
 		ni_writew(dev, s->state, M_Offset_PFI_DO);
 		for (i = 0; i < NUM_PFI_OUTPUT_SELECT_REGS; ++i) {
 			ni_writew(dev, devpriv->pfi_output_select_reg[i],
 				  M_Offset_PFI_Output_Select(i + 1));
 		}
 	} else {
-		s->n_chan = 10;
+		s->n_chan	= 10;
 	}
-	s->maxdata = 1;
-	if (devpriv->is_m_series)
-		s->insn_bits = &ni_pfi_insn_bits;
-	s->insn_config = &ni_pfi_insn_config;
+	s->insn_config	= ni_pfi_insn_config;
+
 	ni_set_bits(dev, IO_Bidirection_Pin_Register, ~0, 0);
 
 	/* cs5529 calibration adc */
@@ -5748,8 +5748,8 @@ static int ni_E_init(struct comedi_device *dev,
 		return -ENOMEM;
 
 	/* General purpose counters */
-	for (j = 0; j < NUM_GPCT; ++j) {
-		s = &dev->subdevices[NI_GPCT_SUBDEV(j)];
+	for (i = 0; i < NUM_GPCT; ++i) {
+		s = &dev->subdevices[NI_GPCT_SUBDEV(i)];
 		s->type = COMEDI_SUBD_COUNTER;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
 		s->n_chan = 3;
@@ -5768,11 +5768,11 @@ static int ni_E_init(struct comedi_device *dev,
 		s->cancel = &ni_gpct_cancel;
 		s->async_dma_dir = DMA_BIDIRECTIONAL;
 #endif
-		s->private = &devpriv->counter_dev->counters[j];
+		s->private = &devpriv->counter_dev->counters[i];
 
-		devpriv->counter_dev->counters[j].chip_index = 0;
-		devpriv->counter_dev->counters[j].counter_index = j;
-		ni_tio_init_counter(&devpriv->counter_dev->counters[j]);
+		devpriv->counter_dev->counters[i].chip_index = 0;
+		devpriv->counter_dev->counters[i].counter_index = i;
+		ni_tio_init_counter(&devpriv->counter_dev->counters[i]);
 	}
 
 	/* Frequency output */

commit 433c79f92edc52ec754a52acae65fcde4661c8d9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:24:02 2014 -0700

    staging: comedi: ni_mio_common: tidy up the EEPROM subdevice init
    
    For aesthetics, add some whitespace to the subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 49c22d61fb90..8f7edcdc1f1d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5665,17 +5665,17 @@ static int ni_E_init(struct comedi_device *dev,
 		caldac_setup(dev, s);
 	}
 
-	/* EEPROM */
+	/* EEPROM subdevice */
 	s = &dev->subdevices[NI_EEPROM_SUBDEV];
-	s->type = COMEDI_SUBD_MEMORY;
-	s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
-	s->maxdata = 0xff;
+	s->type		= COMEDI_SUBD_MEMORY;
+	s->subdev_flags	= SDF_READABLE | SDF_INTERNAL;
+	s->maxdata	= 0xff;
 	if (devpriv->is_m_series) {
-		s->n_chan = M_SERIES_EEPROM_SIZE;
-		s->insn_read = &ni_m_series_eeprom_insn_read;
+		s->n_chan	= M_SERIES_EEPROM_SIZE;
+		s->insn_read	= ni_m_series_eeprom_insn_read;
 	} else {
-		s->n_chan = 512;
-		s->insn_read = &ni_eeprom_insn_read;
+		s->n_chan	= 512;
+		s->insn_read	= ni_eeprom_insn_read;
 	}
 
 	/* PFI */

commit cb429506155b3c6c64ee7c06e3961b76fbffb173
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:24:01 2014 -0700

    staging: comedi: ni_mio_common: tidy up the calibration subdevice init
    
    For aesthetics, add some whitespace to the subdevice init.
    
    Refactor the code so that the common parts of the subdevice are initialized
    in one place.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e60b9e696233..49c22d61fb90 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5642,26 +5642,26 @@ static int ni_E_init(struct comedi_device *dev,
 	s = &dev->subdevices[NI_UNUSED_SUBDEV];
 	s->type = COMEDI_SUBD_UNUSED;
 
-	/* calibration subdevice -- ai and ao */
+	/* Calibration subdevice */
 	s = &dev->subdevices[NI_CALIBRATION_SUBDEV];
-	s->type = COMEDI_SUBD_CALIB;
+	s->type		= COMEDI_SUBD_CALIB;
+	s->subdev_flags	= SDF_INTERNAL;
+	s->n_chan	= 1;
+	s->maxdata	= 0;
 	if (devpriv->is_m_series) {
-		/*  internal PWM analog output used for AI nonlinearity calibration */
-		s->subdev_flags = SDF_INTERNAL;
-		s->insn_config = &ni_m_series_pwm_config;
-		s->n_chan = 1;
-		s->maxdata = 0;
+		/* internal PWM output used for AI nonlinearity calibration */
+		s->insn_config	= ni_m_series_pwm_config;
+
 		ni_writel(dev, 0x0, M_Offset_Cal_PWM);
 	} else if (devpriv->is_6143) {
-		/*  internal PWM analog output used for AI nonlinearity calibration */
-		s->subdev_flags = SDF_INTERNAL;
-		s->insn_config = &ni_6143_pwm_config;
-		s->n_chan = 1;
-		s->maxdata = 0;
+		/* internal PWM output used for AI nonlinearity calibration */
+		s->insn_config	= ni_6143_pwm_config;
 	} else {
-		s->subdev_flags = SDF_WRITABLE | SDF_INTERNAL;
-		s->insn_read = &ni_calib_insn_read;
-		s->insn_write = &ni_calib_insn_write;
+		s->subdev_flags	|= SDF_WRITABLE;
+		s->insn_read	= ni_calib_insn_read;
+		s->insn_write	= ni_calib_insn_write;
+
+		/* setup the caldacs and find the real n_chan and maxdata */
 		caldac_setup(dev, s);
 	}
 

commit eeca0caa84169dcff5e67da6dee74b785f12a4f4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:24:00 2014 -0700

    staging: comedi: ni_mio_common: only reset the ai/ao subdevices if they exist
    
    So of the boards supported by this driver do not have analog inputs and
    some don't have analog outputs. Move the calls that reset these subdevices
    during the (*attach) by ni_E_init() so they only happen if the subdevices
    are present.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 6d1754f98c2e..e60b9e696233 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5544,6 +5544,9 @@ static int ni_E_init(struct comedi_device *dev,
 			if (devpriv->mite)
 				s->async_dma_dir = DMA_FROM_DEVICE;
 		}
+
+		/* reset the analog input configuration */
+		ni_ai_reset(dev, s);
 	} else {
 		s->type		= COMEDI_SUBD_UNUSED;
 	}
@@ -5582,6 +5585,9 @@ static int ni_E_init(struct comedi_device *dev,
 
 		if (devpriv->is_67xx)
 			init_ao_67xx(dev, s);
+
+		/* reset the analog output configuration */
+		ni_ao_reset(dev, s);
 	} else {
 		s->type		= COMEDI_SUBD_UNUSED;
 	}
@@ -5779,14 +5785,6 @@ static int ni_E_init(struct comedi_device *dev,
 	s->insn_write = &ni_freq_out_insn_write;
 	s->insn_config = &ni_freq_out_insn_config;
 
-	/* ai configuration */
-	s = &dev->subdevices[NI_AI_SUBDEV];
-	ni_ai_reset(dev, s);
-
-	/* analog output configuration */
-	s = &dev->subdevices[NI_AO_SUBDEV];
-	ni_ao_reset(dev, s);
-
 	if (dev->irq) {
 		ni_stc_writew(dev,
 			      (irq_polarity ? Interrupt_Output_Polarity : 0) |

commit caedecfa3a0aea7dc588fd9bb8a0453e74d381c9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:59 2014 -0700

    staging: comedi: ni_mio_common: init clock dividers early in ni_E_init()
    
    The init/reset of the hardware is a bit scattered in this function. For
    aesthetics, move the init of the clock dividers so it happens early and
    tidy up the code a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index dc5f927d32ff..6d1754f98c2e 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5499,6 +5499,18 @@ static int ni_E_init(struct comedi_device *dev,
 		return -EINVAL;
 	}
 
+	/* initialize clock dividers */
+	devpriv->clock_and_fout = Slow_Internal_Time_Divide_By_2 |
+				  Slow_Internal_Timebase |
+				  Clock_To_Board_Divide_By_2 |
+				  Clock_To_Board;
+	if (!devpriv->is_6xxx) {
+		/* BEAM is this needed for PCI-6143 ?? */
+		devpriv->clock_and_fout |= (AI_Output_Divide_By_2 |
+					    AO_Output_Divide_By_2);
+	}
+	ni_stc_writew(dev, devpriv->clock_and_fout, Clock_and_FOUT_Register);
+
 	ret = comedi_alloc_subdevices(dev, NI_NUM_SUBDEVICES);
 	if (ret)
 		return ret;
@@ -5770,21 +5782,6 @@ static int ni_E_init(struct comedi_device *dev,
 	/* ai configuration */
 	s = &dev->subdevices[NI_AI_SUBDEV];
 	ni_ai_reset(dev, s);
-	if (!devpriv->is_6xxx) {
-		/*  BEAM is this needed for PCI-6143 ?? */
-		devpriv->clock_and_fout =
-		    Slow_Internal_Time_Divide_By_2 |
-		    Slow_Internal_Timebase |
-		    Clock_To_Board_Divide_By_2 |
-		    Clock_To_Board |
-		    AI_Output_Divide_By_2 | AO_Output_Divide_By_2;
-	} else {
-		devpriv->clock_and_fout =
-		    Slow_Internal_Time_Divide_By_2 |
-		    Slow_Internal_Timebase |
-		    Clock_To_Board_Divide_By_2 | Clock_To_Board;
-	}
-	ni_stc_writew(dev, devpriv->clock_and_fout, Clock_and_FOUT_Register);
 
 	/* analog output configuration */
 	s = &dev->subdevices[NI_AO_SUBDEV];

commit 2d4ecc38b9e5491c0a655ac549ee52c586955231
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:58 2014 -0700

    staging: comedi: ni_mio_common: tidy up the Digital I/O subdevice init
    
    For aesthetics, add some whitespace to the Digital I/O subdevice init.
    
    Only hook up the async command support if we have an irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7146f21a619c..dc5f927d32ff 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5574,32 +5574,37 @@ static int ni_E_init(struct comedi_device *dev,
 		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
-	/* digital i/o subdevice */
-
+	/* Digital I/O subdevice */
 	s = &dev->subdevices[NI_DIO_SUBDEV];
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->maxdata = 1;
-	s->io_bits = 0;		/* all bits input */
-	s->range_table = &range_digital;
-	s->n_chan = board->has_32dio_chan ? 32 : 8;
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE;
+	s->n_chan	= board->has_32dio_chan ? 32 : 8;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
 	if (devpriv->is_m_series) {
-		s->subdev_flags |=
-		    SDF_LSAMPL | SDF_CMD_WRITE /* | SDF_CMD_READ */;
-		s->insn_bits = &ni_m_series_dio_insn_bits;
-		s->insn_config = &ni_m_series_dio_insn_config;
-		s->do_cmd = &ni_cdio_cmd;
-		s->do_cmdtest = &ni_cdio_cmdtest;
-		s->cancel = &ni_cdio_cancel;
-		s->async_dma_dir = DMA_BIDIRECTIONAL;
-		s->len_chanlist = s->n_chan;
+		s->subdev_flags	|= SDF_LSAMPL;
+		s->insn_bits	= ni_m_series_dio_insn_bits;
+		s->insn_config	= ni_m_series_dio_insn_config;
+		if (dev->irq) {
+			s->subdev_flags	|= SDF_CMD_WRITE /* | SDF_CMD_READ */;
+			s->len_chanlist	= s->n_chan;
+			s->do_cmdtest	= ni_cdio_cmdtest;
+			s->do_cmd	= ni_cdio_cmd;
+			s->cancel	= ni_cdio_cancel;
+
+			/* M-series boards use DMA */
+			s->async_dma_dir = DMA_BIDIRECTIONAL;
+		}
 
+		/* reset DIO and set all channels to inputs */
 		ni_writel(dev, CDO_Reset_Bit | CDI_Reset_Bit,
 			  M_Offset_CDIO_Command);
 		ni_writel(dev, s->io_bits, M_Offset_DIO_Direction);
 	} else {
-		s->insn_bits = &ni_dio_insn_bits;
-		s->insn_config = &ni_dio_insn_config;
+		s->insn_bits	= ni_dio_insn_bits;
+		s->insn_config	= ni_dio_insn_config;
+
+		/* set all channels to inputs */
 		devpriv->dio_control = DIO_Pins_Dir(s->io_bits);
 		ni_writew(dev, devpriv->dio_control, DIO_Control_Register);
 	}

commit 0615c162f659fb96cbb97dfb2a0a315eecb7861f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:57 2014 -0700

    staging: comedi: ni_mio_common: refactor 'num_p0_dio_channels' boardinfo
    
    All of the board supported by this driver have at least 8 Digital I/O
    channels. A couple of the PCI boards in ni_pcimio have 32 channels.
    
    For aesthetics, change this member of the boardinfo into a bit-field
    flag, 'has_32dio_chan', and use that when initializing the DIO subdevice
    to set the number of channels to 32 or 8.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 91b3fb4d12c2..7146f21a619c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5582,7 +5582,7 @@ static int ni_E_init(struct comedi_device *dev,
 	s->maxdata = 1;
 	s->io_bits = 0;		/* all bits input */
 	s->range_table = &range_digital;
-	s->n_chan = board->num_p0_dio_channels;
+	s->n_chan = board->has_32dio_chan ? 32 : 8;
 	if (devpriv->is_m_series) {
 		s->subdev_flags |=
 		    SDF_LSAMPL | SDF_CMD_WRITE /* | SDF_CMD_READ */;

commit 80a94e405bf7bdc23f92a1d0f2ace85f6681b116
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:56 2014 -0700

    staging: comedi: ni_mio_common: tidy up the Analog Output subdevice init
    
    For aesthetics, add some whitespace to the Analog Output subdevice init.
    
    Also, remove the '#ifdef PCIDMA' here and only hook up the async command
    support if we have an irq and the board either has a fifo or DMA is
    supported.
    
    The ni_pcimio driver is the only place PCIDMA is defined. That driver
    is also the only user of ni_mio_common that allocates devpriv->mite. Use
    that test instead to determine if dma is supported.
    
    Move 'is_67xx' check and init_ao_67xx() call into the Analog Output
    subdevice init. The 67xx boards all have analog outputs and this check
    does not need to be done for the boards that do not have analog outputs.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 800f4e3af77b..91b3fb4d12c2 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5536,40 +5536,43 @@ static int ni_E_init(struct comedi_device *dev,
 		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
-	/* analog output subdevice */
-
+	/* Analog Output subdevice */
 	s = &dev->subdevices[NI_AO_SUBDEV];
 	if (board->n_aochan) {
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_WRITABLE | SDF_DEGLITCH | SDF_GROUND;
+		s->type		= COMEDI_SUBD_AO;
+		s->subdev_flags	= SDF_WRITABLE | SDF_DEGLITCH | SDF_GROUND;
 		if (devpriv->is_m_series)
-			s->subdev_flags |= SDF_SOFT_CALIBRATED;
-		s->n_chan = board->n_aochan;
-		s->maxdata = board->ao_maxdata;
-		s->range_table = board->ao_range_table;
-		s->insn_read = &ni_ao_insn_read;
-		s->insn_write = &ni_ao_insn_write;
-		s->insn_config = &ni_ao_insn_config;
-#ifdef PCIDMA
-		if (board->n_aochan) {
-			s->async_dma_dir = DMA_TO_DEVICE;
-#else
-		if (board->ao_fifo_depth) {
-#endif
+			s->subdev_flags	|= SDF_SOFT_CALIBRATED;
+		s->n_chan	= board->n_aochan;
+		s->maxdata	= board->ao_maxdata;
+		s->range_table	= board->ao_range_table;
+		s->insn_read	= ni_ao_insn_read;
+		s->insn_write	= ni_ao_insn_write;
+		s->insn_config	= ni_ao_insn_config;
+
+		/*
+		 * Along with the IRQ we need either a FIFO or DMA for
+		 * async command support.
+		 */
+		if (dev->irq && (board->ao_fifo_depth || devpriv->mite)) {
 			dev->write_subdev = s;
-			s->subdev_flags |= SDF_CMD_WRITE;
-			s->do_cmd = &ni_ao_cmd;
-			s->do_cmdtest = &ni_ao_cmdtest;
-			s->cancel = &ni_ao_reset;
-			s->len_chanlist = board->n_aochan;
+			s->subdev_flags	|= SDF_CMD_WRITE;
+			s->len_chanlist	= s->n_chan;
+			s->do_cmdtest	= ni_ao_cmdtest;
+			s->do_cmd	= ni_ao_cmd;
+			s->cancel	= ni_ao_reset;
 			if (!devpriv->is_m_series)
-				s->munge = ni_ao_munge;
+				s->munge	= ni_ao_munge;
+
+			if (devpriv->mite)
+				s->async_dma_dir = DMA_TO_DEVICE;
 		}
+
+		if (devpriv->is_67xx)
+			init_ao_67xx(dev, s);
 	} else {
-		s->type = COMEDI_SUBD_UNUSED;
+		s->type		= COMEDI_SUBD_UNUSED;
 	}
-	if (devpriv->is_67xx)
-		init_ao_67xx(dev, s);
 
 	/* digital i/o subdevice */
 

commit a06500b4adf2c8adb1ca1b44c77850d76f8c839b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:55 2014 -0700

    staging: comedi: ni_mio_common: tidy up the Analog Input subdevice init
    
    For aesthetics, add some whitespace to the Analog Input subdevice init.
    
    The callers of ni_E_init() do the request_irq() and set dev->irq if the
    interrupt is available. Only hook up the async command support if we
    have the irq.
    
    Also, remove the '#ifdef PCIDMA' here. The ni_pcimio driver is the only
    place PCIDMA is defined. That driver is also the only user of ni_mio_common
    that allocates devpriv->mite. Use that test instead to determine if the
    subdevice async_dma_dir member needs to be initialized.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2ab267b04a96..800f4e3af77b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5503,36 +5503,37 @@ static int ni_E_init(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	/* analog input subdevice */
-
+	/* Analog Input subdevice */
 	s = &dev->subdevices[NI_AI_SUBDEV];
-	dev->read_subdev = s;
 	if (board->n_adchan) {
-		s->type = COMEDI_SUBD_AI;
-		s->subdev_flags =
-		    SDF_READABLE | SDF_DIFF | SDF_DITHER | SDF_CMD_READ;
+		s->type		= COMEDI_SUBD_AI;
+		s->subdev_flags	= SDF_READABLE | SDF_DIFF | SDF_DITHER;
 		if (!devpriv->is_611x)
-			s->subdev_flags |= SDF_GROUND | SDF_COMMON | SDF_OTHER;
+			s->subdev_flags	|= SDF_GROUND | SDF_COMMON | SDF_OTHER;
 		if (board->ai_maxdata > 0xffff)
-			s->subdev_flags |= SDF_LSAMPL;
+			s->subdev_flags	|= SDF_LSAMPL;
 		if (devpriv->is_m_series)
-			s->subdev_flags |= SDF_SOFT_CALIBRATED;
-		s->n_chan = board->n_adchan;
-		s->len_chanlist = 512;
-		s->maxdata = board->ai_maxdata;
-		s->range_table = ni_range_lkup[board->gainlkup];
-		s->insn_read = &ni_ai_insn_read;
-		s->insn_config = &ni_ai_insn_config;
-		s->do_cmdtest = &ni_ai_cmdtest;
-		s->do_cmd = &ni_ai_cmd;
-		s->cancel = &ni_ai_reset;
-		s->poll = &ni_ai_poll;
-		s->munge = &ni_ai_munge;
-#ifdef PCIDMA
-		s->async_dma_dir = DMA_FROM_DEVICE;
-#endif
+			s->subdev_flags	|= SDF_SOFT_CALIBRATED;
+		s->n_chan	= board->n_adchan;
+		s->maxdata	= board->ai_maxdata;
+		s->range_table	= ni_range_lkup[board->gainlkup];
+		s->insn_read	= ni_ai_insn_read;
+		s->insn_config	= ni_ai_insn_config;
+		if (dev->irq) {
+			dev->read_subdev = s;
+			s->subdev_flags	|= SDF_CMD_READ;
+			s->len_chanlist	= 512;
+			s->do_cmdtest	= ni_ai_cmdtest;
+			s->do_cmd	= ni_ai_cmd;
+			s->cancel	= ni_ai_reset;
+			s->poll		= ni_ai_poll;
+			s->munge	= ni_ai_munge;
+
+			if (devpriv->mite)
+				s->async_dma_dir = DMA_FROM_DEVICE;
+		}
 	} else {
-		s->type = COMEDI_SUBD_UNUSED;
+		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
 	/* analog output subdevice */

commit daabc8a63154adef43df5eddadb8d0371a5cc06d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:54 2014 -0700

    staging: comedi: ni_mio_common: (*cancel) only works with async cmd support
    
    The comedi subdevice (*cancel) function can only be called by the core if the
    subdevice supports async commands. Move the initialization of this callback
    to it is only set if async commands are enabled.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8303d66220a0..2ab267b04a96 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5559,11 +5559,11 @@ static int ni_E_init(struct comedi_device *dev,
 			s->subdev_flags |= SDF_CMD_WRITE;
 			s->do_cmd = &ni_ao_cmd;
 			s->do_cmdtest = &ni_ao_cmdtest;
+			s->cancel = &ni_ao_reset;
 			s->len_chanlist = board->n_aochan;
 			if (!devpriv->is_m_series)
 				s->munge = ni_ao_munge;
 		}
-		s->cancel = &ni_ao_reset;
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}

commit c5f26499998476edf599b599cd88163305dee5b2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:53 2014 -0700

    staging: comedi: ni_stc.h: refactor 'aobits' boardinfo
    
    For aesthetics, change the 'aobits' in the boardinfo to 'ao_maxdata'
    to remove the need for the calculation of the subdevice 'maxdata'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 4c451b5b4a09..8303d66220a0 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5544,7 +5544,7 @@ static int ni_E_init(struct comedi_device *dev,
 		if (devpriv->is_m_series)
 			s->subdev_flags |= SDF_SOFT_CALIBRATED;
 		s->n_chan = board->n_aochan;
-		s->maxdata = (1 << board->aobits) - 1;
+		s->maxdata = board->ao_maxdata;
 		s->range_table = board->ao_range_table;
 		s->insn_read = &ni_ao_insn_read;
 		s->insn_write = &ni_ao_insn_write;

commit db2255f5a0394fc5bc295a4b3e96667c46a7b9ef
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:52 2014 -0700

    staging: comedi: ni_stc.h: refactor 'adbits' boardinfo
    
    For aesthetics, change the 'adbits' in the boardinfo to 'ai_maxdata'
    to remove the need for the calculation of the subdevice 'maxdata'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 05f51bc1f2df..4c451b5b4a09 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5513,13 +5513,13 @@ static int ni_E_init(struct comedi_device *dev,
 		    SDF_READABLE | SDF_DIFF | SDF_DITHER | SDF_CMD_READ;
 		if (!devpriv->is_611x)
 			s->subdev_flags |= SDF_GROUND | SDF_COMMON | SDF_OTHER;
-		if (board->adbits > 16)
+		if (board->ai_maxdata > 0xffff)
 			s->subdev_flags |= SDF_LSAMPL;
 		if (devpriv->is_m_series)
 			s->subdev_flags |= SDF_SOFT_CALIBRATED;
 		s->n_chan = board->n_adchan;
 		s->len_chanlist = 512;
-		s->maxdata = (1 << board->adbits) - 1;
+		s->maxdata = board->ai_maxdata;
 		s->range_table = ni_range_lkup[board->gainlkup];
 		s->insn_read = &ni_ai_insn_read;
 		s->insn_config = &ni_ai_insn_config;

commit 817144ae7fda855dc120b3497246b7eea17bb561
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:51 2014 -0700

    staging: comedi: ni_mio_common: remove unnecessary use of 'board->adbits'
    
    For aesthetics, use the subdevice 'maxdata' instead of the board 'adbits'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index f4125c059d08..05f51bc1f2df 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1899,13 +1899,11 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 	struct ni_private *devpriv = dev->private;
 	unsigned int chan, range, aref;
 	unsigned int i;
-	unsigned offset;
 	unsigned int dither;
 	unsigned range_code;
 
 	ni_stc_writew(dev, 1, Configuration_Memory_Clear);
 
-/* offset = 1 << (board->adbits - 1); */
 	if ((list[0] & CR_ALT_SOURCE)) {
 		unsigned bypass_bits;
 		chan = CR_CHAN(list[0]);
@@ -1929,7 +1927,6 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 	} else {
 		ni_writel(dev, 0, M_Offset_AI_Config_FIFO_Bypass);
 	}
-	offset = 0;
 	for (i = 0; i < n_chan; i++) {
 		unsigned config_bits = 0;
 		chan = CR_CHAN(list[i]);
@@ -1938,7 +1935,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 		dither = ((list[i] & CR_ALT_FILTER) != 0);
 
 		range_code = ni_gainlkup[board->gainlkup][range];
-		devpriv->ai_offset[i] = offset;
+		devpriv->ai_offset[i] = 0;
 		switch (aref) {
 		case AREF_DIFF:
 			config_bits |=
@@ -2000,14 +1997,15 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
  *       valid channels are 0-3
  */
 static void ni_load_channelgain_list(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
 				     unsigned int n_chan, unsigned int *list)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
+	unsigned int offset = (s->maxdata + 1) >> 1;
 	unsigned int chan, range, aref;
 	unsigned int i;
 	unsigned int hi, lo;
-	unsigned offset;
 	unsigned int dither;
 
 	if (devpriv->is_m_series) {
@@ -2053,7 +2051,6 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		}
 	}
 
-	offset = 1 << (board->adbits - 1);
 	for (i = 0; i < n_chan; i++) {
 		if (!devpriv->is_6143 && (list[i] & CR_ALT_SOURCE)) {
 			chan = devpriv->ai_calib_source;
@@ -2120,15 +2117,14 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			   struct comedi_insn *insn,
 			   unsigned int *data)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
+	unsigned int mask = (s->maxdata + 1) >> 1;
 	int i, n;
-	const unsigned int mask = (1 << board->adbits) - 1;
 	unsigned signbits;
 	unsigned short d;
 	unsigned long dl;
 
-	ni_load_channelgain_list(dev, 1, &insn->chanspec);
+	ni_load_channelgain_list(dev, s, 1, &insn->chanspec);
 
 	ni_clear_ai_fifo(dev);
 
@@ -2447,7 +2443,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	ni_clear_ai_fifo(dev);
 
-	ni_load_channelgain_list(dev, cmd->chanlist_len, cmd->chanlist);
+	ni_load_channelgain_list(dev, s, cmd->chanlist_len, cmd->chanlist);
 
 	/* start configuration */
 	ni_stc_writew(dev, AI_Configuration_Start, Joint_Reset_Register);

commit 47ef2541fefbff61d54b8bbb47ccc9cd736bb49e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:50 2014 -0700

    staging: comedi: ni_mio_common: fix ni_ao_insn_read()
    
    The comedi core expects (*insn_read) functions to return insn->n
    data smaples. Fix this function to work like the core expects.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 1718382a7e7c..f4125c059d08 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2939,14 +2939,18 @@ static int ni_ao_config_chanlist(struct comedi_device *dev,
 }
 
 static int ni_ao_insn_read(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   struct comedi_subdevice *s,
+			   struct comedi_insn *insn,
 			   unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int i;
 
-	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
+	for (i = 0; i < insn->n; i++)
+		data[i] = devpriv->ao[chan];
 
-	return 1;
+	return insn->n;
 }
 
 static int ni_ao_insn_write(struct comedi_device *dev,

commit 93fac790668ca6e0151b590385a48360cf521c31
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:49 2014 -0700

    staging: comedi: ni_mio_common: remove ai_continuous from private data
    
    This member of the private data can be determined by checking the
    cmd->stop_src. Do that instead and remove the member.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 9bcf8351129d..1718382a7e7c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1499,8 +1499,8 @@ static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			       unsigned ai_mite_status)
 {
-	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
 	/* 67xx boards don't have ai subdevice, but their gpct0 might generate an a interrupt */
 	if (s->type == COMEDI_SUBD_UNUSED)
@@ -1551,7 +1551,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			return;
 		}
 		if (status & AI_SC_TC_St) {
-			if (!devpriv->ai_continuous)
+			if (cmd->stop_src == TRIG_COUNT)
 				shutdown_ai_command(dev);
 		}
 	}
@@ -2513,7 +2513,6 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* load SC (Scan Count) */
 		ni_stc_writew(dev, AI_SC_Load, AI_Command_1_Register);
 
-		devpriv->ai_continuous = 0;
 		if (stop_count == 0) {
 			devpriv->ai_cmd2 |= AI_End_On_End_Of_Scan;
 			interrupt_a_enable |= AI_STOP_Interrupt_Enable;
@@ -2532,9 +2531,6 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		/* load SC (Scan Count) */
 		ni_stc_writew(dev, AI_SC_Load, AI_Command_1_Register);
-
-		devpriv->ai_continuous = 1;
-
 		break;
 	}
 

commit 79816da17302910f70a85b4d269aedb067688926
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:48 2014 -0700

    staging: comedi: ni_mio_common: merge analog output (*insn_write) functions
    
    Currently the PCI6xxx boards use a different (*insn_write) function
    for the analog output subdevice. Most of the code is identical to the
    (*insn_write) used by all the other board types.
    
    For aesthetics, merge the two (*insn_write) functions and handle the
    'is_6xxx' differences in the common code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 6e79bcf3ce87..9bcf8351129d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2964,10 +2964,15 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 	int reg;
 	int i;
 
-	if (devpriv->is_m_series)
+	if (devpriv->is_6xxx) {
+		ni_ao_win_outw(dev, 1 << chan, AO_Immediate_671x);
+
+		reg = DACx_Direct_Data_671x(chan);
+	} else if (devpriv->is_m_series) {
 		reg = M_Offset_DAC_Direct_Data(chan);
-	else
+	} else {
 		reg = (chan) ? DAC1_Direct_Data : DAC0_Direct_Data;
+	}
 
 	ni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);
 
@@ -2976,8 +2981,19 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 
 		devpriv->ao[chan] = val;
 
-		if (devpriv->is_m_series) {
-			/* M-series board always use offset binary values */
+		if (devpriv->is_6xxx) {
+			/*
+			 * 6xxx boards have bipolar outputs, munge the
+			 * unsigned comedi values to 2's complement
+			 */
+			val = comedi_offset_munge(s, val);
+
+			ni_ao_win_outw(dev, val, reg);
+		} else if (devpriv->is_m_series) {
+			/*
+			 * M-series boards use offset binary values for
+			 * bipolar and uinpolar outputs
+			 */
 			ni_writew(dev, val, reg);
 		} else {
 			/*
@@ -2994,36 +3010,6 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int ni_ao_insn_write_671x(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn,
-				 unsigned int *data)
-{
-	struct ni_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	int i;
-
-	ni_ao_win_outw(dev, 1 << chan, AO_Immediate_671x);
-
-	ni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);
-
-	for (i = 0; i < insn->n; i++) {
-		unsigned int val = data[i];
-
-		devpriv->ao[chan] = val;
-
-		/*
-		 * 671x boards have +/-10V outputs
-		 * munge the unsigned comedi values to 2's complement
-		 */
-		val = comedi_offset_munge(s, val);
-
-		ni_ao_win_outw(dev, val, DACx_Direct_Data_671x(chan));
-	}
-
-	return insn->n;
-}
-
 static int ni_ao_insn_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
@@ -5565,10 +5551,7 @@ static int ni_E_init(struct comedi_device *dev,
 		s->maxdata = (1 << board->aobits) - 1;
 		s->range_table = board->ao_range_table;
 		s->insn_read = &ni_ao_insn_read;
-		if (devpriv->is_6xxx)
-			s->insn_write = &ni_ao_insn_write_671x;
-		else
-			s->insn_write = &ni_ao_insn_write;
+		s->insn_write = &ni_ao_insn_write;
 		s->insn_config = &ni_ao_insn_config;
 #ifdef PCIDMA
 		if (board->n_aochan) {

commit 47277365195c9722534e1ff3d4c10d36a77858e4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:47 2014 -0700

    staging: comedi: ni_mio_common: remove some unnecessary boardinfo access
    
    Currently ni_m_series_ao_config_chanlist() gets the boardinfo pointer in
    order to get the number of analog output channels. Get this from the
    comedi_subdevice instead.
    
    The ni_old_ao_config_chanlist() function also gets the boardinfo pointer
    to get the analog output resolution, 'aobits', in order to calculate the
    value needed to convert samples from unsigned to two's complement for
    bipolar ranges. Use the comedi_subdevice 'maxdata' instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8854f18eaa16..6e79bcf3ce87 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2818,7 +2818,6 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 					  unsigned int chanspec[],
 					  unsigned int n_chans, int timed)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int range;
 	unsigned int chan;
@@ -2827,7 +2826,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 	int invert = 0;
 
 	if (timed) {
-		for (i = 0; i < board->n_aochan; ++i) {
+		for (i = 0; i < s->n_chan; ++i) {
 			devpriv->ao_conf[i] &= ~MSeries_AO_Update_Timed_Bit;
 			ni_writeb(dev, devpriv->ao_conf[i],
 				  M_Offset_AO_Config_Bank(i));
@@ -2893,7 +2892,6 @@ static int ni_old_ao_config_chanlist(struct comedi_device *dev,
 				     unsigned int chanspec[],
 				     unsigned int n_chans)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int range;
 	unsigned int chan;
@@ -2908,7 +2906,7 @@ static int ni_old_ao_config_chanlist(struct comedi_device *dev,
 
 		if (comedi_range_is_bipolar(s, range)) {
 			conf |= AO_Bipolar;
-			invert = (1 << (board->aobits - 1));
+			invert = (s->maxdata + 1) >> 1;
 		} else {
 			invert = 0;
 		}

commit ab15dce7e963c115cc063643cd6f50c55b606268
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:46 2014 -0700

    staging: comedi: ni_mio_common: remove INSN_CONFIG_ANALOG_TRIG support code
    
    None of the boardinfo that uses this code sets the 'has_analog_trig' flag so
    ni_ai_config_analog_trig() always returns -EINVAL.
    
    Also, the private data 'atrig_low', 'atrig_high', and 'atrig_mode' values
    that are set by ni_ai_config_analog_trig() are never used.
    
    Remove the incomplete INSN_CONFIG_ANALOG_TRIG support along with the unused
    boardinfo and private data members.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 13270b348f82..8854f18eaa16 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2732,106 +2732,6 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int ni_ai_config_analog_trig(struct comedi_device *dev,
-				    struct comedi_subdevice *s,
-				    struct comedi_insn *insn,
-				    unsigned int *data)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
-	unsigned int a, b, modebits;
-	int err = 0;
-
-	/* data[1] is flags
-	 * data[2] is analog line
-	 * data[3] is set level
-	 * data[4] is reset level */
-	if (!board->has_analog_trig)
-		return -EINVAL;
-	if ((data[1] & 0xffff0000) != COMEDI_EV_SCAN_BEGIN) {
-		data[1] &= (COMEDI_EV_SCAN_BEGIN | 0xffff);
-		err++;
-	}
-	if (data[2] >= board->n_adchan) {
-		data[2] = board->n_adchan - 1;
-		err++;
-	}
-	if (data[3] > 255) {	/* a */
-		data[3] = 255;
-		err++;
-	}
-	if (data[4] > 255) {	/* b */
-		data[4] = 255;
-		err++;
-	}
-	/*
-	 * 00 ignore
-	 * 01 set
-	 * 10 reset
-	 *
-	 * modes:
-	 *   1 level:                    +b-   +a-
-	 *     high mode                00 00 01 10
-	 *     low mode                 00 00 10 01
-	 *   2 level: (a<b)
-	 *     hysteresis low mode      10 00 00 01
-	 *     hysteresis high mode     01 00 00 10
-	 *     middle mode              10 01 01 10
-	 */
-
-	a = data[3];
-	b = data[4];
-	modebits = data[1] & 0xff;
-	if (modebits & 0xf0) {
-		/* two level mode */
-		if (b < a) {
-			/* swap order */
-			a = data[4];
-			b = data[3];
-			modebits =
-			    ((data[1] & 0xf) << 4) | ((data[1] & 0xf0) >> 4);
-		}
-		devpriv->atrig_low = a;
-		devpriv->atrig_high = b;
-		switch (modebits) {
-		case 0x81:	/* low hysteresis mode */
-			devpriv->atrig_mode = 6;
-			break;
-		case 0x42:	/* high hysteresis mode */
-			devpriv->atrig_mode = 3;
-			break;
-		case 0x96:	/* middle window mode */
-			devpriv->atrig_mode = 2;
-			break;
-		default:
-			data[1] &= ~0xff;
-			err++;
-		}
-	} else {
-		/* one level mode */
-		if (b != 0) {
-			data[4] = 0;
-			err++;
-		}
-		switch (modebits) {
-		case 0x06:	/* high window mode */
-			devpriv->atrig_high = a;
-			devpriv->atrig_mode = 0;
-			break;
-		case 0x09:	/* low window mode */
-			devpriv->atrig_low = a;
-			devpriv->atrig_mode = 1;
-			break;
-		default:
-			data[1] &= ~0xff;
-			err++;
-		}
-	}
-	if (err)
-		return -EAGAIN;
-	return 5;
-}
-
 static int ni_ai_insn_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
@@ -2842,8 +2742,6 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 		return -EINVAL;
 
 	switch (data[0]) {
-	case INSN_CONFIG_ANALOG_TRIG:
-		return ni_ai_config_analog_trig(dev, s, insn, data);
 	case INSN_CONFIG_ALT_SOURCE:
 		if (devpriv->is_m_series) {
 			if (data[1] & ~(MSeries_AI_Bypass_Cal_Sel_Pos_Mask |

commit a10817d67f34546401f6733badd427c9decf88e8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:45 2014 -0700

    staging: comedi: ni_mio_common: tidy up ni_ao_munge()
    
    Use the bytes_per_sample() helper instead of 'sizeof(short)' to clarify
    the length calculation.
    
    Use comedi_offset_munge() to handle the unsigned to two's complement
    munge of the data for bipolar ranges.
    
    Tidy up the local variables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b5b4a7b7db20..13270b348f82 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2886,28 +2886,30 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 	return -EINVAL;
 }
 
-/* munge data from unsigned to 2's complement for analog output bipolar modes */
 static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 			void *data, unsigned int num_bytes,
 			unsigned int chan_index)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
-	unsigned int length = num_bytes / sizeof(short);
-	unsigned int offset = 1 << (board->aobits - 1);
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int length = num_bytes / bytes_per_sample(s);
 	unsigned short *array = data;
-	unsigned int range;
 	unsigned int i;
 
 	for (i = 0; i < length; i++) {
-		range = CR_RANGE(cmd->chanlist[chan_index]);
+		unsigned int range = CR_RANGE(cmd->chanlist[chan_index]);
+		unsigned short val = array[i];
 
+		/*
+		 * Munge data from unsigned to two's complement for
+		 * bipolar ranges.
+		 */
 		if (comedi_range_is_bipolar(s, range))
-			array[i] -= offset;
+			val = comedi_offset_munge(s, val);
 #ifdef PCIDMA
-		array[i] = cpu_to_le16(array[i]);
+		val = cpu_to_le16(val);
 #endif
+		array[i] = val;
+
 		chan_index++;
 		chan_index %= cmd->chanlist_len;
 	}

commit a52b53e4a743988667e5db7cd0de1cdb0732b4f9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:44 2014 -0700

    staging: comedi: ni_stc.h: add some 'is_{board type}' flags to private data
    
    The board->reg_type if checked quite often in the ni_mio_common.c code to
    handle differences in the PCI devices supported by the ni_pcimio driver.
    Simplify the code a bit by adding some 'is_{board type}' bit-field flags
    to the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c08b9b63a770..b5b4a7b7db20 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -958,11 +958,11 @@ static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 
 static void ni_clear_ai_fifo(struct comedi_device *dev)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
 	static const int timeout = 10000;
 	int i;
 
-	if (board->reg_type == ni_reg_6143) {
+	if (devpriv->is_6143) {
 		/*  Flush the 6143 data FIFO */
 		ni_writel(dev, 0x10, AIFIFO_Control_6143);
 		ni_writel(dev, 0x00, AIFIFO_Control_6143);
@@ -977,7 +977,7 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 		}
 	} else {
 		ni_stc_writew(dev, 1, ADC_FIFO_Clear);
-		if (board->reg_type == ni_reg_625x) {
+		if (devpriv->is_625x) {
 			ni_writeb(dev, 0, M_Offset_Static_AI_Control(0));
 			ni_writeb(dev, 1, M_Offset_Static_AI_Control(0));
 #if 0
@@ -1140,7 +1140,7 @@ static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 static void ni_ao_fifo_load(struct comedi_device *dev,
 			    struct comedi_subdevice *s, int n)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	int chan;
@@ -1158,10 +1158,10 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 
 		range = CR_RANGE(cmd->chanlist[chan]);
 
-		if (board->reg_type & ni_reg_6xxx_mask) {
+		if (devpriv->is_6xxx) {
 			packed_data = d & 0xffff;
 			/* 6711 only has 16 bit wide ao fifo */
-			if (board->reg_type != ni_reg_6711) {
+			if (!devpriv->is_6711) {
 				err &= comedi_buf_get(s, &d);
 				if (err == 0)
 					break;
@@ -1224,11 +1224,12 @@ static int ni_ao_prep_fifo(struct comedi_device *dev,
 			   struct comedi_subdevice *s)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
 	int n;
 
 	/* reset fifo */
 	ni_stc_writew(dev, 1, DAC_FIFO_Clear);
-	if (board->reg_type & ni_reg_6xxx_mask)
+	if (devpriv->is_6xxx)
 		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
 
 	/* load some data */
@@ -1248,12 +1249,11 @@ static int ni_ao_prep_fifo(struct comedi_device *dev,
 static void ni_ai_fifo_read(struct comedi_device *dev,
 			    struct comedi_subdevice *s, int n)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	int i;
 
-	if (board->reg_type == ni_reg_611x) {
+	if (devpriv->is_611x) {
 		unsigned short data[2];
 		u32 dl;
 
@@ -1270,7 +1270,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 			data[0] = dl & 0xffff;
 			cfc_write_to_buffer(s, data[0]);
 		}
-	} else if (board->reg_type == ni_reg_6143) {
+	} else if (devpriv->is_6143) {
 		unsigned short data[2];
 		u32 dl;
 
@@ -1324,7 +1324,6 @@ static void ni_handle_fifo_half_full(struct comedi_device *dev)
 */
 static void ni_handle_fifo_dregs(struct comedi_device *dev)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned short data[2];
@@ -1332,7 +1331,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 	unsigned short fifo_empty;
 	int i;
 
-	if (board->reg_type == ni_reg_611x) {
+	if (devpriv->is_611x) {
 		while ((ni_stc_readw(dev, AI_Status_1_Register) &
 			AI_FIFO_Empty_St) == 0) {
 			dl = ni_readl(dev, ADC_FIFO_Data_611x);
@@ -1342,7 +1341,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 			data[1] = (dl & 0xffff);
 			cfc_write_array_to_buffer(s, data, sizeof(data));
 		}
-	} else if (board->reg_type == ni_reg_6143) {
+	} else if (devpriv->is_6143) {
 		i = 0;
 		while (ni_readl(dev, AIFIFO_Status_6143) & 0x04) {
 			dl = ni_readl(dev, AIFIFO_Data_6143);
@@ -1388,12 +1387,12 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 
 static void get_last_sample_611x(struct comedi_device *dev)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned short data;
 	u32 dl;
 
-	if (board->reg_type != ni_reg_611x)
+	if (!devpriv->is_611x)
 		return;
 
 	/* Check if there's a single sample stuck in the FIFO */
@@ -1406,12 +1405,12 @@ static void get_last_sample_611x(struct comedi_device *dev)
 
 static void get_last_sample_6143(struct comedi_device *dev)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned short data;
 	u32 dl;
 
-	if (board->reg_type != ni_reg_6143)
+	if (!devpriv->is_6143)
 		return;
 
 	/* Check if there's a single sample stuck in the FIFO */
@@ -1685,7 +1684,6 @@ static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	int retval;
@@ -1705,18 +1703,13 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 		return -EIO;
 	}
 
-	switch (board->reg_type) {
-	case ni_reg_611x:
-	case ni_reg_6143:
+	if (devpriv->is_611x || devpriv->is_6143)
 		mite_prep_dma(devpriv->ai_mite_chan, 32, 16);
-		break;
-	case ni_reg_628x:
+	else if (devpriv->is_628x)
 		mite_prep_dma(devpriv->ai_mite_chan, 32, 32);
-		break;
-	default:
+	else
 		mite_prep_dma(devpriv->ai_mite_chan, 16, 16);
-		break;
-	}
+
 	/*start the MITE */
 	mite_dma_arm(devpriv->ai_mite_chan);
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
@@ -1726,7 +1719,6 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 
 static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->write_subdev;
 	int retval;
@@ -1741,7 +1733,7 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ao_mite_chan) {
-		if (board->reg_type & (ni_reg_611x | ni_reg_6713)) {
+		if (devpriv->is_611x || devpriv->is_6713) {
 			mite_prep_dma(devpriv->ao_mite_chan, 32, 32);
 		} else {
 			/* doing 32 instead of 16 bit wide transfers from memory
@@ -1766,7 +1758,7 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 
 static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
 
 	ni_release_ai_mite_channel(dev);
 	/* ai configuration */
@@ -1781,7 +1773,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	ni_clear_ai_fifo(dev);
 
-	if (board->reg_type != ni_reg_6143)
+	if (!devpriv->is_6143)
 		ni_writeb(dev, 0, Misc_Command);
 
 	ni_stc_writew(dev, AI_Disarm, AI_Command_1_Register); /* reset pulses */
@@ -1791,7 +1783,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_stc_writew(dev, 0x0000, AI_Mode_2_Register);
 	/* generate FIFO interrupts on non-empty */
 	ni_stc_writew(dev, (0 << 6) | 0x0000, AI_Mode_3_Register);
-	if (board->reg_type == ni_reg_611x) {
+	if (devpriv->is_611x) {
 		ni_stc_writew(dev,
 			      AI_SHIFTIN_Pulse_Width |
 			      AI_SOC_Polarity |
@@ -1805,7 +1797,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 			      AI_CONVERT_Output_Select
 			      (AI_CONVERT_Output_Enable_High),
 			      AI_Output_Control_Register);
-	} else if (board->reg_type == ni_reg_6143) {
+	} else if (devpriv->is_6143) {
 		ni_stc_writew(dev, AI_SHIFTIN_Pulse_Width |
 				   AI_SOC_Polarity |
 				   AI_LOCALMUX_CLK_Pulse_Width,
@@ -1831,7 +1823,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 		    AI_EXTMUX_CLK_Output_Select(0) |
 		    AI_LOCALMUX_CLK_Output_Select(2) |
 		    AI_SC_TC_Output_Select(3);
-		if (board->reg_type == ni_reg_622x)
+		if (devpriv->is_622x)
 			ai_output_control_bits |=
 			    AI_CONVERT_Output_Select
 			    (AI_CONVERT_Output_Enable_High);
@@ -2022,8 +2014,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		ni_m_series_load_channelgain_list(dev, n_chan, list);
 		return;
 	}
-	if (n_chan == 1 && (board->reg_type != ni_reg_611x)
-	    && (board->reg_type != ni_reg_6143)) {
+	if (n_chan == 1 && !devpriv->is_611x && !devpriv->is_6143) {
 		if (devpriv->changain_state
 		    && devpriv->changain_spec == list[0]) {
 			/*  ready to go. */
@@ -2038,7 +2029,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 	ni_stc_writew(dev, 1, Configuration_Memory_Clear);
 
 	/*  Set up Calibration mode if required */
-	if (board->reg_type == ni_reg_6143) {
+	if (devpriv->is_6143) {
 		if ((list[0] & CR_ALT_SOURCE)
 		    && !devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay enable bit */
@@ -2064,8 +2055,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 
 	offset = 1 << (board->adbits - 1);
 	for (i = 0; i < n_chan; i++) {
-		if ((board->reg_type != ni_reg_6143)
-		    && (list[i] & CR_ALT_SOURCE)) {
+		if (!devpriv->is_6143 && (list[i] & CR_ALT_SOURCE)) {
 			chan = devpriv->ai_calib_source;
 		} else {
 			chan = CR_CHAN(list[i]);
@@ -2076,20 +2066,20 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 
 		/* fix the external/internal range differences */
 		range = ni_gainlkup[board->gainlkup][range];
-		if (board->reg_type == ni_reg_611x)
+		if (devpriv->is_611x)
 			devpriv->ai_offset[i] = offset;
 		else
 			devpriv->ai_offset[i] = (range & 0x100) ? 0 : offset;
 
 		hi = 0;
 		if ((list[i] & CR_ALT_SOURCE)) {
-			if (board->reg_type == ni_reg_611x)
+			if (devpriv->is_611x)
 				ni_writew(dev, CR_CHAN(list[i]) & 0x0003,
 					  Calibration_Channel_Select_611x);
 		} else {
-			if (board->reg_type == ni_reg_611x)
+			if (devpriv->is_611x)
 				aref = AREF_DIFF;
-			else if (board->reg_type == ni_reg_6143)
+			else if (devpriv->is_6143)
 				aref = AREF_OTHER;
 			switch (aref) {
 			case AREF_DIFF:
@@ -2109,7 +2099,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 
 		ni_writew(dev, hi, Configuration_Memory_High);
 
-		if (board->reg_type != ni_reg_6143) {
+		if (!devpriv->is_6143) {
 			lo = range;
 			if (i == n_chan - 1)
 				lo |= AI_LAST_CHANNEL;
@@ -2121,10 +2111,8 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 	}
 
 	/* prime the channel/gain list */
-	if ((board->reg_type != ni_reg_611x)
-	    && (board->reg_type != ni_reg_6143)) {
+	if (!devpriv->is_611x && !devpriv->is_6143)
 		ni_prime_channelgain_list(dev);
-	}
 }
 
 static int ni_ai_insn_read(struct comedi_device *dev,
@@ -2145,7 +2133,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 	ni_clear_ai_fifo(dev);
 
 	signbits = devpriv->ai_offset[0];
-	if (board->reg_type == ni_reg_611x) {
+	if (devpriv->is_611x) {
 		for (n = 0; n < num_adc_stages_611x; n++) {
 			ni_stc_writew(dev, AI_CONVERT_Pulse,
 				      AI_Command_1_Register);
@@ -2178,7 +2166,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			d += signbits;
 			data[n] = d;
 		}
-	} else if (board->reg_type == ni_reg_6143) {
+	} else if (devpriv->is_6143) {
 		for (n = 0; n < insn->n; n++) {
 			ni_stc_writew(dev, AI_CONVERT_Pulse,
 				      AI_Command_1_Register);
@@ -2261,17 +2249,13 @@ static unsigned ni_min_ai_scan_period_ns(struct comedi_device *dev,
 					 unsigned num_channels)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
 
-	switch (board->reg_type) {
-	case ni_reg_611x:
-	case ni_reg_6143:
-		/*  simultaneously-sampled inputs */
+	/* simultaneously-sampled inputs */
+	if (devpriv->is_611x || devpriv->is_6143)
 		return board->ai_speed;
-		break;
-	default:
-		/*  multiplexed inputs */
-		break;
-	}
+
+	/* multiplexed inputs */
 	return board->ai_speed * num_channels;
 }
 
@@ -2295,8 +2279,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 					TRIG_TIMER | TRIG_EXT);
 
 	sources = TRIG_TIMER | TRIG_EXT;
-	if (board->reg_type == ni_reg_611x ||
-	    board->reg_type == ni_reg_6143)
+	if (devpriv->is_611x || devpriv->is_6143)
 		sources |= TRIG_NOW;
 	err |= cfc_check_trigger_src(&cmd->convert_src, sources);
 
@@ -2353,8 +2336,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	}
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		if ((board->reg_type == ni_reg_611x)
-		    || (board->reg_type == ni_reg_6143)) {
+		if (devpriv->is_611x || devpriv->is_6143) {
 			err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 		} else {
 			err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
@@ -2379,7 +2361,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->stop_src == TRIG_COUNT) {
 		unsigned int max_count = 0x01000000;
 
-		if (board->reg_type == ni_reg_611x)
+		if (devpriv->is_611x)
 			max_count -= num_adc_stages_611x;
 		err |= cfc_check_trigger_arg_max(&cmd->stop_arg, max_count);
 		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
@@ -2405,8 +2387,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
-		if ((board->reg_type != ni_reg_611x)
-		    && (board->reg_type != ni_reg_6143)) {
+		if (!devpriv->is_611x && !devpriv->is_6143) {
 			tmp = cmd->convert_arg;
 			cmd->convert_arg =
 			    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
@@ -2451,7 +2432,6 @@ static int ni_ai_inttrig(struct comedi_device *dev,
 
 static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	const struct comedi_cmd *cmd = &s->async->cmd;
 	int timer;
@@ -2507,8 +2487,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	mode2 &= ~AI_SC_Reload_Mode;
 	ni_stc_writew(dev, mode2, AI_Mode_2_Register);
 
-	if (cmd->chanlist_len == 1 || (board->reg_type == ni_reg_611x)
-	    || (board->reg_type == ni_reg_6143)) {
+	if (cmd->chanlist_len == 1 || devpriv->is_611x || devpriv->is_6143) {
 		start_stop_select |= AI_STOP_Polarity;
 		start_stop_select |= AI_STOP_Select(31);	/*  logic low */
 		start_stop_select |= AI_STOP_Sync;
@@ -2522,7 +2501,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	case TRIG_COUNT:
 		stop_count = cmd->stop_arg - 1;
 
-		if (board->reg_type == ni_reg_611x) {
+		if (devpriv->is_611x) {
 			/*  have to take 3 stage adc pipeline into account */
 			stop_count += num_adc_stages_611x;
 		}
@@ -2857,7 +2836,6 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
 	if (insn->n < 1)
@@ -2875,7 +2853,7 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 				return -EINVAL;
 			}
 			devpriv->ai_calib_source = data[1];
-		} else if (board->reg_type == ni_reg_6143) {
+		} else if (devpriv->is_6143) {
 			unsigned int calib_source;
 
 			calib_source = data[1] & 0xf;
@@ -2895,7 +2873,7 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 			if (calib_source >= 8)
 				return -EINVAL;
 			devpriv->ai_calib_source = calib_source;
-			if (board->reg_type == ni_reg_611x) {
+			if (devpriv->is_611x) {
 				ni_writeb(dev, calib_source_adjust,
 					  Cal_Gain_Select_611x);
 			}
@@ -3182,7 +3160,6 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 			 struct comedi_subdevice *s,
 			 unsigned int trig_num)
 {
-	const struct ni_board_struct *board __maybe_unused = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int ret;
@@ -3203,7 +3180,7 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 	interrupt_b_bits = AO_Error_Interrupt_Enable;
 #ifdef PCIDMA
 	ni_stc_writew(dev, 1, DAC_FIFO_Clear);
-	if (board->reg_type & ni_reg_6xxx_mask)
+	if (devpriv->is_6xxx)
 		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
 	ret = ni_ao_setup_MITE_dma(dev);
 	if (ret)
@@ -3271,7 +3248,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	ni_stc_writew(dev, AO_Disarm, AO_Command_1_Register);
 
-	if (board->reg_type & ni_reg_6xxx_mask) {
+	if (devpriv->is_6xxx) {
 		ni_ao_win_outw(dev, CLEAR_WG, AO_Misc_611x);
 
 		bits = 0;
@@ -3397,8 +3374,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		unsigned bits;
 		devpriv->ao_mode1 &= ~AO_Multiple_Channels;
 		bits = AO_UPDATE_Output_Select(AO_Update_Output_High_Z);
-		if (devpriv->is_m_series ||
-		    board->reg_type & ni_reg_6xxx_mask) {
+		if (devpriv->is_m_series || devpriv->is_6xxx) {
 			bits |= AO_Number_Of_Channels(0);
 		} else {
 			bits |=
@@ -3541,7 +3517,6 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
 	ni_release_ao_mite_channel(dev);
@@ -3571,7 +3546,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ao_trigger_select = 0;
 	ni_stc_writew(dev, devpriv->ao_trigger_select,
 		      AO_Trigger_Select_Register);
-	if (board->reg_type & ni_reg_6xxx_mask) {
+	if (devpriv->is_6xxx) {
 		unsigned immediate_bits = 0;
 		unsigned i;
 		for (i = 0; i < s->n_chan; ++i)
@@ -5656,7 +5631,7 @@ static int ni_E_init(struct comedi_device *dev,
 		s->type = COMEDI_SUBD_AI;
 		s->subdev_flags =
 		    SDF_READABLE | SDF_DIFF | SDF_DITHER | SDF_CMD_READ;
-		if (board->reg_type != ni_reg_611x)
+		if (!devpriv->is_611x)
 			s->subdev_flags |= SDF_GROUND | SDF_COMMON | SDF_OTHER;
 		if (board->adbits > 16)
 			s->subdev_flags |= SDF_LSAMPL;
@@ -5692,7 +5667,7 @@ static int ni_E_init(struct comedi_device *dev,
 		s->maxdata = (1 << board->aobits) - 1;
 		s->range_table = board->ao_range_table;
 		s->insn_read = &ni_ao_insn_read;
-		if (board->reg_type & ni_reg_6xxx_mask)
+		if (devpriv->is_6xxx)
 			s->insn_write = &ni_ao_insn_write_671x;
 		else
 			s->insn_write = &ni_ao_insn_write;
@@ -5715,7 +5690,7 @@ static int ni_E_init(struct comedi_device *dev,
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}
-	if ((board->reg_type & ni_reg_67xx_mask))
+	if (devpriv->is_67xx)
 		init_ao_67xx(dev, s);
 
 	/* digital i/o subdevice */
@@ -5773,7 +5748,7 @@ static int ni_E_init(struct comedi_device *dev,
 		s->n_chan = 1;
 		s->maxdata = 0;
 		ni_writel(dev, 0x0, M_Offset_Cal_PWM);
-	} else if (board->reg_type == ni_reg_6143) {
+	} else if (devpriv->is_6143) {
 		/*  internal PWM analog output used for AI nonlinearity calibration */
 		s->subdev_flags = SDF_INTERNAL;
 		s->insn_config = &ni_6143_pwm_config;
@@ -5822,7 +5797,7 @@ static int ni_E_init(struct comedi_device *dev,
 
 	/* cs5529 calibration adc */
 	s = &dev->subdevices[NI_CS5529_CALIBRATION_SUBDEV];
-	if (board->reg_type & ni_reg_67xx_mask) {
+	if (devpriv->is_67xx) {
 		s->type = COMEDI_SUBD_AI;
 		s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_INTERNAL;
 		/*  one channel for each analog output channel */
@@ -5909,7 +5884,7 @@ static int ni_E_init(struct comedi_device *dev,
 	/* ai configuration */
 	s = &dev->subdevices[NI_AI_SUBDEV];
 	ni_ai_reset(dev, s);
-	if ((board->reg_type & ni_reg_6xxx_mask) == 0) {
+	if (!devpriv->is_6xxx) {
 		/*  BEAM is this needed for PCI-6143 ?? */
 		devpriv->clock_and_fout =
 		    Slow_Internal_Time_Divide_By_2 |
@@ -5943,7 +5918,7 @@ static int ni_E_init(struct comedi_device *dev,
 	ni_writeb(dev, devpriv->ai_ao_select_reg, AI_AO_Select);
 	ni_writeb(dev, devpriv->g0_g1_select_reg, G0_G1_Select);
 
-	if (board->reg_type & ni_reg_6xxx_mask) {
+	if (devpriv->is_6xxx) {
 		ni_writeb(dev, 0, Magic_611x);
 	} else if (devpriv->is_m_series) {
 		int channel;

commit bfb0c28ba03a46740c80848ba7b93fafb91de033
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:43 2014 -0700

    staging: comedi: ni_mio_common: fix ni_ao_insn_write()
    
    Comedi (*insn_write) functions are expected to write insn->n values
    to the hardware. Fix this function to work like the core expects.
    
    Also, don't rely on the return value of ni_ao_comfig_chanlist() to
    determine if the values need converted to two's complement before
    writing to the hardware. Use the comedi_range_is_bipolar() and
    comedi_offset_munge() helpers to clarify the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d937eb87cf40..c08b9b63a770 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3079,23 +3079,43 @@ static int ni_ao_insn_read(struct comedi_device *dev,
 
 static int ni_ao_insn_write(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+			    struct comedi_insn *insn,
+			    unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int invert;
+	unsigned int range = CR_RANGE(insn->chanspec);
+	int reg;
+	int i;
 
-	invert = ni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);
+	if (devpriv->is_m_series)
+		reg = M_Offset_DAC_Direct_Data(chan);
+	else
+		reg = (chan) ? DAC1_Direct_Data : DAC0_Direct_Data;
 
-	devpriv->ao[chan] = data[0];
+	ni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);
 
-	if (devpriv->is_m_series) {
-		ni_writew(dev, data[0], M_Offset_DAC_Direct_Data(chan));
-	} else
-		ni_writew(dev, data[0] ^ invert,
-			  (chan) ? DAC1_Direct_Data : DAC0_Direct_Data);
+	for (i = 0; i < insn->n; i++) {
+		unsigned int val = data[i];
 
-	return 1;
+		devpriv->ao[chan] = val;
+
+		if (devpriv->is_m_series) {
+			/* M-series board always use offset binary values */
+			ni_writew(dev, val, reg);
+		} else {
+			/*
+			 * Non-M series boards need two's complement values
+			 * for bipolar ranges.
+			 */
+			if (comedi_range_is_bipolar(s, range))
+				val = comedi_offset_munge(s, val);
+
+			ni_writew(dev, val, reg);
+		}
+	}
+
+	return insn->n;
 }
 
 static int ni_ao_insn_write_671x(struct comedi_device *dev,

commit 87b4fe5c877b178949c71e017e4a129e29aae37e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:42 2014 -0700

    staging: comedi: ni_mio_common: remove ao_win_out() macro
    
    This marco relies on a local variable having a specific name. Remove the
    macro and just use ni_ao_win_outw() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b52dd2fdf88d..d937eb87cf40 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -994,7 +994,6 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 	}
 }
 
-#define ao_win_out(data, addr) ni_ao_win_outw(dev, data, addr)
 static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data,
 				  int addr)
 {
@@ -3108,7 +3107,7 @@ static int ni_ao_insn_write_671x(struct comedi_device *dev,
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	int i;
 
-	ao_win_out(1 << chan, AO_Immediate_671x);
+	ni_ao_win_outw(dev, 1 << chan, AO_Immediate_671x);
 
 	ni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);
 
@@ -3123,7 +3122,7 @@ static int ni_ao_insn_write_671x(struct comedi_device *dev,
 		 */
 		val = comedi_offset_munge(s, val);
 
-		ao_win_out(val, DACx_Direct_Data_671x(chan));
+		ni_ao_win_outw(dev, val, DACx_Direct_Data_671x(chan));
 	}
 
 	return insn->n;
@@ -3253,7 +3252,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_stc_writew(dev, AO_Disarm, AO_Command_1_Register);
 
 	if (board->reg_type & ni_reg_6xxx_mask) {
-		ao_win_out(CLEAR_WG, AO_Misc_611x);
+		ni_ao_win_outw(dev, CLEAR_WG, AO_Misc_611x);
 
 		bits = 0;
 		for (i = 0; i < cmd->chanlist_len; i++) {
@@ -3261,9 +3260,9 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 			chan = CR_CHAN(cmd->chanlist[i]);
 			bits |= 1 << chan;
-			ao_win_out(chan, AO_Waveform_Generation_611x);
+			ni_ao_win_outw(dev, chan, AO_Waveform_Generation_611x);
 		}
-		ao_win_out(bits, AO_Timed_611x);
+		ni_ao_win_outw(dev, bits, AO_Timed_611x);
 	}
 
 	ni_ao_config_chanlist(dev, s, cmd->chanlist, cmd->chanlist_len, 1);
@@ -3557,8 +3556,8 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 		unsigned i;
 		for (i = 0; i < s->n_chan; ++i)
 			immediate_bits |= 1 << i;
-		ao_win_out(immediate_bits, AO_Immediate_671x);
-		ao_win_out(CLEAR_WG, AO_Misc_611x);
+		ni_ao_win_outw(dev, immediate_bits, AO_Immediate_671x);
+		ni_ao_win_outw(dev, CLEAR_WG, AO_Misc_611x);
 	}
 	ni_stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);
 
@@ -4051,7 +4050,7 @@ static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_ao_win_outw(dev, AO_Channel(i) | 0x0,
 			       AO_Configuration_2_67xx);
 	}
-	ao_win_out(0x0, AO_Later_Single_Point_Updates);
+	ni_ao_win_outw(dev, 0x0, AO_Later_Single_Point_Updates);
 }
 
 static unsigned ni_gpct_to_stc_register(enum ni_gpct_register reg)

commit 093b6968857eb47493b955989ae62bb857648117
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:41 2014 -0700

    staging: comedi: ni_mio_common: fix ni_ao_insn_write_671x()
    
    Comedi (*insn_write) functions are expected to write insn->n values to
    the hardware. Fix this function to work like the core expects.
    
    Also, use the comedi_offset_munge() helper to convert the comedi unsigned
    values into the two's complement values that the hardware needs.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 471d7af59e99..b52dd2fdf88d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3101,22 +3101,32 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 
 static int ni_ao_insn_write_671x(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn, unsigned int *data)
+				 struct comedi_insn *insn,
+				 unsigned int *data)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int invert;
+	int i;
 
 	ao_win_out(1 << chan, AO_Immediate_671x);
-	invert = 1 << (board->aobits - 1);
 
 	ni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);
 
-	devpriv->ao[chan] = data[0];
-	ao_win_out(data[0] ^ invert, DACx_Direct_Data_671x(chan));
+	for (i = 0; i < insn->n; i++) {
+		unsigned int val = data[i];
 
-	return 1;
+		devpriv->ao[chan] = val;
+
+		/*
+		 * 671x boards have +/-10V outputs
+		 * munge the unsigned comedi values to 2's complement
+		 */
+		val = comedi_offset_munge(s, val);
+
+		ao_win_out(val, DACx_Direct_Data_671x(chan));
+	}
+
+	return insn->n;
 }
 
 static int ni_ao_insn_config(struct comedi_device *dev,

commit fed3c23b5e3c56e358e751418d7310b9c8e926cc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 14 12:23:40 2014 -0700

    staging: comedi: ni_stc.h: remove 'ao_unipolar' flag from ni_board_struct
    
    This member of the boardinfo for the NI MIO drivers is used to indicate if
    the ranges for the analog output subdevice (ao_range_table in the boardinfo)
    includes any unipolar ranges. If it's not set, the ao_range_table only has
    bipolar ranges.
    
    The 'ao_unipolar' flag is checked when munging the ao data values from the
    user so that the values for bipolar ranges are converted to 2's complement
    values before they are written to the hardware.
    
    The flag is also used when programming the analog output configuration on
    non-M series boards for bipolar/unipolar and external reference operation.
    
    Simplify the driver a bit by removing this boardinfo flag and just using
    the comedi_range_is_bipolar() and comedi_range_is_external() helpers to
    check the range directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ff881a7afdd3..471d7af59e99 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2925,7 +2925,8 @@ static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	for (i = 0; i < length; i++) {
 		range = CR_RANGE(cmd->chanlist[chan_index]);
-		if (board->ao_unipolar == 0 || (range & 1) == 0)
+
+		if (comedi_range_is_bipolar(s, range))
 			array[i] -= offset;
 #ifdef PCIDMA
 		array[i] = cpu_to_le16(array[i]);
@@ -3028,19 +3029,14 @@ static int ni_old_ao_config_chanlist(struct comedi_device *dev,
 		range = CR_RANGE(chanspec[i]);
 		conf = AO_Channel(chan);
 
-		if (board->ao_unipolar) {
-			if ((range & 1) == 0) {
-				conf |= AO_Bipolar;
-				invert = (1 << (board->aobits - 1));
-			} else {
-				invert = 0;
-			}
-			if (range & 2)
-				conf |= AO_Ext_Ref;
-		} else {
+		if (comedi_range_is_bipolar(s, range)) {
 			conf |= AO_Bipolar;
 			invert = (1 << (board->aobits - 1));
+		} else {
+			invert = 0;
 		}
+		if (comedi_range_is_external(s, range))
+			conf |= AO_Ext_Ref;
 
 		/* not all boards can deglitch, but this shouldn't hurt */
 		if (chanspec[i] & CR_DEGLITCH)

commit 1fa955ba355bfa6eb83b8fd9cc6064a561291d1f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 11:10:23 2014 -0700

    staging: comedi: ni_mio_common.c: remove IRQ_POLARITY defines
    
    Pass the irq_polarity to ni_E_init() and remove the defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e9b9c851922a..ff881a7afdd3 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5604,7 +5604,8 @@ static int ni_alloc_private(struct comedi_device *dev)
 	return 0;
 }
 
-static int ni_E_init(struct comedi_device *dev, unsigned interrupt_pin)
+static int ni_E_init(struct comedi_device *dev,
+		     unsigned interrupt_pin, unsigned irq_polarity)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
@@ -5905,7 +5906,7 @@ static int ni_E_init(struct comedi_device *dev, unsigned interrupt_pin)
 
 	if (dev->irq) {
 		ni_stc_writew(dev,
-			      (IRQ_POLARITY ? Interrupt_Output_Polarity : 0) |
+			      (irq_polarity ? Interrupt_Output_Polarity : 0) |
 			      (Interrupt_Output_On_3_Pins & 0) |
 			      Interrupt_A_Enable | Interrupt_B_Enable |
 			      Interrupt_A_Output_Select(interrupt_pin) |

commit 614b5cf097faabb969a0f7bc0f0a5eff3e48a07f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 11:10:21 2014 -0700

    staging: comedi: ni_mio_common.c: remove interrupt_pin() macros
    
    Pass the 'interrupt_pin' to ni_E_init() and remove the macros.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b2d6b1d1807d..e9b9c851922a 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5604,7 +5604,7 @@ static int ni_alloc_private(struct comedi_device *dev)
 	return 0;
 }
 
-static int ni_E_init(struct comedi_device *dev)
+static int ni_E_init(struct comedi_device *dev, unsigned interrupt_pin)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
@@ -5908,8 +5908,8 @@ static int ni_E_init(struct comedi_device *dev)
 			      (IRQ_POLARITY ? Interrupt_Output_Polarity : 0) |
 			      (Interrupt_Output_On_3_Pins & 0) |
 			      Interrupt_A_Enable | Interrupt_B_Enable |
-			      Interrupt_A_Output_Select(interrupt_pin(dev->irq)) |
-			      Interrupt_B_Output_Select(interrupt_pin(dev->irq)),
+			      Interrupt_A_Output_Select(interrupt_pin) |
+			      Interrupt_B_Output_Select(interrupt_pin),
 			      Interrupt_Control_Register);
 	}
 

commit f4f3f7cf27e7ae015672b59ec40c7deabeaf5d2e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 10:58:28 2014 -0700

    staging: comedi: introduce comedi_buf_n_bytes_ready()
    
    Introduce an inline helper to return the number of bytes that are
    ready to read from the comedi_async buffer. Use the helper in the
    comedi drivers that currently do the calculation as part of the
    (*poll) operation.
    
    Also, use the helper in comedi_fops where the calculation is used as
    part of the subdevice going nonbusy.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7737749d3b2c..b2d6b1d1807d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1878,7 +1878,7 @@ static int ni_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 #else
 	ni_sync_ai_dma(dev);
 #endif
-	count = s->async->buf_write_count - s->async->buf_read_count;
+	count = comedi_buf_n_bytes_ready(s);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return count;

commit b30f0d0caa1ffc1051c82cfb42014e084b6ac4c3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 19 10:20:37 2014 -0700

    staging: comedi: ni_stc.h: remove stc read/write callbacks from ni_private
    
    The drivers that include ni_mio_common.c set the stc register read/write
    callbacks to private functions that handle the read/write operations in
    the correct manner for the hardware.
    
    The ni_atmio and ni_mio_cs drivers use identical code to handle the
    operations.
    
    The ni_pcimio driver is a bit different due to the non-windowed setup
    of the stc registers on the m series boards. For the other boards
    supported by the ni_pcimio driver, the direct access of the first 8
    STC registers is also disabled due to a difference on the 611x devices.
    
    These differences can all be handled in the ni_stc_{read,write}[lw]()
    helpers. Refactor the helpers and remove the callbacks from the private
    data.
    
    Also, move the helper functions the handle the mapping of the windowed
    STC register offsets to M series register offset from ni_pcimio.c to
    ni_mio_common.c.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5db40eacfe78..7737749d3b2c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -306,32 +306,345 @@ static uint8_t ni_readb(struct comedi_device *dev, int reg)
 		return inb(dev->iobase + reg);
 }
 
-static void ni_stc_writel(struct comedi_device *dev, uint32_t data, int reg)
+/*
+ * We automatically take advantage of STC registers that can be
+ * read/written directly in the I/O space of the board.
+ *
+ * The AT-MIO and DAQCard devices map the low 8 STC registers to
+ * iobase+reg*2.
+ *
+ * Most PCIMIO devices also map the low 8 STC registers but the
+ * 611x devices map the read registers to iobase+(addr-1)*2.
+ * For now non-windowed STC access is disabled if a PCIMIO device
+ * is detected (devpriv->mite has been initialized).
+ *
+ * The M series devices do not used windowed registers for the
+ * STC registers. The functions below handle the mapping of the
+ * windowed STC registers to the m series register offsets.
+ */
+
+static void m_series_stc_writel(struct comedi_device *dev,
+				uint32_t data, int reg)
 {
-	struct ni_private *devpriv = dev->private;
+	unsigned offset;
 
-	devpriv->stc_writel(dev, data, reg);
+	switch (reg) {
+	case AI_SC_Load_A_Registers:
+		offset = M_Offset_AI_SC_Load_A;
+		break;
+	case AI_SI_Load_A_Registers:
+		offset = M_Offset_AI_SI_Load_A;
+		break;
+	case AO_BC_Load_A_Register:
+		offset = M_Offset_AO_BC_Load_A;
+		break;
+	case AO_UC_Load_A_Register:
+		offset = M_Offset_AO_UC_Load_A;
+		break;
+	case AO_UI_Load_A_Register:
+		offset = M_Offset_AO_UI_Load_A;
+		break;
+	case G_Load_A_Register(0):
+		offset = M_Offset_G0_Load_A;
+		break;
+	case G_Load_A_Register(1):
+		offset = M_Offset_G1_Load_A;
+		break;
+	case G_Load_B_Register(0):
+		offset = M_Offset_G0_Load_B;
+		break;
+	case G_Load_B_Register(1):
+		offset = M_Offset_G1_Load_B;
+		break;
+	default:
+		dev_warn(dev->class_dev,
+			 "%s: bug! unhandled register=0x%x in switch\n",
+			 __func__, reg);
+		return;
+	}
+	ni_writel(dev, data, offset);
+}
+
+static void m_series_stc_writew(struct comedi_device *dev,
+				uint16_t data, int reg)
+{
+	unsigned offset;
+
+	switch (reg) {
+	case ADC_FIFO_Clear:
+		offset = M_Offset_AI_FIFO_Clear;
+		break;
+	case AI_Command_1_Register:
+		offset = M_Offset_AI_Command_1;
+		break;
+	case AI_Command_2_Register:
+		offset = M_Offset_AI_Command_2;
+		break;
+	case AI_Mode_1_Register:
+		offset = M_Offset_AI_Mode_1;
+		break;
+	case AI_Mode_2_Register:
+		offset = M_Offset_AI_Mode_2;
+		break;
+	case AI_Mode_3_Register:
+		offset = M_Offset_AI_Mode_3;
+		break;
+	case AI_Output_Control_Register:
+		offset = M_Offset_AI_Output_Control;
+		break;
+	case AI_Personal_Register:
+		offset = M_Offset_AI_Personal;
+		break;
+	case AI_SI2_Load_A_Register:
+		/* this is a 32 bit register on m series boards */
+		ni_writel(dev, data, M_Offset_AI_SI2_Load_A);
+		return;
+	case AI_SI2_Load_B_Register:
+		/* this is a 32 bit register on m series boards */
+		ni_writel(dev, data, M_Offset_AI_SI2_Load_B);
+		return;
+	case AI_START_STOP_Select_Register:
+		offset = M_Offset_AI_START_STOP_Select;
+		break;
+	case AI_Trigger_Select_Register:
+		offset = M_Offset_AI_Trigger_Select;
+		break;
+	case Analog_Trigger_Etc_Register:
+		offset = M_Offset_Analog_Trigger_Etc;
+		break;
+	case AO_Command_1_Register:
+		offset = M_Offset_AO_Command_1;
+		break;
+	case AO_Command_2_Register:
+		offset = M_Offset_AO_Command_2;
+		break;
+	case AO_Mode_1_Register:
+		offset = M_Offset_AO_Mode_1;
+		break;
+	case AO_Mode_2_Register:
+		offset = M_Offset_AO_Mode_2;
+		break;
+	case AO_Mode_3_Register:
+		offset = M_Offset_AO_Mode_3;
+		break;
+	case AO_Output_Control_Register:
+		offset = M_Offset_AO_Output_Control;
+		break;
+	case AO_Personal_Register:
+		offset = M_Offset_AO_Personal;
+		break;
+	case AO_Start_Select_Register:
+		offset = M_Offset_AO_Start_Select;
+		break;
+	case AO_Trigger_Select_Register:
+		offset = M_Offset_AO_Trigger_Select;
+		break;
+	case Clock_and_FOUT_Register:
+		offset = M_Offset_Clock_and_FOUT;
+		break;
+	case Configuration_Memory_Clear:
+		offset = M_Offset_Configuration_Memory_Clear;
+		break;
+	case DAC_FIFO_Clear:
+		offset = M_Offset_AO_FIFO_Clear;
+		break;
+	case DIO_Control_Register:
+		dev_dbg(dev->class_dev,
+			"%s: FIXME: register 0x%x does not map cleanly on to m-series boards\n",
+			__func__, reg);
+		return;
+	case G_Autoincrement_Register(0):
+		offset = M_Offset_G0_Autoincrement;
+		break;
+	case G_Autoincrement_Register(1):
+		offset = M_Offset_G1_Autoincrement;
+		break;
+	case G_Command_Register(0):
+		offset = M_Offset_G0_Command;
+		break;
+	case G_Command_Register(1):
+		offset = M_Offset_G1_Command;
+		break;
+	case G_Input_Select_Register(0):
+		offset = M_Offset_G0_Input_Select;
+		break;
+	case G_Input_Select_Register(1):
+		offset = M_Offset_G1_Input_Select;
+		break;
+	case G_Mode_Register(0):
+		offset = M_Offset_G0_Mode;
+		break;
+	case G_Mode_Register(1):
+		offset = M_Offset_G1_Mode;
+		break;
+	case Interrupt_A_Ack_Register:
+		offset = M_Offset_Interrupt_A_Ack;
+		break;
+	case Interrupt_A_Enable_Register:
+		offset = M_Offset_Interrupt_A_Enable;
+		break;
+	case Interrupt_B_Ack_Register:
+		offset = M_Offset_Interrupt_B_Ack;
+		break;
+	case Interrupt_B_Enable_Register:
+		offset = M_Offset_Interrupt_B_Enable;
+		break;
+	case Interrupt_Control_Register:
+		offset = M_Offset_Interrupt_Control;
+		break;
+	case IO_Bidirection_Pin_Register:
+		offset = M_Offset_IO_Bidirection_Pin;
+		break;
+	case Joint_Reset_Register:
+		offset = M_Offset_Joint_Reset;
+		break;
+	case RTSI_Trig_A_Output_Register:
+		offset = M_Offset_RTSI_Trig_A_Output;
+		break;
+	case RTSI_Trig_B_Output_Register:
+		offset = M_Offset_RTSI_Trig_B_Output;
+		break;
+	case RTSI_Trig_Direction_Register:
+		offset = M_Offset_RTSI_Trig_Direction;
+		break;
+	/*
+	 * FIXME: DIO_Output_Register (16 bit reg) is replaced by
+	 * M_Offset_Static_Digital_Output (32 bit) and
+	 * M_Offset_SCXI_Serial_Data_Out (8 bit)
+	 */
+	default:
+		dev_warn(dev->class_dev,
+			 "%s: bug! unhandled register=0x%x in switch\n",
+			 __func__, reg);
+		return;
+	}
+	ni_writew(dev, data, offset);
+}
+
+static uint32_t m_series_stc_readl(struct comedi_device *dev, int reg)
+{
+	unsigned offset;
+
+	switch (reg) {
+	case G_HW_Save_Register(0):
+		offset = M_Offset_G0_HW_Save;
+		break;
+	case G_HW_Save_Register(1):
+		offset = M_Offset_G1_HW_Save;
+		break;
+	case G_Save_Register(0):
+		offset = M_Offset_G0_Save;
+		break;
+	case G_Save_Register(1):
+		offset = M_Offset_G1_Save;
+		break;
+	default:
+		dev_warn(dev->class_dev,
+			 "%s: bug! unhandled register=0x%x in switch\n",
+			 __func__, reg);
+		return 0;
+	}
+	return ni_readl(dev, offset);
+}
+
+static uint16_t m_series_stc_readw(struct comedi_device *dev, int reg)
+{
+	unsigned offset;
+
+	switch (reg) {
+	case AI_Status_1_Register:
+		offset = M_Offset_AI_Status_1;
+		break;
+	case AO_Status_1_Register:
+		offset = M_Offset_AO_Status_1;
+		break;
+	case AO_Status_2_Register:
+		offset = M_Offset_AO_Status_2;
+		break;
+	case DIO_Serial_Input_Register:
+		return ni_readb(dev, M_Offset_SCXI_Serial_Data_In);
+	case Joint_Status_1_Register:
+		offset = M_Offset_Joint_Status_1;
+		break;
+	case Joint_Status_2_Register:
+		offset = M_Offset_Joint_Status_2;
+		break;
+	case G_Status_Register:
+		offset = M_Offset_G01_Status;
+		break;
+	default:
+		dev_warn(dev->class_dev,
+			 "%s: bug! unhandled register=0x%x in switch\n",
+			 __func__, reg);
+		return 0;
+	}
+	return ni_readw(dev, offset);
 }
 
 static void ni_stc_writew(struct comedi_device *dev, uint16_t data, int reg)
 {
 	struct ni_private *devpriv = dev->private;
+	unsigned long flags;
 
-	devpriv->stc_writew(dev, data, reg);
+	if (devpriv->is_m_series) {
+		m_series_stc_writew(dev, data, reg);
+	} else {
+		spin_lock_irqsave(&devpriv->window_lock, flags);
+		if (!devpriv->mite && reg < 8) {
+			ni_writew(dev, data, reg * 2);
+		} else {
+			ni_writew(dev, reg, Window_Address);
+			ni_writew(dev, data, Window_Data);
+		}
+		spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	}
 }
 
-static uint32_t ni_stc_readl(struct comedi_device *dev, int reg)
+static void ni_stc_writel(struct comedi_device *dev, uint32_t data, int reg)
 {
 	struct ni_private *devpriv = dev->private;
 
-	return devpriv->stc_readl(dev, reg);
+	if (devpriv->is_m_series) {
+		m_series_stc_writel(dev, data, reg);
+	} else {
+		ni_stc_writew(dev, data >> 16, reg);
+		ni_stc_writew(dev, data & 0xffff, reg + 1);
+	}
 }
 
 static uint16_t ni_stc_readw(struct comedi_device *dev, int reg)
 {
 	struct ni_private *devpriv = dev->private;
+	unsigned long flags;
+	uint16_t val;
 
-	return devpriv->stc_readw(dev, reg);
+	if (devpriv->is_m_series) {
+		val = m_series_stc_readw(dev, reg);
+	} else {
+		spin_lock_irqsave(&devpriv->window_lock, flags);
+		if (!devpriv->mite && reg < 8) {
+			val = ni_readw(dev, reg * 2);
+		} else {
+			ni_writew(dev, reg, Window_Address);
+			val = ni_readw(dev, Window_Data);
+		}
+		spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	}
+	return val;
+}
+
+static uint32_t ni_stc_readl(struct comedi_device *dev, int reg)
+{
+	struct ni_private *devpriv = dev->private;
+	uint32_t val;
+
+	if (devpriv->is_m_series) {
+		val = m_series_stc_readl(dev, reg);
+	} else {
+		val = ni_stc_readw(dev, reg) << 16;
+		val |= ni_stc_readw(dev, reg + 1);
+	}
+	return val;
 }
 
 static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
@@ -681,21 +994,6 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 	}
 }
 
-static void win_out2(struct comedi_device *dev, uint32_t data, int reg)
-{
-	ni_stc_writew(dev, data >> 16, reg);
-	ni_stc_writew(dev, data & 0xffff, reg + 1);
-}
-
-static uint32_t win_in2(struct comedi_device *dev, int reg)
-{
-	uint32_t bits;
-
-	bits = ni_stc_readw(dev, reg) << 16;
-	bits |= ni_stc_readw(dev, reg + 1);
-	return bits;
-}
-
 #define ao_win_out(data, addr) ni_ao_win_outw(dev, data, addr)
 static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data,
 				  int addr)

commit ac63baf5517cb7c22d63e2c5d269994f3002c7e0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 19 10:20:36 2014 -0700

    staging: comedi: ni_stc.h: remove read/write callbacks from ni_private
    
    The drivers that include ni_mio_common.c set the read/write callbacks
    to private functions that handle the read/write operations in the
    correct manner for the hardware. The ni_atmio and ni_mio_cs drivers
    use ioport register access and the ni_pcimio driver uses memory mapped
    register access. The memory mapped base address is stored in the 'mite'
    pointer in the private data which is only allocated and initialized by
    the ni_pcimio driver.
    
    Detect the need for memory mapped register access by checking if the
    'mite' pointer is set in the private data and remove the callbacks
    from the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 040afba980c1..5db40eacfe78 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -250,42 +250,60 @@ static void ni_writel(struct comedi_device *dev, uint32_t data, int reg)
 {
 	struct ni_private *devpriv = dev->private;
 
-	devpriv->writel(dev, data, reg);
+	if (devpriv->mite)
+		writel(data, devpriv->mite->daq_io_addr + reg);
+	else
+		outl(data, dev->iobase + reg);
 }
 
 static void ni_writew(struct comedi_device *dev, uint16_t data, int reg)
 {
 	struct ni_private *devpriv = dev->private;
 
-	devpriv->writew(dev, data, reg);
+	if (devpriv->mite)
+		writew(data, devpriv->mite->daq_io_addr + reg);
+	else
+		outw(data, dev->iobase + reg);
 }
 
 static void ni_writeb(struct comedi_device *dev, uint8_t data, int reg)
 {
 	struct ni_private *devpriv = dev->private;
 
-	devpriv->writeb(dev, data, reg);
+	if (devpriv->mite)
+		writeb(data, devpriv->mite->daq_io_addr + reg);
+	else
+		outb(data, dev->iobase + reg);
 }
 
 static uint32_t ni_readl(struct comedi_device *dev, int reg)
 {
 	struct ni_private *devpriv = dev->private;
 
-	return devpriv->readl(dev, reg);
+	if (devpriv->mite)
+		return readl(devpriv->mite->daq_io_addr + reg);
+	else
+		return inl(dev->iobase + reg);
 }
 
 static uint16_t ni_readw(struct comedi_device *dev, int reg)
 {
 	struct ni_private *devpriv = dev->private;
 
-	return devpriv->readw(dev, reg);
+	if (devpriv->mite)
+		return readw(devpriv->mite->daq_io_addr + reg);
+	else
+		return inw(dev->iobase + reg);
 }
 
 static uint8_t ni_readb(struct comedi_device *dev, int reg)
 {
 	struct ni_private *devpriv = dev->private;
 
-	return devpriv->readb(dev, reg);
+	if (devpriv->mite)
+		return readb(devpriv->mite->daq_io_addr + reg);
+	else
+		return inb(dev->iobase + reg);
 }
 
 static void ni_stc_writel(struct comedi_device *dev, uint32_t data, int reg)

commit 5a92cac5dc3b48a4ae176045e1f13ecde5a7b586
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 19 10:20:35 2014 -0700

    staging: comedi: ni_mio_common.c: wrap the read/write operations
    
    The ni_atmio, ni_pcimio, and ni_mio_cs drivers all include this source
    file to handle the common functionality of the drivers. Each of those
    drivers set some function pointers in the private data to handle the
    read/write operations to the normal registers.
    
    Like done for the stc register operations, wrap these operations with
    some helper functions to clarify the code a bit and make it easier to
    read and maintain.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e54c016ea6a4..040afba980c1 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -246,6 +246,48 @@ enum timebase_nanoseconds {
 
 static const int num_adc_stages_611x = 3;
 
+static void ni_writel(struct comedi_device *dev, uint32_t data, int reg)
+{
+	struct ni_private *devpriv = dev->private;
+
+	devpriv->writel(dev, data, reg);
+}
+
+static void ni_writew(struct comedi_device *dev, uint16_t data, int reg)
+{
+	struct ni_private *devpriv = dev->private;
+
+	devpriv->writew(dev, data, reg);
+}
+
+static void ni_writeb(struct comedi_device *dev, uint8_t data, int reg)
+{
+	struct ni_private *devpriv = dev->private;
+
+	devpriv->writeb(dev, data, reg);
+}
+
+static uint32_t ni_readl(struct comedi_device *dev, int reg)
+{
+	struct ni_private *devpriv = dev->private;
+
+	return devpriv->readl(dev, reg);
+}
+
+static uint16_t ni_readw(struct comedi_device *dev, int reg)
+{
+	struct ni_private *devpriv = dev->private;
+
+	return devpriv->readw(dev, reg);
+}
+
+static uint8_t ni_readb(struct comedi_device *dev, int reg)
+{
+	struct ni_private *devpriv = dev->private;
+
+	return devpriv->readb(dev, reg);
+}
+
 static void ni_stc_writel(struct comedi_device *dev, uint32_t data, int reg)
 {
 	struct ni_private *devpriv = dev->private;
@@ -303,12 +345,12 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 	case AI_AO_Select:
 		devpriv->ai_ao_select_reg &= ~bit_mask;
 		devpriv->ai_ao_select_reg |= bit_values & bit_mask;
-		devpriv->writeb(dev, devpriv->ai_ao_select_reg, AI_AO_Select);
+		ni_writeb(dev, devpriv->ai_ao_select_reg, AI_AO_Select);
 		break;
 	case G0_G1_Select:
 		devpriv->g0_g1_select_reg &= ~bit_mask;
 		devpriv->g0_g1_select_reg |= bit_values & bit_mask;
-		devpriv->writeb(dev, devpriv->g0_g1_select_reg, G0_G1_Select);
+		ni_writeb(dev, devpriv->g0_g1_select_reg, G0_G1_Select);
 		break;
 	default:
 		printk("Warning %s() called with invalid register\n", __func__);
@@ -384,7 +426,7 @@ static inline void ni_set_cdo_dma_channel(struct comedi_device *dev,
 		    (ni_stc_dma_channel_select_bitfield(mite_channel) <<
 		     CDO_DMA_Select_Shift) & CDO_DMA_Select_Mask;
 	}
-	devpriv->writeb(dev, devpriv->cdio_dma_select_reg, M_Offset_CDIO_DMA_Select);
+	ni_writeb(dev, devpriv->cdio_dma_select_reg, M_Offset_CDIO_DMA_Select);
 	mmiowb();
 	spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
 }
@@ -586,17 +628,16 @@ static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 static void ni_clear_ai_fifo(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
 	static const int timeout = 10000;
 	int i;
 
 	if (board->reg_type == ni_reg_6143) {
 		/*  Flush the 6143 data FIFO */
-		devpriv->writel(dev, 0x10, AIFIFO_Control_6143);
-		devpriv->writel(dev, 0x00, AIFIFO_Control_6143);
+		ni_writel(dev, 0x10, AIFIFO_Control_6143);
+		ni_writel(dev, 0x00, AIFIFO_Control_6143);
 		/*  Wait for complete */
 		for (i = 0; i < timeout; i++) {
-			if (!(devpriv->readl(dev, AIFIFO_Status_6143) & 0x10))
+			if (!(ni_readl(dev, AIFIFO_Status_6143) & 0x10))
 				break;
 			udelay(1);
 		}
@@ -606,8 +647,8 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 	} else {
 		ni_stc_writew(dev, 1, ADC_FIFO_Clear);
 		if (board->reg_type == ni_reg_625x) {
-			devpriv->writeb(dev, 0, M_Offset_Static_AI_Control(0));
-			devpriv->writeb(dev, 1, M_Offset_Static_AI_Control(0));
+			ni_writeb(dev, 0, M_Offset_Static_AI_Control(0));
+			ni_writeb(dev, 1, M_Offset_Static_AI_Control(0));
 #if 0
 			/* the NI example code does 3 convert pulses for 625x boards,
 			   but that appears to be wrong in practice. */
@@ -645,8 +686,8 @@ static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data,
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->window_lock, flags);
-	devpriv->writew(dev, addr, AO_Window_Address_611x);
-	devpriv->writew(dev, data, AO_Window_Data_611x);
+	ni_writew(dev, addr, AO_Window_Address_611x);
+	ni_writew(dev, data, AO_Window_Data_611x);
 	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
@@ -657,8 +698,8 @@ static inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data,
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->window_lock, flags);
-	devpriv->writew(dev, addr, AO_Window_Address_611x);
-	devpriv->writel(dev, data, AO_Window_Data_611x);
+	ni_writew(dev, addr, AO_Window_Address_611x);
+	ni_writel(dev, data, AO_Window_Data_611x);
 	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
@@ -669,8 +710,8 @@ static inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)
 	unsigned short data;
 
 	spin_lock_irqsave(&devpriv->window_lock, flags);
-	devpriv->writew(dev, addr, AO_Window_Address_611x);
-	data = devpriv->readw(dev, AO_Window_Data_611x);
+	ni_writew(dev, addr, AO_Window_Address_611x);
+	data = ni_readw(dev, AO_Window_Data_611x);
 	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 	return data;
 }
@@ -785,7 +826,6 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 			    struct comedi_subdevice *s, int n)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	int chan;
@@ -814,9 +854,9 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 				i++;
 				packed_data |= (d << 16) & 0xffff0000;
 			}
-			devpriv->writel(dev, packed_data, DAC_FIFO_Data_611x);
+			ni_writel(dev, packed_data, DAC_FIFO_Data_611x);
 		} else {
-			devpriv->writew(dev, d, DAC_FIFO_Data);
+			ni_writew(dev, d, DAC_FIFO_Data);
 		}
 		chan++;
 		chan %= cmd->chanlist_len;
@@ -903,7 +943,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 		u32 dl;
 
 		for (i = 0; i < n / 2; i++) {
-			dl = devpriv->readl(dev, ADC_FIFO_Data_611x);
+			dl = ni_readl(dev, ADC_FIFO_Data_611x);
 			/* This may get the hi/lo data in the wrong order */
 			data[0] = (dl >> 16) & 0xffff;
 			data[1] = dl & 0xffff;
@@ -911,7 +951,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 		}
 		/* Check if there's a single sample stuck in the FIFO */
 		if (n % 2) {
-			dl = devpriv->readl(dev, ADC_FIFO_Data_611x);
+			dl = ni_readl(dev, ADC_FIFO_Data_611x);
 			data[0] = dl & 0xffff;
 			cfc_write_to_buffer(s, data[0]);
 		}
@@ -921,7 +961,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 
 		/*  This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed */
 		for (i = 0; i < n / 2; i++) {
-			dl = devpriv->readl(dev, AIFIFO_Data_6143);
+			dl = ni_readl(dev, AIFIFO_Data_6143);
 
 			data[0] = (dl >> 16) & 0xffff;
 			data[1] = dl & 0xffff;
@@ -930,8 +970,8 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 		if (n % 2) {
 			/* Assume there is a single sample stuck in the FIFO */
 			/* Get stranded sample into FIFO */
-			devpriv->writel(dev, 0x01, AIFIFO_Control_6143);
-			dl = devpriv->readl(dev, AIFIFO_Data_6143);
+			ni_writel(dev, 0x01, AIFIFO_Control_6143);
+			dl = ni_readl(dev, AIFIFO_Data_6143);
 			data[0] = (dl >> 16) & 0xffff;
 			cfc_write_to_buffer(s, data[0]);
 		}
@@ -944,7 +984,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 		}
 		for (i = 0; i < n; i++) {
 			devpriv->ai_fifo_buffer[i] =
-			    devpriv->readw(dev, ADC_FIFO_Data_Register);
+			    ni_readw(dev, ADC_FIFO_Data_Register);
 		}
 		cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
 					  n *
@@ -980,7 +1020,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 	if (board->reg_type == ni_reg_611x) {
 		while ((ni_stc_readw(dev, AI_Status_1_Register) &
 			AI_FIFO_Empty_St) == 0) {
-			dl = devpriv->readl(dev, ADC_FIFO_Data_611x);
+			dl = ni_readl(dev, ADC_FIFO_Data_611x);
 
 			/* This may get the hi/lo data in the wrong order */
 			data[0] = (dl >> 16);
@@ -989,8 +1029,8 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 		}
 	} else if (board->reg_type == ni_reg_6143) {
 		i = 0;
-		while (devpriv->readl(dev, AIFIFO_Status_6143) & 0x04) {
-			dl = devpriv->readl(dev, AIFIFO_Data_6143);
+		while (ni_readl(dev, AIFIFO_Status_6143) & 0x04) {
+			dl = ni_readl(dev, AIFIFO_Data_6143);
 
 			/* This may get the hi/lo data in the wrong order */
 			data[0] = (dl >> 16);
@@ -999,10 +1039,10 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 			i += 2;
 		}
 		/*  Check if stranded sample is present */
-		if (devpriv->readl(dev, AIFIFO_Status_6143) & 0x01) {
+		if (ni_readl(dev, AIFIFO_Status_6143) & 0x01) {
 			/* Get stranded sample into FIFO */
-			devpriv->writel(dev, 0x01, AIFIFO_Control_6143);
-			dl = devpriv->readl(dev, AIFIFO_Data_6143);
+			ni_writel(dev, 0x01, AIFIFO_Control_6143);
+			dl = ni_readl(dev, AIFIFO_Data_6143);
 			data[0] = (dl >> 16) & 0xffff;
 			cfc_write_to_buffer(s, data[0]);
 		}
@@ -1021,7 +1061,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 				if (fifo_empty)
 					break;
 				devpriv->ai_fifo_buffer[i] =
-				    devpriv->readw(dev, ADC_FIFO_Data_Register);
+				    ni_readw(dev, ADC_FIFO_Data_Register);
 			}
 			cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
 						  i *
@@ -1034,7 +1074,6 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 static void get_last_sample_611x(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned short data;
 	u32 dl;
@@ -1043,8 +1082,8 @@ static void get_last_sample_611x(struct comedi_device *dev)
 		return;
 
 	/* Check if there's a single sample stuck in the FIFO */
-	if (devpriv->readb(dev, XXX_Status) & 0x80) {
-		dl = devpriv->readl(dev, ADC_FIFO_Data_611x);
+	if (ni_readb(dev, XXX_Status) & 0x80) {
+		dl = ni_readl(dev, ADC_FIFO_Data_611x);
 		data = (dl & 0xffff);
 		cfc_write_to_buffer(s, data);
 	}
@@ -1053,7 +1092,6 @@ static void get_last_sample_611x(struct comedi_device *dev)
 static void get_last_sample_6143(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned short data;
 	u32 dl;
@@ -1062,10 +1100,10 @@ static void get_last_sample_6143(struct comedi_device *dev)
 		return;
 
 	/* Check if there's a single sample stuck in the FIFO */
-	if (devpriv->readl(dev, AIFIFO_Status_6143) & 0x01) {
+	if (ni_readl(dev, AIFIFO_Status_6143) & 0x01) {
 		/* Get stranded sample into FIFO */
-		devpriv->writel(dev, 0x01, AIFIFO_Control_6143);
-		dl = devpriv->readl(dev, AIFIFO_Data_6143);
+		ni_writel(dev, 0x01, AIFIFO_Control_6143);
+		dl = ni_readl(dev, AIFIFO_Data_6143);
 
 		/* This may get the hi/lo data in the wrong order */
 		data = (dl >> 16) & 0xffff;
@@ -1414,7 +1452,6 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
 
 	ni_release_ai_mite_channel(dev);
 	/* ai configuration */
@@ -1430,7 +1467,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_clear_ai_fifo(dev);
 
 	if (board->reg_type != ni_reg_6143)
-		devpriv->writeb(dev, 0, Misc_Command);
+		ni_writeb(dev, 0, Misc_Command);
 
 	ni_stc_writew(dev, AI_Disarm, AI_Command_1_Register); /* reset pulses */
 	ni_stc_writew(dev, AI_Start_Stop | AI_Mode_1_Reserved
@@ -1581,10 +1618,9 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 			bypass_bits |= MSeries_AI_Bypass_Dither_Bit;
 		/*  don't use 2's complement encoding */
 		bypass_bits |= MSeries_AI_Bypass_Polarity_Bit;
-		devpriv->writel(dev, bypass_bits,
-				M_Offset_AI_Config_FIFO_Bypass);
+		ni_writel(dev, bypass_bits, M_Offset_AI_Config_FIFO_Bypass);
 	} else {
-		devpriv->writel(dev, 0, M_Offset_AI_Config_FIFO_Bypass);
+		ni_writel(dev, 0, M_Offset_AI_Config_FIFO_Bypass);
 	}
 	offset = 0;
 	for (i = 0; i < n_chan; i++) {
@@ -1622,7 +1658,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 			config_bits |= MSeries_AI_Config_Dither_Bit;
 		/*  don't use 2's complement encoding */
 		config_bits |= MSeries_AI_Config_Polarity_Bit;
-		devpriv->writew(dev, config_bits, M_Offset_AI_Config_FIFO_Data);
+		ni_writew(dev, config_bits, M_Offset_AI_Config_FIFO_Data);
 	}
 	ni_prime_channelgain_list(dev);
 }
@@ -1691,21 +1727,21 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		if ((list[0] & CR_ALT_SOURCE)
 		    && !devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay enable bit */
-			devpriv->writew(dev, devpriv->ai_calib_source |
-					     Calibration_Channel_6143_RelayOn,
-					Calibration_Channel_6143);
-			devpriv->writew(dev, devpriv->ai_calib_source,
-					Calibration_Channel_6143);
+			ni_writew(dev, devpriv->ai_calib_source |
+				       Calibration_Channel_6143_RelayOn,
+				  Calibration_Channel_6143);
+			ni_writew(dev, devpriv->ai_calib_source,
+				  Calibration_Channel_6143);
 			devpriv->ai_calib_source_enabled = 1;
 			msleep_interruptible(100);	/*  Allow relays to change */
 		} else if (!(list[0] & CR_ALT_SOURCE)
 			   && devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay disable bit */
-			devpriv->writew(dev, devpriv->ai_calib_source |
-					     Calibration_Channel_6143_RelayOff,
-					Calibration_Channel_6143);
-			devpriv->writew(dev, devpriv->ai_calib_source,
-					Calibration_Channel_6143);
+			ni_writew(dev, devpriv->ai_calib_source |
+				       Calibration_Channel_6143_RelayOff,
+				  Calibration_Channel_6143);
+			ni_writew(dev, devpriv->ai_calib_source,
+				  Calibration_Channel_6143);
 			devpriv->ai_calib_source_enabled = 0;
 			msleep_interruptible(100);	/*  Allow relays to change */
 		}
@@ -1733,8 +1769,8 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		hi = 0;
 		if ((list[i] & CR_ALT_SOURCE)) {
 			if (board->reg_type == ni_reg_611x)
-				devpriv->writew(dev, CR_CHAN(list[i]) & 0x0003,
-					Calibration_Channel_Select_611x);
+				ni_writew(dev, CR_CHAN(list[i]) & 0x0003,
+					  Calibration_Channel_Select_611x);
 		} else {
 			if (board->reg_type == ni_reg_611x)
 				aref = AREF_DIFF;
@@ -1756,7 +1792,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		}
 		hi |= AI_CONFIG_CHANNEL(chan);
 
-		devpriv->writew(dev, hi, Configuration_Memory_High);
+		ni_writew(dev, hi, Configuration_Memory_High);
 
 		if (board->reg_type != ni_reg_6143) {
 			lo = range;
@@ -1765,7 +1801,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 			if (dither)
 				lo |= AI_DITHER;
 
-			devpriv->writew(dev, lo, Configuration_Memory_Low);
+			ni_writew(dev, lo, Configuration_Memory_Low);
 		}
 	}
 
@@ -1806,17 +1842,15 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			/* The 611x has screwy 32-bit FIFOs. */
 			d = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
-				if (devpriv->readb(dev, XXX_Status) & 0x80) {
-					d = devpriv->readl(dev,
-							   ADC_FIFO_Data_611x);
+				if (ni_readb(dev, XXX_Status) & 0x80) {
+					d = ni_readl(dev, ADC_FIFO_Data_611x);
 					d >>= 16;
 					d &= 0xffff;
 					break;
 				}
 				if (!(ni_stc_readw(dev, AI_Status_1_Register) &
 				      AI_FIFO_Empty_St)) {
-					d = devpriv->readl(dev,
-							   ADC_FIFO_Data_611x);
+					d = ni_readl(dev, ADC_FIFO_Data_611x);
 					d &= 0xffff;
 					break;
 				}
@@ -1837,13 +1871,11 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			/* The 6143 has 32-bit FIFOs. You need to strobe a bit to move a single 16bit stranded sample into the FIFO */
 			dl = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
-				if (devpriv->readl(dev, AIFIFO_Status_6143) &
-				    0x01) {
+				if (ni_readl(dev, AIFIFO_Status_6143) & 0x01) {
 					/* Get stranded sample into FIFO */
-					devpriv->writel(dev, 0x01,
-							AIFIFO_Control_6143);
-					dl = devpriv->readl(dev,
-							    AIFIFO_Data_6143);
+					ni_writel(dev, 0x01,
+						  AIFIFO_Control_6143);
+					dl = ni_readl(dev, AIFIFO_Data_6143);
 					break;
 				}
 			}
@@ -1869,11 +1901,11 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				return -ETIME;
 			}
 			if (devpriv->is_m_series) {
-				dl = devpriv->readl(dev, M_Offset_AI_FIFO_Data);
+				dl = ni_readl(dev, M_Offset_AI_FIFO_Data);
 				dl &= mask;
 				data[n] = dl;
 			} else {
-				d = devpriv->readw(dev, ADC_FIFO_Data_Register);
+				d = ni_readw(dev, ADC_FIFO_Data_Register);
 				d += signbits;	/* subtle: needs to be short addition */
 				data[n] = d;
 			}
@@ -2537,8 +2569,7 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 				return -EINVAL;
 
 			devpriv->ai_calib_source = calib_source;
-			devpriv->writew(dev, calib_source,
-					Calibration_Channel_6143);
+			ni_writew(dev, calib_source, Calibration_Channel_6143);
 		} else {
 			unsigned int calib_source;
 			unsigned int calib_source_adjust;
@@ -2550,8 +2581,8 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 				return -EINVAL;
 			devpriv->ai_calib_source = calib_source;
 			if (board->reg_type == ni_reg_611x) {
-				devpriv->writeb(dev, calib_source_adjust,
-						Cal_Gain_Select_611x);
+				ni_writeb(dev, calib_source_adjust,
+					  Cal_Gain_Select_611x);
 			}
 		}
 		return 2;
@@ -2604,10 +2635,9 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 	if (timed) {
 		for (i = 0; i < board->n_aochan; ++i) {
 			devpriv->ao_conf[i] &= ~MSeries_AO_Update_Timed_Bit;
-			devpriv->writeb(dev, devpriv->ao_conf[i],
-					M_Offset_AO_Config_Bank(i));
-			devpriv->writeb(dev, 0xf,
-					M_Offset_AO_Waveform_Order(i));
+			ni_writeb(dev, devpriv->ao_conf[i],
+				  M_Offset_AO_Config_Bank(i));
+			ni_writeb(dev, 0xf, M_Offset_AO_Waveform_Order(i));
 		}
 	}
 	for (i = 0; i < n_chans; i++) {
@@ -2620,23 +2650,23 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 		switch (krange->max - krange->min) {
 		case 20000000:
 			conf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;
-			devpriv->writeb(dev, 0,
-					M_Offset_AO_Reference_Attenuation(chan));
+			ni_writeb(dev, 0,
+				  M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		case 10000000:
 			conf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;
-			devpriv->writeb(dev, 0,
-					M_Offset_AO_Reference_Attenuation(chan));
+			ni_writeb(dev, 0,
+				  M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		case 4000000:
 			conf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;
-			devpriv->writeb(dev, MSeries_Attenuate_x5_Bit,
-					M_Offset_AO_Reference_Attenuation(chan));
+			ni_writeb(dev, MSeries_Attenuate_x5_Bit,
+				  M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		case 2000000:
 			conf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;
-			devpriv->writeb(dev, MSeries_Attenuate_x5_Bit,
-					M_Offset_AO_Reference_Attenuation(chan));
+			ni_writeb(dev, MSeries_Attenuate_x5_Bit,
+				  M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		default:
 			printk("%s: bug! unhandled ao reference voltage\n",
@@ -2657,9 +2687,9 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 		}
 		if (timed)
 			conf |= MSeries_AO_Update_Timed_Bit;
-		devpriv->writeb(dev, conf, M_Offset_AO_Config_Bank(chan));
+		ni_writeb(dev, conf, M_Offset_AO_Config_Bank(chan));
 		devpriv->ao_conf[chan] = conf;
-		devpriv->writeb(dev, i, M_Offset_AO_Waveform_Order(chan));
+		ni_writeb(dev, i, M_Offset_AO_Waveform_Order(chan));
 	}
 	return invert;
 }
@@ -2705,7 +2735,7 @@ static int ni_old_ao_config_chanlist(struct comedi_device *dev,
 		conf |= (CR_AREF(chanspec[i]) ==
 			 AREF_OTHER) ? AO_Ground_Ref : 0;
 
-		devpriv->writew(dev, conf, AO_Configuration);
+		ni_writew(dev, conf, AO_Configuration);
 		devpriv->ao_conf[chan] = conf;
 	}
 	return invert;
@@ -2749,10 +2779,10 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 	devpriv->ao[chan] = data[0];
 
 	if (devpriv->is_m_series) {
-		devpriv->writew(dev, data[0], M_Offset_DAC_Direct_Data(chan));
+		ni_writew(dev, data[0], M_Offset_DAC_Direct_Data(chan));
 	} else
-		devpriv->writew(dev, data[0] ^ invert,
-				(chan) ? DAC1_Direct_Data : DAC0_Direct_Data);
+		ni_writew(dev, data[0] ^ invert,
+			  (chan) ? DAC1_Direct_Data : DAC0_Direct_Data);
 
 	return 1;
 }
@@ -3261,14 +3291,13 @@ static int ni_m_series_dio_insn_config(struct comedi_device *dev,
 				       struct comedi_insn *insn,
 				       unsigned int *data)
 {
-	struct ni_private *devpriv = dev->private;
 	int ret;
 
 	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
 	if (ret)
 		return ret;
 
-	devpriv->writel(dev, s->io_bits, M_Offset_DIO_Direction);
+	ni_writel(dev, s->io_bits, M_Offset_DIO_Direction);
 
 	return insn->n;
 }
@@ -3278,12 +3307,10 @@ static int ni_m_series_dio_insn_bits(struct comedi_device *dev,
 				     struct comedi_insn *insn,
 				     unsigned int *data)
 {
-	struct ni_private *devpriv = dev->private;
-
 	if (comedi_dio_update_state(s, data))
-		devpriv->writel(dev, s->state, M_Offset_Static_Digital_Output);
+		ni_writel(dev, s->state, M_Offset_Static_Digital_Output);
 
-	data[1] = devpriv->readl(dev, M_Offset_Static_Digital_Input);
+	data[1] = ni_readl(dev, M_Offset_Static_Digital_Input);
 
 	return insn->n;
 }
@@ -3362,12 +3389,12 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 			  struct comedi_subdevice *s,
 			  unsigned int trig_num)
 {
-	struct ni_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	const unsigned timeout = 1000;
 	int retval = 0;
 	unsigned i;
 #ifdef PCIDMA
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 #endif
 
@@ -3394,12 +3421,11 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 #endif
 /*
 * XXX not sure what interrupt C group does
-* devpriv->writeb(dev, Interrupt_Group_C_Enable_Bit,
+* ni_writeb(dev, Interrupt_Group_C_Enable_Bit,
 * M_Offset_Interrupt_C_Enable); wait for dma to fill output fifo
 */
 	for (i = 0; i < timeout; ++i) {
-		if (devpriv->readl(dev, M_Offset_CDIO_Status) &
-		    CDO_FIFO_Full_Bit)
+		if (ni_readl(dev, M_Offset_CDIO_Status) & CDO_FIFO_Full_Bit)
 			break;
 		udelay(10);
 	}
@@ -3408,20 +3434,19 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 		s->cancel(dev, s);
 		return -EIO;
 	}
-	devpriv->writel(dev, CDO_Arm_Bit | CDO_Error_Interrupt_Enable_Set_Bit |
-			     CDO_Empty_FIFO_Interrupt_Enable_Set_Bit,
-			M_Offset_CDIO_Command);
+	ni_writel(dev, CDO_Arm_Bit | CDO_Error_Interrupt_Enable_Set_Bit |
+		       CDO_Empty_FIFO_Interrupt_Enable_Set_Bit,
+		  M_Offset_CDIO_Command);
 	return retval;
 }
 
 static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct ni_private *devpriv = dev->private;
 	const struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;
 	int retval;
 
-	devpriv->writel(dev, CDO_Reset_Bit, M_Offset_CDIO_Command);
+	ni_writel(dev, CDO_Reset_Bit, M_Offset_CDIO_Command);
 	switch (cmd->scan_begin_src) {
 	case TRIG_EXT:
 		cdo_mode_bits |=
@@ -3434,11 +3459,11 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	if (cmd->scan_begin_arg & CR_INVERT)
 		cdo_mode_bits |= CDO_Polarity_Bit;
-	devpriv->writel(dev, cdo_mode_bits, M_Offset_CDO_Mode);
+	ni_writel(dev, cdo_mode_bits, M_Offset_CDO_Mode);
 	if (s->io_bits) {
-		devpriv->writel(dev, s->state, M_Offset_CDO_FIFO_Data);
-		devpriv->writel(dev, CDO_SW_Update_Bit, M_Offset_CDIO_Command);
-		devpriv->writel(dev, s->io_bits, M_Offset_CDO_Mask_Enable);
+		ni_writel(dev, s->state, M_Offset_CDO_FIFO_Data);
+		ni_writel(dev, CDO_SW_Update_Bit, M_Offset_CDIO_Command);
+		ni_writel(dev, s->io_bits, M_Offset_CDO_Mask_Enable);
 	} else {
 		comedi_error(dev,
 			     "attempted to run digital output command with no lines configured as outputs");
@@ -3455,18 +3480,15 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct ni_private *devpriv = dev->private;
-
-	devpriv->writel(dev, CDO_Disarm_Bit |
-			     CDO_Error_Interrupt_Enable_Clear_Bit |
-			     CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
-			     CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
-			M_Offset_CDIO_Command);
+	ni_writel(dev, CDO_Disarm_Bit | CDO_Error_Interrupt_Enable_Clear_Bit |
+		       CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
+		       CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
+		  M_Offset_CDIO_Command);
 /*
-* XXX not sure what interrupt C group does devpriv->writeb(dev, 0,
+* XXX not sure what interrupt C group does ni_writeb(dev, 0,
 * M_Offset_Interrupt_C_Enable);
 */
-	devpriv->writel(dev, 0, M_Offset_CDO_Mask_Enable);
+	ni_writel(dev, 0, M_Offset_CDO_Mask_Enable);
 	ni_release_cdo_mite_channel(dev);
 	return 0;
 }
@@ -3497,18 +3519,18 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif
 
-	cdio_status = devpriv->readl(dev, M_Offset_CDIO_Status);
+	cdio_status = ni_readl(dev, M_Offset_CDIO_Status);
 	if (cdio_status & (CDO_Overrun_Bit | CDO_Underflow_Bit)) {
 		/* printk("cdio error: statux=0x%x\n", cdio_status); */
 		/* XXX just guessing this is needed and does something useful */
-		devpriv->writel(dev, CDO_Error_Interrupt_Confirm_Bit,
-				M_Offset_CDIO_Command);
+		ni_writel(dev, CDO_Error_Interrupt_Confirm_Bit,
+			  M_Offset_CDIO_Command);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 	if (cdio_status & CDO_FIFO_Empty_Bit) {
 		/* printk("cdio fifo empty\n"); */
-		devpriv->writel(dev, CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
-				M_Offset_CDIO_Command);
+		ni_writel(dev, CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
+			  M_Offset_CDIO_Command);
 		/* s->async->events |= COMEDI_CB_EOA; */
 	}
 	cfc_handle_events(dev, s);
@@ -3806,7 +3828,6 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 				   enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
-	struct ni_private *devpriv = dev->private;
 	unsigned stc_register;
 	/* bits in the join reset register which are relevant to counters */
 	static const unsigned gpct_joint_reset_mask = G0_Reset | G1_Reset;
@@ -3818,28 +3839,28 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 	switch (reg) {
 		/* m-series-only registers */
 	case NITIO_G0_CNT_MODE:
-		devpriv->writew(dev, bits, M_Offset_G0_Counting_Mode);
+		ni_writew(dev, bits, M_Offset_G0_Counting_Mode);
 		break;
 	case NITIO_G1_CNT_MODE:
-		devpriv->writew(dev, bits, M_Offset_G1_Counting_Mode);
+		ni_writew(dev, bits, M_Offset_G1_Counting_Mode);
 		break;
 	case NITIO_G0_GATE2:
-		devpriv->writew(dev, bits, M_Offset_G0_Second_Gate);
+		ni_writew(dev, bits, M_Offset_G0_Second_Gate);
 		break;
 	case NITIO_G1_GATE2:
-		devpriv->writew(dev, bits, M_Offset_G1_Second_Gate);
+		ni_writew(dev, bits, M_Offset_G1_Second_Gate);
 		break;
 	case NITIO_G0_DMA_CFG:
-		devpriv->writew(dev, bits, M_Offset_G0_DMA_Config);
+		ni_writew(dev, bits, M_Offset_G0_DMA_Config);
 		break;
 	case NITIO_G1_DMA_CFG:
-		devpriv->writew(dev, bits, M_Offset_G1_DMA_Config);
+		ni_writew(dev, bits, M_Offset_G1_DMA_Config);
 		break;
 	case NITIO_G0_ABZ:
-		devpriv->writew(dev, bits, M_Offset_G0_MSeries_ABZ);
+		ni_writew(dev, bits, M_Offset_G0_MSeries_ABZ);
 		break;
 	case NITIO_G1_ABZ:
-		devpriv->writew(dev, bits, M_Offset_G1_MSeries_ABZ);
+		ni_writew(dev, bits, M_Offset_G1_MSeries_ABZ);
 		break;
 
 		/* 32 bit registers */
@@ -3875,15 +3896,14 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 				      enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
-	struct ni_private *devpriv = dev->private;
 	unsigned stc_register;
 
 	switch (reg) {
 		/* m-series only registers */
 	case NITIO_G0_DMA_STATUS:
-		return devpriv->readw(dev, M_Offset_G0_DMA_Status);
+		return ni_readw(dev, M_Offset_G0_DMA_Status);
 	case NITIO_G1_DMA_STATUS:
-		return devpriv->readw(dev, M_Offset_G1_DMA_Status);
+		return ni_readw(dev, M_Offset_G1_DMA_Status);
 
 		/* 32 bit registers */
 	case NITIO_G0_HW_SAVE:
@@ -3980,13 +4000,12 @@ static int ni_freq_out_insn_config(struct comedi_device *dev,
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 {
 	struct comedi_device *dev = (struct comedi_device *)arg;
-	struct ni_private *devpriv = dev->private;
 
 	if (dir) {
-		devpriv->writeb(dev, data, Port_A + 2 * port);
+		ni_writeb(dev, data, Port_A + 2 * port);
 		return 0;
 	} else {
-		return devpriv->readb(dev, Port_A + 2 * port);
+		return ni_readb(dev, Port_A + 2 * port);
 	}
 }
 
@@ -4051,9 +4070,9 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 			data[4] = down_count * devpriv->clock_ns;
 			return -EAGAIN;
 		}
-		devpriv->writel(dev, MSeries_Cal_PWM_High_Time_Bits(up_count) |
-				     MSeries_Cal_PWM_Low_Time_Bits(down_count),
-				M_Offset_Cal_PWM);
+		ni_writel(dev, MSeries_Cal_PWM_High_Time_Bits(up_count) |
+			       MSeries_Cal_PWM_Low_Time_Bits(down_count),
+			  M_Offset_Cal_PWM);
 		devpriv->pwm_up_count = up_count;
 		devpriv->pwm_down_count = down_count;
 		return 5;
@@ -4120,9 +4139,9 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 			data[4] = down_count * devpriv->clock_ns;
 			return -EAGAIN;
 		}
-		devpriv->writel(dev, up_count, Calibration_HighTime_6143);
+		ni_writel(dev, up_count, Calibration_HighTime_6143);
 		devpriv->pwm_up_count = up_count;
-		devpriv->writel(dev, down_count, Calibration_LowTime_6143);
+		ni_writel(dev, down_count, Calibration_LowTime_6143);
 		devpriv->pwm_down_count = down_count;
 		return 5;
 		break;
@@ -4226,16 +4245,15 @@ static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 	}
 
 	for (bit = 1 << (bits - 1); bit; bit >>= 1) {
-		devpriv->writeb(dev, ((bit & bitstring) ? 0x02 : 0),
-				Serial_Command);
+		ni_writeb(dev, ((bit & bitstring) ? 0x02 : 0), Serial_Command);
 		udelay(1);
-		devpriv->writeb(dev, 1 | ((bit & bitstring) ? 0x02 : 0),
-				Serial_Command);
+		ni_writeb(dev, 1 | ((bit & bitstring) ? 0x02 : 0),
+			  Serial_Command);
 		udelay(1);
 	}
-	devpriv->writeb(dev, loadbit, Serial_Command);
+	ni_writeb(dev, loadbit, Serial_Command);
 	udelay(1);
-	devpriv->writeb(dev, 0, Serial_Command);
+	ni_writeb(dev, 0, Serial_Command);
 }
 
 static int ni_calib_insn_write(struct comedi_device *dev,
@@ -4316,26 +4334,24 @@ static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int ni_read_eeprom(struct comedi_device *dev, int addr)
 {
-	struct ni_private *devpriv = dev->private;
 	int bit;
 	int bitstring;
 
 	bitstring = 0x0300 | ((addr & 0x100) << 3) | (addr & 0xff);
-	devpriv->writeb(dev, 0x04, Serial_Command);
+	ni_writeb(dev, 0x04, Serial_Command);
 	for (bit = 0x8000; bit; bit >>= 1) {
-		devpriv->writeb(dev, 0x04 | ((bit & bitstring) ? 0x02 : 0),
-				Serial_Command);
-		devpriv->writeb(dev, 0x05 | ((bit & bitstring) ? 0x02 : 0),
-				Serial_Command);
+		ni_writeb(dev, 0x04 | ((bit & bitstring) ? 0x02 : 0),
+			  Serial_Command);
+		ni_writeb(dev, 0x05 | ((bit & bitstring) ? 0x02 : 0),
+			  Serial_Command);
 	}
 	bitstring = 0;
 	for (bit = 0x80; bit; bit >>= 1) {
-		devpriv->writeb(dev, 0x04, Serial_Command);
-		devpriv->writeb(dev, 0x05, Serial_Command);
-		bitstring |= ((devpriv->readb(dev, XXX_Status) & PROMOUT)
-				? bit : 0);
+		ni_writeb(dev, 0x04, Serial_Command);
+		ni_writeb(dev, 0x05, Serial_Command);
+		bitstring |= ((ni_readb(dev, XXX_Status) & PROMOUT) ? bit : 0);
 	}
-	devpriv->writeb(dev, 0x00, Serial_Command);
+	ni_writeb(dev, 0x00, Serial_Command);
 
 	return bitstring;
 }
@@ -4438,8 +4454,8 @@ static int ni_m_series_set_pfi_routing(struct comedi_device *dev,
 	    ~MSeries_PFI_Output_Select_Mask(chan);
 	devpriv->pfi_output_select_reg[array_offset] |=
 	    MSeries_PFI_Output_Select_Bits(chan, source);
-	devpriv->writew(dev, devpriv->pfi_output_select_reg[array_offset],
-			M_Offset_PFI_Output_Select(pfi_reg_index));
+	ni_writew(dev, devpriv->pfi_output_select_reg[array_offset],
+		  M_Offset_PFI_Output_Select(pfi_reg_index));
 	return 2;
 }
 
@@ -4474,10 +4490,10 @@ static int ni_config_filter(struct comedi_device *dev,
 	if (!devpriv->is_m_series)
 		return -ENOTSUPP;
 
-	bits = devpriv->readl(dev, M_Offset_PFI_Filter);
+	bits = ni_readl(dev, M_Offset_PFI_Filter);
 	bits &= ~MSeries_PFI_Filter_Select_Mask(pfi_channel);
 	bits |= MSeries_PFI_Filter_Select_Bits(pfi_channel, filter);
-	devpriv->writel(dev, bits, M_Offset_PFI_Filter);
+	ni_writel(dev, bits, M_Offset_PFI_Filter);
 	return 0;
 }
 
@@ -4533,9 +4549,9 @@ static int ni_pfi_insn_bits(struct comedi_device *dev,
 		return -ENOTSUPP;
 
 	if (comedi_dio_update_state(s, data))
-		devpriv->writew(dev, s->state, M_Offset_PFI_DO);
+		ni_writew(dev, s->state, M_Offset_PFI_DO);
 
-	data[1] = devpriv->readw(dev, M_Offset_PFI_DI);
+	data[1] = ni_readw(dev, M_Offset_PFI_DI);
 
 	return insn->n;
 }
@@ -4800,8 +4816,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 		}
 		break;
 	}
-	devpriv->writew(dev, devpriv->clock_and_fout2,
-			M_Offset_Clock_and_Fout2);
+	ni_writew(dev, devpriv->clock_and_fout2, M_Offset_Clock_and_Fout2);
 	pll_control_bits |=
 	    MSeries_PLL_Divisor_Bits(freq_divider) |
 	    MSeries_PLL_Multiplier_Bits(freq_multiplier);
@@ -4809,12 +4824,11 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 	/* printk("using divider=%i, multiplier=%i for PLL. pll_control_bits = 0x%x\n",
 	 * freq_divider, freq_multiplier, pll_control_bits); */
 	/* printk("clock_ns=%d\n", devpriv->clock_ns); */
-	devpriv->writew(dev, pll_control_bits, M_Offset_PLL_Control);
+	ni_writew(dev, pll_control_bits, M_Offset_PLL_Control);
 	devpriv->clock_source = source;
 	/* it seems to typically take a few hundred microseconds for PLL to lock */
 	for (i = 0; i < timeout; ++i) {
-		if (devpriv->readw(dev, M_Offset_PLL_Status) &
-		    MSeries_PLL_Locked_Bit)
+		if (ni_readw(dev, M_Offset_PLL_Status) & MSeries_PLL_Locked_Bit)
 			break;
 		udelay(1);
 	}
@@ -4841,9 +4855,9 @@ static int ni_set_master_clock(struct comedi_device *dev,
 			devpriv->clock_and_fout2 &=
 			    ~(MSeries_Timebase1_Select_Bit |
 			      MSeries_Timebase3_Select_Bit);
-			devpriv->writew(dev, devpriv->clock_and_fout2,
-					M_Offset_Clock_and_Fout2);
-			devpriv->writew(dev, 0, M_Offset_PLL_Control);
+			ni_writew(dev, devpriv->clock_and_fout2,
+				  M_Offset_Clock_and_Fout2);
+			ni_writew(dev, 0, M_Offset_PLL_Control);
 		}
 		devpriv->clock_source = source;
 	} else {
@@ -5382,15 +5396,14 @@ static int ni_E_init(struct comedi_device *dev)
 		s->async_dma_dir = DMA_BIDIRECTIONAL;
 		s->len_chanlist = s->n_chan;
 
-		devpriv->writel(dev, CDO_Reset_Bit | CDI_Reset_Bit,
-				M_Offset_CDIO_Command);
-		devpriv->writel(dev, s->io_bits, M_Offset_DIO_Direction);
+		ni_writel(dev, CDO_Reset_Bit | CDI_Reset_Bit,
+			  M_Offset_CDIO_Command);
+		ni_writel(dev, s->io_bits, M_Offset_DIO_Direction);
 	} else {
 		s->insn_bits = &ni_dio_insn_bits;
 		s->insn_config = &ni_dio_insn_config;
 		devpriv->dio_control = DIO_Pins_Dir(s->io_bits);
-		devpriv->writew(dev, devpriv->dio_control,
-				DIO_Control_Register);
+		ni_writew(dev, devpriv->dio_control, DIO_Control_Register);
 	}
 
 	/* 8255 device */
@@ -5417,7 +5430,7 @@ static int ni_E_init(struct comedi_device *dev)
 		s->insn_config = &ni_m_series_pwm_config;
 		s->n_chan = 1;
 		s->maxdata = 0;
-		devpriv->writel(dev, 0x0, M_Offset_Cal_PWM);
+		ni_writel(dev, 0x0, M_Offset_Cal_PWM);
 	} else if (board->reg_type == ni_reg_6143) {
 		/*  internal PWM analog output used for AI nonlinearity calibration */
 		s->subdev_flags = SDF_INTERNAL;
@@ -5451,10 +5464,10 @@ static int ni_E_init(struct comedi_device *dev)
 	if (devpriv->is_m_series) {
 		unsigned i;
 		s->n_chan = 16;
-		devpriv->writew(dev, s->state, M_Offset_PFI_DO);
+		ni_writew(dev, s->state, M_Offset_PFI_DO);
 		for (i = 0; i < NUM_PFI_OUTPUT_SELECT_REGS; ++i) {
-			devpriv->writew(dev, devpriv->pfi_output_select_reg[i],
-					M_Offset_PFI_Output_Select(i + 1));
+			ni_writew(dev, devpriv->pfi_output_select_reg[i],
+				  M_Offset_PFI_Output_Select(i + 1));
 		}
 	} else {
 		s->n_chan = 10;
@@ -5585,20 +5598,20 @@ static int ni_E_init(struct comedi_device *dev)
 	}
 
 	/* DMA setup */
-	devpriv->writeb(dev, devpriv->ai_ao_select_reg, AI_AO_Select);
-	devpriv->writeb(dev, devpriv->g0_g1_select_reg, G0_G1_Select);
+	ni_writeb(dev, devpriv->ai_ao_select_reg, AI_AO_Select);
+	ni_writeb(dev, devpriv->g0_g1_select_reg, G0_G1_Select);
 
 	if (board->reg_type & ni_reg_6xxx_mask) {
-		devpriv->writeb(dev, 0, Magic_611x);
+		ni_writeb(dev, 0, Magic_611x);
 	} else if (devpriv->is_m_series) {
 		int channel;
 		for (channel = 0; channel < board->n_aochan; ++channel) {
-			devpriv->writeb(dev, 0xf,
-					M_Offset_AO_Waveform_Order(channel));
-			devpriv->writeb(dev, 0x0,
-					M_Offset_AO_Reference_Attenuation(channel));
+			ni_writeb(dev, 0xf,
+				  M_Offset_AO_Waveform_Order(channel));
+			ni_writeb(dev, 0x0,
+				  M_Offset_AO_Reference_Attenuation(channel));
 		}
-		devpriv->writeb(dev, 0x0, M_Offset_AO_Calibration);
+		ni_writeb(dev, 0x0, M_Offset_AO_Calibration);
 	}
 
 	return 0;

commit 00b14b1dfb79cffaf53c5a05e13af644641cdc21
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 19 10:20:34 2014 -0700

    staging: comedi: ni_mio_common.c: wrap the stc_read/write operations
    
    The ni_atmio, ni_pcimio, and ni_mio_cs drivers all include this source
    file to handle the common functionality of the drivers. Each of those
    drivers set some function pointers in the private data to handle the
    read/write operations to the stc registers.
    
    Wrap these operations with some helper functions to clarify the code
    a bit and make it easier to read and maintain.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index aa1ee9624ce0..e54c016ea6a4 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -246,6 +246,34 @@ enum timebase_nanoseconds {
 
 static const int num_adc_stages_611x = 3;
 
+static void ni_stc_writel(struct comedi_device *dev, uint32_t data, int reg)
+{
+	struct ni_private *devpriv = dev->private;
+
+	devpriv->stc_writel(dev, data, reg);
+}
+
+static void ni_stc_writew(struct comedi_device *dev, uint16_t data, int reg)
+{
+	struct ni_private *devpriv = dev->private;
+
+	devpriv->stc_writew(dev, data, reg);
+}
+
+static uint32_t ni_stc_readl(struct comedi_device *dev, int reg)
+{
+	struct ni_private *devpriv = dev->private;
+
+	return devpriv->stc_readl(dev, reg);
+}
+
+static uint16_t ni_stc_readw(struct comedi_device *dev, int reg)
+{
+	struct ni_private *devpriv = dev->private;
+
+	return devpriv->stc_readw(dev, reg);
+}
+
 static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 				   unsigned bit_mask, unsigned bit_values)
 {
@@ -257,20 +285,20 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 	case Interrupt_A_Enable_Register:
 		devpriv->int_a_enable_reg &= ~bit_mask;
 		devpriv->int_a_enable_reg |= bit_values & bit_mask;
-		devpriv->stc_writew(dev, devpriv->int_a_enable_reg,
-				    Interrupt_A_Enable_Register);
+		ni_stc_writew(dev, devpriv->int_a_enable_reg,
+			      Interrupt_A_Enable_Register);
 		break;
 	case Interrupt_B_Enable_Register:
 		devpriv->int_b_enable_reg &= ~bit_mask;
 		devpriv->int_b_enable_reg |= bit_values & bit_mask;
-		devpriv->stc_writew(dev, devpriv->int_b_enable_reg,
-				    Interrupt_B_Enable_Register);
+		ni_stc_writew(dev, devpriv->int_b_enable_reg,
+			      Interrupt_B_Enable_Register);
 		break;
 	case IO_Bidirection_Pin_Register:
 		devpriv->io_bidirection_pin_reg &= ~bit_mask;
 		devpriv->io_bidirection_pin_reg |= bit_values & bit_mask;
-		devpriv->stc_writew(dev, devpriv->io_bidirection_pin_reg,
-				    IO_Bidirection_Pin_Register);
+		ni_stc_writew(dev, devpriv->io_bidirection_pin_reg,
+			      IO_Bidirection_Pin_Register);
 		break;
 	case AI_AO_Select:
 		devpriv->ai_ao_select_reg &= ~bit_mask;
@@ -551,7 +579,7 @@ static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 		if (enable)
 			val = G1_Gate_Second_Irq_Enable;
 	}
-	devpriv->stc_writew(dev, val, reg);
+	ni_stc_writew(dev, val, reg);
 }
 #endif /*  PCIDMA */
 
@@ -576,19 +604,19 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 			comedi_error(dev, "FIFO flush timeout.");
 		}
 	} else {
-		devpriv->stc_writew(dev, 1, ADC_FIFO_Clear);
+		ni_stc_writew(dev, 1, ADC_FIFO_Clear);
 		if (board->reg_type == ni_reg_625x) {
 			devpriv->writeb(dev, 0, M_Offset_Static_AI_Control(0));
 			devpriv->writeb(dev, 1, M_Offset_Static_AI_Control(0));
 #if 0
 			/* the NI example code does 3 convert pulses for 625x boards,
 			   but that appears to be wrong in practice. */
-			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-					    AI_Command_1_Register);
-			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-					    AI_Command_1_Register);
-			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-					    AI_Command_1_Register);
+			ni_stc_writew(dev, AI_CONVERT_Pulse,
+				      AI_Command_1_Register);
+			ni_stc_writew(dev, AI_CONVERT_Pulse,
+				      AI_Command_1_Register);
+			ni_stc_writew(dev, AI_CONVERT_Pulse,
+				      AI_Command_1_Register);
 #endif
 		}
 	}
@@ -596,19 +624,16 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 
 static void win_out2(struct comedi_device *dev, uint32_t data, int reg)
 {
-	struct ni_private *devpriv = dev->private;
-
-	devpriv->stc_writew(dev, data >> 16, reg);
-	devpriv->stc_writew(dev, data & 0xffff, reg + 1);
+	ni_stc_writew(dev, data >> 16, reg);
+	ni_stc_writew(dev, data & 0xffff, reg + 1);
 }
 
 static uint32_t win_in2(struct comedi_device *dev, int reg)
 {
-	struct ni_private *devpriv = dev->private;
 	uint32_t bits;
 
-	bits = devpriv->stc_readw(dev, reg) << 16;
-	bits |= devpriv->stc_readw(dev, reg + 1);
+	bits = ni_stc_readw(dev, reg) << 16;
+	bits |= ni_stc_readw(dev, reg + 1);
 	return bits;
 }
 
@@ -696,8 +721,7 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ai_mite_chan) {
 		for (i = 0; i < timeout; i++) {
-			if ((devpriv->stc_readw(dev,
-						AI_Status_1_Register) &
+			if ((ni_stc_readw(dev, AI_Status_1_Register) &
 			     AI_FIFO_Empty_St)
 			    && mite_bytes_in_transit(devpriv->ai_mite_chan) ==
 			    0)
@@ -709,7 +733,7 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 			printk
 			    ("mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
 			     mite_bytes_in_transit(devpriv->ai_mite_chan),
-			     devpriv->stc_readw(dev, AI_Status_1_Register));
+			     ni_stc_readw(dev, AI_Status_1_Register));
 			retval = -1;
 		}
 	}
@@ -735,13 +759,12 @@ static void mite_handle_b_linkc(struct mite_struct *mite,
 
 static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 {
-	struct ni_private *devpriv = dev->private;
 	static const int timeout = 10000;
 	int i;
 	for (i = 0; i < timeout; i++) {
 		unsigned short b_status;
 
-		b_status = devpriv->stc_readw(dev, AO_Status_1_Register);
+		b_status = ni_stc_readw(dev, AO_Status_1_Register);
 		if (b_status & AO_FIFO_Half_Full_St)
 			break;
 		/* if we poll too often, the pci bus activity seems
@@ -846,11 +869,10 @@ static int ni_ao_prep_fifo(struct comedi_device *dev,
 			   struct comedi_subdevice *s)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
 	int n;
 
 	/* reset fifo */
-	devpriv->stc_writew(dev, 1, DAC_FIFO_Clear);
+	ni_stc_writew(dev, 1, DAC_FIFO_Clear);
 	if (board->reg_type & ni_reg_6xxx_mask)
 		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
 
@@ -956,8 +978,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 	int i;
 
 	if (board->reg_type == ni_reg_611x) {
-		while ((devpriv->stc_readw(dev,
-					   AI_Status_1_Register) &
+		while ((ni_stc_readw(dev, AI_Status_1_Register) &
 			AI_FIFO_Empty_St) == 0) {
 			dl = devpriv->readl(dev, ADC_FIFO_Data_611x);
 
@@ -987,18 +1008,16 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 		}
 
 	} else {
-		fifo_empty =
-		    devpriv->stc_readw(dev,
-				       AI_Status_1_Register) & AI_FIFO_Empty_St;
+		fifo_empty = ni_stc_readw(dev, AI_Status_1_Register) &
+			     AI_FIFO_Empty_St;
 		while (fifo_empty == 0) {
 			for (i = 0;
 			     i <
 			     sizeof(devpriv->ai_fifo_buffer) /
 			     sizeof(devpriv->ai_fifo_buffer[0]); i++) {
-				fifo_empty =
-				    devpriv->stc_readw(dev,
-						       AI_Status_1_Register) &
-				    AI_FIFO_Empty_St;
+				fifo_empty = ni_stc_readw(dev,
+							  AI_Status_1_Register) &
+						AI_FIFO_Empty_St;
 				if (fifo_empty)
 					break;
 				devpriv->ai_fifo_buffer[i] =
@@ -1110,7 +1129,6 @@ static void handle_gpct_interrupt(struct comedi_device *dev,
 
 static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 {
-	struct ni_private *devpriv = dev->private;
 	unsigned short ack = 0;
 
 	if (a_status & AI_SC_TC_St)
@@ -1123,7 +1141,7 @@ static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 		/* not sure why we used to ack the START here also, instead of doing it independently. Frank Hess 2007-07-06 */
 		ack |= AI_STOP_Interrupt_Ack /*| AI_START_Interrupt_Ack */;
 	if (ack)
-		devpriv->stc_writew(dev, ack, Interrupt_A_Ack_Register);
+		ni_stc_writew(dev, ack, Interrupt_A_Ack_Register);
 }
 
 static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
@@ -1193,8 +1211,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 		 *fail to get the fifo less than half full, so loop to be sure.*/
 		for (i = 0; i < timeout; ++i) {
 			ni_handle_fifo_half_full(dev);
-			if ((devpriv->stc_readw(dev,
-						AI_Status_1_Register) &
+			if ((ni_stc_readw(dev, AI_Status_1_Register) &
 			     AI_FIFO_Half_Full_St) == 0)
 				break;
 		}
@@ -1209,7 +1226,6 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 
 static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
 {
-	struct ni_private *devpriv = dev->private;
 	unsigned short ack = 0;
 
 	if (b_status & AO_BC_TC_St)
@@ -1227,20 +1243,22 @@ static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
 	if (b_status & AO_UPDATE_St)
 		ack |= AO_UPDATE_Interrupt_Ack;
 	if (ack)
-		devpriv->stc_writew(dev, ack, Interrupt_B_Ack_Register);
+		ni_stc_writew(dev, ack, Interrupt_B_Ack_Register);
 }
 
 static void handle_b_interrupt(struct comedi_device *dev,
 			       unsigned short b_status, unsigned ao_mite_status)
 {
-	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->write_subdev;
 	/* unsigned short ack=0; */
 
 #ifdef PCIDMA
 	/* Currently, mite.c requires us to handle LINKC */
-	if (ao_mite_status & CHSR_LINKC)
+	if (ao_mite_status & CHSR_LINKC) {
+		struct ni_private *devpriv = dev->private;
+
 		mite_handle_b_linkc(devpriv->mite, dev);
+	}
 
 	if (ao_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
 			       CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
@@ -1257,7 +1275,7 @@ static void handle_b_interrupt(struct comedi_device *dev,
 	if (b_status & AO_Overrun_St) {
 		printk
 		    ("ni_mio_common: AO FIFO underrun status=0x%04x status2=0x%04x\n",
-		     b_status, devpriv->stc_readw(dev, AO_Status_2_Register));
+		     b_status, ni_stc_readw(dev, AO_Status_2_Register));
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 
@@ -1400,8 +1418,8 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	ni_release_ai_mite_channel(dev);
 	/* ai configuration */
-	devpriv->stc_writew(dev, AI_Configuration_Start | AI_Reset,
-			    Joint_Reset_Register);
+	ni_stc_writew(dev, AI_Configuration_Start | AI_Reset,
+		      Joint_Reset_Register);
 
 	ni_set_bits(dev, Interrupt_A_Enable_Register,
 		    AI_SC_TC_Interrupt_Enable | AI_START1_Interrupt_Enable |
@@ -1414,47 +1432,48 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (board->reg_type != ni_reg_6143)
 		devpriv->writeb(dev, 0, Misc_Command);
 
-	devpriv->stc_writew(dev, AI_Disarm, AI_Command_1_Register);	/* reset pulses */
-	devpriv->stc_writew(dev,
-			    AI_Start_Stop | AI_Mode_1_Reserved
-			    /*| AI_Trigger_Once */ ,
-			    AI_Mode_1_Register);
-	devpriv->stc_writew(dev, 0x0000, AI_Mode_2_Register);
+	ni_stc_writew(dev, AI_Disarm, AI_Command_1_Register); /* reset pulses */
+	ni_stc_writew(dev, AI_Start_Stop | AI_Mode_1_Reserved
+			    /*| AI_Trigger_Once */,
+		      AI_Mode_1_Register);
+	ni_stc_writew(dev, 0x0000, AI_Mode_2_Register);
 	/* generate FIFO interrupts on non-empty */
-	devpriv->stc_writew(dev, (0 << 6) | 0x0000, AI_Mode_3_Register);
+	ni_stc_writew(dev, (0 << 6) | 0x0000, AI_Mode_3_Register);
 	if (board->reg_type == ni_reg_611x) {
-		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
-				    AI_SOC_Polarity |
-				    AI_LOCALMUX_CLK_Pulse_Width,
-				    AI_Personal_Register);
-		devpriv->stc_writew(dev,
-				    AI_SCAN_IN_PROG_Output_Select(3) |
-				    AI_EXTMUX_CLK_Output_Select(0) |
-				    AI_LOCALMUX_CLK_Output_Select(2) |
-				    AI_SC_TC_Output_Select(3) |
-				    AI_CONVERT_Output_Select
-				    (AI_CONVERT_Output_Enable_High),
-				    AI_Output_Control_Register);
+		ni_stc_writew(dev,
+			      AI_SHIFTIN_Pulse_Width |
+			      AI_SOC_Polarity |
+			      AI_LOCALMUX_CLK_Pulse_Width,
+			      AI_Personal_Register);
+		ni_stc_writew(dev,
+			      AI_SCAN_IN_PROG_Output_Select(3) |
+			      AI_EXTMUX_CLK_Output_Select(0) |
+			      AI_LOCALMUX_CLK_Output_Select(2) |
+			      AI_SC_TC_Output_Select(3) |
+			      AI_CONVERT_Output_Select
+			      (AI_CONVERT_Output_Enable_High),
+			      AI_Output_Control_Register);
 	} else if (board->reg_type == ni_reg_6143) {
-		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
-				    AI_SOC_Polarity |
-				    AI_LOCALMUX_CLK_Pulse_Width,
-				    AI_Personal_Register);
-		devpriv->stc_writew(dev,
-				    AI_SCAN_IN_PROG_Output_Select(3) |
-				    AI_EXTMUX_CLK_Output_Select(0) |
-				    AI_LOCALMUX_CLK_Output_Select(2) |
-				    AI_SC_TC_Output_Select(3) |
-				    AI_CONVERT_Output_Select
-				    (AI_CONVERT_Output_Enable_Low),
-				    AI_Output_Control_Register);
+		ni_stc_writew(dev, AI_SHIFTIN_Pulse_Width |
+				   AI_SOC_Polarity |
+				   AI_LOCALMUX_CLK_Pulse_Width,
+			      AI_Personal_Register);
+		ni_stc_writew(dev,
+			      AI_SCAN_IN_PROG_Output_Select(3) |
+			      AI_EXTMUX_CLK_Output_Select(0) |
+			      AI_LOCALMUX_CLK_Output_Select(2) |
+			      AI_SC_TC_Output_Select(3) |
+			      AI_CONVERT_Output_Select
+			      (AI_CONVERT_Output_Enable_Low),
+			      AI_Output_Control_Register);
 	} else {
 		unsigned ai_output_control_bits;
-		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
-				    AI_SOC_Polarity |
-				    AI_CONVERT_Pulse_Width |
-				    AI_LOCALMUX_CLK_Pulse_Width,
-				    AI_Personal_Register);
+		ni_stc_writew(dev,
+			      AI_SHIFTIN_Pulse_Width |
+			      AI_SOC_Polarity |
+			      AI_CONVERT_Pulse_Width |
+			      AI_LOCALMUX_CLK_Pulse_Width,
+			      AI_Personal_Register);
 		ai_output_control_bits =
 		    AI_SCAN_IN_PROG_Output_Select(3) |
 		    AI_EXTMUX_CLK_Output_Select(0) |
@@ -1468,8 +1487,8 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 			ai_output_control_bits |=
 			    AI_CONVERT_Output_Select
 			    (AI_CONVERT_Output_Enable_Low);
-		devpriv->stc_writew(dev, ai_output_control_bits,
-				    AI_Output_Control_Register);
+		ni_stc_writew(dev, ai_output_control_bits,
+			      AI_Output_Control_Register);
 	}
 	/* the following registers should not be changed, because there
 	 * are no backup registers in devpriv.  If you want to change
@@ -1479,9 +1498,17 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	 *      AI_Personal_Register
 	 *      AI_Output_Control_Register
 	 */
-	devpriv->stc_writew(dev, AI_SC_TC_Error_Confirm | AI_START_Interrupt_Ack | AI_START2_Interrupt_Ack | AI_START1_Interrupt_Ack | AI_SC_TC_Interrupt_Ack | AI_Error_Interrupt_Ack | AI_STOP_Interrupt_Ack, Interrupt_A_Ack_Register);	/* clear interrupts */
-
-	devpriv->stc_writew(dev, AI_Configuration_End, Joint_Reset_Register);
+	ni_stc_writew(dev,
+		      AI_SC_TC_Error_Confirm |
+		      AI_START_Interrupt_Ack |
+		      AI_START2_Interrupt_Ack |
+		      AI_START1_Interrupt_Ack |
+		      AI_SC_TC_Interrupt_Ack |
+		      AI_Error_Interrupt_Ack |
+		      AI_STOP_Interrupt_Ack,
+		      Interrupt_A_Ack_Register);	/* clear interrupts */
+
+	ni_stc_writew(dev, AI_Configuration_End, Joint_Reset_Register);
 
 	return 0;
 }
@@ -1506,15 +1533,13 @@ static int ni_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static void ni_prime_channelgain_list(struct comedi_device *dev)
 {
-	struct ni_private *devpriv = dev->private;
 	int i;
 
-	devpriv->stc_writew(dev, AI_CONVERT_Pulse, AI_Command_1_Register);
+	ni_stc_writew(dev, AI_CONVERT_Pulse, AI_Command_1_Register);
 	for (i = 0; i < NI_TIMEOUT; ++i) {
-		if (!(devpriv->stc_readw(dev,
-					 AI_Status_1_Register) &
+		if (!(ni_stc_readw(dev, AI_Status_1_Register) &
 		      AI_FIFO_Empty_St)) {
-			devpriv->stc_writew(dev, 1, ADC_FIFO_Clear);
+			ni_stc_writew(dev, 1, ADC_FIFO_Clear);
 			return;
 		}
 		udelay(1);
@@ -1534,7 +1559,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 	unsigned int dither;
 	unsigned range_code;
 
-	devpriv->stc_writew(dev, 1, Configuration_Memory_Clear);
+	ni_stc_writew(dev, 1, Configuration_Memory_Clear);
 
 /* offset = 1 << (board->adbits - 1); */
 	if ((list[0] & CR_ALT_SOURCE)) {
@@ -1659,7 +1684,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		devpriv->changain_state = 0;
 	}
 
-	devpriv->stc_writew(dev, 1, Configuration_Memory_Clear);
+	ni_stc_writew(dev, 1, Configuration_Memory_Clear);
 
 	/*  Set up Calibration mode if required */
 	if (board->reg_type == ni_reg_6143) {
@@ -1771,13 +1796,13 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 	signbits = devpriv->ai_offset[0];
 	if (board->reg_type == ni_reg_611x) {
 		for (n = 0; n < num_adc_stages_611x; n++) {
-			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-					    AI_Command_1_Register);
+			ni_stc_writew(dev, AI_CONVERT_Pulse,
+				      AI_Command_1_Register);
 			udelay(1);
 		}
 		for (n = 0; n < insn->n; n++) {
-			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-					    AI_Command_1_Register);
+			ni_stc_writew(dev, AI_CONVERT_Pulse,
+				      AI_Command_1_Register);
 			/* The 611x has screwy 32-bit FIFOs. */
 			d = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
@@ -1788,8 +1813,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 					d &= 0xffff;
 					break;
 				}
-				if (!(devpriv->stc_readw(dev,
-							 AI_Status_1_Register) &
+				if (!(ni_stc_readw(dev, AI_Status_1_Register) &
 				      AI_FIFO_Empty_St)) {
 					d = devpriv->readl(dev,
 							   ADC_FIFO_Data_611x);
@@ -1807,8 +1831,8 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 		}
 	} else if (board->reg_type == ni_reg_6143) {
 		for (n = 0; n < insn->n; n++) {
-			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-					    AI_Command_1_Register);
+			ni_stc_writew(dev, AI_CONVERT_Pulse,
+				      AI_Command_1_Register);
 
 			/* The 6143 has 32-bit FIFOs. You need to strobe a bit to move a single 16bit stranded sample into the FIFO */
 			dl = 0;
@@ -1832,11 +1856,10 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 		}
 	} else {
 		for (n = 0; n < insn->n; n++) {
-			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-					    AI_Command_1_Register);
+			ni_stc_writew(dev, AI_CONVERT_Pulse,
+				      AI_Command_1_Register);
 			for (i = 0; i < NI_TIMEOUT; i++) {
-				if (!(devpriv->stc_readw(dev,
-							 AI_Status_1_Register) &
+				if (!(ni_stc_readw(dev, AI_Status_1_Register) &
 				      AI_FIFO_Empty_St))
 					break;
 			}
@@ -2072,8 +2095,8 @@ static int ni_ai_inttrig(struct comedi_device *dev,
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
-	devpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
-			    AI_Command_2_Register);
+	ni_stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
+		      AI_Command_2_Register);
 	s->async->inttrig = NULL;
 
 	return 1;
@@ -2100,21 +2123,22 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_load_channelgain_list(dev, cmd->chanlist_len, cmd->chanlist);
 
 	/* start configuration */
-	devpriv->stc_writew(dev, AI_Configuration_Start, Joint_Reset_Register);
+	ni_stc_writew(dev, AI_Configuration_Start, Joint_Reset_Register);
 
 	/* disable analog triggering for now, since it
 	 * interferes with the use of pfi0 */
 	devpriv->an_trig_etc_reg &= ~Analog_Trigger_Enable;
-	devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
-			    Analog_Trigger_Etc_Register);
+	ni_stc_writew(dev, devpriv->an_trig_etc_reg,
+		      Analog_Trigger_Etc_Register);
 
 	switch (cmd->start_src) {
 	case TRIG_INT:
 	case TRIG_NOW:
-		devpriv->stc_writew(dev, AI_START2_Select(0) |
-				    AI_START1_Sync | AI_START1_Edge |
-				    AI_START1_Select(0),
-				    AI_Trigger_Select_Register);
+		ni_stc_writew(dev,
+			      AI_START2_Select(0) |
+			      AI_START1_Sync | AI_START1_Edge |
+			      AI_START1_Select(0),
+			      AI_Trigger_Select_Register);
 		break;
 	case TRIG_EXT:
 		{
@@ -2126,8 +2150,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				bits |= AI_START1_Polarity;
 			if (cmd->start_arg & CR_EDGE)
 				bits |= AI_START1_Edge;
-			devpriv->stc_writew(dev, bits,
-					    AI_Trigger_Select_Register);
+			ni_stc_writew(dev, bits, AI_Trigger_Select_Register);
 			break;
 		}
 	}
@@ -2135,7 +2158,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	mode2 &= ~AI_Pre_Trigger;
 	mode2 &= ~AI_SC_Initial_Load_Source;
 	mode2 &= ~AI_SC_Reload_Mode;
-	devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
+	ni_stc_writew(dev, mode2, AI_Mode_2_Register);
 
 	if (cmd->chanlist_len == 1 || (board->reg_type == ni_reg_611x)
 	    || (board->reg_type == ni_reg_6143)) {
@@ -2145,8 +2168,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	} else {
 		start_stop_select |= AI_STOP_Select(19);	/*  ai configuration memory */
 	}
-	devpriv->stc_writew(dev, start_stop_select,
-			    AI_START_STOP_Select_Register);
+	ni_stc_writew(dev, start_stop_select, AI_START_STOP_Select_Register);
 
 	devpriv->ai_cmd2 = 0;
 	switch (cmd->stop_src) {
@@ -2158,12 +2180,12 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			stop_count += num_adc_stages_611x;
 		}
 		/* stage number of scans */
-		devpriv->stc_writel(dev, stop_count, AI_SC_Load_A_Registers);
+		ni_stc_writel(dev, stop_count, AI_SC_Load_A_Registers);
 
 		mode1 |= AI_Start_Stop | AI_Mode_1_Reserved | AI_Trigger_Once;
-		devpriv->stc_writew(dev, mode1, AI_Mode_1_Register);
+		ni_stc_writew(dev, mode1, AI_Mode_1_Register);
 		/* load SC (Scan Count) */
-		devpriv->stc_writew(dev, AI_SC_Load, AI_Command_1_Register);
+		ni_stc_writew(dev, AI_SC_Load, AI_Command_1_Register);
 
 		devpriv->ai_continuous = 0;
 		if (stop_count == 0) {
@@ -2177,13 +2199,13 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	case TRIG_NONE:
 		/* stage number of scans */
-		devpriv->stc_writel(dev, 0, AI_SC_Load_A_Registers);
+		ni_stc_writel(dev, 0, AI_SC_Load_A_Registers);
 
 		mode1 |= AI_Start_Stop | AI_Mode_1_Reserved | AI_Continuous;
-		devpriv->stc_writew(dev, mode1, AI_Mode_1_Register);
+		ni_stc_writew(dev, mode1, AI_Mode_1_Register);
 
 		/* load SC (Scan Count) */
-		devpriv->stc_writew(dev, AI_SC_Load, AI_Command_1_Register);
+		ni_stc_writew(dev, AI_SC_Load, AI_Command_1_Register);
 
 		devpriv->ai_continuous = 1;
 
@@ -2207,20 +2229,20 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		   AI_STOP_Select=19            external pin (configuration mem)
 		 */
 		start_stop_select |= AI_START_Edge | AI_START_Sync;
-		devpriv->stc_writew(dev, start_stop_select,
-				    AI_START_STOP_Select_Register);
+		ni_stc_writew(dev, start_stop_select,
+			      AI_START_STOP_Select_Register);
 
 		mode2 |= AI_SI_Reload_Mode(0);
 		/* AI_SI_Initial_Load_Source=A */
 		mode2 &= ~AI_SI_Initial_Load_Source;
 		/* mode2 |= AI_SC_Reload_Mode; */
-		devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
+		ni_stc_writew(dev, mode2, AI_Mode_2_Register);
 
 		/* load SI */
 		timer = ni_ns_to_timer(dev, cmd->scan_begin_arg,
 				       TRIG_ROUND_NEAREST);
-		devpriv->stc_writel(dev, timer, AI_SI_Load_A_Registers);
-		devpriv->stc_writew(dev, AI_SI_Load, AI_Command_1_Register);
+		ni_stc_writel(dev, timer, AI_SI_Load_A_Registers);
+		ni_stc_writew(dev, AI_SI_Load, AI_Command_1_Register);
 		break;
 	case TRIG_EXT:
 		if (cmd->scan_begin_arg & CR_EDGE)
@@ -2234,7 +2256,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			start_stop_select |= AI_START_Sync;
 		start_stop_select |=
 		    AI_START_Select(1 + CR_CHAN(cmd->scan_begin_arg));
-		devpriv->stc_writew(dev, start_stop_select,
+		ni_stc_writew(dev, start_stop_select,
 				    AI_START_STOP_Select_Register);
 		break;
 	}
@@ -2247,31 +2269,32 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		else
 			timer = ni_ns_to_timer(dev, cmd->convert_arg,
 					       TRIG_ROUND_NEAREST);
-		devpriv->stc_writew(dev, 1, AI_SI2_Load_A_Register);	/* 0,0 does not work. */
-		devpriv->stc_writew(dev, timer, AI_SI2_Load_B_Register);
+		/* 0,0 does not work */
+		ni_stc_writew(dev, 1, AI_SI2_Load_A_Register);
+		ni_stc_writew(dev, timer, AI_SI2_Load_B_Register);
 
 		/* AI_SI2_Reload_Mode = alternate */
 		/* AI_SI2_Initial_Load_Source = A */
 		mode2 &= ~AI_SI2_Initial_Load_Source;
 		mode2 |= AI_SI2_Reload_Mode;
-		devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
+		ni_stc_writew(dev, mode2, AI_Mode_2_Register);
 
 		/* AI_SI2_Load */
-		devpriv->stc_writew(dev, AI_SI2_Load, AI_Command_1_Register);
+		ni_stc_writew(dev, AI_SI2_Load, AI_Command_1_Register);
 
 		mode2 |= AI_SI2_Reload_Mode;	/*  alternate */
 		mode2 |= AI_SI2_Initial_Load_Source;	/*  B */
 
-		devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
+		ni_stc_writew(dev, mode2, AI_Mode_2_Register);
 		break;
 	case TRIG_EXT:
 		mode1 |= AI_CONVERT_Source_Select(1 + cmd->convert_arg);
 		if ((cmd->convert_arg & CR_INVERT) == 0)
 			mode1 |= AI_CONVERT_Source_Polarity;
-		devpriv->stc_writew(dev, mode1, AI_Mode_1_Register);
+		ni_stc_writew(dev, mode1, AI_Mode_1_Register);
 
 		mode2 |= AI_Start_Stop_Gate_Enable | AI_SC_Gate_Enable;
-		devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
+		ni_stc_writew(dev, mode2, AI_Mode_2_Register);
 
 		break;
 	}
@@ -2298,25 +2321,25 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		case AIMODE_HALF_FULL:
 			/*generate FIFO interrupts and DMA requests on half-full */
 #ifdef PCIDMA
-			devpriv->stc_writew(dev, AI_FIFO_Mode_HF_to_E,
-					    AI_Mode_3_Register);
+			ni_stc_writew(dev, AI_FIFO_Mode_HF_to_E,
+				      AI_Mode_3_Register);
 #else
-			devpriv->stc_writew(dev, AI_FIFO_Mode_HF,
-					    AI_Mode_3_Register);
+			ni_stc_writew(dev, AI_FIFO_Mode_HF,
+				      AI_Mode_3_Register);
 #endif
 			break;
 		case AIMODE_SAMPLE:
 			/*generate FIFO interrupts on non-empty */
-			devpriv->stc_writew(dev, AI_FIFO_Mode_NE,
-					    AI_Mode_3_Register);
+			ni_stc_writew(dev, AI_FIFO_Mode_NE,
+				      AI_Mode_3_Register);
 			break;
 		case AIMODE_SCAN:
 #ifdef PCIDMA
-			devpriv->stc_writew(dev, AI_FIFO_Mode_NE,
-					    AI_Mode_3_Register);
+			ni_stc_writew(dev, AI_FIFO_Mode_NE,
+				      AI_Mode_3_Register);
 #else
-			devpriv->stc_writew(dev, AI_FIFO_Mode_HF,
-					    AI_Mode_3_Register);
+			ni_stc_writew(dev, AI_FIFO_Mode_HF,
+				      AI_Mode_3_Register);
 #endif
 			interrupt_a_enable |= AI_STOP_Interrupt_Enable;
 			break;
@@ -2324,7 +2347,16 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			break;
 		}
 
-		devpriv->stc_writew(dev, AI_Error_Interrupt_Ack | AI_STOP_Interrupt_Ack | AI_START_Interrupt_Ack | AI_START2_Interrupt_Ack | AI_START1_Interrupt_Ack | AI_SC_TC_Interrupt_Ack | AI_SC_TC_Error_Confirm, Interrupt_A_Ack_Register);	/* clear interrupts */
+		/* clear interrupts */
+		ni_stc_writew(dev,
+			      AI_Error_Interrupt_Ack |
+			      AI_STOP_Interrupt_Ack |
+			      AI_START_Interrupt_Ack |
+			      AI_START2_Interrupt_Ack |
+			      AI_START1_Interrupt_Ack |
+			      AI_SC_TC_Interrupt_Ack |
+			      AI_SC_TC_Error_Confirm,
+			      Interrupt_A_Ack_Register);
 
 		ni_set_bits(dev, Interrupt_A_Enable_Register,
 			    interrupt_a_enable, 1);
@@ -2336,19 +2368,19 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* end configuration */
-	devpriv->stc_writew(dev, AI_Configuration_End, Joint_Reset_Register);
+	ni_stc_writew(dev, AI_Configuration_End, Joint_Reset_Register);
 
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
-		devpriv->stc_writew(dev,
-				    AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm |
-				    AI_SC_Arm, AI_Command_1_Register);
+		ni_stc_writew(dev,
+			      AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm | AI_SC_Arm,
+			      AI_Command_1_Register);
 		break;
 	case TRIG_EXT:
 		/* XXX AI_SI_Arm? */
-		devpriv->stc_writew(dev,
-				    AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm |
-				    AI_SC_Arm, AI_Command_1_Register);
+		ni_stc_writew(dev,
+			      AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm | AI_SC_Arm,
+			      AI_Command_1_Register);
 		break;
 	}
 
@@ -2362,8 +2394,8 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (cmd->start_src == TRIG_NOW) {
 		/* AI_START1_Pulse */
-		devpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
-				    AI_Command_2_Register);
+		ni_stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
+			      AI_Command_2_Register);
 		s->async->inttrig = NULL;
 	} else if (cmd->start_src == TRIG_EXT) {
 		s->async->inttrig = NULL;
@@ -2799,7 +2831,7 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 		    AO_FIFO_Interrupt_Enable | AO_Error_Interrupt_Enable, 0);
 	interrupt_b_bits = AO_Error_Interrupt_Enable;
 #ifdef PCIDMA
-	devpriv->stc_writew(dev, 1, DAC_FIFO_Clear);
+	ni_stc_writew(dev, 1, DAC_FIFO_Clear);
 	if (board->reg_type & ni_reg_6xxx_mask)
 		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
 	ret = ni_ao_setup_MITE_dma(dev);
@@ -2816,14 +2848,13 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 	interrupt_b_bits |= AO_FIFO_Interrupt_Enable;
 #endif
 
-	devpriv->stc_writew(dev, devpriv->ao_mode3 | AO_Not_An_UPDATE,
-			    AO_Mode_3_Register);
-	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
+	ni_stc_writew(dev, devpriv->ao_mode3 | AO_Not_An_UPDATE,
+		      AO_Mode_3_Register);
+	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 	/* wait for DACs to be loaded */
 	for (i = 0; i < timeout; i++) {
 		udelay(1);
-		if ((devpriv->stc_readw(dev,
-					Joint_Status_2_Register) &
+		if ((ni_stc_readw(dev, Joint_Status_2_Register) &
 		     AO_TMRDACWRs_In_Progress_St) == 0)
 			break;
 	}
@@ -2832,19 +2863,21 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 			     "timed out waiting for AO_TMRDACWRs_In_Progress_St to clear");
 		return -EIO;
 	}
-	/*  stc manual says we are need to clear error interrupt after AO_TMRDACWRs_In_Progress_St clears */
-	devpriv->stc_writew(dev, AO_Error_Interrupt_Ack,
-			    Interrupt_B_Ack_Register);
+	/*
+	 * stc manual says we are need to clear error interrupt after
+	 * AO_TMRDACWRs_In_Progress_St clears
+	 */
+	ni_stc_writew(dev, AO_Error_Interrupt_Ack, Interrupt_B_Ack_Register);
 
 	ni_set_bits(dev, Interrupt_B_Enable_Register, interrupt_b_bits, 1);
 
-	devpriv->stc_writew(dev,
-			    devpriv->ao_cmd1 | AO_UI_Arm | AO_UC_Arm | AO_BC_Arm
-			    | AO_DAC1_Update_Mode | AO_DAC0_Update_Mode,
-			    AO_Command_1_Register);
+	ni_stc_writew(dev, devpriv->ao_cmd1 |
+		      AO_UI_Arm | AO_UC_Arm | AO_BC_Arm |
+		      AO_DAC1_Update_Mode | AO_DAC0_Update_Mode,
+		      AO_Command_1_Register);
 
-	devpriv->stc_writew(dev, devpriv->ao_cmd2 | AO_START1_Pulse,
-			    AO_Command_2_Register);
+	ni_stc_writew(dev, devpriv->ao_cmd2 | AO_START1_Pulse,
+		      AO_Command_2_Register);
 
 	return 0;
 }
@@ -2863,9 +2896,9 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EIO;
 	}
 
-	devpriv->stc_writew(dev, AO_Configuration_Start, Joint_Reset_Register);
+	ni_stc_writew(dev, AO_Configuration_Start, Joint_Reset_Register);
 
-	devpriv->stc_writew(dev, AO_Disarm, AO_Command_1_Register);
+	ni_stc_writew(dev, AO_Disarm, AO_Command_1_Register);
 
 	if (board->reg_type & ni_reg_6xxx_mask) {
 		ao_win_out(CLEAR_WG, AO_Misc_611x);
@@ -2890,15 +2923,15 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ao_mode1 &= ~AO_Continuous;
 		devpriv->ao_mode1 |= AO_Trigger_Once;
 	}
-	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	ni_stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 	switch (cmd->start_src) {
 	case TRIG_INT:
 	case TRIG_NOW:
 		devpriv->ao_trigger_select &=
 		    ~(AO_START1_Polarity | AO_START1_Select(-1));
 		devpriv->ao_trigger_select |= AO_START1_Edge | AO_START1_Sync;
-		devpriv->stc_writew(dev, devpriv->ao_trigger_select,
-				    AO_Trigger_Select_Register);
+		ni_stc_writew(dev, devpriv->ao_trigger_select,
+			      AO_Trigger_Select_Register);
 		break;
 	case TRIG_EXT:
 		devpriv->ao_trigger_select =
@@ -2907,52 +2940,50 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			devpriv->ao_trigger_select |= AO_START1_Polarity;	/*  0=active high, 1=active low. see daq-stc 3-24 (p186) */
 		if (cmd->start_arg & CR_EDGE)
 			devpriv->ao_trigger_select |= AO_START1_Edge;	/*  0=edge detection disabled, 1=enabled */
-		devpriv->stc_writew(dev, devpriv->ao_trigger_select,
-				    AO_Trigger_Select_Register);
+		ni_stc_writew(dev, devpriv->ao_trigger_select,
+			      AO_Trigger_Select_Register);
 		break;
 	default:
 		BUG();
 		break;
 	}
 	devpriv->ao_mode3 &= ~AO_Trigger_Length;
-	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
+	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 
-	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	ni_stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 	devpriv->ao_mode2 &= ~AO_BC_Initial_Load_Source;
-	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 	if (cmd->stop_src == TRIG_NONE)
-		devpriv->stc_writel(dev, 0xffffff, AO_BC_Load_A_Register);
+		ni_stc_writel(dev, 0xffffff, AO_BC_Load_A_Register);
 	else
-		devpriv->stc_writel(dev, 0, AO_BC_Load_A_Register);
-	devpriv->stc_writew(dev, AO_BC_Load, AO_Command_1_Register);
+		ni_stc_writel(dev, 0, AO_BC_Load_A_Register);
+	ni_stc_writew(dev, AO_BC_Load, AO_Command_1_Register);
 	devpriv->ao_mode2 &= ~AO_UC_Initial_Load_Source;
-	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
 		if (devpriv->is_m_series) {
 			/*  this is how the NI example code does it for m-series boards, verified correct with 6259 */
-			devpriv->stc_writel(dev, cmd->stop_arg - 1,
-					    AO_UC_Load_A_Register);
-			devpriv->stc_writew(dev, AO_UC_Load,
-					    AO_Command_1_Register);
+			ni_stc_writel(dev, cmd->stop_arg - 1,
+				      AO_UC_Load_A_Register);
+			ni_stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
 		} else {
-			devpriv->stc_writel(dev, cmd->stop_arg,
-					    AO_UC_Load_A_Register);
-			devpriv->stc_writew(dev, AO_UC_Load,
-					    AO_Command_1_Register);
-			devpriv->stc_writel(dev, cmd->stop_arg - 1,
-					    AO_UC_Load_A_Register);
+			ni_stc_writel(dev, cmd->stop_arg,
+				      AO_UC_Load_A_Register);
+			ni_stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
+			ni_stc_writel(dev, cmd->stop_arg - 1,
+				      AO_UC_Load_A_Register);
 		}
 		break;
 	case TRIG_NONE:
-		devpriv->stc_writel(dev, 0xffffff, AO_UC_Load_A_Register);
-		devpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
-		devpriv->stc_writel(dev, 0xffffff, AO_UC_Load_A_Register);
+		ni_stc_writel(dev, 0xffffff, AO_UC_Load_A_Register);
+		ni_stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
+		ni_stc_writel(dev, 0xffffff, AO_UC_Load_A_Register);
 		break;
 	default:
-		devpriv->stc_writel(dev, 0, AO_UC_Load_A_Register);
-		devpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
-		devpriv->stc_writel(dev, cmd->stop_arg, AO_UC_Load_A_Register);
+		ni_stc_writel(dev, 0, AO_UC_Load_A_Register);
+		ni_stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
+		ni_stc_writel(dev, cmd->stop_arg, AO_UC_Load_A_Register);
 	}
 
 	devpriv->ao_mode1 &=
@@ -2964,9 +2995,9 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		trigvar =
 		    ni_ns_to_timer(dev, cmd->scan_begin_arg,
 				   TRIG_ROUND_NEAREST);
-		devpriv->stc_writel(dev, 1, AO_UI_Load_A_Register);
-		devpriv->stc_writew(dev, AO_UI_Load, AO_Command_1_Register);
-		devpriv->stc_writel(dev, trigvar, AO_UI_Load_A_Register);
+		ni_stc_writel(dev, 1, AO_UI_Load_A_Register);
+		ni_stc_writew(dev, AO_UI_Load, AO_Command_1_Register);
+		ni_stc_writel(dev, trigvar, AO_UI_Load_A_Register);
 		break;
 	case TRIG_EXT:
 		devpriv->ao_mode1 |=
@@ -2979,20 +3010,18 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		BUG();
 		break;
 	}
-	devpriv->stc_writew(dev, devpriv->ao_cmd2, AO_Command_2_Register);
-	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	ni_stc_writew(dev, devpriv->ao_cmd2, AO_Command_2_Register);
+	ni_stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 	devpriv->ao_mode2 &=
 	    ~(AO_UI_Reload_Mode(3) | AO_UI_Initial_Load_Source);
-	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 
 	if (cmd->scan_end_arg > 1) {
 		devpriv->ao_mode1 |= AO_Multiple_Channels;
-		devpriv->stc_writew(dev,
-				    AO_Number_Of_Channels(cmd->scan_end_arg -
-							  1) |
-				    AO_UPDATE_Output_Select
-				    (AO_Update_Output_High_Z),
-				    AO_Output_Control_Register);
+		ni_stc_writew(dev,
+			      AO_Number_Of_Channels(cmd->scan_end_arg - 1) |
+			      AO_UPDATE_Output_Select(AO_Update_Output_High_Z),
+			      AO_Output_Control_Register);
 	} else {
 		unsigned bits;
 		devpriv->ao_mode1 &= ~AO_Multiple_Channels;
@@ -3004,15 +3033,15 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			bits |=
 			    AO_Number_Of_Channels(CR_CHAN(cmd->chanlist[0]));
 		}
-		devpriv->stc_writew(dev, bits, AO_Output_Control_Register);
+		ni_stc_writew(dev, bits, AO_Output_Control_Register);
 	}
-	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	ni_stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 
-	devpriv->stc_writew(dev, AO_DAC0_Update_Mode | AO_DAC1_Update_Mode,
-			    AO_Command_1_Register);
+	ni_stc_writew(dev, AO_DAC0_Update_Mode | AO_DAC1_Update_Mode,
+		      AO_Command_1_Register);
 
 	devpriv->ao_mode3 |= AO_Stop_On_Overrun_Error;
-	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
+	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 
 	devpriv->ao_mode2 &= ~AO_FIFO_Mode_Mask;
 #ifdef PCIDMA
@@ -3021,7 +3050,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ao_mode2 |= AO_FIFO_Mode_HF;
 #endif
 	devpriv->ao_mode2 &= ~AO_FIFO_Retransmit_Enable;
-	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 
 	bits = AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
 	    AO_TMRDACWR_Pulse_Width;
@@ -3035,15 +3064,15 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->is_m_series)
 		bits |= AO_Number_Of_DAC_Packages;
 #endif
-	devpriv->stc_writew(dev, bits, AO_Personal_Register);
+	ni_stc_writew(dev, bits, AO_Personal_Register);
 	/*  enable sending of ao dma requests */
-	devpriv->stc_writew(dev, AO_AOFREQ_Enable, AO_Start_Select_Register);
+	ni_stc_writew(dev, AO_AOFREQ_Enable, AO_Start_Select_Register);
 
-	devpriv->stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);
+	ni_stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		devpriv->stc_writew(dev, AO_BC_TC_Interrupt_Ack,
-				    Interrupt_B_Ack_Register);
+		ni_stc_writew(dev, AO_BC_TC_Interrupt_Ack,
+			      Interrupt_B_Ack_Register);
 		ni_set_bits(dev, Interrupt_B_Enable_Register,
 			    AO_BC_TC_Interrupt_Enable, 1);
 	}
@@ -3146,31 +3175,31 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	ni_release_ao_mite_channel(dev);
 
-	devpriv->stc_writew(dev, AO_Configuration_Start, Joint_Reset_Register);
-	devpriv->stc_writew(dev, AO_Disarm, AO_Command_1_Register);
+	ni_stc_writew(dev, AO_Configuration_Start, Joint_Reset_Register);
+	ni_stc_writew(dev, AO_Disarm, AO_Command_1_Register);
 	ni_set_bits(dev, Interrupt_B_Enable_Register, ~0, 0);
-	devpriv->stc_writew(dev, AO_BC_Source_Select, AO_Personal_Register);
-	devpriv->stc_writew(dev, 0x3f98, Interrupt_B_Ack_Register);
-	devpriv->stc_writew(dev, AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
-			    AO_TMRDACWR_Pulse_Width, AO_Personal_Register);
-	devpriv->stc_writew(dev, 0, AO_Output_Control_Register);
-	devpriv->stc_writew(dev, 0, AO_Start_Select_Register);
+	ni_stc_writew(dev, AO_BC_Source_Select, AO_Personal_Register);
+	ni_stc_writew(dev, 0x3f98, Interrupt_B_Ack_Register);
+	ni_stc_writew(dev, AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
+		      AO_TMRDACWR_Pulse_Width, AO_Personal_Register);
+	ni_stc_writew(dev, 0, AO_Output_Control_Register);
+	ni_stc_writew(dev, 0, AO_Start_Select_Register);
 	devpriv->ao_cmd1 = 0;
-	devpriv->stc_writew(dev, devpriv->ao_cmd1, AO_Command_1_Register);
+	ni_stc_writew(dev, devpriv->ao_cmd1, AO_Command_1_Register);
 	devpriv->ao_cmd2 = 0;
-	devpriv->stc_writew(dev, devpriv->ao_cmd2, AO_Command_2_Register);
+	ni_stc_writew(dev, devpriv->ao_cmd2, AO_Command_2_Register);
 	devpriv->ao_mode1 = 0;
-	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	ni_stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 	devpriv->ao_mode2 = 0;
-	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+	ni_stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 	if (devpriv->is_m_series)
 		devpriv->ao_mode3 = AO_Last_Gate_Disable;
 	else
 		devpriv->ao_mode3 = 0;
-	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
+	ni_stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 	devpriv->ao_trigger_select = 0;
-	devpriv->stc_writew(dev, devpriv->ao_trigger_select,
-			    AO_Trigger_Select_Register);
+	ni_stc_writew(dev, devpriv->ao_trigger_select,
+		      AO_Trigger_Select_Register);
 	if (board->reg_type & ni_reg_6xxx_mask) {
 		unsigned immediate_bits = 0;
 		unsigned i;
@@ -3179,7 +3208,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 		ao_win_out(immediate_bits, AO_Immediate_671x);
 		ao_win_out(CLEAR_WG, AO_Misc_611x);
 	}
-	devpriv->stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);
+	ni_stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);
 
 	return 0;
 }
@@ -3200,7 +3229,7 @@ static int ni_dio_insn_config(struct comedi_device *dev,
 
 	devpriv->dio_control &= ~DIO_Pins_Dir_Mask;
 	devpriv->dio_control |= DIO_Pins_Dir(s->io_bits);
-	devpriv->stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
+	ni_stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
 
 	return insn->n;
 }
@@ -3219,11 +3248,10 @@ static int ni_dio_insn_bits(struct comedi_device *dev,
 	if (comedi_dio_update_state(s, data)) {
 		devpriv->dio_output &= ~DIO_Parallel_Data_Mask;
 		devpriv->dio_output |= DIO_Parallel_Data_Out(s->state);
-		devpriv->stc_writew(dev, devpriv->dio_output,
-				    DIO_Output_Register);
+		ni_stc_writew(dev, devpriv->dio_output, DIO_Output_Register);
 	}
 
-	data[1] = devpriv->stc_readw(dev, DIO_Parallel_Input_Register);
+	data[1] = ni_stc_readw(dev, DIO_Parallel_Input_Register);
 
 	return insn->n;
 }
@@ -3497,22 +3525,20 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 
 	devpriv->dio_output &= ~DIO_Serial_Data_Mask;
 	devpriv->dio_output |= DIO_Serial_Data_Out(data_out);
-	devpriv->stc_writew(dev, devpriv->dio_output, DIO_Output_Register);
+	ni_stc_writew(dev, devpriv->dio_output, DIO_Output_Register);
 
-	status1 = devpriv->stc_readw(dev, Joint_Status_1_Register);
+	status1 = ni_stc_readw(dev, Joint_Status_1_Register);
 	if (status1 & DIO_Serial_IO_In_Progress_St) {
 		err = -EBUSY;
 		goto Error;
 	}
 
 	devpriv->dio_control |= DIO_HW_Serial_Start;
-	devpriv->stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
+	ni_stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
 	devpriv->dio_control &= ~DIO_HW_Serial_Start;
 
 	/* Wait until STC says we're done, but don't loop infinitely. */
-	while ((status1 =
-		devpriv->stc_readw(dev,
-				   Joint_Status_1_Register)) &
+	while ((status1 = ni_stc_readw(dev, Joint_Status_1_Register)) &
 	       DIO_Serial_IO_In_Progress_St) {
 		/* Delay one bit per loop */
 		udelay((devpriv->serial_interval_ns + 999) / 1000);
@@ -3529,10 +3555,10 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 	udelay((devpriv->serial_interval_ns + 999) / 1000);
 
 	if (data_in != NULL)
-		*data_in = devpriv->stc_readw(dev, DIO_Serial_Input_Register);
+		*data_in = ni_stc_readw(dev, DIO_Serial_Input_Register);
 
 Error:
-	devpriv->stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
+	ni_stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
 
 	return err;
 }
@@ -3555,27 +3581,23 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 		devpriv->dio_output &= ~DIO_SDOUT;
 		if (data_out & mask)
 			devpriv->dio_output |= DIO_SDOUT;
-		devpriv->stc_writew(dev, devpriv->dio_output,
-				    DIO_Output_Register);
+		ni_stc_writew(dev, devpriv->dio_output, DIO_Output_Register);
 
 		/* Assert SDCLK (active low, inverted), wait for half of
 		   the delay, deassert SDCLK, and wait for the other half. */
 		devpriv->dio_control |= DIO_Software_Serial_Control;
-		devpriv->stc_writew(dev, devpriv->dio_control,
-				    DIO_Control_Register);
+		ni_stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
 
 		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
 		devpriv->dio_control &= ~DIO_Software_Serial_Control;
-		devpriv->stc_writew(dev, devpriv->dio_control,
-				    DIO_Control_Register);
+		ni_stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
 
 		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
 		/* Input current bit */
-		if (devpriv->stc_readw(dev,
-				       DIO_Parallel_Input_Register) & DIO_SDIN) {
-			/* printk("DIO_P_I_R: 0x%x\n", devpriv->stc_readw(dev, DIO_Parallel_Input_Register)); */
+		if (ni_stc_readw(dev, DIO_Parallel_Input_Register) & DIO_SDIN) {
+			/* printk("DIO_P_I_R: 0x%x\n", ni_stc_readw(dev, DIO_Parallel_Input_Register)); */
 			input |= mask;
 		}
 	}
@@ -3641,10 +3663,9 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 			devpriv->serial_interval_ns = data[1];
 		}
 
-		devpriv->stc_writew(dev, devpriv->dio_control,
-				    DIO_Control_Register);
-		devpriv->stc_writew(dev, devpriv->clock_and_fout,
-				    Clock_and_FOUT_Register);
+		ni_stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
+		ni_stc_writew(dev, devpriv->clock_and_fout,
+			      Clock_and_FOUT_Register);
 		return 1;
 
 		break;
@@ -3827,7 +3848,7 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 	case NITIO_G0_LOADB:
 	case NITIO_G1_LOADB:
 		stc_register = ni_gpct_to_stc_register(reg);
-		devpriv->stc_writel(dev, bits, stc_register);
+		ni_stc_writel(dev, bits, stc_register);
 		break;
 
 		/* 16 bit registers */
@@ -3846,7 +3867,7 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 		/* fall-through */
 	default:
 		stc_register = ni_gpct_to_stc_register(reg);
-		devpriv->stc_writew(dev, bits, stc_register);
+		ni_stc_writew(dev, bits, stc_register);
 	}
 }
 
@@ -3870,12 +3891,12 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 	case NITIO_G0_SW_SAVE:
 	case NITIO_G1_SW_SAVE:
 		stc_register = ni_gpct_to_stc_register(reg);
-		return devpriv->stc_readl(dev, stc_register);
+		return ni_stc_readl(dev, stc_register);
 
 		/* 16 bit registers */
 	default:
 		stc_register = ni_gpct_to_stc_register(reg);
-		return devpriv->stc_readw(dev, stc_register);
+		return ni_stc_readw(dev, stc_register);
 		break;
 	}
 	return 0;
@@ -3905,16 +3926,16 @@ static int ni_freq_out_insn_write(struct comedi_device *dev,
 
 	if (insn->n) {
 		devpriv->clock_and_fout &= ~FOUT_Enable;
-		devpriv->stc_writew(dev, devpriv->clock_and_fout,
-				    Clock_and_FOUT_Register);
+		ni_stc_writew(dev, devpriv->clock_and_fout,
+			      Clock_and_FOUT_Register);
 		devpriv->clock_and_fout &= ~FOUT_Divider_mask;
 
 		/* use the last data value to set the fout divider */
 		devpriv->clock_and_fout |= FOUT_Divider(data[insn->n - 1]);
 
 		devpriv->clock_and_fout |= FOUT_Enable;
-		devpriv->stc_writew(dev, devpriv->clock_and_fout,
-				    Clock_and_FOUT_Register);
+		ni_stc_writew(dev, devpriv->clock_and_fout,
+			      Clock_and_FOUT_Register);
 	}
 	return insn->n;
 }
@@ -3938,8 +3959,8 @@ static int ni_freq_out_insn_config(struct comedi_device *dev,
 		default:
 			return -EINVAL;
 		}
-		devpriv->stc_writew(dev, devpriv->clock_and_fout,
-				    Clock_and_FOUT_Register);
+		ni_stc_writew(dev, devpriv->clock_and_fout,
+			      Clock_and_FOUT_Register);
 		break;
 	case INSN_CONFIG_GET_CLOCK_SRC:
 		if (devpriv->clock_and_fout & FOUT_Timebase_Select) {
@@ -4726,8 +4747,8 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 		return -EINVAL;
 	}
 	devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
-	devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-			    RTSI_Trig_Direction_Register);
+	ni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+		      RTSI_Trig_Direction_Register);
 	pll_control_bits =
 	    MSeries_PLL_Enable_Bit | MSeries_PLL_VCO_Mode_75_150MHz_Bits;
 	devpriv->clock_and_fout2 |=
@@ -4813,8 +4834,8 @@ static int ni_set_master_clock(struct comedi_device *dev,
 
 	if (source == NI_MIO_INTERNAL_CLOCK) {
 		devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
-		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-				    RTSI_Trig_Direction_Register);
+		ni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+			      RTSI_Trig_Direction_Register);
 		devpriv->clock_ns = TIMEBASE_1_NS;
 		if (devpriv->is_m_series) {
 			devpriv->clock_and_fout2 &=
@@ -4833,10 +4854,9 @@ static int ni_set_master_clock(struct comedi_device *dev,
 			if (source == NI_MIO_RTSI_CLOCK) {
 				devpriv->rtsi_trig_direction_reg |=
 				    Use_RTSI_Clock_Bit;
-				devpriv->stc_writew(dev,
-						    devpriv->
-						    rtsi_trig_direction_reg,
-						    RTSI_Trig_Direction_Register);
+				ni_stc_writew(dev,
+					      devpriv->rtsi_trig_direction_reg,
+					      RTSI_Trig_Direction_Register);
 				if (period_ns == 0) {
 					printk
 					    ("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",
@@ -4916,14 +4936,14 @@ static int ni_set_rtsi_routing(struct comedi_device *dev,
 		devpriv->rtsi_trig_a_output_reg &= ~RTSI_Trig_Output_Mask(chan);
 		devpriv->rtsi_trig_a_output_reg |=
 		    RTSI_Trig_Output_Bits(chan, source);
-		devpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
-				    RTSI_Trig_A_Output_Register);
+		ni_stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
+			      RTSI_Trig_A_Output_Register);
 	} else if (chan < 8) {
 		devpriv->rtsi_trig_b_output_reg &= ~RTSI_Trig_Output_Mask(chan);
 		devpriv->rtsi_trig_b_output_reg |=
 		    RTSI_Trig_Output_Bits(chan, source);
-		devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
-				    RTSI_Trig_B_Output_Register);
+		ni_stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
+			      RTSI_Trig_B_Output_Register);
 	}
 	return 2;
 }
@@ -4963,8 +4983,8 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 			devpriv->rtsi_trig_direction_reg |=
 			    Drive_RTSI_Clock_Bit;
 		}
-		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-				    RTSI_Trig_Direction_Register);
+		ni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+			      RTSI_Trig_Direction_Register);
 		break;
 	case INSN_CONFIG_DIO_INPUT:
 		if (chan < num_configurable_rtsi_channels(dev)) {
@@ -4974,8 +4994,8 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 			devpriv->rtsi_trig_direction_reg &=
 			    ~Drive_RTSI_Clock_Bit;
 		}
-		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-				    RTSI_Trig_Direction_Register);
+		ni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+			      RTSI_Trig_Direction_Register);
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		if (chan < num_configurable_rtsi_channels(dev)) {
@@ -5043,8 +5063,8 @@ static void ni_rtsi_init(struct comedi_device *dev)
 	    RTSI_Trig_Output_Bits(2,
 				  NI_RTSI_OUTPUT_SCLKG) |
 	    RTSI_Trig_Output_Bits(3, NI_RTSI_OUTPUT_DACUPDN);
-	devpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
-			    RTSI_Trig_A_Output_Register);
+	ni_stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
+		      RTSI_Trig_A_Output_Register);
 	devpriv->rtsi_trig_b_output_reg =
 	    RTSI_Trig_Output_Bits(4,
 				  NI_RTSI_OUTPUT_DA_START1) |
@@ -5054,12 +5074,12 @@ static void ni_rtsi_init(struct comedi_device *dev)
 	if (devpriv->is_m_series)
 		devpriv->rtsi_trig_b_output_reg |=
 		    RTSI_Trig_Output_Bits(7, NI_RTSI_OUTPUT_RTSI_OSC);
-	devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
-			    RTSI_Trig_B_Output_Register);
+	ni_stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
+		      RTSI_Trig_B_Output_Register);
 
 /*
 * Sets the source and direction of the 4 on board lines
-* devpriv->stc_writew(dev, 0x0000, RTSI_Board_Register);
+* ni_stc_writew(dev, 0x0000, RTSI_Board_Register);
 */
 }
 
@@ -5103,19 +5123,19 @@ static int GPCT_G_Watch(struct comedi_device *dev, int chan)
 	unsigned int hi1, hi2, lo;
 
 	devpriv->gpct_command[chan] &= ~G_Save_Trace;
-	devpriv->stc_writew(dev, devpriv->gpct_command[chan],
-			    G_Command_Register(chan));
+	ni_stc_writew(dev, devpriv->gpct_command[chan],
+		      G_Command_Register(chan));
 
 	devpriv->gpct_command[chan] |= G_Save_Trace;
-	devpriv->stc_writew(dev, devpriv->gpct_command[chan],
-			    G_Command_Register(chan));
+	ni_stc_writew(dev, devpriv->gpct_command[chan],
+		      G_Command_Register(chan));
 
 	/* This procedure is used because the two registers cannot
 	 * be read atomically. */
 	do {
-		hi1 = devpriv->stc_readw(dev, G_Save_Register_High(chan));
-		lo = devpriv->stc_readw(dev, G_Save_Register_Low(chan));
-		hi2 = devpriv->stc_readw(dev, G_Save_Register_High(chan));
+		hi1 = ni_stc_readw(dev, G_Save_Register_High(chan));
+		lo = ni_stc_readw(dev, G_Save_Register_Low(chan));
+		hi2 = ni_stc_readw(dev, G_Save_Register_High(chan));
 	} while (hi1 != hi2);
 
 	return (hi1 << 16) | lo;
@@ -5130,7 +5150,7 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 
 	switch (chan) {
 	case 0:
-		devpriv->stc_writew(dev, G0_Reset, Joint_Reset_Register);
+		ni_stc_writew(dev, G0_Reset, Joint_Reset_Register);
 		ni_set_bits(dev, Interrupt_A_Enable_Register,
 			    G0_TC_Interrupt_Enable, 0);
 		ni_set_bits(dev, Interrupt_A_Enable_Register,
@@ -5139,16 +5159,15 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 		temp_ack_reg |= G0_TC_Error_Confirm;
 		temp_ack_reg |= G0_TC_Interrupt_Ack;
 		temp_ack_reg |= G0_Gate_Interrupt_Ack;
-		devpriv->stc_writew(dev, temp_ack_reg,
-				    Interrupt_A_Ack_Register);
+		ni_stc_writew(dev, temp_ack_reg, Interrupt_A_Ack_Register);
 
 		/* problem...this interferes with the other ctr... */
 		devpriv->an_trig_etc_reg |= GPFO_0_Output_Enable;
-		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
-				    Analog_Trigger_Etc_Register);
+		ni_stc_writew(dev, devpriv->an_trig_etc_reg,
+			      Analog_Trigger_Etc_Register);
 		break;
 	case 1:
-		devpriv->stc_writew(dev, G1_Reset, Joint_Reset_Register);
+		ni_stc_writew(dev, G1_Reset, Joint_Reset_Register);
 		ni_set_bits(dev, Interrupt_B_Enable_Register,
 			    G1_TC_Interrupt_Enable, 0);
 		ni_set_bits(dev, Interrupt_B_Enable_Register,
@@ -5157,12 +5176,11 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 		temp_ack_reg |= G1_TC_Error_Confirm;
 		temp_ack_reg |= G1_TC_Interrupt_Ack;
 		temp_ack_reg |= G1_Gate_Interrupt_Ack;
-		devpriv->stc_writew(dev, temp_ack_reg,
-				    Interrupt_B_Ack_Register);
+		ni_stc_writew(dev, temp_ack_reg, Interrupt_B_Ack_Register);
 
 		devpriv->an_trig_etc_reg |= GPFO_1_Output_Enable;
-		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
-				    Analog_Trigger_Etc_Register);
+		ni_stc_writew(dev, devpriv->an_trig_etc_reg,
+			      Analog_Trigger_Etc_Register);
 		break;
 	}
 
@@ -5172,11 +5190,10 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 
 	devpriv->gpct_command[chan] |= G_Synchronized_Gate;
 
-	devpriv->stc_writew(dev, devpriv->gpct_mode[chan],
-			    G_Mode_Register(chan));
-	devpriv->stc_writew(dev, devpriv->gpct_input_select[chan],
-			    G_Input_Select_Register(chan));
-	devpriv->stc_writew(dev, 0, G_Autoincrement_Register(chan));
+	ni_stc_writew(dev, devpriv->gpct_mode[chan], G_Mode_Register(chan));
+	ni_stc_writew(dev, devpriv->gpct_input_select[chan],
+		      G_Input_Select_Register(chan));
+	ni_stc_writew(dev, 0, G_Autoincrement_Register(chan));
 
 	/* printk("exit GPCT_Reset\n"); */
 }
@@ -5185,13 +5202,13 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 static irqreturn_t ni_E_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct ni_private *devpriv = dev->private;
 	unsigned short a_status;
 	unsigned short b_status;
 	unsigned int ai_mite_status = 0;
 	unsigned int ao_mite_status = 0;
 	unsigned long flags;
 #ifdef PCIDMA
+	struct ni_private *devpriv = dev->private;
 	struct mite_struct *mite = devpriv->mite;
 #endif
 
@@ -5201,10 +5218,11 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 
 	/*  lock to avoid race with comedi_poll */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	a_status = devpriv->stc_readw(dev, AI_Status_1_Register);
-	b_status = devpriv->stc_readw(dev, AO_Status_1_Register);
+	a_status = ni_stc_readw(dev, AI_Status_1_Register);
+	b_status = ni_stc_readw(dev, AO_Status_1_Register);
 #ifdef PCIDMA
 	if (mite) {
+		struct ni_private *devpriv = dev->private;
 		unsigned long flags_too;
 
 		spin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);
@@ -5550,23 +5568,20 @@ static int ni_E_init(struct comedi_device *dev)
 		    Slow_Internal_Timebase |
 		    Clock_To_Board_Divide_By_2 | Clock_To_Board;
 	}
-	devpriv->stc_writew(dev, devpriv->clock_and_fout,
-			    Clock_and_FOUT_Register);
+	ni_stc_writew(dev, devpriv->clock_and_fout, Clock_and_FOUT_Register);
 
 	/* analog output configuration */
 	s = &dev->subdevices[NI_AO_SUBDEV];
 	ni_ao_reset(dev, s);
 
 	if (dev->irq) {
-		devpriv->stc_writew(dev,
-				    (IRQ_POLARITY ? Interrupt_Output_Polarity :
-				     0) | (Interrupt_Output_On_3_Pins & 0) |
-				    Interrupt_A_Enable | Interrupt_B_Enable |
-				    Interrupt_A_Output_Select(interrupt_pin
-							      (dev->irq)) |
-				    Interrupt_B_Output_Select(interrupt_pin
-							      (dev->irq)),
-				    Interrupt_Control_Register);
+		ni_stc_writew(dev,
+			      (IRQ_POLARITY ? Interrupt_Output_Polarity : 0) |
+			      (Interrupt_Output_On_3_Pins & 0) |
+			      Interrupt_A_Enable | Interrupt_B_Enable |
+			      Interrupt_A_Output_Select(interrupt_pin(dev->irq)) |
+			      Interrupt_B_Output_Select(interrupt_pin(dev->irq)),
+			      Interrupt_Control_Register);
 	}
 
 	/* DMA setup */

commit 5f315520315b8db6c5a784b6d8a71756301af0ce
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 19 10:20:33 2014 -0700

    staging: comedi: ni_stc.h: cleanup ni_e_series_enable_second_irq()
    
    This function is used to enable/disable the second irq on NI e-series
    boards. This irq used used to generate dma requests for the counters.
    
    There are only 2 counters (NUM_GPCT) so the default case of the switch
    can never occur.
    
    Tidy up this function and remove the unreachable BUG().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 6da1424866e6..aa1ee9624ce0 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -527,38 +527,31 @@ static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 #endif /*  PCIDMA */
 }
 
-/* e-series boards use the second irq signals to generate dma requests for their counters */
 #ifdef PCIDMA
 static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 					  unsigned gpct_index, short enable)
 {
 	struct ni_private *devpriv = dev->private;
+	uint16_t val = 0;
+	int reg;
 
-	if (devpriv->is_m_series)
+	if (devpriv->is_m_series || gpct_index > 1)
 		return;
-	switch (gpct_index) {
-	case 0:
-		if (enable) {
-			devpriv->stc_writew(dev, G0_Gate_Second_Irq_Enable,
-					    Second_IRQ_A_Enable_Register);
-		} else {
-			devpriv->stc_writew(dev, 0,
-					    Second_IRQ_A_Enable_Register);
-		}
-		break;
-	case 1:
-		if (enable) {
-			devpriv->stc_writew(dev, G1_Gate_Second_Irq_Enable,
-					    Second_IRQ_B_Enable_Register);
-		} else {
-			devpriv->stc_writew(dev, 0,
-					    Second_IRQ_B_Enable_Register);
-		}
-		break;
-	default:
-		BUG();
-		break;
+
+	/*
+	 * e-series boards use the second irq signals to generate
+	 * dma requests for their counters
+	 */
+	if (gpct_index == 0) {
+		reg = Second_IRQ_A_Enable_Register;
+		if (enable)
+			val = G0_Gate_Second_Irq_Enable;
+	} else {
+		reg = Second_IRQ_B_Enable_Register;
+		if (enable)
+			val = G1_Gate_Second_Irq_Enable;
 	}
+	devpriv->stc_writew(dev, val, reg);
 }
 #endif /*  PCIDMA */
 

commit 17733219fb577912520c478b9548ba2963c8500a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 19 10:20:32 2014 -0700

    staging: comedi: ni_stc.h: add a 'is_m_series' flag to private data
    
    The (board->reg_type & ni_reg_m_series_mask) test is commonly used
    in ni_mio_common.c to detect if the driver is being used with a
    National Instruments "M series" DAQ board. Simplify the code a bit
    by adding an 'is_m_series' bit-field flag to the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7632bd6cafc1..6da1424866e6 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -532,10 +532,9 @@ static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 					  unsigned gpct_index, short enable)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
-	if (board->reg_type & ni_reg_m_series_mask)
+	if (devpriv->is_m_series)
 		return;
 	switch (gpct_index) {
 	case 0:
@@ -1650,7 +1649,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 	unsigned offset;
 	unsigned int dither;
 
-	if (board->reg_type & ni_reg_m_series_mask) {
+	if (devpriv->is_m_series) {
 		ni_m_series_load_channelgain_list(dev, n_chan, list);
 		return;
 	}
@@ -1853,7 +1852,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				    ("ni_mio_common: timeout in ni_ai_insn_read\n");
 				return -ETIME;
 			}
-			if (board->reg_type & ni_reg_m_series_mask) {
+			if (devpriv->is_m_series) {
 				dl = devpriv->readl(dev, M_Offset_AI_FIFO_Data);
 				dl &= mask;
 				data[n] = dl;
@@ -2496,7 +2495,7 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 	case INSN_CONFIG_ANALOG_TRIG:
 		return ni_ai_config_analog_trig(dev, s, insn, data);
 	case INSN_CONFIG_ALT_SOURCE:
-		if (board->reg_type & ni_reg_m_series_mask) {
+		if (devpriv->is_m_series) {
 			if (data[1] & ~(MSeries_AI_Bypass_Cal_Sel_Pos_Mask |
 					MSeries_AI_Bypass_Cal_Sel_Neg_Mask |
 					MSeries_AI_Bypass_Mode_Mux_Mask |
@@ -2692,9 +2691,9 @@ static int ni_ao_config_chanlist(struct comedi_device *dev,
 				 unsigned int chanspec[], unsigned int n_chans,
 				 int timed)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
 
-	if (board->reg_type & ni_reg_m_series_mask)
+	if (devpriv->is_m_series)
 		return ni_m_series_ao_config_chanlist(dev, s, chanspec, n_chans,
 						      timed);
 	else
@@ -2716,7 +2715,6 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
@@ -2725,7 +2723,7 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 
 	devpriv->ao[chan] = data[0];
 
-	if (board->reg_type & ni_reg_m_series_mask) {
+	if (devpriv->is_m_series) {
 		devpriv->writew(dev, data[0], M_Offset_DAC_Direct_Data(chan));
 	} else
 		devpriv->writew(dev, data[0] ^ invert,
@@ -2938,7 +2936,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		if (board->reg_type & ni_reg_m_series_mask) {
+		if (devpriv->is_m_series) {
 			/*  this is how the NI example code does it for m-series boards, verified correct with 6259 */
 			devpriv->stc_writel(dev, cmd->stop_arg - 1,
 					    AO_UC_Load_A_Register);
@@ -3006,8 +3004,8 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		unsigned bits;
 		devpriv->ao_mode1 &= ~AO_Multiple_Channels;
 		bits = AO_UPDATE_Output_Select(AO_Update_Output_High_Z);
-		if (board->reg_type &
-		    (ni_reg_m_series_mask | ni_reg_6xxx_mask)) {
+		if (devpriv->is_m_series ||
+		    board->reg_type & ni_reg_6xxx_mask) {
 			bits |= AO_Number_Of_Channels(0);
 		} else {
 			bits |=
@@ -3041,7 +3039,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 #if 0
 	/* F Hess: windows driver does not set AO_Number_Of_DAC_Packages bit for 6281,
 	   verified with bus analyzer. */
-	if (board->reg_type & ni_reg_m_series_mask)
+	if (devpriv->is_m_series)
 		bits |= AO_Number_Of_DAC_Packages;
 #endif
 	devpriv->stc_writew(dev, bits, AO_Personal_Register);
@@ -3172,7 +3170,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 	devpriv->ao_mode2 = 0;
 	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
-	if (board->reg_type & ni_reg_m_series_mask)
+	if (devpriv->is_m_series)
 		devpriv->ao_mode3 = AO_Last_Gate_Disable;
 	else
 		devpriv->ao_mode3 = 0;
@@ -3454,7 +3452,6 @@ static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static void handle_cdio_interrupt(struct comedi_device *dev)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned cdio_status;
 	struct comedi_subdevice *s = &dev->subdevices[NI_DIO_SUBDEV];
@@ -3462,7 +3459,7 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	unsigned long flags;
 #endif
 
-	if ((board->reg_type & ni_reg_m_series_mask) == 0)
+	if (!devpriv->is_m_series)
 		return;
 #ifdef PCIDMA
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
@@ -4434,9 +4431,9 @@ static int ni_m_series_set_pfi_routing(struct comedi_device *dev,
 
 static unsigned ni_get_pfi_routing(struct comedi_device *dev, unsigned chan)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
 
-	if (board->reg_type & ni_reg_m_series_mask)
+	if (devpriv->is_m_series)
 		return ni_m_series_get_pfi_routing(dev, chan);
 	else
 		return ni_old_get_pfi_routing(dev, chan);
@@ -4445,9 +4442,9 @@ static unsigned ni_get_pfi_routing(struct comedi_device *dev, unsigned chan)
 static int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,
 			      unsigned source)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
 
-	if (board->reg_type & ni_reg_m_series_mask)
+	if (devpriv->is_m_series)
 		return ni_m_series_set_pfi_routing(dev, chan, source);
 	else
 		return ni_old_set_pfi_routing(dev, chan, source);
@@ -4457,12 +4454,12 @@ static int ni_config_filter(struct comedi_device *dev,
 			    unsigned pfi_channel,
 			    enum ni_pfi_filter_select filter)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned bits;
 
-	if ((board->reg_type & ni_reg_m_series_mask) == 0)
+	if (!devpriv->is_m_series)
 		return -ENOTSUPP;
+
 	bits = devpriv->readl(dev, M_Offset_PFI_Filter);
 	bits &= ~MSeries_PFI_Filter_Select_Mask(pfi_channel);
 	bits |= MSeries_PFI_Filter_Select_Bits(pfi_channel, filter);
@@ -4516,10 +4513,9 @@ static int ni_pfi_insn_bits(struct comedi_device *dev,
 			    struct comedi_insn *insn,
 			    unsigned int *data)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
-	if (!(board->reg_type & ni_reg_m_series_mask))
+	if (!devpriv->is_m_series)
 		return -ENOTSUPP;
 
 	if (comedi_dio_update_state(s, data))
@@ -4820,7 +4816,6 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 static int ni_set_master_clock(struct comedi_device *dev,
 			       unsigned source, unsigned period_ns)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
 	if (source == NI_MIO_INTERNAL_CLOCK) {
@@ -4828,7 +4823,7 @@ static int ni_set_master_clock(struct comedi_device *dev,
 		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
 				    RTSI_Trig_Direction_Register);
 		devpriv->clock_ns = TIMEBASE_1_NS;
-		if (board->reg_type & ni_reg_m_series_mask) {
+		if (devpriv->is_m_series) {
 			devpriv->clock_and_fout2 &=
 			    ~(MSeries_Timebase1_Select_Bit |
 			      MSeries_Timebase3_Select_Bit);
@@ -4838,7 +4833,7 @@ static int ni_set_master_clock(struct comedi_device *dev,
 		}
 		devpriv->clock_source = source;
 	} else {
-		if (board->reg_type & ni_reg_m_series_mask) {
+		if (devpriv->is_m_series) {
 			return ni_mseries_set_pll_master_clock(dev, source,
 							       period_ns);
 		} else {
@@ -4867,9 +4862,9 @@ static int ni_set_master_clock(struct comedi_device *dev,
 
 static unsigned num_configurable_rtsi_channels(struct comedi_device *dev)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
 
-	if (board->reg_type & ni_reg_m_series_mask)
+	if (devpriv->is_m_series)
 		return 8;
 	else
 		return 7;
@@ -4878,7 +4873,7 @@ static unsigned num_configurable_rtsi_channels(struct comedi_device *dev)
 static int ni_valid_rtsi_output_source(struct comedi_device *dev,
 				       unsigned chan, unsigned source)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
 
 	if (chan >= num_configurable_rtsi_channels(dev)) {
 		if (chan == old_RTSI_clock_channel) {
@@ -4906,7 +4901,7 @@ static int ni_valid_rtsi_output_source(struct comedi_device *dev,
 		return 1;
 		break;
 	case NI_RTSI_OUTPUT_RTSI_OSC:
-		if (board->reg_type & ni_reg_m_series_mask)
+		if (devpriv->is_m_series)
 			return 1;
 		else
 			return 0;
@@ -4963,7 +4958,6 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 			       struct comedi_insn *insn,
 			       unsigned int *data)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 
@@ -4971,8 +4965,7 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 	case INSN_CONFIG_DIO_OUTPUT:
 		if (chan < num_configurable_rtsi_channels(dev)) {
 			devpriv->rtsi_trig_direction_reg |=
-			    RTSI_Output_Bit(chan,
-				(board->reg_type & ni_reg_m_series_mask) != 0);
+			    RTSI_Output_Bit(chan, devpriv->is_m_series);
 		} else if (chan == old_RTSI_clock_channel) {
 			devpriv->rtsi_trig_direction_reg |=
 			    Drive_RTSI_Clock_Bit;
@@ -4983,8 +4976,7 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 	case INSN_CONFIG_DIO_INPUT:
 		if (chan < num_configurable_rtsi_channels(dev)) {
 			devpriv->rtsi_trig_direction_reg &=
-			    ~RTSI_Output_Bit(chan,
-				(board->reg_type & ni_reg_m_series_mask) != 0);
+			    ~RTSI_Output_Bit(chan, devpriv->is_m_series);
 		} else if (chan == old_RTSI_clock_channel) {
 			devpriv->rtsi_trig_direction_reg &=
 			    ~Drive_RTSI_Clock_Bit;
@@ -4996,8 +4988,7 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 		if (chan < num_configurable_rtsi_channels(dev)) {
 			data[1] =
 			    (devpriv->rtsi_trig_direction_reg &
-			     RTSI_Output_Bit(chan,
-				(board->reg_type & ni_reg_m_series_mask) != 0))
+			     RTSI_Output_Bit(chan, devpriv->is_m_series))
 				? INSN_CONFIG_DIO_OUTPUT
 				: INSN_CONFIG_DIO_INPUT;
 		} else if (chan == old_RTSI_clock_channel) {
@@ -5042,7 +5033,6 @@ static int ni_rtsi_insn_bits(struct comedi_device *dev,
 
 static void ni_rtsi_init(struct comedi_device *dev)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
 	/*  Initialises the RTSI bus signal switch to a default state */
@@ -5068,7 +5058,7 @@ static void ni_rtsi_init(struct comedi_device *dev)
 	    RTSI_Trig_Output_Bits(5,
 				  NI_RTSI_OUTPUT_G_SRC0) |
 	    RTSI_Trig_Output_Bits(6, NI_RTSI_OUTPUT_G_GATE0);
-	if (board->reg_type & ni_reg_m_series_mask)
+	if (devpriv->is_m_series)
 		devpriv->rtsi_trig_b_output_reg |=
 		    RTSI_Trig_Output_Bits(7, NI_RTSI_OUTPUT_RTSI_OSC);
 	devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
@@ -5303,7 +5293,7 @@ static int ni_E_init(struct comedi_device *dev)
 			s->subdev_flags |= SDF_GROUND | SDF_COMMON | SDF_OTHER;
 		if (board->adbits > 16)
 			s->subdev_flags |= SDF_LSAMPL;
-		if (board->reg_type & ni_reg_m_series_mask)
+		if (devpriv->is_m_series)
 			s->subdev_flags |= SDF_SOFT_CALIBRATED;
 		s->n_chan = board->n_adchan;
 		s->len_chanlist = 512;
@@ -5329,7 +5319,7 @@ static int ni_E_init(struct comedi_device *dev)
 	if (board->n_aochan) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_WRITABLE | SDF_DEGLITCH | SDF_GROUND;
-		if (board->reg_type & ni_reg_m_series_mask)
+		if (devpriv->is_m_series)
 			s->subdev_flags |= SDF_SOFT_CALIBRATED;
 		s->n_chan = board->n_aochan;
 		s->maxdata = (1 << board->aobits) - 1;
@@ -5351,7 +5341,7 @@ static int ni_E_init(struct comedi_device *dev)
 			s->do_cmd = &ni_ao_cmd;
 			s->do_cmdtest = &ni_ao_cmdtest;
 			s->len_chanlist = board->n_aochan;
-			if ((board->reg_type & ni_reg_m_series_mask) == 0)
+			if (!devpriv->is_m_series)
 				s->munge = ni_ao_munge;
 		}
 		s->cancel = &ni_ao_reset;
@@ -5370,7 +5360,7 @@ static int ni_E_init(struct comedi_device *dev)
 	s->io_bits = 0;		/* all bits input */
 	s->range_table = &range_digital;
 	s->n_chan = board->num_p0_dio_channels;
-	if (board->reg_type & ni_reg_m_series_mask) {
+	if (devpriv->is_m_series) {
 		s->subdev_flags |=
 		    SDF_LSAMPL | SDF_CMD_WRITE /* | SDF_CMD_READ */;
 		s->insn_bits = &ni_m_series_dio_insn_bits;
@@ -5410,7 +5400,7 @@ static int ni_E_init(struct comedi_device *dev)
 	/* calibration subdevice -- ai and ao */
 	s = &dev->subdevices[NI_CALIBRATION_SUBDEV];
 	s->type = COMEDI_SUBD_CALIB;
-	if (board->reg_type & ni_reg_m_series_mask) {
+	if (devpriv->is_m_series) {
 		/*  internal PWM analog output used for AI nonlinearity calibration */
 		s->subdev_flags = SDF_INTERNAL;
 		s->insn_config = &ni_m_series_pwm_config;
@@ -5435,7 +5425,7 @@ static int ni_E_init(struct comedi_device *dev)
 	s->type = COMEDI_SUBD_MEMORY;
 	s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
 	s->maxdata = 0xff;
-	if (board->reg_type & ni_reg_m_series_mask) {
+	if (devpriv->is_m_series) {
 		s->n_chan = M_SERIES_EEPROM_SIZE;
 		s->insn_read = &ni_m_series_eeprom_insn_read;
 	} else {
@@ -5447,7 +5437,7 @@ static int ni_E_init(struct comedi_device *dev)
 	s = &dev->subdevices[NI_PFI_DIO_SUBDEV];
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-	if (board->reg_type & ni_reg_m_series_mask) {
+	if (devpriv->is_m_series) {
 		unsigned i;
 		s->n_chan = 16;
 		devpriv->writew(dev, s->state, M_Offset_PFI_DO);
@@ -5459,7 +5449,7 @@ static int ni_E_init(struct comedi_device *dev)
 		s->n_chan = 10;
 	}
 	s->maxdata = 1;
-	if (board->reg_type & ni_reg_m_series_mask)
+	if (devpriv->is_m_series)
 		s->insn_bits = &ni_pfi_insn_bits;
 	s->insn_config = &ni_pfi_insn_config;
 	ni_set_bits(dev, IO_Bidirection_Pin_Register, ~0, 0);
@@ -5500,7 +5490,7 @@ static int ni_E_init(struct comedi_device *dev)
 	s->insn_config = ni_rtsi_insn_config;
 	ni_rtsi_init(dev);
 
-	if (board->reg_type & ni_reg_m_series_mask)
+	if (devpriv->is_m_series)
 		counter_variant = ni_gpct_variant_m_series;
 	else
 		counter_variant = ni_gpct_variant_e_series;
@@ -5518,7 +5508,7 @@ static int ni_E_init(struct comedi_device *dev)
 		s->type = COMEDI_SUBD_COUNTER;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
 		s->n_chan = 3;
-		if (board->reg_type & ni_reg_m_series_mask)
+		if (devpriv->is_m_series)
 			s->maxdata = 0xffffffff;
 		else
 			s->maxdata = 0xffffff;
@@ -5592,7 +5582,7 @@ static int ni_E_init(struct comedi_device *dev)
 
 	if (board->reg_type & ni_reg_6xxx_mask) {
 		devpriv->writeb(dev, 0, Magic_611x);
-	} else if (board->reg_type & ni_reg_m_series_mask) {
+	} else if (devpriv->is_m_series) {
 		int channel;
 		for (channel = 0; channel < board->n_aochan; ++channel) {
 			devpriv->writeb(dev, 0xf,

commit 9c340ac934dbbfd46e776465b08391baac32d486
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 29 10:56:32 2014 -0700

    staging: comedi: ni_stc.h: add read/write callbacks to struct ni_private
    
    The {read,write}[bwl] macros used to access the registers in the ni_atmio,
    ni_mio_cs, and ni_pcimio drivers and the included ni_mio_common.c file all
    rely on a local variable having a specific name. They also require some of
    the ni_mio_common code to need a __maybe_unused tag on the devpriv local
    variable.
    
    Remove all the macros by converting them into private functions and storing
    the callbacks in the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 45c42089f690..7632bd6cafc1 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -275,12 +275,12 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 	case AI_AO_Select:
 		devpriv->ai_ao_select_reg &= ~bit_mask;
 		devpriv->ai_ao_select_reg |= bit_values & bit_mask;
-		ni_writeb(devpriv->ai_ao_select_reg, AI_AO_Select);
+		devpriv->writeb(dev, devpriv->ai_ao_select_reg, AI_AO_Select);
 		break;
 	case G0_G1_Select:
 		devpriv->g0_g1_select_reg &= ~bit_mask;
 		devpriv->g0_g1_select_reg |= bit_values & bit_mask;
-		ni_writeb(devpriv->g0_g1_select_reg, G0_G1_Select);
+		devpriv->writeb(dev, devpriv->g0_g1_select_reg, G0_G1_Select);
 		break;
 	default:
 		printk("Warning %s() called with invalid register\n", __func__);
@@ -356,7 +356,7 @@ static inline void ni_set_cdo_dma_channel(struct comedi_device *dev,
 		    (ni_stc_dma_channel_select_bitfield(mite_channel) <<
 		     CDO_DMA_Select_Shift) & CDO_DMA_Select_Mask;
 	}
-	ni_writeb(devpriv->cdio_dma_select_reg, M_Offset_CDIO_DMA_Select);
+	devpriv->writeb(dev, devpriv->cdio_dma_select_reg, M_Offset_CDIO_DMA_Select);
 	mmiowb();
 	spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
 }
@@ -572,11 +572,11 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 
 	if (board->reg_type == ni_reg_6143) {
 		/*  Flush the 6143 data FIFO */
-		ni_writel(0x10, AIFIFO_Control_6143);	/*  Flush fifo */
-		ni_writel(0x00, AIFIFO_Control_6143);	/*  Flush fifo */
+		devpriv->writel(dev, 0x10, AIFIFO_Control_6143);
+		devpriv->writel(dev, 0x00, AIFIFO_Control_6143);
 		/*  Wait for complete */
 		for (i = 0; i < timeout; i++) {
-			if (!(ni_readl(AIFIFO_Status_6143) & 0x10))
+			if (!(devpriv->readl(dev, AIFIFO_Status_6143) & 0x10))
 				break;
 			udelay(1);
 		}
@@ -586,8 +586,8 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 	} else {
 		devpriv->stc_writew(dev, 1, ADC_FIFO_Clear);
 		if (board->reg_type == ni_reg_625x) {
-			ni_writeb(0, M_Offset_Static_AI_Control(0));
-			ni_writeb(1, M_Offset_Static_AI_Control(0));
+			devpriv->writeb(dev, 0, M_Offset_Static_AI_Control(0));
+			devpriv->writeb(dev, 1, M_Offset_Static_AI_Control(0));
 #if 0
 			/* the NI example code does 3 convert pulses for 625x boards,
 			   but that appears to be wrong in practice. */
@@ -628,8 +628,8 @@ static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data,
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->window_lock, flags);
-	ni_writew(addr, AO_Window_Address_611x);
-	ni_writew(data, AO_Window_Data_611x);
+	devpriv->writew(dev, addr, AO_Window_Address_611x);
+	devpriv->writew(dev, data, AO_Window_Data_611x);
 	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
@@ -640,8 +640,8 @@ static inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data,
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->window_lock, flags);
-	ni_writew(addr, AO_Window_Address_611x);
-	ni_writel(data, AO_Window_Data_611x);
+	devpriv->writew(dev, addr, AO_Window_Address_611x);
+	devpriv->writel(dev, data, AO_Window_Data_611x);
 	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
@@ -652,8 +652,8 @@ static inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)
 	unsigned short data;
 
 	spin_lock_irqsave(&devpriv->window_lock, flags);
-	ni_writew(addr, AO_Window_Address_611x);
-	data = ni_readw(AO_Window_Data_611x);
+	devpriv->writew(dev, addr, AO_Window_Address_611x);
+	data = devpriv->readw(dev, AO_Window_Data_611x);
 	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 	return data;
 }
@@ -770,6 +770,7 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 			    struct comedi_subdevice *s, int n)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	int chan;
@@ -798,9 +799,9 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 				i++;
 				packed_data |= (d << 16) & 0xffff0000;
 			}
-			ni_writel(packed_data, DAC_FIFO_Data_611x);
+			devpriv->writel(dev, packed_data, DAC_FIFO_Data_611x);
 		} else {
-			ni_writew(d, DAC_FIFO_Data);
+			devpriv->writew(dev, d, DAC_FIFO_Data);
 		}
 		chan++;
 		chan %= cmd->chanlist_len;
@@ -888,7 +889,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 		u32 dl;
 
 		for (i = 0; i < n / 2; i++) {
-			dl = ni_readl(ADC_FIFO_Data_611x);
+			dl = devpriv->readl(dev, ADC_FIFO_Data_611x);
 			/* This may get the hi/lo data in the wrong order */
 			data[0] = (dl >> 16) & 0xffff;
 			data[1] = dl & 0xffff;
@@ -896,7 +897,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 		}
 		/* Check if there's a single sample stuck in the FIFO */
 		if (n % 2) {
-			dl = ni_readl(ADC_FIFO_Data_611x);
+			dl = devpriv->readl(dev, ADC_FIFO_Data_611x);
 			data[0] = dl & 0xffff;
 			cfc_write_to_buffer(s, data[0]);
 		}
@@ -906,7 +907,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 
 		/*  This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed */
 		for (i = 0; i < n / 2; i++) {
-			dl = ni_readl(AIFIFO_Data_6143);
+			dl = devpriv->readl(dev, AIFIFO_Data_6143);
 
 			data[0] = (dl >> 16) & 0xffff;
 			data[1] = dl & 0xffff;
@@ -914,8 +915,9 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 		}
 		if (n % 2) {
 			/* Assume there is a single sample stuck in the FIFO */
-			ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
-			dl = ni_readl(AIFIFO_Data_6143);
+			/* Get stranded sample into FIFO */
+			devpriv->writel(dev, 0x01, AIFIFO_Control_6143);
+			dl = devpriv->readl(dev, AIFIFO_Data_6143);
 			data[0] = (dl >> 16) & 0xffff;
 			cfc_write_to_buffer(s, data[0]);
 		}
@@ -928,7 +930,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 		}
 		for (i = 0; i < n; i++) {
 			devpriv->ai_fifo_buffer[i] =
-			    ni_readw(ADC_FIFO_Data_Register);
+			    devpriv->readw(dev, ADC_FIFO_Data_Register);
 		}
 		cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
 					  n *
@@ -965,7 +967,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 		while ((devpriv->stc_readw(dev,
 					   AI_Status_1_Register) &
 			AI_FIFO_Empty_St) == 0) {
-			dl = ni_readl(ADC_FIFO_Data_611x);
+			dl = devpriv->readl(dev, ADC_FIFO_Data_611x);
 
 			/* This may get the hi/lo data in the wrong order */
 			data[0] = (dl >> 16);
@@ -974,8 +976,8 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 		}
 	} else if (board->reg_type == ni_reg_6143) {
 		i = 0;
-		while (ni_readl(AIFIFO_Status_6143) & 0x04) {
-			dl = ni_readl(AIFIFO_Data_6143);
+		while (devpriv->readl(dev, AIFIFO_Status_6143) & 0x04) {
+			dl = devpriv->readl(dev, AIFIFO_Data_6143);
 
 			/* This may get the hi/lo data in the wrong order */
 			data[0] = (dl >> 16);
@@ -984,9 +986,10 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 			i += 2;
 		}
 		/*  Check if stranded sample is present */
-		if (ni_readl(AIFIFO_Status_6143) & 0x01) {
-			ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
-			dl = ni_readl(AIFIFO_Data_6143);
+		if (devpriv->readl(dev, AIFIFO_Status_6143) & 0x01) {
+			/* Get stranded sample into FIFO */
+			devpriv->writel(dev, 0x01, AIFIFO_Control_6143);
+			dl = devpriv->readl(dev, AIFIFO_Data_6143);
 			data[0] = (dl >> 16) & 0xffff;
 			cfc_write_to_buffer(s, data[0]);
 		}
@@ -1007,7 +1010,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 				if (fifo_empty)
 					break;
 				devpriv->ai_fifo_buffer[i] =
-				    ni_readw(ADC_FIFO_Data_Register);
+				    devpriv->readw(dev, ADC_FIFO_Data_Register);
 			}
 			cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
 						  i *
@@ -1020,7 +1023,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 static void get_last_sample_611x(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv __maybe_unused = dev->private;
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned short data;
 	u32 dl;
@@ -1029,8 +1032,8 @@ static void get_last_sample_611x(struct comedi_device *dev)
 		return;
 
 	/* Check if there's a single sample stuck in the FIFO */
-	if (ni_readb(XXX_Status) & 0x80) {
-		dl = ni_readl(ADC_FIFO_Data_611x);
+	if (devpriv->readb(dev, XXX_Status) & 0x80) {
+		dl = devpriv->readl(dev, ADC_FIFO_Data_611x);
 		data = (dl & 0xffff);
 		cfc_write_to_buffer(s, data);
 	}
@@ -1039,7 +1042,7 @@ static void get_last_sample_611x(struct comedi_device *dev)
 static void get_last_sample_6143(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv __maybe_unused = dev->private;
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned short data;
 	u32 dl;
@@ -1048,9 +1051,10 @@ static void get_last_sample_6143(struct comedi_device *dev)
 		return;
 
 	/* Check if there's a single sample stuck in the FIFO */
-	if (ni_readl(AIFIFO_Status_6143) & 0x01) {
-		ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
-		dl = ni_readl(AIFIFO_Data_6143);
+	if (devpriv->readl(dev, AIFIFO_Status_6143) & 0x01) {
+		/* Get stranded sample into FIFO */
+		devpriv->writel(dev, 0x01, AIFIFO_Control_6143);
+		dl = devpriv->readl(dev, AIFIFO_Data_6143);
 
 		/* This may get the hi/lo data in the wrong order */
 		data = (dl >> 16) & 0xffff;
@@ -1416,7 +1420,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_clear_ai_fifo(dev);
 
 	if (board->reg_type != ni_reg_6143)
-		ni_writeb(0, Misc_Command);
+		devpriv->writeb(dev, 0, Misc_Command);
 
 	devpriv->stc_writew(dev, AI_Disarm, AI_Command_1_Register);	/* reset pulses */
 	devpriv->stc_writew(dev,
@@ -1560,9 +1564,10 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 			bypass_bits |= MSeries_AI_Bypass_Dither_Bit;
 		/*  don't use 2's complement encoding */
 		bypass_bits |= MSeries_AI_Bypass_Polarity_Bit;
-		ni_writel(bypass_bits, M_Offset_AI_Config_FIFO_Bypass);
+		devpriv->writel(dev, bypass_bits,
+				M_Offset_AI_Config_FIFO_Bypass);
 	} else {
-		ni_writel(0, M_Offset_AI_Config_FIFO_Bypass);
+		devpriv->writel(dev, 0, M_Offset_AI_Config_FIFO_Bypass);
 	}
 	offset = 0;
 	for (i = 0; i < n_chan; i++) {
@@ -1600,7 +1605,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 			config_bits |= MSeries_AI_Config_Dither_Bit;
 		/*  don't use 2's complement encoding */
 		config_bits |= MSeries_AI_Config_Polarity_Bit;
-		ni_writew(config_bits, M_Offset_AI_Config_FIFO_Data);
+		devpriv->writew(dev, config_bits, M_Offset_AI_Config_FIFO_Data);
 	}
 	ni_prime_channelgain_list(dev);
 }
@@ -1669,21 +1674,21 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		if ((list[0] & CR_ALT_SOURCE)
 		    && !devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay enable bit */
-			ni_writew(devpriv->ai_calib_source |
-				  Calibration_Channel_6143_RelayOn,
-				  Calibration_Channel_6143);
-			ni_writew(devpriv->ai_calib_source,
-				  Calibration_Channel_6143);
+			devpriv->writew(dev, devpriv->ai_calib_source |
+					     Calibration_Channel_6143_RelayOn,
+					Calibration_Channel_6143);
+			devpriv->writew(dev, devpriv->ai_calib_source,
+					Calibration_Channel_6143);
 			devpriv->ai_calib_source_enabled = 1;
 			msleep_interruptible(100);	/*  Allow relays to change */
 		} else if (!(list[0] & CR_ALT_SOURCE)
 			   && devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay disable bit */
-			ni_writew(devpriv->ai_calib_source |
-				  Calibration_Channel_6143_RelayOff,
-				  Calibration_Channel_6143);
-			ni_writew(devpriv->ai_calib_source,
-				  Calibration_Channel_6143);
+			devpriv->writew(dev, devpriv->ai_calib_source |
+					     Calibration_Channel_6143_RelayOff,
+					Calibration_Channel_6143);
+			devpriv->writew(dev, devpriv->ai_calib_source,
+					Calibration_Channel_6143);
 			devpriv->ai_calib_source_enabled = 0;
 			msleep_interruptible(100);	/*  Allow relays to change */
 		}
@@ -1711,8 +1716,8 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		hi = 0;
 		if ((list[i] & CR_ALT_SOURCE)) {
 			if (board->reg_type == ni_reg_611x)
-				ni_writew(CR_CHAN(list[i]) & 0x0003,
-					  Calibration_Channel_Select_611x);
+				devpriv->writew(dev, CR_CHAN(list[i]) & 0x0003,
+					Calibration_Channel_Select_611x);
 		} else {
 			if (board->reg_type == ni_reg_611x)
 				aref = AREF_DIFF;
@@ -1734,7 +1739,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		}
 		hi |= AI_CONFIG_CHANNEL(chan);
 
-		ni_writew(hi, Configuration_Memory_High);
+		devpriv->writew(dev, hi, Configuration_Memory_High);
 
 		if (board->reg_type != ni_reg_6143) {
 			lo = range;
@@ -1743,7 +1748,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 			if (dither)
 				lo |= AI_DITHER;
 
-			ni_writew(lo, Configuration_Memory_Low);
+			devpriv->writew(dev, lo, Configuration_Memory_Low);
 		}
 	}
 
@@ -1784,16 +1789,19 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			/* The 611x has screwy 32-bit FIFOs. */
 			d = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
-				if (ni_readb(XXX_Status) & 0x80) {
-					d = (ni_readl(ADC_FIFO_Data_611x) >> 16)
-					    & 0xffff;
+				if (devpriv->readb(dev, XXX_Status) & 0x80) {
+					d = devpriv->readl(dev,
+							   ADC_FIFO_Data_611x);
+					d >>= 16;
+					d &= 0xffff;
 					break;
 				}
 				if (!(devpriv->stc_readw(dev,
 							 AI_Status_1_Register) &
 				      AI_FIFO_Empty_St)) {
-					d = ni_readl(ADC_FIFO_Data_611x) &
-					    0xffff;
+					d = devpriv->readl(dev,
+							   ADC_FIFO_Data_611x);
+					d &= 0xffff;
 					break;
 				}
 			}
@@ -1813,9 +1821,13 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			/* The 6143 has 32-bit FIFOs. You need to strobe a bit to move a single 16bit stranded sample into the FIFO */
 			dl = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
-				if (ni_readl(AIFIFO_Status_6143) & 0x01) {
-					ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
-					dl = ni_readl(AIFIFO_Data_6143);
+				if (devpriv->readl(dev, AIFIFO_Status_6143) &
+				    0x01) {
+					/* Get stranded sample into FIFO */
+					devpriv->writel(dev, 0x01,
+							AIFIFO_Control_6143);
+					dl = devpriv->readl(dev,
+							    AIFIFO_Data_6143);
 					break;
 				}
 			}
@@ -1842,10 +1854,11 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				return -ETIME;
 			}
 			if (board->reg_type & ni_reg_m_series_mask) {
-				data[n] =
-				    ni_readl(M_Offset_AI_FIFO_Data) & mask;
+				dl = devpriv->readl(dev, M_Offset_AI_FIFO_Data);
+				dl &= mask;
+				data[n] = dl;
 			} else {
-				d = ni_readw(ADC_FIFO_Data_Register);
+				d = devpriv->readw(dev, ADC_FIFO_Data_Register);
 				d += signbits;	/* subtle: needs to be short addition */
 				data[n] = d;
 			}
@@ -2500,7 +2513,8 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 				return -EINVAL;
 
 			devpriv->ai_calib_source = calib_source;
-			ni_writew(calib_source, Calibration_Channel_6143);
+			devpriv->writew(dev, calib_source,
+					Calibration_Channel_6143);
 		} else {
 			unsigned int calib_source;
 			unsigned int calib_source_adjust;
@@ -2512,8 +2526,8 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 				return -EINVAL;
 			devpriv->ai_calib_source = calib_source;
 			if (board->reg_type == ni_reg_611x) {
-				ni_writeb(calib_source_adjust,
-					  Cal_Gain_Select_611x);
+				devpriv->writeb(dev, calib_source_adjust,
+						Cal_Gain_Select_611x);
 			}
 		}
 		return 2;
@@ -2566,9 +2580,10 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 	if (timed) {
 		for (i = 0; i < board->n_aochan; ++i) {
 			devpriv->ao_conf[i] &= ~MSeries_AO_Update_Timed_Bit;
-			ni_writeb(devpriv->ao_conf[i],
-				  M_Offset_AO_Config_Bank(i));
-			ni_writeb(0xf, M_Offset_AO_Waveform_Order(i));
+			devpriv->writeb(dev, devpriv->ao_conf[i],
+					M_Offset_AO_Config_Bank(i));
+			devpriv->writeb(dev, 0xf,
+					M_Offset_AO_Waveform_Order(i));
 		}
 	}
 	for (i = 0; i < n_chans; i++) {
@@ -2581,21 +2596,23 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 		switch (krange->max - krange->min) {
 		case 20000000:
 			conf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;
-			ni_writeb(0, M_Offset_AO_Reference_Attenuation(chan));
+			devpriv->writeb(dev, 0,
+					M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		case 10000000:
 			conf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;
-			ni_writeb(0, M_Offset_AO_Reference_Attenuation(chan));
+			devpriv->writeb(dev, 0,
+					M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		case 4000000:
 			conf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;
-			ni_writeb(MSeries_Attenuate_x5_Bit,
-				  M_Offset_AO_Reference_Attenuation(chan));
+			devpriv->writeb(dev, MSeries_Attenuate_x5_Bit,
+					M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		case 2000000:
 			conf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;
-			ni_writeb(MSeries_Attenuate_x5_Bit,
-				  M_Offset_AO_Reference_Attenuation(chan));
+			devpriv->writeb(dev, MSeries_Attenuate_x5_Bit,
+					M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		default:
 			printk("%s: bug! unhandled ao reference voltage\n",
@@ -2616,9 +2633,9 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 		}
 		if (timed)
 			conf |= MSeries_AO_Update_Timed_Bit;
-		ni_writeb(conf, M_Offset_AO_Config_Bank(chan));
+		devpriv->writeb(dev, conf, M_Offset_AO_Config_Bank(chan));
 		devpriv->ao_conf[chan] = conf;
-		ni_writeb(i, M_Offset_AO_Waveform_Order(chan));
+		devpriv->writeb(dev, i, M_Offset_AO_Waveform_Order(chan));
 	}
 	return invert;
 }
@@ -2664,7 +2681,7 @@ static int ni_old_ao_config_chanlist(struct comedi_device *dev,
 		conf |= (CR_AREF(chanspec[i]) ==
 			 AREF_OTHER) ? AO_Ground_Ref : 0;
 
-		ni_writew(conf, AO_Configuration);
+		devpriv->writew(dev, conf, AO_Configuration);
 		devpriv->ao_conf[chan] = conf;
 	}
 	return invert;
@@ -2709,10 +2726,10 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 	devpriv->ao[chan] = data[0];
 
 	if (board->reg_type & ni_reg_m_series_mask) {
-		ni_writew(data[0], M_Offset_DAC_Direct_Data(chan));
+		devpriv->writew(dev, data[0], M_Offset_DAC_Direct_Data(chan));
 	} else
-		ni_writew(data[0] ^ invert,
-			  (chan) ? DAC1_Direct_Data : DAC0_Direct_Data);
+		devpriv->writew(dev, data[0] ^ invert,
+				(chan) ? DAC1_Direct_Data : DAC0_Direct_Data);
 
 	return 1;
 }
@@ -3225,14 +3242,14 @@ static int ni_m_series_dio_insn_config(struct comedi_device *dev,
 				       struct comedi_insn *insn,
 				       unsigned int *data)
 {
-	struct ni_private *devpriv __maybe_unused = dev->private;
+	struct ni_private *devpriv = dev->private;
 	int ret;
 
 	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
 	if (ret)
 		return ret;
 
-	ni_writel(s->io_bits, M_Offset_DIO_Direction);
+	devpriv->writel(dev, s->io_bits, M_Offset_DIO_Direction);
 
 	return insn->n;
 }
@@ -3242,12 +3259,12 @@ static int ni_m_series_dio_insn_bits(struct comedi_device *dev,
 				     struct comedi_insn *insn,
 				     unsigned int *data)
 {
-	struct ni_private *devpriv __maybe_unused = dev->private;
+	struct ni_private *devpriv = dev->private;
 
 	if (comedi_dio_update_state(s, data))
-		ni_writel(s->state, M_Offset_Static_Digital_Output);
+		devpriv->writel(dev, s->state, M_Offset_Static_Digital_Output);
 
-	data[1] = ni_readl(M_Offset_Static_Digital_Input);
+	data[1] = devpriv->readl(dev, M_Offset_Static_Digital_Input);
 
 	return insn->n;
 }
@@ -3326,14 +3343,14 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 			  struct comedi_subdevice *s,
 			  unsigned int trig_num)
 {
-#ifdef PCIDMA
 	struct ni_private *devpriv = dev->private;
-	unsigned long flags;
-#endif
 	struct comedi_cmd *cmd = &s->async->cmd;
+	const unsigned timeout = 1000;
 	int retval = 0;
 	unsigned i;
-	const unsigned timeout = 1000;
+#ifdef PCIDMA
+	unsigned long flags;
+#endif
 
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
@@ -3358,11 +3375,12 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 #endif
 /*
 * XXX not sure what interrupt C group does
-* ni_writeb(Interrupt_Group_C_Enable_Bit,
+* devpriv->writeb(dev, Interrupt_Group_C_Enable_Bit,
 * M_Offset_Interrupt_C_Enable); wait for dma to fill output fifo
 */
 	for (i = 0; i < timeout; ++i) {
-		if (ni_readl(M_Offset_CDIO_Status) & CDO_FIFO_Full_Bit)
+		if (devpriv->readl(dev, M_Offset_CDIO_Status) &
+		    CDO_FIFO_Full_Bit)
 			break;
 		udelay(10);
 	}
@@ -3371,20 +3389,20 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 		s->cancel(dev, s);
 		return -EIO;
 	}
-	ni_writel(CDO_Arm_Bit | CDO_Error_Interrupt_Enable_Set_Bit |
-		  CDO_Empty_FIFO_Interrupt_Enable_Set_Bit,
-		  M_Offset_CDIO_Command);
+	devpriv->writel(dev, CDO_Arm_Bit | CDO_Error_Interrupt_Enable_Set_Bit |
+			     CDO_Empty_FIFO_Interrupt_Enable_Set_Bit,
+			M_Offset_CDIO_Command);
 	return retval;
 }
 
 static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct ni_private *devpriv __maybe_unused = dev->private;
+	struct ni_private *devpriv = dev->private;
 	const struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;
 	int retval;
 
-	ni_writel(CDO_Reset_Bit, M_Offset_CDIO_Command);
+	devpriv->writel(dev, CDO_Reset_Bit, M_Offset_CDIO_Command);
 	switch (cmd->scan_begin_src) {
 	case TRIG_EXT:
 		cdo_mode_bits |=
@@ -3397,11 +3415,11 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	if (cmd->scan_begin_arg & CR_INVERT)
 		cdo_mode_bits |= CDO_Polarity_Bit;
-	ni_writel(cdo_mode_bits, M_Offset_CDO_Mode);
+	devpriv->writel(dev, cdo_mode_bits, M_Offset_CDO_Mode);
 	if (s->io_bits) {
-		ni_writel(s->state, M_Offset_CDO_FIFO_Data);
-		ni_writel(CDO_SW_Update_Bit, M_Offset_CDIO_Command);
-		ni_writel(s->io_bits, M_Offset_CDO_Mask_Enable);
+		devpriv->writel(dev, s->state, M_Offset_CDO_FIFO_Data);
+		devpriv->writel(dev, CDO_SW_Update_Bit, M_Offset_CDIO_Command);
+		devpriv->writel(dev, s->io_bits, M_Offset_CDO_Mask_Enable);
 	} else {
 		comedi_error(dev,
 			     "attempted to run digital output command with no lines configured as outputs");
@@ -3418,17 +3436,18 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct ni_private *devpriv __maybe_unused = dev->private;
+	struct ni_private *devpriv = dev->private;
 
-	ni_writel(CDO_Disarm_Bit | CDO_Error_Interrupt_Enable_Clear_Bit |
-		  CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
-		  CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
-		  M_Offset_CDIO_Command);
+	devpriv->writel(dev, CDO_Disarm_Bit |
+			     CDO_Error_Interrupt_Enable_Clear_Bit |
+			     CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
+			     CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
+			M_Offset_CDIO_Command);
 /*
-* XXX not sure what interrupt C group does ni_writeb(0,
+* XXX not sure what interrupt C group does devpriv->writeb(dev, 0,
 * M_Offset_Interrupt_C_Enable);
 */
-	ni_writel(0, M_Offset_CDO_Mask_Enable);
+	devpriv->writel(dev, 0, M_Offset_CDO_Mask_Enable);
 	ni_release_cdo_mite_channel(dev);
 	return 0;
 }
@@ -3436,7 +3455,7 @@ static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static void handle_cdio_interrupt(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv __maybe_unused = dev->private;
+	struct ni_private *devpriv = dev->private;
 	unsigned cdio_status;
 	struct comedi_subdevice *s = &dev->subdevices[NI_DIO_SUBDEV];
 #ifdef PCIDMA
@@ -3460,16 +3479,18 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif
 
-	cdio_status = ni_readl(M_Offset_CDIO_Status);
+	cdio_status = devpriv->readl(dev, M_Offset_CDIO_Status);
 	if (cdio_status & (CDO_Overrun_Bit | CDO_Underflow_Bit)) {
 		/* printk("cdio error: statux=0x%x\n", cdio_status); */
-		ni_writel(CDO_Error_Interrupt_Confirm_Bit, M_Offset_CDIO_Command);	/*  XXX just guessing this is needed and does something useful */
+		/* XXX just guessing this is needed and does something useful */
+		devpriv->writel(dev, CDO_Error_Interrupt_Confirm_Bit,
+				M_Offset_CDIO_Command);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 	if (cdio_status & CDO_FIFO_Empty_Bit) {
 		/* printk("cdio fifo empty\n"); */
-		ni_writel(CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
-			  M_Offset_CDIO_Command);
+		devpriv->writel(dev, CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
+				M_Offset_CDIO_Command);
 		/* s->async->events |= COMEDI_CB_EOA; */
 	}
 	cfc_handle_events(dev, s);
@@ -3786,28 +3807,28 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 	switch (reg) {
 		/* m-series-only registers */
 	case NITIO_G0_CNT_MODE:
-		ni_writew(bits, M_Offset_G0_Counting_Mode);
+		devpriv->writew(dev, bits, M_Offset_G0_Counting_Mode);
 		break;
 	case NITIO_G1_CNT_MODE:
-		ni_writew(bits, M_Offset_G1_Counting_Mode);
+		devpriv->writew(dev, bits, M_Offset_G1_Counting_Mode);
 		break;
 	case NITIO_G0_GATE2:
-		ni_writew(bits, M_Offset_G0_Second_Gate);
+		devpriv->writew(dev, bits, M_Offset_G0_Second_Gate);
 		break;
 	case NITIO_G1_GATE2:
-		ni_writew(bits, M_Offset_G1_Second_Gate);
+		devpriv->writew(dev, bits, M_Offset_G1_Second_Gate);
 		break;
 	case NITIO_G0_DMA_CFG:
-		ni_writew(bits, M_Offset_G0_DMA_Config);
+		devpriv->writew(dev, bits, M_Offset_G0_DMA_Config);
 		break;
 	case NITIO_G1_DMA_CFG:
-		ni_writew(bits, M_Offset_G1_DMA_Config);
+		devpriv->writew(dev, bits, M_Offset_G1_DMA_Config);
 		break;
 	case NITIO_G0_ABZ:
-		ni_writew(bits, M_Offset_G0_MSeries_ABZ);
+		devpriv->writew(dev, bits, M_Offset_G0_MSeries_ABZ);
 		break;
 	case NITIO_G1_ABZ:
-		ni_writew(bits, M_Offset_G1_MSeries_ABZ);
+		devpriv->writew(dev, bits, M_Offset_G1_MSeries_ABZ);
 		break;
 
 		/* 32 bit registers */
@@ -3849,9 +3870,9 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 	switch (reg) {
 		/* m-series only registers */
 	case NITIO_G0_DMA_STATUS:
-		return ni_readw(M_Offset_G0_DMA_Status);
+		return devpriv->readw(dev, M_Offset_G0_DMA_Status);
 	case NITIO_G1_DMA_STATUS:
-		return ni_readw(M_Offset_G1_DMA_Status);
+		return devpriv->readw(dev, M_Offset_G1_DMA_Status);
 
 		/* 32 bit registers */
 	case NITIO_G0_HW_SAVE:
@@ -3948,13 +3969,13 @@ static int ni_freq_out_insn_config(struct comedi_device *dev,
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 {
 	struct comedi_device *dev = (struct comedi_device *)arg;
-	struct ni_private *devpriv __maybe_unused = dev->private;
+	struct ni_private *devpriv = dev->private;
 
 	if (dir) {
-		ni_writeb(data, Port_A + 2 * port);
+		devpriv->writeb(dev, data, Port_A + 2 * port);
 		return 0;
 	} else {
-		return ni_readb(Port_A + 2 * port);
+		return devpriv->readb(dev, Port_A + 2 * port);
 	}
 }
 
@@ -4019,9 +4040,9 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 			data[4] = down_count * devpriv->clock_ns;
 			return -EAGAIN;
 		}
-		ni_writel(MSeries_Cal_PWM_High_Time_Bits(up_count) |
-			  MSeries_Cal_PWM_Low_Time_Bits(down_count),
-			  M_Offset_Cal_PWM);
+		devpriv->writel(dev, MSeries_Cal_PWM_High_Time_Bits(up_count) |
+				     MSeries_Cal_PWM_Low_Time_Bits(down_count),
+				M_Offset_Cal_PWM);
 		devpriv->pwm_up_count = up_count;
 		devpriv->pwm_down_count = down_count;
 		return 5;
@@ -4088,9 +4109,9 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 			data[4] = down_count * devpriv->clock_ns;
 			return -EAGAIN;
 		}
-		ni_writel(up_count, Calibration_HighTime_6143);
+		devpriv->writel(dev, up_count, Calibration_HighTime_6143);
 		devpriv->pwm_up_count = up_count;
-		ni_writel(down_count, Calibration_LowTime_6143);
+		devpriv->writel(dev, down_count, Calibration_LowTime_6143);
 		devpriv->pwm_down_count = down_count;
 		return 5;
 		break;
@@ -4194,14 +4215,16 @@ static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 	}
 
 	for (bit = 1 << (bits - 1); bit; bit >>= 1) {
-		ni_writeb(((bit & bitstring) ? 0x02 : 0), Serial_Command);
+		devpriv->writeb(dev, ((bit & bitstring) ? 0x02 : 0),
+				Serial_Command);
 		udelay(1);
-		ni_writeb(1 | ((bit & bitstring) ? 0x02 : 0), Serial_Command);
+		devpriv->writeb(dev, 1 | ((bit & bitstring) ? 0x02 : 0),
+				Serial_Command);
 		udelay(1);
 	}
-	ni_writeb(loadbit, Serial_Command);
+	devpriv->writeb(dev, loadbit, Serial_Command);
 	udelay(1);
-	ni_writeb(0, Serial_Command);
+	devpriv->writeb(dev, 0, Serial_Command);
 }
 
 static int ni_calib_insn_write(struct comedi_device *dev,
@@ -4282,25 +4305,26 @@ static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int ni_read_eeprom(struct comedi_device *dev, int addr)
 {
-	struct ni_private *devpriv __maybe_unused = dev->private;
+	struct ni_private *devpriv = dev->private;
 	int bit;
 	int bitstring;
 
 	bitstring = 0x0300 | ((addr & 0x100) << 3) | (addr & 0xff);
-	ni_writeb(0x04, Serial_Command);
+	devpriv->writeb(dev, 0x04, Serial_Command);
 	for (bit = 0x8000; bit; bit >>= 1) {
-		ni_writeb(0x04 | ((bit & bitstring) ? 0x02 : 0),
-			  Serial_Command);
-		ni_writeb(0x05 | ((bit & bitstring) ? 0x02 : 0),
-			  Serial_Command);
+		devpriv->writeb(dev, 0x04 | ((bit & bitstring) ? 0x02 : 0),
+				Serial_Command);
+		devpriv->writeb(dev, 0x05 | ((bit & bitstring) ? 0x02 : 0),
+				Serial_Command);
 	}
 	bitstring = 0;
 	for (bit = 0x80; bit; bit >>= 1) {
-		ni_writeb(0x04, Serial_Command);
-		ni_writeb(0x05, Serial_Command);
-		bitstring |= ((ni_readb(XXX_Status) & PROMOUT) ? bit : 0);
+		devpriv->writeb(dev, 0x04, Serial_Command);
+		devpriv->writeb(dev, 0x05, Serial_Command);
+		bitstring |= ((devpriv->readb(dev, XXX_Status) & PROMOUT)
+				? bit : 0);
 	}
-	ni_writeb(0x00, Serial_Command);
+	devpriv->writeb(dev, 0x00, Serial_Command);
 
 	return bitstring;
 }
@@ -4403,8 +4427,8 @@ static int ni_m_series_set_pfi_routing(struct comedi_device *dev,
 	    ~MSeries_PFI_Output_Select_Mask(chan);
 	devpriv->pfi_output_select_reg[array_offset] |=
 	    MSeries_PFI_Output_Select_Bits(chan, source);
-	ni_writew(devpriv->pfi_output_select_reg[array_offset],
-		  M_Offset_PFI_Output_Select(pfi_reg_index));
+	devpriv->writew(dev, devpriv->pfi_output_select_reg[array_offset],
+			M_Offset_PFI_Output_Select(pfi_reg_index));
 	return 2;
 }
 
@@ -4434,15 +4458,15 @@ static int ni_config_filter(struct comedi_device *dev,
 			    enum ni_pfi_filter_select filter)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv __maybe_unused = dev->private;
+	struct ni_private *devpriv = dev->private;
 	unsigned bits;
 
 	if ((board->reg_type & ni_reg_m_series_mask) == 0)
 		return -ENOTSUPP;
-	bits = ni_readl(M_Offset_PFI_Filter);
+	bits = devpriv->readl(dev, M_Offset_PFI_Filter);
 	bits &= ~MSeries_PFI_Filter_Select_Mask(pfi_channel);
 	bits |= MSeries_PFI_Filter_Select_Bits(pfi_channel, filter);
-	ni_writel(bits, M_Offset_PFI_Filter);
+	devpriv->writel(dev, bits, M_Offset_PFI_Filter);
 	return 0;
 }
 
@@ -4493,15 +4517,15 @@ static int ni_pfi_insn_bits(struct comedi_device *dev,
 			    unsigned int *data)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv __maybe_unused = dev->private;
+	struct ni_private *devpriv = dev->private;
 
 	if (!(board->reg_type & ni_reg_m_series_mask))
 		return -ENOTSUPP;
 
 	if (comedi_dio_update_state(s, data))
-		ni_writew(s->state, M_Offset_PFI_DO);
+		devpriv->writew(dev, s->state, M_Offset_PFI_DO);
 
-	data[1] = ni_readw(M_Offset_PFI_DI);
+	data[1] = devpriv->readw(dev, M_Offset_PFI_DI);
 
 	return insn->n;
 }
@@ -4766,7 +4790,8 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 		}
 		break;
 	}
-	ni_writew(devpriv->clock_and_fout2, M_Offset_Clock_and_Fout2);
+	devpriv->writew(dev, devpriv->clock_and_fout2,
+			M_Offset_Clock_and_Fout2);
 	pll_control_bits |=
 	    MSeries_PLL_Divisor_Bits(freq_divider) |
 	    MSeries_PLL_Multiplier_Bits(freq_multiplier);
@@ -4774,11 +4799,12 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 	/* printk("using divider=%i, multiplier=%i for PLL. pll_control_bits = 0x%x\n",
 	 * freq_divider, freq_multiplier, pll_control_bits); */
 	/* printk("clock_ns=%d\n", devpriv->clock_ns); */
-	ni_writew(pll_control_bits, M_Offset_PLL_Control);
+	devpriv->writew(dev, pll_control_bits, M_Offset_PLL_Control);
 	devpriv->clock_source = source;
 	/* it seems to typically take a few hundred microseconds for PLL to lock */
 	for (i = 0; i < timeout; ++i) {
-		if (ni_readw(M_Offset_PLL_Status) & MSeries_PLL_Locked_Bit)
+		if (devpriv->readw(dev, M_Offset_PLL_Status) &
+		    MSeries_PLL_Locked_Bit)
 			break;
 		udelay(1);
 	}
@@ -4806,9 +4832,9 @@ static int ni_set_master_clock(struct comedi_device *dev,
 			devpriv->clock_and_fout2 &=
 			    ~(MSeries_Timebase1_Select_Bit |
 			      MSeries_Timebase3_Select_Bit);
-			ni_writew(devpriv->clock_and_fout2,
-				  M_Offset_Clock_and_Fout2);
-			ni_writew(0, M_Offset_PLL_Control);
+			devpriv->writew(dev, devpriv->clock_and_fout2,
+					M_Offset_Clock_and_Fout2);
+			devpriv->writew(dev, 0, M_Offset_PLL_Control);
 		}
 		devpriv->clock_source = source;
 	} else {
@@ -5355,13 +5381,15 @@ static int ni_E_init(struct comedi_device *dev)
 		s->async_dma_dir = DMA_BIDIRECTIONAL;
 		s->len_chanlist = s->n_chan;
 
-		ni_writel(CDO_Reset_Bit | CDI_Reset_Bit, M_Offset_CDIO_Command);
-		ni_writel(s->io_bits, M_Offset_DIO_Direction);
+		devpriv->writel(dev, CDO_Reset_Bit | CDI_Reset_Bit,
+				M_Offset_CDIO_Command);
+		devpriv->writel(dev, s->io_bits, M_Offset_DIO_Direction);
 	} else {
 		s->insn_bits = &ni_dio_insn_bits;
 		s->insn_config = &ni_dio_insn_config;
 		devpriv->dio_control = DIO_Pins_Dir(s->io_bits);
-		ni_writew(devpriv->dio_control, DIO_Control_Register);
+		devpriv->writew(dev, devpriv->dio_control,
+				DIO_Control_Register);
 	}
 
 	/* 8255 device */
@@ -5388,7 +5416,7 @@ static int ni_E_init(struct comedi_device *dev)
 		s->insn_config = &ni_m_series_pwm_config;
 		s->n_chan = 1;
 		s->maxdata = 0;
-		ni_writel(0x0, M_Offset_Cal_PWM);
+		devpriv->writel(dev, 0x0, M_Offset_Cal_PWM);
 	} else if (board->reg_type == ni_reg_6143) {
 		/*  internal PWM analog output used for AI nonlinearity calibration */
 		s->subdev_flags = SDF_INTERNAL;
@@ -5422,10 +5450,10 @@ static int ni_E_init(struct comedi_device *dev)
 	if (board->reg_type & ni_reg_m_series_mask) {
 		unsigned i;
 		s->n_chan = 16;
-		ni_writew(s->state, M_Offset_PFI_DO);
+		devpriv->writew(dev, s->state, M_Offset_PFI_DO);
 		for (i = 0; i < NUM_PFI_OUTPUT_SELECT_REGS; ++i) {
-			ni_writew(devpriv->pfi_output_select_reg[i],
-				  M_Offset_PFI_Output_Select(i + 1));
+			devpriv->writew(dev, devpriv->pfi_output_select_reg[i],
+					M_Offset_PFI_Output_Select(i + 1));
 		}
 	} else {
 		s->n_chan = 10;
@@ -5559,19 +5587,20 @@ static int ni_E_init(struct comedi_device *dev)
 	}
 
 	/* DMA setup */
-	ni_writeb(devpriv->ai_ao_select_reg, AI_AO_Select);
-	ni_writeb(devpriv->g0_g1_select_reg, G0_G1_Select);
+	devpriv->writeb(dev, devpriv->ai_ao_select_reg, AI_AO_Select);
+	devpriv->writeb(dev, devpriv->g0_g1_select_reg, G0_G1_Select);
 
 	if (board->reg_type & ni_reg_6xxx_mask) {
-		ni_writeb(0, Magic_611x);
+		devpriv->writeb(dev, 0, Magic_611x);
 	} else if (board->reg_type & ni_reg_m_series_mask) {
 		int channel;
 		for (channel = 0; channel < board->n_aochan; ++channel) {
-			ni_writeb(0xf, M_Offset_AO_Waveform_Order(channel));
-			ni_writeb(0x0,
-				  M_Offset_AO_Reference_Attenuation(channel));
+			devpriv->writeb(dev, 0xf,
+					M_Offset_AO_Waveform_Order(channel));
+			devpriv->writeb(dev, 0x0,
+					M_Offset_AO_Reference_Attenuation(channel));
 		}
-		ni_writeb(0x0, M_Offset_AO_Calibration);
+		devpriv->writeb(dev, 0x0, M_Offset_AO_Calibration);
 	}
 
 	return 0;

commit 9588fa8fe908c5501de5076de9a0c9d44ef737ec
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 29 10:56:31 2014 -0700

    staging: comedi: ni_stc.h: remove unused members from struct ni_private
    
    Remove all the unsed members from the private data for the ni mio drivers.
    
    The ao0p and ao1p members are only used in the ni_ao_reset() function and
    the code is commented out. Remove them, and the commented out code, as well.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 68cd92bf17c6..45c42089f690 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3136,12 +3136,6 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
-	/* devpriv->ao0p=0x0000; */
-	/* ni_writew(devpriv->ao0p,AO_Configuration); */
-
-	/* devpriv->ao1p=AO_Channel(1); */
-	/* ni_writew(devpriv->ao1p,AO_Configuration); */
-
 	ni_release_ao_mite_channel(dev);
 
 	devpriv->stc_writew(dev, AO_Configuration_Start, Joint_Reset_Register);

commit d9c4261f6a35bf9067ba0fdaf8ed4775ee0c5cea
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:54 2014 -0700

    staging: comedi: ni_mio_common: fix the (*insn_read) for the freq_out counter
    
    The (*insn_read) functions are supposed to "read" insn->n data values and
    return the number of values read.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 69be8eaff7ac..68cd92bf17c6 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3878,12 +3878,17 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 
 static int ni_freq_out_insn_read(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn, unsigned int *data)
+				 struct comedi_insn *insn,
+				 unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
+	unsigned int val = devpriv->clock_and_fout & FOUT_Divider_mask;
+	int i;
 
-	data[0] = devpriv->clock_and_fout & FOUT_Divider_mask;
-	return 1;
+	for (i = 0; i < insn->n; i++)
+		data[i] = val;
+
+	return insn->n;
 }
 
 static int ni_freq_out_insn_write(struct comedi_device *dev,

commit 00a92c03be9ff392383e18ba222d480fc34d568c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:53 2014 -0700

    staging: comedi: ni_mio_common: fix the (*insn_write) for the freq_out counter
    
    The (*insn_write) functions are supposed to write insn->n data values and
    return the number of values written. For this subdevice it only makes sense
    to write the last data value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 6536d68eb716..69be8eaff7ac 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3888,18 +3888,24 @@ static int ni_freq_out_insn_read(struct comedi_device *dev,
 
 static int ni_freq_out_insn_write(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data)
+				  struct comedi_insn *insn,
+				  unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
 
-	devpriv->clock_and_fout &= ~FOUT_Enable;
-	devpriv->stc_writew(dev, devpriv->clock_and_fout,
-			    Clock_and_FOUT_Register);
-	devpriv->clock_and_fout &= ~FOUT_Divider_mask;
-	devpriv->clock_and_fout |= FOUT_Divider(data[0]);
-	devpriv->clock_and_fout |= FOUT_Enable;
-	devpriv->stc_writew(dev, devpriv->clock_and_fout,
-			    Clock_and_FOUT_Register);
+	if (insn->n) {
+		devpriv->clock_and_fout &= ~FOUT_Enable;
+		devpriv->stc_writew(dev, devpriv->clock_and_fout,
+				    Clock_and_FOUT_Register);
+		devpriv->clock_and_fout &= ~FOUT_Divider_mask;
+
+		/* use the last data value to set the fout divider */
+		devpriv->clock_and_fout |= FOUT_Divider(data[insn->n - 1]);
+
+		devpriv->clock_and_fout |= FOUT_Enable;
+		devpriv->stc_writew(dev, devpriv->clock_and_fout,
+				    Clock_and_FOUT_Register);
+	}
 	return insn->n;
 }
 

commit e63dabd00ba02921933a2f7bd46f72874d07dc01
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:52 2014 -0700

    staging: comedi: ni_mio_common: absorb helpers into ni_freq_out_insn_config()
    
    Absorb the helper functions that handle the INSN_CONFIG_SET_CLOCK_SRC and
    INSN_CONFIG_GET_CLOCK_SRC comedi instructions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0bffc56b73cc..6536d68eb716 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3903,56 +3903,41 @@ static int ni_freq_out_insn_write(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int ni_set_freq_out_clock(struct comedi_device *dev,
-				 unsigned int clock_source)
-{
-	struct ni_private *devpriv = dev->private;
-
-	switch (clock_source) {
-	case NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC:
-		devpriv->clock_and_fout &= ~FOUT_Timebase_Select;
-		break;
-	case NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC:
-		devpriv->clock_and_fout |= FOUT_Timebase_Select;
-		break;
-	default:
-		return -EINVAL;
-	}
-	devpriv->stc_writew(dev, devpriv->clock_and_fout,
-			    Clock_and_FOUT_Register);
-	return 3;
-}
-
-static void ni_get_freq_out_clock(struct comedi_device *dev,
-				  unsigned int *clock_source,
-				  unsigned int *clock_period_ns)
-{
-	struct ni_private *devpriv = dev->private;
-
-	if (devpriv->clock_and_fout & FOUT_Timebase_Select) {
-		*clock_source = NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC;
-		*clock_period_ns = TIMEBASE_2_NS;
-	} else {
-		*clock_source = NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC;
-		*clock_period_ns = TIMEBASE_1_NS * 2;
-	}
-}
-
 static int ni_freq_out_insn_config(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
-				   struct comedi_insn *insn, unsigned int *data)
+				   struct comedi_insn *insn,
+				   unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
+
 	switch (data[0]) {
 	case INSN_CONFIG_SET_CLOCK_SRC:
-		return ni_set_freq_out_clock(dev, data[1]);
+		switch (data[1]) {
+		case NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC:
+			devpriv->clock_and_fout &= ~FOUT_Timebase_Select;
+			break;
+		case NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC:
+			devpriv->clock_and_fout |= FOUT_Timebase_Select;
+			break;
+		default:
+			return -EINVAL;
+		}
+		devpriv->stc_writew(dev, devpriv->clock_and_fout,
+				    Clock_and_FOUT_Register);
 		break;
 	case INSN_CONFIG_GET_CLOCK_SRC:
-		ni_get_freq_out_clock(dev, &data[1], &data[2]);
-		return 3;
-	default:
+		if (devpriv->clock_and_fout & FOUT_Timebase_Select) {
+			data[1] = NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC;
+			data[2] = TIMEBASE_2_NS;
+		} else {
+			data[1] = NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC;
+			data[2] = TIMEBASE_1_NS * 2;
+		}
 		break;
+	default:
+		return -EINVAL;
 	}
-	return -EINVAL;
+	return insn->n;
 }
 
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg)

commit e879c315c3050a1b422291e5a7509dc24ec2c7d1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:51 2014 -0700

    staging: comedi: ni_mio_common: use dev->write_subdev
    
    The (*attach) in ni_E_init() sets the dev->write_subdev to the analog
    output subdevice. Use that instead of accessing the dev->subdevices
    array directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7083af267e2d..0bffc56b73cc 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -732,7 +732,7 @@ static void mite_handle_b_linkc(struct mite_struct *mite,
 				struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[NI_AO_SUBDEV];
+	struct comedi_subdevice *s = dev->write_subdev;
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
@@ -1238,7 +1238,7 @@ static void handle_b_interrupt(struct comedi_device *dev,
 			       unsigned short b_status, unsigned ao_mite_status)
 {
 	struct ni_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[NI_AO_SUBDEV];
+	struct comedi_subdevice *s = dev->write_subdev;
 	/* unsigned short ack=0; */
 
 #ifdef PCIDMA
@@ -1361,7 +1361,7 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[NI_AO_SUBDEV];
+	struct comedi_subdevice *s = dev->write_subdev;
 	int retval;
 	unsigned long flags;
 

commit 5dce16e51aaf6e948d982a310f0338a1b395b6ca
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:50 2014 -0700

    staging: comedi: ni_mio_common: use dev->read_subdev
    
    The (*attach) in ni_E_init() sets the dev->read_subdev to the analog
    input subdevice. Use that instead of accessing the dev->subdevices
    array directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8b2178af858c..7083af267e2d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -684,7 +684,7 @@ static inline void ni_set_bits(struct comedi_device *dev, int reg,
 static void ni_sync_ai_dma(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
@@ -939,7 +939,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 static void ni_handle_fifo_half_full(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
-	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+	struct comedi_subdevice *s = dev->read_subdev;
 	int n;
 
 	n = board->ai_fifo_depth / 2;
@@ -955,7 +955,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned short data[2];
 	u32 dl;
 	unsigned short fifo_empty;
@@ -1021,7 +1021,7 @@ static void get_last_sample_611x(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv __maybe_unused = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned short data;
 	u32 dl;
 
@@ -1040,7 +1040,7 @@ static void get_last_sample_6143(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv __maybe_unused = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned short data;
 	u32 dl;
 
@@ -1060,7 +1060,7 @@ static void get_last_sample_6143(struct comedi_device *dev)
 
 static void shutdown_ai_command(struct comedi_device *dev)
 {
-	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+	struct comedi_subdevice *s = dev->read_subdev;
 
 #ifdef PCIDMA
 	ni_ai_drain_dma(dev);
@@ -1134,7 +1134,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			       unsigned ai_mite_status)
 {
 	struct ni_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+	struct comedi_subdevice *s = dev->read_subdev;
 
 	/* 67xx boards don't have ai subdevice, but their gpct0 might generate an a interrupt */
 	if (s->type == COMEDI_SUBD_UNUSED)
@@ -1320,7 +1320,7 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+	struct comedi_subdevice *s = dev->read_subdev;
 	int retval;
 	unsigned long flags;
 

commit 2832b1831cac1ed64e7d106b85972e57516c21b2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:49 2014 -0700

    staging: comedi: ni_mio_common: move externally called functions to EOF
    
    This source file is included by the ni_atmio, ni_mio_cs, and ni_pcmio
    drivers to support the common hardware on National Instruments DAQ-STC
    based boards.
    
    The only functions actually used by the external source files are
    ni_E_interrupt(), ni_alloc_private(), ni_E_init(), and mio_common_detach().
    The rest of the functions in this file are only used locally.
    
    For aesthetics, move all the externally called functions to the end of
    the file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 556e88573de7..8b2178af858c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3673,16 +3673,6 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 
 }
 
-static void mio_common_detach(struct comedi_device *dev)
-{
-	struct ni_private *devpriv = dev->private;
-
-	if (devpriv) {
-		if (devpriv->counter_dev)
-			ni_gpct_device_destroy(devpriv->counter_dev);
-	}
-}
-
 static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int i;
@@ -3965,21 +3955,6 @@ static int ni_freq_out_insn_config(struct comedi_device *dev,
 	return -EINVAL;
 }
 
-static int ni_alloc_private(struct comedi_device *dev)
-{
-	struct ni_private *devpriv;
-
-	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
-	if (!devpriv)
-		return -ENOMEM;
-
-	spin_lock_init(&devpriv->window_lock);
-	spin_lock_init(&devpriv->soft_reg_copy_lock);
-	spin_lock_init(&devpriv->mite_channel_lock);
-
-	return 0;
-};
-
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 {
 	struct comedi_device *dev = (struct comedi_device *)arg;
@@ -5267,6 +5242,21 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
+static int ni_alloc_private(struct comedi_device *dev)
+{
+	struct ni_private *devpriv;
+
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
+	if (!devpriv)
+		return -ENOMEM;
+
+	spin_lock_init(&devpriv->window_lock);
+	spin_lock_init(&devpriv->soft_reg_copy_lock);
+	spin_lock_init(&devpriv->mite_channel_lock);
+
+	return 0;
+}
+
 static int ni_E_init(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
@@ -5596,3 +5586,13 @@ static int ni_E_init(struct comedi_device *dev)
 
 	return 0;
 }
+
+static void mio_common_detach(struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+
+	if (devpriv) {
+		if (devpriv->counter_dev)
+			ni_gpct_device_destroy(devpriv->counter_dev);
+	}
+}

commit 849590f75945903f4330f4533f3a76688af3eb71
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:48 2014 -0700

    staging: comedi: ni_mio_common: move disabled GPCT functions
    
    I have not determined if the code in these functions is actually
    usable. For now just move the disabled code closer to the working
    gpct functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 93bc362e8329..556e88573de7 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5120,6 +5120,94 @@ static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 #endif
 
+#if 0
+/*
+ *	Read the GPCTs current value.
+ */
+static int GPCT_G_Watch(struct comedi_device *dev, int chan)
+{
+	unsigned int hi1, hi2, lo;
+
+	devpriv->gpct_command[chan] &= ~G_Save_Trace;
+	devpriv->stc_writew(dev, devpriv->gpct_command[chan],
+			    G_Command_Register(chan));
+
+	devpriv->gpct_command[chan] |= G_Save_Trace;
+	devpriv->stc_writew(dev, devpriv->gpct_command[chan],
+			    G_Command_Register(chan));
+
+	/* This procedure is used because the two registers cannot
+	 * be read atomically. */
+	do {
+		hi1 = devpriv->stc_readw(dev, G_Save_Register_High(chan));
+		lo = devpriv->stc_readw(dev, G_Save_Register_Low(chan));
+		hi2 = devpriv->stc_readw(dev, G_Save_Register_High(chan));
+	} while (hi1 != hi2);
+
+	return (hi1 << 16) | lo;
+}
+
+static void GPCT_Reset(struct comedi_device *dev, int chan)
+{
+	int temp_ack_reg = 0;
+
+	/* printk("GPCT_Reset..."); */
+	devpriv->gpct_cur_operation[chan] = GPCT_RESET;
+
+	switch (chan) {
+	case 0:
+		devpriv->stc_writew(dev, G0_Reset, Joint_Reset_Register);
+		ni_set_bits(dev, Interrupt_A_Enable_Register,
+			    G0_TC_Interrupt_Enable, 0);
+		ni_set_bits(dev, Interrupt_A_Enable_Register,
+			    G0_Gate_Interrupt_Enable, 0);
+		temp_ack_reg |= G0_Gate_Error_Confirm;
+		temp_ack_reg |= G0_TC_Error_Confirm;
+		temp_ack_reg |= G0_TC_Interrupt_Ack;
+		temp_ack_reg |= G0_Gate_Interrupt_Ack;
+		devpriv->stc_writew(dev, temp_ack_reg,
+				    Interrupt_A_Ack_Register);
+
+		/* problem...this interferes with the other ctr... */
+		devpriv->an_trig_etc_reg |= GPFO_0_Output_Enable;
+		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
+				    Analog_Trigger_Etc_Register);
+		break;
+	case 1:
+		devpriv->stc_writew(dev, G1_Reset, Joint_Reset_Register);
+		ni_set_bits(dev, Interrupt_B_Enable_Register,
+			    G1_TC_Interrupt_Enable, 0);
+		ni_set_bits(dev, Interrupt_B_Enable_Register,
+			    G0_Gate_Interrupt_Enable, 0);
+		temp_ack_reg |= G1_Gate_Error_Confirm;
+		temp_ack_reg |= G1_TC_Error_Confirm;
+		temp_ack_reg |= G1_TC_Interrupt_Ack;
+		temp_ack_reg |= G1_Gate_Interrupt_Ack;
+		devpriv->stc_writew(dev, temp_ack_reg,
+				    Interrupt_B_Ack_Register);
+
+		devpriv->an_trig_etc_reg |= GPFO_1_Output_Enable;
+		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
+				    Analog_Trigger_Etc_Register);
+		break;
+	}
+
+	devpriv->gpct_mode[chan] = 0;
+	devpriv->gpct_input_select[chan] = 0;
+	devpriv->gpct_command[chan] = 0;
+
+	devpriv->gpct_command[chan] |= G_Synchronized_Gate;
+
+	devpriv->stc_writew(dev, devpriv->gpct_mode[chan],
+			    G_Mode_Register(chan));
+	devpriv->stc_writew(dev, devpriv->gpct_input_select[chan],
+			    G_Input_Select_Register(chan));
+	devpriv->stc_writew(dev, 0, G_Autoincrement_Register(chan));
+
+	/* printk("exit GPCT_Reset\n"); */
+}
+#endif
+
 static irqreturn_t ni_E_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -5508,92 +5596,3 @@ static int ni_E_init(struct comedi_device *dev)
 
 	return 0;
 }
-
-#if 0
-/*
- *	Read the GPCTs current value.
- */
-static int GPCT_G_Watch(struct comedi_device *dev, int chan)
-{
-	unsigned int hi1, hi2, lo;
-
-	devpriv->gpct_command[chan] &= ~G_Save_Trace;
-	devpriv->stc_writew(dev, devpriv->gpct_command[chan],
-			    G_Command_Register(chan));
-
-	devpriv->gpct_command[chan] |= G_Save_Trace;
-	devpriv->stc_writew(dev, devpriv->gpct_command[chan],
-			    G_Command_Register(chan));
-
-	/* This procedure is used because the two registers cannot
-	 * be read atomically. */
-	do {
-		hi1 = devpriv->stc_readw(dev, G_Save_Register_High(chan));
-		lo = devpriv->stc_readw(dev, G_Save_Register_Low(chan));
-		hi2 = devpriv->stc_readw(dev, G_Save_Register_High(chan));
-	} while (hi1 != hi2);
-
-	return (hi1 << 16) | lo;
-}
-
-static void GPCT_Reset(struct comedi_device *dev, int chan)
-{
-	int temp_ack_reg = 0;
-
-	/* printk("GPCT_Reset..."); */
-	devpriv->gpct_cur_operation[chan] = GPCT_RESET;
-
-	switch (chan) {
-	case 0:
-		devpriv->stc_writew(dev, G0_Reset, Joint_Reset_Register);
-		ni_set_bits(dev, Interrupt_A_Enable_Register,
-			    G0_TC_Interrupt_Enable, 0);
-		ni_set_bits(dev, Interrupt_A_Enable_Register,
-			    G0_Gate_Interrupt_Enable, 0);
-		temp_ack_reg |= G0_Gate_Error_Confirm;
-		temp_ack_reg |= G0_TC_Error_Confirm;
-		temp_ack_reg |= G0_TC_Interrupt_Ack;
-		temp_ack_reg |= G0_Gate_Interrupt_Ack;
-		devpriv->stc_writew(dev, temp_ack_reg,
-				    Interrupt_A_Ack_Register);
-
-		/* problem...this interferes with the other ctr... */
-		devpriv->an_trig_etc_reg |= GPFO_0_Output_Enable;
-		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
-				    Analog_Trigger_Etc_Register);
-		break;
-	case 1:
-		devpriv->stc_writew(dev, G1_Reset, Joint_Reset_Register);
-		ni_set_bits(dev, Interrupt_B_Enable_Register,
-			    G1_TC_Interrupt_Enable, 0);
-		ni_set_bits(dev, Interrupt_B_Enable_Register,
-			    G0_Gate_Interrupt_Enable, 0);
-		temp_ack_reg |= G1_Gate_Error_Confirm;
-		temp_ack_reg |= G1_TC_Error_Confirm;
-		temp_ack_reg |= G1_TC_Interrupt_Ack;
-		temp_ack_reg |= G1_Gate_Interrupt_Ack;
-		devpriv->stc_writew(dev, temp_ack_reg,
-				    Interrupt_B_Ack_Register);
-
-		devpriv->an_trig_etc_reg |= GPFO_1_Output_Enable;
-		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
-				    Analog_Trigger_Etc_Register);
-		break;
-	}
-
-	devpriv->gpct_mode[chan] = 0;
-	devpriv->gpct_input_select[chan] = 0;
-	devpriv->gpct_command[chan] = 0;
-
-	devpriv->gpct_command[chan] |= G_Synchronized_Gate;
-
-	devpriv->stc_writew(dev, devpriv->gpct_mode[chan],
-			    G_Mode_Register(chan));
-	devpriv->stc_writew(dev, devpriv->gpct_input_select[chan],
-			    G_Input_Select_Register(chan));
-	devpriv->stc_writew(dev, 0, G_Autoincrement_Register(chan));
-
-	/* printk("exit GPCT_Reset\n"); */
-}
-
-#endif

commit 2ffb247691f6e0ecb299ca526d54b868b5338fa0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:47 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 24
    
    Move some functions to remove the need for the remaining forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c174eac47f7e..93bc362e8329 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -194,13 +194,6 @@ static const struct comedi_lrange *const ni_range_lkup[] = {
 	[ai_gain_6143] = &range_bipolar5
 };
 
-#ifndef PCIDMA
-static void ni_handle_fifo_half_full(struct comedi_device *dev);
-static int ni_ao_fifo_half_empty(struct comedi_device *dev,
-				 struct comedi_subdevice *s);
-#endif
-static void ni_handle_fifo_dregs(struct comedi_device *dev);
-
 enum aimodes {
 	AIMODE_NONE = 0,
 	AIMODE_HALF_FULL = 1,
@@ -771,6 +764,259 @@ static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 }
 #endif /* PCIDMA */
 
+#ifndef PCIDMA
+
+static void ni_ao_fifo_load(struct comedi_device *dev,
+			    struct comedi_subdevice *s, int n)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+	int chan;
+	int i;
+	unsigned short d;
+	u32 packed_data;
+	int range;
+	int err = 1;
+
+	chan = async->cur_chan;
+	for (i = 0; i < n; i++) {
+		err &= comedi_buf_get(s, &d);
+		if (err == 0)
+			break;
+
+		range = CR_RANGE(cmd->chanlist[chan]);
+
+		if (board->reg_type & ni_reg_6xxx_mask) {
+			packed_data = d & 0xffff;
+			/* 6711 only has 16 bit wide ao fifo */
+			if (board->reg_type != ni_reg_6711) {
+				err &= comedi_buf_get(s, &d);
+				if (err == 0)
+					break;
+				chan++;
+				i++;
+				packed_data |= (d << 16) & 0xffff0000;
+			}
+			ni_writel(packed_data, DAC_FIFO_Data_611x);
+		} else {
+			ni_writew(d, DAC_FIFO_Data);
+		}
+		chan++;
+		chan %= cmd->chanlist_len;
+	}
+	async->cur_chan = chan;
+	if (err == 0)
+		async->events |= COMEDI_CB_OVERFLOW;
+}
+
+/*
+ *  There's a small problem if the FIFO gets really low and we
+ *  don't have the data to fill it.  Basically, if after we fill
+ *  the FIFO with all the data available, the FIFO is _still_
+ *  less than half full, we never clear the interrupt.  If the
+ *  IRQ is in edge mode, we never get another interrupt, because
+ *  this one wasn't cleared.  If in level mode, we get flooded
+ *  with interrupts that we can't fulfill, because nothing ever
+ *  gets put into the buffer.
+ *
+ *  This kind of situation is recoverable, but it is easier to
+ *  just pretend we had a FIFO underrun, since there is a good
+ *  chance it will happen anyway.  This is _not_ the case for
+ *  RT code, as RT code might purposely be running close to the
+ *  metal.  Needs to be fixed eventually.
+ */
+static int ni_ao_fifo_half_empty(struct comedi_device *dev,
+				 struct comedi_subdevice *s)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	int n;
+
+	n = comedi_buf_read_n_available(s);
+	if (n == 0) {
+		s->async->events |= COMEDI_CB_OVERFLOW;
+		return 0;
+	}
+
+	n /= sizeof(short);
+	if (n > board->ao_fifo_depth / 2)
+		n = board->ao_fifo_depth / 2;
+
+	ni_ao_fifo_load(dev, s, n);
+
+	s->async->events |= COMEDI_CB_BLOCK;
+
+	return 1;
+}
+
+static int ni_ao_prep_fifo(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
+	int n;
+
+	/* reset fifo */
+	devpriv->stc_writew(dev, 1, DAC_FIFO_Clear);
+	if (board->reg_type & ni_reg_6xxx_mask)
+		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
+
+	/* load some data */
+	n = comedi_buf_read_n_available(s);
+	if (n == 0)
+		return 0;
+
+	n /= sizeof(short);
+	if (n > board->ao_fifo_depth)
+		n = board->ao_fifo_depth;
+
+	ni_ao_fifo_load(dev, s, n);
+
+	return n;
+}
+
+static void ni_ai_fifo_read(struct comedi_device *dev,
+			    struct comedi_subdevice *s, int n)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
+	struct comedi_async *async = s->async;
+	int i;
+
+	if (board->reg_type == ni_reg_611x) {
+		unsigned short data[2];
+		u32 dl;
+
+		for (i = 0; i < n / 2; i++) {
+			dl = ni_readl(ADC_FIFO_Data_611x);
+			/* This may get the hi/lo data in the wrong order */
+			data[0] = (dl >> 16) & 0xffff;
+			data[1] = dl & 0xffff;
+			cfc_write_array_to_buffer(s, data, sizeof(data));
+		}
+		/* Check if there's a single sample stuck in the FIFO */
+		if (n % 2) {
+			dl = ni_readl(ADC_FIFO_Data_611x);
+			data[0] = dl & 0xffff;
+			cfc_write_to_buffer(s, data[0]);
+		}
+	} else if (board->reg_type == ni_reg_6143) {
+		unsigned short data[2];
+		u32 dl;
+
+		/*  This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed */
+		for (i = 0; i < n / 2; i++) {
+			dl = ni_readl(AIFIFO_Data_6143);
+
+			data[0] = (dl >> 16) & 0xffff;
+			data[1] = dl & 0xffff;
+			cfc_write_array_to_buffer(s, data, sizeof(data));
+		}
+		if (n % 2) {
+			/* Assume there is a single sample stuck in the FIFO */
+			ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
+			dl = ni_readl(AIFIFO_Data_6143);
+			data[0] = (dl >> 16) & 0xffff;
+			cfc_write_to_buffer(s, data[0]);
+		}
+	} else {
+		if (n > sizeof(devpriv->ai_fifo_buffer) /
+		    sizeof(devpriv->ai_fifo_buffer[0])) {
+			comedi_error(dev, "bug! ai_fifo_buffer too small");
+			async->events |= COMEDI_CB_ERROR;
+			return;
+		}
+		for (i = 0; i < n; i++) {
+			devpriv->ai_fifo_buffer[i] =
+			    ni_readw(ADC_FIFO_Data_Register);
+		}
+		cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
+					  n *
+					  sizeof(devpriv->ai_fifo_buffer[0]));
+	}
+}
+
+static void ni_handle_fifo_half_full(struct comedi_device *dev)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+	int n;
+
+	n = board->ai_fifo_depth / 2;
+
+	ni_ai_fifo_read(dev, s, n);
+}
+#endif
+
+/*
+   Empties the AI fifo
+*/
+static void ni_handle_fifo_dregs(struct comedi_device *dev)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+	unsigned short data[2];
+	u32 dl;
+	unsigned short fifo_empty;
+	int i;
+
+	if (board->reg_type == ni_reg_611x) {
+		while ((devpriv->stc_readw(dev,
+					   AI_Status_1_Register) &
+			AI_FIFO_Empty_St) == 0) {
+			dl = ni_readl(ADC_FIFO_Data_611x);
+
+			/* This may get the hi/lo data in the wrong order */
+			data[0] = (dl >> 16);
+			data[1] = (dl & 0xffff);
+			cfc_write_array_to_buffer(s, data, sizeof(data));
+		}
+	} else if (board->reg_type == ni_reg_6143) {
+		i = 0;
+		while (ni_readl(AIFIFO_Status_6143) & 0x04) {
+			dl = ni_readl(AIFIFO_Data_6143);
+
+			/* This may get the hi/lo data in the wrong order */
+			data[0] = (dl >> 16);
+			data[1] = (dl & 0xffff);
+			cfc_write_array_to_buffer(s, data, sizeof(data));
+			i += 2;
+		}
+		/*  Check if stranded sample is present */
+		if (ni_readl(AIFIFO_Status_6143) & 0x01) {
+			ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
+			dl = ni_readl(AIFIFO_Data_6143);
+			data[0] = (dl >> 16) & 0xffff;
+			cfc_write_to_buffer(s, data[0]);
+		}
+
+	} else {
+		fifo_empty =
+		    devpriv->stc_readw(dev,
+				       AI_Status_1_Register) & AI_FIFO_Empty_St;
+		while (fifo_empty == 0) {
+			for (i = 0;
+			     i <
+			     sizeof(devpriv->ai_fifo_buffer) /
+			     sizeof(devpriv->ai_fifo_buffer[0]); i++) {
+				fifo_empty =
+				    devpriv->stc_readw(dev,
+						       AI_Status_1_Register) &
+				    AI_FIFO_Empty_St;
+				if (fifo_empty)
+					break;
+				devpriv->ai_fifo_buffer[i] =
+				    ni_readw(ADC_FIFO_Data_Register);
+			}
+			cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
+						  i *
+						  sizeof(devpriv->
+							 ai_fifo_buffer[0]));
+		}
+	}
+}
+
 static void get_last_sample_611x(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
@@ -1040,259 +1286,6 @@ static void handle_b_interrupt(struct comedi_device *dev,
 	cfc_handle_events(dev, s);
 }
 
-#ifndef PCIDMA
-
-static void ni_ao_fifo_load(struct comedi_device *dev,
-			    struct comedi_subdevice *s, int n)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
-	int chan;
-	int i;
-	unsigned short d;
-	u32 packed_data;
-	int range;
-	int err = 1;
-
-	chan = async->cur_chan;
-	for (i = 0; i < n; i++) {
-		err &= comedi_buf_get(s, &d);
-		if (err == 0)
-			break;
-
-		range = CR_RANGE(cmd->chanlist[chan]);
-
-		if (board->reg_type & ni_reg_6xxx_mask) {
-			packed_data = d & 0xffff;
-			/* 6711 only has 16 bit wide ao fifo */
-			if (board->reg_type != ni_reg_6711) {
-				err &= comedi_buf_get(s, &d);
-				if (err == 0)
-					break;
-				chan++;
-				i++;
-				packed_data |= (d << 16) & 0xffff0000;
-			}
-			ni_writel(packed_data, DAC_FIFO_Data_611x);
-		} else {
-			ni_writew(d, DAC_FIFO_Data);
-		}
-		chan++;
-		chan %= cmd->chanlist_len;
-	}
-	async->cur_chan = chan;
-	if (err == 0)
-		async->events |= COMEDI_CB_OVERFLOW;
-}
-
-/*
- *  There's a small problem if the FIFO gets really low and we
- *  don't have the data to fill it.  Basically, if after we fill
- *  the FIFO with all the data available, the FIFO is _still_
- *  less than half full, we never clear the interrupt.  If the
- *  IRQ is in edge mode, we never get another interrupt, because
- *  this one wasn't cleared.  If in level mode, we get flooded
- *  with interrupts that we can't fulfill, because nothing ever
- *  gets put into the buffer.
- *
- *  This kind of situation is recoverable, but it is easier to
- *  just pretend we had a FIFO underrun, since there is a good
- *  chance it will happen anyway.  This is _not_ the case for
- *  RT code, as RT code might purposely be running close to the
- *  metal.  Needs to be fixed eventually.
- */
-static int ni_ao_fifo_half_empty(struct comedi_device *dev,
-				 struct comedi_subdevice *s)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	int n;
-
-	n = comedi_buf_read_n_available(s);
-	if (n == 0) {
-		s->async->events |= COMEDI_CB_OVERFLOW;
-		return 0;
-	}
-
-	n /= sizeof(short);
-	if (n > board->ao_fifo_depth / 2)
-		n = board->ao_fifo_depth / 2;
-
-	ni_ao_fifo_load(dev, s, n);
-
-	s->async->events |= COMEDI_CB_BLOCK;
-
-	return 1;
-}
-
-static int ni_ao_prep_fifo(struct comedi_device *dev,
-			   struct comedi_subdevice *s)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
-	int n;
-
-	/* reset fifo */
-	devpriv->stc_writew(dev, 1, DAC_FIFO_Clear);
-	if (board->reg_type & ni_reg_6xxx_mask)
-		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
-
-	/* load some data */
-	n = comedi_buf_read_n_available(s);
-	if (n == 0)
-		return 0;
-
-	n /= sizeof(short);
-	if (n > board->ao_fifo_depth)
-		n = board->ao_fifo_depth;
-
-	ni_ao_fifo_load(dev, s, n);
-
-	return n;
-}
-
-static void ni_ai_fifo_read(struct comedi_device *dev,
-			    struct comedi_subdevice *s, int n)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
-	struct comedi_async *async = s->async;
-	int i;
-
-	if (board->reg_type == ni_reg_611x) {
-		unsigned short data[2];
-		u32 dl;
-
-		for (i = 0; i < n / 2; i++) {
-			dl = ni_readl(ADC_FIFO_Data_611x);
-			/* This may get the hi/lo data in the wrong order */
-			data[0] = (dl >> 16) & 0xffff;
-			data[1] = dl & 0xffff;
-			cfc_write_array_to_buffer(s, data, sizeof(data));
-		}
-		/* Check if there's a single sample stuck in the FIFO */
-		if (n % 2) {
-			dl = ni_readl(ADC_FIFO_Data_611x);
-			data[0] = dl & 0xffff;
-			cfc_write_to_buffer(s, data[0]);
-		}
-	} else if (board->reg_type == ni_reg_6143) {
-		unsigned short data[2];
-		u32 dl;
-
-		/*  This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed */
-		for (i = 0; i < n / 2; i++) {
-			dl = ni_readl(AIFIFO_Data_6143);
-
-			data[0] = (dl >> 16) & 0xffff;
-			data[1] = dl & 0xffff;
-			cfc_write_array_to_buffer(s, data, sizeof(data));
-		}
-		if (n % 2) {
-			/* Assume there is a single sample stuck in the FIFO */
-			ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
-			dl = ni_readl(AIFIFO_Data_6143);
-			data[0] = (dl >> 16) & 0xffff;
-			cfc_write_to_buffer(s, data[0]);
-		}
-	} else {
-		if (n > sizeof(devpriv->ai_fifo_buffer) /
-		    sizeof(devpriv->ai_fifo_buffer[0])) {
-			comedi_error(dev, "bug! ai_fifo_buffer too small");
-			async->events |= COMEDI_CB_ERROR;
-			return;
-		}
-		for (i = 0; i < n; i++) {
-			devpriv->ai_fifo_buffer[i] =
-			    ni_readw(ADC_FIFO_Data_Register);
-		}
-		cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
-					  n *
-					  sizeof(devpriv->ai_fifo_buffer[0]));
-	}
-}
-
-static void ni_handle_fifo_half_full(struct comedi_device *dev)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
-	int n;
-
-	n = board->ai_fifo_depth / 2;
-
-	ni_ai_fifo_read(dev, s, n);
-}
-#endif
-
-/*
-   Empties the AI fifo
-*/
-static void ni_handle_fifo_dregs(struct comedi_device *dev)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
-	unsigned short data[2];
-	u32 dl;
-	unsigned short fifo_empty;
-	int i;
-
-	if (board->reg_type == ni_reg_611x) {
-		while ((devpriv->stc_readw(dev,
-					   AI_Status_1_Register) &
-			AI_FIFO_Empty_St) == 0) {
-			dl = ni_readl(ADC_FIFO_Data_611x);
-
-			/* This may get the hi/lo data in the wrong order */
-			data[0] = (dl >> 16);
-			data[1] = (dl & 0xffff);
-			cfc_write_array_to_buffer(s, data, sizeof(data));
-		}
-	} else if (board->reg_type == ni_reg_6143) {
-		i = 0;
-		while (ni_readl(AIFIFO_Status_6143) & 0x04) {
-			dl = ni_readl(AIFIFO_Data_6143);
-
-			/* This may get the hi/lo data in the wrong order */
-			data[0] = (dl >> 16);
-			data[1] = (dl & 0xffff);
-			cfc_write_array_to_buffer(s, data, sizeof(data));
-			i += 2;
-		}
-		/*  Check if stranded sample is present */
-		if (ni_readl(AIFIFO_Status_6143) & 0x01) {
-			ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
-			dl = ni_readl(AIFIFO_Data_6143);
-			data[0] = (dl >> 16) & 0xffff;
-			cfc_write_to_buffer(s, data[0]);
-		}
-
-	} else {
-		fifo_empty =
-		    devpriv->stc_readw(dev,
-				       AI_Status_1_Register) & AI_FIFO_Empty_St;
-		while (fifo_empty == 0) {
-			for (i = 0;
-			     i <
-			     sizeof(devpriv->ai_fifo_buffer) /
-			     sizeof(devpriv->ai_fifo_buffer[0]); i++) {
-				fifo_empty =
-				    devpriv->stc_readw(dev,
-						       AI_Status_1_Register) &
-				    AI_FIFO_Empty_St;
-				if (fifo_empty)
-					break;
-				devpriv->ai_fifo_buffer[i] =
-				    ni_readw(ADC_FIFO_Data_Register);
-			}
-			cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
-						  i *
-						  sizeof(devpriv->
-							 ai_fifo_buffer[0]));
-		}
-	}
-}
-
 static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 			void *data, unsigned int num_bytes,
 			unsigned int chan_index)

commit 624b161f7e3f94b23d17c884539e3b4dcc8e0392
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:46 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 23
    
    Move ni_set_master_clock() and its helper functions to remove the need
    for the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ba876dee1922..c174eac47f7e 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -201,9 +201,6 @@ static int ni_ao_fifo_half_empty(struct comedi_device *dev,
 #endif
 static void ni_handle_fifo_dregs(struct comedi_device *dev);
 
-static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
-			       unsigned period_ns);
-
 enum aimodes {
 	AIMODE_NONE = 0,
 	AIMODE_HALF_FULL = 1,
@@ -4687,6 +4684,203 @@ static int init_cs5529(struct comedi_device *dev)
 	return 0;
 }
 
+/*
+ * Find best multiplier/divider to try and get the PLL running at 80 MHz
+ * given an arbitrary frequency input clock.
+ */
+static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
+					 unsigned *freq_divider,
+					 unsigned *freq_multiplier,
+					 unsigned *actual_period_ns)
+{
+	unsigned div;
+	unsigned best_div = 1;
+	static const unsigned max_div = 0x10;
+	unsigned mult;
+	unsigned best_mult = 1;
+	static const unsigned max_mult = 0x100;
+	static const unsigned pico_per_nano = 1000;
+
+	const unsigned reference_picosec = reference_period_ns * pico_per_nano;
+	/* m-series wants the phased-locked loop to output 80MHz, which is divided by 4 to
+	 * 20 MHz for most timing clocks */
+	static const unsigned target_picosec = 12500;
+	static const unsigned fudge_factor_80_to_20Mhz = 4;
+	int best_period_picosec = 0;
+	for (div = 1; div <= max_div; ++div) {
+		for (mult = 1; mult <= max_mult; ++mult) {
+			unsigned new_period_ps =
+			    (reference_picosec * div) / mult;
+			if (abs(new_period_ps - target_picosec) <
+			    abs(best_period_picosec - target_picosec)) {
+				best_period_picosec = new_period_ps;
+				best_div = div;
+				best_mult = mult;
+			}
+		}
+	}
+	if (best_period_picosec == 0) {
+		printk("%s: bug, failed to find pll parameters\n", __func__);
+		return -EIO;
+	}
+	*freq_divider = best_div;
+	*freq_multiplier = best_mult;
+	*actual_period_ns =
+	    (best_period_picosec * fudge_factor_80_to_20Mhz +
+	     (pico_per_nano / 2)) / pico_per_nano;
+	return 0;
+}
+
+static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
+					   unsigned source, unsigned period_ns)
+{
+	struct ni_private *devpriv = dev->private;
+	static const unsigned min_period_ns = 50;
+	static const unsigned max_period_ns = 1000;
+	static const unsigned timeout = 1000;
+	unsigned pll_control_bits;
+	unsigned freq_divider;
+	unsigned freq_multiplier;
+	unsigned i;
+	int retval;
+
+	if (source == NI_MIO_PLL_PXI10_CLOCK)
+		period_ns = 100;
+	/*  these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that */
+	if (period_ns < min_period_ns || period_ns > max_period_ns) {
+		printk
+		    ("%s: you must specify an input clock frequency between %i and %i nanosec "
+		     "for the phased-lock loop.\n", __func__,
+		     min_period_ns, max_period_ns);
+		return -EINVAL;
+	}
+	devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
+	devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+			    RTSI_Trig_Direction_Register);
+	pll_control_bits =
+	    MSeries_PLL_Enable_Bit | MSeries_PLL_VCO_Mode_75_150MHz_Bits;
+	devpriv->clock_and_fout2 |=
+	    MSeries_Timebase1_Select_Bit | MSeries_Timebase3_Select_Bit;
+	devpriv->clock_and_fout2 &= ~MSeries_PLL_In_Source_Select_Mask;
+	switch (source) {
+	case NI_MIO_PLL_PXI_STAR_TRIGGER_CLOCK:
+		devpriv->clock_and_fout2 |=
+		    MSeries_PLL_In_Source_Select_Star_Trigger_Bits;
+		retval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,
+						       &freq_multiplier,
+						       &devpriv->clock_ns);
+		if (retval < 0)
+			return retval;
+		break;
+	case NI_MIO_PLL_PXI10_CLOCK:
+		/* pxi clock is 10MHz */
+		devpriv->clock_and_fout2 |=
+		    MSeries_PLL_In_Source_Select_PXI_Clock10;
+		retval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,
+						       &freq_multiplier,
+						       &devpriv->clock_ns);
+		if (retval < 0)
+			return retval;
+		break;
+	default:
+		{
+			unsigned rtsi_channel;
+			static const unsigned max_rtsi_channel = 7;
+			for (rtsi_channel = 0; rtsi_channel <= max_rtsi_channel;
+			     ++rtsi_channel) {
+				if (source ==
+				    NI_MIO_PLL_RTSI_CLOCK(rtsi_channel)) {
+					devpriv->clock_and_fout2 |=
+					    MSeries_PLL_In_Source_Select_RTSI_Bits
+					    (rtsi_channel);
+					break;
+				}
+			}
+			if (rtsi_channel > max_rtsi_channel)
+				return -EINVAL;
+			retval = ni_mseries_get_pll_parameters(period_ns,
+							       &freq_divider,
+							       &freq_multiplier,
+							       &devpriv->
+							       clock_ns);
+			if (retval < 0)
+				return retval;
+		}
+		break;
+	}
+	ni_writew(devpriv->clock_and_fout2, M_Offset_Clock_and_Fout2);
+	pll_control_bits |=
+	    MSeries_PLL_Divisor_Bits(freq_divider) |
+	    MSeries_PLL_Multiplier_Bits(freq_multiplier);
+
+	/* printk("using divider=%i, multiplier=%i for PLL. pll_control_bits = 0x%x\n",
+	 * freq_divider, freq_multiplier, pll_control_bits); */
+	/* printk("clock_ns=%d\n", devpriv->clock_ns); */
+	ni_writew(pll_control_bits, M_Offset_PLL_Control);
+	devpriv->clock_source = source;
+	/* it seems to typically take a few hundred microseconds for PLL to lock */
+	for (i = 0; i < timeout; ++i) {
+		if (ni_readw(M_Offset_PLL_Status) & MSeries_PLL_Locked_Bit)
+			break;
+		udelay(1);
+	}
+	if (i == timeout) {
+		printk
+		    ("%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns.\n",
+		     __func__, source, period_ns);
+		return -ETIMEDOUT;
+	}
+	return 3;
+}
+
+static int ni_set_master_clock(struct comedi_device *dev,
+			       unsigned source, unsigned period_ns)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
+
+	if (source == NI_MIO_INTERNAL_CLOCK) {
+		devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
+		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+				    RTSI_Trig_Direction_Register);
+		devpriv->clock_ns = TIMEBASE_1_NS;
+		if (board->reg_type & ni_reg_m_series_mask) {
+			devpriv->clock_and_fout2 &=
+			    ~(MSeries_Timebase1_Select_Bit |
+			      MSeries_Timebase3_Select_Bit);
+			ni_writew(devpriv->clock_and_fout2,
+				  M_Offset_Clock_and_Fout2);
+			ni_writew(0, M_Offset_PLL_Control);
+		}
+		devpriv->clock_source = source;
+	} else {
+		if (board->reg_type & ni_reg_m_series_mask) {
+			return ni_mseries_set_pll_master_clock(dev, source,
+							       period_ns);
+		} else {
+			if (source == NI_MIO_RTSI_CLOCK) {
+				devpriv->rtsi_trig_direction_reg |=
+				    Use_RTSI_Clock_Bit;
+				devpriv->stc_writew(dev,
+						    devpriv->
+						    rtsi_trig_direction_reg,
+						    RTSI_Trig_Direction_Register);
+				if (period_ns == 0) {
+					printk
+					    ("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",
+					     __func__);
+					return -EINVAL;
+				} else {
+					devpriv->clock_ns = period_ns;
+				}
+				devpriv->clock_source = source;
+			} else
+				return -EINVAL;
+		}
+	}
+	return 3;
+}
+
 static unsigned num_configurable_rtsi_channels(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
@@ -5410,198 +5604,3 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 }
 
 #endif
-
-/* Find best multiplier/divider to try and get the PLL running at 80 MHz
- * given an arbitrary frequency input clock */
-static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
-					 unsigned *freq_divider,
-					 unsigned *freq_multiplier,
-					 unsigned *actual_period_ns)
-{
-	unsigned div;
-	unsigned best_div = 1;
-	static const unsigned max_div = 0x10;
-	unsigned mult;
-	unsigned best_mult = 1;
-	static const unsigned max_mult = 0x100;
-	static const unsigned pico_per_nano = 1000;
-
-	const unsigned reference_picosec = reference_period_ns * pico_per_nano;
-	/* m-series wants the phased-locked loop to output 80MHz, which is divided by 4 to
-	 * 20 MHz for most timing clocks */
-	static const unsigned target_picosec = 12500;
-	static const unsigned fudge_factor_80_to_20Mhz = 4;
-	int best_period_picosec = 0;
-	for (div = 1; div <= max_div; ++div) {
-		for (mult = 1; mult <= max_mult; ++mult) {
-			unsigned new_period_ps =
-			    (reference_picosec * div) / mult;
-			if (abs(new_period_ps - target_picosec) <
-			    abs(best_period_picosec - target_picosec)) {
-				best_period_picosec = new_period_ps;
-				best_div = div;
-				best_mult = mult;
-			}
-		}
-	}
-	if (best_period_picosec == 0) {
-		printk("%s: bug, failed to find pll parameters\n", __func__);
-		return -EIO;
-	}
-	*freq_divider = best_div;
-	*freq_multiplier = best_mult;
-	*actual_period_ns =
-	    (best_period_picosec * fudge_factor_80_to_20Mhz +
-	     (pico_per_nano / 2)) / pico_per_nano;
-	return 0;
-}
-
-static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
-					   unsigned source, unsigned period_ns)
-{
-	struct ni_private *devpriv = dev->private;
-	static const unsigned min_period_ns = 50;
-	static const unsigned max_period_ns = 1000;
-	static const unsigned timeout = 1000;
-	unsigned pll_control_bits;
-	unsigned freq_divider;
-	unsigned freq_multiplier;
-	unsigned i;
-	int retval;
-
-	if (source == NI_MIO_PLL_PXI10_CLOCK)
-		period_ns = 100;
-	/*  these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that */
-	if (period_ns < min_period_ns || period_ns > max_period_ns) {
-		printk
-		    ("%s: you must specify an input clock frequency between %i and %i nanosec "
-		     "for the phased-lock loop.\n", __func__,
-		     min_period_ns, max_period_ns);
-		return -EINVAL;
-	}
-	devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
-	devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-			    RTSI_Trig_Direction_Register);
-	pll_control_bits =
-	    MSeries_PLL_Enable_Bit | MSeries_PLL_VCO_Mode_75_150MHz_Bits;
-	devpriv->clock_and_fout2 |=
-	    MSeries_Timebase1_Select_Bit | MSeries_Timebase3_Select_Bit;
-	devpriv->clock_and_fout2 &= ~MSeries_PLL_In_Source_Select_Mask;
-	switch (source) {
-	case NI_MIO_PLL_PXI_STAR_TRIGGER_CLOCK:
-		devpriv->clock_and_fout2 |=
-		    MSeries_PLL_In_Source_Select_Star_Trigger_Bits;
-		retval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,
-						       &freq_multiplier,
-						       &devpriv->clock_ns);
-		if (retval < 0)
-			return retval;
-		break;
-	case NI_MIO_PLL_PXI10_CLOCK:
-		/* pxi clock is 10MHz */
-		devpriv->clock_and_fout2 |=
-		    MSeries_PLL_In_Source_Select_PXI_Clock10;
-		retval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,
-						       &freq_multiplier,
-						       &devpriv->clock_ns);
-		if (retval < 0)
-			return retval;
-		break;
-	default:
-		{
-			unsigned rtsi_channel;
-			static const unsigned max_rtsi_channel = 7;
-			for (rtsi_channel = 0; rtsi_channel <= max_rtsi_channel;
-			     ++rtsi_channel) {
-				if (source ==
-				    NI_MIO_PLL_RTSI_CLOCK(rtsi_channel)) {
-					devpriv->clock_and_fout2 |=
-					    MSeries_PLL_In_Source_Select_RTSI_Bits
-					    (rtsi_channel);
-					break;
-				}
-			}
-			if (rtsi_channel > max_rtsi_channel)
-				return -EINVAL;
-			retval = ni_mseries_get_pll_parameters(period_ns,
-							       &freq_divider,
-							       &freq_multiplier,
-							       &devpriv->
-							       clock_ns);
-			if (retval < 0)
-				return retval;
-		}
-		break;
-	}
-	ni_writew(devpriv->clock_and_fout2, M_Offset_Clock_and_Fout2);
-	pll_control_bits |=
-	    MSeries_PLL_Divisor_Bits(freq_divider) |
-	    MSeries_PLL_Multiplier_Bits(freq_multiplier);
-
-	/* printk("using divider=%i, multiplier=%i for PLL. pll_control_bits = 0x%x\n",
-	 * freq_divider, freq_multiplier, pll_control_bits); */
-	/* printk("clock_ns=%d\n", devpriv->clock_ns); */
-	ni_writew(pll_control_bits, M_Offset_PLL_Control);
-	devpriv->clock_source = source;
-	/* it seems to typically take a few hundred microseconds for PLL to lock */
-	for (i = 0; i < timeout; ++i) {
-		if (ni_readw(M_Offset_PLL_Status) & MSeries_PLL_Locked_Bit)
-			break;
-		udelay(1);
-	}
-	if (i == timeout) {
-		printk
-		    ("%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns.\n",
-		     __func__, source, period_ns);
-		return -ETIMEDOUT;
-	}
-	return 3;
-}
-
-static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
-			       unsigned period_ns)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
-
-	if (source == NI_MIO_INTERNAL_CLOCK) {
-		devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
-		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-				    RTSI_Trig_Direction_Register);
-		devpriv->clock_ns = TIMEBASE_1_NS;
-		if (board->reg_type & ni_reg_m_series_mask) {
-			devpriv->clock_and_fout2 &=
-			    ~(MSeries_Timebase1_Select_Bit |
-			      MSeries_Timebase3_Select_Bit);
-			ni_writew(devpriv->clock_and_fout2,
-				  M_Offset_Clock_and_Fout2);
-			ni_writew(0, M_Offset_PLL_Control);
-		}
-		devpriv->clock_source = source;
-	} else {
-		if (board->reg_type & ni_reg_m_series_mask) {
-			return ni_mseries_set_pll_master_clock(dev, source,
-							       period_ns);
-		} else {
-			if (source == NI_MIO_RTSI_CLOCK) {
-				devpriv->rtsi_trig_direction_reg |=
-				    Use_RTSI_Clock_Bit;
-				devpriv->stc_writew(dev,
-						    devpriv->
-						    rtsi_trig_direction_reg,
-						    RTSI_Trig_Direction_Register);
-				if (period_ns == 0) {
-					printk
-					    ("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",
-					     __func__);
-					return -EINVAL;
-				} else {
-					devpriv->clock_ns = period_ns;
-				}
-				devpriv->clock_source = source;
-			} else
-				return -EINVAL;
-		}
-	}
-	return 3;
-}

commit ae43763d347cd87f195bb63daf56dcbb3557c86b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:45 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 22
    
    Move ni_rtsi_insn_config() and its helper functions to remove the need
    for the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 77fda821efa4..ba876dee1922 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -194,10 +194,6 @@ static const struct comedi_lrange *const ni_range_lkup[] = {
 	[ai_gain_6143] = &range_bipolar5
 };
 
-static int ni_rtsi_insn_config(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data);
-
 #ifndef PCIDMA
 static void ni_handle_fifo_half_full(struct comedi_device *dev);
 static int ni_ao_fifo_half_empty(struct comedi_device *dev,
@@ -4691,6 +4687,171 @@ static int init_cs5529(struct comedi_device *dev)
 	return 0;
 }
 
+static unsigned num_configurable_rtsi_channels(struct comedi_device *dev)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+
+	if (board->reg_type & ni_reg_m_series_mask)
+		return 8;
+	else
+		return 7;
+}
+
+static int ni_valid_rtsi_output_source(struct comedi_device *dev,
+				       unsigned chan, unsigned source)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+
+	if (chan >= num_configurable_rtsi_channels(dev)) {
+		if (chan == old_RTSI_clock_channel) {
+			if (source == NI_RTSI_OUTPUT_RTSI_OSC)
+				return 1;
+			else {
+				printk
+				    ("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",
+				     __func__, chan, old_RTSI_clock_channel);
+				return 0;
+			}
+		}
+		return 0;
+	}
+	switch (source) {
+	case NI_RTSI_OUTPUT_ADR_START1:
+	case NI_RTSI_OUTPUT_ADR_START2:
+	case NI_RTSI_OUTPUT_SCLKG:
+	case NI_RTSI_OUTPUT_DACUPDN:
+	case NI_RTSI_OUTPUT_DA_START1:
+	case NI_RTSI_OUTPUT_G_SRC0:
+	case NI_RTSI_OUTPUT_G_GATE0:
+	case NI_RTSI_OUTPUT_RGOUT0:
+	case NI_RTSI_OUTPUT_RTSI_BRD_0:
+		return 1;
+		break;
+	case NI_RTSI_OUTPUT_RTSI_OSC:
+		if (board->reg_type & ni_reg_m_series_mask)
+			return 1;
+		else
+			return 0;
+		break;
+	default:
+		return 0;
+		break;
+	}
+}
+
+static int ni_set_rtsi_routing(struct comedi_device *dev,
+			       unsigned chan, unsigned source)
+{
+	struct ni_private *devpriv = dev->private;
+
+	if (ni_valid_rtsi_output_source(dev, chan, source) == 0)
+		return -EINVAL;
+	if (chan < 4) {
+		devpriv->rtsi_trig_a_output_reg &= ~RTSI_Trig_Output_Mask(chan);
+		devpriv->rtsi_trig_a_output_reg |=
+		    RTSI_Trig_Output_Bits(chan, source);
+		devpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
+				    RTSI_Trig_A_Output_Register);
+	} else if (chan < 8) {
+		devpriv->rtsi_trig_b_output_reg &= ~RTSI_Trig_Output_Mask(chan);
+		devpriv->rtsi_trig_b_output_reg |=
+		    RTSI_Trig_Output_Bits(chan, source);
+		devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
+				    RTSI_Trig_B_Output_Register);
+	}
+	return 2;
+}
+
+static unsigned ni_get_rtsi_routing(struct comedi_device *dev, unsigned chan)
+{
+	struct ni_private *devpriv = dev->private;
+
+	if (chan < 4) {
+		return RTSI_Trig_Output_Source(chan,
+					       devpriv->rtsi_trig_a_output_reg);
+	} else if (chan < num_configurable_rtsi_channels(dev)) {
+		return RTSI_Trig_Output_Source(chan,
+					       devpriv->rtsi_trig_b_output_reg);
+	} else {
+		if (chan == old_RTSI_clock_channel)
+			return NI_RTSI_OUTPUT_RTSI_OSC;
+		printk("%s: bug! should never get here?\n", __func__);
+		return 0;
+	}
+}
+
+static int ni_rtsi_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_OUTPUT:
+		if (chan < num_configurable_rtsi_channels(dev)) {
+			devpriv->rtsi_trig_direction_reg |=
+			    RTSI_Output_Bit(chan,
+				(board->reg_type & ni_reg_m_series_mask) != 0);
+		} else if (chan == old_RTSI_clock_channel) {
+			devpriv->rtsi_trig_direction_reg |=
+			    Drive_RTSI_Clock_Bit;
+		}
+		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+				    RTSI_Trig_Direction_Register);
+		break;
+	case INSN_CONFIG_DIO_INPUT:
+		if (chan < num_configurable_rtsi_channels(dev)) {
+			devpriv->rtsi_trig_direction_reg &=
+			    ~RTSI_Output_Bit(chan,
+				(board->reg_type & ni_reg_m_series_mask) != 0);
+		} else if (chan == old_RTSI_clock_channel) {
+			devpriv->rtsi_trig_direction_reg &=
+			    ~Drive_RTSI_Clock_Bit;
+		}
+		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+				    RTSI_Trig_Direction_Register);
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		if (chan < num_configurable_rtsi_channels(dev)) {
+			data[1] =
+			    (devpriv->rtsi_trig_direction_reg &
+			     RTSI_Output_Bit(chan,
+				(board->reg_type & ni_reg_m_series_mask) != 0))
+				? INSN_CONFIG_DIO_OUTPUT
+				: INSN_CONFIG_DIO_INPUT;
+		} else if (chan == old_RTSI_clock_channel) {
+			data[1] =
+			    (devpriv->rtsi_trig_direction_reg &
+			     Drive_RTSI_Clock_Bit)
+			    ? INSN_CONFIG_DIO_OUTPUT : INSN_CONFIG_DIO_INPUT;
+		}
+		return 2;
+		break;
+	case INSN_CONFIG_SET_CLOCK_SRC:
+		return ni_set_master_clock(dev, data[1], data[2]);
+		break;
+	case INSN_CONFIG_GET_CLOCK_SRC:
+		data[1] = devpriv->clock_source;
+		data[2] = devpriv->clock_ns;
+		return 3;
+		break;
+	case INSN_CONFIG_SET_ROUTING:
+		return ni_set_rtsi_routing(dev, chan, data[1]);
+		break;
+	case INSN_CONFIG_GET_ROUTING:
+		data[1] = ni_get_rtsi_routing(dev, chan);
+		return 2;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 1;
+}
+
 static int ni_rtsi_insn_bits(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn,
@@ -5295,16 +5456,6 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 	return 0;
 }
 
-static inline unsigned num_configurable_rtsi_channels(struct comedi_device *dev)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-
-	if (board->reg_type & ni_reg_m_series_mask)
-		return 8;
-	else
-		return 7;
-}
-
 static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 					   unsigned source, unsigned period_ns)
 {
@@ -5454,157 +5605,3 @@ static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 	}
 	return 3;
 }
-
-static int ni_valid_rtsi_output_source(struct comedi_device *dev, unsigned chan,
-				       unsigned source)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-
-	if (chan >= num_configurable_rtsi_channels(dev)) {
-		if (chan == old_RTSI_clock_channel) {
-			if (source == NI_RTSI_OUTPUT_RTSI_OSC)
-				return 1;
-			else {
-				printk
-				    ("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",
-				     __func__, chan, old_RTSI_clock_channel);
-				return 0;
-			}
-		}
-		return 0;
-	}
-	switch (source) {
-	case NI_RTSI_OUTPUT_ADR_START1:
-	case NI_RTSI_OUTPUT_ADR_START2:
-	case NI_RTSI_OUTPUT_SCLKG:
-	case NI_RTSI_OUTPUT_DACUPDN:
-	case NI_RTSI_OUTPUT_DA_START1:
-	case NI_RTSI_OUTPUT_G_SRC0:
-	case NI_RTSI_OUTPUT_G_GATE0:
-	case NI_RTSI_OUTPUT_RGOUT0:
-	case NI_RTSI_OUTPUT_RTSI_BRD_0:
-		return 1;
-		break;
-	case NI_RTSI_OUTPUT_RTSI_OSC:
-		if (board->reg_type & ni_reg_m_series_mask)
-			return 1;
-		else
-			return 0;
-		break;
-	default:
-		return 0;
-		break;
-	}
-}
-
-static int ni_set_rtsi_routing(struct comedi_device *dev, unsigned chan,
-			       unsigned source)
-{
-	struct ni_private *devpriv = dev->private;
-
-	if (ni_valid_rtsi_output_source(dev, chan, source) == 0)
-		return -EINVAL;
-	if (chan < 4) {
-		devpriv->rtsi_trig_a_output_reg &= ~RTSI_Trig_Output_Mask(chan);
-		devpriv->rtsi_trig_a_output_reg |=
-		    RTSI_Trig_Output_Bits(chan, source);
-		devpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
-				    RTSI_Trig_A_Output_Register);
-	} else if (chan < 8) {
-		devpriv->rtsi_trig_b_output_reg &= ~RTSI_Trig_Output_Mask(chan);
-		devpriv->rtsi_trig_b_output_reg |=
-		    RTSI_Trig_Output_Bits(chan, source);
-		devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
-				    RTSI_Trig_B_Output_Register);
-	}
-	return 2;
-}
-
-static unsigned ni_get_rtsi_routing(struct comedi_device *dev, unsigned chan)
-{
-	struct ni_private *devpriv = dev->private;
-
-	if (chan < 4) {
-		return RTSI_Trig_Output_Source(chan,
-					       devpriv->rtsi_trig_a_output_reg);
-	} else if (chan < num_configurable_rtsi_channels(dev)) {
-		return RTSI_Trig_Output_Source(chan,
-					       devpriv->rtsi_trig_b_output_reg);
-	} else {
-		if (chan == old_RTSI_clock_channel)
-			return NI_RTSI_OUTPUT_RTSI_OSC;
-		printk("%s: bug! should never get here?\n", __func__);
-		return 0;
-	}
-}
-
-static int ni_rtsi_insn_config(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_OUTPUT:
-		if (chan < num_configurable_rtsi_channels(dev)) {
-			devpriv->rtsi_trig_direction_reg |=
-			    RTSI_Output_Bit(chan,
-				(board->reg_type & ni_reg_m_series_mask) != 0);
-		} else if (chan == old_RTSI_clock_channel) {
-			devpriv->rtsi_trig_direction_reg |=
-			    Drive_RTSI_Clock_Bit;
-		}
-		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-				    RTSI_Trig_Direction_Register);
-		break;
-	case INSN_CONFIG_DIO_INPUT:
-		if (chan < num_configurable_rtsi_channels(dev)) {
-			devpriv->rtsi_trig_direction_reg &=
-			    ~RTSI_Output_Bit(chan,
-				(board->reg_type & ni_reg_m_series_mask) != 0);
-		} else if (chan == old_RTSI_clock_channel) {
-			devpriv->rtsi_trig_direction_reg &=
-			    ~Drive_RTSI_Clock_Bit;
-		}
-		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-				    RTSI_Trig_Direction_Register);
-		break;
-	case INSN_CONFIG_DIO_QUERY:
-		if (chan < num_configurable_rtsi_channels(dev)) {
-			data[1] =
-			    (devpriv->rtsi_trig_direction_reg &
-			     RTSI_Output_Bit(chan,
-				(board->reg_type & ni_reg_m_series_mask) != 0))
-				? INSN_CONFIG_DIO_OUTPUT
-				: INSN_CONFIG_DIO_INPUT;
-		} else if (chan == old_RTSI_clock_channel) {
-			data[1] =
-			    (devpriv->rtsi_trig_direction_reg &
-			     Drive_RTSI_Clock_Bit)
-			    ? INSN_CONFIG_DIO_OUTPUT : INSN_CONFIG_DIO_INPUT;
-		}
-		return 2;
-		break;
-	case INSN_CONFIG_SET_CLOCK_SRC:
-		return ni_set_master_clock(dev, data[1], data[2]);
-		break;
-	case INSN_CONFIG_GET_CLOCK_SRC:
-		data[1] = devpriv->clock_source;
-		data[2] = devpriv->clock_ns;
-		return 3;
-		break;
-	case INSN_CONFIG_SET_ROUTING:
-		return ni_set_rtsi_routing(dev, chan, data[1]);
-		break;
-	case INSN_CONFIG_GET_ROUTING:
-		data[1] = ni_get_rtsi_routing(dev, chan);
-		return 2;
-		break;
-	default:
-		return -EINVAL;
-		break;
-	}
-	return 1;
-}

commit 892885eafaf2ff88a6cddf21bba0edc7c6dd6e4f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:44 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 21
    
    Move ni_rtsi_init() to remove the need for the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e88d8ffe03b1..77fda821efa4 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -194,7 +194,6 @@ static const struct comedi_lrange *const ni_range_lkup[] = {
 	[ai_gain_6143] = &range_bipolar5
 };
 
-static void ni_rtsi_init(struct comedi_device *dev);
 static int ni_rtsi_insn_config(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data);
@@ -4702,6 +4701,46 @@ static int ni_rtsi_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
+static void ni_rtsi_init(struct comedi_device *dev)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
+
+	/*  Initialises the RTSI bus signal switch to a default state */
+
+	/*  Set clock mode to internal */
+	devpriv->clock_and_fout2 = MSeries_RTSI_10MHz_Bit;
+	if (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0)
+		printk("ni_set_master_clock failed, bug?");
+	/*  default internal lines routing to RTSI bus lines */
+	devpriv->rtsi_trig_a_output_reg =
+	    RTSI_Trig_Output_Bits(0,
+				  NI_RTSI_OUTPUT_ADR_START1) |
+	    RTSI_Trig_Output_Bits(1,
+				  NI_RTSI_OUTPUT_ADR_START2) |
+	    RTSI_Trig_Output_Bits(2,
+				  NI_RTSI_OUTPUT_SCLKG) |
+	    RTSI_Trig_Output_Bits(3, NI_RTSI_OUTPUT_DACUPDN);
+	devpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
+			    RTSI_Trig_A_Output_Register);
+	devpriv->rtsi_trig_b_output_reg =
+	    RTSI_Trig_Output_Bits(4,
+				  NI_RTSI_OUTPUT_DA_START1) |
+	    RTSI_Trig_Output_Bits(5,
+				  NI_RTSI_OUTPUT_G_SRC0) |
+	    RTSI_Trig_Output_Bits(6, NI_RTSI_OUTPUT_G_GATE0);
+	if (board->reg_type & ni_reg_m_series_mask)
+		devpriv->rtsi_trig_b_output_reg |=
+		    RTSI_Trig_Output_Bits(7, NI_RTSI_OUTPUT_RTSI_OSC);
+	devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
+			    RTSI_Trig_B_Output_Register);
+
+/*
+* Sets the source and direction of the 4 on board lines
+* devpriv->stc_writew(dev, 0x0000, RTSI_Board_Register);
+*/
+}
+
 #ifdef PCIDMA
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
@@ -5211,51 +5250,6 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 
 #endif
 
-/*
- *
- *  NI RTSI Bus Functions
- *
- */
-static void ni_rtsi_init(struct comedi_device *dev)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
-
-	/*  Initialises the RTSI bus signal switch to a default state */
-
-	/*  Set clock mode to internal */
-	devpriv->clock_and_fout2 = MSeries_RTSI_10MHz_Bit;
-	if (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0)
-		printk("ni_set_master_clock failed, bug?");
-	/*  default internal lines routing to RTSI bus lines */
-	devpriv->rtsi_trig_a_output_reg =
-	    RTSI_Trig_Output_Bits(0,
-				  NI_RTSI_OUTPUT_ADR_START1) |
-	    RTSI_Trig_Output_Bits(1,
-				  NI_RTSI_OUTPUT_ADR_START2) |
-	    RTSI_Trig_Output_Bits(2,
-				  NI_RTSI_OUTPUT_SCLKG) |
-	    RTSI_Trig_Output_Bits(3, NI_RTSI_OUTPUT_DACUPDN);
-	devpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
-			    RTSI_Trig_A_Output_Register);
-	devpriv->rtsi_trig_b_output_reg =
-	    RTSI_Trig_Output_Bits(4,
-				  NI_RTSI_OUTPUT_DA_START1) |
-	    RTSI_Trig_Output_Bits(5,
-				  NI_RTSI_OUTPUT_G_SRC0) |
-	    RTSI_Trig_Output_Bits(6, NI_RTSI_OUTPUT_G_GATE0);
-	if (board->reg_type & ni_reg_m_series_mask)
-		devpriv->rtsi_trig_b_output_reg |=
-		    RTSI_Trig_Output_Bits(7, NI_RTSI_OUTPUT_RTSI_OSC);
-	devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
-			    RTSI_Trig_B_Output_Register);
-
-/*
-* Sets the source and direction of the 4 on board lines
-* devpriv->stc_writew(dev, 0x0000, RTSI_Board_Register);
-*/
-}
-
 /* Find best multiplier/divider to try and get the PLL running at 80 MHz
  * given an arbitrary frequency input clock */
 static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,

commit 3d129c3e5fa73391d7af5d091ce2d9ca4226d81a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:43 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 20
    
    Move ni_ai_insn_read() to remove the need for a forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0c2ef4c25a48..e88d8ffe03b1 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -205,8 +205,6 @@ static int ni_ao_fifo_half_empty(struct comedi_device *dev,
 				 struct comedi_subdevice *s);
 #endif
 static void ni_handle_fifo_dregs(struct comedi_device *dev);
-static void ni_load_channelgain_list(struct comedi_device *dev,
-				     unsigned int n_chan, unsigned int *list);
 
 static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 			       unsigned period_ns);
@@ -1525,105 +1523,6 @@ static int ni_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 	return count;
 }
 
-static int ni_ai_insn_read(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
-	int i, n;
-	const unsigned int mask = (1 << board->adbits) - 1;
-	unsigned signbits;
-	unsigned short d;
-	unsigned long dl;
-
-	ni_load_channelgain_list(dev, 1, &insn->chanspec);
-
-	ni_clear_ai_fifo(dev);
-
-	signbits = devpriv->ai_offset[0];
-	if (board->reg_type == ni_reg_611x) {
-		for (n = 0; n < num_adc_stages_611x; n++) {
-			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-					    AI_Command_1_Register);
-			udelay(1);
-		}
-		for (n = 0; n < insn->n; n++) {
-			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-					    AI_Command_1_Register);
-			/* The 611x has screwy 32-bit FIFOs. */
-			d = 0;
-			for (i = 0; i < NI_TIMEOUT; i++) {
-				if (ni_readb(XXX_Status) & 0x80) {
-					d = (ni_readl(ADC_FIFO_Data_611x) >> 16)
-					    & 0xffff;
-					break;
-				}
-				if (!(devpriv->stc_readw(dev,
-							 AI_Status_1_Register) &
-				      AI_FIFO_Empty_St)) {
-					d = ni_readl(ADC_FIFO_Data_611x) &
-					    0xffff;
-					break;
-				}
-			}
-			if (i == NI_TIMEOUT) {
-				printk
-				    ("ni_mio_common: timeout in 611x ni_ai_insn_read\n");
-				return -ETIME;
-			}
-			d += signbits;
-			data[n] = d;
-		}
-	} else if (board->reg_type == ni_reg_6143) {
-		for (n = 0; n < insn->n; n++) {
-			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-					    AI_Command_1_Register);
-
-			/* The 6143 has 32-bit FIFOs. You need to strobe a bit to move a single 16bit stranded sample into the FIFO */
-			dl = 0;
-			for (i = 0; i < NI_TIMEOUT; i++) {
-				if (ni_readl(AIFIFO_Status_6143) & 0x01) {
-					ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
-					dl = ni_readl(AIFIFO_Data_6143);
-					break;
-				}
-			}
-			if (i == NI_TIMEOUT) {
-				printk
-				    ("ni_mio_common: timeout in 6143 ni_ai_insn_read\n");
-				return -ETIME;
-			}
-			data[n] = (((dl >> 16) & 0xFFFF) + signbits) & 0xFFFF;
-		}
-	} else {
-		for (n = 0; n < insn->n; n++) {
-			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-					    AI_Command_1_Register);
-			for (i = 0; i < NI_TIMEOUT; i++) {
-				if (!(devpriv->stc_readw(dev,
-							 AI_Status_1_Register) &
-				      AI_FIFO_Empty_St))
-					break;
-			}
-			if (i == NI_TIMEOUT) {
-				printk
-				    ("ni_mio_common: timeout in ni_ai_insn_read\n");
-				return -ETIME;
-			}
-			if (board->reg_type & ni_reg_m_series_mask) {
-				data[n] =
-				    ni_readl(M_Offset_AI_FIFO_Data) & mask;
-			} else {
-				d = ni_readw(ADC_FIFO_Data_Register);
-				d += signbits;	/* subtle: needs to be short addition */
-				data[n] = d;
-			}
-		}
-	}
-	return insn->n;
-}
-
 static void ni_prime_channelgain_list(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;
@@ -1870,6 +1769,106 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 	}
 }
 
+static int ni_ai_insn_read(struct comedi_device *dev,
+			   struct comedi_subdevice *s,
+			   struct comedi_insn *insn,
+			   unsigned int *data)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
+	int i, n;
+	const unsigned int mask = (1 << board->adbits) - 1;
+	unsigned signbits;
+	unsigned short d;
+	unsigned long dl;
+
+	ni_load_channelgain_list(dev, 1, &insn->chanspec);
+
+	ni_clear_ai_fifo(dev);
+
+	signbits = devpriv->ai_offset[0];
+	if (board->reg_type == ni_reg_611x) {
+		for (n = 0; n < num_adc_stages_611x; n++) {
+			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
+					    AI_Command_1_Register);
+			udelay(1);
+		}
+		for (n = 0; n < insn->n; n++) {
+			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
+					    AI_Command_1_Register);
+			/* The 611x has screwy 32-bit FIFOs. */
+			d = 0;
+			for (i = 0; i < NI_TIMEOUT; i++) {
+				if (ni_readb(XXX_Status) & 0x80) {
+					d = (ni_readl(ADC_FIFO_Data_611x) >> 16)
+					    & 0xffff;
+					break;
+				}
+				if (!(devpriv->stc_readw(dev,
+							 AI_Status_1_Register) &
+				      AI_FIFO_Empty_St)) {
+					d = ni_readl(ADC_FIFO_Data_611x) &
+					    0xffff;
+					break;
+				}
+			}
+			if (i == NI_TIMEOUT) {
+				printk
+				    ("ni_mio_common: timeout in 611x ni_ai_insn_read\n");
+				return -ETIME;
+			}
+			d += signbits;
+			data[n] = d;
+		}
+	} else if (board->reg_type == ni_reg_6143) {
+		for (n = 0; n < insn->n; n++) {
+			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
+					    AI_Command_1_Register);
+
+			/* The 6143 has 32-bit FIFOs. You need to strobe a bit to move a single 16bit stranded sample into the FIFO */
+			dl = 0;
+			for (i = 0; i < NI_TIMEOUT; i++) {
+				if (ni_readl(AIFIFO_Status_6143) & 0x01) {
+					ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
+					dl = ni_readl(AIFIFO_Data_6143);
+					break;
+				}
+			}
+			if (i == NI_TIMEOUT) {
+				printk
+				    ("ni_mio_common: timeout in 6143 ni_ai_insn_read\n");
+				return -ETIME;
+			}
+			data[n] = (((dl >> 16) & 0xFFFF) + signbits) & 0xFFFF;
+		}
+	} else {
+		for (n = 0; n < insn->n; n++) {
+			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
+					    AI_Command_1_Register);
+			for (i = 0; i < NI_TIMEOUT; i++) {
+				if (!(devpriv->stc_readw(dev,
+							 AI_Status_1_Register) &
+				      AI_FIFO_Empty_St))
+					break;
+			}
+			if (i == NI_TIMEOUT) {
+				printk
+				    ("ni_mio_common: timeout in ni_ai_insn_read\n");
+				return -ETIME;
+			}
+			if (board->reg_type & ni_reg_m_series_mask) {
+				data[n] =
+				    ni_readl(M_Offset_AI_FIFO_Data) & mask;
+			} else {
+				d = ni_readw(ADC_FIFO_Data_Register);
+				d += signbits;	/* subtle: needs to be short addition */
+				data[n] = d;
+			}
+		}
+	}
+	return insn->n;
+}
+
 static int ni_ns_to_timer(const struct comedi_device *dev, unsigned nanosec,
 			  int round_mode)
 {

commit c75527fbf688efb40aa58da08eb622af40cb8841
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:42 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 19
    
    Move ni_E_interrupt() to remove the need for some forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5a33b24f464b..0c2ef4c25a48 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -194,8 +194,6 @@ static const struct comedi_lrange *const ni_range_lkup[] = {
 	[ai_gain_6143] = &range_bipolar5
 };
 
-static void handle_cdio_interrupt(struct comedi_device *dev);
-
 static void ni_rtsi_init(struct comedi_device *dev);
 static int ni_rtsi_insn_config(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
@@ -210,13 +208,8 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev);
 static void ni_load_channelgain_list(struct comedi_device *dev,
 				     unsigned int n_chan, unsigned int *list);
 
-static void handle_gpct_interrupt(struct comedi_device *dev,
-				  unsigned short counter_index);
-
 static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 			       unsigned period_ns);
-static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status);
-static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status);
 
 enum aimodes {
 	AIMODE_NONE = 0,
@@ -270,11 +263,6 @@ enum timebase_nanoseconds {
 
 static const int num_adc_stages_611x = 3;
 
-static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
-			       unsigned ai_mite_status);
-static void handle_b_interrupt(struct comedi_device *dev, unsigned short status,
-			       unsigned ao_mite_status);
-
 static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 				   unsigned bit_mask, unsigned bit_values)
 {
@@ -709,65 +697,6 @@ static inline void ni_set_bits(struct comedi_device *dev, int reg,
 	ni_set_bitfield(dev, reg, bits, bit_values);
 }
 
-static irqreturn_t ni_E_interrupt(int irq, void *d)
-{
-	struct comedi_device *dev = d;
-	struct ni_private *devpriv = dev->private;
-	unsigned short a_status;
-	unsigned short b_status;
-	unsigned int ai_mite_status = 0;
-	unsigned int ao_mite_status = 0;
-	unsigned long flags;
-#ifdef PCIDMA
-	struct mite_struct *mite = devpriv->mite;
-#endif
-
-	if (!dev->attached)
-		return IRQ_NONE;
-	smp_mb();		/*  make sure dev->attached is checked before handler does anything else. */
-
-	/*  lock to avoid race with comedi_poll */
-	spin_lock_irqsave(&dev->spinlock, flags);
-	a_status = devpriv->stc_readw(dev, AI_Status_1_Register);
-	b_status = devpriv->stc_readw(dev, AO_Status_1_Register);
-#ifdef PCIDMA
-	if (mite) {
-		unsigned long flags_too;
-
-		spin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);
-		if (devpriv->ai_mite_chan) {
-			ai_mite_status = mite_get_status(devpriv->ai_mite_chan);
-			if (ai_mite_status & CHSR_LINKC)
-				writel(CHOR_CLRLC,
-				       devpriv->mite->mite_io_addr +
-				       MITE_CHOR(devpriv->
-						 ai_mite_chan->channel));
-		}
-		if (devpriv->ao_mite_chan) {
-			ao_mite_status = mite_get_status(devpriv->ao_mite_chan);
-			if (ao_mite_status & CHSR_LINKC)
-				writel(CHOR_CLRLC,
-				       mite->mite_io_addr +
-				       MITE_CHOR(devpriv->
-						 ao_mite_chan->channel));
-		}
-		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);
-	}
-#endif
-	ack_a_interrupt(dev, a_status);
-	ack_b_interrupt(dev, b_status);
-	if ((a_status & Interrupt_A_St) || (ai_mite_status & CHSR_INT))
-		handle_a_interrupt(dev, a_status, ai_mite_status);
-	if ((b_status & Interrupt_B_St) || (ao_mite_status & CHSR_INT))
-		handle_b_interrupt(dev, b_status, ao_mite_status);
-	handle_gpct_interrupt(dev, 0);
-	handle_gpct_interrupt(dev, 1);
-	handle_cdio_interrupt(dev);
-
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-	return IRQ_HANDLED;
-}
-
 #ifdef PCIDMA
 static void ni_sync_ai_dma(struct comedi_device *dev)
 {
@@ -4805,6 +4734,65 @@ static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 #endif
 
+static irqreturn_t ni_E_interrupt(int irq, void *d)
+{
+	struct comedi_device *dev = d;
+	struct ni_private *devpriv = dev->private;
+	unsigned short a_status;
+	unsigned short b_status;
+	unsigned int ai_mite_status = 0;
+	unsigned int ao_mite_status = 0;
+	unsigned long flags;
+#ifdef PCIDMA
+	struct mite_struct *mite = devpriv->mite;
+#endif
+
+	if (!dev->attached)
+		return IRQ_NONE;
+	smp_mb();		/*  make sure dev->attached is checked before handler does anything else. */
+
+	/*  lock to avoid race with comedi_poll */
+	spin_lock_irqsave(&dev->spinlock, flags);
+	a_status = devpriv->stc_readw(dev, AI_Status_1_Register);
+	b_status = devpriv->stc_readw(dev, AO_Status_1_Register);
+#ifdef PCIDMA
+	if (mite) {
+		unsigned long flags_too;
+
+		spin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);
+		if (devpriv->ai_mite_chan) {
+			ai_mite_status = mite_get_status(devpriv->ai_mite_chan);
+			if (ai_mite_status & CHSR_LINKC)
+				writel(CHOR_CLRLC,
+				       devpriv->mite->mite_io_addr +
+				       MITE_CHOR(devpriv->
+						 ai_mite_chan->channel));
+		}
+		if (devpriv->ao_mite_chan) {
+			ao_mite_status = mite_get_status(devpriv->ao_mite_chan);
+			if (ao_mite_status & CHSR_LINKC)
+				writel(CHOR_CLRLC,
+				       mite->mite_io_addr +
+				       MITE_CHOR(devpriv->
+						 ao_mite_chan->channel));
+		}
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);
+	}
+#endif
+	ack_a_interrupt(dev, a_status);
+	ack_b_interrupt(dev, b_status);
+	if ((a_status & Interrupt_A_St) || (ai_mite_status & CHSR_INT))
+		handle_a_interrupt(dev, a_status, ai_mite_status);
+	if ((b_status & Interrupt_B_St) || (ao_mite_status & CHSR_INT))
+		handle_b_interrupt(dev, b_status, ao_mite_status);
+	handle_gpct_interrupt(dev, 0);
+	handle_gpct_interrupt(dev, 1);
+	handle_cdio_interrupt(dev);
+
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+	return IRQ_HANDLED;
+}
+
 static int ni_E_init(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);

commit 2655c8a1d7305ce0f80c748a37efbb8252dc01ae
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:41 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 18
    
    Move ni_ai_drain_dma() to remove the need for the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2a592a4d6e8c..5a33b24f464b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -321,8 +321,6 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 }
 
 #ifdef PCIDMA
-static int ni_ai_drain_dma(struct comedi_device *dev);
-
 /* DMA channel setup */
 
 /* negative channel means no channel */
@@ -783,6 +781,41 @@ static void ni_sync_ai_dma(struct comedi_device *dev)
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
+static int ni_ai_drain_dma(struct comedi_device *dev)
+{
+	struct ni_private *devpriv = dev->private;
+	int i;
+	static const int timeout = 10000;
+	unsigned long flags;
+	int retval = 0;
+
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if (devpriv->ai_mite_chan) {
+		for (i = 0; i < timeout; i++) {
+			if ((devpriv->stc_readw(dev,
+						AI_Status_1_Register) &
+			     AI_FIFO_Empty_St)
+			    && mite_bytes_in_transit(devpriv->ai_mite_chan) ==
+			    0)
+				break;
+			udelay(5);
+		}
+		if (i == timeout) {
+			printk("ni_mio_common: wait for dma drain timed out\n");
+			printk
+			    ("mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
+			     mite_bytes_in_transit(devpriv->ai_mite_chan),
+			     devpriv->stc_readw(dev, AI_Status_1_Register));
+			retval = -1;
+		}
+	}
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+
+	ni_sync_ai_dma(dev);
+
+	return retval;
+}
+
 static void mite_handle_b_linkc(struct mite_struct *mite,
 				struct comedi_device *dev)
 {
@@ -1272,42 +1305,6 @@ static void ni_handle_fifo_half_full(struct comedi_device *dev)
 }
 #endif
 
-#ifdef PCIDMA
-static int ni_ai_drain_dma(struct comedi_device *dev)
-{
-	struct ni_private *devpriv = dev->private;
-	int i;
-	static const int timeout = 10000;
-	unsigned long flags;
-	int retval = 0;
-
-	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	if (devpriv->ai_mite_chan) {
-		for (i = 0; i < timeout; i++) {
-			if ((devpriv->stc_readw(dev,
-						AI_Status_1_Register) &
-			     AI_FIFO_Empty_St)
-			    && mite_bytes_in_transit(devpriv->ai_mite_chan) ==
-			    0)
-				break;
-			udelay(5);
-		}
-		if (i == timeout) {
-			printk("ni_mio_common: wait for dma drain timed out\n");
-			printk
-			    ("mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
-			     mite_bytes_in_transit(devpriv->ai_mite_chan),
-			     devpriv->stc_readw(dev, AI_Status_1_Register));
-			retval = -1;
-		}
-	}
-	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-
-	ni_sync_ai_dma(dev);
-
-	return retval;
-}
-#endif
 /*
    Empties the AI fifo
 */

commit f8f6d91d8e65cf5eaaa861eb842f466aab30a9a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:40 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 17
    
    Move the get_last_sample_*() helpers to remove the need for the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 65c20c98dd94..2a592a4d6e8c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -274,8 +274,6 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			       unsigned ai_mite_status);
 static void handle_b_interrupt(struct comedi_device *dev, unsigned short status,
 			       unsigned ao_mite_status);
-static void get_last_sample_611x(struct comedi_device *dev);
-static void get_last_sample_6143(struct comedi_device *dev);
 
 static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 				   unsigned bit_mask, unsigned bit_values)
@@ -821,6 +819,47 @@ static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 }
 #endif /* PCIDMA */
 
+static void get_last_sample_611x(struct comedi_device *dev)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv __maybe_unused = dev->private;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+	unsigned short data;
+	u32 dl;
+
+	if (board->reg_type != ni_reg_611x)
+		return;
+
+	/* Check if there's a single sample stuck in the FIFO */
+	if (ni_readb(XXX_Status) & 0x80) {
+		dl = ni_readl(ADC_FIFO_Data_611x);
+		data = (dl & 0xffff);
+		cfc_write_to_buffer(s, data);
+	}
+}
+
+static void get_last_sample_6143(struct comedi_device *dev)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv __maybe_unused = dev->private;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+	unsigned short data;
+	u32 dl;
+
+	if (board->reg_type != ni_reg_6143)
+		return;
+
+	/* Check if there's a single sample stuck in the FIFO */
+	if (ni_readl(AIFIFO_Status_6143) & 0x01) {
+		ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
+		dl = ni_readl(AIFIFO_Data_6143);
+
+		/* This may get the hi/lo data in the wrong order */
+		data = (dl >> 16) & 0xffff;
+		cfc_write_to_buffer(s, data);
+	}
+}
+
 static void shutdown_ai_command(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
@@ -1338,47 +1377,6 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 	}
 }
 
-static void get_last_sample_611x(struct comedi_device *dev)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv __maybe_unused = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
-	unsigned short data;
-	u32 dl;
-
-	if (board->reg_type != ni_reg_611x)
-		return;
-
-	/* Check if there's a single sample stuck in the FIFO */
-	if (ni_readb(XXX_Status) & 0x80) {
-		dl = ni_readl(ADC_FIFO_Data_611x);
-		data = (dl & 0xffff);
-		cfc_write_to_buffer(s, data);
-	}
-}
-
-static void get_last_sample_6143(struct comedi_device *dev)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv __maybe_unused = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
-	unsigned short data;
-	u32 dl;
-
-	if (board->reg_type != ni_reg_6143)
-		return;
-
-	/* Check if there's a single sample stuck in the FIFO */
-	if (ni_readl(AIFIFO_Status_6143) & 0x01) {
-		ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
-		dl = ni_readl(AIFIFO_Data_6143);
-
-		/* This may get the hi/lo data in the wrong order */
-		data = (dl >> 16) & 0xffff;
-		cfc_write_to_buffer(s, data);
-	}
-}
-
 static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 			void *data, unsigned int num_bytes,
 			unsigned int chan_index)

commit d2a577c0226c98ad5c6d8ca6cc3e08879dac49d9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:39 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 16
    
    Move ni_ai_insn_config() to remove the need for a forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d520417fc0dc..65c20c98dd94 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2461,66 +2461,6 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int ni_ai_config_analog_trig(struct comedi_device *dev,
-				    struct comedi_subdevice *s,
-				    struct comedi_insn *insn,
-				    unsigned int *data);
-
-static int ni_ai_insn_config(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
-
-	if (insn->n < 1)
-		return -EINVAL;
-
-	switch (data[0]) {
-	case INSN_CONFIG_ANALOG_TRIG:
-		return ni_ai_config_analog_trig(dev, s, insn, data);
-	case INSN_CONFIG_ALT_SOURCE:
-		if (board->reg_type & ni_reg_m_series_mask) {
-			if (data[1] & ~(MSeries_AI_Bypass_Cal_Sel_Pos_Mask |
-					MSeries_AI_Bypass_Cal_Sel_Neg_Mask |
-					MSeries_AI_Bypass_Mode_Mux_Mask |
-					MSeries_AO_Bypass_AO_Cal_Sel_Mask)) {
-				return -EINVAL;
-			}
-			devpriv->ai_calib_source = data[1];
-		} else if (board->reg_type == ni_reg_6143) {
-			unsigned int calib_source;
-
-			calib_source = data[1] & 0xf;
-
-			if (calib_source > 0xF)
-				return -EINVAL;
-
-			devpriv->ai_calib_source = calib_source;
-			ni_writew(calib_source, Calibration_Channel_6143);
-		} else {
-			unsigned int calib_source;
-			unsigned int calib_source_adjust;
-
-			calib_source = data[1] & 0xf;
-			calib_source_adjust = (data[1] >> 4) & 0xff;
-
-			if (calib_source >= 8)
-				return -EINVAL;
-			devpriv->ai_calib_source = calib_source;
-			if (board->reg_type == ni_reg_611x) {
-				ni_writeb(calib_source_adjust,
-					  Cal_Gain_Select_611x);
-			}
-		}
-		return 2;
-	default:
-		break;
-	}
-
-	return -EINVAL;
-}
-
 static int ni_ai_config_analog_trig(struct comedi_device *dev,
 				    struct comedi_subdevice *s,
 				    struct comedi_insn *insn,
@@ -2621,6 +2561,61 @@ static int ni_ai_config_analog_trig(struct comedi_device *dev,
 	return 5;
 }
 
+static int ni_ai_insn_config(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
+
+	if (insn->n < 1)
+		return -EINVAL;
+
+	switch (data[0]) {
+	case INSN_CONFIG_ANALOG_TRIG:
+		return ni_ai_config_analog_trig(dev, s, insn, data);
+	case INSN_CONFIG_ALT_SOURCE:
+		if (board->reg_type & ni_reg_m_series_mask) {
+			if (data[1] & ~(MSeries_AI_Bypass_Cal_Sel_Pos_Mask |
+					MSeries_AI_Bypass_Cal_Sel_Neg_Mask |
+					MSeries_AI_Bypass_Mode_Mux_Mask |
+					MSeries_AO_Bypass_AO_Cal_Sel_Mask)) {
+				return -EINVAL;
+			}
+			devpriv->ai_calib_source = data[1];
+		} else if (board->reg_type == ni_reg_6143) {
+			unsigned int calib_source;
+
+			calib_source = data[1] & 0xf;
+
+			if (calib_source > 0xF)
+				return -EINVAL;
+
+			devpriv->ai_calib_source = calib_source;
+			ni_writew(calib_source, Calibration_Channel_6143);
+		} else {
+			unsigned int calib_source;
+			unsigned int calib_source_adjust;
+
+			calib_source = data[1] & 0xf;
+			calib_source_adjust = (data[1] >> 4) & 0xff;
+
+			if (calib_source >= 8)
+				return -EINVAL;
+			devpriv->ai_calib_source = calib_source;
+			if (board->reg_type == ni_reg_611x) {
+				ni_writeb(calib_source_adjust,
+					  Cal_Gain_Select_611x);
+			}
+		}
+		return 2;
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+
 /* munge data from unsigned to 2's complement for analog output bipolar modes */
 static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 			void *data, unsigned int num_bytes,

commit 8511b8582378c7dbf8f75015fae5570a6a46250a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:38 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 15
    
    Move ni_ai_inttrig() to remove the need for the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e5463c9253aa..d520417fc0dc 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -207,8 +207,6 @@ static int ni_ao_fifo_half_empty(struct comedi_device *dev,
 				 struct comedi_subdevice *s);
 #endif
 static void ni_handle_fifo_dregs(struct comedi_device *dev);
-static int ni_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-			 unsigned int trignum);
 static void ni_load_channelgain_list(struct comedi_device *dev,
 				     unsigned int n_chan, unsigned int *list);
 
@@ -2151,6 +2149,23 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	return 0;
 }
 
+static int ni_ai_inttrig(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 unsigned int trig_num)
+{
+	struct ni_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+
+	if (trig_num != cmd->start_arg)
+		return -EINVAL;
+
+	devpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
+			    AI_Command_2_Register);
+	s->async->inttrig = NULL;
+
+	return 1;
+}
+
 static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
@@ -2446,23 +2461,6 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int ni_ai_inttrig(struct comedi_device *dev,
-			 struct comedi_subdevice *s,
-			 unsigned int trig_num)
-{
-	struct ni_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
-
-	if (trig_num != cmd->start_arg)
-		return -EINVAL;
-
-	devpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
-			    AI_Command_2_Register);
-	s->async->inttrig = NULL;
-
-	return 1;
-}
-
 static int ni_ai_config_analog_trig(struct comedi_device *dev,
 				    struct comedi_subdevice *s,
 				    struct comedi_insn *insn,

commit f8246dfadb8a9661d0f79138115370df6c81bd56
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:37 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 14
    
    Move shutdown_ai_command() to remove the need for the forward
    declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 9897f320325d..e5463c9253aa 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -211,7 +211,6 @@ static int ni_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 			 unsigned int trignum);
 static void ni_load_channelgain_list(struct comedi_device *dev,
 				     unsigned int n_chan, unsigned int *list);
-static void shutdown_ai_command(struct comedi_device *dev);
 
 static void handle_gpct_interrupt(struct comedi_device *dev,
 				  unsigned short counter_index);
@@ -822,8 +821,22 @@ static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 	}
 	return 0;
 }
-
 #endif /* PCIDMA */
+
+static void shutdown_ai_command(struct comedi_device *dev)
+{
+	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+
+#ifdef PCIDMA
+	ni_ai_drain_dma(dev);
+#endif
+	ni_handle_fifo_dregs(dev);
+	get_last_sample_611x(dev);
+	get_last_sample_6143(dev);
+
+	s->async->events |= COMEDI_CB_EOA;
+}
+
 static void ni_handle_eos(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct ni_private *devpriv = dev->private;
@@ -849,20 +862,6 @@ static void ni_handle_eos(struct comedi_device *dev, struct comedi_subdevice *s)
 		shutdown_ai_command(dev);
 }
 
-static void shutdown_ai_command(struct comedi_device *dev)
-{
-	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
-
-#ifdef PCIDMA
-	ni_ai_drain_dma(dev);
-#endif
-	ni_handle_fifo_dregs(dev);
-	get_last_sample_611x(dev);
-	get_last_sample_6143(dev);
-
-	s->async->events |= COMEDI_CB_EOA;
-}
-
 static void handle_gpct_interrupt(struct comedi_device *dev,
 				  unsigned short counter_index)
 {

commit 189e173681d8b4a84e2e071816fe30b64710efaa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:36 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 13
    
    Move ni_serial_insn_config() to remove the need for some forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a6edb9442a38..9897f320325d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -196,15 +196,6 @@ static const struct comedi_lrange *const ni_range_lkup[] = {
 
 static void handle_cdio_interrupt(struct comedi_device *dev);
 
-static int ni_serial_hw_readwrite8(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   unsigned char data_out,
-				   unsigned char *data_in);
-static int ni_serial_sw_readwrite8(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   unsigned char data_out,
-				   unsigned char *data_in);
-
 static void ni_rtsi_init(struct comedi_device *dev);
 static int ni_rtsi_insn_config(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
@@ -3590,97 +3581,6 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	cfc_handle_events(dev, s);
 }
 
-static int ni_serial_insn_config(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn, unsigned int *data)
-{
-	struct ni_private *devpriv = dev->private;
-	int err = insn->n;
-	unsigned char byte_out, byte_in = 0;
-
-	if (insn->n != 2)
-		return -EINVAL;
-
-	switch (data[0]) {
-	case INSN_CONFIG_SERIAL_CLOCK:
-		devpriv->serial_hw_mode = 1;
-		devpriv->dio_control |= DIO_HW_Serial_Enable;
-
-		if (data[1] == SERIAL_DISABLED) {
-			devpriv->serial_hw_mode = 0;
-			devpriv->dio_control &= ~(DIO_HW_Serial_Enable |
-						  DIO_Software_Serial_Control);
-			data[1] = SERIAL_DISABLED;
-			devpriv->serial_interval_ns = data[1];
-		} else if (data[1] <= SERIAL_600NS) {
-			/* Warning: this clock speed is too fast to reliably
-			   control SCXI. */
-			devpriv->dio_control &= ~DIO_HW_Serial_Timebase;
-			devpriv->clock_and_fout |= Slow_Internal_Timebase;
-			devpriv->clock_and_fout &= ~DIO_Serial_Out_Divide_By_2;
-			data[1] = SERIAL_600NS;
-			devpriv->serial_interval_ns = data[1];
-		} else if (data[1] <= SERIAL_1_2US) {
-			devpriv->dio_control &= ~DIO_HW_Serial_Timebase;
-			devpriv->clock_and_fout |= Slow_Internal_Timebase |
-			    DIO_Serial_Out_Divide_By_2;
-			data[1] = SERIAL_1_2US;
-			devpriv->serial_interval_ns = data[1];
-		} else if (data[1] <= SERIAL_10US) {
-			devpriv->dio_control |= DIO_HW_Serial_Timebase;
-			devpriv->clock_and_fout |= Slow_Internal_Timebase |
-			    DIO_Serial_Out_Divide_By_2;
-			/* Note: DIO_Serial_Out_Divide_By_2 only affects
-			   600ns/1.2us. If you turn divide_by_2 off with the
-			   slow clock, you will still get 10us, except then
-			   all your delays are wrong. */
-			data[1] = SERIAL_10US;
-			devpriv->serial_interval_ns = data[1];
-		} else {
-			devpriv->dio_control &= ~(DIO_HW_Serial_Enable |
-						  DIO_Software_Serial_Control);
-			devpriv->serial_hw_mode = 0;
-			data[1] = (data[1] / 1000) * 1000;
-			devpriv->serial_interval_ns = data[1];
-		}
-
-		devpriv->stc_writew(dev, devpriv->dio_control,
-				    DIO_Control_Register);
-		devpriv->stc_writew(dev, devpriv->clock_and_fout,
-				    Clock_and_FOUT_Register);
-		return 1;
-
-		break;
-
-	case INSN_CONFIG_BIDIRECTIONAL_DATA:
-
-		if (devpriv->serial_interval_ns == 0)
-			return -EINVAL;
-
-		byte_out = data[1] & 0xFF;
-
-		if (devpriv->serial_hw_mode) {
-			err = ni_serial_hw_readwrite8(dev, s, byte_out,
-						      &byte_in);
-		} else if (devpriv->serial_interval_ns > 0) {
-			err = ni_serial_sw_readwrite8(dev, s, byte_out,
-						      &byte_in);
-		} else {
-			printk("ni_serial_insn_config: serial disabled!\n");
-			return -EINVAL;
-		}
-		if (err < 0)
-			return err;
-		data[1] = byte_in & 0xFF;
-		return insn->n;
-
-		break;
-	default:
-		return -EINVAL;
-	}
-
-}
-
 static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   unsigned char data_out,
@@ -3781,6 +3681,98 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 	return 0;
 }
 
+static int ni_serial_insn_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
+{
+	struct ni_private *devpriv = dev->private;
+	int err = insn->n;
+	unsigned char byte_out, byte_in = 0;
+
+	if (insn->n != 2)
+		return -EINVAL;
+
+	switch (data[0]) {
+	case INSN_CONFIG_SERIAL_CLOCK:
+		devpriv->serial_hw_mode = 1;
+		devpriv->dio_control |= DIO_HW_Serial_Enable;
+
+		if (data[1] == SERIAL_DISABLED) {
+			devpriv->serial_hw_mode = 0;
+			devpriv->dio_control &= ~(DIO_HW_Serial_Enable |
+						  DIO_Software_Serial_Control);
+			data[1] = SERIAL_DISABLED;
+			devpriv->serial_interval_ns = data[1];
+		} else if (data[1] <= SERIAL_600NS) {
+			/* Warning: this clock speed is too fast to reliably
+			   control SCXI. */
+			devpriv->dio_control &= ~DIO_HW_Serial_Timebase;
+			devpriv->clock_and_fout |= Slow_Internal_Timebase;
+			devpriv->clock_and_fout &= ~DIO_Serial_Out_Divide_By_2;
+			data[1] = SERIAL_600NS;
+			devpriv->serial_interval_ns = data[1];
+		} else if (data[1] <= SERIAL_1_2US) {
+			devpriv->dio_control &= ~DIO_HW_Serial_Timebase;
+			devpriv->clock_and_fout |= Slow_Internal_Timebase |
+			    DIO_Serial_Out_Divide_By_2;
+			data[1] = SERIAL_1_2US;
+			devpriv->serial_interval_ns = data[1];
+		} else if (data[1] <= SERIAL_10US) {
+			devpriv->dio_control |= DIO_HW_Serial_Timebase;
+			devpriv->clock_and_fout |= Slow_Internal_Timebase |
+			    DIO_Serial_Out_Divide_By_2;
+			/* Note: DIO_Serial_Out_Divide_By_2 only affects
+			   600ns/1.2us. If you turn divide_by_2 off with the
+			   slow clock, you will still get 10us, except then
+			   all your delays are wrong. */
+			data[1] = SERIAL_10US;
+			devpriv->serial_interval_ns = data[1];
+		} else {
+			devpriv->dio_control &= ~(DIO_HW_Serial_Enable |
+						  DIO_Software_Serial_Control);
+			devpriv->serial_hw_mode = 0;
+			data[1] = (data[1] / 1000) * 1000;
+			devpriv->serial_interval_ns = data[1];
+		}
+
+		devpriv->stc_writew(dev, devpriv->dio_control,
+				    DIO_Control_Register);
+		devpriv->stc_writew(dev, devpriv->clock_and_fout,
+				    Clock_and_FOUT_Register);
+		return 1;
+
+		break;
+
+	case INSN_CONFIG_BIDIRECTIONAL_DATA:
+
+		if (devpriv->serial_interval_ns == 0)
+			return -EINVAL;
+
+		byte_out = data[1] & 0xFF;
+
+		if (devpriv->serial_hw_mode) {
+			err = ni_serial_hw_readwrite8(dev, s, byte_out,
+						      &byte_in);
+		} else if (devpriv->serial_interval_ns > 0) {
+			err = ni_serial_sw_readwrite8(dev, s, byte_out,
+						      &byte_in);
+		} else {
+			printk("ni_serial_insn_config: serial disabled!\n");
+			return -EINVAL;
+		}
+		if (err < 0)
+			return err;
+		data[1] = byte_in & 0xFF;
+		return insn->n;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+}
+
 static void mio_common_detach(struct comedi_device *dev)
 {
 	struct ni_private *devpriv = dev->private;

commit fed37a1e70df88f020db1e53403d70ce67f0802f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:35 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 12
    
    Remove the need for the forward declaration of ni_cdio_cancel() by
    indirectly calling it using the subdevice (*cancel).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e8409b0d58bc..a6edb9442a38 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -194,8 +194,6 @@ static const struct comedi_lrange *const ni_range_lkup[] = {
 	[ai_gain_6143] = &range_bipolar5
 };
 
-static int ni_cdio_cancel(struct comedi_device *dev,
-			  struct comedi_subdevice *s);
 static void handle_cdio_interrupt(struct comedi_device *dev);
 
 static int ni_serial_hw_readwrite8(struct comedi_device *dev,
@@ -3485,7 +3483,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 	}
 	if (i == timeout) {
 		comedi_error(dev, "dma failed to fill cdo fifo!");
-		ni_cdio_cancel(dev, s);
+		s->cancel(dev, s);
 		return -EIO;
 	}
 	ni_writel(CDO_Arm_Bit | CDO_Error_Interrupt_Enable_Set_Bit |

commit 0792928fd61dd5371a0dab64b6cbee40fbbbdc14
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:34 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 11
    
    Move ni_cdio_cmd() to remove the need for the forward declaration
    of ni_cdo_inttrig().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d37c063d8f8a..e8409b0d58bc 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -197,8 +197,6 @@ static const struct comedi_lrange *const ni_range_lkup[] = {
 static int ni_cdio_cancel(struct comedi_device *dev,
 			  struct comedi_subdevice *s);
 static void handle_cdio_interrupt(struct comedi_device *dev);
-static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-			  unsigned int trignum);
 
 static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
@@ -3441,45 +3439,6 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
-static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	struct ni_private *devpriv __maybe_unused = dev->private;
-	const struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;
-	int retval;
-
-	ni_writel(CDO_Reset_Bit, M_Offset_CDIO_Command);
-	switch (cmd->scan_begin_src) {
-	case TRIG_EXT:
-		cdo_mode_bits |=
-		    CR_CHAN(cmd->scan_begin_arg) &
-		    CDO_Sample_Source_Select_Mask;
-		break;
-	default:
-		BUG();
-		break;
-	}
-	if (cmd->scan_begin_arg & CR_INVERT)
-		cdo_mode_bits |= CDO_Polarity_Bit;
-	ni_writel(cdo_mode_bits, M_Offset_CDO_Mode);
-	if (s->io_bits) {
-		ni_writel(s->state, M_Offset_CDO_FIFO_Data);
-		ni_writel(CDO_SW_Update_Bit, M_Offset_CDIO_Command);
-		ni_writel(s->io_bits, M_Offset_CDO_Mask_Enable);
-	} else {
-		comedi_error(dev,
-			     "attempted to run digital output command with no lines configured as outputs");
-		return -EIO;
-	}
-	retval = ni_request_cdo_mite_channel(dev);
-	if (retval < 0)
-		return retval;
-
-	s->async->inttrig = ni_cdo_inttrig;
-
-	return 0;
-}
-
 static int ni_cdo_inttrig(struct comedi_device *dev,
 			  struct comedi_subdevice *s,
 			  unsigned int trig_num)
@@ -3535,6 +3494,45 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 	return retval;
 }
 
+static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+{
+	struct ni_private *devpriv __maybe_unused = dev->private;
+	const struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;
+	int retval;
+
+	ni_writel(CDO_Reset_Bit, M_Offset_CDIO_Command);
+	switch (cmd->scan_begin_src) {
+	case TRIG_EXT:
+		cdo_mode_bits |=
+		    CR_CHAN(cmd->scan_begin_arg) &
+		    CDO_Sample_Source_Select_Mask;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	if (cmd->scan_begin_arg & CR_INVERT)
+		cdo_mode_bits |= CDO_Polarity_Bit;
+	ni_writel(cdo_mode_bits, M_Offset_CDO_Mode);
+	if (s->io_bits) {
+		ni_writel(s->state, M_Offset_CDO_FIFO_Data);
+		ni_writel(CDO_SW_Update_Bit, M_Offset_CDIO_Command);
+		ni_writel(s->io_bits, M_Offset_CDO_Mask_Enable);
+	} else {
+		comedi_error(dev,
+			     "attempted to run digital output command with no lines configured as outputs");
+		return -EIO;
+	}
+	retval = ni_request_cdo_mite_channel(dev);
+	if (retval < 0)
+		return retval;
+
+	s->async->inttrig = ni_cdo_inttrig;
+
+	return 0;
+}
+
 static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct ni_private *devpriv __maybe_unused = dev->private;

commit 9a0c81a2be4bdc5e1557000712a469ebacc2eb96
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:33 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 10
    
    These forward declarations are not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a1ed6c19fbad..d37c063d8f8a 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -194,24 +194,12 @@ static const struct comedi_lrange *const ni_range_lkup[] = {
 	[ai_gain_6143] = &range_bipolar5
 };
 
-static int ni_dio_insn_config(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data);
-static int ni_dio_insn_bits(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-static int ni_cdio_cmdtest(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_cmd *cmd);
-static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ni_cdio_cancel(struct comedi_device *dev,
 			  struct comedi_subdevice *s);
 static void handle_cdio_interrupt(struct comedi_device *dev);
 static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 			  unsigned int trignum);
 
-static int ni_serial_insn_config(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn, unsigned int *data);
 static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   unsigned char data_out,
@@ -238,9 +226,6 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 				     unsigned int n_chan, unsigned int *list);
 static void shutdown_ai_command(struct comedi_device *dev);
 
-static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-			 unsigned int trignum);
-
 static void handle_gpct_interrupt(struct comedi_device *dev,
 				  unsigned short counter_index);
 

commit 12db14163e6beb20398499d523685c05d3fb07f0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:32 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 9
    
    Move ni_rtsi_insn_bits() to remove the need for the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ffb5a846aeb5..a1ed6c19fbad 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -222,9 +222,6 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 				   unsigned char *data_in);
 
 static void ni_rtsi_init(struct comedi_device *dev);
-static int ni_rtsi_insn_bits(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data);
 static int ni_rtsi_insn_config(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data);
@@ -4807,6 +4804,16 @@ static int init_cs5529(struct comedi_device *dev)
 	return 0;
 }
 
+static int ni_rtsi_insn_bits(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn,
+			     unsigned int *data)
+{
+	data[1] = 0;
+
+	return insn->n;
+}
+
 #ifdef PCIDMA
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
@@ -5302,15 +5309,6 @@ static void ni_rtsi_init(struct comedi_device *dev)
 */
 }
 
-static int ni_rtsi_insn_bits(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
-{
-	data[1] = 0;
-
-	return insn->n;
-}
-
 /* Find best multiplier/divider to try and get the PLL running at 80 MHz
  * given an arbitrary frequency input clock */
 static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,

commit 24e7c352ba019653c9fbe006dc3fe4c0162fa3a7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:31 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 8
    
    Move the cs5529 calibration subdevice functions and helpers to remove
    the need for the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 55eadf43728b..ffb5a846aeb5 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -247,15 +247,6 @@ static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 static void handle_gpct_interrupt(struct comedi_device *dev,
 				  unsigned short counter_index);
 
-static int init_cs5529(struct comedi_device *dev);
-static int cs5529_do_conversion(struct comedi_device *dev,
-				unsigned short *data);
-static int cs5529_ai_insn_read(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data);
-static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
-				unsigned int reg_select_bits);
-
 static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 			       unsigned period_ns);
 static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status);
@@ -4680,6 +4671,142 @@ static int ni_pfi_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
+static int cs5529_wait_for_idle(struct comedi_device *dev)
+{
+	unsigned short status;
+	const int timeout = HZ;
+	int i;
+
+	for (i = 0; i < timeout; i++) {
+		status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
+		if ((status & CSS_ADC_BUSY) == 0)
+			break;
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (schedule_timeout(1))
+			return -EIO;
+	}
+/* printk("looped %i times waiting for idle\n", i); */
+	if (i == timeout) {
+		printk("%s: %s: timeout\n", __FILE__, __func__);
+		return -ETIME;
+	}
+	return 0;
+}
+
+static void cs5529_command(struct comedi_device *dev, unsigned short value)
+{
+	static const int timeout = 100;
+	int i;
+
+	ni_ao_win_outw(dev, value, CAL_ADC_Command_67xx);
+	/* give time for command to start being serially clocked into cs5529.
+	 * this insures that the CSS_ADC_BUSY bit will get properly
+	 * set before we exit this function.
+	 */
+	for (i = 0; i < timeout; i++) {
+		if ((ni_ao_win_inw(dev, CAL_ADC_Status_67xx) & CSS_ADC_BUSY))
+			break;
+		udelay(1);
+	}
+/* printk("looped %i times writing command to cs5529\n", i); */
+	if (i == timeout)
+		comedi_error(dev, "possible problem - never saw adc go busy?");
+}
+
+static int cs5529_do_conversion(struct comedi_device *dev,
+				unsigned short *data)
+{
+	int retval;
+	unsigned short status;
+
+	cs5529_command(dev, CSCMD_COMMAND | CSCMD_SINGLE_CONVERSION);
+	retval = cs5529_wait_for_idle(dev);
+	if (retval) {
+		comedi_error(dev,
+			     "timeout or signal in cs5529_do_conversion()");
+		return -ETIME;
+	}
+	status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
+	if (status & CSS_OSC_DETECT) {
+		printk
+		    ("ni_mio_common: cs5529 conversion error, status CSS_OSC_DETECT\n");
+		return -EIO;
+	}
+	if (status & CSS_OVERRANGE) {
+		printk
+		    ("ni_mio_common: cs5529 conversion error, overrange (ignoring)\n");
+	}
+	if (data) {
+		*data = ni_ao_win_inw(dev, CAL_ADC_Data_67xx);
+		/* cs5529 returns 16 bit signed data in bipolar mode */
+		*data ^= (1 << 15);
+	}
+	return 0;
+}
+
+static int cs5529_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
+{
+	int n, retval;
+	unsigned short sample;
+	unsigned int channel_select;
+	const unsigned int INTERNAL_REF = 0x1000;
+
+	/* Set calibration adc source.  Docs lie, reference select bits 8 to 11
+	 * do nothing. bit 12 seems to chooses internal reference voltage, bit
+	 * 13 causes the adc input to go overrange (maybe reads external reference?) */
+	if (insn->chanspec & CR_ALT_SOURCE)
+		channel_select = INTERNAL_REF;
+	else
+		channel_select = CR_CHAN(insn->chanspec);
+	ni_ao_win_outw(dev, channel_select, AO_Calibration_Channel_Select_67xx);
+
+	for (n = 0; n < insn->n; n++) {
+		retval = cs5529_do_conversion(dev, &sample);
+		if (retval < 0)
+			return retval;
+		data[n] = sample;
+	}
+	return insn->n;
+}
+
+static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
+				unsigned int reg_select_bits)
+{
+	ni_ao_win_outw(dev, ((value >> 16) & 0xff),
+		       CAL_ADC_Config_Data_High_Word_67xx);
+	ni_ao_win_outw(dev, (value & 0xffff),
+		       CAL_ADC_Config_Data_Low_Word_67xx);
+	reg_select_bits &= CSCMD_REGISTER_SELECT_MASK;
+	cs5529_command(dev, CSCMD_COMMAND | reg_select_bits);
+	if (cs5529_wait_for_idle(dev))
+		comedi_error(dev, "time or signal in cs5529_config_write()");
+}
+
+static int init_cs5529(struct comedi_device *dev)
+{
+	unsigned int config_bits =
+	    CSCFG_PORT_MODE | CSCFG_WORD_RATE_2180_CYCLES;
+
+#if 1
+	/* do self-calibration */
+	cs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET_GAIN,
+			    CSCMD_CONFIG_REGISTER);
+	/* need to force a conversion for calibration to run */
+	cs5529_do_conversion(dev, NULL);
+#else
+	/* force gain calibration to 1 */
+	cs5529_config_write(dev, 0x400000, CSCMD_GAIN_REGISTER);
+	cs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET,
+			    CSCMD_CONFIG_REGISTER);
+	if (cs5529_wait_for_idle(dev))
+		comedi_error(dev, "timeout or signal in init_cs5529()\n");
+#endif
+	return 0;
+}
+
 #ifdef PCIDMA
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
@@ -5542,138 +5669,3 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 	}
 	return 1;
 }
-
-static int cs5529_wait_for_idle(struct comedi_device *dev)
-{
-	unsigned short status;
-	const int timeout = HZ;
-	int i;
-
-	for (i = 0; i < timeout; i++) {
-		status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
-		if ((status & CSS_ADC_BUSY) == 0)
-			break;
-		set_current_state(TASK_INTERRUPTIBLE);
-		if (schedule_timeout(1))
-			return -EIO;
-	}
-/* printk("looped %i times waiting for idle\n", i); */
-	if (i == timeout) {
-		printk("%s: %s: timeout\n", __FILE__, __func__);
-		return -ETIME;
-	}
-	return 0;
-}
-
-static void cs5529_command(struct comedi_device *dev, unsigned short value)
-{
-	static const int timeout = 100;
-	int i;
-
-	ni_ao_win_outw(dev, value, CAL_ADC_Command_67xx);
-	/* give time for command to start being serially clocked into cs5529.
-	 * this insures that the CSS_ADC_BUSY bit will get properly
-	 * set before we exit this function.
-	 */
-	for (i = 0; i < timeout; i++) {
-		if ((ni_ao_win_inw(dev, CAL_ADC_Status_67xx) & CSS_ADC_BUSY))
-			break;
-		udelay(1);
-	}
-/* printk("looped %i times writing command to cs5529\n", i); */
-	if (i == timeout)
-		comedi_error(dev, "possible problem - never saw adc go busy?");
-}
-
-/* write to cs5529 register */
-static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
-				unsigned int reg_select_bits)
-{
-	ni_ao_win_outw(dev, ((value >> 16) & 0xff),
-		       CAL_ADC_Config_Data_High_Word_67xx);
-	ni_ao_win_outw(dev, (value & 0xffff),
-		       CAL_ADC_Config_Data_Low_Word_67xx);
-	reg_select_bits &= CSCMD_REGISTER_SELECT_MASK;
-	cs5529_command(dev, CSCMD_COMMAND | reg_select_bits);
-	if (cs5529_wait_for_idle(dev))
-		comedi_error(dev, "time or signal in cs5529_config_write()");
-}
-
-static int cs5529_do_conversion(struct comedi_device *dev, unsigned short *data)
-{
-	int retval;
-	unsigned short status;
-
-	cs5529_command(dev, CSCMD_COMMAND | CSCMD_SINGLE_CONVERSION);
-	retval = cs5529_wait_for_idle(dev);
-	if (retval) {
-		comedi_error(dev,
-			     "timeout or signal in cs5529_do_conversion()");
-		return -ETIME;
-	}
-	status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
-	if (status & CSS_OSC_DETECT) {
-		printk
-		    ("ni_mio_common: cs5529 conversion error, status CSS_OSC_DETECT\n");
-		return -EIO;
-	}
-	if (status & CSS_OVERRANGE) {
-		printk
-		    ("ni_mio_common: cs5529 conversion error, overrange (ignoring)\n");
-	}
-	if (data) {
-		*data = ni_ao_win_inw(dev, CAL_ADC_Data_67xx);
-		/* cs5529 returns 16 bit signed data in bipolar mode */
-		*data ^= (1 << 15);
-	}
-	return 0;
-}
-
-static int cs5529_ai_insn_read(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
-{
-	int n, retval;
-	unsigned short sample;
-	unsigned int channel_select;
-	const unsigned int INTERNAL_REF = 0x1000;
-
-	/* Set calibration adc source.  Docs lie, reference select bits 8 to 11
-	 * do nothing. bit 12 seems to chooses internal reference voltage, bit
-	 * 13 causes the adc input to go overrange (maybe reads external reference?) */
-	if (insn->chanspec & CR_ALT_SOURCE)
-		channel_select = INTERNAL_REF;
-	else
-		channel_select = CR_CHAN(insn->chanspec);
-	ni_ao_win_outw(dev, channel_select, AO_Calibration_Channel_Select_67xx);
-
-	for (n = 0; n < insn->n; n++) {
-		retval = cs5529_do_conversion(dev, &sample);
-		if (retval < 0)
-			return retval;
-		data[n] = sample;
-	}
-	return insn->n;
-}
-
-static int init_cs5529(struct comedi_device *dev)
-{
-	unsigned int config_bits =
-	    CSCFG_PORT_MODE | CSCFG_WORD_RATE_2180_CYCLES;
-
-#if 1
-	/* do self-calibration */
-	cs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET_GAIN,
-			    CSCMD_CONFIG_REGISTER);
-	/* need to force a conversion for calibration to run */
-	cs5529_do_conversion(dev, NULL);
-#else
-	/* force gain calibration to 1 */
-	cs5529_config_write(dev, 0x400000, CSCMD_GAIN_REGISTER);
-	cs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET,
-			    CSCMD_CONFIG_REGISTER);
-	if (cs5529_wait_for_idle(dev))
-		comedi_error(dev, "timeout or signal in init_cs5529()\n");
-#endif
-	return 0;
-}

commit 4187a79a8416cbbb37354d6e64d013db0f131646
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:30 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 7
    
    Move the programmable function inputs subdevice functions and helpers
    to remove the need for the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2b997ef0f97c..55eadf43728b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -221,15 +221,6 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 				   unsigned char data_out,
 				   unsigned char *data_in);
 
-static int ni_pfi_insn_bits(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-static int ni_pfi_insn_config(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data);
-static unsigned ni_old_get_pfi_routing(struct comedi_device *dev,
-				       unsigned chan);
-
 static void ni_rtsi_init(struct comedi_device *dev);
 static int ni_rtsi_insn_bits(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
@@ -4510,6 +4501,185 @@ static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
 	return 1;
 }
 
+static unsigned ni_old_get_pfi_routing(struct comedi_device *dev,
+				       unsigned chan)
+{
+	/*  pre-m-series boards have fixed signals on pfi pins */
+	switch (chan) {
+	case 0:
+		return NI_PFI_OUTPUT_AI_START1;
+		break;
+	case 1:
+		return NI_PFI_OUTPUT_AI_START2;
+		break;
+	case 2:
+		return NI_PFI_OUTPUT_AI_CONVERT;
+		break;
+	case 3:
+		return NI_PFI_OUTPUT_G_SRC1;
+		break;
+	case 4:
+		return NI_PFI_OUTPUT_G_GATE1;
+		break;
+	case 5:
+		return NI_PFI_OUTPUT_AO_UPDATE_N;
+		break;
+	case 6:
+		return NI_PFI_OUTPUT_AO_START1;
+		break;
+	case 7:
+		return NI_PFI_OUTPUT_AI_START_PULSE;
+		break;
+	case 8:
+		return NI_PFI_OUTPUT_G_SRC0;
+		break;
+	case 9:
+		return NI_PFI_OUTPUT_G_GATE0;
+		break;
+	default:
+		printk("%s: bug, unhandled case in switch.\n", __func__);
+		break;
+	}
+	return 0;
+}
+
+static int ni_old_set_pfi_routing(struct comedi_device *dev,
+				  unsigned chan, unsigned source)
+{
+	/*  pre-m-series boards have fixed signals on pfi pins */
+	if (source != ni_old_get_pfi_routing(dev, chan))
+		return -EINVAL;
+	return 2;
+}
+
+static unsigned ni_m_series_get_pfi_routing(struct comedi_device *dev,
+					    unsigned chan)
+{
+	struct ni_private *devpriv = dev->private;
+	const unsigned array_offset = chan / 3;
+
+	return MSeries_PFI_Output_Select_Source(chan,
+				devpriv->pfi_output_select_reg[array_offset]);
+}
+
+static int ni_m_series_set_pfi_routing(struct comedi_device *dev,
+				       unsigned chan, unsigned source)
+{
+	struct ni_private *devpriv = dev->private;
+	unsigned pfi_reg_index;
+	unsigned array_offset;
+
+	if ((source & 0x1f) != source)
+		return -EINVAL;
+	pfi_reg_index = 1 + chan / 3;
+	array_offset = pfi_reg_index - 1;
+	devpriv->pfi_output_select_reg[array_offset] &=
+	    ~MSeries_PFI_Output_Select_Mask(chan);
+	devpriv->pfi_output_select_reg[array_offset] |=
+	    MSeries_PFI_Output_Select_Bits(chan, source);
+	ni_writew(devpriv->pfi_output_select_reg[array_offset],
+		  M_Offset_PFI_Output_Select(pfi_reg_index));
+	return 2;
+}
+
+static unsigned ni_get_pfi_routing(struct comedi_device *dev, unsigned chan)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+
+	if (board->reg_type & ni_reg_m_series_mask)
+		return ni_m_series_get_pfi_routing(dev, chan);
+	else
+		return ni_old_get_pfi_routing(dev, chan);
+}
+
+static int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,
+			      unsigned source)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+
+	if (board->reg_type & ni_reg_m_series_mask)
+		return ni_m_series_set_pfi_routing(dev, chan, source);
+	else
+		return ni_old_set_pfi_routing(dev, chan, source);
+}
+
+static int ni_config_filter(struct comedi_device *dev,
+			    unsigned pfi_channel,
+			    enum ni_pfi_filter_select filter)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv __maybe_unused = dev->private;
+	unsigned bits;
+
+	if ((board->reg_type & ni_reg_m_series_mask) == 0)
+		return -ENOTSUPP;
+	bits = ni_readl(M_Offset_PFI_Filter);
+	bits &= ~MSeries_PFI_Filter_Select_Mask(pfi_channel);
+	bits |= MSeries_PFI_Filter_Select_Bits(pfi_channel, filter);
+	ni_writel(bits, M_Offset_PFI_Filter);
+	return 0;
+}
+
+static int ni_pfi_insn_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned int *data)
+{
+	struct ni_private *devpriv = dev->private;
+	unsigned int chan;
+
+	if (insn->n < 1)
+		return -EINVAL;
+
+	chan = CR_CHAN(insn->chanspec);
+
+	switch (data[0]) {
+	case COMEDI_OUTPUT:
+		ni_set_bits(dev, IO_Bidirection_Pin_Register, 1 << chan, 1);
+		break;
+	case COMEDI_INPUT:
+		ni_set_bits(dev, IO_Bidirection_Pin_Register, 1 << chan, 0);
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] =
+		    (devpriv->io_bidirection_pin_reg & (1 << chan)) ?
+		    COMEDI_OUTPUT : COMEDI_INPUT;
+		return 0;
+		break;
+	case INSN_CONFIG_SET_ROUTING:
+		return ni_set_pfi_routing(dev, chan, data[1]);
+		break;
+	case INSN_CONFIG_GET_ROUTING:
+		data[1] = ni_get_pfi_routing(dev, chan);
+		break;
+	case INSN_CONFIG_FILTER:
+		return ni_config_filter(dev, chan, data[1]);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int ni_pfi_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn,
+			    unsigned int *data)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv __maybe_unused = dev->private;
+
+	if (!(board->reg_type & ni_reg_m_series_mask))
+		return -ENOTSUPP;
+
+	if (comedi_dio_update_state(s, data))
+		ni_writew(s->state, M_Offset_PFI_DO);
+
+	data[1] = ni_readw(M_Offset_PFI_DI);
+
+	return insn->n;
+}
+
 #ifdef PCIDMA
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
@@ -4960,190 +5130,6 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 
 #endif
 
-/*
- *
- *  Programmable Function Inputs
- *
- */
-
-static int ni_m_series_set_pfi_routing(struct comedi_device *dev, unsigned chan,
-				       unsigned source)
-{
-	struct ni_private *devpriv = dev->private;
-	unsigned pfi_reg_index;
-	unsigned array_offset;
-
-	if ((source & 0x1f) != source)
-		return -EINVAL;
-	pfi_reg_index = 1 + chan / 3;
-	array_offset = pfi_reg_index - 1;
-	devpriv->pfi_output_select_reg[array_offset] &=
-	    ~MSeries_PFI_Output_Select_Mask(chan);
-	devpriv->pfi_output_select_reg[array_offset] |=
-	    MSeries_PFI_Output_Select_Bits(chan, source);
-	ni_writew(devpriv->pfi_output_select_reg[array_offset],
-		  M_Offset_PFI_Output_Select(pfi_reg_index));
-	return 2;
-}
-
-static int ni_old_set_pfi_routing(struct comedi_device *dev, unsigned chan,
-				  unsigned source)
-{
-	/*  pre-m-series boards have fixed signals on pfi pins */
-	if (source != ni_old_get_pfi_routing(dev, chan))
-		return -EINVAL;
-	return 2;
-}
-
-static int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,
-			      unsigned source)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-
-	if (board->reg_type & ni_reg_m_series_mask)
-		return ni_m_series_set_pfi_routing(dev, chan, source);
-	else
-		return ni_old_set_pfi_routing(dev, chan, source);
-}
-
-static unsigned ni_m_series_get_pfi_routing(struct comedi_device *dev,
-					    unsigned chan)
-{
-	struct ni_private *devpriv = dev->private;
-	const unsigned array_offset = chan / 3;
-
-	return MSeries_PFI_Output_Select_Source(chan,
-						devpriv->
-						pfi_output_select_reg
-						[array_offset]);
-}
-
-static unsigned ni_old_get_pfi_routing(struct comedi_device *dev, unsigned chan)
-{
-	/*  pre-m-series boards have fixed signals on pfi pins */
-	switch (chan) {
-	case 0:
-		return NI_PFI_OUTPUT_AI_START1;
-		break;
-	case 1:
-		return NI_PFI_OUTPUT_AI_START2;
-		break;
-	case 2:
-		return NI_PFI_OUTPUT_AI_CONVERT;
-		break;
-	case 3:
-		return NI_PFI_OUTPUT_G_SRC1;
-		break;
-	case 4:
-		return NI_PFI_OUTPUT_G_GATE1;
-		break;
-	case 5:
-		return NI_PFI_OUTPUT_AO_UPDATE_N;
-		break;
-	case 6:
-		return NI_PFI_OUTPUT_AO_START1;
-		break;
-	case 7:
-		return NI_PFI_OUTPUT_AI_START_PULSE;
-		break;
-	case 8:
-		return NI_PFI_OUTPUT_G_SRC0;
-		break;
-	case 9:
-		return NI_PFI_OUTPUT_G_GATE0;
-		break;
-	default:
-		printk("%s: bug, unhandled case in switch.\n", __func__);
-		break;
-	}
-	return 0;
-}
-
-static unsigned ni_get_pfi_routing(struct comedi_device *dev, unsigned chan)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-
-	if (board->reg_type & ni_reg_m_series_mask)
-		return ni_m_series_get_pfi_routing(dev, chan);
-	else
-		return ni_old_get_pfi_routing(dev, chan);
-}
-
-static int ni_config_filter(struct comedi_device *dev, unsigned pfi_channel,
-			    enum ni_pfi_filter_select filter)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv __maybe_unused = dev->private;
-	unsigned bits;
-
-	if ((board->reg_type & ni_reg_m_series_mask) == 0)
-		return -ENOTSUPP;
-	bits = ni_readl(M_Offset_PFI_Filter);
-	bits &= ~MSeries_PFI_Filter_Select_Mask(pfi_channel);
-	bits |= MSeries_PFI_Filter_Select_Bits(pfi_channel, filter);
-	ni_writel(bits, M_Offset_PFI_Filter);
-	return 0;
-}
-
-static int ni_pfi_insn_bits(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn,
-			    unsigned int *data)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv __maybe_unused = dev->private;
-
-	if (!(board->reg_type & ni_reg_m_series_mask))
-		return -ENOTSUPP;
-
-	if (comedi_dio_update_state(s, data))
-		ni_writew(s->state, M_Offset_PFI_DO);
-
-	data[1] = ni_readw(M_Offset_PFI_DI);
-
-	return insn->n;
-}
-
-static int ni_pfi_insn_config(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
-{
-	struct ni_private *devpriv = dev->private;
-	unsigned int chan;
-
-	if (insn->n < 1)
-		return -EINVAL;
-
-	chan = CR_CHAN(insn->chanspec);
-
-	switch (data[0]) {
-	case COMEDI_OUTPUT:
-		ni_set_bits(dev, IO_Bidirection_Pin_Register, 1 << chan, 1);
-		break;
-	case COMEDI_INPUT:
-		ni_set_bits(dev, IO_Bidirection_Pin_Register, 1 << chan, 0);
-		break;
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] =
-		    (devpriv->io_bidirection_pin_reg & (1 << chan)) ?
-		    COMEDI_OUTPUT : COMEDI_INPUT;
-		return 0;
-		break;
-	case INSN_CONFIG_SET_ROUTING:
-		return ni_set_pfi_routing(dev, chan, data[1]);
-		break;
-	case INSN_CONFIG_GET_ROUTING:
-		data[1] = ni_get_pfi_routing(dev, chan);
-		break;
-	case INSN_CONFIG_FILTER:
-		return ni_config_filter(dev, chan, data[1]);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
 /*
  *
  *  NI RTSI Bus Functions

commit c8508a1d7bfcef2fa557770ef94f481b5d70c9a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:29 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 6
    
    Move the ni_gpct_cmd() and ni_gpct_cancel() functions to remove the
    need for the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0bce283eb72b..2b997ef0f97c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -253,10 +253,6 @@ static void shutdown_ai_command(struct comedi_device *dev);
 static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 			 unsigned int trignum);
 
-#ifdef PCIDMA
-static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-#endif
 static void handle_gpct_interrupt(struct comedi_device *dev,
 				  unsigned short counter_index);
 
@@ -4514,6 +4510,37 @@ static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
 	return 1;
 }
 
+#ifdef PCIDMA
+static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+{
+	struct ni_gpct *counter = s->private;
+	int retval;
+
+	retval = ni_request_gpct_mite_channel(dev, counter->counter_index,
+					      COMEDI_INPUT);
+	if (retval) {
+		comedi_error(dev,
+			     "no dma channel available for use by counter");
+		return retval;
+	}
+	ni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);
+	ni_e_series_enable_second_irq(dev, counter->counter_index, 1);
+
+	return ni_tio_cmd(dev, s);
+}
+
+static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+{
+	struct ni_gpct *counter = s->private;
+	int retval;
+
+	retval = ni_tio_cancel(counter);
+	ni_e_series_enable_second_irq(dev, counter->counter_index, 0);
+	ni_release_gpct_mite_channel(dev, counter->counter_index);
+	return retval;
+}
+#endif
+
 static int ni_E_init(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
@@ -4933,39 +4960,6 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 
 #endif
 
-#ifdef PCIDMA
-static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	struct ni_gpct *counter = s->private;
-	int retval;
-
-	retval = ni_request_gpct_mite_channel(dev, counter->counter_index,
-					      COMEDI_INPUT);
-	if (retval) {
-		comedi_error(dev,
-			     "no dma channel available for use by counter");
-		return retval;
-	}
-	ni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);
-	ni_e_series_enable_second_irq(dev, counter->counter_index, 1);
-
-	return ni_tio_cmd(dev, s);
-}
-#endif
-
-#ifdef PCIDMA
-static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	struct ni_gpct *counter = s->private;
-	int retval;
-
-	retval = ni_tio_cancel(counter);
-	ni_e_series_enable_second_irq(dev, counter->counter_index, 0);
-	ni_release_gpct_mite_channel(dev, counter->counter_index);
-	return retval;
-}
-#endif
-
 /*
  *
  *  Programmable Function Inputs

commit 62c2bce0229c15c14dab42c84897fb8299f7e368
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:28 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 5
    
    Move the calibration subdevice functions and helpers to remove the need
    for the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 85eaeb9df42f..0bce283eb72b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -221,13 +221,6 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 				   unsigned char data_out,
 				   unsigned char *data_in);
 
-static int ni_calib_insn_read(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data);
-static int ni_calib_insn_write(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data);
-
 static int ni_pfi_insn_bits(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data);
@@ -245,8 +238,6 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data);
 
-static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s);
-
 #ifndef PCIDMA
 static void ni_handle_fifo_half_full(struct comedi_device *dev);
 static int ni_ao_fifo_half_empty(struct comedi_device *dev,
@@ -4299,6 +4290,183 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 	return 0;
 }
 
+static int pack_mb88341(int addr, int val, int *bitstring)
+{
+	/*
+	   Fujitsu MB 88341
+	   Note that address bits are reversed.  Thanks to
+	   Ingo Keen for noticing this.
+
+	   Note also that the 88341 expects address values from
+	   1-12, whereas we use channel numbers 0-11.  The NI
+	   docs use 1-12, also, so be careful here.
+	 */
+	addr++;
+	*bitstring = ((addr & 0x1) << 11) |
+	    ((addr & 0x2) << 9) |
+	    ((addr & 0x4) << 7) | ((addr & 0x8) << 5) | (val & 0xff);
+	return 12;
+}
+
+static int pack_dac8800(int addr, int val, int *bitstring)
+{
+	*bitstring = ((addr & 0x7) << 8) | (val & 0xff);
+	return 11;
+}
+
+static int pack_dac8043(int addr, int val, int *bitstring)
+{
+	*bitstring = val & 0xfff;
+	return 12;
+}
+
+static int pack_ad8522(int addr, int val, int *bitstring)
+{
+	*bitstring = (val & 0xfff) | (addr ? 0xc000 : 0xa000);
+	return 16;
+}
+
+static int pack_ad8804(int addr, int val, int *bitstring)
+{
+	*bitstring = ((addr & 0xf) << 8) | (val & 0xff);
+	return 12;
+}
+
+static int pack_ad8842(int addr, int val, int *bitstring)
+{
+	*bitstring = ((addr + 1) << 8) | (val & 0xff);
+	return 12;
+}
+
+struct caldac_struct {
+	int n_chans;
+	int n_bits;
+	int (*packbits)(int, int, int *);
+};
+
+static struct caldac_struct caldacs[] = {
+	[mb88341] = {12, 8, pack_mb88341},
+	[dac8800] = {8, 8, pack_dac8800},
+	[dac8043] = {1, 12, pack_dac8043},
+	[ad8522] = {2, 12, pack_ad8522},
+	[ad8804] = {12, 8, pack_ad8804},
+	[ad8842] = {8, 8, pack_ad8842},
+	[ad8804_debug] = {16, 8, pack_ad8804},
+};
+
+static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
+	unsigned int loadbit = 0, bits = 0, bit, bitstring = 0;
+	int i;
+	int type;
+
+	/* printk("ni_write_caldac: chan=%d val=%d\n",addr,val); */
+	if (devpriv->caldacs[addr] == val)
+		return;
+	devpriv->caldacs[addr] = val;
+
+	for (i = 0; i < 3; i++) {
+		type = board->caldac[i];
+		if (type == caldac_none)
+			break;
+		if (addr < caldacs[type].n_chans) {
+			bits = caldacs[type].packbits(addr, val, &bitstring);
+			loadbit = SerDacLd(i);
+			/* printk("caldac: using i=%d addr=%d %x\n",i,addr,bitstring); */
+			break;
+		}
+		addr -= caldacs[type].n_chans;
+	}
+
+	for (bit = 1 << (bits - 1); bit; bit >>= 1) {
+		ni_writeb(((bit & bitstring) ? 0x02 : 0), Serial_Command);
+		udelay(1);
+		ni_writeb(1 | ((bit & bitstring) ? 0x02 : 0), Serial_Command);
+		udelay(1);
+	}
+	ni_writeb(loadbit, Serial_Command);
+	udelay(1);
+	ni_writeb(0, Serial_Command);
+}
+
+static int ni_calib_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
+{
+	ni_write_caldac(dev, CR_CHAN(insn->chanspec), data[0]);
+
+	return 1;
+}
+
+static int ni_calib_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned int *data)
+{
+	struct ni_private *devpriv = dev->private;
+
+	data[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
+static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
+{
+	const struct ni_board_struct *board = comedi_board(dev);
+	struct ni_private *devpriv = dev->private;
+	int i, j;
+	int n_dacs;
+	int n_chans = 0;
+	int n_bits;
+	int diffbits = 0;
+	int type;
+	int chan;
+
+	type = board->caldac[0];
+	if (type == caldac_none)
+		return;
+	n_bits = caldacs[type].n_bits;
+	for (i = 0; i < 3; i++) {
+		type = board->caldac[i];
+		if (type == caldac_none)
+			break;
+		if (caldacs[type].n_bits != n_bits)
+			diffbits = 1;
+		n_chans += caldacs[type].n_chans;
+	}
+	n_dacs = i;
+	s->n_chan = n_chans;
+
+	if (diffbits) {
+		unsigned int *maxdata_list;
+
+		if (n_chans > MAX_N_CALDACS)
+			printk("BUG! MAX_N_CALDACS too small\n");
+		s->maxdata_list = maxdata_list = devpriv->caldac_maxdata_list;
+		chan = 0;
+		for (i = 0; i < n_dacs; i++) {
+			type = board->caldac[i];
+			for (j = 0; j < caldacs[type].n_chans; j++) {
+				maxdata_list[chan] =
+				    (1 << caldacs[type].n_bits) - 1;
+				chan++;
+			}
+		}
+
+		for (chan = 0; chan < s->n_chan; chan++)
+			ni_write_caldac(dev, i, s->maxdata_list[i] / 2);
+	} else {
+		type = board->caldac[0];
+		s->maxdata = (1 << caldacs[type].n_bits) - 1;
+
+		for (chan = 0; chan < s->n_chan; chan++)
+			ni_write_caldac(dev, i, s->maxdata / 2);
+	}
+}
+
 static int ni_read_eeprom(struct comedi_device *dev, int addr)
 {
 	struct ni_private *devpriv __maybe_unused = dev->private;
@@ -4676,185 +4844,6 @@ static int ni_E_init(struct comedi_device *dev)
 	return 0;
 }
 
-static void ni_write_caldac(struct comedi_device *dev, int addr, int val);
-/*
-	calibration subdevice
-*/
-static int ni_calib_insn_write(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
-{
-	ni_write_caldac(dev, CR_CHAN(insn->chanspec), data[0]);
-
-	return 1;
-}
-
-static int ni_calib_insn_read(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
-{
-	struct ni_private *devpriv = dev->private;
-
-	data[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];
-
-	return 1;
-}
-
-static int pack_mb88341(int addr, int val, int *bitstring)
-{
-	/*
-	   Fujitsu MB 88341
-	   Note that address bits are reversed.  Thanks to
-	   Ingo Keen for noticing this.
-
-	   Note also that the 88341 expects address values from
-	   1-12, whereas we use channel numbers 0-11.  The NI
-	   docs use 1-12, also, so be careful here.
-	 */
-	addr++;
-	*bitstring = ((addr & 0x1) << 11) |
-	    ((addr & 0x2) << 9) |
-	    ((addr & 0x4) << 7) | ((addr & 0x8) << 5) | (val & 0xff);
-	return 12;
-}
-
-static int pack_dac8800(int addr, int val, int *bitstring)
-{
-	*bitstring = ((addr & 0x7) << 8) | (val & 0xff);
-	return 11;
-}
-
-static int pack_dac8043(int addr, int val, int *bitstring)
-{
-	*bitstring = val & 0xfff;
-	return 12;
-}
-
-static int pack_ad8522(int addr, int val, int *bitstring)
-{
-	*bitstring = (val & 0xfff) | (addr ? 0xc000 : 0xa000);
-	return 16;
-}
-
-static int pack_ad8804(int addr, int val, int *bitstring)
-{
-	*bitstring = ((addr & 0xf) << 8) | (val & 0xff);
-	return 12;
-}
-
-static int pack_ad8842(int addr, int val, int *bitstring)
-{
-	*bitstring = ((addr + 1) << 8) | (val & 0xff);
-	return 12;
-}
-
-struct caldac_struct {
-	int n_chans;
-	int n_bits;
-	int (*packbits)(int, int, int *);
-};
-
-static struct caldac_struct caldacs[] = {
-	[mb88341] = {12, 8, pack_mb88341},
-	[dac8800] = {8, 8, pack_dac8800},
-	[dac8043] = {1, 12, pack_dac8043},
-	[ad8522] = {2, 12, pack_ad8522},
-	[ad8804] = {12, 8, pack_ad8804},
-	[ad8842] = {8, 8, pack_ad8842},
-	[ad8804_debug] = {16, 8, pack_ad8804},
-};
-
-static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
-	int i, j;
-	int n_dacs;
-	int n_chans = 0;
-	int n_bits;
-	int diffbits = 0;
-	int type;
-	int chan;
-
-	type = board->caldac[0];
-	if (type == caldac_none)
-		return;
-	n_bits = caldacs[type].n_bits;
-	for (i = 0; i < 3; i++) {
-		type = board->caldac[i];
-		if (type == caldac_none)
-			break;
-		if (caldacs[type].n_bits != n_bits)
-			diffbits = 1;
-		n_chans += caldacs[type].n_chans;
-	}
-	n_dacs = i;
-	s->n_chan = n_chans;
-
-	if (diffbits) {
-		unsigned int *maxdata_list;
-
-		if (n_chans > MAX_N_CALDACS)
-			printk("BUG! MAX_N_CALDACS too small\n");
-		s->maxdata_list = maxdata_list = devpriv->caldac_maxdata_list;
-		chan = 0;
-		for (i = 0; i < n_dacs; i++) {
-			type = board->caldac[i];
-			for (j = 0; j < caldacs[type].n_chans; j++) {
-				maxdata_list[chan] =
-				    (1 << caldacs[type].n_bits) - 1;
-				chan++;
-			}
-		}
-
-		for (chan = 0; chan < s->n_chan; chan++)
-			ni_write_caldac(dev, i, s->maxdata_list[i] / 2);
-	} else {
-		type = board->caldac[0];
-		s->maxdata = (1 << caldacs[type].n_bits) - 1;
-
-		for (chan = 0; chan < s->n_chan; chan++)
-			ni_write_caldac(dev, i, s->maxdata / 2);
-	}
-}
-
-static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
-{
-	const struct ni_board_struct *board = comedi_board(dev);
-	struct ni_private *devpriv = dev->private;
-	unsigned int loadbit = 0, bits = 0, bit, bitstring = 0;
-	int i;
-	int type;
-
-	/* printk("ni_write_caldac: chan=%d val=%d\n",addr,val); */
-	if (devpriv->caldacs[addr] == val)
-		return;
-	devpriv->caldacs[addr] = val;
-
-	for (i = 0; i < 3; i++) {
-		type = board->caldac[i];
-		if (type == caldac_none)
-			break;
-		if (addr < caldacs[type].n_chans) {
-			bits = caldacs[type].packbits(addr, val, &bitstring);
-			loadbit = SerDacLd(i);
-			/* printk("caldac: using i=%d addr=%d %x\n",i,addr,bitstring); */
-			break;
-		}
-		addr -= caldacs[type].n_chans;
-	}
-
-	for (bit = 1 << (bits - 1); bit; bit >>= 1) {
-		ni_writeb(((bit & bitstring) ? 0x02 : 0), Serial_Command);
-		udelay(1);
-		ni_writeb(1 | ((bit & bitstring) ? 0x02 : 0), Serial_Command);
-		udelay(1);
-	}
-	ni_writeb(loadbit, Serial_Command);
-	udelay(1);
-	ni_writeb(0, Serial_Command);
-}
-
 #if 0
 /*
  *	Read the GPCTs current value.

commit 9e7cb171de7db458a20aefeff5f485212c0d040c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:27 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 4
    
    Move the caldac "packbits" callbacks to remove the need for the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b63c793afebe..85eaeb9df42f 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4700,12 +4700,53 @@ static int ni_calib_insn_read(struct comedi_device *dev,
 	return 1;
 }
 
-static int pack_mb88341(int addr, int val, int *bitstring);
-static int pack_dac8800(int addr, int val, int *bitstring);
-static int pack_dac8043(int addr, int val, int *bitstring);
-static int pack_ad8522(int addr, int val, int *bitstring);
-static int pack_ad8804(int addr, int val, int *bitstring);
-static int pack_ad8842(int addr, int val, int *bitstring);
+static int pack_mb88341(int addr, int val, int *bitstring)
+{
+	/*
+	   Fujitsu MB 88341
+	   Note that address bits are reversed.  Thanks to
+	   Ingo Keen for noticing this.
+
+	   Note also that the 88341 expects address values from
+	   1-12, whereas we use channel numbers 0-11.  The NI
+	   docs use 1-12, also, so be careful here.
+	 */
+	addr++;
+	*bitstring = ((addr & 0x1) << 11) |
+	    ((addr & 0x2) << 9) |
+	    ((addr & 0x4) << 7) | ((addr & 0x8) << 5) | (val & 0xff);
+	return 12;
+}
+
+static int pack_dac8800(int addr, int val, int *bitstring)
+{
+	*bitstring = ((addr & 0x7) << 8) | (val & 0xff);
+	return 11;
+}
+
+static int pack_dac8043(int addr, int val, int *bitstring)
+{
+	*bitstring = val & 0xfff;
+	return 12;
+}
+
+static int pack_ad8522(int addr, int val, int *bitstring)
+{
+	*bitstring = (val & 0xfff) | (addr ? 0xc000 : 0xa000);
+	return 16;
+}
+
+static int pack_ad8804(int addr, int val, int *bitstring)
+{
+	*bitstring = ((addr & 0xf) << 8) | (val & 0xff);
+	return 12;
+}
+
+static int pack_ad8842(int addr, int val, int *bitstring)
+{
+	*bitstring = ((addr + 1) << 8) | (val & 0xff);
+	return 12;
+}
 
 struct caldac_struct {
 	int n_chans;
@@ -4814,54 +4855,6 @@ static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 	ni_writeb(0, Serial_Command);
 }
 
-static int pack_mb88341(int addr, int val, int *bitstring)
-{
-	/*
-	   Fujitsu MB 88341
-	   Note that address bits are reversed.  Thanks to
-	   Ingo Keen for noticing this.
-
-	   Note also that the 88341 expects address values from
-	   1-12, whereas we use channel numbers 0-11.  The NI
-	   docs use 1-12, also, so be careful here.
-	 */
-	addr++;
-	*bitstring = ((addr & 0x1) << 11) |
-	    ((addr & 0x2) << 9) |
-	    ((addr & 0x4) << 7) | ((addr & 0x8) << 5) | (val & 0xff);
-	return 12;
-}
-
-static int pack_dac8800(int addr, int val, int *bitstring)
-{
-	*bitstring = ((addr & 0x7) << 8) | (val & 0xff);
-	return 11;
-}
-
-static int pack_dac8043(int addr, int val, int *bitstring)
-{
-	*bitstring = val & 0xfff;
-	return 12;
-}
-
-static int pack_ad8522(int addr, int val, int *bitstring)
-{
-	*bitstring = (val & 0xfff) | (addr ? 0xc000 : 0xa000);
-	return 16;
-}
-
-static int pack_ad8804(int addr, int val, int *bitstring)
-{
-	*bitstring = ((addr & 0xf) << 8) | (val & 0xff);
-	return 12;
-}
-
-static int pack_ad8842(int addr, int val, int *bitstring)
-{
-	*bitstring = ((addr + 1) << 8) | (val & 0xff);
-	return 12;
-}
-
 #if 0
 /*
  *	Read the GPCTs current value.

commit 1e49c5da48cdfcc7b46d219f0fd3e83843539b30
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:26 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 3
    
    Move the pwm config functions to remove the need for the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index aa1f1938b8fb..b63c793afebe 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -278,13 +278,6 @@ static int cs5529_ai_insn_read(struct comedi_device *dev,
 static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
 				unsigned int reg_select_bits);
 
-static int ni_m_series_pwm_config(struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data);
-static int ni_6143_pwm_config(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data);
-
 static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 			       unsigned period_ns);
 static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status);
@@ -4161,6 +4154,151 @@ static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 	}
 }
 
+static int ni_get_pwm_config(struct comedi_device *dev, unsigned int *data)
+{
+	struct ni_private *devpriv = dev->private;
+
+	data[1] = devpriv->pwm_up_count * devpriv->clock_ns;
+	data[2] = devpriv->pwm_down_count * devpriv->clock_ns;
+	return 3;
+}
+
+static int ni_m_series_pwm_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn,
+				  unsigned int *data)
+{
+	struct ni_private *devpriv = dev->private;
+	unsigned up_count, down_count;
+
+	switch (data[0]) {
+	case INSN_CONFIG_PWM_OUTPUT:
+		switch (data[1]) {
+		case TRIG_ROUND_NEAREST:
+			up_count =
+			    (data[2] +
+			     devpriv->clock_ns / 2) / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_DOWN:
+			up_count = data[2] / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_UP:
+			up_count =
+			    (data[2] + devpriv->clock_ns -
+			     1) / devpriv->clock_ns;
+			break;
+		default:
+			return -EINVAL;
+			break;
+		}
+		switch (data[3]) {
+		case TRIG_ROUND_NEAREST:
+			down_count =
+			    (data[4] +
+			     devpriv->clock_ns / 2) / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_DOWN:
+			down_count = data[4] / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_UP:
+			down_count =
+			    (data[4] + devpriv->clock_ns -
+			     1) / devpriv->clock_ns;
+			break;
+		default:
+			return -EINVAL;
+			break;
+		}
+		if (up_count * devpriv->clock_ns != data[2] ||
+		    down_count * devpriv->clock_ns != data[4]) {
+			data[2] = up_count * devpriv->clock_ns;
+			data[4] = down_count * devpriv->clock_ns;
+			return -EAGAIN;
+		}
+		ni_writel(MSeries_Cal_PWM_High_Time_Bits(up_count) |
+			  MSeries_Cal_PWM_Low_Time_Bits(down_count),
+			  M_Offset_Cal_PWM);
+		devpriv->pwm_up_count = up_count;
+		devpriv->pwm_down_count = down_count;
+		return 5;
+		break;
+	case INSN_CONFIG_GET_PWM_OUTPUT:
+		return ni_get_pwm_config(dev, data);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 0;
+}
+
+static int ni_6143_pwm_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned int *data)
+{
+	struct ni_private *devpriv = dev->private;
+	unsigned up_count, down_count;
+
+	switch (data[0]) {
+	case INSN_CONFIG_PWM_OUTPUT:
+		switch (data[1]) {
+		case TRIG_ROUND_NEAREST:
+			up_count =
+			    (data[2] +
+			     devpriv->clock_ns / 2) / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_DOWN:
+			up_count = data[2] / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_UP:
+			up_count =
+			    (data[2] + devpriv->clock_ns -
+			     1) / devpriv->clock_ns;
+			break;
+		default:
+			return -EINVAL;
+			break;
+		}
+		switch (data[3]) {
+		case TRIG_ROUND_NEAREST:
+			down_count =
+			    (data[4] +
+			     devpriv->clock_ns / 2) / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_DOWN:
+			down_count = data[4] / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_UP:
+			down_count =
+			    (data[4] + devpriv->clock_ns -
+			     1) / devpriv->clock_ns;
+			break;
+		default:
+			return -EINVAL;
+			break;
+		}
+		if (up_count * devpriv->clock_ns != data[2] ||
+		    down_count * devpriv->clock_ns != data[4]) {
+			data[2] = up_count * devpriv->clock_ns;
+			data[4] = down_count * devpriv->clock_ns;
+			return -EAGAIN;
+		}
+		ni_writel(up_count, Calibration_HighTime_6143);
+		devpriv->pwm_up_count = up_count;
+		ni_writel(down_count, Calibration_LowTime_6143);
+		devpriv->pwm_down_count = down_count;
+		return 5;
+		break;
+	case INSN_CONFIG_GET_PWM_OUTPUT:
+		return ni_get_pwm_config(dev, data);
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 0;
+}
+
 static int ni_read_eeprom(struct comedi_device *dev, int addr)
 {
 	struct ni_private *devpriv __maybe_unused = dev->private;
@@ -4538,149 +4676,6 @@ static int ni_E_init(struct comedi_device *dev)
 	return 0;
 }
 
-static int ni_get_pwm_config(struct comedi_device *dev, unsigned int *data)
-{
-	struct ni_private *devpriv = dev->private;
-
-	data[1] = devpriv->pwm_up_count * devpriv->clock_ns;
-	data[2] = devpriv->pwm_down_count * devpriv->clock_ns;
-	return 3;
-}
-
-static int ni_m_series_pwm_config(struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data)
-{
-	struct ni_private *devpriv = dev->private;
-	unsigned up_count, down_count;
-
-	switch (data[0]) {
-	case INSN_CONFIG_PWM_OUTPUT:
-		switch (data[1]) {
-		case TRIG_ROUND_NEAREST:
-			up_count =
-			    (data[2] +
-			     devpriv->clock_ns / 2) / devpriv->clock_ns;
-			break;
-		case TRIG_ROUND_DOWN:
-			up_count = data[2] / devpriv->clock_ns;
-			break;
-		case TRIG_ROUND_UP:
-			up_count =
-			    (data[2] + devpriv->clock_ns -
-			     1) / devpriv->clock_ns;
-			break;
-		default:
-			return -EINVAL;
-			break;
-		}
-		switch (data[3]) {
-		case TRIG_ROUND_NEAREST:
-			down_count =
-			    (data[4] +
-			     devpriv->clock_ns / 2) / devpriv->clock_ns;
-			break;
-		case TRIG_ROUND_DOWN:
-			down_count = data[4] / devpriv->clock_ns;
-			break;
-		case TRIG_ROUND_UP:
-			down_count =
-			    (data[4] + devpriv->clock_ns -
-			     1) / devpriv->clock_ns;
-			break;
-		default:
-			return -EINVAL;
-			break;
-		}
-		if (up_count * devpriv->clock_ns != data[2] ||
-		    down_count * devpriv->clock_ns != data[4]) {
-			data[2] = up_count * devpriv->clock_ns;
-			data[4] = down_count * devpriv->clock_ns;
-			return -EAGAIN;
-		}
-		ni_writel(MSeries_Cal_PWM_High_Time_Bits(up_count) |
-			  MSeries_Cal_PWM_Low_Time_Bits(down_count),
-			  M_Offset_Cal_PWM);
-		devpriv->pwm_up_count = up_count;
-		devpriv->pwm_down_count = down_count;
-		return 5;
-		break;
-	case INSN_CONFIG_GET_PWM_OUTPUT:
-		return ni_get_pwm_config(dev, data);
-		break;
-	default:
-		return -EINVAL;
-		break;
-	}
-	return 0;
-}
-
-static int ni_6143_pwm_config(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
-{
-	struct ni_private *devpriv = dev->private;
-	unsigned up_count, down_count;
-
-	switch (data[0]) {
-	case INSN_CONFIG_PWM_OUTPUT:
-		switch (data[1]) {
-		case TRIG_ROUND_NEAREST:
-			up_count =
-			    (data[2] +
-			     devpriv->clock_ns / 2) / devpriv->clock_ns;
-			break;
-		case TRIG_ROUND_DOWN:
-			up_count = data[2] / devpriv->clock_ns;
-			break;
-		case TRIG_ROUND_UP:
-			up_count =
-			    (data[2] + devpriv->clock_ns -
-			     1) / devpriv->clock_ns;
-			break;
-		default:
-			return -EINVAL;
-			break;
-		}
-		switch (data[3]) {
-		case TRIG_ROUND_NEAREST:
-			down_count =
-			    (data[4] +
-			     devpriv->clock_ns / 2) / devpriv->clock_ns;
-			break;
-		case TRIG_ROUND_DOWN:
-			down_count = data[4] / devpriv->clock_ns;
-			break;
-		case TRIG_ROUND_UP:
-			down_count =
-			    (data[4] + devpriv->clock_ns -
-			     1) / devpriv->clock_ns;
-			break;
-		default:
-			return -EINVAL;
-			break;
-		}
-		if (up_count * devpriv->clock_ns != data[2] ||
-		    down_count * devpriv->clock_ns != data[4]) {
-			data[2] = up_count * devpriv->clock_ns;
-			data[4] = down_count * devpriv->clock_ns;
-			return -EAGAIN;
-		}
-		ni_writel(up_count, Calibration_HighTime_6143);
-		devpriv->pwm_up_count = up_count;
-		ni_writel(down_count, Calibration_LowTime_6143);
-		devpriv->pwm_down_count = down_count;
-		return 5;
-		break;
-	case INSN_CONFIG_GET_PWM_OUTPUT:
-		return ni_get_pwm_config(dev, data);
-	default:
-		return -EINVAL;
-		break;
-	}
-	return 0;
-}
-
 static void ni_write_caldac(struct comedi_device *dev, int addr, int val);
 /*
 	calibration subdevice

commit 36adeee19ef91a3aebac626cedbb3b0c323c6f4f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:25 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 2
    
    Move the eeprom read functions to remove the need for the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ae941db6cb72..aa1f1938b8fb 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -228,14 +228,6 @@ static int ni_calib_insn_write(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data);
 
-static int ni_eeprom_insn_read(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data);
-static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
-					struct comedi_subdevice *s,
-					struct comedi_insn *insn,
-					unsigned int *data);
-
 static int ni_pfi_insn_bits(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data);
@@ -254,7 +246,6 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 			       struct comedi_insn *insn, unsigned int *data);
 
 static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s);
-static int ni_read_eeprom(struct comedi_device *dev, int addr);
 
 #ifndef PCIDMA
 static void ni_handle_fifo_half_full(struct comedi_device *dev);
@@ -4170,6 +4161,53 @@ static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 	}
 }
 
+static int ni_read_eeprom(struct comedi_device *dev, int addr)
+{
+	struct ni_private *devpriv __maybe_unused = dev->private;
+	int bit;
+	int bitstring;
+
+	bitstring = 0x0300 | ((addr & 0x100) << 3) | (addr & 0xff);
+	ni_writeb(0x04, Serial_Command);
+	for (bit = 0x8000; bit; bit >>= 1) {
+		ni_writeb(0x04 | ((bit & bitstring) ? 0x02 : 0),
+			  Serial_Command);
+		ni_writeb(0x05 | ((bit & bitstring) ? 0x02 : 0),
+			  Serial_Command);
+	}
+	bitstring = 0;
+	for (bit = 0x80; bit; bit >>= 1) {
+		ni_writeb(0x04, Serial_Command);
+		ni_writeb(0x05, Serial_Command);
+		bitstring |= ((ni_readb(XXX_Status) & PROMOUT) ? bit : 0);
+	}
+	ni_writeb(0x00, Serial_Command);
+
+	return bitstring;
+}
+
+static int ni_eeprom_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
+{
+	data[0] = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));
+
+	return 1;
+}
+
+static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
+					struct comedi_subdevice *s,
+					struct comedi_insn *insn,
+					unsigned int *data)
+{
+	struct ni_private *devpriv = dev->private;
+
+	data[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
 static int ni_E_init(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
@@ -4500,60 +4538,6 @@ static int ni_E_init(struct comedi_device *dev)
 	return 0;
 }
 
-/*
-	presents the EEPROM as a subdevice
-*/
-
-static int ni_eeprom_insn_read(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
-{
-	data[0] = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));
-
-	return 1;
-}
-
-/*
-	reads bytes out of eeprom
-*/
-
-static int ni_read_eeprom(struct comedi_device *dev, int addr)
-{
-	struct ni_private *devpriv __maybe_unused = dev->private;
-	int bit;
-	int bitstring;
-
-	bitstring = 0x0300 | ((addr & 0x100) << 3) | (addr & 0xff);
-	ni_writeb(0x04, Serial_Command);
-	for (bit = 0x8000; bit; bit >>= 1) {
-		ni_writeb(0x04 | ((bit & bitstring) ? 0x02 : 0),
-			  Serial_Command);
-		ni_writeb(0x05 | ((bit & bitstring) ? 0x02 : 0),
-			  Serial_Command);
-	}
-	bitstring = 0;
-	for (bit = 0x80; bit; bit >>= 1) {
-		ni_writeb(0x04, Serial_Command);
-		ni_writeb(0x05, Serial_Command);
-		bitstring |= ((ni_readb(XXX_Status) & PROMOUT) ? bit : 0);
-	}
-	ni_writeb(0x00, Serial_Command);
-
-	return bitstring;
-}
-
-static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
-					struct comedi_subdevice *s,
-					struct comedi_insn *insn,
-					unsigned int *data)
-{
-	struct ni_private *devpriv = dev->private;
-
-	data[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];
-
-	return 1;
-}
-
 static int ni_get_pwm_config(struct comedi_device *dev, unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;

commit f5985867ff22e8dd572b9d361cc714abe10bc46c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed May 28 16:26:24 2014 -0700

    staging: comedi: ni_mio_common: remove forward declaration 1
    
    Move ni_8255_callback() to remove the need for the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7ffdcc07ef92..ae941db6cb72 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -271,8 +271,6 @@ static void shutdown_ai_command(struct comedi_device *dev);
 static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 			 unsigned int trignum);
 
-static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
-
 #ifdef PCIDMA
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
@@ -4159,6 +4157,19 @@ static int ni_alloc_private(struct comedi_device *dev)
 	return 0;
 };
 
+static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
+{
+	struct comedi_device *dev = (struct comedi_device *)arg;
+	struct ni_private *devpriv __maybe_unused = dev->private;
+
+	if (dir) {
+		ni_writeb(data, Port_A + 2 * port);
+		return 0;
+	} else {
+		return ni_readb(Port_A + 2 * port);
+	}
+}
+
 static int ni_E_init(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
@@ -4489,19 +4500,6 @@ static int ni_E_init(struct comedi_device *dev)
 	return 0;
 }
 
-static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
-{
-	struct comedi_device *dev = (struct comedi_device *)arg;
-	struct ni_private *devpriv __maybe_unused = dev->private;
-
-	if (dir) {
-		ni_writeb(data, Port_A + 2 * port);
-		return 0;
-	} else {
-		return ni_readb(Port_A + 2 * port);
-	}
-}
-
 /*
 	presents the EEPROM as a subdevice
 */

commit 9663ab1f9fda4b53cfbfe7a0b196b6d0c1de8efa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:31:00 2014 -0700

    staging: comedi: ni_mio_common: use comedi_cmd pointer
    
    Use a local variable to access the comedi_cmd as a pointer instead
    of getting to from the comedi_async pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 9afe76f2c7c8..7ffdcc07ef92 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1468,10 +1468,11 @@ static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 {
 	struct ni_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
-	unsigned int i;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int length = num_bytes / bytes_per_sample(s);
 	unsigned short *array = data;
 	unsigned int *larray = data;
+	unsigned int i;
 
 	for (i = 0; i < length; i++) {
 #ifdef PCIDMA
@@ -1485,7 +1486,7 @@ static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 		else
 			array[i] += devpriv->ai_offset[chan_index];
 		chan_index++;
-		chan_index %= async->cmd.chanlist_len;
+		chan_index %= cmd->chanlist_len;
 	}
 }
 
@@ -2710,22 +2711,22 @@ static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 {
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct comedi_async *async = s->async;
-	unsigned int range;
-	unsigned int i;
-	unsigned int offset;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int length = num_bytes / sizeof(short);
+	unsigned int offset = 1 << (board->aobits - 1);
 	unsigned short *array = data;
+	unsigned int range;
+	unsigned int i;
 
-	offset = 1 << (board->aobits - 1);
 	for (i = 0; i < length; i++) {
-		range = CR_RANGE(async->cmd.chanlist[chan_index]);
+		range = CR_RANGE(cmd->chanlist[chan_index]);
 		if (board->ao_unipolar == 0 || (range & 1) == 0)
 			array[i] -= offset;
 #ifdef PCIDMA
 		array[i] = cpu_to_le16(array[i]);
 #endif
 		chan_index++;
-		chan_index %= async->cmd.chanlist_len;
+		chan_index %= cmd->chanlist_len;
 	}
 }
 

commit 1e575a9cd9f65f18e7a47a58b10f57dc92263e39
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:17 2014 +0100

    staging: comedi: mite: pass subdevice to mite_sync_output_dma()
    
    `mite_sync_output_dma()` in the "mite" module currently takes a pointer
    to a `struct comedi_async` and gets a pointer to the owning `struct
    comedi_subdevice` from the `subdevice` member.  Change it to take a
    pointer to a `struct comedi_subdevice` and use the `async` member.
    
    The motivation for this is to eliminate the `subdevice` member of
    `struct comedi_async`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 953130b37fda..9afe76f2c7c8 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -877,7 +877,7 @@ static void mite_handle_b_linkc(struct mite_struct *mite,
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ao_mite_chan)
-		mite_sync_output_dma(devpriv->ao_mite_chan, s->async);
+		mite_sync_output_dma(devpriv->ao_mite_chan, s);
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
@@ -3640,7 +3640,7 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 			       devpriv->mite->mite_io_addr +
 			       MITE_CHOR(devpriv->cdo_mite_chan->channel));
 		}
-		mite_sync_output_dma(devpriv->cdo_mite_chan, s->async);
+		mite_sync_output_dma(devpriv->cdo_mite_chan, s);
 	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif

commit 74f63db7ae614aee8370df6152c0da76e14b6ff0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:16 2014 +0100

    staging: comedi: mite: pass subdevice to mite_sync_input_dma()
    
    `mite_sync_input_dma()` in the "mite" module currently takes a pointer
    to a `struct comedi_async` and gets a pointer to the owning `struct
    comedi_subdevice` from the `subdevice` member.  Change it to take a
    pointer to a `struct comedi_subdevice` and use the `async` member.
    
    The motivation for this is to eliminate the `subdevice` member of
    `struct comedi_async`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e54488c2eb5a..953130b37fda 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -864,7 +864,7 @@ static void ni_sync_ai_dma(struct comedi_device *dev)
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ai_mite_chan)
-		mite_sync_input_dma(devpriv->ai_mite_chan, s->async);
+		mite_sync_input_dma(devpriv->ai_mite_chan, s);
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 

commit e9edef3a5454a19fd0d0c342cc88b6310b871a48
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:09 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_read_n_available()
    
    Change the parameters of `comedi_buf_read_n_available()` to pass a
    pointer to the comedi subdevice instead of a pointer to the "async"
    structure belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 950b223440d4..e54488c2eb5a 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1200,7 +1200,7 @@ static int ni_ao_fifo_half_empty(struct comedi_device *dev,
 	const struct ni_board_struct *board = comedi_board(dev);
 	int n;
 
-	n = comedi_buf_read_n_available(s->async);
+	n = comedi_buf_read_n_available(s);
 	if (n == 0) {
 		s->async->events |= COMEDI_CB_OVERFLOW;
 		return 0;
@@ -1230,7 +1230,7 @@ static int ni_ao_prep_fifo(struct comedi_device *dev,
 		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
 
 	/* load some data */
-	n = comedi_buf_read_n_available(s->async);
+	n = comedi_buf_read_n_available(s);
 	if (n == 0)
 		return 0;
 

commit d13be55a37a136ee4274680308b7d0d7e3818bf3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:07 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_read_alloc()
    
    Change the parameters of `comedi_buf_read_alloc()` to pass a pointer to
    the comedi subdevice instead of a pointer to the "async" structure
    belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d8415fe2188b..950b223440d4 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1545,7 +1545,7 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 		return retval;
 
 	/* read alloc the entire buffer */
-	comedi_buf_read_alloc(s->async, s->async->prealloc_bufsz);
+	comedi_buf_read_alloc(s, s->async->prealloc_bufsz);
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ao_mite_chan) {
@@ -3565,7 +3565,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 	s->async->inttrig = NULL;
 
 	/* read alloc the entire buffer */
-	comedi_buf_read_alloc(s->async, s->async->prealloc_bufsz);
+	comedi_buf_read_alloc(s, s->async->prealloc_bufsz);
 
 #ifdef PCIDMA
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);

commit 24e894bbf247ecdeed3ed2f77f658da756760f60
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:04 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_write_alloc()
    
    Change the parameters of `comedi_buf_write_alloc()` to pass a pointer to
    the comedi subdevice instead of a pointer to the "async" structure
    belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d4e99af6de71..d8415fe2188b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1505,7 +1505,7 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 /* printk("comedi_debug: using mite channel %i for ai.\n", devpriv->ai_mite_chan->channel); */
 
 	/* write alloc the entire buffer */
-	comedi_buf_write_alloc(s->async, s->async->prealloc_bufsz);
+	comedi_buf_write_alloc(s, s->async->prealloc_bufsz);
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ai_mite_chan == NULL) {

commit 458c13e935d9f33fffb099e49ecb53c67ddd1a21
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:00 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_get()
    
    Change the parameters of `comedi_buf_get()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function gets a sample value from the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 087b533625df..d4e99af6de71 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1149,7 +1149,7 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 
 	chan = async->cur_chan;
 	for (i = 0; i < n; i++) {
-		err &= comedi_buf_get(async, &d);
+		err &= comedi_buf_get(s, &d);
 		if (err == 0)
 			break;
 
@@ -1159,7 +1159,7 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 			packed_data = d & 0xffff;
 			/* 6711 only has 16 bit wide ao fifo */
 			if (board->reg_type != ni_reg_6711) {
-				err &= comedi_buf_get(async, &d);
+				err &= comedi_buf_get(s, &d);
 				if (err == 0)
 					break;
 				chan++;

commit ebb657babfa9b0b1978c1998e93865772ee9bb27
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:08:11 2014 -0700

    staging: comedi: ni_mio_common: clarify the cmd->start_arg validation and use
    
    Clarify the cmd->start_arg validation in Step 3 of the (*do_cmdtest)
    functions.
    
    For a TRIG_INT source, the cmd->start_arg is actually the valid
    trig_num that is used by the async (*inttrig) callbacks.
    
    Refactor the (*inttrig) functions so that the cmd->start_arg is used
    to check the trig_num instead of the open coded values.
    
    For aesthetics, refactor the (*do_cmd) functions to use if/else instead
    of the switch to handle the cmd->start_src.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2e26622edee5..087b533625df 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2080,7 +2080,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	int err = 0;
-	int tmp;
+	unsigned int tmp;
 	unsigned int sources;
 
 	/* Step 1 : check if triggers are trivially valid */
@@ -2119,17 +2119,19 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_src == TRIG_EXT) {
-		/* external trigger */
-		unsigned int tmp = CR_CHAN(cmd->start_arg);
+	switch (cmd->start_src) {
+	case TRIG_NOW:
+	case TRIG_INT:
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		break;
+	case TRIG_EXT:
+		tmp = CR_CHAN(cmd->start_arg);
 
 		if (tmp > 16)
 			tmp = 16;
 		tmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));
 		err |= cfc_check_trigger_arg_is(&cmd->start_arg, tmp);
-	} else {
-		/* true for both TRIG_NOW and TRIG_INT */
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		break;
 	}
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
@@ -2510,30 +2512,28 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 #endif
 
-	switch (cmd->start_src) {
-	case TRIG_NOW:
+	if (cmd->start_src == TRIG_NOW) {
 		/* AI_START1_Pulse */
 		devpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
 				    AI_Command_2_Register);
 		s->async->inttrig = NULL;
-		break;
-	case TRIG_EXT:
+	} else if (cmd->start_src == TRIG_EXT) {
 		s->async->inttrig = NULL;
-		break;
-	case TRIG_INT:
-		s->async->inttrig = &ni_ai_inttrig;
-		break;
+	} else {	/* TRIG_INT */
+		s->async->inttrig = ni_ai_inttrig;
 	}
 
 	return 0;
 }
 
-static int ni_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-			 unsigned int trignum)
+static int ni_ai_inttrig(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 unsigned int trig_num)
 {
 	struct ni_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
-	if (trignum != 0)
+	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
 	devpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
@@ -2946,17 +2946,19 @@ static int ni_ao_insn_config(struct comedi_device *dev,
 	return -EINVAL;
 }
 
-static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-			 unsigned int trignum)
+static int ni_ao_inttrig(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 unsigned int trig_num)
 {
 	const struct ni_board_struct *board __maybe_unused = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int ret;
 	int interrupt_b_bits;
 	int i;
 	static const int timeout = 1000;
 
-	if (trignum != 0)
+	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
 	/* Null trig at beginning prevent ao start trigger from executing more than
@@ -3217,7 +3219,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			    AO_BC_TC_Interrupt_Enable, 1);
 	}
 
-	s->async->inttrig = &ni_ao_inttrig;
+	s->async->inttrig = ni_ao_inttrig;
 
 	return 0;
 }
@@ -3228,7 +3230,7 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	int err = 0;
-	int tmp;
+	unsigned int tmp;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -3258,17 +3260,18 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_src == TRIG_EXT) {
-		/* external trigger */
-		unsigned int tmp = CR_CHAN(cmd->start_arg);
+	switch (cmd->start_src) {
+	case TRIG_INT:
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		break;
+	case TRIG_EXT:
+		tmp = CR_CHAN(cmd->start_arg);
 
 		if (tmp > 18)
 			tmp = 18;
 		tmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));
 		err |= cfc_check_trigger_arg_is(&cmd->start_arg, tmp);
-	} else {
-		/* true for both TRIG_NOW and TRIG_INT */
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		break;
 	}
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
@@ -3537,21 +3540,28 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	retval = ni_request_cdo_mite_channel(dev);
 	if (retval < 0)
 		return retval;
-	s->async->inttrig = &ni_cdo_inttrig;
+
+	s->async->inttrig = ni_cdo_inttrig;
+
 	return 0;
 }
 
-static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-			  unsigned int trignum)
+static int ni_cdo_inttrig(struct comedi_device *dev,
+			  struct comedi_subdevice *s,
+			  unsigned int trig_num)
 {
 #ifdef PCIDMA
 	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 #endif
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval = 0;
 	unsigned i;
 	const unsigned timeout = 1000;
 
+	if (trig_num != cmd->start_arg)
+		return -EINVAL;
+
 	s->async->inttrig = NULL;
 
 	/* read alloc the entire buffer */

commit 368c2dcd2e311bb31deb96024d260f6dec7b3f86
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 16 14:19:19 2014 -0700

    staging: comedi: ni_mio_common: factor out chanlist checking from (*do_cmdtest)
    
    Step 5 of the (*do_cmdtest) validates that the cmd->chanlist is compatible
    with the hardware.
    
    Remove the unnecessary step 5 code in the analog output async command support.
    
    For aesthetics, factor out the step 5 code for the "cdio" async command support.
    Tidy up the factored out code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8a0e3b7236ad..2e26622edee5 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3304,11 +3304,6 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 4;
 
-	/* step 5: fix up chanlist */
-
-	if (err)
-		return 5;
-
 	return 0;
 }
 
@@ -3439,12 +3434,27 @@ static int ni_m_series_dio_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
+static int ni_cdio_check_chanlist(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_cmd *cmd)
+{
+	int i;
+
+	for (i = 0; i < cmd->chanlist_len; ++i) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+
+		if (chan != i)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int ni_cdio_cmdtest(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
-	unsigned i;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -3484,12 +3494,9 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 4;
 
-	/* step 5: check chanlist */
-
-	for (i = 0; i < cmd->chanlist_len; ++i) {
-		if (cmd->chanlist[i] != i)
-			err = 1;
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= ni_cdio_check_chanlist(dev, s, cmd);
 
 	if (err)
 		return 5;

commit a21eacfeb5809427ec71a073a1801419c55446ca
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:35 2014 -0700

    staging: comedi: ni_mio_common: use cfc_handle_events()
    
    The ni_event() function in this file is an open coded version of
    cfc_handle_events() where instead of calling the subdevice (*cancel)
    function a switch is used to call the function based on the subdevice
    'index'.
    
    Use the comedi_fc helper function to simplify the code.
    
    This also allows removing a couple of the forward declarations.
    
    Fix the #ifdef/#endif for the ni_gpct_cancel() foward declaration and
    around the function. This function is now only referenced by code that
    is blocked with #ifdef PCIDMA.
    
    This source file is included by the ni_atmio, ni_mio_cs, and ni_pcimio
    drivers. In the Kconfig, the config options for these drivers already
    select COMEDI_FC.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 3a86d482babd..8a0e3b7236ad 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -256,7 +256,6 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ni_read_eeprom(struct comedi_device *dev, int addr);
 
-static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s);
 #ifndef PCIDMA
 static void ni_handle_fifo_half_full(struct comedi_device *dev);
 static int ni_ao_fifo_half_empty(struct comedi_device *dev,
@@ -272,15 +271,12 @@ static void shutdown_ai_command(struct comedi_device *dev);
 static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 			 unsigned int trignum);
 
-static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s);
-
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
 
 #ifdef PCIDMA
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 #endif
-static int ni_gpct_cancel(struct comedi_device *dev,
-			  struct comedi_subdevice *s);
 static void handle_gpct_interrupt(struct comedi_device *dev,
 				  unsigned short counter_index);
 
@@ -947,32 +943,6 @@ static void shutdown_ai_command(struct comedi_device *dev)
 	s->async->events |= COMEDI_CB_EOA;
 }
 
-static void ni_event(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	if (s->
-	    async->events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW |
-			     COMEDI_CB_EOA)) {
-		switch (s->index) {
-		case NI_AI_SUBDEV:
-			ni_ai_reset(dev, s);
-			break;
-		case NI_AO_SUBDEV:
-			ni_ao_reset(dev, s);
-			break;
-		case NI_GPCT0_SUBDEV:
-		case NI_GPCT1_SUBDEV:
-			ni_gpct_cancel(dev, s);
-			break;
-		case NI_DIO_SUBDEV:
-			ni_cdio_cancel(dev, s);
-			break;
-		default:
-			break;
-		}
-	}
-	comedi_event(dev, s);
-}
-
 static void handle_gpct_interrupt(struct comedi_device *dev,
 				  unsigned short counter_index)
 {
@@ -984,8 +954,7 @@ static void handle_gpct_interrupt(struct comedi_device *dev,
 
 	ni_tio_handle_interrupt(&devpriv->counter_dev->counters[counter_index],
 				s);
-	if (s->async->events)
-		ni_event(dev, s);
+	cfc_handle_events(dev, s);
 #endif
 }
 
@@ -1043,7 +1012,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			if (comedi_is_subdevice_running(s)) {
 				s->async->events |=
 				    COMEDI_CB_ERROR | COMEDI_CB_EOA;
-				ni_event(dev, s);
+				cfc_handle_events(dev, s);
 			}
 			return;
 		}
@@ -1058,8 +1027,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			if (status & (AI_Overrun_St | AI_Overflow_St))
 				s->async->events |= COMEDI_CB_OVERFLOW;
 
-			ni_event(dev, s);
-
+			cfc_handle_events(dev, s);
 			return;
 		}
 		if (status & AI_SC_TC_St) {
@@ -1086,7 +1054,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	if ((status & AI_STOP_St))
 		ni_handle_eos(dev, s);
 
-	ni_event(dev, s);
+	cfc_handle_events(dev, s);
 }
 
 static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
@@ -1161,7 +1129,7 @@ static void handle_b_interrupt(struct comedi_device *dev,
 	}
 #endif
 
-	ni_event(dev, s);
+	cfc_handle_events(dev, s);
 }
 
 #ifndef PCIDMA
@@ -3672,7 +3640,7 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 			  M_Offset_CDIO_Command);
 		/* s->async->events |= COMEDI_CB_EOA; */
 	}
-	ni_event(dev, s);
+	cfc_handle_events(dev, s);
 }
 
 static int ni_serial_insn_config(struct comedi_device *dev,
@@ -5008,9 +4976,9 @@ static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 #endif
 
+#ifdef PCIDMA
 static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-#ifdef PCIDMA
 	struct ni_gpct *counter = s->private;
 	int retval;
 
@@ -5018,10 +4986,8 @@ static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_e_series_enable_second_irq(dev, counter->counter_index, 0);
 	ni_release_gpct_mite_channel(dev, counter->counter_index);
 	return retval;
-#else
-	return 0;
-#endif
 }
+#endif
 
 /*
  *

commit c095fad35ec72835540b3a9b1166dcd83a74ade3
Author: Kumar Amit Mehta <gmate.amit@gmail.com>
Date:   Wed Feb 26 01:04:45 2014 +0200

    staging: comedi: drivers: fix for a potential NULL pointer dereference
    
    Return -ENOMEM in ni_E_init if ni_gpct_device_construct returns NULL
    
    Signed-off-by: Kumar Amit Mehta <gmate.amit@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8adb535516bd..3a86d482babd 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4407,6 +4407,9 @@ static int ni_E_init(struct comedi_device *dev)
 							&ni_gpct_read_register,
 							counter_variant,
 							NUM_GPCT);
+	if (!devpriv->counter_dev)
+		return -ENOMEM;
+
 	/* General purpose counters */
 	for (j = 0; j < NUM_GPCT; ++j) {
 		s = &dev->subdevices[NI_GPCT_SUBDEV(j)];

commit c93999c21319439c4fe2da85f2ec40ed477379ac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 3 11:26:50 2014 -0700

    staging: comedi: drivers: remove final 'attach' messages
    
    These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 575011533a18..8adb535516bd 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4497,7 +4497,6 @@ static int ni_E_init(struct comedi_device *dev)
 		ni_writeb(0x0, M_Offset_AO_Calibration);
 	}
 
-	printk("\n");
 	return 0;
 }
 

commit e6439a458aa2805f05dd5fb3da8a95fd90082728
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 3 10:43:25 2014 -0700

    staging: comedi: drivers: propogate errno from subdev_8255_init()
    
    The initialization of the 8255 subdevice can fail due to the allocation
    of the private data. Make sure all callers of subdev_8255_init() propogate
    the errno.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 10c27cb278cb..575011533a18 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4292,10 +4292,14 @@ static int ni_E_init(struct comedi_device *dev)
 
 	/* 8255 device */
 	s = &dev->subdevices[NI_8255_DIO_SUBDEV];
-	if (board->has_8255)
-		subdev_8255_init(dev, s, ni_8255_callback, (unsigned long)dev);
-	else
+	if (board->has_8255) {
+		ret = subdev_8255_init(dev, s, ni_8255_callback,
+				       (unsigned long)dev);
+		if (ret)
+			return ret;
+	} else {
 		s->type = COMEDI_SUBD_UNUSED;
+	}
 
 	/* formerly general purpose counter/timer device, but no longer used */
 	s = &dev->subdevices[NI_UNUSED_SUBDEV];

commit 60738f605b9575714c8d959425b317692e72c6e3
Author: Chase Southwood <chase.southwood@yahoo.com>
Date:   Thu Jan 16 12:27:29 2014 -0600

    Staging: comedi: convert while loop to timeout in ni_mio_common.c
    
    This patch for ni_mio_common.c changes out a while loop for a timeout,
    which is preferred.
    
    Signed-off-by: Chase Southwood <chase.southwood@yahoo.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 457b88481db0..10c27cb278cb 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -687,12 +687,22 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
+	static const int timeout = 10000;
+	int i;
 
 	if (board->reg_type == ni_reg_6143) {
 		/*  Flush the 6143 data FIFO */
 		ni_writel(0x10, AIFIFO_Control_6143);	/*  Flush fifo */
 		ni_writel(0x00, AIFIFO_Control_6143);	/*  Flush fifo */
-		while (ni_readl(AIFIFO_Status_6143) & 0x10) ;	/*  Wait for complete */
+		/*  Wait for complete */
+		for (i = 0; i < timeout; i++) {
+			if (!(ni_readl(AIFIFO_Status_6143) & 0x10))
+				break;
+			udelay(1);
+		}
+		if (i == timeout) {
+			comedi_error(dev, "FIFO flush timeout.");
+		}
 	} else {
 		devpriv->stc_writew(dev, 1, ADC_FIFO_Clear);
 		if (board->reg_type == ni_reg_625x) {

commit 69ba83585a22091455fdbf7f8b3ddc4788b401e2
Author: Chase Southwood <chase.southwood@yahoo.com>
Date:   Fri Jan 10 22:03:12 2014 -0600

    Staging: comedi: fix extra whitespace style issues in ni_mio_common.c.
    
    This patch for ni_mio_common.c removes extra whitespace causing
    checkpatch.pl warnings.
    
    Signed-off-by: Chase Southwood <chase.southwood@yahoo.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 95f4e3715134..457b88481db0 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -992,7 +992,7 @@ static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 		ack |= AI_START_Interrupt_Ack;
 	if (a_status & AI_STOP_St)
 		/* not sure why we used to ack the START here also, instead of doing it independently. Frank Hess 2007-07-06 */
-		ack |= AI_STOP_Interrupt_Ack /*| AI_START_Interrupt_Ack */ ;
+		ack |= AI_STOP_Interrupt_Ack /*| AI_START_Interrupt_Ack */;
 	if (ack)
 		devpriv->stc_writew(dev, ack, Interrupt_A_Ack_Register);
 }
@@ -4262,7 +4262,7 @@ static int ni_E_init(struct comedi_device *dev)
 	s->n_chan = board->num_p0_dio_channels;
 	if (board->reg_type & ni_reg_m_series_mask) {
 		s->subdev_flags |=
-		    SDF_LSAMPL | SDF_CMD_WRITE /* | SDF_CMD_READ */ ;
+		    SDF_LSAMPL | SDF_CMD_WRITE /* | SDF_CMD_READ */;
 		s->insn_bits = &ni_m_series_dio_insn_bits;
 		s->insn_config = &ni_m_series_dio_insn_config;
 		s->do_cmd = &ni_cdio_cmd;
@@ -4731,7 +4731,7 @@ static int pack_ad8842(int addr, int val, int *bitstring);
 struct caldac_struct {
 	int n_chans;
 	int n_bits;
-	int (*packbits) (int, int, int *);
+	int (*packbits)(int, int, int *);
 };
 
 static struct caldac_struct caldacs[] = {

commit b9ede3154a4342434c155a7e4daa3915fc9769b1
Author: Chase Southwood <chase.southwood@yahoo.com>
Date:   Fri Jan 10 22:02:57 2014 -0600

    Staging: comedi: fix indentation coding style issue in ni_mio_common.c.
    
    This patch for ni_mio_common.c fixes several indentation warnings from
    checkpatch.pl.
    
    Signed-off-by: Chase Southwood <chase.southwood@yahoo.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 116174a14ade..95f4e3715134 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3652,15 +3652,15 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 
 	cdio_status = ni_readl(M_Offset_CDIO_Status);
 	if (cdio_status & (CDO_Overrun_Bit | CDO_Underflow_Bit)) {
-/* printk("cdio error: statux=0x%x\n", cdio_status); */
+		/* printk("cdio error: statux=0x%x\n", cdio_status); */
 		ni_writel(CDO_Error_Interrupt_Confirm_Bit, M_Offset_CDIO_Command);	/*  XXX just guessing this is needed and does something useful */
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 	if (cdio_status & CDO_FIFO_Empty_Bit) {
-/* printk("cdio fifo empty\n"); */
+		/* printk("cdio fifo empty\n"); */
 		ni_writel(CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
 			  M_Offset_CDIO_Command);
-/* s->async->events |= COMEDI_CB_EOA; */
+		/* s->async->events |= COMEDI_CB_EOA; */
 	}
 	ni_event(dev, s);
 }
@@ -3845,7 +3845,7 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 		/* Input current bit */
 		if (devpriv->stc_readw(dev,
 				       DIO_Parallel_Input_Register) & DIO_SDIN) {
-/*			printk("DIO_P_I_R: 0x%x\n", devpriv->stc_readw(dev, DIO_Parallel_Input_Register)); */
+			/* printk("DIO_P_I_R: 0x%x\n", devpriv->stc_readw(dev, DIO_Parallel_Input_Register)); */
 			input |= mask;
 		}
 	}

commit bc4615561fc3df0826ac9a93876770cdbf673a80
Author: Chase Southwood <chase.southwood@yahoo.com>
Date:   Fri Jan 10 22:02:33 2014 -0600

    Staging: comedi: fix numerous brace coding style issues in ni_mio_common.c.
    
    This patch for ni_mio_common.c removes many unneccesary braces to fix
    checkpatch.pl warnings.
    
    Signed-off-by: Chase Southwood <chase.southwood@yahoo.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index eb9f51758435..116174a14ade 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -451,11 +451,10 @@ static inline void ni_set_gpct_dma_channel(struct comedi_device *dev,
 {
 	unsigned bitfield;
 
-	if (mite_channel >= 0) {
+	if (mite_channel >= 0)
 		bitfield = GPCT_DMA_Select_Bits(gpct_index, mite_channel);
-	} else {
+	else
 		bitfield = 0;
-	}
 	ni_set_bitfield(dev, G0_G1_Select, GPCT_DMA_Select_Mask(gpct_index),
 			bitfield);
 }
@@ -871,9 +870,8 @@ static void mite_handle_b_linkc(struct mite_struct *mite,
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	if (devpriv->ao_mite_chan) {
+	if (devpriv->ao_mite_chan)
 		mite_sync_output_dma(devpriv->ao_mite_chan, s->async);
-	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
@@ -921,9 +919,8 @@ static void ni_handle_eos(struct comedi_device *dev, struct comedi_subdevice *s)
 #endif
 	}
 	/* handle special case of single scan using AI_End_On_End_Of_Scan */
-	if ((devpriv->ai_cmd2 & AI_End_On_End_Of_Scan)) {
+	if ((devpriv->ai_cmd2 & AI_End_On_End_Of_Scan))
 		shutdown_ai_command(dev);
-	}
 }
 
 static void shutdown_ai_command(struct comedi_device *dev)
@@ -987,19 +984,15 @@ static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 	struct ni_private *devpriv = dev->private;
 	unsigned short ack = 0;
 
-	if (a_status & AI_SC_TC_St) {
+	if (a_status & AI_SC_TC_St)
 		ack |= AI_SC_TC_Interrupt_Ack;
-	}
-	if (a_status & AI_START1_St) {
+	if (a_status & AI_START1_St)
 		ack |= AI_START1_Interrupt_Ack;
-	}
-	if (a_status & AI_START_St) {
+	if (a_status & AI_START_St)
 		ack |= AI_START_Interrupt_Ack;
-	}
-	if (a_status & AI_STOP_St) {
+	if (a_status & AI_STOP_St)
 		/* not sure why we used to ack the START here also, instead of doing it independently. Frank Hess 2007-07-06 */
 		ack |= AI_STOP_Interrupt_Ack /*| AI_START_Interrupt_Ack */ ;
-	}
 	if (ack)
 		devpriv->stc_writew(dev, ack, Interrupt_A_Ack_Register);
 }
@@ -1015,9 +1008,8 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 		return;
 
 #ifdef PCIDMA
-	if (ai_mite_status & CHSR_LINKC) {
+	if (ai_mite_status & CHSR_LINKC)
 		ni_sync_ai_dma(dev);
-	}
 
 	if (ai_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
 			       CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
@@ -1061,9 +1053,8 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			return;
 		}
 		if (status & AI_SC_TC_St) {
-			if (!devpriv->ai_continuous) {
+			if (!devpriv->ai_continuous)
 				shutdown_ai_command(dev);
-			}
 		}
 	}
 #ifndef PCIDMA
@@ -1082,9 +1073,8 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	}
 #endif /*  !PCIDMA */
 
-	if ((status & AI_STOP_St)) {
+	if ((status & AI_STOP_St))
 		ni_handle_eos(dev, s);
-	}
 
 	ni_event(dev, s);
 }
@@ -1094,27 +1084,20 @@ static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
 	struct ni_private *devpriv = dev->private;
 	unsigned short ack = 0;
 
-	if (b_status & AO_BC_TC_St) {
+	if (b_status & AO_BC_TC_St)
 		ack |= AO_BC_TC_Interrupt_Ack;
-	}
-	if (b_status & AO_Overrun_St) {
+	if (b_status & AO_Overrun_St)
 		ack |= AO_Error_Interrupt_Ack;
-	}
-	if (b_status & AO_START_St) {
+	if (b_status & AO_START_St)
 		ack |= AO_START_Interrupt_Ack;
-	}
-	if (b_status & AO_START1_St) {
+	if (b_status & AO_START1_St)
 		ack |= AO_START1_Interrupt_Ack;
-	}
-	if (b_status & AO_UC_TC_St) {
+	if (b_status & AO_UC_TC_St)
 		ack |= AO_UC_TC_Interrupt_Ack;
-	}
-	if (b_status & AO_UI2_TC_St) {
+	if (b_status & AO_UI2_TC_St)
 		ack |= AO_UI2_TC_Interrupt_Ack;
-	}
-	if (b_status & AO_UPDATE_St) {
+	if (b_status & AO_UPDATE_St)
 		ack |= AO_UPDATE_Interrupt_Ack;
-	}
 	if (ack)
 		devpriv->stc_writew(dev, ack, Interrupt_B_Ack_Register);
 }
@@ -1128,9 +1111,8 @@ static void handle_b_interrupt(struct comedi_device *dev,
 
 #ifdef PCIDMA
 	/* Currently, mite.c requires us to handle LINKC */
-	if (ao_mite_status & CHSR_LINKC) {
+	if (ao_mite_status & CHSR_LINKC)
 		mite_handle_b_linkc(devpriv->mite, dev);
-	}
 
 	if (ao_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
 			       CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
@@ -1214,9 +1196,8 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 		chan %= cmd->chanlist_len;
 	}
 	async->cur_chan = chan;
-	if (err == 0) {
+	if (err == 0)
 		async->events |= COMEDI_CB_OVERFLOW;
-	}
 }
 
 /*
@@ -3130,11 +3111,10 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 	devpriv->ao_mode2 &= ~AO_BC_Initial_Load_Source;
 	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
-	if (cmd->stop_src == TRIG_NONE) {
+	if (cmd->stop_src == TRIG_NONE)
 		devpriv->stc_writel(dev, 0xffffff, AO_BC_Load_A_Register);
-	} else {
+	else
 		devpriv->stc_writel(dev, 0, AO_BC_Load_A_Register);
-	}
 	devpriv->stc_writew(dev, AO_BC_Load, AO_Command_1_Register);
 	devpriv->ao_mode2 &= ~AO_UC_Initial_Load_Source;
 	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
@@ -3395,9 +3375,8 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (board->reg_type & ni_reg_6xxx_mask) {
 		unsigned immediate_bits = 0;
 		unsigned i;
-		for (i = 0; i < s->n_chan; ++i) {
+		for (i = 0; i < s->n_chan; ++i)
 			immediate_bits |= 1 << i;
-		}
 		ao_win_out(immediate_bits, AO_Immediate_671x);
 		ao_win_out(CLEAR_WG, AO_Misc_611x);
 	}
@@ -3571,9 +3550,8 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EIO;
 	}
 	retval = ni_request_cdo_mite_channel(dev);
-	if (retval < 0) {
+	if (retval < 0)
 		return retval;
-	}
 	s->async->inttrig = &ni_cdo_inttrig;
 	return 0;
 }
@@ -3655,9 +3633,8 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	unsigned long flags;
 #endif
 
-	if ((board->reg_type & ni_reg_m_series_mask) == 0) {
+	if ((board->reg_type & ni_reg_m_series_mask) == 0)
 		return;
-	}
 #ifdef PCIDMA
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
@@ -3752,9 +3729,8 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 
 	case INSN_CONFIG_BIDIRECTIONAL_DATA:
 
-		if (devpriv->serial_interval_ns == 0) {
+		if (devpriv->serial_interval_ns == 0)
 			return -EINVAL;
-		}
 
 		byte_out = data[1] & 0xFF;
 
@@ -3847,9 +3823,8 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 		   because it is a per-subdevice field, and serial is
 		   a separate subdevice from DIO. */
 		devpriv->dio_output &= ~DIO_SDOUT;
-		if (data_out & mask) {
+		if (data_out & mask)
 			devpriv->dio_output |= DIO_SDOUT;
-		}
 		devpriv->stc_writew(dev, devpriv->dio_output,
 				    DIO_Output_Register);
 
@@ -3869,8 +3844,7 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 
 		/* Input current bit */
 		if (devpriv->stc_readw(dev,
-				       DIO_Parallel_Input_Register) & DIO_SDIN)
-		{
+				       DIO_Parallel_Input_Register) & DIO_SDIN) {
 /*			printk("DIO_P_I_R: 0x%x\n", devpriv->stc_readw(dev, DIO_Parallel_Input_Register)); */
 			input |= mask;
 		}
@@ -3887,9 +3861,8 @@ static void mio_common_detach(struct comedi_device *dev)
 	struct ni_private *devpriv = dev->private;
 
 	if (devpriv) {
-		if (devpriv->counter_dev) {
+		if (devpriv->counter_dev)
 			ni_gpct_device_destroy(devpriv->counter_dev);
-		}
 	}
 }
 
@@ -4252,11 +4225,10 @@ static int ni_E_init(struct comedi_device *dev)
 		s->maxdata = (1 << board->aobits) - 1;
 		s->range_table = board->ao_range_table;
 		s->insn_read = &ni_ao_insn_read;
-		if (board->reg_type & ni_reg_6xxx_mask) {
+		if (board->reg_type & ni_reg_6xxx_mask)
 			s->insn_write = &ni_ao_insn_write_671x;
-		} else {
+		else
 			s->insn_write = &ni_ao_insn_write;
-		}
 		s->insn_config = &ni_ao_insn_config;
 #ifdef PCIDMA
 		if (board->n_aochan) {
@@ -4310,11 +4282,10 @@ static int ni_E_init(struct comedi_device *dev)
 
 	/* 8255 device */
 	s = &dev->subdevices[NI_8255_DIO_SUBDEV];
-	if (board->has_8255) {
+	if (board->has_8255)
 		subdev_8255_init(dev, s, ni_8255_callback, (unsigned long)dev);
-	} else {
+	else
 		s->type = COMEDI_SUBD_UNUSED;
-	}
 
 	/* formerly general purpose counter/timer device, but no longer used */
 	s = &dev->subdevices[NI_UNUSED_SUBDEV];
@@ -4372,9 +4343,8 @@ static int ni_E_init(struct comedi_device *dev)
 		s->n_chan = 10;
 	}
 	s->maxdata = 1;
-	if (board->reg_type & ni_reg_m_series_mask) {
+	if (board->reg_type & ni_reg_m_series_mask)
 		s->insn_bits = &ni_pfi_insn_bits;
-	}
 	s->insn_config = &ni_pfi_insn_config;
 	ni_set_bits(dev, IO_Bidirection_Pin_Register, ~0, 0);
 
@@ -4414,11 +4384,10 @@ static int ni_E_init(struct comedi_device *dev)
 	s->insn_config = ni_rtsi_insn_config;
 	ni_rtsi_init(dev);
 
-	if (board->reg_type & ni_reg_m_series_mask) {
+	if (board->reg_type & ni_reg_m_series_mask)
 		counter_variant = ni_gpct_variant_m_series;
-	} else {
+	else
 		counter_variant = ni_gpct_variant_e_series;
-	}
 	devpriv->counter_dev = ni_gpct_device_construct(dev,
 							&ni_gpct_write_register,
 							&ni_gpct_read_register,
@@ -4805,9 +4774,8 @@ static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (diffbits) {
 		unsigned int *maxdata_list;
 
-		if (n_chans > MAX_N_CALDACS) {
+		if (n_chans > MAX_N_CALDACS)
 			printk("BUG! MAX_N_CALDACS too small\n");
-		}
 		s->maxdata_list = maxdata_list = devpriv->caldac_maxdata_list;
 		chan = 0;
 		for (i = 0; i < n_dacs; i++) {
@@ -5155,9 +5123,8 @@ static int ni_config_filter(struct comedi_device *dev, unsigned pfi_channel,
 	struct ni_private *devpriv __maybe_unused = dev->private;
 	unsigned bits;
 
-	if ((board->reg_type & ni_reg_m_series_mask) == 0) {
+	if ((board->reg_type & ni_reg_m_series_mask) == 0)
 		return -ENOTSUPP;
-	}
 	bits = ni_readl(M_Offset_PFI_Filter);
 	bits &= ~MSeries_PFI_Filter_Select_Mask(pfi_channel);
 	bits |= MSeries_PFI_Filter_Select_Bits(pfi_channel, filter);
@@ -5238,9 +5205,8 @@ static void ni_rtsi_init(struct comedi_device *dev)
 
 	/*  Set clock mode to internal */
 	devpriv->clock_and_fout2 = MSeries_RTSI_10MHz_Bit;
-	if (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0) {
+	if (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0)
 		printk("ni_set_master_clock failed, bug?");
-	}
 	/*  default internal lines routing to RTSI bus lines */
 	devpriv->rtsi_trig_a_output_reg =
 	    RTSI_Trig_Output_Bits(0,
@@ -5423,9 +5389,8 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 	devpriv->clock_source = source;
 	/* it seems to typically take a few hundred microseconds for PLL to lock */
 	for (i = 0; i < timeout; ++i) {
-		if (ni_readw(M_Offset_PLL_Status) & MSeries_PLL_Locked_Bit) {
+		if (ni_readw(M_Offset_PLL_Status) & MSeries_PLL_Locked_Bit)
 			break;
-		}
 		udelay(1);
 	}
 	if (i == timeout) {
@@ -5647,13 +5612,11 @@ static int cs5529_wait_for_idle(struct comedi_device *dev)
 
 	for (i = 0; i < timeout; i++) {
 		status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
-		if ((status & CSS_ADC_BUSY) == 0) {
+		if ((status & CSS_ADC_BUSY) == 0)
 			break;
-		}
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (schedule_timeout(1)) {
+		if (schedule_timeout(1))
 			return -EIO;
-		}
 	}
 /* printk("looped %i times waiting for idle\n", i); */
 	if (i == timeout) {
@@ -5679,9 +5642,8 @@ static void cs5529_command(struct comedi_device *dev, unsigned short value)
 		udelay(1);
 	}
 /* printk("looped %i times writing command to cs5529\n", i); */
-	if (i == timeout) {
+	if (i == timeout)
 		comedi_error(dev, "possible problem - never saw adc go busy?");
-	}
 }
 
 /* write to cs5529 register */

commit 16cc181d630db4bd75b36979ffaef5d76017cd70
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:32:04 2013 -0700

    staging: comedi: ni_tiocmd: make ni_tio_cmd() a proper comedi (*do_cmd)
    
    Change the parameters to ni_tio_cmd() to make it a proper comedi
    (*do_cmd) function.
    
    The wrappers in the ni_660x and ni_mio_common modules are still needed
    to request the mite channel and setup the device before actually doing
    the command.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a2cfcce1b6a2..eb9f51758435 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5007,9 +5007,8 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 #ifdef PCIDMA
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	int retval;
 	struct ni_gpct *counter = s->private;
-/* const struct comedi_cmd *cmd = &s->async->cmd; */
+	int retval;
 
 	retval = ni_request_gpct_mite_channel(dev, counter->counter_index,
 					      COMEDI_INPUT);
@@ -5020,8 +5019,8 @@ static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	ni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);
 	ni_e_series_enable_second_irq(dev, counter->counter_index, 1);
-	retval = ni_tio_cmd(counter, s->async);
-	return retval;
+
+	return ni_tio_cmd(dev, s);
 }
 #endif
 

commit c3f3b431dec0de741e35a93d506e439bef0bbb26
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:32:03 2013 -0700

    staging: comedi: ni_tiocmd: make ni_tio_cmdtest() a proper comedi (*do_cmdtest)
    
    Change the parameters to ni_tio_cmdtest() to make it a proper comedi
    (*do_cmdtest) function. This allows using it directly and removing the
    wrapper functions in the ni_660x and ni_mio_common modules.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 29f9ca8d31fb..a2cfcce1b6a2 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -278,8 +278,6 @@ static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
 
 #ifdef PCIDMA
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int ni_gpct_cmdtest(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_cmd *cmd);
 #endif
 static int ni_gpct_cancel(struct comedi_device *dev,
 			  struct comedi_subdevice *s);
@@ -4443,7 +4441,7 @@ static int ni_E_init(struct comedi_device *dev)
 		s->subdev_flags |= SDF_CMD_READ /* | SDF_CMD_WRITE */;
 		s->do_cmd = &ni_gpct_cmd;
 		s->len_chanlist = 1;
-		s->do_cmdtest = &ni_gpct_cmdtest;
+		s->do_cmdtest = ni_tio_cmdtest;
 		s->cancel = &ni_gpct_cancel;
 		s->async_dma_dir = DMA_BIDIRECTIONAL;
 #endif
@@ -5027,17 +5025,6 @@ static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 #endif
 
-#ifdef PCIDMA
-static int ni_gpct_cmdtest(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
-{
-	struct ni_gpct *counter = s->private;
-
-	return ni_tio_cmdtest(counter, cmd);
-	return -ENOTSUPP;
-}
-#endif
-
 static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 #ifdef PCIDMA

commit cac04c0f68a2d1c4ebf505f9b7626e194d40c0c0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:32:02 2013 -0700

    staging: comedi: ni_tio: make ni_tio_insn_config() a proper comedi (*insn_config)
    
    Change the parameters to ni_tio_insn_config() to make it a proper comedi
    (*insn_config) function. This allows using it directly and removing the
    wrapper functions in the ni_660x and ni_mio_common modules.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7e030b051d31..29f9ca8d31fb 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -276,9 +276,6 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
 
-static int ni_gpct_insn_config(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data);
 #ifdef PCIDMA
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ni_gpct_cmdtest(struct comedi_device *dev,
@@ -4441,7 +4438,7 @@ static int ni_E_init(struct comedi_device *dev)
 			s->maxdata = 0xffffff;
 		s->insn_read = ni_tio_insn_read;
 		s->insn_write = ni_tio_insn_read;
-		s->insn_config = &ni_gpct_insn_config;
+		s->insn_config = ni_tio_insn_config;
 #ifdef PCIDMA
 		s->subdev_flags |= SDF_CMD_READ /* | SDF_CMD_WRITE */;
 		s->do_cmd = &ni_gpct_cmd;
@@ -5009,14 +5006,6 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 
 #endif
 
-static int ni_gpct_insn_config(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
-{
-	struct ni_gpct *counter = s->private;
-	return ni_tio_insn_config(counter, insn, data);
-}
-
 #ifdef PCIDMA
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {

commit 10f74377eec3318a63a3693e6e6d13af55c25624
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:32:01 2013 -0700

    staging: comedi: ni_tio: make ni_tio_winsn() a proper comedi (*insn_write)
    
    Change the parameters to ni_tio_winsn() to make it a proper comedi
    (*insn_write) function. This allows using it directly and removing the
    wrapper functions in the ni_660x and ni_mio_common modules.
    
    For aesthetics, rename the function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index cbe40881749f..7e030b051d31 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -276,9 +276,6 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
 
-static int ni_gpct_insn_write(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data);
 static int ni_gpct_insn_config(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data);
@@ -4443,7 +4440,7 @@ static int ni_E_init(struct comedi_device *dev)
 		else
 			s->maxdata = 0xffffff;
 		s->insn_read = ni_tio_insn_read;
-		s->insn_write = &ni_gpct_insn_write;
+		s->insn_write = ni_tio_insn_read;
 		s->insn_config = &ni_gpct_insn_config;
 #ifdef PCIDMA
 		s->subdev_flags |= SDF_CMD_READ /* | SDF_CMD_WRITE */;
@@ -5020,14 +5017,6 @@ static int ni_gpct_insn_config(struct comedi_device *dev,
 	return ni_tio_insn_config(counter, insn, data);
 }
 
-static int ni_gpct_insn_write(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
-{
-	struct ni_gpct *counter = s->private;
-	return ni_tio_winsn(counter, insn, data);
-}
-
 #ifdef PCIDMA
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {

commit 9014d816e549d562a3566f8eed6e537500f2cfd1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:32:00 2013 -0700

    staging: comedi: ni_tio: make ni_tio_rinsn() a proper comedi (*insn_read)
    
    Change the parameters to ni_tio_rinsn() to make is a proper comedi
    (*insn_read) function. This allows using it directly and removing the
    wrapper functions in the ni_660x and ni_mio_common modules.
    
    For aesthetics, rename the function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index c087f460c02b..cbe40881749f 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -279,9 +279,6 @@ static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
 static int ni_gpct_insn_write(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data);
-static int ni_gpct_insn_read(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data);
 static int ni_gpct_insn_config(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data);
@@ -4445,7 +4442,7 @@ static int ni_E_init(struct comedi_device *dev)
 			s->maxdata = 0xffffffff;
 		else
 			s->maxdata = 0xffffff;
-		s->insn_read = &ni_gpct_insn_read;
+		s->insn_read = ni_tio_insn_read;
 		s->insn_write = &ni_gpct_insn_write;
 		s->insn_config = &ni_gpct_insn_config;
 #ifdef PCIDMA
@@ -5023,14 +5020,6 @@ static int ni_gpct_insn_config(struct comedi_device *dev,
 	return ni_tio_insn_config(counter, insn, data);
 }
 
-static int ni_gpct_insn_read(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
-{
-	struct ni_gpct *counter = s->private;
-	return ni_tio_rinsn(counter, insn, data);
-}
-
 static int ni_gpct_insn_write(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)

commit 12375292ce8afebab91215539916ae6f511f3923
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:33 2013 -0700

    staging: comedi: ni_tio.h: rename the CamelCase enum ni_gpct_register labels
    
    As prefered by the CodingStyle, rename all the CamelCase labels of the
    enum ni_gpct_register.
    
    Cleanup all the helper functions in ni_tio_internal.h that used the enum.
    
    The 'counter_index' parameter to all the functions is the ni_gpct_device
    'counter_index' which is initialized when the subdevices are setup. This
    value is always < 4 so the default: BUG() cases can never happen. For
    aesthetics, rename the 'counter_idx' to simply 'idx' and fix the type in
    some of the helpers.
    
    Also, remove the unnecessary break statements after the return statements.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 084e67ef53b6..c087f460c02b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3919,82 +3919,82 @@ static unsigned ni_gpct_to_stc_register(enum ni_gpct_register reg)
 {
 	unsigned stc_register;
 	switch (reg) {
-	case NITIO_G0_Autoincrement_Reg:
+	case NITIO_G0_AUTO_INC:
 		stc_register = G_Autoincrement_Register(0);
 		break;
-	case NITIO_G1_Autoincrement_Reg:
+	case NITIO_G1_AUTO_INC:
 		stc_register = G_Autoincrement_Register(1);
 		break;
-	case NITIO_G0_Command_Reg:
+	case NITIO_G0_CMD:
 		stc_register = G_Command_Register(0);
 		break;
-	case NITIO_G1_Command_Reg:
+	case NITIO_G1_CMD:
 		stc_register = G_Command_Register(1);
 		break;
-	case NITIO_G0_HW_Save_Reg:
+	case NITIO_G0_HW_SAVE:
 		stc_register = G_HW_Save_Register(0);
 		break;
-	case NITIO_G1_HW_Save_Reg:
+	case NITIO_G1_HW_SAVE:
 		stc_register = G_HW_Save_Register(1);
 		break;
-	case NITIO_G0_SW_Save_Reg:
+	case NITIO_G0_SW_SAVE:
 		stc_register = G_Save_Register(0);
 		break;
-	case NITIO_G1_SW_Save_Reg:
+	case NITIO_G1_SW_SAVE:
 		stc_register = G_Save_Register(1);
 		break;
-	case NITIO_G0_Mode_Reg:
+	case NITIO_G0_MODE:
 		stc_register = G_Mode_Register(0);
 		break;
-	case NITIO_G1_Mode_Reg:
+	case NITIO_G1_MODE:
 		stc_register = G_Mode_Register(1);
 		break;
-	case NITIO_G0_LoadA_Reg:
+	case NITIO_G0_LOADA:
 		stc_register = G_Load_A_Register(0);
 		break;
-	case NITIO_G1_LoadA_Reg:
+	case NITIO_G1_LOADA:
 		stc_register = G_Load_A_Register(1);
 		break;
-	case NITIO_G0_LoadB_Reg:
+	case NITIO_G0_LOADB:
 		stc_register = G_Load_B_Register(0);
 		break;
-	case NITIO_G1_LoadB_Reg:
+	case NITIO_G1_LOADB:
 		stc_register = G_Load_B_Register(1);
 		break;
-	case NITIO_G0_Input_Select_Reg:
+	case NITIO_G0_INPUT_SEL:
 		stc_register = G_Input_Select_Register(0);
 		break;
-	case NITIO_G1_Input_Select_Reg:
+	case NITIO_G1_INPUT_SEL:
 		stc_register = G_Input_Select_Register(1);
 		break;
-	case NITIO_G01_Status_Reg:
+	case NITIO_G01_STATUS:
 		stc_register = G_Status_Register;
 		break;
-	case NITIO_G01_Joint_Reset_Reg:
+	case NITIO_G01_RESET:
 		stc_register = Joint_Reset_Register;
 		break;
-	case NITIO_G01_Joint_Status1_Reg:
+	case NITIO_G01_STATUS1:
 		stc_register = Joint_Status_1_Register;
 		break;
-	case NITIO_G01_Joint_Status2_Reg:
+	case NITIO_G01_STATUS2:
 		stc_register = Joint_Status_2_Register;
 		break;
-	case NITIO_G0_Interrupt_Acknowledge_Reg:
+	case NITIO_G0_INT_ACK:
 		stc_register = Interrupt_A_Ack_Register;
 		break;
-	case NITIO_G1_Interrupt_Acknowledge_Reg:
+	case NITIO_G1_INT_ACK:
 		stc_register = Interrupt_B_Ack_Register;
 		break;
-	case NITIO_G0_Status_Reg:
+	case NITIO_G0_STATUS:
 		stc_register = AI_Status_1_Register;
 		break;
-	case NITIO_G1_Status_Reg:
+	case NITIO_G1_STATUS:
 		stc_register = AO_Status_1_Register;
 		break;
-	case NITIO_G0_Interrupt_Enable_Reg:
+	case NITIO_G0_INT_ENA:
 		stc_register = Interrupt_A_Enable_Register;
 		break;
-	case NITIO_G1_Interrupt_Enable_Reg:
+	case NITIO_G1_INT_ENA:
 		stc_register = Interrupt_B_Enable_Register;
 		break;
 	default:
@@ -4022,52 +4022,52 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 
 	switch (reg) {
 		/* m-series-only registers */
-	case NITIO_G0_Counting_Mode_Reg:
+	case NITIO_G0_CNT_MODE:
 		ni_writew(bits, M_Offset_G0_Counting_Mode);
 		break;
-	case NITIO_G1_Counting_Mode_Reg:
+	case NITIO_G1_CNT_MODE:
 		ni_writew(bits, M_Offset_G1_Counting_Mode);
 		break;
-	case NITIO_G0_Second_Gate_Reg:
+	case NITIO_G0_GATE2:
 		ni_writew(bits, M_Offset_G0_Second_Gate);
 		break;
-	case NITIO_G1_Second_Gate_Reg:
+	case NITIO_G1_GATE2:
 		ni_writew(bits, M_Offset_G1_Second_Gate);
 		break;
-	case NITIO_G0_DMA_Config_Reg:
+	case NITIO_G0_DMA_CFG:
 		ni_writew(bits, M_Offset_G0_DMA_Config);
 		break;
-	case NITIO_G1_DMA_Config_Reg:
+	case NITIO_G1_DMA_CFG:
 		ni_writew(bits, M_Offset_G1_DMA_Config);
 		break;
-	case NITIO_G0_ABZ_Reg:
+	case NITIO_G0_ABZ:
 		ni_writew(bits, M_Offset_G0_MSeries_ABZ);
 		break;
-	case NITIO_G1_ABZ_Reg:
+	case NITIO_G1_ABZ:
 		ni_writew(bits, M_Offset_G1_MSeries_ABZ);
 		break;
 
 		/* 32 bit registers */
-	case NITIO_G0_LoadA_Reg:
-	case NITIO_G1_LoadA_Reg:
-	case NITIO_G0_LoadB_Reg:
-	case NITIO_G1_LoadB_Reg:
+	case NITIO_G0_LOADA:
+	case NITIO_G1_LOADA:
+	case NITIO_G0_LOADB:
+	case NITIO_G1_LOADB:
 		stc_register = ni_gpct_to_stc_register(reg);
 		devpriv->stc_writel(dev, bits, stc_register);
 		break;
 
 		/* 16 bit registers */
-	case NITIO_G0_Interrupt_Enable_Reg:
+	case NITIO_G0_INT_ENA:
 		BUG_ON(bits & ~gpct_interrupt_a_enable_mask);
 		ni_set_bitfield(dev, Interrupt_A_Enable_Register,
 				gpct_interrupt_a_enable_mask, bits);
 		break;
-	case NITIO_G1_Interrupt_Enable_Reg:
+	case NITIO_G1_INT_ENA:
 		BUG_ON(bits & ~gpct_interrupt_b_enable_mask);
 		ni_set_bitfield(dev, Interrupt_B_Enable_Register,
 				gpct_interrupt_b_enable_mask, bits);
 		break;
-	case NITIO_G01_Joint_Reset_Reg:
+	case NITIO_G01_RESET:
 		BUG_ON(bits & ~gpct_joint_reset_mask);
 		/* fall-through */
 	default:
@@ -4085,21 +4085,18 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 
 	switch (reg) {
 		/* m-series only registers */
-	case NITIO_G0_DMA_Status_Reg:
+	case NITIO_G0_DMA_STATUS:
 		return ni_readw(M_Offset_G0_DMA_Status);
-		break;
-	case NITIO_G1_DMA_Status_Reg:
+	case NITIO_G1_DMA_STATUS:
 		return ni_readw(M_Offset_G1_DMA_Status);
-		break;
 
 		/* 32 bit registers */
-	case NITIO_G0_HW_Save_Reg:
-	case NITIO_G1_HW_Save_Reg:
-	case NITIO_G0_SW_Save_Reg:
-	case NITIO_G1_SW_Save_Reg:
+	case NITIO_G0_HW_SAVE:
+	case NITIO_G1_HW_SAVE:
+	case NITIO_G0_SW_SAVE:
+	case NITIO_G1_SW_SAVE:
 		stc_register = ni_gpct_to_stc_register(reg);
 		return devpriv->stc_readl(dev, stc_register);
-		break;
 
 		/* 16 bit registers */
 	default:

commit daed6c7284480d94f0c03d5eb51ed541e1772894
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:30:59 2013 -0700

    staging: comedi: ni_mio_common: tidy up comedi_lrange tables
    
    Tidy up the whitespace in the comedi_lrange tables.
    
    Use the BIP_RANGE and UNI_RANGE macros instead of the more generic
    RANGE macro to reduce possible typo errors.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 65db6add0a68..084e67ef53b6 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -78,111 +78,109 @@ static const short ni_gainlkup[][16] = {
 	[ai_gain_6143] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
 };
 
-static const struct comedi_lrange range_ni_E_ai = { 16, {
-							 RANGE(-10, 10),
-							 RANGE(-5, 5),
-							 RANGE(-2.5, 2.5),
-							 RANGE(-1, 1),
-							 RANGE(-0.5, 0.5),
-							 RANGE(-0.25, 0.25),
-							 RANGE(-0.1, 0.1),
-							 RANGE(-0.05, 0.05),
-							 RANGE(0, 20),
-							 RANGE(0, 10),
-							 RANGE(0, 5),
-							 RANGE(0, 2),
-							 RANGE(0, 1),
-							 RANGE(0, 0.5),
-							 RANGE(0, 0.2),
-							 RANGE(0, 0.1),
-							 }
+static const struct comedi_lrange range_ni_E_ai = {
+	16, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1),
+		BIP_RANGE(0.5),
+		BIP_RANGE(0.25),
+		BIP_RANGE(0.1),
+		BIP_RANGE(0.05),
+		UNI_RANGE(20),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2),
+		UNI_RANGE(1),
+		UNI_RANGE(0.5),
+		UNI_RANGE(0.2),
+		UNI_RANGE(0.1)
+	}
 };
 
-static const struct comedi_lrange range_ni_E_ai_limited = { 8, {
-								RANGE(-10, 10),
-								RANGE(-5, 5),
-								RANGE(-1, 1),
-								RANGE(-0.1,
-								      0.1),
-								RANGE(0, 10),
-								RANGE(0, 5),
-								RANGE(0, 1),
-								RANGE(0, 0.1),
-								}
+static const struct comedi_lrange range_ni_E_ai_limited = {
+	8, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(1),
+		BIP_RANGE(0.1),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(1),
+		UNI_RANGE(0.1)
+	}
 };
 
-static const struct comedi_lrange range_ni_E_ai_limited14 = { 14, {
-								   RANGE(-10,
-									 10),
-								   RANGE(-5, 5),
-								   RANGE(-2, 2),
-								   RANGE(-1, 1),
-								   RANGE(-0.5,
-									 0.5),
-								   RANGE(-0.2,
-									 0.2),
-								   RANGE(-0.1,
-									 0.1),
-								   RANGE(0, 10),
-								   RANGE(0, 5),
-								   RANGE(0, 2),
-								   RANGE(0, 1),
-								   RANGE(0,
-									 0.5),
-								   RANGE(0,
-									 0.2),
-								   RANGE(0,
-									 0.1),
-								   }
+static const struct comedi_lrange range_ni_E_ai_limited14 = {
+	14, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2),
+		BIP_RANGE(1),
+		BIP_RANGE(0.5),
+		BIP_RANGE(0.2),
+		BIP_RANGE(0.1),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2),
+		UNI_RANGE(1),
+		UNI_RANGE(0.5),
+		UNI_RANGE(0.2),
+		UNI_RANGE(0.1)
+	}
 };
 
-static const struct comedi_lrange range_ni_E_ai_bipolar4 = { 4, {
-								 RANGE(-10, 10),
-								 RANGE(-5, 5),
-								 RANGE(-0.5,
-								       0.5),
-								 RANGE(-0.05,
-								       0.05),
-								 }
+static const struct comedi_lrange range_ni_E_ai_bipolar4 = {
+	4, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(0.5),
+		BIP_RANGE(0.05)
+	}
 };
 
-static const struct comedi_lrange range_ni_E_ai_611x = { 8, {
-							     RANGE(-50, 50),
-							     RANGE(-20, 20),
-							     RANGE(-10, 10),
-							     RANGE(-5, 5),
-							     RANGE(-2, 2),
-							     RANGE(-1, 1),
-							     RANGE(-0.5, 0.5),
-							     RANGE(-0.2, 0.2),
-							     }
+static const struct comedi_lrange range_ni_E_ai_611x = {
+	8, {
+		BIP_RANGE(50),
+		BIP_RANGE(20),
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2),
+		BIP_RANGE(1),
+		BIP_RANGE(0.5),
+		BIP_RANGE(0.2)
+	}
 };
 
-static const struct comedi_lrange range_ni_M_ai_622x = { 4, {
-							     RANGE(-10, 10),
-							     RANGE(-5, 5),
-							     RANGE(-1, 1),
-							     RANGE(-0.2, 0.2),
-							     }
+static const struct comedi_lrange range_ni_M_ai_622x = {
+	4, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(1),
+		BIP_RANGE(0.2)
+	}
 };
 
-static const struct comedi_lrange range_ni_M_ai_628x = { 7, {
-							     RANGE(-10, 10),
-							     RANGE(-5, 5),
-							     RANGE(-2, 2),
-							     RANGE(-1, 1),
-							     RANGE(-0.5, 0.5),
-							     RANGE(-0.2, 0.2),
-							     RANGE(-0.1, 0.1),
-							     }
+static const struct comedi_lrange range_ni_M_ai_628x = {
+	7, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2),
+		BIP_RANGE(1),
+		BIP_RANGE(0.5),
+		BIP_RANGE(0.2),
+		BIP_RANGE(0.1)
+	}
 };
 
-static const struct comedi_lrange range_ni_E_ao_ext = { 4, {
-							    RANGE(-10, 10),
-							    RANGE(0, 10),
-							    RANGE_ext(-1, 1),
-							    RANGE_ext(0, 1),
-							    }
+static const struct comedi_lrange range_ni_E_ao_ext = {
+	4, {
+		BIP_RANGE(10),
+		UNI_RANGE(10),
+		RANGE_ext(-1, 1),
+		RANGE_ext(0, 1)
+	}
 };
 
 static const struct comedi_lrange *const ni_range_lkup[] = {

commit d8e1f9619b039fab3405add5cc66d8916b7f7194
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:35 2013 -0700

    staging: comedi: ni_mio_common: remove DEBUG_INTERRUPT messages
    
    Defining DEBUG_INTERRUPT enables some function trace messages  during the
    interrupt. These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2ca37b611a91..65db6add0a68 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -52,8 +52,6 @@
 		fully tested as yet. Terry Barnaby, BEAM Ltd.
 */
 
-/* #define DEBUG_INTERRUPT */
-
 #include <linux/interrupt.h>
 #include <linux/sched.h>
 #include <linux/delay.h>
@@ -1029,11 +1027,6 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	if (s->type == COMEDI_SUBD_UNUSED)
 		return;
 
-#ifdef DEBUG_INTERRUPT
-	printk
-	    ("ni_mio_common: interrupt: a_status=%04x ai_mite_status=%08x\n",
-	     status, ai_mite_status);
-#endif
 #ifdef PCIDMA
 	if (ai_mite_status & CHSR_LINKC) {
 		ni_sync_ai_dma(dev);
@@ -1081,9 +1074,6 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			return;
 		}
 		if (status & AI_SC_TC_St) {
-#ifdef DEBUG_INTERRUPT
-			printk("ni_mio_common: SC_TC interrupt\n");
-#endif
 			if (!devpriv->ai_continuous) {
 				shutdown_ai_command(dev);
 			}
@@ -1110,15 +1100,6 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	}
 
 	ni_event(dev, s);
-
-#ifdef DEBUG_INTERRUPT
-	status = devpriv->stc_readw(dev, AI_Status_1_Register);
-	if (status & Interrupt_A_St) {
-		printk
-		    ("handle_a_interrupt: didn't clear interrupt? status=0x%x\n",
-		     status);
-	}
-#endif
 }
 
 static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
@@ -1158,11 +1139,6 @@ static void handle_b_interrupt(struct comedi_device *dev,
 	struct comedi_subdevice *s = &dev->subdevices[NI_AO_SUBDEV];
 	/* unsigned short ack=0; */
 
-#ifdef DEBUG_INTERRUPT
-	printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
-	       b_status, ao_mite_status);
-#endif
-
 #ifdef PCIDMA
 	/* Currently, mite.c requires us to handle LINKC */
 	if (ao_mite_status & CHSR_LINKC) {

commit 957a91418669d84de66f72f470972073992d6d7b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:34 2013 -0700

    staging: comedi: ni_mio_common: remove DEBUG_STATUS_A messages
    
    Defining DEBUG_STATUS_A enables dumping of a status register during the
    interrupt. These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 1ae8f97f07f2..2ca37b611a91 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -53,7 +53,6 @@
 */
 
 /* #define DEBUG_INTERRUPT */
-/* #define DEBUG_STATUS_A */
 
 #include <linux/interrupt.h>
 #include <linux/sched.h>
@@ -261,12 +260,6 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ni_read_eeprom(struct comedi_device *dev, int addr);
 
-#ifdef DEBUG_STATUS_A
-static void ni_mio_print_status_a(int status);
-#else
-#define ni_mio_print_status_a(a)
-#endif
-
 static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s);
 #ifndef PCIDMA
 static void ni_handle_fifo_half_full(struct comedi_device *dev);
@@ -1040,7 +1033,6 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	printk
 	    ("ni_mio_common: interrupt: a_status=%04x ai_mite_status=%08x\n",
 	     status, ai_mite_status);
-	ni_mio_print_status_a(status);
 #endif
 #ifdef PCIDMA
 	if (ai_mite_status & CHSR_LINKC) {
@@ -1077,7 +1069,6 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			      AI_SC_TC_Error_St)) {
 			printk("ni_mio_common: ai error a_status=%04x\n",
 			       status);
-			ni_mio_print_status_a(status);
 
 			shutdown_ai_command(dev);
 
@@ -1218,28 +1209,6 @@ static void handle_b_interrupt(struct comedi_device *dev,
 	ni_event(dev, s);
 }
 
-#ifdef DEBUG_STATUS_A
-static const char *const status_a_strings[] = {
-	"passthru0", "fifo", "G0_gate", "G0_TC",
-	"stop", "start", "sc_tc", "start1",
-	"start2", "sc_tc_error", "overflow", "overrun",
-	"fifo_empty", "fifo_half_full", "fifo_full", "interrupt_a"
-};
-
-static void ni_mio_print_status_a(int status)
-{
-	int i;
-
-	printk("A status:");
-	for (i = 15; i >= 0; i--) {
-		if (status & (1 << i)) {
-			printk(" %s", status_a_strings[i]);
-		}
-	}
-	printk("\n");
-}
-#endif
-
 #ifndef PCIDMA
 
 static void ni_ao_fifo_load(struct comedi_device *dev,

commit 9af01ca9b91e142958f1f20bee68c272e7ac0ccd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:33 2013 -0700

    staging: comedi: ni_mio_common: remove DEBUG_STATUS_B messages
    
    Defining DEBUG_STATUS_B enables dumping of a status register during the
    interrupt. These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 4bf0ef2b93d7..1ae8f97f07f2 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -54,7 +54,6 @@
 
 /* #define DEBUG_INTERRUPT */
 /* #define DEBUG_STATUS_A */
-/* #define DEBUG_STATUS_B */
 
 #include <linux/interrupt.h>
 #include <linux/sched.h>
@@ -267,11 +266,6 @@ static void ni_mio_print_status_a(int status);
 #else
 #define ni_mio_print_status_a(a)
 #endif
-#ifdef DEBUG_STATUS_B
-static void ni_mio_print_status_b(int status);
-#else
-#define ni_mio_print_status_b(a)
-#endif
 
 static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s);
 #ifndef PCIDMA
@@ -1176,7 +1170,6 @@ static void handle_b_interrupt(struct comedi_device *dev,
 #ifdef DEBUG_INTERRUPT
 	printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
 	       b_status, ao_mite_status);
-	ni_mio_print_status_b(b_status);
 #endif
 
 #ifdef PCIDMA
@@ -1247,28 +1240,6 @@ static void ni_mio_print_status_a(int status)
 }
 #endif
 
-#ifdef DEBUG_STATUS_B
-static const char *const status_b_strings[] = {
-	"passthru1", "fifo", "G1_gate", "G1_TC",
-	"UI2_TC", "UPDATE", "UC_TC", "BC_TC",
-	"start1", "overrun", "start", "bc_tc_error",
-	"fifo_empty", "fifo_half_full", "fifo_full", "interrupt_b"
-};
-
-static void ni_mio_print_status_b(int status)
-{
-	int i;
-
-	printk("B status:");
-	for (i = 15; i >= 0; i--) {
-		if (status & (1 << i)) {
-			printk(" %s", status_b_strings[i]);
-		}
-	}
-	printk("\n");
-}
-#endif
-
 #ifndef PCIDMA
 
 static void ni_ao_fifo_load(struct comedi_device *dev,

commit 9d6a0f6abe05ee1f7d98adcb06758a0d121bc69a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:32 2013 -0700

    staging: comedi: ni_mio_common: remove DEBUG_DIO messages
    
    Defining DEBUG_DIO simply enables some function trace messages. These are
    just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index f44013c8097b..4bf0ef2b93d7 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3798,10 +3798,6 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 
 	switch (data[0]) {
 	case INSN_CONFIG_SERIAL_CLOCK:
-
-#ifdef DEBUG_DIO
-		printk("SPI serial clock Config cd\n", data[1]);
-#endif
 		devpriv->serial_hw_mode = 1;
 		devpriv->dio_control |= DIO_HW_Serial_Enable;
 
@@ -3890,10 +3886,6 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 	unsigned int status1;
 	int err = 0, count = 20;
 
-#ifdef DEBUG_DIO
-	printk("ni_serial_hw_readwrite8: outputting 0x%x\n", data_out);
-#endif
-
 	devpriv->dio_output &= ~DIO_Serial_Data_Mask;
 	devpriv->dio_output |= DIO_Serial_Data_Out(data_out);
 	devpriv->stc_writew(dev, devpriv->dio_output, DIO_Output_Register);
@@ -3927,12 +3919,8 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 	   DIO_Serial_IO_In_Progress_St goes high one bit too early. */
 	udelay((devpriv->serial_interval_ns + 999) / 1000);
 
-	if (data_in != NULL) {
+	if (data_in != NULL)
 		*data_in = devpriv->stc_readw(dev, DIO_Serial_Input_Register);
-#ifdef DEBUG_DIO
-		printk("ni_serial_hw_readwrite8: inputted 0x%x\n", *data_in);
-#endif
-	}
 
 Error:
 	devpriv->stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
@@ -3948,10 +3936,6 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 	struct ni_private *devpriv = dev->private;
 	unsigned char mask, input = 0;
 
-#ifdef DEBUG_DIO
-	printk("ni_serial_sw_readwrite8: outputting 0x%x\n", data_out);
-#endif
-
 	/* Wait for one bit before transfer */
 	udelay((devpriv->serial_interval_ns + 999) / 1000);
 
@@ -3988,9 +3972,7 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 			input |= mask;
 		}
 	}
-#ifdef DEBUG_DIO
-	printk("ni_serial_sw_readwrite8: inputted 0x%x\n", input);
-#endif
+
 	if (data_in)
 		*data_in = input;
 

commit d316d2aba099b455c30894eb78344e59b23a1367
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:31 2013 -0700

    staging: comedi: ni_mio_common: remove unused NI_CS5529_DEBUG code
    
    The code blocked by #ifdef NI_CS5529_DEBUG is not used by the driver.
    Just remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 866e99394b0c..f44013c8097b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -318,10 +318,6 @@ static int cs5529_do_conversion(struct comedi_device *dev,
 static int cs5529_ai_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data);
-#ifdef NI_CS5529_DEBUG
-static unsigned int cs5529_config_read(struct comedi_device *dev,
-				       unsigned int reg_select_bits);
-#endif
 static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
 				unsigned int reg_select_bits);
 
@@ -5856,25 +5852,6 @@ static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
 		comedi_error(dev, "time or signal in cs5529_config_write()");
 }
 
-#ifdef NI_CS5529_DEBUG
-/* read from cs5529 register */
-static unsigned int cs5529_config_read(struct comedi_device *dev,
-				       unsigned int reg_select_bits)
-{
-	unsigned int value;
-
-	reg_select_bits &= CSCMD_REGISTER_SELECT_MASK;
-	cs5529_command(dev, CSCMD_COMMAND | CSCMD_READ | reg_select_bits);
-	if (cs5529_wait_for_idle(dev))
-		comedi_error(dev, "timeout or signal in cs5529_config_read()");
-	value = (ni_ao_win_inw(dev,
-			       CAL_ADC_Config_Data_High_Word_67xx) << 16) &
-	    0xff0000;
-	value |= ni_ao_win_inw(dev, CAL_ADC_Config_Data_Low_Word_67xx) & 0xffff;
-	return value;
-}
-#endif
-
 static int cs5529_do_conversion(struct comedi_device *dev, unsigned short *data)
 {
 	int retval;
@@ -5950,13 +5927,6 @@ static int init_cs5529(struct comedi_device *dev)
 			    CSCMD_CONFIG_REGISTER);
 	if (cs5529_wait_for_idle(dev))
 		comedi_error(dev, "timeout or signal in init_cs5529()\n");
-#endif
-#ifdef NI_CS5529_DEBUG
-	printk("config: 0x%x\n", cs5529_config_read(dev,
-						    CSCMD_CONFIG_REGISTER));
-	printk("gain: 0x%x\n", cs5529_config_read(dev, CSCMD_GAIN_REGISTER));
-	printk("offset: 0x%x\n", cs5529_config_read(dev,
-						    CSCMD_OFFSET_REGISTER));
 #endif
 	return 0;
 }

commit 096669a8301478641abf16bbc02db786e26165bd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:17 2013 -0700

    staging: comedi: mite: remove DEBUG_MITE code
    
    The code protected by the DEBUG_MITE define outputs some development
    debug information. This information is just added noise in the final
    driver. Remove the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 058185292b0d..866e99394b0c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1063,7 +1063,6 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 		printk
 		    ("unknown mite interrupt, ack! (ai_mite_status=%08x)\n",
 		     ai_mite_status);
-		/* mite_print_chsr(ai_mite_status); */
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		/* disable_irq(dev->irq); */
 	}
@@ -1196,7 +1195,6 @@ static void handle_b_interrupt(struct comedi_device *dev,
 		printk
 		    ("unknown mite interrupt, ack! (ao_mite_status=%08x)\n",
 		     ao_mite_status);
-		/* mite_print_chsr(ao_mite_status); */
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
 #endif
@@ -2652,7 +2650,6 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		if (retval)
 			return retval;
 	}
-	/* mite_dump_regs(devpriv->mite); */
 #endif
 
 	switch (cmd->start_src) {

commit a7866a6ef70f657a54bbdfc2bd19fd8b70f72fd3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:16 2013 -0700

    staging: comedi: mite: remove MDPRINTK macro
    
    This macro is used by the comedi drivers that usee the mite module to
    output development function trace messages. These are just added noise.
    Remove the messages as well as the macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5113397bfecf..058185292b0d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -63,10 +63,6 @@
 #include "mite.h"
 #include "comedi_fc.h"
 
-#ifndef MDPRINTK
-#define MDPRINTK(format, args...)
-#endif
-
 /* A timeout count */
 #define NI_TIMEOUT 1000
 static const unsigned old_RTSI_clock_channel = 7;
@@ -1214,12 +1210,9 @@ static void handle_b_interrupt(struct comedi_device *dev,
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 
-	if (b_status & AO_BC_TC_St) {
-		MDPRINTK
-		    ("ni_mio_common: AO BC_TC status=0x%04x status2=0x%04x\n",
-		     b_status, devpriv->stc_readw(dev, AO_Status_2_Register));
+	if (b_status & AO_BC_TC_St)
 		s->async->events |= COMEDI_CB_EOA;
-	}
+
 #ifndef PCIDMA
 	if (b_status & AO_FIFO_Request_St) {
 		int ret;
@@ -2392,7 +2385,6 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned int stop_count;
 	int interrupt_a_enable = 0;
 
-	MDPRINTK("ni_ai_cmd\n");
 	if (dev->irq == 0) {
 		comedi_error(dev, "cannot run command without an irq");
 		return -EIO;
@@ -2630,15 +2622,11 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		ni_set_bits(dev, Interrupt_A_Enable_Register,
 			    interrupt_a_enable, 1);
-
-		MDPRINTK("Interrupt_A_Enable_Register = 0x%04x\n",
-			 devpriv->int_a_enable_reg);
 	} else {
 		/* interrupt on nothing */
 		ni_set_bits(dev, Interrupt_A_Enable_Register, ~0, 0);
 
 		/* XXX start polling if necessary */
-		MDPRINTK("interrupting on nothing\n");
 	}
 
 	/* end configuration */
@@ -2682,8 +2670,6 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	}
 
-	MDPRINTK("exit ni_ai_cmd\n");
-
 	return 0;
 }
 

commit 3a2b101cc5fbba7f6fbb7c2e19478c884d00c730
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:26 2013 +0100

    staging: comedi: ni_mio_common: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Change the element type of the `ai_fifo_buffer[]` element of `struct
    ni_board_struct` and the types of various local variables from `short`
    to `unsigned short` for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b9df2eeae6fb..5113397bfecf 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1292,7 +1292,7 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 	struct comedi_cmd *cmd = &async->cmd;
 	int chan;
 	int i;
-	short d;
+	unsigned short d;
 	u32 packed_data;
 	int range;
 	int err = 1;
@@ -1403,7 +1403,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 	int i;
 
 	if (board->reg_type == ni_reg_611x) {
-		short data[2];
+		unsigned short data[2];
 		u32 dl;
 
 		for (i = 0; i < n / 2; i++) {
@@ -1420,7 +1420,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 			cfc_write_to_buffer(s, data[0]);
 		}
 	} else if (board->reg_type == ni_reg_6143) {
-		short data[2];
+		unsigned short data[2];
 		u32 dl;
 
 		/*  This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed */
@@ -1511,9 +1511,9 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
-	short data[2];
+	unsigned short data[2];
 	u32 dl;
-	short fifo_empty;
+	unsigned short fifo_empty;
 	int i;
 
 	if (board->reg_type == ni_reg_611x) {
@@ -1577,7 +1577,7 @@ static void get_last_sample_611x(struct comedi_device *dev)
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv __maybe_unused = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
-	short data;
+	unsigned short data;
 	u32 dl;
 
 	if (board->reg_type != ni_reg_611x)
@@ -1596,7 +1596,7 @@ static void get_last_sample_6143(struct comedi_device *dev)
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv __maybe_unused = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
-	short data;
+	unsigned short data;
 	u32 dl;
 
 	if (board->reg_type != ni_reg_6143)
@@ -1621,7 +1621,7 @@ static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	struct comedi_async *async = s->async;
 	unsigned int i;
 	unsigned int length = num_bytes / bytes_per_sample(s);
-	short *array = data;
+	unsigned short *array = data;
 	unsigned int *larray = data;
 
 	for (i = 0; i < length; i++) {
@@ -2873,7 +2873,7 @@ static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int i;
 	unsigned int offset;
 	unsigned int length = num_bytes / sizeof(short);
-	short *array = data;
+	unsigned short *array = data;
 
 	offset = 1 << (board->aobits - 1);
 	for (i = 0; i < length; i++) {

commit 6171667a81fd650082c83df1d417e152686483ab
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:06:38 2013 -0700

    staging: comedi: ni_mio_common: use comedi_dio_update_state()
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state.
    
    Remove the DEBUG_DIO, its just added noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 4e02770e834b..b9df2eeae6fb 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3547,28 +3547,22 @@ static int ni_dio_insn_config(struct comedi_device *dev,
 
 static int ni_dio_insn_bits(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+			    struct comedi_insn *insn,
+			    unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
 
-#ifdef DEBUG_DIO
-	printk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);
-#endif
-
-	if (data[0]) {
-		/* Perform check to make sure we're not using the
-		   serial part of the dio */
-		if ((data[0] & (DIO_SDIN | DIO_SDOUT))
-		    && devpriv->serial_interval_ns)
-			return -EBUSY;
+	/* Make sure we're not using the serial part of the dio */
+	if ((data[0] & (DIO_SDIN | DIO_SDOUT)) && devpriv->serial_interval_ns)
+		return -EBUSY;
 
-		s->state &= ~data[0];
-		s->state |= (data[0] & data[1]);
+	if (comedi_dio_update_state(s, data)) {
 		devpriv->dio_output &= ~DIO_Parallel_Data_Mask;
 		devpriv->dio_output |= DIO_Parallel_Data_Out(s->state);
 		devpriv->stc_writew(dev, devpriv->dio_output,
 				    DIO_Output_Register);
 	}
+
 	data[1] = devpriv->stc_readw(dev, DIO_Parallel_Input_Register);
 
 	return insn->n;
@@ -3598,16 +3592,9 @@ static int ni_m_series_dio_insn_bits(struct comedi_device *dev,
 {
 	struct ni_private *devpriv __maybe_unused = dev->private;
 
-#ifdef DEBUG_DIO
-	printk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],
-	       data[1]);
-#endif
-
-	if (data[0]) {
-		s->state &= ~data[0];
-		s->state |= (data[0] & data[1]);
+	if (comedi_dio_update_state(s, data))
 		ni_writel(s->state, M_Offset_Static_Digital_Output);
-	}
+
 	data[1] = ni_readl(M_Offset_Static_Digital_Input);
 
 	return insn->n;
@@ -5355,20 +5342,20 @@ static int ni_config_filter(struct comedi_device *dev, unsigned pfi_channel,
 
 static int ni_pfi_insn_bits(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+			    struct comedi_insn *insn,
+			    unsigned int *data)
 {
 	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv __maybe_unused = dev->private;
 
-	if ((board->reg_type & ni_reg_m_series_mask) == 0) {
+	if (!(board->reg_type & ni_reg_m_series_mask))
 		return -ENOTSUPP;
-	}
-	if (data[0]) {
-		s->state &= ~data[0];
-		s->state |= (data[0] & data[1]);
+
+	if (comedi_dio_update_state(s, data))
 		ni_writew(s->state, M_Offset_PFI_DO);
-	}
+
 	data[1] = ni_readw(M_Offset_PFI_DI);
+
 	return insn->n;
 }
 

commit ddf62f2c7bd041d35095b525ab33e3a3e0829aaa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 6 09:32:33 2013 -0700

    staging: comedi: drivers: use comedi_dio_insn_config() for simple cases
    
    Convert the drivers with simple, per channel programmable i/o, to use the
    comedi_dio_insn_config() helper function.
    
    All of these pass a 'mask' of '0' to comedi_dio_insn_config() this causes
    the per channel mask to be used to configure the i/o direction.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 04f4b7dce332..4e02770e834b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3528,37 +3528,21 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int ni_dio_insn_config(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
 	struct ni_private *devpriv = dev->private;
+	int ret;
 
-#ifdef DEBUG_DIO
-	printk("ni_dio_insn_config() chan=%d io=%d\n",
-	       CR_CHAN(insn->chanspec), data[0]);
-#endif
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_OUTPUT:
-		s->io_bits |= 1 << CR_CHAN(insn->chanspec);
-		break;
-	case INSN_CONFIG_DIO_INPUT:
-		s->io_bits &= ~(1 << CR_CHAN(insn->chanspec));
-		break;
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] =
-		    (s->
-		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
-		    COMEDI_INPUT;
-		return insn->n;
-		break;
-	default:
-		return -EINVAL;
-	}
+	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
+	if (ret)
+		return ret;
 
 	devpriv->dio_control &= ~DIO_Pins_Dir_Mask;
 	devpriv->dio_control |= DIO_Pins_Dir(s->io_bits);
 	devpriv->stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
 
-	return 1;
+	return insn->n;
 }
 
 static int ni_dio_insn_bits(struct comedi_device *dev,
@@ -3596,32 +3580,15 @@ static int ni_m_series_dio_insn_config(struct comedi_device *dev,
 				       unsigned int *data)
 {
 	struct ni_private *devpriv __maybe_unused = dev->private;
+	int ret;
 
-#ifdef DEBUG_DIO
-	printk("ni_m_series_dio_insn_config() chan=%d io=%d\n",
-	       CR_CHAN(insn->chanspec), data[0]);
-#endif
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_OUTPUT:
-		s->io_bits |= 1 << CR_CHAN(insn->chanspec);
-		break;
-	case INSN_CONFIG_DIO_INPUT:
-		s->io_bits &= ~(1 << CR_CHAN(insn->chanspec));
-		break;
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] =
-		    (s->
-		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
-		    COMEDI_INPUT;
-		return insn->n;
-		break;
-	default:
-		return -EINVAL;
-	}
+	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
+	if (ret)
+		return ret;
 
 	ni_writel(s->io_bits, M_Offset_DIO_Direction);
 
-	return 1;
+	return insn->n;
 }
 
 static int ni_m_series_dio_insn_bits(struct comedi_device *dev,

commit 305591a58d855d0f82a582059596124f9a3503c2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 09:55:00 2013 -0700

    staging: comedi: ni_mio_common: needs <linux/delay.h>
    
    As reported by the kbuild test robot:
    
    Commit: d92fef8d2552ffde42b6092cb467f3021ebf8b98
    staging: comedi: do not include <linux/delay.h> if its not needed
    
    Removed the include from the ni_atmio driver, which did not need it.
    Unfortunately, this driver includes ni_mio_common.c, which does need
    it.
    
    Add the include of <linux/delay.h> to the ni_mio_common.c source
    where it is needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 458331d3fcb7..04f4b7dce332 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -58,6 +58,7 @@
 
 #include <linux/interrupt.h>
 #include <linux/sched.h>
+#include <linux/delay.h>
 #include "8255.h"
 #include "mite.h"
 #include "comedi_fc.h"

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 3e9f544e67fc..458331d3fcb7 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4363,10 +4363,9 @@ static int ni_alloc_private(struct comedi_device *dev)
 {
 	struct ni_private *devpriv;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	spin_lock_init(&devpriv->window_lock);
 	spin_lock_init(&devpriv->soft_reg_copy_lock);

commit 588ba6dc5fb4bdca47a3da38c2718fbb82d3eee1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 11 11:32:29 2013 -0700

    staging: comedi: drivers: let core handle freeing s->private
    
    Introduce a new subdevice runflags, SRF_FREE_SPRIV, and a new helper
    function, comedi_set_spriv(), that the drivers can use to set the
    comedi_subdevice private data pointer. The helper function will also
    set SRF_FREE_SPRIV to allow the comedi core to automatically free the
    subdevice private data during the cleanup_device() stage of the detach.
    
    Currently s->private is only allocated by the 8255, addi_watchdog,
    amplc_dio200_common, and ni_65xx drivers. All users of those drivers
    can then have the comedi_spriv_free() calls removed and in many cases
    the (*detach) can then simply be the appropriate comedi core provided
    function.
    
    The ni_65xx driver uses a helper function, ni_65xx_alloc_subdevice_private(),
    to allocate the private data. Refactor the function to return an errno
    or call comedi_set_spriv() instead of returning a pointer to the private
    data and requiring the caller to handle it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 1e78198a2253..3e9f544e67fc 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4072,7 +4072,6 @@ static void mio_common_detach(struct comedi_device *dev)
 			ni_gpct_device_destroy(devpriv->counter_dev);
 		}
 	}
-	comedi_spriv_free(dev, NI_8255_DIO_SUBDEV);
 }
 
 static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)

commit 829455bb0e994373519e3c58d403fc1148f44630
Merge: 42b4212baa28 e4aa937ec75d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 27 10:54:33 2013 +0900

    Merge 3.10-rc3 into staging-next
    
    We want the changes here, and we resolve the merge conflict that was
    happening in the nvec_kbd.c file.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bd304a736afd99cc38bad4d1628e8e2d05d308d5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 10 14:07:17 2013 +0100

    staging: comedi: ni_mio_common: only do counter commands for ni_pcimio
    
    "ni_mio_common.c" holds common code included by "ni_pcimio.c",
    "ni_atmio.c" and "ni_mio_cs.c", including a common initialization
    function `ni_E_init()`.  Amongst other things, this initializes some
    counter subdevices to support comedi instructions and asynchronous
    commands.  However, even though it sets up the handlers to support
    asynchronous commands on these subdevices, the handlers will return an
    error unless the `PCIDMA` macro is defined (which is defined only in
    "ni_pcimio.c").  If the `PCIDMA` macro is not defined, the comedi core
    will needlessly allocate buffers to support the asynchronous commands.
    Also, `s->async_dma_dir` is set to `DMA_BIDIRECTIONAL`, causing the
    physical pages for the buffers to be allocated using
    `dma_alloc_coherent()`.
    
    If the comedi core cannot call `dma_alloc_coherent()` because
    `CONFIG_HAS_DMA` is not defined, it will fail to allocate the buffers,
    which ultimately causes `ni_E_init()` to fail.
    
    Avoid the wastage and prevent the failure by only setting up
    asynchronous command support for the counter subdevices if the `PCIDMA`
    macro is defined.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a46d579016d9..8c5dee9b3b05 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -310,9 +310,11 @@ static int ni_gpct_insn_read(struct comedi_device *dev,
 static int ni_gpct_insn_config(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data);
+#ifdef PCIDMA
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ni_gpct_cmdtest(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_cmd *cmd);
+#endif
 static int ni_gpct_cancel(struct comedi_device *dev,
 			  struct comedi_subdevice *s);
 static void handle_gpct_interrupt(struct comedi_device *dev,
@@ -4617,9 +4619,7 @@ static int ni_E_init(struct comedi_device *dev)
 	for (j = 0; j < NUM_GPCT; ++j) {
 		s = &dev->subdevices[NI_GPCT_SUBDEV(j)];
 		s->type = COMEDI_SUBD_COUNTER;
-		s->subdev_flags =
-		    SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL | SDF_CMD_READ
-		    /* | SDF_CMD_WRITE */ ;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
 		s->n_chan = 3;
 		if (board->reg_type & ni_reg_m_series_mask)
 			s->maxdata = 0xffffffff;
@@ -4628,11 +4628,14 @@ static int ni_E_init(struct comedi_device *dev)
 		s->insn_read = &ni_gpct_insn_read;
 		s->insn_write = &ni_gpct_insn_write;
 		s->insn_config = &ni_gpct_insn_config;
+#ifdef PCIDMA
+		s->subdev_flags |= SDF_CMD_READ /* | SDF_CMD_WRITE */;
 		s->do_cmd = &ni_gpct_cmd;
 		s->len_chanlist = 1;
 		s->do_cmdtest = &ni_gpct_cmdtest;
 		s->cancel = &ni_gpct_cancel;
 		s->async_dma_dir = DMA_BIDIRECTIONAL;
+#endif
 		s->private = &devpriv->counter_dev->counters[j];
 
 		devpriv->counter_dev->counters[j].chip_index = 0;
@@ -5216,10 +5219,10 @@ static int ni_gpct_insn_write(struct comedi_device *dev,
 	return ni_tio_winsn(counter, insn, data);
 }
 
+#ifdef PCIDMA
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int retval;
-#ifdef PCIDMA
 	struct ni_gpct *counter = s->private;
 /* const struct comedi_cmd *cmd = &s->async->cmd; */
 
@@ -5233,23 +5236,20 @@ static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);
 	ni_e_series_enable_second_irq(dev, counter->counter_index, 1);
 	retval = ni_tio_cmd(counter, s->async);
-#else
-	retval = -ENOTSUPP;
-#endif
 	return retval;
 }
+#endif
 
+#ifdef PCIDMA
 static int ni_gpct_cmdtest(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-#ifdef PCIDMA
 	struct ni_gpct *counter = s->private;
 
 	return ni_tio_cmdtest(counter, cmd);
-#else
 	return -ENOTSUPP;
-#endif
 }
+#endif
 
 static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a46d579016d9..f76339180118 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -15,11 +15,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
 */
 
 /*

commit 2f69915c728c3be41e12dbbbdd4eeb8d3388d58c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 15 16:41:57 2013 -0700

    staging: comedi: introduce, and use, comedi_spriv_free()
    
    The comedi_subdevice 'private' variable is a void * that is available
    for the subdevice to use in manner. It's common in comedi drivers for
    the driver to allocate memory for a subdevice and store the pointer
    to that memory in the 'private' variable. It's then the responsibility
    of the driver to free that memory when the device is detached.
    
    Due to how the attach/detach works in comedi, the drivers need to do
    some sanity checking before they can free the allocated memory during
    the detach.
    
    Introduce a helper function, comedi_spriv_free(), to handle freeing
    the private data allocated for a subdevice. This allows moving all the
    sanity checks into the helper function and makes it safe to call
    with any context. It also allows removing some of the boilerplate
    code in the (*detach) functions.
    
    Remove the subdev_8255_cleanup() export in the 8255 subdevice driver
    as well as the addi_watchdog_cleanup() export in the addi_watchdog
    driver and use the new helper instead.
    
    The amplc_dio200_common driver uses a number of local helper functions
    to free the private data for it's subdevices. Remove those as well and
    use the new helper.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0f8d05c35391..a46d579016d9 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4068,19 +4068,14 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 
 static void mio_common_detach(struct comedi_device *dev)
 {
-	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
-	struct comedi_subdevice *s;
 
 	if (devpriv) {
 		if (devpriv->counter_dev) {
 			ni_gpct_device_destroy(devpriv->counter_dev);
 		}
 	}
-	if (dev->subdevices && board->has_8255) {
-		s = &dev->subdevices[NI_8255_DIO_SUBDEV];
-		subdev_8255_cleanup(dev, s);
-	}
+	comedi_spriv_free(dev, NI_8255_DIO_SUBDEV);
 }
 
 static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)

commit 50708d98ce620a989e5dc3be6594826649b65961
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 3 13:39:34 2013 -0700

    staging: comedi: ni_mio_common: use comedi provided range_bipolar5
    
    Remove the private range, range_ni_S_ai_6143, in this driver and use
    the comedi provided range_bipolar5 instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ca52b759fb9e..0f8d05c35391 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -189,11 +189,6 @@ static const struct comedi_lrange range_ni_M_ai_628x = { 7, {
 							     }
 };
 
-static const struct comedi_lrange range_ni_S_ai_6143 = { 1, {
-							     RANGE(-5, +5),
-							     }
-};
-
 static const struct comedi_lrange range_ni_E_ao_ext = { 4, {
 							    RANGE(-10, 10),
 							    RANGE(0, 10),
@@ -210,7 +205,7 @@ static const struct comedi_lrange *const ni_range_lkup[] = {
 	[ai_gain_611x] = &range_ni_E_ai_611x,
 	[ai_gain_622x] = &range_ni_M_ai_622x,
 	[ai_gain_628x] = &range_ni_M_ai_628x,
-	[ai_gain_6143] = &range_ni_S_ai_6143
+	[ai_gain_6143] = &range_bipolar5
 };
 
 static int ni_dio_insn_config(struct comedi_device *dev,

commit a7401cddcdf739d3cb9598c9b3787a732fc87809
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:33 2013 +0000

    staging: comedi: make 'dev->attached' a bool bit-field
    
    Change the `attached` member of `struct comedi_device` to a 1-bit
    bit-field of type `bool`.  Change assigned values to `true` and `false`
    and replace or remove comparison operations with simple boolean tests.
    
    We'll put some extra bit-fields in the gap later to save space.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 208fa24295ae..ca52b759fb9e 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -847,7 +847,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 	struct mite_struct *mite = devpriv->mite;
 #endif
 
-	if (dev->attached == 0)
+	if (!dev->attached)
 		return IRQ_NONE;
 	smp_mb();		/*  make sure dev->attached is checked before handler does anything else. */
 

commit 6293e35742550320b1720044f9969d9544a5deaa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 10:20:41 2013 -0700

    staging: comedi: ni_stc.h: remove boardtype macro
    
    This macro relies on a local variable having a specific name and
    returns an object that variable points to. This object is the
    boardinfo used by the driver.
    
    The comedi core provides the comedi_board() helper to return a
    const pointer to the boardinfo. Remove the 'boardtype' macro and
    fix all the users of the 'boardtype' macro to use the comedi_board()
    helper to get the const boardinfo pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b7403597e905..208fa24295ae 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -696,9 +696,10 @@ static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 					  unsigned gpct_index, short enable)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
-	if (boardtype.reg_type & ni_reg_m_series_mask)
+	if (board->reg_type & ni_reg_m_series_mask)
 		return;
 	switch (gpct_index) {
 	case 0:
@@ -728,16 +729,17 @@ static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 
 static void ni_clear_ai_fifo(struct comedi_device *dev)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
-	if (boardtype.reg_type == ni_reg_6143) {
+	if (board->reg_type == ni_reg_6143) {
 		/*  Flush the 6143 data FIFO */
 		ni_writel(0x10, AIFIFO_Control_6143);	/*  Flush fifo */
 		ni_writel(0x00, AIFIFO_Control_6143);	/*  Flush fifo */
 		while (ni_readl(AIFIFO_Status_6143) & 0x10) ;	/*  Wait for complete */
 	} else {
 		devpriv->stc_writew(dev, 1, ADC_FIFO_Clear);
-		if (boardtype.reg_type == ni_reg_625x) {
+		if (board->reg_type == ni_reg_625x) {
 			ni_writeb(0, M_Offset_Static_AI_Control(0));
 			ni_writeb(1, M_Offset_Static_AI_Control(0));
 #if 0
@@ -1292,6 +1294,7 @@ static void ni_mio_print_status_b(int status)
 static void ni_ao_fifo_load(struct comedi_device *dev,
 			    struct comedi_subdevice *s, int n)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	int chan;
@@ -1309,10 +1312,10 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 
 		range = CR_RANGE(cmd->chanlist[chan]);
 
-		if (boardtype.reg_type & ni_reg_6xxx_mask) {
+		if (board->reg_type & ni_reg_6xxx_mask) {
 			packed_data = d & 0xffff;
 			/* 6711 only has 16 bit wide ao fifo */
-			if (boardtype.reg_type != ni_reg_6711) {
+			if (board->reg_type != ni_reg_6711) {
 				err &= comedi_buf_get(async, &d);
 				if (err == 0)
 					break;
@@ -1352,6 +1355,7 @@ static void ni_ao_fifo_load(struct comedi_device *dev,
 static int ni_ao_fifo_half_empty(struct comedi_device *dev,
 				 struct comedi_subdevice *s)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	int n;
 
 	n = comedi_buf_read_n_available(s->async);
@@ -1361,8 +1365,8 @@ static int ni_ao_fifo_half_empty(struct comedi_device *dev,
 	}
 
 	n /= sizeof(short);
-	if (n > boardtype.ao_fifo_depth / 2)
-		n = boardtype.ao_fifo_depth / 2;
+	if (n > board->ao_fifo_depth / 2)
+		n = board->ao_fifo_depth / 2;
 
 	ni_ao_fifo_load(dev, s, n);
 
@@ -1374,12 +1378,13 @@ static int ni_ao_fifo_half_empty(struct comedi_device *dev,
 static int ni_ao_prep_fifo(struct comedi_device *dev,
 			   struct comedi_subdevice *s)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	int n;
 
 	/* reset fifo */
 	devpriv->stc_writew(dev, 1, DAC_FIFO_Clear);
-	if (boardtype.reg_type & ni_reg_6xxx_mask)
+	if (board->reg_type & ni_reg_6xxx_mask)
 		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
 
 	/* load some data */
@@ -1388,8 +1393,8 @@ static int ni_ao_prep_fifo(struct comedi_device *dev,
 		return 0;
 
 	n /= sizeof(short);
-	if (n > boardtype.ao_fifo_depth)
-		n = boardtype.ao_fifo_depth;
+	if (n > board->ao_fifo_depth)
+		n = board->ao_fifo_depth;
 
 	ni_ao_fifo_load(dev, s, n);
 
@@ -1399,11 +1404,12 @@ static int ni_ao_prep_fifo(struct comedi_device *dev,
 static void ni_ai_fifo_read(struct comedi_device *dev,
 			    struct comedi_subdevice *s, int n)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	int i;
 
-	if (boardtype.reg_type == ni_reg_611x) {
+	if (board->reg_type == ni_reg_611x) {
 		short data[2];
 		u32 dl;
 
@@ -1420,7 +1426,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 			data[0] = dl & 0xffff;
 			cfc_write_to_buffer(s, data[0]);
 		}
-	} else if (boardtype.reg_type == ni_reg_6143) {
+	} else if (board->reg_type == ni_reg_6143) {
 		short data[2];
 		u32 dl;
 
@@ -1458,10 +1464,11 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 
 static void ni_handle_fifo_half_full(struct comedi_device *dev)
 {
-	int n;
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
+	int n;
 
-	n = boardtype.ai_fifo_depth / 2;
+	n = board->ai_fifo_depth / 2;
 
 	ni_ai_fifo_read(dev, s, n);
 }
@@ -1508,6 +1515,7 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 */
 static void ni_handle_fifo_dregs(struct comedi_device *dev)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	short data[2];
@@ -1515,7 +1523,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 	short fifo_empty;
 	int i;
 
-	if (boardtype.reg_type == ni_reg_611x) {
+	if (board->reg_type == ni_reg_611x) {
 		while ((devpriv->stc_readw(dev,
 					   AI_Status_1_Register) &
 			AI_FIFO_Empty_St) == 0) {
@@ -1526,7 +1534,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 			data[1] = (dl & 0xffff);
 			cfc_write_array_to_buffer(s, data, sizeof(data));
 		}
-	} else if (boardtype.reg_type == ni_reg_6143) {
+	} else if (board->reg_type == ni_reg_6143) {
 		i = 0;
 		while (ni_readl(AIFIFO_Status_6143) & 0x04) {
 			dl = ni_readl(AIFIFO_Data_6143);
@@ -1573,12 +1581,13 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 
 static void get_last_sample_611x(struct comedi_device *dev)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv __maybe_unused = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	short data;
 	u32 dl;
 
-	if (boardtype.reg_type != ni_reg_611x)
+	if (board->reg_type != ni_reg_611x)
 		return;
 
 	/* Check if there's a single sample stuck in the FIFO */
@@ -1591,12 +1600,13 @@ static void get_last_sample_611x(struct comedi_device *dev)
 
 static void get_last_sample_6143(struct comedi_device *dev)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv __maybe_unused = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	short data;
 	u32 dl;
 
-	if (boardtype.reg_type != ni_reg_6143)
+	if (board->reg_type != ni_reg_6143)
 		return;
 
 	/* Check if there's a single sample stuck in the FIFO */
@@ -1641,6 +1651,7 @@ static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	int retval;
@@ -1660,7 +1671,7 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 		return -EIO;
 	}
 
-	switch (boardtype.reg_type) {
+	switch (board->reg_type) {
 	case ni_reg_611x:
 	case ni_reg_6143:
 		mite_prep_dma(devpriv->ai_mite_chan, 32, 16);
@@ -1681,6 +1692,7 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 
 static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AO_SUBDEV];
 	int retval;
@@ -1695,7 +1707,7 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ao_mite_chan) {
-		if (boardtype.reg_type & (ni_reg_611x | ni_reg_6713)) {
+		if (board->reg_type & (ni_reg_611x | ni_reg_6713)) {
 			mite_prep_dma(devpriv->ao_mite_chan, 32, 32);
 		} else {
 			/* doing 32 instead of 16 bit wide transfers from memory
@@ -1720,6 +1732,7 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 
 static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
 	ni_release_ai_mite_channel(dev);
@@ -1735,7 +1748,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	ni_clear_ai_fifo(dev);
 
-	if (boardtype.reg_type != ni_reg_6143)
+	if (board->reg_type != ni_reg_6143)
 		ni_writeb(0, Misc_Command);
 
 	devpriv->stc_writew(dev, AI_Disarm, AI_Command_1_Register);	/* reset pulses */
@@ -1746,7 +1759,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->stc_writew(dev, 0x0000, AI_Mode_2_Register);
 	/* generate FIFO interrupts on non-empty */
 	devpriv->stc_writew(dev, (0 << 6) | 0x0000, AI_Mode_3_Register);
-	if (boardtype.reg_type == ni_reg_611x) {
+	if (board->reg_type == ni_reg_611x) {
 		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
 				    AI_SOC_Polarity |
 				    AI_LOCALMUX_CLK_Pulse_Width,
@@ -1759,7 +1772,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 				    AI_CONVERT_Output_Select
 				    (AI_CONVERT_Output_Enable_High),
 				    AI_Output_Control_Register);
-	} else if (boardtype.reg_type == ni_reg_6143) {
+	} else if (board->reg_type == ni_reg_6143) {
 		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
 				    AI_SOC_Polarity |
 				    AI_LOCALMUX_CLK_Pulse_Width,
@@ -1784,7 +1797,7 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 		    AI_EXTMUX_CLK_Output_Select(0) |
 		    AI_LOCALMUX_CLK_Output_Select(2) |
 		    AI_SC_TC_Output_Select(3);
-		if (boardtype.reg_type == ni_reg_622x)
+		if (board->reg_type == ni_reg_622x)
 			ai_output_control_bits |=
 			    AI_CONVERT_Output_Select
 			    (AI_CONVERT_Output_Enable_High);
@@ -1832,9 +1845,10 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	int i, n;
-	const unsigned int mask = (1 << boardtype.adbits) - 1;
+	const unsigned int mask = (1 << board->adbits) - 1;
 	unsigned signbits;
 	unsigned short d;
 	unsigned long dl;
@@ -1844,7 +1858,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 	ni_clear_ai_fifo(dev);
 
 	signbits = devpriv->ai_offset[0];
-	if (boardtype.reg_type == ni_reg_611x) {
+	if (board->reg_type == ni_reg_611x) {
 		for (n = 0; n < num_adc_stages_611x; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
 					    AI_Command_1_Register);
@@ -1877,7 +1891,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			d += signbits;
 			data[n] = d;
 		}
-	} else if (boardtype.reg_type == ni_reg_6143) {
+	} else if (board->reg_type == ni_reg_6143) {
 		for (n = 0; n < insn->n; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
 					    AI_Command_1_Register);
@@ -1913,7 +1927,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 				    ("ni_mio_common: timeout in ni_ai_insn_read\n");
 				return -ETIME;
 			}
-			if (boardtype.reg_type & ni_reg_m_series_mask) {
+			if (board->reg_type & ni_reg_m_series_mask) {
 				data[n] =
 				    ni_readl(M_Offset_AI_FIFO_Data) & mask;
 			} else {
@@ -1948,6 +1962,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 					      unsigned int n_chan,
 					      unsigned int *list)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int chan, range, aref;
 	unsigned int i;
@@ -1957,12 +1972,12 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 
 	devpriv->stc_writew(dev, 1, Configuration_Memory_Clear);
 
-/* offset = 1 << (boardtype.adbits - 1); */
+/* offset = 1 << (board->adbits - 1); */
 	if ((list[0] & CR_ALT_SOURCE)) {
 		unsigned bypass_bits;
 		chan = CR_CHAN(list[0]);
 		range = CR_RANGE(list[0]);
-		range_code = ni_gainlkup[boardtype.gainlkup][range];
+		range_code = ni_gainlkup[board->gainlkup][range];
 		dither = ((list[0] & CR_ALT_FILTER) != 0);
 		bypass_bits = MSeries_AI_Bypass_Config_FIFO_Bit;
 		bypass_bits |= chan;
@@ -1989,7 +2004,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 		range = CR_RANGE(list[i]);
 		dither = ((list[i] & CR_ALT_FILTER) != 0);
 
-		range_code = ni_gainlkup[boardtype.gainlkup][range];
+		range_code = ni_gainlkup[board->gainlkup][range];
 		devpriv->ai_offset[i] = offset;
 		switch (aref) {
 		case AREF_DIFF:
@@ -2009,7 +2024,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 		}
 		config_bits |= MSeries_AI_Config_Channel_Bits(chan);
 		config_bits |=
-		    MSeries_AI_Config_Bank_Bits(boardtype.reg_type, chan);
+		    MSeries_AI_Config_Bank_Bits(board->reg_type, chan);
 		config_bits |= MSeries_AI_Config_Gain_Bits(range_code);
 		if (i == n_chan - 1)
 			config_bits |= MSeries_AI_Config_Last_Channel_Bit;
@@ -2054,6 +2069,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 static void ni_load_channelgain_list(struct comedi_device *dev,
 				     unsigned int n_chan, unsigned int *list)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int chan, range, aref;
 	unsigned int i;
@@ -2061,12 +2077,12 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 	unsigned offset;
 	unsigned int dither;
 
-	if (boardtype.reg_type & ni_reg_m_series_mask) {
+	if (board->reg_type & ni_reg_m_series_mask) {
 		ni_m_series_load_channelgain_list(dev, n_chan, list);
 		return;
 	}
-	if (n_chan == 1 && (boardtype.reg_type != ni_reg_611x)
-	    && (boardtype.reg_type != ni_reg_6143)) {
+	if (n_chan == 1 && (board->reg_type != ni_reg_611x)
+	    && (board->reg_type != ni_reg_6143)) {
 		if (devpriv->changain_state
 		    && devpriv->changain_spec == list[0]) {
 			/*  ready to go. */
@@ -2081,7 +2097,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 	devpriv->stc_writew(dev, 1, Configuration_Memory_Clear);
 
 	/*  Set up Calibration mode if required */
-	if (boardtype.reg_type == ni_reg_6143) {
+	if (board->reg_type == ni_reg_6143) {
 		if ((list[0] & CR_ALT_SOURCE)
 		    && !devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay enable bit */
@@ -2105,9 +2121,9 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		}
 	}
 
-	offset = 1 << (boardtype.adbits - 1);
+	offset = 1 << (board->adbits - 1);
 	for (i = 0; i < n_chan; i++) {
-		if ((boardtype.reg_type != ni_reg_6143)
+		if ((board->reg_type != ni_reg_6143)
 		    && (list[i] & CR_ALT_SOURCE)) {
 			chan = devpriv->ai_calib_source;
 		} else {
@@ -2118,21 +2134,21 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 		dither = ((list[i] & CR_ALT_FILTER) != 0);
 
 		/* fix the external/internal range differences */
-		range = ni_gainlkup[boardtype.gainlkup][range];
-		if (boardtype.reg_type == ni_reg_611x)
+		range = ni_gainlkup[board->gainlkup][range];
+		if (board->reg_type == ni_reg_611x)
 			devpriv->ai_offset[i] = offset;
 		else
 			devpriv->ai_offset[i] = (range & 0x100) ? 0 : offset;
 
 		hi = 0;
 		if ((list[i] & CR_ALT_SOURCE)) {
-			if (boardtype.reg_type == ni_reg_611x)
+			if (board->reg_type == ni_reg_611x)
 				ni_writew(CR_CHAN(list[i]) & 0x0003,
 					  Calibration_Channel_Select_611x);
 		} else {
-			if (boardtype.reg_type == ni_reg_611x)
+			if (board->reg_type == ni_reg_611x)
 				aref = AREF_DIFF;
-			else if (boardtype.reg_type == ni_reg_6143)
+			else if (board->reg_type == ni_reg_6143)
 				aref = AREF_OTHER;
 			switch (aref) {
 			case AREF_DIFF:
@@ -2152,7 +2168,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 
 		ni_writew(hi, Configuration_Memory_High);
 
-		if (boardtype.reg_type != ni_reg_6143) {
+		if (board->reg_type != ni_reg_6143) {
 			lo = range;
 			if (i == n_chan - 1)
 				lo |= AI_LAST_CHANNEL;
@@ -2164,8 +2180,8 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 	}
 
 	/* prime the channel/gain list */
-	if ((boardtype.reg_type != ni_reg_611x)
-	    && (boardtype.reg_type != ni_reg_6143)) {
+	if ((board->reg_type != ni_reg_611x)
+	    && (board->reg_type != ni_reg_6143)) {
 		ni_prime_channelgain_list(dev);
 	}
 }
@@ -2201,22 +2217,25 @@ static unsigned ni_timer_to_ns(const struct comedi_device *dev, int timer)
 static unsigned ni_min_ai_scan_period_ns(struct comedi_device *dev,
 					 unsigned num_channels)
 {
-	switch (boardtype.reg_type) {
+	const struct ni_board_struct *board = comedi_board(dev);
+
+	switch (board->reg_type) {
 	case ni_reg_611x:
 	case ni_reg_6143:
 		/*  simultaneously-sampled inputs */
-		return boardtype.ai_speed;
+		return board->ai_speed;
 		break;
 	default:
 		/*  multiplexed inputs */
 		break;
 	}
-	return boardtype.ai_speed * num_channels;
+	return board->ai_speed * num_channels;
 }
 
 static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	int err = 0;
 	int tmp;
@@ -2233,8 +2252,8 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 					TRIG_TIMER | TRIG_EXT);
 
 	sources = TRIG_TIMER | TRIG_EXT;
-	if (boardtype.reg_type == ni_reg_611x ||
-	    boardtype.reg_type == ni_reg_6143)
+	if (board->reg_type == ni_reg_611x ||
+	    board->reg_type == ni_reg_6143)
 		sources |= TRIG_NOW;
 	err |= cfc_check_trigger_src(&cmd->convert_src, sources);
 
@@ -2289,12 +2308,12 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	}
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		if ((boardtype.reg_type == ni_reg_611x)
-		    || (boardtype.reg_type == ni_reg_6143)) {
+		if ((board->reg_type == ni_reg_611x)
+		    || (board->reg_type == ni_reg_6143)) {
 			err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 		} else {
 			err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-							 boardtype.ai_speed);
+							 board->ai_speed);
 			err |= cfc_check_trigger_arg_max(&cmd->convert_arg,
 						devpriv->clock_ns * 0xffff);
 		}
@@ -2315,7 +2334,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->stop_src == TRIG_COUNT) {
 		unsigned int max_count = 0x01000000;
 
-		if (boardtype.reg_type == ni_reg_611x)
+		if (board->reg_type == ni_reg_611x)
 			max_count -= num_adc_stages_611x;
 		err |= cfc_check_trigger_arg_max(&cmd->stop_arg, max_count);
 		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
@@ -2341,8 +2360,8 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
-		if ((boardtype.reg_type != ni_reg_611x)
-		    && (boardtype.reg_type != ni_reg_6143)) {
+		if ((board->reg_type != ni_reg_611x)
+		    && (board->reg_type != ni_reg_6143)) {
 			tmp = cmd->convert_arg;
 			cmd->convert_arg =
 			    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
@@ -2370,6 +2389,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	const struct comedi_cmd *cmd = &s->async->cmd;
 	int timer;
@@ -2426,8 +2446,8 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	mode2 &= ~AI_SC_Reload_Mode;
 	devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
 
-	if (cmd->chanlist_len == 1 || (boardtype.reg_type == ni_reg_611x)
-	    || (boardtype.reg_type == ni_reg_6143)) {
+	if (cmd->chanlist_len == 1 || (board->reg_type == ni_reg_611x)
+	    || (board->reg_type == ni_reg_6143)) {
 		start_stop_select |= AI_STOP_Polarity;
 		start_stop_select |= AI_STOP_Select(31);	/*  logic low */
 		start_stop_select |= AI_STOP_Sync;
@@ -2442,7 +2462,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	case TRIG_COUNT:
 		stop_count = cmd->stop_arg - 1;
 
-		if (boardtype.reg_type == ni_reg_611x) {
+		if (board->reg_type == ni_reg_611x) {
 			/*  have to take 3 stage adc pipeline into account */
 			stop_count += num_adc_stages_611x;
 		}
@@ -2698,6 +2718,7 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
 	if (insn->n < 1)
@@ -2707,7 +2728,7 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 	case INSN_CONFIG_ANALOG_TRIG:
 		return ni_ai_config_analog_trig(dev, s, insn, data);
 	case INSN_CONFIG_ALT_SOURCE:
-		if (boardtype.reg_type & ni_reg_m_series_mask) {
+		if (board->reg_type & ni_reg_m_series_mask) {
 			if (data[1] & ~(MSeries_AI_Bypass_Cal_Sel_Pos_Mask |
 					MSeries_AI_Bypass_Cal_Sel_Neg_Mask |
 					MSeries_AI_Bypass_Mode_Mux_Mask |
@@ -2715,7 +2736,7 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 				return -EINVAL;
 			}
 			devpriv->ai_calib_source = data[1];
-		} else if (boardtype.reg_type == ni_reg_6143) {
+		} else if (board->reg_type == ni_reg_6143) {
 			unsigned int calib_source;
 
 			calib_source = data[1] & 0xf;
@@ -2735,7 +2756,7 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 			if (calib_source >= 8)
 				return -EINVAL;
 			devpriv->ai_calib_source = calib_source;
-			if (boardtype.reg_type == ni_reg_611x) {
+			if (board->reg_type == ni_reg_611x) {
 				ni_writeb(calib_source_adjust,
 					  Cal_Gain_Select_611x);
 			}
@@ -2753,6 +2774,7 @@ static int ni_ai_config_analog_trig(struct comedi_device *dev,
 				    struct comedi_insn *insn,
 				    unsigned int *data)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int a, b, modebits;
 	int err = 0;
@@ -2761,14 +2783,14 @@ static int ni_ai_config_analog_trig(struct comedi_device *dev,
 	 * data[2] is analog line
 	 * data[3] is set level
 	 * data[4] is reset level */
-	if (!boardtype.has_analog_trig)
+	if (!board->has_analog_trig)
 		return -EINVAL;
 	if ((data[1] & 0xffff0000) != COMEDI_EV_SCAN_BEGIN) {
 		data[1] &= (COMEDI_EV_SCAN_BEGIN | 0xffff);
 		err++;
 	}
-	if (data[2] >= boardtype.n_adchan) {
-		data[2] = boardtype.n_adchan - 1;
+	if (data[2] >= board->n_adchan) {
+		data[2] = board->n_adchan - 1;
 		err++;
 	}
 	if (data[3] > 255) {	/* a */
@@ -2852,6 +2874,7 @@ static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 			void *data, unsigned int num_bytes,
 			unsigned int chan_index)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct comedi_async *async = s->async;
 	unsigned int range;
 	unsigned int i;
@@ -2859,10 +2882,10 @@ static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int length = num_bytes / sizeof(short);
 	short *array = data;
 
-	offset = 1 << (boardtype.aobits - 1);
+	offset = 1 << (board->aobits - 1);
 	for (i = 0; i < length; i++) {
 		range = CR_RANGE(async->cmd.chanlist[chan_index]);
-		if (boardtype.ao_unipolar == 0 || (range & 1) == 0)
+		if (board->ao_unipolar == 0 || (range & 1) == 0)
 			array[i] -= offset;
 #ifdef PCIDMA
 		array[i] = cpu_to_le16(array[i]);
@@ -2877,6 +2900,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 					  unsigned int chanspec[],
 					  unsigned int n_chans, int timed)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int range;
 	unsigned int chan;
@@ -2885,7 +2909,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 	int invert = 0;
 
 	if (timed) {
-		for (i = 0; i < boardtype.n_aochan; ++i) {
+		for (i = 0; i < board->n_aochan; ++i) {
 			devpriv->ao_conf[i] &= ~MSeries_AO_Update_Timed_Bit;
 			ni_writeb(devpriv->ao_conf[i],
 				  M_Offset_AO_Config_Bank(i));
@@ -2949,6 +2973,7 @@ static int ni_old_ao_config_chanlist(struct comedi_device *dev,
 				     unsigned int chanspec[],
 				     unsigned int n_chans)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int range;
 	unsigned int chan;
@@ -2961,10 +2986,10 @@ static int ni_old_ao_config_chanlist(struct comedi_device *dev,
 		range = CR_RANGE(chanspec[i]);
 		conf = AO_Channel(chan);
 
-		if (boardtype.ao_unipolar) {
+		if (board->ao_unipolar) {
 			if ((range & 1) == 0) {
 				conf |= AO_Bipolar;
-				invert = (1 << (boardtype.aobits - 1));
+				invert = (1 << (board->aobits - 1));
 			} else {
 				invert = 0;
 			}
@@ -2972,7 +2997,7 @@ static int ni_old_ao_config_chanlist(struct comedi_device *dev,
 				conf |= AO_Ext_Ref;
 		} else {
 			conf |= AO_Bipolar;
-			invert = (1 << (boardtype.aobits - 1));
+			invert = (1 << (board->aobits - 1));
 		}
 
 		/* not all boards can deglitch, but this shouldn't hurt */
@@ -2995,7 +3020,9 @@ static int ni_ao_config_chanlist(struct comedi_device *dev,
 				 unsigned int chanspec[], unsigned int n_chans,
 				 int timed)
 {
-	if (boardtype.reg_type & ni_reg_m_series_mask)
+	const struct ni_board_struct *board = comedi_board(dev);
+
+	if (board->reg_type & ni_reg_m_series_mask)
 		return ni_m_series_ao_config_chanlist(dev, s, chanspec, n_chans,
 						      timed);
 	else
@@ -3017,6 +3044,7 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
@@ -3025,7 +3053,7 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 
 	devpriv->ao[chan] = data[0];
 
-	if (boardtype.reg_type & ni_reg_m_series_mask) {
+	if (board->reg_type & ni_reg_m_series_mask) {
 		ni_writew(data[0], M_Offset_DAC_Direct_Data(chan));
 	} else
 		ni_writew(data[0] ^ invert,
@@ -3038,12 +3066,13 @@ static int ni_ao_insn_write_671x(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
 
 	ao_win_out(1 << chan, AO_Immediate_671x);
-	invert = 1 << (boardtype.aobits - 1);
+	invert = 1 << (board->aobits - 1);
 
 	ni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);
 
@@ -3057,13 +3086,14 @@ static int ni_ao_insn_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
 	switch (data[0]) {
 	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
 		switch (data[1]) {
 		case COMEDI_OUTPUT:
-			data[2] = 1 + boardtype.ao_fifo_depth * sizeof(short);
+			data[2] = 1 + board->ao_fifo_depth * sizeof(short);
 			if (devpriv->mite)
 				data[2] += devpriv->mite->fifo_size;
 			break;
@@ -3085,6 +3115,7 @@ static int ni_ao_insn_config(struct comedi_device *dev,
 static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 			 unsigned int trignum)
 {
+	const struct ni_board_struct *board __maybe_unused = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	int ret;
 	int interrupt_b_bits;
@@ -3104,7 +3135,7 @@ static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	interrupt_b_bits = AO_Error_Interrupt_Enable;
 #ifdef PCIDMA
 	devpriv->stc_writew(dev, 1, DAC_FIFO_Clear);
-	if (boardtype.reg_type & ni_reg_6xxx_mask)
+	if (board->reg_type & ni_reg_6xxx_mask)
 		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
 	ret = ni_ao_setup_MITE_dma(dev);
 	if (ret)
@@ -3155,6 +3186,7 @@ static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	const struct comedi_cmd *cmd = &s->async->cmd;
 	int bits;
@@ -3170,7 +3202,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	devpriv->stc_writew(dev, AO_Disarm, AO_Command_1_Register);
 
-	if (boardtype.reg_type & ni_reg_6xxx_mask) {
+	if (board->reg_type & ni_reg_6xxx_mask) {
 		ao_win_out(CLEAR_WG, AO_Misc_611x);
 
 		bits = 0;
@@ -3233,7 +3265,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		if (boardtype.reg_type & ni_reg_m_series_mask) {
+		if (board->reg_type & ni_reg_m_series_mask) {
 			/*  this is how the NI example code does it for m-series boards, verified correct with 6259 */
 			devpriv->stc_writel(dev, cmd->stop_arg - 1,
 					    AO_UC_Load_A_Register);
@@ -3301,8 +3333,8 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		unsigned bits;
 		devpriv->ao_mode1 &= ~AO_Multiple_Channels;
 		bits = AO_UPDATE_Output_Select(AO_Update_Output_High_Z);
-		if (boardtype.
-		    reg_type & (ni_reg_m_series_mask | ni_reg_6xxx_mask)) {
+		if (board->reg_type &
+		    (ni_reg_m_series_mask | ni_reg_6xxx_mask)) {
 			bits |= AO_Number_Of_Channels(0);
 		} else {
 			bits |=
@@ -3329,14 +3361,14 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	bits = AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
 	    AO_TMRDACWR_Pulse_Width;
-	if (boardtype.ao_fifo_depth)
+	if (board->ao_fifo_depth)
 		bits |= AO_FIFO_Enable;
 	else
 		bits |= AO_DMA_PIO_Control;
 #if 0
 	/* F Hess: windows driver does not set AO_Number_Of_DAC_Packages bit for 6281,
 	   verified with bus analyzer. */
-	if (boardtype.reg_type & ni_reg_m_series_mask)
+	if (board->reg_type & ni_reg_m_series_mask)
 		bits |= AO_Number_Of_DAC_Packages;
 #endif
 	devpriv->stc_writew(dev, bits, AO_Personal_Register);
@@ -3360,6 +3392,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	int err = 0;
 	int tmp;
@@ -3407,7 +3440,7 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 boardtype.ao_speed);
+						 board->ao_speed);
 		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
 						 devpriv->clock_ns * 0xffffff);
 	}
@@ -3448,6 +3481,7 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
 	/* devpriv->ao0p=0x0000; */
@@ -3475,7 +3509,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 	devpriv->ao_mode2 = 0;
 	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
-	if (boardtype.reg_type & ni_reg_m_series_mask)
+	if (board->reg_type & ni_reg_m_series_mask)
 		devpriv->ao_mode3 = AO_Last_Gate_Disable;
 	else
 		devpriv->ao_mode3 = 0;
@@ -3483,7 +3517,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ao_trigger_select = 0;
 	devpriv->stc_writew(dev, devpriv->ao_trigger_select,
 			    AO_Trigger_Select_Register);
-	if (boardtype.reg_type & ni_reg_6xxx_mask) {
+	if (board->reg_type & ni_reg_6xxx_mask) {
 		unsigned immediate_bits = 0;
 		unsigned i;
 		for (i = 0; i < s->n_chan; ++i) {
@@ -3784,6 +3818,7 @@ static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static void handle_cdio_interrupt(struct comedi_device *dev)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv __maybe_unused = dev->private;
 	unsigned cdio_status;
 	struct comedi_subdevice *s = &dev->subdevices[NI_DIO_SUBDEV];
@@ -3791,7 +3826,7 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	unsigned long flags;
 #endif
 
-	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
+	if ((board->reg_type & ni_reg_m_series_mask) == 0) {
 		return;
 	}
 #ifdef PCIDMA
@@ -4038,6 +4073,7 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 
 static void mio_common_detach(struct comedi_device *dev)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 
@@ -4046,7 +4082,7 @@ static void mio_common_detach(struct comedi_device *dev)
 			ni_gpct_device_destroy(devpriv->counter_dev);
 		}
 	}
-	if (dev->subdevices && boardtype.has_8255) {
+	if (dev->subdevices && board->has_8255) {
 		s = &dev->subdevices[NI_8255_DIO_SUBDEV];
 		subdev_8255_cleanup(dev, s);
 	}
@@ -4355,14 +4391,15 @@ static int ni_alloc_private(struct comedi_device *dev)
 
 static int ni_E_init(struct comedi_device *dev)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	unsigned j;
 	enum ni_gpct_variant counter_variant;
 	int ret;
 
-	if (boardtype.n_aochan > MAX_N_AO_CHAN) {
-		printk("bug! boardtype.n_aochan > MAX_N_AO_CHAN\n");
+	if (board->n_aochan > MAX_N_AO_CHAN) {
+		printk("bug! n_aochan > MAX_N_AO_CHAN\n");
 		return -EINVAL;
 	}
 
@@ -4374,20 +4411,20 @@ static int ni_E_init(struct comedi_device *dev)
 
 	s = &dev->subdevices[NI_AI_SUBDEV];
 	dev->read_subdev = s;
-	if (boardtype.n_adchan) {
+	if (board->n_adchan) {
 		s->type = COMEDI_SUBD_AI;
 		s->subdev_flags =
 		    SDF_READABLE | SDF_DIFF | SDF_DITHER | SDF_CMD_READ;
-		if (boardtype.reg_type != ni_reg_611x)
+		if (board->reg_type != ni_reg_611x)
 			s->subdev_flags |= SDF_GROUND | SDF_COMMON | SDF_OTHER;
-		if (boardtype.adbits > 16)
+		if (board->adbits > 16)
 			s->subdev_flags |= SDF_LSAMPL;
-		if (boardtype.reg_type & ni_reg_m_series_mask)
+		if (board->reg_type & ni_reg_m_series_mask)
 			s->subdev_flags |= SDF_SOFT_CALIBRATED;
-		s->n_chan = boardtype.n_adchan;
+		s->n_chan = board->n_adchan;
 		s->len_chanlist = 512;
-		s->maxdata = (1 << boardtype.adbits) - 1;
-		s->range_table = ni_range_lkup[boardtype.gainlkup];
+		s->maxdata = (1 << board->adbits) - 1;
+		s->range_table = ni_range_lkup[board->gainlkup];
 		s->insn_read = &ni_ai_insn_read;
 		s->insn_config = &ni_ai_insn_config;
 		s->do_cmdtest = &ni_ai_cmdtest;
@@ -4405,40 +4442,40 @@ static int ni_E_init(struct comedi_device *dev)
 	/* analog output subdevice */
 
 	s = &dev->subdevices[NI_AO_SUBDEV];
-	if (boardtype.n_aochan) {
+	if (board->n_aochan) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_WRITABLE | SDF_DEGLITCH | SDF_GROUND;
-		if (boardtype.reg_type & ni_reg_m_series_mask)
+		if (board->reg_type & ni_reg_m_series_mask)
 			s->subdev_flags |= SDF_SOFT_CALIBRATED;
-		s->n_chan = boardtype.n_aochan;
-		s->maxdata = (1 << boardtype.aobits) - 1;
-		s->range_table = boardtype.ao_range_table;
+		s->n_chan = board->n_aochan;
+		s->maxdata = (1 << board->aobits) - 1;
+		s->range_table = board->ao_range_table;
 		s->insn_read = &ni_ao_insn_read;
-		if (boardtype.reg_type & ni_reg_6xxx_mask) {
+		if (board->reg_type & ni_reg_6xxx_mask) {
 			s->insn_write = &ni_ao_insn_write_671x;
 		} else {
 			s->insn_write = &ni_ao_insn_write;
 		}
 		s->insn_config = &ni_ao_insn_config;
 #ifdef PCIDMA
-		if (boardtype.n_aochan) {
+		if (board->n_aochan) {
 			s->async_dma_dir = DMA_TO_DEVICE;
 #else
-		if (boardtype.ao_fifo_depth) {
+		if (board->ao_fifo_depth) {
 #endif
 			dev->write_subdev = s;
 			s->subdev_flags |= SDF_CMD_WRITE;
 			s->do_cmd = &ni_ao_cmd;
 			s->do_cmdtest = &ni_ao_cmdtest;
-			s->len_chanlist = boardtype.n_aochan;
-			if ((boardtype.reg_type & ni_reg_m_series_mask) == 0)
+			s->len_chanlist = board->n_aochan;
+			if ((board->reg_type & ni_reg_m_series_mask) == 0)
 				s->munge = ni_ao_munge;
 		}
 		s->cancel = &ni_ao_reset;
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}
-	if ((boardtype.reg_type & ni_reg_67xx_mask))
+	if ((board->reg_type & ni_reg_67xx_mask))
 		init_ao_67xx(dev, s);
 
 	/* digital i/o subdevice */
@@ -4449,8 +4486,8 @@ static int ni_E_init(struct comedi_device *dev)
 	s->maxdata = 1;
 	s->io_bits = 0;		/* all bits input */
 	s->range_table = &range_digital;
-	s->n_chan = boardtype.num_p0_dio_channels;
-	if (boardtype.reg_type & ni_reg_m_series_mask) {
+	s->n_chan = board->num_p0_dio_channels;
+	if (board->reg_type & ni_reg_m_series_mask) {
 		s->subdev_flags |=
 		    SDF_LSAMPL | SDF_CMD_WRITE /* | SDF_CMD_READ */ ;
 		s->insn_bits = &ni_m_series_dio_insn_bits;
@@ -4472,7 +4509,7 @@ static int ni_E_init(struct comedi_device *dev)
 
 	/* 8255 device */
 	s = &dev->subdevices[NI_8255_DIO_SUBDEV];
-	if (boardtype.has_8255) {
+	if (board->has_8255) {
 		subdev_8255_init(dev, s, ni_8255_callback, (unsigned long)dev);
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
@@ -4485,14 +4522,14 @@ static int ni_E_init(struct comedi_device *dev)
 	/* calibration subdevice -- ai and ao */
 	s = &dev->subdevices[NI_CALIBRATION_SUBDEV];
 	s->type = COMEDI_SUBD_CALIB;
-	if (boardtype.reg_type & ni_reg_m_series_mask) {
+	if (board->reg_type & ni_reg_m_series_mask) {
 		/*  internal PWM analog output used for AI nonlinearity calibration */
 		s->subdev_flags = SDF_INTERNAL;
 		s->insn_config = &ni_m_series_pwm_config;
 		s->n_chan = 1;
 		s->maxdata = 0;
 		ni_writel(0x0, M_Offset_Cal_PWM);
-	} else if (boardtype.reg_type == ni_reg_6143) {
+	} else if (board->reg_type == ni_reg_6143) {
 		/*  internal PWM analog output used for AI nonlinearity calibration */
 		s->subdev_flags = SDF_INTERNAL;
 		s->insn_config = &ni_6143_pwm_config;
@@ -4510,7 +4547,7 @@ static int ni_E_init(struct comedi_device *dev)
 	s->type = COMEDI_SUBD_MEMORY;
 	s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
 	s->maxdata = 0xff;
-	if (boardtype.reg_type & ni_reg_m_series_mask) {
+	if (board->reg_type & ni_reg_m_series_mask) {
 		s->n_chan = M_SERIES_EEPROM_SIZE;
 		s->insn_read = &ni_m_series_eeprom_insn_read;
 	} else {
@@ -4522,7 +4559,7 @@ static int ni_E_init(struct comedi_device *dev)
 	s = &dev->subdevices[NI_PFI_DIO_SUBDEV];
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-	if (boardtype.reg_type & ni_reg_m_series_mask) {
+	if (board->reg_type & ni_reg_m_series_mask) {
 		unsigned i;
 		s->n_chan = 16;
 		ni_writew(s->state, M_Offset_PFI_DO);
@@ -4534,7 +4571,7 @@ static int ni_E_init(struct comedi_device *dev)
 		s->n_chan = 10;
 	}
 	s->maxdata = 1;
-	if (boardtype.reg_type & ni_reg_m_series_mask) {
+	if (board->reg_type & ni_reg_m_series_mask) {
 		s->insn_bits = &ni_pfi_insn_bits;
 	}
 	s->insn_config = &ni_pfi_insn_config;
@@ -4542,11 +4579,11 @@ static int ni_E_init(struct comedi_device *dev)
 
 	/* cs5529 calibration adc */
 	s = &dev->subdevices[NI_CS5529_CALIBRATION_SUBDEV];
-	if (boardtype.reg_type & ni_reg_67xx_mask) {
+	if (board->reg_type & ni_reg_67xx_mask) {
 		s->type = COMEDI_SUBD_AI;
 		s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_INTERNAL;
 		/*  one channel for each analog output channel */
-		s->n_chan = boardtype.n_aochan;
+		s->n_chan = board->n_aochan;
 		s->maxdata = (1 << 16) - 1;
 		s->range_table = &range_unknown;	/* XXX */
 		s->insn_read = cs5529_ai_insn_read;
@@ -4576,7 +4613,7 @@ static int ni_E_init(struct comedi_device *dev)
 	s->insn_config = ni_rtsi_insn_config;
 	ni_rtsi_init(dev);
 
-	if (boardtype.reg_type & ni_reg_m_series_mask) {
+	if (board->reg_type & ni_reg_m_series_mask) {
 		counter_variant = ni_gpct_variant_m_series;
 	} else {
 		counter_variant = ni_gpct_variant_e_series;
@@ -4594,7 +4631,7 @@ static int ni_E_init(struct comedi_device *dev)
 		    SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL | SDF_CMD_READ
 		    /* | SDF_CMD_WRITE */ ;
 		s->n_chan = 3;
-		if (boardtype.reg_type & ni_reg_m_series_mask)
+		if (board->reg_type & ni_reg_m_series_mask)
 			s->maxdata = 0xffffffff;
 		else
 			s->maxdata = 0xffffff;
@@ -4626,7 +4663,7 @@ static int ni_E_init(struct comedi_device *dev)
 	/* ai configuration */
 	s = &dev->subdevices[NI_AI_SUBDEV];
 	ni_ai_reset(dev, s);
-	if ((boardtype.reg_type & ni_reg_6xxx_mask) == 0) {
+	if ((board->reg_type & ni_reg_6xxx_mask) == 0) {
 		/*  BEAM is this needed for PCI-6143 ?? */
 		devpriv->clock_and_fout =
 		    Slow_Internal_Time_Divide_By_2 |
@@ -4663,11 +4700,11 @@ static int ni_E_init(struct comedi_device *dev)
 	ni_writeb(devpriv->ai_ao_select_reg, AI_AO_Select);
 	ni_writeb(devpriv->g0_g1_select_reg, G0_G1_Select);
 
-	if (boardtype.reg_type & ni_reg_6xxx_mask) {
+	if (board->reg_type & ni_reg_6xxx_mask) {
 		ni_writeb(0, Magic_611x);
-	} else if (boardtype.reg_type & ni_reg_m_series_mask) {
+	} else if (board->reg_type & ni_reg_m_series_mask) {
 		int channel;
-		for (channel = 0; channel < boardtype.n_aochan; ++channel) {
+		for (channel = 0; channel < board->n_aochan; ++channel) {
 			ni_writeb(0xf, M_Offset_AO_Waveform_Order(channel));
 			ni_writeb(0x0,
 				  M_Offset_AO_Reference_Attenuation(channel));
@@ -4938,6 +4975,7 @@ static struct caldac_struct caldacs[] = {
 
 static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	int i, j;
 	int n_dacs;
@@ -4947,12 +4985,12 @@ static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 	int type;
 	int chan;
 
-	type = boardtype.caldac[0];
+	type = board->caldac[0];
 	if (type == caldac_none)
 		return;
 	n_bits = caldacs[type].n_bits;
 	for (i = 0; i < 3; i++) {
-		type = boardtype.caldac[i];
+		type = board->caldac[i];
 		if (type == caldac_none)
 			break;
 		if (caldacs[type].n_bits != n_bits)
@@ -4971,7 +5009,7 @@ static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 		s->maxdata_list = maxdata_list = devpriv->caldac_maxdata_list;
 		chan = 0;
 		for (i = 0; i < n_dacs; i++) {
-			type = boardtype.caldac[i];
+			type = board->caldac[i];
 			for (j = 0; j < caldacs[type].n_chans; j++) {
 				maxdata_list[chan] =
 				    (1 << caldacs[type].n_bits) - 1;
@@ -4982,7 +5020,7 @@ static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 		for (chan = 0; chan < s->n_chan; chan++)
 			ni_write_caldac(dev, i, s->maxdata_list[i] / 2);
 	} else {
-		type = boardtype.caldac[0];
+		type = board->caldac[0];
 		s->maxdata = (1 << caldacs[type].n_bits) - 1;
 
 		for (chan = 0; chan < s->n_chan; chan++)
@@ -4992,6 +5030,7 @@ static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int loadbit = 0, bits = 0, bit, bitstring = 0;
 	int i;
@@ -5003,7 +5042,7 @@ static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 	devpriv->caldacs[addr] = val;
 
 	for (i = 0; i < 3; i++) {
-		type = boardtype.caldac[i];
+		type = board->caldac[i];
 		if (type == caldac_none)
 			break;
 		if (addr < caldacs[type].n_chans) {
@@ -5275,7 +5314,9 @@ static int ni_old_set_pfi_routing(struct comedi_device *dev, unsigned chan,
 static int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,
 			      unsigned source)
 {
-	if (boardtype.reg_type & ni_reg_m_series_mask)
+	const struct ni_board_struct *board = comedi_board(dev);
+
+	if (board->reg_type & ni_reg_m_series_mask)
 		return ni_m_series_set_pfi_routing(dev, chan, source);
 	else
 		return ni_old_set_pfi_routing(dev, chan, source);
@@ -5336,7 +5377,9 @@ static unsigned ni_old_get_pfi_routing(struct comedi_device *dev, unsigned chan)
 
 static unsigned ni_get_pfi_routing(struct comedi_device *dev, unsigned chan)
 {
-	if (boardtype.reg_type & ni_reg_m_series_mask)
+	const struct ni_board_struct *board = comedi_board(dev);
+
+	if (board->reg_type & ni_reg_m_series_mask)
 		return ni_m_series_get_pfi_routing(dev, chan);
 	else
 		return ni_old_get_pfi_routing(dev, chan);
@@ -5345,10 +5388,11 @@ static unsigned ni_get_pfi_routing(struct comedi_device *dev, unsigned chan)
 static int ni_config_filter(struct comedi_device *dev, unsigned pfi_channel,
 			    enum ni_pfi_filter_select filter)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv __maybe_unused = dev->private;
 	unsigned bits;
 
-	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
+	if ((board->reg_type & ni_reg_m_series_mask) == 0) {
 		return -ENOTSUPP;
 	}
 	bits = ni_readl(M_Offset_PFI_Filter);
@@ -5362,9 +5406,10 @@ static int ni_pfi_insn_bits(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv __maybe_unused = dev->private;
 
-	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
+	if ((board->reg_type & ni_reg_m_series_mask) == 0) {
 		return -ENOTSUPP;
 	}
 	if (data[0]) {
@@ -5423,6 +5468,7 @@ static int ni_pfi_insn_config(struct comedi_device *dev,
  */
 static void ni_rtsi_init(struct comedi_device *dev)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
 	/*  Initialises the RTSI bus signal switch to a default state */
@@ -5449,7 +5495,7 @@ static void ni_rtsi_init(struct comedi_device *dev)
 	    RTSI_Trig_Output_Bits(5,
 				  NI_RTSI_OUTPUT_G_SRC0) |
 	    RTSI_Trig_Output_Bits(6, NI_RTSI_OUTPUT_G_GATE0);
-	if (boardtype.reg_type & ni_reg_m_series_mask)
+	if (board->reg_type & ni_reg_m_series_mask)
 		devpriv->rtsi_trig_b_output_reg |=
 		    RTSI_Trig_Output_Bits(7, NI_RTSI_OUTPUT_RTSI_OSC);
 	devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
@@ -5517,7 +5563,9 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 
 static inline unsigned num_configurable_rtsi_channels(struct comedi_device *dev)
 {
-	if (boardtype.reg_type & ni_reg_m_series_mask)
+	const struct ni_board_struct *board = comedi_board(dev);
+
+	if (board->reg_type & ni_reg_m_series_mask)
 		return 8;
 	else
 		return 7;
@@ -5629,6 +5677,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 			       unsigned period_ns)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 
 	if (source == NI_MIO_INTERNAL_CLOCK) {
@@ -5636,7 +5685,7 @@ static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
 				    RTSI_Trig_Direction_Register);
 		devpriv->clock_ns = TIMEBASE_1_NS;
-		if (boardtype.reg_type & ni_reg_m_series_mask) {
+		if (board->reg_type & ni_reg_m_series_mask) {
 			devpriv->clock_and_fout2 &=
 			    ~(MSeries_Timebase1_Select_Bit |
 			      MSeries_Timebase3_Select_Bit);
@@ -5646,7 +5695,7 @@ static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 		}
 		devpriv->clock_source = source;
 	} else {
-		if (boardtype.reg_type & ni_reg_m_series_mask) {
+		if (board->reg_type & ni_reg_m_series_mask) {
 			return ni_mseries_set_pll_master_clock(dev, source,
 							       period_ns);
 		} else {
@@ -5676,6 +5725,8 @@ static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 static int ni_valid_rtsi_output_source(struct comedi_device *dev, unsigned chan,
 				       unsigned source)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
+
 	if (chan >= num_configurable_rtsi_channels(dev)) {
 		if (chan == old_RTSI_clock_channel) {
 			if (source == NI_RTSI_OUTPUT_RTSI_OSC)
@@ -5702,7 +5753,7 @@ static int ni_valid_rtsi_output_source(struct comedi_device *dev, unsigned chan,
 		return 1;
 		break;
 	case NI_RTSI_OUTPUT_RTSI_OSC:
-		if (boardtype.reg_type & ni_reg_m_series_mask)
+		if (board->reg_type & ni_reg_m_series_mask)
 			return 1;
 		else
 			return 0;
@@ -5758,6 +5809,7 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
+	const struct ni_board_struct *board = comedi_board(dev);
 	struct ni_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 
@@ -5766,9 +5818,7 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 		if (chan < num_configurable_rtsi_channels(dev)) {
 			devpriv->rtsi_trig_direction_reg |=
 			    RTSI_Output_Bit(chan,
-					    (boardtype.
-					     reg_type & ni_reg_m_series_mask) !=
-					    0);
+				(board->reg_type & ni_reg_m_series_mask) != 0);
 		} else if (chan == old_RTSI_clock_channel) {
 			devpriv->rtsi_trig_direction_reg |=
 			    Drive_RTSI_Clock_Bit;
@@ -5780,9 +5830,7 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 		if (chan < num_configurable_rtsi_channels(dev)) {
 			devpriv->rtsi_trig_direction_reg &=
 			    ~RTSI_Output_Bit(chan,
-					     (boardtype.
-					      reg_type & ni_reg_m_series_mask)
-					     != 0);
+				(board->reg_type & ni_reg_m_series_mask) != 0);
 		} else if (chan == old_RTSI_clock_channel) {
 			devpriv->rtsi_trig_direction_reg &=
 			    ~Drive_RTSI_Clock_Bit;
@@ -5795,10 +5843,9 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 			data[1] =
 			    (devpriv->rtsi_trig_direction_reg &
 			     RTSI_Output_Bit(chan,
-					     (boardtype.reg_type &
-					      ni_reg_m_series_mask)
-					     != 0)) ? INSN_CONFIG_DIO_OUTPUT :
-			    INSN_CONFIG_DIO_INPUT;
+				(board->reg_type & ni_reg_m_series_mask) != 0))
+				? INSN_CONFIG_DIO_OUTPUT
+				: INSN_CONFIG_DIO_INPUT;
 		} else if (chan == old_RTSI_clock_channel) {
 			data[1] =
 			    (devpriv->rtsi_trig_direction_reg &

commit 90a35c15c5d7d5c6254772d2752975dda185710c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 17:27:02 2012 -0700

    staging: comedi: store the 'index' for each subdevice
    
    Store the 'index' for each comedi_subdevice when they are initially
    allocated by comedi_alloc_subdevice(). This allows removing the
    pointer math in comedi_fops.c which is used to figure out the
    index that user space uses to access the individual subdevices.
    
    Fix the ni_mio_common driver so it also uses the 'index' instead
    of doing the pointer math.
    
    Also, remove a couple unused macros in the pcmda12, pcmmio, and
    pcmuio drivers which also do the pointer math to figure out the
    index.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 81d7350be84f..b7403597e905 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -986,7 +986,7 @@ static void ni_event(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (s->
 	    async->events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW |
 			     COMEDI_CB_EOA)) {
-		switch (s - dev->subdevices) {
+		switch (s->index) {
 		case NI_AI_SUBDEV:
 			ni_ai_reset(dev, s);
 			break;

commit f012463068dbe0be2680aca6c607f7c6f5f0cdf3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 15:43:18 2012 -0700

    staging: comedi: use comedi_is_subdevice_running()
    
    Use the helper function comedi_is_subdevice_running() instead of getting
    the subdevice runflags and then masking the result.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 56dc59908d36..81d7350be84f 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1086,7 +1086,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			    ("ni_mio_common: a_status=0xffff.  Card removed?\n");
 			/* we probably aren't even running a command now,
 			 * so it's a good idea to be careful. */
-			if (comedi_get_subdevice_runflags(s) & SRF_RUNNING) {
+			if (comedi_is_subdevice_running(s)) {
 				s->async->events |=
 				    COMEDI_CB_ERROR | COMEDI_CB_EOA;
 				ni_event(dev, s);

commit c3be5c7f1e124a415453c45508c95bff3a6b2308
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 18:00:36 2012 -0700

    staging: comedi: ni_mio_common: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of ni_{ai,ao,cdio}_cmdtest().
    
    Note that all the command triggers in ni_cdio_cmdtest are single source
    so the extra tests are not required.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 743a9016e076..56dc59908d36 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2256,7 +2256,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
 	if (cmd->start_src == TRIG_EXT) {
 		/* external trigger */
@@ -2265,30 +2265,17 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (tmp > 16)
 			tmp = 16;
 		tmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));
-		if (cmd->start_arg != tmp) {
-			cmd->start_arg = tmp;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, tmp);
 	} else {
-		if (cmd->start_arg != 0) {
-			/* true for both TRIG_NOW and TRIG_INT */
-			cmd->start_arg = 0;
-			err++;
-		}
+		/* true for both TRIG_NOW and TRIG_INT */
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 	}
+
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		if (cmd->scan_begin_arg < ni_min_ai_scan_period_ns(dev,
-								   cmd->
-								   chanlist_len))
-		{
-			cmd->scan_begin_arg =
-			    ni_min_ai_scan_period_ns(dev, cmd->chanlist_len);
-			err++;
-		}
-		if (cmd->scan_begin_arg > devpriv->clock_ns * 0xffffff) {
-			cmd->scan_begin_arg = devpriv->clock_ns * 0xffffff;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+			ni_min_ai_scan_period_ns(dev, cmd->chanlist_len));
+		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
+						 devpriv->clock_ns * 0xffffff);
 	} else if (cmd->scan_begin_src == TRIG_EXT) {
 		/* external trigger */
 		unsigned int tmp = CR_CHAN(cmd->scan_begin_arg);
@@ -2296,32 +2283,20 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (tmp > 16)
 			tmp = 16;
 		tmp |= (cmd->scan_begin_arg & (CR_INVERT | CR_EDGE));
-		if (cmd->scan_begin_arg != tmp) {
-			cmd->scan_begin_arg = tmp;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);
 	} else {		/* TRIG_OTHER */
-		if (cmd->scan_begin_arg) {
-			cmd->scan_begin_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 	}
+
 	if (cmd->convert_src == TRIG_TIMER) {
 		if ((boardtype.reg_type == ni_reg_611x)
 		    || (boardtype.reg_type == ni_reg_6143)) {
-			if (cmd->convert_arg != 0) {
-				cmd->convert_arg = 0;
-				err++;
-			}
+			err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 		} else {
-			if (cmd->convert_arg < boardtype.ai_speed) {
-				cmd->convert_arg = boardtype.ai_speed;
-				err++;
-			}
-			if (cmd->convert_arg > devpriv->clock_ns * 0xffff) {
-				cmd->convert_arg = devpriv->clock_ns * 0xffff;
-				err++;
-			}
+			err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+							 boardtype.ai_speed);
+			err |= cfc_check_trigger_arg_max(&cmd->convert_arg,
+						devpriv->clock_ns * 0xffff);
 		}
 	} else if (cmd->convert_src == TRIG_EXT) {
 		/* external trigger */
@@ -2330,40 +2305,23 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (tmp > 16)
 			tmp = 16;
 		tmp |= (cmd->convert_arg & (CR_ALT_FILTER | CR_INVERT));
-		if (cmd->convert_arg != tmp) {
-			cmd->convert_arg = tmp;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, tmp);
 	} else if (cmd->convert_src == TRIG_NOW) {
-		if (cmd->convert_arg != 0) {
-			cmd->convert_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 	}
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
 	if (cmd->stop_src == TRIG_COUNT) {
 		unsigned int max_count = 0x01000000;
 
 		if (boardtype.reg_type == ni_reg_611x)
 			max_count -= num_adc_stages_611x;
-		if (cmd->stop_arg > max_count) {
-			cmd->stop_arg = max_count;
-			err++;
-		}
-		if (cmd->stop_arg < 1) {
-			cmd->stop_arg = 1;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_max(&cmd->stop_arg, max_count);
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
 	} else {
 		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 	}
 
 	if (err)
@@ -3432,7 +3390,7 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
 	if (cmd->start_src == TRIG_EXT) {
 		/* external trigger */
@@ -3441,48 +3399,27 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (tmp > 18)
 			tmp = 18;
 		tmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));
-		if (cmd->start_arg != tmp) {
-			cmd->start_arg = tmp;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, tmp);
 	} else {
-		if (cmd->start_arg != 0) {
-			/* true for both TRIG_NOW and TRIG_INT */
-			cmd->start_arg = 0;
-			err++;
-		}
+		/* true for both TRIG_NOW and TRIG_INT */
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 	}
+
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		if (cmd->scan_begin_arg < boardtype.ao_speed) {
-			cmd->scan_begin_arg = boardtype.ao_speed;
-			err++;
-		}
-		if (cmd->scan_begin_arg > devpriv->clock_ns * 0xffffff) {	/* XXX check */
-			cmd->scan_begin_arg = devpriv->clock_ns * 0xffffff;
-			err++;
-		}
-	}
-	if (cmd->convert_arg != 0) {
-		cmd->convert_arg = 0;
-		err++;
-	}
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-	if (cmd->stop_src == TRIG_COUNT) {	/* XXX check */
-		if (cmd->stop_arg > 0x00ffffff) {
-			cmd->stop_arg = 0x00ffffff;
-			err++;
-		}
-	} else {
-		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+						 boardtype.ao_speed);
+		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
+						 devpriv->clock_ns * 0xffffff);
 	}
 
+	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);
+	else	/* TRIG_NONE */
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+
 	if (err)
 		return 3;
 
@@ -3706,39 +3643,18 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
-	if (cmd->start_src == TRIG_INT) {
-		if (cmd->start_arg != 0) {
-			cmd->start_arg = 0;
-			err++;
-		}
-	}
-	if (cmd->scan_begin_src == TRIG_EXT) {
-		tmp = cmd->scan_begin_arg;
-		tmp &= CR_PACK_FLAGS(CDO_Sample_Source_Select_Mask, 0, 0,
-				     CR_INVERT);
-		if (tmp != cmd->scan_begin_arg) {
-			err++;
-		}
-	}
-	if (cmd->convert_src == TRIG_NOW) {
-		if (cmd->convert_arg) {
-			cmd->convert_arg = 0;
-			err++;
-		}
-	}
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->stop_src == TRIG_NONE) {
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
+	tmp = cmd->scan_begin_arg;
+	tmp &= CR_PACK_FLAGS(CDO_Sample_Source_Select_Mask, 0, 0, CR_INVERT);
+	if (tmp != cmd->scan_begin_arg)
+		err |= -EINVAL;
+
+	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index b096c4647b12..743a9016e076 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4424,12 +4424,11 @@ static int ni_freq_out_insn_config(struct comedi_device *dev,
 static int ni_alloc_private(struct comedi_device *dev)
 {
 	struct ni_private *devpriv;
-	int ret;
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	spin_lock_init(&devpriv->window_lock);
 	spin_lock_init(&devpriv->soft_reg_copy_lock);

commit 0e05c55226bffcdd3f1393d5ab74cd0d9faff385
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:19:06 2012 -0700

    staging: comedi: ni_mio_common: remove devpriv macro
    
    The ni_mio_common.c file is #include'd by the ni_atmio, ni_mio_cs,
    and ni_pcimio drivers. Those drivers all have a devpriv macro of
    this type:
    
    This macro relies on a local variable having a specific name.
    Remove its use in all the files by replacing it with a local
    variable.
    
    Some of the functions in ni_mio_common.c don't always use the
    devpriv variable due to differences in how the low-level i/o
    is handled by the driver. Tag the variable in those functions
    with __maybe_unused to avoid compile warnings.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 3e5fdae93163..b096c4647b12 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -410,6 +410,7 @@ static void get_last_sample_6143(struct comedi_device *dev);
 static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 				   unsigned bit_mask, unsigned bit_values)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
@@ -506,6 +507,7 @@ static inline void ni_set_gpct_dma_channel(struct comedi_device *dev,
 static inline void ni_set_cdo_dma_channel(struct comedi_device *dev,
 					  int mite_channel)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
@@ -525,6 +527,7 @@ static inline void ni_set_cdo_dma_channel(struct comedi_device *dev,
 
 static int ni_request_ai_mite_channel(struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
@@ -545,6 +548,7 @@ static int ni_request_ai_mite_channel(struct comedi_device *dev)
 
 static int ni_request_ao_mite_channel(struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
@@ -567,6 +571,7 @@ static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 					unsigned gpct_index,
 					enum comedi_io_direction direction)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 	struct mite_channel *mite_chan;
 
@@ -595,6 +600,7 @@ static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 static int ni_request_cdo_mite_channel(struct comedi_device *dev)
 {
 #ifdef PCIDMA
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
@@ -617,6 +623,7 @@ static int ni_request_cdo_mite_channel(struct comedi_device *dev)
 static void ni_release_ai_mite_channel(struct comedi_device *dev)
 {
 #ifdef PCIDMA
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
@@ -632,6 +639,7 @@ static void ni_release_ai_mite_channel(struct comedi_device *dev)
 static void ni_release_ao_mite_channel(struct comedi_device *dev)
 {
 #ifdef PCIDMA
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
@@ -648,6 +656,7 @@ static void ni_release_ao_mite_channel(struct comedi_device *dev)
 static void ni_release_gpct_mite_channel(struct comedi_device *dev,
 					 unsigned gpct_index)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
 	BUG_ON(gpct_index >= NUM_GPCT);
@@ -669,6 +678,7 @@ static void ni_release_gpct_mite_channel(struct comedi_device *dev,
 static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 {
 #ifdef PCIDMA
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
@@ -686,6 +696,8 @@ static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 					  unsigned gpct_index, short enable)
 {
+	struct ni_private *devpriv = dev->private;
+
 	if (boardtype.reg_type & ni_reg_m_series_mask)
 		return;
 	switch (gpct_index) {
@@ -716,6 +728,8 @@ static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 
 static void ni_clear_ai_fifo(struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
+
 	if (boardtype.reg_type == ni_reg_6143) {
 		/*  Flush the 6143 data FIFO */
 		ni_writel(0x10, AIFIFO_Control_6143);	/*  Flush fifo */
@@ -742,13 +756,17 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 
 static void win_out2(struct comedi_device *dev, uint32_t data, int reg)
 {
+	struct ni_private *devpriv = dev->private;
+
 	devpriv->stc_writew(dev, data >> 16, reg);
 	devpriv->stc_writew(dev, data & 0xffff, reg + 1);
 }
 
 static uint32_t win_in2(struct comedi_device *dev, int reg)
 {
+	struct ni_private *devpriv = dev->private;
 	uint32_t bits;
+
 	bits = devpriv->stc_readw(dev, reg) << 16;
 	bits |= devpriv->stc_readw(dev, reg + 1);
 	return bits;
@@ -758,6 +776,7 @@ static uint32_t win_in2(struct comedi_device *dev, int reg)
 static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data,
 				  int addr)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->window_lock, flags);
@@ -769,6 +788,7 @@ static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data,
 static inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data,
 				  int addr)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->window_lock, flags);
@@ -779,6 +799,7 @@ static inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data,
 
 static inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 	unsigned short data;
 
@@ -814,6 +835,7 @@ static inline void ni_set_bits(struct comedi_device *dev, int reg,
 static irqreturn_t ni_E_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct ni_private *devpriv = dev->private;
 	unsigned short a_status;
 	unsigned short b_status;
 	unsigned int ai_mite_status = 0;
@@ -872,6 +894,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 #ifdef PCIDMA
 static void ni_sync_ai_dma(struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	unsigned long flags;
 
@@ -884,6 +907,7 @@ static void ni_sync_ai_dma(struct comedi_device *dev)
 static void mite_handle_b_linkc(struct mite_struct *mite,
 				struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AO_SUBDEV];
 	unsigned long flags;
 
@@ -896,6 +920,7 @@ static void mite_handle_b_linkc(struct mite_struct *mite,
 
 static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
 	static const int timeout = 10000;
 	int i;
 	for (i = 0; i < timeout; i++) {
@@ -918,6 +943,8 @@ static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 #endif /* PCIDMA */
 static void ni_handle_eos(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct ni_private *devpriv = dev->private;
+
 	if (devpriv->aimode == AIMODE_SCAN) {
 #ifdef PCIDMA
 		static const int timeout = 10;
@@ -984,6 +1011,7 @@ static void handle_gpct_interrupt(struct comedi_device *dev,
 				  unsigned short counter_index)
 {
 #ifdef PCIDMA
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 
 	s = &dev->subdevices[NI_GPCT_SUBDEV(counter_index)];
@@ -997,6 +1025,7 @@ static void handle_gpct_interrupt(struct comedi_device *dev,
 
 static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned short ack = 0;
 
 	if (a_status & AI_SC_TC_St) {
@@ -1019,6 +1048,7 @@ static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			       unsigned ai_mite_status)
 {
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 
 	/* 67xx boards don't have ai subdevice, but their gpct0 might generate an a interrupt */
@@ -1122,7 +1152,9 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 
 static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned short ack = 0;
+
 	if (b_status & AO_BC_TC_St) {
 		ack |= AO_BC_TC_Interrupt_Ack;
 	}
@@ -1151,8 +1183,10 @@ static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
 static void handle_b_interrupt(struct comedi_device *dev,
 			       unsigned short b_status, unsigned ao_mite_status)
 {
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AO_SUBDEV];
 	/* unsigned short ack=0; */
+
 #ifdef DEBUG_INTERRUPT
 	printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
 	       b_status, ao_mite_status);
@@ -1340,6 +1374,7 @@ static int ni_ao_fifo_half_empty(struct comedi_device *dev,
 static int ni_ao_prep_fifo(struct comedi_device *dev,
 			   struct comedi_subdevice *s)
 {
+	struct ni_private *devpriv = dev->private;
 	int n;
 
 	/* reset fifo */
@@ -1364,6 +1399,7 @@ static int ni_ao_prep_fifo(struct comedi_device *dev,
 static void ni_ai_fifo_read(struct comedi_device *dev,
 			    struct comedi_subdevice *s, int n)
 {
+	struct ni_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	int i;
 
@@ -1434,6 +1470,7 @@ static void ni_handle_fifo_half_full(struct comedi_device *dev)
 #ifdef PCIDMA
 static int ni_ai_drain_dma(struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
 	int i;
 	static const int timeout = 10000;
 	unsigned long flags;
@@ -1471,6 +1508,7 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 */
 static void ni_handle_fifo_dregs(struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	short data[2];
 	u32 dl;
@@ -1535,6 +1573,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 
 static void get_last_sample_611x(struct comedi_device *dev)
 {
+	struct ni_private *devpriv __maybe_unused = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	short data;
 	u32 dl;
@@ -1552,6 +1591,7 @@ static void get_last_sample_611x(struct comedi_device *dev)
 
 static void get_last_sample_6143(struct comedi_device *dev)
 {
+	struct ni_private *devpriv __maybe_unused = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	short data;
 	u32 dl;
@@ -1574,11 +1614,13 @@ static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 			void *data, unsigned int num_bytes,
 			unsigned int chan_index)
 {
+	struct ni_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	unsigned int i;
 	unsigned int length = num_bytes / bytes_per_sample(s);
 	short *array = data;
 	unsigned int *larray = data;
+
 	for (i = 0; i < length; i++) {
 #ifdef PCIDMA
 		if (s->subdev_flags & SDF_LSAMPL)
@@ -1599,6 +1641,7 @@ static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	int retval;
 	unsigned long flags;
@@ -1638,6 +1681,7 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 
 static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[NI_AO_SUBDEV];
 	int retval;
 	unsigned long flags;
@@ -1676,6 +1720,8 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 
 static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct ni_private *devpriv = dev->private;
+
 	ni_release_ai_mite_channel(dev);
 	/* ai configuration */
 	devpriv->stc_writew(dev, AI_Configuration_Start | AI_Reset,
@@ -1786,6 +1832,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
 	int i, n;
 	const unsigned int mask = (1 << boardtype.adbits) - 1;
 	unsigned signbits;
@@ -1881,7 +1928,9 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 
 static void ni_prime_channelgain_list(struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
 	int i;
+
 	devpriv->stc_writew(dev, AI_CONVERT_Pulse, AI_Command_1_Register);
 	for (i = 0; i < NI_TIMEOUT; ++i) {
 		if (!(devpriv->stc_readw(dev,
@@ -1899,6 +1948,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 					      unsigned int n_chan,
 					      unsigned int *list)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned int chan, range, aref;
 	unsigned int i;
 	unsigned offset;
@@ -2004,6 +2054,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 static void ni_load_channelgain_list(struct comedi_device *dev,
 				     unsigned int n_chan, unsigned int *list)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned int chan, range, aref;
 	unsigned int i;
 	unsigned int hi, lo;
@@ -2122,7 +2173,9 @@ static void ni_load_channelgain_list(struct comedi_device *dev,
 static int ni_ns_to_timer(const struct comedi_device *dev, unsigned nanosec,
 			  int round_mode)
 {
+	struct ni_private *devpriv = dev->private;
 	int divider;
+
 	switch (round_mode) {
 	case TRIG_ROUND_NEAREST:
 	default:
@@ -2140,6 +2193,8 @@ static int ni_ns_to_timer(const struct comedi_device *dev, unsigned nanosec,
 
 static unsigned ni_timer_to_ns(const struct comedi_device *dev, int timer)
 {
+	struct ni_private *devpriv = dev->private;
+
 	return devpriv->clock_ns * (timer + 1);
 }
 
@@ -2162,6 +2217,7 @@ static unsigned ni_min_ai_scan_period_ns(struct comedi_device *dev,
 static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd)
 {
+	struct ni_private *devpriv = dev->private;
 	int err = 0;
 	int tmp;
 	unsigned int sources;
@@ -2356,6 +2412,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct ni_private *devpriv = dev->private;
 	const struct comedi_cmd *cmd = &s->async->cmd;
 	int timer;
 	int mode1 = 0;		/* mode1 is needed for both stop and convert */
@@ -2662,6 +2719,8 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int ni_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 			 unsigned int trignum)
 {
+	struct ni_private *devpriv = dev->private;
+
 	if (trignum != 0)
 		return -EINVAL;
 
@@ -2681,6 +2740,8 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
+
 	if (insn->n < 1)
 		return -EINVAL;
 
@@ -2734,6 +2795,7 @@ static int ni_ai_config_analog_trig(struct comedi_device *dev,
 				    struct comedi_insn *insn,
 				    unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned int a, b, modebits;
 	int err = 0;
 
@@ -2857,6 +2919,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 					  unsigned int chanspec[],
 					  unsigned int n_chans, int timed)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned int range;
 	unsigned int chan;
 	unsigned int conf;
@@ -2928,6 +2991,7 @@ static int ni_old_ao_config_chanlist(struct comedi_device *dev,
 				     unsigned int chanspec[],
 				     unsigned int n_chans)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned int range;
 	unsigned int chan;
 	unsigned int conf;
@@ -2984,6 +3048,8 @@ static int ni_ao_insn_read(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
+
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
 
 	return 1;
@@ -2993,6 +3059,7 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
 
@@ -3013,6 +3080,7 @@ static int ni_ao_insn_write_671x(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
 
@@ -3031,6 +3099,8 @@ static int ni_ao_insn_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
+
 	switch (data[0]) {
 	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
 		switch (data[1]) {
@@ -3057,6 +3127,7 @@ static int ni_ao_insn_config(struct comedi_device *dev,
 static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 			 unsigned int trignum)
 {
+	struct ni_private *devpriv = dev->private;
 	int ret;
 	int interrupt_b_bits;
 	int i;
@@ -3126,6 +3197,7 @@ static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct ni_private *devpriv = dev->private;
 	const struct comedi_cmd *cmd = &s->async->cmd;
 	int bits;
 	int i;
@@ -3330,6 +3402,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd)
 {
+	struct ni_private *devpriv = dev->private;
 	int err = 0;
 	int tmp;
 
@@ -3438,6 +3511,8 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct ni_private *devpriv = dev->private;
+
 	/* devpriv->ao0p=0x0000; */
 	/* ni_writew(devpriv->ao0p,AO_Configuration); */
 
@@ -3491,6 +3566,8 @@ static int ni_dio_insn_config(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
+
 #ifdef DEBUG_DIO
 	printk("ni_dio_insn_config() chan=%d io=%d\n",
 	       CR_CHAN(insn->chanspec), data[0]);
@@ -3524,6 +3601,8 @@ static int ni_dio_insn_bits(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
+
 #ifdef DEBUG_DIO
 	printk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);
 #endif
@@ -3552,6 +3631,8 @@ static int ni_m_series_dio_insn_config(struct comedi_device *dev,
 				       struct comedi_insn *insn,
 				       unsigned int *data)
 {
+	struct ni_private *devpriv __maybe_unused = dev->private;
+
 #ifdef DEBUG_DIO
 	printk("ni_m_series_dio_insn_config() chan=%d io=%d\n",
 	       CR_CHAN(insn->chanspec), data[0]);
@@ -3584,6 +3665,8 @@ static int ni_m_series_dio_insn_bits(struct comedi_device *dev,
 				     struct comedi_insn *insn,
 				     unsigned int *data)
 {
+	struct ni_private *devpriv __maybe_unused = dev->private;
+
 #ifdef DEBUG_DIO
 	printk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],
 	       data[1]);
@@ -3680,6 +3763,7 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 
 static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct ni_private *devpriv __maybe_unused = dev->private;
 	const struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;
 	int retval;
@@ -3719,6 +3803,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 			  unsigned int trignum)
 {
 #ifdef PCIDMA
+	struct ni_private *devpriv = dev->private;
 	unsigned long flags;
 #endif
 	int retval = 0;
@@ -3766,6 +3851,8 @@ static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct ni_private *devpriv __maybe_unused = dev->private;
+
 	ni_writel(CDO_Disarm_Bit | CDO_Error_Interrupt_Enable_Clear_Bit |
 		  CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
 		  CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
@@ -3781,6 +3868,7 @@ static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static void handle_cdio_interrupt(struct comedi_device *dev)
 {
+	struct ni_private *devpriv __maybe_unused = dev->private;
 	unsigned cdio_status;
 	struct comedi_subdevice *s = &dev->subdevices[NI_DIO_SUBDEV];
 #ifdef PCIDMA
@@ -3824,6 +3912,7 @@ static int ni_serial_insn_config(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
 	int err = insn->n;
 	unsigned char byte_out, byte_in = 0;
 
@@ -3920,6 +4009,7 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev,
 				   unsigned char data_out,
 				   unsigned char *data_in)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned int status1;
 	int err = 0, count = 20;
 
@@ -3978,6 +4068,7 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 				   unsigned char data_out,
 				   unsigned char *data_in)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned char mask, input = 0;
 
 #ifdef DEBUG_DIO
@@ -4031,9 +4122,10 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 
 static void mio_common_detach(struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 
-	if (dev->private) {
+	if (devpriv) {
 		if (devpriv->counter_dev) {
 			ni_gpct_device_destroy(devpriv->counter_dev);
 		}
@@ -4151,6 +4243,7 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 				   enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
+	struct ni_private *devpriv = dev->private;
 	unsigned stc_register;
 	/* bits in the join reset register which are relevant to counters */
 	static const unsigned gpct_joint_reset_mask = G0_Reset | G1_Reset;
@@ -4219,7 +4312,9 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 				      enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
+	struct ni_private *devpriv = dev->private;
 	unsigned stc_register;
+
 	switch (reg) {
 		/* m-series only registers */
 	case NITIO_G0_DMA_Status_Reg:
@@ -4251,6 +4346,8 @@ static int ni_freq_out_insn_read(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
+
 	data[0] = devpriv->clock_and_fout & FOUT_Divider_mask;
 	return 1;
 }
@@ -4259,6 +4356,8 @@ static int ni_freq_out_insn_write(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
+
 	devpriv->clock_and_fout &= ~FOUT_Enable;
 	devpriv->stc_writew(dev, devpriv->clock_and_fout,
 			    Clock_and_FOUT_Register);
@@ -4273,6 +4372,8 @@ static int ni_freq_out_insn_write(struct comedi_device *dev,
 static int ni_set_freq_out_clock(struct comedi_device *dev,
 				 unsigned int clock_source)
 {
+	struct ni_private *devpriv = dev->private;
+
 	switch (clock_source) {
 	case NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC:
 		devpriv->clock_and_fout &= ~FOUT_Timebase_Select;
@@ -4292,6 +4393,8 @@ static void ni_get_freq_out_clock(struct comedi_device *dev,
 				  unsigned int *clock_source,
 				  unsigned int *clock_period_ns)
 {
+	struct ni_private *devpriv = dev->private;
+
 	if (devpriv->clock_and_fout & FOUT_Timebase_Select) {
 		*clock_source = NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC;
 		*clock_period_ns = TIMEBASE_2_NS;
@@ -4320,11 +4423,13 @@ static int ni_freq_out_insn_config(struct comedi_device *dev,
 
 static int ni_alloc_private(struct comedi_device *dev)
 {
+	struct ni_private *devpriv;
 	int ret;
 
-	ret = alloc_private(dev, sizeof(struct ni_private));
-	if (ret < 0)
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
 		return ret;
+	devpriv = dev->private;
 
 	spin_lock_init(&devpriv->window_lock);
 	spin_lock_init(&devpriv->soft_reg_copy_lock);
@@ -4335,6 +4440,7 @@ static int ni_alloc_private(struct comedi_device *dev)
 
 static int ni_E_init(struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	unsigned j;
 	enum ni_gpct_variant counter_variant;
@@ -4661,6 +4767,7 @@ static int ni_E_init(struct comedi_device *dev)
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 {
 	struct comedi_device *dev = (struct comedi_device *)arg;
+	struct ni_private *devpriv __maybe_unused = dev->private;
 
 	if (dir) {
 		ni_writeb(data, Port_A + 2 * port);
@@ -4689,6 +4796,7 @@ static int ni_eeprom_insn_read(struct comedi_device *dev,
 
 static int ni_read_eeprom(struct comedi_device *dev, int addr)
 {
+	struct ni_private *devpriv __maybe_unused = dev->private;
 	int bit;
 	int bitstring;
 
@@ -4716,6 +4824,8 @@ static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
 					struct comedi_insn *insn,
 					unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
+
 	data[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];
 
 	return 1;
@@ -4723,6 +4833,8 @@ static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
 
 static int ni_get_pwm_config(struct comedi_device *dev, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
+
 	data[1] = devpriv->pwm_up_count * devpriv->clock_ns;
 	data[2] = devpriv->pwm_down_count * devpriv->clock_ns;
 	return 3;
@@ -4732,7 +4844,9 @@ static int ni_m_series_pwm_config(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned up_count, down_count;
+
 	switch (data[0]) {
 	case INSN_CONFIG_PWM_OUTPUT:
 		switch (data[1]) {
@@ -4798,7 +4912,9 @@ static int ni_6143_pwm_config(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned up_count, down_count;
+
 	switch (data[0]) {
 	case INSN_CONFIG_PWM_OUTPUT:
 		switch (data[1]) {
@@ -4875,6 +4991,8 @@ static int ni_calib_insn_read(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
+
 	data[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];
 
 	return 1;
@@ -4905,6 +5023,7 @@ static struct caldac_struct caldacs[] = {
 
 static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct ni_private *devpriv = dev->private;
 	int i, j;
 	int n_dacs;
 	int n_chans = 0;
@@ -4958,6 +5077,7 @@ static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned int loadbit = 0, bits = 0, bit, bitstring = 0;
 	int i;
 	int type;
@@ -5211,8 +5331,10 @@ static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static int ni_m_series_set_pfi_routing(struct comedi_device *dev, unsigned chan,
 				       unsigned source)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned pfi_reg_index;
 	unsigned array_offset;
+
 	if ((source & 0x1f) != source)
 		return -EINVAL;
 	pfi_reg_index = 1 + chan / 3;
@@ -5247,7 +5369,9 @@ static int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,
 static unsigned ni_m_series_get_pfi_routing(struct comedi_device *dev,
 					    unsigned chan)
 {
+	struct ni_private *devpriv = dev->private;
 	const unsigned array_offset = chan / 3;
+
 	return MSeries_PFI_Output_Select_Source(chan,
 						devpriv->
 						pfi_output_select_reg
@@ -5306,7 +5430,9 @@ static unsigned ni_get_pfi_routing(struct comedi_device *dev, unsigned chan)
 static int ni_config_filter(struct comedi_device *dev, unsigned pfi_channel,
 			    enum ni_pfi_filter_select filter)
 {
+	struct ni_private *devpriv __maybe_unused = dev->private;
 	unsigned bits;
+
 	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
 		return -ENOTSUPP;
 	}
@@ -5321,6 +5447,8 @@ static int ni_pfi_insn_bits(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv __maybe_unused = dev->private;
+
 	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
 		return -ENOTSUPP;
 	}
@@ -5337,6 +5465,7 @@ static int ni_pfi_insn_config(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned int chan;
 
 	if (insn->n < 1)
@@ -5379,6 +5508,8 @@ static int ni_pfi_insn_config(struct comedi_device *dev,
  */
 static void ni_rtsi_init(struct comedi_device *dev)
 {
+	struct ni_private *devpriv = dev->private;
+
 	/*  Initialises the RTSI bus signal switch to a default state */
 
 	/*  Set clock mode to internal */
@@ -5480,6 +5611,7 @@ static inline unsigned num_configurable_rtsi_channels(struct comedi_device *dev)
 static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 					   unsigned source, unsigned period_ns)
 {
+	struct ni_private *devpriv = dev->private;
 	static const unsigned min_period_ns = 50;
 	static const unsigned max_period_ns = 1000;
 	static const unsigned timeout = 1000;
@@ -5488,6 +5620,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 	unsigned freq_multiplier;
 	unsigned i;
 	int retval;
+
 	if (source == NI_MIO_PLL_PXI10_CLOCK)
 		period_ns = 100;
 	/*  these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that */
@@ -5581,6 +5714,8 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
 static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 			       unsigned period_ns)
 {
+	struct ni_private *devpriv = dev->private;
+
 	if (source == NI_MIO_INTERNAL_CLOCK) {
 		devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
 		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
@@ -5666,6 +5801,8 @@ static int ni_valid_rtsi_output_source(struct comedi_device *dev, unsigned chan,
 static int ni_set_rtsi_routing(struct comedi_device *dev, unsigned chan,
 			       unsigned source)
 {
+	struct ni_private *devpriv = dev->private;
+
 	if (ni_valid_rtsi_output_source(dev, chan, source) == 0)
 		return -EINVAL;
 	if (chan < 4) {
@@ -5686,6 +5823,8 @@ static int ni_set_rtsi_routing(struct comedi_device *dev, unsigned chan,
 
 static unsigned ni_get_rtsi_routing(struct comedi_device *dev, unsigned chan)
 {
+	struct ni_private *devpriv = dev->private;
+
 	if (chan < 4) {
 		return RTSI_Trig_Output_Source(chan,
 					       devpriv->rtsi_trig_a_output_reg);
@@ -5704,7 +5843,9 @@ static int ni_rtsi_insn_config(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
+	struct ni_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
+
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
 		if (chan < num_configurable_rtsi_channels(dev)) {

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 4bbb9798af7e..3e5fdae93163 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2164,61 +2164,38 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 {
 	int err = 0;
 	int tmp;
-	int sources;
+	unsigned int sources;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	if ((cmd->flags & CMDF_WRITE)) {
+	if ((cmd->flags & CMDF_WRITE))
 		cmd->flags &= ~CMDF_WRITE;
-	}
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_INT | TRIG_EXT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src,
+					TRIG_NOW | TRIG_INT | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_TIMER | TRIG_EXT);
 
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
 	sources = TRIG_TIMER | TRIG_EXT;
-	if ((boardtype.reg_type == ni_reg_611x)
-	    || (boardtype.reg_type == ni_reg_6143))
+	if (boardtype.reg_type == ni_reg_611x ||
+	    boardtype.reg_type == ni_reg_6143)
 		sources |= TRIG_NOW;
-	cmd->convert_src &= sources;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->convert_src, sources);
 
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* Step 2a : make sure trigger sources are unique */
 
-	/* note that mutual compatibility is not an issue here */
-	if (cmd->start_src != TRIG_NOW &&
-	    cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)
-		err++;
-	if (cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_EXT &&
-	    cmd->scan_begin_src != TRIG_OTHER)
-		err++;
-	if (cmd->convert_src != TRIG_TIMER &&
-	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;
@@ -3356,44 +3333,28 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	int err = 0;
 	int tmp;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	if ((cmd->flags & CMDF_WRITE) == 0) {
+	if ((cmd->flags & CMDF_WRITE) == 0)
 		cmd->flags |= CMDF_WRITE;
-	}
-
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_INT | TRIG_EXT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
 
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_TIMER | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* Step 2a : make sure trigger sources are unique */
 
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;
@@ -3643,51 +3604,21 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 {
 	int err = 0;
 	int tmp;
-	int sources;
 	unsigned i;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	sources = TRIG_INT;
-	cmd->start_src &= sources;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique... */
-
-	if (cmd->start_src != TRIG_INT)
-		err++;
-	if (cmd->scan_begin_src != TRIG_EXT)
-		err++;
-	if (cmd->convert_src != TRIG_NOW)
-		err++;
-	if (cmd->stop_src != TRIG_NONE)
-		err++;
-	/* ... and mutually compatible */
+	/* Step 2a : make sure trigger sources are unique */
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit 3cd73bc1cf59b2c9232d9889ba2b148e262054b6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 24 16:27:59 2012 +0100

    staging: comedi: ni_mio_common: always lock in ni_ai_poll()
    
    `ni_ai_poll()` currently acquires (and later releases) the comedi
    device's spin-lock iff `in_interrupt()` returns 0.  However, it is only
    called during processing of a `COMEDI_POLL` ioctl so `in_interrupt()`
    will always return 0 in this case.  Remove this test and acquire/release
    the spin-lock unconditionally.  This eliminates a sparse warning about
    different lock contexts for basic block.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 87995da00f61..4bbb9798af7e 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1766,20 +1766,18 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int ni_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	unsigned long flags = 0;
+	unsigned long flags;
 	int count;
 
 	/*  lock to avoid race with interrupt handler */
-	if (in_interrupt() == 0)
-		spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 #ifndef PCIDMA
 	ni_handle_fifo_dregs(dev);
 #else
 	ni_sync_ai_dma(dev);
 #endif
 	count = s->async->buf_write_count - s->async->buf_read_count;
-	if (in_interrupt() == 0)
-		spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return count;
 }

commit 29aba763060a2c44a7449dff1579f0fed52ea567
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 17 13:13:32 2012 -0700

    staging: comedi: ni_mio_common: make internal functions static
    
    The functions ni_release_gpct_mite_channel() and ni_prime_channelgain_list()
    are only referenced in this file. Make it static.
    
    The function ni_release_gpct_mite_channel() is also only called
    when PCIDMA is enabled. Move the #ifdef to quite a sparse warning
    about the function not being used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8fd967aec3b3..87995da00f61 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -644,10 +644,10 @@ static void ni_release_ao_mite_channel(struct comedi_device *dev)
 #endif /*  PCIDMA */
 }
 
-void ni_release_gpct_mite_channel(struct comedi_device *dev,
-				  unsigned gpct_index)
-{
 #ifdef PCIDMA
+static void ni_release_gpct_mite_channel(struct comedi_device *dev,
+					 unsigned gpct_index)
+{
 	unsigned long flags;
 
 	BUG_ON(gpct_index >= NUM_GPCT);
@@ -663,8 +663,8 @@ void ni_release_gpct_mite_channel(struct comedi_device *dev,
 		mite_release_channel(mite_chan);
 	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif /*  PCIDMA */
 }
+#endif /*  PCIDMA */
 
 static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 {
@@ -1881,7 +1881,7 @@ static int ni_ai_insn_read(struct comedi_device *dev,
 	return insn->n;
 }
 
-void ni_prime_channelgain_list(struct comedi_device *dev)
+static void ni_prime_channelgain_list(struct comedi_device *dev)
 {
 	int i;
 	devpriv->stc_writew(dev, AI_CONVERT_Pulse, AI_Command_1_Register);

commit 5b6137d8807524c9ecd9a35ff77421ab52a8e955
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Sep 14 17:34:18 2012 +0100

    staging: comedi: ni_mio_common: don't pass config options to ni_E_init()
    
    `ni_E_init()` doesn't use the second parameter pointing to a `struct
    comedi_devconfig` passed from a comedi `attach` handler, so remove the
    parameter.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 68f3bddaf753..8fd967aec3b3 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4404,7 +4404,7 @@ static int ni_alloc_private(struct comedi_device *dev)
 	return 0;
 };
 
-static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
+static int ni_E_init(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s;
 	unsigned j;

commit f9cd92eb81ea5edea0fb3d0f778a5aef35532a31
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:50:19 2012 -0700

    staging: comedi: ni_mio_common: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index cf0e0d147f8c..68f3bddaf753 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -872,7 +872,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 #ifdef PCIDMA
 static void ni_sync_ai_dma(struct comedi_device *dev)
 {
-	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
@@ -884,7 +884,7 @@ static void ni_sync_ai_dma(struct comedi_device *dev)
 static void mite_handle_b_linkc(struct mite_struct *mite,
 				struct comedi_device *dev)
 {
-	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AO_SUBDEV];
 	unsigned long flags;
 
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
@@ -942,7 +942,7 @@ static void ni_handle_eos(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static void shutdown_ai_command(struct comedi_device *dev)
 {
-	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 
 #ifdef PCIDMA
 	ni_ai_drain_dma(dev);
@@ -984,8 +984,9 @@ static void handle_gpct_interrupt(struct comedi_device *dev,
 				  unsigned short counter_index)
 {
 #ifdef PCIDMA
-	struct comedi_subdevice *s =
-	    dev->subdevices + NI_GPCT_SUBDEV(counter_index);
+	struct comedi_subdevice *s;
+
+	s = &dev->subdevices[NI_GPCT_SUBDEV(counter_index)];
 
 	ni_tio_handle_interrupt(&devpriv->counter_dev->counters[counter_index],
 				s);
@@ -1018,7 +1019,7 @@ static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			       unsigned ai_mite_status)
 {
-	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 
 	/* 67xx boards don't have ai subdevice, but their gpct0 might generate an a interrupt */
 	if (s->type == COMEDI_SUBD_UNUSED)
@@ -1150,7 +1151,7 @@ static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
 static void handle_b_interrupt(struct comedi_device *dev,
 			       unsigned short b_status, unsigned ao_mite_status)
 {
-	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AO_SUBDEV];
 	/* unsigned short ack=0; */
 #ifdef DEBUG_INTERRUPT
 	printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
@@ -1422,7 +1423,7 @@ static void ni_ai_fifo_read(struct comedi_device *dev,
 static void ni_handle_fifo_half_full(struct comedi_device *dev)
 {
 	int n;
-	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 
 	n = boardtype.ai_fifo_depth / 2;
 
@@ -1470,7 +1471,7 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 */
 static void ni_handle_fifo_dregs(struct comedi_device *dev)
 {
-	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	short data[2];
 	u32 dl;
 	short fifo_empty;
@@ -1534,7 +1535,7 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 
 static void get_last_sample_611x(struct comedi_device *dev)
 {
-	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	short data;
 	u32 dl;
 
@@ -1551,7 +1552,7 @@ static void get_last_sample_611x(struct comedi_device *dev)
 
 static void get_last_sample_6143(struct comedi_device *dev)
 {
-	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	short data;
 	u32 dl;
 
@@ -1598,7 +1599,7 @@ static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 {
-	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AI_SUBDEV];
 	int retval;
 	unsigned long flags;
 
@@ -1637,7 +1638,7 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 
 static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 {
-	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
+	struct comedi_subdevice *s = &dev->subdevices[NI_AO_SUBDEV];
 	int retval;
 	unsigned long flags;
 
@@ -3852,7 +3853,7 @@ static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static void handle_cdio_interrupt(struct comedi_device *dev)
 {
 	unsigned cdio_status;
-	struct comedi_subdevice *s = dev->subdevices + NI_DIO_SUBDEV;
+	struct comedi_subdevice *s = &dev->subdevices[NI_DIO_SUBDEV];
 #ifdef PCIDMA
 	unsigned long flags;
 #endif
@@ -4101,13 +4102,17 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev,
 
 static void mio_common_detach(struct comedi_device *dev)
 {
+	struct comedi_subdevice *s;
+
 	if (dev->private) {
 		if (devpriv->counter_dev) {
 			ni_gpct_device_destroy(devpriv->counter_dev);
 		}
 	}
-	if (dev->subdevices && boardtype.has_8255)
-		subdev_8255_cleanup(dev, dev->subdevices + NI_8255_DIO_SUBDEV);
+	if (dev->subdevices && boardtype.has_8255) {
+		s = &dev->subdevices[NI_8255_DIO_SUBDEV];
+		subdev_8255_cleanup(dev, s);
+	}
 }
 
 static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -4417,7 +4422,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* analog input subdevice */
 
-	s = dev->subdevices + NI_AI_SUBDEV;
+	s = &dev->subdevices[NI_AI_SUBDEV];
 	dev->read_subdev = s;
 	if (boardtype.n_adchan) {
 		s->type = COMEDI_SUBD_AI;
@@ -4449,7 +4454,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* analog output subdevice */
 
-	s = dev->subdevices + NI_AO_SUBDEV;
+	s = &dev->subdevices[NI_AO_SUBDEV];
 	if (boardtype.n_aochan) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_WRITABLE | SDF_DEGLITCH | SDF_GROUND;
@@ -4488,7 +4493,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* digital i/o subdevice */
 
-	s = dev->subdevices + NI_DIO_SUBDEV;
+	s = &dev->subdevices[NI_DIO_SUBDEV];
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
 	s->maxdata = 1;
@@ -4516,7 +4521,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	/* 8255 device */
-	s = dev->subdevices + NI_8255_DIO_SUBDEV;
+	s = &dev->subdevices[NI_8255_DIO_SUBDEV];
 	if (boardtype.has_8255) {
 		subdev_8255_init(dev, s, ni_8255_callback, (unsigned long)dev);
 	} else {
@@ -4524,11 +4529,11 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	/* formerly general purpose counter/timer device, but no longer used */
-	s = dev->subdevices + NI_UNUSED_SUBDEV;
+	s = &dev->subdevices[NI_UNUSED_SUBDEV];
 	s->type = COMEDI_SUBD_UNUSED;
 
 	/* calibration subdevice -- ai and ao */
-	s = dev->subdevices + NI_CALIBRATION_SUBDEV;
+	s = &dev->subdevices[NI_CALIBRATION_SUBDEV];
 	s->type = COMEDI_SUBD_CALIB;
 	if (boardtype.reg_type & ni_reg_m_series_mask) {
 		/*  internal PWM analog output used for AI nonlinearity calibration */
@@ -4551,7 +4556,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	/* EEPROM */
-	s = dev->subdevices + NI_EEPROM_SUBDEV;
+	s = &dev->subdevices[NI_EEPROM_SUBDEV];
 	s->type = COMEDI_SUBD_MEMORY;
 	s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
 	s->maxdata = 0xff;
@@ -4564,7 +4569,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	/* PFI */
-	s = dev->subdevices + NI_PFI_DIO_SUBDEV;
+	s = &dev->subdevices[NI_PFI_DIO_SUBDEV];
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 	if (boardtype.reg_type & ni_reg_m_series_mask) {
@@ -4586,7 +4591,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 	ni_set_bits(dev, IO_Bidirection_Pin_Register, ~0, 0);
 
 	/* cs5529 calibration adc */
-	s = dev->subdevices + NI_CS5529_CALIBRATION_SUBDEV;
+	s = &dev->subdevices[NI_CS5529_CALIBRATION_SUBDEV];
 	if (boardtype.reg_type & ni_reg_67xx_mask) {
 		s->type = COMEDI_SUBD_AI;
 		s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_INTERNAL;
@@ -4602,7 +4607,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	/* Serial */
-	s = dev->subdevices + NI_SERIAL_SUBDEV;
+	s = &dev->subdevices[NI_SERIAL_SUBDEV];
 	s->type = COMEDI_SUBD_SERIAL;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 	s->n_chan = 1;
@@ -4612,7 +4617,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->serial_hw_mode = 0;
 
 	/* RTSI */
-	s = dev->subdevices + NI_RTSI_SUBDEV;
+	s = &dev->subdevices[NI_RTSI_SUBDEV];
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 	s->n_chan = 8;
@@ -4633,7 +4638,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 							NUM_GPCT);
 	/* General purpose counters */
 	for (j = 0; j < NUM_GPCT; ++j) {
-		s = dev->subdevices + NI_GPCT_SUBDEV(j);
+		s = &dev->subdevices[NI_GPCT_SUBDEV(j)];
 		s->type = COMEDI_SUBD_COUNTER;
 		s->subdev_flags =
 		    SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL | SDF_CMD_READ
@@ -4659,7 +4664,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	/* Frequency output */
-	s = dev->subdevices + NI_FREQ_OUT_SUBDEV;
+	s = &dev->subdevices[NI_FREQ_OUT_SUBDEV];
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
 	s->n_chan = 1;
@@ -4669,7 +4674,8 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->insn_config = &ni_freq_out_insn_config;
 
 	/* ai configuration */
-	ni_ai_reset(dev, dev->subdevices + NI_AI_SUBDEV);
+	s = &dev->subdevices[NI_AI_SUBDEV];
+	ni_ai_reset(dev, s);
 	if ((boardtype.reg_type & ni_reg_6xxx_mask) == 0) {
 		/*  BEAM is this needed for PCI-6143 ?? */
 		devpriv->clock_and_fout =
@@ -4688,7 +4694,8 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 			    Clock_and_FOUT_Register);
 
 	/* analog output configuration */
-	ni_ao_reset(dev, dev->subdevices + NI_AO_SUBDEV);
+	s = &dev->subdevices[NI_AO_SUBDEV];
+	ni_ao_reset(dev, s);
 
 	if (dev->irq) {
 		devpriv->stc_writew(dev,

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 42df64ec921a..cf0e0d147f8c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3584,7 +3584,7 @@ static int ni_dio_insn_bits(struct comedi_device *dev,
 	}
 	data[1] = devpriv->stc_readw(dev, DIO_Parallel_Input_Register);
 
-	return 2;
+	return insn->n;
 }
 
 static int ni_m_series_dio_insn_config(struct comedi_device *dev,
@@ -3636,7 +3636,7 @@ static int ni_m_series_dio_insn_bits(struct comedi_device *dev,
 	}
 	data[1] = ni_readl(M_Offset_Static_Digital_Input);
 
-	return 2;
+	return insn->n;
 }
 
 static int ni_cdio_cmdtest(struct comedi_device *dev,
@@ -5394,7 +5394,7 @@ static int ni_pfi_insn_bits(struct comedi_device *dev,
 		ni_writew(s->state, M_Offset_PFI_DO);
 	}
 	data[1] = ni_readw(M_Offset_PFI_DI);
-	return 2;
+	return insn->n;
 }
 
 static int ni_pfi_insn_config(struct comedi_device *dev,
@@ -5485,7 +5485,7 @@ static int ni_rtsi_insn_bits(struct comedi_device *dev,
 {
 	data[1] = 0;
 
-	return 2;
+	return insn->n;
 }
 
 /* Find best multiplier/divider to try and get the PLL running at 80 MHz

commit 520706607befd1f5c20ec14db35d6be45791bc41
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 11:18:25 2012 -0700

    staging: comedi: remove unneeded sanity check in insn_bits functions
    
    The comedi core does the sanity check to make sure that the data length
    the INSN_BITS instruction is 2. There is no need for the drivers to do
    this check. Remove all the sanity checks in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 1f796b9361b2..42df64ec921a 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3567,8 +3567,7 @@ static int ni_dio_insn_bits(struct comedi_device *dev,
 #ifdef DEBUG_DIO
 	printk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);
 #endif
-	if (insn->n != 2)
-		return -EINVAL;
+
 	if (data[0]) {
 		/* Perform check to make sure we're not using the
 		   serial part of the dio */
@@ -3629,8 +3628,7 @@ static int ni_m_series_dio_insn_bits(struct comedi_device *dev,
 	printk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],
 	       data[1]);
 #endif
-	if (insn->n != 2)
-		return -EINVAL;
+
 	if (data[0]) {
 		s->state &= ~data[0];
 		s->state |= (data[0] & data[1]);
@@ -5485,9 +5483,6 @@ static int ni_rtsi_insn_bits(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	if (insn->n != 2)
-		return -EINVAL;
-
 	data[1] = 0;
 
 	return 2;

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 4261e929869f..1f796b9361b2 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4406,14 +4406,16 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	unsigned j;
 	enum ni_gpct_variant counter_variant;
+	int ret;
 
 	if (boardtype.n_aochan > MAX_N_AO_CHAN) {
 		printk("bug! boardtype.n_aochan > MAX_N_AO_CHAN\n");
 		return -EINVAL;
 	}
 
-	if (comedi_alloc_subdevices(dev, NI_NUM_SUBDEVICES) < 0)
-		return -ENOMEM;
+	ret = comedi_alloc_subdevices(dev, NI_NUM_SUBDEVICES);
+	if (ret)
+		return ret;
 
 	/* analog input subdevice */
 

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index fd232bc5f873..4261e929869f 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4412,7 +4412,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EINVAL;
 	}
 
-	if (alloc_subdevices(dev, NI_NUM_SUBDEVICES) < 0)
+	if (comedi_alloc_subdevices(dev, NI_NUM_SUBDEVICES) < 0)
 		return -ENOMEM;
 
 	/* analog input subdevice */

commit 95cd17c9f3734091a5811fabbd778e3f7b1f0789
Author: Joe Perches <joe@perches.com>
Date:   Sun Apr 10 14:31:35 2011 -0700

    staging: Remove unnecessary semicolons when switch (foo) {...};
    
    Done via perl script:
    
    $ cat remove_semi_switch.pl
    my $match_balanced_parentheses = qr/(\((?:[^\(\)]++|(?-1))*\))/;
    my $match_balanced_braces      = qr/(\{(?:[^\{\}]++|(?-1))*\})/;
    
    foreach my $file (@ARGV) {
        my $f;
        my $text;
        my $oldtext;
    
        next if ((-d $file));
    
        open($f, '<', $file)
            or die "$P: Can't open $file for read\n";
        $oldtext = do { local($/) ; <$f> };
        close($f);
    
        next if ($oldtext eq "");
    
        $text = $oldtext;
    
        my $count = 0;
        do {
            $count = 0;
            $count += $text =~ s@\b(switch\s*${match_balanced_parentheses}\s*)${match_balanced_braces}\s*;@"$1$3"@egx;
        } while ($count > 0);
    
        if ($text ne $oldtext) {
            my $newfile = $file;
    
            open($f, '>', $newfile)
                or die "$P: Can't open $newfile for write\n";
            print $f $text;
            close($f);
        }
    }
    
    $
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 986ef6712989..fd232bc5f873 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1627,7 +1627,7 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 	default:
 		mite_prep_dma(devpriv->ai_mite_chan, 16, 16);
 		break;
-	};
+	}
 	/*start the MITE */
 	mite_dma_arm(devpriv->ai_mite_chan);
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
@@ -2156,7 +2156,7 @@ static unsigned ni_min_ai_scan_period_ns(struct comedi_device *dev,
 	default:
 		/*  multiplexed inputs */
 		break;
-	};
+	}
 	return boardtype.ai_speed * num_channels;
 }
 
@@ -5173,7 +5173,7 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
 				    Analog_Trigger_Etc_Register);
 		break;
-	};
+	}
 
 	devpriv->gpct_mode[chan] = 0;
 	devpriv->gpct_input_select[chan] = 0;

commit 631dd1a885b6d7e9f6f51b4e5b311c2bb04c323c
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Oct 18 11:03:14 2010 +0200

    Update broken web addresses in the kernel.
    
    The patch below updates broken web addresses in the kernel
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Finn Thain <fthain@telegraphics.com.au>
    Cc: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Dimitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Mike Frysinger <vapier.adi@gmail.com>
    Acked-by: Ben Pfaff <blp@cs.stanford.edu>
    Acked-by: Hans J. Koch <hjk@linutronix.de>
    Reviewed-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index bd16f913af23..986ef6712989 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -34,7 +34,7 @@
 	   340747b.pdf  AT-MIO E series Register Level Programmer Manual
 	   341079b.pdf  PCI E Series RLPM
 	   340934b.pdf  DAQ-STC reference manual
-	67xx and 611x registers (from http://www.ni.com/pdf/daq/us)
+	67xx and 611x registers (from ftp://ftp.ni.com/support/daq/mhddk/documentation/)
 	release_ni611x.pdf
 	release_ni67xx.pdf
 	Other possibly relevant info:

commit ea12ac4fd241a141cc64683f4293f48bed84fd42
Author: Frank Mori Hess <frank.hess@nist.gov>
Date:   Mon Feb 22 15:32:32 2010 -0500

    Staging: comedi: Increased timeout for digital output dma loading
    
    Increased timeout for digital output dma loading, due to report of it
    being too short for some hardware.
    
    Signed-off-by: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d6d49c3bbf1c..bd16f913af23 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3795,7 +3795,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 #endif
 	int retval = 0;
 	unsigned i;
-	const unsigned timeout = 100;
+	const unsigned timeout = 1000;
 
 	s->async->inttrig = NULL;
 

commit 828684f9a6e096f9150bad523c43b75d74b9badd
Author: Dirk Hohndel <hohndel@infradead.org>
Date:   Tue Sep 29 11:23:44 2009 +0200

    Staging: comedi: trivial fix of a very frequent spelling mistake
    
    something-bility is spelled as something-blity so a grep for 'blit'
    would find these lines
    
    this is so trivial that I didn't split it by subsystem / copy additional
    maintainers - all changes are to comments The only purpose is to get
    fewer false positives when grepping around the kernel sources.
    
    Signed-off-by: Dirk Hohndel <hohndel@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 753ee0512342..d6d49c3bbf1c 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2207,7 +2207,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
-	/* note that mutual compatiblity is not an issue here */
+	/* note that mutual compatibility is not an issue here */
 	if (cmd->start_src != TRIG_NOW &&
 	    cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)
 		err++;

commit 4377a026500a3f59e9c41c23d03e55ff2e712379
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Oct 12 14:58:16 2009 -0700

    Staging: comedi: fix sched.h build breakage
    
    commit d43c36dc removed sched.h from interrupt.h.  This broke some of
    the comedi drivers.  This patch fixes this.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e3ffb067ead1..753ee0512342 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -62,6 +62,7 @@
 /* #define DEBUG_STATUS_B */
 
 #include <linux/interrupt.h>
+#include <linux/sched.h>
 #include "8255.h"
 #include "mite.h"
 #include "comedi_fc.h"

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index d727d7533fc8..e3ffb067ead1 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -77,110 +77,128 @@ static const unsigned old_RTSI_clock_channel = 7;
 /* Note: this table must match the ai_gain_* definitions */
 static const short ni_gainlkup[][16] = {
 	[ai_gain_16] = {0, 1, 2, 3, 4, 5, 6, 7,
-		0x100, 0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107},
+			0x100, 0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107},
 	[ai_gain_8] = {1, 2, 4, 7, 0x101, 0x102, 0x104, 0x107},
 	[ai_gain_14] = {1, 2, 3, 4, 5, 6, 7,
-		0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107},
+			0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107},
 	[ai_gain_4] = {0, 1, 4, 7},
 	[ai_gain_611x] = {0x00a, 0x00b, 0x001, 0x002,
-		0x003, 0x004, 0x005, 0x006},
+			  0x003, 0x004, 0x005, 0x006},
 	[ai_gain_622x] = {0, 1, 4, 5},
 	[ai_gain_628x] = {1, 2, 3, 4, 5, 6, 7},
 	[ai_gain_6143] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
 };
 
 static const struct comedi_lrange range_ni_E_ai = { 16, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(-1, 1),
-			RANGE(-0.5, 0.5),
-			RANGE(-0.25, 0.25),
-			RANGE(-0.1, 0.1),
-			RANGE(-0.05, 0.05),
-			RANGE(0, 20),
-			RANGE(0, 10),
-			RANGE(0, 5),
-			RANGE(0, 2),
-			RANGE(0, 1),
-			RANGE(0, 0.5),
-			RANGE(0, 0.2),
-			RANGE(0, 0.1),
-	}
+							 RANGE(-10, 10),
+							 RANGE(-5, 5),
+							 RANGE(-2.5, 2.5),
+							 RANGE(-1, 1),
+							 RANGE(-0.5, 0.5),
+							 RANGE(-0.25, 0.25),
+							 RANGE(-0.1, 0.1),
+							 RANGE(-0.05, 0.05),
+							 RANGE(0, 20),
+							 RANGE(0, 10),
+							 RANGE(0, 5),
+							 RANGE(0, 2),
+							 RANGE(0, 1),
+							 RANGE(0, 0.5),
+							 RANGE(0, 0.2),
+							 RANGE(0, 0.1),
+							 }
 };
+
 static const struct comedi_lrange range_ni_E_ai_limited = { 8, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-1, 1),
-			RANGE(-0.1, 0.1),
-			RANGE(0, 10),
-			RANGE(0, 5),
-			RANGE(0, 1),
-			RANGE(0, 0.1),
-	}
+								RANGE(-10, 10),
+								RANGE(-5, 5),
+								RANGE(-1, 1),
+								RANGE(-0.1,
+								      0.1),
+								RANGE(0, 10),
+								RANGE(0, 5),
+								RANGE(0, 1),
+								RANGE(0, 0.1),
+								}
 };
+
 static const struct comedi_lrange range_ni_E_ai_limited14 = { 14, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2, 2),
-			RANGE(-1, 1),
-			RANGE(-0.5, 0.5),
-			RANGE(-0.2, 0.2),
-			RANGE(-0.1, 0.1),
-			RANGE(0, 10),
-			RANGE(0, 5),
-			RANGE(0, 2),
-			RANGE(0, 1),
-			RANGE(0, 0.5),
-			RANGE(0, 0.2),
-			RANGE(0, 0.1),
-	}
+								   RANGE(-10,
+									 10),
+								   RANGE(-5, 5),
+								   RANGE(-2, 2),
+								   RANGE(-1, 1),
+								   RANGE(-0.5,
+									 0.5),
+								   RANGE(-0.2,
+									 0.2),
+								   RANGE(-0.1,
+									 0.1),
+								   RANGE(0, 10),
+								   RANGE(0, 5),
+								   RANGE(0, 2),
+								   RANGE(0, 1),
+								   RANGE(0,
+									 0.5),
+								   RANGE(0,
+									 0.2),
+								   RANGE(0,
+									 0.1),
+								   }
 };
+
 static const struct comedi_lrange range_ni_E_ai_bipolar4 = { 4, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-0.5, 0.5),
-			RANGE(-0.05, 0.05),
-	}
+								 RANGE(-10, 10),
+								 RANGE(-5, 5),
+								 RANGE(-0.5,
+								       0.5),
+								 RANGE(-0.05,
+								       0.05),
+								 }
 };
+
 static const struct comedi_lrange range_ni_E_ai_611x = { 8, {
-			RANGE(-50, 50),
-			RANGE(-20, 20),
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2, 2),
-			RANGE(-1, 1),
-			RANGE(-0.5, 0.5),
-			RANGE(-0.2, 0.2),
-	}
+							     RANGE(-50, 50),
+							     RANGE(-20, 20),
+							     RANGE(-10, 10),
+							     RANGE(-5, 5),
+							     RANGE(-2, 2),
+							     RANGE(-1, 1),
+							     RANGE(-0.5, 0.5),
+							     RANGE(-0.2, 0.2),
+							     }
 };
+
 static const struct comedi_lrange range_ni_M_ai_622x = { 4, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-1, 1),
-			RANGE(-0.2, 0.2),
-	}
+							     RANGE(-10, 10),
+							     RANGE(-5, 5),
+							     RANGE(-1, 1),
+							     RANGE(-0.2, 0.2),
+							     }
 };
+
 static const struct comedi_lrange range_ni_M_ai_628x = { 7, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2, 2),
-			RANGE(-1, 1),
-			RANGE(-0.5, 0.5),
-			RANGE(-0.2, 0.2),
-			RANGE(-0.1, 0.1),
-	}
+							     RANGE(-10, 10),
+							     RANGE(-5, 5),
+							     RANGE(-2, 2),
+							     RANGE(-1, 1),
+							     RANGE(-0.5, 0.5),
+							     RANGE(-0.2, 0.2),
+							     RANGE(-0.1, 0.1),
+							     }
 };
+
 static const struct comedi_lrange range_ni_S_ai_6143 = { 1, {
-			RANGE(-5, +5),
-	}
+							     RANGE(-5, +5),
+							     }
 };
+
 static const struct comedi_lrange range_ni_E_ao_ext = { 4, {
-			RANGE(-10, 10),
-			RANGE(0, 10),
-			RANGE_ext(-1, 1),
-			RANGE_ext(0, 1),
-	}
+							    RANGE(-10, 10),
+							    RANGE(0, 10),
+							    RANGE_ext(-1, 1),
+							    RANGE_ext(0, 1),
+							    }
 };
 
 static const struct comedi_lrange *const ni_range_lkup[] = {
@@ -194,46 +212,64 @@ static const struct comedi_lrange *const ni_range_lkup[] = {
 	[ai_gain_6143] = &range_ni_S_ai_6143
 };
 
-static int ni_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_cdio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int ni_dio_insn_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int ni_dio_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int ni_cdio_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd);
 static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ni_cdio_cancel(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
 static void handle_cdio_interrupt(struct comedi_device *dev);
 static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum);
-
-static int ni_serial_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_serial_hw_readwrite8(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned char data_out, unsigned char *data_in);
-static int ni_serial_sw_readwrite8(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned char data_out, unsigned char *data_in);
-
-static int ni_calib_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_calib_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-
-static int ni_eeprom_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  unsigned int trignum);
+
+static int ni_serial_insn_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
+static int ni_serial_hw_readwrite8(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned char data_out,
+				   unsigned char *data_in);
+static int ni_serial_sw_readwrite8(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned char data_out,
+				   unsigned char *data_in);
+
+static int ni_calib_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int ni_calib_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+
+static int ni_eeprom_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
-
-static int ni_pfi_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_pfi_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static unsigned ni_old_get_pfi_routing(struct comedi_device *dev, unsigned chan);
+					struct comedi_subdevice *s,
+					struct comedi_insn *insn,
+					unsigned int *data);
+
+static int ni_pfi_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int ni_pfi_insn_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static unsigned ni_old_get_pfi_routing(struct comedi_device *dev,
+				       unsigned chan);
 
 static void ni_rtsi_init(struct comedi_device *dev);
-static int ni_rtsi_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_rtsi_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int ni_rtsi_insn_bits(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
+static int ni_rtsi_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 
 static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ni_read_eeprom(struct comedi_device *dev, int addr);
@@ -252,53 +288,62 @@ static void ni_mio_print_status_b(int status);
 static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s);
 #ifndef PCIDMA
 static void ni_handle_fifo_half_full(struct comedi_device *dev);
-static int ni_ao_fifo_half_empty(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ni_ao_fifo_half_empty(struct comedi_device *dev,
+				 struct comedi_subdevice *s);
 #endif
 static void ni_handle_fifo_dregs(struct comedi_device *dev);
 static int ni_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum);
-static void ni_load_channelgain_list(struct comedi_device *dev, unsigned int n_chan,
-	unsigned int *list);
+			 unsigned int trignum);
+static void ni_load_channelgain_list(struct comedi_device *dev,
+				     unsigned int n_chan, unsigned int *list);
 static void shutdown_ai_command(struct comedi_device *dev);
 
 static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum);
+			 unsigned int trignum);
 
 static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
 
-static int ni_gpct_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_gpct_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_gpct_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int ni_gpct_insn_write(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int ni_gpct_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
+static int ni_gpct_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int ni_gpct_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ni_gpct_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd);
+static int ni_gpct_cancel(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
 static void handle_gpct_interrupt(struct comedi_device *dev,
-	unsigned short counter_index);
+				  unsigned short counter_index);
 
 static int init_cs5529(struct comedi_device *dev);
-static int cs5529_do_conversion(struct comedi_device *dev, unsigned short *data);
-static int cs5529_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int cs5529_do_conversion(struct comedi_device *dev,
+				unsigned short *data);
+static int cs5529_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 #ifdef NI_CS5529_DEBUG
 static unsigned int cs5529_config_read(struct comedi_device *dev,
-	unsigned int reg_select_bits);
+				       unsigned int reg_select_bits);
 #endif
 static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
-	unsigned int reg_select_bits);
+				unsigned int reg_select_bits);
 
-static int ni_m_series_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_6143_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int ni_m_series_pwm_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
+static int ni_6143_pwm_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
 
 static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
-	unsigned period_ns);
+			       unsigned period_ns);
 static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status);
 static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status);
 
@@ -355,14 +400,14 @@ enum timebase_nanoseconds {
 static const int num_adc_stages_611x = 3;
 
 static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
-	unsigned ai_mite_status);
+			       unsigned ai_mite_status);
 static void handle_b_interrupt(struct comedi_device *dev, unsigned short status,
-	unsigned ao_mite_status);
+			       unsigned ao_mite_status);
 static void get_last_sample_611x(struct comedi_device *dev);
 static void get_last_sample_6143(struct comedi_device *dev);
 
 static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
-	unsigned bit_mask, unsigned bit_values)
+				   unsigned bit_mask, unsigned bit_values)
 {
 	unsigned long flags;
 
@@ -372,19 +417,19 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 		devpriv->int_a_enable_reg &= ~bit_mask;
 		devpriv->int_a_enable_reg |= bit_values & bit_mask;
 		devpriv->stc_writew(dev, devpriv->int_a_enable_reg,
-			Interrupt_A_Enable_Register);
+				    Interrupt_A_Enable_Register);
 		break;
 	case Interrupt_B_Enable_Register:
 		devpriv->int_b_enable_reg &= ~bit_mask;
 		devpriv->int_b_enable_reg |= bit_values & bit_mask;
 		devpriv->stc_writew(dev, devpriv->int_b_enable_reg,
-			Interrupt_B_Enable_Register);
+				    Interrupt_B_Enable_Register);
 		break;
 	case IO_Bidirection_Pin_Register:
 		devpriv->io_bidirection_pin_reg &= ~bit_mask;
 		devpriv->io_bidirection_pin_reg |= bit_values & bit_mask;
 		devpriv->stc_writew(dev, devpriv->io_bidirection_pin_reg,
-			IO_Bidirection_Pin_Register);
+				    IO_Bidirection_Pin_Register);
 		break;
 	case AI_AO_Select:
 		devpriv->ai_ao_select_reg &= ~bit_mask;
@@ -397,8 +442,7 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 		ni_writeb(devpriv->g0_g1_select_reg, G0_G1_Select);
 		break;
 	default:
-		printk("Warning %s() called with invalid register\n",
-			__func__);
+		printk("Warning %s() called with invalid register\n", __func__);
 		printk("reg is %d\n", reg);
 		break;
 	}
@@ -418,8 +462,8 @@ static inline void ni_set_ai_dma_channel(struct comedi_device *dev, int channel)
 
 	if (channel >= 0) {
 		bitfield =
-			(ni_stc_dma_channel_select_bitfield(channel) <<
-			AI_DMA_Select_Shift) & AI_DMA_Select_Mask;
+		    (ni_stc_dma_channel_select_bitfield(channel) <<
+		     AI_DMA_Select_Shift) & AI_DMA_Select_Mask;
 	} else {
 		bitfield = 0;
 	}
@@ -433,8 +477,8 @@ static inline void ni_set_ao_dma_channel(struct comedi_device *dev, int channel)
 
 	if (channel >= 0) {
 		bitfield =
-			(ni_stc_dma_channel_select_bitfield(channel) <<
-			AO_DMA_Select_Shift) & AO_DMA_Select_Mask;
+		    (ni_stc_dma_channel_select_bitfield(channel) <<
+		     AO_DMA_Select_Shift) & AO_DMA_Select_Mask;
 	} else {
 		bitfield = 0;
 	}
@@ -443,7 +487,8 @@ static inline void ni_set_ao_dma_channel(struct comedi_device *dev, int channel)
 
 /* negative mite_channel means no channel */
 static inline void ni_set_gpct_dma_channel(struct comedi_device *dev,
-	unsigned gpct_index, int mite_channel)
+					   unsigned gpct_index,
+					   int mite_channel)
 {
 	unsigned bitfield;
 
@@ -453,11 +498,12 @@ static inline void ni_set_gpct_dma_channel(struct comedi_device *dev,
 		bitfield = 0;
 	}
 	ni_set_bitfield(dev, G0_G1_Select, GPCT_DMA_Select_Mask(gpct_index),
-		bitfield);
+			bitfield);
 }
 
 /* negative mite_channel means no channel */
-static inline void ni_set_cdo_dma_channel(struct comedi_device *dev, int mite_channel)
+static inline void ni_set_cdo_dma_channel(struct comedi_device *dev,
+					  int mite_channel)
 {
 	unsigned long flags;
 
@@ -468,8 +514,8 @@ static inline void ni_set_cdo_dma_channel(struct comedi_device *dev, int mite_ch
 		   under the assumption the cdio dma selection works just like ai/ao/gpct.
 		   Definitely works for dma channels 0 and 1. */
 		devpriv->cdio_dma_select_reg |=
-			(ni_stc_dma_channel_select_bitfield(mite_channel) <<
-			CDO_DMA_Select_Shift) & CDO_DMA_Select_Mask;
+		    (ni_stc_dma_channel_select_bitfield(mite_channel) <<
+		     CDO_DMA_Select_Shift) & CDO_DMA_Select_Mask;
 	}
 	ni_writeb(devpriv->cdio_dma_select_reg, M_Offset_CDIO_DMA_Select);
 	mmiowb();
@@ -483,12 +529,11 @@ static int ni_request_ai_mite_channel(struct comedi_device *dev)
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->ai_mite_chan);
 	devpriv->ai_mite_chan =
-		mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);
+	    mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);
 	if (devpriv->ai_mite_chan == NULL) {
-		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
-			flags);
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		comedi_error(dev,
-			"failed to reserve mite dma channel for analog input.");
+			     "failed to reserve mite dma channel for analog input.");
 		return -EBUSY;
 	}
 	devpriv->ai_mite_chan->dir = COMEDI_INPUT;
@@ -504,12 +549,11 @@ static int ni_request_ao_mite_channel(struct comedi_device *dev)
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->ao_mite_chan);
 	devpriv->ao_mite_chan =
-		mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);
+	    mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);
 	if (devpriv->ao_mite_chan == NULL) {
-		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
-			flags);
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		comedi_error(dev,
-			"failed to reserve mite dma channel for analog outut.");
+			     "failed to reserve mite dma channel for analog outut.");
 		return -EBUSY;
 	}
 	devpriv->ao_mite_chan->dir = COMEDI_OUTPUT;
@@ -519,7 +563,8 @@ static int ni_request_ao_mite_channel(struct comedi_device *dev)
 }
 
 static int ni_request_gpct_mite_channel(struct comedi_device *dev,
-	unsigned gpct_index, enum comedi_io_direction direction)
+					unsigned gpct_index,
+					enum comedi_io_direction direction)
 {
 	unsigned long flags;
 	struct mite_channel *mite_chan;
@@ -528,18 +573,17 @@ static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->counter_dev->counters[gpct_index].mite_chan);
 	mite_chan =
-		mite_request_channel(devpriv->mite,
-		devpriv->gpct_mite_ring[gpct_index]);
+	    mite_request_channel(devpriv->mite,
+				 devpriv->gpct_mite_ring[gpct_index]);
 	if (mite_chan == NULL) {
-		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
-			flags);
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		comedi_error(dev,
-			"failed to reserve mite dma channel for counter.");
+			     "failed to reserve mite dma channel for counter.");
 		return -EBUSY;
 	}
 	mite_chan->dir = direction;
 	ni_tio_set_mite_channel(&devpriv->counter_dev->counters[gpct_index],
-		mite_chan);
+				mite_chan);
 	ni_set_gpct_dma_channel(dev, gpct_index, mite_chan->channel);
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	return 0;
@@ -555,12 +599,11 @@ static int ni_request_cdo_mite_channel(struct comedi_device *dev)
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->cdo_mite_chan);
 	devpriv->cdo_mite_chan =
-		mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);
+	    mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);
 	if (devpriv->cdo_mite_chan == NULL) {
-		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
-			flags);
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		comedi_error(dev,
-			"failed to reserve mite dma channel for correlated digital outut.");
+			     "failed to reserve mite dma channel for correlated digital outut.");
 		return -EBUSY;
 	}
 	devpriv->cdo_mite_chan->dir = COMEDI_OUTPUT;
@@ -600,7 +643,8 @@ static void ni_release_ao_mite_channel(struct comedi_device *dev)
 #endif /*  PCIDMA */
 }
 
-void ni_release_gpct_mite_channel(struct comedi_device *dev, unsigned gpct_index)
+void ni_release_gpct_mite_channel(struct comedi_device *dev,
+				  unsigned gpct_index)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -609,11 +653,12 @@ void ni_release_gpct_mite_channel(struct comedi_device *dev, unsigned gpct_index
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->counter_dev->counters[gpct_index].mite_chan) {
 		struct mite_channel *mite_chan =
-			devpriv->counter_dev->counters[gpct_index].mite_chan;
+		    devpriv->counter_dev->counters[gpct_index].mite_chan;
 
 		ni_set_gpct_dma_channel(dev, gpct_index, -1);
-		ni_tio_set_mite_channel(&devpriv->counter_dev->
-			counters[gpct_index], NULL);
+		ni_tio_set_mite_channel(&devpriv->
+					counter_dev->counters[gpct_index],
+					NULL);
 		mite_release_channel(mite_chan);
 	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
@@ -638,7 +683,7 @@ static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 /* e-series boards use the second irq signals to generate dma requests for their counters */
 #ifdef PCIDMA
 static void ni_e_series_enable_second_irq(struct comedi_device *dev,
-	unsigned gpct_index, short enable)
+					  unsigned gpct_index, short enable)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
 		return;
@@ -646,19 +691,19 @@ static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 	case 0:
 		if (enable) {
 			devpriv->stc_writew(dev, G0_Gate_Second_Irq_Enable,
-				Second_IRQ_A_Enable_Register);
+					    Second_IRQ_A_Enable_Register);
 		} else {
 			devpriv->stc_writew(dev, 0,
-				Second_IRQ_A_Enable_Register);
+					    Second_IRQ_A_Enable_Register);
 		}
 		break;
 	case 1:
 		if (enable) {
 			devpriv->stc_writew(dev, G1_Gate_Second_Irq_Enable,
-				Second_IRQ_B_Enable_Register);
+					    Second_IRQ_B_Enable_Register);
 		} else {
 			devpriv->stc_writew(dev, 0,
-				Second_IRQ_B_Enable_Register);
+					    Second_IRQ_B_Enable_Register);
 		}
 		break;
 	default:
@@ -684,11 +729,11 @@ static void ni_clear_ai_fifo(struct comedi_device *dev)
 			/* the NI example code does 3 convert pulses for 625x boards,
 			   but that appears to be wrong in practice. */
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 #endif
 		}
 	}
@@ -709,7 +754,8 @@ static uint32_t win_in2(struct comedi_device *dev, int reg)
 }
 
 #define ao_win_out(data, addr) ni_ao_win_outw(dev, data, addr)
-static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data, int addr)
+static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data,
+				  int addr)
 {
 	unsigned long flags;
 
@@ -719,7 +765,8 @@ static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data, int
 	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
-static inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data, int addr)
+static inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data,
+				  int addr)
 {
 	unsigned long flags;
 
@@ -751,8 +798,8 @@ static inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)
 *
 * value should only be 1 or 0.
 */
-static inline void ni_set_bits(struct comedi_device *dev, int reg, unsigned bits,
-	unsigned value)
+static inline void ni_set_bits(struct comedi_device *dev, int reg,
+			       unsigned bits, unsigned value)
 {
 	unsigned bit_values;
 
@@ -792,17 +839,17 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 			ai_mite_status = mite_get_status(devpriv->ai_mite_chan);
 			if (ai_mite_status & CHSR_LINKC)
 				writel(CHOR_CLRLC,
-					devpriv->mite->mite_io_addr +
-					MITE_CHOR(devpriv->ai_mite_chan->
-						channel));
+				       devpriv->mite->mite_io_addr +
+				       MITE_CHOR(devpriv->
+						 ai_mite_chan->channel));
 		}
 		if (devpriv->ao_mite_chan) {
 			ao_mite_status = mite_get_status(devpriv->ao_mite_chan);
 			if (ao_mite_status & CHSR_LINKC)
 				writel(CHOR_CLRLC,
-					mite->mite_io_addr +
-					MITE_CHOR(devpriv->ao_mite_chan->
-						channel));
+				       mite->mite_io_addr +
+				       MITE_CHOR(devpriv->
+						 ao_mite_chan->channel));
 		}
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);
 	}
@@ -833,7 +880,8 @@ static void ni_sync_ai_dma(struct comedi_device *dev)
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
-static void mite_handle_b_linkc(struct mite_struct *mite, struct comedi_device * dev)
+static void mite_handle_b_linkc(struct mite_struct *mite,
+				struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	unsigned long flags;
@@ -907,9 +955,9 @@ static void shutdown_ai_command(struct comedi_device *dev)
 
 static void ni_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	if (s->async->
-		events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW | COMEDI_CB_EOA))
-	{
+	if (s->
+	    async->events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW |
+			     COMEDI_CB_EOA)) {
 		switch (s - dev->subdevices) {
 		case NI_AI_SUBDEV:
 			ni_ai_reset(dev, s);
@@ -932,13 +980,14 @@ static void ni_event(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static void handle_gpct_interrupt(struct comedi_device *dev,
-	unsigned short counter_index)
+				  unsigned short counter_index)
 {
 #ifdef PCIDMA
-	struct comedi_subdevice *s = dev->subdevices + NI_GPCT_SUBDEV(counter_index);
+	struct comedi_subdevice *s =
+	    dev->subdevices + NI_GPCT_SUBDEV(counter_index);
 
 	ni_tio_handle_interrupt(&devpriv->counter_dev->counters[counter_index],
-		s);
+				s);
 	if (s->async->events)
 		ni_event(dev, s);
 #endif
@@ -966,7 +1015,7 @@ static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 }
 
 static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
-	unsigned ai_mite_status)
+			       unsigned ai_mite_status)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 
@@ -976,8 +1025,8 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 
 #ifdef DEBUG_INTERRUPT
 	printk
-		("ni_mio_common: interrupt: a_status=%04x ai_mite_status=%08x\n",
-		status, ai_mite_status);
+	    ("ni_mio_common: interrupt: a_status=%04x ai_mite_status=%08x\n",
+	     status, ai_mite_status);
 	ni_mio_print_status_a(status);
 #endif
 #ifdef PCIDMA
@@ -986,11 +1035,11 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	}
 
 	if (ai_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
-			CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
-			CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
+			       CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
+			       CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
 		printk
-			("unknown mite interrupt, ack! (ai_mite_status=%08x)\n",
-			ai_mite_status);
+		    ("unknown mite interrupt, ack! (ai_mite_status=%08x)\n",
+		     ai_mite_status);
 		/* mite_print_chsr(ai_mite_status); */
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		/* disable_irq(dev->irq); */
@@ -999,23 +1048,23 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 
 	/* test for all uncommon interrupt events at the same time */
 	if (status & (AI_Overrun_St | AI_Overflow_St | AI_SC_TC_Error_St |
-			AI_SC_TC_St | AI_START1_St)) {
+		      AI_SC_TC_St | AI_START1_St)) {
 		if (status == 0xffff) {
 			printk
-				("ni_mio_common: a_status=0xffff.  Card removed?\n");
+			    ("ni_mio_common: a_status=0xffff.  Card removed?\n");
 			/* we probably aren't even running a command now,
 			 * so it's a good idea to be careful. */
 			if (comedi_get_subdevice_runflags(s) & SRF_RUNNING) {
 				s->async->events |=
-					COMEDI_CB_ERROR | COMEDI_CB_EOA;
+				    COMEDI_CB_ERROR | COMEDI_CB_EOA;
 				ni_event(dev, s);
 			}
 			return;
 		}
 		if (status & (AI_Overrun_St | AI_Overflow_St |
-				AI_SC_TC_Error_St)) {
+			      AI_SC_TC_Error_St)) {
 			printk("ni_mio_common: ai error a_status=%04x\n",
-				status);
+			       status);
 			ni_mio_print_status_a(status);
 
 			shutdown_ai_command(dev);
@@ -1047,7 +1096,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 			ni_handle_fifo_half_full(dev);
 			if ((devpriv->stc_readw(dev,
 						AI_Status_1_Register) &
-					AI_FIFO_Half_Full_St) == 0)
+			     AI_FIFO_Half_Full_St) == 0)
 				break;
 		}
 	}
@@ -1063,8 +1112,8 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	status = devpriv->stc_readw(dev, AI_Status_1_Register);
 	if (status & Interrupt_A_St) {
 		printk
-			("handle_a_interrupt: didn't clear interrupt? status=0x%x\n",
-			status);
+		    ("handle_a_interrupt: didn't clear interrupt? status=0x%x\n",
+		     status);
 	}
 #endif
 }
@@ -1097,14 +1146,14 @@ static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
 		devpriv->stc_writew(dev, ack, Interrupt_B_Ack_Register);
 }
 
-static void handle_b_interrupt(struct comedi_device *dev, unsigned short b_status,
-	unsigned ao_mite_status)
+static void handle_b_interrupt(struct comedi_device *dev,
+			       unsigned short b_status, unsigned ao_mite_status)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	/* unsigned short ack=0; */
 #ifdef DEBUG_INTERRUPT
 	printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
-		b_status, ao_mite_status);
+	       b_status, ao_mite_status);
 	ni_mio_print_status_b(b_status);
 #endif
 
@@ -1115,11 +1164,11 @@ static void handle_b_interrupt(struct comedi_device *dev, unsigned short b_statu
 	}
 
 	if (ao_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
-			CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
-			CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
+			       CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
+			       CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
 		printk
-			("unknown mite interrupt, ack! (ao_mite_status=%08x)\n",
-			ao_mite_status);
+		    ("unknown mite interrupt, ack! (ao_mite_status=%08x)\n",
+		     ao_mite_status);
 		/* mite_print_chsr(ao_mite_status); */
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
@@ -1129,14 +1178,15 @@ static void handle_b_interrupt(struct comedi_device *dev, unsigned short b_statu
 		return;
 	if (b_status & AO_Overrun_St) {
 		printk
-			("ni_mio_common: AO FIFO underrun status=0x%04x status2=0x%04x\n",
-			b_status, devpriv->stc_readw(dev,
-				AO_Status_2_Register));
+		    ("ni_mio_common: AO FIFO underrun status=0x%04x status2=0x%04x\n",
+		     b_status, devpriv->stc_readw(dev, AO_Status_2_Register));
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 
 	if (b_status & AO_BC_TC_St) {
-		MDPRINTK("ni_mio_common: AO BC_TC status=0x%04x status2=0x%04x\n", b_status, devpriv->stc_readw(dev, AO_Status_2_Register));
+		MDPRINTK
+		    ("ni_mio_common: AO BC_TC status=0x%04x status2=0x%04x\n",
+		     b_status, devpriv->stc_readw(dev, AO_Status_2_Register));
 		s->async->events |= COMEDI_CB_EOA;
 	}
 #ifndef PCIDMA
@@ -1147,8 +1197,8 @@ static void handle_b_interrupt(struct comedi_device *dev, unsigned short b_statu
 		if (!ret) {
 			printk("ni_mio_common: AO buffer underrun\n");
 			ni_set_bits(dev, Interrupt_B_Enable_Register,
-				AO_FIFO_Interrupt_Enable |
-				AO_Error_Interrupt_Enable, 0);
+				    AO_FIFO_Interrupt_Enable |
+				    AO_Error_Interrupt_Enable, 0);
 			s->async->events |= COMEDI_CB_OVERFLOW;
 		}
 	}
@@ -1203,7 +1253,8 @@ static void ni_mio_print_status_b(int status)
 
 #ifndef PCIDMA
 
-static void ni_ao_fifo_load(struct comedi_device *dev, struct comedi_subdevice *s, int n)
+static void ni_ao_fifo_load(struct comedi_device *dev,
+			    struct comedi_subdevice *s, int n)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1262,7 +1313,8 @@ static void ni_ao_fifo_load(struct comedi_device *dev, struct comedi_subdevice *
  *  RT code, as RT code might purposely be running close to the
  *  metal.  Needs to be fixed eventually.
  */
-static int ni_ao_fifo_half_empty(struct comedi_device *dev, struct comedi_subdevice *s)
+static int ni_ao_fifo_half_empty(struct comedi_device *dev,
+				 struct comedi_subdevice *s)
 {
 	int n;
 
@@ -1283,7 +1335,8 @@ static int ni_ao_fifo_half_empty(struct comedi_device *dev, struct comedi_subdev
 	return 1;
 }
 
-static int ni_ao_prep_fifo(struct comedi_device *dev, struct comedi_subdevice *s)
+static int ni_ao_prep_fifo(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	int n;
 
@@ -1306,7 +1359,8 @@ static int ni_ao_prep_fifo(struct comedi_device *dev, struct comedi_subdevice *s
 	return n;
 }
 
-static void ni_ai_fifo_read(struct comedi_device *dev, struct comedi_subdevice *s, int n)
+static void ni_ai_fifo_read(struct comedi_device *dev,
+			    struct comedi_subdevice *s, int n)
 {
 	struct comedi_async *async = s->async;
 	int i;
@@ -1349,17 +1403,18 @@ static void ni_ai_fifo_read(struct comedi_device *dev, struct comedi_subdevice *
 		}
 	} else {
 		if (n > sizeof(devpriv->ai_fifo_buffer) /
-			sizeof(devpriv->ai_fifo_buffer[0])) {
+		    sizeof(devpriv->ai_fifo_buffer[0])) {
 			comedi_error(dev, "bug! ai_fifo_buffer too small");
 			async->events |= COMEDI_CB_ERROR;
 			return;
 		}
 		for (i = 0; i < n; i++) {
 			devpriv->ai_fifo_buffer[i] =
-				ni_readw(ADC_FIFO_Data_Register);
+			    ni_readw(ADC_FIFO_Data_Register);
 		}
 		cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
-			n * sizeof(devpriv->ai_fifo_buffer[0]));
+					  n *
+					  sizeof(devpriv->ai_fifo_buffer[0]));
 	}
 }
 
@@ -1387,19 +1442,18 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 		for (i = 0; i < timeout; i++) {
 			if ((devpriv->stc_readw(dev,
 						AI_Status_1_Register) &
-					AI_FIFO_Empty_St)
-				&& mite_bytes_in_transit(devpriv->
-					ai_mite_chan) == 0)
+			     AI_FIFO_Empty_St)
+			    && mite_bytes_in_transit(devpriv->ai_mite_chan) ==
+			    0)
 				break;
 			udelay(5);
 		}
 		if (i == timeout) {
+			printk("ni_mio_common: wait for dma drain timed out\n");
 			printk
-				("ni_mio_common: wait for dma drain timed out\n");
-			printk
-				("mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
-				mite_bytes_in_transit(devpriv->ai_mite_chan),
-				devpriv->stc_readw(dev, AI_Status_1_Register));
+			    ("mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
+			     mite_bytes_in_transit(devpriv->ai_mite_chan),
+			     devpriv->stc_readw(dev, AI_Status_1_Register));
 			retval = -1;
 		}
 	}
@@ -1423,8 +1477,8 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 
 	if (boardtype.reg_type == ni_reg_611x) {
 		while ((devpriv->stc_readw(dev,
-					AI_Status_1_Register) &
-				AI_FIFO_Empty_St) == 0) {
+					   AI_Status_1_Register) &
+			AI_FIFO_Empty_St) == 0) {
 			dl = ni_readl(ADC_FIFO_Data_611x);
 
 			/* This may get the hi/lo data in the wrong order */
@@ -1453,24 +1507,26 @@ static void ni_handle_fifo_dregs(struct comedi_device *dev)
 
 	} else {
 		fifo_empty =
-			devpriv->stc_readw(dev,
-			AI_Status_1_Register) & AI_FIFO_Empty_St;
+		    devpriv->stc_readw(dev,
+				       AI_Status_1_Register) & AI_FIFO_Empty_St;
 		while (fifo_empty == 0) {
 			for (i = 0;
-				i <
-				sizeof(devpriv->ai_fifo_buffer) /
-				sizeof(devpriv->ai_fifo_buffer[0]); i++) {
+			     i <
+			     sizeof(devpriv->ai_fifo_buffer) /
+			     sizeof(devpriv->ai_fifo_buffer[0]); i++) {
 				fifo_empty =
-					devpriv->stc_readw(dev,
-					AI_Status_1_Register) &
-					AI_FIFO_Empty_St;
+				    devpriv->stc_readw(dev,
+						       AI_Status_1_Register) &
+				    AI_FIFO_Empty_St;
 				if (fifo_empty)
 					break;
 				devpriv->ai_fifo_buffer[i] =
-					ni_readw(ADC_FIFO_Data_Register);
+				    ni_readw(ADC_FIFO_Data_Register);
 			}
 			cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
-				i * sizeof(devpriv->ai_fifo_buffer[0]));
+						  i *
+						  sizeof(devpriv->
+							 ai_fifo_buffer[0]));
 		}
 	}
 }
@@ -1513,7 +1569,8 @@ static void get_last_sample_6143(struct comedi_device *dev)
 }
 
 static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
-	void *data, unsigned int num_bytes, unsigned int chan_index)
+			void *data, unsigned int num_bytes,
+			unsigned int chan_index)
 {
 	struct comedi_async *async = s->async;
 	unsigned int i;
@@ -1620,13 +1677,13 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_release_ai_mite_channel(dev);
 	/* ai configuration */
 	devpriv->stc_writew(dev, AI_Configuration_Start | AI_Reset,
-		Joint_Reset_Register);
+			    Joint_Reset_Register);
 
 	ni_set_bits(dev, Interrupt_A_Enable_Register,
-		AI_SC_TC_Interrupt_Enable | AI_START1_Interrupt_Enable |
-		AI_START2_Interrupt_Enable | AI_START_Interrupt_Enable |
-		AI_STOP_Interrupt_Enable | AI_Error_Interrupt_Enable |
-		AI_FIFO_Interrupt_Enable, 0);
+		    AI_SC_TC_Interrupt_Enable | AI_START1_Interrupt_Enable |
+		    AI_START2_Interrupt_Enable | AI_START_Interrupt_Enable |
+		    AI_STOP_Interrupt_Enable | AI_Error_Interrupt_Enable |
+		    AI_FIFO_Interrupt_Enable, 0);
 
 	ni_clear_ai_fifo(dev);
 
@@ -1635,51 +1692,60 @@ static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	devpriv->stc_writew(dev, AI_Disarm, AI_Command_1_Register);	/* reset pulses */
 	devpriv->stc_writew(dev,
-		AI_Start_Stop | AI_Mode_1_Reserved /*| AI_Trigger_Once */ ,
-		AI_Mode_1_Register);
+			    AI_Start_Stop | AI_Mode_1_Reserved
+			    /*| AI_Trigger_Once */ ,
+			    AI_Mode_1_Register);
 	devpriv->stc_writew(dev, 0x0000, AI_Mode_2_Register);
 	/* generate FIFO interrupts on non-empty */
 	devpriv->stc_writew(dev, (0 << 6) | 0x0000, AI_Mode_3_Register);
 	if (boardtype.reg_type == ni_reg_611x) {
 		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
-			AI_SOC_Polarity |
-			AI_LOCALMUX_CLK_Pulse_Width, AI_Personal_Register);
-		devpriv->stc_writew(dev, AI_SCAN_IN_PROG_Output_Select(3) |
-			AI_EXTMUX_CLK_Output_Select(0) |
-			AI_LOCALMUX_CLK_Output_Select(2) |
-			AI_SC_TC_Output_Select(3) |
-			AI_CONVERT_Output_Select(AI_CONVERT_Output_Enable_High),
-			AI_Output_Control_Register);
+				    AI_SOC_Polarity |
+				    AI_LOCALMUX_CLK_Pulse_Width,
+				    AI_Personal_Register);
+		devpriv->stc_writew(dev,
+				    AI_SCAN_IN_PROG_Output_Select(3) |
+				    AI_EXTMUX_CLK_Output_Select(0) |
+				    AI_LOCALMUX_CLK_Output_Select(2) |
+				    AI_SC_TC_Output_Select(3) |
+				    AI_CONVERT_Output_Select
+				    (AI_CONVERT_Output_Enable_High),
+				    AI_Output_Control_Register);
 	} else if (boardtype.reg_type == ni_reg_6143) {
 		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
-			AI_SOC_Polarity |
-			AI_LOCALMUX_CLK_Pulse_Width, AI_Personal_Register);
-		devpriv->stc_writew(dev, AI_SCAN_IN_PROG_Output_Select(3) |
-			AI_EXTMUX_CLK_Output_Select(0) |
-			AI_LOCALMUX_CLK_Output_Select(2) |
-			AI_SC_TC_Output_Select(3) |
-			AI_CONVERT_Output_Select(AI_CONVERT_Output_Enable_Low),
-			AI_Output_Control_Register);
+				    AI_SOC_Polarity |
+				    AI_LOCALMUX_CLK_Pulse_Width,
+				    AI_Personal_Register);
+		devpriv->stc_writew(dev,
+				    AI_SCAN_IN_PROG_Output_Select(3) |
+				    AI_EXTMUX_CLK_Output_Select(0) |
+				    AI_LOCALMUX_CLK_Output_Select(2) |
+				    AI_SC_TC_Output_Select(3) |
+				    AI_CONVERT_Output_Select
+				    (AI_CONVERT_Output_Enable_Low),
+				    AI_Output_Control_Register);
 	} else {
 		unsigned ai_output_control_bits;
 		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
-			AI_SOC_Polarity |
-			AI_CONVERT_Pulse_Width |
-			AI_LOCALMUX_CLK_Pulse_Width, AI_Personal_Register);
-		ai_output_control_bits = AI_SCAN_IN_PROG_Output_Select(3) |
-			AI_EXTMUX_CLK_Output_Select(0) |
-			AI_LOCALMUX_CLK_Output_Select(2) |
-			AI_SC_TC_Output_Select(3);
+				    AI_SOC_Polarity |
+				    AI_CONVERT_Pulse_Width |
+				    AI_LOCALMUX_CLK_Pulse_Width,
+				    AI_Personal_Register);
+		ai_output_control_bits =
+		    AI_SCAN_IN_PROG_Output_Select(3) |
+		    AI_EXTMUX_CLK_Output_Select(0) |
+		    AI_LOCALMUX_CLK_Output_Select(2) |
+		    AI_SC_TC_Output_Select(3);
 		if (boardtype.reg_type == ni_reg_622x)
 			ai_output_control_bits |=
-				AI_CONVERT_Output_Select
-				(AI_CONVERT_Output_Enable_High);
+			    AI_CONVERT_Output_Select
+			    (AI_CONVERT_Output_Enable_High);
 		else
 			ai_output_control_bits |=
-				AI_CONVERT_Output_Select
-				(AI_CONVERT_Output_Enable_Low);
+			    AI_CONVERT_Output_Select
+			    (AI_CONVERT_Output_Enable_Low);
 		devpriv->stc_writew(dev, ai_output_control_bits,
-			AI_Output_Control_Register);
+				    AI_Output_Control_Register);
 	}
 	/* the following registers should not be changed, because there
 	 * are no backup registers in devpriv.  If you want to change
@@ -1716,8 +1782,9 @@ static int ni_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 	return count;
 }
 
-static int ni_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_ai_insn_read(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int i, n;
 	const unsigned int mask = (1 << boardtype.adbits) - 1;
@@ -1733,31 +1800,31 @@ static int ni_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s
 	if (boardtype.reg_type == ni_reg_611x) {
 		for (n = 0; n < num_adc_stages_611x; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 			udelay(1);
 		}
 		for (n = 0; n < insn->n; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 			/* The 611x has screwy 32-bit FIFOs. */
 			d = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
 				if (ni_readb(XXX_Status) & 0x80) {
 					d = (ni_readl(ADC_FIFO_Data_611x) >> 16)
-						& 0xffff;
+					    & 0xffff;
 					break;
 				}
 				if (!(devpriv->stc_readw(dev,
-							AI_Status_1_Register) &
-						AI_FIFO_Empty_St)) {
+							 AI_Status_1_Register) &
+				      AI_FIFO_Empty_St)) {
 					d = ni_readl(ADC_FIFO_Data_611x) &
-						0xffff;
+					    0xffff;
 					break;
 				}
 			}
 			if (i == NI_TIMEOUT) {
 				printk
-					("ni_mio_common: timeout in 611x ni_ai_insn_read\n");
+				    ("ni_mio_common: timeout in 611x ni_ai_insn_read\n");
 				return -ETIME;
 			}
 			d += signbits;
@@ -1766,7 +1833,7 @@ static int ni_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s
 	} else if (boardtype.reg_type == ni_reg_6143) {
 		for (n = 0; n < insn->n; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 
 			/* The 6143 has 32-bit FIFOs. You need to strobe a bit to move a single 16bit stranded sample into the FIFO */
 			dl = 0;
@@ -1779,7 +1846,7 @@ static int ni_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s
 			}
 			if (i == NI_TIMEOUT) {
 				printk
-					("ni_mio_common: timeout in 6143 ni_ai_insn_read\n");
+				    ("ni_mio_common: timeout in 6143 ni_ai_insn_read\n");
 				return -ETIME;
 			}
 			data[n] = (((dl >> 16) & 0xFFFF) + signbits) & 0xFFFF;
@@ -1787,21 +1854,21 @@ static int ni_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s
 	} else {
 		for (n = 0; n < insn->n; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 			for (i = 0; i < NI_TIMEOUT; i++) {
 				if (!(devpriv->stc_readw(dev,
-							AI_Status_1_Register) &
-						AI_FIFO_Empty_St))
+							 AI_Status_1_Register) &
+				      AI_FIFO_Empty_St))
 					break;
 			}
 			if (i == NI_TIMEOUT) {
 				printk
-					("ni_mio_common: timeout in ni_ai_insn_read\n");
+				    ("ni_mio_common: timeout in ni_ai_insn_read\n");
 				return -ETIME;
 			}
 			if (boardtype.reg_type & ni_reg_m_series_mask) {
 				data[n] =
-					ni_readl(M_Offset_AI_FIFO_Data) & mask;
+				    ni_readl(M_Offset_AI_FIFO_Data) & mask;
 			} else {
 				d = ni_readw(ADC_FIFO_Data_Register);
 				d += signbits;	/* subtle: needs to be short addition */
@@ -1818,8 +1885,8 @@ void ni_prime_channelgain_list(struct comedi_device *dev)
 	devpriv->stc_writew(dev, AI_CONVERT_Pulse, AI_Command_1_Register);
 	for (i = 0; i < NI_TIMEOUT; ++i) {
 		if (!(devpriv->stc_readw(dev,
-					AI_Status_1_Register) &
-				AI_FIFO_Empty_St)) {
+					 AI_Status_1_Register) &
+		      AI_FIFO_Empty_St)) {
 			devpriv->stc_writew(dev, 1, ADC_FIFO_Clear);
 			return;
 		}
@@ -1829,7 +1896,8 @@ void ni_prime_channelgain_list(struct comedi_device *dev)
 }
 
 static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
-	unsigned int n_chan, unsigned int *list)
+					      unsigned int n_chan,
+					      unsigned int *list)
 {
 	unsigned int chan, range, aref;
 	unsigned int i;
@@ -1849,11 +1917,11 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 		bypass_bits = MSeries_AI_Bypass_Config_FIFO_Bit;
 		bypass_bits |= chan;
 		bypass_bits |=
-			(devpriv->
-			ai_calib_source) & (MSeries_AI_Bypass_Cal_Sel_Pos_Mask |
-			MSeries_AI_Bypass_Cal_Sel_Neg_Mask |
-			MSeries_AI_Bypass_Mode_Mux_Mask |
-			MSeries_AO_Bypass_AO_Cal_Sel_Mask);
+		    (devpriv->ai_calib_source) &
+		    (MSeries_AI_Bypass_Cal_Sel_Pos_Mask |
+		     MSeries_AI_Bypass_Cal_Sel_Neg_Mask |
+		     MSeries_AI_Bypass_Mode_Mux_Mask |
+		     MSeries_AO_Bypass_AO_Cal_Sel_Mask);
 		bypass_bits |= MSeries_AI_Bypass_Gain_Bits(range_code);
 		if (dither)
 			bypass_bits |= MSeries_AI_Bypass_Dither_Bit;
@@ -1876,22 +1944,22 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 		switch (aref) {
 		case AREF_DIFF:
 			config_bits |=
-				MSeries_AI_Config_Channel_Type_Differential_Bits;
+			    MSeries_AI_Config_Channel_Type_Differential_Bits;
 			break;
 		case AREF_COMMON:
 			config_bits |=
-				MSeries_AI_Config_Channel_Type_Common_Ref_Bits;
+			    MSeries_AI_Config_Channel_Type_Common_Ref_Bits;
 			break;
 		case AREF_GROUND:
 			config_bits |=
-				MSeries_AI_Config_Channel_Type_Ground_Ref_Bits;
+			    MSeries_AI_Config_Channel_Type_Ground_Ref_Bits;
 			break;
 		case AREF_OTHER:
 			break;
 		}
 		config_bits |= MSeries_AI_Config_Channel_Bits(chan);
 		config_bits |=
-			MSeries_AI_Config_Bank_Bits(boardtype.reg_type, chan);
+		    MSeries_AI_Config_Bank_Bits(boardtype.reg_type, chan);
 		config_bits |= MSeries_AI_Config_Gain_Bits(range_code);
 		if (i == n_chan - 1)
 			config_bits |= MSeries_AI_Config_Last_Channel_Bit;
@@ -1933,8 +2001,8 @@ static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
  *   bits 0-2: channel
  *       valid channels are 0-3
  */
-static void ni_load_channelgain_list(struct comedi_device *dev, unsigned int n_chan,
-	unsigned int *list)
+static void ni_load_channelgain_list(struct comedi_device *dev,
+				     unsigned int n_chan, unsigned int *list)
 {
 	unsigned int chan, range, aref;
 	unsigned int i;
@@ -1947,9 +2015,9 @@ static void ni_load_channelgain_list(struct comedi_device *dev, unsigned int n_c
 		return;
 	}
 	if (n_chan == 1 && (boardtype.reg_type != ni_reg_611x)
-		&& (boardtype.reg_type != ni_reg_6143)) {
+	    && (boardtype.reg_type != ni_reg_6143)) {
 		if (devpriv->changain_state
-			&& devpriv->changain_spec == list[0]) {
+		    && devpriv->changain_spec == list[0]) {
 			/*  ready to go. */
 			return;
 		}
@@ -1964,25 +2032,23 @@ static void ni_load_channelgain_list(struct comedi_device *dev, unsigned int n_c
 	/*  Set up Calibration mode if required */
 	if (boardtype.reg_type == ni_reg_6143) {
 		if ((list[0] & CR_ALT_SOURCE)
-			&& !devpriv->ai_calib_source_enabled) {
+		    && !devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay enable bit */
-			ni_writew(devpriv->
-				ai_calib_source |
-				Calibration_Channel_6143_RelayOn,
-				Calibration_Channel_6143);
+			ni_writew(devpriv->ai_calib_source |
+				  Calibration_Channel_6143_RelayOn,
+				  Calibration_Channel_6143);
 			ni_writew(devpriv->ai_calib_source,
-				Calibration_Channel_6143);
+				  Calibration_Channel_6143);
 			devpriv->ai_calib_source_enabled = 1;
 			msleep_interruptible(100);	/*  Allow relays to change */
 		} else if (!(list[0] & CR_ALT_SOURCE)
-			&& devpriv->ai_calib_source_enabled) {
+			   && devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay disable bit */
-			ni_writew(devpriv->
-				ai_calib_source |
-				Calibration_Channel_6143_RelayOff,
-				Calibration_Channel_6143);
+			ni_writew(devpriv->ai_calib_source |
+				  Calibration_Channel_6143_RelayOff,
+				  Calibration_Channel_6143);
 			ni_writew(devpriv->ai_calib_source,
-				Calibration_Channel_6143);
+				  Calibration_Channel_6143);
 			devpriv->ai_calib_source_enabled = 0;
 			msleep_interruptible(100);	/*  Allow relays to change */
 		}
@@ -1991,7 +2057,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev, unsigned int n_c
 	offset = 1 << (boardtype.adbits - 1);
 	for (i = 0; i < n_chan; i++) {
 		if ((boardtype.reg_type != ni_reg_6143)
-			&& (list[i] & CR_ALT_SOURCE)) {
+		    && (list[i] & CR_ALT_SOURCE)) {
 			chan = devpriv->ai_calib_source;
 		} else {
 			chan = CR_CHAN(list[i]);
@@ -2011,7 +2077,7 @@ static void ni_load_channelgain_list(struct comedi_device *dev, unsigned int n_c
 		if ((list[i] & CR_ALT_SOURCE)) {
 			if (boardtype.reg_type == ni_reg_611x)
 				ni_writew(CR_CHAN(list[i]) & 0x0003,
-					Calibration_Channel_Select_611x);
+					  Calibration_Channel_Select_611x);
 		} else {
 			if (boardtype.reg_type == ni_reg_611x)
 				aref = AREF_DIFF;
@@ -2048,13 +2114,13 @@ static void ni_load_channelgain_list(struct comedi_device *dev, unsigned int n_c
 
 	/* prime the channel/gain list */
 	if ((boardtype.reg_type != ni_reg_611x)
-		&& (boardtype.reg_type != ni_reg_6143)) {
+	    && (boardtype.reg_type != ni_reg_6143)) {
 		ni_prime_channelgain_list(dev);
 	}
 }
 
 static int ni_ns_to_timer(const struct comedi_device *dev, unsigned nanosec,
-	int round_mode)
+			  int round_mode)
 {
 	int divider;
 	switch (round_mode) {
@@ -2078,7 +2144,7 @@ static unsigned ni_timer_to_ns(const struct comedi_device *dev, int timer)
 }
 
 static unsigned ni_min_ai_scan_period_ns(struct comedi_device *dev,
-	unsigned num_channels)
+					 unsigned num_channels)
 {
 	switch (boardtype.reg_type) {
 	case ni_reg_611x:
@@ -2094,7 +2160,7 @@ static unsigned ni_min_ai_scan_period_ns(struct comedi_device *dev,
 }
 
 static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+			 struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -2119,7 +2185,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	tmp = cmd->convert_src;
 	sources = TRIG_TIMER | TRIG_EXT;
 	if ((boardtype.reg_type == ni_reg_611x)
-		|| (boardtype.reg_type == ni_reg_6143))
+	    || (boardtype.reg_type == ni_reg_6143))
 		sources |= TRIG_NOW;
 	cmd->convert_src &= sources;
 	if (!cmd->convert_src || tmp != cmd->convert_src)
@@ -2142,14 +2208,14 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->start_src != TRIG_NOW &&
-		cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)
+	    cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT &&
-		cmd->scan_begin_src != TRIG_OTHER)
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_OTHER)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -2179,10 +2245,11 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	}
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->scan_begin_arg < ni_min_ai_scan_period_ns(dev,
-				cmd->chanlist_len)) {
+								   cmd->
+								   chanlist_len))
+		{
 			cmd->scan_begin_arg =
-				ni_min_ai_scan_period_ns(dev,
-				cmd->chanlist_len);
+			    ni_min_ai_scan_period_ns(dev, cmd->chanlist_len);
 			err++;
 		}
 		if (cmd->scan_begin_arg > devpriv->clock_ns * 0xffffff) {
@@ -2208,7 +2275,7 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		if ((boardtype.reg_type == ni_reg_611x)
-			|| (boardtype.reg_type == ni_reg_6143)) {
+		    || (boardtype.reg_type == ni_reg_6143)) {
 			if (cmd->convert_arg != 0) {
 				cmd->convert_arg = 0;
 				err++;
@@ -2274,27 +2341,31 @@ static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		cmd->scan_begin_arg =
-			ni_timer_to_ns(dev, ni_ns_to_timer(dev,
-				cmd->scan_begin_arg,
-				cmd->flags & TRIG_ROUND_MASK));
+		    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
+						       cmd->scan_begin_arg,
+						       cmd->
+						       flags &
+						       TRIG_ROUND_MASK));
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		if ((boardtype.reg_type != ni_reg_611x)
-			&& (boardtype.reg_type != ni_reg_6143)) {
+		    && (boardtype.reg_type != ni_reg_6143)) {
 			tmp = cmd->convert_arg;
 			cmd->convert_arg =
-				ni_timer_to_ns(dev, ni_ns_to_timer(dev,
-					cmd->convert_arg,
-					cmd->flags & TRIG_ROUND_MASK));
+			    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
+							       cmd->convert_arg,
+							       cmd->
+							       flags &
+							       TRIG_ROUND_MASK));
 			if (tmp != cmd->convert_arg)
 				err++;
 			if (cmd->scan_begin_src == TRIG_TIMER &&
-				cmd->scan_begin_arg <
-				cmd->convert_arg * cmd->scan_end_arg) {
+			    cmd->scan_begin_arg <
+			    cmd->convert_arg * cmd->scan_end_arg) {
 				cmd->scan_begin_arg =
-					cmd->convert_arg * cmd->scan_end_arg;
+				    cmd->convert_arg * cmd->scan_end_arg;
 				err++;
 			}
 		}
@@ -2332,27 +2403,28 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * interferes with the use of pfi0 */
 	devpriv->an_trig_etc_reg &= ~Analog_Trigger_Enable;
 	devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
-		Analog_Trigger_Etc_Register);
+			    Analog_Trigger_Etc_Register);
 
 	switch (cmd->start_src) {
 	case TRIG_INT:
 	case TRIG_NOW:
 		devpriv->stc_writew(dev, AI_START2_Select(0) |
-			AI_START1_Sync | AI_START1_Edge | AI_START1_Select(0),
-			AI_Trigger_Select_Register);
+				    AI_START1_Sync | AI_START1_Edge |
+				    AI_START1_Select(0),
+				    AI_Trigger_Select_Register);
 		break;
 	case TRIG_EXT:
 		{
 			int chan = CR_CHAN(cmd->start_arg);
 			unsigned int bits = AI_START2_Select(0) |
-				AI_START1_Sync | AI_START1_Select(chan + 1);
+			    AI_START1_Sync | AI_START1_Select(chan + 1);
 
 			if (cmd->start_arg & CR_INVERT)
 				bits |= AI_START1_Polarity;
 			if (cmd->start_arg & CR_EDGE)
 				bits |= AI_START1_Edge;
 			devpriv->stc_writew(dev, bits,
-				AI_Trigger_Select_Register);
+					    AI_Trigger_Select_Register);
 			break;
 		}
 	}
@@ -2363,7 +2435,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
 
 	if (cmd->chanlist_len == 1 || (boardtype.reg_type == ni_reg_611x)
-		|| (boardtype.reg_type == ni_reg_6143)) {
+	    || (boardtype.reg_type == ni_reg_6143)) {
 		start_stop_select |= AI_STOP_Polarity;
 		start_stop_select |= AI_STOP_Select(31);	/*  logic low */
 		start_stop_select |= AI_STOP_Sync;
@@ -2371,7 +2443,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		start_stop_select |= AI_STOP_Select(19);	/*  ai configuration memory */
 	}
 	devpriv->stc_writew(dev, start_stop_select,
-		AI_START_STOP_Select_Register);
+			    AI_START_STOP_Select_Register);
 
 	devpriv->ai_cmd2 = 0;
 	switch (cmd->stop_src) {
@@ -2397,7 +2469,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			/*  this is required to get the last sample for chanlist_len > 1, not sure why */
 			if (cmd->chanlist_len > 1)
 				start_stop_select |=
-					AI_STOP_Polarity | AI_STOP_Edge;
+				    AI_STOP_Polarity | AI_STOP_Edge;
 		}
 		break;
 	case TRIG_NONE:
@@ -2433,7 +2505,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 */
 		start_stop_select |= AI_START_Edge | AI_START_Sync;
 		devpriv->stc_writew(dev, start_stop_select,
-			AI_START_STOP_Select_Register);
+				    AI_START_STOP_Select_Register);
 
 		mode2 |= AI_SI_Reload_Mode(0);
 		/* AI_SI_Initial_Load_Source=A */
@@ -2443,7 +2515,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		/* load SI */
 		timer = ni_ns_to_timer(dev, cmd->scan_begin_arg,
-			TRIG_ROUND_NEAREST);
+				       TRIG_ROUND_NEAREST);
 		devpriv->stc_writel(dev, timer, AI_SI_Load_A_Registers);
 		devpriv->stc_writew(dev, AI_SI_Load, AI_Command_1_Register);
 		break;
@@ -2454,13 +2526,13 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		if (cmd->scan_begin_arg & CR_INVERT)
 			start_stop_select |= AI_START_Polarity;
 		if (cmd->scan_begin_src != cmd->convert_src ||
-			(cmd->scan_begin_arg & ~CR_EDGE) !=
-			(cmd->convert_arg & ~CR_EDGE))
+		    (cmd->scan_begin_arg & ~CR_EDGE) !=
+		    (cmd->convert_arg & ~CR_EDGE))
 			start_stop_select |= AI_START_Sync;
 		start_stop_select |=
-			AI_START_Select(1 + CR_CHAN(cmd->scan_begin_arg));
+		    AI_START_Select(1 + CR_CHAN(cmd->scan_begin_arg));
 		devpriv->stc_writew(dev, start_stop_select,
-			AI_START_STOP_Select_Register);
+				    AI_START_STOP_Select_Register);
 		break;
 	}
 
@@ -2471,7 +2543,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			timer = 1;
 		else
 			timer = ni_ns_to_timer(dev, cmd->convert_arg,
-				TRIG_ROUND_NEAREST);
+					       TRIG_ROUND_NEAREST);
 		devpriv->stc_writew(dev, 1, AI_SI2_Load_A_Register);	/* 0,0 does not work. */
 		devpriv->stc_writew(dev, timer, AI_SI2_Load_B_Register);
 
@@ -2505,14 +2577,14 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		/* interrupt on FIFO, errors, SC_TC */
 		interrupt_a_enable |= AI_Error_Interrupt_Enable |
-			AI_SC_TC_Interrupt_Enable;
+		    AI_SC_TC_Interrupt_Enable;
 
 #ifndef PCIDMA
 		interrupt_a_enable |= AI_FIFO_Interrupt_Enable;
 #endif
 
 		if (cmd->flags & TRIG_WAKE_EOS
-			|| (devpriv->ai_cmd2 & AI_End_On_End_Of_Scan)) {
+		    || (devpriv->ai_cmd2 & AI_End_On_End_Of_Scan)) {
 			/* wake on end-of-scan */
 			devpriv->aimode = AIMODE_SCAN;
 		} else {
@@ -2524,24 +2596,24 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			/*generate FIFO interrupts and DMA requests on half-full */
 #ifdef PCIDMA
 			devpriv->stc_writew(dev, AI_FIFO_Mode_HF_to_E,
-				AI_Mode_3_Register);
+					    AI_Mode_3_Register);
 #else
 			devpriv->stc_writew(dev, AI_FIFO_Mode_HF,
-				AI_Mode_3_Register);
+					    AI_Mode_3_Register);
 #endif
 			break;
 		case AIMODE_SAMPLE:
 			/*generate FIFO interrupts on non-empty */
 			devpriv->stc_writew(dev, AI_FIFO_Mode_NE,
-				AI_Mode_3_Register);
+					    AI_Mode_3_Register);
 			break;
 		case AIMODE_SCAN:
 #ifdef PCIDMA
 			devpriv->stc_writew(dev, AI_FIFO_Mode_NE,
-				AI_Mode_3_Register);
+					    AI_Mode_3_Register);
 #else
 			devpriv->stc_writew(dev, AI_FIFO_Mode_HF,
-				AI_Mode_3_Register);
+					    AI_Mode_3_Register);
 #endif
 			interrupt_a_enable |= AI_STOP_Interrupt_Enable;
 			break;
@@ -2552,10 +2624,10 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->stc_writew(dev, AI_Error_Interrupt_Ack | AI_STOP_Interrupt_Ack | AI_START_Interrupt_Ack | AI_START2_Interrupt_Ack | AI_START1_Interrupt_Ack | AI_SC_TC_Interrupt_Ack | AI_SC_TC_Error_Confirm, Interrupt_A_Ack_Register);	/* clear interrupts */
 
 		ni_set_bits(dev, Interrupt_A_Enable_Register,
-			interrupt_a_enable, 1);
+			    interrupt_a_enable, 1);
 
 		MDPRINTK("Interrupt_A_Enable_Register = 0x%04x\n",
-			devpriv->int_a_enable_reg);
+			 devpriv->int_a_enable_reg);
 	} else {
 		/* interrupt on nothing */
 		ni_set_bits(dev, Interrupt_A_Enable_Register, ~0, 0);
@@ -2570,14 +2642,14 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
 		devpriv->stc_writew(dev,
-			AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm | AI_SC_Arm,
-			AI_Command_1_Register);
+				    AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm |
+				    AI_SC_Arm, AI_Command_1_Register);
 		break;
 	case TRIG_EXT:
 		/* XXX AI_SI_Arm? */
 		devpriv->stc_writew(dev,
-			AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm | AI_SC_Arm,
-			AI_Command_1_Register);
+				    AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm |
+				    AI_SC_Arm, AI_Command_1_Register);
 		break;
 	}
 
@@ -2594,7 +2666,7 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	case TRIG_NOW:
 		/* AI_START1_Pulse */
 		devpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
-			AI_Command_2_Register);
+				    AI_Command_2_Register);
 		s->async->inttrig = NULL;
 		break;
 	case TRIG_EXT:
@@ -2611,23 +2683,26 @@ static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static int ni_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			 unsigned int trignum)
 {
 	if (trignum != 0)
 		return -EINVAL;
 
 	devpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
-		AI_Command_2_Register);
+			    AI_Command_2_Register);
 	s->async->inttrig = NULL;
 
 	return 1;
 }
 
-static int ni_ai_config_analog_trig(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int ni_ai_config_analog_trig(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data);
 
-static int ni_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_ai_insn_config(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n < 1)
 		return -EINVAL;
@@ -2666,7 +2741,7 @@ static int ni_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice
 			devpriv->ai_calib_source = calib_source;
 			if (boardtype.reg_type == ni_reg_611x) {
 				ni_writeb(calib_source_adjust,
-					Cal_Gain_Select_611x);
+					  Cal_Gain_Select_611x);
 			}
 		}
 		return 2;
@@ -2677,8 +2752,10 @@ static int ni_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice
 	return -EINVAL;
 }
 
-static int ni_ai_config_analog_trig(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_ai_config_analog_trig(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
 	unsigned int a, b, modebits;
 	int err = 0;
@@ -2730,8 +2807,7 @@ static int ni_ai_config_analog_trig(struct comedi_device *dev, struct comedi_sub
 			a = data[4];
 			b = data[3];
 			modebits =
-				((data[1] & 0xf) << 4) | ((data[1] & 0xf0) >>
-				4);
+			    ((data[1] & 0xf) << 4) | ((data[1] & 0xf0) >> 4);
 		}
 		devpriv->atrig_low = a;
 		devpriv->atrig_high = b;
@@ -2776,7 +2852,8 @@ static int ni_ai_config_analog_trig(struct comedi_device *dev, struct comedi_sub
 
 /* munge data from unsigned to 2's complement for analog output bipolar modes */
 static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
-	void *data, unsigned int num_bytes, unsigned int chan_index)
+			void *data, unsigned int num_bytes,
+			unsigned int chan_index)
 {
 	struct comedi_async *async = s->async;
 	unsigned int range;
@@ -2799,8 +2876,9 @@ static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int chanspec[], unsigned int n_chans,
-	int timed)
+					  struct comedi_subdevice *s,
+					  unsigned int chanspec[],
+					  unsigned int n_chans, int timed)
 {
 	unsigned int range;
 	unsigned int chan;
@@ -2811,7 +2889,8 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 	if (timed) {
 		for (i = 0; i < boardtype.n_aochan; ++i) {
 			devpriv->ao_conf[i] &= ~MSeries_AO_Update_Timed_Bit;
-			ni_writeb(devpriv->ao_conf[i], M_Offset_AO_Config_Bank(i));
+			ni_writeb(devpriv->ao_conf[i],
+				  M_Offset_AO_Config_Bank(i));
 			ni_writeb(0xf, M_Offset_AO_Waveform_Order(i));
 		}
 	}
@@ -2834,16 +2913,16 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 		case 4000000:
 			conf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;
 			ni_writeb(MSeries_Attenuate_x5_Bit,
-				M_Offset_AO_Reference_Attenuation(chan));
+				  M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		case 2000000:
 			conf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;
 			ni_writeb(MSeries_Attenuate_x5_Bit,
-				M_Offset_AO_Reference_Attenuation(chan));
+				  M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		default:
 			printk("%s: bug! unhandled ao reference voltage\n",
-				__func__);
+			       __func__);
 			break;
 		}
 		switch (krange->max + krange->min) {
@@ -2855,7 +2934,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 			break;
 		default:
 			printk("%s: bug! unhandled ao offset voltage\n",
-				__func__);
+			       __func__);
 			break;
 		}
 		if (timed)
@@ -2867,8 +2946,10 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 	return invert;
 }
 
-static int ni_old_ao_config_chanlist(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int chanspec[], unsigned int n_chans)
+static int ni_old_ao_config_chanlist(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     unsigned int chanspec[],
+				     unsigned int n_chans)
 {
 	unsigned int range;
 	unsigned int chan;
@@ -2902,7 +2983,7 @@ static int ni_old_ao_config_chanlist(struct comedi_device *dev, struct comedi_su
 		/* analog reference */
 		/* AREF_OTHER connects AO ground to AI ground, i think */
 		conf |= (CR_AREF(chanspec[i]) ==
-			AREF_OTHER) ? AO_Ground_Ref : 0;
+			 AREF_OTHER) ? AO_Ground_Ref : 0;
 
 		ni_writew(conf, AO_Configuration);
 		devpriv->ao_conf[chan] = conf;
@@ -2910,25 +2991,30 @@ static int ni_old_ao_config_chanlist(struct comedi_device *dev, struct comedi_su
 	return invert;
 }
 
-static int ni_ao_config_chanlist(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int chanspec[], unsigned int n_chans, int timed)
+static int ni_ao_config_chanlist(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 unsigned int chanspec[], unsigned int n_chans,
+				 int timed)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
 		return ni_m_series_ao_config_chanlist(dev, s, chanspec, n_chans,
-			timed);
+						      timed);
 	else
 		return ni_old_ao_config_chanlist(dev, s, chanspec, n_chans);
 }
-static int ni_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+
+static int ni_ao_insn_read(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int ni_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_ao_insn_write(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
@@ -2941,13 +3027,14 @@ static int ni_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *
 		ni_writew(data[0], M_Offset_DAC_Direct_Data(chan));
 	} else
 		ni_writew(data[0] ^ invert,
-			(chan) ? DAC1_Direct_Data : DAC0_Direct_Data);
+			  (chan) ? DAC1_Direct_Data : DAC0_Direct_Data);
 
 	return 1;
 }
 
-static int ni_ao_insn_write_671x(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_ao_insn_write_671x(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
@@ -2963,16 +3050,17 @@ static int ni_ao_insn_write_671x(struct comedi_device *dev, struct comedi_subdev
 	return 1;
 }
 
-static int ni_ao_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_ao_insn_config(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
-		switch (data[1])
-		{
+		switch (data[1]) {
 		case COMEDI_OUTPUT:
 			data[2] = 1 + boardtype.ao_fifo_depth * sizeof(short);
-			if (devpriv->mite) data[2] += devpriv->mite->fifo_size;
+			if (devpriv->mite)
+				data[2] += devpriv->mite->fifo_size;
 			break;
 		case COMEDI_INPUT:
 			data[2] = 0;
@@ -2990,7 +3078,7 @@ static int ni_ao_insn_config(struct comedi_device *dev, struct comedi_subdevice
 }
 
 static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			 unsigned int trignum)
 {
 	int ret;
 	int interrupt_b_bits;
@@ -3006,7 +3094,7 @@ static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	s->async->inttrig = NULL;
 
 	ni_set_bits(dev, Interrupt_B_Enable_Register,
-		AO_FIFO_Interrupt_Enable | AO_Error_Interrupt_Enable, 0);
+		    AO_FIFO_Interrupt_Enable | AO_Error_Interrupt_Enable, 0);
 	interrupt_b_bits = AO_Error_Interrupt_Enable;
 #ifdef PCIDMA
 	devpriv->stc_writew(dev, 1, DAC_FIFO_Clear);
@@ -3027,35 +3115,34 @@ static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 #endif
 
 	devpriv->stc_writew(dev, devpriv->ao_mode3 | AO_Not_An_UPDATE,
-		AO_Mode_3_Register);
+			    AO_Mode_3_Register);
 	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 	/* wait for DACs to be loaded */
 	for (i = 0; i < timeout; i++) {
 		udelay(1);
 		if ((devpriv->stc_readw(dev,
 					Joint_Status_2_Register) &
-				AO_TMRDACWRs_In_Progress_St) == 0)
+		     AO_TMRDACWRs_In_Progress_St) == 0)
 			break;
 	}
 	if (i == timeout) {
 		comedi_error(dev,
-			"timed out waiting for AO_TMRDACWRs_In_Progress_St to clear");
+			     "timed out waiting for AO_TMRDACWRs_In_Progress_St to clear");
 		return -EIO;
 	}
 	/*  stc manual says we are need to clear error interrupt after AO_TMRDACWRs_In_Progress_St clears */
 	devpriv->stc_writew(dev, AO_Error_Interrupt_Ack,
-		Interrupt_B_Ack_Register);
+			    Interrupt_B_Ack_Register);
 
 	ni_set_bits(dev, Interrupt_B_Enable_Register, interrupt_b_bits, 1);
 
 	devpriv->stc_writew(dev,
-		devpriv->
-		ao_cmd1 | AO_UI_Arm | AO_UC_Arm | AO_BC_Arm |
-		AO_DAC1_Update_Mode | AO_DAC0_Update_Mode,
-		AO_Command_1_Register);
+			    devpriv->ao_cmd1 | AO_UI_Arm | AO_UC_Arm | AO_BC_Arm
+			    | AO_DAC1_Update_Mode | AO_DAC0_Update_Mode,
+			    AO_Command_1_Register);
 
 	devpriv->stc_writew(dev, devpriv->ao_cmd2 | AO_START1_Pulse,
-		AO_Command_2_Register);
+			    AO_Command_2_Register);
 
 	return 0;
 }
@@ -3104,18 +3191,20 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	case TRIG_INT:
 	case TRIG_NOW:
 		devpriv->ao_trigger_select &=
-			~(AO_START1_Polarity | AO_START1_Select(-1));
+		    ~(AO_START1_Polarity | AO_START1_Select(-1));
 		devpriv->ao_trigger_select |= AO_START1_Edge | AO_START1_Sync;
 		devpriv->stc_writew(dev, devpriv->ao_trigger_select,
-			AO_Trigger_Select_Register);
+				    AO_Trigger_Select_Register);
 		break;
 	case TRIG_EXT:
-                devpriv->ao_trigger_select = AO_START1_Select(CR_CHAN(cmd->start_arg)+1);
+		devpriv->ao_trigger_select =
+		    AO_START1_Select(CR_CHAN(cmd->start_arg) + 1);
 		if (cmd->start_arg & CR_INVERT)
-			devpriv->ao_trigger_select |= AO_START1_Polarity;  /*  0=active high, 1=active low. see daq-stc 3-24 (p186) */
+			devpriv->ao_trigger_select |= AO_START1_Polarity;	/*  0=active high, 1=active low. see daq-stc 3-24 (p186) */
 		if (cmd->start_arg & CR_EDGE)
-			devpriv->ao_trigger_select |= AO_START1_Edge;      /*  0=edge detection disabled, 1=enabled */
-		devpriv->stc_writew(dev, devpriv->ao_trigger_select, AO_Trigger_Select_Register);
+			devpriv->ao_trigger_select |= AO_START1_Edge;	/*  0=edge detection disabled, 1=enabled */
+		devpriv->stc_writew(dev, devpriv->ao_trigger_select,
+				    AO_Trigger_Select_Register);
 		break;
 	default:
 		BUG();
@@ -3137,17 +3226,19 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		if (boardtype.reg_type & ni_reg_m_series_mask)
-		{
+		if (boardtype.reg_type & ni_reg_m_series_mask) {
 			/*  this is how the NI example code does it for m-series boards, verified correct with 6259 */
-			devpriv->stc_writel(dev, cmd->stop_arg - 1, AO_UC_Load_A_Register);
-			devpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
-		}else
-		{
-			devpriv->stc_writel(dev, cmd->stop_arg, AO_UC_Load_A_Register);
-			devpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
 			devpriv->stc_writel(dev, cmd->stop_arg - 1,
-				AO_UC_Load_A_Register);
+					    AO_UC_Load_A_Register);
+			devpriv->stc_writew(dev, AO_UC_Load,
+					    AO_Command_1_Register);
+		} else {
+			devpriv->stc_writel(dev, cmd->stop_arg,
+					    AO_UC_Load_A_Register);
+			devpriv->stc_writew(dev, AO_UC_Load,
+					    AO_Command_1_Register);
+			devpriv->stc_writel(dev, cmd->stop_arg - 1,
+					    AO_UC_Load_A_Register);
 		}
 		break;
 	case TRIG_NONE:
@@ -3162,21 +3253,21 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	devpriv->ao_mode1 &=
-		~(AO_UI_Source_Select(0x1f) | AO_UI_Source_Polarity |
-		AO_UPDATE_Source_Select(0x1f) | AO_UPDATE_Source_Polarity);
+	    ~(AO_UI_Source_Select(0x1f) | AO_UI_Source_Polarity |
+	      AO_UPDATE_Source_Select(0x1f) | AO_UPDATE_Source_Polarity);
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
 		devpriv->ao_cmd2 &= ~AO_BC_Gate_Enable;
 		trigvar =
-			ni_ns_to_timer(dev, cmd->scan_begin_arg,
-			TRIG_ROUND_NEAREST);
+		    ni_ns_to_timer(dev, cmd->scan_begin_arg,
+				   TRIG_ROUND_NEAREST);
 		devpriv->stc_writel(dev, 1, AO_UI_Load_A_Register);
 		devpriv->stc_writew(dev, AO_UI_Load, AO_Command_1_Register);
 		devpriv->stc_writel(dev, trigvar, AO_UI_Load_A_Register);
 		break;
 	case TRIG_EXT:
 		devpriv->ao_mode1 |=
-			AO_UPDATE_Source_Select(cmd->scan_begin_arg);
+		    AO_UPDATE_Source_Select(cmd->scan_begin_arg);
 		if (cmd->scan_begin_arg & CR_INVERT)
 			devpriv->ao_mode1 |= AO_UPDATE_Source_Polarity;
 		devpriv->ao_cmd2 |= AO_BC_Gate_Enable;
@@ -3188,34 +3279,34 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->stc_writew(dev, devpriv->ao_cmd2, AO_Command_2_Register);
 	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 	devpriv->ao_mode2 &=
-		~(AO_UI_Reload_Mode(3) | AO_UI_Initial_Load_Source);
+	    ~(AO_UI_Reload_Mode(3) | AO_UI_Initial_Load_Source);
 	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 
 	if (cmd->scan_end_arg > 1) {
 		devpriv->ao_mode1 |= AO_Multiple_Channels;
 		devpriv->stc_writew(dev,
-			AO_Number_Of_Channels(cmd->scan_end_arg -
-				1) |
-			AO_UPDATE_Output_Select
-			(AO_Update_Output_High_Z),
-			AO_Output_Control_Register);
+				    AO_Number_Of_Channels(cmd->scan_end_arg -
+							  1) |
+				    AO_UPDATE_Output_Select
+				    (AO_Update_Output_High_Z),
+				    AO_Output_Control_Register);
 	} else {
 		unsigned bits;
 		devpriv->ao_mode1 &= ~AO_Multiple_Channels;
 		bits = AO_UPDATE_Output_Select(AO_Update_Output_High_Z);
-		if (boardtype.reg_type & (ni_reg_m_series_mask | ni_reg_6xxx_mask)) {
+		if (boardtype.
+		    reg_type & (ni_reg_m_series_mask | ni_reg_6xxx_mask)) {
 			bits |= AO_Number_Of_Channels(0);
 		} else {
-			bits |= AO_Number_Of_Channels(CR_CHAN(cmd->
-					chanlist[0]));
+			bits |=
+			    AO_Number_Of_Channels(CR_CHAN(cmd->chanlist[0]));
 		}
-		devpriv->stc_writew(dev, bits,
-			AO_Output_Control_Register);
+		devpriv->stc_writew(dev, bits, AO_Output_Control_Register);
 	}
 	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 
 	devpriv->stc_writew(dev, AO_DAC0_Update_Mode | AO_DAC1_Update_Mode,
-		AO_Command_1_Register);
+			    AO_Command_1_Register);
 
 	devpriv->ao_mode3 |= AO_Stop_On_Overrun_Error;
 	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
@@ -3230,7 +3321,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 
 	bits = AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
-		AO_TMRDACWR_Pulse_Width;
+	    AO_TMRDACWR_Pulse_Width;
 	if (boardtype.ao_fifo_depth)
 		bits |= AO_FIFO_Enable;
 	else
@@ -3249,9 +3340,9 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		devpriv->stc_writew(dev, AO_BC_TC_Interrupt_Ack,
-			Interrupt_B_Ack_Register);
+				    Interrupt_B_Ack_Register);
 		ni_set_bits(dev, Interrupt_B_Enable_Register,
-			AO_BC_TC_Interrupt_Enable, 1);
+			    AO_BC_TC_Interrupt_Enable, 1);
 	}
 
 	s->async->inttrig = &ni_ao_inttrig;
@@ -3260,7 +3351,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+			 struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -3365,9 +3456,11 @@ static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		cmd->scan_begin_arg =
-			ni_timer_to_ns(dev, ni_ns_to_timer(dev,
-				cmd->scan_begin_arg,
-				cmd->flags & TRIG_ROUND_MASK));
+		    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
+						       cmd->scan_begin_arg,
+						       cmd->
+						       flags &
+						       TRIG_ROUND_MASK));
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -3398,7 +3491,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->stc_writew(dev, AO_BC_Source_Select, AO_Personal_Register);
 	devpriv->stc_writew(dev, 0x3f98, Interrupt_B_Ack_Register);
 	devpriv->stc_writew(dev, AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
-		AO_TMRDACWR_Pulse_Width, AO_Personal_Register);
+			    AO_TMRDACWR_Pulse_Width, AO_Personal_Register);
 	devpriv->stc_writew(dev, 0, AO_Output_Control_Register);
 	devpriv->stc_writew(dev, 0, AO_Start_Select_Register);
 	devpriv->ao_cmd1 = 0;
@@ -3416,12 +3509,11 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 	devpriv->ao_trigger_select = 0;
 	devpriv->stc_writew(dev, devpriv->ao_trigger_select,
-		AO_Trigger_Select_Register);
+			    AO_Trigger_Select_Register);
 	if (boardtype.reg_type & ni_reg_6xxx_mask) {
 		unsigned immediate_bits = 0;
 		unsigned i;
-		for (i = 0; i < s->n_chan; ++i)
-		{
+		for (i = 0; i < s->n_chan; ++i) {
 			immediate_bits |= 1 << i;
 		}
 		ao_win_out(immediate_bits, AO_Immediate_671x);
@@ -3434,12 +3526,13 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 
 /* digital io */
 
-static int ni_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_dio_insn_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
 	printk("ni_dio_insn_config() chan=%d io=%d\n",
-		CR_CHAN(insn->chanspec), data[0]);
+	       CR_CHAN(insn->chanspec), data[0]);
 #endif
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
@@ -3450,9 +3543,9 @@ static int ni_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->io_bits & (1 << CR_CHAN(insn->
-					chanspec))) ? COMEDI_OUTPUT :
-			COMEDI_INPUT;
+		    (s->
+		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
+		    COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
@@ -3466,8 +3559,9 @@ static int ni_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice
 	return 1;
 }
 
-static int ni_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_dio_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
 	printk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);
@@ -3478,7 +3572,7 @@ static int ni_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *
 		/* Perform check to make sure we're not using the
 		   serial part of the dio */
 		if ((data[0] & (DIO_SDIN | DIO_SDOUT))
-			&& devpriv->serial_interval_ns)
+		    && devpriv->serial_interval_ns)
 			return -EBUSY;
 
 		s->state &= ~data[0];
@@ -3486,7 +3580,7 @@ static int ni_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *
 		devpriv->dio_output &= ~DIO_Parallel_Data_Mask;
 		devpriv->dio_output |= DIO_Parallel_Data_Out(s->state);
 		devpriv->stc_writew(dev, devpriv->dio_output,
-			DIO_Output_Register);
+				    DIO_Output_Register);
 	}
 	data[1] = devpriv->stc_readw(dev, DIO_Parallel_Input_Register);
 
@@ -3494,11 +3588,13 @@ static int ni_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *
 }
 
 static int ni_m_series_dio_insn_config(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				       struct comedi_subdevice *s,
+				       struct comedi_insn *insn,
+				       unsigned int *data)
 {
 #ifdef DEBUG_DIO
 	printk("ni_m_series_dio_insn_config() chan=%d io=%d\n",
-		CR_CHAN(insn->chanspec), data[0]);
+	       CR_CHAN(insn->chanspec), data[0]);
 #endif
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
@@ -3509,9 +3605,9 @@ static int ni_m_series_dio_insn_config(struct comedi_device *dev,
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->io_bits & (1 << CR_CHAN(insn->
-					chanspec))) ? COMEDI_OUTPUT :
-			COMEDI_INPUT;
+		    (s->
+		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
+		    COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
@@ -3523,12 +3619,14 @@ static int ni_m_series_dio_insn_config(struct comedi_device *dev,
 	return 1;
 }
 
-static int ni_m_series_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_m_series_dio_insn_bits(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
 {
 #ifdef DEBUG_DIO
 	printk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],
-		data[1]);
+	       data[1]);
 #endif
 	if (insn->n != 2)
 		return -EINVAL;
@@ -3542,8 +3640,8 @@ static int ni_m_series_dio_insn_bits(struct comedi_device *dev, struct comedi_su
 	return 2;
 }
 
-static int ni_cdio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int ni_cdio_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -3606,7 +3704,7 @@ static int ni_cdio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s
 	if (cmd->scan_begin_src == TRIG_EXT) {
 		tmp = cmd->scan_begin_arg;
 		tmp &= CR_PACK_FLAGS(CDO_Sample_Source_Select_Mask, 0, 0,
-			CR_INVERT);
+				     CR_INVERT);
 		if (tmp != cmd->scan_begin_arg) {
 			err++;
 		}
@@ -3661,8 +3759,8 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	switch (cmd->scan_begin_src) {
 	case TRIG_EXT:
 		cdo_mode_bits |=
-			CR_CHAN(cmd->
-			scan_begin_arg) & CDO_Sample_Source_Select_Mask;
+		    CR_CHAN(cmd->scan_begin_arg) &
+		    CDO_Sample_Source_Select_Mask;
 		break;
 	default:
 		BUG();
@@ -3677,7 +3775,7 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		ni_writel(s->io_bits, M_Offset_CDO_Mask_Enable);
 	} else {
 		comedi_error(dev,
-			"attempted to run digital output command with no lines configured as outputs");
+			     "attempted to run digital output command with no lines configured as outputs");
 		return -EIO;
 	}
 	retval = ni_request_cdo_mite_channel(dev);
@@ -3689,7 +3787,7 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			  unsigned int trignum)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -3732,16 +3830,17 @@ static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 		return -EIO;
 	}
 	ni_writel(CDO_Arm_Bit | CDO_Error_Interrupt_Enable_Set_Bit |
-		CDO_Empty_FIFO_Interrupt_Enable_Set_Bit, M_Offset_CDIO_Command);
+		  CDO_Empty_FIFO_Interrupt_Enable_Set_Bit,
+		  M_Offset_CDIO_Command);
 	return retval;
 }
 
 static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	ni_writel(CDO_Disarm_Bit | CDO_Error_Interrupt_Enable_Clear_Bit |
-		CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
-		CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
-		M_Offset_CDIO_Command);
+		  CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
+		  CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
+		  M_Offset_CDIO_Command);
 /*
 * XXX not sure what interrupt C group does ni_writeb(0,
 * M_Offset_Interrupt_C_Enable);
@@ -3766,11 +3865,11 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
 		unsigned cdo_mite_status =
-			mite_get_status(devpriv->cdo_mite_chan);
+		    mite_get_status(devpriv->cdo_mite_chan);
 		if (cdo_mite_status & CHSR_LINKC) {
 			writel(CHOR_CLRLC,
-				devpriv->mite->mite_io_addr +
-				MITE_CHOR(devpriv->cdo_mite_chan->channel));
+			       devpriv->mite->mite_io_addr +
+			       MITE_CHOR(devpriv->cdo_mite_chan->channel));
 		}
 		mite_sync_output_dma(devpriv->cdo_mite_chan, s->async);
 	}
@@ -3786,14 +3885,15 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 	if (cdio_status & CDO_FIFO_Empty_Bit) {
 /* printk("cdio fifo empty\n"); */
 		ni_writel(CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
-			M_Offset_CDIO_Command);
+			  M_Offset_CDIO_Command);
 /* s->async->events |= COMEDI_CB_EOA; */
 	}
 	ni_event(dev, s);
 }
 
-static int ni_serial_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_serial_insn_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int err = insn->n;
 	unsigned char byte_out, byte_in = 0;
@@ -3813,7 +3913,7 @@ static int ni_serial_insn_config(struct comedi_device *dev, struct comedi_subdev
 		if (data[1] == SERIAL_DISABLED) {
 			devpriv->serial_hw_mode = 0;
 			devpriv->dio_control &= ~(DIO_HW_Serial_Enable |
-				DIO_Software_Serial_Control);
+						  DIO_Software_Serial_Control);
 			data[1] = SERIAL_DISABLED;
 			devpriv->serial_interval_ns = data[1];
 		} else if (data[1] <= SERIAL_600NS) {
@@ -3827,13 +3927,13 @@ static int ni_serial_insn_config(struct comedi_device *dev, struct comedi_subdev
 		} else if (data[1] <= SERIAL_1_2US) {
 			devpriv->dio_control &= ~DIO_HW_Serial_Timebase;
 			devpriv->clock_and_fout |= Slow_Internal_Timebase |
-				DIO_Serial_Out_Divide_By_2;
+			    DIO_Serial_Out_Divide_By_2;
 			data[1] = SERIAL_1_2US;
 			devpriv->serial_interval_ns = data[1];
 		} else if (data[1] <= SERIAL_10US) {
 			devpriv->dio_control |= DIO_HW_Serial_Timebase;
 			devpriv->clock_and_fout |= Slow_Internal_Timebase |
-				DIO_Serial_Out_Divide_By_2;
+			    DIO_Serial_Out_Divide_By_2;
 			/* Note: DIO_Serial_Out_Divide_By_2 only affects
 			   600ns/1.2us. If you turn divide_by_2 off with the
 			   slow clock, you will still get 10us, except then
@@ -3842,16 +3942,16 @@ static int ni_serial_insn_config(struct comedi_device *dev, struct comedi_subdev
 			devpriv->serial_interval_ns = data[1];
 		} else {
 			devpriv->dio_control &= ~(DIO_HW_Serial_Enable |
-				DIO_Software_Serial_Control);
+						  DIO_Software_Serial_Control);
 			devpriv->serial_hw_mode = 0;
 			data[1] = (data[1] / 1000) * 1000;
 			devpriv->serial_interval_ns = data[1];
 		}
 
 		devpriv->stc_writew(dev, devpriv->dio_control,
-			DIO_Control_Register);
+				    DIO_Control_Register);
 		devpriv->stc_writew(dev, devpriv->clock_and_fout,
-			Clock_and_FOUT_Register);
+				    Clock_and_FOUT_Register);
 		return 1;
 
 		break;
@@ -3866,10 +3966,10 @@ static int ni_serial_insn_config(struct comedi_device *dev, struct comedi_subdev
 
 		if (devpriv->serial_hw_mode) {
 			err = ni_serial_hw_readwrite8(dev, s, byte_out,
-				&byte_in);
+						      &byte_in);
 		} else if (devpriv->serial_interval_ns > 0) {
 			err = ni_serial_sw_readwrite8(dev, s, byte_out,
-				&byte_in);
+						      &byte_in);
 		} else {
 			printk("ni_serial_insn_config: serial disabled!\n");
 			return -EINVAL;
@@ -3886,8 +3986,10 @@ static int ni_serial_insn_config(struct comedi_device *dev, struct comedi_subdev
 
 }
 
-static int ni_serial_hw_readwrite8(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned char data_out, unsigned char *data_in)
+static int ni_serial_hw_readwrite8(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned char data_out,
+				   unsigned char *data_in)
 {
 	unsigned int status1;
 	int err = 0, count = 20;
@@ -3912,14 +4014,14 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev, struct comedi_subd
 
 	/* Wait until STC says we're done, but don't loop infinitely. */
 	while ((status1 =
-			devpriv->stc_readw(dev,
-				Joint_Status_1_Register)) &
-		DIO_Serial_IO_In_Progress_St) {
+		devpriv->stc_readw(dev,
+				   Joint_Status_1_Register)) &
+	       DIO_Serial_IO_In_Progress_St) {
 		/* Delay one bit per loop */
 		udelay((devpriv->serial_interval_ns + 999) / 1000);
 		if (--count < 0) {
 			printk
-				("ni_serial_hw_readwrite8: SPI serial I/O didn't finish in time!\n");
+			    ("ni_serial_hw_readwrite8: SPI serial I/O didn't finish in time!\n");
 			err = -ETIME;
 			goto Error;
 		}
@@ -3936,14 +4038,16 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev, struct comedi_subd
 #endif
 	}
 
-      Error:
+Error:
 	devpriv->stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
 
 	return err;
 }
 
-static int ni_serial_sw_readwrite8(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned char data_out, unsigned char *data_in)
+static int ni_serial_sw_readwrite8(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned char data_out,
+				   unsigned char *data_in)
 {
 	unsigned char mask, input = 0;
 
@@ -3963,25 +4067,26 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev, struct comedi_subd
 			devpriv->dio_output |= DIO_SDOUT;
 		}
 		devpriv->stc_writew(dev, devpriv->dio_output,
-			DIO_Output_Register);
+				    DIO_Output_Register);
 
 		/* Assert SDCLK (active low, inverted), wait for half of
 		   the delay, deassert SDCLK, and wait for the other half. */
 		devpriv->dio_control |= DIO_Software_Serial_Control;
 		devpriv->stc_writew(dev, devpriv->dio_control,
-			DIO_Control_Register);
+				    DIO_Control_Register);
 
 		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
 		devpriv->dio_control &= ~DIO_Software_Serial_Control;
 		devpriv->stc_writew(dev, devpriv->dio_control,
-			DIO_Control_Register);
+				    DIO_Control_Register);
 
 		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
 		/* Input current bit */
 		if (devpriv->stc_readw(dev,
-				DIO_Parallel_Input_Register) & DIO_SDIN) {
+				       DIO_Parallel_Input_Register) & DIO_SDIN)
+		{
 /*			printk("DIO_P_I_R: 0x%x\n", devpriv->stc_readw(dev, DIO_Parallel_Input_Register)); */
 			input |= mask;
 		}
@@ -4010,10 +4115,9 @@ static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int i;
 
-	for (i = 0; i < s->n_chan; i++)
-	{
+	for (i = 0; i < s->n_chan; i++) {
 		ni_ao_win_outw(dev, AO_Channel(i) | 0x0,
-			AO_Configuration_2_67xx);
+			       AO_Configuration_2_67xx);
 	}
 	ao_win_out(0x0, AO_Later_Single_Point_Updates);
 }
@@ -4102,7 +4206,7 @@ static unsigned ni_gpct_to_stc_register(enum ni_gpct_register reg)
 		break;
 	default:
 		printk("%s: unhandled register 0x%x in switch.\n",
-			__func__, reg);
+		       __func__, reg);
 		BUG();
 		return 0;
 		break;
@@ -4111,16 +4215,16 @@ static unsigned ni_gpct_to_stc_register(enum ni_gpct_register reg)
 }
 
 static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
-	enum ni_gpct_register reg)
+				   enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
 	unsigned stc_register;
 	/* bits in the join reset register which are relevant to counters */
 	static const unsigned gpct_joint_reset_mask = G0_Reset | G1_Reset;
 	static const unsigned gpct_interrupt_a_enable_mask =
-		G0_Gate_Interrupt_Enable | G0_TC_Interrupt_Enable;
+	    G0_Gate_Interrupt_Enable | G0_TC_Interrupt_Enable;
 	static const unsigned gpct_interrupt_b_enable_mask =
-		G1_Gate_Interrupt_Enable | G1_TC_Interrupt_Enable;
+	    G1_Gate_Interrupt_Enable | G1_TC_Interrupt_Enable;
 
 	switch (reg) {
 		/* m-series-only registers */
@@ -4162,12 +4266,12 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 	case NITIO_G0_Interrupt_Enable_Reg:
 		BUG_ON(bits & ~gpct_interrupt_a_enable_mask);
 		ni_set_bitfield(dev, Interrupt_A_Enable_Register,
-			gpct_interrupt_a_enable_mask, bits);
+				gpct_interrupt_a_enable_mask, bits);
 		break;
 	case NITIO_G1_Interrupt_Enable_Reg:
 		BUG_ON(bits & ~gpct_interrupt_b_enable_mask);
 		ni_set_bitfield(dev, Interrupt_B_Enable_Register,
-			gpct_interrupt_b_enable_mask, bits);
+				gpct_interrupt_b_enable_mask, bits);
 		break;
 	case NITIO_G01_Joint_Reset_Reg:
 		BUG_ON(bits & ~gpct_joint_reset_mask);
@@ -4179,7 +4283,7 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 }
 
 static unsigned ni_gpct_read_register(struct ni_gpct *counter,
-	enum ni_gpct_register reg)
+				      enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
 	unsigned stc_register;
@@ -4211,27 +4315,30 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 }
 
 static int ni_freq_out_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->clock_and_fout & FOUT_Divider_mask;
 	return 1;
 }
 
 static int ni_freq_out_insn_write(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	devpriv->clock_and_fout &= ~FOUT_Enable;
 	devpriv->stc_writew(dev, devpriv->clock_and_fout,
-		Clock_and_FOUT_Register);
+			    Clock_and_FOUT_Register);
 	devpriv->clock_and_fout &= ~FOUT_Divider_mask;
 	devpriv->clock_and_fout |= FOUT_Divider(data[0]);
 	devpriv->clock_and_fout |= FOUT_Enable;
 	devpriv->stc_writew(dev, devpriv->clock_and_fout,
-		Clock_and_FOUT_Register);
+			    Clock_and_FOUT_Register);
 	return insn->n;
 }
 
-static int ni_set_freq_out_clock(struct comedi_device *dev, unsigned int clock_source)
+static int ni_set_freq_out_clock(struct comedi_device *dev,
+				 unsigned int clock_source)
 {
 	switch (clock_source) {
 	case NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC:
@@ -4244,12 +4351,13 @@ static int ni_set_freq_out_clock(struct comedi_device *dev, unsigned int clock_s
 		return -EINVAL;
 	}
 	devpriv->stc_writew(dev, devpriv->clock_and_fout,
-		Clock_and_FOUT_Register);
+			    Clock_and_FOUT_Register);
 	return 3;
 }
 
-static void ni_get_freq_out_clock(struct comedi_device *dev, unsigned int *clock_source,
-	unsigned int *clock_period_ns)
+static void ni_get_freq_out_clock(struct comedi_device *dev,
+				  unsigned int *clock_source,
+				  unsigned int *clock_period_ns)
 {
 	if (devpriv->clock_and_fout & FOUT_Timebase_Select) {
 		*clock_source = NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC;
@@ -4260,8 +4368,9 @@ static void ni_get_freq_out_clock(struct comedi_device *dev, unsigned int *clock
 	}
 }
 
-static int ni_freq_out_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_freq_out_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_SET_CLOCK_SRC:
@@ -4312,7 +4421,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (boardtype.n_adchan) {
 		s->type = COMEDI_SUBD_AI;
 		s->subdev_flags =
-			SDF_READABLE | SDF_DIFF | SDF_DITHER | SDF_CMD_READ;
+		    SDF_READABLE | SDF_DIFF | SDF_DITHER | SDF_CMD_READ;
 		if (boardtype.reg_type != ni_reg_611x)
 			s->subdev_flags |= SDF_GROUND | SDF_COMMON | SDF_OTHER;
 		if (boardtype.adbits > 16)
@@ -4387,7 +4496,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->n_chan = boardtype.num_p0_dio_channels;
 	if (boardtype.reg_type & ni_reg_m_series_mask) {
 		s->subdev_flags |=
-			SDF_LSAMPL | SDF_CMD_WRITE /* | SDF_CMD_READ */ ;
+		    SDF_LSAMPL | SDF_CMD_WRITE /* | SDF_CMD_READ */ ;
 		s->insn_bits = &ni_m_series_dio_insn_bits;
 		s->insn_config = &ni_m_series_dio_insn_config;
 		s->do_cmd = &ni_cdio_cmd;
@@ -4463,7 +4572,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 		ni_writew(s->state, M_Offset_PFI_DO);
 		for (i = 0; i < NUM_PFI_OUTPUT_SELECT_REGS; ++i) {
 			ni_writew(devpriv->pfi_output_select_reg[i],
-				M_Offset_PFI_Output_Select(i + 1));
+				  M_Offset_PFI_Output_Select(i + 1));
 		}
 	} else {
 		s->n_chan = 10;
@@ -4517,15 +4626,17 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 		counter_variant = ni_gpct_variant_e_series;
 	}
 	devpriv->counter_dev = ni_gpct_device_construct(dev,
-		&ni_gpct_write_register, &ni_gpct_read_register,
-		counter_variant, NUM_GPCT);
+							&ni_gpct_write_register,
+							&ni_gpct_read_register,
+							counter_variant,
+							NUM_GPCT);
 	/* General purpose counters */
 	for (j = 0; j < NUM_GPCT; ++j) {
 		s = dev->subdevices + NI_GPCT_SUBDEV(j);
 		s->type = COMEDI_SUBD_COUNTER;
 		s->subdev_flags =
-			SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL | SDF_CMD_READ
-			/* | SDF_CMD_WRITE */ ;
+		    SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL | SDF_CMD_READ
+		    /* | SDF_CMD_WRITE */ ;
 		s->n_chan = 3;
 		if (boardtype.reg_type & ni_reg_m_series_mask)
 			s->maxdata = 0xffffffff;
@@ -4561,32 +4672,33 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 	if ((boardtype.reg_type & ni_reg_6xxx_mask) == 0) {
 		/*  BEAM is this needed for PCI-6143 ?? */
 		devpriv->clock_and_fout =
-			Slow_Internal_Time_Divide_By_2 |
-			Slow_Internal_Timebase |
-			Clock_To_Board_Divide_By_2 |
-			Clock_To_Board |
-			AI_Output_Divide_By_2 | AO_Output_Divide_By_2;
+		    Slow_Internal_Time_Divide_By_2 |
+		    Slow_Internal_Timebase |
+		    Clock_To_Board_Divide_By_2 |
+		    Clock_To_Board |
+		    AI_Output_Divide_By_2 | AO_Output_Divide_By_2;
 	} else {
 		devpriv->clock_and_fout =
-			Slow_Internal_Time_Divide_By_2 |
-			Slow_Internal_Timebase |
-			Clock_To_Board_Divide_By_2 | Clock_To_Board;
+		    Slow_Internal_Time_Divide_By_2 |
+		    Slow_Internal_Timebase |
+		    Clock_To_Board_Divide_By_2 | Clock_To_Board;
 	}
 	devpriv->stc_writew(dev, devpriv->clock_and_fout,
-		Clock_and_FOUT_Register);
+			    Clock_and_FOUT_Register);
 
 	/* analog output configuration */
 	ni_ao_reset(dev, dev->subdevices + NI_AO_SUBDEV);
 
 	if (dev->irq) {
 		devpriv->stc_writew(dev,
-			(IRQ_POLARITY ? Interrupt_Output_Polarity : 0) |
-			(Interrupt_Output_On_3_Pins & 0) | Interrupt_A_Enable |
-			Interrupt_B_Enable |
-			Interrupt_A_Output_Select(interrupt_pin(dev->
-					irq)) |
-			Interrupt_B_Output_Select(interrupt_pin(dev->irq)),
-			Interrupt_Control_Register);
+				    (IRQ_POLARITY ? Interrupt_Output_Polarity :
+				     0) | (Interrupt_Output_On_3_Pins & 0) |
+				    Interrupt_A_Enable | Interrupt_B_Enable |
+				    Interrupt_A_Output_Select(interrupt_pin
+							      (dev->irq)) |
+				    Interrupt_B_Output_Select(interrupt_pin
+							      (dev->irq)),
+				    Interrupt_Control_Register);
 	}
 
 	/* DMA setup */
@@ -4600,7 +4712,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 		for (channel = 0; channel < boardtype.n_aochan; ++channel) {
 			ni_writeb(0xf, M_Offset_AO_Waveform_Order(channel));
 			ni_writeb(0x0,
-				M_Offset_AO_Reference_Attenuation(channel));
+				  M_Offset_AO_Reference_Attenuation(channel));
 		}
 		ni_writeb(0x0, M_Offset_AO_Calibration);
 	}
@@ -4611,7 +4723,7 @@ static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 {
-	struct comedi_device *dev = (struct comedi_device *) arg;
+	struct comedi_device *dev = (struct comedi_device *)arg;
 
 	if (dir) {
 		ni_writeb(data, Port_A + 2 * port);
@@ -4625,8 +4737,9 @@ static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 	presents the EEPROM as a subdevice
 */
 
-static int ni_eeprom_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_eeprom_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));
 
@@ -4646,9 +4759,9 @@ static int ni_read_eeprom(struct comedi_device *dev, int addr)
 	ni_writeb(0x04, Serial_Command);
 	for (bit = 0x8000; bit; bit >>= 1) {
 		ni_writeb(0x04 | ((bit & bitstring) ? 0x02 : 0),
-			Serial_Command);
+			  Serial_Command);
 		ni_writeb(0x05 | ((bit & bitstring) ? 0x02 : 0),
-			Serial_Command);
+			  Serial_Command);
 	}
 	bitstring = 0;
 	for (bit = 0x80; bit; bit >>= 1) {
@@ -4662,7 +4775,9 @@ static int ni_read_eeprom(struct comedi_device *dev, int addr)
 }
 
 static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+					struct comedi_subdevice *s,
+					struct comedi_insn *insn,
+					unsigned int *data)
 {
 	data[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];
 
@@ -4676,8 +4791,9 @@ static int ni_get_pwm_config(struct comedi_device *dev, unsigned int *data)
 	return 3;
 }
 
-static int ni_m_series_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_m_series_pwm_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned up_count, down_count;
 	switch (data[0]) {
@@ -4685,16 +4801,16 @@ static int ni_m_series_pwm_config(struct comedi_device *dev, struct comedi_subde
 		switch (data[1]) {
 		case TRIG_ROUND_NEAREST:
 			up_count =
-				(data[2] +
-				devpriv->clock_ns / 2) / devpriv->clock_ns;
+			    (data[2] +
+			     devpriv->clock_ns / 2) / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_DOWN:
 			up_count = data[2] / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_UP:
 			up_count =
-				(data[2] + devpriv->clock_ns -
-				1) / devpriv->clock_ns;
+			    (data[2] + devpriv->clock_ns -
+			     1) / devpriv->clock_ns;
 			break;
 		default:
 			return -EINVAL;
@@ -4703,30 +4819,30 @@ static int ni_m_series_pwm_config(struct comedi_device *dev, struct comedi_subde
 		switch (data[3]) {
 		case TRIG_ROUND_NEAREST:
 			down_count =
-				(data[4] +
-				devpriv->clock_ns / 2) / devpriv->clock_ns;
+			    (data[4] +
+			     devpriv->clock_ns / 2) / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_DOWN:
 			down_count = data[4] / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_UP:
 			down_count =
-				(data[4] + devpriv->clock_ns -
-				1) / devpriv->clock_ns;
+			    (data[4] + devpriv->clock_ns -
+			     1) / devpriv->clock_ns;
 			break;
 		default:
 			return -EINVAL;
 			break;
 		}
 		if (up_count * devpriv->clock_ns != data[2] ||
-			down_count * devpriv->clock_ns != data[4]) {
+		    down_count * devpriv->clock_ns != data[4]) {
 			data[2] = up_count * devpriv->clock_ns;
 			data[4] = down_count * devpriv->clock_ns;
 			return -EAGAIN;
 		}
 		ni_writel(MSeries_Cal_PWM_High_Time_Bits(up_count) |
-			MSeries_Cal_PWM_Low_Time_Bits(down_count),
-			M_Offset_Cal_PWM);
+			  MSeries_Cal_PWM_Low_Time_Bits(down_count),
+			  M_Offset_Cal_PWM);
 		devpriv->pwm_up_count = up_count;
 		devpriv->pwm_down_count = down_count;
 		return 5;
@@ -4741,8 +4857,9 @@ static int ni_m_series_pwm_config(struct comedi_device *dev, struct comedi_subde
 	return 0;
 }
 
-static int ni_6143_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_6143_pwm_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned up_count, down_count;
 	switch (data[0]) {
@@ -4750,16 +4867,16 @@ static int ni_6143_pwm_config(struct comedi_device *dev, struct comedi_subdevice
 		switch (data[1]) {
 		case TRIG_ROUND_NEAREST:
 			up_count =
-				(data[2] +
-				devpriv->clock_ns / 2) / devpriv->clock_ns;
+			    (data[2] +
+			     devpriv->clock_ns / 2) / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_DOWN:
 			up_count = data[2] / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_UP:
 			up_count =
-				(data[2] + devpriv->clock_ns -
-				1) / devpriv->clock_ns;
+			    (data[2] + devpriv->clock_ns -
+			     1) / devpriv->clock_ns;
 			break;
 		default:
 			return -EINVAL;
@@ -4768,23 +4885,23 @@ static int ni_6143_pwm_config(struct comedi_device *dev, struct comedi_subdevice
 		switch (data[3]) {
 		case TRIG_ROUND_NEAREST:
 			down_count =
-				(data[4] +
-				devpriv->clock_ns / 2) / devpriv->clock_ns;
+			    (data[4] +
+			     devpriv->clock_ns / 2) / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_DOWN:
 			down_count = data[4] / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_UP:
 			down_count =
-				(data[4] + devpriv->clock_ns -
-				1) / devpriv->clock_ns;
+			    (data[4] + devpriv->clock_ns -
+			     1) / devpriv->clock_ns;
 			break;
 		default:
 			return -EINVAL;
 			break;
 		}
 		if (up_count * devpriv->clock_ns != data[2] ||
-			down_count * devpriv->clock_ns != data[4]) {
+		    down_count * devpriv->clock_ns != data[4]) {
 			data[2] = up_count * devpriv->clock_ns;
 			data[4] = down_count * devpriv->clock_ns;
 			return -EAGAIN;
@@ -4808,16 +4925,18 @@ static void ni_write_caldac(struct comedi_device *dev, int addr, int val);
 /*
 	calibration subdevice
 */
-static int ni_calib_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_calib_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	ni_write_caldac(dev, CR_CHAN(insn->chanspec), data[0]);
 
 	return 1;
 }
 
-static int ni_calib_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_calib_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];
 
@@ -4884,7 +5003,7 @@ static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 			type = boardtype.caldac[i];
 			for (j = 0; j < caldacs[type].n_chans; j++) {
 				maxdata_list[chan] =
-					(1 << caldacs[type].n_bits) - 1;
+				    (1 << caldacs[type].n_bits) - 1;
 				chan++;
 			}
 		}
@@ -4948,8 +5067,8 @@ static int pack_mb88341(int addr, int val, int *bitstring)
 	 */
 	addr++;
 	*bitstring = ((addr & 0x1) << 11) |
-		((addr & 0x2) << 9) |
-		((addr & 0x4) << 7) | ((addr & 0x8) << 5) | (val & 0xff);
+	    ((addr & 0x2) << 9) |
+	    ((addr & 0x4) << 7) | ((addr & 0x8) << 5) | (val & 0xff);
 	return 12;
 }
 
@@ -4993,11 +5112,11 @@ static int GPCT_G_Watch(struct comedi_device *dev, int chan)
 
 	devpriv->gpct_command[chan] &= ~G_Save_Trace;
 	devpriv->stc_writew(dev, devpriv->gpct_command[chan],
-		G_Command_Register(chan));
+			    G_Command_Register(chan));
 
 	devpriv->gpct_command[chan] |= G_Save_Trace;
 	devpriv->stc_writew(dev, devpriv->gpct_command[chan],
-		G_Command_Register(chan));
+			    G_Command_Register(chan));
 
 	/* This procedure is used because the two registers cannot
 	 * be read atomically. */
@@ -5021,37 +5140,37 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 	case 0:
 		devpriv->stc_writew(dev, G0_Reset, Joint_Reset_Register);
 		ni_set_bits(dev, Interrupt_A_Enable_Register,
-			G0_TC_Interrupt_Enable, 0);
+			    G0_TC_Interrupt_Enable, 0);
 		ni_set_bits(dev, Interrupt_A_Enable_Register,
-			G0_Gate_Interrupt_Enable, 0);
+			    G0_Gate_Interrupt_Enable, 0);
 		temp_ack_reg |= G0_Gate_Error_Confirm;
 		temp_ack_reg |= G0_TC_Error_Confirm;
 		temp_ack_reg |= G0_TC_Interrupt_Ack;
 		temp_ack_reg |= G0_Gate_Interrupt_Ack;
 		devpriv->stc_writew(dev, temp_ack_reg,
-			Interrupt_A_Ack_Register);
+				    Interrupt_A_Ack_Register);
 
 		/* problem...this interferes with the other ctr... */
 		devpriv->an_trig_etc_reg |= GPFO_0_Output_Enable;
 		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
-			Analog_Trigger_Etc_Register);
+				    Analog_Trigger_Etc_Register);
 		break;
 	case 1:
 		devpriv->stc_writew(dev, G1_Reset, Joint_Reset_Register);
 		ni_set_bits(dev, Interrupt_B_Enable_Register,
-			G1_TC_Interrupt_Enable, 0);
+			    G1_TC_Interrupt_Enable, 0);
 		ni_set_bits(dev, Interrupt_B_Enable_Register,
-			G0_Gate_Interrupt_Enable, 0);
+			    G0_Gate_Interrupt_Enable, 0);
 		temp_ack_reg |= G1_Gate_Error_Confirm;
 		temp_ack_reg |= G1_TC_Error_Confirm;
 		temp_ack_reg |= G1_TC_Interrupt_Ack;
 		temp_ack_reg |= G1_Gate_Interrupt_Ack;
 		devpriv->stc_writew(dev, temp_ack_reg,
-			Interrupt_B_Ack_Register);
+				    Interrupt_B_Ack_Register);
 
 		devpriv->an_trig_etc_reg |= GPFO_1_Output_Enable;
 		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
-			Analog_Trigger_Etc_Register);
+				    Analog_Trigger_Etc_Register);
 		break;
 	};
 
@@ -5062,9 +5181,9 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 	devpriv->gpct_command[chan] |= G_Synchronized_Gate;
 
 	devpriv->stc_writew(dev, devpriv->gpct_mode[chan],
-		G_Mode_Register(chan));
+			    G_Mode_Register(chan));
 	devpriv->stc_writew(dev, devpriv->gpct_input_select[chan],
-		G_Input_Select_Register(chan));
+			    G_Input_Select_Register(chan));
 	devpriv->stc_writew(dev, 0, G_Autoincrement_Register(chan));
 
 	/* printk("exit GPCT_Reset\n"); */
@@ -5072,22 +5191,25 @@ static void GPCT_Reset(struct comedi_device *dev, int chan)
 
 #endif
 
-static int ni_gpct_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_gpct_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_insn_config(counter, insn, data);
 }
 
-static int ni_gpct_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_gpct_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_rinsn(counter, insn, data);
 }
 
-static int ni_gpct_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_gpct_insn_write(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_winsn(counter, insn, data);
@@ -5101,10 +5223,10 @@ static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 /* const struct comedi_cmd *cmd = &s->async->cmd; */
 
 	retval = ni_request_gpct_mite_channel(dev, counter->counter_index,
-		COMEDI_INPUT);
+					      COMEDI_INPUT);
 	if (retval) {
 		comedi_error(dev,
-			"no dma channel available for use by counter");
+			     "no dma channel available for use by counter");
 		return retval;
 	}
 	ni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);
@@ -5116,8 +5238,8 @@ static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return retval;
 }
 
-static int ni_gpct_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int ni_gpct_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 #ifdef PCIDMA
 	struct ni_gpct *counter = s->private;
@@ -5150,7 +5272,7 @@ static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
  */
 
 static int ni_m_series_set_pfi_routing(struct comedi_device *dev, unsigned chan,
-	unsigned source)
+				       unsigned source)
 {
 	unsigned pfi_reg_index;
 	unsigned array_offset;
@@ -5159,16 +5281,16 @@ static int ni_m_series_set_pfi_routing(struct comedi_device *dev, unsigned chan,
 	pfi_reg_index = 1 + chan / 3;
 	array_offset = pfi_reg_index - 1;
 	devpriv->pfi_output_select_reg[array_offset] &=
-		~MSeries_PFI_Output_Select_Mask(chan);
+	    ~MSeries_PFI_Output_Select_Mask(chan);
 	devpriv->pfi_output_select_reg[array_offset] |=
-		MSeries_PFI_Output_Select_Bits(chan, source);
+	    MSeries_PFI_Output_Select_Bits(chan, source);
 	ni_writew(devpriv->pfi_output_select_reg[array_offset],
-		M_Offset_PFI_Output_Select(pfi_reg_index));
+		  M_Offset_PFI_Output_Select(pfi_reg_index));
 	return 2;
 }
 
 static int ni_old_set_pfi_routing(struct comedi_device *dev, unsigned chan,
-	unsigned source)
+				  unsigned source)
 {
 	/*  pre-m-series boards have fixed signals on pfi pins */
 	if (source != ni_old_get_pfi_routing(dev, chan))
@@ -5177,7 +5299,7 @@ static int ni_old_set_pfi_routing(struct comedi_device *dev, unsigned chan,
 }
 
 static int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,
-	unsigned source)
+			      unsigned source)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
 		return ni_m_series_set_pfi_routing(dev, chan, source);
@@ -5185,11 +5307,14 @@ static int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,
 		return ni_old_set_pfi_routing(dev, chan, source);
 }
 
-static unsigned ni_m_series_get_pfi_routing(struct comedi_device *dev, unsigned chan)
+static unsigned ni_m_series_get_pfi_routing(struct comedi_device *dev,
+					    unsigned chan)
 {
 	const unsigned array_offset = chan / 3;
 	return MSeries_PFI_Output_Select_Source(chan,
-		devpriv->pfi_output_select_reg[array_offset]);
+						devpriv->
+						pfi_output_select_reg
+						[array_offset]);
 }
 
 static unsigned ni_old_get_pfi_routing(struct comedi_device *dev, unsigned chan)
@@ -5242,7 +5367,7 @@ static unsigned ni_get_pfi_routing(struct comedi_device *dev, unsigned chan)
 }
 
 static int ni_config_filter(struct comedi_device *dev, unsigned pfi_channel,
-	enum ni_pfi_filter_select filter)
+			    enum ni_pfi_filter_select filter)
 {
 	unsigned bits;
 	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
@@ -5255,8 +5380,9 @@ static int ni_config_filter(struct comedi_device *dev, unsigned pfi_channel,
 	return 0;
 }
 
-static int ni_pfi_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_pfi_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
 		return -ENOTSUPP;
@@ -5270,8 +5396,9 @@ static int ni_pfi_insn_bits(struct comedi_device *dev, struct comedi_subdevice *
 	return 2;
 }
 
-static int ni_pfi_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_pfi_insn_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan;
 
@@ -5289,9 +5416,8 @@ static int ni_pfi_insn_config(struct comedi_device *dev, struct comedi_subdevice
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(devpriv->
-			io_bidirection_pin_reg & (1 << chan)) ? COMEDI_OUTPUT :
-			COMEDI_INPUT;
+		    (devpriv->io_bidirection_pin_reg & (1 << chan)) ?
+		    COMEDI_OUTPUT : COMEDI_INPUT;
 		return 0;
 		break;
 	case INSN_CONFIG_SET_ROUTING:
@@ -5325,23 +5451,26 @@ static void ni_rtsi_init(struct comedi_device *dev)
 	}
 	/*  default internal lines routing to RTSI bus lines */
 	devpriv->rtsi_trig_a_output_reg =
-		RTSI_Trig_Output_Bits(0,
-		NI_RTSI_OUTPUT_ADR_START1) | RTSI_Trig_Output_Bits(1,
-		NI_RTSI_OUTPUT_ADR_START2) | RTSI_Trig_Output_Bits(2,
-		NI_RTSI_OUTPUT_SCLKG) | RTSI_Trig_Output_Bits(3,
-		NI_RTSI_OUTPUT_DACUPDN);
+	    RTSI_Trig_Output_Bits(0,
+				  NI_RTSI_OUTPUT_ADR_START1) |
+	    RTSI_Trig_Output_Bits(1,
+				  NI_RTSI_OUTPUT_ADR_START2) |
+	    RTSI_Trig_Output_Bits(2,
+				  NI_RTSI_OUTPUT_SCLKG) |
+	    RTSI_Trig_Output_Bits(3, NI_RTSI_OUTPUT_DACUPDN);
 	devpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
-		RTSI_Trig_A_Output_Register);
+			    RTSI_Trig_A_Output_Register);
 	devpriv->rtsi_trig_b_output_reg =
-		RTSI_Trig_Output_Bits(4,
-		NI_RTSI_OUTPUT_DA_START1) | RTSI_Trig_Output_Bits(5,
-		NI_RTSI_OUTPUT_G_SRC0) | RTSI_Trig_Output_Bits(6,
-		NI_RTSI_OUTPUT_G_GATE0);
+	    RTSI_Trig_Output_Bits(4,
+				  NI_RTSI_OUTPUT_DA_START1) |
+	    RTSI_Trig_Output_Bits(5,
+				  NI_RTSI_OUTPUT_G_SRC0) |
+	    RTSI_Trig_Output_Bits(6, NI_RTSI_OUTPUT_G_GATE0);
 	if (boardtype.reg_type & ni_reg_m_series_mask)
 		devpriv->rtsi_trig_b_output_reg |=
-			RTSI_Trig_Output_Bits(7, NI_RTSI_OUTPUT_RTSI_OSC);
+		    RTSI_Trig_Output_Bits(7, NI_RTSI_OUTPUT_RTSI_OSC);
 	devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
-		RTSI_Trig_B_Output_Register);
+			    RTSI_Trig_B_Output_Register);
 
 /*
 * Sets the source and direction of the 4 on board lines
@@ -5349,8 +5478,9 @@ static void ni_rtsi_init(struct comedi_device *dev)
 */
 }
 
-static int ni_rtsi_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_rtsi_insn_bits(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -5363,8 +5493,9 @@ static int ni_rtsi_insn_bits(struct comedi_device *dev, struct comedi_subdevice
 /* Find best multiplier/divider to try and get the PLL running at 80 MHz
  * given an arbitrary frequency input clock */
 static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
-	unsigned *freq_divider, unsigned *freq_multiplier,
-	unsigned *actual_period_ns)
+					 unsigned *freq_divider,
+					 unsigned *freq_multiplier,
+					 unsigned *actual_period_ns)
 {
 	unsigned div;
 	unsigned best_div = 1;
@@ -5383,9 +5514,9 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 	for (div = 1; div <= max_div; ++div) {
 		for (mult = 1; mult <= max_mult; ++mult) {
 			unsigned new_period_ps =
-				(reference_picosec * div) / mult;
+			    (reference_picosec * div) / mult;
 			if (abs(new_period_ps - target_picosec) <
-				abs(best_period_picosec - target_picosec)) {
+			    abs(best_period_picosec - target_picosec)) {
 				best_period_picosec = new_period_ps;
 				best_div = div;
 				best_mult = mult;
@@ -5393,15 +5524,14 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 		}
 	}
 	if (best_period_picosec == 0) {
-		printk("%s: bug, failed to find pll parameters\n",
-			__func__);
+		printk("%s: bug, failed to find pll parameters\n", __func__);
 		return -EIO;
 	}
 	*freq_divider = best_div;
 	*freq_multiplier = best_mult;
 	*actual_period_ns =
-		(best_period_picosec * fudge_factor_80_to_20Mhz +
-		(pico_per_nano / 2)) / pico_per_nano;
+	    (best_period_picosec * fudge_factor_80_to_20Mhz +
+	     (pico_per_nano / 2)) / pico_per_nano;
 	return 0;
 }
 
@@ -5413,8 +5543,8 @@ static inline unsigned num_configurable_rtsi_channels(struct comedi_device *dev)
 		return 7;
 }
 
-static int ni_mseries_set_pll_master_clock(struct comedi_device *dev, unsigned source,
-	unsigned period_ns)
+static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
+					   unsigned source, unsigned period_ns)
 {
 	static const unsigned min_period_ns = 50;
 	static const unsigned max_period_ns = 1000;
@@ -5429,34 +5559,36 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev, unsigned s
 	/*  these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that */
 	if (period_ns < min_period_ns || period_ns > max_period_ns) {
 		printk
-			("%s: you must specify an input clock frequency between %i and %i nanosec "
-			"for the phased-lock loop.\n", __func__,
-			min_period_ns, max_period_ns);
+		    ("%s: you must specify an input clock frequency between %i and %i nanosec "
+		     "for the phased-lock loop.\n", __func__,
+		     min_period_ns, max_period_ns);
 		return -EINVAL;
 	}
 	devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
 	devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-		RTSI_Trig_Direction_Register);
+			    RTSI_Trig_Direction_Register);
 	pll_control_bits =
-		MSeries_PLL_Enable_Bit | MSeries_PLL_VCO_Mode_75_150MHz_Bits;
+	    MSeries_PLL_Enable_Bit | MSeries_PLL_VCO_Mode_75_150MHz_Bits;
 	devpriv->clock_and_fout2 |=
-		MSeries_Timebase1_Select_Bit | MSeries_Timebase3_Select_Bit;
+	    MSeries_Timebase1_Select_Bit | MSeries_Timebase3_Select_Bit;
 	devpriv->clock_and_fout2 &= ~MSeries_PLL_In_Source_Select_Mask;
 	switch (source) {
 	case NI_MIO_PLL_PXI_STAR_TRIGGER_CLOCK:
 		devpriv->clock_and_fout2 |=
-			MSeries_PLL_In_Source_Select_Star_Trigger_Bits;
+		    MSeries_PLL_In_Source_Select_Star_Trigger_Bits;
 		retval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,
-			&freq_multiplier, &devpriv->clock_ns);
+						       &freq_multiplier,
+						       &devpriv->clock_ns);
 		if (retval < 0)
 			return retval;
 		break;
 	case NI_MIO_PLL_PXI10_CLOCK:
 		/* pxi clock is 10MHz */
 		devpriv->clock_and_fout2 |=
-			MSeries_PLL_In_Source_Select_PXI_Clock10;
+		    MSeries_PLL_In_Source_Select_PXI_Clock10;
 		retval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,
-			&freq_multiplier, &devpriv->clock_ns);
+						       &freq_multiplier,
+						       &devpriv->clock_ns);
 		if (retval < 0)
 			return retval;
 		break;
@@ -5465,20 +5597,22 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev, unsigned s
 			unsigned rtsi_channel;
 			static const unsigned max_rtsi_channel = 7;
 			for (rtsi_channel = 0; rtsi_channel <= max_rtsi_channel;
-				++rtsi_channel) {
+			     ++rtsi_channel) {
 				if (source ==
-					NI_MIO_PLL_RTSI_CLOCK(rtsi_channel)) {
+				    NI_MIO_PLL_RTSI_CLOCK(rtsi_channel)) {
 					devpriv->clock_and_fout2 |=
-						MSeries_PLL_In_Source_Select_RTSI_Bits
-						(rtsi_channel);
+					    MSeries_PLL_In_Source_Select_RTSI_Bits
+					    (rtsi_channel);
 					break;
 				}
 			}
 			if (rtsi_channel > max_rtsi_channel)
 				return -EINVAL;
 			retval = ni_mseries_get_pll_parameters(period_ns,
-				&freq_divider, &freq_multiplier,
-				&devpriv->clock_ns);
+							       &freq_divider,
+							       &freq_multiplier,
+							       &devpriv->
+							       clock_ns);
 			if (retval < 0)
 				return retval;
 		}
@@ -5486,8 +5620,8 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev, unsigned s
 	}
 	ni_writew(devpriv->clock_and_fout2, M_Offset_Clock_and_Fout2);
 	pll_control_bits |=
-		MSeries_PLL_Divisor_Bits(freq_divider) |
-		MSeries_PLL_Multiplier_Bits(freq_multiplier);
+	    MSeries_PLL_Divisor_Bits(freq_divider) |
+	    MSeries_PLL_Multiplier_Bits(freq_multiplier);
 
 	/* printk("using divider=%i, multiplier=%i for PLL. pll_control_bits = 0x%x\n",
 	 * freq_divider, freq_multiplier, pll_control_bits); */
@@ -5503,45 +5637,46 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev, unsigned s
 	}
 	if (i == timeout) {
 		printk
-			("%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns.\n",
-			__func__, source, period_ns);
+		    ("%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns.\n",
+		     __func__, source, period_ns);
 		return -ETIMEDOUT;
 	}
 	return 3;
 }
 
 static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
-	unsigned period_ns)
+			       unsigned period_ns)
 {
 	if (source == NI_MIO_INTERNAL_CLOCK) {
 		devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
 		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-			RTSI_Trig_Direction_Register);
+				    RTSI_Trig_Direction_Register);
 		devpriv->clock_ns = TIMEBASE_1_NS;
 		if (boardtype.reg_type & ni_reg_m_series_mask) {
 			devpriv->clock_and_fout2 &=
-				~(MSeries_Timebase1_Select_Bit |
-				MSeries_Timebase3_Select_Bit);
+			    ~(MSeries_Timebase1_Select_Bit |
+			      MSeries_Timebase3_Select_Bit);
 			ni_writew(devpriv->clock_and_fout2,
-				M_Offset_Clock_and_Fout2);
+				  M_Offset_Clock_and_Fout2);
 			ni_writew(0, M_Offset_PLL_Control);
 		}
 		devpriv->clock_source = source;
 	} else {
 		if (boardtype.reg_type & ni_reg_m_series_mask) {
 			return ni_mseries_set_pll_master_clock(dev, source,
-				period_ns);
+							       period_ns);
 		} else {
 			if (source == NI_MIO_RTSI_CLOCK) {
 				devpriv->rtsi_trig_direction_reg |=
-					Use_RTSI_Clock_Bit;
+				    Use_RTSI_Clock_Bit;
 				devpriv->stc_writew(dev,
-					devpriv->rtsi_trig_direction_reg,
-					RTSI_Trig_Direction_Register);
+						    devpriv->
+						    rtsi_trig_direction_reg,
+						    RTSI_Trig_Direction_Register);
 				if (period_ns == 0) {
 					printk
-						("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",
-						__func__);
+					    ("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",
+					     __func__);
 					return -EINVAL;
 				} else {
 					devpriv->clock_ns = period_ns;
@@ -5555,7 +5690,7 @@ static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 }
 
 static int ni_valid_rtsi_output_source(struct comedi_device *dev, unsigned chan,
-	unsigned source)
+				       unsigned source)
 {
 	if (chan >= num_configurable_rtsi_channels(dev)) {
 		if (chan == old_RTSI_clock_channel) {
@@ -5563,9 +5698,8 @@ static int ni_valid_rtsi_output_source(struct comedi_device *dev, unsigned chan,
 				return 1;
 			else {
 				printk
-					("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",
-					__func__, chan,
-					old_RTSI_clock_channel);
+				    ("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",
+				     __func__, chan, old_RTSI_clock_channel);
 				return 0;
 			}
 		}
@@ -5596,22 +5730,22 @@ static int ni_valid_rtsi_output_source(struct comedi_device *dev, unsigned chan,
 }
 
 static int ni_set_rtsi_routing(struct comedi_device *dev, unsigned chan,
-	unsigned source)
+			       unsigned source)
 {
 	if (ni_valid_rtsi_output_source(dev, chan, source) == 0)
 		return -EINVAL;
 	if (chan < 4) {
 		devpriv->rtsi_trig_a_output_reg &= ~RTSI_Trig_Output_Mask(chan);
 		devpriv->rtsi_trig_a_output_reg |=
-			RTSI_Trig_Output_Bits(chan, source);
+		    RTSI_Trig_Output_Bits(chan, source);
 		devpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
-			RTSI_Trig_A_Output_Register);
+				    RTSI_Trig_A_Output_Register);
 	} else if (chan < 8) {
 		devpriv->rtsi_trig_b_output_reg &= ~RTSI_Trig_Output_Mask(chan);
 		devpriv->rtsi_trig_b_output_reg |=
-			RTSI_Trig_Output_Bits(chan, source);
+		    RTSI_Trig_Output_Bits(chan, source);
 		devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
-			RTSI_Trig_B_Output_Register);
+				    RTSI_Trig_B_Output_Register);
 	}
 	return 2;
 }
@@ -5620,10 +5754,10 @@ static unsigned ni_get_rtsi_routing(struct comedi_device *dev, unsigned chan)
 {
 	if (chan < 4) {
 		return RTSI_Trig_Output_Source(chan,
-			devpriv->rtsi_trig_a_output_reg);
+					       devpriv->rtsi_trig_a_output_reg);
 	} else if (chan < num_configurable_rtsi_channels(dev)) {
 		return RTSI_Trig_Output_Source(chan,
-			devpriv->rtsi_trig_b_output_reg);
+					       devpriv->rtsi_trig_b_output_reg);
 	} else {
 		if (chan == old_RTSI_clock_channel)
 			return NI_RTSI_OUTPUT_RTSI_OSC;
@@ -5632,53 +5766,54 @@ static unsigned ni_get_rtsi_routing(struct comedi_device *dev, unsigned chan)
 	}
 }
 
-static int ni_rtsi_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_rtsi_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
 		if (chan < num_configurable_rtsi_channels(dev)) {
 			devpriv->rtsi_trig_direction_reg |=
-				RTSI_Output_Bit(chan,
-				(boardtype.reg_type & ni_reg_m_series_mask) !=
-				0);
+			    RTSI_Output_Bit(chan,
+					    (boardtype.
+					     reg_type & ni_reg_m_series_mask) !=
+					    0);
 		} else if (chan == old_RTSI_clock_channel) {
 			devpriv->rtsi_trig_direction_reg |=
-				Drive_RTSI_Clock_Bit;
+			    Drive_RTSI_Clock_Bit;
 		}
 		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-			RTSI_Trig_Direction_Register);
+				    RTSI_Trig_Direction_Register);
 		break;
 	case INSN_CONFIG_DIO_INPUT:
 		if (chan < num_configurable_rtsi_channels(dev)) {
 			devpriv->rtsi_trig_direction_reg &=
-				~RTSI_Output_Bit(chan,
-				(boardtype.reg_type & ni_reg_m_series_mask) !=
-				0);
+			    ~RTSI_Output_Bit(chan,
+					     (boardtype.
+					      reg_type & ni_reg_m_series_mask)
+					     != 0);
 		} else if (chan == old_RTSI_clock_channel) {
 			devpriv->rtsi_trig_direction_reg &=
-				~Drive_RTSI_Clock_Bit;
+			    ~Drive_RTSI_Clock_Bit;
 		}
 		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-			RTSI_Trig_Direction_Register);
+				    RTSI_Trig_Direction_Register);
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		if (chan < num_configurable_rtsi_channels(dev)) {
 			data[1] =
-				(devpriv->
-				rtsi_trig_direction_reg & RTSI_Output_Bit(chan,
-					(boardtype.
-						reg_type & ni_reg_m_series_mask)
-					!=
-					0)) ? INSN_CONFIG_DIO_OUTPUT :
-				INSN_CONFIG_DIO_INPUT;
+			    (devpriv->rtsi_trig_direction_reg &
+			     RTSI_Output_Bit(chan,
+					     (boardtype.reg_type &
+					      ni_reg_m_series_mask)
+					     != 0)) ? INSN_CONFIG_DIO_OUTPUT :
+			    INSN_CONFIG_DIO_INPUT;
 		} else if (chan == old_RTSI_clock_channel) {
 			data[1] =
-				(devpriv->
-				rtsi_trig_direction_reg & Drive_RTSI_Clock_Bit)
-				? INSN_CONFIG_DIO_OUTPUT :
-				INSN_CONFIG_DIO_INPUT;
+			    (devpriv->rtsi_trig_direction_reg &
+			     Drive_RTSI_Clock_Bit)
+			    ? INSN_CONFIG_DIO_OUTPUT : INSN_CONFIG_DIO_INPUT;
 		}
 		return 2;
 		break;
@@ -5751,12 +5886,12 @@ static void cs5529_command(struct comedi_device *dev, unsigned short value)
 
 /* write to cs5529 register */
 static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
-	unsigned int reg_select_bits)
+				unsigned int reg_select_bits)
 {
 	ni_ao_win_outw(dev, ((value >> 16) & 0xff),
-		CAL_ADC_Config_Data_High_Word_67xx);
+		       CAL_ADC_Config_Data_High_Word_67xx);
 	ni_ao_win_outw(dev, (value & 0xffff),
-		CAL_ADC_Config_Data_Low_Word_67xx);
+		       CAL_ADC_Config_Data_Low_Word_67xx);
 	reg_select_bits &= CSCMD_REGISTER_SELECT_MASK;
 	cs5529_command(dev, CSCMD_COMMAND | reg_select_bits);
 	if (cs5529_wait_for_idle(dev))
@@ -5766,7 +5901,7 @@ static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
 #ifdef NI_CS5529_DEBUG
 /* read from cs5529 register */
 static unsigned int cs5529_config_read(struct comedi_device *dev,
-	unsigned int reg_select_bits)
+				       unsigned int reg_select_bits)
 {
 	unsigned int value;
 
@@ -5775,7 +5910,8 @@ static unsigned int cs5529_config_read(struct comedi_device *dev,
 	if (cs5529_wait_for_idle(dev))
 		comedi_error(dev, "timeout or signal in cs5529_config_read()");
 	value = (ni_ao_win_inw(dev,
-			CAL_ADC_Config_Data_High_Word_67xx) << 16) & 0xff0000;
+			       CAL_ADC_Config_Data_High_Word_67xx) << 16) &
+	    0xff0000;
 	value |= ni_ao_win_inw(dev, CAL_ADC_Config_Data_Low_Word_67xx) & 0xffff;
 	return value;
 }
@@ -5790,18 +5926,18 @@ static int cs5529_do_conversion(struct comedi_device *dev, unsigned short *data)
 	retval = cs5529_wait_for_idle(dev);
 	if (retval) {
 		comedi_error(dev,
-			"timeout or signal in cs5529_do_conversion()");
+			     "timeout or signal in cs5529_do_conversion()");
 		return -ETIME;
 	}
 	status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
 	if (status & CSS_OSC_DETECT) {
 		printk
-			("ni_mio_common: cs5529 conversion error, status CSS_OSC_DETECT\n");
+		    ("ni_mio_common: cs5529 conversion error, status CSS_OSC_DETECT\n");
 		return -EIO;
 	}
 	if (status & CSS_OVERRANGE) {
 		printk
-			("ni_mio_common: cs5529 conversion error, overrange (ignoring)\n");
+		    ("ni_mio_common: cs5529 conversion error, overrange (ignoring)\n");
 	}
 	if (data) {
 		*data = ni_ao_win_inw(dev, CAL_ADC_Data_67xx);
@@ -5811,8 +5947,9 @@ static int cs5529_do_conversion(struct comedi_device *dev, unsigned short *data)
 	return 0;
 }
 
-static int cs5529_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cs5529_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n, retval;
 	unsigned short sample;
@@ -5840,29 +5977,28 @@ static int cs5529_ai_insn_read(struct comedi_device *dev, struct comedi_subdevic
 static int init_cs5529(struct comedi_device *dev)
 {
 	unsigned int config_bits =
-		CSCFG_PORT_MODE | CSCFG_WORD_RATE_2180_CYCLES;
+	    CSCFG_PORT_MODE | CSCFG_WORD_RATE_2180_CYCLES;
 
 #if 1
 	/* do self-calibration */
 	cs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET_GAIN,
-		CSCMD_CONFIG_REGISTER);
+			    CSCMD_CONFIG_REGISTER);
 	/* need to force a conversion for calibration to run */
 	cs5529_do_conversion(dev, NULL);
 #else
 	/* force gain calibration to 1 */
 	cs5529_config_write(dev, 0x400000, CSCMD_GAIN_REGISTER);
 	cs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET,
-		CSCMD_CONFIG_REGISTER);
+			    CSCMD_CONFIG_REGISTER);
 	if (cs5529_wait_for_idle(dev))
 		comedi_error(dev, "timeout or signal in init_cs5529()\n");
 #endif
 #ifdef NI_CS5529_DEBUG
 	printk("config: 0x%x\n", cs5529_config_read(dev,
-		CSCMD_CONFIG_REGISTER));
-	printk("gain: 0x%x\n", cs5529_config_read(dev,
-		CSCMD_GAIN_REGISTER));
+						    CSCMD_CONFIG_REGISTER));
+	printk("gain: 0x%x\n", cs5529_config_read(dev, CSCMD_GAIN_REGISTER));
 	printk("offset: 0x%x\n", cs5529_config_read(dev,
-		CSCMD_OFFSET_REGISTER));
+						    CSCMD_OFFSET_REGISTER));
 #endif
 	return 0;
 }

commit 25436dc9d84f1be60ff549c9ab712bba2835f284
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 15:14:34 2009 -0700

    Staging: comedi: remove RT code
    
    This removes the unused RT code from the comedi subsystem.
    
    A lot of drivers needed to then include interrupt.h on their own, as they
    were picking it up through the comedi_rt.h inclusion.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 476f30a13d16..d727d7533fc8 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -61,6 +61,7 @@
 /* #define DEBUG_STATUS_A */
 /* #define DEBUG_STATUS_B */
 
+#include <linux/interrupt.h>
 #include "8255.h"
 #include "mite.h"
 #include "comedi_fc.h"

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 7b0030e853c4..476f30a13d16 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -365,7 +365,7 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
+	spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
 	switch (reg) {
 	case Interrupt_A_Enable_Register:
 		devpriv->int_a_enable_reg &= ~bit_mask;
@@ -396,13 +396,13 @@ static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 		ni_writeb(devpriv->g0_g1_select_reg, G0_G1_Select);
 		break;
 	default:
-		rt_printk("Warning %s() called with invalid register\n",
+		printk("Warning %s() called with invalid register\n",
 			__func__);
-		rt_printk("reg is %d\n", reg);
+		printk("reg is %d\n", reg);
 		break;
 	}
 	mmiowb();
-	comedi_spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
+	spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
 }
 
 #ifdef PCIDMA
@@ -460,7 +460,7 @@ static inline void ni_set_cdo_dma_channel(struct comedi_device *dev, int mite_ch
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
+	spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
 	devpriv->cdio_dma_select_reg &= ~CDO_DMA_Select_Mask;
 	if (mite_channel >= 0) {
 		/*XXX just guessing ni_stc_dma_channel_select_bitfield() returns the right bits,
@@ -472,19 +472,19 @@ static inline void ni_set_cdo_dma_channel(struct comedi_device *dev, int mite_ch
 	}
 	ni_writeb(devpriv->cdio_dma_select_reg, M_Offset_CDIO_DMA_Select);
 	mmiowb();
-	comedi_spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
+	spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
 }
 
 static int ni_request_ai_mite_channel(struct comedi_device *dev)
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->ai_mite_chan);
 	devpriv->ai_mite_chan =
 		mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);
 	if (devpriv->ai_mite_chan == NULL) {
-		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
 			flags);
 		comedi_error(dev,
 			"failed to reserve mite dma channel for analog input.");
@@ -492,7 +492,7 @@ static int ni_request_ai_mite_channel(struct comedi_device *dev)
 	}
 	devpriv->ai_mite_chan->dir = COMEDI_INPUT;
 	ni_set_ai_dma_channel(dev, devpriv->ai_mite_chan->channel);
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	return 0;
 }
 
@@ -500,12 +500,12 @@ static int ni_request_ao_mite_channel(struct comedi_device *dev)
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->ao_mite_chan);
 	devpriv->ao_mite_chan =
 		mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);
 	if (devpriv->ao_mite_chan == NULL) {
-		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
 			flags);
 		comedi_error(dev,
 			"failed to reserve mite dma channel for analog outut.");
@@ -513,7 +513,7 @@ static int ni_request_ao_mite_channel(struct comedi_device *dev)
 	}
 	devpriv->ao_mite_chan->dir = COMEDI_OUTPUT;
 	ni_set_ao_dma_channel(dev, devpriv->ao_mite_chan->channel);
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	return 0;
 }
 
@@ -524,13 +524,13 @@ static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 	struct mite_channel *mite_chan;
 
 	BUG_ON(gpct_index >= NUM_GPCT);
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->counter_dev->counters[gpct_index].mite_chan);
 	mite_chan =
 		mite_request_channel(devpriv->mite,
 		devpriv->gpct_mite_ring[gpct_index]);
 	if (mite_chan == NULL) {
-		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
 			flags);
 		comedi_error(dev,
 			"failed to reserve mite dma channel for counter.");
@@ -540,7 +540,7 @@ static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 	ni_tio_set_mite_channel(&devpriv->counter_dev->counters[gpct_index],
 		mite_chan);
 	ni_set_gpct_dma_channel(dev, gpct_index, mite_chan->channel);
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	return 0;
 }
 
@@ -551,12 +551,12 @@ static int ni_request_cdo_mite_channel(struct comedi_device *dev)
 #ifdef PCIDMA
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->cdo_mite_chan);
 	devpriv->cdo_mite_chan =
 		mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);
 	if (devpriv->cdo_mite_chan == NULL) {
-		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
 			flags);
 		comedi_error(dev,
 			"failed to reserve mite dma channel for correlated digital outut.");
@@ -564,7 +564,7 @@ static int ni_request_cdo_mite_channel(struct comedi_device *dev)
 	}
 	devpriv->cdo_mite_chan->dir = COMEDI_OUTPUT;
 	ni_set_cdo_dma_channel(dev, devpriv->cdo_mite_chan->channel);
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif /*  PCIDMA */
 	return 0;
 }
@@ -574,13 +574,13 @@ static void ni_release_ai_mite_channel(struct comedi_device *dev)
 #ifdef PCIDMA
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ai_mite_chan) {
 		ni_set_ai_dma_channel(dev, -1);
 		mite_release_channel(devpriv->ai_mite_chan);
 		devpriv->ai_mite_chan = NULL;
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif /*  PCIDMA */
 }
 
@@ -589,13 +589,13 @@ static void ni_release_ao_mite_channel(struct comedi_device *dev)
 #ifdef PCIDMA
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ao_mite_chan) {
 		ni_set_ao_dma_channel(dev, -1);
 		mite_release_channel(devpriv->ao_mite_chan);
 		devpriv->ao_mite_chan = NULL;
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif /*  PCIDMA */
 }
 
@@ -605,7 +605,7 @@ void ni_release_gpct_mite_channel(struct comedi_device *dev, unsigned gpct_index
 	unsigned long flags;
 
 	BUG_ON(gpct_index >= NUM_GPCT);
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->counter_dev->counters[gpct_index].mite_chan) {
 		struct mite_channel *mite_chan =
 			devpriv->counter_dev->counters[gpct_index].mite_chan;
@@ -615,7 +615,7 @@ void ni_release_gpct_mite_channel(struct comedi_device *dev, unsigned gpct_index
 			counters[gpct_index], NULL);
 		mite_release_channel(mite_chan);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif /*  PCIDMA */
 }
 
@@ -624,13 +624,13 @@ static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 #ifdef PCIDMA
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
 		ni_set_cdo_dma_channel(dev, -1);
 		mite_release_channel(devpriv->cdo_mite_chan);
 		devpriv->cdo_mite_chan = NULL;
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif /*  PCIDMA */
 }
 
@@ -712,20 +712,20 @@ static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data, int
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	spin_lock_irqsave(&devpriv->window_lock, flags);
 	ni_writew(addr, AO_Window_Address_611x);
 	ni_writew(data, AO_Window_Data_611x);
-	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
 static inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data, int addr)
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	spin_lock_irqsave(&devpriv->window_lock, flags);
 	ni_writew(addr, AO_Window_Address_611x);
 	ni_writel(data, AO_Window_Data_611x);
-	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
 static inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)
@@ -733,10 +733,10 @@ static inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)
 	unsigned long flags;
 	unsigned short data;
 
-	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	spin_lock_irqsave(&devpriv->window_lock, flags);
 	ni_writew(addr, AO_Window_Address_611x);
 	data = ni_readw(AO_Window_Data_611x);
-	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 	return data;
 }
 
@@ -779,15 +779,14 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 	smp_mb();		/*  make sure dev->attached is checked before handler does anything else. */
 
 	/*  lock to avoid race with comedi_poll */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	a_status = devpriv->stc_readw(dev, AI_Status_1_Register);
 	b_status = devpriv->stc_readw(dev, AO_Status_1_Register);
 #ifdef PCIDMA
 	if (mite) {
 		unsigned long flags_too;
 
-		comedi_spin_lock_irqsave(&devpriv->mite_channel_lock,
-			flags_too);
+		spin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);
 		if (devpriv->ai_mite_chan) {
 			ai_mite_status = mite_get_status(devpriv->ai_mite_chan);
 			if (ai_mite_status & CHSR_LINKC)
@@ -804,8 +803,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 					MITE_CHOR(devpriv->ao_mite_chan->
 						channel));
 		}
-		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
-			flags_too);
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);
 	}
 #endif
 	ack_a_interrupt(dev, a_status);
@@ -818,7 +816,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 	handle_gpct_interrupt(dev, 1);
 	handle_cdio_interrupt(dev);
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 	return IRQ_HANDLED;
 }
 
@@ -828,10 +826,10 @@ static void ni_sync_ai_dma(struct comedi_device *dev)
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ai_mite_chan)
 		mite_sync_input_dma(devpriv->ai_mite_chan, s->async);
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
 static void mite_handle_b_linkc(struct mite_struct *mite, struct comedi_device * dev)
@@ -839,11 +837,11 @@ static void mite_handle_b_linkc(struct mite_struct *mite, struct comedi_device *
 	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ao_mite_chan) {
 		mite_sync_output_dma(devpriv->ao_mite_chan, s->async);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
 static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
@@ -858,7 +856,7 @@ static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 			break;
 		/* if we poll too often, the pci bus activity seems
 		   to slow the dma transfer down */
-		comedi_udelay(10);
+		udelay(10);
 	}
 	if (i == timeout) {
 		comedi_error(dev, "timed out waiting for dma load");
@@ -879,7 +877,7 @@ static void ni_handle_eos(struct comedi_device *dev, struct comedi_subdevice *s)
 			ni_sync_ai_dma(dev);
 			if ((s->async->events & COMEDI_CB_EOS))
 				break;
-			comedi_udelay(1);
+			udelay(1);
 		}
 #else
 		ni_handle_fifo_dregs(dev);
@@ -976,7 +974,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 		return;
 
 #ifdef DEBUG_INTERRUPT
-	rt_printk
+	printk
 		("ni_mio_common: interrupt: a_status=%04x ai_mite_status=%08x\n",
 		status, ai_mite_status);
 	ni_mio_print_status_a(status);
@@ -989,7 +987,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	if (ai_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
 			CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
 			CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
-		rt_printk
+		printk
 			("unknown mite interrupt, ack! (ai_mite_status=%08x)\n",
 			ai_mite_status);
 		/* mite_print_chsr(ai_mite_status); */
@@ -1002,7 +1000,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	if (status & (AI_Overrun_St | AI_Overflow_St | AI_SC_TC_Error_St |
 			AI_SC_TC_St | AI_START1_St)) {
 		if (status == 0xffff) {
-			rt_printk
+			printk
 				("ni_mio_common: a_status=0xffff.  Card removed?\n");
 			/* we probably aren't even running a command now,
 			 * so it's a good idea to be careful. */
@@ -1015,7 +1013,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 		}
 		if (status & (AI_Overrun_St | AI_Overflow_St |
 				AI_SC_TC_Error_St)) {
-			rt_printk("ni_mio_common: ai error a_status=%04x\n",
+			printk("ni_mio_common: ai error a_status=%04x\n",
 				status);
 			ni_mio_print_status_a(status);
 
@@ -1031,7 +1029,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 		}
 		if (status & AI_SC_TC_St) {
 #ifdef DEBUG_INTERRUPT
-			rt_printk("ni_mio_common: SC_TC interrupt\n");
+			printk("ni_mio_common: SC_TC interrupt\n");
 #endif
 			if (!devpriv->ai_continuous) {
 				shutdown_ai_command(dev);
@@ -1063,7 +1061,7 @@ static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 #ifdef DEBUG_INTERRUPT
 	status = devpriv->stc_readw(dev, AI_Status_1_Register);
 	if (status & Interrupt_A_St) {
-		rt_printk
+		printk
 			("handle_a_interrupt: didn't clear interrupt? status=0x%x\n",
 			status);
 	}
@@ -1104,7 +1102,7 @@ static void handle_b_interrupt(struct comedi_device *dev, unsigned short b_statu
 	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	/* unsigned short ack=0; */
 #ifdef DEBUG_INTERRUPT
-	rt_printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
+	printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
 		b_status, ao_mite_status);
 	ni_mio_print_status_b(b_status);
 #endif
@@ -1118,7 +1116,7 @@ static void handle_b_interrupt(struct comedi_device *dev, unsigned short b_statu
 	if (ao_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
 			CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
 			CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
-		rt_printk
+		printk
 			("unknown mite interrupt, ack! (ao_mite_status=%08x)\n",
 			ao_mite_status);
 		/* mite_print_chsr(ao_mite_status); */
@@ -1129,7 +1127,7 @@ static void handle_b_interrupt(struct comedi_device *dev, unsigned short b_statu
 	if (b_status == 0xffff)
 		return;
 	if (b_status & AO_Overrun_St) {
-		rt_printk
+		printk
 			("ni_mio_common: AO FIFO underrun status=0x%04x status2=0x%04x\n",
 			b_status, devpriv->stc_readw(dev,
 				AO_Status_2_Register));
@@ -1146,7 +1144,7 @@ static void handle_b_interrupt(struct comedi_device *dev, unsigned short b_statu
 
 		ret = ni_ao_fifo_half_empty(dev, s);
 		if (!ret) {
-			rt_printk("ni_mio_common: AO buffer underrun\n");
+			printk("ni_mio_common: AO buffer underrun\n");
 			ni_set_bits(dev, Interrupt_B_Enable_Register,
 				AO_FIFO_Interrupt_Enable |
 				AO_Error_Interrupt_Enable, 0);
@@ -1170,13 +1168,13 @@ static void ni_mio_print_status_a(int status)
 {
 	int i;
 
-	rt_printk("A status:");
+	printk("A status:");
 	for (i = 15; i >= 0; i--) {
 		if (status & (1 << i)) {
-			rt_printk(" %s", status_a_strings[i]);
+			printk(" %s", status_a_strings[i]);
 		}
 	}
-	rt_printk("\n");
+	printk("\n");
 }
 #endif
 
@@ -1192,13 +1190,13 @@ static void ni_mio_print_status_b(int status)
 {
 	int i;
 
-	rt_printk("B status:");
+	printk("B status:");
 	for (i = 15; i >= 0; i--) {
 		if (status & (1 << i)) {
-			rt_printk(" %s", status_b_strings[i]);
+			printk(" %s", status_b_strings[i]);
 		}
 	}
-	rt_printk("\n");
+	printk("\n");
 }
 #endif
 
@@ -1383,7 +1381,7 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 	unsigned long flags;
 	int retval = 0;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ai_mite_chan) {
 		for (i = 0; i < timeout; i++) {
 			if ((devpriv->stc_readw(dev,
@@ -1392,19 +1390,19 @@ static int ni_ai_drain_dma(struct comedi_device *dev)
 				&& mite_bytes_in_transit(devpriv->
 					ai_mite_chan) == 0)
 				break;
-			comedi_udelay(5);
+			udelay(5);
 		}
 		if (i == timeout) {
-			rt_printk
+			printk
 				("ni_mio_common: wait for dma drain timed out\n");
-			rt_printk
+			printk
 				("mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
 				mite_bytes_in_transit(devpriv->ai_mite_chan),
 				devpriv->stc_readw(dev, AI_Status_1_Register));
 			retval = -1;
 		}
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 
 	ni_sync_ai_dma(dev);
 
@@ -1548,15 +1546,14 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 	retval = ni_request_ai_mite_channel(dev);
 	if (retval)
 		return retval;
-/* rt_printk("comedi_debug: using mite channel %i for ai.\n", devpriv->ai_mite_chan->channel); */
+/* printk("comedi_debug: using mite channel %i for ai.\n", devpriv->ai_mite_chan->channel); */
 
 	/* write alloc the entire buffer */
 	comedi_buf_write_alloc(s->async, s->async->prealloc_bufsz);
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	if (devpriv->ai_mite_chan == NULL)
-	{
-		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if (devpriv->ai_mite_chan == NULL) {
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		return -EIO;
 	}
 
@@ -1574,7 +1571,7 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 	};
 	/*start the MITE */
 	mite_dma_arm(devpriv->ai_mite_chan);
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 
 	return 0;
 }
@@ -1592,7 +1589,7 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 	/* read alloc the entire buffer */
 	comedi_buf_read_alloc(s->async, s->async->prealloc_bufsz);
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ao_mite_chan) {
 		if (boardtype.reg_type & (ni_reg_611x | ni_reg_6713)) {
 			mite_prep_dma(devpriv->ao_mite_chan, 32, 32);
@@ -1604,7 +1601,7 @@ static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 		mite_dma_arm(devpriv->ao_mite_chan);
 	} else
 		retval = -EIO;
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 
 	return retval;
 }
@@ -1705,7 +1702,7 @@ static int ni_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/*  lock to avoid race with interrupt handler */
 	if (in_interrupt() == 0)
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 #ifndef PCIDMA
 	ni_handle_fifo_dregs(dev);
 #else
@@ -1713,7 +1710,7 @@ static int ni_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 #endif
 	count = s->async->buf_write_count - s->async->buf_read_count;
 	if (in_interrupt() == 0)
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return count;
 }
@@ -1736,7 +1733,7 @@ static int ni_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s
 		for (n = 0; n < num_adc_stages_611x; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
 				AI_Command_1_Register);
-			comedi_udelay(1);
+			udelay(1);
 		}
 		for (n = 0; n < insn->n; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
@@ -1758,7 +1755,7 @@ static int ni_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s
 				}
 			}
 			if (i == NI_TIMEOUT) {
-				rt_printk
+				printk
 					("ni_mio_common: timeout in 611x ni_ai_insn_read\n");
 				return -ETIME;
 			}
@@ -1780,7 +1777,7 @@ static int ni_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s
 				}
 			}
 			if (i == NI_TIMEOUT) {
-				rt_printk
+				printk
 					("ni_mio_common: timeout in 6143 ni_ai_insn_read\n");
 				return -ETIME;
 			}
@@ -1797,7 +1794,7 @@ static int ni_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s
 					break;
 			}
 			if (i == NI_TIMEOUT) {
-				rt_printk
+				printk
 					("ni_mio_common: timeout in ni_ai_insn_read\n");
 				return -ETIME;
 			}
@@ -1825,9 +1822,9 @@ void ni_prime_channelgain_list(struct comedi_device *dev)
 			devpriv->stc_writew(dev, 1, ADC_FIFO_Clear);
 			return;
 		}
-		comedi_udelay(1);
+		udelay(1);
 	}
-	rt_printk("ni_mio_common: timeout loading channel/gain list\n");
+	printk("ni_mio_common: timeout loading channel/gain list\n");
 }
 
 static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
@@ -2844,7 +2841,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 				M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		default:
-			rt_printk("%s: bug! unhandled ao reference voltage\n",
+			printk("%s: bug! unhandled ao reference voltage\n",
 				__func__);
 			break;
 		}
@@ -2856,7 +2853,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 			conf |= MSeries_AO_DAC_Offset_5V_Bits;
 			break;
 		default:
-			rt_printk("%s: bug! unhandled ao offset voltage\n",
+			printk("%s: bug! unhandled ao offset voltage\n",
 				__func__);
 			break;
 		}
@@ -3033,7 +3030,7 @@ static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 	/* wait for DACs to be loaded */
 	for (i = 0; i < timeout; i++) {
-		comedi_udelay(1);
+		udelay(1);
 		if ((devpriv->stc_readw(dev,
 					Joint_Status_2_Register) &
 				AO_TMRDACWRs_In_Progress_St) == 0)
@@ -3440,7 +3437,7 @@ static int ni_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice
 	struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
-	rt_printk("ni_dio_insn_config() chan=%d io=%d\n",
+	printk("ni_dio_insn_config() chan=%d io=%d\n",
 		CR_CHAN(insn->chanspec), data[0]);
 #endif
 	switch (data[0]) {
@@ -3472,7 +3469,7 @@ static int ni_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *
 	struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
-	rt_printk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);
+	printk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);
 #endif
 	if (insn->n != 2)
 		return -EINVAL;
@@ -3499,7 +3496,7 @@ static int ni_m_series_dio_insn_config(struct comedi_device *dev,
 	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
-	rt_printk("ni_m_series_dio_insn_config() chan=%d io=%d\n",
+	printk("ni_m_series_dio_insn_config() chan=%d io=%d\n",
 		CR_CHAN(insn->chanspec), data[0]);
 #endif
 	switch (data[0]) {
@@ -3529,7 +3526,7 @@ static int ni_m_series_dio_insn_bits(struct comedi_device *dev, struct comedi_su
 	struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
-	rt_printk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],
+	printk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],
 		data[1]);
 #endif
 	if (insn->n != 2)
@@ -3706,7 +3703,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	comedi_buf_read_alloc(s->async, s->async->prealloc_bufsz);
 
 #ifdef PCIDMA
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
 		mite_prep_dma(devpriv->cdo_mite_chan, 32, 32);
 		mite_dma_arm(devpriv->cdo_mite_chan);
@@ -3714,7 +3711,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 		comedi_error(dev, "BUG: no cdo mite channel?");
 		retval = -EIO;
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	if (retval < 0)
 		return retval;
 #endif
@@ -3726,7 +3723,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	for (i = 0; i < timeout; ++i) {
 		if (ni_readl(M_Offset_CDIO_Status) & CDO_FIFO_Full_Bit)
 			break;
-		comedi_udelay(10);
+		udelay(10);
 	}
 	if (i == timeout) {
 		comedi_error(dev, "dma failed to fill cdo fifo!");
@@ -3765,7 +3762,7 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 		return;
 	}
 #ifdef PCIDMA
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
 		unsigned cdo_mite_status =
 			mite_get_status(devpriv->cdo_mite_chan);
@@ -3776,17 +3773,17 @@ static void handle_cdio_interrupt(struct comedi_device *dev)
 		}
 		mite_sync_output_dma(devpriv->cdo_mite_chan, s->async);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif
 
 	cdio_status = ni_readl(M_Offset_CDIO_Status);
 	if (cdio_status & (CDO_Overrun_Bit | CDO_Underflow_Bit)) {
-/* rt_printk("cdio error: statux=0x%x\n", cdio_status); */
+/* printk("cdio error: statux=0x%x\n", cdio_status); */
 		ni_writel(CDO_Error_Interrupt_Confirm_Bit, M_Offset_CDIO_Command);	/*  XXX just guessing this is needed and does something useful */
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 	if (cdio_status & CDO_FIFO_Empty_Bit) {
-/* rt_printk("cdio fifo empty\n"); */
+/* printk("cdio fifo empty\n"); */
 		ni_writel(CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
 			M_Offset_CDIO_Command);
 /* s->async->events |= COMEDI_CB_EOA; */
@@ -3807,7 +3804,7 @@ static int ni_serial_insn_config(struct comedi_device *dev, struct comedi_subdev
 	case INSN_CONFIG_SERIAL_CLOCK:
 
 #ifdef DEBUG_DIO
-		rt_printk("SPI serial clock Config cd\n", data[1]);
+		printk("SPI serial clock Config cd\n", data[1]);
 #endif
 		devpriv->serial_hw_mode = 1;
 		devpriv->dio_control |= DIO_HW_Serial_Enable;
@@ -3873,7 +3870,7 @@ static int ni_serial_insn_config(struct comedi_device *dev, struct comedi_subdev
 			err = ni_serial_sw_readwrite8(dev, s, byte_out,
 				&byte_in);
 		} else {
-			rt_printk("ni_serial_insn_config: serial disabled!\n");
+			printk("ni_serial_insn_config: serial disabled!\n");
 			return -EINVAL;
 		}
 		if (err < 0)
@@ -3895,7 +3892,7 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev, struct comedi_subd
 	int err = 0, count = 20;
 
 #ifdef DEBUG_DIO
-	rt_printk("ni_serial_hw_readwrite8: outputting 0x%x\n", data_out);
+	printk("ni_serial_hw_readwrite8: outputting 0x%x\n", data_out);
 #endif
 
 	devpriv->dio_output &= ~DIO_Serial_Data_Mask;
@@ -3918,9 +3915,9 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev, struct comedi_subd
 				Joint_Status_1_Register)) &
 		DIO_Serial_IO_In_Progress_St) {
 		/* Delay one bit per loop */
-		comedi_udelay((devpriv->serial_interval_ns + 999) / 1000);
+		udelay((devpriv->serial_interval_ns + 999) / 1000);
 		if (--count < 0) {
-			rt_printk
+			printk
 				("ni_serial_hw_readwrite8: SPI serial I/O didn't finish in time!\n");
 			err = -ETIME;
 			goto Error;
@@ -3929,12 +3926,12 @@ static int ni_serial_hw_readwrite8(struct comedi_device *dev, struct comedi_subd
 
 	/* Delay for last bit. This delay is absolutely necessary, because
 	   DIO_Serial_IO_In_Progress_St goes high one bit too early. */
-	comedi_udelay((devpriv->serial_interval_ns + 999) / 1000);
+	udelay((devpriv->serial_interval_ns + 999) / 1000);
 
 	if (data_in != NULL) {
 		*data_in = devpriv->stc_readw(dev, DIO_Serial_Input_Register);
 #ifdef DEBUG_DIO
-		rt_printk("ni_serial_hw_readwrite8: inputted 0x%x\n", *data_in);
+		printk("ni_serial_hw_readwrite8: inputted 0x%x\n", *data_in);
 #endif
 	}
 
@@ -3950,11 +3947,11 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev, struct comedi_subd
 	unsigned char mask, input = 0;
 
 #ifdef DEBUG_DIO
-	rt_printk("ni_serial_sw_readwrite8: outputting 0x%x\n", data_out);
+	printk("ni_serial_sw_readwrite8: outputting 0x%x\n", data_out);
 #endif
 
 	/* Wait for one bit before transfer */
-	comedi_udelay((devpriv->serial_interval_ns + 999) / 1000);
+	udelay((devpriv->serial_interval_ns + 999) / 1000);
 
 	for (mask = 0x80; mask; mask >>= 1) {
 		/* Output current bit; note that we cannot touch s->state
@@ -3973,23 +3970,23 @@ static int ni_serial_sw_readwrite8(struct comedi_device *dev, struct comedi_subd
 		devpriv->stc_writew(dev, devpriv->dio_control,
 			DIO_Control_Register);
 
-		comedi_udelay((devpriv->serial_interval_ns + 999) / 2000);
+		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
 		devpriv->dio_control &= ~DIO_Software_Serial_Control;
 		devpriv->stc_writew(dev, devpriv->dio_control,
 			DIO_Control_Register);
 
-		comedi_udelay((devpriv->serial_interval_ns + 999) / 2000);
+		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
 		/* Input current bit */
 		if (devpriv->stc_readw(dev,
 				DIO_Parallel_Input_Register) & DIO_SDIN) {
-/*			rt_printk("DIO_P_I_R: 0x%x\n", devpriv->stc_readw(dev, DIO_Parallel_Input_Register)); */
+/*			printk("DIO_P_I_R: 0x%x\n", devpriv->stc_readw(dev, DIO_Parallel_Input_Register)); */
 			input |= mask;
 		}
 	}
 #ifdef DEBUG_DIO
-	rt_printk("ni_serial_sw_readwrite8: inputted 0x%x\n", input);
+	printk("ni_serial_sw_readwrite8: inputted 0x%x\n", input);
 #endif
 	if (data_in)
 		*data_in = input;
@@ -4103,7 +4100,7 @@ static unsigned ni_gpct_to_stc_register(enum ni_gpct_register reg)
 		stc_register = Interrupt_B_Enable_Register;
 		break;
 	default:
-		rt_printk("%s: unhandled register 0x%x in switch.\n",
+		printk("%s: unhandled register 0x%x in switch.\n",
 			__func__, reg);
 		BUG();
 		return 0;
@@ -4928,12 +4925,12 @@ static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 
 	for (bit = 1 << (bits - 1); bit; bit >>= 1) {
 		ni_writeb(((bit & bitstring) ? 0x02 : 0), Serial_Command);
-		comedi_udelay(1);
+		udelay(1);
 		ni_writeb(1 | ((bit & bitstring) ? 0x02 : 0), Serial_Command);
-		comedi_udelay(1);
+		udelay(1);
 	}
 	ni_writeb(loadbit, Serial_Command);
-	comedi_udelay(1);
+	udelay(1);
 	ni_writeb(0, Serial_Command);
 }
 
@@ -5229,7 +5226,7 @@ static unsigned ni_old_get_pfi_routing(struct comedi_device *dev, unsigned chan)
 		return NI_PFI_OUTPUT_G_GATE0;
 		break;
 	default:
-		rt_printk("%s: bug, unhandled case in switch.\n", __func__);
+		printk("%s: bug, unhandled case in switch.\n", __func__);
 		break;
 	}
 	return 0;
@@ -5323,7 +5320,7 @@ static void ni_rtsi_init(struct comedi_device *dev)
 	/*  Set clock mode to internal */
 	devpriv->clock_and_fout2 = MSeries_RTSI_10MHz_Bit;
 	if (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0) {
-		rt_printk("ni_set_master_clock failed, bug?");
+		printk("ni_set_master_clock failed, bug?");
 	}
 	/*  default internal lines routing to RTSI bus lines */
 	devpriv->rtsi_trig_a_output_reg =
@@ -5395,7 +5392,7 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 		}
 	}
 	if (best_period_picosec == 0) {
-		rt_printk("%s: bug, failed to find pll parameters\n",
+		printk("%s: bug, failed to find pll parameters\n",
 			__func__);
 		return -EIO;
 	}
@@ -5430,7 +5427,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev, unsigned s
 		period_ns = 100;
 	/*  these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that */
 	if (period_ns < min_period_ns || period_ns > max_period_ns) {
-		rt_printk
+		printk
 			("%s: you must specify an input clock frequency between %i and %i nanosec "
 			"for the phased-lock loop.\n", __func__,
 			min_period_ns, max_period_ns);
@@ -5491,9 +5488,9 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev, unsigned s
 		MSeries_PLL_Divisor_Bits(freq_divider) |
 		MSeries_PLL_Multiplier_Bits(freq_multiplier);
 
-	/* rt_printk("using divider=%i, multiplier=%i for PLL. pll_control_bits = 0x%x\n",
+	/* printk("using divider=%i, multiplier=%i for PLL. pll_control_bits = 0x%x\n",
 	 * freq_divider, freq_multiplier, pll_control_bits); */
-	/* rt_printk("clock_ns=%d\n", devpriv->clock_ns); */
+	/* printk("clock_ns=%d\n", devpriv->clock_ns); */
 	ni_writew(pll_control_bits, M_Offset_PLL_Control);
 	devpriv->clock_source = source;
 	/* it seems to typically take a few hundred microseconds for PLL to lock */
@@ -5504,7 +5501,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device *dev, unsigned s
 		udelay(1);
 	}
 	if (i == timeout) {
-		rt_printk
+		printk
 			("%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns.\n",
 			__func__, source, period_ns);
 		return -ETIMEDOUT;
@@ -5541,7 +5538,7 @@ static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 					devpriv->rtsi_trig_direction_reg,
 					RTSI_Trig_Direction_Register);
 				if (period_ns == 0) {
-					rt_printk
+					printk
 						("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",
 						__func__);
 					return -EINVAL;
@@ -5564,7 +5561,7 @@ static int ni_valid_rtsi_output_source(struct comedi_device *dev, unsigned chan,
 			if (source == NI_RTSI_OUTPUT_RTSI_OSC)
 				return 1;
 			else {
-				rt_printk
+				printk
 					("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",
 					__func__, chan,
 					old_RTSI_clock_channel);
@@ -5629,7 +5626,7 @@ static unsigned ni_get_rtsi_routing(struct comedi_device *dev, unsigned chan)
 	} else {
 		if (chan == old_RTSI_clock_channel)
 			return NI_RTSI_OUTPUT_RTSI_OSC;
-		rt_printk("%s: bug! should never get here?\n", __func__);
+		printk("%s: bug! should never get here?\n", __func__);
 		return 0;
 	}
 }
@@ -5724,7 +5721,7 @@ static int cs5529_wait_for_idle(struct comedi_device *dev)
 	}
 /* printk("looped %i times waiting for idle\n", i); */
 	if (i == timeout) {
-		rt_printk("%s: %s: timeout\n", __FILE__, __func__);
+		printk("%s: %s: timeout\n", __FILE__, __func__);
 		return -ETIME;
 	}
 	return 0;
@@ -5743,7 +5740,7 @@ static void cs5529_command(struct comedi_device *dev, unsigned short value)
 	for (i = 0; i < timeout; i++) {
 		if ((ni_ao_win_inw(dev, CAL_ADC_Status_67xx) & CSS_ADC_BUSY))
 			break;
-		comedi_udelay(1);
+		udelay(1);
 	}
 /* printk("looped %i times writing command to cs5529\n", i); */
 	if (i == timeout) {
@@ -5797,12 +5794,12 @@ static int cs5529_do_conversion(struct comedi_device *dev, unsigned short *data)
 	}
 	status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
 	if (status & CSS_OSC_DETECT) {
-		rt_printk
+		printk
 			("ni_mio_common: cs5529 conversion error, status CSS_OSC_DETECT\n");
 		return -EIO;
 	}
 	if (status & CSS_OVERRANGE) {
-		rt_printk
+		printk
 			("ni_mio_common: cs5529 conversion error, overrange (ignoring)\n");
 	}
 	if (data) {
@@ -5859,11 +5856,11 @@ static int init_cs5529(struct comedi_device *dev)
 		comedi_error(dev, "timeout or signal in init_cs5529()\n");
 #endif
 #ifdef NI_CS5529_DEBUG
-	rt_printk("config: 0x%x\n", cs5529_config_read(dev,
+	printk("config: 0x%x\n", cs5529_config_read(dev,
 		CSCMD_CONFIG_REGISTER));
-	rt_printk("gain: 0x%x\n", cs5529_config_read(dev,
+	printk("gain: 0x%x\n", cs5529_config_read(dev,
 		CSCMD_GAIN_REGISTER));
-	rt_printk("offset: 0x%x\n", cs5529_config_read(dev,
+	printk("offset: 0x%x\n", cs5529_config_read(dev,
 		CSCMD_OFFSET_REGISTER));
 #endif
 	return 0;

commit 53106ae68acf6eda9593150a25fc44e30fd5ff68
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:21 2009 -0400

    Staging Comedi: fix spacing around parens
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 5c165cac2348..7b0030e853c4 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1554,7 +1554,7 @@ static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 	comedi_buf_write_alloc(s->async, s->async->prealloc_bufsz);
 
 	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	if(devpriv->ai_mite_chan == NULL)
+	if (devpriv->ai_mite_chan == NULL)
 	{
 		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		return -EIO;
@@ -2810,7 +2810,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
 	int i;
 	int invert = 0;
 
-	if(timed) {
+	if (timed) {
 		for (i = 0; i < boardtype.n_aochan; ++i) {
 			devpriv->ao_conf[i] &= ~MSeries_AO_Update_Timed_Bit;
 			ni_writeb(devpriv->ao_conf[i], M_Offset_AO_Config_Bank(i));
@@ -2970,11 +2970,11 @@ static int ni_ao_insn_config(struct comedi_device *dev, struct comedi_subdevice
 {
 	switch (data[0]) {
 	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
-		switch(data[1])
+		switch (data[1])
 		{
 		case COMEDI_OUTPUT:
 			data[2] = 1 + boardtype.ao_fifo_depth * sizeof(short);
-			if(devpriv->mite) data[2] += devpriv->mite->fifo_size;
+			if (devpriv->mite) data[2] += devpriv->mite->fifo_size;
 			break;
 		case COMEDI_INPUT:
 			data[2] = 0;
@@ -3139,7 +3139,7 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		if(boardtype.reg_type & ni_reg_m_series_mask)
+		if (boardtype.reg_type & ni_reg_m_series_mask)
 		{
 			/*  this is how the NI example code does it for m-series boards, verified correct with 6259 */
 			devpriv->stc_writel(dev, cmd->stop_arg - 1, AO_UC_Load_A_Register);
@@ -3422,7 +3422,7 @@ static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (boardtype.reg_type & ni_reg_6xxx_mask) {
 		unsigned immediate_bits = 0;
 		unsigned i;
-		for(i = 0; i < s->n_chan; ++i)
+		for (i = 0; i < s->n_chan; ++i)
 		{
 			immediate_bits |= 1 << i;
 		}

commit f7cbd7aad063b2a4b7aff6a743b2b00015ce3c3e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:16 2009 -0400

    Staging: comedi: Add spaces after commas
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index f277ca6b73d4..5c165cac2348 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -66,7 +66,7 @@
 #include "comedi_fc.h"
 
 #ifndef MDPRINTK
-#define MDPRINTK(format,args...)
+#define MDPRINTK(format, args...)
 #endif
 
 /* A timeout count */
@@ -707,7 +707,7 @@ static uint32_t win_in2(struct comedi_device *dev, int reg)
 	return bits;
 }
 
-#define ao_win_out(data,addr) ni_ao_win_outw(dev,data,addr)
+#define ao_win_out(data, addr) ni_ao_win_outw(dev, data, addr)
 static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data, int addr)
 {
 	unsigned long flags;

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 838487868c62..f277ca6b73d4 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -193,49 +193,49 @@ static const struct comedi_lrange *const ni_range_lkup[] = {
 	[ai_gain_6143] = &range_ni_S_ai_6143
 };
 
-static int ni_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ni_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ni_cdio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int ni_cdio_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int ni_cdio_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static void handle_cdio_interrupt(struct comedi_device * dev);
-static int ni_cdo_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
+static int ni_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ni_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ni_cdio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static void handle_cdio_interrupt(struct comedi_device *dev);
+static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum);
 
-static int ni_serial_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ni_serial_hw_readwrite8(struct comedi_device * dev, struct comedi_subdevice * s,
+static int ni_serial_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ni_serial_hw_readwrite8(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned char data_out, unsigned char *data_in);
-static int ni_serial_sw_readwrite8(struct comedi_device * dev, struct comedi_subdevice * s,
+static int ni_serial_sw_readwrite8(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned char data_out, unsigned char *data_in);
 
-static int ni_calib_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ni_calib_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
+static int ni_calib_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ni_calib_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
 
-static int ni_eeprom_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ni_m_series_eeprom_insn_read(struct comedi_device * dev,
-	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data);
+static int ni_eeprom_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
+	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
 
-static int ni_pfi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ni_pfi_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static unsigned ni_old_get_pfi_routing(struct comedi_device * dev, unsigned chan);
+static int ni_pfi_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ni_pfi_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static unsigned ni_old_get_pfi_routing(struct comedi_device *dev, unsigned chan);
 
-static void ni_rtsi_init(struct comedi_device * dev);
-static int ni_rtsi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ni_rtsi_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
+static void ni_rtsi_init(struct comedi_device *dev);
+static int ni_rtsi_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ni_rtsi_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
 
-static void caldac_setup(struct comedi_device * dev, struct comedi_subdevice * s);
-static int ni_read_eeprom(struct comedi_device * dev, int addr);
+static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ni_read_eeprom(struct comedi_device *dev, int addr);
 
 #ifdef DEBUG_STATUS_A
 static void ni_mio_print_status_a(int status);
@@ -248,58 +248,58 @@ static void ni_mio_print_status_b(int status);
 #define ni_mio_print_status_b(a)
 #endif
 
-static int ni_ai_reset(struct comedi_device * dev, struct comedi_subdevice * s);
+static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s);
 #ifndef PCIDMA
-static void ni_handle_fifo_half_full(struct comedi_device * dev);
-static int ni_ao_fifo_half_empty(struct comedi_device * dev, struct comedi_subdevice * s);
+static void ni_handle_fifo_half_full(struct comedi_device *dev);
+static int ni_ao_fifo_half_empty(struct comedi_device *dev, struct comedi_subdevice *s);
 #endif
-static void ni_handle_fifo_dregs(struct comedi_device * dev);
-static int ni_ai_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
+static void ni_handle_fifo_dregs(struct comedi_device *dev);
+static int ni_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum);
-static void ni_load_channelgain_list(struct comedi_device * dev, unsigned int n_chan,
+static void ni_load_channelgain_list(struct comedi_device *dev, unsigned int n_chan,
 	unsigned int *list);
-static void shutdown_ai_command(struct comedi_device * dev);
+static void shutdown_ai_command(struct comedi_device *dev);
 
-static int ni_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
+static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum);
 
-static int ni_ao_reset(struct comedi_device * dev, struct comedi_subdevice * s);
+static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
 
-static int ni_gpct_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ni_gpct_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ni_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ni_gpct_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int ni_gpct_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int ni_gpct_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static void handle_gpct_interrupt(struct comedi_device * dev,
+static int ni_gpct_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ni_gpct_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ni_gpct_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ni_gpct_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static void handle_gpct_interrupt(struct comedi_device *dev,
 	unsigned short counter_index);
 
-static int init_cs5529(struct comedi_device * dev);
-static int cs5529_do_conversion(struct comedi_device * dev, unsigned short *data);
-static int cs5529_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
+static int init_cs5529(struct comedi_device *dev);
+static int cs5529_do_conversion(struct comedi_device *dev, unsigned short *data);
+static int cs5529_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
 #ifdef NI_CS5529_DEBUG
-static unsigned int cs5529_config_read(struct comedi_device * dev,
+static unsigned int cs5529_config_read(struct comedi_device *dev,
 	unsigned int reg_select_bits);
 #endif
-static void cs5529_config_write(struct comedi_device * dev, unsigned int value,
+static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
 	unsigned int reg_select_bits);
 
-static int ni_m_series_pwm_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ni_6143_pwm_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
+static int ni_m_series_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ni_6143_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
 
-static int ni_set_master_clock(struct comedi_device * dev, unsigned source,
+static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 	unsigned period_ns);
-static void ack_a_interrupt(struct comedi_device * dev, unsigned short a_status);
-static void ack_b_interrupt(struct comedi_device * dev, unsigned short b_status);
+static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status);
+static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status);
 
 enum aimodes {
 	AIMODE_NONE = 0,
@@ -353,14 +353,14 @@ enum timebase_nanoseconds {
 
 static const int num_adc_stages_611x = 3;
 
-static void handle_a_interrupt(struct comedi_device * dev, unsigned short status,
+static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	unsigned ai_mite_status);
-static void handle_b_interrupt(struct comedi_device * dev, unsigned short status,
+static void handle_b_interrupt(struct comedi_device *dev, unsigned short status,
 	unsigned ao_mite_status);
-static void get_last_sample_611x(struct comedi_device * dev);
-static void get_last_sample_6143(struct comedi_device * dev);
+static void get_last_sample_611x(struct comedi_device *dev);
+static void get_last_sample_6143(struct comedi_device *dev);
 
-static inline void ni_set_bitfield(struct comedi_device * dev, int reg,
+static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
 	unsigned bit_mask, unsigned bit_values)
 {
 	unsigned long flags;
@@ -406,12 +406,12 @@ static inline void ni_set_bitfield(struct comedi_device * dev, int reg,
 }
 
 #ifdef PCIDMA
-static int ni_ai_drain_dma(struct comedi_device * dev);
+static int ni_ai_drain_dma(struct comedi_device *dev);
 
 /* DMA channel setup */
 
 /* negative channel means no channel */
-static inline void ni_set_ai_dma_channel(struct comedi_device * dev, int channel)
+static inline void ni_set_ai_dma_channel(struct comedi_device *dev, int channel)
 {
 	unsigned bitfield;
 
@@ -426,7 +426,7 @@ static inline void ni_set_ai_dma_channel(struct comedi_device * dev, int channel
 }
 
 /* negative channel means no channel */
-static inline void ni_set_ao_dma_channel(struct comedi_device * dev, int channel)
+static inline void ni_set_ao_dma_channel(struct comedi_device *dev, int channel)
 {
 	unsigned bitfield;
 
@@ -441,7 +441,7 @@ static inline void ni_set_ao_dma_channel(struct comedi_device * dev, int channel
 }
 
 /* negative mite_channel means no channel */
-static inline void ni_set_gpct_dma_channel(struct comedi_device * dev,
+static inline void ni_set_gpct_dma_channel(struct comedi_device *dev,
 	unsigned gpct_index, int mite_channel)
 {
 	unsigned bitfield;
@@ -456,7 +456,7 @@ static inline void ni_set_gpct_dma_channel(struct comedi_device * dev,
 }
 
 /* negative mite_channel means no channel */
-static inline void ni_set_cdo_dma_channel(struct comedi_device * dev, int mite_channel)
+static inline void ni_set_cdo_dma_channel(struct comedi_device *dev, int mite_channel)
 {
 	unsigned long flags;
 
@@ -475,7 +475,7 @@ static inline void ni_set_cdo_dma_channel(struct comedi_device * dev, int mite_c
 	comedi_spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
 }
 
-static int ni_request_ai_mite_channel(struct comedi_device * dev)
+static int ni_request_ai_mite_channel(struct comedi_device *dev)
 {
 	unsigned long flags;
 
@@ -496,7 +496,7 @@ static int ni_request_ai_mite_channel(struct comedi_device * dev)
 	return 0;
 }
 
-static int ni_request_ao_mite_channel(struct comedi_device * dev)
+static int ni_request_ao_mite_channel(struct comedi_device *dev)
 {
 	unsigned long flags;
 
@@ -517,7 +517,7 @@ static int ni_request_ao_mite_channel(struct comedi_device * dev)
 	return 0;
 }
 
-static int ni_request_gpct_mite_channel(struct comedi_device * dev,
+static int ni_request_gpct_mite_channel(struct comedi_device *dev,
 	unsigned gpct_index, enum comedi_io_direction direction)
 {
 	unsigned long flags;
@@ -546,7 +546,7 @@ static int ni_request_gpct_mite_channel(struct comedi_device * dev,
 
 #endif /*  PCIDMA */
 
-static int ni_request_cdo_mite_channel(struct comedi_device * dev)
+static int ni_request_cdo_mite_channel(struct comedi_device *dev)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -569,7 +569,7 @@ static int ni_request_cdo_mite_channel(struct comedi_device * dev)
 	return 0;
 }
 
-static void ni_release_ai_mite_channel(struct comedi_device * dev)
+static void ni_release_ai_mite_channel(struct comedi_device *dev)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -584,7 +584,7 @@ static void ni_release_ai_mite_channel(struct comedi_device * dev)
 #endif /*  PCIDMA */
 }
 
-static void ni_release_ao_mite_channel(struct comedi_device * dev)
+static void ni_release_ao_mite_channel(struct comedi_device *dev)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -599,7 +599,7 @@ static void ni_release_ao_mite_channel(struct comedi_device * dev)
 #endif /*  PCIDMA */
 }
 
-void ni_release_gpct_mite_channel(struct comedi_device * dev, unsigned gpct_index)
+void ni_release_gpct_mite_channel(struct comedi_device *dev, unsigned gpct_index)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -619,7 +619,7 @@ void ni_release_gpct_mite_channel(struct comedi_device * dev, unsigned gpct_inde
 #endif /*  PCIDMA */
 }
 
-static void ni_release_cdo_mite_channel(struct comedi_device * dev)
+static void ni_release_cdo_mite_channel(struct comedi_device *dev)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -636,7 +636,7 @@ static void ni_release_cdo_mite_channel(struct comedi_device * dev)
 
 /* e-series boards use the second irq signals to generate dma requests for their counters */
 #ifdef PCIDMA
-static void ni_e_series_enable_second_irq(struct comedi_device * dev,
+static void ni_e_series_enable_second_irq(struct comedi_device *dev,
 	unsigned gpct_index, short enable)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
@@ -667,7 +667,7 @@ static void ni_e_series_enable_second_irq(struct comedi_device * dev,
 }
 #endif /*  PCIDMA */
 
-static void ni_clear_ai_fifo(struct comedi_device * dev)
+static void ni_clear_ai_fifo(struct comedi_device *dev)
 {
 	if (boardtype.reg_type == ni_reg_6143) {
 		/*  Flush the 6143 data FIFO */
@@ -693,13 +693,13 @@ static void ni_clear_ai_fifo(struct comedi_device * dev)
 	}
 }
 
-static void win_out2(struct comedi_device * dev, uint32_t data, int reg)
+static void win_out2(struct comedi_device *dev, uint32_t data, int reg)
 {
 	devpriv->stc_writew(dev, data >> 16, reg);
 	devpriv->stc_writew(dev, data & 0xffff, reg + 1);
 }
 
-static uint32_t win_in2(struct comedi_device * dev, int reg)
+static uint32_t win_in2(struct comedi_device *dev, int reg)
 {
 	uint32_t bits;
 	bits = devpriv->stc_readw(dev, reg) << 16;
@@ -708,7 +708,7 @@ static uint32_t win_in2(struct comedi_device * dev, int reg)
 }
 
 #define ao_win_out(data,addr) ni_ao_win_outw(dev,data,addr)
-static inline void ni_ao_win_outw(struct comedi_device * dev, uint16_t data, int addr)
+static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data, int addr)
 {
 	unsigned long flags;
 
@@ -718,7 +718,7 @@ static inline void ni_ao_win_outw(struct comedi_device * dev, uint16_t data, int
 	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
-static inline void ni_ao_win_outl(struct comedi_device * dev, uint32_t data, int addr)
+static inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data, int addr)
 {
 	unsigned long flags;
 
@@ -728,7 +728,7 @@ static inline void ni_ao_win_outl(struct comedi_device * dev, uint32_t data, int
 	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
-static inline unsigned short ni_ao_win_inw(struct comedi_device * dev, int addr)
+static inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)
 {
 	unsigned long flags;
 	unsigned short data;
@@ -750,7 +750,7 @@ static inline unsigned short ni_ao_win_inw(struct comedi_device * dev, int addr)
 *
 * value should only be 1 or 0.
 */
-static inline void ni_set_bits(struct comedi_device * dev, int reg, unsigned bits,
+static inline void ni_set_bits(struct comedi_device *dev, int reg, unsigned bits,
 	unsigned value)
 {
 	unsigned bit_values;
@@ -823,7 +823,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 }
 
 #ifdef PCIDMA
-static void ni_sync_ai_dma(struct comedi_device * dev)
+static void ni_sync_ai_dma(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	unsigned long flags;
@@ -846,7 +846,7 @@ static void mite_handle_b_linkc(struct mite_struct *mite, struct comedi_device *
 	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
-static int ni_ao_wait_for_dma_load(struct comedi_device * dev)
+static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
 {
 	static const int timeout = 10000;
 	int i;
@@ -868,7 +868,7 @@ static int ni_ao_wait_for_dma_load(struct comedi_device * dev)
 }
 
 #endif /* PCIDMA */
-static void ni_handle_eos(struct comedi_device * dev, struct comedi_subdevice * s)
+static void ni_handle_eos(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	if (devpriv->aimode == AIMODE_SCAN) {
 #ifdef PCIDMA
@@ -892,7 +892,7 @@ static void ni_handle_eos(struct comedi_device * dev, struct comedi_subdevice *
 	}
 }
 
-static void shutdown_ai_command(struct comedi_device * dev)
+static void shutdown_ai_command(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 
@@ -906,7 +906,7 @@ static void shutdown_ai_command(struct comedi_device * dev)
 	s->async->events |= COMEDI_CB_EOA;
 }
 
-static void ni_event(struct comedi_device * dev, struct comedi_subdevice * s)
+static void ni_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	if (s->async->
 		events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW | COMEDI_CB_EOA))
@@ -932,7 +932,7 @@ static void ni_event(struct comedi_device * dev, struct comedi_subdevice * s)
 	comedi_event(dev, s);
 }
 
-static void handle_gpct_interrupt(struct comedi_device * dev,
+static void handle_gpct_interrupt(struct comedi_device *dev,
 	unsigned short counter_index)
 {
 #ifdef PCIDMA
@@ -945,7 +945,7 @@ static void handle_gpct_interrupt(struct comedi_device * dev,
 #endif
 }
 
-static void ack_a_interrupt(struct comedi_device * dev, unsigned short a_status)
+static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)
 {
 	unsigned short ack = 0;
 
@@ -966,7 +966,7 @@ static void ack_a_interrupt(struct comedi_device * dev, unsigned short a_status)
 		devpriv->stc_writew(dev, ack, Interrupt_A_Ack_Register);
 }
 
-static void handle_a_interrupt(struct comedi_device * dev, unsigned short status,
+static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
 	unsigned ai_mite_status)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
@@ -1070,7 +1070,7 @@ static void handle_a_interrupt(struct comedi_device * dev, unsigned short status
 #endif
 }
 
-static void ack_b_interrupt(struct comedi_device * dev, unsigned short b_status)
+static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)
 {
 	unsigned short ack = 0;
 	if (b_status & AO_BC_TC_St) {
@@ -1098,7 +1098,7 @@ static void ack_b_interrupt(struct comedi_device * dev, unsigned short b_status)
 		devpriv->stc_writew(dev, ack, Interrupt_B_Ack_Register);
 }
 
-static void handle_b_interrupt(struct comedi_device * dev, unsigned short b_status,
+static void handle_b_interrupt(struct comedi_device *dev, unsigned short b_status,
 	unsigned ao_mite_status)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
@@ -1204,7 +1204,7 @@ static void ni_mio_print_status_b(int status)
 
 #ifndef PCIDMA
 
-static void ni_ao_fifo_load(struct comedi_device * dev, struct comedi_subdevice * s, int n)
+static void ni_ao_fifo_load(struct comedi_device *dev, struct comedi_subdevice *s, int n)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1263,7 +1263,7 @@ static void ni_ao_fifo_load(struct comedi_device * dev, struct comedi_subdevice
  *  RT code, as RT code might purposely be running close to the
  *  metal.  Needs to be fixed eventually.
  */
-static int ni_ao_fifo_half_empty(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ni_ao_fifo_half_empty(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int n;
 
@@ -1284,7 +1284,7 @@ static int ni_ao_fifo_half_empty(struct comedi_device * dev, struct comedi_subde
 	return 1;
 }
 
-static int ni_ao_prep_fifo(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ni_ao_prep_fifo(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int n;
 
@@ -1307,7 +1307,7 @@ static int ni_ao_prep_fifo(struct comedi_device * dev, struct comedi_subdevice *
 	return n;
 }
 
-static void ni_ai_fifo_read(struct comedi_device * dev, struct comedi_subdevice * s, int n)
+static void ni_ai_fifo_read(struct comedi_device *dev, struct comedi_subdevice *s, int n)
 {
 	struct comedi_async *async = s->async;
 	int i;
@@ -1364,7 +1364,7 @@ static void ni_ai_fifo_read(struct comedi_device * dev, struct comedi_subdevice
 	}
 }
 
-static void ni_handle_fifo_half_full(struct comedi_device * dev)
+static void ni_handle_fifo_half_full(struct comedi_device *dev)
 {
 	int n;
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
@@ -1376,7 +1376,7 @@ static void ni_handle_fifo_half_full(struct comedi_device * dev)
 #endif
 
 #ifdef PCIDMA
-static int ni_ai_drain_dma(struct comedi_device * dev)
+static int ni_ai_drain_dma(struct comedi_device *dev)
 {
 	int i;
 	static const int timeout = 10000;
@@ -1414,7 +1414,7 @@ static int ni_ai_drain_dma(struct comedi_device * dev)
 /*
    Empties the AI fifo
 */
-static void ni_handle_fifo_dregs(struct comedi_device * dev)
+static void ni_handle_fifo_dregs(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	short data[2];
@@ -1476,7 +1476,7 @@ static void ni_handle_fifo_dregs(struct comedi_device * dev)
 	}
 }
 
-static void get_last_sample_611x(struct comedi_device * dev)
+static void get_last_sample_611x(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	short data;
@@ -1493,7 +1493,7 @@ static void get_last_sample_611x(struct comedi_device * dev)
 	}
 }
 
-static void get_last_sample_6143(struct comedi_device * dev)
+static void get_last_sample_6143(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	short data;
@@ -1513,7 +1513,7 @@ static void get_last_sample_6143(struct comedi_device * dev)
 	}
 }
 
-static void ni_ai_munge(struct comedi_device * dev, struct comedi_subdevice * s,
+static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	void *data, unsigned int num_bytes, unsigned int chan_index)
 {
 	struct comedi_async *async = s->async;
@@ -1539,7 +1539,7 @@ static void ni_ai_munge(struct comedi_device * dev, struct comedi_subdevice * s,
 
 #ifdef PCIDMA
 
-static int ni_ai_setup_MITE_dma(struct comedi_device * dev)
+static int ni_ai_setup_MITE_dma(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	int retval;
@@ -1579,7 +1579,7 @@ static int ni_ai_setup_MITE_dma(struct comedi_device * dev)
 	return 0;
 }
 
-static int ni_ao_setup_MITE_dma(struct comedi_device * dev)
+static int ni_ao_setup_MITE_dma(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	int retval;
@@ -1617,7 +1617,7 @@ static int ni_ao_setup_MITE_dma(struct comedi_device * dev)
    this is pretty harsh for a cancel, but it works...
  */
 
-static int ni_ai_reset(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	ni_release_ai_mite_channel(dev);
 	/* ai configuration */
@@ -1698,7 +1698,7 @@ static int ni_ai_reset(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-static int ni_ai_poll(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ni_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags = 0;
 	int count;
@@ -1718,8 +1718,8 @@ static int ni_ai_poll(struct comedi_device * dev, struct comedi_subdevice * s)
 	return count;
 }
 
-static int ni_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	const unsigned int mask = (1 << boardtype.adbits) - 1;
@@ -1814,7 +1814,7 @@ static int ni_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice *
 	return insn->n;
 }
 
-void ni_prime_channelgain_list(struct comedi_device * dev)
+void ni_prime_channelgain_list(struct comedi_device *dev)
 {
 	int i;
 	devpriv->stc_writew(dev, AI_CONVERT_Pulse, AI_Command_1_Register);
@@ -1830,7 +1830,7 @@ void ni_prime_channelgain_list(struct comedi_device * dev)
 	rt_printk("ni_mio_common: timeout loading channel/gain list\n");
 }
 
-static void ni_m_series_load_channelgain_list(struct comedi_device * dev,
+static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
 	unsigned int n_chan, unsigned int *list)
 {
 	unsigned int chan, range, aref;
@@ -1935,7 +1935,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device * dev,
  *   bits 0-2: channel
  *       valid channels are 0-3
  */
-static void ni_load_channelgain_list(struct comedi_device * dev, unsigned int n_chan,
+static void ni_load_channelgain_list(struct comedi_device *dev, unsigned int n_chan,
 	unsigned int *list)
 {
 	unsigned int chan, range, aref;
@@ -2055,7 +2055,7 @@ static void ni_load_channelgain_list(struct comedi_device * dev, unsigned int n_
 	}
 }
 
-static int ni_ns_to_timer(const struct comedi_device * dev, unsigned nanosec,
+static int ni_ns_to_timer(const struct comedi_device *dev, unsigned nanosec,
 	int round_mode)
 {
 	int divider;
@@ -2074,12 +2074,12 @@ static int ni_ns_to_timer(const struct comedi_device * dev, unsigned nanosec,
 	return divider - 1;
 }
 
-static unsigned ni_timer_to_ns(const struct comedi_device * dev, int timer)
+static unsigned ni_timer_to_ns(const struct comedi_device *dev, int timer)
 {
 	return devpriv->clock_ns * (timer + 1);
 }
 
-static unsigned ni_min_ai_scan_period_ns(struct comedi_device * dev,
+static unsigned ni_min_ai_scan_period_ns(struct comedi_device *dev,
 	unsigned num_channels)
 {
 	switch (boardtype.reg_type) {
@@ -2095,8 +2095,8 @@ static unsigned ni_min_ai_scan_period_ns(struct comedi_device * dev,
 	return boardtype.ai_speed * num_channels;
 }
 
-static int ni_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -2308,7 +2308,7 @@ static int ni_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s
 	return 0;
 }
 
-static int ni_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct comedi_cmd *cmd = &s->async->cmd;
 	int timer;
@@ -2612,7 +2612,7 @@ static int ni_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-static int ni_ai_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
+static int ni_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum)
 {
 	if (trignum != 0)
@@ -2625,11 +2625,11 @@ static int ni_ai_inttrig(struct comedi_device * dev, struct comedi_subdevice * s
 	return 1;
 }
 
-static int ni_ai_config_analog_trig(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
+static int ni_ai_config_analog_trig(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
 
-static int ni_ai_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n < 1)
 		return -EINVAL;
@@ -2679,8 +2679,8 @@ static int ni_ai_insn_config(struct comedi_device * dev, struct comedi_subdevice
 	return -EINVAL;
 }
 
-static int ni_ai_config_analog_trig(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_ai_config_analog_trig(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int a, b, modebits;
 	int err = 0;
@@ -2777,7 +2777,7 @@ static int ni_ai_config_analog_trig(struct comedi_device * dev, struct comedi_su
 }
 
 /* munge data from unsigned to 2's complement for analog output bipolar modes */
-static void ni_ao_munge(struct comedi_device * dev, struct comedi_subdevice * s,
+static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	void *data, unsigned int num_bytes, unsigned int chan_index)
 {
 	struct comedi_async *async = s->async;
@@ -2800,8 +2800,8 @@ static void ni_ao_munge(struct comedi_device * dev, struct comedi_subdevice * s,
 	}
 }
 
-static int ni_m_series_ao_config_chanlist(struct comedi_device * dev,
-	struct comedi_subdevice * s, unsigned int chanspec[], unsigned int n_chans,
+static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
+	struct comedi_subdevice *s, unsigned int chanspec[], unsigned int n_chans,
 	int timed)
 {
 	unsigned int range;
@@ -2869,7 +2869,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device * dev,
 	return invert;
 }
 
-static int ni_old_ao_config_chanlist(struct comedi_device * dev, struct comedi_subdevice * s,
+static int ni_old_ao_config_chanlist(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int chanspec[], unsigned int n_chans)
 {
 	unsigned int range;
@@ -2912,7 +2912,7 @@ static int ni_old_ao_config_chanlist(struct comedi_device * dev, struct comedi_s
 	return invert;
 }
 
-static int ni_ao_config_chanlist(struct comedi_device * dev, struct comedi_subdevice * s,
+static int ni_ao_config_chanlist(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int chanspec[], unsigned int n_chans, int timed)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
@@ -2921,16 +2921,16 @@ static int ni_ao_config_chanlist(struct comedi_device * dev, struct comedi_subde
 	else
 		return ni_old_ao_config_chanlist(dev, s, chanspec, n_chans);
 }
-static int ni_ao_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int ni_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
@@ -2948,8 +2948,8 @@ static int ni_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice
 	return 1;
 }
 
-static int ni_ao_insn_write_671x(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_ao_insn_write_671x(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
@@ -2965,8 +2965,8 @@ static int ni_ao_insn_write_671x(struct comedi_device * dev, struct comedi_subde
 	return 1;
 }
 
-static int ni_ao_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_ao_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
@@ -2991,7 +2991,7 @@ static int ni_ao_insn_config(struct comedi_device * dev, struct comedi_subdevice
 	return -EINVAL;
 }
 
-static int ni_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
+static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum)
 {
 	int ret;
@@ -3062,7 +3062,7 @@ static int ni_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s
 	return 0;
 }
 
-static int ni_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct comedi_cmd *cmd = &s->async->cmd;
 	int bits;
@@ -3261,8 +3261,8 @@ static int ni_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-static int ni_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -3384,7 +3384,7 @@ static int ni_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s
 	return 0;
 }
 
-static int ni_ao_reset(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	/* devpriv->ao0p=0x0000; */
 	/* ni_writew(devpriv->ao0p,AO_Configuration); */
@@ -3436,8 +3436,8 @@ static int ni_ao_reset(struct comedi_device * dev, struct comedi_subdevice * s)
 
 /* digital io */
 
-static int ni_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
 	rt_printk("ni_dio_insn_config() chan=%d io=%d\n",
@@ -3468,8 +3468,8 @@ static int ni_dio_insn_config(struct comedi_device * dev, struct comedi_subdevic
 	return 1;
 }
 
-static int ni_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
 	rt_printk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);
@@ -3495,8 +3495,8 @@ static int ni_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice
 	return 2;
 }
 
-static int ni_m_series_dio_insn_config(struct comedi_device * dev,
-	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data)
+static int ni_m_series_dio_insn_config(struct comedi_device *dev,
+	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
 	rt_printk("ni_m_series_dio_insn_config() chan=%d io=%d\n",
@@ -3525,8 +3525,8 @@ static int ni_m_series_dio_insn_config(struct comedi_device * dev,
 	return 1;
 }
 
-static int ni_m_series_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_m_series_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
 	rt_printk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],
@@ -3544,8 +3544,8 @@ static int ni_m_series_dio_insn_bits(struct comedi_device * dev, struct comedi_s
 	return 2;
 }
 
-static int ni_cdio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int ni_cdio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -3653,7 +3653,7 @@ static int ni_cdio_cmdtest(struct comedi_device * dev, struct comedi_subdevice *
 	return 0;
 }
 
-static int ni_cdio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;
@@ -3690,7 +3690,7 @@ static int ni_cdio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-static int ni_cdo_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
+static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum)
 {
 #ifdef PCIDMA
@@ -3738,7 +3738,7 @@ static int ni_cdo_inttrig(struct comedi_device * dev, struct comedi_subdevice *
 	return retval;
 }
 
-static int ni_cdio_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	ni_writel(CDO_Disarm_Bit | CDO_Error_Interrupt_Enable_Clear_Bit |
 		CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
@@ -3753,7 +3753,7 @@ static int ni_cdio_cancel(struct comedi_device * dev, struct comedi_subdevice *
 	return 0;
 }
 
-static void handle_cdio_interrupt(struct comedi_device * dev)
+static void handle_cdio_interrupt(struct comedi_device *dev)
 {
 	unsigned cdio_status;
 	struct comedi_subdevice *s = dev->subdevices + NI_DIO_SUBDEV;
@@ -3794,8 +3794,8 @@ static void handle_cdio_interrupt(struct comedi_device * dev)
 	ni_event(dev, s);
 }
 
-static int ni_serial_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_serial_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int err = insn->n;
 	unsigned char byte_out, byte_in = 0;
@@ -3888,7 +3888,7 @@ static int ni_serial_insn_config(struct comedi_device * dev, struct comedi_subde
 
 }
 
-static int ni_serial_hw_readwrite8(struct comedi_device * dev, struct comedi_subdevice * s,
+static int ni_serial_hw_readwrite8(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned char data_out, unsigned char *data_in)
 {
 	unsigned int status1;
@@ -3944,7 +3944,7 @@ static int ni_serial_hw_readwrite8(struct comedi_device * dev, struct comedi_sub
 	return err;
 }
 
-static int ni_serial_sw_readwrite8(struct comedi_device * dev, struct comedi_subdevice * s,
+static int ni_serial_sw_readwrite8(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned char data_out, unsigned char *data_in)
 {
 	unsigned char mask, input = 0;
@@ -3997,7 +3997,7 @@ static int ni_serial_sw_readwrite8(struct comedi_device * dev, struct comedi_sub
 	return 0;
 }
 
-static void mio_common_detach(struct comedi_device * dev)
+static void mio_common_detach(struct comedi_device *dev)
 {
 	if (dev->private) {
 		if (devpriv->counter_dev) {
@@ -4008,7 +4008,7 @@ static void mio_common_detach(struct comedi_device * dev)
 		subdev_8255_cleanup(dev, dev->subdevices + NI_8255_DIO_SUBDEV);
 }
 
-static void init_ao_67xx(struct comedi_device * dev, struct comedi_subdevice * s)
+static void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int i;
 
@@ -4212,15 +4212,15 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 	return 0;
 }
 
-static int ni_freq_out_insn_read(struct comedi_device * dev,
-	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data)
+static int ni_freq_out_insn_read(struct comedi_device *dev,
+	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->clock_and_fout & FOUT_Divider_mask;
 	return 1;
 }
 
-static int ni_freq_out_insn_write(struct comedi_device * dev,
-	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data)
+static int ni_freq_out_insn_write(struct comedi_device *dev,
+	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
 {
 	devpriv->clock_and_fout &= ~FOUT_Enable;
 	devpriv->stc_writew(dev, devpriv->clock_and_fout,
@@ -4233,7 +4233,7 @@ static int ni_freq_out_insn_write(struct comedi_device * dev,
 	return insn->n;
 }
 
-static int ni_set_freq_out_clock(struct comedi_device * dev, unsigned int clock_source)
+static int ni_set_freq_out_clock(struct comedi_device *dev, unsigned int clock_source)
 {
 	switch (clock_source) {
 	case NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC:
@@ -4250,8 +4250,8 @@ static int ni_set_freq_out_clock(struct comedi_device * dev, unsigned int clock_
 	return 3;
 }
 
-static void ni_get_freq_out_clock(struct comedi_device * dev, unsigned int * clock_source,
-	unsigned int * clock_period_ns)
+static void ni_get_freq_out_clock(struct comedi_device *dev, unsigned int *clock_source,
+	unsigned int *clock_period_ns)
 {
 	if (devpriv->clock_and_fout & FOUT_Timebase_Select) {
 		*clock_source = NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC;
@@ -4262,8 +4262,8 @@ static void ni_get_freq_out_clock(struct comedi_device * dev, unsigned int * clo
 	}
 }
 
-static int ni_freq_out_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_freq_out_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_SET_CLOCK_SRC:
@@ -4278,7 +4278,7 @@ static int ni_freq_out_insn_config(struct comedi_device * dev, struct comedi_sub
 	return -EINVAL;
 }
 
-static int ni_alloc_private(struct comedi_device * dev)
+static int ni_alloc_private(struct comedi_device *dev)
 {
 	int ret;
 
@@ -4293,7 +4293,7 @@ static int ni_alloc_private(struct comedi_device * dev)
 	return 0;
 };
 
-static int ni_E_init(struct comedi_device * dev, struct comedi_devconfig * it)
+static int ni_E_init(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	unsigned j;
@@ -4627,8 +4627,8 @@ static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 	presents the EEPROM as a subdevice
 */
 
-static int ni_eeprom_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_eeprom_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));
 
@@ -4639,7 +4639,7 @@ static int ni_eeprom_insn_read(struct comedi_device * dev, struct comedi_subdevi
 	reads bytes out of eeprom
 */
 
-static int ni_read_eeprom(struct comedi_device * dev, int addr)
+static int ni_read_eeprom(struct comedi_device *dev, int addr)
 {
 	int bit;
 	int bitstring;
@@ -4663,23 +4663,23 @@ static int ni_read_eeprom(struct comedi_device * dev, int addr)
 	return bitstring;
 }
 
-static int ni_m_series_eeprom_insn_read(struct comedi_device * dev,
-	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data)
+static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
+	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int ni_get_pwm_config(struct comedi_device * dev, unsigned int * data)
+static int ni_get_pwm_config(struct comedi_device *dev, unsigned int *data)
 {
 	data[1] = devpriv->pwm_up_count * devpriv->clock_ns;
 	data[2] = devpriv->pwm_down_count * devpriv->clock_ns;
 	return 3;
 }
 
-static int ni_m_series_pwm_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_m_series_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned up_count, down_count;
 	switch (data[0]) {
@@ -4743,8 +4743,8 @@ static int ni_m_series_pwm_config(struct comedi_device * dev, struct comedi_subd
 	return 0;
 }
 
-static int ni_6143_pwm_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_6143_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned up_count, down_count;
 	switch (data[0]) {
@@ -4806,20 +4806,20 @@ static int ni_6143_pwm_config(struct comedi_device * dev, struct comedi_subdevic
 	return 0;
 }
 
-static void ni_write_caldac(struct comedi_device * dev, int addr, int val);
+static void ni_write_caldac(struct comedi_device *dev, int addr, int val);
 /*
 	calibration subdevice
 */
-static int ni_calib_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_calib_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	ni_write_caldac(dev, CR_CHAN(insn->chanspec), data[0]);
 
 	return 1;
 }
 
-static int ni_calib_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_calib_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];
 
@@ -4849,7 +4849,7 @@ static struct caldac_struct caldacs[] = {
 	[ad8804_debug] = {16, 8, pack_ad8804},
 };
 
-static void caldac_setup(struct comedi_device * dev, struct comedi_subdevice * s)
+static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int i, j;
 	int n_dacs;
@@ -4902,7 +4902,7 @@ static void caldac_setup(struct comedi_device * dev, struct comedi_subdevice * s
 	}
 }
 
-static void ni_write_caldac(struct comedi_device * dev, int addr, int val)
+static void ni_write_caldac(struct comedi_device *dev, int addr, int val)
 {
 	unsigned int loadbit = 0, bits = 0, bit, bitstring = 0;
 	int i;
@@ -4989,7 +4989,7 @@ static int pack_ad8842(int addr, int val, int *bitstring)
 /*
  *	Read the GPCTs current value.
  */
-static int GPCT_G_Watch(struct comedi_device * dev, int chan)
+static int GPCT_G_Watch(struct comedi_device *dev, int chan)
 {
 	unsigned int hi1, hi2, lo;
 
@@ -5012,7 +5012,7 @@ static int GPCT_G_Watch(struct comedi_device * dev, int chan)
 	return (hi1 << 16) | lo;
 }
 
-static void GPCT_Reset(struct comedi_device * dev, int chan)
+static void GPCT_Reset(struct comedi_device *dev, int chan)
 {
 	int temp_ack_reg = 0;
 
@@ -5074,28 +5074,28 @@ static void GPCT_Reset(struct comedi_device * dev, int chan)
 
 #endif
 
-static int ni_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_gpct_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_insn_config(counter, insn, data);
 }
 
-static int ni_gpct_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_gpct_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_rinsn(counter, insn, data);
 }
 
-static int ni_gpct_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_gpct_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_winsn(counter, insn, data);
 }
 
-static int ni_gpct_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int retval;
 #ifdef PCIDMA
@@ -5118,8 +5118,8 @@ static int ni_gpct_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	return retval;
 }
 
-static int ni_gpct_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int ni_gpct_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 #ifdef PCIDMA
 	struct ni_gpct *counter = s->private;
@@ -5130,7 +5130,7 @@ static int ni_gpct_cmdtest(struct comedi_device * dev, struct comedi_subdevice *
 #endif
 }
 
-static int ni_gpct_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 #ifdef PCIDMA
 	struct ni_gpct *counter = s->private;
@@ -5151,7 +5151,7 @@ static int ni_gpct_cancel(struct comedi_device * dev, struct comedi_subdevice *
  *
  */
 
-static int ni_m_series_set_pfi_routing(struct comedi_device * dev, unsigned chan,
+static int ni_m_series_set_pfi_routing(struct comedi_device *dev, unsigned chan,
 	unsigned source)
 {
 	unsigned pfi_reg_index;
@@ -5169,7 +5169,7 @@ static int ni_m_series_set_pfi_routing(struct comedi_device * dev, unsigned chan
 	return 2;
 }
 
-static int ni_old_set_pfi_routing(struct comedi_device * dev, unsigned chan,
+static int ni_old_set_pfi_routing(struct comedi_device *dev, unsigned chan,
 	unsigned source)
 {
 	/*  pre-m-series boards have fixed signals on pfi pins */
@@ -5178,7 +5178,7 @@ static int ni_old_set_pfi_routing(struct comedi_device * dev, unsigned chan,
 	return 2;
 }
 
-static int ni_set_pfi_routing(struct comedi_device * dev, unsigned chan,
+static int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,
 	unsigned source)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
@@ -5187,14 +5187,14 @@ static int ni_set_pfi_routing(struct comedi_device * dev, unsigned chan,
 		return ni_old_set_pfi_routing(dev, chan, source);
 }
 
-static unsigned ni_m_series_get_pfi_routing(struct comedi_device * dev, unsigned chan)
+static unsigned ni_m_series_get_pfi_routing(struct comedi_device *dev, unsigned chan)
 {
 	const unsigned array_offset = chan / 3;
 	return MSeries_PFI_Output_Select_Source(chan,
 		devpriv->pfi_output_select_reg[array_offset]);
 }
 
-static unsigned ni_old_get_pfi_routing(struct comedi_device * dev, unsigned chan)
+static unsigned ni_old_get_pfi_routing(struct comedi_device *dev, unsigned chan)
 {
 	/*  pre-m-series boards have fixed signals on pfi pins */
 	switch (chan) {
@@ -5235,7 +5235,7 @@ static unsigned ni_old_get_pfi_routing(struct comedi_device * dev, unsigned chan
 	return 0;
 }
 
-static unsigned ni_get_pfi_routing(struct comedi_device * dev, unsigned chan)
+static unsigned ni_get_pfi_routing(struct comedi_device *dev, unsigned chan)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
 		return ni_m_series_get_pfi_routing(dev, chan);
@@ -5243,7 +5243,7 @@ static unsigned ni_get_pfi_routing(struct comedi_device * dev, unsigned chan)
 		return ni_old_get_pfi_routing(dev, chan);
 }
 
-static int ni_config_filter(struct comedi_device * dev, unsigned pfi_channel,
+static int ni_config_filter(struct comedi_device *dev, unsigned pfi_channel,
 	enum ni_pfi_filter_select filter)
 {
 	unsigned bits;
@@ -5257,8 +5257,8 @@ static int ni_config_filter(struct comedi_device * dev, unsigned pfi_channel,
 	return 0;
 }
 
-static int ni_pfi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_pfi_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
 		return -ENOTSUPP;
@@ -5272,8 +5272,8 @@ static int ni_pfi_insn_bits(struct comedi_device * dev, struct comedi_subdevice
 	return 2;
 }
 
-static int ni_pfi_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_pfi_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan;
 
@@ -5316,7 +5316,7 @@ static int ni_pfi_insn_config(struct comedi_device * dev, struct comedi_subdevic
  *  NI RTSI Bus Functions
  *
  */
-static void ni_rtsi_init(struct comedi_device * dev)
+static void ni_rtsi_init(struct comedi_device *dev)
 {
 	/*  Initialises the RTSI bus signal switch to a default state */
 
@@ -5351,8 +5351,8 @@ static void ni_rtsi_init(struct comedi_device * dev)
 */
 }
 
-static int ni_rtsi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_rtsi_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -5407,7 +5407,7 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 	return 0;
 }
 
-static inline unsigned num_configurable_rtsi_channels(struct comedi_device * dev)
+static inline unsigned num_configurable_rtsi_channels(struct comedi_device *dev)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
 		return 8;
@@ -5415,7 +5415,7 @@ static inline unsigned num_configurable_rtsi_channels(struct comedi_device * dev
 		return 7;
 }
 
-static int ni_mseries_set_pll_master_clock(struct comedi_device * dev, unsigned source,
+static int ni_mseries_set_pll_master_clock(struct comedi_device *dev, unsigned source,
 	unsigned period_ns)
 {
 	static const unsigned min_period_ns = 50;
@@ -5512,7 +5512,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device * dev, unsigned
 	return 3;
 }
 
-static int ni_set_master_clock(struct comedi_device * dev, unsigned source,
+static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
 	unsigned period_ns)
 {
 	if (source == NI_MIO_INTERNAL_CLOCK) {
@@ -5556,7 +5556,7 @@ static int ni_set_master_clock(struct comedi_device * dev, unsigned source,
 	return 3;
 }
 
-static int ni_valid_rtsi_output_source(struct comedi_device * dev, unsigned chan,
+static int ni_valid_rtsi_output_source(struct comedi_device *dev, unsigned chan,
 	unsigned source)
 {
 	if (chan >= num_configurable_rtsi_channels(dev)) {
@@ -5597,7 +5597,7 @@ static int ni_valid_rtsi_output_source(struct comedi_device * dev, unsigned chan
 	}
 }
 
-static int ni_set_rtsi_routing(struct comedi_device * dev, unsigned chan,
+static int ni_set_rtsi_routing(struct comedi_device *dev, unsigned chan,
 	unsigned source)
 {
 	if (ni_valid_rtsi_output_source(dev, chan, source) == 0)
@@ -5618,7 +5618,7 @@ static int ni_set_rtsi_routing(struct comedi_device * dev, unsigned chan,
 	return 2;
 }
 
-static unsigned ni_get_rtsi_routing(struct comedi_device * dev, unsigned chan)
+static unsigned ni_get_rtsi_routing(struct comedi_device *dev, unsigned chan)
 {
 	if (chan < 4) {
 		return RTSI_Trig_Output_Source(chan,
@@ -5634,8 +5634,8 @@ static unsigned ni_get_rtsi_routing(struct comedi_device * dev, unsigned chan)
 	}
 }
 
-static int ni_rtsi_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_rtsi_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	switch (data[0]) {
@@ -5706,7 +5706,7 @@ static int ni_rtsi_insn_config(struct comedi_device * dev, struct comedi_subdevi
 	return 1;
 }
 
-static int cs5529_wait_for_idle(struct comedi_device * dev)
+static int cs5529_wait_for_idle(struct comedi_device *dev)
 {
 	unsigned short status;
 	const int timeout = HZ;
@@ -5730,7 +5730,7 @@ static int cs5529_wait_for_idle(struct comedi_device * dev)
 	return 0;
 }
 
-static void cs5529_command(struct comedi_device * dev, unsigned short value)
+static void cs5529_command(struct comedi_device *dev, unsigned short value)
 {
 	static const int timeout = 100;
 	int i;
@@ -5752,7 +5752,7 @@ static void cs5529_command(struct comedi_device * dev, unsigned short value)
 }
 
 /* write to cs5529 register */
-static void cs5529_config_write(struct comedi_device * dev, unsigned int value,
+static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
 	unsigned int reg_select_bits)
 {
 	ni_ao_win_outw(dev, ((value >> 16) & 0xff),
@@ -5767,7 +5767,7 @@ static void cs5529_config_write(struct comedi_device * dev, unsigned int value,
 
 #ifdef NI_CS5529_DEBUG
 /* read from cs5529 register */
-static unsigned int cs5529_config_read(struct comedi_device * dev,
+static unsigned int cs5529_config_read(struct comedi_device *dev,
 	unsigned int reg_select_bits)
 {
 	unsigned int value;
@@ -5783,7 +5783,7 @@ static unsigned int cs5529_config_read(struct comedi_device * dev,
 }
 #endif
 
-static int cs5529_do_conversion(struct comedi_device * dev, unsigned short *data)
+static int cs5529_do_conversion(struct comedi_device *dev, unsigned short *data)
 {
 	int retval;
 	unsigned short status;
@@ -5813,8 +5813,8 @@ static int cs5529_do_conversion(struct comedi_device * dev, unsigned short *data
 	return 0;
 }
 
-static int cs5529_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int cs5529_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int n, retval;
 	unsigned short sample;
@@ -5839,7 +5839,7 @@ static int cs5529_ai_insn_read(struct comedi_device * dev, struct comedi_subdevi
 	return insn->n;
 }
 
-static int init_cs5529(struct comedi_device * dev)
+static int init_cs5529(struct comedi_device *dev)
 {
 	unsigned int config_bits =
 		CSCFG_PORT_MODE | CSCFG_WORD_RATE_2180_CYCLES;

commit ddcb01d458e8cbe33c76e4af11636257e8a14cb0
Author: Alessio Igor Bogani <abogani@texware.it>
Date:   Tue Mar 24 19:30:57 2009 +0100

    Staging: comedi: replace __FUNCTION__ usages
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Alessio Igor Bogani <abogani@texware.it>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index dfc2f86c5a25..838487868c62 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -397,7 +397,7 @@ static inline void ni_set_bitfield(struct comedi_device * dev, int reg,
 		break;
 	default:
 		rt_printk("Warning %s() called with invalid register\n",
-			__FUNCTION__);
+			__func__);
 		rt_printk("reg is %d\n", reg);
 		break;
 	}
@@ -2845,7 +2845,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device * dev,
 			break;
 		default:
 			rt_printk("%s: bug! unhandled ao reference voltage\n",
-				__FUNCTION__);
+				__func__);
 			break;
 		}
 		switch (krange->max + krange->min) {
@@ -2857,7 +2857,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device * dev,
 			break;
 		default:
 			rt_printk("%s: bug! unhandled ao offset voltage\n",
-				__FUNCTION__);
+				__func__);
 			break;
 		}
 		if (timed)
@@ -4104,7 +4104,7 @@ static unsigned ni_gpct_to_stc_register(enum ni_gpct_register reg)
 		break;
 	default:
 		rt_printk("%s: unhandled register 0x%x in switch.\n",
-			__FUNCTION__, reg);
+			__func__, reg);
 		BUG();
 		return 0;
 		break;
@@ -5229,7 +5229,7 @@ static unsigned ni_old_get_pfi_routing(struct comedi_device * dev, unsigned chan
 		return NI_PFI_OUTPUT_G_GATE0;
 		break;
 	default:
-		rt_printk("%s: bug, unhandled case in switch.\n", __FUNCTION__);
+		rt_printk("%s: bug, unhandled case in switch.\n", __func__);
 		break;
 	}
 	return 0;
@@ -5396,7 +5396,7 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 	}
 	if (best_period_picosec == 0) {
 		rt_printk("%s: bug, failed to find pll parameters\n",
-			__FUNCTION__);
+			__func__);
 		return -EIO;
 	}
 	*freq_divider = best_div;
@@ -5432,7 +5432,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device * dev, unsigned
 	if (period_ns < min_period_ns || period_ns > max_period_ns) {
 		rt_printk
 			("%s: you must specify an input clock frequency between %i and %i nanosec "
-			"for the phased-lock loop.\n", __FUNCTION__,
+			"for the phased-lock loop.\n", __func__,
 			min_period_ns, max_period_ns);
 		return -EINVAL;
 	}
@@ -5506,7 +5506,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device * dev, unsigned
 	if (i == timeout) {
 		rt_printk
 			("%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns.\n",
-			__FUNCTION__, source, period_ns);
+			__func__, source, period_ns);
 		return -ETIMEDOUT;
 	}
 	return 3;
@@ -5543,7 +5543,7 @@ static int ni_set_master_clock(struct comedi_device * dev, unsigned source,
 				if (period_ns == 0) {
 					rt_printk
 						("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",
-						__FUNCTION__);
+						__func__);
 					return -EINVAL;
 				} else {
 					devpriv->clock_ns = period_ns;
@@ -5566,7 +5566,7 @@ static int ni_valid_rtsi_output_source(struct comedi_device * dev, unsigned chan
 			else {
 				rt_printk
 					("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",
-					__FUNCTION__, chan,
+					__func__, chan,
 					old_RTSI_clock_channel);
 				return 0;
 			}
@@ -5629,7 +5629,7 @@ static unsigned ni_get_rtsi_routing(struct comedi_device * dev, unsigned chan)
 	} else {
 		if (chan == old_RTSI_clock_channel)
 			return NI_RTSI_OUTPUT_RTSI_OSC;
-		rt_printk("%s: bug! should never get here?\n", __FUNCTION__);
+		rt_printk("%s: bug! should never get here?\n", __func__);
 		return 0;
 	}
 }
@@ -5724,7 +5724,7 @@ static int cs5529_wait_for_idle(struct comedi_device * dev)
 	}
 /* printk("looped %i times waiting for idle\n", i); */
 	if (i == timeout) {
-		rt_printk("%s: %s: timeout\n", __FILE__, __FUNCTION__);
+		rt_printk("%s: %s: timeout\n", __FILE__, __func__);
 		return -ETIME;
 	}
 	return 0;

commit 2696fb57e6af653dd8b4df41b16754579f42fc78
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:29:34 2009 -0400

    Staging: comedi: Remove C99 comments
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8e9cf12f9251..dfc2f86c5a25 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -57,9 +57,9 @@
 		fully tested as yet. Terry Barnaby, BEAM Ltd.
 */
 
-//#define DEBUG_INTERRUPT
-//#define DEBUG_STATUS_A
-//#define DEBUG_STATUS_B
+/* #define DEBUG_INTERRUPT */
+/* #define DEBUG_STATUS_A */
+/* #define DEBUG_STATUS_B */
 
 #include "8255.h"
 #include "mite.h"
@@ -410,7 +410,7 @@ static int ni_ai_drain_dma(struct comedi_device * dev);
 
 /* DMA channel setup */
 
-// negative channel means no channel
+/* negative channel means no channel */
 static inline void ni_set_ai_dma_channel(struct comedi_device * dev, int channel)
 {
 	unsigned bitfield;
@@ -425,7 +425,7 @@ static inline void ni_set_ai_dma_channel(struct comedi_device * dev, int channel
 	ni_set_bitfield(dev, AI_AO_Select, AI_DMA_Select_Mask, bitfield);
 }
 
-// negative channel means no channel
+/* negative channel means no channel */
 static inline void ni_set_ao_dma_channel(struct comedi_device * dev, int channel)
 {
 	unsigned bitfield;
@@ -440,7 +440,7 @@ static inline void ni_set_ao_dma_channel(struct comedi_device * dev, int channel
 	ni_set_bitfield(dev, AI_AO_Select, AO_DMA_Select_Mask, bitfield);
 }
 
-// negative mite_channel means no channel
+/* negative mite_channel means no channel */
 static inline void ni_set_gpct_dma_channel(struct comedi_device * dev,
 	unsigned gpct_index, int mite_channel)
 {
@@ -455,7 +455,7 @@ static inline void ni_set_gpct_dma_channel(struct comedi_device * dev,
 		bitfield);
 }
 
-// negative mite_channel means no channel
+/* negative mite_channel means no channel */
 static inline void ni_set_cdo_dma_channel(struct comedi_device * dev, int mite_channel)
 {
 	unsigned long flags;
@@ -544,7 +544,7 @@ static int ni_request_gpct_mite_channel(struct comedi_device * dev,
 	return 0;
 }
 
-#endif // PCIDMA
+#endif /*  PCIDMA */
 
 static int ni_request_cdo_mite_channel(struct comedi_device * dev)
 {
@@ -565,7 +565,7 @@ static int ni_request_cdo_mite_channel(struct comedi_device * dev)
 	devpriv->cdo_mite_chan->dir = COMEDI_OUTPUT;
 	ni_set_cdo_dma_channel(dev, devpriv->cdo_mite_chan->channel);
 	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif // PCIDMA
+#endif /*  PCIDMA */
 	return 0;
 }
 
@@ -581,7 +581,7 @@ static void ni_release_ai_mite_channel(struct comedi_device * dev)
 		devpriv->ai_mite_chan = NULL;
 	}
 	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif // PCIDMA
+#endif /*  PCIDMA */
 }
 
 static void ni_release_ao_mite_channel(struct comedi_device * dev)
@@ -596,7 +596,7 @@ static void ni_release_ao_mite_channel(struct comedi_device * dev)
 		devpriv->ao_mite_chan = NULL;
 	}
 	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif // PCIDMA
+#endif /*  PCIDMA */
 }
 
 void ni_release_gpct_mite_channel(struct comedi_device * dev, unsigned gpct_index)
@@ -616,7 +616,7 @@ void ni_release_gpct_mite_channel(struct comedi_device * dev, unsigned gpct_inde
 		mite_release_channel(mite_chan);
 	}
 	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif // PCIDMA
+#endif /*  PCIDMA */
 }
 
 static void ni_release_cdo_mite_channel(struct comedi_device * dev)
@@ -631,10 +631,10 @@ static void ni_release_cdo_mite_channel(struct comedi_device * dev)
 		devpriv->cdo_mite_chan = NULL;
 	}
 	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif // PCIDMA
+#endif /*  PCIDMA */
 }
 
-// e-series boards use the second irq signals to generate dma requests for their counters
+/* e-series boards use the second irq signals to generate dma requests for their counters */
 #ifdef PCIDMA
 static void ni_e_series_enable_second_irq(struct comedi_device * dev,
 	unsigned gpct_index, short enable)
@@ -665,15 +665,15 @@ static void ni_e_series_enable_second_irq(struct comedi_device * dev,
 		break;
 	}
 }
-#endif // PCIDMA
+#endif /*  PCIDMA */
 
 static void ni_clear_ai_fifo(struct comedi_device * dev)
 {
 	if (boardtype.reg_type == ni_reg_6143) {
-		// Flush the 6143 data FIFO
-		ni_writel(0x10, AIFIFO_Control_6143);	// Flush fifo
-		ni_writel(0x00, AIFIFO_Control_6143);	// Flush fifo
-		while (ni_readl(AIFIFO_Status_6143) & 0x10) ;	// Wait for complete
+		/*  Flush the 6143 data FIFO */
+		ni_writel(0x10, AIFIFO_Control_6143);	/*  Flush fifo */
+		ni_writel(0x00, AIFIFO_Control_6143);	/*  Flush fifo */
+		while (ni_readl(AIFIFO_Status_6143) & 0x10) ;	/*  Wait for complete */
 	} else {
 		devpriv->stc_writew(dev, 1, ADC_FIFO_Clear);
 		if (boardtype.reg_type == ni_reg_625x) {
@@ -776,9 +776,9 @@ static irqreturn_t ni_E_interrupt(int irq, void *d)
 
 	if (dev->attached == 0)
 		return IRQ_NONE;
-	smp_mb();		// make sure dev->attached is checked before handler does anything else.
+	smp_mb();		/*  make sure dev->attached is checked before handler does anything else. */
 
-	// lock to avoid race with comedi_poll
+	/*  lock to avoid race with comedi_poll */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	a_status = devpriv->stc_readw(dev, AI_Status_1_Register);
 	b_status = devpriv->stc_readw(dev, AO_Status_1_Register);
@@ -867,7 +867,7 @@ static int ni_ao_wait_for_dma_load(struct comedi_device * dev)
 	return 0;
 }
 
-#endif //PCIDMA
+#endif /* PCIDMA */
 static void ni_handle_eos(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	if (devpriv->aimode == AIMODE_SCAN) {
@@ -971,7 +971,7 @@ static void handle_a_interrupt(struct comedi_device * dev, unsigned short status
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 
-	//67xx boards don't have ai subdevice, but their gpct0 might generate an a interrupt
+	/* 67xx boards don't have ai subdevice, but their gpct0 might generate an a interrupt */
 	if (s->type == COMEDI_SUBD_UNUSED)
 		return;
 
@@ -992,9 +992,9 @@ static void handle_a_interrupt(struct comedi_device * dev, unsigned short status
 		rt_printk
 			("unknown mite interrupt, ack! (ai_mite_status=%08x)\n",
 			ai_mite_status);
-		//mite_print_chsr(ai_mite_status);
+		/* mite_print_chsr(ai_mite_status); */
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		//disable_irq(dev->irq);
+		/* disable_irq(dev->irq); */
 	}
 #endif
 
@@ -1052,7 +1052,7 @@ static void handle_a_interrupt(struct comedi_device * dev, unsigned short status
 				break;
 		}
 	}
-#endif // !PCIDMA
+#endif /*  !PCIDMA */
 
 	if ((status & AI_STOP_St)) {
 		ni_handle_eos(dev, s);
@@ -1102,7 +1102,7 @@ static void handle_b_interrupt(struct comedi_device * dev, unsigned short b_stat
 	unsigned ao_mite_status)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
-	//unsigned short ack=0;
+	/* unsigned short ack=0; */
 #ifdef DEBUG_INTERRUPT
 	rt_printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
 		b_status, ao_mite_status);
@@ -1121,7 +1121,7 @@ static void handle_b_interrupt(struct comedi_device * dev, unsigned short b_stat
 		rt_printk
 			("unknown mite interrupt, ack! (ao_mite_status=%08x)\n",
 			ao_mite_status);
-		//mite_print_chsr(ao_mite_status);
+		/* mite_print_chsr(ao_mite_status); */
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
 #endif
@@ -1333,7 +1333,7 @@ static void ni_ai_fifo_read(struct comedi_device * dev, struct comedi_subdevice
 		short data[2];
 		u32 dl;
 
-		// This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed
+		/*  This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed */
 		for (i = 0; i < n / 2; i++) {
 			dl = ni_readl(AIFIFO_Data_6143);
 
@@ -1343,7 +1343,7 @@ static void ni_ai_fifo_read(struct comedi_device * dev, struct comedi_subdevice
 		}
 		if (n % 2) {
 			/* Assume there is a single sample stuck in the FIFO */
-			ni_writel(0x01, AIFIFO_Control_6143);	// Get stranded sample into FIFO
+			ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
 			dl = ni_readl(AIFIFO_Data_6143);
 			data[0] = (dl >> 16) & 0xffff;
 			cfc_write_to_buffer(s, data[0]);
@@ -1444,9 +1444,9 @@ static void ni_handle_fifo_dregs(struct comedi_device * dev)
 			cfc_write_array_to_buffer(s, data, sizeof(data));
 			i += 2;
 		}
-		// Check if stranded sample is present
+		/*  Check if stranded sample is present */
 		if (ni_readl(AIFIFO_Status_6143) & 0x01) {
-			ni_writel(0x01, AIFIFO_Control_6143);	// Get stranded sample into FIFO
+			ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
 			dl = ni_readl(AIFIFO_Data_6143);
 			data[0] = (dl >> 16) & 0xffff;
 			cfc_write_to_buffer(s, data[0]);
@@ -1504,7 +1504,7 @@ static void get_last_sample_6143(struct comedi_device * dev)
 
 	/* Check if there's a single sample stuck in the FIFO */
 	if (ni_readl(AIFIFO_Status_6143) & 0x01) {
-		ni_writel(0x01, AIFIFO_Control_6143);	// Get stranded sample into FIFO
+		ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
 		dl = ni_readl(AIFIFO_Data_6143);
 
 		/* This may get the hi/lo data in the wrong order */
@@ -1548,7 +1548,7 @@ static int ni_ai_setup_MITE_dma(struct comedi_device * dev)
 	retval = ni_request_ai_mite_channel(dev);
 	if (retval)
 		return retval;
-//      rt_printk("comedi_debug: using mite channel %i for ai.\n", devpriv->ai_mite_chan->channel);
+/* rt_printk("comedi_debug: using mite channel %i for ai.\n", devpriv->ai_mite_chan->channel); */
 
 	/* write alloc the entire buffer */
 	comedi_buf_write_alloc(s->async, s->async->prealloc_bufsz);
@@ -1609,7 +1609,7 @@ static int ni_ao_setup_MITE_dma(struct comedi_device * dev)
 	return retval;
 }
 
-#endif // PCIDMA
+#endif /*  PCIDMA */
 
 /*
    used for both cancel ioctl and board initialization
@@ -1703,7 +1703,7 @@ static int ni_ai_poll(struct comedi_device * dev, struct comedi_subdevice * s)
 	unsigned long flags = 0;
 	int count;
 
-	// lock to avoid race with interrupt handler
+	/*  lock to avoid race with interrupt handler */
 	if (in_interrupt() == 0)
 		comedi_spin_lock_irqsave(&dev->spinlock, flags);
 #ifndef PCIDMA
@@ -1774,7 +1774,7 @@ static int ni_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice *
 			dl = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
 				if (ni_readl(AIFIFO_Status_6143) & 0x01) {
-					ni_writel(0x01, AIFIFO_Control_6143);	// Get stranded sample into FIFO
+					ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
 					dl = ni_readl(AIFIFO_Data_6143);
 					break;
 				}
@@ -1841,7 +1841,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device * dev,
 
 	devpriv->stc_writew(dev, 1, Configuration_Memory_Clear);
 
-//      offset = 1 << (boardtype.adbits - 1);
+/* offset = 1 << (boardtype.adbits - 1); */
 	if ((list[0] & CR_ALT_SOURCE)) {
 		unsigned bypass_bits;
 		chan = CR_CHAN(list[0]);
@@ -1859,7 +1859,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device * dev,
 		bypass_bits |= MSeries_AI_Bypass_Gain_Bits(range_code);
 		if (dither)
 			bypass_bits |= MSeries_AI_Bypass_Dither_Bit;
-		// don't use 2's complement encoding
+		/*  don't use 2's complement encoding */
 		bypass_bits |= MSeries_AI_Bypass_Polarity_Bit;
 		ni_writel(bypass_bits, M_Offset_AI_Config_FIFO_Bypass);
 	} else {
@@ -1899,7 +1899,7 @@ static void ni_m_series_load_channelgain_list(struct comedi_device * dev,
 			config_bits |= MSeries_AI_Config_Last_Channel_Bit;
 		if (dither)
 			config_bits |= MSeries_AI_Config_Dither_Bit;
-		// don't use 2's complement encoding
+		/*  don't use 2's complement encoding */
 		config_bits |= MSeries_AI_Config_Polarity_Bit;
 		ni_writew(config_bits, M_Offset_AI_Config_FIFO_Data);
 	}
@@ -1952,7 +1952,7 @@ static void ni_load_channelgain_list(struct comedi_device * dev, unsigned int n_
 		&& (boardtype.reg_type != ni_reg_6143)) {
 		if (devpriv->changain_state
 			&& devpriv->changain_spec == list[0]) {
-			// ready to go.
+			/*  ready to go. */
 			return;
 		}
 		devpriv->changain_state = 1;
@@ -1963,11 +1963,11 @@ static void ni_load_channelgain_list(struct comedi_device * dev, unsigned int n_
 
 	devpriv->stc_writew(dev, 1, Configuration_Memory_Clear);
 
-	// Set up Calibration mode if required
+	/*  Set up Calibration mode if required */
 	if (boardtype.reg_type == ni_reg_6143) {
 		if ((list[0] & CR_ALT_SOURCE)
 			&& !devpriv->ai_calib_source_enabled) {
-			// Strobe Relay enable bit
+			/*  Strobe Relay enable bit */
 			ni_writew(devpriv->
 				ai_calib_source |
 				Calibration_Channel_6143_RelayOn,
@@ -1975,10 +1975,10 @@ static void ni_load_channelgain_list(struct comedi_device * dev, unsigned int n_
 			ni_writew(devpriv->ai_calib_source,
 				Calibration_Channel_6143);
 			devpriv->ai_calib_source_enabled = 1;
-			msleep_interruptible(100);	// Allow relays to change
+			msleep_interruptible(100);	/*  Allow relays to change */
 		} else if (!(list[0] & CR_ALT_SOURCE)
 			&& devpriv->ai_calib_source_enabled) {
-			// Strobe Relay disable bit
+			/*  Strobe Relay disable bit */
 			ni_writew(devpriv->
 				ai_calib_source |
 				Calibration_Channel_6143_RelayOff,
@@ -1986,7 +1986,7 @@ static void ni_load_channelgain_list(struct comedi_device * dev, unsigned int n_
 			ni_writew(devpriv->ai_calib_source,
 				Calibration_Channel_6143);
 			devpriv->ai_calib_source_enabled = 0;
-			msleep_interruptible(100);	// Allow relays to change
+			msleep_interruptible(100);	/*  Allow relays to change */
 		}
 	}
 
@@ -2085,11 +2085,11 @@ static unsigned ni_min_ai_scan_period_ns(struct comedi_device * dev,
 	switch (boardtype.reg_type) {
 	case ni_reg_611x:
 	case ni_reg_6143:
-		// simultaneously-sampled inputs
+		/*  simultaneously-sampled inputs */
 		return boardtype.ai_speed;
 		break;
 	default:
-		// multiplexed inputs
+		/*  multiplexed inputs */
 		break;
 	};
 	return boardtype.ai_speed * num_channels;
@@ -2367,10 +2367,10 @@ static int ni_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	if (cmd->chanlist_len == 1 || (boardtype.reg_type == ni_reg_611x)
 		|| (boardtype.reg_type == ni_reg_6143)) {
 		start_stop_select |= AI_STOP_Polarity;
-		start_stop_select |= AI_STOP_Select(31);	// logic low
+		start_stop_select |= AI_STOP_Select(31);	/*  logic low */
 		start_stop_select |= AI_STOP_Sync;
 	} else {
-		start_stop_select |= AI_STOP_Select(19);	// ai configuration memory
+		start_stop_select |= AI_STOP_Select(19);	/*  ai configuration memory */
 	}
 	devpriv->stc_writew(dev, start_stop_select,
 		AI_START_STOP_Select_Register);
@@ -2381,7 +2381,7 @@ static int ni_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		stop_count = cmd->stop_arg - 1;
 
 		if (boardtype.reg_type == ni_reg_611x) {
-			// have to take 3 stage adc pipeline into account
+			/*  have to take 3 stage adc pipeline into account */
 			stop_count += num_adc_stages_611x;
 		}
 		/* stage number of scans */
@@ -2396,7 +2396,7 @@ static int ni_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		if (stop_count == 0) {
 			devpriv->ai_cmd2 |= AI_End_On_End_Of_Scan;
 			interrupt_a_enable |= AI_STOP_Interrupt_Enable;
-			// this is required to get the last sample for chanlist_len > 1, not sure why
+			/*  this is required to get the last sample for chanlist_len > 1, not sure why */
 			if (cmd->chanlist_len > 1)
 				start_stop_select |=
 					AI_STOP_Polarity | AI_STOP_Edge;
@@ -2440,7 +2440,7 @@ static int ni_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		mode2 |= AI_SI_Reload_Mode(0);
 		/* AI_SI_Initial_Load_Source=A */
 		mode2 &= ~AI_SI_Initial_Load_Source;
-		//mode2 |= AI_SC_Reload_Mode;
+		/* mode2 |= AI_SC_Reload_Mode; */
 		devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
 
 		/* load SI */
@@ -2486,8 +2486,8 @@ static int ni_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		/* AI_SI2_Load */
 		devpriv->stc_writew(dev, AI_SI2_Load, AI_Command_1_Register);
 
-		mode2 |= AI_SI2_Reload_Mode;	// alternate
-		mode2 |= AI_SI2_Initial_Load_Source;	// B
+		mode2 |= AI_SI2_Reload_Mode;	/*  alternate */
+		mode2 |= AI_SI2_Initial_Load_Source;	/*  B */
 
 		devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
 		break;
@@ -2589,7 +2589,7 @@ static int ni_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		if (retval)
 			return retval;
 	}
-	//mite_dump_regs(devpriv->mite);
+	/* mite_dump_regs(devpriv->mite); */
 #endif
 
 	switch (cmd->start_src) {
@@ -3044,7 +3044,7 @@ static int ni_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s
 			"timed out waiting for AO_TMRDACWRs_In_Progress_St to clear");
 		return -EIO;
 	}
-	// stc manual says we are need to clear error interrupt after AO_TMRDACWRs_In_Progress_St clears
+	/*  stc manual says we are need to clear error interrupt after AO_TMRDACWRs_In_Progress_St clears */
 	devpriv->stc_writew(dev, AO_Error_Interrupt_Ack,
 		Interrupt_B_Ack_Register);
 
@@ -3114,9 +3114,9 @@ static int ni_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	case TRIG_EXT:
                 devpriv->ao_trigger_select = AO_START1_Select(CR_CHAN(cmd->start_arg)+1);
 		if (cmd->start_arg & CR_INVERT)
-			devpriv->ao_trigger_select |= AO_START1_Polarity;  // 0=active high, 1=active low. see daq-stc 3-24 (p186)
+			devpriv->ao_trigger_select |= AO_START1_Polarity;  /*  0=active high, 1=active low. see daq-stc 3-24 (p186) */
 		if (cmd->start_arg & CR_EDGE)
-			devpriv->ao_trigger_select |= AO_START1_Edge;      // 0=edge detection disabled, 1=enabled
+			devpriv->ao_trigger_select |= AO_START1_Edge;      /*  0=edge detection disabled, 1=enabled */
 		devpriv->stc_writew(dev, devpriv->ao_trigger_select, AO_Trigger_Select_Register);
 		break;
 	default:
@@ -3141,7 +3141,7 @@ static int ni_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	case TRIG_COUNT:
 		if(boardtype.reg_type & ni_reg_m_series_mask)
 		{
-			// this is how the NI example code does it for m-series boards, verified correct with 6259
+			/*  this is how the NI example code does it for m-series boards, verified correct with 6259 */
 			devpriv->stc_writel(dev, cmd->stop_arg - 1, AO_UC_Load_A_Register);
 			devpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
 		}else
@@ -3244,7 +3244,7 @@ static int ni_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		bits |= AO_Number_Of_DAC_Packages;
 #endif
 	devpriv->stc_writew(dev, bits, AO_Personal_Register);
-	// enable sending of ao dma requests
+	/*  enable sending of ao dma requests */
 	devpriv->stc_writew(dev, AO_AOFREQ_Enable, AO_Start_Select_Register);
 
 	devpriv->stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);
@@ -3386,11 +3386,11 @@ static int ni_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s
 
 static int ni_ao_reset(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	//devpriv->ao0p=0x0000;
-	//ni_writew(devpriv->ao0p,AO_Configuration);
+	/* devpriv->ao0p=0x0000; */
+	/* ni_writew(devpriv->ao0p,AO_Configuration); */
 
-	//devpriv->ao1p=AO_Channel(1);
-	//ni_writew(devpriv->ao1p,AO_Configuration);
+	/* devpriv->ao1p=AO_Channel(1); */
+	/* ni_writew(devpriv->ao1p,AO_Configuration); */
 
 	ni_release_ao_mite_channel(dev);
 
@@ -3434,7 +3434,7 @@ static int ni_ao_reset(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-// digital io
+/* digital io */
 
 static int ni_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
@@ -3718,9 +3718,11 @@ static int ni_cdo_inttrig(struct comedi_device * dev, struct comedi_subdevice *
 	if (retval < 0)
 		return retval;
 #endif
-// XXX not sure what interrupt C group does
-//      ni_writeb(Interrupt_Group_C_Enable_Bit, M_Offset_Interrupt_C_Enable);
-	//wait for dma to fill output fifo
+/*
+* XXX not sure what interrupt C group does
+* ni_writeb(Interrupt_Group_C_Enable_Bit,
+* M_Offset_Interrupt_C_Enable); wait for dma to fill output fifo
+*/
 	for (i = 0; i < timeout; ++i) {
 		if (ni_readl(M_Offset_CDIO_Status) & CDO_FIFO_Full_Bit)
 			break;
@@ -3742,8 +3744,10 @@ static int ni_cdio_cancel(struct comedi_device * dev, struct comedi_subdevice *
 		CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
 		CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
 		M_Offset_CDIO_Command);
-// XXX not sure what interrupt C group does
-//      ni_writeb(0, M_Offset_Interrupt_C_Enable);
+/*
+* XXX not sure what interrupt C group does ni_writeb(0,
+* M_Offset_Interrupt_C_Enable);
+*/
 	ni_writel(0, M_Offset_CDO_Mask_Enable);
 	ni_release_cdo_mite_channel(dev);
 	return 0;
@@ -3777,15 +3781,15 @@ static void handle_cdio_interrupt(struct comedi_device * dev)
 
 	cdio_status = ni_readl(M_Offset_CDIO_Status);
 	if (cdio_status & (CDO_Overrun_Bit | CDO_Underflow_Bit)) {
-//              rt_printk("cdio error: statux=0x%x\n", cdio_status);
-		ni_writel(CDO_Error_Interrupt_Confirm_Bit, M_Offset_CDIO_Command);	// XXX just guessing this is needed and does something useful
+/* rt_printk("cdio error: statux=0x%x\n", cdio_status); */
+		ni_writel(CDO_Error_Interrupt_Confirm_Bit, M_Offset_CDIO_Command);	/*  XXX just guessing this is needed and does something useful */
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 	if (cdio_status & CDO_FIFO_Empty_Bit) {
-//              rt_printk("cdio fifo empty\n");
+/* rt_printk("cdio fifo empty\n"); */
 		ni_writel(CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
 			M_Offset_CDIO_Command);
-//              s->async->events |= COMEDI_CB_EOA;
+/* s->async->events |= COMEDI_CB_EOA; */
 	}
 	ni_event(dev, s);
 }
@@ -4419,14 +4423,14 @@ static int ni_E_init(struct comedi_device * dev, struct comedi_devconfig * it)
 	s = dev->subdevices + NI_CALIBRATION_SUBDEV;
 	s->type = COMEDI_SUBD_CALIB;
 	if (boardtype.reg_type & ni_reg_m_series_mask) {
-		// internal PWM analog output used for AI nonlinearity calibration
+		/*  internal PWM analog output used for AI nonlinearity calibration */
 		s->subdev_flags = SDF_INTERNAL;
 		s->insn_config = &ni_m_series_pwm_config;
 		s->n_chan = 1;
 		s->maxdata = 0;
 		ni_writel(0x0, M_Offset_Cal_PWM);
 	} else if (boardtype.reg_type == ni_reg_6143) {
-		// internal PWM analog output used for AI nonlinearity calibration
+		/*  internal PWM analog output used for AI nonlinearity calibration */
 		s->subdev_flags = SDF_INTERNAL;
 		s->insn_config = &ni_6143_pwm_config;
 		s->n_chan = 1;
@@ -4478,7 +4482,7 @@ static int ni_E_init(struct comedi_device * dev, struct comedi_devconfig * it)
 	if (boardtype.reg_type & ni_reg_67xx_mask) {
 		s->type = COMEDI_SUBD_AI;
 		s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_INTERNAL;
-		// one channel for each analog output channel
+		/*  one channel for each analog output channel */
 		s->n_chan = boardtype.n_aochan;
 		s->maxdata = (1 << 16) - 1;
 		s->range_table = &range_unknown;	/* XXX */
@@ -4557,7 +4561,7 @@ static int ni_E_init(struct comedi_device * dev, struct comedi_devconfig * it)
 	/* ai configuration */
 	ni_ai_reset(dev, dev->subdevices + NI_AI_SUBDEV);
 	if ((boardtype.reg_type & ni_reg_6xxx_mask) == 0) {
-		// BEAM is this needed for PCI-6143 ??
+		/*  BEAM is this needed for PCI-6143 ?? */
 		devpriv->clock_and_fout =
 			Slow_Internal_Time_Divide_By_2 |
 			Slow_Internal_Timebase |
@@ -4904,7 +4908,7 @@ static void ni_write_caldac(struct comedi_device * dev, int addr, int val)
 	int i;
 	int type;
 
-	//printk("ni_write_caldac: chan=%d val=%d\n",addr,val);
+	/* printk("ni_write_caldac: chan=%d val=%d\n",addr,val); */
 	if (devpriv->caldacs[addr] == val)
 		return;
 	devpriv->caldacs[addr] = val;
@@ -4916,7 +4920,7 @@ static void ni_write_caldac(struct comedi_device * dev, int addr, int val)
 		if (addr < caldacs[type].n_chans) {
 			bits = caldacs[type].packbits(addr, val, &bitstring);
 			loadbit = SerDacLd(i);
-			//printk("caldac: using i=%d addr=%d %x\n",i,addr,bitstring);
+			/* printk("caldac: using i=%d addr=%d %x\n",i,addr,bitstring); */
 			break;
 		}
 		addr -= caldacs[type].n_chans;
@@ -5012,7 +5016,7 @@ static void GPCT_Reset(struct comedi_device * dev, int chan)
 {
 	int temp_ack_reg = 0;
 
-	//printk("GPCT_Reset...");
+	/* printk("GPCT_Reset..."); */
 	devpriv->gpct_cur_operation[chan] = GPCT_RESET;
 
 	switch (chan) {
@@ -5029,7 +5033,7 @@ static void GPCT_Reset(struct comedi_device * dev, int chan)
 		devpriv->stc_writew(dev, temp_ack_reg,
 			Interrupt_A_Ack_Register);
 
-		//problem...this interferes with the other ctr...
+		/* problem...this interferes with the other ctr... */
 		devpriv->an_trig_etc_reg |= GPFO_0_Output_Enable;
 		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
 			Analog_Trigger_Etc_Register);
@@ -5065,7 +5069,7 @@ static void GPCT_Reset(struct comedi_device * dev, int chan)
 		G_Input_Select_Register(chan));
 	devpriv->stc_writew(dev, 0, G_Autoincrement_Register(chan));
 
-	//printk("exit GPCT_Reset\n");
+	/* printk("exit GPCT_Reset\n"); */
 }
 
 #endif
@@ -5096,7 +5100,7 @@ static int ni_gpct_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	int retval;
 #ifdef PCIDMA
 	struct ni_gpct *counter = s->private;
-//      const struct comedi_cmd *cmd = &s->async->cmd;
+/* const struct comedi_cmd *cmd = &s->async->cmd; */
 
 	retval = ni_request_gpct_mite_channel(dev, counter->counter_index,
 		COMEDI_INPUT);
@@ -5168,7 +5172,7 @@ static int ni_m_series_set_pfi_routing(struct comedi_device * dev, unsigned chan
 static int ni_old_set_pfi_routing(struct comedi_device * dev, unsigned chan,
 	unsigned source)
 {
-	// pre-m-series boards have fixed signals on pfi pins
+	/*  pre-m-series boards have fixed signals on pfi pins */
 	if (source != ni_old_get_pfi_routing(dev, chan))
 		return -EINVAL;
 	return 2;
@@ -5192,7 +5196,7 @@ static unsigned ni_m_series_get_pfi_routing(struct comedi_device * dev, unsigned
 
 static unsigned ni_old_get_pfi_routing(struct comedi_device * dev, unsigned chan)
 {
-	// pre-m-series boards have fixed signals on pfi pins
+	/*  pre-m-series boards have fixed signals on pfi pins */
 	switch (chan) {
 	case 0:
 		return NI_PFI_OUTPUT_AI_START1;
@@ -5314,14 +5318,14 @@ static int ni_pfi_insn_config(struct comedi_device * dev, struct comedi_subdevic
  */
 static void ni_rtsi_init(struct comedi_device * dev)
 {
-	// Initialises the RTSI bus signal switch to a default state
+	/*  Initialises the RTSI bus signal switch to a default state */
 
-	// Set clock mode to internal
+	/*  Set clock mode to internal */
 	devpriv->clock_and_fout2 = MSeries_RTSI_10MHz_Bit;
 	if (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0) {
 		rt_printk("ni_set_master_clock failed, bug?");
 	}
-	// default internal lines routing to RTSI bus lines
+	/*  default internal lines routing to RTSI bus lines */
 	devpriv->rtsi_trig_a_output_reg =
 		RTSI_Trig_Output_Bits(0,
 		NI_RTSI_OUTPUT_ADR_START1) | RTSI_Trig_Output_Bits(1,
@@ -5341,8 +5345,10 @@ static void ni_rtsi_init(struct comedi_device * dev)
 	devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
 		RTSI_Trig_B_Output_Register);
 
-	// Sets the source and direction of the 4 on board lines
-//      devpriv->stc_writew(dev, 0x0000, RTSI_Board_Register);
+/*
+* Sets the source and direction of the 4 on board lines
+* devpriv->stc_writew(dev, 0x0000, RTSI_Board_Register);
+*/
 }
 
 static int ni_rtsi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
@@ -5422,7 +5428,7 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device * dev, unsigned
 	int retval;
 	if (source == NI_MIO_PLL_PXI10_CLOCK)
 		period_ns = 100;
-	// these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that
+	/*  these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that */
 	if (period_ns < min_period_ns || period_ns > max_period_ns) {
 		rt_printk
 			("%s: you must specify an input clock frequency between %i and %i nanosec "
@@ -5484,8 +5490,10 @@ static int ni_mseries_set_pll_master_clock(struct comedi_device * dev, unsigned
 	pll_control_bits |=
 		MSeries_PLL_Divisor_Bits(freq_divider) |
 		MSeries_PLL_Multiplier_Bits(freq_multiplier);
-//      rt_printk("using divider=%i, multiplier=%i for PLL.  pll_control_bits = 0x%x\n", freq_divider, freq_multiplier, pll_control_bits);
-//      rt_printk("clock_ns=%d\n", devpriv->clock_ns);
+
+	/* rt_printk("using divider=%i, multiplier=%i for PLL. pll_control_bits = 0x%x\n",
+	 * freq_divider, freq_multiplier, pll_control_bits); */
+	/* rt_printk("clock_ns=%d\n", devpriv->clock_ns); */
 	ni_writew(pll_control_bits, M_Offset_PLL_Control);
 	devpriv->clock_source = source;
 	/* it seems to typically take a few hundred microseconds for PLL to lock */
@@ -5714,7 +5722,7 @@ static int cs5529_wait_for_idle(struct comedi_device * dev)
 			return -EIO;
 		}
 	}
-//printk("looped %i times waiting for idle\n", i);
+/* printk("looped %i times waiting for idle\n", i); */
 	if (i == timeout) {
 		rt_printk("%s: %s: timeout\n", __FILE__, __FUNCTION__);
 		return -ETIME;
@@ -5737,7 +5745,7 @@ static void cs5529_command(struct comedi_device * dev, unsigned short value)
 			break;
 		comedi_udelay(1);
 	}
-//printk("looped %i times writing command to cs5529\n", i);
+/* printk("looped %i times writing command to cs5529\n", i); */
 	if (i == timeout) {
 		comedi_error(dev, "possible problem - never saw adc go busy?");
 	}

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index e46545048c3a..8e9cf12f9251 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -762,7 +762,7 @@ static inline void ni_set_bits(struct comedi_device * dev, int reg, unsigned bit
 	ni_set_bitfield(dev, reg, bits, bit_values);
 }
 
-static irqreturn_t ni_E_interrupt(int irq, void *d PT_REGS_ARG)
+static irqreturn_t ni_E_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	unsigned short a_status;

commit 3301cc76656c5fee5b638378d9057e93796d490f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Mar 25 11:04:20 2009 -0400

    Staging: comedi: Remove ni_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 542bd0dcd44d..e46545048c3a 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4278,7 +4278,7 @@ static int ni_alloc_private(struct comedi_device * dev)
 {
 	int ret;
 
-	ret = alloc_private(dev, sizeof(ni_private));
+	ret = alloc_private(dev, sizeof(struct ni_private));
 	if (ret < 0)
 		return ret;
 

commit 1f6325d629ce03501e8927480495685828561f26
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:31 2009 -0400

    Staging: comedi: Remove comedi_krange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index ce8c704565d2..542bd0dcd44d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2818,7 +2818,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device * dev,
 		}
 	}
 	for (i = 0; i < n_chans; i++) {
-		const comedi_krange *krange;
+		const struct comedi_krange *krange;
 		chan = CR_CHAN(chanspec[i]);
 		range = CR_RANGE(chanspec[i]);
 		krange = s->range_table->range + range;

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 52984b0a1b7b..ce8c704565d2 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4289,7 +4289,7 @@ static int ni_alloc_private(struct comedi_device * dev)
 	return 0;
 };
 
-static int ni_E_init(struct comedi_device * dev, comedi_devconfig * it)
+static int ni_E_init(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct comedi_subdevice *s;
 	unsigned j;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index a2988bdb2652..52984b0a1b7b 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -194,9 +194,9 @@ static const struct comedi_lrange *const ni_range_lkup[] = {
 };
 
 static int ni_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ni_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ni_cdio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_cmd * cmd);
 static int ni_cdio_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
@@ -206,33 +206,33 @@ static int ni_cdo_inttrig(struct comedi_device * dev, struct comedi_subdevice *
 	unsigned int trignum);
 
 static int ni_serial_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ni_serial_hw_readwrite8(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned char data_out, unsigned char *data_in);
 static int ni_serial_sw_readwrite8(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned char data_out, unsigned char *data_in);
 
 static int ni_calib_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ni_calib_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 
 static int ni_eeprom_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ni_m_series_eeprom_insn_read(struct comedi_device * dev,
-	struct comedi_subdevice * s, comedi_insn * insn, unsigned int * data);
+	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data);
 
 static int ni_pfi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ni_pfi_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static unsigned ni_old_get_pfi_routing(struct comedi_device * dev, unsigned chan);
 
 static void ni_rtsi_init(struct comedi_device * dev);
 static int ni_rtsi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ni_rtsi_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 
 static void caldac_setup(struct comedi_device * dev, struct comedi_subdevice * s);
 static int ni_read_eeprom(struct comedi_device * dev, int addr);
@@ -268,11 +268,11 @@ static int ni_ao_reset(struct comedi_device * dev, struct comedi_subdevice * s);
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
 
 static int ni_gpct_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ni_gpct_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ni_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ni_gpct_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int ni_gpct_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_cmd * cmd);
@@ -283,7 +283,7 @@ static void handle_gpct_interrupt(struct comedi_device * dev,
 static int init_cs5529(struct comedi_device * dev);
 static int cs5529_do_conversion(struct comedi_device * dev, unsigned short *data);
 static int cs5529_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 #ifdef NI_CS5529_DEBUG
 static unsigned int cs5529_config_read(struct comedi_device * dev,
 	unsigned int reg_select_bits);
@@ -292,9 +292,9 @@ static void cs5529_config_write(struct comedi_device * dev, unsigned int value,
 	unsigned int reg_select_bits);
 
 static int ni_m_series_pwm_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ni_6143_pwm_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 
 static int ni_set_master_clock(struct comedi_device * dev, unsigned source,
 	unsigned period_ns);
@@ -1719,7 +1719,7 @@ static int ni_ai_poll(struct comedi_device * dev, struct comedi_subdevice * s)
 }
 
 static int ni_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
 	const unsigned int mask = (1 << boardtype.adbits) - 1;
@@ -2626,10 +2626,10 @@ static int ni_ai_inttrig(struct comedi_device * dev, struct comedi_subdevice * s
 }
 
 static int ni_ai_config_analog_trig(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 
 static int ni_ai_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n < 1)
 		return -EINVAL;
@@ -2680,7 +2680,7 @@ static int ni_ai_insn_config(struct comedi_device * dev, struct comedi_subdevice
 }
 
 static int ni_ai_config_analog_trig(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int a, b, modebits;
 	int err = 0;
@@ -2922,7 +2922,7 @@ static int ni_ao_config_chanlist(struct comedi_device * dev, struct comedi_subde
 		return ni_old_ao_config_chanlist(dev, s, chanspec, n_chans);
 }
 static int ni_ao_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
 
@@ -2930,7 +2930,7 @@ static int ni_ao_insn_read(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 static int ni_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
@@ -2949,7 +2949,7 @@ static int ni_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice
 }
 
 static int ni_ao_insn_write_671x(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
@@ -2966,7 +2966,7 @@ static int ni_ao_insn_write_671x(struct comedi_device * dev, struct comedi_subde
 }
 
 static int ni_ao_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
@@ -3437,7 +3437,7 @@ static int ni_ao_reset(struct comedi_device * dev, struct comedi_subdevice * s)
 // digital io
 
 static int ni_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
 	rt_printk("ni_dio_insn_config() chan=%d io=%d\n",
@@ -3469,7 +3469,7 @@ static int ni_dio_insn_config(struct comedi_device * dev, struct comedi_subdevic
 }
 
 static int ni_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
 	rt_printk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);
@@ -3496,7 +3496,7 @@ static int ni_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice
 }
 
 static int ni_m_series_dio_insn_config(struct comedi_device * dev,
-	struct comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
+	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
 	rt_printk("ni_m_series_dio_insn_config() chan=%d io=%d\n",
@@ -3526,7 +3526,7 @@ static int ni_m_series_dio_insn_config(struct comedi_device * dev,
 }
 
 static int ni_m_series_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
 	rt_printk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],
@@ -3791,7 +3791,7 @@ static void handle_cdio_interrupt(struct comedi_device * dev)
 }
 
 static int ni_serial_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int err = insn->n;
 	unsigned char byte_out, byte_in = 0;
@@ -4209,14 +4209,14 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 }
 
 static int ni_freq_out_insn_read(struct comedi_device * dev,
-	struct comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
+	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->clock_and_fout & FOUT_Divider_mask;
 	return 1;
 }
 
 static int ni_freq_out_insn_write(struct comedi_device * dev,
-	struct comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
+	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data)
 {
 	devpriv->clock_and_fout &= ~FOUT_Enable;
 	devpriv->stc_writew(dev, devpriv->clock_and_fout,
@@ -4259,7 +4259,7 @@ static void ni_get_freq_out_clock(struct comedi_device * dev, unsigned int * clo
 }
 
 static int ni_freq_out_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_SET_CLOCK_SRC:
@@ -4624,7 +4624,7 @@ static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 */
 
 static int ni_eeprom_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));
 
@@ -4660,7 +4660,7 @@ static int ni_read_eeprom(struct comedi_device * dev, int addr)
 }
 
 static int ni_m_series_eeprom_insn_read(struct comedi_device * dev,
-	struct comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
+	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];
 
@@ -4675,7 +4675,7 @@ static int ni_get_pwm_config(struct comedi_device * dev, unsigned int * data)
 }
 
 static int ni_m_series_pwm_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned up_count, down_count;
 	switch (data[0]) {
@@ -4740,7 +4740,7 @@ static int ni_m_series_pwm_config(struct comedi_device * dev, struct comedi_subd
 }
 
 static int ni_6143_pwm_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned up_count, down_count;
 	switch (data[0]) {
@@ -4807,7 +4807,7 @@ static void ni_write_caldac(struct comedi_device * dev, int addr, int val);
 	calibration subdevice
 */
 static int ni_calib_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	ni_write_caldac(dev, CR_CHAN(insn->chanspec), data[0]);
 
@@ -4815,7 +4815,7 @@ static int ni_calib_insn_write(struct comedi_device * dev, struct comedi_subdevi
 }
 
 static int ni_calib_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];
 
@@ -5071,21 +5071,21 @@ static void GPCT_Reset(struct comedi_device * dev, int chan)
 #endif
 
 static int ni_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_insn_config(counter, insn, data);
 }
 
 static int ni_gpct_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_rinsn(counter, insn, data);
 }
 
 static int ni_gpct_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_winsn(counter, insn, data);
@@ -5254,7 +5254,7 @@ static int ni_config_filter(struct comedi_device * dev, unsigned pfi_channel,
 }
 
 static int ni_pfi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
 		return -ENOTSUPP;
@@ -5269,7 +5269,7 @@ static int ni_pfi_insn_bits(struct comedi_device * dev, struct comedi_subdevice
 }
 
 static int ni_pfi_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan;
 
@@ -5346,7 +5346,7 @@ static void ni_rtsi_init(struct comedi_device * dev)
 }
 
 static int ni_rtsi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -5627,7 +5627,7 @@ static unsigned ni_get_rtsi_routing(struct comedi_device * dev, unsigned chan)
 }
 
 static int ni_rtsi_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	switch (data[0]) {
@@ -5806,7 +5806,7 @@ static int cs5529_do_conversion(struct comedi_device * dev, unsigned short *data
 }
 
 static int cs5529_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int n, retval;
 	unsigned short sample;

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index eaa141daafae..a2988bdb2652 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -198,7 +198,7 @@ static int ni_dio_insn_config(struct comedi_device * dev, struct comedi_subdevic
 static int ni_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static int ni_cdio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int ni_cdio_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int ni_cdio_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static void handle_cdio_interrupt(struct comedi_device * dev);
@@ -275,7 +275,7 @@ static int ni_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevi
 	comedi_insn * insn, unsigned int * data);
 static int ni_gpct_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int ni_gpct_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int ni_gpct_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static void handle_gpct_interrupt(struct comedi_device * dev,
 	unsigned short counter_index);
@@ -1207,7 +1207,7 @@ static void ni_mio_print_status_b(int status)
 static void ni_ao_fifo_load(struct comedi_device * dev, struct comedi_subdevice * s, int n)
 {
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	int chan;
 	int i;
 	short d;
@@ -2096,7 +2096,7 @@ static unsigned ni_min_ai_scan_period_ns(struct comedi_device * dev,
 }
 
 static int ni_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -2310,7 +2310,7 @@ static int ni_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s
 
 static int ni_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	const comedi_cmd *cmd = &s->async->cmd;
+	const struct comedi_cmd *cmd = &s->async->cmd;
 	int timer;
 	int mode1 = 0;		/* mode1 is needed for both stop and convert */
 	int mode2 = 0;
@@ -3064,7 +3064,7 @@ static int ni_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s
 
 static int ni_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	const comedi_cmd *cmd = &s->async->cmd;
+	const struct comedi_cmd *cmd = &s->async->cmd;
 	int bits;
 	int i;
 	unsigned trigvar;
@@ -3262,7 +3262,7 @@ static int ni_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 }
 
 static int ni_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -3545,7 +3545,7 @@ static int ni_m_series_dio_insn_bits(struct comedi_device * dev, struct comedi_s
 }
 
 static int ni_cdio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -3655,7 +3655,7 @@ static int ni_cdio_cmdtest(struct comedi_device * dev, struct comedi_subdevice *
 
 static int ni_cdio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	const comedi_cmd *cmd = &s->async->cmd;
+	const struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;
 	int retval;
 
@@ -5096,7 +5096,7 @@ static int ni_gpct_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	int retval;
 #ifdef PCIDMA
 	struct ni_gpct *counter = s->private;
-//      const comedi_cmd *cmd = &s->async->cmd;
+//      const struct comedi_cmd *cmd = &s->async->cmd;
 
 	retval = ni_request_gpct_mite_channel(dev, counter->counter_index,
 		COMEDI_INPUT);
@@ -5115,7 +5115,7 @@ static int ni_gpct_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 }
 
 static int ni_gpct_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 #ifdef PCIDMA
 	struct ni_gpct *counter = s->private;

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 8f3c959f6265..eaa141daafae 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -88,7 +88,7 @@ static const short ni_gainlkup[][16] = {
 	[ai_gain_6143] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
 };
 
-static const comedi_lrange range_ni_E_ai = { 16, {
+static const struct comedi_lrange range_ni_E_ai = { 16, {
 			RANGE(-10, 10),
 			RANGE(-5, 5),
 			RANGE(-2.5, 2.5),
@@ -107,7 +107,7 @@ static const comedi_lrange range_ni_E_ai = { 16, {
 			RANGE(0, 0.1),
 	}
 };
-static const comedi_lrange range_ni_E_ai_limited = { 8, {
+static const struct comedi_lrange range_ni_E_ai_limited = { 8, {
 			RANGE(-10, 10),
 			RANGE(-5, 5),
 			RANGE(-1, 1),
@@ -118,7 +118,7 @@ static const comedi_lrange range_ni_E_ai_limited = { 8, {
 			RANGE(0, 0.1),
 	}
 };
-static const comedi_lrange range_ni_E_ai_limited14 = { 14, {
+static const struct comedi_lrange range_ni_E_ai_limited14 = { 14, {
 			RANGE(-10, 10),
 			RANGE(-5, 5),
 			RANGE(-2, 2),
@@ -135,14 +135,14 @@ static const comedi_lrange range_ni_E_ai_limited14 = { 14, {
 			RANGE(0, 0.1),
 	}
 };
-static const comedi_lrange range_ni_E_ai_bipolar4 = { 4, {
+static const struct comedi_lrange range_ni_E_ai_bipolar4 = { 4, {
 			RANGE(-10, 10),
 			RANGE(-5, 5),
 			RANGE(-0.5, 0.5),
 			RANGE(-0.05, 0.05),
 	}
 };
-static const comedi_lrange range_ni_E_ai_611x = { 8, {
+static const struct comedi_lrange range_ni_E_ai_611x = { 8, {
 			RANGE(-50, 50),
 			RANGE(-20, 20),
 			RANGE(-10, 10),
@@ -153,14 +153,14 @@ static const comedi_lrange range_ni_E_ai_611x = { 8, {
 			RANGE(-0.2, 0.2),
 	}
 };
-static const comedi_lrange range_ni_M_ai_622x = { 4, {
+static const struct comedi_lrange range_ni_M_ai_622x = { 4, {
 			RANGE(-10, 10),
 			RANGE(-5, 5),
 			RANGE(-1, 1),
 			RANGE(-0.2, 0.2),
 	}
 };
-static const comedi_lrange range_ni_M_ai_628x = { 7, {
+static const struct comedi_lrange range_ni_M_ai_628x = { 7, {
 			RANGE(-10, 10),
 			RANGE(-5, 5),
 			RANGE(-2, 2),
@@ -170,11 +170,11 @@ static const comedi_lrange range_ni_M_ai_628x = { 7, {
 			RANGE(-0.1, 0.1),
 	}
 };
-static const comedi_lrange range_ni_S_ai_6143 = { 1, {
+static const struct comedi_lrange range_ni_S_ai_6143 = { 1, {
 			RANGE(-5, +5),
 	}
 };
-static const comedi_lrange range_ni_E_ao_ext = { 4, {
+static const struct comedi_lrange range_ni_E_ao_ext = { 4, {
 			RANGE(-10, 10),
 			RANGE(0, 10),
 			RANGE_ext(-1, 1),
@@ -182,7 +182,7 @@ static const comedi_lrange range_ni_E_ao_ext = { 4, {
 	}
 };
 
-static const comedi_lrange *const ni_range_lkup[] = {
+static const struct comedi_lrange *const ni_range_lkup[] = {
 	[ai_gain_16] = &range_ni_E_ai,
 	[ai_gain_8] = &range_ni_E_ai_limited,
 	[ai_gain_14] = &range_ni_E_ai_limited14,

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 29698d995a19..8f3c959f6265 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -1206,7 +1206,7 @@ static void ni_mio_print_status_b(int status)
 
 static void ni_ao_fifo_load(struct comedi_device * dev, struct comedi_subdevice * s, int n)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	int chan;
 	int i;
@@ -1309,7 +1309,7 @@ static int ni_ao_prep_fifo(struct comedi_device * dev, struct comedi_subdevice *
 
 static void ni_ai_fifo_read(struct comedi_device * dev, struct comedi_subdevice * s, int n)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	int i;
 
 	if (boardtype.reg_type == ni_reg_611x) {
@@ -1516,7 +1516,7 @@ static void get_last_sample_6143(struct comedi_device * dev)
 static void ni_ai_munge(struct comedi_device * dev, struct comedi_subdevice * s,
 	void *data, unsigned int num_bytes, unsigned int chan_index)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	unsigned int i;
 	unsigned int length = num_bytes / bytes_per_sample(s);
 	short *array = data;
@@ -2780,7 +2780,7 @@ static int ni_ai_config_analog_trig(struct comedi_device * dev, struct comedi_su
 static void ni_ao_munge(struct comedi_device * dev, struct comedi_subdevice * s,
 	void *data, unsigned int num_bytes, unsigned int chan_index)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	unsigned int range;
 	unsigned int i;
 	unsigned int offset;

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index f702cc9064ba..29698d995a19 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -193,48 +193,48 @@ static const comedi_lrange *const ni_range_lkup[] = {
 	[ai_gain_6143] = &range_ni_S_ai_6143
 };
 
-static int ni_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_cdio_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_cdio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int ni_cdio_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int ni_cdio_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int ni_cdio_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int ni_cdio_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static void handle_cdio_interrupt(struct comedi_device * dev);
-static int ni_cdo_inttrig(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_cdo_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trignum);
 
-static int ni_serial_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_serial_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_serial_hw_readwrite8(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_serial_hw_readwrite8(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned char data_out, unsigned char *data_in);
-static int ni_serial_sw_readwrite8(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_serial_sw_readwrite8(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned char data_out, unsigned char *data_in);
 
-static int ni_calib_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_calib_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_calib_insn_write(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_calib_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
-static int ni_eeprom_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_eeprom_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static int ni_m_series_eeprom_insn_read(struct comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, unsigned int * data);
+	struct comedi_subdevice * s, comedi_insn * insn, unsigned int * data);
 
-static int ni_pfi_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_pfi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_pfi_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_pfi_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static unsigned ni_old_get_pfi_routing(struct comedi_device * dev, unsigned chan);
 
 static void ni_rtsi_init(struct comedi_device * dev);
-static int ni_rtsi_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_rtsi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_rtsi_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_rtsi_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
-static void caldac_setup(struct comedi_device * dev, comedi_subdevice * s);
+static void caldac_setup(struct comedi_device * dev, struct comedi_subdevice * s);
 static int ni_read_eeprom(struct comedi_device * dev, int addr);
 
 #ifdef DEBUG_STATUS_A
@@ -248,41 +248,41 @@ static void ni_mio_print_status_b(int status);
 #define ni_mio_print_status_b(a)
 #endif
 
-static int ni_ai_reset(struct comedi_device * dev, comedi_subdevice * s);
+static int ni_ai_reset(struct comedi_device * dev, struct comedi_subdevice * s);
 #ifndef PCIDMA
 static void ni_handle_fifo_half_full(struct comedi_device * dev);
-static int ni_ao_fifo_half_empty(struct comedi_device * dev, comedi_subdevice * s);
+static int ni_ao_fifo_half_empty(struct comedi_device * dev, struct comedi_subdevice * s);
 #endif
 static void ni_handle_fifo_dregs(struct comedi_device * dev);
-static int ni_ai_inttrig(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ai_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trignum);
 static void ni_load_channelgain_list(struct comedi_device * dev, unsigned int n_chan,
 	unsigned int *list);
 static void shutdown_ai_command(struct comedi_device * dev);
 
-static int ni_ao_inttrig(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trignum);
 
-static int ni_ao_reset(struct comedi_device * dev, comedi_subdevice * s);
+static int ni_ao_reset(struct comedi_device * dev, struct comedi_subdevice * s);
 
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
 
-static int ni_gpct_insn_write(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_gpct_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_gpct_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_gpct_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int ni_gpct_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int ni_gpct_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int ni_gpct_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int ni_gpct_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static void handle_gpct_interrupt(struct comedi_device * dev,
 	unsigned short counter_index);
 
 static int init_cs5529(struct comedi_device * dev);
 static int cs5529_do_conversion(struct comedi_device * dev, unsigned short *data);
-static int cs5529_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int cs5529_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 #ifdef NI_CS5529_DEBUG
 static unsigned int cs5529_config_read(struct comedi_device * dev,
@@ -291,9 +291,9 @@ static unsigned int cs5529_config_read(struct comedi_device * dev,
 static void cs5529_config_write(struct comedi_device * dev, unsigned int value,
 	unsigned int reg_select_bits);
 
-static int ni_m_series_pwm_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_m_series_pwm_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_6143_pwm_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_6143_pwm_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
 static int ni_set_master_clock(struct comedi_device * dev, unsigned source,
@@ -825,7 +825,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d PT_REGS_ARG)
 #ifdef PCIDMA
 static void ni_sync_ai_dma(struct comedi_device * dev)
 {
-	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	unsigned long flags;
 
 	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
@@ -836,7 +836,7 @@ static void ni_sync_ai_dma(struct comedi_device * dev)
 
 static void mite_handle_b_linkc(struct mite_struct *mite, struct comedi_device * dev)
 {
-	comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
+	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	unsigned long flags;
 
 	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
@@ -868,7 +868,7 @@ static int ni_ao_wait_for_dma_load(struct comedi_device * dev)
 }
 
 #endif //PCIDMA
-static void ni_handle_eos(struct comedi_device * dev, comedi_subdevice * s)
+static void ni_handle_eos(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	if (devpriv->aimode == AIMODE_SCAN) {
 #ifdef PCIDMA
@@ -894,7 +894,7 @@ static void ni_handle_eos(struct comedi_device * dev, comedi_subdevice * s)
 
 static void shutdown_ai_command(struct comedi_device * dev)
 {
-	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 
 #ifdef PCIDMA
 	ni_ai_drain_dma(dev);
@@ -906,7 +906,7 @@ static void shutdown_ai_command(struct comedi_device * dev)
 	s->async->events |= COMEDI_CB_EOA;
 }
 
-static void ni_event(struct comedi_device * dev, comedi_subdevice * s)
+static void ni_event(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	if (s->async->
 		events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW | COMEDI_CB_EOA))
@@ -936,7 +936,7 @@ static void handle_gpct_interrupt(struct comedi_device * dev,
 	unsigned short counter_index)
 {
 #ifdef PCIDMA
-	comedi_subdevice *s = dev->subdevices + NI_GPCT_SUBDEV(counter_index);
+	struct comedi_subdevice *s = dev->subdevices + NI_GPCT_SUBDEV(counter_index);
 
 	ni_tio_handle_interrupt(&devpriv->counter_dev->counters[counter_index],
 		s);
@@ -969,7 +969,7 @@ static void ack_a_interrupt(struct comedi_device * dev, unsigned short a_status)
 static void handle_a_interrupt(struct comedi_device * dev, unsigned short status,
 	unsigned ai_mite_status)
 {
-	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 
 	//67xx boards don't have ai subdevice, but their gpct0 might generate an a interrupt
 	if (s->type == COMEDI_SUBD_UNUSED)
@@ -1101,7 +1101,7 @@ static void ack_b_interrupt(struct comedi_device * dev, unsigned short b_status)
 static void handle_b_interrupt(struct comedi_device * dev, unsigned short b_status,
 	unsigned ao_mite_status)
 {
-	comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
+	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	//unsigned short ack=0;
 #ifdef DEBUG_INTERRUPT
 	rt_printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
@@ -1204,7 +1204,7 @@ static void ni_mio_print_status_b(int status)
 
 #ifndef PCIDMA
 
-static void ni_ao_fifo_load(struct comedi_device * dev, comedi_subdevice * s, int n)
+static void ni_ao_fifo_load(struct comedi_device * dev, struct comedi_subdevice * s, int n)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -1263,7 +1263,7 @@ static void ni_ao_fifo_load(struct comedi_device * dev, comedi_subdevice * s, in
  *  RT code, as RT code might purposely be running close to the
  *  metal.  Needs to be fixed eventually.
  */
-static int ni_ao_fifo_half_empty(struct comedi_device * dev, comedi_subdevice * s)
+static int ni_ao_fifo_half_empty(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int n;
 
@@ -1284,7 +1284,7 @@ static int ni_ao_fifo_half_empty(struct comedi_device * dev, comedi_subdevice *
 	return 1;
 }
 
-static int ni_ao_prep_fifo(struct comedi_device * dev, comedi_subdevice * s)
+static int ni_ao_prep_fifo(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int n;
 
@@ -1307,7 +1307,7 @@ static int ni_ao_prep_fifo(struct comedi_device * dev, comedi_subdevice * s)
 	return n;
 }
 
-static void ni_ai_fifo_read(struct comedi_device * dev, comedi_subdevice * s, int n)
+static void ni_ai_fifo_read(struct comedi_device * dev, struct comedi_subdevice * s, int n)
 {
 	comedi_async *async = s->async;
 	int i;
@@ -1367,7 +1367,7 @@ static void ni_ai_fifo_read(struct comedi_device * dev, comedi_subdevice * s, in
 static void ni_handle_fifo_half_full(struct comedi_device * dev)
 {
 	int n;
-	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 
 	n = boardtype.ai_fifo_depth / 2;
 
@@ -1416,7 +1416,7 @@ static int ni_ai_drain_dma(struct comedi_device * dev)
 */
 static void ni_handle_fifo_dregs(struct comedi_device * dev)
 {
-	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	short data[2];
 	u32 dl;
 	short fifo_empty;
@@ -1478,7 +1478,7 @@ static void ni_handle_fifo_dregs(struct comedi_device * dev)
 
 static void get_last_sample_611x(struct comedi_device * dev)
 {
-	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	short data;
 	u32 dl;
 
@@ -1495,7 +1495,7 @@ static void get_last_sample_611x(struct comedi_device * dev)
 
 static void get_last_sample_6143(struct comedi_device * dev)
 {
-	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	short data;
 	u32 dl;
 
@@ -1513,7 +1513,7 @@ static void get_last_sample_6143(struct comedi_device * dev)
 	}
 }
 
-static void ni_ai_munge(struct comedi_device * dev, comedi_subdevice * s,
+static void ni_ai_munge(struct comedi_device * dev, struct comedi_subdevice * s,
 	void *data, unsigned int num_bytes, unsigned int chan_index)
 {
 	comedi_async *async = s->async;
@@ -1541,7 +1541,7 @@ static void ni_ai_munge(struct comedi_device * dev, comedi_subdevice * s,
 
 static int ni_ai_setup_MITE_dma(struct comedi_device * dev)
 {
-	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	int retval;
 	unsigned long flags;
 
@@ -1581,7 +1581,7 @@ static int ni_ai_setup_MITE_dma(struct comedi_device * dev)
 
 static int ni_ao_setup_MITE_dma(struct comedi_device * dev)
 {
-	comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
+	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	int retval;
 	unsigned long flags;
 
@@ -1617,7 +1617,7 @@ static int ni_ao_setup_MITE_dma(struct comedi_device * dev)
    this is pretty harsh for a cancel, but it works...
  */
 
-static int ni_ai_reset(struct comedi_device * dev, comedi_subdevice * s)
+static int ni_ai_reset(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	ni_release_ai_mite_channel(dev);
 	/* ai configuration */
@@ -1698,7 +1698,7 @@ static int ni_ai_reset(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int ni_ai_poll(struct comedi_device * dev, comedi_subdevice * s)
+static int ni_ai_poll(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long flags = 0;
 	int count;
@@ -1718,7 +1718,7 @@ static int ni_ai_poll(struct comedi_device * dev, comedi_subdevice * s)
 	return count;
 }
 
-static int ni_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
@@ -2095,7 +2095,7 @@ static unsigned ni_min_ai_scan_period_ns(struct comedi_device * dev,
 	return boardtype.ai_speed * num_channels;
 }
 
-static int ni_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -2308,7 +2308,7 @@ static int ni_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int ni_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int ni_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	const comedi_cmd *cmd = &s->async->cmd;
 	int timer;
@@ -2612,7 +2612,7 @@ static int ni_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int ni_ai_inttrig(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ai_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trignum)
 {
 	if (trignum != 0)
@@ -2625,10 +2625,10 @@ static int ni_ai_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ni_ai_config_analog_trig(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ai_config_analog_trig(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
-static int ni_ai_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ai_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n < 1)
@@ -2679,7 +2679,7 @@ static int ni_ai_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	return -EINVAL;
 }
 
-static int ni_ai_config_analog_trig(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ai_config_analog_trig(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int a, b, modebits;
@@ -2777,7 +2777,7 @@ static int ni_ai_config_analog_trig(struct comedi_device * dev, comedi_subdevice
 }
 
 /* munge data from unsigned to 2's complement for analog output bipolar modes */
-static void ni_ao_munge(struct comedi_device * dev, comedi_subdevice * s,
+static void ni_ao_munge(struct comedi_device * dev, struct comedi_subdevice * s,
 	void *data, unsigned int num_bytes, unsigned int chan_index)
 {
 	comedi_async *async = s->async;
@@ -2801,7 +2801,7 @@ static void ni_ao_munge(struct comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ni_m_series_ao_config_chanlist(struct comedi_device * dev,
-	comedi_subdevice * s, unsigned int chanspec[], unsigned int n_chans,
+	struct comedi_subdevice * s, unsigned int chanspec[], unsigned int n_chans,
 	int timed)
 {
 	unsigned int range;
@@ -2869,7 +2869,7 @@ static int ni_m_series_ao_config_chanlist(struct comedi_device * dev,
 	return invert;
 }
 
-static int ni_old_ao_config_chanlist(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_old_ao_config_chanlist(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int chanspec[], unsigned int n_chans)
 {
 	unsigned int range;
@@ -2912,7 +2912,7 @@ static int ni_old_ao_config_chanlist(struct comedi_device * dev, comedi_subdevic
 	return invert;
 }
 
-static int ni_ao_config_chanlist(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_config_chanlist(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int chanspec[], unsigned int n_chans, int timed)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
@@ -2921,7 +2921,7 @@ static int ni_ao_config_chanlist(struct comedi_device * dev, comedi_subdevice *
 	else
 		return ni_old_ao_config_chanlist(dev, s, chanspec, n_chans);
 }
-static int ni_ao_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
@@ -2929,7 +2929,7 @@ static int ni_ao_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ni_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
@@ -2948,7 +2948,7 @@ static int ni_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ni_ao_insn_write_671x(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_insn_write_671x(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
@@ -2965,7 +2965,7 @@ static int ni_ao_insn_write_671x(struct comedi_device * dev, comedi_subdevice *
 	return 1;
 }
 
-static int ni_ao_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
@@ -2991,7 +2991,7 @@ static int ni_ao_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	return -EINVAL;
 }
 
-static int ni_ao_inttrig(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trignum)
 {
 	int ret;
@@ -3062,7 +3062,7 @@ static int ni_ao_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int ni_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int ni_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	const comedi_cmd *cmd = &s->async->cmd;
 	int bits;
@@ -3261,7 +3261,7 @@ static int ni_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int ni_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -3384,7 +3384,7 @@ static int ni_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int ni_ao_reset(struct comedi_device * dev, comedi_subdevice * s)
+static int ni_ao_reset(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	//devpriv->ao0p=0x0000;
 	//ni_writew(devpriv->ao0p,AO_Configuration);
@@ -3436,7 +3436,7 @@ static int ni_ao_reset(struct comedi_device * dev, comedi_subdevice * s)
 
 // digital io
 
-static int ni_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
@@ -3468,7 +3468,7 @@ static int ni_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ni_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
@@ -3496,7 +3496,7 @@ static int ni_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ni_m_series_dio_insn_config(struct comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
+	struct comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
 	rt_printk("ni_m_series_dio_insn_config() chan=%d io=%d\n",
@@ -3525,7 +3525,7 @@ static int ni_m_series_dio_insn_config(struct comedi_device * dev,
 	return 1;
 }
 
-static int ni_m_series_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_m_series_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
@@ -3544,7 +3544,7 @@ static int ni_m_series_dio_insn_bits(struct comedi_device * dev, comedi_subdevic
 	return 2;
 }
 
-static int ni_cdio_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_cdio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -3653,7 +3653,7 @@ static int ni_cdio_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int ni_cdio_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int ni_cdio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	const comedi_cmd *cmd = &s->async->cmd;
 	unsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;
@@ -3690,7 +3690,7 @@ static int ni_cdio_cmd(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int ni_cdo_inttrig(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_cdo_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trignum)
 {
 #ifdef PCIDMA
@@ -3736,7 +3736,7 @@ static int ni_cdo_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	return retval;
 }
 
-static int ni_cdio_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int ni_cdio_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	ni_writel(CDO_Disarm_Bit | CDO_Error_Interrupt_Enable_Clear_Bit |
 		CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
@@ -3752,7 +3752,7 @@ static int ni_cdio_cancel(struct comedi_device * dev, comedi_subdevice * s)
 static void handle_cdio_interrupt(struct comedi_device * dev)
 {
 	unsigned cdio_status;
-	comedi_subdevice *s = dev->subdevices + NI_DIO_SUBDEV;
+	struct comedi_subdevice *s = dev->subdevices + NI_DIO_SUBDEV;
 #ifdef PCIDMA
 	unsigned long flags;
 #endif
@@ -3790,7 +3790,7 @@ static void handle_cdio_interrupt(struct comedi_device * dev)
 	ni_event(dev, s);
 }
 
-static int ni_serial_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_serial_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int err = insn->n;
@@ -3884,7 +3884,7 @@ static int ni_serial_insn_config(struct comedi_device * dev, comedi_subdevice *
 
 }
 
-static int ni_serial_hw_readwrite8(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_serial_hw_readwrite8(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned char data_out, unsigned char *data_in)
 {
 	unsigned int status1;
@@ -3940,7 +3940,7 @@ static int ni_serial_hw_readwrite8(struct comedi_device * dev, comedi_subdevice
 	return err;
 }
 
-static int ni_serial_sw_readwrite8(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_serial_sw_readwrite8(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned char data_out, unsigned char *data_in)
 {
 	unsigned char mask, input = 0;
@@ -4004,7 +4004,7 @@ static void mio_common_detach(struct comedi_device * dev)
 		subdev_8255_cleanup(dev, dev->subdevices + NI_8255_DIO_SUBDEV);
 }
 
-static void init_ao_67xx(struct comedi_device * dev, comedi_subdevice * s)
+static void init_ao_67xx(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int i;
 
@@ -4209,14 +4209,14 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 }
 
 static int ni_freq_out_insn_read(struct comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
+	struct comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->clock_and_fout & FOUT_Divider_mask;
 	return 1;
 }
 
 static int ni_freq_out_insn_write(struct comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
+	struct comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
 {
 	devpriv->clock_and_fout &= ~FOUT_Enable;
 	devpriv->stc_writew(dev, devpriv->clock_and_fout,
@@ -4258,7 +4258,7 @@ static void ni_get_freq_out_clock(struct comedi_device * dev, unsigned int * clo
 	}
 }
 
-static int ni_freq_out_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_freq_out_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
@@ -4291,7 +4291,7 @@ static int ni_alloc_private(struct comedi_device * dev)
 
 static int ni_E_init(struct comedi_device * dev, comedi_devconfig * it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	unsigned j;
 	enum ni_gpct_variant counter_variant;
 
@@ -4623,7 +4623,7 @@ static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 	presents the EEPROM as a subdevice
 */
 
-static int ni_eeprom_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_eeprom_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));
@@ -4660,7 +4660,7 @@ static int ni_read_eeprom(struct comedi_device * dev, int addr)
 }
 
 static int ni_m_series_eeprom_insn_read(struct comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
+	struct comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];
 
@@ -4674,7 +4674,7 @@ static int ni_get_pwm_config(struct comedi_device * dev, unsigned int * data)
 	return 3;
 }
 
-static int ni_m_series_pwm_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_m_series_pwm_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned up_count, down_count;
@@ -4739,7 +4739,7 @@ static int ni_m_series_pwm_config(struct comedi_device * dev, comedi_subdevice *
 	return 0;
 }
 
-static int ni_6143_pwm_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_6143_pwm_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned up_count, down_count;
@@ -4806,7 +4806,7 @@ static void ni_write_caldac(struct comedi_device * dev, int addr, int val);
 /*
 	calibration subdevice
 */
-static int ni_calib_insn_write(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_calib_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	ni_write_caldac(dev, CR_CHAN(insn->chanspec), data[0]);
@@ -4814,7 +4814,7 @@ static int ni_calib_insn_write(struct comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ni_calib_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_calib_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];
@@ -4845,7 +4845,7 @@ static struct caldac_struct caldacs[] = {
 	[ad8804_debug] = {16, 8, pack_ad8804},
 };
 
-static void caldac_setup(struct comedi_device * dev, comedi_subdevice * s)
+static void caldac_setup(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int i, j;
 	int n_dacs;
@@ -5070,28 +5070,28 @@ static void GPCT_Reset(struct comedi_device * dev, int chan)
 
 #endif
 
-static int ni_gpct_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_insn_config(counter, insn, data);
 }
 
-static int ni_gpct_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_rinsn(counter, insn, data);
 }
 
-static int ni_gpct_insn_write(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_winsn(counter, insn, data);
 }
 
-static int ni_gpct_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int ni_gpct_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int retval;
 #ifdef PCIDMA
@@ -5114,7 +5114,7 @@ static int ni_gpct_cmd(struct comedi_device * dev, comedi_subdevice * s)
 	return retval;
 }
 
-static int ni_gpct_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 #ifdef PCIDMA
@@ -5126,7 +5126,7 @@ static int ni_gpct_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 #endif
 }
 
-static int ni_gpct_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int ni_gpct_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 #ifdef PCIDMA
 	struct ni_gpct *counter = s->private;
@@ -5253,7 +5253,7 @@ static int ni_config_filter(struct comedi_device * dev, unsigned pfi_channel,
 	return 0;
 }
 
-static int ni_pfi_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_pfi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
@@ -5268,7 +5268,7 @@ static int ni_pfi_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int ni_pfi_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_pfi_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan;
@@ -5345,7 +5345,7 @@ static void ni_rtsi_init(struct comedi_device * dev)
 //      devpriv->stc_writew(dev, 0x0000, RTSI_Board_Register);
 }
 
-static int ni_rtsi_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_rtsi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
@@ -5626,7 +5626,7 @@ static unsigned ni_get_rtsi_routing(struct comedi_device * dev, unsigned chan)
 	}
 }
 
-static int ni_rtsi_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_rtsi_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
@@ -5805,7 +5805,7 @@ static int cs5529_do_conversion(struct comedi_device * dev, unsigned short *data
 	return 0;
 }
 
-static int cs5529_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int cs5529_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n, retval;

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index bb2c378cf68a..f702cc9064ba 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -193,49 +193,49 @@ static const comedi_lrange *const ni_range_lkup[] = {
 	[ai_gain_6143] = &range_ni_S_ai_6143
 };
 
-static int ni_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int ni_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_cdio_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int ni_cdio_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int ni_cdio_cmd(comedi_device * dev, comedi_subdevice * s);
-static int ni_cdio_cancel(comedi_device * dev, comedi_subdevice * s);
-static void handle_cdio_interrupt(comedi_device * dev);
-static int ni_cdo_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int ni_cdio_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int ni_cdio_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static void handle_cdio_interrupt(struct comedi_device * dev);
+static int ni_cdo_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trignum);
 
-static int ni_serial_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_serial_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_serial_hw_readwrite8(comedi_device * dev, comedi_subdevice * s,
+static int ni_serial_hw_readwrite8(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned char data_out, unsigned char *data_in);
-static int ni_serial_sw_readwrite8(comedi_device * dev, comedi_subdevice * s,
+static int ni_serial_sw_readwrite8(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned char data_out, unsigned char *data_in);
 
-static int ni_calib_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int ni_calib_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_calib_insn_write(comedi_device * dev, comedi_subdevice * s,
+static int ni_calib_insn_write(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
-static int ni_eeprom_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int ni_eeprom_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_m_series_eeprom_insn_read(comedi_device * dev,
+static int ni_m_series_eeprom_insn_read(struct comedi_device * dev,
 	comedi_subdevice * s, comedi_insn * insn, unsigned int * data);
 
-static int ni_pfi_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int ni_pfi_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_pfi_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_pfi_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static unsigned ni_old_get_pfi_routing(comedi_device * dev, unsigned chan);
+static unsigned ni_old_get_pfi_routing(struct comedi_device * dev, unsigned chan);
 
-static void ni_rtsi_init(comedi_device * dev);
-static int ni_rtsi_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static void ni_rtsi_init(struct comedi_device * dev);
+static int ni_rtsi_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_rtsi_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_rtsi_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
-static void caldac_setup(comedi_device * dev, comedi_subdevice * s);
-static int ni_read_eeprom(comedi_device * dev, int addr);
+static void caldac_setup(struct comedi_device * dev, comedi_subdevice * s);
+static int ni_read_eeprom(struct comedi_device * dev, int addr);
 
 #ifdef DEBUG_STATUS_A
 static void ni_mio_print_status_a(int status);
@@ -248,58 +248,58 @@ static void ni_mio_print_status_b(int status);
 #define ni_mio_print_status_b(a)
 #endif
 
-static int ni_ai_reset(comedi_device * dev, comedi_subdevice * s);
+static int ni_ai_reset(struct comedi_device * dev, comedi_subdevice * s);
 #ifndef PCIDMA
-static void ni_handle_fifo_half_full(comedi_device * dev);
-static int ni_ao_fifo_half_empty(comedi_device * dev, comedi_subdevice * s);
+static void ni_handle_fifo_half_full(struct comedi_device * dev);
+static int ni_ao_fifo_half_empty(struct comedi_device * dev, comedi_subdevice * s);
 #endif
-static void ni_handle_fifo_dregs(comedi_device * dev);
-static int ni_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
+static void ni_handle_fifo_dregs(struct comedi_device * dev);
+static int ni_ai_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trignum);
-static void ni_load_channelgain_list(comedi_device * dev, unsigned int n_chan,
+static void ni_load_channelgain_list(struct comedi_device * dev, unsigned int n_chan,
 	unsigned int *list);
-static void shutdown_ai_command(comedi_device * dev);
+static void shutdown_ai_command(struct comedi_device * dev);
 
-static int ni_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trignum);
 
-static int ni_ao_reset(comedi_device * dev, comedi_subdevice * s);
+static int ni_ao_reset(struct comedi_device * dev, comedi_subdevice * s);
 
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
 
-static int ni_gpct_insn_write(comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_insn_write(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_gpct_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_gpct_cmd(comedi_device * dev, comedi_subdevice * s);
-static int ni_gpct_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int ni_gpct_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int ni_gpct_cancel(comedi_device * dev, comedi_subdevice * s);
-static void handle_gpct_interrupt(comedi_device * dev,
+static int ni_gpct_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static void handle_gpct_interrupt(struct comedi_device * dev,
 	unsigned short counter_index);
 
-static int init_cs5529(comedi_device * dev);
-static int cs5529_do_conversion(comedi_device * dev, unsigned short *data);
-static int cs5529_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int init_cs5529(struct comedi_device * dev);
+static int cs5529_do_conversion(struct comedi_device * dev, unsigned short *data);
+static int cs5529_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 #ifdef NI_CS5529_DEBUG
-static unsigned int cs5529_config_read(comedi_device * dev,
+static unsigned int cs5529_config_read(struct comedi_device * dev,
 	unsigned int reg_select_bits);
 #endif
-static void cs5529_config_write(comedi_device * dev, unsigned int value,
+static void cs5529_config_write(struct comedi_device * dev, unsigned int value,
 	unsigned int reg_select_bits);
 
-static int ni_m_series_pwm_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_m_series_pwm_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ni_6143_pwm_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_6143_pwm_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
-static int ni_set_master_clock(comedi_device * dev, unsigned source,
+static int ni_set_master_clock(struct comedi_device * dev, unsigned source,
 	unsigned period_ns);
-static void ack_a_interrupt(comedi_device * dev, unsigned short a_status);
-static void ack_b_interrupt(comedi_device * dev, unsigned short b_status);
+static void ack_a_interrupt(struct comedi_device * dev, unsigned short a_status);
+static void ack_b_interrupt(struct comedi_device * dev, unsigned short b_status);
 
 enum aimodes {
 	AIMODE_NONE = 0,
@@ -353,14 +353,14 @@ enum timebase_nanoseconds {
 
 static const int num_adc_stages_611x = 3;
 
-static void handle_a_interrupt(comedi_device * dev, unsigned short status,
+static void handle_a_interrupt(struct comedi_device * dev, unsigned short status,
 	unsigned ai_mite_status);
-static void handle_b_interrupt(comedi_device * dev, unsigned short status,
+static void handle_b_interrupt(struct comedi_device * dev, unsigned short status,
 	unsigned ao_mite_status);
-static void get_last_sample_611x(comedi_device * dev);
-static void get_last_sample_6143(comedi_device * dev);
+static void get_last_sample_611x(struct comedi_device * dev);
+static void get_last_sample_6143(struct comedi_device * dev);
 
-static inline void ni_set_bitfield(comedi_device * dev, int reg,
+static inline void ni_set_bitfield(struct comedi_device * dev, int reg,
 	unsigned bit_mask, unsigned bit_values)
 {
 	unsigned long flags;
@@ -406,12 +406,12 @@ static inline void ni_set_bitfield(comedi_device * dev, int reg,
 }
 
 #ifdef PCIDMA
-static int ni_ai_drain_dma(comedi_device * dev);
+static int ni_ai_drain_dma(struct comedi_device * dev);
 
 /* DMA channel setup */
 
 // negative channel means no channel
-static inline void ni_set_ai_dma_channel(comedi_device * dev, int channel)
+static inline void ni_set_ai_dma_channel(struct comedi_device * dev, int channel)
 {
 	unsigned bitfield;
 
@@ -426,7 +426,7 @@ static inline void ni_set_ai_dma_channel(comedi_device * dev, int channel)
 }
 
 // negative channel means no channel
-static inline void ni_set_ao_dma_channel(comedi_device * dev, int channel)
+static inline void ni_set_ao_dma_channel(struct comedi_device * dev, int channel)
 {
 	unsigned bitfield;
 
@@ -441,7 +441,7 @@ static inline void ni_set_ao_dma_channel(comedi_device * dev, int channel)
 }
 
 // negative mite_channel means no channel
-static inline void ni_set_gpct_dma_channel(comedi_device * dev,
+static inline void ni_set_gpct_dma_channel(struct comedi_device * dev,
 	unsigned gpct_index, int mite_channel)
 {
 	unsigned bitfield;
@@ -456,7 +456,7 @@ static inline void ni_set_gpct_dma_channel(comedi_device * dev,
 }
 
 // negative mite_channel means no channel
-static inline void ni_set_cdo_dma_channel(comedi_device * dev, int mite_channel)
+static inline void ni_set_cdo_dma_channel(struct comedi_device * dev, int mite_channel)
 {
 	unsigned long flags;
 
@@ -475,7 +475,7 @@ static inline void ni_set_cdo_dma_channel(comedi_device * dev, int mite_channel)
 	comedi_spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
 }
 
-static int ni_request_ai_mite_channel(comedi_device * dev)
+static int ni_request_ai_mite_channel(struct comedi_device * dev)
 {
 	unsigned long flags;
 
@@ -496,7 +496,7 @@ static int ni_request_ai_mite_channel(comedi_device * dev)
 	return 0;
 }
 
-static int ni_request_ao_mite_channel(comedi_device * dev)
+static int ni_request_ao_mite_channel(struct comedi_device * dev)
 {
 	unsigned long flags;
 
@@ -517,7 +517,7 @@ static int ni_request_ao_mite_channel(comedi_device * dev)
 	return 0;
 }
 
-static int ni_request_gpct_mite_channel(comedi_device * dev,
+static int ni_request_gpct_mite_channel(struct comedi_device * dev,
 	unsigned gpct_index, enum comedi_io_direction direction)
 {
 	unsigned long flags;
@@ -546,7 +546,7 @@ static int ni_request_gpct_mite_channel(comedi_device * dev,
 
 #endif // PCIDMA
 
-static int ni_request_cdo_mite_channel(comedi_device * dev)
+static int ni_request_cdo_mite_channel(struct comedi_device * dev)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -569,7 +569,7 @@ static int ni_request_cdo_mite_channel(comedi_device * dev)
 	return 0;
 }
 
-static void ni_release_ai_mite_channel(comedi_device * dev)
+static void ni_release_ai_mite_channel(struct comedi_device * dev)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -584,7 +584,7 @@ static void ni_release_ai_mite_channel(comedi_device * dev)
 #endif // PCIDMA
 }
 
-static void ni_release_ao_mite_channel(comedi_device * dev)
+static void ni_release_ao_mite_channel(struct comedi_device * dev)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -599,7 +599,7 @@ static void ni_release_ao_mite_channel(comedi_device * dev)
 #endif // PCIDMA
 }
 
-void ni_release_gpct_mite_channel(comedi_device * dev, unsigned gpct_index)
+void ni_release_gpct_mite_channel(struct comedi_device * dev, unsigned gpct_index)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -619,7 +619,7 @@ void ni_release_gpct_mite_channel(comedi_device * dev, unsigned gpct_index)
 #endif // PCIDMA
 }
 
-static void ni_release_cdo_mite_channel(comedi_device * dev)
+static void ni_release_cdo_mite_channel(struct comedi_device * dev)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -636,7 +636,7 @@ static void ni_release_cdo_mite_channel(comedi_device * dev)
 
 // e-series boards use the second irq signals to generate dma requests for their counters
 #ifdef PCIDMA
-static void ni_e_series_enable_second_irq(comedi_device * dev,
+static void ni_e_series_enable_second_irq(struct comedi_device * dev,
 	unsigned gpct_index, short enable)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
@@ -667,7 +667,7 @@ static void ni_e_series_enable_second_irq(comedi_device * dev,
 }
 #endif // PCIDMA
 
-static void ni_clear_ai_fifo(comedi_device * dev)
+static void ni_clear_ai_fifo(struct comedi_device * dev)
 {
 	if (boardtype.reg_type == ni_reg_6143) {
 		// Flush the 6143 data FIFO
@@ -693,13 +693,13 @@ static void ni_clear_ai_fifo(comedi_device * dev)
 	}
 }
 
-static void win_out2(comedi_device * dev, uint32_t data, int reg)
+static void win_out2(struct comedi_device * dev, uint32_t data, int reg)
 {
 	devpriv->stc_writew(dev, data >> 16, reg);
 	devpriv->stc_writew(dev, data & 0xffff, reg + 1);
 }
 
-static uint32_t win_in2(comedi_device * dev, int reg)
+static uint32_t win_in2(struct comedi_device * dev, int reg)
 {
 	uint32_t bits;
 	bits = devpriv->stc_readw(dev, reg) << 16;
@@ -708,7 +708,7 @@ static uint32_t win_in2(comedi_device * dev, int reg)
 }
 
 #define ao_win_out(data,addr) ni_ao_win_outw(dev,data,addr)
-static inline void ni_ao_win_outw(comedi_device * dev, uint16_t data, int addr)
+static inline void ni_ao_win_outw(struct comedi_device * dev, uint16_t data, int addr)
 {
 	unsigned long flags;
 
@@ -718,7 +718,7 @@ static inline void ni_ao_win_outw(comedi_device * dev, uint16_t data, int addr)
 	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
-static inline void ni_ao_win_outl(comedi_device * dev, uint32_t data, int addr)
+static inline void ni_ao_win_outl(struct comedi_device * dev, uint32_t data, int addr)
 {
 	unsigned long flags;
 
@@ -728,7 +728,7 @@ static inline void ni_ao_win_outl(comedi_device * dev, uint32_t data, int addr)
 	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
-static inline unsigned short ni_ao_win_inw(comedi_device * dev, int addr)
+static inline unsigned short ni_ao_win_inw(struct comedi_device * dev, int addr)
 {
 	unsigned long flags;
 	unsigned short data;
@@ -750,7 +750,7 @@ static inline unsigned short ni_ao_win_inw(comedi_device * dev, int addr)
 *
 * value should only be 1 or 0.
 */
-static inline void ni_set_bits(comedi_device * dev, int reg, unsigned bits,
+static inline void ni_set_bits(struct comedi_device * dev, int reg, unsigned bits,
 	unsigned value)
 {
 	unsigned bit_values;
@@ -764,7 +764,7 @@ static inline void ni_set_bits(comedi_device * dev, int reg, unsigned bits,
 
 static irqreturn_t ni_E_interrupt(int irq, void *d PT_REGS_ARG)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	unsigned short a_status;
 	unsigned short b_status;
 	unsigned int ai_mite_status = 0;
@@ -823,7 +823,7 @@ static irqreturn_t ni_E_interrupt(int irq, void *d PT_REGS_ARG)
 }
 
 #ifdef PCIDMA
-static void ni_sync_ai_dma(comedi_device * dev)
+static void ni_sync_ai_dma(struct comedi_device * dev)
 {
 	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	unsigned long flags;
@@ -834,7 +834,7 @@ static void ni_sync_ai_dma(comedi_device * dev)
 	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
-static void mite_handle_b_linkc(struct mite_struct *mite, comedi_device * dev)
+static void mite_handle_b_linkc(struct mite_struct *mite, struct comedi_device * dev)
 {
 	comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	unsigned long flags;
@@ -846,7 +846,7 @@ static void mite_handle_b_linkc(struct mite_struct *mite, comedi_device * dev)
 	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
-static int ni_ao_wait_for_dma_load(comedi_device * dev)
+static int ni_ao_wait_for_dma_load(struct comedi_device * dev)
 {
 	static const int timeout = 10000;
 	int i;
@@ -868,7 +868,7 @@ static int ni_ao_wait_for_dma_load(comedi_device * dev)
 }
 
 #endif //PCIDMA
-static void ni_handle_eos(comedi_device * dev, comedi_subdevice * s)
+static void ni_handle_eos(struct comedi_device * dev, comedi_subdevice * s)
 {
 	if (devpriv->aimode == AIMODE_SCAN) {
 #ifdef PCIDMA
@@ -892,7 +892,7 @@ static void ni_handle_eos(comedi_device * dev, comedi_subdevice * s)
 	}
 }
 
-static void shutdown_ai_command(comedi_device * dev)
+static void shutdown_ai_command(struct comedi_device * dev)
 {
 	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 
@@ -906,7 +906,7 @@ static void shutdown_ai_command(comedi_device * dev)
 	s->async->events |= COMEDI_CB_EOA;
 }
 
-static void ni_event(comedi_device * dev, comedi_subdevice * s)
+static void ni_event(struct comedi_device * dev, comedi_subdevice * s)
 {
 	if (s->async->
 		events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW | COMEDI_CB_EOA))
@@ -932,7 +932,7 @@ static void ni_event(comedi_device * dev, comedi_subdevice * s)
 	comedi_event(dev, s);
 }
 
-static void handle_gpct_interrupt(comedi_device * dev,
+static void handle_gpct_interrupt(struct comedi_device * dev,
 	unsigned short counter_index)
 {
 #ifdef PCIDMA
@@ -945,7 +945,7 @@ static void handle_gpct_interrupt(comedi_device * dev,
 #endif
 }
 
-static void ack_a_interrupt(comedi_device * dev, unsigned short a_status)
+static void ack_a_interrupt(struct comedi_device * dev, unsigned short a_status)
 {
 	unsigned short ack = 0;
 
@@ -966,7 +966,7 @@ static void ack_a_interrupt(comedi_device * dev, unsigned short a_status)
 		devpriv->stc_writew(dev, ack, Interrupt_A_Ack_Register);
 }
 
-static void handle_a_interrupt(comedi_device * dev, unsigned short status,
+static void handle_a_interrupt(struct comedi_device * dev, unsigned short status,
 	unsigned ai_mite_status)
 {
 	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
@@ -1070,7 +1070,7 @@ static void handle_a_interrupt(comedi_device * dev, unsigned short status,
 #endif
 }
 
-static void ack_b_interrupt(comedi_device * dev, unsigned short b_status)
+static void ack_b_interrupt(struct comedi_device * dev, unsigned short b_status)
 {
 	unsigned short ack = 0;
 	if (b_status & AO_BC_TC_St) {
@@ -1098,7 +1098,7 @@ static void ack_b_interrupt(comedi_device * dev, unsigned short b_status)
 		devpriv->stc_writew(dev, ack, Interrupt_B_Ack_Register);
 }
 
-static void handle_b_interrupt(comedi_device * dev, unsigned short b_status,
+static void handle_b_interrupt(struct comedi_device * dev, unsigned short b_status,
 	unsigned ao_mite_status)
 {
 	comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
@@ -1204,7 +1204,7 @@ static void ni_mio_print_status_b(int status)
 
 #ifndef PCIDMA
 
-static void ni_ao_fifo_load(comedi_device * dev, comedi_subdevice * s, int n)
+static void ni_ao_fifo_load(struct comedi_device * dev, comedi_subdevice * s, int n)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -1263,7 +1263,7 @@ static void ni_ao_fifo_load(comedi_device * dev, comedi_subdevice * s, int n)
  *  RT code, as RT code might purposely be running close to the
  *  metal.  Needs to be fixed eventually.
  */
-static int ni_ao_fifo_half_empty(comedi_device * dev, comedi_subdevice * s)
+static int ni_ao_fifo_half_empty(struct comedi_device * dev, comedi_subdevice * s)
 {
 	int n;
 
@@ -1284,7 +1284,7 @@ static int ni_ao_fifo_half_empty(comedi_device * dev, comedi_subdevice * s)
 	return 1;
 }
 
-static int ni_ao_prep_fifo(comedi_device * dev, comedi_subdevice * s)
+static int ni_ao_prep_fifo(struct comedi_device * dev, comedi_subdevice * s)
 {
 	int n;
 
@@ -1307,7 +1307,7 @@ static int ni_ao_prep_fifo(comedi_device * dev, comedi_subdevice * s)
 	return n;
 }
 
-static void ni_ai_fifo_read(comedi_device * dev, comedi_subdevice * s, int n)
+static void ni_ai_fifo_read(struct comedi_device * dev, comedi_subdevice * s, int n)
 {
 	comedi_async *async = s->async;
 	int i;
@@ -1364,7 +1364,7 @@ static void ni_ai_fifo_read(comedi_device * dev, comedi_subdevice * s, int n)
 	}
 }
 
-static void ni_handle_fifo_half_full(comedi_device * dev)
+static void ni_handle_fifo_half_full(struct comedi_device * dev)
 {
 	int n;
 	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
@@ -1376,7 +1376,7 @@ static void ni_handle_fifo_half_full(comedi_device * dev)
 #endif
 
 #ifdef PCIDMA
-static int ni_ai_drain_dma(comedi_device * dev)
+static int ni_ai_drain_dma(struct comedi_device * dev)
 {
 	int i;
 	static const int timeout = 10000;
@@ -1414,7 +1414,7 @@ static int ni_ai_drain_dma(comedi_device * dev)
 /*
    Empties the AI fifo
 */
-static void ni_handle_fifo_dregs(comedi_device * dev)
+static void ni_handle_fifo_dregs(struct comedi_device * dev)
 {
 	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	short data[2];
@@ -1476,7 +1476,7 @@ static void ni_handle_fifo_dregs(comedi_device * dev)
 	}
 }
 
-static void get_last_sample_611x(comedi_device * dev)
+static void get_last_sample_611x(struct comedi_device * dev)
 {
 	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	short data;
@@ -1493,7 +1493,7 @@ static void get_last_sample_611x(comedi_device * dev)
 	}
 }
 
-static void get_last_sample_6143(comedi_device * dev)
+static void get_last_sample_6143(struct comedi_device * dev)
 {
 	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	short data;
@@ -1513,7 +1513,7 @@ static void get_last_sample_6143(comedi_device * dev)
 	}
 }
 
-static void ni_ai_munge(comedi_device * dev, comedi_subdevice * s,
+static void ni_ai_munge(struct comedi_device * dev, comedi_subdevice * s,
 	void *data, unsigned int num_bytes, unsigned int chan_index)
 {
 	comedi_async *async = s->async;
@@ -1539,7 +1539,7 @@ static void ni_ai_munge(comedi_device * dev, comedi_subdevice * s,
 
 #ifdef PCIDMA
 
-static int ni_ai_setup_MITE_dma(comedi_device * dev)
+static int ni_ai_setup_MITE_dma(struct comedi_device * dev)
 {
 	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	int retval;
@@ -1579,7 +1579,7 @@ static int ni_ai_setup_MITE_dma(comedi_device * dev)
 	return 0;
 }
 
-static int ni_ao_setup_MITE_dma(comedi_device * dev)
+static int ni_ao_setup_MITE_dma(struct comedi_device * dev)
 {
 	comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	int retval;
@@ -1617,7 +1617,7 @@ static int ni_ao_setup_MITE_dma(comedi_device * dev)
    this is pretty harsh for a cancel, but it works...
  */
 
-static int ni_ai_reset(comedi_device * dev, comedi_subdevice * s)
+static int ni_ai_reset(struct comedi_device * dev, comedi_subdevice * s)
 {
 	ni_release_ai_mite_channel(dev);
 	/* ai configuration */
@@ -1698,7 +1698,7 @@ static int ni_ai_reset(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int ni_ai_poll(comedi_device * dev, comedi_subdevice * s)
+static int ni_ai_poll(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long flags = 0;
 	int count;
@@ -1718,7 +1718,7 @@ static int ni_ai_poll(comedi_device * dev, comedi_subdevice * s)
 	return count;
 }
 
-static int ni_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int ni_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
@@ -1814,7 +1814,7 @@ static int ni_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
 	return insn->n;
 }
 
-void ni_prime_channelgain_list(comedi_device * dev)
+void ni_prime_channelgain_list(struct comedi_device * dev)
 {
 	int i;
 	devpriv->stc_writew(dev, AI_CONVERT_Pulse, AI_Command_1_Register);
@@ -1830,7 +1830,7 @@ void ni_prime_channelgain_list(comedi_device * dev)
 	rt_printk("ni_mio_common: timeout loading channel/gain list\n");
 }
 
-static void ni_m_series_load_channelgain_list(comedi_device * dev,
+static void ni_m_series_load_channelgain_list(struct comedi_device * dev,
 	unsigned int n_chan, unsigned int *list)
 {
 	unsigned int chan, range, aref;
@@ -1935,7 +1935,7 @@ static void ni_m_series_load_channelgain_list(comedi_device * dev,
  *   bits 0-2: channel
  *       valid channels are 0-3
  */
-static void ni_load_channelgain_list(comedi_device * dev, unsigned int n_chan,
+static void ni_load_channelgain_list(struct comedi_device * dev, unsigned int n_chan,
 	unsigned int *list)
 {
 	unsigned int chan, range, aref;
@@ -2055,7 +2055,7 @@ static void ni_load_channelgain_list(comedi_device * dev, unsigned int n_chan,
 	}
 }
 
-static int ni_ns_to_timer(const comedi_device * dev, unsigned nanosec,
+static int ni_ns_to_timer(const struct comedi_device * dev, unsigned nanosec,
 	int round_mode)
 {
 	int divider;
@@ -2074,12 +2074,12 @@ static int ni_ns_to_timer(const comedi_device * dev, unsigned nanosec,
 	return divider - 1;
 }
 
-static unsigned ni_timer_to_ns(const comedi_device * dev, int timer)
+static unsigned ni_timer_to_ns(const struct comedi_device * dev, int timer)
 {
 	return devpriv->clock_ns * (timer + 1);
 }
 
-static unsigned ni_min_ai_scan_period_ns(comedi_device * dev,
+static unsigned ni_min_ai_scan_period_ns(struct comedi_device * dev,
 	unsigned num_channels)
 {
 	switch (boardtype.reg_type) {
@@ -2095,7 +2095,7 @@ static unsigned ni_min_ai_scan_period_ns(comedi_device * dev,
 	return boardtype.ai_speed * num_channels;
 }
 
-static int ni_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int ni_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -2308,7 +2308,7 @@ static int ni_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int ni_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int ni_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	const comedi_cmd *cmd = &s->async->cmd;
 	int timer;
@@ -2612,7 +2612,7 @@ static int ni_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int ni_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int ni_ai_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trignum)
 {
 	if (trignum != 0)
@@ -2625,10 +2625,10 @@ static int ni_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ni_ai_config_analog_trig(comedi_device * dev, comedi_subdevice * s,
+static int ni_ai_config_analog_trig(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
-static int ni_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_ai_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n < 1)
@@ -2679,7 +2679,7 @@ static int ni_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
 	return -EINVAL;
 }
 
-static int ni_ai_config_analog_trig(comedi_device * dev, comedi_subdevice * s,
+static int ni_ai_config_analog_trig(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int a, b, modebits;
@@ -2777,7 +2777,7 @@ static int ni_ai_config_analog_trig(comedi_device * dev, comedi_subdevice * s,
 }
 
 /* munge data from unsigned to 2's complement for analog output bipolar modes */
-static void ni_ao_munge(comedi_device * dev, comedi_subdevice * s,
+static void ni_ao_munge(struct comedi_device * dev, comedi_subdevice * s,
 	void *data, unsigned int num_bytes, unsigned int chan_index)
 {
 	comedi_async *async = s->async;
@@ -2800,7 +2800,7 @@ static void ni_ao_munge(comedi_device * dev, comedi_subdevice * s,
 	}
 }
 
-static int ni_m_series_ao_config_chanlist(comedi_device * dev,
+static int ni_m_series_ao_config_chanlist(struct comedi_device * dev,
 	comedi_subdevice * s, unsigned int chanspec[], unsigned int n_chans,
 	int timed)
 {
@@ -2869,7 +2869,7 @@ static int ni_m_series_ao_config_chanlist(comedi_device * dev,
 	return invert;
 }
 
-static int ni_old_ao_config_chanlist(comedi_device * dev, comedi_subdevice * s,
+static int ni_old_ao_config_chanlist(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int chanspec[], unsigned int n_chans)
 {
 	unsigned int range;
@@ -2912,7 +2912,7 @@ static int ni_old_ao_config_chanlist(comedi_device * dev, comedi_subdevice * s,
 	return invert;
 }
 
-static int ni_ao_config_chanlist(comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_config_chanlist(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int chanspec[], unsigned int n_chans, int timed)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
@@ -2921,7 +2921,7 @@ static int ni_ao_config_chanlist(comedi_device * dev, comedi_subdevice * s,
 	else
 		return ni_old_ao_config_chanlist(dev, s, chanspec, n_chans);
 }
-static int ni_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
@@ -2929,7 +2929,7 @@ static int ni_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ni_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
@@ -2948,7 +2948,7 @@ static int ni_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ni_ao_insn_write_671x(comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_insn_write_671x(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
@@ -2965,7 +2965,7 @@ static int ni_ao_insn_write_671x(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ni_ao_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
@@ -2991,7 +2991,7 @@ static int ni_ao_insn_config(comedi_device * dev, comedi_subdevice * s,
 	return -EINVAL;
 }
 
-static int ni_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trignum)
 {
 	int ret;
@@ -3062,7 +3062,7 @@ static int ni_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int ni_ao_cmd(comedi_device * dev, comedi_subdevice * s)
+static int ni_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	const comedi_cmd *cmd = &s->async->cmd;
 	int bits;
@@ -3261,7 +3261,7 @@ static int ni_ao_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int ni_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int ni_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -3384,7 +3384,7 @@ static int ni_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int ni_ao_reset(comedi_device * dev, comedi_subdevice * s)
+static int ni_ao_reset(struct comedi_device * dev, comedi_subdevice * s)
 {
 	//devpriv->ao0p=0x0000;
 	//ni_writew(devpriv->ao0p,AO_Configuration);
@@ -3436,7 +3436,7 @@ static int ni_ao_reset(comedi_device * dev, comedi_subdevice * s)
 
 // digital io
 
-static int ni_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
@@ -3468,7 +3468,7 @@ static int ni_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ni_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int ni_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
@@ -3495,7 +3495,7 @@ static int ni_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int ni_m_series_dio_insn_config(comedi_device * dev,
+static int ni_m_series_dio_insn_config(struct comedi_device * dev,
 	comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
@@ -3525,7 +3525,7 @@ static int ni_m_series_dio_insn_config(comedi_device * dev,
 	return 1;
 }
 
-static int ni_m_series_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int ni_m_series_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
@@ -3544,7 +3544,7 @@ static int ni_m_series_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int ni_cdio_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int ni_cdio_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -3653,7 +3653,7 @@ static int ni_cdio_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int ni_cdio_cmd(comedi_device * dev, comedi_subdevice * s)
+static int ni_cdio_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	const comedi_cmd *cmd = &s->async->cmd;
 	unsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;
@@ -3690,7 +3690,7 @@ static int ni_cdio_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int ni_cdo_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int ni_cdo_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trignum)
 {
 #ifdef PCIDMA
@@ -3736,7 +3736,7 @@ static int ni_cdo_inttrig(comedi_device * dev, comedi_subdevice * s,
 	return retval;
 }
 
-static int ni_cdio_cancel(comedi_device * dev, comedi_subdevice * s)
+static int ni_cdio_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	ni_writel(CDO_Disarm_Bit | CDO_Error_Interrupt_Enable_Clear_Bit |
 		CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
@@ -3749,7 +3749,7 @@ static int ni_cdio_cancel(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static void handle_cdio_interrupt(comedi_device * dev)
+static void handle_cdio_interrupt(struct comedi_device * dev)
 {
 	unsigned cdio_status;
 	comedi_subdevice *s = dev->subdevices + NI_DIO_SUBDEV;
@@ -3790,7 +3790,7 @@ static void handle_cdio_interrupt(comedi_device * dev)
 	ni_event(dev, s);
 }
 
-static int ni_serial_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_serial_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int err = insn->n;
@@ -3884,7 +3884,7 @@ static int ni_serial_insn_config(comedi_device * dev, comedi_subdevice * s,
 
 }
 
-static int ni_serial_hw_readwrite8(comedi_device * dev, comedi_subdevice * s,
+static int ni_serial_hw_readwrite8(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned char data_out, unsigned char *data_in)
 {
 	unsigned int status1;
@@ -3940,7 +3940,7 @@ static int ni_serial_hw_readwrite8(comedi_device * dev, comedi_subdevice * s,
 	return err;
 }
 
-static int ni_serial_sw_readwrite8(comedi_device * dev, comedi_subdevice * s,
+static int ni_serial_sw_readwrite8(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned char data_out, unsigned char *data_in)
 {
 	unsigned char mask, input = 0;
@@ -3993,7 +3993,7 @@ static int ni_serial_sw_readwrite8(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static void mio_common_detach(comedi_device * dev)
+static void mio_common_detach(struct comedi_device * dev)
 {
 	if (dev->private) {
 		if (devpriv->counter_dev) {
@@ -4004,7 +4004,7 @@ static void mio_common_detach(comedi_device * dev)
 		subdev_8255_cleanup(dev, dev->subdevices + NI_8255_DIO_SUBDEV);
 }
 
-static void init_ao_67xx(comedi_device * dev, comedi_subdevice * s)
+static void init_ao_67xx(struct comedi_device * dev, comedi_subdevice * s)
 {
 	int i;
 
@@ -4111,7 +4111,7 @@ static unsigned ni_gpct_to_stc_register(enum ni_gpct_register reg)
 static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 	enum ni_gpct_register reg)
 {
-	comedi_device *dev = counter->counter_dev->dev;
+	struct comedi_device *dev = counter->counter_dev->dev;
 	unsigned stc_register;
 	/* bits in the join reset register which are relevant to counters */
 	static const unsigned gpct_joint_reset_mask = G0_Reset | G1_Reset;
@@ -4179,7 +4179,7 @@ static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
 static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 	enum ni_gpct_register reg)
 {
-	comedi_device *dev = counter->counter_dev->dev;
+	struct comedi_device *dev = counter->counter_dev->dev;
 	unsigned stc_register;
 	switch (reg) {
 		/* m-series only registers */
@@ -4208,14 +4208,14 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 	return 0;
 }
 
-static int ni_freq_out_insn_read(comedi_device * dev,
+static int ni_freq_out_insn_read(struct comedi_device * dev,
 	comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->clock_and_fout & FOUT_Divider_mask;
 	return 1;
 }
 
-static int ni_freq_out_insn_write(comedi_device * dev,
+static int ni_freq_out_insn_write(struct comedi_device * dev,
 	comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
 {
 	devpriv->clock_and_fout &= ~FOUT_Enable;
@@ -4229,7 +4229,7 @@ static int ni_freq_out_insn_write(comedi_device * dev,
 	return insn->n;
 }
 
-static int ni_set_freq_out_clock(comedi_device * dev, unsigned int clock_source)
+static int ni_set_freq_out_clock(struct comedi_device * dev, unsigned int clock_source)
 {
 	switch (clock_source) {
 	case NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC:
@@ -4246,7 +4246,7 @@ static int ni_set_freq_out_clock(comedi_device * dev, unsigned int clock_source)
 	return 3;
 }
 
-static void ni_get_freq_out_clock(comedi_device * dev, unsigned int * clock_source,
+static void ni_get_freq_out_clock(struct comedi_device * dev, unsigned int * clock_source,
 	unsigned int * clock_period_ns)
 {
 	if (devpriv->clock_and_fout & FOUT_Timebase_Select) {
@@ -4258,7 +4258,7 @@ static void ni_get_freq_out_clock(comedi_device * dev, unsigned int * clock_sour
 	}
 }
 
-static int ni_freq_out_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_freq_out_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
@@ -4274,7 +4274,7 @@ static int ni_freq_out_insn_config(comedi_device * dev, comedi_subdevice * s,
 	return -EINVAL;
 }
 
-static int ni_alloc_private(comedi_device * dev)
+static int ni_alloc_private(struct comedi_device * dev)
 {
 	int ret;
 
@@ -4289,7 +4289,7 @@ static int ni_alloc_private(comedi_device * dev)
 	return 0;
 };
 
-static int ni_E_init(comedi_device * dev, comedi_devconfig * it)
+static int ni_E_init(struct comedi_device * dev, comedi_devconfig * it)
 {
 	comedi_subdevice *s;
 	unsigned j;
@@ -4609,7 +4609,7 @@ static int ni_E_init(comedi_device * dev, comedi_devconfig * it)
 
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 {
-	comedi_device *dev = (comedi_device *) arg;
+	struct comedi_device *dev = (struct comedi_device *) arg;
 
 	if (dir) {
 		ni_writeb(data, Port_A + 2 * port);
@@ -4623,7 +4623,7 @@ static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 	presents the EEPROM as a subdevice
 */
 
-static int ni_eeprom_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int ni_eeprom_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));
@@ -4635,7 +4635,7 @@ static int ni_eeprom_insn_read(comedi_device * dev, comedi_subdevice * s,
 	reads bytes out of eeprom
 */
 
-static int ni_read_eeprom(comedi_device * dev, int addr)
+static int ni_read_eeprom(struct comedi_device * dev, int addr)
 {
 	int bit;
 	int bitstring;
@@ -4659,7 +4659,7 @@ static int ni_read_eeprom(comedi_device * dev, int addr)
 	return bitstring;
 }
 
-static int ni_m_series_eeprom_insn_read(comedi_device * dev,
+static int ni_m_series_eeprom_insn_read(struct comedi_device * dev,
 	comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];
@@ -4667,14 +4667,14 @@ static int ni_m_series_eeprom_insn_read(comedi_device * dev,
 	return 1;
 }
 
-static int ni_get_pwm_config(comedi_device * dev, unsigned int * data)
+static int ni_get_pwm_config(struct comedi_device * dev, unsigned int * data)
 {
 	data[1] = devpriv->pwm_up_count * devpriv->clock_ns;
 	data[2] = devpriv->pwm_down_count * devpriv->clock_ns;
 	return 3;
 }
 
-static int ni_m_series_pwm_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_m_series_pwm_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned up_count, down_count;
@@ -4739,7 +4739,7 @@ static int ni_m_series_pwm_config(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int ni_6143_pwm_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_6143_pwm_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned up_count, down_count;
@@ -4802,11 +4802,11 @@ static int ni_6143_pwm_config(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static void ni_write_caldac(comedi_device * dev, int addr, int val);
+static void ni_write_caldac(struct comedi_device * dev, int addr, int val);
 /*
 	calibration subdevice
 */
-static int ni_calib_insn_write(comedi_device * dev, comedi_subdevice * s,
+static int ni_calib_insn_write(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	ni_write_caldac(dev, CR_CHAN(insn->chanspec), data[0]);
@@ -4814,7 +4814,7 @@ static int ni_calib_insn_write(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ni_calib_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int ni_calib_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];
@@ -4845,7 +4845,7 @@ static struct caldac_struct caldacs[] = {
 	[ad8804_debug] = {16, 8, pack_ad8804},
 };
 
-static void caldac_setup(comedi_device * dev, comedi_subdevice * s)
+static void caldac_setup(struct comedi_device * dev, comedi_subdevice * s)
 {
 	int i, j;
 	int n_dacs;
@@ -4898,7 +4898,7 @@ static void caldac_setup(comedi_device * dev, comedi_subdevice * s)
 	}
 }
 
-static void ni_write_caldac(comedi_device * dev, int addr, int val)
+static void ni_write_caldac(struct comedi_device * dev, int addr, int val)
 {
 	unsigned int loadbit = 0, bits = 0, bit, bitstring = 0;
 	int i;
@@ -4985,7 +4985,7 @@ static int pack_ad8842(int addr, int val, int *bitstring)
 /*
  *	Read the GPCTs current value.
  */
-static int GPCT_G_Watch(comedi_device * dev, int chan)
+static int GPCT_G_Watch(struct comedi_device * dev, int chan)
 {
 	unsigned int hi1, hi2, lo;
 
@@ -5008,7 +5008,7 @@ static int GPCT_G_Watch(comedi_device * dev, int chan)
 	return (hi1 << 16) | lo;
 }
 
-static void GPCT_Reset(comedi_device * dev, int chan)
+static void GPCT_Reset(struct comedi_device * dev, int chan)
 {
 	int temp_ack_reg = 0;
 
@@ -5070,28 +5070,28 @@ static void GPCT_Reset(comedi_device * dev, int chan)
 
 #endif
 
-static int ni_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_insn_config(counter, insn, data);
 }
 
-static int ni_gpct_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_rinsn(counter, insn, data);
 }
 
-static int ni_gpct_insn_write(comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_insn_write(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_winsn(counter, insn, data);
 }
 
-static int ni_gpct_cmd(comedi_device * dev, comedi_subdevice * s)
+static int ni_gpct_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	int retval;
 #ifdef PCIDMA
@@ -5114,7 +5114,7 @@ static int ni_gpct_cmd(comedi_device * dev, comedi_subdevice * s)
 	return retval;
 }
 
-static int ni_gpct_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int ni_gpct_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 #ifdef PCIDMA
@@ -5126,7 +5126,7 @@ static int ni_gpct_cmdtest(comedi_device * dev, comedi_subdevice * s,
 #endif
 }
 
-static int ni_gpct_cancel(comedi_device * dev, comedi_subdevice * s)
+static int ni_gpct_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 #ifdef PCIDMA
 	struct ni_gpct *counter = s->private;
@@ -5147,7 +5147,7 @@ static int ni_gpct_cancel(comedi_device * dev, comedi_subdevice * s)
  *
  */
 
-static int ni_m_series_set_pfi_routing(comedi_device * dev, unsigned chan,
+static int ni_m_series_set_pfi_routing(struct comedi_device * dev, unsigned chan,
 	unsigned source)
 {
 	unsigned pfi_reg_index;
@@ -5165,7 +5165,7 @@ static int ni_m_series_set_pfi_routing(comedi_device * dev, unsigned chan,
 	return 2;
 }
 
-static int ni_old_set_pfi_routing(comedi_device * dev, unsigned chan,
+static int ni_old_set_pfi_routing(struct comedi_device * dev, unsigned chan,
 	unsigned source)
 {
 	// pre-m-series boards have fixed signals on pfi pins
@@ -5174,7 +5174,7 @@ static int ni_old_set_pfi_routing(comedi_device * dev, unsigned chan,
 	return 2;
 }
 
-static int ni_set_pfi_routing(comedi_device * dev, unsigned chan,
+static int ni_set_pfi_routing(struct comedi_device * dev, unsigned chan,
 	unsigned source)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
@@ -5183,14 +5183,14 @@ static int ni_set_pfi_routing(comedi_device * dev, unsigned chan,
 		return ni_old_set_pfi_routing(dev, chan, source);
 }
 
-static unsigned ni_m_series_get_pfi_routing(comedi_device * dev, unsigned chan)
+static unsigned ni_m_series_get_pfi_routing(struct comedi_device * dev, unsigned chan)
 {
 	const unsigned array_offset = chan / 3;
 	return MSeries_PFI_Output_Select_Source(chan,
 		devpriv->pfi_output_select_reg[array_offset]);
 }
 
-static unsigned ni_old_get_pfi_routing(comedi_device * dev, unsigned chan)
+static unsigned ni_old_get_pfi_routing(struct comedi_device * dev, unsigned chan)
 {
 	// pre-m-series boards have fixed signals on pfi pins
 	switch (chan) {
@@ -5231,7 +5231,7 @@ static unsigned ni_old_get_pfi_routing(comedi_device * dev, unsigned chan)
 	return 0;
 }
 
-static unsigned ni_get_pfi_routing(comedi_device * dev, unsigned chan)
+static unsigned ni_get_pfi_routing(struct comedi_device * dev, unsigned chan)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
 		return ni_m_series_get_pfi_routing(dev, chan);
@@ -5239,7 +5239,7 @@ static unsigned ni_get_pfi_routing(comedi_device * dev, unsigned chan)
 		return ni_old_get_pfi_routing(dev, chan);
 }
 
-static int ni_config_filter(comedi_device * dev, unsigned pfi_channel,
+static int ni_config_filter(struct comedi_device * dev, unsigned pfi_channel,
 	enum ni_pfi_filter_select filter)
 {
 	unsigned bits;
@@ -5253,7 +5253,7 @@ static int ni_config_filter(comedi_device * dev, unsigned pfi_channel,
 	return 0;
 }
 
-static int ni_pfi_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int ni_pfi_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
@@ -5268,7 +5268,7 @@ static int ni_pfi_insn_bits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int ni_pfi_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_pfi_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan;
@@ -5312,7 +5312,7 @@ static int ni_pfi_insn_config(comedi_device * dev, comedi_subdevice * s,
  *  NI RTSI Bus Functions
  *
  */
-static void ni_rtsi_init(comedi_device * dev)
+static void ni_rtsi_init(struct comedi_device * dev)
 {
 	// Initialises the RTSI bus signal switch to a default state
 
@@ -5345,7 +5345,7 @@ static void ni_rtsi_init(comedi_device * dev)
 //      devpriv->stc_writew(dev, 0x0000, RTSI_Board_Register);
 }
 
-static int ni_rtsi_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int ni_rtsi_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
@@ -5401,7 +5401,7 @@ static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
 	return 0;
 }
 
-static inline unsigned num_configurable_rtsi_channels(comedi_device * dev)
+static inline unsigned num_configurable_rtsi_channels(struct comedi_device * dev)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
 		return 8;
@@ -5409,7 +5409,7 @@ static inline unsigned num_configurable_rtsi_channels(comedi_device * dev)
 		return 7;
 }
 
-static int ni_mseries_set_pll_master_clock(comedi_device * dev, unsigned source,
+static int ni_mseries_set_pll_master_clock(struct comedi_device * dev, unsigned source,
 	unsigned period_ns)
 {
 	static const unsigned min_period_ns = 50;
@@ -5504,7 +5504,7 @@ static int ni_mseries_set_pll_master_clock(comedi_device * dev, unsigned source,
 	return 3;
 }
 
-static int ni_set_master_clock(comedi_device * dev, unsigned source,
+static int ni_set_master_clock(struct comedi_device * dev, unsigned source,
 	unsigned period_ns)
 {
 	if (source == NI_MIO_INTERNAL_CLOCK) {
@@ -5548,7 +5548,7 @@ static int ni_set_master_clock(comedi_device * dev, unsigned source,
 	return 3;
 }
 
-static int ni_valid_rtsi_output_source(comedi_device * dev, unsigned chan,
+static int ni_valid_rtsi_output_source(struct comedi_device * dev, unsigned chan,
 	unsigned source)
 {
 	if (chan >= num_configurable_rtsi_channels(dev)) {
@@ -5589,7 +5589,7 @@ static int ni_valid_rtsi_output_source(comedi_device * dev, unsigned chan,
 	}
 }
 
-static int ni_set_rtsi_routing(comedi_device * dev, unsigned chan,
+static int ni_set_rtsi_routing(struct comedi_device * dev, unsigned chan,
 	unsigned source)
 {
 	if (ni_valid_rtsi_output_source(dev, chan, source) == 0)
@@ -5610,7 +5610,7 @@ static int ni_set_rtsi_routing(comedi_device * dev, unsigned chan,
 	return 2;
 }
 
-static unsigned ni_get_rtsi_routing(comedi_device * dev, unsigned chan)
+static unsigned ni_get_rtsi_routing(struct comedi_device * dev, unsigned chan)
 {
 	if (chan < 4) {
 		return RTSI_Trig_Output_Source(chan,
@@ -5626,7 +5626,7 @@ static unsigned ni_get_rtsi_routing(comedi_device * dev, unsigned chan)
 	}
 }
 
-static int ni_rtsi_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int ni_rtsi_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
@@ -5698,7 +5698,7 @@ static int ni_rtsi_insn_config(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int cs5529_wait_for_idle(comedi_device * dev)
+static int cs5529_wait_for_idle(struct comedi_device * dev)
 {
 	unsigned short status;
 	const int timeout = HZ;
@@ -5722,7 +5722,7 @@ static int cs5529_wait_for_idle(comedi_device * dev)
 	return 0;
 }
 
-static void cs5529_command(comedi_device * dev, unsigned short value)
+static void cs5529_command(struct comedi_device * dev, unsigned short value)
 {
 	static const int timeout = 100;
 	int i;
@@ -5744,7 +5744,7 @@ static void cs5529_command(comedi_device * dev, unsigned short value)
 }
 
 /* write to cs5529 register */
-static void cs5529_config_write(comedi_device * dev, unsigned int value,
+static void cs5529_config_write(struct comedi_device * dev, unsigned int value,
 	unsigned int reg_select_bits)
 {
 	ni_ao_win_outw(dev, ((value >> 16) & 0xff),
@@ -5759,7 +5759,7 @@ static void cs5529_config_write(comedi_device * dev, unsigned int value,
 
 #ifdef NI_CS5529_DEBUG
 /* read from cs5529 register */
-static unsigned int cs5529_config_read(comedi_device * dev,
+static unsigned int cs5529_config_read(struct comedi_device * dev,
 	unsigned int reg_select_bits)
 {
 	unsigned int value;
@@ -5775,7 +5775,7 @@ static unsigned int cs5529_config_read(comedi_device * dev,
 }
 #endif
 
-static int cs5529_do_conversion(comedi_device * dev, unsigned short *data)
+static int cs5529_do_conversion(struct comedi_device * dev, unsigned short *data)
 {
 	int retval;
 	unsigned short status;
@@ -5805,7 +5805,7 @@ static int cs5529_do_conversion(comedi_device * dev, unsigned short *data)
 	return 0;
 }
 
-static int cs5529_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int cs5529_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n, retval;
@@ -5831,7 +5831,7 @@ static int cs5529_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
 	return insn->n;
 }
 
-static int init_cs5529(comedi_device * dev)
+static int init_cs5529(struct comedi_device * dev)
 {
 	unsigned int config_bits =
 		CSCFG_PORT_MODE | CSCFG_WORD_RATE_2180_CYCLES;

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 116a9e559659..bb2c378cf68a 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -194,9 +194,9 @@ static const comedi_lrange *const ni_range_lkup[] = {
 };
 
 static int ni_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ni_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ni_cdio_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
 static int ni_cdio_cmd(comedi_device * dev, comedi_subdevice * s);
@@ -206,33 +206,33 @@ static int ni_cdo_inttrig(comedi_device * dev, comedi_subdevice * s,
 	unsigned int trignum);
 
 static int ni_serial_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ni_serial_hw_readwrite8(comedi_device * dev, comedi_subdevice * s,
 	unsigned char data_out, unsigned char *data_in);
 static int ni_serial_sw_readwrite8(comedi_device * dev, comedi_subdevice * s,
 	unsigned char data_out, unsigned char *data_in);
 
 static int ni_calib_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ni_calib_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 
 static int ni_eeprom_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ni_m_series_eeprom_insn_read(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data);
+	comedi_subdevice * s, comedi_insn * insn, unsigned int * data);
 
 static int ni_pfi_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ni_pfi_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static unsigned ni_old_get_pfi_routing(comedi_device * dev, unsigned chan);
 
 static void ni_rtsi_init(comedi_device * dev);
 static int ni_rtsi_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ni_rtsi_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 
 static void caldac_setup(comedi_device * dev, comedi_subdevice * s);
 static int ni_read_eeprom(comedi_device * dev, int addr);
@@ -268,11 +268,11 @@ static int ni_ao_reset(comedi_device * dev, comedi_subdevice * s);
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
 
 static int ni_gpct_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ni_gpct_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ni_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ni_gpct_cmd(comedi_device * dev, comedi_subdevice * s);
 static int ni_gpct_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
@@ -283,7 +283,7 @@ static void handle_gpct_interrupt(comedi_device * dev,
 static int init_cs5529(comedi_device * dev);
 static int cs5529_do_conversion(comedi_device * dev, unsigned short *data);
 static int cs5529_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 #ifdef NI_CS5529_DEBUG
 static unsigned int cs5529_config_read(comedi_device * dev,
 	unsigned int reg_select_bits);
@@ -292,9 +292,9 @@ static void cs5529_config_write(comedi_device * dev, unsigned int value,
 	unsigned int reg_select_bits);
 
 static int ni_m_series_pwm_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ni_6143_pwm_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 
 static int ni_set_master_clock(comedi_device * dev, unsigned source,
 	unsigned period_ns);
@@ -1210,7 +1210,7 @@ static void ni_ao_fifo_load(comedi_device * dev, comedi_subdevice * s, int n)
 	comedi_cmd *cmd = &async->cmd;
 	int chan;
 	int i;
-	sampl_t d;
+	short d;
 	u32 packed_data;
 	int range;
 	int err = 1;
@@ -1273,7 +1273,7 @@ static int ni_ao_fifo_half_empty(comedi_device * dev, comedi_subdevice * s)
 		return 0;
 	}
 
-	n /= sizeof(sampl_t);
+	n /= sizeof(short);
 	if (n > boardtype.ao_fifo_depth / 2)
 		n = boardtype.ao_fifo_depth / 2;
 
@@ -1298,7 +1298,7 @@ static int ni_ao_prep_fifo(comedi_device * dev, comedi_subdevice * s)
 	if (n == 0)
 		return 0;
 
-	n /= sizeof(sampl_t);
+	n /= sizeof(short);
 	if (n > boardtype.ao_fifo_depth)
 		n = boardtype.ao_fifo_depth;
 
@@ -1313,7 +1313,7 @@ static void ni_ai_fifo_read(comedi_device * dev, comedi_subdevice * s, int n)
 	int i;
 
 	if (boardtype.reg_type == ni_reg_611x) {
-		sampl_t data[2];
+		short data[2];
 		u32 dl;
 
 		for (i = 0; i < n / 2; i++) {
@@ -1330,7 +1330,7 @@ static void ni_ai_fifo_read(comedi_device * dev, comedi_subdevice * s, int n)
 			cfc_write_to_buffer(s, data[0]);
 		}
 	} else if (boardtype.reg_type == ni_reg_6143) {
-		sampl_t data[2];
+		short data[2];
 		u32 dl;
 
 		// This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed
@@ -1417,7 +1417,7 @@ static int ni_ai_drain_dma(comedi_device * dev)
 static void ni_handle_fifo_dregs(comedi_device * dev)
 {
 	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
-	sampl_t data[2];
+	short data[2];
 	u32 dl;
 	short fifo_empty;
 	int i;
@@ -1479,7 +1479,7 @@ static void ni_handle_fifo_dregs(comedi_device * dev)
 static void get_last_sample_611x(comedi_device * dev)
 {
 	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
-	sampl_t data;
+	short data;
 	u32 dl;
 
 	if (boardtype.reg_type != ni_reg_611x)
@@ -1496,7 +1496,7 @@ static void get_last_sample_611x(comedi_device * dev)
 static void get_last_sample_6143(comedi_device * dev)
 {
 	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
-	sampl_t data;
+	short data;
 	u32 dl;
 
 	if (boardtype.reg_type != ni_reg_6143)
@@ -1519,8 +1519,8 @@ static void ni_ai_munge(comedi_device * dev, comedi_subdevice * s,
 	comedi_async *async = s->async;
 	unsigned int i;
 	unsigned int length = num_bytes / bytes_per_sample(s);
-	sampl_t *array = data;
-	lsampl_t *larray = data;
+	short *array = data;
+	unsigned int *larray = data;
 	for (i = 0; i < length; i++) {
 #ifdef PCIDMA
 		if (s->subdev_flags & SDF_LSAMPL)
@@ -1719,7 +1719,7 @@ static int ni_ai_poll(comedi_device * dev, comedi_subdevice * s)
 }
 
 static int ni_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
 	const unsigned int mask = (1 << boardtype.adbits) - 1;
@@ -2626,10 +2626,10 @@ static int ni_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ni_ai_config_analog_trig(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 
 static int ni_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n < 1)
 		return -EINVAL;
@@ -2680,7 +2680,7 @@ static int ni_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ni_ai_config_analog_trig(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int a, b, modebits;
 	int err = 0;
@@ -2784,8 +2784,8 @@ static void ni_ao_munge(comedi_device * dev, comedi_subdevice * s,
 	unsigned int range;
 	unsigned int i;
 	unsigned int offset;
-	unsigned int length = num_bytes / sizeof(sampl_t);
-	sampl_t *array = data;
+	unsigned int length = num_bytes / sizeof(short);
+	short *array = data;
 
 	offset = 1 << (boardtype.aobits - 1);
 	for (i = 0; i < length; i++) {
@@ -2922,7 +2922,7 @@ static int ni_ao_config_chanlist(comedi_device * dev, comedi_subdevice * s,
 		return ni_old_ao_config_chanlist(dev, s, chanspec, n_chans);
 }
 static int ni_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
 
@@ -2930,7 +2930,7 @@ static int ni_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ni_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
@@ -2949,7 +2949,7 @@ static int ni_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ni_ao_insn_write_671x(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
@@ -2966,14 +2966,14 @@ static int ni_ao_insn_write_671x(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ni_ao_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
 		switch(data[1])
 		{
 		case COMEDI_OUTPUT:
-			data[2] = 1 + boardtype.ao_fifo_depth * sizeof(sampl_t);
+			data[2] = 1 + boardtype.ao_fifo_depth * sizeof(short);
 			if(devpriv->mite) data[2] += devpriv->mite->fifo_size;
 			break;
 		case COMEDI_INPUT:
@@ -3437,7 +3437,7 @@ static int ni_ao_reset(comedi_device * dev, comedi_subdevice * s)
 // digital io
 
 static int ni_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
 	rt_printk("ni_dio_insn_config() chan=%d io=%d\n",
@@ -3469,7 +3469,7 @@ static int ni_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ni_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
 	rt_printk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);
@@ -3496,7 +3496,7 @@ static int ni_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ni_m_series_dio_insn_config(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+	comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
 	rt_printk("ni_m_series_dio_insn_config() chan=%d io=%d\n",
@@ -3526,7 +3526,7 @@ static int ni_m_series_dio_insn_config(comedi_device * dev,
 }
 
 static int ni_m_series_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 #ifdef DEBUG_DIO
 	rt_printk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],
@@ -3791,7 +3791,7 @@ static void handle_cdio_interrupt(comedi_device * dev)
 }
 
 static int ni_serial_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int err = insn->n;
 	unsigned char byte_out, byte_in = 0;
@@ -4209,14 +4209,14 @@ static unsigned ni_gpct_read_register(struct ni_gpct *counter,
 }
 
 static int ni_freq_out_insn_read(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+	comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->clock_and_fout & FOUT_Divider_mask;
 	return 1;
 }
 
 static int ni_freq_out_insn_write(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+	comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
 {
 	devpriv->clock_and_fout &= ~FOUT_Enable;
 	devpriv->stc_writew(dev, devpriv->clock_and_fout,
@@ -4229,7 +4229,7 @@ static int ni_freq_out_insn_write(comedi_device * dev,
 	return insn->n;
 }
 
-static int ni_set_freq_out_clock(comedi_device * dev, lsampl_t clock_source)
+static int ni_set_freq_out_clock(comedi_device * dev, unsigned int clock_source)
 {
 	switch (clock_source) {
 	case NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC:
@@ -4246,8 +4246,8 @@ static int ni_set_freq_out_clock(comedi_device * dev, lsampl_t clock_source)
 	return 3;
 }
 
-static void ni_get_freq_out_clock(comedi_device * dev, lsampl_t * clock_source,
-	lsampl_t * clock_period_ns)
+static void ni_get_freq_out_clock(comedi_device * dev, unsigned int * clock_source,
+	unsigned int * clock_period_ns)
 {
 	if (devpriv->clock_and_fout & FOUT_Timebase_Select) {
 		*clock_source = NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC;
@@ -4259,7 +4259,7 @@ static void ni_get_freq_out_clock(comedi_device * dev, lsampl_t * clock_source,
 }
 
 static int ni_freq_out_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_SET_CLOCK_SRC:
@@ -4624,7 +4624,7 @@ static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 */
 
 static int ni_eeprom_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));
 
@@ -4660,14 +4660,14 @@ static int ni_read_eeprom(comedi_device * dev, int addr)
 }
 
 static int ni_m_series_eeprom_insn_read(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+	comedi_subdevice * s, comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int ni_get_pwm_config(comedi_device * dev, lsampl_t * data)
+static int ni_get_pwm_config(comedi_device * dev, unsigned int * data)
 {
 	data[1] = devpriv->pwm_up_count * devpriv->clock_ns;
 	data[2] = devpriv->pwm_down_count * devpriv->clock_ns;
@@ -4675,7 +4675,7 @@ static int ni_get_pwm_config(comedi_device * dev, lsampl_t * data)
 }
 
 static int ni_m_series_pwm_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned up_count, down_count;
 	switch (data[0]) {
@@ -4740,7 +4740,7 @@ static int ni_m_series_pwm_config(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ni_6143_pwm_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned up_count, down_count;
 	switch (data[0]) {
@@ -4807,7 +4807,7 @@ static void ni_write_caldac(comedi_device * dev, int addr, int val);
 	calibration subdevice
 */
 static int ni_calib_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	ni_write_caldac(dev, CR_CHAN(insn->chanspec), data[0]);
 
@@ -4815,7 +4815,7 @@ static int ni_calib_insn_write(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ni_calib_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];
 
@@ -5071,21 +5071,21 @@ static void GPCT_Reset(comedi_device * dev, int chan)
 #endif
 
 static int ni_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_insn_config(counter, insn, data);
 }
 
 static int ni_gpct_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_rinsn(counter, insn, data);
 }
 
 static int ni_gpct_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_winsn(counter, insn, data);
@@ -5254,7 +5254,7 @@ static int ni_config_filter(comedi_device * dev, unsigned pfi_channel,
 }
 
 static int ni_pfi_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
 		return -ENOTSUPP;
@@ -5269,7 +5269,7 @@ static int ni_pfi_insn_bits(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ni_pfi_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan;
 
@@ -5346,7 +5346,7 @@ static void ni_rtsi_init(comedi_device * dev)
 }
 
 static int ni_rtsi_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -5627,7 +5627,7 @@ static unsigned ni_get_rtsi_routing(comedi_device * dev, unsigned chan)
 }
 
 static int ni_rtsi_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	switch (data[0]) {
@@ -5806,7 +5806,7 @@ static int cs5529_do_conversion(comedi_device * dev, unsigned short *data)
 }
 
 static int cs5529_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int n, retval;
 	unsigned short sample;

commit 03aef4b6dc12dfc98c1caace3d860a348b17e7c8
Author: David Schleef <ds@schleef.org>
Date:   Tue Feb 17 17:04:22 2009 -0800

    Staging: comedi: add ni_mio_common code
    
    Common code for DAQ-STC based boards.  Other drivers #include
    this file to take advantage of the functions here.
    
    From: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
new file mode 100644
index 000000000000..116a9e559659
--- /dev/null
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -0,0 +1,5862 @@
+/*
+    comedi/drivers/ni_mio_common.c
+    Hardware driver for DAQ-STC based boards
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 1997-2001 David A. Schleef <ds@schleef.org>
+    Copyright (C) 2002-2006 Frank Mori Hess <fmhess@users.sourceforge.net>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+/*
+	This file is meant to be included by another file, e.g.,
+	ni_atmio.c or ni_pcimio.c.
+
+	Interrupt support originally added by Truxton Fulton
+	<trux@truxton.com>
+
+	References (from ftp://ftp.natinst.com/support/manuals):
+
+	   340747b.pdf  AT-MIO E series Register Level Programmer Manual
+	   341079b.pdf  PCI E Series RLPM
+	   340934b.pdf  DAQ-STC reference manual
+	67xx and 611x registers (from http://www.ni.com/pdf/daq/us)
+	release_ni611x.pdf
+	release_ni67xx.pdf
+	Other possibly relevant info:
+
+	   320517c.pdf  User manual (obsolete)
+	   320517f.pdf  User manual (new)
+	   320889a.pdf  delete
+	   320906c.pdf  maximum signal ratings
+	   321066a.pdf  about 16x
+	   321791a.pdf  discontinuation of at-mio-16e-10 rev. c
+	   321808a.pdf  about at-mio-16e-10 rev P
+	   321837a.pdf  discontinuation of at-mio-16de-10 rev d
+	   321838a.pdf  about at-mio-16de-10 rev N
+
+	ISSUES:
+
+	 - the interrupt routine needs to be cleaned up
+
+	2006-02-07: S-Series PCI-6143: Support has been added but is not
+		fully tested as yet. Terry Barnaby, BEAM Ltd.
+*/
+
+//#define DEBUG_INTERRUPT
+//#define DEBUG_STATUS_A
+//#define DEBUG_STATUS_B
+
+#include "8255.h"
+#include "mite.h"
+#include "comedi_fc.h"
+
+#ifndef MDPRINTK
+#define MDPRINTK(format,args...)
+#endif
+
+/* A timeout count */
+#define NI_TIMEOUT 1000
+static const unsigned old_RTSI_clock_channel = 7;
+
+/* Note: this table must match the ai_gain_* definitions */
+static const short ni_gainlkup[][16] = {
+	[ai_gain_16] = {0, 1, 2, 3, 4, 5, 6, 7,
+		0x100, 0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107},
+	[ai_gain_8] = {1, 2, 4, 7, 0x101, 0x102, 0x104, 0x107},
+	[ai_gain_14] = {1, 2, 3, 4, 5, 6, 7,
+		0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107},
+	[ai_gain_4] = {0, 1, 4, 7},
+	[ai_gain_611x] = {0x00a, 0x00b, 0x001, 0x002,
+		0x003, 0x004, 0x005, 0x006},
+	[ai_gain_622x] = {0, 1, 4, 5},
+	[ai_gain_628x] = {1, 2, 3, 4, 5, 6, 7},
+	[ai_gain_6143] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static const comedi_lrange range_ni_E_ai = { 16, {
+			RANGE(-10, 10),
+			RANGE(-5, 5),
+			RANGE(-2.5, 2.5),
+			RANGE(-1, 1),
+			RANGE(-0.5, 0.5),
+			RANGE(-0.25, 0.25),
+			RANGE(-0.1, 0.1),
+			RANGE(-0.05, 0.05),
+			RANGE(0, 20),
+			RANGE(0, 10),
+			RANGE(0, 5),
+			RANGE(0, 2),
+			RANGE(0, 1),
+			RANGE(0, 0.5),
+			RANGE(0, 0.2),
+			RANGE(0, 0.1),
+	}
+};
+static const comedi_lrange range_ni_E_ai_limited = { 8, {
+			RANGE(-10, 10),
+			RANGE(-5, 5),
+			RANGE(-1, 1),
+			RANGE(-0.1, 0.1),
+			RANGE(0, 10),
+			RANGE(0, 5),
+			RANGE(0, 1),
+			RANGE(0, 0.1),
+	}
+};
+static const comedi_lrange range_ni_E_ai_limited14 = { 14, {
+			RANGE(-10, 10),
+			RANGE(-5, 5),
+			RANGE(-2, 2),
+			RANGE(-1, 1),
+			RANGE(-0.5, 0.5),
+			RANGE(-0.2, 0.2),
+			RANGE(-0.1, 0.1),
+			RANGE(0, 10),
+			RANGE(0, 5),
+			RANGE(0, 2),
+			RANGE(0, 1),
+			RANGE(0, 0.5),
+			RANGE(0, 0.2),
+			RANGE(0, 0.1),
+	}
+};
+static const comedi_lrange range_ni_E_ai_bipolar4 = { 4, {
+			RANGE(-10, 10),
+			RANGE(-5, 5),
+			RANGE(-0.5, 0.5),
+			RANGE(-0.05, 0.05),
+	}
+};
+static const comedi_lrange range_ni_E_ai_611x = { 8, {
+			RANGE(-50, 50),
+			RANGE(-20, 20),
+			RANGE(-10, 10),
+			RANGE(-5, 5),
+			RANGE(-2, 2),
+			RANGE(-1, 1),
+			RANGE(-0.5, 0.5),
+			RANGE(-0.2, 0.2),
+	}
+};
+static const comedi_lrange range_ni_M_ai_622x = { 4, {
+			RANGE(-10, 10),
+			RANGE(-5, 5),
+			RANGE(-1, 1),
+			RANGE(-0.2, 0.2),
+	}
+};
+static const comedi_lrange range_ni_M_ai_628x = { 7, {
+			RANGE(-10, 10),
+			RANGE(-5, 5),
+			RANGE(-2, 2),
+			RANGE(-1, 1),
+			RANGE(-0.5, 0.5),
+			RANGE(-0.2, 0.2),
+			RANGE(-0.1, 0.1),
+	}
+};
+static const comedi_lrange range_ni_S_ai_6143 = { 1, {
+			RANGE(-5, +5),
+	}
+};
+static const comedi_lrange range_ni_E_ao_ext = { 4, {
+			RANGE(-10, 10),
+			RANGE(0, 10),
+			RANGE_ext(-1, 1),
+			RANGE_ext(0, 1),
+	}
+};
+
+static const comedi_lrange *const ni_range_lkup[] = {
+	[ai_gain_16] = &range_ni_E_ai,
+	[ai_gain_8] = &range_ni_E_ai_limited,
+	[ai_gain_14] = &range_ni_E_ai_limited14,
+	[ai_gain_4] = &range_ni_E_ai_bipolar4,
+	[ai_gain_611x] = &range_ni_E_ai_611x,
+	[ai_gain_622x] = &range_ni_M_ai_622x,
+	[ai_gain_628x] = &range_ni_M_ai_628x,
+	[ai_gain_6143] = &range_ni_S_ai_6143
+};
+
+static int ni_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ni_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ni_cdio_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int ni_cdio_cmd(comedi_device * dev, comedi_subdevice * s);
+static int ni_cdio_cancel(comedi_device * dev, comedi_subdevice * s);
+static void handle_cdio_interrupt(comedi_device * dev);
+static int ni_cdo_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum);
+
+static int ni_serial_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ni_serial_hw_readwrite8(comedi_device * dev, comedi_subdevice * s,
+	unsigned char data_out, unsigned char *data_in);
+static int ni_serial_sw_readwrite8(comedi_device * dev, comedi_subdevice * s,
+	unsigned char data_out, unsigned char *data_in);
+
+static int ni_calib_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ni_calib_insn_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+
+static int ni_eeprom_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ni_m_series_eeprom_insn_read(comedi_device * dev,
+	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data);
+
+static int ni_pfi_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ni_pfi_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static unsigned ni_old_get_pfi_routing(comedi_device * dev, unsigned chan);
+
+static void ni_rtsi_init(comedi_device * dev);
+static int ni_rtsi_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ni_rtsi_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+
+static void caldac_setup(comedi_device * dev, comedi_subdevice * s);
+static int ni_read_eeprom(comedi_device * dev, int addr);
+
+#ifdef DEBUG_STATUS_A
+static void ni_mio_print_status_a(int status);
+#else
+#define ni_mio_print_status_a(a)
+#endif
+#ifdef DEBUG_STATUS_B
+static void ni_mio_print_status_b(int status);
+#else
+#define ni_mio_print_status_b(a)
+#endif
+
+static int ni_ai_reset(comedi_device * dev, comedi_subdevice * s);
+#ifndef PCIDMA
+static void ni_handle_fifo_half_full(comedi_device * dev);
+static int ni_ao_fifo_half_empty(comedi_device * dev, comedi_subdevice * s);
+#endif
+static void ni_handle_fifo_dregs(comedi_device * dev);
+static int ni_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum);
+static void ni_load_channelgain_list(comedi_device * dev, unsigned int n_chan,
+	unsigned int *list);
+static void shutdown_ai_command(comedi_device * dev);
+
+static int ni_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum);
+
+static int ni_ao_reset(comedi_device * dev, comedi_subdevice * s);
+
+static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
+
+static int ni_gpct_insn_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ni_gpct_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ni_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ni_gpct_cmd(comedi_device * dev, comedi_subdevice * s);
+static int ni_gpct_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int ni_gpct_cancel(comedi_device * dev, comedi_subdevice * s);
+static void handle_gpct_interrupt(comedi_device * dev,
+	unsigned short counter_index);
+
+static int init_cs5529(comedi_device * dev);
+static int cs5529_do_conversion(comedi_device * dev, unsigned short *data);
+static int cs5529_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+#ifdef NI_CS5529_DEBUG
+static unsigned int cs5529_config_read(comedi_device * dev,
+	unsigned int reg_select_bits);
+#endif
+static void cs5529_config_write(comedi_device * dev, unsigned int value,
+	unsigned int reg_select_bits);
+
+static int ni_m_series_pwm_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ni_6143_pwm_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+
+static int ni_set_master_clock(comedi_device * dev, unsigned source,
+	unsigned period_ns);
+static void ack_a_interrupt(comedi_device * dev, unsigned short a_status);
+static void ack_b_interrupt(comedi_device * dev, unsigned short b_status);
+
+enum aimodes {
+	AIMODE_NONE = 0,
+	AIMODE_HALF_FULL = 1,
+	AIMODE_SCAN = 2,
+	AIMODE_SAMPLE = 3,
+};
+
+enum ni_common_subdevices {
+	NI_AI_SUBDEV,
+	NI_AO_SUBDEV,
+	NI_DIO_SUBDEV,
+	NI_8255_DIO_SUBDEV,
+	NI_UNUSED_SUBDEV,
+	NI_CALIBRATION_SUBDEV,
+	NI_EEPROM_SUBDEV,
+	NI_PFI_DIO_SUBDEV,
+	NI_CS5529_CALIBRATION_SUBDEV,
+	NI_SERIAL_SUBDEV,
+	NI_RTSI_SUBDEV,
+	NI_GPCT0_SUBDEV,
+	NI_GPCT1_SUBDEV,
+	NI_FREQ_OUT_SUBDEV,
+	NI_NUM_SUBDEVICES
+};
+static inline unsigned NI_GPCT_SUBDEV(unsigned counter_index)
+{
+	switch (counter_index) {
+	case 0:
+		return NI_GPCT0_SUBDEV;
+		break;
+	case 1:
+		return NI_GPCT1_SUBDEV;
+		break;
+	default:
+		break;
+	}
+	BUG();
+	return NI_GPCT0_SUBDEV;
+}
+
+enum timebase_nanoseconds {
+	TIMEBASE_1_NS = 50,
+	TIMEBASE_2_NS = 10000
+};
+
+#define SERIAL_DISABLED		0
+#define SERIAL_600NS		600
+#define SERIAL_1_2US		1200
+#define SERIAL_10US			10000
+
+static const int num_adc_stages_611x = 3;
+
+static void handle_a_interrupt(comedi_device * dev, unsigned short status,
+	unsigned ai_mite_status);
+static void handle_b_interrupt(comedi_device * dev, unsigned short status,
+	unsigned ao_mite_status);
+static void get_last_sample_611x(comedi_device * dev);
+static void get_last_sample_6143(comedi_device * dev);
+
+static inline void ni_set_bitfield(comedi_device * dev, int reg,
+	unsigned bit_mask, unsigned bit_values)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
+	switch (reg) {
+	case Interrupt_A_Enable_Register:
+		devpriv->int_a_enable_reg &= ~bit_mask;
+		devpriv->int_a_enable_reg |= bit_values & bit_mask;
+		devpriv->stc_writew(dev, devpriv->int_a_enable_reg,
+			Interrupt_A_Enable_Register);
+		break;
+	case Interrupt_B_Enable_Register:
+		devpriv->int_b_enable_reg &= ~bit_mask;
+		devpriv->int_b_enable_reg |= bit_values & bit_mask;
+		devpriv->stc_writew(dev, devpriv->int_b_enable_reg,
+			Interrupt_B_Enable_Register);
+		break;
+	case IO_Bidirection_Pin_Register:
+		devpriv->io_bidirection_pin_reg &= ~bit_mask;
+		devpriv->io_bidirection_pin_reg |= bit_values & bit_mask;
+		devpriv->stc_writew(dev, devpriv->io_bidirection_pin_reg,
+			IO_Bidirection_Pin_Register);
+		break;
+	case AI_AO_Select:
+		devpriv->ai_ao_select_reg &= ~bit_mask;
+		devpriv->ai_ao_select_reg |= bit_values & bit_mask;
+		ni_writeb(devpriv->ai_ao_select_reg, AI_AO_Select);
+		break;
+	case G0_G1_Select:
+		devpriv->g0_g1_select_reg &= ~bit_mask;
+		devpriv->g0_g1_select_reg |= bit_values & bit_mask;
+		ni_writeb(devpriv->g0_g1_select_reg, G0_G1_Select);
+		break;
+	default:
+		rt_printk("Warning %s() called with invalid register\n",
+			__FUNCTION__);
+		rt_printk("reg is %d\n", reg);
+		break;
+	}
+	mmiowb();
+	comedi_spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
+}
+
+#ifdef PCIDMA
+static int ni_ai_drain_dma(comedi_device * dev);
+
+/* DMA channel setup */
+
+// negative channel means no channel
+static inline void ni_set_ai_dma_channel(comedi_device * dev, int channel)
+{
+	unsigned bitfield;
+
+	if (channel >= 0) {
+		bitfield =
+			(ni_stc_dma_channel_select_bitfield(channel) <<
+			AI_DMA_Select_Shift) & AI_DMA_Select_Mask;
+	} else {
+		bitfield = 0;
+	}
+	ni_set_bitfield(dev, AI_AO_Select, AI_DMA_Select_Mask, bitfield);
+}
+
+// negative channel means no channel
+static inline void ni_set_ao_dma_channel(comedi_device * dev, int channel)
+{
+	unsigned bitfield;
+
+	if (channel >= 0) {
+		bitfield =
+			(ni_stc_dma_channel_select_bitfield(channel) <<
+			AO_DMA_Select_Shift) & AO_DMA_Select_Mask;
+	} else {
+		bitfield = 0;
+	}
+	ni_set_bitfield(dev, AI_AO_Select, AO_DMA_Select_Mask, bitfield);
+}
+
+// negative mite_channel means no channel
+static inline void ni_set_gpct_dma_channel(comedi_device * dev,
+	unsigned gpct_index, int mite_channel)
+{
+	unsigned bitfield;
+
+	if (mite_channel >= 0) {
+		bitfield = GPCT_DMA_Select_Bits(gpct_index, mite_channel);
+	} else {
+		bitfield = 0;
+	}
+	ni_set_bitfield(dev, G0_G1_Select, GPCT_DMA_Select_Mask(gpct_index),
+		bitfield);
+}
+
+// negative mite_channel means no channel
+static inline void ni_set_cdo_dma_channel(comedi_device * dev, int mite_channel)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
+	devpriv->cdio_dma_select_reg &= ~CDO_DMA_Select_Mask;
+	if (mite_channel >= 0) {
+		/*XXX just guessing ni_stc_dma_channel_select_bitfield() returns the right bits,
+		   under the assumption the cdio dma selection works just like ai/ao/gpct.
+		   Definitely works for dma channels 0 and 1. */
+		devpriv->cdio_dma_select_reg |=
+			(ni_stc_dma_channel_select_bitfield(mite_channel) <<
+			CDO_DMA_Select_Shift) & CDO_DMA_Select_Mask;
+	}
+	ni_writeb(devpriv->cdio_dma_select_reg, M_Offset_CDIO_DMA_Select);
+	mmiowb();
+	comedi_spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
+}
+
+static int ni_request_ai_mite_channel(comedi_device * dev)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	BUG_ON(devpriv->ai_mite_chan);
+	devpriv->ai_mite_chan =
+		mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);
+	if (devpriv->ai_mite_chan == NULL) {
+		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
+			flags);
+		comedi_error(dev,
+			"failed to reserve mite dma channel for analog input.");
+		return -EBUSY;
+	}
+	devpriv->ai_mite_chan->dir = COMEDI_INPUT;
+	ni_set_ai_dma_channel(dev, devpriv->ai_mite_chan->channel);
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	return 0;
+}
+
+static int ni_request_ao_mite_channel(comedi_device * dev)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	BUG_ON(devpriv->ao_mite_chan);
+	devpriv->ao_mite_chan =
+		mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);
+	if (devpriv->ao_mite_chan == NULL) {
+		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
+			flags);
+		comedi_error(dev,
+			"failed to reserve mite dma channel for analog outut.");
+		return -EBUSY;
+	}
+	devpriv->ao_mite_chan->dir = COMEDI_OUTPUT;
+	ni_set_ao_dma_channel(dev, devpriv->ao_mite_chan->channel);
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	return 0;
+}
+
+static int ni_request_gpct_mite_channel(comedi_device * dev,
+	unsigned gpct_index, enum comedi_io_direction direction)
+{
+	unsigned long flags;
+	struct mite_channel *mite_chan;
+
+	BUG_ON(gpct_index >= NUM_GPCT);
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	BUG_ON(devpriv->counter_dev->counters[gpct_index].mite_chan);
+	mite_chan =
+		mite_request_channel(devpriv->mite,
+		devpriv->gpct_mite_ring[gpct_index]);
+	if (mite_chan == NULL) {
+		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
+			flags);
+		comedi_error(dev,
+			"failed to reserve mite dma channel for counter.");
+		return -EBUSY;
+	}
+	mite_chan->dir = direction;
+	ni_tio_set_mite_channel(&devpriv->counter_dev->counters[gpct_index],
+		mite_chan);
+	ni_set_gpct_dma_channel(dev, gpct_index, mite_chan->channel);
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	return 0;
+}
+
+#endif // PCIDMA
+
+static int ni_request_cdo_mite_channel(comedi_device * dev)
+{
+#ifdef PCIDMA
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	BUG_ON(devpriv->cdo_mite_chan);
+	devpriv->cdo_mite_chan =
+		mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);
+	if (devpriv->cdo_mite_chan == NULL) {
+		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
+			flags);
+		comedi_error(dev,
+			"failed to reserve mite dma channel for correlated digital outut.");
+		return -EBUSY;
+	}
+	devpriv->cdo_mite_chan->dir = COMEDI_OUTPUT;
+	ni_set_cdo_dma_channel(dev, devpriv->cdo_mite_chan->channel);
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+#endif // PCIDMA
+	return 0;
+}
+
+static void ni_release_ai_mite_channel(comedi_device * dev)
+{
+#ifdef PCIDMA
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if (devpriv->ai_mite_chan) {
+		ni_set_ai_dma_channel(dev, -1);
+		mite_release_channel(devpriv->ai_mite_chan);
+		devpriv->ai_mite_chan = NULL;
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+#endif // PCIDMA
+}
+
+static void ni_release_ao_mite_channel(comedi_device * dev)
+{
+#ifdef PCIDMA
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if (devpriv->ao_mite_chan) {
+		ni_set_ao_dma_channel(dev, -1);
+		mite_release_channel(devpriv->ao_mite_chan);
+		devpriv->ao_mite_chan = NULL;
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+#endif // PCIDMA
+}
+
+void ni_release_gpct_mite_channel(comedi_device * dev, unsigned gpct_index)
+{
+#ifdef PCIDMA
+	unsigned long flags;
+
+	BUG_ON(gpct_index >= NUM_GPCT);
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if (devpriv->counter_dev->counters[gpct_index].mite_chan) {
+		struct mite_channel *mite_chan =
+			devpriv->counter_dev->counters[gpct_index].mite_chan;
+
+		ni_set_gpct_dma_channel(dev, gpct_index, -1);
+		ni_tio_set_mite_channel(&devpriv->counter_dev->
+			counters[gpct_index], NULL);
+		mite_release_channel(mite_chan);
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+#endif // PCIDMA
+}
+
+static void ni_release_cdo_mite_channel(comedi_device * dev)
+{
+#ifdef PCIDMA
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if (devpriv->cdo_mite_chan) {
+		ni_set_cdo_dma_channel(dev, -1);
+		mite_release_channel(devpriv->cdo_mite_chan);
+		devpriv->cdo_mite_chan = NULL;
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+#endif // PCIDMA
+}
+
+// e-series boards use the second irq signals to generate dma requests for their counters
+#ifdef PCIDMA
+static void ni_e_series_enable_second_irq(comedi_device * dev,
+	unsigned gpct_index, short enable)
+{
+	if (boardtype.reg_type & ni_reg_m_series_mask)
+		return;
+	switch (gpct_index) {
+	case 0:
+		if (enable) {
+			devpriv->stc_writew(dev, G0_Gate_Second_Irq_Enable,
+				Second_IRQ_A_Enable_Register);
+		} else {
+			devpriv->stc_writew(dev, 0,
+				Second_IRQ_A_Enable_Register);
+		}
+		break;
+	case 1:
+		if (enable) {
+			devpriv->stc_writew(dev, G1_Gate_Second_Irq_Enable,
+				Second_IRQ_B_Enable_Register);
+		} else {
+			devpriv->stc_writew(dev, 0,
+				Second_IRQ_B_Enable_Register);
+		}
+		break;
+	default:
+		BUG();
+		break;
+	}
+}
+#endif // PCIDMA
+
+static void ni_clear_ai_fifo(comedi_device * dev)
+{
+	if (boardtype.reg_type == ni_reg_6143) {
+		// Flush the 6143 data FIFO
+		ni_writel(0x10, AIFIFO_Control_6143);	// Flush fifo
+		ni_writel(0x00, AIFIFO_Control_6143);	// Flush fifo
+		while (ni_readl(AIFIFO_Status_6143) & 0x10) ;	// Wait for complete
+	} else {
+		devpriv->stc_writew(dev, 1, ADC_FIFO_Clear);
+		if (boardtype.reg_type == ni_reg_625x) {
+			ni_writeb(0, M_Offset_Static_AI_Control(0));
+			ni_writeb(1, M_Offset_Static_AI_Control(0));
+#if 0
+			/* the NI example code does 3 convert pulses for 625x boards,
+			   but that appears to be wrong in practice. */
+			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
+				AI_Command_1_Register);
+			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
+				AI_Command_1_Register);
+			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
+				AI_Command_1_Register);
+#endif
+		}
+	}
+}
+
+static void win_out2(comedi_device * dev, uint32_t data, int reg)
+{
+	devpriv->stc_writew(dev, data >> 16, reg);
+	devpriv->stc_writew(dev, data & 0xffff, reg + 1);
+}
+
+static uint32_t win_in2(comedi_device * dev, int reg)
+{
+	uint32_t bits;
+	bits = devpriv->stc_readw(dev, reg) << 16;
+	bits |= devpriv->stc_readw(dev, reg + 1);
+	return bits;
+}
+
+#define ao_win_out(data,addr) ni_ao_win_outw(dev,data,addr)
+static inline void ni_ao_win_outw(comedi_device * dev, uint16_t data, int addr)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	ni_writew(addr, AO_Window_Address_611x);
+	ni_writew(data, AO_Window_Data_611x);
+	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+}
+
+static inline void ni_ao_win_outl(comedi_device * dev, uint32_t data, int addr)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	ni_writew(addr, AO_Window_Address_611x);
+	ni_writel(data, AO_Window_Data_611x);
+	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+}
+
+static inline unsigned short ni_ao_win_inw(comedi_device * dev, int addr)
+{
+	unsigned long flags;
+	unsigned short data;
+
+	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	ni_writew(addr, AO_Window_Address_611x);
+	data = ni_readw(AO_Window_Data_611x);
+	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	return data;
+}
+
+/* ni_set_bits( ) allows different parts of the ni_mio_common driver to
+* share registers (such as Interrupt_A_Register) without interfering with
+* each other.
+*
+* NOTE: the switch/case statements are optimized out for a constant argument
+* so this is actually quite fast---  If you must wrap another function around this
+* make it inline to avoid a large speed penalty.
+*
+* value should only be 1 or 0.
+*/
+static inline void ni_set_bits(comedi_device * dev, int reg, unsigned bits,
+	unsigned value)
+{
+	unsigned bit_values;
+
+	if (value)
+		bit_values = bits;
+	else
+		bit_values = 0;
+	ni_set_bitfield(dev, reg, bits, bit_values);
+}
+
+static irqreturn_t ni_E_interrupt(int irq, void *d PT_REGS_ARG)
+{
+	comedi_device *dev = d;
+	unsigned short a_status;
+	unsigned short b_status;
+	unsigned int ai_mite_status = 0;
+	unsigned int ao_mite_status = 0;
+	unsigned long flags;
+#ifdef PCIDMA
+	struct mite_struct *mite = devpriv->mite;
+#endif
+
+	if (dev->attached == 0)
+		return IRQ_NONE;
+	smp_mb();		// make sure dev->attached is checked before handler does anything else.
+
+	// lock to avoid race with comedi_poll
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	a_status = devpriv->stc_readw(dev, AI_Status_1_Register);
+	b_status = devpriv->stc_readw(dev, AO_Status_1_Register);
+#ifdef PCIDMA
+	if (mite) {
+		unsigned long flags_too;
+
+		comedi_spin_lock_irqsave(&devpriv->mite_channel_lock,
+			flags_too);
+		if (devpriv->ai_mite_chan) {
+			ai_mite_status = mite_get_status(devpriv->ai_mite_chan);
+			if (ai_mite_status & CHSR_LINKC)
+				writel(CHOR_CLRLC,
+					devpriv->mite->mite_io_addr +
+					MITE_CHOR(devpriv->ai_mite_chan->
+						channel));
+		}
+		if (devpriv->ao_mite_chan) {
+			ao_mite_status = mite_get_status(devpriv->ao_mite_chan);
+			if (ao_mite_status & CHSR_LINKC)
+				writel(CHOR_CLRLC,
+					mite->mite_io_addr +
+					MITE_CHOR(devpriv->ao_mite_chan->
+						channel));
+		}
+		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
+			flags_too);
+	}
+#endif
+	ack_a_interrupt(dev, a_status);
+	ack_b_interrupt(dev, b_status);
+	if ((a_status & Interrupt_A_St) || (ai_mite_status & CHSR_INT))
+		handle_a_interrupt(dev, a_status, ai_mite_status);
+	if ((b_status & Interrupt_B_St) || (ao_mite_status & CHSR_INT))
+		handle_b_interrupt(dev, b_status, ao_mite_status);
+	handle_gpct_interrupt(dev, 0);
+	handle_gpct_interrupt(dev, 1);
+	handle_cdio_interrupt(dev);
+
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	return IRQ_HANDLED;
+}
+
+#ifdef PCIDMA
+static void ni_sync_ai_dma(comedi_device * dev)
+{
+	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if (devpriv->ai_mite_chan)
+		mite_sync_input_dma(devpriv->ai_mite_chan, s->async);
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+}
+
+static void mite_handle_b_linkc(struct mite_struct *mite, comedi_device * dev)
+{
+	comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if (devpriv->ao_mite_chan) {
+		mite_sync_output_dma(devpriv->ao_mite_chan, s->async);
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+}
+
+static int ni_ao_wait_for_dma_load(comedi_device * dev)
+{
+	static const int timeout = 10000;
+	int i;
+	for (i = 0; i < timeout; i++) {
+		unsigned short b_status;
+
+		b_status = devpriv->stc_readw(dev, AO_Status_1_Register);
+		if (b_status & AO_FIFO_Half_Full_St)
+			break;
+		/* if we poll too often, the pci bus activity seems
+		   to slow the dma transfer down */
+		comedi_udelay(10);
+	}
+	if (i == timeout) {
+		comedi_error(dev, "timed out waiting for dma load");
+		return -EPIPE;
+	}
+	return 0;
+}
+
+#endif //PCIDMA
+static void ni_handle_eos(comedi_device * dev, comedi_subdevice * s)
+{
+	if (devpriv->aimode == AIMODE_SCAN) {
+#ifdef PCIDMA
+		static const int timeout = 10;
+		int i;
+
+		for (i = 0; i < timeout; i++) {
+			ni_sync_ai_dma(dev);
+			if ((s->async->events & COMEDI_CB_EOS))
+				break;
+			comedi_udelay(1);
+		}
+#else
+		ni_handle_fifo_dregs(dev);
+		s->async->events |= COMEDI_CB_EOS;
+#endif
+	}
+	/* handle special case of single scan using AI_End_On_End_Of_Scan */
+	if ((devpriv->ai_cmd2 & AI_End_On_End_Of_Scan)) {
+		shutdown_ai_command(dev);
+	}
+}
+
+static void shutdown_ai_command(comedi_device * dev)
+{
+	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+
+#ifdef PCIDMA
+	ni_ai_drain_dma(dev);
+#endif
+	ni_handle_fifo_dregs(dev);
+	get_last_sample_611x(dev);
+	get_last_sample_6143(dev);
+
+	s->async->events |= COMEDI_CB_EOA;
+}
+
+static void ni_event(comedi_device * dev, comedi_subdevice * s)
+{
+	if (s->async->
+		events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW | COMEDI_CB_EOA))
+	{
+		switch (s - dev->subdevices) {
+		case NI_AI_SUBDEV:
+			ni_ai_reset(dev, s);
+			break;
+		case NI_AO_SUBDEV:
+			ni_ao_reset(dev, s);
+			break;
+		case NI_GPCT0_SUBDEV:
+		case NI_GPCT1_SUBDEV:
+			ni_gpct_cancel(dev, s);
+			break;
+		case NI_DIO_SUBDEV:
+			ni_cdio_cancel(dev, s);
+			break;
+		default:
+			break;
+		}
+	}
+	comedi_event(dev, s);
+}
+
+static void handle_gpct_interrupt(comedi_device * dev,
+	unsigned short counter_index)
+{
+#ifdef PCIDMA
+	comedi_subdevice *s = dev->subdevices + NI_GPCT_SUBDEV(counter_index);
+
+	ni_tio_handle_interrupt(&devpriv->counter_dev->counters[counter_index],
+		s);
+	if (s->async->events)
+		ni_event(dev, s);
+#endif
+}
+
+static void ack_a_interrupt(comedi_device * dev, unsigned short a_status)
+{
+	unsigned short ack = 0;
+
+	if (a_status & AI_SC_TC_St) {
+		ack |= AI_SC_TC_Interrupt_Ack;
+	}
+	if (a_status & AI_START1_St) {
+		ack |= AI_START1_Interrupt_Ack;
+	}
+	if (a_status & AI_START_St) {
+		ack |= AI_START_Interrupt_Ack;
+	}
+	if (a_status & AI_STOP_St) {
+		/* not sure why we used to ack the START here also, instead of doing it independently. Frank Hess 2007-07-06 */
+		ack |= AI_STOP_Interrupt_Ack /*| AI_START_Interrupt_Ack */ ;
+	}
+	if (ack)
+		devpriv->stc_writew(dev, ack, Interrupt_A_Ack_Register);
+}
+
+static void handle_a_interrupt(comedi_device * dev, unsigned short status,
+	unsigned ai_mite_status)
+{
+	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+
+	//67xx boards don't have ai subdevice, but their gpct0 might generate an a interrupt
+	if (s->type == COMEDI_SUBD_UNUSED)
+		return;
+
+#ifdef DEBUG_INTERRUPT
+	rt_printk
+		("ni_mio_common: interrupt: a_status=%04x ai_mite_status=%08x\n",
+		status, ai_mite_status);
+	ni_mio_print_status_a(status);
+#endif
+#ifdef PCIDMA
+	if (ai_mite_status & CHSR_LINKC) {
+		ni_sync_ai_dma(dev);
+	}
+
+	if (ai_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
+			CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
+			CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
+		rt_printk
+			("unknown mite interrupt, ack! (ai_mite_status=%08x)\n",
+			ai_mite_status);
+		//mite_print_chsr(ai_mite_status);
+		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		//disable_irq(dev->irq);
+	}
+#endif
+
+	/* test for all uncommon interrupt events at the same time */
+	if (status & (AI_Overrun_St | AI_Overflow_St | AI_SC_TC_Error_St |
+			AI_SC_TC_St | AI_START1_St)) {
+		if (status == 0xffff) {
+			rt_printk
+				("ni_mio_common: a_status=0xffff.  Card removed?\n");
+			/* we probably aren't even running a command now,
+			 * so it's a good idea to be careful. */
+			if (comedi_get_subdevice_runflags(s) & SRF_RUNNING) {
+				s->async->events |=
+					COMEDI_CB_ERROR | COMEDI_CB_EOA;
+				ni_event(dev, s);
+			}
+			return;
+		}
+		if (status & (AI_Overrun_St | AI_Overflow_St |
+				AI_SC_TC_Error_St)) {
+			rt_printk("ni_mio_common: ai error a_status=%04x\n",
+				status);
+			ni_mio_print_status_a(status);
+
+			shutdown_ai_command(dev);
+
+			s->async->events |= COMEDI_CB_ERROR;
+			if (status & (AI_Overrun_St | AI_Overflow_St))
+				s->async->events |= COMEDI_CB_OVERFLOW;
+
+			ni_event(dev, s);
+
+			return;
+		}
+		if (status & AI_SC_TC_St) {
+#ifdef DEBUG_INTERRUPT
+			rt_printk("ni_mio_common: SC_TC interrupt\n");
+#endif
+			if (!devpriv->ai_continuous) {
+				shutdown_ai_command(dev);
+			}
+		}
+	}
+#ifndef PCIDMA
+	if (status & AI_FIFO_Half_Full_St) {
+		int i;
+		static const int timeout = 10;
+		/* pcmcia cards (at least 6036) seem to stop producing interrupts if we
+		 *fail to get the fifo less than half full, so loop to be sure.*/
+		for (i = 0; i < timeout; ++i) {
+			ni_handle_fifo_half_full(dev);
+			if ((devpriv->stc_readw(dev,
+						AI_Status_1_Register) &
+					AI_FIFO_Half_Full_St) == 0)
+				break;
+		}
+	}
+#endif // !PCIDMA
+
+	if ((status & AI_STOP_St)) {
+		ni_handle_eos(dev, s);
+	}
+
+	ni_event(dev, s);
+
+#ifdef DEBUG_INTERRUPT
+	status = devpriv->stc_readw(dev, AI_Status_1_Register);
+	if (status & Interrupt_A_St) {
+		rt_printk
+			("handle_a_interrupt: didn't clear interrupt? status=0x%x\n",
+			status);
+	}
+#endif
+}
+
+static void ack_b_interrupt(comedi_device * dev, unsigned short b_status)
+{
+	unsigned short ack = 0;
+	if (b_status & AO_BC_TC_St) {
+		ack |= AO_BC_TC_Interrupt_Ack;
+	}
+	if (b_status & AO_Overrun_St) {
+		ack |= AO_Error_Interrupt_Ack;
+	}
+	if (b_status & AO_START_St) {
+		ack |= AO_START_Interrupt_Ack;
+	}
+	if (b_status & AO_START1_St) {
+		ack |= AO_START1_Interrupt_Ack;
+	}
+	if (b_status & AO_UC_TC_St) {
+		ack |= AO_UC_TC_Interrupt_Ack;
+	}
+	if (b_status & AO_UI2_TC_St) {
+		ack |= AO_UI2_TC_Interrupt_Ack;
+	}
+	if (b_status & AO_UPDATE_St) {
+		ack |= AO_UPDATE_Interrupt_Ack;
+	}
+	if (ack)
+		devpriv->stc_writew(dev, ack, Interrupt_B_Ack_Register);
+}
+
+static void handle_b_interrupt(comedi_device * dev, unsigned short b_status,
+	unsigned ao_mite_status)
+{
+	comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
+	//unsigned short ack=0;
+#ifdef DEBUG_INTERRUPT
+	rt_printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
+		b_status, ao_mite_status);
+	ni_mio_print_status_b(b_status);
+#endif
+
+#ifdef PCIDMA
+	/* Currently, mite.c requires us to handle LINKC */
+	if (ao_mite_status & CHSR_LINKC) {
+		mite_handle_b_linkc(devpriv->mite, dev);
+	}
+
+	if (ao_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
+			CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
+			CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
+		rt_printk
+			("unknown mite interrupt, ack! (ao_mite_status=%08x)\n",
+			ao_mite_status);
+		//mite_print_chsr(ao_mite_status);
+		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+	}
+#endif
+
+	if (b_status == 0xffff)
+		return;
+	if (b_status & AO_Overrun_St) {
+		rt_printk
+			("ni_mio_common: AO FIFO underrun status=0x%04x status2=0x%04x\n",
+			b_status, devpriv->stc_readw(dev,
+				AO_Status_2_Register));
+		s->async->events |= COMEDI_CB_OVERFLOW;
+	}
+
+	if (b_status & AO_BC_TC_St) {
+		MDPRINTK("ni_mio_common: AO BC_TC status=0x%04x status2=0x%04x\n", b_status, devpriv->stc_readw(dev, AO_Status_2_Register));
+		s->async->events |= COMEDI_CB_EOA;
+	}
+#ifndef PCIDMA
+	if (b_status & AO_FIFO_Request_St) {
+		int ret;
+
+		ret = ni_ao_fifo_half_empty(dev, s);
+		if (!ret) {
+			rt_printk("ni_mio_common: AO buffer underrun\n");
+			ni_set_bits(dev, Interrupt_B_Enable_Register,
+				AO_FIFO_Interrupt_Enable |
+				AO_Error_Interrupt_Enable, 0);
+			s->async->events |= COMEDI_CB_OVERFLOW;
+		}
+	}
+#endif
+
+	ni_event(dev, s);
+}
+
+#ifdef DEBUG_STATUS_A
+static const char *const status_a_strings[] = {
+	"passthru0", "fifo", "G0_gate", "G0_TC",
+	"stop", "start", "sc_tc", "start1",
+	"start2", "sc_tc_error", "overflow", "overrun",
+	"fifo_empty", "fifo_half_full", "fifo_full", "interrupt_a"
+};
+
+static void ni_mio_print_status_a(int status)
+{
+	int i;
+
+	rt_printk("A status:");
+	for (i = 15; i >= 0; i--) {
+		if (status & (1 << i)) {
+			rt_printk(" %s", status_a_strings[i]);
+		}
+	}
+	rt_printk("\n");
+}
+#endif
+
+#ifdef DEBUG_STATUS_B
+static const char *const status_b_strings[] = {
+	"passthru1", "fifo", "G1_gate", "G1_TC",
+	"UI2_TC", "UPDATE", "UC_TC", "BC_TC",
+	"start1", "overrun", "start", "bc_tc_error",
+	"fifo_empty", "fifo_half_full", "fifo_full", "interrupt_b"
+};
+
+static void ni_mio_print_status_b(int status)
+{
+	int i;
+
+	rt_printk("B status:");
+	for (i = 15; i >= 0; i--) {
+		if (status & (1 << i)) {
+			rt_printk(" %s", status_b_strings[i]);
+		}
+	}
+	rt_printk("\n");
+}
+#endif
+
+#ifndef PCIDMA
+
+static void ni_ao_fifo_load(comedi_device * dev, comedi_subdevice * s, int n)
+{
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	int chan;
+	int i;
+	sampl_t d;
+	u32 packed_data;
+	int range;
+	int err = 1;
+
+	chan = async->cur_chan;
+	for (i = 0; i < n; i++) {
+		err &= comedi_buf_get(async, &d);
+		if (err == 0)
+			break;
+
+		range = CR_RANGE(cmd->chanlist[chan]);
+
+		if (boardtype.reg_type & ni_reg_6xxx_mask) {
+			packed_data = d & 0xffff;
+			/* 6711 only has 16 bit wide ao fifo */
+			if (boardtype.reg_type != ni_reg_6711) {
+				err &= comedi_buf_get(async, &d);
+				if (err == 0)
+					break;
+				chan++;
+				i++;
+				packed_data |= (d << 16) & 0xffff0000;
+			}
+			ni_writel(packed_data, DAC_FIFO_Data_611x);
+		} else {
+			ni_writew(d, DAC_FIFO_Data);
+		}
+		chan++;
+		chan %= cmd->chanlist_len;
+	}
+	async->cur_chan = chan;
+	if (err == 0) {
+		async->events |= COMEDI_CB_OVERFLOW;
+	}
+}
+
+/*
+ *  There's a small problem if the FIFO gets really low and we
+ *  don't have the data to fill it.  Basically, if after we fill
+ *  the FIFO with all the data available, the FIFO is _still_
+ *  less than half full, we never clear the interrupt.  If the
+ *  IRQ is in edge mode, we never get another interrupt, because
+ *  this one wasn't cleared.  If in level mode, we get flooded
+ *  with interrupts that we can't fulfill, because nothing ever
+ *  gets put into the buffer.
+ *
+ *  This kind of situation is recoverable, but it is easier to
+ *  just pretend we had a FIFO underrun, since there is a good
+ *  chance it will happen anyway.  This is _not_ the case for
+ *  RT code, as RT code might purposely be running close to the
+ *  metal.  Needs to be fixed eventually.
+ */
+static int ni_ao_fifo_half_empty(comedi_device * dev, comedi_subdevice * s)
+{
+	int n;
+
+	n = comedi_buf_read_n_available(s->async);
+	if (n == 0) {
+		s->async->events |= COMEDI_CB_OVERFLOW;
+		return 0;
+	}
+
+	n /= sizeof(sampl_t);
+	if (n > boardtype.ao_fifo_depth / 2)
+		n = boardtype.ao_fifo_depth / 2;
+
+	ni_ao_fifo_load(dev, s, n);
+
+	s->async->events |= COMEDI_CB_BLOCK;
+
+	return 1;
+}
+
+static int ni_ao_prep_fifo(comedi_device * dev, comedi_subdevice * s)
+{
+	int n;
+
+	/* reset fifo */
+	devpriv->stc_writew(dev, 1, DAC_FIFO_Clear);
+	if (boardtype.reg_type & ni_reg_6xxx_mask)
+		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
+
+	/* load some data */
+	n = comedi_buf_read_n_available(s->async);
+	if (n == 0)
+		return 0;
+
+	n /= sizeof(sampl_t);
+	if (n > boardtype.ao_fifo_depth)
+		n = boardtype.ao_fifo_depth;
+
+	ni_ao_fifo_load(dev, s, n);
+
+	return n;
+}
+
+static void ni_ai_fifo_read(comedi_device * dev, comedi_subdevice * s, int n)
+{
+	comedi_async *async = s->async;
+	int i;
+
+	if (boardtype.reg_type == ni_reg_611x) {
+		sampl_t data[2];
+		u32 dl;
+
+		for (i = 0; i < n / 2; i++) {
+			dl = ni_readl(ADC_FIFO_Data_611x);
+			/* This may get the hi/lo data in the wrong order */
+			data[0] = (dl >> 16) & 0xffff;
+			data[1] = dl & 0xffff;
+			cfc_write_array_to_buffer(s, data, sizeof(data));
+		}
+		/* Check if there's a single sample stuck in the FIFO */
+		if (n % 2) {
+			dl = ni_readl(ADC_FIFO_Data_611x);
+			data[0] = dl & 0xffff;
+			cfc_write_to_buffer(s, data[0]);
+		}
+	} else if (boardtype.reg_type == ni_reg_6143) {
+		sampl_t data[2];
+		u32 dl;
+
+		// This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed
+		for (i = 0; i < n / 2; i++) {
+			dl = ni_readl(AIFIFO_Data_6143);
+
+			data[0] = (dl >> 16) & 0xffff;
+			data[1] = dl & 0xffff;
+			cfc_write_array_to_buffer(s, data, sizeof(data));
+		}
+		if (n % 2) {
+			/* Assume there is a single sample stuck in the FIFO */
+			ni_writel(0x01, AIFIFO_Control_6143);	// Get stranded sample into FIFO
+			dl = ni_readl(AIFIFO_Data_6143);
+			data[0] = (dl >> 16) & 0xffff;
+			cfc_write_to_buffer(s, data[0]);
+		}
+	} else {
+		if (n > sizeof(devpriv->ai_fifo_buffer) /
+			sizeof(devpriv->ai_fifo_buffer[0])) {
+			comedi_error(dev, "bug! ai_fifo_buffer too small");
+			async->events |= COMEDI_CB_ERROR;
+			return;
+		}
+		for (i = 0; i < n; i++) {
+			devpriv->ai_fifo_buffer[i] =
+				ni_readw(ADC_FIFO_Data_Register);
+		}
+		cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
+			n * sizeof(devpriv->ai_fifo_buffer[0]));
+	}
+}
+
+static void ni_handle_fifo_half_full(comedi_device * dev)
+{
+	int n;
+	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+
+	n = boardtype.ai_fifo_depth / 2;
+
+	ni_ai_fifo_read(dev, s, n);
+}
+#endif
+
+#ifdef PCIDMA
+static int ni_ai_drain_dma(comedi_device * dev)
+{
+	int i;
+	static const int timeout = 10000;
+	unsigned long flags;
+	int retval = 0;
+
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if (devpriv->ai_mite_chan) {
+		for (i = 0; i < timeout; i++) {
+			if ((devpriv->stc_readw(dev,
+						AI_Status_1_Register) &
+					AI_FIFO_Empty_St)
+				&& mite_bytes_in_transit(devpriv->
+					ai_mite_chan) == 0)
+				break;
+			comedi_udelay(5);
+		}
+		if (i == timeout) {
+			rt_printk
+				("ni_mio_common: wait for dma drain timed out\n");
+			rt_printk
+				("mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
+				mite_bytes_in_transit(devpriv->ai_mite_chan),
+				devpriv->stc_readw(dev, AI_Status_1_Register));
+			retval = -1;
+		}
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+
+	ni_sync_ai_dma(dev);
+
+	return retval;
+}
+#endif
+/*
+   Empties the AI fifo
+*/
+static void ni_handle_fifo_dregs(comedi_device * dev)
+{
+	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	sampl_t data[2];
+	u32 dl;
+	short fifo_empty;
+	int i;
+
+	if (boardtype.reg_type == ni_reg_611x) {
+		while ((devpriv->stc_readw(dev,
+					AI_Status_1_Register) &
+				AI_FIFO_Empty_St) == 0) {
+			dl = ni_readl(ADC_FIFO_Data_611x);
+
+			/* This may get the hi/lo data in the wrong order */
+			data[0] = (dl >> 16);
+			data[1] = (dl & 0xffff);
+			cfc_write_array_to_buffer(s, data, sizeof(data));
+		}
+	} else if (boardtype.reg_type == ni_reg_6143) {
+		i = 0;
+		while (ni_readl(AIFIFO_Status_6143) & 0x04) {
+			dl = ni_readl(AIFIFO_Data_6143);
+
+			/* This may get the hi/lo data in the wrong order */
+			data[0] = (dl >> 16);
+			data[1] = (dl & 0xffff);
+			cfc_write_array_to_buffer(s, data, sizeof(data));
+			i += 2;
+		}
+		// Check if stranded sample is present
+		if (ni_readl(AIFIFO_Status_6143) & 0x01) {
+			ni_writel(0x01, AIFIFO_Control_6143);	// Get stranded sample into FIFO
+			dl = ni_readl(AIFIFO_Data_6143);
+			data[0] = (dl >> 16) & 0xffff;
+			cfc_write_to_buffer(s, data[0]);
+		}
+
+	} else {
+		fifo_empty =
+			devpriv->stc_readw(dev,
+			AI_Status_1_Register) & AI_FIFO_Empty_St;
+		while (fifo_empty == 0) {
+			for (i = 0;
+				i <
+				sizeof(devpriv->ai_fifo_buffer) /
+				sizeof(devpriv->ai_fifo_buffer[0]); i++) {
+				fifo_empty =
+					devpriv->stc_readw(dev,
+					AI_Status_1_Register) &
+					AI_FIFO_Empty_St;
+				if (fifo_empty)
+					break;
+				devpriv->ai_fifo_buffer[i] =
+					ni_readw(ADC_FIFO_Data_Register);
+			}
+			cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
+				i * sizeof(devpriv->ai_fifo_buffer[0]));
+		}
+	}
+}
+
+static void get_last_sample_611x(comedi_device * dev)
+{
+	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	sampl_t data;
+	u32 dl;
+
+	if (boardtype.reg_type != ni_reg_611x)
+		return;
+
+	/* Check if there's a single sample stuck in the FIFO */
+	if (ni_readb(XXX_Status) & 0x80) {
+		dl = ni_readl(ADC_FIFO_Data_611x);
+		data = (dl & 0xffff);
+		cfc_write_to_buffer(s, data);
+	}
+}
+
+static void get_last_sample_6143(comedi_device * dev)
+{
+	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	sampl_t data;
+	u32 dl;
+
+	if (boardtype.reg_type != ni_reg_6143)
+		return;
+
+	/* Check if there's a single sample stuck in the FIFO */
+	if (ni_readl(AIFIFO_Status_6143) & 0x01) {
+		ni_writel(0x01, AIFIFO_Control_6143);	// Get stranded sample into FIFO
+		dl = ni_readl(AIFIFO_Data_6143);
+
+		/* This may get the hi/lo data in the wrong order */
+		data = (dl >> 16) & 0xffff;
+		cfc_write_to_buffer(s, data);
+	}
+}
+
+static void ni_ai_munge(comedi_device * dev, comedi_subdevice * s,
+	void *data, unsigned int num_bytes, unsigned int chan_index)
+{
+	comedi_async *async = s->async;
+	unsigned int i;
+	unsigned int length = num_bytes / bytes_per_sample(s);
+	sampl_t *array = data;
+	lsampl_t *larray = data;
+	for (i = 0; i < length; i++) {
+#ifdef PCIDMA
+		if (s->subdev_flags & SDF_LSAMPL)
+			larray[i] = le32_to_cpu(larray[i]);
+		else
+			array[i] = le16_to_cpu(array[i]);
+#endif
+		if (s->subdev_flags & SDF_LSAMPL)
+			larray[i] += devpriv->ai_offset[chan_index];
+		else
+			array[i] += devpriv->ai_offset[chan_index];
+		chan_index++;
+		chan_index %= async->cmd.chanlist_len;
+	}
+}
+
+#ifdef PCIDMA
+
+static int ni_ai_setup_MITE_dma(comedi_device * dev)
+{
+	comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
+	int retval;
+	unsigned long flags;
+
+	retval = ni_request_ai_mite_channel(dev);
+	if (retval)
+		return retval;
+//      rt_printk("comedi_debug: using mite channel %i for ai.\n", devpriv->ai_mite_chan->channel);
+
+	/* write alloc the entire buffer */
+	comedi_buf_write_alloc(s->async, s->async->prealloc_bufsz);
+
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if(devpriv->ai_mite_chan == NULL)
+	{
+		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+		return -EIO;
+	}
+
+	switch (boardtype.reg_type) {
+	case ni_reg_611x:
+	case ni_reg_6143:
+		mite_prep_dma(devpriv->ai_mite_chan, 32, 16);
+		break;
+	case ni_reg_628x:
+		mite_prep_dma(devpriv->ai_mite_chan, 32, 32);
+		break;
+	default:
+		mite_prep_dma(devpriv->ai_mite_chan, 16, 16);
+		break;
+	};
+	/*start the MITE */
+	mite_dma_arm(devpriv->ai_mite_chan);
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+
+	return 0;
+}
+
+static int ni_ao_setup_MITE_dma(comedi_device * dev)
+{
+	comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
+	int retval;
+	unsigned long flags;
+
+	retval = ni_request_ao_mite_channel(dev);
+	if (retval)
+		return retval;
+
+	/* read alloc the entire buffer */
+	comedi_buf_read_alloc(s->async, s->async->prealloc_bufsz);
+
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if (devpriv->ao_mite_chan) {
+		if (boardtype.reg_type & (ni_reg_611x | ni_reg_6713)) {
+			mite_prep_dma(devpriv->ao_mite_chan, 32, 32);
+		} else {
+			/* doing 32 instead of 16 bit wide transfers from memory
+			   makes the mite do 32 bit pci transfers, doubling pci bandwidth. */
+			mite_prep_dma(devpriv->ao_mite_chan, 16, 32);
+		}
+		mite_dma_arm(devpriv->ao_mite_chan);
+	} else
+		retval = -EIO;
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+
+	return retval;
+}
+
+#endif // PCIDMA
+
+/*
+   used for both cancel ioctl and board initialization
+
+   this is pretty harsh for a cancel, but it works...
+ */
+
+static int ni_ai_reset(comedi_device * dev, comedi_subdevice * s)
+{
+	ni_release_ai_mite_channel(dev);
+	/* ai configuration */
+	devpriv->stc_writew(dev, AI_Configuration_Start | AI_Reset,
+		Joint_Reset_Register);
+
+	ni_set_bits(dev, Interrupt_A_Enable_Register,
+		AI_SC_TC_Interrupt_Enable | AI_START1_Interrupt_Enable |
+		AI_START2_Interrupt_Enable | AI_START_Interrupt_Enable |
+		AI_STOP_Interrupt_Enable | AI_Error_Interrupt_Enable |
+		AI_FIFO_Interrupt_Enable, 0);
+
+	ni_clear_ai_fifo(dev);
+
+	if (boardtype.reg_type != ni_reg_6143)
+		ni_writeb(0, Misc_Command);
+
+	devpriv->stc_writew(dev, AI_Disarm, AI_Command_1_Register);	/* reset pulses */
+	devpriv->stc_writew(dev,
+		AI_Start_Stop | AI_Mode_1_Reserved /*| AI_Trigger_Once */ ,
+		AI_Mode_1_Register);
+	devpriv->stc_writew(dev, 0x0000, AI_Mode_2_Register);
+	/* generate FIFO interrupts on non-empty */
+	devpriv->stc_writew(dev, (0 << 6) | 0x0000, AI_Mode_3_Register);
+	if (boardtype.reg_type == ni_reg_611x) {
+		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
+			AI_SOC_Polarity |
+			AI_LOCALMUX_CLK_Pulse_Width, AI_Personal_Register);
+		devpriv->stc_writew(dev, AI_SCAN_IN_PROG_Output_Select(3) |
+			AI_EXTMUX_CLK_Output_Select(0) |
+			AI_LOCALMUX_CLK_Output_Select(2) |
+			AI_SC_TC_Output_Select(3) |
+			AI_CONVERT_Output_Select(AI_CONVERT_Output_Enable_High),
+			AI_Output_Control_Register);
+	} else if (boardtype.reg_type == ni_reg_6143) {
+		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
+			AI_SOC_Polarity |
+			AI_LOCALMUX_CLK_Pulse_Width, AI_Personal_Register);
+		devpriv->stc_writew(dev, AI_SCAN_IN_PROG_Output_Select(3) |
+			AI_EXTMUX_CLK_Output_Select(0) |
+			AI_LOCALMUX_CLK_Output_Select(2) |
+			AI_SC_TC_Output_Select(3) |
+			AI_CONVERT_Output_Select(AI_CONVERT_Output_Enable_Low),
+			AI_Output_Control_Register);
+	} else {
+		unsigned ai_output_control_bits;
+		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
+			AI_SOC_Polarity |
+			AI_CONVERT_Pulse_Width |
+			AI_LOCALMUX_CLK_Pulse_Width, AI_Personal_Register);
+		ai_output_control_bits = AI_SCAN_IN_PROG_Output_Select(3) |
+			AI_EXTMUX_CLK_Output_Select(0) |
+			AI_LOCALMUX_CLK_Output_Select(2) |
+			AI_SC_TC_Output_Select(3);
+		if (boardtype.reg_type == ni_reg_622x)
+			ai_output_control_bits |=
+				AI_CONVERT_Output_Select
+				(AI_CONVERT_Output_Enable_High);
+		else
+			ai_output_control_bits |=
+				AI_CONVERT_Output_Select
+				(AI_CONVERT_Output_Enable_Low);
+		devpriv->stc_writew(dev, ai_output_control_bits,
+			AI_Output_Control_Register);
+	}
+	/* the following registers should not be changed, because there
+	 * are no backup registers in devpriv.  If you want to change
+	 * any of these, add a backup register and other appropriate code:
+	 *      AI_Mode_1_Register
+	 *      AI_Mode_3_Register
+	 *      AI_Personal_Register
+	 *      AI_Output_Control_Register
+	 */
+	devpriv->stc_writew(dev, AI_SC_TC_Error_Confirm | AI_START_Interrupt_Ack | AI_START2_Interrupt_Ack | AI_START1_Interrupt_Ack | AI_SC_TC_Interrupt_Ack | AI_Error_Interrupt_Ack | AI_STOP_Interrupt_Ack, Interrupt_A_Ack_Register);	/* clear interrupts */
+
+	devpriv->stc_writew(dev, AI_Configuration_End, Joint_Reset_Register);
+
+	return 0;
+}
+
+static int ni_ai_poll(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long flags = 0;
+	int count;
+
+	// lock to avoid race with interrupt handler
+	if (in_interrupt() == 0)
+		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+#ifndef PCIDMA
+	ni_handle_fifo_dregs(dev);
+#else
+	ni_sync_ai_dma(dev);
+#endif
+	count = s->async->buf_write_count - s->async->buf_read_count;
+	if (in_interrupt() == 0)
+		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	return count;
+}
+
+static int ni_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i, n;
+	const unsigned int mask = (1 << boardtype.adbits) - 1;
+	unsigned signbits;
+	unsigned short d;
+	unsigned long dl;
+
+	ni_load_channelgain_list(dev, 1, &insn->chanspec);
+
+	ni_clear_ai_fifo(dev);
+
+	signbits = devpriv->ai_offset[0];
+	if (boardtype.reg_type == ni_reg_611x) {
+		for (n = 0; n < num_adc_stages_611x; n++) {
+			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
+				AI_Command_1_Register);
+			comedi_udelay(1);
+		}
+		for (n = 0; n < insn->n; n++) {
+			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
+				AI_Command_1_Register);
+			/* The 611x has screwy 32-bit FIFOs. */
+			d = 0;
+			for (i = 0; i < NI_TIMEOUT; i++) {
+				if (ni_readb(XXX_Status) & 0x80) {
+					d = (ni_readl(ADC_FIFO_Data_611x) >> 16)
+						& 0xffff;
+					break;
+				}
+				if (!(devpriv->stc_readw(dev,
+							AI_Status_1_Register) &
+						AI_FIFO_Empty_St)) {
+					d = ni_readl(ADC_FIFO_Data_611x) &
+						0xffff;
+					break;
+				}
+			}
+			if (i == NI_TIMEOUT) {
+				rt_printk
+					("ni_mio_common: timeout in 611x ni_ai_insn_read\n");
+				return -ETIME;
+			}
+			d += signbits;
+			data[n] = d;
+		}
+	} else if (boardtype.reg_type == ni_reg_6143) {
+		for (n = 0; n < insn->n; n++) {
+			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
+				AI_Command_1_Register);
+
+			/* The 6143 has 32-bit FIFOs. You need to strobe a bit to move a single 16bit stranded sample into the FIFO */
+			dl = 0;
+			for (i = 0; i < NI_TIMEOUT; i++) {
+				if (ni_readl(AIFIFO_Status_6143) & 0x01) {
+					ni_writel(0x01, AIFIFO_Control_6143);	// Get stranded sample into FIFO
+					dl = ni_readl(AIFIFO_Data_6143);
+					break;
+				}
+			}
+			if (i == NI_TIMEOUT) {
+				rt_printk
+					("ni_mio_common: timeout in 6143 ni_ai_insn_read\n");
+				return -ETIME;
+			}
+			data[n] = (((dl >> 16) & 0xFFFF) + signbits) & 0xFFFF;
+		}
+	} else {
+		for (n = 0; n < insn->n; n++) {
+			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
+				AI_Command_1_Register);
+			for (i = 0; i < NI_TIMEOUT; i++) {
+				if (!(devpriv->stc_readw(dev,
+							AI_Status_1_Register) &
+						AI_FIFO_Empty_St))
+					break;
+			}
+			if (i == NI_TIMEOUT) {
+				rt_printk
+					("ni_mio_common: timeout in ni_ai_insn_read\n");
+				return -ETIME;
+			}
+			if (boardtype.reg_type & ni_reg_m_series_mask) {
+				data[n] =
+					ni_readl(M_Offset_AI_FIFO_Data) & mask;
+			} else {
+				d = ni_readw(ADC_FIFO_Data_Register);
+				d += signbits;	/* subtle: needs to be short addition */
+				data[n] = d;
+			}
+		}
+	}
+	return insn->n;
+}
+
+void ni_prime_channelgain_list(comedi_device * dev)
+{
+	int i;
+	devpriv->stc_writew(dev, AI_CONVERT_Pulse, AI_Command_1_Register);
+	for (i = 0; i < NI_TIMEOUT; ++i) {
+		if (!(devpriv->stc_readw(dev,
+					AI_Status_1_Register) &
+				AI_FIFO_Empty_St)) {
+			devpriv->stc_writew(dev, 1, ADC_FIFO_Clear);
+			return;
+		}
+		comedi_udelay(1);
+	}
+	rt_printk("ni_mio_common: timeout loading channel/gain list\n");
+}
+
+static void ni_m_series_load_channelgain_list(comedi_device * dev,
+	unsigned int n_chan, unsigned int *list)
+{
+	unsigned int chan, range, aref;
+	unsigned int i;
+	unsigned offset;
+	unsigned int dither;
+	unsigned range_code;
+
+	devpriv->stc_writew(dev, 1, Configuration_Memory_Clear);
+
+//      offset = 1 << (boardtype.adbits - 1);
+	if ((list[0] & CR_ALT_SOURCE)) {
+		unsigned bypass_bits;
+		chan = CR_CHAN(list[0]);
+		range = CR_RANGE(list[0]);
+		range_code = ni_gainlkup[boardtype.gainlkup][range];
+		dither = ((list[0] & CR_ALT_FILTER) != 0);
+		bypass_bits = MSeries_AI_Bypass_Config_FIFO_Bit;
+		bypass_bits |= chan;
+		bypass_bits |=
+			(devpriv->
+			ai_calib_source) & (MSeries_AI_Bypass_Cal_Sel_Pos_Mask |
+			MSeries_AI_Bypass_Cal_Sel_Neg_Mask |
+			MSeries_AI_Bypass_Mode_Mux_Mask |
+			MSeries_AO_Bypass_AO_Cal_Sel_Mask);
+		bypass_bits |= MSeries_AI_Bypass_Gain_Bits(range_code);
+		if (dither)
+			bypass_bits |= MSeries_AI_Bypass_Dither_Bit;
+		// don't use 2's complement encoding
+		bypass_bits |= MSeries_AI_Bypass_Polarity_Bit;
+		ni_writel(bypass_bits, M_Offset_AI_Config_FIFO_Bypass);
+	} else {
+		ni_writel(0, M_Offset_AI_Config_FIFO_Bypass);
+	}
+	offset = 0;
+	for (i = 0; i < n_chan; i++) {
+		unsigned config_bits = 0;
+		chan = CR_CHAN(list[i]);
+		aref = CR_AREF(list[i]);
+		range = CR_RANGE(list[i]);
+		dither = ((list[i] & CR_ALT_FILTER) != 0);
+
+		range_code = ni_gainlkup[boardtype.gainlkup][range];
+		devpriv->ai_offset[i] = offset;
+		switch (aref) {
+		case AREF_DIFF:
+			config_bits |=
+				MSeries_AI_Config_Channel_Type_Differential_Bits;
+			break;
+		case AREF_COMMON:
+			config_bits |=
+				MSeries_AI_Config_Channel_Type_Common_Ref_Bits;
+			break;
+		case AREF_GROUND:
+			config_bits |=
+				MSeries_AI_Config_Channel_Type_Ground_Ref_Bits;
+			break;
+		case AREF_OTHER:
+			break;
+		}
+		config_bits |= MSeries_AI_Config_Channel_Bits(chan);
+		config_bits |=
+			MSeries_AI_Config_Bank_Bits(boardtype.reg_type, chan);
+		config_bits |= MSeries_AI_Config_Gain_Bits(range_code);
+		if (i == n_chan - 1)
+			config_bits |= MSeries_AI_Config_Last_Channel_Bit;
+		if (dither)
+			config_bits |= MSeries_AI_Config_Dither_Bit;
+		// don't use 2's complement encoding
+		config_bits |= MSeries_AI_Config_Polarity_Bit;
+		ni_writew(config_bits, M_Offset_AI_Config_FIFO_Data);
+	}
+	ni_prime_channelgain_list(dev);
+}
+
+/*
+ * Notes on the 6110 and 6111:
+ * These boards a slightly different than the rest of the series, since
+ * they have multiple A/D converters.
+ * From the driver side, the configuration memory is a
+ * little different.
+ * Configuration Memory Low:
+ *   bits 15-9: same
+ *   bit 8: unipolar/bipolar (should be 0 for bipolar)
+ *   bits 0-3: gain.  This is 4 bits instead of 3 for the other boards
+ *       1001 gain=0.1 (+/- 50)
+ *       1010 0.2
+ *       1011 0.1
+ *       0001 1
+ *       0010 2
+ *       0011 5
+ *       0100 10
+ *       0101 20
+ *       0110 50
+ * Configuration Memory High:
+ *   bits 12-14: Channel Type
+ *       001 for differential
+ *       000 for calibration
+ *   bit 11: coupling  (this is not currently handled)
+ *       1 AC coupling
+ *       0 DC coupling
+ *   bits 0-2: channel
+ *       valid channels are 0-3
+ */
+static void ni_load_channelgain_list(comedi_device * dev, unsigned int n_chan,
+	unsigned int *list)
+{
+	unsigned int chan, range, aref;
+	unsigned int i;
+	unsigned int hi, lo;
+	unsigned offset;
+	unsigned int dither;
+
+	if (boardtype.reg_type & ni_reg_m_series_mask) {
+		ni_m_series_load_channelgain_list(dev, n_chan, list);
+		return;
+	}
+	if (n_chan == 1 && (boardtype.reg_type != ni_reg_611x)
+		&& (boardtype.reg_type != ni_reg_6143)) {
+		if (devpriv->changain_state
+			&& devpriv->changain_spec == list[0]) {
+			// ready to go.
+			return;
+		}
+		devpriv->changain_state = 1;
+		devpriv->changain_spec = list[0];
+	} else {
+		devpriv->changain_state = 0;
+	}
+
+	devpriv->stc_writew(dev, 1, Configuration_Memory_Clear);
+
+	// Set up Calibration mode if required
+	if (boardtype.reg_type == ni_reg_6143) {
+		if ((list[0] & CR_ALT_SOURCE)
+			&& !devpriv->ai_calib_source_enabled) {
+			// Strobe Relay enable bit
+			ni_writew(devpriv->
+				ai_calib_source |
+				Calibration_Channel_6143_RelayOn,
+				Calibration_Channel_6143);
+			ni_writew(devpriv->ai_calib_source,
+				Calibration_Channel_6143);
+			devpriv->ai_calib_source_enabled = 1;
+			msleep_interruptible(100);	// Allow relays to change
+		} else if (!(list[0] & CR_ALT_SOURCE)
+			&& devpriv->ai_calib_source_enabled) {
+			// Strobe Relay disable bit
+			ni_writew(devpriv->
+				ai_calib_source |
+				Calibration_Channel_6143_RelayOff,
+				Calibration_Channel_6143);
+			ni_writew(devpriv->ai_calib_source,
+				Calibration_Channel_6143);
+			devpriv->ai_calib_source_enabled = 0;
+			msleep_interruptible(100);	// Allow relays to change
+		}
+	}
+
+	offset = 1 << (boardtype.adbits - 1);
+	for (i = 0; i < n_chan; i++) {
+		if ((boardtype.reg_type != ni_reg_6143)
+			&& (list[i] & CR_ALT_SOURCE)) {
+			chan = devpriv->ai_calib_source;
+		} else {
+			chan = CR_CHAN(list[i]);
+		}
+		aref = CR_AREF(list[i]);
+		range = CR_RANGE(list[i]);
+		dither = ((list[i] & CR_ALT_FILTER) != 0);
+
+		/* fix the external/internal range differences */
+		range = ni_gainlkup[boardtype.gainlkup][range];
+		if (boardtype.reg_type == ni_reg_611x)
+			devpriv->ai_offset[i] = offset;
+		else
+			devpriv->ai_offset[i] = (range & 0x100) ? 0 : offset;
+
+		hi = 0;
+		if ((list[i] & CR_ALT_SOURCE)) {
+			if (boardtype.reg_type == ni_reg_611x)
+				ni_writew(CR_CHAN(list[i]) & 0x0003,
+					Calibration_Channel_Select_611x);
+		} else {
+			if (boardtype.reg_type == ni_reg_611x)
+				aref = AREF_DIFF;
+			else if (boardtype.reg_type == ni_reg_6143)
+				aref = AREF_OTHER;
+			switch (aref) {
+			case AREF_DIFF:
+				hi |= AI_DIFFERENTIAL;
+				break;
+			case AREF_COMMON:
+				hi |= AI_COMMON;
+				break;
+			case AREF_GROUND:
+				hi |= AI_GROUND;
+				break;
+			case AREF_OTHER:
+				break;
+			}
+		}
+		hi |= AI_CONFIG_CHANNEL(chan);
+
+		ni_writew(hi, Configuration_Memory_High);
+
+		if (boardtype.reg_type != ni_reg_6143) {
+			lo = range;
+			if (i == n_chan - 1)
+				lo |= AI_LAST_CHANNEL;
+			if (dither)
+				lo |= AI_DITHER;
+
+			ni_writew(lo, Configuration_Memory_Low);
+		}
+	}
+
+	/* prime the channel/gain list */
+	if ((boardtype.reg_type != ni_reg_611x)
+		&& (boardtype.reg_type != ni_reg_6143)) {
+		ni_prime_channelgain_list(dev);
+	}
+}
+
+static int ni_ns_to_timer(const comedi_device * dev, unsigned nanosec,
+	int round_mode)
+{
+	int divider;
+	switch (round_mode) {
+	case TRIG_ROUND_NEAREST:
+	default:
+		divider = (nanosec + devpriv->clock_ns / 2) / devpriv->clock_ns;
+		break;
+	case TRIG_ROUND_DOWN:
+		divider = (nanosec) / devpriv->clock_ns;
+		break;
+	case TRIG_ROUND_UP:
+		divider = (nanosec + devpriv->clock_ns - 1) / devpriv->clock_ns;
+		break;
+	}
+	return divider - 1;
+}
+
+static unsigned ni_timer_to_ns(const comedi_device * dev, int timer)
+{
+	return devpriv->clock_ns * (timer + 1);
+}
+
+static unsigned ni_min_ai_scan_period_ns(comedi_device * dev,
+	unsigned num_channels)
+{
+	switch (boardtype.reg_type) {
+	case ni_reg_611x:
+	case ni_reg_6143:
+		// simultaneously-sampled inputs
+		return boardtype.ai_speed;
+		break;
+	default:
+		// multiplexed inputs
+		break;
+	};
+	return boardtype.ai_speed * num_channels;
+}
+
+static int ni_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+	int sources;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	if ((cmd->flags & CMDF_WRITE)) {
+		cmd->flags &= ~CMDF_WRITE;
+	}
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_INT | TRIG_EXT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	sources = TRIG_TIMER | TRIG_EXT;
+	if ((boardtype.reg_type == ni_reg_611x)
+		|| (boardtype.reg_type == ni_reg_6143))
+		sources |= TRIG_NOW;
+	cmd->convert_src &= sources;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	/* note that mutual compatiblity is not an issue here */
+	if (cmd->start_src != TRIG_NOW &&
+		cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)
+		err++;
+	if (cmd->scan_begin_src != TRIG_TIMER &&
+		cmd->scan_begin_src != TRIG_EXT &&
+		cmd->scan_begin_src != TRIG_OTHER)
+		err++;
+	if (cmd->convert_src != TRIG_TIMER &&
+		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_src == TRIG_EXT) {
+		/* external trigger */
+		unsigned int tmp = CR_CHAN(cmd->start_arg);
+
+		if (tmp > 16)
+			tmp = 16;
+		tmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));
+		if (cmd->start_arg != tmp) {
+			cmd->start_arg = tmp;
+			err++;
+		}
+	} else {
+		if (cmd->start_arg != 0) {
+			/* true for both TRIG_NOW and TRIG_INT */
+			cmd->start_arg = 0;
+			err++;
+		}
+	}
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		if (cmd->scan_begin_arg < ni_min_ai_scan_period_ns(dev,
+				cmd->chanlist_len)) {
+			cmd->scan_begin_arg =
+				ni_min_ai_scan_period_ns(dev,
+				cmd->chanlist_len);
+			err++;
+		}
+		if (cmd->scan_begin_arg > devpriv->clock_ns * 0xffffff) {
+			cmd->scan_begin_arg = devpriv->clock_ns * 0xffffff;
+			err++;
+		}
+	} else if (cmd->scan_begin_src == TRIG_EXT) {
+		/* external trigger */
+		unsigned int tmp = CR_CHAN(cmd->scan_begin_arg);
+
+		if (tmp > 16)
+			tmp = 16;
+		tmp |= (cmd->scan_begin_arg & (CR_INVERT | CR_EDGE));
+		if (cmd->scan_begin_arg != tmp) {
+			cmd->scan_begin_arg = tmp;
+			err++;
+		}
+	} else {		/* TRIG_OTHER */
+		if (cmd->scan_begin_arg) {
+			cmd->scan_begin_arg = 0;
+			err++;
+		}
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		if ((boardtype.reg_type == ni_reg_611x)
+			|| (boardtype.reg_type == ni_reg_6143)) {
+			if (cmd->convert_arg != 0) {
+				cmd->convert_arg = 0;
+				err++;
+			}
+		} else {
+			if (cmd->convert_arg < boardtype.ai_speed) {
+				cmd->convert_arg = boardtype.ai_speed;
+				err++;
+			}
+			if (cmd->convert_arg > devpriv->clock_ns * 0xffff) {
+				cmd->convert_arg = devpriv->clock_ns * 0xffff;
+				err++;
+			}
+		}
+	} else if (cmd->convert_src == TRIG_EXT) {
+		/* external trigger */
+		unsigned int tmp = CR_CHAN(cmd->convert_arg);
+
+		if (tmp > 16)
+			tmp = 16;
+		tmp |= (cmd->convert_arg & (CR_ALT_FILTER | CR_INVERT));
+		if (cmd->convert_arg != tmp) {
+			cmd->convert_arg = tmp;
+			err++;
+		}
+	} else if (cmd->convert_src == TRIG_NOW) {
+		if (cmd->convert_arg != 0) {
+			cmd->convert_arg = 0;
+			err++;
+		}
+	}
+
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_COUNT) {
+		unsigned int max_count = 0x01000000;
+
+		if (boardtype.reg_type == ni_reg_611x)
+			max_count -= num_adc_stages_611x;
+		if (cmd->stop_arg > max_count) {
+			cmd->stop_arg = max_count;
+			err++;
+		}
+		if (cmd->stop_arg < 1) {
+			cmd->stop_arg = 1;
+			err++;
+		}
+	} else {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		tmp = cmd->scan_begin_arg;
+		cmd->scan_begin_arg =
+			ni_timer_to_ns(dev, ni_ns_to_timer(dev,
+				cmd->scan_begin_arg,
+				cmd->flags & TRIG_ROUND_MASK));
+		if (tmp != cmd->scan_begin_arg)
+			err++;
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		if ((boardtype.reg_type != ni_reg_611x)
+			&& (boardtype.reg_type != ni_reg_6143)) {
+			tmp = cmd->convert_arg;
+			cmd->convert_arg =
+				ni_timer_to_ns(dev, ni_ns_to_timer(dev,
+					cmd->convert_arg,
+					cmd->flags & TRIG_ROUND_MASK));
+			if (tmp != cmd->convert_arg)
+				err++;
+			if (cmd->scan_begin_src == TRIG_TIMER &&
+				cmd->scan_begin_arg <
+				cmd->convert_arg * cmd->scan_end_arg) {
+				cmd->scan_begin_arg =
+					cmd->convert_arg * cmd->scan_end_arg;
+				err++;
+			}
+		}
+	}
+
+	if (err)
+		return 4;
+
+	return 0;
+}
+
+static int ni_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	const comedi_cmd *cmd = &s->async->cmd;
+	int timer;
+	int mode1 = 0;		/* mode1 is needed for both stop and convert */
+	int mode2 = 0;
+	int start_stop_select = 0;
+	unsigned int stop_count;
+	int interrupt_a_enable = 0;
+
+	MDPRINTK("ni_ai_cmd\n");
+	if (dev->irq == 0) {
+		comedi_error(dev, "cannot run command without an irq");
+		return -EIO;
+	}
+	ni_clear_ai_fifo(dev);
+
+	ni_load_channelgain_list(dev, cmd->chanlist_len, cmd->chanlist);
+
+	/* start configuration */
+	devpriv->stc_writew(dev, AI_Configuration_Start, Joint_Reset_Register);
+
+	/* disable analog triggering for now, since it
+	 * interferes with the use of pfi0 */
+	devpriv->an_trig_etc_reg &= ~Analog_Trigger_Enable;
+	devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
+		Analog_Trigger_Etc_Register);
+
+	switch (cmd->start_src) {
+	case TRIG_INT:
+	case TRIG_NOW:
+		devpriv->stc_writew(dev, AI_START2_Select(0) |
+			AI_START1_Sync | AI_START1_Edge | AI_START1_Select(0),
+			AI_Trigger_Select_Register);
+		break;
+	case TRIG_EXT:
+		{
+			int chan = CR_CHAN(cmd->start_arg);
+			unsigned int bits = AI_START2_Select(0) |
+				AI_START1_Sync | AI_START1_Select(chan + 1);
+
+			if (cmd->start_arg & CR_INVERT)
+				bits |= AI_START1_Polarity;
+			if (cmd->start_arg & CR_EDGE)
+				bits |= AI_START1_Edge;
+			devpriv->stc_writew(dev, bits,
+				AI_Trigger_Select_Register);
+			break;
+		}
+	}
+
+	mode2 &= ~AI_Pre_Trigger;
+	mode2 &= ~AI_SC_Initial_Load_Source;
+	mode2 &= ~AI_SC_Reload_Mode;
+	devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
+
+	if (cmd->chanlist_len == 1 || (boardtype.reg_type == ni_reg_611x)
+		|| (boardtype.reg_type == ni_reg_6143)) {
+		start_stop_select |= AI_STOP_Polarity;
+		start_stop_select |= AI_STOP_Select(31);	// logic low
+		start_stop_select |= AI_STOP_Sync;
+	} else {
+		start_stop_select |= AI_STOP_Select(19);	// ai configuration memory
+	}
+	devpriv->stc_writew(dev, start_stop_select,
+		AI_START_STOP_Select_Register);
+
+	devpriv->ai_cmd2 = 0;
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		stop_count = cmd->stop_arg - 1;
+
+		if (boardtype.reg_type == ni_reg_611x) {
+			// have to take 3 stage adc pipeline into account
+			stop_count += num_adc_stages_611x;
+		}
+		/* stage number of scans */
+		devpriv->stc_writel(dev, stop_count, AI_SC_Load_A_Registers);
+
+		mode1 |= AI_Start_Stop | AI_Mode_1_Reserved | AI_Trigger_Once;
+		devpriv->stc_writew(dev, mode1, AI_Mode_1_Register);
+		/* load SC (Scan Count) */
+		devpriv->stc_writew(dev, AI_SC_Load, AI_Command_1_Register);
+
+		devpriv->ai_continuous = 0;
+		if (stop_count == 0) {
+			devpriv->ai_cmd2 |= AI_End_On_End_Of_Scan;
+			interrupt_a_enable |= AI_STOP_Interrupt_Enable;
+			// this is required to get the last sample for chanlist_len > 1, not sure why
+			if (cmd->chanlist_len > 1)
+				start_stop_select |=
+					AI_STOP_Polarity | AI_STOP_Edge;
+		}
+		break;
+	case TRIG_NONE:
+		/* stage number of scans */
+		devpriv->stc_writel(dev, 0, AI_SC_Load_A_Registers);
+
+		mode1 |= AI_Start_Stop | AI_Mode_1_Reserved | AI_Continuous;
+		devpriv->stc_writew(dev, mode1, AI_Mode_1_Register);
+
+		/* load SC (Scan Count) */
+		devpriv->stc_writew(dev, AI_SC_Load, AI_Command_1_Register);
+
+		devpriv->ai_continuous = 1;
+
+		break;
+	}
+
+	switch (cmd->scan_begin_src) {
+	case TRIG_TIMER:
+		/*
+		   stop bits for non 611x boards
+		   AI_SI_Special_Trigger_Delay=0
+		   AI_Pre_Trigger=0
+		   AI_START_STOP_Select_Register:
+		   AI_START_Polarity=0 (?)      rising edge
+		   AI_START_Edge=1              edge triggered
+		   AI_START_Sync=1 (?)
+		   AI_START_Select=0            SI_TC
+		   AI_STOP_Polarity=0           rising edge
+		   AI_STOP_Edge=0               level
+		   AI_STOP_Sync=1
+		   AI_STOP_Select=19            external pin (configuration mem)
+		 */
+		start_stop_select |= AI_START_Edge | AI_START_Sync;
+		devpriv->stc_writew(dev, start_stop_select,
+			AI_START_STOP_Select_Register);
+
+		mode2 |= AI_SI_Reload_Mode(0);
+		/* AI_SI_Initial_Load_Source=A */
+		mode2 &= ~AI_SI_Initial_Load_Source;
+		//mode2 |= AI_SC_Reload_Mode;
+		devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
+
+		/* load SI */
+		timer = ni_ns_to_timer(dev, cmd->scan_begin_arg,
+			TRIG_ROUND_NEAREST);
+		devpriv->stc_writel(dev, timer, AI_SI_Load_A_Registers);
+		devpriv->stc_writew(dev, AI_SI_Load, AI_Command_1_Register);
+		break;
+	case TRIG_EXT:
+		if (cmd->scan_begin_arg & CR_EDGE)
+			start_stop_select |= AI_START_Edge;
+		/* AI_START_Polarity==1 is falling edge */
+		if (cmd->scan_begin_arg & CR_INVERT)
+			start_stop_select |= AI_START_Polarity;
+		if (cmd->scan_begin_src != cmd->convert_src ||
+			(cmd->scan_begin_arg & ~CR_EDGE) !=
+			(cmd->convert_arg & ~CR_EDGE))
+			start_stop_select |= AI_START_Sync;
+		start_stop_select |=
+			AI_START_Select(1 + CR_CHAN(cmd->scan_begin_arg));
+		devpriv->stc_writew(dev, start_stop_select,
+			AI_START_STOP_Select_Register);
+		break;
+	}
+
+	switch (cmd->convert_src) {
+	case TRIG_TIMER:
+	case TRIG_NOW:
+		if (cmd->convert_arg == 0 || cmd->convert_src == TRIG_NOW)
+			timer = 1;
+		else
+			timer = ni_ns_to_timer(dev, cmd->convert_arg,
+				TRIG_ROUND_NEAREST);
+		devpriv->stc_writew(dev, 1, AI_SI2_Load_A_Register);	/* 0,0 does not work. */
+		devpriv->stc_writew(dev, timer, AI_SI2_Load_B_Register);
+
+		/* AI_SI2_Reload_Mode = alternate */
+		/* AI_SI2_Initial_Load_Source = A */
+		mode2 &= ~AI_SI2_Initial_Load_Source;
+		mode2 |= AI_SI2_Reload_Mode;
+		devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
+
+		/* AI_SI2_Load */
+		devpriv->stc_writew(dev, AI_SI2_Load, AI_Command_1_Register);
+
+		mode2 |= AI_SI2_Reload_Mode;	// alternate
+		mode2 |= AI_SI2_Initial_Load_Source;	// B
+
+		devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
+		break;
+	case TRIG_EXT:
+		mode1 |= AI_CONVERT_Source_Select(1 + cmd->convert_arg);
+		if ((cmd->convert_arg & CR_INVERT) == 0)
+			mode1 |= AI_CONVERT_Source_Polarity;
+		devpriv->stc_writew(dev, mode1, AI_Mode_1_Register);
+
+		mode2 |= AI_Start_Stop_Gate_Enable | AI_SC_Gate_Enable;
+		devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
+
+		break;
+	}
+
+	if (dev->irq) {
+
+		/* interrupt on FIFO, errors, SC_TC */
+		interrupt_a_enable |= AI_Error_Interrupt_Enable |
+			AI_SC_TC_Interrupt_Enable;
+
+#ifndef PCIDMA
+		interrupt_a_enable |= AI_FIFO_Interrupt_Enable;
+#endif
+
+		if (cmd->flags & TRIG_WAKE_EOS
+			|| (devpriv->ai_cmd2 & AI_End_On_End_Of_Scan)) {
+			/* wake on end-of-scan */
+			devpriv->aimode = AIMODE_SCAN;
+		} else {
+			devpriv->aimode = AIMODE_HALF_FULL;
+		}
+
+		switch (devpriv->aimode) {
+		case AIMODE_HALF_FULL:
+			/*generate FIFO interrupts and DMA requests on half-full */
+#ifdef PCIDMA
+			devpriv->stc_writew(dev, AI_FIFO_Mode_HF_to_E,
+				AI_Mode_3_Register);
+#else
+			devpriv->stc_writew(dev, AI_FIFO_Mode_HF,
+				AI_Mode_3_Register);
+#endif
+			break;
+		case AIMODE_SAMPLE:
+			/*generate FIFO interrupts on non-empty */
+			devpriv->stc_writew(dev, AI_FIFO_Mode_NE,
+				AI_Mode_3_Register);
+			break;
+		case AIMODE_SCAN:
+#ifdef PCIDMA
+			devpriv->stc_writew(dev, AI_FIFO_Mode_NE,
+				AI_Mode_3_Register);
+#else
+			devpriv->stc_writew(dev, AI_FIFO_Mode_HF,
+				AI_Mode_3_Register);
+#endif
+			interrupt_a_enable |= AI_STOP_Interrupt_Enable;
+			break;
+		default:
+			break;
+		}
+
+		devpriv->stc_writew(dev, AI_Error_Interrupt_Ack | AI_STOP_Interrupt_Ack | AI_START_Interrupt_Ack | AI_START2_Interrupt_Ack | AI_START1_Interrupt_Ack | AI_SC_TC_Interrupt_Ack | AI_SC_TC_Error_Confirm, Interrupt_A_Ack_Register);	/* clear interrupts */
+
+		ni_set_bits(dev, Interrupt_A_Enable_Register,
+			interrupt_a_enable, 1);
+
+		MDPRINTK("Interrupt_A_Enable_Register = 0x%04x\n",
+			devpriv->int_a_enable_reg);
+	} else {
+		/* interrupt on nothing */
+		ni_set_bits(dev, Interrupt_A_Enable_Register, ~0, 0);
+
+		/* XXX start polling if necessary */
+		MDPRINTK("interrupting on nothing\n");
+	}
+
+	/* end configuration */
+	devpriv->stc_writew(dev, AI_Configuration_End, Joint_Reset_Register);
+
+	switch (cmd->scan_begin_src) {
+	case TRIG_TIMER:
+		devpriv->stc_writew(dev,
+			AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm | AI_SC_Arm,
+			AI_Command_1_Register);
+		break;
+	case TRIG_EXT:
+		/* XXX AI_SI_Arm? */
+		devpriv->stc_writew(dev,
+			AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm | AI_SC_Arm,
+			AI_Command_1_Register);
+		break;
+	}
+
+#ifdef PCIDMA
+	{
+		int retval = ni_ai_setup_MITE_dma(dev);
+		if (retval)
+			return retval;
+	}
+	//mite_dump_regs(devpriv->mite);
+#endif
+
+	switch (cmd->start_src) {
+	case TRIG_NOW:
+		/* AI_START1_Pulse */
+		devpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
+			AI_Command_2_Register);
+		s->async->inttrig = NULL;
+		break;
+	case TRIG_EXT:
+		s->async->inttrig = NULL;
+		break;
+	case TRIG_INT:
+		s->async->inttrig = &ni_ai_inttrig;
+		break;
+	}
+
+	MDPRINTK("exit ni_ai_cmd\n");
+
+	return 0;
+}
+
+static int ni_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum)
+{
+	if (trignum != 0)
+		return -EINVAL;
+
+	devpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
+		AI_Command_2_Register);
+	s->async->inttrig = NULL;
+
+	return 1;
+}
+
+static int ni_ai_config_analog_trig(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+
+static int ni_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	if (insn->n < 1)
+		return -EINVAL;
+
+	switch (data[0]) {
+	case INSN_CONFIG_ANALOG_TRIG:
+		return ni_ai_config_analog_trig(dev, s, insn, data);
+	case INSN_CONFIG_ALT_SOURCE:
+		if (boardtype.reg_type & ni_reg_m_series_mask) {
+			if (data[1] & ~(MSeries_AI_Bypass_Cal_Sel_Pos_Mask |
+					MSeries_AI_Bypass_Cal_Sel_Neg_Mask |
+					MSeries_AI_Bypass_Mode_Mux_Mask |
+					MSeries_AO_Bypass_AO_Cal_Sel_Mask)) {
+				return -EINVAL;
+			}
+			devpriv->ai_calib_source = data[1];
+		} else if (boardtype.reg_type == ni_reg_6143) {
+			unsigned int calib_source;
+
+			calib_source = data[1] & 0xf;
+
+			if (calib_source > 0xF)
+				return -EINVAL;
+
+			devpriv->ai_calib_source = calib_source;
+			ni_writew(calib_source, Calibration_Channel_6143);
+		} else {
+			unsigned int calib_source;
+			unsigned int calib_source_adjust;
+
+			calib_source = data[1] & 0xf;
+			calib_source_adjust = (data[1] >> 4) & 0xff;
+
+			if (calib_source >= 8)
+				return -EINVAL;
+			devpriv->ai_calib_source = calib_source;
+			if (boardtype.reg_type == ni_reg_611x) {
+				ni_writeb(calib_source_adjust,
+					Cal_Gain_Select_611x);
+			}
+		}
+		return 2;
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+
+static int ni_ai_config_analog_trig(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned int a, b, modebits;
+	int err = 0;
+
+	/* data[1] is flags
+	 * data[2] is analog line
+	 * data[3] is set level
+	 * data[4] is reset level */
+	if (!boardtype.has_analog_trig)
+		return -EINVAL;
+	if ((data[1] & 0xffff0000) != COMEDI_EV_SCAN_BEGIN) {
+		data[1] &= (COMEDI_EV_SCAN_BEGIN | 0xffff);
+		err++;
+	}
+	if (data[2] >= boardtype.n_adchan) {
+		data[2] = boardtype.n_adchan - 1;
+		err++;
+	}
+	if (data[3] > 255) {	/* a */
+		data[3] = 255;
+		err++;
+	}
+	if (data[4] > 255) {	/* b */
+		data[4] = 255;
+		err++;
+	}
+	/*
+	 * 00 ignore
+	 * 01 set
+	 * 10 reset
+	 *
+	 * modes:
+	 *   1 level:                    +b-   +a-
+	 *     high mode                00 00 01 10
+	 *     low mode                 00 00 10 01
+	 *   2 level: (a<b)
+	 *     hysteresis low mode      10 00 00 01
+	 *     hysteresis high mode     01 00 00 10
+	 *     middle mode              10 01 01 10
+	 */
+
+	a = data[3];
+	b = data[4];
+	modebits = data[1] & 0xff;
+	if (modebits & 0xf0) {
+		/* two level mode */
+		if (b < a) {
+			/* swap order */
+			a = data[4];
+			b = data[3];
+			modebits =
+				((data[1] & 0xf) << 4) | ((data[1] & 0xf0) >>
+				4);
+		}
+		devpriv->atrig_low = a;
+		devpriv->atrig_high = b;
+		switch (modebits) {
+		case 0x81:	/* low hysteresis mode */
+			devpriv->atrig_mode = 6;
+			break;
+		case 0x42:	/* high hysteresis mode */
+			devpriv->atrig_mode = 3;
+			break;
+		case 0x96:	/* middle window mode */
+			devpriv->atrig_mode = 2;
+			break;
+		default:
+			data[1] &= ~0xff;
+			err++;
+		}
+	} else {
+		/* one level mode */
+		if (b != 0) {
+			data[4] = 0;
+			err++;
+		}
+		switch (modebits) {
+		case 0x06:	/* high window mode */
+			devpriv->atrig_high = a;
+			devpriv->atrig_mode = 0;
+			break;
+		case 0x09:	/* low window mode */
+			devpriv->atrig_low = a;
+			devpriv->atrig_mode = 1;
+			break;
+		default:
+			data[1] &= ~0xff;
+			err++;
+		}
+	}
+	if (err)
+		return -EAGAIN;
+	return 5;
+}
+
+/* munge data from unsigned to 2's complement for analog output bipolar modes */
+static void ni_ao_munge(comedi_device * dev, comedi_subdevice * s,
+	void *data, unsigned int num_bytes, unsigned int chan_index)
+{
+	comedi_async *async = s->async;
+	unsigned int range;
+	unsigned int i;
+	unsigned int offset;
+	unsigned int length = num_bytes / sizeof(sampl_t);
+	sampl_t *array = data;
+
+	offset = 1 << (boardtype.aobits - 1);
+	for (i = 0; i < length; i++) {
+		range = CR_RANGE(async->cmd.chanlist[chan_index]);
+		if (boardtype.ao_unipolar == 0 || (range & 1) == 0)
+			array[i] -= offset;
+#ifdef PCIDMA
+		array[i] = cpu_to_le16(array[i]);
+#endif
+		chan_index++;
+		chan_index %= async->cmd.chanlist_len;
+	}
+}
+
+static int ni_m_series_ao_config_chanlist(comedi_device * dev,
+	comedi_subdevice * s, unsigned int chanspec[], unsigned int n_chans,
+	int timed)
+{
+	unsigned int range;
+	unsigned int chan;
+	unsigned int conf;
+	int i;
+	int invert = 0;
+
+	if(timed) {
+		for (i = 0; i < boardtype.n_aochan; ++i) {
+			devpriv->ao_conf[i] &= ~MSeries_AO_Update_Timed_Bit;
+			ni_writeb(devpriv->ao_conf[i], M_Offset_AO_Config_Bank(i));
+			ni_writeb(0xf, M_Offset_AO_Waveform_Order(i));
+		}
+	}
+	for (i = 0; i < n_chans; i++) {
+		const comedi_krange *krange;
+		chan = CR_CHAN(chanspec[i]);
+		range = CR_RANGE(chanspec[i]);
+		krange = s->range_table->range + range;
+		invert = 0;
+		conf = 0;
+		switch (krange->max - krange->min) {
+		case 20000000:
+			conf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;
+			ni_writeb(0, M_Offset_AO_Reference_Attenuation(chan));
+			break;
+		case 10000000:
+			conf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;
+			ni_writeb(0, M_Offset_AO_Reference_Attenuation(chan));
+			break;
+		case 4000000:
+			conf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;
+			ni_writeb(MSeries_Attenuate_x5_Bit,
+				M_Offset_AO_Reference_Attenuation(chan));
+			break;
+		case 2000000:
+			conf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;
+			ni_writeb(MSeries_Attenuate_x5_Bit,
+				M_Offset_AO_Reference_Attenuation(chan));
+			break;
+		default:
+			rt_printk("%s: bug! unhandled ao reference voltage\n",
+				__FUNCTION__);
+			break;
+		}
+		switch (krange->max + krange->min) {
+		case 0:
+			conf |= MSeries_AO_DAC_Offset_0V_Bits;
+			break;
+		case 10000000:
+			conf |= MSeries_AO_DAC_Offset_5V_Bits;
+			break;
+		default:
+			rt_printk("%s: bug! unhandled ao offset voltage\n",
+				__FUNCTION__);
+			break;
+		}
+		if (timed)
+			conf |= MSeries_AO_Update_Timed_Bit;
+		ni_writeb(conf, M_Offset_AO_Config_Bank(chan));
+		devpriv->ao_conf[chan] = conf;
+		ni_writeb(i, M_Offset_AO_Waveform_Order(chan));
+	}
+	return invert;
+}
+
+static int ni_old_ao_config_chanlist(comedi_device * dev, comedi_subdevice * s,
+	unsigned int chanspec[], unsigned int n_chans)
+{
+	unsigned int range;
+	unsigned int chan;
+	unsigned int conf;
+	int i;
+	int invert = 0;
+
+	for (i = 0; i < n_chans; i++) {
+		chan = CR_CHAN(chanspec[i]);
+		range = CR_RANGE(chanspec[i]);
+		conf = AO_Channel(chan);
+
+		if (boardtype.ao_unipolar) {
+			if ((range & 1) == 0) {
+				conf |= AO_Bipolar;
+				invert = (1 << (boardtype.aobits - 1));
+			} else {
+				invert = 0;
+			}
+			if (range & 2)
+				conf |= AO_Ext_Ref;
+		} else {
+			conf |= AO_Bipolar;
+			invert = (1 << (boardtype.aobits - 1));
+		}
+
+		/* not all boards can deglitch, but this shouldn't hurt */
+		if (chanspec[i] & CR_DEGLITCH)
+			conf |= AO_Deglitch;
+
+		/* analog reference */
+		/* AREF_OTHER connects AO ground to AI ground, i think */
+		conf |= (CR_AREF(chanspec[i]) ==
+			AREF_OTHER) ? AO_Ground_Ref : 0;
+
+		ni_writew(conf, AO_Configuration);
+		devpriv->ao_conf[chan] = conf;
+	}
+	return invert;
+}
+
+static int ni_ao_config_chanlist(comedi_device * dev, comedi_subdevice * s,
+	unsigned int chanspec[], unsigned int n_chans, int timed)
+{
+	if (boardtype.reg_type & ni_reg_m_series_mask)
+		return ni_m_series_ao_config_chanlist(dev, s, chanspec, n_chans,
+			timed);
+	else
+		return ni_old_ao_config_chanlist(dev, s, chanspec, n_chans);
+}
+static int ni_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
+static int ni_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int invert;
+
+	invert = ni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);
+
+	devpriv->ao[chan] = data[0];
+
+	if (boardtype.reg_type & ni_reg_m_series_mask) {
+		ni_writew(data[0], M_Offset_DAC_Direct_Data(chan));
+	} else
+		ni_writew(data[0] ^ invert,
+			(chan) ? DAC1_Direct_Data : DAC0_Direct_Data);
+
+	return 1;
+}
+
+static int ni_ao_insn_write_671x(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int invert;
+
+	ao_win_out(1 << chan, AO_Immediate_671x);
+	invert = 1 << (boardtype.aobits - 1);
+
+	ni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);
+
+	devpriv->ao[chan] = data[0];
+	ao_win_out(data[0] ^ invert, DACx_Direct_Data_671x(chan));
+
+	return 1;
+}
+
+static int ni_ao_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	switch (data[0]) {
+	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
+		switch(data[1])
+		{
+		case COMEDI_OUTPUT:
+			data[2] = 1 + boardtype.ao_fifo_depth * sizeof(sampl_t);
+			if(devpriv->mite) data[2] += devpriv->mite->fifo_size;
+			break;
+		case COMEDI_INPUT:
+			data[2] = 0;
+			break;
+		default:
+			return -EINVAL;
+			break;
+		}
+		return 0;
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+
+static int ni_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum)
+{
+	int ret;
+	int interrupt_b_bits;
+	int i;
+	static const int timeout = 1000;
+
+	if (trignum != 0)
+		return -EINVAL;
+
+	/* Null trig at beginning prevent ao start trigger from executing more than
+	   once per command (and doing things like trying to allocate the ao dma channel
+	   multiple times) */
+	s->async->inttrig = NULL;
+
+	ni_set_bits(dev, Interrupt_B_Enable_Register,
+		AO_FIFO_Interrupt_Enable | AO_Error_Interrupt_Enable, 0);
+	interrupt_b_bits = AO_Error_Interrupt_Enable;
+#ifdef PCIDMA
+	devpriv->stc_writew(dev, 1, DAC_FIFO_Clear);
+	if (boardtype.reg_type & ni_reg_6xxx_mask)
+		ni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);
+	ret = ni_ao_setup_MITE_dma(dev);
+	if (ret)
+		return ret;
+	ret = ni_ao_wait_for_dma_load(dev);
+	if (ret < 0)
+		return ret;
+#else
+	ret = ni_ao_prep_fifo(dev, s);
+	if (ret == 0)
+		return -EPIPE;
+
+	interrupt_b_bits |= AO_FIFO_Interrupt_Enable;
+#endif
+
+	devpriv->stc_writew(dev, devpriv->ao_mode3 | AO_Not_An_UPDATE,
+		AO_Mode_3_Register);
+	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
+	/* wait for DACs to be loaded */
+	for (i = 0; i < timeout; i++) {
+		comedi_udelay(1);
+		if ((devpriv->stc_readw(dev,
+					Joint_Status_2_Register) &
+				AO_TMRDACWRs_In_Progress_St) == 0)
+			break;
+	}
+	if (i == timeout) {
+		comedi_error(dev,
+			"timed out waiting for AO_TMRDACWRs_In_Progress_St to clear");
+		return -EIO;
+	}
+	// stc manual says we are need to clear error interrupt after AO_TMRDACWRs_In_Progress_St clears
+	devpriv->stc_writew(dev, AO_Error_Interrupt_Ack,
+		Interrupt_B_Ack_Register);
+
+	ni_set_bits(dev, Interrupt_B_Enable_Register, interrupt_b_bits, 1);
+
+	devpriv->stc_writew(dev,
+		devpriv->
+		ao_cmd1 | AO_UI_Arm | AO_UC_Arm | AO_BC_Arm |
+		AO_DAC1_Update_Mode | AO_DAC0_Update_Mode,
+		AO_Command_1_Register);
+
+	devpriv->stc_writew(dev, devpriv->ao_cmd2 | AO_START1_Pulse,
+		AO_Command_2_Register);
+
+	return 0;
+}
+
+static int ni_ao_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	const comedi_cmd *cmd = &s->async->cmd;
+	int bits;
+	int i;
+	unsigned trigvar;
+
+	if (dev->irq == 0) {
+		comedi_error(dev, "cannot run command without an irq");
+		return -EIO;
+	}
+
+	devpriv->stc_writew(dev, AO_Configuration_Start, Joint_Reset_Register);
+
+	devpriv->stc_writew(dev, AO_Disarm, AO_Command_1_Register);
+
+	if (boardtype.reg_type & ni_reg_6xxx_mask) {
+		ao_win_out(CLEAR_WG, AO_Misc_611x);
+
+		bits = 0;
+		for (i = 0; i < cmd->chanlist_len; i++) {
+			int chan;
+
+			chan = CR_CHAN(cmd->chanlist[i]);
+			bits |= 1 << chan;
+			ao_win_out(chan, AO_Waveform_Generation_611x);
+		}
+		ao_win_out(bits, AO_Timed_611x);
+	}
+
+	ni_ao_config_chanlist(dev, s, cmd->chanlist, cmd->chanlist_len, 1);
+
+	if (cmd->stop_src == TRIG_NONE) {
+		devpriv->ao_mode1 |= AO_Continuous;
+		devpriv->ao_mode1 &= ~AO_Trigger_Once;
+	} else {
+		devpriv->ao_mode1 &= ~AO_Continuous;
+		devpriv->ao_mode1 |= AO_Trigger_Once;
+	}
+	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	switch (cmd->start_src) {
+	case TRIG_INT:
+	case TRIG_NOW:
+		devpriv->ao_trigger_select &=
+			~(AO_START1_Polarity | AO_START1_Select(-1));
+		devpriv->ao_trigger_select |= AO_START1_Edge | AO_START1_Sync;
+		devpriv->stc_writew(dev, devpriv->ao_trigger_select,
+			AO_Trigger_Select_Register);
+		break;
+	case TRIG_EXT:
+                devpriv->ao_trigger_select = AO_START1_Select(CR_CHAN(cmd->start_arg)+1);
+		if (cmd->start_arg & CR_INVERT)
+			devpriv->ao_trigger_select |= AO_START1_Polarity;  // 0=active high, 1=active low. see daq-stc 3-24 (p186)
+		if (cmd->start_arg & CR_EDGE)
+			devpriv->ao_trigger_select |= AO_START1_Edge;      // 0=edge detection disabled, 1=enabled
+		devpriv->stc_writew(dev, devpriv->ao_trigger_select, AO_Trigger_Select_Register);
+		break;
+	default:
+		BUG();
+		break;
+	}
+	devpriv->ao_mode3 &= ~AO_Trigger_Length;
+	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
+
+	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	devpriv->ao_mode2 &= ~AO_BC_Initial_Load_Source;
+	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+	if (cmd->stop_src == TRIG_NONE) {
+		devpriv->stc_writel(dev, 0xffffff, AO_BC_Load_A_Register);
+	} else {
+		devpriv->stc_writel(dev, 0, AO_BC_Load_A_Register);
+	}
+	devpriv->stc_writew(dev, AO_BC_Load, AO_Command_1_Register);
+	devpriv->ao_mode2 &= ~AO_UC_Initial_Load_Source;
+	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		if(boardtype.reg_type & ni_reg_m_series_mask)
+		{
+			// this is how the NI example code does it for m-series boards, verified correct with 6259
+			devpriv->stc_writel(dev, cmd->stop_arg - 1, AO_UC_Load_A_Register);
+			devpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
+		}else
+		{
+			devpriv->stc_writel(dev, cmd->stop_arg, AO_UC_Load_A_Register);
+			devpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
+			devpriv->stc_writel(dev, cmd->stop_arg - 1,
+				AO_UC_Load_A_Register);
+		}
+		break;
+	case TRIG_NONE:
+		devpriv->stc_writel(dev, 0xffffff, AO_UC_Load_A_Register);
+		devpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
+		devpriv->stc_writel(dev, 0xffffff, AO_UC_Load_A_Register);
+		break;
+	default:
+		devpriv->stc_writel(dev, 0, AO_UC_Load_A_Register);
+		devpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
+		devpriv->stc_writel(dev, cmd->stop_arg, AO_UC_Load_A_Register);
+	}
+
+	devpriv->ao_mode1 &=
+		~(AO_UI_Source_Select(0x1f) | AO_UI_Source_Polarity |
+		AO_UPDATE_Source_Select(0x1f) | AO_UPDATE_Source_Polarity);
+	switch (cmd->scan_begin_src) {
+	case TRIG_TIMER:
+		devpriv->ao_cmd2 &= ~AO_BC_Gate_Enable;
+		trigvar =
+			ni_ns_to_timer(dev, cmd->scan_begin_arg,
+			TRIG_ROUND_NEAREST);
+		devpriv->stc_writel(dev, 1, AO_UI_Load_A_Register);
+		devpriv->stc_writew(dev, AO_UI_Load, AO_Command_1_Register);
+		devpriv->stc_writel(dev, trigvar, AO_UI_Load_A_Register);
+		break;
+	case TRIG_EXT:
+		devpriv->ao_mode1 |=
+			AO_UPDATE_Source_Select(cmd->scan_begin_arg);
+		if (cmd->scan_begin_arg & CR_INVERT)
+			devpriv->ao_mode1 |= AO_UPDATE_Source_Polarity;
+		devpriv->ao_cmd2 |= AO_BC_Gate_Enable;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	devpriv->stc_writew(dev, devpriv->ao_cmd2, AO_Command_2_Register);
+	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	devpriv->ao_mode2 &=
+		~(AO_UI_Reload_Mode(3) | AO_UI_Initial_Load_Source);
+	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+
+	if (cmd->scan_end_arg > 1) {
+		devpriv->ao_mode1 |= AO_Multiple_Channels;
+		devpriv->stc_writew(dev,
+			AO_Number_Of_Channels(cmd->scan_end_arg -
+				1) |
+			AO_UPDATE_Output_Select
+			(AO_Update_Output_High_Z),
+			AO_Output_Control_Register);
+	} else {
+		unsigned bits;
+		devpriv->ao_mode1 &= ~AO_Multiple_Channels;
+		bits = AO_UPDATE_Output_Select(AO_Update_Output_High_Z);
+		if (boardtype.reg_type & (ni_reg_m_series_mask | ni_reg_6xxx_mask)) {
+			bits |= AO_Number_Of_Channels(0);
+		} else {
+			bits |= AO_Number_Of_Channels(CR_CHAN(cmd->
+					chanlist[0]));
+		}
+		devpriv->stc_writew(dev, bits,
+			AO_Output_Control_Register);
+	}
+	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+
+	devpriv->stc_writew(dev, AO_DAC0_Update_Mode | AO_DAC1_Update_Mode,
+		AO_Command_1_Register);
+
+	devpriv->ao_mode3 |= AO_Stop_On_Overrun_Error;
+	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
+
+	devpriv->ao_mode2 &= ~AO_FIFO_Mode_Mask;
+#ifdef PCIDMA
+	devpriv->ao_mode2 |= AO_FIFO_Mode_HF_to_F;
+#else
+	devpriv->ao_mode2 |= AO_FIFO_Mode_HF;
+#endif
+	devpriv->ao_mode2 &= ~AO_FIFO_Retransmit_Enable;
+	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+
+	bits = AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
+		AO_TMRDACWR_Pulse_Width;
+	if (boardtype.ao_fifo_depth)
+		bits |= AO_FIFO_Enable;
+	else
+		bits |= AO_DMA_PIO_Control;
+#if 0
+	/* F Hess: windows driver does not set AO_Number_Of_DAC_Packages bit for 6281,
+	   verified with bus analyzer. */
+	if (boardtype.reg_type & ni_reg_m_series_mask)
+		bits |= AO_Number_Of_DAC_Packages;
+#endif
+	devpriv->stc_writew(dev, bits, AO_Personal_Register);
+	// enable sending of ao dma requests
+	devpriv->stc_writew(dev, AO_AOFREQ_Enable, AO_Start_Select_Register);
+
+	devpriv->stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		devpriv->stc_writew(dev, AO_BC_TC_Interrupt_Ack,
+			Interrupt_B_Ack_Register);
+		ni_set_bits(dev, Interrupt_B_Enable_Register,
+			AO_BC_TC_Interrupt_Enable, 1);
+	}
+
+	s->async->inttrig = &ni_ao_inttrig;
+
+	return 0;
+}
+
+static int ni_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	if ((cmd->flags & CMDF_WRITE) == 0) {
+		cmd->flags |= CMDF_WRITE;
+	}
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_INT | TRIG_EXT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_src == TRIG_EXT) {
+		/* external trigger */
+		unsigned int tmp = CR_CHAN(cmd->start_arg);
+
+		if (tmp > 18)
+			tmp = 18;
+		tmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));
+		if (cmd->start_arg != tmp) {
+			cmd->start_arg = tmp;
+			err++;
+		}
+	} else {
+		if (cmd->start_arg != 0) {
+			/* true for both TRIG_NOW and TRIG_INT */
+			cmd->start_arg = 0;
+			err++;
+		}
+	}
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		if (cmd->scan_begin_arg < boardtype.ao_speed) {
+			cmd->scan_begin_arg = boardtype.ao_speed;
+			err++;
+		}
+		if (cmd->scan_begin_arg > devpriv->clock_ns * 0xffffff) {	/* XXX check */
+			cmd->scan_begin_arg = devpriv->clock_ns * 0xffffff;
+			err++;
+		}
+	}
+	if (cmd->convert_arg != 0) {
+		cmd->convert_arg = 0;
+		err++;
+	}
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_COUNT) {	/* XXX check */
+		if (cmd->stop_arg > 0x00ffffff) {
+			cmd->stop_arg = 0x00ffffff;
+			err++;
+		}
+	} else {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		tmp = cmd->scan_begin_arg;
+		cmd->scan_begin_arg =
+			ni_timer_to_ns(dev, ni_ns_to_timer(dev,
+				cmd->scan_begin_arg,
+				cmd->flags & TRIG_ROUND_MASK));
+		if (tmp != cmd->scan_begin_arg)
+			err++;
+	}
+	if (err)
+		return 4;
+
+	/* step 5: fix up chanlist */
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+static int ni_ao_reset(comedi_device * dev, comedi_subdevice * s)
+{
+	//devpriv->ao0p=0x0000;
+	//ni_writew(devpriv->ao0p,AO_Configuration);
+
+	//devpriv->ao1p=AO_Channel(1);
+	//ni_writew(devpriv->ao1p,AO_Configuration);
+
+	ni_release_ao_mite_channel(dev);
+
+	devpriv->stc_writew(dev, AO_Configuration_Start, Joint_Reset_Register);
+	devpriv->stc_writew(dev, AO_Disarm, AO_Command_1_Register);
+	ni_set_bits(dev, Interrupt_B_Enable_Register, ~0, 0);
+	devpriv->stc_writew(dev, AO_BC_Source_Select, AO_Personal_Register);
+	devpriv->stc_writew(dev, 0x3f98, Interrupt_B_Ack_Register);
+	devpriv->stc_writew(dev, AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
+		AO_TMRDACWR_Pulse_Width, AO_Personal_Register);
+	devpriv->stc_writew(dev, 0, AO_Output_Control_Register);
+	devpriv->stc_writew(dev, 0, AO_Start_Select_Register);
+	devpriv->ao_cmd1 = 0;
+	devpriv->stc_writew(dev, devpriv->ao_cmd1, AO_Command_1_Register);
+	devpriv->ao_cmd2 = 0;
+	devpriv->stc_writew(dev, devpriv->ao_cmd2, AO_Command_2_Register);
+	devpriv->ao_mode1 = 0;
+	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
+	devpriv->ao_mode2 = 0;
+	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
+	if (boardtype.reg_type & ni_reg_m_series_mask)
+		devpriv->ao_mode3 = AO_Last_Gate_Disable;
+	else
+		devpriv->ao_mode3 = 0;
+	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
+	devpriv->ao_trigger_select = 0;
+	devpriv->stc_writew(dev, devpriv->ao_trigger_select,
+		AO_Trigger_Select_Register);
+	if (boardtype.reg_type & ni_reg_6xxx_mask) {
+		unsigned immediate_bits = 0;
+		unsigned i;
+		for(i = 0; i < s->n_chan; ++i)
+		{
+			immediate_bits |= 1 << i;
+		}
+		ao_win_out(immediate_bits, AO_Immediate_671x);
+		ao_win_out(CLEAR_WG, AO_Misc_611x);
+	}
+	devpriv->stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);
+
+	return 0;
+}
+
+// digital io
+
+static int ni_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+#ifdef DEBUG_DIO
+	rt_printk("ni_dio_insn_config() chan=%d io=%d\n",
+		CR_CHAN(insn->chanspec), data[0]);
+#endif
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_OUTPUT:
+		s->io_bits |= 1 << CR_CHAN(insn->chanspec);
+		break;
+	case INSN_CONFIG_DIO_INPUT:
+		s->io_bits &= ~(1 << CR_CHAN(insn->chanspec));
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] =
+			(s->io_bits & (1 << CR_CHAN(insn->
+					chanspec))) ? COMEDI_OUTPUT :
+			COMEDI_INPUT;
+		return insn->n;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	devpriv->dio_control &= ~DIO_Pins_Dir_Mask;
+	devpriv->dio_control |= DIO_Pins_Dir(s->io_bits);
+	devpriv->stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
+
+	return 1;
+}
+
+static int ni_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+#ifdef DEBUG_DIO
+	rt_printk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);
+#endif
+	if (insn->n != 2)
+		return -EINVAL;
+	if (data[0]) {
+		/* Perform check to make sure we're not using the
+		   serial part of the dio */
+		if ((data[0] & (DIO_SDIN | DIO_SDOUT))
+			&& devpriv->serial_interval_ns)
+			return -EBUSY;
+
+		s->state &= ~data[0];
+		s->state |= (data[0] & data[1]);
+		devpriv->dio_output &= ~DIO_Parallel_Data_Mask;
+		devpriv->dio_output |= DIO_Parallel_Data_Out(s->state);
+		devpriv->stc_writew(dev, devpriv->dio_output,
+			DIO_Output_Register);
+	}
+	data[1] = devpriv->stc_readw(dev, DIO_Parallel_Input_Register);
+
+	return 2;
+}
+
+static int ni_m_series_dio_insn_config(comedi_device * dev,
+	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+{
+#ifdef DEBUG_DIO
+	rt_printk("ni_m_series_dio_insn_config() chan=%d io=%d\n",
+		CR_CHAN(insn->chanspec), data[0]);
+#endif
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_OUTPUT:
+		s->io_bits |= 1 << CR_CHAN(insn->chanspec);
+		break;
+	case INSN_CONFIG_DIO_INPUT:
+		s->io_bits &= ~(1 << CR_CHAN(insn->chanspec));
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] =
+			(s->io_bits & (1 << CR_CHAN(insn->
+					chanspec))) ? COMEDI_OUTPUT :
+			COMEDI_INPUT;
+		return insn->n;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ni_writel(s->io_bits, M_Offset_DIO_Direction);
+
+	return 1;
+}
+
+static int ni_m_series_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+#ifdef DEBUG_DIO
+	rt_printk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],
+		data[1]);
+#endif
+	if (insn->n != 2)
+		return -EINVAL;
+	if (data[0]) {
+		s->state &= ~data[0];
+		s->state |= (data[0] & data[1]);
+		ni_writel(s->state, M_Offset_Static_Digital_Output);
+	}
+	data[1] = ni_readl(M_Offset_Static_Digital_Input);
+
+	return 2;
+}
+
+static int ni_cdio_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+	int sources;
+	unsigned i;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	sources = TRIG_INT;
+	cmd->start_src &= sources;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique... */
+
+	if (cmd->start_src != TRIG_INT)
+		err++;
+	if (cmd->scan_begin_src != TRIG_EXT)
+		err++;
+	if (cmd->convert_src != TRIG_NOW)
+		err++;
+	if (cmd->stop_src != TRIG_NONE)
+		err++;
+	/* ... and mutually compatible */
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+	if (cmd->start_src == TRIG_INT) {
+		if (cmd->start_arg != 0) {
+			cmd->start_arg = 0;
+			err++;
+		}
+	}
+	if (cmd->scan_begin_src == TRIG_EXT) {
+		tmp = cmd->scan_begin_arg;
+		tmp &= CR_PACK_FLAGS(CDO_Sample_Source_Select_Mask, 0, 0,
+			CR_INVERT);
+		if (tmp != cmd->scan_begin_arg) {
+			err++;
+		}
+	}
+	if (cmd->convert_src == TRIG_NOW) {
+		if (cmd->convert_arg) {
+			cmd->convert_arg = 0;
+			err++;
+		}
+	}
+
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	if (cmd->stop_src == TRIG_NONE) {
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (err)
+		return 4;
+
+	/* step 5: check chanlist */
+
+	for (i = 0; i < cmd->chanlist_len; ++i) {
+		if (cmd->chanlist[i] != i)
+			err = 1;
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+static int ni_cdio_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	const comedi_cmd *cmd = &s->async->cmd;
+	unsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;
+	int retval;
+
+	ni_writel(CDO_Reset_Bit, M_Offset_CDIO_Command);
+	switch (cmd->scan_begin_src) {
+	case TRIG_EXT:
+		cdo_mode_bits |=
+			CR_CHAN(cmd->
+			scan_begin_arg) & CDO_Sample_Source_Select_Mask;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	if (cmd->scan_begin_arg & CR_INVERT)
+		cdo_mode_bits |= CDO_Polarity_Bit;
+	ni_writel(cdo_mode_bits, M_Offset_CDO_Mode);
+	if (s->io_bits) {
+		ni_writel(s->state, M_Offset_CDO_FIFO_Data);
+		ni_writel(CDO_SW_Update_Bit, M_Offset_CDIO_Command);
+		ni_writel(s->io_bits, M_Offset_CDO_Mask_Enable);
+	} else {
+		comedi_error(dev,
+			"attempted to run digital output command with no lines configured as outputs");
+		return -EIO;
+	}
+	retval = ni_request_cdo_mite_channel(dev);
+	if (retval < 0) {
+		return retval;
+	}
+	s->async->inttrig = &ni_cdo_inttrig;
+	return 0;
+}
+
+static int ni_cdo_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum)
+{
+#ifdef PCIDMA
+	unsigned long flags;
+#endif
+	int retval = 0;
+	unsigned i;
+	const unsigned timeout = 100;
+
+	s->async->inttrig = NULL;
+
+	/* read alloc the entire buffer */
+	comedi_buf_read_alloc(s->async, s->async->prealloc_bufsz);
+
+#ifdef PCIDMA
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if (devpriv->cdo_mite_chan) {
+		mite_prep_dma(devpriv->cdo_mite_chan, 32, 32);
+		mite_dma_arm(devpriv->cdo_mite_chan);
+	} else {
+		comedi_error(dev, "BUG: no cdo mite channel?");
+		retval = -EIO;
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	if (retval < 0)
+		return retval;
+#endif
+// XXX not sure what interrupt C group does
+//      ni_writeb(Interrupt_Group_C_Enable_Bit, M_Offset_Interrupt_C_Enable);
+	//wait for dma to fill output fifo
+	for (i = 0; i < timeout; ++i) {
+		if (ni_readl(M_Offset_CDIO_Status) & CDO_FIFO_Full_Bit)
+			break;
+		comedi_udelay(10);
+	}
+	if (i == timeout) {
+		comedi_error(dev, "dma failed to fill cdo fifo!");
+		ni_cdio_cancel(dev, s);
+		return -EIO;
+	}
+	ni_writel(CDO_Arm_Bit | CDO_Error_Interrupt_Enable_Set_Bit |
+		CDO_Empty_FIFO_Interrupt_Enable_Set_Bit, M_Offset_CDIO_Command);
+	return retval;
+}
+
+static int ni_cdio_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	ni_writel(CDO_Disarm_Bit | CDO_Error_Interrupt_Enable_Clear_Bit |
+		CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
+		CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
+		M_Offset_CDIO_Command);
+// XXX not sure what interrupt C group does
+//      ni_writeb(0, M_Offset_Interrupt_C_Enable);
+	ni_writel(0, M_Offset_CDO_Mask_Enable);
+	ni_release_cdo_mite_channel(dev);
+	return 0;
+}
+
+static void handle_cdio_interrupt(comedi_device * dev)
+{
+	unsigned cdio_status;
+	comedi_subdevice *s = dev->subdevices + NI_DIO_SUBDEV;
+#ifdef PCIDMA
+	unsigned long flags;
+#endif
+
+	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
+		return;
+	}
+#ifdef PCIDMA
+	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if (devpriv->cdo_mite_chan) {
+		unsigned cdo_mite_status =
+			mite_get_status(devpriv->cdo_mite_chan);
+		if (cdo_mite_status & CHSR_LINKC) {
+			writel(CHOR_CLRLC,
+				devpriv->mite->mite_io_addr +
+				MITE_CHOR(devpriv->cdo_mite_chan->channel));
+		}
+		mite_sync_output_dma(devpriv->cdo_mite_chan, s->async);
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+#endif
+
+	cdio_status = ni_readl(M_Offset_CDIO_Status);
+	if (cdio_status & (CDO_Overrun_Bit | CDO_Underflow_Bit)) {
+//              rt_printk("cdio error: statux=0x%x\n", cdio_status);
+		ni_writel(CDO_Error_Interrupt_Confirm_Bit, M_Offset_CDIO_Command);	// XXX just guessing this is needed and does something useful
+		s->async->events |= COMEDI_CB_OVERFLOW;
+	}
+	if (cdio_status & CDO_FIFO_Empty_Bit) {
+//              rt_printk("cdio fifo empty\n");
+		ni_writel(CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
+			M_Offset_CDIO_Command);
+//              s->async->events |= COMEDI_CB_EOA;
+	}
+	ni_event(dev, s);
+}
+
+static int ni_serial_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int err = insn->n;
+	unsigned char byte_out, byte_in = 0;
+
+	if (insn->n != 2)
+		return -EINVAL;
+
+	switch (data[0]) {
+	case INSN_CONFIG_SERIAL_CLOCK:
+
+#ifdef DEBUG_DIO
+		rt_printk("SPI serial clock Config cd\n", data[1]);
+#endif
+		devpriv->serial_hw_mode = 1;
+		devpriv->dio_control |= DIO_HW_Serial_Enable;
+
+		if (data[1] == SERIAL_DISABLED) {
+			devpriv->serial_hw_mode = 0;
+			devpriv->dio_control &= ~(DIO_HW_Serial_Enable |
+				DIO_Software_Serial_Control);
+			data[1] = SERIAL_DISABLED;
+			devpriv->serial_interval_ns = data[1];
+		} else if (data[1] <= SERIAL_600NS) {
+			/* Warning: this clock speed is too fast to reliably
+			   control SCXI. */
+			devpriv->dio_control &= ~DIO_HW_Serial_Timebase;
+			devpriv->clock_and_fout |= Slow_Internal_Timebase;
+			devpriv->clock_and_fout &= ~DIO_Serial_Out_Divide_By_2;
+			data[1] = SERIAL_600NS;
+			devpriv->serial_interval_ns = data[1];
+		} else if (data[1] <= SERIAL_1_2US) {
+			devpriv->dio_control &= ~DIO_HW_Serial_Timebase;
+			devpriv->clock_and_fout |= Slow_Internal_Timebase |
+				DIO_Serial_Out_Divide_By_2;
+			data[1] = SERIAL_1_2US;
+			devpriv->serial_interval_ns = data[1];
+		} else if (data[1] <= SERIAL_10US) {
+			devpriv->dio_control |= DIO_HW_Serial_Timebase;
+			devpriv->clock_and_fout |= Slow_Internal_Timebase |
+				DIO_Serial_Out_Divide_By_2;
+			/* Note: DIO_Serial_Out_Divide_By_2 only affects
+			   600ns/1.2us. If you turn divide_by_2 off with the
+			   slow clock, you will still get 10us, except then
+			   all your delays are wrong. */
+			data[1] = SERIAL_10US;
+			devpriv->serial_interval_ns = data[1];
+		} else {
+			devpriv->dio_control &= ~(DIO_HW_Serial_Enable |
+				DIO_Software_Serial_Control);
+			devpriv->serial_hw_mode = 0;
+			data[1] = (data[1] / 1000) * 1000;
+			devpriv->serial_interval_ns = data[1];
+		}
+
+		devpriv->stc_writew(dev, devpriv->dio_control,
+			DIO_Control_Register);
+		devpriv->stc_writew(dev, devpriv->clock_and_fout,
+			Clock_and_FOUT_Register);
+		return 1;
+
+		break;
+
+	case INSN_CONFIG_BIDIRECTIONAL_DATA:
+
+		if (devpriv->serial_interval_ns == 0) {
+			return -EINVAL;
+		}
+
+		byte_out = data[1] & 0xFF;
+
+		if (devpriv->serial_hw_mode) {
+			err = ni_serial_hw_readwrite8(dev, s, byte_out,
+				&byte_in);
+		} else if (devpriv->serial_interval_ns > 0) {
+			err = ni_serial_sw_readwrite8(dev, s, byte_out,
+				&byte_in);
+		} else {
+			rt_printk("ni_serial_insn_config: serial disabled!\n");
+			return -EINVAL;
+		}
+		if (err < 0)
+			return err;
+		data[1] = byte_in & 0xFF;
+		return insn->n;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+}
+
+static int ni_serial_hw_readwrite8(comedi_device * dev, comedi_subdevice * s,
+	unsigned char data_out, unsigned char *data_in)
+{
+	unsigned int status1;
+	int err = 0, count = 20;
+
+#ifdef DEBUG_DIO
+	rt_printk("ni_serial_hw_readwrite8: outputting 0x%x\n", data_out);
+#endif
+
+	devpriv->dio_output &= ~DIO_Serial_Data_Mask;
+	devpriv->dio_output |= DIO_Serial_Data_Out(data_out);
+	devpriv->stc_writew(dev, devpriv->dio_output, DIO_Output_Register);
+
+	status1 = devpriv->stc_readw(dev, Joint_Status_1_Register);
+	if (status1 & DIO_Serial_IO_In_Progress_St) {
+		err = -EBUSY;
+		goto Error;
+	}
+
+	devpriv->dio_control |= DIO_HW_Serial_Start;
+	devpriv->stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
+	devpriv->dio_control &= ~DIO_HW_Serial_Start;
+
+	/* Wait until STC says we're done, but don't loop infinitely. */
+	while ((status1 =
+			devpriv->stc_readw(dev,
+				Joint_Status_1_Register)) &
+		DIO_Serial_IO_In_Progress_St) {
+		/* Delay one bit per loop */
+		comedi_udelay((devpriv->serial_interval_ns + 999) / 1000);
+		if (--count < 0) {
+			rt_printk
+				("ni_serial_hw_readwrite8: SPI serial I/O didn't finish in time!\n");
+			err = -ETIME;
+			goto Error;
+		}
+	}
+
+	/* Delay for last bit. This delay is absolutely necessary, because
+	   DIO_Serial_IO_In_Progress_St goes high one bit too early. */
+	comedi_udelay((devpriv->serial_interval_ns + 999) / 1000);
+
+	if (data_in != NULL) {
+		*data_in = devpriv->stc_readw(dev, DIO_Serial_Input_Register);
+#ifdef DEBUG_DIO
+		rt_printk("ni_serial_hw_readwrite8: inputted 0x%x\n", *data_in);
+#endif
+	}
+
+      Error:
+	devpriv->stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
+
+	return err;
+}
+
+static int ni_serial_sw_readwrite8(comedi_device * dev, comedi_subdevice * s,
+	unsigned char data_out, unsigned char *data_in)
+{
+	unsigned char mask, input = 0;
+
+#ifdef DEBUG_DIO
+	rt_printk("ni_serial_sw_readwrite8: outputting 0x%x\n", data_out);
+#endif
+
+	/* Wait for one bit before transfer */
+	comedi_udelay((devpriv->serial_interval_ns + 999) / 1000);
+
+	for (mask = 0x80; mask; mask >>= 1) {
+		/* Output current bit; note that we cannot touch s->state
+		   because it is a per-subdevice field, and serial is
+		   a separate subdevice from DIO. */
+		devpriv->dio_output &= ~DIO_SDOUT;
+		if (data_out & mask) {
+			devpriv->dio_output |= DIO_SDOUT;
+		}
+		devpriv->stc_writew(dev, devpriv->dio_output,
+			DIO_Output_Register);
+
+		/* Assert SDCLK (active low, inverted), wait for half of
+		   the delay, deassert SDCLK, and wait for the other half. */
+		devpriv->dio_control |= DIO_Software_Serial_Control;
+		devpriv->stc_writew(dev, devpriv->dio_control,
+			DIO_Control_Register);
+
+		comedi_udelay((devpriv->serial_interval_ns + 999) / 2000);
+
+		devpriv->dio_control &= ~DIO_Software_Serial_Control;
+		devpriv->stc_writew(dev, devpriv->dio_control,
+			DIO_Control_Register);
+
+		comedi_udelay((devpriv->serial_interval_ns + 999) / 2000);
+
+		/* Input current bit */
+		if (devpriv->stc_readw(dev,
+				DIO_Parallel_Input_Register) & DIO_SDIN) {
+/*			rt_printk("DIO_P_I_R: 0x%x\n", devpriv->stc_readw(dev, DIO_Parallel_Input_Register)); */
+			input |= mask;
+		}
+	}
+#ifdef DEBUG_DIO
+	rt_printk("ni_serial_sw_readwrite8: inputted 0x%x\n", input);
+#endif
+	if (data_in)
+		*data_in = input;
+
+	return 0;
+}
+
+static void mio_common_detach(comedi_device * dev)
+{
+	if (dev->private) {
+		if (devpriv->counter_dev) {
+			ni_gpct_device_destroy(devpriv->counter_dev);
+		}
+	}
+	if (dev->subdevices && boardtype.has_8255)
+		subdev_8255_cleanup(dev, dev->subdevices + NI_8255_DIO_SUBDEV);
+}
+
+static void init_ao_67xx(comedi_device * dev, comedi_subdevice * s)
+{
+	int i;
+
+	for (i = 0; i < s->n_chan; i++)
+	{
+		ni_ao_win_outw(dev, AO_Channel(i) | 0x0,
+			AO_Configuration_2_67xx);
+	}
+	ao_win_out(0x0, AO_Later_Single_Point_Updates);
+}
+
+static unsigned ni_gpct_to_stc_register(enum ni_gpct_register reg)
+{
+	unsigned stc_register;
+	switch (reg) {
+	case NITIO_G0_Autoincrement_Reg:
+		stc_register = G_Autoincrement_Register(0);
+		break;
+	case NITIO_G1_Autoincrement_Reg:
+		stc_register = G_Autoincrement_Register(1);
+		break;
+	case NITIO_G0_Command_Reg:
+		stc_register = G_Command_Register(0);
+		break;
+	case NITIO_G1_Command_Reg:
+		stc_register = G_Command_Register(1);
+		break;
+	case NITIO_G0_HW_Save_Reg:
+		stc_register = G_HW_Save_Register(0);
+		break;
+	case NITIO_G1_HW_Save_Reg:
+		stc_register = G_HW_Save_Register(1);
+		break;
+	case NITIO_G0_SW_Save_Reg:
+		stc_register = G_Save_Register(0);
+		break;
+	case NITIO_G1_SW_Save_Reg:
+		stc_register = G_Save_Register(1);
+		break;
+	case NITIO_G0_Mode_Reg:
+		stc_register = G_Mode_Register(0);
+		break;
+	case NITIO_G1_Mode_Reg:
+		stc_register = G_Mode_Register(1);
+		break;
+	case NITIO_G0_LoadA_Reg:
+		stc_register = G_Load_A_Register(0);
+		break;
+	case NITIO_G1_LoadA_Reg:
+		stc_register = G_Load_A_Register(1);
+		break;
+	case NITIO_G0_LoadB_Reg:
+		stc_register = G_Load_B_Register(0);
+		break;
+	case NITIO_G1_LoadB_Reg:
+		stc_register = G_Load_B_Register(1);
+		break;
+	case NITIO_G0_Input_Select_Reg:
+		stc_register = G_Input_Select_Register(0);
+		break;
+	case NITIO_G1_Input_Select_Reg:
+		stc_register = G_Input_Select_Register(1);
+		break;
+	case NITIO_G01_Status_Reg:
+		stc_register = G_Status_Register;
+		break;
+	case NITIO_G01_Joint_Reset_Reg:
+		stc_register = Joint_Reset_Register;
+		break;
+	case NITIO_G01_Joint_Status1_Reg:
+		stc_register = Joint_Status_1_Register;
+		break;
+	case NITIO_G01_Joint_Status2_Reg:
+		stc_register = Joint_Status_2_Register;
+		break;
+	case NITIO_G0_Interrupt_Acknowledge_Reg:
+		stc_register = Interrupt_A_Ack_Register;
+		break;
+	case NITIO_G1_Interrupt_Acknowledge_Reg:
+		stc_register = Interrupt_B_Ack_Register;
+		break;
+	case NITIO_G0_Status_Reg:
+		stc_register = AI_Status_1_Register;
+		break;
+	case NITIO_G1_Status_Reg:
+		stc_register = AO_Status_1_Register;
+		break;
+	case NITIO_G0_Interrupt_Enable_Reg:
+		stc_register = Interrupt_A_Enable_Register;
+		break;
+	case NITIO_G1_Interrupt_Enable_Reg:
+		stc_register = Interrupt_B_Enable_Register;
+		break;
+	default:
+		rt_printk("%s: unhandled register 0x%x in switch.\n",
+			__FUNCTION__, reg);
+		BUG();
+		return 0;
+		break;
+	}
+	return stc_register;
+}
+
+static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
+	enum ni_gpct_register reg)
+{
+	comedi_device *dev = counter->counter_dev->dev;
+	unsigned stc_register;
+	/* bits in the join reset register which are relevant to counters */
+	static const unsigned gpct_joint_reset_mask = G0_Reset | G1_Reset;
+	static const unsigned gpct_interrupt_a_enable_mask =
+		G0_Gate_Interrupt_Enable | G0_TC_Interrupt_Enable;
+	static const unsigned gpct_interrupt_b_enable_mask =
+		G1_Gate_Interrupt_Enable | G1_TC_Interrupt_Enable;
+
+	switch (reg) {
+		/* m-series-only registers */
+	case NITIO_G0_Counting_Mode_Reg:
+		ni_writew(bits, M_Offset_G0_Counting_Mode);
+		break;
+	case NITIO_G1_Counting_Mode_Reg:
+		ni_writew(bits, M_Offset_G1_Counting_Mode);
+		break;
+	case NITIO_G0_Second_Gate_Reg:
+		ni_writew(bits, M_Offset_G0_Second_Gate);
+		break;
+	case NITIO_G1_Second_Gate_Reg:
+		ni_writew(bits, M_Offset_G1_Second_Gate);
+		break;
+	case NITIO_G0_DMA_Config_Reg:
+		ni_writew(bits, M_Offset_G0_DMA_Config);
+		break;
+	case NITIO_G1_DMA_Config_Reg:
+		ni_writew(bits, M_Offset_G1_DMA_Config);
+		break;
+	case NITIO_G0_ABZ_Reg:
+		ni_writew(bits, M_Offset_G0_MSeries_ABZ);
+		break;
+	case NITIO_G1_ABZ_Reg:
+		ni_writew(bits, M_Offset_G1_MSeries_ABZ);
+		break;
+
+		/* 32 bit registers */
+	case NITIO_G0_LoadA_Reg:
+	case NITIO_G1_LoadA_Reg:
+	case NITIO_G0_LoadB_Reg:
+	case NITIO_G1_LoadB_Reg:
+		stc_register = ni_gpct_to_stc_register(reg);
+		devpriv->stc_writel(dev, bits, stc_register);
+		break;
+
+		/* 16 bit registers */
+	case NITIO_G0_Interrupt_Enable_Reg:
+		BUG_ON(bits & ~gpct_interrupt_a_enable_mask);
+		ni_set_bitfield(dev, Interrupt_A_Enable_Register,
+			gpct_interrupt_a_enable_mask, bits);
+		break;
+	case NITIO_G1_Interrupt_Enable_Reg:
+		BUG_ON(bits & ~gpct_interrupt_b_enable_mask);
+		ni_set_bitfield(dev, Interrupt_B_Enable_Register,
+			gpct_interrupt_b_enable_mask, bits);
+		break;
+	case NITIO_G01_Joint_Reset_Reg:
+		BUG_ON(bits & ~gpct_joint_reset_mask);
+		/* fall-through */
+	default:
+		stc_register = ni_gpct_to_stc_register(reg);
+		devpriv->stc_writew(dev, bits, stc_register);
+	}
+}
+
+static unsigned ni_gpct_read_register(struct ni_gpct *counter,
+	enum ni_gpct_register reg)
+{
+	comedi_device *dev = counter->counter_dev->dev;
+	unsigned stc_register;
+	switch (reg) {
+		/* m-series only registers */
+	case NITIO_G0_DMA_Status_Reg:
+		return ni_readw(M_Offset_G0_DMA_Status);
+		break;
+	case NITIO_G1_DMA_Status_Reg:
+		return ni_readw(M_Offset_G1_DMA_Status);
+		break;
+
+		/* 32 bit registers */
+	case NITIO_G0_HW_Save_Reg:
+	case NITIO_G1_HW_Save_Reg:
+	case NITIO_G0_SW_Save_Reg:
+	case NITIO_G1_SW_Save_Reg:
+		stc_register = ni_gpct_to_stc_register(reg);
+		return devpriv->stc_readl(dev, stc_register);
+		break;
+
+		/* 16 bit registers */
+	default:
+		stc_register = ni_gpct_to_stc_register(reg);
+		return devpriv->stc_readw(dev, stc_register);
+		break;
+	}
+	return 0;
+}
+
+static int ni_freq_out_insn_read(comedi_device * dev,
+	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = devpriv->clock_and_fout & FOUT_Divider_mask;
+	return 1;
+}
+
+static int ni_freq_out_insn_write(comedi_device * dev,
+	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+{
+	devpriv->clock_and_fout &= ~FOUT_Enable;
+	devpriv->stc_writew(dev, devpriv->clock_and_fout,
+		Clock_and_FOUT_Register);
+	devpriv->clock_and_fout &= ~FOUT_Divider_mask;
+	devpriv->clock_and_fout |= FOUT_Divider(data[0]);
+	devpriv->clock_and_fout |= FOUT_Enable;
+	devpriv->stc_writew(dev, devpriv->clock_and_fout,
+		Clock_and_FOUT_Register);
+	return insn->n;
+}
+
+static int ni_set_freq_out_clock(comedi_device * dev, lsampl_t clock_source)
+{
+	switch (clock_source) {
+	case NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC:
+		devpriv->clock_and_fout &= ~FOUT_Timebase_Select;
+		break;
+	case NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC:
+		devpriv->clock_and_fout |= FOUT_Timebase_Select;
+		break;
+	default:
+		return -EINVAL;
+	}
+	devpriv->stc_writew(dev, devpriv->clock_and_fout,
+		Clock_and_FOUT_Register);
+	return 3;
+}
+
+static void ni_get_freq_out_clock(comedi_device * dev, lsampl_t * clock_source,
+	lsampl_t * clock_period_ns)
+{
+	if (devpriv->clock_and_fout & FOUT_Timebase_Select) {
+		*clock_source = NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC;
+		*clock_period_ns = TIMEBASE_2_NS;
+	} else {
+		*clock_source = NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC;
+		*clock_period_ns = TIMEBASE_1_NS * 2;
+	}
+}
+
+static int ni_freq_out_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	switch (data[0]) {
+	case INSN_CONFIG_SET_CLOCK_SRC:
+		return ni_set_freq_out_clock(dev, data[1]);
+		break;
+	case INSN_CONFIG_GET_CLOCK_SRC:
+		ni_get_freq_out_clock(dev, &data[1], &data[2]);
+		return 3;
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+static int ni_alloc_private(comedi_device * dev)
+{
+	int ret;
+
+	ret = alloc_private(dev, sizeof(ni_private));
+	if (ret < 0)
+		return ret;
+
+	spin_lock_init(&devpriv->window_lock);
+	spin_lock_init(&devpriv->soft_reg_copy_lock);
+	spin_lock_init(&devpriv->mite_channel_lock);
+
+	return 0;
+};
+
+static int ni_E_init(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_subdevice *s;
+	unsigned j;
+	enum ni_gpct_variant counter_variant;
+
+	if (boardtype.n_aochan > MAX_N_AO_CHAN) {
+		printk("bug! boardtype.n_aochan > MAX_N_AO_CHAN\n");
+		return -EINVAL;
+	}
+
+	if (alloc_subdevices(dev, NI_NUM_SUBDEVICES) < 0)
+		return -ENOMEM;
+
+	/* analog input subdevice */
+
+	s = dev->subdevices + NI_AI_SUBDEV;
+	dev->read_subdev = s;
+	if (boardtype.n_adchan) {
+		s->type = COMEDI_SUBD_AI;
+		s->subdev_flags =
+			SDF_READABLE | SDF_DIFF | SDF_DITHER | SDF_CMD_READ;
+		if (boardtype.reg_type != ni_reg_611x)
+			s->subdev_flags |= SDF_GROUND | SDF_COMMON | SDF_OTHER;
+		if (boardtype.adbits > 16)
+			s->subdev_flags |= SDF_LSAMPL;
+		if (boardtype.reg_type & ni_reg_m_series_mask)
+			s->subdev_flags |= SDF_SOFT_CALIBRATED;
+		s->n_chan = boardtype.n_adchan;
+		s->len_chanlist = 512;
+		s->maxdata = (1 << boardtype.adbits) - 1;
+		s->range_table = ni_range_lkup[boardtype.gainlkup];
+		s->insn_read = &ni_ai_insn_read;
+		s->insn_config = &ni_ai_insn_config;
+		s->do_cmdtest = &ni_ai_cmdtest;
+		s->do_cmd = &ni_ai_cmd;
+		s->cancel = &ni_ai_reset;
+		s->poll = &ni_ai_poll;
+		s->munge = &ni_ai_munge;
+#ifdef PCIDMA
+		s->async_dma_dir = DMA_FROM_DEVICE;
+#endif
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/* analog output subdevice */
+
+	s = dev->subdevices + NI_AO_SUBDEV;
+	if (boardtype.n_aochan) {
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_WRITABLE | SDF_DEGLITCH | SDF_GROUND;
+		if (boardtype.reg_type & ni_reg_m_series_mask)
+			s->subdev_flags |= SDF_SOFT_CALIBRATED;
+		s->n_chan = boardtype.n_aochan;
+		s->maxdata = (1 << boardtype.aobits) - 1;
+		s->range_table = boardtype.ao_range_table;
+		s->insn_read = &ni_ao_insn_read;
+		if (boardtype.reg_type & ni_reg_6xxx_mask) {
+			s->insn_write = &ni_ao_insn_write_671x;
+		} else {
+			s->insn_write = &ni_ao_insn_write;
+		}
+		s->insn_config = &ni_ao_insn_config;
+#ifdef PCIDMA
+		if (boardtype.n_aochan) {
+			s->async_dma_dir = DMA_TO_DEVICE;
+#else
+		if (boardtype.ao_fifo_depth) {
+#endif
+			dev->write_subdev = s;
+			s->subdev_flags |= SDF_CMD_WRITE;
+			s->do_cmd = &ni_ao_cmd;
+			s->do_cmdtest = &ni_ao_cmdtest;
+			s->len_chanlist = boardtype.n_aochan;
+			if ((boardtype.reg_type & ni_reg_m_series_mask) == 0)
+				s->munge = ni_ao_munge;
+		}
+		s->cancel = &ni_ao_reset;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+	if ((boardtype.reg_type & ni_reg_67xx_mask))
+		init_ao_67xx(dev, s);
+
+	/* digital i/o subdevice */
+
+	s = dev->subdevices + NI_DIO_SUBDEV;
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->maxdata = 1;
+	s->io_bits = 0;		/* all bits input */
+	s->range_table = &range_digital;
+	s->n_chan = boardtype.num_p0_dio_channels;
+	if (boardtype.reg_type & ni_reg_m_series_mask) {
+		s->subdev_flags |=
+			SDF_LSAMPL | SDF_CMD_WRITE /* | SDF_CMD_READ */ ;
+		s->insn_bits = &ni_m_series_dio_insn_bits;
+		s->insn_config = &ni_m_series_dio_insn_config;
+		s->do_cmd = &ni_cdio_cmd;
+		s->do_cmdtest = &ni_cdio_cmdtest;
+		s->cancel = &ni_cdio_cancel;
+		s->async_dma_dir = DMA_BIDIRECTIONAL;
+		s->len_chanlist = s->n_chan;
+
+		ni_writel(CDO_Reset_Bit | CDI_Reset_Bit, M_Offset_CDIO_Command);
+		ni_writel(s->io_bits, M_Offset_DIO_Direction);
+	} else {
+		s->insn_bits = &ni_dio_insn_bits;
+		s->insn_config = &ni_dio_insn_config;
+		devpriv->dio_control = DIO_Pins_Dir(s->io_bits);
+		ni_writew(devpriv->dio_control, DIO_Control_Register);
+	}
+
+	/* 8255 device */
+	s = dev->subdevices + NI_8255_DIO_SUBDEV;
+	if (boardtype.has_8255) {
+		subdev_8255_init(dev, s, ni_8255_callback, (unsigned long)dev);
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/* formerly general purpose counter/timer device, but no longer used */
+	s = dev->subdevices + NI_UNUSED_SUBDEV;
+	s->type = COMEDI_SUBD_UNUSED;
+
+	/* calibration subdevice -- ai and ao */
+	s = dev->subdevices + NI_CALIBRATION_SUBDEV;
+	s->type = COMEDI_SUBD_CALIB;
+	if (boardtype.reg_type & ni_reg_m_series_mask) {
+		// internal PWM analog output used for AI nonlinearity calibration
+		s->subdev_flags = SDF_INTERNAL;
+		s->insn_config = &ni_m_series_pwm_config;
+		s->n_chan = 1;
+		s->maxdata = 0;
+		ni_writel(0x0, M_Offset_Cal_PWM);
+	} else if (boardtype.reg_type == ni_reg_6143) {
+		// internal PWM analog output used for AI nonlinearity calibration
+		s->subdev_flags = SDF_INTERNAL;
+		s->insn_config = &ni_6143_pwm_config;
+		s->n_chan = 1;
+		s->maxdata = 0;
+	} else {
+		s->subdev_flags = SDF_WRITABLE | SDF_INTERNAL;
+		s->insn_read = &ni_calib_insn_read;
+		s->insn_write = &ni_calib_insn_write;
+		caldac_setup(dev, s);
+	}
+
+	/* EEPROM */
+	s = dev->subdevices + NI_EEPROM_SUBDEV;
+	s->type = COMEDI_SUBD_MEMORY;
+	s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
+	s->maxdata = 0xff;
+	if (boardtype.reg_type & ni_reg_m_series_mask) {
+		s->n_chan = M_SERIES_EEPROM_SIZE;
+		s->insn_read = &ni_m_series_eeprom_insn_read;
+	} else {
+		s->n_chan = 512;
+		s->insn_read = &ni_eeprom_insn_read;
+	}
+
+	/* PFI */
+	s = dev->subdevices + NI_PFI_DIO_SUBDEV;
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+	if (boardtype.reg_type & ni_reg_m_series_mask) {
+		unsigned i;
+		s->n_chan = 16;
+		ni_writew(s->state, M_Offset_PFI_DO);
+		for (i = 0; i < NUM_PFI_OUTPUT_SELECT_REGS; ++i) {
+			ni_writew(devpriv->pfi_output_select_reg[i],
+				M_Offset_PFI_Output_Select(i + 1));
+		}
+	} else {
+		s->n_chan = 10;
+	}
+	s->maxdata = 1;
+	if (boardtype.reg_type & ni_reg_m_series_mask) {
+		s->insn_bits = &ni_pfi_insn_bits;
+	}
+	s->insn_config = &ni_pfi_insn_config;
+	ni_set_bits(dev, IO_Bidirection_Pin_Register, ~0, 0);
+
+	/* cs5529 calibration adc */
+	s = dev->subdevices + NI_CS5529_CALIBRATION_SUBDEV;
+	if (boardtype.reg_type & ni_reg_67xx_mask) {
+		s->type = COMEDI_SUBD_AI;
+		s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_INTERNAL;
+		// one channel for each analog output channel
+		s->n_chan = boardtype.n_aochan;
+		s->maxdata = (1 << 16) - 1;
+		s->range_table = &range_unknown;	/* XXX */
+		s->insn_read = cs5529_ai_insn_read;
+		s->insn_config = NULL;
+		init_cs5529(dev);
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/* Serial */
+	s = dev->subdevices + NI_SERIAL_SUBDEV;
+	s->type = COMEDI_SUBD_SERIAL;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+	s->n_chan = 1;
+	s->maxdata = 0xff;
+	s->insn_config = ni_serial_insn_config;
+	devpriv->serial_interval_ns = 0;
+	devpriv->serial_hw_mode = 0;
+
+	/* RTSI */
+	s = dev->subdevices + NI_RTSI_SUBDEV;
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+	s->n_chan = 8;
+	s->maxdata = 1;
+	s->insn_bits = ni_rtsi_insn_bits;
+	s->insn_config = ni_rtsi_insn_config;
+	ni_rtsi_init(dev);
+
+	if (boardtype.reg_type & ni_reg_m_series_mask) {
+		counter_variant = ni_gpct_variant_m_series;
+	} else {
+		counter_variant = ni_gpct_variant_e_series;
+	}
+	devpriv->counter_dev = ni_gpct_device_construct(dev,
+		&ni_gpct_write_register, &ni_gpct_read_register,
+		counter_variant, NUM_GPCT);
+	/* General purpose counters */
+	for (j = 0; j < NUM_GPCT; ++j) {
+		s = dev->subdevices + NI_GPCT_SUBDEV(j);
+		s->type = COMEDI_SUBD_COUNTER;
+		s->subdev_flags =
+			SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL | SDF_CMD_READ
+			/* | SDF_CMD_WRITE */ ;
+		s->n_chan = 3;
+		if (boardtype.reg_type & ni_reg_m_series_mask)
+			s->maxdata = 0xffffffff;
+		else
+			s->maxdata = 0xffffff;
+		s->insn_read = &ni_gpct_insn_read;
+		s->insn_write = &ni_gpct_insn_write;
+		s->insn_config = &ni_gpct_insn_config;
+		s->do_cmd = &ni_gpct_cmd;
+		s->len_chanlist = 1;
+		s->do_cmdtest = &ni_gpct_cmdtest;
+		s->cancel = &ni_gpct_cancel;
+		s->async_dma_dir = DMA_BIDIRECTIONAL;
+		s->private = &devpriv->counter_dev->counters[j];
+
+		devpriv->counter_dev->counters[j].chip_index = 0;
+		devpriv->counter_dev->counters[j].counter_index = j;
+		ni_tio_init_counter(&devpriv->counter_dev->counters[j]);
+	}
+
+	/* Frequency output */
+	s = dev->subdevices + NI_FREQ_OUT_SUBDEV;
+	s->type = COMEDI_SUBD_COUNTER;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+	s->n_chan = 1;
+	s->maxdata = 0xf;
+	s->insn_read = &ni_freq_out_insn_read;
+	s->insn_write = &ni_freq_out_insn_write;
+	s->insn_config = &ni_freq_out_insn_config;
+
+	/* ai configuration */
+	ni_ai_reset(dev, dev->subdevices + NI_AI_SUBDEV);
+	if ((boardtype.reg_type & ni_reg_6xxx_mask) == 0) {
+		// BEAM is this needed for PCI-6143 ??
+		devpriv->clock_and_fout =
+			Slow_Internal_Time_Divide_By_2 |
+			Slow_Internal_Timebase |
+			Clock_To_Board_Divide_By_2 |
+			Clock_To_Board |
+			AI_Output_Divide_By_2 | AO_Output_Divide_By_2;
+	} else {
+		devpriv->clock_and_fout =
+			Slow_Internal_Time_Divide_By_2 |
+			Slow_Internal_Timebase |
+			Clock_To_Board_Divide_By_2 | Clock_To_Board;
+	}
+	devpriv->stc_writew(dev, devpriv->clock_and_fout,
+		Clock_and_FOUT_Register);
+
+	/* analog output configuration */
+	ni_ao_reset(dev, dev->subdevices + NI_AO_SUBDEV);
+
+	if (dev->irq) {
+		devpriv->stc_writew(dev,
+			(IRQ_POLARITY ? Interrupt_Output_Polarity : 0) |
+			(Interrupt_Output_On_3_Pins & 0) | Interrupt_A_Enable |
+			Interrupt_B_Enable |
+			Interrupt_A_Output_Select(interrupt_pin(dev->
+					irq)) |
+			Interrupt_B_Output_Select(interrupt_pin(dev->irq)),
+			Interrupt_Control_Register);
+	}
+
+	/* DMA setup */
+	ni_writeb(devpriv->ai_ao_select_reg, AI_AO_Select);
+	ni_writeb(devpriv->g0_g1_select_reg, G0_G1_Select);
+
+	if (boardtype.reg_type & ni_reg_6xxx_mask) {
+		ni_writeb(0, Magic_611x);
+	} else if (boardtype.reg_type & ni_reg_m_series_mask) {
+		int channel;
+		for (channel = 0; channel < boardtype.n_aochan; ++channel) {
+			ni_writeb(0xf, M_Offset_AO_Waveform_Order(channel));
+			ni_writeb(0x0,
+				M_Offset_AO_Reference_Attenuation(channel));
+		}
+		ni_writeb(0x0, M_Offset_AO_Calibration);
+	}
+
+	printk("\n");
+	return 0;
+}
+
+static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
+{
+	comedi_device *dev = (comedi_device *) arg;
+
+	if (dir) {
+		ni_writeb(data, Port_A + 2 * port);
+		return 0;
+	} else {
+		return ni_readb(Port_A + 2 * port);
+	}
+}
+
+/*
+	presents the EEPROM as a subdevice
+*/
+
+static int ni_eeprom_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));
+
+	return 1;
+}
+
+/*
+	reads bytes out of eeprom
+*/
+
+static int ni_read_eeprom(comedi_device * dev, int addr)
+{
+	int bit;
+	int bitstring;
+
+	bitstring = 0x0300 | ((addr & 0x100) << 3) | (addr & 0xff);
+	ni_writeb(0x04, Serial_Command);
+	for (bit = 0x8000; bit; bit >>= 1) {
+		ni_writeb(0x04 | ((bit & bitstring) ? 0x02 : 0),
+			Serial_Command);
+		ni_writeb(0x05 | ((bit & bitstring) ? 0x02 : 0),
+			Serial_Command);
+	}
+	bitstring = 0;
+	for (bit = 0x80; bit; bit >>= 1) {
+		ni_writeb(0x04, Serial_Command);
+		ni_writeb(0x05, Serial_Command);
+		bitstring |= ((ni_readb(XXX_Status) & PROMOUT) ? bit : 0);
+	}
+	ni_writeb(0x00, Serial_Command);
+
+	return bitstring;
+}
+
+static int ni_m_series_eeprom_insn_read(comedi_device * dev,
+	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
+static int ni_get_pwm_config(comedi_device * dev, lsampl_t * data)
+{
+	data[1] = devpriv->pwm_up_count * devpriv->clock_ns;
+	data[2] = devpriv->pwm_down_count * devpriv->clock_ns;
+	return 3;
+}
+
+static int ni_m_series_pwm_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned up_count, down_count;
+	switch (data[0]) {
+	case INSN_CONFIG_PWM_OUTPUT:
+		switch (data[1]) {
+		case TRIG_ROUND_NEAREST:
+			up_count =
+				(data[2] +
+				devpriv->clock_ns / 2) / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_DOWN:
+			up_count = data[2] / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_UP:
+			up_count =
+				(data[2] + devpriv->clock_ns -
+				1) / devpriv->clock_ns;
+			break;
+		default:
+			return -EINVAL;
+			break;
+		}
+		switch (data[3]) {
+		case TRIG_ROUND_NEAREST:
+			down_count =
+				(data[4] +
+				devpriv->clock_ns / 2) / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_DOWN:
+			down_count = data[4] / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_UP:
+			down_count =
+				(data[4] + devpriv->clock_ns -
+				1) / devpriv->clock_ns;
+			break;
+		default:
+			return -EINVAL;
+			break;
+		}
+		if (up_count * devpriv->clock_ns != data[2] ||
+			down_count * devpriv->clock_ns != data[4]) {
+			data[2] = up_count * devpriv->clock_ns;
+			data[4] = down_count * devpriv->clock_ns;
+			return -EAGAIN;
+		}
+		ni_writel(MSeries_Cal_PWM_High_Time_Bits(up_count) |
+			MSeries_Cal_PWM_Low_Time_Bits(down_count),
+			M_Offset_Cal_PWM);
+		devpriv->pwm_up_count = up_count;
+		devpriv->pwm_down_count = down_count;
+		return 5;
+		break;
+	case INSN_CONFIG_GET_PWM_OUTPUT:
+		return ni_get_pwm_config(dev, data);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 0;
+}
+
+static int ni_6143_pwm_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned up_count, down_count;
+	switch (data[0]) {
+	case INSN_CONFIG_PWM_OUTPUT:
+		switch (data[1]) {
+		case TRIG_ROUND_NEAREST:
+			up_count =
+				(data[2] +
+				devpriv->clock_ns / 2) / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_DOWN:
+			up_count = data[2] / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_UP:
+			up_count =
+				(data[2] + devpriv->clock_ns -
+				1) / devpriv->clock_ns;
+			break;
+		default:
+			return -EINVAL;
+			break;
+		}
+		switch (data[3]) {
+		case TRIG_ROUND_NEAREST:
+			down_count =
+				(data[4] +
+				devpriv->clock_ns / 2) / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_DOWN:
+			down_count = data[4] / devpriv->clock_ns;
+			break;
+		case TRIG_ROUND_UP:
+			down_count =
+				(data[4] + devpriv->clock_ns -
+				1) / devpriv->clock_ns;
+			break;
+		default:
+			return -EINVAL;
+			break;
+		}
+		if (up_count * devpriv->clock_ns != data[2] ||
+			down_count * devpriv->clock_ns != data[4]) {
+			data[2] = up_count * devpriv->clock_ns;
+			data[4] = down_count * devpriv->clock_ns;
+			return -EAGAIN;
+		}
+		ni_writel(up_count, Calibration_HighTime_6143);
+		devpriv->pwm_up_count = up_count;
+		ni_writel(down_count, Calibration_LowTime_6143);
+		devpriv->pwm_down_count = down_count;
+		return 5;
+		break;
+	case INSN_CONFIG_GET_PWM_OUTPUT:
+		return ni_get_pwm_config(dev, data);
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 0;
+}
+
+static void ni_write_caldac(comedi_device * dev, int addr, int val);
+/*
+	calibration subdevice
+*/
+static int ni_calib_insn_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	ni_write_caldac(dev, CR_CHAN(insn->chanspec), data[0]);
+
+	return 1;
+}
+
+static int ni_calib_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
+static int pack_mb88341(int addr, int val, int *bitstring);
+static int pack_dac8800(int addr, int val, int *bitstring);
+static int pack_dac8043(int addr, int val, int *bitstring);
+static int pack_ad8522(int addr, int val, int *bitstring);
+static int pack_ad8804(int addr, int val, int *bitstring);
+static int pack_ad8842(int addr, int val, int *bitstring);
+
+struct caldac_struct {
+	int n_chans;
+	int n_bits;
+	int (*packbits) (int, int, int *);
+};
+
+static struct caldac_struct caldacs[] = {
+	[mb88341] = {12, 8, pack_mb88341},
+	[dac8800] = {8, 8, pack_dac8800},
+	[dac8043] = {1, 12, pack_dac8043},
+	[ad8522] = {2, 12, pack_ad8522},
+	[ad8804] = {12, 8, pack_ad8804},
+	[ad8842] = {8, 8, pack_ad8842},
+	[ad8804_debug] = {16, 8, pack_ad8804},
+};
+
+static void caldac_setup(comedi_device * dev, comedi_subdevice * s)
+{
+	int i, j;
+	int n_dacs;
+	int n_chans = 0;
+	int n_bits;
+	int diffbits = 0;
+	int type;
+	int chan;
+
+	type = boardtype.caldac[0];
+	if (type == caldac_none)
+		return;
+	n_bits = caldacs[type].n_bits;
+	for (i = 0; i < 3; i++) {
+		type = boardtype.caldac[i];
+		if (type == caldac_none)
+			break;
+		if (caldacs[type].n_bits != n_bits)
+			diffbits = 1;
+		n_chans += caldacs[type].n_chans;
+	}
+	n_dacs = i;
+	s->n_chan = n_chans;
+
+	if (diffbits) {
+		unsigned int *maxdata_list;
+
+		if (n_chans > MAX_N_CALDACS) {
+			printk("BUG! MAX_N_CALDACS too small\n");
+		}
+		s->maxdata_list = maxdata_list = devpriv->caldac_maxdata_list;
+		chan = 0;
+		for (i = 0; i < n_dacs; i++) {
+			type = boardtype.caldac[i];
+			for (j = 0; j < caldacs[type].n_chans; j++) {
+				maxdata_list[chan] =
+					(1 << caldacs[type].n_bits) - 1;
+				chan++;
+			}
+		}
+
+		for (chan = 0; chan < s->n_chan; chan++)
+			ni_write_caldac(dev, i, s->maxdata_list[i] / 2);
+	} else {
+		type = boardtype.caldac[0];
+		s->maxdata = (1 << caldacs[type].n_bits) - 1;
+
+		for (chan = 0; chan < s->n_chan; chan++)
+			ni_write_caldac(dev, i, s->maxdata / 2);
+	}
+}
+
+static void ni_write_caldac(comedi_device * dev, int addr, int val)
+{
+	unsigned int loadbit = 0, bits = 0, bit, bitstring = 0;
+	int i;
+	int type;
+
+	//printk("ni_write_caldac: chan=%d val=%d\n",addr,val);
+	if (devpriv->caldacs[addr] == val)
+		return;
+	devpriv->caldacs[addr] = val;
+
+	for (i = 0; i < 3; i++) {
+		type = boardtype.caldac[i];
+		if (type == caldac_none)
+			break;
+		if (addr < caldacs[type].n_chans) {
+			bits = caldacs[type].packbits(addr, val, &bitstring);
+			loadbit = SerDacLd(i);
+			//printk("caldac: using i=%d addr=%d %x\n",i,addr,bitstring);
+			break;
+		}
+		addr -= caldacs[type].n_chans;
+	}
+
+	for (bit = 1 << (bits - 1); bit; bit >>= 1) {
+		ni_writeb(((bit & bitstring) ? 0x02 : 0), Serial_Command);
+		comedi_udelay(1);
+		ni_writeb(1 | ((bit & bitstring) ? 0x02 : 0), Serial_Command);
+		comedi_udelay(1);
+	}
+	ni_writeb(loadbit, Serial_Command);
+	comedi_udelay(1);
+	ni_writeb(0, Serial_Command);
+}
+
+static int pack_mb88341(int addr, int val, int *bitstring)
+{
+	/*
+	   Fujitsu MB 88341
+	   Note that address bits are reversed.  Thanks to
+	   Ingo Keen for noticing this.
+
+	   Note also that the 88341 expects address values from
+	   1-12, whereas we use channel numbers 0-11.  The NI
+	   docs use 1-12, also, so be careful here.
+	 */
+	addr++;
+	*bitstring = ((addr & 0x1) << 11) |
+		((addr & 0x2) << 9) |
+		((addr & 0x4) << 7) | ((addr & 0x8) << 5) | (val & 0xff);
+	return 12;
+}
+
+static int pack_dac8800(int addr, int val, int *bitstring)
+{
+	*bitstring = ((addr & 0x7) << 8) | (val & 0xff);
+	return 11;
+}
+
+static int pack_dac8043(int addr, int val, int *bitstring)
+{
+	*bitstring = val & 0xfff;
+	return 12;
+}
+
+static int pack_ad8522(int addr, int val, int *bitstring)
+{
+	*bitstring = (val & 0xfff) | (addr ? 0xc000 : 0xa000);
+	return 16;
+}
+
+static int pack_ad8804(int addr, int val, int *bitstring)
+{
+	*bitstring = ((addr & 0xf) << 8) | (val & 0xff);
+	return 12;
+}
+
+static int pack_ad8842(int addr, int val, int *bitstring)
+{
+	*bitstring = ((addr + 1) << 8) | (val & 0xff);
+	return 12;
+}
+
+#if 0
+/*
+ *	Read the GPCTs current value.
+ */
+static int GPCT_G_Watch(comedi_device * dev, int chan)
+{
+	unsigned int hi1, hi2, lo;
+
+	devpriv->gpct_command[chan] &= ~G_Save_Trace;
+	devpriv->stc_writew(dev, devpriv->gpct_command[chan],
+		G_Command_Register(chan));
+
+	devpriv->gpct_command[chan] |= G_Save_Trace;
+	devpriv->stc_writew(dev, devpriv->gpct_command[chan],
+		G_Command_Register(chan));
+
+	/* This procedure is used because the two registers cannot
+	 * be read atomically. */
+	do {
+		hi1 = devpriv->stc_readw(dev, G_Save_Register_High(chan));
+		lo = devpriv->stc_readw(dev, G_Save_Register_Low(chan));
+		hi2 = devpriv->stc_readw(dev, G_Save_Register_High(chan));
+	} while (hi1 != hi2);
+
+	return (hi1 << 16) | lo;
+}
+
+static void GPCT_Reset(comedi_device * dev, int chan)
+{
+	int temp_ack_reg = 0;
+
+	//printk("GPCT_Reset...");
+	devpriv->gpct_cur_operation[chan] = GPCT_RESET;
+
+	switch (chan) {
+	case 0:
+		devpriv->stc_writew(dev, G0_Reset, Joint_Reset_Register);
+		ni_set_bits(dev, Interrupt_A_Enable_Register,
+			G0_TC_Interrupt_Enable, 0);
+		ni_set_bits(dev, Interrupt_A_Enable_Register,
+			G0_Gate_Interrupt_Enable, 0);
+		temp_ack_reg |= G0_Gate_Error_Confirm;
+		temp_ack_reg |= G0_TC_Error_Confirm;
+		temp_ack_reg |= G0_TC_Interrupt_Ack;
+		temp_ack_reg |= G0_Gate_Interrupt_Ack;
+		devpriv->stc_writew(dev, temp_ack_reg,
+			Interrupt_A_Ack_Register);
+
+		//problem...this interferes with the other ctr...
+		devpriv->an_trig_etc_reg |= GPFO_0_Output_Enable;
+		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
+			Analog_Trigger_Etc_Register);
+		break;
+	case 1:
+		devpriv->stc_writew(dev, G1_Reset, Joint_Reset_Register);
+		ni_set_bits(dev, Interrupt_B_Enable_Register,
+			G1_TC_Interrupt_Enable, 0);
+		ni_set_bits(dev, Interrupt_B_Enable_Register,
+			G0_Gate_Interrupt_Enable, 0);
+		temp_ack_reg |= G1_Gate_Error_Confirm;
+		temp_ack_reg |= G1_TC_Error_Confirm;
+		temp_ack_reg |= G1_TC_Interrupt_Ack;
+		temp_ack_reg |= G1_Gate_Interrupt_Ack;
+		devpriv->stc_writew(dev, temp_ack_reg,
+			Interrupt_B_Ack_Register);
+
+		devpriv->an_trig_etc_reg |= GPFO_1_Output_Enable;
+		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
+			Analog_Trigger_Etc_Register);
+		break;
+	};
+
+	devpriv->gpct_mode[chan] = 0;
+	devpriv->gpct_input_select[chan] = 0;
+	devpriv->gpct_command[chan] = 0;
+
+	devpriv->gpct_command[chan] |= G_Synchronized_Gate;
+
+	devpriv->stc_writew(dev, devpriv->gpct_mode[chan],
+		G_Mode_Register(chan));
+	devpriv->stc_writew(dev, devpriv->gpct_input_select[chan],
+		G_Input_Select_Register(chan));
+	devpriv->stc_writew(dev, 0, G_Autoincrement_Register(chan));
+
+	//printk("exit GPCT_Reset\n");
+}
+
+#endif
+
+static int ni_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	struct ni_gpct *counter = s->private;
+	return ni_tio_insn_config(counter, insn, data);
+}
+
+static int ni_gpct_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	struct ni_gpct *counter = s->private;
+	return ni_tio_rinsn(counter, insn, data);
+}
+
+static int ni_gpct_insn_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	struct ni_gpct *counter = s->private;
+	return ni_tio_winsn(counter, insn, data);
+}
+
+static int ni_gpct_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	int retval;
+#ifdef PCIDMA
+	struct ni_gpct *counter = s->private;
+//      const comedi_cmd *cmd = &s->async->cmd;
+
+	retval = ni_request_gpct_mite_channel(dev, counter->counter_index,
+		COMEDI_INPUT);
+	if (retval) {
+		comedi_error(dev,
+			"no dma channel available for use by counter");
+		return retval;
+	}
+	ni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);
+	ni_e_series_enable_second_irq(dev, counter->counter_index, 1);
+	retval = ni_tio_cmd(counter, s->async);
+#else
+	retval = -ENOTSUPP;
+#endif
+	return retval;
+}
+
+static int ni_gpct_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+#ifdef PCIDMA
+	struct ni_gpct *counter = s->private;
+
+	return ni_tio_cmdtest(counter, cmd);
+#else
+	return -ENOTSUPP;
+#endif
+}
+
+static int ni_gpct_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+#ifdef PCIDMA
+	struct ni_gpct *counter = s->private;
+	int retval;
+
+	retval = ni_tio_cancel(counter);
+	ni_e_series_enable_second_irq(dev, counter->counter_index, 0);
+	ni_release_gpct_mite_channel(dev, counter->counter_index);
+	return retval;
+#else
+	return 0;
+#endif
+}
+
+/*
+ *
+ *  Programmable Function Inputs
+ *
+ */
+
+static int ni_m_series_set_pfi_routing(comedi_device * dev, unsigned chan,
+	unsigned source)
+{
+	unsigned pfi_reg_index;
+	unsigned array_offset;
+	if ((source & 0x1f) != source)
+		return -EINVAL;
+	pfi_reg_index = 1 + chan / 3;
+	array_offset = pfi_reg_index - 1;
+	devpriv->pfi_output_select_reg[array_offset] &=
+		~MSeries_PFI_Output_Select_Mask(chan);
+	devpriv->pfi_output_select_reg[array_offset] |=
+		MSeries_PFI_Output_Select_Bits(chan, source);
+	ni_writew(devpriv->pfi_output_select_reg[array_offset],
+		M_Offset_PFI_Output_Select(pfi_reg_index));
+	return 2;
+}
+
+static int ni_old_set_pfi_routing(comedi_device * dev, unsigned chan,
+	unsigned source)
+{
+	// pre-m-series boards have fixed signals on pfi pins
+	if (source != ni_old_get_pfi_routing(dev, chan))
+		return -EINVAL;
+	return 2;
+}
+
+static int ni_set_pfi_routing(comedi_device * dev, unsigned chan,
+	unsigned source)
+{
+	if (boardtype.reg_type & ni_reg_m_series_mask)
+		return ni_m_series_set_pfi_routing(dev, chan, source);
+	else
+		return ni_old_set_pfi_routing(dev, chan, source);
+}
+
+static unsigned ni_m_series_get_pfi_routing(comedi_device * dev, unsigned chan)
+{
+	const unsigned array_offset = chan / 3;
+	return MSeries_PFI_Output_Select_Source(chan,
+		devpriv->pfi_output_select_reg[array_offset]);
+}
+
+static unsigned ni_old_get_pfi_routing(comedi_device * dev, unsigned chan)
+{
+	// pre-m-series boards have fixed signals on pfi pins
+	switch (chan) {
+	case 0:
+		return NI_PFI_OUTPUT_AI_START1;
+		break;
+	case 1:
+		return NI_PFI_OUTPUT_AI_START2;
+		break;
+	case 2:
+		return NI_PFI_OUTPUT_AI_CONVERT;
+		break;
+	case 3:
+		return NI_PFI_OUTPUT_G_SRC1;
+		break;
+	case 4:
+		return NI_PFI_OUTPUT_G_GATE1;
+		break;
+	case 5:
+		return NI_PFI_OUTPUT_AO_UPDATE_N;
+		break;
+	case 6:
+		return NI_PFI_OUTPUT_AO_START1;
+		break;
+	case 7:
+		return NI_PFI_OUTPUT_AI_START_PULSE;
+		break;
+	case 8:
+		return NI_PFI_OUTPUT_G_SRC0;
+		break;
+	case 9:
+		return NI_PFI_OUTPUT_G_GATE0;
+		break;
+	default:
+		rt_printk("%s: bug, unhandled case in switch.\n", __FUNCTION__);
+		break;
+	}
+	return 0;
+}
+
+static unsigned ni_get_pfi_routing(comedi_device * dev, unsigned chan)
+{
+	if (boardtype.reg_type & ni_reg_m_series_mask)
+		return ni_m_series_get_pfi_routing(dev, chan);
+	else
+		return ni_old_get_pfi_routing(dev, chan);
+}
+
+static int ni_config_filter(comedi_device * dev, unsigned pfi_channel,
+	enum ni_pfi_filter_select filter)
+{
+	unsigned bits;
+	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
+		return -ENOTSUPP;
+	}
+	bits = ni_readl(M_Offset_PFI_Filter);
+	bits &= ~MSeries_PFI_Filter_Select_Mask(pfi_channel);
+	bits |= MSeries_PFI_Filter_Select_Bits(pfi_channel, filter);
+	ni_writel(bits, M_Offset_PFI_Filter);
+	return 0;
+}
+
+static int ni_pfi_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
+		return -ENOTSUPP;
+	}
+	if (data[0]) {
+		s->state &= ~data[0];
+		s->state |= (data[0] & data[1]);
+		ni_writew(s->state, M_Offset_PFI_DO);
+	}
+	data[1] = ni_readw(M_Offset_PFI_DI);
+	return 2;
+}
+
+static int ni_pfi_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned int chan;
+
+	if (insn->n < 1)
+		return -EINVAL;
+
+	chan = CR_CHAN(insn->chanspec);
+
+	switch (data[0]) {
+	case COMEDI_OUTPUT:
+		ni_set_bits(dev, IO_Bidirection_Pin_Register, 1 << chan, 1);
+		break;
+	case COMEDI_INPUT:
+		ni_set_bits(dev, IO_Bidirection_Pin_Register, 1 << chan, 0);
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] =
+			(devpriv->
+			io_bidirection_pin_reg & (1 << chan)) ? COMEDI_OUTPUT :
+			COMEDI_INPUT;
+		return 0;
+		break;
+	case INSN_CONFIG_SET_ROUTING:
+		return ni_set_pfi_routing(dev, chan, data[1]);
+		break;
+	case INSN_CONFIG_GET_ROUTING:
+		data[1] = ni_get_pfi_routing(dev, chan);
+		break;
+	case INSN_CONFIG_FILTER:
+		return ni_config_filter(dev, chan, data[1]);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*
+ *
+ *  NI RTSI Bus Functions
+ *
+ */
+static void ni_rtsi_init(comedi_device * dev)
+{
+	// Initialises the RTSI bus signal switch to a default state
+
+	// Set clock mode to internal
+	devpriv->clock_and_fout2 = MSeries_RTSI_10MHz_Bit;
+	if (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0) {
+		rt_printk("ni_set_master_clock failed, bug?");
+	}
+	// default internal lines routing to RTSI bus lines
+	devpriv->rtsi_trig_a_output_reg =
+		RTSI_Trig_Output_Bits(0,
+		NI_RTSI_OUTPUT_ADR_START1) | RTSI_Trig_Output_Bits(1,
+		NI_RTSI_OUTPUT_ADR_START2) | RTSI_Trig_Output_Bits(2,
+		NI_RTSI_OUTPUT_SCLKG) | RTSI_Trig_Output_Bits(3,
+		NI_RTSI_OUTPUT_DACUPDN);
+	devpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
+		RTSI_Trig_A_Output_Register);
+	devpriv->rtsi_trig_b_output_reg =
+		RTSI_Trig_Output_Bits(4,
+		NI_RTSI_OUTPUT_DA_START1) | RTSI_Trig_Output_Bits(5,
+		NI_RTSI_OUTPUT_G_SRC0) | RTSI_Trig_Output_Bits(6,
+		NI_RTSI_OUTPUT_G_GATE0);
+	if (boardtype.reg_type & ni_reg_m_series_mask)
+		devpriv->rtsi_trig_b_output_reg |=
+			RTSI_Trig_Output_Bits(7, NI_RTSI_OUTPUT_RTSI_OSC);
+	devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
+		RTSI_Trig_B_Output_Register);
+
+	// Sets the source and direction of the 4 on board lines
+//      devpriv->stc_writew(dev, 0x0000, RTSI_Board_Register);
+}
+
+static int ni_rtsi_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	if (insn->n != 2)
+		return -EINVAL;
+
+	data[1] = 0;
+
+	return 2;
+}
+
+/* Find best multiplier/divider to try and get the PLL running at 80 MHz
+ * given an arbitrary frequency input clock */
+static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
+	unsigned *freq_divider, unsigned *freq_multiplier,
+	unsigned *actual_period_ns)
+{
+	unsigned div;
+	unsigned best_div = 1;
+	static const unsigned max_div = 0x10;
+	unsigned mult;
+	unsigned best_mult = 1;
+	static const unsigned max_mult = 0x100;
+	static const unsigned pico_per_nano = 1000;
+
+	const unsigned reference_picosec = reference_period_ns * pico_per_nano;
+	/* m-series wants the phased-locked loop to output 80MHz, which is divided by 4 to
+	 * 20 MHz for most timing clocks */
+	static const unsigned target_picosec = 12500;
+	static const unsigned fudge_factor_80_to_20Mhz = 4;
+	int best_period_picosec = 0;
+	for (div = 1; div <= max_div; ++div) {
+		for (mult = 1; mult <= max_mult; ++mult) {
+			unsigned new_period_ps =
+				(reference_picosec * div) / mult;
+			if (abs(new_period_ps - target_picosec) <
+				abs(best_period_picosec - target_picosec)) {
+				best_period_picosec = new_period_ps;
+				best_div = div;
+				best_mult = mult;
+			}
+		}
+	}
+	if (best_period_picosec == 0) {
+		rt_printk("%s: bug, failed to find pll parameters\n",
+			__FUNCTION__);
+		return -EIO;
+	}
+	*freq_divider = best_div;
+	*freq_multiplier = best_mult;
+	*actual_period_ns =
+		(best_period_picosec * fudge_factor_80_to_20Mhz +
+		(pico_per_nano / 2)) / pico_per_nano;
+	return 0;
+}
+
+static inline unsigned num_configurable_rtsi_channels(comedi_device * dev)
+{
+	if (boardtype.reg_type & ni_reg_m_series_mask)
+		return 8;
+	else
+		return 7;
+}
+
+static int ni_mseries_set_pll_master_clock(comedi_device * dev, unsigned source,
+	unsigned period_ns)
+{
+	static const unsigned min_period_ns = 50;
+	static const unsigned max_period_ns = 1000;
+	static const unsigned timeout = 1000;
+	unsigned pll_control_bits;
+	unsigned freq_divider;
+	unsigned freq_multiplier;
+	unsigned i;
+	int retval;
+	if (source == NI_MIO_PLL_PXI10_CLOCK)
+		period_ns = 100;
+	// these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that
+	if (period_ns < min_period_ns || period_ns > max_period_ns) {
+		rt_printk
+			("%s: you must specify an input clock frequency between %i and %i nanosec "
+			"for the phased-lock loop.\n", __FUNCTION__,
+			min_period_ns, max_period_ns);
+		return -EINVAL;
+	}
+	devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
+	devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+		RTSI_Trig_Direction_Register);
+	pll_control_bits =
+		MSeries_PLL_Enable_Bit | MSeries_PLL_VCO_Mode_75_150MHz_Bits;
+	devpriv->clock_and_fout2 |=
+		MSeries_Timebase1_Select_Bit | MSeries_Timebase3_Select_Bit;
+	devpriv->clock_and_fout2 &= ~MSeries_PLL_In_Source_Select_Mask;
+	switch (source) {
+	case NI_MIO_PLL_PXI_STAR_TRIGGER_CLOCK:
+		devpriv->clock_and_fout2 |=
+			MSeries_PLL_In_Source_Select_Star_Trigger_Bits;
+		retval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,
+			&freq_multiplier, &devpriv->clock_ns);
+		if (retval < 0)
+			return retval;
+		break;
+	case NI_MIO_PLL_PXI10_CLOCK:
+		/* pxi clock is 10MHz */
+		devpriv->clock_and_fout2 |=
+			MSeries_PLL_In_Source_Select_PXI_Clock10;
+		retval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,
+			&freq_multiplier, &devpriv->clock_ns);
+		if (retval < 0)
+			return retval;
+		break;
+	default:
+		{
+			unsigned rtsi_channel;
+			static const unsigned max_rtsi_channel = 7;
+			for (rtsi_channel = 0; rtsi_channel <= max_rtsi_channel;
+				++rtsi_channel) {
+				if (source ==
+					NI_MIO_PLL_RTSI_CLOCK(rtsi_channel)) {
+					devpriv->clock_and_fout2 |=
+						MSeries_PLL_In_Source_Select_RTSI_Bits
+						(rtsi_channel);
+					break;
+				}
+			}
+			if (rtsi_channel > max_rtsi_channel)
+				return -EINVAL;
+			retval = ni_mseries_get_pll_parameters(period_ns,
+				&freq_divider, &freq_multiplier,
+				&devpriv->clock_ns);
+			if (retval < 0)
+				return retval;
+		}
+		break;
+	}
+	ni_writew(devpriv->clock_and_fout2, M_Offset_Clock_and_Fout2);
+	pll_control_bits |=
+		MSeries_PLL_Divisor_Bits(freq_divider) |
+		MSeries_PLL_Multiplier_Bits(freq_multiplier);
+//      rt_printk("using divider=%i, multiplier=%i for PLL.  pll_control_bits = 0x%x\n", freq_divider, freq_multiplier, pll_control_bits);
+//      rt_printk("clock_ns=%d\n", devpriv->clock_ns);
+	ni_writew(pll_control_bits, M_Offset_PLL_Control);
+	devpriv->clock_source = source;
+	/* it seems to typically take a few hundred microseconds for PLL to lock */
+	for (i = 0; i < timeout; ++i) {
+		if (ni_readw(M_Offset_PLL_Status) & MSeries_PLL_Locked_Bit) {
+			break;
+		}
+		udelay(1);
+	}
+	if (i == timeout) {
+		rt_printk
+			("%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns.\n",
+			__FUNCTION__, source, period_ns);
+		return -ETIMEDOUT;
+	}
+	return 3;
+}
+
+static int ni_set_master_clock(comedi_device * dev, unsigned source,
+	unsigned period_ns)
+{
+	if (source == NI_MIO_INTERNAL_CLOCK) {
+		devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
+		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+			RTSI_Trig_Direction_Register);
+		devpriv->clock_ns = TIMEBASE_1_NS;
+		if (boardtype.reg_type & ni_reg_m_series_mask) {
+			devpriv->clock_and_fout2 &=
+				~(MSeries_Timebase1_Select_Bit |
+				MSeries_Timebase3_Select_Bit);
+			ni_writew(devpriv->clock_and_fout2,
+				M_Offset_Clock_and_Fout2);
+			ni_writew(0, M_Offset_PLL_Control);
+		}
+		devpriv->clock_source = source;
+	} else {
+		if (boardtype.reg_type & ni_reg_m_series_mask) {
+			return ni_mseries_set_pll_master_clock(dev, source,
+				period_ns);
+		} else {
+			if (source == NI_MIO_RTSI_CLOCK) {
+				devpriv->rtsi_trig_direction_reg |=
+					Use_RTSI_Clock_Bit;
+				devpriv->stc_writew(dev,
+					devpriv->rtsi_trig_direction_reg,
+					RTSI_Trig_Direction_Register);
+				if (period_ns == 0) {
+					rt_printk
+						("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",
+						__FUNCTION__);
+					return -EINVAL;
+				} else {
+					devpriv->clock_ns = period_ns;
+				}
+				devpriv->clock_source = source;
+			} else
+				return -EINVAL;
+		}
+	}
+	return 3;
+}
+
+static int ni_valid_rtsi_output_source(comedi_device * dev, unsigned chan,
+	unsigned source)
+{
+	if (chan >= num_configurable_rtsi_channels(dev)) {
+		if (chan == old_RTSI_clock_channel) {
+			if (source == NI_RTSI_OUTPUT_RTSI_OSC)
+				return 1;
+			else {
+				rt_printk
+					("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",
+					__FUNCTION__, chan,
+					old_RTSI_clock_channel);
+				return 0;
+			}
+		}
+		return 0;
+	}
+	switch (source) {
+	case NI_RTSI_OUTPUT_ADR_START1:
+	case NI_RTSI_OUTPUT_ADR_START2:
+	case NI_RTSI_OUTPUT_SCLKG:
+	case NI_RTSI_OUTPUT_DACUPDN:
+	case NI_RTSI_OUTPUT_DA_START1:
+	case NI_RTSI_OUTPUT_G_SRC0:
+	case NI_RTSI_OUTPUT_G_GATE0:
+	case NI_RTSI_OUTPUT_RGOUT0:
+	case NI_RTSI_OUTPUT_RTSI_BRD_0:
+		return 1;
+		break;
+	case NI_RTSI_OUTPUT_RTSI_OSC:
+		if (boardtype.reg_type & ni_reg_m_series_mask)
+			return 1;
+		else
+			return 0;
+		break;
+	default:
+		return 0;
+		break;
+	}
+}
+
+static int ni_set_rtsi_routing(comedi_device * dev, unsigned chan,
+	unsigned source)
+{
+	if (ni_valid_rtsi_output_source(dev, chan, source) == 0)
+		return -EINVAL;
+	if (chan < 4) {
+		devpriv->rtsi_trig_a_output_reg &= ~RTSI_Trig_Output_Mask(chan);
+		devpriv->rtsi_trig_a_output_reg |=
+			RTSI_Trig_Output_Bits(chan, source);
+		devpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
+			RTSI_Trig_A_Output_Register);
+	} else if (chan < 8) {
+		devpriv->rtsi_trig_b_output_reg &= ~RTSI_Trig_Output_Mask(chan);
+		devpriv->rtsi_trig_b_output_reg |=
+			RTSI_Trig_Output_Bits(chan, source);
+		devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
+			RTSI_Trig_B_Output_Register);
+	}
+	return 2;
+}
+
+static unsigned ni_get_rtsi_routing(comedi_device * dev, unsigned chan)
+{
+	if (chan < 4) {
+		return RTSI_Trig_Output_Source(chan,
+			devpriv->rtsi_trig_a_output_reg);
+	} else if (chan < num_configurable_rtsi_channels(dev)) {
+		return RTSI_Trig_Output_Source(chan,
+			devpriv->rtsi_trig_b_output_reg);
+	} else {
+		if (chan == old_RTSI_clock_channel)
+			return NI_RTSI_OUTPUT_RTSI_OSC;
+		rt_printk("%s: bug! should never get here?\n", __FUNCTION__);
+		return 0;
+	}
+}
+
+static int ni_rtsi_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_OUTPUT:
+		if (chan < num_configurable_rtsi_channels(dev)) {
+			devpriv->rtsi_trig_direction_reg |=
+				RTSI_Output_Bit(chan,
+				(boardtype.reg_type & ni_reg_m_series_mask) !=
+				0);
+		} else if (chan == old_RTSI_clock_channel) {
+			devpriv->rtsi_trig_direction_reg |=
+				Drive_RTSI_Clock_Bit;
+		}
+		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+			RTSI_Trig_Direction_Register);
+		break;
+	case INSN_CONFIG_DIO_INPUT:
+		if (chan < num_configurable_rtsi_channels(dev)) {
+			devpriv->rtsi_trig_direction_reg &=
+				~RTSI_Output_Bit(chan,
+				(boardtype.reg_type & ni_reg_m_series_mask) !=
+				0);
+		} else if (chan == old_RTSI_clock_channel) {
+			devpriv->rtsi_trig_direction_reg &=
+				~Drive_RTSI_Clock_Bit;
+		}
+		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
+			RTSI_Trig_Direction_Register);
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		if (chan < num_configurable_rtsi_channels(dev)) {
+			data[1] =
+				(devpriv->
+				rtsi_trig_direction_reg & RTSI_Output_Bit(chan,
+					(boardtype.
+						reg_type & ni_reg_m_series_mask)
+					!=
+					0)) ? INSN_CONFIG_DIO_OUTPUT :
+				INSN_CONFIG_DIO_INPUT;
+		} else if (chan == old_RTSI_clock_channel) {
+			data[1] =
+				(devpriv->
+				rtsi_trig_direction_reg & Drive_RTSI_Clock_Bit)
+				? INSN_CONFIG_DIO_OUTPUT :
+				INSN_CONFIG_DIO_INPUT;
+		}
+		return 2;
+		break;
+	case INSN_CONFIG_SET_CLOCK_SRC:
+		return ni_set_master_clock(dev, data[1], data[2]);
+		break;
+	case INSN_CONFIG_GET_CLOCK_SRC:
+		data[1] = devpriv->clock_source;
+		data[2] = devpriv->clock_ns;
+		return 3;
+		break;
+	case INSN_CONFIG_SET_ROUTING:
+		return ni_set_rtsi_routing(dev, chan, data[1]);
+		break;
+	case INSN_CONFIG_GET_ROUTING:
+		data[1] = ni_get_rtsi_routing(dev, chan);
+		return 2;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 1;
+}
+
+static int cs5529_wait_for_idle(comedi_device * dev)
+{
+	unsigned short status;
+	const int timeout = HZ;
+	int i;
+
+	for (i = 0; i < timeout; i++) {
+		status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
+		if ((status & CSS_ADC_BUSY) == 0) {
+			break;
+		}
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (schedule_timeout(1)) {
+			return -EIO;
+		}
+	}
+//printk("looped %i times waiting for idle\n", i);
+	if (i == timeout) {
+		rt_printk("%s: %s: timeout\n", __FILE__, __FUNCTION__);
+		return -ETIME;
+	}
+	return 0;
+}
+
+static void cs5529_command(comedi_device * dev, unsigned short value)
+{
+	static const int timeout = 100;
+	int i;
+
+	ni_ao_win_outw(dev, value, CAL_ADC_Command_67xx);
+	/* give time for command to start being serially clocked into cs5529.
+	 * this insures that the CSS_ADC_BUSY bit will get properly
+	 * set before we exit this function.
+	 */
+	for (i = 0; i < timeout; i++) {
+		if ((ni_ao_win_inw(dev, CAL_ADC_Status_67xx) & CSS_ADC_BUSY))
+			break;
+		comedi_udelay(1);
+	}
+//printk("looped %i times writing command to cs5529\n", i);
+	if (i == timeout) {
+		comedi_error(dev, "possible problem - never saw adc go busy?");
+	}
+}
+
+/* write to cs5529 register */
+static void cs5529_config_write(comedi_device * dev, unsigned int value,
+	unsigned int reg_select_bits)
+{
+	ni_ao_win_outw(dev, ((value >> 16) & 0xff),
+		CAL_ADC_Config_Data_High_Word_67xx);
+	ni_ao_win_outw(dev, (value & 0xffff),
+		CAL_ADC_Config_Data_Low_Word_67xx);
+	reg_select_bits &= CSCMD_REGISTER_SELECT_MASK;
+	cs5529_command(dev, CSCMD_COMMAND | reg_select_bits);
+	if (cs5529_wait_for_idle(dev))
+		comedi_error(dev, "time or signal in cs5529_config_write()");
+}
+
+#ifdef NI_CS5529_DEBUG
+/* read from cs5529 register */
+static unsigned int cs5529_config_read(comedi_device * dev,
+	unsigned int reg_select_bits)
+{
+	unsigned int value;
+
+	reg_select_bits &= CSCMD_REGISTER_SELECT_MASK;
+	cs5529_command(dev, CSCMD_COMMAND | CSCMD_READ | reg_select_bits);
+	if (cs5529_wait_for_idle(dev))
+		comedi_error(dev, "timeout or signal in cs5529_config_read()");
+	value = (ni_ao_win_inw(dev,
+			CAL_ADC_Config_Data_High_Word_67xx) << 16) & 0xff0000;
+	value |= ni_ao_win_inw(dev, CAL_ADC_Config_Data_Low_Word_67xx) & 0xffff;
+	return value;
+}
+#endif
+
+static int cs5529_do_conversion(comedi_device * dev, unsigned short *data)
+{
+	int retval;
+	unsigned short status;
+
+	cs5529_command(dev, CSCMD_COMMAND | CSCMD_SINGLE_CONVERSION);
+	retval = cs5529_wait_for_idle(dev);
+	if (retval) {
+		comedi_error(dev,
+			"timeout or signal in cs5529_do_conversion()");
+		return -ETIME;
+	}
+	status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
+	if (status & CSS_OSC_DETECT) {
+		rt_printk
+			("ni_mio_common: cs5529 conversion error, status CSS_OSC_DETECT\n");
+		return -EIO;
+	}
+	if (status & CSS_OVERRANGE) {
+		rt_printk
+			("ni_mio_common: cs5529 conversion error, overrange (ignoring)\n");
+	}
+	if (data) {
+		*data = ni_ao_win_inw(dev, CAL_ADC_Data_67xx);
+		/* cs5529 returns 16 bit signed data in bipolar mode */
+		*data ^= (1 << 15);
+	}
+	return 0;
+}
+
+static int cs5529_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n, retval;
+	unsigned short sample;
+	unsigned int channel_select;
+	const unsigned int INTERNAL_REF = 0x1000;
+
+	/* Set calibration adc source.  Docs lie, reference select bits 8 to 11
+	 * do nothing. bit 12 seems to chooses internal reference voltage, bit
+	 * 13 causes the adc input to go overrange (maybe reads external reference?) */
+	if (insn->chanspec & CR_ALT_SOURCE)
+		channel_select = INTERNAL_REF;
+	else
+		channel_select = CR_CHAN(insn->chanspec);
+	ni_ao_win_outw(dev, channel_select, AO_Calibration_Channel_Select_67xx);
+
+	for (n = 0; n < insn->n; n++) {
+		retval = cs5529_do_conversion(dev, &sample);
+		if (retval < 0)
+			return retval;
+		data[n] = sample;
+	}
+	return insn->n;
+}
+
+static int init_cs5529(comedi_device * dev)
+{
+	unsigned int config_bits =
+		CSCFG_PORT_MODE | CSCFG_WORD_RATE_2180_CYCLES;
+
+#if 1
+	/* do self-calibration */
+	cs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET_GAIN,
+		CSCMD_CONFIG_REGISTER);
+	/* need to force a conversion for calibration to run */
+	cs5529_do_conversion(dev, NULL);
+#else
+	/* force gain calibration to 1 */
+	cs5529_config_write(dev, 0x400000, CSCMD_GAIN_REGISTER);
+	cs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET,
+		CSCMD_CONFIG_REGISTER);
+	if (cs5529_wait_for_idle(dev))
+		comedi_error(dev, "timeout or signal in init_cs5529()\n");
+#endif
+#ifdef NI_CS5529_DEBUG
+	rt_printk("config: 0x%x\n", cs5529_config_read(dev,
+		CSCMD_CONFIG_REGISTER));
+	rt_printk("gain: 0x%x\n", cs5529_config_read(dev,
+		CSCMD_GAIN_REGISTER));
+	rt_printk("offset: 0x%x\n", cs5529_config_read(dev,
+		CSCMD_OFFSET_REGISTER));
+#endif
+	return 0;
+}
