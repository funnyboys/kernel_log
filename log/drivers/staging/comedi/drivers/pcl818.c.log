commit c833223652cf5ee0440413831d679419b69a1b7b
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Jul 11 11:32:29 2018 +0100

    staging: comedi: remove redundant variable segpos
    
    Variable segpos is being assigned but is never used hence it is redundant
    and can be removed.
    
    Cleans up clang warning:
    warning: variable 'segpos' set but not used [-Wunused-but-set-variable]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index eebb49751713..0af5315d4357 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -573,7 +573,7 @@ static int check_channel_list(struct comedi_device *dev,
 			      unsigned int *chanlist, unsigned int n_chan)
 {
 	unsigned int chansegment[16];
-	unsigned int i, nowmustbechan, seglen, segpos;
+	unsigned int i, nowmustbechan, seglen;
 
 	/* correct channel and range number check itself comedi/range.c */
 	if (n_chan < 1) {
@@ -605,7 +605,7 @@ static int check_channel_list(struct comedi_device *dev,
 		}
 
 		/*  check whole chanlist */
-		for (i = 0, segpos = 0; i < n_chan; i++) {
+		for (i = 0; i < n_chan; i++) {
 			if (chanlist[i] != chansegment[i % seglen]) {
 				dev_dbg(dev->class_dev,
 					"bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 5b5df0596ad9..eebb49751713 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * comedi/drivers/pcl818.c
  *

commit 321c799cd95cafc67fbf955f8a61b49e42b2f9b4
Author: Jakub Jedelsky <jakub.jedelsky@gmail.com>
Date:   Wed Oct 5 00:32:55 2016 +0200

    staging: comedi: Align the * on block comments
    
    Block comments should align the * on each line as reported by checkpatch
    
    Signed-off-by: Jakub Jedelsky <jakub.jedelsky@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 5aeed44dff70..5b5df0596ad9 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -771,9 +771,9 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 		     s->async->scans_done < cmd->stop_arg)) {
 			if (!devpriv->ai_cmd_canceled) {
 				/*
-				* Wait for running dma transfer to end,
-				* do cleanup in interrupt.
-				*/
+				 * Wait for running dma transfer to end,
+				 * do cleanup in interrupt.
+				 */
 				devpriv->ai_cmd_canceled = 1;
 				return 0;
 			}

commit 699849fe452471cfa740cd659f42d349cf0b4bd1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 15:40:23 2015 -0700

    staging: comedi: pcl818: remove unused "boards constants"
    
    These defines are not used. Remove them to get rid of the
    checkpatch.pl issue about avoiding CamelCase.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 913251458a1b..5aeed44dff70 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -102,15 +102,6 @@
 #include "comedi_isadma.h"
 #include "comedi_8254.h"
 
-/* boards constants */
-
-#define boardPCL818L 0
-#define boardPCL818H 1
-#define boardPCL818HD 2
-#define boardPCL818HG 3
-#define boardPCL818 4
-#define boardPCL718 5
-
 /*
  * Register I/O map
  */

commit 0bbf3ea6c4173fc6586326e1d46877168309d00a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 15:40:22 2015 -0700

    staging: comedi: pcl818: prefer using the BIT macro
    
    Fix the checkpatch.pl issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index e1bdde977302..913251458a1b 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -124,23 +124,22 @@
 #define PCL818_AO_MSB_REG(x)			(0x05 + ((x) * 2))
 #define PCL818_STATUS_REG			0x08
 #define PCL818_STATUS_NEXT_CHAN_MASK		(0xf << 0)
-#define PCL818_STATUS_INT			(1 << 4)
-#define PCL818_STATUS_MUX			(1 << 5)
-#define PCL818_STATUS_UNI			(1 << 6)
-#define PCL818_STATUS_EOC			(1 << 7)
+#define PCL818_STATUS_INT			BIT(4)
+#define PCL818_STATUS_MUX			BIT(5)
+#define PCL818_STATUS_UNI			BIT(6)
+#define PCL818_STATUS_EOC			BIT(7)
 #define PCL818_CTRL_REG				0x09
-#define PCL818_CTRL_DISABLE_TRIG		(0 << 0)
-#define PCL818_CTRL_SOFT_TRIG			(1 << 0)
-#define PCL818_CTRL_EXT_TRIG			(2 << 0)
-#define PCL818_CTRL_PACER_TRIG			(3 << 0)
-#define PCL818_CTRL_DMAE			(1 << 2)
+#define PCL818_CTRL_TRIG(x)			(((x) & 0x3) << 0)
+#define PCL818_CTRL_DISABLE_TRIG		PCL818_CTRL_TRIG(0)
+#define PCL818_CTRL_SOFT_TRIG			PCL818_CTRL_TRIG(1)
+#define PCL818_CTRL_EXT_TRIG			PCL818_CTRL_TRIG(2)
+#define PCL818_CTRL_PACER_TRIG			PCL818_CTRL_TRIG(3)
+#define PCL818_CTRL_DMAE			BIT(2)
 #define PCL818_CTRL_IRQ(x)			((x) << 4)
-#define PCL818_CTRL_INTE			(1 << 7)
+#define PCL818_CTRL_INTE			BIT(7)
 #define PCL818_CNTENABLE_REG			0x0a
-#define PCL818_CNTENABLE_PACER_ENA		(0 << 0)
-#define PCL818_CNTENABLE_PACER_TRIG0		(1 << 0)
-#define PCL818_CNTENABLE_CNT0_EXT_CLK		(0 << 1)
-#define PCL818_CNTENABLE_CNT0_INT_CLK		(1 << 1)
+#define PCL818_CNTENABLE_PACER_TRIG0		BIT(0)
+#define PCL818_CNTENABLE_CNT0_INT_CLK		BIT(1)	/* 0=ext clk */
 #define PCL818_DO_DI_MSB_REG			0x0b
 #define PCL818_TIMER_BASE			0x0c
 
@@ -740,7 +739,7 @@ static int pcl818_ai_cmd(struct comedi_device *dev,
 	else
 		ctrl |= PCL818_CTRL_EXT_TRIG;
 
-	outb(PCL818_CNTENABLE_PACER_ENA, dev->iobase + PCL818_CNTENABLE_REG);
+	outb(0, dev->iobase + PCL818_CNTENABLE_REG);
 
 	if (dma) {
 		/* setup and enable dma for the first buffer */
@@ -902,7 +901,7 @@ static void pcl818_reset(struct comedi_device *dev)
 	pcl818_ai_set_chan_range(dev, 0, 0);
 
 	/* stop pacer */
-	outb(PCL818_CNTENABLE_PACER_ENA, dev->iobase + PCL818_CNTENABLE_REG);
+	outb(0, dev->iobase + PCL818_CNTENABLE_REG);
 
 	/* set analog output channels to 0V */
 	for (chan = 0; chan < board->n_aochan; chan++) {

commit 95373ceb1e236c0d9ca298b7db028a11115b5297
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:31 2015 +0000

    staging: comedi: pcl818: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 8d933dcad533..e1bdde977302 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -100,7 +100,6 @@
 #include "../comedidev.h"
 
 #include "comedi_isadma.h"
-#include "comedi_fc.h"
 #include "comedi_8254.h"
 
 /* boards constants */
@@ -649,19 +648,20 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);
+	err |= comedi_check_trigger_src(&cmd->convert_src,
+					TRIG_TIMER | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -670,21 +670,23 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
-	if (cmd->convert_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 board->ns_min);
-	else	/* TRIG_EXT */
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+	if (cmd->convert_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
+						    board->ns_min);
+	} else {	/* TRIG_EXT */
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
+	}
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -695,7 +697,7 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		unsigned int arg = cmd->convert_arg;
 
 		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
 	if (err)

commit 18c284c68b8a52335c9d1ae53b2236ea350310d7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 14:57:32 2015 -0700

    staging: comedi: pcl818: convert driver to use the comedi_8254 module
    
    This driver uses an 8254 timer to generate the pacer clock used for analog
    input data acquisition. Convert it to use the comedi_8254 module to provide
    support for the 8254 timer.
    
    Note that the pacer does not have to be stopped when starting a new async
    command in pcl818_ai_cmd() or when the card is initialy reset by pcl818_reset().
    The counters are all reset when the driver is initially attached and the
    counters used by the pacer are stopped when a command is canceled.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 7e4cdea5fe59..8d933dcad533 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -101,7 +101,7 @@
 
 #include "comedi_isadma.h"
 #include "comedi_fc.h"
-#include "8253.h"
+#include "comedi_8254.h"
 
 /* boards constants */
 
@@ -299,33 +299,15 @@ struct pcl818_private {
 	struct comedi_isadma *dma;
 	/*  manimal allowed delay between samples (in us) for actual card */
 	unsigned int ns_min;
-	int i8253_osc_base;	/*  1/frequency of on board oscilator in ns */
 	/*  MUX setting for actual AI operations */
 	unsigned int act_chanlist[16];
 	unsigned int act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
-	unsigned int divisor1;
-	unsigned int divisor2;
 	unsigned int usefifo:1;
 	unsigned int ai_cmd_running:1;
 	unsigned int ai_cmd_canceled:1;
 };
 
-static void pcl818_start_pacer(struct comedi_device *dev, bool load_counters)
-{
-	struct pcl818_private *devpriv = dev->private;
-	unsigned long timer_base = dev->iobase + PCL818_TIMER_BASE;
-
-	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
-	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
-	udelay(1);
-
-	if (load_counters) {
-		i8254_write(timer_base, 0, 2, devpriv->divisor2);
-		i8254_write(timer_base, 0, 1, devpriv->divisor1);
-	}
-}
-
 static void pcl818_ai_setup_dma(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				unsigned int unread_samples)
@@ -663,9 +645,7 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
 	const struct pcl818_board *board = dev->board_ptr;
-	struct pcl818_private *devpriv = dev->private;
 	int err = 0;
-	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -712,11 +692,9 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* step 4: fix up any arguments */
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		arg = cmd->convert_arg;
-		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base,
-					  &devpriv->divisor1,
-					  &devpriv->divisor2,
-					  &arg, cmd->flags);
+		unsigned int arg = cmd->convert_arg;
+
+		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
@@ -746,8 +724,6 @@ static int pcl818_ai_cmd(struct comedi_device *dev,
 	if (devpriv->ai_cmd_running)
 		return -EBUSY;
 
-	pcl818_start_pacer(dev, false);
-
 	seglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);
 	if (seglen < 1)
 		return -EINVAL;
@@ -779,8 +755,10 @@ static int pcl818_ai_cmd(struct comedi_device *dev,
 	}
 	outb(ctrl, dev->iobase + PCL818_CTRL_REG);
 
-	if (cmd->convert_src == TRIG_TIMER)
-		pcl818_start_pacer(dev, true);
+	if (cmd->convert_src == TRIG_TIMER) {
+		comedi_8254_update_divisors(dev->pacer);
+		comedi_8254_pacer_enable(dev->pacer, 1, 2, true);
+	}
 
 	return 0;
 }
@@ -812,7 +790,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	}
 
 	outb(PCL818_CTRL_DISABLE_TRIG, dev->iobase + PCL818_CTRL_REG);
-	pcl818_start_pacer(dev, false);
+	comedi_8254_pacer_enable(dev->pacer, 1, 2, false);
 	pcl818_ai_clear_eoc(dev);
 
 	if (devpriv->usefifo) {	/*  FIFO shutdown */
@@ -906,7 +884,6 @@ static int pcl818_do_insn_bits(struct comedi_device *dev,
 static void pcl818_reset(struct comedi_device *dev)
 {
 	const struct pcl818_board *board = dev->board_ptr;
-	unsigned long timer_base = dev->iobase + PCL818_TIMER_BASE;
 	unsigned int chan;
 
 	/* flush and disable the FIFO */
@@ -924,9 +901,6 @@ static void pcl818_reset(struct comedi_device *dev)
 
 	/* stop pacer */
 	outb(PCL818_CNTENABLE_PACER_ENA, dev->iobase + PCL818_CNTENABLE_REG);
-	i8254_set_mode(timer_base, 0, 2, I8254_MODE0 | I8254_BINARY);
-	i8254_set_mode(timer_base, 0, 1, I8254_MODE0 | I8254_BINARY);
-	i8254_set_mode(timer_base, 0, 0, I8254_MODE0 | I8254_BINARY);
 
 	/* set analog output channels to 0V */
 	for (chan = 0; chan < board->n_aochan; chan++) {
@@ -1016,6 +990,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct pcl818_board *board = dev->board_ptr;
 	struct pcl818_private *devpriv;
 	struct comedi_subdevice *s;
+	unsigned int osc_base;
 	int ret;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
@@ -1043,6 +1018,25 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (dev->irq && board->has_dma)
 		pcl818_alloc_dma(dev, it->options[2]);
 
+	/* use 1MHz or 10MHz oscilator */
+	if ((it->options[3] == 0) || (it->options[3] == 10))
+		osc_base = I8254_OSC_BASE_10MHZ;
+	else
+		osc_base = I8254_OSC_BASE_1MHZ;
+
+	dev->pacer = comedi_8254_init(dev->iobase + PCL818_TIMER_BASE,
+				      osc_base, I8254_IO8, 0);
+	if (!dev->pacer)
+		return -ENOMEM;
+
+	/* max sampling speed */
+	devpriv->ns_min = board->ns_min;
+	if (!board->is_818) {
+		/* extended PCL718 to 100kHz DAC */
+		if ((it->options[6] == 1) || (it->options[6] == 100))
+			devpriv->ns_min = 10000;
+	}
+
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
 		return ret;
@@ -1117,22 +1111,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->range_table	= &range_digital;
 	s->insn_bits	= pcl818_do_insn_bits;
 
-	/* select 1/10MHz oscilator */
-	if ((it->options[3] == 0) || (it->options[3] == 10))
-		devpriv->i8253_osc_base = I8254_OSC_BASE_10MHZ;
-	else
-		devpriv->i8253_osc_base = I8254_OSC_BASE_1MHZ;
-
-	/* max sampling speed */
-	devpriv->ns_min = board->ns_min;
-
-	if (!board->is_818) {
-		if ((it->options[6] == 1) || (it->options[6] == 100)) {
-			/* extended PCL718 to 100kHz DAC */
-			devpriv->ns_min = 10000;
-		}
-	}
-
 	pcl818_reset(dev);
 
 	return 0;

commit 8004a0c9b0e694c25e1ea7e058c64dff459f19f9
Author: Simon Guo <wei.guo.simon@gmail.com>
Date:   Thu Jan 29 13:34:28 2015 +0800

    STAGING: Fix pcl818.c coding style issue: line over 80 characters
    
    Correct one coding style problem(detected by checkpatch.pl) in pcl818.c.
    - line over 80 characters
    
    Signed-off-by: Simon Guo <wei.guo.simon@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 47a2f7bb22f4..7e4cdea5fe59 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -297,9 +297,11 @@ static const struct pcl818_board boardtypes[] = {
 
 struct pcl818_private {
 	struct comedi_isadma *dma;
-	unsigned int ns_min;	/*  manimal allowed delay between samples (in us) for actual card */
+	/*  manimal allowed delay between samples (in us) for actual card */
+	unsigned int ns_min;
 	int i8253_osc_base;	/*  1/frequency of on board oscilator in ns */
-	unsigned int act_chanlist[16];	/*  MUX setting for actual AI operations */
+	/*  MUX setting for actual AI operations */
+	unsigned int act_chanlist[16];
 	unsigned int act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
 	unsigned int divisor1;
@@ -618,7 +620,8 @@ static int check_channel_list(struct comedi_device *dev,
 				break;
 			nowmustbechan =
 			    (CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
-			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continuous :-( */
+			if (nowmustbechan != CR_CHAN(chanlist[i])) {
+				/*  channel list isn't continuous :-( */
 				dev_dbg(dev->class_dev,
 					"channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\n",
 					i, CR_CHAN(chanlist[i]), nowmustbechan,
@@ -1124,8 +1127,10 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->ns_min = board->ns_min;
 
 	if (!board->is_818) {
-		if ((it->options[6] == 1) || (it->options[6] == 100))
-			devpriv->ns_min = 10000;	/* extended PCL718 to 100kHz DAC */
+		if ((it->options[6] == 1) || (it->options[6] == 100)) {
+			/* extended PCL718 to 100kHz DAC */
+			devpriv->ns_min = 10000;
+		}
 	}
 
 	pcl818_reset(dev);

commit 25ef8072fbea1843c29c24cf82e6913c504db55c
Author: Simon Guo <wei.guo.simon@gmail.com>
Date:   Thu Jan 29 13:33:17 2015 +0800

    STAGING: Fix pcl818.c coding style issue: code indent should use tabs where possible
    
    Correct one coding style problem(detected by checkpatch.pl) in pcl818.c.
    - code indent should use tabs where possible
    It is fixed by reformatting the comment block to usual comment style.
    
    And with the reformatting, following coding style problem is also fixed:
    - please, no space before tabs
    
    Signed-off-by: Simon Guo <wei.guo.simon@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index a10ce41067ee..47a2f7bb22f4 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1,102 +1,95 @@
 /*
-   comedi/drivers/pcl818.c
-
-   Author:  Michal Dobes <dobes@tesnet.cz>
-
-   hardware driver for Advantech cards:
-    card:   PCL-818L, PCL-818H, PCL-818HD, PCL-818HG, PCL-818, PCL-718
-    driver: pcl818l,  pcl818h,  pcl818hd,  pcl818hg,  pcl818,  pcl718
-*/
-/*
-Driver: pcl818
-Description: Advantech PCL-818 cards, PCL-718
-Author: Michal Dobes <dobes@tesnet.cz>
-Devices: [Advantech] PCL-818L (pcl818l), PCL-818H (pcl818h),
-  PCL-818HD (pcl818hd), PCL-818HG (pcl818hg), PCL-818 (pcl818),
-  PCL-718 (pcl718)
-Status: works
-
-All cards have 16 SE/8 DIFF ADCs, one or two DACs, 16 DI and 16 DO.
-Differences are only at maximal sample speed, range list and FIFO
-support.
-The driver support AI mode 0, 1, 3 other subdevices (AO, DI, DO) support
-only mode 0. If DMA/FIFO/INT are disabled then AI support only mode 0.
-PCL-818HD and PCL-818HG support 1kword FIFO. Driver support this FIFO
-but this code is untested.
-A word or two about DMA. Driver support DMA operations at two ways:
-1) DMA uses two buffers and after one is filled then is generated
-   INT and DMA restart with second buffer. With this mode I'm unable run
-   more that 80Ksamples/secs without data dropouts on K6/233.
-2) DMA uses one buffer and run in autoinit mode and the data are
-   from DMA buffer moved on the fly with 2kHz interrupts from RTC.
-   This mode is used if the interrupt 8 is available for allocation.
-   If not, then first DMA mode is used. With this I can run at
-   full speed one card (100ksamples/secs) or two cards with
-   60ksamples/secs each (more is problem on account of ISA limitations).
-   To use this mode you must have compiled  kernel with disabled
-   "Enhanced Real Time Clock Support".
-   Maybe you can have problems if you use xntpd or similar.
-   If you've data dropouts with DMA mode 2 then:
-    a) disable IDE DMA
-    b) switch text mode console to fb.
-
-   Options for PCL-818L:
-    [0] - IO Base
-    [1] - IRQ	(0=disable, 2, 3, 4, 5, 6, 7)
-    [2] - DMA	(0=disable, 1, 3)
-    [3] - 0, 10=10MHz clock for 8254
-              1= 1MHz clock for 8254
-    [4] - 0,  5=A/D input  -5V.. +5V
-          1, 10=A/D input -10V..+10V
-    [5] - 0,  5=D/A output 0-5V  (internal reference -5V)
-          1, 10=D/A output 0-10V (internal reference -10V)
-	  2    =D/A output unknown (external reference)
-
-   Options for PCL-818, PCL-818H:
-    [0] - IO Base
-    [1] - IRQ	(0=disable, 2, 3, 4, 5, 6, 7)
-    [2] - DMA	(0=disable, 1, 3)
-    [3] - 0, 10=10MHz clock for 8254
-              1= 1MHz clock for 8254
-    [4] - 0,  5=D/A output 0-5V  (internal reference -5V)
-          1, 10=D/A output 0-10V (internal reference -10V)
-	  2    =D/A output unknown (external reference)
-
-   Options for PCL-818HD, PCL-818HG:
-    [0] - IO Base
-    [1] - IRQ	(0=disable, 2, 3, 4, 5, 6, 7)
-    [2] - DMA/FIFO  (-1=use FIFO, 0=disable both FIFO and DMA,
-                      1=use DMA ch 1, 3=use DMA ch 3)
-    [3] - 0, 10=10MHz clock for 8254
-              1= 1MHz clock for 8254
-    [4] - 0,  5=D/A output 0-5V  (internal reference -5V)
-          1, 10=D/A output 0-10V (internal reference -10V)
-   	  2    =D/A output unknown (external reference)
-
-   Options for PCL-718:
-    [0] - IO Base
-    [1] - IRQ	(0=disable, 2, 3, 4, 5, 6, 7)
-    [2] - DMA	(0=disable, 1, 3)
-    [3] - 0, 10=10MHz clock for 8254
-              1= 1MHz clock for 8254
-    [4] -     0=A/D Range is +/-10V
-	      1=             +/-5V
-	      2=             +/-2.5V
-	      3=             +/-1V
-	      4=             +/-0.5V
-	      5=  	     user defined bipolar
-	      6=	     0-10V
-	      7=	     0-5V
- 	      8=	     0-2V
-	      9=	     0-1V
-	     10=	     user defined unipolar
-    [5] - 0,  5=D/A outputs 0-5V  (internal reference -5V)
-          1, 10=D/A outputs 0-10V (internal reference -10V)
-	      2=D/A outputs unknown (external reference)
-    [6] - 0, 60=max  60kHz A/D sampling
-          1,100=max 100kHz A/D sampling (PCL-718 with Option 001 installed)
-
-*/
+ * comedi/drivers/pcl818.c
+ *
+ * Driver: pcl818
+ * Description: Advantech PCL-818 cards, PCL-718
+ * Author: Michal Dobes <dobes@tesnet.cz>
+ * Devices: [Advantech] PCL-818L (pcl818l), PCL-818H (pcl818h),
+ *   PCL-818HD (pcl818hd), PCL-818HG (pcl818hg), PCL-818 (pcl818),
+ *   PCL-718 (pcl718)
+ * Status: works
+ *
+ * All cards have 16 SE/8 DIFF ADCs, one or two DACs, 16 DI and 16 DO.
+ * Differences are only at maximal sample speed, range list and FIFO
+ * support.
+ * The driver support AI mode 0, 1, 3 other subdevices (AO, DI, DO) support
+ * only mode 0. If DMA/FIFO/INT are disabled then AI support only mode 0.
+ * PCL-818HD and PCL-818HG support 1kword FIFO. Driver support this FIFO
+ * but this code is untested.
+ * A word or two about DMA. Driver support DMA operations at two ways:
+ * 1) DMA uses two buffers and after one is filled then is generated
+ *    INT and DMA restart with second buffer. With this mode I'm unable run
+ *    more that 80Ksamples/secs without data dropouts on K6/233.
+ * 2) DMA uses one buffer and run in autoinit mode and the data are
+ *    from DMA buffer moved on the fly with 2kHz interrupts from RTC.
+ *    This mode is used if the interrupt 8 is available for allocation.
+ *    If not, then first DMA mode is used. With this I can run at
+ *    full speed one card (100ksamples/secs) or two cards with
+ *    60ksamples/secs each (more is problem on account of ISA limitations).
+ *    To use this mode you must have compiled  kernel with disabled
+ *    "Enhanced Real Time Clock Support".
+ *    Maybe you can have problems if you use xntpd or similar.
+ *    If you've data dropouts with DMA mode 2 then:
+ *     a) disable IDE DMA
+ *     b) switch text mode console to fb.
+ *
+ *  Options for PCL-818L:
+ *  [0] - IO Base
+ *  [1] - IRQ        (0=disable, 2, 3, 4, 5, 6, 7)
+ *  [2] - DMA        (0=disable, 1, 3)
+ *  [3] - 0, 10=10MHz clock for 8254
+ *            1= 1MHz clock for 8254
+ *  [4] - 0,  5=A/D input  -5V.. +5V
+ *        1, 10=A/D input -10V..+10V
+ *  [5] - 0,  5=D/A output 0-5V  (internal reference -5V)
+ *        1, 10=D/A output 0-10V (internal reference -10V)
+ *        2    =D/A output unknown (external reference)
+ *
+ *  Options for PCL-818, PCL-818H:
+ *  [0] - IO Base
+ *  [1] - IRQ        (0=disable, 2, 3, 4, 5, 6, 7)
+ *  [2] - DMA        (0=disable, 1, 3)
+ *  [3] - 0, 10=10MHz clock for 8254
+ *            1= 1MHz clock for 8254
+ *  [4] - 0,  5=D/A output 0-5V  (internal reference -5V)
+ *        1, 10=D/A output 0-10V (internal reference -10V)
+ *        2    =D/A output unknown (external reference)
+ *
+ *  Options for PCL-818HD, PCL-818HG:
+ *  [0] - IO Base
+ *  [1] - IRQ        (0=disable, 2, 3, 4, 5, 6, 7)
+ *  [2] - DMA/FIFO  (-1=use FIFO, 0=disable both FIFO and DMA,
+ *                    1=use DMA ch 1, 3=use DMA ch 3)
+ *  [3] - 0, 10=10MHz clock for 8254
+ *            1= 1MHz clock for 8254
+ *  [4] - 0,  5=D/A output 0-5V  (internal reference -5V)
+ *        1, 10=D/A output 0-10V (internal reference -10V)
+ *        2    =D/A output unknown (external reference)
+ *
+ *  Options for PCL-718:
+ *  [0] - IO Base
+ *  [1] - IRQ        (0=disable, 2, 3, 4, 5, 6, 7)
+ *  [2] - DMA        (0=disable, 1, 3)
+ *  [3] - 0, 10=10MHz clock for 8254
+ *            1= 1MHz clock for 8254
+ *  [4] -     0=A/D Range is +/-10V
+ *            1=             +/-5V
+ *            2=             +/-2.5V
+ *            3=             +/-1V
+ *            4=             +/-0.5V
+ *            5=             user defined bipolar
+ *            6=             0-10V
+ *            7=             0-5V
+ *            8=             0-2V
+ *            9=             0-1V
+ *           10=             user defined unipolar
+ *  [5] - 0,  5=D/A outputs 0-5V  (internal reference -5V)
+ *        1, 10=D/A outputs 0-10V (internal reference -10V)
+ *            2=D/A outputs unknown (external reference)
+ *  [6] - 0, 60=max  60kHz A/D sampling
+ *        1,100=max 100kHz A/D sampling (PCL-718 with Option 001 installed)
+ *
+ */
 
 #include <linux/module.h>
 #include <linux/gfp.h>

commit d615416de6157812e6d7b732991ece884fc6c59e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:03 2015 -0700

    staging: comedi: pcl818: introduce pcl818_ai_write_sample()
    
    This driver can acquire analog input samples during the async command with
    DMA, by using the FIFO, or sample-by-sample using the End-Of-Conversion
    interrupt. All three methods do the following sequence:
    
      1) check for channel dropout
      2) add the sample to the async buffer
      3) advance the channel dropout detection and detect the end of the command
    
    Merge this sequence into a new helper function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 6e5d8bfb1c6d..a10ce41067ee 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -454,11 +454,12 @@ static int pcl818_ai_eoc(struct comedi_device *dev,
 	return -EBUSY;
 }
 
-static bool pcl818_ai_dropout(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      unsigned int chan)
+static bool pcl818_ai_write_sample(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned int chan, unsigned int val)
 {
 	struct pcl818_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int expected_chan;
 
 	expected_chan = devpriv->act_chanlist[devpriv->act_chanlist_pos];
@@ -469,16 +470,10 @@ static bool pcl818_ai_dropout(struct comedi_device *dev,
 			(devpriv->usefifo) ? "FIFO" : "IRQ",
 			chan, expected_chan);
 		s->async->events |= COMEDI_CB_ERROR;
-		return true;
+		return false;
 	}
-	return false;
-}
 
-static bool pcl818_ai_next_chan(struct comedi_device *dev,
-				struct comedi_subdevice *s)
-{
-	struct pcl818_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
+	comedi_buf_write_samples(s, &val, 1);
 
 	devpriv->act_chanlist_pos++;
 	if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)
@@ -506,13 +501,7 @@ static void pcl818_handle_eoc(struct comedi_device *dev,
 	}
 
 	val = pcl818_ai_get_sample(dev, s, &chan);
-
-	if (pcl818_ai_dropout(dev, s, chan))
-		return;
-
-	comedi_buf_write_samples(s, &val, 1);
-
-	pcl818_ai_next_chan(dev, s);
+	pcl818_ai_write_sample(dev, s, chan, val);
 }
 
 static void pcl818_handle_dma(struct comedi_device *dev,
@@ -535,13 +524,7 @@ static void pcl818_handle_dma(struct comedi_device *dev,
 		val = ptr[i];
 		chan = val & 0xf;
 		val = (val >> 4) & s->maxdata;
-
-		if (pcl818_ai_dropout(dev, s, chan))
-			break;
-
-		comedi_buf_write_samples(s, &val, 1);
-
-		if (!pcl818_ai_next_chan(dev, s))
+		if (!pcl818_ai_write_sample(dev, s, chan, val))
 			break;
 	}
 }
@@ -576,13 +559,7 @@ static void pcl818_handle_fifo(struct comedi_device *dev,
 
 	for (i = 0; i < len; i++) {
 		val = pcl818_ai_get_fifo_sample(dev, s, &chan);
-
-		if (pcl818_ai_dropout(dev, s, chan))
-			break;
-
-		comedi_buf_write_samples(s, &val, 1);
-
-		if (!pcl818_ai_next_chan(dev, s))
+		if (!pcl818_ai_write_sample(dev, s, chan, val))
 			break;
 	}
 }

commit 3e6cb74f5632e1ac2b4209b4d2c64fca43e2838b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:02 2015 -0700

    staging: comedi: drivers: remove inappropriate COMEDI_CB_EOA events
    
    Hardware errors should be reported with the COMEDI_CB_ERROR event. This event
    will cause the async command to cancel. It's not necessary to also set the
    COMEDI_CB_EOA event. Remove these events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index ba2e1373f43d..6e5d8bfb1c6d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -468,7 +468,7 @@ static bool pcl818_ai_dropout(struct comedi_device *dev,
 			(devpriv->dma) ? "DMA" :
 			(devpriv->usefifo) ? "FIFO" : "IRQ",
 			chan, expected_chan);
-		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		s->async->events |= COMEDI_CB_ERROR;
 		return true;
 	}
 	return false;
@@ -501,7 +501,7 @@ static void pcl818_handle_eoc(struct comedi_device *dev,
 
 	if (pcl818_ai_eoc(dev, s, NULL, 0)) {
 		dev_err(dev->class_dev, "A/D mode1/3 IRQ without DRDY!\n");
-		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		s->async->events |= COMEDI_CB_ERROR;
 		return;
 	}
 
@@ -558,14 +558,14 @@ static void pcl818_handle_fifo(struct comedi_device *dev,
 
 	if (status & 4) {
 		dev_err(dev->class_dev, "A/D mode1/3 FIFO overflow!\n");
-		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		s->async->events |= COMEDI_CB_ERROR;
 		return;
 	}
 
 	if (status & 1) {
 		dev_err(dev->class_dev,
 			"A/D mode1/3 FIFO interrupt without data!\n");
-		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		s->async->events |= COMEDI_CB_ERROR;
 		return;
 	}
 

commit 421f1b6832efd618c5ce3e639642a49d38ba5a37
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 14 10:05:12 2015 -0700

    staging: comedi: pcl818: use common function to setup dma
    
    THe pcl818_ai_setup_dma() and pcl818_ai_setup_next_dma() functions are similar
    other than the buffer switch and the inclusion of the "unread_samples" in
    pcl818_ai_setup_next_dma() when calculating the dma size.
    
    Merge these two functions by initializing the 'dma->cur_dma' in the callers
    and passing '0' for the "unread_samples" when first starting the DMA.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index fa7b4e22953f..ba2e1373f43d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -332,49 +332,22 @@ static void pcl818_start_pacer(struct comedi_device *dev, bool load_counters)
 }
 
 static void pcl818_ai_setup_dma(struct comedi_device *dev,
-				struct comedi_subdevice *s)
-{
-	struct pcl818_private *devpriv = dev->private;
-	struct comedi_isadma *dma = devpriv->dma;
-	struct comedi_isadma_desc *desc = &dma->desc[0];
-	unsigned int nsamples;
-
-	comedi_isadma_disable(dma->chan);
-
-	dma->cur_dma = 0;
-
-	/*
-	 * Determine dma size based on the buffer maxsize and the number of
-	 * samples remaining in the command.
-	 */
-	nsamples = comedi_bytes_to_samples(s, desc->maxsize);
-	nsamples = comedi_nsamples_left(s, nsamples);
-	desc->size = comedi_samples_to_bytes(s, nsamples);
-	comedi_isadma_program(desc);
-}
-
-static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
-				     struct comedi_subdevice *s,
-				     unsigned int unread_samples)
+				struct comedi_subdevice *s,
+				unsigned int unread_samples)
 {
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_isadma *dma = devpriv->dma;
-	struct comedi_isadma_desc *desc;
-	unsigned int max_samples;
+	struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
+	unsigned int max_samples = comedi_bytes_to_samples(s, desc->maxsize);
 	unsigned int nsamples;
 
 	comedi_isadma_disable(dma->chan);
 
-	dma->cur_dma = 1 - dma->cur_dma;
-	desc = &dma->desc[dma->cur_dma];
-
 	/*
 	 * Determine dma size based on the buffer maxsize plus the number of
 	 * unread samples and the number of samples remaining in the command.
 	 */
-	max_samples = comedi_bytes_to_samples(s, desc->maxsize);
-	nsamples = max_samples + unread_samples;
-	nsamples = comedi_nsamples_left(s, nsamples);
+	nsamples = comedi_nsamples_left(s, max_samples + unread_samples);
 	if (nsamples > unread_samples) {
 		nsamples -= unread_samples;
 		desc->size = comedi_samples_to_bytes(s, nsamples);
@@ -554,7 +527,9 @@ static void pcl818_handle_dma(struct comedi_device *dev,
 	unsigned int val;
 	int i;
 
-	pcl818_ai_setup_next_dma(dev, s, nsamples);
+	/* restart dma with the next buffer */
+	dma->cur_dma = 1 - dma->cur_dma;
+	pcl818_ai_setup_dma(dev, s, nsamples);
 
 	for (i = 0; i < nsamples; i++) {
 		val = ptr[i];
@@ -790,6 +765,7 @@ static int pcl818_ai_cmd(struct comedi_device *dev,
 			 struct comedi_subdevice *s)
 {
 	struct pcl818_private *devpriv = dev->private;
+	struct comedi_isadma *dma = devpriv->dma;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int ctrl = 0;
 	unsigned int seglen;
@@ -815,8 +791,10 @@ static int pcl818_ai_cmd(struct comedi_device *dev,
 
 	outb(PCL818_CNTENABLE_PACER_ENA, dev->iobase + PCL818_CNTENABLE_REG);
 
-	if (devpriv->dma) {
-		pcl818_ai_setup_dma(dev, s);
+	if (dma) {
+		/* setup and enable dma for the first buffer */
+		dma->cur_dma = 0;
+		pcl818_ai_setup_dma(dev, s, 0);
 
 		ctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq) |
 			PCL818_CTRL_DMAE;

commit 296e3f1816dbdb5f1c3213386756e362263b17b5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 14 10:05:11 2015 -0700

    staging: comedi: pcl818: simplify the dma->size calculations
    
    Currently this driver determines the number of DMA "runs" needed and the size
    of the "last" DMA transfer in order to perform a command. As long as there are
    more "runs" required, the dma->size is set to the buffer maxsize. On the last
    "run" the buffer is set to the "last" size.
    
    Refactor the driver to use the comedi core helpers to determine the DMA size
    based on the buffer maxsize and the number of samples remaining in the command.
    
    This allows removing the 'dma_runs_to_end' and 'last_dma_run' mamebers from
    the private data. Also remove the 'ai_data_len' member which is set but never
    used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 1c9581933a13..fa7b4e22953f 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -304,14 +304,11 @@ static const struct pcl818_board boardtypes[] = {
 
 struct pcl818_private {
 	struct comedi_isadma *dma;
-	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
-	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
 	unsigned int ns_min;	/*  manimal allowed delay between samples (in us) for actual card */
 	int i8253_osc_base;	/*  1/frequency of on board oscilator in ns */
 	unsigned int act_chanlist[16];	/*  MUX setting for actual AI operations */
 	unsigned int act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
-	unsigned int ai_data_len;	/*  len of data buffer */
 	unsigned int divisor1;
 	unsigned int divisor2;
 	unsigned int usefifo:1;
@@ -340,48 +337,49 @@ static void pcl818_ai_setup_dma(struct comedi_device *dev,
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_isadma *dma = devpriv->dma;
 	struct comedi_isadma_desc *desc = &dma->desc[0];
-	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int nsamples;
 
 	comedi_isadma_disable(dma->chan);
-	if (cmd->stop_src == TRIG_COUNT) {
-		desc->size = cmd->stop_arg * comedi_bytes_per_scan(s);
-		devpriv->dma_runs_to_end = desc->size / desc->maxsize;
-		devpriv->last_dma_run = desc->size % desc->maxsize;
-		devpriv->dma_runs_to_end--;
-		if (devpriv->dma_runs_to_end >= 0)
-			desc->size = desc->maxsize;
-	} else {
-		desc->size = desc->maxsize;
-	}
 
 	dma->cur_dma = 0;
 
+	/*
+	 * Determine dma size based on the buffer maxsize and the number of
+	 * samples remaining in the command.
+	 */
+	nsamples = comedi_bytes_to_samples(s, desc->maxsize);
+	nsamples = comedi_nsamples_left(s, nsamples);
+	desc->size = comedi_samples_to_bytes(s, nsamples);
 	comedi_isadma_program(desc);
 }
 
 static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
-				     struct comedi_subdevice *s)
+				     struct comedi_subdevice *s,
+				     unsigned int unread_samples)
 {
 	struct pcl818_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
 	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc;
+	unsigned int max_samples;
+	unsigned int nsamples;
 
 	comedi_isadma_disable(dma->chan);
-	dma->cur_dma = 1 - dma->cur_dma;
-
-	/* switch dma bufs if still running */
-	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
-		struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
-
-		if (devpriv->dma_runs_to_end || cmd->stop_src == TRIG_NONE)
-			desc->size = desc->maxsize;
-		else
-			desc->size = devpriv->last_dma_run;
 
+	dma->cur_dma = 1 - dma->cur_dma;
+	desc = &dma->desc[dma->cur_dma];
+
+	/*
+	 * Determine dma size based on the buffer maxsize plus the number of
+	 * unread samples and the number of samples remaining in the command.
+	 */
+	max_samples = comedi_bytes_to_samples(s, desc->maxsize);
+	nsamples = max_samples + unread_samples;
+	nsamples = comedi_nsamples_left(s, nsamples);
+	if (nsamples > unread_samples) {
+		nsamples -= unread_samples;
+		desc->size = comedi_samples_to_bytes(s, nsamples);
 		comedi_isadma_program(desc);
 	}
-
-	devpriv->dma_runs_to_end--;
 }
 
 static void pcl818_ai_set_chan_range(struct comedi_device *dev,
@@ -556,7 +554,7 @@ static void pcl818_handle_dma(struct comedi_device *dev,
 	unsigned int val;
 	int i;
 
-	pcl818_ai_setup_next_dma(dev, s);
+	pcl818_ai_setup_next_dma(dev, s, nsamples);
 
 	for (i = 0; i < nsamples; i++) {
 		val = ptr[i];
@@ -806,11 +804,9 @@ static int pcl818_ai_cmd(struct comedi_device *dev,
 		return -EINVAL;
 	pcl818_ai_setup_chanlist(dev, cmd->chanlist, seglen);
 
-	devpriv->ai_data_len = s->async->prealloc_bufsz;
 	devpriv->ai_cmd_running = 1;
 	devpriv->ai_cmd_canceled = 0;
 	devpriv->act_chanlist_pos = 0;
-	devpriv->dma_runs_to_end = 0;
 
 	if (cmd->convert_src == TRIG_TIMER)
 		ctrl |= PCL818_CTRL_PACER_TRIG;

commit dd7c0f04168a3faedf4a5a8ef9605ef90bdeb09c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 14 10:05:03 2015 -0700

    staging: comedi: pcl818: remove depends on ISA_DMA_API limitation
    
    Use the new comedi_isadma module to provide the ISA DMA support. This removes
    all the ISA_DMA_API code from this driver and allows the driver to be used on
    platforms that don't support the ISA_DMA_API.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index a1279c24afb9..1c9581933a13 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -103,10 +103,10 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/interrupt.h>
-#include <asm/dma.h>
 
 #include "../comedidev.h"
 
+#include "comedi_isadma.h"
 #include "comedi_fc.h"
 #include "8253.h"
 
@@ -302,17 +302,8 @@ static const struct pcl818_board boardtypes[] = {
 	},
 };
 
-struct pcl818_dma_desc {
-	void *virt_addr;	/* virtual address of DMA buffer */
-	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
-	unsigned int size;	/* transfer size (in bytes) */
-};
-
 struct pcl818_private {
-	unsigned int dma;	/*  used DMA, 0=don't use DMA */
-	unsigned int hwdmasize;
-	struct pcl818_dma_desc dma_desc[2];
-	int cur_dma;
+	struct comedi_isadma *dma;
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
 	unsigned int ns_min;	/*  manimal allowed delay between samples (in us) for actual card */
@@ -328,29 +319,6 @@ struct pcl818_private {
 	unsigned int ai_cmd_canceled:1;
 };
 
-static void pcl818_isadma_program(unsigned int dma_chan,
-				  struct pcl818_dma_desc *dma)
-{
-	unsigned long flags;
-
-	flags = claim_dma_lock();
-	clear_dma_ff(dma_chan);
-	set_dma_mode(dma_chan, DMA_MODE_READ);
-	set_dma_addr(dma_chan, dma->hw_addr);
-	set_dma_count(dma_chan, dma->size);
-	enable_dma(dma_chan);
-	release_dma_lock(flags);
-}
-
-static void pcl818_isadma_disable(unsigned int dma_chan)
-{
-	unsigned long flags;
-
-	flags = claim_dma_lock();
-	disable_dma(dma_chan);
-	release_dma_lock(flags);
-}
-
 static void pcl818_start_pacer(struct comedi_device *dev, bool load_counters)
 {
 	struct pcl818_private *devpriv = dev->private;
@@ -370,24 +338,25 @@ static void pcl818_ai_setup_dma(struct comedi_device *dev,
 				struct comedi_subdevice *s)
 {
 	struct pcl818_private *devpriv = dev->private;
-	struct pcl818_dma_desc *dma = &devpriv->dma_desc[0];
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[0];
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	pcl818_isadma_disable(devpriv->dma);
+	comedi_isadma_disable(dma->chan);
 	if (cmd->stop_src == TRIG_COUNT) {
-		dma->size = cmd->stop_arg * comedi_bytes_per_scan(s);
-		devpriv->dma_runs_to_end = dma->size / devpriv->hwdmasize;
-		devpriv->last_dma_run = dma->size % devpriv->hwdmasize;
+		desc->size = cmd->stop_arg * comedi_bytes_per_scan(s);
+		devpriv->dma_runs_to_end = desc->size / desc->maxsize;
+		devpriv->last_dma_run = desc->size % desc->maxsize;
 		devpriv->dma_runs_to_end--;
 		if (devpriv->dma_runs_to_end >= 0)
-			dma->size = devpriv->hwdmasize;
+			desc->size = desc->maxsize;
 	} else {
-		dma->size = devpriv->hwdmasize;
+		desc->size = desc->maxsize;
 	}
 
-	devpriv->cur_dma = 0;
+	dma->cur_dma = 0;
 
-	pcl818_isadma_program(devpriv->dma, dma);
+	comedi_isadma_program(desc);
 }
 
 static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
@@ -395,19 +364,21 @@ static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
 {
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	struct pcl818_dma_desc *dma;
+	struct comedi_isadma *dma = devpriv->dma;
+
+	comedi_isadma_disable(dma->chan);
+	dma->cur_dma = 1 - dma->cur_dma;
 
-	pcl818_isadma_disable(devpriv->dma);
-	devpriv->cur_dma = 1 - devpriv->cur_dma;
+	/* switch dma bufs if still running */
 	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
-		/* switch dma bufs */
-		dma = &devpriv->dma_desc[devpriv->cur_dma];
+		struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
+
 		if (devpriv->dma_runs_to_end || cmd->stop_src == TRIG_NONE)
-			dma->size = devpriv->hwdmasize;
+			desc->size = desc->maxsize;
 		else
-			dma->size = devpriv->last_dma_run;
+			desc->size = devpriv->last_dma_run;
 
-		pcl818_isadma_program(devpriv->dma, dma);
+		comedi_isadma_program(desc);
 	}
 
 	devpriv->dma_runs_to_end--;
@@ -577,9 +548,10 @@ static void pcl818_handle_dma(struct comedi_device *dev,
 			      struct comedi_subdevice *s)
 {
 	struct pcl818_private *devpriv = dev->private;
-	struct pcl818_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
-	unsigned short *ptr = dma->virt_addr;
-	unsigned int nsamples = comedi_bytes_to_samples(s, dma->size);
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
+	unsigned short *ptr = desc->virt_addr;
+	unsigned int nsamples = comedi_bytes_to_samples(s, desc->size);
 	unsigned int chan;
 	unsigned int val;
 	int i;
@@ -870,12 +842,13 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
 	struct pcl818_private *devpriv = dev->private;
+	struct comedi_isadma *dma = devpriv->dma;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
 	if (!devpriv->ai_cmd_running)
 		return 0;
 
-	if (devpriv->dma) {
+	if (dma) {
 		if (cmd->stop_src == TRIG_NONE ||
 		    (cmd->stop_src == TRIG_COUNT &&
 		     s->async->scans_done < cmd->stop_arg)) {
@@ -888,7 +861,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 				return 0;
 			}
 		}
-		pcl818_isadma_disable(devpriv->dma);
+		comedi_isadma_disable(dma->chan);
 	}
 
 	outb(PCL818_CTRL_DISABLE_TRIG, dev->iobase + PCL818_CTRL_REG);
@@ -1070,49 +1043,25 @@ static void pcl818_set_ai_range_table(struct comedi_device *dev,
 	}
 }
 
-static int pcl818_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
+static void pcl818_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 {
 	struct pcl818_private *devpriv = dev->private;
-	struct pcl818_dma_desc *dma;
-	int i;
 
+	/* only DMA channels 3 and 1 are valid */
 	if (!(dma_chan == 3 || dma_chan == 1))
-		return 0;
-
-	if (request_dma(dma_chan, dev->board_name))
-		return 0;
-	devpriv->dma = dma_chan;
-
-	devpriv->hwdmasize = PAGE_SIZE * 4;	/* we need 16KB */
-
-	for (i = 0; i < 2; i++) {
-		dma = &devpriv->dma_desc[i];
+		return;
 
-		dma->virt_addr = dma_alloc_coherent(NULL, devpriv->hwdmasize,
-						    &dma->hw_addr, GFP_KERNEL);
-		if (!dma->virt_addr)
-			return -ENOMEM;
-	}
-	return 0;
+	/* DMA uses two 16K buffers */
+	devpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan, dma_chan,
+					   PAGE_SIZE * 4, COMEDI_ISADMA_READ);
 }
 
 static void pcl818_free_dma(struct comedi_device *dev)
 {
 	struct pcl818_private *devpriv = dev->private;
-	struct pcl818_dma_desc *dma;
-	int i;
 
-	if (!devpriv)
-		return;
-
-	if (devpriv->dma)
-		free_dma(devpriv->dma);
-	for (i = 0; i < 2; i++) {
-		dma = &devpriv->dma_desc[i];
-		if (dma->virt_addr)
-			dma_free_coherent(NULL, devpriv->hwdmasize,
-					  dma->virt_addr, dma->hw_addr);
-	}
+	if (devpriv)
+		comedi_isadma_free(devpriv->dma);
 }
 
 static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -1144,11 +1093,8 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->usefifo = 1;
 
 	/* we need an IRQ to do DMA on channel 3 or 1 */
-	if (dev->irq && board->has_dma) {
-		ret = pcl818_alloc_dma(dev, it->options[2]);
-		if (ret)
-			return ret;
-	}
+	if (dev->irq && board->has_dma)
+		pcl818_alloc_dma(dev, it->options[2]);
 
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)

commit bed8d5381c8cf34fd7511cd02bb7e312ec83addf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:21 2015 -0700

    staging: comedi: pcl818: introduce pcl818_isadma_disable()
    
    According to Documentation/DMA-ISA-LPC.txt, the DMA lock needs to be
    claimed before using any of the ISA DMA routines. Introduce a helper
    function to disable the ISA DMA controller and add the necessary
    locking calls.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 4f5f4e94ae0f..a1279c24afb9 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -342,6 +342,15 @@ static void pcl818_isadma_program(unsigned int dma_chan,
 	release_dma_lock(flags);
 }
 
+static void pcl818_isadma_disable(unsigned int dma_chan)
+{
+	unsigned long flags;
+
+	flags = claim_dma_lock();
+	disable_dma(dma_chan);
+	release_dma_lock(flags);
+}
+
 static void pcl818_start_pacer(struct comedi_device *dev, bool load_counters)
 {
 	struct pcl818_private *devpriv = dev->private;
@@ -364,7 +373,7 @@ static void pcl818_ai_setup_dma(struct comedi_device *dev,
 	struct pcl818_dma_desc *dma = &devpriv->dma_desc[0];
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	disable_dma(devpriv->dma);	/*  disable dma */
+	pcl818_isadma_disable(devpriv->dma);
 	if (cmd->stop_src == TRIG_COUNT) {
 		dma->size = cmd->stop_arg * comedi_bytes_per_scan(s);
 		devpriv->dma_runs_to_end = dma->size / devpriv->hwdmasize;
@@ -388,7 +397,7 @@ static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct pcl818_dma_desc *dma;
 
-	disable_dma(devpriv->dma);
+	pcl818_isadma_disable(devpriv->dma);
 	devpriv->cur_dma = 1 - devpriv->cur_dma;
 	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
 		/* switch dma bufs */
@@ -879,7 +888,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 				return 0;
 			}
 		}
-		disable_dma(devpriv->dma);
+		pcl818_isadma_disable(devpriv->dma);
 	}
 
 	outb(PCL818_CTRL_DISABLE_TRIG, dev->iobase + PCL818_CTRL_REG);

commit 9cf2765f5e39ffd600715a4b19e5fface154ba32
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:20 2015 -0700

    staging: comedi: pcl818: introduce pcl818_isadma_program()
    
    Introduce a helper function to program the ISA DMA controller. Program
    the ISA DMA as described in Documentation/DMA-ISA-LPC.txt.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 19f6b595a80e..4f5f4e94ae0f 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -328,6 +328,20 @@ struct pcl818_private {
 	unsigned int ai_cmd_canceled:1;
 };
 
+static void pcl818_isadma_program(unsigned int dma_chan,
+				  struct pcl818_dma_desc *dma)
+{
+	unsigned long flags;
+
+	flags = claim_dma_lock();
+	clear_dma_ff(dma_chan);
+	set_dma_mode(dma_chan, DMA_MODE_READ);
+	set_dma_addr(dma_chan, dma->hw_addr);
+	set_dma_count(dma_chan, dma->size);
+	enable_dma(dma_chan);
+	release_dma_lock(flags);
+}
+
 static void pcl818_start_pacer(struct comedi_device *dev, bool load_counters)
 {
 	struct pcl818_private *devpriv = dev->private;
@@ -349,7 +363,6 @@ static void pcl818_ai_setup_dma(struct comedi_device *dev,
 	struct pcl818_private *devpriv = dev->private;
 	struct pcl818_dma_desc *dma = &devpriv->dma_desc[0];
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int flags;
 
 	disable_dma(devpriv->dma);	/*  disable dma */
 	if (cmd->stop_src == TRIG_COUNT) {
@@ -364,13 +377,8 @@ static void pcl818_ai_setup_dma(struct comedi_device *dev,
 	}
 
 	devpriv->cur_dma = 0;
-	set_dma_mode(devpriv->dma, DMA_MODE_READ);
-	flags = claim_dma_lock();
-	clear_dma_ff(devpriv->dma);
-	set_dma_addr(devpriv->dma, dma->hw_addr);
-	set_dma_count(devpriv->dma, dma->size);
-	release_dma_lock(flags);
-	enable_dma(devpriv->dma);
+
+	pcl818_isadma_program(devpriv->dma, dma);
 }
 
 static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
@@ -379,7 +387,6 @@ static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct pcl818_dma_desc *dma;
-	unsigned long flags;
 
 	disable_dma(devpriv->dma);
 	devpriv->cur_dma = 1 - devpriv->cur_dma;
@@ -390,12 +397,8 @@ static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
 			dma->size = devpriv->hwdmasize;
 		else
 			dma->size = devpriv->last_dma_run;
-		set_dma_mode(devpriv->dma, DMA_MODE_READ);
-		flags = claim_dma_lock();
-		set_dma_addr(devpriv->dma, dma->hw_addr);
-		set_dma_count(devpriv->dma, dma->size);
-		release_dma_lock(flags);
-		enable_dma(devpriv->dma);
+
+		pcl818_isadma_program(devpriv->dma, dma);
 	}
 
 	devpriv->dma_runs_to_end--;

commit 1c53093a1dea755f5ab9598d57b78f9a9444262d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:59 2015 -0700

    staging: comedi: pcl818: fix pcl818_handle_dma() for short DMA transaction
    
    Currently this function always transfers the full DMA buffer to the comedi
    async buffer. When the cmd->stop_src == TRIG_COUNT the last DMA transfer
    might be smaller than the buffer size. This results in invalid data being
    added to the asunc buffer.
    
    Add a 'size' member to the DMA descriptor and initialize it with the
    actual size of the DMA transfer. Use that in pcl818_handle_dma() to
    return the proper number of samples. Use the comedi_bytes_to_samples()
    helper to convert the byte size to comedi samples. Remove the unnecessary
    'bufptr' local variable.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 3656ecf10813..19f6b595a80e 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -305,6 +305,7 @@ static const struct pcl818_board boardtypes[] = {
 struct pcl818_dma_desc {
 	void *virt_addr;	/* virtual address of DMA buffer */
 	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
+	unsigned int size;	/* transfer size (in bytes) */
 };
 
 struct pcl818_private {
@@ -349,17 +350,17 @@ static void pcl818_ai_setup_dma(struct comedi_device *dev,
 	struct pcl818_dma_desc *dma = &devpriv->dma_desc[0];
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int flags;
-	unsigned int bytes;
 
 	disable_dma(devpriv->dma);	/*  disable dma */
-	bytes = devpriv->hwdmasize;
 	if (cmd->stop_src == TRIG_COUNT) {
-		bytes = cmd->stop_arg * comedi_bytes_per_scan(s);
-		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;
-		devpriv->last_dma_run = bytes % devpriv->hwdmasize;
+		dma->size = cmd->stop_arg * comedi_bytes_per_scan(s);
+		devpriv->dma_runs_to_end = dma->size / devpriv->hwdmasize;
+		devpriv->last_dma_run = dma->size % devpriv->hwdmasize;
 		devpriv->dma_runs_to_end--;
 		if (devpriv->dma_runs_to_end >= 0)
-			bytes = devpriv->hwdmasize;
+			dma->size = devpriv->hwdmasize;
+	} else {
+		dma->size = devpriv->hwdmasize;
 	}
 
 	devpriv->cur_dma = 0;
@@ -367,7 +368,7 @@ static void pcl818_ai_setup_dma(struct comedi_device *dev,
 	flags = claim_dma_lock();
 	clear_dma_ff(devpriv->dma);
 	set_dma_addr(devpriv->dma, dma->hw_addr);
-	set_dma_count(devpriv->dma, bytes);
+	set_dma_count(devpriv->dma, dma->size);
 	release_dma_lock(flags);
 	enable_dma(devpriv->dma);
 }
@@ -385,13 +386,14 @@ static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
 	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
 		/* switch dma bufs */
 		dma = &devpriv->dma_desc[devpriv->cur_dma];
+		if (devpriv->dma_runs_to_end || cmd->stop_src == TRIG_NONE)
+			dma->size = devpriv->hwdmasize;
+		else
+			dma->size = devpriv->last_dma_run;
 		set_dma_mode(devpriv->dma, DMA_MODE_READ);
 		flags = claim_dma_lock();
 		set_dma_addr(devpriv->dma, dma->hw_addr);
-		if (devpriv->dma_runs_to_end || cmd->stop_src == TRIG_NONE)
-			set_dma_count(devpriv->dma, devpriv->hwdmasize);
-		else
-			set_dma_count(devpriv->dma, devpriv->last_dma_run);
+		set_dma_count(devpriv->dma, dma->size);
 		release_dma_lock(flags);
 		enable_dma(devpriv->dma);
 	}
@@ -565,17 +567,15 @@ static void pcl818_handle_dma(struct comedi_device *dev,
 	struct pcl818_private *devpriv = dev->private;
 	struct pcl818_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
 	unsigned short *ptr = dma->virt_addr;
+	unsigned int nsamples = comedi_bytes_to_samples(s, dma->size);
 	unsigned int chan;
 	unsigned int val;
-	int i, len, bufptr;
+	int i;
 
 	pcl818_ai_setup_next_dma(dev, s);
 
-	len = devpriv->hwdmasize >> 1;
-	bufptr = 0;
-
-	for (i = 0; i < len; i++) {
-		val = ptr[bufptr++];
+	for (i = 0; i < nsamples; i++) {
+		val = ptr[i];
 		chan = val & 0xf;
 		val = (val >> 4) & s->maxdata;
 

commit 7a37b7a7556fe6b4108ad7cea25a484b87d11ee9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:58 2015 -0700

    staging: comedi: pcl818: remove VIRT_TO_BUS dependancy
    
    Use dma_{alloc,free}_coherent() to allocate and free the DMA buffers.
    This removes the dependancy on VIRT_TO_BUS.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index f34c5cc03834..3656ecf10813 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -303,13 +303,12 @@ static const struct pcl818_board boardtypes[] = {
 };
 
 struct pcl818_dma_desc {
-	unsigned long dmabuf;	/*  pointers to begin of DMA buffers */
-	unsigned int hwdmaptr;	/*  hardware address of DMA buffers */
+	void *virt_addr;	/* virtual address of DMA buffer */
+	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
 };
 
 struct pcl818_private {
 	unsigned int dma;	/*  used DMA, 0=don't use DMA */
-	unsigned int dmapages;
 	unsigned int hwdmasize;
 	struct pcl818_dma_desc dma_desc[2];
 	int cur_dma;
@@ -367,7 +366,7 @@ static void pcl818_ai_setup_dma(struct comedi_device *dev,
 	set_dma_mode(devpriv->dma, DMA_MODE_READ);
 	flags = claim_dma_lock();
 	clear_dma_ff(devpriv->dma);
-	set_dma_addr(devpriv->dma, dma->hwdmaptr);
+	set_dma_addr(devpriv->dma, dma->hw_addr);
 	set_dma_count(devpriv->dma, bytes);
 	release_dma_lock(flags);
 	enable_dma(devpriv->dma);
@@ -388,7 +387,7 @@ static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
 		dma = &devpriv->dma_desc[devpriv->cur_dma];
 		set_dma_mode(devpriv->dma, DMA_MODE_READ);
 		flags = claim_dma_lock();
-		set_dma_addr(devpriv->dma, dma->hwdmaptr);
+		set_dma_addr(devpriv->dma, dma->hw_addr);
 		if (devpriv->dma_runs_to_end || cmd->stop_src == TRIG_NONE)
 			set_dma_count(devpriv->dma, devpriv->hwdmasize);
 		else
@@ -565,7 +564,7 @@ static void pcl818_handle_dma(struct comedi_device *dev,
 {
 	struct pcl818_private *devpriv = dev->private;
 	struct pcl818_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
-	unsigned short *ptr = (unsigned short *)dma->dmabuf;
+	unsigned short *ptr = dma->virt_addr;
 	unsigned int chan;
 	unsigned int val;
 	int i, len, bufptr;
@@ -1072,16 +1071,15 @@ static int pcl818_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 		return 0;
 	devpriv->dma = dma_chan;
 
-	devpriv->dmapages = 2;	/* we need 16KB */
-	devpriv->hwdmasize = (1 << devpriv->dmapages) * PAGE_SIZE;
+	devpriv->hwdmasize = PAGE_SIZE * 4;	/* we need 16KB */
 
 	for (i = 0; i < 2; i++) {
 		dma = &devpriv->dma_desc[i];
 
-		dma->dmabuf = __get_dma_pages(GFP_KERNEL, devpriv->dmapages);
-		if (!dma->dmabuf)
+		dma->virt_addr = dma_alloc_coherent(NULL, devpriv->hwdmasize,
+						    &dma->hw_addr, GFP_KERNEL);
+		if (!dma->virt_addr)
 			return -ENOMEM;
-		dma->hwdmaptr = virt_to_bus((void *)dma->dmabuf);
 	}
 	return 0;
 }
@@ -1099,8 +1097,9 @@ static void pcl818_free_dma(struct comedi_device *dev)
 		free_dma(devpriv->dma);
 	for (i = 0; i < 2; i++) {
 		dma = &devpriv->dma_desc[i];
-		if (dma->dmabuf)
-			free_pages(dma->dmabuf, devpriv->dmapages);
+		if (dma->virt_addr)
+			dma_free_coherent(NULL, devpriv->hwdmasize,
+					  dma->virt_addr, dma->hw_addr);
 	}
 }
 

commit b8e7048bab32b6571dd4930f9a94622556a01ad4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:57 2015 -0700

    staging: comedi: pcl818: introduce struct pcl818_dma_desc
    
    For aesthetics, introduce a struct to hold the DMA descriptor data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index beb03ec10cd1..f34c5cc03834 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -302,13 +302,17 @@ static const struct pcl818_board boardtypes[] = {
 	},
 };
 
+struct pcl818_dma_desc {
+	unsigned long dmabuf;	/*  pointers to begin of DMA buffers */
+	unsigned int hwdmaptr;	/*  hardware address of DMA buffers */
+};
+
 struct pcl818_private {
 	unsigned int dma;	/*  used DMA, 0=don't use DMA */
 	unsigned int dmapages;
 	unsigned int hwdmasize;
-	unsigned long dmabuf[2];	/*  pointers to begin of DMA buffers */
-	unsigned int hwdmaptr[2];	/*  hardware address of DMA buffers */
-	int next_dma_buf;	/*  which DMA buffer will be used next round */
+	struct pcl818_dma_desc dma_desc[2];
+	int cur_dma;
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
 	unsigned int ns_min;	/*  manimal allowed delay between samples (in us) for actual card */
@@ -343,6 +347,7 @@ static void pcl818_ai_setup_dma(struct comedi_device *dev,
 				struct comedi_subdevice *s)
 {
 	struct pcl818_private *devpriv = dev->private;
+	struct pcl818_dma_desc *dma = &devpriv->dma_desc[0];
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int flags;
 	unsigned int bytes;
@@ -358,11 +363,11 @@ static void pcl818_ai_setup_dma(struct comedi_device *dev,
 			bytes = devpriv->hwdmasize;
 	}
 
-	devpriv->next_dma_buf = 0;
+	devpriv->cur_dma = 0;
 	set_dma_mode(devpriv->dma, DMA_MODE_READ);
 	flags = claim_dma_lock();
 	clear_dma_ff(devpriv->dma);
-	set_dma_addr(devpriv->dma, devpriv->hwdmaptr[0]);
+	set_dma_addr(devpriv->dma, dma->hwdmaptr);
 	set_dma_count(devpriv->dma, bytes);
 	release_dma_lock(flags);
 	enable_dma(devpriv->dma);
@@ -373,16 +378,17 @@ static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
 {
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
+	struct pcl818_dma_desc *dma;
 	unsigned long flags;
 
 	disable_dma(devpriv->dma);
-	devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
+	devpriv->cur_dma = 1 - devpriv->cur_dma;
 	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
 		/* switch dma bufs */
+		dma = &devpriv->dma_desc[devpriv->cur_dma];
 		set_dma_mode(devpriv->dma, DMA_MODE_READ);
 		flags = claim_dma_lock();
-		set_dma_addr(devpriv->dma,
-			     devpriv->hwdmaptr[devpriv->next_dma_buf]);
+		set_dma_addr(devpriv->dma, dma->hwdmaptr);
 		if (devpriv->dma_runs_to_end || cmd->stop_src == TRIG_NONE)
 			set_dma_count(devpriv->dma, devpriv->hwdmasize);
 		else
@@ -558,15 +564,14 @@ static void pcl818_handle_dma(struct comedi_device *dev,
 			      struct comedi_subdevice *s)
 {
 	struct pcl818_private *devpriv = dev->private;
-	unsigned short *ptr;
+	struct pcl818_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
+	unsigned short *ptr = (unsigned short *)dma->dmabuf;
 	unsigned int chan;
 	unsigned int val;
 	int i, len, bufptr;
 
 	pcl818_ai_setup_next_dma(dev, s);
 
-	ptr = (unsigned short *)devpriv->dmabuf[1 - devpriv->next_dma_buf];
-
 	len = devpriv->hwdmasize >> 1;
 	bufptr = 0;
 
@@ -1057,6 +1062,7 @@ static void pcl818_set_ai_range_table(struct comedi_device *dev,
 static int pcl818_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 {
 	struct pcl818_private *devpriv = dev->private;
+	struct pcl818_dma_desc *dma;
 	int i;
 
 	if (!(dma_chan == 3 || dma_chan == 1))
@@ -1070,14 +1076,12 @@ static int pcl818_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 	devpriv->hwdmasize = (1 << devpriv->dmapages) * PAGE_SIZE;
 
 	for (i = 0; i < 2; i++) {
-		unsigned long dmabuf;
+		dma = &devpriv->dma_desc[i];
 
-		dmabuf = __get_dma_pages(GFP_KERNEL, devpriv->dmapages);
-		if (!dmabuf)
+		dma->dmabuf = __get_dma_pages(GFP_KERNEL, devpriv->dmapages);
+		if (!dma->dmabuf)
 			return -ENOMEM;
-
-		devpriv->dmabuf[i] = dmabuf;
-		devpriv->hwdmaptr[i] = virt_to_bus((void *)dmabuf);
+		dma->hwdmaptr = virt_to_bus((void *)dma->dmabuf);
 	}
 	return 0;
 }
@@ -1085,6 +1089,7 @@ static int pcl818_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 static void pcl818_free_dma(struct comedi_device *dev)
 {
 	struct pcl818_private *devpriv = dev->private;
+	struct pcl818_dma_desc *dma;
 	int i;
 
 	if (!devpriv)
@@ -1093,8 +1098,9 @@ static void pcl818_free_dma(struct comedi_device *dev)
 	if (devpriv->dma)
 		free_dma(devpriv->dma);
 	for (i = 0; i < 2; i++) {
-		if (devpriv->dmabuf[i])
-			free_pages(devpriv->dmabuf[i], devpriv->dmapages);
+		dma = &devpriv->dma_desc[i];
+		if (dma->dmabuf)
+			free_pages(dma->dmabuf, devpriv->dmapages);
 	}
 }
 

commit 665ee190c99d05940ed0959717b78ef176b92e95
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:56 2015 -0700

    staging: comedi: pcl818: introduce pcl818_dma_free()
    
    For aesthetics, move the freeing of the DMA channel and the buffers to
    a helper function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index b25ff3531d23..beb03ec10cd1 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1082,6 +1082,22 @@ static int pcl818_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 	return 0;
 }
 
+static void pcl818_free_dma(struct comedi_device *dev)
+{
+	struct pcl818_private *devpriv = dev->private;
+	int i;
+
+	if (!devpriv)
+		return;
+
+	if (devpriv->dma)
+		free_dma(devpriv->dma);
+	for (i = 0; i < 2; i++) {
+		if (devpriv->dmabuf[i])
+			free_pages(devpriv->dmabuf[i], devpriv->dmapages);
+	}
+}
+
 static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl818_board *board = dev->board_ptr;
@@ -1217,13 +1233,8 @@ static void pcl818_detach(struct comedi_device *dev)
 	if (devpriv) {
 		pcl818_ai_cancel(dev, dev->read_subdev);
 		pcl818_reset(dev);
-		if (devpriv->dma)
-			free_dma(devpriv->dma);
-		if (devpriv->dmabuf[0])
-			free_pages(devpriv->dmabuf[0], devpriv->dmapages);
-		if (devpriv->dmabuf[1])
-			free_pages(devpriv->dmabuf[1], devpriv->dmapages);
 	}
+	pcl818_free_dma(dev);
 	comedi_legacy_detach(dev);
 }
 

commit 655cd94018c9b98b9aabab8960e5b3772a5bafaf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:55 2015 -0700

    staging: comedi: pcl818: introduce pcl818_alloc_dma()
    
    DMA is optional with this driver. Introduce a helper function to request
    the DMA channel and allocate the buffers. Don't fail the driver attach
    if the user passed an invalid DMA channel or the channel cannot be
    requested.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 8edea35532a9..b25ff3531d23 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1054,13 +1054,40 @@ static void pcl818_set_ai_range_table(struct comedi_device *dev,
 	}
 }
 
+static int pcl818_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
+{
+	struct pcl818_private *devpriv = dev->private;
+	int i;
+
+	if (!(dma_chan == 3 || dma_chan == 1))
+		return 0;
+
+	if (request_dma(dma_chan, dev->board_name))
+		return 0;
+	devpriv->dma = dma_chan;
+
+	devpriv->dmapages = 2;	/* we need 16KB */
+	devpriv->hwdmasize = (1 << devpriv->dmapages) * PAGE_SIZE;
+
+	for (i = 0; i < 2; i++) {
+		unsigned long dmabuf;
+
+		dmabuf = __get_dma_pages(GFP_KERNEL, devpriv->dmapages);
+		if (!dmabuf)
+			return -ENOMEM;
+
+		devpriv->dmabuf[i] = dmabuf;
+		devpriv->hwdmaptr[i] = virt_to_bus((void *)dmabuf);
+	}
+	return 0;
+}
+
 static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl818_board *board = dev->board_ptr;
 	struct pcl818_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
-	int i;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
@@ -1084,30 +1111,10 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->usefifo = 1;
 
 	/* we need an IRQ to do DMA on channel 3 or 1 */
-	if (dev->irq && board->has_dma &&
-	    (it->options[2] == 3 || it->options[2] == 1)) {
-		ret = request_dma(it->options[2], dev->board_name);
-		if (ret) {
-			dev_err(dev->class_dev,
-				"unable to request DMA channel %d\n",
-				it->options[2]);
-			return -EBUSY;
-		}
-		devpriv->dma = it->options[2];
-
-		devpriv->dmapages = 2;	/* we need 16KB */
-		devpriv->hwdmasize = (1 << devpriv->dmapages) * PAGE_SIZE;
-
-		for (i = 0; i < 2; i++) {
-			unsigned long dmabuf;
-
-			dmabuf = __get_dma_pages(GFP_KERNEL, devpriv->dmapages);
-			if (!dmabuf)
-				return -ENOMEM;
-
-			devpriv->dmabuf[i] = dmabuf;
-			devpriv->hwdmaptr[i] = virt_to_bus((void *)dmabuf);
-		}
+	if (dev->irq && board->has_dma) {
+		ret = pcl818_alloc_dma(dev, it->options[2]);
+		if (ret)
+			return ret;
 	}
 
 	ret = comedi_alloc_subdevices(dev, 4);

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index f1e0f36424e9..8edea35532a9 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1158,7 +1158,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				s->range_table = &range_unknown;
 		}
 		s->insn_write	= pcl818_ao_insn_write;
-		s->insn_read	= comedi_readback_insn_read;
 
 		ret = comedi_alloc_subdev_readback(s);
 		if (ret)

commit c76844e1ffd7504b6f5b9a356ac3d3d230eed8db
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:20:59 2014 -0700

    staging: comedi: pcl818: use comedi_async 'scans_done' to detect EOA
    
    Remove the private data member 'ai_act_scan' and use the comedi_async
    'scans_done' member to detect the end-of-acquisition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index d219e04468c7..f1e0f36424e9 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -313,7 +313,6 @@ struct pcl818_private {
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
 	unsigned int ns_min;	/*  manimal allowed delay between samples (in us) for actual card */
 	int i8253_osc_base;	/*  1/frequency of on board oscilator in ns */
-	int ai_act_scan;	/*  how many scans we finished */
 	unsigned int act_chanlist[16];	/*  MUX setting for actual AI operations */
 	unsigned int act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
@@ -524,11 +523,8 @@ static bool pcl818_ai_next_chan(struct comedi_device *dev,
 	if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)
 		devpriv->act_chanlist_pos = 0;
 
-	if (s->async->cur_chan == 0)
-		devpriv->ai_act_scan--;
-
-	if (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan == 0) {
-		/* all data sampled */
+	if (cmd->stop_src == TRIG_COUNT &&
+	    s->async->scans_done >= cmd->stop_arg) {
 		s->async->events |= COMEDI_CB_EOA;
 		return false;
 	}
@@ -635,6 +631,7 @@ static irqreturn_t pcl818_interrupt(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
 	if (!dev->attached || !devpriv->ai_cmd_running) {
 		pcl818_ai_clear_eoc(dev);
@@ -648,7 +645,7 @@ static irqreturn_t pcl818_interrupt(int irq, void *d)
 		 * being reprogrammed while a DMA transfer is in
 		 * progress.
 		 */
-		devpriv->ai_act_scan = 0;
+		s->async->scans_done = cmd->stop_arg;
 		s->cancel(dev, s);
 		return IRQ_HANDLED;
 	}
@@ -822,7 +819,6 @@ static int pcl818_ai_cmd(struct comedi_device *dev,
 	pcl818_ai_setup_chanlist(dev, cmd->chanlist, seglen);
 
 	devpriv->ai_data_len = s->async->prealloc_bufsz;
-	devpriv->ai_act_scan = cmd->stop_arg;
 	devpriv->ai_cmd_running = 1;
 	devpriv->ai_cmd_canceled = 0;
 	devpriv->act_chanlist_pos = 0;
@@ -865,7 +861,8 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 
 	if (devpriv->dma) {
 		if (cmd->stop_src == TRIG_NONE ||
-		    (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan > 0)) {
+		    (cmd->stop_src == TRIG_COUNT &&
+		     s->async->scans_done < cmd->stop_arg)) {
 			if (!devpriv->ai_cmd_canceled) {
 				/*
 				* Wait for running dma transfer to end,

commit 42dafac3a5302dd4165a5532a99bbdc4b39b1b94
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:20:58 2014 -0700

    staging: comedi: pcl818: remove private data member 'ai_act_chan'
    
    This member of the private data is set to '0' but never used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index dc2715ae6b18..d219e04468c7 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -314,7 +314,6 @@ struct pcl818_private {
 	unsigned int ns_min;	/*  manimal allowed delay between samples (in us) for actual card */
 	int i8253_osc_base;	/*  1/frequency of on board oscilator in ns */
 	int ai_act_scan;	/*  how many scans we finished */
-	int ai_act_chan;	/*  actual position in actual scan */
 	unsigned int act_chanlist[16];	/*  MUX setting for actual AI operations */
 	unsigned int act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
@@ -824,7 +823,6 @@ static int pcl818_ai_cmd(struct comedi_device *dev,
 
 	devpriv->ai_data_len = s->async->prealloc_bufsz;
 	devpriv->ai_act_scan = cmd->stop_arg;
-	devpriv->ai_act_chan = 0;
 	devpriv->ai_cmd_running = 1;
 	devpriv->ai_cmd_canceled = 0;
 	devpriv->act_chanlist_pos = 0;

commit f8736ca466e2014d6e8bad478fcc5e5cb0105af0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 09:49:31 2014 -0700

    staging: comedi: drivers: move comedi_async 'cur_chan' tracking into the core
    
    The commedi_async 'cur_chan' member is used to track the current position
    in the chanlist for a scan. Currently only a couple comedi drivers use
    this member.
    
    For aeshtetics, move the 'cur_chan' tracking into the core for non-SDF_PACKED
    subdevices. The 'cur_chan' will be updated after reading or writing samples
    to the async buffer by comedi_inc_scan_progress(). All non-SDF_PACKED subdevices
    will then automatiaclly track the 'cur_chan'.
    
    Some of the drivers use the 'cur_chan' to detect the end of scan event when
    counting scans. The COMEDI_CB_EOS event is automatically added by the core
    when the end of scan is detected. The drivers just need to check if the
    'cur_chan' is 0 to count the number of scans completed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index e6d897bf5714..dc2715ae6b18 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -525,12 +525,8 @@ static bool pcl818_ai_next_chan(struct comedi_device *dev,
 	if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)
 		devpriv->act_chanlist_pos = 0;
 
-	s->async->cur_chan++;
-	if (s->async->cur_chan >= cmd->chanlist_len) {
-		s->async->cur_chan = 0;
+	if (s->async->cur_chan == 0)
 		devpriv->ai_act_scan--;
-		s->async->events |= COMEDI_CB_EOS;
-	}
 
 	if (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan == 0) {
 		/* all data sampled */

commit edf4537bcbf53bb6297678431da12b766fe16610
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:37:04 2014 -0700

    staging: comedi: pcl818: use comedi_buf_write_samples()
    
    For aesthetics, use comedi_buf_write_samples() to add the sample to the
    async buffer.
    
    The core will add the COMEDI_CB_BLOCK event when data is written to the
    async buffer. Remove the unnecessary event in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 9921e1fa7515..e6d897bf5714 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -521,8 +521,6 @@ static bool pcl818_ai_next_chan(struct comedi_device *dev,
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	s->async->events |= COMEDI_CB_BLOCK;
-
 	devpriv->act_chanlist_pos++;
 	if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)
 		devpriv->act_chanlist_pos = 0;
@@ -560,7 +558,7 @@ static void pcl818_handle_eoc(struct comedi_device *dev,
 	if (pcl818_ai_dropout(dev, s, chan))
 		return;
 
-	comedi_buf_put(s, val);
+	comedi_buf_write_samples(s, &val, 1);
 
 	pcl818_ai_next_chan(dev, s);
 }
@@ -589,7 +587,7 @@ static void pcl818_handle_dma(struct comedi_device *dev,
 		if (pcl818_ai_dropout(dev, s, chan))
 			break;
 
-		comedi_buf_put(s, val);
+		comedi_buf_write_samples(s, &val, 1);
 
 		if (!pcl818_ai_next_chan(dev, s))
 			break;
@@ -630,7 +628,7 @@ static void pcl818_handle_fifo(struct comedi_device *dev,
 		if (pcl818_ai_dropout(dev, s, chan))
 			break;
 
-		comedi_buf_put(s, val);
+		comedi_buf_write_samples(s, &val, 1);
 
 		if (!pcl818_ai_next_chan(dev, s))
 			break;

commit ab192afc6571c49570ff52ab9c833a8f61ae6b18
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:41:19 2014 -0700

    staging: comedi: pcl818: use comedi_bytes_per_scan()
    
    This inline function is just a wrapper around comedi_bytes_per_scan().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 618591d3b3b3..9921e1fa7515 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -352,7 +352,7 @@ static void pcl818_ai_setup_dma(struct comedi_device *dev,
 	disable_dma(devpriv->dma);	/*  disable dma */
 	bytes = devpriv->hwdmasize;
 	if (cmd->stop_src == TRIG_COUNT) {
-		bytes = cmd->stop_arg * cfc_bytes_per_scan(s);
+		bytes = cmd->stop_arg * comedi_bytes_per_scan(s);
 		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;
 		devpriv->last_dma_run = bytes % devpriv->hwdmasize;
 		devpriv->dma_runs_to_end--;

commit 11e7c09aee65e496dbe27e4d57bede97f7a5af4c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:34 2014 -0700

    staging: comedi: pcl818: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index ac19e83ce62a..618591d3b3b3 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -669,7 +669,7 @@ static irqreturn_t pcl818_interrupt(int irq, void *d)
 
 	pcl818_ai_clear_eoc(dev);
 
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 	return IRQ_HANDLED;
 }
 

commit dc453864d6124603af8e3600650304d9b9643586
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:52 2014 +0100

    staging: comedi: pcl818: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 36c77518d6e4..ac19e83ce62a 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -738,7 +738,7 @@ static int check_single_ended(unsigned int port)
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
-	const struct pcl818_board *board = comedi_board(dev);
+	const struct pcl818_board *board = dev->board_ptr;
 	struct pcl818_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int arg;
@@ -980,7 +980,7 @@ static int pcl818_do_insn_bits(struct comedi_device *dev,
 
 static void pcl818_reset(struct comedi_device *dev)
 {
-	const struct pcl818_board *board = comedi_board(dev);
+	const struct pcl818_board *board = dev->board_ptr;
 	unsigned long timer_base = dev->iobase + PCL818_TIMER_BASE;
 	unsigned int chan;
 
@@ -1018,7 +1018,7 @@ static void pcl818_set_ai_range_table(struct comedi_device *dev,
 				      struct comedi_subdevice *s,
 				      struct comedi_devconfig *it)
 {
-	const struct pcl818_board *board = comedi_board(dev);
+	const struct pcl818_board *board = dev->board_ptr;
 
 	/* default to the range table from the boardinfo */
 	s->range_table = board->ai_range_type;
@@ -1067,7 +1067,7 @@ static void pcl818_set_ai_range_table(struct comedi_device *dev,
 
 static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct pcl818_board *board = comedi_board(dev);
+	const struct pcl818_board *board = dev->board_ptr;
 	struct pcl818_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;

commit 073d4632600cb76e7452f8eaa25b720fa9a992ca
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:35 2014 -0700

    staging: comedi: pcl818: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 000dbf841e45..36c77518d6e4 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -319,7 +319,6 @@ struct pcl818_private {
 	unsigned int act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
 	unsigned int ai_data_len;	/*  len of data buffer */
-	unsigned int ao_readback[2];
 	unsigned int divisor1;
 	unsigned int divisor2;
 	unsigned int usefifo:1;
@@ -937,32 +936,18 @@ static int pcl818_ao_insn_write(struct comedi_device *dev,
 				struct comedi_insn *insn,
 				unsigned int *data)
 {
-	struct pcl818_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int val = s->readback[chan];
 	int i;
 
 	for (i = 0; i < insn->n; i++) {
-		devpriv->ao_readback[chan] = data[i];
-		outb((data[i] & 0x000f) << 4,
+		val = data[i];
+		outb((val & 0x000f) << 4,
 		     dev->iobase + PCL818_AO_LSB_REG(chan));
-		outb((data[i] & 0x0ff0) >> 4,
+		outb((val & 0x0ff0) >> 4,
 		     dev->iobase + PCL818_AO_MSB_REG(chan));
 	}
-
-	return insn->n;
-}
-
-static int pcl818_ao_insn_read(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn,
-			       unsigned int *data)
-{
-	struct pcl818_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	int i;
-
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->ao_readback[chan];
+	s->readback[chan] = val;
 
 	return insn->n;
 }
@@ -1172,8 +1157,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->n_chan	= board->n_aochan;
 		s->maxdata	= 0x0fff;
 		s->range_table	= &range_unipolar5;
-		s->insn_read	= pcl818_ao_insn_read;
-		s->insn_write	= pcl818_ao_insn_write;
 		if (board->is_818) {
 			if ((it->options[4] == 1) || (it->options[4] == 10))
 				s->range_table = &range_unipolar10;
@@ -1185,6 +1168,12 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			if (it->options[5] == 2)
 				s->range_table = &range_unknown;
 		}
+		s->insn_write	= pcl818_ao_insn_write;
+		s->insn_read	= comedi_readback_insn_read;
+
+		ret = comedi_alloc_subdev_readback(s);
+		if (ret)
+			return ret;
 	} else {
 		s->type		= COMEDI_SUBD_UNUSED;
 	}

commit f25a9ba271676469ecb9c0c7559e52af2f3f32fe
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:29 2014 -0700

    staging: comedi: pcl818: remove use of comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character. The addition of the driver_name is just added noise
    and some of the users of comedi_error() add unnecessary additional new-line
    characters.
    
    Use dev_err() directly instead of comedi_error() to avoid any confusion
    and so that all the comedi generated kernel messages have the same format.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 7d00ae639d38..000dbf841e45 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -551,7 +551,7 @@ static void pcl818_handle_eoc(struct comedi_device *dev,
 	unsigned int val;
 
 	if (pcl818_ai_eoc(dev, s, NULL, 0)) {
-		comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
+		dev_err(dev->class_dev, "A/D mode1/3 IRQ without DRDY!\n");
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		return;
 	}
@@ -608,13 +608,14 @@ static void pcl818_handle_fifo(struct comedi_device *dev,
 	status = inb(dev->iobase + PCL818_FI_STATUS);
 
 	if (status & 4) {
-		comedi_error(dev, "A/D mode1/3 FIFO overflow!");
+		dev_err(dev->class_dev, "A/D mode1/3 FIFO overflow!\n");
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		return;
 	}
 
 	if (status & 1) {
-		comedi_error(dev, "A/D mode1/3 FIFO interrupt without data!");
+		dev_err(dev->class_dev,
+			"A/D mode1/3 FIFO interrupt without data!\n");
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		return;
 	}
@@ -682,7 +683,7 @@ static int check_channel_list(struct comedi_device *dev,
 
 	/* correct channel and range number check itself comedi/range.c */
 	if (n_chan < 1) {
-		comedi_error(dev, "range/channel list is empty!");
+		dev_err(dev->class_dev, "range/channel list is empty!\n");
 		return 0;
 	}
 

commit 42e21c974377e2188888d88b2cf2d3c95033d9d7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:31:12 2014 -0700

    staging: comedi: pcl818: use cfc_bytes_per_scan()
    
    Use the comedi_fc helper to get the number of bytes per scan.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 48b81c39c6a8..7d00ae639d38 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -353,7 +353,7 @@ static void pcl818_ai_setup_dma(struct comedi_device *dev,
 	disable_dma(devpriv->dma);	/*  disable dma */
 	bytes = devpriv->hwdmasize;
 	if (cmd->stop_src == TRIG_COUNT) {
-		bytes = cmd->chanlist_len * cmd->stop_arg * sizeof(short);
+		bytes = cmd->stop_arg * cfc_bytes_per_scan(s);
 		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;
 		devpriv->last_dma_run = bytes % devpriv->hwdmasize;
 		devpriv->dma_runs_to_end--;

commit 863731fd6f9d375ce6e72f5816d578913a2d3223
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:12:56 2014 -0700

    staging: comedi: pcl818: use comedi_fc helpers to validate timer arg
    
    Use the comedi_fc helper cfc_check_trigger_arg_is() to validate the
    trigger argument when the source is TRIG_TIMER.
    
    The minimum test is not needed, this was already validated in Step 3.
    
    All the arguments are unsigned int, change the local variable to an
    unsigned int and rename it for aesthetic reasons.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index b960b66bc9a8..48b81c39c6a8 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -741,7 +741,7 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	const struct pcl818_board *board = comedi_board(dev);
 	struct pcl818_private *devpriv = dev->private;
 	int err = 0;
-	int tmp;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -788,15 +788,12 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* step 4: fix up any arguments */
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		tmp = cmd->convert_arg;
+		arg = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base,
 					  &devpriv->divisor1,
 					  &devpriv->divisor2,
-					  &cmd->convert_arg, cmd->flags);
-		if (cmd->convert_arg < board->ns_min)
-			cmd->convert_arg = board->ns_min;
-		if (tmp != cmd->convert_arg)
-			err++;
+					  &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
 	if (err)

commit 3672effdeae5395d661a2103f69082146ef949fc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:11:59 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_put()
    
    Change the parameters of `comedi_buf_put()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function puts a sample value in the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 6463476ce45a..b960b66bc9a8 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -561,7 +561,7 @@ static void pcl818_handle_eoc(struct comedi_device *dev,
 	if (pcl818_ai_dropout(dev, s, chan))
 		return;
 
-	comedi_buf_put(s->async, val);
+	comedi_buf_put(s, val);
 
 	pcl818_ai_next_chan(dev, s);
 }
@@ -590,7 +590,7 @@ static void pcl818_handle_dma(struct comedi_device *dev,
 		if (pcl818_ai_dropout(dev, s, chan))
 			break;
 
-		comedi_buf_put(s->async, val);
+		comedi_buf_put(s, val);
 
 		if (!pcl818_ai_next_chan(dev, s))
 			break;
@@ -630,7 +630,7 @@ static void pcl818_handle_fifo(struct comedi_device *dev,
 		if (pcl818_ai_dropout(dev, s, chan))
 			break;
 
-		comedi_buf_put(s->async, val);
+		comedi_buf_put(s, val);
 
 		if (!pcl818_ai_next_chan(dev, s))
 			break;

commit 2f1f7ea0c5a8171583b93f880d4b988d83658a76
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:40 2014 -0700

    staging: comedi: pcl818: use cfc_handle_events()
    
    Use the comedi_fc helper function to automatically call the subdevice
    (*cancel) function when needed and call comedi_event().
    
    Update the Kconfig so that COMEDI_PCL818 selects COMEDI_FC.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index d4d5c384aa1b..6463476ce45a 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -510,7 +510,6 @@ static bool pcl818_ai_dropout(struct comedi_device *dev,
 			(devpriv->dma) ? "DMA" :
 			(devpriv->usefifo) ? "FIFO" : "IRQ",
 			chan, expected_chan);
-		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		return true;
 	}
@@ -538,7 +537,6 @@ static bool pcl818_ai_next_chan(struct comedi_device *dev,
 
 	if (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan == 0) {
 		/* all data sampled */
-		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA;
 		return false;
 	}
@@ -554,7 +552,6 @@ static void pcl818_handle_eoc(struct comedi_device *dev,
 
 	if (pcl818_ai_eoc(dev, s, NULL, 0)) {
 		comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
-		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		return;
 	}
@@ -612,14 +609,12 @@ static void pcl818_handle_fifo(struct comedi_device *dev,
 
 	if (status & 4) {
 		comedi_error(dev, "A/D mode1/3 FIFO overflow!");
-		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		return;
 	}
 
 	if (status & 1) {
 		comedi_error(dev, "A/D mode1/3 FIFO interrupt without data!");
-		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		return;
 	}
@@ -674,7 +669,7 @@ static irqreturn_t pcl818_interrupt(int irq, void *d)
 
 	pcl818_ai_clear_eoc(dev);
 
-	comedi_event(dev, s);
+	cfc_handle_events(dev, s);
 	return IRQ_HANDLED;
 }
 

commit bc7d7fc0e377c5028bb3d2945a5d4a3162c461dc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:27 2014 -0700

    staging: comedi: pcl818: clarify pcl818_reset()
    
    Like done in the pcl812 driver, use the boardinfo to determine what
    should be reset.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index a2d65e429709..d4d5c384aa1b 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1004,6 +1004,7 @@ static void pcl818_reset(struct comedi_device *dev)
 {
 	const struct pcl818_board *board = comedi_board(dev);
 	unsigned long timer_base = dev->iobase + PCL818_TIMER_BASE;
+	unsigned int chan;
 
 	/* flush and disable the FIFO */
 	if (board->has_fifo) {
@@ -1011,30 +1012,28 @@ static void pcl818_reset(struct comedi_device *dev)
 		outb(0, dev->iobase + PCL818_FI_FLUSH);
 		outb(0, dev->iobase + PCL818_FI_ENABLE);
 	}
-	/* set analog output channel 0 to 0V */
-	outb(0, dev->iobase + PCL818_AO_LSB_REG(0));
-	outb(0, dev->iobase + PCL818_AO_MSB_REG(0));
-	udelay(1);
-	outb(0, dev->iobase + PCL818_DO_DI_MSB_REG);
-	outb(0, dev->iobase + PCL818_DO_DI_LSB_REG);
-	udelay(1);
+
+	/* disable analog input trigger */
 	outb(PCL818_CTRL_DISABLE_TRIG, dev->iobase + PCL818_CTRL_REG);
-	outb(PCL818_CNTENABLE_PACER_ENA, dev->iobase + PCL818_CNTENABLE_REG);
-	outb(0, dev->iobase + PCL818_MUX_REG);
 	pcl818_ai_clear_eoc(dev);
 
-	/* Stop pacer */
+	pcl818_ai_set_chan_range(dev, 0, 0);
+
+	/* stop pacer */
+	outb(PCL818_CNTENABLE_PACER_ENA, dev->iobase + PCL818_CNTENABLE_REG);
 	i8254_set_mode(timer_base, 0, 2, I8254_MODE0 | I8254_BINARY);
 	i8254_set_mode(timer_base, 0, 1, I8254_MODE0 | I8254_BINARY);
 	i8254_set_mode(timer_base, 0, 0, I8254_MODE0 | I8254_BINARY);
 
-	if (board->is_818) {
-		outb(0, dev->iobase + PCL818_RANGE_REG);
-	} else {
-		/* set analog output channel 1 to 0V */
-		outb(0, dev->iobase + PCL818_AO_LSB_REG(1));
-		outb(0, dev->iobase + PCL818_AO_MSB_REG(1));
+	/* set analog output channels to 0V */
+	for (chan = 0; chan < board->n_aochan; chan++) {
+		outb(0, dev->iobase + PCL818_AO_LSB_REG(chan));
+		outb(0, dev->iobase + PCL818_AO_MSB_REG(chan));
 	}
+
+	/* set all digital outputs low */
+	outb(0, dev->iobase + PCL818_DO_DI_MSB_REG);
+	outb(0, dev->iobase + PCL818_DO_DI_LSB_REG);
 }
 
 static void pcl818_set_ai_range_table(struct comedi_device *dev,

commit 1be6b015e7549aae113d31bbd0ce948ba85f262c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:25 2014 -0700

    staging: comedi: pcl818: tidy up the remaining register defines
    
    For aesthetics, rename the timer/counter enable request register
    and define its bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 84faf38b8c9f..a2d65e429709 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -119,9 +119,9 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define boardPCL818 4
 #define boardPCL718 5
 
-/* W: counter enable */
-#define PCL818_CNTENABLE 10
-
+/*
+ * Register I/O map
+ */
 #define PCL818_AI_LSB_REG			0x00
 #define PCL818_AI_MSB_REG			0x01
 #define PCL818_RANGE_REG			0x01
@@ -144,6 +144,11 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define PCL818_CTRL_DMAE			(1 << 2)
 #define PCL818_CTRL_IRQ(x)			((x) << 4)
 #define PCL818_CTRL_INTE			(1 << 7)
+#define PCL818_CNTENABLE_REG			0x0a
+#define PCL818_CNTENABLE_PACER_ENA		(0 << 0)
+#define PCL818_CNTENABLE_PACER_TRIG0		(1 << 0)
+#define PCL818_CNTENABLE_CNT0_EXT_CLK		(0 << 1)
+#define PCL818_CNTENABLE_CNT0_INT_CLK		(1 << 1)
 #define PCL818_DO_DI_MSB_REG			0x0b
 #define PCL818_TIMER_BASE			0x0c
 
@@ -844,7 +849,7 @@ static int pcl818_ai_cmd(struct comedi_device *dev,
 	else
 		ctrl |= PCL818_CTRL_EXT_TRIG;
 
-	outb(0, dev->iobase + PCL818_CNTENABLE);	/* enable pacer */
+	outb(PCL818_CNTENABLE_PACER_ENA, dev->iobase + PCL818_CNTENABLE_REG);
 
 	if (devpriv->dma) {
 		pcl818_ai_setup_dma(dev, s);
@@ -1014,7 +1019,7 @@ static void pcl818_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + PCL818_DO_DI_LSB_REG);
 	udelay(1);
 	outb(PCL818_CTRL_DISABLE_TRIG, dev->iobase + PCL818_CTRL_REG);
-	outb(0, dev->iobase + PCL818_CNTENABLE);
+	outb(PCL818_CNTENABLE_PACER_ENA, dev->iobase + PCL818_CNTENABLE_REG);
 	outb(0, dev->iobase + PCL818_MUX_REG);
 	pcl818_ai_clear_eoc(dev);
 

commit d5f874367ae5e448860ce7df3f63db16246ac980
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:22 2014 -0700

    staging: comedi: pcl818: cleanup ai_cmd()
    
    Rename this function so it has namespace associated with the driver.
    
    The cmd->scan_begin_src is always TRIG_FOLLOW and the only valid
    cmd->convert_src is TRIG_TIMER or TRIG_EXT so pcl818_ai_cmd_mode()
    is always called with a 'mode' of 1 or 3. The 'mode' actually indicates
    the trigger source.
    
    Absorb pcl818_ai_cmd_mode() into this function and simplify the code.
    
    This also removes the need for a forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index c4f9d54ca0a6..84faf38b8c9f 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -322,10 +322,6 @@ struct pcl818_private {
 	unsigned int ai_cmd_canceled:1;
 };
 
-static int check_channel_list(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      unsigned int *chanlist, unsigned int n_chan);
-
 static void pcl818_start_pacer(struct comedi_device *dev, bool load_counters)
 {
 	struct pcl818_private *devpriv = dev->private;
@@ -677,58 +673,6 @@ static irqreturn_t pcl818_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
-			      struct comedi_subdevice *s)
-{
-	struct pcl818_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int ctrl = 0;
-	unsigned int seglen;
-
-	if (devpriv->ai_cmd_running)
-		return -EBUSY;
-
-	pcl818_start_pacer(dev, false);
-
-	seglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);
-	if (seglen < 1)
-		return -EINVAL;
-	pcl818_ai_setup_chanlist(dev, cmd->chanlist, seglen);
-
-	udelay(1);
-
-	devpriv->ai_act_scan = cmd->stop_arg;
-	devpriv->ai_act_chan = 0;
-	devpriv->ai_cmd_running = 1;
-	devpriv->ai_cmd_canceled = 0;
-	devpriv->act_chanlist_pos = 0;
-	devpriv->dma_runs_to_end = 0;
-
-	outb(0, dev->iobase + PCL818_CNTENABLE);	/* enable pacer */
-
-	if (mode == 1)
-		ctrl |= PCL818_CTRL_PACER_TRIG;
-	else
-		ctrl |= PCL818_CTRL_EXT_TRIG;
-
-	if (devpriv->dma) {
-		pcl818_ai_setup_dma(dev, s);
-
-		ctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq) |
-			PCL818_CTRL_DMAE;
-	} else if (devpriv->usefifo) {
-		/* enable FIFO */
-		outb(1, dev->iobase + PCL818_FI_ENABLE);
-	} else {
-		ctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq);
-	}
-	outb(ctrl, dev->iobase + PCL818_CTRL_REG);
-
-	pcl818_start_pacer(dev, mode == 1);
-
-	return 0;
-}
-
 static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      unsigned int *chanlist, unsigned int n_chan)
@@ -869,25 +813,56 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	return 0;
 }
 
-static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pcl818_ai_cmd(struct comedi_device *dev,
+			 struct comedi_subdevice *s)
 {
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	int retval;
+	unsigned int ctrl = 0;
+	unsigned int seglen;
+
+	if (devpriv->ai_cmd_running)
+		return -EBUSY;
+
+	pcl818_start_pacer(dev, false);
+
+	seglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);
+	if (seglen < 1)
+		return -EINVAL;
+	pcl818_ai_setup_chanlist(dev, cmd->chanlist, seglen);
 
 	devpriv->ai_data_len = s->async->prealloc_bufsz;
+	devpriv->ai_act_scan = cmd->stop_arg;
+	devpriv->ai_act_chan = 0;
+	devpriv->ai_cmd_running = 1;
+	devpriv->ai_cmd_canceled = 0;
+	devpriv->act_chanlist_pos = 0;
+	devpriv->dma_runs_to_end = 0;
 
-	if (cmd->scan_begin_src == TRIG_FOLLOW) {	/*  mode 1, 3 */
-		if (cmd->convert_src == TRIG_TIMER) {	/*  mode 1 */
-			retval = pcl818_ai_cmd_mode(1, dev, s);
-			return retval;
-		}
-		if (cmd->convert_src == TRIG_EXT) {	/*  mode 3 */
-			return pcl818_ai_cmd_mode(3, dev, s);
-		}
+	if (cmd->convert_src == TRIG_TIMER)
+		ctrl |= PCL818_CTRL_PACER_TRIG;
+	else
+		ctrl |= PCL818_CTRL_EXT_TRIG;
+
+	outb(0, dev->iobase + PCL818_CNTENABLE);	/* enable pacer */
+
+	if (devpriv->dma) {
+		pcl818_ai_setup_dma(dev, s);
+
+		ctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq) |
+			PCL818_CTRL_DMAE;
+	} else if (devpriv->usefifo) {
+		/* enable FIFO */
+		outb(1, dev->iobase + PCL818_FI_ENABLE);
+	} else {
+		ctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq);
 	}
+	outb(ctrl, dev->iobase + PCL818_CTRL_REG);
 
-	return -1;
+	if (cmd->convert_src == TRIG_TIMER)
+		pcl818_start_pacer(dev, true);
+
+	return 0;
 }
 
 static int pcl818_ai_cancel(struct comedi_device *dev,
@@ -1188,7 +1163,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->subdev_flags	|= SDF_CMD_READ;
 		s->len_chanlist	= s->n_chan;
 		s->do_cmdtest	= ai_cmdtest;
-		s->do_cmd	= ai_cmd;
+		s->do_cmd	= pcl818_ai_cmd;
 		s->cancel	= pcl818_ai_cancel;
 	}
 

commit b8d17c4a5f88a3540905aab381a05cc964210343
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:21 2014 -0700

    staging: comedi: pcl818: absorb pcl818_ai_mode13dma_int()
    
    Absorb this function into pcl818_ai_cmd_mode() and simplify the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index d07d3606a02d..c4f9d54ca0a6 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -677,22 +677,6 @@ static irqreturn_t pcl818_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
-				    struct comedi_subdevice *s)
-{
-	unsigned int ctrl = 0;
-
-	pcl818_ai_setup_dma(dev, s);
-
-	ctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq) | PCL818_CTRL_DMAE;
-	if (mode == 1)
-		ctrl |= PCL818_CTRL_PACER_TRIG;
-	else
-		ctrl |= PCL818_CTRL_EXT_TRIG;
-
-	outb(ctrl, dev->iobase + PCL818_CTRL_REG);
-}
-
 static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 			      struct comedi_subdevice *s)
 {
@@ -722,28 +706,23 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 
 	outb(0, dev->iobase + PCL818_CNTENABLE);	/* enable pacer */
 
-	switch (devpriv->dma) {
-	case 1:		/*  DMA */
-	case 3:
-		pcl818_ai_mode13dma_int(mode, dev, s);
-		break;
-	case 0:
-		if (!devpriv->usefifo) {
-			ctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq);
-			if (mode == 1)
-				ctrl |= PCL818_CTRL_PACER_TRIG;
-			else
-				ctrl |= PCL818_CTRL_EXT_TRIG;
-		} else {
-			/* enable FIFO */
-			outb(1, dev->iobase + PCL818_FI_ENABLE);
-			if (mode == 1)
-				ctrl |= PCL818_CTRL_PACER_TRIG;
-			else
-				ctrl |= PCL818_CTRL_EXT_TRIG;
-		}
-		outb(ctrl, dev->iobase + PCL818_CTRL_REG);
+	if (mode == 1)
+		ctrl |= PCL818_CTRL_PACER_TRIG;
+	else
+		ctrl |= PCL818_CTRL_EXT_TRIG;
+
+	if (devpriv->dma) {
+		pcl818_ai_setup_dma(dev, s);
+
+		ctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq) |
+			PCL818_CTRL_DMAE;
+	} else if (devpriv->usefifo) {
+		/* enable FIFO */
+		outb(1, dev->iobase + PCL818_FI_ENABLE);
+	} else {
+		ctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq);
 	}
+	outb(ctrl, dev->iobase + PCL818_CTRL_REG);
 
 	pcl818_start_pacer(dev, mode == 1);
 

commit 5af366ffad65425b6b89b76c2c26e0100af07d1d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:20 2014 -0700

    staging: comedi: pcl818: define the mode register bits
    
    Define the bits in the register to remove the magic values.
    
    Tidy up pcl818_ai_cancel(). The 0x73 mask of the value read from
    the control register will disable dma and interrupts but it does
    not change the trigger mode. So the software trigger following it
    might not work.
    
    Just disable the trigger and clear any pending end-of-conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index b23457c5a881..d07d3606a02d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -119,8 +119,6 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define boardPCL818 4
 #define boardPCL718 5
 
-/* R/W: operation control register */
-#define PCL818_CONTROL 9
 /* W: counter enable */
 #define PCL818_CNTENABLE 10
 
@@ -138,6 +136,14 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define PCL818_STATUS_MUX			(1 << 5)
 #define PCL818_STATUS_UNI			(1 << 6)
 #define PCL818_STATUS_EOC			(1 << 7)
+#define PCL818_CTRL_REG				0x09
+#define PCL818_CTRL_DISABLE_TRIG		(0 << 0)
+#define PCL818_CTRL_SOFT_TRIG			(1 << 0)
+#define PCL818_CTRL_EXT_TRIG			(2 << 0)
+#define PCL818_CTRL_PACER_TRIG			(3 << 0)
+#define PCL818_CTRL_DMAE			(1 << 2)
+#define PCL818_CTRL_IRQ(x)			((x) << 4)
+#define PCL818_CTRL_INTE			(1 << 7)
 #define PCL818_DO_DI_MSB_REG			0x0b
 #define PCL818_TIMER_BASE			0x0c
 
@@ -674,12 +680,17 @@ static irqreturn_t pcl818_interrupt(int irq, void *d)
 static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
+	unsigned int ctrl = 0;
+
 	pcl818_ai_setup_dma(dev, s);
 
-	if (mode == 1)	/* Pacer+IRQ+DMA */
-		outb(0x87 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);
-	else		/* Ext trig+IRQ+DMA */
-		outb(0x86 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);
+	ctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq) | PCL818_CTRL_DMAE;
+	if (mode == 1)
+		ctrl |= PCL818_CTRL_PACER_TRIG;
+	else
+		ctrl |= PCL818_CTRL_EXT_TRIG;
+
+	outb(ctrl, dev->iobase + PCL818_CTRL_REG);
 }
 
 static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
@@ -687,6 +698,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 {
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int ctrl = 0;
 	unsigned int seglen;
 
 	if (devpriv->ai_cmd_running)
@@ -717,22 +729,20 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 		break;
 	case 0:
 		if (!devpriv->usefifo) {
-			/* IRQ */
-			if (mode == 1)	/* Pacer+IRQ */
-				outb(0x83 | (dev->irq << 4),
-				     dev->iobase + PCL818_CONTROL);
-			else		/* Ext trig+IRQ */
-				outb(0x82 | (dev->irq << 4),
-				     dev->iobase + PCL818_CONTROL);
+			ctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq);
+			if (mode == 1)
+				ctrl |= PCL818_CTRL_PACER_TRIG;
+			else
+				ctrl |= PCL818_CTRL_EXT_TRIG;
 		} else {
-			/* FIFO */
 			/* enable FIFO */
 			outb(1, dev->iobase + PCL818_FI_ENABLE);
-			if (mode == 1)	/* Pacer */
-				outb(0x03, dev->iobase + PCL818_CONTROL);
-			else		/* Ext trig */
-				outb(0x02, dev->iobase + PCL818_CONTROL);
+			if (mode == 1)
+				ctrl |= PCL818_CTRL_PACER_TRIG;
+			else
+				ctrl |= PCL818_CTRL_EXT_TRIG;
 		}
+		outb(ctrl, dev->iobase + PCL818_CTRL_REG);
 	}
 
 	pcl818_start_pacer(dev, mode == 1);
@@ -925,13 +935,8 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 		disable_dma(devpriv->dma);
 	}
 
-	outb(inb(dev->iobase + PCL818_CONTROL) & 0x73,
-	     dev->iobase + PCL818_CONTROL);	/* Stop A/D */
-	udelay(1);
+	outb(PCL818_CTRL_DISABLE_TRIG, dev->iobase + PCL818_CTRL_REG);
 	pcl818_start_pacer(dev, false);
-	pcl818_ai_soft_trig(dev);
-	pcl818_ai_get_sample(dev, s, NULL);
-	outb(0, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
 	pcl818_ai_clear_eoc(dev);
 
 	if (devpriv->usefifo) {	/*  FIFO shutdown */
@@ -955,8 +960,7 @@ static int pcl818_ai_insn_read(struct comedi_device *dev,
 	int ret = 0;
 	int i;
 
-	/* software trigger, DMA and INT off */
-	outb(0, dev->iobase + PCL818_CONTROL);
+	outb(PCL818_CTRL_SOFT_TRIG, dev->iobase + PCL818_CTRL_REG);
 
 	pcl818_ai_set_chan_range(dev, chan, range);
 	pcl818_ai_set_chan_scan(dev, chan, chan);
@@ -1055,7 +1059,7 @@ static void pcl818_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + PCL818_DO_DI_MSB_REG);
 	outb(0, dev->iobase + PCL818_DO_DI_LSB_REG);
 	udelay(1);
-	outb(0, dev->iobase + PCL818_CONTROL);
+	outb(PCL818_CTRL_DISABLE_TRIG, dev->iobase + PCL818_CTRL_REG);
 	outb(0, dev->iobase + PCL818_CNTENABLE);
 	outb(0, dev->iobase + PCL818_MUX_REG);
 	pcl818_ai_clear_eoc(dev);

commit 933ccd824d3bf099ae59f3ddf76f55f94b8bb22f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:17 2014 -0700

    staging: comedi: pcl818: cleanup setup_channel_list()
    
    Move this function to remove the need for the forward declaration. Rename it
    so it has namespace associated with the driver. Remove the unnecessary
    comedi_subdevice parameter from the function.
    
    The hardware has per-channel programmable gain. This function first sets the
    range for each channel then sets the mux register to automatically scan the
    channels.
    
    The use of 'muxonechan' when programming the ranges is incorrect. Only the low
    4-bits are supposed to be set when programming the ranges.
    
    Introduce a couple helper functions to set the range for a channel and to set
    the first/last channels to scan.
    
    Tidy up the range and mux register defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 3b87090808d6..b23457c5a881 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -119,10 +119,6 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define boardPCL818 4
 #define boardPCL718 5
 
-/* R: A/D high byte W: A/D range control */
-#define PCL818_RANGE 1
-/* R: next mux scan channel W: mux scan channel & range control pointer */
-#define PCL818_MUX 2
 /* R/W: operation control register */
 #define PCL818_CONTROL 9
 /* W: counter enable */
@@ -130,6 +126,9 @@ A word or two about DMA. Driver support DMA operations at two ways:
 
 #define PCL818_AI_LSB_REG			0x00
 #define PCL818_AI_MSB_REG			0x01
+#define PCL818_RANGE_REG			0x01
+#define PCL818_MUX_REG				0x02
+#define PCL818_MUX_SCAN(_first, _last)		(((_last) << 4) | (_first))
 #define PCL818_DO_DI_LSB_REG			0x03
 #define PCL818_AO_LSB_REG(x)			(0x04 + ((x) * 2))
 #define PCL818_AO_MSB_REG(x)			(0x05 + ((x) * 2))
@@ -317,14 +316,6 @@ struct pcl818_private {
 	unsigned int ai_cmd_canceled:1;
 };
 
-static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	/*  used for gain list programming */
-	0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
-};
-
-static void setup_channel_list(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       unsigned int *chanlist, unsigned int n_chan,
-			       unsigned int seglen);
 static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      unsigned int *chanlist, unsigned int n_chan);
@@ -399,6 +390,50 @@ static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
 	devpriv->dma_runs_to_end--;
 }
 
+static void pcl818_ai_set_chan_range(struct comedi_device *dev,
+				     unsigned int chan,
+				     unsigned int range)
+{
+	outb(chan, dev->iobase + PCL818_MUX_REG);
+	outb(range, dev->iobase + PCL818_RANGE_REG);
+}
+
+static void pcl818_ai_set_chan_scan(struct comedi_device *dev,
+				    unsigned int first_chan,
+				    unsigned int last_chan)
+{
+	outb(PCL818_MUX_SCAN(first_chan, last_chan),
+	     dev->iobase + PCL818_MUX_REG);
+}
+
+static void pcl818_ai_setup_chanlist(struct comedi_device *dev,
+				     unsigned int *chanlist,
+				     unsigned int seglen)
+{
+	struct pcl818_private *devpriv = dev->private;
+	unsigned int first_chan = CR_CHAN(chanlist[0]);
+	unsigned int last_chan;
+	unsigned int range;
+	int i;
+
+	devpriv->act_chanlist_len = seglen;
+	devpriv->act_chanlist_pos = 0;
+
+	/* store range list to card */
+	for (i = 0; i < seglen; i++) {
+		last_chan = CR_CHAN(chanlist[i]);
+		range = CR_RANGE(chanlist[i]);
+
+		devpriv->act_chanlist[i] = last_chan;
+
+		pcl818_ai_set_chan_range(dev, last_chan, range);
+	}
+
+	udelay(1);
+
+	pcl818_ai_set_chan_scan(dev, first_chan, last_chan);
+}
+
 static void pcl818_ai_clear_eoc(struct comedi_device *dev)
 {
 	/* writing any value clears the interrupt request */
@@ -662,7 +697,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	seglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);
 	if (seglen < 1)
 		return -EINVAL;
-	setup_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len, seglen);
+	pcl818_ai_setup_chanlist(dev, cmd->chanlist, seglen);
 
 	udelay(1);
 
@@ -760,31 +795,6 @@ static int check_channel_list(struct comedi_device *dev,
 	return seglen;
 }
 
-static void setup_channel_list(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       unsigned int *chanlist, unsigned int n_chan,
-			       unsigned int seglen)
-{
-	struct pcl818_private *devpriv = dev->private;
-	int i;
-
-	devpriv->act_chanlist_len = seglen;
-	devpriv->act_chanlist_pos = 0;
-
-	for (i = 0; i < seglen; i++) {	/*  store range list to card */
-		devpriv->act_chanlist[i] = CR_CHAN(chanlist[i]);
-		outb(muxonechan[CR_CHAN(chanlist[i])], dev->iobase + PCL818_MUX);	/* select channel */
-		outb(CR_RANGE(chanlist[i]), dev->iobase + PCL818_RANGE);	/* select gain */
-	}
-
-	udelay(1);
-
-	/* select channel interval to scan */
-	outb(devpriv->act_chanlist[0] | (devpriv->act_chanlist[seglen -
-							       1] << 4),
-	     dev->iobase + PCL818_MUX);
-}
-
 static int check_single_ended(unsigned int port)
 {
 	if (inb(port + PCL818_STATUS_REG) & PCL818_STATUS_MUX)
@@ -948,10 +958,8 @@ static int pcl818_ai_insn_read(struct comedi_device *dev,
 	/* software trigger, DMA and INT off */
 	outb(0, dev->iobase + PCL818_CONTROL);
 
-	/* select channel */
-	outb(muxonechan[chan], dev->iobase + PCL818_MUX);
-	/* select gain */
-	outb(range, dev->iobase + PCL818_RANGE);
+	pcl818_ai_set_chan_range(dev, chan, range);
+	pcl818_ai_set_chan_scan(dev, chan, chan);
 
 	for (i = 0; i < insn->n; i++) {
 		pcl818_ai_clear_eoc(dev);
@@ -1049,7 +1057,7 @@ static void pcl818_reset(struct comedi_device *dev)
 	udelay(1);
 	outb(0, dev->iobase + PCL818_CONTROL);
 	outb(0, dev->iobase + PCL818_CNTENABLE);
-	outb(0, dev->iobase + PCL818_MUX);
+	outb(0, dev->iobase + PCL818_MUX_REG);
 	pcl818_ai_clear_eoc(dev);
 
 	/* Stop pacer */
@@ -1058,7 +1066,7 @@ static void pcl818_reset(struct comedi_device *dev)
 	i8254_set_mode(timer_base, 0, 0, I8254_MODE0 | I8254_BINARY);
 
 	if (board->is_818) {
-		outb(0, dev->iobase + PCL818_RANGE);
+		outb(0, dev->iobase + PCL818_RANGE_REG);
 	} else {
 		/* set analog output channel 1 to 0V */
 		outb(0, dev->iobase + PCL818_AO_LSB_REG(1));

commit 8d0b5e15df78c56bd9ac34cfba80d644a3240511
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:12 2014 -0700

    staging: comedi: pcl818: define the status register bits
    
    Define the bits in the status register and remove the magic values.
    
    Writing any value to the status register clears any pending interrupt.
    For aesthetics, rename the status register and remove the "clrint"
    register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 4a8d9e1e195e..3b87090808d6 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -119,10 +119,6 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define boardPCL818 4
 #define boardPCL718 5
 
-/* W: clear INT request */
-#define PCL818_CLRINT 8
-/* R: return status byte */
-#define PCL818_STATUS 8
 /* R: A/D high byte W: A/D range control */
 #define PCL818_RANGE 1
 /* R: next mux scan channel W: mux scan channel & range control pointer */
@@ -134,9 +130,15 @@ A word or two about DMA. Driver support DMA operations at two ways:
 
 #define PCL818_AI_LSB_REG			0x00
 #define PCL818_AI_MSB_REG			0x01
+#define PCL818_DO_DI_LSB_REG			0x03
 #define PCL818_AO_LSB_REG(x)			(0x04 + ((x) * 2))
 #define PCL818_AO_MSB_REG(x)			(0x05 + ((x) * 2))
-#define PCL818_DO_DI_LSB_REG			0x03
+#define PCL818_STATUS_REG			0x08
+#define PCL818_STATUS_NEXT_CHAN_MASK		(0xf << 0)
+#define PCL818_STATUS_INT			(1 << 4)
+#define PCL818_STATUS_MUX			(1 << 5)
+#define PCL818_STATUS_UNI			(1 << 6)
+#define PCL818_STATUS_EOC			(1 << 7)
 #define PCL818_DO_DI_MSB_REG			0x0b
 #define PCL818_TIMER_BASE			0x0c
 
@@ -400,7 +402,7 @@ static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
 static void pcl818_ai_clear_eoc(struct comedi_device *dev)
 {
 	/* writing any value clears the interrupt request */
-	outb(0, dev->iobase + PCL818_CLRINT);
+	outb(0, dev->iobase + PCL818_STATUS_REG);
 }
 
 static void pcl818_ai_soft_trig(struct comedi_device *dev)
@@ -446,8 +448,8 @@ static int pcl818_ai_eoc(struct comedi_device *dev,
 {
 	unsigned int status;
 
-	status = inb(dev->iobase + PCL818_STATUS);
-	if (status & 0x10)
+	status = inb(dev->iobase + PCL818_STATUS_REG);
+	if (status & PCL818_STATUS_INT)
 		return 0;
 	return -EBUSY;
 }
@@ -785,7 +787,7 @@ static void setup_channel_list(struct comedi_device *dev,
 
 static int check_single_ended(unsigned int port)
 {
-	if (inb(port + PCL818_STATUS) & 0x20)
+	if (inb(port + PCL818_STATUS_REG) & PCL818_STATUS_MUX)
 		return 1;
 	return 0;
 }

commit 906a183ff06fd3eedba2d26f8bcc1ef78f9e56a5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:11 2014 -0700

    staging: comedi: pcl818: tidy up analog input registers
    
    For aesthetics, rename the analog input register defines and convert
    the offsets to hex.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 1783b6f6767e..4a8d9e1e195e 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -132,15 +132,12 @@ A word or two about DMA. Driver support DMA operations at two ways:
 /* W: counter enable */
 #define PCL818_CNTENABLE 10
 
-/* R: low byte of A/D W: soft A/D trigger */
-#define PCL818_AD_LO 0
-/* R: high byte of A/D W: A/D range control */
-#define PCL818_AD_HI 1
+#define PCL818_AI_LSB_REG			0x00
+#define PCL818_AI_MSB_REG			0x01
 #define PCL818_AO_LSB_REG(x)			(0x04 + ((x) * 2))
 #define PCL818_AO_MSB_REG(x)			(0x05 + ((x) * 2))
 #define PCL818_DO_DI_LSB_REG			0x03
 #define PCL818_DO_DI_MSB_REG			0x0b
-
 #define PCL818_TIMER_BASE			0x0c
 
 /* W: fifo enable/disable */
@@ -409,7 +406,7 @@ static void pcl818_ai_clear_eoc(struct comedi_device *dev)
 static void pcl818_ai_soft_trig(struct comedi_device *dev)
 {
 	/* writing any value triggers a software conversion */
-	outb(0, dev->iobase + PCL818_AD_LO);
+	outb(0, dev->iobase + PCL818_AI_LSB_REG);
 }
 
 static unsigned int pcl818_ai_get_fifo_sample(struct comedi_device *dev,
@@ -433,8 +430,8 @@ static unsigned int pcl818_ai_get_sample(struct comedi_device *dev,
 {
 	unsigned int val;
 
-	val = inb(dev->iobase + PCL818_AD_HI) << 8;
-	val |= inb(dev->iobase + PCL818_AD_LO);
+	val = inb(dev->iobase + PCL818_AI_MSB_REG) << 8;
+	val |= inb(dev->iobase + PCL818_AI_LSB_REG);
 
 	if (chan)
 		*chan = val & 0xf;

commit 9fdef9c84a8ca68ac48de4b778ec229744924041
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:06 2014 -0700

    staging: comedi: pcl818: introduce pcl818_ai_soft_trig()
    
    Introduce a helper function to start a software triggered analog input
    conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index d90c47db5da3..1783b6f6767e 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -406,6 +406,11 @@ static void pcl818_ai_clear_eoc(struct comedi_device *dev)
 	outb(0, dev->iobase + PCL818_CLRINT);
 }
 
+static void pcl818_ai_soft_trig(struct comedi_device *dev)
+{
+	/* writing any value triggers a software conversion */
+	outb(0, dev->iobase + PCL818_AD_LO);
+}
 
 static unsigned int pcl818_ai_get_fifo_sample(struct comedi_device *dev,
 					      struct comedi_subdevice *s,
@@ -915,7 +920,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	     dev->iobase + PCL818_CONTROL);	/* Stop A/D */
 	udelay(1);
 	pcl818_start_pacer(dev, false);
-	outb(0, dev->iobase + PCL818_AD_LO);
+	pcl818_ai_soft_trig(dev);
 	pcl818_ai_get_sample(dev, s, NULL);
 	outb(0, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
 	pcl818_ai_clear_eoc(dev);
@@ -951,8 +956,7 @@ static int pcl818_ai_insn_read(struct comedi_device *dev,
 
 	for (i = 0; i < insn->n; i++) {
 		pcl818_ai_clear_eoc(dev);
-		/* start conversion */
-		outb(0, dev->iobase + PCL818_AD_LO);
+		pcl818_ai_soft_trig(dev);
 
 		ret = comedi_timeout(dev, s, insn, pcl818_ai_eoc, 0);
 		if (ret)

commit 9fd3effaa7334f6061f4ad4b57665f375457d0eb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:05 2014 -0700

    staging: comedi: pcl818: introduce pcl818_ai_clear_eoc()
    
    Introduce a helper function to clear the end-of-conversion flag.
    
    This flag is set when an analog input conversion is finished and the
    hardware generates an interrupt request. Writing any value to the
    register resets the flag and re-enables the interrupt.
    
    Remove the clearing of the flag in pcl818_handle_eoc(). The interrupt
    function will handle clearing the flag.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 5eea4ebbb26d..d90c47db5da3 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -400,6 +400,13 @@ static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
 	devpriv->dma_runs_to_end--;
 }
 
+static void pcl818_ai_clear_eoc(struct comedi_device *dev)
+{
+	/* writing any value clears the interrupt request */
+	outb(0, dev->iobase + PCL818_CLRINT);
+}
+
+
 static unsigned int pcl818_ai_get_fifo_sample(struct comedi_device *dev,
 					      struct comedi_subdevice *s,
 					      unsigned int *chan)
@@ -500,7 +507,6 @@ static void pcl818_handle_eoc(struct comedi_device *dev,
 	unsigned int val;
 
 	if (pcl818_ai_eoc(dev, s, NULL, 0)) {
-		outb(0, dev->iobase + PCL818_STATUS);	/* clear INT request */
 		comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
 		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
@@ -508,7 +514,6 @@ static void pcl818_handle_eoc(struct comedi_device *dev,
 	}
 
 	val = pcl818_ai_get_sample(dev, s, &chan);
-	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
 	if (pcl818_ai_dropout(dev, s, chan))
 		return;
@@ -598,7 +603,7 @@ static irqreturn_t pcl818_interrupt(int irq, void *d)
 	struct comedi_subdevice *s = dev->read_subdev;
 
 	if (!dev->attached || !devpriv->ai_cmd_running) {
-		outb(0, dev->iobase + PCL818_CLRINT);
+		pcl818_ai_clear_eoc(dev);
 		return IRQ_HANDLED;
 	}
 
@@ -611,7 +616,6 @@ static irqreturn_t pcl818_interrupt(int irq, void *d)
 		 */
 		devpriv->ai_act_scan = 0;
 		s->cancel(dev, s);
-		outb(0, dev->iobase + PCL818_CLRINT);
 		return IRQ_HANDLED;
 	}
 
@@ -622,7 +626,7 @@ static irqreturn_t pcl818_interrupt(int irq, void *d)
 	else
 		pcl818_handle_eoc(dev, s);
 
-	outb(0, dev->iobase + PCL818_CLRINT);
+	pcl818_ai_clear_eoc(dev);
 
 	comedi_event(dev, s);
 	return IRQ_HANDLED;
@@ -913,8 +917,9 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	pcl818_start_pacer(dev, false);
 	outb(0, dev->iobase + PCL818_AD_LO);
 	pcl818_ai_get_sample(dev, s, NULL);
-	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 	outb(0, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
+	pcl818_ai_clear_eoc(dev);
+
 	if (devpriv->usefifo) {	/*  FIFO shutdown */
 		outb(0, dev->iobase + PCL818_FI_INTCLR);
 		outb(0, dev->iobase + PCL818_FI_FLUSH);
@@ -945,8 +950,7 @@ static int pcl818_ai_insn_read(struct comedi_device *dev,
 	outb(range, dev->iobase + PCL818_RANGE);
 
 	for (i = 0; i < insn->n; i++) {
-		/* clear INT (conversion end) flag */
-		outb(0, dev->iobase + PCL818_CLRINT);
+		pcl818_ai_clear_eoc(dev);
 		/* start conversion */
 		outb(0, dev->iobase + PCL818_AD_LO);
 
@@ -956,8 +960,7 @@ static int pcl818_ai_insn_read(struct comedi_device *dev,
 
 		data[i] = pcl818_ai_get_sample(dev, s, NULL);
 	}
-	/* clear INT (conversion end) flag */
-	outb(0, dev->iobase + PCL818_CLRINT);
+	pcl818_ai_clear_eoc(dev);
 
 	return ret ? ret : insn->n;
 }
@@ -1044,7 +1047,7 @@ static void pcl818_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + PCL818_CONTROL);
 	outb(0, dev->iobase + PCL818_CNTENABLE);
 	outb(0, dev->iobase + PCL818_MUX);
-	outb(0, dev->iobase + PCL818_CLRINT);
+	pcl818_ai_clear_eoc(dev);
 
 	/* Stop pacer */
 	i8254_set_mode(timer_base, 0, 2, I8254_MODE0 | I8254_BINARY);

commit 8916f5bcdf2fe4da0f7a83bc3533b307628ff3b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:00 2014 -0700

    staging: comedi: pcl818: tidy up the analog input (*insn_read)
    
    For aesthetics, move this function out of the async command support
    code.
    
    For safety, the INT request (end-of-conversion flag) should be cleared
    before doing each conversion and after the final data sample is read.
    This driver already clears the flag before starting a conversion but it
    does not clear the flag after the final sample.
    
    Refactor the function a bit so that the flag is cleared for a conversion
    timeout and after the last sample.
    
    Do a bit of other tidying up during the move.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 4918da352ac4..5eea4ebbb26d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -443,43 +443,6 @@ static int pcl818_ai_eoc(struct comedi_device *dev,
 	return -EBUSY;
 }
 
-static int pcl818_ai_insn_read(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
-{
-	int ret;
-	int n;
-
-	/* software trigger, DMA and INT off */
-	outb(0, dev->iobase + PCL818_CONTROL);
-
-	/* select channel */
-	outb(muxonechan[CR_CHAN(insn->chanspec)], dev->iobase + PCL818_MUX);
-
-	/* select gain */
-	outb(CR_RANGE(insn->chanspec), dev->iobase + PCL818_RANGE);
-
-	for (n = 0; n < insn->n; n++) {
-
-		/* clear INT (conversion end) flag */
-		outb(0, dev->iobase + PCL818_CLRINT);
-
-		/* start conversion */
-		outb(0, dev->iobase + PCL818_AD_LO);
-
-		ret = comedi_timeout(dev, s, insn, pcl818_ai_eoc, 0);
-		if (ret) {
-			/* clear INT (conversion end) flag */
-			outb(0, dev->iobase + PCL818_CLRINT);
-			return ret;
-		}
-
-		data[n] = pcl818_ai_get_sample(dev, s, NULL);
-	}
-
-	return n;
-}
-
 static bool pcl818_ai_dropout(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      unsigned int chan)
@@ -963,6 +926,42 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
+static int pcl818_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
+{
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
+	int ret = 0;
+	int i;
+
+	/* software trigger, DMA and INT off */
+	outb(0, dev->iobase + PCL818_CONTROL);
+
+	/* select channel */
+	outb(muxonechan[chan], dev->iobase + PCL818_MUX);
+	/* select gain */
+	outb(range, dev->iobase + PCL818_RANGE);
+
+	for (i = 0; i < insn->n; i++) {
+		/* clear INT (conversion end) flag */
+		outb(0, dev->iobase + PCL818_CLRINT);
+		/* start conversion */
+		outb(0, dev->iobase + PCL818_AD_LO);
+
+		ret = comedi_timeout(dev, s, insn, pcl818_ai_eoc, 0);
+		if (ret)
+			break;
+
+		data[i] = pcl818_ai_get_sample(dev, s, NULL);
+	}
+	/* clear INT (conversion end) flag */
+	outb(0, dev->iobase + PCL818_CLRINT);
+
+	return ret ? ret : insn->n;
+}
+
 static int pcl818_ao_insn_write(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn,

commit 9350557325b242cd2b5cd39f169c9cbaad0d2f3c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:59 2014 -0700

    staging: comedi: pcl818: tidy up the analog output subdevice
    
    For aesthetics, tidy up the analog output subdevice code.
    
    Change the regsiter map defines to simplify the code.
    
    Move the analog subdevice support functions out of the analog input
    support functions. Tidy them up a bit during the move.
    
    Reverse the logic of the subdevice init and add some whitespace.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index d22fb273a699..4918da352ac4 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -136,14 +136,10 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define PCL818_AD_LO 0
 /* R: high byte of A/D W: A/D range control */
 #define PCL818_AD_HI 1
-/* W: D/A low&high byte */
-#define PCL818_DA_LO 4
-#define PCL818_DA_HI 5
+#define PCL818_AO_LSB_REG(x)			(0x04 + ((x) * 2))
+#define PCL818_AO_MSB_REG(x)			(0x05 + ((x) * 2))
 #define PCL818_DO_DI_LSB_REG			0x03
 #define PCL818_DO_DI_MSB_REG			0x0b
-/* W: PCL718 second D/A */
-#define PCL718_DA2_LO 6
-#define PCL718_DA2_HI 7
 
 #define PCL818_TIMER_BASE			0x0c
 
@@ -484,39 +480,6 @@ static int pcl818_ai_insn_read(struct comedi_device *dev,
 	return n;
 }
 
-static int pcl818_ao_insn_read(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
-{
-	struct pcl818_private *devpriv = dev->private;
-	int n;
-	int chan = CR_CHAN(insn->chanspec);
-
-	for (n = 0; n < insn->n; n++)
-		data[n] = devpriv->ao_readback[chan];
-
-	return n;
-}
-
-static int pcl818_ao_insn_write(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
-{
-	struct pcl818_private *devpriv = dev->private;
-	int n;
-	int chan = CR_CHAN(insn->chanspec);
-
-	for (n = 0; n < insn->n; n++) {
-		devpriv->ao_readback[chan] = data[n];
-		outb((data[n] & 0x000f) << 4, dev->iobase +
-		     (chan ? PCL718_DA2_LO : PCL818_DA_LO));
-		outb((data[n] & 0x0ff0) >> 4, dev->iobase +
-		     (chan ? PCL718_DA2_HI : PCL818_DA_HI));
-	}
-
-	return n;
-}
-
 static bool pcl818_ai_dropout(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      unsigned int chan)
@@ -1000,6 +963,41 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
+static int pcl818_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
+{
+	struct pcl818_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int i;
+
+	for (i = 0; i < insn->n; i++) {
+		devpriv->ao_readback[chan] = data[i];
+		outb((data[i] & 0x000f) << 4,
+		     dev->iobase + PCL818_AO_LSB_REG(chan));
+		outb((data[i] & 0x0ff0) >> 4,
+		     dev->iobase + PCL818_AO_MSB_REG(chan));
+	}
+
+	return insn->n;
+}
+
+static int pcl818_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
+{
+	struct pcl818_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int i;
+
+	for (i = 0; i < insn->n; i++)
+		data[i] = devpriv->ao_readback[chan];
+
+	return insn->n;
+}
+
 static int pcl818_di_insn_bits(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn,
@@ -1037,8 +1035,9 @@ static void pcl818_reset(struct comedi_device *dev)
 		outb(0, dev->iobase + PCL818_FI_FLUSH);
 		outb(0, dev->iobase + PCL818_FI_ENABLE);
 	}
-	outb(0, dev->iobase + PCL818_DA_LO);	/*  DAC=0V */
-	outb(0, dev->iobase + PCL818_DA_HI);
+	/* set analog output channel 0 to 0V */
+	outb(0, dev->iobase + PCL818_AO_LSB_REG(0));
+	outb(0, dev->iobase + PCL818_AO_MSB_REG(0));
 	udelay(1);
 	outb(0, dev->iobase + PCL818_DO_DI_MSB_REG);
 	outb(0, dev->iobase + PCL818_DO_DI_LSB_REG);
@@ -1056,8 +1055,9 @@ static void pcl818_reset(struct comedi_device *dev)
 	if (board->is_818) {
 		outb(0, dev->iobase + PCL818_RANGE);
 	} else {
-		outb(0, dev->iobase + PCL718_DA2_LO);
-		outb(0, dev->iobase + PCL718_DA2_HI);
+		/* set analog output channel 1 to 0V */
+		outb(0, dev->iobase + PCL818_AO_LSB_REG(1));
+		outb(0, dev->iobase + PCL818_AO_MSB_REG(1));
 	}
 }
 
@@ -1196,17 +1196,16 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->cancel	= pcl818_ai_cancel;
 	}
 
+	/* Analog Output subdevice */
 	s = &dev->subdevices[1];
-	if (!board->n_aochan) {
-		s->type = COMEDI_SUBD_UNUSED;
-	} else {
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
-		s->n_chan = board->n_aochan;
-		s->maxdata = 0x0fff;
-		s->range_table = &range_unipolar5;
-		s->insn_read = pcl818_ao_insn_read;
-		s->insn_write = pcl818_ao_insn_write;
+	if (board->n_aochan) {
+		s->type		= COMEDI_SUBD_AO;
+		s->subdev_flags	= SDF_WRITABLE | SDF_GROUND;
+		s->n_chan	= board->n_aochan;
+		s->maxdata	= 0x0fff;
+		s->range_table	= &range_unipolar5;
+		s->insn_read	= pcl818_ao_insn_read;
+		s->insn_write	= pcl818_ao_insn_write;
 		if (board->is_818) {
 			if ((it->options[4] == 1) || (it->options[4] == 10))
 				s->range_table = &range_unipolar10;
@@ -1218,6 +1217,8 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			if (it->options[5] == 2)
 				s->range_table = &range_unknown;
 		}
+	} else {
+		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
 	/* Digital Input subdevice */

commit 4ab490b372e8d2fb14f5ecb78c3f87198b303f31
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:56 2014 -0700

    staging: comedi: pcl818: tidy up the digital subdevices
    
    For aesthetics, tidy up the digtial subdevice code.
    
    Rename the register map defines for the digital input and output ports.
    
    Move the two digital subdevice (*insn_bits) functions out of the analog
    support functions. Tidy them up a bit during the move.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 6db9c878a76d..d22fb273a699 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -139,12 +139,8 @@ A word or two about DMA. Driver support DMA operations at two ways:
 /* W: D/A low&high byte */
 #define PCL818_DA_LO 4
 #define PCL818_DA_HI 5
-/* R: low&high byte of DI */
-#define PCL818_DI_LO 3
-#define PCL818_DI_HI 11
-/* W: low&high byte of DO */
-#define PCL818_DO_LO 3
-#define PCL818_DO_HI 11
+#define PCL818_DO_DI_LSB_REG			0x03
+#define PCL818_DO_DI_MSB_REG			0x0b
 /* W: PCL718 second D/A */
 #define PCL718_DA2_LO 6
 #define PCL718_DA2_HI 7
@@ -521,31 +517,6 @@ static int pcl818_ao_insn_write(struct comedi_device *dev,
 	return n;
 }
 
-static int pcl818_di_insn_bits(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
-{
-	data[1] = inb(dev->iobase + PCL818_DI_LO) |
-	    (inb(dev->iobase + PCL818_DI_HI) << 8);
-
-	return insn->n;
-}
-
-static int pcl818_do_insn_bits(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn,
-			       unsigned int *data)
-{
-	if (comedi_dio_update_state(s, data)) {
-		outb(s->state & 0xff, dev->iobase + PCL818_DO_LO);
-		outb((s->state >> 8), dev->iobase + PCL818_DO_HI);
-	}
-
-	data[1] = s->state;
-
-	return insn->n;
-}
-
 static bool pcl818_ai_dropout(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      unsigned int chan)
@@ -1029,6 +1000,32 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
+static int pcl818_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
+{
+	data[1] = inb(dev->iobase + PCL818_DO_DI_LSB_REG) |
+		  (inb(dev->iobase + PCL818_DO_DI_MSB_REG) << 8);
+
+	return insn->n;
+}
+
+static int pcl818_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
+{
+	if (comedi_dio_update_state(s, data)) {
+		outb(s->state & 0xff, dev->iobase + PCL818_DO_DI_LSB_REG);
+		outb((s->state >> 8), dev->iobase + PCL818_DO_DI_MSB_REG);
+	}
+
+	data[1] = s->state;
+
+	return insn->n;
+}
+
 static void pcl818_reset(struct comedi_device *dev)
 {
 	const struct pcl818_board *board = comedi_board(dev);
@@ -1043,8 +1040,8 @@ static void pcl818_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + PCL818_DA_LO);	/*  DAC=0V */
 	outb(0, dev->iobase + PCL818_DA_HI);
 	udelay(1);
-	outb(0, dev->iobase + PCL818_DO_HI);	/*  DO=$0000 */
-	outb(0, dev->iobase + PCL818_DO_LO);
+	outb(0, dev->iobase + PCL818_DO_DI_MSB_REG);
+	outb(0, dev->iobase + PCL818_DO_DI_LSB_REG);
 	udelay(1);
 	outb(0, dev->iobase + PCL818_CONTROL);
 	outb(0, dev->iobase + PCL818_CNTENABLE);

commit e09469409c9ef6e4e2e37adb0a19796aaa04177b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:53 2014 -0700

    staging: comedi: pcl818: consolidate the common interrupt code
    
    The DMA, FIFO, and EOC interrupt handler functions, that are called by
    the _real_ interrupt function, always return IRQ_HANDLED. Change the
    return type for these functions to void and move the final return to
    the real interrupt function.
    
    Change the parameters to the handler functions to the comedi_device and
    comedi_subdevice pointers.
    
    At some point in the handler functions the interrupt request is cleared.
    Move this to the real interrupt function.
    
    Also at some point in the handlers, comedi_event() is called to pass any
    events to the comedi subsystem. Move this to the real interrupt function
    also.
    
    For aesthetics, and to clarify the code, rename the interrupt function and
    the handler functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 7c30bcf435d4..6db9c878a76d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -562,7 +562,6 @@ static bool pcl818_ai_dropout(struct comedi_device *dev,
 			chan, expected_chan);
 		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
-		comedi_event(dev, s);
 		return true;
 	}
 	return false;
@@ -591,17 +590,15 @@ static bool pcl818_ai_next_chan(struct comedi_device *dev,
 		/* all data sampled */
 		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA;
-		comedi_event(dev, s);
 		return false;
 	}
 
 	return true;
 }
 
-static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
+static void pcl818_handle_eoc(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
 {
-	struct comedi_device *dev = d;
-	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int chan;
 	unsigned int val;
 
@@ -610,30 +607,24 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 		comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
 		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
-		comedi_event(dev, s);
-		return IRQ_HANDLED;
+		return;
 	}
 
 	val = pcl818_ai_get_sample(dev, s, &chan);
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
 	if (pcl818_ai_dropout(dev, s, chan))
-		return IRQ_HANDLED;
+		return;
 
 	comedi_buf_put(s->async, val);
 
-	if (!pcl818_ai_next_chan(dev, s))
-		return IRQ_HANDLED;
-
-	comedi_event(dev, s);
-	return IRQ_HANDLED;
+	pcl818_ai_next_chan(dev, s);
 }
 
-static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
+static void pcl818_handle_dma(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
 {
-	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned short *ptr;
 	unsigned int chan;
 	unsigned int val;
@@ -641,7 +632,6 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 
 	pcl818_ai_setup_next_dma(dev, s);
 
-	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 	ptr = (unsigned short *)devpriv->dmabuf[1 - devpriv->next_dma_buf];
 
 	len = devpriv->hwdmasize >> 1;
@@ -653,46 +643,37 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 		val = (val >> 4) & s->maxdata;
 
 		if (pcl818_ai_dropout(dev, s, chan))
-			return IRQ_HANDLED;
+			break;
 
 		comedi_buf_put(s->async, val);
 
 		if (!pcl818_ai_next_chan(dev, s))
-			return IRQ_HANDLED;
+			break;
 	}
-
-	if (len > 0)
-		comedi_event(dev, s);
-	return IRQ_HANDLED;
 }
 
-static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
+static void pcl818_handle_fifo(struct comedi_device *dev,
+			       struct comedi_subdevice *s)
 {
-	struct comedi_device *dev = d;
-	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int status;
 	unsigned int chan;
 	unsigned int val;
 	int i, len;
 
-	outb(0, dev->iobase + PCL818_FI_INTCLR);	/*  clear fifo int request */
-
 	status = inb(dev->iobase + PCL818_FI_STATUS);
 
 	if (status & 4) {
 		comedi_error(dev, "A/D mode1/3 FIFO overflow!");
 		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
-		comedi_event(dev, s);
-		return IRQ_HANDLED;
+		return;
 	}
 
 	if (status & 1) {
 		comedi_error(dev, "A/D mode1/3 FIFO interrupt without data!");
 		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
-		comedi_event(dev, s);
-		return IRQ_HANDLED;
+		return;
 	}
 
 	if (status & 2)
@@ -704,20 +685,16 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 		val = pcl818_ai_get_fifo_sample(dev, s, &chan);
 
 		if (pcl818_ai_dropout(dev, s, chan))
-			return IRQ_HANDLED;
+			break;
 
 		comedi_buf_put(s->async, val);
 
 		if (!pcl818_ai_next_chan(dev, s))
-			return IRQ_HANDLED;
+			break;
 	}
-
-	if (len > 0)
-		comedi_event(dev, s);
-	return IRQ_HANDLED;
 }
 
-static irqreturn_t interrupt_pcl818(int irq, void *d)
+static irqreturn_t pcl818_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
@@ -737,16 +714,21 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 		 */
 		devpriv->ai_act_scan = 0;
 		s->cancel(dev, s);
-		outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
+		outb(0, dev->iobase + PCL818_CLRINT);
 		return IRQ_HANDLED;
 	}
 
 	if (devpriv->dma)
-		return interrupt_pcl818_ai_mode13_dma(irq, d);
+		pcl818_handle_dma(dev, s);
 	else if (devpriv->usefifo)
-		return interrupt_pcl818_ai_mode13_fifo(irq, d);
+		pcl818_handle_fifo(dev, s);
 	else
-		return interrupt_pcl818_ai_mode13_int(irq, d);
+		pcl818_handle_eoc(dev, s);
+
+	outb(0, dev->iobase + PCL818_CLRINT);
+
+	comedi_event(dev, s);
+	return IRQ_HANDLED;
 }
 
 static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
@@ -1152,7 +1134,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* we can use IRQ 2-7 for async command support */
 	if (it->options[1] >= 2 && it->options[1] <= 7) {
-		ret = request_irq(it->options[1], interrupt_pcl818, 0,
+		ret = request_irq(it->options[1], pcl818_interrupt, 0,
 				  dev->board_name, dev);
 		if (ret == 0)
 			dev->irq = it->options[1];

commit 799f89cee3525c495e90fe448619d5042f67cc35
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:50 2014 -0700

    staging: comedi: pcl818: remove 'ai_mode' from private data
    
    This member of the private data is not needed. We can determine the
    interrupt mode based on the 'dma' and 'usefifo' members.
    
    Refactor the interrupt handler and the (*cancel) function to not use
    the 'ai_mode' and remove the setting of this member in the (*do_cmd)
    heler functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index d00d6902c4a6..7c30bcf435d4 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -163,14 +163,6 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define PCL818_FI_DATALO 23
 #define PCL818_FI_DATAHI 24
 
-/* type of interrupt handler */
-#define INT_TYPE_AI1_INT 1
-#define INT_TYPE_AI1_DMA 2
-#define INT_TYPE_AI1_FIFO 3
-#define INT_TYPE_AI3_INT 4
-#define INT_TYPE_AI3_DMA 5
-#define INT_TYPE_AI3_FIFO 6
-
 #define MAGIC_DMA_WORD 0x5a5a
 
 static const struct comedi_lrange range_pcl818h_ai = {
@@ -320,7 +312,6 @@ struct pcl818_private {
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
 	unsigned int ns_min;	/*  manimal allowed delay between samples (in us) for actual card */
 	int i8253_osc_base;	/*  1/frequency of on board oscilator in ns */
-	int ai_mode;		/*  who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma */
 	int ai_act_scan;	/*  how many scans we finished */
 	int ai_act_chan;	/*  actual position in actual scan */
 	unsigned int act_chanlist[16];	/*  MUX setting for actual AI operations */
@@ -732,8 +723,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 
-	if (!dev->attached || !devpriv->ai_cmd_running ||
-	    !devpriv->ai_mode) {
+	if (!dev->attached || !devpriv->ai_cmd_running) {
 		outb(0, dev->iobase + PCL818_CLRINT);
 		return IRQ_HANDLED;
 	}
@@ -751,38 +741,23 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	switch (devpriv->ai_mode) {
-	case INT_TYPE_AI1_DMA:
-	case INT_TYPE_AI3_DMA:
+	if (devpriv->dma)
 		return interrupt_pcl818_ai_mode13_dma(irq, d);
-	case INT_TYPE_AI1_INT:
-	case INT_TYPE_AI3_INT:
-		return interrupt_pcl818_ai_mode13_int(irq, d);
-	case INT_TYPE_AI1_FIFO:
-	case INT_TYPE_AI3_FIFO:
+	else if (devpriv->usefifo)
 		return interrupt_pcl818_ai_mode13_fifo(irq, d);
-	default:
-		break;
-	}
-
-	outb(0, dev->iobase + PCL818_CLRINT);
-	return IRQ_HANDLED;
+	else
+		return interrupt_pcl818_ai_mode13_int(irq, d);
 }
 
 static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
-	struct pcl818_private *devpriv = dev->private;
-
 	pcl818_ai_setup_dma(dev, s);
 
-	if (mode == 1) {
-		devpriv->ai_mode = INT_TYPE_AI1_DMA;
-		outb(0x87 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Pacer+IRQ+DMA */
-	} else {
-		devpriv->ai_mode = INT_TYPE_AI3_DMA;
-		outb(0x86 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Ext trig+IRQ+DMA */
-	}
+	if (mode == 1)	/* Pacer+IRQ+DMA */
+		outb(0x87 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);
+	else		/* Ext trig+IRQ+DMA */
+		outb(0x86 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);
 }
 
 static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
@@ -821,29 +796,20 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	case 0:
 		if (!devpriv->usefifo) {
 			/* IRQ */
-			if (mode == 1) {
-				devpriv->ai_mode = INT_TYPE_AI1_INT;
-				/* Pacer+IRQ */
+			if (mode == 1)	/* Pacer+IRQ */
 				outb(0x83 | (dev->irq << 4),
 				     dev->iobase + PCL818_CONTROL);
-			} else {
-				devpriv->ai_mode = INT_TYPE_AI3_INT;
-				/* Ext trig+IRQ */
+			else		/* Ext trig+IRQ */
 				outb(0x82 | (dev->irq << 4),
 				     dev->iobase + PCL818_CONTROL);
-			}
 		} else {
 			/* FIFO */
 			/* enable FIFO */
 			outb(1, dev->iobase + PCL818_FI_ENABLE);
-			if (mode == 1) {
-				devpriv->ai_mode = INT_TYPE_AI1_FIFO;
-				/* Pacer */
+			if (mode == 1)	/* Pacer */
 				outb(0x03, dev->iobase + PCL818_CONTROL);
-			} else {
-				devpriv->ai_mode = INT_TYPE_AI3_FIFO;
+			else		/* Ext trig */
 				outb(0x02, dev->iobase + PCL818_CONTROL);
-			}
 		}
 	}
 
@@ -1047,9 +1013,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	if (!devpriv->ai_cmd_running)
 		return 0;
 
-	switch (devpriv->ai_mode) {
-	case INT_TYPE_AI1_DMA:
-	case INT_TYPE_AI3_DMA:
+	if (devpriv->dma) {
 		if (cmd->stop_src == TRIG_NONE ||
 		    (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan > 0)) {
 			if (!devpriv->ai_cmd_canceled) {
@@ -1062,29 +1026,24 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 			}
 		}
 		disable_dma(devpriv->dma);
-	case INT_TYPE_AI1_INT:
-	case INT_TYPE_AI3_INT:
-	case INT_TYPE_AI1_FIFO:
-	case INT_TYPE_AI3_FIFO:
-		outb(inb(dev->iobase + PCL818_CONTROL) & 0x73,
-		     dev->iobase + PCL818_CONTROL);	/* Stop A/D */
-		udelay(1);
-		pcl818_start_pacer(dev, false);
-		outb(0, dev->iobase + PCL818_AD_LO);
-		pcl818_ai_get_sample(dev, s, NULL);
-		outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
-		outb(0, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
-		if (devpriv->usefifo) {	/*  FIFO shutdown */
-			outb(0, dev->iobase + PCL818_FI_INTCLR);
-			outb(0, dev->iobase + PCL818_FI_FLUSH);
-			outb(0, dev->iobase + PCL818_FI_ENABLE);
-		}
-		devpriv->ai_cmd_running = 0;
-		devpriv->ai_mode = 0;
-		devpriv->ai_cmd_canceled = 0;
-		break;
 	}
 
+	outb(inb(dev->iobase + PCL818_CONTROL) & 0x73,
+	     dev->iobase + PCL818_CONTROL);	/* Stop A/D */
+	udelay(1);
+	pcl818_start_pacer(dev, false);
+	outb(0, dev->iobase + PCL818_AD_LO);
+	pcl818_ai_get_sample(dev, s, NULL);
+	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
+	outb(0, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
+	if (devpriv->usefifo) {	/*  FIFO shutdown */
+		outb(0, dev->iobase + PCL818_FI_INTCLR);
+		outb(0, dev->iobase + PCL818_FI_FLUSH);
+		outb(0, dev->iobase + PCL818_FI_ENABLE);
+	}
+	devpriv->ai_cmd_running = 0;
+	devpriv->ai_cmd_canceled = 0;
+
 	return 0;
 }
 

commit 10933a9cfa258048813fd8a287be844d30711731
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:48 2014 -0700

    staging: comedi: pcl818: exit interrupt quick when there is nothing to do
    
    If an async ai command is not running or the ai_mode is 0 the interrupt
    routine doesn't do anything other than spew some noise and clear the
    interrupt request in the hardware.
    
    Because this driver is manually attached, the "premature interrupt"
    check in the interrupt handler should never happen. The interrupt is
    only hooked up during the attach and it's released during the detach.
    
    Combine these checks so that the interrupt function exits quick if it
    has nothing to handle. Remove the noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 6c91a7b424d8..d00d6902c4a6 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -732,8 +732,9 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 
-	if (!dev->attached) {
-		comedi_error(dev, "premature interrupt");
+	if (!dev->attached || !devpriv->ai_cmd_running ||
+	    !devpriv->ai_mode) {
+		outb(0, dev->iobase + PCL818_CLRINT);
 		return IRQ_HANDLED;
 	}
 
@@ -764,15 +765,8 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 		break;
 	}
 
-	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
-
-	if (!devpriv->ai_cmd_running || !devpriv->ai_mode) {
-		comedi_error(dev, "bad IRQ!");
-		return IRQ_NONE;
-	}
-
-	comedi_error(dev, "IRQ from unknown source!");
-	return IRQ_NONE;
+	outb(0, dev->iobase + PCL818_CLRINT);
+	return IRQ_HANDLED;
 }
 
 static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,

commit 905a83211825d11716192043527ed7f84b0572a7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:45 2014 -0700

    staging: comedi: pcl818: fix (*cancel) when cmd->stop_src == TRIG_NONE
    
    When using DMA, the async command (*cancel) operation is delayed until the
    current DMA transfer is complete. When the DMA transfer finishes the interrupt
    routine detects this and calls the (*cancel) again which should then cancel the
    async command.
    
    The current logic does not work when cmd->stop_src == TRIG_NONE. In this case
    the (*cancel) function keeps delaying the cancel. The actual DMA does stop
    because the DMA handler is not called to setup the next transfer but the
    (*cancel) code is never executed.
    
    Rename the 'irq_was_now_closed' flag in the private data to 'ai_cmd_canceled'
    to clarify what it is.
    
    Only set the flag in the (*cancel) when a DMA transfer is running and the
    async command has not already been canceled. The interrupt routine then does
    not need all the extra checks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index c820df2aac45..6c91a7b424d8 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -332,7 +332,7 @@ struct pcl818_private {
 	unsigned int divisor2;
 	unsigned int usefifo:1;
 	unsigned int ai_cmd_running:1;
-	unsigned int irq_was_now_closed:1;
+	unsigned int ai_cmd_canceled:1;
 };
 
 static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	/*  used for gain list programming */
@@ -731,29 +731,22 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_cmd *cmd = &s->async->cmd;
 
 	if (!dev->attached) {
 		comedi_error(dev, "premature interrupt");
 		return IRQ_HANDLED;
 	}
 
-	if (devpriv->ai_cmd_running && devpriv->irq_was_now_closed) {
-		if ((cmd->stop_src == TRIG_NONE ||
-		    (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan > 0)) &&
-		    (devpriv->ai_mode == INT_TYPE_AI1_DMA ||
-		     devpriv->ai_mode == INT_TYPE_AI3_DMA)) {
-			/* The cleanup from ai_cancel() has been delayed
-			   until now because the card doesn't seem to like
-			   being reprogrammed while a DMA transfer is in
-			   progress.
-			 */
-			devpriv->ai_act_scan = 0;
-			s->cancel(dev, s);
-		}
-
+	if (devpriv->ai_cmd_canceled) {
+		/*
+		 * The cleanup from ai_cancel() has been delayed
+		 * until now because the card doesn't seem to like
+		 * being reprogrammed while a DMA transfer is in
+		 * progress.
+		 */
+		devpriv->ai_act_scan = 0;
+		s->cancel(dev, s);
 		outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
-
 		return IRQ_HANDLED;
 	}
 
@@ -820,7 +813,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	devpriv->ai_act_scan = cmd->stop_arg;
 	devpriv->ai_act_chan = 0;
 	devpriv->ai_cmd_running = 1;
-	devpriv->irq_was_now_closed = 0;
+	devpriv->ai_cmd_canceled = 0;
 	devpriv->act_chanlist_pos = 0;
 	devpriv->dma_runs_to_end = 0;
 
@@ -1065,12 +1058,14 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	case INT_TYPE_AI3_DMA:
 		if (cmd->stop_src == TRIG_NONE ||
 		    (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan > 0)) {
-			/*
-			 * Wait for running dma transfer to end,
-			 * do cleanup in interrupt.
-			 */
-			devpriv->irq_was_now_closed = 1;
-			return 0;
+			if (!devpriv->ai_cmd_canceled) {
+				/*
+				* Wait for running dma transfer to end,
+				* do cleanup in interrupt.
+				*/
+				devpriv->ai_cmd_canceled = 1;
+				return 0;
+			}
 		}
 		disable_dma(devpriv->dma);
 	case INT_TYPE_AI1_INT:
@@ -1092,7 +1087,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 		}
 		devpriv->ai_cmd_running = 0;
 		devpriv->ai_mode = 0;
-		devpriv->irq_was_now_closed = 0;
+		devpriv->ai_cmd_canceled = 0;
 		break;
 	}
 

commit 2850b1c74ef065368827776a612cb0d873a39d8e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:43 2014 -0700

    staging: comedi: pcl818: reduce indent level in pcl818_ai_cancel()
    
    If an async command is not running the (*cancel) function doesn't do
    anything. Exit the function early if this is the case.
    
    This allows reducing the indent level in the rest of the function.
    
    Also, move the setting of the 'irq_was_now_closed' to the only place
    wher it actually gets left set to 1 and remove the goto.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 745beddecdd4..c820df2aac45 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1057,42 +1057,45 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	if (devpriv->ai_cmd_running) {
-		devpriv->irq_was_now_closed = 1;
-
-		switch (devpriv->ai_mode) {
-		case INT_TYPE_AI1_DMA:
-		case INT_TYPE_AI3_DMA:
-			if (cmd->stop_src == TRIG_NONE ||
-			    (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan > 0)) {
-				/* wait for running dma transfer to end, do cleanup in interrupt */
-				goto end;
-			}
-			disable_dma(devpriv->dma);
-		case INT_TYPE_AI1_INT:
-		case INT_TYPE_AI3_INT:
-		case INT_TYPE_AI1_FIFO:
-		case INT_TYPE_AI3_FIFO:
-			outb(inb(dev->iobase + PCL818_CONTROL) & 0x73, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
-			udelay(1);
-			pcl818_start_pacer(dev, false);
-			outb(0, dev->iobase + PCL818_AD_LO);
-			pcl818_ai_get_sample(dev, s, NULL);
-			outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
-			outb(0, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
-			if (devpriv->usefifo) {	/*  FIFO shutdown */
-				outb(0, dev->iobase + PCL818_FI_INTCLR);
-				outb(0, dev->iobase + PCL818_FI_FLUSH);
-				outb(0, dev->iobase + PCL818_FI_ENABLE);
-			}
-			devpriv->ai_cmd_running = 0;
-			devpriv->ai_mode = 0;
-			devpriv->irq_was_now_closed = 0;
-			break;
+	if (!devpriv->ai_cmd_running)
+		return 0;
+
+	switch (devpriv->ai_mode) {
+	case INT_TYPE_AI1_DMA:
+	case INT_TYPE_AI3_DMA:
+		if (cmd->stop_src == TRIG_NONE ||
+		    (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan > 0)) {
+			/*
+			 * Wait for running dma transfer to end,
+			 * do cleanup in interrupt.
+			 */
+			devpriv->irq_was_now_closed = 1;
+			return 0;
 		}
+		disable_dma(devpriv->dma);
+	case INT_TYPE_AI1_INT:
+	case INT_TYPE_AI3_INT:
+	case INT_TYPE_AI1_FIFO:
+	case INT_TYPE_AI3_FIFO:
+		outb(inb(dev->iobase + PCL818_CONTROL) & 0x73,
+		     dev->iobase + PCL818_CONTROL);	/* Stop A/D */
+		udelay(1);
+		pcl818_start_pacer(dev, false);
+		outb(0, dev->iobase + PCL818_AD_LO);
+		pcl818_ai_get_sample(dev, s, NULL);
+		outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
+		outb(0, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
+		if (devpriv->usefifo) {	/*  FIFO shutdown */
+			outb(0, dev->iobase + PCL818_FI_INTCLR);
+			outb(0, dev->iobase + PCL818_FI_FLUSH);
+			outb(0, dev->iobase + PCL818_FI_ENABLE);
+		}
+		devpriv->ai_cmd_running = 0;
+		devpriv->ai_mode = 0;
+		devpriv->irq_was_now_closed = 0;
+		break;
 	}
 
-end:
 	return 0;
 }
 

commit a8f461c2b9df3c69f0ea995ce1fb506be50be409
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:41 2014 -0700

    staging: comedi: pcl818: factor out the common "dropout" detect code
    
    The DMA, FIFO, and EOC interrupt handlers all have common code that
    checks for channel dropout when running an async command.
    
    Factor this common code into a helper function.
    
    Only return the sample if the channel is valid. The EOC handler was
    previously returning the value then checking for channel dropout.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 53d1af253494..745beddecdd4 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -555,6 +555,28 @@ static int pcl818_do_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
+static bool pcl818_ai_dropout(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      unsigned int chan)
+{
+	struct pcl818_private *devpriv = dev->private;
+	unsigned int expected_chan;
+
+	expected_chan = devpriv->act_chanlist[devpriv->act_chanlist_pos];
+	if (chan != expected_chan) {
+		dev_dbg(dev->class_dev,
+			"A/D mode1/3 %s - channel dropout %d!=%d !\n",
+			(devpriv->dma) ? "DMA" :
+			(devpriv->usefifo) ? "FIFO" : "IRQ",
+			chan, expected_chan);
+		s->cancel(dev, s);
+		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		comedi_event(dev, s);
+		return true;
+	}
+	return false;
+}
+
 static bool pcl818_ai_next_chan(struct comedi_device *dev,
 				struct comedi_subdevice *s)
 {
@@ -588,9 +610,9 @@ static bool pcl818_ai_next_chan(struct comedi_device *dev,
 static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int chan;
+	unsigned int val;
 
 	if (pcl818_ai_eoc(dev, s, NULL, 0)) {
 		outb(0, dev->iobase + PCL818_STATUS);	/* clear INT request */
@@ -601,19 +623,13 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	comedi_buf_put(s->async, pcl818_ai_get_sample(dev, s, &chan));
+	val = pcl818_ai_get_sample(dev, s, &chan);
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
-	if (chan != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {
-		dev_dbg(dev->class_dev,
-			"A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
-			chan,
-			devpriv->act_chanlist[devpriv->act_chanlist_pos]);
-		s->cancel(dev, s);
-		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
-		comedi_event(dev, s);
+	if (pcl818_ai_dropout(dev, s, chan))
 		return IRQ_HANDLED;
-	}
+
+	comedi_buf_put(s->async, val);
 
 	if (!pcl818_ai_next_chan(dev, s))
 		return IRQ_HANDLED;
@@ -627,8 +643,10 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	int i, len, bufptr;
 	unsigned short *ptr;
+	unsigned int chan;
+	unsigned int val;
+	int i, len, bufptr;
 
 	pcl818_ai_setup_next_dma(dev, s);
 
@@ -639,19 +657,14 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 	bufptr = 0;
 
 	for (i = 0; i < len; i++) {
-		if ((ptr[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
-			dev_dbg(dev->class_dev,
-				"A/D mode1/3 DMA - channel dropout %d(card)!=%d(chanlist) at %d !\n",
-				(ptr[bufptr] & 0xf),
-				devpriv->act_chanlist[devpriv->act_chanlist_pos],
-				devpriv->act_chanlist_pos);
-			s->cancel(dev, s);
-			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
-			comedi_event(dev, s);
+		val = ptr[bufptr++];
+		chan = val & 0xf;
+		val = (val >> 4) & s->maxdata;
+
+		if (pcl818_ai_dropout(dev, s, chan))
 			return IRQ_HANDLED;
-		}
 
-		comedi_buf_put(s->async, ptr[bufptr++] >> 4);	/*  get one sample */
+		comedi_buf_put(s->async, val);
 
 		if (!pcl818_ai_next_chan(dev, s))
 			return IRQ_HANDLED;
@@ -665,7 +678,6 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int status;
 	unsigned int chan;
@@ -699,16 +711,9 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 
 	for (i = 0; i < len; i++) {
 		val = pcl818_ai_get_fifo_sample(dev, s, &chan);
-		if (chan != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {
-			dev_dbg(dev->class_dev,
-				"A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
-				chan,
-				devpriv->act_chanlist[devpriv->act_chanlist_pos]);
-			s->cancel(dev, s);
-			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
-			comedi_event(dev, s);
+
+		if (pcl818_ai_dropout(dev, s, chan))
 			return IRQ_HANDLED;
-		}
 
 		comedi_buf_put(s->async, val);
 

commit 4206e1be3d713672a255a877b48793ecbae4d2e4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:40 2014 -0700

    staging: comedi: pcl818: introduce pcl818_ai_get_fifo_sample()
    
    To clarify the code, introduce a helper function to read the analog
    input data sample from the FIFO and optionally return the channel
    that the sample was for. The channel is used to check for dropped
    samples.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index aff87924b03b..53d1af253494 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -417,6 +417,21 @@ static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
 	devpriv->dma_runs_to_end--;
 }
 
+static unsigned int pcl818_ai_get_fifo_sample(struct comedi_device *dev,
+					      struct comedi_subdevice *s,
+					      unsigned int *chan)
+{
+	unsigned int val;
+
+	val = inb(dev->iobase + PCL818_FI_DATALO);
+	val |= (inb(dev->iobase + PCL818_FI_DATAHI) << 8);
+
+	if (chan)
+		*chan = val & 0xf;
+
+	return (val >> 4) & s->maxdata;
+}
+
 static unsigned int pcl818_ai_get_sample(struct comedi_device *dev,
 					 struct comedi_subdevice *s,
 					 unsigned int *chan)
@@ -652,14 +667,16 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
+	unsigned int status;
+	unsigned int chan;
+	unsigned int val;
 	int i, len;
-	unsigned char lo;
 
 	outb(0, dev->iobase + PCL818_FI_INTCLR);	/*  clear fifo int request */
 
-	lo = inb(dev->iobase + PCL818_FI_STATUS);
+	status = inb(dev->iobase + PCL818_FI_STATUS);
 
-	if (lo & 4) {
+	if (status & 4) {
 		comedi_error(dev, "A/D mode1/3 FIFO overflow!");
 		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
@@ -667,7 +684,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	if (lo & 1) {
+	if (status & 1) {
 		comedi_error(dev, "A/D mode1/3 FIFO interrupt without data!");
 		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
@@ -675,17 +692,17 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	if (lo & 2)
+	if (status & 2)
 		len = 512;
 	else
 		len = 0;
 
 	for (i = 0; i < len; i++) {
-		lo = inb(dev->iobase + PCL818_FI_DATALO);
-		if ((lo & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
+		val = pcl818_ai_get_fifo_sample(dev, s, &chan);
+		if (chan != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {
 			dev_dbg(dev->class_dev,
 				"A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
-				(lo & 0xf),
+				chan,
 				devpriv->act_chanlist[devpriv->act_chanlist_pos]);
 			s->cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
@@ -693,7 +710,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 			return IRQ_HANDLED;
 		}
 
-		comedi_buf_put(s->async, (lo >> 4) | (inb(dev->iobase + PCL818_FI_DATAHI) << 4));	/*  get one sample */
+		comedi_buf_put(s->async, val);
 
 		if (!pcl818_ai_next_chan(dev, s))
 			return IRQ_HANDLED;

commit 61ef4719ea7cb3c019c5eefb73eb37390cb55db6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:39 2014 -0700

    staging: comedi: pcl818: fix PCL818_FI_DATAHI
    
    The A/D FIFO uses two registers to get each analog data sample.
    PCL818_FI_DATALO is the LSB of the data and PCL818_FI_DATAHI is
    the MSB of the data. The current define for PCL818_FI_DATAHI is
    incorrect and results in the LSB getting read twice.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 42448d22ac9f..aff87924b03b 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -161,7 +161,7 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define PCL818_FI_STATUS 25
 /* R: one record from FIFO */
 #define PCL818_FI_DATALO 23
-#define PCL818_FI_DATAHI 23
+#define PCL818_FI_DATAHI 24
 
 /* type of interrupt handler */
 #define INT_TYPE_AI1_INT 1

commit 6d5b78584f8fabfa8f359af1e44d64aba8264155
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:38 2014 -0700

    staging: comedi: pcl818: factor out the common "next ai chan" code
    
    The DMA, FIFO, and EOC interrupt handlers all have common code that
    bumps the counters in the private data that keep track of what channel
    is being sampled next and when all the data has been sampled.
    
    Factor this common code into a helper function.
    
    Make sure the COMEDI_CB_BLOCK event is set when advancing to the next
    channel so that when the comedi_event() is finally called the core will
    wake the async_queue to return the analog input data.
    
    Also, make sure the COMEDI_CB_EOS event is set at the completion of each
    scan.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 0167d7ee6d0d..42448d22ac9f 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -540,12 +540,41 @@ static int pcl818_do_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
+static bool pcl818_ai_next_chan(struct comedi_device *dev,
+				struct comedi_subdevice *s)
+{
+	struct pcl818_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+
+	s->async->events |= COMEDI_CB_BLOCK;
+
+	devpriv->act_chanlist_pos++;
+	if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)
+		devpriv->act_chanlist_pos = 0;
+
+	s->async->cur_chan++;
+	if (s->async->cur_chan >= cmd->chanlist_len) {
+		s->async->cur_chan = 0;
+		devpriv->ai_act_scan--;
+		s->async->events |= COMEDI_CB_EOS;
+	}
+
+	if (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan == 0) {
+		/* all data sampled */
+		s->cancel(dev, s);
+		s->async->events |= COMEDI_CB_EOA;
+		comedi_event(dev, s);
+		return false;
+	}
+
+	return true;
+}
+
 static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan;
 
 	if (pcl818_ai_eoc(dev, s, NULL, 0)) {
@@ -570,21 +599,10 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 		comedi_event(dev, s);
 		return IRQ_HANDLED;
 	}
-	devpriv->act_chanlist_pos++;
-	if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)
-		devpriv->act_chanlist_pos = 0;
 
-	s->async->cur_chan++;
-	if (s->async->cur_chan >= cmd->chanlist_len) {
-		s->async->cur_chan = 0;
-		devpriv->ai_act_scan--;
-	}
+	if (!pcl818_ai_next_chan(dev, s))
+		return IRQ_HANDLED;
 
-	if (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan == 0) {
-		/* all data sampled */
-		s->cancel(dev, s);
-		s->async->events |= COMEDI_CB_EOA;
-	}
 	comedi_event(dev, s);
 	return IRQ_HANDLED;
 }
@@ -594,7 +612,6 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_cmd *cmd = &s->async->cmd;
 	int i, len, bufptr;
 	unsigned short *ptr;
 
@@ -621,23 +638,8 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 
 		comedi_buf_put(s->async, ptr[bufptr++] >> 4);	/*  get one sample */
 
-		devpriv->act_chanlist_pos++;
-		if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)
-			devpriv->act_chanlist_pos = 0;
-
-		s->async->cur_chan++;
-		if (s->async->cur_chan >= cmd->chanlist_len) {
-			s->async->cur_chan = 0;
-			devpriv->ai_act_scan--;
-		}
-
-		if (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan == 0) {
-			/* all data sampled */
-			s->cancel(dev, s);
-			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(dev, s);
+		if (!pcl818_ai_next_chan(dev, s))
 			return IRQ_HANDLED;
-		}
 	}
 
 	if (len > 0)
@@ -650,7 +652,6 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_cmd *cmd = &s->async->cmd;
 	int i, len;
 	unsigned char lo;
 
@@ -694,23 +695,8 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 
 		comedi_buf_put(s->async, (lo >> 4) | (inb(dev->iobase + PCL818_FI_DATAHI) << 4));	/*  get one sample */
 
-		devpriv->act_chanlist_pos++;
-		if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)
-			devpriv->act_chanlist_pos = 0;
-
-		s->async->cur_chan++;
-		if (s->async->cur_chan >= cmd->chanlist_len) {
-			s->async->cur_chan = 0;
-			devpriv->ai_act_scan--;
-		}
-
-		if (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan == 0) {
-			/* all data sampled */
-			s->cancel(dev, s);
-			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(dev, s);
+		if (!pcl818_ai_next_chan(dev, s))
 			return IRQ_HANDLED;
-		}
 	}
 
 	if (len > 0)

commit 127005717dfc5bf42091a14e5a9736f52bfaea1c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:33 2014 -0700

    staging: comedi: pcl818: interrupt handlers should not busywait
    
    The interrupt is only generated by the hardware at the completion of
    an A/D conversion. Because of this the sanity check to make sure that
    the A/D conversion is complete and data is available is probably
    unnecessary but it doesn't hurt anything.
    
    The busywait loop is a different issue. Interrupt routines should not
    busywait. That's just mean...
    
    Remove the bustwait and use pcl818_ai_eoc() to check for the end-of-
    conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 661a907272bc..0167d7ee6d0d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -547,21 +547,16 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan;
-	int timeout = 50;	/* wait max 50us */
 
-	while (timeout--) {
-		if (inb(dev->iobase + PCL818_STATUS) & 0x10)
-			goto conv_finish;
-		udelay(1);
+	if (pcl818_ai_eoc(dev, s, NULL, 0)) {
+		outb(0, dev->iobase + PCL818_STATUS);	/* clear INT request */
+		comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
+		s->cancel(dev, s);
+		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		comedi_event(dev, s);
+		return IRQ_HANDLED;
 	}
-	outb(0, dev->iobase + PCL818_STATUS);	/* clear INT request */
-	comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
-	s->cancel(dev, s);
-	s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
-	comedi_event(dev, s);
-	return IRQ_HANDLED;
 
-conv_finish:
 	comedi_buf_put(s->async, pcl818_ai_get_sample(dev, s, &chan));
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 

commit ab72ef30da7341ab881dd7893a5d96766ca57d9f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:29 2014 -0700

    staging: comedi: pcl818: factor out dma setup to helper functions
    
    To assist in cleaning up the the rest of the driver, factor the initial
    dma setup and the next dma buffer setup into helper functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index ef3b577a8944..661a907272bc 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -362,6 +362,61 @@ static void pcl818_start_pacer(struct comedi_device *dev, bool load_counters)
 	}
 }
 
+static void pcl818_ai_setup_dma(struct comedi_device *dev,
+				struct comedi_subdevice *s)
+{
+	struct pcl818_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int flags;
+	unsigned int bytes;
+
+	disable_dma(devpriv->dma);	/*  disable dma */
+	bytes = devpriv->hwdmasize;
+	if (cmd->stop_src == TRIG_COUNT) {
+		bytes = cmd->chanlist_len * cmd->stop_arg * sizeof(short);
+		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;
+		devpriv->last_dma_run = bytes % devpriv->hwdmasize;
+		devpriv->dma_runs_to_end--;
+		if (devpriv->dma_runs_to_end >= 0)
+			bytes = devpriv->hwdmasize;
+	}
+
+	devpriv->next_dma_buf = 0;
+	set_dma_mode(devpriv->dma, DMA_MODE_READ);
+	flags = claim_dma_lock();
+	clear_dma_ff(devpriv->dma);
+	set_dma_addr(devpriv->dma, devpriv->hwdmaptr[0]);
+	set_dma_count(devpriv->dma, bytes);
+	release_dma_lock(flags);
+	enable_dma(devpriv->dma);
+}
+
+static void pcl818_ai_setup_next_dma(struct comedi_device *dev,
+				     struct comedi_subdevice *s)
+{
+	struct pcl818_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned long flags;
+
+	disable_dma(devpriv->dma);
+	devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
+	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
+		/* switch dma bufs */
+		set_dma_mode(devpriv->dma, DMA_MODE_READ);
+		flags = claim_dma_lock();
+		set_dma_addr(devpriv->dma,
+			     devpriv->hwdmaptr[devpriv->next_dma_buf]);
+		if (devpriv->dma_runs_to_end || cmd->stop_src == TRIG_NONE)
+			set_dma_count(devpriv->dma, devpriv->hwdmasize);
+		else
+			set_dma_count(devpriv->dma, devpriv->last_dma_run);
+		release_dma_lock(flags);
+		enable_dma(devpriv->dma);
+	}
+
+	devpriv->dma_runs_to_end--;
+}
+
 static unsigned int pcl818_ai_get_sample(struct comedi_device *dev,
 					 struct comedi_subdevice *s,
 					 unsigned int *chan)
@@ -546,26 +601,10 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int i, len, bufptr;
-	unsigned long flags;
 	unsigned short *ptr;
 
-	disable_dma(devpriv->dma);
-	devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
-	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
-		/* switch dma bufs */
-		set_dma_mode(devpriv->dma, DMA_MODE_READ);
-		flags = claim_dma_lock();
-		set_dma_addr(devpriv->dma,
-			     devpriv->hwdmaptr[devpriv->next_dma_buf]);
-		if (devpriv->dma_runs_to_end || cmd->stop_src == TRIG_NONE)
-			set_dma_count(devpriv->dma, devpriv->hwdmasize);
-		else
-			set_dma_count(devpriv->dma, devpriv->last_dma_run);
-		release_dma_lock(flags);
-		enable_dma(devpriv->dma);
-	}
+	pcl818_ai_setup_next_dma(dev, s);
 
-	devpriv->dma_runs_to_end--;
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 	ptr = (unsigned short *)devpriv->dmabuf[1 - devpriv->next_dma_buf];
 
@@ -744,29 +783,8 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
 	struct pcl818_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int flags;
-	unsigned int bytes;
-
-	disable_dma(devpriv->dma);	/*  disable dma */
-	bytes = devpriv->hwdmasize;
-	if (cmd->stop_src == TRIG_COUNT) {
-		bytes = cmd->chanlist_len * cmd->stop_arg * sizeof(short);
-		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;
-		devpriv->last_dma_run = bytes % devpriv->hwdmasize;
-		devpriv->dma_runs_to_end--;
-		if (devpriv->dma_runs_to_end >= 0)
-			bytes = devpriv->hwdmasize;
-	}
 
-	devpriv->next_dma_buf = 0;
-	set_dma_mode(devpriv->dma, DMA_MODE_READ);
-	flags = claim_dma_lock();
-	clear_dma_ff(devpriv->dma);
-	set_dma_addr(devpriv->dma, devpriv->hwdmaptr[0]);
-	set_dma_count(devpriv->dma, bytes);
-	release_dma_lock(flags);
-	enable_dma(devpriv->dma);
+	pcl818_ai_setup_dma(dev, s);
 
 	if (mode == 1) {
 		devpriv->ai_mode = INT_TYPE_AI1_DMA;

commit 00aba6e7b5653a6607238ecdab7172318059d984
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:26 2014 -0700

    staging: comedi: pcl818: remove 'neverending_ai' from private data
    
    This member of the private data is not needed. We can check the stop_src
    to determine this information:
    
      neverending_ai -> cmd->stop_src == TRIG_NONE
      !neverending_ai -> cmd->stop_src == TRIG_COUNT
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 226bee1c7a00..ef3b577a8944 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -333,7 +333,6 @@ struct pcl818_private {
 	unsigned int usefifo:1;
 	unsigned int ai_cmd_running:1;
 	unsigned int irq_was_now_closed:1;
-	unsigned int neverending_ai:1;
 };
 
 static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	/*  used for gain list programming */
@@ -531,11 +530,10 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 		devpriv->ai_act_scan--;
 	}
 
-	if (!devpriv->neverending_ai) {
-		if (devpriv->ai_act_scan == 0) {	/* all data sampled */
-			s->cancel(dev, s);
-			s->async->events |= COMEDI_CB_EOA;
-		}
+	if (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan == 0) {
+		/* all data sampled */
+		s->cancel(dev, s);
+		s->async->events |= COMEDI_CB_EOA;
 	}
 	comedi_event(dev, s);
 	return IRQ_HANDLED;
@@ -553,12 +551,13 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 
 	disable_dma(devpriv->dma);
 	devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
-	if ((devpriv->dma_runs_to_end) > -1 || devpriv->neverending_ai) {	/*  switch dma bufs */
+	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
+		/* switch dma bufs */
 		set_dma_mode(devpriv->dma, DMA_MODE_READ);
 		flags = claim_dma_lock();
 		set_dma_addr(devpriv->dma,
 			     devpriv->hwdmaptr[devpriv->next_dma_buf]);
-		if (devpriv->dma_runs_to_end || devpriv->neverending_ai)
+		if (devpriv->dma_runs_to_end || cmd->stop_src == TRIG_NONE)
 			set_dma_count(devpriv->dma, devpriv->hwdmasize);
 		else
 			set_dma_count(devpriv->dma, devpriv->last_dma_run);
@@ -598,13 +597,13 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 			devpriv->ai_act_scan--;
 		}
 
-		if (!devpriv->neverending_ai)
-			if (devpriv->ai_act_scan == 0) {	/* all data sampled */
-				s->cancel(dev, s);
-				s->async->events |= COMEDI_CB_EOA;
-				comedi_event(dev, s);
-				return IRQ_HANDLED;
-			}
+		if (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan == 0) {
+			/* all data sampled */
+			s->cancel(dev, s);
+			s->async->events |= COMEDI_CB_EOA;
+			comedi_event(dev, s);
+			return IRQ_HANDLED;
+		}
 	}
 
 	if (len > 0)
@@ -671,13 +670,13 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 			devpriv->ai_act_scan--;
 		}
 
-		if (!devpriv->neverending_ai)
-			if (devpriv->ai_act_scan == 0) {	/* all data sampled */
-				s->cancel(dev, s);
-				s->async->events |= COMEDI_CB_EOA;
-				comedi_event(dev, s);
-				return IRQ_HANDLED;
-			}
+		if (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan == 0) {
+			/* all data sampled */
+			s->cancel(dev, s);
+			s->async->events |= COMEDI_CB_EOA;
+			comedi_event(dev, s);
+			return IRQ_HANDLED;
+		}
 	}
 
 	if (len > 0)
@@ -690,6 +689,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
 	if (!dev->attached) {
 		comedi_error(dev, "premature interrupt");
@@ -697,8 +697,8 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 	}
 
 	if (devpriv->ai_cmd_running && devpriv->irq_was_now_closed) {
-		if ((devpriv->neverending_ai || (!devpriv->neverending_ai &&
-						 devpriv->ai_act_scan > 0)) &&
+		if ((cmd->stop_src == TRIG_NONE ||
+		    (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan > 0)) &&
 		    (devpriv->ai_mode == INT_TYPE_AI1_DMA ||
 		     devpriv->ai_mode == INT_TYPE_AI3_DMA)) {
 			/* The cleanup from ai_cancel() has been delayed
@@ -707,7 +707,6 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 			   progress.
 			 */
 			devpriv->ai_act_scan = 0;
-			devpriv->neverending_ai = 0;
 			s->cancel(dev, s);
 		}
 
@@ -751,7 +750,7 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 
 	disable_dma(devpriv->dma);	/*  disable dma */
 	bytes = devpriv->hwdmasize;
-	if (!devpriv->neverending_ai) {
+	if (cmd->stop_src == TRIG_COUNT) {
 		bytes = cmd->chanlist_len * cmd->stop_arg * sizeof(short);
 		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;
 		devpriv->last_dma_run = bytes % devpriv->hwdmasize;
@@ -1018,11 +1017,6 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	devpriv->ai_data_len = s->async->prealloc_bufsz;
 
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->neverending_ai = 0;
-	else
-		devpriv->neverending_ai = 1;
-
 	if (cmd->scan_begin_src == TRIG_FOLLOW) {	/*  mode 1, 3 */
 		if (cmd->convert_src == TRIG_TIMER) {	/*  mode 1 */
 			retval = pcl818_ai_cmd_mode(1, dev, s);
@@ -1040,6 +1034,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
 	struct pcl818_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
 	if (devpriv->ai_cmd_running) {
 		devpriv->irq_was_now_closed = 1;
@@ -1047,9 +1042,8 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 		switch (devpriv->ai_mode) {
 		case INT_TYPE_AI1_DMA:
 		case INT_TYPE_AI3_DMA:
-			if (devpriv->neverending_ai ||
-			    (!devpriv->neverending_ai &&
-			     devpriv->ai_act_scan > 0)) {
+			if (cmd->stop_src == TRIG_NONE ||
+			    (cmd->stop_src == TRIG_COUNT && devpriv->ai_act_scan > 0)) {
 				/* wait for running dma transfer to end, do cleanup in interrupt */
 				goto end;
 			}
@@ -1071,7 +1065,6 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 				outb(0, dev->iobase + PCL818_FI_ENABLE);
 			}
 			devpriv->ai_cmd_running = 0;
-			devpriv->neverending_ai = 0;
 			devpriv->ai_mode = 0;
 			devpriv->irq_was_now_closed = 0;
 			break;

commit 80cc64863aed80efdf89fcc9b30e7940683cb916
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:23 2014 -0700

    staging: comedi: pcl818: fix board resource region request
    
    Some of the PCL-818 compatible boards have a FIFO that can be used
    when running analog input async commands. This FIFO increased the
    resource range used by the driver.
    
    Request the correct resources used by the board even if the FIFO is
    not used. This prevents another driver from trying to use the I/O
    space.
    
    Modify the attach so that the 'usefifo' flag is only set if we have
    and IRQ, the board has a FIFO, and the user wahts to use it.
    
    Fix pcl818_reset() so that the FIFO is always flushed and disabled
    if it exists.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index c9f141243c8e..226bee1c7a00 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1085,10 +1085,10 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 static void pcl818_reset(struct comedi_device *dev)
 {
 	const struct pcl818_board *board = comedi_board(dev);
-	struct pcl818_private *devpriv = dev->private;
 	unsigned long timer_base = dev->iobase + PCL818_TIMER_BASE;
 
-	if (devpriv->usefifo) {	/*  FIFO shutdown */
+	/* flush and disable the FIFO */
+	if (board->has_fifo) {
 		outb(0, dev->iobase + PCL818_FI_INTCLR);
 		outb(0, dev->iobase + PCL818_FI_FLUSH);
 		outb(0, dev->iobase + PCL818_FI_ENABLE);
@@ -1180,12 +1180,8 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!devpriv)
 		return -ENOMEM;
 
-	/* should we use the FIFO? */
-	if (board->has_fifo && it->options[2] == -1)
-		devpriv->usefifo = 1;
-
 	ret = comedi_request_region(dev, it->options[0],
-				    devpriv->usefifo ? 0x20 : 0x10);
+				    board->has_fifo ? 0x20 : 0x10);
 	if (ret)
 		return ret;
 
@@ -1197,6 +1193,10 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			dev->irq = it->options[1];
 	}
 
+	/* should we use the FIFO? */
+	if (dev->irq && board->has_fifo && it->options[2] == -1)
+		devpriv->usefifo = 1;
+
 	/* we need an IRQ to do DMA on channel 3 or 1 */
 	if (dev->irq && board->has_dma &&
 	    (it->options[2] == 3 || it->options[2] == 1)) {

commit 569d138fc4a08e36b48b818ea007675629eb46b5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:22 2014 -0700

    staging: comedi: pcl818: remove pcl818_check()
    
    This function is a _very_ simplified probe that tried to verify that
    the driver is being attached to a PCL-818 compatible board. The function
    simply writes some values to specific registers then reads back the
    values to see if they are the same.
    
    It's possible that the user could try to attach this driver to a non-
    compatible board but the check would still pass depending on the register
    map of the board.
    
    Just remove the buggy function to simplify the attach a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 861f51976fd7..c9f141243c8e 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1168,30 +1168,6 @@ static void pcl818_set_ai_range_table(struct comedi_device *dev,
 	}
 }
 
-static int pcl818_check(struct comedi_device *dev)
-{
-	/* the MUX register should return the same value written */
-	outb(0x00, dev->iobase + PCL818_MUX);
-	if (inb(dev->iobase + PCL818_MUX) != 0x00)
-		return -ENODEV;
-	outb(0x55, dev->iobase + PCL818_MUX);
-	if (inb(dev->iobase + PCL818_MUX) != 0x55)
-		return -ENODEV;
-
-	/* reset the MUX register to a known state */
-	outb(0x00, dev->iobase + PCL818_MUX);
-
-	/* the CONTROL register should return the same value written */
-	outb(0x18, dev->iobase + PCL818_CONTROL);
-	if (inb(dev->iobase + PCL818_CONTROL) != 0x18)
-		return -ENODEV;
-
-	/* reset the CONTROL register to a known state */
-	outb(0x00, dev->iobase + PCL818_CONTROL);
-
-	return 0;
-}
-
 static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl818_board *board = comedi_board(dev);
@@ -1213,10 +1189,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	ret = pcl818_check(dev);
-	if (ret)
-		return ret;
-
 	/* we can use IRQ 2-7 for async command support */
 	if (it->options[1] >= 2 && it->options[1] <= 7) {
 		ret = request_irq(it->options[1], interrupt_pcl818, 0,

commit 53693d9068735ccb4a2c304f60c88e168895029d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:28:01 2014 -0700

    staging: comedi: pcl818: kzalloc'ed memory does not need to be cleared
    
    The private data is kzalloc'ed in the (*attach). There is no need to
    initialize and the members to 0.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 56a5de712e87..861f51976fd7 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1225,8 +1225,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			dev->irq = it->options[1];
 	}
 
-	devpriv->ai_mode = 0;	/* mode of irq */
-
 	/* we need an IRQ to do DMA on channel 3 or 1 */
 	if (dev->irq && board->has_dma &&
 	    (it->options[2] == 3 || it->options[2] == 1)) {

commit 243e7146c8ed16cbda71126168fe73acab7c62d2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:57 2014 -0700

    staging: comedi: pcl818: tidy up pcl818_check()
    
    This function probes a number of the boards registers during the
    (*attach) to verify that it is actually a PCL-818 compatible board.
    For aesthetics, move the function closer to the (*attach).
    
    Refactor the function to return an errno if fails. Change the errno
    from -EIO to -ENODEV and remove the unnecessary comedi_error() noise.
    
    Make sure the CONTROL register is reset to a known state after the
    check. The 0x18 value actually defines an invalid interrupt selection
    and sets an undefined bit.
    
    Add a couple comments to clarify the magic values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 65101970f99e..56a5de712e87 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1082,25 +1082,6 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static int pcl818_check(unsigned long iobase)
-{
-	outb(0x00, iobase + PCL818_MUX);
-	udelay(1);
-	if (inb(iobase + PCL818_MUX) != 0x00)
-		return 1;	/* there isn't card */
-	outb(0x55, iobase + PCL818_MUX);
-	udelay(1);
-	if (inb(iobase + PCL818_MUX) != 0x55)
-		return 1;	/* there isn't card */
-	outb(0x00, iobase + PCL818_MUX);
-	udelay(1);
-	outb(0x18, iobase + PCL818_CONTROL);
-	udelay(1);
-	if (inb(iobase + PCL818_CONTROL) != 0x18)
-		return 1;	/* there isn't card */
-	return 0;		/*  ok, card exist */
-}
-
 static void pcl818_reset(struct comedi_device *dev)
 {
 	const struct pcl818_board *board = comedi_board(dev);
@@ -1187,6 +1168,30 @@ static void pcl818_set_ai_range_table(struct comedi_device *dev,
 	}
 }
 
+static int pcl818_check(struct comedi_device *dev)
+{
+	/* the MUX register should return the same value written */
+	outb(0x00, dev->iobase + PCL818_MUX);
+	if (inb(dev->iobase + PCL818_MUX) != 0x00)
+		return -ENODEV;
+	outb(0x55, dev->iobase + PCL818_MUX);
+	if (inb(dev->iobase + PCL818_MUX) != 0x55)
+		return -ENODEV;
+
+	/* reset the MUX register to a known state */
+	outb(0x00, dev->iobase + PCL818_MUX);
+
+	/* the CONTROL register should return the same value written */
+	outb(0x18, dev->iobase + PCL818_CONTROL);
+	if (inb(dev->iobase + PCL818_CONTROL) != 0x18)
+		return -ENODEV;
+
+	/* reset the CONTROL register to a known state */
+	outb(0x00, dev->iobase + PCL818_CONTROL);
+
+	return 0;
+}
+
 static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl818_board *board = comedi_board(dev);
@@ -1208,10 +1213,9 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	if (pcl818_check(dev->iobase)) {
-		comedi_error(dev, "I can't detect board. FAIL!\n");
-		return -EIO;
-	}
+	ret = pcl818_check(dev);
+	if (ret)
+		return ret;
 
 	/* we can use IRQ 2-7 for async command support */
 	if (it->options[1] >= 2 && it->options[1] <= 7) {

commit 18c7a6df49d6a1b8d1d59b86bec0ee76e63b44b5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:56 2014 -0700

    staging: comedi: pcl818: remove unnecessary function separation comments
    
    These comments are just added cruft. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 2b2e7e698b91..65101970f99e 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -340,9 +340,6 @@ static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0
 	0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
 };
 
-/*
-==============================================================================
-*/
 static void setup_channel_list(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       unsigned int *chanlist, unsigned int n_chan,
@@ -431,11 +428,6 @@ static int pcl818_ai_insn_read(struct comedi_device *dev,
 	return n;
 }
 
-/*
-==============================================================================
-   ANALOG OUTPUT MODE0, 818 cards
-   only one sample per call is supported
-*/
 static int pcl818_ao_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
@@ -469,12 +461,6 @@ static int pcl818_ao_insn_write(struct comedi_device *dev,
 	return n;
 }
 
-/*
-==============================================================================
-   DIGITAL INPUT MODE0, 818 cards
-
-   only one sample per call is supported
-*/
 static int pcl818_di_insn_bits(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
@@ -500,11 +486,6 @@ static int pcl818_do_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-/*
-==============================================================================
-   analog input interrupt mode 1 & 3, 818 cards
-   one sample per interrupt version
-*/
 static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -560,10 +541,6 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-/*
-==============================================================================
-   analog input dma mode 1 & 3, 818 cards
-*/
 static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -635,10 +612,6 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-/*
-==============================================================================
-   analog input interrupt mode 1 & 3, 818HD/HG cards
-*/
 static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -712,10 +685,6 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-/*
-==============================================================================
-    INT procedure
-*/
 static irqreturn_t interrupt_pcl818(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -772,10 +741,6 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 	return IRQ_NONE;
 }
 
-/*
-==============================================================================
-   ANALOG INPUT MODE 1 or 3 DMA , 818 cards
-*/
 static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
@@ -813,10 +778,6 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 	}
 }
 
-/*
-==============================================================================
-   ANALOG INPUT MODE 1 or 3, 818 cards
-*/
 static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 			      struct comedi_subdevice *s)
 {
@@ -884,11 +845,6 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	return 0;
 }
 
-/*
-==============================================================================
- Check if channel list from user is builded correctly
- If it's ok, then program scan/gain logic
-*/
 static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      unsigned int *chanlist, unsigned int n_chan)
@@ -969,10 +925,6 @@ static void setup_channel_list(struct comedi_device *dev,
 	     dev->iobase + PCL818_MUX);
 }
 
-/*
-==============================================================================
- Check if board is switched to SE (1) or DIFF(0) mode
-*/
 static int check_single_ended(unsigned int port)
 {
 	if (inb(port + PCL818_STATUS) & 0x20)
@@ -980,9 +932,6 @@ static int check_single_ended(unsigned int port)
 	return 0;
 }
 
-/*
-==============================================================================
-*/
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
@@ -1061,9 +1010,6 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	return 0;
 }
 
-/*
-==============================================================================
-*/
 static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pcl818_private *devpriv = dev->private;
@@ -1090,10 +1036,6 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return -1;
 }
 
-/*
-==============================================================================
- cancel any mode 1-4 AI
-*/
 static int pcl818_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
@@ -1140,10 +1082,6 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-/*
-==============================================================================
- chech for PCL818
-*/
 static int pcl818_check(unsigned long iobase)
 {
 	outb(0x00, iobase + PCL818_MUX);
@@ -1163,10 +1101,6 @@ static int pcl818_check(unsigned long iobase)
 	return 0;		/*  ok, card exist */
 }
 
-/*
-==============================================================================
- reset whole PCL-818 cards
-*/
 static void pcl818_reset(struct comedi_device *dev)
 {
 	const struct pcl818_board *board = comedi_board(dev);

commit c8bc43ec67cd113892c5eb9dd22d3bf35fb38662
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:52 2014 -0700

    staging: comedi: pcl818: rename 'irq_blocked' in private data
    
    This member in the private data is a flag that indicates that an analog
    input async command is currently running. Rename it to make this clear.
    
    The private data is kzalloc'ed in the attach so remove the unnecessary
    clearing of this flag.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 8be7cb99708d..2b2e7e698b91 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -331,7 +331,7 @@ struct pcl818_private {
 	unsigned int divisor1;
 	unsigned int divisor2;
 	unsigned int usefifo:1;
-	unsigned int irq_blocked:1;
+	unsigned int ai_cmd_running:1;
 	unsigned int irq_was_now_closed:1;
 	unsigned int neverending_ai:1;
 };
@@ -727,7 +727,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	if (devpriv->irq_blocked && devpriv->irq_was_now_closed) {
+	if (devpriv->ai_cmd_running && devpriv->irq_was_now_closed) {
 		if ((devpriv->neverending_ai || (!devpriv->neverending_ai &&
 						 devpriv->ai_act_scan > 0)) &&
 		    (devpriv->ai_mode == INT_TYPE_AI1_DMA ||
@@ -763,7 +763,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
-	if (!devpriv->irq_blocked || !devpriv->ai_mode) {
+	if (!devpriv->ai_cmd_running || !devpriv->ai_mode) {
 		comedi_error(dev, "bad IRQ!");
 		return IRQ_NONE;
 	}
@@ -824,7 +824,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int seglen;
 
-	if (devpriv->irq_blocked)
+	if (devpriv->ai_cmd_running)
 		return -EBUSY;
 
 	pcl818_start_pacer(dev, false);
@@ -838,7 +838,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 
 	devpriv->ai_act_scan = cmd->stop_arg;
 	devpriv->ai_act_chan = 0;
-	devpriv->irq_blocked = 1;
+	devpriv->ai_cmd_running = 1;
 	devpriv->irq_was_now_closed = 0;
 	devpriv->act_chanlist_pos = 0;
 	devpriv->dma_runs_to_end = 0;
@@ -1099,7 +1099,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 {
 	struct pcl818_private *devpriv = dev->private;
 
-	if (devpriv->irq_blocked > 0) {
+	if (devpriv->ai_cmd_running) {
 		devpriv->irq_was_now_closed = 1;
 
 		switch (devpriv->ai_mode) {
@@ -1128,7 +1128,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 				outb(0, dev->iobase + PCL818_FI_FLUSH);
 				outb(0, dev->iobase + PCL818_FI_ENABLE);
 			}
-			devpriv->irq_blocked = 0;
+			devpriv->ai_cmd_running = 0;
 			devpriv->neverending_ai = 0;
 			devpriv->ai_mode = 0;
 			devpriv->irq_was_now_closed = 0;
@@ -1287,7 +1287,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			dev->irq = it->options[1];
 	}
 
-	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
 	devpriv->ai_mode = 0;	/* mode of irq */
 
 	/* we need an IRQ to do DMA on channel 3 or 1 */

commit e5143adb18a90346d9f24229188f054853410998
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:50 2014 -0700

    staging: comedi: pcl818: convert private data flags to bit-fields
    
    Convert the flags in the private data to bit-fields to save a bit of
    space.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 4da0062f894a..8be7cb99708d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -318,11 +318,8 @@ struct pcl818_private {
 	int next_dma_buf;	/*  which DMA buffer will be used next round */
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
-	unsigned char neverending_ai;	/*  if=1, then we do neverending record (you must use cancel()) */
 	unsigned int ns_min;	/*  manimal allowed delay between samples (in us) for actual card */
 	int i8253_osc_base;	/*  1/frequency of on board oscilator in ns */
-	int irq_blocked;	/*  1=IRQ now uses any subdev */
-	int irq_was_now_closed;	/*  when IRQ finish, there's stored int818_mode for last interrupt */
 	int ai_mode;		/*  who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma */
 	int ai_act_scan;	/*  how many scans we finished */
 	int ai_act_chan;	/*  actual position in actual scan */
@@ -330,10 +327,13 @@ struct pcl818_private {
 	unsigned int act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
 	unsigned int ai_data_len;	/*  len of data buffer */
-	unsigned char usefifo;	/*  1=use fifo */
 	unsigned int ao_readback[2];
 	unsigned int divisor1;
 	unsigned int divisor2;
+	unsigned int usefifo:1;
+	unsigned int irq_blocked:1;
+	unsigned int irq_was_now_closed:1;
+	unsigned int neverending_ai:1;
 };
 
 static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	/*  used for gain list programming */

commit 1784f30556a60b3692140e946f8338ce21035814
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:46 2014 -0700

    staging: comedi: pcl818: remove 'ai_chanlist' from private data
    
    This member of the private data is just a pointer to the cmd->chanlist.
    Use that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 874b9f24a65b..4da0062f894a 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -329,7 +329,6 @@ struct pcl818_private {
 	unsigned int act_chanlist[16];	/*  MUX setting for actual AI operations */
 	unsigned int act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
-	unsigned int *ai_chanlist;	/*  actaul chanlist */
 	unsigned int ai_data_len;	/*  len of data buffer */
 	unsigned char usefifo;	/*  1=use fifo */
 	unsigned int ao_readback[2];
@@ -830,12 +829,10 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 
 	pcl818_start_pacer(dev, false);
 
-	seglen = check_channel_list(dev, s, devpriv->ai_chanlist,
-				    cmd->chanlist_len);
+	seglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);
 	if (seglen < 1)
 		return -EINVAL;
-	setup_channel_list(dev, s, devpriv->ai_chanlist,
-			   cmd->chanlist_len, seglen);
+	setup_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len, seglen);
 
 	udelay(1);
 
@@ -1073,7 +1070,6 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
 
-	devpriv->ai_chanlist = cmd->chanlist;
 	devpriv->ai_data_len = s->async->prealloc_bufsz;
 
 	if (cmd->stop_src == TRIG_COUNT)

commit 7b822d011be55d1dec906fd857a5fdeef6e308ee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:44 2014 -0700

    staging: comedi: pcl818: remove 'ai_timer[12]' from private data
    
    These members of the private data are set but never used. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 4b1506a4b68a..874b9f24a65b 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -331,8 +331,6 @@ struct pcl818_private {
 	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
 	unsigned int *ai_chanlist;	/*  actaul chanlist */
 	unsigned int ai_data_len;	/*  len of data buffer */
-	unsigned int ai_timer1;	/*  timers */
-	unsigned int ai_timer2;
 	unsigned char usefifo;	/*  1=use fifo */
 	unsigned int ao_readback[2];
 	unsigned int divisor1;
@@ -1077,8 +1075,6 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	devpriv->ai_chanlist = cmd->chanlist;
 	devpriv->ai_data_len = s->async->prealloc_bufsz;
-	devpriv->ai_timer1 = 0;
-	devpriv->ai_timer2 = 0;
 
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->neverending_ai = 0;
@@ -1087,7 +1083,6 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW) {	/*  mode 1, 3 */
 		if (cmd->convert_src == TRIG_TIMER) {	/*  mode 1 */
-			devpriv->ai_timer1 = cmd->convert_arg;
 			retval = pcl818_ai_cmd_mode(1, dev, s);
 			return retval;
 		}

commit 00f921c7b9d380a39f3d46a262321a7350404196
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:43 2014 -0700

    staging: comedi: pcl818: remove analog output interrupt code
    
    The hardware does not have any analog output interrupt support. Remove the
    stubbed in code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 47c87fb3eeff..4b1506a4b68a 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -110,8 +110,6 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #include "comedi_fc.h"
 #include "8253.h"
 
-/* #define PCL818_MODE13_AO 1 */
-
 /* boards constants */
 
 #define boardPCL818L 0
@@ -172,10 +170,6 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define INT_TYPE_AI3_INT 4
 #define INT_TYPE_AI3_DMA 5
 #define INT_TYPE_AI3_FIFO 6
-#ifdef PCL818_MODE13_AO
-#define INT_TYPE_AO1_INT 7
-#define INT_TYPE_AO3_INT 8
-#endif
 
 #define MAGIC_DMA_WORD 0x5a5a
 
@@ -766,11 +760,6 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 	case INT_TYPE_AI1_FIFO:
 	case INT_TYPE_AI3_FIFO:
 		return interrupt_pcl818_ai_mode13_fifo(irq, d);
-#ifdef PCL818_MODE13_AO
-	case INT_TYPE_AO1_INT:
-	case INT_TYPE_AO3_INT:
-		return interrupt_pcl818_ao_mode13_int(irq, d);
-#endif
 	default:
 		break;
 	}
@@ -1136,10 +1125,6 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 		case INT_TYPE_AI3_INT:
 		case INT_TYPE_AI1_FIFO:
 		case INT_TYPE_AI3_FIFO:
-#ifdef PCL818_MODE13_AO
-		case INT_TYPE_AO1_INT:
-		case INT_TYPE_AO3_INT:
-#endif
 			outb(inb(dev->iobase + PCL818_CONTROL) & 0x73, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
 			udelay(1);
 			pcl818_start_pacer(dev, false);

commit 6c42119d3d9d0f73017bbde7db6a11d10876805e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:42 2014 -0700

    staging: comedi: pcl818: use subdevice (*cancel)
    
    Use the subdevice (*cancel) operation to remove the need for a forward
    declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index f8fe04cdb059..47c87fb3eeff 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -360,9 +360,6 @@ static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      unsigned int *chanlist, unsigned int n_chan);
 
-static int pcl818_ai_cancel(struct comedi_device *dev,
-			    struct comedi_subdevice *s);
-
 static void pcl818_start_pacer(struct comedi_device *dev, bool load_counters)
 {
 	struct pcl818_private *devpriv = dev->private;
@@ -533,7 +530,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 	}
 	outb(0, dev->iobase + PCL818_STATUS);	/* clear INT request */
 	comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
-	pcl818_ai_cancel(dev, s);
+	s->cancel(dev, s);
 	s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	comedi_event(dev, s);
 	return IRQ_HANDLED;
@@ -547,7 +544,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 			"A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
 			chan,
 			devpriv->act_chanlist[devpriv->act_chanlist_pos]);
-		pcl818_ai_cancel(dev, s);
+		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		comedi_event(dev, s);
 		return IRQ_HANDLED;
@@ -564,7 +561,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 
 	if (!devpriv->neverending_ai) {
 		if (devpriv->ai_act_scan == 0) {	/* all data sampled */
-			pcl818_ai_cancel(dev, s);
+			s->cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA;
 		}
 	}
@@ -615,7 +612,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 				(ptr[bufptr] & 0xf),
 				devpriv->act_chanlist[devpriv->act_chanlist_pos],
 				devpriv->act_chanlist_pos);
-			pcl818_ai_cancel(dev, s);
+			s->cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			comedi_event(dev, s);
 			return IRQ_HANDLED;
@@ -635,7 +632,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 
 		if (!devpriv->neverending_ai)
 			if (devpriv->ai_act_scan == 0) {	/* all data sampled */
-				pcl818_ai_cancel(dev, s);
+				s->cancel(dev, s);
 				s->async->events |= COMEDI_CB_EOA;
 				comedi_event(dev, s);
 				return IRQ_HANDLED;
@@ -666,7 +663,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 
 	if (lo & 4) {
 		comedi_error(dev, "A/D mode1/3 FIFO overflow!");
-		pcl818_ai_cancel(dev, s);
+		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		comedi_event(dev, s);
 		return IRQ_HANDLED;
@@ -674,7 +671,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 
 	if (lo & 1) {
 		comedi_error(dev, "A/D mode1/3 FIFO interrupt without data!");
-		pcl818_ai_cancel(dev, s);
+		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		comedi_event(dev, s);
 		return IRQ_HANDLED;
@@ -692,7 +689,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 				"A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
 				(lo & 0xf),
 				devpriv->act_chanlist[devpriv->act_chanlist_pos]);
-			pcl818_ai_cancel(dev, s);
+			s->cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			comedi_event(dev, s);
 			return IRQ_HANDLED;
@@ -712,7 +709,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 
 		if (!devpriv->neverending_ai)
 			if (devpriv->ai_act_scan == 0) {	/* all data sampled */
-				pcl818_ai_cancel(dev, s);
+				s->cancel(dev, s);
 				s->async->events |= COMEDI_CB_EOA;
 				comedi_event(dev, s);
 				return IRQ_HANDLED;
@@ -732,6 +729,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->read_subdev;
 
 	if (!dev->attached) {
 		comedi_error(dev, "premature interrupt");
@@ -750,7 +748,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 			 */
 			devpriv->ai_act_scan = 0;
 			devpriv->neverending_ai = 0;
-			pcl818_ai_cancel(dev, dev->read_subdev);
+			s->cancel(dev, s);
 		}
 
 		outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */

commit f4985a79ca5ba6a2eb0edeb3125a7e763c3e6cc2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:39 2014 -0700

    staging: comedi: pcl818: don't calc the timer divisors twice
    
    The timer divisors are calculated in the (*do_cmdtest) before the (*do_cmd)
    is called by the comedi core. The extra sanity checks in the (*do_cmd) are
    not necessary, the values returned from i8253_cascade_ns_to_timer() will be
    greater than 1. Save the values in the private data so they don't need to be
    recalced.
    
    Refactor pcl818_start_pacer() to use the values from the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 2f62a49b369d..f8fe04cdb059 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -341,6 +341,8 @@ struct pcl818_private {
 	unsigned int ai_timer2;
 	unsigned char usefifo;	/*  1=use fifo */
 	unsigned int ao_readback[2];
+	unsigned int divisor1;
+	unsigned int divisor2;
 };
 
 static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	/*  used for gain list programming */
@@ -361,9 +363,9 @@ static int check_channel_list(struct comedi_device *dev,
 static int pcl818_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s);
 
-static void pcl818_start_pacer(struct comedi_device *dev, bool load_counters,
-			       unsigned int divisor1, unsigned int divisor2)
+static void pcl818_start_pacer(struct comedi_device *dev, bool load_counters)
 {
+	struct pcl818_private *devpriv = dev->private;
 	unsigned long timer_base = dev->iobase + PCL818_TIMER_BASE;
 
 	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
@@ -371,8 +373,8 @@ static void pcl818_start_pacer(struct comedi_device *dev, bool load_counters,
 	udelay(1);
 
 	if (load_counters) {
-		i8254_write(timer_base, 0, 2, divisor2);
-		i8254_write(timer_base, 0, 1, divisor1);
+		i8254_write(timer_base, 0, 2, devpriv->divisor2);
+		i8254_write(timer_base, 0, 1, devpriv->divisor1);
 	}
 }
 
@@ -836,13 +838,12 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 {
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	int divisor1 = 0, divisor2 = 0;
 	unsigned int seglen;
 
 	if (devpriv->irq_blocked)
 		return -EBUSY;
 
-	pcl818_start_pacer(dev, false, 0, 0);
+	pcl818_start_pacer(dev, false);
 
 	seglen = check_channel_list(dev, s, devpriv->ai_chanlist,
 				    cmd->chanlist_len);
@@ -860,21 +861,6 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	devpriv->act_chanlist_pos = 0;
 	devpriv->dma_runs_to_end = 0;
 
-	if (mode == 1) {
-		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base,
-					  &divisor1, &divisor2,
-					  &cmd->convert_arg,
-					  TRIG_ROUND_NEAREST);
-		if (divisor1 == 1) {	/* PCL718/818 crash if any divisor is set to 1 */
-			divisor1 = 2;
-			divisor2 /= 2;
-		}
-		if (divisor2 == 1) {
-			divisor2 = 2;
-			divisor1 /= 2;
-		}
-	}
-
 	outb(0, dev->iobase + PCL818_CNTENABLE);	/* enable pacer */
 
 	switch (devpriv->dma) {
@@ -911,7 +897,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 		}
 	}
 
-	pcl818_start_pacer(dev, mode == 1, divisor1, divisor2);
+	pcl818_start_pacer(dev, mode == 1);
 
 	return 0;
 }
@@ -1021,7 +1007,7 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	const struct pcl818_board *board = comedi_board(dev);
 	struct pcl818_private *devpriv = dev->private;
 	int err = 0;
-	int tmp, divisor1 = 0, divisor2 = 0;
+	int tmp;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -1070,7 +1056,8 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base,
-					  &divisor1, &divisor2,
+					  &devpriv->divisor1,
+					  &devpriv->divisor2,
 					  &cmd->convert_arg, cmd->flags);
 		if (cmd->convert_arg < board->ns_min)
 			cmd->convert_arg = board->ns_min;
@@ -1157,7 +1144,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 #endif
 			outb(inb(dev->iobase + PCL818_CONTROL) & 0x73, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
 			udelay(1);
-			pcl818_start_pacer(dev, false, 0, 0);
+			pcl818_start_pacer(dev, false);
 			outb(0, dev->iobase + PCL818_AD_LO);
 			pcl818_ai_get_sample(dev, s, NULL);
 			outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */

commit 833b458a01eea7f4f0e5f1721141d5ad992da95c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:35 2014 -0700

    staging: comedi: pcl818: use 8253.h helpers
    
    Use the helper functions in 8253.h to clarify the timer programming.
    
    Move start_pacer() to remove the need for the forward declarations.
    Rename the function so it has namespace associated with the driver.
    
    Change the 'mode' parameter. This parameter is really a flag to the
    function indicating if the divisors should be loaded into the timers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 0ac07a90192a..2f62a49b369d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -150,12 +150,8 @@ A word or two about DMA. Driver support DMA operations at two ways:
 /* W: PCL718 second D/A */
 #define PCL718_DA2_LO 6
 #define PCL718_DA2_HI 7
-/* counters */
-#define PCL818_CTR0 12
-#define PCL818_CTR1 13
-#define PCL818_CTR2 14
-/* W: counter control */
-#define PCL818_CTRCTL 15
+
+#define PCL818_TIMER_BASE			0x0c
 
 /* W: fifo enable/disable */
 #define PCL818_FI_ENABLE 6
@@ -364,8 +360,21 @@ static int check_channel_list(struct comedi_device *dev,
 
 static int pcl818_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s);
-static void start_pacer(struct comedi_device *dev, int mode,
-			unsigned int divisor1, unsigned int divisor2);
+
+static void pcl818_start_pacer(struct comedi_device *dev, bool load_counters,
+			       unsigned int divisor1, unsigned int divisor2)
+{
+	unsigned long timer_base = dev->iobase + PCL818_TIMER_BASE;
+
+	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
+	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
+	udelay(1);
+
+	if (load_counters) {
+		i8254_write(timer_base, 0, 2, divisor2);
+		i8254_write(timer_base, 0, 1, divisor1);
+	}
+}
 
 static unsigned int pcl818_ai_get_sample(struct comedi_device *dev,
 					 struct comedi_subdevice *s,
@@ -833,7 +842,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	if (devpriv->irq_blocked)
 		return -EBUSY;
 
-	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
+	pcl818_start_pacer(dev, false, 0, 0);
 
 	seglen = check_channel_list(dev, s, devpriv->ai_chanlist,
 				    cmd->chanlist_len);
@@ -902,30 +911,11 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 		}
 	}
 
-	start_pacer(dev, mode, divisor1, divisor2);
+	pcl818_start_pacer(dev, mode == 1, divisor1, divisor2);
 
 	return 0;
 }
 
-/*
-==============================================================================
- Start/stop pacer onboard pacer
-*/
-static void start_pacer(struct comedi_device *dev, int mode,
-			unsigned int divisor1, unsigned int divisor2)
-{
-	outb(0xb4, dev->iobase + PCL818_CTRCTL);
-	outb(0x74, dev->iobase + PCL818_CTRCTL);
-	udelay(1);
-
-	if (mode == 1) {
-		outb(divisor2 & 0xff, dev->iobase + PCL818_CTR2);
-		outb((divisor2 >> 8) & 0xff, dev->iobase + PCL818_CTR2);
-		outb(divisor1 & 0xff, dev->iobase + PCL818_CTR1);
-		outb((divisor1 >> 8) & 0xff, dev->iobase + PCL818_CTR1);
-	}
-}
-
 /*
 ==============================================================================
  Check if channel list from user is builded correctly
@@ -1167,7 +1157,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 #endif
 			outb(inb(dev->iobase + PCL818_CONTROL) & 0x73, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
 			udelay(1);
-			start_pacer(dev, -1, 0, 0);
+			pcl818_start_pacer(dev, false, 0, 0);
 			outb(0, dev->iobase + PCL818_AD_LO);
 			pcl818_ai_get_sample(dev, s, NULL);
 			outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
@@ -1220,6 +1210,7 @@ static void pcl818_reset(struct comedi_device *dev)
 {
 	const struct pcl818_board *board = comedi_board(dev);
 	struct pcl818_private *devpriv = dev->private;
+	unsigned long timer_base = dev->iobase + PCL818_TIMER_BASE;
 
 	if (devpriv->usefifo) {	/*  FIFO shutdown */
 		outb(0, dev->iobase + PCL818_FI_INTCLR);
@@ -1236,9 +1227,12 @@ static void pcl818_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + PCL818_CNTENABLE);
 	outb(0, dev->iobase + PCL818_MUX);
 	outb(0, dev->iobase + PCL818_CLRINT);
-	outb(0xb0, dev->iobase + PCL818_CTRCTL);	/* Stop pacer */
-	outb(0x70, dev->iobase + PCL818_CTRCTL);
-	outb(0x30, dev->iobase + PCL818_CTRCTL);
+
+	/* Stop pacer */
+	i8254_set_mode(timer_base, 0, 2, I8254_MODE0 | I8254_BINARY);
+	i8254_set_mode(timer_base, 0, 1, I8254_MODE0 | I8254_BINARY);
+	i8254_set_mode(timer_base, 0, 0, I8254_MODE0 | I8254_BINARY);
+
 	if (board->is_818) {
 		outb(0, dev->iobase + PCL818_RANGE);
 	} else {

commit da7c36a51e072aac6d2a799fe32f3dbbfa8737be
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:32 2014 -0700

    staging: comedi: pcl818: remove 'last_int_sub' from private data
    
    THis member of the private data is set but never used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index e2629087d097..0ac07a90192a 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -334,7 +334,6 @@ struct pcl818_private {
 	int irq_blocked;	/*  1=IRQ now uses any subdev */
 	int irq_was_now_closed;	/*  when IRQ finish, there's stored int818_mode for last interrupt */
 	int ai_mode;		/*  who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma */
-	struct comedi_subdevice *last_int_sub;	/*  ptr to subdevice which now finish */
 	int ai_act_scan;	/*  how many scans we finished */
 	int ai_act_chan;	/*  actual position in actual scan */
 	unsigned int act_chanlist[16];	/*  MUX setting for actual AI operations */
@@ -1179,7 +1178,6 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 				outb(0, dev->iobase + PCL818_FI_ENABLE);
 			}
 			devpriv->irq_blocked = 0;
-			devpriv->last_int_sub = s;
 			devpriv->neverending_ai = 0;
 			devpriv->ai_mode = 0;
 			devpriv->irq_was_now_closed = 0;

commit f5cc425afed63820734f130fc245ba7bb11c11ac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:30 2014 -0700

    staging: comedi: pcl818: tidy up dma buffer allocation
    
    This driver uses 2 buffers for DMA. Refactor the buffer allocation to
    use a for loop to remove code duplication. Remove the dev_err() messages
    when __get_dma_pages() fails and change the errno returned from -EBUSY
    to -ENOMEM.
    
    Both buffers are the same size so replace the 'dmapages' and 'hwdmasize'
    arrays in the private data with variables to save a bit of space.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index dcc397cf45bb..e2629087d097 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -320,12 +320,11 @@ static const struct pcl818_board boardtypes[] = {
 };
 
 struct pcl818_private {
-
 	unsigned int dma;	/*  used DMA, 0=don't use DMA */
+	unsigned int dmapages;
+	unsigned int hwdmasize;
 	unsigned long dmabuf[2];	/*  pointers to begin of DMA buffers */
-	unsigned int dmapages[2];	/*  len of DMA buffers in PAGE_SIZEs */
 	unsigned int hwdmaptr[2];	/*  hardware address of DMA buffers */
-	unsigned int hwdmasize[2];	/*  len of DMA buffers in Bytes */
 	int next_dma_buf;	/*  which DMA buffer will be used next round */
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
@@ -584,13 +583,10 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 		flags = claim_dma_lock();
 		set_dma_addr(devpriv->dma,
 			     devpriv->hwdmaptr[devpriv->next_dma_buf]);
-		if (devpriv->dma_runs_to_end || devpriv->neverending_ai) {
-			set_dma_count(devpriv->dma,
-				      devpriv->hwdmasize[devpriv->
-							 next_dma_buf]);
-		} else {
+		if (devpriv->dma_runs_to_end || devpriv->neverending_ai)
+			set_dma_count(devpriv->dma, devpriv->hwdmasize);
+		else
 			set_dma_count(devpriv->dma, devpriv->last_dma_run);
-		}
 		release_dma_lock(flags);
 		enable_dma(devpriv->dma);
 	}
@@ -599,7 +595,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 	ptr = (unsigned short *)devpriv->dmabuf[1 - devpriv->next_dma_buf];
 
-	len = devpriv->hwdmasize[0] >> 1;
+	len = devpriv->hwdmasize >> 1;
 	bufptr = 0;
 
 	for (i = 0; i < len; i++) {
@@ -795,14 +791,14 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 	unsigned int bytes;
 
 	disable_dma(devpriv->dma);	/*  disable dma */
-	bytes = devpriv->hwdmasize[0];
+	bytes = devpriv->hwdmasize;
 	if (!devpriv->neverending_ai) {
-		bytes = cmd->chanlist_len * cmd->stop_arg * sizeof(short);	/*  how many */
-		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize[0];	/*  how many DMA pages we must fiil */
-		devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];	/* on last dma transfer must be moved */
+		bytes = cmd->chanlist_len * cmd->stop_arg * sizeof(short);
+		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;
+		devpriv->last_dma_run = bytes % devpriv->hwdmasize;
 		devpriv->dma_runs_to_end--;
 		if (devpriv->dma_runs_to_end >= 0)
-			bytes = devpriv->hwdmasize[0];
+			bytes = devpriv->hwdmasize;
 	}
 
 	devpriv->next_dma_buf = 0;
@@ -1308,9 +1304,9 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl818_board *board = comedi_board(dev);
 	struct pcl818_private *devpriv;
-	int ret;
-	unsigned long pages;
 	struct comedi_subdevice *s;
+	int ret;
+	int i;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
@@ -1353,20 +1349,19 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 		devpriv->dma = it->options[2];
 
-		pages = 2;	/* we need 16KB */
-		devpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);
-		if (!devpriv->dmabuf[0])
-			/* maybe experiment with try_to_free_pages() will help .... */
-			return -EBUSY;	/* no buffer :-( */
-		devpriv->dmapages[0] = pages;
-		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
-		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
-		devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
-		if (!devpriv->dmabuf[1])
-			return -EBUSY;
-		devpriv->dmapages[1] = pages;
-		devpriv->hwdmaptr[1] = virt_to_bus((void *)devpriv->dmabuf[1]);
-		devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
+		devpriv->dmapages = 2;	/* we need 16KB */
+		devpriv->hwdmasize = (1 << devpriv->dmapages) * PAGE_SIZE;
+
+		for (i = 0; i < 2; i++) {
+			unsigned long dmabuf;
+
+			dmabuf = __get_dma_pages(GFP_KERNEL, devpriv->dmapages);
+			if (!dmabuf)
+				return -ENOMEM;
+
+			devpriv->dmabuf[i] = dmabuf;
+			devpriv->hwdmaptr[i] = virt_to_bus((void *)dmabuf);
+		}
 	}
 
 	ret = comedi_alloc_subdevices(dev, 4);
@@ -1468,9 +1463,9 @@ static void pcl818_detach(struct comedi_device *dev)
 		if (devpriv->dma)
 			free_dma(devpriv->dma);
 		if (devpriv->dmabuf[0])
-			free_pages(devpriv->dmabuf[0], devpriv->dmapages[0]);
+			free_pages(devpriv->dmabuf[0], devpriv->dmapages);
 		if (devpriv->dmabuf[1])
-			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
+			free_pages(devpriv->dmabuf[1], devpriv->dmapages);
 	}
 	comedi_legacy_detach(dev);
 }

commit 0f536336e4530748f3fd8e76e0b4899faec3da09
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:27 2014 -0700

    staging: comedi: pcl818: remove 'ai_flags' from private data
    
    This member of the private data is not used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index f73fc791a13c..dcc397cf45bb 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -342,7 +342,6 @@ struct pcl818_private {
 	unsigned int act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
 	unsigned int *ai_chanlist;	/*  actaul chanlist */
-	unsigned int ai_flags;	/*  flaglist */
 	unsigned int ai_data_len;	/*  len of data buffer */
 	unsigned int ai_timer1;	/*  timers */
 	unsigned int ai_timer2;
@@ -1118,7 +1117,6 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int retval;
 
 	devpriv->ai_chanlist = cmd->chanlist;
-	devpriv->ai_flags = cmd->flags;
 	devpriv->ai_data_len = s->async->prealloc_bufsz;
 	devpriv->ai_timer1 = 0;
 	devpriv->ai_timer2 = 0;

commit 41bbe835f1cd48a14af2cd3a3a9b41e1528f07dc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:25 2014 -0700

    staging: comedi: pcl818: remove 'ai_n_chan' from private data
    
    This member of the private data is just a copy of the cmd->chanlist_len.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index eea48ded0413..f73fc791a13c 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -341,7 +341,6 @@ struct pcl818_private {
 	unsigned int act_chanlist[16];	/*  MUX setting for actual AI operations */
 	unsigned int act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
-	unsigned int ai_n_chan;	/*  how many channels is measured */
 	unsigned int *ai_chanlist;	/*  actaul chanlist */
 	unsigned int ai_flags;	/*  flaglist */
 	unsigned int ai_data_len;	/*  len of data buffer */
@@ -515,6 +514,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan;
 	int timeout = 50;	/* wait max 50us */
 
@@ -549,7 +549,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 		devpriv->act_chanlist_pos = 0;
 
 	s->async->cur_chan++;
-	if (s->async->cur_chan >= devpriv->ai_n_chan) {
+	if (s->async->cur_chan >= cmd->chanlist_len) {
 		s->async->cur_chan = 0;
 		devpriv->ai_act_scan--;
 	}
@@ -573,6 +573,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int i, len, bufptr;
 	unsigned long flags;
 	unsigned short *ptr;
@@ -622,7 +623,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 			devpriv->act_chanlist_pos = 0;
 
 		s->async->cur_chan++;
-		if (s->async->cur_chan >= devpriv->ai_n_chan) {
+		if (s->async->cur_chan >= cmd->chanlist_len) {
 			s->async->cur_chan = 0;
 			devpriv->ai_act_scan--;
 		}
@@ -650,6 +651,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int i, len;
 	unsigned char lo;
 
@@ -698,7 +700,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 			devpriv->act_chanlist_pos = 0;
 
 		s->async->cur_chan++;
-		if (s->async->cur_chan >= devpriv->ai_n_chan) {
+		if (s->async->cur_chan >= cmd->chanlist_len) {
 			s->async->cur_chan = 0;
 			devpriv->ai_act_scan--;
 		}
@@ -796,7 +798,7 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 	disable_dma(devpriv->dma);	/*  disable dma */
 	bytes = devpriv->hwdmasize[0];
 	if (!devpriv->neverending_ai) {
-		bytes = devpriv->ai_n_chan * cmd->stop_arg * sizeof(short);	/*  how many */
+		bytes = cmd->chanlist_len * cmd->stop_arg * sizeof(short);	/*  how many */
 		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize[0];	/*  how many DMA pages we must fiil */
 		devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];	/* on last dma transfer must be moved */
 		devpriv->dma_runs_to_end--;
@@ -840,11 +842,11 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	seglen = check_channel_list(dev, s, devpriv->ai_chanlist,
-				    devpriv->ai_n_chan);
+				    cmd->chanlist_len);
 	if (seglen < 1)
 		return -EINVAL;
 	setup_channel_list(dev, s, devpriv->ai_chanlist,
-			   devpriv->ai_n_chan, seglen);
+			   cmd->chanlist_len, seglen);
 
 	udelay(1);
 
@@ -1115,7 +1117,6 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
 
-	devpriv->ai_n_chan = cmd->chanlist_len;
 	devpriv->ai_chanlist = cmd->chanlist;
 	devpriv->ai_flags = cmd->flags;
 	devpriv->ai_data_len = s->async->prealloc_bufsz;

commit c2e519dd212937d3726ef9e326b35185295c455a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:22 2014 -0700

    staging: comedi: pcl818: remove 'ai_scans' from private data
    
    This member of the private data is just a copy of the cmd->stop_arg.
    
    Refactor the code to follow the style of pcl812 and pcl816 drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index d5709edd6799..eea48ded0413 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -341,7 +341,6 @@ struct pcl818_private {
 	unsigned int act_chanlist[16];	/*  MUX setting for actual AI operations */
 	unsigned int act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
-	unsigned int ai_scans;	/*  len of scanlist */
 	unsigned int ai_n_chan;	/*  how many channels is measured */
 	unsigned int *ai_chanlist;	/*  actaul chanlist */
 	unsigned int ai_flags;	/*  flaglist */
@@ -790,13 +789,14 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
 	struct pcl818_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int flags;
 	unsigned int bytes;
 
 	disable_dma(devpriv->dma);	/*  disable dma */
 	bytes = devpriv->hwdmasize[0];
 	if (!devpriv->neverending_ai) {
-		bytes = devpriv->ai_n_chan * devpriv->ai_scans * sizeof(short);	/*  how many */
+		bytes = devpriv->ai_n_chan * cmd->stop_arg * sizeof(short);	/*  how many */
 		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize[0];	/*  how many DMA pages we must fiil */
 		devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];	/* on last dma transfer must be moved */
 		devpriv->dma_runs_to_end--;
@@ -848,17 +848,13 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 
 	udelay(1);
 
-	devpriv->ai_act_scan = devpriv->ai_scans;
+	devpriv->ai_act_scan = cmd->stop_arg;
 	devpriv->ai_act_chan = 0;
 	devpriv->irq_blocked = 1;
 	devpriv->irq_was_now_closed = 0;
-	devpriv->neverending_ai = 0;
 	devpriv->act_chanlist_pos = 0;
 	devpriv->dma_runs_to_end = 0;
 
-	if ((devpriv->ai_scans == 0) || (devpriv->ai_scans == -1))
-		devpriv->neverending_ai = 1;	/* well, user want neverending */
-
 	if (mode == 1) {
 		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base,
 					  &divisor1, &divisor2,
@@ -1127,9 +1123,9 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_timer2 = 0;
 
 	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->ai_scans = cmd->stop_arg;
+		devpriv->neverending_ai = 0;
 	else
-		devpriv->ai_scans = 0;
+		devpriv->neverending_ai = 1;
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW) {	/*  mode 1, 3 */
 		if (cmd->convert_src == TRIG_TIMER) {	/*  mode 1 */

commit 8fc9f652abd71fd53e17c3b2430e702e5a55fae2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:16 2014 -0700

    staging: comedi: pcl818: introduce pcl818_ai_get_sample()
    
    Introduce a helper function to read the 12-bit analog input data
    sample and optionally return the channel that the sample was for.
    The channel is only used in the interrupt routine to check for
    dropped samples.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 2b8e7e0d2c75..d5709edd6799 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -372,6 +372,21 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 static void start_pacer(struct comedi_device *dev, int mode,
 			unsigned int divisor1, unsigned int divisor2);
 
+static unsigned int pcl818_ai_get_sample(struct comedi_device *dev,
+					 struct comedi_subdevice *s,
+					 unsigned int *chan)
+{
+	unsigned int val;
+
+	val = inb(dev->iobase + PCL818_AD_HI) << 8;
+	val |= inb(dev->iobase + PCL818_AD_LO);
+
+	if (chan)
+		*chan = val & 0xf;
+
+	return (val >> 4) & s->maxdata;
+}
+
 static int pcl818_ai_eoc(struct comedi_device *dev,
 			 struct comedi_subdevice *s,
 			 struct comedi_insn *insn,
@@ -416,8 +431,7 @@ static int pcl818_ai_insn_read(struct comedi_device *dev,
 			return ret;
 		}
 
-		data[n] = ((inb(dev->iobase + PCL818_AD_HI) << 4) |
-			   (inb(dev->iobase + PCL818_AD_LO) >> 4));
+		data[n] = pcl818_ai_get_sample(dev, s, NULL);
 	}
 
 	return n;
@@ -502,7 +516,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	unsigned char low;
+	unsigned int chan;
 	int timeout = 50;	/* wait max 50us */
 
 	while (timeout--) {
@@ -518,14 +532,13 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 	return IRQ_HANDLED;
 
 conv_finish:
-	low = inb(dev->iobase + PCL818_AD_LO);
-	comedi_buf_put(s->async, ((inb(dev->iobase + PCL818_AD_HI) << 4) | (low >> 4)));	/*  get one sample */
+	comedi_buf_put(s->async, pcl818_ai_get_sample(dev, s, &chan));
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
-	if ((low & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
+	if (chan != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {
 		dev_dbg(dev->class_dev,
 			"A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
-			(low & 0xf),
+			chan,
 			devpriv->act_chanlist[devpriv->act_chanlist_pos]);
 		pcl818_ai_cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
@@ -1166,8 +1179,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 			udelay(1);
 			start_pacer(dev, -1, 0, 0);
 			outb(0, dev->iobase + PCL818_AD_LO);
-			inb(dev->iobase + PCL818_AD_LO);
-			inb(dev->iobase + PCL818_AD_HI);
+			pcl818_ai_get_sample(dev, s, NULL);
 			outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 			outb(0, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
 			if (devpriv->usefifo) {	/*  FIFO shutdown */

commit 2bfe3eb76fa427492924f48a32bf230bfb88caf8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:12 2014 -0700

    staging: comedi: pcl818: remove 'ao_maxdata' from boardinfo
    
    All the board types have 12-bit analog outputs. Remove this data from
    the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 4d452d20402d..2b8e7e0d2c75 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -261,7 +261,6 @@ struct pcl818_board {
 	unsigned int ns_min;
 	int n_aochan;
 	const struct comedi_lrange *ai_range_type;
-	int ao_maxdata;
 	unsigned int has_dma:1;
 	unsigned int has_fifo:1;
 	unsigned int is_818:1;
@@ -273,7 +272,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 25000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818l_l_ai,
-		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 		.is_818		= 1,
 	}, {
@@ -281,7 +279,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818h_ai,
-		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 		.is_818		= 1,
 	}, {
@@ -289,7 +286,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818h_ai,
-		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 		.has_fifo	= 1,
 		.is_818		= 1,
@@ -298,7 +294,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818hg_ai,
-		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 		.has_fifo	= 1,
 		.is_818		= 1,
@@ -307,7 +302,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 10000,
 		.n_aochan	= 2,
 		.ai_range_type	= &range_pcl818h_ai,
-		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 		.is_818		= 1,
 	}, {
@@ -315,13 +309,11 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 16000,
 		.n_aochan	= 2,
 		.ai_range_type	= &range_unipolar5,
-		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 	}, {
 		.name		= "pcm3718",
 		.ns_min		= 10000,
 		.ai_range_type	= &range_pcl818h_ai,
-		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 		.is_818		= 1,
 	},
@@ -1405,7 +1397,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
 		s->n_chan = board->n_aochan;
-		s->maxdata = board->ao_maxdata;
+		s->maxdata = 0x0fff;
 		s->range_table = &range_unipolar5;
 		s->insn_read = pcl818_ao_insn_read;
 		s->insn_write = pcl818_ao_insn_write;

commit bca1b5944db3af9f7e04b5d3917f789ad4cc3960
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:11 2014 -0700

    staging: comedi: pcl818: remove 'ai_maxdata' from boardinfo
    
    All the board types have 12-bit analog inputs. Remove this data from
    the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index e3a2579eecf2..4d452d20402d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -261,7 +261,6 @@ struct pcl818_board {
 	unsigned int ns_min;
 	int n_aochan;
 	const struct comedi_lrange *ai_range_type;
-	int ai_maxdata;
 	int ao_maxdata;
 	unsigned int has_dma:1;
 	unsigned int has_fifo:1;
@@ -274,7 +273,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 25000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818l_l_ai,
-		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 		.is_818		= 1,
@@ -283,7 +281,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818h_ai,
-		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 		.is_818		= 1,
@@ -292,7 +289,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818h_ai,
-		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 		.has_fifo	= 1,
@@ -302,7 +298,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818hg_ai,
-		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 		.has_fifo	= 1,
@@ -312,7 +307,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 10000,
 		.n_aochan	= 2,
 		.ai_range_type	= &range_pcl818h_ai,
-		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 		.is_818		= 1,
@@ -321,14 +315,12 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 16000,
 		.n_aochan	= 2,
 		.ai_range_type	= &range_unipolar5,
-		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 	}, {
 		.name		= "pcm3718",
 		.ns_min		= 10000,
 		.ai_range_type	= &range_pcl818h_ai,
-		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
 		.is_818		= 1,
@@ -1392,7 +1384,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->n_chan	= 8;
 		s->subdev_flags	|= SDF_DIFF;
 	}
-	s->maxdata	= board->ai_maxdata;
+	s->maxdata	= 0x0fff;
 
 	pcl818_set_ai_range_table(dev, s, it);
 

commit 8356d4b4f444fa5745f042527043a2ad3a5bf685
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:10 2014 -0700

    staging: comedi: pcl818: clarify irq request in pcl818_attach()
    
    All the board types can use IRQ 2-7 for async command support. Remove
    the 'IRQbits', which is a mask of the valid IRQs, from the boardinfo
    and refactor pcl818_attach().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index ded1bf8dbe3e..e3a2579eecf2 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -261,7 +261,6 @@ struct pcl818_board {
 	unsigned int ns_min;
 	int n_aochan;
 	const struct comedi_lrange *ai_range_type;
-	unsigned int IRQbits;
 	int ai_maxdata;
 	int ao_maxdata;
 	unsigned int has_dma:1;
@@ -275,7 +274,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 25000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818l_l_ai,
-		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
@@ -285,7 +283,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818h_ai,
-		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
@@ -295,7 +292,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818h_ai,
-		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
@@ -306,7 +302,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818hg_ai,
-		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
@@ -317,7 +312,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 10000,
 		.n_aochan	= 2,
 		.ai_range_type	= &range_pcl818h_ai,
-		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
@@ -327,7 +321,6 @@ static const struct pcl818_board boardtypes[] = {
 		.ns_min		= 16000,
 		.n_aochan	= 2,
 		.ai_range_type	= &range_unipolar5,
-		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
@@ -335,7 +328,6 @@ static const struct pcl818_board boardtypes[] = {
 		.name		= "pcm3718",
 		.ns_min		= 10000,
 		.ai_range_type	= &range_pcl818h_ai,
-		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
 		.has_dma	= 1,
@@ -1347,7 +1339,8 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EIO;
 	}
 
-	if ((1 << it->options[1]) & board->IRQbits) {
+	/* we can use IRQ 2-7 for async command support */
+	if (it->options[1] >= 2 && it->options[1] <= 7) {
 		ret = request_irq(it->options[1], interrupt_pcl818, 0,
 				  dev->board_name, dev);
 		if (ret == 0)

commit bffeff2d2c858bad9e97517cc4936fb05ce197d6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:03 2014 -0700

    staging: comedi: pcl818: remove 'n_ranges' from boardinfo
    
    This member in the boardinfo is not used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 4f280268fd6c..ded1bf8dbe3e 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -258,7 +258,6 @@ static const struct comedi_lrange range718_unipolar1 = {
 
 struct pcl818_board {
 	const char *name;
-	int n_ranges;
 	unsigned int ns_min;
 	int n_aochan;
 	const struct comedi_lrange *ai_range_type;
@@ -273,7 +272,6 @@ struct pcl818_board {
 static const struct pcl818_board boardtypes[] = {
 	{
 		.name		= "pcl818l",
-		.n_ranges	= 4,
 		.ns_min		= 25000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818l_l_ai,
@@ -284,7 +282,6 @@ static const struct pcl818_board boardtypes[] = {
 		.is_818		= 1,
 	}, {
 		.name		= "pcl818h",
-		.n_ranges	= 9,
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818h_ai,
@@ -295,7 +292,6 @@ static const struct pcl818_board boardtypes[] = {
 		.is_818		= 1,
 	}, {
 		.name		= "pcl818hd",
-		.n_ranges	= 9,
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818h_ai,
@@ -307,7 +303,6 @@ static const struct pcl818_board boardtypes[] = {
 		.is_818		= 1,
 	}, {
 		.name		= "pcl818hg",
-		.n_ranges	= 12,
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818hg_ai,
@@ -319,7 +314,6 @@ static const struct pcl818_board boardtypes[] = {
 		.is_818		= 1,
 	}, {
 		.name		= "pcl818",
-		.n_ranges	= 9,
 		.ns_min		= 10000,
 		.n_aochan	= 2,
 		.ai_range_type	= &range_pcl818h_ai,
@@ -330,7 +324,6 @@ static const struct pcl818_board boardtypes[] = {
 		.is_818		= 1,
 	}, {
 		.name		= "pcl718",
-		.n_ranges	= 1,
 		.ns_min		= 16000,
 		.n_aochan	= 2,
 		.ai_range_type	= &range_unipolar5,
@@ -340,7 +333,6 @@ static const struct pcl818_board boardtypes[] = {
 		.has_dma	= 1,
 	}, {
 		.name		= "pcm3718",
-		.n_ranges	= 9,
 		.ns_min		= 10000,
 		.ai_range_type	= &range_pcl818h_ai,
 		.IRQbits	= 0x00fc,

commit 9c06c4e39671ded54036075eaf0aae9404954b06
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:00 2014 -0700

    staging: comedi: pcl818: all board types have analog inputs
    
    All the boards supported by this driver have 16 single-ended analog input
    channels. The boards can also be configued to give 8 differential inputs.
    
    Remove the 'n_aichan_se' and 'n_aichan_diff' members from the boardinfo and
    refactor pcl818_attach().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 000df80a689d..4f280268fd6c 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -259,8 +259,6 @@ static const struct comedi_lrange range718_unipolar1 = {
 struct pcl818_board {
 	const char *name;
 	int n_ranges;
-	int n_aichan_se;
-	int n_aichan_diff;
 	unsigned int ns_min;
 	int n_aochan;
 	const struct comedi_lrange *ai_range_type;
@@ -276,8 +274,6 @@ static const struct pcl818_board boardtypes[] = {
 	{
 		.name		= "pcl818l",
 		.n_ranges	= 4,
-		.n_aichan_se	= 16,
-		.n_aichan_diff	= 8,
 		.ns_min		= 25000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818l_l_ai,
@@ -289,8 +285,6 @@ static const struct pcl818_board boardtypes[] = {
 	}, {
 		.name		= "pcl818h",
 		.n_ranges	= 9,
-		.n_aichan_se	= 16,
-		.n_aichan_diff	= 8,
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818h_ai,
@@ -302,8 +296,6 @@ static const struct pcl818_board boardtypes[] = {
 	}, {
 		.name		= "pcl818hd",
 		.n_ranges	= 9,
-		.n_aichan_se	= 16,
-		.n_aichan_diff	= 8,
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818h_ai,
@@ -316,8 +308,6 @@ static const struct pcl818_board boardtypes[] = {
 	}, {
 		.name		= "pcl818hg",
 		.n_ranges	= 12,
-		.n_aichan_se	= 16,
-		.n_aichan_diff	= 8,
 		.ns_min		= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl818hg_ai,
@@ -330,8 +320,6 @@ static const struct pcl818_board boardtypes[] = {
 	}, {
 		.name		= "pcl818",
 		.n_ranges	= 9,
-		.n_aichan_se	= 16,
-		.n_aichan_diff	= 8,
 		.ns_min		= 10000,
 		.n_aochan	= 2,
 		.ai_range_type	= &range_pcl818h_ai,
@@ -343,8 +331,6 @@ static const struct pcl818_board boardtypes[] = {
 	}, {
 		.name		= "pcl718",
 		.n_ranges	= 1,
-		.n_aichan_se	= 16,
-		.n_aichan_diff	= 8,
 		.ns_min		= 16000,
 		.n_aochan	= 2,
 		.ai_range_type	= &range_unipolar5,
@@ -355,8 +341,6 @@ static const struct pcl818_board boardtypes[] = {
 	}, {
 		.name		= "pcm3718",
 		.n_ranges	= 9,
-		.n_aichan_se	= 16,
-		.n_aichan_diff	= 8,
 		.ns_min		= 10000,
 		.ai_range_type	= &range_pcl818h_ai,
 		.IRQbits	= 0x00fc,
@@ -1414,31 +1398,27 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return ret;
 
 	s = &dev->subdevices[0];
-	if (!board->n_aichan_se) {
-		s->type = COMEDI_SUBD_UNUSED;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE;
+	if (check_single_ended(dev->iobase)) {
+		s->n_chan	= 16;
+		s->subdev_flags	|= SDF_COMMON | SDF_GROUND;
 	} else {
-		s->type = COMEDI_SUBD_AI;
-		s->subdev_flags = SDF_READABLE;
-		if (check_single_ended(dev->iobase)) {
-			s->n_chan = board->n_aichan_se;
-			s->subdev_flags |= SDF_COMMON | SDF_GROUND;
-		} else {
-			s->n_chan = board->n_aichan_diff;
-			s->subdev_flags |= SDF_DIFF;
-		}
-		s->maxdata = board->ai_maxdata;
-
-		pcl818_set_ai_range_table(dev, s, it);
-
-		s->insn_read = pcl818_ai_insn_read;
-		if (dev->irq) {
-			dev->read_subdev = s;
-			s->subdev_flags |= SDF_CMD_READ;
-			s->len_chanlist = s->n_chan;
-			s->do_cmdtest = ai_cmdtest;
-			s->do_cmd = ai_cmd;
-			s->cancel = pcl818_ai_cancel;
-		}
+		s->n_chan	= 8;
+		s->subdev_flags	|= SDF_DIFF;
+	}
+	s->maxdata	= board->ai_maxdata;
+
+	pcl818_set_ai_range_table(dev, s, it);
+
+	s->insn_read	= pcl818_ai_insn_read;
+	if (dev->irq) {
+		dev->read_subdev = s;
+		s->subdev_flags	|= SDF_CMD_READ;
+		s->len_chanlist	= s->n_chan;
+		s->do_cmdtest	= ai_cmdtest;
+		s->do_cmd	= ai_cmd;
+		s->cancel	= pcl818_ai_cancel;
 	}
 
 	s = &dev->subdevices[1];

commit f39b8ccf7e02277d94ae67210fd71225ee4e53f5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:57 2014 -0700

    staging: comedi: pcl818: factor analog input range selection out of (*attach)
    
    The analog input subdevice range is setup in this driver based on a config
    option passed by the user. Factor the code that sets the range_table out
    of pcl818_attach() to clarify the (*attach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index e206b78826a6..000df80a689d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1294,6 +1294,57 @@ static void pcl818_reset(struct comedi_device *dev)
 	}
 }
 
+static void pcl818_set_ai_range_table(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_devconfig *it)
+{
+	const struct pcl818_board *board = comedi_board(dev);
+
+	/* default to the range table from the boardinfo */
+	s->range_table = board->ai_range_type;
+
+	/* now check the user config option based on the boardtype */
+	if (board->is_818) {
+		if (it->options[4] == 1 || it->options[4] == 10) {
+			/* secondary range list jumper selectable */
+			s->range_table = &range_pcl818l_h_ai;
+		}
+	} else {
+		switch (it->options[4]) {
+		case 0:
+			s->range_table = &range_bipolar10;
+			break;
+		case 1:
+			s->range_table = &range_bipolar5;
+			break;
+		case 2:
+			s->range_table = &range_bipolar2_5;
+			break;
+		case 3:
+			s->range_table = &range718_bipolar1;
+			break;
+		case 4:
+			s->range_table = &range718_bipolar0_5;
+			break;
+		case 6:
+			s->range_table = &range_unipolar10;
+			break;
+		case 7:
+			s->range_table = &range_unipolar5;
+			break;
+		case 8:
+			s->range_table = &range718_unipolar2;
+			break;
+		case 9:
+			s->range_table = &range718_unipolar1;
+			break;
+		default:
+			s->range_table = &range_unknown;
+			break;
+		}
+	}
+}
+
 static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl818_board *board = comedi_board(dev);
@@ -1376,7 +1427,9 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			s->subdev_flags |= SDF_DIFF;
 		}
 		s->maxdata = board->ai_maxdata;
-		s->range_table = board->ai_range_type;
+
+		pcl818_set_ai_range_table(dev, s, it);
+
 		s->insn_read = pcl818_ai_insn_read;
 		if (dev->irq) {
 			dev->read_subdev = s;
@@ -1386,43 +1439,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			s->do_cmd = ai_cmd;
 			s->cancel = pcl818_ai_cancel;
 		}
-		if (board->is_818) {
-			if ((it->options[4] == 1) || (it->options[4] == 10))
-				s->range_table = &range_pcl818l_h_ai;	/*  secondary range list jumper selectable */
-		} else {
-			switch (it->options[4]) {
-			case 0:
-				s->range_table = &range_bipolar10;
-				break;
-			case 1:
-				s->range_table = &range_bipolar5;
-				break;
-			case 2:
-				s->range_table = &range_bipolar2_5;
-				break;
-			case 3:
-				s->range_table = &range718_bipolar1;
-				break;
-			case 4:
-				s->range_table = &range718_bipolar0_5;
-				break;
-			case 6:
-				s->range_table = &range_unipolar10;
-				break;
-			case 7:
-				s->range_table = &range_unipolar5;
-				break;
-			case 8:
-				s->range_table = &range718_unipolar2;
-				break;
-			case 9:
-				s->range_table = &range718_unipolar1;
-				break;
-			default:
-				s->range_table = &range_unknown;
-				break;
-			}
-		}
 	}
 
 	s = &dev->subdevices[1];

commit 03d98e6c78c4de55220a8ad687b3c5df3b83f7d2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:54 2014 -0700

    staging: comedi: pcl818: all board types have digital inputs and outputs
    
    All the board types have 16 digital inputs and 16 digital outputs.
    
    Remove the 'n_dichan' and 'n_dochan' members in the boardinfo. Refactor
    pcl818_attach() to always setup these subdevices.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index e709e3c0a10b..e206b78826a6 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -263,8 +263,6 @@ struct pcl818_board {
 	int n_aichan_diff;
 	unsigned int ns_min;
 	int n_aochan;
-	int n_dichan;
-	int n_dochan;
 	const struct comedi_lrange *ai_range_type;
 	unsigned int IRQbits;
 	int ai_maxdata;
@@ -282,8 +280,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_aichan_diff	= 8,
 		.ns_min		= 25000,
 		.n_aochan	= 1,
-		.n_dichan	= 16,
-		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818l_l_ai,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
@@ -297,8 +293,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_aichan_diff	= 8,
 		.ns_min		= 10000,
 		.n_aochan	= 1,
-		.n_dichan	= 16,
-		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
@@ -312,8 +306,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_aichan_diff	= 8,
 		.ns_min		= 10000,
 		.n_aochan	= 1,
-		.n_dichan	= 16,
-		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
@@ -328,8 +320,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_aichan_diff	= 8,
 		.ns_min		= 10000,
 		.n_aochan	= 1,
-		.n_dichan	= 16,
-		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818hg_ai,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
@@ -344,8 +334,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_aichan_diff	= 8,
 		.ns_min		= 10000,
 		.n_aochan	= 2,
-		.n_dichan	= 16,
-		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
@@ -359,8 +347,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_aichan_diff	= 8,
 		.ns_min		= 16000,
 		.n_aochan	= 2,
-		.n_dichan	= 16,
-		.n_dochan	= 16,
 		.ai_range_type	= &range_unipolar5,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
@@ -372,8 +358,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_aichan_se	= 16,
 		.n_aichan_diff	= 8,
 		.ns_min		= 10000,
-		.n_dichan	= 16,
-		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xfff,
@@ -1465,29 +1449,23 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	}
 
+	/* Digital Input subdevice */
 	s = &dev->subdevices[2];
-	if (!board->n_dichan) {
-		s->type = COMEDI_SUBD_UNUSED;
-	} else {
-		s->type = COMEDI_SUBD_DI;
-		s->subdev_flags = SDF_READABLE;
-		s->n_chan = board->n_dichan;
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->insn_bits = pcl818_di_insn_bits;
-	}
-
+	s->type		= COMEDI_SUBD_DI;
+	s->subdev_flags	= SDF_READABLE;
+	s->n_chan	= 16;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= pcl818_di_insn_bits;
+
+	/* Digital Output subdevice */
 	s = &dev->subdevices[3];
-	if (!board->n_dochan) {
-		s->type = COMEDI_SUBD_UNUSED;
-	} else {
-		s->type = COMEDI_SUBD_DO;
-		s->subdev_flags = SDF_WRITABLE;
-		s->n_chan = board->n_dochan;
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->insn_bits = pcl818_do_insn_bits;
-	}
+	s->type		= COMEDI_SUBD_DO;
+	s->subdev_flags	= SDF_WRITABLE;
+	s->n_chan	= 16;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= pcl818_do_insn_bits;
 
 	/* select 1/10MHz oscilator */
 	if ((it->options[3] == 0) || (it->options[3] == 10))

commit 9acf56f25ae157e3b78d1238671d103c360f83b4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:52 2014 -0700

    staging: comedi: pcl818: change 'is_818' in boardinfo to a bit-field
    
    Change this flag in the boardinfo into a bit-field.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 9cb3e460c915..e709e3c0a10b 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -271,7 +271,7 @@ struct pcl818_board {
 	int ao_maxdata;
 	unsigned int has_dma:1;
 	unsigned int has_fifo:1;
-	int is_818;
+	unsigned int is_818:1;
 };
 
 static const struct pcl818_board boardtypes[] = {

commit 4ba4a2d307de7b60b47506346ad5e2bdf37e211a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:50 2014 -0700

    staging: comedi: pcl818: clarify dma channel request in pcl818_attach()
    
    All the board types that can do DMA can use DMA channels 3 or 1. Remove
    the 'DMAbits', which is a mask of the valid channels, from the boardinfo
    and replace it with a bit-field flag 'has_dma'.
    
    Refactor pcl818_attach() to use the new flag and remove the need for the
    goto.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index a000f742b0bf..9cb3e460c915 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -267,9 +267,9 @@ struct pcl818_board {
 	int n_dochan;
 	const struct comedi_lrange *ai_range_type;
 	unsigned int IRQbits;
-	unsigned int DMAbits;
 	int ai_maxdata;
 	int ao_maxdata;
+	unsigned int has_dma:1;
 	unsigned int has_fifo:1;
 	int is_818;
 };
@@ -286,9 +286,9 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818l_l_ai,
 		.IRQbits	= 0x00fc,
-		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
+		.has_dma	= 1,
 		.is_818		= 1,
 	}, {
 		.name		= "pcl818h",
@@ -301,9 +301,9 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
 		.IRQbits	= 0x00fc,
-		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
+		.has_dma	= 1,
 		.is_818		= 1,
 	}, {
 		.name		= "pcl818hd",
@@ -316,9 +316,9 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
 		.IRQbits	= 0x00fc,
-		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
+		.has_dma	= 1,
 		.has_fifo	= 1,
 		.is_818		= 1,
 	}, {
@@ -332,9 +332,9 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818hg_ai,
 		.IRQbits	= 0x00fc,
-		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
+		.has_dma	= 1,
 		.has_fifo	= 1,
 		.is_818		= 1,
 	}, {
@@ -348,9 +348,9 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
 		.IRQbits	= 0x00fc,
-		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
+		.has_dma	= 1,
 		.is_818		= 1,
 	}, {
 		.name		= "pcl718",
@@ -363,9 +363,9 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_unipolar5,
 		.IRQbits	= 0x00fc,
-		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
+		.has_dma	= 1,
 	}, {
 		.name		= "pcm3718",
 		.n_ranges	= 9,
@@ -376,9 +376,9 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
 		.IRQbits	= 0x00fc,
-		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
+		.has_dma	= 1,
 		.is_818		= 1,
 	},
 };
@@ -1315,7 +1315,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct pcl818_board *board = comedi_board(dev);
 	struct pcl818_private *devpriv;
 	int ret;
-	int dma;
 	unsigned long pages;
 	struct comedi_subdevice *s;
 
@@ -1347,24 +1346,18 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
 	devpriv->ai_mode = 0;	/* mode of irq */
 
-	/* grab our DMA */
-	dma = 0;
-	devpriv->dma = dma;
-	if (!dev->irq)
-		goto no_dma;	/* if we haven't IRQ, we can't use DMA */
-	if (board->DMAbits != 0) {	/* board support DMA */
-		dma = it->options[2];
-		if (dma < 1)
-			goto no_dma;	/* DMA disabled */
-		if (((1 << dma) & board->DMAbits) == 0) {
+	/* we need an IRQ to do DMA on channel 3 or 1 */
+	if (dev->irq && board->has_dma &&
+	    (it->options[2] == 3 || it->options[2] == 1)) {
+		ret = request_dma(it->options[2], dev->board_name);
+		if (ret) {
 			dev_err(dev->class_dev,
-				"DMA is out of allowed range, FAIL!\n");
-			return -EINVAL;	/* Bad DMA */
+				"unable to request DMA channel %d\n",
+				it->options[2]);
+			return -EBUSY;
 		}
-		ret = request_dma(dma, dev->board_name);
-		if (ret)
-			return -EBUSY;	/* DMA isn't free */
-		devpriv->dma = dma;
+		devpriv->dma = it->options[2];
+
 		pages = 2;	/* we need 16KB */
 		devpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);
 		if (!devpriv->dmabuf[0])
@@ -1381,8 +1374,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
 	}
 
-no_dma:
-
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
 		return ret;

commit ba93331e33c4600fe72bcbbe1bf8afb72b425098
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:47 2014 -0700

    staging: comedi: pcl818: remove 'rangelist_ao' from boardinfo
    
    The 'rangelist_ao' is the same for all board types. Remove this data
    from the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 4f195dbccba4..a000f742b0bf 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -266,7 +266,6 @@ struct pcl818_board {
 	int n_dichan;
 	int n_dochan;
 	const struct comedi_lrange *ai_range_type;
-	const struct comedi_lrange *ao_range_type;
 	unsigned int IRQbits;
 	unsigned int DMAbits;
 	int ai_maxdata;
@@ -286,7 +285,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dichan	= 16,
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818l_l_ai,
-		.ao_range_type	= &range_unipolar5,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
@@ -302,7 +300,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dichan	= 16,
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
-		.ao_range_type	= &range_unipolar5,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
@@ -318,7 +315,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dichan	= 16,
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
-		.ao_range_type	= &range_unipolar5,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
@@ -335,7 +331,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dichan	= 16,
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818hg_ai,
-		.ao_range_type	= &range_unipolar5,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
@@ -352,7 +347,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dichan	= 16,
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
-		.ao_range_type	= &range_unipolar5,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
@@ -368,7 +362,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dichan	= 16,
 		.n_dochan	= 16,
 		.ai_range_type	= &range_unipolar5,
-		.ao_range_type	= &range_unipolar5,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
@@ -382,7 +375,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dichan	= 16,
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
-		.ao_range_type	= &range_unipolar5,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
@@ -1466,7 +1458,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
 		s->n_chan = board->n_aochan;
 		s->maxdata = board->ao_maxdata;
-		s->range_table = board->ao_range_type;
+		s->range_table = &range_unipolar5;
 		s->insn_read = pcl818_ao_insn_read;
 		s->insn_write = pcl818_ao_insn_write;
 		if (board->is_818) {

commit d61255883967474fd68c2a927518c87e53b10f53
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:42 2014 -0700

    staging: comedi: pcl818: remove 'io_range' from boardinfo
    
    The 'io_range' is the same for all board types. Remove this data from
    the boardinfo.
    
    The i/o resource size is larger for board types that have a FIFO but this
    larger region is only requested if the user wants to use the fifo.
    
    Modify the pcl818_attach() to remove the need for the 'io_range' in the
    private data.
    
    For aesthetics, rename the 'fifo' member in the boardinfo to 'has_fifo'
    and change it to a bit-field.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 3dd9d98157d3..4f195dbccba4 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -121,11 +121,6 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define boardPCL818 4
 #define boardPCL718 5
 
-/* IO space len */
-#define PCLx1x_RANGE 16
-/* IO space len if we use FIFO */
-#define PCLx1xFIFO_RANGE 32
-
 /* W: clear INT request */
 #define PCL818_CLRINT 8
 /* R: return status byte */
@@ -272,12 +267,11 @@ struct pcl818_board {
 	int n_dochan;
 	const struct comedi_lrange *ai_range_type;
 	const struct comedi_lrange *ao_range_type;
-	unsigned int io_range;
 	unsigned int IRQbits;
 	unsigned int DMAbits;
 	int ai_maxdata;
 	int ao_maxdata;
-	unsigned char fifo;
+	unsigned int has_fifo:1;
 	int is_818;
 };
 
@@ -293,7 +287,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818l_l_ai,
 		.ao_range_type	= &range_unipolar5,
-		.io_range	= PCLx1x_RANGE,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
@@ -310,7 +303,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
 		.ao_range_type	= &range_unipolar5,
-		.io_range	= PCLx1x_RANGE,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
@@ -327,12 +319,11 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
 		.ao_range_type	= &range_unipolar5,
-		.io_range	= PCLx1x_RANGE,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
-		.fifo		= 1,
+		.has_fifo	= 1,
 		.is_818		= 1,
 	}, {
 		.name		= "pcl818hg",
@@ -345,12 +336,11 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818hg_ai,
 		.ao_range_type	= &range_unipolar5,
-		.io_range	= PCLx1x_RANGE,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
-		.fifo		= 1,
+		.has_fifo	= 1,
 		.is_818		= 1,
 	}, {
 		.name		= "pcl818",
@@ -363,7 +353,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
 		.ao_range_type	= &range_unipolar5,
-		.io_range	= PCLx1x_RANGE,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
@@ -380,7 +369,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_unipolar5,
 		.ao_range_type	= &range_unipolar5,
-		.io_range	= PCLx1x_RANGE,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
@@ -395,7 +383,6 @@ static const struct pcl818_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
 		.ao_range_type	= &range_unipolar5,
-		.io_range	= PCLx1x_RANGE,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
@@ -407,7 +394,6 @@ static const struct pcl818_board boardtypes[] = {
 struct pcl818_private {
 
 	unsigned int dma;	/*  used DMA, 0=don't use DMA */
-	unsigned int io_range;
 	unsigned long dmabuf[2];	/*  pointers to begin of DMA buffers */
 	unsigned int dmapages[2];	/*  len of DMA buffers in PAGE_SIZEs */
 	unsigned int hwdmaptr[2];	/*  hardware address of DMA buffers */
@@ -1345,13 +1331,12 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!devpriv)
 		return -ENOMEM;
 
-	devpriv->io_range = board->io_range;
-	if ((board->fifo) && (it->options[2] == -1)) {
-		/*  we've board with FIFO and we want to use FIFO */
-		devpriv->io_range = PCLx1xFIFO_RANGE;
+	/* should we use the FIFO? */
+	if (board->has_fifo && it->options[2] == -1)
 		devpriv->usefifo = 1;
-	}
-	ret = comedi_request_region(dev, it->options[0], devpriv->io_range);
+
+	ret = comedi_request_region(dev, it->options[0],
+				    devpriv->usefifo ? 0x20 : 0x10);
 	if (ret)
 		return ret;
 

commit 04f788694201a1062bb05d7a99937eef68c8c095
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:39 2014 -0700

    staging: comedi: pcl818: remove 0/NULL initialzation in boardinfo
    
    The unlisted members in the boardinfo declaration will default to 0/NULL.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index dcbee0a23821..3dd9d98157d3 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -298,7 +298,6 @@ static const struct pcl818_board boardtypes[] = {
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
-		.fifo		= 0,
 		.is_818		= 1,
 	}, {
 		.name		= "pcl818h",
@@ -316,7 +315,6 @@ static const struct pcl818_board boardtypes[] = {
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
-		.fifo		= 0,
 		.is_818		= 1,
 	}, {
 		.name		= "pcl818hd",
@@ -370,7 +368,6 @@ static const struct pcl818_board boardtypes[] = {
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
-		.fifo		= 0,
 		.is_818		= 1,
 	}, {
 		.name		= "pcl718",
@@ -388,15 +385,12 @@ static const struct pcl818_board boardtypes[] = {
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
-		.fifo		= 0,
-		.is_818		= 0,
 	}, {
 		.name		= "pcm3718",
 		.n_ranges	= 9,
 		.n_aichan_se	= 16,
 		.n_aichan_diff	= 8,
 		.ns_min		= 10000,
-		.n_aochan	= 0,
 		.n_dichan	= 16,
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl818h_ai,
@@ -406,7 +400,6 @@ static const struct pcl818_board boardtypes[] = {
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xfff,
 		.ao_maxdata	= 0xfff,
-		.fifo		= 0,
 		.is_818		= 1,
 	},
 };

commit 43f1b6e9fa755ea6937f121b769716358751fd69
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:37 2014 -0700

    staging: comedi: pcl818: convert boardinfo declaration to C99 format
    
    To reduce editing errors and make the data more maintainable, convert
    the boardinfo declaration to C99 format.
    
    For aesthetics, move the declaration closer to the definition and remove
    the unnecessary comments in the definition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 9087e54537ec..dcbee0a23821 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -262,26 +262,155 @@ static const struct comedi_lrange range718_unipolar1 = {
 };
 
 struct pcl818_board {
-
-	const char *name;	/*  driver name */
-	int n_ranges;		/*  len of range list */
-	int n_aichan_se;	/*  num of A/D chans in single ended  mode */
-	int n_aichan_diff;	/*  num of A/D chans in diferencial mode */
-	unsigned int ns_min;	/*  minimal allowed delay between samples (in ns) */
-	int n_aochan;		/*  num of D/A chans */
-	int n_dichan;		/*  num of DI chans */
-	int n_dochan;		/*  num of DO chans */
-	const struct comedi_lrange *ai_range_type;	/*  default A/D rangelist */
-	const struct comedi_lrange *ao_range_type;	/*  default D/A rangelist */
-	unsigned int io_range;	/*  len of IO space */
-	unsigned int IRQbits;	/*  allowed interrupts */
-	unsigned int DMAbits;	/*  allowed DMA chans */
-	int ai_maxdata;		/*  maxdata for A/D */
-	int ao_maxdata;		/*  maxdata for D/A */
-	unsigned char fifo;	/*  1=board has FIFO */
+	const char *name;
+	int n_ranges;
+	int n_aichan_se;
+	int n_aichan_diff;
+	unsigned int ns_min;
+	int n_aochan;
+	int n_dichan;
+	int n_dochan;
+	const struct comedi_lrange *ai_range_type;
+	const struct comedi_lrange *ao_range_type;
+	unsigned int io_range;
+	unsigned int IRQbits;
+	unsigned int DMAbits;
+	int ai_maxdata;
+	int ao_maxdata;
+	unsigned char fifo;
 	int is_818;
 };
 
+static const struct pcl818_board boardtypes[] = {
+	{
+		.name		= "pcl818l",
+		.n_ranges	= 4,
+		.n_aichan_se	= 16,
+		.n_aichan_diff	= 8,
+		.ns_min		= 25000,
+		.n_aochan	= 1,
+		.n_dichan	= 16,
+		.n_dochan	= 16,
+		.ai_range_type	= &range_pcl818l_l_ai,
+		.ao_range_type	= &range_unipolar5,
+		.io_range	= PCLx1x_RANGE,
+		.IRQbits	= 0x00fc,
+		.DMAbits	= 0x0a,
+		.ai_maxdata	= 0xfff,
+		.ao_maxdata	= 0xfff,
+		.fifo		= 0,
+		.is_818		= 1,
+	}, {
+		.name		= "pcl818h",
+		.n_ranges	= 9,
+		.n_aichan_se	= 16,
+		.n_aichan_diff	= 8,
+		.ns_min		= 10000,
+		.n_aochan	= 1,
+		.n_dichan	= 16,
+		.n_dochan	= 16,
+		.ai_range_type	= &range_pcl818h_ai,
+		.ao_range_type	= &range_unipolar5,
+		.io_range	= PCLx1x_RANGE,
+		.IRQbits	= 0x00fc,
+		.DMAbits	= 0x0a,
+		.ai_maxdata	= 0xfff,
+		.ao_maxdata	= 0xfff,
+		.fifo		= 0,
+		.is_818		= 1,
+	}, {
+		.name		= "pcl818hd",
+		.n_ranges	= 9,
+		.n_aichan_se	= 16,
+		.n_aichan_diff	= 8,
+		.ns_min		= 10000,
+		.n_aochan	= 1,
+		.n_dichan	= 16,
+		.n_dochan	= 16,
+		.ai_range_type	= &range_pcl818h_ai,
+		.ao_range_type	= &range_unipolar5,
+		.io_range	= PCLx1x_RANGE,
+		.IRQbits	= 0x00fc,
+		.DMAbits	= 0x0a,
+		.ai_maxdata	= 0xfff,
+		.ao_maxdata	= 0xfff,
+		.fifo		= 1,
+		.is_818		= 1,
+	}, {
+		.name		= "pcl818hg",
+		.n_ranges	= 12,
+		.n_aichan_se	= 16,
+		.n_aichan_diff	= 8,
+		.ns_min		= 10000,
+		.n_aochan	= 1,
+		.n_dichan	= 16,
+		.n_dochan	= 16,
+		.ai_range_type	= &range_pcl818hg_ai,
+		.ao_range_type	= &range_unipolar5,
+		.io_range	= PCLx1x_RANGE,
+		.IRQbits	= 0x00fc,
+		.DMAbits	= 0x0a,
+		.ai_maxdata	= 0xfff,
+		.ao_maxdata	= 0xfff,
+		.fifo		= 1,
+		.is_818		= 1,
+	}, {
+		.name		= "pcl818",
+		.n_ranges	= 9,
+		.n_aichan_se	= 16,
+		.n_aichan_diff	= 8,
+		.ns_min		= 10000,
+		.n_aochan	= 2,
+		.n_dichan	= 16,
+		.n_dochan	= 16,
+		.ai_range_type	= &range_pcl818h_ai,
+		.ao_range_type	= &range_unipolar5,
+		.io_range	= PCLx1x_RANGE,
+		.IRQbits	= 0x00fc,
+		.DMAbits	= 0x0a,
+		.ai_maxdata	= 0xfff,
+		.ao_maxdata	= 0xfff,
+		.fifo		= 0,
+		.is_818		= 1,
+	}, {
+		.name		= "pcl718",
+		.n_ranges	= 1,
+		.n_aichan_se	= 16,
+		.n_aichan_diff	= 8,
+		.ns_min		= 16000,
+		.n_aochan	= 2,
+		.n_dichan	= 16,
+		.n_dochan	= 16,
+		.ai_range_type	= &range_unipolar5,
+		.ao_range_type	= &range_unipolar5,
+		.io_range	= PCLx1x_RANGE,
+		.IRQbits	= 0x00fc,
+		.DMAbits	= 0x0a,
+		.ai_maxdata	= 0xfff,
+		.ao_maxdata	= 0xfff,
+		.fifo		= 0,
+		.is_818		= 0,
+	}, {
+		.name		= "pcm3718",
+		.n_ranges	= 9,
+		.n_aichan_se	= 16,
+		.n_aichan_diff	= 8,
+		.ns_min		= 10000,
+		.n_aochan	= 0,
+		.n_dichan	= 16,
+		.n_dochan	= 16,
+		.ai_range_type	= &range_pcl818h_ai,
+		.ao_range_type	= &range_unipolar5,
+		.io_range	= PCLx1x_RANGE,
+		.IRQbits	= 0x00fc,
+		.DMAbits	= 0x0a,
+		.ai_maxdata	= 0xfff,
+		.ao_maxdata	= 0xfff,
+		.fifo		= 0,
+		.is_818		= 1,
+	},
+};
+
 struct pcl818_private {
 
 	unsigned int dma;	/*  used DMA, 0=don't use DMA */
@@ -1435,31 +1564,6 @@ static void pcl818_detach(struct comedi_device *dev)
 	comedi_legacy_detach(dev);
 }
 
-static const struct pcl818_board boardtypes[] = {
-	{"pcl818l", 4, 16, 8, 25000, 1, 16, 16, &range_pcl818l_l_ai,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 0, 1},
-	{"pcl818h", 9, 16, 8, 10000, 1, 16, 16, &range_pcl818h_ai,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 0, 1},
-	{"pcl818hd", 9, 16, 8, 10000, 1, 16, 16, &range_pcl818h_ai,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 1, 1},
-	{"pcl818hg", 12, 16, 8, 10000, 1, 16, 16, &range_pcl818hg_ai,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 1, 1},
-	{"pcl818", 9, 16, 8, 10000, 2, 16, 16, &range_pcl818h_ai,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 0, 1},
-	{"pcl718", 1, 16, 8, 16000, 2, 16, 16, &range_unipolar5,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 0, 0},
-	/* pcm3718 */
-	{"pcm3718", 9, 16, 8, 10000, 0, 16, 16, &range_pcl818h_ai,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 0, 1 /* XXX ? */ },
-};
-
 static struct comedi_driver pcl818_driver = {
 	.driver_name	= "pcl818",
 	.module		= THIS_MODULE,

commit 22ca19d93d92c79cff68270846a84bd34fe6fb34
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:45 2014 -0700

    staging: comedi: move (*insn_{read, write}) timeout debug messages to core
    
    Have the comedi core display a standard dev_dbg() message when a timeout
    occurs and remove all the driver specific messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index ff5cc1b8bed7..9087e54537ec 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -375,7 +375,6 @@ static int pcl818_ai_insn_read(struct comedi_device *dev,
 
 		ret = comedi_timeout(dev, s, insn, pcl818_ai_eoc, 0);
 		if (ret) {
-			comedi_error(dev, "A/D insn timeout");
 			/* clear INT (conversion end) flag */
 			outb(0, dev->iobase + PCL818_CLRINT);
 			return ret;

commit 1d6f4af9090021eb7a1074d30ebd991d43a639c6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:42 2014 -0700

    staging: comedi: pcl818: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input end-of-conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index fa1758ad49d5..ff5cc1b8bed7 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -336,16 +336,25 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 static void start_pacer(struct comedi_device *dev, int mode,
 			unsigned int divisor1, unsigned int divisor2);
 
-/*
-==============================================================================
-   ANALOG INPUT MODE0, 818 cards, slow version
-*/
+static int pcl818_ai_eoc(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 struct comedi_insn *insn,
+			 unsigned long context)
+{
+	unsigned int status;
+
+	status = inb(dev->iobase + PCL818_STATUS);
+	if (status & 0x10)
+		return 0;
+	return -EBUSY;
+}
+
 static int pcl818_ai_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
+	int ret;
 	int n;
-	int timeout;
 
 	/* software trigger, DMA and INT off */
 	outb(0, dev->iobase + PCL818_CONTROL);
@@ -364,18 +373,14 @@ static int pcl818_ai_insn_read(struct comedi_device *dev,
 		/* start conversion */
 		outb(0, dev->iobase + PCL818_AD_LO);
 
-		timeout = 100;
-		while (timeout--) {
-			if (inb(dev->iobase + PCL818_STATUS) & 0x10)
-				goto conv_finish;
-			udelay(1);
+		ret = comedi_timeout(dev, s, insn, pcl818_ai_eoc, 0);
+		if (ret) {
+			comedi_error(dev, "A/D insn timeout");
+			/* clear INT (conversion end) flag */
+			outb(0, dev->iobase + PCL818_CLRINT);
+			return ret;
 		}
-		comedi_error(dev, "A/D insn timeout");
-		/* clear INT (conversion end) flag */
-		outb(0, dev->iobase + PCL818_CLRINT);
-		return -EIO;
 
-conv_finish:
 		data[n] = ((inb(dev->iobase + PCL818_AD_HI) << 4) |
 			   (inb(dev->iobase + PCL818_AD_LO) >> 4));
 	}

commit 4cdd4eb2d3e11c124e8bbb6d01636ec3e9e5af70
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:31:01 2013 -0700

    staging: comedi: pcl818: tidy up comedi_lrange tables
    
    Tidy up the whitespace in the comedi_lrange tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 695e84a94ced..fa1758ad49d5 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -188,56 +188,78 @@ A word or two about DMA. Driver support DMA operations at two ways:
 
 #define MAGIC_DMA_WORD 0x5a5a
 
-static const struct comedi_lrange range_pcl818h_ai = { 9, {
-							   BIP_RANGE(5),
-							   BIP_RANGE(2.5),
-							   BIP_RANGE(1.25),
-							   BIP_RANGE(0.625),
-							   UNI_RANGE(10),
-							   UNI_RANGE(5),
-							   UNI_RANGE(2.5),
-							   UNI_RANGE(1.25),
-							   BIP_RANGE(10),
-							   }
+static const struct comedi_lrange range_pcl818h_ai = {
+	9, {
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		BIP_RANGE(0.625),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25),
+		BIP_RANGE(10)
+	}
+};
+
+static const struct comedi_lrange range_pcl818hg_ai = {
+	10, {
+		BIP_RANGE(5),
+		BIP_RANGE(0.5),
+		BIP_RANGE(0.05),
+		BIP_RANGE(0.005),
+		UNI_RANGE(10),
+		UNI_RANGE(1),
+		UNI_RANGE(0.1),
+		UNI_RANGE(0.01),
+		BIP_RANGE(10),
+		BIP_RANGE(1),
+		BIP_RANGE(0.1),
+		BIP_RANGE(0.01)
+	}
 };
 
-static const struct comedi_lrange range_pcl818hg_ai = { 10, {
-							     BIP_RANGE(5),
-							     BIP_RANGE(0.5),
-							     BIP_RANGE(0.05),
-							     BIP_RANGE(0.005),
-							     UNI_RANGE(10),
-							     UNI_RANGE(1),
-							     UNI_RANGE(0.1),
-							     UNI_RANGE(0.01),
-							     BIP_RANGE(10),
-							     BIP_RANGE(1),
-							     BIP_RANGE(0.1),
-							     BIP_RANGE(0.01),
-							     }
+static const struct comedi_lrange range_pcl818l_l_ai = {
+	4, {
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		BIP_RANGE(0.625)
+	}
 };
 
-static const struct comedi_lrange range_pcl818l_l_ai = { 4, {
-							     BIP_RANGE(5),
-							     BIP_RANGE(2.5),
-							     BIP_RANGE(1.25),
-							     BIP_RANGE(0.625),
-							     }
+static const struct comedi_lrange range_pcl818l_h_ai = {
+	4, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25)
+	}
 };
 
-static const struct comedi_lrange range_pcl818l_h_ai = { 4, {
-							     BIP_RANGE(10),
-							     BIP_RANGE(5),
-							     BIP_RANGE(2.5),
-							     BIP_RANGE(1.25),
-							     }
+static const struct comedi_lrange range718_bipolar1 = {
+	1, {
+		BIP_RANGE(1)
+	}
 };
 
-static const struct comedi_lrange range718_bipolar1 = { 1, {BIP_RANGE(1),} };
 static const struct comedi_lrange range718_bipolar0_5 = {
-	1, {BIP_RANGE(0.5),} };
-static const struct comedi_lrange range718_unipolar2 = { 1, {UNI_RANGE(2),} };
-static const struct comedi_lrange range718_unipolar1 = { 1, {BIP_RANGE(1),} };
+	1, {
+		BIP_RANGE(0.5)
+	}
+};
+
+static const struct comedi_lrange range718_unipolar2 = {
+	1, {
+		UNI_RANGE(2)
+	}
+};
+
+static const struct comedi_lrange range718_unipolar1 = {
+	1, {
+		BIP_RANGE(1)
+	}
+};
 
 struct pcl818_board {
 

commit 6464e2ff4303108b20fc60c45e843c95f314a814
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Dec 3 12:07:21 2013 -0700

    staging: comedi: pcl818: remove unnecessary s->len_chanlist init
    
    The subdevice 'len_chanlist' member is only used with async command
    support. Remove the initialization of this member for the subdevices
    that do not support commands. The core will then correctly initialize
    it to the default value of '1'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index fc587002f9cb..695e84a94ced 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1333,7 +1333,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
 		s->n_chan = board->n_aochan;
 		s->maxdata = board->ao_maxdata;
-		s->len_chanlist = board->n_aochan;
 		s->range_table = board->ao_range_type;
 		s->insn_read = pcl818_ao_insn_read;
 		s->insn_write = pcl818_ao_insn_write;
@@ -1358,7 +1357,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->subdev_flags = SDF_READABLE;
 		s->n_chan = board->n_dichan;
 		s->maxdata = 1;
-		s->len_chanlist = board->n_dichan;
 		s->range_table = &range_digital;
 		s->insn_bits = pcl818_di_insn_bits;
 	}
@@ -1371,7 +1369,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->subdev_flags = SDF_WRITABLE;
 		s->n_chan = board->n_dochan;
 		s->maxdata = 1;
-		s->len_chanlist = board->n_dochan;
 		s->range_table = &range_digital;
 		s->insn_bits = pcl818_do_insn_bits;
 	}

commit e4bfb085ed75ba3553b6621b67ed80550dcfdac3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Dec 3 12:07:20 2013 -0700

    staging: comedi: pcl818: use dev->read_subdev
    
    Use the dev->read_subdev that was setup in the device attach instead
    of accessing the dev->subdevices array directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index fb9141274e19..fc587002f9cb 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -439,7 +439,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[0];
+	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned char low;
 	int timeout = 50;	/* wait max 50us */
 
@@ -498,7 +498,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[0];
+	struct comedi_subdevice *s = dev->read_subdev;
 	int i, len, bufptr;
 	unsigned long flags;
 	unsigned short *ptr;
@@ -575,7 +575,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[0];
+	struct comedi_subdevice *s = dev->read_subdev;
 	int i, len;
 	unsigned char lo;
 
@@ -667,10 +667,9 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 			   being reprogrammed while a DMA transfer is in
 			   progress.
 			 */
-			struct comedi_subdevice *s = &dev->subdevices[0];
 			devpriv->ai_act_scan = 0;
 			devpriv->neverending_ai = 0;
-			pcl818_ai_cancel(dev, s);
+			pcl818_ai_cancel(dev, dev->read_subdev);
 		}
 
 		outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */

commit 89dac49eed7d82d8f9164dcf22f15ad228d43446
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Dec 3 12:07:19 2013 -0700

    staging: comedi: pcl818: remove 'sub_ai' from private data
    
    This member of the private data is a duplicate of the comedi_device
    'read_subdev' member. Remove the private data member and use the
    comedi_device member instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index ad1f34706643..fb9141274e19 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -290,7 +290,6 @@ struct pcl818_private {
 	unsigned int ai_data_len;	/*  len of data buffer */
 	unsigned int ai_timer1;	/*  timers */
 	unsigned int ai_timer2;
-	struct comedi_subdevice *sub_ai;	/*  ptr to AI subdevice */
 	unsigned char usefifo;	/*  1=use fifo */
 	unsigned int ao_readback[2];
 };
@@ -1269,7 +1268,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_UNUSED;
 	} else {
 		s->type = COMEDI_SUBD_AI;
-		devpriv->sub_ai = s;
 		s->subdev_flags = SDF_READABLE;
 		if (check_single_ended(dev->iobase)) {
 			s->n_chan = board->n_aichan_se;
@@ -1403,7 +1401,7 @@ static void pcl818_detach(struct comedi_device *dev)
 	struct pcl818_private *devpriv = dev->private;
 
 	if (devpriv) {
-		pcl818_ai_cancel(dev, devpriv->sub_ai);
+		pcl818_ai_cancel(dev, dev->read_subdev);
 		pcl818_reset(dev);
 		if (devpriv->dma)
 			free_dma(devpriv->dma);

commit 5d788d019c4c7c36878a5149f60b40bfeba26ea0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Dec 3 12:07:18 2013 -0700

    staging: comedi: pcl818: only init async command members when needed
    
    The 'len_chanlist' and 'cancel' members of the comedi_subdevice are
    only used with async command support. Only initialize them if the irq
    was sucessfully requested.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index e1fef1b57547..ad1f34706643 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1279,15 +1279,15 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			s->subdev_flags |= SDF_DIFF;
 		}
 		s->maxdata = board->ai_maxdata;
-		s->len_chanlist = s->n_chan;
 		s->range_table = board->ai_range_type;
-		s->cancel = pcl818_ai_cancel;
 		s->insn_read = pcl818_ai_insn_read;
 		if (dev->irq) {
 			dev->read_subdev = s;
 			s->subdev_flags |= SDF_CMD_READ;
+			s->len_chanlist = s->n_chan;
 			s->do_cmdtest = ai_cmdtest;
 			s->do_cmd = ai_cmd;
+			s->cancel = pcl818_ai_cancel;
 		}
 		if (board->is_818) {
 			if ((it->options[4] == 1) || (it->options[4] == 10))

commit 281b6e75fd95db1517406e0ec671691115de482d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Dec 3 12:07:17 2013 -0700

    staging: comedi: pcl818: remove function trace noise
    
    These kernel messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 5fc470800b01..e1fef1b57547 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -761,8 +761,6 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	int divisor1 = 0, divisor2 = 0;
 	unsigned int seglen;
 
-	dev_dbg(dev->class_dev, "pcl818_ai_cmd_mode()\n");
-
 	if (devpriv->irq_blocked)
 		return -EBUSY;
 
@@ -841,7 +839,6 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 
 	start_pacer(dev, mode, divisor1, divisor2);
 
-	dev_dbg(dev->class_dev, "pcl818_ai_cmd_mode() end\n");
 	return 0;
 }
 
@@ -1049,7 +1046,6 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
 
-	dev_dbg(dev->class_dev, "pcl818_ai_cmd()\n");
 	devpriv->ai_n_chan = cmd->chanlist_len;
 	devpriv->ai_chanlist = cmd->chanlist;
 	devpriv->ai_flags = cmd->flags;
@@ -1066,7 +1062,6 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		if (cmd->convert_src == TRIG_TIMER) {	/*  mode 1 */
 			devpriv->ai_timer1 = cmd->convert_arg;
 			retval = pcl818_ai_cmd_mode(1, dev, s);
-			dev_dbg(dev->class_dev, "pcl818_ai_cmd() end\n");
 			return retval;
 		}
 		if (cmd->convert_src == TRIG_EXT) {	/*  mode 3 */
@@ -1087,7 +1082,6 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	struct pcl818_private *devpriv = dev->private;
 
 	if (devpriv->irq_blocked > 0) {
-		dev_dbg(dev->class_dev, "pcl818_ai_cancel()\n");
 		devpriv->irq_was_now_closed = 1;
 
 		switch (devpriv->ai_mode) {
@@ -1131,7 +1125,6 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	}
 
 end:
-	dev_dbg(dev->class_dev, "pcl818_ai_cancel() end\n");
 	return 0;
 }
 

commit 1dcea26a226c18cb843014d1f68d88a89c784912
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Dec 3 12:07:16 2013 -0700

    staging: comedi: pcl818: remove unnecessary 'dev->irq' tests
    
    These functions can only be called if the irq was sucessfully requested.
    The dev->irq will always be valid.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 3dac1dd1372f..5fc470800b01 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -700,7 +700,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
-	if (!dev->irq || !devpriv->irq_blocked || !devpriv->ai_mode) {
+	if (!devpriv->irq_blocked || !devpriv->ai_mode) {
 		comedi_error(dev, "bad IRQ!");
 		return IRQ_NONE;
 	}
@@ -762,10 +762,6 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	unsigned int seglen;
 
 	dev_dbg(dev->class_dev, "pcl818_ai_cmd_mode()\n");
-	if (!dev->irq) {
-		comedi_error(dev, "IRQ not defined!");
-		return -EINVAL;
-	}
 
 	if (devpriv->irq_blocked)
 		return -EBUSY;

commit 35a8735d1cea548c12ca00e38fb56f91d053035b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Dec 3 12:07:15 2013 -0700

    staging: comedi: pcl818: remove 'irq_free' from private data
    
    This member of the private data is not needed. We can check if
    dev->irq is none zero instead. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index cacdca0983bb..3dac1dd1372f 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -274,7 +274,6 @@ struct pcl818_private {
 	unsigned char neverending_ai;	/*  if=1, then we do neverending record (you must use cancel()) */
 	unsigned int ns_min;	/*  manimal allowed delay between samples (in us) for actual card */
 	int i8253_osc_base;	/*  1/frequency of on board oscilator in ns */
-	int irq_free;		/*  1=have allocated IRQ */
 	int irq_blocked;	/*  1=IRQ now uses any subdev */
 	int irq_was_now_closed;	/*  when IRQ finish, there's stored int818_mode for last interrupt */
 	int ai_mode;		/*  who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma */
@@ -701,8 +700,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
-	if ((!dev->irq) || (!devpriv->irq_free) || (!devpriv->irq_blocked)
-	    || (!devpriv->ai_mode)) {
+	if (!dev->irq || !devpriv->irq_blocked || !devpriv->ai_mode) {
 		comedi_error(dev, "bad IRQ!");
 		return IRQ_NONE;
 	}
@@ -1230,10 +1228,8 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if ((1 << it->options[1]) & board->IRQbits) {
 		ret = request_irq(it->options[1], interrupt_pcl818, 0,
 				  dev->board_name, dev);
-		if (ret == 0) {
+		if (ret == 0)
 			dev->irq = it->options[1];
-			devpriv->irq_free = 1;
-		}
 	}
 
 	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
@@ -1242,7 +1238,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* grab our DMA */
 	dma = 0;
 	devpriv->dma = dma;
-	if (!devpriv->irq_free)
+	if (!dev->irq)
 		goto no_dma;	/* if we haven't IRQ, we can't use DMA */
 	if (board->DMAbits != 0) {	/* board support DMA */
 		dma = it->options[2];

commit d65e5b9d918aecd992947f1494ffb92b38c5f349
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:19 2013 -0700

    staging: comedi: pcl818: convert printk() messages to dev_{level}
    
    Convert the remaining printk messsages in this driver to dev_{level}.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 15b424733a9e..cacdca0983bb 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -463,10 +463,10 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
 	if ((low & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
-		printk
-		    ("comedi: A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
-		     (low & 0xf),
-		     devpriv->act_chanlist[devpriv->act_chanlist_pos]);
+		dev_dbg(dev->class_dev,
+			"A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
+			(low & 0xf),
+			devpriv->act_chanlist[devpriv->act_chanlist_pos]);
 		pcl818_ai_cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		comedi_event(dev, s);
@@ -532,11 +532,11 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 
 	for (i = 0; i < len; i++) {
 		if ((ptr[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
-			printk
-			    ("comedi: A/D mode1/3 DMA - channel dropout %d(card)!=%d(chanlist) at %d !\n",
-			     (ptr[bufptr] & 0xf),
-			     devpriv->act_chanlist[devpriv->act_chanlist_pos],
-			     devpriv->act_chanlist_pos);
+			dev_dbg(dev->class_dev,
+				"A/D mode1/3 DMA - channel dropout %d(card)!=%d(chanlist) at %d !\n",
+				(ptr[bufptr] & 0xf),
+				devpriv->act_chanlist[devpriv->act_chanlist_pos],
+				devpriv->act_chanlist_pos);
 			pcl818_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			comedi_event(dev, s);
@@ -609,10 +609,10 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 	for (i = 0; i < len; i++) {
 		lo = inb(dev->iobase + PCL818_FI_DATALO);
 		if ((lo & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
-			printk
-			    ("comedi: A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
-			     (lo & 0xf),
-			     devpriv->act_chanlist[devpriv->act_chanlist_pos]);
+			dev_dbg(dev->class_dev,
+				"A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
+				(lo & 0xf),
+				devpriv->act_chanlist[devpriv->act_chanlist_pos]);
 			pcl818_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			comedi_event(dev, s);
@@ -1249,7 +1249,8 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (dma < 1)
 			goto no_dma;	/* DMA disabled */
 		if (((1 << dma) & board->DMAbits) == 0) {
-			printk(KERN_ERR "DMA is out of allowed range, FAIL!\n");
+			dev_err(dev->class_dev,
+				"DMA is out of allowed range, FAIL!\n");
 			return -EINVAL;	/* Bad DMA */
 		}
 		ret = request_dma(dma, dev->board_name);

commit e30b22a9ccbe0b3c2e9c68ab3e46c69f56c3ae35
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:18 2013 -0700

    staging: comedi: pcl818: tidy up the irq support in pcl818_attach()
    
    Tidy up the code that does the request_irq().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 945a5dd4ec48..15b424733a9e 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1204,7 +1204,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct pcl818_board *board = comedi_board(dev);
 	struct pcl818_private *devpriv;
 	int ret;
-	unsigned int irq;
 	int dma;
 	unsigned long pages;
 	struct comedi_subdevice *s;
@@ -1228,28 +1227,15 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EIO;
 	}
 
-	/* grab our IRQ */
-	irq = 0;
-	if (board->IRQbits != 0) {	/* board support IRQ */
-		irq = it->options[1];
-		if (irq) {	/* we want to use IRQ */
-			if (((1 << irq) & board->IRQbits) == 0) {
-				irq = 0;	/* Bad IRQ */
-			} else {
-				if (request_irq(irq, interrupt_pcl818, 0,
-						dev->board_name, dev)) {
-					irq = 0;	/* Can't use IRQ */
-				}
-			}
+	if ((1 << it->options[1]) & board->IRQbits) {
+		ret = request_irq(it->options[1], interrupt_pcl818, 0,
+				  dev->board_name, dev);
+		if (ret == 0) {
+			dev->irq = it->options[1];
+			devpriv->irq_free = 1;
 		}
 	}
 
-	dev->irq = irq;
-	if (irq)
-		devpriv->irq_free = 1;   /* 1=we have allocated irq */
-	else
-		devpriv->irq_free = 0;
-
 	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
 	devpriv->ai_mode = 0;	/* mode of irq */
 
@@ -1311,7 +1297,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->range_table = board->ai_range_type;
 		s->cancel = pcl818_ai_cancel;
 		s->insn_read = pcl818_ai_insn_read;
-		if (irq) {
+		if (dev->irq) {
 			dev->read_subdev = s;
 			s->subdev_flags |= SDF_CMD_READ;
 			s->do_cmdtest = ai_cmdtest;

commit eeb6f2d3b7406e569c718f265100cce0227841bd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:17 2013 -0700

    staging: comedi: pcl818: remove board attach noise
    
    These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 931aed0e2c23..945a5dd4ec48 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1234,16 +1234,10 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		irq = it->options[1];
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & board->IRQbits) == 0) {
-				printk
-				    (", IRQ %u is out of allowed range, DISABLING IT",
-				     irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
 				if (request_irq(irq, interrupt_pcl818, 0,
 						dev->board_name, dev)) {
-					printk
-					    (", unable to allocate IRQ %u, DISABLING IT",
-					     irq);
 					irq = 0;	/* Can't use IRQ */
 				}
 			}
@@ -1308,11 +1302,9 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (check_single_ended(dev->iobase)) {
 			s->n_chan = board->n_aichan_se;
 			s->subdev_flags |= SDF_COMMON | SDF_GROUND;
-			printk(", %dchans S.E. DAC", s->n_chan);
 		} else {
 			s->n_chan = board->n_aichan_diff;
 			s->subdev_flags |= SDF_DIFF;
-			printk(", %dchans DIFF DAC", s->n_chan);
 		}
 		s->maxdata = board->ai_maxdata;
 		s->len_chanlist = s->n_chan;
@@ -1431,8 +1423,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	pcl818_reset(dev);
 
-	printk("\n");
-
 	return 0;
 }
 

commit de4ea8e3c1d6fa5af584e48bfe321c9cff2a79fc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:16 2013 -0700

    staging: comedi: pcl818: remove printk function trace messages
    
    These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 5b968003e16e..931aed0e2c23 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -522,7 +522,6 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 		release_dma_lock(flags);
 		enable_dma(devpriv->dma);
 	}
-	printk("comedi: A/D mode1/3 IRQ \n");
 
 	devpriv->dma_runs_to_end--;
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
@@ -723,7 +722,6 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 	unsigned int flags;
 	unsigned int bytes;
 
-	printk("mode13dma_int, mode: %d\n", mode);
 	disable_dma(devpriv->dma);	/*  disable dma */
 	bytes = devpriv->hwdmasize[0];
 	if (!devpriv->neverending_ai) {
@@ -929,7 +927,6 @@ static int check_channel_list(struct comedi_device *dev,
 	} else {
 		seglen = 1;
 	}
-	printk("check_channel_list: seglen %d\n", seglen);
 	return seglen;
 }
 

commit aad6fd1fca730c89058a7b399790369772cb30f7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:15 2013 -0700

    staging: comedi: pcl818: remove commented out printk debug
    
    These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index def79c5b1a66..5b968003e16e 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -478,7 +478,6 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 
 	s->async->cur_chan++;
 	if (s->async->cur_chan >= devpriv->ai_n_chan) {
-		/*  printk("E"); */
 		s->async->cur_chan = 0;
 		devpriv->ai_act_scan--;
 	}
@@ -562,7 +561,6 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 				pcl818_ai_cancel(dev, s);
 				s->async->events |= COMEDI_CB_EOA;
 				comedi_event(dev, s);
-				/*  printk("done int ai13 dma\n"); */
 				return IRQ_HANDLED;
 			}
 	}
@@ -661,7 +659,6 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 		comedi_error(dev, "premature interrupt");
 		return IRQ_HANDLED;
 	}
-	/* printk("I\n"); */
 
 	if (devpriv->irq_blocked && devpriv->irq_was_now_closed) {
 		if ((devpriv->neverending_ai || (!devpriv->neverending_ai &&
@@ -824,7 +821,6 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	case 0:
 		if (!devpriv->usefifo) {
 			/* IRQ */
-			/* printk("IRQ\n"); */
 			if (mode == 1) {
 				devpriv->ai_mode = INT_TYPE_AI1_INT;
 				/* Pacer+IRQ */
@@ -899,10 +895,6 @@ static int check_channel_list(struct comedi_device *dev,
 		chansegment[0] = chanlist[0];
 		/*  build part of chanlist */
 		for (i = 1, seglen = 1; i < n_chan; i++, seglen++) {
-
-			/* printk("%d. %d * %d\n",i,
-			 * CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i]));*/
-
 			/* we detect loop, this must by finish */
 
 			if (chanlist[0] == chanlist[i])
@@ -922,7 +914,6 @@ static int check_channel_list(struct comedi_device *dev,
 
 		/*  check whole chanlist */
 		for (i = 0, segpos = 0; i < n_chan; i++) {
-			/* printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i])); */
 			if (chanlist[i] != chansegment[i % seglen]) {
 				dev_dbg(dev->class_dev,
 					"bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
@@ -1296,7 +1287,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->dmapages[0] = pages;
 		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
 		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
-		/* printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
 		devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 		if (!devpriv->dmabuf[1])
 			return -EBUSY;

commit 84f03cf1d5912da90eca069a3458a3aea5d5fa8a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:41:37 2013 -0700

    staging: comedi: pcl818: convert some printk's to dev_dbg()
    
    Convert these messages to dev_dbg() and tidy them up a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index be9cb8df877d..def79c5b1a66 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -910,10 +910,10 @@ static int check_channel_list(struct comedi_device *dev,
 			nowmustbechan =
 			    (CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continuous :-( */
-				printk
-				    ("comedi%d: pcl818: channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\n",
-				     dev->minor, i, CR_CHAN(chanlist[i]),
-				     nowmustbechan, CR_CHAN(chanlist[0]));
+				dev_dbg(dev->class_dev,
+					"channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\n",
+					i, CR_CHAN(chanlist[i]), nowmustbechan,
+					CR_CHAN(chanlist[0]));
 				return 0;
 			}
 			/*  well, this is next correct channel in list */
@@ -924,14 +924,14 @@ static int check_channel_list(struct comedi_device *dev,
 		for (i = 0, segpos = 0; i < n_chan; i++) {
 			/* printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i])); */
 			if (chanlist[i] != chansegment[i % seglen]) {
-				printk
-				    ("comedi%d: pcl818: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
-				     dev->minor, i, CR_CHAN(chansegment[i]),
-				     CR_RANGE(chansegment[i]),
-				     CR_AREF(chansegment[i]),
-				     CR_CHAN(chanlist[i % seglen]),
-				     CR_RANGE(chanlist[i % seglen]),
-				     CR_AREF(chansegment[i % seglen]));
+				dev_dbg(dev->class_dev,
+					"bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
+					i, CR_CHAN(chansegment[i]),
+					CR_RANGE(chansegment[i]),
+					CR_AREF(chansegment[i]),
+					CR_CHAN(chanlist[i % seglen]),
+					CR_RANGE(chanlist[i % seglen]),
+					CR_AREF(chansegment[i % seglen]));
 				return 0;	/*  chan/gain list is strange */
 			}
 		}

commit 7567e83039598af34b867a9b4abef1a0d90f7381
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:29 2013 -0700

    staging: comedi: pcl818: remove an unnecessary printk(KERN_DEBUG ...
    
    This debug message is just added noise. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 8b5e9c097349..be9cb8df877d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1257,8 +1257,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 					    (", unable to allocate IRQ %u, DISABLING IT",
 					     irq);
 					irq = 0;	/* Can't use IRQ */
-				} else {
-					printk(KERN_DEBUG "irq=%u", irq);
 				}
 			}
 		}

commit 4b5c08e85d5dbbe6c22e47b5cf4401be2639e9e5
Author: Teodora Baluta <teobaluta@gmail.com>
Date:   Mon Nov 4 20:13:11 2013 +0200

    staging: comedi: remove unneeded semicolon
    
    There is no need for ';' after '}'. This minor fix was suggested by
    coccinelle.
    
    Signed-off-by: Teodora Baluta <teobaluta@gmail.com>
    Reviewed-by: Lisa Nguyen <lisa@xenapiadmin.com>
    Reviewed-by: Peter P Waskiewicz Jr <peter.p.waskiewicz.jr@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 9e4d7e860509..8b5e9c097349 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -753,7 +753,7 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 	} else {
 		devpriv->ai_mode = INT_TYPE_AI3_DMA;
 		outb(0x86 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Ext trig+IRQ+DMA */
-	};
+	}
 }
 
 /*

commit 4bf59ce248250f4c847a2a9d51713233c88f1d0f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:31 2013 +0100

    staging: comedi: pcl818: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Change the interrupt data transfer functions in the "pcl818" module to
    use unsigned types for consistency.
    
    Also remove the `short *ai_data` member of `struct pcl818_private` as it
    is only assigned to and otherwise unused.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 7be0c946bd7c..9e4d7e860509 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -289,7 +289,6 @@ struct pcl818_private {
 	unsigned int *ai_chanlist;	/*  actaul chanlist */
 	unsigned int ai_flags;	/*  flaglist */
 	unsigned int ai_data_len;	/*  len of data buffer */
-	short *ai_data;		/*  data buffer */
 	unsigned int ai_timer1;	/*  timers */
 	unsigned int ai_timer2;
 	struct comedi_subdevice *sub_ai;	/*  ptr to AI subdevice */
@@ -443,7 +442,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[0];
-	int low;
+	unsigned char low;
 	int timeout = 50;	/* wait max 50us */
 
 	while (timeout--) {
@@ -505,7 +504,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 	struct comedi_subdevice *s = &dev->subdevices[0];
 	int i, len, bufptr;
 	unsigned long flags;
-	short *ptr;
+	unsigned short *ptr;
 
 	disable_dma(devpriv->dma);
 	devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
@@ -528,7 +527,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 
 	devpriv->dma_runs_to_end--;
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
-	ptr = (short *)devpriv->dmabuf[1 - devpriv->next_dma_buf];
+	ptr = (unsigned short *)devpriv->dmabuf[1 - devpriv->next_dma_buf];
 
 	len = devpriv->hwdmasize[0] >> 1;
 	bufptr = 0;
@@ -582,7 +581,8 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[0];
-	int i, len, lo;
+	int i, len;
+	unsigned char lo;
 
 	outb(0, dev->iobase + PCL818_FI_INTCLR);	/*  clear fifo int request */
 
@@ -1072,7 +1072,6 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_chanlist = cmd->chanlist;
 	devpriv->ai_flags = cmd->flags;
 	devpriv->ai_data_len = s->async->prealloc_bufsz;
-	devpriv->ai_data = s->async->prealloc_buf;
 	devpriv->ai_timer1 = 0;
 	devpriv->ai_timer2 = 0;
 

commit cb9cfd7ed3f6ed4c40167b4251cdb382b6b3ba1c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 26 11:40:15 2013 -0700

    staging: comedi: 8253.h: tidy up the i8253_cascade_ns_to_timer*() users
    
    Introduce a couple defines for the common 8254 oscillator base values
    used in the comedi drivers and remove the custom defines and open
    coded values.
    
    Change the i8253_cascade_ns_to_timer_2div() calls in the drivers to
    the more generic i8253_cascade_ns_to_timer(). They are identical due
    to the #define in the 8253.h header.
    
    Remove the extra mask by TRIG_ROUND_MASK of the 'round_mode' parameter
    to i8253_cascade_ns_to_timer(). That function already handles the mask.
    
    Tidy up all the calls to i8253_cascade_ns_to_timer().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 33cd4aae884e..7be0c946bd7c 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -800,8 +800,9 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 		devpriv->neverending_ai = 1;	/* well, user want neverending */
 
 	if (mode == 1) {
-		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
-					  &divisor2, &cmd->convert_arg,
+		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base,
+					  &divisor1, &divisor2,
+					  &cmd->convert_arg,
 					  TRIG_ROUND_NEAREST);
 		if (divisor1 == 1) {	/* PCL718/818 crash if any divisor is set to 1 */
 			divisor1 = 2;
@@ -1034,9 +1035,9 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
-		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
-					  &divisor2, &cmd->convert_arg,
-					  cmd->flags & TRIG_ROUND_MASK);
+		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base,
+					  &divisor1, &divisor2,
+					  &cmd->convert_arg, cmd->flags);
 		if (cmd->convert_arg < board->ns_min)
 			cmd->convert_arg = board->ns_min;
 		if (tmp != cmd->convert_arg)
@@ -1432,9 +1433,9 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* select 1/10MHz oscilator */
 	if ((it->options[3] == 0) || (it->options[3] == 10))
-		devpriv->i8253_osc_base = 100;
+		devpriv->i8253_osc_base = I8254_OSC_BASE_10MHZ;
 	else
-		devpriv->i8253_osc_base = 1000;
+		devpriv->i8253_osc_base = I8254_OSC_BASE_1MHZ;
 
 	/* max sampling speed */
 	devpriv->ns_min = board->ns_min;

commit 97f4289ad08cffe55de06d4ac4f89ac540450aee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:05:58 2013 -0700

    staging: comedi: drivers: use comedi_dio_update_state() for simple cases
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state for simple cases where the hardware is updated
    when any channel is modified.
    
    Also, fix a bug in the amplc_pc263 and amplc_pci263 drivers where the
    current state is not returned in data[1].
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index a52ba82ff0e4..33cd4aae884e 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -418,21 +418,15 @@ static int pcl818_di_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-/*
-==============================================================================
-   DIGITAL OUTPUT MODE0, 818 cards
-
-   only one sample per call is supported
-*/
 static int pcl818_do_insn_bits(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
+			       struct comedi_insn *insn,
+			       unsigned int *data)
 {
-	s->state &= ~data[0];
-	s->state |= (data[0] & data[1]);
-
-	outb(s->state & 0xff, dev->iobase + PCL818_DO_LO);
-	outb((s->state >> 8), dev->iobase + PCL818_DO_HI);
+	if (comedi_dio_update_state(s, data)) {
+		outb(s->state & 0xff, dev->iobase + PCL818_DO_LO);
+		outb((s->state >> 8), dev->iobase + PCL818_DO_HI);
+	}
 
 	data[1] = s->state;
 

commit 8e6b7915a1da703617dca28c33e150141fcec9b0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:05:07 2013 -0700

    staging: comedi: drivers do not need <linux/ioport.h>
    
    All the ioport resources are managed by the comedi core. None of
    the drivers depend on <linux/ioport.h>. Remove the includes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 48042967065d..a52ba82ff0e4 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -99,7 +99,6 @@ A word or two about DMA. Driver support DMA operations at two ways:
 */
 
 #include <linux/module.h>
-#include <linux/ioport.h>
 #include <linux/gfp.h>
 #include <linux/delay.h>
 #include <linux/io.h>

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 55f10e754c76..48042967065d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -98,6 +98,7 @@ A word or two about DMA. Driver support DMA operations at two ways:
 
 */
 
+#include <linux/module.h>
 #include <linux/ioport.h>
 #include <linux/gfp.h>
 #include <linux/delay.h>

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 91cb1bd6717f..55f10e754c76 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1227,10 +1227,9 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned long pages;
 	struct comedi_subdevice *s;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	devpriv->io_range = board->io_range;
 	if ((board->fifo) && (it->options[2] == -1)) {

commit aecfd1ec015397ec7a159ebb3a8c48202e0ac9a5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 19 17:14:06 2013 -0700

    staging: comedi: pcl818: remove unused RTC dma support
    
    All the RTC dma support code in this driver is #ifdef'ed out.
    
    Remove the unused code to assist in cleaning up this driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 142449d7f8b4..91cb1bd6717f 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -98,15 +98,15 @@ A word or two about DMA. Driver support DMA operations at two ways:
 
 */
 
-#include "../comedidev.h"
-
 #include <linux/ioport.h>
-#include <linux/mc146818rtc.h>
 #include <linux/gfp.h>
 #include <linux/delay.h>
 #include <linux/io.h>
+#include <linux/interrupt.h>
 #include <asm/dma.h>
 
+#include "../comedidev.h"
+
 #include "comedi_fc.h"
 #include "8253.h"
 
@@ -186,15 +186,6 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define INT_TYPE_AO3_INT 8
 #endif
 
-#ifdef unused
-/* RTC stuff... */
-#define INT_TYPE_AI1_DMA_RTC 9
-#define INT_TYPE_AI3_DMA_RTC 10
-
-#define RTC_IRQ 	8
-#define RTC_IO_EXTENT	0x10
-#endif
-
 #define MAGIC_DMA_WORD 0x5a5a
 
 static const struct comedi_lrange range_pcl818h_ai = { 9, {
@@ -248,11 +239,6 @@ static const struct comedi_lrange range718_bipolar0_5 = {
 static const struct comedi_lrange range718_unipolar2 = { 1, {UNI_RANGE(2),} };
 static const struct comedi_lrange range718_unipolar1 = { 1, {BIP_RANGE(1),} };
 
-#ifdef unused
-static int RTC_lock;	/* RTC lock */
-static int RTC_timer_lock;	/* RTC int lock */
-#endif
-
 struct pcl818_board {
 
 	const char *name;	/*  driver name */
@@ -277,22 +263,11 @@ struct pcl818_board {
 struct pcl818_private {
 
 	unsigned int dma;	/*  used DMA, 0=don't use DMA */
-	int dma_rtc;		/*  1=RTC used with DMA, 0=no RTC alloc */
 	unsigned int io_range;
-#ifdef unused
-	unsigned long rtc_iobase;	/*  RTC port region */
-	unsigned int rtc_iosize;
-	unsigned int rtc_irq;
-	struct timer_list rtc_irq_timer;	/*  timer for RTC sanity check */
-	unsigned long rtc_freq;	/*  RTC int freq */
-	int rtc_irq_blocked;	/*  1=we now do AI with DMA&RTC */
-#endif
 	unsigned long dmabuf[2];	/*  pointers to begin of DMA buffers */
 	unsigned int dmapages[2];	/*  len of DMA buffers in PAGE_SIZEs */
 	unsigned int hwdmaptr[2];	/*  hardware address of DMA buffers */
 	unsigned int hwdmasize[2];	/*  len of DMA buffers in Bytes */
-	unsigned int dmasamplsize;	/*  size in samples hwdmasize[0]/2 */
-	unsigned int last_top_dma;	/*  DMA pointer in last RTC int */
 	int next_dma_buf;	/*  which DMA buffer will be used next round */
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
@@ -342,12 +317,6 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 static void start_pacer(struct comedi_device *dev, int mode,
 			unsigned int divisor1, unsigned int divisor2);
 
-#ifdef unused
-static int set_rtc_irq_bit(unsigned char bit);
-static void rtc_dropped_irq(unsigned long data);
-static int rtc_setfreq_irq(int freq);
-#endif
-
 /*
 ==============================================================================
    ANALOG INPUT MODE0, 818 cards, slow version
@@ -610,113 +579,6 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-#ifdef unused
-/*
-==============================================================================
-   analog input dma mode 1 & 3 over RTC, 818 cards
-*/
-static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
-{
-	struct comedi_device *dev = d;
-	struct pcl818_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[0];
-	unsigned long tmp;
-	unsigned int top1, top2, i, bufptr;
-	long ofs_dats;
-	short *dmabuf = (short *)devpriv->dmabuf[0];
-
-	/* outb(2,0x378); */
-	switch (devpriv->ai_mode) {
-	case INT_TYPE_AI1_DMA_RTC:
-	case INT_TYPE_AI3_DMA_RTC:
-		tmp = (CMOS_READ(RTC_INTR_FLAGS) & 0xF0);
-		mod_timer(&devpriv->rtc_irq_timer,
-			  jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100);
-
-		for (i = 0; i < 10; i++) {
-			top1 = get_dma_residue(devpriv->dma);
-			top2 = get_dma_residue(devpriv->dma);
-			if (top1 == top2)
-				break;
-		}
-
-		if (top1 != top2)
-			return IRQ_HANDLED;
-		top1 = devpriv->hwdmasize[0] - top1;	/*  where is now DMA in buffer */
-		top1 >>= 1;
-		ofs_dats = top1 - devpriv->last_top_dma;	/*  new samples from last call */
-		if (ofs_dats < 0)
-			ofs_dats = (devpriv->dmasamplsize) + ofs_dats;
-		if (!ofs_dats)
-			return IRQ_HANDLED;	/*  exit=no new samples from last call */
-		/*  obsluz data */
-		i = devpriv->last_top_dma - 1;
-		i &= (devpriv->dmasamplsize - 1);
-
-		if (dmabuf[i] != MAGIC_DMA_WORD) {	/*  DMA overflow! */
-			comedi_error(dev, "A/D mode1/3 DMA buffer overflow!");
-			/* printk("I %d dmabuf[i] %d %d\n",i,dmabuf[i],devpriv->dmasamplsize); */
-			pcl818_ai_cancel(dev, s);
-			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
-			comedi_event(dev, s);
-			return IRQ_HANDLED;
-		}
-		/* printk("r %ld ",ofs_dats); */
-
-		bufptr = devpriv->last_top_dma;
-
-		for (i = 0; i < ofs_dats; i++) {
-			if ((dmabuf[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
-				printk
-				    ("comedi: A/D mode1/3 DMA - channel dropout %d!=%d !\n",
-				     (dmabuf[bufptr] & 0xf),
-				     devpriv->
-				     act_chanlist[devpriv->act_chanlist_pos]);
-				pcl818_ai_cancel(dev, s);
-				s->async->events |=
-				    COMEDI_CB_EOA | COMEDI_CB_ERROR;
-				comedi_event(dev, s);
-				return IRQ_HANDLED;
-			}
-
-			comedi_buf_put(s->async, dmabuf[bufptr++] >> 4);	/*  get one sample */
-			bufptr &= (devpriv->dmasamplsize - 1);
-
-			devpriv->act_chanlist_pos++;
-			if (devpriv->act_chanlist_pos >=
-					devpriv->act_chanlist_len) {
-				devpriv->act_chanlist_pos = 0;
-			}
-			s->async->cur_chan++;
-			if (s->async->cur_chan >= devpriv->ai_n_chan) {
-				s->async->cur_chan = 0;
-				devpriv->ai_act_scan--;
-			}
-
-			if (!devpriv->neverending_ai)
-				if (devpriv->ai_act_scan == 0) {	/* all data sampled */
-					pcl818_ai_cancel(dev, s);
-					s->async->events |= COMEDI_CB_EOA;
-					comedi_event(dev, s);
-					/* printk("done int ai13 dma\n"); */
-					return IRQ_HANDLED;
-				}
-		}
-
-		devpriv->last_top_dma = bufptr;
-		bufptr--;
-		bufptr &= (devpriv->dmasamplsize - 1);
-		dmabuf[bufptr] = MAGIC_DMA_WORD;
-		comedi_event(dev, s);
-		/* outb(0,0x378); */
-		return IRQ_HANDLED;
-	}
-
-	/* outb(0,0x378); */
-	return IRQ_HANDLED;
-}
-#endif
-
 /*
 ==============================================================================
    analog input interrupt mode 1 & 3, 818HD/HG cards
@@ -900,49 +762,6 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 	};
 }
 
-#ifdef unused
-/*
-==============================================================================
-   ANALOG INPUT MODE 1 or 3 DMA rtc, 818 cards
-*/
-static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device *dev,
-				    struct comedi_subdevice *s)
-{
-	struct pcl818_private *devpriv = dev->private;
-	unsigned int flags;
-	short *pole;
-
-	set_dma_mode(devpriv->dma, DMA_MODE_READ | DMA_AUTOINIT);
-	flags = claim_dma_lock();
-	clear_dma_ff(devpriv->dma);
-	set_dma_addr(devpriv->dma, devpriv->hwdmaptr[0]);
-	set_dma_count(devpriv->dma, devpriv->hwdmasize[0]);
-	release_dma_lock(flags);
-	enable_dma(devpriv->dma);
-	devpriv->last_top_dma = 0;	/* devpriv->hwdmasize[0]; */
-	pole = (short *)devpriv->dmabuf[0];
-	devpriv->dmasamplsize = devpriv->hwdmasize[0] / 2;
-	pole[devpriv->dmasamplsize - 1] = MAGIC_DMA_WORD;
-#ifdef unused
-	devpriv->rtc_freq = rtc_setfreq_irq(2048);
-	devpriv->rtc_irq_timer.expires =
-	    jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100;
-	devpriv->rtc_irq_timer.data = (unsigned long)dev;
-	devpriv->rtc_irq_timer.function = rtc_dropped_irq;
-
-	add_timer(&devpriv->rtc_irq_timer);
-#endif
-
-	if (mode == 1) {
-		devpriv->int818_mode = INT_TYPE_AI1_DMA_RTC;
-		outb(0x07 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Pacer+DMA */
-	} else {
-		devpriv->int818_mode = INT_TYPE_AI3_DMA_RTC;
-		outb(0x06 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Ext trig+DMA */
-	};
-}
-#endif
-
 /*
 ==============================================================================
    ANALOG INPUT MODE 1 or 3, 818 cards
@@ -956,7 +775,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	unsigned int seglen;
 
 	dev_dbg(dev->class_dev, "pcl818_ai_cmd_mode()\n");
-	if ((!dev->irq) && (!devpriv->dma_rtc)) {
+	if (!dev->irq) {
 		comedi_error(dev, "IRQ not defined!");
 		return -EINVAL;
 	}
@@ -1005,15 +824,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	switch (devpriv->dma) {
 	case 1:		/*  DMA */
 	case 3:
-		if (devpriv->dma_rtc == 0)
-			pcl818_ai_mode13dma_int(mode, dev, s);
-#ifdef unused
-		else
-			pcl818_ai_mode13dma_rtc(mode, dev, s);
-#else
-		else
-			return -EINVAL;
-#endif
+		pcl818_ai_mode13dma_int(mode, dev, s);
 		break;
 	case 0:
 		if (!devpriv->usefifo) {
@@ -1047,97 +858,10 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 
 	start_pacer(dev, mode, divisor1, divisor2);
 
-#ifdef unused
-	switch (devpriv->ai_mode) {
-	case INT_TYPE_AI1_DMA_RTC:
-	case INT_TYPE_AI3_DMA_RTC:
-		set_rtc_irq_bit(1);	/* start RTC */
-		break;
-	}
-#endif
 	dev_dbg(dev->class_dev, "pcl818_ai_cmd_mode() end\n");
 	return 0;
 }
 
-#ifdef unused
-/*
-==============================================================================
-   ANALOG OUTPUT MODE 1 or 3, 818 cards
-*/
-#ifdef PCL818_MODE13_AO
-static int pcl818_ao_mode13(int mode, struct comedi_device *dev,
-			    struct comedi_subdevice *s, comedi_trig *it)
-{
-	struct pcl818_private *devpriv = dev->private;
-	int divisor1 = 0, divisor2 = 0;
-
-	if (!dev->irq) {
-		comedi_error(dev, "IRQ not defined!");
-		return -EINVAL;
-	}
-
-	if (devpriv->irq_blocked)
-		return -EBUSY;
-
-	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
-
-	devpriv->int13_act_scan = it->n;
-	devpriv->int13_act_chan = 0;
-	devpriv->irq_blocked = 1;
-	devpriv->irq_was_now_closed = 0;
-	devpriv->neverending_ai = 0;
-	devpriv->act_chanlist_pos = 0;
-
-	if (mode == 1) {
-		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
-					  &divisor2, &it->trigvar,
-					  TRIG_ROUND_NEAREST);
-		if (divisor1 == 1) {	/* PCL818 crash if any divisor is set to 1 */
-			divisor1 = 2;
-			divisor2 /= 2;
-		}
-		if (divisor2 == 1) {
-			divisor2 = 2;
-			divisor1 /= 2;
-		}
-	}
-
-	outb(0, dev->iobase + PCL818_CNTENABLE);	/* enable pacer */
-	if (mode == 1) {
-		devpriv->int818_mode = INT_TYPE_AO1_INT;
-		outb(0x83 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Pacer+IRQ */
-	} else {
-		devpriv->int818_mode = INT_TYPE_AO3_INT;
-		outb(0x82 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Ext trig+IRQ */
-	};
-
-	start_pacer(dev, mode, divisor1, divisor2);
-
-	return 0;
-}
-
-/*
-==============================================================================
-   ANALOG OUTPUT MODE 1, 818 cards
-*/
-static int pcl818_ao_mode1(struct comedi_device *dev,
-			   struct comedi_subdevice *s, comedi_trig *it)
-{
-	return pcl818_ao_mode13(1, dev, s, it);
-}
-
-/*
-==============================================================================
-   ANALOG OUTPUT MODE 3, 818 cards
-*/
-static int pcl818_ao_mode3(struct comedi_device *dev,
-			   struct comedi_subdevice *s, comedi_trig *it)
-{
-	return pcl818_ao_mode13(3, dev, s, it);
-}
-#endif
-#endif
-
 /*
 ==============================================================================
  Start/stop pacer onboard pacer
@@ -1391,12 +1115,6 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 		devpriv->irq_was_now_closed = 1;
 
 		switch (devpriv->ai_mode) {
-#ifdef unused
-		case INT_TYPE_AI1_DMA_RTC:
-		case INT_TYPE_AI3_DMA_RTC:
-			set_rtc_irq_bit(0);	/*  stop RTC */
-			del_timer(&devpriv->rtc_irq_timer);
-#endif
 		case INT_TYPE_AI1_DMA:
 		case INT_TYPE_AI3_DMA:
 			if (devpriv->neverending_ai ||
@@ -1499,96 +1217,6 @@ static void pcl818_reset(struct comedi_device *dev)
 	}
 }
 
-#ifdef unused
-/*
-==============================================================================
-  Enable(1)/disable(0) periodic interrupts from RTC
-*/
-static int set_rtc_irq_bit(unsigned char bit)
-{
-	unsigned char val;
-	unsigned long flags;
-
-	if (bit == 1) {
-		RTC_timer_lock++;
-		if (RTC_timer_lock > 1)
-			return 0;
-	} else {
-		RTC_timer_lock--;
-		if (RTC_timer_lock < 0)
-			RTC_timer_lock = 0;
-		if (RTC_timer_lock > 0)
-			return 0;
-	}
-
-	save_flags(flags);
-	cli();
-	val = CMOS_READ(RTC_CONTROL);
-	if (bit)
-		val |= RTC_PIE;
-	else
-		val &= ~RTC_PIE;
-
-	CMOS_WRITE(val, RTC_CONTROL);
-	CMOS_READ(RTC_INTR_FLAGS);
-	restore_flags(flags);
-	return 0;
-}
-
-/*
-==============================================================================
-  Restart RTC if something stop it (xntpd every 11 mins or large IDE transfers)
-*/
-static void rtc_dropped_irq(unsigned long data)
-{
-	struct comedi_device *dev = (void *)data;
-	struct pcl818_private *devpriv = dev->private;
-	unsigned long flags, tmp;
-
-	switch (devpriv->int818_mode) {
-	case INT_TYPE_AI1_DMA_RTC:
-	case INT_TYPE_AI3_DMA_RTC:
-		mod_timer(&devpriv->rtc_irq_timer,
-			  jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100);
-		save_flags(flags);
-		cli();
-		tmp = (CMOS_READ(RTC_INTR_FLAGS) & 0xF0);	/* restart */
-		restore_flags(flags);
-		break;
-	}
-}
-
-/*
-==============================================================================
-  Set frequency of interrupts from RTC
-*/
-static int rtc_setfreq_irq(int freq)
-{
-	int tmp = 0;
-	int rtc_freq;
-	unsigned char val;
-	unsigned long flags;
-
-	if (freq < 2)
-		freq = 2;
-	if (freq > 8192)
-		freq = 8192;
-
-	while (freq > (1 << tmp))
-		tmp++;
-
-	rtc_freq = 1 << tmp;
-
-	save_flags(flags);
-	cli();
-	val = CMOS_READ(RTC_FREQ_SELECT) & 0xf0;
-	val |= (16 - tmp);
-	CMOS_WRITE(val, RTC_FREQ_SELECT);
-	restore_flags(flags);
-	return rtc_freq;
-}
-#endif
-
 static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl818_board *board = comedi_board(dev);
@@ -1652,42 +1280,10 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
 	devpriv->ai_mode = 0;	/* mode of irq */
 
-#ifdef unused
-	/* grab RTC for DMA operations */
-	devpriv->dma_rtc = 0;
-	if (it->options[2] > 0) {	/*  we want to use DMA */
-		if (RTC_lock == 0) {
-			ret = __comedi_request_resource(dev, RTC_PORT(0),
-							RTC_IO_EXTENT);
-			if (ret)
-				goto no_rtc;
-		}
-		devpriv->rtc_iobase = RTC_PORT(0);
-		devpriv->rtc_iosize = RTC_IO_EXTENT;
-		RTC_lock++;
-		if (!request_irq(RTC_IRQ, interrupt_pcl818_ai_mode13_dma_rtc, 0,
-				 "pcl818 DMA (RTC)", dev)) {
-			devpriv->dma_rtc = 1;
-			devpriv->rtc_irq = RTC_IRQ;
-			printk(KERN_DEBUG "dma_irq=%u", devpriv->rtc_irq);
-		} else {
-			RTC_lock--;
-			if (RTC_lock == 0) {
-				if (devpriv->rtc_iobase)
-					release_region(devpriv->rtc_iobase,
-						       devpriv->rtc_iosize);
-			}
-			devpriv->rtc_iobase = 0;
-			devpriv->rtc_iosize = 0;
-		}
-	}
-
-no_rtc:
-#endif
 	/* grab our DMA */
 	dma = 0;
 	devpriv->dma = dma;
-	if ((devpriv->irq_free == 0) && (devpriv->dma_rtc == 0))
+	if (!devpriv->irq_free)
 		goto no_dma;	/* if we haven't IRQ, we can't use DMA */
 	if (board->DMAbits != 0) {	/* board support DMA */
 		dma = it->options[2];
@@ -1710,15 +1306,12 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
 		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
 		/* printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
-		if (devpriv->dma_rtc == 0) {	/*  we must do duble buff :-( */
-			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
-			if (!devpriv->dmabuf[1])
-				return -EBUSY;
-			devpriv->dmapages[1] = pages;
-			devpriv->hwdmaptr[1] =
-			    virt_to_bus((void *)devpriv->dmabuf[1]);
-			devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
-		}
+		devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
+		if (!devpriv->dmabuf[1])
+			return -EBUSY;
+		devpriv->dmapages[1] = pages;
+		devpriv->hwdmaptr[1] = virt_to_bus((void *)devpriv->dmabuf[1]);
+		devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
 	}
 
 no_dma:
@@ -1748,7 +1341,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->range_table = board->ai_range_type;
 		s->cancel = pcl818_ai_cancel;
 		s->insn_read = pcl818_ai_insn_read;
-		if ((irq) || (devpriv->dma_rtc)) {
+		if (irq) {
 			dev->read_subdev = s;
 			s->subdev_flags |= SDF_CMD_READ;
 			s->do_cmdtest = ai_cmdtest;
@@ -1805,14 +1398,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->range_table = board->ao_range_type;
 		s->insn_read = pcl818_ao_insn_read;
 		s->insn_write = pcl818_ao_insn_write;
-#ifdef unused
-#ifdef PCL818_MODE13_AO
-		if (irq) {
-			s->trig[1] = pcl818_ao_mode1;
-			s->trig[3] = pcl818_ao_mode3;
-		}
-#endif
-#endif
 		if (board->is_818) {
 			if ((it->options[4] == 1) || (it->options[4] == 10))
 				s->range_table = &range_unipolar10;
@@ -1886,17 +1471,6 @@ static void pcl818_detach(struct comedi_device *dev)
 			free_pages(devpriv->dmabuf[0], devpriv->dmapages[0]);
 		if (devpriv->dmabuf[1])
 			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
-#ifdef unused
-		if (devpriv->rtc_irq)
-			free_irq(devpriv->rtc_irq, dev);
-		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
-			if (devpriv->rtc_iobase)
-				release_region(devpriv->rtc_iobase,
-					       devpriv->rtc_iosize);
-		}
-		if (devpriv->dma_rtc)
-			RTC_lock--;
-#endif
 	}
 	comedi_legacy_detach(dev);
 }

commit 3d1fe3f785c80e17f62acf8f92570ae9210bd588
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:37 2013 -0700

    staging: comedi: drivers: free_irq() in comedi_legacy_detach()
    
    All the legacy comedi drivers now call comedi_legacy_detach()
    either directly or as part of their (*detach). Move the free_irq()
    into comedi_legacy_detach() so that the drivers don't have to
    deal with it.
    
    For drivers that then only call comedi_legacy_detach() in their
    private (*detach), remove the private function and use the helper
    directly for the (*detach).
    
    The amplc_pc236 and ni_labpc drivers are hybrid legacy/PCI drivers.
    In the detach of a PCI board free_irq() still needs to be handled
    by the driver.
    
    The pcl724 and pcl726 drivers currently have the free_irq() #ifdef'ed
    out. The comedi_legacy_detach() function sanity checks that the irq
    has been requested before freeing it so they are safe to convert.
    
    For aesthetic reasons, move the #ifdef unused chunk in the pcl816
    driver up to the previous #ifdef unused block.
    
    The pcmio and pcmuio drivers request multiple irqs and handle the
    freeing of them. Remove the 'dev->irq = irq[0]' in those drivers
    so that comedi_legacy_detach() does not attempt to free the irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index cd76da66575d..142449d7f8b4 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1898,8 +1898,6 @@ static void pcl818_detach(struct comedi_device *dev)
 			RTC_lock--;
 #endif
 	}
-	if (dev->irq)
-		free_irq(dev->irq, dev);
 	comedi_legacy_detach(dev);
 }
 

commit a32c6d0084992d3e58a93120c9ce9527e80c651e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:19 2013 -0700

    staging: comedi: drivers: use comedi_legacy_detach()
    
    Use comedi_legacy_detach() to release the I/O region requested
    by these drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 8a1a8a5dc8c8..cd76da66575d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1900,8 +1900,7 @@ static void pcl818_detach(struct comedi_device *dev)
 	}
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (dev->iobase)
-		release_region(dev->iobase, devpriv->io_range);
+	comedi_legacy_detach(dev);
 }
 
 static const struct pcl818_board boardtypes[] = {

commit 2e5fc06aa78283b8da5c1547da1bb7e81a0ebb3d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:32:03 2013 -0700

    staging: comedi: pcl818: use __comedi_request_region()
    
    Use __comedi_request_region() to request the additional I/O region
    used by this driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 6540186753ee..8a1a8a5dc8c8 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1657,8 +1657,9 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->dma_rtc = 0;
 	if (it->options[2] > 0) {	/*  we want to use DMA */
 		if (RTC_lock == 0) {
-			if (!request_region(RTC_PORT(0), RTC_IO_EXTENT,
-					    "pcl818 (RTC)"))
+			ret = __comedi_request_resource(dev, RTC_PORT(0),
+							RTC_IO_EXTENT);
+			if (ret)
 				goto no_rtc;
 		}
 		devpriv->rtc_iobase = RTC_PORT(0);

commit d6c5ec047e6a4d50942dba9298ec5c239ee2a2bf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:11:31 2013 -0700

    staging: comedi: pcl818: use comedi_request_region()
    
    Use comedi_request_region() to request the I/O region used by this
    driver.
    
    Remove the noise when the board is first attached as well as the
    error message when the request_region() fails, comedi_request_reqion()
    will output the error message if necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index e4df63e2e3f9..6540186753ee 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1594,7 +1594,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct pcl818_board *board = comedi_board(dev);
 	struct pcl818_private *devpriv;
 	int ret;
-	unsigned long iobase;
 	unsigned int irq;
 	int dma;
 	unsigned long pages;
@@ -1605,25 +1604,17 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	/* claim our I/O space */
-	iobase = it->options[0];
-	printk
-	    ("comedi%d: pcl818:  board=%s, ioport=0x%03lx",
-	     dev->minor, board->name, iobase);
 	devpriv->io_range = board->io_range;
 	if ((board->fifo) && (it->options[2] == -1)) {
 		/*  we've board with FIFO and we want to use FIFO */
 		devpriv->io_range = PCLx1xFIFO_RANGE;
 		devpriv->usefifo = 1;
 	}
-	if (!request_region(iobase, devpriv->io_range, dev->board_name)) {
-		comedi_error(dev, "I/O port conflict\n");
-		return -EIO;
-	}
-
-	dev->iobase = iobase;
+	ret = comedi_request_region(dev, it->options[0], devpriv->io_range);
+	if (ret)
+		return ret;
 
-	if (pcl818_check(iobase)) {
+	if (pcl818_check(dev->iobase)) {
 		comedi_error(dev, "I can't detect board. FAIL!\n");
 		return -EIO;
 	}

commit b27cc4135cd54064ccee8b4aeccfc659e19447a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:11:10 2013 -0700

    staging: comedi: pcl818: cleanup dev->board_name usage
    
    This legacy driver does no additional probing so the dev->board_name
    will already be properly initialized by the comedi core before calling
    the (*attach) function.
    
    Remove the unnecessary initialization of dev->board_name and use it
    when requesting the resources instead of the open-coded strings.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index b5af22eb7c37..e4df63e2e3f9 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1616,7 +1616,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->io_range = PCLx1xFIFO_RANGE;
 		devpriv->usefifo = 1;
 	}
-	if (!request_region(iobase, devpriv->io_range, "pcl818")) {
+	if (!request_region(iobase, devpriv->io_range, dev->board_name)) {
 		comedi_error(dev, "I/O port conflict\n");
 		return -EIO;
 	}
@@ -1628,8 +1628,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EIO;
 	}
 
-	dev->board_name = board->name;
-
 	/* grab our IRQ */
 	irq = 0;
 	if (board->IRQbits != 0) {	/* board support IRQ */
@@ -1641,8 +1639,8 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				     irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (request_irq
-				    (irq, interrupt_pcl818, 0, "pcl818", dev)) {
+				if (request_irq(irq, interrupt_pcl818, 0,
+						dev->board_name, dev)) {
 					printk
 					    (", unable to allocate IRQ %u, DISABLING IT",
 					     irq);
@@ -1707,7 +1705,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			printk(KERN_ERR "DMA is out of allowed range, FAIL!\n");
 			return -EINVAL;	/* Bad DMA */
 		}
-		ret = request_dma(dma, "pcl818");
+		ret = request_dma(dma, dev->board_name);
 		if (ret)
 			return -EBUSY;	/* DMA isn't free */
 		devpriv->dma = dma;

commit 74c7c503c792b36ee8943363bac021ec9ed5f9b8
Author: Jake Champlin <jake.champlin.27@gmail.com>
Date:   Sat Jan 19 01:03:32 2013 -0500

    Staging: Comedi: pcl818: Fixed Coding Style Issues
    
    Fixed single line if statement brace issues as well as pointer errors from
    checkpatch.pl
    
    Signed-off-by: Jake Champlin <jake.champlin.27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 06127a5f62a0..b5af22eb7c37 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -243,8 +243,8 @@ static const struct comedi_lrange range_pcl818l_h_ai = { 4, {
 };
 
 static const struct comedi_lrange range718_bipolar1 = { 1, {BIP_RANGE(1),} };
-static const struct comedi_lrange range718_bipolar0_5 =
-    { 1, {BIP_RANGE(0.5),} };
+static const struct comedi_lrange range718_bipolar0_5 = {
+	1, {BIP_RANGE(0.5),} };
 static const struct comedi_lrange range718_unipolar2 = { 1, {UNI_RANGE(2),} };
 static const struct comedi_lrange range718_unipolar1 = { 1, {BIP_RANGE(1),} };
 
@@ -1005,17 +1005,14 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	switch (devpriv->dma) {
 	case 1:		/*  DMA */
 	case 3:
-		if (devpriv->dma_rtc == 0) {
+		if (devpriv->dma_rtc == 0)
 			pcl818_ai_mode13dma_int(mode, dev, s);
-		}
 #ifdef unused
-		else {
+		else
 			pcl818_ai_mode13dma_rtc(mode, dev, s);
-		}
 #else
-		else {
+		else
 			return -EINVAL;
-		}
 #endif
 		break;
 	case 0:
@@ -1069,7 +1066,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 */
 #ifdef PCL818_MODE13_AO
 static int pcl818_ao_mode13(int mode, struct comedi_device *dev,
-			    struct comedi_subdevice *s, comedi_trig * it)
+			    struct comedi_subdevice *s, comedi_trig *it)
 {
 	struct pcl818_private *devpriv = dev->private;
 	int divisor1 = 0, divisor2 = 0;
@@ -1124,7 +1121,7 @@ static int pcl818_ao_mode13(int mode, struct comedi_device *dev,
    ANALOG OUTPUT MODE 1, 818 cards
 */
 static int pcl818_ao_mode1(struct comedi_device *dev,
-			   struct comedi_subdevice *s, comedi_trig * it)
+			   struct comedi_subdevice *s, comedi_trig *it)
 {
 	return pcl818_ao_mode13(1, dev, s, it);
 }
@@ -1134,7 +1131,7 @@ static int pcl818_ao_mode1(struct comedi_device *dev,
    ANALOG OUTPUT MODE 3, 818 cards
 */
 static int pcl818_ao_mode3(struct comedi_device *dev,
-			   struct comedi_subdevice *s, comedi_trig * it)
+			   struct comedi_subdevice *s, comedi_trig *it)
 {
 	return pcl818_ao_mode13(3, dev, s, it);
 }

commit 8efdc1bf560338b3d40f9eb9985576d35c6eeec7
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:58:32 2012 -0700

    staging: comedi: pcl818: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of ai_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index c94f289e3f3a..06127a5f62a0 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1294,45 +1294,23 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
-	if (cmd->scan_begin_arg != 0) {
-		cmd->scan_begin_arg = 0;
-		err++;
-	}
+	if (cmd->convert_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+						 board->ns_min);
+	else	/* TRIG_EXT */
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < board->ns_min) {
-			cmd->convert_arg = board->ns_min;
-			err++;
-		}
-	} else {		/* TRIG_EXT */
-		if (cmd->convert_arg != 0) {
-			cmd->convert_arg = 0;
-			err++;
-		}
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-	if (cmd->stop_src == TRIG_COUNT) {
-		if (!cmd->stop_arg) {
-			cmd->stop_arg = 1;
-			err++;
-		}
-	} else {		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 9dcddea3f61a..c94f289e3f3a 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1625,10 +1625,10 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned long pages;
 	struct comedi_subdevice *s;
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	/* claim our I/O space */
 	iobase = it->options[0];

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index d4b0859d81f2..9dcddea3f61a 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -326,8 +326,6 @@ static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0
 	0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
 };
 
-#define devpriv ((struct pcl818_private *)dev->private)
-
 /*
 ==============================================================================
 */
@@ -406,6 +404,7 @@ static int pcl818_ao_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcl818_private *devpriv = dev->private;
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -419,6 +418,7 @@ static int pcl818_ao_insn_write(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcl818_private *devpriv = dev->private;
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -478,6 +478,7 @@ static int pcl818_do_insn_bits(struct comedi_device *dev,
 static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[0];
 	int low;
 	int timeout = 50;	/* wait max 50us */
@@ -537,6 +538,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[0];
 	int i, len, bufptr;
 	unsigned long flags;
@@ -616,6 +618,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[0];
 	unsigned long tmp;
 	unsigned int top1, top2, i, bufptr;
@@ -721,6 +724,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct pcl818_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[0];
 	int i, len, lo;
 
@@ -795,6 +799,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 static irqreturn_t interrupt_pcl818(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct pcl818_private *devpriv = dev->private;
 
 	if (!dev->attached) {
 		comedi_error(dev, "premature interrupt");
@@ -861,6 +866,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
+	struct pcl818_private *devpriv = dev->private;
 	unsigned int flags;
 	unsigned int bytes;
 
@@ -902,6 +908,7 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
+	struct pcl818_private *devpriv = dev->private;
 	unsigned int flags;
 	short *pole;
 
@@ -943,6 +950,7 @@ static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device *dev,
 static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 			      struct comedi_subdevice *s)
 {
+	struct pcl818_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int divisor1 = 0, divisor2 = 0;
 	unsigned int seglen;
@@ -1063,6 +1071,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 static int pcl818_ao_mode13(int mode, struct comedi_device *dev,
 			    struct comedi_subdevice *s, comedi_trig * it)
 {
+	struct pcl818_private *devpriv = dev->private;
 	int divisor1 = 0, divisor2 = 0;
 
 	if (!dev->irq) {
@@ -1222,6 +1231,7 @@ static void setup_channel_list(struct comedi_device *dev,
 			       unsigned int *chanlist, unsigned int n_chan,
 			       unsigned int seglen)
 {
+	struct pcl818_private *devpriv = dev->private;
 	int i;
 
 	devpriv->act_chanlist_len = seglen;
@@ -1259,6 +1269,7 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
 	const struct pcl818_board *board = comedi_board(dev);
+	struct pcl818_private *devpriv = dev->private;
 	int err = 0;
 	int tmp, divisor1 = 0, divisor2 = 0;
 
@@ -1358,6 +1369,7 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 */
 static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct pcl818_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
 
@@ -1397,6 +1409,8 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int pcl818_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
+	struct pcl818_private *devpriv = dev->private;
+
 	if (devpriv->irq_blocked > 0) {
 		dev_dbg(dev->class_dev, "pcl818_ai_cancel()\n");
 		devpriv->irq_was_now_closed = 1;
@@ -1482,6 +1496,7 @@ static int pcl818_check(unsigned long iobase)
 static void pcl818_reset(struct comedi_device *dev)
 {
 	const struct pcl818_board *board = comedi_board(dev);
+	struct pcl818_private *devpriv = dev->private;
 
 	if (devpriv->usefifo) {	/*  FIFO shutdown */
 		outb(0, dev->iobase + PCL818_FI_INTCLR);
@@ -1552,6 +1567,7 @@ static int set_rtc_irq_bit(unsigned char bit)
 static void rtc_dropped_irq(unsigned long data)
 {
 	struct comedi_device *dev = (void *)data;
+	struct pcl818_private *devpriv = dev->private;
 	unsigned long flags, tmp;
 
 	switch (devpriv->int818_mode) {
@@ -1601,6 +1617,7 @@ static int rtc_setfreq_irq(int freq)
 static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl818_board *board = comedi_board(dev);
+	struct pcl818_private *devpriv;
 	int ret;
 	unsigned long iobase;
 	unsigned int irq;
@@ -1608,9 +1625,10 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned long pages;
 	struct comedi_subdevice *s;
 
-	ret = alloc_private(dev, sizeof(struct pcl818_private));
-	if (ret < 0)
-		return ret;	/* Can't alloc mem */
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
+		return ret;
+	devpriv = dev->private;
 
 	/* claim our I/O space */
 	iobase = it->options[0];
@@ -1892,7 +1910,9 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void pcl818_detach(struct comedi_device *dev)
 {
-	if (dev->private) {
+	struct pcl818_private *devpriv = dev->private;
+
+	if (devpriv) {
 		pcl818_ai_cancel(dev, devpriv->sub_ai);
 		pcl818_reset(dev);
 		if (devpriv->dma)

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 023a27df0d29..d4b0859d81f2 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -107,6 +107,7 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #include <linux/io.h>
 #include <asm/dma.h>
 
+#include "comedi_fc.h"
 #include "8253.h"
 
 /* #define PCL818_MODE13_AO 1 */
@@ -1261,43 +1262,23 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	int err = 0;
 	int tmp, divisor1 = 0, divisor2 = 0;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_FOLLOW;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_TIMER | TRIG_EXT;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* Step 2a : make sure trigger sources are unique */
 
-	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
 
-	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
-		err++;
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit 9fab612335c0822e0e0a404fdd6d9222b3bfc800
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:53:07 2012 -0700

    staging: comedi: pcl818: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 34169c16fb92..023a27df0d29 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -477,7 +477,7 @@ static int pcl818_do_insn_bits(struct comedi_device *dev,
 static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct comedi_subdevice *s = dev->subdevices + 0;
+	struct comedi_subdevice *s = &dev->subdevices[0];
 	int low;
 	int timeout = 50;	/* wait max 50us */
 
@@ -536,7 +536,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct comedi_subdevice *s = dev->subdevices + 0;
+	struct comedi_subdevice *s = &dev->subdevices[0];
 	int i, len, bufptr;
 	unsigned long flags;
 	short *ptr;
@@ -615,7 +615,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct comedi_subdevice *s = dev->subdevices + 0;
+	struct comedi_subdevice *s = &dev->subdevices[0];
 	unsigned long tmp;
 	unsigned int top1, top2, i, bufptr;
 	long ofs_dats;
@@ -720,7 +720,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct comedi_subdevice *s = dev->subdevices + 0;
+	struct comedi_subdevice *s = &dev->subdevices[0];
 	int i, len, lo;
 
 	outb(0, dev->iobase + PCL818_FI_INTCLR);	/*  clear fifo int request */
@@ -811,7 +811,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 			   being reprogrammed while a DMA transfer is in
 			   progress.
 			 */
-			struct comedi_subdevice *s = dev->subdevices + 0;
+			struct comedi_subdevice *s = &dev->subdevices[0];
 			devpriv->ai_act_scan = 0;
 			devpriv->neverending_ai = 0;
 			pcl818_ai_cancel(dev, s);
@@ -1763,7 +1763,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	if (!board->n_aichan_se) {
 		s->type = COMEDI_SUBD_UNUSED;
 	} else {
@@ -1829,7 +1829,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	}
 
-	s = dev->subdevices + 1;
+	s = &dev->subdevices[1];
 	if (!board->n_aochan) {
 		s->type = COMEDI_SUBD_UNUSED;
 	} else {
@@ -1862,7 +1862,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	}
 
-	s = dev->subdevices + 2;
+	s = &dev->subdevices[2];
 	if (!board->n_dichan) {
 		s->type = COMEDI_SUBD_UNUSED;
 	} else {
@@ -1875,7 +1875,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->insn_bits = pcl818_di_insn_bits;
 	}
 
-	s = dev->subdevices + 3;
+	s = &dev->subdevices[3];
 	if (!board->n_dochan) {
 		s->type = COMEDI_SUBD_UNUSED;
 	} else {

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 13eaadfbaaab..34169c16fb92 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -445,7 +445,7 @@ static int pcl818_di_insn_bits(struct comedi_device *dev,
 	data[1] = inb(dev->iobase + PCL818_DI_LO) |
 	    (inb(dev->iobase + PCL818_DI_HI) << 8);
 
-	return 2;
+	return insn->n;
 }
 
 /*
@@ -466,7 +466,7 @@ static int pcl818_do_insn_bits(struct comedi_device *dev,
 
 	data[1] = s->state;
 
-	return 2;
+	return insn->n;
 }
 
 /*

commit 520706607befd1f5c20ec14db35d6be45791bc41
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 11:18:25 2012 -0700

    staging: comedi: remove unneeded sanity check in insn_bits functions
    
    The comedi core does the sanity check to make sure that the data length
    the INSN_BITS instruction is 2. There is no need for the drivers to do
    this check. Remove all the sanity checks in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 23b61d8aa404..13eaadfbaaab 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -442,9 +442,6 @@ static int pcl818_di_insn_bits(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
-	if (insn->n != 2)
-		return -EINVAL;
-
 	data[1] = inb(dev->iobase + PCL818_DI_LO) |
 	    (inb(dev->iobase + PCL818_DI_HI) << 8);
 
@@ -461,9 +458,6 @@ static int pcl818_do_insn_bits(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
-	if (insn->n != 2)
-		return -EINVAL;
-
 	s->state &= ~data[0];
 	s->state |= (data[0] & data[1]);
 

commit f41ad6675f2d5705a0fc1e210af8eb4a27dbacb4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jun 18 14:05:34 2012 +0100

    staging: comedi: change device used in dev_...() calls
    
    A previous set of patches by Ravishankar Karkala Mallikarjunayya
    replaced a load of printk() calls with dev_info(), dev_err(), etc.
    Unfortunately, these used the 'struct device *hw_dev' member of 'struct
    comedi_device') as the first parameter of these dev_...() calls, but
    that pointer is usually NULL, so the kernel log messages come out a bit
    wrong (they contain the phrase "(NULL device *)").
    
    Use the 'struct device *class_dev' member of 'struct comedi_device'
    instead for these dev_...() calls.  It will be non-NULL and somewhat
    meaningful to users.  It's also consistent with those comedi drivers
    that already use the class_dev member in their dev_...() calls.
    
    Some of the messages included the format "comedi%d" with the minor
    device number used for the "%d".  This is now redundant as it will be
    the same as the dev_name() part of the kernel log message produced by
    the dev_...() calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 786c3b6442a6..23b61d8aa404 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -952,7 +952,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	int divisor1 = 0, divisor2 = 0;
 	unsigned int seglen;
 
-	dev_dbg(dev->hw_dev, "pcl818_ai_cmd_mode()\n");
+	dev_dbg(dev->class_dev, "pcl818_ai_cmd_mode()\n");
 	if ((!dev->irq) && (!devpriv->dma_rtc)) {
 		comedi_error(dev, "IRQ not defined!");
 		return -EINVAL;
@@ -1055,7 +1055,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 		break;
 	}
 #endif
-	dev_dbg(dev->hw_dev, "pcl818_ai_cmd_mode() end\n");
+	dev_dbg(dev->class_dev, "pcl818_ai_cmd_mode() end\n");
 	return 0;
 }
 
@@ -1386,7 +1386,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
 
-	dev_dbg(dev->hw_dev, "pcl818_ai_cmd()\n");
+	dev_dbg(dev->class_dev, "pcl818_ai_cmd()\n");
 	devpriv->ai_n_chan = cmd->chanlist_len;
 	devpriv->ai_chanlist = cmd->chanlist;
 	devpriv->ai_flags = cmd->flags;
@@ -1404,7 +1404,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		if (cmd->convert_src == TRIG_TIMER) {	/*  mode 1 */
 			devpriv->ai_timer1 = cmd->convert_arg;
 			retval = pcl818_ai_cmd_mode(1, dev, s);
-			dev_dbg(dev->hw_dev, "pcl818_ai_cmd() end\n");
+			dev_dbg(dev->class_dev, "pcl818_ai_cmd() end\n");
 			return retval;
 		}
 		if (cmd->convert_src == TRIG_EXT) {	/*  mode 3 */
@@ -1423,7 +1423,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
 	if (devpriv->irq_blocked > 0) {
-		dev_dbg(dev->hw_dev, "pcl818_ai_cancel()\n");
+		dev_dbg(dev->class_dev, "pcl818_ai_cancel()\n");
 		devpriv->irq_was_now_closed = 1;
 
 		switch (devpriv->ai_mode) {
@@ -1473,7 +1473,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	}
 
 end:
-	dev_dbg(dev->hw_dev, "pcl818_ai_cancel() end\n");
+	dev_dbg(dev->class_dev, "pcl818_ai_cancel() end\n");
 	return 0;
 }
 

commit f7f111c214f218483a23d40a1f8e2d798b6e130a
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 13 17:41:35 2012 -0700

    staging: comedi: pcl818: remove unneeded tests in ai_cmdtest
    
    The step 2 tests of the start_src, scan_begin_src, and scan_end_src
    triggers to make sure they are unique are not needed.  These triggers
    all only have one source and it was trivially validated in step 1.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 66b2570fb24e..786c3b6442a6 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1299,22 +1299,9 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
-	if (cmd->start_src != TRIG_NOW) {
-		cmd->start_src = TRIG_NOW;
-		err++;
-	}
-	if (cmd->scan_begin_src != TRIG_FOLLOW) {
-		cmd->scan_begin_src = TRIG_FOLLOW;
-		err++;
-	}
 	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
 		err++;
 
-	if (cmd->scan_end_src != TRIG_COUNT) {
-		cmd->scan_end_src = TRIG_COUNT;
-		err++;
-	}
-
 	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
 		err++;
 

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index a4c2870562fb..66b2570fb24e 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1779,7 +1779,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 no_dma:
 
 	ret = comedi_alloc_subdevices(dev, 4);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	s = dev->subdevices + 0;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 6c84b29a8dad..a4c2870562fb 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1778,7 +1778,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 no_dma:
 
-	ret = alloc_subdevices(dev, 4);
+	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret < 0)
 		return ret;
 

commit dd8a4b478846c2cd38c09dcc564a8b964da185d0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 22 17:22:48 2012 -0700

    staging: comedi: remove this_board macro in the pcl818 driver
    
    The 'this_board' macro depends on having a local variable with
    a magic name. The CodingStyle document suggests not doing this
    to avoid confusion. Remove the macro and use the comedi_board()
    inline helper to get the dev->board_ptr information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 1406c9720f5d..6c84b29a8dad 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -326,7 +326,6 @@ static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0
 };
 
 #define devpriv ((struct pcl818_private *)dev->private)
-#define this_board ((const struct pcl818_board *)dev->board_ptr)
 
 /*
 ==============================================================================
@@ -1264,6 +1263,7 @@ static int check_single_ended(unsigned int port)
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
+	const struct pcl818_board *board = comedi_board(dev);
 	int err = 0;
 	int tmp, divisor1 = 0, divisor2 = 0;
 
@@ -1334,8 +1334,8 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	}
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < this_board->ns_min) {
-			cmd->convert_arg = this_board->ns_min;
+		if (cmd->convert_arg < board->ns_min) {
+			cmd->convert_arg = board->ns_min;
 			err++;
 		}
 	} else {		/* TRIG_EXT */
@@ -1371,8 +1371,8 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
 					  &divisor2, &cmd->convert_arg,
 					  cmd->flags & TRIG_ROUND_MASK);
-		if (cmd->convert_arg < this_board->ns_min)
-			cmd->convert_arg = this_board->ns_min;
+		if (cmd->convert_arg < board->ns_min)
+			cmd->convert_arg = board->ns_min;
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -1519,6 +1519,8 @@ static int pcl818_check(unsigned long iobase)
 */
 static void pcl818_reset(struct comedi_device *dev)
 {
+	const struct pcl818_board *board = comedi_board(dev);
+
 	if (devpriv->usefifo) {	/*  FIFO shutdown */
 		outb(0, dev->iobase + PCL818_FI_INTCLR);
 		outb(0, dev->iobase + PCL818_FI_FLUSH);
@@ -1537,7 +1539,7 @@ static void pcl818_reset(struct comedi_device *dev)
 	outb(0xb0, dev->iobase + PCL818_CTRCTL);	/* Stop pacer */
 	outb(0x70, dev->iobase + PCL818_CTRCTL);
 	outb(0x30, dev->iobase + PCL818_CTRCTL);
-	if (this_board->is_818) {
+	if (board->is_818) {
 		outb(0, dev->iobase + PCL818_RANGE);
 	} else {
 		outb(0, dev->iobase + PCL718_DA2_LO);
@@ -1636,6 +1638,7 @@ static int rtc_setfreq_irq(int freq)
 
 static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	const struct pcl818_board *board = comedi_board(dev);
 	int ret;
 	unsigned long iobase;
 	unsigned int irq;
@@ -1651,9 +1654,10 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	iobase = it->options[0];
 	printk
 	    ("comedi%d: pcl818:  board=%s, ioport=0x%03lx",
-	     dev->minor, this_board->name, iobase);
-	devpriv->io_range = this_board->io_range;
-	if ((this_board->fifo) && (it->options[2] == -1)) {	/*  we've board with FIFO and we want to use FIFO */
+	     dev->minor, board->name, iobase);
+	devpriv->io_range = board->io_range;
+	if ((board->fifo) && (it->options[2] == -1)) {
+		/*  we've board with FIFO and we want to use FIFO */
 		devpriv->io_range = PCLx1xFIFO_RANGE;
 		devpriv->usefifo = 1;
 	}
@@ -1669,14 +1673,14 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EIO;
 	}
 
-	/* set up some name stuff */
-	dev->board_name = this_board->name;
+	dev->board_name = board->name;
+
 	/* grab our IRQ */
 	irq = 0;
-	if (this_board->IRQbits != 0) {	/* board support IRQ */
+	if (board->IRQbits != 0) {	/* board support IRQ */
 		irq = it->options[1];
 		if (irq) {	/* we want to use IRQ */
-			if (((1 << irq) & this_board->IRQbits) == 0) {
+			if (((1 << irq) & board->IRQbits) == 0) {
 				printk
 				    (", IRQ %u is out of allowed range, DISABLING IT",
 				     irq);
@@ -1740,11 +1744,11 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->dma = dma;
 	if ((devpriv->irq_free == 0) && (devpriv->dma_rtc == 0))
 		goto no_dma;	/* if we haven't IRQ, we can't use DMA */
-	if (this_board->DMAbits != 0) {	/* board support DMA */
+	if (board->DMAbits != 0) {	/* board support DMA */
 		dma = it->options[2];
 		if (dma < 1)
 			goto no_dma;	/* DMA disabled */
-		if (((1 << dma) & this_board->DMAbits) == 0) {
+		if (((1 << dma) & board->DMAbits) == 0) {
 			printk(KERN_ERR "DMA is out of allowed range, FAIL!\n");
 			return -EINVAL;	/* Bad DMA */
 		}
@@ -1779,24 +1783,24 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return ret;
 
 	s = dev->subdevices + 0;
-	if (!this_board->n_aichan_se) {
+	if (!board->n_aichan_se) {
 		s->type = COMEDI_SUBD_UNUSED;
 	} else {
 		s->type = COMEDI_SUBD_AI;
 		devpriv->sub_ai = s;
 		s->subdev_flags = SDF_READABLE;
 		if (check_single_ended(dev->iobase)) {
-			s->n_chan = this_board->n_aichan_se;
+			s->n_chan = board->n_aichan_se;
 			s->subdev_flags |= SDF_COMMON | SDF_GROUND;
 			printk(", %dchans S.E. DAC", s->n_chan);
 		} else {
-			s->n_chan = this_board->n_aichan_diff;
+			s->n_chan = board->n_aichan_diff;
 			s->subdev_flags |= SDF_DIFF;
 			printk(", %dchans DIFF DAC", s->n_chan);
 		}
-		s->maxdata = this_board->ai_maxdata;
+		s->maxdata = board->ai_maxdata;
 		s->len_chanlist = s->n_chan;
-		s->range_table = this_board->ai_range_type;
+		s->range_table = board->ai_range_type;
 		s->cancel = pcl818_ai_cancel;
 		s->insn_read = pcl818_ai_insn_read;
 		if ((irq) || (devpriv->dma_rtc)) {
@@ -1805,7 +1809,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			s->do_cmdtest = ai_cmdtest;
 			s->do_cmd = ai_cmd;
 		}
-		if (this_board->is_818) {
+		if (board->is_818) {
 			if ((it->options[4] == 1) || (it->options[4] == 10))
 				s->range_table = &range_pcl818l_h_ai;	/*  secondary range list jumper selectable */
 		} else {
@@ -1845,15 +1849,15 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	s = dev->subdevices + 1;
-	if (!this_board->n_aochan) {
+	if (!board->n_aochan) {
 		s->type = COMEDI_SUBD_UNUSED;
 	} else {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
-		s->n_chan = this_board->n_aochan;
-		s->maxdata = this_board->ao_maxdata;
-		s->len_chanlist = this_board->n_aochan;
-		s->range_table = this_board->ao_range_type;
+		s->n_chan = board->n_aochan;
+		s->maxdata = board->ao_maxdata;
+		s->len_chanlist = board->n_aochan;
+		s->range_table = board->ao_range_type;
 		s->insn_read = pcl818_ao_insn_read;
 		s->insn_write = pcl818_ao_insn_write;
 #ifdef unused
@@ -1864,7 +1868,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 #endif
 #endif
-		if (this_board->is_818) {
+		if (board->is_818) {
 			if ((it->options[4] == 1) || (it->options[4] == 10))
 				s->range_table = &range_unipolar10;
 			if (it->options[4] == 2)
@@ -1878,27 +1882,27 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	s = dev->subdevices + 2;
-	if (!this_board->n_dichan) {
+	if (!board->n_dichan) {
 		s->type = COMEDI_SUBD_UNUSED;
 	} else {
 		s->type = COMEDI_SUBD_DI;
 		s->subdev_flags = SDF_READABLE;
-		s->n_chan = this_board->n_dichan;
+		s->n_chan = board->n_dichan;
 		s->maxdata = 1;
-		s->len_chanlist = this_board->n_dichan;
+		s->len_chanlist = board->n_dichan;
 		s->range_table = &range_digital;
 		s->insn_bits = pcl818_di_insn_bits;
 	}
 
 	s = dev->subdevices + 3;
-	if (!this_board->n_dochan) {
+	if (!board->n_dochan) {
 		s->type = COMEDI_SUBD_UNUSED;
 	} else {
 		s->type = COMEDI_SUBD_DO;
 		s->subdev_flags = SDF_WRITABLE;
-		s->n_chan = this_board->n_dochan;
+		s->n_chan = board->n_dochan;
 		s->maxdata = 1;
-		s->len_chanlist = this_board->n_dochan;
+		s->len_chanlist = board->n_dochan;
 		s->range_table = &range_digital;
 		s->insn_bits = pcl818_do_insn_bits;
 	}
@@ -1910,9 +1914,9 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->i8253_osc_base = 1000;
 
 	/* max sampling speed */
-	devpriv->ns_min = this_board->ns_min;
+	devpriv->ns_min = board->ns_min;
 
-	if (!this_board->is_818) {
+	if (!board->is_818) {
 		if ((it->options[6] == 1) || (it->options[6] == 100))
 			devpriv->ns_min = 10000;	/* extended PCL718 to 100kHz DAC */
 	}

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 9b8a1ff5c8a4..1406c9720f5d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1634,42 +1634,6 @@ static int rtc_setfreq_irq(int freq)
 }
 #endif
 
-/*
-==============================================================================
-  Free any resources that we have claimed
-*/
-static void free_resources(struct comedi_device *dev)
-{
-	/* printk("free_resource()\n"); */
-	if (dev->private) {
-		pcl818_ai_cancel(dev, devpriv->sub_ai);
-		pcl818_reset(dev);
-		if (devpriv->dma)
-			free_dma(devpriv->dma);
-		if (devpriv->dmabuf[0])
-			free_pages(devpriv->dmabuf[0], devpriv->dmapages[0]);
-		if (devpriv->dmabuf[1])
-			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
-#ifdef unused
-		if (devpriv->rtc_irq)
-			free_irq(devpriv->rtc_irq, dev);
-		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
-			if (devpriv->rtc_iobase)
-				release_region(devpriv->rtc_iobase,
-					       devpriv->rtc_iosize);
-		}
-		if (devpriv->dma_rtc)
-			RTC_lock--;
-#endif
-	}
-
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	if (dev->iobase)
-		release_region(dev->iobase, devpriv->io_range);
-	/* printk("free_resource() end\n"); */
-}
-
 static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	int ret;
@@ -1960,11 +1924,33 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 0;
 }
 
-static int pcl818_detach(struct comedi_device *dev)
+static void pcl818_detach(struct comedi_device *dev)
 {
-	/*   printk("comedi%d: pcl818: remove\n", dev->minor); */
-	free_resources(dev);
-	return 0;
+	if (dev->private) {
+		pcl818_ai_cancel(dev, devpriv->sub_ai);
+		pcl818_reset(dev);
+		if (devpriv->dma)
+			free_dma(devpriv->dma);
+		if (devpriv->dmabuf[0])
+			free_pages(devpriv->dmabuf[0], devpriv->dmapages[0]);
+		if (devpriv->dmabuf[1])
+			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
+#ifdef unused
+		if (devpriv->rtc_irq)
+			free_irq(devpriv->rtc_irq, dev);
+		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
+			if (devpriv->rtc_iobase)
+				release_region(devpriv->rtc_iobase,
+					       devpriv->rtc_iosize);
+		}
+		if (devpriv->dma_rtc)
+			RTC_lock--;
+#endif
+	}
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	if (dev->iobase)
+		release_region(dev->iobase, devpriv->io_range);
 }
 
 static const struct pcl818_board boardtypes[] = {

commit 294f930d98be86fb4f34302c718a49719650857f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 3 15:09:40 2012 -0700

    staging: comedi: use module_comedi_driver
    
    Convert the refactored comedi drivers to use the module_comedi_driver()
    macro which makes the code smaller and a bit simpler.
    
    In the process, rename the driver variables from driver_* to *_driver,
    as is more typical with other subsystems, and make sure they are all
    static.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 8dbefc51b2fc..9b8a1ff5c8a4 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1992,7 +1992,7 @@ static const struct pcl818_board boardtypes[] = {
 	 0x0a, 0xfff, 0xfff, 0, 1 /* XXX ? */ },
 };
 
-static struct comedi_driver driver_pcl818 = {
+static struct comedi_driver pcl818_driver = {
 	.driver_name	= "pcl818",
 	.module		= THIS_MODULE,
 	.attach		= pcl818_attach,
@@ -2001,18 +2001,7 @@ static struct comedi_driver driver_pcl818 = {
 	.num_names	= ARRAY_SIZE(boardtypes),
 	.offset		= sizeof(struct pcl818_board),
 };
-
-static int __init driver_pcl818_init_module(void)
-{
-	return comedi_driver_register(&driver_pcl818);
-}
-module_init(driver_pcl818_init_module);
-
-static void __exit driver_pcl818_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_pcl818);
-}
-module_exit(driver_pcl818_cleanup_module);
+module_comedi_driver(pcl818_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit f6aafa10def97020437bab02444da4cdeb92d5d9
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Apr 27 16:09:11 2012 -0700

    staging: comedi: refactor pcl818 driver to remove forward declarations
    
    Move the module_init/module_exit routines and the associated
    struct comedi_driver and other variables to the end of the source.
    This is more typical of how other drivers are written and removes
    the need for the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 0272491c784f..8dbefc51b2fc 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -247,10 +247,6 @@ static const struct comedi_lrange range718_bipolar0_5 =
 static const struct comedi_lrange range718_unipolar2 = { 1, {UNI_RANGE(2),} };
 static const struct comedi_lrange range718_unipolar1 = { 1, {BIP_RANGE(1),} };
 
-static int pcl818_attach(struct comedi_device *dev,
-			 struct comedi_devconfig *it);
-static int pcl818_detach(struct comedi_device *dev);
-
 #ifdef unused
 static int RTC_lock;	/* RTC lock */
 static int RTC_timer_lock;	/* RTC int lock */
@@ -277,54 +273,6 @@ struct pcl818_board {
 	int is_818;
 };
 
-static const struct pcl818_board boardtypes[] = {
-	{"pcl818l", 4, 16, 8, 25000, 1, 16, 16, &range_pcl818l_l_ai,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 0, 1},
-	{"pcl818h", 9, 16, 8, 10000, 1, 16, 16, &range_pcl818h_ai,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 0, 1},
-	{"pcl818hd", 9, 16, 8, 10000, 1, 16, 16, &range_pcl818h_ai,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 1, 1},
-	{"pcl818hg", 12, 16, 8, 10000, 1, 16, 16, &range_pcl818hg_ai,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 1, 1},
-	{"pcl818", 9, 16, 8, 10000, 2, 16, 16, &range_pcl818h_ai,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 0, 1},
-	{"pcl718", 1, 16, 8, 16000, 2, 16, 16, &range_unipolar5,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 0, 0},
-	/* pcm3718 */
-	{"pcm3718", 9, 16, 8, 10000, 0, 16, 16, &range_pcl818h_ai,
-	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
-	 0x0a, 0xfff, 0xfff, 0, 1 /* XXX ? */ },
-};
-
-static struct comedi_driver driver_pcl818 = {
-	.driver_name = "pcl818",
-	.module = THIS_MODULE,
-	.attach = pcl818_attach,
-	.detach = pcl818_detach,
-	.board_name = &boardtypes[0].name,
-	.num_names = ARRAY_SIZE(boardtypes),
-	.offset = sizeof(struct pcl818_board),
-};
-
-static int __init driver_pcl818_init_module(void)
-{
-	return comedi_driver_register(&driver_pcl818);
-}
-
-static void __exit driver_pcl818_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_pcl818);
-}
-
-module_init(driver_pcl818_init_module);
-module_exit(driver_pcl818_cleanup_module);
-
 struct pcl818_private {
 
 	unsigned int dma;	/*  used DMA, 0=don't use DMA */
@@ -1722,12 +1670,6 @@ static void free_resources(struct comedi_device *dev)
 	/* printk("free_resource() end\n"); */
 }
 
-/*
-==============================================================================
-
-   Initialization
-
-*/
 static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	int ret;
@@ -2018,10 +1960,6 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 0;
 }
 
-/*
-==============================================================================
-  Removes device
- */
 static int pcl818_detach(struct comedi_device *dev)
 {
 	/*   printk("comedi%d: pcl818: remove\n", dev->minor); */
@@ -2029,6 +1967,53 @@ static int pcl818_detach(struct comedi_device *dev)
 	return 0;
 }
 
+static const struct pcl818_board boardtypes[] = {
+	{"pcl818l", 4, 16, 8, 25000, 1, 16, 16, &range_pcl818l_l_ai,
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 1},
+	{"pcl818h", 9, 16, 8, 10000, 1, 16, 16, &range_pcl818h_ai,
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 1},
+	{"pcl818hd", 9, 16, 8, 10000, 1, 16, 16, &range_pcl818h_ai,
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 1, 1},
+	{"pcl818hg", 12, 16, 8, 10000, 1, 16, 16, &range_pcl818hg_ai,
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 1, 1},
+	{"pcl818", 9, 16, 8, 10000, 2, 16, 16, &range_pcl818h_ai,
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 1},
+	{"pcl718", 1, 16, 8, 16000, 2, 16, 16, &range_unipolar5,
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 0},
+	/* pcm3718 */
+	{"pcm3718", 9, 16, 8, 10000, 0, 16, 16, &range_pcl818h_ai,
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 1 /* XXX ? */ },
+};
+
+static struct comedi_driver driver_pcl818 = {
+	.driver_name	= "pcl818",
+	.module		= THIS_MODULE,
+	.attach		= pcl818_attach,
+	.detach		= pcl818_detach,
+	.board_name	= &boardtypes[0].name,
+	.num_names	= ARRAY_SIZE(boardtypes),
+	.offset		= sizeof(struct pcl818_board),
+};
+
+static int __init driver_pcl818_init_module(void)
+{
+	return comedi_driver_register(&driver_pcl818);
+}
+module_init(driver_pcl818_init_module);
+
+static void __exit driver_pcl818_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver_pcl818);
+}
+module_exit(driver_pcl818_cleanup_module);
+
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");
 MODULE_LICENSE("GPL");

commit 542038f4df5a9d5d806a4af8725d2d21c4423a15
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Apr 20 12:05:04 2012 -0700

    staging: comedi: use ARRAY_SIZE instead of custom n_boardtypes macros
    
    The n_boardtypes macros are simply open-coded versions of the kernels
    ARRAY_SIZE macro. Use the kernel provided macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 7344a53a81c4..0272491c784f 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -302,15 +302,13 @@ static const struct pcl818_board boardtypes[] = {
 	 0x0a, 0xfff, 0xfff, 0, 1 /* XXX ? */ },
 };
 
-#define n_boardtypes (sizeof(boardtypes)/sizeof(struct pcl818_board))
-
 static struct comedi_driver driver_pcl818 = {
 	.driver_name = "pcl818",
 	.module = THIS_MODULE,
 	.attach = pcl818_attach,
 	.detach = pcl818_detach,
 	.board_name = &boardtypes[0].name,
-	.num_names = n_boardtypes,
+	.num_names = ARRAY_SIZE(boardtypes),
 	.offset = sizeof(struct pcl818_board),
 };
 

commit 408f6bcd2acfe03c1f86b1fd9f77e010447b0080
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Sat Nov 19 10:06:57 2011 +0530

    Staging: comedi: fix printk issue in pcl818.c
    
    This is a patch to the pcl818.c file that fixes up a printk
    warning found by the checkpatch.pl tool.
    Removed an unnecessary printks.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index bad7ee409ed4..7344a53a81c4 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1841,34 +1841,26 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (dma < 1)
 			goto no_dma;	/* DMA disabled */
 		if (((1 << dma) & this_board->DMAbits) == 0) {
-			printk(", DMA is out of allowed range, FAIL!\n");
+			printk(KERN_ERR "DMA is out of allowed range, FAIL!\n");
 			return -EINVAL;	/* Bad DMA */
 		}
 		ret = request_dma(dma, "pcl818");
-		if (ret) {
-			printk(", unable to allocate DMA %u, FAIL!\n", dma);
+		if (ret)
 			return -EBUSY;	/* DMA isn't free */
-		}
 		devpriv->dma = dma;
-		printk(", dma=%u", dma);
 		pages = 2;	/* we need 16KB */
 		devpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);
-		if (!devpriv->dmabuf[0]) {
-			printk(", unable to allocate DMA buffer, FAIL!\n");
+		if (!devpriv->dmabuf[0])
 			/* maybe experiment with try_to_free_pages() will help .... */
 			return -EBUSY;	/* no buffer :-( */
-		}
 		devpriv->dmapages[0] = pages;
 		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
 		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
 		/* printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
 		if (devpriv->dma_rtc == 0) {	/*  we must do duble buff :-( */
 			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
-			if (!devpriv->dmabuf[1]) {
-				printk
-				    (", unable to allocate DMA buffer, FAIL!\n");
+			if (!devpriv->dmabuf[1])
 				return -EBUSY;
-			}
 			devpriv->dmapages[1] = pages;
 			devpriv->hwdmaptr[1] =
 			    virt_to_bus((void *)devpriv->dmabuf[1]);

commit c62a0ef42c119f6c36d6f228839e0f3aafba0dca
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Sat Nov 19 10:06:56 2011 +0530

    Staging: comedi: fix printk issue in pcl818.c
    
    This is a patch to the pcl818.c file that fixes up a printk
    warning found by the checkpatch.pl tool.
    Converted printks to dev_version.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index c207b253dd45..bad7ee409ed4 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1007,7 +1007,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	int divisor1 = 0, divisor2 = 0;
 	unsigned int seglen;
 
-	printk("pcl818_ai_cmd_mode()\n");
+	dev_dbg(dev->hw_dev, "pcl818_ai_cmd_mode()\n");
 	if ((!dev->irq) && (!devpriv->dma_rtc)) {
 		comedi_error(dev, "IRQ not defined!");
 		return -EINVAL;
@@ -1110,7 +1110,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 		break;
 	}
 #endif
-	printk("pcl818_ai_cmd_mode() end\n");
+	dev_dbg(dev->hw_dev, "pcl818_ai_cmd_mode() end\n");
 	return 0;
 }
 
@@ -1453,7 +1453,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
 
-	printk("pcl818_ai_cmd()\n");
+	dev_dbg(dev->hw_dev, "pcl818_ai_cmd()\n");
 	devpriv->ai_n_chan = cmd->chanlist_len;
 	devpriv->ai_chanlist = cmd->chanlist;
 	devpriv->ai_flags = cmd->flags;
@@ -1471,7 +1471,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		if (cmd->convert_src == TRIG_TIMER) {	/*  mode 1 */
 			devpriv->ai_timer1 = cmd->convert_arg;
 			retval = pcl818_ai_cmd_mode(1, dev, s);
-			printk("pcl818_ai_cmd() end\n");
+			dev_dbg(dev->hw_dev, "pcl818_ai_cmd() end\n");
 			return retval;
 		}
 		if (cmd->convert_src == TRIG_EXT) {	/*  mode 3 */
@@ -1490,7 +1490,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
 	if (devpriv->irq_blocked > 0) {
-		printk("pcl818_ai_cancel()\n");
+		dev_dbg(dev->hw_dev, "pcl818_ai_cancel()\n");
 		devpriv->irq_was_now_closed = 1;
 
 		switch (devpriv->ai_mode) {
@@ -1540,7 +1540,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev,
 	}
 
 end:
-	printk("pcl818_ai_cancel() end\n");
+	dev_dbg(dev->hw_dev, "pcl818_ai_cancel() end\n");
 	return 0;
 }
 

commit 26ba666c50a9a7883e837626d85dc71c30b28b77
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Sat Nov 19 10:06:55 2011 +0530

    Staging: comedi: fix printk issue in pcl818.c
    
    This is a patch to the pcl818.c file that fixes up a printk
    warning found by the checkpatch.pl tool
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 4e134e9d06cc..c207b253dd45 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1745,22 +1745,23 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* claim our I/O space */
 	iobase = it->options[0];
-	printk("comedi%d: pcl818:  board=%s, ioport=0x%03lx",
-	       dev->minor, this_board->name, iobase);
+	printk
+	    ("comedi%d: pcl818:  board=%s, ioport=0x%03lx",
+	     dev->minor, this_board->name, iobase);
 	devpriv->io_range = this_board->io_range;
 	if ((this_board->fifo) && (it->options[2] == -1)) {	/*  we've board with FIFO and we want to use FIFO */
 		devpriv->io_range = PCLx1xFIFO_RANGE;
 		devpriv->usefifo = 1;
 	}
 	if (!request_region(iobase, devpriv->io_range, "pcl818")) {
-		printk("I/O port conflict\n");
+		comedi_error(dev, "I/O port conflict\n");
 		return -EIO;
 	}
 
 	dev->iobase = iobase;
 
 	if (pcl818_check(iobase)) {
-		printk(", I can't detect board. FAIL!\n");
+		comedi_error(dev, "I can't detect board. FAIL!\n");
 		return -EIO;
 	}
 
@@ -1784,7 +1785,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 					     irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
-					printk(", irq=%u", irq);
+					printk(KERN_DEBUG "irq=%u", irq);
 				}
 			}
 		}
@@ -1815,7 +1816,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				 "pcl818 DMA (RTC)", dev)) {
 			devpriv->dma_rtc = 1;
 			devpriv->rtc_irq = RTC_IRQ;
-			printk(", dma_irq=%u", devpriv->rtc_irq);
+			printk(KERN_DEBUG "dma_irq=%u", devpriv->rtc_irq);
 		} else {
 			RTC_lock--;
 			if (RTC_lock == 0) {

commit 2b8731348a107e894cb3483faa10d46b1f763be4
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Sat Nov 19 10:06:38 2011 +0530

    Staging: comedi: fix NULL initilization issue in pcl818.c
    
    This is a patch to the pcl818.c file that fixes up a NULL initilization
    warning found by the checkpatch.pl tool.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index ca033de4a4e2..4e134e9d06cc 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -252,8 +252,8 @@ static int pcl818_attach(struct comedi_device *dev,
 static int pcl818_detach(struct comedi_device *dev);
 
 #ifdef unused
-static int RTC_lock = 0;	/* RTC lock */
-static int RTC_timer_lock = 0;	/* RTC int lock */
+static int RTC_lock;	/* RTC lock */
+static int RTC_timer_lock;	/* RTC int lock */
 #endif
 
 struct pcl818_board {

commit fc950139636c63a839b95d4d404b0ded7a565c23
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Sat Nov 19 10:06:37 2011 +0530

    Staging: comedi: fix brace coding style issue in pcl818.c
    
    This is a patch to the pcl818.c file that fixes up a brace
    coding style warning found by the checkpatch.pl tool.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index b45a9bd8b489..ca033de4a4e2 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -463,9 +463,8 @@ static int pcl818_ao_insn_read(struct comedi_device *dev,
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
 
-	for (n = 0; n < insn->n; n++) {
+	for (n = 0; n < insn->n; n++)
 		data[n] = devpriv->ao_readback[chan];
-	}
 
 	return n;
 }
@@ -571,9 +570,9 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 	devpriv->act_chanlist_pos++;
-	if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len) {
+	if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)
 		devpriv->act_chanlist_pos = 0;
-	}
+
 	s->async->cur_chan++;
 	if (s->async->cur_chan >= devpriv->ai_n_chan) {
 		/*  printk("E"); */
@@ -645,9 +644,9 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 		comedi_buf_put(s->async, ptr[bufptr++] >> 4);	/*  get one sample */
 
 		devpriv->act_chanlist_pos++;
-		if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len) {
+		if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)
 			devpriv->act_chanlist_pos = 0;
-		}
+
 		s->async->cur_chan++;
 		if (s->async->cur_chan >= devpriv->ai_n_chan) {
 			s->async->cur_chan = 0;
@@ -805,11 +804,10 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	if (lo & 2) {
+	if (lo & 2)
 		len = 512;
-	} else {
+	else
 		len = 0;
-	}
 
 	for (i = 0; i < len; i++) {
 		lo = inb(dev->iobase + PCL818_FI_DATALO);
@@ -827,9 +825,9 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 		comedi_buf_put(s->async, (lo >> 4) | (inb(dev->iobase + PCL818_FI_DATAHI) << 4));	/*  get one sample */
 
 		devpriv->act_chanlist_pos++;
-		if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len) {
+		if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)
 			devpriv->act_chanlist_pos = 0;
-		}
+
 		s->async->cur_chan++;
 		if (s->async->cur_chan >= devpriv->ai_n_chan) {
 			s->async->cur_chan = 0;
@@ -1309,11 +1307,9 @@ static void setup_channel_list(struct comedi_device *dev,
 */
 static int check_single_ended(unsigned int port)
 {
-	if (inb(port + PCL818_STATUS) & 0x20) {
+	if (inb(port + PCL818_STATUS) & 0x20)
 		return 1;
-	} else {
-		return 0;
-	}
+	return 0;
 }
 
 /*
@@ -1352,9 +1348,8 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (!cmd->stop_src || tmp != cmd->stop_src)
 		err++;
 
-	if (err) {
+	if (err)
 		return 1;
-	}
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
@@ -1377,9 +1372,8 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
 		err++;
 
-	if (err) {
+	if (err)
 		return 2;
-	}
 
 	/* step 3: make sure arguments are trivially compatible */
 
@@ -1421,9 +1415,8 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		}
 	}
 
-	if (err) {
+	if (err)
 		return 3;
-	}
 
 	/* step 4: fix up any arguments */
 
@@ -1438,9 +1431,8 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			err++;
 	}
 
-	if (err) {
+	if (err)
 		return 4;
-	}
 
 	/* step 5: complain about special chanlist considerations */
 
@@ -1470,11 +1462,10 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_timer1 = 0;
 	devpriv->ai_timer2 = 0;
 
-	if (cmd->stop_src == TRIG_COUNT) {
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ai_scans = cmd->stop_arg;
-	} else {
+	else
 		devpriv->ai_scans = 0;
-	}
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW) {	/*  mode 1, 3 */
 		if (cmd->convert_src == TRIG_TIMER) {	/*  mode 1 */
@@ -1633,11 +1624,11 @@ static int set_rtc_irq_bit(unsigned char bit)
 	save_flags(flags);
 	cli();
 	val = CMOS_READ(RTC_CONTROL);
-	if (bit) {
+	if (bit)
 		val |= RTC_PIE;
-	} else {
+	else
 		val &= ~RTC_PIE;
-	}
+
 	CMOS_WRITE(val, RTC_CONTROL);
 	CMOS_READ(RTC_INTR_FLAGS);
 	restore_flags(flags);
@@ -1800,12 +1791,11 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	dev->irq = irq;
-	if (irq) {
-		devpriv->irq_free = 1;
-	} /* 1=we have allocated irq */
-	else {
+	if (irq)
+		devpriv->irq_free = 1;   /* 1=we have allocated irq */
+	else
 		devpriv->irq_free = 0;
-	}
+
 	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
 	devpriv->ai_mode = 0;	/* mode of irq */
 
@@ -2017,11 +2007,10 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	/* select 1/10MHz oscilator */
-	if ((it->options[3] == 0) || (it->options[3] == 10)) {
+	if ((it->options[3] == 0) || (it->options[3] == 10))
 		devpriv->i8253_osc_base = 100;
-	} else {
+	else
 		devpriv->i8253_osc_base = 1000;
-	}
 
 	/* max sampling speed */
 	devpriv->ns_min = this_board->ns_min;

commit 845d131e2b363717d8ac8db2c6b4417de8cf10b5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 9 12:20:28 2011 -0700

    Staging: comedi: add #include <linux/io.h> to a bunch of drivers
    
    On some arches the function virt_to_bus() wasn't being pulled in due to
    include chains being different.  So, as we are explicitly calling this
    function, explicitly include the proper header file so all will build
    properly.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 8933e5089bd3..b45a9bd8b489 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -104,6 +104,7 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #include <linux/mc146818rtc.h>
 #include <linux/gfp.h>
 #include <linux/delay.h>
+#include <linux/io.h>
 #include <asm/dma.h>
 
 #include "8253.h"

commit 95cd17c9f3734091a5811fabbd778e3f7b1f0789
Author: Joe Perches <joe@perches.com>
Date:   Sun Apr 10 14:31:35 2011 -0700

    staging: Remove unnecessary semicolons when switch (foo) {...};
    
    Done via perl script:
    
    $ cat remove_semi_switch.pl
    my $match_balanced_parentheses = qr/(\((?:[^\(\)]++|(?-1))*\))/;
    my $match_balanced_braces      = qr/(\{(?:[^\{\}]++|(?-1))*\})/;
    
    foreach my $file (@ARGV) {
        my $f;
        my $text;
        my $oldtext;
    
        next if ((-d $file));
    
        open($f, '<', $file)
            or die "$P: Can't open $file for read\n";
        $oldtext = do { local($/) ; <$f> };
        close($f);
    
        next if ($oldtext eq "");
    
        $text = $oldtext;
    
        my $count = 0;
        do {
            $count = 0;
            $count += $text =~ s@\b(switch\s*${match_balanced_parentheses}\s*)${match_balanced_braces}\s*;@"$1$3"@egx;
        } while ($count > 0);
    
        if ($text ne $oldtext) {
            my $newfile = $file;
    
            open($f, '>', $newfile)
                or die "$P: Can't open $newfile for write\n";
            print $f $text;
            close($f);
        }
    }
    
    $
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index e3eea09ae1fb..8933e5089bd3 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1662,7 +1662,7 @@ static void rtc_dropped_irq(unsigned long data)
 		tmp = (CMOS_READ(RTC_INTR_FLAGS) & 0xF0);	/* restart */
 		restore_flags(flags);
 		break;
-	};
+	}
 }
 
 /*

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index f58d75be7295..e3eea09ae1fb 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1231,7 +1231,7 @@ static int check_channel_list(struct comedi_device *dev,
 	}
 
 	if (n_chan > 1) {
-		/*  first channel is everytime ok */
+		/*  first channel is every time ok */
 		chansegment[0] = chanlist[0];
 		/*  build part of chanlist */
 		for (i = 1, seglen = 1; i < n_chan; i++, seglen++) {
@@ -1245,9 +1245,9 @@ static int check_channel_list(struct comedi_device *dev,
 				break;
 			nowmustbechan =
 			    (CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
-			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continous :-( */
+			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continuous :-( */
 				printk
-				    ("comedi%d: pcl818: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
+				    ("comedi%d: pcl818: channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\n",
 				     dev->minor, i, CR_CHAN(chanlist[i]),
 				     nowmustbechan, CR_CHAN(chanlist[0]));
 				return 0;

commit 39eaedb68e54408c5476304a71ede713f31df37c
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Thu Feb 24 22:14:05 2011 -0800

    staging: comedi: pcl818.c remove one to many l's in the word.
    
    The patch below removes an extra "l" in the word.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index d2bd6f82b830..f58d75be7295 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -261,7 +261,7 @@ struct pcl818_board {
 	int n_ranges;		/*  len of range list */
 	int n_aichan_se;	/*  num of A/D chans in single ended  mode */
 	int n_aichan_diff;	/*  num of A/D chans in diferencial mode */
-	unsigned int ns_min;	/*  minimal alllowed delay between samples (in ns) */
+	unsigned int ns_min;	/*  minimal allowed delay between samples (in ns) */
 	int n_aochan;		/*  num of D/A chans */
 	int n_dichan;		/*  num of DI chans */
 	int n_dochan;		/*  num of DO chans */
@@ -349,7 +349,7 @@ struct pcl818_private {
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
 	unsigned char neverending_ai;	/*  if=1, then we do neverending record (you must use cancel()) */
-	unsigned int ns_min;	/*  manimal alllowed delay between samples (in us) for actual card */
+	unsigned int ns_min;	/*  manimal allowed delay between samples (in us) for actual card */
 	int i8253_osc_base;	/*  1/frequency of on board oscilator in ns */
 	int irq_free;		/*  1=have allocated IRQ */
 	int irq_blocked;	/*  1=IRQ now uses any subdev */

commit 7114a28011f9d5f3d981731ad341177c21f9d948
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:30 2010 +0200

    Staging: comedi: Remove COMEDI_INITCLEANUP macro
    
    Move the init/exit routines to the respective C source files
    instead of calling COMEDI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 887f1c37aa6b..d2bd6f82b830 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -313,7 +313,18 @@ static struct comedi_driver driver_pcl818 = {
 	.offset = sizeof(struct pcl818_board),
 };
 
-COMEDI_INITCLEANUP(driver_pcl818);
+static int __init driver_pcl818_init_module(void)
+{
+	return comedi_driver_register(&driver_pcl818);
+}
+
+static void __exit driver_pcl818_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver_pcl818);
+}
+
+module_init(driver_pcl818_init_module);
+module_exit(driver_pcl818_cleanup_module);
 
 struct pcl818_private {
 

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 9d6aa393ef13..887f1c37aa6b 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -2036,3 +2036,7 @@ static int pcl818_detach(struct comedi_device *dev)
 	free_resources(dev);
 	return 0;
 }
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index c9d75385755d..9d6aa393ef13 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -102,6 +102,7 @@ A word or two about DMA. Driver support DMA operations at two ways:
 
 #include <linux/ioport.h>
 #include <linux/mc146818rtc.h>
+#include <linux/gfp.h>
 #include <linux/delay.h>
 #include <asm/dma.h>
 

commit 57ac827c9b17f2cc2f0f86c4fd43c3597c40253c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jan 20 13:04:51 2010 +0000

    Staging: comedi: pcl818: Remove unneeded chanlist_len check
    
    For AI command testing, the driver does not need to range-check the
    length of the channel list as the comedi core has already checked it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 40ac293ad89d..c9d75385755d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1392,14 +1392,6 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		}
 	}
 
-	if (!cmd->chanlist_len) {
-		cmd->chanlist_len = 1;
-		err++;
-	}
-	if (cmd->chanlist_len > s->n_chan) {
-		cmd->chanlist_len = s->n_chan;
-		err++;
-	}
 	if (cmd->scan_end_arg != cmd->chanlist_len) {
 		cmd->scan_end_arg = cmd->chanlist_len;
 		err++;

commit b3559cb1aa5f863e1ce9b94b518be7ddf6680e45
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jan 20 13:04:46 2010 +0000

    Staging: comedi: pcl818: Correct AI scan counting and channel checks
    
    For AI commands, the scan counter should be updated after every
    scan.  It was being updated after every sample except for DMA mode
    where it was being updated after every repeated segment of the
    channel list.
    
    Also AI commands with multiple channels were being terminated with
    an error prematurely except in DMA mode.  This was because the
    driver was comparing channel numbers received from the hardware
    (combined with the sample value) with the expected channel numbers
    to check for a "channel dropout".  This test was failing
    incorrectly because the driver was not keeping the current position
    within the (repeated segment of the) channel list up to date.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index d0481013a837..40ac293ad89d 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -557,8 +557,14 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 		comedi_event(dev, s);
 		return IRQ_HANDLED;
 	}
-	if (s->async->cur_chan == 0) {
+	devpriv->act_chanlist_pos++;
+	if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len) {
+		devpriv->act_chanlist_pos = 0;
+	}
+	s->async->cur_chan++;
+	if (s->async->cur_chan >= devpriv->ai_n_chan) {
 		/*  printk("E"); */
+		s->async->cur_chan = 0;
 		devpriv->ai_act_scan--;
 	}
 
@@ -627,9 +633,13 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 
 		devpriv->act_chanlist_pos++;
 		if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len) {
-			devpriv->ai_act_scan--;
 			devpriv->act_chanlist_pos = 0;
 		}
+		s->async->cur_chan++;
+		if (s->async->cur_chan >= devpriv->ai_n_chan) {
+			s->async->cur_chan = 0;
+			devpriv->ai_act_scan--;
+		}
 
 		if (!devpriv->neverending_ai)
 			if (devpriv->ai_act_scan == 0) {	/* all data sampled */
@@ -717,7 +727,14 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 			comedi_buf_put(s->async, dmabuf[bufptr++] >> 4);	/*  get one sample */
 			bufptr &= (devpriv->dmasamplsize - 1);
 
-			if (s->async->cur_chan == 0) {
+			devpriv->act_chanlist_pos++;
+			if (devpriv->act_chanlist_pos >=
+					devpriv->act_chanlist_len) {
+				devpriv->act_chanlist_pos = 0;
+			}
+			s->async->cur_chan++;
+			if (s->async->cur_chan >= devpriv->ai_n_chan) {
+				s->async->cur_chan = 0;
 				devpriv->ai_act_scan--;
 			}
 
@@ -796,7 +813,13 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 
 		comedi_buf_put(s->async, (lo >> 4) | (inb(dev->iobase + PCL818_FI_DATAHI) << 4));	/*  get one sample */
 
-		if (s->async->cur_chan == 0) {
+		devpriv->act_chanlist_pos++;
+		if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len) {
+			devpriv->act_chanlist_pos = 0;
+		}
+		s->async->cur_chan++;
+		if (s->async->cur_chan >= devpriv->ai_n_chan) {
+			s->async->cur_chan = 0;
 			devpriv->ai_act_scan--;
 		}
 

commit bbc9a9916bc1cd997f3bf303e7930d5f3c804d37
Author: Andr Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:06 2009 -0200

    Staging: fix assorted typos all over the place
    
    Signed-off-by: Andr Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 819dd838b075..d0481013a837 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -50,7 +50,7 @@ A word or two about DMA. Driver support DMA operations at two ways:
           1, 10=A/D input -10V..+10V
     [5] - 0,  5=D/A output 0-5V  (internal reference -5V)
           1, 10=D/A output 0-10V (internal reference -10V)
-	  2    =D/A output unknow (external reference)
+	  2    =D/A output unknown (external reference)
 
    Options for PCL-818, PCL-818H:
     [0] - IO Base
@@ -60,7 +60,7 @@ A word or two about DMA. Driver support DMA operations at two ways:
               1= 1MHz clock for 8254
     [4] - 0,  5=D/A output 0-5V  (internal reference -5V)
           1, 10=D/A output 0-10V (internal reference -10V)
-	  2    =D/A output unknow (external reference)
+	  2    =D/A output unknown (external reference)
 
    Options for PCL-818HD, PCL-818HG:
     [0] - IO Base
@@ -71,7 +71,7 @@ A word or two about DMA. Driver support DMA operations at two ways:
               1= 1MHz clock for 8254
     [4] - 0,  5=D/A output 0-5V  (internal reference -5V)
           1, 10=D/A output 0-10V (internal reference -10V)
-   	  2    =D/A output unknow (external reference)
+   	  2    =D/A output unknown (external reference)
 
    Options for PCL-718:
     [0] - IO Base
@@ -92,7 +92,7 @@ A word or two about DMA. Driver support DMA operations at two ways:
 	     10=	     user defined unipolar
     [5] - 0,  5=D/A outputs 0-5V  (internal reference -5V)
           1, 10=D/A outputs 0-10V (internal reference -10V)
-	      2=D/A outputs unknow (external reference)
+	      2=D/A outputs unknown (external reference)
     [6] - 0, 60=max  60kHz A/D sampling
           1,100=max 100kHz A/D sampling (PCL-718 with Option 001 installed)
 
@@ -876,7 +876,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 		return IRQ_NONE;
 	}
 
-	comedi_error(dev, "IRQ from unknow source!");
+	comedi_error(dev, "IRQ from unknown source!");
 	return IRQ_NONE;
 }
 

commit 48b1aff5b93521c5ad90842bef52b218ac50a4ab
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 20 11:32:37 2009 +0000

    Staging: comedi: initialize divisor variables
    
    The i8253_cascade_ns_to_timer_2div() function (and
    i8253_cascade_ns_to_timer macro) checks the old values *d1 and *d2
    for correctness as a heuristic before calculating new values.  Don't
    call the function with uninitialized values in *d1 and *d2.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index e95229b13118..819dd838b075 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -970,7 +970,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 			      struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
-	int divisor1, divisor2;
+	int divisor1 = 0, divisor2 = 0;
 	unsigned int seglen;
 
 	printk("pcl818_ai_cmd_mode()\n");
@@ -1089,7 +1089,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 static int pcl818_ao_mode13(int mode, struct comedi_device *dev,
 			    struct comedi_subdevice *s, comedi_trig * it)
 {
-	int divisor1, divisor2;
+	int divisor1 = 0, divisor2 = 0;
 
 	if (!dev->irq) {
 		comedi_error(dev, "IRQ not defined!");
@@ -1287,7 +1287,7 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int tmp, divisor1, divisor2;
+	int tmp, divisor1 = 0, divisor2 = 0;
 
 	/* step 1: make sure trigger sources are trivially valid */
 

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 039a77a66451..e95229b13118 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -195,56 +195,58 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define MAGIC_DMA_WORD 0x5a5a
 
 static const struct comedi_lrange range_pcl818h_ai = { 9, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-			BIP_RANGE(10),
-	}
+							   BIP_RANGE(5),
+							   BIP_RANGE(2.5),
+							   BIP_RANGE(1.25),
+							   BIP_RANGE(0.625),
+							   UNI_RANGE(10),
+							   UNI_RANGE(5),
+							   UNI_RANGE(2.5),
+							   UNI_RANGE(1.25),
+							   BIP_RANGE(10),
+							   }
 };
 
 static const struct comedi_lrange range_pcl818hg_ai = { 10, {
-			BIP_RANGE(5),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.05),
-			BIP_RANGE(0.005),
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.01),
-			BIP_RANGE(10),
-			BIP_RANGE(1),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.01),
-	}
+							     BIP_RANGE(5),
+							     BIP_RANGE(0.5),
+							     BIP_RANGE(0.05),
+							     BIP_RANGE(0.005),
+							     UNI_RANGE(10),
+							     UNI_RANGE(1),
+							     UNI_RANGE(0.1),
+							     UNI_RANGE(0.01),
+							     BIP_RANGE(10),
+							     BIP_RANGE(1),
+							     BIP_RANGE(0.1),
+							     BIP_RANGE(0.01),
+							     }
 };
 
 static const struct comedi_lrange range_pcl818l_l_ai = { 4, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-	}
+							     BIP_RANGE(5),
+							     BIP_RANGE(2.5),
+							     BIP_RANGE(1.25),
+							     BIP_RANGE(0.625),
+							     }
 };
 
 static const struct comedi_lrange range_pcl818l_h_ai = { 4, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-	}
+							     BIP_RANGE(10),
+							     BIP_RANGE(5),
+							     BIP_RANGE(2.5),
+							     BIP_RANGE(1.25),
+							     }
 };
 
 static const struct comedi_lrange range718_bipolar1 = { 1, {BIP_RANGE(1),} };
-static const struct comedi_lrange range718_bipolar0_5 = { 1, {BIP_RANGE(0.5),} };
+static const struct comedi_lrange range718_bipolar0_5 =
+    { 1, {BIP_RANGE(0.5),} };
 static const struct comedi_lrange range718_unipolar2 = { 1, {UNI_RANGE(2),} };
 static const struct comedi_lrange range718_unipolar1 = { 1, {BIP_RANGE(1),} };
 
-static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcl818_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcl818_detach(struct comedi_device *dev);
 
 #ifdef unused
@@ -273,30 +275,29 @@ struct pcl818_board {
 	int is_818;
 };
 
-
 static const struct pcl818_board boardtypes[] = {
 	{"pcl818l", 4, 16, 8, 25000, 1, 16, 16, &range_pcl818l_l_ai,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 0, 1},
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 1},
 	{"pcl818h", 9, 16, 8, 10000, 1, 16, 16, &range_pcl818h_ai,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 0, 1},
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 1},
 	{"pcl818hd", 9, 16, 8, 10000, 1, 16, 16, &range_pcl818h_ai,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 1, 1},
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 1, 1},
 	{"pcl818hg", 12, 16, 8, 10000, 1, 16, 16, &range_pcl818hg_ai,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 1, 1},
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 1, 1},
 	{"pcl818", 9, 16, 8, 10000, 2, 16, 16, &range_pcl818h_ai,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 0, 1},
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 1},
 	{"pcl718", 1, 16, 8, 16000, 2, 16, 16, &range_unipolar5,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 0, 0},
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 0},
 	/* pcm3718 */
 	{"pcm3718", 9, 16, 8, 10000, 0, 16, 16, &range_pcl818h_ai,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 0, 1 /* XXX ? */ },
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 1 /* XXX ? */ },
 };
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct pcl818_board))
@@ -353,7 +354,7 @@ struct pcl818_private {
 	unsigned int *ai_chanlist;	/*  actaul chanlist */
 	unsigned int ai_flags;	/*  flaglist */
 	unsigned int ai_data_len;	/*  len of data buffer */
-	short *ai_data;	/*  data buffer */
+	short *ai_data;		/*  data buffer */
 	unsigned int ai_timer1;	/*  timers */
 	unsigned int ai_timer2;
 	struct comedi_subdevice *sub_ai;	/*  ptr to AI subdevice */
@@ -361,7 +362,6 @@ struct pcl818_private {
 	unsigned int ao_readback[2];
 };
 
-
 static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	/*  used for gain list programming */
 	0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
 };
@@ -372,14 +372,18 @@ static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0
 /*
 ==============================================================================
 */
-static void setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen);
-static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan);
-
-static int pcl818_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2);
+static void setup_channel_list(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned int *chanlist, unsigned int n_chan,
+			       unsigned int seglen);
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      unsigned int *chanlist, unsigned int n_chan);
+
+static int pcl818_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2);
 
 #ifdef unused
 static int set_rtc_irq_bit(unsigned char bit);
@@ -391,8 +395,9 @@ static int rtc_setfreq_irq(int freq);
 ==============================================================================
    ANALOG INPUT MODE0, 818 cards, slow version
 */
-static int pcl818_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl818_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int timeout;
@@ -425,9 +430,9 @@ static int pcl818_ai_insn_read(struct comedi_device *dev, struct comedi_subdevic
 		outb(0, dev->iobase + PCL818_CLRINT);
 		return -EIO;
 
-	      conv_finish:
+conv_finish:
 		data[n] = ((inb(dev->iobase + PCL818_AD_HI) << 4) |
-			(inb(dev->iobase + PCL818_AD_LO) >> 4));
+			   (inb(dev->iobase + PCL818_AD_LO) >> 4));
 	}
 
 	return n;
@@ -438,8 +443,9 @@ static int pcl818_ai_insn_read(struct comedi_device *dev, struct comedi_subdevic
    ANALOG OUTPUT MODE0, 818 cards
    only one sample per call is supported
 */
-static int pcl818_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl818_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -451,8 +457,9 @@ static int pcl818_ao_insn_read(struct comedi_device *dev, struct comedi_subdevic
 	return n;
 }
 
-static int pcl818_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl818_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -460,9 +467,9 @@ static int pcl818_ao_insn_write(struct comedi_device *dev, struct comedi_subdevi
 	for (n = 0; n < insn->n; n++) {
 		devpriv->ao_readback[chan] = data[n];
 		outb((data[n] & 0x000f) << 4, dev->iobase +
-			(chan ? PCL718_DA2_LO : PCL818_DA_LO));
+		     (chan ? PCL718_DA2_LO : PCL818_DA_LO));
 		outb((data[n] & 0x0ff0) >> 4, dev->iobase +
-			(chan ? PCL718_DA2_HI : PCL818_DA_HI));
+		     (chan ? PCL718_DA2_HI : PCL818_DA_HI));
 	}
 
 	return n;
@@ -474,14 +481,15 @@ static int pcl818_ao_insn_write(struct comedi_device *dev, struct comedi_subdevi
 
    only one sample per call is supported
 */
-static int pcl818_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl818_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
 
 	data[1] = inb(dev->iobase + PCL818_DI_LO) |
-		(inb(dev->iobase + PCL818_DI_HI) << 8);
+	    (inb(dev->iobase + PCL818_DI_HI) << 8);
 
 	return 2;
 }
@@ -492,8 +500,9 @@ static int pcl818_di_insn_bits(struct comedi_device *dev, struct comedi_subdevic
 
    only one sample per call is supported
 */
-static int pcl818_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl818_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -533,16 +542,16 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 	comedi_event(dev, s);
 	return IRQ_HANDLED;
 
-      conv_finish:
+conv_finish:
 	low = inb(dev->iobase + PCL818_AD_LO);
 	comedi_buf_put(s->async, ((inb(dev->iobase + PCL818_AD_HI) << 4) | (low >> 4)));	/*  get one sample */
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
 	if ((low & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
 		printk
-			("comedi: A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
-			(low & 0xf),
-			devpriv->act_chanlist[devpriv->act_chanlist_pos]);
+		    ("comedi: A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
+		     (low & 0xf),
+		     devpriv->act_chanlist[devpriv->act_chanlist_pos]);
 		pcl818_ai_cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		comedi_event(dev, s);
@@ -581,10 +590,11 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 		set_dma_mode(devpriv->dma, DMA_MODE_READ);
 		flags = claim_dma_lock();
 		set_dma_addr(devpriv->dma,
-			devpriv->hwdmaptr[devpriv->next_dma_buf]);
+			     devpriv->hwdmaptr[devpriv->next_dma_buf]);
 		if (devpriv->dma_runs_to_end || devpriv->neverending_ai) {
 			set_dma_count(devpriv->dma,
-				devpriv->hwdmasize[devpriv->next_dma_buf]);
+				      devpriv->hwdmasize[devpriv->
+							 next_dma_buf]);
 		} else {
 			set_dma_count(devpriv->dma, devpriv->last_dma_run);
 		}
@@ -595,7 +605,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 
 	devpriv->dma_runs_to_end--;
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
-	ptr = (short *) devpriv->dmabuf[1 - devpriv->next_dma_buf];
+	ptr = (short *)devpriv->dmabuf[1 - devpriv->next_dma_buf];
 
 	len = devpriv->hwdmasize[0] >> 1;
 	bufptr = 0;
@@ -603,11 +613,10 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 	for (i = 0; i < len; i++) {
 		if ((ptr[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
 			printk
-				("comedi: A/D mode1/3 DMA - channel dropout %d(card)!=%d(chanlist) at %d !\n",
-				(ptr[bufptr] & 0xf),
-				devpriv->act_chanlist[devpriv->
-					act_chanlist_pos],
-				devpriv->act_chanlist_pos);
+			    ("comedi: A/D mode1/3 DMA - channel dropout %d(card)!=%d(chanlist) at %d !\n",
+			     (ptr[bufptr] & 0xf),
+			     devpriv->act_chanlist[devpriv->act_chanlist_pos],
+			     devpriv->act_chanlist_pos);
 			pcl818_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			comedi_event(dev, s);
@@ -649,7 +658,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 	unsigned long tmp;
 	unsigned int top1, top2, i, bufptr;
 	long ofs_dats;
-	short *dmabuf = (short *) devpriv->dmabuf[0];
+	short *dmabuf = (short *)devpriv->dmabuf[0];
 
 	/* outb(2,0x378); */
 	switch (devpriv->ai_mode) {
@@ -657,7 +666,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 	case INT_TYPE_AI3_DMA_RTC:
 		tmp = (CMOS_READ(RTC_INTR_FLAGS) & 0xF0);
 		mod_timer(&devpriv->rtc_irq_timer,
-			jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100);
+			  jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100);
 
 		for (i = 0; i < 10; i++) {
 			top1 = get_dma_residue(devpriv->dma);
@@ -694,13 +703,13 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 		for (i = 0; i < ofs_dats; i++) {
 			if ((dmabuf[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
 				printk
-					("comedi: A/D mode1/3 DMA - channel dropout %d!=%d !\n",
-					(dmabuf[bufptr] & 0xf),
-					devpriv->act_chanlist[devpriv->
-						act_chanlist_pos]);
+				    ("comedi: A/D mode1/3 DMA - channel dropout %d!=%d !\n",
+				     (dmabuf[bufptr] & 0xf),
+				     devpriv->
+				     act_chanlist[devpriv->act_chanlist_pos]);
 				pcl818_ai_cancel(dev, s);
 				s->async->events |=
-					COMEDI_CB_EOA | COMEDI_CB_ERROR;
+				    COMEDI_CB_EOA | COMEDI_CB_ERROR;
 				comedi_event(dev, s);
 				return IRQ_HANDLED;
 			}
@@ -776,10 +785,9 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 		lo = inb(dev->iobase + PCL818_FI_DATALO);
 		if ((lo & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
 			printk
-				("comedi: A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
-				(lo & 0xf),
-				devpriv->act_chanlist[devpriv->
-					act_chanlist_pos]);
+			    ("comedi: A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
+			     (lo & 0xf),
+			     devpriv->act_chanlist[devpriv->act_chanlist_pos]);
 			pcl818_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			comedi_event(dev, s);
@@ -822,9 +830,9 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 
 	if (devpriv->irq_blocked && devpriv->irq_was_now_closed) {
 		if ((devpriv->neverending_ai || (!devpriv->neverending_ai &&
-						devpriv->ai_act_scan > 0)) &&
-				(devpriv->ai_mode == INT_TYPE_AI1_DMA ||
-				 devpriv->ai_mode == INT_TYPE_AI3_DMA)) {
+						 devpriv->ai_act_scan > 0)) &&
+		    (devpriv->ai_mode == INT_TYPE_AI1_DMA ||
+		     devpriv->ai_mode == INT_TYPE_AI3_DMA)) {
 			/* The cleanup from ai_cancel() has been delayed
 			   until now because the card doesn't seem to like
 			   being reprogrammed while a DMA transfer is in
@@ -863,7 +871,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
 	if ((!dev->irq) || (!devpriv->irq_free) || (!devpriv->irq_blocked)
-		|| (!devpriv->ai_mode)) {
+	    || (!devpriv->ai_mode)) {
 		comedi_error(dev, "bad IRQ!");
 		return IRQ_NONE;
 	}
@@ -877,7 +885,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
    ANALOG INPUT MODE 1 or 3 DMA , 818 cards
 */
 static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
-	struct comedi_subdevice *s)
+				    struct comedi_subdevice *s)
 {
 	unsigned int flags;
 	unsigned int bytes;
@@ -918,7 +926,7 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
    ANALOG INPUT MODE 1 or 3 DMA rtc, 818 cards
 */
 static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device *dev,
-	struct comedi_subdevice *s)
+				    struct comedi_subdevice *s)
 {
 	unsigned int flags;
 	short *pole;
@@ -931,13 +939,13 @@ static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device *dev,
 	release_dma_lock(flags);
 	enable_dma(devpriv->dma);
 	devpriv->last_top_dma = 0;	/* devpriv->hwdmasize[0]; */
-	pole = (short *) devpriv->dmabuf[0];
+	pole = (short *)devpriv->dmabuf[0];
 	devpriv->dmasamplsize = devpriv->hwdmasize[0] / 2;
 	pole[devpriv->dmasamplsize - 1] = MAGIC_DMA_WORD;
 #ifdef unused
 	devpriv->rtc_freq = rtc_setfreq_irq(2048);
 	devpriv->rtc_irq_timer.expires =
-		jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100;
+	    jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100;
 	devpriv->rtc_irq_timer.data = (unsigned long)dev;
 	devpriv->rtc_irq_timer.function = rtc_dropped_irq;
 
@@ -959,7 +967,7 @@ static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device *dev,
    ANALOG INPUT MODE 1 or 3, 818 cards
 */
 static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
-	struct comedi_subdevice *s)
+			      struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int divisor1, divisor2;
@@ -977,11 +985,11 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	seglen = check_channel_list(dev, s, devpriv->ai_chanlist,
-		devpriv->ai_n_chan);
+				    devpriv->ai_n_chan);
 	if (seglen < 1)
 		return -EINVAL;
 	setup_channel_list(dev, s, devpriv->ai_chanlist,
-		devpriv->ai_n_chan, seglen);
+			   devpriv->ai_n_chan, seglen);
 
 	udelay(1);
 
@@ -998,7 +1006,8 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 
 	if (mode == 1) {
 		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
-			&divisor2, &cmd->convert_arg, TRIG_ROUND_NEAREST);
+					  &divisor2, &cmd->convert_arg,
+					  TRIG_ROUND_NEAREST);
 		if (divisor1 == 1) {	/* PCL718/818 crash if any divisor is set to 1 */
 			divisor1 = 2;
 			divisor2 /= 2;
@@ -1034,11 +1043,13 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 			if (mode == 1) {
 				devpriv->ai_mode = INT_TYPE_AI1_INT;
 				/* Pacer+IRQ */
-				outb(0x83 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);
+				outb(0x83 | (dev->irq << 4),
+				     dev->iobase + PCL818_CONTROL);
 			} else {
 				devpriv->ai_mode = INT_TYPE_AI3_INT;
 				/* Ext trig+IRQ */
-				outb(0x82 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);
+				outb(0x82 | (dev->irq << 4),
+				     dev->iobase + PCL818_CONTROL);
 			}
 		} else {
 			/* FIFO */
@@ -1075,8 +1086,8 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
    ANALOG OUTPUT MODE 1 or 3, 818 cards
 */
 #ifdef PCL818_MODE13_AO
-static int pcl818_ao_mode13(int mode, struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_trig *it)
+static int pcl818_ao_mode13(int mode, struct comedi_device *dev,
+			    struct comedi_subdevice *s, comedi_trig * it)
 {
 	int divisor1, divisor2;
 
@@ -1099,7 +1110,8 @@ static int pcl818_ao_mode13(int mode, struct comedi_device *dev, struct comedi_s
 
 	if (mode == 1) {
 		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
-			&divisor2, &it->trigvar, TRIG_ROUND_NEAREST);
+					  &divisor2, &it->trigvar,
+					  TRIG_ROUND_NEAREST);
 		if (divisor1 == 1) {	/* PCL818 crash if any divisor is set to 1 */
 			divisor1 = 2;
 			divisor2 /= 2;
@@ -1128,8 +1140,8 @@ static int pcl818_ao_mode13(int mode, struct comedi_device *dev, struct comedi_s
 ==============================================================================
    ANALOG OUTPUT MODE 1, 818 cards
 */
-static int pcl818_ao_mode1(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_trig *it)
+static int pcl818_ao_mode1(struct comedi_device *dev,
+			   struct comedi_subdevice *s, comedi_trig * it)
 {
 	return pcl818_ao_mode13(1, dev, s, it);
 }
@@ -1138,8 +1150,8 @@ static int pcl818_ao_mode1(struct comedi_device *dev, struct comedi_subdevice *s
 ==============================================================================
    ANALOG OUTPUT MODE 3, 818 cards
 */
-static int pcl818_ao_mode3(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_trig *it)
+static int pcl818_ao_mode3(struct comedi_device *dev,
+			   struct comedi_subdevice *s, comedi_trig * it)
 {
 	return pcl818_ao_mode13(3, dev, s, it);
 }
@@ -1150,8 +1162,8 @@ static int pcl818_ao_mode3(struct comedi_device *dev, struct comedi_subdevice *s
 ==============================================================================
  Start/stop pacer onboard pacer
 */
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2)
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2)
 {
 	outb(0xb4, dev->iobase + PCL818_CTRCTL);
 	outb(0x74, dev->iobase + PCL818_CTRCTL);
@@ -1170,8 +1182,9 @@ static void start_pacer(struct comedi_device *dev, int mode, unsigned int diviso
  Check if channel list from user is builded correctly
  If it's ok, then program scan/gain logic
 */
-static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan)
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      unsigned int *chanlist, unsigned int n_chan)
 {
 	unsigned int chansegment[16];
 	unsigned int i, nowmustbechan, seglen, segpos;
@@ -1196,12 +1209,12 @@ static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice
 			if (chanlist[0] == chanlist[i])
 				break;
 			nowmustbechan =
-				(CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
+			    (CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continous :-( */
 				printk
-					("comedi%d: pcl818: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
-					dev->minor, i, CR_CHAN(chanlist[i]),
-					nowmustbechan, CR_CHAN(chanlist[0]));
+				    ("comedi%d: pcl818: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
+				     dev->minor, i, CR_CHAN(chanlist[i]),
+				     nowmustbechan, CR_CHAN(chanlist[0]));
 				return 0;
 			}
 			/*  well, this is next correct channel in list */
@@ -1213,13 +1226,13 @@ static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice
 			/* printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i])); */
 			if (chanlist[i] != chansegment[i % seglen]) {
 				printk
-					("comedi%d: pcl818: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
-					dev->minor, i, CR_CHAN(chansegment[i]),
-					CR_RANGE(chansegment[i]),
-					CR_AREF(chansegment[i]),
-					CR_CHAN(chanlist[i % seglen]),
-					CR_RANGE(chanlist[i % seglen]),
-					CR_AREF(chansegment[i % seglen]));
+				    ("comedi%d: pcl818: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
+				     dev->minor, i, CR_CHAN(chansegment[i]),
+				     CR_RANGE(chansegment[i]),
+				     CR_AREF(chansegment[i]),
+				     CR_CHAN(chanlist[i % seglen]),
+				     CR_RANGE(chanlist[i % seglen]),
+				     CR_AREF(chansegment[i % seglen]));
 				return 0;	/*  chan/gain list is strange */
 			}
 		}
@@ -1230,8 +1243,10 @@ static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice
 	return seglen;
 }
 
-static void setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen)
+static void setup_channel_list(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned int *chanlist, unsigned int n_chan,
+			       unsigned int seglen)
 {
 	int i;
 
@@ -1248,7 +1263,8 @@ static void setup_channel_list(struct comedi_device *dev, struct comedi_subdevic
 
 	/* select channel interval to scan */
 	outb(devpriv->act_chanlist[0] | (devpriv->act_chanlist[seglen -
-				1] << 4), dev->iobase + PCL818_MUX);
+							       1] << 4),
+	     dev->iobase + PCL818_MUX);
 }
 
 /*
@@ -1268,7 +1284,7 @@ static int check_single_ended(unsigned int port)
 ==============================================================================
 */
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+		      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
@@ -1386,8 +1402,8 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
-			&divisor2, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  &divisor2, &cmd->convert_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (cmd->convert_arg < this_board->ns_min)
 			cmd->convert_arg = this_board->ns_min;
 		if (tmp != cmd->convert_arg)
@@ -1402,7 +1418,7 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	if (cmd->chanlist) {
 		if (!check_channel_list(dev, s, cmd->chanlist,
-				cmd->chanlist_len))
+					cmd->chanlist_len))
 			return 5;	/*  incorrect channels list */
 	}
 
@@ -1451,7 +1467,8 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 ==============================================================================
  cancel any mode 1-4 AI
 */
-static int pcl818_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pcl818_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	if (devpriv->irq_blocked > 0) {
 		printk("pcl818_ai_cancel()\n");
@@ -1467,8 +1484,8 @@ static int pcl818_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *
 		case INT_TYPE_AI1_DMA:
 		case INT_TYPE_AI3_DMA:
 			if (devpriv->neverending_ai ||
-					(!devpriv->neverending_ai &&
-					 devpriv->ai_act_scan > 0)) {
+			    (!devpriv->neverending_ai &&
+			     devpriv->ai_act_scan > 0)) {
 				/* wait for running dma transfer to end, do cleanup in interrupt */
 				goto end;
 			}
@@ -1503,7 +1520,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *
 		}
 	}
 
-      end:
+end:
 	printk("pcl818_ai_cancel() end\n");
 	return 0;
 }
@@ -1612,7 +1629,7 @@ static void rtc_dropped_irq(unsigned long data)
 	case INT_TYPE_AI1_DMA_RTC:
 	case INT_TYPE_AI3_DMA_RTC:
 		mod_timer(&devpriv->rtc_irq_timer,
-			jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100);
+			  jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100);
 		save_flags(flags);
 		cli();
 		tmp = (CMOS_READ(RTC_INTR_FLAGS) & 0xF0);	/* restart */
@@ -1674,7 +1691,7 @@ static void free_resources(struct comedi_device *dev)
 		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
 			if (devpriv->rtc_iobase)
 				release_region(devpriv->rtc_iobase,
-					devpriv->rtc_iosize);
+					       devpriv->rtc_iosize);
 		}
 		if (devpriv->dma_rtc)
 			RTC_lock--;
@@ -1710,7 +1727,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* claim our I/O space */
 	iobase = it->options[0];
 	printk("comedi%d: pcl818:  board=%s, ioport=0x%03lx",
-		dev->minor, this_board->name, iobase);
+	       dev->minor, this_board->name, iobase);
 	devpriv->io_range = this_board->io_range;
 	if ((this_board->fifo) && (it->options[2] == -1)) {	/*  we've board with FIFO and we want to use FIFO */
 		devpriv->io_range = PCLx1xFIFO_RANGE;
@@ -1737,14 +1754,15 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & this_board->IRQbits) == 0) {
 				printk
-					(", IRQ %u is out of allowed range, DISABLING IT",
-					irq);
+				    (", IRQ %u is out of allowed range, DISABLING IT",
+				     irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (request_irq(irq, interrupt_pcl818, 0, "pcl818", dev)) {
+				if (request_irq
+				    (irq, interrupt_pcl818, 0, "pcl818", dev)) {
 					printk
-						(", unable to allocate IRQ %u, DISABLING IT",
-						irq);
+					    (", unable to allocate IRQ %u, DISABLING IT",
+					     irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
 					printk(", irq=%u", irq);
@@ -1769,14 +1787,14 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (it->options[2] > 0) {	/*  we want to use DMA */
 		if (RTC_lock == 0) {
 			if (!request_region(RTC_PORT(0), RTC_IO_EXTENT,
-					"pcl818 (RTC)"))
+					    "pcl818 (RTC)"))
 				goto no_rtc;
 		}
 		devpriv->rtc_iobase = RTC_PORT(0);
 		devpriv->rtc_iosize = RTC_IO_EXTENT;
 		RTC_lock++;
 		if (!request_irq(RTC_IRQ, interrupt_pcl818_ai_mode13_dma_rtc, 0,
-				"pcl818 DMA (RTC)", dev)) {
+				 "pcl818 DMA (RTC)", dev)) {
 			devpriv->dma_rtc = 1;
 			devpriv->rtc_irq = RTC_IRQ;
 			printk(", dma_irq=%u", devpriv->rtc_irq);
@@ -1785,14 +1803,14 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			if (RTC_lock == 0) {
 				if (devpriv->rtc_iobase)
 					release_region(devpriv->rtc_iobase,
-						devpriv->rtc_iosize);
+						       devpriv->rtc_iosize);
 			}
 			devpriv->rtc_iobase = 0;
 			devpriv->rtc_iosize = 0;
 		}
 	}
 
-      no_rtc:
+no_rtc:
 #endif
 	/* grab our DMA */
 	dma = 0;
@@ -1829,17 +1847,17 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 			if (!devpriv->dmabuf[1]) {
 				printk
-					(", unable to allocate DMA buffer, FAIL!\n");
+				    (", unable to allocate DMA buffer, FAIL!\n");
 				return -EBUSY;
 			}
 			devpriv->dmapages[1] = pages;
 			devpriv->hwdmaptr[1] =
-				virt_to_bus((void *)devpriv->dmabuf[1]);
+			    virt_to_bus((void *)devpriv->dmabuf[1]);
 			devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
 		}
 	}
 
-      no_dma:
+no_dma:
 
 	ret = alloc_subdevices(dev, 4);
 	if (ret < 0)

commit f764df88f86c8db669bd7bfac230b9d2689ae322
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Thu May 14 13:58:26 2009 +0200

    staging: comedi: fix missing parentheses
    
    Add missing parentheses.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 607c71744bfc..039a77a66451 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -460,9 +460,9 @@ static int pcl818_ao_insn_write(struct comedi_device *dev, struct comedi_subdevi
 	for (n = 0; n < insn->n; n++) {
 		devpriv->ao_readback[chan] = data[n];
 		outb((data[n] & 0x000f) << 4, dev->iobase +
-			(chan) ? PCL718_DA2_LO : PCL818_DA_LO);
+			(chan ? PCL718_DA2_LO : PCL818_DA_LO));
 		outb((data[n] & 0x0ff0) >> 4, dev->iobase +
-			(chan) ? PCL718_DA2_HI : PCL818_DA_HI);
+			(chan ? PCL718_DA2_HI : PCL818_DA_HI));
 	}
 
 	return n;

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index acca36212773..607c71744bfc 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -418,7 +418,7 @@ static int pcl818_ai_insn_read(struct comedi_device *dev, struct comedi_subdevic
 		while (timeout--) {
 			if (inb(dev->iobase + PCL818_STATUS) & 0x10)
 				goto conv_finish;
-			comedi_udelay(1);
+			udelay(1);
 		}
 		comedi_error(dev, "A/D insn timeout");
 		/* clear INT (conversion end) flag */
@@ -524,7 +524,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 	while (timeout--) {
 		if (inb(dev->iobase + PCL818_STATUS) & 0x10)
 			goto conv_finish;
-		comedi_udelay(1);
+		udelay(1);
 	}
 	outb(0, dev->iobase + PCL818_STATUS);	/* clear INT request */
 	comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
@@ -539,7 +539,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
 	if ((low & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
-		rt_printk
+		printk
 			("comedi: A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
 			(low & 0xf),
 			devpriv->act_chanlist[devpriv->act_chanlist_pos]);
@@ -549,7 +549,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 	if (s->async->cur_chan == 0) {
-		/*  rt_printk("E"); */
+		/*  printk("E"); */
 		devpriv->ai_act_scan--;
 	}
 
@@ -591,7 +591,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 		release_dma_lock(flags);
 		enable_dma(devpriv->dma);
 	}
-	rt_printk("comedi: A/D mode1/3 IRQ \n");
+	printk("comedi: A/D mode1/3 IRQ \n");
 
 	devpriv->dma_runs_to_end--;
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
@@ -602,7 +602,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 
 	for (i = 0; i < len; i++) {
 		if ((ptr[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
-			rt_printk
+			printk
 				("comedi: A/D mode1/3 DMA - channel dropout %d(card)!=%d(chanlist) at %d !\n",
 				(ptr[bufptr] & 0xf),
 				devpriv->act_chanlist[devpriv->
@@ -681,19 +681,19 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 
 		if (dmabuf[i] != MAGIC_DMA_WORD) {	/*  DMA overflow! */
 			comedi_error(dev, "A/D mode1/3 DMA buffer overflow!");
-			/* rt_printk("I %d dmabuf[i] %d %d\n",i,dmabuf[i],devpriv->dmasamplsize); */
+			/* printk("I %d dmabuf[i] %d %d\n",i,dmabuf[i],devpriv->dmasamplsize); */
 			pcl818_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			comedi_event(dev, s);
 			return IRQ_HANDLED;
 		}
-		/* rt_printk("r %ld ",ofs_dats); */
+		/* printk("r %ld ",ofs_dats); */
 
 		bufptr = devpriv->last_top_dma;
 
 		for (i = 0; i < ofs_dats; i++) {
 			if ((dmabuf[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
-				rt_printk
+				printk
 					("comedi: A/D mode1/3 DMA - channel dropout %d!=%d !\n",
 					(dmabuf[bufptr] & 0xf),
 					devpriv->act_chanlist[devpriv->
@@ -775,7 +775,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 	for (i = 0; i < len; i++) {
 		lo = inb(dev->iobase + PCL818_FI_DATALO);
 		if ((lo & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
-			rt_printk
+			printk
 				("comedi: A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
 				(lo & 0xf),
 				devpriv->act_chanlist[devpriv->
@@ -818,7 +818,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 		comedi_error(dev, "premature interrupt");
 		return IRQ_HANDLED;
 	}
-	/* rt_printk("I\n"); */
+	/* printk("I\n"); */
 
 	if (devpriv->irq_blocked && devpriv->irq_was_now_closed) {
 		if ((devpriv->neverending_ai || (!devpriv->neverending_ai &&
@@ -882,7 +882,7 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
 	unsigned int flags;
 	unsigned int bytes;
 
-	rt_printk("mode13dma_int, mode: %d\n", mode);
+	printk("mode13dma_int, mode: %d\n", mode);
 	disable_dma(devpriv->dma);	/*  disable dma */
 	bytes = devpriv->hwdmasize[0];
 	if (!devpriv->neverending_ai) {
@@ -965,7 +965,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	int divisor1, divisor2;
 	unsigned int seglen;
 
-	rt_printk("pcl818_ai_cmd_mode()\n");
+	printk("pcl818_ai_cmd_mode()\n");
 	if ((!dev->irq) && (!devpriv->dma_rtc)) {
 		comedi_error(dev, "IRQ not defined!");
 		return -EINVAL;
@@ -983,7 +983,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	setup_channel_list(dev, s, devpriv->ai_chanlist,
 		devpriv->ai_n_chan, seglen);
 
-	comedi_udelay(1);
+	udelay(1);
 
 	devpriv->ai_act_scan = devpriv->ai_scans;
 	devpriv->ai_act_chan = 0;
@@ -1030,7 +1030,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 	case 0:
 		if (!devpriv->usefifo) {
 			/* IRQ */
-			/* rt_printk("IRQ\n"); */
+			/* printk("IRQ\n"); */
 			if (mode == 1) {
 				devpriv->ai_mode = INT_TYPE_AI1_INT;
 				/* Pacer+IRQ */
@@ -1065,7 +1065,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
 		break;
 	}
 #endif
-	rt_printk("pcl818_ai_cmd_mode() end\n");
+	printk("pcl818_ai_cmd_mode() end\n");
 	return 0;
 }
 
@@ -1155,7 +1155,7 @@ static void start_pacer(struct comedi_device *dev, int mode, unsigned int diviso
 {
 	outb(0xb4, dev->iobase + PCL818_CTRCTL);
 	outb(0x74, dev->iobase + PCL818_CTRCTL);
-	comedi_udelay(1);
+	udelay(1);
 
 	if (mode == 1) {
 		outb(divisor2 & 0xff, dev->iobase + PCL818_CTR2);
@@ -1188,7 +1188,7 @@ static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice
 		/*  build part of chanlist */
 		for (i = 1, seglen = 1; i < n_chan; i++, seglen++) {
 
-			/* rt_printk("%d. %d * %d\n",i,
+			/* printk("%d. %d * %d\n",i,
 			 * CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i]));*/
 
 			/* we detect loop, this must by finish */
@@ -1198,7 +1198,7 @@ static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice
 			nowmustbechan =
 				(CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continous :-( */
-				rt_printk
+				printk
 					("comedi%d: pcl818: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
 					dev->minor, i, CR_CHAN(chanlist[i]),
 					nowmustbechan, CR_CHAN(chanlist[0]));
@@ -1210,9 +1210,9 @@ static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice
 
 		/*  check whole chanlist */
 		for (i = 0, segpos = 0; i < n_chan; i++) {
-			/* rt_printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i])); */
+			/* printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i])); */
 			if (chanlist[i] != chansegment[i % seglen]) {
-				rt_printk
+				printk
 					("comedi%d: pcl818: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
 					dev->minor, i, CR_CHAN(chansegment[i]),
 					CR_RANGE(chansegment[i]),
@@ -1226,7 +1226,7 @@ static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice
 	} else {
 		seglen = 1;
 	}
-	rt_printk("check_channel_list: seglen %d\n", seglen);
+	printk("check_channel_list: seglen %d\n", seglen);
 	return seglen;
 }
 
@@ -1244,7 +1244,7 @@ static void setup_channel_list(struct comedi_device *dev, struct comedi_subdevic
 		outb(CR_RANGE(chanlist[i]), dev->iobase + PCL818_RANGE);	/* select gain */
 	}
 
-	comedi_udelay(1);
+	udelay(1);
 
 	/* select channel interval to scan */
 	outb(devpriv->act_chanlist[0] | (devpriv->act_chanlist[seglen -
@@ -1417,7 +1417,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
 
-	rt_printk("pcl818_ai_cmd()\n");
+	printk("pcl818_ai_cmd()\n");
 	devpriv->ai_n_chan = cmd->chanlist_len;
 	devpriv->ai_chanlist = cmd->chanlist;
 	devpriv->ai_flags = cmd->flags;
@@ -1436,7 +1436,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		if (cmd->convert_src == TRIG_TIMER) {	/*  mode 1 */
 			devpriv->ai_timer1 = cmd->convert_arg;
 			retval = pcl818_ai_cmd_mode(1, dev, s);
-			rt_printk("pcl818_ai_cmd() end\n");
+			printk("pcl818_ai_cmd() end\n");
 			return retval;
 		}
 		if (cmd->convert_src == TRIG_EXT) {	/*  mode 3 */
@@ -1454,7 +1454,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int pcl818_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	if (devpriv->irq_blocked > 0) {
-		rt_printk("pcl818_ai_cancel()\n");
+		printk("pcl818_ai_cancel()\n");
 		devpriv->irq_was_now_closed = 1;
 
 		switch (devpriv->ai_mode) {
@@ -1482,7 +1482,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *
 		case INT_TYPE_AO3_INT:
 #endif
 			outb(inb(dev->iobase + PCL818_CONTROL) & 0x73, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
-			comedi_udelay(1);
+			udelay(1);
 			start_pacer(dev, -1, 0, 0);
 			outb(0, dev->iobase + PCL818_AD_LO);
 			inb(dev->iobase + PCL818_AD_LO);
@@ -1504,7 +1504,7 @@ static int pcl818_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *
 	}
 
       end:
-	rt_printk("pcl818_ai_cancel() end\n");
+	printk("pcl818_ai_cancel() end\n");
 	return 0;
 }
 
@@ -1515,17 +1515,17 @@ static int pcl818_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *
 static int pcl818_check(unsigned long iobase)
 {
 	outb(0x00, iobase + PCL818_MUX);
-	comedi_udelay(1);
+	udelay(1);
 	if (inb(iobase + PCL818_MUX) != 0x00)
 		return 1;	/* there isn't card */
 	outb(0x55, iobase + PCL818_MUX);
-	comedi_udelay(1);
+	udelay(1);
 	if (inb(iobase + PCL818_MUX) != 0x55)
 		return 1;	/* there isn't card */
 	outb(0x00, iobase + PCL818_MUX);
-	comedi_udelay(1);
+	udelay(1);
 	outb(0x18, iobase + PCL818_CONTROL);
-	comedi_udelay(1);
+	udelay(1);
 	if (inb(iobase + PCL818_CONTROL) != 0x18)
 		return 1;	/* there isn't card */
 	return 0;		/*  ok, card exist */
@@ -1544,10 +1544,10 @@ static void pcl818_reset(struct comedi_device *dev)
 	}
 	outb(0, dev->iobase + PCL818_DA_LO);	/*  DAC=0V */
 	outb(0, dev->iobase + PCL818_DA_HI);
-	comedi_udelay(1);
+	udelay(1);
 	outb(0, dev->iobase + PCL818_DO_HI);	/*  DO=$0000 */
 	outb(0, dev->iobase + PCL818_DO_LO);
-	comedi_udelay(1);
+	udelay(1);
 	outb(0, dev->iobase + PCL818_CONTROL);
 	outb(0, dev->iobase + PCL818_CNTENABLE);
 	outb(0, dev->iobase + PCL818_MUX);
@@ -1658,7 +1658,7 @@ static int rtc_setfreq_irq(int freq)
 */
 static void free_resources(struct comedi_device *dev)
 {
-	/* rt_printk("free_resource()\n"); */
+	/* printk("free_resource()\n"); */
 	if (dev->private) {
 		pcl818_ai_cancel(dev, devpriv->sub_ai);
 		pcl818_reset(dev);
@@ -1670,7 +1670,7 @@ static void free_resources(struct comedi_device *dev)
 			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
 #ifdef unused
 		if (devpriv->rtc_irq)
-			comedi_free_irq(devpriv->rtc_irq, dev);
+			free_irq(devpriv->rtc_irq, dev);
 		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
 			if (devpriv->rtc_iobase)
 				release_region(devpriv->rtc_iobase,
@@ -1685,7 +1685,7 @@ static void free_resources(struct comedi_device *dev)
 		free_irq(dev->irq, dev);
 	if (dev->iobase)
 		release_region(dev->iobase, devpriv->io_range);
-	/* rt_printk("free_resource() end\n"); */
+	/* printk("free_resource() end\n"); */
 }
 
 /*
@@ -1717,14 +1717,14 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->usefifo = 1;
 	}
 	if (!request_region(iobase, devpriv->io_range, "pcl818")) {
-		rt_printk("I/O port conflict\n");
+		printk("I/O port conflict\n");
 		return -EIO;
 	}
 
 	dev->iobase = iobase;
 
 	if (pcl818_check(iobase)) {
-		rt_printk(", I can't detect board. FAIL!\n");
+		printk(", I can't detect board. FAIL!\n");
 		return -EIO;
 	}
 
@@ -1736,19 +1736,18 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		irq = it->options[1];
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & this_board->IRQbits) == 0) {
-				rt_printk
+				printk
 					(", IRQ %u is out of allowed range, DISABLING IT",
 					irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (comedi_request_irq(irq, interrupt_pcl818, 0,
-						"pcl818", dev)) {
-					rt_printk
+				if (request_irq(irq, interrupt_pcl818, 0, "pcl818", dev)) {
+					printk
 						(", unable to allocate IRQ %u, DISABLING IT",
 						irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
-					rt_printk(", irq=%u", irq);
+					printk(", irq=%u", irq);
 				}
 			}
 		}
@@ -1776,12 +1775,11 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->rtc_iobase = RTC_PORT(0);
 		devpriv->rtc_iosize = RTC_IO_EXTENT;
 		RTC_lock++;
-		if (!comedi_request_irq(RTC_IRQ,
-				interrupt_pcl818_ai_mode13_dma_rtc, 0,
+		if (!request_irq(RTC_IRQ, interrupt_pcl818_ai_mode13_dma_rtc, 0,
 				"pcl818 DMA (RTC)", dev)) {
 			devpriv->dma_rtc = 1;
 			devpriv->rtc_irq = RTC_IRQ;
-			rt_printk(", dma_irq=%u", devpriv->rtc_irq);
+			printk(", dma_irq=%u", devpriv->rtc_irq);
 		} else {
 			RTC_lock--;
 			if (RTC_lock == 0) {
@@ -1806,31 +1804,31 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (dma < 1)
 			goto no_dma;	/* DMA disabled */
 		if (((1 << dma) & this_board->DMAbits) == 0) {
-			rt_printk(", DMA is out of allowed range, FAIL!\n");
+			printk(", DMA is out of allowed range, FAIL!\n");
 			return -EINVAL;	/* Bad DMA */
 		}
 		ret = request_dma(dma, "pcl818");
 		if (ret) {
-			rt_printk(", unable to allocate DMA %u, FAIL!\n", dma);
+			printk(", unable to allocate DMA %u, FAIL!\n", dma);
 			return -EBUSY;	/* DMA isn't free */
 		}
 		devpriv->dma = dma;
-		rt_printk(", dma=%u", dma);
+		printk(", dma=%u", dma);
 		pages = 2;	/* we need 16KB */
 		devpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);
 		if (!devpriv->dmabuf[0]) {
-			rt_printk(", unable to allocate DMA buffer, FAIL!\n");
+			printk(", unable to allocate DMA buffer, FAIL!\n");
 			/* maybe experiment with try_to_free_pages() will help .... */
 			return -EBUSY;	/* no buffer :-( */
 		}
 		devpriv->dmapages[0] = pages;
 		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
 		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
-		/* rt_printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
+		/* printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
 		if (devpriv->dma_rtc == 0) {	/*  we must do duble buff :-( */
 			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 			if (!devpriv->dmabuf[1]) {
-				rt_printk
+				printk
 					(", unable to allocate DMA buffer, FAIL!\n");
 				return -EBUSY;
 			}
@@ -1989,7 +1987,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	pcl818_reset(dev);
 
-	rt_printk("\n");
+	printk("\n");
 
 	return 0;
 }
@@ -2000,7 +1998,7 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
  */
 static int pcl818_detach(struct comedi_device *dev)
 {
-	/*   rt_printk("comedi%d: pcl818: remove\n", dev->minor); */
+	/*   printk("comedi%d: pcl818: remove\n", dev->minor); */
 	free_resources(dev);
 	return 0;
 }

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 6fbc9abdbd7b..acca36212773 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -302,13 +302,13 @@ static const struct pcl818_board boardtypes[] = {
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct pcl818_board))
 
 static struct comedi_driver driver_pcl818 = {
-      driver_name:"pcl818",
-      module:THIS_MODULE,
-      attach:pcl818_attach,
-      detach:pcl818_detach,
-      board_name:&boardtypes[0].name,
-      num_names:n_boardtypes,
-      offset:sizeof(struct pcl818_board),
+	.driver_name = "pcl818",
+	.module = THIS_MODULE,
+	.attach = pcl818_attach,
+	.detach = pcl818_detach,
+	.board_name = &boardtypes[0].name,
+	.num_names = n_boardtypes,
+	.offset = sizeof(struct pcl818_board),
 };
 
 COMEDI_INITCLEANUP(driver_pcl818);

commit c3744138715045adb316284ee7a1e608f0278f6c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:47 2009 -0400

    Staging: comedi: remove assignment in conditionals
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index f1deeb247e19..6fbc9abdbd7b 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1703,7 +1703,8 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned long pages;
 	struct comedi_subdevice *s;
 
-	if ((ret = alloc_private(dev, sizeof(struct pcl818_private))) < 0)
+	ret = alloc_private(dev, sizeof(struct pcl818_private));
+	if (ret < 0)
 		return ret;	/* Can't alloc mem */
 
 	/* claim our I/O space */
@@ -1842,7 +1843,8 @@ static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
       no_dma:
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 495f802c39ac..f1deeb247e19 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -244,8 +244,8 @@ static const struct comedi_lrange range718_bipolar0_5 = { 1, {BIP_RANGE(0.5),} }
 static const struct comedi_lrange range718_unipolar2 = { 1, {UNI_RANGE(2),} };
 static const struct comedi_lrange range718_unipolar1 = { 1, {BIP_RANGE(1),} };
 
-static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int pcl818_detach(struct comedi_device * dev);
+static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcl818_detach(struct comedi_device *dev);
 
 #ifdef unused
 static int RTC_lock = 0;	/* RTC lock */
@@ -372,13 +372,13 @@ static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0
 /*
 ==============================================================================
 */
-static void setup_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
+static void setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen);
-static int check_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
+static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int *chanlist, unsigned int n_chan);
 
-static int pcl818_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static void start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
+static int pcl818_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
 	unsigned int divisor2);
 
 #ifdef unused
@@ -391,8 +391,8 @@ static int rtc_setfreq_irq(int freq);
 ==============================================================================
    ANALOG INPUT MODE0, 818 cards, slow version
 */
-static int pcl818_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pcl818_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int timeout;
@@ -438,8 +438,8 @@ static int pcl818_ai_insn_read(struct comedi_device * dev, struct comedi_subdevi
    ANALOG OUTPUT MODE0, 818 cards
    only one sample per call is supported
 */
-static int pcl818_ao_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pcl818_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -451,8 +451,8 @@ static int pcl818_ao_insn_read(struct comedi_device * dev, struct comedi_subdevi
 	return n;
 }
 
-static int pcl818_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pcl818_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -474,8 +474,8 @@ static int pcl818_ao_insn_write(struct comedi_device * dev, struct comedi_subdev
 
    only one sample per call is supported
 */
-static int pcl818_di_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pcl818_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -492,8 +492,8 @@ static int pcl818_di_insn_bits(struct comedi_device * dev, struct comedi_subdevi
 
    only one sample per call is supported
 */
-static int pcl818_do_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pcl818_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -876,8 +876,8 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 ==============================================================================
    ANALOG INPUT MODE 1 or 3 DMA , 818 cards
 */
-static void pcl818_ai_mode13dma_int(int mode, struct comedi_device * dev,
-	struct comedi_subdevice * s)
+static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
+	struct comedi_subdevice *s)
 {
 	unsigned int flags;
 	unsigned int bytes;
@@ -917,8 +917,8 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device * dev,
 ==============================================================================
    ANALOG INPUT MODE 1 or 3 DMA rtc, 818 cards
 */
-static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device * dev,
-	struct comedi_subdevice * s)
+static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device *dev,
+	struct comedi_subdevice *s)
 {
 	unsigned int flags;
 	short *pole;
@@ -958,8 +958,8 @@ static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device * dev,
 ==============================================================================
    ANALOG INPUT MODE 1 or 3, 818 cards
 */
-static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
-	struct comedi_subdevice * s)
+static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
+	struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int divisor1, divisor2;
@@ -1075,8 +1075,8 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
    ANALOG OUTPUT MODE 1 or 3, 818 cards
 */
 #ifdef PCL818_MODE13_AO
-static int pcl818_ao_mode13(int mode, struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_trig * it)
+static int pcl818_ao_mode13(int mode, struct comedi_device *dev, struct comedi_subdevice *s,
+	comedi_trig *it)
 {
 	int divisor1, divisor2;
 
@@ -1128,8 +1128,8 @@ static int pcl818_ao_mode13(int mode, struct comedi_device * dev, struct comedi_
 ==============================================================================
    ANALOG OUTPUT MODE 1, 818 cards
 */
-static int pcl818_ao_mode1(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_trig * it)
+static int pcl818_ao_mode1(struct comedi_device *dev, struct comedi_subdevice *s,
+	comedi_trig *it)
 {
 	return pcl818_ao_mode13(1, dev, s, it);
 }
@@ -1138,8 +1138,8 @@ static int pcl818_ao_mode1(struct comedi_device * dev, struct comedi_subdevice *
 ==============================================================================
    ANALOG OUTPUT MODE 3, 818 cards
 */
-static int pcl818_ao_mode3(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_trig * it)
+static int pcl818_ao_mode3(struct comedi_device *dev, struct comedi_subdevice *s,
+	comedi_trig *it)
 {
 	return pcl818_ao_mode13(3, dev, s, it);
 }
@@ -1150,7 +1150,7 @@ static int pcl818_ao_mode3(struct comedi_device * dev, struct comedi_subdevice *
 ==============================================================================
  Start/stop pacer onboard pacer
 */
-static void start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
+static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
 	unsigned int divisor2)
 {
 	outb(0xb4, dev->iobase + PCL818_CTRCTL);
@@ -1170,7 +1170,7 @@ static void start_pacer(struct comedi_device * dev, int mode, unsigned int divis
  Check if channel list from user is builded correctly
  If it's ok, then program scan/gain logic
 */
-static int check_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
+static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int *chanlist, unsigned int n_chan)
 {
 	unsigned int chansegment[16];
@@ -1230,7 +1230,7 @@ static int check_channel_list(struct comedi_device * dev, struct comedi_subdevic
 	return seglen;
 }
 
-static void setup_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
+static void setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen)
 {
 	int i;
@@ -1267,8 +1267,8 @@ static int check_single_ended(unsigned int port)
 /*
 ==============================================================================
 */
-static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
@@ -1412,7 +1412,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
@@ -1451,7 +1451,7 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 ==============================================================================
  cancel any mode 1-4 AI
 */
-static int pcl818_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pcl818_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	if (devpriv->irq_blocked > 0) {
 		rt_printk("pcl818_ai_cancel()\n");
@@ -1535,7 +1535,7 @@ static int pcl818_check(unsigned long iobase)
 ==============================================================================
  reset whole PCL-818 cards
 */
-static void pcl818_reset(struct comedi_device * dev)
+static void pcl818_reset(struct comedi_device *dev)
 {
 	if (devpriv->usefifo) {	/*  FIFO shutdown */
 		outb(0, dev->iobase + PCL818_FI_INTCLR);
@@ -1656,7 +1656,7 @@ static int rtc_setfreq_irq(int freq)
 ==============================================================================
   Free any resources that we have claimed
 */
-static void free_resources(struct comedi_device * dev)
+static void free_resources(struct comedi_device *dev)
 {
 	/* rt_printk("free_resource()\n"); */
 	if (dev->private) {
@@ -1694,7 +1694,7 @@ static void free_resources(struct comedi_device * dev)
    Initialization
 
 */
-static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	int ret;
 	unsigned long iobase;
@@ -1996,7 +1996,7 @@ static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * i
 ==============================================================================
   Removes device
  */
-static int pcl818_detach(struct comedi_device * dev)
+static int pcl818_detach(struct comedi_device *dev)
 {
 	/*   rt_printk("comedi%d: pcl818: remove\n", dev->minor); */
 	free_resources(dev);

commit e21de1a8e592898fb0426c40b11e19acc4b16fdf
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Apr 14 10:39:53 2009 -0400

    Staging: comedi: pcl818: Tidy up AI command after channel dropout or similar error.
    
    It was causing subsequent commands to fail with -EBUSY.
    
    From: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 29cc5a5151a6..495f802c39ac 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -820,6 +820,27 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 	}
 	/* rt_printk("I\n"); */
 
+	if (devpriv->irq_blocked && devpriv->irq_was_now_closed) {
+		if ((devpriv->neverending_ai || (!devpriv->neverending_ai &&
+						devpriv->ai_act_scan > 0)) &&
+				(devpriv->ai_mode == INT_TYPE_AI1_DMA ||
+				 devpriv->ai_mode == INT_TYPE_AI3_DMA)) {
+			/* The cleanup from ai_cancel() has been delayed
+			   until now because the card doesn't seem to like
+			   being reprogrammed while a DMA transfer is in
+			   progress.
+			 */
+			struct comedi_subdevice *s = dev->subdevices + 0;
+			devpriv->ai_act_scan = 0;
+			devpriv->neverending_ai = 0;
+			pcl818_ai_cancel(dev, s);
+		}
+
+		outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
+
+		return IRQ_HANDLED;
+	}
+
 	switch (devpriv->ai_mode) {
 	case INT_TYPE_AI1_DMA:
 	case INT_TYPE_AI3_DMA:
@@ -843,25 +864,6 @@ static irqreturn_t interrupt_pcl818(int irq, void *d)
 
 	if ((!dev->irq) || (!devpriv->irq_free) || (!devpriv->irq_blocked)
 		|| (!devpriv->ai_mode)) {
-		if (devpriv->irq_was_now_closed) {
-			if (devpriv->neverending_ai &&
-				(devpriv->ai_mode == INT_TYPE_AI1_DMA
-					|| devpriv->ai_mode ==
-					INT_TYPE_AI3_DMA)) {
-				/* we had neverending ai but ai_cancel() has been called
-				   the cleanup from ai_cancel() has been delayed until know
-				   because the card doesn't seem to like being reprogrammed
-				   while a DMA transfer is in progress
-				 */
-				struct comedi_subdevice *s = dev->subdevices + 0;
-				devpriv->ai_mode = devpriv->irq_was_now_closed;
-				devpriv->irq_was_now_closed = 0;
-				devpriv->neverending_ai = 0;
-				pcl818_ai_cancel(dev, s);
-			}
-			devpriv->irq_was_now_closed = 0;
-			return IRQ_HANDLED;
-		}
 		comedi_error(dev, "bad IRQ!");
 		return IRQ_NONE;
 	}
@@ -1453,10 +1455,9 @@ static int pcl818_ai_cancel(struct comedi_device * dev, struct comedi_subdevice
 {
 	if (devpriv->irq_blocked > 0) {
 		rt_printk("pcl818_ai_cancel()\n");
-		devpriv->irq_was_now_closed = devpriv->ai_mode;
-		devpriv->ai_mode = 0;
+		devpriv->irq_was_now_closed = 1;
 
-		switch (devpriv->irq_was_now_closed) {
+		switch (devpriv->ai_mode) {
 #ifdef unused
 		case INT_TYPE_AI1_DMA_RTC:
 		case INT_TYPE_AI3_DMA_RTC:
@@ -1465,7 +1466,9 @@ static int pcl818_ai_cancel(struct comedi_device * dev, struct comedi_subdevice
 #endif
 		case INT_TYPE_AI1_DMA:
 		case INT_TYPE_AI3_DMA:
-			if (devpriv->neverending_ai) {
+			if (devpriv->neverending_ai ||
+					(!devpriv->neverending_ai &&
+					 devpriv->ai_act_scan > 0)) {
 				/* wait for running dma transfer to end, do cleanup in interrupt */
 				goto end;
 			}
@@ -1494,6 +1497,8 @@ static int pcl818_ai_cancel(struct comedi_device * dev, struct comedi_subdevice
 			devpriv->irq_blocked = 0;
 			devpriv->last_int_sub = s;
 			devpriv->neverending_ai = 0;
+			devpriv->ai_mode = 0;
+			devpriv->irq_was_now_closed = 0;
 			break;
 		}
 	}

commit a71f18d2a1ca1b3a0e1e46f3c7259829d4d33f47
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Apr 14 10:33:42 2009 -0400

    Staging: comedi: pcl818: Fix option handling for FIFO mode (hopefully!).
    
    Signed-off-by: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 4ab4154242ef..29cc5a5151a6 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1025,26 +1025,32 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
 		}
 #endif
 		break;
-	case 0:		/*  IRQ */
-		/*  rt_printk("IRQ\n"); */
-		if (mode == 1) {
-			devpriv->ai_mode = INT_TYPE_AI1_INT;
-			outb(0x83 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Pacer+IRQ */
-		} else {
-			devpriv->ai_mode = INT_TYPE_AI3_INT;
-			outb(0x82 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Ext trig+IRQ */
-		};
-		break;
-	case -1:		/*  FIFO */
-		outb(1, dev->iobase + PCL818_FI_ENABLE);	/*  enable FIFO */
-		if (mode == 1) {
-			devpriv->ai_mode = INT_TYPE_AI1_FIFO;
-			outb(0x03, dev->iobase + PCL818_CONTROL);	/* Pacer */
+	case 0:
+		if (!devpriv->usefifo) {
+			/* IRQ */
+			/* rt_printk("IRQ\n"); */
+			if (mode == 1) {
+				devpriv->ai_mode = INT_TYPE_AI1_INT;
+				/* Pacer+IRQ */
+				outb(0x83 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);
+			} else {
+				devpriv->ai_mode = INT_TYPE_AI3_INT;
+				/* Ext trig+IRQ */
+				outb(0x82 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);
+			}
 		} else {
-			devpriv->ai_mode = INT_TYPE_AI3_FIFO;
-			outb(0x02, dev->iobase + PCL818_CONTROL);
-		};		/* Ext trig */
-		break;
+			/* FIFO */
+			/* enable FIFO */
+			outb(1, dev->iobase + PCL818_FI_ENABLE);
+			if (mode == 1) {
+				devpriv->ai_mode = INT_TYPE_AI1_FIFO;
+				/* Pacer */
+				outb(0x03, dev->iobase + PCL818_CONTROL);
+			} else {
+				devpriv->ai_mode = INT_TYPE_AI3_FIFO;
+				outb(0x02, dev->iobase + PCL818_CONTROL);
+			}
+		}
 	}
 
 	start_pacer(dev, mode, divisor1, divisor2);
@@ -1687,7 +1693,8 @@ static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * i
 {
 	int ret;
 	unsigned long iobase;
-	unsigned int irq, dma;
+	unsigned int irq;
+	int dma;
 	unsigned long pages;
 	struct comedi_subdevice *s;
 

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index b65a44bfdde9..4ab4154242ef 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -810,7 +810,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 ==============================================================================
     INT procedure
 */
-static irqreturn_t interrupt_pcl818(int irq, void *d PT_REGS_ARG)
+static irqreturn_t interrupt_pcl818(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 

commit 0109253dee3d211619876d3345ecc4c312d1b153
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:29:45 2009 -0400

    Staging: comedi: remove C99 comments in pcl818.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 43a9d56c6a43..b65a44bfdde9 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -107,9 +107,9 @@ A word or two about DMA. Driver support DMA operations at two ways:
 
 #include "8253.h"
 
-// #define PCL818_MODE13_AO 1
+/* #define PCL818_MODE13_AO 1 */
 
-// boards constants
+/* boards constants */
 
 #define boardPCL818L 0
 #define boardPCL818H 1
@@ -118,60 +118,60 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define boardPCL818 4
 #define boardPCL718 5
 
-// IO space len
+/* IO space len */
 #define PCLx1x_RANGE 16
-// IO space len if we use FIFO
+/* IO space len if we use FIFO */
 #define PCLx1xFIFO_RANGE 32
 
-// W: clear INT request
+/* W: clear INT request */
 #define PCL818_CLRINT 8
-// R: return status byte
+/* R: return status byte */
 #define PCL818_STATUS 8
-// R: A/D high byte W: A/D range control
+/* R: A/D high byte W: A/D range control */
 #define PCL818_RANGE 1
-// R: next mux scan channel W: mux scan channel & range control pointer
+/* R: next mux scan channel W: mux scan channel & range control pointer */
 #define PCL818_MUX 2
-// R/W: operation control register
+/* R/W: operation control register */
 #define PCL818_CONTROL 9
-// W: counter enable
+/* W: counter enable */
 #define PCL818_CNTENABLE 10
 
-// R: low byte of A/D W: soft A/D trigger
+/* R: low byte of A/D W: soft A/D trigger */
 #define PCL818_AD_LO 0
-// R: high byte of A/D W: A/D range control
+/* R: high byte of A/D W: A/D range control */
 #define PCL818_AD_HI 1
-// W: D/A low&high byte
+/* W: D/A low&high byte */
 #define PCL818_DA_LO 4
 #define PCL818_DA_HI 5
-// R: low&high byte of DI
+/* R: low&high byte of DI */
 #define PCL818_DI_LO 3
 #define PCL818_DI_HI 11
-// W: low&high byte of DO
+/* W: low&high byte of DO */
 #define PCL818_DO_LO 3
 #define PCL818_DO_HI 11
-// W: PCL718 second D/A
+/* W: PCL718 second D/A */
 #define PCL718_DA2_LO 6
 #define PCL718_DA2_HI 7
-// counters
+/* counters */
 #define PCL818_CTR0 12
 #define PCL818_CTR1 13
 #define PCL818_CTR2 14
-// W: counter control
+/* W: counter control */
 #define PCL818_CTRCTL 15
 
-// W: fifo enable/disable
+/* W: fifo enable/disable */
 #define PCL818_FI_ENABLE 6
-// W: fifo interrupt clear
+/* W: fifo interrupt clear */
 #define PCL818_FI_INTCLR 20
-// W: fifo interrupt clear
+/* W: fifo interrupt clear */
 #define PCL818_FI_FLUSH 25
-// R: fifo status
+/* R: fifo status */
 #define PCL818_FI_STATUS 25
-// R: one record from FIFO
+/* R: one record from FIFO */
 #define PCL818_FI_DATALO 23
 #define PCL818_FI_DATAHI 23
 
-// type of interrupt handler
+/* type of interrupt handler */
 #define INT_TYPE_AI1_INT 1
 #define INT_TYPE_AI1_DMA 2
 #define INT_TYPE_AI1_FIFO 3
@@ -184,7 +184,7 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #endif
 
 #ifdef unused
-// RTC stuff...
+/* RTC stuff... */
 #define INT_TYPE_AI1_DMA_RTC 9
 #define INT_TYPE_AI3_DMA_RTC 10
 
@@ -254,22 +254,22 @@ static int RTC_timer_lock = 0;	/* RTC int lock */
 
 struct pcl818_board {
 
-	const char *name;	// driver name
-	int n_ranges;		// len of range list
-	int n_aichan_se;	// num of A/D chans in single ended  mode
-	int n_aichan_diff;	// num of A/D chans in diferencial mode
-	unsigned int ns_min;	// minimal alllowed delay between samples (in ns)
-	int n_aochan;		// num of D/A chans
-	int n_dichan;		// num of DI chans
-	int n_dochan;		// num of DO chans
-	const struct comedi_lrange *ai_range_type;	// default A/D rangelist
-	const struct comedi_lrange *ao_range_type;	// default D/A rangelist
-	unsigned int io_range;	// len of IO space
-	unsigned int IRQbits;	// allowed interrupts
-	unsigned int DMAbits;	// allowed DMA chans
-	int ai_maxdata;		// maxdata for A/D
-	int ao_maxdata;		// maxdata for D/A
-	unsigned char fifo;	// 1=board has FIFO
+	const char *name;	/*  driver name */
+	int n_ranges;		/*  len of range list */
+	int n_aichan_se;	/*  num of A/D chans in single ended  mode */
+	int n_aichan_diff;	/*  num of A/D chans in diferencial mode */
+	unsigned int ns_min;	/*  minimal alllowed delay between samples (in ns) */
+	int n_aochan;		/*  num of D/A chans */
+	int n_dichan;		/*  num of DI chans */
+	int n_dochan;		/*  num of DO chans */
+	const struct comedi_lrange *ai_range_type;	/*  default A/D rangelist */
+	const struct comedi_lrange *ao_range_type;	/*  default D/A rangelist */
+	unsigned int io_range;	/*  len of IO space */
+	unsigned int IRQbits;	/*  allowed interrupts */
+	unsigned int DMAbits;	/*  allowed DMA chans */
+	int ai_maxdata;		/*  maxdata for A/D */
+	int ao_maxdata;		/*  maxdata for D/A */
+	unsigned char fifo;	/*  1=board has FIFO */
 	int is_818;
 };
 
@@ -315,54 +315,54 @@ COMEDI_INITCLEANUP(driver_pcl818);
 
 struct pcl818_private {
 
-	unsigned int dma;	// used DMA, 0=don't use DMA
-	int dma_rtc;		// 1=RTC used with DMA, 0=no RTC alloc
+	unsigned int dma;	/*  used DMA, 0=don't use DMA */
+	int dma_rtc;		/*  1=RTC used with DMA, 0=no RTC alloc */
 	unsigned int io_range;
 #ifdef unused
-	unsigned long rtc_iobase;	// RTC port region
+	unsigned long rtc_iobase;	/*  RTC port region */
 	unsigned int rtc_iosize;
 	unsigned int rtc_irq;
-	struct timer_list rtc_irq_timer;	// timer for RTC sanity check
-	unsigned long rtc_freq;	// RTC int freq
-	int rtc_irq_blocked;	// 1=we now do AI with DMA&RTC
+	struct timer_list rtc_irq_timer;	/*  timer for RTC sanity check */
+	unsigned long rtc_freq;	/*  RTC int freq */
+	int rtc_irq_blocked;	/*  1=we now do AI with DMA&RTC */
 #endif
-	unsigned long dmabuf[2];	// pointers to begin of DMA buffers
-	unsigned int dmapages[2];	// len of DMA buffers in PAGE_SIZEs
-	unsigned int hwdmaptr[2];	// hardware address of DMA buffers
-	unsigned int hwdmasize[2];	// len of DMA buffers in Bytes
-	unsigned int dmasamplsize;	// size in samples hwdmasize[0]/2
-	unsigned int last_top_dma;	// DMA pointer in last RTC int
-	int next_dma_buf;	// which DMA buffer will be used next round
-	long dma_runs_to_end;	// how many we must permorm DMA transfer to end of record
-	unsigned long last_dma_run;	// how many bytes we must transfer on last DMA page
-	unsigned char neverending_ai;	// if=1, then we do neverending record (you must use cancel())
-	unsigned int ns_min;	// manimal alllowed delay between samples (in us) for actual card
-	int i8253_osc_base;	// 1/frequency of on board oscilator in ns
-	int irq_free;		// 1=have allocated IRQ
-	int irq_blocked;	// 1=IRQ now uses any subdev
-	int irq_was_now_closed;	// when IRQ finish, there's stored int818_mode for last interrupt
-	int ai_mode;		// who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma
-	struct comedi_subdevice *last_int_sub;	// ptr to subdevice which now finish
-	int ai_act_scan;	// how many scans we finished
-	int ai_act_chan;	// actual position in actual scan
-	unsigned int act_chanlist[16];	// MUX setting for actual AI operations
-	unsigned int act_chanlist_len;	// how long is actual MUX list
-	unsigned int act_chanlist_pos;	// actual position in MUX list
-	unsigned int ai_scans;	// len of scanlist
-	unsigned int ai_n_chan;	// how many channels is measured
-	unsigned int *ai_chanlist;	// actaul chanlist
-	unsigned int ai_flags;	// flaglist
-	unsigned int ai_data_len;	// len of data buffer
-	short *ai_data;	// data buffer
-	unsigned int ai_timer1;	// timers
+	unsigned long dmabuf[2];	/*  pointers to begin of DMA buffers */
+	unsigned int dmapages[2];	/*  len of DMA buffers in PAGE_SIZEs */
+	unsigned int hwdmaptr[2];	/*  hardware address of DMA buffers */
+	unsigned int hwdmasize[2];	/*  len of DMA buffers in Bytes */
+	unsigned int dmasamplsize;	/*  size in samples hwdmasize[0]/2 */
+	unsigned int last_top_dma;	/*  DMA pointer in last RTC int */
+	int next_dma_buf;	/*  which DMA buffer will be used next round */
+	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
+	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
+	unsigned char neverending_ai;	/*  if=1, then we do neverending record (you must use cancel()) */
+	unsigned int ns_min;	/*  manimal alllowed delay between samples (in us) for actual card */
+	int i8253_osc_base;	/*  1/frequency of on board oscilator in ns */
+	int irq_free;		/*  1=have allocated IRQ */
+	int irq_blocked;	/*  1=IRQ now uses any subdev */
+	int irq_was_now_closed;	/*  when IRQ finish, there's stored int818_mode for last interrupt */
+	int ai_mode;		/*  who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma */
+	struct comedi_subdevice *last_int_sub;	/*  ptr to subdevice which now finish */
+	int ai_act_scan;	/*  how many scans we finished */
+	int ai_act_chan;	/*  actual position in actual scan */
+	unsigned int act_chanlist[16];	/*  MUX setting for actual AI operations */
+	unsigned int act_chanlist_len;	/*  how long is actual MUX list */
+	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
+	unsigned int ai_scans;	/*  len of scanlist */
+	unsigned int ai_n_chan;	/*  how many channels is measured */
+	unsigned int *ai_chanlist;	/*  actaul chanlist */
+	unsigned int ai_flags;	/*  flaglist */
+	unsigned int ai_data_len;	/*  len of data buffer */
+	short *ai_data;	/*  data buffer */
+	unsigned int ai_timer1;	/*  timers */
 	unsigned int ai_timer2;
-	struct comedi_subdevice *sub_ai;	// ptr to AI subdevice
-	unsigned char usefifo;	// 1=use fifo
+	struct comedi_subdevice *sub_ai;	/*  ptr to AI subdevice */
+	unsigned char usefifo;	/*  1=use fifo */
 	unsigned int ao_readback[2];
 };
 
 
-static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	// used for gain list programming
+static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	/*  used for gain list programming */
 	0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
 };
 
@@ -535,10 +535,10 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 
       conv_finish:
 	low = inb(dev->iobase + PCL818_AD_LO);
-	comedi_buf_put(s->async, ((inb(dev->iobase + PCL818_AD_HI) << 4) | (low >> 4)));	// get one sample
+	comedi_buf_put(s->async, ((inb(dev->iobase + PCL818_AD_HI) << 4) | (low >> 4)));	/*  get one sample */
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
-	if ((low & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	// dropout!
+	if ((low & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
 		rt_printk
 			("comedi: A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
 			(low & 0xf),
@@ -549,7 +549,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 	if (s->async->cur_chan == 0) {
-		// rt_printk("E");
+		/*  rt_printk("E"); */
 		devpriv->ai_act_scan--;
 	}
 
@@ -577,7 +577,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 
 	disable_dma(devpriv->dma);
 	devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
-	if ((devpriv->dma_runs_to_end) > -1 || devpriv->neverending_ai) {	// switch dma bufs
+	if ((devpriv->dma_runs_to_end) > -1 || devpriv->neverending_ai) {	/*  switch dma bufs */
 		set_dma_mode(devpriv->dma, DMA_MODE_READ);
 		flags = claim_dma_lock();
 		set_dma_addr(devpriv->dma,
@@ -601,7 +601,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 	bufptr = 0;
 
 	for (i = 0; i < len; i++) {
-		if ((ptr[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	// dropout!
+		if ((ptr[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
 			rt_printk
 				("comedi: A/D mode1/3 DMA - channel dropout %d(card)!=%d(chanlist) at %d !\n",
 				(ptr[bufptr] & 0xf),
@@ -614,7 +614,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 			return IRQ_HANDLED;
 		}
 
-		comedi_buf_put(s->async, ptr[bufptr++] >> 4);	// get one sample
+		comedi_buf_put(s->async, ptr[bufptr++] >> 4);	/*  get one sample */
 
 		devpriv->act_chanlist_pos++;
 		if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len) {
@@ -627,7 +627,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 				pcl818_ai_cancel(dev, s);
 				s->async->events |= COMEDI_CB_EOA;
 				comedi_event(dev, s);
-				// printk("done int ai13 dma\n");
+				/*  printk("done int ai13 dma\n"); */
 				return IRQ_HANDLED;
 			}
 	}
@@ -651,7 +651,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 	long ofs_dats;
 	short *dmabuf = (short *) devpriv->dmabuf[0];
 
-	//outb(2,0x378);
+	/* outb(2,0x378); */
 	switch (devpriv->ai_mode) {
 	case INT_TYPE_AI1_DMA_RTC:
 	case INT_TYPE_AI3_DMA_RTC:
@@ -668,31 +668,31 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 
 		if (top1 != top2)
 			return IRQ_HANDLED;
-		top1 = devpriv->hwdmasize[0] - top1;	// where is now DMA in buffer
+		top1 = devpriv->hwdmasize[0] - top1;	/*  where is now DMA in buffer */
 		top1 >>= 1;
-		ofs_dats = top1 - devpriv->last_top_dma;	// new samples from last call
+		ofs_dats = top1 - devpriv->last_top_dma;	/*  new samples from last call */
 		if (ofs_dats < 0)
 			ofs_dats = (devpriv->dmasamplsize) + ofs_dats;
 		if (!ofs_dats)
-			return IRQ_HANDLED;	// exit=no new samples from last call
-		// obsluz data
+			return IRQ_HANDLED;	/*  exit=no new samples from last call */
+		/*  obsluz data */
 		i = devpriv->last_top_dma - 1;
 		i &= (devpriv->dmasamplsize - 1);
 
-		if (dmabuf[i] != MAGIC_DMA_WORD) {	// DMA overflow!
+		if (dmabuf[i] != MAGIC_DMA_WORD) {	/*  DMA overflow! */
 			comedi_error(dev, "A/D mode1/3 DMA buffer overflow!");
-			//rt_printk("I %d dmabuf[i] %d %d\n",i,dmabuf[i],devpriv->dmasamplsize);
+			/* rt_printk("I %d dmabuf[i] %d %d\n",i,dmabuf[i],devpriv->dmasamplsize); */
 			pcl818_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			comedi_event(dev, s);
 			return IRQ_HANDLED;
 		}
-		//rt_printk("r %ld ",ofs_dats);
+		/* rt_printk("r %ld ",ofs_dats); */
 
 		bufptr = devpriv->last_top_dma;
 
 		for (i = 0; i < ofs_dats; i++) {
-			if ((dmabuf[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	// dropout!
+			if ((dmabuf[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
 				rt_printk
 					("comedi: A/D mode1/3 DMA - channel dropout %d!=%d !\n",
 					(dmabuf[bufptr] & 0xf),
@@ -705,7 +705,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 				return IRQ_HANDLED;
 			}
 
-			comedi_buf_put(s->async, dmabuf[bufptr++] >> 4);	// get one sample
+			comedi_buf_put(s->async, dmabuf[bufptr++] >> 4);	/*  get one sample */
 			bufptr &= (devpriv->dmasamplsize - 1);
 
 			if (s->async->cur_chan == 0) {
@@ -717,7 +717,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 					pcl818_ai_cancel(dev, s);
 					s->async->events |= COMEDI_CB_EOA;
 					comedi_event(dev, s);
-					//printk("done int ai13 dma\n");
+					/* printk("done int ai13 dma\n"); */
 					return IRQ_HANDLED;
 				}
 		}
@@ -727,11 +727,11 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 		bufptr &= (devpriv->dmasamplsize - 1);
 		dmabuf[bufptr] = MAGIC_DMA_WORD;
 		comedi_event(dev, s);
-		//outb(0,0x378);
+		/* outb(0,0x378); */
 		return IRQ_HANDLED;
 	}
 
-	//outb(0,0x378);
+	/* outb(0,0x378); */
 	return IRQ_HANDLED;
 }
 #endif
@@ -746,7 +746,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 	struct comedi_subdevice *s = dev->subdevices + 0;
 	int i, len, lo;
 
-	outb(0, dev->iobase + PCL818_FI_INTCLR);	// clear fifo int request
+	outb(0, dev->iobase + PCL818_FI_INTCLR);	/*  clear fifo int request */
 
 	lo = inb(dev->iobase + PCL818_FI_STATUS);
 
@@ -774,7 +774,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 
 	for (i = 0; i < len; i++) {
 		lo = inb(dev->iobase + PCL818_FI_DATALO);
-		if ((lo & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	// dropout!
+		if ((lo & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
 			rt_printk
 				("comedi: A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
 				(lo & 0xf),
@@ -786,7 +786,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 			return IRQ_HANDLED;
 		}
 
-		comedi_buf_put(s->async, (lo >> 4) | (inb(dev->iobase + PCL818_FI_DATAHI) << 4));	// get one sample
+		comedi_buf_put(s->async, (lo >> 4) | (inb(dev->iobase + PCL818_FI_DATAHI) << 4));	/*  get one sample */
 
 		if (s->async->cur_chan == 0) {
 			devpriv->ai_act_scan--;
@@ -818,7 +818,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d PT_REGS_ARG)
 		comedi_error(dev, "premature interrupt");
 		return IRQ_HANDLED;
 	}
-	//rt_printk("I\n");
+	/* rt_printk("I\n"); */
 
 	switch (devpriv->ai_mode) {
 	case INT_TYPE_AI1_DMA:
@@ -881,12 +881,12 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device * dev,
 	unsigned int bytes;
 
 	rt_printk("mode13dma_int, mode: %d\n", mode);
-	disable_dma(devpriv->dma);	// disable dma
+	disable_dma(devpriv->dma);	/*  disable dma */
 	bytes = devpriv->hwdmasize[0];
 	if (!devpriv->neverending_ai) {
-		bytes = devpriv->ai_n_chan * devpriv->ai_scans * sizeof(short);	// how many
-		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize[0];	// how many DMA pages we must fiil
-		devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];	//on last dma transfer must be moved
+		bytes = devpriv->ai_n_chan * devpriv->ai_scans * sizeof(short);	/*  how many */
+		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize[0];	/*  how many DMA pages we must fiil */
+		devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];	/* on last dma transfer must be moved */
 		devpriv->dma_runs_to_end--;
 		if (devpriv->dma_runs_to_end >= 0)
 			bytes = devpriv->hwdmasize[0];
@@ -928,7 +928,7 @@ static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device * dev,
 	set_dma_count(devpriv->dma, devpriv->hwdmasize[0]);
 	release_dma_lock(flags);
 	enable_dma(devpriv->dma);
-	devpriv->last_top_dma = 0;	//devpriv->hwdmasize[0];
+	devpriv->last_top_dma = 0;	/* devpriv->hwdmasize[0]; */
 	pole = (short *) devpriv->dmabuf[0];
 	devpriv->dmasamplsize = devpriv->hwdmasize[0] / 2;
 	pole[devpriv->dmasamplsize - 1] = MAGIC_DMA_WORD;
@@ -972,7 +972,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
 	if (devpriv->irq_blocked)
 		return -EBUSY;
 
-	start_pacer(dev, -1, 0, 0);	// stop pacer
+	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	seglen = check_channel_list(dev, s, devpriv->ai_chanlist,
 		devpriv->ai_n_chan);
@@ -992,7 +992,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
 	devpriv->dma_runs_to_end = 0;
 
 	if ((devpriv->ai_scans == 0) || (devpriv->ai_scans == -1))
-		devpriv->neverending_ai = 1;	//well, user want neverending
+		devpriv->neverending_ai = 1;	/* well, user want neverending */
 
 	if (mode == 1) {
 		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
@@ -1010,7 +1010,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
 	outb(0, dev->iobase + PCL818_CNTENABLE);	/* enable pacer */
 
 	switch (devpriv->dma) {
-	case 1:		// DMA
+	case 1:		/*  DMA */
 	case 3:
 		if (devpriv->dma_rtc == 0) {
 			pcl818_ai_mode13dma_int(mode, dev, s);
@@ -1025,8 +1025,8 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
 		}
 #endif
 		break;
-	case 0:		// IRQ
-		// rt_printk("IRQ\n");
+	case 0:		/*  IRQ */
+		/*  rt_printk("IRQ\n"); */
 		if (mode == 1) {
 			devpriv->ai_mode = INT_TYPE_AI1_INT;
 			outb(0x83 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Pacer+IRQ */
@@ -1035,8 +1035,8 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
 			outb(0x82 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Ext trig+IRQ */
 		};
 		break;
-	case -1:		// FIFO
-		outb(1, dev->iobase + PCL818_FI_ENABLE);	// enable FIFO
+	case -1:		/*  FIFO */
+		outb(1, dev->iobase + PCL818_FI_ENABLE);	/*  enable FIFO */
 		if (mode == 1) {
 			devpriv->ai_mode = INT_TYPE_AI1_FIFO;
 			outb(0x03, dev->iobase + PCL818_CONTROL);	/* Pacer */
@@ -1080,7 +1080,7 @@ static int pcl818_ao_mode13(int mode, struct comedi_device * dev, struct comedi_
 	if (devpriv->irq_blocked)
 		return -EBUSY;
 
-	start_pacer(dev, -1, 0, 0);	// stop pacer
+	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	devpriv->int13_act_scan = it->n;
 	devpriv->int13_act_chan = 0;
@@ -1175,30 +1175,34 @@ static int check_channel_list(struct comedi_device * dev, struct comedi_subdevic
 	}
 
 	if (n_chan > 1) {
-		// first channel is everytime ok
+		/*  first channel is everytime ok */
 		chansegment[0] = chanlist[0];
-		// build part of chanlist
+		/*  build part of chanlist */
 		for (i = 1, seglen = 1; i < n_chan; i++, seglen++) {
-			// rt_printk("%d. %d %d\n",i,CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i]));
-			// we detect loop, this must by finish
+
+			/* rt_printk("%d. %d * %d\n",i,
+			 * CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i]));*/
+
+			/* we detect loop, this must by finish */
+
 			if (chanlist[0] == chanlist[i])
 				break;
 			nowmustbechan =
 				(CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
-			if (nowmustbechan != CR_CHAN(chanlist[i])) {	// channel list isn't continous :-(
+			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continous :-( */
 				rt_printk
 					("comedi%d: pcl818: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
 					dev->minor, i, CR_CHAN(chanlist[i]),
 					nowmustbechan, CR_CHAN(chanlist[0]));
 				return 0;
 			}
-			// well, this is next correct channel in list
+			/*  well, this is next correct channel in list */
 			chansegment[i] = chanlist[i];
 		}
 
-		// check whole chanlist
+		/*  check whole chanlist */
 		for (i = 0, segpos = 0; i < n_chan; i++) {
-			//rt_printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i]));
+			/* rt_printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i])); */
 			if (chanlist[i] != chansegment[i % seglen]) {
 				rt_printk
 					("comedi%d: pcl818: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
@@ -1208,7 +1212,7 @@ static int check_channel_list(struct comedi_device * dev, struct comedi_subdevic
 					CR_CHAN(chanlist[i % seglen]),
 					CR_RANGE(chanlist[i % seglen]),
 					CR_AREF(chansegment[i % seglen]));
-				return 0;	// chan/gain list is strange
+				return 0;	/*  chan/gain list is strange */
 			}
 		}
 	} else {
@@ -1226,7 +1230,7 @@ static void setup_channel_list(struct comedi_device * dev, struct comedi_subdevi
 	devpriv->act_chanlist_len = seglen;
 	devpriv->act_chanlist_pos = 0;
 
-	for (i = 0; i < seglen; i++) {	// store range list to card
+	for (i = 0; i < seglen; i++) {	/*  store range list to card */
 		devpriv->act_chanlist[i] = CR_CHAN(chanlist[i]);
 		outb(muxonechan[CR_CHAN(chanlist[i])], dev->iobase + PCL818_MUX);	/* select channel */
 		outb(CR_RANGE(chanlist[i]), dev->iobase + PCL818_RANGE);	/* select gain */
@@ -1391,7 +1395,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	if (cmd->chanlist) {
 		if (!check_channel_list(dev, s, cmd->chanlist,
 				cmd->chanlist_len))
-			return 5;	// incorrect channels list
+			return 5;	/*  incorrect channels list */
 	}
 
 	return 0;
@@ -1420,14 +1424,14 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		devpriv->ai_scans = 0;
 	}
 
-	if (cmd->scan_begin_src == TRIG_FOLLOW) {	// mode 1, 3
-		if (cmd->convert_src == TRIG_TIMER) {	// mode 1
+	if (cmd->scan_begin_src == TRIG_FOLLOW) {	/*  mode 1, 3 */
+		if (cmd->convert_src == TRIG_TIMER) {	/*  mode 1 */
 			devpriv->ai_timer1 = cmd->convert_arg;
 			retval = pcl818_ai_cmd_mode(1, dev, s);
 			rt_printk("pcl818_ai_cmd() end\n");
 			return retval;
 		}
-		if (cmd->convert_src == TRIG_EXT) {	// mode 3
+		if (cmd->convert_src == TRIG_EXT) {	/*  mode 3 */
 			return pcl818_ai_cmd_mode(3, dev, s);
 		}
 	}
@@ -1450,7 +1454,7 @@ static int pcl818_ai_cancel(struct comedi_device * dev, struct comedi_subdevice
 #ifdef unused
 		case INT_TYPE_AI1_DMA_RTC:
 		case INT_TYPE_AI3_DMA_RTC:
-			set_rtc_irq_bit(0);	// stop RTC
+			set_rtc_irq_bit(0);	/*  stop RTC */
 			del_timer(&devpriv->rtc_irq_timer);
 #endif
 		case INT_TYPE_AI1_DMA:
@@ -1476,7 +1480,7 @@ static int pcl818_ai_cancel(struct comedi_device * dev, struct comedi_subdevice
 			inb(dev->iobase + PCL818_AD_HI);
 			outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 			outb(0, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
-			if (devpriv->usefifo) {	// FIFO shutdown
+			if (devpriv->usefifo) {	/*  FIFO shutdown */
 				outb(0, dev->iobase + PCL818_FI_INTCLR);
 				outb(0, dev->iobase + PCL818_FI_FLUSH);
 				outb(0, dev->iobase + PCL818_FI_ENABLE);
@@ -1502,18 +1506,18 @@ static int pcl818_check(unsigned long iobase)
 	outb(0x00, iobase + PCL818_MUX);
 	comedi_udelay(1);
 	if (inb(iobase + PCL818_MUX) != 0x00)
-		return 1;	//there isn't card
+		return 1;	/* there isn't card */
 	outb(0x55, iobase + PCL818_MUX);
 	comedi_udelay(1);
 	if (inb(iobase + PCL818_MUX) != 0x55)
-		return 1;	//there isn't card
+		return 1;	/* there isn't card */
 	outb(0x00, iobase + PCL818_MUX);
 	comedi_udelay(1);
 	outb(0x18, iobase + PCL818_CONTROL);
 	comedi_udelay(1);
 	if (inb(iobase + PCL818_CONTROL) != 0x18)
-		return 1;	//there isn't card
-	return 0;		// ok, card exist
+		return 1;	/* there isn't card */
+	return 0;		/*  ok, card exist */
 }
 
 /*
@@ -1522,15 +1526,15 @@ static int pcl818_check(unsigned long iobase)
 */
 static void pcl818_reset(struct comedi_device * dev)
 {
-	if (devpriv->usefifo) {	// FIFO shutdown
+	if (devpriv->usefifo) {	/*  FIFO shutdown */
 		outb(0, dev->iobase + PCL818_FI_INTCLR);
 		outb(0, dev->iobase + PCL818_FI_FLUSH);
 		outb(0, dev->iobase + PCL818_FI_ENABLE);
 	}
-	outb(0, dev->iobase + PCL818_DA_LO);	// DAC=0V
+	outb(0, dev->iobase + PCL818_DA_LO);	/*  DAC=0V */
 	outb(0, dev->iobase + PCL818_DA_HI);
 	comedi_udelay(1);
-	outb(0, dev->iobase + PCL818_DO_HI);	// DO=$0000
+	outb(0, dev->iobase + PCL818_DO_HI);	/*  DO=$0000 */
 	outb(0, dev->iobase + PCL818_DO_LO);
 	comedi_udelay(1);
 	outb(0, dev->iobase + PCL818_CONTROL);
@@ -1643,7 +1647,7 @@ static int rtc_setfreq_irq(int freq)
 */
 static void free_resources(struct comedi_device * dev)
 {
-	//rt_printk("free_resource()\n");
+	/* rt_printk("free_resource()\n"); */
 	if (dev->private) {
 		pcl818_ai_cancel(dev, devpriv->sub_ai);
 		pcl818_reset(dev);
@@ -1670,7 +1674,7 @@ static void free_resources(struct comedi_device * dev)
 		free_irq(dev->irq, dev);
 	if (dev->iobase)
 		release_region(dev->iobase, devpriv->io_range);
-	//rt_printk("free_resource() end\n");
+	/* rt_printk("free_resource() end\n"); */
 }
 
 /*
@@ -1695,7 +1699,7 @@ static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * i
 	printk("comedi%d: pcl818:  board=%s, ioport=0x%03lx",
 		dev->minor, this_board->name, iobase);
 	devpriv->io_range = this_board->io_range;
-	if ((this_board->fifo) && (it->options[2] == -1)) {	// we've board with FIFO and we want to use FIFO
+	if ((this_board->fifo) && (it->options[2] == -1)) {	/*  we've board with FIFO and we want to use FIFO */
 		devpriv->io_range = PCLx1xFIFO_RANGE;
 		devpriv->usefifo = 1;
 	}
@@ -1750,7 +1754,7 @@ static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * i
 #ifdef unused
 	/* grab RTC for DMA operations */
 	devpriv->dma_rtc = 0;
-	if (it->options[2] > 0) {	// we want to use DMA
+	if (it->options[2] > 0) {	/*  we want to use DMA */
 		if (RTC_lock == 0) {
 			if (!request_region(RTC_PORT(0), RTC_IO_EXTENT,
 					"pcl818 (RTC)"))
@@ -1809,8 +1813,8 @@ static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * i
 		devpriv->dmapages[0] = pages;
 		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
 		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
-		//rt_printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE);
-		if (devpriv->dma_rtc == 0) {	// we must do duble buff :-(
+		/* rt_printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
+		if (devpriv->dma_rtc == 0) {	/*  we must do duble buff :-( */
 			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 			if (!devpriv->dmabuf[1]) {
 				rt_printk
@@ -1858,7 +1862,7 @@ static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * i
 		}
 		if (this_board->is_818) {
 			if ((it->options[4] == 1) || (it->options[4] == 10))
-				s->range_table = &range_pcl818l_h_ai;	// secondary range list jumper selectable
+				s->range_table = &range_pcl818l_h_ai;	/*  secondary range list jumper selectable */
 		} else {
 			switch (it->options[4]) {
 			case 0:
@@ -1982,7 +1986,7 @@ static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * i
  */
 static int pcl818_detach(struct comedi_device * dev)
 {
-	//  rt_printk("comedi%d: pcl818: remove\n", dev->minor);
+	/*   rt_printk("comedi%d: pcl818: remove\n", dev->minor); */
 	free_resources(dev);
 	return 0;
 }

commit 087ea31bdabb0395f83223c153a0557136461a85
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:17:17 2009 -0400

    Staging: comedi: Remove pcl818_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 274741f76158..43a9d56c6a43 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -313,7 +313,8 @@ static struct comedi_driver driver_pcl818 = {
 
 COMEDI_INITCLEANUP(driver_pcl818);
 
-typedef struct {
+struct pcl818_private {
+
 	unsigned int dma;	// used DMA, 0=don't use DMA
 	int dma_rtc;		// 1=RTC used with DMA, 0=no RTC alloc
 	unsigned int io_range;
@@ -358,13 +359,14 @@ typedef struct {
 	struct comedi_subdevice *sub_ai;	// ptr to AI subdevice
 	unsigned char usefifo;	// 1=use fifo
 	unsigned int ao_readback[2];
-} pcl818_private;
+};
+
 
 static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	// used for gain list programming
 	0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
 };
 
-#define devpriv ((pcl818_private *)dev->private)
+#define devpriv ((struct pcl818_private *)dev->private)
 #define this_board ((const struct pcl818_board *)dev->board_ptr)
 
 /*
@@ -1685,7 +1687,7 @@ static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * i
 	unsigned long pages;
 	struct comedi_subdevice *s;
 
-	if ((ret = alloc_private(dev, sizeof(pcl818_private))) < 0)
+	if ((ret = alloc_private(dev, sizeof(struct pcl818_private))) < 0)
 		return ret;	/* Can't alloc mem */
 
 	/* claim our I/O space */

commit 4634b8154e23ced2f70a00ab3a22e6b1987fc348
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:14:35 2009 -0400

    Staging: comedi: Remove boardtype typedef in pcl818.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index fb5ddad18735..274741f76158 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -252,7 +252,8 @@ static int RTC_lock = 0;	/* RTC lock */
 static int RTC_timer_lock = 0;	/* RTC int lock */
 #endif
 
-typedef struct {
+struct pcl818_board {
+
 	const char *name;	// driver name
 	int n_ranges;		// len of range list
 	int n_aichan_se;	// num of A/D chans in single ended  mode
@@ -270,9 +271,10 @@ typedef struct {
 	int ao_maxdata;		// maxdata for D/A
 	unsigned char fifo;	// 1=board has FIFO
 	int is_818;
-} boardtype;
+};
+
 
-static const boardtype boardtypes[] = {
+static const struct pcl818_board boardtypes[] = {
 	{"pcl818l", 4, 16, 8, 25000, 1, 16, 16, &range_pcl818l_l_ai,
 			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
 		0x0a, 0xfff, 0xfff, 0, 1},
@@ -297,7 +299,7 @@ static const boardtype boardtypes[] = {
 		0x0a, 0xfff, 0xfff, 0, 1 /* XXX ? */ },
 };
 
-#define n_boardtypes (sizeof(boardtypes)/sizeof(boardtype))
+#define n_boardtypes (sizeof(boardtypes)/sizeof(struct pcl818_board))
 
 static struct comedi_driver driver_pcl818 = {
       driver_name:"pcl818",
@@ -306,7 +308,7 @@ static struct comedi_driver driver_pcl818 = {
       detach:pcl818_detach,
       board_name:&boardtypes[0].name,
       num_names:n_boardtypes,
-      offset:sizeof(boardtype),
+      offset:sizeof(struct pcl818_board),
 };
 
 COMEDI_INITCLEANUP(driver_pcl818);
@@ -363,7 +365,7 @@ static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0
 };
 
 #define devpriv ((pcl818_private *)dev->private)
-#define this_board ((const boardtype *)dev->board_ptr)
+#define this_board ((const struct pcl818_board *)dev->board_ptr)
 
 /*
 ==============================================================================

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 4b315c090baf..fb5ddad18735 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -244,7 +244,7 @@ static const struct comedi_lrange range718_bipolar0_5 = { 1, {BIP_RANGE(0.5),} }
 static const struct comedi_lrange range718_unipolar2 = { 1, {UNI_RANGE(2),} };
 static const struct comedi_lrange range718_unipolar1 = { 1, {BIP_RANGE(1),} };
 
-static int pcl818_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int pcl818_detach(struct comedi_device * dev);
 
 #ifdef unused
@@ -1675,7 +1675,7 @@ static void free_resources(struct comedi_device * dev)
    Initialization
 
 */
-static int pcl818_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	int ret;
 	unsigned long iobase;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 9eaabfb18042..4b315c090baf 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -388,7 +388,7 @@ static int rtc_setfreq_irq(int freq);
    ANALOG INPUT MODE0, 818 cards, slow version
 */
 static int pcl818_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	int timeout;
@@ -435,7 +435,7 @@ static int pcl818_ai_insn_read(struct comedi_device * dev, struct comedi_subdevi
    only one sample per call is supported
 */
 static int pcl818_ao_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -448,7 +448,7 @@ static int pcl818_ao_insn_read(struct comedi_device * dev, struct comedi_subdevi
 }
 
 static int pcl818_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -471,7 +471,7 @@ static int pcl818_ao_insn_write(struct comedi_device * dev, struct comedi_subdev
    only one sample per call is supported
 */
 static int pcl818_di_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -489,7 +489,7 @@ static int pcl818_di_insn_bits(struct comedi_device * dev, struct comedi_subdevi
    only one sample per call is supported
 */
 static int pcl818_do_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
 		return -EINVAL;

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index d1992969c037..9eaabfb18042 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -955,7 +955,7 @@ static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device * dev,
 static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
 	struct comedi_subdevice * s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int divisor1, divisor2;
 	unsigned int seglen;
 
@@ -1252,7 +1252,7 @@ static int check_single_ended(unsigned int port)
 ==============================================================================
 */
 static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
@@ -1398,7 +1398,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 */
 static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
 
 	rt_printk("pcl818_ai_cmd()\n");

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index afe326e7d98c..d1992969c037 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -194,7 +194,7 @@ A word or two about DMA. Driver support DMA operations at two ways:
 
 #define MAGIC_DMA_WORD 0x5a5a
 
-static const comedi_lrange range_pcl818h_ai = { 9, {
+static const struct comedi_lrange range_pcl818h_ai = { 9, {
 			BIP_RANGE(5),
 			BIP_RANGE(2.5),
 			BIP_RANGE(1.25),
@@ -207,7 +207,7 @@ static const comedi_lrange range_pcl818h_ai = { 9, {
 	}
 };
 
-static const comedi_lrange range_pcl818hg_ai = { 10, {
+static const struct comedi_lrange range_pcl818hg_ai = { 10, {
 			BIP_RANGE(5),
 			BIP_RANGE(0.5),
 			BIP_RANGE(0.05),
@@ -223,7 +223,7 @@ static const comedi_lrange range_pcl818hg_ai = { 10, {
 	}
 };
 
-static const comedi_lrange range_pcl818l_l_ai = { 4, {
+static const struct comedi_lrange range_pcl818l_l_ai = { 4, {
 			BIP_RANGE(5),
 			BIP_RANGE(2.5),
 			BIP_RANGE(1.25),
@@ -231,7 +231,7 @@ static const comedi_lrange range_pcl818l_l_ai = { 4, {
 	}
 };
 
-static const comedi_lrange range_pcl818l_h_ai = { 4, {
+static const struct comedi_lrange range_pcl818l_h_ai = { 4, {
 			BIP_RANGE(10),
 			BIP_RANGE(5),
 			BIP_RANGE(2.5),
@@ -239,10 +239,10 @@ static const comedi_lrange range_pcl818l_h_ai = { 4, {
 	}
 };
 
-static const comedi_lrange range718_bipolar1 = { 1, {BIP_RANGE(1),} };
-static const comedi_lrange range718_bipolar0_5 = { 1, {BIP_RANGE(0.5),} };
-static const comedi_lrange range718_unipolar2 = { 1, {UNI_RANGE(2),} };
-static const comedi_lrange range718_unipolar1 = { 1, {BIP_RANGE(1),} };
+static const struct comedi_lrange range718_bipolar1 = { 1, {BIP_RANGE(1),} };
+static const struct comedi_lrange range718_bipolar0_5 = { 1, {BIP_RANGE(0.5),} };
+static const struct comedi_lrange range718_unipolar2 = { 1, {UNI_RANGE(2),} };
+static const struct comedi_lrange range718_unipolar1 = { 1, {BIP_RANGE(1),} };
 
 static int pcl818_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int pcl818_detach(struct comedi_device * dev);
@@ -261,8 +261,8 @@ typedef struct {
 	int n_aochan;		// num of D/A chans
 	int n_dichan;		// num of DI chans
 	int n_dochan;		// num of DO chans
-	const comedi_lrange *ai_range_type;	// default A/D rangelist
-	const comedi_lrange *ao_range_type;	// default D/A rangelist
+	const struct comedi_lrange *ai_range_type;	// default A/D rangelist
+	const struct comedi_lrange *ao_range_type;	// default D/A rangelist
 	unsigned int io_range;	// len of IO space
 	unsigned int IRQbits;	// allowed interrupts
 	unsigned int DMAbits;	// allowed DMA chans

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index d202022c1be6..afe326e7d98c 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -299,7 +299,7 @@ static const boardtype boardtypes[] = {
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(boardtype))
 
-static comedi_driver driver_pcl818 = {
+static struct comedi_driver driver_pcl818 = {
       driver_name:"pcl818",
       module:THIS_MODULE,
       attach:pcl818_attach,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 156788916b50..d202022c1be6 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -339,7 +339,7 @@ typedef struct {
 	int irq_blocked;	// 1=IRQ now uses any subdev
 	int irq_was_now_closed;	// when IRQ finish, there's stored int818_mode for last interrupt
 	int ai_mode;		// who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma
-	comedi_subdevice *last_int_sub;	// ptr to subdevice which now finish
+	struct comedi_subdevice *last_int_sub;	// ptr to subdevice which now finish
 	int ai_act_scan;	// how many scans we finished
 	int ai_act_chan;	// actual position in actual scan
 	unsigned int act_chanlist[16];	// MUX setting for actual AI operations
@@ -353,7 +353,7 @@ typedef struct {
 	short *ai_data;	// data buffer
 	unsigned int ai_timer1;	// timers
 	unsigned int ai_timer2;
-	comedi_subdevice *sub_ai;	// ptr to AI subdevice
+	struct comedi_subdevice *sub_ai;	// ptr to AI subdevice
 	unsigned char usefifo;	// 1=use fifo
 	unsigned int ao_readback[2];
 } pcl818_private;
@@ -368,12 +368,12 @@ static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0
 /*
 ==============================================================================
 */
-static void setup_channel_list(struct comedi_device * dev, comedi_subdevice * s,
+static void setup_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen);
-static int check_channel_list(struct comedi_device * dev, comedi_subdevice * s,
+static int check_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int *chanlist, unsigned int n_chan);
 
-static int pcl818_ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int pcl818_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static void start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
 	unsigned int divisor2);
 
@@ -387,7 +387,7 @@ static int rtc_setfreq_irq(int freq);
 ==============================================================================
    ANALOG INPUT MODE0, 818 cards, slow version
 */
-static int pcl818_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int pcl818_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;
@@ -434,7 +434,7 @@ static int pcl818_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
    ANALOG OUTPUT MODE0, 818 cards
    only one sample per call is supported
 */
-static int pcl818_ao_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int pcl818_ao_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;
@@ -447,7 +447,7 @@ static int pcl818_ao_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int pcl818_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s,
+static int pcl818_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;
@@ -470,7 +470,7 @@ static int pcl818_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s
 
    only one sample per call is supported
 */
-static int pcl818_di_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int pcl818_di_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
@@ -488,7 +488,7 @@ static int pcl818_di_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 
    only one sample per call is supported
 */
-static int pcl818_do_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int pcl818_do_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
@@ -513,7 +513,7 @@ static int pcl818_do_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	comedi_subdevice *s = dev->subdevices + 0;
+	struct comedi_subdevice *s = dev->subdevices + 0;
 	int low;
 	int timeout = 50;	/* wait max 50us */
 
@@ -566,7 +566,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	comedi_subdevice *s = dev->subdevices + 0;
+	struct comedi_subdevice *s = dev->subdevices + 0;
 	int i, len, bufptr;
 	unsigned long flags;
 	short *ptr;
@@ -641,7 +641,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	comedi_subdevice *s = dev->subdevices + 0;
+	struct comedi_subdevice *s = dev->subdevices + 0;
 	unsigned long tmp;
 	unsigned int top1, top2, i, bufptr;
 	long ofs_dats;
@@ -739,7 +739,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	comedi_subdevice *s = dev->subdevices + 0;
+	struct comedi_subdevice *s = dev->subdevices + 0;
 	int i, len, lo;
 
 	outb(0, dev->iobase + PCL818_FI_INTCLR);	// clear fifo int request
@@ -849,7 +849,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d PT_REGS_ARG)
 				   because the card doesn't seem to like being reprogrammed
 				   while a DMA transfer is in progress
 				 */
-				comedi_subdevice *s = dev->subdevices + 0;
+				struct comedi_subdevice *s = dev->subdevices + 0;
 				devpriv->ai_mode = devpriv->irq_was_now_closed;
 				devpriv->irq_was_now_closed = 0;
 				devpriv->neverending_ai = 0;
@@ -871,7 +871,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d PT_REGS_ARG)
    ANALOG INPUT MODE 1 or 3 DMA , 818 cards
 */
 static void pcl818_ai_mode13dma_int(int mode, struct comedi_device * dev,
-	comedi_subdevice * s)
+	struct comedi_subdevice * s)
 {
 	unsigned int flags;
 	unsigned int bytes;
@@ -912,7 +912,7 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device * dev,
    ANALOG INPUT MODE 1 or 3 DMA rtc, 818 cards
 */
 static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device * dev,
-	comedi_subdevice * s)
+	struct comedi_subdevice * s)
 {
 	unsigned int flags;
 	short *pole;
@@ -953,7 +953,7 @@ static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device * dev,
    ANALOG INPUT MODE 1 or 3, 818 cards
 */
 static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
-	comedi_subdevice * s)
+	struct comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	int divisor1, divisor2;
@@ -1063,7 +1063,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
    ANALOG OUTPUT MODE 1 or 3, 818 cards
 */
 #ifdef PCL818_MODE13_AO
-static int pcl818_ao_mode13(int mode, struct comedi_device * dev, comedi_subdevice * s,
+static int pcl818_ao_mode13(int mode, struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_trig * it)
 {
 	int divisor1, divisor2;
@@ -1116,7 +1116,7 @@ static int pcl818_ao_mode13(int mode, struct comedi_device * dev, comedi_subdevi
 ==============================================================================
    ANALOG OUTPUT MODE 1, 818 cards
 */
-static int pcl818_ao_mode1(struct comedi_device * dev, comedi_subdevice * s,
+static int pcl818_ao_mode1(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_trig * it)
 {
 	return pcl818_ao_mode13(1, dev, s, it);
@@ -1126,7 +1126,7 @@ static int pcl818_ao_mode1(struct comedi_device * dev, comedi_subdevice * s,
 ==============================================================================
    ANALOG OUTPUT MODE 3, 818 cards
 */
-static int pcl818_ao_mode3(struct comedi_device * dev, comedi_subdevice * s,
+static int pcl818_ao_mode3(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_trig * it)
 {
 	return pcl818_ao_mode13(3, dev, s, it);
@@ -1158,7 +1158,7 @@ static void start_pacer(struct comedi_device * dev, int mode, unsigned int divis
  Check if channel list from user is builded correctly
  If it's ok, then program scan/gain logic
 */
-static int check_channel_list(struct comedi_device * dev, comedi_subdevice * s,
+static int check_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int *chanlist, unsigned int n_chan)
 {
 	unsigned int chansegment[16];
@@ -1214,7 +1214,7 @@ static int check_channel_list(struct comedi_device * dev, comedi_subdevice * s,
 	return seglen;
 }
 
-static void setup_channel_list(struct comedi_device * dev, comedi_subdevice * s,
+static void setup_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen)
 {
 	int i;
@@ -1251,7 +1251,7 @@ static int check_single_ended(unsigned int port)
 /*
 ==============================================================================
 */
-static int ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1396,7 +1396,7 @@ static int ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static int ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	int retval;
@@ -1435,7 +1435,7 @@ static int ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 ==============================================================================
  cancel any mode 1-4 AI
 */
-static int pcl818_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int pcl818_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	if (devpriv->irq_blocked > 0) {
 		rt_printk("pcl818_ai_cancel()\n");
@@ -1681,7 +1681,7 @@ static int pcl818_attach(struct comedi_device * dev, comedi_devconfig * it)
 	unsigned long iobase;
 	unsigned int irq, dma;
 	unsigned long pages;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	if ((ret = alloc_private(dev, sizeof(pcl818_private))) < 0)
 		return ret;	/* Can't alloc mem */

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 5425c196bed1..156788916b50 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -244,8 +244,8 @@ static const comedi_lrange range718_bipolar0_5 = { 1, {BIP_RANGE(0.5),} };
 static const comedi_lrange range718_unipolar2 = { 1, {UNI_RANGE(2),} };
 static const comedi_lrange range718_unipolar1 = { 1, {BIP_RANGE(1),} };
 
-static int pcl818_attach(comedi_device * dev, comedi_devconfig * it);
-static int pcl818_detach(comedi_device * dev);
+static int pcl818_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pcl818_detach(struct comedi_device * dev);
 
 #ifdef unused
 static int RTC_lock = 0;	/* RTC lock */
@@ -368,13 +368,13 @@ static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0
 /*
 ==============================================================================
 */
-static void setup_channel_list(comedi_device * dev, comedi_subdevice * s,
+static void setup_channel_list(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen);
-static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
+static int check_channel_list(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int *chanlist, unsigned int n_chan);
 
-static int pcl818_ai_cancel(comedi_device * dev, comedi_subdevice * s);
-static void start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
+static int pcl818_ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static void start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
 	unsigned int divisor2);
 
 #ifdef unused
@@ -387,7 +387,7 @@ static int rtc_setfreq_irq(int freq);
 ==============================================================================
    ANALOG INPUT MODE0, 818 cards, slow version
 */
-static int pcl818_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int pcl818_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;
@@ -434,7 +434,7 @@ static int pcl818_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
    ANALOG OUTPUT MODE0, 818 cards
    only one sample per call is supported
 */
-static int pcl818_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int pcl818_ao_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;
@@ -447,7 +447,7 @@ static int pcl818_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int pcl818_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
+static int pcl818_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;
@@ -470,7 +470,7 @@ static int pcl818_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
 
    only one sample per call is supported
 */
-static int pcl818_di_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int pcl818_di_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
@@ -488,7 +488,7 @@ static int pcl818_di_insn_bits(comedi_device * dev, comedi_subdevice * s,
 
    only one sample per call is supported
 */
-static int pcl818_do_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int pcl818_do_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
@@ -512,7 +512,7 @@ static int pcl818_do_insn_bits(comedi_device * dev, comedi_subdevice * s,
 */
 static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	comedi_subdevice *s = dev->subdevices + 0;
 	int low;
 	int timeout = 50;	/* wait max 50us */
@@ -565,7 +565,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 */
 static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	comedi_subdevice *s = dev->subdevices + 0;
 	int i, len, bufptr;
 	unsigned long flags;
@@ -640,7 +640,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 */
 static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	comedi_subdevice *s = dev->subdevices + 0;
 	unsigned long tmp;
 	unsigned int top1, top2, i, bufptr;
@@ -738,7 +738,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 */
 static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	comedi_subdevice *s = dev->subdevices + 0;
 	int i, len, lo;
 
@@ -808,7 +808,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 */
 static irqreturn_t interrupt_pcl818(int irq, void *d PT_REGS_ARG)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 
 	if (!dev->attached) {
 		comedi_error(dev, "premature interrupt");
@@ -870,7 +870,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d PT_REGS_ARG)
 ==============================================================================
    ANALOG INPUT MODE 1 or 3 DMA , 818 cards
 */
-static void pcl818_ai_mode13dma_int(int mode, comedi_device * dev,
+static void pcl818_ai_mode13dma_int(int mode, struct comedi_device * dev,
 	comedi_subdevice * s)
 {
 	unsigned int flags;
@@ -911,7 +911,7 @@ static void pcl818_ai_mode13dma_int(int mode, comedi_device * dev,
 ==============================================================================
    ANALOG INPUT MODE 1 or 3 DMA rtc, 818 cards
 */
-static void pcl818_ai_mode13dma_rtc(int mode, comedi_device * dev,
+static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device * dev,
 	comedi_subdevice * s)
 {
 	unsigned int flags;
@@ -952,7 +952,7 @@ static void pcl818_ai_mode13dma_rtc(int mode, comedi_device * dev,
 ==============================================================================
    ANALOG INPUT MODE 1 or 3, 818 cards
 */
-static int pcl818_ai_cmd_mode(int mode, comedi_device * dev,
+static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
 	comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
@@ -1063,7 +1063,7 @@ static int pcl818_ai_cmd_mode(int mode, comedi_device * dev,
    ANALOG OUTPUT MODE 1 or 3, 818 cards
 */
 #ifdef PCL818_MODE13_AO
-static int pcl818_ao_mode13(int mode, comedi_device * dev, comedi_subdevice * s,
+static int pcl818_ao_mode13(int mode, struct comedi_device * dev, comedi_subdevice * s,
 	comedi_trig * it)
 {
 	int divisor1, divisor2;
@@ -1116,7 +1116,7 @@ static int pcl818_ao_mode13(int mode, comedi_device * dev, comedi_subdevice * s,
 ==============================================================================
    ANALOG OUTPUT MODE 1, 818 cards
 */
-static int pcl818_ao_mode1(comedi_device * dev, comedi_subdevice * s,
+static int pcl818_ao_mode1(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_trig * it)
 {
 	return pcl818_ao_mode13(1, dev, s, it);
@@ -1126,7 +1126,7 @@ static int pcl818_ao_mode1(comedi_device * dev, comedi_subdevice * s,
 ==============================================================================
    ANALOG OUTPUT MODE 3, 818 cards
 */
-static int pcl818_ao_mode3(comedi_device * dev, comedi_subdevice * s,
+static int pcl818_ao_mode3(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_trig * it)
 {
 	return pcl818_ao_mode13(3, dev, s, it);
@@ -1138,7 +1138,7 @@ static int pcl818_ao_mode3(comedi_device * dev, comedi_subdevice * s,
 ==============================================================================
  Start/stop pacer onboard pacer
 */
-static void start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
+static void start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
 	unsigned int divisor2)
 {
 	outb(0xb4, dev->iobase + PCL818_CTRCTL);
@@ -1158,7 +1158,7 @@ static void start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
  Check if channel list from user is builded correctly
  If it's ok, then program scan/gain logic
 */
-static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
+static int check_channel_list(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int *chanlist, unsigned int n_chan)
 {
 	unsigned int chansegment[16];
@@ -1214,7 +1214,7 @@ static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
 	return seglen;
 }
 
-static void setup_channel_list(comedi_device * dev, comedi_subdevice * s,
+static void setup_channel_list(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen)
 {
 	int i;
@@ -1251,7 +1251,7 @@ static int check_single_ended(unsigned int port)
 /*
 ==============================================================================
 */
-static int ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1396,7 +1396,7 @@ static int ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static int ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	int retval;
@@ -1435,7 +1435,7 @@ static int ai_cmd(comedi_device * dev, comedi_subdevice * s)
 ==============================================================================
  cancel any mode 1-4 AI
 */
-static int pcl818_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+static int pcl818_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	if (devpriv->irq_blocked > 0) {
 		rt_printk("pcl818_ai_cancel()\n");
@@ -1516,7 +1516,7 @@ static int pcl818_check(unsigned long iobase)
 ==============================================================================
  reset whole PCL-818 cards
 */
-static void pcl818_reset(comedi_device * dev)
+static void pcl818_reset(struct comedi_device * dev)
 {
 	if (devpriv->usefifo) {	// FIFO shutdown
 		outb(0, dev->iobase + PCL818_FI_INTCLR);
@@ -1586,7 +1586,7 @@ static int set_rtc_irq_bit(unsigned char bit)
 */
 static void rtc_dropped_irq(unsigned long data)
 {
-	comedi_device *dev = (void *)data;
+	struct comedi_device *dev = (void *)data;
 	unsigned long flags, tmp;
 
 	switch (devpriv->int818_mode) {
@@ -1637,7 +1637,7 @@ static int rtc_setfreq_irq(int freq)
 ==============================================================================
   Free any resources that we have claimed
 */
-static void free_resources(comedi_device * dev)
+static void free_resources(struct comedi_device * dev)
 {
 	//rt_printk("free_resource()\n");
 	if (dev->private) {
@@ -1675,7 +1675,7 @@ static void free_resources(comedi_device * dev)
    Initialization
 
 */
-static int pcl818_attach(comedi_device * dev, comedi_devconfig * it)
+static int pcl818_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	int ret;
 	unsigned long iobase;
@@ -1976,7 +1976,7 @@ static int pcl818_attach(comedi_device * dev, comedi_devconfig * it)
 ==============================================================================
   Removes device
  */
-static int pcl818_detach(comedi_device * dev)
+static int pcl818_detach(struct comedi_device * dev)
 {
 	//  rt_printk("comedi%d: pcl818: remove\n", dev->minor);
 	free_resources(dev);

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 9e648c3cc12e..5425c196bed1 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -350,12 +350,12 @@ typedef struct {
 	unsigned int *ai_chanlist;	// actaul chanlist
 	unsigned int ai_flags;	// flaglist
 	unsigned int ai_data_len;	// len of data buffer
-	sampl_t *ai_data;	// data buffer
+	short *ai_data;	// data buffer
 	unsigned int ai_timer1;	// timers
 	unsigned int ai_timer2;
 	comedi_subdevice *sub_ai;	// ptr to AI subdevice
 	unsigned char usefifo;	// 1=use fifo
-	lsampl_t ao_readback[2];
+	unsigned int ao_readback[2];
 } pcl818_private;
 
 static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	// used for gain list programming
@@ -388,7 +388,7 @@ static int rtc_setfreq_irq(int freq);
    ANALOG INPUT MODE0, 818 cards, slow version
 */
 static int pcl818_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	int timeout;
@@ -435,7 +435,7 @@ static int pcl818_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
    only one sample per call is supported
 */
 static int pcl818_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -448,7 +448,7 @@ static int pcl818_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int pcl818_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -471,7 +471,7 @@ static int pcl818_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
    only one sample per call is supported
 */
 static int pcl818_di_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -489,7 +489,7 @@ static int pcl818_di_insn_bits(comedi_device * dev, comedi_subdevice * s,
    only one sample per call is supported
 */
 static int pcl818_do_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -569,7 +569,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 	comedi_subdevice *s = dev->subdevices + 0;
 	int i, len, bufptr;
 	unsigned long flags;
-	sampl_t *ptr;
+	short *ptr;
 
 	disable_dma(devpriv->dma);
 	devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
@@ -591,7 +591,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 
 	devpriv->dma_runs_to_end--;
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
-	ptr = (sampl_t *) devpriv->dmabuf[1 - devpriv->next_dma_buf];
+	ptr = (short *) devpriv->dmabuf[1 - devpriv->next_dma_buf];
 
 	len = devpriv->hwdmasize[0] >> 1;
 	bufptr = 0;
@@ -645,7 +645,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 	unsigned long tmp;
 	unsigned int top1, top2, i, bufptr;
 	long ofs_dats;
-	sampl_t *dmabuf = (sampl_t *) devpriv->dmabuf[0];
+	short *dmabuf = (short *) devpriv->dmabuf[0];
 
 	//outb(2,0x378);
 	switch (devpriv->ai_mode) {
@@ -880,7 +880,7 @@ static void pcl818_ai_mode13dma_int(int mode, comedi_device * dev,
 	disable_dma(devpriv->dma);	// disable dma
 	bytes = devpriv->hwdmasize[0];
 	if (!devpriv->neverending_ai) {
-		bytes = devpriv->ai_n_chan * devpriv->ai_scans * sizeof(sampl_t);	// how many
+		bytes = devpriv->ai_n_chan * devpriv->ai_scans * sizeof(short);	// how many
 		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize[0];	// how many DMA pages we must fiil
 		devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];	//on last dma transfer must be moved
 		devpriv->dma_runs_to_end--;
@@ -915,7 +915,7 @@ static void pcl818_ai_mode13dma_rtc(int mode, comedi_device * dev,
 	comedi_subdevice * s)
 {
 	unsigned int flags;
-	sampl_t *pole;
+	short *pole;
 
 	set_dma_mode(devpriv->dma, DMA_MODE_READ | DMA_AUTOINIT);
 	flags = claim_dma_lock();
@@ -925,7 +925,7 @@ static void pcl818_ai_mode13dma_rtc(int mode, comedi_device * dev,
 	release_dma_lock(flags);
 	enable_dma(devpriv->dma);
 	devpriv->last_top_dma = 0;	//devpriv->hwdmasize[0];
-	pole = (sampl_t *) devpriv->dmabuf[0];
+	pole = (short *) devpriv->dmabuf[0];
 	devpriv->dmasamplsize = devpriv->hwdmasize[0] / 2;
 	pole[devpriv->dmasamplsize - 1] = MAGIC_DMA_WORD;
 #ifdef unused

commit 4da6a1d8f56f01f6526f151c2c61059fc656ec80
Author: Michal Dobes <dobes@tesnet.cz>
Date:   Tue Feb 17 16:21:06 2009 -0800

    Staging: comedi: add pcl818 driver
    
    For Advantech cards:
            PCL-818L, PCL-818H, PCL-818HD, PCL-818HG, PCL-818, PCL-718
    
    From: Michal Dobes <dobes@tesnet.cz>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
new file mode 100644
index 000000000000..9e648c3cc12e
--- /dev/null
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -0,0 +1,1984 @@
+/*
+   comedi/drivers/pcl818.c
+
+   Author:  Michal Dobes <dobes@tesnet.cz>
+
+   hardware driver for Advantech cards:
+    card:   PCL-818L, PCL-818H, PCL-818HD, PCL-818HG, PCL-818, PCL-718
+    driver: pcl818l,  pcl818h,  pcl818hd,  pcl818hg,  pcl818,  pcl718
+*/
+/*
+Driver: pcl818
+Description: Advantech PCL-818 cards, PCL-718
+Author: Michal Dobes <dobes@tesnet.cz>
+Devices: [Advantech] PCL-818L (pcl818l), PCL-818H (pcl818h),
+  PCL-818HD (pcl818hd), PCL-818HG (pcl818hg), PCL-818 (pcl818),
+  PCL-718 (pcl718)
+Status: works
+
+All cards have 16 SE/8 DIFF ADCs, one or two DACs, 16 DI and 16 DO.
+Differences are only at maximal sample speed, range list and FIFO
+support.
+The driver support AI mode 0, 1, 3 other subdevices (AO, DI, DO) support
+only mode 0. If DMA/FIFO/INT are disabled then AI support only mode 0.
+PCL-818HD and PCL-818HG support 1kword FIFO. Driver support this FIFO
+but this code is untested.
+A word or two about DMA. Driver support DMA operations at two ways:
+1) DMA uses two buffers and after one is filled then is generated
+   INT and DMA restart with second buffer. With this mode I'm unable run
+   more that 80Ksamples/secs without data dropouts on K6/233.
+2) DMA uses one buffer and run in autoinit mode and the data are
+   from DMA buffer moved on the fly with 2kHz interrupts from RTC.
+   This mode is used if the interrupt 8 is available for allocation.
+   If not, then first DMA mode is used. With this I can run at
+   full speed one card (100ksamples/secs) or two cards with
+   60ksamples/secs each (more is problem on account of ISA limitations).
+   To use this mode you must have compiled  kernel with disabled
+   "Enhanced Real Time Clock Support".
+   Maybe you can have problems if you use xntpd or similar.
+   If you've data dropouts with DMA mode 2 then:
+    a) disable IDE DMA
+    b) switch text mode console to fb.
+
+   Options for PCL-818L:
+    [0] - IO Base
+    [1] - IRQ	(0=disable, 2, 3, 4, 5, 6, 7)
+    [2] - DMA	(0=disable, 1, 3)
+    [3] - 0, 10=10MHz clock for 8254
+              1= 1MHz clock for 8254
+    [4] - 0,  5=A/D input  -5V.. +5V
+          1, 10=A/D input -10V..+10V
+    [5] - 0,  5=D/A output 0-5V  (internal reference -5V)
+          1, 10=D/A output 0-10V (internal reference -10V)
+	  2    =D/A output unknow (external reference)
+
+   Options for PCL-818, PCL-818H:
+    [0] - IO Base
+    [1] - IRQ	(0=disable, 2, 3, 4, 5, 6, 7)
+    [2] - DMA	(0=disable, 1, 3)
+    [3] - 0, 10=10MHz clock for 8254
+              1= 1MHz clock for 8254
+    [4] - 0,  5=D/A output 0-5V  (internal reference -5V)
+          1, 10=D/A output 0-10V (internal reference -10V)
+	  2    =D/A output unknow (external reference)
+
+   Options for PCL-818HD, PCL-818HG:
+    [0] - IO Base
+    [1] - IRQ	(0=disable, 2, 3, 4, 5, 6, 7)
+    [2] - DMA/FIFO  (-1=use FIFO, 0=disable both FIFO and DMA,
+                      1=use DMA ch 1, 3=use DMA ch 3)
+    [3] - 0, 10=10MHz clock for 8254
+              1= 1MHz clock for 8254
+    [4] - 0,  5=D/A output 0-5V  (internal reference -5V)
+          1, 10=D/A output 0-10V (internal reference -10V)
+   	  2    =D/A output unknow (external reference)
+
+   Options for PCL-718:
+    [0] - IO Base
+    [1] - IRQ	(0=disable, 2, 3, 4, 5, 6, 7)
+    [2] - DMA	(0=disable, 1, 3)
+    [3] - 0, 10=10MHz clock for 8254
+              1= 1MHz clock for 8254
+    [4] -     0=A/D Range is +/-10V
+	      1=             +/-5V
+	      2=             +/-2.5V
+	      3=             +/-1V
+	      4=             +/-0.5V
+	      5=  	     user defined bipolar
+	      6=	     0-10V
+	      7=	     0-5V
+ 	      8=	     0-2V
+	      9=	     0-1V
+	     10=	     user defined unipolar
+    [5] - 0,  5=D/A outputs 0-5V  (internal reference -5V)
+          1, 10=D/A outputs 0-10V (internal reference -10V)
+	      2=D/A outputs unknow (external reference)
+    [6] - 0, 60=max  60kHz A/D sampling
+          1,100=max 100kHz A/D sampling (PCL-718 with Option 001 installed)
+
+*/
+
+#include "../comedidev.h"
+
+#include <linux/ioport.h>
+#include <linux/mc146818rtc.h>
+#include <linux/delay.h>
+#include <asm/dma.h>
+
+#include "8253.h"
+
+// #define PCL818_MODE13_AO 1
+
+// boards constants
+
+#define boardPCL818L 0
+#define boardPCL818H 1
+#define boardPCL818HD 2
+#define boardPCL818HG 3
+#define boardPCL818 4
+#define boardPCL718 5
+
+// IO space len
+#define PCLx1x_RANGE 16
+// IO space len if we use FIFO
+#define PCLx1xFIFO_RANGE 32
+
+// W: clear INT request
+#define PCL818_CLRINT 8
+// R: return status byte
+#define PCL818_STATUS 8
+// R: A/D high byte W: A/D range control
+#define PCL818_RANGE 1
+// R: next mux scan channel W: mux scan channel & range control pointer
+#define PCL818_MUX 2
+// R/W: operation control register
+#define PCL818_CONTROL 9
+// W: counter enable
+#define PCL818_CNTENABLE 10
+
+// R: low byte of A/D W: soft A/D trigger
+#define PCL818_AD_LO 0
+// R: high byte of A/D W: A/D range control
+#define PCL818_AD_HI 1
+// W: D/A low&high byte
+#define PCL818_DA_LO 4
+#define PCL818_DA_HI 5
+// R: low&high byte of DI
+#define PCL818_DI_LO 3
+#define PCL818_DI_HI 11
+// W: low&high byte of DO
+#define PCL818_DO_LO 3
+#define PCL818_DO_HI 11
+// W: PCL718 second D/A
+#define PCL718_DA2_LO 6
+#define PCL718_DA2_HI 7
+// counters
+#define PCL818_CTR0 12
+#define PCL818_CTR1 13
+#define PCL818_CTR2 14
+// W: counter control
+#define PCL818_CTRCTL 15
+
+// W: fifo enable/disable
+#define PCL818_FI_ENABLE 6
+// W: fifo interrupt clear
+#define PCL818_FI_INTCLR 20
+// W: fifo interrupt clear
+#define PCL818_FI_FLUSH 25
+// R: fifo status
+#define PCL818_FI_STATUS 25
+// R: one record from FIFO
+#define PCL818_FI_DATALO 23
+#define PCL818_FI_DATAHI 23
+
+// type of interrupt handler
+#define INT_TYPE_AI1_INT 1
+#define INT_TYPE_AI1_DMA 2
+#define INT_TYPE_AI1_FIFO 3
+#define INT_TYPE_AI3_INT 4
+#define INT_TYPE_AI3_DMA 5
+#define INT_TYPE_AI3_FIFO 6
+#ifdef PCL818_MODE13_AO
+#define INT_TYPE_AO1_INT 7
+#define INT_TYPE_AO3_INT 8
+#endif
+
+#ifdef unused
+// RTC stuff...
+#define INT_TYPE_AI1_DMA_RTC 9
+#define INT_TYPE_AI3_DMA_RTC 10
+
+#define RTC_IRQ 	8
+#define RTC_IO_EXTENT	0x10
+#endif
+
+#define MAGIC_DMA_WORD 0x5a5a
+
+static const comedi_lrange range_pcl818h_ai = { 9, {
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25),
+			BIP_RANGE(0.625),
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2.5),
+			UNI_RANGE(1.25),
+			BIP_RANGE(10),
+	}
+};
+
+static const comedi_lrange range_pcl818hg_ai = { 10, {
+			BIP_RANGE(5),
+			BIP_RANGE(0.5),
+			BIP_RANGE(0.05),
+			BIP_RANGE(0.005),
+			UNI_RANGE(10),
+			UNI_RANGE(1),
+			UNI_RANGE(0.1),
+			UNI_RANGE(0.01),
+			BIP_RANGE(10),
+			BIP_RANGE(1),
+			BIP_RANGE(0.1),
+			BIP_RANGE(0.01),
+	}
+};
+
+static const comedi_lrange range_pcl818l_l_ai = { 4, {
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25),
+			BIP_RANGE(0.625),
+	}
+};
+
+static const comedi_lrange range_pcl818l_h_ai = { 4, {
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25),
+	}
+};
+
+static const comedi_lrange range718_bipolar1 = { 1, {BIP_RANGE(1),} };
+static const comedi_lrange range718_bipolar0_5 = { 1, {BIP_RANGE(0.5),} };
+static const comedi_lrange range718_unipolar2 = { 1, {UNI_RANGE(2),} };
+static const comedi_lrange range718_unipolar1 = { 1, {BIP_RANGE(1),} };
+
+static int pcl818_attach(comedi_device * dev, comedi_devconfig * it);
+static int pcl818_detach(comedi_device * dev);
+
+#ifdef unused
+static int RTC_lock = 0;	/* RTC lock */
+static int RTC_timer_lock = 0;	/* RTC int lock */
+#endif
+
+typedef struct {
+	const char *name;	// driver name
+	int n_ranges;		// len of range list
+	int n_aichan_se;	// num of A/D chans in single ended  mode
+	int n_aichan_diff;	// num of A/D chans in diferencial mode
+	unsigned int ns_min;	// minimal alllowed delay between samples (in ns)
+	int n_aochan;		// num of D/A chans
+	int n_dichan;		// num of DI chans
+	int n_dochan;		// num of DO chans
+	const comedi_lrange *ai_range_type;	// default A/D rangelist
+	const comedi_lrange *ao_range_type;	// default D/A rangelist
+	unsigned int io_range;	// len of IO space
+	unsigned int IRQbits;	// allowed interrupts
+	unsigned int DMAbits;	// allowed DMA chans
+	int ai_maxdata;		// maxdata for A/D
+	int ao_maxdata;		// maxdata for D/A
+	unsigned char fifo;	// 1=board has FIFO
+	int is_818;
+} boardtype;
+
+static const boardtype boardtypes[] = {
+	{"pcl818l", 4, 16, 8, 25000, 1, 16, 16, &range_pcl818l_l_ai,
+			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
+		0x0a, 0xfff, 0xfff, 0, 1},
+	{"pcl818h", 9, 16, 8, 10000, 1, 16, 16, &range_pcl818h_ai,
+			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
+		0x0a, 0xfff, 0xfff, 0, 1},
+	{"pcl818hd", 9, 16, 8, 10000, 1, 16, 16, &range_pcl818h_ai,
+			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
+		0x0a, 0xfff, 0xfff, 1, 1},
+	{"pcl818hg", 12, 16, 8, 10000, 1, 16, 16, &range_pcl818hg_ai,
+			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
+		0x0a, 0xfff, 0xfff, 1, 1},
+	{"pcl818", 9, 16, 8, 10000, 2, 16, 16, &range_pcl818h_ai,
+			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
+		0x0a, 0xfff, 0xfff, 0, 1},
+	{"pcl718", 1, 16, 8, 16000, 2, 16, 16, &range_unipolar5,
+			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
+		0x0a, 0xfff, 0xfff, 0, 0},
+	/* pcm3718 */
+	{"pcm3718", 9, 16, 8, 10000, 0, 16, 16, &range_pcl818h_ai,
+			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
+		0x0a, 0xfff, 0xfff, 0, 1 /* XXX ? */ },
+};
+
+#define n_boardtypes (sizeof(boardtypes)/sizeof(boardtype))
+
+static comedi_driver driver_pcl818 = {
+      driver_name:"pcl818",
+      module:THIS_MODULE,
+      attach:pcl818_attach,
+      detach:pcl818_detach,
+      board_name:&boardtypes[0].name,
+      num_names:n_boardtypes,
+      offset:sizeof(boardtype),
+};
+
+COMEDI_INITCLEANUP(driver_pcl818);
+
+typedef struct {
+	unsigned int dma;	// used DMA, 0=don't use DMA
+	int dma_rtc;		// 1=RTC used with DMA, 0=no RTC alloc
+	unsigned int io_range;
+#ifdef unused
+	unsigned long rtc_iobase;	// RTC port region
+	unsigned int rtc_iosize;
+	unsigned int rtc_irq;
+	struct timer_list rtc_irq_timer;	// timer for RTC sanity check
+	unsigned long rtc_freq;	// RTC int freq
+	int rtc_irq_blocked;	// 1=we now do AI with DMA&RTC
+#endif
+	unsigned long dmabuf[2];	// pointers to begin of DMA buffers
+	unsigned int dmapages[2];	// len of DMA buffers in PAGE_SIZEs
+	unsigned int hwdmaptr[2];	// hardware address of DMA buffers
+	unsigned int hwdmasize[2];	// len of DMA buffers in Bytes
+	unsigned int dmasamplsize;	// size in samples hwdmasize[0]/2
+	unsigned int last_top_dma;	// DMA pointer in last RTC int
+	int next_dma_buf;	// which DMA buffer will be used next round
+	long dma_runs_to_end;	// how many we must permorm DMA transfer to end of record
+	unsigned long last_dma_run;	// how many bytes we must transfer on last DMA page
+	unsigned char neverending_ai;	// if=1, then we do neverending record (you must use cancel())
+	unsigned int ns_min;	// manimal alllowed delay between samples (in us) for actual card
+	int i8253_osc_base;	// 1/frequency of on board oscilator in ns
+	int irq_free;		// 1=have allocated IRQ
+	int irq_blocked;	// 1=IRQ now uses any subdev
+	int irq_was_now_closed;	// when IRQ finish, there's stored int818_mode for last interrupt
+	int ai_mode;		// who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma
+	comedi_subdevice *last_int_sub;	// ptr to subdevice which now finish
+	int ai_act_scan;	// how many scans we finished
+	int ai_act_chan;	// actual position in actual scan
+	unsigned int act_chanlist[16];	// MUX setting for actual AI operations
+	unsigned int act_chanlist_len;	// how long is actual MUX list
+	unsigned int act_chanlist_pos;	// actual position in MUX list
+	unsigned int ai_scans;	// len of scanlist
+	unsigned int ai_n_chan;	// how many channels is measured
+	unsigned int *ai_chanlist;	// actaul chanlist
+	unsigned int ai_flags;	// flaglist
+	unsigned int ai_data_len;	// len of data buffer
+	sampl_t *ai_data;	// data buffer
+	unsigned int ai_timer1;	// timers
+	unsigned int ai_timer2;
+	comedi_subdevice *sub_ai;	// ptr to AI subdevice
+	unsigned char usefifo;	// 1=use fifo
+	lsampl_t ao_readback[2];
+} pcl818_private;
+
+static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	// used for gain list programming
+	0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
+};
+
+#define devpriv ((pcl818_private *)dev->private)
+#define this_board ((const boardtype *)dev->board_ptr)
+
+/*
+==============================================================================
+*/
+static void setup_channel_list(comedi_device * dev, comedi_subdevice * s,
+	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen);
+static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
+	unsigned int *chanlist, unsigned int n_chan);
+
+static int pcl818_ai_cancel(comedi_device * dev, comedi_subdevice * s);
+static void start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
+	unsigned int divisor2);
+
+#ifdef unused
+static int set_rtc_irq_bit(unsigned char bit);
+static void rtc_dropped_irq(unsigned long data);
+static int rtc_setfreq_irq(int freq);
+#endif
+
+/*
+==============================================================================
+   ANALOG INPUT MODE0, 818 cards, slow version
+*/
+static int pcl818_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n;
+	int timeout;
+
+	/* software trigger, DMA and INT off */
+	outb(0, dev->iobase + PCL818_CONTROL);
+
+	/* select channel */
+	outb(muxonechan[CR_CHAN(insn->chanspec)], dev->iobase + PCL818_MUX);
+
+	/* select gain */
+	outb(CR_RANGE(insn->chanspec), dev->iobase + PCL818_RANGE);
+
+	for (n = 0; n < insn->n; n++) {
+
+		/* clear INT (conversion end) flag */
+		outb(0, dev->iobase + PCL818_CLRINT);
+
+		/* start conversion */
+		outb(0, dev->iobase + PCL818_AD_LO);
+
+		timeout = 100;
+		while (timeout--) {
+			if (inb(dev->iobase + PCL818_STATUS) & 0x10)
+				goto conv_finish;
+			comedi_udelay(1);
+		}
+		comedi_error(dev, "A/D insn timeout");
+		/* clear INT (conversion end) flag */
+		outb(0, dev->iobase + PCL818_CLRINT);
+		return -EIO;
+
+	      conv_finish:
+		data[n] = ((inb(dev->iobase + PCL818_AD_HI) << 4) |
+			(inb(dev->iobase + PCL818_AD_LO) >> 4));
+	}
+
+	return n;
+}
+
+/*
+==============================================================================
+   ANALOG OUTPUT MODE0, 818 cards
+   only one sample per call is supported
+*/
+static int pcl818_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n;
+	int chan = CR_CHAN(insn->chanspec);
+
+	for (n = 0; n < insn->n; n++) {
+		data[n] = devpriv->ao_readback[chan];
+	}
+
+	return n;
+}
+
+static int pcl818_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n;
+	int chan = CR_CHAN(insn->chanspec);
+
+	for (n = 0; n < insn->n; n++) {
+		devpriv->ao_readback[chan] = data[n];
+		outb((data[n] & 0x000f) << 4, dev->iobase +
+			(chan) ? PCL718_DA2_LO : PCL818_DA_LO);
+		outb((data[n] & 0x0ff0) >> 4, dev->iobase +
+			(chan) ? PCL718_DA2_HI : PCL818_DA_HI);
+	}
+
+	return n;
+}
+
+/*
+==============================================================================
+   DIGITAL INPUT MODE0, 818 cards
+
+   only one sample per call is supported
+*/
+static int pcl818_di_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	if (insn->n != 2)
+		return -EINVAL;
+
+	data[1] = inb(dev->iobase + PCL818_DI_LO) |
+		(inb(dev->iobase + PCL818_DI_HI) << 8);
+
+	return 2;
+}
+
+/*
+==============================================================================
+   DIGITAL OUTPUT MODE0, 818 cards
+
+   only one sample per call is supported
+*/
+static int pcl818_do_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	if (insn->n != 2)
+		return -EINVAL;
+
+	s->state &= ~data[0];
+	s->state |= (data[0] & data[1]);
+
+	outb(s->state & 0xff, dev->iobase + PCL818_DO_LO);
+	outb((s->state >> 8), dev->iobase + PCL818_DO_HI);
+
+	data[1] = s->state;
+
+	return 2;
+}
+
+/*
+==============================================================================
+   analog input interrupt mode 1 & 3, 818 cards
+   one sample per interrupt version
+*/
+static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
+{
+	comedi_device *dev = d;
+	comedi_subdevice *s = dev->subdevices + 0;
+	int low;
+	int timeout = 50;	/* wait max 50us */
+
+	while (timeout--) {
+		if (inb(dev->iobase + PCL818_STATUS) & 0x10)
+			goto conv_finish;
+		comedi_udelay(1);
+	}
+	outb(0, dev->iobase + PCL818_STATUS);	/* clear INT request */
+	comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
+	pcl818_ai_cancel(dev, s);
+	s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+	comedi_event(dev, s);
+	return IRQ_HANDLED;
+
+      conv_finish:
+	low = inb(dev->iobase + PCL818_AD_LO);
+	comedi_buf_put(s->async, ((inb(dev->iobase + PCL818_AD_HI) << 4) | (low >> 4)));	// get one sample
+	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
+
+	if ((low & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	// dropout!
+		rt_printk
+			("comedi: A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
+			(low & 0xf),
+			devpriv->act_chanlist[devpriv->act_chanlist_pos]);
+		pcl818_ai_cancel(dev, s);
+		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		comedi_event(dev, s);
+		return IRQ_HANDLED;
+	}
+	if (s->async->cur_chan == 0) {
+		// rt_printk("E");
+		devpriv->ai_act_scan--;
+	}
+
+	if (!devpriv->neverending_ai) {
+		if (devpriv->ai_act_scan == 0) {	/* all data sampled */
+			pcl818_ai_cancel(dev, s);
+			s->async->events |= COMEDI_CB_EOA;
+		}
+	}
+	comedi_event(dev, s);
+	return IRQ_HANDLED;
+}
+
+/*
+==============================================================================
+   analog input dma mode 1 & 3, 818 cards
+*/
+static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
+{
+	comedi_device *dev = d;
+	comedi_subdevice *s = dev->subdevices + 0;
+	int i, len, bufptr;
+	unsigned long flags;
+	sampl_t *ptr;
+
+	disable_dma(devpriv->dma);
+	devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
+	if ((devpriv->dma_runs_to_end) > -1 || devpriv->neverending_ai) {	// switch dma bufs
+		set_dma_mode(devpriv->dma, DMA_MODE_READ);
+		flags = claim_dma_lock();
+		set_dma_addr(devpriv->dma,
+			devpriv->hwdmaptr[devpriv->next_dma_buf]);
+		if (devpriv->dma_runs_to_end || devpriv->neverending_ai) {
+			set_dma_count(devpriv->dma,
+				devpriv->hwdmasize[devpriv->next_dma_buf]);
+		} else {
+			set_dma_count(devpriv->dma, devpriv->last_dma_run);
+		}
+		release_dma_lock(flags);
+		enable_dma(devpriv->dma);
+	}
+	rt_printk("comedi: A/D mode1/3 IRQ \n");
+
+	devpriv->dma_runs_to_end--;
+	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
+	ptr = (sampl_t *) devpriv->dmabuf[1 - devpriv->next_dma_buf];
+
+	len = devpriv->hwdmasize[0] >> 1;
+	bufptr = 0;
+
+	for (i = 0; i < len; i++) {
+		if ((ptr[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	// dropout!
+			rt_printk
+				("comedi: A/D mode1/3 DMA - channel dropout %d(card)!=%d(chanlist) at %d !\n",
+				(ptr[bufptr] & 0xf),
+				devpriv->act_chanlist[devpriv->
+					act_chanlist_pos],
+				devpriv->act_chanlist_pos);
+			pcl818_ai_cancel(dev, s);
+			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+			comedi_event(dev, s);
+			return IRQ_HANDLED;
+		}
+
+		comedi_buf_put(s->async, ptr[bufptr++] >> 4);	// get one sample
+
+		devpriv->act_chanlist_pos++;
+		if (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len) {
+			devpriv->ai_act_scan--;
+			devpriv->act_chanlist_pos = 0;
+		}
+
+		if (!devpriv->neverending_ai)
+			if (devpriv->ai_act_scan == 0) {	/* all data sampled */
+				pcl818_ai_cancel(dev, s);
+				s->async->events |= COMEDI_CB_EOA;
+				comedi_event(dev, s);
+				// printk("done int ai13 dma\n");
+				return IRQ_HANDLED;
+			}
+	}
+
+	if (len > 0)
+		comedi_event(dev, s);
+	return IRQ_HANDLED;
+}
+
+#ifdef unused
+/*
+==============================================================================
+   analog input dma mode 1 & 3 over RTC, 818 cards
+*/
+static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
+{
+	comedi_device *dev = d;
+	comedi_subdevice *s = dev->subdevices + 0;
+	unsigned long tmp;
+	unsigned int top1, top2, i, bufptr;
+	long ofs_dats;
+	sampl_t *dmabuf = (sampl_t *) devpriv->dmabuf[0];
+
+	//outb(2,0x378);
+	switch (devpriv->ai_mode) {
+	case INT_TYPE_AI1_DMA_RTC:
+	case INT_TYPE_AI3_DMA_RTC:
+		tmp = (CMOS_READ(RTC_INTR_FLAGS) & 0xF0);
+		mod_timer(&devpriv->rtc_irq_timer,
+			jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100);
+
+		for (i = 0; i < 10; i++) {
+			top1 = get_dma_residue(devpriv->dma);
+			top2 = get_dma_residue(devpriv->dma);
+			if (top1 == top2)
+				break;
+		}
+
+		if (top1 != top2)
+			return IRQ_HANDLED;
+		top1 = devpriv->hwdmasize[0] - top1;	// where is now DMA in buffer
+		top1 >>= 1;
+		ofs_dats = top1 - devpriv->last_top_dma;	// new samples from last call
+		if (ofs_dats < 0)
+			ofs_dats = (devpriv->dmasamplsize) + ofs_dats;
+		if (!ofs_dats)
+			return IRQ_HANDLED;	// exit=no new samples from last call
+		// obsluz data
+		i = devpriv->last_top_dma - 1;
+		i &= (devpriv->dmasamplsize - 1);
+
+		if (dmabuf[i] != MAGIC_DMA_WORD) {	// DMA overflow!
+			comedi_error(dev, "A/D mode1/3 DMA buffer overflow!");
+			//rt_printk("I %d dmabuf[i] %d %d\n",i,dmabuf[i],devpriv->dmasamplsize);
+			pcl818_ai_cancel(dev, s);
+			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+			comedi_event(dev, s);
+			return IRQ_HANDLED;
+		}
+		//rt_printk("r %ld ",ofs_dats);
+
+		bufptr = devpriv->last_top_dma;
+
+		for (i = 0; i < ofs_dats; i++) {
+			if ((dmabuf[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	// dropout!
+				rt_printk
+					("comedi: A/D mode1/3 DMA - channel dropout %d!=%d !\n",
+					(dmabuf[bufptr] & 0xf),
+					devpriv->act_chanlist[devpriv->
+						act_chanlist_pos]);
+				pcl818_ai_cancel(dev, s);
+				s->async->events |=
+					COMEDI_CB_EOA | COMEDI_CB_ERROR;
+				comedi_event(dev, s);
+				return IRQ_HANDLED;
+			}
+
+			comedi_buf_put(s->async, dmabuf[bufptr++] >> 4);	// get one sample
+			bufptr &= (devpriv->dmasamplsize - 1);
+
+			if (s->async->cur_chan == 0) {
+				devpriv->ai_act_scan--;
+			}
+
+			if (!devpriv->neverending_ai)
+				if (devpriv->ai_act_scan == 0) {	/* all data sampled */
+					pcl818_ai_cancel(dev, s);
+					s->async->events |= COMEDI_CB_EOA;
+					comedi_event(dev, s);
+					//printk("done int ai13 dma\n");
+					return IRQ_HANDLED;
+				}
+		}
+
+		devpriv->last_top_dma = bufptr;
+		bufptr--;
+		bufptr &= (devpriv->dmasamplsize - 1);
+		dmabuf[bufptr] = MAGIC_DMA_WORD;
+		comedi_event(dev, s);
+		//outb(0,0x378);
+		return IRQ_HANDLED;
+	}
+
+	//outb(0,0x378);
+	return IRQ_HANDLED;
+}
+#endif
+
+/*
+==============================================================================
+   analog input interrupt mode 1 & 3, 818HD/HG cards
+*/
+static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
+{
+	comedi_device *dev = d;
+	comedi_subdevice *s = dev->subdevices + 0;
+	int i, len, lo;
+
+	outb(0, dev->iobase + PCL818_FI_INTCLR);	// clear fifo int request
+
+	lo = inb(dev->iobase + PCL818_FI_STATUS);
+
+	if (lo & 4) {
+		comedi_error(dev, "A/D mode1/3 FIFO overflow!");
+		pcl818_ai_cancel(dev, s);
+		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		comedi_event(dev, s);
+		return IRQ_HANDLED;
+	}
+
+	if (lo & 1) {
+		comedi_error(dev, "A/D mode1/3 FIFO interrupt without data!");
+		pcl818_ai_cancel(dev, s);
+		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		comedi_event(dev, s);
+		return IRQ_HANDLED;
+	}
+
+	if (lo & 2) {
+		len = 512;
+	} else {
+		len = 0;
+	}
+
+	for (i = 0; i < len; i++) {
+		lo = inb(dev->iobase + PCL818_FI_DATALO);
+		if ((lo & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	// dropout!
+			rt_printk
+				("comedi: A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
+				(lo & 0xf),
+				devpriv->act_chanlist[devpriv->
+					act_chanlist_pos]);
+			pcl818_ai_cancel(dev, s);
+			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+			comedi_event(dev, s);
+			return IRQ_HANDLED;
+		}
+
+		comedi_buf_put(s->async, (lo >> 4) | (inb(dev->iobase + PCL818_FI_DATAHI) << 4));	// get one sample
+
+		if (s->async->cur_chan == 0) {
+			devpriv->ai_act_scan--;
+		}
+
+		if (!devpriv->neverending_ai)
+			if (devpriv->ai_act_scan == 0) {	/* all data sampled */
+				pcl818_ai_cancel(dev, s);
+				s->async->events |= COMEDI_CB_EOA;
+				comedi_event(dev, s);
+				return IRQ_HANDLED;
+			}
+	}
+
+	if (len > 0)
+		comedi_event(dev, s);
+	return IRQ_HANDLED;
+}
+
+/*
+==============================================================================
+    INT procedure
+*/
+static irqreturn_t interrupt_pcl818(int irq, void *d PT_REGS_ARG)
+{
+	comedi_device *dev = d;
+
+	if (!dev->attached) {
+		comedi_error(dev, "premature interrupt");
+		return IRQ_HANDLED;
+	}
+	//rt_printk("I\n");
+
+	switch (devpriv->ai_mode) {
+	case INT_TYPE_AI1_DMA:
+	case INT_TYPE_AI3_DMA:
+		return interrupt_pcl818_ai_mode13_dma(irq, d);
+	case INT_TYPE_AI1_INT:
+	case INT_TYPE_AI3_INT:
+		return interrupt_pcl818_ai_mode13_int(irq, d);
+	case INT_TYPE_AI1_FIFO:
+	case INT_TYPE_AI3_FIFO:
+		return interrupt_pcl818_ai_mode13_fifo(irq, d);
+#ifdef PCL818_MODE13_AO
+	case INT_TYPE_AO1_INT:
+	case INT_TYPE_AO3_INT:
+		return interrupt_pcl818_ao_mode13_int(irq, d);
+#endif
+	default:
+		break;
+	}
+
+	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
+
+	if ((!dev->irq) || (!devpriv->irq_free) || (!devpriv->irq_blocked)
+		|| (!devpriv->ai_mode)) {
+		if (devpriv->irq_was_now_closed) {
+			if (devpriv->neverending_ai &&
+				(devpriv->ai_mode == INT_TYPE_AI1_DMA
+					|| devpriv->ai_mode ==
+					INT_TYPE_AI3_DMA)) {
+				/* we had neverending ai but ai_cancel() has been called
+				   the cleanup from ai_cancel() has been delayed until know
+				   because the card doesn't seem to like being reprogrammed
+				   while a DMA transfer is in progress
+				 */
+				comedi_subdevice *s = dev->subdevices + 0;
+				devpriv->ai_mode = devpriv->irq_was_now_closed;
+				devpriv->irq_was_now_closed = 0;
+				devpriv->neverending_ai = 0;
+				pcl818_ai_cancel(dev, s);
+			}
+			devpriv->irq_was_now_closed = 0;
+			return IRQ_HANDLED;
+		}
+		comedi_error(dev, "bad IRQ!");
+		return IRQ_NONE;
+	}
+
+	comedi_error(dev, "IRQ from unknow source!");
+	return IRQ_NONE;
+}
+
+/*
+==============================================================================
+   ANALOG INPUT MODE 1 or 3 DMA , 818 cards
+*/
+static void pcl818_ai_mode13dma_int(int mode, comedi_device * dev,
+	comedi_subdevice * s)
+{
+	unsigned int flags;
+	unsigned int bytes;
+
+	rt_printk("mode13dma_int, mode: %d\n", mode);
+	disable_dma(devpriv->dma);	// disable dma
+	bytes = devpriv->hwdmasize[0];
+	if (!devpriv->neverending_ai) {
+		bytes = devpriv->ai_n_chan * devpriv->ai_scans * sizeof(sampl_t);	// how many
+		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize[0];	// how many DMA pages we must fiil
+		devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];	//on last dma transfer must be moved
+		devpriv->dma_runs_to_end--;
+		if (devpriv->dma_runs_to_end >= 0)
+			bytes = devpriv->hwdmasize[0];
+	}
+
+	devpriv->next_dma_buf = 0;
+	set_dma_mode(devpriv->dma, DMA_MODE_READ);
+	flags = claim_dma_lock();
+	clear_dma_ff(devpriv->dma);
+	set_dma_addr(devpriv->dma, devpriv->hwdmaptr[0]);
+	set_dma_count(devpriv->dma, bytes);
+	release_dma_lock(flags);
+	enable_dma(devpriv->dma);
+
+	if (mode == 1) {
+		devpriv->ai_mode = INT_TYPE_AI1_DMA;
+		outb(0x87 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Pacer+IRQ+DMA */
+	} else {
+		devpriv->ai_mode = INT_TYPE_AI3_DMA;
+		outb(0x86 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Ext trig+IRQ+DMA */
+	};
+}
+
+#ifdef unused
+/*
+==============================================================================
+   ANALOG INPUT MODE 1 or 3 DMA rtc, 818 cards
+*/
+static void pcl818_ai_mode13dma_rtc(int mode, comedi_device * dev,
+	comedi_subdevice * s)
+{
+	unsigned int flags;
+	sampl_t *pole;
+
+	set_dma_mode(devpriv->dma, DMA_MODE_READ | DMA_AUTOINIT);
+	flags = claim_dma_lock();
+	clear_dma_ff(devpriv->dma);
+	set_dma_addr(devpriv->dma, devpriv->hwdmaptr[0]);
+	set_dma_count(devpriv->dma, devpriv->hwdmasize[0]);
+	release_dma_lock(flags);
+	enable_dma(devpriv->dma);
+	devpriv->last_top_dma = 0;	//devpriv->hwdmasize[0];
+	pole = (sampl_t *) devpriv->dmabuf[0];
+	devpriv->dmasamplsize = devpriv->hwdmasize[0] / 2;
+	pole[devpriv->dmasamplsize - 1] = MAGIC_DMA_WORD;
+#ifdef unused
+	devpriv->rtc_freq = rtc_setfreq_irq(2048);
+	devpriv->rtc_irq_timer.expires =
+		jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100;
+	devpriv->rtc_irq_timer.data = (unsigned long)dev;
+	devpriv->rtc_irq_timer.function = rtc_dropped_irq;
+
+	add_timer(&devpriv->rtc_irq_timer);
+#endif
+
+	if (mode == 1) {
+		devpriv->int818_mode = INT_TYPE_AI1_DMA_RTC;
+		outb(0x07 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Pacer+DMA */
+	} else {
+		devpriv->int818_mode = INT_TYPE_AI3_DMA_RTC;
+		outb(0x06 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Ext trig+DMA */
+	};
+}
+#endif
+
+/*
+==============================================================================
+   ANALOG INPUT MODE 1 or 3, 818 cards
+*/
+static int pcl818_ai_cmd_mode(int mode, comedi_device * dev,
+	comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	int divisor1, divisor2;
+	unsigned int seglen;
+
+	rt_printk("pcl818_ai_cmd_mode()\n");
+	if ((!dev->irq) && (!devpriv->dma_rtc)) {
+		comedi_error(dev, "IRQ not defined!");
+		return -EINVAL;
+	}
+
+	if (devpriv->irq_blocked)
+		return -EBUSY;
+
+	start_pacer(dev, -1, 0, 0);	// stop pacer
+
+	seglen = check_channel_list(dev, s, devpriv->ai_chanlist,
+		devpriv->ai_n_chan);
+	if (seglen < 1)
+		return -EINVAL;
+	setup_channel_list(dev, s, devpriv->ai_chanlist,
+		devpriv->ai_n_chan, seglen);
+
+	comedi_udelay(1);
+
+	devpriv->ai_act_scan = devpriv->ai_scans;
+	devpriv->ai_act_chan = 0;
+	devpriv->irq_blocked = 1;
+	devpriv->irq_was_now_closed = 0;
+	devpriv->neverending_ai = 0;
+	devpriv->act_chanlist_pos = 0;
+	devpriv->dma_runs_to_end = 0;
+
+	if ((devpriv->ai_scans == 0) || (devpriv->ai_scans == -1))
+		devpriv->neverending_ai = 1;	//well, user want neverending
+
+	if (mode == 1) {
+		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
+			&divisor2, &cmd->convert_arg, TRIG_ROUND_NEAREST);
+		if (divisor1 == 1) {	/* PCL718/818 crash if any divisor is set to 1 */
+			divisor1 = 2;
+			divisor2 /= 2;
+		}
+		if (divisor2 == 1) {
+			divisor2 = 2;
+			divisor1 /= 2;
+		}
+	}
+
+	outb(0, dev->iobase + PCL818_CNTENABLE);	/* enable pacer */
+
+	switch (devpriv->dma) {
+	case 1:		// DMA
+	case 3:
+		if (devpriv->dma_rtc == 0) {
+			pcl818_ai_mode13dma_int(mode, dev, s);
+		}
+#ifdef unused
+		else {
+			pcl818_ai_mode13dma_rtc(mode, dev, s);
+		}
+#else
+		else {
+			return -EINVAL;
+		}
+#endif
+		break;
+	case 0:		// IRQ
+		// rt_printk("IRQ\n");
+		if (mode == 1) {
+			devpriv->ai_mode = INT_TYPE_AI1_INT;
+			outb(0x83 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Pacer+IRQ */
+		} else {
+			devpriv->ai_mode = INT_TYPE_AI3_INT;
+			outb(0x82 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Ext trig+IRQ */
+		};
+		break;
+	case -1:		// FIFO
+		outb(1, dev->iobase + PCL818_FI_ENABLE);	// enable FIFO
+		if (mode == 1) {
+			devpriv->ai_mode = INT_TYPE_AI1_FIFO;
+			outb(0x03, dev->iobase + PCL818_CONTROL);	/* Pacer */
+		} else {
+			devpriv->ai_mode = INT_TYPE_AI3_FIFO;
+			outb(0x02, dev->iobase + PCL818_CONTROL);
+		};		/* Ext trig */
+		break;
+	}
+
+	start_pacer(dev, mode, divisor1, divisor2);
+
+#ifdef unused
+	switch (devpriv->ai_mode) {
+	case INT_TYPE_AI1_DMA_RTC:
+	case INT_TYPE_AI3_DMA_RTC:
+		set_rtc_irq_bit(1);	/* start RTC */
+		break;
+	}
+#endif
+	rt_printk("pcl818_ai_cmd_mode() end\n");
+	return 0;
+}
+
+#ifdef unused
+/*
+==============================================================================
+   ANALOG OUTPUT MODE 1 or 3, 818 cards
+*/
+#ifdef PCL818_MODE13_AO
+static int pcl818_ao_mode13(int mode, comedi_device * dev, comedi_subdevice * s,
+	comedi_trig * it)
+{
+	int divisor1, divisor2;
+
+	if (!dev->irq) {
+		comedi_error(dev, "IRQ not defined!");
+		return -EINVAL;
+	}
+
+	if (devpriv->irq_blocked)
+		return -EBUSY;
+
+	start_pacer(dev, -1, 0, 0);	// stop pacer
+
+	devpriv->int13_act_scan = it->n;
+	devpriv->int13_act_chan = 0;
+	devpriv->irq_blocked = 1;
+	devpriv->irq_was_now_closed = 0;
+	devpriv->neverending_ai = 0;
+	devpriv->act_chanlist_pos = 0;
+
+	if (mode == 1) {
+		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
+			&divisor2, &it->trigvar, TRIG_ROUND_NEAREST);
+		if (divisor1 == 1) {	/* PCL818 crash if any divisor is set to 1 */
+			divisor1 = 2;
+			divisor2 /= 2;
+		}
+		if (divisor2 == 1) {
+			divisor2 = 2;
+			divisor1 /= 2;
+		}
+	}
+
+	outb(0, dev->iobase + PCL818_CNTENABLE);	/* enable pacer */
+	if (mode == 1) {
+		devpriv->int818_mode = INT_TYPE_AO1_INT;
+		outb(0x83 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Pacer+IRQ */
+	} else {
+		devpriv->int818_mode = INT_TYPE_AO3_INT;
+		outb(0x82 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);	/* Ext trig+IRQ */
+	};
+
+	start_pacer(dev, mode, divisor1, divisor2);
+
+	return 0;
+}
+
+/*
+==============================================================================
+   ANALOG OUTPUT MODE 1, 818 cards
+*/
+static int pcl818_ao_mode1(comedi_device * dev, comedi_subdevice * s,
+	comedi_trig * it)
+{
+	return pcl818_ao_mode13(1, dev, s, it);
+}
+
+/*
+==============================================================================
+   ANALOG OUTPUT MODE 3, 818 cards
+*/
+static int pcl818_ao_mode3(comedi_device * dev, comedi_subdevice * s,
+	comedi_trig * it)
+{
+	return pcl818_ao_mode13(3, dev, s, it);
+}
+#endif
+#endif
+
+/*
+==============================================================================
+ Start/stop pacer onboard pacer
+*/
+static void start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
+	unsigned int divisor2)
+{
+	outb(0xb4, dev->iobase + PCL818_CTRCTL);
+	outb(0x74, dev->iobase + PCL818_CTRCTL);
+	comedi_udelay(1);
+
+	if (mode == 1) {
+		outb(divisor2 & 0xff, dev->iobase + PCL818_CTR2);
+		outb((divisor2 >> 8) & 0xff, dev->iobase + PCL818_CTR2);
+		outb(divisor1 & 0xff, dev->iobase + PCL818_CTR1);
+		outb((divisor1 >> 8) & 0xff, dev->iobase + PCL818_CTR1);
+	}
+}
+
+/*
+==============================================================================
+ Check if channel list from user is builded correctly
+ If it's ok, then program scan/gain logic
+*/
+static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
+	unsigned int *chanlist, unsigned int n_chan)
+{
+	unsigned int chansegment[16];
+	unsigned int i, nowmustbechan, seglen, segpos;
+
+	/* correct channel and range number check itself comedi/range.c */
+	if (n_chan < 1) {
+		comedi_error(dev, "range/channel list is empty!");
+		return 0;
+	}
+
+	if (n_chan > 1) {
+		// first channel is everytime ok
+		chansegment[0] = chanlist[0];
+		// build part of chanlist
+		for (i = 1, seglen = 1; i < n_chan; i++, seglen++) {
+			// rt_printk("%d. %d %d\n",i,CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i]));
+			// we detect loop, this must by finish
+			if (chanlist[0] == chanlist[i])
+				break;
+			nowmustbechan =
+				(CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
+			if (nowmustbechan != CR_CHAN(chanlist[i])) {	// channel list isn't continous :-(
+				rt_printk
+					("comedi%d: pcl818: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
+					dev->minor, i, CR_CHAN(chanlist[i]),
+					nowmustbechan, CR_CHAN(chanlist[0]));
+				return 0;
+			}
+			// well, this is next correct channel in list
+			chansegment[i] = chanlist[i];
+		}
+
+		// check whole chanlist
+		for (i = 0, segpos = 0; i < n_chan; i++) {
+			//rt_printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i]));
+			if (chanlist[i] != chansegment[i % seglen]) {
+				rt_printk
+					("comedi%d: pcl818: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
+					dev->minor, i, CR_CHAN(chansegment[i]),
+					CR_RANGE(chansegment[i]),
+					CR_AREF(chansegment[i]),
+					CR_CHAN(chanlist[i % seglen]),
+					CR_RANGE(chanlist[i % seglen]),
+					CR_AREF(chansegment[i % seglen]));
+				return 0;	// chan/gain list is strange
+			}
+		}
+	} else {
+		seglen = 1;
+	}
+	rt_printk("check_channel_list: seglen %d\n", seglen);
+	return seglen;
+}
+
+static void setup_channel_list(comedi_device * dev, comedi_subdevice * s,
+	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen)
+{
+	int i;
+
+	devpriv->act_chanlist_len = seglen;
+	devpriv->act_chanlist_pos = 0;
+
+	for (i = 0; i < seglen; i++) {	// store range list to card
+		devpriv->act_chanlist[i] = CR_CHAN(chanlist[i]);
+		outb(muxonechan[CR_CHAN(chanlist[i])], dev->iobase + PCL818_MUX);	/* select channel */
+		outb(CR_RANGE(chanlist[i]), dev->iobase + PCL818_RANGE);	/* select gain */
+	}
+
+	comedi_udelay(1);
+
+	/* select channel interval to scan */
+	outb(devpriv->act_chanlist[0] | (devpriv->act_chanlist[seglen -
+				1] << 4), dev->iobase + PCL818_MUX);
+}
+
+/*
+==============================================================================
+ Check if board is switched to SE (1) or DIFF(0) mode
+*/
+static int check_single_ended(unsigned int port)
+{
+	if (inb(port + PCL818_STATUS) & 0x20) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+/*
+==============================================================================
+*/
+static int ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp, divisor1, divisor2;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_FOLLOW;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_TIMER | TRIG_EXT;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err) {
+		return 1;
+	}
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	if (cmd->start_src != TRIG_NOW) {
+		cmd->start_src = TRIG_NOW;
+		err++;
+	}
+	if (cmd->scan_begin_src != TRIG_FOLLOW) {
+		cmd->scan_begin_src = TRIG_FOLLOW;
+		err++;
+	}
+	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
+		err++;
+
+	if (cmd->scan_end_src != TRIG_COUNT) {
+		cmd->scan_end_src = TRIG_COUNT;
+		err++;
+	}
+
+	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
+		err++;
+
+	if (err) {
+		return 2;
+	}
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	if (cmd->scan_begin_arg != 0) {
+		cmd->scan_begin_arg = 0;
+		err++;
+	}
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg < this_board->ns_min) {
+			cmd->convert_arg = this_board->ns_min;
+			err++;
+		}
+	} else {		/* TRIG_EXT */
+		if (cmd->convert_arg != 0) {
+			cmd->convert_arg = 0;
+			err++;
+		}
+	}
+
+	if (!cmd->chanlist_len) {
+		cmd->chanlist_len = 1;
+		err++;
+	}
+	if (cmd->chanlist_len > s->n_chan) {
+		cmd->chanlist_len = s->n_chan;
+		err++;
+	}
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_COUNT) {
+		if (!cmd->stop_arg) {
+			cmd->stop_arg = 1;
+			err++;
+		}
+	} else {		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err) {
+		return 3;
+	}
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		tmp = cmd->convert_arg;
+		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
+			&divisor2, &cmd->convert_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		if (cmd->convert_arg < this_board->ns_min)
+			cmd->convert_arg = this_board->ns_min;
+		if (tmp != cmd->convert_arg)
+			err++;
+	}
+
+	if (err) {
+		return 4;
+	}
+
+	/* step 5: complain about special chanlist considerations */
+
+	if (cmd->chanlist) {
+		if (!check_channel_list(dev, s, cmd->chanlist,
+				cmd->chanlist_len))
+			return 5;	// incorrect channels list
+	}
+
+	return 0;
+}
+
+/*
+==============================================================================
+*/
+static int ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	int retval;
+
+	rt_printk("pcl818_ai_cmd()\n");
+	devpriv->ai_n_chan = cmd->chanlist_len;
+	devpriv->ai_chanlist = cmd->chanlist;
+	devpriv->ai_flags = cmd->flags;
+	devpriv->ai_data_len = s->async->prealloc_bufsz;
+	devpriv->ai_data = s->async->prealloc_buf;
+	devpriv->ai_timer1 = 0;
+	devpriv->ai_timer2 = 0;
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		devpriv->ai_scans = cmd->stop_arg;
+	} else {
+		devpriv->ai_scans = 0;
+	}
+
+	if (cmd->scan_begin_src == TRIG_FOLLOW) {	// mode 1, 3
+		if (cmd->convert_src == TRIG_TIMER) {	// mode 1
+			devpriv->ai_timer1 = cmd->convert_arg;
+			retval = pcl818_ai_cmd_mode(1, dev, s);
+			rt_printk("pcl818_ai_cmd() end\n");
+			return retval;
+		}
+		if (cmd->convert_src == TRIG_EXT) {	// mode 3
+			return pcl818_ai_cmd_mode(3, dev, s);
+		}
+	}
+
+	return -1;
+}
+
+/*
+==============================================================================
+ cancel any mode 1-4 AI
+*/
+static int pcl818_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	if (devpriv->irq_blocked > 0) {
+		rt_printk("pcl818_ai_cancel()\n");
+		devpriv->irq_was_now_closed = devpriv->ai_mode;
+		devpriv->ai_mode = 0;
+
+		switch (devpriv->irq_was_now_closed) {
+#ifdef unused
+		case INT_TYPE_AI1_DMA_RTC:
+		case INT_TYPE_AI3_DMA_RTC:
+			set_rtc_irq_bit(0);	// stop RTC
+			del_timer(&devpriv->rtc_irq_timer);
+#endif
+		case INT_TYPE_AI1_DMA:
+		case INT_TYPE_AI3_DMA:
+			if (devpriv->neverending_ai) {
+				/* wait for running dma transfer to end, do cleanup in interrupt */
+				goto end;
+			}
+			disable_dma(devpriv->dma);
+		case INT_TYPE_AI1_INT:
+		case INT_TYPE_AI3_INT:
+		case INT_TYPE_AI1_FIFO:
+		case INT_TYPE_AI3_FIFO:
+#ifdef PCL818_MODE13_AO
+		case INT_TYPE_AO1_INT:
+		case INT_TYPE_AO3_INT:
+#endif
+			outb(inb(dev->iobase + PCL818_CONTROL) & 0x73, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
+			comedi_udelay(1);
+			start_pacer(dev, -1, 0, 0);
+			outb(0, dev->iobase + PCL818_AD_LO);
+			inb(dev->iobase + PCL818_AD_LO);
+			inb(dev->iobase + PCL818_AD_HI);
+			outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
+			outb(0, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
+			if (devpriv->usefifo) {	// FIFO shutdown
+				outb(0, dev->iobase + PCL818_FI_INTCLR);
+				outb(0, dev->iobase + PCL818_FI_FLUSH);
+				outb(0, dev->iobase + PCL818_FI_ENABLE);
+			}
+			devpriv->irq_blocked = 0;
+			devpriv->last_int_sub = s;
+			devpriv->neverending_ai = 0;
+			break;
+		}
+	}
+
+      end:
+	rt_printk("pcl818_ai_cancel() end\n");
+	return 0;
+}
+
+/*
+==============================================================================
+ chech for PCL818
+*/
+static int pcl818_check(unsigned long iobase)
+{
+	outb(0x00, iobase + PCL818_MUX);
+	comedi_udelay(1);
+	if (inb(iobase + PCL818_MUX) != 0x00)
+		return 1;	//there isn't card
+	outb(0x55, iobase + PCL818_MUX);
+	comedi_udelay(1);
+	if (inb(iobase + PCL818_MUX) != 0x55)
+		return 1;	//there isn't card
+	outb(0x00, iobase + PCL818_MUX);
+	comedi_udelay(1);
+	outb(0x18, iobase + PCL818_CONTROL);
+	comedi_udelay(1);
+	if (inb(iobase + PCL818_CONTROL) != 0x18)
+		return 1;	//there isn't card
+	return 0;		// ok, card exist
+}
+
+/*
+==============================================================================
+ reset whole PCL-818 cards
+*/
+static void pcl818_reset(comedi_device * dev)
+{
+	if (devpriv->usefifo) {	// FIFO shutdown
+		outb(0, dev->iobase + PCL818_FI_INTCLR);
+		outb(0, dev->iobase + PCL818_FI_FLUSH);
+		outb(0, dev->iobase + PCL818_FI_ENABLE);
+	}
+	outb(0, dev->iobase + PCL818_DA_LO);	// DAC=0V
+	outb(0, dev->iobase + PCL818_DA_HI);
+	comedi_udelay(1);
+	outb(0, dev->iobase + PCL818_DO_HI);	// DO=$0000
+	outb(0, dev->iobase + PCL818_DO_LO);
+	comedi_udelay(1);
+	outb(0, dev->iobase + PCL818_CONTROL);
+	outb(0, dev->iobase + PCL818_CNTENABLE);
+	outb(0, dev->iobase + PCL818_MUX);
+	outb(0, dev->iobase + PCL818_CLRINT);
+	outb(0xb0, dev->iobase + PCL818_CTRCTL);	/* Stop pacer */
+	outb(0x70, dev->iobase + PCL818_CTRCTL);
+	outb(0x30, dev->iobase + PCL818_CTRCTL);
+	if (this_board->is_818) {
+		outb(0, dev->iobase + PCL818_RANGE);
+	} else {
+		outb(0, dev->iobase + PCL718_DA2_LO);
+		outb(0, dev->iobase + PCL718_DA2_HI);
+	}
+}
+
+#ifdef unused
+/*
+==============================================================================
+  Enable(1)/disable(0) periodic interrupts from RTC
+*/
+static int set_rtc_irq_bit(unsigned char bit)
+{
+	unsigned char val;
+	unsigned long flags;
+
+	if (bit == 1) {
+		RTC_timer_lock++;
+		if (RTC_timer_lock > 1)
+			return 0;
+	} else {
+		RTC_timer_lock--;
+		if (RTC_timer_lock < 0)
+			RTC_timer_lock = 0;
+		if (RTC_timer_lock > 0)
+			return 0;
+	}
+
+	save_flags(flags);
+	cli();
+	val = CMOS_READ(RTC_CONTROL);
+	if (bit) {
+		val |= RTC_PIE;
+	} else {
+		val &= ~RTC_PIE;
+	}
+	CMOS_WRITE(val, RTC_CONTROL);
+	CMOS_READ(RTC_INTR_FLAGS);
+	restore_flags(flags);
+	return 0;
+}
+
+/*
+==============================================================================
+  Restart RTC if something stop it (xntpd every 11 mins or large IDE transfers)
+*/
+static void rtc_dropped_irq(unsigned long data)
+{
+	comedi_device *dev = (void *)data;
+	unsigned long flags, tmp;
+
+	switch (devpriv->int818_mode) {
+	case INT_TYPE_AI1_DMA_RTC:
+	case INT_TYPE_AI3_DMA_RTC:
+		mod_timer(&devpriv->rtc_irq_timer,
+			jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100);
+		save_flags(flags);
+		cli();
+		tmp = (CMOS_READ(RTC_INTR_FLAGS) & 0xF0);	/* restart */
+		restore_flags(flags);
+		break;
+	};
+}
+
+/*
+==============================================================================
+  Set frequency of interrupts from RTC
+*/
+static int rtc_setfreq_irq(int freq)
+{
+	int tmp = 0;
+	int rtc_freq;
+	unsigned char val;
+	unsigned long flags;
+
+	if (freq < 2)
+		freq = 2;
+	if (freq > 8192)
+		freq = 8192;
+
+	while (freq > (1 << tmp))
+		tmp++;
+
+	rtc_freq = 1 << tmp;
+
+	save_flags(flags);
+	cli();
+	val = CMOS_READ(RTC_FREQ_SELECT) & 0xf0;
+	val |= (16 - tmp);
+	CMOS_WRITE(val, RTC_FREQ_SELECT);
+	restore_flags(flags);
+	return rtc_freq;
+}
+#endif
+
+/*
+==============================================================================
+  Free any resources that we have claimed
+*/
+static void free_resources(comedi_device * dev)
+{
+	//rt_printk("free_resource()\n");
+	if (dev->private) {
+		pcl818_ai_cancel(dev, devpriv->sub_ai);
+		pcl818_reset(dev);
+		if (devpriv->dma)
+			free_dma(devpriv->dma);
+		if (devpriv->dmabuf[0])
+			free_pages(devpriv->dmabuf[0], devpriv->dmapages[0]);
+		if (devpriv->dmabuf[1])
+			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
+#ifdef unused
+		if (devpriv->rtc_irq)
+			comedi_free_irq(devpriv->rtc_irq, dev);
+		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
+			if (devpriv->rtc_iobase)
+				release_region(devpriv->rtc_iobase,
+					devpriv->rtc_iosize);
+		}
+		if (devpriv->dma_rtc)
+			RTC_lock--;
+#endif
+	}
+
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	if (dev->iobase)
+		release_region(dev->iobase, devpriv->io_range);
+	//rt_printk("free_resource() end\n");
+}
+
+/*
+==============================================================================
+
+   Initialization
+
+*/
+static int pcl818_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	int ret;
+	unsigned long iobase;
+	unsigned int irq, dma;
+	unsigned long pages;
+	comedi_subdevice *s;
+
+	if ((ret = alloc_private(dev, sizeof(pcl818_private))) < 0)
+		return ret;	/* Can't alloc mem */
+
+	/* claim our I/O space */
+	iobase = it->options[0];
+	printk("comedi%d: pcl818:  board=%s, ioport=0x%03lx",
+		dev->minor, this_board->name, iobase);
+	devpriv->io_range = this_board->io_range;
+	if ((this_board->fifo) && (it->options[2] == -1)) {	// we've board with FIFO and we want to use FIFO
+		devpriv->io_range = PCLx1xFIFO_RANGE;
+		devpriv->usefifo = 1;
+	}
+	if (!request_region(iobase, devpriv->io_range, "pcl818")) {
+		rt_printk("I/O port conflict\n");
+		return -EIO;
+	}
+
+	dev->iobase = iobase;
+
+	if (pcl818_check(iobase)) {
+		rt_printk(", I can't detect board. FAIL!\n");
+		return -EIO;
+	}
+
+	/* set up some name stuff */
+	dev->board_name = this_board->name;
+	/* grab our IRQ */
+	irq = 0;
+	if (this_board->IRQbits != 0) {	/* board support IRQ */
+		irq = it->options[1];
+		if (irq) {	/* we want to use IRQ */
+			if (((1 << irq) & this_board->IRQbits) == 0) {
+				rt_printk
+					(", IRQ %u is out of allowed range, DISABLING IT",
+					irq);
+				irq = 0;	/* Bad IRQ */
+			} else {
+				if (comedi_request_irq(irq, interrupt_pcl818, 0,
+						"pcl818", dev)) {
+					rt_printk
+						(", unable to allocate IRQ %u, DISABLING IT",
+						irq);
+					irq = 0;	/* Can't use IRQ */
+				} else {
+					rt_printk(", irq=%u", irq);
+				}
+			}
+		}
+	}
+
+	dev->irq = irq;
+	if (irq) {
+		devpriv->irq_free = 1;
+	} /* 1=we have allocated irq */
+	else {
+		devpriv->irq_free = 0;
+	}
+	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
+	devpriv->ai_mode = 0;	/* mode of irq */
+
+#ifdef unused
+	/* grab RTC for DMA operations */
+	devpriv->dma_rtc = 0;
+	if (it->options[2] > 0) {	// we want to use DMA
+		if (RTC_lock == 0) {
+			if (!request_region(RTC_PORT(0), RTC_IO_EXTENT,
+					"pcl818 (RTC)"))
+				goto no_rtc;
+		}
+		devpriv->rtc_iobase = RTC_PORT(0);
+		devpriv->rtc_iosize = RTC_IO_EXTENT;
+		RTC_lock++;
+		if (!comedi_request_irq(RTC_IRQ,
+				interrupt_pcl818_ai_mode13_dma_rtc, 0,
+				"pcl818 DMA (RTC)", dev)) {
+			devpriv->dma_rtc = 1;
+			devpriv->rtc_irq = RTC_IRQ;
+			rt_printk(", dma_irq=%u", devpriv->rtc_irq);
+		} else {
+			RTC_lock--;
+			if (RTC_lock == 0) {
+				if (devpriv->rtc_iobase)
+					release_region(devpriv->rtc_iobase,
+						devpriv->rtc_iosize);
+			}
+			devpriv->rtc_iobase = 0;
+			devpriv->rtc_iosize = 0;
+		}
+	}
+
+      no_rtc:
+#endif
+	/* grab our DMA */
+	dma = 0;
+	devpriv->dma = dma;
+	if ((devpriv->irq_free == 0) && (devpriv->dma_rtc == 0))
+		goto no_dma;	/* if we haven't IRQ, we can't use DMA */
+	if (this_board->DMAbits != 0) {	/* board support DMA */
+		dma = it->options[2];
+		if (dma < 1)
+			goto no_dma;	/* DMA disabled */
+		if (((1 << dma) & this_board->DMAbits) == 0) {
+			rt_printk(", DMA is out of allowed range, FAIL!\n");
+			return -EINVAL;	/* Bad DMA */
+		}
+		ret = request_dma(dma, "pcl818");
+		if (ret) {
+			rt_printk(", unable to allocate DMA %u, FAIL!\n", dma);
+			return -EBUSY;	/* DMA isn't free */
+		}
+		devpriv->dma = dma;
+		rt_printk(", dma=%u", dma);
+		pages = 2;	/* we need 16KB */
+		devpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);
+		if (!devpriv->dmabuf[0]) {
+			rt_printk(", unable to allocate DMA buffer, FAIL!\n");
+			/* maybe experiment with try_to_free_pages() will help .... */
+			return -EBUSY;	/* no buffer :-( */
+		}
+		devpriv->dmapages[0] = pages;
+		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
+		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
+		//rt_printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE);
+		if (devpriv->dma_rtc == 0) {	// we must do duble buff :-(
+			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
+			if (!devpriv->dmabuf[1]) {
+				rt_printk
+					(", unable to allocate DMA buffer, FAIL!\n");
+				return -EBUSY;
+			}
+			devpriv->dmapages[1] = pages;
+			devpriv->hwdmaptr[1] =
+				virt_to_bus((void *)devpriv->dmabuf[1]);
+			devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
+		}
+	}
+
+      no_dma:
+
+	if ((ret = alloc_subdevices(dev, 4)) < 0)
+		return ret;
+
+	s = dev->subdevices + 0;
+	if (!this_board->n_aichan_se) {
+		s->type = COMEDI_SUBD_UNUSED;
+	} else {
+		s->type = COMEDI_SUBD_AI;
+		devpriv->sub_ai = s;
+		s->subdev_flags = SDF_READABLE;
+		if (check_single_ended(dev->iobase)) {
+			s->n_chan = this_board->n_aichan_se;
+			s->subdev_flags |= SDF_COMMON | SDF_GROUND;
+			printk(", %dchans S.E. DAC", s->n_chan);
+		} else {
+			s->n_chan = this_board->n_aichan_diff;
+			s->subdev_flags |= SDF_DIFF;
+			printk(", %dchans DIFF DAC", s->n_chan);
+		}
+		s->maxdata = this_board->ai_maxdata;
+		s->len_chanlist = s->n_chan;
+		s->range_table = this_board->ai_range_type;
+		s->cancel = pcl818_ai_cancel;
+		s->insn_read = pcl818_ai_insn_read;
+		if ((irq) || (devpriv->dma_rtc)) {
+			dev->read_subdev = s;
+			s->subdev_flags |= SDF_CMD_READ;
+			s->do_cmdtest = ai_cmdtest;
+			s->do_cmd = ai_cmd;
+		}
+		if (this_board->is_818) {
+			if ((it->options[4] == 1) || (it->options[4] == 10))
+				s->range_table = &range_pcl818l_h_ai;	// secondary range list jumper selectable
+		} else {
+			switch (it->options[4]) {
+			case 0:
+				s->range_table = &range_bipolar10;
+				break;
+			case 1:
+				s->range_table = &range_bipolar5;
+				break;
+			case 2:
+				s->range_table = &range_bipolar2_5;
+				break;
+			case 3:
+				s->range_table = &range718_bipolar1;
+				break;
+			case 4:
+				s->range_table = &range718_bipolar0_5;
+				break;
+			case 6:
+				s->range_table = &range_unipolar10;
+				break;
+			case 7:
+				s->range_table = &range_unipolar5;
+				break;
+			case 8:
+				s->range_table = &range718_unipolar2;
+				break;
+			case 9:
+				s->range_table = &range718_unipolar1;
+				break;
+			default:
+				s->range_table = &range_unknown;
+				break;
+			}
+		}
+	}
+
+	s = dev->subdevices + 1;
+	if (!this_board->n_aochan) {
+		s->type = COMEDI_SUBD_UNUSED;
+	} else {
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
+		s->n_chan = this_board->n_aochan;
+		s->maxdata = this_board->ao_maxdata;
+		s->len_chanlist = this_board->n_aochan;
+		s->range_table = this_board->ao_range_type;
+		s->insn_read = pcl818_ao_insn_read;
+		s->insn_write = pcl818_ao_insn_write;
+#ifdef unused
+#ifdef PCL818_MODE13_AO
+		if (irq) {
+			s->trig[1] = pcl818_ao_mode1;
+			s->trig[3] = pcl818_ao_mode3;
+		}
+#endif
+#endif
+		if (this_board->is_818) {
+			if ((it->options[4] == 1) || (it->options[4] == 10))
+				s->range_table = &range_unipolar10;
+			if (it->options[4] == 2)
+				s->range_table = &range_unknown;
+		} else {
+			if ((it->options[5] == 1) || (it->options[5] == 10))
+				s->range_table = &range_unipolar10;
+			if (it->options[5] == 2)
+				s->range_table = &range_unknown;
+		}
+	}
+
+	s = dev->subdevices + 2;
+	if (!this_board->n_dichan) {
+		s->type = COMEDI_SUBD_UNUSED;
+	} else {
+		s->type = COMEDI_SUBD_DI;
+		s->subdev_flags = SDF_READABLE;
+		s->n_chan = this_board->n_dichan;
+		s->maxdata = 1;
+		s->len_chanlist = this_board->n_dichan;
+		s->range_table = &range_digital;
+		s->insn_bits = pcl818_di_insn_bits;
+	}
+
+	s = dev->subdevices + 3;
+	if (!this_board->n_dochan) {
+		s->type = COMEDI_SUBD_UNUSED;
+	} else {
+		s->type = COMEDI_SUBD_DO;
+		s->subdev_flags = SDF_WRITABLE;
+		s->n_chan = this_board->n_dochan;
+		s->maxdata = 1;
+		s->len_chanlist = this_board->n_dochan;
+		s->range_table = &range_digital;
+		s->insn_bits = pcl818_do_insn_bits;
+	}
+
+	/* select 1/10MHz oscilator */
+	if ((it->options[3] == 0) || (it->options[3] == 10)) {
+		devpriv->i8253_osc_base = 100;
+	} else {
+		devpriv->i8253_osc_base = 1000;
+	}
+
+	/* max sampling speed */
+	devpriv->ns_min = this_board->ns_min;
+
+	if (!this_board->is_818) {
+		if ((it->options[6] == 1) || (it->options[6] == 100))
+			devpriv->ns_min = 10000;	/* extended PCL718 to 100kHz DAC */
+	}
+
+	pcl818_reset(dev);
+
+	rt_printk("\n");
+
+	return 0;
+}
+
+/*
+==============================================================================
+  Removes device
+ */
+static int pcl818_detach(comedi_device * dev)
+{
+	//  rt_printk("comedi%d: pcl818: remove\n", dev->minor);
+	free_resources(dev);
+	return 0;
+}
