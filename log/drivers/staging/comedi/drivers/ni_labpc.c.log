commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 3b2782cccf12..c6cf37ccbc92 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -3,16 +3,6 @@
  * comedi/drivers/ni_labpc.c
  * Driver for National Instruments Lab-PC series boards and compatibles
  * Copyright (C) 2001-2003 Frank Mori Hess <fmhess@users.sourceforge.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 51e5e942b442..3b2782cccf12 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * comedi/drivers/ni_labpc.c
  * Driver for National Instruments Lab-PC series boards and compatibles

commit c0cfeca1a80efbb7691961d4ac31af30c559f976
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 14:58:02 2015 -0700

    staging: comedi: ni_labpc_common: convert driver to use the comedi_8254 module
    
    This driver uses an 8254 timer to generate the pacer clock used for analog
    input data conversion. Convert it to use the comedi_8254 module to provide
    support for the 8254 timer.
    
    The hardware actually has two 8254 devices. Timer B0 is the master for timed
    conversions, timer B1 sets the scan pacing, and tmer A0 sets the conversion
    pacing.
    
    For the conversion, dev->pacer is used for the "B" timers and a new private
    data member, dev->counter, is used for the "A" timers. All the divisor values
    are stored in the dev->pacer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index a916047791b8..51e5e942b442 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -105,6 +105,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 static void labpc_detach(struct comedi_device *dev)
 {
 	labpc_free_dma_chan(dev);
+	labpc_common_detach(dev);
 	comedi_legacy_detach(dev);
 }
 

commit aae59483bce95c3fffd4fa66d5360712f372ba1a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 21 15:11:46 2015 -0700

    staging: comedi: ni_labpc: remove unnecessary private data validation
    
    The labpc_free_dma_chan() function validates the private data. Remove the
    unnecessary validation in labpc_datach().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index e7b25e8a1467..a916047791b8 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -104,11 +104,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void labpc_detach(struct comedi_device *dev)
 {
-	struct labpc_private *devpriv = dev->private;
-
-	if (devpriv)
-		labpc_free_dma_chan(dev);
-
+	labpc_free_dma_chan(dev);
 	comedi_legacy_detach(dev);
 }
 

commit 83d682bda16b515c61a99ff830964c1461b837a2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 21 15:11:44 2015 -0700

    staging: comedi: ni_labpc_common: move comedi_alloc_devpriv() to common code
    
    The ni_labpc_common module is used by the ni_labpc, ni_labpc_pci, and ni_labpc_cs
    drivers to provide the common code support. Those drivers currently all call
    comedi_alloc_devpriv() to allocate the private data before calling the common
    attach function.
    
    For aesthetics, move the private data allocation into the common code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 59da4047022c..e7b25e8a1467 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -84,15 +84,10 @@ static const struct labpc_boardinfo labpc_boards[] = {
 
 static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	struct labpc_private *devpriv;
 	unsigned int irq = it->options[1];
 	unsigned int dma_chan = it->options[2];
 	int ret;
 
-	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
-	if (!devpriv)
-		return -ENOMEM;
-
 	ret = comedi_request_region(dev, it->options[0], 0x20);
 	if (ret)
 		return ret;

commit d49ebefeeb165873c1b06b9869498bc32a2699dd
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 5 17:54:55 2015 +0000

    staging: comedi: ni_labpc: rewrite "Devices:" line
    
    Rewrite the "Devices:" line in the comedi "driver" comment to conform to
    the usual comedi format for this line.  The line should be a
    comma-separated list where the first item is in the following format:
    
      [Manufacturer] BOARD-NAME (comedi-board-name)
    
    The "[Manufacturer]" and/or "(comedi-board-name)" parts may be omitted
    from following items, in which case the parts from the preceding item
    are used.  The "Devices:" line may be continued continued over several
    lines by using one or more spaces at the start of each continuation line
    (not counting the space after the "*" in the block comment).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 1fbfdb4c80c0..59da4047022c 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -17,9 +17,8 @@
 /*
  * Driver: ni_labpc
  * Description: National Instruments Lab-PC (& compatibles)
- * Devices: (National Instruments) Lab-PC-1200 [lab-pc-1200]
- *	    (National Instruments) Lab-PC-1200AI [lab-pc-1200ai]
- *	    (National Instruments) Lab-PC+ [lab-pc+]
+ * Devices: [National Instruments] Lab-PC-1200 (lab-pc-1200),
+ *   Lab-PC-1200AI (lab-pc-1200ai), Lab-PC+ (lab-pc+)
  * Author: Frank Mori Hess <fmhess@users.sourceforge.net>
  * Status: works
  *

commit 1b41976933378192871629ba8afa37cfa1003f85
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Aug 19 16:06:33 2014 +0100

    staging: comedi: ni_labpc: split common code to ni_labpc_common
    
    The "ni_labpc" module is a Comedi driver for the National Instruments
    Lab-PC series of ISA data acquistion boards, and also provides common
    code for the "ni_labpc_pci" and "ni_labpci_cs" modules (for PCI boards
    and PCMCIA cards).
    
    Split out the common code into a new module "ni_labpc_common", leaving
    the driver for the ISA boards in the existing "ni_labpc" module.  This
    removes the C preprocessor conditional directives from the resulting
    ".c" files (although they remain in the included header file
    "ni_labpc_isadma.h").
    
    Unneccessary `#include` directives have been removed from the resulting
    ".c" files.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index ccf5ce800697..1fbfdb4c80c0 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -58,99 +58,12 @@
  */
 
 #include <linux/module.h>
-#include <linux/interrupt.h>
-#include <linux/slab.h>
-#include <linux/io.h>
-#include <linux/delay.h>
 
 #include "../comedidev.h"
 
-#include "8253.h"
-#include "8255.h"
-#include "comedi_fc.h"
 #include "ni_labpc.h"
-#include "ni_labpc_regs.h"
 #include "ni_labpc_isadma.h"
 
-enum scan_mode {
-	MODE_SINGLE_CHAN,
-	MODE_SINGLE_CHAN_INTERVAL,
-	MODE_MULT_CHAN_UP,
-	MODE_MULT_CHAN_DOWN,
-};
-
-static const struct comedi_lrange range_labpc_plus_ai = {
-	16, {
-		BIP_RANGE(5),
-		BIP_RANGE(4),
-		BIP_RANGE(2.5),
-		BIP_RANGE(1),
-		BIP_RANGE(0.5),
-		BIP_RANGE(0.25),
-		BIP_RANGE(0.1),
-		BIP_RANGE(0.05),
-		UNI_RANGE(10),
-		UNI_RANGE(8),
-		UNI_RANGE(5),
-		UNI_RANGE(2),
-		UNI_RANGE(1),
-		UNI_RANGE(0.5),
-		UNI_RANGE(0.2),
-		UNI_RANGE(0.1)
-	}
-};
-
-static const struct comedi_lrange range_labpc_1200_ai = {
-	14, {
-		BIP_RANGE(5),
-		BIP_RANGE(2.5),
-		BIP_RANGE(1),
-		BIP_RANGE(0.5),
-		BIP_RANGE(0.25),
-		BIP_RANGE(0.1),
-		BIP_RANGE(0.05),
-		UNI_RANGE(10),
-		UNI_RANGE(5),
-		UNI_RANGE(2),
-		UNI_RANGE(1),
-		UNI_RANGE(0.5),
-		UNI_RANGE(0.2),
-		UNI_RANGE(0.1)
-	}
-};
-
-static const struct comedi_lrange range_labpc_ao = {
-	2, {
-		BIP_RANGE(5),
-		UNI_RANGE(10)
-	}
-};
-
-/* functions that do inb/outb and readb/writeb so we can use
- * function pointers to decide which to use */
-static unsigned int labpc_inb(struct comedi_device *dev, unsigned long reg)
-{
-	return inb(dev->iobase + reg);
-}
-
-static void labpc_outb(struct comedi_device *dev,
-		       unsigned int byte, unsigned long reg)
-{
-	outb(byte, dev->iobase + reg);
-}
-
-static unsigned int labpc_readb(struct comedi_device *dev, unsigned long reg)
-{
-	return readb(dev->mmio + reg);
-}
-
-static void labpc_writeb(struct comedi_device *dev,
-			 unsigned int byte, unsigned long reg)
-{
-	writeb(byte, dev->mmio + reg);
-}
-
-#if IS_ENABLED(CONFIG_COMEDI_NI_LABPC_ISA)
 static const struct labpc_boardinfo labpc_boards[] = {
 	{
 		.name			= "lab-pc-1200",
@@ -169,1272 +82,7 @@ static const struct labpc_boardinfo labpc_boards[] = {
 		.has_ao			= 1,
 	},
 };
-#endif
-
-static void labpc_counter_load(struct comedi_device *dev,
-			       unsigned long reg,
-			       unsigned int counter_number,
-			       unsigned int count,
-			       unsigned int mode)
-{
-	if (dev->mmio) {
-		i8254_mm_set_mode(dev->mmio + reg, 0, counter_number, mode);
-		i8254_mm_write(dev->mmio + reg, 0, counter_number, count);
-	} else {
-		i8254_set_mode(dev->iobase + reg, 0, counter_number, mode);
-		i8254_write(dev->iobase + reg, 0, counter_number, count);
-	}
-}
-
-static void labpc_counter_set_mode(struct comedi_device *dev,
-				   unsigned long reg,
-				   unsigned int counter_number,
-				   unsigned int mode)
-{
-	if (dev->mmio)
-		i8254_mm_set_mode(dev->mmio + reg, 0, counter_number, mode);
-	else
-		i8254_set_mode(dev->iobase + reg, 0, counter_number, mode);
-}
-
-static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	struct labpc_private *devpriv = dev->private;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->cmd2 &= ~(CMD2_SWTRIG | CMD2_HWTRIG | CMD2_PRETRIG);
-	devpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	devpriv->cmd3 = 0;
-	devpriv->write_byte(dev, devpriv->cmd3, CMD3_REG);
-
-	return 0;
-}
-
-static void labpc_ai_set_chan_and_gain(struct comedi_device *dev,
-				       enum scan_mode mode,
-				       unsigned int chan,
-				       unsigned int range,
-				       unsigned int aref)
-{
-	const struct labpc_boardinfo *board = comedi_board(dev);
-	struct labpc_private *devpriv = dev->private;
-
-	if (board->is_labpc1200) {
-		/*
-		 * The LabPC-1200 boards do not have a gain
-		 * of '0x10'. Skip the range values that would
-		 * result in this gain.
-		 */
-		range += (range > 0) + (range > 7);
-	}
-
-	/* munge channel bits for differential/scan disabled mode */
-	if ((mode == MODE_SINGLE_CHAN || mode == MODE_SINGLE_CHAN_INTERVAL) &&
-	    aref == AREF_DIFF)
-		chan *= 2;
-	devpriv->cmd1 = CMD1_MA(chan);
-	devpriv->cmd1 |= CMD1_GAIN(range);
-
-	devpriv->write_byte(dev, devpriv->cmd1, CMD1_REG);
-}
-
-static void labpc_setup_cmd6_reg(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 enum scan_mode mode,
-				 enum transfer_type xfer,
-				 unsigned int range,
-				 unsigned int aref,
-				 bool ena_intr)
-{
-	const struct labpc_boardinfo *board = comedi_board(dev);
-	struct labpc_private *devpriv = dev->private;
-
-	if (!board->is_labpc1200)
-		return;
-
-	/* reference inputs to ground or common? */
-	if (aref != AREF_GROUND)
-		devpriv->cmd6 |= CMD6_NRSE;
-	else
-		devpriv->cmd6 &= ~CMD6_NRSE;
-
-	/* bipolar or unipolar range? */
-	if (comedi_range_is_unipolar(s, range))
-		devpriv->cmd6 |= CMD6_ADCUNI;
-	else
-		devpriv->cmd6 &= ~CMD6_ADCUNI;
-
-	/*  interrupt on fifo half full? */
-	if (xfer == fifo_half_full_transfer)
-		devpriv->cmd6 |= CMD6_HFINTEN;
-	else
-		devpriv->cmd6 &= ~CMD6_HFINTEN;
-
-	/* enable interrupt on counter a1 terminal count? */
-	if (ena_intr)
-		devpriv->cmd6 |= CMD6_DQINTEN;
-	else
-		devpriv->cmd6 &= ~CMD6_DQINTEN;
-
-	/* are we scanning up or down through channels? */
-	if (mode == MODE_MULT_CHAN_UP)
-		devpriv->cmd6 |= CMD6_SCANUP;
-	else
-		devpriv->cmd6 &= ~CMD6_SCANUP;
-
-	devpriv->write_byte(dev, devpriv->cmd6, CMD6_REG);
-}
-
-static unsigned int labpc_read_adc_fifo(struct comedi_device *dev)
-{
-	struct labpc_private *devpriv = dev->private;
-	unsigned int lsb = devpriv->read_byte(dev, ADC_FIFO_REG);
-	unsigned int msb = devpriv->read_byte(dev, ADC_FIFO_REG);
-
-	return (msb << 8) | lsb;
-}
-
-static void labpc_clear_adc_fifo(struct comedi_device *dev)
-{
-	struct labpc_private *devpriv = dev->private;
-
-	devpriv->write_byte(dev, 0x1, ADC_FIFO_CLEAR_REG);
-	labpc_read_adc_fifo(dev);
-}
-
-static int labpc_ai_eoc(struct comedi_device *dev,
-			struct comedi_subdevice *s,
-			struct comedi_insn *insn,
-			unsigned long context)
-{
-	struct labpc_private *devpriv = dev->private;
-
-	devpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);
-	if (devpriv->stat1 & STAT1_DAVAIL)
-		return 0;
-	return -EBUSY;
-}
-
-static int labpc_ai_insn_read(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn,
-			      unsigned int *data)
-{
-	struct labpc_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int range = CR_RANGE(insn->chanspec);
-	unsigned int aref = CR_AREF(insn->chanspec);
-	int ret;
-	int i;
-
-	/* disable timed conversions, interrupt generation and dma */
-	labpc_cancel(dev, s);
-
-	labpc_ai_set_chan_and_gain(dev, MODE_SINGLE_CHAN, chan, range, aref);
-
-	labpc_setup_cmd6_reg(dev, s, MODE_SINGLE_CHAN, fifo_not_empty_transfer,
-			     range, aref, false);
-
-	/* setup cmd4 register */
-	devpriv->cmd4 = 0;
-	devpriv->cmd4 |= CMD4_ECLKRCV;
-	/* single-ended/differential */
-	if (aref == AREF_DIFF)
-		devpriv->cmd4 |= CMD4_SEDIFF;
-	devpriv->write_byte(dev, devpriv->cmd4, CMD4_REG);
-
-	/* initialize pacer counter to prevent any problems */
-	labpc_counter_set_mode(dev, COUNTER_A_BASE_REG, 0, I8254_MODE2);
-
-	labpc_clear_adc_fifo(dev);
-
-	for (i = 0; i < insn->n; i++) {
-		/* trigger conversion */
-		devpriv->write_byte(dev, 0x1, ADC_START_CONVERT_REG);
-
-		ret = comedi_timeout(dev, s, insn, labpc_ai_eoc, 0);
-		if (ret)
-			return ret;
-
-		data[i] = labpc_read_adc_fifo(dev);
-	}
-
-	return insn->n;
-}
-
-static bool labpc_use_continuous_mode(const struct comedi_cmd *cmd,
-				      enum scan_mode mode)
-{
-	if (mode == MODE_SINGLE_CHAN || cmd->scan_begin_src == TRIG_FOLLOW)
-		return true;
-
-	return false;
-}
-
-static unsigned int labpc_ai_convert_period(const struct comedi_cmd *cmd,
-					    enum scan_mode mode)
-{
-	if (cmd->convert_src != TRIG_TIMER)
-		return 0;
-
-	if (mode == MODE_SINGLE_CHAN && cmd->scan_begin_src == TRIG_TIMER)
-		return cmd->scan_begin_arg;
-
-	return cmd->convert_arg;
-}
-
-static void labpc_set_ai_convert_period(struct comedi_cmd *cmd,
-					enum scan_mode mode, unsigned int ns)
-{
-	if (cmd->convert_src != TRIG_TIMER)
-		return;
-
-	if (mode == MODE_SINGLE_CHAN &&
-	    cmd->scan_begin_src == TRIG_TIMER) {
-		cmd->scan_begin_arg = ns;
-		if (cmd->convert_arg > cmd->scan_begin_arg)
-			cmd->convert_arg = cmd->scan_begin_arg;
-	} else {
-		cmd->convert_arg = ns;
-	}
-}
-
-static unsigned int labpc_ai_scan_period(const struct comedi_cmd *cmd,
-					 enum scan_mode mode)
-{
-	if (cmd->scan_begin_src != TRIG_TIMER)
-		return 0;
-
-	if (mode == MODE_SINGLE_CHAN && cmd->convert_src == TRIG_TIMER)
-		return 0;
-
-	return cmd->scan_begin_arg;
-}
-
-static void labpc_set_ai_scan_period(struct comedi_cmd *cmd,
-				     enum scan_mode mode, unsigned int ns)
-{
-	if (cmd->scan_begin_src != TRIG_TIMER)
-		return;
-
-	if (mode == MODE_SINGLE_CHAN && cmd->convert_src == TRIG_TIMER)
-		return;
-
-	cmd->scan_begin_arg = ns;
-}
-
-/* figures out what counter values to use based on command */
-static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
-			     enum scan_mode mode)
-{
-	struct labpc_private *devpriv = dev->private;
-	/* max value for 16 bit counter in mode 2 */
-	const int max_counter_value = 0x10000;
-	/* min value for 16 bit counter in mode 2 */
-	const int min_counter_value = 2;
-	unsigned int base_period;
-	unsigned int scan_period;
-	unsigned int convert_period;
-
-	/*
-	 * if both convert and scan triggers are TRIG_TIMER, then they
-	 * both rely on counter b0
-	 */
-	convert_period = labpc_ai_convert_period(cmd, mode);
-	scan_period = labpc_ai_scan_period(cmd, mode);
-	if (convert_period && scan_period) {
-		/*
-		 * pick the lowest b0 divisor value we can (for maximum input
-		 * clock speed on convert and scan counters)
-		 */
-		devpriv->divisor_b0 = (scan_period - 1) /
-		    (I8254_OSC_BASE_2MHZ * max_counter_value) + 1;
-		if (devpriv->divisor_b0 < min_counter_value)
-			devpriv->divisor_b0 = min_counter_value;
-		if (devpriv->divisor_b0 > max_counter_value)
-			devpriv->divisor_b0 = max_counter_value;
-
-		base_period = I8254_OSC_BASE_2MHZ * devpriv->divisor_b0;
-
-		/*  set a0 for conversion frequency and b1 for scan frequency */
-		switch (cmd->flags & TRIG_ROUND_MASK) {
-		default:
-		case TRIG_ROUND_NEAREST:
-			devpriv->divisor_a0 =
-			    (convert_period + (base_period / 2)) / base_period;
-			devpriv->divisor_b1 =
-			    (scan_period + (base_period / 2)) / base_period;
-			break;
-		case TRIG_ROUND_UP:
-			devpriv->divisor_a0 =
-			    (convert_period + (base_period - 1)) / base_period;
-			devpriv->divisor_b1 =
-			    (scan_period + (base_period - 1)) / base_period;
-			break;
-		case TRIG_ROUND_DOWN:
-			devpriv->divisor_a0 = convert_period / base_period;
-			devpriv->divisor_b1 = scan_period / base_period;
-			break;
-		}
-		/*  make sure a0 and b1 values are acceptable */
-		if (devpriv->divisor_a0 < min_counter_value)
-			devpriv->divisor_a0 = min_counter_value;
-		if (devpriv->divisor_a0 > max_counter_value)
-			devpriv->divisor_a0 = max_counter_value;
-		if (devpriv->divisor_b1 < min_counter_value)
-			devpriv->divisor_b1 = min_counter_value;
-		if (devpriv->divisor_b1 > max_counter_value)
-			devpriv->divisor_b1 = max_counter_value;
-		/*  write corrected timings to command */
-		labpc_set_ai_convert_period(cmd, mode,
-					    base_period * devpriv->divisor_a0);
-		labpc_set_ai_scan_period(cmd, mode,
-					 base_period * devpriv->divisor_b1);
-		/*
-		 * if only one TRIG_TIMER is used, we can employ the generic
-		 * cascaded timing functions
-		 */
-	} else if (scan_period) {
-		/*
-		 * calculate cascaded counter values
-		 * that give desired scan timing
-		 */
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_2MHZ,
-					  &devpriv->divisor_b1,
-					  &devpriv->divisor_b0,
-					  &scan_period, cmd->flags);
-		labpc_set_ai_scan_period(cmd, mode, scan_period);
-	} else if (convert_period) {
-		/*
-		 * calculate cascaded counter values
-		 * that give desired conversion timing
-		 */
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_2MHZ,
-					  &devpriv->divisor_a0,
-					  &devpriv->divisor_b0,
-					  &convert_period, cmd->flags);
-		labpc_set_ai_convert_period(cmd, mode, convert_period);
-	}
-}
-
-static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)
-{
-	unsigned int chan0;
-	unsigned int chan1;
-
-	if (cmd->chanlist_len == 1)
-		return MODE_SINGLE_CHAN;
-
-	/* chanlist may be NULL during cmdtest */
-	if (cmd->chanlist == NULL)
-		return MODE_MULT_CHAN_UP;
-
-	chan0 = CR_CHAN(cmd->chanlist[0]);
-	chan1 = CR_CHAN(cmd->chanlist[1]);
-
-	if (chan0 < chan1)
-		return MODE_MULT_CHAN_UP;
-
-	if (chan0 > chan1)
-		return MODE_MULT_CHAN_DOWN;
-
-	return MODE_SINGLE_CHAN_INTERVAL;
-}
-
-static int labpc_ai_check_chanlist(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   struct comedi_cmd *cmd)
-{
-	enum scan_mode mode = labpc_ai_scan_mode(cmd);
-	unsigned int chan0 = CR_CHAN(cmd->chanlist[0]);
-	unsigned int range0 = CR_RANGE(cmd->chanlist[0]);
-	unsigned int aref0 = CR_AREF(cmd->chanlist[0]);
-	int i;
-
-	if (mode == MODE_SINGLE_CHAN)
-		return 0;
-
-	for (i = 0; i < cmd->chanlist_len; i++) {
-		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
-		unsigned int range = CR_RANGE(cmd->chanlist[i]);
-		unsigned int aref = CR_AREF(cmd->chanlist[i]);
-
-		switch (mode) {
-		case MODE_SINGLE_CHAN:
-			break;
-		case MODE_SINGLE_CHAN_INTERVAL:
-			if (chan != chan0) {
-				dev_dbg(dev->class_dev,
-					"channel scanning order specified in chanlist is not supported by hardware\n");
-				return -EINVAL;
-			}
-			break;
-		case MODE_MULT_CHAN_UP:
-			if (chan != i) {
-				dev_dbg(dev->class_dev,
-					"channel scanning order specified in chanlist is not supported by hardware\n");
-				return -EINVAL;
-			}
-			break;
-		case MODE_MULT_CHAN_DOWN:
-			if (chan != (cmd->chanlist_len - i - 1)) {
-				dev_dbg(dev->class_dev,
-					"channel scanning order specified in chanlist is not supported by hardware\n");
-				return -EINVAL;
-			}
-			break;
-		}
-
-		if (range != range0) {
-			dev_dbg(dev->class_dev,
-				"entries in chanlist must all have the same range\n");
-			return -EINVAL;
-		}
-
-		if (aref != aref0) {
-			dev_dbg(dev->class_dev,
-				"entries in chanlist must all have the same reference\n");
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-
-static int labpc_ai_cmdtest(struct comedi_device *dev,
-			    struct comedi_subdevice *s, struct comedi_cmd *cmd)
-{
-	const struct labpc_boardinfo *board = comedi_board(dev);
-	int err = 0;
-	int tmp, tmp2;
-	unsigned int stop_mask;
-	enum scan_mode mode;
-
-	/* Step 1 : check if triggers are trivially valid */
-
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
-					TRIG_TIMER | TRIG_FOLLOW | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-
-	stop_mask = TRIG_COUNT | TRIG_NONE;
-	if (board->is_labpc1200)
-		stop_mask |= TRIG_EXT;
-	err |= cfc_check_trigger_src(&cmd->stop_src, stop_mask);
-
-	if (err)
-		return 1;
-
-	/* Step 2a : make sure trigger sources are unique */
-
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
-
-	/* Step 2b : and mutually compatible */
-
-	/* can't have external stop and start triggers at once */
-	if (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)
-		err++;
-
-	if (err)
-		return 2;
-
-	/* Step 3: check if arguments are trivially valid */
-
-	switch (cmd->start_src) {
-	case TRIG_NOW:
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
-		break;
-	case TRIG_EXT:
-		/* start_arg value is ignored */
-		break;
-	}
-
-	if (!cmd->chanlist_len)
-		err |= -EINVAL;
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
-
-	if (cmd->convert_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 board->ai_speed);
-
-	/* make sure scan timing is not too fast */
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		if (cmd->convert_src == TRIG_TIMER)
-			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-					cmd->convert_arg * cmd->chanlist_len);
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-				board->ai_speed * cmd->chanlist_len);
-	}
-
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
-		break;
-	case TRIG_NONE:
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
-		break;
-		/*
-		 * TRIG_EXT doesn't care since it doesn't
-		 * trigger off a numbered channel
-		 */
-	default:
-		break;
-	}
-
-	if (err)
-		return 3;
-
-	/* step 4: fix up any arguments */
-
-	tmp = cmd->convert_arg;
-	tmp2 = cmd->scan_begin_arg;
-	mode = labpc_ai_scan_mode(cmd);
-	labpc_adc_timing(dev, cmd, mode);
-	if (tmp != cmd->convert_arg || tmp2 != cmd->scan_begin_arg)
-		err++;
-
-	if (err)
-		return 4;
-
-	/* Step 5: check channel list if it exists */
-	if (cmd->chanlist && cmd->chanlist_len > 0)
-		err |= labpc_ai_check_chanlist(dev, s, cmd);
-
-	if (err)
-		return 5;
-
-	return 0;
-}
-
-static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	const struct labpc_boardinfo *board = comedi_board(dev);
-	struct labpc_private *devpriv = dev->private;
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
-	enum scan_mode mode = labpc_ai_scan_mode(cmd);
-	unsigned int chanspec = (mode == MODE_MULT_CHAN_UP) ?
-				cmd->chanlist[cmd->chanlist_len - 1] :
-				cmd->chanlist[0];
-	unsigned int chan = CR_CHAN(chanspec);
-	unsigned int range = CR_RANGE(chanspec);
-	unsigned int aref = CR_AREF(chanspec);
-	enum transfer_type xfer;
-	unsigned long flags;
-
-	/* make sure board is disabled before setting up acquisition */
-	labpc_cancel(dev, s);
-
-	/*  initialize software conversion count */
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->count = cmd->stop_arg * cmd->chanlist_len;
-
-	/*  setup hardware conversion counter */
-	if (cmd->stop_src == TRIG_EXT) {
-		/*
-		 * load counter a1 with count of 3
-		 * (pc+ manual says this is minimum allowed) using mode 0
-		 */
-		labpc_counter_load(dev, COUNTER_A_BASE_REG,
-				   1, 3, I8254_MODE0);
-	} else	{
-		/* just put counter a1 in mode 0 to set its output low */
-		labpc_counter_set_mode(dev, COUNTER_A_BASE_REG, 1, I8254_MODE0);
-	}
 
-	/* figure out what method we will use to transfer data */
-	if (labpc_have_dma_chan(dev) &&
-	    /* dma unsafe at RT priority,
-	     * and too much setup time for TRIG_WAKE_EOS */
-	    (cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0)
-		xfer = isa_dma_transfer;
-	else if (/* pc-plus has no fifo-half full interrupt */
-		 board->is_labpc1200 &&
-		 /* wake-end-of-scan should interrupt on fifo not empty */
-		 (cmd->flags & TRIG_WAKE_EOS) == 0 &&
-		 /* make sure we are taking more than just a few points */
-		 (cmd->stop_src != TRIG_COUNT || devpriv->count > 256))
-		xfer = fifo_half_full_transfer;
-	else
-		xfer = fifo_not_empty_transfer;
-	devpriv->current_transfer = xfer;
-
-	labpc_ai_set_chan_and_gain(dev, mode, chan, range, aref);
-
-	labpc_setup_cmd6_reg(dev, s, mode, xfer, range, aref,
-			     (cmd->stop_src == TRIG_EXT));
-
-	/* manual says to set scan enable bit on second pass */
-	if (mode == MODE_MULT_CHAN_UP || mode == MODE_MULT_CHAN_DOWN) {
-		devpriv->cmd1 |= CMD1_SCANEN;
-		/* need a brief delay before enabling scan, or scan
-		 * list will get screwed when you switch
-		 * between scan up to scan down mode - dunno why */
-		udelay(1);
-		devpriv->write_byte(dev, devpriv->cmd1, CMD1_REG);
-	}
-
-	devpriv->write_byte(dev, cmd->chanlist_len, INTERVAL_COUNT_REG);
-	/*  load count */
-	devpriv->write_byte(dev, 0x1, INTERVAL_STROBE_REG);
-
-	if (cmd->convert_src == TRIG_TIMER ||
-	    cmd->scan_begin_src == TRIG_TIMER) {
-		/*  set up pacing */
-		labpc_adc_timing(dev, cmd, mode);
-		/*  load counter b0 in mode 3 */
-		labpc_counter_load(dev, COUNTER_B_BASE_REG,
-				   0, devpriv->divisor_b0, I8254_MODE3);
-	}
-	/*  set up conversion pacing */
-	if (labpc_ai_convert_period(cmd, mode)) {
-		/*  load counter a0 in mode 2 */
-		labpc_counter_load(dev, COUNTER_A_BASE_REG,
-				   0, devpriv->divisor_a0, I8254_MODE2);
-	} else {
-		/* initialize pacer counter to prevent any problems */
-		labpc_counter_set_mode(dev, COUNTER_A_BASE_REG, 0, I8254_MODE2);
-	}
-
-	/*  set up scan pacing */
-	if (labpc_ai_scan_period(cmd, mode)) {
-		/*  load counter b1 in mode 2 */
-		labpc_counter_load(dev, COUNTER_B_BASE_REG,
-				   1, devpriv->divisor_b1, I8254_MODE2);
-	}
-
-	labpc_clear_adc_fifo(dev);
-
-	if (xfer == isa_dma_transfer)
-		labpc_setup_dma(dev, s);
-
-	/*  enable error interrupts */
-	devpriv->cmd3 |= CMD3_ERRINTEN;
-	/*  enable fifo not empty interrupt? */
-	if (xfer == fifo_not_empty_transfer)
-		devpriv->cmd3 |= CMD3_FIFOINTEN;
-	devpriv->write_byte(dev, devpriv->cmd3, CMD3_REG);
-
-	/*  setup any external triggering/pacing (cmd4 register) */
-	devpriv->cmd4 = 0;
-	if (cmd->convert_src != TRIG_EXT)
-		devpriv->cmd4 |= CMD4_ECLKRCV;
-	/* XXX should discard first scan when using interval scanning
-	 * since manual says it is not synced with scan clock */
-	if (!labpc_use_continuous_mode(cmd, mode)) {
-		devpriv->cmd4 |= CMD4_INTSCAN;
-		if (cmd->scan_begin_src == TRIG_EXT)
-			devpriv->cmd4 |= CMD4_EOIRCV;
-	}
-	/*  single-ended/differential */
-	if (aref == AREF_DIFF)
-		devpriv->cmd4 |= CMD4_SEDIFF;
-	devpriv->write_byte(dev, devpriv->cmd4, CMD4_REG);
-
-	/*  startup acquisition */
-
-	spin_lock_irqsave(&dev->spinlock, flags);
-
-	/* use 2 cascaded counters for pacing */
-	devpriv->cmd2 |= CMD2_TBSEL;
-
-	devpriv->cmd2 &= ~(CMD2_SWTRIG | CMD2_HWTRIG | CMD2_PRETRIG);
-	if (cmd->start_src == TRIG_EXT)
-		devpriv->cmd2 |= CMD2_HWTRIG;
-	else
-		devpriv->cmd2 |= CMD2_SWTRIG;
-	if (cmd->stop_src == TRIG_EXT)
-		devpriv->cmd2 |= (CMD2_HWTRIG | CMD2_PRETRIG);
-
-	devpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);
-
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	return 0;
-}
-
-/* read all available samples from ai fifo */
-static int labpc_drain_fifo(struct comedi_device *dev)
-{
-	struct labpc_private *devpriv = dev->private;
-	struct comedi_async *async = dev->read_subdev->async;
-	struct comedi_cmd *cmd = &async->cmd;
-	unsigned short data;
-	const int timeout = 10000;
-	unsigned int i;
-
-	devpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);
-
-	for (i = 0; (devpriv->stat1 & STAT1_DAVAIL) && i < timeout;
-	     i++) {
-		/*  quit if we have all the data we want */
-		if (cmd->stop_src == TRIG_COUNT) {
-			if (devpriv->count == 0)
-				break;
-			devpriv->count--;
-		}
-		data = labpc_read_adc_fifo(dev);
-		cfc_write_to_buffer(dev->read_subdev, data);
-		devpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);
-	}
-	if (i == timeout) {
-		dev_err(dev->class_dev, "ai timeout, fifo never empties\n");
-		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		return -1;
-	}
-
-	return 0;
-}
-
-/* makes sure all data acquired by board is transferred to comedi (used
- * when acquisition is terminated by stop_src == TRIG_EXT). */
-static void labpc_drain_dregs(struct comedi_device *dev)
-{
-	struct labpc_private *devpriv = dev->private;
-
-	if (devpriv->current_transfer == isa_dma_transfer)
-		labpc_drain_dma(dev);
-
-	labpc_drain_fifo(dev);
-}
-
-/* interrupt service routine */
-static irqreturn_t labpc_interrupt(int irq, void *d)
-{
-	struct comedi_device *dev = d;
-	const struct labpc_boardinfo *board = comedi_board(dev);
-	struct labpc_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_async *async;
-	struct comedi_cmd *cmd;
-
-	if (!dev->attached) {
-		dev_err(dev->class_dev, "premature interrupt\n");
-		return IRQ_HANDLED;
-	}
-
-	async = s->async;
-	cmd = &async->cmd;
-
-	/* read board status */
-	devpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);
-	if (board->is_labpc1200)
-		devpriv->stat2 = devpriv->read_byte(dev, STAT2_REG);
-
-	if ((devpriv->stat1 & (STAT1_GATA0 | STAT1_CNTINT | STAT1_OVERFLOW |
-			       STAT1_OVERRUN | STAT1_DAVAIL)) == 0 &&
-	    (devpriv->stat2 & STAT2_OUTA1) == 0 &&
-	    (devpriv->stat2 & STAT2_FIFONHF)) {
-		return IRQ_NONE;
-	}
-
-	if (devpriv->stat1 & STAT1_OVERRUN) {
-		/* clear error interrupt */
-		devpriv->write_byte(dev, 0x1, ADC_FIFO_CLEAR_REG);
-		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		cfc_handle_events(dev, s);
-		dev_err(dev->class_dev, "overrun\n");
-		return IRQ_HANDLED;
-	}
-
-	if (devpriv->current_transfer == isa_dma_transfer)
-		labpc_handle_dma_status(dev);
-	else
-		labpc_drain_fifo(dev);
-
-	if (devpriv->stat1 & STAT1_CNTINT) {
-		dev_err(dev->class_dev, "handled timer interrupt?\n");
-		/*  clear it */
-		devpriv->write_byte(dev, 0x1, TIMER_CLEAR_REG);
-	}
-
-	if (devpriv->stat1 & STAT1_OVERFLOW) {
-		/*  clear error interrupt */
-		devpriv->write_byte(dev, 0x1, ADC_FIFO_CLEAR_REG);
-		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		cfc_handle_events(dev, s);
-		dev_err(dev->class_dev, "overflow\n");
-		return IRQ_HANDLED;
-	}
-	/*  handle external stop trigger */
-	if (cmd->stop_src == TRIG_EXT) {
-		if (devpriv->stat2 & STAT2_OUTA1) {
-			labpc_drain_dregs(dev);
-			async->events |= COMEDI_CB_EOA;
-		}
-	}
-
-	/* TRIG_COUNT end of acquisition */
-	if (cmd->stop_src == TRIG_COUNT) {
-		if (devpriv->count == 0)
-			async->events |= COMEDI_CB_EOA;
-	}
-
-	cfc_handle_events(dev, s);
-	return IRQ_HANDLED;
-}
-
-static int labpc_ao_insn_write(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn,
-			       unsigned int *data)
-{
-	const struct labpc_boardinfo *board = comedi_board(dev);
-	struct labpc_private *devpriv = dev->private;
-	int channel, range;
-	unsigned long flags;
-	int lsb, msb;
-
-	channel = CR_CHAN(insn->chanspec);
-
-	/* turn off pacing of analog output channel */
-	/* note: hardware bug in daqcard-1200 means pacing cannot
-	 * be independently enabled/disabled for its the two channels */
-	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->cmd2 &= ~CMD2_LDAC(channel);
-	devpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	/* set range */
-	if (board->is_labpc1200) {
-		range = CR_RANGE(insn->chanspec);
-		if (comedi_range_is_unipolar(s, range))
-			devpriv->cmd6 |= CMD6_DACUNI(channel);
-		else
-			devpriv->cmd6 &= ~CMD6_DACUNI(channel);
-		/*  write to register */
-		devpriv->write_byte(dev, devpriv->cmd6, CMD6_REG);
-	}
-	/* send data */
-	lsb = data[0] & 0xff;
-	msb = (data[0] >> 8) & 0xff;
-	devpriv->write_byte(dev, lsb, DAC_LSB_REG(channel));
-	devpriv->write_byte(dev, msb, DAC_MSB_REG(channel));
-
-	/* remember value for readback */
-	devpriv->ao_value[channel] = data[0];
-
-	return 1;
-}
-
-static int labpc_ao_insn_read(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn,
-			      unsigned int *data)
-{
-	struct labpc_private *devpriv = dev->private;
-
-	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
-
-	return 1;
-}
-
-/* lowlevel write to eeprom/dac */
-static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
-			     unsigned int value_width)
-{
-	struct labpc_private *devpriv = dev->private;
-	int i;
-
-	for (i = 1; i <= value_width; i++) {
-		/*  clear serial clock */
-		devpriv->cmd5 &= ~CMD5_SCLK;
-		/*  send bits most significant bit first */
-		if (value & (1 << (value_width - i)))
-			devpriv->cmd5 |= CMD5_SDATA;
-		else
-			devpriv->cmd5 &= ~CMD5_SDATA;
-		udelay(1);
-		devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-		/*  set clock to load bit */
-		devpriv->cmd5 |= CMD5_SCLK;
-		udelay(1);
-		devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-	}
-}
-
-/* lowlevel read from eeprom */
-static unsigned int labpc_serial_in(struct comedi_device *dev)
-{
-	struct labpc_private *devpriv = dev->private;
-	unsigned int value = 0;
-	int i;
-	const int value_width = 8;	/*  number of bits wide values are */
-
-	for (i = 1; i <= value_width; i++) {
-		/*  set serial clock */
-		devpriv->cmd5 |= CMD5_SCLK;
-		udelay(1);
-		devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-		/*  clear clock bit */
-		devpriv->cmd5 &= ~CMD5_SCLK;
-		udelay(1);
-		devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-		/*  read bits most significant bit first */
-		udelay(1);
-		devpriv->stat2 = devpriv->read_byte(dev, STAT2_REG);
-		if (devpriv->stat2 & STAT2_PROMOUT)
-			value |= 1 << (value_width - i);
-	}
-
-	return value;
-}
-
-static unsigned int labpc_eeprom_read(struct comedi_device *dev,
-				      unsigned int address)
-{
-	struct labpc_private *devpriv = dev->private;
-	unsigned int value;
-	/*  bits to tell eeprom to expect a read */
-	const int read_instruction = 0x3;
-	/*  8 bit write lengths to eeprom */
-	const int write_length = 8;
-
-	/*  enable read/write to eeprom */
-	devpriv->cmd5 &= ~CMD5_EEPROMCS;
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-	devpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-
-	/*  send read instruction */
-	labpc_serial_out(dev, read_instruction, write_length);
-	/*  send 8 bit address to read from */
-	labpc_serial_out(dev, address, write_length);
-	/*  read result */
-	value = labpc_serial_in(dev);
-
-	/*  disable read/write to eeprom */
-	devpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-
-	return value;
-}
-
-static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
-{
-	struct labpc_private *devpriv = dev->private;
-	unsigned int value;
-	const int read_status_instruction = 0x5;
-	const int write_length = 8;	/*  8 bit write lengths to eeprom */
-
-	/*  enable read/write to eeprom */
-	devpriv->cmd5 &= ~CMD5_EEPROMCS;
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-	devpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-
-	/*  send read status instruction */
-	labpc_serial_out(dev, read_status_instruction, write_length);
-	/*  read result */
-	value = labpc_serial_in(dev);
-
-	/*  disable read/write to eeprom */
-	devpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-
-	return value;
-}
-
-static int labpc_eeprom_write(struct comedi_device *dev,
-			      unsigned int address, unsigned int value)
-{
-	struct labpc_private *devpriv = dev->private;
-	const int write_enable_instruction = 0x6;
-	const int write_instruction = 0x2;
-	const int write_length = 8;	/*  8 bit write lengths to eeprom */
-	const int write_in_progress_bit = 0x1;
-	const int timeout = 10000;
-	int i;
-
-	/*  make sure there isn't already a write in progress */
-	for (i = 0; i < timeout; i++) {
-		if ((labpc_eeprom_read_status(dev) & write_in_progress_bit) ==
-		    0)
-			break;
-	}
-	if (i == timeout) {
-		dev_err(dev->class_dev, "eeprom write timed out\n");
-		return -ETIME;
-	}
-	/*  update software copy of eeprom */
-	devpriv->eeprom_data[address] = value;
-
-	/*  enable read/write to eeprom */
-	devpriv->cmd5 &= ~CMD5_EEPROMCS;
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-	devpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-
-	/*  send write_enable instruction */
-	labpc_serial_out(dev, write_enable_instruction, write_length);
-	devpriv->cmd5 &= ~CMD5_EEPROMCS;
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-
-	/*  send write instruction */
-	devpriv->cmd5 |= CMD5_EEPROMCS;
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-	labpc_serial_out(dev, write_instruction, write_length);
-	/*  send 8 bit address to write to */
-	labpc_serial_out(dev, address, write_length);
-	/*  write value */
-	labpc_serial_out(dev, value, write_length);
-	devpriv->cmd5 &= ~CMD5_EEPROMCS;
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-
-	/*  disable read/write to eeprom */
-	devpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-
-	return 0;
-}
-
-/* writes to 8 bit calibration dacs */
-static void write_caldac(struct comedi_device *dev, unsigned int channel,
-			 unsigned int value)
-{
-	struct labpc_private *devpriv = dev->private;
-
-	if (value == devpriv->caldac[channel])
-		return;
-	devpriv->caldac[channel] = value;
-
-	/*  clear caldac load bit and make sure we don't write to eeprom */
-	devpriv->cmd5 &= ~(CMD5_CALDACLD | CMD5_EEPROMCS | CMD5_WRTPRT);
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-
-	/*  write 4 bit channel */
-	labpc_serial_out(dev, channel, 4);
-	/*  write 8 bit caldac value */
-	labpc_serial_out(dev, value, 8);
-
-	/*  set and clear caldac bit to load caldac value */
-	devpriv->cmd5 |= CMD5_CALDACLD;
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-	devpriv->cmd5 &= ~CMD5_CALDACLD;
-	udelay(1);
-	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-}
-
-static int labpc_calib_insn_write(struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn,
-				  unsigned int *data)
-{
-	unsigned int chan = CR_CHAN(insn->chanspec);
-
-	/*
-	 * Only write the last data value to the caldac. Preceding
-	 * data would be overwritten anyway.
-	 */
-	if (insn->n > 0)
-		write_caldac(dev, chan, data[insn->n - 1]);
-
-	return insn->n;
-}
-
-static int labpc_calib_insn_read(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn,
-				 unsigned int *data)
-{
-	struct labpc_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	int i;
-
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->caldac[chan];
-
-	return insn->n;
-}
-
-static int labpc_eeprom_insn_write(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   struct comedi_insn *insn,
-				   unsigned int *data)
-{
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	int ret;
-
-	/* only allow writes to user area of eeprom */
-	if (chan < 16 || chan > 127)
-		return -EINVAL;
-
-	/*
-	 * Only write the last data value to the eeprom. Preceding
-	 * data would be overwritten anyway.
-	 */
-	if (insn->n > 0) {
-		ret = labpc_eeprom_write(dev, chan, data[insn->n - 1]);
-		if (ret)
-			return ret;
-	}
-
-	return insn->n;
-}
-
-static int labpc_eeprom_insn_read(struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn,
-				  unsigned int *data)
-{
-	struct labpc_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	int i;
-
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->eeprom_data[chan];
-
-	return insn->n;
-}
-
-int labpc_common_attach(struct comedi_device *dev,
-			unsigned int irq, unsigned long isr_flags)
-{
-	const struct labpc_boardinfo *board = comedi_board(dev);
-	struct labpc_private *devpriv = dev->private;
-	struct comedi_subdevice *s;
-	int ret;
-	int i;
-
-	if (dev->mmio) {
-		devpriv->read_byte = labpc_readb;
-		devpriv->write_byte = labpc_writeb;
-	} else {
-		devpriv->read_byte = labpc_inb;
-		devpriv->write_byte = labpc_outb;
-	}
-
-	/* initialize board's command registers */
-	devpriv->write_byte(dev, devpriv->cmd1, CMD1_REG);
-	devpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);
-	devpriv->write_byte(dev, devpriv->cmd3, CMD3_REG);
-	devpriv->write_byte(dev, devpriv->cmd4, CMD4_REG);
-	if (board->is_labpc1200) {
-		devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
-		devpriv->write_byte(dev, devpriv->cmd6, CMD6_REG);
-	}
-
-	if (irq) {
-		ret = request_irq(irq, labpc_interrupt, isr_flags,
-				  dev->board_name, dev);
-		if (ret == 0)
-			dev->irq = irq;
-	}
-
-	ret = comedi_alloc_subdevices(dev, 5);
-	if (ret)
-		return ret;
-
-	/* analog input subdevice */
-	s = &dev->subdevices[0];
-	s->type		= COMEDI_SUBD_AI;
-	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF;
-	s->n_chan	= 8;
-	s->len_chanlist	= 8;
-	s->maxdata	= 0x0fff;
-	s->range_table	= board->is_labpc1200 ?
-			  &range_labpc_1200_ai : &range_labpc_plus_ai;
-	s->insn_read	= labpc_ai_insn_read;
-	if (dev->irq) {
-		dev->read_subdev = s;
-		s->subdev_flags	|= SDF_CMD_READ;
-		s->do_cmd	= labpc_ai_cmd;
-		s->do_cmdtest	= labpc_ai_cmdtest;
-		s->cancel	= labpc_cancel;
-	}
-
-	/* analog output */
-	s = &dev->subdevices[1];
-	if (board->has_ao) {
-		s->type		= COMEDI_SUBD_AO;
-		s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
-		s->n_chan	= NUM_AO_CHAN;
-		s->maxdata	= 0x0fff;
-		s->range_table	= &range_labpc_ao;
-		s->insn_read	= labpc_ao_insn_read;
-		s->insn_write	= labpc_ao_insn_write;
-
-		/* initialize analog outputs to a known value */
-		for (i = 0; i < s->n_chan; i++) {
-			short lsb, msb;
-
-			devpriv->ao_value[i] = s->maxdata / 2;
-			lsb = devpriv->ao_value[i] & 0xff;
-			msb = (devpriv->ao_value[i] >> 8) & 0xff;
-			devpriv->write_byte(dev, lsb, DAC_LSB_REG(i));
-			devpriv->write_byte(dev, msb, DAC_MSB_REG(i));
-		}
-	} else {
-		s->type		= COMEDI_SUBD_UNUSED;
-	}
-
-	/* 8255 dio */
-	s = &dev->subdevices[2];
-	if (dev->mmio)
-		ret = subdev_8255_mm_init(dev, s, NULL, DIO_BASE_REG);
-	else
-		ret = subdev_8255_init(dev, s, NULL, DIO_BASE_REG);
-	if (ret)
-		return ret;
-
-	/*  calibration subdevices for boards that have one */
-	s = &dev->subdevices[3];
-	if (board->is_labpc1200) {
-		s->type		= COMEDI_SUBD_CALIB;
-		s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-		s->n_chan	= 16;
-		s->maxdata	= 0xff;
-		s->insn_read	= labpc_calib_insn_read;
-		s->insn_write	= labpc_calib_insn_write;
-
-		for (i = 0; i < s->n_chan; i++)
-			write_caldac(dev, i, s->maxdata / 2);
-	} else {
-		s->type		= COMEDI_SUBD_UNUSED;
-	}
-
-	/* EEPROM */
-	s = &dev->subdevices[4];
-	if (board->is_labpc1200) {
-		s->type		= COMEDI_SUBD_MEMORY;
-		s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-		s->n_chan	= EEPROM_SIZE;
-		s->maxdata	= 0xff;
-		s->insn_read	= labpc_eeprom_insn_read;
-		s->insn_write	= labpc_eeprom_insn_write;
-
-		for (i = 0; i < s->n_chan; i++)
-			devpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);
-	} else {
-		s->type		= COMEDI_SUBD_UNUSED;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(labpc_common_attach);
-
-#if IS_ENABLED(CONFIG_COMEDI_NI_LABPC_ISA)
 static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct labpc_private *devpriv;
@@ -1480,19 +128,7 @@ static struct comedi_driver labpc_driver = {
 	.offset		= sizeof(struct labpc_boardinfo),
 };
 module_comedi_driver(labpc_driver);
-#else
-static int __init labpc_common_init(void)
-{
-	return 0;
-}
-module_init(labpc_common_init);
-
-static void __exit labpc_common_exit(void)
-{
-}
-module_exit(labpc_common_exit);
-#endif
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_DESCRIPTION("Comedi driver for NI Lab-PC ISA boards");
 MODULE_LICENSE("GPL");

commit 9439881a38c2bef6807954732768d636ff94c0d5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Aug 19 16:06:32 2014 +0100

    staging: comedi: ni_labpc: break lines after operators
    
    For consistency, break lines before operators, not after.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index f551a3b9dad1..ccf5ce800697 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -720,9 +720,9 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	enum scan_mode mode = labpc_ai_scan_mode(cmd);
-	unsigned int chanspec = (mode == MODE_MULT_CHAN_UP)
-				? cmd->chanlist[cmd->chanlist_len - 1]
-				: cmd->chanlist[0];
+	unsigned int chanspec = (mode == MODE_MULT_CHAN_UP) ?
+				cmd->chanlist[cmd->chanlist_len - 1] :
+				cmd->chanlist[0];
 	unsigned int chan = CR_CHAN(chanspec);
 	unsigned int range = CR_RANGE(chanspec);
 	unsigned int aref = CR_AREF(chanspec);
@@ -1353,8 +1353,8 @@ int labpc_common_attach(struct comedi_device *dev,
 	s->n_chan	= 8;
 	s->len_chanlist	= 8;
 	s->maxdata	= 0x0fff;
-	s->range_table	= board->is_labpc1200
-				? &range_labpc_1200_ai : &range_labpc_plus_ai;
+	s->range_table	= board->is_labpc1200 ?
+			  &range_labpc_1200_ai : &range_labpc_plus_ai;
 	s->insn_read	= labpc_ai_insn_read;
 	if (dev->irq) {
 		dev->read_subdev = s;

commit 4e3f39b16650db36bdc3f6a456f0a6509b6b6729
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Aug 19 16:06:31 2014 +0100

    staging: comedi: ni_labpc: Logical continuations should be on the previous line
    
    Fix checkpatch issues "CHECK: Logical continuations should be on the
    previous line".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 7210a04c82bb..f551a3b9dad1 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -929,9 +929,9 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 		devpriv->stat2 = devpriv->read_byte(dev, STAT2_REG);
 
 	if ((devpriv->stat1 & (STAT1_GATA0 | STAT1_CNTINT | STAT1_OVERFLOW |
-			       STAT1_OVERRUN | STAT1_DAVAIL)) == 0
-	    && (devpriv->stat2 & STAT2_OUTA1) == 0
-	    && (devpriv->stat2 & STAT2_FIFONHF)) {
+			       STAT1_OVERRUN | STAT1_DAVAIL)) == 0 &&
+	    (devpriv->stat2 & STAT2_OUTA1) == 0 &&
+	    (devpriv->stat2 & STAT2_FIFONHF)) {
 		return IRQ_NONE;
 	}
 

commit bd98a4abff8018e11273767404fb9ef3cdf8a807
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Aug 19 16:06:30 2014 +0100

    staging: comedi: ni_labpc: Alignment should match open parenthesis
    
    Fix checkpatch issues "CHECK: Alignment should match open parenthesis".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 4f49d51687b8..7210a04c82bb 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -403,7 +403,7 @@ static void labpc_set_ai_convert_period(struct comedi_cmd *cmd,
 }
 
 static unsigned int labpc_ai_scan_period(const struct comedi_cmd *cmd,
-					enum scan_mode mode)
+					 enum scan_mode mode)
 {
 	if (cmd->scan_begin_src != TRIG_TIMER)
 		return 0;
@@ -1149,7 +1149,7 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
 }
 
 static int labpc_eeprom_write(struct comedi_device *dev,
-				unsigned int address, unsigned int value)
+			      unsigned int address, unsigned int value)
 {
 	struct labpc_private *devpriv = dev->private;
 	const int write_enable_instruction = 0x6;

commit 6569f098279225258e805e4c9a20805d87ab4277
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Aug 19 16:06:29 2014 +0100

    staging: comedi: ni_labpc: use braces on all arms of `if` statement
    
    Fix checkpatch issues "CHECK: braces {} should be used on all arms of
    this statement".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index f5e78adf98e8..4f49d51687b8 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -397,8 +397,9 @@ static void labpc_set_ai_convert_period(struct comedi_cmd *cmd,
 		cmd->scan_begin_arg = ns;
 		if (cmd->convert_arg > cmd->scan_begin_arg)
 			cmd->convert_arg = cmd->scan_begin_arg;
-	} else
+	} else {
 		cmd->convert_arg = ns;
+	}
 }
 
 static unsigned int labpc_ai_scan_period(const struct comedi_cmd *cmd,
@@ -1409,8 +1410,9 @@ int labpc_common_attach(struct comedi_device *dev,
 
 		for (i = 0; i < s->n_chan; i++)
 			write_caldac(dev, i, s->maxdata / 2);
-	} else
+	} else {
 		s->type		= COMEDI_SUBD_UNUSED;
+	}
 
 	/* EEPROM */
 	s = &dev->subdevices[4];
@@ -1424,8 +1426,9 @@ int labpc_common_attach(struct comedi_device *dev,
 
 		for (i = 0; i < s->n_chan; i++)
 			devpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);
-	} else
+	} else {
 		s->type		= COMEDI_SUBD_UNUSED;
+	}
 
 	return 0;
 }

commit 13fec56c96b5b81d425c4eba734b02ab0377e5a7
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Aug 19 16:06:28 2014 +0100

    staging: comedi: ni_labpc: remove unnecessary braces in labpc_common_attach()
    
    Correct checkpatch issue "WARNING: braces {} are not necessary for any
    arm of this statement".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index c9c090e15e85..f5e78adf98e8 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1390,11 +1390,10 @@ int labpc_common_attach(struct comedi_device *dev,
 
 	/* 8255 dio */
 	s = &dev->subdevices[2];
-	if (dev->mmio) {
+	if (dev->mmio)
 		ret = subdev_8255_mm_init(dev, s, NULL, DIO_BASE_REG);
-	} else {
+	else
 		ret = subdev_8255_init(dev, s, NULL, DIO_BASE_REG);
-	}
 	if (ret)
 		return ret;
 

commit 5c19084bbd4ef7c0a10e5b01145b940edf872a63
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:28 2014 -0700

    staging: comedi: 8255: handle memory mapped io
    
    The drivers that use this module with memory mapped io all have the
    ioremap'ed base address stored in the comedi_device 'mmio' member.
    
    Introduce a default (*io) function that does 8-bit memory mapped io.
    
    Modify subdev_8255_init() so that it takes a flag parameter indicating
    if the io is port or memory mapped. Make the function static and rename
    it to __subdev_8255_init().
    
    Introduce two exported wrappers for __subdev_8255_init():
    
      subdev_8255_init() - for drivers that do 8-bit port io
      subdev_8255_mm_init() - for drivers that do 8-bit memory mapped io
    
    Use subdev_8255_mm_init() in the drivers that do 8-bit memory mapped io
    and remove the private (*io) functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 8f914de1c153..c9c090e15e85 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1035,17 +1035,6 @@ static int labpc_ao_insn_read(struct comedi_device *dev,
 	return 1;
 }
 
-static int labpc_8255_mmio(struct comedi_device *dev,
-			   int dir, int port, int data, unsigned long iobase)
-{
-	if (dir) {
-		writeb(data, dev->mmio + iobase + port);
-		return 0;
-	}
-
-	return readb(dev->mmio + iobase + port);
-}
-
 /* lowlevel write to eeprom/dac */
 static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
 			     unsigned int value_width)
@@ -1402,8 +1391,7 @@ int labpc_common_attach(struct comedi_device *dev,
 	/* 8255 dio */
 	s = &dev->subdevices[2];
 	if (dev->mmio) {
-		ret = subdev_8255_init(dev, s, labpc_8255_mmio,
-				       DIO_BASE_REG);
+		ret = subdev_8255_mm_init(dev, s, NULL, DIO_BASE_REG);
 	} else {
 		ret = subdev_8255_init(dev, s, NULL, DIO_BASE_REG);
 	}

commit 4085e93b9fecfad454159694c19efc36e7ac1cdf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:26 2014 -0700

    staging: comedi: 8255: refactor how the (*io) function works
    
    Currently, all users of is module that use the default (*io) function
    pass an 'iobase' to subdev_8255_init() of the form:
    
      dev->iobase + OFFSET_TO_8255_BASE_REG
    
    Now that the (*io) callback includes the comedi_device 'dev' pointer
    the 'dev->iobase' does not need to be included.
    
    Modify the default (*io) function, subdev_8255_io(), to automatically
    add the dev->iobase to the address when reading/writing the port.
    
    For aesthetics, rename the subdevice private data member to 'regbase'.
    Also, rename the local variables in this module that are used to
    access this member.
    
    Add a comment in dev_8255_attach() about the 'iobase' that is passed
    to subdev_8255_init(). For manually attached 8255 devices the io
    region is requested with __comedi_request_region() which does not
    set dev->iobase. For these devices the 'regbase' is actually the
    'iobase'.
    
    Remove the, now unnecessary, dev->iobase from all the callers of
    subdev_8255_init(). There are a couple drivers that only passed the
    dev->iobase. For those drivers pass a 'regbase' of 0x00.
    
    Note that the das16m1 driver is a bit goofy. The devpriv->extra_iobase
    is requested using __comedi_request_region() which does not set the
    dev->iobase. But the starting address passed is dev->iobase + DAS16M1_82C55
    so a 'regbase' of DAS16M1_82C55 is passed to subdev_8255_init().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 15ead2715926..8f914de1c153 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1405,8 +1405,7 @@ int labpc_common_attach(struct comedi_device *dev,
 		ret = subdev_8255_init(dev, s, labpc_8255_mmio,
 				       DIO_BASE_REG);
 	} else {
-		ret = subdev_8255_init(dev, s, NULL,
-				       dev->iobase + DIO_BASE_REG);
+		ret = subdev_8255_init(dev, s, NULL, DIO_BASE_REG);
 	}
 	if (ret)
 		return ret;

commit ed8c80d0a4c65c062ee520cd167649b80afce16f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:21 2014 -0700

    staging: comedi: ni_labpc: tidy up labpc_8255_mmio()
    
    The 8255 driver (*io) callback now includes the comedi_device pointer.
    
    Instead of passing the (cast) pointer to subdev_8255_init(), pass the
    'iobase' of the 8255 registers (DIO_BASE_REG).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index fa108b9dd603..15ead2715926 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1035,17 +1035,15 @@ static int labpc_ao_insn_read(struct comedi_device *dev,
 	return 1;
 }
 
-static int labpc_8255_mmio(struct comedi_device *cdev,
-			   int dir, int port, int data, unsigned long arg)
+static int labpc_8255_mmio(struct comedi_device *dev,
+			   int dir, int port, int data, unsigned long iobase)
 {
-	struct comedi_device *dev = (struct comedi_device *)arg;
-
 	if (dir) {
-		writeb(data, dev->mmio + DIO_BASE_REG + port);
+		writeb(data, dev->mmio + iobase + port);
 		return 0;
 	}
 
-	return readb(dev->mmio + DIO_BASE_REG + port);
+	return readb(dev->mmio + iobase + port);
 }
 
 /* lowlevel write to eeprom/dac */
@@ -1405,7 +1403,7 @@ int labpc_common_attach(struct comedi_device *dev,
 	s = &dev->subdevices[2];
 	if (dev->mmio) {
 		ret = subdev_8255_init(dev, s, labpc_8255_mmio,
-				       (unsigned long)dev);
+				       DIO_BASE_REG);
 	} else {
 		ret = subdev_8255_init(dev, s, NULL,
 				       dev->iobase + DIO_BASE_REG);

commit 09d6dd7490ee7f1dda926e309df370e28679a71c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:19 2014 -0700

    staging: comedi: 8255: add a comedi_device param to the (*io) callback
    
    The 8255 driver uses an (*io) callback to read/write the registers
    of the 8255 device. The default callback provided by the driver uses
    inb()/outb() calls to access to registers based on an 'iobase' that
    was initialized during the subdev_8255_init() and a 'port' value.
    
    The users of this module can optionally provide a custom (*io) callback
    to handle the read/write in another manner.
    
    Make the (*io) callback a bit more flexible by also passing the
    comedi_device pointer as a parameter.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 126d65cb39f2..fa108b9dd603 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1035,7 +1035,8 @@ static int labpc_ao_insn_read(struct comedi_device *dev,
 	return 1;
 }
 
-static int labpc_8255_mmio(int dir, int port, int data, unsigned long arg)
+static int labpc_8255_mmio(struct comedi_device *cdev,
+			   int dir, int port, int data, unsigned long arg)
 {
 	struct comedi_device *dev = (struct comedi_device *)arg;
 

commit 70f72867147b18fc36d2717cda6ddbaf4f71cf77
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jul 29 15:01:43 2014 -0700

    staging: comedi: ni_labpc: use the comedi_device 'mmio' member
    
    Use the new 'mmio' member in the comedi_device for the ioremap'ed
    base address.
    
    Only the ni_labpc_pci module does the ioremap, its also the only
    module that sets the 'has_mmio' member in the boardinfo. Remove
    this member from the boardinfo and use dev->mmio to determine if
    the I/O is memory mapped.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 7f5072bae493..126d65cb39f2 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -141,17 +141,13 @@ static void labpc_outb(struct comedi_device *dev,
 
 static unsigned int labpc_readb(struct comedi_device *dev, unsigned long reg)
 {
-	void __iomem *mmio = (void __iomem *)dev->iobase;
-
-	return readb(mmio + reg);
+	return readb(dev->mmio + reg);
 }
 
 static void labpc_writeb(struct comedi_device *dev,
 			 unsigned int byte, unsigned long reg)
 {
-	void __iomem *mmio = (void __iomem *)dev->iobase;
-
-	writeb(byte, mmio + reg);
+	writeb(byte, dev->mmio + reg);
 }
 
 #if IS_ENABLED(CONFIG_COMEDI_NI_LABPC_ISA)
@@ -181,13 +177,9 @@ static void labpc_counter_load(struct comedi_device *dev,
 			       unsigned int count,
 			       unsigned int mode)
 {
-	const struct labpc_boardinfo *board = comedi_board(dev);
-
-	if (board->has_mmio) {
-		void __iomem *mmio = (void __iomem *)dev->iobase;
-
-		i8254_mm_set_mode(mmio + reg, 0, counter_number, mode);
-		i8254_mm_write(mmio + reg, 0, counter_number, count);
+	if (dev->mmio) {
+		i8254_mm_set_mode(dev->mmio + reg, 0, counter_number, mode);
+		i8254_mm_write(dev->mmio + reg, 0, counter_number, count);
 	} else {
 		i8254_set_mode(dev->iobase + reg, 0, counter_number, mode);
 		i8254_write(dev->iobase + reg, 0, counter_number, count);
@@ -199,15 +191,10 @@ static void labpc_counter_set_mode(struct comedi_device *dev,
 				   unsigned int counter_number,
 				   unsigned int mode)
 {
-	const struct labpc_boardinfo *board = comedi_board(dev);
-
-	if (board->has_mmio) {
-		void __iomem *mmio = (void __iomem *)dev->iobase;
-
-		i8254_mm_set_mode(mmio + reg, 0, counter_number, mode);
-	} else {
+	if (dev->mmio)
+		i8254_mm_set_mode(dev->mmio + reg, 0, counter_number, mode);
+	else
 		i8254_set_mode(dev->iobase + reg, 0, counter_number, mode);
-	}
 }
 
 static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -1051,14 +1038,13 @@ static int labpc_ao_insn_read(struct comedi_device *dev,
 static int labpc_8255_mmio(int dir, int port, int data, unsigned long arg)
 {
 	struct comedi_device *dev = (struct comedi_device *)arg;
-	void __iomem *mmio = (void __iomem *)dev->iobase + DIO_BASE_REG;
 
 	if (dir) {
-		writeb(data, mmio + port);
+		writeb(data, dev->mmio + DIO_BASE_REG + port);
 		return 0;
 	}
 
-	return readb(mmio + port);
+	return readb(dev->mmio + DIO_BASE_REG + port);
 }
 
 /* lowlevel write to eeprom/dac */
@@ -1342,7 +1328,7 @@ int labpc_common_attach(struct comedi_device *dev,
 	int ret;
 	int i;
 
-	if (board->has_mmio) {
+	if (dev->mmio) {
 		devpriv->read_byte = labpc_readb;
 		devpriv->write_byte = labpc_writeb;
 	} else {
@@ -1416,7 +1402,7 @@ int labpc_common_attach(struct comedi_device *dev,
 
 	/* 8255 dio */
 	s = &dev->subdevices[2];
-	if (board->has_mmio) {
+	if (dev->mmio) {
 		ret = subdev_8255_init(dev, s, labpc_8255_mmio,
 				       (unsigned long)dev);
 	} else {

commit adcd16a2983c4f29cabd0af3bc2881e97348a4ee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jul 29 15:01:42 2014 -0700

    staging: comedi: ni_labpc: refactor labpc_8255_mmio()
    
    Refactor the 8255 support code in preperation for using the comedi_device
    'mmio' member.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 819eeec9d20d..7f5072bae493 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1048,14 +1048,17 @@ static int labpc_ao_insn_read(struct comedi_device *dev,
 	return 1;
 }
 
-static int labpc_8255_mmio(int dir, int port, int data, unsigned long iobase)
+static int labpc_8255_mmio(int dir, int port, int data, unsigned long arg)
 {
+	struct comedi_device *dev = (struct comedi_device *)arg;
+	void __iomem *mmio = (void __iomem *)dev->iobase + DIO_BASE_REG;
+
 	if (dir) {
-		writeb(data, (void __iomem *)(iobase + port));
+		writeb(data, mmio + port);
 		return 0;
 	}
 
-	return readb((void __iomem *)(iobase + port));
+	return readb(mmio + port);
 }
 
 /* lowlevel write to eeprom/dac */
@@ -1413,9 +1416,13 @@ int labpc_common_attach(struct comedi_device *dev,
 
 	/* 8255 dio */
 	s = &dev->subdevices[2];
-	ret = subdev_8255_init(dev, s,
-			       (board->has_mmio) ? labpc_8255_mmio : NULL,
-			       dev->iobase + DIO_BASE_REG);
+	if (board->has_mmio) {
+		ret = subdev_8255_init(dev, s, labpc_8255_mmio,
+				       (unsigned long)dev);
+	} else {
+		ret = subdev_8255_init(dev, s, NULL,
+				       dev->iobase + DIO_BASE_REG);
+	}
 	if (ret)
 		return ret;
 

commit 7c555f06fb6afc9e83b8b375e8cf131cfe355e95
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jul 29 15:01:41 2014 -0700

    staging: comedi: ni_labpc: don't pass dev->iobase to labpc_counter_set_mode()
    
    Use the comedi_device parameter that is passed to this function to find
    the dev->iobase so it does not have to be included in each call.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 7a8ff2598281..819eeec9d20d 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -195,18 +195,18 @@ static void labpc_counter_load(struct comedi_device *dev,
 }
 
 static void labpc_counter_set_mode(struct comedi_device *dev,
-				   unsigned long base_address,
+				   unsigned long reg,
 				   unsigned int counter_number,
 				   unsigned int mode)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 
 	if (board->has_mmio) {
-		void __iomem *mmio_base = (void __iomem *)base_address;
+		void __iomem *mmio = (void __iomem *)dev->iobase;
 
-		i8254_mm_set_mode(mmio_base, 0, counter_number, mode);
+		i8254_mm_set_mode(mmio + reg, 0, counter_number, mode);
 	} else {
-		i8254_set_mode(base_address, 0, counter_number, mode);
+		i8254_set_mode(dev->iobase + reg, 0, counter_number, mode);
 	}
 }
 
@@ -360,8 +360,7 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 	devpriv->write_byte(dev, devpriv->cmd4, CMD4_REG);
 
 	/* initialize pacer counter to prevent any problems */
-	labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
-			       0, I8254_MODE2);
+	labpc_counter_set_mode(dev, COUNTER_A_BASE_REG, 0, I8254_MODE2);
 
 	labpc_clear_adc_fifo(dev);
 
@@ -759,8 +758,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				   1, 3, I8254_MODE0);
 	} else	{
 		/* just put counter a1 in mode 0 to set its output low */
-		labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
-				       1, I8254_MODE0);
+		labpc_counter_set_mode(dev, COUNTER_A_BASE_REG, 1, I8254_MODE0);
 	}
 
 	/* figure out what method we will use to transfer data */
@@ -814,8 +812,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				   0, devpriv->divisor_a0, I8254_MODE2);
 	} else {
 		/* initialize pacer counter to prevent any problems */
-		labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
-				       0, I8254_MODE2);
+		labpc_counter_set_mode(dev, COUNTER_A_BASE_REG, 0, I8254_MODE2);
 	}
 
 	/*  set up scan pacing */

commit 3f1ecb9b429eb909cee4ab35b34cb8de5e0b3f78
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jul 29 15:01:40 2014 -0700

    staging: comedi: ni_labpc: don't pass dev->iobase to labpc_counter_load()
    
    Use the comedi_device parameter that is passed to this function to find
    the dev->iobase so it does not have to be included in each call.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 90ce57f72fc3..7a8ff2598281 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -176,7 +176,7 @@ static const struct labpc_boardinfo labpc_boards[] = {
 #endif
 
 static void labpc_counter_load(struct comedi_device *dev,
-			       unsigned long base_address,
+			       unsigned long reg,
 			       unsigned int counter_number,
 			       unsigned int count,
 			       unsigned int mode)
@@ -184,13 +184,13 @@ static void labpc_counter_load(struct comedi_device *dev,
 	const struct labpc_boardinfo *board = comedi_board(dev);
 
 	if (board->has_mmio) {
-		void __iomem *mmio_base = (void __iomem *)base_address;
+		void __iomem *mmio = (void __iomem *)dev->iobase;
 
-		i8254_mm_set_mode(mmio_base, 0, counter_number, mode);
-		i8254_mm_write(mmio_base, 0, counter_number, count);
+		i8254_mm_set_mode(mmio + reg, 0, counter_number, mode);
+		i8254_mm_write(mmio + reg, 0, counter_number, count);
 	} else {
-		i8254_set_mode(base_address, 0, counter_number, mode);
-		i8254_write(base_address, 0, counter_number, count);
+		i8254_set_mode(dev->iobase + reg, 0, counter_number, mode);
+		i8254_write(dev->iobase + reg, 0, counter_number, count);
 	}
 }
 
@@ -755,7 +755,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * load counter a1 with count of 3
 		 * (pc+ manual says this is minimum allowed) using mode 0
 		 */
-		labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
+		labpc_counter_load(dev, COUNTER_A_BASE_REG,
 				   1, 3, I8254_MODE0);
 	} else	{
 		/* just put counter a1 in mode 0 to set its output low */
@@ -804,13 +804,13 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/*  set up pacing */
 		labpc_adc_timing(dev, cmd, mode);
 		/*  load counter b0 in mode 3 */
-		labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
+		labpc_counter_load(dev, COUNTER_B_BASE_REG,
 				   0, devpriv->divisor_b0, I8254_MODE3);
 	}
 	/*  set up conversion pacing */
 	if (labpc_ai_convert_period(cmd, mode)) {
 		/*  load counter a0 in mode 2 */
-		labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
+		labpc_counter_load(dev, COUNTER_A_BASE_REG,
 				   0, devpriv->divisor_a0, I8254_MODE2);
 	} else {
 		/* initialize pacer counter to prevent any problems */
@@ -821,7 +821,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  set up scan pacing */
 	if (labpc_ai_scan_period(cmd, mode)) {
 		/*  load counter b1 in mode 2 */
-		labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
+		labpc_counter_load(dev, COUNTER_B_BASE_REG,
 				   1, devpriv->divisor_b1, I8254_MODE2);
 	}
 

commit ac482be4b6312263ffd5101dc5e560d55c00b571
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jul 29 15:01:39 2014 -0700

    staging: comedi: ni_labpc: pass comedi_device to the I/O callbacks
    
    This driver uses some callbacks in the private data to handle the
    port mapped or memory mapped I/O used to access the hardware.
    
    Pass the comedi_device pointer to the helper functions so that the
    base address can be found and does not need to be included in each
    call.
    
    Also, remove the inline from the helper functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 51a6d4e78c04..90ce57f72fc3 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -128,24 +128,30 @@ static const struct comedi_lrange range_labpc_ao = {
 
 /* functions that do inb/outb and readb/writeb so we can use
  * function pointers to decide which to use */
-static inline unsigned int labpc_inb(unsigned long address)
+static unsigned int labpc_inb(struct comedi_device *dev, unsigned long reg)
 {
-	return inb(address);
+	return inb(dev->iobase + reg);
 }
 
-static inline void labpc_outb(unsigned int byte, unsigned long address)
+static void labpc_outb(struct comedi_device *dev,
+		       unsigned int byte, unsigned long reg)
 {
-	outb(byte, address);
+	outb(byte, dev->iobase + reg);
 }
 
-static inline unsigned int labpc_readb(unsigned long address)
+static unsigned int labpc_readb(struct comedi_device *dev, unsigned long reg)
 {
-	return readb((void __iomem *)address);
+	void __iomem *mmio = (void __iomem *)dev->iobase;
+
+	return readb(mmio + reg);
 }
 
-static inline void labpc_writeb(unsigned int byte, unsigned long address)
+static void labpc_writeb(struct comedi_device *dev,
+			 unsigned int byte, unsigned long reg)
 {
-	writeb(byte, (void __iomem *)address);
+	void __iomem *mmio = (void __iomem *)dev->iobase;
+
+	writeb(byte, mmio + reg);
 }
 
 #if IS_ENABLED(CONFIG_COMEDI_NI_LABPC_ISA)
@@ -211,11 +217,11 @@ static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->cmd2 &= ~(CMD2_SWTRIG | CMD2_HWTRIG | CMD2_PRETRIG);
-	devpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);
+	devpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	devpriv->cmd3 = 0;
-	devpriv->write_byte(devpriv->cmd3, dev->iobase + CMD3_REG);
+	devpriv->write_byte(dev, devpriv->cmd3, CMD3_REG);
 
 	return 0;
 }
@@ -245,7 +251,7 @@ static void labpc_ai_set_chan_and_gain(struct comedi_device *dev,
 	devpriv->cmd1 = CMD1_MA(chan);
 	devpriv->cmd1 |= CMD1_GAIN(range);
 
-	devpriv->write_byte(devpriv->cmd1, dev->iobase + CMD1_REG);
+	devpriv->write_byte(dev, devpriv->cmd1, CMD1_REG);
 }
 
 static void labpc_setup_cmd6_reg(struct comedi_device *dev,
@@ -292,14 +298,14 @@ static void labpc_setup_cmd6_reg(struct comedi_device *dev,
 	else
 		devpriv->cmd6 &= ~CMD6_SCANUP;
 
-	devpriv->write_byte(devpriv->cmd6, dev->iobase + CMD6_REG);
+	devpriv->write_byte(dev, devpriv->cmd6, CMD6_REG);
 }
 
 static unsigned int labpc_read_adc_fifo(struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
-	unsigned int lsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
-	unsigned int msb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+	unsigned int lsb = devpriv->read_byte(dev, ADC_FIFO_REG);
+	unsigned int msb = devpriv->read_byte(dev, ADC_FIFO_REG);
 
 	return (msb << 8) | lsb;
 }
@@ -308,7 +314,7 @@ static void labpc_clear_adc_fifo(struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
 
-	devpriv->write_byte(0x1, dev->iobase + ADC_FIFO_CLEAR_REG);
+	devpriv->write_byte(dev, 0x1, ADC_FIFO_CLEAR_REG);
 	labpc_read_adc_fifo(dev);
 }
 
@@ -319,7 +325,7 @@ static int labpc_ai_eoc(struct comedi_device *dev,
 {
 	struct labpc_private *devpriv = dev->private;
 
-	devpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);
+	devpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);
 	if (devpriv->stat1 & STAT1_DAVAIL)
 		return 0;
 	return -EBUSY;
@@ -351,7 +357,7 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 	/* single-ended/differential */
 	if (aref == AREF_DIFF)
 		devpriv->cmd4 |= CMD4_SEDIFF;
-	devpriv->write_byte(devpriv->cmd4, dev->iobase + CMD4_REG);
+	devpriv->write_byte(dev, devpriv->cmd4, CMD4_REG);
 
 	/* initialize pacer counter to prevent any problems */
 	labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
@@ -361,7 +367,7 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 
 	for (i = 0; i < insn->n; i++) {
 		/* trigger conversion */
-		devpriv->write_byte(0x1, dev->iobase + ADC_START_CONVERT_REG);
+		devpriv->write_byte(dev, 0x1, ADC_START_CONVERT_REG);
 
 		ret = comedi_timeout(dev, s, insn, labpc_ai_eoc, 0);
 		if (ret)
@@ -786,13 +792,12 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * list will get screwed when you switch
 		 * between scan up to scan down mode - dunno why */
 		udelay(1);
-		devpriv->write_byte(devpriv->cmd1, dev->iobase + CMD1_REG);
+		devpriv->write_byte(dev, devpriv->cmd1, CMD1_REG);
 	}
 
-	devpriv->write_byte(cmd->chanlist_len,
-			    dev->iobase + INTERVAL_COUNT_REG);
+	devpriv->write_byte(dev, cmd->chanlist_len, INTERVAL_COUNT_REG);
 	/*  load count */
-	devpriv->write_byte(0x1, dev->iobase + INTERVAL_STROBE_REG);
+	devpriv->write_byte(dev, 0x1, INTERVAL_STROBE_REG);
 
 	if (cmd->convert_src == TRIG_TIMER ||
 	    cmd->scan_begin_src == TRIG_TIMER) {
@@ -830,7 +835,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  enable fifo not empty interrupt? */
 	if (xfer == fifo_not_empty_transfer)
 		devpriv->cmd3 |= CMD3_FIFOINTEN;
-	devpriv->write_byte(devpriv->cmd3, dev->iobase + CMD3_REG);
+	devpriv->write_byte(dev, devpriv->cmd3, CMD3_REG);
 
 	/*  setup any external triggering/pacing (cmd4 register) */
 	devpriv->cmd4 = 0;
@@ -846,7 +851,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  single-ended/differential */
 	if (aref == AREF_DIFF)
 		devpriv->cmd4 |= CMD4_SEDIFF;
-	devpriv->write_byte(devpriv->cmd4, dev->iobase + CMD4_REG);
+	devpriv->write_byte(dev, devpriv->cmd4, CMD4_REG);
 
 	/*  startup acquisition */
 
@@ -863,7 +868,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->stop_src == TRIG_EXT)
 		devpriv->cmd2 |= (CMD2_HWTRIG | CMD2_PRETRIG);
 
-	devpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);
+	devpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -880,7 +885,7 @@ static int labpc_drain_fifo(struct comedi_device *dev)
 	const int timeout = 10000;
 	unsigned int i;
 
-	devpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);
+	devpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);
 
 	for (i = 0; (devpriv->stat1 & STAT1_DAVAIL) && i < timeout;
 	     i++) {
@@ -892,7 +897,7 @@ static int labpc_drain_fifo(struct comedi_device *dev)
 		}
 		data = labpc_read_adc_fifo(dev);
 		cfc_write_to_buffer(dev->read_subdev, data);
-		devpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);
+		devpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);
 	}
 	if (i == timeout) {
 		dev_err(dev->class_dev, "ai timeout, fifo never empties\n");
@@ -934,9 +939,9 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	cmd = &async->cmd;
 
 	/* read board status */
-	devpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);
+	devpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);
 	if (board->is_labpc1200)
-		devpriv->stat2 = devpriv->read_byte(dev->iobase + STAT2_REG);
+		devpriv->stat2 = devpriv->read_byte(dev, STAT2_REG);
 
 	if ((devpriv->stat1 & (STAT1_GATA0 | STAT1_CNTINT | STAT1_OVERFLOW |
 			       STAT1_OVERRUN | STAT1_DAVAIL)) == 0
@@ -947,7 +952,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 
 	if (devpriv->stat1 & STAT1_OVERRUN) {
 		/* clear error interrupt */
-		devpriv->write_byte(0x1, dev->iobase + ADC_FIFO_CLEAR_REG);
+		devpriv->write_byte(dev, 0x1, ADC_FIFO_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		cfc_handle_events(dev, s);
 		dev_err(dev->class_dev, "overrun\n");
@@ -962,12 +967,12 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	if (devpriv->stat1 & STAT1_CNTINT) {
 		dev_err(dev->class_dev, "handled timer interrupt?\n");
 		/*  clear it */
-		devpriv->write_byte(0x1, dev->iobase + TIMER_CLEAR_REG);
+		devpriv->write_byte(dev, 0x1, TIMER_CLEAR_REG);
 	}
 
 	if (devpriv->stat1 & STAT1_OVERFLOW) {
 		/*  clear error interrupt */
-		devpriv->write_byte(0x1, dev->iobase + ADC_FIFO_CLEAR_REG);
+		devpriv->write_byte(dev, 0x1, ADC_FIFO_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		cfc_handle_events(dev, s);
 		dev_err(dev->class_dev, "overflow\n");
@@ -1009,7 +1014,7 @@ static int labpc_ao_insn_write(struct comedi_device *dev,
 	 * be independently enabled/disabled for its the two channels */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->cmd2 &= ~CMD2_LDAC(channel);
-	devpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);
+	devpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* set range */
@@ -1020,13 +1025,13 @@ static int labpc_ao_insn_write(struct comedi_device *dev,
 		else
 			devpriv->cmd6 &= ~CMD6_DACUNI(channel);
 		/*  write to register */
-		devpriv->write_byte(devpriv->cmd6, dev->iobase + CMD6_REG);
+		devpriv->write_byte(dev, devpriv->cmd6, CMD6_REG);
 	}
 	/* send data */
 	lsb = data[0] & 0xff;
 	msb = (data[0] >> 8) & 0xff;
-	devpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(channel));
-	devpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(channel));
+	devpriv->write_byte(dev, lsb, DAC_LSB_REG(channel));
+	devpriv->write_byte(dev, msb, DAC_MSB_REG(channel));
 
 	/* remember value for readback */
 	devpriv->ao_value[channel] = data[0];
@@ -1072,11 +1077,11 @@ static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
 		else
 			devpriv->cmd5 &= ~CMD5_SDATA;
 		udelay(1);
-		devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+		devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 		/*  set clock to load bit */
 		devpriv->cmd5 |= CMD5_SCLK;
 		udelay(1);
-		devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+		devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 	}
 }
 
@@ -1092,14 +1097,14 @@ static unsigned int labpc_serial_in(struct comedi_device *dev)
 		/*  set serial clock */
 		devpriv->cmd5 |= CMD5_SCLK;
 		udelay(1);
-		devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+		devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 		/*  clear clock bit */
 		devpriv->cmd5 &= ~CMD5_SCLK;
 		udelay(1);
-		devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+		devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 		/*  read bits most significant bit first */
 		udelay(1);
-		devpriv->stat2 = devpriv->read_byte(dev->iobase + STAT2_REG);
+		devpriv->stat2 = devpriv->read_byte(dev, STAT2_REG);
 		if (devpriv->stat2 & STAT2_PROMOUT)
 			value |= 1 << (value_width - i);
 	}
@@ -1120,10 +1125,10 @@ static unsigned int labpc_eeprom_read(struct comedi_device *dev,
 	/*  enable read/write to eeprom */
 	devpriv->cmd5 &= ~CMD5_EEPROMCS;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 	devpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 
 	/*  send read instruction */
 	labpc_serial_out(dev, read_instruction, write_length);
@@ -1135,7 +1140,7 @@ static unsigned int labpc_eeprom_read(struct comedi_device *dev,
 	/*  disable read/write to eeprom */
 	devpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 
 	return value;
 }
@@ -1150,10 +1155,10 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
 	/*  enable read/write to eeprom */
 	devpriv->cmd5 &= ~CMD5_EEPROMCS;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 	devpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 
 	/*  send read status instruction */
 	labpc_serial_out(dev, read_status_instruction, write_length);
@@ -1163,7 +1168,7 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
 	/*  disable read/write to eeprom */
 	devpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 
 	return value;
 }
@@ -1195,21 +1200,21 @@ static int labpc_eeprom_write(struct comedi_device *dev,
 	/*  enable read/write to eeprom */
 	devpriv->cmd5 &= ~CMD5_EEPROMCS;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 	devpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 
 	/*  send write_enable instruction */
 	labpc_serial_out(dev, write_enable_instruction, write_length);
 	devpriv->cmd5 &= ~CMD5_EEPROMCS;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 
 	/*  send write instruction */
 	devpriv->cmd5 |= CMD5_EEPROMCS;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 	labpc_serial_out(dev, write_instruction, write_length);
 	/*  send 8 bit address to write to */
 	labpc_serial_out(dev, address, write_length);
@@ -1217,12 +1222,12 @@ static int labpc_eeprom_write(struct comedi_device *dev,
 	labpc_serial_out(dev, value, write_length);
 	devpriv->cmd5 &= ~CMD5_EEPROMCS;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 
 	/*  disable read/write to eeprom */
 	devpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 
 	return 0;
 }
@@ -1240,7 +1245,7 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	/*  clear caldac load bit and make sure we don't write to eeprom */
 	devpriv->cmd5 &= ~(CMD5_CALDACLD | CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 
 	/*  write 4 bit channel */
 	labpc_serial_out(dev, channel, 4);
@@ -1250,10 +1255,10 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	/*  set and clear caldac bit to load caldac value */
 	devpriv->cmd5 |= CMD5_CALDACLD;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 	devpriv->cmd5 &= ~CMD5_CALDACLD;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
 }
 
 static int labpc_calib_insn_write(struct comedi_device *dev,
@@ -1346,13 +1351,13 @@ int labpc_common_attach(struct comedi_device *dev,
 	}
 
 	/* initialize board's command registers */
-	devpriv->write_byte(devpriv->cmd1, dev->iobase + CMD1_REG);
-	devpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);
-	devpriv->write_byte(devpriv->cmd3, dev->iobase + CMD3_REG);
-	devpriv->write_byte(devpriv->cmd4, dev->iobase + CMD4_REG);
+	devpriv->write_byte(dev, devpriv->cmd1, CMD1_REG);
+	devpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);
+	devpriv->write_byte(dev, devpriv->cmd3, CMD3_REG);
+	devpriv->write_byte(dev, devpriv->cmd4, CMD4_REG);
 	if (board->is_labpc1200) {
-		devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
-		devpriv->write_byte(devpriv->cmd6, dev->iobase + CMD6_REG);
+		devpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);
+		devpriv->write_byte(dev, devpriv->cmd6, CMD6_REG);
 	}
 
 	if (irq) {
@@ -1402,8 +1407,8 @@ int labpc_common_attach(struct comedi_device *dev,
 			devpriv->ao_value[i] = s->maxdata / 2;
 			lsb = devpriv->ao_value[i] & 0xff;
 			msb = (devpriv->ao_value[i] >> 8) & 0xff;
-			devpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(i));
-			devpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(i));
+			devpriv->write_byte(dev, lsb, DAC_LSB_REG(i));
+			devpriv->write_byte(dev, msb, DAC_MSB_REG(i));
 		}
 	} else {
 		s->type		= COMEDI_SUBD_UNUSED;

commit 862755ec07572036b0c69d738b88f89b6beede99
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:22 2014 -0700

    staging: comedi: drivers: remove unnecessary *_SIZE defines
    
    Some of the legacy comedi drivers have a *_SIZE define that is only
    passed to comedi_request_region() to specify the size of the region.
    
    Some of the pnp drivers (pci, etc.) also have a *_SIZE define which
    is unused.
    
    For aesthetics, remove these defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 8b41813ebf65..51a6d4e78c04 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -72,8 +72,6 @@
 #include "ni_labpc_regs.h"
 #include "ni_labpc_isadma.h"
 
-#define LABPC_SIZE		0x20	/* size of ISA io region */
-
 enum scan_mode {
 	MODE_SINGLE_CHAN,
 	MODE_SINGLE_CHAN_INTERVAL,
@@ -1465,7 +1463,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!devpriv)
 		return -ENOMEM;
 
-	ret = comedi_request_region(dev, it->options[0], LABPC_SIZE);
+	ret = comedi_request_region(dev, it->options[0], 0x20);
 	if (ret)
 		return ret;
 

commit 2042088cd67d0064d18c52c13c69af2499907bb1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 12:27:31 2014 -0700

    staging: comedi: ni_labpc: tidy up labpc_ai_scan_mode()
    
    This function checks the cmd->chanlist to determine the scan mode
    used to sample the analog inputs. All possible modes are checked
    so the final pr_err() and return 0 can never be reached.
    
    Tidy up the function a bit and remove the unreachable code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 6fb405eb0933..8b41813ebf65 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -531,24 +531,26 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
 
 static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)
 {
+	unsigned int chan0;
+	unsigned int chan1;
+
 	if (cmd->chanlist_len == 1)
 		return MODE_SINGLE_CHAN;
 
-	/* chanlist may be NULL during cmdtest. */
+	/* chanlist may be NULL during cmdtest */
 	if (cmd->chanlist == NULL)
 		return MODE_MULT_CHAN_UP;
 
-	if (CR_CHAN(cmd->chanlist[0]) == CR_CHAN(cmd->chanlist[1]))
-		return MODE_SINGLE_CHAN_INTERVAL;
+	chan0 = CR_CHAN(cmd->chanlist[0]);
+	chan1 = CR_CHAN(cmd->chanlist[1]);
 
-	if (CR_CHAN(cmd->chanlist[0]) < CR_CHAN(cmd->chanlist[1]))
+	if (chan0 < chan1)
 		return MODE_MULT_CHAN_UP;
 
-	if (CR_CHAN(cmd->chanlist[0]) > CR_CHAN(cmd->chanlist[1]))
+	if (chan0 > chan1)
 		return MODE_MULT_CHAN_DOWN;
 
-	pr_err("ni_labpc: bug! cannot determine AI scan mode\n");
-	return 0;
+	return MODE_SINGLE_CHAN_INTERVAL;
 }
 
 static int labpc_ai_check_chanlist(struct comedi_device *dev,

commit b3780f1da1b1d4e0af32b0f71b590b2bfd9c3e63
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:34 2014 -0700

    staging: comedi: ni_labpc: remove use of comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character. The addition of the driver_name is just added noise
    and some of the users of comedi_error() add unnecessary additional new-line
    characters.
    
    Use dev_err() directly instead of comedi_error() to avoid any confusion
    and so that all the comedi generated kernel messages have the same format.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 34ffa2e43657..6fb405eb0933 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -895,7 +895,7 @@ static int labpc_drain_fifo(struct comedi_device *dev)
 		devpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);
 	}
 	if (i == timeout) {
-		comedi_error(dev, "ai timeout, fifo never empties");
+		dev_err(dev->class_dev, "ai timeout, fifo never empties\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		return -1;
 	}
@@ -926,7 +926,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	struct comedi_cmd *cmd;
 
 	if (!dev->attached) {
-		comedi_error(dev, "premature interrupt");
+		dev_err(dev->class_dev, "premature interrupt\n");
 		return IRQ_HANDLED;
 	}
 
@@ -950,7 +950,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 		devpriv->write_byte(0x1, dev->iobase + ADC_FIFO_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		cfc_handle_events(dev, s);
-		comedi_error(dev, "overrun");
+		dev_err(dev->class_dev, "overrun\n");
 		return IRQ_HANDLED;
 	}
 
@@ -960,7 +960,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 		labpc_drain_fifo(dev);
 
 	if (devpriv->stat1 & STAT1_CNTINT) {
-		comedi_error(dev, "handled timer interrupt?");
+		dev_err(dev->class_dev, "handled timer interrupt?\n");
 		/*  clear it */
 		devpriv->write_byte(0x1, dev->iobase + TIMER_CLEAR_REG);
 	}
@@ -970,7 +970,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 		devpriv->write_byte(0x1, dev->iobase + ADC_FIFO_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		cfc_handle_events(dev, s);
-		comedi_error(dev, "overflow");
+		dev_err(dev->class_dev, "overflow\n");
 		return IRQ_HANDLED;
 	}
 	/*  handle external stop trigger */
@@ -1186,7 +1186,7 @@ static int labpc_eeprom_write(struct comedi_device *dev,
 			break;
 	}
 	if (i == timeout) {
-		comedi_error(dev, "eeprom write timed out");
+		dev_err(dev->class_dev, "eeprom write timed out\n");
 		return -ETIME;
 	}
 	/*  update software copy of eeprom */

commit d88e3da90f5210f859b19a11a00fa4d539eb7dbd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:40 2014 -0700

    staging: comedi: ni_labpc: checkpatch.pl cleanup (else is not useful)
    
    Fix the checkpatch.pl warning:
    
    WARNING: else is not generally useful after a break or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 3e3f940fa57c..34ffa2e43657 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1051,9 +1051,9 @@ static int labpc_8255_mmio(int dir, int port, int data, unsigned long iobase)
 	if (dir) {
 		writeb(data, (void __iomem *)(iobase + port));
 		return 0;
-	} else {
-		return readb((void __iomem *)(iobase + port));
 	}
+
+	return readb((void __iomem *)(iobase + port));
 }
 
 /* lowlevel write to eeprom/dac */

commit b727a91f59df86f022f868522fd0d1f9d294ca0b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:31:02 2014 -0700

    staging: comedi: ni_labpc: use comedi_cmd pointer
    
    Use a local variable to access the comedi_cmd as a pointer instead
    of getting to from the comedi_async pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index c6e914dc70cf..3e3f940fa57c 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -874,8 +874,9 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int labpc_drain_fifo(struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
-	unsigned short data;
 	struct comedi_async *async = dev->read_subdev->async;
+	struct comedi_cmd *cmd = &async->cmd;
+	unsigned short data;
 	const int timeout = 10000;
 	unsigned int i;
 
@@ -884,7 +885,7 @@ static int labpc_drain_fifo(struct comedi_device *dev)
 	for (i = 0; (devpriv->stat1 & STAT1_DAVAIL) && i < timeout;
 	     i++) {
 		/*  quit if we have all the data we want */
-		if (async->cmd.stop_src == TRIG_COUNT) {
+		if (cmd->stop_src == TRIG_COUNT) {
 			if (devpriv->count == 0)
 				break;
 			devpriv->count--;

commit e74e98993da8dff62190c937d4371eda962e64b9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 29 12:59:56 2014 -0700

    staging: comedi: ni_labpc: fix 8254 timer programming
    
    As pointed out by Ian Abbott, the i8254_load() function does not
    use the I8254_MODE* values to specify the "mode".
    
    The labpc_counter_load() function in this driver is passed an
    I8254_MODE* value so we need to use the i8254_set_mode() and
    i8254_write() helpers instead of i8254_load() to program the
    timers.
    
    The calls to labpc_counter_load() will not fail so change the
    return to void and remove all the unnecessary error handling.
    
    Similarly, change the return type of labpc_counter_set_mode() to
    void and remove the unnecessary error handling.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index fc9d31420956..c6e914dc70cf 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -171,32 +171,39 @@ static const struct labpc_boardinfo labpc_boards[] = {
 };
 #endif
 
-static int labpc_counter_load(struct comedi_device *dev,
-			      unsigned long base_address,
-			      unsigned int counter_number,
-			      unsigned int count, unsigned int mode)
+static void labpc_counter_load(struct comedi_device *dev,
+			       unsigned long base_address,
+			       unsigned int counter_number,
+			       unsigned int count,
+			       unsigned int mode)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 
-	if (board->has_mmio)
-		return i8254_mm_load((void __iomem *)base_address, 0,
-				     counter_number, count, mode);
-	else
-		return i8254_load(base_address, 0, counter_number, count, mode);
+	if (board->has_mmio) {
+		void __iomem *mmio_base = (void __iomem *)base_address;
+
+		i8254_mm_set_mode(mmio_base, 0, counter_number, mode);
+		i8254_mm_write(mmio_base, 0, counter_number, count);
+	} else {
+		i8254_set_mode(base_address, 0, counter_number, mode);
+		i8254_write(base_address, 0, counter_number, count);
+	}
 }
 
-static int labpc_counter_set_mode(struct comedi_device *dev,
-				  unsigned long base_address,
-				  unsigned int counter_number,
-				  unsigned int mode)
+static void labpc_counter_set_mode(struct comedi_device *dev,
+				   unsigned long base_address,
+				   unsigned int counter_number,
+				   unsigned int mode)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 
-	if (board->has_mmio)
-		return i8254_mm_set_mode((void __iomem *)base_address, 0,
-					 counter_number, mode);
-	else
-		return i8254_set_mode(base_address, 0, counter_number, mode);
+	if (board->has_mmio) {
+		void __iomem *mmio_base = (void __iomem *)base_address;
+
+		i8254_mm_set_mode(mmio_base, 0, counter_number, mode);
+	} else {
+		i8254_set_mode(base_address, 0, counter_number, mode);
+	}
 }
 
 static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -349,10 +356,8 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 	devpriv->write_byte(devpriv->cmd4, dev->iobase + CMD4_REG);
 
 	/* initialize pacer counter to prevent any problems */
-	ret = labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
-				     0, I8254_MODE2);
-	if (ret)
-		return ret;
+	labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
+			       0, I8254_MODE2);
 
 	labpc_clear_adc_fifo(dev);
 
@@ -730,7 +735,6 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned int aref = CR_AREF(chanspec);
 	enum transfer_type xfer;
 	unsigned long flags;
-	int ret;
 
 	/* make sure board is disabled before setting up acquisition */
 	labpc_cancel(dev, s);
@@ -745,17 +749,12 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * load counter a1 with count of 3
 		 * (pc+ manual says this is minimum allowed) using mode 0
 		 */
-		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
-					 1, 3, I8254_MODE0);
+		labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
+				   1, 3, I8254_MODE0);
 	} else	{
 		/* just put counter a1 in mode 0 to set its output low */
-		ret = labpc_counter_set_mode(dev,
-					     dev->iobase + COUNTER_A_BASE_REG,
-					     1, I8254_MODE0);
-	}
-	if (ret) {
-		comedi_error(dev, "error loading counter a1");
-		return ret;
+		labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
+				       1, I8254_MODE0);
 	}
 
 	/* figure out what method we will use to transfer data */
@@ -800,38 +799,25 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/*  set up pacing */
 		labpc_adc_timing(dev, cmd, mode);
 		/*  load counter b0 in mode 3 */
-		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
-					 0, devpriv->divisor_b0, I8254_MODE3);
-		if (ret < 0) {
-			comedi_error(dev, "error loading counter b0");
-			return -1;
-		}
+		labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
+				   0, devpriv->divisor_b0, I8254_MODE3);
 	}
 	/*  set up conversion pacing */
 	if (labpc_ai_convert_period(cmd, mode)) {
 		/*  load counter a0 in mode 2 */
-		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
-					 0, devpriv->divisor_a0, I8254_MODE2);
+		labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
+				   0, devpriv->divisor_a0, I8254_MODE2);
 	} else {
 		/* initialize pacer counter to prevent any problems */
-		ret = labpc_counter_set_mode(dev,
-					     dev->iobase + COUNTER_A_BASE_REG,
-					     0, I8254_MODE2);
-	}
-	if (ret) {
-		comedi_error(dev, "error loading counter a0");
-		return ret;
+		labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
+				       0, I8254_MODE2);
 	}
 
 	/*  set up scan pacing */
 	if (labpc_ai_scan_period(cmd, mode)) {
 		/*  load counter b1 in mode 2 */
-		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
-					 1, devpriv->divisor_b1, I8254_MODE2);
-		if (ret < 0) {
-			comedi_error(dev, "error loading counter b1");
-			return -1;
-		}
+		labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
+				   1, devpriv->divisor_b1, I8254_MODE2);
 	}
 
 	labpc_clear_adc_fifo(dev);

commit c55881686302a5e7f19b82f0a163beec2cc314c3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:08:04 2014 -0700

    staging: comedi: ni_labpc: clarify the cmd->start_arg validation
    
    This driver supports cmd->start_src sources of TRIG_NOW and TRIG_EXT.
    Refactor the (*do_cmdtest) to clarify the trivial validation of the
    cmd->start_arg.
    
    This also fixes a bug, the cmd->start_src has the trigger not the
    cmd->start_arg.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index f80ca3278314..fc9d31420956 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -649,8 +649,14 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_arg == TRIG_NOW)
+	switch (cmd->start_src) {
+	case TRIG_NOW:
 		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		break;
+	case TRIG_EXT:
+		/* start_arg value is ignored */
+		break;
+	}
 
 	if (!cmd->chanlist_len)
 		err |= -EINVAL;

commit 5089b058966c4f6a5ca33556ca8c3bc88be0ab4c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 16 14:19:21 2014 -0700

    staging: comedi: ni_labpc: tidy up the chanlist checking
    
    The labpc_ai_chanlist_invalid() function validates that the cmd->chanlist
    is compatible with the hardware. This is step 5 of the (*do_cmdtest).
    
    For aesthetics, rename this function and tidy up the code.
    
    To minimize the noise, change the comedi_error(), which is a wrapper around
    dev_err(), to dev_dbg().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index f4216e825f03..f80ca3278314 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -546,72 +546,60 @@ static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)
 	return 0;
 }
 
-static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
-				     const struct comedi_cmd *cmd,
-				     enum scan_mode mode)
+static int labpc_ai_check_chanlist(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_cmd *cmd)
 {
-	int channel, range, aref, i;
-
-	if (cmd->chanlist == NULL)
-		return 0;
+	enum scan_mode mode = labpc_ai_scan_mode(cmd);
+	unsigned int chan0 = CR_CHAN(cmd->chanlist[0]);
+	unsigned int range0 = CR_RANGE(cmd->chanlist[0]);
+	unsigned int aref0 = CR_AREF(cmd->chanlist[0]);
+	int i;
 
 	if (mode == MODE_SINGLE_CHAN)
 		return 0;
 
-	if (mode == MODE_SINGLE_CHAN_INTERVAL) {
-		if (cmd->chanlist_len > 0xff) {
-			comedi_error(dev,
-				     "ni_labpc: chanlist too long for single channel interval mode\n");
-			return 1;
-		}
-	}
-
-	channel = CR_CHAN(cmd->chanlist[0]);
-	range = CR_RANGE(cmd->chanlist[0]);
-	aref = CR_AREF(cmd->chanlist[0]);
-
 	for (i = 0; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+		unsigned int range = CR_RANGE(cmd->chanlist[i]);
+		unsigned int aref = CR_AREF(cmd->chanlist[i]);
 
 		switch (mode) {
+		case MODE_SINGLE_CHAN:
+			break;
 		case MODE_SINGLE_CHAN_INTERVAL:
-			if (CR_CHAN(cmd->chanlist[i]) != channel) {
-				comedi_error(dev,
-					     "channel scanning order specified in chanlist is not supported by hardware.\n");
-				return 1;
+			if (chan != chan0) {
+				dev_dbg(dev->class_dev,
+					"channel scanning order specified in chanlist is not supported by hardware\n");
+				return -EINVAL;
 			}
 			break;
 		case MODE_MULT_CHAN_UP:
-			if (CR_CHAN(cmd->chanlist[i]) != i) {
-				comedi_error(dev,
-					     "channel scanning order specified in chanlist is not supported by hardware.\n");
-				return 1;
+			if (chan != i) {
+				dev_dbg(dev->class_dev,
+					"channel scanning order specified in chanlist is not supported by hardware\n");
+				return -EINVAL;
 			}
 			break;
 		case MODE_MULT_CHAN_DOWN:
-			if (CR_CHAN(cmd->chanlist[i]) !=
-			    cmd->chanlist_len - i - 1) {
-				comedi_error(dev,
-					     "channel scanning order specified in chanlist is not supported by hardware.\n");
-				return 1;
+			if (chan != (cmd->chanlist_len - i - 1)) {
+				dev_dbg(dev->class_dev,
+					"channel scanning order specified in chanlist is not supported by hardware\n");
+				return -EINVAL;
 			}
 			break;
-		default:
-			dev_err(dev->class_dev,
-				"ni_labpc: bug! in chanlist check\n");
-			return 1;
-			break;
 		}
 
-		if (CR_RANGE(cmd->chanlist[i]) != range) {
-			comedi_error(dev,
-				     "entries in chanlist must all have the same range\n");
-			return 1;
+		if (range != range0) {
+			dev_dbg(dev->class_dev,
+				"entries in chanlist must all have the same range\n");
+			return -EINVAL;
 		}
 
-		if (CR_AREF(cmd->chanlist[i]) != aref) {
-			comedi_error(dev,
-				     "entries in chanlist must all have the same reference\n");
-			return 1;
+		if (aref != aref0) {
+			dev_dbg(dev->class_dev,
+				"entries in chanlist must all have the same reference\n");
+			return -EINVAL;
 		}
 	}
 
@@ -711,7 +699,11 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 4;
 
-	if (labpc_ai_chanlist_invalid(dev, cmd, mode))
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= labpc_ai_check_chanlist(dev, s, cmd);
+
+	if (err)
 		return 5;
 
 	return 0;

commit 3c5e6a62e363f194fffef9cde98ce6614b2815f8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:43 2014 -0700

    staging: comedi: ni_labpc: use cfc_handle_events()
    
    Use the comedi_fc helper function to automatically call the subdevice
    (*cancel) function when needed and call comedi_event().
    
    Also, remove the clearing of the events, comedi_event() does that.
    
    In the Kconfig, COMEDI_NI_LABPC already selects COMEDI_FC.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 037b46eb949f..f4216e825f03 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -947,7 +947,6 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 
 	async = s->async;
 	cmd = &async->cmd;
-	async->events = 0;
 
 	/* read board status */
 	devpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);
@@ -965,7 +964,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 		/* clear error interrupt */
 		devpriv->write_byte(0x1, dev->iobase + ADC_FIFO_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		comedi_event(dev, s);
+		cfc_handle_events(dev, s);
 		comedi_error(dev, "overrun");
 		return IRQ_HANDLED;
 	}
@@ -985,7 +984,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 		/*  clear error interrupt */
 		devpriv->write_byte(0x1, dev->iobase + ADC_FIFO_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		comedi_event(dev, s);
+		cfc_handle_events(dev, s);
 		comedi_error(dev, "overflow");
 		return IRQ_HANDLED;
 	}
@@ -993,20 +992,17 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	if (cmd->stop_src == TRIG_EXT) {
 		if (devpriv->stat2 & STAT2_OUTA1) {
 			labpc_drain_dregs(dev);
-			labpc_cancel(dev, s);
 			async->events |= COMEDI_CB_EOA;
 		}
 	}
 
 	/* TRIG_COUNT end of acquisition */
 	if (cmd->stop_src == TRIG_COUNT) {
-		if (devpriv->count == 0) {
-			labpc_cancel(dev, s);
+		if (devpriv->count == 0)
 			async->events |= COMEDI_CB_EOA;
-		}
 	}
 
-	comedi_event(dev, s);
+	cfc_handle_events(dev, s);
 	return IRQ_HANDLED;
 }
 

commit cf7b57fd6ab357198a327e0c74100e984bbf850f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:07 2014 -0700

    staging: comedi: ni_labpc: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input end-of-conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 0512445df08e..037b46eb949f 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -73,7 +73,6 @@
 #include "ni_labpc_isadma.h"
 
 #define LABPC_SIZE		0x20	/* size of ISA io region */
-#define LABPC_ADC_TIMEOUT	1000
 
 enum scan_mode {
 	MODE_SINGLE_CHAN,
@@ -308,19 +307,17 @@ static void labpc_clear_adc_fifo(struct comedi_device *dev)
 	labpc_read_adc_fifo(dev);
 }
 
-static int labpc_ai_wait_for_data(struct comedi_device *dev,
-				  int timeout)
+static int labpc_ai_eoc(struct comedi_device *dev,
+			struct comedi_subdevice *s,
+			struct comedi_insn *insn,
+			unsigned long context)
 {
 	struct labpc_private *devpriv = dev->private;
-	int i;
 
-	for (i = 0; i < timeout; i++) {
-		devpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);
-		if (devpriv->stat1 & STAT1_DAVAIL)
-			return 0;
-		udelay(1);
-	}
-	return -ETIME;
+	devpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);
+	if (devpriv->stat1 & STAT1_DAVAIL)
+		return 0;
+	return -EBUSY;
 }
 
 static int labpc_ai_insn_read(struct comedi_device *dev,
@@ -363,7 +360,7 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 		/* trigger conversion */
 		devpriv->write_byte(0x1, dev->iobase + ADC_START_CONVERT_REG);
 
-		ret = labpc_ai_wait_for_data(dev, LABPC_ADC_TIMEOUT);
+		ret = comedi_timeout(dev, s, insn, labpc_ai_eoc, 0);
 		if (ret)
 			return ret;
 

commit c0edd2c62765e76a03de48722d3d171aa6dd584a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:25 2013 +0100

    staging: comedi: ni_labpc: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Change the type of the `data` variable in `labpc_ai_cmd()` from `short`
    to `unsigned short` for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index e91570dd6b0d..0512445df08e 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -893,7 +893,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int labpc_drain_fifo(struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
-	short data;
+	unsigned short data;
 	struct comedi_async *async = dev->read_subdev->async;
 	const int timeout = 10000;
 	unsigned int i;

commit cb9cfd7ed3f6ed4c40167b4251cdb382b6b3ba1c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 26 11:40:15 2013 -0700

    staging: comedi: 8253.h: tidy up the i8253_cascade_ns_to_timer*() users
    
    Introduce a couple defines for the common 8254 oscillator base values
    used in the comedi drivers and remove the custom defines and open
    coded values.
    
    Change the i8253_cascade_ns_to_timer_2div() calls in the drivers to
    the more generic i8253_cascade_ns_to_timer(). They are identical due
    to the #define in the 8253.h header.
    
    Remove the extra mask by TRIG_ROUND_MASK of the 'round_mode' parameter
    to i8253_cascade_ns_to_timer(). That function already handles the mask.
    
    Tidy up all the calls to i8253_cascade_ns_to_timer().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 27daccb78f83..e91570dd6b0d 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -73,7 +73,6 @@
 #include "ni_labpc_isadma.h"
 
 #define LABPC_SIZE		0x20	/* size of ISA io region */
-#define LABPC_TIMER_BASE	500	/* 2 MHz master clock */
 #define LABPC_ADC_TIMEOUT	1000
 
 enum scan_mode {
@@ -459,13 +458,13 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
 		 * clock speed on convert and scan counters)
 		 */
 		devpriv->divisor_b0 = (scan_period - 1) /
-		    (LABPC_TIMER_BASE * max_counter_value) + 1;
+		    (I8254_OSC_BASE_2MHZ * max_counter_value) + 1;
 		if (devpriv->divisor_b0 < min_counter_value)
 			devpriv->divisor_b0 = min_counter_value;
 		if (devpriv->divisor_b0 > max_counter_value)
 			devpriv->divisor_b0 = max_counter_value;
 
-		base_period = LABPC_TIMER_BASE * devpriv->divisor_b0;
+		base_period = I8254_OSC_BASE_2MHZ * devpriv->divisor_b0;
 
 		/*  set a0 for conversion frequency and b1 for scan frequency */
 		switch (cmd->flags & TRIG_ROUND_MASK) {
@@ -510,22 +509,20 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
 		 * calculate cascaded counter values
 		 * that give desired scan timing
 		 */
-		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
-					       &(devpriv->divisor_b1),
-					       &(devpriv->divisor_b0),
-					       &scan_period,
-					       cmd->flags & TRIG_ROUND_MASK);
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_2MHZ,
+					  &devpriv->divisor_b1,
+					  &devpriv->divisor_b0,
+					  &scan_period, cmd->flags);
 		labpc_set_ai_scan_period(cmd, mode, scan_period);
 	} else if (convert_period) {
 		/*
 		 * calculate cascaded counter values
 		 * that give desired conversion timing
 		 */
-		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
-					       &(devpriv->divisor_a0),
-					       &(devpriv->divisor_b0),
-					       &convert_period,
-					       cmd->flags & TRIG_ROUND_MASK);
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_2MHZ,
+					  &devpriv->divisor_a0,
+					  &devpriv->divisor_b0,
+					  &convert_period, cmd->flags);
 		labpc_set_ai_convert_period(cmd, mode, convert_period);
 	}
 }

commit a49061af1fe303964a56e27e3884361809e4b004
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Aug 28 15:01:53 2013 -0700

    staging: comedi: ni_labpc: use comedi_range_is_unipolar()
    
    Use the core provided helper function instead of duplicating it as
    a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 1add114dc0bc..27daccb78f83 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -201,12 +201,6 @@ static int labpc_counter_set_mode(struct comedi_device *dev,
 		return i8254_set_mode(base_address, 0, counter_number, mode);
 }
 
-static bool labpc_range_is_unipolar(struct comedi_subdevice *s,
-				    unsigned int range)
-{
-	return s->range_table->range[range].min >= 0;
-}
-
 static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct labpc_private *devpriv = dev->private;
@@ -272,7 +266,7 @@ static void labpc_setup_cmd6_reg(struct comedi_device *dev,
 		devpriv->cmd6 &= ~CMD6_NRSE;
 
 	/* bipolar or unipolar range? */
-	if (labpc_range_is_unipolar(s, range))
+	if (comedi_range_is_unipolar(s, range))
 		devpriv->cmd6 |= CMD6_ADCUNI;
 	else
 		devpriv->cmd6 &= ~CMD6_ADCUNI;
@@ -1046,7 +1040,7 @@ static int labpc_ao_insn_write(struct comedi_device *dev,
 	/* set range */
 	if (board->is_labpc1200) {
 		range = CR_RANGE(insn->chanspec);
-		if (labpc_range_is_unipolar(s, range))
+		if (comedi_range_is_unipolar(s, range))
 			devpriv->cmd6 |= CMD6_DACUNI(channel);
 		else
 			devpriv->cmd6 &= ~CMD6_DACUNI(channel);

commit 72f2baeb75ba2e6e3ffbfb64890438f576f1d931
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 28 17:09:27 2013 +0100

    staging: comedi: ni_labpc: tidy up after DMA code migration
    
    After migrating the ISA DMA handling code to the "ni_labpc_isadma"
    module, get rid of an unneeded `#include` and a couple of unused
    static variables.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 57985a24dda4..1add114dc0bc 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -65,8 +65,6 @@
 
 #include "../comedidev.h"
 
-#include <asm/dma.h>
-
 #include "8253.h"
 #include "8255.h"
 #include "comedi_fc.h"
@@ -175,11 +173,6 @@ static const struct labpc_boardinfo labpc_boards[] = {
 };
 #endif
 
-/* size in bytes of dma buffer */
-static const int dma_buffer_size = 0xff00;
-/* 2 bytes per sample */
-static const int sample_size = 2;
-
 static int labpc_counter_load(struct comedi_device *dev,
 			      unsigned long base_address,
 			      unsigned int counter_number,

commit 9bd53e0398f490707549455c00475af4923df872
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 28 17:09:26 2013 +0100

    staging: comedi: ni_labpc: migrate DMA status handling
    
    Migrate the code for checking and handling the interrupt status handling
    for ISA DMA transfers into new a new function
    `labpc_handle_dma_status()` in the "ni_labpc_isadma" module.  Provide a
    dummy inline function in "ni_labpc_isadma.h" if the "ni_labpc_isadma"
    module is not being built.
    
    The static function `handle_isa_dma()` also needs to move across to the
    new module.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 818a8abe208c..57985a24dda4 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -905,20 +905,6 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-#ifdef CONFIG_ISA_DMA_API
-static void handle_isa_dma(struct comedi_device *dev)
-{
-	struct labpc_private *devpriv = dev->private;
-
-	labpc_drain_dma(dev);
-
-	enable_dma(devpriv->dma_chan);
-
-	/*  clear dma tc interrupt */
-	devpriv->write_byte(0x1, dev->iobase + DMATC_CLEAR_REG);
-}
-#endif
-
 /* read all available samples from ai fifo */
 static int labpc_drain_fifo(struct comedi_device *dev)
 {
@@ -1003,18 +989,9 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-#ifdef CONFIG_ISA_DMA_API
-	if (devpriv->current_transfer == isa_dma_transfer) {
-		/*
-		 * if a dma terminal count of external stop trigger
-		 * has occurred
-		 */
-		if (devpriv->stat1 & STAT1_GATA0 ||
-		    (board->is_labpc1200 && devpriv->stat2 & STAT2_OUTA1)) {
-			handle_isa_dma(dev);
-		}
-	} else
-#endif
+	if (devpriv->current_transfer == isa_dma_transfer)
+		labpc_handle_dma_status(dev);
+	else
 		labpc_drain_fifo(dev);
 
 	if (devpriv->stat1 & STAT1_CNTINT) {

commit f88e8e09880d4abe3cad98ec8889e0f46eb89e4d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 28 17:09:25 2013 +0100

    staging: comedi: ni_labpc: migrate labpc_drain_dma()
    
    Move `labpc_drain_dma()` into the "ni_labpc_isadma" module.  Provide a
    dummy inline function in "ni_labpc_isadma.h" if the module is not being
    built.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index e1b073f746fe..818a8abe208c 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -906,60 +906,6 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 #ifdef CONFIG_ISA_DMA_API
-static void labpc_drain_dma(struct comedi_device *dev)
-{
-	struct labpc_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_async *async = s->async;
-	int status;
-	unsigned long flags;
-	unsigned int max_points, num_points, residue, leftover;
-	int i;
-
-	status = devpriv->stat1;
-
-	flags = claim_dma_lock();
-	disable_dma(devpriv->dma_chan);
-	/* clear flip-flop to make sure 2-byte registers for
-	 * count and address get set correctly */
-	clear_dma_ff(devpriv->dma_chan);
-
-	/*  figure out how many points to read */
-	max_points = devpriv->dma_transfer_size / sample_size;
-	/* residue is the number of points left to be done on the dma
-	 * transfer.  It should always be zero at this point unless
-	 * the stop_src is set to external triggering.
-	 */
-	residue = get_dma_residue(devpriv->dma_chan) / sample_size;
-	num_points = max_points - residue;
-	if (devpriv->count < num_points && async->cmd.stop_src == TRIG_COUNT)
-		num_points = devpriv->count;
-
-	/*  figure out how many points will be stored next time */
-	leftover = 0;
-	if (async->cmd.stop_src != TRIG_COUNT) {
-		leftover = devpriv->dma_transfer_size / sample_size;
-	} else if (devpriv->count > num_points) {
-		leftover = devpriv->count - num_points;
-		if (leftover > max_points)
-			leftover = max_points;
-	}
-
-	/* write data to comedi buffer */
-	for (i = 0; i < num_points; i++)
-		cfc_write_to_buffer(s, devpriv->dma_buffer[i]);
-
-	if (async->cmd.stop_src == TRIG_COUNT)
-		devpriv->count -= num_points;
-
-	/*  set address and count for next transfer */
-	set_dma_addr(devpriv->dma_chan, devpriv->dma_addr);
-	set_dma_count(devpriv->dma_chan, leftover * sample_size);
-	release_dma_lock(flags);
-
-	async->events |= COMEDI_CB_BLOCK;
-}
-
 static void handle_isa_dma(struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
@@ -1009,12 +955,10 @@ static int labpc_drain_fifo(struct comedi_device *dev)
  * when acquisition is terminated by stop_src == TRIG_EXT). */
 static void labpc_drain_dregs(struct comedi_device *dev)
 {
-#ifdef CONFIG_ISA_DMA_API
 	struct labpc_private *devpriv = dev->private;
 
 	if (devpriv->current_transfer == isa_dma_transfer)
 		labpc_drain_dma(dev);
-#endif
 
 	labpc_drain_fifo(dev);
 }

commit 88dd0c0a8016d6d80ed47eb306c5b41e8af0f83a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 28 17:09:24 2013 +0100

    staging: comedi: ni_labpc: migrate DMA transfer set-up
    
    Migrate the code for setting up an ISA DMA transfer into a new function
    `labpc_setup_dma()` in the "ni_labpc_isadma" module.  Provide a dummy
    inline function in "ni_labpc_isadma.h" if the "ni_labpc_isadma" module
    is not being built.
    
    The static function `labpc_suggest_transfer_size()` also needs to move
    across to the new module.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index dd858d58a93e..e1b073f746fe 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -387,32 +387,6 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 	return insn->n;
 }
 
-#ifdef CONFIG_ISA_DMA_API
-/* utility function that suggests a dma transfer size in bytes */
-static unsigned int labpc_suggest_transfer_size(const struct comedi_cmd *cmd)
-{
-	unsigned int size;
-	unsigned int freq;
-
-	if (cmd->convert_src == TRIG_TIMER)
-		freq = 1000000000 / cmd->convert_arg;
-	/* return some default value */
-	else
-		freq = 0xffffffff;
-
-	/* make buffer fill in no more than 1/3 second */
-	size = (freq / 3) * sample_size;
-
-	/* set a minimum and maximum size allowed */
-	if (size > dma_buffer_size)
-		size = dma_buffer_size - dma_buffer_size % sample_size;
-	else if (size < sample_size)
-		size = sample_size;
-
-	return size;
-}
-#endif
-
 static bool labpc_use_continuous_mode(const struct comedi_cmd *cmd,
 				      enum scan_mode mode)
 {
@@ -883,31 +857,8 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	labpc_clear_adc_fifo(dev);
 
-#ifdef CONFIG_ISA_DMA_API
-	/*  set up dma transfer */
-	if (xfer == isa_dma_transfer) {
-		unsigned long irq_flags;
-
-		irq_flags = claim_dma_lock();
-		disable_dma(devpriv->dma_chan);
-		/* clear flip-flop to make sure 2-byte registers for
-		 * count and address get set correctly */
-		clear_dma_ff(devpriv->dma_chan);
-		set_dma_addr(devpriv->dma_chan, devpriv->dma_addr);
-		/*  set appropriate size of transfer */
-		devpriv->dma_transfer_size = labpc_suggest_transfer_size(cmd);
-		if (cmd->stop_src == TRIG_COUNT &&
-		    devpriv->count * sample_size < devpriv->dma_transfer_size) {
-			devpriv->dma_transfer_size =
-			    devpriv->count * sample_size;
-		}
-		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
-		enable_dma(devpriv->dma_chan);
-		release_dma_lock(irq_flags);
-		/*  enable board's dma */
-		devpriv->cmd3 |= (CMD3_DMAEN | CMD3_DMATCINTEN);
-	}
-#endif
+	if (xfer == isa_dma_transfer)
+		labpc_setup_dma(dev, s);
 
 	/*  enable error interrupts */
 	devpriv->cmd3 |= CMD3_ERRINTEN;

commit 50787fa99d80e86c9a22b7af16fd9827f733f3ab
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 28 17:09:23 2013 +0100

    staging: comedi: ni_labpc: move register defs to new file
    
    The new "ni_labpc_isadma" module will need to access some register
    definitions from "ni_labpc.c", which is not part of the module's source.
    Move all the register definitions into a new, common header file
    "ni_labpc_regs.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 1f0f7f538215..dd858d58a93e 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -71,75 +71,9 @@
 #include "8255.h"
 #include "comedi_fc.h"
 #include "ni_labpc.h"
+#include "ni_labpc_regs.h"
 #include "ni_labpc_isadma.h"
 
-/*
- * Register map (all registers are 8-bit)
- */
-#define STAT1_REG		0x00	/* R: Status 1 reg */
-#define STAT1_DAVAIL		(1 << 0)
-#define STAT1_OVERRUN		(1 << 1)
-#define STAT1_OVERFLOW		(1 << 2)
-#define STAT1_CNTINT		(1 << 3)
-#define STAT1_GATA0		(1 << 5)
-#define STAT1_EXTGATA0		(1 << 6)
-#define CMD1_REG		0x00	/* W: Command 1 reg */
-#define CMD1_MA(x)		(((x) & 0x7) << 0)
-#define CMD1_TWOSCMP		(1 << 3)
-#define CMD1_GAIN(x)		(((x) & 0x7) << 4)
-#define CMD1_SCANEN		(1 << 7)
-#define CMD2_REG		0x01	/* W: Command 2 reg */
-#define CMD2_PRETRIG		(1 << 0)
-#define CMD2_HWTRIG		(1 << 1)
-#define CMD2_SWTRIG		(1 << 2)
-#define CMD2_TBSEL		(1 << 3)
-#define CMD2_2SDAC0		(1 << 4)
-#define CMD2_2SDAC1		(1 << 5)
-#define CMD2_LDAC(x)		(1 << (6 + (x)))
-#define CMD3_REG		0x02	/* W: Command 3 reg */
-#define CMD3_DMAEN		(1 << 0)
-#define CMD3_DIOINTEN		(1 << 1)
-#define CMD3_DMATCINTEN		(1 << 2)
-#define CMD3_CNTINTEN		(1 << 3)
-#define CMD3_ERRINTEN		(1 << 4)
-#define CMD3_FIFOINTEN		(1 << 5)
-#define ADC_START_CONVERT_REG	0x03	/* W: Start Convert reg */
-#define DAC_LSB_REG(x)		(0x04 + 2 * (x)) /* W: DAC0/1 LSB reg */
-#define DAC_MSB_REG(x)		(0x05 + 2 * (x)) /* W: DAC0/1 MSB reg */
-#define ADC_FIFO_CLEAR_REG	0x08	/* W: A/D FIFO Clear reg */
-#define ADC_FIFO_REG		0x0a	/* R: A/D FIFO reg */
-#define DMATC_CLEAR_REG		0x0a	/* W: DMA Interrupt Clear reg */
-#define TIMER_CLEAR_REG		0x0c	/* W: Timer Interrupt Clear reg */
-#define CMD6_REG		0x0e	/* W: Command 6 reg */
-#define CMD6_NRSE		(1 << 0)
-#define CMD6_ADCUNI		(1 << 1)
-#define CMD6_DACUNI(x)		(1 << (2 + (x)))
-#define CMD6_HFINTEN		(1 << 5)
-#define CMD6_DQINTEN		(1 << 6)
-#define CMD6_SCANUP		(1 << 7)
-#define CMD4_REG		0x0f	/* W: Command 3 reg */
-#define CMD4_INTSCAN		(1 << 0)
-#define CMD4_EOIRCV		(1 << 1)
-#define CMD4_ECLKDRV		(1 << 2)
-#define CMD4_SEDIFF		(1 << 3)
-#define CMD4_ECLKRCV		(1 << 4)
-#define DIO_BASE_REG		0x10	/* R/W: 8255 DIO base reg */
-#define COUNTER_A_BASE_REG	0x14	/* R/W: 8253 Counter A base reg */
-#define COUNTER_B_BASE_REG	0x18	/* R/W: 8253 Counter B base reg */
-#define CMD5_REG		0x1c	/* W: Command 5 reg */
-#define CMD5_WRTPRT		(1 << 2)
-#define CMD5_DITHEREN		(1 << 3)
-#define CMD5_CALDACLD		(1 << 4)
-#define CMD5_SCLK		(1 << 5)
-#define CMD5_SDATA		(1 << 6)
-#define CMD5_EEPROMCS		(1 << 7)
-#define STAT2_REG		0x1d	/* R: Status 2 reg */
-#define STAT2_PROMOUT		(1 << 0)
-#define STAT2_OUTA1		(1 << 1)
-#define STAT2_FIFONHF		(1 << 2)
-#define INTERVAL_COUNT_REG	0x1e	/* W: Interval Counter Data reg */
-#define INTERVAL_STROBE_REG	0x1f	/* W: Interval Counter Strobe reg */
-
 #define LABPC_SIZE		0x20	/* size of ISA io region */
 #define LABPC_TIMER_BASE	500	/* 2 MHz master clock */
 #define LABPC_ADC_TIMEOUT	1000

commit 5c8a138e9d33df4960e3cb497c60723c7fbdacf9
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 28 17:09:22 2013 +0100

    staging: comedi: ni_labpc: use labpc_have_dma_chan()
    
    Call the new static inline function `labpc_have_dma_chan()` from
    `labpc_ai_cmd()` to check if the ISA DMA channel has been initialized,
    tidying up the surrounding code and removing an `#ifdef`.  If the
    "ni_labpc_isadma" module is not being built, `labpc_have_dma_chan()`
    doesn't bother checking the DMA channel and just returns `false`,
    allowing the compiler to optimize out a small amount of code.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index ab1773e1fbcc..1f0f7f538215 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -871,25 +871,20 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return ret;
 	}
 
-#ifdef CONFIG_ISA_DMA_API
-	/*  figure out what method we will use to transfer data */
-	if (devpriv->dma_chan &&	/*  need a dma channel allocated */
-		/*
-		 * dma unsafe at RT priority,
-		 * and too much setup time for TRIG_WAKE_EOS for
-		 */
-	    (cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0) {
+	/* figure out what method we will use to transfer data */
+	if (labpc_have_dma_chan(dev) &&
+	    /* dma unsafe at RT priority,
+	     * and too much setup time for TRIG_WAKE_EOS */
+	    (cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0)
 		xfer = isa_dma_transfer;
-		/* pc-plus has no fifo-half full interrupt */
-	} else
-#endif
-	if (board->is_labpc1200 &&
-		   /*  wake-end-of-scan should interrupt on fifo not empty */
-		   (cmd->flags & TRIG_WAKE_EOS) == 0 &&
-		   /*  make sure we are taking more than just a few points */
-		   (cmd->stop_src != TRIG_COUNT || devpriv->count > 256)) {
+	else if (/* pc-plus has no fifo-half full interrupt */
+		 board->is_labpc1200 &&
+		 /* wake-end-of-scan should interrupt on fifo not empty */
+		 (cmd->flags & TRIG_WAKE_EOS) == 0 &&
+		 /* make sure we are taking more than just a few points */
+		 (cmd->stop_src != TRIG_COUNT || devpriv->count > 256))
 		xfer = fifo_half_full_transfer;
-	} else
+	else
 		xfer = fifo_not_empty_transfer;
 	devpriv->current_transfer = xfer;
 

commit 86aff4bb11eb721b9be40dcd51f7571fb00edcde
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 28 17:09:20 2013 +0100

    staging: comedi: ni_labpc: migrate DMA channel init & free
    
    Migrate the code for requesting an ISA DMA channel and a DMA buffer, and
    the code for freeing them into two new functions in the
    "ni_labpc_isadma" module: `labpc_init_dma_chan()` and
    `labpc_free_dma_chan()`.  Dummy inline functions are provided in
    "ni_labpc_isadma.h" if the "ni_labpc_isadma" module is not being built.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index d1d22a19f022..ab1773e1fbcc 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1708,31 +1708,8 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-#ifdef CONFIG_ISA_DMA_API
-	if (dev->irq && (dma_chan == 1 || dma_chan == 3)) {
-		void *dma_buffer = kmalloc(dma_buffer_size,
-					   GFP_KERNEL | GFP_DMA);
-
-		if (dma_buffer) {
-			ret = request_dma(dma_chan, dev->board_name);
-			if (ret == 0) {
-				unsigned long dma_flags;
-
-				devpriv->dma_buffer = dma_buffer;
-				devpriv->dma_chan = dma_chan;
-				devpriv->dma_addr =
-					virt_to_bus(devpriv->dma_buffer);
-
-				dma_flags = claim_dma_lock();
-				disable_dma(devpriv->dma_chan);
-				set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
-				release_dma_lock(dma_flags);
-			} else {
-				kfree(dma_buffer);
-			}
-		}
-	}
-#endif
+	if (dev->irq)
+		labpc_init_dma_chan(dev, dma_chan);
 
 	return 0;
 }
@@ -1741,11 +1718,9 @@ static void labpc_detach(struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
 
-	if (devpriv) {
-		kfree(devpriv->dma_buffer);
-		if (devpriv->dma_chan)
-			free_dma(devpriv->dma_chan);
-	}
+	if (devpriv)
+		labpc_free_dma_chan(dev);
+
 	comedi_legacy_detach(dev);
 }
 

commit 9a6386623fc8a67f792b9df56acbd8758e1aa93d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 28 17:09:19 2013 +0100

    staging: comedi: ni_labpc_isadma: new module for ISA DMA support
    
    It's just an empty module at the moment, selected by COMEDI_NI_LABPC_ISA
    && ISA_DMA_API && VIRT_TO_BUS, but will be populated by later patches to
    migrate ISA DMA support for NI Lab-PC cards out of the "ni_labpc"
    module.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 65ab8f6c5b69..d1d22a19f022 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -71,6 +71,7 @@
 #include "8255.h"
 #include "comedi_fc.h"
 #include "ni_labpc.h"
+#include "ni_labpc_isadma.h"
 
 /*
  * Register map (all registers are 8-bit)

commit f12a34ca0b7f02f725965f39f9ccf5d5c339d3e0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 28 17:09:18 2013 +0100

    staging: comedi: ni_labpc: don't clear cmd3 bits explicitly in labpc_ai_cmd()
    
    `labpc_ai_cmd()` calls `labpc_cancel()` which already sets
    `devpriv->cmd3` to 0.  Remove the lines from `labpc_ai_cmd()` that clear
    specific bits in `devpriv->cmd3` explicitly as they have no effect.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 4ff1ed0c8fa8..65ab8f6c5b69 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -976,8 +976,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		release_dma_lock(irq_flags);
 		/*  enable board's dma */
 		devpriv->cmd3 |= (CMD3_DMAEN | CMD3_DMATCINTEN);
-	} else
-		devpriv->cmd3 &= ~(CMD3_DMAEN | CMD3_DMATCINTEN);
+	}
 #endif
 
 	/*  enable error interrupts */
@@ -985,8 +984,6 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  enable fifo not empty interrupt? */
 	if (xfer == fifo_not_empty_transfer)
 		devpriv->cmd3 |= CMD3_FIFOINTEN;
-	else
-		devpriv->cmd3 &= ~CMD3_FIFOINTEN;
 	devpriv->write_byte(devpriv->cmd3, dev->iobase + CMD3_REG);
 
 	/*  setup any external triggering/pacing (cmd4 register) */

commit 725a70d8a68ef5368652c0c49631fefb361d62cf
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 28 17:09:17 2013 +0100

    staging: comedi: ni_labpc: fix possible double-free of dma_buffer
    
    If `labpc_attach()` allocates memory for `devpriv->dma_buffer` but fails
    to request a DMA channel, it frees `devpriv->dma_buffer` but leaves the
    pointer set.  Later, `labpc_detach()` frees `devpriv->dma_buffer` again,
    which means it has been freed twice in this case.
    
    Fix it by only setting `devpriv->dma_buffer` in `labpc_attach()` if the
    DMA channel was requested successfully.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 3e95ac5402ca..4ff1ed0c8fa8 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1712,13 +1712,15 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 #ifdef CONFIG_ISA_DMA_API
 	if (dev->irq && (dma_chan == 1 || dma_chan == 3)) {
-		devpriv->dma_buffer = kmalloc(dma_buffer_size,
-					      GFP_KERNEL | GFP_DMA);
-		if (devpriv->dma_buffer) {
+		void *dma_buffer = kmalloc(dma_buffer_size,
+					   GFP_KERNEL | GFP_DMA);
+
+		if (dma_buffer) {
 			ret = request_dma(dma_chan, dev->board_name);
 			if (ret == 0) {
 				unsigned long dma_flags;
 
+				devpriv->dma_buffer = dma_buffer;
 				devpriv->dma_chan = dma_chan;
 				devpriv->dma_addr =
 					virt_to_bus(devpriv->dma_buffer);
@@ -1728,7 +1730,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
 				release_dma_lock(dma_flags);
 			} else {
-				kfree(devpriv->dma_buffer);
+				kfree(dma_buffer);
 			}
 		}
 	}

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 4119dcfd4761..3e95ac5402ca 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -57,6 +57,7 @@
  * 320502b (lab-pc+)
  */
 
+#include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/io.h>

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index f161e70b3a0d..4119dcfd4761 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1697,10 +1697,9 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned int dma_chan = it->options[2];
 	int ret;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	ret = comedi_request_region(dev, it->options[0], LABPC_SIZE);
 	if (ret)

commit 588ba6dc5fb4bdca47a3da38c2718fbb82d3eee1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 11 11:32:29 2013 -0700

    staging: comedi: drivers: let core handle freeing s->private
    
    Introduce a new subdevice runflags, SRF_FREE_SPRIV, and a new helper
    function, comedi_set_spriv(), that the drivers can use to set the
    comedi_subdevice private data pointer. The helper function will also
    set SRF_FREE_SPRIV to allow the comedi core to automatically free the
    subdevice private data during the cleanup_device() stage of the detach.
    
    Currently s->private is only allocated by the 8255, addi_watchdog,
    amplc_dio200_common, and ni_65xx drivers. All users of those drivers
    can then have the comedi_spriv_free() calls removed and in many cases
    the (*detach) can then simply be the appropriate comedi core provided
    function.
    
    The ni_65xx driver uses a helper function, ni_65xx_alloc_subdevice_private(),
    to allocate the private data. Refactor the function to return an errno
    or call comedi_set_spriv() instead of returning a pointer to the private
    data and requiring the caller to handle it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index a918b7ffbe22..f161e70b3a0d 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1689,12 +1689,6 @@ int labpc_common_attach(struct comedi_device *dev,
 }
 EXPORT_SYMBOL_GPL(labpc_common_attach);
 
-void labpc_common_detach(struct comedi_device *dev)
-{
-	comedi_spriv_free(dev, 2);
-}
-EXPORT_SYMBOL_GPL(labpc_common_detach);
-
 #if IS_ENABLED(CONFIG_COMEDI_NI_LABPC_ISA)
 static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
@@ -1747,8 +1741,6 @@ static void labpc_detach(struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
 
-	labpc_common_detach(dev);
-
 	if (devpriv) {
 		kfree(devpriv->dma_buffer);
 		if (devpriv->dma_chan)

commit 829455bb0e994373519e3c58d403fc1148f44630
Merge: 42b4212baa28 e4aa937ec75d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 27 10:54:33 2013 +0900

    Merge 3.10-rc3 into staging-next
    
    We want the changes here, and we resolve the merge conflict that was
    happening in the nvec_kbd.c file.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5e763f7bd9fea0027e246e6c2cee291566a390a9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 13 17:07:24 2013 -0700

    staging: comedi: ni_labpc: remove *_ai_gain_bits tables
    
    The bits needed to set the analog input gain can be simply calculated
    based on the 'range'.
    
    The LabPC versions of the board do not have the '0x10' gain that the
    LabPC+ board supports. By incrementing the range appropriately the
    correct gain bits can still be calculated.
    
    This allows removing the two gain tables, as well as the export, along
    with the 'ai_range_code' data in the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 7d6bd1b6ef72..732000917310 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -84,7 +84,7 @@
 #define CMD1_REG		0x00	/* W: Command 1 reg */
 #define CMD1_MA(x)		(((x) & 0x7) << 0)
 #define CMD1_TWOSCMP		(1 << 3)
-#define CMD1_GAIN_MASK		(7 << 4)
+#define CMD1_GAIN(x)		(((x) & 0x7) << 4)
 #define CMD1_SCANEN		(1 << 7)
 #define CMD2_REG		0x01	/* W: Command 2 reg */
 #define CMD2_PRETRIG		(1 << 0)
@@ -149,11 +149,6 @@ enum scan_mode {
 	MODE_MULT_CHAN_DOWN,
 };
 
-static const int labpc_plus_ai_gain_bits[] = {
-	0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
-	0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
-};
-
 static const struct comedi_lrange range_labpc_plus_ai = {
 	16, {
 		BIP_RANGE(5),
@@ -175,12 +170,6 @@ static const struct comedi_lrange range_labpc_plus_ai = {
 	}
 };
 
-const int labpc_1200_ai_gain_bits[] = {
-	0x00, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
-	0x00, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
-};
-EXPORT_SYMBOL_GPL(labpc_1200_ai_gain_bits);
-
 static const struct comedi_lrange range_labpc_1200_ai = {
 	14, {
 		BIP_RANGE(5),
@@ -233,20 +222,17 @@ static inline void labpc_writeb(unsigned int byte, unsigned long address)
 static const struct labpc_boardinfo labpc_boards[] = {
 	{
 		.name			= "lab-pc-1200",
-		.ai_range_code		= labpc_1200_ai_gain_bits,
 		.ai_speed		= 10000,
 		.ai_scan_up		= 1,
 		.has_ao			= 1,
 		.is_labpc1200		= 1,
 	}, {
 		.name			= "lab-pc-1200ai",
-		.ai_range_code		= labpc_1200_ai_gain_bits,
 		.ai_speed		= 10000,
 		.ai_scan_up		= 1,
 		.is_labpc1200		= 1,
 	}, {
 		.name			= "lab-pc+",
-		.ai_range_code		= labpc_plus_ai_gain_bits,
 		.ai_speed		= 12000,
 		.has_ao			= 1,
 	},
@@ -317,12 +303,21 @@ static void labpc_ai_set_chan_and_gain(struct comedi_device *dev,
 	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 
+	if (board->is_labpc1200) {
+		/*
+		 * The LabPC-1200 boards do not have a gain
+		 * of '0x10'. Skip the range values that would
+		 * result in this gain.
+		 */
+		range += (range > 0) + (range > 7);
+	}
+
 	/* munge channel bits for differential/scan disabled mode */
 	if ((mode == MODE_SINGLE_CHAN || mode == MODE_SINGLE_CHAN_INTERVAL) &&
 	    aref == AREF_DIFF)
 		chan *= 2;
 	devpriv->cmd1 = CMD1_MA(chan);
-	devpriv->cmd1 |= board->ai_range_code[range];
+	devpriv->cmd1 |= CMD1_GAIN(range);
 
 	devpriv->write_byte(devpriv->cmd1, dev->iobase + CMD1_REG);
 }

commit 1581a03573e6c9ebd931e31f9172cce25dcb69e6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 11:26:14 2013 -0700

    staging: comedi: ni_labpc: fix build when VIRT_TO_BUS is not defined
    
    After merging the final tree, the next-20130424 build (powerpc
    allyesconfig) failed like this:
    
    drivers/staging/comedi/drivers/ni_labpc.c: In function 'labpc_ai_cmd':
    drivers/staging/comedi/drivers/ni_labpc.c:980:9: error:
        implicit declaration of function 'virt_to_bus'
       [-Werror=implicit-function-declaration]
    
    The virt_to_bus() is only needed for the ISA DMA support in this driver.
    
    On powerpc, CONFIG_COMEDI_NI_LABPC_ISA cannot be enabled due to the
    depends on VIRT_TO_BUS but the PCI driver, ni_labpc_pci, can be enabled.
    That driver uses the ni_labpc driver for the common support code shared
    by the ISA, PCI, and PCMCIA boards.
    
    The ISA specific support, and the optional ISA DMA support, are currently
    still in the common ni_labpc driver. The ISA specific code is protected
    by #if IS_ENABLED(CONFIG_COMEDI_NI_LABPC_ISA) and the ISA DMA support
    is protected by #ifdef CONFIG_ISA_DMA_API. This allows the ISA support
    to be enabled on architectures that support VIRT_TO_BUS and optionally
    enables ISA DMA support if ISA_DMA_API is enabled.
    
    Unfortunately, the ISA DMA code uses virt_to_bus(). This results in
    the build failure for architectures that enable ISA_DMA_API but do not
    have VIRT_TO_BUS.
    
    Add a new member to the private data, dma_addr, to hold the phys_addr_t
    returned by virt_to_bus() and initialize it in the ISA specific
    labpc_attach().
    
    For architectures that enable ISA_DMA_API but not VIRT_TO_BUS, this
    will fix the build error. This is also safe for architectures the
    enable both options but don't enable COMEDI_NI_LABPC_ISA because the
    dma channel (devpriv->dma_chan) is only initialized in the ISA
    specific labpc_attach().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 3d978f34d212..77a7bb632580 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -976,8 +976,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* clear flip-flop to make sure 2-byte registers for
 		 * count and address get set correctly */
 		clear_dma_ff(devpriv->dma_chan);
-		set_dma_addr(devpriv->dma_chan,
-			     virt_to_bus(devpriv->dma_buffer));
+		set_dma_addr(devpriv->dma_chan, devpriv->dma_addr);
 		/*  set appropriate size of transfer */
 		devpriv->dma_transfer_size = labpc_suggest_transfer_size(cmd);
 		if (cmd->stop_src == TRIG_COUNT &&
@@ -1089,7 +1088,7 @@ static void labpc_drain_dma(struct comedi_device *dev)
 		devpriv->count -= num_points;
 
 	/*  set address and count for next transfer */
-	set_dma_addr(devpriv->dma_chan, virt_to_bus(devpriv->dma_buffer));
+	set_dma_addr(devpriv->dma_chan, devpriv->dma_addr);
 	set_dma_count(devpriv->dma_chan, leftover * sample_size);
 	release_dma_lock(flags);
 
@@ -1741,6 +1740,9 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				unsigned long dma_flags;
 
 				devpriv->dma_chan = dma_chan;
+				devpriv->dma_addr =
+					virt_to_bus(devpriv->dma_buffer);
+
 				dma_flags = claim_dma_lock();
 				disable_dma(devpriv->dma_chan);
 				set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 5ed9a6fef96b..7d6bd1b6ef72 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -12,10 +12,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 /*

commit 70d52bce5523f2c6a7bf3f9a54dacc0be112a3e8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 23 12:57:58 2013 -0700

    staging: comedi: ni_labpc: remove range_labpc_1200_ai export
    
    The 'ai_range_table' boardinfo is only used to initialize the
    analog input subdevice s->range_table. We can use the 'is_labpc1200'
    flag in the boardinfo to determine which range table is needed.
    
    This allows making range_labpc_1200_ai static and removing the
    export as well as removing the 'ai_range_table' from the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index da10a762e8c2..5ed9a6fef96b 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -185,7 +185,7 @@ const int labpc_1200_ai_gain_bits[] = {
 };
 EXPORT_SYMBOL_GPL(labpc_1200_ai_gain_bits);
 
-const struct comedi_lrange range_labpc_1200_ai = {
+static const struct comedi_lrange range_labpc_1200_ai = {
 	14, {
 		BIP_RANGE(5),
 		BIP_RANGE(2.5),
@@ -203,7 +203,6 @@ const struct comedi_lrange range_labpc_1200_ai = {
 		UNI_RANGE(0.1)
 	}
 };
-EXPORT_SYMBOL_GPL(range_labpc_1200_ai);
 
 static const struct comedi_lrange range_labpc_ao = {
 	2, {
@@ -238,7 +237,6 @@ static inline void labpc_writeb(unsigned int byte, unsigned long address)
 static const struct labpc_boardinfo labpc_boards[] = {
 	{
 		.name			= "lab-pc-1200",
-		.ai_range_table		= &range_labpc_1200_ai,
 		.ai_range_code		= labpc_1200_ai_gain_bits,
 		.ai_speed		= 10000,
 		.ai_scan_up		= 1,
@@ -246,14 +244,12 @@ static const struct labpc_boardinfo labpc_boards[] = {
 		.is_labpc1200		= 1,
 	}, {
 		.name			= "lab-pc-1200ai",
-		.ai_range_table		= &range_labpc_1200_ai,
 		.ai_range_code		= labpc_1200_ai_gain_bits,
 		.ai_speed		= 10000,
 		.ai_scan_up		= 1,
 		.is_labpc1200		= 1,
 	}, {
 		.name			= "lab-pc+",
-		.ai_range_table		= &range_labpc_plus_ai,
 		.ai_range_code		= labpc_plus_ai_gain_bits,
 		.ai_speed		= 12000,
 		.has_ao			= 1,
@@ -1625,7 +1621,8 @@ int labpc_common_attach(struct comedi_device *dev,
 	s->n_chan	= 8;
 	s->len_chanlist	= 8;
 	s->maxdata	= 0x0fff;
-	s->range_table	= board->ai_range_table;
+	s->range_table	= board->is_labpc1200
+				? &range_labpc_1200_ai : &range_labpc_plus_ai;
 	s->insn_read	= labpc_ai_insn_read;
 	if (dev->irq) {
 		dev->read_subdev = s;

commit 63d6ba20bab01ea1a92b3fe7718416a8527e009a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 23 12:57:38 2013 -0700

    staging: comedi: ni_labpc: cleanup true/false flags in boardinfo
    
    The 'register_layout' in the boardinfo can be represented as
    a true/false flag instead of an enum. Rename the variable to
    'is_labpc1200' and change it to an unsigned 1-bit bit-field.
    
    The 'has_ao' variable is also a true/false flag. Change it to
    an unsigned 1-bit bit-field.
    
    Reorder the boardinfo data so that the bit-field data is grouped
    together.
    
    For aesthetic reasons, and move the 'const' variables then
    reorder the boardinfo declarations to match the definition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 3d978f34d212..da10a762e8c2 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -238,26 +238,25 @@ static inline void labpc_writeb(unsigned int byte, unsigned long address)
 static const struct labpc_boardinfo labpc_boards[] = {
 	{
 		.name			= "lab-pc-1200",
-		.ai_speed		= 10000,
-		.register_layout	= labpc_1200_layout,
-		.has_ao			= 1,
 		.ai_range_table		= &range_labpc_1200_ai,
 		.ai_range_code		= labpc_1200_ai_gain_bits,
+		.ai_speed		= 10000,
 		.ai_scan_up		= 1,
+		.has_ao			= 1,
+		.is_labpc1200		= 1,
 	}, {
 		.name			= "lab-pc-1200ai",
-		.ai_speed		= 10000,
-		.register_layout	= labpc_1200_layout,
 		.ai_range_table		= &range_labpc_1200_ai,
 		.ai_range_code		= labpc_1200_ai_gain_bits,
+		.ai_speed		= 10000,
 		.ai_scan_up		= 1,
+		.is_labpc1200		= 1,
 	}, {
 		.name			= "lab-pc+",
-		.ai_speed		= 12000,
-		.register_layout	= labpc_plus_layout,
-		.has_ao			= 1,
 		.ai_range_table		= &range_labpc_plus_ai,
 		.ai_range_code		= labpc_plus_ai_gain_bits,
+		.ai_speed		= 12000,
+		.has_ao			= 1,
 	},
 };
 #endif
@@ -347,7 +346,7 @@ static void labpc_setup_cmd6_reg(struct comedi_device *dev,
 	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 
-	if (board->register_layout != labpc_1200_layout)
+	if (!board->is_labpc1200)
 		return;
 
 	/* reference inputs to ground or common? */
@@ -759,7 +758,7 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 
 	stop_mask = TRIG_COUNT | TRIG_NONE;
-	if (board->register_layout == labpc_1200_layout)
+	if (board->is_labpc1200)
 		stop_mask |= TRIG_EXT;
 	err |= cfc_check_trigger_src(&cmd->stop_src, stop_mask);
 
@@ -895,7 +894,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* pc-plus has no fifo-half full interrupt */
 	} else
 #endif
-	if (board->register_layout == labpc_1200_layout &&
+	if (board->is_labpc1200 &&
 		   /*  wake-end-of-scan should interrupt on fifo not empty */
 		   (cmd->flags & TRIG_WAKE_EOS) == 0 &&
 		   /*  make sure we are taking more than just a few points */
@@ -1176,7 +1175,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 
 	/* read board status */
 	devpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);
-	if (board->register_layout == labpc_1200_layout)
+	if (board->is_labpc1200)
 		devpriv->stat2 = devpriv->read_byte(dev->iobase + STAT2_REG);
 
 	if ((devpriv->stat1 & (STAT1_GATA0 | STAT1_CNTINT | STAT1_OVERFLOW |
@@ -1202,8 +1201,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 		 * has occurred
 		 */
 		if (devpriv->stat1 & STAT1_GATA0 ||
-		    (board->register_layout == labpc_1200_layout
-		     && devpriv->stat2 & STAT2_OUTA1)) {
+		    (board->is_labpc1200 && devpriv->stat2 & STAT2_OUTA1)) {
 			handle_isa_dma(dev);
 		}
 	} else
@@ -1267,7 +1265,7 @@ static int labpc_ao_insn_write(struct comedi_device *dev,
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* set range */
-	if (board->register_layout == labpc_1200_layout) {
+	if (board->is_labpc1200) {
 		range = CR_RANGE(insn->chanspec);
 		if (labpc_range_is_unipolar(s, range))
 			devpriv->cmd6 |= CMD6_DACUNI(channel);
@@ -1604,7 +1602,7 @@ int labpc_common_attach(struct comedi_device *dev,
 	devpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);
 	devpriv->write_byte(devpriv->cmd3, dev->iobase + CMD3_REG);
 	devpriv->write_byte(devpriv->cmd4, dev->iobase + CMD4_REG);
-	if (board->register_layout == labpc_1200_layout) {
+	if (board->is_labpc1200) {
 		devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 		devpriv->write_byte(devpriv->cmd6, dev->iobase + CMD6_REG);
 	}
@@ -1672,7 +1670,7 @@ int labpc_common_attach(struct comedi_device *dev,
 
 	/*  calibration subdevices for boards that have one */
 	s = &dev->subdevices[3];
-	if (board->register_layout == labpc_1200_layout) {
+	if (board->is_labpc1200) {
 		s->type		= COMEDI_SUBD_CALIB;
 		s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 		s->n_chan	= 16;
@@ -1687,7 +1685,7 @@ int labpc_common_attach(struct comedi_device *dev,
 
 	/* EEPROM */
 	s = &dev->subdevices[4];
-	if (board->register_layout == labpc_1200_layout) {
+	if (board->is_labpc1200) {
 		s->type		= COMEDI_SUBD_MEMORY;
 		s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 		s->n_chan	= EEPROM_SIZE;

commit a0eeed40100b2eca57afdf99d76c57dedd218a8a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 23 11:05:06 2013 -0700

    staging: comedi: ni_labpc: fix legacy driver build
    
    CONFIG_COMEDI_NI_LABPC_ISA is a tristate option. #if IS_ENABLED()
    needs to be used instead of #ifdef in order to build the legacy
    specific code in this driver.
    
    The local variable 'board' is not used in labpc_attach(). Remove it.
    
    The labpc_detach() function is only referenced in this file. Make
    it static.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index bb68d8fa83a3..3d978f34d212 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -234,7 +234,7 @@ static inline void labpc_writeb(unsigned int byte, unsigned long address)
 	writeb(byte, (void __iomem *)address);
 }
 
-#ifdef CONFIG_COMEDI_NI_LABPC_ISA
+#if IS_ENABLED(CONFIG_COMEDI_NI_LABPC_ISA)
 static const struct labpc_boardinfo labpc_boards[] = {
 	{
 		.name			= "lab-pc-1200",
@@ -1710,10 +1710,9 @@ void labpc_common_detach(struct comedi_device *dev)
 }
 EXPORT_SYMBOL_GPL(labpc_common_detach);
 
-#ifdef CONFIG_COMEDI_NI_LABPC_ISA
+#if IS_ENABLED(CONFIG_COMEDI_NI_LABPC_ISA)
 static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv;
 	unsigned int irq = it->options[1];
 	unsigned int dma_chan = it->options[2];
@@ -1756,7 +1755,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 0;
 }
 
-void labpc_detach(struct comedi_device *dev)
+static void labpc_detach(struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
 

commit a9b3ea3dbbb54f9160465f6f1086f877e958fdcc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 12:34:34 2013 -0700

    staging: comedi: ni_labpc: remove 'bustype' from boardinfo
    
    The 'bustype' in the boardinfo is not used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 5630be33d452..bb68d8fa83a3 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -239,7 +239,6 @@ static const struct labpc_boardinfo labpc_boards[] = {
 	{
 		.name			= "lab-pc-1200",
 		.ai_speed		= 10000,
-		.bustype		= isa_bustype,
 		.register_layout	= labpc_1200_layout,
 		.has_ao			= 1,
 		.ai_range_table		= &range_labpc_1200_ai,
@@ -248,7 +247,6 @@ static const struct labpc_boardinfo labpc_boards[] = {
 	}, {
 		.name			= "lab-pc-1200ai",
 		.ai_speed		= 10000,
-		.bustype		= isa_bustype,
 		.register_layout	= labpc_1200_layout,
 		.ai_range_table		= &range_labpc_1200_ai,
 		.ai_range_code		= labpc_1200_ai_gain_bits,
@@ -256,7 +254,6 @@ static const struct labpc_boardinfo labpc_boards[] = {
 	}, {
 		.name			= "lab-pc+",
 		.ai_speed		= 12000,
-		.bustype		= isa_bustype,
 		.register_layout	= labpc_plus_layout,
 		.has_ao			= 1,
 		.ai_range_table		= &range_labpc_plus_ai,

commit 3a0a73b3c884ef43487d6c3b43af077d6da124b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 12:34:13 2013 -0700

    staging: comedi: ni_labpc: remove unnecessary 'bustype' check
    
    Only the ISA versions of the LabPC boards support DMA and the
    devpriv->dma_chan is only set during the ISA board attach if
    DMA is available. The extra check of the board->bustype is not
    necessary in labpc_ai_cmd().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 365149a2ef73..5630be33d452 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -893,9 +893,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * dma unsafe at RT priority,
 		 * and too much setup time for TRIG_WAKE_EOS for
 		 */
-	    (cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0 &&
-	    /*  only available on the isa boards */
-	    board->bustype == isa_bustype) {
+	    (cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0) {
 		xfer = isa_dma_transfer;
 		/* pc-plus has no fifo-half full interrupt */
 	} else

commit 3e034797191de9981cddff4d1a8203d020360958
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 12:33:53 2013 -0700

    staging: comedi: ni_labpc: pass the isr_flags to labpc_common_attach()
    
    The PCI and PCMCIA LabPC boards use shared interrupts and need the
    IRQF_SHARED flag set when requesting the irq, the ISA boards do not.
    
    Instead of checking the 'bustype' in labpc_common_attach() in order
    to determine the isr_flags, just pass the flags as a parameter to the
    function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 56fb5b2136a4..365149a2ef73 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1588,12 +1588,11 @@ static int labpc_eeprom_insn_read(struct comedi_device *dev,
 }
 
 int labpc_common_attach(struct comedi_device *dev,
-			unsigned int irq)
+			unsigned int irq, unsigned long isr_flags)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
-	unsigned long isr_flags;
 	int ret;
 	int i;
 
@@ -1616,10 +1615,6 @@ int labpc_common_attach(struct comedi_device *dev,
 	}
 
 	if (irq) {
-		isr_flags = 0;
-		if (board->bustype == pci_bustype ||
-		    board->bustype == pcmcia_bustype)
-			isr_flags |= IRQF_SHARED;
 		ret = request_irq(irq, labpc_interrupt, isr_flags,
 				  dev->board_name, dev);
 		if (ret == 0)
@@ -1738,7 +1733,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	ret = labpc_common_attach(dev, irq);
+	ret = labpc_common_attach(dev, irq, 0);
 	if (ret)
 		return ret;
 

commit 767308842b4b970ca105b1e80cd92af39355dfc5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 12:33:30 2013 -0700

    staging: comedi: ni_labpc: move DMA init out of the common attach
    
    Only the ISA versions of the LabPC boards support DMA. Move the DMA
    initialization out of the labpc_common_attach() and put it in the
    ISA specific labpc_attach() function.
    
    Remove the 'dma_chan' parameter from labpc_common_attach().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index e8fc6a1c629a..56fb5b2136a4 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1588,7 +1588,7 @@ static int labpc_eeprom_insn_read(struct comedi_device *dev,
 }
 
 int labpc_common_attach(struct comedi_device *dev,
-			unsigned int irq, unsigned int dma_chan)
+			unsigned int irq)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
@@ -1626,27 +1626,6 @@ int labpc_common_attach(struct comedi_device *dev,
 			dev->irq = irq;
 	}
 
-#ifdef CONFIG_ISA_DMA_API
-	if (dev->irq && (dma_chan == 1 || dma_chan == 3)) {
-		devpriv->dma_buffer = kmalloc(dma_buffer_size,
-					      GFP_KERNEL | GFP_DMA);
-		if (devpriv->dma_buffer) {
-			ret = request_dma(dma_chan, dev->board_name);
-			if (ret == 0) {
-				unsigned long dma_flags;
-
-				devpriv->dma_chan = dma_chan;
-				dma_flags = claim_dma_lock();
-				disable_dma(devpriv->dma_chan);
-				set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
-				release_dma_lock(dma_flags);
-			} else {
-				kfree(devpriv->dma_buffer);
-			}
-		}
-	}
-#endif
-
 	ret = comedi_alloc_subdevices(dev, 5);
 	if (ret)
 		return ret;
@@ -1759,7 +1738,32 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	return labpc_common_attach(dev, irq, dma_chan);
+	ret = labpc_common_attach(dev, irq);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_ISA_DMA_API
+	if (dev->irq && (dma_chan == 1 || dma_chan == 3)) {
+		devpriv->dma_buffer = kmalloc(dma_buffer_size,
+					      GFP_KERNEL | GFP_DMA);
+		if (devpriv->dma_buffer) {
+			ret = request_dma(dma_chan, dev->board_name);
+			if (ret == 0) {
+				unsigned long dma_flags;
+
+				devpriv->dma_chan = dma_chan;
+				dma_flags = claim_dma_lock();
+				disable_dma(devpriv->dma_chan);
+				set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
+				release_dma_lock(dma_flags);
+			} else {
+				kfree(devpriv->dma_buffer);
+			}
+		}
+	}
+#endif
+
+	return 0;
 }
 
 void labpc_detach(struct comedi_device *dev)

commit fa3cb2191091657038ddb9207888b6cfb11fdf6e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 22 12:33:09 2013 -0700

    staging: comedi: ni_labpc: split out PCI support
    
    Currently the ni_labpc driver is used by the legacy (ISA), PCI, and
    PCMCIA versions of the LabPC board. The driver is enabled under the
    COMEDI_PCI_DRIVERS section of the Kconfig. This means that PCI support
    must be enabled in order to use the ni_labpc driver for the PCI or
    PCMCIA drivers.
    
    Split the PCI support code out of the ni_labpc driver into a separate
    driver, ni_labpc_pci. The PCMCIA support is already slip out as
    ni_labpc_cs.
    
    Modify the Kconfig so that the common code in ni_labpc is enabled by the
    Kconfig option COMEDI_NI_LABPC. The ISA support code is currently still
    in the ni_labpc driver but is only compiled in if COMEDI_NI_LABPC_ISA is
    also enabled.
    
    This allows the PCI and PCMCIA drivers to be enabled without the need
    for the ISA stuff.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 96a6837774e0..e8fc6a1c629a 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -24,7 +24,6 @@
  * Devices: (National Instruments) Lab-PC-1200 [lab-pc-1200]
  *	    (National Instruments) Lab-PC-1200AI [lab-pc-1200ai]
  *	    (National Instruments) Lab-PC+ [lab-pc+]
- *	    (National Instruments) PCI-1200 [pci-1200]
  * Author: Frank Mori Hess <fmhess@users.sourceforge.net>
  * Status: works
  *
@@ -34,9 +33,6 @@
  *		conversions)
  *   [2] - DMA channel (optional)
  *
- * Configuration options - PCI boards:
- *    not applicable, uses PCI auto config
- *
  * Tested with lab-pc-1200.  For the older Lab-PC+, not all input
  * ranges and analog references will work, the available ranges/arefs
  * will depend on how you have configured the jumpers on your board
@@ -62,11 +58,9 @@
  *
  * NI manuals:
  * 341309a (labpc-1200 register manual)
- * 340914a (pci-1200)
  * 320502b (lab-pc+)
  */
 
-#include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/io.h>
@@ -78,7 +72,6 @@
 
 #include "8253.h"
 #include "8255.h"
-#include "mite.h"
 #include "comedi_fc.h"
 #include "ni_labpc.h"
 
@@ -241,6 +234,7 @@ static inline void labpc_writeb(unsigned int byte, unsigned long address)
 	writeb(byte, (void __iomem *)address);
 }
 
+#ifdef CONFIG_COMEDI_NI_LABPC_ISA
 static const struct labpc_boardinfo labpc_boards[] = {
 	{
 		.name			= "lab-pc-1200",
@@ -268,21 +262,8 @@ static const struct labpc_boardinfo labpc_boards[] = {
 		.ai_range_table		= &range_labpc_plus_ai,
 		.ai_range_code		= labpc_plus_ai_gain_bits,
 	},
-#ifdef CONFIG_COMEDI_PCI_DRIVERS
-	{
-		.name			= "pci-1200",
-		.device_id		= 0x161,
-		.ai_speed		= 10000,
-		.bustype		= pci_bustype,
-		.register_layout	= labpc_1200_layout,
-		.has_ao			= 1,
-		.ai_range_table		= &range_labpc_1200_ai,
-		.ai_range_code		= labpc_1200_ai_gain_bits,
-		.ai_scan_up		= 1,
-		.has_mmio		= 1,
-	},
-#endif
 };
+#endif
 
 /* size in bytes of dma buffer */
 static const int dma_buffer_size = 0xff00;
@@ -1754,12 +1735,19 @@ int labpc_common_attach(struct comedi_device *dev,
 }
 EXPORT_SYMBOL_GPL(labpc_common_attach);
 
+void labpc_common_detach(struct comedi_device *dev)
+{
+	comedi_spriv_free(dev, 2);
+}
+EXPORT_SYMBOL_GPL(labpc_common_detach);
+
+#ifdef CONFIG_COMEDI_NI_LABPC_ISA
 static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv;
-	unsigned int irq = 0;
-	unsigned int dma_chan = 0;
+	unsigned int irq = it->options[1];
+	unsigned int dma_chan = it->options[2];
 	int ret;
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
@@ -1767,161 +1755,50 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	/* get base address, irq etc. based on bustype */
-	switch (board->bustype) {
-	case isa_bustype:
-#ifdef CONFIG_ISA_DMA_API
-		irq = it->options[1];
-		dma_chan = it->options[2];
-		ret = comedi_request_region(dev, it->options[0], LABPC_SIZE);
-		if (ret)
-			return ret;
-#else
-		dev_err(dev->class_dev,
-			"ni_labpc driver has not been built with ISA DMA support.\n");
-		return -EINVAL;
-#endif
-		break;
-	case pci_bustype:
-#ifdef CONFIG_COMEDI_PCI_DRIVERS
-		dev_err(dev->class_dev,
-			"manual configuration of PCI board '%s' is not supported\n",
-			board->name);
-		return -EINVAL;
-#else
-		dev_err(dev->class_dev,
-			"ni_labpc driver has not been built with PCI support.\n");
-		return -EINVAL;
-#endif
-		break;
-	default:
-		dev_err(dev->class_dev,
-			"ni_labpc: bug! couldn't determine board type\n");
-		return -EINVAL;
-		break;
-	}
-
-	return labpc_common_attach(dev, irq, dma_chan);
-}
-
-static const struct labpc_boardinfo *
-labpc_pci_find_boardinfo(struct pci_dev *pcidev)
-{
-	unsigned int device_id = pcidev->device;
-	unsigned int n;
-
-	for (n = 0; n < ARRAY_SIZE(labpc_boards); n++) {
-		const struct labpc_boardinfo *board = &labpc_boards[n];
-		if (board->bustype == pci_bustype &&
-		    board->device_id == device_id)
-			return board;
-	}
-	return NULL;
-}
-
-static int labpc_auto_attach(struct comedi_device *dev,
-				       unsigned long context_unused)
-{
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	const struct labpc_boardinfo *board;
-	struct labpc_private *devpriv;
-	unsigned int irq;
-	int ret;
-
-	if (!IS_ENABLED(CONFIG_COMEDI_PCI_DRIVERS))
-		return -ENODEV;
-
-	ret = comedi_pci_enable(dev);
+	ret = comedi_request_region(dev, it->options[0], LABPC_SIZE);
 	if (ret)
 		return ret;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
-	if (!devpriv)
-		return -ENOMEM;
-	dev->private = devpriv;
-
-	board = labpc_pci_find_boardinfo(pcidev);
-	if (!board)
-		return -ENODEV;
-	dev->board_ptr = board;
-	dev->board_name = board->name;
-	devpriv->mite = mite_alloc(pcidev);
-	if (!devpriv->mite)
-		return -ENOMEM;
-	ret = mite_setup(devpriv->mite);
-	if (ret < 0)
-		return ret;
-	dev->iobase = (unsigned long)devpriv->mite->daq_io_addr;
-	irq = mite_irq(devpriv->mite);
-	return labpc_common_attach(dev, irq, 0);
+	return labpc_common_attach(dev, irq, dma_chan);
 }
 
-void labpc_common_detach(struct comedi_device *dev)
+void labpc_detach(struct comedi_device *dev)
 {
-	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 
-	if (!board)
-		return;
-	comedi_spriv_free(dev, 2);
-#ifdef CONFIG_ISA_DMA_API
-	/* only free stuff if it has been allocated by _attach */
-	kfree(devpriv->dma_buffer);
-	if (devpriv->dma_chan)
-		free_dma(devpriv->dma_chan);
-#endif
-	if (board->bustype == isa_bustype)
-		comedi_legacy_detach(dev);
-#ifdef CONFIG_COMEDI_PCI_DRIVERS
-	if (devpriv->mite) {
-		mite_unsetup(devpriv->mite);
-		mite_free(devpriv->mite);
-	}
-	if (board->bustype == pci_bustype) {
-		if (dev->irq)
-			free_irq(dev->irq, dev);
-		comedi_pci_disable(dev);
+	labpc_common_detach(dev);
+
+	if (devpriv) {
+		kfree(devpriv->dma_buffer);
+		if (devpriv->dma_chan)
+			free_dma(devpriv->dma_chan);
 	}
-#endif
+	comedi_legacy_detach(dev);
 }
-EXPORT_SYMBOL_GPL(labpc_common_detach);
 
 static struct comedi_driver labpc_driver = {
 	.driver_name	= "ni_labpc",
 	.module		= THIS_MODULE,
 	.attach		= labpc_attach,
-	.auto_attach	= labpc_auto_attach,
-	.detach		= labpc_common_detach,
+	.detach		= labpc_detach,
 	.num_names	= ARRAY_SIZE(labpc_boards),
 	.board_name	= &labpc_boards[0].name,
 	.offset		= sizeof(struct labpc_boardinfo),
 };
-
-#ifdef CONFIG_COMEDI_PCI_DRIVERS
-static DEFINE_PCI_DEVICE_TABLE(labpc_pci_table) = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_NI, 0x161) },
-	{ 0 }
-};
-MODULE_DEVICE_TABLE(pci, labpc_pci_table);
-
-static int labpc_pci_probe(struct pci_dev *dev,
-			   const struct pci_device_id *id)
+module_comedi_driver(labpc_driver);
+#else
+static int __init labpc_common_init(void)
 {
-	return comedi_pci_auto_config(dev, &labpc_driver, id->driver_data);
+	return 0;
 }
+module_init(labpc_common_init);
 
-static struct pci_driver labpc_pci_driver = {
-	.name		= "ni_labpc",
-	.id_table	= labpc_pci_table,
-	.probe		= labpc_pci_probe,
-	.remove		= comedi_pci_auto_unconfig,
-};
-module_comedi_pci_driver(labpc_driver, labpc_pci_driver);
-#else
-module_comedi_driver(labpc_driver);
+static void __exit labpc_common_exit(void)
+{
+}
+module_exit(labpc_common_exit);
 #endif
 
-
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");
 MODULE_LICENSE("GPL");

commit 3d1fe3f785c80e17f62acf8f92570ae9210bd588
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:37 2013 -0700

    staging: comedi: drivers: free_irq() in comedi_legacy_detach()
    
    All the legacy comedi drivers now call comedi_legacy_detach()
    either directly or as part of their (*detach). Move the free_irq()
    into comedi_legacy_detach() so that the drivers don't have to
    deal with it.
    
    For drivers that then only call comedi_legacy_detach() in their
    private (*detach), remove the private function and use the helper
    directly for the (*detach).
    
    The amplc_pc236 and ni_labpc drivers are hybrid legacy/PCI drivers.
    In the detach of a PCI board free_irq() still needs to be handled
    by the driver.
    
    The pcl724 and pcl726 drivers currently have the free_irq() #ifdef'ed
    out. The comedi_legacy_detach() function sanity checks that the irq
    has been requested before freeing it so they are safe to convert.
    
    For aesthetic reasons, move the #ifdef unused chunk in the pcl816
    driver up to the previous #ifdef unused block.
    
    The pcmio and pcmuio drivers request multiple irqs and handle the
    freeing of them. Remove the 'dev->irq = irq[0]' in those drivers
    so that comedi_legacy_detach() does not attempt to free the irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 1137281004d2..96a6837774e0 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1870,8 +1870,6 @@ void labpc_common_detach(struct comedi_device *dev)
 	if (devpriv->dma_chan)
 		free_dma(devpriv->dma_chan);
 #endif
-	if (dev->irq)
-		free_irq(dev->irq, dev);
 	if (board->bustype == isa_bustype)
 		comedi_legacy_detach(dev);
 #ifdef CONFIG_COMEDI_PCI_DRIVERS
@@ -1879,8 +1877,11 @@ void labpc_common_detach(struct comedi_device *dev)
 		mite_unsetup(devpriv->mite);
 		mite_free(devpriv->mite);
 	}
-	if (board->bustype == pci_bustype)
+	if (board->bustype == pci_bustype) {
+		if (dev->irq)
+			free_irq(dev->irq, dev);
 		comedi_pci_disable(dev);
+	}
 #endif
 }
 EXPORT_SYMBOL_GPL(labpc_common_detach);

commit a32c6d0084992d3e58a93120c9ce9527e80c651e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:19 2013 -0700

    staging: comedi: drivers: use comedi_legacy_detach()
    
    Use comedi_legacy_detach() to release the I/O region requested
    by these drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index d48511f0cacd..1137281004d2 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1872,8 +1872,8 @@ void labpc_common_detach(struct comedi_device *dev)
 #endif
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (board->bustype == isa_bustype && dev->iobase)
-		release_region(dev->iobase, LABPC_SIZE);
+	if (board->bustype == isa_bustype)
+		comedi_legacy_detach(dev);
 #ifdef CONFIG_COMEDI_PCI_DRIVERS
 	if (devpriv->mite) {
 		mite_unsetup(devpriv->mite);

commit 2f69915c728c3be41e12dbbbdd4eeb8d3388d58c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 15 16:41:57 2013 -0700

    staging: comedi: introduce, and use, comedi_spriv_free()
    
    The comedi_subdevice 'private' variable is a void * that is available
    for the subdevice to use in manner. It's common in comedi drivers for
    the driver to allocate memory for a subdevice and store the pointer
    to that memory in the 'private' variable. It's then the responsibility
    of the driver to free that memory when the device is detached.
    
    Due to how the attach/detach works in comedi, the drivers need to do
    some sanity checking before they can free the allocated memory during
    the detach.
    
    Introduce a helper function, comedi_spriv_free(), to handle freeing
    the private data allocated for a subdevice. This allows moving all the
    sanity checks into the helper function and makes it safe to call
    with any context. It also allows removing some of the boilerplate
    code in the (*detach) functions.
    
    Remove the subdev_8255_cleanup() export in the 8255 subdevice driver
    as well as the addi_watchdog_cleanup() export in the addi_watchdog
    driver and use the new helper instead.
    
    The amplc_dio200_common driver uses a number of local helper functions
    to free the private data for it's subdevices. Remove those as well and
    use the new helper.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 19961424d1df..d48511f0cacd 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1860,14 +1860,10 @@ void labpc_common_detach(struct comedi_device *dev)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
-	struct comedi_subdevice *s;
 
 	if (!board)
 		return;
-	if (dev->subdevices) {
-		s = &dev->subdevices[2];
-		subdev_8255_cleanup(dev, s);
-	}
+	comedi_spriv_free(dev, 2);
 #ifdef CONFIG_ISA_DMA_API
 	/* only free stuff if it has been allocated by _attach */
 	kfree(devpriv->dma_buffer);

commit 5b365a8ace90bd027a34f0db4c1c28f2ba433910
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:34:36 2013 -0700

    staging: comedi: ni_labpc: use comedi_request_region()
    
    Use comedi_request_region() to request the I/O region used by this
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 8083f4815693..19961424d1df 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1758,9 +1758,9 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv;
-	unsigned long iobase = 0;
 	unsigned int irq = 0;
 	unsigned int dma_chan = 0;
+	int ret;
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
@@ -1771,12 +1771,11 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	switch (board->bustype) {
 	case isa_bustype:
 #ifdef CONFIG_ISA_DMA_API
-		iobase = it->options[0];
 		irq = it->options[1];
 		dma_chan = it->options[2];
-		if (!request_region(iobase, LABPC_SIZE, dev->board_name))
-			return -EIO;
-		dev->iobase = iobase;
+		ret = comedi_request_region(dev, it->options[0], LABPC_SIZE);
+		if (ret)
+			return ret;
 #else
 		dev_err(dev->class_dev,
 			"ni_labpc driver has not been built with ISA DMA support.\n");

commit de024b3d57ba93f8a63a1610a15587e3358d4a4d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:34:17 2013 -0700

    staging: comedi: ni_labpc: only ISA boards need to request_region()
    
    Currently this driver calls request_region() in labpc_common_attach()
    which is the common attach function for the ISA, PCMCIA, and PCI
    versions of the labpc board.
    
    The PCMCIA support is handled in a separate driver, ni_labpc_cs.
    That driver sets the dev->iobase after aquiring the resource and
    then just passes it to labpc_common_attach() which then sets
    dev->iobase again.
    
    The PCI support, currently in this driver, calls mite_setup() to
    aquire the resource and then passes it to labpc_common_attach()
    to set the dev->iobase.
    
    The ISA support, also in this driver, passes a user supplied
    configuration option to labpc_common_attach() which then does
    the request_region() before setting the dev->iobase.
    
    Move the request_region() to the ISA support code in labpc_attach()
    and set the dev->iobase there before calling the common attach
    code.
    
    For the PCI support, also set the dev->iobase before calling the
    common code.
    
    This allows removing the extra parameter from labpc_common_attach().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index e46854f8e932..8083f4815693 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1606,7 +1606,7 @@ static int labpc_eeprom_insn_read(struct comedi_device *dev,
 	return insn->n;
 }
 
-int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
+int labpc_common_attach(struct comedi_device *dev,
 			unsigned int irq, unsigned int dma_chan)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
@@ -1616,14 +1616,6 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	int ret;
 	int i;
 
-	if (iobase == 0)
-		return -EINVAL;
-	if (board->bustype == isa_bustype) {
-		if (!request_region(iobase, LABPC_SIZE, dev->board_name))
-			return -EIO;
-	}
-	dev->iobase = iobase;
-
 	if (board->has_mmio) {
 		devpriv->read_byte = labpc_readb;
 		devpriv->write_byte = labpc_writeb;
@@ -1782,6 +1774,9 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		iobase = it->options[0];
 		irq = it->options[1];
 		dma_chan = it->options[2];
+		if (!request_region(iobase, LABPC_SIZE, dev->board_name))
+			return -EIO;
+		dev->iobase = iobase;
 #else
 		dev_err(dev->class_dev,
 			"ni_labpc driver has not been built with ISA DMA support.\n");
@@ -1807,7 +1802,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		break;
 	}
 
-	return labpc_common_attach(dev, iobase, irq, dma_chan);
+	return labpc_common_attach(dev, irq, dma_chan);
 }
 
 static const struct labpc_boardinfo *
@@ -1831,7 +1826,6 @@ static int labpc_auto_attach(struct comedi_device *dev,
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	const struct labpc_boardinfo *board;
 	struct labpc_private *devpriv;
-	unsigned long iobase;
 	unsigned int irq;
 	int ret;
 
@@ -1858,9 +1852,9 @@ static int labpc_auto_attach(struct comedi_device *dev,
 	ret = mite_setup(devpriv->mite);
 	if (ret < 0)
 		return ret;
-	iobase = (unsigned long)devpriv->mite->daq_io_addr;
+	dev->iobase = (unsigned long)devpriv->mite->daq_io_addr;
 	irq = mite_irq(devpriv->mite);
-	return labpc_common_attach(dev, iobase, irq, 0);
+	return labpc_common_attach(dev, irq, 0);
 }
 
 void labpc_common_detach(struct comedi_device *dev)

commit 7a1e1f9ae5f15026126f09311b158d6673ad8200
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:33:59 2013 -0700

    staging: comedi: ni_labpc: cleanup dev->board_name usage
    
    The dev->board_name is initialized by the comedi core before calling
    the (*attach) or (*auto_attach) functions. It only needs to be updated
    if the driver does any additional probing and changes the dev->board_ptr.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 22f8d45ae6d5..e46854f8e932 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1616,8 +1616,6 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	int ret;
 	int i;
 
-	dev->board_name = board->name;
-
 	if (iobase == 0)
 		return -EINVAL;
 	if (board->bustype == isa_bustype) {
@@ -1831,6 +1829,7 @@ static int labpc_auto_attach(struct comedi_device *dev,
 				       unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	const struct labpc_boardinfo *board;
 	struct labpc_private *devpriv;
 	unsigned long iobase;
 	unsigned int irq;
@@ -1848,9 +1847,11 @@ static int labpc_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	dev->board_ptr = labpc_pci_find_boardinfo(pcidev);
-	if (!dev->board_ptr)
+	board = labpc_pci_find_boardinfo(pcidev);
+	if (!board)
 		return -ENODEV;
+	dev->board_ptr = board;
+	dev->board_name = board->name;
 	devpriv->mite = mite_alloc(pcidev);
 	if (!devpriv->mite)
 		return -ENOMEM;

commit 7c00782b1d4b9073ae38891d636302b1267285af
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 10:27:33 2013 -0700

    staging: comedi: ni_labpc: fix labpc_calib_insn_write()
    
    The comedi core expects the (*insn_write) operations to write insn->n
    values and return the number of values actually wrote.
    
    Make this function work like the core expects.
    
    As Ian Abbott pointed out for the eeprom writes, we really only need
    to write the last value to the caldac. The preceding data would be
    overwritten anyway.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index bae72eb73451..22f8d45ae6d5 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1539,10 +1539,16 @@ static int labpc_calib_insn_write(struct comedi_device *dev,
 				  struct comedi_insn *insn,
 				  unsigned int *data)
 {
-	int channel = CR_CHAN(insn->chanspec);
+	unsigned int chan = CR_CHAN(insn->chanspec);
 
-	write_caldac(dev, channel, data[0]);
-	return 1;
+	/*
+	 * Only write the last data value to the caldac. Preceding
+	 * data would be overwritten anyway.
+	 */
+	if (insn->n > 0)
+		write_caldac(dev, chan, data[insn->n - 1]);
+
+	return insn->n;
 }
 
 static int labpc_calib_insn_read(struct comedi_device *dev,

commit 198ac9dc7f0d06cd760d376c6a6c6217c5968d4a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 10:27:11 2013 -0700

    staging: comedi: ni_labpc: fix labpc_calib_insn_read()
    
    The comedi core expects the (*insn_read) operations to read insn->n
    values and return the number of values actually read.
    
    Make this function work like the core expects.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index b0ec088a7285..bae72eb73451 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1551,10 +1551,13 @@ static int labpc_calib_insn_read(struct comedi_device *dev,
 				 unsigned int *data)
 {
 	struct labpc_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int i;
 
-	data[0] = devpriv->caldac[CR_CHAN(insn->chanspec)];
+	for (i = 0; i < insn->n; i++)
+		data[i] = devpriv->caldac[chan];
 
-	return 1;
+	return insn->n;
 }
 
 static int labpc_eeprom_insn_write(struct comedi_device *dev,

commit 43d092c67740704c9a8d04da2ca070bfca34207a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 10:26:38 2013 -0700

    staging: comedi: ni_labpc: simplify labpc_range_is_unipolar()
    
    As Ian Abbott pointed out, this helper function can be simplified
    by just checking if the 'min' value is >= 0.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index a9117f77b9b2..b0ec088a7285 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -320,13 +320,7 @@ static int labpc_counter_set_mode(struct comedi_device *dev,
 static bool labpc_range_is_unipolar(struct comedi_subdevice *s,
 				    unsigned int range)
 {
-	const struct comedi_lrange *lrange = s->range_table;
-	const struct comedi_krange *krange = &lrange->range[range];
-
-	if (krange->min < 0)
-		return false;
-	else
-		return true;
+	return s->range_table->range[range].min >= 0;
 }
 
 static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)

commit e7a1aa62823d8cc861aaad078006e6742c114a0e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 26 10:25:57 2013 -0700

    staging: comedi: ni_labpc: fix labpc_eeprom_insn_write()
    
    The comedi core expects the (*insn_write) operations to write insn->n
    values and return the number of values actually wrote.
    
    Make this function work like the core expects.
    
    As Ian Abbott pointed out, we really only need to write the last value
    to the eeprom. The preceding data would be overwritten anyway.
    
    Also, remove the noise about invalid channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 0afcede602ec..a9117f77b9b2 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1568,21 +1568,24 @@ static int labpc_eeprom_insn_write(struct comedi_device *dev,
 				   struct comedi_insn *insn,
 				   unsigned int *data)
 {
-	int channel = CR_CHAN(insn->chanspec);
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	int ret;
 
-	/*  only allow writes to user area of eeprom */
-	if (channel < 16 || channel > 127) {
-		dev_dbg(dev->class_dev,
-			"eeprom writes are only allowed to channels 16 through 127 (the pointer and user areas)\n");
+	/* only allow writes to user area of eeprom */
+	if (chan < 16 || chan > 127)
 		return -EINVAL;
-	}
 
-	ret = labpc_eeprom_write(dev, channel, data[0]);
-	if (ret < 0)
-		return ret;
+	/*
+	 * Only write the last data value to the eeprom. Preceding
+	 * data would be overwritten anyway.
+	 */
+	if (insn->n > 0) {
+		ret = labpc_eeprom_write(dev, chan, data[insn->n - 1]);
+		if (ret)
+			return ret;
+	}
 
-	return 1;
+	return insn->n;
 }
 
 static int labpc_eeprom_insn_read(struct comedi_device *dev,

commit 1330af4c7deedd0b6d1ba43734d7e4eb1a83a491
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:57:48 2013 -0700

    staging: comedi: ni_labpc: fix labpc_eeprom_insn_read()
    
    The comedi core expects the (*insn_read) operations to read insn->n
    values and return the number of values actually read.
    
    Make this function work like the core expects.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 234f85e0f2f2..0afcede602ec 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1591,10 +1591,13 @@ static int labpc_eeprom_insn_read(struct comedi_device *dev,
 				  unsigned int *data)
 {
 	struct labpc_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int i;
 
-	data[0] = devpriv->eeprom_data[CR_CHAN(insn->chanspec)];
+	for (i = 0; i < insn->n; i++)
+		data[i] = devpriv->eeprom_data[chan];
 
-	return 1;
+	return insn->n;
 }
 
 int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,

commit 63a93381ef17902c1d8dd33506163c43cf2178be
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:57:26 2013 -0700

    staging: comedi: ni_labpc: return bool from labpc_use_continuous_mode()
    
    This is a simple true/false test, return bool instead of int.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index f6128751a578..234f85e0f2f2 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -519,16 +519,13 @@ static unsigned int labpc_suggest_transfer_size(const struct comedi_cmd *cmd)
 }
 #endif
 
-static int labpc_use_continuous_mode(const struct comedi_cmd *cmd,
-				     enum scan_mode mode)
+static bool labpc_use_continuous_mode(const struct comedi_cmd *cmd,
+				      enum scan_mode mode)
 {
-	if (mode == MODE_SINGLE_CHAN)
-		return 1;
-
-	if (cmd->scan_begin_src == TRIG_FOLLOW)
-		return 1;
+	if (mode == MODE_SINGLE_CHAN || cmd->scan_begin_src == TRIG_FOLLOW)
+		return true;
 
-	return 0;
+	return false;
 }
 
 static unsigned int labpc_ai_convert_period(const struct comedi_cmd *cmd,
@@ -1042,7 +1039,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->cmd4 |= CMD4_ECLKRCV;
 	/* XXX should discard first scan when using interval scanning
 	 * since manual says it is not synced with scan clock */
-	if (labpc_use_continuous_mode(cmd, mode) == 0) {
+	if (!labpc_use_continuous_mode(cmd, mode)) {
 		devpriv->cmd4 |= CMD4_INTSCAN;
 		if (cmd->scan_begin_src == TRIG_EXT)
 			devpriv->cmd4 |= CMD4_EOIRCV;

commit 58cd9b91f809196adb39b52d1c18069ca73c8103
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:56:48 2013 -0700

    staging: comedi: ni_labpc: cleanup trigger setting in labpc_ai_cmd()
    
    The (*do_cmdtest) already validated the cmd sources so the default
    cases in the switch() statements can never happen.
    
    Preclear to trigger bits and change the switch() statements to simple
    if() tests to set the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 244b3e51ee3b..f6128751a578 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1054,38 +1054,21 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/*  startup acquisition */
 
-	/*  cmd2 reg */
-	/*  use 2 cascaded counters for pacing */
 	spin_lock_irqsave(&dev->spinlock, flags);
+
+	/* use 2 cascaded counters for pacing */
 	devpriv->cmd2 |= CMD2_TBSEL;
-	switch (cmd->start_src) {
-	case TRIG_EXT:
+
+	devpriv->cmd2 &= ~(CMD2_SWTRIG | CMD2_HWTRIG | CMD2_PRETRIG);
+	if (cmd->start_src == TRIG_EXT)
 		devpriv->cmd2 |= CMD2_HWTRIG;
-		devpriv->cmd2 &= ~(CMD2_PRETRIG | CMD2_SWTRIG);
-		break;
-	case TRIG_NOW:
+	else
 		devpriv->cmd2 |= CMD2_SWTRIG;
-		devpriv->cmd2 &= ~(CMD2_PRETRIG | CMD2_HWTRIG);
-		break;
-	default:
-		comedi_error(dev, "bug with start_src");
-		spin_unlock_irqrestore(&dev->spinlock, flags);
-		return -1;
-		break;
-	}
-	switch (cmd->stop_src) {
-	case TRIG_EXT:
+	if (cmd->stop_src == TRIG_EXT)
 		devpriv->cmd2 |= (CMD2_HWTRIG | CMD2_PRETRIG);
-		break;
-	case TRIG_COUNT:
-	case TRIG_NONE:
-		break;
-	default:
-		comedi_error(dev, "bug with stop_src");
-		spin_unlock_irqrestore(&dev->spinlock, flags);
-		return -1;
-	}
+
 	devpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);
+
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return 0;

commit 83d75effa74dc26f5c989f7a4385c345dff1e58f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:56:25 2013 -0700

    staging: comedi: ni_labpc: remove board attach noise
    
    Remove the kernel noise in labpc_common_attach() as well as a couple
    obvious comments.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 926c4f12d04c..244b3e51ee3b 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1629,18 +1629,11 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 	dev->board_name = board->name;
 
-	dev_info(dev->class_dev, "ni_labpc: %s\n", dev->board_name);
-	if (iobase == 0) {
-		dev_err(dev->class_dev, "io base address is zero!\n");
+	if (iobase == 0)
 		return -EINVAL;
-	}
-	/*  request io regions for isa boards */
 	if (board->bustype == isa_bustype) {
-		/* check if io addresses are available */
-		if (!request_region(iobase, LABPC_SIZE, dev->board_name)) {
-			dev_err(dev->class_dev, "I/O port conflict\n");
+		if (!request_region(iobase, LABPC_SIZE, dev->board_name))
 			return -EIO;
-		}
 	}
 	dev->iobase = iobase;
 
@@ -1651,6 +1644,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		devpriv->read_byte = labpc_inb;
 		devpriv->write_byte = labpc_outb;
 	}
+
 	/* initialize board's command registers */
 	devpriv->write_byte(devpriv->cmd1, dev->iobase + CMD1_REG);
 	devpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);

commit 290899082a4214b16537be64a6b7e3882bb5aeb1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:55:54 2013 -0700

    staging: comedi: ni_labpc: dma requires an interrupt
    
    DMA support only works if an interrupt is available.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 744db1f5aa25..926c4f12d04c 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1673,7 +1673,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	}
 
 #ifdef CONFIG_ISA_DMA_API
-	if (dma_chan == 1 || dma_chan == 3) {
+	if (dev->irq && (dma_chan == 1 || dma_chan == 3)) {
 		devpriv->dma_buffer = kmalloc(dma_buffer_size,
 					      GFP_KERNEL | GFP_DMA);
 		if (devpriv->dma_buffer) {

commit 19a40abf5ee320e8f0874116989773b7c071aa08
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:55:30 2013 -0700

    staging: comedi: ni_labpc: allow board to attach without dma
    
    If the dma channel is not available this driver will still work
    with interrupts for the analog input subdevice command support.
    
    In addition, only dma channels 1 and 3 are valid for the ISA
    devices.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index a52647a901f6..744db1f5aa25 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1673,30 +1673,23 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	}
 
 #ifdef CONFIG_ISA_DMA_API
-	/* grab dma channel */
-	if (dma_chan > 3) {
-		dev_err(dev->class_dev, "invalid dma channel %u\n", dma_chan);
-		return -EINVAL;
-	} else if (dma_chan) {
-		unsigned long dma_flags;
-
-		/* allocate dma buffer */
+	if (dma_chan == 1 || dma_chan == 3) {
 		devpriv->dma_buffer = kmalloc(dma_buffer_size,
 					      GFP_KERNEL | GFP_DMA);
-		if (devpriv->dma_buffer == NULL)
-			return -ENOMEM;
-
-		if (request_dma(dma_chan, dev->board_name)) {
-			dev_err(dev->class_dev,
-				"failed to allocate dma channel %u\n",
-				dma_chan);
-			return -EINVAL;
+		if (devpriv->dma_buffer) {
+			ret = request_dma(dma_chan, dev->board_name);
+			if (ret == 0) {
+				unsigned long dma_flags;
+
+				devpriv->dma_chan = dma_chan;
+				dma_flags = claim_dma_lock();
+				disable_dma(devpriv->dma_chan);
+				set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
+				release_dma_lock(dma_flags);
+			} else {
+				kfree(devpriv->dma_buffer);
+			}
 		}
-		devpriv->dma_chan = dma_chan;
-		dma_flags = claim_dma_lock();
-		disable_dma(devpriv->dma_chan);
-		set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
-		release_dma_lock(dma_flags);
 	}
 #endif
 

commit 0229979a329e7354adb17d3ccb98bce82d73eb59
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:55:08 2013 -0700

    staging: comedi: ni_labpc: allow board to attach without interrupt
    
    If the interrupt is not available this driver will still work
    with command support disabled for the analog input subdevice.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 350ba0454bd6..a52647a901f6 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1661,20 +1661,16 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		devpriv->write_byte(devpriv->cmd6, dev->iobase + CMD6_REG);
 	}
 
-	/* grab our IRQ */
 	if (irq) {
 		isr_flags = 0;
 		if (board->bustype == pci_bustype ||
 		    board->bustype == pcmcia_bustype)
 			isr_flags |= IRQF_SHARED;
-		if (request_irq(irq, labpc_interrupt, isr_flags,
-				dev->board_name, dev)) {
-			dev_err(dev->class_dev, "unable to allocate irq %u\n",
-				irq);
-			return -EINVAL;
-		}
+		ret = request_irq(irq, labpc_interrupt, isr_flags,
+				  dev->board_name, dev);
+		if (ret == 0)
+			dev->irq = irq;
 	}
-	dev->irq = irq;
 
 #ifdef CONFIG_ISA_DMA_API
 	/* grab dma channel */

commit f06563f0132b21ce4258f977c58f9eb01c90cdd3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:54:41 2013 -0700

    staging: comedi: ni_labpc: return error from labpc_counter_set_mode()
    
    Make sure labpc_counter_set_mode() was successfull and return any
    errno back to the caller.
    
    For the if/else conditions that either load the counter of just set
    the mode, use a common error patch to check for the error.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 5782b019697d..350ba0454bd6 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -472,8 +472,10 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 	devpriv->write_byte(devpriv->cmd4, dev->iobase + CMD4_REG);
 
 	/* initialize pacer counter to prevent any problems */
-	labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
-			       0, I8254_MODE2);
+	ret = labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
+				     0, I8254_MODE2);
+	if (ret)
+		return ret;
 
 	labpc_clear_adc_fifo(dev);
 
@@ -901,14 +903,15 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
 					 1, 3, I8254_MODE0);
-		if (ret < 0) {
-			comedi_error(dev, "error loading counter a1");
-			return -1;
-		}
 	} else	{
 		/* just put counter a1 in mode 0 to set its output low */
-		labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
-				       1, I8254_MODE0);
+		ret = labpc_counter_set_mode(dev,
+					     dev->iobase + COUNTER_A_BASE_REG,
+					     1, I8254_MODE0);
+	}
+	if (ret) {
+		comedi_error(dev, "error loading counter a1");
+		return ret;
 	}
 
 #ifdef CONFIG_ISA_DMA_API
@@ -972,14 +975,15 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/*  load counter a0 in mode 2 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
 					 0, devpriv->divisor_a0, I8254_MODE2);
-		if (ret < 0) {
-			comedi_error(dev, "error loading counter a0");
-			return -1;
-		}
 	} else {
 		/* initialize pacer counter to prevent any problems */
-		labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
-				       0, I8254_MODE2);
+		ret = labpc_counter_set_mode(dev,
+					     dev->iobase + COUNTER_A_BASE_REG,
+					     0, I8254_MODE2);
+	}
+	if (ret) {
+		comedi_error(dev, "error loading counter a0");
+		return ret;
 	}
 
 	/*  set up scan pacing */

commit fbca05d601a94d16912613d119f5b672a75a587f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:54:16 2013 -0700

    staging: comedi: ni_labpc: cleanup labpc_counter_load() usage
    
    For aesthetic reasons, move the labpc_counter_load() function so
    it's by the labpc_counter_set_mode() function.
    
    Update all the labpc_counter_load() calls so that the I8254_MODE*
    enums are used instead of the open coded values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index ba9c97d29398..5782b019697d 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -289,6 +289,20 @@ static const int dma_buffer_size = 0xff00;
 /* 2 bytes per sample */
 static const int sample_size = 2;
 
+static int labpc_counter_load(struct comedi_device *dev,
+			      unsigned long base_address,
+			      unsigned int counter_number,
+			      unsigned int count, unsigned int mode)
+{
+	const struct labpc_boardinfo *board = comedi_board(dev);
+
+	if (board->has_mmio)
+		return i8254_mm_load((void __iomem *)base_address, 0,
+				     counter_number, count, mode);
+	else
+		return i8254_load(base_address, 0, counter_number, count, mode);
+}
+
 static int labpc_counter_set_mode(struct comedi_device *dev,
 				  unsigned long base_address,
 				  unsigned int counter_number,
@@ -855,20 +869,6 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
-static int labpc_counter_load(struct comedi_device *dev,
-			      unsigned long base_address,
-			      unsigned int counter_number,
-			      unsigned int count, unsigned int mode)
-{
-	const struct labpc_boardinfo *board = comedi_board(dev);
-
-	if (board->has_mmio)
-		return i8254_mm_load((void __iomem *)base_address, 0,
-				     counter_number, count, mode);
-	else
-		return i8254_load(base_address, 0, counter_number, count, mode);
-}
-
 static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
@@ -900,7 +900,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * (pc+ manual says this is minimum allowed) using mode 0
 		 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
-					 1, 3, 0);
+					 1, 3, I8254_MODE0);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter a1");
 			return -1;
@@ -961,7 +961,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		labpc_adc_timing(dev, cmd, mode);
 		/*  load counter b0 in mode 3 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
-					 0, devpriv->divisor_b0, 3);
+					 0, devpriv->divisor_b0, I8254_MODE3);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter b0");
 			return -1;
@@ -971,7 +971,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (labpc_ai_convert_period(cmd, mode)) {
 		/*  load counter a0 in mode 2 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
-					 0, devpriv->divisor_a0, 2);
+					 0, devpriv->divisor_a0, I8254_MODE2);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter a0");
 			return -1;
@@ -986,7 +986,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (labpc_ai_scan_period(cmd, mode)) {
 		/*  load counter b1 in mode 2 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
-					 1, devpriv->divisor_b1, 2);
+					 1, devpriv->divisor_b1, I8254_MODE2);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter b1");
 			return -1;

commit 463f930401024926eadf4c613a547f2eb41a2882
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:53:49 2013 -0700

    staging: comedi: ni_labpc: introduce labpc_counter_set_mode()
    
    Introduce labpc_counter_set_mode() which is a wrapper around the
    i8254_set_mode() helpers to program the 8254 timers. Use the new
    function instead of directly writing to the timer mode register
    with a "magic" number.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index bc4f3e689952..ba9c97d29398 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -134,9 +134,6 @@
 #define CMD4_ECLKRCV		(1 << 4)
 #define DIO_BASE_REG		0x10	/* R/W: 8255 DIO base reg */
 #define COUNTER_A_BASE_REG	0x14	/* R/W: 8253 Counter A base reg */
-#define COUNTER_A_MODE_REG	0x17	/* W: 8253 Counter A mode reg */
-#define INIT_A0_BITS		0x14	/*	(a0 mode 2) */
-#define INIT_A1_BITS		0x70	/*	(a1 mode 0) */
 #define COUNTER_B_BASE_REG	0x18	/* R/W: 8253 Counter B base reg */
 #define CMD5_REG		0x1c	/* W: Command 5 reg */
 #define CMD5_WRTPRT		(1 << 2)
@@ -292,6 +289,20 @@ static const int dma_buffer_size = 0xff00;
 /* 2 bytes per sample */
 static const int sample_size = 2;
 
+static int labpc_counter_set_mode(struct comedi_device *dev,
+				  unsigned long base_address,
+				  unsigned int counter_number,
+				  unsigned int mode)
+{
+	const struct labpc_boardinfo *board = comedi_board(dev);
+
+	if (board->has_mmio)
+		return i8254_mm_set_mode((void __iomem *)base_address, 0,
+					 counter_number, mode);
+	else
+		return i8254_set_mode(base_address, 0, counter_number, mode);
+}
+
 static bool labpc_range_is_unipolar(struct comedi_subdevice *s,
 				    unsigned int range)
 {
@@ -446,11 +457,9 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 		devpriv->cmd4 |= CMD4_SEDIFF;
 	devpriv->write_byte(devpriv->cmd4, dev->iobase + CMD4_REG);
 
-	/*
-	 * initialize pacer counter output to make sure it doesn't
-	 * cause any problems
-	 */
-	devpriv->write_byte(INIT_A0_BITS, dev->iobase + COUNTER_A_MODE_REG);
+	/* initialize pacer counter to prevent any problems */
+	labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
+			       0, I8254_MODE2);
 
 	labpc_clear_adc_fifo(dev);
 
@@ -896,12 +905,11 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			comedi_error(dev, "error loading counter a1");
 			return -1;
 		}
-	} else			/*
-				 * otherwise, just put a1 in mode 0
-				 * with no count to set its output low
-				 */
-		devpriv->write_byte(INIT_A1_BITS,
-				    dev->iobase + COUNTER_A_MODE_REG);
+	} else	{
+		/* just put counter a1 in mode 0 to set its output low */
+		labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
+				       1, I8254_MODE0);
+	}
 
 #ifdef CONFIG_ISA_DMA_API
 	/*  figure out what method we will use to transfer data */
@@ -968,9 +976,11 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			comedi_error(dev, "error loading counter a0");
 			return -1;
 		}
-	} else
-		devpriv->write_byte(INIT_A0_BITS,
-				    dev->iobase + COUNTER_A_MODE_REG);
+	} else {
+		/* initialize pacer counter to prevent any problems */
+		labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,
+				       0, I8254_MODE2);
+	}
 
 	/*  set up scan pacing */
 	if (labpc_ai_scan_period(cmd, mode)) {

commit 161ce6fa4b6c3538f104e51e101771a2abc72677
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:53:20 2013 -0700

    staging: comedi: ni_labpc: remove inline from labpc_counter_load()
    
    Let the compiler figure out if this function should be inlined.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 159d31d98707..bc4f3e689952 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -846,10 +846,10 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
-static inline int labpc_counter_load(struct comedi_device *dev,
-				     unsigned long base_address,
-				     unsigned int counter_number,
-				     unsigned int count, unsigned int mode)
+static int labpc_counter_load(struct comedi_device *dev,
+			      unsigned long base_address,
+			      unsigned int counter_number,
+			      unsigned int count, unsigned int mode)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 

commit 488ec9f12d8b9768798987b4660b82cbb6ed181b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:52:15 2013 -0700

    staging: comedi: ni_labpc: move a couple of the #define's
    
    For aesthetic reasons, move a couple of the #defines in this file
    so that the register map defines are first.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 8791caedd476..159d31d98707 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -82,11 +82,6 @@
 #include "comedi_fc.h"
 #include "ni_labpc.h"
 
-/* size of io region used by board */
-#define LABPC_SIZE           32
-/* 2 MHz master clock */
-#define LABPC_TIMER_BASE            500
-
 /*
  * Register map (all registers are 8-bit)
  */
@@ -157,6 +152,8 @@
 #define INTERVAL_COUNT_REG	0x1e	/* W: Interval Counter Data reg */
 #define INTERVAL_STROBE_REG	0x1f	/* W: Interval Counter Strobe reg */
 
+#define LABPC_SIZE		0x20	/* size of ISA io region */
+#define LABPC_TIMER_BASE	500	/* 2 MHz master clock */
 #define LABPC_ADC_TIMEOUT	1000
 
 enum scan_mode {

commit 42cb6a82a9ed770a3fccc8fbbff54a0fff1e9881
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:51:45 2013 -0700

    staging: comedi: ni_labpc: clean up register map
    
    Rename the register map defines to better match the National
    Instruments Register-Level Programming Manual for the labpc.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 94e25e761a28..8791caedd476 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -87,117 +87,75 @@
 /* 2 MHz master clock */
 #define LABPC_TIMER_BASE            500
 
-/* Registers for the lab-pc+ */
-
-/* write-only registers */
-#define COMMAND1_REG	0x0
-#define   ADC_GAIN_MASK	(0x7 << 4)
-#define   ADC_CHAN_BITS(x)	((x) & 0x7)
-/* enables multi channel scans */
-#define   ADC_SCAN_EN_BIT	0x80
-#define COMMAND2_REG	0x1
-/* enable pretriggering (used in conjunction with SWTRIG) */
-#define   PRETRIG_BIT	0x1
-/* enable paced conversions on external trigger */
-#define   HWTRIG_BIT	0x2
-/* enable paced conversions */
-#define   SWTRIG_BIT	0x4
-/* use two cascaded counters for pacing */
-#define   CASCADE_BIT	0x8
-#define   DAC_PACED_BIT(channel)	(0x40 << ((channel) & 0x1))
-#define COMMAND3_REG	0x2
-/* enable dma transfers */
-#define   DMA_EN_BIT	0x1
-/* enable interrupts for 8255 */
-#define   DIO_INTR_EN_BIT	0x2
-/* enable dma terminal count interrupt */
-#define   DMATC_INTR_EN_BIT	0x4
-/* enable timer interrupt */
-#define   TIMER_INTR_EN_BIT	0x8
-/* enable error interrupt */
-#define   ERR_INTR_EN_BIT	0x10
-/* enable fifo not empty interrupt */
-#define   ADC_FNE_INTR_EN_BIT	0x20
-#define ADC_CONVERT_REG	0x3
-#define DAC_LSB_REG(channel)	(0x4 + 2 * ((channel) & 0x1))
-#define DAC_MSB_REG(channel)	(0x5 + 2 * ((channel) & 0x1))
-#define ADC_CLEAR_REG	0x8
-#define DMATC_CLEAR_REG	0xa
-#define TIMER_CLEAR_REG	0xc
-/* 1200 boards only */
-#define COMMAND6_REG	0xe
-/* select ground or common-mode reference */
-#define   ADC_COMMON_BIT	0x1
-/*  adc unipolar */
-#define   ADC_UNIP_BIT	0x2
-/*  dac unipolar */
-#define   DAC_UNIP_BIT(channel)	(0x4 << ((channel) & 0x1))
-/* enable fifo half full interrupt */
-#define   ADC_FHF_INTR_EN_BIT	0x20
-/* enable interrupt on end of hardware count */
-#define   A1_INTR_EN_BIT	0x40
-/* scan up from channel zero instead of down to zero */
-#define   ADC_SCAN_UP_BIT 0x80
-#define COMMAND4_REG	0xf
-/* enables 'interval' scanning */
-#define   INTERVAL_SCAN_EN_BIT	0x1
-/* enables external signal on counter b1 output to trigger scan */
-#define   EXT_SCAN_EN_BIT	0x2
-/* chooses direction (output or input) for EXTCONV* line */
-#define   EXT_CONVERT_OUT_BIT	0x4
-/* chooses differential inputs for adc (in conjunction with board jumper) */
-#define   ADC_DIFF_BIT	0x8
-#define   EXT_CONVERT_DISABLE_BIT	0x10
-/* 1200 boards only, calibration stuff */
-#define COMMAND5_REG	0x1c
-/* enable eeprom for write */
-#define   EEPROM_WRITE_UNPROTECT_BIT	0x4
-/* enable dithering */
-#define   DITHER_EN_BIT	0x8
-/* load calibration dac */
-#define   CALDAC_LOAD_BIT	0x10
-/* serial clock - rising edge writes, falling edge reads */
-#define   SCLOCK_BIT	0x20
-/* serial data bit for writing to eeprom or calibration dacs */
-#define   SDATA_BIT	0x40
-/* enable eeprom for read/write */
-#define   EEPROM_EN_BIT	0x80
-#define INTERVAL_COUNT_REG	0x1e
-#define INTERVAL_LOAD_REG	0x1f
-#define   INTERVAL_LOAD_BITS	0x1
-
-/* read-only registers */
-#define STATUS1_REG	0x0
-/* data is available in fifo */
-#define   DATA_AVAIL_BIT	0x1
-/* overrun has occurred */
-#define   OVERRUN_BIT	0x2
-/* fifo overflow */
-#define   OVERFLOW_BIT	0x4
-/* timer interrupt has occurred */
-#define   TIMER_BIT	0x8
-/* dma terminal count has occurred */
-#define   DMATC_BIT	0x10
-/* external trigger has occurred */
-#define   EXT_TRIG_BIT	0x40
-/* 1200 boards only */
-#define STATUS2_REG	0x1d
-/* programmable eeprom serial output */
-#define   EEPROM_OUT_BIT	0x1
-/* counter A1 terminal count */
-#define   A1_TC_BIT	0x2
-/* fifo not half full */
-#define   FNHF_BIT	0x4
-#define ADC_FIFO_REG	0xa
-
-#define DIO_BASE_REG	0x10
-#define COUNTER_A_BASE_REG	0x14
-#define COUNTER_A_CONTROL_REG	(COUNTER_A_BASE_REG + 0x3)
-/* check modes put conversion pacer output in harmless state (a0 mode 2) */
-#define   INIT_A0_BITS	0x14
-/* put hardware conversion counter output in harmless state (a1 mode 0) */
-#define   INIT_A1_BITS	0x70
-#define COUNTER_B_BASE_REG	0x18
+/*
+ * Register map (all registers are 8-bit)
+ */
+#define STAT1_REG		0x00	/* R: Status 1 reg */
+#define STAT1_DAVAIL		(1 << 0)
+#define STAT1_OVERRUN		(1 << 1)
+#define STAT1_OVERFLOW		(1 << 2)
+#define STAT1_CNTINT		(1 << 3)
+#define STAT1_GATA0		(1 << 5)
+#define STAT1_EXTGATA0		(1 << 6)
+#define CMD1_REG		0x00	/* W: Command 1 reg */
+#define CMD1_MA(x)		(((x) & 0x7) << 0)
+#define CMD1_TWOSCMP		(1 << 3)
+#define CMD1_GAIN_MASK		(7 << 4)
+#define CMD1_SCANEN		(1 << 7)
+#define CMD2_REG		0x01	/* W: Command 2 reg */
+#define CMD2_PRETRIG		(1 << 0)
+#define CMD2_HWTRIG		(1 << 1)
+#define CMD2_SWTRIG		(1 << 2)
+#define CMD2_TBSEL		(1 << 3)
+#define CMD2_2SDAC0		(1 << 4)
+#define CMD2_2SDAC1		(1 << 5)
+#define CMD2_LDAC(x)		(1 << (6 + (x)))
+#define CMD3_REG		0x02	/* W: Command 3 reg */
+#define CMD3_DMAEN		(1 << 0)
+#define CMD3_DIOINTEN		(1 << 1)
+#define CMD3_DMATCINTEN		(1 << 2)
+#define CMD3_CNTINTEN		(1 << 3)
+#define CMD3_ERRINTEN		(1 << 4)
+#define CMD3_FIFOINTEN		(1 << 5)
+#define ADC_START_CONVERT_REG	0x03	/* W: Start Convert reg */
+#define DAC_LSB_REG(x)		(0x04 + 2 * (x)) /* W: DAC0/1 LSB reg */
+#define DAC_MSB_REG(x)		(0x05 + 2 * (x)) /* W: DAC0/1 MSB reg */
+#define ADC_FIFO_CLEAR_REG	0x08	/* W: A/D FIFO Clear reg */
+#define ADC_FIFO_REG		0x0a	/* R: A/D FIFO reg */
+#define DMATC_CLEAR_REG		0x0a	/* W: DMA Interrupt Clear reg */
+#define TIMER_CLEAR_REG		0x0c	/* W: Timer Interrupt Clear reg */
+#define CMD6_REG		0x0e	/* W: Command 6 reg */
+#define CMD6_NRSE		(1 << 0)
+#define CMD6_ADCUNI		(1 << 1)
+#define CMD6_DACUNI(x)		(1 << (2 + (x)))
+#define CMD6_HFINTEN		(1 << 5)
+#define CMD6_DQINTEN		(1 << 6)
+#define CMD6_SCANUP		(1 << 7)
+#define CMD4_REG		0x0f	/* W: Command 3 reg */
+#define CMD4_INTSCAN		(1 << 0)
+#define CMD4_EOIRCV		(1 << 1)
+#define CMD4_ECLKDRV		(1 << 2)
+#define CMD4_SEDIFF		(1 << 3)
+#define CMD4_ECLKRCV		(1 << 4)
+#define DIO_BASE_REG		0x10	/* R/W: 8255 DIO base reg */
+#define COUNTER_A_BASE_REG	0x14	/* R/W: 8253 Counter A base reg */
+#define COUNTER_A_MODE_REG	0x17	/* W: 8253 Counter A mode reg */
+#define INIT_A0_BITS		0x14	/*	(a0 mode 2) */
+#define INIT_A1_BITS		0x70	/*	(a1 mode 0) */
+#define COUNTER_B_BASE_REG	0x18	/* R/W: 8253 Counter B base reg */
+#define CMD5_REG		0x1c	/* W: Command 5 reg */
+#define CMD5_WRTPRT		(1 << 2)
+#define CMD5_DITHEREN		(1 << 3)
+#define CMD5_CALDACLD		(1 << 4)
+#define CMD5_SCLK		(1 << 5)
+#define CMD5_SDATA		(1 << 6)
+#define CMD5_EEPROMCS		(1 << 7)
+#define STAT2_REG		0x1d	/* R: Status 2 reg */
+#define STAT2_PROMOUT		(1 << 0)
+#define STAT2_OUTA1		(1 << 1)
+#define STAT2_FIFONHF		(1 << 2)
+#define INTERVAL_COUNT_REG	0x1e	/* W: Interval Counter Data reg */
+#define INTERVAL_STROBE_REG	0x1f	/* W: Interval Counter Strobe reg */
 
 #define LABPC_ADC_TIMEOUT	1000
 
@@ -355,12 +313,12 @@ static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->cmd2 &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
-	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
+	devpriv->cmd2 &= ~(CMD2_SWTRIG | CMD2_HWTRIG | CMD2_PRETRIG);
+	devpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	devpriv->cmd3 = 0;
-	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
+	devpriv->write_byte(devpriv->cmd3, dev->iobase + CMD3_REG);
 
 	return 0;
 }
@@ -378,10 +336,10 @@ static void labpc_ai_set_chan_and_gain(struct comedi_device *dev,
 	if ((mode == MODE_SINGLE_CHAN || mode == MODE_SINGLE_CHAN_INTERVAL) &&
 	    aref == AREF_DIFF)
 		chan *= 2;
-	devpriv->cmd1 = ADC_CHAN_BITS(chan);
+	devpriv->cmd1 = CMD1_MA(chan);
 	devpriv->cmd1 |= board->ai_range_code[range];
 
-	devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
+	devpriv->write_byte(devpriv->cmd1, dev->iobase + CMD1_REG);
 }
 
 static void labpc_setup_cmd6_reg(struct comedi_device *dev,
@@ -400,35 +358,35 @@ static void labpc_setup_cmd6_reg(struct comedi_device *dev,
 
 	/* reference inputs to ground or common? */
 	if (aref != AREF_GROUND)
-		devpriv->cmd6 |= ADC_COMMON_BIT;
+		devpriv->cmd6 |= CMD6_NRSE;
 	else
-		devpriv->cmd6 &= ~ADC_COMMON_BIT;
+		devpriv->cmd6 &= ~CMD6_NRSE;
 
 	/* bipolar or unipolar range? */
 	if (labpc_range_is_unipolar(s, range))
-		devpriv->cmd6 |= ADC_UNIP_BIT;
+		devpriv->cmd6 |= CMD6_ADCUNI;
 	else
-		devpriv->cmd6 &= ~ADC_UNIP_BIT;
+		devpriv->cmd6 &= ~CMD6_ADCUNI;
 
 	/*  interrupt on fifo half full? */
 	if (xfer == fifo_half_full_transfer)
-		devpriv->cmd6 |= ADC_FHF_INTR_EN_BIT;
+		devpriv->cmd6 |= CMD6_HFINTEN;
 	else
-		devpriv->cmd6 &= ~ADC_FHF_INTR_EN_BIT;
+		devpriv->cmd6 &= ~CMD6_HFINTEN;
 
 	/* enable interrupt on counter a1 terminal count? */
 	if (ena_intr)
-		devpriv->cmd6 |= A1_INTR_EN_BIT;
+		devpriv->cmd6 |= CMD6_DQINTEN;
 	else
-		devpriv->cmd6 &= ~A1_INTR_EN_BIT;
+		devpriv->cmd6 &= ~CMD6_DQINTEN;
 
 	/* are we scanning up or down through channels? */
 	if (mode == MODE_MULT_CHAN_UP)
-		devpriv->cmd6 |= ADC_SCAN_UP_BIT;
+		devpriv->cmd6 |= CMD6_SCANUP;
 	else
-		devpriv->cmd6 &= ~ADC_SCAN_UP_BIT;
+		devpriv->cmd6 &= ~CMD6_SCANUP;
 
-	devpriv->write_byte(devpriv->cmd6, dev->iobase + COMMAND6_REG);
+	devpriv->write_byte(devpriv->cmd6, dev->iobase + CMD6_REG);
 }
 
 static unsigned int labpc_read_adc_fifo(struct comedi_device *dev)
@@ -444,7 +402,7 @@ static void labpc_clear_adc_fifo(struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
 
-	devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
+	devpriv->write_byte(0x1, dev->iobase + ADC_FIFO_CLEAR_REG);
 	labpc_read_adc_fifo(dev);
 }
 
@@ -455,8 +413,8 @@ static int labpc_ai_wait_for_data(struct comedi_device *dev,
 	int i;
 
 	for (i = 0; i < timeout; i++) {
-		devpriv->stat1 = devpriv->read_byte(dev->iobase + STATUS1_REG);
-		if (devpriv->stat1 & DATA_AVAIL_BIT)
+		devpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);
+		if (devpriv->stat1 & STAT1_DAVAIL)
 			return 0;
 		udelay(1);
 	}
@@ -485,23 +443,23 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 
 	/* setup cmd4 register */
 	devpriv->cmd4 = 0;
-	devpriv->cmd4 |= EXT_CONVERT_DISABLE_BIT;
+	devpriv->cmd4 |= CMD4_ECLKRCV;
 	/* single-ended/differential */
 	if (aref == AREF_DIFF)
-		devpriv->cmd4 |= ADC_DIFF_BIT;
-	devpriv->write_byte(devpriv->cmd4, dev->iobase + COMMAND4_REG);
+		devpriv->cmd4 |= CMD4_SEDIFF;
+	devpriv->write_byte(devpriv->cmd4, dev->iobase + CMD4_REG);
 
 	/*
 	 * initialize pacer counter output to make sure it doesn't
 	 * cause any problems
 	 */
-	devpriv->write_byte(INIT_A0_BITS, dev->iobase + COUNTER_A_CONTROL_REG);
+	devpriv->write_byte(INIT_A0_BITS, dev->iobase + COUNTER_A_MODE_REG);
 
 	labpc_clear_adc_fifo(dev);
 
 	for (i = 0; i < insn->n; i++) {
 		/* trigger conversion */
-		devpriv->write_byte(0x1, dev->iobase + ADC_CONVERT_REG);
+		devpriv->write_byte(0x1, dev->iobase + ADC_START_CONVERT_REG);
 
 		ret = labpc_ai_wait_for_data(dev, LABPC_ADC_TIMEOUT);
 		if (ret)
@@ -946,7 +904,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				 * with no count to set its output low
 				 */
 		devpriv->write_byte(INIT_A1_BITS,
-				    dev->iobase + COUNTER_A_CONTROL_REG);
+				    dev->iobase + COUNTER_A_MODE_REG);
 
 #ifdef CONFIG_ISA_DMA_API
 	/*  figure out what method we will use to transfer data */
@@ -979,19 +937,18 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* manual says to set scan enable bit on second pass */
 	if (mode == MODE_MULT_CHAN_UP || mode == MODE_MULT_CHAN_DOWN) {
-		devpriv->cmd1 |= ADC_SCAN_EN_BIT;
+		devpriv->cmd1 |= CMD1_SCANEN;
 		/* need a brief delay before enabling scan, or scan
 		 * list will get screwed when you switch
 		 * between scan up to scan down mode - dunno why */
 		udelay(1);
-		devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
+		devpriv->write_byte(devpriv->cmd1, dev->iobase + CMD1_REG);
 	}
 
 	devpriv->write_byte(cmd->chanlist_len,
 			    dev->iobase + INTERVAL_COUNT_REG);
 	/*  load count */
-	devpriv->write_byte(INTERVAL_LOAD_BITS,
-			    dev->iobase + INTERVAL_LOAD_REG);
+	devpriv->write_byte(0x1, dev->iobase + INTERVAL_STROBE_REG);
 
 	if (cmd->convert_src == TRIG_TIMER ||
 	    cmd->scan_begin_src == TRIG_TIMER) {
@@ -1016,7 +973,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		}
 	} else
 		devpriv->write_byte(INIT_A0_BITS,
-				    dev->iobase + COUNTER_A_CONTROL_REG);
+				    dev->iobase + COUNTER_A_MODE_REG);
 
 	/*  set up scan pacing */
 	if (labpc_ai_scan_period(cmd, mode)) {
@@ -1054,50 +1011,50 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		enable_dma(devpriv->dma_chan);
 		release_dma_lock(irq_flags);
 		/*  enable board's dma */
-		devpriv->cmd3 |= DMA_EN_BIT | DMATC_INTR_EN_BIT;
+		devpriv->cmd3 |= (CMD3_DMAEN | CMD3_DMATCINTEN);
 	} else
-		devpriv->cmd3 &= ~DMA_EN_BIT & ~DMATC_INTR_EN_BIT;
+		devpriv->cmd3 &= ~(CMD3_DMAEN | CMD3_DMATCINTEN);
 #endif
 
 	/*  enable error interrupts */
-	devpriv->cmd3 |= ERR_INTR_EN_BIT;
+	devpriv->cmd3 |= CMD3_ERRINTEN;
 	/*  enable fifo not empty interrupt? */
 	if (xfer == fifo_not_empty_transfer)
-		devpriv->cmd3 |= ADC_FNE_INTR_EN_BIT;
+		devpriv->cmd3 |= CMD3_FIFOINTEN;
 	else
-		devpriv->cmd3 &= ~ADC_FNE_INTR_EN_BIT;
-	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
+		devpriv->cmd3 &= ~CMD3_FIFOINTEN;
+	devpriv->write_byte(devpriv->cmd3, dev->iobase + CMD3_REG);
 
 	/*  setup any external triggering/pacing (cmd4 register) */
 	devpriv->cmd4 = 0;
 	if (cmd->convert_src != TRIG_EXT)
-		devpriv->cmd4 |= EXT_CONVERT_DISABLE_BIT;
+		devpriv->cmd4 |= CMD4_ECLKRCV;
 	/* XXX should discard first scan when using interval scanning
 	 * since manual says it is not synced with scan clock */
 	if (labpc_use_continuous_mode(cmd, mode) == 0) {
-		devpriv->cmd4 |= INTERVAL_SCAN_EN_BIT;
+		devpriv->cmd4 |= CMD4_INTSCAN;
 		if (cmd->scan_begin_src == TRIG_EXT)
-			devpriv->cmd4 |= EXT_SCAN_EN_BIT;
+			devpriv->cmd4 |= CMD4_EOIRCV;
 	}
 	/*  single-ended/differential */
 	if (aref == AREF_DIFF)
-		devpriv->cmd4 |= ADC_DIFF_BIT;
-	devpriv->write_byte(devpriv->cmd4, dev->iobase + COMMAND4_REG);
+		devpriv->cmd4 |= CMD4_SEDIFF;
+	devpriv->write_byte(devpriv->cmd4, dev->iobase + CMD4_REG);
 
 	/*  startup acquisition */
 
 	/*  cmd2 reg */
 	/*  use 2 cascaded counters for pacing */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->cmd2 |= CASCADE_BIT;
+	devpriv->cmd2 |= CMD2_TBSEL;
 	switch (cmd->start_src) {
 	case TRIG_EXT:
-		devpriv->cmd2 |= HWTRIG_BIT;
-		devpriv->cmd2 &= ~PRETRIG_BIT & ~SWTRIG_BIT;
+		devpriv->cmd2 |= CMD2_HWTRIG;
+		devpriv->cmd2 &= ~(CMD2_PRETRIG | CMD2_SWTRIG);
 		break;
 	case TRIG_NOW:
-		devpriv->cmd2 |= SWTRIG_BIT;
-		devpriv->cmd2 &= ~PRETRIG_BIT & ~HWTRIG_BIT;
+		devpriv->cmd2 |= CMD2_SWTRIG;
+		devpriv->cmd2 &= ~(CMD2_PRETRIG | CMD2_HWTRIG);
 		break;
 	default:
 		comedi_error(dev, "bug with start_src");
@@ -1107,7 +1064,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	switch (cmd->stop_src) {
 	case TRIG_EXT:
-		devpriv->cmd2 |= HWTRIG_BIT | PRETRIG_BIT;
+		devpriv->cmd2 |= (CMD2_HWTRIG | CMD2_PRETRIG);
 		break;
 	case TRIG_COUNT:
 	case TRIG_NONE:
@@ -1117,7 +1074,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		return -1;
 	}
-	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
+	devpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return 0;
@@ -1200,9 +1157,9 @@ static int labpc_drain_fifo(struct comedi_device *dev)
 	const int timeout = 10000;
 	unsigned int i;
 
-	devpriv->stat1 = devpriv->read_byte(dev->iobase + STATUS1_REG);
+	devpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);
 
-	for (i = 0; (devpriv->stat1 & DATA_AVAIL_BIT) && i < timeout;
+	for (i = 0; (devpriv->stat1 & STAT1_DAVAIL) && i < timeout;
 	     i++) {
 		/*  quit if we have all the data we want */
 		if (async->cmd.stop_src == TRIG_COUNT) {
@@ -1212,7 +1169,7 @@ static int labpc_drain_fifo(struct comedi_device *dev)
 		}
 		data = labpc_read_adc_fifo(dev);
 		cfc_write_to_buffer(dev->read_subdev, data);
-		devpriv->stat1 = devpriv->read_byte(dev->iobase + STATUS1_REG);
+		devpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);
 	}
 	if (i == timeout) {
 		comedi_error(dev, "ai timeout, fifo never empties");
@@ -1257,20 +1214,20 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	async->events = 0;
 
 	/* read board status */
-	devpriv->stat1 = devpriv->read_byte(dev->iobase + STATUS1_REG);
+	devpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);
 	if (board->register_layout == labpc_1200_layout)
-		devpriv->stat2 = devpriv->read_byte(dev->iobase + STATUS2_REG);
+		devpriv->stat2 = devpriv->read_byte(dev->iobase + STAT2_REG);
 
-	if ((devpriv->stat1 & (DMATC_BIT | TIMER_BIT | OVERFLOW_BIT |
-			       OVERRUN_BIT | DATA_AVAIL_BIT)) == 0
-	    && (devpriv->stat2 & A1_TC_BIT) == 0
-	    && (devpriv->stat2 & FNHF_BIT)) {
+	if ((devpriv->stat1 & (STAT1_GATA0 | STAT1_CNTINT | STAT1_OVERFLOW |
+			       STAT1_OVERRUN | STAT1_DAVAIL)) == 0
+	    && (devpriv->stat2 & STAT2_OUTA1) == 0
+	    && (devpriv->stat2 & STAT2_FIFONHF)) {
 		return IRQ_NONE;
 	}
 
-	if (devpriv->stat1 & OVERRUN_BIT) {
+	if (devpriv->stat1 & STAT1_OVERRUN) {
 		/* clear error interrupt */
-		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
+		devpriv->write_byte(0x1, dev->iobase + ADC_FIFO_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		comedi_event(dev, s);
 		comedi_error(dev, "overrun");
@@ -1283,24 +1240,24 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 		 * if a dma terminal count of external stop trigger
 		 * has occurred
 		 */
-		if (devpriv->stat1 & DMATC_BIT ||
+		if (devpriv->stat1 & STAT1_GATA0 ||
 		    (board->register_layout == labpc_1200_layout
-		     && devpriv->stat2 & A1_TC_BIT)) {
+		     && devpriv->stat2 & STAT2_OUTA1)) {
 			handle_isa_dma(dev);
 		}
 	} else
 #endif
 		labpc_drain_fifo(dev);
 
-	if (devpriv->stat1 & TIMER_BIT) {
+	if (devpriv->stat1 & STAT1_CNTINT) {
 		comedi_error(dev, "handled timer interrupt?");
 		/*  clear it */
 		devpriv->write_byte(0x1, dev->iobase + TIMER_CLEAR_REG);
 	}
 
-	if (devpriv->stat1 & OVERFLOW_BIT) {
+	if (devpriv->stat1 & STAT1_OVERFLOW) {
 		/*  clear error interrupt */
-		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
+		devpriv->write_byte(0x1, dev->iobase + ADC_FIFO_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		comedi_event(dev, s);
 		comedi_error(dev, "overflow");
@@ -1308,7 +1265,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	}
 	/*  handle external stop trigger */
 	if (cmd->stop_src == TRIG_EXT) {
-		if (devpriv->stat2 & A1_TC_BIT) {
+		if (devpriv->stat2 & STAT2_OUTA1) {
 			labpc_drain_dregs(dev);
 			labpc_cancel(dev, s);
 			async->events |= COMEDI_CB_EOA;
@@ -1344,19 +1301,19 @@ static int labpc_ao_insn_write(struct comedi_device *dev,
 	/* note: hardware bug in daqcard-1200 means pacing cannot
 	 * be independently enabled/disabled for its the two channels */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->cmd2 &= ~DAC_PACED_BIT(channel);
-	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
+	devpriv->cmd2 &= ~CMD2_LDAC(channel);
+	devpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* set range */
 	if (board->register_layout == labpc_1200_layout) {
 		range = CR_RANGE(insn->chanspec);
 		if (labpc_range_is_unipolar(s, range))
-			devpriv->cmd6 |= DAC_UNIP_BIT(channel);
+			devpriv->cmd6 |= CMD6_DACUNI(channel);
 		else
-			devpriv->cmd6 &= ~DAC_UNIP_BIT(channel);
+			devpriv->cmd6 &= ~CMD6_DACUNI(channel);
 		/*  write to register */
-		devpriv->write_byte(devpriv->cmd6, dev->iobase + COMMAND6_REG);
+		devpriv->write_byte(devpriv->cmd6, dev->iobase + CMD6_REG);
 	}
 	/* send data */
 	lsb = data[0] & 0xff;
@@ -1401,19 +1358,18 @@ static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
 
 	for (i = 1; i <= value_width; i++) {
 		/*  clear serial clock */
-		devpriv->cmd5 &= ~SCLOCK_BIT;
+		devpriv->cmd5 &= ~CMD5_SCLK;
 		/*  send bits most significant bit first */
 		if (value & (1 << (value_width - i)))
-			devpriv->cmd5 |= SDATA_BIT;
+			devpriv->cmd5 |= CMD5_SDATA;
 		else
-			devpriv->cmd5 &= ~SDATA_BIT;
+			devpriv->cmd5 &= ~CMD5_SDATA;
 		udelay(1);
-		devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+		devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 		/*  set clock to load bit */
-		devpriv->cmd5 |= SCLOCK_BIT;
+		devpriv->cmd5 |= CMD5_SCLK;
 		udelay(1);
-		devpriv->write_byte(devpriv->cmd5,
-				    dev->iobase + COMMAND5_REG);
+		devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 	}
 }
 
@@ -1427,17 +1383,17 @@ static unsigned int labpc_serial_in(struct comedi_device *dev)
 
 	for (i = 1; i <= value_width; i++) {
 		/*  set serial clock */
-		devpriv->cmd5 |= SCLOCK_BIT;
+		devpriv->cmd5 |= CMD5_SCLK;
 		udelay(1);
-		devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+		devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 		/*  clear clock bit */
-		devpriv->cmd5 &= ~SCLOCK_BIT;
+		devpriv->cmd5 &= ~CMD5_SCLK;
 		udelay(1);
-		devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+		devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 		/*  read bits most significant bit first */
 		udelay(1);
-		devpriv->stat2 = devpriv->read_byte(dev->iobase + STATUS2_REG);
-		if (devpriv->stat2 & EEPROM_OUT_BIT)
+		devpriv->stat2 = devpriv->read_byte(dev->iobase + STAT2_REG);
+		if (devpriv->stat2 & STAT2_PROMOUT)
 			value |= 1 << (value_width - i);
 	}
 
@@ -1455,12 +1411,12 @@ static unsigned int labpc_eeprom_read(struct comedi_device *dev,
 	const int write_length = 8;
 
 	/*  enable read/write to eeprom */
-	devpriv->cmd5 &= ~EEPROM_EN_BIT;
+	devpriv->cmd5 &= ~CMD5_EEPROMCS;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
-	devpriv->cmd5 |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 
 	/*  send read instruction */
 	labpc_serial_out(dev, read_instruction, write_length);
@@ -1470,9 +1426,9 @@ static unsigned int labpc_eeprom_read(struct comedi_device *dev,
 	value = labpc_serial_in(dev);
 
 	/*  disable read/write to eeprom */
-	devpriv->cmd5 &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	devpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 
 	return value;
 }
@@ -1485,12 +1441,12 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
 	const int write_length = 8;	/*  8 bit write lengths to eeprom */
 
 	/*  enable read/write to eeprom */
-	devpriv->cmd5 &= ~EEPROM_EN_BIT;
+	devpriv->cmd5 &= ~CMD5_EEPROMCS;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
-	devpriv->cmd5 |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 
 	/*  send read status instruction */
 	labpc_serial_out(dev, read_status_instruction, write_length);
@@ -1498,9 +1454,9 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
 	value = labpc_serial_in(dev);
 
 	/*  disable read/write to eeprom */
-	devpriv->cmd5 &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	devpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 
 	return value;
 }
@@ -1530,36 +1486,36 @@ static int labpc_eeprom_write(struct comedi_device *dev,
 	devpriv->eeprom_data[address] = value;
 
 	/*  enable read/write to eeprom */
-	devpriv->cmd5 &= ~EEPROM_EN_BIT;
+	devpriv->cmd5 &= ~CMD5_EEPROMCS;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
-	devpriv->cmd5 |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 
 	/*  send write_enable instruction */
 	labpc_serial_out(dev, write_enable_instruction, write_length);
-	devpriv->cmd5 &= ~EEPROM_EN_BIT;
+	devpriv->cmd5 &= ~CMD5_EEPROMCS;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 
 	/*  send write instruction */
-	devpriv->cmd5 |= EEPROM_EN_BIT;
+	devpriv->cmd5 |= CMD5_EEPROMCS;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 	labpc_serial_out(dev, write_instruction, write_length);
 	/*  send 8 bit address to write to */
 	labpc_serial_out(dev, address, write_length);
 	/*  write value */
 	labpc_serial_out(dev, value, write_length);
-	devpriv->cmd5 &= ~EEPROM_EN_BIT;
+	devpriv->cmd5 &= ~CMD5_EEPROMCS;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 
 	/*  disable read/write to eeprom */
-	devpriv->cmd5 &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	devpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 
 	return 0;
 }
@@ -1575,10 +1531,9 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	devpriv->caldac[channel] = value;
 
 	/*  clear caldac load bit and make sure we don't write to eeprom */
-	devpriv->cmd5 &=
-	    ~CALDAC_LOAD_BIT & ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	devpriv->cmd5 &= ~(CMD5_CALDACLD | CMD5_EEPROMCS | CMD5_WRTPRT);
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 
 	/*  write 4 bit channel */
 	labpc_serial_out(dev, channel, 4);
@@ -1586,12 +1541,12 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	labpc_serial_out(dev, value, 8);
 
 	/*  set and clear caldac bit to load caldac value */
-	devpriv->cmd5 |= CALDAC_LOAD_BIT;
+	devpriv->cmd5 |= CMD5_CALDACLD;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
-	devpriv->cmd5 &= ~CALDAC_LOAD_BIT;
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+	devpriv->cmd5 &= ~CMD5_CALDACLD;
 	udelay(1);
-	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
 }
 
 static int labpc_calib_insn_write(struct comedi_device *dev,
@@ -1686,13 +1641,13 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		devpriv->write_byte = labpc_outb;
 	}
 	/* initialize board's command registers */
-	devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
-	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
-	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
-	devpriv->write_byte(devpriv->cmd4, dev->iobase + COMMAND4_REG);
+	devpriv->write_byte(devpriv->cmd1, dev->iobase + CMD1_REG);
+	devpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);
+	devpriv->write_byte(devpriv->cmd3, dev->iobase + CMD3_REG);
+	devpriv->write_byte(devpriv->cmd4, dev->iobase + CMD4_REG);
 	if (board->register_layout == labpc_1200_layout) {
-		devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
-		devpriv->write_byte(devpriv->cmd6, dev->iobase + COMMAND6_REG);
+		devpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);
+		devpriv->write_byte(devpriv->cmd6, dev->iobase + CMD6_REG);
 	}
 
 	/* grab our IRQ */

commit 31922394179b5ddaaa4184642186285a519702a4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:51:23 2013 -0700

    staging: comedi: ni_labpc: clean up multi-line comments
    
    Clean up the multi-line comments at the beginning of the file
    so that they follow the CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index c967bc9fb87b..94e25e761a28 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1,77 +1,70 @@
 /*
-    comedi/drivers/ni_labpc.c
-    Driver for National Instruments Lab-PC series boards and compatibles
-    Copyright (C) 2001, 2002, 2003 Frank Mori Hess <fmhess@users.sourceforge.net>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-************************************************************************
-*/
-/*
-Driver: ni_labpc
-Description: National Instruments Lab-PC (& compatibles)
-Author: Frank Mori Hess <fmhess@users.sourceforge.net>
-Devices: [National Instruments] Lab-PC-1200 (labpc-1200),
-  Lab-PC-1200AI (labpc-1200ai), Lab-PC+ (lab-pc+), PCI-1200 (ni_labpc)
-Status: works
-
-Tested with lab-pc-1200.  For the older Lab-PC+, not all input ranges
-and analog references will work, the available ranges/arefs will
-depend on how you have configured the jumpers on your board
-(see your owner's manual).
-
-Kernel-level ISA plug-and-play support for the lab-pc-1200
-boards has not
-yet been added to the driver, mainly due to the fact that
-I don't know the device id numbers.  If you have one
-of these boards,
-please file a bug report at http://comedi.org/ 
-so I can get the necessary information from you.
-
-The 1200 series boards have onboard calibration dacs for correcting
-analog input/output offsets and gains.  The proper settings for these
-caldacs are stored on the board's eeprom.  To read the caldac values
-from the eeprom and store them into a file that can be then be used by
-comedilib, use the comedi_calibrate program.
-
-Configuration options - ISA boards:
-  [0] - I/O port base address
-  [1] - IRQ (optional, required for timed or externally triggered conversions)
-  [2] - DMA channel (optional)
-
-Configuration options - PCI boards:
-  [0] - bus (optional)
-  [1] - slot (optional)
-
-The Lab-pc+ has quirky chanlist requirements
-when scanning multiple channels.  Multiple channel scan
-sequence must start at highest channel, then decrement down to
-channel 0.  The rest of the cards can scan down like lab-pc+ or scan
-up from channel zero.  Chanlists consisting of all one channel
-are also legal, and allow you to pace conversions in bursts.
-
-*/
+ * comedi/drivers/ni_labpc.c
+ * Driver for National Instruments Lab-PC series boards and compatibles
+ * Copyright (C) 2001-2003 Frank Mori Hess <fmhess@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 /*
-
-NI manuals:
-341309a (labpc-1200 register manual)
-340914a (pci-1200)
-320502b (lab-pc+)
-
-*/
+ * Driver: ni_labpc
+ * Description: National Instruments Lab-PC (& compatibles)
+ * Devices: (National Instruments) Lab-PC-1200 [lab-pc-1200]
+ *	    (National Instruments) Lab-PC-1200AI [lab-pc-1200ai]
+ *	    (National Instruments) Lab-PC+ [lab-pc+]
+ *	    (National Instruments) PCI-1200 [pci-1200]
+ * Author: Frank Mori Hess <fmhess@users.sourceforge.net>
+ * Status: works
+ *
+ * Configuration options - ISA boards:
+ *   [0] - I/O port base address
+ *   [1] - IRQ (optional, required for timed or externally triggered
+ *		conversions)
+ *   [2] - DMA channel (optional)
+ *
+ * Configuration options - PCI boards:
+ *    not applicable, uses PCI auto config
+ *
+ * Tested with lab-pc-1200.  For the older Lab-PC+, not all input
+ * ranges and analog references will work, the available ranges/arefs
+ * will depend on how you have configured the jumpers on your board
+ * (see your owner's manual).
+ *
+ * Kernel-level ISA plug-and-play support for the lab-pc-1200 boards
+ * has not yet been added to the driver, mainly due to the fact that
+ * I don't know the device id numbers. If you have one of these boards,
+ * please file a bug report at http://comedi.org/ so I can get the
+ * necessary information from you.
+ *
+ * The 1200 series boards have onboard calibration dacs for correcting
+ * analog input/output offsets and gains. The proper settings for these
+ * caldacs are stored on the board's eeprom. To read the caldac values
+ * from the eeprom and store them into a file that can be then be used
+ * by comedilib, use the comedi_calibrate program.
+ *
+ * The Lab-pc+ has quirky chanlist requirements when scanning multiple
+ * channels. Multiple channel scan sequence must start at highest channel,
+ * then decrement down to channel 0. The rest of the cards can scan down
+ * like lab-pc+ or scan up from channel zero. Chanlists consisting of all
+ * one channel are also legal, and allow you to pace conversions in bursts.
+ *
+ * NI manuals:
+ * 341309a (labpc-1200 register manual)
+ * 340914a (pci-1200)
+ * 320502b (lab-pc+)
+ */
 
 #include <linux/pci.h>
 #include <linux/interrupt.h>

commit d5c8d9c411f2a95d42c90dcdee754447a505d4d7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:50:56 2013 -0700

    staging: comedi: ni_labpc: fix a > 80 char line issue
    
    Fix a checkpatch.pl warning about a line over 80 characters.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index ceb6e786cbdd..c967bc9fb87b 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1000,7 +1000,8 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->write_byte(INTERVAL_LOAD_BITS,
 			    dev->iobase + INTERVAL_LOAD_REG);
 
-	if (cmd->convert_src == TRIG_TIMER || cmd->scan_begin_src == TRIG_TIMER) {
+	if (cmd->convert_src == TRIG_TIMER ||
+	    cmd->scan_begin_src == TRIG_TIMER) {
 		/*  set up pacing */
 		labpc_adc_timing(dev, cmd, mode);
 		/*  load counter b0 in mode 3 */

commit 810c73c7e7d3892fb508e28ca774d69309c316a2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:50:31 2013 -0700

    staging: comedi: ni_labpc: introduce labpc_ai_wait_for_data()
    
    Introduce a helper function to wait for the a/d conversion to
    complete.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 9e47fc0322f4..ceb6e786cbdd 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -206,6 +206,8 @@ NI manuals:
 #define   INIT_A1_BITS	0x70
 #define COUNTER_B_BASE_REG	0x18
 
+#define LABPC_ADC_TIMEOUT	1000
+
 enum scan_mode {
 	MODE_SINGLE_CHAN,
 	MODE_SINGLE_CHAN_INTERVAL,
@@ -453,6 +455,21 @@ static void labpc_clear_adc_fifo(struct comedi_device *dev)
 	labpc_read_adc_fifo(dev);
 }
 
+static int labpc_ai_wait_for_data(struct comedi_device *dev,
+				  int timeout)
+{
+	struct labpc_private *devpriv = dev->private;
+	int i;
+
+	for (i = 0; i < timeout; i++) {
+		devpriv->stat1 = devpriv->read_byte(dev->iobase + STATUS1_REG);
+		if (devpriv->stat1 & DATA_AVAIL_BIT)
+			return 0;
+		udelay(1);
+	}
+	return -ETIME;
+}
+
 static int labpc_ai_insn_read(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn,
@@ -462,8 +479,8 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
 	unsigned int aref = CR_AREF(insn->chanspec);
-	int timeout = 1000;
-	int i, n;
+	int ret;
+	int i;
 
 	/* disable timed conversions, interrupt generation and dma */
 	labpc_cancel(dev, s);
@@ -489,24 +506,18 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 
 	labpc_clear_adc_fifo(dev);
 
-	for (n = 0; n < insn->n; n++) {
+	for (i = 0; i < insn->n; i++) {
 		/* trigger conversion */
 		devpriv->write_byte(0x1, dev->iobase + ADC_CONVERT_REG);
 
-		for (i = 0; i < timeout; i++) {
-			if (devpriv->read_byte(dev->iobase +
-					       STATUS1_REG) & DATA_AVAIL_BIT)
-				break;
-			udelay(1);
-		}
-		if (i == timeout) {
-			comedi_error(dev, "timeout");
-			return -ETIME;
-		}
-		data[n] = labpc_read_adc_fifo(dev);
+		ret = labpc_ai_wait_for_data(dev, LABPC_ADC_TIMEOUT);
+		if (ret)
+			return ret;
+
+		data[i] = labpc_read_adc_fifo(dev);
 	}
 
-	return n;
+	return insn->n;
 }
 
 #ifdef CONFIG_ISA_DMA_API

commit 3c4dfac8f7d2504234d1b7e3108e401a882bb9e1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:50:03 2013 -0700

    staging: comedi: ni_labpc: introduce labpc_read_adc_fifo()
    
    Introduce a helper function to read the a/d conversion result
    from the fifo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 7f24450930c6..9e47fc0322f4 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -436,13 +436,21 @@ static void labpc_setup_cmd6_reg(struct comedi_device *dev,
 	devpriv->write_byte(devpriv->cmd6, dev->iobase + COMMAND6_REG);
 }
 
-static void labpc_clear_adc_fifo(const struct comedi_device *dev)
+static unsigned int labpc_read_adc_fifo(struct comedi_device *dev)
+{
+	struct labpc_private *devpriv = dev->private;
+	unsigned int lsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+	unsigned int msb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+
+	return (msb << 8) | lsb;
+}
+
+static void labpc_clear_adc_fifo(struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
 
 	devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
-	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
-	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+	labpc_read_adc_fifo(dev);
 }
 
 static int labpc_ai_insn_read(struct comedi_device *dev,
@@ -455,7 +463,6 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 	unsigned int range = CR_RANGE(insn->chanspec);
 	unsigned int aref = CR_AREF(insn->chanspec);
 	int timeout = 1000;
-	int lsb, msb;
 	int i, n;
 
 	/* disable timed conversions, interrupt generation and dma */
@@ -496,9 +503,7 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 			comedi_error(dev, "timeout");
 			return -ETIME;
 		}
-		lsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
-		msb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
-		data[n] = (msb << 8) | lsb;
+		data[n] = labpc_read_adc_fifo(dev);
 	}
 
 	return n;
@@ -1185,7 +1190,6 @@ static void handle_isa_dma(struct comedi_device *dev)
 static int labpc_drain_fifo(struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
-	unsigned int lsb, msb;
 	short data;
 	struct comedi_async *async = dev->read_subdev->async;
 	const int timeout = 10000;
@@ -1201,9 +1205,7 @@ static int labpc_drain_fifo(struct comedi_device *dev)
 				break;
 			devpriv->count--;
 		}
-		lsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
-		msb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
-		data = (msb << 8) | lsb;
+		data = labpc_read_adc_fifo(dev);
 		cfc_write_to_buffer(dev->read_subdev, data);
 		devpriv->stat1 = devpriv->read_byte(dev->iobase + STATUS1_REG);
 	}

commit 359553bb3b4d19207c5a7439eaae1b1ea186a859
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:49:34 2013 -0700

    staging: comedi: ni_labpc: introduce labpc_setup_cmd6_reg()
    
    Introduce a helper function to set the COMMAND6_REG.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 2b9bd61943af..7f24450930c6 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -389,6 +389,53 @@ static void labpc_ai_set_chan_and_gain(struct comedi_device *dev,
 	devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
 }
 
+static void labpc_setup_cmd6_reg(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 enum scan_mode mode,
+				 enum transfer_type xfer,
+				 unsigned int range,
+				 unsigned int aref,
+				 bool ena_intr)
+{
+	const struct labpc_boardinfo *board = comedi_board(dev);
+	struct labpc_private *devpriv = dev->private;
+
+	if (board->register_layout != labpc_1200_layout)
+		return;
+
+	/* reference inputs to ground or common? */
+	if (aref != AREF_GROUND)
+		devpriv->cmd6 |= ADC_COMMON_BIT;
+	else
+		devpriv->cmd6 &= ~ADC_COMMON_BIT;
+
+	/* bipolar or unipolar range? */
+	if (labpc_range_is_unipolar(s, range))
+		devpriv->cmd6 |= ADC_UNIP_BIT;
+	else
+		devpriv->cmd6 &= ~ADC_UNIP_BIT;
+
+	/*  interrupt on fifo half full? */
+	if (xfer == fifo_half_full_transfer)
+		devpriv->cmd6 |= ADC_FHF_INTR_EN_BIT;
+	else
+		devpriv->cmd6 &= ~ADC_FHF_INTR_EN_BIT;
+
+	/* enable interrupt on counter a1 terminal count? */
+	if (ena_intr)
+		devpriv->cmd6 |= A1_INTR_EN_BIT;
+	else
+		devpriv->cmd6 &= ~A1_INTR_EN_BIT;
+
+	/* are we scanning up or down through channels? */
+	if (mode == MODE_MULT_CHAN_UP)
+		devpriv->cmd6 |= ADC_SCAN_UP_BIT;
+	else
+		devpriv->cmd6 &= ~ADC_SCAN_UP_BIT;
+
+	devpriv->write_byte(devpriv->cmd6, dev->iobase + COMMAND6_REG);
+}
+
 static void labpc_clear_adc_fifo(const struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
@@ -403,7 +450,6 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 			      struct comedi_insn *insn,
 			      unsigned int *data)
 {
-	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
@@ -417,25 +463,9 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 
 	labpc_ai_set_chan_and_gain(dev, MODE_SINGLE_CHAN, chan, range, aref);
 
-	/* setup cmd6 register for 1200 boards */
-	if (board->register_layout == labpc_1200_layout) {
-		/*  reference inputs to ground or common? */
-		if (aref != AREF_GROUND)
-			devpriv->cmd6 |= ADC_COMMON_BIT;
-		else
-			devpriv->cmd6 &= ~ADC_COMMON_BIT;
-		/* bipolar or unipolar range? */
-		if (labpc_range_is_unipolar(s, range))
-			devpriv->cmd6 |= ADC_UNIP_BIT;
-		else
-			devpriv->cmd6 &= ~ADC_UNIP_BIT;
-		/* don't interrupt on fifo half full */
-		devpriv->cmd6 &= ~ADC_FHF_INTR_EN_BIT;
-		/* don't enable interrupt on counter a1 terminal count? */
-		devpriv->cmd6 &= ~A1_INTR_EN_BIT;
-		/* write to register */
-		devpriv->write_byte(devpriv->cmd6, dev->iobase + COMMAND6_REG);
-	}
+	labpc_setup_cmd6_reg(dev, s, MODE_SINGLE_CHAN, fifo_not_empty_transfer,
+			     range, aref, false);
+
 	/* setup cmd4 register */
 	devpriv->cmd4 = 0;
 	devpriv->cmd4 |= EXT_CONVERT_DISABLE_BIT;
@@ -933,39 +963,11 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		xfer = fifo_not_empty_transfer;
 	devpriv->current_transfer = xfer;
 
-	/*  setup cmd6 register for 1200 boards */
-	if (board->register_layout == labpc_1200_layout) {
-		/*  reference inputs to ground or common? */
-		if (aref != AREF_GROUND)
-			devpriv->cmd6 |= ADC_COMMON_BIT;
-		else
-			devpriv->cmd6 &= ~ADC_COMMON_BIT;
-		/*  bipolar or unipolar range? */
-		if (labpc_range_is_unipolar(s, range))
-			devpriv->cmd6 |= ADC_UNIP_BIT;
-		else
-			devpriv->cmd6 &= ~ADC_UNIP_BIT;
-		/*  interrupt on fifo half full? */
-		if (xfer == fifo_half_full_transfer)
-			devpriv->cmd6 |= ADC_FHF_INTR_EN_BIT;
-		else
-			devpriv->cmd6 &= ~ADC_FHF_INTR_EN_BIT;
-		/*  enable interrupt on counter a1 terminal count? */
-		if (cmd->stop_src == TRIG_EXT)
-			devpriv->cmd6 |= A1_INTR_EN_BIT;
-		else
-			devpriv->cmd6 &= ~A1_INTR_EN_BIT;
-		/*  are we scanning up or down through channels? */
-		if (mode == MODE_MULT_CHAN_UP)
-			devpriv->cmd6 |= ADC_SCAN_UP_BIT;
-		else
-			devpriv->cmd6 &= ~ADC_SCAN_UP_BIT;
-		/*  write to register */
-		devpriv->write_byte(devpriv->cmd6, dev->iobase + COMMAND6_REG);
-	}
-
 	labpc_ai_set_chan_and_gain(dev, mode, chan, range, aref);
 
+	labpc_setup_cmd6_reg(dev, s, mode, xfer, range, aref,
+			     (cmd->stop_src == TRIG_EXT));
+
 	/* manual says to set scan enable bit on second pass */
 	if (mode == MODE_MULT_CHAN_UP || mode == MODE_MULT_CHAN_DOWN) {
 		devpriv->cmd1 |= ADC_SCAN_EN_BIT;

commit 8a498667b613387ee270bc0b49a375294e38a4f6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:49:10 2013 -0700

    staging: comedi: ni_labpc:use labpc_cancel() to remove some common code
    
    The labpc_cancel() function can be used by the labpc_ai_insn_read() and
    labpc_ai_cmd() functions to disable the ai subdevice.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index dbc358970171..2b9bd61943af 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -354,6 +354,22 @@ static bool labpc_range_is_unipolar(struct comedi_subdevice *s,
 		return true;
 }
 
+static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+{
+	struct labpc_private *devpriv = dev->private;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->cmd2 &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
+	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	devpriv->cmd3 = 0;
+	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
+
+	return 0;
+}
+
 static void labpc_ai_set_chan_and_gain(struct comedi_device *dev,
 				       enum scan_mode mode,
 				       unsigned int chan,
@@ -393,19 +409,11 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 	unsigned int range = CR_RANGE(insn->chanspec);
 	unsigned int aref = CR_AREF(insn->chanspec);
 	int timeout = 1000;
-	unsigned long flags;
 	int lsb, msb;
 	int i, n;
 
-	/*  disable timed conversions */
-	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->cmd2 &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
-	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	/*  disable interrupt generation and dma */
-	devpriv->cmd3 = 0;
-	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
+	/* disable timed conversions, interrupt generation and dma */
+	labpc_cancel(dev, s);
 
 	labpc_ai_set_chan_and_gain(dev, MODE_SINGLE_CHAN, chan, range, aref);
 
@@ -876,13 +884,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int ret;
 
 	/* make sure board is disabled before setting up acquisition */
-	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->cmd2 &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
-	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	devpriv->cmd3 = 0;
-	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
+	labpc_cancel(dev, s);
 
 	/*  initialize software conversion count */
 	if (cmd->stop_src == TRIG_COUNT)
@@ -1109,22 +1111,6 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	struct labpc_private *devpriv = dev->private;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->cmd2 &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
-	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	devpriv->cmd3 = 0;
-	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
-
-	return 0;
-}
-
 #ifdef CONFIG_ISA_DMA_API
 static void labpc_drain_dma(struct comedi_device *dev)
 {

commit 8c2bc333af026bed05a0041b028c34ef9b5c9cab
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:48:44 2013 -0700

    staging: comedi: ni_labpc: introduce labpc_ai_set_chan_and_gain()
    
    Introduce a helper function to set the channel and gain bits in the
    COMMAND1_REG.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 0b68e13e2377..dbc358970171 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -354,6 +354,25 @@ static bool labpc_range_is_unipolar(struct comedi_subdevice *s,
 		return true;
 }
 
+static void labpc_ai_set_chan_and_gain(struct comedi_device *dev,
+				       enum scan_mode mode,
+				       unsigned int chan,
+				       unsigned int range,
+				       unsigned int aref)
+{
+	const struct labpc_boardinfo *board = comedi_board(dev);
+	struct labpc_private *devpriv = dev->private;
+
+	/* munge channel bits for differential/scan disabled mode */
+	if ((mode == MODE_SINGLE_CHAN || mode == MODE_SINGLE_CHAN_INTERVAL) &&
+	    aref == AREF_DIFF)
+		chan *= 2;
+	devpriv->cmd1 = ADC_CHAN_BITS(chan);
+	devpriv->cmd1 |= board->ai_range_code[range];
+
+	devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
+}
+
 static void labpc_clear_adc_fifo(const struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
@@ -388,14 +407,7 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 	devpriv->cmd3 = 0;
 	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
 
-	/* set gain and channel */
-	devpriv->cmd1 = 0;
-	devpriv->cmd1 |= board->ai_range_code[range];
-	/* munge channel bits for differential/scan disabled mode */
-	if (aref == AREF_DIFF)
-		chan *= 2;
-	devpriv->cmd1 |= ADC_CHAN_BITS(chan);
-	devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
+	labpc_ai_set_chan_and_gain(dev, MODE_SINGLE_CHAN, chan, range, aref);
 
 	/* setup cmd6 register for 1200 boards */
 	if (board->register_layout == labpc_1200_layout) {
@@ -950,15 +962,8 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->write_byte(devpriv->cmd6, dev->iobase + COMMAND6_REG);
 	}
 
-	/* setup channel list, etc (cmd1 register) */
-	devpriv->cmd1 = 0;
-	/* munge channel bits for differential / scan disabled mode */
-	if ((mode == MODE_SINGLE_CHAN || mode == MODE_SINGLE_CHAN_INTERVAL) &&
-	    aref == AREF_DIFF)
-		chan *= 2;
-	devpriv->cmd1 |= ADC_CHAN_BITS(chan);
-	devpriv->cmd1 |= board->ai_range_code[range];
-	devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
+	labpc_ai_set_chan_and_gain(dev, mode, chan, range, aref);
+
 	/* manual says to set scan enable bit on second pass */
 	if (mode == MODE_MULT_CHAN_UP || mode == MODE_MULT_CHAN_DOWN) {
 		devpriv->cmd1 |= ADC_SCAN_EN_BIT;

commit 73f2b1d26f3d97f7c34166d22b30f89dc9cf9402
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:48:19 2013 -0700

    staging: comedi: ni_labpc: cleanup local var declarations in labpc_ai_insn_read()
    
    Determine the chan, range, and aref when the variables are declared.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 3672ba897b86..0b68e13e2377 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -370,11 +370,13 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
-	int i, n;
-	int chan, range;
-	int lsb, msb;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
+	unsigned int aref = CR_AREF(insn->chanspec);
 	int timeout = 1000;
 	unsigned long flags;
+	int lsb, msb;
+	int i, n;
 
 	/*  disable timed conversions */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -388,11 +390,9 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 
 	/* set gain and channel */
 	devpriv->cmd1 = 0;
-	chan = CR_CHAN(insn->chanspec);
-	range = CR_RANGE(insn->chanspec);
 	devpriv->cmd1 |= board->ai_range_code[range];
 	/* munge channel bits for differential/scan disabled mode */
-	if (CR_AREF(insn->chanspec) == AREF_DIFF)
+	if (aref == AREF_DIFF)
 		chan *= 2;
 	devpriv->cmd1 |= ADC_CHAN_BITS(chan);
 	devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
@@ -400,7 +400,7 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 	/* setup cmd6 register for 1200 boards */
 	if (board->register_layout == labpc_1200_layout) {
 		/*  reference inputs to ground or common? */
-		if (CR_AREF(insn->chanspec) != AREF_GROUND)
+		if (aref != AREF_GROUND)
 			devpriv->cmd6 |= ADC_COMMON_BIT;
 		else
 			devpriv->cmd6 &= ~ADC_COMMON_BIT;
@@ -420,7 +420,7 @@ static int labpc_ai_insn_read(struct comedi_device *dev,
 	devpriv->cmd4 = 0;
 	devpriv->cmd4 |= EXT_CONVERT_DISABLE_BIT;
 	/* single-ended/differential */
-	if (CR_AREF(insn->chanspec) == AREF_DIFF)
+	if (aref == AREF_DIFF)
 		devpriv->cmd4 |= ADC_DIFF_BIT;
 	devpriv->write_byte(devpriv->cmd4, dev->iobase + COMMAND4_REG);
 

commit 8a67a67f45b1393a4cf656b89afa99202adb041c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:47:51 2013 -0700

    staging: comedi: ni_labpc: cleanup local var declarations in labpc_ai_cmd()
    
    Determine the scan_mode early and get the proper chanspec so that
    the chan, range, and aref can be determined when the variables are
    declared.
    
    labpc_ai_chanlist_invalid() checks that all the range and aref values
    in the chanlist are the same so, for consistency, use the same chanspec
    used to get the chan.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 56d60847f820..3672ba897b86 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -850,16 +850,18 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
-	int channel, range, aref;
-	int ret;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
+	enum scan_mode mode = labpc_ai_scan_mode(cmd);
+	unsigned int chanspec = (mode == MODE_MULT_CHAN_UP)
+				? cmd->chanlist[cmd->chanlist_len - 1]
+				: cmd->chanlist[0];
+	unsigned int chan = CR_CHAN(chanspec);
+	unsigned int range = CR_RANGE(chanspec);
+	unsigned int aref = CR_AREF(chanspec);
 	enum transfer_type xfer;
-	enum scan_mode mode;
 	unsigned long flags;
-
-	range = CR_RANGE(cmd->chanlist[0]);
-	aref = CR_AREF(cmd->chanlist[0]);
+	int ret;
 
 	/* make sure board is disabled before setting up acquisition */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -916,7 +918,6 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	} else
 		xfer = fifo_not_empty_transfer;
 	devpriv->current_transfer = xfer;
-	mode = labpc_ai_scan_mode(cmd);
 
 	/*  setup cmd6 register for 1200 boards */
 	if (board->register_layout == labpc_1200_layout) {
@@ -951,15 +952,11 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* setup channel list, etc (cmd1 register) */
 	devpriv->cmd1 = 0;
-	if (mode == MODE_MULT_CHAN_UP)
-		channel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);
-	else
-		channel = CR_CHAN(cmd->chanlist[0]);
 	/* munge channel bits for differential / scan disabled mode */
 	if ((mode == MODE_SINGLE_CHAN || mode == MODE_SINGLE_CHAN_INTERVAL) &&
 	    aref == AREF_DIFF)
-		channel *= 2;
-	devpriv->cmd1 |= ADC_CHAN_BITS(channel);
+		chan *= 2;
+	devpriv->cmd1 |= ADC_CHAN_BITS(chan);
 	devpriv->cmd1 |= board->ai_range_code[range];
 	devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
 	/* manual says to set scan enable bit on second pass */

commit 9718e5dfd7e19a2fb0d98a9afdb0459ba6b5d41f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:47:20 2013 -0700

    staging: comedi: ni_labpc: remove unnecessary test of dev->irq
    
    The ai subdevice (*do_cmd) pointer is only initialized if the
    driver has successfully requested the interrupt. The extra test
    in labpc_ai_cmd() is not necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index f9c720938e27..56d60847f820 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -858,11 +858,6 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	enum scan_mode mode;
 	unsigned long flags;
 
-	if (!dev->irq) {
-		comedi_error(dev, "no irq assigned, cannot perform command");
-		return -1;
-	}
-
 	range = CR_RANGE(cmd->chanlist[0]);
 	aref = CR_AREF(cmd->chanlist[0]);
 

commit fe7fc72af7df7120e1897fc07a05e247364b3a50
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:46:53 2013 -0700

    staging: comedi: ni_labpc: move declaration of local var 'irq_flags'
    
    In labpc_ai_cmd(), move the declaration of the local variable
    'irq_flags' to remove the need for the extra #ifdef/#endif.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 54669b46e7e2..f9c720938e27 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -851,9 +851,6 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	int channel, range, aref;
-#ifdef CONFIG_ISA_DMA_API
-	unsigned long irq_flags;
-#endif
 	int ret;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1026,6 +1023,8 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 #ifdef CONFIG_ISA_DMA_API
 	/*  set up dma transfer */
 	if (xfer == isa_dma_transfer) {
+		unsigned long irq_flags;
+
 		irq_flags = claim_dma_lock();
 		disable_dma(devpriv->dma_chan);
 		/* clear flip-flop to make sure 2-byte registers for

commit 147a85d7dbda7f672deddba46f7165e26036c4ab
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:46:28 2013 -0700

    staging: comedi: ni_labpc: remove DRV_NAME
    
    Remove the DRV_NAME define and just open code the string in the
    comedi_driver and pci_driver declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 887fa8cc2684..54669b46e7e2 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -89,8 +89,6 @@ NI manuals:
 #include "comedi_fc.h"
 #include "ni_labpc.h"
 
-#define DRV_NAME "ni_labpc"
-
 /* size of io region used by board */
 #define LABPC_SIZE           32
 /* 2 MHz master clock */
@@ -1969,7 +1967,7 @@ void labpc_common_detach(struct comedi_device *dev)
 EXPORT_SYMBOL_GPL(labpc_common_detach);
 
 static struct comedi_driver labpc_driver = {
-	.driver_name	= DRV_NAME,
+	.driver_name	= "ni_labpc",
 	.module		= THIS_MODULE,
 	.attach		= labpc_attach,
 	.auto_attach	= labpc_auto_attach,
@@ -1993,7 +1991,7 @@ static int labpc_pci_probe(struct pci_dev *dev,
 }
 
 static struct pci_driver labpc_pci_driver = {
-	.name		= DRV_NAME,
+	.name		= "ni_labpc",
 	.id_table	= labpc_pci_table,
 	.probe		= labpc_pci_probe,
 	.remove		= comedi_pci_auto_unconfig,

commit 7b09c9f63d70cf9aa54455b22f3f9e0df596d8c2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:46:05 2013 -0700

    staging: comedi: ni_labpc: use dev->board_name instead of DRV_NAME
    
    In labpc_common_attach(), initialize the dev->board_name early and
    use that instead of DRV_NAME when allocating the resources.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 2c932e6d97cc..887fa8cc2684 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1672,7 +1672,9 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	int ret;
 	int i;
 
-	dev_info(dev->class_dev, "ni_labpc: %s\n", board->name);
+	dev->board_name = board->name;
+
+	dev_info(dev->class_dev, "ni_labpc: %s\n", dev->board_name);
 	if (iobase == 0) {
 		dev_err(dev->class_dev, "io base address is zero!\n");
 		return -EINVAL;
@@ -1680,7 +1682,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	/*  request io regions for isa boards */
 	if (board->bustype == isa_bustype) {
 		/* check if io addresses are available */
-		if (!request_region(iobase, LABPC_SIZE, DRV_NAME)) {
+		if (!request_region(iobase, LABPC_SIZE, dev->board_name)) {
 			dev_err(dev->class_dev, "I/O port conflict\n");
 			return -EIO;
 		}
@@ -1711,7 +1713,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		    board->bustype == pcmcia_bustype)
 			isr_flags |= IRQF_SHARED;
 		if (request_irq(irq, labpc_interrupt, isr_flags,
-				DRV_NAME, dev)) {
+				dev->board_name, dev)) {
 			dev_err(dev->class_dev, "unable to allocate irq %u\n",
 				irq);
 			return -EINVAL;
@@ -1733,7 +1735,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		if (devpriv->dma_buffer == NULL)
 			return -ENOMEM;
 
-		if (request_dma(dma_chan, DRV_NAME)) {
+		if (request_dma(dma_chan, dev->board_name)) {
 			dev_err(dev->class_dev,
 				"failed to allocate dma channel %u\n",
 				dma_chan);
@@ -1747,8 +1749,6 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	}
 #endif
 
-	dev->board_name = board->name;
-
 	ret = comedi_alloc_subdevices(dev, 5);
 	if (ret)
 		return ret;

commit cacedd0ce5f3482574dd18ce218a3f4440b4c828
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:45:41 2013 -0700

    staging: comedi: ni_labpc: move declaration of local var 'dma_flags'
    
    In labpc_common_attach(), move the declaration of the local variable
    'dma_flags' to remove the need for the extra #ifdef/#endif.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 33e9f4dee6d3..2c932e6d97cc 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1668,12 +1668,9 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
-	int i;
 	unsigned long isr_flags;
-#ifdef CONFIG_ISA_DMA_API
-	unsigned long dma_flags;
-#endif
 	int ret;
+	int i;
 
 	dev_info(dev->class_dev, "ni_labpc: %s\n", board->name);
 	if (iobase == 0) {
@@ -1728,6 +1725,8 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		dev_err(dev->class_dev, "invalid dma channel %u\n", dma_chan);
 		return -EINVAL;
 	} else if (dma_chan) {
+		unsigned long dma_flags;
+
 		/* allocate dma buffer */
 		devpriv->dma_buffer = kmalloc(dma_buffer_size,
 					      GFP_KERNEL | GFP_DMA);

commit 7d47f0f4c6005b74cc73be01869051d2aee8102e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:45:13 2013 -0700

    staging: comedi: ni_labpc: tidy up subdevice init
    
    Add some whitespace to the subdevice init.
    
    Remove the unnecessary comment about adding command support to
    the analog input subdevice and change the 'maxdata' value to hex
    as this is more common in comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 94de40b273de..33e9f4dee6d3 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1673,7 +1673,6 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 #ifdef CONFIG_ISA_DMA_API
 	unsigned long dma_flags;
 #endif
-	short lsb, msb;
 	int ret;
 
 	dev_info(dev->class_dev, "ni_labpc: %s\n", board->name);
@@ -1775,20 +1774,18 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	/* analog output */
 	s = &dev->subdevices[1];
 	if (board->has_ao) {
-		/*
-		 * Could provide command support, except it only has a
-		 * one sample hardware buffer for analog output and no
-		 * underrun flag.
-		 */
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
-		s->n_chan = NUM_AO_CHAN;
-		s->maxdata = (1 << 12) - 1;	/*  12 bit resolution */
-		s->range_table = &range_labpc_ao;
-		s->insn_read = labpc_ao_insn_read;
-		s->insn_write = labpc_ao_insn_write;
+		s->type		= COMEDI_SUBD_AO;
+		s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
+		s->n_chan	= NUM_AO_CHAN;
+		s->maxdata	= 0x0fff;
+		s->range_table	= &range_labpc_ao;
+		s->insn_read	= labpc_ao_insn_read;
+		s->insn_write	= labpc_ao_insn_write;
+
 		/* initialize analog outputs to a known value */
 		for (i = 0; i < s->n_chan; i++) {
+			short lsb, msb;
+
 			devpriv->ao_value[i] = s->maxdata / 2;
 			lsb = devpriv->ao_value[i] & 0xff;
 			msb = (devpriv->ao_value[i] >> 8) & 0xff;
@@ -1796,7 +1793,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 			devpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(i));
 		}
 	} else {
-		s->type = COMEDI_SUBD_UNUSED;
+		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
 	/* 8255 dio */
@@ -1810,32 +1807,32 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	/*  calibration subdevices for boards that have one */
 	s = &dev->subdevices[3];
 	if (board->register_layout == labpc_1200_layout) {
-		s->type = COMEDI_SUBD_CALIB;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-		s->n_chan = 16;
-		s->maxdata = 0xff;
-		s->insn_read = labpc_calib_insn_read;
-		s->insn_write = labpc_calib_insn_write;
+		s->type		= COMEDI_SUBD_CALIB;
+		s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+		s->n_chan	= 16;
+		s->maxdata	= 0xff;
+		s->insn_read	= labpc_calib_insn_read;
+		s->insn_write	= labpc_calib_insn_write;
 
 		for (i = 0; i < s->n_chan; i++)
 			write_caldac(dev, i, s->maxdata / 2);
 	} else
-		s->type = COMEDI_SUBD_UNUSED;
+		s->type		= COMEDI_SUBD_UNUSED;
 
 	/* EEPROM */
 	s = &dev->subdevices[4];
 	if (board->register_layout == labpc_1200_layout) {
-		s->type = COMEDI_SUBD_MEMORY;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-		s->n_chan = EEPROM_SIZE;
-		s->maxdata = 0xff;
-		s->insn_read = labpc_eeprom_insn_read;
-		s->insn_write = labpc_eeprom_insn_write;
-
-		for (i = 0; i < EEPROM_SIZE; i++)
+		s->type		= COMEDI_SUBD_MEMORY;
+		s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+		s->n_chan	= EEPROM_SIZE;
+		s->maxdata	= 0xff;
+		s->insn_read	= labpc_eeprom_insn_read;
+		s->insn_write	= labpc_eeprom_insn_write;
+
+		for (i = 0; i < s->n_chan; i++)
 			devpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);
 	} else
-		s->type = COMEDI_SUBD_UNUSED;
+		s->type		= COMEDI_SUBD_UNUSED;
 
 	return 0;
 }

commit 370c8e1f76a316ba698d3ef525dd95d83db7b097
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:44:38 2013 -0700

    staging: comedi: ni_labpc: fix 8255 dio subdevice init
    
    The subdev_8255_init() function can fail. Check for failure and
    return the errno.
    
    Consolidate the mmio/ioport calls to subdev_8255_init(). The callback
    function can be added with a simple ? : test and the cast of the iobase
    is not necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index ef9a206068fd..94de40b273de 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1393,8 +1393,7 @@ static int labpc_ao_insn_read(struct comedi_device *dev,
 	return 1;
 }
 
-static int labpc_dio_mem_callback(int dir, int port, int data,
-				  unsigned long iobase)
+static int labpc_8255_mmio(int dir, int port, int data, unsigned long iobase)
 {
 	if (dir) {
 		writeb(data, (void __iomem *)(iobase + port));
@@ -1802,13 +1801,11 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 	/* 8255 dio */
 	s = &dev->subdevices[2];
-	/*  if board uses io memory we have to give a custom callback
-	 * function to the 8255 driver */
-	if (board->has_mmio)
-		subdev_8255_init(dev, s, labpc_dio_mem_callback,
-				 (unsigned long)(dev->iobase + DIO_BASE_REG));
-	else
-		subdev_8255_init(dev, s, NULL, dev->iobase + DIO_BASE_REG);
+	ret = subdev_8255_init(dev, s,
+			       (board->has_mmio) ? labpc_8255_mmio : NULL,
+			       dev->iobase + DIO_BASE_REG);
+	if (ret)
+		return ret;
 
 	/*  calibration subdevices for boards that have one */
 	s = &dev->subdevices[3];

commit 9bffb75d7510c44ce227d940cd8663df911bc487
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:43:45 2013 -0700

    staging: comedi: ni_labpc: fix command support with analog input subdevice
    
    An interrupt is required for command support to work with the
    analog input subdevice. When used with the ISA driver, enabling
    the interrupt is optional. Fix the subdevice init so that command
    support is only enabled if the irq is available.
    
    Add some whitespace to the subdevice init. Change the 'maxdata'
    value to hex as this is more common in comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index b6bfb2b626a8..ef9a206068fd 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1758,18 +1758,20 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 	/* analog input subdevice */
 	s = &dev->subdevices[0];
-	dev->read_subdev = s;
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags =
-	    SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF | SDF_CMD_READ;
-	s->n_chan = 8;
-	s->len_chanlist = 8;
-	s->maxdata = (1 << 12) - 1;	/* 12 bit resolution */
-	s->range_table = board->ai_range_table;
-	s->do_cmd = labpc_ai_cmd;
-	s->do_cmdtest = labpc_ai_cmdtest;
-	s->insn_read = labpc_ai_insn_read;
-	s->cancel = labpc_cancel;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF;
+	s->n_chan	= 8;
+	s->len_chanlist	= 8;
+	s->maxdata	= 0x0fff;
+	s->range_table	= board->ai_range_table;
+	s->insn_read	= labpc_ai_insn_read;
+	if (dev->irq) {
+		dev->read_subdev = s;
+		s->subdev_flags	|= SDF_CMD_READ;
+		s->do_cmd	= labpc_ai_cmd;
+		s->do_cmdtest	= labpc_ai_cmdtest;
+		s->cancel	= labpc_cancel;
+	}
 
 	/* analog output */
 	s = &dev->subdevices[1];

commit 28a10930e6af5585ade2ef23eb8ce370d1450488
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:43:14 2013 -0700

    staging: comedi: ni_labpc: rename subdevice (*insn_{read, write}) functions
    
    For aesthetic reasons, and to make grepping easier, rename all the
    subdevice (*insn_read) and (*insn_write) functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 96da6e71c0ac..b6bfb2b626a8 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -365,8 +365,10 @@ static void labpc_clear_adc_fifo(const struct comedi_device *dev)
 	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
 }
 
-static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data)
+static int labpc_ai_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
@@ -1336,9 +1338,10 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-/* analog output insn */
-static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data)
+static int labpc_ao_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
@@ -1378,9 +1381,10 @@ static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return 1;
 }
 
-/* analog output readback insn */
-static int labpc_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data)
+static int labpc_ao_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
 	struct labpc_private *devpriv = dev->private;
 
@@ -1602,9 +1606,10 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 }
 
-static int labpc_calib_write_insn(struct comedi_device *dev,
+static int labpc_calib_insn_write(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data)
+				  struct comedi_insn *insn,
+				  unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -1612,9 +1617,10 @@ static int labpc_calib_write_insn(struct comedi_device *dev,
 	return 1;
 }
 
-static int labpc_calib_read_insn(struct comedi_device *dev,
+static int labpc_calib_insn_read(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn, unsigned int *data)
+				 struct comedi_insn *insn,
+				 unsigned int *data)
 {
 	struct labpc_private *devpriv = dev->private;
 
@@ -1623,9 +1629,10 @@ static int labpc_calib_read_insn(struct comedi_device *dev,
 	return 1;
 }
 
-static int labpc_eeprom_write_insn(struct comedi_device *dev,
+static int labpc_eeprom_insn_write(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
-				   struct comedi_insn *insn, unsigned int *data)
+				   struct comedi_insn *insn,
+				   unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 	int ret;
@@ -1644,9 +1651,10 @@ static int labpc_eeprom_write_insn(struct comedi_device *dev,
 	return 1;
 }
 
-static int labpc_eeprom_read_insn(struct comedi_device *dev,
+static int labpc_eeprom_insn_read(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data)
+				  struct comedi_insn *insn,
+				  unsigned int *data)
 {
 	struct labpc_private *devpriv = dev->private;
 
@@ -1760,7 +1768,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	s->range_table = board->ai_range_table;
 	s->do_cmd = labpc_ai_cmd;
 	s->do_cmdtest = labpc_ai_cmdtest;
-	s->insn_read = labpc_ai_rinsn;
+	s->insn_read = labpc_ai_insn_read;
 	s->cancel = labpc_cancel;
 
 	/* analog output */
@@ -1776,8 +1784,8 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		s->n_chan = NUM_AO_CHAN;
 		s->maxdata = (1 << 12) - 1;	/*  12 bit resolution */
 		s->range_table = &range_labpc_ao;
-		s->insn_read = labpc_ao_rinsn;
-		s->insn_write = labpc_ao_winsn;
+		s->insn_read = labpc_ao_insn_read;
+		s->insn_write = labpc_ao_insn_write;
 		/* initialize analog outputs to a known value */
 		for (i = 0; i < s->n_chan; i++) {
 			devpriv->ao_value[i] = s->maxdata / 2;
@@ -1807,8 +1815,8 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 		s->n_chan = 16;
 		s->maxdata = 0xff;
-		s->insn_read = labpc_calib_read_insn;
-		s->insn_write = labpc_calib_write_insn;
+		s->insn_read = labpc_calib_insn_read;
+		s->insn_write = labpc_calib_insn_write;
 
 		for (i = 0; i < s->n_chan; i++)
 			write_caldac(dev, i, s->maxdata / 2);
@@ -1822,8 +1830,8 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 		s->n_chan = EEPROM_SIZE;
 		s->maxdata = 0xff;
-		s->insn_read = labpc_eeprom_read_insn;
-		s->insn_write = labpc_eeprom_write_insn;
+		s->insn_read = labpc_eeprom_insn_read;
+		s->insn_write = labpc_eeprom_insn_write;
 
 		for (i = 0; i < EEPROM_SIZE; i++)
 			devpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);

commit 43a9411a67509623ad8f9e9d3712dea449a488bf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:42:48 2013 -0700

    staging: comedi: ni_labpc: introduce labpc_range_is_unipolar()
    
    Introduce a helper function to determine if a range selection is
    bipolar or unipolar.
    
    This allows removing the static data 'labpc_range_is_unipolar' and
    'labpc_plus_is_unipolar' as well as the boardinfo 'ai_range_is_unipolar'.
    
    For consistency, also use the helper in labpc_ao_winsn() when
    checking the range.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 240db9e23f73..96da6e71c0ac 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -215,11 +215,6 @@ enum scan_mode {
 	MODE_MULT_CHAN_DOWN,
 };
 
-static const int labpc_plus_is_unipolar[] = {
-	0, 0, 0, 0, 0, 0, 0, 0,
-	1, 1, 1, 1, 1, 1, 1, 1,
-};
-
 static const int labpc_plus_ai_gain_bits[] = {
 	0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
 	0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
@@ -246,12 +241,6 @@ static const struct comedi_lrange range_labpc_plus_ai = {
 	}
 };
 
-const int labpc_1200_is_unipolar[] = {
-	0, 0, 0, 0, 0, 0, 0,
-	1, 1, 1, 1, 1, 1, 1,
-};
-EXPORT_SYMBOL_GPL(labpc_1200_is_unipolar);
-
 const int labpc_1200_ai_gain_bits[] = {
 	0x00, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
 	0x00, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
@@ -278,7 +267,6 @@ const struct comedi_lrange range_labpc_1200_ai = {
 };
 EXPORT_SYMBOL_GPL(range_labpc_1200_ai);
 
-#define AO_RANGE_IS_UNIPOLAR 0x1
 static const struct comedi_lrange range_labpc_ao = {
 	2, {
 		BIP_RANGE(5),
@@ -317,7 +305,6 @@ static const struct labpc_boardinfo labpc_boards[] = {
 		.has_ao			= 1,
 		.ai_range_table		= &range_labpc_1200_ai,
 		.ai_range_code		= labpc_1200_ai_gain_bits,
-		.ai_range_is_unipolar	= labpc_1200_is_unipolar,
 		.ai_scan_up		= 1,
 	}, {
 		.name			= "lab-pc-1200ai",
@@ -326,7 +313,6 @@ static const struct labpc_boardinfo labpc_boards[] = {
 		.register_layout	= labpc_1200_layout,
 		.ai_range_table		= &range_labpc_1200_ai,
 		.ai_range_code		= labpc_1200_ai_gain_bits,
-		.ai_range_is_unipolar	= labpc_1200_is_unipolar,
 		.ai_scan_up		= 1,
 	}, {
 		.name			= "lab-pc+",
@@ -336,7 +322,6 @@ static const struct labpc_boardinfo labpc_boards[] = {
 		.has_ao			= 1,
 		.ai_range_table		= &range_labpc_plus_ai,
 		.ai_range_code		= labpc_plus_ai_gain_bits,
-		.ai_range_is_unipolar	= labpc_plus_is_unipolar,
 	},
 #ifdef CONFIG_COMEDI_PCI_DRIVERS
 	{
@@ -348,7 +333,6 @@ static const struct labpc_boardinfo labpc_boards[] = {
 		.has_ao			= 1,
 		.ai_range_table		= &range_labpc_1200_ai,
 		.ai_range_code		= labpc_1200_ai_gain_bits,
-		.ai_range_is_unipolar	= labpc_1200_is_unipolar,
 		.ai_scan_up		= 1,
 		.has_mmio		= 1,
 	},
@@ -360,6 +344,18 @@ static const int dma_buffer_size = 0xff00;
 /* 2 bytes per sample */
 static const int sample_size = 2;
 
+static bool labpc_range_is_unipolar(struct comedi_subdevice *s,
+				    unsigned int range)
+{
+	const struct comedi_lrange *lrange = s->range_table;
+	const struct comedi_krange *krange = &lrange->range[range];
+
+	if (krange->min < 0)
+		return false;
+	else
+		return true;
+}
+
 static void labpc_clear_adc_fifo(const struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
@@ -409,7 +405,7 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		else
 			devpriv->cmd6 &= ~ADC_COMMON_BIT;
 		/* bipolar or unipolar range? */
-		if (board->ai_range_is_unipolar[range])
+		if (labpc_range_is_unipolar(s, range))
 			devpriv->cmd6 |= ADC_UNIP_BIT;
 		else
 			devpriv->cmd6 &= ~ADC_UNIP_BIT;
@@ -938,7 +934,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		else
 			devpriv->cmd6 &= ~ADC_COMMON_BIT;
 		/*  bipolar or unipolar range? */
-		if (board->ai_range_is_unipolar[range])
+		if (labpc_range_is_unipolar(s, range))
 			devpriv->cmd6 |= ADC_UNIP_BIT;
 		else
 			devpriv->cmd6 &= ~ADC_UNIP_BIT;
@@ -1363,7 +1359,7 @@ static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* set range */
 	if (board->register_layout == labpc_1200_layout) {
 		range = CR_RANGE(insn->chanspec);
-		if (range & AO_RANGE_IS_UNIPOLAR)
+		if (labpc_range_is_unipolar(s, range))
 			devpriv->cmd6 |= DAC_UNIP_BIT(channel);
 		else
 			devpriv->cmd6 &= ~DAC_UNIP_BIT(channel);

commit 4d3cc8ab551af2452705cbccd0165dcdf1862196
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:42:18 2013 -0700

    staging: comedi: ni_labpc: rename boardinfo 'memory_mapped_io'
    
    Rename the boardinfo 'memory_mapped_io' to 'has_mmio'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 43cf49141e5f..240db9e23f73 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -350,7 +350,7 @@ static const struct labpc_boardinfo labpc_boards[] = {
 		.ai_range_code		= labpc_1200_ai_gain_bits,
 		.ai_range_is_unipolar	= labpc_1200_is_unipolar,
 		.ai_scan_up		= 1,
-		.memory_mapped_io	= 1,
+		.has_mmio		= 1,
 	},
 #endif
 };
@@ -843,7 +843,7 @@ static inline int labpc_counter_load(struct comedi_device *dev,
 {
 	const struct labpc_boardinfo *board = comedi_board(dev);
 
-	if (board->memory_mapped_io)
+	if (board->has_mmio)
 		return i8254_mm_load((void __iomem *)base_address, 0,
 				     counter_number, count, mode);
 	else
@@ -1688,7 +1688,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	}
 	dev->iobase = iobase;
 
-	if (board->memory_mapped_io) {
+	if (board->has_mmio) {
 		devpriv->read_byte = labpc_readb;
 		devpriv->write_byte = labpc_writeb;
 	} else {
@@ -1798,7 +1798,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	s = &dev->subdevices[2];
 	/*  if board uses io memory we have to give a custom callback
 	 * function to the 8255 driver */
-	if (board->memory_mapped_io)
+	if (board->has_mmio)
 		subdev_8255_init(dev, s, labpc_dio_mem_callback,
 				 (unsigned long)(dev->iobase + DIO_BASE_REG));
 	else

commit d0baa0c11701ae0f813cbdf32cbe54e90f8f4958
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:41:48 2013 -0700

    staging: comedi: ni_labpc: rename local var 'thisboard'
    
    For aesthetic reasons, rename the local variable 'thisboard' to
    'board'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 81a3b3a5758b..43cf49141e5f 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -372,7 +372,7 @@ static void labpc_clear_adc_fifo(const struct comedi_device *dev)
 static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	int i, n;
 	int chan, range;
@@ -394,7 +394,7 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	devpriv->cmd1 = 0;
 	chan = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
-	devpriv->cmd1 |= thisboard->ai_range_code[range];
+	devpriv->cmd1 |= board->ai_range_code[range];
 	/* munge channel bits for differential/scan disabled mode */
 	if (CR_AREF(insn->chanspec) == AREF_DIFF)
 		chan *= 2;
@@ -402,14 +402,14 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
 
 	/* setup cmd6 register for 1200 boards */
-	if (thisboard->register_layout == labpc_1200_layout) {
+	if (board->register_layout == labpc_1200_layout) {
 		/*  reference inputs to ground or common? */
 		if (CR_AREF(insn->chanspec) != AREF_GROUND)
 			devpriv->cmd6 |= ADC_COMMON_BIT;
 		else
 			devpriv->cmd6 &= ~ADC_COMMON_BIT;
 		/* bipolar or unipolar range? */
-		if (thisboard->ai_range_is_unipolar[range])
+		if (board->ai_range_is_unipolar[range])
 			devpriv->cmd6 |= ADC_UNIP_BIT;
 		else
 			devpriv->cmd6 &= ~ADC_UNIP_BIT;
@@ -740,7 +740,7 @@ static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
 static int labpc_ai_cmdtest(struct comedi_device *dev,
 			    struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	const struct labpc_boardinfo *board = comedi_board(dev);
 	int err = 0;
 	int tmp, tmp2;
 	unsigned int stop_mask;
@@ -755,7 +755,7 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 
 	stop_mask = TRIG_COUNT | TRIG_NONE;
-	if (thisboard->register_layout == labpc_1200_layout)
+	if (board->register_layout == labpc_1200_layout)
 		stop_mask |= TRIG_EXT;
 	err |= cfc_check_trigger_src(&cmd->stop_src, stop_mask);
 
@@ -789,7 +789,7 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->convert_src == TRIG_TIMER)
 		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 thisboard->ai_speed);
+						 board->ai_speed);
 
 	/* make sure scan timing is not too fast */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
@@ -797,7 +797,7 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
 					cmd->convert_arg * cmd->chanlist_len);
 		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-				thisboard->ai_speed * cmd->chanlist_len);
+				board->ai_speed * cmd->chanlist_len);
 	}
 
 	switch (cmd->stop_src) {
@@ -841,9 +841,9 @@ static inline int labpc_counter_load(struct comedi_device *dev,
 				     unsigned int counter_number,
 				     unsigned int count, unsigned int mode)
 {
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	const struct labpc_boardinfo *board = comedi_board(dev);
 
-	if (thisboard->memory_mapped_io)
+	if (board->memory_mapped_io)
 		return i8254_mm_load((void __iomem *)base_address, 0,
 				     counter_number, count, mode);
 	else
@@ -852,7 +852,7 @@ static inline int labpc_counter_load(struct comedi_device *dev,
 
 static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	int channel, range, aref;
 #ifdef CONFIG_ISA_DMA_API
@@ -914,12 +914,12 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 */
 	    (cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0 &&
 	    /*  only available on the isa boards */
-	    thisboard->bustype == isa_bustype) {
+	    board->bustype == isa_bustype) {
 		xfer = isa_dma_transfer;
 		/* pc-plus has no fifo-half full interrupt */
 	} else
 #endif
-	if (thisboard->register_layout == labpc_1200_layout &&
+	if (board->register_layout == labpc_1200_layout &&
 		   /*  wake-end-of-scan should interrupt on fifo not empty */
 		   (cmd->flags & TRIG_WAKE_EOS) == 0 &&
 		   /*  make sure we are taking more than just a few points */
@@ -931,14 +931,14 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	mode = labpc_ai_scan_mode(cmd);
 
 	/*  setup cmd6 register for 1200 boards */
-	if (thisboard->register_layout == labpc_1200_layout) {
+	if (board->register_layout == labpc_1200_layout) {
 		/*  reference inputs to ground or common? */
 		if (aref != AREF_GROUND)
 			devpriv->cmd6 |= ADC_COMMON_BIT;
 		else
 			devpriv->cmd6 &= ~ADC_COMMON_BIT;
 		/*  bipolar or unipolar range? */
-		if (thisboard->ai_range_is_unipolar[range])
+		if (board->ai_range_is_unipolar[range])
 			devpriv->cmd6 |= ADC_UNIP_BIT;
 		else
 			devpriv->cmd6 &= ~ADC_UNIP_BIT;
@@ -972,7 +972,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	    aref == AREF_DIFF)
 		channel *= 2;
 	devpriv->cmd1 |= ADC_CHAN_BITS(channel);
-	devpriv->cmd1 |= thisboard->ai_range_code[range];
+	devpriv->cmd1 |= board->ai_range_code[range];
 	devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
 	/* manual says to set scan enable bit on second pass */
 	if (mode == MODE_MULT_CHAN_UP || mode == MODE_MULT_CHAN_DOWN) {
@@ -1254,7 +1254,7 @@ static void labpc_drain_dregs(struct comedi_device *dev)
 static irqreturn_t labpc_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
@@ -1271,7 +1271,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 
 	/* read board status */
 	devpriv->stat1 = devpriv->read_byte(dev->iobase + STATUS1_REG);
-	if (thisboard->register_layout == labpc_1200_layout)
+	if (board->register_layout == labpc_1200_layout)
 		devpriv->stat2 = devpriv->read_byte(dev->iobase + STATUS2_REG);
 
 	if ((devpriv->stat1 & (DMATC_BIT | TIMER_BIT | OVERFLOW_BIT |
@@ -1297,7 +1297,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 		 * has occurred
 		 */
 		if (devpriv->stat1 & DMATC_BIT ||
-		    (thisboard->register_layout == labpc_1200_layout
+		    (board->register_layout == labpc_1200_layout
 		     && devpriv->stat2 & A1_TC_BIT)) {
 			handle_isa_dma(dev);
 		}
@@ -1344,7 +1344,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	int channel, range;
 	unsigned long flags;
@@ -1361,7 +1361,7 @@ static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* set range */
-	if (thisboard->register_layout == labpc_1200_layout) {
+	if (board->register_layout == labpc_1200_layout) {
 		range = CR_RANGE(insn->chanspec);
 		if (range & AO_RANGE_IS_UNIPOLAR)
 			devpriv->cmd6 |= DAC_UNIP_BIT(channel);
@@ -1662,7 +1662,7 @@ static int labpc_eeprom_read_insn(struct comedi_device *dev,
 int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 			unsigned int irq, unsigned int dma_chan)
 {
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	int i;
@@ -1673,13 +1673,13 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	short lsb, msb;
 	int ret;
 
-	dev_info(dev->class_dev, "ni_labpc: %s\n", thisboard->name);
+	dev_info(dev->class_dev, "ni_labpc: %s\n", board->name);
 	if (iobase == 0) {
 		dev_err(dev->class_dev, "io base address is zero!\n");
 		return -EINVAL;
 	}
 	/*  request io regions for isa boards */
-	if (thisboard->bustype == isa_bustype) {
+	if (board->bustype == isa_bustype) {
 		/* check if io addresses are available */
 		if (!request_region(iobase, LABPC_SIZE, DRV_NAME)) {
 			dev_err(dev->class_dev, "I/O port conflict\n");
@@ -1688,7 +1688,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	}
 	dev->iobase = iobase;
 
-	if (thisboard->memory_mapped_io) {
+	if (board->memory_mapped_io) {
 		devpriv->read_byte = labpc_readb;
 		devpriv->write_byte = labpc_writeb;
 	} else {
@@ -1700,7 +1700,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
 	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
 	devpriv->write_byte(devpriv->cmd4, dev->iobase + COMMAND4_REG);
-	if (thisboard->register_layout == labpc_1200_layout) {
+	if (board->register_layout == labpc_1200_layout) {
 		devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 		devpriv->write_byte(devpriv->cmd6, dev->iobase + COMMAND6_REG);
 	}
@@ -1708,8 +1708,8 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	/* grab our IRQ */
 	if (irq) {
 		isr_flags = 0;
-		if (thisboard->bustype == pci_bustype
-		    || thisboard->bustype == pcmcia_bustype)
+		if (board->bustype == pci_bustype ||
+		    board->bustype == pcmcia_bustype)
 			isr_flags |= IRQF_SHARED;
 		if (request_irq(irq, labpc_interrupt, isr_flags,
 				DRV_NAME, dev)) {
@@ -1746,7 +1746,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	}
 #endif
 
-	dev->board_name = thisboard->name;
+	dev->board_name = board->name;
 
 	ret = comedi_alloc_subdevices(dev, 5);
 	if (ret)
@@ -1761,7 +1761,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	s->n_chan = 8;
 	s->len_chanlist = 8;
 	s->maxdata = (1 << 12) - 1;	/* 12 bit resolution */
-	s->range_table = thisboard->ai_range_table;
+	s->range_table = board->ai_range_table;
 	s->do_cmd = labpc_ai_cmd;
 	s->do_cmdtest = labpc_ai_cmdtest;
 	s->insn_read = labpc_ai_rinsn;
@@ -1769,7 +1769,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 	/* analog output */
 	s = &dev->subdevices[1];
-	if (thisboard->has_ao) {
+	if (board->has_ao) {
 		/*
 		 * Could provide command support, except it only has a
 		 * one sample hardware buffer for analog output and no
@@ -1798,7 +1798,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	s = &dev->subdevices[2];
 	/*  if board uses io memory we have to give a custom callback
 	 * function to the 8255 driver */
-	if (thisboard->memory_mapped_io)
+	if (board->memory_mapped_io)
 		subdev_8255_init(dev, s, labpc_dio_mem_callback,
 				 (unsigned long)(dev->iobase + DIO_BASE_REG));
 	else
@@ -1806,7 +1806,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 	/*  calibration subdevices for boards that have one */
 	s = &dev->subdevices[3];
-	if (thisboard->register_layout == labpc_1200_layout) {
+	if (board->register_layout == labpc_1200_layout) {
 		s->type = COMEDI_SUBD_CALIB;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 		s->n_chan = 16;
@@ -1821,7 +1821,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 	/* EEPROM */
 	s = &dev->subdevices[4];
-	if (thisboard->register_layout == labpc_1200_layout) {
+	if (board->register_layout == labpc_1200_layout) {
 		s->type = COMEDI_SUBD_MEMORY;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 		s->n_chan = EEPROM_SIZE;
@@ -1840,7 +1840,7 @@ EXPORT_SYMBOL_GPL(labpc_common_attach);
 
 static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv;
 	unsigned long iobase = 0;
 	unsigned int irq = 0;
@@ -1852,7 +1852,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->private = devpriv;
 
 	/* get base address, irq etc. based on bustype */
-	switch (thisboard->bustype) {
+	switch (board->bustype) {
 	case isa_bustype:
 #ifdef CONFIG_ISA_DMA_API
 		iobase = it->options[0];
@@ -1868,7 +1868,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 #ifdef CONFIG_COMEDI_PCI_DRIVERS
 		dev_err(dev->class_dev,
 			"manual configuration of PCI board '%s' is not supported\n",
-			thisboard->name);
+			board->name);
 		return -EINVAL;
 #else
 		dev_err(dev->class_dev,
@@ -1938,11 +1938,11 @@ static int labpc_auto_attach(struct comedi_device *dev,
 
 void labpc_common_detach(struct comedi_device *dev)
 {
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	const struct labpc_boardinfo *board = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 
-	if (!thisboard)
+	if (!board)
 		return;
 	if (dev->subdevices) {
 		s = &dev->subdevices[2];
@@ -1956,14 +1956,14 @@ void labpc_common_detach(struct comedi_device *dev)
 #endif
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (thisboard->bustype == isa_bustype && dev->iobase)
+	if (board->bustype == isa_bustype && dev->iobase)
 		release_region(dev->iobase, LABPC_SIZE);
 #ifdef CONFIG_COMEDI_PCI_DRIVERS
 	if (devpriv->mite) {
 		mite_unsetup(devpriv->mite);
 		mite_free(devpriv->mite);
 	}
-	if (thisboard->bustype == pci_bustype)
+	if (board->bustype == pci_bustype)
 		comedi_pci_disable(dev);
 #endif
 }

commit 1b3e0c80ee2c678e645cf3e18dac9674f2e67496
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:39:22 2013 -0700

    staging: comedi: ni_labpc: tidy up range table declarations
    
    Tidy up all the tables used to indicate the bipolar/unipolar
    type of the range. the gain bits used to set the range, and the
    comedi_lrange.
    
    Remove a couple unnecessary #define's used to indicate the size
    of the tables as well as some unnecessary comments.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 44416fee6a6b..81a3b3a5758b 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -215,138 +215,75 @@ enum scan_mode {
 	MODE_MULT_CHAN_DOWN,
 };
 
-/* analog input ranges */
-#define NUM_LABPC_PLUS_AI_RANGES 16
-/* indicates unipolar ranges */
-static const int labpc_plus_is_unipolar[NUM_LABPC_PLUS_AI_RANGES] = {
-	0,
-	0,
-	0,
-	0,
-	0,
-	0,
-	0,
-	0,
-	1,
-	1,
-	1,
-	1,
-	1,
-	1,
-	1,
-	1,
+static const int labpc_plus_is_unipolar[] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	1, 1, 1, 1, 1, 1, 1, 1,
 };
 
-/* map range index to gain bits */
-static const int labpc_plus_ai_gain_bits[NUM_LABPC_PLUS_AI_RANGES] = {
-	0x00,
-	0x10,
-	0x20,
-	0x30,
-	0x40,
-	0x50,
-	0x60,
-	0x70,
-	0x00,
-	0x10,
-	0x20,
-	0x30,
-	0x40,
-	0x50,
-	0x60,
-	0x70,
+static const int labpc_plus_ai_gain_bits[] = {
+	0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
+	0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
 };
 
 static const struct comedi_lrange range_labpc_plus_ai = {
-	NUM_LABPC_PLUS_AI_RANGES,
-	{
-	 BIP_RANGE(5),
-	 BIP_RANGE(4),
-	 BIP_RANGE(2.5),
-	 BIP_RANGE(1),
-	 BIP_RANGE(0.5),
-	 BIP_RANGE(0.25),
-	 BIP_RANGE(0.1),
-	 BIP_RANGE(0.05),
-	 UNI_RANGE(10),
-	 UNI_RANGE(8),
-	 UNI_RANGE(5),
-	 UNI_RANGE(2),
-	 UNI_RANGE(1),
-	 UNI_RANGE(0.5),
-	 UNI_RANGE(0.2),
-	 UNI_RANGE(0.1),
-	 }
+	16, {
+		BIP_RANGE(5),
+		BIP_RANGE(4),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1),
+		BIP_RANGE(0.5),
+		BIP_RANGE(0.25),
+		BIP_RANGE(0.1),
+		BIP_RANGE(0.05),
+		UNI_RANGE(10),
+		UNI_RANGE(8),
+		UNI_RANGE(5),
+		UNI_RANGE(2),
+		UNI_RANGE(1),
+		UNI_RANGE(0.5),
+		UNI_RANGE(0.2),
+		UNI_RANGE(0.1)
+	}
 };
 
-#define NUM_LABPC_1200_AI_RANGES 14
-/* indicates unipolar ranges */
-const int labpc_1200_is_unipolar[NUM_LABPC_1200_AI_RANGES] = {
-	0,
-	0,
-	0,
-	0,
-	0,
-	0,
-	0,
-	1,
-	1,
-	1,
-	1,
-	1,
-	1,
-	1,
+const int labpc_1200_is_unipolar[] = {
+	0, 0, 0, 0, 0, 0, 0,
+	1, 1, 1, 1, 1, 1, 1,
 };
 EXPORT_SYMBOL_GPL(labpc_1200_is_unipolar);
 
-/* map range index to gain bits */
-const int labpc_1200_ai_gain_bits[NUM_LABPC_1200_AI_RANGES] = {
-	0x00,
-	0x20,
-	0x30,
-	0x40,
-	0x50,
-	0x60,
-	0x70,
-	0x00,
-	0x20,
-	0x30,
-	0x40,
-	0x50,
-	0x60,
-	0x70,
+const int labpc_1200_ai_gain_bits[] = {
+	0x00, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
+	0x00, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
 };
 EXPORT_SYMBOL_GPL(labpc_1200_ai_gain_bits);
 
 const struct comedi_lrange range_labpc_1200_ai = {
-	NUM_LABPC_1200_AI_RANGES,
-	{
-	 BIP_RANGE(5),
-	 BIP_RANGE(2.5),
-	 BIP_RANGE(1),
-	 BIP_RANGE(0.5),
-	 BIP_RANGE(0.25),
-	 BIP_RANGE(0.1),
-	 BIP_RANGE(0.05),
-	 UNI_RANGE(10),
-	 UNI_RANGE(5),
-	 UNI_RANGE(2),
-	 UNI_RANGE(1),
-	 UNI_RANGE(0.5),
-	 UNI_RANGE(0.2),
-	 UNI_RANGE(0.1),
-	 }
+	14, {
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1),
+		BIP_RANGE(0.5),
+		BIP_RANGE(0.25),
+		BIP_RANGE(0.1),
+		BIP_RANGE(0.05),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2),
+		UNI_RANGE(1),
+		UNI_RANGE(0.5),
+		UNI_RANGE(0.2),
+		UNI_RANGE(0.1)
+	}
 };
 EXPORT_SYMBOL_GPL(range_labpc_1200_ai);
 
-/* analog output ranges */
 #define AO_RANGE_IS_UNIPOLAR 0x1
 static const struct comedi_lrange range_labpc_ao = {
-	2,
-	{
-	 BIP_RANGE(5),
-	 UNI_RANGE(10),
-	 }
+	2, {
+		BIP_RANGE(5),
+		UNI_RANGE(10)
+	}
 };
 
 /* functions that do inb/outb and readb/writeb so we can use

commit 74df5760767333eb7e0fe267e1d460c463ee442c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:41:22 2013 -0700

    staging: comedi: ni_labpc: rename some of the private data variables
    
    For aesthetic reasons, rename the 'command*_bits' and 'status*_bits'
    variables in the private data in order to shorten some of the long
    lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 05751467e422..44416fee6a6b 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -445,52 +445,51 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/*  disable timed conversions */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
-	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	devpriv->cmd2 &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
+	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  disable interrupt generation and dma */
-	devpriv->command3_bits = 0;
-	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
+	devpriv->cmd3 = 0;
+	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
 
 	/* set gain and channel */
-	devpriv->command1_bits = 0;
+	devpriv->cmd1 = 0;
 	chan = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
-	devpriv->command1_bits |= thisboard->ai_range_code[range];
+	devpriv->cmd1 |= thisboard->ai_range_code[range];
 	/* munge channel bits for differential/scan disabled mode */
 	if (CR_AREF(insn->chanspec) == AREF_DIFF)
 		chan *= 2;
-	devpriv->command1_bits |= ADC_CHAN_BITS(chan);
-	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
+	devpriv->cmd1 |= ADC_CHAN_BITS(chan);
+	devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
 
-	/* setup command6 register for 1200 boards */
+	/* setup cmd6 register for 1200 boards */
 	if (thisboard->register_layout == labpc_1200_layout) {
 		/*  reference inputs to ground or common? */
 		if (CR_AREF(insn->chanspec) != AREF_GROUND)
-			devpriv->command6_bits |= ADC_COMMON_BIT;
+			devpriv->cmd6 |= ADC_COMMON_BIT;
 		else
-			devpriv->command6_bits &= ~ADC_COMMON_BIT;
+			devpriv->cmd6 &= ~ADC_COMMON_BIT;
 		/* bipolar or unipolar range? */
 		if (thisboard->ai_range_is_unipolar[range])
-			devpriv->command6_bits |= ADC_UNIP_BIT;
+			devpriv->cmd6 |= ADC_UNIP_BIT;
 		else
-			devpriv->command6_bits &= ~ADC_UNIP_BIT;
+			devpriv->cmd6 &= ~ADC_UNIP_BIT;
 		/* don't interrupt on fifo half full */
-		devpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;
+		devpriv->cmd6 &= ~ADC_FHF_INTR_EN_BIT;
 		/* don't enable interrupt on counter a1 terminal count? */
-		devpriv->command6_bits &= ~A1_INTR_EN_BIT;
+		devpriv->cmd6 &= ~A1_INTR_EN_BIT;
 		/* write to register */
-		devpriv->write_byte(devpriv->command6_bits,
-				    dev->iobase + COMMAND6_REG);
+		devpriv->write_byte(devpriv->cmd6, dev->iobase + COMMAND6_REG);
 	}
-	/* setup command4 register */
-	devpriv->command4_bits = 0;
-	devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
+	/* setup cmd4 register */
+	devpriv->cmd4 = 0;
+	devpriv->cmd4 |= EXT_CONVERT_DISABLE_BIT;
 	/* single-ended/differential */
 	if (CR_AREF(insn->chanspec) == AREF_DIFF)
-		devpriv->command4_bits |= ADC_DIFF_BIT;
-	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
+		devpriv->cmd4 |= ADC_DIFF_BIT;
+	devpriv->write_byte(devpriv->cmd4, dev->iobase + COMMAND4_REG);
 
 	/*
 	 * initialize pacer counter output to make sure it doesn't
@@ -939,12 +938,12 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* make sure board is disabled before setting up acquisition */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
-	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	devpriv->cmd2 &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
+	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	devpriv->command3_bits = 0;
-	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
+	devpriv->cmd3 = 0;
+	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
 
 	/*  initialize software conversion count */
 	if (cmd->stop_src == TRIG_COUNT)
@@ -994,40 +993,39 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->current_transfer = xfer;
 	mode = labpc_ai_scan_mode(cmd);
 
-	/*  setup command6 register for 1200 boards */
+	/*  setup cmd6 register for 1200 boards */
 	if (thisboard->register_layout == labpc_1200_layout) {
 		/*  reference inputs to ground or common? */
 		if (aref != AREF_GROUND)
-			devpriv->command6_bits |= ADC_COMMON_BIT;
+			devpriv->cmd6 |= ADC_COMMON_BIT;
 		else
-			devpriv->command6_bits &= ~ADC_COMMON_BIT;
+			devpriv->cmd6 &= ~ADC_COMMON_BIT;
 		/*  bipolar or unipolar range? */
 		if (thisboard->ai_range_is_unipolar[range])
-			devpriv->command6_bits |= ADC_UNIP_BIT;
+			devpriv->cmd6 |= ADC_UNIP_BIT;
 		else
-			devpriv->command6_bits &= ~ADC_UNIP_BIT;
+			devpriv->cmd6 &= ~ADC_UNIP_BIT;
 		/*  interrupt on fifo half full? */
 		if (xfer == fifo_half_full_transfer)
-			devpriv->command6_bits |= ADC_FHF_INTR_EN_BIT;
+			devpriv->cmd6 |= ADC_FHF_INTR_EN_BIT;
 		else
-			devpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;
+			devpriv->cmd6 &= ~ADC_FHF_INTR_EN_BIT;
 		/*  enable interrupt on counter a1 terminal count? */
 		if (cmd->stop_src == TRIG_EXT)
-			devpriv->command6_bits |= A1_INTR_EN_BIT;
+			devpriv->cmd6 |= A1_INTR_EN_BIT;
 		else
-			devpriv->command6_bits &= ~A1_INTR_EN_BIT;
+			devpriv->cmd6 &= ~A1_INTR_EN_BIT;
 		/*  are we scanning up or down through channels? */
 		if (mode == MODE_MULT_CHAN_UP)
-			devpriv->command6_bits |= ADC_SCAN_UP_BIT;
+			devpriv->cmd6 |= ADC_SCAN_UP_BIT;
 		else
-			devpriv->command6_bits &= ~ADC_SCAN_UP_BIT;
+			devpriv->cmd6 &= ~ADC_SCAN_UP_BIT;
 		/*  write to register */
-		devpriv->write_byte(devpriv->command6_bits,
-				    dev->iobase + COMMAND6_REG);
+		devpriv->write_byte(devpriv->cmd6, dev->iobase + COMMAND6_REG);
 	}
 
-	/* setup channel list, etc (command1 register) */
-	devpriv->command1_bits = 0;
+	/* setup channel list, etc (cmd1 register) */
+	devpriv->cmd1 = 0;
 	if (mode == MODE_MULT_CHAN_UP)
 		channel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);
 	else
@@ -1036,18 +1034,17 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if ((mode == MODE_SINGLE_CHAN || mode == MODE_SINGLE_CHAN_INTERVAL) &&
 	    aref == AREF_DIFF)
 		channel *= 2;
-	devpriv->command1_bits |= ADC_CHAN_BITS(channel);
-	devpriv->command1_bits |= thisboard->ai_range_code[range];
-	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
+	devpriv->cmd1 |= ADC_CHAN_BITS(channel);
+	devpriv->cmd1 |= thisboard->ai_range_code[range];
+	devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
 	/* manual says to set scan enable bit on second pass */
 	if (mode == MODE_MULT_CHAN_UP || mode == MODE_MULT_CHAN_DOWN) {
-		devpriv->command1_bits |= ADC_SCAN_EN_BIT;
+		devpriv->cmd1 |= ADC_SCAN_EN_BIT;
 		/* need a brief delay before enabling scan, or scan
 		 * list will get screwed when you switch
 		 * between scan up to scan down mode - dunno why */
 		udelay(1);
-		devpriv->write_byte(devpriv->command1_bits,
-				    dev->iobase + COMMAND1_REG);
+		devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
 	}
 
 	devpriv->write_byte(cmd->chanlist_len,
@@ -1114,50 +1111,50 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		enable_dma(devpriv->dma_chan);
 		release_dma_lock(irq_flags);
 		/*  enable board's dma */
-		devpriv->command3_bits |= DMA_EN_BIT | DMATC_INTR_EN_BIT;
+		devpriv->cmd3 |= DMA_EN_BIT | DMATC_INTR_EN_BIT;
 	} else
-		devpriv->command3_bits &= ~DMA_EN_BIT & ~DMATC_INTR_EN_BIT;
+		devpriv->cmd3 &= ~DMA_EN_BIT & ~DMATC_INTR_EN_BIT;
 #endif
 
 	/*  enable error interrupts */
-	devpriv->command3_bits |= ERR_INTR_EN_BIT;
+	devpriv->cmd3 |= ERR_INTR_EN_BIT;
 	/*  enable fifo not empty interrupt? */
 	if (xfer == fifo_not_empty_transfer)
-		devpriv->command3_bits |= ADC_FNE_INTR_EN_BIT;
+		devpriv->cmd3 |= ADC_FNE_INTR_EN_BIT;
 	else
-		devpriv->command3_bits &= ~ADC_FNE_INTR_EN_BIT;
-	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
+		devpriv->cmd3 &= ~ADC_FNE_INTR_EN_BIT;
+	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
 
-	/*  setup any external triggering/pacing (command4 register) */
-	devpriv->command4_bits = 0;
+	/*  setup any external triggering/pacing (cmd4 register) */
+	devpriv->cmd4 = 0;
 	if (cmd->convert_src != TRIG_EXT)
-		devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
+		devpriv->cmd4 |= EXT_CONVERT_DISABLE_BIT;
 	/* XXX should discard first scan when using interval scanning
 	 * since manual says it is not synced with scan clock */
 	if (labpc_use_continuous_mode(cmd, mode) == 0) {
-		devpriv->command4_bits |= INTERVAL_SCAN_EN_BIT;
+		devpriv->cmd4 |= INTERVAL_SCAN_EN_BIT;
 		if (cmd->scan_begin_src == TRIG_EXT)
-			devpriv->command4_bits |= EXT_SCAN_EN_BIT;
+			devpriv->cmd4 |= EXT_SCAN_EN_BIT;
 	}
 	/*  single-ended/differential */
 	if (aref == AREF_DIFF)
-		devpriv->command4_bits |= ADC_DIFF_BIT;
-	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
+		devpriv->cmd4 |= ADC_DIFF_BIT;
+	devpriv->write_byte(devpriv->cmd4, dev->iobase + COMMAND4_REG);
 
 	/*  startup acquisition */
 
-	/*  command2 reg */
+	/*  cmd2 reg */
 	/*  use 2 cascaded counters for pacing */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->command2_bits |= CASCADE_BIT;
+	devpriv->cmd2 |= CASCADE_BIT;
 	switch (cmd->start_src) {
 	case TRIG_EXT:
-		devpriv->command2_bits |= HWTRIG_BIT;
-		devpriv->command2_bits &= ~PRETRIG_BIT & ~SWTRIG_BIT;
+		devpriv->cmd2 |= HWTRIG_BIT;
+		devpriv->cmd2 &= ~PRETRIG_BIT & ~SWTRIG_BIT;
 		break;
 	case TRIG_NOW:
-		devpriv->command2_bits |= SWTRIG_BIT;
-		devpriv->command2_bits &= ~PRETRIG_BIT & ~HWTRIG_BIT;
+		devpriv->cmd2 |= SWTRIG_BIT;
+		devpriv->cmd2 &= ~PRETRIG_BIT & ~HWTRIG_BIT;
 		break;
 	default:
 		comedi_error(dev, "bug with start_src");
@@ -1167,7 +1164,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	switch (cmd->stop_src) {
 	case TRIG_EXT:
-		devpriv->command2_bits |= HWTRIG_BIT | PRETRIG_BIT;
+		devpriv->cmd2 |= HWTRIG_BIT | PRETRIG_BIT;
 		break;
 	case TRIG_COUNT:
 	case TRIG_NONE:
@@ -1177,7 +1174,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		return -1;
 	}
-	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return 0;
@@ -1189,12 +1186,12 @@ static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
-	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	devpriv->cmd2 &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
+	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	devpriv->command3_bits = 0;
-	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
+	devpriv->cmd3 = 0;
+	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
 
 	return 0;
 }
@@ -1210,7 +1207,7 @@ static void labpc_drain_dma(struct comedi_device *dev)
 	unsigned int max_points, num_points, residue, leftover;
 	int i;
 
-	status = devpriv->status1_bits;
+	status = devpriv->stat1;
 
 	flags = claim_dma_lock();
 	disable_dma(devpriv->dma_chan);
@@ -1277,9 +1274,9 @@ static int labpc_drain_fifo(struct comedi_device *dev)
 	const int timeout = 10000;
 	unsigned int i;
 
-	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
+	devpriv->stat1 = devpriv->read_byte(dev->iobase + STATUS1_REG);
 
-	for (i = 0; (devpriv->status1_bits & DATA_AVAIL_BIT) && i < timeout;
+	for (i = 0; (devpriv->stat1 & DATA_AVAIL_BIT) && i < timeout;
 	     i++) {
 		/*  quit if we have all the data we want */
 		if (async->cmd.stop_src == TRIG_COUNT) {
@@ -1291,8 +1288,7 @@ static int labpc_drain_fifo(struct comedi_device *dev)
 		msb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
 		data = (msb << 8) | lsb;
 		cfc_write_to_buffer(dev->read_subdev, data);
-		devpriv->status1_bits =
-		    devpriv->read_byte(dev->iobase + STATUS1_REG);
+		devpriv->stat1 = devpriv->read_byte(dev->iobase + STATUS1_REG);
 	}
 	if (i == timeout) {
 		comedi_error(dev, "ai timeout, fifo never empties");
@@ -1337,19 +1333,18 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	async->events = 0;
 
 	/* read board status */
-	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
+	devpriv->stat1 = devpriv->read_byte(dev->iobase + STATUS1_REG);
 	if (thisboard->register_layout == labpc_1200_layout)
-		devpriv->status2_bits =
-		    devpriv->read_byte(dev->iobase + STATUS2_REG);
+		devpriv->stat2 = devpriv->read_byte(dev->iobase + STATUS2_REG);
 
-	if ((devpriv->status1_bits & (DMATC_BIT | TIMER_BIT | OVERFLOW_BIT |
-				      OVERRUN_BIT | DATA_AVAIL_BIT)) == 0
-	    && (devpriv->status2_bits & A1_TC_BIT) == 0
-	    && (devpriv->status2_bits & FNHF_BIT)) {
+	if ((devpriv->stat1 & (DMATC_BIT | TIMER_BIT | OVERFLOW_BIT |
+			       OVERRUN_BIT | DATA_AVAIL_BIT)) == 0
+	    && (devpriv->stat2 & A1_TC_BIT) == 0
+	    && (devpriv->stat2 & FNHF_BIT)) {
 		return IRQ_NONE;
 	}
 
-	if (devpriv->status1_bits & OVERRUN_BIT) {
+	if (devpriv->stat1 & OVERRUN_BIT) {
 		/* clear error interrupt */
 		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
@@ -1364,22 +1359,22 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 		 * if a dma terminal count of external stop trigger
 		 * has occurred
 		 */
-		if (devpriv->status1_bits & DMATC_BIT ||
+		if (devpriv->stat1 & DMATC_BIT ||
 		    (thisboard->register_layout == labpc_1200_layout
-		     && devpriv->status2_bits & A1_TC_BIT)) {
+		     && devpriv->stat2 & A1_TC_BIT)) {
 			handle_isa_dma(dev);
 		}
 	} else
 #endif
 		labpc_drain_fifo(dev);
 
-	if (devpriv->status1_bits & TIMER_BIT) {
+	if (devpriv->stat1 & TIMER_BIT) {
 		comedi_error(dev, "handled timer interrupt?");
 		/*  clear it */
 		devpriv->write_byte(0x1, dev->iobase + TIMER_CLEAR_REG);
 	}
 
-	if (devpriv->status1_bits & OVERFLOW_BIT) {
+	if (devpriv->stat1 & OVERFLOW_BIT) {
 		/*  clear error interrupt */
 		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
@@ -1389,7 +1384,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	}
 	/*  handle external stop trigger */
 	if (cmd->stop_src == TRIG_EXT) {
-		if (devpriv->status2_bits & A1_TC_BIT) {
+		if (devpriv->stat2 & A1_TC_BIT) {
 			labpc_drain_dregs(dev);
 			labpc_cancel(dev, s);
 			async->events |= COMEDI_CB_EOA;
@@ -1424,20 +1419,19 @@ static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* note: hardware bug in daqcard-1200 means pacing cannot
 	 * be independently enabled/disabled for its the two channels */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->command2_bits &= ~DAC_PACED_BIT(channel);
-	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	devpriv->cmd2 &= ~DAC_PACED_BIT(channel);
+	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* set range */
 	if (thisboard->register_layout == labpc_1200_layout) {
 		range = CR_RANGE(insn->chanspec);
 		if (range & AO_RANGE_IS_UNIPOLAR)
-			devpriv->command6_bits |= DAC_UNIP_BIT(channel);
+			devpriv->cmd6 |= DAC_UNIP_BIT(channel);
 		else
-			devpriv->command6_bits &= ~DAC_UNIP_BIT(channel);
+			devpriv->cmd6 &= ~DAC_UNIP_BIT(channel);
 		/*  write to register */
-		devpriv->write_byte(devpriv->command6_bits,
-				    dev->iobase + COMMAND6_REG);
+		devpriv->write_byte(devpriv->cmd6, dev->iobase + COMMAND6_REG);
 	}
 	/* send data */
 	lsb = data[0] & 0xff;
@@ -1482,19 +1476,18 @@ static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
 
 	for (i = 1; i <= value_width; i++) {
 		/*  clear serial clock */
-		devpriv->command5_bits &= ~SCLOCK_BIT;
+		devpriv->cmd5 &= ~SCLOCK_BIT;
 		/*  send bits most significant bit first */
 		if (value & (1 << (value_width - i)))
-			devpriv->command5_bits |= SDATA_BIT;
+			devpriv->cmd5 |= SDATA_BIT;
 		else
-			devpriv->command5_bits &= ~SDATA_BIT;
+			devpriv->cmd5 &= ~SDATA_BIT;
 		udelay(1);
-		devpriv->write_byte(devpriv->command5_bits,
-				    dev->iobase + COMMAND5_REG);
+		devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 		/*  set clock to load bit */
-		devpriv->command5_bits |= SCLOCK_BIT;
+		devpriv->cmd5 |= SCLOCK_BIT;
 		udelay(1);
-		devpriv->write_byte(devpriv->command5_bits,
+		devpriv->write_byte(devpriv->cmd5,
 				    dev->iobase + COMMAND5_REG);
 	}
 }
@@ -1509,20 +1502,17 @@ static unsigned int labpc_serial_in(struct comedi_device *dev)
 
 	for (i = 1; i <= value_width; i++) {
 		/*  set serial clock */
-		devpriv->command5_bits |= SCLOCK_BIT;
+		devpriv->cmd5 |= SCLOCK_BIT;
 		udelay(1);
-		devpriv->write_byte(devpriv->command5_bits,
-				    dev->iobase + COMMAND5_REG);
+		devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 		/*  clear clock bit */
-		devpriv->command5_bits &= ~SCLOCK_BIT;
+		devpriv->cmd5 &= ~SCLOCK_BIT;
 		udelay(1);
-		devpriv->write_byte(devpriv->command5_bits,
-				    dev->iobase + COMMAND5_REG);
+		devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 		/*  read bits most significant bit first */
 		udelay(1);
-		devpriv->status2_bits =
-		    devpriv->read_byte(dev->iobase + STATUS2_REG);
-		if (devpriv->status2_bits & EEPROM_OUT_BIT)
+		devpriv->stat2 = devpriv->read_byte(dev->iobase + STATUS2_REG);
+		if (devpriv->stat2 & EEPROM_OUT_BIT)
 			value |= 1 << (value_width - i);
 	}
 
@@ -1540,12 +1530,12 @@ static unsigned int labpc_eeprom_read(struct comedi_device *dev,
 	const int write_length = 8;
 
 	/*  enable read/write to eeprom */
-	devpriv->command5_bits &= ~EEPROM_EN_BIT;
+	devpriv->cmd5 &= ~EEPROM_EN_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
-	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->cmd5 |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 
 	/*  send read instruction */
 	labpc_serial_out(dev, read_instruction, write_length);
@@ -1555,9 +1545,9 @@ static unsigned int labpc_eeprom_read(struct comedi_device *dev,
 	value = labpc_serial_in(dev);
 
 	/*  disable read/write to eeprom */
-	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	devpriv->cmd5 &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 
 	return value;
 }
@@ -1570,12 +1560,12 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
 	const int write_length = 8;	/*  8 bit write lengths to eeprom */
 
 	/*  enable read/write to eeprom */
-	devpriv->command5_bits &= ~EEPROM_EN_BIT;
+	devpriv->cmd5 &= ~EEPROM_EN_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
-	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->cmd5 |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 
 	/*  send read status instruction */
 	labpc_serial_out(dev, read_status_instruction, write_length);
@@ -1583,9 +1573,9 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
 	value = labpc_serial_in(dev);
 
 	/*  disable read/write to eeprom */
-	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	devpriv->cmd5 &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 
 	return value;
 }
@@ -1615,36 +1605,36 @@ static int labpc_eeprom_write(struct comedi_device *dev,
 	devpriv->eeprom_data[address] = value;
 
 	/*  enable read/write to eeprom */
-	devpriv->command5_bits &= ~EEPROM_EN_BIT;
+	devpriv->cmd5 &= ~EEPROM_EN_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
-	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->cmd5 |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 
 	/*  send write_enable instruction */
 	labpc_serial_out(dev, write_enable_instruction, write_length);
-	devpriv->command5_bits &= ~EEPROM_EN_BIT;
+	devpriv->cmd5 &= ~EEPROM_EN_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 
 	/*  send write instruction */
-	devpriv->command5_bits |= EEPROM_EN_BIT;
+	devpriv->cmd5 |= EEPROM_EN_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 	labpc_serial_out(dev, write_instruction, write_length);
 	/*  send 8 bit address to write to */
 	labpc_serial_out(dev, address, write_length);
 	/*  write value */
 	labpc_serial_out(dev, value, write_length);
-	devpriv->command5_bits &= ~EEPROM_EN_BIT;
+	devpriv->cmd5 &= ~EEPROM_EN_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 
 	/*  disable read/write to eeprom */
-	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	devpriv->cmd5 &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 
 	return 0;
 }
@@ -1660,10 +1650,10 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	devpriv->caldac[channel] = value;
 
 	/*  clear caldac load bit and make sure we don't write to eeprom */
-	devpriv->command5_bits &=
+	devpriv->cmd5 &=
 	    ~CALDAC_LOAD_BIT & ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 
 	/*  write 4 bit channel */
 	labpc_serial_out(dev, channel, 4);
@@ -1671,12 +1661,12 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	labpc_serial_out(dev, value, 8);
 
 	/*  set and clear caldac bit to load caldac value */
-	devpriv->command5_bits |= CALDAC_LOAD_BIT;
+	devpriv->cmd5 |= CALDAC_LOAD_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
-	devpriv->command5_bits &= ~CALDAC_LOAD_BIT;
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+	devpriv->cmd5 &= ~CALDAC_LOAD_BIT;
 	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
 }
 
 static int labpc_calib_write_insn(struct comedi_device *dev,
@@ -1769,15 +1759,13 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		devpriv->write_byte = labpc_outb;
 	}
 	/* initialize board's command registers */
-	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
-	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
-	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
+	devpriv->write_byte(devpriv->cmd1, dev->iobase + COMMAND1_REG);
+	devpriv->write_byte(devpriv->cmd2, dev->iobase + COMMAND2_REG);
+	devpriv->write_byte(devpriv->cmd3, dev->iobase + COMMAND3_REG);
+	devpriv->write_byte(devpriv->cmd4, dev->iobase + COMMAND4_REG);
 	if (thisboard->register_layout == labpc_1200_layout) {
-		devpriv->write_byte(devpriv->command5_bits,
-				    dev->iobase + COMMAND5_REG);
-		devpriv->write_byte(devpriv->command6_bits,
-				    dev->iobase + COMMAND6_REG);
+		devpriv->write_byte(devpriv->cmd5, dev->iobase + COMMAND5_REG);
+		devpriv->write_byte(devpriv->cmd6, dev->iobase + COMMAND6_REG);
 	}
 
 	/* grab our IRQ */

commit f2c447caf64fb13b111c151c92eae8115933539e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:40:36 2013 -0700

    staging: comedi: ni_labpc: cleanup the boardinfo
    
    For aesthetic reasons, add some whitespace to the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index d2afcaead523..05751467e422 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -373,50 +373,48 @@ static inline void labpc_writeb(unsigned int byte, unsigned long address)
 
 static const struct labpc_boardinfo labpc_boards[] = {
 	{
-	 .name = "lab-pc-1200",
-	 .ai_speed = 10000,
-	 .bustype = isa_bustype,
-	 .register_layout = labpc_1200_layout,
-	 .has_ao = 1,
-	 .ai_range_table = &range_labpc_1200_ai,
-	 .ai_range_code = labpc_1200_ai_gain_bits,
-	 .ai_range_is_unipolar = labpc_1200_is_unipolar,
-	 .ai_scan_up = 1,
-	 },
-	{
-	 .name = "lab-pc-1200ai",
-	 .ai_speed = 10000,
-	 .bustype = isa_bustype,
-	 .register_layout = labpc_1200_layout,
-	 .ai_range_table = &range_labpc_1200_ai,
-	 .ai_range_code = labpc_1200_ai_gain_bits,
-	 .ai_range_is_unipolar = labpc_1200_is_unipolar,
-	 .ai_scan_up = 1,
-	 },
-	{
-	 .name = "lab-pc+",
-	 .ai_speed = 12000,
-	 .bustype = isa_bustype,
-	 .register_layout = labpc_plus_layout,
-	 .has_ao = 1,
-	 .ai_range_table = &range_labpc_plus_ai,
-	 .ai_range_code = labpc_plus_ai_gain_bits,
-	 .ai_range_is_unipolar = labpc_plus_is_unipolar,
-	 },
+		.name			= "lab-pc-1200",
+		.ai_speed		= 10000,
+		.bustype		= isa_bustype,
+		.register_layout	= labpc_1200_layout,
+		.has_ao			= 1,
+		.ai_range_table		= &range_labpc_1200_ai,
+		.ai_range_code		= labpc_1200_ai_gain_bits,
+		.ai_range_is_unipolar	= labpc_1200_is_unipolar,
+		.ai_scan_up		= 1,
+	}, {
+		.name			= "lab-pc-1200ai",
+		.ai_speed		= 10000,
+		.bustype		= isa_bustype,
+		.register_layout	= labpc_1200_layout,
+		.ai_range_table		= &range_labpc_1200_ai,
+		.ai_range_code		= labpc_1200_ai_gain_bits,
+		.ai_range_is_unipolar	= labpc_1200_is_unipolar,
+		.ai_scan_up		= 1,
+	}, {
+		.name			= "lab-pc+",
+		.ai_speed		= 12000,
+		.bustype		= isa_bustype,
+		.register_layout	= labpc_plus_layout,
+		.has_ao			= 1,
+		.ai_range_table		= &range_labpc_plus_ai,
+		.ai_range_code		= labpc_plus_ai_gain_bits,
+		.ai_range_is_unipolar	= labpc_plus_is_unipolar,
+	},
 #ifdef CONFIG_COMEDI_PCI_DRIVERS
 	{
-	 .name = "pci-1200",
-	 .device_id = 0x161,
-	 .ai_speed = 10000,
-	 .bustype = pci_bustype,
-	 .register_layout = labpc_1200_layout,
-	 .has_ao = 1,
-	 .ai_range_table = &range_labpc_1200_ai,
-	 .ai_range_code = labpc_1200_ai_gain_bits,
-	 .ai_range_is_unipolar = labpc_1200_is_unipolar,
-	 .ai_scan_up = 1,
-	 .memory_mapped_io = 1,
-	 },
+		.name			= "pci-1200",
+		.device_id		= 0x161,
+		.ai_speed		= 10000,
+		.bustype		= pci_bustype,
+		.register_layout	= labpc_1200_layout,
+		.has_ao			= 1,
+		.ai_range_table		= &range_labpc_1200_ai,
+		.ai_range_code		= labpc_1200_ai_gain_bits,
+		.ai_range_is_unipolar	= labpc_1200_is_unipolar,
+		.ai_scan_up		= 1,
+		.memory_mapped_io	= 1,
+	},
 #endif
 };
 

commit d23370578a632f61ca2a6ef5656910cebc3d0850
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:40:13 2013 -0700

    staging: comedi: ni_labpc: remove "dummy" pci boardinfo entry
    
    This driver uses the comedi auto config mechanism to attach to PCI
    boards. The "dummy" entry in the boardinfo table is not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 2ae97c5228d0..d2afcaead523 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -417,11 +417,6 @@ static const struct labpc_boardinfo labpc_boards[] = {
 	 .ai_scan_up = 1,
 	 .memory_mapped_io = 1,
 	 },
-/* dummy entry so pci board works when comedi_config is passed driver name */
-	{
-	 .name = DRV_NAME,
-	 .bustype = pci_bustype,
-	 },
 #endif
 };
 

commit 50b9dd9414fefdece46f568edb31b5ae7473dbe9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:39:50 2013 -0700

    staging: comedi: ni_labpc: remove boardinfo data that is set to '0'
    
    It's not necessary to initialize the boardinfo data that is set
    to '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 6f9e2baff092..2ae97c5228d0 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -382,19 +382,16 @@ static const struct labpc_boardinfo labpc_boards[] = {
 	 .ai_range_code = labpc_1200_ai_gain_bits,
 	 .ai_range_is_unipolar = labpc_1200_is_unipolar,
 	 .ai_scan_up = 1,
-	 .memory_mapped_io = 0,
 	 },
 	{
 	 .name = "lab-pc-1200ai",
 	 .ai_speed = 10000,
 	 .bustype = isa_bustype,
 	 .register_layout = labpc_1200_layout,
-	 .has_ao = 0,
 	 .ai_range_table = &range_labpc_1200_ai,
 	 .ai_range_code = labpc_1200_ai_gain_bits,
 	 .ai_range_is_unipolar = labpc_1200_is_unipolar,
 	 .ai_scan_up = 1,
-	 .memory_mapped_io = 0,
 	 },
 	{
 	 .name = "lab-pc+",
@@ -405,8 +402,6 @@ static const struct labpc_boardinfo labpc_boards[] = {
 	 .ai_range_table = &range_labpc_plus_ai,
 	 .ai_range_code = labpc_plus_ai_gain_bits,
 	 .ai_range_is_unipolar = labpc_plus_is_unipolar,
-	 .ai_scan_up = 0,
-	 .memory_mapped_io = 0,
 	 },
 #ifdef CONFIG_COMEDI_PCI_DRIVERS
 	{

commit af81f093d026b4f61c89175a9b695f0488f13f1f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:38:36 2013 -0700

    staging: comedi: ni_labpc: remove forward declarations 4
    
    Move the analog input support functions to remove the need for the
    remaining forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index a33884ff005d..6f9e2baff092 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -215,12 +215,6 @@ enum scan_mode {
 	MODE_MULT_CHAN_DOWN,
 };
 
-static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
-			     enum scan_mode scan_mode);
-#ifdef CONFIG_ISA_DMA_API
-static unsigned int labpc_suggest_transfer_size(const struct comedi_cmd *cmd);
-#endif
-
 /* analog input ranges */
 #define NUM_LABPC_PLUS_AI_RANGES 16
 /* indicates unipolar ranges */
@@ -441,20 +435,6 @@ static const int dma_buffer_size = 0xff00;
 /* 2 bytes per sample */
 static const int sample_size = 2;
 
-static inline int labpc_counter_load(struct comedi_device *dev,
-				     unsigned long base_address,
-				     unsigned int counter_number,
-				     unsigned int count, unsigned int mode)
-{
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
-
-	if (thisboard->memory_mapped_io)
-		return i8254_mm_load((void __iomem *)base_address, 0,
-				     counter_number, count, mode);
-	else
-		return i8254_load(base_address, 0, counter_number, count, mode);
-}
-
 static void labpc_clear_adc_fifo(const struct comedi_device *dev)
 {
 	struct labpc_private *devpriv = dev->private;
@@ -464,115 +444,121 @@ static void labpc_clear_adc_fifo(const struct comedi_device *dev)
 	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
 }
 
-static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+			  struct comedi_insn *insn, unsigned int *data)
 {
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
+	int i, n;
+	int chan, range;
+	int lsb, msb;
+	int timeout = 1000;
 	unsigned long flags;
 
+	/*  disable timed conversions */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
+	/*  disable interrupt generation and dma */
 	devpriv->command3_bits = 0;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
-	return 0;
-}
-
-static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)
-{
-	if (cmd->chanlist_len == 1)
-		return MODE_SINGLE_CHAN;
-
-	/* chanlist may be NULL during cmdtest. */
-	if (cmd->chanlist == NULL)
-		return MODE_MULT_CHAN_UP;
-
-	if (CR_CHAN(cmd->chanlist[0]) == CR_CHAN(cmd->chanlist[1]))
-		return MODE_SINGLE_CHAN_INTERVAL;
-
-	if (CR_CHAN(cmd->chanlist[0]) < CR_CHAN(cmd->chanlist[1]))
-		return MODE_MULT_CHAN_UP;
-
-	if (CR_CHAN(cmd->chanlist[0]) > CR_CHAN(cmd->chanlist[1]))
-		return MODE_MULT_CHAN_DOWN;
+	/* set gain and channel */
+	devpriv->command1_bits = 0;
+	chan = CR_CHAN(insn->chanspec);
+	range = CR_RANGE(insn->chanspec);
+	devpriv->command1_bits |= thisboard->ai_range_code[range];
+	/* munge channel bits for differential/scan disabled mode */
+	if (CR_AREF(insn->chanspec) == AREF_DIFF)
+		chan *= 2;
+	devpriv->command1_bits |= ADC_CHAN_BITS(chan);
+	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
 
-	pr_err("ni_labpc: bug! cannot determine AI scan mode\n");
-	return 0;
-}
+	/* setup command6 register for 1200 boards */
+	if (thisboard->register_layout == labpc_1200_layout) {
+		/*  reference inputs to ground or common? */
+		if (CR_AREF(insn->chanspec) != AREF_GROUND)
+			devpriv->command6_bits |= ADC_COMMON_BIT;
+		else
+			devpriv->command6_bits &= ~ADC_COMMON_BIT;
+		/* bipolar or unipolar range? */
+		if (thisboard->ai_range_is_unipolar[range])
+			devpriv->command6_bits |= ADC_UNIP_BIT;
+		else
+			devpriv->command6_bits &= ~ADC_UNIP_BIT;
+		/* don't interrupt on fifo half full */
+		devpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;
+		/* don't enable interrupt on counter a1 terminal count? */
+		devpriv->command6_bits &= ~A1_INTR_EN_BIT;
+		/* write to register */
+		devpriv->write_byte(devpriv->command6_bits,
+				    dev->iobase + COMMAND6_REG);
+	}
+	/* setup command4 register */
+	devpriv->command4_bits = 0;
+	devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
+	/* single-ended/differential */
+	if (CR_AREF(insn->chanspec) == AREF_DIFF)
+		devpriv->command4_bits |= ADC_DIFF_BIT;
+	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
 
-static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
-				     const struct comedi_cmd *cmd,
-				     enum scan_mode mode)
-{
-	int channel, range, aref, i;
+	/*
+	 * initialize pacer counter output to make sure it doesn't
+	 * cause any problems
+	 */
+	devpriv->write_byte(INIT_A0_BITS, dev->iobase + COUNTER_A_CONTROL_REG);
 
-	if (cmd->chanlist == NULL)
-		return 0;
+	labpc_clear_adc_fifo(dev);
 
-	if (mode == MODE_SINGLE_CHAN)
-		return 0;
+	for (n = 0; n < insn->n; n++) {
+		/* trigger conversion */
+		devpriv->write_byte(0x1, dev->iobase + ADC_CONVERT_REG);
 
-	if (mode == MODE_SINGLE_CHAN_INTERVAL) {
-		if (cmd->chanlist_len > 0xff) {
-			comedi_error(dev,
-				     "ni_labpc: chanlist too long for single channel interval mode\n");
-			return 1;
+		for (i = 0; i < timeout; i++) {
+			if (devpriv->read_byte(dev->iobase +
+					       STATUS1_REG) & DATA_AVAIL_BIT)
+				break;
+			udelay(1);
 		}
+		if (i == timeout) {
+			comedi_error(dev, "timeout");
+			return -ETIME;
+		}
+		lsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+		msb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+		data[n] = (msb << 8) | lsb;
 	}
 
-	channel = CR_CHAN(cmd->chanlist[0]);
-	range = CR_RANGE(cmd->chanlist[0]);
-	aref = CR_AREF(cmd->chanlist[0]);
+	return n;
+}
 
-	for (i = 0; i < cmd->chanlist_len; i++) {
+#ifdef CONFIG_ISA_DMA_API
+/* utility function that suggests a dma transfer size in bytes */
+static unsigned int labpc_suggest_transfer_size(const struct comedi_cmd *cmd)
+{
+	unsigned int size;
+	unsigned int freq;
 
-		switch (mode) {
-		case MODE_SINGLE_CHAN_INTERVAL:
-			if (CR_CHAN(cmd->chanlist[i]) != channel) {
-				comedi_error(dev,
-					     "channel scanning order specified in chanlist is not supported by hardware.\n");
-				return 1;
-			}
-			break;
-		case MODE_MULT_CHAN_UP:
-			if (CR_CHAN(cmd->chanlist[i]) != i) {
-				comedi_error(dev,
-					     "channel scanning order specified in chanlist is not supported by hardware.\n");
-				return 1;
-			}
-			break;
-		case MODE_MULT_CHAN_DOWN:
-			if (CR_CHAN(cmd->chanlist[i]) !=
-			    cmd->chanlist_len - i - 1) {
-				comedi_error(dev,
-					     "channel scanning order specified in chanlist is not supported by hardware.\n");
-				return 1;
-			}
-			break;
-		default:
-			dev_err(dev->class_dev,
-				"ni_labpc: bug! in chanlist check\n");
-			return 1;
-			break;
-		}
+	if (cmd->convert_src == TRIG_TIMER)
+		freq = 1000000000 / cmd->convert_arg;
+	/* return some default value */
+	else
+		freq = 0xffffffff;
 
-		if (CR_RANGE(cmd->chanlist[i]) != range) {
-			comedi_error(dev,
-				     "entries in chanlist must all have the same range\n");
-			return 1;
-		}
+	/* make buffer fill in no more than 1/3 second */
+	size = (freq / 3) * sample_size;
 
-		if (CR_AREF(cmd->chanlist[i]) != aref) {
-			comedi_error(dev,
-				     "entries in chanlist must all have the same reference\n");
-			return 1;
-		}
-	}
+	/* set a minimum and maximum size allowed */
+	if (size > dma_buffer_size)
+		size = dma_buffer_size - dma_buffer_size % sample_size;
+	else if (size < sample_size)
+		size = sample_size;
 
-	return 0;
+	return size;
 }
+#endif
 
 static int labpc_use_continuous_mode(const struct comedi_cmd *cmd,
 				     enum scan_mode mode)
@@ -625,16 +611,206 @@ static unsigned int labpc_ai_scan_period(const struct comedi_cmd *cmd,
 	return cmd->scan_begin_arg;
 }
 
-static void labpc_set_ai_scan_period(struct comedi_cmd *cmd,
-				     enum scan_mode mode, unsigned int ns)
-{
-	if (cmd->scan_begin_src != TRIG_TIMER)
-		return;
+static void labpc_set_ai_scan_period(struct comedi_cmd *cmd,
+				     enum scan_mode mode, unsigned int ns)
+{
+	if (cmd->scan_begin_src != TRIG_TIMER)
+		return;
+
+	if (mode == MODE_SINGLE_CHAN && cmd->convert_src == TRIG_TIMER)
+		return;
+
+	cmd->scan_begin_arg = ns;
+}
+
+/* figures out what counter values to use based on command */
+static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
+			     enum scan_mode mode)
+{
+	struct labpc_private *devpriv = dev->private;
+	/* max value for 16 bit counter in mode 2 */
+	const int max_counter_value = 0x10000;
+	/* min value for 16 bit counter in mode 2 */
+	const int min_counter_value = 2;
+	unsigned int base_period;
+	unsigned int scan_period;
+	unsigned int convert_period;
+
+	/*
+	 * if both convert and scan triggers are TRIG_TIMER, then they
+	 * both rely on counter b0
+	 */
+	convert_period = labpc_ai_convert_period(cmd, mode);
+	scan_period = labpc_ai_scan_period(cmd, mode);
+	if (convert_period && scan_period) {
+		/*
+		 * pick the lowest b0 divisor value we can (for maximum input
+		 * clock speed on convert and scan counters)
+		 */
+		devpriv->divisor_b0 = (scan_period - 1) /
+		    (LABPC_TIMER_BASE * max_counter_value) + 1;
+		if (devpriv->divisor_b0 < min_counter_value)
+			devpriv->divisor_b0 = min_counter_value;
+		if (devpriv->divisor_b0 > max_counter_value)
+			devpriv->divisor_b0 = max_counter_value;
+
+		base_period = LABPC_TIMER_BASE * devpriv->divisor_b0;
+
+		/*  set a0 for conversion frequency and b1 for scan frequency */
+		switch (cmd->flags & TRIG_ROUND_MASK) {
+		default:
+		case TRIG_ROUND_NEAREST:
+			devpriv->divisor_a0 =
+			    (convert_period + (base_period / 2)) / base_period;
+			devpriv->divisor_b1 =
+			    (scan_period + (base_period / 2)) / base_period;
+			break;
+		case TRIG_ROUND_UP:
+			devpriv->divisor_a0 =
+			    (convert_period + (base_period - 1)) / base_period;
+			devpriv->divisor_b1 =
+			    (scan_period + (base_period - 1)) / base_period;
+			break;
+		case TRIG_ROUND_DOWN:
+			devpriv->divisor_a0 = convert_period / base_period;
+			devpriv->divisor_b1 = scan_period / base_period;
+			break;
+		}
+		/*  make sure a0 and b1 values are acceptable */
+		if (devpriv->divisor_a0 < min_counter_value)
+			devpriv->divisor_a0 = min_counter_value;
+		if (devpriv->divisor_a0 > max_counter_value)
+			devpriv->divisor_a0 = max_counter_value;
+		if (devpriv->divisor_b1 < min_counter_value)
+			devpriv->divisor_b1 = min_counter_value;
+		if (devpriv->divisor_b1 > max_counter_value)
+			devpriv->divisor_b1 = max_counter_value;
+		/*  write corrected timings to command */
+		labpc_set_ai_convert_period(cmd, mode,
+					    base_period * devpriv->divisor_a0);
+		labpc_set_ai_scan_period(cmd, mode,
+					 base_period * devpriv->divisor_b1);
+		/*
+		 * if only one TRIG_TIMER is used, we can employ the generic
+		 * cascaded timing functions
+		 */
+	} else if (scan_period) {
+		/*
+		 * calculate cascaded counter values
+		 * that give desired scan timing
+		 */
+		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
+					       &(devpriv->divisor_b1),
+					       &(devpriv->divisor_b0),
+					       &scan_period,
+					       cmd->flags & TRIG_ROUND_MASK);
+		labpc_set_ai_scan_period(cmd, mode, scan_period);
+	} else if (convert_period) {
+		/*
+		 * calculate cascaded counter values
+		 * that give desired conversion timing
+		 */
+		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
+					       &(devpriv->divisor_a0),
+					       &(devpriv->divisor_b0),
+					       &convert_period,
+					       cmd->flags & TRIG_ROUND_MASK);
+		labpc_set_ai_convert_period(cmd, mode, convert_period);
+	}
+}
+
+static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)
+{
+	if (cmd->chanlist_len == 1)
+		return MODE_SINGLE_CHAN;
+
+	/* chanlist may be NULL during cmdtest. */
+	if (cmd->chanlist == NULL)
+		return MODE_MULT_CHAN_UP;
+
+	if (CR_CHAN(cmd->chanlist[0]) == CR_CHAN(cmd->chanlist[1]))
+		return MODE_SINGLE_CHAN_INTERVAL;
+
+	if (CR_CHAN(cmd->chanlist[0]) < CR_CHAN(cmd->chanlist[1]))
+		return MODE_MULT_CHAN_UP;
+
+	if (CR_CHAN(cmd->chanlist[0]) > CR_CHAN(cmd->chanlist[1]))
+		return MODE_MULT_CHAN_DOWN;
+
+	pr_err("ni_labpc: bug! cannot determine AI scan mode\n");
+	return 0;
+}
+
+static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
+				     const struct comedi_cmd *cmd,
+				     enum scan_mode mode)
+{
+	int channel, range, aref, i;
+
+	if (cmd->chanlist == NULL)
+		return 0;
+
+	if (mode == MODE_SINGLE_CHAN)
+		return 0;
+
+	if (mode == MODE_SINGLE_CHAN_INTERVAL) {
+		if (cmd->chanlist_len > 0xff) {
+			comedi_error(dev,
+				     "ni_labpc: chanlist too long for single channel interval mode\n");
+			return 1;
+		}
+	}
+
+	channel = CR_CHAN(cmd->chanlist[0]);
+	range = CR_RANGE(cmd->chanlist[0]);
+	aref = CR_AREF(cmd->chanlist[0]);
+
+	for (i = 0; i < cmd->chanlist_len; i++) {
+
+		switch (mode) {
+		case MODE_SINGLE_CHAN_INTERVAL:
+			if (CR_CHAN(cmd->chanlist[i]) != channel) {
+				comedi_error(dev,
+					     "channel scanning order specified in chanlist is not supported by hardware.\n");
+				return 1;
+			}
+			break;
+		case MODE_MULT_CHAN_UP:
+			if (CR_CHAN(cmd->chanlist[i]) != i) {
+				comedi_error(dev,
+					     "channel scanning order specified in chanlist is not supported by hardware.\n");
+				return 1;
+			}
+			break;
+		case MODE_MULT_CHAN_DOWN:
+			if (CR_CHAN(cmd->chanlist[i]) !=
+			    cmd->chanlist_len - i - 1) {
+				comedi_error(dev,
+					     "channel scanning order specified in chanlist is not supported by hardware.\n");
+				return 1;
+			}
+			break;
+		default:
+			dev_err(dev->class_dev,
+				"ni_labpc: bug! in chanlist check\n");
+			return 1;
+			break;
+		}
+
+		if (CR_RANGE(cmd->chanlist[i]) != range) {
+			comedi_error(dev,
+				     "entries in chanlist must all have the same range\n");
+			return 1;
+		}
 
-	if (mode == MODE_SINGLE_CHAN && cmd->convert_src == TRIG_TIMER)
-		return;
+		if (CR_AREF(cmd->chanlist[i]) != aref) {
+			comedi_error(dev,
+				     "entries in chanlist must all have the same reference\n");
+			return 1;
+		}
+	}
 
-	cmd->scan_begin_arg = ns;
+	return 0;
 }
 
 static int labpc_ai_cmdtest(struct comedi_device *dev,
@@ -736,6 +912,20 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
+static inline int labpc_counter_load(struct comedi_device *dev,
+				     unsigned long base_address,
+				     unsigned int counter_number,
+				     unsigned int count, unsigned int mode)
+{
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+
+	if (thisboard->memory_mapped_io)
+		return i8254_mm_load((void __iomem *)base_address, 0,
+				     counter_number, count, mode);
+	else
+		return i8254_load(base_address, 0, counter_number, count, mode);
+}
+
 static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct labpc_boardinfo *thisboard = comedi_board(dev);
@@ -1005,216 +1195,20 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data)
+static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
-	int i, n;
-	int chan, range;
-	int lsb, msb;
-	int timeout = 1000;
 	unsigned long flags;
 
-	/*  disable timed conversions */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  disable interrupt generation and dma */
 	devpriv->command3_bits = 0;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
-	/* set gain and channel */
-	devpriv->command1_bits = 0;
-	chan = CR_CHAN(insn->chanspec);
-	range = CR_RANGE(insn->chanspec);
-	devpriv->command1_bits |= thisboard->ai_range_code[range];
-	/* munge channel bits for differential/scan disabled mode */
-	if (CR_AREF(insn->chanspec) == AREF_DIFF)
-		chan *= 2;
-	devpriv->command1_bits |= ADC_CHAN_BITS(chan);
-	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
-
-	/* setup command6 register for 1200 boards */
-	if (thisboard->register_layout == labpc_1200_layout) {
-		/*  reference inputs to ground or common? */
-		if (CR_AREF(insn->chanspec) != AREF_GROUND)
-			devpriv->command6_bits |= ADC_COMMON_BIT;
-		else
-			devpriv->command6_bits &= ~ADC_COMMON_BIT;
-		/* bipolar or unipolar range? */
-		if (thisboard->ai_range_is_unipolar[range])
-			devpriv->command6_bits |= ADC_UNIP_BIT;
-		else
-			devpriv->command6_bits &= ~ADC_UNIP_BIT;
-		/* don't interrupt on fifo half full */
-		devpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;
-		/* don't enable interrupt on counter a1 terminal count? */
-		devpriv->command6_bits &= ~A1_INTR_EN_BIT;
-		/* write to register */
-		devpriv->write_byte(devpriv->command6_bits,
-				    dev->iobase + COMMAND6_REG);
-	}
-	/* setup command4 register */
-	devpriv->command4_bits = 0;
-	devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
-	/* single-ended/differential */
-	if (CR_AREF(insn->chanspec) == AREF_DIFF)
-		devpriv->command4_bits |= ADC_DIFF_BIT;
-	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
-
-	/*
-	 * initialize pacer counter output to make sure it doesn't
-	 * cause any problems
-	 */
-	devpriv->write_byte(INIT_A0_BITS, dev->iobase + COUNTER_A_CONTROL_REG);
-
-	labpc_clear_adc_fifo(dev);
-
-	for (n = 0; n < insn->n; n++) {
-		/* trigger conversion */
-		devpriv->write_byte(0x1, dev->iobase + ADC_CONVERT_REG);
-
-		for (i = 0; i < timeout; i++) {
-			if (devpriv->read_byte(dev->iobase +
-					       STATUS1_REG) & DATA_AVAIL_BIT)
-				break;
-			udelay(1);
-		}
-		if (i == timeout) {
-			comedi_error(dev, "timeout");
-			return -ETIME;
-		}
-		lsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
-		msb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
-		data[n] = (msb << 8) | lsb;
-	}
-
-	return n;
-}
-
-#ifdef CONFIG_ISA_DMA_API
-/* utility function that suggests a dma transfer size in bytes */
-static unsigned int labpc_suggest_transfer_size(const struct comedi_cmd *cmd)
-{
-	unsigned int size;
-	unsigned int freq;
-
-	if (cmd->convert_src == TRIG_TIMER)
-		freq = 1000000000 / cmd->convert_arg;
-	/* return some default value */
-	else
-		freq = 0xffffffff;
-
-	/* make buffer fill in no more than 1/3 second */
-	size = (freq / 3) * sample_size;
-
-	/* set a minimum and maximum size allowed */
-	if (size > dma_buffer_size)
-		size = dma_buffer_size - dma_buffer_size % sample_size;
-	else if (size < sample_size)
-		size = sample_size;
-
-	return size;
-}
-#endif
-
-/* figures out what counter values to use based on command */
-static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
-			     enum scan_mode mode)
-{
-	struct labpc_private *devpriv = dev->private;
-	/* max value for 16 bit counter in mode 2 */
-	const int max_counter_value = 0x10000;
-	/* min value for 16 bit counter in mode 2 */
-	const int min_counter_value = 2;
-	unsigned int base_period;
-	unsigned int scan_period;
-	unsigned int convert_period;
-
-	/*
-	 * if both convert and scan triggers are TRIG_TIMER, then they
-	 * both rely on counter b0
-	 */
-	convert_period = labpc_ai_convert_period(cmd, mode);
-	scan_period = labpc_ai_scan_period(cmd, mode);
-	if (convert_period && scan_period) {
-		/*
-		 * pick the lowest b0 divisor value we can (for maximum input
-		 * clock speed on convert and scan counters)
-		 */
-		devpriv->divisor_b0 = (scan_period - 1) /
-		    (LABPC_TIMER_BASE * max_counter_value) + 1;
-		if (devpriv->divisor_b0 < min_counter_value)
-			devpriv->divisor_b0 = min_counter_value;
-		if (devpriv->divisor_b0 > max_counter_value)
-			devpriv->divisor_b0 = max_counter_value;
-
-		base_period = LABPC_TIMER_BASE * devpriv->divisor_b0;
-
-		/*  set a0 for conversion frequency and b1 for scan frequency */
-		switch (cmd->flags & TRIG_ROUND_MASK) {
-		default:
-		case TRIG_ROUND_NEAREST:
-			devpriv->divisor_a0 =
-			    (convert_period + (base_period / 2)) / base_period;
-			devpriv->divisor_b1 =
-			    (scan_period + (base_period / 2)) / base_period;
-			break;
-		case TRIG_ROUND_UP:
-			devpriv->divisor_a0 =
-			    (convert_period + (base_period - 1)) / base_period;
-			devpriv->divisor_b1 =
-			    (scan_period + (base_period - 1)) / base_period;
-			break;
-		case TRIG_ROUND_DOWN:
-			devpriv->divisor_a0 = convert_period / base_period;
-			devpriv->divisor_b1 = scan_period / base_period;
-			break;
-		}
-		/*  make sure a0 and b1 values are acceptable */
-		if (devpriv->divisor_a0 < min_counter_value)
-			devpriv->divisor_a0 = min_counter_value;
-		if (devpriv->divisor_a0 > max_counter_value)
-			devpriv->divisor_a0 = max_counter_value;
-		if (devpriv->divisor_b1 < min_counter_value)
-			devpriv->divisor_b1 = min_counter_value;
-		if (devpriv->divisor_b1 > max_counter_value)
-			devpriv->divisor_b1 = max_counter_value;
-		/*  write corrected timings to command */
-		labpc_set_ai_convert_period(cmd, mode,
-					    base_period * devpriv->divisor_a0);
-		labpc_set_ai_scan_period(cmd, mode,
-					 base_period * devpriv->divisor_b1);
-		/*
-		 * if only one TRIG_TIMER is used, we can employ the generic
-		 * cascaded timing functions
-		 */
-	} else if (scan_period) {
-		/*
-		 * calculate cascaded counter values
-		 * that give desired scan timing
-		 */
-		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
-					       &(devpriv->divisor_b1),
-					       &(devpriv->divisor_b0),
-					       &scan_period,
-					       cmd->flags & TRIG_ROUND_MASK);
-		labpc_set_ai_scan_period(cmd, mode, scan_period);
-	} else if (convert_period) {
-		/*
-		 * calculate cascaded counter values
-		 * that give desired conversion timing
-		 */
-		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
-					       &(devpriv->divisor_a0),
-					       &(devpriv->divisor_b0),
-					       &convert_period,
-					       cmd->flags & TRIG_ROUND_MASK);
-		labpc_set_ai_convert_period(cmd, mode, convert_period);
-	}
+	return 0;
 }
 
 #ifdef CONFIG_ISA_DMA_API

commit 571e06c1978d79702f83c27802ccfce33f7e80bb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:38:10 2013 -0700

    staging: comedi: ni_labpc: remove forward declarations 3
    
    Move the interrupt/dma support functions to remove the need for
    some of the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index b470afc5701d..a33884ff005d 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -215,12 +215,6 @@ enum scan_mode {
 	MODE_MULT_CHAN_DOWN,
 };
 
-static int labpc_drain_fifo(struct comedi_device *dev);
-#ifdef CONFIG_ISA_DMA_API
-static void labpc_drain_dma(struct comedi_device *dev);
-static void handle_isa_dma(struct comedi_device *dev);
-#endif
-static void labpc_drain_dregs(struct comedi_device *dev);
 static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
 			     enum scan_mode scan_mode);
 #ifdef CONFIG_ISA_DMA_API
@@ -1011,215 +1005,6 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-/* interrupt service routine */
-static irqreturn_t labpc_interrupt(int irq, void *d)
-{
-	struct comedi_device *dev = d;
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
-	struct labpc_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_async *async;
-	struct comedi_cmd *cmd;
-
-	if (!dev->attached) {
-		comedi_error(dev, "premature interrupt");
-		return IRQ_HANDLED;
-	}
-
-	async = s->async;
-	cmd = &async->cmd;
-	async->events = 0;
-
-	/* read board status */
-	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
-	if (thisboard->register_layout == labpc_1200_layout)
-		devpriv->status2_bits =
-		    devpriv->read_byte(dev->iobase + STATUS2_REG);
-
-	if ((devpriv->status1_bits & (DMATC_BIT | TIMER_BIT | OVERFLOW_BIT |
-				      OVERRUN_BIT | DATA_AVAIL_BIT)) == 0
-	    && (devpriv->status2_bits & A1_TC_BIT) == 0
-	    && (devpriv->status2_bits & FNHF_BIT)) {
-		return IRQ_NONE;
-	}
-
-	if (devpriv->status1_bits & OVERRUN_BIT) {
-		/* clear error interrupt */
-		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
-		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		comedi_event(dev, s);
-		comedi_error(dev, "overrun");
-		return IRQ_HANDLED;
-	}
-
-#ifdef CONFIG_ISA_DMA_API
-	if (devpriv->current_transfer == isa_dma_transfer) {
-		/*
-		 * if a dma terminal count of external stop trigger
-		 * has occurred
-		 */
-		if (devpriv->status1_bits & DMATC_BIT ||
-		    (thisboard->register_layout == labpc_1200_layout
-		     && devpriv->status2_bits & A1_TC_BIT)) {
-			handle_isa_dma(dev);
-		}
-	} else
-#endif
-		labpc_drain_fifo(dev);
-
-	if (devpriv->status1_bits & TIMER_BIT) {
-		comedi_error(dev, "handled timer interrupt?");
-		/*  clear it */
-		devpriv->write_byte(0x1, dev->iobase + TIMER_CLEAR_REG);
-	}
-
-	if (devpriv->status1_bits & OVERFLOW_BIT) {
-		/*  clear error interrupt */
-		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
-		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		comedi_event(dev, s);
-		comedi_error(dev, "overflow");
-		return IRQ_HANDLED;
-	}
-	/*  handle external stop trigger */
-	if (cmd->stop_src == TRIG_EXT) {
-		if (devpriv->status2_bits & A1_TC_BIT) {
-			labpc_drain_dregs(dev);
-			labpc_cancel(dev, s);
-			async->events |= COMEDI_CB_EOA;
-		}
-	}
-
-	/* TRIG_COUNT end of acquisition */
-	if (cmd->stop_src == TRIG_COUNT) {
-		if (devpriv->count == 0) {
-			labpc_cancel(dev, s);
-			async->events |= COMEDI_CB_EOA;
-		}
-	}
-
-	comedi_event(dev, s);
-	return IRQ_HANDLED;
-}
-
-/* read all available samples from ai fifo */
-static int labpc_drain_fifo(struct comedi_device *dev)
-{
-	struct labpc_private *devpriv = dev->private;
-	unsigned int lsb, msb;
-	short data;
-	struct comedi_async *async = dev->read_subdev->async;
-	const int timeout = 10000;
-	unsigned int i;
-
-	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
-
-	for (i = 0; (devpriv->status1_bits & DATA_AVAIL_BIT) && i < timeout;
-	     i++) {
-		/*  quit if we have all the data we want */
-		if (async->cmd.stop_src == TRIG_COUNT) {
-			if (devpriv->count == 0)
-				break;
-			devpriv->count--;
-		}
-		lsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
-		msb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
-		data = (msb << 8) | lsb;
-		cfc_write_to_buffer(dev->read_subdev, data);
-		devpriv->status1_bits =
-		    devpriv->read_byte(dev->iobase + STATUS1_REG);
-	}
-	if (i == timeout) {
-		comedi_error(dev, "ai timeout, fifo never empties");
-		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		return -1;
-	}
-
-	return 0;
-}
-
-#ifdef CONFIG_ISA_DMA_API
-static void labpc_drain_dma(struct comedi_device *dev)
-{
-	struct labpc_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_async *async = s->async;
-	int status;
-	unsigned long flags;
-	unsigned int max_points, num_points, residue, leftover;
-	int i;
-
-	status = devpriv->status1_bits;
-
-	flags = claim_dma_lock();
-	disable_dma(devpriv->dma_chan);
-	/* clear flip-flop to make sure 2-byte registers for
-	 * count and address get set correctly */
-	clear_dma_ff(devpriv->dma_chan);
-
-	/*  figure out how many points to read */
-	max_points = devpriv->dma_transfer_size / sample_size;
-	/* residue is the number of points left to be done on the dma
-	 * transfer.  It should always be zero at this point unless
-	 * the stop_src is set to external triggering.
-	 */
-	residue = get_dma_residue(devpriv->dma_chan) / sample_size;
-	num_points = max_points - residue;
-	if (devpriv->count < num_points && async->cmd.stop_src == TRIG_COUNT)
-		num_points = devpriv->count;
-
-	/*  figure out how many points will be stored next time */
-	leftover = 0;
-	if (async->cmd.stop_src != TRIG_COUNT) {
-		leftover = devpriv->dma_transfer_size / sample_size;
-	} else if (devpriv->count > num_points) {
-		leftover = devpriv->count - num_points;
-		if (leftover > max_points)
-			leftover = max_points;
-	}
-
-	/* write data to comedi buffer */
-	for (i = 0; i < num_points; i++)
-		cfc_write_to_buffer(s, devpriv->dma_buffer[i]);
-
-	if (async->cmd.stop_src == TRIG_COUNT)
-		devpriv->count -= num_points;
-
-	/*  set address and count for next transfer */
-	set_dma_addr(devpriv->dma_chan, virt_to_bus(devpriv->dma_buffer));
-	set_dma_count(devpriv->dma_chan, leftover * sample_size);
-	release_dma_lock(flags);
-
-	async->events |= COMEDI_CB_BLOCK;
-}
-
-static void handle_isa_dma(struct comedi_device *dev)
-{
-	struct labpc_private *devpriv = dev->private;
-
-	labpc_drain_dma(dev);
-
-	enable_dma(devpriv->dma_chan);
-
-	/*  clear dma tc interrupt */
-	devpriv->write_byte(0x1, dev->iobase + DMATC_CLEAR_REG);
-}
-#endif
-
-/* makes sure all data acquired by board is transferred to comedi (used
- * when acquisition is terminated by stop_src == TRIG_EXT). */
-static void labpc_drain_dregs(struct comedi_device *dev)
-{
-#ifdef CONFIG_ISA_DMA_API
-	struct labpc_private *devpriv = dev->private;
-
-	if (devpriv->current_transfer == isa_dma_transfer)
-		labpc_drain_dma(dev);
-#endif
-
-	labpc_drain_fifo(dev);
-}
-
 static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
@@ -1432,6 +1217,215 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
 	}
 }
 
+#ifdef CONFIG_ISA_DMA_API
+static void labpc_drain_dma(struct comedi_device *dev)
+{
+	struct labpc_private *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_async *async = s->async;
+	int status;
+	unsigned long flags;
+	unsigned int max_points, num_points, residue, leftover;
+	int i;
+
+	status = devpriv->status1_bits;
+
+	flags = claim_dma_lock();
+	disable_dma(devpriv->dma_chan);
+	/* clear flip-flop to make sure 2-byte registers for
+	 * count and address get set correctly */
+	clear_dma_ff(devpriv->dma_chan);
+
+	/*  figure out how many points to read */
+	max_points = devpriv->dma_transfer_size / sample_size;
+	/* residue is the number of points left to be done on the dma
+	 * transfer.  It should always be zero at this point unless
+	 * the stop_src is set to external triggering.
+	 */
+	residue = get_dma_residue(devpriv->dma_chan) / sample_size;
+	num_points = max_points - residue;
+	if (devpriv->count < num_points && async->cmd.stop_src == TRIG_COUNT)
+		num_points = devpriv->count;
+
+	/*  figure out how many points will be stored next time */
+	leftover = 0;
+	if (async->cmd.stop_src != TRIG_COUNT) {
+		leftover = devpriv->dma_transfer_size / sample_size;
+	} else if (devpriv->count > num_points) {
+		leftover = devpriv->count - num_points;
+		if (leftover > max_points)
+			leftover = max_points;
+	}
+
+	/* write data to comedi buffer */
+	for (i = 0; i < num_points; i++)
+		cfc_write_to_buffer(s, devpriv->dma_buffer[i]);
+
+	if (async->cmd.stop_src == TRIG_COUNT)
+		devpriv->count -= num_points;
+
+	/*  set address and count for next transfer */
+	set_dma_addr(devpriv->dma_chan, virt_to_bus(devpriv->dma_buffer));
+	set_dma_count(devpriv->dma_chan, leftover * sample_size);
+	release_dma_lock(flags);
+
+	async->events |= COMEDI_CB_BLOCK;
+}
+
+static void handle_isa_dma(struct comedi_device *dev)
+{
+	struct labpc_private *devpriv = dev->private;
+
+	labpc_drain_dma(dev);
+
+	enable_dma(devpriv->dma_chan);
+
+	/*  clear dma tc interrupt */
+	devpriv->write_byte(0x1, dev->iobase + DMATC_CLEAR_REG);
+}
+#endif
+
+/* read all available samples from ai fifo */
+static int labpc_drain_fifo(struct comedi_device *dev)
+{
+	struct labpc_private *devpriv = dev->private;
+	unsigned int lsb, msb;
+	short data;
+	struct comedi_async *async = dev->read_subdev->async;
+	const int timeout = 10000;
+	unsigned int i;
+
+	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
+
+	for (i = 0; (devpriv->status1_bits & DATA_AVAIL_BIT) && i < timeout;
+	     i++) {
+		/*  quit if we have all the data we want */
+		if (async->cmd.stop_src == TRIG_COUNT) {
+			if (devpriv->count == 0)
+				break;
+			devpriv->count--;
+		}
+		lsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+		msb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+		data = (msb << 8) | lsb;
+		cfc_write_to_buffer(dev->read_subdev, data);
+		devpriv->status1_bits =
+		    devpriv->read_byte(dev->iobase + STATUS1_REG);
+	}
+	if (i == timeout) {
+		comedi_error(dev, "ai timeout, fifo never empties");
+		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		return -1;
+	}
+
+	return 0;
+}
+
+/* makes sure all data acquired by board is transferred to comedi (used
+ * when acquisition is terminated by stop_src == TRIG_EXT). */
+static void labpc_drain_dregs(struct comedi_device *dev)
+{
+#ifdef CONFIG_ISA_DMA_API
+	struct labpc_private *devpriv = dev->private;
+
+	if (devpriv->current_transfer == isa_dma_transfer)
+		labpc_drain_dma(dev);
+#endif
+
+	labpc_drain_fifo(dev);
+}
+
+/* interrupt service routine */
+static irqreturn_t labpc_interrupt(int irq, void *d)
+{
+	struct comedi_device *dev = d;
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	struct labpc_private *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_async *async;
+	struct comedi_cmd *cmd;
+
+	if (!dev->attached) {
+		comedi_error(dev, "premature interrupt");
+		return IRQ_HANDLED;
+	}
+
+	async = s->async;
+	cmd = &async->cmd;
+	async->events = 0;
+
+	/* read board status */
+	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
+	if (thisboard->register_layout == labpc_1200_layout)
+		devpriv->status2_bits =
+		    devpriv->read_byte(dev->iobase + STATUS2_REG);
+
+	if ((devpriv->status1_bits & (DMATC_BIT | TIMER_BIT | OVERFLOW_BIT |
+				      OVERRUN_BIT | DATA_AVAIL_BIT)) == 0
+	    && (devpriv->status2_bits & A1_TC_BIT) == 0
+	    && (devpriv->status2_bits & FNHF_BIT)) {
+		return IRQ_NONE;
+	}
+
+	if (devpriv->status1_bits & OVERRUN_BIT) {
+		/* clear error interrupt */
+		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
+		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		comedi_event(dev, s);
+		comedi_error(dev, "overrun");
+		return IRQ_HANDLED;
+	}
+
+#ifdef CONFIG_ISA_DMA_API
+	if (devpriv->current_transfer == isa_dma_transfer) {
+		/*
+		 * if a dma terminal count of external stop trigger
+		 * has occurred
+		 */
+		if (devpriv->status1_bits & DMATC_BIT ||
+		    (thisboard->register_layout == labpc_1200_layout
+		     && devpriv->status2_bits & A1_TC_BIT)) {
+			handle_isa_dma(dev);
+		}
+	} else
+#endif
+		labpc_drain_fifo(dev);
+
+	if (devpriv->status1_bits & TIMER_BIT) {
+		comedi_error(dev, "handled timer interrupt?");
+		/*  clear it */
+		devpriv->write_byte(0x1, dev->iobase + TIMER_CLEAR_REG);
+	}
+
+	if (devpriv->status1_bits & OVERFLOW_BIT) {
+		/*  clear error interrupt */
+		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
+		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		comedi_event(dev, s);
+		comedi_error(dev, "overflow");
+		return IRQ_HANDLED;
+	}
+	/*  handle external stop trigger */
+	if (cmd->stop_src == TRIG_EXT) {
+		if (devpriv->status2_bits & A1_TC_BIT) {
+			labpc_drain_dregs(dev);
+			labpc_cancel(dev, s);
+			async->events |= COMEDI_CB_EOA;
+		}
+	}
+
+	/* TRIG_COUNT end of acquisition */
+	if (cmd->stop_src == TRIG_COUNT) {
+		if (devpriv->count == 0) {
+			labpc_cancel(dev, s);
+			async->events |= COMEDI_CB_EOA;
+		}
+	}
+
+	comedi_event(dev, s);
+	return IRQ_HANDLED;
+}
+
 /* analog output insn */
 static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)

commit 8913491d9040f02b46f8766eacab5935a7fb9106
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:37:37 2013 -0700

    staging: comedi: ni_labpc: move the analog output support functions
    
    For aesthetic reasons, move the analog output support functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 198198a7091d..b470afc5701d 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1310,60 +1310,6 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return n;
 }
 
-/* analog output insn */
-static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data)
-{
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
-	struct labpc_private *devpriv = dev->private;
-	int channel, range;
-	unsigned long flags;
-	int lsb, msb;
-
-	channel = CR_CHAN(insn->chanspec);
-
-	/* turn off pacing of analog output channel */
-	/* note: hardware bug in daqcard-1200 means pacing cannot
-	 * be independently enabled/disabled for its the two channels */
-	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->command2_bits &= ~DAC_PACED_BIT(channel);
-	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	/* set range */
-	if (thisboard->register_layout == labpc_1200_layout) {
-		range = CR_RANGE(insn->chanspec);
-		if (range & AO_RANGE_IS_UNIPOLAR)
-			devpriv->command6_bits |= DAC_UNIP_BIT(channel);
-		else
-			devpriv->command6_bits &= ~DAC_UNIP_BIT(channel);
-		/*  write to register */
-		devpriv->write_byte(devpriv->command6_bits,
-				    dev->iobase + COMMAND6_REG);
-	}
-	/* send data */
-	lsb = data[0] & 0xff;
-	msb = (data[0] >> 8) & 0xff;
-	devpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(channel));
-	devpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(channel));
-
-	/* remember value for readback */
-	devpriv->ao_value[channel] = data[0];
-
-	return 1;
-}
-
-/* analog output readback insn */
-static int labpc_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data)
-{
-	struct labpc_private *devpriv = dev->private;
-
-	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
-
-	return 1;
-}
-
 #ifdef CONFIG_ISA_DMA_API
 /* utility function that suggests a dma transfer size in bytes */
 static unsigned int labpc_suggest_transfer_size(const struct comedi_cmd *cmd)
@@ -1486,6 +1432,60 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
 	}
 }
 
+/* analog output insn */
+static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+			  struct comedi_insn *insn, unsigned int *data)
+{
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	struct labpc_private *devpriv = dev->private;
+	int channel, range;
+	unsigned long flags;
+	int lsb, msb;
+
+	channel = CR_CHAN(insn->chanspec);
+
+	/* turn off pacing of analog output channel */
+	/* note: hardware bug in daqcard-1200 means pacing cannot
+	 * be independently enabled/disabled for its the two channels */
+	spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->command2_bits &= ~DAC_PACED_BIT(channel);
+	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	/* set range */
+	if (thisboard->register_layout == labpc_1200_layout) {
+		range = CR_RANGE(insn->chanspec);
+		if (range & AO_RANGE_IS_UNIPOLAR)
+			devpriv->command6_bits |= DAC_UNIP_BIT(channel);
+		else
+			devpriv->command6_bits &= ~DAC_UNIP_BIT(channel);
+		/*  write to register */
+		devpriv->write_byte(devpriv->command6_bits,
+				    dev->iobase + COMMAND6_REG);
+	}
+	/* send data */
+	lsb = data[0] & 0xff;
+	msb = (data[0] >> 8) & 0xff;
+	devpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(channel));
+	devpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(channel));
+
+	/* remember value for readback */
+	devpriv->ao_value[channel] = data[0];
+
+	return 1;
+}
+
+/* analog output readback insn */
+static int labpc_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+			  struct comedi_insn *insn, unsigned int *data)
+{
+	struct labpc_private *devpriv = dev->private;
+
+	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
 static int labpc_dio_mem_callback(int dir, int port, int data,
 				  unsigned long iobase)
 {

commit bc3fc446800aff41abf3af82f673590b6b39c642
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:37:04 2013 -0700

    staging: comedi: ni_labpc: remove forward declarations 2
    
    Move the eeprom/caldac support functions to remove the need for
    some of the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 846a1e9a9427..198198a7091d 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -226,12 +226,6 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
 #ifdef CONFIG_ISA_DMA_API
 static unsigned int labpc_suggest_transfer_size(const struct comedi_cmd *cmd);
 #endif
-static unsigned int labpc_eeprom_read_status(struct comedi_device *dev);
-static int labpc_eeprom_write(struct comedi_device *dev,
-				       unsigned int address,
-				       unsigned int value);
-static void write_caldac(struct comedi_device *dev, unsigned int channel,
-			 unsigned int value);
 
 /* analog input ranges */
 #define NUM_LABPC_PLUS_AI_RANGES 16
@@ -1370,59 +1364,6 @@ static int labpc_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return 1;
 }
 
-static int labpc_calib_read_insn(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn, unsigned int *data)
-{
-	struct labpc_private *devpriv = dev->private;
-
-	data[0] = devpriv->caldac[CR_CHAN(insn->chanspec)];
-
-	return 1;
-}
-
-static int labpc_calib_write_insn(struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data)
-{
-	int channel = CR_CHAN(insn->chanspec);
-
-	write_caldac(dev, channel, data[0]);
-	return 1;
-}
-
-static int labpc_eeprom_read_insn(struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data)
-{
-	struct labpc_private *devpriv = dev->private;
-
-	data[0] = devpriv->eeprom_data[CR_CHAN(insn->chanspec)];
-
-	return 1;
-}
-
-static int labpc_eeprom_write_insn(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   struct comedi_insn *insn, unsigned int *data)
-{
-	int channel = CR_CHAN(insn->chanspec);
-	int ret;
-
-	/*  only allow writes to user area of eeprom */
-	if (channel < 16 || channel > 127) {
-		dev_dbg(dev->class_dev,
-			"eeprom writes are only allowed to channels 16 through 127 (the pointer and user areas)\n");
-		return -EINVAL;
-	}
-
-	ret = labpc_eeprom_write(dev, channel, data[0]);
-	if (ret < 0)
-		return ret;
-
-	return 1;
-}
-
 #ifdef CONFIG_ISA_DMA_API
 /* utility function that suggests a dma transfer size in bytes */
 static unsigned int labpc_suggest_transfer_size(const struct comedi_cmd *cmd)
@@ -1645,6 +1586,34 @@ static unsigned int labpc_eeprom_read(struct comedi_device *dev,
 	return value;
 }
 
+static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
+{
+	struct labpc_private *devpriv = dev->private;
+	unsigned int value;
+	const int read_status_instruction = 0x5;
+	const int write_length = 8;	/*  8 bit write lengths to eeprom */
+
+	/*  enable read/write to eeprom */
+	devpriv->command5_bits &= ~EEPROM_EN_BIT;
+	udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
+	udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+
+	/*  send read status instruction */
+	labpc_serial_out(dev, read_status_instruction, write_length);
+	/*  read result */
+	value = labpc_serial_in(dev);
+
+	/*  disable read/write to eeprom */
+	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+
+	return value;
+}
+
 static int labpc_eeprom_write(struct comedi_device *dev,
 				unsigned int address, unsigned int value)
 {
@@ -1704,34 +1673,6 @@ static int labpc_eeprom_write(struct comedi_device *dev,
 	return 0;
 }
 
-static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
-{
-	struct labpc_private *devpriv = dev->private;
-	unsigned int value;
-	const int read_status_instruction = 0x5;
-	const int write_length = 8;	/*  8 bit write lengths to eeprom */
-
-	/*  enable read/write to eeprom */
-	devpriv->command5_bits &= ~EEPROM_EN_BIT;
-	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
-	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
-	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
-
-	/*  send read status instruction */
-	labpc_serial_out(dev, read_status_instruction, write_length);
-	/*  read result */
-	value = labpc_serial_in(dev);
-
-	/*  disable read/write to eeprom */
-	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
-	udelay(1);
-	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
-
-	return value;
-}
-
 /* writes to 8 bit calibration dacs */
 static void write_caldac(struct comedi_device *dev, unsigned int channel,
 			 unsigned int value)
@@ -1762,6 +1703,59 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 }
 
+static int labpc_calib_write_insn(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
+{
+	int channel = CR_CHAN(insn->chanspec);
+
+	write_caldac(dev, channel, data[0]);
+	return 1;
+}
+
+static int labpc_calib_read_insn(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
+{
+	struct labpc_private *devpriv = dev->private;
+
+	data[0] = devpriv->caldac[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
+static int labpc_eeprom_write_insn(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
+{
+	int channel = CR_CHAN(insn->chanspec);
+	int ret;
+
+	/*  only allow writes to user area of eeprom */
+	if (channel < 16 || channel > 127) {
+		dev_dbg(dev->class_dev,
+			"eeprom writes are only allowed to channels 16 through 127 (the pointer and user areas)\n");
+		return -EINVAL;
+	}
+
+	ret = labpc_eeprom_write(dev, channel, data[0]);
+	if (ret < 0)
+		return ret;
+
+	return 1;
+}
+
+static int labpc_eeprom_read_insn(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
+{
+	struct labpc_private *devpriv = dev->private;
+
+	data[0] = devpriv->eeprom_data[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
 int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 			unsigned int irq, unsigned int dma_chan)
 {

commit dd2aef646c9cfcc2647cae52a5097ce70f1e13c3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:36:34 2013 -0700

    staging: comedi: ni_labpc: remove forward declarations 1
    
    Move the comedi_driver (*attach), (*auto_attach), and (*detach)
    functions as well as a couple of the attach helper functions to
    remove the need for a number of the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 1a9024dd8941..846a1e9a9427 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -215,48 +215,17 @@ enum scan_mode {
 	MODE_MULT_CHAN_DOWN,
 };
 
-static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static irqreturn_t labpc_interrupt(int irq, void *d);
 static int labpc_drain_fifo(struct comedi_device *dev);
 #ifdef CONFIG_ISA_DMA_API
 static void labpc_drain_dma(struct comedi_device *dev);
 static void handle_isa_dma(struct comedi_device *dev);
 #endif
 static void labpc_drain_dregs(struct comedi_device *dev);
-static int labpc_ai_cmdtest(struct comedi_device *dev,
-			    struct comedi_subdevice *s, struct comedi_cmd *cmd);
-static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data);
-static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data);
-static int labpc_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data);
-static int labpc_calib_read_insn(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn, unsigned int *data);
-static int labpc_calib_write_insn(struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data);
-static int labpc_eeprom_read_insn(struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data);
-static int labpc_eeprom_write_insn(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   struct comedi_insn *insn,
-				   unsigned int *data);
 static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
 			     enum scan_mode scan_mode);
 #ifdef CONFIG_ISA_DMA_API
 static unsigned int labpc_suggest_transfer_size(const struct comedi_cmd *cmd);
 #endif
-static int labpc_dio_mem_callback(int dir, int port, int data,
-				  unsigned long arg);
-static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
-			     unsigned int num_bits);
-static unsigned int labpc_serial_in(struct comedi_device *dev);
-static unsigned int labpc_eeprom_read(struct comedi_device *dev,
-				      unsigned int address);
 static unsigned int labpc_eeprom_read_status(struct comedi_device *dev);
 static int labpc_eeprom_write(struct comedi_device *dev,
 				       unsigned int address,
@@ -498,388 +467,76 @@ static inline int labpc_counter_load(struct comedi_device *dev,
 		return i8254_load(base_address, 0, counter_number, count, mode);
 }
 
-int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
-			unsigned int irq, unsigned int dma_chan)
+static void labpc_clear_adc_fifo(const struct comedi_device *dev)
 {
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
-	struct comedi_subdevice *s;
-	int i;
-	unsigned long isr_flags;
-#ifdef CONFIG_ISA_DMA_API
-	unsigned long dma_flags;
-#endif
-	short lsb, msb;
-	int ret;
-
-	dev_info(dev->class_dev, "ni_labpc: %s\n", thisboard->name);
-	if (iobase == 0) {
-		dev_err(dev->class_dev, "io base address is zero!\n");
-		return -EINVAL;
-	}
-	/*  request io regions for isa boards */
-	if (thisboard->bustype == isa_bustype) {
-		/* check if io addresses are available */
-		if (!request_region(iobase, LABPC_SIZE, DRV_NAME)) {
-			dev_err(dev->class_dev, "I/O port conflict\n");
-			return -EIO;
-		}
-	}
-	dev->iobase = iobase;
-
-	if (thisboard->memory_mapped_io) {
-		devpriv->read_byte = labpc_readb;
-		devpriv->write_byte = labpc_writeb;
-	} else {
-		devpriv->read_byte = labpc_inb;
-		devpriv->write_byte = labpc_outb;
-	}
-	/* initialize board's command registers */
-	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
-	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
-	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
-	if (thisboard->register_layout == labpc_1200_layout) {
-		devpriv->write_byte(devpriv->command5_bits,
-				    dev->iobase + COMMAND5_REG);
-		devpriv->write_byte(devpriv->command6_bits,
-				    dev->iobase + COMMAND6_REG);
-	}
-
-	/* grab our IRQ */
-	if (irq) {
-		isr_flags = 0;
-		if (thisboard->bustype == pci_bustype
-		    || thisboard->bustype == pcmcia_bustype)
-			isr_flags |= IRQF_SHARED;
-		if (request_irq(irq, labpc_interrupt, isr_flags,
-				DRV_NAME, dev)) {
-			dev_err(dev->class_dev, "unable to allocate irq %u\n",
-				irq);
-			return -EINVAL;
-		}
-	}
-	dev->irq = irq;
-
-#ifdef CONFIG_ISA_DMA_API
-	/* grab dma channel */
-	if (dma_chan > 3) {
-		dev_err(dev->class_dev, "invalid dma channel %u\n", dma_chan);
-		return -EINVAL;
-	} else if (dma_chan) {
-		/* allocate dma buffer */
-		devpriv->dma_buffer = kmalloc(dma_buffer_size,
-					      GFP_KERNEL | GFP_DMA);
-		if (devpriv->dma_buffer == NULL)
-			return -ENOMEM;
 
-		if (request_dma(dma_chan, DRV_NAME)) {
-			dev_err(dev->class_dev,
-				"failed to allocate dma channel %u\n",
-				dma_chan);
-			return -EINVAL;
-		}
-		devpriv->dma_chan = dma_chan;
-		dma_flags = claim_dma_lock();
-		disable_dma(devpriv->dma_chan);
-		set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
-		release_dma_lock(dma_flags);
-	}
-#endif
+	devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
+	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+}
 
-	dev->board_name = thisboard->name;
+static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+{
+	struct labpc_private *devpriv = dev->private;
+	unsigned long flags;
 
-	ret = comedi_alloc_subdevices(dev, 5);
-	if (ret)
-		return ret;
+	spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
+	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/* analog input subdevice */
-	s = &dev->subdevices[0];
-	dev->read_subdev = s;
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags =
-	    SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF | SDF_CMD_READ;
-	s->n_chan = 8;
-	s->len_chanlist = 8;
-	s->maxdata = (1 << 12) - 1;	/* 12 bit resolution */
-	s->range_table = thisboard->ai_range_table;
-	s->do_cmd = labpc_ai_cmd;
-	s->do_cmdtest = labpc_ai_cmdtest;
-	s->insn_read = labpc_ai_rinsn;
-	s->cancel = labpc_cancel;
+	devpriv->command3_bits = 0;
+	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
-	/* analog output */
-	s = &dev->subdevices[1];
-	if (thisboard->has_ao) {
-		/*
-		 * Could provide command support, except it only has a
-		 * one sample hardware buffer for analog output and no
-		 * underrun flag.
-		 */
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
-		s->n_chan = NUM_AO_CHAN;
-		s->maxdata = (1 << 12) - 1;	/*  12 bit resolution */
-		s->range_table = &range_labpc_ao;
-		s->insn_read = labpc_ao_rinsn;
-		s->insn_write = labpc_ao_winsn;
-		/* initialize analog outputs to a known value */
-		for (i = 0; i < s->n_chan; i++) {
-			devpriv->ao_value[i] = s->maxdata / 2;
-			lsb = devpriv->ao_value[i] & 0xff;
-			msb = (devpriv->ao_value[i] >> 8) & 0xff;
-			devpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(i));
-			devpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(i));
-		}
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	return 0;
+}
 
-	/* 8255 dio */
-	s = &dev->subdevices[2];
-	/*  if board uses io memory we have to give a custom callback
-	 * function to the 8255 driver */
-	if (thisboard->memory_mapped_io)
-		subdev_8255_init(dev, s, labpc_dio_mem_callback,
-				 (unsigned long)(dev->iobase + DIO_BASE_REG));
-	else
-		subdev_8255_init(dev, s, NULL, dev->iobase + DIO_BASE_REG);
+static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)
+{
+	if (cmd->chanlist_len == 1)
+		return MODE_SINGLE_CHAN;
 
-	/*  calibration subdevices for boards that have one */
-	s = &dev->subdevices[3];
-	if (thisboard->register_layout == labpc_1200_layout) {
-		s->type = COMEDI_SUBD_CALIB;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-		s->n_chan = 16;
-		s->maxdata = 0xff;
-		s->insn_read = labpc_calib_read_insn;
-		s->insn_write = labpc_calib_write_insn;
+	/* chanlist may be NULL during cmdtest. */
+	if (cmd->chanlist == NULL)
+		return MODE_MULT_CHAN_UP;
 
-		for (i = 0; i < s->n_chan; i++)
-			write_caldac(dev, i, s->maxdata / 2);
-	} else
-		s->type = COMEDI_SUBD_UNUSED;
+	if (CR_CHAN(cmd->chanlist[0]) == CR_CHAN(cmd->chanlist[1]))
+		return MODE_SINGLE_CHAN_INTERVAL;
 
-	/* EEPROM */
-	s = &dev->subdevices[4];
-	if (thisboard->register_layout == labpc_1200_layout) {
-		s->type = COMEDI_SUBD_MEMORY;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-		s->n_chan = EEPROM_SIZE;
-		s->maxdata = 0xff;
-		s->insn_read = labpc_eeprom_read_insn;
-		s->insn_write = labpc_eeprom_write_insn;
+	if (CR_CHAN(cmd->chanlist[0]) < CR_CHAN(cmd->chanlist[1]))
+		return MODE_MULT_CHAN_UP;
 
-		for (i = 0; i < EEPROM_SIZE; i++)
-			devpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);
-	} else
-		s->type = COMEDI_SUBD_UNUSED;
+	if (CR_CHAN(cmd->chanlist[0]) > CR_CHAN(cmd->chanlist[1]))
+		return MODE_MULT_CHAN_DOWN;
 
+	pr_err("ni_labpc: bug! cannot determine AI scan mode\n");
 	return 0;
 }
-EXPORT_SYMBOL_GPL(labpc_common_attach);
 
-static const struct labpc_boardinfo *
-labpc_pci_find_boardinfo(struct pci_dev *pcidev)
+static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
+				     const struct comedi_cmd *cmd,
+				     enum scan_mode mode)
 {
-	unsigned int device_id = pcidev->device;
-	unsigned int n;
+	int channel, range, aref, i;
 
-	for (n = 0; n < ARRAY_SIZE(labpc_boards); n++) {
-		const struct labpc_boardinfo *board = &labpc_boards[n];
-		if (board->bustype == pci_bustype &&
-		    board->device_id == device_id)
-			return board;
-	}
-	return NULL;
-}
+	if (cmd->chanlist == NULL)
+		return 0;
 
-static int labpc_auto_attach(struct comedi_device *dev,
-				       unsigned long context_unused)
-{
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	struct labpc_private *devpriv;
-	unsigned long iobase;
-	unsigned int irq;
-	int ret;
+	if (mode == MODE_SINGLE_CHAN)
+		return 0;
 
-	if (!IS_ENABLED(CONFIG_COMEDI_PCI_DRIVERS))
-		return -ENODEV;
+	if (mode == MODE_SINGLE_CHAN_INTERVAL) {
+		if (cmd->chanlist_len > 0xff) {
+			comedi_error(dev,
+				     "ni_labpc: chanlist too long for single channel interval mode\n");
+			return 1;
+		}
+	}
 
-	ret = comedi_pci_enable(dev);
-	if (ret)
-		return ret;
-
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
-	if (!devpriv)
-		return -ENOMEM;
-	dev->private = devpriv;
-
-	dev->board_ptr = labpc_pci_find_boardinfo(pcidev);
-	if (!dev->board_ptr)
-		return -ENODEV;
-	devpriv->mite = mite_alloc(pcidev);
-	if (!devpriv->mite)
-		return -ENOMEM;
-	ret = mite_setup(devpriv->mite);
-	if (ret < 0)
-		return ret;
-	iobase = (unsigned long)devpriv->mite->daq_io_addr;
-	irq = mite_irq(devpriv->mite);
-	return labpc_common_attach(dev, iobase, irq, 0);
-}
-
-static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
-{
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
-	struct labpc_private *devpriv;
-	unsigned long iobase = 0;
-	unsigned int irq = 0;
-	unsigned int dma_chan = 0;
-
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
-	if (!devpriv)
-		return -ENOMEM;
-	dev->private = devpriv;
-
-	/* get base address, irq etc. based on bustype */
-	switch (thisboard->bustype) {
-	case isa_bustype:
-#ifdef CONFIG_ISA_DMA_API
-		iobase = it->options[0];
-		irq = it->options[1];
-		dma_chan = it->options[2];
-#else
-		dev_err(dev->class_dev,
-			"ni_labpc driver has not been built with ISA DMA support.\n");
-		return -EINVAL;
-#endif
-		break;
-	case pci_bustype:
-#ifdef CONFIG_COMEDI_PCI_DRIVERS
-		dev_err(dev->class_dev,
-			"manual configuration of PCI board '%s' is not supported\n",
-			thisboard->name);
-		return -EINVAL;
-#else
-		dev_err(dev->class_dev,
-			"ni_labpc driver has not been built with PCI support.\n");
-		return -EINVAL;
-#endif
-		break;
-	default:
-		dev_err(dev->class_dev,
-			"ni_labpc: bug! couldn't determine board type\n");
-		return -EINVAL;
-		break;
-	}
-
-	return labpc_common_attach(dev, iobase, irq, dma_chan);
-}
-
-void labpc_common_detach(struct comedi_device *dev)
-{
-	const struct labpc_boardinfo *thisboard = comedi_board(dev);
-	struct labpc_private *devpriv = dev->private;
-	struct comedi_subdevice *s;
-
-	if (!thisboard)
-		return;
-	if (dev->subdevices) {
-		s = &dev->subdevices[2];
-		subdev_8255_cleanup(dev, s);
-	}
-#ifdef CONFIG_ISA_DMA_API
-	/* only free stuff if it has been allocated by _attach */
-	kfree(devpriv->dma_buffer);
-	if (devpriv->dma_chan)
-		free_dma(devpriv->dma_chan);
-#endif
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	if (thisboard->bustype == isa_bustype && dev->iobase)
-		release_region(dev->iobase, LABPC_SIZE);
-#ifdef CONFIG_COMEDI_PCI_DRIVERS
-	if (devpriv->mite) {
-		mite_unsetup(devpriv->mite);
-		mite_free(devpriv->mite);
-	}
-	if (thisboard->bustype == pci_bustype)
-		comedi_pci_disable(dev);
-#endif
-};
-EXPORT_SYMBOL_GPL(labpc_common_detach);
-
-static void labpc_clear_adc_fifo(const struct comedi_device *dev)
-{
-	struct labpc_private *devpriv = dev->private;
-
-	devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
-	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
-	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
-}
-
-static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	struct labpc_private *devpriv = dev->private;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
-	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	devpriv->command3_bits = 0;
-	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
-
-	return 0;
-}
-
-static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)
-{
-	if (cmd->chanlist_len == 1)
-		return MODE_SINGLE_CHAN;
-
-	/* chanlist may be NULL during cmdtest. */
-	if (cmd->chanlist == NULL)
-		return MODE_MULT_CHAN_UP;
-
-	if (CR_CHAN(cmd->chanlist[0]) == CR_CHAN(cmd->chanlist[1]))
-		return MODE_SINGLE_CHAN_INTERVAL;
-
-	if (CR_CHAN(cmd->chanlist[0]) < CR_CHAN(cmd->chanlist[1]))
-		return MODE_MULT_CHAN_UP;
-
-	if (CR_CHAN(cmd->chanlist[0]) > CR_CHAN(cmd->chanlist[1]))
-		return MODE_MULT_CHAN_DOWN;
-
-	pr_err("ni_labpc: bug! cannot determine AI scan mode\n");
-	return 0;
-}
-
-static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
-				     const struct comedi_cmd *cmd,
-				     enum scan_mode mode)
-{
-	int channel, range, aref, i;
-
-	if (cmd->chanlist == NULL)
-		return 0;
-
-	if (mode == MODE_SINGLE_CHAN)
-		return 0;
-
-	if (mode == MODE_SINGLE_CHAN_INTERVAL) {
-		if (cmd->chanlist_len > 0xff) {
-			comedi_error(dev,
-				     "ni_labpc: chanlist too long for single channel interval mode\n");
-			return 1;
-		}
-	}
-
-	channel = CR_CHAN(cmd->chanlist[0]);
-	range = CR_RANGE(cmd->chanlist[0]);
-	aref = CR_AREF(cmd->chanlist[0]);
+	channel = CR_CHAN(cmd->chanlist[0]);
+	range = CR_RANGE(cmd->chanlist[0]);
+	aref = CR_AREF(cmd->chanlist[0]);
 
 	for (i = 0; i < cmd->chanlist_len; i++) {
 
@@ -2105,6 +1762,318 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 }
 
+int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
+			unsigned int irq, unsigned int dma_chan)
+{
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	struct labpc_private *devpriv = dev->private;
+	struct comedi_subdevice *s;
+	int i;
+	unsigned long isr_flags;
+#ifdef CONFIG_ISA_DMA_API
+	unsigned long dma_flags;
+#endif
+	short lsb, msb;
+	int ret;
+
+	dev_info(dev->class_dev, "ni_labpc: %s\n", thisboard->name);
+	if (iobase == 0) {
+		dev_err(dev->class_dev, "io base address is zero!\n");
+		return -EINVAL;
+	}
+	/*  request io regions for isa boards */
+	if (thisboard->bustype == isa_bustype) {
+		/* check if io addresses are available */
+		if (!request_region(iobase, LABPC_SIZE, DRV_NAME)) {
+			dev_err(dev->class_dev, "I/O port conflict\n");
+			return -EIO;
+		}
+	}
+	dev->iobase = iobase;
+
+	if (thisboard->memory_mapped_io) {
+		devpriv->read_byte = labpc_readb;
+		devpriv->write_byte = labpc_writeb;
+	} else {
+		devpriv->read_byte = labpc_inb;
+		devpriv->write_byte = labpc_outb;
+	}
+	/* initialize board's command registers */
+	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
+	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
+	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
+	if (thisboard->register_layout == labpc_1200_layout) {
+		devpriv->write_byte(devpriv->command5_bits,
+				    dev->iobase + COMMAND5_REG);
+		devpriv->write_byte(devpriv->command6_bits,
+				    dev->iobase + COMMAND6_REG);
+	}
+
+	/* grab our IRQ */
+	if (irq) {
+		isr_flags = 0;
+		if (thisboard->bustype == pci_bustype
+		    || thisboard->bustype == pcmcia_bustype)
+			isr_flags |= IRQF_SHARED;
+		if (request_irq(irq, labpc_interrupt, isr_flags,
+				DRV_NAME, dev)) {
+			dev_err(dev->class_dev, "unable to allocate irq %u\n",
+				irq);
+			return -EINVAL;
+		}
+	}
+	dev->irq = irq;
+
+#ifdef CONFIG_ISA_DMA_API
+	/* grab dma channel */
+	if (dma_chan > 3) {
+		dev_err(dev->class_dev, "invalid dma channel %u\n", dma_chan);
+		return -EINVAL;
+	} else if (dma_chan) {
+		/* allocate dma buffer */
+		devpriv->dma_buffer = kmalloc(dma_buffer_size,
+					      GFP_KERNEL | GFP_DMA);
+		if (devpriv->dma_buffer == NULL)
+			return -ENOMEM;
+
+		if (request_dma(dma_chan, DRV_NAME)) {
+			dev_err(dev->class_dev,
+				"failed to allocate dma channel %u\n",
+				dma_chan);
+			return -EINVAL;
+		}
+		devpriv->dma_chan = dma_chan;
+		dma_flags = claim_dma_lock();
+		disable_dma(devpriv->dma_chan);
+		set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
+		release_dma_lock(dma_flags);
+	}
+#endif
+
+	dev->board_name = thisboard->name;
+
+	ret = comedi_alloc_subdevices(dev, 5);
+	if (ret)
+		return ret;
+
+	/* analog input subdevice */
+	s = &dev->subdevices[0];
+	dev->read_subdev = s;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags =
+	    SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF | SDF_CMD_READ;
+	s->n_chan = 8;
+	s->len_chanlist = 8;
+	s->maxdata = (1 << 12) - 1;	/* 12 bit resolution */
+	s->range_table = thisboard->ai_range_table;
+	s->do_cmd = labpc_ai_cmd;
+	s->do_cmdtest = labpc_ai_cmdtest;
+	s->insn_read = labpc_ai_rinsn;
+	s->cancel = labpc_cancel;
+
+	/* analog output */
+	s = &dev->subdevices[1];
+	if (thisboard->has_ao) {
+		/*
+		 * Could provide command support, except it only has a
+		 * one sample hardware buffer for analog output and no
+		 * underrun flag.
+		 */
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
+		s->n_chan = NUM_AO_CHAN;
+		s->maxdata = (1 << 12) - 1;	/*  12 bit resolution */
+		s->range_table = &range_labpc_ao;
+		s->insn_read = labpc_ao_rinsn;
+		s->insn_write = labpc_ao_winsn;
+		/* initialize analog outputs to a known value */
+		for (i = 0; i < s->n_chan; i++) {
+			devpriv->ao_value[i] = s->maxdata / 2;
+			lsb = devpriv->ao_value[i] & 0xff;
+			msb = (devpriv->ao_value[i] >> 8) & 0xff;
+			devpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(i));
+			devpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(i));
+		}
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/* 8255 dio */
+	s = &dev->subdevices[2];
+	/*  if board uses io memory we have to give a custom callback
+	 * function to the 8255 driver */
+	if (thisboard->memory_mapped_io)
+		subdev_8255_init(dev, s, labpc_dio_mem_callback,
+				 (unsigned long)(dev->iobase + DIO_BASE_REG));
+	else
+		subdev_8255_init(dev, s, NULL, dev->iobase + DIO_BASE_REG);
+
+	/*  calibration subdevices for boards that have one */
+	s = &dev->subdevices[3];
+	if (thisboard->register_layout == labpc_1200_layout) {
+		s->type = COMEDI_SUBD_CALIB;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+		s->n_chan = 16;
+		s->maxdata = 0xff;
+		s->insn_read = labpc_calib_read_insn;
+		s->insn_write = labpc_calib_write_insn;
+
+		for (i = 0; i < s->n_chan; i++)
+			write_caldac(dev, i, s->maxdata / 2);
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	/* EEPROM */
+	s = &dev->subdevices[4];
+	if (thisboard->register_layout == labpc_1200_layout) {
+		s->type = COMEDI_SUBD_MEMORY;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+		s->n_chan = EEPROM_SIZE;
+		s->maxdata = 0xff;
+		s->insn_read = labpc_eeprom_read_insn;
+		s->insn_write = labpc_eeprom_write_insn;
+
+		for (i = 0; i < EEPROM_SIZE; i++)
+			devpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(labpc_common_attach);
+
+static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+{
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	struct labpc_private *devpriv;
+	unsigned long iobase = 0;
+	unsigned int irq = 0;
+	unsigned int dma_chan = 0;
+
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
+
+	/* get base address, irq etc. based on bustype */
+	switch (thisboard->bustype) {
+	case isa_bustype:
+#ifdef CONFIG_ISA_DMA_API
+		iobase = it->options[0];
+		irq = it->options[1];
+		dma_chan = it->options[2];
+#else
+		dev_err(dev->class_dev,
+			"ni_labpc driver has not been built with ISA DMA support.\n");
+		return -EINVAL;
+#endif
+		break;
+	case pci_bustype:
+#ifdef CONFIG_COMEDI_PCI_DRIVERS
+		dev_err(dev->class_dev,
+			"manual configuration of PCI board '%s' is not supported\n",
+			thisboard->name);
+		return -EINVAL;
+#else
+		dev_err(dev->class_dev,
+			"ni_labpc driver has not been built with PCI support.\n");
+		return -EINVAL;
+#endif
+		break;
+	default:
+		dev_err(dev->class_dev,
+			"ni_labpc: bug! couldn't determine board type\n");
+		return -EINVAL;
+		break;
+	}
+
+	return labpc_common_attach(dev, iobase, irq, dma_chan);
+}
+
+static const struct labpc_boardinfo *
+labpc_pci_find_boardinfo(struct pci_dev *pcidev)
+{
+	unsigned int device_id = pcidev->device;
+	unsigned int n;
+
+	for (n = 0; n < ARRAY_SIZE(labpc_boards); n++) {
+		const struct labpc_boardinfo *board = &labpc_boards[n];
+		if (board->bustype == pci_bustype &&
+		    board->device_id == device_id)
+			return board;
+	}
+	return NULL;
+}
+
+static int labpc_auto_attach(struct comedi_device *dev,
+				       unsigned long context_unused)
+{
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct labpc_private *devpriv;
+	unsigned long iobase;
+	unsigned int irq;
+	int ret;
+
+	if (!IS_ENABLED(CONFIG_COMEDI_PCI_DRIVERS))
+		return -ENODEV;
+
+	ret = comedi_pci_enable(dev);
+	if (ret)
+		return ret;
+
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
+
+	dev->board_ptr = labpc_pci_find_boardinfo(pcidev);
+	if (!dev->board_ptr)
+		return -ENODEV;
+	devpriv->mite = mite_alloc(pcidev);
+	if (!devpriv->mite)
+		return -ENOMEM;
+	ret = mite_setup(devpriv->mite);
+	if (ret < 0)
+		return ret;
+	iobase = (unsigned long)devpriv->mite->daq_io_addr;
+	irq = mite_irq(devpriv->mite);
+	return labpc_common_attach(dev, iobase, irq, 0);
+}
+
+void labpc_common_detach(struct comedi_device *dev)
+{
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+	struct labpc_private *devpriv = dev->private;
+	struct comedi_subdevice *s;
+
+	if (!thisboard)
+		return;
+	if (dev->subdevices) {
+		s = &dev->subdevices[2];
+		subdev_8255_cleanup(dev, s);
+	}
+#ifdef CONFIG_ISA_DMA_API
+	/* only free stuff if it has been allocated by _attach */
+	kfree(devpriv->dma_buffer);
+	if (devpriv->dma_chan)
+		free_dma(devpriv->dma_chan);
+#endif
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	if (thisboard->bustype == isa_bustype && dev->iobase)
+		release_region(dev->iobase, LABPC_SIZE);
+#ifdef CONFIG_COMEDI_PCI_DRIVERS
+	if (devpriv->mite) {
+		mite_unsetup(devpriv->mite);
+		mite_free(devpriv->mite);
+	}
+	if (thisboard->bustype == pci_bustype)
+		comedi_pci_disable(dev);
+#endif
+}
+EXPORT_SYMBOL_GPL(labpc_common_detach);
+
 static struct comedi_driver labpc_driver = {
 	.driver_name	= DRV_NAME,
 	.module		= THIS_MODULE,

commit 6e8bddf281d5db0da34f919271b3966c14ed5de4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:36:00 2013 -0700

    staging: comedi: ni_labpc: add some whitespace to the *_driver declarations
    
    For aesthetic reasons, add some whitespace to the comedi_driver and
    pci_driver as well as the pci device table declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 023b08552206..1a9024dd8941 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -2106,20 +2106,20 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 }
 
 static struct comedi_driver labpc_driver = {
-	.driver_name = DRV_NAME,
-	.module = THIS_MODULE,
-	.attach = labpc_attach,
-	.auto_attach = labpc_auto_attach,
-	.detach = labpc_common_detach,
-	.num_names = ARRAY_SIZE(labpc_boards),
-	.board_name = &labpc_boards[0].name,
-	.offset = sizeof(struct labpc_boardinfo),
+	.driver_name	= DRV_NAME,
+	.module		= THIS_MODULE,
+	.attach		= labpc_attach,
+	.auto_attach	= labpc_auto_attach,
+	.detach		= labpc_common_detach,
+	.num_names	= ARRAY_SIZE(labpc_boards),
+	.board_name	= &labpc_boards[0].name,
+	.offset		= sizeof(struct labpc_boardinfo),
 };
 
 #ifdef CONFIG_COMEDI_PCI_DRIVERS
 static DEFINE_PCI_DEVICE_TABLE(labpc_pci_table) = {
-	{PCI_DEVICE(PCI_VENDOR_ID_NI, 0x161)},
-	{0}
+	{ PCI_DEVICE(PCI_VENDOR_ID_NI, 0x161) },
+	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, labpc_pci_table);
 
@@ -2130,9 +2130,9 @@ static int labpc_pci_probe(struct pci_dev *dev,
 }
 
 static struct pci_driver labpc_pci_driver = {
-	.name = DRV_NAME,
-	.id_table = labpc_pci_table,
-	.probe = labpc_pci_probe,
+	.name		= DRV_NAME,
+	.id_table	= labpc_pci_table,
+	.probe		= labpc_pci_probe,
 	.remove		= comedi_pci_auto_unconfig,
 };
 module_comedi_pci_driver(labpc_driver, labpc_pci_driver);

commit d72da604afe9db30b1150a51734df3c25c15ed54
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:34:39 2013 -0700

    staging: comedi: ni_labpc: remove thisboard macro
    
    The 'thisboard' macro relies on a local variable having a specific
    name and yields a pointer derived from that local variable.
    
    Replace the macro with a local variable and use the comedi_board()
    helper to get the const pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 590c8565ca7b..023b08552206 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -479,11 +479,6 @@ static const struct labpc_boardinfo labpc_boards[] = {
 #endif
 };
 
-/*
- * Useful for shorthand access to the particular board structure
- */
-#define thisboard ((struct labpc_boardinfo *)dev->board_ptr)
-
 /* size in bytes of dma buffer */
 static const int dma_buffer_size = 0xff00;
 /* 2 bytes per sample */
@@ -494,6 +489,8 @@ static inline int labpc_counter_load(struct comedi_device *dev,
 				     unsigned int counter_number,
 				     unsigned int count, unsigned int mode)
 {
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
+
 	if (thisboard->memory_mapped_io)
 		return i8254_mm_load((void __iomem *)base_address, 0,
 				     counter_number, count, mode);
@@ -504,6 +501,7 @@ static inline int labpc_counter_load(struct comedi_device *dev,
 int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 			unsigned int irq, unsigned int dma_chan)
 {
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	int i;
@@ -733,6 +731,7 @@ static int labpc_auto_attach(struct comedi_device *dev,
 
 static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
 	struct labpc_private *devpriv;
 	unsigned long iobase = 0;
 	unsigned int irq = 0;
@@ -780,6 +779,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 void labpc_common_detach(struct comedi_device *dev)
 {
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 
@@ -995,6 +995,7 @@ static void labpc_set_ai_scan_period(struct comedi_cmd *cmd,
 static int labpc_ai_cmdtest(struct comedi_device *dev,
 			    struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
 	int err = 0;
 	int tmp, tmp2;
 	unsigned int stop_mask;
@@ -1092,6 +1093,7 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 
 static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	int channel, range, aref;
 #ifdef CONFIG_ISA_DMA_API
@@ -1362,6 +1364,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static irqreturn_t labpc_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
@@ -1569,6 +1572,7 @@ static void labpc_drain_dregs(struct comedi_device *dev)
 static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	int i, n;
 	int chan, range;
@@ -1659,6 +1663,7 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
+	const struct labpc_boardinfo *thisboard = comedi_board(dev);
 	struct labpc_private *devpriv = dev->private;
 	int channel, range;
 	unsigned long flags;

commit f65d971dfb3cb85ef4534a9e4a45a170da5970d9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 22 09:34:09 2013 -0700

    staging: comedi: ni_labpc: rename labpc_board_struct
    
    For aesthetic reasons, rename labpc_board_struct to labpc_boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 152dc844fa96..590c8565ca7b 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -420,7 +420,7 @@ static inline void labpc_writeb(unsigned int byte, unsigned long address)
 	writeb(byte, (void __iomem *)address);
 }
 
-static const struct labpc_board_struct labpc_boards[] = {
+static const struct labpc_boardinfo labpc_boards[] = {
 	{
 	 .name = "lab-pc-1200",
 	 .ai_speed = 10000,
@@ -482,7 +482,7 @@ static const struct labpc_board_struct labpc_boards[] = {
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((struct labpc_board_struct *)dev->board_ptr)
+#define thisboard ((struct labpc_boardinfo *)dev->board_ptr)
 
 /* size in bytes of dma buffer */
 static const int dma_buffer_size = 0xff00;
@@ -681,14 +681,14 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 }
 EXPORT_SYMBOL_GPL(labpc_common_attach);
 
-static const struct labpc_board_struct *
+static const struct labpc_boardinfo *
 labpc_pci_find_boardinfo(struct pci_dev *pcidev)
 {
 	unsigned int device_id = pcidev->device;
 	unsigned int n;
 
 	for (n = 0; n < ARRAY_SIZE(labpc_boards); n++) {
-		const struct labpc_board_struct *board = &labpc_boards[n];
+		const struct labpc_boardinfo *board = &labpc_boards[n];
 		if (board->bustype == pci_bustype &&
 		    board->device_id == device_id)
 			return board;
@@ -2108,7 +2108,7 @@ static struct comedi_driver labpc_driver = {
 	.detach = labpc_common_detach,
 	.num_names = ARRAY_SIZE(labpc_boards),
 	.board_name = &labpc_boards[0].name,
-	.offset = sizeof(struct labpc_board_struct),
+	.offset = sizeof(struct labpc_boardinfo),
 };
 
 #ifdef CONFIG_COMEDI_PCI_DRIVERS

commit a14592896023adcab12307774c89284ce0744ce2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:39:52 2013 +0000

    staging: comedi: ni_labpc: fix common detach
    
    `labpc_common_detach()` calls `comedi_pci_disable()` unconditionally.
    That's okay for PCI devices and harmless for ISA devices (as the
    `hw_dev` member will be NULL so `comedi_to_pci_dev()` will return NULL
    and `comedi_pci_disable()` checks for that), but it is disastrous for
    PCMCIA devices.  Those are managed by the "ni_labpc_cs" module but it
    calls this `labpc_common_detach()` and the `hw_dev` member will be
    pointing to the `struct device` embedded in a `struct pcmcia_device` in
    that case.  That's enough to confuse `comedi_pci_disable()` into
    thinking it's a valid PCI device to be disabled.
    
    Use the private board information (`thisboard`) to make sure it is a PCI
    device before calling `comedi_pci_disable()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 62ec39dea97d..152dc844fa96 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -804,7 +804,8 @@ void labpc_common_detach(struct comedi_device *dev)
 		mite_unsetup(devpriv->mite);
 		mite_free(devpriv->mite);
 	}
-	comedi_pci_disable(dev);
+	if (thisboard->bustype == pci_bustype)
+		comedi_pci_disable(dev);
 #endif
 };
 EXPORT_SYMBOL_GPL(labpc_common_detach);

commit 84b44d08993ffe762d9a86ee2243239350b871a4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:36 2013 +0000

    staging: comedi: remove unneeded settings of `dev->iobase`
    
    Some PCI drivers use the "spare" `iobase` member of `struct
    comedi_device` as a flag to indicate that the call to
    `comedi_pci_enable()` was successful.  This is no longer necessary now
    that `comedi_pci_enable()` and `comedi_pci_disable()` use the
    `ioenabled` member of `struct comedi_device` themselves to keep track of
    what needs to be done.
    
    Remove the unnecessary assignments to the `iobase` member in the
    relevant drivers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index d2edaad4ddbe..62ec39dea97d 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -711,7 +711,6 @@ static int labpc_auto_attach(struct comedi_device *dev,
 	ret = comedi_pci_enable(dev);
 	if (ret)
 		return ret;
-	dev->iobase = 1;
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)

commit a7401cddcdf739d3cb9598c9b3787a732fc87809
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:33 2013 +0000

    staging: comedi: make 'dev->attached' a bool bit-field
    
    Change the `attached` member of `struct comedi_device` to a 1-bit
    bit-field of type `bool`.  Change assigned values to `true` and `false`
    and replace or remove comparison operations with simple boolean tests.
    
    We'll put some extra bit-fields in the gap later to save space.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 78f01709e222..d2edaad4ddbe 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1367,7 +1367,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	struct comedi_async *async;
 	struct comedi_cmd *cmd;
 
-	if (dev->attached == 0) {
+	if (!dev->attached) {
 		comedi_error(dev, "premature interrupt");
 		return IRQ_HANDLED;
 	}

commit 818f569fe930c5b8a05d1a44ece3c63c99c13c88
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:36:31 2013 -0700

    staging: comedi_pci: pass comedi_device to comedi_pci_enable()
    
    Make comedi_pci_enable() use the same parameter type as
    comedi_pci_disable(). This also allows comedi_pci_enable
    to automatically determine the resource name passed to
    pci_request_regions().
    
    Make sure the errno value returned is passed on instead of
    assuming an errno. Also, remove any kernel noise that is
    generated when the call fails.
    
    The National Instruments drivers that use the mite module
    currently enable the PCI device in the mite module. For
    those drivers move the call to comedi_pci_enable into the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 9082eca09499..78f01709e222 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -708,6 +708,11 @@ static int labpc_auto_attach(struct comedi_device *dev,
 	if (!IS_ENABLED(CONFIG_COMEDI_PCI_DRIVERS))
 		return -ENODEV;
 
+	ret = comedi_pci_enable(dev);
+	if (ret)
+		return ret;
+	dev->iobase = 1;
+
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
 		return -ENOMEM;
@@ -722,7 +727,6 @@ static int labpc_auto_attach(struct comedi_device *dev,
 	ret = mite_setup(devpriv->mite);
 	if (ret < 0)
 		return ret;
-	dev->iobase = 1;
 	iobase = (unsigned long)devpriv->mite->daq_io_addr;
 	irq = mite_irq(devpriv->mite);
 	return labpc_common_attach(dev, iobase, irq, 0);

commit 7f072f54ae5dc9965cbe450419b1389d13e2b849
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:35:51 2013 -0700

    staging: comedi_pci: make comedi_pci_disable() safe to call
    
    Currently all the comedi PCI drivers need to do some checking in
    their (*detach) before calling comedi_pci_disable() in order to
    make sure the PCI device has actually be enabled.
    
    Change the parameter passed to comedi_pci_disable() from a struct
    pci_dev pointer to a comedi_device pointer and have comedi_pci_disable()
    handle all the checking.
    
    For most comedi PCI drivers this also allows removing the local
    variable holding the pointer to the pci_dev. For some of the drivers
    comedi_pci_disable can now be used directly as the (*detach) function.
    
    The National Instruments drivers that use the mite module currently
    enable/disable the PCI device in the mite module. For those drivers
    move the call to comedi_pci_disable into the driver and make sure
    dev->iobase is set to a non-zero value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index d386c3e2b976..9082eca09499 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -722,6 +722,7 @@ static int labpc_auto_attach(struct comedi_device *dev,
 	ret = mite_setup(devpriv->mite);
 	if (ret < 0)
 		return ret;
+	dev->iobase = 1;
 	iobase = (unsigned long)devpriv->mite->daq_io_addr;
 	irq = mite_irq(devpriv->mite);
 	return labpc_common_attach(dev, iobase, irq, 0);
@@ -800,6 +801,7 @@ void labpc_common_detach(struct comedi_device *dev)
 		mite_unsetup(devpriv->mite);
 		mite_free(devpriv->mite);
 	}
+	comedi_pci_disable(dev);
 #endif
 };
 EXPORT_SYMBOL_GPL(labpc_common_detach);

commit b8f4ac237e382accd4b30c75043939f7ed9e79a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 09:53:41 2013 -0700

    staging: comedi: comedi_pci: change the comedi_pci_auto_config() 'context'
    
    The comedi_pci_auto_config() function is used to allow the PCI driver
    (*probe) function to automatically call the comedi driver (*auto_attach).
    This allows the comedi driver to be part of the PnP process when the
    PCI device is detected.
    
    Currently the comedi_pci_auto_config() always passes a 'context' of '0'
    to comedi_auto_config(). This makes the 'context' a bit useless.
    
    Modify comedi_pci_auto_config() to allow the comedi pci drivers to pass
    a 'context' from the PCI driver.
    
    Make all the comedi pci drivers pass the pci_device_id 'driver_data' as
    the 'context'. Since none of the comedi pci drivers currently set the
    'driver_data' the 'context' will still be '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index f957b8859b3d..d386c3e2b976 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -2113,9 +2113,9 @@ static DEFINE_PCI_DEVICE_TABLE(labpc_pci_table) = {
 MODULE_DEVICE_TABLE(pci, labpc_pci_table);
 
 static int labpc_pci_probe(struct pci_dev *dev,
-				     const struct pci_device_id *ent)
+			   const struct pci_device_id *id)
 {
-	return comedi_pci_auto_config(dev, &labpc_driver);
+	return comedi_pci_auto_config(dev, &labpc_driver, id->driver_data);
 }
 
 static struct pci_driver labpc_pci_driver = {

commit 78110bb8dc4a7ff331bfa3cfe7d4e287cfb3f22b
Author: Joe Perches <joe@perches.com>
Date:   Mon Feb 11 09:41:29 2013 -0800

    staging: Remove unnecessary OOM messages
    
    alloc failures already get standardized OOM
    messages and a dump_stack.
    
    For the affected mallocs around these OOM messages:
    
    Converted kzallocs with multiplies to kcalloc.
    Converted kmallocs with multiplies to kmalloc_array.
    Converted a kmalloc/strlen/strncpy to kstrdup.
    Moved a spin_lock below a removed OOM message and
    removed a now unnecessary spin_unlock.
    Neatened alignment and whitespace.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index f851c54b0c33..f957b8859b3d 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -570,13 +570,11 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		return -EINVAL;
 	} else if (dma_chan) {
 		/* allocate dma buffer */
-		devpriv->dma_buffer =
-		    kmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);
-		if (devpriv->dma_buffer == NULL) {
-			dev_err(dev->class_dev,
-				"failed to allocate dma buffer\n");
+		devpriv->dma_buffer = kmalloc(dma_buffer_size,
+					      GFP_KERNEL | GFP_DMA);
+		if (devpriv->dma_buffer == NULL)
 			return -ENOMEM;
-		}
+
 		if (request_dma(dma_chan, DRV_NAME)) {
 			dev_err(dev->class_dev,
 				"failed to allocate dma channel %u\n",

commit 4c4bc25d0fa6beaf054c0b4c3b324487f266c820
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 1 14:51:58 2013 +0000

    staging: comedi: ni_labpc: correct differential channel sequence for AI commands
    
    Tuomas <tvainikk _at_ gmail _dot_ com> reported problems getting
    meaningful output from a Lab-PC+ in differential mode for AI cmds, but
    AI insn reads gave correct readings.  He tracked it down to two
    problems, one of which is addressed by this patch.
    
    It seems the setting of the channel bits for particular scanning modes
    was incorrect for differential mode.  (Only half the number of channels
    are available in differential mode; comedi refers to them as channels 0,
    1, 2 and 3, but the hardware documentation refers to them as channels 0,
    2, 4 and 6.)  In differential mode, the setting of the channel enable
    bits in the command1 register should depend on whether the scan enable
    bit is set.  Effectively, we need to double the comedi channel number
    when the scan enable bit is not set in differential mode.  The scan
    enable bit gets set when the AI scan mode is `MODE_MULT_CHAN_UP` or
    `MODE_MULT_CHAN_DOWN`, and gets cleared when the AI scan mode is
    `MODE_SINGLE_CHAN` or `MODE_SINGLE_CHAN_INTERVAL`.  The existing test
    for whether the comedi channel number needs to be doubled in
    differential mode is incorrect in `labpc_ai_cmd()`.  This patch corrects
    the test.
    
    Thanks to Tuomas for suggesting the fix.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: <stable@vger.kernel.org> # 3.7.x, 3.8.x
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 10bd2b36b1e2..f851c54b0c33 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1204,7 +1204,8 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	else
 		channel = CR_CHAN(cmd->chanlist[0]);
 	/* munge channel bits for differential / scan disabled mode */
-	if (mode != MODE_SINGLE_CHAN && aref == AREF_DIFF)
+	if ((mode == MODE_SINGLE_CHAN || mode == MODE_SINGLE_CHAN_INTERVAL) &&
+	    aref == AREF_DIFF)
 		channel *= 2;
 	devpriv->command1_bits |= ADC_CHAN_BITS(channel);
 	devpriv->command1_bits |= thisboard->ai_range_code[range];

commit 22056e2b46246d97ff0f7c6e21a77b8daa07f02c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Feb 1 14:51:57 2013 +0000

    staging: comedi: ni_labpc: set up command4 register *after* command3
    
    Tuomas <tvainikk _at_ gmail _dot_ com> reported problems getting
    meaningful output from a Lab-PC+ in differential mode for AI cmds, but
    AI insn reads gave correct readings.  He tracked it down to two
    problems, one of which is addressed by this patch.
    
    It seems that writing to the command3 register after writing to the
    command4 register in `labpc_ai_cmd()` messes up the differential
    reference bit setting in the command4 register.  Set up the command4
    register after the command3 register (as in `labpc_ai_rinsn()`) to avoid
    the problem.
    
    Thanks to Tuomas for suggesting the fix.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: <stable@vger.kernel.org> # 3.7.x, 3.8.x
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 9e4d2da5f5a7..10bd2b36b1e2 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1219,21 +1219,6 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->write_byte(devpriv->command1_bits,
 				    dev->iobase + COMMAND1_REG);
 	}
-	/*  setup any external triggering/pacing (command4 register) */
-	devpriv->command4_bits = 0;
-	if (cmd->convert_src != TRIG_EXT)
-		devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
-	/* XXX should discard first scan when using interval scanning
-	 * since manual says it is not synced with scan clock */
-	if (labpc_use_continuous_mode(cmd, mode) == 0) {
-		devpriv->command4_bits |= INTERVAL_SCAN_EN_BIT;
-		if (cmd->scan_begin_src == TRIG_EXT)
-			devpriv->command4_bits |= EXT_SCAN_EN_BIT;
-	}
-	/*  single-ended/differential */
-	if (aref == AREF_DIFF)
-		devpriv->command4_bits |= ADC_DIFF_BIT;
-	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
 
 	devpriv->write_byte(cmd->chanlist_len,
 			    dev->iobase + INTERVAL_COUNT_REG);
@@ -1313,6 +1298,22 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->command3_bits &= ~ADC_FNE_INTR_EN_BIT;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
+	/*  setup any external triggering/pacing (command4 register) */
+	devpriv->command4_bits = 0;
+	if (cmd->convert_src != TRIG_EXT)
+		devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
+	/* XXX should discard first scan when using interval scanning
+	 * since manual says it is not synced with scan clock */
+	if (labpc_use_continuous_mode(cmd, mode) == 0) {
+		devpriv->command4_bits |= INTERVAL_SCAN_EN_BIT;
+		if (cmd->scan_begin_src == TRIG_EXT)
+			devpriv->command4_bits |= EXT_SCAN_EN_BIT;
+	}
+	/*  single-ended/differential */
+	if (aref == AREF_DIFF)
+		devpriv->command4_bits |= ADC_DIFF_BIT;
+	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
+
 	/*  startup acquisition */
 
 	/*  command2 reg */

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index dedb2ab780f3..9e4d2da5f5a7 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -73,12 +73,14 @@ NI manuals:
 
 */
 
+#include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/io.h>
+#include <linux/delay.h>
+
 #include "../comedidev.h"
 
-#include <linux/delay.h>
 #include <asm/dma.h>
 
 #include "8253.h"

commit 9901a4d75d007686e8f6473189cafc4b216b7449
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Tue Jan 22 23:40:03 2013 +0100

    staging/comedi: Use comedi_pci_auto_unconfig directly for pci_driver.remove
    
    (Almost) all comedi pci drivers have some wrapper for their
    pci_driver.remove function which simply calls comedi_pci_auto_unconfig
    which has the same function prototype as the wrapper.
    
    -> we can remove these wrappers and call comedi_pci_auto_unconfig
    directly. This removes a lot some boilerplate code and saves some bytes.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index d29c4d761bac..dedb2ab780f3 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -2116,16 +2116,11 @@ static int labpc_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &labpc_driver);
 }
 
-static void labpc_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
 static struct pci_driver labpc_pci_driver = {
 	.name = DRV_NAME,
 	.id_table = labpc_pci_table,
 	.probe = labpc_pci_probe,
-	.remove = labpc_pci_remove
+	.remove		= comedi_pci_auto_unconfig,
 };
 module_comedi_pci_driver(labpc_driver, labpc_pci_driver);
 #else

commit 53b800198592b0ff96577ecc5f116f7d902a4362
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:36 2012 -0500

    staging: comedi: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 961642549624..d29c4d761bac 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -2116,7 +2116,7 @@ static int labpc_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &labpc_driver);
 }
 
-static void __devexit labpc_pci_remove(struct pci_dev *dev)
+static void labpc_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }

commit a690b7e535f2f97a3a05ee570715abeb60a8910f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:58 2012 -0500

    staging: comedi: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index b2e565bf3df0..961642549624 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -696,7 +696,7 @@ labpc_pci_find_boardinfo(struct pci_dev *pcidev)
 	return NULL;
 }
 
-static int __devinit labpc_auto_attach(struct comedi_device *dev,
+static int labpc_auto_attach(struct comedi_device *dev,
 				       unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
@@ -2110,7 +2110,7 @@ static DEFINE_PCI_DEVICE_TABLE(labpc_pci_table) = {
 };
 MODULE_DEVICE_TABLE(pci, labpc_pci_table);
 
-static int __devinit labpc_pci_probe(struct pci_dev *dev,
+static int labpc_pci_probe(struct pci_dev *dev,
 				     const struct pci_device_id *ent)
 {
 	return comedi_pci_auto_config(dev, &labpc_driver);

commit a471eace7baa40cdf16d3f26b2f78ddce613ca8f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:37 2012 -0500

    staging: comedi: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index b56039bea6a8..b2e565bf3df0 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -2125,7 +2125,7 @@ static struct pci_driver labpc_pci_driver = {
 	.name = DRV_NAME,
 	.id_table = labpc_pci_table,
 	.probe = labpc_pci_probe,
-	.remove = __devexit_p(labpc_pci_remove)
+	.remove = labpc_pci_remove
 };
 module_comedi_pci_driver(labpc_driver, labpc_pci_driver);
 #else

commit 88c793010bdeace47d6fc19f42bce00544280205
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:56:56 2012 -0700

    staging: comedi: ni_labpc: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of labpc_ai_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index f4a0377486ee..b56039bea6a8 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1026,56 +1026,34 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_arg == TRIG_NOW && cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
+	if (cmd->start_arg == TRIG_NOW)
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	if (!cmd->chanlist_len)
-		err++;
+		err |= -EINVAL;
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	if (cmd->convert_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+						 thisboard->ai_speed);
 
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < thisboard->ai_speed) {
-			cmd->convert_arg = thisboard->ai_speed;
-			err++;
-		}
-	}
 	/* make sure scan timing is not too fast */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		if (cmd->convert_src == TRIG_TIMER &&
-		    cmd->scan_begin_arg <
-		    cmd->convert_arg * cmd->chanlist_len) {
-			cmd->scan_begin_arg =
-			    cmd->convert_arg * cmd->chanlist_len;
-			err++;
-		}
-		if (cmd->scan_begin_arg <
-		    thisboard->ai_speed * cmd->chanlist_len) {
-			cmd->scan_begin_arg =
-			    thisboard->ai_speed * cmd->chanlist_len;
-			err++;
-		}
+		if (cmd->convert_src == TRIG_TIMER)
+			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+					cmd->convert_arg * cmd->chanlist_len);
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+				thisboard->ai_speed * cmd->chanlist_len);
 	}
-	/* stop source */
+
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		if (!cmd->stop_arg) {
-			cmd->stop_arg = 1;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
 		break;
 	case TRIG_NONE:
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 		break;
 		/*
 		 * TRIG_EXT doesn't care since it doesn't

commit 750af5e568d060ec6994cdcb4e86cdddfcd473c0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 30 13:30:04 2012 +0000

    staging: comedi/drivers: use auto_attach instead of attach_pci
    
    Change comedi drivers for PCI boards to use the new `auto_attach()`
    method instead of the `attach_pci()` method.  I plan to remove the
    `attach_pci()` and `attach_usb()` methods from `struct comedi_driver`
    once nothing is using them.
    
    Tag the functions with `__devinit` where they are not already so tagged,
    as they are only called during PCI probe.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index ab51c2678b9d..f4a0377486ee 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -696,9 +696,10 @@ labpc_pci_find_boardinfo(struct pci_dev *pcidev)
 	return NULL;
 }
 
-static int __devinit labpc_attach_pci(struct comedi_device *dev,
-				      struct pci_dev *pcidev)
+static int __devinit labpc_auto_attach(struct comedi_device *dev,
+				       unsigned long context_unused)
 {
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct labpc_private *devpriv;
 	unsigned long iobase;
 	unsigned int irq;
@@ -2117,7 +2118,7 @@ static struct comedi_driver labpc_driver = {
 	.driver_name = DRV_NAME,
 	.module = THIS_MODULE,
 	.attach = labpc_attach,
-	.attach_pci = labpc_attach_pci,
+	.auto_attach = labpc_auto_attach,
 	.detach = labpc_common_detach,
 	.num_names = ARRAY_SIZE(labpc_boards),
 	.board_name = &labpc_boards[0].name,

commit cb1f6268acd7f1bca7153fa9ca187ffb73f60ab8
Merge: d9ff3934171b 8f0d8163b50e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 29 08:37:12 2012 -0700

    Merge 3.7-rc3 into staging-next
    
    This resolves the conflict with:
            drivers/staging/comedi/drivers/amplc_dio200.c
    and syncs up the changes that happened in the staging directory for
    3.7-rc3.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index d3b386e51bfb..40012506334f 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -707,10 +707,10 @@ static int __devinit labpc_attach_pci(struct comedi_device *dev,
 	if (!IS_ENABLED(CONFIG_COMEDI_PCI_DRIVERS))
 		return -ENODEV;
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	dev->board_ptr = labpc_pci_find_boardinfo(pcidev);
 	if (!dev->board_ptr)
@@ -732,12 +732,11 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned long iobase = 0;
 	unsigned int irq = 0;
 	unsigned int dma_chan = 0;
-	int ret;
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	/* get base address, irq etc. based on bustype */
 	switch (thisboard->bustype) {

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 28b91a6c3789..d3b386e51bfb 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -487,8 +487,6 @@ static const int dma_buffer_size = 0xff00;
 /* 2 bytes per sample */
 static const int sample_size = 2;
 
-#define devpriv ((struct labpc_private *)dev->private)
-
 static inline int labpc_counter_load(struct comedi_device *dev,
 				     unsigned long base_address,
 				     unsigned int counter_number,
@@ -504,6 +502,7 @@ static inline int labpc_counter_load(struct comedi_device *dev,
 int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 			unsigned int irq, unsigned int dma_chan)
 {
+	struct labpc_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	int i;
 	unsigned long isr_flags;
@@ -700,15 +699,19 @@ labpc_pci_find_boardinfo(struct pci_dev *pcidev)
 static int __devinit labpc_attach_pci(struct comedi_device *dev,
 				      struct pci_dev *pcidev)
 {
+	struct labpc_private *devpriv;
 	unsigned long iobase;
 	unsigned int irq;
 	int ret;
 
 	if (!IS_ENABLED(CONFIG_COMEDI_PCI_DRIVERS))
 		return -ENODEV;
-	ret = alloc_private(dev, sizeof(struct labpc_private));
-	if (ret < 0)
+
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
 		return ret;
+	devpriv = dev->private;
+
 	dev->board_ptr = labpc_pci_find_boardinfo(pcidev);
 	if (!dev->board_ptr)
 		return -ENODEV;
@@ -725,13 +728,16 @@ static int __devinit labpc_attach_pci(struct comedi_device *dev,
 
 static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	struct labpc_private *devpriv;
 	unsigned long iobase = 0;
 	unsigned int irq = 0;
 	unsigned int dma_chan = 0;
+	int ret;
 
-	/* allocate and initialize dev->private */
-	if (alloc_private(dev, sizeof(struct labpc_private)) < 0)
-		return -ENOMEM;
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
+		return ret;
+	devpriv = dev->private;
 
 	/* get base address, irq etc. based on bustype */
 	switch (thisboard->bustype) {
@@ -770,6 +776,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 void labpc_common_detach(struct comedi_device *dev)
 {
+	struct labpc_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 
 	if (dev->subdevices) {
@@ -797,6 +804,8 @@ EXPORT_SYMBOL_GPL(labpc_common_detach);
 
 static void labpc_clear_adc_fifo(const struct comedi_device *dev)
 {
+	struct labpc_private *devpriv = dev->private;
+
 	devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
 	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
 	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
@@ -804,6 +813,7 @@ static void labpc_clear_adc_fifo(const struct comedi_device *dev)
 
 static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct labpc_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -1096,6 +1106,7 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 
 static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct labpc_private *devpriv = dev->private;
 	int channel, range, aref;
 #ifdef CONFIG_ISA_DMA_API
 	unsigned long irq_flags;
@@ -1363,6 +1374,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static irqreturn_t labpc_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct labpc_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
 	struct comedi_cmd *cmd;
@@ -1451,6 +1463,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 /* read all available samples from ai fifo */
 static int labpc_drain_fifo(struct comedi_device *dev)
 {
+	struct labpc_private *devpriv = dev->private;
 	unsigned int lsb, msb;
 	short data;
 	struct comedi_async *async = dev->read_subdev->async;
@@ -1486,6 +1499,7 @@ static int labpc_drain_fifo(struct comedi_device *dev)
 #ifdef CONFIG_ISA_DMA_API
 static void labpc_drain_dma(struct comedi_device *dev)
 {
+	struct labpc_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
 	int status;
@@ -1539,6 +1553,8 @@ static void labpc_drain_dma(struct comedi_device *dev)
 
 static void handle_isa_dma(struct comedi_device *dev)
 {
+	struct labpc_private *devpriv = dev->private;
+
 	labpc_drain_dma(dev);
 
 	enable_dma(devpriv->dma_chan);
@@ -1553,6 +1569,8 @@ static void handle_isa_dma(struct comedi_device *dev)
 static void labpc_drain_dregs(struct comedi_device *dev)
 {
 #ifdef CONFIG_ISA_DMA_API
+	struct labpc_private *devpriv = dev->private;
+
 	if (devpriv->current_transfer == isa_dma_transfer)
 		labpc_drain_dma(dev);
 #endif
@@ -1563,6 +1581,7 @@ static void labpc_drain_dregs(struct comedi_device *dev)
 static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
+	struct labpc_private *devpriv = dev->private;
 	int i, n;
 	int chan, range;
 	int lsb, msb;
@@ -1652,6 +1671,7 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
+	struct labpc_private *devpriv = dev->private;
 	int channel, range;
 	unsigned long flags;
 	int lsb, msb;
@@ -1693,6 +1713,8 @@ static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 static int labpc_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
+	struct labpc_private *devpriv = dev->private;
+
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
 
 	return 1;
@@ -1702,6 +1724,8 @@ static int labpc_calib_read_insn(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
 {
+	struct labpc_private *devpriv = dev->private;
+
 	data[0] = devpriv->caldac[CR_CHAN(insn->chanspec)];
 
 	return 1;
@@ -1721,6 +1745,8 @@ static int labpc_eeprom_read_insn(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data)
 {
+	struct labpc_private *devpriv = dev->private;
+
 	data[0] = devpriv->eeprom_data[CR_CHAN(insn->chanspec)];
 
 	return 1;
@@ -1777,6 +1803,7 @@ static unsigned int labpc_suggest_transfer_size(const struct comedi_cmd *cmd)
 static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
 			     enum scan_mode mode)
 {
+	struct labpc_private *devpriv = dev->private;
 	/* max value for 16 bit counter in mode 2 */
 	const int max_counter_value = 0x10000;
 	/* min value for 16 bit counter in mode 2 */
@@ -1883,6 +1910,7 @@ static int labpc_dio_mem_callback(int dir, int port, int data,
 static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
 			     unsigned int value_width)
 {
+	struct labpc_private *devpriv = dev->private;
 	int i;
 
 	for (i = 1; i <= value_width; i++) {
@@ -1907,6 +1935,7 @@ static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
 /* lowlevel read from eeprom */
 static unsigned int labpc_serial_in(struct comedi_device *dev)
 {
+	struct labpc_private *devpriv = dev->private;
 	unsigned int value = 0;
 	int i;
 	const int value_width = 8;	/*  number of bits wide values are */
@@ -1936,6 +1965,7 @@ static unsigned int labpc_serial_in(struct comedi_device *dev)
 static unsigned int labpc_eeprom_read(struct comedi_device *dev,
 				      unsigned int address)
 {
+	struct labpc_private *devpriv = dev->private;
 	unsigned int value;
 	/*  bits to tell eeprom to expect a read */
 	const int read_instruction = 0x3;
@@ -1968,6 +1998,7 @@ static unsigned int labpc_eeprom_read(struct comedi_device *dev,
 static int labpc_eeprom_write(struct comedi_device *dev,
 				unsigned int address, unsigned int value)
 {
+	struct labpc_private *devpriv = dev->private;
 	const int write_enable_instruction = 0x6;
 	const int write_instruction = 0x2;
 	const int write_length = 8;	/*  8 bit write lengths to eeprom */
@@ -2025,6 +2056,7 @@ static int labpc_eeprom_write(struct comedi_device *dev,
 
 static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
 {
+	struct labpc_private *devpriv = dev->private;
 	unsigned int value;
 	const int read_status_instruction = 0x5;
 	const int write_length = 8;	/*  8 bit write lengths to eeprom */
@@ -2054,6 +2086,8 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
 static void write_caldac(struct comedi_device *dev, unsigned int channel,
 			 unsigned int value)
 {
+	struct labpc_private *devpriv = dev->private;
+
 	if (value == devpriv->caldac[channel])
 		return;
 	devpriv->caldac[channel] = value;

commit 922b67c1ac53014d80649a961a2fde700cd065d8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 3 16:25:21 2012 +0100

    staging: comedi: ni_labpc: fix possible NULL deref during detach
    
    `labpc_common_detach()` is called by the comedi core to clean up if
    either `labpc_attach()` (including the one in the "ni_labpc_cs" module)
    or `labpc_attach_pci()` returns an error.  It assumes the `thisboard`
    macro (expanding to `((struct labpc_board_struct *)dev->board_ptr)`) is
    non-null.  This is a valid assumption if `labpc_attach()` fails, but not
    if `labpc_attach_pci()` fails, leading to a possible NULL pointer
    dereference.
    
    Check `thisboard` at the top of `labpc_common_detach()` and return early
    if it is `NULL`.  This is okay because the only other thing that could
    have been allocated is `dev->private` and that is freed by the comedi
    core, not by this function.
    
    Cc: <stable@vger.kernel.org> # 3.6.x
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 28b91a6c3789..b5a19a0863fb 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -772,6 +772,8 @@ void labpc_common_detach(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s;
 
+	if (!thisboard)
+		return;
 	if (dev->subdevices) {
 		s = &dev->subdevices[2];
 		subdev_8255_cleanup(dev, s);

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index d534e63d886e..28b91a6c3789 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -979,55 +979,33 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 {
 	int err = 0;
 	int tmp, tmp2;
-	int stop_mask;
+	unsigned int stop_mask;
 	enum scan_mode mode;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_EXT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_TIMER | TRIG_FOLLOW | TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_TIMER | TRIG_EXT;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_TIMER | TRIG_FOLLOW | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 
-	tmp = cmd->stop_src;
 	stop_mask = TRIG_COUNT | TRIG_NONE;
 	if (thisboard->register_layout == labpc_1200_layout)
 		stop_mask |= TRIG_EXT;
-	cmd->stop_src &= stop_mask;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->stop_src, stop_mask);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* Step 2a : make sure trigger sources are unique */
 
-	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
-		err++;
-	if (cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_FOLLOW &&
-	    cmd->scan_begin_src != TRIG_EXT)
-		err++;
-	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT &&
-	    cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	/* can't have external stop and start triggers at once */
 	if (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)

commit 62fea8c8f1bf5ca33ba55b3f421d9598a68297ee
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 19 19:37:42 2012 +0100

    staging: comedi: ni_labpc: don't pass struct comedi_cmd by value
    
    `labpc_suggest_transfer_size()` has a parameter of type `struct
    comedi_cmd` passed by value.  Change it to pass by pointer reference.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 200099e4c220..d534e63d886e 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -246,7 +246,7 @@ static int labpc_eeprom_write_insn(struct comedi_device *dev,
 static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
 			     enum scan_mode scan_mode);
 #ifdef CONFIG_ISA_DMA_API
-static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd);
+static unsigned int labpc_suggest_transfer_size(const struct comedi_cmd *cmd);
 #endif
 static int labpc_dio_mem_callback(int dir, int port, int data,
 				  unsigned long arg);
@@ -1318,7 +1318,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		set_dma_addr(devpriv->dma_chan,
 			     virt_to_bus(devpriv->dma_buffer));
 		/*  set appropriate size of transfer */
-		devpriv->dma_transfer_size = labpc_suggest_transfer_size(*cmd);
+		devpriv->dma_transfer_size = labpc_suggest_transfer_size(cmd);
 		if (cmd->stop_src == TRIG_COUNT &&
 		    devpriv->count * sample_size < devpriv->dma_transfer_size) {
 			devpriv->dma_transfer_size =
@@ -1771,13 +1771,13 @@ static int labpc_eeprom_write_insn(struct comedi_device *dev,
 
 #ifdef CONFIG_ISA_DMA_API
 /* utility function that suggests a dma transfer size in bytes */
-static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd)
+static unsigned int labpc_suggest_transfer_size(const struct comedi_cmd *cmd)
 {
 	unsigned int size;
 	unsigned int freq;
 
-	if (cmd.convert_src == TRIG_TIMER)
-		freq = 1000000000 / cmd.convert_arg;
+	if (cmd->convert_src == TRIG_TIMER)
+		freq = 1000000000 / cmd->convert_arg;
 	/* return some default value */
 	else
 		freq = 0xffffffff;

commit 6f73fbcec27be8b074555e18d9f50c3013e4d802
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 19 19:37:37 2012 +0100

    staging: comedi: ni_labpc: pass ai scan mode through various functions
    
    Pass the `enum scan_mode` value calculated by `labpc_ai_scan_mode()` as
    a parameter to various other functions so they don't have to call it
    themselves.  Amongst others, the affected functions include
    `labpc_adc_timing()`, `labpc_ai_convert_period()` and
    `labpc_ai_scan_period()`.
    
    `labpc_adc_timing()` calls `labpc_ai_convert_period()` and
    `labpc_ai_scan_period()` in several places, but the returned values are
    the same each time, so change it to just call those functions once and
    re-use the return values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 2d060b5cc1b7..200099e4c220 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -206,6 +206,13 @@ NI manuals:
 #define   INIT_A1_BITS	0x70
 #define COUNTER_B_BASE_REG	0x18
 
+enum scan_mode {
+	MODE_SINGLE_CHAN,
+	MODE_SINGLE_CHAN_INTERVAL,
+	MODE_MULT_CHAN_UP,
+	MODE_MULT_CHAN_DOWN,
+};
+
 static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static irqreturn_t labpc_interrupt(int irq, void *d);
 static int labpc_drain_fifo(struct comedi_device *dev);
@@ -236,7 +243,8 @@ static int labpc_eeprom_write_insn(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   struct comedi_insn *insn,
 				   unsigned int *data);
-static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd);
+static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
+			     enum scan_mode scan_mode);
 #ifdef CONFIG_ISA_DMA_API
 static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd);
 #endif
@@ -254,13 +262,6 @@ static int labpc_eeprom_write(struct comedi_device *dev,
 static void write_caldac(struct comedi_device *dev, unsigned int channel,
 			 unsigned int value);
 
-enum scan_mode {
-	MODE_SINGLE_CHAN,
-	MODE_SINGLE_CHAN_INTERVAL,
-	MODE_MULT_CHAN_UP,
-	MODE_MULT_CHAN_DOWN,
-};
-
 /* analog input ranges */
 #define NUM_LABPC_PLUS_AI_RANGES 16
 /* indicates unipolar ranges */
@@ -839,15 +840,14 @@ static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)
 }
 
 static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
-				     const struct comedi_cmd *cmd)
+				     const struct comedi_cmd *cmd,
+				     enum scan_mode mode)
 {
-	int mode, channel, range, aref, i;
+	int channel, range, aref, i;
 
 	if (cmd->chanlist == NULL)
 		return 0;
 
-	mode = labpc_ai_scan_mode(cmd);
-
 	if (mode == MODE_SINGLE_CHAN)
 		return 0;
 
@@ -911,9 +911,10 @@ static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
 	return 0;
 }
 
-static int labpc_use_continuous_mode(const struct comedi_cmd *cmd)
+static int labpc_use_continuous_mode(const struct comedi_cmd *cmd,
+				     enum scan_mode mode)
 {
-	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN)
+	if (mode == MODE_SINGLE_CHAN)
 		return 1;
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW)
@@ -922,24 +923,25 @@ static int labpc_use_continuous_mode(const struct comedi_cmd *cmd)
 	return 0;
 }
 
-static unsigned int labpc_ai_convert_period(const struct comedi_cmd *cmd)
+static unsigned int labpc_ai_convert_period(const struct comedi_cmd *cmd,
+					    enum scan_mode mode)
 {
 	if (cmd->convert_src != TRIG_TIMER)
 		return 0;
 
-	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
-	    cmd->scan_begin_src == TRIG_TIMER)
+	if (mode == MODE_SINGLE_CHAN && cmd->scan_begin_src == TRIG_TIMER)
 		return cmd->scan_begin_arg;
 
 	return cmd->convert_arg;
 }
 
-static void labpc_set_ai_convert_period(struct comedi_cmd *cmd, unsigned int ns)
+static void labpc_set_ai_convert_period(struct comedi_cmd *cmd,
+					enum scan_mode mode, unsigned int ns)
 {
 	if (cmd->convert_src != TRIG_TIMER)
 		return;
 
-	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
+	if (mode == MODE_SINGLE_CHAN &&
 	    cmd->scan_begin_src == TRIG_TIMER) {
 		cmd->scan_begin_arg = ns;
 		if (cmd->convert_arg > cmd->scan_begin_arg)
@@ -948,25 +950,25 @@ static void labpc_set_ai_convert_period(struct comedi_cmd *cmd, unsigned int ns)
 		cmd->convert_arg = ns;
 }
 
-static unsigned int labpc_ai_scan_period(const struct comedi_cmd *cmd)
+static unsigned int labpc_ai_scan_period(const struct comedi_cmd *cmd,
+					enum scan_mode mode)
 {
 	if (cmd->scan_begin_src != TRIG_TIMER)
 		return 0;
 
-	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
-	    cmd->convert_src == TRIG_TIMER)
+	if (mode == MODE_SINGLE_CHAN && cmd->convert_src == TRIG_TIMER)
 		return 0;
 
 	return cmd->scan_begin_arg;
 }
 
-static void labpc_set_ai_scan_period(struct comedi_cmd *cmd, unsigned int ns)
+static void labpc_set_ai_scan_period(struct comedi_cmd *cmd,
+				     enum scan_mode mode, unsigned int ns)
 {
 	if (cmd->scan_begin_src != TRIG_TIMER)
 		return;
 
-	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
-	    cmd->convert_src == TRIG_TIMER)
+	if (mode == MODE_SINGLE_CHAN && cmd->convert_src == TRIG_TIMER)
 		return;
 
 	cmd->scan_begin_arg = ns;
@@ -978,6 +980,7 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 	int err = 0;
 	int tmp, tmp2;
 	int stop_mask;
+	enum scan_mode mode;
 
 	/* step 1: make sure trigger sources are trivially valid */
 
@@ -1099,14 +1102,15 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 
 	tmp = cmd->convert_arg;
 	tmp2 = cmd->scan_begin_arg;
-	labpc_adc_timing(dev, cmd);
+	mode = labpc_ai_scan_mode(cmd);
+	labpc_adc_timing(dev, cmd, mode);
 	if (tmp != cmd->convert_arg || tmp2 != cmd->scan_begin_arg)
 		err++;
 
 	if (err)
 		return 4;
 
-	if (labpc_ai_chanlist_invalid(dev, cmd))
+	if (labpc_ai_chanlist_invalid(dev, cmd, mode))
 		return 5;
 
 	return 0;
@@ -1122,6 +1126,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	enum transfer_type xfer;
+	enum scan_mode mode;
 	unsigned long flags;
 
 	if (!dev->irq) {
@@ -1187,6 +1192,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	} else
 		xfer = fifo_not_empty_transfer;
 	devpriv->current_transfer = xfer;
+	mode = labpc_ai_scan_mode(cmd);
 
 	/*  setup command6 register for 1200 boards */
 	if (thisboard->register_layout == labpc_1200_layout) {
@@ -1211,7 +1217,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		else
 			devpriv->command6_bits &= ~A1_INTR_EN_BIT;
 		/*  are we scanning up or down through channels? */
-		if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP)
+		if (mode == MODE_MULT_CHAN_UP)
 			devpriv->command6_bits |= ADC_SCAN_UP_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_SCAN_UP_BIT;
@@ -1222,19 +1228,18 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* setup channel list, etc (command1 register) */
 	devpriv->command1_bits = 0;
-	if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP)
+	if (mode == MODE_MULT_CHAN_UP)
 		channel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);
 	else
 		channel = CR_CHAN(cmd->chanlist[0]);
 	/* munge channel bits for differential / scan disabled mode */
-	if (labpc_ai_scan_mode(cmd) != MODE_SINGLE_CHAN && aref == AREF_DIFF)
+	if (mode != MODE_SINGLE_CHAN && aref == AREF_DIFF)
 		channel *= 2;
 	devpriv->command1_bits |= ADC_CHAN_BITS(channel);
 	devpriv->command1_bits |= thisboard->ai_range_code[range];
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
 	/* manual says to set scan enable bit on second pass */
-	if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP ||
-	    labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_DOWN) {
+	if (mode == MODE_MULT_CHAN_UP || mode == MODE_MULT_CHAN_DOWN) {
 		devpriv->command1_bits |= ADC_SCAN_EN_BIT;
 		/* need a brief delay before enabling scan, or scan
 		 * list will get screwed when you switch
@@ -1249,7 +1254,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
 	/* XXX should discard first scan when using interval scanning
 	 * since manual says it is not synced with scan clock */
-	if (labpc_use_continuous_mode(cmd) == 0) {
+	if (labpc_use_continuous_mode(cmd, mode) == 0) {
 		devpriv->command4_bits |= INTERVAL_SCAN_EN_BIT;
 		if (cmd->scan_begin_src == TRIG_EXT)
 			devpriv->command4_bits |= EXT_SCAN_EN_BIT;
@@ -1267,7 +1272,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (cmd->convert_src == TRIG_TIMER || cmd->scan_begin_src == TRIG_TIMER) {
 		/*  set up pacing */
-		labpc_adc_timing(dev, cmd);
+		labpc_adc_timing(dev, cmd, mode);
 		/*  load counter b0 in mode 3 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
 					 0, devpriv->divisor_b0, 3);
@@ -1277,7 +1282,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		}
 	}
 	/*  set up conversion pacing */
-	if (labpc_ai_convert_period(cmd)) {
+	if (labpc_ai_convert_period(cmd, mode)) {
 		/*  load counter a0 in mode 2 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
 					 0, devpriv->divisor_a0, 2);
@@ -1290,7 +1295,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				    dev->iobase + COUNTER_A_CONTROL_REG);
 
 	/*  set up scan pacing */
-	if (labpc_ai_scan_period(cmd)) {
+	if (labpc_ai_scan_period(cmd, mode)) {
 		/*  load counter b1 in mode 2 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
 					 1, devpriv->divisor_b1, 2);
@@ -1791,24 +1796,29 @@ static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd)
 #endif
 
 /* figures out what counter values to use based on command */
-static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
+static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,
+			     enum scan_mode mode)
 {
 	/* max value for 16 bit counter in mode 2 */
 	const int max_counter_value = 0x10000;
 	/* min value for 16 bit counter in mode 2 */
 	const int min_counter_value = 2;
 	unsigned int base_period;
+	unsigned int scan_period;
+	unsigned int convert_period;
 
 	/*
 	 * if both convert and scan triggers are TRIG_TIMER, then they
 	 * both rely on counter b0
 	 */
-	if (labpc_ai_convert_period(cmd) && labpc_ai_scan_period(cmd)) {
+	convert_period = labpc_ai_convert_period(cmd, mode);
+	scan_period = labpc_ai_scan_period(cmd, mode);
+	if (convert_period && scan_period) {
 		/*
 		 * pick the lowest b0 divisor value we can (for maximum input
 		 * clock speed on convert and scan counters)
 		 */
-		devpriv->divisor_b0 = (labpc_ai_scan_period(cmd) - 1) /
+		devpriv->divisor_b0 = (scan_period - 1) /
 		    (LABPC_TIMER_BASE * max_counter_value) + 1;
 		if (devpriv->divisor_b0 < min_counter_value)
 			devpriv->divisor_b0 = min_counter_value;
@@ -1822,25 +1832,19 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 		default:
 		case TRIG_ROUND_NEAREST:
 			devpriv->divisor_a0 =
-			    (labpc_ai_convert_period(cmd) +
-			     (base_period / 2)) / base_period;
+			    (convert_period + (base_period / 2)) / base_period;
 			devpriv->divisor_b1 =
-			    (labpc_ai_scan_period(cmd) +
-			     (base_period / 2)) / base_period;
+			    (scan_period + (base_period / 2)) / base_period;
 			break;
 		case TRIG_ROUND_UP:
 			devpriv->divisor_a0 =
-			    (labpc_ai_convert_period(cmd) + (base_period -
-							     1)) / base_period;
+			    (convert_period + (base_period - 1)) / base_period;
 			devpriv->divisor_b1 =
-			    (labpc_ai_scan_period(cmd) + (base_period -
-							  1)) / base_period;
+			    (scan_period + (base_period - 1)) / base_period;
 			break;
 		case TRIG_ROUND_DOWN:
-			devpriv->divisor_a0 =
-			    labpc_ai_convert_period(cmd) / base_period;
-			devpriv->divisor_b1 =
-			    labpc_ai_scan_period(cmd) / base_period;
+			devpriv->divisor_a0 = convert_period / base_period;
+			devpriv->divisor_b1 = scan_period / base_period;
 			break;
 		}
 		/*  make sure a0 and b1 values are acceptable */
@@ -1853,18 +1857,15 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 		if (devpriv->divisor_b1 > max_counter_value)
 			devpriv->divisor_b1 = max_counter_value;
 		/*  write corrected timings to command */
-		labpc_set_ai_convert_period(cmd,
+		labpc_set_ai_convert_period(cmd, mode,
 					    base_period * devpriv->divisor_a0);
-		labpc_set_ai_scan_period(cmd,
+		labpc_set_ai_scan_period(cmd, mode,
 					 base_period * devpriv->divisor_b1);
 		/*
 		 * if only one TRIG_TIMER is used, we can employ the generic
 		 * cascaded timing functions
 		 */
-	} else if (labpc_ai_scan_period(cmd)) {
-		unsigned int scan_period;
-
-		scan_period = labpc_ai_scan_period(cmd);
+	} else if (scan_period) {
 		/*
 		 * calculate cascaded counter values
 		 * that give desired scan timing
@@ -1874,11 +1875,8 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 					       &(devpriv->divisor_b0),
 					       &scan_period,
 					       cmd->flags & TRIG_ROUND_MASK);
-		labpc_set_ai_scan_period(cmd, scan_period);
-	} else if (labpc_ai_convert_period(cmd)) {
-		unsigned int convert_period;
-
-		convert_period = labpc_ai_convert_period(cmd);
+		labpc_set_ai_scan_period(cmd, mode, scan_period);
+	} else if (convert_period) {
 		/*
 		 * calculate cascaded counter values
 		 * that give desired conversion timing
@@ -1888,7 +1886,7 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 					       &(devpriv->divisor_b0),
 					       &convert_period,
 					       cmd->flags & TRIG_ROUND_MASK);
-		labpc_set_ai_convert_period(cmd, convert_period);
+		labpc_set_ai_convert_period(cmd, mode, convert_period);
 	}
 }
 

commit 5743aaac2938eb841e14879b0f73afb7fca6f0ad
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 17:06:47 2012 -0700

    staging: comedi: 8253: mmio address is a void __iomem *
    
    The inline functions for accessing a memory mapped 8254 device
    are using a void * for the 'base_address' of the device. Memory
    mapped io using the read/write functions should be using a
    void __iomem * for the address.
    
    Fixing these exposed a couple other void * / void __iomem *
    issues in the ni_labpc driver.
    
    This fixes a number of sparse warnings like:
    
      warning: incorrect type in argument 2 (different address spaces)
         expected void volatile [noderef] <asn:2>*addr
         got void *
    
      warning: incorrect type in argument 1 (different address spaces)
         expected void const volatile [noderef] <asn:2>*addr
         got void *<noident>
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 295ddbb4d586..2d060b5cc1b7 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -409,12 +409,12 @@ static inline void labpc_outb(unsigned int byte, unsigned long address)
 
 static inline unsigned int labpc_readb(unsigned long address)
 {
-	return readb((void *)address);
+	return readb((void __iomem *)address);
 }
 
 static inline void labpc_writeb(unsigned int byte, unsigned long address)
 {
-	writeb(byte, (void *)address);
+	writeb(byte, (void __iomem *)address);
 }
 
 static const struct labpc_board_struct labpc_boards[] = {
@@ -494,8 +494,8 @@ static inline int labpc_counter_load(struct comedi_device *dev,
 				     unsigned int count, unsigned int mode)
 {
 	if (thisboard->memory_mapped_io)
-		return i8254_mm_load((void *)base_address, 0, counter_number,
-				     count, mode);
+		return i8254_mm_load((void __iomem *)base_address, 0,
+				     counter_number, count, mode);
 	else
 		return i8254_load(base_address, 0, counter_number, count, mode);
 }
@@ -1896,10 +1896,10 @@ static int labpc_dio_mem_callback(int dir, int port, int data,
 				  unsigned long iobase)
 {
 	if (dir) {
-		writeb(data, (void *)(iobase + port));
+		writeb(data, (void __iomem *)(iobase + port));
 		return 0;
 	} else {
-		return readb((void *)(iobase + port));
+		return readb((void __iomem *)(iobase + port));
 	}
 }
 

commit e4ff75b58a2475c9aafe1d137aa81bcba90aa379
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Sep 14 17:34:31 2012 +0100

    staging: comedi: ni_labpc: use mite_alloc()
    
    Allocate `struct mite_device` dynamically instead of searching for
    one on the `mite_devices` list constructed by the "mite" module.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 7d36c2c68c50..295ddbb4d586 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -696,20 +696,6 @@ labpc_pci_find_boardinfo(struct pci_dev *pcidev)
 	return NULL;
 }
 
-/* FIXME: remove this when dynamic MITE allocation implemented. */
-static struct mite_struct *labpc_pci_find_mite(struct pci_dev *pcidev)
-{
-	struct mite_struct *mite;
-
-	for (mite = mite_devices; mite; mite = mite->next) {
-		if (mite->used)
-			continue;
-		if (mite->pcidev == pcidev)
-			return mite;
-	}
-	return NULL;
-}
-
 static int __devinit labpc_attach_pci(struct comedi_device *dev,
 				      struct pci_dev *pcidev)
 {
@@ -725,9 +711,9 @@ static int __devinit labpc_attach_pci(struct comedi_device *dev,
 	dev->board_ptr = labpc_pci_find_boardinfo(pcidev);
 	if (!dev->board_ptr)
 		return -ENODEV;
-	devpriv->mite = labpc_pci_find_mite(pcidev);
+	devpriv->mite = mite_alloc(pcidev);
 	if (!devpriv->mite)
-		return -ENODEV;
+		return -ENOMEM;
 	ret = mite_setup(devpriv->mite);
 	if (ret < 0)
 		return ret;
@@ -800,8 +786,10 @@ void labpc_common_detach(struct comedi_device *dev)
 	if (thisboard->bustype == isa_bustype && dev->iobase)
 		release_region(dev->iobase, LABPC_SIZE);
 #ifdef CONFIG_COMEDI_PCI_DRIVERS
-	if (devpriv->mite)
+	if (devpriv->mite) {
 		mite_unsetup(devpriv->mite);
+		mite_free(devpriv->mite);
+	}
 #endif
 };
 EXPORT_SYMBOL_GPL(labpc_common_detach);

commit 7e2716cdc34778ea989093b2308bf62fc12da810
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Sep 14 17:34:14 2012 +0100

    staging: comedi: ni_labpc: use comedi attach_pci callback
    
    Convert this PCI driver to use the comedi `attach_pci` callback instead
    of the `attach` callback for PCI auto-configuration.  Remove support for
    manual attachment of PCI boards supported by this driver.  The `attach`
    callback is still needed to manually attach ISA boards, but print an
    error if an attempt is made to manually attach a PCI board.
    
    Note that this driver still uses the list of PCI "mite" devices created
    by the "mite" module.  This will be dealt with by a later patch once
    dynamic allocation of "mite" structures has been implemented.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 72a75a022786..7d36c2c68c50 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -240,9 +240,6 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd);
 #ifdef CONFIG_ISA_DMA_API
 static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd);
 #endif
-#ifdef CONFIG_COMEDI_PCI_DRIVERS
-static int labpc_find_device(struct comedi_device *dev, int bus, int slot);
-#endif
 static int labpc_dio_mem_callback(int dir, int port, int data,
 				  unsigned long arg);
 static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
@@ -684,14 +681,66 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 }
 EXPORT_SYMBOL_GPL(labpc_common_attach);
 
+static const struct labpc_board_struct *
+labpc_pci_find_boardinfo(struct pci_dev *pcidev)
+{
+	unsigned int device_id = pcidev->device;
+	unsigned int n;
+
+	for (n = 0; n < ARRAY_SIZE(labpc_boards); n++) {
+		const struct labpc_board_struct *board = &labpc_boards[n];
+		if (board->bustype == pci_bustype &&
+		    board->device_id == device_id)
+			return board;
+	}
+	return NULL;
+}
+
+/* FIXME: remove this when dynamic MITE allocation implemented. */
+static struct mite_struct *labpc_pci_find_mite(struct pci_dev *pcidev)
+{
+	struct mite_struct *mite;
+
+	for (mite = mite_devices; mite; mite = mite->next) {
+		if (mite->used)
+			continue;
+		if (mite->pcidev == pcidev)
+			return mite;
+	}
+	return NULL;
+}
+
+static int __devinit labpc_attach_pci(struct comedi_device *dev,
+				      struct pci_dev *pcidev)
+{
+	unsigned long iobase;
+	unsigned int irq;
+	int ret;
+
+	if (!IS_ENABLED(CONFIG_COMEDI_PCI_DRIVERS))
+		return -ENODEV;
+	ret = alloc_private(dev, sizeof(struct labpc_private));
+	if (ret < 0)
+		return ret;
+	dev->board_ptr = labpc_pci_find_boardinfo(pcidev);
+	if (!dev->board_ptr)
+		return -ENODEV;
+	devpriv->mite = labpc_pci_find_mite(pcidev);
+	if (!devpriv->mite)
+		return -ENODEV;
+	ret = mite_setup(devpriv->mite);
+	if (ret < 0)
+		return ret;
+	iobase = (unsigned long)devpriv->mite->daq_io_addr;
+	irq = mite_irq(devpriv->mite);
+	return labpc_common_attach(dev, iobase, irq, 0);
+}
+
 static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	unsigned long iobase = 0;
 	unsigned int irq = 0;
 	unsigned int dma_chan = 0;
-#ifdef CONFIG_COMEDI_PCI_DRIVERS
-	int retval;
-#endif
 
 	/* allocate and initialize dev->private */
 	if (alloc_private(dev, sizeof(struct labpc_private)) < 0)
@@ -712,14 +761,10 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		break;
 	case pci_bustype:
 #ifdef CONFIG_COMEDI_PCI_DRIVERS
-		retval = labpc_find_device(dev, it->options[0], it->options[1]);
-		if (retval < 0)
-			return retval;
-		retval = mite_setup(devpriv->mite);
-		if (retval < 0)
-			return retval;
-		iobase = (unsigned long)devpriv->mite->daq_io_addr;
-		irq = mite_irq(devpriv->mite);
+		dev_err(dev->class_dev,
+			"manual configuration of PCI board '%s' is not supported\n",
+			thisboard->name);
+		return -EINVAL;
 #else
 		dev_err(dev->class_dev,
 			"ni_labpc driver has not been built with PCI support.\n");
@@ -736,38 +781,6 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return labpc_common_attach(dev, iobase, irq, dma_chan);
 }
 
-/* adapted from ni_pcimio for finding mite based boards (pc-1200) */
-#ifdef CONFIG_COMEDI_PCI_DRIVERS
-static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
-{
-	struct mite_struct *mite;
-	int i;
-	for (mite = mite_devices; mite; mite = mite->next) {
-		if (mite->used)
-			continue;
-/* if bus/slot are specified then make sure we have the right bus/slot */
-		if (bus || slot) {
-			if (bus != mite->pcidev->bus->number
-			    || slot != PCI_SLOT(mite->pcidev->devfn))
-				continue;
-		}
-		for (i = 0; i < ARRAY_SIZE(labpc_boards); i++) {
-			if (labpc_boards[i].bustype != pci_bustype)
-				continue;
-			if (mite_device_id(mite) == labpc_boards[i].device_id) {
-				devpriv->mite = mite;
-/* fixup board pointer, in case we were using the dummy "ni_labpc" entry */
-				dev->board_ptr = &labpc_boards[i];
-				return 0;
-			}
-		}
-	}
-	dev_err(dev->class_dev, "no device found\n");
-	mite_list_devices();
-	return -EIO;
-}
-#endif
-
 void labpc_common_detach(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s;
@@ -2105,6 +2118,7 @@ static struct comedi_driver labpc_driver = {
 	.driver_name = DRV_NAME,
 	.module = THIS_MODULE,
 	.attach = labpc_attach,
+	.attach_pci = labpc_attach_pci,
 	.detach = labpc_common_detach,
 	.num_names = ARRAY_SIZE(labpc_boards),
 	.board_name = &labpc_boards[0].name,

commit 5e51f0db14b4a2013f4f64885191076475c5b86f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Sep 14 17:34:13 2012 +0100

    staging: comedi: ni_labpc: move labpc_driver and labpc_pci_table
    
    Move the `labpc_driver` and `labpc_pci_table` variables nearer the
    module initialization code near the bottom of the module for aesthetic
    reasons and to avoid a forward declaration of `labpc_attach()`.
    
    As a consequence, to avoid having to add a forward declaration of the
    `labpc_driver` variable, change code that uses
    `labpc_driver.driver_name` to use `DRV_NAME` instead, and change code
    that uses `labpc_driver.num_names` to use `ARRAY_SIZE(labpc_boards)`
    instead.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 3b1e47ec8535..72a75a022786 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -206,7 +206,6 @@ NI manuals:
 #define   INIT_A1_BITS	0x70
 #define COUNTER_B_BASE_REG	0x18
 
-static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static irqreturn_t labpc_interrupt(int irq, void *d);
 static int labpc_drain_fifo(struct comedi_device *dev);
@@ -492,25 +491,6 @@ static const int sample_size = 2;
 
 #define devpriv ((struct labpc_private *)dev->private)
 
-static struct comedi_driver labpc_driver = {
-	.driver_name = DRV_NAME,
-	.module = THIS_MODULE,
-	.attach = labpc_attach,
-	.detach = labpc_common_detach,
-	.num_names = ARRAY_SIZE(labpc_boards),
-	.board_name = &labpc_boards[0].name,
-	.offset = sizeof(struct labpc_board_struct),
-};
-
-#ifdef CONFIG_COMEDI_PCI_DRIVERS
-static DEFINE_PCI_DEVICE_TABLE(labpc_pci_table) = {
-	{PCI_DEVICE(PCI_VENDOR_ID_NI, 0x161)},
-	{0}
-};
-
-MODULE_DEVICE_TABLE(pci, labpc_pci_table);
-#endif /* CONFIG_COMEDI_PCI_DRIVERS */
-
 static inline int labpc_counter_load(struct comedi_device *dev,
 				     unsigned long base_address,
 				     unsigned int counter_number,
@@ -543,8 +523,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	/*  request io regions for isa boards */
 	if (thisboard->bustype == isa_bustype) {
 		/* check if io addresses are available */
-		if (!request_region(iobase, LABPC_SIZE,
-				    labpc_driver.driver_name)) {
+		if (!request_region(iobase, LABPC_SIZE, DRV_NAME)) {
 			dev_err(dev->class_dev, "I/O port conflict\n");
 			return -EIO;
 		}
@@ -577,7 +556,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		    || thisboard->bustype == pcmcia_bustype)
 			isr_flags |= IRQF_SHARED;
 		if (request_irq(irq, labpc_interrupt, isr_flags,
-				labpc_driver.driver_name, dev)) {
+				DRV_NAME, dev)) {
 			dev_err(dev->class_dev, "unable to allocate irq %u\n",
 				irq);
 			return -EINVAL;
@@ -599,7 +578,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 				"failed to allocate dma buffer\n");
 			return -ENOMEM;
 		}
-		if (request_dma(dma_chan, labpc_driver.driver_name)) {
+		if (request_dma(dma_chan, DRV_NAME)) {
 			dev_err(dev->class_dev,
 				"failed to allocate dma channel %u\n",
 				dma_chan);
@@ -772,7 +751,7 @@ static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 			    || slot != PCI_SLOT(mite->pcidev->devfn))
 				continue;
 		}
-		for (i = 0; i < labpc_driver.num_names; i++) {
+		for (i = 0; i < ARRAY_SIZE(labpc_boards); i++) {
 			if (labpc_boards[i].bustype != pci_bustype)
 				continue;
 			if (mite_device_id(mite) == labpc_boards[i].device_id) {
@@ -2122,7 +2101,23 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 }
 
+static struct comedi_driver labpc_driver = {
+	.driver_name = DRV_NAME,
+	.module = THIS_MODULE,
+	.attach = labpc_attach,
+	.detach = labpc_common_detach,
+	.num_names = ARRAY_SIZE(labpc_boards),
+	.board_name = &labpc_boards[0].name,
+	.offset = sizeof(struct labpc_board_struct),
+};
+
 #ifdef CONFIG_COMEDI_PCI_DRIVERS
+static DEFINE_PCI_DEVICE_TABLE(labpc_pci_table) = {
+	{PCI_DEVICE(PCI_VENDOR_ID_NI, 0x161)},
+	{0}
+};
+MODULE_DEVICE_TABLE(pci, labpc_pci_table);
+
 static int __devinit labpc_pci_probe(struct pci_dev *dev,
 				     const struct pci_device_id *ent)
 {

commit 3faeeecbc85c7f4a2867bcdc65b8a598e2f4aa83
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Sep 14 17:34:12 2012 +0100

    staging: comedi: ni_labpc: use module_comedi_pci_driver()
    
    Use the macro `module_comedi_pci_driver(comedi_driver, pci_driver)` to
    register the module as a Comedi PCI driver if the module supports PCI
    devices, otherwise use `module_comedi_driver(comedi_driver)` to register
    it as an ordinary Comedi driver.  Rename variables and functions that
    have prefix `driver_` for consistency.  Set the `name` member of the
    `struct pci_driver` variable in its initializer instead of initializing
    it in the module initialization function.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 8f835b68ad79..3b1e47ec8535 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -492,7 +492,7 @@ static const int sample_size = 2;
 
 #define devpriv ((struct labpc_private *)dev->private)
 
-static struct comedi_driver driver_labpc = {
+static struct comedi_driver labpc_driver = {
 	.driver_name = DRV_NAME,
 	.module = THIS_MODULE,
 	.attach = labpc_attach,
@@ -544,7 +544,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	if (thisboard->bustype == isa_bustype) {
 		/* check if io addresses are available */
 		if (!request_region(iobase, LABPC_SIZE,
-				    driver_labpc.driver_name)) {
+				    labpc_driver.driver_name)) {
 			dev_err(dev->class_dev, "I/O port conflict\n");
 			return -EIO;
 		}
@@ -577,7 +577,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		    || thisboard->bustype == pcmcia_bustype)
 			isr_flags |= IRQF_SHARED;
 		if (request_irq(irq, labpc_interrupt, isr_flags,
-				driver_labpc.driver_name, dev)) {
+				labpc_driver.driver_name, dev)) {
 			dev_err(dev->class_dev, "unable to allocate irq %u\n",
 				irq);
 			return -EINVAL;
@@ -599,7 +599,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 				"failed to allocate dma buffer\n");
 			return -ENOMEM;
 		}
-		if (request_dma(dma_chan, driver_labpc.driver_name)) {
+		if (request_dma(dma_chan, labpc_driver.driver_name)) {
 			dev_err(dev->class_dev,
 				"failed to allocate dma channel %u\n",
 				dma_chan);
@@ -772,7 +772,7 @@ static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 			    || slot != PCI_SLOT(mite->pcidev->devfn))
 				continue;
 		}
-		for (i = 0; i < driver_labpc.num_names; i++) {
+		for (i = 0; i < labpc_driver.num_names; i++) {
 			if (labpc_boards[i].bustype != pci_bustype)
 				continue;
 			if (mite_device_id(mite) == labpc_boards[i].device_id) {
@@ -2123,56 +2123,26 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 }
 
 #ifdef CONFIG_COMEDI_PCI_DRIVERS
-static int __devinit driver_labpc_pci_probe(struct pci_dev *dev,
-					    const struct pci_device_id *ent)
+static int __devinit labpc_pci_probe(struct pci_dev *dev,
+				     const struct pci_device_id *ent)
 {
-	return comedi_pci_auto_config(dev, &driver_labpc);
+	return comedi_pci_auto_config(dev, &labpc_driver);
 }
 
-static void __devexit driver_labpc_pci_remove(struct pci_dev *dev)
+static void __devexit labpc_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }
 
-static struct pci_driver driver_labpc_pci_driver = {
+static struct pci_driver labpc_pci_driver = {
+	.name = DRV_NAME,
 	.id_table = labpc_pci_table,
-	.probe = &driver_labpc_pci_probe,
-	.remove = __devexit_p(&driver_labpc_pci_remove)
+	.probe = labpc_pci_probe,
+	.remove = __devexit_p(labpc_pci_remove)
 };
-
-static int __init driver_labpc_init_module(void)
-{
-	int retval;
-
-	retval = comedi_driver_register(&driver_labpc);
-	if (retval < 0)
-		return retval;
-
-	driver_labpc_pci_driver.name = (char *)driver_labpc.driver_name;
-	return pci_register_driver(&driver_labpc_pci_driver);
-}
-
-static void __exit driver_labpc_cleanup_module(void)
-{
-	pci_unregister_driver(&driver_labpc_pci_driver);
-	comedi_driver_unregister(&driver_labpc);
-}
-
-module_init(driver_labpc_init_module);
-module_exit(driver_labpc_cleanup_module);
+module_comedi_pci_driver(labpc_driver, labpc_pci_driver);
 #else
-static int __init driver_labpc_init_module(void)
-{
-	return comedi_driver_register(&driver_labpc);
-}
-
-static void __exit driver_labpc_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_labpc);
-}
-
-module_init(driver_labpc_init_module);
-module_exit(driver_labpc_cleanup_module);
+module_comedi_driver(labpc_driver);
 #endif
 
 

commit 1cabcd3164029da5f718f0c9807bcc108b63cb7b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Sep 14 17:34:11 2012 +0100

    staging: comedi: ni_labpc: convert printk() to dev_...()
    
    Convert the `printk()` calls in this driver to use the `dev_...()` calls
    where possible, or the `pr_...()` calls otherwise.  Remove the ifdefed
    out code that prints the EEPROM contents.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 65d5dfcc7941..8f835b68ad79 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -73,9 +73,6 @@ NI manuals:
 
 */
 
-#undef LABPC_DEBUG
-/* #define LABPC_DEBUG    enable debugging messages */
-
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/io.h>
@@ -538,17 +535,9 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	short lsb, msb;
 	int ret;
 
-	printk(KERN_ERR "comedi%d: ni_labpc: %s, io 0x%lx", dev->minor,
-								thisboard->name,
-	       iobase);
-	if (irq)
-		printk(", irq %u", irq);
-	if (dma_chan)
-		printk(", dma %u", dma_chan);
-	printk("\n");
-
+	dev_info(dev->class_dev, "ni_labpc: %s\n", thisboard->name);
 	if (iobase == 0) {
-		printk(KERN_ERR "io base address is zero!\n");
+		dev_err(dev->class_dev, "io base address is zero!\n");
 		return -EINVAL;
 	}
 	/*  request io regions for isa boards */
@@ -556,7 +545,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		/* check if io addresses are available */
 		if (!request_region(iobase, LABPC_SIZE,
 				    driver_labpc.driver_name)) {
-			printk(KERN_ERR "I/O port conflict\n");
+			dev_err(dev->class_dev, "I/O port conflict\n");
 			return -EIO;
 		}
 	}
@@ -589,7 +578,8 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 			isr_flags |= IRQF_SHARED;
 		if (request_irq(irq, labpc_interrupt, isr_flags,
 				driver_labpc.driver_name, dev)) {
-			printk(KERN_ERR "unable to allocate irq %u\n", irq);
+			dev_err(dev->class_dev, "unable to allocate irq %u\n",
+				irq);
 			return -EINVAL;
 		}
 	}
@@ -598,19 +588,21 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 #ifdef CONFIG_ISA_DMA_API
 	/* grab dma channel */
 	if (dma_chan > 3) {
-		printk(KERN_ERR " invalid dma channel %u\n", dma_chan);
+		dev_err(dev->class_dev, "invalid dma channel %u\n", dma_chan);
 		return -EINVAL;
 	} else if (dma_chan) {
 		/* allocate dma buffer */
 		devpriv->dma_buffer =
 		    kmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);
 		if (devpriv->dma_buffer == NULL) {
-			printk(KERN_ERR " failed to allocate dma buffer\n");
+			dev_err(dev->class_dev,
+				"failed to allocate dma buffer\n");
 			return -ENOMEM;
 		}
 		if (request_dma(dma_chan, driver_labpc.driver_name)) {
-			printk(KERN_ERR " failed to allocate dma channel %u\n",
-			       dma_chan);
+			dev_err(dev->class_dev,
+				"failed to allocate dma channel %u\n",
+				dma_chan);
 			return -EINVAL;
 		}
 		devpriv->dma_chan = dma_chan;
@@ -706,12 +698,6 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 		for (i = 0; i < EEPROM_SIZE; i++)
 			devpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);
-#ifdef LABPC_DEBUG
-		printk(KERN_ERR " eeprom:");
-		for (i = 0; i < EEPROM_SIZE; i++)
-			printk(" %i:0x%x ", i, devpriv->eeprom_data[i]);
-		printk("\n");
-#endif
 	} else
 		s->type = COMEDI_SUBD_UNUSED;
 
@@ -740,8 +726,8 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		irq = it->options[1];
 		dma_chan = it->options[2];
 #else
-		printk(KERN_ERR " this driver has not been built with ISA DMA "
-								"support.\n");
+		dev_err(dev->class_dev,
+			"ni_labpc driver has not been built with ISA DMA support.\n");
 		return -EINVAL;
 #endif
 		break;
@@ -756,18 +742,14 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		iobase = (unsigned long)devpriv->mite->daq_io_addr;
 		irq = mite_irq(devpriv->mite);
 #else
-		printk(KERN_ERR " this driver has not been built with PCI "
-								"support.\n");
+		dev_err(dev->class_dev,
+			"ni_labpc driver has not been built with PCI support.\n");
 		return -EINVAL;
 #endif
 		break;
-	case pcmcia_bustype:
-		printk
-		    (" this driver does not support pcmcia cards, use ni_labpc_cs.o\n");
-		return -EINVAL;
-		break;
 	default:
-		printk(KERN_ERR "bug! couldn't determine board type\n");
+		dev_err(dev->class_dev,
+			"ni_labpc: bug! couldn't determine board type\n");
 		return -EINVAL;
 		break;
 	}
@@ -801,7 +783,7 @@ static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 			}
 		}
 	}
-	printk(KERN_ERR "no device found\n");
+	dev_err(dev->class_dev, "no device found\n");
 	mite_list_devices();
 	return -EIO;
 }
@@ -872,8 +854,7 @@ static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)
 	if (CR_CHAN(cmd->chanlist[0]) > CR_CHAN(cmd->chanlist[1]))
 		return MODE_MULT_CHAN_DOWN;
 
-	printk(KERN_ERR "ni_labpc: bug! this should never happen\n");
-
+	pr_err("ni_labpc: bug! cannot determine AI scan mode\n");
 	return 0;
 }
 
@@ -928,7 +909,8 @@ static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
 			}
 			break;
 		default:
-			printk(KERN_ERR "ni_labpc: bug! in chanlist check\n");
+			dev_err(dev->class_dev,
+				"ni_labpc: bug! in chanlist check\n");
 			return 1;
 			break;
 		}
@@ -1790,8 +1772,8 @@ static int labpc_eeprom_write_insn(struct comedi_device *dev,
 
 	/*  only allow writes to user area of eeprom */
 	if (channel < 16 || channel > 127) {
-		printk
-		    ("eeprom writes are only allowed to channels 16 through 127 (the pointer and user areas)");
+		dev_dbg(dev->class_dev,
+			"eeprom writes are only allowed to channels 16 through 127 (the pointer and user areas)\n");
 		return -EINVAL;
 	}
 

commit c65e3be19a9c256ce88f057241f5a168aa3bff70
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:49:58 2012 -0700

    staging: comedi: ni_labpc: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index ab8b787c78bb..65d5dfcc7941 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -628,7 +628,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		return ret;
 
 	/* analog input subdevice */
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags =
@@ -643,7 +643,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	s->cancel = labpc_cancel;
 
 	/* analog output */
-	s = dev->subdevices + 1;
+	s = &dev->subdevices[1];
 	if (thisboard->has_ao) {
 		/*
 		 * Could provide command support, except it only has a
@@ -670,7 +670,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	}
 
 	/* 8255 dio */
-	s = dev->subdevices + 2;
+	s = &dev->subdevices[2];
 	/*  if board uses io memory we have to give a custom callback
 	 * function to the 8255 driver */
 	if (thisboard->memory_mapped_io)
@@ -680,7 +680,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		subdev_8255_init(dev, s, NULL, dev->iobase + DIO_BASE_REG);
 
 	/*  calibration subdevices for boards that have one */
-	s = dev->subdevices + 3;
+	s = &dev->subdevices[3];
 	if (thisboard->register_layout == labpc_1200_layout) {
 		s->type = COMEDI_SUBD_CALIB;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
@@ -695,7 +695,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		s->type = COMEDI_SUBD_UNUSED;
 
 	/* EEPROM */
-	s = dev->subdevices + 4;
+	s = &dev->subdevices[4];
 	if (thisboard->register_layout == labpc_1200_layout) {
 		s->type = COMEDI_SUBD_MEMORY;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
@@ -809,8 +809,12 @@ static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 
 void labpc_common_detach(struct comedi_device *dev)
 {
-	if (dev->subdevices)
-		subdev_8255_cleanup(dev, dev->subdevices + 2);
+	struct comedi_subdevice *s;
+
+	if (dev->subdevices) {
+		s = &dev->subdevices[2];
+		subdev_8255_cleanup(dev, s);
+	}
 #ifdef CONFIG_ISA_DMA_API
 	/* only free stuff if it has been allocated by _attach */
 	kfree(devpriv->dma_buffer);

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index a92570f5a7c5..ab8b787c78bb 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -536,6 +536,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	unsigned long dma_flags;
 #endif
 	short lsb, msb;
+	int ret;
 
 	printk(KERN_ERR "comedi%d: ni_labpc: %s, io 0x%lx", dev->minor,
 								thisboard->name,
@@ -622,8 +623,9 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 	dev->board_name = thisboard->name;
 
-	if (comedi_alloc_subdevices(dev, 5) < 0)
-		return -ENOMEM;
+	ret = comedi_alloc_subdevices(dev, 5);
+	if (ret)
+		return ret;
 
 	/* analog input subdevice */
 	s = dev->subdevices + 0;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 1d739b26e678..a92570f5a7c5 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -622,7 +622,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 	dev->board_name = thisboard->name;
 
-	if (alloc_subdevices(dev, 5) < 0)
+	if (comedi_alloc_subdevices(dev, 5) < 0)
 		return -ENOMEM;
 
 	/* analog input subdevice */

commit 513e48f90a9d092ffcf8301b6ed10a8d8a5ebe77
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 5 11:12:18 2012 -0700

    staging: comedi: ni_labpc: unlock spinlock on command error
    
    When starting the acquisition the labpc_ai_cmd function was
    exiting without unlocking the spinlock. This results in a
    sparse warning:
    
    warning: context imbalance in 'labpc_ai_cmd' - different lock contexts for basic block
    
    Add the missing spin_unlock_irqrestore calls.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 53349777246b..1d739b26e678 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1386,6 +1386,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	default:
 		comedi_error(dev, "bug with start_src");
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		return -1;
 		break;
 	}
@@ -1398,6 +1399,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	default:
 		comedi_error(dev, "bug with stop_src");
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		return -1;
 	}
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index b281fc6e6b7d..53349777246b 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -805,13 +805,10 @@ static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 }
 #endif
 
-int labpc_common_detach(struct comedi_device *dev)
+void labpc_common_detach(struct comedi_device *dev)
 {
-	printk(KERN_ERR "comedi%d: ni_labpc: detach\n", dev->minor);
-
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
-
 #ifdef CONFIG_ISA_DMA_API
 	/* only free stuff if it has been allocated by _attach */
 	kfree(devpriv->dma_buffer);
@@ -826,8 +823,6 @@ int labpc_common_detach(struct comedi_device *dev)
 	if (devpriv->mite)
 		mite_unsetup(devpriv->mite);
 #endif
-
-	return 0;
 };
 EXPORT_SYMBOL_GPL(labpc_common_detach);
 

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 721b2be22500..b281fc6e6b7d 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -2141,7 +2141,7 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 static int __devinit driver_labpc_pci_probe(struct pci_dev *dev,
 					    const struct pci_device_id *ent)
 {
-	return comedi_pci_auto_config(dev, driver_labpc.driver_name);
+	return comedi_pci_auto_config(dev, &driver_labpc);
 }
 
 static void __devexit driver_labpc_pci_remove(struct pci_dev *dev)

commit d6aa8366dde1656f859b6ebf5face1718793a467
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Mon Aug 8 16:32:12 2011 -0700

    staging: fix comedi build errors
    
    Fix build errors when CONFIG_COMEDI_PCI_DRIVERS is not enabled
    and CONFIG_COMEDI_PCI_DRIVERS was used where CONFIG_ISA_DMA_API
    should have been used.
    
    drivers/staging/comedi/drivers/ni_labpc.c: In function 'labpc_ai_cmd':
    drivers/staging/comedi/drivers/ni_labpc.c:1351: error: implicit declaration of function 'labpc_suggest_transfer_size'
    drivers/staging/comedi/drivers/ni_labpc.c: At top level:
    drivers/staging/comedi/drivers/ni_labpc.c:1802: error: conflicting types for 'labpc_suggest_transfer_size'
    drivers/staging/comedi/drivers/ni_labpc.c:1351: note: previous implicit declaration of 'labpc_suggest_transfer_size' was here
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 6859af0778cf..721b2be22500 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -241,8 +241,10 @@ static int labpc_eeprom_write_insn(struct comedi_device *dev,
 				   struct comedi_insn *insn,
 				   unsigned int *data);
 static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd);
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_ISA_DMA_API
 static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd);
+#endif
+#ifdef CONFIG_COMEDI_PCI_DRIVERS
 static int labpc_find_device(struct comedi_device *dev, int bus, int slot);
 #endif
 static int labpc_dio_mem_callback(int dir, int port, int data,
@@ -459,7 +461,7 @@ static const struct labpc_board_struct labpc_boards[] = {
 	 .ai_scan_up = 0,
 	 .memory_mapped_io = 0,
 	 },
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_PCI_DRIVERS
 	{
 	 .name = "pci-1200",
 	 .device_id = 0x161,
@@ -503,14 +505,14 @@ static struct comedi_driver driver_labpc = {
 	.offset = sizeof(struct labpc_board_struct),
 };
 
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_PCI_DRIVERS
 static DEFINE_PCI_DEVICE_TABLE(labpc_pci_table) = {
 	{PCI_DEVICE(PCI_VENDOR_ID_NI, 0x161)},
 	{0}
 };
 
 MODULE_DEVICE_TABLE(pci, labpc_pci_table);
-#endif /* CONFIG_COMEDI_PCI */
+#endif /* CONFIG_COMEDI_PCI_DRIVERS */
 
 static inline int labpc_counter_load(struct comedi_device *dev,
 				     unsigned long base_address,
@@ -720,7 +722,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned long iobase = 0;
 	unsigned int irq = 0;
 	unsigned int dma_chan = 0;
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_PCI_DRIVERS
 	int retval;
 #endif
 
@@ -742,7 +744,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 #endif
 		break;
 	case pci_bustype:
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_PCI_DRIVERS
 		retval = labpc_find_device(dev, it->options[0], it->options[1]);
 		if (retval < 0)
 			return retval;
@@ -772,7 +774,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 }
 
 /* adapted from ni_pcimio for finding mite based boards (pc-1200) */
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_PCI_DRIVERS
 static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 {
 	struct mite_struct *mite;
@@ -820,7 +822,7 @@ int labpc_common_detach(struct comedi_device *dev)
 		free_irq(dev->irq, dev);
 	if (thisboard->bustype == isa_bustype && dev->iobase)
 		release_region(dev->iobase, LABPC_SIZE);
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_PCI_DRIVERS
 	if (devpriv->mite)
 		mite_unsetup(devpriv->mite);
 #endif
@@ -2135,7 +2137,7 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 }
 
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_PCI_DRIVERS
 static int __devinit driver_labpc_pci_probe(struct pci_dev *dev,
 					    const struct pci_device_id *ent)
 {

commit 3297d6c7c84a2a3f62b41b703a2963759e822e96
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Sat Jul 2 11:44:36 2011 -0700

    staging: fix comedi NI labpc driver build when ISA_DMA_API is not enabled
    
    Fix ni_labpc.c to build when CONFIG_ISA_DMA_API is not enabled.
    
    This is a driver that supports both ISA and PCI devices.
    It now builds when for PCI-only support or for both
    ISA and PCI device support.
    (It does not support ISA-only without PCI.)
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index f82e732b16f5..6859af0778cf 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -213,8 +213,10 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static irqreturn_t labpc_interrupt(int irq, void *d);
 static int labpc_drain_fifo(struct comedi_device *dev);
+#ifdef CONFIG_ISA_DMA_API
 static void labpc_drain_dma(struct comedi_device *dev);
 static void handle_isa_dma(struct comedi_device *dev);
+#endif
 static void labpc_drain_dregs(struct comedi_device *dev);
 static int labpc_ai_cmdtest(struct comedi_device *dev,
 			    struct comedi_subdevice *s, struct comedi_cmd *cmd);
@@ -238,9 +240,9 @@ static int labpc_eeprom_write_insn(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   struct comedi_insn *insn,
 				   unsigned int *data);
-static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd);
 static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd);
 #ifdef CONFIG_COMEDI_PCI
+static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd);
 static int labpc_find_device(struct comedi_device *dev, int bus, int slot);
 #endif
 static int labpc_dio_mem_callback(int dir, int port, int data,
@@ -527,7 +529,10 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 {
 	struct comedi_subdevice *s;
 	int i;
-	unsigned long dma_flags, isr_flags;
+	unsigned long isr_flags;
+#ifdef CONFIG_ISA_DMA_API
+	unsigned long dma_flags;
+#endif
 	short lsb, msb;
 
 	printk(KERN_ERR "comedi%d: ni_labpc: %s, io 0x%lx", dev->minor,
@@ -587,6 +592,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	}
 	dev->irq = irq;
 
+#ifdef CONFIG_ISA_DMA_API
 	/* grab dma channel */
 	if (dma_chan > 3) {
 		printk(KERN_ERR " invalid dma channel %u\n", dma_chan);
@@ -610,6 +616,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
 		release_dma_lock(dma_flags);
 	}
+#endif
 
 	dev->board_name = thisboard->name;
 
@@ -724,9 +731,15 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* get base address, irq etc. based on bustype */
 	switch (thisboard->bustype) {
 	case isa_bustype:
+#ifdef CONFIG_ISA_DMA_API
 		iobase = it->options[0];
 		irq = it->options[1];
 		dma_chan = it->options[2];
+#else
+		printk(KERN_ERR " this driver has not been built with ISA DMA "
+								"support.\n");
+		return -EINVAL;
+#endif
 		break;
 	case pci_bustype:
 #ifdef CONFIG_COMEDI_PCI
@@ -797,10 +810,12 @@ int labpc_common_detach(struct comedi_device *dev)
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
 
+#ifdef CONFIG_ISA_DMA_API
 	/* only free stuff if it has been allocated by _attach */
 	kfree(devpriv->dma_buffer);
 	if (devpriv->dma_chan)
 		free_dma(devpriv->dma_chan);
+#endif
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (thisboard->bustype == isa_bustype && dev->iobase)
@@ -1135,7 +1150,9 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int channel, range, aref;
+#ifdef CONFIG_ISA_DMA_API
 	unsigned long irq_flags;
+#endif
 	int ret;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1182,6 +1199,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->write_byte(INIT_A1_BITS,
 				    dev->iobase + COUNTER_A_CONTROL_REG);
 
+#ifdef CONFIG_ISA_DMA_API
 	/*  figure out what method we will use to transfer data */
 	if (devpriv->dma_chan &&	/*  need a dma channel allocated */
 		/*
@@ -1193,7 +1211,9 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	    thisboard->bustype == isa_bustype) {
 		xfer = isa_dma_transfer;
 		/* pc-plus has no fifo-half full interrupt */
-	} else if (thisboard->register_layout == labpc_1200_layout &&
+	} else
+#endif
+	if (thisboard->register_layout == labpc_1200_layout &&
 		   /*  wake-end-of-scan should interrupt on fifo not empty */
 		   (cmd->flags & TRIG_WAKE_EOS) == 0 &&
 		   /*  make sure we are taking more than just a few points */
@@ -1317,6 +1337,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	labpc_clear_adc_fifo(dev);
 
+#ifdef CONFIG_ISA_DMA_API
 	/*  set up dma transfer */
 	if (xfer == isa_dma_transfer) {
 		irq_flags = claim_dma_lock();
@@ -1340,6 +1361,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->command3_bits |= DMA_EN_BIT | DMATC_INTR_EN_BIT;
 	} else
 		devpriv->command3_bits &= ~DMA_EN_BIT & ~DMATC_INTR_EN_BIT;
+#endif
 
 	/*  enable error interrupts */
 	devpriv->command3_bits |= ERR_INTR_EN_BIT;
@@ -1426,6 +1448,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
+#ifdef CONFIG_ISA_DMA_API
 	if (devpriv->current_transfer == isa_dma_transfer) {
 		/*
 		 * if a dma terminal count of external stop trigger
@@ -1437,6 +1460,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 			handle_isa_dma(dev);
 		}
 	} else
+#endif
 		labpc_drain_fifo(dev);
 
 	if (devpriv->status1_bits & TIMER_BIT) {
@@ -1509,6 +1533,7 @@ static int labpc_drain_fifo(struct comedi_device *dev)
 	return 0;
 }
 
+#ifdef CONFIG_ISA_DMA_API
 static void labpc_drain_dma(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
@@ -1571,13 +1596,16 @@ static void handle_isa_dma(struct comedi_device *dev)
 	/*  clear dma tc interrupt */
 	devpriv->write_byte(0x1, dev->iobase + DMATC_CLEAR_REG);
 }
+#endif
 
 /* makes sure all data acquired by board is transferred to comedi (used
  * when acquisition is terminated by stop_src == TRIG_EXT). */
 static void labpc_drain_dregs(struct comedi_device *dev)
 {
+#ifdef CONFIG_ISA_DMA_API
 	if (devpriv->current_transfer == isa_dma_transfer)
 		labpc_drain_dma(dev);
+#endif
 
 	labpc_drain_fifo(dev);
 }
@@ -1769,6 +1797,7 @@ static int labpc_eeprom_write_insn(struct comedi_device *dev,
 	return 1;
 }
 
+#ifdef CONFIG_ISA_DMA_API
 /* utility function that suggests a dma transfer size in bytes */
 static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd)
 {
@@ -1792,6 +1821,7 @@ static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd)
 
 	return size;
 }
+#endif
 
 /* figures out what counter values to use based on command */
 static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)

commit 845d131e2b363717d8ac8db2c6b4417de8cf10b5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 9 12:20:28 2011 -0700

    Staging: comedi: add #include <linux/io.h> to a bunch of drivers
    
    On some arches the function virt_to_bus() wasn't being pulled in due to
    include chains being different.  So, as we are explicitly calling this
    function, explicitly include the proper header file so all will build
    properly.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index ab8f37022a3c..f82e732b16f5 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -78,6 +78,7 @@ NI manuals:
 
 #include <linux/interrupt.h>
 #include <linux/slab.h>
+#include <linux/io.h>
 #include "../comedidev.h"
 
 #include <linux/delay.h>

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 241fe525abf0..ab8f37022a3c 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -183,11 +183,11 @@ NI manuals:
 #define   OVERRUN_BIT	0x2
 /* fifo overflow */
 #define   OVERFLOW_BIT	0x4
-/* timer interrupt has occured */
+/* timer interrupt has occurred */
 #define   TIMER_BIT	0x8
-/* dma terminal count has occured */
+/* dma terminal count has occurred */
 #define   DMATC_BIT	0x10
-/* external trigger has occured */
+/* external trigger has occurred */
 #define   EXT_TRIG_BIT	0x40
 /* 1200 boards only */
 #define STATUS2_REG	0x1d
@@ -1149,7 +1149,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	range = CR_RANGE(cmd->chanlist[0]);
 	aref = CR_AREF(cmd->chanlist[0]);
 
-	/* make sure board is disabled before setting up aquisition */
+	/* make sure board is disabled before setting up acquisition */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
@@ -1349,7 +1349,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->command3_bits &= ~ADC_FNE_INTR_EN_BIT;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
-	/*  startup aquisition */
+	/*  startup acquisition */
 
 	/*  command2 reg */
 	/*  use 2 cascaded counters for pacing */
@@ -1571,8 +1571,8 @@ static void handle_isa_dma(struct comedi_device *dev)
 	devpriv->write_byte(0x1, dev->iobase + DMATC_CLEAR_REG);
 }
 
-/* makes sure all data acquired by board is transfered to comedi (used
- * when aquisition is terminated by stop_src == TRIG_EXT). */
+/* makes sure all data acquired by board is transferred to comedi (used
+ * when acquisition is terminated by stop_src == TRIG_EXT). */
 static void labpc_drain_dregs(struct comedi_device *dev)
 {
 	if (devpriv->current_transfer == isa_dma_transfer)

commit e4e1f289be88a75dc8b63d50ade1f9a2e6168021
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Sun Mar 13 00:28:57 2011 -0500

    staging: comedi: Remove NULL check before kfree
    
    This patch was generated by the following semantic patch:
    // <smpl>
    @@ expression E; @@
    - if (E != NULL) { kfree(E); }
    + kfree(E);
    
    @@ expression E; @@
    - if (E != NULL) { kfree(E); E = NULL; }
    + kfree(E);
    + E = NULL;
    // </smpl>
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 0728c3c0cb0e..241fe525abf0 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -797,8 +797,7 @@ int labpc_common_detach(struct comedi_device *dev)
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
 
 	/* only free stuff if it has been allocated by _attach */
-	if (devpriv->dma_buffer)
-		kfree(devpriv->dma_buffer);
+	kfree(devpriv->dma_buffer);
 	if (devpriv->dma_chan)
 		free_dma(devpriv->dma_chan);
 	if (dev->irq)

commit d1ce318496f5943d2cc5e20171fc383a59a1421f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jan 19 11:48:44 2011 +0000

    staging: comedi: ni_labpc: Use shared IRQ for PCMCIA card
    
    The ni_labpc driver module only requests a shared IRQ for PCI devices,
    requesting a non-shared IRQ for non-PCI devices.
    As this module is also used by the ni_labpc_cs module for certain
    National Instruments PCMCIA cards, it also needs to request a shared IRQ
    for PCMCIA devices, otherwise you get a IRQ mismatch with the CardBus
    controller.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 4d1868d04bac..0728c3c0cb0e 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -575,7 +575,8 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	/* grab our IRQ */
 	if (irq) {
 		isr_flags = 0;
-		if (thisboard->bustype == pci_bustype)
+		if (thisboard->bustype == pci_bustype
+		    || thisboard->bustype == pcmcia_bustype)
 			isr_flags |= IRQF_SHARED;
 		if (request_irq(irq, labpc_interrupt, isr_flags,
 				driver_labpc.driver_name, dev)) {

commit e4c5bf8e3dca827a1b3a6fac494eae8c74b7e1e7
Merge: 81280572ca6f a4ac0d847af9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 28 09:44:56 2010 -0700

    Merge 'staging-next' to Linus's tree
    
    This merges the staging-next tree to Linus's tree and resolves
    some conflicts that were present due to changes in other trees that were
    affected by files here.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 631dd1a885b6d7e9f6f51b4e5b311c2bb04c323c
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Oct 18 11:03:14 2010 +0200

    Update broken web addresses in the kernel.
    
    The patch below updates broken web addresses in the kernel
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Finn Thain <fthain@telegraphics.com.au>
    Cc: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Dimitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Mike Frysinger <vapier.adi@gmail.com>
    Acked-by: Ben Pfaff <blp@cs.stanford.edu>
    Acked-by: Hans J. Koch <hjk@linutronix.de>
    Reviewed-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 3acf7e62bec4..1411dd8f4e7c 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -37,7 +37,7 @@ boards has not
 yet been added to the driver, mainly due to the fact that
 I don't know the device id numbers.  If you have one
 of these boards,
-please file a bug report at https://bugs.comedi.org/
+please file a bug report at http://comedi.org/ 
 so I can get the necessary information from you.
 
 The 1200 series boards have onboard calibration dacs for correcting

commit 0656bb352080982f960bfff2b78602a5071c909f
Author: Maurice Dawson <mauricedawson2699@gmail.com>
Date:   Tue Sep 28 17:35:53 2010 +0100

    Staging: comedi: fix EXPORT SYMBOL coding style issue in ni_labpc.c
    
    This is a patch to the ni_labpc.c file that fixes up, EXPORT SYMBOL(foo)
    should immediately follow its function/variable warnings, found by the
    checkpatch.pl tool
    
    Signed-off-by: Maurice Dawson <mauricedawson2699@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 19f79e8c497a..91a43c3110b8 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -345,6 +345,7 @@ const int labpc_1200_is_unipolar[NUM_LABPC_1200_AI_RANGES] = {
 	1,
 	1,
 };
+EXPORT_SYMBOL_GPL(labpc_1200_is_unipolar);
 
 /* map range index to gain bits */
 const int labpc_1200_ai_gain_bits[NUM_LABPC_1200_AI_RANGES] = {
@@ -363,6 +364,7 @@ const int labpc_1200_ai_gain_bits[NUM_LABPC_1200_AI_RANGES] = {
 	0x60,
 	0x70,
 };
+EXPORT_SYMBOL_GPL(labpc_1200_ai_gain_bits);
 
 const struct comedi_lrange range_labpc_1200_ai = {
 	NUM_LABPC_1200_AI_RANGES,
@@ -383,6 +385,7 @@ const struct comedi_lrange range_labpc_1200_ai = {
 	 UNI_RANGE(0.1),
 	 }
 };
+EXPORT_SYMBOL_GPL(range_labpc_1200_ai);
 
 /* analog output ranges */
 #define AO_RANGE_IS_UNIPOLAR 0x1
@@ -701,6 +704,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(labpc_common_attach);
 
 static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
@@ -807,6 +811,7 @@ int labpc_common_detach(struct comedi_device *dev)
 
 	return 0;
 };
+EXPORT_SYMBOL_GPL(labpc_common_detach);
 
 static void labpc_clear_adc_fifo(const struct comedi_device *dev)
 {
@@ -2152,11 +2157,6 @@ module_init(driver_labpc_init_module);
 module_exit(driver_labpc_cleanup_module);
 #endif
 
-EXPORT_SYMBOL_GPL(labpc_common_attach);
-EXPORT_SYMBOL_GPL(labpc_common_detach);
-EXPORT_SYMBOL_GPL(range_labpc_1200_ai);
-EXPORT_SYMBOL_GPL(labpc_1200_ai_gain_bits);
-EXPORT_SYMBOL_GPL(labpc_1200_is_unipolar);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit d6269644e1f8fc7931c4d6b86d58de7af63a5fc9
Author: Julia Lawall <julia@diku.dk>
Date:   Sun Sep 5 21:00:24 2010 +0200

    Staging: comedi: Fix unsigned return type
    
    In each case, the function has an unsigned return type, but returns a
    negative constant to indicate an error condition.  For move_block_from_dma,
    there is only one call and the return value is dropped, so it need not be
    unsigned.  For labpc_eeprom_write, there is only one call and the result is
    stored in a signed variable, so again the unsigned return type is not
    necessary.
    
    A sematic match that finds this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @exists@
    identifier f;
    constant C;
    @@
    
     unsigned f(...)
     { <+...
    *  return -C;
     ...+> }
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 3acf7e62bec4..19f79e8c497a 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -250,7 +250,7 @@ static unsigned int labpc_serial_in(struct comedi_device *dev);
 static unsigned int labpc_eeprom_read(struct comedi_device *dev,
 				      unsigned int address);
 static unsigned int labpc_eeprom_read_status(struct comedi_device *dev);
-static unsigned int labpc_eeprom_write(struct comedi_device *dev,
+static int labpc_eeprom_write(struct comedi_device *dev,
 				       unsigned int address,
 				       unsigned int value);
 static void write_caldac(struct comedi_device *dev, unsigned int channel,
@@ -1986,8 +1986,8 @@ static unsigned int labpc_eeprom_read(struct comedi_device *dev,
 	return value;
 }
 
-static unsigned int labpc_eeprom_write(struct comedi_device *dev,
-				       unsigned int address, unsigned int value)
+static int labpc_eeprom_write(struct comedi_device *dev,
+				unsigned int address, unsigned int value)
 {
 	const int write_enable_instruction = 0x6;
 	const int write_instruction = 0x2;

commit 1309e617bc56f2f8af9a9c5aab1224a45539002a
Author: Maurice Dawson <mauricedawson2699@gmail.com>
Date:   Sat Jun 26 17:02:25 2010 +0100

    Staging: comedi: fix over 80 character coding style issue in ni_labpc.c
    
    This is a patch to the ni_labpc.c file that fixes up 80 character warnings found by the checkpatch.pl tool
    
    Signed-off-by: Maurice Dawson <mauricedawson2699@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 170bab60555a..3acf7e62bec4 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1098,7 +1098,10 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 			err++;
 		}
 		break;
-		/*  TRIG_EXT doesn't care since it doesn't trigger off a numbered channel */
+		/*
+		 * TRIG_EXT doesn't care since it doesn't
+		 * trigger off a numbered channel
+		 */
 	default:
 		break;
 	}
@@ -1156,25 +1159,35 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/*  setup hardware conversion counter */
 	if (cmd->stop_src == TRIG_EXT) {
-		/*  load counter a1 with count of 3 (pc+ manual says this is minimum allowed) using mode 0 */
+		/*
+		 * load counter a1 with count of 3
+		 * (pc+ manual says this is minimum allowed) using mode 0
+		 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
 					 1, 3, 0);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter a1");
 			return -1;
 		}
-	} else			/*  otherwise, just put a1 in mode 0 with no count to set its output low */
+	} else			/*
+				 * otherwise, just put a1 in mode 0
+				 * with no count to set its output low
+				 */
 		devpriv->write_byte(INIT_A1_BITS,
 				    dev->iobase + COUNTER_A_CONTROL_REG);
 
 	/*  figure out what method we will use to transfer data */
 	if (devpriv->dma_chan &&	/*  need a dma channel allocated */
-	    /*  dma unsafe at RT priority, and too much setup time for TRIG_WAKE_EOS for */
+		/*
+		 * dma unsafe at RT priority,
+		 * and too much setup time for TRIG_WAKE_EOS for
+		 */
 	    (cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0 &&
 	    /*  only available on the isa boards */
 	    thisboard->bustype == isa_bustype) {
 		xfer = isa_dma_transfer;
-	} else if (thisboard->register_layout == labpc_1200_layout &&	/*  pc-plus has no fifo-half full interrupt */
+		/* pc-plus has no fifo-half full interrupt */
+	} else if (thisboard->register_layout == labpc_1200_layout &&
 		   /*  wake-end-of-scan should interrupt on fifo not empty */
 		   (cmd->flags & TRIG_WAKE_EOS) == 0 &&
 		   /*  make sure we are taking more than just a few points */
@@ -1621,7 +1634,10 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		devpriv->command4_bits |= ADC_DIFF_BIT;
 	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
 
-	/* initialize pacer counter output to make sure it doesn't cause any problems */
+	/*
+	 * initialize pacer counter output to make sure it doesn't
+	 * cause any problems
+	 */
 	devpriv->write_byte(INIT_A0_BITS, dev->iobase + COUNTER_A_CONTROL_REG);
 
 	labpc_clear_adc_fifo(dev);
@@ -1846,7 +1862,10 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 		unsigned int scan_period;
 
 		scan_period = labpc_ai_scan_period(cmd);
-		/* calculate cascaded counter values that give desired scan timing */
+		/*
+		 * calculate cascaded counter values
+		 * that give desired scan timing
+		 */
 		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
 					       &(devpriv->divisor_b1),
 					       &(devpriv->divisor_b0),
@@ -1857,7 +1876,10 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 		unsigned int convert_period;
 
 		convert_period = labpc_ai_convert_period(cmd);
-		/* calculate cascaded counter values that give desired conversion timing */
+		/*
+		 * calculate cascaded counter values
+		 * that give desired conversion timing
+		 */
 		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
 					       &(devpriv->divisor_a0),
 					       &(devpriv->divisor_b0),

commit 727b286b44ea359d66f47d241cc2cdad36ed7bdc
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:31 2010 +0200

    Staging: comedi: Remove COMEDI_PCI_INITCLEANUP macro
    
    Move the PCI devinit/devexit routines to the respective C source files
    instead of calling COMEDI_PCI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 383ee1024ad3..170bab60555a 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -2078,7 +2078,43 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 }
 
 #ifdef CONFIG_COMEDI_PCI
-COMEDI_PCI_INITCLEANUP(driver_labpc, labpc_pci_table);
+static int __devinit driver_labpc_pci_probe(struct pci_dev *dev,
+					    const struct pci_device_id *ent)
+{
+	return comedi_pci_auto_config(dev, driver_labpc.driver_name);
+}
+
+static void __devexit driver_labpc_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static struct pci_driver driver_labpc_pci_driver = {
+	.id_table = labpc_pci_table,
+	.probe = &driver_labpc_pci_probe,
+	.remove = __devexit_p(&driver_labpc_pci_remove)
+};
+
+static int __init driver_labpc_init_module(void)
+{
+	int retval;
+
+	retval = comedi_driver_register(&driver_labpc);
+	if (retval < 0)
+		return retval;
+
+	driver_labpc_pci_driver.name = (char *)driver_labpc.driver_name;
+	return pci_register_driver(&driver_labpc_pci_driver);
+}
+
+static void __exit driver_labpc_cleanup_module(void)
+{
+	pci_unregister_driver(&driver_labpc_pci_driver);
+	comedi_driver_unregister(&driver_labpc);
+}
+
+module_init(driver_labpc_init_module);
+module_exit(driver_labpc_cleanup_module);
 #else
 static int __init driver_labpc_init_module(void)
 {

commit 7114a28011f9d5f3d981731ad341177c21f9d948
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:30 2010 +0200

    Staging: comedi: Remove COMEDI_INITCLEANUP macro
    
    Move the init/exit routines to the respective C source files
    instead of calling COMEDI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 4966c8e496d5..383ee1024ad3 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -2080,7 +2080,18 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 #ifdef CONFIG_COMEDI_PCI
 COMEDI_PCI_INITCLEANUP(driver_labpc, labpc_pci_table);
 #else
-COMEDI_INITCLEANUP(driver_labpc);
+static int __init driver_labpc_init_module(void)
+{
+	return comedi_driver_register(&driver_labpc);
+}
+
+static void __exit driver_labpc_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver_labpc);
+}
+
+module_init(driver_labpc_init_module);
+module_exit(driver_labpc_cleanup_module);
 #endif
 
 EXPORT_SYMBOL_GPL(labpc_common_attach);

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 0e3ac5a5b050..4966c8e496d5 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -2088,3 +2088,7 @@ EXPORT_SYMBOL_GPL(labpc_common_detach);
 EXPORT_SYMBOL_GPL(range_labpc_1200_ai);
 EXPORT_SYMBOL_GPL(labpc_1200_ai_gain_bits);
 EXPORT_SYMBOL_GPL(labpc_1200_is_unipolar);
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 88d8ed4b643d2064a663b2f07426963289def676
Author: Maurice Dawson <mauricedawson2699@gmail.com>
Date:   Fri Jun 4 13:07:06 2010 +0100

    Staging: comedi: fix printk() coding style issue in ni_labpc.c
    
    This is a patch to the ni_labpc.c file that fixes all, printk() should
    include KERN-facility level, warnings found by the checkpatch.pl tool
    
    Signed-off-by: Maurice Dawson <mauricedawson2699@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 67c8a538802c..0e3ac5a5b050 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -526,7 +526,8 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	unsigned long dma_flags, isr_flags;
 	short lsb, msb;
 
-	printk("comedi%d: ni_labpc: %s, io 0x%lx", dev->minor, thisboard->name,
+	printk(KERN_ERR "comedi%d: ni_labpc: %s, io 0x%lx", dev->minor,
+								thisboard->name,
 	       iobase);
 	if (irq)
 		printk(", irq %u", irq);
@@ -543,7 +544,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		/* check if io addresses are available */
 		if (!request_region(iobase, LABPC_SIZE,
 				    driver_labpc.driver_name)) {
-			printk("I/O port conflict\n");
+			printk(KERN_ERR "I/O port conflict\n");
 			return -EIO;
 		}
 	}
@@ -575,7 +576,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 			isr_flags |= IRQF_SHARED;
 		if (request_irq(irq, labpc_interrupt, isr_flags,
 				driver_labpc.driver_name, dev)) {
-			printk("unable to allocate irq %u\n", irq);
+			printk(KERN_ERR "unable to allocate irq %u\n", irq);
 			return -EINVAL;
 		}
 	}
@@ -583,18 +584,18 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 	/* grab dma channel */
 	if (dma_chan > 3) {
-		printk(" invalid dma channel %u\n", dma_chan);
+		printk(KERN_ERR " invalid dma channel %u\n", dma_chan);
 		return -EINVAL;
 	} else if (dma_chan) {
 		/* allocate dma buffer */
 		devpriv->dma_buffer =
 		    kmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);
 		if (devpriv->dma_buffer == NULL) {
-			printk(" failed to allocate dma buffer\n");
+			printk(KERN_ERR " failed to allocate dma buffer\n");
 			return -ENOMEM;
 		}
 		if (request_dma(dma_chan, driver_labpc.driver_name)) {
-			printk(" failed to allocate dma channel %u\n",
+			printk(KERN_ERR " failed to allocate dma channel %u\n",
 			       dma_chan);
 			return -EINVAL;
 		}
@@ -690,7 +691,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		for (i = 0; i < EEPROM_SIZE; i++)
 			devpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);
 #ifdef LABPC_DEBUG
-		printk(" eeprom:");
+		printk(KERN_ERR " eeprom:");
 		for (i = 0; i < EEPROM_SIZE; i++)
 			printk(" %i:0x%x ", i, devpriv->eeprom_data[i]);
 		printk("\n");
@@ -732,7 +733,8 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		iobase = (unsigned long)devpriv->mite->daq_io_addr;
 		irq = mite_irq(devpriv->mite);
 #else
-		printk(" this driver has not been built with PCI support.\n");
+		printk(KERN_ERR " this driver has not been built with PCI "
+								"support.\n");
 		return -EINVAL;
 #endif
 		break;
@@ -742,7 +744,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EINVAL;
 		break;
 	default:
-		printk("bug! couldn't determine board type\n");
+		printk(KERN_ERR "bug! couldn't determine board type\n");
 		return -EINVAL;
 		break;
 	}
@@ -776,7 +778,7 @@ static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 			}
 		}
 	}
-	printk("no device found\n");
+	printk(KERN_ERR "no device found\n");
 	mite_list_devices();
 	return -EIO;
 }
@@ -784,7 +786,7 @@ static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 
 int labpc_common_detach(struct comedi_device *dev)
 {
-	printk("comedi%d: ni_labpc: detach\n", dev->minor);
+	printk(KERN_ERR "comedi%d: ni_labpc: detach\n", dev->minor);
 
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
@@ -846,7 +848,7 @@ static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)
 	if (CR_CHAN(cmd->chanlist[0]) > CR_CHAN(cmd->chanlist[1]))
 		return MODE_MULT_CHAN_DOWN;
 
-	printk("ni_labpc: bug! this should never happen\n");
+	printk(KERN_ERR "ni_labpc: bug! this should never happen\n");
 
 	return 0;
 }
@@ -902,7 +904,7 @@ static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
 			}
 			break;
 		default:
-			printk("ni_labpc: bug! in chanlist check\n");
+			printk(KERN_ERR "ni_labpc: bug! in chanlist check\n");
 			return 1;
 			break;
 		}

commit 4e40cee9c8a46d4231d28ae7ae6d9938cf0526d5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 30 16:52:52 2010 -0700

    Staging: comedi: use the standard NI pci device id
    
    Don't redefine something that we already have in the core
    kernel.  Also move to use PCI_DEVICE() macros to make things
    a bit simpler when changing the define.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 9b840a96bafa..67c8a538802c 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -499,9 +499,8 @@ static struct comedi_driver driver_labpc = {
 
 #ifdef CONFIG_COMEDI_PCI
 static DEFINE_PCI_DEVICE_TABLE(labpc_pci_table) = {
-	{
-	PCI_VENDOR_ID_NATINST, 0x161, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	0}
+	{PCI_DEVICE(PCI_VENDOR_ID_NI, 0x161)},
+	{0}
 };
 
 MODULE_DEVICE_TABLE(pci, labpc_pci_table);

commit 177d42821e2d662fda5bb57d31d33d215fb74fd0
Author: Aseem Sethi <aseemsethi@yahoo.com>
Date:   Wed Mar 10 00:04:36 2010 +0530

    Staging: comedi: fix missing KERN_facility level in ni_labpc.c
    
    This is a patch to fix the "missing KERN_facility level" error found
    when running the checkpatch.pl script
    
    Signed-off-by: Aseem Sethi <aseemsethi@yahoo.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 558e525fed37..9b840a96bafa 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -536,7 +536,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	printk("\n");
 
 	if (iobase == 0) {
-		printk("io base address is zero!\n");
+		printk(KERN_ERR "io base address is zero!\n");
 		return -EINVAL;
 	}
 	/*  request io regions for isa boards */

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 3c88caaa9dab..558e525fed37 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -77,6 +77,7 @@ NI manuals:
 /* #define LABPC_DEBUG    enable debugging messages */
 
 #include <linux/interrupt.h>
+#include <linux/slab.h>
 #include "../comedidev.h"
 
 #include <linux/delay.h>

commit b02957d58a27525499ab10d272d3b44682a7ae50
Merge: 3a8954e8f22c b94c765ac31f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Mar 4 08:14:54 2010 -0800

    Staging: Merge two branches of coding style fixes together
    
    Turns out that multiple people sent pretty much the same patch
    for the same staging drivers.  Commit these in two different
    branches and merge them together to get a more complete coverage
    of the cleanup and properly credit everyone for the work that they
    did.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 639b9f1ee5987270be2bca4bf8b7e6110d3b47ec
Author: Stewart Robertson <stewart_r@aliencamel.com>
Date:   Sun Feb 21 11:21:37 2010 +0000

    Staging: comedi: fix suspect code indent in ni_labpc.c
    
    This is a patch to the ni_labpc.c file that fixes suspect code indent for
    conditional statements found by the checkpatch.pl tool
    
    Signed-off-by: Stewart Robertson <stewart_r@aliencamel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index d6b5c05ee199..ddc3b0715dc3 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -583,8 +583,11 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	/* analog output */
 	s = dev->subdevices + 1;
 	if (thisboard->has_ao) {
-/* Could provide command support, except it only has a one sample
- * hardware buffer for analog output and no underrun flag. */
+		/*
+		 * Could provide command support, except it only has a
+		 * one sample hardware buffer for analog output and no
+		 * underrun flag.
+		 */
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
 		s->n_chan = NUM_AO_CHAN;
@@ -1356,7 +1359,10 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	}
 
 	if (devpriv->current_transfer == isa_dma_transfer) {
-		/*  if a dma terminal count of external stop trigger has occurred */
+		/*
+		 * if a dma terminal count of external stop trigger
+		 * has occurred
+		 */
 		if (devpriv->status1_bits & DMATC_BIT ||
 		    (thisboard->register_layout == labpc_1200_layout
 		     && devpriv->status2_bits & A1_TC_BIT)) {

commit 65d6d26c6bcd802ebe2b22a29d9b6bbebfd8d7f8
Author: Maurice Dawson <mauricedawson2699@googlemail.com>
Date:   Fri Feb 19 10:53:15 2010 +0000

    Staging: comedi: fix yet another brace coding style issue in ni_labpc.c
    
    This is a patch to the ni_labpc.c file that fixes up all the brace
    warnings found by the checkpatch.pl tool
    
    Signed-off-by: Maurice Dawson <mauricedawson2699@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 5dc8606009aa..d6b5c05ee199 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -642,9 +642,8 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 			devpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);
 #ifdef LABPC_DEBUG
 		printk(" eeprom:");
-		for (i = 0; i < EEPROM_SIZE; i++) {
+		for (i = 0; i < EEPROM_SIZE; i++)
 			printk(" %i:0x%x ", i, devpriv->eeprom_data[i]);
-		}
 		printk("\n");
 #endif
 	} else
@@ -676,9 +675,8 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	case pci_bustype:
 #ifdef CONFIG_COMEDI_PCI
 		retval = labpc_find_device(dev, it->options[0], it->options[1]);
-		if (retval < 0) {
+		if (retval < 0)
 			return retval;
-		}
 		retval = mite_setup(devpriv->mite);
 		if (retval < 0)
 			return retval;
@@ -1005,9 +1003,9 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 		err++;
 	}
 
-	if (!cmd->chanlist_len) {
+	if (!cmd->chanlist_len)
 		err++;
-	}
+
 	if (cmd->scan_end_arg != cmd->chanlist_len) {
 		cmd->scan_end_arg = cmd->chanlist_len;
 		err++;
@@ -1102,9 +1100,9 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
 	/*  initialize software conversion count */
-	if (cmd->stop_src == TRIG_COUNT) {
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->count = cmd->stop_arg * cmd->chanlist_len;
-	}
+
 	/*  setup hardware conversion counter */
 	if (cmd->stop_src == TRIG_EXT) {
 		/*  load counter a1 with count of 3 (pc+ manual says this is minimum allowed) using mode 0 */
@@ -1476,9 +1474,9 @@ static void labpc_drain_dma(struct comedi_device *dev)
 	}
 
 	/* write data to comedi buffer */
-	for (i = 0; i < num_points; i++) {
+	for (i = 0; i < num_points; i++)
 		cfc_write_to_buffer(s, devpriv->dma_buffer[i]);
-	}
+
 	if (async->cmd.stop_src == TRIG_COUNT)
 		devpriv->count -= num_points;
 
@@ -1861,9 +1859,9 @@ static unsigned int labpc_serial_in(struct comedi_device *dev)
 		udelay(1);
 		devpriv->status2_bits =
 		    devpriv->read_byte(dev->iobase + STATUS2_REG);
-		if (devpriv->status2_bits & EEPROM_OUT_BIT) {
+		if (devpriv->status2_bits & EEPROM_OUT_BIT)
 			value |= 1 << (value_width - i);
-		}
+
 	}
 
 	return value;

commit 2bb9c335902a5d59fc084170aaae0ccc9d9d4012
Author: Maurice Dawson <mauricedawson2699@googlemail.com>
Date:   Fri Feb 19 10:53:14 2010 +0000

    Staging: comedi: fix another brace coding style issues in ni_labpc.c
    
    This is a patch to the ni_labpc.c file that fixes up a brace warning
    found by the checkpatch.pl tool
    
    Signed-off-by: Maurice Dawson <mauricedawson2699@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index a01e35d4b31e..5dc8606009aa 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -638,9 +638,8 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		s->insn_read = labpc_eeprom_read_insn;
 		s->insn_write = labpc_eeprom_write_insn;
 
-		for (i = 0; i < EEPROM_SIZE; i++) {
+		for (i = 0; i < EEPROM_SIZE; i++)
 			devpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);
-		}
 #ifdef LABPC_DEBUG
 		printk(" eeprom:");
 		for (i = 0; i < EEPROM_SIZE; i++) {

commit 8377e813c75cf5aca46032fb780ca74c923dbe86
Author: Maurice Dawson <maurice2699@btinternet.com>
Date:   Fri Feb 19 10:53:13 2010 +0000

    Staging: comedi: fix brace coding style issue in ni_labpc.c
    
    This is a patch to the ni_labpc.c file that fixes up a brace warning
    found by the checkpatch.pl tool.
    
    Signed-off-by: Maurice Dawson <maurice2699@btinternet.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index dc3f398cb3ed..a01e35d4b31e 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -483,12 +483,10 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 	printk("comedi%d: ni_labpc: %s, io 0x%lx", dev->minor, thisboard->name,
 	       iobase);
-	if (irq) {
+	if (irq)
 		printk(", irq %u", irq);
-	}
-	if (dma_chan) {
+	if (dma_chan)
 		printk(", dma %u", dma_chan);
-	}
 	printk("\n");
 
 	if (iobase == 0) {

commit e41a6f6d9cb7404420d596f27609a3f4f55dcaf5
Author: Stewart Robertson <stewart_r@aliencamel.com>
Date:   Sun Feb 21 10:13:21 2010 +0000

    Staging: comedi: fix coding style issues in ni_labpc.c
    
    This is a patch to the ni_labpc.c file that fixes the brace warnings and
    comments over 80 characters found by the checkpatch.pl tool. Some code
    still goes over 80 characters because I didn't know what to do with it.
    
    Signed-off-by: Stewart Robertson <stewart_r@aliencamel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 566b791e00c7..bc5662e2a9bf 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -90,8 +90,10 @@ NI manuals:
 
 #define DRV_NAME "ni_labpc"
 
-#define LABPC_SIZE           32	/*  size of io region used by board */
-#define LABPC_TIMER_BASE            500	/*  2 MHz master clock */
+/* size of io region used by board */
+#define LABPC_SIZE           32
+/* 2 MHz master clock */
+#define LABPC_TIMER_BASE            500
 
 /* Registers for the lab-pc+ */
 
@@ -99,69 +101,110 @@ NI manuals:
 #define COMMAND1_REG	0x0
 #define   ADC_GAIN_MASK	(0x7 << 4)
 #define   ADC_CHAN_BITS(x)	((x) & 0x7)
-#define   ADC_SCAN_EN_BIT	0x80	/*  enables multi channel scans */
+/* enables multi channel scans */
+#define   ADC_SCAN_EN_BIT	0x80
 #define COMMAND2_REG	0x1
-#define   PRETRIG_BIT	0x1	/*  enable pretriggering (used in conjunction with SWTRIG) */
-#define   HWTRIG_BIT	0x2	/*  enable paced conversions on external trigger */
-#define   SWTRIG_BIT	0x4	/*  enable paced conversions */
-#define   CASCADE_BIT	0x8	/*  use two cascaded counters for pacing */
+/* enable pretriggering (used in conjunction with SWTRIG) */
+#define   PRETRIG_BIT	0x1
+/* enable paced conversions on external trigger */
+#define   HWTRIG_BIT	0x2
+/* enable paced conversions */
+#define   SWTRIG_BIT	0x4
+/* use two cascaded counters for pacing */
+#define   CASCADE_BIT	0x8
 #define   DAC_PACED_BIT(channel)	(0x40 << ((channel) & 0x1))
 #define COMMAND3_REG	0x2
-#define   DMA_EN_BIT	0x1	/*  enable dma transfers */
-#define   DIO_INTR_EN_BIT	0x2	/*  enable interrupts for 8255 */
-#define   DMATC_INTR_EN_BIT	0x4	/*  enable dma terminal count interrupt */
-#define   TIMER_INTR_EN_BIT	0x8	/*  enable timer interrupt */
-#define   ERR_INTR_EN_BIT	0x10	/*  enable error interrupt */
-#define   ADC_FNE_INTR_EN_BIT	0x20	/*  enable fifo not empty interrupt */
+/* enable dma transfers */
+#define   DMA_EN_BIT	0x1
+/* enable interrupts for 8255 */
+#define   DIO_INTR_EN_BIT	0x2
+/* enable dma terminal count interrupt */
+#define   DMATC_INTR_EN_BIT	0x4
+/* enable timer interrupt */
+#define   TIMER_INTR_EN_BIT	0x8
+/* enable error interrupt */
+#define   ERR_INTR_EN_BIT	0x10
+/* enable fifo not empty interrupt */
+#define   ADC_FNE_INTR_EN_BIT	0x20
 #define ADC_CONVERT_REG	0x3
 #define DAC_LSB_REG(channel)	(0x4 + 2 * ((channel) & 0x1))
 #define DAC_MSB_REG(channel)	(0x5 + 2 * ((channel) & 0x1))
 #define ADC_CLEAR_REG	0x8
 #define DMATC_CLEAR_REG	0xa
 #define TIMER_CLEAR_REG	0xc
-#define COMMAND6_REG	0xe	/*  1200 boards only */
-#define   ADC_COMMON_BIT	0x1	/*  select ground or common-mode reference */
-#define   ADC_UNIP_BIT	0x2	/*  adc unipolar */
-#define   DAC_UNIP_BIT(channel)	(0x4 << ((channel) & 0x1))	/*  dac unipolar */
-#define   ADC_FHF_INTR_EN_BIT	0x20	/*  enable fifo half full interrupt */
-#define   A1_INTR_EN_BIT	0x40	/*  enable interrupt on end of hardware count */
-#define   ADC_SCAN_UP_BIT 0x80	/*  scan up from channel zero instead of down to zero */
+/* 1200 boards only */
+#define COMMAND6_REG	0xe
+/* select ground or common-mode reference */
+#define   ADC_COMMON_BIT	0x1
+/*  adc unipolar */
+#define   ADC_UNIP_BIT	0x2
+/*  dac unipolar */
+#define   DAC_UNIP_BIT(channel)	(0x4 << ((channel) & 0x1))
+/* enable fifo half full interrupt */
+#define   ADC_FHF_INTR_EN_BIT	0x20
+/* enable interrupt on end of hardware count */
+#define   A1_INTR_EN_BIT	0x40
+/* scan up from channel zero instead of down to zero */
+#define   ADC_SCAN_UP_BIT 0x80
 #define COMMAND4_REG	0xf
-#define   INTERVAL_SCAN_EN_BIT	0x1	/*  enables 'interval' scanning */
-#define   EXT_SCAN_EN_BIT	0x2	/*  enables external signal on counter b1 output to trigger scan */
-#define   EXT_CONVERT_OUT_BIT	0x4	/*  chooses direction (output or input) for EXTCONV* line */
-#define   ADC_DIFF_BIT	0x8	/*  chooses differential inputs for adc (in conjunction with board jumper) */
+/* enables 'interval' scanning */
+#define   INTERVAL_SCAN_EN_BIT	0x1
+/* enables external signal on counter b1 output to trigger scan */
+#define   EXT_SCAN_EN_BIT	0x2
+/* chooses direction (output or input) for EXTCONV* line */
+#define   EXT_CONVERT_OUT_BIT	0x4
+/* chooses differential inputs for adc (in conjunction with board jumper) */
+#define   ADC_DIFF_BIT	0x8
 #define   EXT_CONVERT_DISABLE_BIT	0x10
-#define COMMAND5_REG	0x1c	/*  1200 boards only, calibration stuff */
-#define   EEPROM_WRITE_UNPROTECT_BIT	0x4	/*  enable eeprom for write */
-#define   DITHER_EN_BIT	0x8	/*  enable dithering */
-#define   CALDAC_LOAD_BIT	0x10	/*  load calibration dac */
-#define   SCLOCK_BIT	0x20	/*  serial clock - rising edge writes, falling edge reads */
-#define   SDATA_BIT	0x40	/*  serial data bit for writing to eeprom or calibration dacs */
-#define   EEPROM_EN_BIT	0x80	/*  enable eeprom for read/write */
+/* 1200 boards only, calibration stuff */
+#define COMMAND5_REG	0x1c
+/* enable eeprom for write */
+#define   EEPROM_WRITE_UNPROTECT_BIT	0x4
+/* enable dithering */
+#define   DITHER_EN_BIT	0x8
+/* load calibration dac */
+#define   CALDAC_LOAD_BIT	0x10
+/* serial clock - rising edge writes, falling edge reads */
+#define   SCLOCK_BIT	0x20
+/* serial data bit for writing to eeprom or calibration dacs */
+#define   SDATA_BIT	0x40
+/* enable eeprom for read/write */
+#define   EEPROM_EN_BIT	0x80
 #define INTERVAL_COUNT_REG	0x1e
 #define INTERVAL_LOAD_REG	0x1f
 #define   INTERVAL_LOAD_BITS	0x1
 
 /* read-only registers */
 #define STATUS1_REG	0x0
-#define   DATA_AVAIL_BIT	0x1	/*  data is available in fifo */
-#define   OVERRUN_BIT	0x2	/*  overrun has occurred */
-#define   OVERFLOW_BIT	0x4	/*  fifo overflow */
-#define   TIMER_BIT	0x8	/*  timer interrupt has occured */
-#define   DMATC_BIT	0x10	/*  dma terminal count has occured */
-#define   EXT_TRIG_BIT	0x40	/*  external trigger has occured */
-#define STATUS2_REG	0x1d	/*  1200 boards only */
-#define   EEPROM_OUT_BIT	0x1	/*  programmable eeprom serial output */
-#define   A1_TC_BIT	0x2	/*  counter A1 terminal count */
-#define   FNHF_BIT	0x4	/*  fifo not half full */
+/* data is available in fifo */
+#define   DATA_AVAIL_BIT	0x1
+/* overrun has occurred */
+#define   OVERRUN_BIT	0x2
+/* fifo overflow */
+#define   OVERFLOW_BIT	0x4
+/* timer interrupt has occured */
+#define   TIMER_BIT	0x8
+/* dma terminal count has occured */
+#define   DMATC_BIT	0x10
+/* external trigger has occured */
+#define   EXT_TRIG_BIT	0x40
+/* 1200 boards only */
+#define STATUS2_REG	0x1d
+/* programmable eeprom serial output */
+#define   EEPROM_OUT_BIT	0x1
+/* counter A1 terminal count */
+#define   A1_TC_BIT	0x2
+/* fifo not half full */
+#define   FNHF_BIT	0x4
 #define ADC_FIFO_REG	0xa
 
 #define DIO_BASE_REG	0x10
 #define COUNTER_A_BASE_REG	0x14
 #define COUNTER_A_CONTROL_REG	(COUNTER_A_BASE_REG + 0x3)
-#define   INIT_A0_BITS	0x14	/*  check modes put conversion pacer output in harmless state (a0 mode 2) */
-#define   INIT_A1_BITS	0x70	/*  put hardware conversion counter output in harmless state (a1 mode 0) */
+/* check modes put conversion pacer output in harmless state (a0 mode 2) */
+#define   INIT_A0_BITS	0x14
+/* put hardware conversion counter output in harmless state (a1 mode 0) */
+#define   INIT_A1_BITS	0x70
 #define COUNTER_B_BASE_REG	0x18
 
 static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it);
@@ -423,7 +466,7 @@ static const struct labpc_board_struct labpc_boards[] = {
 	 .ai_scan_up = 1,
 	 .memory_mapped_io = 1,
 	 },
-	/*  dummy entry so pci board works when comedi_config is passed driver name */
+/* dummy entry so pci board works when comedi_config is passed driver name */
 	{
 	 .name = DRV_NAME,
 	 .bustype = pci_bustype,
@@ -436,8 +479,10 @@ static const struct labpc_board_struct labpc_boards[] = {
  */
 #define thisboard ((struct labpc_board_struct *)dev->board_ptr)
 
-static const int dma_buffer_size = 0xff00;	/*  size in bytes of dma buffer */
-static const int sample_size = 2;	/*  2 bytes per sample */
+/* size in bytes of dma buffer */
+static const int dma_buffer_size = 0xff00;
+/* 2 bytes per sample */
+static const int sample_size = 2;
 
 #define devpriv ((struct labpc_private *)dev->private)
 
@@ -511,7 +556,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		devpriv->read_byte = labpc_inb;
 		devpriv->write_byte = labpc_outb;
 	}
-	/*  initialize board's command registers */
+	/* initialize board's command registers */
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
@@ -536,12 +581,12 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	}
 	dev->irq = irq;
 
-	/*  grab dma channel */
+	/* grab dma channel */
 	if (dma_chan > 3) {
 		printk(" invalid dma channel %u\n", dma_chan);
 		return -EINVAL;
 	} else if (dma_chan) {
-		/*  allocate dma buffer */
+		/* allocate dma buffer */
 		devpriv->dma_buffer =
 		    kmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);
 		if (devpriv->dma_buffer == NULL) {
@@ -573,7 +618,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	    SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF | SDF_CMD_READ;
 	s->n_chan = 8;
 	s->len_chanlist = 8;
-	s->maxdata = (1 << 12) - 1;	/*  12 bit resolution */
+	s->maxdata = (1 << 12) - 1;	/* 12 bit resolution */
 	s->range_table = thisboard->ai_range_table;
 	s->do_cmd = labpc_ai_cmd;
 	s->do_cmdtest = labpc_ai_cmdtest;
@@ -667,7 +712,7 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (alloc_private(dev, sizeof(struct labpc_private)) < 0)
 		return -ENOMEM;
 
-	/*  get base address, irq etc. based on bustype */
+	/* get base address, irq etc. based on bustype */
 	switch (thisboard->bustype) {
 	case isa_bustype:
 		iobase = it->options[0];
@@ -712,7 +757,7 @@ static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
-		/*  if bus/slot are specified then make sure we have the right bus/slot */
+/* if bus/slot are specified then make sure we have the right bus/slot */
 		if (bus || slot) {
 			if (bus != mite->pcidev->bus->number
 			    || slot != PCI_SLOT(mite->pcidev->devfn))
@@ -723,7 +768,7 @@ static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 				continue;
 			if (mite_device_id(mite) == labpc_boards[i].device_id) {
 				devpriv->mite = mite;
-				/*  fixup board pointer, in case we were using the dummy "ni_labpc" entry */
+/* fixup board pointer, in case we were using the dummy "ni_labpc" entry */
 				dev->board_ptr = &labpc_boards[i];
 				return 0;
 			}
@@ -991,7 +1036,7 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 	    cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
 		err++;
 
-	/*  can't have external stop and start triggers at once */
+	/* can't have external stop and start triggers at once */
 	if (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)
 		err++;
 
@@ -1019,7 +1064,7 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 			err++;
 		}
 	}
-	/*  make sure scan timing is not too fast */
+	/* make sure scan timing is not too fast */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->convert_src == TRIG_TIMER &&
 		    cmd->scan_begin_arg <
@@ -1035,7 +1080,7 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 			err++;
 		}
 	}
-	/*  stop source */
+	/* stop source */
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
 		if (!cmd->stop_arg) {
@@ -1092,7 +1137,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	range = CR_RANGE(cmd->chanlist[0]);
 	aref = CR_AREF(cmd->chanlist[0]);
 
-	/*  make sure board is disabled before setting up aquisition */
+	/* make sure board is disabled before setting up aquisition */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
@@ -1172,17 +1217,18 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		channel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);
 	else
 		channel = CR_CHAN(cmd->chanlist[0]);
-	/*  munge channel bits for differential / scan disabled mode */
+	/* munge channel bits for differential / scan disabled mode */
 	if (labpc_ai_scan_mode(cmd) != MODE_SINGLE_CHAN && aref == AREF_DIFF)
 		channel *= 2;
 	devpriv->command1_bits |= ADC_CHAN_BITS(channel);
 	devpriv->command1_bits |= thisboard->ai_range_code[range];
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
-	/*  manual says to set scan enable bit on second pass */
+	/* manual says to set scan enable bit on second pass */
 	if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP ||
 	    labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_DOWN) {
 		devpriv->command1_bits |= ADC_SCAN_EN_BIT;
-		/* need a brief delay before enabling scan, or scan list will get screwed when you switch
+		/* need a brief delay before enabling scan, or scan
+		 * list will get screwed when you switch
 		 * between scan up to scan down mode - dunno why */
 		udelay(1);
 		devpriv->write_byte(devpriv->command1_bits,
@@ -1334,7 +1380,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	cmd = &async->cmd;
 	async->events = 0;
 
-	/*  read board status */
+	/* read board status */
 	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
 	if (thisboard->register_layout == labpc_1200_layout)
 		devpriv->status2_bits =
@@ -1348,7 +1394,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	}
 
 	if (devpriv->status1_bits & OVERRUN_BIT) {
-		/*  clear error interrupt */
+		/* clear error interrupt */
 		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		comedi_event(dev, s);
@@ -1357,7 +1403,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	}
 
 	if (devpriv->current_transfer == isa_dma_transfer) {
-		/*  if a dma terminal count of external stop trigger has occurred */
+	/* if a dma terminal count of external stop trigger has occurred */
 		if (devpriv->status1_bits & DMATC_BIT ||
 		    (thisboard->register_layout == labpc_1200_layout
 		     && devpriv->status2_bits & A1_TC_BIT)) {
@@ -1532,41 +1578,41 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	chan = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
 	devpriv->command1_bits |= thisboard->ai_range_code[range];
-	/*  munge channel bits for differential/scan disabled mode */
+	/* munge channel bits for differential/scan disabled mode */
 	if (CR_AREF(insn->chanspec) == AREF_DIFF)
 		chan *= 2;
 	devpriv->command1_bits |= ADC_CHAN_BITS(chan);
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
 
-	/*  setup command6 register for 1200 boards */
+	/* setup command6 register for 1200 boards */
 	if (thisboard->register_layout == labpc_1200_layout) {
 		/*  reference inputs to ground or common? */
 		if (CR_AREF(insn->chanspec) != AREF_GROUND)
 			devpriv->command6_bits |= ADC_COMMON_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_COMMON_BIT;
-		/*  bipolar or unipolar range? */
+		/* bipolar or unipolar range? */
 		if (thisboard->ai_range_is_unipolar[range])
 			devpriv->command6_bits |= ADC_UNIP_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_UNIP_BIT;
-		/*  don't interrupt on fifo half full */
+		/* don't interrupt on fifo half full */
 		devpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;
-		/*  don't enable interrupt on counter a1 terminal count? */
+		/* don't enable interrupt on counter a1 terminal count? */
 		devpriv->command6_bits &= ~A1_INTR_EN_BIT;
-		/*  write to register */
+		/* write to register */
 		devpriv->write_byte(devpriv->command6_bits,
 				    dev->iobase + COMMAND6_REG);
 	}
-	/*  setup command4 register */
+	/* setup command4 register */
 	devpriv->command4_bits = 0;
 	devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
-	/*  single-ended/differential */
+	/* single-ended/differential */
 	if (CR_AREF(insn->chanspec) == AREF_DIFF)
 		devpriv->command4_bits |= ADC_DIFF_BIT;
 	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
 
-	/*  initialize pacer counter output to make sure it doesn't cause any problems */
+	/* initialize pacer counter output to make sure it doesn't cause any problems */
 	devpriv->write_byte(INIT_A0_BITS, dev->iobase + COUNTER_A_CONTROL_REG);
 
 	labpc_clear_adc_fifo(dev);
@@ -1603,7 +1649,7 @@ static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	channel = CR_CHAN(insn->chanspec);
 
-	/*  turn off pacing of analog output channel */
+	/* turn off pacing of analog output channel */
 	/* note: hardware bug in daqcard-1200 means pacing cannot
 	 * be independently enabled/disabled for its the two channels */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -1611,7 +1657,7 @@ static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  set range */
+	/* set range */
 	if (thisboard->register_layout == labpc_1200_layout) {
 		range = CR_RANGE(insn->chanspec);
 		if (range & AO_RANGE_IS_UNIPOLAR)
@@ -1622,13 +1668,13 @@ static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		devpriv->write_byte(devpriv->command6_bits,
 				    dev->iobase + COMMAND6_REG);
 	}
-	/*  send data */
+	/* send data */
 	lsb = data[0] & 0xff;
 	msb = (data[0] >> 8) & 0xff;
 	devpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(channel));
 	devpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(channel));
 
-	/*  remember value for readback */
+	/* remember value for readback */
 	devpriv->ao_value[channel] = data[0];
 
 	return 1;
@@ -1700,14 +1746,14 @@ static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd)
 
 	if (cmd.convert_src == TRIG_TIMER)
 		freq = 1000000000 / cmd.convert_arg;
-	/*  return some default value */
+	/* return some default value */
 	else
 		freq = 0xffffffff;
 
-	/*  make buffer fill in no more than 1/3 second */
+	/* make buffer fill in no more than 1/3 second */
 	size = (freq / 3) * sample_size;
 
-	/*  set a minimum and maximum size allowed */
+	/* set a minimum and maximum size allowed */
 	if (size > dma_buffer_size)
 		size = dma_buffer_size - dma_buffer_size % sample_size;
 	else if (size < sample_size)
@@ -1719,13 +1765,21 @@ static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd)
 /* figures out what counter values to use based on command */
 static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
-	const int max_counter_value = 0x10000;	/*  max value for 16 bit counter in mode 2 */
-	const int min_counter_value = 2;	/*  min value for 16 bit counter in mode 2 */
+	/* max value for 16 bit counter in mode 2 */
+	const int max_counter_value = 0x10000;
+	/* min value for 16 bit counter in mode 2 */
+	const int min_counter_value = 2;
 	unsigned int base_period;
 
-	/*  if both convert and scan triggers are TRIG_TIMER, then they both rely on counter b0 */
+	/*
+	 * if both convert and scan triggers are TRIG_TIMER, then they
+	 * both rely on counter b0
+	 */
 	if (labpc_ai_convert_period(cmd) && labpc_ai_scan_period(cmd)) {
-		/*  pick the lowest b0 divisor value we can (for maximum input clock speed on convert and scan counters) */
+		/*
+		 * pick the lowest b0 divisor value we can (for maximum input
+		 * clock speed on convert and scan counters)
+		 */
 		devpriv->divisor_b0 = (labpc_ai_scan_period(cmd) - 1) /
 		    (LABPC_TIMER_BASE * max_counter_value) + 1;
 		if (devpriv->divisor_b0 < min_counter_value)
@@ -1775,7 +1829,10 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 					    base_period * devpriv->divisor_a0);
 		labpc_set_ai_scan_period(cmd,
 					 base_period * devpriv->divisor_b1);
-		/*  if only one TRIG_TIMER is used, we can employ the generic cascaded timing functions */
+		/*
+		 * if only one TRIG_TIMER is used, we can employ the generic
+		 * cascaded timing functions
+		 */
 	} else if (labpc_ai_scan_period(cmd)) {
 		unsigned int scan_period;
 
@@ -1870,8 +1927,10 @@ static unsigned int labpc_eeprom_read(struct comedi_device *dev,
 				      unsigned int address)
 {
 	unsigned int value;
-	const int read_instruction = 0x3;	/*  bits to tell eeprom to expect a read */
-	const int write_length = 8;	/*  8 bit write lengths to eeprom */
+	/*  bits to tell eeprom to expect a read */
+	const int read_instruction = 0x3;
+	/*  8 bit write lengths to eeprom */
+	const int write_length = 8;
 
 	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;

commit 412bd046b0a1726f8b168d5056d21213932f9d84
Author: tony burrows <tony@tonyburrows.com>
Date:   Tue Feb 2 16:52:49 2010 +0000

    Staging: comedi: fix brace coding style issues in ni_labpc.c
    
    This patch fixes all of the brace style warnings found by the
    checkpatch.pl tool
    
    Signed-off-by: Tony Burrows <tony@tonyburrows.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 647c9b72b551..566b791e00c7 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -483,12 +483,10 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 	printk("comedi%d: ni_labpc: %s, io 0x%lx", dev->minor, thisboard->name,
 	       iobase);
-	if (irq) {
+	if (irq)
 		printk(", irq %u", irq);
-	}
-	if (dma_chan) {
+	if (dma_chan)
 		printk(", dma %u", dma_chan);
-	}
 	printk("\n");
 
 	if (iobase == 0) {
@@ -585,8 +583,9 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	/* analog output */
 	s = dev->subdevices + 1;
 	if (thisboard->has_ao) {
-/* Could provide command support, except it only has a one sample
- * hardware buffer for analog output and no underrun flag. */
+		/* Could provide command support, except it only has a
+		 * one sample hardware buffer for analog output and no
+		 * underrun flag. */
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
 		s->n_chan = NUM_AO_CHAN;
@@ -608,7 +607,8 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 
 	/* 8255 dio */
 	s = dev->subdevices + 2;
-	/*  if board uses io memory we have to give a custom callback function to the 8255 driver */
+	/*  if board uses io memory we have to give a custom callback
+	 * function to the 8255 driver */
 	if (thisboard->memory_mapped_io)
 		subdev_8255_init(dev, s, labpc_dio_mem_callback,
 				 (unsigned long)(dev->iobase + DIO_BASE_REG));
@@ -640,14 +640,12 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		s->insn_read = labpc_eeprom_read_insn;
 		s->insn_write = labpc_eeprom_write_insn;
 
-		for (i = 0; i < EEPROM_SIZE; i++) {
+		for (i = 0; i < EEPROM_SIZE; i++)
 			devpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);
-		}
 #ifdef LABPC_DEBUG
 		printk(" eeprom:");
-		for (i = 0; i < EEPROM_SIZE; i++) {
+		for (i = 0; i < EEPROM_SIZE; i++)
 			printk(" %i:0x%x ", i, devpriv->eeprom_data[i]);
-		}
 		printk("\n");
 #endif
 	} else
@@ -679,9 +677,8 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	case pci_bustype:
 #ifdef CONFIG_COMEDI_PCI
 		retval = labpc_find_device(dev, it->options[0], it->options[1]);
-		if (retval < 0) {
+		if (retval < 0)
 			return retval;
-		}
 		retval = mite_setup(devpriv->mite);
 		if (retval < 0)
 			return retval;
@@ -1008,9 +1005,9 @@ static int labpc_ai_cmdtest(struct comedi_device *dev,
 		err++;
 	}
 
-	if (!cmd->chanlist_len) {
+	if (!cmd->chanlist_len)
 		err++;
-	}
+
 	if (cmd->scan_end_arg != cmd->chanlist_len) {
 		cmd->scan_end_arg = cmd->chanlist_len;
 		err++;
@@ -1105,9 +1102,8 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
 	/*  initialize software conversion count */
-	if (cmd->stop_src == TRIG_COUNT) {
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->count = cmd->stop_arg * cmd->chanlist_len;
-	}
 	/*  setup hardware conversion counter */
 	if (cmd->stop_src == TRIG_EXT) {
 		/*  load counter a1 with count of 3 (pc+ manual says this is minimum allowed) using mode 0 */
@@ -1479,9 +1475,8 @@ static void labpc_drain_dma(struct comedi_device *dev)
 	}
 
 	/* write data to comedi buffer */
-	for (i = 0; i < num_points; i++) {
+	for (i = 0; i < num_points; i++)
 		cfc_write_to_buffer(s, devpriv->dma_buffer[i]);
-	}
 	if (async->cmd.stop_src == TRIG_COUNT)
 		devpriv->count -= num_points;
 
@@ -1864,9 +1859,8 @@ static unsigned int labpc_serial_in(struct comedi_device *dev)
 		udelay(1);
 		devpriv->status2_bits =
 		    devpriv->read_byte(dev->iobase + STATUS2_REG);
-		if (devpriv->status2_bits & EEPROM_OUT_BIT) {
+		if (devpriv->status2_bits & EEPROM_OUT_BIT)
 			value |= 1 << (value_width - i);
-		}
 	}
 
 	return value;

commit 9d220c6b54f3d0b141846321814ec1c4e4fbdc67
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Tue Jan 12 15:57:58 2010 +0100

    staging: fix typos "aquire" -> "acquire"
    
    This patch was generated by
    
        git grep -E -i -l '[Aa]quire' drivers/staging | xargs -r perl -p -i -e 's/([Aa])quire/$1cquire/'
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index dc3f398cb3ed..647c9b72b551 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1503,7 +1503,7 @@ static void handle_isa_dma(struct comedi_device *dev)
 	devpriv->write_byte(0x1, dev->iobase + DMATC_CLEAR_REG);
 }
 
-/* makes sure all data aquired by board is transfered to comedi (used
+/* makes sure all data acquired by board is transfered to comedi (used
  * when aquisition is terminated by stop_src == TRIG_EXT). */
 static void labpc_drain_dregs(struct comedi_device *dev)
 {

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 30e11f46a640..dc3f398cb3ed 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -171,40 +171,46 @@ static int labpc_drain_fifo(struct comedi_device *dev);
 static void labpc_drain_dma(struct comedi_device *dev);
 static void handle_isa_dma(struct comedi_device *dev);
 static void labpc_drain_dregs(struct comedi_device *dev);
-static int labpc_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int labpc_ai_cmdtest(struct comedi_device *dev,
+			    struct comedi_subdevice *s, struct comedi_cmd *cmd);
 static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int labpc_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int labpc_calib_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int labpc_calib_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int labpc_eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int labpc_eeprom_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
+static int labpc_calib_read_insn(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
+static int labpc_calib_write_insn(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
+static int labpc_eeprom_read_insn(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
+static int labpc_eeprom_write_insn(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data);
 static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd);
 static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd);
 #ifdef CONFIG_COMEDI_PCI
 static int labpc_find_device(struct comedi_device *dev, int bus, int slot);
 #endif
 static int labpc_dio_mem_callback(int dir, int port, int data,
-	unsigned long arg);
+				  unsigned long arg);
 static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
-	unsigned int num_bits);
+			     unsigned int num_bits);
 static unsigned int labpc_serial_in(struct comedi_device *dev);
 static unsigned int labpc_eeprom_read(struct comedi_device *dev,
-	unsigned int address);
+				      unsigned int address);
 static unsigned int labpc_eeprom_read_status(struct comedi_device *dev);
 static unsigned int labpc_eeprom_write(struct comedi_device *dev,
-	unsigned int address, unsigned int value);
+				       unsigned int address,
+				       unsigned int value);
 static void write_caldac(struct comedi_device *dev, unsigned int channel,
-	unsigned int value);
+			 unsigned int value);
 
 enum scan_mode {
 	MODE_SINGLE_CHAN,
@@ -254,26 +260,27 @@ static const int labpc_plus_ai_gain_bits[NUM_LABPC_PLUS_AI_RANGES] = {
 	0x60,
 	0x70,
 };
+
 static const struct comedi_lrange range_labpc_plus_ai = {
 	NUM_LABPC_PLUS_AI_RANGES,
 	{
-			BIP_RANGE(5),
-			BIP_RANGE(4),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.25),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.05),
-			UNI_RANGE(10),
-			UNI_RANGE(8),
-			UNI_RANGE(5),
-			UNI_RANGE(2),
-			UNI_RANGE(1),
-			UNI_RANGE(0.5),
-			UNI_RANGE(0.2),
-			UNI_RANGE(0.1),
-		}
+	 BIP_RANGE(5),
+	 BIP_RANGE(4),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1),
+	 BIP_RANGE(0.5),
+	 BIP_RANGE(0.25),
+	 BIP_RANGE(0.1),
+	 BIP_RANGE(0.05),
+	 UNI_RANGE(10),
+	 UNI_RANGE(8),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2),
+	 UNI_RANGE(1),
+	 UNI_RANGE(0.5),
+	 UNI_RANGE(0.2),
+	 UNI_RANGE(0.1),
+	 }
 };
 
 #define NUM_LABPC_1200_AI_RANGES 14
@@ -312,24 +319,25 @@ const int labpc_1200_ai_gain_bits[NUM_LABPC_1200_AI_RANGES] = {
 	0x60,
 	0x70,
 };
+
 const struct comedi_lrange range_labpc_1200_ai = {
 	NUM_LABPC_1200_AI_RANGES,
 	{
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.25),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.05),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2),
-			UNI_RANGE(1),
-			UNI_RANGE(0.5),
-			UNI_RANGE(0.2),
-			UNI_RANGE(0.1),
-		}
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1),
+	 BIP_RANGE(0.5),
+	 BIP_RANGE(0.25),
+	 BIP_RANGE(0.1),
+	 BIP_RANGE(0.05),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2),
+	 UNI_RANGE(1),
+	 UNI_RANGE(0.5),
+	 UNI_RANGE(0.2),
+	 UNI_RANGE(0.1),
+	 }
 };
 
 /* analog output ranges */
@@ -337,9 +345,9 @@ const struct comedi_lrange range_labpc_1200_ai = {
 static const struct comedi_lrange range_labpc_ao = {
 	2,
 	{
-			BIP_RANGE(5),
-			UNI_RANGE(10),
-		}
+	 BIP_RANGE(5),
+	 UNI_RANGE(10),
+	 }
 };
 
 /* functions that do inb/outb and readb/writeb so we can use
@@ -348,14 +356,17 @@ static inline unsigned int labpc_inb(unsigned long address)
 {
 	return inb(address);
 }
+
 static inline void labpc_outb(unsigned int byte, unsigned long address)
 {
 	outb(byte, address);
 }
+
 static inline unsigned int labpc_readb(unsigned long address)
 {
 	return readb((void *)address);
 }
+
 static inline void labpc_writeb(unsigned int byte, unsigned long address)
 {
 	writeb(byte, (void *)address);
@@ -363,60 +374,60 @@ static inline void labpc_writeb(unsigned int byte, unsigned long address)
 
 static const struct labpc_board_struct labpc_boards[] = {
 	{
-	.name = "lab-pc-1200",
-	.ai_speed = 10000,
-	.bustype = isa_bustype,
-	.register_layout = labpc_1200_layout,
-	.has_ao = 1,
-	.ai_range_table = &range_labpc_1200_ai,
-	.ai_range_code = labpc_1200_ai_gain_bits,
-	.ai_range_is_unipolar = labpc_1200_is_unipolar,
-	.ai_scan_up = 1,
-	.memory_mapped_io = 0,
-		},
+	 .name = "lab-pc-1200",
+	 .ai_speed = 10000,
+	 .bustype = isa_bustype,
+	 .register_layout = labpc_1200_layout,
+	 .has_ao = 1,
+	 .ai_range_table = &range_labpc_1200_ai,
+	 .ai_range_code = labpc_1200_ai_gain_bits,
+	 .ai_range_is_unipolar = labpc_1200_is_unipolar,
+	 .ai_scan_up = 1,
+	 .memory_mapped_io = 0,
+	 },
 	{
-	.name = "lab-pc-1200ai",
-	.ai_speed = 10000,
-	.bustype = isa_bustype,
-	.register_layout = labpc_1200_layout,
-	.has_ao = 0,
-	.ai_range_table = &range_labpc_1200_ai,
-	.ai_range_code = labpc_1200_ai_gain_bits,
-	.ai_range_is_unipolar = labpc_1200_is_unipolar,
-	.ai_scan_up = 1,
-	.memory_mapped_io = 0,
-		},
+	 .name = "lab-pc-1200ai",
+	 .ai_speed = 10000,
+	 .bustype = isa_bustype,
+	 .register_layout = labpc_1200_layout,
+	 .has_ao = 0,
+	 .ai_range_table = &range_labpc_1200_ai,
+	 .ai_range_code = labpc_1200_ai_gain_bits,
+	 .ai_range_is_unipolar = labpc_1200_is_unipolar,
+	 .ai_scan_up = 1,
+	 .memory_mapped_io = 0,
+	 },
 	{
-	.name = "lab-pc+",
-	.ai_speed = 12000,
-	.bustype = isa_bustype,
-	.register_layout = labpc_plus_layout,
-	.has_ao = 1,
-	.ai_range_table = &range_labpc_plus_ai,
-	.ai_range_code = labpc_plus_ai_gain_bits,
-	.ai_range_is_unipolar = labpc_plus_is_unipolar,
-	.ai_scan_up = 0,
-	.memory_mapped_io = 0,
-		},
+	 .name = "lab-pc+",
+	 .ai_speed = 12000,
+	 .bustype = isa_bustype,
+	 .register_layout = labpc_plus_layout,
+	 .has_ao = 1,
+	 .ai_range_table = &range_labpc_plus_ai,
+	 .ai_range_code = labpc_plus_ai_gain_bits,
+	 .ai_range_is_unipolar = labpc_plus_is_unipolar,
+	 .ai_scan_up = 0,
+	 .memory_mapped_io = 0,
+	 },
 #ifdef CONFIG_COMEDI_PCI
 	{
-	.name = "pci-1200",
-	.device_id = 0x161,
-	.ai_speed = 10000,
-	.bustype = pci_bustype,
-	.register_layout = labpc_1200_layout,
-	.has_ao = 1,
-	.ai_range_table = &range_labpc_1200_ai,
-	.ai_range_code = labpc_1200_ai_gain_bits,
-	.ai_range_is_unipolar = labpc_1200_is_unipolar,
-	.ai_scan_up = 1,
-	.memory_mapped_io = 1,
-		},
+	 .name = "pci-1200",
+	 .device_id = 0x161,
+	 .ai_speed = 10000,
+	 .bustype = pci_bustype,
+	 .register_layout = labpc_1200_layout,
+	 .has_ao = 1,
+	 .ai_range_table = &range_labpc_1200_ai,
+	 .ai_range_code = labpc_1200_ai_gain_bits,
+	 .ai_range_is_unipolar = labpc_1200_is_unipolar,
+	 .ai_scan_up = 1,
+	 .memory_mapped_io = 1,
+	 },
 	/*  dummy entry so pci board works when comedi_config is passed driver name */
 	{
-		.name = DRV_NAME,
-		.bustype = pci_bustype,
-		},
+	 .name = DRV_NAME,
+	 .bustype = pci_bustype,
+	 },
 #endif
 };
 
@@ -442,26 +453,28 @@ static struct comedi_driver driver_labpc = {
 
 #ifdef CONFIG_COMEDI_PCI
 static DEFINE_PCI_DEVICE_TABLE(labpc_pci_table) = {
-	{PCI_VENDOR_ID_NATINST, 0x161, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_NATINST, 0x161, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, labpc_pci_table);
 #endif /* CONFIG_COMEDI_PCI */
 
 static inline int labpc_counter_load(struct comedi_device *dev,
-	unsigned long base_address, unsigned int counter_number,
-	unsigned int count, unsigned int mode)
+				     unsigned long base_address,
+				     unsigned int counter_number,
+				     unsigned int count, unsigned int mode)
 {
 	if (thisboard->memory_mapped_io)
 		return i8254_mm_load((void *)base_address, 0, counter_number,
-			count, mode);
+				     count, mode);
 	else
 		return i8254_load(base_address, 0, counter_number, count, mode);
 }
 
 int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
-	unsigned int irq, unsigned int dma_chan)
+			unsigned int irq, unsigned int dma_chan)
 {
 	struct comedi_subdevice *s;
 	int i;
@@ -469,7 +482,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	short lsb, msb;
 
 	printk("comedi%d: ni_labpc: %s, io 0x%lx", dev->minor, thisboard->name,
-		iobase);
+	       iobase);
 	if (irq) {
 		printk(", irq %u", irq);
 	}
@@ -486,7 +499,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	if (thisboard->bustype == isa_bustype) {
 		/* check if io addresses are available */
 		if (!request_region(iobase, LABPC_SIZE,
-				driver_labpc.driver_name)) {
+				    driver_labpc.driver_name)) {
 			printk("I/O port conflict\n");
 			return -EIO;
 		}
@@ -507,9 +520,9 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
 	if (thisboard->register_layout == labpc_1200_layout) {
 		devpriv->write_byte(devpriv->command5_bits,
-			dev->iobase + COMMAND5_REG);
+				    dev->iobase + COMMAND5_REG);
 		devpriv->write_byte(devpriv->command6_bits,
-			dev->iobase + COMMAND6_REG);
+				    dev->iobase + COMMAND6_REG);
 	}
 
 	/* grab our IRQ */
@@ -532,14 +545,14 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	} else if (dma_chan) {
 		/*  allocate dma buffer */
 		devpriv->dma_buffer =
-			kmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);
+		    kmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);
 		if (devpriv->dma_buffer == NULL) {
 			printk(" failed to allocate dma buffer\n");
 			return -ENOMEM;
 		}
 		if (request_dma(dma_chan, driver_labpc.driver_name)) {
 			printk(" failed to allocate dma channel %u\n",
-				dma_chan);
+			       dma_chan);
 			return -EINVAL;
 		}
 		devpriv->dma_chan = dma_chan;
@@ -559,8 +572,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags =
-		SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF |
-		SDF_CMD_READ;
+	    SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF | SDF_CMD_READ;
 	s->n_chan = 8;
 	s->len_chanlist = 8;
 	s->maxdata = (1 << 12) - 1;	/*  12 bit resolution */
@@ -599,7 +611,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	/*  if board uses io memory we have to give a custom callback function to the 8255 driver */
 	if (thisboard->memory_mapped_io)
 		subdev_8255_init(dev, s, labpc_dio_mem_callback,
-			(unsigned long)(dev->iobase + DIO_BASE_REG));
+				 (unsigned long)(dev->iobase + DIO_BASE_REG));
 	else
 		subdev_8255_init(dev, s, NULL, dev->iobase + DIO_BASE_REG);
 
@@ -681,7 +693,8 @@ static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 #endif
 		break;
 	case pcmcia_bustype:
-		printk(" this driver does not support pcmcia cards, use ni_labpc_cs.o\n");
+		printk
+		    (" this driver does not support pcmcia cards, use ni_labpc_cs.o\n");
 		return -EINVAL;
 		break;
 	default:
@@ -705,7 +718,7 @@ static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 		/*  if bus/slot are specified then make sure we have the right bus/slot */
 		if (bus || slot) {
 			if (bus != mite->pcidev->bus->number
-				|| slot != PCI_SLOT(mite->pcidev->devfn))
+			    || slot != PCI_SLOT(mite->pcidev->devfn))
 				continue;
 		}
 		for (i = 0; i < driver_labpc.num_names; i++) {
@@ -795,7 +808,7 @@ static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)
 }
 
 static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
-	const struct comedi_cmd *cmd)
+				     const struct comedi_cmd *cmd)
 {
 	int mode, channel, range, aref, i;
 
@@ -810,7 +823,7 @@ static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
 	if (mode == MODE_SINGLE_CHAN_INTERVAL) {
 		if (cmd->chanlist_len > 0xff) {
 			comedi_error(dev,
-				"ni_labpc: chanlist too long for single channel interval mode\n");
+				     "ni_labpc: chanlist too long for single channel interval mode\n");
 			return 1;
 		}
 	}
@@ -825,22 +838,22 @@ static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
 		case MODE_SINGLE_CHAN_INTERVAL:
 			if (CR_CHAN(cmd->chanlist[i]) != channel) {
 				comedi_error(dev,
-					"channel scanning order specified in chanlist is not supported by hardware.\n");
+					     "channel scanning order specified in chanlist is not supported by hardware.\n");
 				return 1;
 			}
 			break;
 		case MODE_MULT_CHAN_UP:
 			if (CR_CHAN(cmd->chanlist[i]) != i) {
 				comedi_error(dev,
-					"channel scanning order specified in chanlist is not supported by hardware.\n");
+					     "channel scanning order specified in chanlist is not supported by hardware.\n");
 				return 1;
 			}
 			break;
 		case MODE_MULT_CHAN_DOWN:
 			if (CR_CHAN(cmd->chanlist[i]) !=
-				cmd->chanlist_len - i - 1) {
+			    cmd->chanlist_len - i - 1) {
 				comedi_error(dev,
-					"channel scanning order specified in chanlist is not supported by hardware.\n");
+					     "channel scanning order specified in chanlist is not supported by hardware.\n");
 				return 1;
 			}
 			break;
@@ -852,13 +865,13 @@ static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
 
 		if (CR_RANGE(cmd->chanlist[i]) != range) {
 			comedi_error(dev,
-				"entries in chanlist must all have the same range\n");
+				     "entries in chanlist must all have the same range\n");
 			return 1;
 		}
 
 		if (CR_AREF(cmd->chanlist[i]) != aref) {
 			comedi_error(dev,
-				"entries in chanlist must all have the same reference\n");
+				     "entries in chanlist must all have the same reference\n");
 			return 1;
 		}
 	}
@@ -883,7 +896,7 @@ static unsigned int labpc_ai_convert_period(const struct comedi_cmd *cmd)
 		return 0;
 
 	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
-		cmd->scan_begin_src == TRIG_TIMER)
+	    cmd->scan_begin_src == TRIG_TIMER)
 		return cmd->scan_begin_arg;
 
 	return cmd->convert_arg;
@@ -895,7 +908,7 @@ static void labpc_set_ai_convert_period(struct comedi_cmd *cmd, unsigned int ns)
 		return;
 
 	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
-		cmd->scan_begin_src == TRIG_TIMER) {
+	    cmd->scan_begin_src == TRIG_TIMER) {
 		cmd->scan_begin_arg = ns;
 		if (cmd->convert_arg > cmd->scan_begin_arg)
 			cmd->convert_arg = cmd->scan_begin_arg;
@@ -909,7 +922,7 @@ static unsigned int labpc_ai_scan_period(const struct comedi_cmd *cmd)
 		return 0;
 
 	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
-		cmd->convert_src == TRIG_TIMER)
+	    cmd->convert_src == TRIG_TIMER)
 		return 0;
 
 	return cmd->scan_begin_arg;
@@ -921,14 +934,14 @@ static void labpc_set_ai_scan_period(struct comedi_cmd *cmd, unsigned int ns)
 		return;
 
 	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
-		cmd->convert_src == TRIG_TIMER)
+	    cmd->convert_src == TRIG_TIMER)
 		return;
 
 	cmd->scan_begin_arg = ns;
 }
 
-static int labpc_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int labpc_ai_cmdtest(struct comedi_device *dev,
+			    struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, tmp2;
@@ -972,13 +985,13 @@ static int labpc_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *
 	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_FOLLOW &&
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
+	    cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
 		err++;
 
 	/*  can't have external stop and start triggers at once */
@@ -1012,16 +1025,16 @@ static int labpc_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *
 	/*  make sure scan timing is not too fast */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->convert_src == TRIG_TIMER &&
-			cmd->scan_begin_arg <
-			cmd->convert_arg * cmd->chanlist_len) {
+		    cmd->scan_begin_arg <
+		    cmd->convert_arg * cmd->chanlist_len) {
 			cmd->scan_begin_arg =
-				cmd->convert_arg * cmd->chanlist_len;
+			    cmd->convert_arg * cmd->chanlist_len;
 			err++;
 		}
 		if (cmd->scan_begin_arg <
-			thisboard->ai_speed * cmd->chanlist_len) {
+		    thisboard->ai_speed * cmd->chanlist_len) {
 			cmd->scan_begin_arg =
-				thisboard->ai_speed * cmd->chanlist_len;
+			    thisboard->ai_speed * cmd->chanlist_len;
 			err++;
 		}
 	}
@@ -1099,27 +1112,27 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->stop_src == TRIG_EXT) {
 		/*  load counter a1 with count of 3 (pc+ manual says this is minimum allowed) using mode 0 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
-			1, 3, 0);
+					 1, 3, 0);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter a1");
 			return -1;
 		}
 	} else			/*  otherwise, just put a1 in mode 0 with no count to set its output low */
 		devpriv->write_byte(INIT_A1_BITS,
-			dev->iobase + COUNTER_A_CONTROL_REG);
+				    dev->iobase + COUNTER_A_CONTROL_REG);
 
 	/*  figure out what method we will use to transfer data */
 	if (devpriv->dma_chan &&	/*  need a dma channel allocated */
-		/*  dma unsafe at RT priority, and too much setup time for TRIG_WAKE_EOS for */
-		(cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0 &&
-		/*  only available on the isa boards */
-		thisboard->bustype == isa_bustype) {
+	    /*  dma unsafe at RT priority, and too much setup time for TRIG_WAKE_EOS for */
+	    (cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0 &&
+	    /*  only available on the isa boards */
+	    thisboard->bustype == isa_bustype) {
 		xfer = isa_dma_transfer;
 	} else if (thisboard->register_layout == labpc_1200_layout &&	/*  pc-plus has no fifo-half full interrupt */
-		/*  wake-end-of-scan should interrupt on fifo not empty */
-		(cmd->flags & TRIG_WAKE_EOS) == 0 &&
-		/*  make sure we are taking more than just a few points */
-		(cmd->stop_src != TRIG_COUNT || devpriv->count > 256)) {
+		   /*  wake-end-of-scan should interrupt on fifo not empty */
+		   (cmd->flags & TRIG_WAKE_EOS) == 0 &&
+		   /*  make sure we are taking more than just a few points */
+		   (cmd->stop_src != TRIG_COUNT || devpriv->count > 256)) {
 		xfer = fifo_half_full_transfer;
 	} else
 		xfer = fifo_not_empty_transfer;
@@ -1154,7 +1167,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			devpriv->command6_bits &= ~ADC_SCAN_UP_BIT;
 		/*  write to register */
 		devpriv->write_byte(devpriv->command6_bits,
-			dev->iobase + COMMAND6_REG);
+				    dev->iobase + COMMAND6_REG);
 	}
 
 	/* setup channel list, etc (command1 register) */
@@ -1171,13 +1184,13 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
 	/*  manual says to set scan enable bit on second pass */
 	if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP ||
-		labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_DOWN) {
+	    labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_DOWN) {
 		devpriv->command1_bits |= ADC_SCAN_EN_BIT;
 		/* need a brief delay before enabling scan, or scan list will get screwed when you switch
 		 * between scan up to scan down mode - dunno why */
 		udelay(1);
 		devpriv->write_byte(devpriv->command1_bits,
-			dev->iobase + COMMAND1_REG);
+				    dev->iobase + COMMAND1_REG);
 	}
 	/*  setup any external triggering/pacing (command4 register) */
 	devpriv->command4_bits = 0;
@@ -1196,17 +1209,17 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
 
 	devpriv->write_byte(cmd->chanlist_len,
-		dev->iobase + INTERVAL_COUNT_REG);
+			    dev->iobase + INTERVAL_COUNT_REG);
 	/*  load count */
 	devpriv->write_byte(INTERVAL_LOAD_BITS,
-		dev->iobase + INTERVAL_LOAD_REG);
+			    dev->iobase + INTERVAL_LOAD_REG);
 
 	if (cmd->convert_src == TRIG_TIMER || cmd->scan_begin_src == TRIG_TIMER) {
 		/*  set up pacing */
 		labpc_adc_timing(dev, cmd);
 		/*  load counter b0 in mode 3 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
-			0, devpriv->divisor_b0, 3);
+					 0, devpriv->divisor_b0, 3);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter b0");
 			return -1;
@@ -1216,20 +1229,20 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (labpc_ai_convert_period(cmd)) {
 		/*  load counter a0 in mode 2 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
-			0, devpriv->divisor_a0, 2);
+					 0, devpriv->divisor_a0, 2);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter a0");
 			return -1;
 		}
 	} else
 		devpriv->write_byte(INIT_A0_BITS,
-			dev->iobase + COUNTER_A_CONTROL_REG);
+				    dev->iobase + COUNTER_A_CONTROL_REG);
 
 	/*  set up scan pacing */
 	if (labpc_ai_scan_period(cmd)) {
 		/*  load counter b1 in mode 2 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
-			1, devpriv->divisor_b1, 2);
+					 1, devpriv->divisor_b1, 2);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter b1");
 			return -1;
@@ -1246,14 +1259,13 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 * count and address get set correctly */
 		clear_dma_ff(devpriv->dma_chan);
 		set_dma_addr(devpriv->dma_chan,
-			virt_to_bus(devpriv->dma_buffer));
+			     virt_to_bus(devpriv->dma_buffer));
 		/*  set appropriate size of transfer */
 		devpriv->dma_transfer_size = labpc_suggest_transfer_size(*cmd);
 		if (cmd->stop_src == TRIG_COUNT &&
-			devpriv->count * sample_size <
-			devpriv->dma_transfer_size) {
+		    devpriv->count * sample_size < devpriv->dma_transfer_size) {
 			devpriv->dma_transfer_size =
-				devpriv->count * sample_size;
+			    devpriv->count * sample_size;
 		}
 		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 		enable_dma(devpriv->dma_chan);
@@ -1330,12 +1342,12 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
 	if (thisboard->register_layout == labpc_1200_layout)
 		devpriv->status2_bits =
-			devpriv->read_byte(dev->iobase + STATUS2_REG);
+		    devpriv->read_byte(dev->iobase + STATUS2_REG);
 
 	if ((devpriv->status1_bits & (DMATC_BIT | TIMER_BIT | OVERFLOW_BIT |
-				OVERRUN_BIT | DATA_AVAIL_BIT)) == 0
-		&& (devpriv->status2_bits & A1_TC_BIT) == 0
-		&& (devpriv->status2_bits & FNHF_BIT)) {
+				      OVERRUN_BIT | DATA_AVAIL_BIT)) == 0
+	    && (devpriv->status2_bits & A1_TC_BIT) == 0
+	    && (devpriv->status2_bits & FNHF_BIT)) {
 		return IRQ_NONE;
 	}
 
@@ -1351,8 +1363,8 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 	if (devpriv->current_transfer == isa_dma_transfer) {
 		/*  if a dma terminal count of external stop trigger has occurred */
 		if (devpriv->status1_bits & DMATC_BIT ||
-			(thisboard->register_layout == labpc_1200_layout
-				&& devpriv->status2_bits & A1_TC_BIT)) {
+		    (thisboard->register_layout == labpc_1200_layout
+		     && devpriv->status2_bits & A1_TC_BIT)) {
 			handle_isa_dma(dev);
 		}
 	} else
@@ -1405,7 +1417,7 @@ static int labpc_drain_fifo(struct comedi_device *dev)
 	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
 
 	for (i = 0; (devpriv->status1_bits & DATA_AVAIL_BIT) && i < timeout;
-		i++) {
+	     i++) {
 		/*  quit if we have all the data we want */
 		if (async->cmd.stop_src == TRIG_COUNT) {
 			if (devpriv->count == 0)
@@ -1417,7 +1429,7 @@ static int labpc_drain_fifo(struct comedi_device *dev)
 		data = (msb << 8) | lsb;
 		cfc_write_to_buffer(dev->read_subdev, data);
 		devpriv->status1_bits =
-			devpriv->read_byte(dev->iobase + STATUS1_REG);
+		    devpriv->read_byte(dev->iobase + STATUS1_REG);
 	}
 	if (i == timeout) {
 		comedi_error(dev, "ai timeout, fifo never empties");
@@ -1502,7 +1514,7 @@ static void labpc_drain_dregs(struct comedi_device *dev)
 }
 
 static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int chan, range;
@@ -1549,7 +1561,7 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		devpriv->command6_bits &= ~A1_INTR_EN_BIT;
 		/*  write to register */
 		devpriv->write_byte(devpriv->command6_bits,
-			dev->iobase + COMMAND6_REG);
+				    dev->iobase + COMMAND6_REG);
 	}
 	/*  setup command4 register */
 	devpriv->command4_bits = 0;
@@ -1570,7 +1582,7 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 		for (i = 0; i < timeout; i++) {
 			if (devpriv->read_byte(dev->iobase +
-					STATUS1_REG) & DATA_AVAIL_BIT)
+					       STATUS1_REG) & DATA_AVAIL_BIT)
 				break;
 			udelay(1);
 		}
@@ -1588,7 +1600,7 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 /* analog output insn */
 static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int channel, range;
 	unsigned long flags;
@@ -1613,7 +1625,7 @@ static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			devpriv->command6_bits &= ~DAC_UNIP_BIT(channel);
 		/*  write to register */
 		devpriv->write_byte(devpriv->command6_bits,
-			dev->iobase + COMMAND6_REG);
+				    dev->iobase + COMMAND6_REG);
 	}
 	/*  send data */
 	lsb = data[0] & 0xff;
@@ -1629,23 +1641,25 @@ static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 /* analog output readback insn */
 static int labpc_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int labpc_calib_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int labpc_calib_read_insn(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->caldac[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int labpc_calib_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int labpc_calib_write_insn(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -1653,23 +1667,26 @@ static int labpc_calib_write_insn(struct comedi_device *dev, struct comedi_subde
 	return 1;
 }
 
-static int labpc_eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int labpc_eeprom_read_insn(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->eeprom_data[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int labpc_eeprom_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int labpc_eeprom_write_insn(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 	int ret;
 
 	/*  only allow writes to user area of eeprom */
 	if (channel < 16 || channel > 127) {
-		printk("eeprom writes are only allowed to channels 16 through 127 (the pointer and user areas)");
+		printk
+		    ("eeprom writes are only allowed to channels 16 through 127 (the pointer and user areas)");
 		return -EINVAL;
 	}
 
@@ -1715,7 +1732,7 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 	if (labpc_ai_convert_period(cmd) && labpc_ai_scan_period(cmd)) {
 		/*  pick the lowest b0 divisor value we can (for maximum input clock speed on convert and scan counters) */
 		devpriv->divisor_b0 = (labpc_ai_scan_period(cmd) - 1) /
-			(LABPC_TIMER_BASE * max_counter_value) + 1;
+		    (LABPC_TIMER_BASE * max_counter_value) + 1;
 		if (devpriv->divisor_b0 < min_counter_value)
 			devpriv->divisor_b0 = min_counter_value;
 		if (devpriv->divisor_b0 > max_counter_value)
@@ -1728,25 +1745,25 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 		default:
 		case TRIG_ROUND_NEAREST:
 			devpriv->divisor_a0 =
-				(labpc_ai_convert_period(cmd) +
-				(base_period / 2)) / base_period;
+			    (labpc_ai_convert_period(cmd) +
+			     (base_period / 2)) / base_period;
 			devpriv->divisor_b1 =
-				(labpc_ai_scan_period(cmd) +
-				(base_period / 2)) / base_period;
+			    (labpc_ai_scan_period(cmd) +
+			     (base_period / 2)) / base_period;
 			break;
 		case TRIG_ROUND_UP:
 			devpriv->divisor_a0 =
-				(labpc_ai_convert_period(cmd) + (base_period -
-					1)) / base_period;
+			    (labpc_ai_convert_period(cmd) + (base_period -
+							     1)) / base_period;
 			devpriv->divisor_b1 =
-				(labpc_ai_scan_period(cmd) + (base_period -
-					1)) / base_period;
+			    (labpc_ai_scan_period(cmd) + (base_period -
+							  1)) / base_period;
 			break;
 		case TRIG_ROUND_DOWN:
 			devpriv->divisor_a0 =
-				labpc_ai_convert_period(cmd) / base_period;
+			    labpc_ai_convert_period(cmd) / base_period;
 			devpriv->divisor_b1 =
-				labpc_ai_scan_period(cmd) / base_period;
+			    labpc_ai_scan_period(cmd) / base_period;
 			break;
 		}
 		/*  make sure a0 and b1 values are acceptable */
@@ -1760,9 +1777,9 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 			devpriv->divisor_b1 = max_counter_value;
 		/*  write corrected timings to command */
 		labpc_set_ai_convert_period(cmd,
-			base_period * devpriv->divisor_a0);
+					    base_period * devpriv->divisor_a0);
 		labpc_set_ai_scan_period(cmd,
-			base_period * devpriv->divisor_b1);
+					 base_period * devpriv->divisor_b1);
 		/*  if only one TRIG_TIMER is used, we can employ the generic cascaded timing functions */
 	} else if (labpc_ai_scan_period(cmd)) {
 		unsigned int scan_period;
@@ -1770,8 +1787,10 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 		scan_period = labpc_ai_scan_period(cmd);
 		/* calculate cascaded counter values that give desired scan timing */
 		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
-			&(devpriv->divisor_b1), &(devpriv->divisor_b0),
-			&scan_period, cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor_b1),
+					       &(devpriv->divisor_b0),
+					       &scan_period,
+					       cmd->flags & TRIG_ROUND_MASK);
 		labpc_set_ai_scan_period(cmd, scan_period);
 	} else if (labpc_ai_convert_period(cmd)) {
 		unsigned int convert_period;
@@ -1779,14 +1798,16 @@ static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 		convert_period = labpc_ai_convert_period(cmd);
 		/* calculate cascaded counter values that give desired conversion timing */
 		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
-			&(devpriv->divisor_a0), &(devpriv->divisor_b0),
-			&convert_period, cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor_a0),
+					       &(devpriv->divisor_b0),
+					       &convert_period,
+					       cmd->flags & TRIG_ROUND_MASK);
 		labpc_set_ai_convert_period(cmd, convert_period);
 	}
 }
 
 static int labpc_dio_mem_callback(int dir, int port, int data,
-	unsigned long iobase)
+				  unsigned long iobase)
 {
 	if (dir) {
 		writeb(data, (void *)(iobase + port));
@@ -1798,7 +1819,7 @@ static int labpc_dio_mem_callback(int dir, int port, int data,
 
 /* lowlevel write to eeprom/dac */
 static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
-	unsigned int value_width)
+			     unsigned int value_width)
 {
 	int i;
 
@@ -1812,12 +1833,12 @@ static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
 			devpriv->command5_bits &= ~SDATA_BIT;
 		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
-			dev->iobase + COMMAND5_REG);
+				    dev->iobase + COMMAND5_REG);
 		/*  set clock to load bit */
 		devpriv->command5_bits |= SCLOCK_BIT;
 		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
-			dev->iobase + COMMAND5_REG);
+				    dev->iobase + COMMAND5_REG);
 	}
 }
 
@@ -1833,16 +1854,16 @@ static unsigned int labpc_serial_in(struct comedi_device *dev)
 		devpriv->command5_bits |= SCLOCK_BIT;
 		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
-			dev->iobase + COMMAND5_REG);
+				    dev->iobase + COMMAND5_REG);
 		/*  clear clock bit */
 		devpriv->command5_bits &= ~SCLOCK_BIT;
 		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
-			dev->iobase + COMMAND5_REG);
+				    dev->iobase + COMMAND5_REG);
 		/*  read bits most significant bit first */
 		udelay(1);
 		devpriv->status2_bits =
-			devpriv->read_byte(dev->iobase + STATUS2_REG);
+		    devpriv->read_byte(dev->iobase + STATUS2_REG);
 		if (devpriv->status2_bits & EEPROM_OUT_BIT) {
 			value |= 1 << (value_width - i);
 		}
@@ -1851,7 +1872,8 @@ static unsigned int labpc_serial_in(struct comedi_device *dev)
 	return value;
 }
 
-static unsigned int labpc_eeprom_read(struct comedi_device *dev, unsigned int address)
+static unsigned int labpc_eeprom_read(struct comedi_device *dev,
+				      unsigned int address)
 {
 	unsigned int value;
 	const int read_instruction = 0x3;	/*  bits to tell eeprom to expect a read */
@@ -1881,7 +1903,7 @@ static unsigned int labpc_eeprom_read(struct comedi_device *dev, unsigned int ad
 }
 
 static unsigned int labpc_eeprom_write(struct comedi_device *dev,
-	unsigned int address, unsigned int value)
+				       unsigned int address, unsigned int value)
 {
 	const int write_enable_instruction = 0x6;
 	const int write_instruction = 0x2;
@@ -1893,7 +1915,7 @@ static unsigned int labpc_eeprom_write(struct comedi_device *dev,
 	/*  make sure there isn't already a write in progress */
 	for (i = 0; i < timeout; i++) {
 		if ((labpc_eeprom_read_status(dev) & write_in_progress_bit) ==
-			0)
+		    0)
 			break;
 	}
 	if (i == timeout) {
@@ -1967,7 +1989,7 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
 
 /* writes to 8 bit calibration dacs */
 static void write_caldac(struct comedi_device *dev, unsigned int channel,
-	unsigned int value)
+			 unsigned int value)
 {
 	if (value == devpriv->caldac[channel])
 		return;
@@ -1975,7 +1997,7 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 
 	/*  clear caldac load bit and make sure we don't write to eeprom */
 	devpriv->command5_bits &=
-		~CALDAC_LOAD_BIT & ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	    ~CALDAC_LOAD_BIT & ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 

commit 25436dc9d84f1be60ff549c9ab712bba2835f284
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 15:14:34 2009 -0700

    Staging: comedi: remove RT code
    
    This removes the unused RT code from the comedi subsystem.
    
    A lot of drivers needed to then include interrupt.h on their own, as they
    were picking it up through the comedi_rt.h inclusion.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 435e34a838aa..30e11f46a640 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -76,6 +76,7 @@ NI manuals:
 #undef LABPC_DEBUG
 /* #define LABPC_DEBUG    enable debugging messages */
 
+#include <linux/interrupt.h>
 #include "../comedidev.h"
 
 #include <linux/delay.h>

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 031d994ed227..435e34a838aa 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -516,7 +516,7 @@ int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 		isr_flags = 0;
 		if (thisboard->bustype == pci_bustype)
 			isr_flags |= IRQF_SHARED;
-		if (comedi_request_irq(irq, labpc_interrupt, isr_flags,
+		if (request_irq(irq, labpc_interrupt, isr_flags,
 				driver_labpc.driver_name, dev)) {
 			printk("unable to allocate irq %u\n", irq);
 			return -EINVAL;
@@ -737,7 +737,7 @@ int labpc_common_detach(struct comedi_device *dev)
 	if (devpriv->dma_chan)
 		free_dma(devpriv->dma_chan);
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (thisboard->bustype == isa_bustype && dev->iobase)
 		release_region(dev->iobase, LABPC_SIZE);
 #ifdef CONFIG_COMEDI_PCI
@@ -759,10 +759,10 @@ static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	devpriv->command3_bits = 0;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
@@ -788,7 +788,7 @@ static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)
 	if (CR_CHAN(cmd->chanlist[0]) > CR_CHAN(cmd->chanlist[1]))
 		return MODE_MULT_CHAN_DOWN;
 
-	rt_printk("ni_labpc: bug! this should never happen\n");
+	printk("ni_labpc: bug! this should never happen\n");
 
 	return 0;
 }
@@ -844,7 +844,7 @@ static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
 			}
 			break;
 		default:
-			rt_printk("ni_labpc: bug! in chanlist check\n");
+			printk("ni_labpc: bug! in chanlist check\n");
 			return 1;
 			break;
 		}
@@ -1082,10 +1082,10 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	aref = CR_AREF(cmd->chanlist[0]);
 
 	/*  make sure board is disabled before setting up aquisition */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	devpriv->command3_bits = 0;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
@@ -1174,7 +1174,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->command1_bits |= ADC_SCAN_EN_BIT;
 		/* need a brief delay before enabling scan, or scan list will get screwed when you switch
 		 * between scan up to scan down mode - dunno why */
-		comedi_udelay(1);
+		udelay(1);
 		devpriv->write_byte(devpriv->command1_bits,
 			dev->iobase + COMMAND1_REG);
 	}
@@ -1275,7 +1275,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/*  command2 reg */
 	/*  use 2 cascaded counters for pacing */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits |= CASCADE_BIT;
 	switch (cmd->start_src) {
 	case TRIG_EXT:
@@ -1303,7 +1303,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -1;
 	}
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return 0;
 }
@@ -1510,10 +1510,10 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned long flags;
 
 	/*  disable timed conversions */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  disable interrupt generation and dma */
 	devpriv->command3_bits = 0;
@@ -1571,7 +1571,7 @@ static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			if (devpriv->read_byte(dev->iobase +
 					STATUS1_REG) & DATA_AVAIL_BIT)
 				break;
-			comedi_udelay(1);
+			udelay(1);
 		}
 		if (i == timeout) {
 			comedi_error(dev, "timeout");
@@ -1598,10 +1598,10 @@ static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	/*  turn off pacing of analog output channel */
 	/* note: hardware bug in daqcard-1200 means pacing cannot
 	 * be independently enabled/disabled for its the two channels */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~DAC_PACED_BIT(channel);
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  set range */
 	if (thisboard->register_layout == labpc_1200_layout) {
@@ -1809,12 +1809,12 @@ static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
 			devpriv->command5_bits |= SDATA_BIT;
 		else
 			devpriv->command5_bits &= ~SDATA_BIT;
-		comedi_udelay(1);
+		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
 		/*  set clock to load bit */
 		devpriv->command5_bits |= SCLOCK_BIT;
-		comedi_udelay(1);
+		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
 	}
@@ -1830,16 +1830,16 @@ static unsigned int labpc_serial_in(struct comedi_device *dev)
 	for (i = 1; i <= value_width; i++) {
 		/*  set serial clock */
 		devpriv->command5_bits |= SCLOCK_BIT;
-		comedi_udelay(1);
+		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
 		/*  clear clock bit */
 		devpriv->command5_bits &= ~SCLOCK_BIT;
-		comedi_udelay(1);
+		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
 		/*  read bits most significant bit first */
-		comedi_udelay(1);
+		udelay(1);
 		devpriv->status2_bits =
 			devpriv->read_byte(dev->iobase + STATUS2_REG);
 		if (devpriv->status2_bits & EEPROM_OUT_BIT) {
@@ -1858,10 +1858,10 @@ static unsigned int labpc_eeprom_read(struct comedi_device *dev, unsigned int ad
 
 	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	/*  send read instruction */
@@ -1873,7 +1873,7 @@ static unsigned int labpc_eeprom_read(struct comedi_device *dev, unsigned int ad
 
 	/*  disable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	return value;
@@ -1904,21 +1904,21 @@ static unsigned int labpc_eeprom_write(struct comedi_device *dev,
 
 	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	/*  send write_enable instruction */
 	labpc_serial_out(dev, write_enable_instruction, write_length);
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	/*  send write instruction */
 	devpriv->command5_bits |= EEPROM_EN_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 	labpc_serial_out(dev, write_instruction, write_length);
 	/*  send 8 bit address to write to */
@@ -1926,12 +1926,12 @@ static unsigned int labpc_eeprom_write(struct comedi_device *dev,
 	/*  write value */
 	labpc_serial_out(dev, value, write_length);
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	/*  disable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	return 0;
@@ -1945,10 +1945,10 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
 
 	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	/*  send read status instruction */
@@ -1958,7 +1958,7 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
 
 	/*  disable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	return value;
@@ -1975,7 +1975,7 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	/*  clear caldac load bit and make sure we don't write to eeprom */
 	devpriv->command5_bits &=
 		~CALDAC_LOAD_BIT & ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	/*  write 4 bit channel */
@@ -1985,10 +1985,10 @@ static void write_caldac(struct comedi_device *dev, unsigned int channel,
 
 	/*  set and clear caldac bit to load caldac value */
 	devpriv->command5_bits |= CALDAC_LOAD_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 	devpriv->command5_bits &= ~CALDAC_LOAD_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 }
 

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index d1a2b5065036..031d994ed227 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -434,7 +434,7 @@ static struct comedi_driver driver_labpc = {
 	.module = THIS_MODULE,
 	.attach = labpc_attach,
 	.detach = labpc_common_detach,
-	.num_names = sizeof(labpc_boards) / sizeof(struct labpc_board_struct),
+	.num_names = ARRAY_SIZE(labpc_boards),
 	.board_name = &labpc_boards[0].name,
 	.offset = sizeof(struct labpc_board_struct),
 };

commit 814900c904140cfe7f3e48cabec06b3eec57e0ea
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:54 2009 -0400

    Staging: comedi: more fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index e6ee7d94ca9a..d1a2b5065036 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -163,46 +163,46 @@ NI manuals:
 #define   INIT_A1_BITS	0x70	/*  put hardware conversion counter output in harmless state (a1 mode 0) */
 #define COUNTER_B_BASE_REG	0x18
 
-static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int labpc_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static irqreturn_t labpc_interrupt(int irq, void *d);
-static int labpc_drain_fifo(struct comedi_device * dev);
-static void labpc_drain_dma(struct comedi_device * dev);
-static void handle_isa_dma(struct comedi_device * dev);
-static void labpc_drain_dregs(struct comedi_device * dev);
-static int labpc_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int labpc_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int labpc_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int labpc_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int labpc_calib_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int labpc_calib_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int labpc_eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int labpc_eeprom_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
+static int labpc_drain_fifo(struct comedi_device *dev);
+static void labpc_drain_dma(struct comedi_device *dev);
+static void handle_isa_dma(struct comedi_device *dev);
+static void labpc_drain_dregs(struct comedi_device *dev);
+static int labpc_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int labpc_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int labpc_calib_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int labpc_calib_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int labpc_eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int labpc_eeprom_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
 static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd);
-static void labpc_adc_timing(struct comedi_device * dev, struct comedi_cmd * cmd);
+static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd);
 #ifdef CONFIG_COMEDI_PCI
 static int labpc_find_device(struct comedi_device *dev, int bus, int slot);
 #endif
 static int labpc_dio_mem_callback(int dir, int port, int data,
 	unsigned long arg);
-static void labpc_serial_out(struct comedi_device * dev, unsigned int value,
+static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
 	unsigned int num_bits);
-static unsigned int labpc_serial_in(struct comedi_device * dev);
-static unsigned int labpc_eeprom_read(struct comedi_device * dev,
+static unsigned int labpc_serial_in(struct comedi_device *dev);
+static unsigned int labpc_eeprom_read(struct comedi_device *dev,
 	unsigned int address);
-static unsigned int labpc_eeprom_read_status(struct comedi_device * dev);
-static unsigned int labpc_eeprom_write(struct comedi_device * dev,
+static unsigned int labpc_eeprom_read_status(struct comedi_device *dev);
+static unsigned int labpc_eeprom_write(struct comedi_device *dev,
 	unsigned int address, unsigned int value);
-static void write_caldac(struct comedi_device * dev, unsigned int channel,
+static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	unsigned int value);
 
 enum scan_mode {

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index caec783ca89a..e6ee7d94ca9a 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -362,54 +362,54 @@ static inline void labpc_writeb(unsigned int byte, unsigned long address)
 
 static const struct labpc_board_struct labpc_boards[] = {
 	{
-	      name:	"lab-pc-1200",
-	      ai_speed:10000,
-	      bustype:	isa_bustype,
-	      register_layout:labpc_1200_layout,
-	      has_ao:	1,
-	      ai_range_table:&range_labpc_1200_ai,
-	      ai_range_code:labpc_1200_ai_gain_bits,
-	      ai_range_is_unipolar:labpc_1200_is_unipolar,
-	      ai_scan_up:1,
-	      memory_mapped_io:0,
+	.name = "lab-pc-1200",
+	.ai_speed = 10000,
+	.bustype = isa_bustype,
+	.register_layout = labpc_1200_layout,
+	.has_ao = 1,
+	.ai_range_table = &range_labpc_1200_ai,
+	.ai_range_code = labpc_1200_ai_gain_bits,
+	.ai_range_is_unipolar = labpc_1200_is_unipolar,
+	.ai_scan_up = 1,
+	.memory_mapped_io = 0,
 		},
 	{
-	      name:	"lab-pc-1200ai",
-	      ai_speed:10000,
-	      bustype:	isa_bustype,
-	      register_layout:labpc_1200_layout,
-	      has_ao:	0,
-	      ai_range_table:&range_labpc_1200_ai,
-	      ai_range_code:labpc_1200_ai_gain_bits,
-	      ai_range_is_unipolar:labpc_1200_is_unipolar,
-	      ai_scan_up:1,
-	      memory_mapped_io:0,
+	.name = "lab-pc-1200ai",
+	.ai_speed = 10000,
+	.bustype = isa_bustype,
+	.register_layout = labpc_1200_layout,
+	.has_ao = 0,
+	.ai_range_table = &range_labpc_1200_ai,
+	.ai_range_code = labpc_1200_ai_gain_bits,
+	.ai_range_is_unipolar = labpc_1200_is_unipolar,
+	.ai_scan_up = 1,
+	.memory_mapped_io = 0,
 		},
 	{
-	      name:	"lab-pc+",
-	      ai_speed:12000,
-	      bustype:	isa_bustype,
-	      register_layout:labpc_plus_layout,
-	      has_ao:	1,
-	      ai_range_table:&range_labpc_plus_ai,
-	      ai_range_code:labpc_plus_ai_gain_bits,
-	      ai_range_is_unipolar:labpc_plus_is_unipolar,
-	      ai_scan_up:0,
-	      memory_mapped_io:0,
+	.name = "lab-pc+",
+	.ai_speed = 12000,
+	.bustype = isa_bustype,
+	.register_layout = labpc_plus_layout,
+	.has_ao = 1,
+	.ai_range_table = &range_labpc_plus_ai,
+	.ai_range_code = labpc_plus_ai_gain_bits,
+	.ai_range_is_unipolar = labpc_plus_is_unipolar,
+	.ai_scan_up = 0,
+	.memory_mapped_io = 0,
 		},
 #ifdef CONFIG_COMEDI_PCI
 	{
-		name:	"pci-1200",
-		device_id:0x161,
-		ai_speed:10000,
-		bustype:	pci_bustype,
-		register_layout:labpc_1200_layout,
-		has_ao:	1,
-		ai_range_table:&range_labpc_1200_ai,
-		ai_range_code:labpc_1200_ai_gain_bits,
-		ai_range_is_unipolar:labpc_1200_is_unipolar,
-		ai_scan_up:1,
-		memory_mapped_io:1,
+	.name = "pci-1200",
+	.device_id = 0x161,
+	.ai_speed = 10000,
+	.bustype = pci_bustype,
+	.register_layout = labpc_1200_layout,
+	.has_ao = 1,
+	.ai_range_table = &range_labpc_1200_ai,
+	.ai_range_code = labpc_1200_ai_gain_bits,
+	.ai_range_is_unipolar = labpc_1200_is_unipolar,
+	.ai_scan_up = 1,
+	.memory_mapped_io = 1,
 		},
 	/*  dummy entry so pci board works when comedi_config is passed driver name */
 	{

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 15172c20251d..caec783ca89a 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -448,7 +448,7 @@ static DEFINE_PCI_DEVICE_TABLE(labpc_pci_table) = {
 MODULE_DEVICE_TABLE(pci, labpc_pci_table);
 #endif /* CONFIG_COMEDI_PCI */
 
-static inline int labpc_counter_load(struct comedi_device * dev,
+static inline int labpc_counter_load(struct comedi_device *dev,
 	unsigned long base_address, unsigned int counter_number,
 	unsigned int count, unsigned int mode)
 {
@@ -459,7 +459,7 @@ static inline int labpc_counter_load(struct comedi_device * dev,
 		return i8254_load(base_address, 0, counter_number, count, mode);
 }
 
-int labpc_common_attach(struct comedi_device * dev, unsigned long iobase,
+int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
 	unsigned int irq, unsigned int dma_chan)
 {
 	struct comedi_subdevice *s;
@@ -643,7 +643,7 @@ int labpc_common_attach(struct comedi_device * dev, unsigned long iobase,
 	return 0;
 }
 
-static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	unsigned long iobase = 0;
 	unsigned int irq = 0;
@@ -724,7 +724,7 @@ static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 }
 #endif
 
-int labpc_common_detach(struct comedi_device * dev)
+int labpc_common_detach(struct comedi_device *dev)
 {
 	printk("comedi%d: ni_labpc: detach\n", dev->minor);
 
@@ -748,14 +748,14 @@ int labpc_common_detach(struct comedi_device * dev)
 	return 0;
 };
 
-static void labpc_clear_adc_fifo(const struct comedi_device * dev)
+static void labpc_clear_adc_fifo(const struct comedi_device *dev)
 {
 	devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
 	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
 	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
 }
 
-static int labpc_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -770,7 +770,7 @@ static int labpc_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd * cmd)
+static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)
 {
 	if (cmd->chanlist_len == 1)
 		return MODE_SINGLE_CHAN;
@@ -793,8 +793,8 @@ static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd * cmd)
 	return 0;
 }
 
-static int labpc_ai_chanlist_invalid(const struct comedi_device * dev,
-	const struct comedi_cmd * cmd)
+static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
+	const struct comedi_cmd *cmd)
 {
 	int mode, channel, range, aref, i;
 
@@ -865,7 +865,7 @@ static int labpc_ai_chanlist_invalid(const struct comedi_device * dev,
 	return 0;
 }
 
-static int labpc_use_continuous_mode(const struct comedi_cmd * cmd)
+static int labpc_use_continuous_mode(const struct comedi_cmd *cmd)
 {
 	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN)
 		return 1;
@@ -876,7 +876,7 @@ static int labpc_use_continuous_mode(const struct comedi_cmd * cmd)
 	return 0;
 }
 
-static unsigned int labpc_ai_convert_period(const struct comedi_cmd * cmd)
+static unsigned int labpc_ai_convert_period(const struct comedi_cmd *cmd)
 {
 	if (cmd->convert_src != TRIG_TIMER)
 		return 0;
@@ -888,7 +888,7 @@ static unsigned int labpc_ai_convert_period(const struct comedi_cmd * cmd)
 	return cmd->convert_arg;
 }
 
-static void labpc_set_ai_convert_period(struct comedi_cmd * cmd, unsigned int ns)
+static void labpc_set_ai_convert_period(struct comedi_cmd *cmd, unsigned int ns)
 {
 	if (cmd->convert_src != TRIG_TIMER)
 		return;
@@ -902,7 +902,7 @@ static void labpc_set_ai_convert_period(struct comedi_cmd * cmd, unsigned int ns
 		cmd->convert_arg = ns;
 }
 
-static unsigned int labpc_ai_scan_period(const struct comedi_cmd * cmd)
+static unsigned int labpc_ai_scan_period(const struct comedi_cmd *cmd)
 {
 	if (cmd->scan_begin_src != TRIG_TIMER)
 		return 0;
@@ -914,7 +914,7 @@ static unsigned int labpc_ai_scan_period(const struct comedi_cmd * cmd)
 	return cmd->scan_begin_arg;
 }
 
-static void labpc_set_ai_scan_period(struct comedi_cmd * cmd, unsigned int ns)
+static void labpc_set_ai_scan_period(struct comedi_cmd *cmd, unsigned int ns)
 {
 	if (cmd->scan_begin_src != TRIG_TIMER)
 		return;
@@ -926,8 +926,8 @@ static void labpc_set_ai_scan_period(struct comedi_cmd * cmd, unsigned int ns)
 	cmd->scan_begin_arg = ns;
 }
 
-static int labpc_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int labpc_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, tmp2;
@@ -1063,7 +1063,7 @@ static int labpc_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int channel, range, aref;
 	unsigned long irq_flags;
@@ -1393,7 +1393,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d)
 }
 
 /* read all available samples from ai fifo */
-static int labpc_drain_fifo(struct comedi_device * dev)
+static int labpc_drain_fifo(struct comedi_device *dev)
 {
 	unsigned int lsb, msb;
 	short data;
@@ -1427,7 +1427,7 @@ static int labpc_drain_fifo(struct comedi_device * dev)
 	return 0;
 }
 
-static void labpc_drain_dma(struct comedi_device * dev)
+static void labpc_drain_dma(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
@@ -1480,7 +1480,7 @@ static void labpc_drain_dma(struct comedi_device * dev)
 	async->events |= COMEDI_CB_BLOCK;
 }
 
-static void handle_isa_dma(struct comedi_device * dev)
+static void handle_isa_dma(struct comedi_device *dev)
 {
 	labpc_drain_dma(dev);
 
@@ -1492,7 +1492,7 @@ static void handle_isa_dma(struct comedi_device * dev)
 
 /* makes sure all data aquired by board is transfered to comedi (used
  * when aquisition is terminated by stop_src == TRIG_EXT). */
-static void labpc_drain_dregs(struct comedi_device * dev)
+static void labpc_drain_dregs(struct comedi_device *dev)
 {
 	if (devpriv->current_transfer == isa_dma_transfer)
 		labpc_drain_dma(dev);
@@ -1500,8 +1500,8 @@ static void labpc_drain_dregs(struct comedi_device * dev)
 	labpc_drain_fifo(dev);
 }
 
-static int labpc_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int chan, range;
@@ -1586,8 +1586,8 @@ static int labpc_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 /* analog output insn */
-static int labpc_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int channel, range;
 	unsigned long flags;
@@ -1627,24 +1627,24 @@ static int labpc_ao_winsn(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 /* analog output readback insn */
-static int labpc_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int labpc_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int labpc_calib_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int labpc_calib_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->caldac[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int labpc_calib_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int labpc_calib_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -1652,16 +1652,16 @@ static int labpc_calib_write_insn(struct comedi_device * dev, struct comedi_subd
 	return 1;
 }
 
-static int labpc_eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int labpc_eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->eeprom_data[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int labpc_eeprom_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int labpc_eeprom_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 	int ret;
@@ -1704,7 +1704,7 @@ static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd)
 }
 
 /* figures out what counter values to use based on command */
-static void labpc_adc_timing(struct comedi_device * dev, struct comedi_cmd * cmd)
+static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
 	const int max_counter_value = 0x10000;	/*  max value for 16 bit counter in mode 2 */
 	const int min_counter_value = 2;	/*  min value for 16 bit counter in mode 2 */
@@ -1796,7 +1796,7 @@ static int labpc_dio_mem_callback(int dir, int port, int data,
 }
 
 /* lowlevel write to eeprom/dac */
-static void labpc_serial_out(struct comedi_device * dev, unsigned int value,
+static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
 	unsigned int value_width)
 {
 	int i;
@@ -1821,7 +1821,7 @@ static void labpc_serial_out(struct comedi_device * dev, unsigned int value,
 }
 
 /* lowlevel read from eeprom */
-static unsigned int labpc_serial_in(struct comedi_device * dev)
+static unsigned int labpc_serial_in(struct comedi_device *dev)
 {
 	unsigned int value = 0;
 	int i;
@@ -1850,7 +1850,7 @@ static unsigned int labpc_serial_in(struct comedi_device * dev)
 	return value;
 }
 
-static unsigned int labpc_eeprom_read(struct comedi_device * dev, unsigned int address)
+static unsigned int labpc_eeprom_read(struct comedi_device *dev, unsigned int address)
 {
 	unsigned int value;
 	const int read_instruction = 0x3;	/*  bits to tell eeprom to expect a read */
@@ -1879,7 +1879,7 @@ static unsigned int labpc_eeprom_read(struct comedi_device * dev, unsigned int a
 	return value;
 }
 
-static unsigned int labpc_eeprom_write(struct comedi_device * dev,
+static unsigned int labpc_eeprom_write(struct comedi_device *dev,
 	unsigned int address, unsigned int value)
 {
 	const int write_enable_instruction = 0x6;
@@ -1937,7 +1937,7 @@ static unsigned int labpc_eeprom_write(struct comedi_device * dev,
 	return 0;
 }
 
-static unsigned int labpc_eeprom_read_status(struct comedi_device * dev)
+static unsigned int labpc_eeprom_read_status(struct comedi_device *dev)
 {
 	unsigned int value;
 	const int read_status_instruction = 0x5;
@@ -1965,7 +1965,7 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device * dev)
 }
 
 /* writes to 8 bit calibration dacs */
-static void write_caldac(struct comedi_device * dev, unsigned int channel,
+static void write_caldac(struct comedi_device *dev, unsigned int channel,
 	unsigned int value)
 {
 	if (value == devpriv->caldac[channel])

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 028eada2ad74..15172c20251d 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -165,7 +165,7 @@ NI manuals:
 
 static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int labpc_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG);
+static irqreturn_t labpc_interrupt(int irq, void *d);
 static int labpc_drain_fifo(struct comedi_device * dev);
 static void labpc_drain_dma(struct comedi_device * dev);
 static void handle_isa_dma(struct comedi_device * dev);
@@ -1309,7 +1309,7 @@ static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 }
 
 /* interrupt service routine */
-static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG)
+static irqreturn_t labpc_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->read_subdev;

commit f6b49620a43ca661246d209009b849d7d3030cae
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:31:11 2009 -0400

    Staging: comedi: remove C99 comments in ni_labpc.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index c0da5c75b4bb..028eada2ad74 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -74,7 +74,7 @@ NI manuals:
 */
 
 #undef LABPC_DEBUG
-//#define LABPC_DEBUG   // enable debugging messages
+/* #define LABPC_DEBUG    enable debugging messages */
 
 #include "../comedidev.h"
 
@@ -89,78 +89,78 @@ NI manuals:
 
 #define DRV_NAME "ni_labpc"
 
-#define LABPC_SIZE           32	// size of io region used by board
-#define LABPC_TIMER_BASE            500	// 2 MHz master clock
+#define LABPC_SIZE           32	/*  size of io region used by board */
+#define LABPC_TIMER_BASE            500	/*  2 MHz master clock */
 
 /* Registers for the lab-pc+ */
 
-//write-only registers
+/* write-only registers */
 #define COMMAND1_REG	0x0
 #define   ADC_GAIN_MASK	(0x7 << 4)
 #define   ADC_CHAN_BITS(x)	((x) & 0x7)
-#define   ADC_SCAN_EN_BIT	0x80	// enables multi channel scans
+#define   ADC_SCAN_EN_BIT	0x80	/*  enables multi channel scans */
 #define COMMAND2_REG	0x1
-#define   PRETRIG_BIT	0x1	// enable pretriggering (used in conjunction with SWTRIG)
-#define   HWTRIG_BIT	0x2	// enable paced conversions on external trigger
-#define   SWTRIG_BIT	0x4	// enable paced conversions
-#define   CASCADE_BIT	0x8	// use two cascaded counters for pacing
+#define   PRETRIG_BIT	0x1	/*  enable pretriggering (used in conjunction with SWTRIG) */
+#define   HWTRIG_BIT	0x2	/*  enable paced conversions on external trigger */
+#define   SWTRIG_BIT	0x4	/*  enable paced conversions */
+#define   CASCADE_BIT	0x8	/*  use two cascaded counters for pacing */
 #define   DAC_PACED_BIT(channel)	(0x40 << ((channel) & 0x1))
 #define COMMAND3_REG	0x2
-#define   DMA_EN_BIT	0x1	// enable dma transfers
-#define   DIO_INTR_EN_BIT	0x2	// enable interrupts for 8255
-#define   DMATC_INTR_EN_BIT	0x4	// enable dma terminal count interrupt
-#define   TIMER_INTR_EN_BIT	0x8	// enable timer interrupt
-#define   ERR_INTR_EN_BIT	0x10	// enable error interrupt
-#define   ADC_FNE_INTR_EN_BIT	0x20	// enable fifo not empty interrupt
+#define   DMA_EN_BIT	0x1	/*  enable dma transfers */
+#define   DIO_INTR_EN_BIT	0x2	/*  enable interrupts for 8255 */
+#define   DMATC_INTR_EN_BIT	0x4	/*  enable dma terminal count interrupt */
+#define   TIMER_INTR_EN_BIT	0x8	/*  enable timer interrupt */
+#define   ERR_INTR_EN_BIT	0x10	/*  enable error interrupt */
+#define   ADC_FNE_INTR_EN_BIT	0x20	/*  enable fifo not empty interrupt */
 #define ADC_CONVERT_REG	0x3
 #define DAC_LSB_REG(channel)	(0x4 + 2 * ((channel) & 0x1))
 #define DAC_MSB_REG(channel)	(0x5 + 2 * ((channel) & 0x1))
 #define ADC_CLEAR_REG	0x8
 #define DMATC_CLEAR_REG	0xa
 #define TIMER_CLEAR_REG	0xc
-#define COMMAND6_REG	0xe	// 1200 boards only
-#define   ADC_COMMON_BIT	0x1	// select ground or common-mode reference
-#define   ADC_UNIP_BIT	0x2	// adc unipolar
-#define   DAC_UNIP_BIT(channel)	(0x4 << ((channel) & 0x1))	// dac unipolar
-#define   ADC_FHF_INTR_EN_BIT	0x20	// enable fifo half full interrupt
-#define   A1_INTR_EN_BIT	0x40	// enable interrupt on end of hardware count
-#define   ADC_SCAN_UP_BIT 0x80	// scan up from channel zero instead of down to zero
+#define COMMAND6_REG	0xe	/*  1200 boards only */
+#define   ADC_COMMON_BIT	0x1	/*  select ground or common-mode reference */
+#define   ADC_UNIP_BIT	0x2	/*  adc unipolar */
+#define   DAC_UNIP_BIT(channel)	(0x4 << ((channel) & 0x1))	/*  dac unipolar */
+#define   ADC_FHF_INTR_EN_BIT	0x20	/*  enable fifo half full interrupt */
+#define   A1_INTR_EN_BIT	0x40	/*  enable interrupt on end of hardware count */
+#define   ADC_SCAN_UP_BIT 0x80	/*  scan up from channel zero instead of down to zero */
 #define COMMAND4_REG	0xf
-#define   INTERVAL_SCAN_EN_BIT	0x1	// enables 'interval' scanning
-#define   EXT_SCAN_EN_BIT	0x2	// enables external signal on counter b1 output to trigger scan
-#define   EXT_CONVERT_OUT_BIT	0x4	// chooses direction (output or input) for EXTCONV* line
-#define   ADC_DIFF_BIT	0x8	// chooses differential inputs for adc (in conjunction with board jumper)
+#define   INTERVAL_SCAN_EN_BIT	0x1	/*  enables 'interval' scanning */
+#define   EXT_SCAN_EN_BIT	0x2	/*  enables external signal on counter b1 output to trigger scan */
+#define   EXT_CONVERT_OUT_BIT	0x4	/*  chooses direction (output or input) for EXTCONV* line */
+#define   ADC_DIFF_BIT	0x8	/*  chooses differential inputs for adc (in conjunction with board jumper) */
 #define   EXT_CONVERT_DISABLE_BIT	0x10
-#define COMMAND5_REG	0x1c	// 1200 boards only, calibration stuff
-#define   EEPROM_WRITE_UNPROTECT_BIT	0x4	// enable eeprom for write
-#define   DITHER_EN_BIT	0x8	// enable dithering
-#define   CALDAC_LOAD_BIT	0x10	// load calibration dac
-#define   SCLOCK_BIT	0x20	// serial clock - rising edge writes, falling edge reads
-#define   SDATA_BIT	0x40	// serial data bit for writing to eeprom or calibration dacs
-#define   EEPROM_EN_BIT	0x80	// enable eeprom for read/write
+#define COMMAND5_REG	0x1c	/*  1200 boards only, calibration stuff */
+#define   EEPROM_WRITE_UNPROTECT_BIT	0x4	/*  enable eeprom for write */
+#define   DITHER_EN_BIT	0x8	/*  enable dithering */
+#define   CALDAC_LOAD_BIT	0x10	/*  load calibration dac */
+#define   SCLOCK_BIT	0x20	/*  serial clock - rising edge writes, falling edge reads */
+#define   SDATA_BIT	0x40	/*  serial data bit for writing to eeprom or calibration dacs */
+#define   EEPROM_EN_BIT	0x80	/*  enable eeprom for read/write */
 #define INTERVAL_COUNT_REG	0x1e
 #define INTERVAL_LOAD_REG	0x1f
 #define   INTERVAL_LOAD_BITS	0x1
 
-// read-only registers
+/* read-only registers */
 #define STATUS1_REG	0x0
-#define   DATA_AVAIL_BIT	0x1	// data is available in fifo
-#define   OVERRUN_BIT	0x2	// overrun has occurred
-#define   OVERFLOW_BIT	0x4	// fifo overflow
-#define   TIMER_BIT	0x8	// timer interrupt has occured
-#define   DMATC_BIT	0x10	// dma terminal count has occured
-#define   EXT_TRIG_BIT	0x40	// external trigger has occured
-#define STATUS2_REG	0x1d	// 1200 boards only
-#define   EEPROM_OUT_BIT	0x1	// programmable eeprom serial output
-#define   A1_TC_BIT	0x2	// counter A1 terminal count
-#define   FNHF_BIT	0x4	// fifo not half full
+#define   DATA_AVAIL_BIT	0x1	/*  data is available in fifo */
+#define   OVERRUN_BIT	0x2	/*  overrun has occurred */
+#define   OVERFLOW_BIT	0x4	/*  fifo overflow */
+#define   TIMER_BIT	0x8	/*  timer interrupt has occured */
+#define   DMATC_BIT	0x10	/*  dma terminal count has occured */
+#define   EXT_TRIG_BIT	0x40	/*  external trigger has occured */
+#define STATUS2_REG	0x1d	/*  1200 boards only */
+#define   EEPROM_OUT_BIT	0x1	/*  programmable eeprom serial output */
+#define   A1_TC_BIT	0x2	/*  counter A1 terminal count */
+#define   FNHF_BIT	0x4	/*  fifo not half full */
 #define ADC_FIFO_REG	0xa
 
 #define DIO_BASE_REG	0x10
 #define COUNTER_A_BASE_REG	0x14
 #define COUNTER_A_CONTROL_REG	(COUNTER_A_BASE_REG + 0x3)
-#define   INIT_A0_BITS	0x14	// check modes put conversion pacer output in harmless state (a0 mode 2)
-#define   INIT_A1_BITS	0x70	// put hardware conversion counter output in harmless state (a1 mode 0)
+#define   INIT_A0_BITS	0x14	/*  check modes put conversion pacer output in harmless state (a0 mode 2) */
+#define   INIT_A1_BITS	0x70	/*  put hardware conversion counter output in harmless state (a1 mode 0) */
 #define COUNTER_B_BASE_REG	0x18
 
 static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it);
@@ -212,9 +212,9 @@ enum scan_mode {
 	MODE_MULT_CHAN_DOWN,
 };
 
-//analog input ranges
+/* analog input ranges */
 #define NUM_LABPC_PLUS_AI_RANGES 16
-// indicates unipolar ranges
+/* indicates unipolar ranges */
 static const int labpc_plus_is_unipolar[NUM_LABPC_PLUS_AI_RANGES] = {
 	0,
 	0,
@@ -234,7 +234,7 @@ static const int labpc_plus_is_unipolar[NUM_LABPC_PLUS_AI_RANGES] = {
 	1,
 };
 
-// map range index to gain bits
+/* map range index to gain bits */
 static const int labpc_plus_ai_gain_bits[NUM_LABPC_PLUS_AI_RANGES] = {
 	0x00,
 	0x10,
@@ -276,7 +276,7 @@ static const struct comedi_lrange range_labpc_plus_ai = {
 };
 
 #define NUM_LABPC_1200_AI_RANGES 14
-// indicates unipolar ranges
+/* indicates unipolar ranges */
 const int labpc_1200_is_unipolar[NUM_LABPC_1200_AI_RANGES] = {
 	0,
 	0,
@@ -294,7 +294,7 @@ const int labpc_1200_is_unipolar[NUM_LABPC_1200_AI_RANGES] = {
 	1,
 };
 
-// map range index to gain bits
+/* map range index to gain bits */
 const int labpc_1200_ai_gain_bits[NUM_LABPC_1200_AI_RANGES] = {
 	0x00,
 	0x20,
@@ -331,7 +331,7 @@ const struct comedi_lrange range_labpc_1200_ai = {
 		}
 };
 
-//analog output ranges
+/* analog output ranges */
 #define AO_RANGE_IS_UNIPOLAR 0x1
 static const struct comedi_lrange range_labpc_ao = {
 	2,
@@ -411,7 +411,7 @@ static const struct labpc_board_struct labpc_boards[] = {
 		ai_scan_up:1,
 		memory_mapped_io:1,
 		},
-	// dummy entry so pci board works when comedi_config is passed driver name
+	/*  dummy entry so pci board works when comedi_config is passed driver name */
 	{
 		.name = DRV_NAME,
 		.bustype = pci_bustype,
@@ -424,8 +424,8 @@ static const struct labpc_board_struct labpc_boards[] = {
  */
 #define thisboard ((struct labpc_board_struct *)dev->board_ptr)
 
-static const int dma_buffer_size = 0xff00;	// size in bytes of dma buffer
-static const int sample_size = 2;	// 2 bytes per sample
+static const int dma_buffer_size = 0xff00;	/*  size in bytes of dma buffer */
+static const int sample_size = 2;	/*  2 bytes per sample */
 
 #define devpriv ((struct labpc_private *)dev->private)
 
@@ -481,7 +481,7 @@ int labpc_common_attach(struct comedi_device * dev, unsigned long iobase,
 		printk("io base address is zero!\n");
 		return -EINVAL;
 	}
-	// request io regions for isa boards
+	/*  request io regions for isa boards */
 	if (thisboard->bustype == isa_bustype) {
 		/* check if io addresses are available */
 		if (!request_region(iobase, LABPC_SIZE,
@@ -499,7 +499,7 @@ int labpc_common_attach(struct comedi_device * dev, unsigned long iobase,
 		devpriv->read_byte = labpc_inb;
 		devpriv->write_byte = labpc_outb;
 	}
-	// initialize board's command registers
+	/*  initialize board's command registers */
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
@@ -524,12 +524,12 @@ int labpc_common_attach(struct comedi_device * dev, unsigned long iobase,
 	}
 	dev->irq = irq;
 
-	// grab dma channel
+	/*  grab dma channel */
 	if (dma_chan > 3) {
 		printk(" invalid dma channel %u\n", dma_chan);
 		return -EINVAL;
 	} else if (dma_chan) {
-		// allocate dma buffer
+		/*  allocate dma buffer */
 		devpriv->dma_buffer =
 			kmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);
 		if (devpriv->dma_buffer == NULL) {
@@ -562,7 +562,7 @@ int labpc_common_attach(struct comedi_device * dev, unsigned long iobase,
 		SDF_CMD_READ;
 	s->n_chan = 8;
 	s->len_chanlist = 8;
-	s->maxdata = (1 << 12) - 1;	// 12 bit resolution
+	s->maxdata = (1 << 12) - 1;	/*  12 bit resolution */
 	s->range_table = thisboard->ai_range_table;
 	s->do_cmd = labpc_ai_cmd;
 	s->do_cmdtest = labpc_ai_cmdtest;
@@ -577,7 +577,7 @@ int labpc_common_attach(struct comedi_device * dev, unsigned long iobase,
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
 		s->n_chan = NUM_AO_CHAN;
-		s->maxdata = (1 << 12) - 1;	// 12 bit resolution
+		s->maxdata = (1 << 12) - 1;	/*  12 bit resolution */
 		s->range_table = &range_labpc_ao;
 		s->insn_read = labpc_ao_rinsn;
 		s->insn_write = labpc_ao_winsn;
@@ -595,14 +595,14 @@ int labpc_common_attach(struct comedi_device * dev, unsigned long iobase,
 
 	/* 8255 dio */
 	s = dev->subdevices + 2;
-	// if board uses io memory we have to give a custom callback function to the 8255 driver
+	/*  if board uses io memory we have to give a custom callback function to the 8255 driver */
 	if (thisboard->memory_mapped_io)
 		subdev_8255_init(dev, s, labpc_dio_mem_callback,
 			(unsigned long)(dev->iobase + DIO_BASE_REG));
 	else
 		subdev_8255_init(dev, s, NULL, dev->iobase + DIO_BASE_REG);
 
-	// calibration subdevices for boards that have one
+	/*  calibration subdevices for boards that have one */
 	s = dev->subdevices + 3;
 	if (thisboard->register_layout == labpc_1200_layout) {
 		s->type = COMEDI_SUBD_CALIB;
@@ -656,7 +656,7 @@ static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it
 	if (alloc_private(dev, sizeof(struct labpc_private)) < 0)
 		return -ENOMEM;
 
-	// get base address, irq etc. based on bustype
+	/*  get base address, irq etc. based on bustype */
 	switch (thisboard->bustype) {
 	case isa_bustype:
 		iobase = it->options[0];
@@ -692,7 +692,7 @@ static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it
 	return labpc_common_attach(dev, iobase, irq, dma_chan);
 }
 
-// adapted from ni_pcimio for finding mite based boards (pc-1200)
+/* adapted from ni_pcimio for finding mite based boards (pc-1200) */
 #ifdef CONFIG_COMEDI_PCI
 static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 {
@@ -701,7 +701,7 @@ static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
-		// if bus/slot are specified then make sure we have the right bus/slot
+		/*  if bus/slot are specified then make sure we have the right bus/slot */
 		if (bus || slot) {
 			if (bus != mite->pcidev->bus->number
 				|| slot != PCI_SLOT(mite->pcidev->devfn))
@@ -712,7 +712,7 @@ static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 				continue;
 			if (mite_device_id(mite) == labpc_boards[i].device_id) {
 				devpriv->mite = mite;
-				// fixup board pointer, in case we were using the dummy "ni_labpc" entry
+				/*  fixup board pointer, in case we were using the dummy "ni_labpc" entry */
 				dev->board_ptr = &labpc_boards[i];
 				return 0;
 			}
@@ -980,7 +980,7 @@ static int labpc_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 		cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
 		err++;
 
-	// can't have external stop and start triggers at once
+	/*  can't have external stop and start triggers at once */
 	if (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)
 		err++;
 
@@ -1008,7 +1008,7 @@ static int labpc_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 			err++;
 		}
 	}
-	// make sure scan timing is not too fast
+	/*  make sure scan timing is not too fast */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->convert_src == TRIG_TIMER &&
 			cmd->scan_begin_arg <
@@ -1024,7 +1024,7 @@ static int labpc_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 			err++;
 		}
 	}
-	// stop source
+	/*  stop source */
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
 		if (!cmd->stop_arg) {
@@ -1038,7 +1038,7 @@ static int labpc_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 			err++;
 		}
 		break;
-		// TRIG_EXT doesn't care since it doesn't trigger off a numbered channel
+		/*  TRIG_EXT doesn't care since it doesn't trigger off a numbered channel */
 	default:
 		break;
 	}
@@ -1081,7 +1081,7 @@ static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	range = CR_RANGE(cmd->chanlist[0]);
 	aref = CR_AREF(cmd->chanlist[0]);
 
-	// make sure board is disabled before setting up aquisition
+	/*  make sure board is disabled before setting up aquisition */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
@@ -1090,68 +1090,68 @@ static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	devpriv->command3_bits = 0;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
-	// initialize software conversion count
+	/*  initialize software conversion count */
 	if (cmd->stop_src == TRIG_COUNT) {
 		devpriv->count = cmd->stop_arg * cmd->chanlist_len;
 	}
-	// setup hardware conversion counter
+	/*  setup hardware conversion counter */
 	if (cmd->stop_src == TRIG_EXT) {
-		// load counter a1 with count of 3 (pc+ manual says this is minimum allowed) using mode 0
+		/*  load counter a1 with count of 3 (pc+ manual says this is minimum allowed) using mode 0 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
 			1, 3, 0);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter a1");
 			return -1;
 		}
-	} else			// otherwise, just put a1 in mode 0 with no count to set its output low
+	} else			/*  otherwise, just put a1 in mode 0 with no count to set its output low */
 		devpriv->write_byte(INIT_A1_BITS,
 			dev->iobase + COUNTER_A_CONTROL_REG);
 
-	// figure out what method we will use to transfer data
-	if (devpriv->dma_chan &&	// need a dma channel allocated
-		// dma unsafe at RT priority, and too much setup time for TRIG_WAKE_EOS for
+	/*  figure out what method we will use to transfer data */
+	if (devpriv->dma_chan &&	/*  need a dma channel allocated */
+		/*  dma unsafe at RT priority, and too much setup time for TRIG_WAKE_EOS for */
 		(cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0 &&
-		// only available on the isa boards
+		/*  only available on the isa boards */
 		thisboard->bustype == isa_bustype) {
 		xfer = isa_dma_transfer;
-	} else if (thisboard->register_layout == labpc_1200_layout &&	// pc-plus has no fifo-half full interrupt
-		// wake-end-of-scan should interrupt on fifo not empty
+	} else if (thisboard->register_layout == labpc_1200_layout &&	/*  pc-plus has no fifo-half full interrupt */
+		/*  wake-end-of-scan should interrupt on fifo not empty */
 		(cmd->flags & TRIG_WAKE_EOS) == 0 &&
-		// make sure we are taking more than just a few points
+		/*  make sure we are taking more than just a few points */
 		(cmd->stop_src != TRIG_COUNT || devpriv->count > 256)) {
 		xfer = fifo_half_full_transfer;
 	} else
 		xfer = fifo_not_empty_transfer;
 	devpriv->current_transfer = xfer;
 
-	// setup command6 register for 1200 boards
+	/*  setup command6 register for 1200 boards */
 	if (thisboard->register_layout == labpc_1200_layout) {
-		// reference inputs to ground or common?
+		/*  reference inputs to ground or common? */
 		if (aref != AREF_GROUND)
 			devpriv->command6_bits |= ADC_COMMON_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_COMMON_BIT;
-		// bipolar or unipolar range?
+		/*  bipolar or unipolar range? */
 		if (thisboard->ai_range_is_unipolar[range])
 			devpriv->command6_bits |= ADC_UNIP_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_UNIP_BIT;
-		// interrupt on fifo half full?
+		/*  interrupt on fifo half full? */
 		if (xfer == fifo_half_full_transfer)
 			devpriv->command6_bits |= ADC_FHF_INTR_EN_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;
-		// enable interrupt on counter a1 terminal count?
+		/*  enable interrupt on counter a1 terminal count? */
 		if (cmd->stop_src == TRIG_EXT)
 			devpriv->command6_bits |= A1_INTR_EN_BIT;
 		else
 			devpriv->command6_bits &= ~A1_INTR_EN_BIT;
-		// are we scanning up or down through channels?
+		/*  are we scanning up or down through channels? */
 		if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP)
 			devpriv->command6_bits |= ADC_SCAN_UP_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_SCAN_UP_BIT;
-		// write to register
+		/*  write to register */
 		devpriv->write_byte(devpriv->command6_bits,
 			dev->iobase + COMMAND6_REG);
 	}
@@ -1162,13 +1162,13 @@ static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		channel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);
 	else
 		channel = CR_CHAN(cmd->chanlist[0]);
-	// munge channel bits for differential / scan disabled mode
+	/*  munge channel bits for differential / scan disabled mode */
 	if (labpc_ai_scan_mode(cmd) != MODE_SINGLE_CHAN && aref == AREF_DIFF)
 		channel *= 2;
 	devpriv->command1_bits |= ADC_CHAN_BITS(channel);
 	devpriv->command1_bits |= thisboard->ai_range_code[range];
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
-	// manual says to set scan enable bit on second pass
+	/*  manual says to set scan enable bit on second pass */
 	if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP ||
 		labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_DOWN) {
 		devpriv->command1_bits |= ADC_SCAN_EN_BIT;
@@ -1178,7 +1178,7 @@ static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		devpriv->write_byte(devpriv->command1_bits,
 			dev->iobase + COMMAND1_REG);
 	}
-	// setup any external triggering/pacing (command4 register)
+	/*  setup any external triggering/pacing (command4 register) */
 	devpriv->command4_bits = 0;
 	if (cmd->convert_src != TRIG_EXT)
 		devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
@@ -1189,21 +1189,21 @@ static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		if (cmd->scan_begin_src == TRIG_EXT)
 			devpriv->command4_bits |= EXT_SCAN_EN_BIT;
 	}
-	// single-ended/differential
+	/*  single-ended/differential */
 	if (aref == AREF_DIFF)
 		devpriv->command4_bits |= ADC_DIFF_BIT;
 	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
 
 	devpriv->write_byte(cmd->chanlist_len,
 		dev->iobase + INTERVAL_COUNT_REG);
-	// load count
+	/*  load count */
 	devpriv->write_byte(INTERVAL_LOAD_BITS,
 		dev->iobase + INTERVAL_LOAD_REG);
 
 	if (cmd->convert_src == TRIG_TIMER || cmd->scan_begin_src == TRIG_TIMER) {
-		// set up pacing
+		/*  set up pacing */
 		labpc_adc_timing(dev, cmd);
-		// load counter b0 in mode 3
+		/*  load counter b0 in mode 3 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
 			0, devpriv->divisor_b0, 3);
 		if (ret < 0) {
@@ -1211,9 +1211,9 @@ static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 			return -1;
 		}
 	}
-	// set up conversion pacing
+	/*  set up conversion pacing */
 	if (labpc_ai_convert_period(cmd)) {
-		// load counter a0 in mode 2
+		/*  load counter a0 in mode 2 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
 			0, devpriv->divisor_a0, 2);
 		if (ret < 0) {
@@ -1224,9 +1224,9 @@ static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		devpriv->write_byte(INIT_A0_BITS,
 			dev->iobase + COUNTER_A_CONTROL_REG);
 
-	// set up scan pacing
+	/*  set up scan pacing */
 	if (labpc_ai_scan_period(cmd)) {
-		// load counter b1 in mode 2
+		/*  load counter b1 in mode 2 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
 			1, devpriv->divisor_b1, 2);
 		if (ret < 0) {
@@ -1237,7 +1237,7 @@ static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 
 	labpc_clear_adc_fifo(dev);
 
-	// set up dma transfer
+	/*  set up dma transfer */
 	if (xfer == isa_dma_transfer) {
 		irq_flags = claim_dma_lock();
 		disable_dma(devpriv->dma_chan);
@@ -1246,7 +1246,7 @@ static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		clear_dma_ff(devpriv->dma_chan);
 		set_dma_addr(devpriv->dma_chan,
 			virt_to_bus(devpriv->dma_buffer));
-		// set appropriate size of transfer
+		/*  set appropriate size of transfer */
 		devpriv->dma_transfer_size = labpc_suggest_transfer_size(*cmd);
 		if (cmd->stop_src == TRIG_COUNT &&
 			devpriv->count * sample_size <
@@ -1257,24 +1257,24 @@ static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 		enable_dma(devpriv->dma_chan);
 		release_dma_lock(irq_flags);
-		// enable board's dma
+		/*  enable board's dma */
 		devpriv->command3_bits |= DMA_EN_BIT | DMATC_INTR_EN_BIT;
 	} else
 		devpriv->command3_bits &= ~DMA_EN_BIT & ~DMATC_INTR_EN_BIT;
 
-	// enable error interrupts
+	/*  enable error interrupts */
 	devpriv->command3_bits |= ERR_INTR_EN_BIT;
-	// enable fifo not empty interrupt?
+	/*  enable fifo not empty interrupt? */
 	if (xfer == fifo_not_empty_transfer)
 		devpriv->command3_bits |= ADC_FNE_INTR_EN_BIT;
 	else
 		devpriv->command3_bits &= ~ADC_FNE_INTR_EN_BIT;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
-	// startup aquisition
+	/*  startup aquisition */
 
-	// command2 reg
-	// use 2 cascaded counters for pacing
+	/*  command2 reg */
+	/*  use 2 cascaded counters for pacing */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits |= CASCADE_BIT;
 	switch (cmd->start_src) {
@@ -1325,7 +1325,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG)
 	cmd = &async->cmd;
 	async->events = 0;
 
-	// read board status
+	/*  read board status */
 	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
 	if (thisboard->register_layout == labpc_1200_layout)
 		devpriv->status2_bits =
@@ -1339,7 +1339,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG)
 	}
 
 	if (devpriv->status1_bits & OVERRUN_BIT) {
-		// clear error interrupt
+		/*  clear error interrupt */
 		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		comedi_event(dev, s);
@@ -1348,7 +1348,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG)
 	}
 
 	if (devpriv->current_transfer == isa_dma_transfer) {
-		// if a dma terminal count of external stop trigger has occurred
+		/*  if a dma terminal count of external stop trigger has occurred */
 		if (devpriv->status1_bits & DMATC_BIT ||
 			(thisboard->register_layout == labpc_1200_layout
 				&& devpriv->status2_bits & A1_TC_BIT)) {
@@ -1359,19 +1359,19 @@ static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG)
 
 	if (devpriv->status1_bits & TIMER_BIT) {
 		comedi_error(dev, "handled timer interrupt?");
-		// clear it
+		/*  clear it */
 		devpriv->write_byte(0x1, dev->iobase + TIMER_CLEAR_REG);
 	}
 
 	if (devpriv->status1_bits & OVERFLOW_BIT) {
-		// clear error interrupt
+		/*  clear error interrupt */
 		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		comedi_event(dev, s);
 		comedi_error(dev, "overflow");
 		return IRQ_HANDLED;
 	}
-	// handle external stop trigger
+	/*  handle external stop trigger */
 	if (cmd->stop_src == TRIG_EXT) {
 		if (devpriv->status2_bits & A1_TC_BIT) {
 			labpc_drain_dregs(dev);
@@ -1392,7 +1392,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-// read all available samples from ai fifo
+/* read all available samples from ai fifo */
 static int labpc_drain_fifo(struct comedi_device * dev)
 {
 	unsigned int lsb, msb;
@@ -1405,7 +1405,7 @@ static int labpc_drain_fifo(struct comedi_device * dev)
 
 	for (i = 0; (devpriv->status1_bits & DATA_AVAIL_BIT) && i < timeout;
 		i++) {
-		// quit if we have all the data we want
+		/*  quit if we have all the data we want */
 		if (async->cmd.stop_src == TRIG_COUNT) {
 			if (devpriv->count == 0)
 				break;
@@ -1444,7 +1444,7 @@ static void labpc_drain_dma(struct comedi_device * dev)
 	 * count and address get set correctly */
 	clear_dma_ff(devpriv->dma_chan);
 
-	// figure out how many points to read
+	/*  figure out how many points to read */
 	max_points = devpriv->dma_transfer_size / sample_size;
 	/* residue is the number of points left to be done on the dma
 	 * transfer.  It should always be zero at this point unless
@@ -1455,7 +1455,7 @@ static void labpc_drain_dma(struct comedi_device * dev)
 	if (devpriv->count < num_points && async->cmd.stop_src == TRIG_COUNT)
 		num_points = devpriv->count;
 
-	// figure out how many points will be stored next time
+	/*  figure out how many points will be stored next time */
 	leftover = 0;
 	if (async->cmd.stop_src != TRIG_COUNT) {
 		leftover = devpriv->dma_transfer_size / sample_size;
@@ -1472,7 +1472,7 @@ static void labpc_drain_dma(struct comedi_device * dev)
 	if (async->cmd.stop_src == TRIG_COUNT)
 		devpriv->count -= num_points;
 
-	// set address and count for next transfer
+	/*  set address and count for next transfer */
 	set_dma_addr(devpriv->dma_chan, virt_to_bus(devpriv->dma_buffer));
 	set_dma_count(devpriv->dma_chan, leftover * sample_size);
 	release_dma_lock(flags);
@@ -1486,7 +1486,7 @@ static void handle_isa_dma(struct comedi_device * dev)
 
 	enable_dma(devpriv->dma_chan);
 
-	// clear dma tc interrupt
+	/*  clear dma tc interrupt */
 	devpriv->write_byte(0x1, dev->iobase + DMATC_CLEAR_REG);
 }
 
@@ -1509,13 +1509,13 @@ static int labpc_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 	int timeout = 1000;
 	unsigned long flags;
 
-	// disable timed conversions
+	/*  disable timed conversions */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// disable interrupt generation and dma
+	/*  disable interrupt generation and dma */
 	devpriv->command3_bits = 0;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
@@ -1524,41 +1524,41 @@ static int labpc_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 	chan = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
 	devpriv->command1_bits |= thisboard->ai_range_code[range];
-	// munge channel bits for differential/scan disabled mode
+	/*  munge channel bits for differential/scan disabled mode */
 	if (CR_AREF(insn->chanspec) == AREF_DIFF)
 		chan *= 2;
 	devpriv->command1_bits |= ADC_CHAN_BITS(chan);
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
 
-	// setup command6 register for 1200 boards
+	/*  setup command6 register for 1200 boards */
 	if (thisboard->register_layout == labpc_1200_layout) {
-		// reference inputs to ground or common?
+		/*  reference inputs to ground or common? */
 		if (CR_AREF(insn->chanspec) != AREF_GROUND)
 			devpriv->command6_bits |= ADC_COMMON_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_COMMON_BIT;
-		// bipolar or unipolar range?
+		/*  bipolar or unipolar range? */
 		if (thisboard->ai_range_is_unipolar[range])
 			devpriv->command6_bits |= ADC_UNIP_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_UNIP_BIT;
-		// don't interrupt on fifo half full
+		/*  don't interrupt on fifo half full */
 		devpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;
-		// don't enable interrupt on counter a1 terminal count?
+		/*  don't enable interrupt on counter a1 terminal count? */
 		devpriv->command6_bits &= ~A1_INTR_EN_BIT;
-		// write to register
+		/*  write to register */
 		devpriv->write_byte(devpriv->command6_bits,
 			dev->iobase + COMMAND6_REG);
 	}
-	// setup command4 register
+	/*  setup command4 register */
 	devpriv->command4_bits = 0;
 	devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
-	// single-ended/differential
+	/*  single-ended/differential */
 	if (CR_AREF(insn->chanspec) == AREF_DIFF)
 		devpriv->command4_bits |= ADC_DIFF_BIT;
 	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
 
-	// initialize pacer counter output to make sure it doesn't cause any problems
+	/*  initialize pacer counter output to make sure it doesn't cause any problems */
 	devpriv->write_byte(INIT_A0_BITS, dev->iobase + COUNTER_A_CONTROL_REG);
 
 	labpc_clear_adc_fifo(dev);
@@ -1585,7 +1585,7 @@ static int labpc_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 	return n;
 }
 
-// analog output insn
+/* analog output insn */
 static int labpc_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
@@ -1595,7 +1595,7 @@ static int labpc_ao_winsn(struct comedi_device * dev, struct comedi_subdevice *
 
 	channel = CR_CHAN(insn->chanspec);
 
-	// turn off pacing of analog output channel
+	/*  turn off pacing of analog output channel */
 	/* note: hardware bug in daqcard-1200 means pacing cannot
 	 * be independently enabled/disabled for its the two channels */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
@@ -1603,30 +1603,30 @@ static int labpc_ao_winsn(struct comedi_device * dev, struct comedi_subdevice *
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// set range
+	/*  set range */
 	if (thisboard->register_layout == labpc_1200_layout) {
 		range = CR_RANGE(insn->chanspec);
 		if (range & AO_RANGE_IS_UNIPOLAR)
 			devpriv->command6_bits |= DAC_UNIP_BIT(channel);
 		else
 			devpriv->command6_bits &= ~DAC_UNIP_BIT(channel);
-		// write to register
+		/*  write to register */
 		devpriv->write_byte(devpriv->command6_bits,
 			dev->iobase + COMMAND6_REG);
 	}
-	// send data
+	/*  send data */
 	lsb = data[0] & 0xff;
 	msb = (data[0] >> 8) & 0xff;
 	devpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(channel));
 	devpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(channel));
 
-	// remember value for readback
+	/*  remember value for readback */
 	devpriv->ao_value[channel] = data[0];
 
 	return 1;
 }
 
-// analog output readback insn
+/* analog output readback insn */
 static int labpc_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
@@ -1666,7 +1666,7 @@ static int labpc_eeprom_write_insn(struct comedi_device * dev, struct comedi_sub
 	int channel = CR_CHAN(insn->chanspec);
 	int ret;
 
-	// only allow writes to user area of eeprom
+	/*  only allow writes to user area of eeprom */
 	if (channel < 16 || channel > 127) {
 		printk("eeprom writes are only allowed to channels 16 through 127 (the pointer and user areas)");
 		return -EINVAL;
@@ -1679,7 +1679,7 @@ static int labpc_eeprom_write_insn(struct comedi_device * dev, struct comedi_sub
 	return 1;
 }
 
-// utility function that suggests a dma transfer size in bytes
+/* utility function that suggests a dma transfer size in bytes */
 static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd)
 {
 	unsigned int size;
@@ -1687,14 +1687,14 @@ static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd)
 
 	if (cmd.convert_src == TRIG_TIMER)
 		freq = 1000000000 / cmd.convert_arg;
-	// return some default value
+	/*  return some default value */
 	else
 		freq = 0xffffffff;
 
-	// make buffer fill in no more than 1/3 second
+	/*  make buffer fill in no more than 1/3 second */
 	size = (freq / 3) * sample_size;
 
-	// set a minimum and maximum size allowed
+	/*  set a minimum and maximum size allowed */
 	if (size > dma_buffer_size)
 		size = dma_buffer_size - dma_buffer_size % sample_size;
 	else if (size < sample_size)
@@ -1703,16 +1703,16 @@ static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd)
 	return size;
 }
 
-// figures out what counter values to use based on command
+/* figures out what counter values to use based on command */
 static void labpc_adc_timing(struct comedi_device * dev, struct comedi_cmd * cmd)
 {
-	const int max_counter_value = 0x10000;	// max value for 16 bit counter in mode 2
-	const int min_counter_value = 2;	// min value for 16 bit counter in mode 2
+	const int max_counter_value = 0x10000;	/*  max value for 16 bit counter in mode 2 */
+	const int min_counter_value = 2;	/*  min value for 16 bit counter in mode 2 */
 	unsigned int base_period;
 
-	// if both convert and scan triggers are TRIG_TIMER, then they both rely on counter b0
+	/*  if both convert and scan triggers are TRIG_TIMER, then they both rely on counter b0 */
 	if (labpc_ai_convert_period(cmd) && labpc_ai_scan_period(cmd)) {
-		// pick the lowest b0 divisor value we can (for maximum input clock speed on convert and scan counters)
+		/*  pick the lowest b0 divisor value we can (for maximum input clock speed on convert and scan counters) */
 		devpriv->divisor_b0 = (labpc_ai_scan_period(cmd) - 1) /
 			(LABPC_TIMER_BASE * max_counter_value) + 1;
 		if (devpriv->divisor_b0 < min_counter_value)
@@ -1722,7 +1722,7 @@ static void labpc_adc_timing(struct comedi_device * dev, struct comedi_cmd * cmd
 
 		base_period = LABPC_TIMER_BASE * devpriv->divisor_b0;
 
-		// set a0 for conversion frequency and b1 for scan frequency
+		/*  set a0 for conversion frequency and b1 for scan frequency */
 		switch (cmd->flags & TRIG_ROUND_MASK) {
 		default:
 		case TRIG_ROUND_NEAREST:
@@ -1748,7 +1748,7 @@ static void labpc_adc_timing(struct comedi_device * dev, struct comedi_cmd * cmd
 				labpc_ai_scan_period(cmd) / base_period;
 			break;
 		}
-		// make sure a0 and b1 values are acceptable
+		/*  make sure a0 and b1 values are acceptable */
 		if (devpriv->divisor_a0 < min_counter_value)
 			devpriv->divisor_a0 = min_counter_value;
 		if (devpriv->divisor_a0 > max_counter_value)
@@ -1757,12 +1757,12 @@ static void labpc_adc_timing(struct comedi_device * dev, struct comedi_cmd * cmd
 			devpriv->divisor_b1 = min_counter_value;
 		if (devpriv->divisor_b1 > max_counter_value)
 			devpriv->divisor_b1 = max_counter_value;
-		// write corrected timings to command
+		/*  write corrected timings to command */
 		labpc_set_ai_convert_period(cmd,
 			base_period * devpriv->divisor_a0);
 		labpc_set_ai_scan_period(cmd,
 			base_period * devpriv->divisor_b1);
-		// if only one TRIG_TIMER is used, we can employ the generic cascaded timing functions
+		/*  if only one TRIG_TIMER is used, we can employ the generic cascaded timing functions */
 	} else if (labpc_ai_scan_period(cmd)) {
 		unsigned int scan_period;
 
@@ -1795,16 +1795,16 @@ static int labpc_dio_mem_callback(int dir, int port, int data,
 	}
 }
 
-// lowlevel write to eeprom/dac
+/* lowlevel write to eeprom/dac */
 static void labpc_serial_out(struct comedi_device * dev, unsigned int value,
 	unsigned int value_width)
 {
 	int i;
 
 	for (i = 1; i <= value_width; i++) {
-		// clear serial clock
+		/*  clear serial clock */
 		devpriv->command5_bits &= ~SCLOCK_BIT;
-		// send bits most significant bit first
+		/*  send bits most significant bit first */
 		if (value & (1 << (value_width - i)))
 			devpriv->command5_bits |= SDATA_BIT;
 		else
@@ -1812,7 +1812,7 @@ static void labpc_serial_out(struct comedi_device * dev, unsigned int value,
 		comedi_udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
-		// set clock to load bit
+		/*  set clock to load bit */
 		devpriv->command5_bits |= SCLOCK_BIT;
 		comedi_udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
@@ -1820,25 +1820,25 @@ static void labpc_serial_out(struct comedi_device * dev, unsigned int value,
 	}
 }
 
-// lowlevel read from eeprom
+/* lowlevel read from eeprom */
 static unsigned int labpc_serial_in(struct comedi_device * dev)
 {
 	unsigned int value = 0;
 	int i;
-	const int value_width = 8;	// number of bits wide values are
+	const int value_width = 8;	/*  number of bits wide values are */
 
 	for (i = 1; i <= value_width; i++) {
-		// set serial clock
+		/*  set serial clock */
 		devpriv->command5_bits |= SCLOCK_BIT;
 		comedi_udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
-		// clear clock bit
+		/*  clear clock bit */
 		devpriv->command5_bits &= ~SCLOCK_BIT;
 		comedi_udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
-		// read bits most significant bit first
+		/*  read bits most significant bit first */
 		comedi_udelay(1);
 		devpriv->status2_bits =
 			devpriv->read_byte(dev->iobase + STATUS2_REG);
@@ -1853,10 +1853,10 @@ static unsigned int labpc_serial_in(struct comedi_device * dev)
 static unsigned int labpc_eeprom_read(struct comedi_device * dev, unsigned int address)
 {
 	unsigned int value;
-	const int read_instruction = 0x3;	// bits to tell eeprom to expect a read
-	const int write_length = 8;	// 8 bit write lengths to eeprom
+	const int read_instruction = 0x3;	/*  bits to tell eeprom to expect a read */
+	const int write_length = 8;	/*  8 bit write lengths to eeprom */
 
-	// enable read/write to eeprom
+	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
@@ -1864,14 +1864,14 @@ static unsigned int labpc_eeprom_read(struct comedi_device * dev, unsigned int a
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
-	// send read instruction
+	/*  send read instruction */
 	labpc_serial_out(dev, read_instruction, write_length);
-	// send 8 bit address to read from
+	/*  send 8 bit address to read from */
 	labpc_serial_out(dev, address, write_length);
-	// read result
+	/*  read result */
 	value = labpc_serial_in(dev);
 
-	// disable read/write to eeprom
+	/*  disable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
@@ -1884,12 +1884,12 @@ static unsigned int labpc_eeprom_write(struct comedi_device * dev,
 {
 	const int write_enable_instruction = 0x6;
 	const int write_instruction = 0x2;
-	const int write_length = 8;	// 8 bit write lengths to eeprom
+	const int write_length = 8;	/*  8 bit write lengths to eeprom */
 	const int write_in_progress_bit = 0x1;
 	const int timeout = 10000;
 	int i;
 
-	// make sure there isn't already a write in progress
+	/*  make sure there isn't already a write in progress */
 	for (i = 0; i < timeout; i++) {
 		if ((labpc_eeprom_read_status(dev) & write_in_progress_bit) ==
 			0)
@@ -1899,10 +1899,10 @@ static unsigned int labpc_eeprom_write(struct comedi_device * dev,
 		comedi_error(dev, "eeprom write timed out");
 		return -ETIME;
 	}
-	// update software copy of eeprom
+	/*  update software copy of eeprom */
 	devpriv->eeprom_data[address] = value;
 
-	// enable read/write to eeprom
+	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
@@ -1910,26 +1910,26 @@ static unsigned int labpc_eeprom_write(struct comedi_device * dev,
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
-	// send write_enable instruction
+	/*  send write_enable instruction */
 	labpc_serial_out(dev, write_enable_instruction, write_length);
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
-	// send write instruction
+	/*  send write instruction */
 	devpriv->command5_bits |= EEPROM_EN_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 	labpc_serial_out(dev, write_instruction, write_length);
-	// send 8 bit address to write to
+	/*  send 8 bit address to write to */
 	labpc_serial_out(dev, address, write_length);
-	// write value
+	/*  write value */
 	labpc_serial_out(dev, value, write_length);
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
-	// disable read/write to eeprom
+	/*  disable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
@@ -1941,9 +1941,9 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device * dev)
 {
 	unsigned int value;
 	const int read_status_instruction = 0x5;
-	const int write_length = 8;	// 8 bit write lengths to eeprom
+	const int write_length = 8;	/*  8 bit write lengths to eeprom */
 
-	// enable read/write to eeprom
+	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
@@ -1951,12 +1951,12 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device * dev)
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
-	// send read status instruction
+	/*  send read status instruction */
 	labpc_serial_out(dev, read_status_instruction, write_length);
-	// read result
+	/*  read result */
 	value = labpc_serial_in(dev);
 
-	// disable read/write to eeprom
+	/*  disable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
@@ -1964,7 +1964,7 @@ static unsigned int labpc_eeprom_read_status(struct comedi_device * dev)
 	return value;
 }
 
-// writes to 8 bit calibration dacs
+/* writes to 8 bit calibration dacs */
 static void write_caldac(struct comedi_device * dev, unsigned int channel,
 	unsigned int value)
 {
@@ -1972,18 +1972,18 @@ static void write_caldac(struct comedi_device * dev, unsigned int channel,
 		return;
 	devpriv->caldac[channel] = value;
 
-	// clear caldac load bit and make sure we don't write to eeprom
+	/*  clear caldac load bit and make sure we don't write to eeprom */
 	devpriv->command5_bits &=
 		~CALDAC_LOAD_BIT & ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
-	// write 4 bit channel
+	/*  write 4 bit channel */
 	labpc_serial_out(dev, channel, 4);
-	// write 8 bit caldac value
+	/*  write 8 bit caldac value */
 	labpc_serial_out(dev, value, 8);
 
-	// set and clear caldac bit to load caldac value
+	/*  set and clear caldac bit to load caldac value */
 	devpriv->command5_bits |= CALDAC_LOAD_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);

commit 0a4eb4b6c7c12730254be53d93a67ed2955d5c66
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Mar 25 11:07:01 2009 -0400

    Staging: comedi: Remove labpc_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index d7641cd920be..c0da5c75b4bb 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -427,7 +427,7 @@ static const struct labpc_board_struct labpc_boards[] = {
 static const int dma_buffer_size = 0xff00;	// size in bytes of dma buffer
 static const int sample_size = 2;	// 2 bytes per sample
 
-#define devpriv ((labpc_private *)dev->private)
+#define devpriv ((struct labpc_private *)dev->private)
 
 static struct comedi_driver driver_labpc = {
 	.driver_name = DRV_NAME,
@@ -653,7 +653,7 @@ static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it
 #endif
 
 	/* allocate and initialize dev->private */
-	if (alloc_private(dev, sizeof(labpc_private)) < 0)
+	if (alloc_private(dev, sizeof(struct labpc_private)) < 0)
 		return -ENOMEM;
 
 	// get base address, irq etc. based on bustype

commit 9ad007403fa4326586060e443ee344697daa60ec
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Mar 25 11:06:56 2009 -0400

    Staging: comedi: Remove labpc_board_struct typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 37898d8474cd..d7641cd920be 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -360,7 +360,7 @@ static inline void labpc_writeb(unsigned int byte, unsigned long address)
 	writeb(byte, (void *)address);
 }
 
-static const labpc_board labpc_boards[] = {
+static const struct labpc_board_struct labpc_boards[] = {
 	{
 	      name:	"lab-pc-1200",
 	      ai_speed:10000,
@@ -422,7 +422,7 @@ static const labpc_board labpc_boards[] = {
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((labpc_board *)dev->board_ptr)
+#define thisboard ((struct labpc_board_struct *)dev->board_ptr)
 
 static const int dma_buffer_size = 0xff00;	// size in bytes of dma buffer
 static const int sample_size = 2;	// 2 bytes per sample
@@ -434,9 +434,9 @@ static struct comedi_driver driver_labpc = {
 	.module = THIS_MODULE,
 	.attach = labpc_attach,
 	.detach = labpc_common_detach,
-	.num_names = sizeof(labpc_boards) / sizeof(labpc_board),
+	.num_names = sizeof(labpc_boards) / sizeof(struct labpc_board_struct),
 	.board_name = &labpc_boards[0].name,
-	.offset = sizeof(labpc_board),
+	.offset = sizeof(struct labpc_board_struct),
 };
 
 #ifdef CONFIG_COMEDI_PCI

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index f6ab0fde2c11..37898d8474cd 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -163,7 +163,7 @@ NI manuals:
 #define   INIT_A1_BITS	0x70	// put hardware conversion counter output in harmless state (a1 mode 0)
 #define COUNTER_B_BASE_REG	0x18
 
-static int labpc_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int labpc_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG);
 static int labpc_drain_fifo(struct comedi_device * dev);
@@ -643,7 +643,7 @@ int labpc_common_attach(struct comedi_device * dev, unsigned long iobase,
 	return 0;
 }
 
-static int labpc_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	unsigned long iobase = 0;
 	unsigned int irq = 0;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 2b3b4664bead..f6ab0fde2c11 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -174,19 +174,19 @@ static int labpc_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 	struct comedi_cmd * cmd);
 static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int labpc_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int labpc_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int labpc_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int labpc_calib_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int labpc_calib_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int labpc_eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int labpc_eeprom_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd);
 static void labpc_adc_timing(struct comedi_device * dev, struct comedi_cmd * cmd);
 #ifdef CONFIG_COMEDI_PCI
@@ -1501,7 +1501,7 @@ static void labpc_drain_dregs(struct comedi_device * dev)
 }
 
 static int labpc_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
 	int chan, range;
@@ -1587,7 +1587,7 @@ static int labpc_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 
 // analog output insn
 static int labpc_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int channel, range;
 	unsigned long flags;
@@ -1628,7 +1628,7 @@ static int labpc_ao_winsn(struct comedi_device * dev, struct comedi_subdevice *
 
 // analog output readback insn
 static int labpc_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
 
@@ -1636,7 +1636,7 @@ static int labpc_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 static int labpc_calib_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->caldac[CR_CHAN(insn->chanspec)];
 
@@ -1644,7 +1644,7 @@ static int labpc_calib_read_insn(struct comedi_device * dev, struct comedi_subde
 }
 
 static int labpc_calib_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -1653,7 +1653,7 @@ static int labpc_calib_write_insn(struct comedi_device * dev, struct comedi_subd
 }
 
 static int labpc_eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->eeprom_data[CR_CHAN(insn->chanspec)];
 
@@ -1661,7 +1661,7 @@ static int labpc_eeprom_read_insn(struct comedi_device * dev, struct comedi_subd
 }
 
 static int labpc_eeprom_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 	int ret;

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index f1a284e6358c..2b3b4664bead 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -171,7 +171,7 @@ static void labpc_drain_dma(struct comedi_device * dev);
 static void handle_isa_dma(struct comedi_device * dev);
 static void labpc_drain_dregs(struct comedi_device * dev);
 static int labpc_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int labpc_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
@@ -187,8 +187,8 @@ static int labpc_eeprom_read_insn(struct comedi_device * dev, struct comedi_subd
 	comedi_insn * insn, unsigned int * data);
 static int labpc_eeprom_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static unsigned int labpc_suggest_transfer_size(comedi_cmd cmd);
-static void labpc_adc_timing(struct comedi_device * dev, comedi_cmd * cmd);
+static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd);
+static void labpc_adc_timing(struct comedi_device * dev, struct comedi_cmd * cmd);
 #ifdef CONFIG_COMEDI_PCI
 static int labpc_find_device(struct comedi_device *dev, int bus, int slot);
 #endif
@@ -770,7 +770,7 @@ static int labpc_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-static enum scan_mode labpc_ai_scan_mode(const comedi_cmd * cmd)
+static enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd * cmd)
 {
 	if (cmd->chanlist_len == 1)
 		return MODE_SINGLE_CHAN;
@@ -794,7 +794,7 @@ static enum scan_mode labpc_ai_scan_mode(const comedi_cmd * cmd)
 }
 
 static int labpc_ai_chanlist_invalid(const struct comedi_device * dev,
-	const comedi_cmd * cmd)
+	const struct comedi_cmd * cmd)
 {
 	int mode, channel, range, aref, i;
 
@@ -865,7 +865,7 @@ static int labpc_ai_chanlist_invalid(const struct comedi_device * dev,
 	return 0;
 }
 
-static int labpc_use_continuous_mode(const comedi_cmd * cmd)
+static int labpc_use_continuous_mode(const struct comedi_cmd * cmd)
 {
 	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN)
 		return 1;
@@ -876,7 +876,7 @@ static int labpc_use_continuous_mode(const comedi_cmd * cmd)
 	return 0;
 }
 
-static unsigned int labpc_ai_convert_period(const comedi_cmd * cmd)
+static unsigned int labpc_ai_convert_period(const struct comedi_cmd * cmd)
 {
 	if (cmd->convert_src != TRIG_TIMER)
 		return 0;
@@ -888,7 +888,7 @@ static unsigned int labpc_ai_convert_period(const comedi_cmd * cmd)
 	return cmd->convert_arg;
 }
 
-static void labpc_set_ai_convert_period(comedi_cmd * cmd, unsigned int ns)
+static void labpc_set_ai_convert_period(struct comedi_cmd * cmd, unsigned int ns)
 {
 	if (cmd->convert_src != TRIG_TIMER)
 		return;
@@ -902,7 +902,7 @@ static void labpc_set_ai_convert_period(comedi_cmd * cmd, unsigned int ns)
 		cmd->convert_arg = ns;
 }
 
-static unsigned int labpc_ai_scan_period(const comedi_cmd * cmd)
+static unsigned int labpc_ai_scan_period(const struct comedi_cmd * cmd)
 {
 	if (cmd->scan_begin_src != TRIG_TIMER)
 		return 0;
@@ -914,7 +914,7 @@ static unsigned int labpc_ai_scan_period(const comedi_cmd * cmd)
 	return cmd->scan_begin_arg;
 }
 
-static void labpc_set_ai_scan_period(comedi_cmd * cmd, unsigned int ns)
+static void labpc_set_ai_scan_period(struct comedi_cmd * cmd, unsigned int ns)
 {
 	if (cmd->scan_begin_src != TRIG_TIMER)
 		return;
@@ -927,7 +927,7 @@ static void labpc_set_ai_scan_period(comedi_cmd * cmd, unsigned int ns)
 }
 
 static int labpc_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp, tmp2;
@@ -1069,7 +1069,7 @@ static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	unsigned long irq_flags;
 	int ret;
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	enum transfer_type xfer;
 	unsigned long flags;
 
@@ -1314,7 +1314,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG)
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
-	comedi_cmd *cmd;
+	struct comedi_cmd *cmd;
 
 	if (dev->attached == 0) {
 		comedi_error(dev, "premature interrupt");
@@ -1680,7 +1680,7 @@ static int labpc_eeprom_write_insn(struct comedi_device * dev, struct comedi_sub
 }
 
 // utility function that suggests a dma transfer size in bytes
-static unsigned int labpc_suggest_transfer_size(comedi_cmd cmd)
+static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd)
 {
 	unsigned int size;
 	unsigned int freq;
@@ -1704,7 +1704,7 @@ static unsigned int labpc_suggest_transfer_size(comedi_cmd cmd)
 }
 
 // figures out what counter values to use based on command
-static void labpc_adc_timing(struct comedi_device * dev, comedi_cmd * cmd)
+static void labpc_adc_timing(struct comedi_device * dev, struct comedi_cmd * cmd)
 {
 	const int max_counter_value = 0x10000;	// max value for 16 bit counter in mode 2
 	const int min_counter_value = 2;	// min value for 16 bit counter in mode 2

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index e1326a35e78c..f1a284e6358c 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -253,7 +253,7 @@ static const int labpc_plus_ai_gain_bits[NUM_LABPC_PLUS_AI_RANGES] = {
 	0x60,
 	0x70,
 };
-static const comedi_lrange range_labpc_plus_ai = {
+static const struct comedi_lrange range_labpc_plus_ai = {
 	NUM_LABPC_PLUS_AI_RANGES,
 	{
 			BIP_RANGE(5),
@@ -311,7 +311,7 @@ const int labpc_1200_ai_gain_bits[NUM_LABPC_1200_AI_RANGES] = {
 	0x60,
 	0x70,
 };
-const comedi_lrange range_labpc_1200_ai = {
+const struct comedi_lrange range_labpc_1200_ai = {
 	NUM_LABPC_1200_AI_RANGES,
 	{
 			BIP_RANGE(5),
@@ -333,7 +333,7 @@ const comedi_lrange range_labpc_1200_ai = {
 
 //analog output ranges
 #define AO_RANGE_IS_UNIPOLAR 0x1
-static const comedi_lrange range_labpc_ao = {
+static const struct comedi_lrange range_labpc_ao = {
 	2,
 	{
 			BIP_RANGE(5),

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 6ba97da42def..e1326a35e78c 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -429,7 +429,7 @@ static const int sample_size = 2;	// 2 bytes per sample
 
 #define devpriv ((labpc_private *)dev->private)
 
-static comedi_driver driver_labpc = {
+static struct comedi_driver driver_labpc = {
 	.driver_name = DRV_NAME,
 	.module = THIS_MODULE,
 	.attach = labpc_attach,

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index be528f6c3ab0..6ba97da42def 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -1068,7 +1068,7 @@ static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	int channel, range, aref;
 	unsigned long irq_flags;
 	int ret;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	enum transfer_type xfer;
 	unsigned long flags;
@@ -1313,7 +1313,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->read_subdev;
-	comedi_async *async;
+	struct comedi_async *async;
 	comedi_cmd *cmd;
 
 	if (dev->attached == 0) {
@@ -1397,7 +1397,7 @@ static int labpc_drain_fifo(struct comedi_device * dev)
 {
 	unsigned int lsb, msb;
 	short data;
-	comedi_async *async = dev->read_subdev->async;
+	struct comedi_async *async = dev->read_subdev->async;
 	const int timeout = 10000;
 	unsigned int i;
 
@@ -1430,7 +1430,7 @@ static int labpc_drain_fifo(struct comedi_device * dev)
 static void labpc_drain_dma(struct comedi_device * dev)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	int status;
 	unsigned long flags;
 	unsigned int max_points, num_points, residue, leftover;

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 53a7783793e3..be528f6c3ab0 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -164,28 +164,28 @@ NI manuals:
 #define COUNTER_B_BASE_REG	0x18
 
 static int labpc_attach(struct comedi_device * dev, comedi_devconfig * it);
-static int labpc_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int labpc_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG);
 static int labpc_drain_fifo(struct comedi_device * dev);
 static void labpc_drain_dma(struct comedi_device * dev);
 static void handle_isa_dma(struct comedi_device * dev);
 static void labpc_drain_dregs(struct comedi_device * dev);
-static int labpc_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int labpc_ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int labpc_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int labpc_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int labpc_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int labpc_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int labpc_calib_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_calib_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int labpc_calib_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_calib_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int labpc_eeprom_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int labpc_eeprom_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_eeprom_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static unsigned int labpc_suggest_transfer_size(comedi_cmd cmd);
 static void labpc_adc_timing(struct comedi_device * dev, comedi_cmd * cmd);
@@ -462,7 +462,7 @@ static inline int labpc_counter_load(struct comedi_device * dev,
 int labpc_common_attach(struct comedi_device * dev, unsigned long iobase,
 	unsigned int irq, unsigned int dma_chan)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	int i;
 	unsigned long dma_flags, isr_flags;
 	short lsb, msb;
@@ -755,7 +755,7 @@ static void labpc_clear_adc_fifo(const struct comedi_device * dev)
 	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
 }
 
-static int labpc_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int labpc_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -926,7 +926,7 @@ static void labpc_set_ai_scan_period(comedi_cmd * cmd, unsigned int ns)
 	cmd->scan_begin_arg = ns;
 }
 
-static int labpc_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1063,7 +1063,7 @@ static int labpc_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int labpc_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int labpc_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int channel, range, aref;
 	unsigned long irq_flags;
@@ -1312,7 +1312,7 @@ static int labpc_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	struct comedi_device *dev = d;
-	comedi_subdevice *s = dev->read_subdev;
+	struct comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async;
 	comedi_cmd *cmd;
 
@@ -1429,7 +1429,7 @@ static int labpc_drain_fifo(struct comedi_device * dev)
 
 static void labpc_drain_dma(struct comedi_device * dev)
 {
-	comedi_subdevice *s = dev->read_subdev;
+	struct comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async = s->async;
 	int status;
 	unsigned long flags;
@@ -1500,7 +1500,7 @@ static void labpc_drain_dregs(struct comedi_device * dev)
 	labpc_drain_fifo(dev);
 }
 
-static int labpc_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
@@ -1586,7 +1586,7 @@ static int labpc_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 }
 
 // analog output insn
-static int labpc_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel, range;
@@ -1627,7 +1627,7 @@ static int labpc_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 }
 
 // analog output readback insn
-static int labpc_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
@@ -1635,7 +1635,7 @@ static int labpc_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int labpc_calib_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_calib_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->caldac[CR_CHAN(insn->chanspec)];
@@ -1643,7 +1643,7 @@ static int labpc_calib_read_insn(struct comedi_device * dev, comedi_subdevice *
 	return 1;
 }
 
-static int labpc_calib_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_calib_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
@@ -1652,7 +1652,7 @@ static int labpc_calib_write_insn(struct comedi_device * dev, comedi_subdevice *
 	return 1;
 }
 
-static int labpc_eeprom_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->eeprom_data[CR_CHAN(insn->chanspec)];
@@ -1660,7 +1660,7 @@ static int labpc_eeprom_read_insn(struct comedi_device * dev, comedi_subdevice *
 	return 1;
 }
 
-static int labpc_eeprom_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int labpc_eeprom_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index a7688f1670aa..53a7783793e3 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -163,46 +163,46 @@ NI manuals:
 #define   INIT_A1_BITS	0x70	// put hardware conversion counter output in harmless state (a1 mode 0)
 #define COUNTER_B_BASE_REG	0x18
 
-static int labpc_attach(comedi_device * dev, comedi_devconfig * it);
-static int labpc_cancel(comedi_device * dev, comedi_subdevice * s);
+static int labpc_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int labpc_cancel(struct comedi_device * dev, comedi_subdevice * s);
 static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG);
-static int labpc_drain_fifo(comedi_device * dev);
-static void labpc_drain_dma(comedi_device * dev);
-static void handle_isa_dma(comedi_device * dev);
-static void labpc_drain_dregs(comedi_device * dev);
-static int labpc_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int labpc_drain_fifo(struct comedi_device * dev);
+static void labpc_drain_dma(struct comedi_device * dev);
+static void handle_isa_dma(struct comedi_device * dev);
+static void labpc_drain_dregs(struct comedi_device * dev);
+static int labpc_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int labpc_ai_cmd(comedi_device * dev, comedi_subdevice * s);
-static int labpc_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int labpc_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int labpc_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int labpc_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int labpc_calib_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_calib_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int labpc_calib_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_calib_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int labpc_eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_eeprom_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int labpc_eeprom_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_eeprom_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static unsigned int labpc_suggest_transfer_size(comedi_cmd cmd);
-static void labpc_adc_timing(comedi_device * dev, comedi_cmd * cmd);
+static void labpc_adc_timing(struct comedi_device * dev, comedi_cmd * cmd);
 #ifdef CONFIG_COMEDI_PCI
-static int labpc_find_device(comedi_device *dev, int bus, int slot);
+static int labpc_find_device(struct comedi_device *dev, int bus, int slot);
 #endif
 static int labpc_dio_mem_callback(int dir, int port, int data,
 	unsigned long arg);
-static void labpc_serial_out(comedi_device * dev, unsigned int value,
+static void labpc_serial_out(struct comedi_device * dev, unsigned int value,
 	unsigned int num_bits);
-static unsigned int labpc_serial_in(comedi_device * dev);
-static unsigned int labpc_eeprom_read(comedi_device * dev,
+static unsigned int labpc_serial_in(struct comedi_device * dev);
+static unsigned int labpc_eeprom_read(struct comedi_device * dev,
 	unsigned int address);
-static unsigned int labpc_eeprom_read_status(comedi_device * dev);
-static unsigned int labpc_eeprom_write(comedi_device * dev,
+static unsigned int labpc_eeprom_read_status(struct comedi_device * dev);
+static unsigned int labpc_eeprom_write(struct comedi_device * dev,
 	unsigned int address, unsigned int value);
-static void write_caldac(comedi_device * dev, unsigned int channel,
+static void write_caldac(struct comedi_device * dev, unsigned int channel,
 	unsigned int value);
 
 enum scan_mode {
@@ -448,7 +448,7 @@ static DEFINE_PCI_DEVICE_TABLE(labpc_pci_table) = {
 MODULE_DEVICE_TABLE(pci, labpc_pci_table);
 #endif /* CONFIG_COMEDI_PCI */
 
-static inline int labpc_counter_load(comedi_device * dev,
+static inline int labpc_counter_load(struct comedi_device * dev,
 	unsigned long base_address, unsigned int counter_number,
 	unsigned int count, unsigned int mode)
 {
@@ -459,7 +459,7 @@ static inline int labpc_counter_load(comedi_device * dev,
 		return i8254_load(base_address, 0, counter_number, count, mode);
 }
 
-int labpc_common_attach(comedi_device * dev, unsigned long iobase,
+int labpc_common_attach(struct comedi_device * dev, unsigned long iobase,
 	unsigned int irq, unsigned int dma_chan)
 {
 	comedi_subdevice *s;
@@ -643,7 +643,7 @@ int labpc_common_attach(comedi_device * dev, unsigned long iobase,
 	return 0;
 }
 
-static int labpc_attach(comedi_device * dev, comedi_devconfig * it)
+static int labpc_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	unsigned long iobase = 0;
 	unsigned int irq = 0;
@@ -694,7 +694,7 @@ static int labpc_attach(comedi_device * dev, comedi_devconfig * it)
 
 // adapted from ni_pcimio for finding mite based boards (pc-1200)
 #ifdef CONFIG_COMEDI_PCI
-static int labpc_find_device(comedi_device *dev, int bus, int slot)
+static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 {
 	struct mite_struct *mite;
 	int i;
@@ -724,7 +724,7 @@ static int labpc_find_device(comedi_device *dev, int bus, int slot)
 }
 #endif
 
-int labpc_common_detach(comedi_device * dev)
+int labpc_common_detach(struct comedi_device * dev)
 {
 	printk("comedi%d: ni_labpc: detach\n", dev->minor);
 
@@ -748,14 +748,14 @@ int labpc_common_detach(comedi_device * dev)
 	return 0;
 };
 
-static void labpc_clear_adc_fifo(const comedi_device * dev)
+static void labpc_clear_adc_fifo(const struct comedi_device * dev)
 {
 	devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
 	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
 	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
 }
 
-static int labpc_cancel(comedi_device * dev, comedi_subdevice * s)
+static int labpc_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -793,7 +793,7 @@ static enum scan_mode labpc_ai_scan_mode(const comedi_cmd * cmd)
 	return 0;
 }
 
-static int labpc_ai_chanlist_invalid(const comedi_device * dev,
+static int labpc_ai_chanlist_invalid(const struct comedi_device * dev,
 	const comedi_cmd * cmd)
 {
 	int mode, channel, range, aref, i;
@@ -926,7 +926,7 @@ static void labpc_set_ai_scan_period(comedi_cmd * cmd, unsigned int ns)
 	cmd->scan_begin_arg = ns;
 }
 
-static int labpc_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int labpc_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1063,7 +1063,7 @@ static int labpc_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int labpc_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int labpc_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	int channel, range, aref;
 	unsigned long irq_flags;
@@ -1311,7 +1311,7 @@ static int labpc_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 /* interrupt service routine */
 static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async;
 	comedi_cmd *cmd;
@@ -1393,7 +1393,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG)
 }
 
 // read all available samples from ai fifo
-static int labpc_drain_fifo(comedi_device * dev)
+static int labpc_drain_fifo(struct comedi_device * dev)
 {
 	unsigned int lsb, msb;
 	short data;
@@ -1427,7 +1427,7 @@ static int labpc_drain_fifo(comedi_device * dev)
 	return 0;
 }
 
-static void labpc_drain_dma(comedi_device * dev)
+static void labpc_drain_dma(struct comedi_device * dev)
 {
 	comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async = s->async;
@@ -1480,7 +1480,7 @@ static void labpc_drain_dma(comedi_device * dev)
 	async->events |= COMEDI_CB_BLOCK;
 }
 
-static void handle_isa_dma(comedi_device * dev)
+static void handle_isa_dma(struct comedi_device * dev)
 {
 	labpc_drain_dma(dev);
 
@@ -1492,7 +1492,7 @@ static void handle_isa_dma(comedi_device * dev)
 
 /* makes sure all data aquired by board is transfered to comedi (used
  * when aquisition is terminated by stop_src == TRIG_EXT). */
-static void labpc_drain_dregs(comedi_device * dev)
+static void labpc_drain_dregs(struct comedi_device * dev)
 {
 	if (devpriv->current_transfer == isa_dma_transfer)
 		labpc_drain_dma(dev);
@@ -1500,7 +1500,7 @@ static void labpc_drain_dregs(comedi_device * dev)
 	labpc_drain_fifo(dev);
 }
 
-static int labpc_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
@@ -1586,7 +1586,7 @@ static int labpc_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 }
 
 // analog output insn
-static int labpc_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel, range;
@@ -1627,7 +1627,7 @@ static int labpc_ao_winsn(comedi_device * dev, comedi_subdevice * s,
 }
 
 // analog output readback insn
-static int labpc_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
@@ -1635,7 +1635,7 @@ static int labpc_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int labpc_calib_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_calib_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->caldac[CR_CHAN(insn->chanspec)];
@@ -1643,7 +1643,7 @@ static int labpc_calib_read_insn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int labpc_calib_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_calib_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
@@ -1652,7 +1652,7 @@ static int labpc_calib_write_insn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int labpc_eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_eeprom_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->eeprom_data[CR_CHAN(insn->chanspec)];
@@ -1660,7 +1660,7 @@ static int labpc_eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int labpc_eeprom_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int labpc_eeprom_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
@@ -1704,7 +1704,7 @@ static unsigned int labpc_suggest_transfer_size(comedi_cmd cmd)
 }
 
 // figures out what counter values to use based on command
-static void labpc_adc_timing(comedi_device * dev, comedi_cmd * cmd)
+static void labpc_adc_timing(struct comedi_device * dev, comedi_cmd * cmd)
 {
 	const int max_counter_value = 0x10000;	// max value for 16 bit counter in mode 2
 	const int min_counter_value = 2;	// min value for 16 bit counter in mode 2
@@ -1796,7 +1796,7 @@ static int labpc_dio_mem_callback(int dir, int port, int data,
 }
 
 // lowlevel write to eeprom/dac
-static void labpc_serial_out(comedi_device * dev, unsigned int value,
+static void labpc_serial_out(struct comedi_device * dev, unsigned int value,
 	unsigned int value_width)
 {
 	int i;
@@ -1821,7 +1821,7 @@ static void labpc_serial_out(comedi_device * dev, unsigned int value,
 }
 
 // lowlevel read from eeprom
-static unsigned int labpc_serial_in(comedi_device * dev)
+static unsigned int labpc_serial_in(struct comedi_device * dev)
 {
 	unsigned int value = 0;
 	int i;
@@ -1850,7 +1850,7 @@ static unsigned int labpc_serial_in(comedi_device * dev)
 	return value;
 }
 
-static unsigned int labpc_eeprom_read(comedi_device * dev, unsigned int address)
+static unsigned int labpc_eeprom_read(struct comedi_device * dev, unsigned int address)
 {
 	unsigned int value;
 	const int read_instruction = 0x3;	// bits to tell eeprom to expect a read
@@ -1879,7 +1879,7 @@ static unsigned int labpc_eeprom_read(comedi_device * dev, unsigned int address)
 	return value;
 }
 
-static unsigned int labpc_eeprom_write(comedi_device * dev,
+static unsigned int labpc_eeprom_write(struct comedi_device * dev,
 	unsigned int address, unsigned int value)
 {
 	const int write_enable_instruction = 0x6;
@@ -1937,7 +1937,7 @@ static unsigned int labpc_eeprom_write(comedi_device * dev,
 	return 0;
 }
 
-static unsigned int labpc_eeprom_read_status(comedi_device * dev)
+static unsigned int labpc_eeprom_read_status(struct comedi_device * dev)
 {
 	unsigned int value;
 	const int read_status_instruction = 0x5;
@@ -1965,7 +1965,7 @@ static unsigned int labpc_eeprom_read_status(comedi_device * dev)
 }
 
 // writes to 8 bit calibration dacs
-static void write_caldac(comedi_device * dev, unsigned int channel,
+static void write_caldac(struct comedi_device * dev, unsigned int channel,
 	unsigned int value)
 {
 	if (value == devpriv->caldac[channel])

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 9ea1953bae8f..a7688f1670aa 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -174,19 +174,19 @@ static int labpc_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
 static int labpc_ai_cmd(comedi_device * dev, comedi_subdevice * s);
 static int labpc_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int labpc_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int labpc_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int labpc_calib_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int labpc_calib_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int labpc_eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int labpc_eeprom_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static unsigned int labpc_suggest_transfer_size(comedi_cmd cmd);
 static void labpc_adc_timing(comedi_device * dev, comedi_cmd * cmd);
 #ifdef CONFIG_COMEDI_PCI
@@ -1396,7 +1396,7 @@ static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG)
 static int labpc_drain_fifo(comedi_device * dev)
 {
 	unsigned int lsb, msb;
-	sampl_t data;
+	short data;
 	comedi_async *async = dev->read_subdev->async;
 	const int timeout = 10000;
 	unsigned int i;
@@ -1501,7 +1501,7 @@ static void labpc_drain_dregs(comedi_device * dev)
 }
 
 static int labpc_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
 	int chan, range;
@@ -1587,7 +1587,7 @@ static int labpc_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 
 // analog output insn
 static int labpc_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int channel, range;
 	unsigned long flags;
@@ -1628,7 +1628,7 @@ static int labpc_ao_winsn(comedi_device * dev, comedi_subdevice * s,
 
 // analog output readback insn
 static int labpc_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
 
@@ -1636,7 +1636,7 @@ static int labpc_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int labpc_calib_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->caldac[CR_CHAN(insn->chanspec)];
 
@@ -1644,7 +1644,7 @@ static int labpc_calib_read_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int labpc_calib_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -1653,7 +1653,7 @@ static int labpc_calib_write_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int labpc_eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->eeprom_data[CR_CHAN(insn->chanspec)];
 
@@ -1661,7 +1661,7 @@ static int labpc_eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int labpc_eeprom_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 	int ret;

commit 124b13b26df5dab0236520de95e1cc1dea06e3c3
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Thu Feb 12 15:49:25 2009 -0800

    Staging: comedi: add ni_labpc drivers
    
    This supports National Instruments Lab-PC and compatibles
    
    From: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
new file mode 100644
index 000000000000..9ea1953bae8f
--- /dev/null
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -0,0 +1,2005 @@
+/*
+    comedi/drivers/ni_labpc.c
+    Driver for National Instruments Lab-PC series boards and compatibles
+    Copyright (C) 2001, 2002, 2003 Frank Mori Hess <fmhess@users.sourceforge.net>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+************************************************************************
+*/
+/*
+Driver: ni_labpc
+Description: National Instruments Lab-PC (& compatibles)
+Author: Frank Mori Hess <fmhess@users.sourceforge.net>
+Devices: [National Instruments] Lab-PC-1200 (labpc-1200),
+  Lab-PC-1200AI (labpc-1200ai), Lab-PC+ (lab-pc+), PCI-1200 (ni_labpc)
+Status: works
+
+Tested with lab-pc-1200.  For the older Lab-PC+, not all input ranges
+and analog references will work, the available ranges/arefs will
+depend on how you have configured the jumpers on your board
+(see your owner's manual).
+
+Kernel-level ISA plug-and-play support for the lab-pc-1200
+boards has not
+yet been added to the driver, mainly due to the fact that
+I don't know the device id numbers.  If you have one
+of these boards,
+please file a bug report at https://bugs.comedi.org/
+so I can get the necessary information from you.
+
+The 1200 series boards have onboard calibration dacs for correcting
+analog input/output offsets and gains.  The proper settings for these
+caldacs are stored on the board's eeprom.  To read the caldac values
+from the eeprom and store them into a file that can be then be used by
+comedilib, use the comedi_calibrate program.
+
+Configuration options - ISA boards:
+  [0] - I/O port base address
+  [1] - IRQ (optional, required for timed or externally triggered conversions)
+  [2] - DMA channel (optional)
+
+Configuration options - PCI boards:
+  [0] - bus (optional)
+  [1] - slot (optional)
+
+The Lab-pc+ has quirky chanlist requirements
+when scanning multiple channels.  Multiple channel scan
+sequence must start at highest channel, then decrement down to
+channel 0.  The rest of the cards can scan down like lab-pc+ or scan
+up from channel zero.  Chanlists consisting of all one channel
+are also legal, and allow you to pace conversions in bursts.
+
+*/
+
+/*
+
+NI manuals:
+341309a (labpc-1200 register manual)
+340914a (pci-1200)
+320502b (lab-pc+)
+
+*/
+
+#undef LABPC_DEBUG
+//#define LABPC_DEBUG   // enable debugging messages
+
+#include "../comedidev.h"
+
+#include <linux/delay.h>
+#include <asm/dma.h>
+
+#include "8253.h"
+#include "8255.h"
+#include "mite.h"
+#include "comedi_fc.h"
+#include "ni_labpc.h"
+
+#define DRV_NAME "ni_labpc"
+
+#define LABPC_SIZE           32	// size of io region used by board
+#define LABPC_TIMER_BASE            500	// 2 MHz master clock
+
+/* Registers for the lab-pc+ */
+
+//write-only registers
+#define COMMAND1_REG	0x0
+#define   ADC_GAIN_MASK	(0x7 << 4)
+#define   ADC_CHAN_BITS(x)	((x) & 0x7)
+#define   ADC_SCAN_EN_BIT	0x80	// enables multi channel scans
+#define COMMAND2_REG	0x1
+#define   PRETRIG_BIT	0x1	// enable pretriggering (used in conjunction with SWTRIG)
+#define   HWTRIG_BIT	0x2	// enable paced conversions on external trigger
+#define   SWTRIG_BIT	0x4	// enable paced conversions
+#define   CASCADE_BIT	0x8	// use two cascaded counters for pacing
+#define   DAC_PACED_BIT(channel)	(0x40 << ((channel) & 0x1))
+#define COMMAND3_REG	0x2
+#define   DMA_EN_BIT	0x1	// enable dma transfers
+#define   DIO_INTR_EN_BIT	0x2	// enable interrupts for 8255
+#define   DMATC_INTR_EN_BIT	0x4	// enable dma terminal count interrupt
+#define   TIMER_INTR_EN_BIT	0x8	// enable timer interrupt
+#define   ERR_INTR_EN_BIT	0x10	// enable error interrupt
+#define   ADC_FNE_INTR_EN_BIT	0x20	// enable fifo not empty interrupt
+#define ADC_CONVERT_REG	0x3
+#define DAC_LSB_REG(channel)	(0x4 + 2 * ((channel) & 0x1))
+#define DAC_MSB_REG(channel)	(0x5 + 2 * ((channel) & 0x1))
+#define ADC_CLEAR_REG	0x8
+#define DMATC_CLEAR_REG	0xa
+#define TIMER_CLEAR_REG	0xc
+#define COMMAND6_REG	0xe	// 1200 boards only
+#define   ADC_COMMON_BIT	0x1	// select ground or common-mode reference
+#define   ADC_UNIP_BIT	0x2	// adc unipolar
+#define   DAC_UNIP_BIT(channel)	(0x4 << ((channel) & 0x1))	// dac unipolar
+#define   ADC_FHF_INTR_EN_BIT	0x20	// enable fifo half full interrupt
+#define   A1_INTR_EN_BIT	0x40	// enable interrupt on end of hardware count
+#define   ADC_SCAN_UP_BIT 0x80	// scan up from channel zero instead of down to zero
+#define COMMAND4_REG	0xf
+#define   INTERVAL_SCAN_EN_BIT	0x1	// enables 'interval' scanning
+#define   EXT_SCAN_EN_BIT	0x2	// enables external signal on counter b1 output to trigger scan
+#define   EXT_CONVERT_OUT_BIT	0x4	// chooses direction (output or input) for EXTCONV* line
+#define   ADC_DIFF_BIT	0x8	// chooses differential inputs for adc (in conjunction with board jumper)
+#define   EXT_CONVERT_DISABLE_BIT	0x10
+#define COMMAND5_REG	0x1c	// 1200 boards only, calibration stuff
+#define   EEPROM_WRITE_UNPROTECT_BIT	0x4	// enable eeprom for write
+#define   DITHER_EN_BIT	0x8	// enable dithering
+#define   CALDAC_LOAD_BIT	0x10	// load calibration dac
+#define   SCLOCK_BIT	0x20	// serial clock - rising edge writes, falling edge reads
+#define   SDATA_BIT	0x40	// serial data bit for writing to eeprom or calibration dacs
+#define   EEPROM_EN_BIT	0x80	// enable eeprom for read/write
+#define INTERVAL_COUNT_REG	0x1e
+#define INTERVAL_LOAD_REG	0x1f
+#define   INTERVAL_LOAD_BITS	0x1
+
+// read-only registers
+#define STATUS1_REG	0x0
+#define   DATA_AVAIL_BIT	0x1	// data is available in fifo
+#define   OVERRUN_BIT	0x2	// overrun has occurred
+#define   OVERFLOW_BIT	0x4	// fifo overflow
+#define   TIMER_BIT	0x8	// timer interrupt has occured
+#define   DMATC_BIT	0x10	// dma terminal count has occured
+#define   EXT_TRIG_BIT	0x40	// external trigger has occured
+#define STATUS2_REG	0x1d	// 1200 boards only
+#define   EEPROM_OUT_BIT	0x1	// programmable eeprom serial output
+#define   A1_TC_BIT	0x2	// counter A1 terminal count
+#define   FNHF_BIT	0x4	// fifo not half full
+#define ADC_FIFO_REG	0xa
+
+#define DIO_BASE_REG	0x10
+#define COUNTER_A_BASE_REG	0x14
+#define COUNTER_A_CONTROL_REG	(COUNTER_A_BASE_REG + 0x3)
+#define   INIT_A0_BITS	0x14	// check modes put conversion pacer output in harmless state (a0 mode 2)
+#define   INIT_A1_BITS	0x70	// put hardware conversion counter output in harmless state (a1 mode 0)
+#define COUNTER_B_BASE_REG	0x18
+
+static int labpc_attach(comedi_device * dev, comedi_devconfig * it);
+static int labpc_cancel(comedi_device * dev, comedi_subdevice * s);
+static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG);
+static int labpc_drain_fifo(comedi_device * dev);
+static void labpc_drain_dma(comedi_device * dev);
+static void handle_isa_dma(comedi_device * dev);
+static void labpc_drain_dregs(comedi_device * dev);
+static int labpc_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int labpc_ai_cmd(comedi_device * dev, comedi_subdevice * s);
+static int labpc_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int labpc_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int labpc_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int labpc_calib_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int labpc_calib_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int labpc_eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int labpc_eeprom_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static unsigned int labpc_suggest_transfer_size(comedi_cmd cmd);
+static void labpc_adc_timing(comedi_device * dev, comedi_cmd * cmd);
+#ifdef CONFIG_COMEDI_PCI
+static int labpc_find_device(comedi_device *dev, int bus, int slot);
+#endif
+static int labpc_dio_mem_callback(int dir, int port, int data,
+	unsigned long arg);
+static void labpc_serial_out(comedi_device * dev, unsigned int value,
+	unsigned int num_bits);
+static unsigned int labpc_serial_in(comedi_device * dev);
+static unsigned int labpc_eeprom_read(comedi_device * dev,
+	unsigned int address);
+static unsigned int labpc_eeprom_read_status(comedi_device * dev);
+static unsigned int labpc_eeprom_write(comedi_device * dev,
+	unsigned int address, unsigned int value);
+static void write_caldac(comedi_device * dev, unsigned int channel,
+	unsigned int value);
+
+enum scan_mode {
+	MODE_SINGLE_CHAN,
+	MODE_SINGLE_CHAN_INTERVAL,
+	MODE_MULT_CHAN_UP,
+	MODE_MULT_CHAN_DOWN,
+};
+
+//analog input ranges
+#define NUM_LABPC_PLUS_AI_RANGES 16
+// indicates unipolar ranges
+static const int labpc_plus_is_unipolar[NUM_LABPC_PLUS_AI_RANGES] = {
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	1,
+	1,
+	1,
+	1,
+	1,
+	1,
+	1,
+	1,
+};
+
+// map range index to gain bits
+static const int labpc_plus_ai_gain_bits[NUM_LABPC_PLUS_AI_RANGES] = {
+	0x00,
+	0x10,
+	0x20,
+	0x30,
+	0x40,
+	0x50,
+	0x60,
+	0x70,
+	0x00,
+	0x10,
+	0x20,
+	0x30,
+	0x40,
+	0x50,
+	0x60,
+	0x70,
+};
+static const comedi_lrange range_labpc_plus_ai = {
+	NUM_LABPC_PLUS_AI_RANGES,
+	{
+			BIP_RANGE(5),
+			BIP_RANGE(4),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1),
+			BIP_RANGE(0.5),
+			BIP_RANGE(0.25),
+			BIP_RANGE(0.1),
+			BIP_RANGE(0.05),
+			UNI_RANGE(10),
+			UNI_RANGE(8),
+			UNI_RANGE(5),
+			UNI_RANGE(2),
+			UNI_RANGE(1),
+			UNI_RANGE(0.5),
+			UNI_RANGE(0.2),
+			UNI_RANGE(0.1),
+		}
+};
+
+#define NUM_LABPC_1200_AI_RANGES 14
+// indicates unipolar ranges
+const int labpc_1200_is_unipolar[NUM_LABPC_1200_AI_RANGES] = {
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	1,
+	1,
+	1,
+	1,
+	1,
+	1,
+	1,
+};
+
+// map range index to gain bits
+const int labpc_1200_ai_gain_bits[NUM_LABPC_1200_AI_RANGES] = {
+	0x00,
+	0x20,
+	0x30,
+	0x40,
+	0x50,
+	0x60,
+	0x70,
+	0x00,
+	0x20,
+	0x30,
+	0x40,
+	0x50,
+	0x60,
+	0x70,
+};
+const comedi_lrange range_labpc_1200_ai = {
+	NUM_LABPC_1200_AI_RANGES,
+	{
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1),
+			BIP_RANGE(0.5),
+			BIP_RANGE(0.25),
+			BIP_RANGE(0.1),
+			BIP_RANGE(0.05),
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2),
+			UNI_RANGE(1),
+			UNI_RANGE(0.5),
+			UNI_RANGE(0.2),
+			UNI_RANGE(0.1),
+		}
+};
+
+//analog output ranges
+#define AO_RANGE_IS_UNIPOLAR 0x1
+static const comedi_lrange range_labpc_ao = {
+	2,
+	{
+			BIP_RANGE(5),
+			UNI_RANGE(10),
+		}
+};
+
+/* functions that do inb/outb and readb/writeb so we can use
+ * function pointers to decide which to use */
+static inline unsigned int labpc_inb(unsigned long address)
+{
+	return inb(address);
+}
+static inline void labpc_outb(unsigned int byte, unsigned long address)
+{
+	outb(byte, address);
+}
+static inline unsigned int labpc_readb(unsigned long address)
+{
+	return readb((void *)address);
+}
+static inline void labpc_writeb(unsigned int byte, unsigned long address)
+{
+	writeb(byte, (void *)address);
+}
+
+static const labpc_board labpc_boards[] = {
+	{
+	      name:	"lab-pc-1200",
+	      ai_speed:10000,
+	      bustype:	isa_bustype,
+	      register_layout:labpc_1200_layout,
+	      has_ao:	1,
+	      ai_range_table:&range_labpc_1200_ai,
+	      ai_range_code:labpc_1200_ai_gain_bits,
+	      ai_range_is_unipolar:labpc_1200_is_unipolar,
+	      ai_scan_up:1,
+	      memory_mapped_io:0,
+		},
+	{
+	      name:	"lab-pc-1200ai",
+	      ai_speed:10000,
+	      bustype:	isa_bustype,
+	      register_layout:labpc_1200_layout,
+	      has_ao:	0,
+	      ai_range_table:&range_labpc_1200_ai,
+	      ai_range_code:labpc_1200_ai_gain_bits,
+	      ai_range_is_unipolar:labpc_1200_is_unipolar,
+	      ai_scan_up:1,
+	      memory_mapped_io:0,
+		},
+	{
+	      name:	"lab-pc+",
+	      ai_speed:12000,
+	      bustype:	isa_bustype,
+	      register_layout:labpc_plus_layout,
+	      has_ao:	1,
+	      ai_range_table:&range_labpc_plus_ai,
+	      ai_range_code:labpc_plus_ai_gain_bits,
+	      ai_range_is_unipolar:labpc_plus_is_unipolar,
+	      ai_scan_up:0,
+	      memory_mapped_io:0,
+		},
+#ifdef CONFIG_COMEDI_PCI
+	{
+		name:	"pci-1200",
+		device_id:0x161,
+		ai_speed:10000,
+		bustype:	pci_bustype,
+		register_layout:labpc_1200_layout,
+		has_ao:	1,
+		ai_range_table:&range_labpc_1200_ai,
+		ai_range_code:labpc_1200_ai_gain_bits,
+		ai_range_is_unipolar:labpc_1200_is_unipolar,
+		ai_scan_up:1,
+		memory_mapped_io:1,
+		},
+	// dummy entry so pci board works when comedi_config is passed driver name
+	{
+		.name = DRV_NAME,
+		.bustype = pci_bustype,
+		},
+#endif
+};
+
+/*
+ * Useful for shorthand access to the particular board structure
+ */
+#define thisboard ((labpc_board *)dev->board_ptr)
+
+static const int dma_buffer_size = 0xff00;	// size in bytes of dma buffer
+static const int sample_size = 2;	// 2 bytes per sample
+
+#define devpriv ((labpc_private *)dev->private)
+
+static comedi_driver driver_labpc = {
+	.driver_name = DRV_NAME,
+	.module = THIS_MODULE,
+	.attach = labpc_attach,
+	.detach = labpc_common_detach,
+	.num_names = sizeof(labpc_boards) / sizeof(labpc_board),
+	.board_name = &labpc_boards[0].name,
+	.offset = sizeof(labpc_board),
+};
+
+#ifdef CONFIG_COMEDI_PCI
+static DEFINE_PCI_DEVICE_TABLE(labpc_pci_table) = {
+	{PCI_VENDOR_ID_NATINST, 0x161, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, labpc_pci_table);
+#endif /* CONFIG_COMEDI_PCI */
+
+static inline int labpc_counter_load(comedi_device * dev,
+	unsigned long base_address, unsigned int counter_number,
+	unsigned int count, unsigned int mode)
+{
+	if (thisboard->memory_mapped_io)
+		return i8254_mm_load((void *)base_address, 0, counter_number,
+			count, mode);
+	else
+		return i8254_load(base_address, 0, counter_number, count, mode);
+}
+
+int labpc_common_attach(comedi_device * dev, unsigned long iobase,
+	unsigned int irq, unsigned int dma_chan)
+{
+	comedi_subdevice *s;
+	int i;
+	unsigned long dma_flags, isr_flags;
+	short lsb, msb;
+
+	printk("comedi%d: ni_labpc: %s, io 0x%lx", dev->minor, thisboard->name,
+		iobase);
+	if (irq) {
+		printk(", irq %u", irq);
+	}
+	if (dma_chan) {
+		printk(", dma %u", dma_chan);
+	}
+	printk("\n");
+
+	if (iobase == 0) {
+		printk("io base address is zero!\n");
+		return -EINVAL;
+	}
+	// request io regions for isa boards
+	if (thisboard->bustype == isa_bustype) {
+		/* check if io addresses are available */
+		if (!request_region(iobase, LABPC_SIZE,
+				driver_labpc.driver_name)) {
+			printk("I/O port conflict\n");
+			return -EIO;
+		}
+	}
+	dev->iobase = iobase;
+
+	if (thisboard->memory_mapped_io) {
+		devpriv->read_byte = labpc_readb;
+		devpriv->write_byte = labpc_writeb;
+	} else {
+		devpriv->read_byte = labpc_inb;
+		devpriv->write_byte = labpc_outb;
+	}
+	// initialize board's command registers
+	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
+	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
+	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
+	if (thisboard->register_layout == labpc_1200_layout) {
+		devpriv->write_byte(devpriv->command5_bits,
+			dev->iobase + COMMAND5_REG);
+		devpriv->write_byte(devpriv->command6_bits,
+			dev->iobase + COMMAND6_REG);
+	}
+
+	/* grab our IRQ */
+	if (irq) {
+		isr_flags = 0;
+		if (thisboard->bustype == pci_bustype)
+			isr_flags |= IRQF_SHARED;
+		if (comedi_request_irq(irq, labpc_interrupt, isr_flags,
+				driver_labpc.driver_name, dev)) {
+			printk("unable to allocate irq %u\n", irq);
+			return -EINVAL;
+		}
+	}
+	dev->irq = irq;
+
+	// grab dma channel
+	if (dma_chan > 3) {
+		printk(" invalid dma channel %u\n", dma_chan);
+		return -EINVAL;
+	} else if (dma_chan) {
+		// allocate dma buffer
+		devpriv->dma_buffer =
+			kmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);
+		if (devpriv->dma_buffer == NULL) {
+			printk(" failed to allocate dma buffer\n");
+			return -ENOMEM;
+		}
+		if (request_dma(dma_chan, driver_labpc.driver_name)) {
+			printk(" failed to allocate dma channel %u\n",
+				dma_chan);
+			return -EINVAL;
+		}
+		devpriv->dma_chan = dma_chan;
+		dma_flags = claim_dma_lock();
+		disable_dma(devpriv->dma_chan);
+		set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
+		release_dma_lock(dma_flags);
+	}
+
+	dev->board_name = thisboard->name;
+
+	if (alloc_subdevices(dev, 5) < 0)
+		return -ENOMEM;
+
+	/* analog input subdevice */
+	s = dev->subdevices + 0;
+	dev->read_subdev = s;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags =
+		SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF |
+		SDF_CMD_READ;
+	s->n_chan = 8;
+	s->len_chanlist = 8;
+	s->maxdata = (1 << 12) - 1;	// 12 bit resolution
+	s->range_table = thisboard->ai_range_table;
+	s->do_cmd = labpc_ai_cmd;
+	s->do_cmdtest = labpc_ai_cmdtest;
+	s->insn_read = labpc_ai_rinsn;
+	s->cancel = labpc_cancel;
+
+	/* analog output */
+	s = dev->subdevices + 1;
+	if (thisboard->has_ao) {
+/* Could provide command support, except it only has a one sample
+ * hardware buffer for analog output and no underrun flag. */
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
+		s->n_chan = NUM_AO_CHAN;
+		s->maxdata = (1 << 12) - 1;	// 12 bit resolution
+		s->range_table = &range_labpc_ao;
+		s->insn_read = labpc_ao_rinsn;
+		s->insn_write = labpc_ao_winsn;
+		/* initialize analog outputs to a known value */
+		for (i = 0; i < s->n_chan; i++) {
+			devpriv->ao_value[i] = s->maxdata / 2;
+			lsb = devpriv->ao_value[i] & 0xff;
+			msb = (devpriv->ao_value[i] >> 8) & 0xff;
+			devpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(i));
+			devpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(i));
+		}
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/* 8255 dio */
+	s = dev->subdevices + 2;
+	// if board uses io memory we have to give a custom callback function to the 8255 driver
+	if (thisboard->memory_mapped_io)
+		subdev_8255_init(dev, s, labpc_dio_mem_callback,
+			(unsigned long)(dev->iobase + DIO_BASE_REG));
+	else
+		subdev_8255_init(dev, s, NULL, dev->iobase + DIO_BASE_REG);
+
+	// calibration subdevices for boards that have one
+	s = dev->subdevices + 3;
+	if (thisboard->register_layout == labpc_1200_layout) {
+		s->type = COMEDI_SUBD_CALIB;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+		s->n_chan = 16;
+		s->maxdata = 0xff;
+		s->insn_read = labpc_calib_read_insn;
+		s->insn_write = labpc_calib_write_insn;
+
+		for (i = 0; i < s->n_chan; i++)
+			write_caldac(dev, i, s->maxdata / 2);
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	/* EEPROM */
+	s = dev->subdevices + 4;
+	if (thisboard->register_layout == labpc_1200_layout) {
+		s->type = COMEDI_SUBD_MEMORY;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+		s->n_chan = EEPROM_SIZE;
+		s->maxdata = 0xff;
+		s->insn_read = labpc_eeprom_read_insn;
+		s->insn_write = labpc_eeprom_write_insn;
+
+		for (i = 0; i < EEPROM_SIZE; i++) {
+			devpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);
+		}
+#ifdef LABPC_DEBUG
+		printk(" eeprom:");
+		for (i = 0; i < EEPROM_SIZE; i++) {
+			printk(" %i:0x%x ", i, devpriv->eeprom_data[i]);
+		}
+		printk("\n");
+#endif
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	return 0;
+}
+
+static int labpc_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	unsigned long iobase = 0;
+	unsigned int irq = 0;
+	unsigned int dma_chan = 0;
+#ifdef CONFIG_COMEDI_PCI
+	int retval;
+#endif
+
+	/* allocate and initialize dev->private */
+	if (alloc_private(dev, sizeof(labpc_private)) < 0)
+		return -ENOMEM;
+
+	// get base address, irq etc. based on bustype
+	switch (thisboard->bustype) {
+	case isa_bustype:
+		iobase = it->options[0];
+		irq = it->options[1];
+		dma_chan = it->options[2];
+		break;
+	case pci_bustype:
+#ifdef CONFIG_COMEDI_PCI
+		retval = labpc_find_device(dev, it->options[0], it->options[1]);
+		if (retval < 0) {
+			return retval;
+		}
+		retval = mite_setup(devpriv->mite);
+		if (retval < 0)
+			return retval;
+		iobase = (unsigned long)devpriv->mite->daq_io_addr;
+		irq = mite_irq(devpriv->mite);
+#else
+		printk(" this driver has not been built with PCI support.\n");
+		return -EINVAL;
+#endif
+		break;
+	case pcmcia_bustype:
+		printk(" this driver does not support pcmcia cards, use ni_labpc_cs.o\n");
+		return -EINVAL;
+		break;
+	default:
+		printk("bug! couldn't determine board type\n");
+		return -EINVAL;
+		break;
+	}
+
+	return labpc_common_attach(dev, iobase, irq, dma_chan);
+}
+
+// adapted from ni_pcimio for finding mite based boards (pc-1200)
+#ifdef CONFIG_COMEDI_PCI
+static int labpc_find_device(comedi_device *dev, int bus, int slot)
+{
+	struct mite_struct *mite;
+	int i;
+	for (mite = mite_devices; mite; mite = mite->next) {
+		if (mite->used)
+			continue;
+		// if bus/slot are specified then make sure we have the right bus/slot
+		if (bus || slot) {
+			if (bus != mite->pcidev->bus->number
+				|| slot != PCI_SLOT(mite->pcidev->devfn))
+				continue;
+		}
+		for (i = 0; i < driver_labpc.num_names; i++) {
+			if (labpc_boards[i].bustype != pci_bustype)
+				continue;
+			if (mite_device_id(mite) == labpc_boards[i].device_id) {
+				devpriv->mite = mite;
+				// fixup board pointer, in case we were using the dummy "ni_labpc" entry
+				dev->board_ptr = &labpc_boards[i];
+				return 0;
+			}
+		}
+	}
+	printk("no device found\n");
+	mite_list_devices();
+	return -EIO;
+}
+#endif
+
+int labpc_common_detach(comedi_device * dev)
+{
+	printk("comedi%d: ni_labpc: detach\n", dev->minor);
+
+	if (dev->subdevices)
+		subdev_8255_cleanup(dev, dev->subdevices + 2);
+
+	/* only free stuff if it has been allocated by _attach */
+	if (devpriv->dma_buffer)
+		kfree(devpriv->dma_buffer);
+	if (devpriv->dma_chan)
+		free_dma(devpriv->dma_chan);
+	if (dev->irq)
+		comedi_free_irq(dev->irq, dev);
+	if (thisboard->bustype == isa_bustype && dev->iobase)
+		release_region(dev->iobase, LABPC_SIZE);
+#ifdef CONFIG_COMEDI_PCI
+	if (devpriv->mite)
+		mite_unsetup(devpriv->mite);
+#endif
+
+	return 0;
+};
+
+static void labpc_clear_adc_fifo(const comedi_device * dev)
+{
+	devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
+	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+	devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+}
+
+static int labpc_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
+	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	devpriv->command3_bits = 0;
+	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
+
+	return 0;
+}
+
+static enum scan_mode labpc_ai_scan_mode(const comedi_cmd * cmd)
+{
+	if (cmd->chanlist_len == 1)
+		return MODE_SINGLE_CHAN;
+
+	/* chanlist may be NULL during cmdtest. */
+	if (cmd->chanlist == NULL)
+		return MODE_MULT_CHAN_UP;
+
+	if (CR_CHAN(cmd->chanlist[0]) == CR_CHAN(cmd->chanlist[1]))
+		return MODE_SINGLE_CHAN_INTERVAL;
+
+	if (CR_CHAN(cmd->chanlist[0]) < CR_CHAN(cmd->chanlist[1]))
+		return MODE_MULT_CHAN_UP;
+
+	if (CR_CHAN(cmd->chanlist[0]) > CR_CHAN(cmd->chanlist[1]))
+		return MODE_MULT_CHAN_DOWN;
+
+	rt_printk("ni_labpc: bug! this should never happen\n");
+
+	return 0;
+}
+
+static int labpc_ai_chanlist_invalid(const comedi_device * dev,
+	const comedi_cmd * cmd)
+{
+	int mode, channel, range, aref, i;
+
+	if (cmd->chanlist == NULL)
+		return 0;
+
+	mode = labpc_ai_scan_mode(cmd);
+
+	if (mode == MODE_SINGLE_CHAN)
+		return 0;
+
+	if (mode == MODE_SINGLE_CHAN_INTERVAL) {
+		if (cmd->chanlist_len > 0xff) {
+			comedi_error(dev,
+				"ni_labpc: chanlist too long for single channel interval mode\n");
+			return 1;
+		}
+	}
+
+	channel = CR_CHAN(cmd->chanlist[0]);
+	range = CR_RANGE(cmd->chanlist[0]);
+	aref = CR_AREF(cmd->chanlist[0]);
+
+	for (i = 0; i < cmd->chanlist_len; i++) {
+
+		switch (mode) {
+		case MODE_SINGLE_CHAN_INTERVAL:
+			if (CR_CHAN(cmd->chanlist[i]) != channel) {
+				comedi_error(dev,
+					"channel scanning order specified in chanlist is not supported by hardware.\n");
+				return 1;
+			}
+			break;
+		case MODE_MULT_CHAN_UP:
+			if (CR_CHAN(cmd->chanlist[i]) != i) {
+				comedi_error(dev,
+					"channel scanning order specified in chanlist is not supported by hardware.\n");
+				return 1;
+			}
+			break;
+		case MODE_MULT_CHAN_DOWN:
+			if (CR_CHAN(cmd->chanlist[i]) !=
+				cmd->chanlist_len - i - 1) {
+				comedi_error(dev,
+					"channel scanning order specified in chanlist is not supported by hardware.\n");
+				return 1;
+			}
+			break;
+		default:
+			rt_printk("ni_labpc: bug! in chanlist check\n");
+			return 1;
+			break;
+		}
+
+		if (CR_RANGE(cmd->chanlist[i]) != range) {
+			comedi_error(dev,
+				"entries in chanlist must all have the same range\n");
+			return 1;
+		}
+
+		if (CR_AREF(cmd->chanlist[i]) != aref) {
+			comedi_error(dev,
+				"entries in chanlist must all have the same reference\n");
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static int labpc_use_continuous_mode(const comedi_cmd * cmd)
+{
+	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN)
+		return 1;
+
+	if (cmd->scan_begin_src == TRIG_FOLLOW)
+		return 1;
+
+	return 0;
+}
+
+static unsigned int labpc_ai_convert_period(const comedi_cmd * cmd)
+{
+	if (cmd->convert_src != TRIG_TIMER)
+		return 0;
+
+	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
+		cmd->scan_begin_src == TRIG_TIMER)
+		return cmd->scan_begin_arg;
+
+	return cmd->convert_arg;
+}
+
+static void labpc_set_ai_convert_period(comedi_cmd * cmd, unsigned int ns)
+{
+	if (cmd->convert_src != TRIG_TIMER)
+		return;
+
+	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
+		cmd->scan_begin_src == TRIG_TIMER) {
+		cmd->scan_begin_arg = ns;
+		if (cmd->convert_arg > cmd->scan_begin_arg)
+			cmd->convert_arg = cmd->scan_begin_arg;
+	} else
+		cmd->convert_arg = ns;
+}
+
+static unsigned int labpc_ai_scan_period(const comedi_cmd * cmd)
+{
+	if (cmd->scan_begin_src != TRIG_TIMER)
+		return 0;
+
+	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
+		cmd->convert_src == TRIG_TIMER)
+		return 0;
+
+	return cmd->scan_begin_arg;
+}
+
+static void labpc_set_ai_scan_period(comedi_cmd * cmd, unsigned int ns)
+{
+	if (cmd->scan_begin_src != TRIG_TIMER)
+		return;
+
+	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
+		cmd->convert_src == TRIG_TIMER)
+		return;
+
+	cmd->scan_begin_arg = ns;
+}
+
+static int labpc_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp, tmp2;
+	int stop_mask;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_EXT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_TIMER | TRIG_FOLLOW | TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_TIMER | TRIG_EXT;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	stop_mask = TRIG_COUNT | TRIG_NONE;
+	if (thisboard->register_layout == labpc_1200_layout)
+		stop_mask |= TRIG_EXT;
+	cmd->stop_src &= stop_mask;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
+		err++;
+	if (cmd->scan_begin_src != TRIG_TIMER &&
+		cmd->scan_begin_src != TRIG_FOLLOW &&
+		cmd->scan_begin_src != TRIG_EXT)
+		err++;
+	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT &&
+		cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	// can't have external stop and start triggers at once
+	if (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg == TRIG_NOW && cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	if (!cmd->chanlist_len) {
+		err++;
+	}
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg < thisboard->ai_speed) {
+			cmd->convert_arg = thisboard->ai_speed;
+			err++;
+		}
+	}
+	// make sure scan timing is not too fast
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		if (cmd->convert_src == TRIG_TIMER &&
+			cmd->scan_begin_arg <
+			cmd->convert_arg * cmd->chanlist_len) {
+			cmd->scan_begin_arg =
+				cmd->convert_arg * cmd->chanlist_len;
+			err++;
+		}
+		if (cmd->scan_begin_arg <
+			thisboard->ai_speed * cmd->chanlist_len) {
+			cmd->scan_begin_arg =
+				thisboard->ai_speed * cmd->chanlist_len;
+			err++;
+		}
+	}
+	// stop source
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		if (!cmd->stop_arg) {
+			cmd->stop_arg = 1;
+			err++;
+		}
+		break;
+	case TRIG_NONE:
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+		break;
+		// TRIG_EXT doesn't care since it doesn't trigger off a numbered channel
+	default:
+		break;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	tmp = cmd->convert_arg;
+	tmp2 = cmd->scan_begin_arg;
+	labpc_adc_timing(dev, cmd);
+	if (tmp != cmd->convert_arg || tmp2 != cmd->scan_begin_arg)
+		err++;
+
+	if (err)
+		return 4;
+
+	if (labpc_ai_chanlist_invalid(dev, cmd))
+		return 5;
+
+	return 0;
+}
+
+static int labpc_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	int channel, range, aref;
+	unsigned long irq_flags;
+	int ret;
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	enum transfer_type xfer;
+	unsigned long flags;
+
+	if (!dev->irq) {
+		comedi_error(dev, "no irq assigned, cannot perform command");
+		return -1;
+	}
+
+	range = CR_RANGE(cmd->chanlist[0]);
+	aref = CR_AREF(cmd->chanlist[0]);
+
+	// make sure board is disabled before setting up aquisition
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
+	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	devpriv->command3_bits = 0;
+	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
+
+	// initialize software conversion count
+	if (cmd->stop_src == TRIG_COUNT) {
+		devpriv->count = cmd->stop_arg * cmd->chanlist_len;
+	}
+	// setup hardware conversion counter
+	if (cmd->stop_src == TRIG_EXT) {
+		// load counter a1 with count of 3 (pc+ manual says this is minimum allowed) using mode 0
+		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
+			1, 3, 0);
+		if (ret < 0) {
+			comedi_error(dev, "error loading counter a1");
+			return -1;
+		}
+	} else			// otherwise, just put a1 in mode 0 with no count to set its output low
+		devpriv->write_byte(INIT_A1_BITS,
+			dev->iobase + COUNTER_A_CONTROL_REG);
+
+	// figure out what method we will use to transfer data
+	if (devpriv->dma_chan &&	// need a dma channel allocated
+		// dma unsafe at RT priority, and too much setup time for TRIG_WAKE_EOS for
+		(cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0 &&
+		// only available on the isa boards
+		thisboard->bustype == isa_bustype) {
+		xfer = isa_dma_transfer;
+	} else if (thisboard->register_layout == labpc_1200_layout &&	// pc-plus has no fifo-half full interrupt
+		// wake-end-of-scan should interrupt on fifo not empty
+		(cmd->flags & TRIG_WAKE_EOS) == 0 &&
+		// make sure we are taking more than just a few points
+		(cmd->stop_src != TRIG_COUNT || devpriv->count > 256)) {
+		xfer = fifo_half_full_transfer;
+	} else
+		xfer = fifo_not_empty_transfer;
+	devpriv->current_transfer = xfer;
+
+	// setup command6 register for 1200 boards
+	if (thisboard->register_layout == labpc_1200_layout) {
+		// reference inputs to ground or common?
+		if (aref != AREF_GROUND)
+			devpriv->command6_bits |= ADC_COMMON_BIT;
+		else
+			devpriv->command6_bits &= ~ADC_COMMON_BIT;
+		// bipolar or unipolar range?
+		if (thisboard->ai_range_is_unipolar[range])
+			devpriv->command6_bits |= ADC_UNIP_BIT;
+		else
+			devpriv->command6_bits &= ~ADC_UNIP_BIT;
+		// interrupt on fifo half full?
+		if (xfer == fifo_half_full_transfer)
+			devpriv->command6_bits |= ADC_FHF_INTR_EN_BIT;
+		else
+			devpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;
+		// enable interrupt on counter a1 terminal count?
+		if (cmd->stop_src == TRIG_EXT)
+			devpriv->command6_bits |= A1_INTR_EN_BIT;
+		else
+			devpriv->command6_bits &= ~A1_INTR_EN_BIT;
+		// are we scanning up or down through channels?
+		if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP)
+			devpriv->command6_bits |= ADC_SCAN_UP_BIT;
+		else
+			devpriv->command6_bits &= ~ADC_SCAN_UP_BIT;
+		// write to register
+		devpriv->write_byte(devpriv->command6_bits,
+			dev->iobase + COMMAND6_REG);
+	}
+
+	/* setup channel list, etc (command1 register) */
+	devpriv->command1_bits = 0;
+	if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP)
+		channel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);
+	else
+		channel = CR_CHAN(cmd->chanlist[0]);
+	// munge channel bits for differential / scan disabled mode
+	if (labpc_ai_scan_mode(cmd) != MODE_SINGLE_CHAN && aref == AREF_DIFF)
+		channel *= 2;
+	devpriv->command1_bits |= ADC_CHAN_BITS(channel);
+	devpriv->command1_bits |= thisboard->ai_range_code[range];
+	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
+	// manual says to set scan enable bit on second pass
+	if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP ||
+		labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_DOWN) {
+		devpriv->command1_bits |= ADC_SCAN_EN_BIT;
+		/* need a brief delay before enabling scan, or scan list will get screwed when you switch
+		 * between scan up to scan down mode - dunno why */
+		comedi_udelay(1);
+		devpriv->write_byte(devpriv->command1_bits,
+			dev->iobase + COMMAND1_REG);
+	}
+	// setup any external triggering/pacing (command4 register)
+	devpriv->command4_bits = 0;
+	if (cmd->convert_src != TRIG_EXT)
+		devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
+	/* XXX should discard first scan when using interval scanning
+	 * since manual says it is not synced with scan clock */
+	if (labpc_use_continuous_mode(cmd) == 0) {
+		devpriv->command4_bits |= INTERVAL_SCAN_EN_BIT;
+		if (cmd->scan_begin_src == TRIG_EXT)
+			devpriv->command4_bits |= EXT_SCAN_EN_BIT;
+	}
+	// single-ended/differential
+	if (aref == AREF_DIFF)
+		devpriv->command4_bits |= ADC_DIFF_BIT;
+	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
+
+	devpriv->write_byte(cmd->chanlist_len,
+		dev->iobase + INTERVAL_COUNT_REG);
+	// load count
+	devpriv->write_byte(INTERVAL_LOAD_BITS,
+		dev->iobase + INTERVAL_LOAD_REG);
+
+	if (cmd->convert_src == TRIG_TIMER || cmd->scan_begin_src == TRIG_TIMER) {
+		// set up pacing
+		labpc_adc_timing(dev, cmd);
+		// load counter b0 in mode 3
+		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
+			0, devpriv->divisor_b0, 3);
+		if (ret < 0) {
+			comedi_error(dev, "error loading counter b0");
+			return -1;
+		}
+	}
+	// set up conversion pacing
+	if (labpc_ai_convert_period(cmd)) {
+		// load counter a0 in mode 2
+		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
+			0, devpriv->divisor_a0, 2);
+		if (ret < 0) {
+			comedi_error(dev, "error loading counter a0");
+			return -1;
+		}
+	} else
+		devpriv->write_byte(INIT_A0_BITS,
+			dev->iobase + COUNTER_A_CONTROL_REG);
+
+	// set up scan pacing
+	if (labpc_ai_scan_period(cmd)) {
+		// load counter b1 in mode 2
+		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
+			1, devpriv->divisor_b1, 2);
+		if (ret < 0) {
+			comedi_error(dev, "error loading counter b1");
+			return -1;
+		}
+	}
+
+	labpc_clear_adc_fifo(dev);
+
+	// set up dma transfer
+	if (xfer == isa_dma_transfer) {
+		irq_flags = claim_dma_lock();
+		disable_dma(devpriv->dma_chan);
+		/* clear flip-flop to make sure 2-byte registers for
+		 * count and address get set correctly */
+		clear_dma_ff(devpriv->dma_chan);
+		set_dma_addr(devpriv->dma_chan,
+			virt_to_bus(devpriv->dma_buffer));
+		// set appropriate size of transfer
+		devpriv->dma_transfer_size = labpc_suggest_transfer_size(*cmd);
+		if (cmd->stop_src == TRIG_COUNT &&
+			devpriv->count * sample_size <
+			devpriv->dma_transfer_size) {
+			devpriv->dma_transfer_size =
+				devpriv->count * sample_size;
+		}
+		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
+		enable_dma(devpriv->dma_chan);
+		release_dma_lock(irq_flags);
+		// enable board's dma
+		devpriv->command3_bits |= DMA_EN_BIT | DMATC_INTR_EN_BIT;
+	} else
+		devpriv->command3_bits &= ~DMA_EN_BIT & ~DMATC_INTR_EN_BIT;
+
+	// enable error interrupts
+	devpriv->command3_bits |= ERR_INTR_EN_BIT;
+	// enable fifo not empty interrupt?
+	if (xfer == fifo_not_empty_transfer)
+		devpriv->command3_bits |= ADC_FNE_INTR_EN_BIT;
+	else
+		devpriv->command3_bits &= ~ADC_FNE_INTR_EN_BIT;
+	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
+
+	// startup aquisition
+
+	// command2 reg
+	// use 2 cascaded counters for pacing
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->command2_bits |= CASCADE_BIT;
+	switch (cmd->start_src) {
+	case TRIG_EXT:
+		devpriv->command2_bits |= HWTRIG_BIT;
+		devpriv->command2_bits &= ~PRETRIG_BIT & ~SWTRIG_BIT;
+		break;
+	case TRIG_NOW:
+		devpriv->command2_bits |= SWTRIG_BIT;
+		devpriv->command2_bits &= ~PRETRIG_BIT & ~HWTRIG_BIT;
+		break;
+	default:
+		comedi_error(dev, "bug with start_src");
+		return -1;
+		break;
+	}
+	switch (cmd->stop_src) {
+	case TRIG_EXT:
+		devpriv->command2_bits |= HWTRIG_BIT | PRETRIG_BIT;
+		break;
+	case TRIG_COUNT:
+	case TRIG_NONE:
+		break;
+	default:
+		comedi_error(dev, "bug with stop_src");
+		return -1;
+	}
+	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	return 0;
+}
+
+/* interrupt service routine */
+static irqreturn_t labpc_interrupt(int irq, void *d PT_REGS_ARG)
+{
+	comedi_device *dev = d;
+	comedi_subdevice *s = dev->read_subdev;
+	comedi_async *async;
+	comedi_cmd *cmd;
+
+	if (dev->attached == 0) {
+		comedi_error(dev, "premature interrupt");
+		return IRQ_HANDLED;
+	}
+
+	async = s->async;
+	cmd = &async->cmd;
+	async->events = 0;
+
+	// read board status
+	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
+	if (thisboard->register_layout == labpc_1200_layout)
+		devpriv->status2_bits =
+			devpriv->read_byte(dev->iobase + STATUS2_REG);
+
+	if ((devpriv->status1_bits & (DMATC_BIT | TIMER_BIT | OVERFLOW_BIT |
+				OVERRUN_BIT | DATA_AVAIL_BIT)) == 0
+		&& (devpriv->status2_bits & A1_TC_BIT) == 0
+		&& (devpriv->status2_bits & FNHF_BIT)) {
+		return IRQ_NONE;
+	}
+
+	if (devpriv->status1_bits & OVERRUN_BIT) {
+		// clear error interrupt
+		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
+		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		comedi_event(dev, s);
+		comedi_error(dev, "overrun");
+		return IRQ_HANDLED;
+	}
+
+	if (devpriv->current_transfer == isa_dma_transfer) {
+		// if a dma terminal count of external stop trigger has occurred
+		if (devpriv->status1_bits & DMATC_BIT ||
+			(thisboard->register_layout == labpc_1200_layout
+				&& devpriv->status2_bits & A1_TC_BIT)) {
+			handle_isa_dma(dev);
+		}
+	} else
+		labpc_drain_fifo(dev);
+
+	if (devpriv->status1_bits & TIMER_BIT) {
+		comedi_error(dev, "handled timer interrupt?");
+		// clear it
+		devpriv->write_byte(0x1, dev->iobase + TIMER_CLEAR_REG);
+	}
+
+	if (devpriv->status1_bits & OVERFLOW_BIT) {
+		// clear error interrupt
+		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
+		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		comedi_event(dev, s);
+		comedi_error(dev, "overflow");
+		return IRQ_HANDLED;
+	}
+	// handle external stop trigger
+	if (cmd->stop_src == TRIG_EXT) {
+		if (devpriv->status2_bits & A1_TC_BIT) {
+			labpc_drain_dregs(dev);
+			labpc_cancel(dev, s);
+			async->events |= COMEDI_CB_EOA;
+		}
+	}
+
+	/* TRIG_COUNT end of acquisition */
+	if (cmd->stop_src == TRIG_COUNT) {
+		if (devpriv->count == 0) {
+			labpc_cancel(dev, s);
+			async->events |= COMEDI_CB_EOA;
+		}
+	}
+
+	comedi_event(dev, s);
+	return IRQ_HANDLED;
+}
+
+// read all available samples from ai fifo
+static int labpc_drain_fifo(comedi_device * dev)
+{
+	unsigned int lsb, msb;
+	sampl_t data;
+	comedi_async *async = dev->read_subdev->async;
+	const int timeout = 10000;
+	unsigned int i;
+
+	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
+
+	for (i = 0; (devpriv->status1_bits & DATA_AVAIL_BIT) && i < timeout;
+		i++) {
+		// quit if we have all the data we want
+		if (async->cmd.stop_src == TRIG_COUNT) {
+			if (devpriv->count == 0)
+				break;
+			devpriv->count--;
+		}
+		lsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+		msb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+		data = (msb << 8) | lsb;
+		cfc_write_to_buffer(dev->read_subdev, data);
+		devpriv->status1_bits =
+			devpriv->read_byte(dev->iobase + STATUS1_REG);
+	}
+	if (i == timeout) {
+		comedi_error(dev, "ai timeout, fifo never empties");
+		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		return -1;
+	}
+
+	return 0;
+}
+
+static void labpc_drain_dma(comedi_device * dev)
+{
+	comedi_subdevice *s = dev->read_subdev;
+	comedi_async *async = s->async;
+	int status;
+	unsigned long flags;
+	unsigned int max_points, num_points, residue, leftover;
+	int i;
+
+	status = devpriv->status1_bits;
+
+	flags = claim_dma_lock();
+	disable_dma(devpriv->dma_chan);
+	/* clear flip-flop to make sure 2-byte registers for
+	 * count and address get set correctly */
+	clear_dma_ff(devpriv->dma_chan);
+
+	// figure out how many points to read
+	max_points = devpriv->dma_transfer_size / sample_size;
+	/* residue is the number of points left to be done on the dma
+	 * transfer.  It should always be zero at this point unless
+	 * the stop_src is set to external triggering.
+	 */
+	residue = get_dma_residue(devpriv->dma_chan) / sample_size;
+	num_points = max_points - residue;
+	if (devpriv->count < num_points && async->cmd.stop_src == TRIG_COUNT)
+		num_points = devpriv->count;
+
+	// figure out how many points will be stored next time
+	leftover = 0;
+	if (async->cmd.stop_src != TRIG_COUNT) {
+		leftover = devpriv->dma_transfer_size / sample_size;
+	} else if (devpriv->count > num_points) {
+		leftover = devpriv->count - num_points;
+		if (leftover > max_points)
+			leftover = max_points;
+	}
+
+	/* write data to comedi buffer */
+	for (i = 0; i < num_points; i++) {
+		cfc_write_to_buffer(s, devpriv->dma_buffer[i]);
+	}
+	if (async->cmd.stop_src == TRIG_COUNT)
+		devpriv->count -= num_points;
+
+	// set address and count for next transfer
+	set_dma_addr(devpriv->dma_chan, virt_to_bus(devpriv->dma_buffer));
+	set_dma_count(devpriv->dma_chan, leftover * sample_size);
+	release_dma_lock(flags);
+
+	async->events |= COMEDI_CB_BLOCK;
+}
+
+static void handle_isa_dma(comedi_device * dev)
+{
+	labpc_drain_dma(dev);
+
+	enable_dma(devpriv->dma_chan);
+
+	// clear dma tc interrupt
+	devpriv->write_byte(0x1, dev->iobase + DMATC_CLEAR_REG);
+}
+
+/* makes sure all data aquired by board is transfered to comedi (used
+ * when aquisition is terminated by stop_src == TRIG_EXT). */
+static void labpc_drain_dregs(comedi_device * dev)
+{
+	if (devpriv->current_transfer == isa_dma_transfer)
+		labpc_drain_dma(dev);
+
+	labpc_drain_fifo(dev);
+}
+
+static int labpc_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i, n;
+	int chan, range;
+	int lsb, msb;
+	int timeout = 1000;
+	unsigned long flags;
+
+	// disable timed conversions
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
+	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	// disable interrupt generation and dma
+	devpriv->command3_bits = 0;
+	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
+
+	/* set gain and channel */
+	devpriv->command1_bits = 0;
+	chan = CR_CHAN(insn->chanspec);
+	range = CR_RANGE(insn->chanspec);
+	devpriv->command1_bits |= thisboard->ai_range_code[range];
+	// munge channel bits for differential/scan disabled mode
+	if (CR_AREF(insn->chanspec) == AREF_DIFF)
+		chan *= 2;
+	devpriv->command1_bits |= ADC_CHAN_BITS(chan);
+	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
+
+	// setup command6 register for 1200 boards
+	if (thisboard->register_layout == labpc_1200_layout) {
+		// reference inputs to ground or common?
+		if (CR_AREF(insn->chanspec) != AREF_GROUND)
+			devpriv->command6_bits |= ADC_COMMON_BIT;
+		else
+			devpriv->command6_bits &= ~ADC_COMMON_BIT;
+		// bipolar or unipolar range?
+		if (thisboard->ai_range_is_unipolar[range])
+			devpriv->command6_bits |= ADC_UNIP_BIT;
+		else
+			devpriv->command6_bits &= ~ADC_UNIP_BIT;
+		// don't interrupt on fifo half full
+		devpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;
+		// don't enable interrupt on counter a1 terminal count?
+		devpriv->command6_bits &= ~A1_INTR_EN_BIT;
+		// write to register
+		devpriv->write_byte(devpriv->command6_bits,
+			dev->iobase + COMMAND6_REG);
+	}
+	// setup command4 register
+	devpriv->command4_bits = 0;
+	devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
+	// single-ended/differential
+	if (CR_AREF(insn->chanspec) == AREF_DIFF)
+		devpriv->command4_bits |= ADC_DIFF_BIT;
+	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
+
+	// initialize pacer counter output to make sure it doesn't cause any problems
+	devpriv->write_byte(INIT_A0_BITS, dev->iobase + COUNTER_A_CONTROL_REG);
+
+	labpc_clear_adc_fifo(dev);
+
+	for (n = 0; n < insn->n; n++) {
+		/* trigger conversion */
+		devpriv->write_byte(0x1, dev->iobase + ADC_CONVERT_REG);
+
+		for (i = 0; i < timeout; i++) {
+			if (devpriv->read_byte(dev->iobase +
+					STATUS1_REG) & DATA_AVAIL_BIT)
+				break;
+			comedi_udelay(1);
+		}
+		if (i == timeout) {
+			comedi_error(dev, "timeout");
+			return -ETIME;
+		}
+		lsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+		msb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);
+		data[n] = (msb << 8) | lsb;
+	}
+
+	return n;
+}
+
+// analog output insn
+static int labpc_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int channel, range;
+	unsigned long flags;
+	int lsb, msb;
+
+	channel = CR_CHAN(insn->chanspec);
+
+	// turn off pacing of analog output channel
+	/* note: hardware bug in daqcard-1200 means pacing cannot
+	 * be independently enabled/disabled for its the two channels */
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->command2_bits &= ~DAC_PACED_BIT(channel);
+	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	// set range
+	if (thisboard->register_layout == labpc_1200_layout) {
+		range = CR_RANGE(insn->chanspec);
+		if (range & AO_RANGE_IS_UNIPOLAR)
+			devpriv->command6_bits |= DAC_UNIP_BIT(channel);
+		else
+			devpriv->command6_bits &= ~DAC_UNIP_BIT(channel);
+		// write to register
+		devpriv->write_byte(devpriv->command6_bits,
+			dev->iobase + COMMAND6_REG);
+	}
+	// send data
+	lsb = data[0] & 0xff;
+	msb = (data[0] >> 8) & 0xff;
+	devpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(channel));
+	devpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(channel));
+
+	// remember value for readback
+	devpriv->ao_value[channel] = data[0];
+
+	return 1;
+}
+
+// analog output readback insn
+static int labpc_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
+static int labpc_calib_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = devpriv->caldac[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
+static int labpc_calib_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int channel = CR_CHAN(insn->chanspec);
+
+	write_caldac(dev, channel, data[0]);
+	return 1;
+}
+
+static int labpc_eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = devpriv->eeprom_data[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
+static int labpc_eeprom_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int channel = CR_CHAN(insn->chanspec);
+	int ret;
+
+	// only allow writes to user area of eeprom
+	if (channel < 16 || channel > 127) {
+		printk("eeprom writes are only allowed to channels 16 through 127 (the pointer and user areas)");
+		return -EINVAL;
+	}
+
+	ret = labpc_eeprom_write(dev, channel, data[0]);
+	if (ret < 0)
+		return ret;
+
+	return 1;
+}
+
+// utility function that suggests a dma transfer size in bytes
+static unsigned int labpc_suggest_transfer_size(comedi_cmd cmd)
+{
+	unsigned int size;
+	unsigned int freq;
+
+	if (cmd.convert_src == TRIG_TIMER)
+		freq = 1000000000 / cmd.convert_arg;
+	// return some default value
+	else
+		freq = 0xffffffff;
+
+	// make buffer fill in no more than 1/3 second
+	size = (freq / 3) * sample_size;
+
+	// set a minimum and maximum size allowed
+	if (size > dma_buffer_size)
+		size = dma_buffer_size - dma_buffer_size % sample_size;
+	else if (size < sample_size)
+		size = sample_size;
+
+	return size;
+}
+
+// figures out what counter values to use based on command
+static void labpc_adc_timing(comedi_device * dev, comedi_cmd * cmd)
+{
+	const int max_counter_value = 0x10000;	// max value for 16 bit counter in mode 2
+	const int min_counter_value = 2;	// min value for 16 bit counter in mode 2
+	unsigned int base_period;
+
+	// if both convert and scan triggers are TRIG_TIMER, then they both rely on counter b0
+	if (labpc_ai_convert_period(cmd) && labpc_ai_scan_period(cmd)) {
+		// pick the lowest b0 divisor value we can (for maximum input clock speed on convert and scan counters)
+		devpriv->divisor_b0 = (labpc_ai_scan_period(cmd) - 1) /
+			(LABPC_TIMER_BASE * max_counter_value) + 1;
+		if (devpriv->divisor_b0 < min_counter_value)
+			devpriv->divisor_b0 = min_counter_value;
+		if (devpriv->divisor_b0 > max_counter_value)
+			devpriv->divisor_b0 = max_counter_value;
+
+		base_period = LABPC_TIMER_BASE * devpriv->divisor_b0;
+
+		// set a0 for conversion frequency and b1 for scan frequency
+		switch (cmd->flags & TRIG_ROUND_MASK) {
+		default:
+		case TRIG_ROUND_NEAREST:
+			devpriv->divisor_a0 =
+				(labpc_ai_convert_period(cmd) +
+				(base_period / 2)) / base_period;
+			devpriv->divisor_b1 =
+				(labpc_ai_scan_period(cmd) +
+				(base_period / 2)) / base_period;
+			break;
+		case TRIG_ROUND_UP:
+			devpriv->divisor_a0 =
+				(labpc_ai_convert_period(cmd) + (base_period -
+					1)) / base_period;
+			devpriv->divisor_b1 =
+				(labpc_ai_scan_period(cmd) + (base_period -
+					1)) / base_period;
+			break;
+		case TRIG_ROUND_DOWN:
+			devpriv->divisor_a0 =
+				labpc_ai_convert_period(cmd) / base_period;
+			devpriv->divisor_b1 =
+				labpc_ai_scan_period(cmd) / base_period;
+			break;
+		}
+		// make sure a0 and b1 values are acceptable
+		if (devpriv->divisor_a0 < min_counter_value)
+			devpriv->divisor_a0 = min_counter_value;
+		if (devpriv->divisor_a0 > max_counter_value)
+			devpriv->divisor_a0 = max_counter_value;
+		if (devpriv->divisor_b1 < min_counter_value)
+			devpriv->divisor_b1 = min_counter_value;
+		if (devpriv->divisor_b1 > max_counter_value)
+			devpriv->divisor_b1 = max_counter_value;
+		// write corrected timings to command
+		labpc_set_ai_convert_period(cmd,
+			base_period * devpriv->divisor_a0);
+		labpc_set_ai_scan_period(cmd,
+			base_period * devpriv->divisor_b1);
+		// if only one TRIG_TIMER is used, we can employ the generic cascaded timing functions
+	} else if (labpc_ai_scan_period(cmd)) {
+		unsigned int scan_period;
+
+		scan_period = labpc_ai_scan_period(cmd);
+		/* calculate cascaded counter values that give desired scan timing */
+		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
+			&(devpriv->divisor_b1), &(devpriv->divisor_b0),
+			&scan_period, cmd->flags & TRIG_ROUND_MASK);
+		labpc_set_ai_scan_period(cmd, scan_period);
+	} else if (labpc_ai_convert_period(cmd)) {
+		unsigned int convert_period;
+
+		convert_period = labpc_ai_convert_period(cmd);
+		/* calculate cascaded counter values that give desired conversion timing */
+		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
+			&(devpriv->divisor_a0), &(devpriv->divisor_b0),
+			&convert_period, cmd->flags & TRIG_ROUND_MASK);
+		labpc_set_ai_convert_period(cmd, convert_period);
+	}
+}
+
+static int labpc_dio_mem_callback(int dir, int port, int data,
+	unsigned long iobase)
+{
+	if (dir) {
+		writeb(data, (void *)(iobase + port));
+		return 0;
+	} else {
+		return readb((void *)(iobase + port));
+	}
+}
+
+// lowlevel write to eeprom/dac
+static void labpc_serial_out(comedi_device * dev, unsigned int value,
+	unsigned int value_width)
+{
+	int i;
+
+	for (i = 1; i <= value_width; i++) {
+		// clear serial clock
+		devpriv->command5_bits &= ~SCLOCK_BIT;
+		// send bits most significant bit first
+		if (value & (1 << (value_width - i)))
+			devpriv->command5_bits |= SDATA_BIT;
+		else
+			devpriv->command5_bits &= ~SDATA_BIT;
+		comedi_udelay(1);
+		devpriv->write_byte(devpriv->command5_bits,
+			dev->iobase + COMMAND5_REG);
+		// set clock to load bit
+		devpriv->command5_bits |= SCLOCK_BIT;
+		comedi_udelay(1);
+		devpriv->write_byte(devpriv->command5_bits,
+			dev->iobase + COMMAND5_REG);
+	}
+}
+
+// lowlevel read from eeprom
+static unsigned int labpc_serial_in(comedi_device * dev)
+{
+	unsigned int value = 0;
+	int i;
+	const int value_width = 8;	// number of bits wide values are
+
+	for (i = 1; i <= value_width; i++) {
+		// set serial clock
+		devpriv->command5_bits |= SCLOCK_BIT;
+		comedi_udelay(1);
+		devpriv->write_byte(devpriv->command5_bits,
+			dev->iobase + COMMAND5_REG);
+		// clear clock bit
+		devpriv->command5_bits &= ~SCLOCK_BIT;
+		comedi_udelay(1);
+		devpriv->write_byte(devpriv->command5_bits,
+			dev->iobase + COMMAND5_REG);
+		// read bits most significant bit first
+		comedi_udelay(1);
+		devpriv->status2_bits =
+			devpriv->read_byte(dev->iobase + STATUS2_REG);
+		if (devpriv->status2_bits & EEPROM_OUT_BIT) {
+			value |= 1 << (value_width - i);
+		}
+	}
+
+	return value;
+}
+
+static unsigned int labpc_eeprom_read(comedi_device * dev, unsigned int address)
+{
+	unsigned int value;
+	const int read_instruction = 0x3;	// bits to tell eeprom to expect a read
+	const int write_length = 8;	// 8 bit write lengths to eeprom
+
+	// enable read/write to eeprom
+	devpriv->command5_bits &= ~EEPROM_EN_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+
+	// send read instruction
+	labpc_serial_out(dev, read_instruction, write_length);
+	// send 8 bit address to read from
+	labpc_serial_out(dev, address, write_length);
+	// read result
+	value = labpc_serial_in(dev);
+
+	// disable read/write to eeprom
+	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+
+	return value;
+}
+
+static unsigned int labpc_eeprom_write(comedi_device * dev,
+	unsigned int address, unsigned int value)
+{
+	const int write_enable_instruction = 0x6;
+	const int write_instruction = 0x2;
+	const int write_length = 8;	// 8 bit write lengths to eeprom
+	const int write_in_progress_bit = 0x1;
+	const int timeout = 10000;
+	int i;
+
+	// make sure there isn't already a write in progress
+	for (i = 0; i < timeout; i++) {
+		if ((labpc_eeprom_read_status(dev) & write_in_progress_bit) ==
+			0)
+			break;
+	}
+	if (i == timeout) {
+		comedi_error(dev, "eeprom write timed out");
+		return -ETIME;
+	}
+	// update software copy of eeprom
+	devpriv->eeprom_data[address] = value;
+
+	// enable read/write to eeprom
+	devpriv->command5_bits &= ~EEPROM_EN_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+
+	// send write_enable instruction
+	labpc_serial_out(dev, write_enable_instruction, write_length);
+	devpriv->command5_bits &= ~EEPROM_EN_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+
+	// send write instruction
+	devpriv->command5_bits |= EEPROM_EN_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	labpc_serial_out(dev, write_instruction, write_length);
+	// send 8 bit address to write to
+	labpc_serial_out(dev, address, write_length);
+	// write value
+	labpc_serial_out(dev, value, write_length);
+	devpriv->command5_bits &= ~EEPROM_EN_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+
+	// disable read/write to eeprom
+	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+
+	return 0;
+}
+
+static unsigned int labpc_eeprom_read_status(comedi_device * dev)
+{
+	unsigned int value;
+	const int read_status_instruction = 0x5;
+	const int write_length = 8;	// 8 bit write lengths to eeprom
+
+	// enable read/write to eeprom
+	devpriv->command5_bits &= ~EEPROM_EN_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+
+	// send read status instruction
+	labpc_serial_out(dev, read_status_instruction, write_length);
+	// read result
+	value = labpc_serial_in(dev);
+
+	// disable read/write to eeprom
+	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+
+	return value;
+}
+
+// writes to 8 bit calibration dacs
+static void write_caldac(comedi_device * dev, unsigned int channel,
+	unsigned int value)
+{
+	if (value == devpriv->caldac[channel])
+		return;
+	devpriv->caldac[channel] = value;
+
+	// clear caldac load bit and make sure we don't write to eeprom
+	devpriv->command5_bits &=
+		~CALDAC_LOAD_BIT & ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+
+	// write 4 bit channel
+	labpc_serial_out(dev, channel, 4);
+	// write 8 bit caldac value
+	labpc_serial_out(dev, value, 8);
+
+	// set and clear caldac bit to load caldac value
+	devpriv->command5_bits |= CALDAC_LOAD_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+	devpriv->command5_bits &= ~CALDAC_LOAD_BIT;
+	comedi_udelay(1);
+	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
+}
+
+#ifdef CONFIG_COMEDI_PCI
+COMEDI_PCI_INITCLEANUP(driver_labpc, labpc_pci_table);
+#else
+COMEDI_INITCLEANUP(driver_labpc);
+#endif
+
+EXPORT_SYMBOL_GPL(labpc_common_attach);
+EXPORT_SYMBOL_GPL(labpc_common_detach);
+EXPORT_SYMBOL_GPL(range_labpc_1200_ai);
+EXPORT_SYMBOL_GPL(labpc_1200_ai_gain_bits);
+EXPORT_SYMBOL_GPL(labpc_1200_is_unipolar);
