commit c833223652cf5ee0440413831d679419b69a1b7b
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Jul 11 11:32:29 2018 +0100

    staging: comedi: remove redundant variable segpos
    
    Variable segpos is being assigned but is never used hence it is redundant
    and can be removed.
    
    Cleans up clang warning:
    warning: variable 'segpos' set but not used [-Wunused-but-set-variable]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index d722079f3327..d87cf6d4a161 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -282,7 +282,7 @@ static int check_channel_list(struct comedi_device *dev,
 			      unsigned int chanlen)
 {
 	unsigned int chansegment[16];
-	unsigned int i, nowmustbechan, seglen, segpos;
+	unsigned int i, nowmustbechan, seglen;
 
 	/*  correct channel and range number check itself comedi/range.c */
 	if (chanlen < 1) {
@@ -312,7 +312,7 @@ static int check_channel_list(struct comedi_device *dev,
 		}
 
 		/*  check whole chanlist */
-		for (i = 0, segpos = 0; i < chanlen; i++) {
+		for (i = 0; i < chanlen; i++) {
 			if (chanlist[i] != chansegment[i % seglen]) {
 				dev_dbg(dev->class_dev,
 					"bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index c00a71f538ef..d722079f3327 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * pcl816.c
  * Comedi driver for Advantech PCL-816 cards

commit 026d7877c89ee23d632181f23b4a37e73fe985b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 15:44:04 2015 -0700

    staging: comedi: pcl816: remove #if 0'ed out code
    
    Remove the #if 0'ed out code that would initialize an analog output
    subdevice.
    
    The hardware does not normally support an analog output subdevice.
    Analog outputs are only supported with additional "piggyback" modules.
    Support for these modules is not included in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index aa775b6aa825..c00a71f538ef 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -86,7 +86,6 @@ static const struct comedi_lrange range_pcl816 = {
 struct pcl816_board {
 	const char *name;
 	int ai_maxdata;
-	int ao_maxdata;
 	int ai_chanlist;
 };
 
@@ -94,12 +93,10 @@ static const struct pcl816_board boardtypes[] = {
 	{
 		.name		= "pcl816",
 		.ai_maxdata	= 0xffff,
-		.ao_maxdata	= 0xffff,
 		.ai_chanlist	= 1024,
 	}, {
 		.name		= "pcl814b",
 		.ai_maxdata	= 0x3fff,
-		.ao_maxdata	= 0x3fff,
 		.ai_chanlist	= 1024,
 	},
 };
@@ -645,16 +642,9 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->cancel	= pcl816_ai_cancel;
 	}
 
-	/* Analog OUtput subdevice */
-	s = &dev->subdevices[2];
+	/* Piggyback Slot1 subdevice */
+	s = &dev->subdevices[1];
 	s->type		= COMEDI_SUBD_UNUSED;
-#if 0
-	subdevs[1] = COMEDI_SUBD_AO;
-	s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
-	s->n_chan = 1;
-	s->maxdata = board->ao_maxdata;
-	s->range_table = &range_pcl816;
-#endif
 
 	/* Digital Input subdevice */
 	s = &dev->subdevices[2];

commit 2d8ea89191c3820bd3c08e75fff2f4d9fbd20f21
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 15:44:03 2015 -0700

    staging: comedi: pcl816: prefer using the BIT macro
    
    Fix the checkpatch.pl issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 0f9b54b3fb00..aa775b6aa825 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -53,25 +53,20 @@
 #define PCL816_MUX_REG				0x0b
 #define PCL816_MUX_SCAN(_first, _last)		(((_last) << 4) | (_first))
 #define PCL816_CTRL_REG				0x0c
-#define PCL816_CTRL_DISABLE_TRIG		(0 << 0)
-#define PCL816_CTRL_SOFT_TRIG			(1 << 0)
-#define PCL816_CTRL_PACER_TRIG			(1 << 1)
-#define PCL816_CTRL_EXT_TRIG			(1 << 2)
-#define PCL816_CTRL_POE				(1 << 3)
-#define PCL816_CTRL_DMAEN			(1 << 4)
-#define PCL816_CTRL_INTEN			(1 << 5)
-#define PCL816_CTRL_DMASRC_SLOT0		(0 << 6)
-#define PCL816_CTRL_DMASRC_SLOT1		(1 << 6)
-#define PCL816_CTRL_DMASRC_SLOT2		(2 << 6)
+#define PCL816_CTRL_SOFT_TRIG			BIT(0)
+#define PCL816_CTRL_PACER_TRIG			BIT(1)
+#define PCL816_CTRL_EXT_TRIG			BIT(2)
+#define PCL816_CTRL_POE				BIT(3)
+#define PCL816_CTRL_DMAEN			BIT(4)
+#define PCL816_CTRL_INTEN			BIT(5)
+#define PCL816_CTRL_DMASRC_SLOT(x)		(((x) & 0x3) << 6)
 #define PCL816_STATUS_REG			0x0d
 #define PCL816_STATUS_NEXT_CHAN_MASK		(0xf << 0)
-#define PCL816_STATUS_INTSRC_MASK		(3 << 4)
-#define PCL816_STATUS_INTSRC_SLOT0		(0 << 4)
-#define PCL816_STATUS_INTSRC_SLOT1		(1 << 4)
-#define PCL816_STATUS_INTSRC_SLOT2		(2 << 4)
-#define PCL816_STATUS_INTSRC_DMA		(3 << 4)
-#define PCL816_STATUS_INTACT			(1 << 6)
-#define PCL816_STATUS_DRDY			(1 << 7)
+#define PCL816_STATUS_INTSRC_SLOT(x)		(((x) & 0x3) << 4)
+#define PCL816_STATUS_INTSRC_DMA		PCL816_STATUS_INTSRC_SLOT(3)
+#define PCL816_STATUS_INTSRC_MASK		PCL816_STATUS_INTSRC_SLOT(3)
+#define PCL816_STATUS_INTACT			BIT(6)
+#define PCL816_STATUS_DRDY			BIT(7)
 
 #define MAGIC_DMA_WORD 0x5a5a
 
@@ -440,7 +435,8 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	comedi_8254_update_divisors(dev->pacer);
 	comedi_8254_pacer_enable(dev->pacer, 1, 2, true);
 
-	ctrl = PCL816_CTRL_INTEN | PCL816_CTRL_DMAEN | PCL816_CTRL_DMASRC_SLOT0;
+	ctrl = PCL816_CTRL_INTEN | PCL816_CTRL_DMAEN |
+	       PCL816_CTRL_DMASRC_SLOT(0);
 	if (cmd->convert_src == TRIG_TIMER)
 		ctrl |= PCL816_CTRL_PACER_TRIG;
 	else	/* TRIG_EXT */
@@ -494,7 +490,7 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 	if (!devpriv->ai_cmd_running)
 		return 0;
 
-	outb(PCL816_CTRL_DISABLE_TRIG, dev->iobase + PCL816_CTRL_REG);
+	outb(0, dev->iobase + PCL816_CTRL_REG);
 	pcl816_ai_clear_eoc(dev);
 
 	comedi_8254_pacer_enable(dev->pacer, 1, 2, false);
@@ -530,7 +526,7 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 
 		data[i] = pcl816_ai_get_sample(dev, s);
 	}
-	outb(PCL816_CTRL_DISABLE_TRIG, dev->iobase + PCL816_CTRL_REG);
+	outb(0, dev->iobase + PCL816_CTRL_REG);
 	pcl816_ai_clear_eoc(dev);
 
 	return ret ? ret : insn->n;
@@ -564,7 +560,7 @@ static int pcl816_do_insn_bits(struct comedi_device *dev,
 
 static void pcl816_reset(struct comedi_device *dev)
 {
-	outb(PCL816_CTRL_DISABLE_TRIG, dev->iobase + PCL816_CTRL_REG);
+	outb(0, dev->iobase + PCL816_CTRL_REG);
 	pcl816_ai_set_chan_range(dev, 0, 0);
 	pcl816_ai_clear_eoc(dev);
 

commit fdb3be16df0b4859a4fb21a02357e2007ffe5dbb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 15:44:02 2015 -0700

    staging: comedi: pcl816: tidy up multi-line comments
    
    Reformat the multi-line comments in the kernel CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index a353d1b155bb..0f9b54b3fb00 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -1,36 +1,33 @@
 /*
-   comedi/drivers/pcl816.c
-
-   Author:  Juan Grigera <juan@grigera.com.ar>
-	    based on pcl818 by Michal Dobes <dobes@tesnet.cz> and bits of pcl812
+ * pcl816.c
+ * Comedi driver for Advantech PCL-816 cards
+ *
+ * Author:  Juan Grigera <juan@grigera.com.ar>
+ * based on pcl818 by Michal Dobes <dobes@tesnet.cz> and bits of pcl812
+ */
 
-   hardware driver for Advantech cards:
-    card:   PCL-816, PCL814B
-    driver: pcl816
-*/
 /*
-Driver: pcl816
-Description: Advantech PCL-816 cards, PCL-814
-Author: Juan Grigera <juan@grigera.com.ar>
-Devices: [Advantech] PCL-816 (pcl816), PCL-814B (pcl814b)
-Status: works
-Updated: Tue,  2 Apr 2002 23:15:21 -0800
-
-PCL 816 and 814B have 16 SE/DIFF ADCs, 16 DACs, 16 DI and 16 DO.
-Differences are at resolution (16 vs 12 bits).
-
-The driver support AI command mode, other subdevices not written.
-
-Analog output and digital input and output are not supported.
-
-Configuration Options:
-  [0] - IO Base
-  [1] - IRQ	(0=disable, 2, 3, 4, 5, 6, 7)
-  [2] - DMA	(0=disable, 1, 3)
-  [3] - 0, 10=10MHz clock for 8254
-	    1= 1MHz clock for 8254
-
-*/
+ * Driver: pcl816
+ * Description: Advantech PCL-816 cards, PCL-814
+ * Devices: [Advantech] PCL-816 (pcl816), PCL-814B (pcl814b)
+ * Author: Juan Grigera <juan@grigera.com.ar>
+ * Status: works
+ * Updated: Tue,  2 Apr 2002 23:15:21 -0800
+ *
+ * PCL 816 and 814B have 16 SE/DIFF ADCs, 16 DACs, 16 DI and 16 DO.
+ * Differences are at resolution (16 vs 12 bits).
+ *
+ * The driver support AI command mode, other subdevices not written.
+ *
+ * Analog output and digital input and output are not supported.
+ *
+ * Configuration Options:
+ *   [0] - IO Base
+ *   [1] - IRQ	(0=disable, 2, 3, 4, 5, 6, 7)
+ *   [2] - DMA	(0=disable, 1, 3)
+ *   [3] - 0, 10=10MHz clock for 8254
+ *	       1= 1MHz clock for 8254
+ */
 
 #include <linux/module.h>
 #include <linux/gfp.h>

commit d258bf054a446c77a9cb7fa31dc4518ba2f1861d
Author: Chandra S Gorentla <csgorentla@gmail.com>
Date:   Mon Jul 20 16:53:15 2015 +0530

    staging: comedi: drivers: pcl816.c remove leading space
    
    Checkpatch.pl warning - suspect code indent for conditional statements -
    is corrected
    
    Signed-off-by: Chandra S Gorentla <csgorentla@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 781b321587dc..a353d1b155bb 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -305,7 +305,7 @@ static int check_channel_list(struct comedi_device *dev,
 		chansegment[0] = chanlist[0];
 		for (i = 1, seglen = 1; i < chanlen; i++, seglen++) {
 			/*  we detect loop, this must by finish */
-			    if (chanlist[0] == chanlist[i])
+			if (chanlist[0] == chanlist[i])
 				break;
 			nowmustbechan =
 			    (CR_CHAN(chansegment[i - 1]) + 1) % chanlen;

commit 8b4e7da516aa52f2b8dcff1939073beacf63788a
Author: Matthew Needes <mneedes@gmail.com>
Date:   Mon May 25 16:41:20 2015 -0700

    staging: comedi/drivers/pcl.* coding style fixes
    
    pcl812.c / pcl816.c (resend of earlier patch)
       Fixed indentation problems.
    
    Signed-off-by: Matthew Needes <mneedes@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 1ccb2f19f4be..781b321587dc 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -323,7 +323,7 @@ static int check_channel_list(struct comedi_device *dev,
 
 		/*  check whole chanlist */
 		for (i = 0, segpos = 0; i < chanlen; i++) {
-			    if (chanlist[i] != chansegment[i % seglen]) {
+			if (chanlist[i] != chansegment[i % seglen]) {
 				dev_dbg(dev->class_dev,
 					"bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
 					i, CR_CHAN(chansegment[i]),

commit 5cf36bd747a631afa78e59518f65368ab3f6708f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:30 2015 +0000

    staging: comedi: pcl816: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 992a38c81d0f..1ccb2f19f4be 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -41,7 +41,6 @@ Configuration Options:
 #include "../comedidev.h"
 
 #include "comedi_isadma.h"
-#include "comedi_fc.h"
 #include "comedi_8254.h"
 
 /*
@@ -350,19 +349,20 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_EXT | TRIG_TIMER);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);
+	err |= comedi_check_trigger_src(&cmd->convert_src,
+					TRIG_EXT | TRIG_TIMER);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -371,20 +371,21 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
 	if (cmd->convert_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg, 10000);
+		err |= comedi_check_trigger_arg_min(&cmd->convert_arg, 10000);
 	else	/* TRIG_EXT */
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -394,7 +395,7 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 		unsigned int arg = cmd->convert_arg;
 
 		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
 	if (err)

commit c8f4b98f47e498a823d1b82b8f3848d81183ea22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:17 2015 -0700

    staging: comedi: drivers/*.c: remove unnecessary blank lines
    
    Blank lines are not needed before a close brace '}' or after an
    open brace '{'. Also remove any multiple blank lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 9cc6933d47da..992a38c81d0f 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -369,7 +369,6 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-
 	/* Step 3: check if arguments are trivially valid */
 
 	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
@@ -390,7 +389,6 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-
 	/* step 4: fix up any arguments */
 	if (cmd->convert_src == TRIG_TIMER) {
 		unsigned int arg = cmd->convert_arg;
@@ -402,7 +400,6 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 4;
 
-
 	/* step 5: complain about special chanlist considerations */
 
 	if (cmd->chanlist) {

commit f48c21fc62addff97c5dbf765a93ba604031dd2d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 14:57:31 2015 -0700

    staging: comedi: pcl816: convert driver to use the comedi_8254 module
    
    This driver uses an 8254 timer to generate the pacer clock used for analog
    input data conversion. Convert it to use the comedi_8254 module to provide
    support for the 8254 timer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index da35edfccbc3..9cc6933d47da 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -42,7 +42,7 @@ Configuration Options:
 
 #include "comedi_isadma.h"
 #include "comedi_fc.h"
-#include "8253.h"
+#include "comedi_8254.h"
 
 /*
  * Register I/O map
@@ -116,31 +116,10 @@ static const struct pcl816_board boardtypes[] = {
 struct pcl816_private {
 	struct comedi_isadma *dma;
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
-	unsigned int divisor1;
-	unsigned int divisor2;
 	unsigned int ai_cmd_running:1;
 	unsigned int ai_cmd_canceled:1;
 };
 
-static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters)
-{
-	struct pcl816_private *devpriv = dev->private;
-	unsigned long timer_base = dev->iobase + PCL816_TIMER_BASE;
-
-	i8254_set_mode(timer_base, 0, 0, I8254_MODE1 | I8254_BINARY);
-	i8254_write(timer_base, 0, 0, 0x00ff);
-	udelay(1);
-
-	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
-	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
-	udelay(1);
-
-	if (load_counters) {
-		i8254_write(timer_base, 0, 2, devpriv->divisor2);
-		i8254_write(timer_base, 0, 1, devpriv->divisor1);
-	}
-}
-
 static void pcl816_ai_setup_dma(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				unsigned int unread_samples)
@@ -367,9 +346,7 @@ static int check_channel_list(struct comedi_device *dev,
 static int pcl816_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	struct pcl816_private *devpriv = dev->private;
 	int err = 0;
-	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -416,11 +393,9 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 
 	/* step 4: fix up any arguments */
 	if (cmd->convert_src == TRIG_TIMER) {
-		arg = cmd->convert_arg;
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-					  &devpriv->divisor1,
-					  &devpriv->divisor2,
-					  &arg, cmd->flags);
+		unsigned int arg = cmd->convert_arg;
+
+		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
@@ -450,8 +425,6 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->ai_cmd_running)
 		return -EBUSY;
 
-	pcl816_start_pacer(dev, false);
-
 	seglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);
 	if (seglen < 1)
 		return -EINVAL;
@@ -466,7 +439,11 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	dma->cur_dma = 0;
 	pcl816_ai_setup_dma(dev, s, 0);
 
-	pcl816_start_pacer(dev, true);
+	comedi_8254_set_mode(dev->pacer, 0, I8254_MODE1 | I8254_BINARY);
+	comedi_8254_write(dev->pacer, 0, 0x0ff);
+	udelay(1);
+	comedi_8254_update_divisors(dev->pacer);
+	comedi_8254_pacer_enable(dev->pacer, 1, 2, true);
 
 	ctrl = PCL816_CTRL_INTEN | PCL816_CTRL_DMAEN | PCL816_CTRL_DMASRC_SLOT0;
 	if (cmd->convert_src == TRIG_TIMER)
@@ -525,11 +502,7 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 	outb(PCL816_CTRL_DISABLE_TRIG, dev->iobase + PCL816_CTRL_REG);
 	pcl816_ai_clear_eoc(dev);
 
-	/* Stop pacer */
-	i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
-			2, I8254_MODE0 | I8254_BINARY);
-	i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
-			1, I8254_MODE0 | I8254_BINARY);
+	comedi_8254_pacer_enable(dev->pacer, 1, 2, false);
 
 	devpriv->ai_cmd_running = 0;
 	devpriv->ai_cmd_canceled = 1;
@@ -596,17 +569,10 @@ static int pcl816_do_insn_bits(struct comedi_device *dev,
 
 static void pcl816_reset(struct comedi_device *dev)
 {
-	unsigned long timer_base = dev->iobase + PCL816_TIMER_BASE;
-
 	outb(PCL816_CTRL_DISABLE_TRIG, dev->iobase + PCL816_CTRL_REG);
 	pcl816_ai_set_chan_range(dev, 0, 0);
 	pcl816_ai_clear_eoc(dev);
 
-	/* Stop pacer */
-	i8254_set_mode(timer_base, 0, 2, I8254_MODE0 | I8254_BINARY);
-	i8254_set_mode(timer_base, 0, 1, I8254_MODE0 | I8254_BINARY);
-	i8254_set_mode(timer_base, 0, 0, I8254_MODE0 | I8254_BINARY);
-
 	/* set all digital outputs low */
 	outb(0, dev->iobase + PCL816_DO_DI_LSB_REG);
 	outb(0, dev->iobase + PCL816_DO_DI_MSB_REG);
@@ -662,6 +628,11 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* an IRQ and DMA are required to support async commands */
 	pcl816_alloc_irq_and_dma(dev, it);
 
+	dev->pacer = comedi_8254_init(dev->iobase + PCL816_TIMER_BASE,
+				      I8254_OSC_BASE_10MHZ, I8254_IO8, 0);
+	if (!dev->pacer)
+		return -ENOMEM;
+
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
 		return ret;

commit 93e604523619d32a88e0afbdfef65ec83582c209
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 14 10:05:14 2015 -0700

    staging: comedi: pcl816: use common function to setup dma
    
    THe pcl816_ai_setup_dma() and pcl816_ai_setup_next_dma() functions are similar
    other than the buffer switch and the inclusion of the "unread_samples" in
    pcl818_ai_setup_next_dma() when calculating the dma size.
    
    Merge these two functions by initializing the 'dma->cur_dma' in the callers
    and passing '0' for the "unread_samples" when first starting the DMA.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 88c89df717e5..da35edfccbc3 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -142,47 +142,22 @@ static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters)
 }
 
 static void pcl816_ai_setup_dma(struct comedi_device *dev,
-				struct comedi_subdevice *s)
-{
-	struct pcl816_private *devpriv = dev->private;
-	struct comedi_isadma *dma = devpriv->dma;
-	struct comedi_isadma_desc *desc = &dma->desc[0];
-	unsigned int nsamples;
-
-	dma->cur_dma = 0;
-
-	/*
-	 * Determine dma size based on the buffer maxsize and the number of
-	 * samples remaining in the command.
-	 */
-	nsamples = comedi_bytes_to_samples(s, desc->maxsize);
-	nsamples = comedi_nsamples_left(s, nsamples);
-	desc->size = comedi_samples_to_bytes(s, nsamples);
-	comedi_isadma_program(desc);
-}
-
-static void pcl816_ai_setup_next_dma(struct comedi_device *dev,
-				     struct comedi_subdevice *s,
-				     unsigned int unread_samples)
+				struct comedi_subdevice *s,
+				unsigned int unread_samples)
 {
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_isadma *dma = devpriv->dma;
-	struct comedi_isadma_desc *desc;
-	unsigned int max_samples;
+	struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
+	unsigned int max_samples = comedi_bytes_to_samples(s, desc->maxsize);
 	unsigned int nsamples;
 
 	comedi_isadma_disable(dma->chan);
 
-	dma->cur_dma = 1 - dma->cur_dma;
-	desc = &dma->desc[dma->cur_dma];
-
 	/*
 	 * Determine dma size based on the buffer maxsize plus the number of
 	 * unread samples and the number of samples remaining in the command.
 	 */
-	max_samples = comedi_bytes_to_samples(s, desc->maxsize);
-	nsamples = max_samples + unread_samples;
-	nsamples = comedi_nsamples_left(s, nsamples);
+	nsamples = comedi_nsamples_left(s, max_samples + unread_samples);
 	if (nsamples > unread_samples) {
 		nsamples -= unread_samples;
 		desc->size = comedi_samples_to_bytes(s, nsamples);
@@ -321,7 +296,9 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 	bufptr = devpriv->ai_poll_ptr;
 	devpriv->ai_poll_ptr = 0;
 
-	pcl816_ai_setup_next_dma(dev, s, nsamples);
+	/* restart dma with the next buffer */
+	dma->cur_dma = 1 - dma->cur_dma;
+	pcl816_ai_setup_dma(dev, s, nsamples);
 
 	transfer_from_dma_buf(dev, s, desc->virt_addr, bufptr, nsamples);
 
@@ -485,7 +462,9 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_poll_ptr = 0;
 	devpriv->ai_cmd_canceled = 0;
 
-	pcl816_ai_setup_dma(dev, s);
+	/* setup and enable dma for the first buffer */
+	dma->cur_dma = 0;
+	pcl816_ai_setup_dma(dev, s, 0);
 
 	pcl816_start_pacer(dev, true);
 

commit fe4a22a009982442ba8b37f4f499f708d956d16d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 14 10:05:13 2015 -0700

    staging: comedi: pcl816: simplify the dma->size calculations
    
    Currently this driver determines the number of DMA "runs" needed and the size
    of the "last" DMA transfer in order to perform a command. As long as there are
    more "runs" required, the dma->size is set to the buffer maxsize. On the last
    "run" the buffer is set to the "last" size.
    
    Refactor the driver to use the comedi core helpers to determine the DMA size
    based on the buffer maxsize and the number of samples remaining in the command.
    
    This allows removing the 'dma_runs_to_end' and 'last_dma_run' mamebers from
    the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 09fa40904daa..88c89df717e5 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -115,8 +115,6 @@ static const struct pcl816_board boardtypes[] = {
 
 struct pcl816_private {
 	struct comedi_isadma *dma;
-	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
-	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
 	unsigned int divisor1;
 	unsigned int divisor2;
@@ -149,53 +147,47 @@ static void pcl816_ai_setup_dma(struct comedi_device *dev,
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_isadma *dma = devpriv->dma;
 	struct comedi_isadma_desc *desc = &dma->desc[0];
-	struct comedi_cmd *cmd = &s->async->cmd;
-
-	if (cmd->stop_src == TRIG_COUNT) {
-		/*  how many */
-		desc->size = cmd->stop_arg * comedi_bytes_per_scan(s);
-
-		/*  how many DMA pages we must fill */
-		devpriv->dma_runs_to_end = desc->size / desc->maxsize;
-
-		/* on last dma transfer must be moved */
-		devpriv->last_dma_run = desc->size % desc->maxsize;
-		devpriv->dma_runs_to_end--;
-		if (devpriv->dma_runs_to_end >= 0)
-			desc->size = desc->maxsize;
-	} else {
-		desc->size = desc->maxsize;
-		devpriv->dma_runs_to_end = -1;
-	}
+	unsigned int nsamples;
 
 	dma->cur_dma = 0;
 
+	/*
+	 * Determine dma size based on the buffer maxsize and the number of
+	 * samples remaining in the command.
+	 */
+	nsamples = comedi_bytes_to_samples(s, desc->maxsize);
+	nsamples = comedi_nsamples_left(s, nsamples);
+	desc->size = comedi_samples_to_bytes(s, nsamples);
 	comedi_isadma_program(desc);
 }
 
 static void pcl816_ai_setup_next_dma(struct comedi_device *dev,
-				     struct comedi_subdevice *s)
+				     struct comedi_subdevice *s,
+				     unsigned int unread_samples)
 {
 	struct pcl816_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
 	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc;
+	unsigned int max_samples;
+	unsigned int nsamples;
 
 	comedi_isadma_disable(dma->chan);
-	dma->cur_dma = 1 - dma->cur_dma;
-
-	/* switch dma bufs if still running */
-	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
-		struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
-
-		if (devpriv->dma_runs_to_end)
-			desc->size = desc->maxsize;
-		else
-			desc->size = devpriv->last_dma_run;
 
+	dma->cur_dma = 1 - dma->cur_dma;
+	desc = &dma->desc[dma->cur_dma];
+
+	/*
+	 * Determine dma size based on the buffer maxsize plus the number of
+	 * unread samples and the number of samples remaining in the command.
+	 */
+	max_samples = comedi_bytes_to_samples(s, desc->maxsize);
+	nsamples = max_samples + unread_samples;
+	nsamples = comedi_nsamples_left(s, nsamples);
+	if (nsamples > unread_samples) {
+		nsamples -= unread_samples;
+		desc->size = comedi_samples_to_bytes(s, nsamples);
 		comedi_isadma_program(desc);
 	}
-
-	devpriv->dma_runs_to_end--;
 }
 
 static void pcl816_ai_set_chan_range(struct comedi_device *dev,
@@ -324,13 +316,13 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	pcl816_ai_setup_next_dma(dev, s);
-
 	nsamples = comedi_bytes_to_samples(s, desc->size) -
 		   devpriv->ai_poll_ptr;
 	bufptr = devpriv->ai_poll_ptr;
 	devpriv->ai_poll_ptr = 0;
 
+	pcl816_ai_setup_next_dma(dev, s, nsamples);
+
 	transfer_from_dma_buf(dev, s, desc->virt_addr, bufptr, nsamples);
 
 	pcl816_ai_clear_eoc(dev);

commit bd7ea421e3f9750deecdf78af94c8191ef05788d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 14 10:05:04 2015 -0700

    staging: comedi: pcl816: remove depends on ISA_DMA_API limitation
    
    Use the new comedi_isadma module to provide the ISA DMA support. This removes
    all the ISA_DMA_API code from this driver and allows the driver to be used on
    platforms that don't support the ISA_DMA_API.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index d2ce7751df93..09fa40904daa 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -33,14 +33,14 @@ Configuration Options:
 */
 
 #include <linux/module.h>
-#include "../comedidev.h"
-
 #include <linux/gfp.h>
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/interrupt.h>
-#include <asm/dma.h>
 
+#include "../comedidev.h"
+
+#include "comedi_isadma.h"
 #include "comedi_fc.h"
 #include "8253.h"
 
@@ -113,17 +113,8 @@ static const struct pcl816_board boardtypes[] = {
 	},
 };
 
-struct pcl816_dma_desc {
-	void *virt_addr;	/* virtual address of DMA buffer */
-	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
-	unsigned int size;	/* transfer size (in bytes) */
-};
-
 struct pcl816_private {
-	unsigned int dma;	/*  used DMA, 0=don't use DMA */
-	unsigned int hwdmasize;
-	struct pcl816_dma_desc dma_desc[2];
-	int cur_dma;
+	struct comedi_isadma *dma;
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
@@ -133,29 +124,6 @@ struct pcl816_private {
 	unsigned int ai_cmd_canceled:1;
 };
 
-static void pcl816_isadma_program(unsigned int dma_chan,
-				  struct pcl816_dma_desc *dma)
-{
-	unsigned long flags;
-
-	flags = claim_dma_lock();
-	clear_dma_ff(dma_chan);
-	set_dma_mode(dma_chan, DMA_MODE_READ);
-	set_dma_addr(dma_chan, dma->hw_addr);
-	set_dma_count(dma_chan, dma->size);
-	enable_dma(dma_chan);
-	release_dma_lock(flags);
-}
-
-static void pcl816_isadma_disable(unsigned int dma_chan)
-{
-	unsigned long flags;
-
-	flags = claim_dma_lock();
-	disable_dma(dma_chan);
-	release_dma_lock(flags);
-}
-
 static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters)
 {
 	struct pcl816_private *devpriv = dev->private;
@@ -179,29 +147,30 @@ static void pcl816_ai_setup_dma(struct comedi_device *dev,
 				struct comedi_subdevice *s)
 {
 	struct pcl816_private *devpriv = dev->private;
-	struct pcl816_dma_desc *dma = &devpriv->dma_desc[0];
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[0];
 	struct comedi_cmd *cmd = &s->async->cmd;
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		/*  how many */
-		dma->size = cmd->stop_arg * comedi_bytes_per_scan(s);
+		desc->size = cmd->stop_arg * comedi_bytes_per_scan(s);
 
 		/*  how many DMA pages we must fill */
-		devpriv->dma_runs_to_end = dma->size / devpriv->hwdmasize;
+		devpriv->dma_runs_to_end = desc->size / desc->maxsize;
 
 		/* on last dma transfer must be moved */
-		devpriv->last_dma_run = dma->size % devpriv->hwdmasize;
+		devpriv->last_dma_run = desc->size % desc->maxsize;
 		devpriv->dma_runs_to_end--;
 		if (devpriv->dma_runs_to_end >= 0)
-			dma->size = devpriv->hwdmasize;
+			desc->size = desc->maxsize;
 	} else {
-		dma->size = devpriv->hwdmasize;
+		desc->size = desc->maxsize;
 		devpriv->dma_runs_to_end = -1;
 	}
 
-	devpriv->cur_dma = 0;
+	dma->cur_dma = 0;
 
-	pcl816_isadma_program(devpriv->dma, dma);
+	comedi_isadma_program(desc);
 }
 
 static void pcl816_ai_setup_next_dma(struct comedi_device *dev,
@@ -209,19 +178,21 @@ static void pcl816_ai_setup_next_dma(struct comedi_device *dev,
 {
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	struct pcl816_dma_desc *dma;
+	struct comedi_isadma *dma = devpriv->dma;
+
+	comedi_isadma_disable(dma->chan);
+	dma->cur_dma = 1 - dma->cur_dma;
 
-	pcl816_isadma_disable(devpriv->dma);
+	/* switch dma bufs if still running */
 	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
-		/* switch dma bufs */
-		devpriv->cur_dma = 1 - devpriv->cur_dma;
-		dma = &devpriv->dma_desc[devpriv->cur_dma];
+		struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
+
 		if (devpriv->dma_runs_to_end)
-			dma->size = devpriv->hwdmasize;
+			desc->size = desc->maxsize;
 		else
-			dma->size = devpriv->last_dma_run;
+			desc->size = devpriv->last_dma_run;
 
-		pcl816_isadma_program(devpriv->dma, dma);
+		comedi_isadma_program(desc);
 	}
 
 	devpriv->dma_runs_to_end--;
@@ -337,7 +308,8 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct pcl816_private *devpriv = dev->private;
-	struct pcl816_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
 	unsigned int nsamples;
 	unsigned int bufptr;
 
@@ -354,11 +326,12 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 
 	pcl816_ai_setup_next_dma(dev, s);
 
-	nsamples = comedi_bytes_to_samples(s, dma->size) - devpriv->ai_poll_ptr;
+	nsamples = comedi_bytes_to_samples(s, desc->size) -
+		   devpriv->ai_poll_ptr;
 	bufptr = devpriv->ai_poll_ptr;
 	devpriv->ai_poll_ptr = 0;
 
-	transfer_from_dma_buf(dev, s, dma->virt_addr, bufptr, nsamples);
+	transfer_from_dma_buf(dev, s, desc->virt_addr, bufptr, nsamples);
 
 	pcl816_ai_clear_eoc(dev);
 
@@ -500,6 +473,7 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pcl816_private *devpriv = dev->private;
+	struct comedi_isadma *dma = devpriv->dma;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int ctrl;
 	unsigned int seglen;
@@ -530,7 +504,8 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		ctrl |= PCL816_CTRL_EXT_TRIG;
 
 	outb(ctrl, dev->iobase + PCL816_CTRL_REG);
-	outb((devpriv->dma << 4) | dev->irq, dev->iobase + PCL816_STATUS_REG);
+	outb((dma->chan << 4) | dev->irq,
+	     dev->iobase + PCL816_STATUS_REG);
 
 	return 0;
 }
@@ -538,41 +513,34 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pcl816_private *devpriv = dev->private;
-	struct pcl816_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc;
 	unsigned long flags;
-	unsigned int top1, top2, i;
+	unsigned int poll;
+	int ret;
 
 	spin_lock_irqsave(&dev->spinlock, flags);
 
-	for (i = 0; i < 20; i++) {
-		top1 = get_dma_residue(devpriv->dma);	/*  where is now DMA */
-		top2 = get_dma_residue(devpriv->dma);
-		if (top1 == top2)
-			break;
-	}
-	if (top1 != top2) {
-		spin_unlock_irqrestore(&dev->spinlock, flags);
-		return 0;
-	}
-
-	/*  where is now DMA in buffer */
-	top1 = dma->size - top1;
-	top1 >>= 1;		/*  sample position */
-	top2 = top1 - devpriv->ai_poll_ptr;
-	if (top2 < 1) {		/*  no new samples */
-		spin_unlock_irqrestore(&dev->spinlock, flags);
-		return 0;
-	}
+	poll = comedi_isadma_poll(dma);
+	poll = comedi_bytes_to_samples(s, poll);
+	if (poll > devpriv->ai_poll_ptr) {
+		desc = &dma->desc[dma->cur_dma];
+		transfer_from_dma_buf(dev, s, desc->virt_addr,
+				      devpriv->ai_poll_ptr,
+				      poll - devpriv->ai_poll_ptr);
+		/* new buffer position */
+		devpriv->ai_poll_ptr = poll;
 
-	transfer_from_dma_buf(dev, s, dma->virt_addr,
-			      devpriv->ai_poll_ptr, top2);
+		comedi_handle_events(dev, s);
 
-	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
+		ret = comedi_buf_n_bytes_ready(s);
+	} else {
+		/* no new samples */
+		ret = 0;
+	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	comedi_handle_events(dev, s);
-
-	return comedi_buf_n_bytes_ready(s);
+	return ret;
 }
 
 static int pcl816_ai_cancel(struct comedi_device *dev,
@@ -673,68 +641,36 @@ static void pcl816_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + PCL816_DO_DI_MSB_REG);
 }
 
-static int pcl816_alloc_dma(struct comedi_device *dev,
-			    unsigned int irq_num, unsigned int dma_chan)
+static void pcl816_alloc_irq_and_dma(struct comedi_device *dev,
+				     struct comedi_devconfig *it)
 {
 	struct pcl816_private *devpriv = dev->private;
-	struct pcl816_dma_desc *dma;
-	int i;
+	unsigned int irq_num = it->options[1];
+	unsigned int dma_chan = it->options[2];
 
-	/*
-	 * Only IRQs 2-7 are valid.
-	 * Only DMA channels 3 and 1 are valid.
-	 *
-	 * Both must be valid for async command support.
-	 */
+	/* only IRQs 2-7 and DMA channels 3 and 1 are valid */
 	if (!(irq_num >= 2 && irq_num <= 7) ||
 	    !(dma_chan == 3 || dma_chan == 1))
-		return 0;
+		return;
 
-	/*
-	 * Request the IRQ and DMA channels and allocate the DMA buffers.
-	 * If the requests or allocations fail async command supprt will
-	 * not be available.
-	 */
 	if (request_irq(irq_num, pcl816_interrupt, 0, dev->board_name, dev))
-		return 0;
-	if (request_dma(dma_chan, dev->board_name)) {
-		free_irq(irq_num, dev);
-		return 0;
-	}
-
-	dev->irq = irq_num;
-	devpriv->dma = dma_chan;
-
-	devpriv->hwdmasize = PAGE_SIZE * 4;	/* we need 16KB */
-
-	for (i = 0; i < 2; i++) {
-		dma = &devpriv->dma_desc[i];
+		return;
 
-		dma->virt_addr = dma_alloc_coherent(NULL, devpriv->hwdmasize,
-						    &dma->hw_addr, GFP_KERNEL);
-		if (!dma->virt_addr)
-			return -ENOMEM;
-	}
-	return 0;
+	/* DMA uses two 16K buffers */
+	devpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan, dma_chan,
+					   PAGE_SIZE * 4, COMEDI_ISADMA_READ);
+	if (!devpriv->dma)
+		free_irq(irq_num, dev);
+	else
+		dev->irq = irq_num;
 }
 
 static void pcl816_free_dma(struct comedi_device *dev)
 {
 	struct pcl816_private *devpriv = dev->private;
-	struct pcl816_dma_desc *dma;
-	int i;
 
-	if (!devpriv)
-		return;
-
-	if (devpriv->dma)
-		free_dma(devpriv->dma);
-	for (i = 0; i < 2; i++) {
-		dma = &devpriv->dma_desc[i];
-		if (dma->virt_addr)
-			dma_free_coherent(NULL, devpriv->hwdmasize,
-					  dma->virt_addr, dma->hw_addr);
-	}
+	if (devpriv)
+		comedi_isadma_free(devpriv->dma);
 }
 
 static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -752,14 +688,8 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	/*
-	 * An IRQ and DMA are required to support async commands.
-	 * pcl816_alloc_dma() will only fail if the DMA buffers
-	 * cannot be allocated.
-	 */
-	ret = pcl816_alloc_dma(dev, it->options[1], it->options[2]);
-	if (ret)
-		return ret;
+	/* an IRQ and DMA are required to support async commands */
+	pcl816_alloc_irq_and_dma(dev, it);
 
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)

commit 65fdfedbc06169bc49fbbdab205659237a06568c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:23 2015 -0700

    staging: comedi: pcl816: introduce pcl816_isadma_disable()
    
    According to Documentation/DMA-ISA-LPC.txt, the DMA lock needs to be
    claimed before using any of the ISA DMA routines. Introduce a helper
    function to disable the ISA DMA controller and add the necessary
    locking calls.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index e0d91a18ec64..d2ce7751df93 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -147,6 +147,15 @@ static void pcl816_isadma_program(unsigned int dma_chan,
 	release_dma_lock(flags);
 }
 
+static void pcl816_isadma_disable(unsigned int dma_chan)
+{
+	unsigned long flags;
+
+	flags = claim_dma_lock();
+	disable_dma(dma_chan);
+	release_dma_lock(flags);
+}
+
 static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters)
 {
 	struct pcl816_private *devpriv = dev->private;
@@ -202,7 +211,7 @@ static void pcl816_ai_setup_next_dma(struct comedi_device *dev,
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct pcl816_dma_desc *dma;
 
-	disable_dma(devpriv->dma);
+	pcl816_isadma_disable(devpriv->dma);
 	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
 		/* switch dma bufs */
 		devpriv->cur_dma = 1 - devpriv->cur_dma;

commit d77bf9736b11671f803e830c5bead436a415d040
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:22 2015 -0700

    staging: comedi: pcl816: introduce pcl816_isadma_program()
    
    Introduce a helper function to program the ISA DMA controller. Program
    the ISA DMA as described in Documentation/DMA-ISA-LPC.txt.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index f880cb994074..e0d91a18ec64 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -133,6 +133,20 @@ struct pcl816_private {
 	unsigned int ai_cmd_canceled:1;
 };
 
+static void pcl816_isadma_program(unsigned int dma_chan,
+				  struct pcl816_dma_desc *dma)
+{
+	unsigned long flags;
+
+	flags = claim_dma_lock();
+	clear_dma_ff(dma_chan);
+	set_dma_mode(dma_chan, DMA_MODE_READ);
+	set_dma_addr(dma_chan, dma->hw_addr);
+	set_dma_count(dma_chan, dma->size);
+	enable_dma(dma_chan);
+	release_dma_lock(flags);
+}
+
 static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters)
 {
 	struct pcl816_private *devpriv = dev->private;
@@ -158,7 +172,6 @@ static void pcl816_ai_setup_dma(struct comedi_device *dev,
 	struct pcl816_private *devpriv = dev->private;
 	struct pcl816_dma_desc *dma = &devpriv->dma_desc[0];
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int dma_flags;
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		/*  how many */
@@ -178,13 +191,8 @@ static void pcl816_ai_setup_dma(struct comedi_device *dev,
 	}
 
 	devpriv->cur_dma = 0;
-	set_dma_mode(devpriv->dma, DMA_MODE_READ);
-	dma_flags = claim_dma_lock();
-	clear_dma_ff(devpriv->dma);
-	set_dma_addr(devpriv->dma, dma->hw_addr);
-	set_dma_count(devpriv->dma, dma->size);
-	release_dma_lock(dma_flags);
-	enable_dma(devpriv->dma);
+
+	pcl816_isadma_program(devpriv->dma, dma);
 }
 
 static void pcl816_ai_setup_next_dma(struct comedi_device *dev,
@@ -193,7 +201,6 @@ static void pcl816_ai_setup_next_dma(struct comedi_device *dev,
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct pcl816_dma_desc *dma;
-	unsigned long dma_flags;
 
 	disable_dma(devpriv->dma);
 	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
@@ -204,12 +211,8 @@ static void pcl816_ai_setup_next_dma(struct comedi_device *dev,
 			dma->size = devpriv->hwdmasize;
 		else
 			dma->size = devpriv->last_dma_run;
-		set_dma_mode(devpriv->dma, DMA_MODE_READ);
-		dma_flags = claim_dma_lock();
-		set_dma_addr(devpriv->dma, dma->hw_addr);
-		set_dma_count(devpriv->dma, dma->size);
-		release_dma_lock(dma_flags);
-		enable_dma(devpriv->dma);
+
+		pcl816_isadma_program(devpriv->dma, dma);
 	}
 
 	devpriv->dma_runs_to_end--;

commit ceb41be712b68fac4ac834120a80fc3cb8e5ac37
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:56:04 2015 -0700

    staging: comedi: pcl816: fix short DMA transactions
    
    When the cmd->stop_src == TRIG_COUNT the last DMA transfer might be smaller
    than the buffer size. This results in invalid data being added to the async
    buffer.
    
    Add a 'size' member to the DMA descriptor and initialize it with the
    actual size of the DMA transfer. Use that in interrupt and ai subdevice
    (*poll) function to return the proper number of samples. Use the
    comedi_bytes_to_samples() helper to convert the byte size to comedi
    samples in the interrupt handler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 1b760858c72a..f880cb994074 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -116,6 +116,7 @@ static const struct pcl816_board boardtypes[] = {
 struct pcl816_dma_desc {
 	void *virt_addr;	/* virtual address of DMA buffer */
 	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
+	unsigned int size;	/* transfer size (in bytes) */
 };
 
 struct pcl816_private {
@@ -158,30 +159,30 @@ static void pcl816_ai_setup_dma(struct comedi_device *dev,
 	struct pcl816_dma_desc *dma = &devpriv->dma_desc[0];
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int dma_flags;
-	unsigned int bytes;
 
-	bytes = devpriv->hwdmasize;
 	if (cmd->stop_src == TRIG_COUNT) {
 		/*  how many */
-		bytes = cmd->stop_arg * comedi_bytes_per_scan(s);
+		dma->size = cmd->stop_arg * comedi_bytes_per_scan(s);
 
 		/*  how many DMA pages we must fill */
-		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;
+		devpriv->dma_runs_to_end = dma->size / devpriv->hwdmasize;
 
 		/* on last dma transfer must be moved */
-		devpriv->last_dma_run = bytes % devpriv->hwdmasize;
+		devpriv->last_dma_run = dma->size % devpriv->hwdmasize;
 		devpriv->dma_runs_to_end--;
 		if (devpriv->dma_runs_to_end >= 0)
-			bytes = devpriv->hwdmasize;
-	} else
+			dma->size = devpriv->hwdmasize;
+	} else {
+		dma->size = devpriv->hwdmasize;
 		devpriv->dma_runs_to_end = -1;
+	}
 
 	devpriv->cur_dma = 0;
 	set_dma_mode(devpriv->dma, DMA_MODE_READ);
 	dma_flags = claim_dma_lock();
 	clear_dma_ff(devpriv->dma);
 	set_dma_addr(devpriv->dma, dma->hw_addr);
-	set_dma_count(devpriv->dma, bytes);
+	set_dma_count(devpriv->dma, dma->size);
 	release_dma_lock(dma_flags);
 	enable_dma(devpriv->dma);
 }
@@ -199,13 +200,14 @@ static void pcl816_ai_setup_next_dma(struct comedi_device *dev,
 		/* switch dma bufs */
 		devpriv->cur_dma = 1 - devpriv->cur_dma;
 		dma = &devpriv->dma_desc[devpriv->cur_dma];
+		if (devpriv->dma_runs_to_end)
+			dma->size = devpriv->hwdmasize;
+		else
+			dma->size = devpriv->last_dma_run;
 		set_dma_mode(devpriv->dma, DMA_MODE_READ);
 		dma_flags = claim_dma_lock();
 		set_dma_addr(devpriv->dma, dma->hw_addr);
-		if (devpriv->dma_runs_to_end)
-			set_dma_count(devpriv->dma, devpriv->hwdmasize);
-		else
-			set_dma_count(devpriv->dma, devpriv->last_dma_run);
+		set_dma_count(devpriv->dma, dma->size);
 		release_dma_lock(dma_flags);
 		enable_dma(devpriv->dma);
 	}
@@ -324,8 +326,8 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct pcl816_private *devpriv = dev->private;
 	struct pcl816_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
+	unsigned int nsamples;
 	unsigned int bufptr;
-	unsigned int len;
 
 	if (!dev->attached || !devpriv->ai_cmd_running) {
 		pcl816_ai_clear_eoc(dev);
@@ -340,11 +342,11 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 
 	pcl816_ai_setup_next_dma(dev, s);
 
-	len = (devpriv->hwdmasize >> 1) - devpriv->ai_poll_ptr;
+	nsamples = comedi_bytes_to_samples(s, dma->size) - devpriv->ai_poll_ptr;
 	bufptr = devpriv->ai_poll_ptr;
 	devpriv->ai_poll_ptr = 0;
 
-	transfer_from_dma_buf(dev, s, dma->virt_addr, bufptr, len);
+	transfer_from_dma_buf(dev, s, dma->virt_addr, bufptr, nsamples);
 
 	pcl816_ai_clear_eoc(dev);
 
@@ -542,7 +544,7 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/*  where is now DMA in buffer */
-	top1 = devpriv->hwdmasize - top1;
+	top1 = dma->size - top1;
 	top1 >>= 1;		/*  sample position */
 	top2 = top1 - devpriv->ai_poll_ptr;
 	if (top2 < 1) {		/*  no new samples */

commit a2c3966d18a93540f49c2c8cc3dda5ce6c9399a7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:56:03 2015 -0700

    staging: comedi: pcl816: remove VIRT_TO_BUS dependancy
    
    Use dma_{alloc,free}_coherent() to allocate and free the DMA buffers.
    This removes the dependancy on VIRT_TO_BUS.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 49c1f170f082..1b760858c72a 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -114,13 +114,12 @@ static const struct pcl816_board boardtypes[] = {
 };
 
 struct pcl816_dma_desc {
-	unsigned long virt_addr;	/* virtual address of DMA buffer */
-	unsigned int hw_addr;	/* hardware (bus) address of DMA buffer */
+	void *virt_addr;	/* virtual address of DMA buffer */
+	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
 };
 
 struct pcl816_private {
 	unsigned int dma;	/*  used DMA, 0=don't use DMA */
-	unsigned int dmapages;
 	unsigned int hwdmasize;
 	struct pcl816_dma_desc dma_desc[2];
 	int cur_dma;
@@ -345,8 +344,7 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 	bufptr = devpriv->ai_poll_ptr;
 	devpriv->ai_poll_ptr = 0;
 
-	transfer_from_dma_buf(dev, s, (unsigned short *)dma->virt_addr,
-			      bufptr, len);
+	transfer_from_dma_buf(dev, s, dma->virt_addr, bufptr, len);
 
 	pcl816_ai_clear_eoc(dev);
 
@@ -552,7 +550,7 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 		return 0;
 	}
 
-	transfer_from_dma_buf(dev, s, (unsigned short *)dma->virt_addr,
+	transfer_from_dma_buf(dev, s, dma->virt_addr,
 			      devpriv->ai_poll_ptr, top2);
 
 	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
@@ -693,16 +691,15 @@ static int pcl816_alloc_dma(struct comedi_device *dev,
 	dev->irq = irq_num;
 	devpriv->dma = dma_chan;
 
-	devpriv->dmapages = 2;	/* we need 16KB */
-	devpriv->hwdmasize = (1 << devpriv->dmapages) * PAGE_SIZE;
+	devpriv->hwdmasize = PAGE_SIZE * 4;	/* we need 16KB */
 
 	for (i = 0; i < 2; i++) {
 		dma = &devpriv->dma_desc[i];
 
-		dma->virt_addr = __get_dma_pages(GFP_KERNEL, devpriv->dmapages);
+		dma->virt_addr = dma_alloc_coherent(NULL, devpriv->hwdmasize,
+						    &dma->hw_addr, GFP_KERNEL);
 		if (!dma->virt_addr)
 			return -ENOMEM;
-		dma->hw_addr = virt_to_bus((void *)dma->virt_addr);
 	}
 	return 0;
 }
@@ -721,7 +718,8 @@ static void pcl816_free_dma(struct comedi_device *dev)
 	for (i = 0; i < 2; i++) {
 		dma = &devpriv->dma_desc[i];
 		if (dma->virt_addr)
-			free_pages(dma->virt_addr, devpriv->dmapages);
+			dma_free_coherent(NULL, devpriv->hwdmasize,
+					  dma->virt_addr, dma->hw_addr);
 	}
 }
 

commit 16d87782c560fac81627ddc9368b4f7100a1c2f7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:56:02 2015 -0700

    staging: comedi: pcl816: introduce struct pcl816_dma_desc
    
    For aesthetics, introduce a struct to hold the DMA descriptor data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 4cff02a1f720..49c1f170f082 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -113,13 +113,17 @@ static const struct pcl816_board boardtypes[] = {
 	},
 };
 
+struct pcl816_dma_desc {
+	unsigned long virt_addr;	/* virtual address of DMA buffer */
+	unsigned int hw_addr;	/* hardware (bus) address of DMA buffer */
+};
+
 struct pcl816_private {
 	unsigned int dma;	/*  used DMA, 0=don't use DMA */
 	unsigned int dmapages;
 	unsigned int hwdmasize;
-	unsigned long dmabuf[2];	/*  pointers to begin of DMA buffers */
-	unsigned int hwdmaptr[2];	/*  hardware address of DMA buffers */
-	int next_dma_buf;	/*  which DMA buffer will be used next round */
+	struct pcl816_dma_desc dma_desc[2];
+	int cur_dma;
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
@@ -152,6 +156,7 @@ static void pcl816_ai_setup_dma(struct comedi_device *dev,
 				struct comedi_subdevice *s)
 {
 	struct pcl816_private *devpriv = dev->private;
+	struct pcl816_dma_desc *dma = &devpriv->dma_desc[0];
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int dma_flags;
 	unsigned int bytes;
@@ -172,11 +177,11 @@ static void pcl816_ai_setup_dma(struct comedi_device *dev,
 	} else
 		devpriv->dma_runs_to_end = -1;
 
-	devpriv->next_dma_buf = 0;
+	devpriv->cur_dma = 0;
 	set_dma_mode(devpriv->dma, DMA_MODE_READ);
 	dma_flags = claim_dma_lock();
 	clear_dma_ff(devpriv->dma);
-	set_dma_addr(devpriv->dma, devpriv->hwdmaptr[0]);
+	set_dma_addr(devpriv->dma, dma->hw_addr);
 	set_dma_count(devpriv->dma, bytes);
 	release_dma_lock(dma_flags);
 	enable_dma(devpriv->dma);
@@ -187,16 +192,17 @@ static void pcl816_ai_setup_next_dma(struct comedi_device *dev,
 {
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
+	struct pcl816_dma_desc *dma;
 	unsigned long dma_flags;
 
 	disable_dma(devpriv->dma);
 	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
 		/* switch dma bufs */
-		devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
+		devpriv->cur_dma = 1 - devpriv->cur_dma;
+		dma = &devpriv->dma_desc[devpriv->cur_dma];
 		set_dma_mode(devpriv->dma, DMA_MODE_READ);
 		dma_flags = claim_dma_lock();
-		set_dma_addr(devpriv->dma,
-			     devpriv->hwdmaptr[devpriv->next_dma_buf]);
+		set_dma_addr(devpriv->dma, dma->hw_addr);
 		if (devpriv->dma_runs_to_end)
 			set_dma_count(devpriv->dma, devpriv->hwdmasize);
 		else
@@ -318,7 +324,7 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct pcl816_private *devpriv = dev->private;
-	unsigned short *ptr;
+	struct pcl816_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
 	unsigned int bufptr;
 	unsigned int len;
 
@@ -333,15 +339,14 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	ptr = (unsigned short *)devpriv->dmabuf[devpriv->next_dma_buf];
-
 	pcl816_ai_setup_next_dma(dev, s);
 
 	len = (devpriv->hwdmasize >> 1) - devpriv->ai_poll_ptr;
 	bufptr = devpriv->ai_poll_ptr;
 	devpriv->ai_poll_ptr = 0;
 
-	transfer_from_dma_buf(dev, s, ptr, bufptr, len);
+	transfer_from_dma_buf(dev, s, (unsigned short *)dma->virt_addr,
+			      bufptr, len);
 
 	pcl816_ai_clear_eoc(dev);
 
@@ -521,6 +526,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pcl816_private *devpriv = dev->private;
+	struct pcl816_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
 	unsigned long flags;
 	unsigned int top1, top2, i;
 
@@ -546,9 +552,7 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 		return 0;
 	}
 
-	transfer_from_dma_buf(dev, s,
-			      (unsigned short *)devpriv->dmabuf[devpriv->
-								next_dma_buf],
+	transfer_from_dma_buf(dev, s, (unsigned short *)dma->virt_addr,
 			      devpriv->ai_poll_ptr, top2);
 
 	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
@@ -661,6 +665,7 @@ static int pcl816_alloc_dma(struct comedi_device *dev,
 			    unsigned int irq_num, unsigned int dma_chan)
 {
 	struct pcl816_private *devpriv = dev->private;
+	struct pcl816_dma_desc *dma;
 	int i;
 
 	/*
@@ -692,14 +697,12 @@ static int pcl816_alloc_dma(struct comedi_device *dev,
 	devpriv->hwdmasize = (1 << devpriv->dmapages) * PAGE_SIZE;
 
 	for (i = 0; i < 2; i++) {
-		unsigned long dmabuf;
+		dma = &devpriv->dma_desc[i];
 
-		dmabuf = __get_dma_pages(GFP_KERNEL, devpriv->dmapages);
-		if (!dmabuf)
+		dma->virt_addr = __get_dma_pages(GFP_KERNEL, devpriv->dmapages);
+		if (!dma->virt_addr)
 			return -ENOMEM;
-
-		devpriv->dmabuf[i] = dmabuf;
-		devpriv->hwdmaptr[i] = virt_to_bus((void *)dmabuf);
+		dma->hw_addr = virt_to_bus((void *)dma->virt_addr);
 	}
 	return 0;
 }
@@ -707,6 +710,7 @@ static int pcl816_alloc_dma(struct comedi_device *dev,
 static void pcl816_free_dma(struct comedi_device *dev)
 {
 	struct pcl816_private *devpriv = dev->private;
+	struct pcl816_dma_desc *dma;
 	int i;
 
 	if (!devpriv)
@@ -715,8 +719,9 @@ static void pcl816_free_dma(struct comedi_device *dev)
 	if (devpriv->dma)
 		free_dma(devpriv->dma);
 	for (i = 0; i < 2; i++) {
-		if (devpriv->dmabuf[i])
-			free_pages(devpriv->dmabuf[i], devpriv->dmapages);
+		dma = &devpriv->dma_desc[i];
+		if (dma->virt_addr)
+			free_pages(dma->virt_addr, devpriv->dmapages);
 	}
 }
 

commit d7b8bbb6a7c22fd3b830161febfaa89f1d820f09
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:56:01 2015 -0700

    staging: comedi: pcl816: introduce pcl816_free_dma()
    
    For aesthetics, move the freeing of the DMA channel and the buffers to
    a helper function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 0374f832065a..4cff02a1f720 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -704,6 +704,22 @@ static int pcl816_alloc_dma(struct comedi_device *dev,
 	return 0;
 }
 
+static void pcl816_free_dma(struct comedi_device *dev)
+{
+	struct pcl816_private *devpriv = dev->private;
+	int i;
+
+	if (!devpriv)
+		return;
+
+	if (devpriv->dma)
+		free_dma(devpriv->dma);
+	for (i = 0; i < 2; i++) {
+		if (devpriv->dmabuf[i])
+			free_pages(devpriv->dmabuf[i], devpriv->dmapages);
+	}
+}
+
 static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl816_board *board = dev->board_ptr;
@@ -785,18 +801,11 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void pcl816_detach(struct comedi_device *dev)
 {
-	struct pcl816_private *devpriv = dev->private;
-
 	if (dev->private) {
 		pcl816_ai_cancel(dev, dev->read_subdev);
 		pcl816_reset(dev);
-		if (devpriv->dma)
-			free_dma(devpriv->dma);
-		if (devpriv->dmabuf[0])
-			free_pages(devpriv->dmabuf[0], devpriv->dmapages);
-		if (devpriv->dmabuf[1])
-			free_pages(devpriv->dmabuf[1], devpriv->dmapages);
 	}
+	pcl816_free_dma(dev);
 	comedi_legacy_detach(dev);
 }
 

commit 1fa51639e551bee7de73122b8bbafd509eae52fa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:56:00 2015 -0700

    staging: comedi: pcl816: introduce pcl816_alloc_dma()
    
    The IRA and DMA are optional with this driver but both are required to
    support async commands. Introduce a helper function to request the IRQ
    and DMA channel and allocate the buffers. Don't fail the driver attach
    if the user passed an invalid IRQ or DMA channel or they cannot be
    requested.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 73deb4bd5c93..0374f832065a 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -657,13 +657,59 @@ static void pcl816_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + PCL816_DO_DI_MSB_REG);
 }
 
+static int pcl816_alloc_dma(struct comedi_device *dev,
+			    unsigned int irq_num, unsigned int dma_chan)
+{
+	struct pcl816_private *devpriv = dev->private;
+	int i;
+
+	/*
+	 * Only IRQs 2-7 are valid.
+	 * Only DMA channels 3 and 1 are valid.
+	 *
+	 * Both must be valid for async command support.
+	 */
+	if (!(irq_num >= 2 && irq_num <= 7) ||
+	    !(dma_chan == 3 || dma_chan == 1))
+		return 0;
+
+	/*
+	 * Request the IRQ and DMA channels and allocate the DMA buffers.
+	 * If the requests or allocations fail async command supprt will
+	 * not be available.
+	 */
+	if (request_irq(irq_num, pcl816_interrupt, 0, dev->board_name, dev))
+		return 0;
+	if (request_dma(dma_chan, dev->board_name)) {
+		free_irq(irq_num, dev);
+		return 0;
+	}
+
+	dev->irq = irq_num;
+	devpriv->dma = dma_chan;
+
+	devpriv->dmapages = 2;	/* we need 16KB */
+	devpriv->hwdmasize = (1 << devpriv->dmapages) * PAGE_SIZE;
+
+	for (i = 0; i < 2; i++) {
+		unsigned long dmabuf;
+
+		dmabuf = __get_dma_pages(GFP_KERNEL, devpriv->dmapages);
+		if (!dmabuf)
+			return -ENOMEM;
+
+		devpriv->dmabuf[i] = dmabuf;
+		devpriv->hwdmaptr[i] = virt_to_bus((void *)dmabuf);
+	}
+	return 0;
+}
+
 static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl816_board *board = dev->board_ptr;
 	struct pcl816_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
-	int i;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
@@ -673,39 +719,14 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	/* we can use IRQ 2-7 for async command support */
-	if (it->options[1] >= 2 && it->options[1] <= 7) {
-		ret = request_irq(it->options[1], pcl816_interrupt, 0,
-				  dev->board_name, dev);
-		if (ret == 0)
-			dev->irq = it->options[1];
-	}
-
-	/* we need an IRQ to do DMA on channel 3 or 1 */
-	if (dev->irq && (it->options[2] == 3 || it->options[2] == 1)) {
-		ret = request_dma(it->options[2], dev->board_name);
-		if (ret) {
-			dev_err(dev->class_dev,
-				"unable to request DMA channel %d\n",
-				it->options[2]);
-			return -EBUSY;
-		}
-		devpriv->dma = it->options[2];
-
-		devpriv->dmapages = 2;	/* we need 16KB */
-		devpriv->hwdmasize = (1 << devpriv->dmapages) * PAGE_SIZE;
-
-		for (i = 0; i < 2; i++) {
-			unsigned long dmabuf;
-
-			dmabuf = __get_dma_pages(GFP_KERNEL, devpriv->dmapages);
-			if (!dmabuf)
-				return -ENOMEM;
-
-			devpriv->dmabuf[i] = dmabuf;
-			devpriv->hwdmaptr[i] = virt_to_bus((void *)dmabuf);
-		}
-	}
+	/*
+	 * An IRQ and DMA are required to support async commands.
+	 * pcl816_alloc_dma() will only fail if the DMA buffers
+	 * cannot be allocated.
+	 */
+	ret = pcl816_alloc_dma(dev, it->options[1], it->options[2]);
+	if (ret)
+		return ret;
 
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
@@ -718,7 +739,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->maxdata	= board->ai_maxdata;
 	s->range_table	= &range_pcl816;
 	s->insn_read	= pcl816_ai_insn_read;
-	if (devpriv->dma) {
+	if (dev->irq) {
 		dev->read_subdev = s;
 		s->subdev_flags	|= SDF_CMD_READ;
 		s->len_chanlist	= board->ai_chanlist;

commit 64886498b2e83e9f443c4ce37398f0b1481cc966
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:20:57 2014 -0700

    staging: comedi: pcl816: use comedi_async 'scans_done' to detect EOA
    
    Remove the private data member 'ai_act_scan' and use the comedi_async
    'scans_done' member to detect the end-of-acquisition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 7cdb79826213..73deb4bd5c93 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -122,7 +122,6 @@ struct pcl816_private {
 	int next_dma_buf;	/*  which DMA buffer will be used next round */
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
-	int ai_act_scan;	/*  how many scans we finished */
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
 	unsigned int divisor1;
 	unsigned int divisor2;
@@ -286,15 +285,10 @@ static int pcl816_ai_eoc(struct comedi_device *dev,
 static bool pcl816_ai_next_chan(struct comedi_device *dev,
 				struct comedi_subdevice *s)
 {
-	struct pcl816_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	if (s->async->cur_chan == 0)
-		devpriv->ai_act_scan++;
-
 	if (cmd->stop_src == TRIG_COUNT &&
-	    devpriv->ai_act_scan >= cmd->stop_arg) {
-		/* all data sampled */
+	    s->async->scans_done >= cmd->stop_arg) {
 		s->async->events |= COMEDI_CB_EOA;
 		return false;
 	}
@@ -504,7 +498,6 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	pcl816_ai_setup_chanlist(dev, cmd->chanlist, seglen);
 	udelay(1);
 
-	devpriv->ai_act_scan = 0;
 	devpriv->ai_cmd_running = 1;
 	devpriv->ai_poll_ptr = 0;
 	devpriv->ai_cmd_canceled = 0;

commit f8736ca466e2014d6e8bad478fcc5e5cb0105af0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 09:49:31 2014 -0700

    staging: comedi: drivers: move comedi_async 'cur_chan' tracking into the core
    
    The commedi_async 'cur_chan' member is used to track the current position
    in the chanlist for a scan. Currently only a couple comedi drivers use
    this member.
    
    For aeshtetics, move the 'cur_chan' tracking into the core for non-SDF_PACKED
    subdevices. The 'cur_chan' will be updated after reading or writing samples
    to the async buffer by comedi_inc_scan_progress(). All non-SDF_PACKED subdevices
    will then automatiaclly track the 'cur_chan'.
    
    Some of the drivers use the 'cur_chan' to detect the end of scan event when
    counting scans. The COMEDI_CB_EOS event is automatically added by the core
    when the end of scan is detected. The drivers just need to check if the
    'cur_chan' is 0 to count the number of scans completed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 053eed047490..7cdb79826213 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -289,12 +289,8 @@ static bool pcl816_ai_next_chan(struct comedi_device *dev,
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	s->async->cur_chan++;
-	if (s->async->cur_chan >= cmd->chanlist_len) {
-		s->async->cur_chan = 0;
+	if (s->async->cur_chan == 0)
 		devpriv->ai_act_scan++;
-		s->async->events |= COMEDI_CB_EOS;
-	}
 
 	if (cmd->stop_src == TRIG_COUNT &&
 	    devpriv->ai_act_scan >= cmd->stop_arg) {

commit a7d3de75cf00574f8d360d51d0e1beb3c561cc89
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Oct 30 11:21:54 2014 -0700

    staging: comedi: drivers do not need to reset the async->cur_chan
    
    The comedi core calls comedi_buf_reset() before starting an async command
    (*do_cmd) and after returning a subdevice to an idle state (*cancel).
    
    The drivers do not need to reset the async->cur_chan in those functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index a471c3df12b4..053eed047490 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -509,7 +509,6 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	udelay(1);
 
 	devpriv->ai_act_scan = 0;
-	s->async->cur_chan = 0;
 	devpriv->ai_cmd_running = 1;
 	devpriv->ai_poll_ptr = 0;
 	devpriv->ai_cmd_canceled = 0;

commit c0491d4eb4b19721331f6986edfd106ce975f63d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:37:03 2014 -0700

    staging: comedi: pcl816: use comedi_buf_write_samples()
    
    For aesthetics, use comedi_buf_write_samples() to add the sample to the
    async buffer.
    
    The core will add the COMEDI_CB_BLOCK event when data is written to the
    async buffer. Remove the unnecessary event in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 65cbafb85698..a471c3df12b4 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -289,8 +289,6 @@ static bool pcl816_ai_next_chan(struct comedi_device *dev,
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	s->async->events |= COMEDI_CB_BLOCK;
-
 	s->async->cur_chan++;
 	if (s->async->cur_chan >= cmd->chanlist_len) {
 		s->async->cur_chan = 0;
@@ -313,10 +311,12 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 				  unsigned short *ptr,
 				  unsigned int bufptr, unsigned int len)
 {
+	unsigned short val;
 	int i;
 
 	for (i = 0; i < len; i++) {
-		comedi_buf_put(s, ptr[bufptr++]);
+		val = ptr[bufptr++];
+		comedi_buf_write_samples(s, &val, 1);
 
 		if (!pcl816_ai_next_chan(dev, s))
 			return;

commit 3d18aa60ec898092462d28e5e8e50b89082357d4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:41:18 2014 -0700

    staging: comedi: pcl816: use comedi_bytes_per_scan()
    
    This inline function is just a wrapper around comedi_bytes_per_scan().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index e4383ac2b505..65cbafb85698 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -160,7 +160,7 @@ static void pcl816_ai_setup_dma(struct comedi_device *dev,
 	bytes = devpriv->hwdmasize;
 	if (cmd->stop_src == TRIG_COUNT) {
 		/*  how many */
-		bytes = cmd->stop_arg * cfc_bytes_per_scan(s);
+		bytes = cmd->stop_arg * comedi_bytes_per_scan(s);
 
 		/*  how many DMA pages we must fill */
 		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;

commit a2ca8c86515aec54f772533b3fc7e21a635cdab3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:33 2014 -0700

    staging: comedi: pcl816: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index aa6487132017..e4383ac2b505 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -355,7 +355,7 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 
 	pcl816_ai_clear_eoc(dev);
 
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 	return IRQ_HANDLED;
 }
 
@@ -566,7 +566,7 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 
 	return comedi_buf_n_bytes_ready(s);
 }

commit 79c9f68f55b4d539e61bc8ca4bb1eb556e049d94
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:51 2014 +0100

    staging: comedi: pcl816: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 54732c5cab97..aa6487132017 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -671,7 +671,7 @@ static void pcl816_reset(struct comedi_device *dev)
 
 static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct pcl816_board *board = comedi_board(dev);
+	const struct pcl816_board *board = dev->board_ptr;
 	struct pcl816_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;

commit bb3bd743b8394452f8415be099aa512a5bfeb03a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:20 2014 -0700

    staging: comedi: pcl816: remove forward declaration
    
    Move check_channel_list() to remove the need for the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 7cd54359af64..54732c5cab97 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -130,10 +130,6 @@ struct pcl816_private {
 	unsigned int ai_cmd_canceled:1;
 };
 
-static int check_channel_list(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      unsigned int *chanlist, unsigned int chanlen);
-
 static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters)
 {
 	struct pcl816_private *devpriv = dev->private;
@@ -363,6 +359,62 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      unsigned int *chanlist,
+			      unsigned int chanlen)
+{
+	unsigned int chansegment[16];
+	unsigned int i, nowmustbechan, seglen, segpos;
+
+	/*  correct channel and range number check itself comedi/range.c */
+	if (chanlen < 1) {
+		dev_err(dev->class_dev, "range/channel list is empty!\n");
+		return 0;
+	}
+
+	if (chanlen > 1) {
+		/*  first channel is every time ok */
+		chansegment[0] = chanlist[0];
+		for (i = 1, seglen = 1; i < chanlen; i++, seglen++) {
+			/*  we detect loop, this must by finish */
+			    if (chanlist[0] == chanlist[i])
+				break;
+			nowmustbechan =
+			    (CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
+			if (nowmustbechan != CR_CHAN(chanlist[i])) {
+				/*  channel list isn't continuous :-( */
+				dev_dbg(dev->class_dev,
+					"channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\n",
+					i, CR_CHAN(chanlist[i]), nowmustbechan,
+					CR_CHAN(chanlist[0]));
+				return 0;
+			}
+			/*  well, this is next correct channel in list */
+			chansegment[i] = chanlist[i];
+		}
+
+		/*  check whole chanlist */
+		for (i = 0, segpos = 0; i < chanlen; i++) {
+			    if (chanlist[i] != chansegment[i % seglen]) {
+				dev_dbg(dev->class_dev,
+					"bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
+					i, CR_CHAN(chansegment[i]),
+					CR_RANGE(chansegment[i]),
+					CR_AREF(chansegment[i]),
+					CR_CHAN(chanlist[i % seglen]),
+					CR_RANGE(chanlist[i % seglen]),
+					CR_AREF(chansegment[i % seglen]));
+				return 0;	/*  chan/gain list is strange */
+			}
+		}
+	} else {
+		seglen = 1;
+	}
+
+	return seglen;	/*  we can serve this with MUX logic */
+}
+
 static int pcl816_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
@@ -542,62 +594,6 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static int
-check_channel_list(struct comedi_device *dev,
-		   struct comedi_subdevice *s, unsigned int *chanlist,
-		   unsigned int chanlen)
-{
-	unsigned int chansegment[16];
-	unsigned int i, nowmustbechan, seglen, segpos;
-
-	/*  correct channel and range number check itself comedi/range.c */
-	if (chanlen < 1) {
-		dev_err(dev->class_dev, "range/channel list is empty!\n");
-		return 0;
-	}
-
-	if (chanlen > 1) {
-		/*  first channel is every time ok */
-		chansegment[0] = chanlist[0];
-		for (i = 1, seglen = 1; i < chanlen; i++, seglen++) {
-			/*  we detect loop, this must by finish */
-			    if (chanlist[0] == chanlist[i])
-				break;
-			nowmustbechan =
-			    (CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
-			if (nowmustbechan != CR_CHAN(chanlist[i])) {
-				/*  channel list isn't continuous :-( */
-				dev_dbg(dev->class_dev,
-					"channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\n",
-					i, CR_CHAN(chanlist[i]), nowmustbechan,
-					CR_CHAN(chanlist[0]));
-				return 0;
-			}
-			/*  well, this is next correct channel in list */
-			chansegment[i] = chanlist[i];
-		}
-
-		/*  check whole chanlist */
-		for (i = 0, segpos = 0; i < chanlen; i++) {
-			    if (chanlist[i] != chansegment[i % seglen]) {
-				dev_dbg(dev->class_dev,
-					"bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
-					i, CR_CHAN(chansegment[i]),
-					CR_RANGE(chansegment[i]),
-					CR_AREF(chansegment[i]),
-					CR_CHAN(chanlist[i % seglen]),
-					CR_RANGE(chanlist[i % seglen]),
-					CR_AREF(chansegment[i % seglen]));
-				return 0;	/*  chan/gain list is strange */
-			}
-		}
-	} else {
-		seglen = 1;
-	}
-
-	return seglen;	/*  we can serve this with MUX logic */
-}
-
 static int pcl816_ai_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn,

commit d656a35652c76bd68dc5f6a94d96f6a9d436fb0a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:30 2014 -0700

    staging: comedi: pcl816: remove use of comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character. The addition of the driver_name is just added noise
    and some of the users of comedi_error() add unnecessary additional new-line
    characters.
    
    Use dev_err() directly instead of comedi_error() to avoid any confusion
    and so that all the comedi generated kernel messages have the same format.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index eda9986d9cf8..7cd54359af64 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -552,7 +552,7 @@ check_channel_list(struct comedi_device *dev,
 
 	/*  correct channel and range number check itself comedi/range.c */
 	if (chanlen < 1) {
-		comedi_error(dev, "range/channel list is empty!");
+		dev_err(dev->class_dev, "range/channel list is empty!\n");
 		return 0;
 	}
 

commit f4f3f7cf27e7ae015672b59ec40c7deabeaf5d2e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 10:58:28 2014 -0700

    staging: comedi: introduce comedi_buf_n_bytes_ready()
    
    Introduce an inline helper to return the number of bytes that are
    ready to read from the comedi_async buffer. Use the helper in the
    comedi drivers that currently do the calculation as part of the
    (*poll) operation.
    
    Also, use the helper in comedi_fops where the calculation is used as
    part of the subdevice going nonbusy.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index d9ca7fe16c96..eda9986d9cf8 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -516,7 +516,7 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	cfc_handle_events(dev, s);
 
-	return s->async->buf_write_count - s->async->buf_read_count;
+	return comedi_buf_n_bytes_ready(s);
 }
 
 static int pcl816_ai_cancel(struct comedi_device *dev,

commit 4acaec1cfa57fb44ede0fea52f242bd4a9a1422d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:31:11 2014 -0700

    staging: comedi: pcl816: use cfc_bytes_per_scan()
    
    Use the comedi_fc helper to get the number of bytes per scan.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 9c1b963a0bed..d9ca7fe16c96 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -164,7 +164,7 @@ static void pcl816_ai_setup_dma(struct comedi_device *dev,
 	bytes = devpriv->hwdmasize;
 	if (cmd->stop_src == TRIG_COUNT) {
 		/*  how many */
-		bytes = cmd->stop_arg * cmd->chanlist_len * sizeof(short);
+		bytes = cmd->stop_arg * cfc_bytes_per_scan(s);
 
 		/*  how many DMA pages we must fill */
 		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;

commit b5fc9c1031407010ea308be15342bd01b848a853
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:58 2014 -0700

    staging: comedi: pcl816: fix DMA 'bytes' calculation
    
    The calculation for the total number of bytes in the DMA transfer
    is incorrect. Fix it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 3742f5f78fc6..9c1b963a0bed 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -164,9 +164,7 @@ static void pcl816_ai_setup_dma(struct comedi_device *dev,
 	bytes = devpriv->hwdmasize;
 	if (cmd->stop_src == TRIG_COUNT) {
 		/*  how many */
-		bytes = s->async->cmd.chanlist_len *
-		s->async->cmd.chanlist_len *
-		sizeof(short);
+		bytes = cmd->stop_arg * cmd->chanlist_len * sizeof(short);
 
 		/*  how many DMA pages we must fill */
 		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;

commit e4d18fe6b43760ad0a4728a3c908de955cbd206c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:12:55 2014 -0700

    staging: comedi: pcl816: use comedi_fc helpers to validate timer arg
    
    Use the comedi_fc helper cfc_check_trigger_arg_is() to validate the
    trigger argument when the source is TRIG_TIMER.
    
    The minimum test is not needed, this was already validated in Step 3.
    
    All the arguments are unsigned int, change the local variable to an
    unsigned int and rename it for aesthetic reasons.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 1260122ee7ab..3742f5f78fc6 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -370,7 +370,7 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 {
 	struct pcl816_private *devpriv = dev->private;
 	int err = 0;
-	int tmp;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -417,15 +417,12 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 
 	/* step 4: fix up any arguments */
 	if (cmd->convert_src == TRIG_TIMER) {
-		tmp = cmd->convert_arg;
+		arg = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
 					  &devpriv->divisor1,
 					  &devpriv->divisor2,
-					  &cmd->convert_arg, cmd->flags);
-		if (cmd->convert_arg < 10000)
-			cmd->convert_arg = 10000;
-		if (tmp != cmd->convert_arg)
-			err++;
+					  &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
 	if (err)

commit 3672effdeae5395d661a2103f69082146ef949fc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:11:59 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_put()
    
    Change the parameters of `comedi_buf_put()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function puts a sample value in the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 6f276f23fabe..1260122ee7ab 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -322,7 +322,7 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 	int i;
 
 	for (i = 0; i < len; i++) {
-		comedi_buf_put(s->async, ptr[bufptr++]);
+		comedi_buf_put(s, ptr[bufptr++]);
 
 		if (!pcl816_ai_next_chan(dev, s))
 			return;

commit 61c3393f9374ae56108db0f6b60d3bd56780fe80
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:39 2014 -0700

    staging: comedi: pcl816: use cfc_handle_events()
    
    Use the comedi_fc helper function to automatically call the subdevice
    (*cancel) function when needed and call comedi_event().
    
    Update the Kconfig so that COMEDI_PCL816 selects COMEDI_FC.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 6386ef7a0042..6f276f23fabe 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -307,7 +307,6 @@ static bool pcl816_ai_next_chan(struct comedi_device *dev,
 	if (cmd->stop_src == TRIG_COUNT &&
 	    devpriv->ai_act_scan >= cmd->stop_arg) {
 		/* all data sampled */
-		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA;
 		return false;
 	}
@@ -362,7 +361,7 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 
 	pcl816_ai_clear_eoc(dev);
 
-	comedi_event(dev, s);
+	cfc_handle_events(dev, s);
 	return IRQ_HANDLED;
 }
 
@@ -520,7 +519,7 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	comedi_event(dev, s);
+	cfc_handle_events(dev, s);
 
 	return s->async->buf_write_count - s->async->buf_read_count;
 }

commit e8e7709f3346feb1d01cdaa4fbeed447f5a6a6e3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:24 2014 -0700

    staging: comedi: pcl816: tidy up the remaining register defines
    
    For aesthetics, rename the clear INT request register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index f22cf8620670..6386ef7a0042 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -44,12 +44,16 @@ Configuration Options:
 #include "comedi_fc.h"
 #include "8253.h"
 
+/*
+ * Register I/O map
+ */
 #define PCL816_DO_DI_LSB_REG			0x00
 #define PCL816_DO_DI_MSB_REG			0x01
 #define PCL816_TIMER_BASE			0x04
 #define PCL816_AI_LSB_REG			0x08
 #define PCL816_AI_MSB_REG			0x09
 #define PCL816_RANGE_REG			0x09
+#define PCL816_CLRINT_REG			0x0a
 #define PCL816_MUX_REG				0x0b
 #define PCL816_MUX_SCAN(_first, _last)		(((_last) << 4) | (_first))
 #define PCL816_CTRL_REG				0x0c
@@ -73,9 +77,6 @@ Configuration Options:
 #define PCL816_STATUS_INTACT			(1 << 6)
 #define PCL816_STATUS_DRDY			(1 << 7)
 
-/* W: clear INT request */
-#define PCL816_CLRINT 10
-
 #define MAGIC_DMA_WORD 0x5a5a
 
 static const struct comedi_lrange range_pcl816 = {
@@ -255,7 +256,7 @@ static void pcl816_ai_setup_chanlist(struct comedi_device *dev,
 static void pcl816_ai_clear_eoc(struct comedi_device *dev)
 {
 	/* writing any value clears the interrupt request */
-	outb(0, dev->iobase + PCL816_CLRINT);
+	outb(0, dev->iobase + PCL816_CLRINT_REG);
 }
 
 static void pcl816_ai_soft_trig(struct comedi_device *dev)

commit 6cf215d730d5fc050603edd0d693e3520626b6a3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:19 2014 -0700

    staging: comedi: pcl816: define the mode register bits
    
    Define the bits in the register to remove the magic values.
    
    Fix pcl816_ai_cancel(). The 0x73 mask of the value read from the control
    register will not stop the A/D as indicated by the comment. This would just
    clear the DS1, POE, and EXT bits which would only disable the external
    trigger. Setting the control register to '0' would then stop the A/D which
    means the software trigger following it would not work. Just disable the
    trigger and clear any pending end-of-conversion.
    
    Make sure the A/D trigger is disabled at the end of the (*insn_read).
    
    Remove a couple unnecessary devpriv->dev checks. The pcl816_ai_cmd() and
    pcl816_ai_poll() functions are only hooked up when devpriv->dma is valid.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 786680f32686..f22cf8620670 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -52,6 +52,17 @@ Configuration Options:
 #define PCL816_RANGE_REG			0x09
 #define PCL816_MUX_REG				0x0b
 #define PCL816_MUX_SCAN(_first, _last)		(((_last) << 4) | (_first))
+#define PCL816_CTRL_REG				0x0c
+#define PCL816_CTRL_DISABLE_TRIG		(0 << 0)
+#define PCL816_CTRL_SOFT_TRIG			(1 << 0)
+#define PCL816_CTRL_PACER_TRIG			(1 << 1)
+#define PCL816_CTRL_EXT_TRIG			(1 << 2)
+#define PCL816_CTRL_POE				(1 << 3)
+#define PCL816_CTRL_DMAEN			(1 << 4)
+#define PCL816_CTRL_INTEN			(1 << 5)
+#define PCL816_CTRL_DMASRC_SLOT0		(0 << 6)
+#define PCL816_CTRL_DMASRC_SLOT1		(1 << 6)
+#define PCL816_CTRL_DMASRC_SLOT2		(2 << 6)
 #define PCL816_STATUS_REG			0x0d
 #define PCL816_STATUS_NEXT_CHAN_MASK		(0xf << 0)
 #define PCL816_STATUS_INTSRC_MASK		(3 << 4)
@@ -64,9 +75,6 @@ Configuration Options:
 
 /* W: clear INT request */
 #define PCL816_CLRINT 10
-/* R/W: operation control register */
-#define PCL816_CONTROL 12
-
 
 #define MAGIC_DMA_WORD 0x5a5a
 
@@ -439,7 +447,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int dmairq;
+	unsigned int ctrl;
 	unsigned int seglen;
 
 	if (devpriv->ai_cmd_running)
@@ -459,29 +467,18 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_poll_ptr = 0;
 	devpriv->ai_cmd_canceled = 0;
 
-	if (devpriv->dma)
-		pcl816_ai_setup_dma(dev, s);
+	pcl816_ai_setup_dma(dev, s);
 
 	pcl816_start_pacer(dev, true);
-	dmairq = ((devpriv->dma & 0x3) << 4) | (dev->irq & 0x7);
-
-	switch (cmd->convert_src) {
-	case TRIG_TIMER:
-		/*  Pacer+IRQ+DMA */
-		outb(0x32, dev->iobase + PCL816_CONTROL);
 
-		/*  write irq and DMA to card */
-		outb(dmairq, dev->iobase + PCL816_STATUS_REG);
-		break;
-
-	default:
-		/*  Ext trig+IRQ+DMA */
-		outb(0x34, dev->iobase + PCL816_CONTROL);
+	ctrl = PCL816_CTRL_INTEN | PCL816_CTRL_DMAEN | PCL816_CTRL_DMASRC_SLOT0;
+	if (cmd->convert_src == TRIG_TIMER)
+		ctrl |= PCL816_CTRL_PACER_TRIG;
+	else	/* TRIG_EXT */
+		ctrl |= PCL816_CTRL_EXT_TRIG;
 
-		/*  write irq to card */
-		outb(dmairq, dev->iobase + PCL816_STATUS_REG);
-		break;
-	}
+	outb(ctrl, dev->iobase + PCL816_CTRL_REG);
+	outb((devpriv->dma << 4) | dev->irq, dev->iobase + PCL816_STATUS_REG);
 
 	return 0;
 }
@@ -492,9 +489,6 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned long flags;
 	unsigned int top1, top2, i;
 
-	if (!devpriv->dma)
-		return 0;	/*  poll is valid only for DMA transfer */
-
 	spin_lock_irqsave(&dev->spinlock, flags);
 
 	for (i = 0; i < 20; i++) {
@@ -538,11 +532,8 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 	if (!devpriv->ai_cmd_running)
 		return 0;
 
-	disable_dma(devpriv->dma);
-	outb(inb(dev->iobase + PCL816_CONTROL) & 0x73,
-	     dev->iobase + PCL816_CONTROL);	/* Stop A/D */
-	udelay(1);
-	outb(0, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
+	outb(PCL816_CTRL_DISABLE_TRIG, dev->iobase + PCL816_CTRL_REG);
+	pcl816_ai_clear_eoc(dev);
 
 	/* Stop pacer */
 	i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
@@ -550,13 +541,6 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 	i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
 			1, I8254_MODE0 | I8254_BINARY);
 
-	pcl816_ai_soft_trig(dev);
-	pcl816_ai_get_sample(dev, s);
-
-	pcl816_ai_clear_eoc(dev);
-
-	/* Stop A/D */
-	outb(0, dev->iobase + PCL816_CONTROL);
 	devpriv->ai_cmd_running = 0;
 	devpriv->ai_cmd_canceled = 1;
 
@@ -629,8 +613,7 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 	int ret = 0;
 	int i;
 
-	/*  software trigger, DMA and INT off */
-	outb(0, dev->iobase + PCL816_CONTROL);
+	outb(PCL816_CTRL_SOFT_TRIG, dev->iobase + PCL816_CTRL_REG);
 
 	pcl816_ai_set_chan_range(dev, chan, range);
 	pcl816_ai_set_chan_scan(dev, chan, chan);
@@ -645,6 +628,7 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 
 		data[i] = pcl816_ai_get_sample(dev, s);
 	}
+	outb(PCL816_CTRL_DISABLE_TRIG, dev->iobase + PCL816_CTRL_REG);
 	pcl816_ai_clear_eoc(dev);
 
 	return ret ? ret : insn->n;
@@ -680,7 +664,7 @@ static void pcl816_reset(struct comedi_device *dev)
 {
 	unsigned long timer_base = dev->iobase + PCL816_TIMER_BASE;
 
-	outb(0, dev->iobase + PCL816_CONTROL);
+	outb(PCL816_CTRL_DISABLE_TRIG, dev->iobase + PCL816_CTRL_REG);
 	pcl816_ai_set_chan_range(dev, 0, 0);
 	pcl816_ai_clear_eoc(dev);
 

commit 19720c07f1f82c21311f3f7ac3e9b993598d6b70
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:16 2014 -0700

    staging: comedi: pcl816: cleanup setup_channel_list()
    
    Move this function to remove the need for the forward declaration. Rename it
    so it has namespace associated with the driver. Remove the unnecessary
    comedi_subdevice parameter from the function.
    
    The hardware has per-channel programmable gain. This function first sets the
    range for each channel then sets the mux register to automatically scan the
    channels.
    
    Remove the need for the 'ai_act_chanlist' member in the private data. It is
    only used to set the first/last channel to scan.
    
    Introduce a couple helper functions to set the range for a channel and to set
    the first/last channels to scan.
    
    Tidy up the range and mux register defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 6ad279362d60..786680f32686 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -49,6 +49,9 @@ Configuration Options:
 #define PCL816_TIMER_BASE			0x04
 #define PCL816_AI_LSB_REG			0x08
 #define PCL816_AI_MSB_REG			0x09
+#define PCL816_RANGE_REG			0x09
+#define PCL816_MUX_REG				0x0b
+#define PCL816_MUX_SCAN(_first, _last)		(((_last) << 4) | (_first))
 #define PCL816_STATUS_REG			0x0d
 #define PCL816_STATUS_NEXT_CHAN_MASK		(0xf << 0)
 #define PCL816_STATUS_INTSRC_MASK		(3 << 4)
@@ -59,12 +62,8 @@ Configuration Options:
 #define PCL816_STATUS_INTACT			(1 << 6)
 #define PCL816_STATUS_DRDY			(1 << 7)
 
-/* R: A/D high byte W: A/D range control */
-#define PCL816_RANGE 9
 /* W: clear INT request */
 #define PCL816_CLRINT 10
-/* R: next mux scan channel W: mux scan channel & range control pointer */
-#define PCL816_MUX 11
 /* R/W: operation control register */
 #define PCL816_CONTROL 12
 
@@ -115,7 +114,6 @@ struct pcl816_private {
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
 	int ai_act_scan;	/*  how many scans we finished */
-	unsigned int ai_act_chanlist[16];	/*  MUX setting for actual AI operations */
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
 	unsigned int divisor1;
 	unsigned int divisor2;
@@ -126,9 +124,6 @@ struct pcl816_private {
 static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      unsigned int *chanlist, unsigned int chanlen);
-static void setup_channel_list(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       unsigned int *chanlist, unsigned int seglen);
 
 static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters)
 {
@@ -211,6 +206,44 @@ static void pcl816_ai_setup_next_dma(struct comedi_device *dev,
 	devpriv->dma_runs_to_end--;
 }
 
+static void pcl816_ai_set_chan_range(struct comedi_device *dev,
+				     unsigned int chan,
+				     unsigned int range)
+{
+	outb(chan, dev->iobase + PCL816_MUX_REG);
+	outb(range, dev->iobase + PCL816_RANGE_REG);
+}
+
+static void pcl816_ai_set_chan_scan(struct comedi_device *dev,
+				    unsigned int first_chan,
+				    unsigned int last_chan)
+{
+	outb(PCL816_MUX_SCAN(first_chan, last_chan),
+	     dev->iobase + PCL816_MUX_REG);
+}
+
+static void pcl816_ai_setup_chanlist(struct comedi_device *dev,
+				     unsigned int *chanlist,
+				     unsigned int seglen)
+{
+	unsigned int first_chan = CR_CHAN(chanlist[0]);
+	unsigned int last_chan;
+	unsigned int range;
+	unsigned int i;
+
+	/* store range list to card */
+	for (i = 0; i < seglen; i++) {
+		last_chan = CR_CHAN(chanlist[i]);
+		range = CR_RANGE(chanlist[i]);
+
+		pcl816_ai_set_chan_range(dev, last_chan, range);
+	}
+
+	udelay(1);
+
+	pcl816_ai_set_chan_scan(dev, first_chan, last_chan);
+}
+
 static void pcl816_ai_clear_eoc(struct comedi_device *dev)
 {
 	/* writing any value clears the interrupt request */
@@ -417,7 +450,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	seglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);
 	if (seglen < 1)
 		return -EINVAL;
-	setup_channel_list(dev, s, cmd->chanlist, seglen);
+	pcl816_ai_setup_chanlist(dev, cmd->chanlist, seglen);
 	udelay(1);
 
 	devpriv->ai_act_scan = 0;
@@ -586,28 +619,6 @@ check_channel_list(struct comedi_device *dev,
 	return seglen;	/*  we can serve this with MUX logic */
 }
 
-static void
-setup_channel_list(struct comedi_device *dev,
-		   struct comedi_subdevice *s, unsigned int *chanlist,
-		   unsigned int seglen)
-{
-	struct pcl816_private *devpriv = dev->private;
-	unsigned int i;
-
-	for (i = 0; i < seglen; i++) {	/*  store range list to card */
-		devpriv->ai_act_chanlist[i] = CR_CHAN(chanlist[i]);
-		outb(CR_CHAN(chanlist[0]) & 0xf, dev->iobase + PCL816_MUX);
-		/* select gain */
-		outb(CR_RANGE(chanlist[0]), dev->iobase + PCL816_RANGE);
-	}
-
-	udelay(1);
-	/* select channel interval to scan */
-	outb(devpriv->ai_act_chanlist[0] |
-	     (devpriv->ai_act_chanlist[seglen - 1] << 4),
-	     dev->iobase + PCL816_MUX);
-}
-
 static int pcl816_ai_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn,
@@ -621,10 +632,8 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 	/*  software trigger, DMA and INT off */
 	outb(0, dev->iobase + PCL816_CONTROL);
 
-	/*  Set the input channel */
-	outb(chan, dev->iobase + PCL816_MUX);
-	/* select gain */
-	outb(range, dev->iobase + PCL816_RANGE);
+	pcl816_ai_set_chan_range(dev, chan, range);
+	pcl816_ai_set_chan_scan(dev, chan, chan);
 
 	for (i = 0; i < insn->n; i++) {
 		pcl816_ai_clear_eoc(dev);
@@ -672,7 +681,7 @@ static void pcl816_reset(struct comedi_device *dev)
 	unsigned long timer_base = dev->iobase + PCL816_TIMER_BASE;
 
 	outb(0, dev->iobase + PCL816_CONTROL);
-	outb(0, dev->iobase + PCL816_MUX);
+	pcl816_ai_set_chan_range(dev, 0, 0);
 	pcl816_ai_clear_eoc(dev);
 
 	/* Stop pacer */
@@ -680,8 +689,6 @@ static void pcl816_reset(struct comedi_device *dev)
 	i8254_set_mode(timer_base, 0, 1, I8254_MODE0 | I8254_BINARY);
 	i8254_set_mode(timer_base, 0, 0, I8254_MODE0 | I8254_BINARY);
 
-	outb(0, dev->iobase + PCL816_RANGE);
-
 	/* set all digital outputs low */
 	outb(0, dev->iobase + PCL816_DO_DI_LSB_REG);
 	outb(0, dev->iobase + PCL816_DO_DI_MSB_REG);

commit f72196eca4ec8159b61a47e19f84d32446b3cede
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:13 2014 -0700

    staging: comedi: pcl816: define the status register bits
    
    Define the bits in the status register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 55869106e158..6ad279362d60 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -49,6 +49,15 @@ Configuration Options:
 #define PCL816_TIMER_BASE			0x04
 #define PCL816_AI_LSB_REG			0x08
 #define PCL816_AI_MSB_REG			0x09
+#define PCL816_STATUS_REG			0x0d
+#define PCL816_STATUS_NEXT_CHAN_MASK		(0xf << 0)
+#define PCL816_STATUS_INTSRC_MASK		(3 << 4)
+#define PCL816_STATUS_INTSRC_SLOT0		(0 << 4)
+#define PCL816_STATUS_INTSRC_SLOT1		(1 << 4)
+#define PCL816_STATUS_INTSRC_SLOT2		(2 << 4)
+#define PCL816_STATUS_INTSRC_DMA		(3 << 4)
+#define PCL816_STATUS_INTACT			(1 << 6)
+#define PCL816_STATUS_DRDY			(1 << 7)
 
 /* R: A/D high byte W: A/D range control */
 #define PCL816_RANGE 9
@@ -59,9 +68,6 @@ Configuration Options:
 /* R/W: operation control register */
 #define PCL816_CONTROL 12
 
-/* R: return status byte  W: set DMA/IRQ */
-#define PCL816_STATUS 13
-#define PCL816_STATUS_DRDY_MASK 0x80
 
 #define MAGIC_DMA_WORD 0x5a5a
 
@@ -235,8 +241,8 @@ static int pcl816_ai_eoc(struct comedi_device *dev,
 {
 	unsigned int status;
 
-	status = inb(dev->iobase + PCL816_STATUS);
-	if ((status & PCL816_STATUS_DRDY_MASK) == 0)
+	status = inb(dev->iobase + PCL816_STATUS_REG);
+	if ((status & PCL816_STATUS_DRDY) == 0)
 		return 0;
 	return -EBUSY;
 }
@@ -432,7 +438,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		outb(0x32, dev->iobase + PCL816_CONTROL);
 
 		/*  write irq and DMA to card */
-		outb(dmairq, dev->iobase + PCL816_STATUS);
+		outb(dmairq, dev->iobase + PCL816_STATUS_REG);
 		break;
 
 	default:
@@ -440,7 +446,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		outb(0x34, dev->iobase + PCL816_CONTROL);
 
 		/*  write irq to card */
-		outb(dmairq, dev->iobase + PCL816_STATUS);
+		outb(dmairq, dev->iobase + PCL816_STATUS_REG);
 		break;
 	}
 

commit c99e0e196ce98848792d345ec0ab9dca4d891b05
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:10 2014 -0700

    staging: comedi: pcl816: tidy up analog input registers
    
    For aesthetics, rename the analog input register defines and convert
    the offsets to hex.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index f77bc68ba12f..55869106e158 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -47,6 +47,8 @@ Configuration Options:
 #define PCL816_DO_DI_LSB_REG			0x00
 #define PCL816_DO_DI_MSB_REG			0x01
 #define PCL816_TIMER_BASE			0x04
+#define PCL816_AI_LSB_REG			0x08
+#define PCL816_AI_MSB_REG			0x09
 
 /* R: A/D high byte W: A/D range control */
 #define PCL816_RANGE 9
@@ -61,11 +63,6 @@ Configuration Options:
 #define PCL816_STATUS 13
 #define PCL816_STATUS_DRDY_MASK 0x80
 
-/* R: low byte of A/D W: soft A/D trigger */
-#define PCL816_AD_LO 8
-/* R: high byte of A/D W: A/D range control */
-#define PCL816_AD_HI 9
-
 #define MAGIC_DMA_WORD 0x5a5a
 
 static const struct comedi_lrange range_pcl816 = {
@@ -217,7 +214,7 @@ static void pcl816_ai_clear_eoc(struct comedi_device *dev)
 static void pcl816_ai_soft_trig(struct comedi_device *dev)
 {
 	/* writing any value triggers a software conversion */
-	outb(0, dev->iobase + PCL816_AD_LO);
+	outb(0, dev->iobase + PCL816_AI_LSB_REG);
 }
 
 static unsigned int pcl816_ai_get_sample(struct comedi_device *dev,
@@ -225,8 +222,8 @@ static unsigned int pcl816_ai_get_sample(struct comedi_device *dev,
 {
 	unsigned int val;
 
-	val = inb(dev->iobase + PCL816_AD_HI) << 8;
-	val |= inb(dev->iobase + PCL816_AD_LO);
+	val = inb(dev->iobase + PCL816_AI_MSB_REG) << 8;
+	val |= inb(dev->iobase + PCL816_AI_LSB_REG);
 
 	return val & s->maxdata;
 }

commit 939d33d688e208a2c8ff0f083704c15b0c11d4ee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:07 2014 -0700

    staging: comedi: pcl816: introduce pcl816_ai_soft_trig()
    
    Introduce a helper function to start a software triggered analog input
    conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 40fd27789886..f77bc68ba12f 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -214,6 +214,12 @@ static void pcl816_ai_clear_eoc(struct comedi_device *dev)
 	outb(0, dev->iobase + PCL816_CLRINT);
 }
 
+static void pcl816_ai_soft_trig(struct comedi_device *dev)
+{
+	/* writing any value triggers a software conversion */
+	outb(0, dev->iobase + PCL816_AD_LO);
+}
+
 static unsigned int pcl816_ai_get_sample(struct comedi_device *dev,
 					 struct comedi_subdevice *s)
 {
@@ -508,7 +514,7 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 	i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
 			1, I8254_MODE0 | I8254_BINARY);
 
-	outb(0, dev->iobase + PCL816_AD_LO);
+	pcl816_ai_soft_trig(dev);
 	pcl816_ai_get_sample(dev, s);
 
 	pcl816_ai_clear_eoc(dev);
@@ -619,8 +625,7 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 
 	for (i = 0; i < insn->n; i++) {
 		pcl816_ai_clear_eoc(dev);
-		/* start conversion */
-		outb(0, dev->iobase + PCL816_AD_LO);
+		pcl816_ai_soft_trig(dev);
 
 		ret = comedi_timeout(dev, s, insn, pcl816_ai_eoc, 0);
 		if (ret)

commit 97880eaf9b965dd121b8fc2ef0a8fb3f4beaddbe
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:04 2014 -0700

    staging: comedi: pcl816: introduce pcl816_ai_clear_eoc()
    
    Introduce a helper function to clear the end-of-conversion flag.
    
    This flag is set when an analog input conversion is finished and the
    hardware generates an interrupt request. Writing any value to the
    register resets the flag and re-enables the interrupt.
    
    Move the call in pcl816_ai_cancel() so that the flag is reset after
    stopping the A/D.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index e9795106b848..40fd27789886 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -208,6 +208,12 @@ static void pcl816_ai_setup_next_dma(struct comedi_device *dev,
 	devpriv->dma_runs_to_end--;
 }
 
+static void pcl816_ai_clear_eoc(struct comedi_device *dev)
+{
+	/* writing any value clears the interrupt request */
+	outb(0, dev->iobase + PCL816_CLRINT);
+}
+
 static unsigned int pcl816_ai_get_sample(struct comedi_device *dev,
 					 struct comedi_subdevice *s)
 {
@@ -283,13 +289,13 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 	unsigned int len;
 
 	if (!dev->attached || !devpriv->ai_cmd_running) {
-		outb(0, dev->iobase + PCL816_CLRINT);
+		pcl816_ai_clear_eoc(dev);
 		return IRQ_HANDLED;
 	}
 
 	if (devpriv->ai_cmd_canceled) {
 		devpriv->ai_cmd_canceled = 0;
-		outb(0, dev->iobase + PCL816_CLRINT);
+		pcl816_ai_clear_eoc(dev);
 		return IRQ_HANDLED;
 	}
 
@@ -303,7 +309,7 @@ static irqreturn_t pcl816_interrupt(int irq, void *d)
 
 	transfer_from_dma_buf(dev, s, ptr, bufptr, len);
 
-	outb(0, dev->iobase + PCL816_CLRINT);
+	pcl816_ai_clear_eoc(dev);
 
 	comedi_event(dev, s);
 	return IRQ_HANDLED;
@@ -505,8 +511,7 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 	outb(0, dev->iobase + PCL816_AD_LO);
 	pcl816_ai_get_sample(dev, s);
 
-	/* clear INT request */
-	outb(0, dev->iobase + PCL816_CLRINT);
+	pcl816_ai_clear_eoc(dev);
 
 	/* Stop A/D */
 	outb(0, dev->iobase + PCL816_CONTROL);
@@ -613,8 +618,7 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 	outb(range, dev->iobase + PCL816_RANGE);
 
 	for (i = 0; i < insn->n; i++) {
-		/* clear INT (conversion end) flag */
-		outb(0, dev->iobase + PCL816_CLRINT);
+		pcl816_ai_clear_eoc(dev);
 		/* start conversion */
 		outb(0, dev->iobase + PCL816_AD_LO);
 
@@ -624,8 +628,7 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 
 		data[i] = pcl816_ai_get_sample(dev, s);
 	}
-	/* clear INT (conversion end) flag */
-	outb(0, dev->iobase + PCL816_CLRINT);
+	pcl816_ai_clear_eoc(dev);
 
 	return ret ? ret : insn->n;
 }
@@ -662,7 +665,7 @@ static void pcl816_reset(struct comedi_device *dev)
 
 	outb(0, dev->iobase + PCL816_CONTROL);
 	outb(0, dev->iobase + PCL816_MUX);
-	outb(0, dev->iobase + PCL816_CLRINT);
+	pcl816_ai_clear_eoc(dev);
 
 	/* Stop pacer */
 	i8254_set_mode(timer_base, 0, 2, I8254_MODE0 | I8254_BINARY);

commit 937a3706880c9bd3ff106cba296ce7bf751951f2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:30:01 2014 -0700

    staging: comedi: pcl816: tidy up the analog input (*insn_read)
    
    For aesthetics, move this function out of the async command support
    code.
    
    For safety, the INT request (end-of-conversion flag) should be cleared
    before doing each conversion and after the final data sample is read.
    This driver does that but it's a bit awkward with the initial clear being
    outside the for loop that reads the samples.
    
    Refactor the function a bit so it's more like the pcl818 driver and we
    can use common code to clear the flag for a timeout and after the last
    sample.
    
    Do a bit of other tidying up during the move.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 2487e4448fc4..e9795106b848 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -232,42 +232,6 @@ static int pcl816_ai_eoc(struct comedi_device *dev,
 	return -EBUSY;
 }
 
-static int pcl816_ai_insn_read(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
-{
-	int ret;
-	int n;
-
-	/*  software trigger, DMA and INT off */
-	outb(0, dev->iobase + PCL816_CONTROL);
-	/*  clear INT (conversion end) flag */
-	outb(0, dev->iobase + PCL816_CLRINT);
-
-	/*  Set the input channel */
-	outb(CR_CHAN(insn->chanspec) & 0xf, dev->iobase + PCL816_MUX);
-	/* select gain */
-	outb(CR_RANGE(insn->chanspec), dev->iobase + PCL816_RANGE);
-
-	for (n = 0; n < insn->n; n++) {
-
-		outb(0, dev->iobase + PCL816_AD_LO);	/* start conversion */
-
-		ret = comedi_timeout(dev, s, insn, pcl816_ai_eoc, 0);
-		if (ret) {
-			/* clear INT (conversion end) flag */
-			outb(0, dev->iobase + PCL816_CLRINT);
-			return ret;
-		}
-
-		data[n] = pcl816_ai_get_sample(dev, s);
-
-		/* clear INT (conversion end) flag */
-		outb(0, dev->iobase + PCL816_CLRINT);
-	}
-	return n;
-}
-
 static bool pcl816_ai_next_chan(struct comedi_device *dev,
 				struct comedi_subdevice *s)
 {
@@ -630,6 +594,42 @@ setup_channel_list(struct comedi_device *dev,
 	     dev->iobase + PCL816_MUX);
 }
 
+static int pcl816_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
+{
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
+	int ret = 0;
+	int i;
+
+	/*  software trigger, DMA and INT off */
+	outb(0, dev->iobase + PCL816_CONTROL);
+
+	/*  Set the input channel */
+	outb(chan, dev->iobase + PCL816_MUX);
+	/* select gain */
+	outb(range, dev->iobase + PCL816_RANGE);
+
+	for (i = 0; i < insn->n; i++) {
+		/* clear INT (conversion end) flag */
+		outb(0, dev->iobase + PCL816_CLRINT);
+		/* start conversion */
+		outb(0, dev->iobase + PCL816_AD_LO);
+
+		ret = comedi_timeout(dev, s, insn, pcl816_ai_eoc, 0);
+		if (ret)
+			break;
+
+		data[i] = pcl816_ai_get_sample(dev, s);
+	}
+	/* clear INT (conversion end) flag */
+	outb(0, dev->iobase + PCL816_CLRINT);
+
+	return ret ? ret : insn->n;
+}
+
 static int pcl816_di_insn_bits(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn,

commit dc917419212f80fa90ecbfa7bce10aa98183db45
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:57 2014 -0700

    staging: comedi: pcl816: move pcl816_reset()
    
    For aesthetics, move this function to follow the pcl812 and pcl818 drivers
    better.
    
    Remove the commented out cut-and-paste code from the pcl818 driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 228301095824..2487e4448fc4 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -552,29 +552,6 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static void pcl816_reset(struct comedi_device *dev)
-{
-	unsigned long timer_base = dev->iobase + PCL816_TIMER_BASE;
-
-/* outb (0, dev->iobase + PCL818_DA_LO);         DAC=0V */
-/* outb (0, dev->iobase + PCL818_DA_HI); */
-/* udelay (1); */
-	outb(0, dev->iobase + PCL816_CONTROL);
-	outb(0, dev->iobase + PCL816_MUX);
-	outb(0, dev->iobase + PCL816_CLRINT);
-
-	/* Stop pacer */
-	i8254_set_mode(timer_base, 0, 2, I8254_MODE0 | I8254_BINARY);
-	i8254_set_mode(timer_base, 0, 1, I8254_MODE0 | I8254_BINARY);
-	i8254_set_mode(timer_base, 0, 0, I8254_MODE0 | I8254_BINARY);
-
-	outb(0, dev->iobase + PCL816_RANGE);
-
-	/* set all digital outputs low */
-	outb(0, dev->iobase + PCL816_DO_DI_LSB_REG);
-	outb(0, dev->iobase + PCL816_DO_DI_MSB_REG);
-}
-
 static int
 check_channel_list(struct comedi_device *dev,
 		   struct comedi_subdevice *s, unsigned int *chanlist,
@@ -679,6 +656,26 @@ static int pcl816_do_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
+static void pcl816_reset(struct comedi_device *dev)
+{
+	unsigned long timer_base = dev->iobase + PCL816_TIMER_BASE;
+
+	outb(0, dev->iobase + PCL816_CONTROL);
+	outb(0, dev->iobase + PCL816_MUX);
+	outb(0, dev->iobase + PCL816_CLRINT);
+
+	/* Stop pacer */
+	i8254_set_mode(timer_base, 0, 2, I8254_MODE0 | I8254_BINARY);
+	i8254_set_mode(timer_base, 0, 1, I8254_MODE0 | I8254_BINARY);
+	i8254_set_mode(timer_base, 0, 0, I8254_MODE0 | I8254_BINARY);
+
+	outb(0, dev->iobase + PCL816_RANGE);
+
+	/* set all digital outputs low */
+	outb(0, dev->iobase + PCL816_DO_DI_LSB_REG);
+	outb(0, dev->iobase + PCL816_DO_DI_MSB_REG);
+}
+
 static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl816_board *board = comedi_board(dev);

commit c1cd5623b17ab7d6c51f2775f95ac3ca06420d63
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:55 2014 -0700

    staging: comedi: pcl816: add support for digital subdevices
    
    The PCL-816 boards have 16 digital inputs and 16 digtial outputs. Add the
    subdevice support for these channels.
    
    Allocate additional subdevice space to the analog outputs. This code is
    not currently in the driver so mark the subdevice as COMEDI_SUBD_UNUSED.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 0d20fba0abea..228301095824 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -44,6 +44,8 @@ Configuration Options:
 #include "comedi_fc.h"
 #include "8253.h"
 
+#define PCL816_DO_DI_LSB_REG			0x00
+#define PCL816_DO_DI_MSB_REG			0x01
 #define PCL816_TIMER_BASE			0x04
 
 /* R: A/D high byte W: A/D range control */
@@ -556,9 +558,6 @@ static void pcl816_reset(struct comedi_device *dev)
 
 /* outb (0, dev->iobase + PCL818_DA_LO);         DAC=0V */
 /* outb (0, dev->iobase + PCL818_DA_HI); */
-/* udelay (1); */
-/* outb (0, dev->iobase + PCL818_DO_HI);        DO=$0000 */
-/* outb (0, dev->iobase + PCL818_DO_LO); */
 /* udelay (1); */
 	outb(0, dev->iobase + PCL816_CONTROL);
 	outb(0, dev->iobase + PCL816_MUX);
@@ -570,6 +569,10 @@ static void pcl816_reset(struct comedi_device *dev)
 	i8254_set_mode(timer_base, 0, 0, I8254_MODE0 | I8254_BINARY);
 
 	outb(0, dev->iobase + PCL816_RANGE);
+
+	/* set all digital outputs low */
+	outb(0, dev->iobase + PCL816_DO_DI_LSB_REG);
+	outb(0, dev->iobase + PCL816_DO_DI_MSB_REG);
 }
 
 static int
@@ -650,6 +653,32 @@ setup_channel_list(struct comedi_device *dev,
 	     dev->iobase + PCL816_MUX);
 }
 
+static int pcl816_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
+{
+	data[1] = inb(dev->iobase + PCL816_DO_DI_LSB_REG) |
+		  (inb(dev->iobase + PCL816_DO_DI_MSB_REG) << 8);
+
+	return insn->n;
+}
+
+static int pcl816_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
+{
+	if (comedi_dio_update_state(s, data)) {
+		outb(s->state & 0xff, dev->iobase + PCL816_DO_DI_LSB_REG);
+		outb((s->state >> 8), dev->iobase + PCL816_DO_DI_MSB_REG);
+	}
+
+	data[1] = s->state;
+
+	return insn->n;
+}
+
 static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl816_board *board = comedi_board(dev);
@@ -700,7 +729,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	}
 
-	ret = comedi_alloc_subdevices(dev, 1);
+	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
 		return ret;
 
@@ -721,29 +750,35 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->cancel	= pcl816_ai_cancel;
 	}
 
+	/* Analog OUtput subdevice */
+	s = &dev->subdevices[2];
+	s->type		= COMEDI_SUBD_UNUSED;
 #if 0
 	subdevs[1] = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
 	s->n_chan = 1;
 	s->maxdata = board->ao_maxdata;
 	s->range_table = &range_pcl816;
-	break;
-
-	subdevs[2] = COMEDI_SUBD_DI;
-	s->subdev_flags = SDF_READABLE;
-	s->n_chan = 16;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	break;
-
-	subdevs[3] = COMEDI_SUBD_DO;
-	s->subdev_flags = SDF_WRITABLE;
-	s->n_chan = 16;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	break;
 #endif
 
+	/* Digital Input subdevice */
+	s = &dev->subdevices[2];
+	s->type		= COMEDI_SUBD_DI;
+	s->subdev_flags	= SDF_READABLE;
+	s->n_chan	= 16;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= pcl816_di_insn_bits;
+
+	/* Digital Output subdevice */
+	s = &dev->subdevices[3];
+	s->type		= COMEDI_SUBD_DO;
+	s->subdev_flags	= SDF_WRITABLE;
+	s->n_chan	= 16;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= pcl816_do_insn_bits;
+
 	pcl816_reset(dev);
 
 	return 0;

commit fb98ec17ee55c1fea78a6513df697d7ab125e729
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:52 2014 -0700

    staging: comedi: pcl816: consolidate the interrupt code
    
    This driver only supports interrupt driven DMA transfers for async
    command support. Absorb the interrupt_pcl816_ai_mode13_dma() helper
    into the interrupt handler to clarify the code.
    
    At some point during the interrupt, comedi_event() is called to pass
    any events to the comedi subsystem. Move this to the interrupt handler.
    Add a comedi_event() call to pcl816_ai_poll() due to the removal of
    the call from transfer_from_dma_buf().
    
    For aesthetics, rename the interrupt function so it has namespace
    associated with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 348fc683f0e3..0d20fba0abea 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -286,7 +286,6 @@ static bool pcl816_ai_next_chan(struct comedi_device *dev,
 		/* all data sampled */
 		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA;
-		comedi_event(dev, s);
 		return false;
 	}
 
@@ -306,38 +305,16 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 		if (!pcl816_ai_next_chan(dev, s))
 			return;
 	}
-
-	comedi_event(dev, s);
 }
 
-static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
+static irqreturn_t pcl816_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct pcl816_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	int len, bufptr, this_dma_buf;
-	unsigned short *ptr;
-
-	this_dma_buf = devpriv->next_dma_buf;
-
-	pcl816_ai_setup_next_dma(dev, s);
-
-	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
-
-	ptr = (unsigned short *)devpriv->dmabuf[this_dma_buf];
-
-	len = (devpriv->hwdmasize >> 1) - devpriv->ai_poll_ptr;
-	bufptr = devpriv->ai_poll_ptr;
-	devpriv->ai_poll_ptr = 0;
-
-	transfer_from_dma_buf(dev, s, ptr, bufptr, len);
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t interrupt_pcl816(int irq, void *d)
-{
-	struct comedi_device *dev = d;
 	struct pcl816_private *devpriv = dev->private;
+	unsigned short *ptr;
+	unsigned int bufptr;
+	unsigned int len;
 
 	if (!dev->attached || !devpriv->ai_cmd_running) {
 		outb(0, dev->iobase + PCL816_CLRINT);
@@ -350,7 +327,20 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	return interrupt_pcl816_ai_mode13_dma(irq, d);
+	ptr = (unsigned short *)devpriv->dmabuf[devpriv->next_dma_buf];
+
+	pcl816_ai_setup_next_dma(dev, s);
+
+	len = (devpriv->hwdmasize >> 1) - devpriv->ai_poll_ptr;
+	bufptr = devpriv->ai_poll_ptr;
+	devpriv->ai_poll_ptr = 0;
+
+	transfer_from_dma_buf(dev, s, ptr, bufptr, len);
+
+	outb(0, dev->iobase + PCL816_CLRINT);
+
+	comedi_event(dev, s);
+	return IRQ_HANDLED;
 }
 
 static int pcl816_ai_cmdtest(struct comedi_device *dev,
@@ -521,6 +511,8 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
+	comedi_event(dev, s);
+
 	return s->async->buf_write_count - s->async->buf_read_count;
 }
 
@@ -676,7 +668,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* we can use IRQ 2-7 for async command support */
 	if (it->options[1] >= 2 && it->options[1] <= 7) {
-		ret = request_irq(it->options[1], interrupt_pcl816, 0,
+		ret = request_irq(it->options[1], pcl816_interrupt, 0,
 				  dev->board_name, dev);
 		if (ret == 0)
 			dev->irq = it->options[1];

commit b619f5aabd1db66e317b2d520ce3289978b6afe7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:49 2014 -0700

    staging: comedi: pcl816: remove 'int816_mode' from private data
    
    This member of the private data is not needed.
    
    Refactor the interrupt handler and the (*cancel) function to not use
    the 'int816_mode' and remove the setting of this member in the (*do_cmd)
    heler function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 632a4a4578d3..348fc683f0e3 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -64,10 +64,6 @@ Configuration Options:
 /* R: high byte of A/D W: A/D range control */
 #define PCL816_AD_HI 9
 
-/* type of interrupt handler */
-#define INT_TYPE_AI1_DMA 2
-#define INT_TYPE_AI3_DMA 5
-
 #define MAGIC_DMA_WORD 0x5a5a
 
 static const struct comedi_lrange range_pcl816 = {
@@ -113,7 +109,6 @@ struct pcl816_private {
 	int next_dma_buf;	/*  which DMA buffer will be used next round */
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
-	int int816_mode;	/*  who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma */
 	int ai_act_scan;	/*  how many scans we finished */
 	unsigned int ai_act_chanlist[16];	/*  MUX setting for actual AI operations */
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
@@ -344,8 +339,7 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl816_private *devpriv = dev->private;
 
-	if (!dev->attached || !devpriv->ai_cmd_running ||
-	    !devpriv->int816_mode) {
+	if (!dev->attached || !devpriv->ai_cmd_running) {
 		outb(0, dev->iobase + PCL816_CLRINT);
 		return IRQ_HANDLED;
 	}
@@ -356,14 +350,7 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	switch (devpriv->int816_mode) {
-	case INT_TYPE_AI1_DMA:
-	case INT_TYPE_AI3_DMA:
-		return interrupt_pcl816_ai_mode13_dma(irq, d);
-	}
-
-	outb(0, dev->iobase + PCL816_CLRINT);
-	return IRQ_HANDLED;
+	return interrupt_pcl816_ai_mode13_dma(irq, d);
 }
 
 static int pcl816_ai_cmdtest(struct comedi_device *dev,
@@ -476,8 +463,6 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	switch (cmd->convert_src) {
 	case TRIG_TIMER:
-		devpriv->int816_mode = INT_TYPE_AI1_DMA;
-
 		/*  Pacer+IRQ+DMA */
 		outb(0x32, dev->iobase + PCL816_CONTROL);
 
@@ -486,8 +471,6 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 
 	default:
-		devpriv->int816_mode = INT_TYPE_AI3_DMA;
-
 		/*  Ext trig+IRQ+DMA */
 		outb(0x34, dev->iobase + PCL816_CONTROL);
 
@@ -549,34 +532,28 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 	if (!devpriv->ai_cmd_running)
 		return 0;
 
-	switch (devpriv->int816_mode) {
-	case INT_TYPE_AI1_DMA:
-	case INT_TYPE_AI3_DMA:
-		disable_dma(devpriv->dma);
-		outb(inb(dev->iobase + PCL816_CONTROL) & 0x73,
-			dev->iobase + PCL816_CONTROL);	/* Stop A/D */
-		udelay(1);
-		outb(0, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
-
-		/* Stop pacer */
-		i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
-				2, I8254_MODE0 | I8254_BINARY);
-		i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
-				1, I8254_MODE0 | I8254_BINARY);
-
-		outb(0, dev->iobase + PCL816_AD_LO);
-		pcl816_ai_get_sample(dev, s);
-
-		/* clear INT request */
-		outb(0, dev->iobase + PCL816_CLRINT);
+	disable_dma(devpriv->dma);
+	outb(inb(dev->iobase + PCL816_CONTROL) & 0x73,
+	     dev->iobase + PCL816_CONTROL);	/* Stop A/D */
+	udelay(1);
+	outb(0, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
 
-		/* Stop A/D */
-		outb(0, dev->iobase + PCL816_CONTROL);
-		devpriv->ai_cmd_running = 0;
-		devpriv->ai_cmd_canceled = 1;
-		devpriv->int816_mode = 0;
-		break;
-	}
+	/* Stop pacer */
+	i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
+			2, I8254_MODE0 | I8254_BINARY);
+	i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
+			1, I8254_MODE0 | I8254_BINARY);
+
+	outb(0, dev->iobase + PCL816_AD_LO);
+	pcl816_ai_get_sample(dev, s);
+
+	/* clear INT request */
+	outb(0, dev->iobase + PCL816_CLRINT);
+
+	/* Stop A/D */
+	outb(0, dev->iobase + PCL816_CONTROL);
+	devpriv->ai_cmd_running = 0;
+	devpriv->ai_cmd_canceled = 1;
 
 	return 0;
 }

commit d7a9f769ba0134cbcc55008f167c97227b024798
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:47 2014 -0700

    staging: comedi: pcl816: exit interrupt quick when there is nothing to do
    
    If an async ai command is not running or the int816_mode is 0 the
    interrupt routine doesn't do anything other than spew some noise and
    clear the interrupt request in the hardware.
    
    Because this driver is manually attached, the "premature interrupt"
    check in the interrupt handler should never happen. The interrupt is
    only hooked up during the attach and it's released during the detach.
    
    Combine these checks so that the interrupt function exits quick if it
    has nothing to handle. Remove the noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index e77bf9fb2a9a..632a4a4578d3 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -344,8 +344,8 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl816_private *devpriv = dev->private;
 
-	if (!dev->attached) {
-		comedi_error(dev, "premature interrupt");
+	if (!dev->attached || !devpriv->ai_cmd_running ||
+	    !devpriv->int816_mode) {
 		outb(0, dev->iobase + PCL816_CLRINT);
 		return IRQ_HANDLED;
 	}
@@ -362,13 +362,8 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 		return interrupt_pcl816_ai_mode13_dma(irq, d);
 	}
 
-	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
-	if (!devpriv->ai_cmd_running || !devpriv->int816_mode) {
-		comedi_error(dev, "bad IRQ!");
-		return IRQ_NONE;
-	}
-	comedi_error(dev, "IRQ from unknown source!");
-	return IRQ_NONE;
+	outb(0, dev->iobase + PCL816_CLRINT);
+	return IRQ_HANDLED;
 }
 
 static int pcl816_ai_cmdtest(struct comedi_device *dev,

commit edf0f32bafd92afaffca4f086be2a49ad526dfd3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:44 2014 -0700

    staging: comedi: pcl816: clarify 'irq_was_now_closed' flag in private data
    
    This flag in the private data is set when an async command is canceled with
    the ai (*cancel) operation. Rename the flag to 'ai_cmd_canceled' to clarify
    its use.
    
    Move the check for the flag in the interrupt handler. If the async command
    was canceled there is no reason to handle the interrupt. Just clear interrupt
    and return.
    
    Also, make sure to clear the interrupt when the device is not attached.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index d6dae5466023..e77bf9fb2a9a 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -120,7 +120,7 @@ struct pcl816_private {
 	unsigned int divisor1;
 	unsigned int divisor2;
 	unsigned int ai_cmd_running:1;
-	unsigned int irq_was_now_closed:1;
+	unsigned int ai_cmd_canceled:1;
 };
 
 static int check_channel_list(struct comedi_device *dev,
@@ -346,6 +346,13 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 
 	if (!dev->attached) {
 		comedi_error(dev, "premature interrupt");
+		outb(0, dev->iobase + PCL816_CLRINT);
+		return IRQ_HANDLED;
+	}
+
+	if (devpriv->ai_cmd_canceled) {
+		devpriv->ai_cmd_canceled = 0;
+		outb(0, dev->iobase + PCL816_CLRINT);
 		return IRQ_HANDLED;
 	}
 
@@ -357,11 +364,6 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
 	if (!devpriv->ai_cmd_running || !devpriv->int816_mode) {
-		if (devpriv->irq_was_now_closed) {
-			devpriv->irq_was_now_closed = 0;
-			/*  comedi_error(dev,"last IRQ.."); */
-			return IRQ_HANDLED;
-		}
 		comedi_error(dev, "bad IRQ!");
 		return IRQ_NONE;
 	}
@@ -469,7 +471,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	s->async->cur_chan = 0;
 	devpriv->ai_cmd_running = 1;
 	devpriv->ai_poll_ptr = 0;
-	devpriv->irq_was_now_closed = 0;
+	devpriv->ai_cmd_canceled = 0;
 
 	if (devpriv->dma)
 		pcl816_ai_setup_dma(dev, s);
@@ -576,7 +578,7 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 		/* Stop A/D */
 		outb(0, dev->iobase + PCL816_CONTROL);
 		devpriv->ai_cmd_running = 0;
-		devpriv->irq_was_now_closed = 1;
+		devpriv->ai_cmd_canceled = 1;
 		devpriv->int816_mode = 0;
 		break;
 	}

commit 61b3980f1f7471b1d74a8571a29710bf6937f702
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:42 2014 -0700

    staging: comedi: pcl816: reduce indent level in pcl816_ai_cancel()
    
    If an async command is not running the (*cancel) function doesn't do
    anything. Exit the function early if this is the case.
    
    This allows reducing the indent level in the rest of the function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 36599861c78b..d6dae5466023 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -549,37 +549,38 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 {
 	struct pcl816_private *devpriv = dev->private;
 
-	if (devpriv->ai_cmd_running) {
-		switch (devpriv->int816_mode) {
-		case INT_TYPE_AI1_DMA:
-		case INT_TYPE_AI3_DMA:
-			disable_dma(devpriv->dma);
-			outb(inb(dev->iobase + PCL816_CONTROL) & 0x73,
-			     dev->iobase + PCL816_CONTROL);	/* Stop A/D */
-			udelay(1);
-			outb(0, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
-
-			/* Stop pacer */
-			i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
-				       2, I8254_MODE0 | I8254_BINARY);
-			i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
-				       1, I8254_MODE0 | I8254_BINARY);
-
-			outb(0, dev->iobase + PCL816_AD_LO);
-			pcl816_ai_get_sample(dev, s);
-
-			/* clear INT request */
-			outb(0, dev->iobase + PCL816_CLRINT);
+	if (!devpriv->ai_cmd_running)
+		return 0;
 
-			/* Stop A/D */
-			outb(0, dev->iobase + PCL816_CONTROL);
-			devpriv->ai_cmd_running = 0;
-			devpriv->irq_was_now_closed = 1;
-			devpriv->int816_mode = 0;
-/* s->busy = 0; */
-			break;
-		}
+	switch (devpriv->int816_mode) {
+	case INT_TYPE_AI1_DMA:
+	case INT_TYPE_AI3_DMA:
+		disable_dma(devpriv->dma);
+		outb(inb(dev->iobase + PCL816_CONTROL) & 0x73,
+			dev->iobase + PCL816_CONTROL);	/* Stop A/D */
+		udelay(1);
+		outb(0, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
+
+		/* Stop pacer */
+		i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
+				2, I8254_MODE0 | I8254_BINARY);
+		i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
+				1, I8254_MODE0 | I8254_BINARY);
+
+		outb(0, dev->iobase + PCL816_AD_LO);
+		pcl816_ai_get_sample(dev, s);
+
+		/* clear INT request */
+		outb(0, dev->iobase + PCL816_CLRINT);
+
+		/* Stop A/D */
+		outb(0, dev->iobase + PCL816_CONTROL);
+		devpriv->ai_cmd_running = 0;
+		devpriv->irq_was_now_closed = 1;
+		devpriv->int816_mode = 0;
+		break;
 	}
+
 	return 0;
 }
 

commit 0f8837bc80dda193535a47776c19e433f24b75de
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:37 2014 -0700

    staging: comedi: pcl816: factor out the "next ai chan" code
    
    Factor out the code that bumps the counters in the private data that keep
    track of what channel is being samples next and when all the data has been
    sampled.
    
    Don't clear the events in the driver. The comedi core will clear the events
    at the end of the comedi_event().
    
    Make sure the COMEDI_CB_BLOCK event is set when advancing to the next
    channel so that when the comedi_event() is finally called the core will
    wake the async_queue to return the analog input data.
    
    Also, make sure the COMEDI_CB_EOS event is set at the completion of each
    scan.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 2498ab19daef..36599861c78b 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -271,35 +271,45 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 	return n;
 }
 
+static bool pcl816_ai_next_chan(struct comedi_device *dev,
+				struct comedi_subdevice *s)
+{
+	struct pcl816_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+
+	s->async->events |= COMEDI_CB_BLOCK;
+
+	s->async->cur_chan++;
+	if (s->async->cur_chan >= cmd->chanlist_len) {
+		s->async->cur_chan = 0;
+		devpriv->ai_act_scan++;
+		s->async->events |= COMEDI_CB_EOS;
+	}
+
+	if (cmd->stop_src == TRIG_COUNT &&
+	    devpriv->ai_act_scan >= cmd->stop_arg) {
+		/* all data sampled */
+		s->cancel(dev, s);
+		s->async->events |= COMEDI_CB_EOA;
+		comedi_event(dev, s);
+		return false;
+	}
+
+	return true;
+}
+
 static void transfer_from_dma_buf(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  unsigned short *ptr,
 				  unsigned int bufptr, unsigned int len)
 {
-	struct pcl816_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
 	int i;
 
-	s->async->events = 0;
-
 	for (i = 0; i < len; i++) {
-
 		comedi_buf_put(s->async, ptr[bufptr++]);
 
-		s->async->cur_chan++;
-		if (s->async->cur_chan >= cmd->chanlist_len) {
-			s->async->cur_chan = 0;
-			devpriv->ai_act_scan++;
-		}
-
-		if (cmd->stop_src == TRIG_COUNT &&
-		    devpriv->ai_act_scan >= cmd->stop_arg) {
-			/* all data sampled */
-			s->cancel(dev, s);
-			s->async->events |= COMEDI_CB_EOA;
-			s->async->events |= COMEDI_CB_BLOCK;
-			break;
-		}
+		if (!pcl816_ai_next_chan(dev, s))
+			return;
 	}
 
 	comedi_event(dev, s);

commit 8429504a575ded74c6267361592879cedfb7b860
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:35 2014 -0700

    staging: comedi: pcl816: only hook up async command support if DMA is available
    
    This driver only supports async commands if a DMA channel is available. Modify
    the subdevice init so that the command support only gets hooked up if we can
    do DMA.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index a4c59291568f..2498ab19daef 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -734,7 +734,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->maxdata	= board->ai_maxdata;
 	s->range_table	= &range_pcl816;
 	s->insn_read	= pcl816_ai_insn_read;
-	if (dev->irq) {
+	if (devpriv->dma) {
 		dev->read_subdev = s;
 		s->subdev_flags	|= SDF_CMD_READ;
 		s->len_chanlist	= board->ai_chanlist;

commit 885a7da351d04e8f62d201e094fc1c287ed5360b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:34 2014 -0700

    staging: comedi: pcl816: remove unreachable interrupt handler code
    
    According to the users manual, when using interrupt (non-DMA) transfers
    this hardware generates an interrupt at the start of a conversion. This
    requires the interrupt routine to busywait until the end-of-conversion.
    It appears this was unreliable and interrupt only async command support
    was removed at some time. Async command support is still available when
    DMA is used.
    
    Remove the unreachable interrupt only handler code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 66d3c5a4f2ce..a4c59291568f 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -65,9 +65,7 @@ Configuration Options:
 #define PCL816_AD_HI 9
 
 /* type of interrupt handler */
-#define INT_TYPE_AI1_INT 1
 #define INT_TYPE_AI1_DMA 2
-#define INT_TYPE_AI3_INT 4
 #define INT_TYPE_AI3_DMA 5
 
 #define MAGIC_DMA_WORD 0x5a5a
@@ -273,50 +271,6 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 	return n;
 }
 
-static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
-{
-	struct comedi_device *dev = d;
-	struct pcl816_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_cmd *cmd = &s->async->cmd;
-	int timeout = 50;	/* wait max 50us */
-
-	while (timeout--) {
-		if (!(inb(dev->iobase + PCL816_STATUS) &
-		      PCL816_STATUS_DRDY_MASK))
-			break;
-		udelay(1);
-	}
-	if (!timeout) {		/*  timeout, bail error */
-		outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
-		comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
-		s->cancel(dev, s);
-		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
-		comedi_event(dev, s);
-		return IRQ_HANDLED;
-
-	}
-
-	comedi_buf_put(s->async, pcl816_ai_get_sample(dev, s));
-
-	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
-
-	s->async->cur_chan++;
-	if (s->async->cur_chan >= cmd->chanlist_len) {
-		s->async->cur_chan = 0;
-		devpriv->ai_act_scan++;
-	}
-
-	if (cmd->stop_src == TRIG_COUNT &&
-	    devpriv->ai_act_scan >= cmd->stop_arg) {
-		/* all data sampled */
-		s->cancel(dev, s);
-		s->async->events |= COMEDI_CB_EOA;
-	}
-	comedi_event(dev, s);
-	return IRQ_HANDLED;
-}
-
 static void transfer_from_dma_buf(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  unsigned short *ptr,
@@ -389,9 +343,6 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 	case INT_TYPE_AI1_DMA:
 	case INT_TYPE_AI3_DMA:
 		return interrupt_pcl816_ai_mode13_dma(irq, d);
-	case INT_TYPE_AI1_INT:
-	case INT_TYPE_AI3_INT:
-		return interrupt_pcl816_ai_mode13_int(irq, d);
 	}
 
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
@@ -593,8 +544,6 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 		case INT_TYPE_AI1_DMA:
 		case INT_TYPE_AI3_DMA:
 			disable_dma(devpriv->dma);
-		case INT_TYPE_AI1_INT:
-		case INT_TYPE_AI3_INT:
 			outb(inb(dev->iobase + PCL816_CONTROL) & 0x73,
 			     dev->iobase + PCL816_CONTROL);	/* Stop A/D */
 			udelay(1);

commit 080ee8820d9c17b79658b03e35b6236c041068b8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:31 2014 -0700

    staging: comedi: pcl816: remove 'dmasamplesize' from private data
    
    This member of the private data is not used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 682101734807..66d3c5a4f2ce 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -112,7 +112,6 @@ struct pcl816_private {
 	unsigned int hwdmasize;
 	unsigned long dmabuf[2];	/*  pointers to begin of DMA buffers */
 	unsigned int hwdmaptr[2];	/*  hardware address of DMA buffers */
-	unsigned int dmasamplsize;	/*  size in samples hwdmasize[0]/2 */
 	int next_dma_buf;	/*  which DMA buffer will be used next round */
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */

commit 82ac3e7ad17b7abf56fa8ced301bd30fc5ca973b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:28 2014 -0700

    staging: comedi: pcl816: factor out dma setup to helper functions
    
    To assist in cleaning up the the rest of the driver, factor the initial
    dma setup and the next dma buffer setup into helper functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 1a8f65e85970..682101734807 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -152,6 +152,68 @@ static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters)
 	}
 }
 
+static void pcl816_ai_setup_dma(struct comedi_device *dev,
+				struct comedi_subdevice *s)
+{
+	struct pcl816_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int dma_flags;
+	unsigned int bytes;
+
+	bytes = devpriv->hwdmasize;
+	if (cmd->stop_src == TRIG_COUNT) {
+		/*  how many */
+		bytes = s->async->cmd.chanlist_len *
+		s->async->cmd.chanlist_len *
+		sizeof(short);
+
+		/*  how many DMA pages we must fill */
+		devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;
+
+		/* on last dma transfer must be moved */
+		devpriv->last_dma_run = bytes % devpriv->hwdmasize;
+		devpriv->dma_runs_to_end--;
+		if (devpriv->dma_runs_to_end >= 0)
+			bytes = devpriv->hwdmasize;
+	} else
+		devpriv->dma_runs_to_end = -1;
+
+	devpriv->next_dma_buf = 0;
+	set_dma_mode(devpriv->dma, DMA_MODE_READ);
+	dma_flags = claim_dma_lock();
+	clear_dma_ff(devpriv->dma);
+	set_dma_addr(devpriv->dma, devpriv->hwdmaptr[0]);
+	set_dma_count(devpriv->dma, bytes);
+	release_dma_lock(dma_flags);
+	enable_dma(devpriv->dma);
+}
+
+static void pcl816_ai_setup_next_dma(struct comedi_device *dev,
+				     struct comedi_subdevice *s)
+{
+	struct pcl816_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned long dma_flags;
+
+	disable_dma(devpriv->dma);
+	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
+		/* switch dma bufs */
+		devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
+		set_dma_mode(devpriv->dma, DMA_MODE_READ);
+		dma_flags = claim_dma_lock();
+		set_dma_addr(devpriv->dma,
+			     devpriv->hwdmaptr[devpriv->next_dma_buf]);
+		if (devpriv->dma_runs_to_end)
+			set_dma_count(devpriv->dma, devpriv->hwdmasize);
+		else
+			set_dma_count(devpriv->dma, devpriv->last_dma_run);
+		release_dma_lock(dma_flags);
+		enable_dma(devpriv->dma);
+	}
+
+	devpriv->dma_runs_to_end--;
+}
+
 static unsigned int pcl816_ai_get_sample(struct comedi_device *dev,
 					 struct comedi_subdevice *s)
 {
@@ -295,31 +357,13 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_cmd *cmd = &s->async->cmd;
 	int len, bufptr, this_dma_buf;
-	unsigned long dma_flags;
 	unsigned short *ptr;
 
-	disable_dma(devpriv->dma);
 	this_dma_buf = devpriv->next_dma_buf;
 
-	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
-		/* switch dma bufs */
-		devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
-		set_dma_mode(devpriv->dma, DMA_MODE_READ);
-		dma_flags = claim_dma_lock();
-/* clear_dma_ff (devpriv->dma); */
-		set_dma_addr(devpriv->dma,
-			     devpriv->hwdmaptr[devpriv->next_dma_buf]);
-		if (devpriv->dma_runs_to_end)
-			set_dma_count(devpriv->dma, devpriv->hwdmasize);
-		else
-			set_dma_count(devpriv->dma, devpriv->last_dma_run);
-		release_dma_lock(dma_flags);
-		enable_dma(devpriv->dma);
-	}
+	pcl816_ai_setup_next_dma(dev, s);
 
-	devpriv->dma_runs_to_end--;
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
 
 	ptr = (unsigned short *)devpriv->dmabuf[this_dma_buf];
@@ -447,7 +491,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int dma_flags, bytes, dmairq;
+	unsigned int dmairq;
 	unsigned int seglen;
 
 	if (devpriv->ai_cmd_running)
@@ -467,34 +511,8 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_poll_ptr = 0;
 	devpriv->irq_was_now_closed = 0;
 
-	if (devpriv->dma) {
-		bytes = devpriv->hwdmasize;
-		if (cmd->stop_src == TRIG_COUNT) {
-			/*  how many */
-			bytes = s->async->cmd.chanlist_len *
-			s->async->cmd.chanlist_len *
-			sizeof(short);
-
-			/*  how many DMA pages we must fill */
-			devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;
-
-			/* on last dma transfer must be moved */
-			devpriv->last_dma_run = bytes % devpriv->hwdmasize;
-			devpriv->dma_runs_to_end--;
-			if (devpriv->dma_runs_to_end >= 0)
-				bytes = devpriv->hwdmasize;
-		} else
-			devpriv->dma_runs_to_end = -1;
-
-		devpriv->next_dma_buf = 0;
-		set_dma_mode(devpriv->dma, DMA_MODE_READ);
-		dma_flags = claim_dma_lock();
-		clear_dma_ff(devpriv->dma);
-		set_dma_addr(devpriv->dma, devpriv->hwdmaptr[0]);
-		set_dma_count(devpriv->dma, bytes);
-		release_dma_lock(dma_flags);
-		enable_dma(devpriv->dma);
-	}
+	if (devpriv->dma)
+		pcl816_ai_setup_dma(dev, s);
 
 	pcl816_start_pacer(dev, true);
 	dmairq = ((devpriv->dma & 0x3) << 4) | (dev->irq & 0x7);

commit 68d7808f09082f7bbbc94486d14ecff24ee3cd5d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:25 2014 -0700

    staging: comedi: pcl816: remove 'ai_neverending' from private data
    
    This member of the private data is not needed. We can check the stop_src
    to determine this information:
    
      ai_neverending -> cmd->stop_src == TRIG_NONE
      !ai_neverending -> cmd->stop_src == TRIG_COUNT
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index c0ad0f12ee7a..1a8f65e85970 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -124,7 +124,6 @@ struct pcl816_private {
 	unsigned int divisor2;
 	unsigned int ai_cmd_running:1;
 	unsigned int irq_was_now_closed:1;
-	unsigned int ai_neverending:1;
 };
 
 static int check_channel_list(struct comedi_device *dev,
@@ -247,13 +246,12 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 		devpriv->ai_act_scan++;
 	}
 
-	if (!devpriv->ai_neverending)
-					/* all data sampled */
-		if (devpriv->ai_act_scan >= cmd->stop_arg) {
-			/* all data sampled */
-			s->cancel(dev, s);
-			s->async->events |= COMEDI_CB_EOA;
-		}
+	if (cmd->stop_src == TRIG_COUNT &&
+	    devpriv->ai_act_scan >= cmd->stop_arg) {
+		/* all data sampled */
+		s->cancel(dev, s);
+		s->async->events |= COMEDI_CB_EOA;
+	}
 	comedi_event(dev, s);
 	return IRQ_HANDLED;
 }
@@ -279,14 +277,14 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 			devpriv->ai_act_scan++;
 		}
 
-		if (!devpriv->ai_neverending)
-						/*  all data sampled */
-			if (devpriv->ai_act_scan >= cmd->stop_arg) {
-				s->cancel(dev, s);
-				s->async->events |= COMEDI_CB_EOA;
-				s->async->events |= COMEDI_CB_BLOCK;
-				break;
-			}
+		if (cmd->stop_src == TRIG_COUNT &&
+		    devpriv->ai_act_scan >= cmd->stop_arg) {
+			/* all data sampled */
+			s->cancel(dev, s);
+			s->async->events |= COMEDI_CB_EOA;
+			s->async->events |= COMEDI_CB_BLOCK;
+			break;
+		}
 	}
 
 	comedi_event(dev, s);
@@ -297,6 +295,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int len, bufptr, this_dma_buf;
 	unsigned long dma_flags;
 	unsigned short *ptr;
@@ -304,9 +303,8 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 	disable_dma(devpriv->dma);
 	this_dma_buf = devpriv->next_dma_buf;
 
-	/*  switch dma bufs */
-	if ((devpriv->dma_runs_to_end > -1) || devpriv->ai_neverending) {
-
+	if (devpriv->dma_runs_to_end > -1 || cmd->stop_src == TRIG_NONE) {
+		/* switch dma bufs */
 		devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
 		set_dma_mode(devpriv->dma, DMA_MODE_READ);
 		dma_flags = claim_dma_lock();
@@ -469,14 +467,9 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_poll_ptr = 0;
 	devpriv->irq_was_now_closed = 0;
 
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->ai_neverending = 0;
-	else
-		devpriv->ai_neverending = 1;
-
 	if (devpriv->dma) {
 		bytes = devpriv->hwdmasize;
-		if (!devpriv->ai_neverending) {
+		if (cmd->stop_src == TRIG_COUNT) {
 			/*  how many */
 			bytes = s->async->cmd.chanlist_len *
 			s->async->cmd.chanlist_len *

commit 3b84e790cf986d20f95331c062b492ee9832ee70
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 4 11:29:21 2014 -0700

    staging: comedi: pcl816: remove pcl816_check()
    
    This function is a _very_ simplified probe that tried to verify that
    the driver is being attached to a PCL-816 compatible board. The function
    simply writes some values to specific registers then reads back the
    values to see if they are the same.
    
    It's possible that the user could try to attach this driver to a non-
    compatible board but the check would still pass depending on the register
    map of the board.
    
    Just remove the buggy function to simplify the attach a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 2e383ebde119..c0ad0f12ee7a 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -714,30 +714,6 @@ setup_channel_list(struct comedi_device *dev,
 	     dev->iobase + PCL816_MUX);
 }
 
-static int pcl816_check(struct comedi_device *dev)
-{
-	/* the MUX register should return the same value written */
-	outb(0x00, dev->iobase + PCL816_MUX);
-	if (inb(dev->iobase + PCL816_MUX) != 0x00)
-		return -ENODEV;
-	outb(0x55, dev->iobase + PCL816_MUX);
-	if (inb(dev->iobase + PCL816_MUX) != 0x55)
-		return -ENODEV;
-
-	/* reset the MUX register to a known state */
-	outb(0x00, dev->iobase + PCL816_MUX);
-
-	/* the CONTROL register should return the same value written */
-	outb(0x18, dev->iobase + PCL816_CONTROL);
-	if (inb(dev->iobase + PCL816_CONTROL) != 0x18)
-		return -ENODEV;
-
-	/* reset the CONTROL register to a known state */
-	outb(0x00, dev->iobase + PCL816_CONTROL);
-
-	return 0;
-}
-
 static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl816_board *board = comedi_board(dev);
@@ -754,10 +730,6 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	ret = pcl816_check(dev);
-	if (ret)
-		return ret;
-
 	/* we can use IRQ 2-7 for async command support */
 	if (it->options[1] >= 2 && it->options[1] <= 7) {
 		ret = request_irq(it->options[1], interrupt_pcl816, 0,

commit c36d44ace681cdbed05d06df736e772a80e20992
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Feb 19 10:11:31 2014 -0700

    staging: comedi: pcl816: tidy up pcl818_check()
    
    This function probes a number of the boards registers during the
    (*attach) to verify that it is actually a PCL-816 compatible board.
    For aesthetics, move the function closer to the (*attach).
    
    To better match the pcl818 driver, allocate the private data before
    calling pcl816_check().
    
    Refactor the function to return an errno if fails. Change the errno
    from -EIO to -ENODEV and remove the unnecessary dev_err() noise.
    
    Make sure the CONTROL register is reset to a known state after the
    check. The 0x18 value actually defines an invalid interrupt selection
    and sets an undefined bit.
    
    Add a couple comments to clarify the magic values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index aae2947281df..2e383ebde119 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -614,25 +614,6 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static int pcl816_check(unsigned long iobase)
-{
-	outb(0x00, iobase + PCL816_MUX);
-	udelay(1);
-	if (inb(iobase + PCL816_MUX) != 0x00)
-		return 1;	/* there isn't card */
-	outb(0x55, iobase + PCL816_MUX);
-	udelay(1);
-	if (inb(iobase + PCL816_MUX) != 0x55)
-		return 1;	/* there isn't card */
-	outb(0x00, iobase + PCL816_MUX);
-	udelay(1);
-	outb(0x18, iobase + PCL816_CONTROL);
-	udelay(1);
-	if (inb(iobase + PCL816_CONTROL) != 0x18)
-		return 1;	/* there isn't card */
-	return 0;		/*  ok, card exist */
-}
-
 static void pcl816_reset(struct comedi_device *dev)
 {
 	unsigned long timer_base = dev->iobase + PCL816_TIMER_BASE;
@@ -733,6 +714,30 @@ setup_channel_list(struct comedi_device *dev,
 	     dev->iobase + PCL816_MUX);
 }
 
+static int pcl816_check(struct comedi_device *dev)
+{
+	/* the MUX register should return the same value written */
+	outb(0x00, dev->iobase + PCL816_MUX);
+	if (inb(dev->iobase + PCL816_MUX) != 0x00)
+		return -ENODEV;
+	outb(0x55, dev->iobase + PCL816_MUX);
+	if (inb(dev->iobase + PCL816_MUX) != 0x55)
+		return -ENODEV;
+
+	/* reset the MUX register to a known state */
+	outb(0x00, dev->iobase + PCL816_MUX);
+
+	/* the CONTROL register should return the same value written */
+	outb(0x18, dev->iobase + PCL816_CONTROL);
+	if (inb(dev->iobase + PCL816_CONTROL) != 0x18)
+		return -ENODEV;
+
+	/* reset the CONTROL register to a known state */
+	outb(0x00, dev->iobase + PCL816_CONTROL);
+
+	return 0;
+}
+
 static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl816_board *board = comedi_board(dev);
@@ -741,18 +746,17 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int ret;
 	int i;
 
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
+	if (!devpriv)
+		return -ENOMEM;
+
 	ret = comedi_request_region(dev, it->options[0], 0x10);
 	if (ret)
 		return ret;
 
-	if (pcl816_check(dev->iobase)) {
-		dev_err(dev->class_dev, "I can't detect board. FAIL!\n");
-		return -EIO;
-	}
-
-	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
-	if (!devpriv)
-		return -ENOMEM;
+	ret = pcl816_check(dev);
+	if (ret)
+		return ret;
 
 	/* we can use IRQ 2-7 for async command support */
 	if (it->options[1] >= 2 && it->options[1] <= 7) {

commit f51eb4f4b9c2021583f2243e75c6a46b5a018144
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Feb 19 10:11:30 2014 -0700

    staging: comedi: pcl816: remove unnecessary function separation comments
    
    These comments are just added cruft. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 4742bc8f3aa4..aae2947281df 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -127,9 +127,6 @@ struct pcl816_private {
 	unsigned int ai_neverending:1;
 };
 
-/*
-==============================================================================
-*/
 static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      unsigned int *chanlist, unsigned int chanlen);
@@ -216,11 +213,6 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 	return n;
 }
 
-/*
-==============================================================================
-   analog input interrupt mode 1 & 3, 818 cards
-   one sample per interrupt version
-*/
 static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -266,10 +258,6 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-/*
-==============================================================================
-   analog input dma mode 1 & 3, 816 cards
-*/
 static void transfer_from_dma_buf(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  unsigned short *ptr,
@@ -346,10 +334,6 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-/*
-==============================================================================
-    INT procedure
-*/
 static irqreturn_t interrupt_pcl816(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -383,9 +367,6 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 	return IRQ_NONE;
 }
 
-/*
-==============================================================================
-*/
 static int pcl816_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
@@ -592,10 +573,6 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 	return s->async->buf_write_count - s->async->buf_read_count;
 }
 
-/*
-==============================================================================
- cancel any mode 1-4 AI
-*/
 static int pcl816_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
@@ -637,10 +614,6 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-/*
-==============================================================================
- chech for PCL816
-*/
 static int pcl816_check(unsigned long iobase)
 {
 	outb(0x00, iobase + PCL816_MUX);
@@ -660,10 +633,6 @@ static int pcl816_check(unsigned long iobase)
 	return 0;		/*  ok, card exist */
 }
 
-/*
-==============================================================================
- reset whole PCL-816 cards
-*/
 static void pcl816_reset(struct comedi_device *dev)
 {
 	unsigned long timer_base = dev->iobase + PCL816_TIMER_BASE;
@@ -686,11 +655,6 @@ static void pcl816_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + PCL816_RANGE);
 }
 
-/*
-==============================================================================
- Check if channel list from user is built correctly
- If it's ok, then return non-zero length of repeated segment of channel list
-*/
 static int
 check_channel_list(struct comedi_device *dev,
 		   struct comedi_subdevice *s, unsigned int *chanlist,
@@ -747,10 +711,6 @@ check_channel_list(struct comedi_device *dev,
 	return seglen;	/*  we can serve this with MUX logic */
 }
 
-/*
-==============================================================================
- Program scan/gain logic with channel list.
-*/
 static void
 setup_channel_list(struct comedi_device *dev,
 		   struct comedi_subdevice *s, unsigned int *chanlist,

commit bf6e48e87c6df4a0a409d0bb7017095aa8da1504
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Feb 19 10:11:29 2014 -0700

    staging: comedi: pcl816: remove unnecessary 'dev->irq' check
    
    If the dev->irq is not valid the interrupt function will not be hooked
    up during the attach. Remove the unnecessary check.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index ab0100304732..4742bc8f3aa4 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -370,7 +370,7 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 	}
 
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
-	if (!dev->irq || !devpriv->ai_cmd_running || !devpriv->int816_mode) {
+	if (!devpriv->ai_cmd_running || !devpriv->int816_mode) {
 		if (devpriv->irq_was_now_closed) {
 			devpriv->irq_was_now_closed = 0;
 			/*  comedi_error(dev,"last IRQ.."); */

commit 94349cb9cb540ef3351b691a675821a220fda1d0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Feb 19 10:11:28 2014 -0700

    staging: comedi: pcl816: rename 'irq_blocked' in private data
    
    This member in the private data is a flag that indicates that an analog
    input async command is currently running. Rename it to make this clear.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index ee7aca1c067b..ab0100304732 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -122,7 +122,7 @@ struct pcl816_private {
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
 	unsigned int divisor1;
 	unsigned int divisor2;
-	unsigned int irq_blocked:1;
+	unsigned int ai_cmd_running:1;
 	unsigned int irq_was_now_closed:1;
 	unsigned int ai_neverending:1;
 };
@@ -370,7 +370,7 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 	}
 
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
-	if (!dev->irq || !devpriv->irq_blocked || !devpriv->int816_mode) {
+	if (!dev->irq || !devpriv->ai_cmd_running || !devpriv->int816_mode) {
 		if (devpriv->irq_was_now_closed) {
 			devpriv->irq_was_now_closed = 0;
 			/*  comedi_error(dev,"last IRQ.."); */
@@ -471,7 +471,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned int dma_flags, bytes, dmairq;
 	unsigned int seglen;
 
-	if (devpriv->irq_blocked)
+	if (devpriv->ai_cmd_running)
 		return -EBUSY;
 
 	pcl816_start_pacer(dev, false);
@@ -484,7 +484,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	devpriv->ai_act_scan = 0;
 	s->async->cur_chan = 0;
-	devpriv->irq_blocked = 1;
+	devpriv->ai_cmd_running = 1;
 	devpriv->ai_poll_ptr = 0;
 	devpriv->irq_was_now_closed = 0;
 
@@ -601,7 +601,7 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 {
 	struct pcl816_private *devpriv = dev->private;
 
-	if (devpriv->irq_blocked) {
+	if (devpriv->ai_cmd_running) {
 		switch (devpriv->int816_mode) {
 		case INT_TYPE_AI1_DMA:
 		case INT_TYPE_AI3_DMA:
@@ -627,7 +627,7 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 
 			/* Stop A/D */
 			outb(0, dev->iobase + PCL816_CONTROL);
-			devpriv->irq_blocked = 0;
+			devpriv->ai_cmd_running = 0;
 			devpriv->irq_was_now_closed = 1;
 			devpriv->int816_mode = 0;
 /* s->busy = 0; */

commit efd5b7b5d79010ae147e384185b8ac594d028850
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Feb 19 10:11:27 2014 -0700

    staging: comedi: pcl816: kzalloc'ed memory does not need to be cleared
    
    The private data is kzalloc'ed in the (*attach). There is no need to
    initialize any of the members to 0.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 36c8c05a2f11..ee7aca1c067b 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -802,9 +802,6 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			dev->irq = it->options[1];
 	}
 
-	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
-	devpriv->int816_mode = 0;	/* mode of irq */
-
 	/* we need an IRQ to do DMA on channel 3 or 1 */
 	if (dev->irq && (it->options[2] == 3 || it->options[2] == 1)) {
 		ret = request_dma(it->options[2], dev->board_name);

commit ab3c44fa38b30b990fd1a29e5954b044488ff990
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Feb 19 10:11:26 2014 -0700

    staging: comedi: pcl816: convert private data flags to bit-fields
    
    The 'irq_was_now_closed' member is actually a flag, devpriv->int816_mode
    will always be > 0 when it's used to set irq_was_now_closed in the cancel
    function.
    
    Convert the flags in the private data to bit-fields to save a bit of
    space.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 54d75a7f866e..36c8c05a2f11 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -116,15 +116,15 @@ struct pcl816_private {
 	int next_dma_buf;	/*  which DMA buffer will be used next round */
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
-	unsigned char ai_neverending;	/*  if=1, then we do neverending record (you must use cancel()) */
-	int irq_blocked;	/*  1=IRQ now uses any subdev */
-	int irq_was_now_closed;	/*  when IRQ finish, there's stored int816_mode for last interrupt */
 	int int816_mode;	/*  who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma */
 	int ai_act_scan;	/*  how many scans we finished */
 	unsigned int ai_act_chanlist[16];	/*  MUX setting for actual AI operations */
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
 	unsigned int divisor1;
 	unsigned int divisor2;
+	unsigned int irq_blocked:1;
+	unsigned int irq_was_now_closed:1;
+	unsigned int ai_neverending:1;
 };
 
 /*
@@ -601,7 +601,7 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 {
 	struct pcl816_private *devpriv = dev->private;
 
-	if (devpriv->irq_blocked > 0) {
+	if (devpriv->irq_blocked) {
 		switch (devpriv->int816_mode) {
 		case INT_TYPE_AI1_DMA:
 		case INT_TYPE_AI3_DMA:
@@ -628,7 +628,7 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 			/* Stop A/D */
 			outb(0, dev->iobase + PCL816_CONTROL);
 			devpriv->irq_blocked = 0;
-			devpriv->irq_was_now_closed = devpriv->int816_mode;
+			devpriv->irq_was_now_closed = 1;
 			devpriv->int816_mode = 0;
 /* s->busy = 0; */
 			break;

commit 0f9c4c7e38c7e1f6669093e8220067fafb8dcae6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Feb 19 10:11:25 2014 -0700

    staging: comedi: pcl816: remove 'ai_act_chanlist_{len, pos}' from private data
    
    These members of the private data don't do anything usefull. Just remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 0d2eaa9fc04c..54d75a7f866e 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -122,8 +122,6 @@ struct pcl816_private {
 	int int816_mode;	/*  who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma */
 	int ai_act_scan;	/*  how many scans we finished */
 	unsigned int ai_act_chanlist[16];	/*  MUX setting for actual AI operations */
-	unsigned int ai_act_chanlist_len;	/*  how long is actual MUX list */
-	unsigned int ai_act_chanlist_pos;	/*  actual position in MUX list */
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
 	unsigned int divisor1;
 	unsigned int divisor2;
@@ -251,9 +249,6 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
 
-	if (++devpriv->ai_act_chanlist_pos >= devpriv->ai_act_chanlist_len)
-		devpriv->ai_act_chanlist_pos = 0;
-
 	s->async->cur_chan++;
 	if (s->async->cur_chan >= cmd->chanlist_len) {
 		s->async->cur_chan = 0;
@@ -290,11 +285,6 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 
 		comedi_buf_put(s->async, ptr[bufptr++]);
 
-		if (++devpriv->ai_act_chanlist_pos >=
-		    devpriv->ai_act_chanlist_len) {
-			devpriv->ai_act_chanlist_pos = 0;
-		}
-
 		s->async->cur_chan++;
 		if (s->async->cur_chan >= cmd->chanlist_len) {
 			s->async->cur_chan = 0;
@@ -769,9 +759,6 @@ setup_channel_list(struct comedi_device *dev,
 	struct pcl816_private *devpriv = dev->private;
 	unsigned int i;
 
-	devpriv->ai_act_chanlist_len = seglen;
-	devpriv->ai_act_chanlist_pos = 0;
-
 	for (i = 0; i < seglen; i++) {	/*  store range list to card */
 		devpriv->ai_act_chanlist[i] = CR_CHAN(chanlist[i]);
 		outb(CR_CHAN(chanlist[0]) & 0xf, dev->iobase + PCL816_MUX);

commit a3ab029e8389de87f7e0b7af0fda21c5041d877f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Feb 19 10:11:24 2014 -0700

    staging: comedi: pcl816: use subdevice (*cancel)
    
    Use the subdevice (*cancel) operation to remove the need for a forward
    declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index a8302daf4301..0d2eaa9fc04c 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -138,8 +138,6 @@ static int check_channel_list(struct comedi_device *dev,
 static void setup_channel_list(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       unsigned int *chanlist, unsigned int seglen);
-static int pcl816_ai_cancel(struct comedi_device *dev,
-			    struct comedi_subdevice *s);
 
 static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters)
 {
@@ -242,7 +240,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 	if (!timeout) {		/*  timeout, bail error */
 		outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
 		comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
-		pcl816_ai_cancel(dev, s);
+		s->cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		comedi_event(dev, s);
 		return IRQ_HANDLED;
@@ -266,7 +264,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 					/* all data sampled */
 		if (devpriv->ai_act_scan >= cmd->stop_arg) {
 			/* all data sampled */
-			pcl816_ai_cancel(dev, s);
+			s->cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA;
 		}
 	comedi_event(dev, s);
@@ -306,7 +304,7 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 		if (!devpriv->ai_neverending)
 						/*  all data sampled */
 			if (devpriv->ai_act_scan >= cmd->stop_arg) {
-				pcl816_ai_cancel(dev, s);
+				s->cancel(dev, s);
 				s->async->events |= COMEDI_CB_EOA;
 				s->async->events |= COMEDI_CB_BLOCK;
 				break;

commit f23068ec57acd6fb0bf4c69075072350a5ff849a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Feb 19 10:11:23 2014 -0700

    staging: comedi: pcl816: don't calc the timer divisors twice
    
    The timer divisors are calculated in the (*do_cmdtest) before the (*do_cmd)
    is called by the comedi core. The extra sanity checks in the (*do_cmd) are
    not necessary, the values returned from i8253_cascade_ns_to_timer() will be
    greater than 1. Save the values in the private data so they don't need to be
    recalced.
    
    Refactor pcl816_start_pacer() to use the values from the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index cfda332ef715..a8302daf4301 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -125,6 +125,8 @@ struct pcl816_private {
 	unsigned int ai_act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int ai_act_chanlist_pos;	/*  actual position in MUX list */
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
+	unsigned int divisor1;
+	unsigned int divisor2;
 };
 
 /*
@@ -139,9 +141,9 @@ static void setup_channel_list(struct comedi_device *dev,
 static int pcl816_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s);
 
-static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters,
-			       unsigned int divisor1, unsigned int divisor2)
+static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters)
 {
+	struct pcl816_private *devpriv = dev->private;
 	unsigned long timer_base = dev->iobase + PCL816_TIMER_BASE;
 
 	i8254_set_mode(timer_base, 0, 0, I8254_MODE1 | I8254_BINARY);
@@ -153,8 +155,8 @@ static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters,
 	udelay(1);
 
 	if (load_counters) {
-		i8254_write(timer_base, 0, 2, divisor2);
-		i8254_write(timer_base, 0, 1, divisor1);
+		i8254_write(timer_base, 0, 2, devpriv->divisor2);
+		i8254_write(timer_base, 0, 1, devpriv->divisor1);
 	}
 }
 
@@ -399,8 +401,9 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 static int pcl816_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
+	struct pcl816_private *devpriv = dev->private;
 	int err = 0;
-	int tmp, divisor1 = 0, divisor2 = 0;
+	int tmp;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -449,7 +452,8 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-					  &divisor1, &divisor2,
+					  &devpriv->divisor1,
+					  &devpriv->divisor2,
 					  &cmd->convert_arg, cmd->flags);
 		if (cmd->convert_arg < 10000)
 			cmd->convert_arg = 10000;
@@ -475,33 +479,14 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pcl816_private *devpriv = dev->private;
-	unsigned int divisor1 = 0, divisor2 = 0, dma_flags, bytes, dmairq;
 	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int dma_flags, bytes, dmairq;
 	unsigned int seglen;
 
 	if (devpriv->irq_blocked)
 		return -EBUSY;
 
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < 10000)
-			cmd->convert_arg = 10000;
-
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-					  &divisor1, &divisor2,
-					  &cmd->convert_arg, cmd->flags);
-
-		/*  PCL816 crash if any divisor is set to 1 */
-		if (divisor1 == 1) {
-			divisor1 = 2;
-			divisor2 /= 2;
-		}
-		if (divisor2 == 1) {
-			divisor2 = 2;
-			divisor1 /= 2;
-		}
-	}
-
-	pcl816_start_pacer(dev, false, 0, 0);
+	pcl816_start_pacer(dev, false);
 
 	seglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);
 	if (seglen < 1)
@@ -549,7 +534,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		enable_dma(devpriv->dma);
 	}
 
-	pcl816_start_pacer(dev, true, divisor1, divisor2);
+	pcl816_start_pacer(dev, true);
 	dmairq = ((devpriv->dma & 0x3) << 4) | (dev->irq & 0x7);
 
 	switch (cmd->convert_src) {

commit e5f376df8b13cf09220a8003469b10a9b8095d3c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Feb 19 10:11:22 2014 -0700

    staging: comedi: pcl816: clarify irq request in pcl816_attach()
    
    All the board types can use IRQ 2-7 for async command support. Remove
    the 'IRQbits', which is a mask of the valid IRQs, from the boardinfo
    and refactor pcl816_attach().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index b76e9d6f9386..cfda332ef715 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -87,7 +87,6 @@ static const struct comedi_lrange range_pcl816 = {
 
 struct pcl816_board {
 	const char *name;
-	unsigned int IRQbits;
 	int ai_maxdata;
 	int ao_maxdata;
 	int ai_chanlist;
@@ -96,13 +95,11 @@ struct pcl816_board {
 static const struct pcl816_board boardtypes[] = {
 	{
 		.name		= "pcl816",
-		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xffff,
 		.ao_maxdata	= 0xffff,
 		.ai_chanlist	= 1024,
 	}, {
 		.name		= "pcl814b",
-		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0x3fff,
 		.ao_maxdata	= 0x3fff,
 		.ai_chanlist	= 1024,
@@ -827,7 +824,8 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!devpriv)
 		return -ENOMEM;
 
-	if ((1 << it->options[1]) & board->IRQbits) {
+	/* we can use IRQ 2-7 for async command support */
+	if (it->options[1] >= 2 && it->options[1] <= 7) {
 		ret = request_irq(it->options[1], interrupt_pcl816, 0,
 				  dev->board_name, dev);
 		if (ret == 0)

commit 31baee58a6c797f399e8b673e5db96a7aeccef44
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Feb 19 10:11:21 2014 -0700

    staging: comedi: pcl816: remove 'n_aochan' from boardinfo
    
    This member of the boardinfo is the same for all board types. Remove this
    data from the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index cabc5fe26df6..b76e9d6f9386 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -87,7 +87,6 @@ static const struct comedi_lrange range_pcl816 = {
 
 struct pcl816_board {
 	const char *name;
-	int n_aochan;
 	unsigned int IRQbits;
 	int ai_maxdata;
 	int ao_maxdata;
@@ -97,14 +96,12 @@ struct pcl816_board {
 static const struct pcl816_board boardtypes[] = {
 	{
 		.name		= "pcl816",
-		.n_aochan	= 1,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xffff,
 		.ao_maxdata	= 0xffff,
 		.ai_chanlist	= 1024,
 	}, {
 		.name		= "pcl814b",
-		.n_aochan	= 1,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0x3fff,
 		.ao_maxdata	= 0x3fff,
@@ -890,7 +887,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 #if 0
 	subdevs[1] = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
-	s->n_chan = board->n_aochan;
+	s->n_chan = 1;
 	s->maxdata = board->ao_maxdata;
 	s->range_table = &range_pcl816;
 	break;

commit d39c5ed7cb06b04d99f2b8f88ef70a657fe7b7ee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Feb 19 10:11:20 2014 -0700

    staging: comedi: pcl816: remove 'ai_ns_min' from boardinfo
    
    This member of the boardinfo is the same for all board types. Remove this
    data from the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index e27457dd16fe..cabc5fe26df6 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -87,7 +87,6 @@ static const struct comedi_lrange range_pcl816 = {
 
 struct pcl816_board {
 	const char *name;
-	unsigned int ai_ns_min;
 	int n_aochan;
 	unsigned int IRQbits;
 	int ai_maxdata;
@@ -98,7 +97,6 @@ struct pcl816_board {
 static const struct pcl816_board boardtypes[] = {
 	{
 		.name		= "pcl816",
-		.ai_ns_min	= 10000,
 		.n_aochan	= 1,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xffff,
@@ -106,7 +104,6 @@ static const struct pcl816_board boardtypes[] = {
 		.ai_chanlist	= 1024,
 	}, {
 		.name		= "pcl814b",
-		.ai_ns_min	= 10000,
 		.n_aochan	= 1,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0x3fff,
@@ -408,7 +405,6 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 static int pcl816_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	const struct pcl816_board *board = comedi_board(dev);
 	int err = 0;
 	int tmp, divisor1 = 0, divisor2 = 0;
 
@@ -440,8 +436,7 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
 	if (cmd->convert_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 board->ai_ns_min);
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg, 10000);
 	else	/* TRIG_EXT */
 		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 
@@ -462,8 +457,8 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
 					  &divisor1, &divisor2,
 					  &cmd->convert_arg, cmd->flags);
-		if (cmd->convert_arg < board->ai_ns_min)
-			cmd->convert_arg = board->ai_ns_min;
+		if (cmd->convert_arg < 10000)
+			cmd->convert_arg = 10000;
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -485,7 +480,6 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 
 static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct pcl816_board *board = comedi_board(dev);
 	struct pcl816_private *devpriv = dev->private;
 	unsigned int divisor1 = 0, divisor2 = 0, dma_flags, bytes, dmairq;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -495,8 +489,8 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EBUSY;
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < board->ai_ns_min)
-			cmd->convert_arg = board->ai_ns_min;
+		if (cmd->convert_arg < 10000)
+			cmd->convert_arg = 10000;
 
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
 					  &divisor1, &divisor2,

commit 7440df0222bef37552dd5b3b7dd86e63f5029165
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:36 2014 -0700

    staging: comedi: pcl816: remove unneeded forward declarations
    
    These forward declarations are not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 998f7b49c1c7..e27457dd16fe 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -148,11 +148,6 @@ static void setup_channel_list(struct comedi_device *dev,
 static int pcl816_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s);
 
-static int pcl816_ai_cmdtest(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_cmd *cmd);
-static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-
 static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters,
 			       unsigned int divisor1, unsigned int divisor2)
 {

commit 15e222c1067fd6bbc2dc09fdab1c5f22ac232823
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:34 2014 -0700

    staging: comedi: pcl816: use 8253.h helpers
    
    Use the helper functions in 8253.h to clarify the timer programming.
    
    Move start_pacer() to remove the need for the forward declarations.
    Rename the function so it has namespace associated with the driver.
    
    Change the 'mode' parameter. This parameter is really a flag to the
    function indicating if the divisors should be loaded into the timers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 64355eae75e8..998f7b49c1c7 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -44,12 +44,7 @@ Configuration Options:
 #include "comedi_fc.h"
 #include "8253.h"
 
-/* INTEL 8254 counters */
-#define PCL816_CTR0 4
-#define PCL816_CTR1 5
-#define PCL816_CTR2 6
-/* R: counter read-back register W: counter control */
-#define PCL816_CTRCTL 7
+#define PCL816_TIMER_BASE			0x04
 
 /* R: A/D high byte W: A/D range control */
 #define PCL816_RANGE 9
@@ -152,14 +147,31 @@ static void setup_channel_list(struct comedi_device *dev,
 			       unsigned int *chanlist, unsigned int seglen);
 static int pcl816_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s);
-static void start_pacer(struct comedi_device *dev, int mode,
-			unsigned int divisor1, unsigned int divisor2);
 
 static int pcl816_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_cmd *cmd);
 static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 
+static void pcl816_start_pacer(struct comedi_device *dev, bool load_counters,
+			       unsigned int divisor1, unsigned int divisor2)
+{
+	unsigned long timer_base = dev->iobase + PCL816_TIMER_BASE;
+
+	i8254_set_mode(timer_base, 0, 0, I8254_MODE1 | I8254_BINARY);
+	i8254_write(timer_base, 0, 0, 0x00ff);
+	udelay(1);
+
+	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
+	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
+	udelay(1);
+
+	if (load_counters) {
+		i8254_write(timer_base, 0, 2, divisor2);
+		i8254_write(timer_base, 0, 1, divisor1);
+	}
+}
+
 static unsigned int pcl816_ai_get_sample(struct comedi_device *dev,
 					 struct comedi_subdevice *s)
 {
@@ -506,7 +518,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		}
 	}
 
-	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
+	pcl816_start_pacer(dev, false, 0, 0);
 
 	seglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);
 	if (seglen < 1)
@@ -554,7 +566,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		enable_dma(devpriv->dma);
 	}
 
-	start_pacer(dev, 1, divisor1, divisor2);
+	pcl816_start_pacer(dev, true, divisor1, divisor2);
 	dmairq = ((devpriv->dma & 0x3) << 4) | (dev->irq & 0x7);
 
 	switch (cmd->convert_src) {
@@ -646,8 +658,11 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 			outb(0, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
 
 			/* Stop pacer */
-			outb(0xb0, dev->iobase + PCL816_CTRCTL);
-			outb(0x70, dev->iobase + PCL816_CTRCTL);
+			i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
+				       2, I8254_MODE0 | I8254_BINARY);
+			i8254_set_mode(dev->iobase + PCL816_TIMER_BASE, 0,
+				       1, I8254_MODE0 | I8254_BINARY);
+
 			outb(0, dev->iobase + PCL816_AD_LO);
 			pcl816_ai_get_sample(dev, s);
 
@@ -695,6 +710,8 @@ static int pcl816_check(unsigned long iobase)
 */
 static void pcl816_reset(struct comedi_device *dev)
 {
+	unsigned long timer_base = dev->iobase + PCL816_TIMER_BASE;
+
 /* outb (0, dev->iobase + PCL818_DA_LO);         DAC=0V */
 /* outb (0, dev->iobase + PCL818_DA_HI); */
 /* udelay (1); */
@@ -704,42 +721,13 @@ static void pcl816_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + PCL816_CONTROL);
 	outb(0, dev->iobase + PCL816_MUX);
 	outb(0, dev->iobase + PCL816_CLRINT);
-	outb(0xb0, dev->iobase + PCL816_CTRCTL);	/* Stop pacer */
-	outb(0x70, dev->iobase + PCL816_CTRCTL);
-	outb(0x30, dev->iobase + PCL816_CTRCTL);
-	outb(0, dev->iobase + PCL816_RANGE);
-}
-
-/*
-==============================================================================
- Start/stop pacer onboard pacer
-*/
-static void
-start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	    unsigned int divisor2)
-{
-	outb(0x32, dev->iobase + PCL816_CTRCTL);
-	outb(0xff, dev->iobase + PCL816_CTR0);
-	outb(0x00, dev->iobase + PCL816_CTR0);
-	udelay(1);
-
-	/*  set counter 2 as mode 3 */
-	outb(0xb4, dev->iobase + PCL816_CTRCTL);
-	/*  set counter 1 as mode 3 */
-	outb(0x74, dev->iobase + PCL816_CTRCTL);
-	udelay(1);
 
-	if (mode == 1) {
-		dev_dbg(dev->class_dev, "mode %d, divisor1 %d, divisor2 %d\n",
-			mode, divisor1, divisor2);
-		outb(divisor2 & 0xff, dev->iobase + PCL816_CTR2);
-		outb((divisor2 >> 8) & 0xff, dev->iobase + PCL816_CTR2);
-		outb(divisor1 & 0xff, dev->iobase + PCL816_CTR1);
-		outb((divisor1 >> 8) & 0xff, dev->iobase + PCL816_CTR1);
-	}
+	/* Stop pacer */
+	i8254_set_mode(timer_base, 0, 2, I8254_MODE0 | I8254_BINARY);
+	i8254_set_mode(timer_base, 0, 1, I8254_MODE0 | I8254_BINARY);
+	i8254_set_mode(timer_base, 0, 0, I8254_MODE0 | I8254_BINARY);
 
-	/* clear pending interrupts (just in case) */
-/* outb(0, dev->iobase + PCL816_CLRINT); */
+	outb(0, dev->iobase + PCL816_RANGE);
 }
 
 /*

commit b14ec4bd3f576be2bb7dd4c69764a422d782e06d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:31 2014 -0700

    staging: comedi: pcl816: remove 'last_int_sub' from private data
    
    THis member of the private data is set but never used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 29d462513c62..64355eae75e8 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -134,7 +134,6 @@ struct pcl816_private {
 	int irq_blocked;	/*  1=IRQ now uses any subdev */
 	int irq_was_now_closed;	/*  when IRQ finish, there's stored int816_mode for last interrupt */
 	int int816_mode;	/*  who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma */
-	struct comedi_subdevice *last_int_sub;	/*  ptr to subdevice which now finish */
 	int ai_act_scan;	/*  how many scans we finished */
 	unsigned int ai_act_chanlist[16];	/*  MUX setting for actual AI operations */
 	unsigned int ai_act_chanlist_len;	/*  how long is actual MUX list */
@@ -660,7 +659,6 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 			devpriv->irq_blocked = 0;
 			devpriv->irq_was_now_closed = devpriv->int816_mode;
 			devpriv->int816_mode = 0;
-			devpriv->last_int_sub = s;
 /* s->busy = 0; */
 			break;
 		}

commit 55b95f14304a7daa8f5253e4054a951e036c735d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:29 2014 -0700

    staging: comedi: pcl816: tidy up dma buffer allocation
    
    This driver uses 2 buffers for DMA. Refactor the buffer allocation to
    use a for loop to remove code duplication. Remove the dev_err() messages
    when __get_dma_pages() fails and change the errno returned from -EBUSY
    to -ENOMEM.
    
    Both buffers are the same size so replace the 'dmapages' and 'hwdmasize'
    arrays in the private data with variables to save a bit of space.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 77bf99698144..29d462513c62 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -121,12 +121,11 @@ static const struct pcl816_board boardtypes[] = {
 };
 
 struct pcl816_private {
-
 	unsigned int dma;	/*  used DMA, 0=don't use DMA */
+	unsigned int dmapages;
+	unsigned int hwdmasize;
 	unsigned long dmabuf[2];	/*  pointers to begin of DMA buffers */
-	unsigned int dmapages[2];	/*  len of DMA buffers in PAGE_SIZEs */
 	unsigned int hwdmaptr[2];	/*  hardware address of DMA buffers */
-	unsigned int hwdmasize[2];	/*  len of DMA buffers in Bytes */
 	unsigned int dmasamplsize;	/*  size in samples hwdmasize[0]/2 */
 	int next_dma_buf;	/*  which DMA buffer will be used next round */
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
@@ -339,13 +338,10 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 /* clear_dma_ff (devpriv->dma); */
 		set_dma_addr(devpriv->dma,
 			     devpriv->hwdmaptr[devpriv->next_dma_buf]);
-		if (devpriv->dma_runs_to_end) {
-			set_dma_count(devpriv->dma,
-				      devpriv->hwdmasize[devpriv->
-							 next_dma_buf]);
-		} else {
+		if (devpriv->dma_runs_to_end)
+			set_dma_count(devpriv->dma, devpriv->hwdmasize);
+		else
 			set_dma_count(devpriv->dma, devpriv->last_dma_run);
-		}
 		release_dma_lock(dma_flags);
 		enable_dma(devpriv->dma);
 	}
@@ -355,7 +351,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 
 	ptr = (unsigned short *)devpriv->dmabuf[this_dma_buf];
 
-	len = (devpriv->hwdmasize[0] >> 1) - devpriv->ai_poll_ptr;
+	len = (devpriv->hwdmasize >> 1) - devpriv->ai_poll_ptr;
 	bufptr = devpriv->ai_poll_ptr;
 	devpriv->ai_poll_ptr = 0;
 
@@ -531,7 +527,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_neverending = 1;
 
 	if (devpriv->dma) {
-		bytes = devpriv->hwdmasize[0];
+		bytes = devpriv->hwdmasize;
 		if (!devpriv->ai_neverending) {
 			/*  how many */
 			bytes = s->async->cmd.chanlist_len *
@@ -539,14 +535,13 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			sizeof(short);
 
 			/*  how many DMA pages we must fill */
-			devpriv->dma_runs_to_end = bytes /
-			devpriv->hwdmasize[0];
+			devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize;
 
 			/* on last dma transfer must be moved */
-			devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];
+			devpriv->last_dma_run = bytes % devpriv->hwdmasize;
 			devpriv->dma_runs_to_end--;
 			if (devpriv->dma_runs_to_end >= 0)
-				bytes = devpriv->hwdmasize[0];
+				bytes = devpriv->hwdmasize;
 		} else
 			devpriv->dma_runs_to_end = -1;
 
@@ -611,7 +606,7 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/*  where is now DMA in buffer */
-	top1 = devpriv->hwdmasize[0] - top1;
+	top1 = devpriv->hwdmasize - top1;
 	top1 >>= 1;		/*  sample position */
 	top2 = top1 - devpriv->ai_poll_ptr;
 	if (top2 < 1) {		/*  no new samples */
@@ -843,10 +838,9 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl816_board *board = comedi_board(dev);
 	struct pcl816_private *devpriv;
-	int ret;
-	unsigned long pages;
-	/* int i; */
 	struct comedi_subdevice *s;
+	int ret;
+	int i;
 
 	ret = comedi_request_region(dev, it->options[0], 0x10);
 	if (ret)
@@ -882,31 +876,19 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 		devpriv->dma = it->options[2];
 
-		pages = 2;	/* we need 16KB */
-		devpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);
+		devpriv->dmapages = 2;	/* we need 16KB */
+		devpriv->hwdmasize = (1 << devpriv->dmapages) * PAGE_SIZE;
 
-		if (!devpriv->dmabuf[0]) {
-			dev_err(dev->class_dev,
-				"unable to allocate DMA buffer, FAIL!\n");
-			/*
-			 * maybe experiment with try_to_free_pages()
-			 * will help ....
-			 */
-			return -EBUSY;	/* no buffer :-( */
-		}
-		devpriv->dmapages[0] = pages;
-		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
-		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
+		for (i = 0; i < 2; i++) {
+			unsigned long dmabuf;
 
-		devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
-		if (!devpriv->dmabuf[1]) {
-			dev_err(dev->class_dev,
-				"unable to allocate DMA buffer, FAIL!\n");
-			return -EBUSY;
+			dmabuf = __get_dma_pages(GFP_KERNEL, devpriv->dmapages);
+			if (!dmabuf)
+				return -ENOMEM;
+
+			devpriv->dmabuf[i] = dmabuf;
+			devpriv->hwdmaptr[i] = virt_to_bus((void *)dmabuf);
 		}
-		devpriv->dmapages[1] = pages;
-		devpriv->hwdmaptr[1] = virt_to_bus((void *)devpriv->dmabuf[1]);
-		devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
 	}
 
 	ret = comedi_alloc_subdevices(dev, 1);
@@ -968,9 +950,9 @@ static void pcl816_detach(struct comedi_device *dev)
 		if (devpriv->dma)
 			free_dma(devpriv->dma);
 		if (devpriv->dmabuf[0])
-			free_pages(devpriv->dmabuf[0], devpriv->dmapages[0]);
+			free_pages(devpriv->dmabuf[0], devpriv->dmapages);
 		if (devpriv->dmabuf[1])
-			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
+			free_pages(devpriv->dmabuf[1], devpriv->dmapages);
 	}
 	comedi_legacy_detach(dev);
 }

commit 91471f9b45d5c36aa50c0940dfaf64fb13cf4fe5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:24 2014 -0700

    staging: comedi: pcl816: remove 'ai_n_chan' from private data
    
    This member of the private data is just a copy of the cmd->chanlist_len.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 042b4c372bfb..77bf99698144 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -140,7 +140,6 @@ struct pcl816_private {
 	unsigned int ai_act_chanlist[16];	/*  MUX setting for actual AI operations */
 	unsigned int ai_act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int ai_act_chanlist_pos;	/*  actual position in MUX list */
-	unsigned int ai_n_chan;		/*  how many channels per scan */
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
 };
 
@@ -260,7 +259,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 		devpriv->ai_act_chanlist_pos = 0;
 
 	s->async->cur_chan++;
-	if (s->async->cur_chan >= devpriv->ai_n_chan) {
+	if (s->async->cur_chan >= cmd->chanlist_len) {
 		s->async->cur_chan = 0;
 		devpriv->ai_act_scan++;
 	}
@@ -301,7 +300,7 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 		}
 
 		s->async->cur_chan++;
-		if (s->async->cur_chan >= devpriv->ai_n_chan) {
+		if (s->async->cur_chan >= cmd->chanlist_len) {
 			s->async->cur_chan = 0;
 			devpriv->ai_act_scan++;
 		}
@@ -520,7 +519,6 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	setup_channel_list(dev, s, cmd->chanlist, seglen);
 	udelay(1);
 
-	devpriv->ai_n_chan = cmd->chanlist_len;
 	devpriv->ai_act_scan = 0;
 	s->async->cur_chan = 0;
 	devpriv->irq_blocked = 1;

commit 6e15fcb24011c0ebca7359cc4ee7d1bf0a229b3a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:21 2014 -0700

    staging: comedi: pcl816: remove 'ai_scans' from private data
    
    This member of the private data is just a copy of the cmd->stop_arg.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 6d3965bffdaf..042b4c372bfb 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -131,8 +131,6 @@ struct pcl816_private {
 	int next_dma_buf;	/*  which DMA buffer will be used next round */
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
-
-	unsigned int ai_scans;	/*  len of scanlist */
 	unsigned char ai_neverending;	/*  if=1, then we do neverending record (you must use cancel()) */
 	int irq_blocked;	/*  1=IRQ now uses any subdev */
 	int irq_was_now_closed;	/*  when IRQ finish, there's stored int816_mode for last interrupt */
@@ -235,6 +233,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int timeout = 50;	/* wait max 50us */
 
 	while (timeout--) {
@@ -268,7 +267,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 
 	if (!devpriv->ai_neverending)
 					/* all data sampled */
-		if (devpriv->ai_act_scan >= devpriv->ai_scans) {
+		if (devpriv->ai_act_scan >= cmd->stop_arg) {
 			/* all data sampled */
 			pcl816_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA;
@@ -287,6 +286,7 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 				  unsigned int bufptr, unsigned int len)
 {
 	struct pcl816_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int i;
 
 	s->async->events = 0;
@@ -308,7 +308,7 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 
 		if (!devpriv->ai_neverending)
 						/*  all data sampled */
-			if (devpriv->ai_act_scan >= devpriv->ai_scans) {
+			if (devpriv->ai_act_scan >= cmd->stop_arg) {
 				pcl816_ai_cancel(dev, s);
 				s->async->events |= COMEDI_CB_EOA;
 				s->async->events |= COMEDI_CB_BLOCK;
@@ -527,13 +527,10 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_poll_ptr = 0;
 	devpriv->irq_was_now_closed = 0;
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		devpriv->ai_scans = cmd->stop_arg;
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ai_neverending = 0;
-	} else {
-		devpriv->ai_scans = 0;
+	else
 		devpriv->ai_neverending = 1;
-	}
 
 	if (devpriv->dma) {
 		bytes = devpriv->hwdmasize[0];

commit 66581ca576717229d65003f0870d6dd14e1fe52e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:15 2014 -0700

    staging: comedi: pcl816: introduce pcl816_ai_get_sample()
    
    Introduce a helper function to read the 14/16-bit analog input data
    sample.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 7e7c30247eef..6d3965bffdaf 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -165,6 +165,17 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_cmd *cmd);
 static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 
+static unsigned int pcl816_ai_get_sample(struct comedi_device *dev,
+					 struct comedi_subdevice *s)
+{
+	unsigned int val;
+
+	val = inb(dev->iobase + PCL816_AD_HI) << 8;
+	val |= inb(dev->iobase + PCL816_AD_LO);
+
+	return val & s->maxdata;
+}
+
 static int pcl816_ai_eoc(struct comedi_device *dev,
 			 struct comedi_subdevice *s,
 			 struct comedi_insn *insn,
@@ -206,9 +217,8 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 			return ret;
 		}
 
-		/*  return read value */
-		data[n] = ((inb(dev->iobase + PCL816_AD_HI) << 8) |
-			  (inb(dev->iobase + PCL816_AD_LO)));
+		data[n] = pcl816_ai_get_sample(dev, s);
+
 		/* clear INT (conversion end) flag */
 		outb(0, dev->iobase + PCL816_CLRINT);
 	}
@@ -225,7 +235,6 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	unsigned char low, hi;
 	int timeout = 50;	/* wait max 50us */
 
 	while (timeout--) {
@@ -244,11 +253,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 
 	}
 
-	/*  get the sample */
-	low = inb(dev->iobase + PCL816_AD_LO);
-	hi = inb(dev->iobase + PCL816_AD_HI);
-
-	comedi_buf_put(s->async, (hi << 8) | low);
+	comedi_buf_put(s->async, pcl816_ai_get_sample(dev, s));
 
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
 
@@ -655,8 +660,7 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 			outb(0xb0, dev->iobase + PCL816_CTRCTL);
 			outb(0x70, dev->iobase + PCL816_CTRCTL);
 			outb(0, dev->iobase + PCL816_AD_LO);
-			inb(dev->iobase + PCL816_AD_LO);
-			inb(dev->iobase + PCL816_AD_HI);
+			pcl816_ai_get_sample(dev, s);
 
 			/* clear INT request */
 			outb(0, dev->iobase + PCL816_CLRINT);

commit 8cfda3f8764136a5a3f17078e99c073a3d377c1e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:06 2014 -0700

    staging: comedi: pcl816: remove 'ai_range_type' from boardinfo
    
    All the board types use the same analog input range_table. Remove this
    data from the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 70f5c78495de..7e7c30247eef 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -94,7 +94,6 @@ struct pcl816_board {
 	const char *name;
 	unsigned int ai_ns_min;
 	int n_aochan;
-	const struct comedi_lrange *ai_range_type;
 	unsigned int IRQbits;
 	int ai_maxdata;
 	int ao_maxdata;
@@ -106,7 +105,6 @@ static const struct pcl816_board boardtypes[] = {
 		.name		= "pcl816",
 		.ai_ns_min	= 10000,
 		.n_aochan	= 1,
-		.ai_range_type	= &range_pcl816,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xffff,
 		.ao_maxdata	= 0xffff,
@@ -115,7 +113,6 @@ static const struct pcl816_board boardtypes[] = {
 		.name		= "pcl814b",
 		.ai_ns_min	= 10000,
 		.n_aochan	= 1,
-		.ai_range_type	= &range_pcl816,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0x3fff,
 		.ao_maxdata	= 0x3fff,
@@ -922,7 +919,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->subdev_flags	= SDF_CMD_READ | SDF_DIFF;
 	s->n_chan	= 16;
 	s->maxdata	= board->ai_maxdata;
-	s->range_table	= board->ai_range_type;
+	s->range_table	= &range_pcl816;
 	s->insn_read	= pcl816_ai_insn_read;
 	if (dev->irq) {
 		dev->read_subdev = s;

commit f5fafc976ffca0350bd7114c213c9f65ec23d6cd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:04 2014 -0700

    staging: comedi: pcl816: remove 'ao_chanlist' from boardinfo
    
    This member in the boardinfo is the same for all board types. Remove
    it.
    
    The comedi core will initalize the subdevice len_chanlist to 1 if it
    is not set by the driver so remove the unnecessary initialization.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index b2d857d3acca..70f5c78495de 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -99,7 +99,6 @@ struct pcl816_board {
 	int ai_maxdata;
 	int ao_maxdata;
 	int ai_chanlist;
-	int ao_chanlist;
 };
 
 static const struct pcl816_board boardtypes[] = {
@@ -112,7 +111,6 @@ static const struct pcl816_board boardtypes[] = {
 		.ai_maxdata	= 0xffff,
 		.ao_maxdata	= 0xffff,
 		.ai_chanlist	= 1024,
-		.ao_chanlist	= 1,
 	}, {
 		.name		= "pcl814b",
 		.ai_ns_min	= 10000,
@@ -122,7 +120,6 @@ static const struct pcl816_board boardtypes[] = {
 		.ai_maxdata	= 0x3fff,
 		.ao_maxdata	= 0x3fff,
 		.ai_chanlist	= 1024,
-		.ao_chanlist	= 1,
 	},
 };
 
@@ -942,7 +939,6 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
 	s->n_chan = board->n_aochan;
 	s->maxdata = board->ao_maxdata;
-	s->len_chanlist = board->ao_chanlist;
 	s->range_table = &range_pcl816;
 	break;
 

commit 90c6328e6c4ab5b753e8cdb12e7455f911ea3be8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:27:02 2014 -0700

    staging: comedi: pcl816: remove 'n_ranges' from boardinfo
    
    This member in the boardinfo is not used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index d64ed5e26858..b2d857d3acca 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -92,7 +92,6 @@ static const struct comedi_lrange range_pcl816 = {
 
 struct pcl816_board {
 	const char *name;
-	int n_ranges;
 	unsigned int ai_ns_min;
 	int n_aochan;
 	const struct comedi_lrange *ai_range_type;
@@ -106,7 +105,6 @@ struct pcl816_board {
 static const struct pcl816_board boardtypes[] = {
 	{
 		.name		= "pcl816",
-		.n_ranges	= 8,
 		.ai_ns_min	= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl816,
@@ -117,7 +115,6 @@ static const struct pcl816_board boardtypes[] = {
 		.ao_chanlist	= 1,
 	}, {
 		.name		= "pcl814b",
-		.n_ranges	= 8,
 		.ai_ns_min	= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl816,

commit 1ddd22c0dfdc1f03e22acae71a39b6be347568be
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:59 2014 -0700

    staging: comedi: pcl816: all board types have 16 analog inputs
    
    All the boards supported by this driver have 16 analog input channels.
    
    Remove the 'n_aichan' member from the boardinfo and refactor pcl816_attach().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index d1ca4b426de8..d64ed5e26858 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -93,7 +93,6 @@ static const struct comedi_lrange range_pcl816 = {
 struct pcl816_board {
 	const char *name;
 	int n_ranges;
-	int n_aichan;
 	unsigned int ai_ns_min;
 	int n_aochan;
 	const struct comedi_lrange *ai_range_type;
@@ -108,7 +107,6 @@ static const struct pcl816_board boardtypes[] = {
 	{
 		.name		= "pcl816",
 		.n_ranges	= 8,
-		.n_aichan	= 16,
 		.ai_ns_min	= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl816,
@@ -120,7 +118,6 @@ static const struct pcl816_board boardtypes[] = {
 	}, {
 		.name		= "pcl814b",
 		.n_ranges	= 8,
-		.n_aichan	= 16,
 		.ai_ns_min	= 10000,
 		.n_aochan	= 1,
 		.ai_range_type	= &range_pcl816,
@@ -927,24 +924,20 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return ret;
 
 	s = &dev->subdevices[0];
-	if (board->n_aichan > 0) {
-		s->type = COMEDI_SUBD_AI;
-		s->subdev_flags = SDF_CMD_READ | SDF_DIFF;
-		s->n_chan = board->n_aichan;
-		s->maxdata = board->ai_maxdata;
-		s->range_table = board->ai_range_type;
-		s->insn_read = pcl816_ai_insn_read;
-		if (dev->irq) {
-			dev->read_subdev = s;
-			s->subdev_flags |= SDF_CMD_READ;
-			s->len_chanlist = board->ai_chanlist;
-			s->do_cmdtest = pcl816_ai_cmdtest;
-			s->do_cmd = pcl816_ai_cmd;
-			s->poll = pcl816_ai_poll;
-			s->cancel = pcl816_ai_cancel;
-		}
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_CMD_READ | SDF_DIFF;
+	s->n_chan	= 16;
+	s->maxdata	= board->ai_maxdata;
+	s->range_table	= board->ai_range_type;
+	s->insn_read	= pcl816_ai_insn_read;
+	if (dev->irq) {
+		dev->read_subdev = s;
+		s->subdev_flags	|= SDF_CMD_READ;
+		s->len_chanlist	= board->ai_chanlist;
+		s->do_cmdtest	= pcl816_ai_cmdtest;
+		s->do_cmd	= pcl816_ai_cmd;
+		s->poll		= pcl816_ai_poll;
+		s->cancel	= pcl816_ai_cancel;
 	}
 
 #if 0

commit c1a6c5e120335082f01a222c346c88211541a856
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:55 2014 -0700

    staging: comedi: pcl816: all board types have digital inputs and outputs
    
    All the board types have 16 digital inputs and 16 digital outputs.
    
    Remove the 'n_dichan' and 'n_dochan' members in the boardinfo.
    
    The subdevice support code is currently incomplete in this driver. For
    now just tidy up the incomplete subdevice code in pcl816_attach().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index e67d24af9127..d1ca4b426de8 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -96,8 +96,6 @@ struct pcl816_board {
 	int n_aichan;
 	unsigned int ai_ns_min;
 	int n_aochan;
-	int n_dichan;
-	int n_dochan;
 	const struct comedi_lrange *ai_range_type;
 	unsigned int IRQbits;
 	int ai_maxdata;
@@ -113,8 +111,6 @@ static const struct pcl816_board boardtypes[] = {
 		.n_aichan	= 16,
 		.ai_ns_min	= 10000,
 		.n_aochan	= 1,
-		.n_dichan	= 16,
-		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl816,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0xffff,
@@ -127,8 +123,6 @@ static const struct pcl816_board boardtypes[] = {
 		.n_aichan	= 16,
 		.ai_ns_min	= 10000,
 		.n_aochan	= 1,
-		.n_dichan	= 16,
-		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl816,
 		.IRQbits	= 0x00fc,
 		.ai_maxdata	= 0x3fff,
@@ -928,14 +922,6 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
 	}
 
-/*  if (board->n_aochan > 0)
-    subdevs[1] = COMEDI_SUBD_AO;
-  if (board->n_dichan > 0)
-    subdevs[2] = COMEDI_SUBD_DI;
-  if (board->n_dochan > 0)
-    subdevs[3] = COMEDI_SUBD_DO;
-*/
-
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret)
 		return ret;
@@ -962,7 +948,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 #if 0
-case COMEDI_SUBD_AO:
+	subdevs[1] = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
 	s->n_chan = board->n_aochan;
 	s->maxdata = board->ao_maxdata;
@@ -970,19 +956,17 @@ case COMEDI_SUBD_AO:
 	s->range_table = &range_pcl816;
 	break;
 
-case COMEDI_SUBD_DI:
+	subdevs[2] = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE;
-	s->n_chan = board->n_dichan;
+	s->n_chan = 16;
 	s->maxdata = 1;
-	s->len_chanlist = board->n_dichan;
 	s->range_table = &range_digital;
 	break;
 
-case COMEDI_SUBD_DO:
+	subdevs[3] = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITABLE;
-	s->n_chan = board->n_dochan;
+	s->n_chan = 16;
 	s->maxdata = 1;
-	s->len_chanlist = board->n_dochan;
 	s->range_table = &range_digital;
 	break;
 #endif

commit ee34785cfd07e279b92f6fb1d44573118116841e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:49 2014 -0700

    staging: comedi: pcl816: clarify dma channel request in pcl816_attach()
    
    All the board types can do DMA using DMA channels 3 or 1. Remove the 'DMAbits',
    which is a mask of the valid channels, from the boardinfo.
    
    Refactor pcl816_attach() to remove the need for the goto.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 5af687ab6b22..e67d24af9127 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -100,7 +100,6 @@ struct pcl816_board {
 	int n_dochan;
 	const struct comedi_lrange *ai_range_type;
 	unsigned int IRQbits;
-	unsigned int DMAbits;
 	int ai_maxdata;
 	int ao_maxdata;
 	int ai_chanlist;
@@ -118,7 +117,6 @@ static const struct pcl816_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl816,
 		.IRQbits	= 0x00fc,
-		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xffff,
 		.ao_maxdata	= 0xffff,
 		.ai_chanlist	= 1024,
@@ -133,7 +131,6 @@ static const struct pcl816_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl816,
 		.IRQbits	= 0x00fc,
-		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0x3fff,
 		.ao_maxdata	= 0x3fff,
 		.ai_chanlist	= 1024,
@@ -866,7 +863,6 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct pcl816_board *board = comedi_board(dev);
 	struct pcl816_private *devpriv;
 	int ret;
-	unsigned int dma;
 	unsigned long pages;
 	/* int i; */
 	struct comedi_subdevice *s;
@@ -894,30 +890,17 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
 	devpriv->int816_mode = 0;	/* mode of irq */
 
-	/* grab our DMA */
-	dma = 0;
-	devpriv->dma = dma;
-	if (!dev->irq)
-		goto no_dma;	/* if we haven't IRQ, we can't use DMA */
-
-	if (board->DMAbits != 0) {	/* board support DMA */
-		dma = it->options[2];
-		if (dma < 1)
-			goto no_dma;	/* DMA disabled */
-
-		if (((1 << dma) & board->DMAbits) == 0) {
-			dev_err(dev->class_dev,
-				"DMA is out of allowed range, FAIL!\n");
-			return -EINVAL;	/* Bad DMA */
-		}
-		ret = request_dma(dma, dev->board_name);
+	/* we need an IRQ to do DMA on channel 3 or 1 */
+	if (dev->irq && (it->options[2] == 3 || it->options[2] == 1)) {
+		ret = request_dma(it->options[2], dev->board_name);
 		if (ret) {
 			dev_err(dev->class_dev,
-				"unable to allocate DMA %u, FAIL!\n", dma);
-			return -EBUSY;	/* DMA isn't free */
+				"unable to request DMA channel %d\n",
+				it->options[2]);
+			return -EBUSY;
 		}
+		devpriv->dma = it->options[2];
 
-		devpriv->dma = dma;
 		pages = 2;	/* we need 16KB */
 		devpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);
 
@@ -945,8 +928,6 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
 	}
 
-no_dma:
-
 /*  if (board->n_aochan > 0)
     subdevs[1] = COMEDI_SUBD_AO;
   if (board->n_dichan > 0)

commit 71b7b12ec96618ebb94b3a89ad0f1d04af53549f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:46 2014 -0700

    staging: comedi: pcl816: remove 'rangelist_ao' from boardinfo
    
    The 'rangelist_ao' is the same for all board types. Remove this data
    from the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 8a10738e013a..5af687ab6b22 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -99,7 +99,6 @@ struct pcl816_board {
 	int n_dichan;
 	int n_dochan;
 	const struct comedi_lrange *ai_range_type;
-	const struct comedi_lrange *ao_range_type;
 	unsigned int IRQbits;
 	unsigned int DMAbits;
 	int ai_maxdata;
@@ -118,7 +117,6 @@ static const struct pcl816_board boardtypes[] = {
 		.n_dichan	= 16,
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl816,
-		.ao_range_type	= &range_pcl816,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xffff,
@@ -134,7 +132,6 @@ static const struct pcl816_board boardtypes[] = {
 		.n_dichan	= 16,
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl816,
-		.ao_range_type	= &range_pcl816,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0x3fff,
@@ -989,7 +986,7 @@ case COMEDI_SUBD_AO:
 	s->n_chan = board->n_aochan;
 	s->maxdata = board->ao_maxdata;
 	s->len_chanlist = board->ao_chanlist;
-	s->range_table = board->ao_range_type;
+	s->range_table = &range_pcl816;
 	break;
 
 case COMEDI_SUBD_DI:

commit 43669f4b2a81678912d07aece9b908d71ae36dc0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:44 2014 -0700

    staging: comedi: pcl816: remove 'i8254_osc_base' from boardinfo
    
    The 'i8254_osc_base' is the same for all board types. Remove this data
    from the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 05cfdc5f3ed3..8a10738e013a 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -106,7 +106,6 @@ struct pcl816_board {
 	int ao_maxdata;
 	int ai_chanlist;
 	int ao_chanlist;
-	int i8254_osc_base;
 };
 
 static const struct pcl816_board boardtypes[] = {
@@ -126,7 +125,6 @@ static const struct pcl816_board boardtypes[] = {
 		.ao_maxdata	= 0xffff,
 		.ai_chanlist	= 1024,
 		.ao_chanlist	= 1,
-		.i8254_osc_base	= I8254_OSC_BASE_10MHZ,
 	}, {
 		.name		= "pcl814b",
 		.n_ranges	= 8,
@@ -143,7 +141,6 @@ static const struct pcl816_board boardtypes[] = {
 		.ao_maxdata	= 0x3fff,
 		.ai_chanlist	= 1024,
 		.ao_chanlist	= 1,
-		.i8254_osc_base	= I8254_OSC_BASE_10MHZ,
 	},
 };
 
@@ -480,7 +477,7 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
-		i8253_cascade_ns_to_timer(board->i8254_osc_base,
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
 					  &divisor1, &divisor2,
 					  &cmd->convert_arg, cmd->flags);
 		if (cmd->convert_arg < board->ai_ns_min)
@@ -519,7 +516,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		if (cmd->convert_arg < board->ai_ns_min)
 			cmd->convert_arg = board->ai_ns_min;
 
-		i8253_cascade_ns_to_timer(board->i8254_osc_base,
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
 					  &divisor1, &divisor2,
 					  &cmd->convert_arg, cmd->flags);
 

commit 2599048aeb1a78c312f1b40cfe9d1aa9743c310d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:41 2014 -0700

    staging: comedi: pcl816: remove 'io_range' from boardinfo
    
    The 'io_range' is the same for all board types. Remove this data from
    the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 3bae039ea7bd..05cfdc5f3ed3 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -44,10 +44,6 @@ Configuration Options:
 #include "comedi_fc.h"
 #include "8253.h"
 
-/* boards constants */
-/* IO space len */
-#define PCLx1x_RANGE 16
-
 /* INTEL 8254 counters */
 #define PCL816_CTR0 4
 #define PCL816_CTR1 5
@@ -104,7 +100,6 @@ struct pcl816_board {
 	int n_dochan;
 	const struct comedi_lrange *ai_range_type;
 	const struct comedi_lrange *ao_range_type;
-	unsigned int io_range;
 	unsigned int IRQbits;
 	unsigned int DMAbits;
 	int ai_maxdata;
@@ -125,7 +120,6 @@ static const struct pcl816_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl816,
 		.ao_range_type	= &range_pcl816,
-		.io_range	= PCLx1x_RANGE,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0xffff,
@@ -143,7 +137,6 @@ static const struct pcl816_board boardtypes[] = {
 		.n_dochan	= 16,
 		.ai_range_type	= &range_pcl816,
 		.ao_range_type	= &range_pcl816,
-		.io_range	= PCLx1x_RANGE,
 		.IRQbits	= 0x00fc,
 		.DMAbits	= 0x0a,
 		.ai_maxdata	= 0x3fff,
@@ -884,7 +877,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* int i; */
 	struct comedi_subdevice *s;
 
-	ret = comedi_request_region(dev, it->options[0], board->io_range);
+	ret = comedi_request_region(dev, it->options[0], 0x10);
 	if (ret)
 		return ret;
 

commit a094dbdd00f2c82f7baf0b534667e5b5f8c65bcb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 17 14:26:36 2014 -0700

    staging: comedi: pcl816: convert boardinfo declaration to C99 format
    
    To reduce editing errors and make the data more maintainable, convert
    the boardinfo declaration to C99 format.
    
    For aesthetics, move the declaration closer to the definition and remove
    the unnecessary comments in the definition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 044722f3a51f..3bae039ea7bd 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -95,24 +95,63 @@ static const struct comedi_lrange range_pcl816 = {
 };
 
 struct pcl816_board {
+	const char *name;
+	int n_ranges;
+	int n_aichan;
+	unsigned int ai_ns_min;
+	int n_aochan;
+	int n_dichan;
+	int n_dochan;
+	const struct comedi_lrange *ai_range_type;
+	const struct comedi_lrange *ao_range_type;
+	unsigned int io_range;
+	unsigned int IRQbits;
+	unsigned int DMAbits;
+	int ai_maxdata;
+	int ao_maxdata;
+	int ai_chanlist;
+	int ao_chanlist;
+	int i8254_osc_base;
+};
 
-	const char *name;	/*  board name */
-	int n_ranges;		/*  len of range list */
-	int n_aichan;		/*  num of A/D chans in diferencial mode */
-	unsigned int ai_ns_min;	/*  minimal allowed delay between samples (in ns) */
-	int n_aochan;		/*  num of D/A chans */
-	int n_dichan;		/*  num of DI chans */
-	int n_dochan;		/*  num of DO chans */
-	const struct comedi_lrange *ai_range_type;	/*  default A/D rangelist */
-	const struct comedi_lrange *ao_range_type;	/*  default D/A rangelist */
-	unsigned int io_range;	/*  len of IO space */
-	unsigned int IRQbits;	/*  allowed interrupts */
-	unsigned int DMAbits;	/*  allowed DMA chans */
-	int ai_maxdata;		/*  maxdata for A/D */
-	int ao_maxdata;		/*  maxdata for D/A */
-	int ai_chanlist;	/*  allowed len of channel list A/D */
-	int ao_chanlist;	/*  allowed len of channel list D/A */
-	int i8254_osc_base;	/*  1/frequency of on board oscilator in ns */
+static const struct pcl816_board boardtypes[] = {
+	{
+		.name		= "pcl816",
+		.n_ranges	= 8,
+		.n_aichan	= 16,
+		.ai_ns_min	= 10000,
+		.n_aochan	= 1,
+		.n_dichan	= 16,
+		.n_dochan	= 16,
+		.ai_range_type	= &range_pcl816,
+		.ao_range_type	= &range_pcl816,
+		.io_range	= PCLx1x_RANGE,
+		.IRQbits	= 0x00fc,
+		.DMAbits	= 0x0a,
+		.ai_maxdata	= 0xffff,
+		.ao_maxdata	= 0xffff,
+		.ai_chanlist	= 1024,
+		.ao_chanlist	= 1,
+		.i8254_osc_base	= I8254_OSC_BASE_10MHZ,
+	}, {
+		.name		= "pcl814b",
+		.n_ranges	= 8,
+		.n_aichan	= 16,
+		.ai_ns_min	= 10000,
+		.n_aochan	= 1,
+		.n_dichan	= 16,
+		.n_dochan	= 16,
+		.ai_range_type	= &range_pcl816,
+		.ao_range_type	= &range_pcl816,
+		.io_range	= PCLx1x_RANGE,
+		.IRQbits	= 0x00fc,
+		.DMAbits	= 0x0a,
+		.ai_maxdata	= 0x3fff,
+		.ao_maxdata	= 0x3fff,
+		.ai_chanlist	= 1024,
+		.ao_chanlist	= 1,
+		.i8254_osc_base	= I8254_OSC_BASE_10MHZ,
+	},
 };
 
 struct pcl816_private {
@@ -1002,27 +1041,6 @@ static void pcl816_detach(struct comedi_device *dev)
 	comedi_legacy_detach(dev);
 }
 
-static const struct pcl816_board boardtypes[] = {
-	{"pcl816", 8, 16, 10000, 1, 16, 16, &range_pcl816,
-	 &range_pcl816, PCLx1x_RANGE,
-	 0x00fc,		/*  IRQ mask */
-	 0x0a,			/*  DMA mask */
-	 0xffff,		/*  16-bit card */
-	 0xffff,		/*  D/A maxdata */
-	 1024,
-	 1,			/*  ao chan list */
-	 I8254_OSC_BASE_10MHZ},
-	{"pcl814b", 8, 16, 10000, 1, 16, 16, &range_pcl816,
-	 &range_pcl816, PCLx1x_RANGE,
-	 0x00fc,
-	 0x0a,
-	 0x3fff,		/* 14 bit card */
-	 0x3fff,
-	 1024,
-	 1,
-	 I8254_OSC_BASE_10MHZ},
-};
-
 static struct comedi_driver pcl816_driver = {
 	.driver_name	= "pcl816",
 	.module		= THIS_MODULE,

commit ab09248c998dd9df4f35912827d95d70b499bd30
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 15:20:37 2014 -0700

    staging: comedi: pcl816: trigger sources were validated in (*do_cmdtest)
    
    The trigger sources were already validataed in the (*do_cmdtest) before the
    (*do_cmd) is called. Remove the unnecessary checks in pcl816_ai_cmd().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index a35f230d1958..044722f3a51f 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -480,15 +480,6 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int seglen;
 
-	if (cmd->start_src != TRIG_NOW)
-		return -EINVAL;
-	if (cmd->scan_begin_src != TRIG_FOLLOW)
-		return -EINVAL;
-	if (cmd->scan_end_src != TRIG_COUNT)
-		return -EINVAL;
-	if (cmd->scan_end_arg != cmd->chanlist_len)
-		return -EINVAL;
-/* if(cmd->chanlist_len>MAX_CHANLIST_LEN) return -EINVAL; */
 	if (devpriv->irq_blocked)
 		return -EBUSY;
 

commit dbd446fc7aab519c213e63eefa15c82586a50989
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:46 2014 -0700

    staging: comedi: don't clear 'data' on (*insn_read) timeout
    
    It's not necessary to clear the returned data pointer when an (*insn_read)
    times out. For aesthetics, remove all of these in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 4bf2efb2c027..a35f230d1958 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -196,7 +196,6 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 
 		ret = comedi_timeout(dev, s, insn, pcl816_ai_eoc, 0);
 		if (ret) {
-			data[0] = 0;
 			/* clear INT (conversion end) flag */
 			outb(0, dev->iobase + PCL816_CLRINT);
 			return ret;

commit 22ca19d93d92c79cff68270846a84bd34fe6fb34
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:45 2014 -0700

    staging: comedi: move (*insn_{read, write}) timeout debug messages to core
    
    Have the comedi core display a standard dev_dbg() message when a timeout
    occurs and remove all the driver specific messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index db00d079c9c9..4bf2efb2c027 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -196,7 +196,6 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 
 		ret = comedi_timeout(dev, s, insn, pcl816_ai_eoc, 0);
 		if (ret) {
-			comedi_error(dev, "A/D insn timeout\n");
 			data[0] = 0;
 			/* clear INT (conversion end) flag */
 			outb(0, dev->iobase + PCL816_CLRINT);

commit c0c3531b59c9ef27760c941b0206a6074699d3b6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:41 2014 -0700

    staging: comedi: pcl816: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input end-of-conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index e9d470459933..db00d079c9c9 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -160,16 +160,25 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_cmd *cmd);
 static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 
-/*
-==============================================================================
-   ANALOG INPUT MODE0, 816 cards, slow version
-*/
+static int pcl816_ai_eoc(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 struct comedi_insn *insn,
+			 unsigned long context)
+{
+	unsigned int status;
+
+	status = inb(dev->iobase + PCL816_STATUS);
+	if ((status & PCL816_STATUS_DRDY_MASK) == 0)
+		return 0;
+	return -EBUSY;
+}
+
 static int pcl816_ai_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
+	int ret;
 	int n;
-	int timeout;
 
 	/*  software trigger, DMA and INT off */
 	outb(0, dev->iobase + PCL816_CONTROL);
@@ -185,30 +194,20 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 
 		outb(0, dev->iobase + PCL816_AD_LO);	/* start conversion */
 
-		timeout = 100;
-		while (timeout--) {
-			if (!(inb(dev->iobase + PCL816_STATUS) &
-			      PCL816_STATUS_DRDY_MASK)) {
-				/*  return read value */
-				data[n] =
-				    ((inb(dev->iobase +
-					  PCL816_AD_HI) << 8) |
-				     (inb(dev->iobase + PCL816_AD_LO)));
-				/* clear INT (conversion end) flag */
-				outb(0, dev->iobase + PCL816_CLRINT);
-				break;
-			}
-			udelay(1);
-		}
-		/*  Return timeout error */
-		if (!timeout) {
+		ret = comedi_timeout(dev, s, insn, pcl816_ai_eoc, 0);
+		if (ret) {
 			comedi_error(dev, "A/D insn timeout\n");
 			data[0] = 0;
 			/* clear INT (conversion end) flag */
 			outb(0, dev->iobase + PCL816_CLRINT);
-			return -EIO;
+			return ret;
 		}
 
+		/*  return read value */
+		data[n] = ((inb(dev->iobase + PCL816_AD_HI) << 8) |
+			  (inb(dev->iobase + PCL816_AD_LO)));
+		/* clear INT (conversion end) flag */
+		outb(0, dev->iobase + PCL816_CLRINT);
 	}
 	return n;
 }

commit f5a9097ec2c6c67a2f54acd7328ea7bd2f86c71d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:31:18 2013 -0700

    staging: comedi: pcl816: tidy up comedi_lrange tables
    
    Tidy up the whitespace in the comedi_lrange tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index a2e0b545401b..e9d470459933 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -81,16 +81,17 @@ Configuration Options:
 
 #define MAGIC_DMA_WORD 0x5a5a
 
-static const struct comedi_lrange range_pcl816 = { 8, {
-						       BIP_RANGE(10),
-						       BIP_RANGE(5),
-						       BIP_RANGE(2.5),
-						       BIP_RANGE(1.25),
-						       UNI_RANGE(10),
-						       UNI_RANGE(5),
-						       UNI_RANGE(2.5),
-						       UNI_RANGE(1.25),
-						       }
+static const struct comedi_lrange range_pcl816 = {
+	8, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25)
+	}
 };
 
 struct pcl816_board {

commit 5451274a3211c7efcea9a268d1177633d841350a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Dec 3 12:07:14 2013 -0700

    staging: comedi: pcl816: use dev->read_subdev
    
    Use the dev->read_subdev that was setup in the device attach instead
    of accessing the dev->subdevices array directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 6445e1fe4e5e..a2e0b545401b 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -221,7 +221,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct pcl816_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[0];
+	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned char low, hi;
 	int timeout = 50;	/* wait max 50us */
 
@@ -315,7 +315,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct pcl816_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[0];
+	struct comedi_subdevice *s = dev->read_subdev;
 	int len, bufptr, this_dma_buf;
 	unsigned long dma_flags;
 	unsigned short *ptr;

commit 5d6f1a2ede8060fedb6baf652cbb24ae9db25b1b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Dec 3 12:07:13 2013 -0700

    staging: comedi: pcl816: remove 'sub_ai' from private data
    
    This member of the private data is a duplicate of the comedi_device
    'read_subdev' member. Remove the private data member and use the
    comedi_device member instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index ed4d57f8a1bd..6445e1fe4e5e 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -138,7 +138,6 @@ struct pcl816_private {
 	unsigned int ai_act_chanlist_pos;	/*  actual position in MUX list */
 	unsigned int ai_n_chan;		/*  how many channels per scan */
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
-	struct comedi_subdevice *sub_ai;	/*  ptr to AI subdevice */
 };
 
 /*
@@ -948,7 +947,6 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s = &dev->subdevices[0];
 	if (board->n_aichan > 0) {
 		s->type = COMEDI_SUBD_AI;
-		devpriv->sub_ai = s;
 		s->subdev_flags = SDF_CMD_READ | SDF_DIFF;
 		s->n_chan = board->n_aichan;
 		s->maxdata = board->ai_maxdata;
@@ -1003,7 +1001,7 @@ static void pcl816_detach(struct comedi_device *dev)
 	struct pcl816_private *devpriv = dev->private;
 
 	if (dev->private) {
-		pcl816_ai_cancel(dev, devpriv->sub_ai);
+		pcl816_ai_cancel(dev, dev->read_subdev);
 		pcl816_reset(dev);
 		if (devpriv->dma)
 			free_dma(devpriv->dma);

commit 109b4d00f92be265f5795d0baf12722ecbf2d146
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Dec 3 12:07:12 2013 -0700

    staging: comedi: pcl816: only init command support if irq is available
    
    The async command support requires an irq. Only initialize the subdevice
    command support if the request_irq was successfull.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index a102db34e131..ed4d57f8a1bd 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -949,18 +949,20 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (board->n_aichan > 0) {
 		s->type = COMEDI_SUBD_AI;
 		devpriv->sub_ai = s;
-		dev->read_subdev = s;
-		s->subdev_flags = SDF_READABLE | SDF_CMD_READ;
+		s->subdev_flags = SDF_CMD_READ | SDF_DIFF;
 		s->n_chan = board->n_aichan;
-		s->subdev_flags |= SDF_DIFF;
 		s->maxdata = board->ai_maxdata;
-		s->len_chanlist = board->ai_chanlist;
 		s->range_table = board->ai_range_type;
-		s->cancel = pcl816_ai_cancel;
-		s->do_cmdtest = pcl816_ai_cmdtest;
-		s->do_cmd = pcl816_ai_cmd;
-		s->poll = pcl816_ai_poll;
 		s->insn_read = pcl816_ai_insn_read;
+		if (dev->irq) {
+			dev->read_subdev = s;
+			s->subdev_flags |= SDF_CMD_READ;
+			s->len_chanlist = board->ai_chanlist;
+			s->do_cmdtest = pcl816_ai_cmdtest;
+			s->do_cmd = pcl816_ai_cmd;
+			s->poll = pcl816_ai_poll;
+			s->cancel = pcl816_ai_cancel;
+		}
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}

commit 6a8f6de10567e0b46e0d8ff605b54886ca13a9f4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Dec 3 12:07:11 2013 -0700

    staging: comedi: pcl816: remove 'irq_free' from private data
    
    This member of the private data is not needed. We can check if
    dev->irq is none zero instead. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index d54325047af6..a102db34e131 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -128,7 +128,6 @@ struct pcl816_private {
 
 	unsigned int ai_scans;	/*  len of scanlist */
 	unsigned char ai_neverending;	/*  if=1, then we do neverending record (you must use cancel()) */
-	int irq_free;		/*  1=have allocated IRQ */
 	int irq_blocked;	/*  1=IRQ now uses any subdev */
 	int irq_was_now_closed;	/*  when IRQ finish, there's stored int816_mode for last interrupt */
 	int int816_mode;	/*  who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma */
@@ -382,8 +381,7 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 	}
 
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
-	if (!dev->irq || !devpriv->irq_free || !devpriv->irq_blocked ||
-	    !devpriv->int816_mode) {
+	if (!dev->irq || !devpriv->irq_blocked || !devpriv->int816_mode) {
 		if (devpriv->irq_was_now_closed) {
 			devpriv->irq_was_now_closed = 0;
 			/*  comedi_error(dev,"last IRQ.."); */
@@ -875,10 +873,8 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if ((1 << it->options[1]) & board->IRQbits) {
 		ret = request_irq(it->options[1], interrupt_pcl816, 0,
 				  dev->board_name, dev);
-		if (ret == 0) {
+		if (ret == 0)
 			dev->irq = it->options[1];
-			devpriv->irq_free = 1;
-		}
 	}
 
 	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
@@ -887,7 +883,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* grab our DMA */
 	dma = 0;
 	devpriv->dma = dma;
-	if (!devpriv->irq_free)
+	if (!dev->irq)
 		goto no_dma;	/* if we haven't IRQ, we can't use DMA */
 
 	if (board->DMAbits != 0) {	/* board support DMA */

commit 5d24b7de41ab53b3f309629fa73e285a8f9645e2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:24 2013 -0700

    staging: comedi: pcl816: convert printk messages in pcl816_attach()
    
    Convert the printk messages in this function to dev_{level} mesages.
    
    Remove the ones that are just added noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 6d8dbf8d2dcf..d54325047af6 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -864,7 +864,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return ret;
 
 	if (pcl816_check(dev->iobase)) {
-		printk(KERN_ERR ", I cann't detect board. FAIL!\n");
+		dev_err(dev->class_dev, "I can't detect board. FAIL!\n");
 		return -EIO;
 	}
 
@@ -896,23 +896,24 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			goto no_dma;	/* DMA disabled */
 
 		if (((1 << dma) & board->DMAbits) == 0) {
-			printk(", DMA is out of allowed range, FAIL!\n");
+			dev_err(dev->class_dev,
+				"DMA is out of allowed range, FAIL!\n");
 			return -EINVAL;	/* Bad DMA */
 		}
 		ret = request_dma(dma, dev->board_name);
 		if (ret) {
-			printk(KERN_ERR
-			       ", unable to allocate DMA %u, FAIL!\n", dma);
+			dev_err(dev->class_dev,
+				"unable to allocate DMA %u, FAIL!\n", dma);
 			return -EBUSY;	/* DMA isn't free */
 		}
 
 		devpriv->dma = dma;
-		printk(KERN_INFO ", dma=%u", dma);
 		pages = 2;	/* we need 16KB */
 		devpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);
 
 		if (!devpriv->dmabuf[0]) {
-			printk(", unable to allocate DMA buffer, FAIL!\n");
+			dev_err(dev->class_dev,
+				"unable to allocate DMA buffer, FAIL!\n");
 			/*
 			 * maybe experiment with try_to_free_pages()
 			 * will help ....
@@ -925,9 +926,8 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 		if (!devpriv->dmabuf[1]) {
-			printk(KERN_ERR
-				", unable to allocate DMA buffer, "
-				"FAIL!\n");
+			dev_err(dev->class_dev,
+				"unable to allocate DMA buffer, FAIL!\n");
 			return -EBUSY;
 		}
 		devpriv->dmapages[1] = pages;
@@ -997,8 +997,6 @@ case COMEDI_SUBD_DO:
 
 	pcl816_reset(dev);
 
-	printk("\n");
-
 	return 0;
 }
 

commit e21f20e769c65cf0c327bc26e91b5e316b262491
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:23 2013 -0700

    staging: comedi: pcl816: remove commented out printk debug
    
    These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 57172156321b..6d8dbf8d2dcf 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -922,7 +922,6 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->dmapages[0] = pages;
 		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
 		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
-		/* printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
 
 		devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 		if (!devpriv->dmabuf[1]) {
@@ -958,7 +957,6 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->subdev_flags = SDF_READABLE | SDF_CMD_READ;
 		s->n_chan = board->n_aichan;
 		s->subdev_flags |= SDF_DIFF;
-		/* printk (", %dchans DIFF DAC - %d", s->n_chan, i); */
 		s->maxdata = board->ai_maxdata;
 		s->len_chanlist = board->ai_chanlist;
 		s->range_table = board->ai_range_type;

commit 8189061ea4a2f877c3867a57b9a33e7e56a44636
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 27 11:05:19 2013 -0700

    staging: comedi: pcl816: tidy up the irq support in pcl816_attach()
    
    Tidy up the code that does the request_irq().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 149a28bbf086..57172156321b 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -854,7 +854,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct pcl816_board *board = comedi_board(dev);
 	struct pcl816_private *devpriv;
 	int ret;
-	unsigned int irq, dma;
+	unsigned int dma;
 	unsigned long pages;
 	/* int i; */
 	struct comedi_subdevice *s;
@@ -872,36 +872,15 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!devpriv)
 		return -ENOMEM;
 
-	/* grab our IRQ */
-	irq = 0;
-	if (board->IRQbits != 0) {	/* board support IRQ */
-		irq = it->options[1];
-		if (irq) {	/* we want to use IRQ */
-			if (((1 << irq) & board->IRQbits) == 0) {
-				printk
-				    (", IRQ %u is out of allowed range, "
-				     "DISABLING IT", irq);
-				irq = 0;	/* Bad IRQ */
-			} else {
-				if (request_irq(irq, interrupt_pcl816, 0,
-						dev->board_name, dev)) {
-					printk
-					    (", unable to allocate IRQ %u, "
-					     "DISABLING IT", irq);
-					irq = 0;	/* Can't use IRQ */
-				} else {
-					printk(KERN_INFO ", irq=%u", irq);
-				}
-			}
+	if ((1 << it->options[1]) & board->IRQbits) {
+		ret = request_irq(it->options[1], interrupt_pcl816, 0,
+				  dev->board_name, dev);
+		if (ret == 0) {
+			dev->irq = it->options[1];
+			devpriv->irq_free = 1;
 		}
 	}
 
-	dev->irq = irq;
-	if (irq)	/* 1=we have allocated irq */
-		devpriv->irq_free = 1;
-	else
-		devpriv->irq_free = 0;
-
 	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
 	devpriv->int816_mode = 0;	/* mode of irq */
 

commit d3629b2b1241e75971026e6ce6671f5b59b9172c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:21 2013 -0700

    staging: comedi: pcl816: remove TRIG_WAKE_EOS support stub
    
    The support code for this command flag is commented out. Just remove
    it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index e1a59f167d29..149a28bbf086 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -539,15 +539,6 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_neverending = 1;
 	}
 
-	/*  don't we want wake up every scan? */
-	if ((cmd->flags & TRIG_WAKE_EOS)) {
-		printk(KERN_INFO
-		       "pl816: You wankt WAKE_EOS but I dont want handle it");
-		/*               devpriv->ai_eos=1; */
-		/* if (devpriv->ai_n_chan==1) */
-		/*       devpriv->dma=0; // DMA is useless for this situation */
-	}
-
 	if (devpriv->dma) {
 		bytes = devpriv->hwdmasize[0];
 		if (!devpriv->ai_neverending) {

commit 11b7f7dc10fa1e5315bbefa11a2d1a5e1c408429
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:20 2013 -0700

    staging: comedi: pcl816: remove commented out outb() macro
    
    This macro is commented out, thankfully... Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 8776c596bad2..e1a59f167d29 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -48,8 +48,6 @@ Configuration Options:
 /* IO space len */
 #define PCLx1x_RANGE 16
 
-/* #define outb(x,y)  printk("OUTB(%x, 200+%d)\n", x,y-0x200); outb(x,y) */
-
 /* INTEL 8254 counters */
 #define PCL816_CTR0 4
 #define PCL816_CTR1 5

commit 5e1503aea7f46dcd5ebc2b929d7368a2f175bfb8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:41:36 2013 -0700

    staging: comedi: pcl816: convert some printk's to dev_dbg()
    
    Convert these warning messages to dev_dbg() to minimize the noise.
    Also, tidy them up a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 7b92aa50aa7f..8776c596bad2 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -800,12 +800,10 @@ check_channel_list(struct comedi_device *dev,
 			    (CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {
 				/*  channel list isn't continuous :-( */
-				printk(KERN_WARNING
-				       "comedi%d: pcl816: channel list must "
-				       "be continuous! chanlist[%i]=%d but "
-				       "must be %d or %d!\n", dev->minor,
-				       i, CR_CHAN(chanlist[i]), nowmustbechan,
-				       CR_CHAN(chanlist[0]));
+				dev_dbg(dev->class_dev,
+					"channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\n",
+					i, CR_CHAN(chanlist[i]), nowmustbechan,
+					CR_CHAN(chanlist[0]));
 				return 0;
 			}
 			/*  well, this is next correct channel in list */
@@ -815,16 +813,14 @@ check_channel_list(struct comedi_device *dev,
 		/*  check whole chanlist */
 		for (i = 0, segpos = 0; i < chanlen; i++) {
 			    if (chanlist[i] != chansegment[i % seglen]) {
-				printk(KERN_WARNING
-				       "comedi%d: pcl816: bad channel or range"
-				       " number! chanlist[%i]=%d,%d,%d and not"
-				       " %d,%d,%d!\n", dev->minor, i,
-				       CR_CHAN(chansegment[i]),
-				       CR_RANGE(chansegment[i]),
-				       CR_AREF(chansegment[i]),
-				       CR_CHAN(chanlist[i % seglen]),
-				       CR_RANGE(chanlist[i % seglen]),
-				       CR_AREF(chansegment[i % seglen]));
+				dev_dbg(dev->class_dev,
+					"bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
+					i, CR_CHAN(chansegment[i]),
+					CR_RANGE(chansegment[i]),
+					CR_AREF(chansegment[i]),
+					CR_CHAN(chanlist[i % seglen]),
+					CR_RANGE(chanlist[i % seglen]),
+					CR_AREF(chansegment[i % seglen]));
 				return 0;	/*  chan/gain list is strange */
 			}
 		}

commit c001798aa1346561cc97af96d8145d7f44d7d6c2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 22 10:46:21 2013 -0700

    staging: comedi: pcl816: remove use of DPRINTK
    
    Remove the DPRINTK messages that are just function trace noise.
    
    Use dev_dbg() instead of the DPRINTK macro to output the comedi
    debugging information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 36a96574b07d..7b92aa50aa7f 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -174,7 +174,6 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 	int n;
 	int timeout;
 
-	DPRINTK("mode 0 analog input\n");
 	/*  software trigger, DMA and INT off */
 	outb(0, dev->iobase + PCL816_CONTROL);
 	/*  clear INT (conversion end) flag */
@@ -370,8 +369,6 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl816_private *devpriv = dev->private;
 
-	DPRINTK("<I>");
-
 	if (!dev->attached) {
 		comedi_error(dev, "premature interrupt");
 		return IRQ_HANDLED;
@@ -608,7 +605,6 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	}
 
-	DPRINTK("pcl816 END: pcl812_ai_cmd()\n");
 	return 0;
 }
 
@@ -762,8 +758,8 @@ start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
 	udelay(1);
 
 	if (mode == 1) {
-		DPRINTK("mode %d, divisor1 %d, divisor2 %d\n", mode, divisor1,
-			divisor2);
+		dev_dbg(dev->class_dev, "mode %d, divisor1 %d, divisor2 %d\n",
+			mode, divisor1, divisor2);
 		outb(divisor2 & 0xff, dev->iobase + PCL816_CTR2);
 		outb((divisor2 >> 8) & 0xff, dev->iobase + PCL816_CTR2);
 		outb(divisor1 & 0xff, dev->iobase + PCL816_CTR1);

commit 76b9e33eaab6482c9fb46b1e6304168586e4f029
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 22 10:42:10 2013 -0700

    staging: comedi: pcl816: remove DEBUG macro
    
    This macro is only used to output some function tracing debug messages.
    These messages are just added noise so remove the DEBUG macro as well
    as the noise.
    
    Also, remove pcl816_cmdtest_out() which was only called as part of the
    DEBUG() in pcl816_ai_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index ab9d2bd26a20..36a96574b07d 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -44,8 +44,6 @@ Configuration Options:
 #include "comedi_fc.h"
 #include "8253.h"
 
-#define DEBUG(x) x
-
 /* boards constants */
 /* IO space len */
 #define PCLx1x_RANGE 16
@@ -403,22 +401,6 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 	return IRQ_NONE;
 }
 
-/*
-==============================================================================
-   COMMAND MODE
-*/
-static void pcl816_cmdtest_out(int e, struct comedi_cmd *cmd)
-{
-	printk(KERN_INFO "pcl816 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
-	       cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
-	printk(KERN_INFO "pcl816 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
-	       cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
-	printk(KERN_INFO "pcl816 e=%d stopsrc=%x scanend=%x\n", e,
-	       cmd->stop_src, cmd->scan_end_src);
-	printk(KERN_INFO "pcl816 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n",
-	       e, cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
-}
-
 /*
 ==============================================================================
 */
@@ -429,10 +411,6 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	int err = 0;
 	int tmp, divisor1 = 0, divisor2 = 0;
 
-	DEBUG(printk(KERN_INFO "pcl816 pcl812_ai_cmdtest\n");
-	      pcl816_cmdtest_out(-1, cmd);
-	     );
-
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
@@ -685,8 +663,6 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 {
 	struct pcl816_private *devpriv = dev->private;
 
-/* DEBUG(printk("pcl816_ai_cancel()\n");) */
-
 	if (devpriv->irq_blocked > 0) {
 		switch (devpriv->int816_mode) {
 		case INT_TYPE_AI1_DMA:
@@ -719,9 +695,7 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 			break;
 		}
 	}
-
-	DEBUG(printk("comedi: pcl816_ai_cancel() successful\n");)
-	    return 0;
+	return 0;
 }
 
 /*
@@ -823,11 +797,6 @@ check_channel_list(struct comedi_device *dev,
 		/*  first channel is every time ok */
 		chansegment[0] = chanlist[0];
 		for (i = 1, seglen = 1; i < chanlen; i++, seglen++) {
-			/*  build part of chanlist */
-			DEBUG(printk(KERN_INFO "%d. %d %d\n", i,
-				     CR_CHAN(chanlist[i]),
-				     CR_RANGE(chanlist[i]));)
-
 			/*  we detect loop, this must by finish */
 			    if (chanlist[0] == chanlist[i])
 				break;
@@ -849,11 +818,6 @@ check_channel_list(struct comedi_device *dev,
 
 		/*  check whole chanlist */
 		for (i = 0, segpos = 0; i < chanlen; i++) {
-			DEBUG(printk("%d %d=%d %d\n",
-				     CR_CHAN(chansegment[i % seglen]),
-				     CR_RANGE(chansegment[i % seglen]),
-				     CR_CHAN(chanlist[i]),
-				     CR_RANGE(chanlist[i]));)
 			    if (chanlist[i] != chansegment[i % seglen]) {
 				printk(KERN_WARNING
 				       "comedi%d: pcl816: bad channel or range"

commit 54d2dd8443d3fda0579ed0e479942c180725dac5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:30 2013 +0100

    staging: comedi: pcl816: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Change the "pcl816" module to use unsigned types to handle samples for
    consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 2fd9b178e0c6..ab9d2bd26a20 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -229,7 +229,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcl816_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[0];
-	int low, hi;
+	unsigned char low, hi;
 	int timeout = 50;	/* wait max 50us */
 
 	while (timeout--) {
@@ -281,7 +281,8 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
    analog input dma mode 1 & 3, 816 cards
 */
 static void transfer_from_dma_buf(struct comedi_device *dev,
-				  struct comedi_subdevice *s, short *ptr,
+				  struct comedi_subdevice *s,
+				  unsigned short *ptr,
 				  unsigned int bufptr, unsigned int len)
 {
 	struct pcl816_private *devpriv = dev->private;
@@ -324,7 +325,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 	struct comedi_subdevice *s = &dev->subdevices[0];
 	int len, bufptr, this_dma_buf;
 	unsigned long dma_flags;
-	short *ptr;
+	unsigned short *ptr;
 
 	disable_dma(devpriv->dma);
 	this_dma_buf = devpriv->next_dma_buf;
@@ -352,7 +353,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 	devpriv->dma_runs_to_end--;
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
 
-	ptr = (short *)devpriv->dmabuf[this_dma_buf];
+	ptr = (unsigned short *)devpriv->dmabuf[this_dma_buf];
 
 	len = (devpriv->hwdmasize[0] >> 1) - devpriv->ai_poll_ptr;
 	bufptr = devpriv->ai_poll_ptr;
@@ -665,7 +666,8 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	transfer_from_dma_buf(dev, s,
-			      (short *)devpriv->dmabuf[devpriv->next_dma_buf],
+			      (unsigned short *)devpriv->dmabuf[devpriv->
+								next_dma_buf],
 			      devpriv->ai_poll_ptr, top2);
 
 	devpriv->ai_poll_ptr = top1;	/*  new buffer position */

commit cb9cfd7ed3f6ed4c40167b4251cdb382b6b3ba1c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 26 11:40:15 2013 -0700

    staging: comedi: 8253.h: tidy up the i8253_cascade_ns_to_timer*() users
    
    Introduce a couple defines for the common 8254 oscillator base values
    used in the comedi drivers and remove the custom defines and open
    coded values.
    
    Change the i8253_cascade_ns_to_timer_2div() calls in the drivers to
    the more generic i8253_cascade_ns_to_timer(). They are identical due
    to the #define in the 8253.h header.
    
    Remove the extra mask by TRIG_ROUND_MASK of the 'round_mode' parameter
    to i8253_cascade_ns_to_timer(). That function already handles the mask.
    
    Tidy up all the calls to i8253_cascade_ns_to_timer().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index f03134962596..2fd9b178e0c6 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -481,8 +481,7 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(board->i8254_osc_base,
 					  &divisor1, &divisor2,
-					  &cmd->convert_arg,
-					  cmd->flags & TRIG_ROUND_MASK);
+					  &cmd->convert_arg, cmd->flags);
 		if (cmd->convert_arg < board->ai_ns_min)
 			cmd->convert_arg = board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
@@ -528,9 +527,9 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		if (cmd->convert_arg < board->ai_ns_min)
 			cmd->convert_arg = board->ai_ns_min;
 
-		i8253_cascade_ns_to_timer(board->i8254_osc_base, &divisor1,
-					  &divisor2, &cmd->convert_arg,
-					  cmd->flags & TRIG_ROUND_MASK);
+		i8253_cascade_ns_to_timer(board->i8254_osc_base,
+					  &divisor1, &divisor2,
+					  &cmd->convert_arg, cmd->flags);
 
 		/*  PCL816 crash if any divisor is set to 1 */
 		if (divisor1 == 1) {
@@ -1105,7 +1104,7 @@ static const struct pcl816_board boardtypes[] = {
 	 0xffff,		/*  D/A maxdata */
 	 1024,
 	 1,			/*  ao chan list */
-	 100},
+	 I8254_OSC_BASE_10MHZ},
 	{"pcl814b", 8, 16, 10000, 1, 16, 16, &range_pcl816,
 	 &range_pcl816, PCLx1x_RANGE,
 	 0x00fc,
@@ -1114,7 +1113,7 @@ static const struct pcl816_board boardtypes[] = {
 	 0x3fff,
 	 1024,
 	 1,
-	 100},
+	 I8254_OSC_BASE_10MHZ},
 };
 
 static struct comedi_driver pcl816_driver = {

commit 8e6b7915a1da703617dca28c33e150141fcec9b0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:05:07 2013 -0700

    staging: comedi: drivers do not need <linux/ioport.h>
    
    All the ioport resources are managed by the comedi core. None of
    the drivers depend on <linux/ioport.h>. Remove the includes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index dfce2a5599ce..f03134962596 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -35,7 +35,6 @@ Configuration Options:
 #include <linux/module.h>
 #include "../comedidev.h"
 
-#include <linux/ioport.h>
 #include <linux/gfp.h>
 #include <linux/delay.h>
 #include <linux/io.h>

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 02285976177a..dfce2a5599ce 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -32,6 +32,7 @@ Configuration Options:
 
 */
 
+#include <linux/module.h>
 #include "../comedidev.h"
 
 #include <linux/ioport.h>

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 91bd2071f571..02285976177a 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -922,10 +922,9 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EIO;
 	}
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	/* grab our IRQ */
 	irq = 0;

commit a4b47eeac2fe1687a6af0d30509a39b23a466cf6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 19 17:14:30 2013 -0700

    staging: comedi: pcl816: remove unused RTC dma support
    
    All the RTC dma support code in this driver is #ifdef'ed out.
    
    Remove the unused code to assist in cleaning up this driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 10e09609924d..91bd2071f571 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -35,10 +35,10 @@ Configuration Options:
 #include "../comedidev.h"
 
 #include <linux/ioport.h>
-#include <linux/mc146818rtc.h>
 #include <linux/gfp.h>
 #include <linux/delay.h>
 #include <linux/io.h>
+#include <linux/interrupt.h>
 #include <asm/dma.h>
 
 #include "comedi_fc.h"
@@ -82,14 +82,6 @@ Configuration Options:
 #define INT_TYPE_AI1_DMA 2
 #define INT_TYPE_AI3_INT 4
 #define INT_TYPE_AI3_DMA 5
-#ifdef unused
-#define INT_TYPE_AI1_DMA_RTC 9
-#define INT_TYPE_AI3_DMA_RTC 10
-
-/* RTC stuff... */
-#define RTC_IRQ		8
-#define RTC_IO_EXTENT	0x10
-#endif
 
 #define MAGIC_DMA_WORD 0x5a5a
 
@@ -126,26 +118,14 @@ struct pcl816_board {
 	int i8254_osc_base;	/*  1/frequency of on board oscilator in ns */
 };
 
-#ifdef unused
-static int RTC_lock;	/* RTC lock */
-static int RTC_timer_lock;	/* RTC int lock */
-#endif
-
 struct pcl816_private {
 
 	unsigned int dma;	/*  used DMA, 0=don't use DMA */
-	int dma_rtc;		/*  1=RTC used with DMA, 0=no RTC alloc */
-#ifdef unused
-	unsigned long rtc_iobase;	/*  RTC port region */
-	unsigned int rtc_iosize;
-	unsigned int rtc_irq;
-#endif
 	unsigned long dmabuf[2];	/*  pointers to begin of DMA buffers */
 	unsigned int dmapages[2];	/*  len of DMA buffers in PAGE_SIZEs */
 	unsigned int hwdmaptr[2];	/*  hardware address of DMA buffers */
 	unsigned int hwdmasize[2];	/*  len of DMA buffers in Bytes */
 	unsigned int dmasamplsize;	/*  size in samples hwdmasize[0]/2 */
-	unsigned int last_top_dma;	/*  DMA pointer in last RTC int */
 	int next_dma_buf;	/*  which DMA buffer will be used next round */
 	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
 	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
@@ -154,9 +134,6 @@ struct pcl816_private {
 	unsigned char ai_neverending;	/*  if=1, then we do neverending record (you must use cancel()) */
 	int irq_free;		/*  1=have allocated IRQ */
 	int irq_blocked;	/*  1=IRQ now uses any subdev */
-#ifdef unused
-	int rtc_irq_blocked;	/*  1=we now do AI with DMA&RTC */
-#endif
 	int irq_was_now_closed;	/*  when IRQ finish, there's stored int816_mode for last interrupt */
 	int int816_mode;	/*  who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma */
 	struct comedi_subdevice *last_int_sub;	/*  ptr to subdevice which now finish */
@@ -167,10 +144,6 @@ struct pcl816_private {
 	unsigned int ai_n_chan;		/*  how many channels per scan */
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
 	struct comedi_subdevice *sub_ai;	/*  ptr to AI subdevice */
-#ifdef unused
-	struct timer_list rtc_irq_timer;	/*  timer for RTC sanity check */
-	unsigned long rtc_freq;	/*  RTC int freq */
-#endif
 };
 
 /*
@@ -186,9 +159,6 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s);
 static void start_pacer(struct comedi_device *dev, int mode,
 			unsigned int divisor1, unsigned int divisor2);
-#ifdef unused
-static int set_rtc_irq_bit(unsigned char bit);
-#endif
 
 static int pcl816_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
@@ -718,12 +688,6 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 
 	if (devpriv->irq_blocked > 0) {
 		switch (devpriv->int816_mode) {
-#ifdef unused
-		case INT_TYPE_AI1_DMA_RTC:
-		case INT_TYPE_AI3_DMA_RTC:
-			set_rtc_irq_bit(0);	/*  stop RTC */
-			del_timer(&devpriv->rtc_irq_timer);
-#endif
 		case INT_TYPE_AI1_DMA:
 		case INT_TYPE_AI3_DMA:
 			disable_dma(devpriv->dma);
@@ -939,43 +903,6 @@ setup_channel_list(struct comedi_device *dev,
 	     dev->iobase + PCL816_MUX);
 }
 
-#ifdef unused
-/*
-==============================================================================
-  Enable(1)/disable(0) periodic interrupts from RTC
-*/
-static int set_rtc_irq_bit(unsigned char bit)
-{
-	unsigned char val;
-	unsigned long flags;
-
-	if (bit == 1) {
-		RTC_timer_lock++;
-		if (RTC_timer_lock > 1)
-			return 0;
-	} else {
-		RTC_timer_lock--;
-		if (RTC_timer_lock < 0)
-			RTC_timer_lock = 0;
-		if (RTC_timer_lock > 0)
-			return 0;
-	}
-
-	save_flags(flags);
-	cli();
-	val = CMOS_READ(RTC_CONTROL);
-	if (bit)
-		val |= RTC_PIE;
-	else
-		val &= ~RTC_PIE;
-
-	CMOS_WRITE(val, RTC_CONTROL);
-	CMOS_READ(RTC_INTR_FLAGS);
-	restore_flags(flags);
-	return 0;
-}
-#endif
-
 static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl816_board *board = comedi_board(dev);
@@ -1033,47 +960,10 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
 	devpriv->int816_mode = 0;	/* mode of irq */
 
-#ifdef unused
-	/* grab RTC for DMA operations */
-	devpriv->dma_rtc = 0;
-	if (it->options[2] > 0) {	/*  we want to use DMA */
-		if (RTC_lock == 0) {
-			ret = __comedi_request_region(dev, RTC_PORT(0),
-						      RTC_IO_EXTENT);
-			if (ret)
-				goto no_rtc;
-		}
-		devpriv->rtc_iobase = RTC_PORT(0);
-		devpriv->rtc_iosize = RTC_IO_EXTENT;
-		RTC_lock++;
-#ifdef UNTESTED_CODE
-		if (!request_irq(RTC_IRQ, interrupt_pcl816_ai_mode13_dma_rtc, 0,
-				 "pcl816 DMA (RTC)", dev)) {
-			devpriv->dma_rtc = 1;
-			devpriv->rtc_irq = RTC_IRQ;
-			printk(", dma_irq=%u", devpriv->rtc_irq);
-		} else {
-			RTC_lock--;
-			if (RTC_lock == 0) {
-				if (devpriv->rtc_iobase)
-					release_region(devpriv->rtc_iobase,
-						       devpriv->rtc_iosize);
-			}
-			devpriv->rtc_iobase = 0;
-			devpriv->rtc_iosize = 0;
-		}
-#else
-		printk("pcl816: RTC code missing");
-#endif
-
-	}
-
-no_rtc:
-#endif
 	/* grab our DMA */
 	dma = 0;
 	devpriv->dma = dma;
-	if ((devpriv->irq_free == 0) && (devpriv->dma_rtc == 0))
+	if (!devpriv->irq_free)
 		goto no_dma;	/* if we haven't IRQ, we can't use DMA */
 
 	if (board->DMAbits != 0) {	/* board support DMA */
@@ -1110,19 +1000,16 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
 		/* printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
 
-		if (devpriv->dma_rtc == 0) {	/*  we must do duble buff :-( */
-			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
-			if (!devpriv->dmabuf[1]) {
-				printk(KERN_ERR
-				       ", unable to allocate DMA buffer, "
-				       "FAIL!\n");
-				return -EBUSY;
-			}
-			devpriv->dmapages[1] = pages;
-			devpriv->hwdmaptr[1] =
-			    virt_to_bus((void *)devpriv->dmabuf[1]);
-			devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
+		devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
+		if (!devpriv->dmabuf[1]) {
+			printk(KERN_ERR
+				", unable to allocate DMA buffer, "
+				"FAIL!\n");
+			return -EBUSY;
 		}
+		devpriv->dmapages[1] = pages;
+		devpriv->hwdmaptr[1] = virt_to_bus((void *)devpriv->dmabuf[1]);
+		devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
 	}
 
 no_dma:
@@ -1206,17 +1093,6 @@ static void pcl816_detach(struct comedi_device *dev)
 			free_pages(devpriv->dmabuf[0], devpriv->dmapages[0]);
 		if (devpriv->dmabuf[1])
 			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
-#ifdef unused
-		if (devpriv->rtc_irq)
-			free_irq(devpriv->rtc_irq, dev);
-		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
-			if (devpriv->rtc_iobase)
-				release_region(devpriv->rtc_iobase,
-					       devpriv->rtc_iosize);
-		}
-		if (devpriv->dma_rtc)
-			RTC_lock--;
-#endif
 	}
 	comedi_legacy_detach(dev);
 }

commit 3d1fe3f785c80e17f62acf8f92570ae9210bd588
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:37 2013 -0700

    staging: comedi: drivers: free_irq() in comedi_legacy_detach()
    
    All the legacy comedi drivers now call comedi_legacy_detach()
    either directly or as part of their (*detach). Move the free_irq()
    into comedi_legacy_detach() so that the drivers don't have to
    deal with it.
    
    For drivers that then only call comedi_legacy_detach() in their
    private (*detach), remove the private function and use the helper
    directly for the (*detach).
    
    The amplc_pc236 and ni_labpc drivers are hybrid legacy/PCI drivers.
    In the detach of a PCI board free_irq() still needs to be handled
    by the driver.
    
    The pcl724 and pcl726 drivers currently have the free_irq() #ifdef'ed
    out. The comedi_legacy_detach() function sanity checks that the irq
    has been requested before freeing it so they are safe to convert.
    
    For aesthetic reasons, move the #ifdef unused chunk in the pcl816
    driver up to the previous #ifdef unused block.
    
    The pcmio and pcmuio drivers request multiple irqs and handle the
    freeing of them. Remove the 'dev->irq = irq[0]' in those drivers
    so that comedi_legacy_detach() does not attempt to free the irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 4ea6fec5d342..10e09609924d 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -1214,14 +1214,10 @@ static void pcl816_detach(struct comedi_device *dev)
 				release_region(devpriv->rtc_iobase,
 					       devpriv->rtc_iosize);
 		}
+		if (devpriv->dma_rtc)
+			RTC_lock--;
 #endif
 	}
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-#ifdef unused
-	if (devpriv->dma_rtc)
-		RTC_lock--;
-#endif
 	comedi_legacy_detach(dev);
 }
 

commit a32c6d0084992d3e58a93120c9ce9527e80c651e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:19 2013 -0700

    staging: comedi: drivers: use comedi_legacy_detach()
    
    Use comedi_legacy_detach() to release the I/O region requested
    by these drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 2fd688a5c63e..4ea6fec5d342 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -1195,7 +1195,6 @@ case COMEDI_SUBD_DO:
 
 static void pcl816_detach(struct comedi_device *dev)
 {
-	const struct pcl816_board *board = comedi_board(dev);
 	struct pcl816_private *devpriv = dev->private;
 
 	if (dev->private) {
@@ -1219,12 +1218,11 @@ static void pcl816_detach(struct comedi_device *dev)
 	}
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (dev->iobase)
-		release_region(dev->iobase, board->io_range);
 #ifdef unused
 	if (devpriv->dma_rtc)
 		RTC_lock--;
 #endif
+	comedi_legacy_detach(dev);
 }
 
 static const struct pcl816_board boardtypes[] = {

commit 8cafadee50dec318d2a9aca701eb43073bb600eb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:31:44 2013 -0700

    staging: comedi: pcl816: use __comedi_request_region()
    
    Use __comedi_request_region() to request the additional I/O region
    used by this driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 6266b2b02597..2fd688a5c63e 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -1038,8 +1038,9 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->dma_rtc = 0;
 	if (it->options[2] > 0) {	/*  we want to use DMA */
 		if (RTC_lock == 0) {
-			if (!request_region(RTC_PORT(0), RTC_IO_EXTENT,
-					    "pcl816 (RTC)"))
+			ret = __comedi_request_region(dev, RTC_PORT(0),
+						      RTC_IO_EXTENT);
+			if (ret)
 				goto no_rtc;
 		}
 		devpriv->rtc_iobase = RTC_PORT(0);

commit 22b580f07ec7cf8452496d7ad80b29ca22e1c541
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:10:53 2013 -0700

    staging: comedi: pcl816: use comedi_request_region()
    
    Use comedi_request_region() to request the I/O region used by this
    driver.
    
    Remove the noise when the board is first attached as well as the
    error message when the request_region() fails, comedi_request_reqion()
    will output the error message if necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index eb0816e75d61..6266b2b02597 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -981,25 +981,16 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct pcl816_board *board = comedi_board(dev);
 	struct pcl816_private *devpriv;
 	int ret;
-	unsigned long iobase;
 	unsigned int irq, dma;
 	unsigned long pages;
 	/* int i; */
 	struct comedi_subdevice *s;
 
-	/* claim our I/O space */
-	iobase = it->options[0];
-	printk("comedi%d: pcl816:  board=%s, ioport=0x%03lx", dev->minor,
-	       board->name, iobase);
-
-	if (!request_region(iobase, board->io_range, dev->board_name)) {
-		printk("I/O port conflict\n");
-		return -EIO;
-	}
-
-	dev->iobase = iobase;
+	ret = comedi_request_region(dev, it->options[0], board->io_range);
+	if (ret)
+		return ret;
 
-	if (pcl816_check(iobase)) {
+	if (pcl816_check(dev->iobase)) {
 		printk(KERN_ERR ", I cann't detect board. FAIL!\n");
 		return -EIO;
 	}

commit 92e5c90dcce34f981a625f3343a3a9baee008396
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:10:31 2013 -0700

    staging: comedi: pcl816: cleanup dev->board_name usage
    
    This legacy driver does no additional probing so the dev->board_name
    will already be properly initialized by the comedi core before calling
    the (*attach) function.
    
    Remove the unnecessary initialization of dev->board_name and use it
    when requesting the resources instead of the open-coded strings.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index ebd9e4706050..eb0816e75d61 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -992,7 +992,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	printk("comedi%d: pcl816:  board=%s, ioport=0x%03lx", dev->minor,
 	       board->name, iobase);
 
-	if (!request_region(iobase, board->io_range, "pcl816")) {
+	if (!request_region(iobase, board->io_range, dev->board_name)) {
 		printk("I/O port conflict\n");
 		return -EIO;
 	}
@@ -1009,8 +1009,6 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	dev->board_name = board->name;
-
 	/* grab our IRQ */
 	irq = 0;
 	if (board->IRQbits != 0) {	/* board support IRQ */
@@ -1022,8 +1020,8 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				     "DISABLING IT", irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (request_irq
-				    (irq, interrupt_pcl816, 0, "pcl816", dev)) {
+				if (request_irq(irq, interrupt_pcl816, 0,
+						dev->board_name, dev)) {
 					printk
 					    (", unable to allocate IRQ %u, "
 					     "DISABLING IT", irq);
@@ -1095,7 +1093,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			printk(", DMA is out of allowed range, FAIL!\n");
 			return -EINVAL;	/* Bad DMA */
 		}
-		ret = request_dma(dma, "pcl816");
+		ret = request_dma(dma, dev->board_name);
 		if (ret) {
 			printk(KERN_ERR
 			       ", unable to allocate DMA %u, FAIL!\n", dma);

commit 20ce161d2f53af092fe8dabfef6fb0d7af846c43
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Thu Mar 7 23:48:40 2013 +0900

    staging: comedi: Fix typo in comedi
    
    Correct spelling typos in staging/comedi
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index f625fdab335c..ebd9e4706050 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -837,7 +837,7 @@ start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
 
 /*
 ==============================================================================
- Check if channel list from user is builded correctly
+ Check if channel list from user is built correctly
  If it's ok, then return non-zero length of repeated segment of channel list
 */
 static int

commit b93e56ade2395dd0320a262e8d4741ce1fc582e0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:58:16 2012 -0700

    staging: comedi: pcl816: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of pcl816_ai_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 858600a753b1..f625fdab335c 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -484,43 +484,23 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 		return 2;
 
 
-	/* step 3: make sure arguments are trivially compatible */
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->scan_begin_arg != 0) {
-		cmd->scan_begin_arg = 0;
-		err++;
-	}
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < board->ai_ns_min) {
-			cmd->convert_arg = board->ai_ns_min;
-			err++;
-		}
-	} else {		/* TRIG_EXT */
-		if (cmd->convert_arg != 0) {
-			cmd->convert_arg = 0;
-			err++;
-		}
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-	if (cmd->stop_src == TRIG_COUNT) {
-		if (!cmd->stop_arg) {
-			cmd->stop_arg = 1;
-			err++;
-		}
-	} else {		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
+	if (cmd->convert_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+						 board->ai_ns_min);
+	else	/* TRIG_EXT */
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 4cdb3c915f5f..858600a753b1 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -1024,10 +1024,10 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EIO;
 	}
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	dev->board_name = board->name;
 

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 0822de058e4d..4cdb3c915f5f 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -126,8 +126,6 @@ struct pcl816_board {
 	int i8254_osc_base;	/*  1/frequency of on board oscilator in ns */
 };
 
-#define devpriv ((struct pcl816_private *)dev->private)
-
 #ifdef unused
 static int RTC_lock;	/* RTC lock */
 static int RTC_timer_lock;	/* RTC int lock */
@@ -259,6 +257,7 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct pcl816_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[0];
 	int low, hi;
 	int timeout = 50;	/* wait max 50us */
@@ -315,6 +314,7 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 				  struct comedi_subdevice *s, short *ptr,
 				  unsigned int bufptr, unsigned int len)
 {
+	struct pcl816_private *devpriv = dev->private;
 	int i;
 
 	s->async->events = 0;
@@ -350,6 +350,7 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct pcl816_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[0];
 	int len, bufptr, this_dma_buf;
 	unsigned long dma_flags;
@@ -398,6 +399,8 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 static irqreturn_t interrupt_pcl816(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct pcl816_private *devpriv = dev->private;
+
 	DPRINTK("<I>");
 
 	if (!dev->attached) {
@@ -554,6 +557,7 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct pcl816_board *board = comedi_board(dev);
+	struct pcl816_private *devpriv = dev->private;
 	unsigned int divisor1 = 0, divisor2 = 0, dma_flags, bytes, dmairq;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int seglen;
@@ -682,6 +686,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct pcl816_private *devpriv = dev->private;
 	unsigned long flags;
 	unsigned int top1, top2, i;
 
@@ -727,6 +732,8 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 static int pcl816_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
+	struct pcl816_private *devpriv = dev->private;
+
 /* DEBUG(printk("pcl816_ai_cancel()\n");) */
 
 	if (devpriv->irq_blocked > 0) {
@@ -932,6 +939,7 @@ setup_channel_list(struct comedi_device *dev,
 		   struct comedi_subdevice *s, unsigned int *chanlist,
 		   unsigned int seglen)
 {
+	struct pcl816_private *devpriv = dev->private;
 	unsigned int i;
 
 	devpriv->ai_act_chanlist_len = seglen;
@@ -991,6 +999,7 @@ static int set_rtc_irq_bit(unsigned char bit)
 static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcl816_board *board = comedi_board(dev);
+	struct pcl816_private *devpriv;
 	int ret;
 	unsigned long iobase;
 	unsigned int irq, dma;
@@ -1015,9 +1024,10 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EIO;
 	}
 
-	ret = alloc_private(dev, sizeof(struct pcl816_private));
-	if (ret < 0)
-		return ret;	/* Can't alloc mem */
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
+		return ret;
+	devpriv = dev->private;
 
 	dev->board_name = board->name;
 
@@ -1216,6 +1226,7 @@ case COMEDI_SUBD_DO:
 static void pcl816_detach(struct comedi_device *dev)
 {
 	const struct pcl816_board *board = comedi_board(dev);
+	struct pcl816_private *devpriv = dev->private;
 
 	if (dev->private) {
 		pcl816_ai_cancel(dev, devpriv->sub_ai);

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index f65fd66cc8a2..0822de058e4d 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -41,6 +41,7 @@ Configuration Options:
 #include <linux/io.h>
 #include <asm/dma.h>
 
+#include "comedi_fc.h"
 #include "8253.h"
 
 #define DEBUG(x) x
@@ -458,48 +459,23 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	      pcl816_cmdtest_out(-1, cmd);
 	     );
 
-	/* step 1: make sure trigger sources are trivially valid */
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_FOLLOW;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_EXT | TRIG_TIMER;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_EXT | TRIG_TIMER);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
+	/* Step 2a : make sure trigger sources are unique */
 
-	/*
-	 * step 2: make sure trigger sources
-	 * are unique and mutually compatible
-	 */
-
-	if (cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_TIMER) {
-		cmd->convert_src = TRIG_TIMER;
-		err++;
-	}
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
 
-	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
-		err++;
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit 9417de06e02b8d968d52e7d59e7f751d592e322e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:52:49 2012 -0700

    staging: comedi: pcl816: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index ba6911f063cb..f65fd66cc8a2 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -258,7 +258,7 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct comedi_subdevice *s = dev->subdevices + 0;
+	struct comedi_subdevice *s = &dev->subdevices[0];
 	int low, hi;
 	int timeout = 50;	/* wait max 50us */
 
@@ -349,7 +349,7 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct comedi_subdevice *s = dev->subdevices + 0;
+	struct comedi_subdevice *s = &dev->subdevices[0];
 	int len, bufptr, this_dma_buf;
 	unsigned long dma_flags;
 	short *ptr;
@@ -1183,7 +1183,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	if (board->n_aichan > 0) {
 		s->type = COMEDI_SUBD_AI;
 		devpriv->sub_ai = s;

commit 2b8557a734ab17d2cbb96a79bc267b30055e0ef3
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 13 17:50:53 2012 -0700

    staging: comedi: pcl816: remove unneeded tests in pcl816_ai_cmdtest
    
    The step 2 tests of the start_src, scan_begin_src, and scan_end_src
    triggers to make sure they are unique are not needed.  These triggers
    all only have one source and it was trivially validated in step 1.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index c3ee6d69b9a6..ba6911f063cb 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -493,26 +493,11 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	 * are unique and mutually compatible
 	 */
 
-	if (cmd->start_src != TRIG_NOW) {
-		cmd->start_src = TRIG_NOW;
-		err++;
-	}
-
-	if (cmd->scan_begin_src != TRIG_FOLLOW) {
-		cmd->scan_begin_src = TRIG_FOLLOW;
-		err++;
-	}
-
 	if (cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_TIMER) {
 		cmd->convert_src = TRIG_TIMER;
 		err++;
 	}
 
-	if (cmd->scan_end_src != TRIG_COUNT) {
-		cmd->scan_end_src = TRIG_COUNT;
-		err++;
-	}
-
 	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
 		err++;
 

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 37cedbc47a43..c3ee6d69b9a6 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -1195,7 +1195,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 */
 
 	ret = comedi_alloc_subdevices(dev, 1);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	s = dev->subdevices + 0;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 845039cd6207..37cedbc47a43 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -1194,7 +1194,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
     subdevs[3] = COMEDI_SUBD_DO;
 */
 
-	ret = alloc_subdevices(dev, 1);
+	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret < 0)
 		return ret;
 

commit e26d925f42064a800c1226e15dbaa23da1721fb7
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Jun 7 17:25:35 2012 -0700

    staging: comedi: pcl816: if test should use logical OR not bitwise OR
    
    This quiets a couple sparse warnings about:
    
    warning: dubious: !x | !y
    warning: dubious: x | !y
    
    Also, remove the unnecessary parentheses abound the variables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 277a23ece6fa..845039cd6207 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -414,8 +414,8 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 	}
 
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
-	if ((!dev->irq) | (!devpriv->irq_free) | (!devpriv->irq_blocked) |
-	    (!devpriv->int816_mode)) {
+	if (!dev->irq || !devpriv->irq_free || !devpriv->irq_blocked ||
+	    !devpriv->int816_mode) {
 		if (devpriv->irq_was_now_closed) {
 			devpriv->irq_was_now_closed = 0;
 			/*  comedi_error(dev,"last IRQ.."); */

commit 240c6e6a7125fd7a6ebcbdd8fbbf646df0f69186
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 22 17:14:14 2012 -0700

    staging: comedi: remove this_board macro in the pcl816 driver
    
    The 'this_board' macro depends on having a local variable with
    a magic name. The CodingStyle document suggests not doing this
    to avoid confusion. Remove the macro and use the comedi_board()
    inline helper to get the dev->board_ptr information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index cc67b6d46059..277a23ece6fa 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -126,7 +126,6 @@ struct pcl816_board {
 };
 
 #define devpriv ((struct pcl816_private *)dev->private)
-#define this_board ((const struct pcl816_board *)dev->board_ptr)
 
 #ifdef unused
 static int RTC_lock;	/* RTC lock */
@@ -451,6 +450,7 @@ static void pcl816_cmdtest_out(int e, struct comedi_cmd *cmd)
 static int pcl816_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
+	const struct pcl816_board *board = comedi_board(dev);
 	int err = 0;
 	int tmp, divisor1 = 0, divisor2 = 0;
 
@@ -531,8 +531,8 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 		err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < this_board->ai_ns_min) {
-			cmd->convert_arg = this_board->ai_ns_min;
+		if (cmd->convert_arg < board->ai_ns_min) {
+			cmd->convert_arg = board->ai_ns_min;
 			err++;
 		}
 	} else {		/* TRIG_EXT */
@@ -565,12 +565,12 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
-		i8253_cascade_ns_to_timer(this_board->i8254_osc_base,
+		i8253_cascade_ns_to_timer(board->i8254_osc_base,
 					  &divisor1, &divisor2,
 					  &cmd->convert_arg,
 					  cmd->flags & TRIG_ROUND_MASK);
-		if (cmd->convert_arg < this_board->ai_ns_min)
-			cmd->convert_arg = this_board->ai_ns_min;
+		if (cmd->convert_arg < board->ai_ns_min)
+			cmd->convert_arg = board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -592,6 +592,7 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 
 static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	const struct pcl816_board *board = comedi_board(dev);
 	unsigned int divisor1 = 0, divisor2 = 0, dma_flags, bytes, dmairq;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int seglen;
@@ -609,10 +610,10 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EBUSY;
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < this_board->ai_ns_min)
-			cmd->convert_arg = this_board->ai_ns_min;
+		if (cmd->convert_arg < board->ai_ns_min)
+			cmd->convert_arg = board->ai_ns_min;
 
-		i8253_cascade_ns_to_timer(this_board->i8254_osc_base, &divisor1,
+		i8253_cascade_ns_to_timer(board->i8254_osc_base, &divisor1,
 					  &divisor2, &cmd->convert_arg,
 					  cmd->flags & TRIG_ROUND_MASK);
 
@@ -1028,6 +1029,7 @@ static int set_rtc_irq_bit(unsigned char bit)
 
 static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	const struct pcl816_board *board = comedi_board(dev);
 	int ret;
 	unsigned long iobase;
 	unsigned int irq, dma;
@@ -1038,9 +1040,9 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* claim our I/O space */
 	iobase = it->options[0];
 	printk("comedi%d: pcl816:  board=%s, ioport=0x%03lx", dev->minor,
-	       this_board->name, iobase);
+	       board->name, iobase);
 
-	if (!request_region(iobase, this_board->io_range, "pcl816")) {
+	if (!request_region(iobase, board->io_range, "pcl816")) {
 		printk("I/O port conflict\n");
 		return -EIO;
 	}
@@ -1056,15 +1058,14 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret < 0)
 		return ret;	/* Can't alloc mem */
 
-	/* set up some name stuff */
-	dev->board_name = this_board->name;
+	dev->board_name = board->name;
 
 	/* grab our IRQ */
 	irq = 0;
-	if (this_board->IRQbits != 0) {	/* board support IRQ */
+	if (board->IRQbits != 0) {	/* board support IRQ */
 		irq = it->options[1];
 		if (irq) {	/* we want to use IRQ */
-			if (((1 << irq) & this_board->IRQbits) == 0) {
+			if (((1 << irq) & board->IRQbits) == 0) {
 				printk
 				    (", IRQ %u is out of allowed range, "
 				     "DISABLING IT", irq);
@@ -1134,12 +1135,12 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if ((devpriv->irq_free == 0) && (devpriv->dma_rtc == 0))
 		goto no_dma;	/* if we haven't IRQ, we can't use DMA */
 
-	if (this_board->DMAbits != 0) {	/* board support DMA */
+	if (board->DMAbits != 0) {	/* board support DMA */
 		dma = it->options[2];
 		if (dma < 1)
 			goto no_dma;	/* DMA disabled */
 
-		if (((1 << dma) & this_board->DMAbits) == 0) {
+		if (((1 << dma) & board->DMAbits) == 0) {
 			printk(", DMA is out of allowed range, FAIL!\n");
 			return -EINVAL;	/* Bad DMA */
 		}
@@ -1185,11 +1186,11 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 no_dma:
 
-/*  if (this_board->n_aochan > 0)
+/*  if (board->n_aochan > 0)
     subdevs[1] = COMEDI_SUBD_AO;
-  if (this_board->n_dichan > 0)
+  if (board->n_dichan > 0)
     subdevs[2] = COMEDI_SUBD_DI;
-  if (this_board->n_dochan > 0)
+  if (board->n_dochan > 0)
     subdevs[3] = COMEDI_SUBD_DO;
 */
 
@@ -1198,17 +1199,17 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return ret;
 
 	s = dev->subdevices + 0;
-	if (this_board->n_aichan > 0) {
+	if (board->n_aichan > 0) {
 		s->type = COMEDI_SUBD_AI;
 		devpriv->sub_ai = s;
 		dev->read_subdev = s;
 		s->subdev_flags = SDF_READABLE | SDF_CMD_READ;
-		s->n_chan = this_board->n_aichan;
+		s->n_chan = board->n_aichan;
 		s->subdev_flags |= SDF_DIFF;
 		/* printk (", %dchans DIFF DAC - %d", s->n_chan, i); */
-		s->maxdata = this_board->ai_maxdata;
-		s->len_chanlist = this_board->ai_chanlist;
-		s->range_table = this_board->ai_range_type;
+		s->maxdata = board->ai_maxdata;
+		s->len_chanlist = board->ai_chanlist;
+		s->range_table = board->ai_range_type;
 		s->cancel = pcl816_ai_cancel;
 		s->do_cmdtest = pcl816_ai_cmdtest;
 		s->do_cmd = pcl816_ai_cmd;
@@ -1221,25 +1222,25 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 #if 0
 case COMEDI_SUBD_AO:
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
-	s->n_chan = this_board->n_aochan;
-	s->maxdata = this_board->ao_maxdata;
-	s->len_chanlist = this_board->ao_chanlist;
-	s->range_table = this_board->ao_range_type;
+	s->n_chan = board->n_aochan;
+	s->maxdata = board->ao_maxdata;
+	s->len_chanlist = board->ao_chanlist;
+	s->range_table = board->ao_range_type;
 	break;
 
 case COMEDI_SUBD_DI:
 	s->subdev_flags = SDF_READABLE;
-	s->n_chan = this_board->n_dichan;
+	s->n_chan = board->n_dichan;
 	s->maxdata = 1;
-	s->len_chanlist = this_board->n_dichan;
+	s->len_chanlist = board->n_dichan;
 	s->range_table = &range_digital;
 	break;
 
 case COMEDI_SUBD_DO:
 	s->subdev_flags = SDF_WRITABLE;
-	s->n_chan = this_board->n_dochan;
+	s->n_chan = board->n_dochan;
 	s->maxdata = 1;
-	s->len_chanlist = this_board->n_dochan;
+	s->len_chanlist = board->n_dochan;
 	s->range_table = &range_digital;
 	break;
 #endif
@@ -1253,6 +1254,8 @@ case COMEDI_SUBD_DO:
 
 static void pcl816_detach(struct comedi_device *dev)
 {
+	const struct pcl816_board *board = comedi_board(dev);
+
 	if (dev->private) {
 		pcl816_ai_cancel(dev, devpriv->sub_ai);
 		pcl816_reset(dev);
@@ -1275,7 +1278,7 @@ static void pcl816_detach(struct comedi_device *dev)
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (dev->iobase)
-		release_region(dev->iobase, this_board->io_range);
+		release_region(dev->iobase, board->io_range);
 #ifdef unused
 	if (devpriv->dma_rtc)
 		RTC_lock--;

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 1559c05b8f14..cc67b6d46059 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -1026,40 +1026,6 @@ static int set_rtc_irq_bit(unsigned char bit)
 }
 #endif
 
-/*
-==============================================================================
-  Free any resources that we have claimed
-*/
-static void free_resources(struct comedi_device *dev)
-{
-	/* printk("free_resource()\n"); */
-	if (dev->private) {
-		pcl816_ai_cancel(dev, devpriv->sub_ai);
-		pcl816_reset(dev);
-		if (devpriv->dma)
-			free_dma(devpriv->dma);
-		if (devpriv->dmabuf[0])
-			free_pages(devpriv->dmabuf[0], devpriv->dmapages[0]);
-		if (devpriv->dmabuf[1])
-			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
-#ifdef unused
-		if (devpriv->rtc_irq)
-			free_irq(devpriv->rtc_irq, dev);
-		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
-			if (devpriv->rtc_iobase)
-				release_region(devpriv->rtc_iobase,
-					       devpriv->rtc_iosize);
-		}
-#endif
-	}
-
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	if (dev->iobase)
-		release_region(dev->iobase, this_board->io_range);
-	/* printk("free_resource() end\n"); */
-}
-
 static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	int ret;
@@ -1285,15 +1251,35 @@ case COMEDI_SUBD_DO:
 	return 0;
 }
 
-static int pcl816_detach(struct comedi_device *dev)
+static void pcl816_detach(struct comedi_device *dev)
 {
-	DEBUG(printk(KERN_INFO "comedi%d: pcl816: remove\n", dev->minor);)
-	    free_resources(dev);
+	if (dev->private) {
+		pcl816_ai_cancel(dev, devpriv->sub_ai);
+		pcl816_reset(dev);
+		if (devpriv->dma)
+			free_dma(devpriv->dma);
+		if (devpriv->dmabuf[0])
+			free_pages(devpriv->dmabuf[0], devpriv->dmapages[0]);
+		if (devpriv->dmabuf[1])
+			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
+#ifdef unused
+		if (devpriv->rtc_irq)
+			free_irq(devpriv->rtc_irq, dev);
+		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
+			if (devpriv->rtc_iobase)
+				release_region(devpriv->rtc_iobase,
+					       devpriv->rtc_iosize);
+		}
+#endif
+	}
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	if (dev->iobase)
+		release_region(dev->iobase, this_board->io_range);
 #ifdef unused
 	if (devpriv->dma_rtc)
 		RTC_lock--;
 #endif
-	return 0;
 }
 
 static const struct pcl816_board boardtypes[] = {

commit 294f930d98be86fb4f34302c718a49719650857f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 3 15:09:40 2012 -0700

    staging: comedi: use module_comedi_driver
    
    Convert the refactored comedi drivers to use the module_comedi_driver()
    macro which makes the code smaller and a bit simpler.
    
    In the process, rename the driver variables from driver_* to *_driver,
    as is more typical with other subsystems, and make sure they are all
    static.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index bccbb236d37d..1559c05b8f14 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -1317,7 +1317,7 @@ static const struct pcl816_board boardtypes[] = {
 	 100},
 };
 
-static struct comedi_driver driver_pcl816 = {
+static struct comedi_driver pcl816_driver = {
 	.driver_name	= "pcl816",
 	.module		= THIS_MODULE,
 	.attach		= pcl816_attach,
@@ -1326,18 +1326,7 @@ static struct comedi_driver driver_pcl816 = {
 	.num_names	= ARRAY_SIZE(boardtypes),
 	.offset		= sizeof(struct pcl816_board),
 };
-
-static int __init driver_pcl816_init_module(void)
-{
-	return comedi_driver_register(&driver_pcl816);
-}
-module_init(driver_pcl816_init_module);
-
-static void __exit driver_pcl816_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_pcl816);
-}
-module_exit(driver_pcl816_cleanup_module);
+module_comedi_driver(pcl816_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit 34023cd12b5cca3aafb08972defa9f4671c168ce
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Apr 27 16:13:37 2012 -0700

    staging: comedi: refactor pcl816 driver to remove forward declarations
    
    Move the module_init/module_exit routines and the associated
    struct comedi_driver and other variables to the end of the source.
    This is more typical of how other drivers are written and removes
    the need for the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index bf7b2621f877..bccbb236d37d 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -125,62 +125,14 @@ struct pcl816_board {
 	int i8254_osc_base;	/*  1/frequency of on board oscilator in ns */
 };
 
-static const struct pcl816_board boardtypes[] = {
-	{"pcl816", 8, 16, 10000, 1, 16, 16, &range_pcl816,
-	 &range_pcl816, PCLx1x_RANGE,
-	 0x00fc,		/*  IRQ mask */
-	 0x0a,			/*  DMA mask */
-	 0xffff,		/*  16-bit card */
-	 0xffff,		/*  D/A maxdata */
-	 1024,
-	 1,			/*  ao chan list */
-	 100},
-	{"pcl814b", 8, 16, 10000, 1, 16, 16, &range_pcl816,
-	 &range_pcl816, PCLx1x_RANGE,
-	 0x00fc,
-	 0x0a,
-	 0x3fff,		/* 14 bit card */
-	 0x3fff,
-	 1024,
-	 1,
-	 100},
-};
-
 #define devpriv ((struct pcl816_private *)dev->private)
 #define this_board ((const struct pcl816_board *)dev->board_ptr)
 
-static int pcl816_attach(struct comedi_device *dev,
-			 struct comedi_devconfig *it);
-static int pcl816_detach(struct comedi_device *dev);
-
 #ifdef unused
 static int RTC_lock;	/* RTC lock */
 static int RTC_timer_lock;	/* RTC int lock */
 #endif
 
-static struct comedi_driver driver_pcl816 = {
-	.driver_name = "pcl816",
-	.module = THIS_MODULE,
-	.attach = pcl816_attach,
-	.detach = pcl816_detach,
-	.board_name = &boardtypes[0].name,
-	.num_names = ARRAY_SIZE(boardtypes),
-	.offset = sizeof(struct pcl816_board),
-};
-
-static int __init driver_pcl816_init_module(void)
-{
-	return comedi_driver_register(&driver_pcl816);
-}
-
-static void __exit driver_pcl816_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_pcl816);
-}
-
-module_init(driver_pcl816_init_module);
-module_exit(driver_pcl816_cleanup_module);
-
 struct pcl816_private {
 
 	unsigned int dma;	/*  used DMA, 0=don't use DMA */
@@ -1108,12 +1060,6 @@ static void free_resources(struct comedi_device *dev)
 	/* printk("free_resource() end\n"); */
 }
 
-/*
-==============================================================================
-
-   Initialization
-
-*/
 static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	int ret;
@@ -1339,10 +1285,6 @@ case COMEDI_SUBD_DO:
 	return 0;
 }
 
-/*
-==============================================================================
-  Removes device
- */
 static int pcl816_detach(struct comedi_device *dev)
 {
 	DEBUG(printk(KERN_INFO "comedi%d: pcl816: remove\n", dev->minor);)
@@ -1354,6 +1296,49 @@ static int pcl816_detach(struct comedi_device *dev)
 	return 0;
 }
 
+static const struct pcl816_board boardtypes[] = {
+	{"pcl816", 8, 16, 10000, 1, 16, 16, &range_pcl816,
+	 &range_pcl816, PCLx1x_RANGE,
+	 0x00fc,		/*  IRQ mask */
+	 0x0a,			/*  DMA mask */
+	 0xffff,		/*  16-bit card */
+	 0xffff,		/*  D/A maxdata */
+	 1024,
+	 1,			/*  ao chan list */
+	 100},
+	{"pcl814b", 8, 16, 10000, 1, 16, 16, &range_pcl816,
+	 &range_pcl816, PCLx1x_RANGE,
+	 0x00fc,
+	 0x0a,
+	 0x3fff,		/* 14 bit card */
+	 0x3fff,
+	 1024,
+	 1,
+	 100},
+};
+
+static struct comedi_driver driver_pcl816 = {
+	.driver_name	= "pcl816",
+	.module		= THIS_MODULE,
+	.attach		= pcl816_attach,
+	.detach		= pcl816_detach,
+	.board_name	= &boardtypes[0].name,
+	.num_names	= ARRAY_SIZE(boardtypes),
+	.offset		= sizeof(struct pcl816_board),
+};
+
+static int __init driver_pcl816_init_module(void)
+{
+	return comedi_driver_register(&driver_pcl816);
+}
+module_init(driver_pcl816_init_module);
+
+static void __exit driver_pcl816_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver_pcl816);
+}
+module_exit(driver_pcl816_cleanup_module);
+
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");
 MODULE_LICENSE("GPL");

commit 542038f4df5a9d5d806a4af8725d2d21c4423a15
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Apr 20 12:05:04 2012 -0700

    staging: comedi: use ARRAY_SIZE instead of custom n_boardtypes macros
    
    The n_boardtypes macros are simply open-coded versions of the kernels
    ARRAY_SIZE macro. Use the kernel provided macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 96cd7ec2ad53..bf7b2621f877 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -146,7 +146,6 @@ static const struct pcl816_board boardtypes[] = {
 	 100},
 };
 
-#define n_boardtypes (sizeof(boardtypes)/sizeof(struct pcl816_board))
 #define devpriv ((struct pcl816_private *)dev->private)
 #define this_board ((const struct pcl816_board *)dev->board_ptr)
 
@@ -165,7 +164,7 @@ static struct comedi_driver driver_pcl816 = {
 	.attach = pcl816_attach,
 	.detach = pcl816_detach,
 	.board_name = &boardtypes[0].name,
-	.num_names = n_boardtypes,
+	.num_names = ARRAY_SIZE(boardtypes),
 	.offset = sizeof(struct pcl816_board),
 };
 

commit b147ed60775ff976f2a0724fa643f9b508bc8652
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Sat Nov 19 10:06:53 2011 +0530

    Staging: comedi: fix initialise statics to 0 or NULL issue in pcl816.c
    
    This is a patch to the pcl816.c file that fixes up a initialise statics to 0 or NULL
    warning found by the checkpatch.pl tool.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 0b9bee36eb5f..96cd7ec2ad53 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -155,8 +155,8 @@ static int pcl816_attach(struct comedi_device *dev,
 static int pcl816_detach(struct comedi_device *dev);
 
 #ifdef unused
-static int RTC_lock = 0;	/* RTC lock */
-static int RTC_timer_lock = 0;	/* RTC int lock */
+static int RTC_lock;	/* RTC lock */
+static int RTC_timer_lock;	/* RTC int lock */
 #endif
 
 static struct comedi_driver driver_pcl816 = {

commit 845d131e2b363717d8ac8db2c6b4417de8cf10b5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 9 12:20:28 2011 -0700

    Staging: comedi: add #include <linux/io.h> to a bunch of drivers
    
    On some arches the function virt_to_bus() wasn't being pulled in due to
    include chains being different.  So, as we are explicitly calling this
    function, explicitly include the proper header file so all will build
    properly.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 8f3fc6ee088b..0b9bee36eb5f 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -38,6 +38,7 @@ Configuration Options:
 #include <linux/mc146818rtc.h>
 #include <linux/gfp.h>
 #include <linux/delay.h>
+#include <linux/io.h>
 #include <asm/dma.h>
 
 #include "8253.h"

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index ef3cc4f3be6e..8f3fc6ee088b 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -954,7 +954,7 @@ check_channel_list(struct comedi_device *dev,
 	}
 
 	if (chanlen > 1) {
-		/*  first channel is everytime ok */
+		/*  first channel is every time ok */
 		chansegment[0] = chanlist[0];
 		for (i = 1, seglen = 1; i < chanlen; i++, seglen++) {
 			/*  build part of chanlist */
@@ -968,10 +968,10 @@ check_channel_list(struct comedi_device *dev,
 			nowmustbechan =
 			    (CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {
-				/*  channel list isn't continous :-( */
+				/*  channel list isn't continuous :-( */
 				printk(KERN_WARNING
 				       "comedi%d: pcl816: channel list must "
-				       "be continous! chanlist[%i]=%d but "
+				       "be continuous! chanlist[%i]=%d but "
 				       "must be %d or %d!\n", dev->minor,
 				       i, CR_CHAN(chanlist[i]), nowmustbechan,
 				       CR_CHAN(chanlist[0]));

commit 8c7f9ae856348d75fe79c179fa5c66e1f9717a20
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Thu Feb 24 22:13:46 2011 -0800

    staging: comedi: pcl816.c remove one to many l's in the word.
    
    The patch below removes an extra "l" in the word.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 3d0f018faa6b..ef3cc4f3be6e 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -108,7 +108,7 @@ struct pcl816_board {
 	const char *name;	/*  board name */
 	int n_ranges;		/*  len of range list */
 	int n_aichan;		/*  num of A/D chans in diferencial mode */
-	unsigned int ai_ns_min;	/*  minimal alllowed delay between samples (in ns) */
+	unsigned int ai_ns_min;	/*  minimal allowed delay between samples (in ns) */
 	int n_aochan;		/*  num of D/A chans */
 	int n_dichan;		/*  num of DI chans */
 	int n_dochan;		/*  num of DO chans */

commit 4c68fb42c2a39b89daca2b7175eb93ffe6860da4
Author: Gustavo Silva <silvagustavosilva@gmail.com>
Date:   Wed Jun 16 00:17:52 2010 -0500

    Staging: comedi: drivers: fix coding style issues in pcl816.c
    
    This is a patch to the pcl816.c file that fixes up the following
    issues:
    
    ERROR: code indent should use tabs where possible                  x  2
    WARNING: line over 80 characters                                   x 34
    WARNING: please, no space before tabs                              x  1
    WARNING: braces {} are not necessary for single statement blocks   x  6
    WARNING: printk() should include KERN_ facility level              x 15
    WARNING: braces {} are not necessary for any arm of this statement x  1
    
    Signed-off-by: Gustavo Silva <silvagustavo@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index a84b942c5a93..3d0f018faa6b 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -2,7 +2,7 @@
    comedi/drivers/pcl816.c
 
    Author:  Juan Grigera <juan@grigera.com.ar>
-            based on pcl818 by Michal Dobes <dobes@tesnet.cz> and bits of pcl812
+	    based on pcl818 by Michal Dobes <dobes@tesnet.cz> and bits of pcl812
 
    hardware driver for Advantech cards:
     card:   PCL-816, PCL814B
@@ -28,7 +28,7 @@ Configuration Options:
   [1] - IRQ	(0=disable, 2, 3, 4, 5, 6, 7)
   [2] - DMA	(0=disable, 1, 3)
   [3] - 0, 10=10MHz clock for 8254
-            1= 1MHz clock for 8254
+	    1= 1MHz clock for 8254
 
 */
 
@@ -85,7 +85,7 @@ Configuration Options:
 #define INT_TYPE_AI3_DMA_RTC 10
 
 /* RTC stuff... */
-#define RTC_IRQ 	8
+#define RTC_IRQ		8
 #define RTC_IO_EXTENT	0x10
 #endif
 
@@ -264,7 +264,8 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 
 	/*  Set the input channel */
 	outb(CR_CHAN(insn->chanspec) & 0xf, dev->iobase + PCL816_MUX);
-	outb(CR_RANGE(insn->chanspec), dev->iobase + PCL816_RANGE);	/* select gain */
+	/* select gain */
+	outb(CR_RANGE(insn->chanspec), dev->iobase + PCL816_RANGE);
 
 	for (n = 0; n < insn->n; n++) {
 
@@ -279,8 +280,8 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 				    ((inb(dev->iobase +
 					  PCL816_AD_HI) << 8) |
 				     (inb(dev->iobase + PCL816_AD_LO)));
-
-				outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT (conversion end) flag */
+				/* clear INT (conversion end) flag */
+				outb(0, dev->iobase + PCL816_CLRINT);
 				break;
 			}
 			udelay(1);
@@ -289,7 +290,8 @@ static int pcl816_ai_insn_read(struct comedi_device *dev,
 		if (!timeout) {
 			comedi_error(dev, "A/D insn timeout\n");
 			data[0] = 0;
-			outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT (conversion end) flag */
+			/* clear INT (conversion end) flag */
+			outb(0, dev->iobase + PCL816_CLRINT);
 			return -EIO;
 		}
 
@@ -343,7 +345,8 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 	}
 
 	if (!devpriv->ai_neverending)
-		if (devpriv->ai_act_scan >= devpriv->ai_scans) {	/* all data sampled */
+					/* all data sampled */
+		if (devpriv->ai_act_scan >= devpriv->ai_scans) {
 			/* all data sampled */
 			pcl816_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA;
@@ -380,7 +383,8 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 		}
 
 		if (!devpriv->ai_neverending)
-			if (devpriv->ai_act_scan >= devpriv->ai_scans) {	/*  all data sampled */
+						/*  all data sampled */
+			if (devpriv->ai_act_scan >= devpriv->ai_scans) {
 				pcl816_ai_cancel(dev, s);
 				s->async->events |= COMEDI_CB_EOA;
 				s->async->events |= COMEDI_CB_BLOCK;
@@ -402,7 +406,8 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 	disable_dma(devpriv->dma);
 	this_dma_buf = devpriv->next_dma_buf;
 
-	if ((devpriv->dma_runs_to_end > -1) || devpriv->ai_neverending) {	/*  switch dma bufs */
+	/*  switch dma bufs */
+	if ((devpriv->dma_runs_to_end > -1) || devpriv->ai_neverending) {
 
 		devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
 		set_dma_mode(devpriv->dma, DMA_MODE_READ);
@@ -478,14 +483,14 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 */
 static void pcl816_cmdtest_out(int e, struct comedi_cmd *cmd)
 {
-	printk("pcl816 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
+	printk(KERN_INFO "pcl816 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
 	       cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
-	printk("pcl816 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
+	printk(KERN_INFO "pcl816 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
 	       cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
-	printk("pcl816 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
-	       cmd->scan_end_src);
-	printk("pcl816 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n", e,
-	       cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
+	printk(KERN_INFO "pcl816 e=%d stopsrc=%x scanend=%x\n", e,
+	       cmd->stop_src, cmd->scan_end_src);
+	printk(KERN_INFO "pcl816 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n",
+	       e, cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
 }
 
 /*
@@ -497,8 +502,9 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	int err = 0;
 	int tmp, divisor1 = 0, divisor2 = 0;
 
-	DEBUG(printk("pcl816 pcl812_ai_cmdtest\n"); pcl816_cmdtest_out(-1, cmd);
-	    );
+	DEBUG(printk(KERN_INFO "pcl816 pcl812_ai_cmdtest\n");
+	      pcl816_cmdtest_out(-1, cmd);
+	     );
 
 	/* step 1: make sure trigger sources are trivially valid */
 	tmp = cmd->start_src;
@@ -526,11 +532,14 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	if (!cmd->stop_src || tmp != cmd->stop_src)
 		err++;
 
-	if (err) {
+	if (err)
 		return 1;
-	}
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	/*
+	 * step 2: make sure trigger sources
+	 * are unique and mutually compatible
+	 */
 
 	if (cmd->start_src != TRIG_NOW) {
 		cmd->start_src = TRIG_NOW;
@@ -555,9 +564,9 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
 		err++;
 
-	if (err) {
+	if (err)
 		return 2;
-	}
+
 
 	/* step 3: make sure arguments are trivially compatible */
 	if (cmd->start_arg != 0) {
@@ -597,9 +606,9 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 		}
 	}
 
-	if (err) {
+	if (err)
 		return 3;
-	}
+
 
 	/* step 4: fix up any arguments */
 	if (cmd->convert_src == TRIG_TIMER) {
@@ -614,9 +623,9 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 			err++;
 	}
 
-	if (err) {
+	if (err)
 		return 4;
-	}
+
 
 	/* step 5: complain about special chanlist considerations */
 
@@ -654,7 +663,9 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		i8253_cascade_ns_to_timer(this_board->i8254_osc_base, &divisor1,
 					  &divisor2, &cmd->convert_arg,
 					  cmd->flags & TRIG_ROUND_MASK);
-		if (divisor1 == 1) {	/*  PCL816 crash if any divisor is set to 1 */
+
+		/*  PCL816 crash if any divisor is set to 1 */
+		if (divisor1 == 1) {
 			divisor1 = 2;
 			divisor2 /= 2;
 		}
@@ -687,8 +698,10 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_neverending = 1;
 	}
 
-	if ((cmd->flags & TRIG_WAKE_EOS)) {	/*  don't we want wake up every scan? */
-		printk("pl816: You wankt WAKE_EOS but I dont want handle it");
+	/*  don't we want wake up every scan? */
+	if ((cmd->flags & TRIG_WAKE_EOS)) {
+		printk(KERN_INFO
+		       "pl816: You wankt WAKE_EOS but I dont want handle it");
 		/*               devpriv->ai_eos=1; */
 		/* if (devpriv->ai_n_chan==1) */
 		/*       devpriv->dma=0; // DMA is useless for this situation */
@@ -697,9 +710,17 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->dma) {
 		bytes = devpriv->hwdmasize[0];
 		if (!devpriv->ai_neverending) {
-			bytes = s->async->cmd.chanlist_len * s->async->cmd.chanlist_len * sizeof(short);	/*  how many */
-			devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize[0];	/*  how many DMA pages we must fill */
-			devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];	/* on last dma transfer must be moved */
+			/*  how many */
+			bytes = s->async->cmd.chanlist_len *
+			s->async->cmd.chanlist_len *
+			sizeof(short);
+
+			/*  how many DMA pages we must fill */
+			devpriv->dma_runs_to_end = bytes /
+			devpriv->hwdmasize[0];
+
+			/* on last dma transfer must be moved */
+			devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];
 			devpriv->dma_runs_to_end--;
 			if (devpriv->dma_runs_to_end >= 0)
 				bytes = devpriv->hwdmasize[0];
@@ -722,14 +743,22 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	switch (cmd->convert_src) {
 	case TRIG_TIMER:
 		devpriv->int816_mode = INT_TYPE_AI1_DMA;
-		outb(0x32, dev->iobase + PCL816_CONTROL);	/*  Pacer+IRQ+DMA */
-		outb(dmairq, dev->iobase + PCL816_STATUS);	/*  write irq and DMA to card */
+
+		/*  Pacer+IRQ+DMA */
+		outb(0x32, dev->iobase + PCL816_CONTROL);
+
+		/*  write irq and DMA to card */
+		outb(dmairq, dev->iobase + PCL816_STATUS);
 		break;
 
 	default:
 		devpriv->int816_mode = INT_TYPE_AI3_DMA;
-		outb(0x34, dev->iobase + PCL816_CONTROL);	/*  Ext trig+IRQ+DMA */
-		outb(dmairq, dev->iobase + PCL816_STATUS);	/*  write irq to card */
+
+		/*  Ext trig+IRQ+DMA */
+		outb(0x34, dev->iobase + PCL816_CONTROL);
+
+		/*  write irq to card */
+		outb(dmairq, dev->iobase + PCL816_STATUS);
 		break;
 	}
 
@@ -758,7 +787,8 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 		return 0;
 	}
 
-	top1 = devpriv->hwdmasize[0] - top1;	/*  where is now DMA in buffer */
+	/*  where is now DMA in buffer */
+	top1 = devpriv->hwdmasize[0] - top1;
 	top1 >>= 1;		/*  sample position */
 	top2 = top1 - devpriv->ai_poll_ptr;
 	if (top2 < 1) {		/*  no new samples */
@@ -798,16 +828,23 @@ static int pcl816_ai_cancel(struct comedi_device *dev,
 			disable_dma(devpriv->dma);
 		case INT_TYPE_AI1_INT:
 		case INT_TYPE_AI3_INT:
-			outb(inb(dev->iobase + PCL816_CONTROL) & 0x73, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
+			outb(inb(dev->iobase + PCL816_CONTROL) & 0x73,
+			     dev->iobase + PCL816_CONTROL);	/* Stop A/D */
 			udelay(1);
 			outb(0, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
-			outb(0xb0, dev->iobase + PCL816_CTRCTL);	/* Stop pacer */
+
+			/* Stop pacer */
+			outb(0xb0, dev->iobase + PCL816_CTRCTL);
 			outb(0x70, dev->iobase + PCL816_CTRCTL);
 			outb(0, dev->iobase + PCL816_AD_LO);
 			inb(dev->iobase + PCL816_AD_LO);
 			inb(dev->iobase + PCL816_AD_HI);
-			outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
-			outb(0, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
+
+			/* clear INT request */
+			outb(0, dev->iobase + PCL816_CLRINT);
+
+			/* Stop A/D */
+			outb(0, dev->iobase + PCL816_CONTROL);
 			devpriv->irq_blocked = 0;
 			devpriv->irq_was_now_closed = devpriv->int816_mode;
 			devpriv->int816_mode = 0;
@@ -877,8 +914,11 @@ start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
 	outb(0xff, dev->iobase + PCL816_CTR0);
 	outb(0x00, dev->iobase + PCL816_CTR0);
 	udelay(1);
-	outb(0xb4, dev->iobase + PCL816_CTRCTL);	/*  set counter 2 as mode 3 */
-	outb(0x74, dev->iobase + PCL816_CTRCTL);	/*  set counter 1 as mode 3 */
+
+	/*  set counter 2 as mode 3 */
+	outb(0xb4, dev->iobase + PCL816_CTRCTL);
+	/*  set counter 1 as mode 3 */
+	outb(0x74, dev->iobase + PCL816_CTRCTL);
 	udelay(1);
 
 	if (mode == 1) {
@@ -914,41 +954,51 @@ check_channel_list(struct comedi_device *dev,
 	}
 
 	if (chanlen > 1) {
-		chansegment[0] = chanlist[0];	/*  first channel is everytime ok */
+		/*  first channel is everytime ok */
+		chansegment[0] = chanlist[0];
 		for (i = 1, seglen = 1; i < chanlen; i++, seglen++) {
 			/*  build part of chanlist */
-			DEBUG(printk("%d. %d %d\n", i, CR_CHAN(chanlist[i]),
+			DEBUG(printk(KERN_INFO "%d. %d %d\n", i,
+				     CR_CHAN(chanlist[i]),
 				     CR_RANGE(chanlist[i]));)
+
+			/*  we detect loop, this must by finish */
 			    if (chanlist[0] == chanlist[i])
-				break;	/*  we detect loop, this must by finish */
+				break;
 			nowmustbechan =
 			    (CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {
 				/*  channel list isn't continous :-( */
-				printk
-				    ("comedi%d: pcl816: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
-				     dev->minor, i, CR_CHAN(chanlist[i]),
-				     nowmustbechan, CR_CHAN(chanlist[0]));
+				printk(KERN_WARNING
+				       "comedi%d: pcl816: channel list must "
+				       "be continous! chanlist[%i]=%d but "
+				       "must be %d or %d!\n", dev->minor,
+				       i, CR_CHAN(chanlist[i]), nowmustbechan,
+				       CR_CHAN(chanlist[0]));
 				return 0;
 			}
-			chansegment[i] = chanlist[i];	/*  well, this is next correct channel in list */
+			/*  well, this is next correct channel in list */
+			chansegment[i] = chanlist[i];
 		}
 
-		for (i = 0, segpos = 0; i < chanlen; i++) {	/*  check whole chanlist */
+		/*  check whole chanlist */
+		for (i = 0, segpos = 0; i < chanlen; i++) {
 			DEBUG(printk("%d %d=%d %d\n",
 				     CR_CHAN(chansegment[i % seglen]),
 				     CR_RANGE(chansegment[i % seglen]),
 				     CR_CHAN(chanlist[i]),
 				     CR_RANGE(chanlist[i]));)
 			    if (chanlist[i] != chansegment[i % seglen]) {
-				printk
-				    ("comedi%d: pcl816: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
-				     dev->minor, i, CR_CHAN(chansegment[i]),
-				     CR_RANGE(chansegment[i]),
-				     CR_AREF(chansegment[i]),
-				     CR_CHAN(chanlist[i % seglen]),
-				     CR_RANGE(chanlist[i % seglen]),
-				     CR_AREF(chansegment[i % seglen]));
+				printk(KERN_WARNING
+				       "comedi%d: pcl816: bad channel or range"
+				       " number! chanlist[%i]=%d,%d,%d and not"
+				       " %d,%d,%d!\n", dev->minor, i,
+				       CR_CHAN(chansegment[i]),
+				       CR_RANGE(chansegment[i]),
+				       CR_AREF(chansegment[i]),
+				       CR_CHAN(chanlist[i % seglen]),
+				       CR_RANGE(chanlist[i % seglen]),
+				       CR_AREF(chansegment[i % seglen]));
 				return 0;	/*  chan/gain list is strange */
 			}
 		}
@@ -976,12 +1026,15 @@ setup_channel_list(struct comedi_device *dev,
 	for (i = 0; i < seglen; i++) {	/*  store range list to card */
 		devpriv->ai_act_chanlist[i] = CR_CHAN(chanlist[i]);
 		outb(CR_CHAN(chanlist[0]) & 0xf, dev->iobase + PCL816_MUX);
-		outb(CR_RANGE(chanlist[0]), dev->iobase + PCL816_RANGE);	/* select gain */
+		/* select gain */
+		outb(CR_RANGE(chanlist[0]), dev->iobase + PCL816_RANGE);
 	}
 
 	udelay(1);
-
-	outb(devpriv->ai_act_chanlist[0] | (devpriv->ai_act_chanlist[seglen - 1] << 4), dev->iobase + PCL816_MUX);	/* select channel interval to scan */
+	/* select channel interval to scan */
+	outb(devpriv->ai_act_chanlist[0] |
+	     (devpriv->ai_act_chanlist[seglen - 1] << 4),
+	     dev->iobase + PCL816_MUX);
 }
 
 #ifdef unused
@@ -1009,11 +1062,11 @@ static int set_rtc_irq_bit(unsigned char bit)
 	save_flags(flags);
 	cli();
 	val = CMOS_READ(RTC_CONTROL);
-	if (bit) {
+	if (bit)
 		val |= RTC_PIE;
-	} else {
+	else
 		val &= ~RTC_PIE;
-	}
+
 	CMOS_WRITE(val, RTC_CONTROL);
 	CMOS_READ(RTC_INTR_FLAGS);
 	restore_flags(flags);
@@ -1083,7 +1136,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->iobase = iobase;
 
 	if (pcl816_check(iobase)) {
-		printk(", I cann't detect board. FAIL!\n");
+		printk(KERN_ERR ", I cann't detect board. FAIL!\n");
 		return -EIO;
 	}
 
@@ -1101,30 +1154,29 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & this_board->IRQbits) == 0) {
 				printk
-				    (", IRQ %u is out of allowed range, DISABLING IT",
-				     irq);
+				    (", IRQ %u is out of allowed range, "
+				     "DISABLING IT", irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
 				if (request_irq
 				    (irq, interrupt_pcl816, 0, "pcl816", dev)) {
 					printk
-					    (", unable to allocate IRQ %u, DISABLING IT",
-					     irq);
+					    (", unable to allocate IRQ %u, "
+					     "DISABLING IT", irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
-					printk(", irq=%u", irq);
+					printk(KERN_INFO ", irq=%u", irq);
 				}
 			}
 		}
 	}
 
 	dev->irq = irq;
-	if (irq) {
+	if (irq)	/* 1=we have allocated irq */
 		devpriv->irq_free = 1;
-	} /* 1=we have allocated irq */
-	else {
+	else
 		devpriv->irq_free = 0;
-	}
+
 	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
 	devpriv->int816_mode = 0;	/* mode of irq */
 
@@ -1181,18 +1233,22 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 		ret = request_dma(dma, "pcl816");
 		if (ret) {
-			printk(", unable to allocate DMA %u, FAIL!\n", dma);
+			printk(KERN_ERR
+			       ", unable to allocate DMA %u, FAIL!\n", dma);
 			return -EBUSY;	/* DMA isn't free */
 		}
 
 		devpriv->dma = dma;
-		printk(", dma=%u", dma);
+		printk(KERN_INFO ", dma=%u", dma);
 		pages = 2;	/* we need 16KB */
 		devpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);
 
 		if (!devpriv->dmabuf[0]) {
 			printk(", unable to allocate DMA buffer, FAIL!\n");
-			/* maybe experiment with try_to_free_pages() will help .... */
+			/*
+			 * maybe experiment with try_to_free_pages()
+			 * will help ....
+			 */
 			return -EBUSY;	/* no buffer :-( */
 		}
 		devpriv->dmapages[0] = pages;
@@ -1203,8 +1259,9 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (devpriv->dma_rtc == 0) {	/*  we must do duble buff :-( */
 			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 			if (!devpriv->dmabuf[1]) {
-				printk
-				    (", unable to allocate DMA buffer, FAIL!\n");
+				printk(KERN_ERR
+				       ", unable to allocate DMA buffer, "
+				       "FAIL!\n");
 				return -EBUSY;
 			}
 			devpriv->dmapages[1] = pages;
@@ -1288,7 +1345,7 @@ case COMEDI_SUBD_DO:
  */
 static int pcl816_detach(struct comedi_device *dev)
 {
-	DEBUG(printk("comedi%d: pcl816: remove\n", dev->minor);)
+	DEBUG(printk(KERN_INFO "comedi%d: pcl816: remove\n", dev->minor);)
 	    free_resources(dev);
 #ifdef unused
 	if (devpriv->dma_rtc)

commit 7114a28011f9d5f3d981731ad341177c21f9d948
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:30 2010 +0200

    Staging: comedi: Remove COMEDI_INITCLEANUP macro
    
    Move the init/exit routines to the respective C source files
    instead of calling COMEDI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index c26dfad2c897..a84b942c5a93 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -168,7 +168,18 @@ static struct comedi_driver driver_pcl816 = {
 	.offset = sizeof(struct pcl816_board),
 };
 
-COMEDI_INITCLEANUP(driver_pcl816);
+static int __init driver_pcl816_init_module(void)
+{
+	return comedi_driver_register(&driver_pcl816);
+}
+
+static void __exit driver_pcl816_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver_pcl816);
+}
+
+module_init(driver_pcl816_init_module);
+module_exit(driver_pcl816_cleanup_module);
 
 struct pcl816_private {
 

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 71c2a3aa379e..c26dfad2c897 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -1285,3 +1285,7 @@ static int pcl816_detach(struct comedi_device *dev)
 #endif
 	return 0;
 }
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 9820759ec54f..71c2a3aa379e 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -36,6 +36,7 @@ Configuration Options:
 
 #include <linux/ioport.h>
 #include <linux/mc146818rtc.h>
+#include <linux/gfp.h>
 #include <linux/delay.h>
 #include <asm/dma.h>
 

commit 64a1f7bd56e0f26bd4dd621805facffde9fbb0a3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jan 20 13:04:50 2010 +0000

    Staging: comedi: pcl816: Check channel list in AI command test
    
    Check the channel list is valid in step 5 of the AI command test.
    Split function check_and_setup_channel_list() in two.  Also, remove
    unnecessary chanlist_len tests in step 3 of the AI command test as the
    comedi core has already checked it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 5c88ddc1fc05..9820759ec54f 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -214,9 +214,12 @@ struct pcl816_private {
 /*
 ==============================================================================
 */
-static int check_and_setup_channel_list(struct comedi_device *dev,
-					struct comedi_subdevice *s,
-					unsigned int *chanlist, int chanlen);
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      unsigned int *chanlist, unsigned int chanlen);
+static void setup_channel_list(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned int *chanlist, unsigned int seglen);
 static int pcl816_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s);
 static void start_pacer(struct comedi_device *dev, int mode,
@@ -566,14 +569,6 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 		}
 	}
 
-	if (!cmd->chanlist_len) {
-		cmd->chanlist_len = 1;
-		err++;
-	}
-	if (cmd->chanlist_len > this_board->n_aichan) {
-		cmd->chanlist_len = this_board->n_aichan;
-		err++;
-	}
 	if (cmd->scan_end_arg != cmd->chanlist_len) {
 		cmd->scan_end_arg = cmd->chanlist_len;
 		err++;
@@ -611,6 +606,14 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 		return 4;
 	}
 
+	/* step 5: complain about special chanlist considerations */
+
+	if (cmd->chanlist) {
+		if (!check_channel_list(dev, s, cmd->chanlist,
+					cmd->chanlist_len))
+			return 5;	/*  incorrect channels list */
+	}
+
 	return 0;
 }
 
@@ -618,6 +621,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned int divisor1 = 0, divisor2 = 0, dma_flags, bytes, dmairq;
 	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int seglen;
 
 	if (cmd->start_src != TRIG_NOW)
 		return -EINVAL;
@@ -650,9 +654,10 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
-	if (!check_and_setup_channel_list(dev, s, cmd->chanlist,
-					  cmd->chanlist_len))
+	seglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);
+	if (seglen < 1)
 		return -EINVAL;
+	setup_channel_list(dev, s, cmd->chanlist, seglen);
 	udelay(1);
 
 	devpriv->ai_n_chan = cmd->chanlist_len;
@@ -880,12 +885,12 @@ start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
 /*
 ==============================================================================
  Check if channel list from user is builded correctly
- If it's ok, then program scan/gain logic
+ If it's ok, then return non-zero length of repeated segment of channel list
 */
 static int
-check_and_setup_channel_list(struct comedi_device *dev,
-			     struct comedi_subdevice *s, unsigned int *chanlist,
-			     int chanlen)
+check_channel_list(struct comedi_device *dev,
+		   struct comedi_subdevice *s, unsigned int *chanlist,
+		   unsigned int chanlen)
 {
 	unsigned int chansegment[16];
 	unsigned int i, nowmustbechan, seglen, segpos;
@@ -939,6 +944,20 @@ check_and_setup_channel_list(struct comedi_device *dev,
 		seglen = 1;
 	}
 
+	return seglen;	/*  we can serve this with MUX logic */
+}
+
+/*
+==============================================================================
+ Program scan/gain logic with channel list.
+*/
+static void
+setup_channel_list(struct comedi_device *dev,
+		   struct comedi_subdevice *s, unsigned int *chanlist,
+		   unsigned int seglen)
+{
+	unsigned int i;
+
 	devpriv->ai_act_chanlist_len = seglen;
 	devpriv->ai_act_chanlist_pos = 0;
 
@@ -951,8 +970,6 @@ check_and_setup_channel_list(struct comedi_device *dev,
 	udelay(1);
 
 	outb(devpriv->ai_act_chanlist[0] | (devpriv->ai_act_chanlist[seglen - 1] << 4), dev->iobase + PCL816_MUX);	/* select channel interval to scan */
-
-	return 1;		/*  we can serve this with MUX logic */
 }
 
 #ifdef unused

commit 13de4f000ec491b16a820e4ed59de2c98b7807be
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jan 20 13:04:45 2010 +0000

    Staging: comedi: pcl816: Correct AI scan counting
    
    For AI commands, the scan counter should be updated after every
    scan.  In DMA mode, it was being updated after every repeated
    segment of the channel list.  In non-DMA mode, it was being updated
    after every sample.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 852fe2458fdc..5c88ddc1fc05 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -202,6 +202,7 @@ struct pcl816_private {
 	unsigned int ai_act_chanlist[16];	/*  MUX setting for actual AI operations */
 	unsigned int ai_act_chanlist_len;	/*  how long is actual MUX list */
 	unsigned int ai_act_chanlist_pos;	/*  actual position in MUX list */
+	unsigned int ai_n_chan;		/*  how many channels per scan */
 	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
 	struct comedi_subdevice *sub_ai;	/*  ptr to AI subdevice */
 #ifdef unused
@@ -320,7 +321,9 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 	if (++devpriv->ai_act_chanlist_pos >= devpriv->ai_act_chanlist_len)
 		devpriv->ai_act_chanlist_pos = 0;
 
-	if (s->async->cur_chan == 0) {
+	s->async->cur_chan++;
+	if (s->async->cur_chan >= devpriv->ai_n_chan) {
+		s->async->cur_chan = 0;
 		devpriv->ai_act_scan++;
 	}
 
@@ -353,6 +356,11 @@ static void transfer_from_dma_buf(struct comedi_device *dev,
 		if (++devpriv->ai_act_chanlist_pos >=
 		    devpriv->ai_act_chanlist_len) {
 			devpriv->ai_act_chanlist_pos = 0;
+		}
+
+		s->async->cur_chan++;
+		if (s->async->cur_chan >= devpriv->ai_n_chan) {
+			s->async->cur_chan = 0;
 			devpriv->ai_act_scan++;
 		}
 
@@ -647,6 +655,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EINVAL;
 	udelay(1);
 
+	devpriv->ai_n_chan = cmd->chanlist_len;
 	devpriv->ai_act_scan = 0;
 	s->async->cur_chan = 0;
 	devpriv->irq_blocked = 1;

commit bbc9a9916bc1cd997f3bf303e7930d5f3c804d37
Author: André Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:06 2009 -0200

    Staging: fix assorted typos all over the place
    
    Signed-off-by: André Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 1b1708a58b67..852fe2458fdc 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -112,7 +112,7 @@ struct pcl816_board {
 	int n_dichan;		/*  num of DI chans */
 	int n_dochan;		/*  num of DO chans */
 	const struct comedi_lrange *ai_range_type;	/*  default A/D rangelist */
-	const struct comedi_lrange *ao_range_type;	/*  dafault D/A rangelist */
+	const struct comedi_lrange *ao_range_type;	/*  default D/A rangelist */
 	unsigned int io_range;	/*  len of IO space */
 	unsigned int IRQbits;	/*  allowed interrupts */
 	unsigned int DMAbits;	/*  allowed DMA chans */
@@ -445,7 +445,7 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 		comedi_error(dev, "bad IRQ!");
 		return IRQ_NONE;
 	}
-	comedi_error(dev, "IRQ from unknow source!");
+	comedi_error(dev, "IRQ from unknown source!");
 	return IRQ_NONE;
 }
 

commit efdf83c1763156220a74c8f2755c1a6fa1e1c26b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 20 11:32:38 2009 +0000

    Staging: comedi: pcl816: update convert_src mask for AI cmdtest
    
    The COMEDI_CMDTEST ioctl needs to clear unsupported bits in the
    struct comedi_cmd's convert_src and other *_src members.  This
    needs fixing in the pcl816 driver's AI cmdtest.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index f9a0dac79eca..1b1708a58b67 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -488,7 +488,9 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
 		err++;
 
-	if (!(cmd->convert_src & (TRIG_EXT | TRIG_TIMER)))
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_EXT | TRIG_TIMER;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
 		err++;
 
 	tmp = cmd->scan_end_src;

commit 48b1aff5b93521c5ad90842bef52b218ac50a4ab
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 20 11:32:37 2009 +0000

    Staging: comedi: initialize divisor variables
    
    The i8253_cascade_ns_to_timer_2div() function (and
    i8253_cascade_ns_to_timer macro) checks the old values *d1 and *d2
    for correctness as a heuristic before calculating new values.  Don't
    call the function with uninitialized values in *d1 and *d2.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index fa2414500a07..f9a0dac79eca 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -472,7 +472,7 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int tmp, divisor1, divisor2;
+	int tmp, divisor1 = 0, divisor2 = 0;
 
 	DEBUG(printk("pcl816 pcl812_ai_cmdtest\n"); pcl816_cmdtest_out(-1, cmd);
 	    );

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 19465c1b53c3..fa2414500a07 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -91,16 +91,17 @@ Configuration Options:
 #define MAGIC_DMA_WORD 0x5a5a
 
 static const struct comedi_lrange range_pcl816 = { 8, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-	}
+						       BIP_RANGE(10),
+						       BIP_RANGE(5),
+						       BIP_RANGE(2.5),
+						       BIP_RANGE(1.25),
+						       UNI_RANGE(10),
+						       UNI_RANGE(5),
+						       UNI_RANGE(2.5),
+						       UNI_RANGE(1.25),
+						       }
 };
+
 struct pcl816_board {
 
 	const char *name;	/*  board name */
@@ -122,33 +123,33 @@ struct pcl816_board {
 	int i8254_osc_base;	/*  1/frequency of on board oscilator in ns */
 };
 
-
 static const struct pcl816_board boardtypes[] = {
 	{"pcl816", 8, 16, 10000, 1, 16, 16, &range_pcl816,
-			&range_pcl816, PCLx1x_RANGE,
-			0x00fc,	/*  IRQ mask */
-			0x0a,	/*  DMA mask */
-			0xffff,	/*  16-bit card */
-			0xffff,	/*  D/A maxdata */
-			1024,
-			1,	/*  ao chan list */
-		100},
+	 &range_pcl816, PCLx1x_RANGE,
+	 0x00fc,		/*  IRQ mask */
+	 0x0a,			/*  DMA mask */
+	 0xffff,		/*  16-bit card */
+	 0xffff,		/*  D/A maxdata */
+	 1024,
+	 1,			/*  ao chan list */
+	 100},
 	{"pcl814b", 8, 16, 10000, 1, 16, 16, &range_pcl816,
-			&range_pcl816, PCLx1x_RANGE,
-			0x00fc,
-			0x0a,
-			0x3fff,	/* 14 bit card */
-			0x3fff,
-			1024,
-			1,
-		100},
+	 &range_pcl816, PCLx1x_RANGE,
+	 0x00fc,
+	 0x0a,
+	 0x3fff,		/* 14 bit card */
+	 0x3fff,
+	 1024,
+	 1,
+	 100},
 };
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct pcl816_board))
 #define devpriv ((struct pcl816_private *)dev->private)
 #define this_board ((const struct pcl816_board *)dev->board_ptr)
 
-static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcl816_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcl816_detach(struct comedi_device *dev);
 
 #ifdef unused
@@ -209,29 +210,32 @@ struct pcl816_private {
 #endif
 };
 
-
 /*
 ==============================================================================
 */
 static int check_and_setup_channel_list(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int *chanlist, int chanlen);
-static int pcl816_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2);
+					struct comedi_subdevice *s,
+					unsigned int *chanlist, int chanlen);
+static int pcl816_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2);
 #ifdef unused
 static int set_rtc_irq_bit(unsigned char bit);
 #endif
 
-static int pcl816_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int pcl816_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd);
 static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 
 /*
 ==============================================================================
    ANALOG INPUT MODE0, 816 cards, slow version
 */
-static int pcl816_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl816_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int timeout;
@@ -253,12 +257,12 @@ static int pcl816_ai_insn_read(struct comedi_device *dev, struct comedi_subdevic
 		timeout = 100;
 		while (timeout--) {
 			if (!(inb(dev->iobase + PCL816_STATUS) &
-					PCL816_STATUS_DRDY_MASK)) {
+			      PCL816_STATUS_DRDY_MASK)) {
 				/*  return read value */
 				data[n] =
-					((inb(dev->iobase +
-							PCL816_AD_HI) << 8) |
-					(inb(dev->iobase + PCL816_AD_LO)));
+				    ((inb(dev->iobase +
+					  PCL816_AD_HI) << 8) |
+				     (inb(dev->iobase + PCL816_AD_LO)));
 
 				outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT (conversion end) flag */
 				break;
@@ -291,7 +295,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 
 	while (timeout--) {
 		if (!(inb(dev->iobase + PCL816_STATUS) &
-				PCL816_STATUS_DRDY_MASK))
+		      PCL816_STATUS_DRDY_MASK))
 			break;
 		udelay(1);
 	}
@@ -334,8 +338,9 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 ==============================================================================
    analog input dma mode 1 & 3, 816 cards
 */
-static void transfer_from_dma_buf(struct comedi_device *dev, struct comedi_subdevice *s,
-	short *ptr, unsigned int bufptr, unsigned int len)
+static void transfer_from_dma_buf(struct comedi_device *dev,
+				  struct comedi_subdevice *s, short *ptr,
+				  unsigned int bufptr, unsigned int len)
 {
 	int i;
 
@@ -346,7 +351,7 @@ static void transfer_from_dma_buf(struct comedi_device *dev, struct comedi_subde
 		comedi_buf_put(s->async, ptr[bufptr++]);
 
 		if (++devpriv->ai_act_chanlist_pos >=
-			devpriv->ai_act_chanlist_len) {
+		    devpriv->ai_act_chanlist_len) {
 			devpriv->ai_act_chanlist_pos = 0;
 			devpriv->ai_act_scan++;
 		}
@@ -381,10 +386,11 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 		dma_flags = claim_dma_lock();
 /* clear_dma_ff (devpriv->dma); */
 		set_dma_addr(devpriv->dma,
-			devpriv->hwdmaptr[devpriv->next_dma_buf]);
+			     devpriv->hwdmaptr[devpriv->next_dma_buf]);
 		if (devpriv->dma_runs_to_end) {
 			set_dma_count(devpriv->dma,
-				devpriv->hwdmasize[devpriv->next_dma_buf]);
+				      devpriv->hwdmasize[devpriv->
+							 next_dma_buf]);
 		} else {
 			set_dma_count(devpriv->dma, devpriv->last_dma_run);
 		}
@@ -395,7 +401,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 	devpriv->dma_runs_to_end--;
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
 
-	ptr = (short *) devpriv->dmabuf[this_dma_buf];
+	ptr = (short *)devpriv->dmabuf[this_dma_buf];
 
 	len = (devpriv->hwdmasize[0] >> 1) - devpriv->ai_poll_ptr;
 	bufptr = devpriv->ai_poll_ptr;
@@ -430,7 +436,7 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
 	if ((!dev->irq) | (!devpriv->irq_free) | (!devpriv->irq_blocked) |
-		(!devpriv->int816_mode)) {
+	    (!devpriv->int816_mode)) {
 		if (devpriv->irq_was_now_closed) {
 			devpriv->irq_was_now_closed = 0;
 			/*  comedi_error(dev,"last IRQ.."); */
@@ -450,26 +456,26 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 static void pcl816_cmdtest_out(int e, struct comedi_cmd *cmd)
 {
 	printk("pcl816 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
-		cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
+	       cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
 	printk("pcl816 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
-		cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
+	       cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
 	printk("pcl816 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
-		cmd->scan_end_src);
+	       cmd->scan_end_src);
 	printk("pcl816 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n", e,
-		cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
+	       cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
 }
 
 /*
 ==============================================================================
 */
-static int pcl816_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int pcl816_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
 
-	DEBUG(printk("pcl816 pcl812_ai_cmdtest\n");
-		pcl816_cmdtest_out(-1, cmd););
+	DEBUG(printk("pcl816 pcl812_ai_cmdtest\n"); pcl816_cmdtest_out(-1, cmd);
+	    );
 
 	/* step 1: make sure trigger sources are trivially valid */
 	tmp = cmd->start_src;
@@ -582,8 +588,9 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(this_board->i8254_osc_base,
-			&divisor1, &divisor2, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  &divisor1, &divisor2,
+					  &cmd->convert_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (cmd->convert_arg < this_board->ai_ns_min)
 			cmd->convert_arg = this_board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
@@ -619,8 +626,8 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			cmd->convert_arg = this_board->ai_ns_min;
 
 		i8253_cascade_ns_to_timer(this_board->i8254_osc_base, &divisor1,
-			&divisor2, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  &divisor2, &cmd->convert_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (divisor1 == 1) {	/*  PCL816 crash if any divisor is set to 1 */
 			divisor1 = 2;
 			divisor2 /= 2;
@@ -634,7 +641,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	if (!check_and_setup_channel_list(dev, s, cmd->chanlist,
-			cmd->chanlist_len))
+					  cmd->chanlist_len))
 		return -EINVAL;
 	udelay(1);
 
@@ -732,8 +739,8 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	transfer_from_dma_buf(dev, s,
-		(short *) devpriv->dmabuf[devpriv->next_dma_buf],
-		devpriv->ai_poll_ptr, top2);
+			      (short *)devpriv->dmabuf[devpriv->next_dma_buf],
+			      devpriv->ai_poll_ptr, top2);
 
 	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
 	spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -745,7 +752,8 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 ==============================================================================
  cancel any mode 1-4 AI
 */
-static int pcl816_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pcl816_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 /* DEBUG(printk("pcl816_ai_cancel()\n");) */
 
@@ -781,9 +789,8 @@ static int pcl816_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *
 		}
 	}
 
-	DEBUG(printk("comedi: pcl816_ai_cancel() successful\n");
-		)
-		return 0;
+	DEBUG(printk("comedi: pcl816_ai_cancel() successful\n");)
+	    return 0;
 }
 
 /*
@@ -836,7 +843,7 @@ static void pcl816_reset(struct comedi_device *dev)
 */
 static void
 start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2)
+	    unsigned int divisor2)
 {
 	outb(0x32, dev->iobase + PCL816_CTRCTL);
 	outb(0xff, dev->iobase + PCL816_CTR0);
@@ -865,8 +872,9 @@ start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
  If it's ok, then program scan/gain logic
 */
 static int
-check_and_setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, int chanlen)
+check_and_setup_channel_list(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int *chanlist,
+			     int chanlen)
 {
 	unsigned int chansegment[16];
 	unsigned int i, nowmustbechan, seglen, segpos;
@@ -882,18 +890,17 @@ check_and_setup_channel_list(struct comedi_device *dev, struct comedi_subdevice
 		for (i = 1, seglen = 1; i < chanlen; i++, seglen++) {
 			/*  build part of chanlist */
 			DEBUG(printk("%d. %d %d\n", i, CR_CHAN(chanlist[i]),
-					CR_RANGE(chanlist[i]));
-				)
-				if (chanlist[0] == chanlist[i])
+				     CR_RANGE(chanlist[i]));)
+			    if (chanlist[0] == chanlist[i])
 				break;	/*  we detect loop, this must by finish */
 			nowmustbechan =
-				(CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
+			    (CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {
 				/*  channel list isn't continous :-( */
 				printk
-					("comedi%d: pcl816: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
-					dev->minor, i, CR_CHAN(chanlist[i]),
-					nowmustbechan, CR_CHAN(chanlist[0]));
+				    ("comedi%d: pcl816: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
+				     dev->minor, i, CR_CHAN(chanlist[i]),
+				     nowmustbechan, CR_CHAN(chanlist[0]));
 				return 0;
 			}
 			chansegment[i] = chanlist[i];	/*  well, this is next correct channel in list */
@@ -901,20 +908,19 @@ check_and_setup_channel_list(struct comedi_device *dev, struct comedi_subdevice
 
 		for (i = 0, segpos = 0; i < chanlen; i++) {	/*  check whole chanlist */
 			DEBUG(printk("%d %d=%d %d\n",
-					CR_CHAN(chansegment[i % seglen]),
-					CR_RANGE(chansegment[i % seglen]),
-					CR_CHAN(chanlist[i]),
-					CR_RANGE(chanlist[i]));
-				)
-				if (chanlist[i] != chansegment[i % seglen]) {
+				     CR_CHAN(chansegment[i % seglen]),
+				     CR_RANGE(chansegment[i % seglen]),
+				     CR_CHAN(chanlist[i]),
+				     CR_RANGE(chanlist[i]));)
+			    if (chanlist[i] != chansegment[i % seglen]) {
 				printk
-					("comedi%d: pcl816: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
-					dev->minor, i, CR_CHAN(chansegment[i]),
-					CR_RANGE(chansegment[i]),
-					CR_AREF(chansegment[i]),
-					CR_CHAN(chanlist[i % seglen]),
-					CR_RANGE(chanlist[i % seglen]),
-					CR_AREF(chansegment[i % seglen]));
+				    ("comedi%d: pcl816: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
+				     dev->minor, i, CR_CHAN(chansegment[i]),
+				     CR_RANGE(chansegment[i]),
+				     CR_AREF(chansegment[i]),
+				     CR_CHAN(chanlist[i % seglen]),
+				     CR_RANGE(chanlist[i % seglen]),
+				     CR_AREF(chansegment[i % seglen]));
 				return 0;	/*  chan/gain list is strange */
 			}
 		}
@@ -997,7 +1003,7 @@ static void free_resources(struct comedi_device *dev)
 		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
 			if (devpriv->rtc_iobase)
 				release_region(devpriv->rtc_iobase,
-					devpriv->rtc_iosize);
+					       devpriv->rtc_iosize);
 		}
 #endif
 	}
@@ -1027,7 +1033,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* claim our I/O space */
 	iobase = it->options[0];
 	printk("comedi%d: pcl816:  board=%s, ioport=0x%03lx", dev->minor,
-		this_board->name, iobase);
+	       this_board->name, iobase);
 
 	if (!request_region(iobase, this_board->io_range, "pcl816")) {
 		printk("I/O port conflict\n");
@@ -1055,14 +1061,15 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & this_board->IRQbits) == 0) {
 				printk
-					(", IRQ %u is out of allowed range, DISABLING IT",
-					irq);
+				    (", IRQ %u is out of allowed range, DISABLING IT",
+				     irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (request_irq(irq, interrupt_pcl816, 0, "pcl816", dev)) {
+				if (request_irq
+				    (irq, interrupt_pcl816, 0, "pcl816", dev)) {
 					printk
-						(", unable to allocate IRQ %u, DISABLING IT",
-						irq);
+					    (", unable to allocate IRQ %u, DISABLING IT",
+					     irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
 					printk(", irq=%u", irq);
@@ -1087,7 +1094,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (it->options[2] > 0) {	/*  we want to use DMA */
 		if (RTC_lock == 0) {
 			if (!request_region(RTC_PORT(0), RTC_IO_EXTENT,
-					"pcl816 (RTC)"))
+					    "pcl816 (RTC)"))
 				goto no_rtc;
 		}
 		devpriv->rtc_iobase = RTC_PORT(0);
@@ -1095,7 +1102,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		RTC_lock++;
 #ifdef UNTESTED_CODE
 		if (!request_irq(RTC_IRQ, interrupt_pcl816_ai_mode13_dma_rtc, 0,
-				"pcl816 DMA (RTC)", dev)) {
+				 "pcl816 DMA (RTC)", dev)) {
 			devpriv->dma_rtc = 1;
 			devpriv->rtc_irq = RTC_IRQ;
 			printk(", dma_irq=%u", devpriv->rtc_irq);
@@ -1104,7 +1111,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			if (RTC_lock == 0) {
 				if (devpriv->rtc_iobase)
 					release_region(devpriv->rtc_iobase,
-						devpriv->rtc_iosize);
+						       devpriv->rtc_iosize);
 			}
 			devpriv->rtc_iobase = 0;
 			devpriv->rtc_iosize = 0;
@@ -1115,7 +1122,7 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	}
 
-      no_rtc:
+no_rtc:
 #endif
 	/* grab our DMA */
 	dma = 0;
@@ -1157,17 +1164,17 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 			if (!devpriv->dmabuf[1]) {
 				printk
-					(", unable to allocate DMA buffer, FAIL!\n");
+				    (", unable to allocate DMA buffer, FAIL!\n");
 				return -EBUSY;
 			}
 			devpriv->dmapages[1] = pages;
 			devpriv->hwdmaptr[1] =
-				virt_to_bus((void *)devpriv->dmabuf[1]);
+			    virt_to_bus((void *)devpriv->dmabuf[1]);
 			devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
 		}
 	}
 
-      no_dma:
+no_dma:
 
 /*  if (this_board->n_aochan > 0)
     subdevs[1] = COMEDI_SUBD_AO;
@@ -1241,9 +1248,8 @@ case COMEDI_SUBD_DO:
  */
 static int pcl816_detach(struct comedi_device *dev)
 {
-	DEBUG(printk("comedi%d: pcl816: remove\n", dev->minor);
-		)
-		free_resources(dev);
+	DEBUG(printk("comedi%d: pcl816: remove\n", dev->minor);)
+	    free_resources(dev);
 #ifdef unused
 	if (devpriv->dma_rtc)
 		RTC_lock--;

commit 5355d8cac2a036471c1e739ee5aa1514973ed114
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Thu Apr 16 22:22:40 2009 +0200

    Staging: fix operator precedence errors
    
    `!' has a higher precedence than `&' and `|' has a higher precedence than `?'
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 353cdaf03ed3..19465c1b53c3 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -482,7 +482,7 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
 		err++;
 
-	if (!cmd->convert_src & (TRIG_EXT | TRIG_TIMER))
+	if (!(cmd->convert_src & (TRIG_EXT | TRIG_TIMER)))
 		err++;
 
 	tmp = cmd->scan_end_src;

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index d269ac1b5ddc..353cdaf03ed3 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -263,7 +263,7 @@ static int pcl816_ai_insn_read(struct comedi_device *dev, struct comedi_subdevic
 				outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT (conversion end) flag */
 				break;
 			}
-			comedi_udelay(1);
+			udelay(1);
 		}
 		/*  Return timeout error */
 		if (!timeout) {
@@ -293,7 +293,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 		if (!(inb(dev->iobase + PCL816_STATUS) &
 				PCL816_STATUS_DRDY_MASK))
 			break;
-		comedi_udelay(1);
+		udelay(1);
 	}
 	if (!timeout) {		/*  timeout, bail error */
 		outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
@@ -449,13 +449,13 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 */
 static void pcl816_cmdtest_out(int e, struct comedi_cmd *cmd)
 {
-	rt_printk("pcl816 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
+	printk("pcl816 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
 		cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
-	rt_printk("pcl816 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
+	printk("pcl816 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
 		cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
-	rt_printk("pcl816 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
+	printk("pcl816 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
 		cmd->scan_end_src);
-	rt_printk("pcl816 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n", e,
+	printk("pcl816 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n", e,
 		cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
 }
 
@@ -468,7 +468,7 @@ static int pcl816_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	int err = 0;
 	int tmp, divisor1, divisor2;
 
-	DEBUG(rt_printk("pcl816 pcl812_ai_cmdtest\n");
+	DEBUG(printk("pcl816 pcl812_ai_cmdtest\n");
 		pcl816_cmdtest_out(-1, cmd););
 
 	/* step 1: make sure trigger sources are trivially valid */
@@ -636,7 +636,7 @@ static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (!check_and_setup_channel_list(dev, s, cmd->chanlist,
 			cmd->chanlist_len))
 		return -EINVAL;
-	comedi_udelay(1);
+	udelay(1);
 
 	devpriv->ai_act_scan = 0;
 	s->async->cur_chan = 0;
@@ -710,7 +710,7 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (!devpriv->dma)
 		return 0;	/*  poll is valid only for DMA transfer */
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 
 	for (i = 0; i < 20; i++) {
 		top1 = get_dma_residue(devpriv->dma);	/*  where is now DMA */
@@ -719,7 +719,7 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 			break;
 	}
 	if (top1 != top2) {
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		return 0;
 	}
 
@@ -727,7 +727,7 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 	top1 >>= 1;		/*  sample position */
 	top2 = top1 - devpriv->ai_poll_ptr;
 	if (top2 < 1) {		/*  no new samples */
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		return 0;
 	}
 
@@ -736,7 +736,7 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_poll_ptr, top2);
 
 	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return s->async->buf_write_count - s->async->buf_read_count;
 }
@@ -747,7 +747,7 @@ static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 */
 static int pcl816_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-/* DEBUG(rt_printk("pcl816_ai_cancel()\n");) */
+/* DEBUG(printk("pcl816_ai_cancel()\n");) */
 
 	if (devpriv->irq_blocked > 0) {
 		switch (devpriv->int816_mode) {
@@ -763,7 +763,7 @@ static int pcl816_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *
 		case INT_TYPE_AI1_INT:
 		case INT_TYPE_AI3_INT:
 			outb(inb(dev->iobase + PCL816_CONTROL) & 0x73, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
-			comedi_udelay(1);
+			udelay(1);
 			outb(0, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
 			outb(0xb0, dev->iobase + PCL816_CTRCTL);	/* Stop pacer */
 			outb(0x70, dev->iobase + PCL816_CTRCTL);
@@ -781,7 +781,7 @@ static int pcl816_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *
 		}
 	}
 
-	DEBUG(rt_printk("comedi: pcl816_ai_cancel() successful\n");
+	DEBUG(printk("comedi: pcl816_ai_cancel() successful\n");
 		)
 		return 0;
 }
@@ -793,17 +793,17 @@ static int pcl816_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *
 static int pcl816_check(unsigned long iobase)
 {
 	outb(0x00, iobase + PCL816_MUX);
-	comedi_udelay(1);
+	udelay(1);
 	if (inb(iobase + PCL816_MUX) != 0x00)
 		return 1;	/* there isn't card */
 	outb(0x55, iobase + PCL816_MUX);
-	comedi_udelay(1);
+	udelay(1);
 	if (inb(iobase + PCL816_MUX) != 0x55)
 		return 1;	/* there isn't card */
 	outb(0x00, iobase + PCL816_MUX);
-	comedi_udelay(1);
+	udelay(1);
 	outb(0x18, iobase + PCL816_CONTROL);
-	comedi_udelay(1);
+	udelay(1);
 	if (inb(iobase + PCL816_CONTROL) != 0x18)
 		return 1;	/* there isn't card */
 	return 0;		/*  ok, card exist */
@@ -817,10 +817,10 @@ static void pcl816_reset(struct comedi_device *dev)
 {
 /* outb (0, dev->iobase + PCL818_DA_LO);         DAC=0V */
 /* outb (0, dev->iobase + PCL818_DA_HI); */
-/* comedi_udelay (1); */
+/* udelay (1); */
 /* outb (0, dev->iobase + PCL818_DO_HI);        DO=$0000 */
 /* outb (0, dev->iobase + PCL818_DO_LO); */
-/* comedi_udelay (1); */
+/* udelay (1); */
 	outb(0, dev->iobase + PCL816_CONTROL);
 	outb(0, dev->iobase + PCL816_MUX);
 	outb(0, dev->iobase + PCL816_CLRINT);
@@ -841,10 +841,10 @@ start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
 	outb(0x32, dev->iobase + PCL816_CTRCTL);
 	outb(0xff, dev->iobase + PCL816_CTR0);
 	outb(0x00, dev->iobase + PCL816_CTR0);
-	comedi_udelay(1);
+	udelay(1);
 	outb(0xb4, dev->iobase + PCL816_CTRCTL);	/*  set counter 2 as mode 3 */
 	outb(0x74, dev->iobase + PCL816_CTRCTL);	/*  set counter 1 as mode 3 */
-	comedi_udelay(1);
+	udelay(1);
 
 	if (mode == 1) {
 		DPRINTK("mode %d, divisor1 %d, divisor2 %d\n", mode, divisor1,
@@ -881,7 +881,7 @@ check_and_setup_channel_list(struct comedi_device *dev, struct comedi_subdevice
 		chansegment[0] = chanlist[0];	/*  first channel is everytime ok */
 		for (i = 1, seglen = 1; i < chanlen; i++, seglen++) {
 			/*  build part of chanlist */
-			DEBUG(rt_printk("%d. %d %d\n", i, CR_CHAN(chanlist[i]),
+			DEBUG(printk("%d. %d %d\n", i, CR_CHAN(chanlist[i]),
 					CR_RANGE(chanlist[i]));
 				)
 				if (chanlist[0] == chanlist[i])
@@ -890,7 +890,7 @@ check_and_setup_channel_list(struct comedi_device *dev, struct comedi_subdevice
 				(CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {
 				/*  channel list isn't continous :-( */
-				rt_printk
+				printk
 					("comedi%d: pcl816: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
 					dev->minor, i, CR_CHAN(chanlist[i]),
 					nowmustbechan, CR_CHAN(chanlist[0]));
@@ -900,14 +900,14 @@ check_and_setup_channel_list(struct comedi_device *dev, struct comedi_subdevice
 		}
 
 		for (i = 0, segpos = 0; i < chanlen; i++) {	/*  check whole chanlist */
-			DEBUG(rt_printk("%d %d=%d %d\n",
+			DEBUG(printk("%d %d=%d %d\n",
 					CR_CHAN(chansegment[i % seglen]),
 					CR_RANGE(chansegment[i % seglen]),
 					CR_CHAN(chanlist[i]),
 					CR_RANGE(chanlist[i]));
 				)
 				if (chanlist[i] != chansegment[i % seglen]) {
-				rt_printk
+				printk
 					("comedi%d: pcl816: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
 					dev->minor, i, CR_CHAN(chansegment[i]),
 					CR_RANGE(chansegment[i]),
@@ -931,7 +931,7 @@ check_and_setup_channel_list(struct comedi_device *dev, struct comedi_subdevice
 		outb(CR_RANGE(chanlist[0]), dev->iobase + PCL816_RANGE);	/* select gain */
 	}
 
-	comedi_udelay(1);
+	udelay(1);
 
 	outb(devpriv->ai_act_chanlist[0] | (devpriv->ai_act_chanlist[seglen - 1] << 4), dev->iobase + PCL816_MUX);	/* select channel interval to scan */
 
@@ -981,7 +981,7 @@ static int set_rtc_irq_bit(unsigned char bit)
 */
 static void free_resources(struct comedi_device *dev)
 {
-	/* rt_printk("free_resource()\n"); */
+	/* printk("free_resource()\n"); */
 	if (dev->private) {
 		pcl816_ai_cancel(dev, devpriv->sub_ai);
 		pcl816_reset(dev);
@@ -993,7 +993,7 @@ static void free_resources(struct comedi_device *dev)
 			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
 #ifdef unused
 		if (devpriv->rtc_irq)
-			comedi_free_irq(devpriv->rtc_irq, dev);
+			free_irq(devpriv->rtc_irq, dev);
 		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
 			if (devpriv->rtc_iobase)
 				release_region(devpriv->rtc_iobase,
@@ -1006,7 +1006,7 @@ static void free_resources(struct comedi_device *dev)
 		free_irq(dev->irq, dev);
 	if (dev->iobase)
 		release_region(dev->iobase, this_board->io_range);
-	/* rt_printk("free_resource() end\n"); */
+	/* printk("free_resource() end\n"); */
 }
 
 /*
@@ -1030,14 +1030,14 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		this_board->name, iobase);
 
 	if (!request_region(iobase, this_board->io_range, "pcl816")) {
-		rt_printk("I/O port conflict\n");
+		printk("I/O port conflict\n");
 		return -EIO;
 	}
 
 	dev->iobase = iobase;
 
 	if (pcl816_check(iobase)) {
-		rt_printk(", I cann't detect board. FAIL!\n");
+		printk(", I cann't detect board. FAIL!\n");
 		return -EIO;
 	}
 
@@ -1054,19 +1054,18 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		irq = it->options[1];
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & this_board->IRQbits) == 0) {
-				rt_printk
+				printk
 					(", IRQ %u is out of allowed range, DISABLING IT",
 					irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (comedi_request_irq(irq, interrupt_pcl816, 0,
-						"pcl816", dev)) {
-					rt_printk
+				if (request_irq(irq, interrupt_pcl816, 0, "pcl816", dev)) {
+					printk
 						(", unable to allocate IRQ %u, DISABLING IT",
 						irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
-					rt_printk(", irq=%u", irq);
+					printk(", irq=%u", irq);
 				}
 			}
 		}
@@ -1095,12 +1094,11 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->rtc_iosize = RTC_IO_EXTENT;
 		RTC_lock++;
 #ifdef UNTESTED_CODE
-		if (!comedi_request_irq(RTC_IRQ,
-				interrupt_pcl816_ai_mode13_dma_rtc, 0,
+		if (!request_irq(RTC_IRQ, interrupt_pcl816_ai_mode13_dma_rtc, 0,
 				"pcl816 DMA (RTC)", dev)) {
 			devpriv->dma_rtc = 1;
 			devpriv->rtc_irq = RTC_IRQ;
-			rt_printk(", dma_irq=%u", devpriv->rtc_irq);
+			printk(", dma_irq=%u", devpriv->rtc_irq);
 		} else {
 			RTC_lock--;
 			if (RTC_lock == 0) {
@@ -1131,34 +1129,34 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			goto no_dma;	/* DMA disabled */
 
 		if (((1 << dma) & this_board->DMAbits) == 0) {
-			rt_printk(", DMA is out of allowed range, FAIL!\n");
+			printk(", DMA is out of allowed range, FAIL!\n");
 			return -EINVAL;	/* Bad DMA */
 		}
 		ret = request_dma(dma, "pcl816");
 		if (ret) {
-			rt_printk(", unable to allocate DMA %u, FAIL!\n", dma);
+			printk(", unable to allocate DMA %u, FAIL!\n", dma);
 			return -EBUSY;	/* DMA isn't free */
 		}
 
 		devpriv->dma = dma;
-		rt_printk(", dma=%u", dma);
+		printk(", dma=%u", dma);
 		pages = 2;	/* we need 16KB */
 		devpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);
 
 		if (!devpriv->dmabuf[0]) {
-			rt_printk(", unable to allocate DMA buffer, FAIL!\n");
+			printk(", unable to allocate DMA buffer, FAIL!\n");
 			/* maybe experiment with try_to_free_pages() will help .... */
 			return -EBUSY;	/* no buffer :-( */
 		}
 		devpriv->dmapages[0] = pages;
 		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
 		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
-		/* rt_printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
+		/* printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
 
 		if (devpriv->dma_rtc == 0) {	/*  we must do duble buff :-( */
 			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 			if (!devpriv->dmabuf[1]) {
-				rt_printk
+				printk
 					(", unable to allocate DMA buffer, FAIL!\n");
 				return -EBUSY;
 			}
@@ -1232,7 +1230,7 @@ case COMEDI_SUBD_DO:
 
 	pcl816_reset(dev);
 
-	rt_printk("\n");
+	printk("\n");
 
 	return 0;
 }
@@ -1243,7 +1241,7 @@ case COMEDI_SUBD_DO:
  */
 static int pcl816_detach(struct comedi_device *dev)
 {
-	DEBUG(rt_printk("comedi%d: pcl816: remove\n", dev->minor);
+	DEBUG(printk("comedi%d: pcl816: remove\n", dev->minor);
 		)
 		free_resources(dev);
 #ifdef unused

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index c52ba0319a46..d269ac1b5ddc 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -157,13 +157,13 @@ static int RTC_timer_lock = 0;	/* RTC int lock */
 #endif
 
 static struct comedi_driver driver_pcl816 = {
-      driver_name:"pcl816",
-      module:THIS_MODULE,
-      attach:pcl816_attach,
-      detach:pcl816_detach,
-      board_name:&boardtypes[0].name,
-      num_names:n_boardtypes,
-      offset:sizeof(struct pcl816_board),
+	.driver_name = "pcl816",
+	.module = THIS_MODULE,
+	.attach = pcl816_attach,
+	.detach = pcl816_detach,
+	.board_name = &boardtypes[0].name,
+	.num_names = n_boardtypes,
+	.offset = sizeof(struct pcl816_board),
 };
 
 COMEDI_INITCLEANUP(driver_pcl816);

commit c3744138715045adb316284ee7a1e608f0278f6c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:47 2009 -0400

    Staging: comedi: remove assignment in conditionals
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index f44bd43f5d3f..c52ba0319a46 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -1041,7 +1041,8 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EIO;
 	}
 
-	if ((ret = alloc_private(dev, sizeof(struct pcl816_private))) < 0)
+	ret = alloc_private(dev, sizeof(struct pcl816_private));
+	if (ret < 0)
 		return ret;	/* Can't alloc mem */
 
 	/* set up some name stuff */
@@ -1177,7 +1178,9 @@ static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
   if (this_board->n_dochan > 0)
     subdevs[3] = COMEDI_SUBD_DO;
 */
-	if ((ret = alloc_subdevices(dev, 1)) < 0)
+
+	ret = alloc_subdevices(dev, 1);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 2241fa9f5b63..f44bd43f5d3f 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -148,8 +148,8 @@ static const struct pcl816_board boardtypes[] = {
 #define devpriv ((struct pcl816_private *)dev->private)
 #define this_board ((const struct pcl816_board *)dev->board_ptr)
 
-static int pcl816_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int pcl816_detach(struct comedi_device * dev);
+static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcl816_detach(struct comedi_device *dev);
 
 #ifdef unused
 static int RTC_lock = 0;	/* RTC lock */
@@ -213,25 +213,25 @@ struct pcl816_private {
 /*
 ==============================================================================
 */
-static int check_and_setup_channel_list(struct comedi_device * dev,
-	struct comedi_subdevice * s, unsigned int *chanlist, int chanlen);
-static int pcl816_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static void start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
+static int check_and_setup_channel_list(struct comedi_device *dev,
+	struct comedi_subdevice *s, unsigned int *chanlist, int chanlen);
+static int pcl816_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
 	unsigned int divisor2);
 #ifdef unused
 static int set_rtc_irq_bit(unsigned char bit);
 #endif
 
-static int pcl816_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int pcl816_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int pcl816_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 
 /*
 ==============================================================================
    ANALOG INPUT MODE0, 816 cards, slow version
 */
-static int pcl816_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pcl816_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int timeout;
@@ -334,8 +334,8 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 ==============================================================================
    analog input dma mode 1 & 3, 816 cards
 */
-static void transfer_from_dma_buf(struct comedi_device * dev, struct comedi_subdevice * s,
-	short * ptr, unsigned int bufptr, unsigned int len)
+static void transfer_from_dma_buf(struct comedi_device *dev, struct comedi_subdevice *s,
+	short *ptr, unsigned int bufptr, unsigned int len)
 {
 	int i;
 
@@ -447,7 +447,7 @@ static irqreturn_t interrupt_pcl816(int irq, void *d)
 ==============================================================================
    COMMAND MODE
 */
-static void pcl816_cmdtest_out(int e, struct comedi_cmd * cmd)
+static void pcl816_cmdtest_out(int e, struct comedi_cmd *cmd)
 {
 	rt_printk("pcl816 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
 		cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
@@ -462,8 +462,8 @@ static void pcl816_cmdtest_out(int e, struct comedi_cmd * cmd)
 /*
 ==============================================================================
 */
-static int pcl816_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int pcl816_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
@@ -597,7 +597,7 @@ static int pcl816_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-static int pcl816_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned int divisor1 = 0, divisor2 = 0, dma_flags, bytes, dmairq;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -702,7 +702,7 @@ static int pcl816_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 	return 0;
 }
 
-static int pcl816_ai_poll(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 	unsigned int top1, top2, i;
@@ -745,7 +745,7 @@ static int pcl816_ai_poll(struct comedi_device * dev, struct comedi_subdevice *
 ==============================================================================
  cancel any mode 1-4 AI
 */
-static int pcl816_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pcl816_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 /* DEBUG(rt_printk("pcl816_ai_cancel()\n");) */
 
@@ -813,7 +813,7 @@ static int pcl816_check(unsigned long iobase)
 ==============================================================================
  reset whole PCL-816 cards
 */
-static void pcl816_reset(struct comedi_device * dev)
+static void pcl816_reset(struct comedi_device *dev)
 {
 /* outb (0, dev->iobase + PCL818_DA_LO);         DAC=0V */
 /* outb (0, dev->iobase + PCL818_DA_HI); */
@@ -835,7 +835,7 @@ static void pcl816_reset(struct comedi_device * dev)
  Start/stop pacer onboard pacer
 */
 static void
-start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
+start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
 	unsigned int divisor2)
 {
 	outb(0x32, dev->iobase + PCL816_CTRCTL);
@@ -865,7 +865,7 @@ start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
  If it's ok, then program scan/gain logic
 */
 static int
-check_and_setup_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
+check_and_setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int *chanlist, int chanlen)
 {
 	unsigned int chansegment[16];
@@ -979,7 +979,7 @@ static int set_rtc_irq_bit(unsigned char bit)
 ==============================================================================
   Free any resources that we have claimed
 */
-static void free_resources(struct comedi_device * dev)
+static void free_resources(struct comedi_device *dev)
 {
 	/* rt_printk("free_resource()\n"); */
 	if (dev->private) {
@@ -1015,7 +1015,7 @@ static void free_resources(struct comedi_device * dev)
    Initialization
 
 */
-static int pcl816_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	int ret;
 	unsigned long iobase;
@@ -1238,7 +1238,7 @@ case COMEDI_SUBD_DO:
 ==============================================================================
   Removes device
  */
-static int pcl816_detach(struct comedi_device * dev)
+static int pcl816_detach(struct comedi_device *dev)
 {
 	DEBUG(rt_printk("comedi%d: pcl816: remove\n", dev->minor);
 		)

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 5382adf1dd6a..2241fa9f5b63 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -409,7 +409,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 ==============================================================================
     INT procedure
 */
-static irqreturn_t interrupt_pcl816(int irq, void *d PT_REGS_ARG)
+static irqreturn_t interrupt_pcl816(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	DPRINTK("<I>");

commit 58c0576eea94298e698e03114c4d3d0179c5ef66
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:31:22 2009 -0400

    Staging: comedi: remove C99 comments in pcl816.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 515ba74cc7fe..5382adf1dd6a 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -43,38 +43,38 @@ Configuration Options:
 
 #define DEBUG(x) x
 
-// boards constants
-// IO space len
+/* boards constants */
+/* IO space len */
 #define PCLx1x_RANGE 16
 
-//#define outb(x,y)  printk("OUTB(%x, 200+%d)\n", x,y-0x200); outb(x,y)
+/* #define outb(x,y)  printk("OUTB(%x, 200+%d)\n", x,y-0x200); outb(x,y) */
 
-// INTEL 8254 counters
+/* INTEL 8254 counters */
 #define PCL816_CTR0 4
 #define PCL816_CTR1 5
 #define PCL816_CTR2 6
-// R: counter read-back register W: counter control
+/* R: counter read-back register W: counter control */
 #define PCL816_CTRCTL 7
 
-// R: A/D high byte W: A/D range control
+/* R: A/D high byte W: A/D range control */
 #define PCL816_RANGE 9
-// W: clear INT request
+/* W: clear INT request */
 #define PCL816_CLRINT 10
-// R: next mux scan channel W: mux scan channel & range control pointer
+/* R: next mux scan channel W: mux scan channel & range control pointer */
 #define PCL816_MUX 11
-// R/W: operation control register
+/* R/W: operation control register */
 #define PCL816_CONTROL 12
 
-// R: return status byte  W: set DMA/IRQ
+/* R: return status byte  W: set DMA/IRQ */
 #define PCL816_STATUS 13
 #define PCL816_STATUS_DRDY_MASK 0x80
 
-// R: low byte of A/D W: soft A/D trigger
+/* R: low byte of A/D W: soft A/D trigger */
 #define PCL816_AD_LO 8
-// R: high byte of A/D W: A/D range control
+/* R: high byte of A/D W: A/D range control */
 #define PCL816_AD_HI 9
 
-// type of interrupt handler
+/* type of interrupt handler */
 #define INT_TYPE_AI1_INT 1
 #define INT_TYPE_AI1_DMA 2
 #define INT_TYPE_AI3_INT 4
@@ -83,7 +83,7 @@ Configuration Options:
 #define INT_TYPE_AI1_DMA_RTC 9
 #define INT_TYPE_AI3_DMA_RTC 10
 
-// RTC stuff...
+/* RTC stuff... */
 #define RTC_IRQ 	8
 #define RTC_IO_EXTENT	0x10
 #endif
@@ -103,35 +103,35 @@ static const struct comedi_lrange range_pcl816 = { 8, {
 };
 struct pcl816_board {
 
-	const char *name;	// board name
-	int n_ranges;		// len of range list
-	int n_aichan;		// num of A/D chans in diferencial mode
-	unsigned int ai_ns_min;	// minimal alllowed delay between samples (in ns)
-	int n_aochan;		// num of D/A chans
-	int n_dichan;		// num of DI chans
-	int n_dochan;		// num of DO chans
-	const struct comedi_lrange *ai_range_type;	// default A/D rangelist
-	const struct comedi_lrange *ao_range_type;	// dafault D/A rangelist
-	unsigned int io_range;	// len of IO space
-	unsigned int IRQbits;	// allowed interrupts
-	unsigned int DMAbits;	// allowed DMA chans
-	int ai_maxdata;		// maxdata for A/D
-	int ao_maxdata;		// maxdata for D/A
-	int ai_chanlist;	// allowed len of channel list A/D
-	int ao_chanlist;	// allowed len of channel list D/A
-	int i8254_osc_base;	// 1/frequency of on board oscilator in ns
+	const char *name;	/*  board name */
+	int n_ranges;		/*  len of range list */
+	int n_aichan;		/*  num of A/D chans in diferencial mode */
+	unsigned int ai_ns_min;	/*  minimal alllowed delay between samples (in ns) */
+	int n_aochan;		/*  num of D/A chans */
+	int n_dichan;		/*  num of DI chans */
+	int n_dochan;		/*  num of DO chans */
+	const struct comedi_lrange *ai_range_type;	/*  default A/D rangelist */
+	const struct comedi_lrange *ao_range_type;	/*  dafault D/A rangelist */
+	unsigned int io_range;	/*  len of IO space */
+	unsigned int IRQbits;	/*  allowed interrupts */
+	unsigned int DMAbits;	/*  allowed DMA chans */
+	int ai_maxdata;		/*  maxdata for A/D */
+	int ao_maxdata;		/*  maxdata for D/A */
+	int ai_chanlist;	/*  allowed len of channel list A/D */
+	int ao_chanlist;	/*  allowed len of channel list D/A */
+	int i8254_osc_base;	/*  1/frequency of on board oscilator in ns */
 };
 
 
 static const struct pcl816_board boardtypes[] = {
 	{"pcl816", 8, 16, 10000, 1, 16, 16, &range_pcl816,
 			&range_pcl816, PCLx1x_RANGE,
-			0x00fc,	// IRQ mask
-			0x0a,	// DMA mask
-			0xffff,	// 16-bit card
-			0xffff,	// D/A maxdata
+			0x00fc,	/*  IRQ mask */
+			0x0a,	/*  DMA mask */
+			0xffff,	/*  16-bit card */
+			0xffff,	/*  D/A maxdata */
 			1024,
-			1,	// ao chan list
+			1,	/*  ao chan list */
 		100},
 	{"pcl814b", 8, 16, 10000, 1, 16, 16, &range_pcl816,
 			&range_pcl816, PCLx1x_RANGE,
@@ -170,42 +170,42 @@ COMEDI_INITCLEANUP(driver_pcl816);
 
 struct pcl816_private {
 
-	unsigned int dma;	// used DMA, 0=don't use DMA
-	int dma_rtc;		// 1=RTC used with DMA, 0=no RTC alloc
+	unsigned int dma;	/*  used DMA, 0=don't use DMA */
+	int dma_rtc;		/*  1=RTC used with DMA, 0=no RTC alloc */
 #ifdef unused
-	unsigned long rtc_iobase;	// RTC port region
+	unsigned long rtc_iobase;	/*  RTC port region */
 	unsigned int rtc_iosize;
 	unsigned int rtc_irq;
 #endif
-	unsigned long dmabuf[2];	// pointers to begin of DMA buffers
-	unsigned int dmapages[2];	// len of DMA buffers in PAGE_SIZEs
-	unsigned int hwdmaptr[2];	// hardware address of DMA buffers
-	unsigned int hwdmasize[2];	// len of DMA buffers in Bytes
-	unsigned int dmasamplsize;	// size in samples hwdmasize[0]/2
-	unsigned int last_top_dma;	// DMA pointer in last RTC int
-	int next_dma_buf;	// which DMA buffer will be used next round
-	long dma_runs_to_end;	// how many we must permorm DMA transfer to end of record
-	unsigned long last_dma_run;	// how many bytes we must transfer on last DMA page
-
-	unsigned int ai_scans;	// len of scanlist
-	unsigned char ai_neverending;	// if=1, then we do neverending record (you must use cancel())
-	int irq_free;		// 1=have allocated IRQ
-	int irq_blocked;	// 1=IRQ now uses any subdev
+	unsigned long dmabuf[2];	/*  pointers to begin of DMA buffers */
+	unsigned int dmapages[2];	/*  len of DMA buffers in PAGE_SIZEs */
+	unsigned int hwdmaptr[2];	/*  hardware address of DMA buffers */
+	unsigned int hwdmasize[2];	/*  len of DMA buffers in Bytes */
+	unsigned int dmasamplsize;	/*  size in samples hwdmasize[0]/2 */
+	unsigned int last_top_dma;	/*  DMA pointer in last RTC int */
+	int next_dma_buf;	/*  which DMA buffer will be used next round */
+	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
+	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
+
+	unsigned int ai_scans;	/*  len of scanlist */
+	unsigned char ai_neverending;	/*  if=1, then we do neverending record (you must use cancel()) */
+	int irq_free;		/*  1=have allocated IRQ */
+	int irq_blocked;	/*  1=IRQ now uses any subdev */
 #ifdef unused
-	int rtc_irq_blocked;	// 1=we now do AI with DMA&RTC
+	int rtc_irq_blocked;	/*  1=we now do AI with DMA&RTC */
 #endif
-	int irq_was_now_closed;	// when IRQ finish, there's stored int816_mode for last interrupt
-	int int816_mode;	// who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma
-	struct comedi_subdevice *last_int_sub;	// ptr to subdevice which now finish
-	int ai_act_scan;	// how many scans we finished
-	unsigned int ai_act_chanlist[16];	// MUX setting for actual AI operations
-	unsigned int ai_act_chanlist_len;	// how long is actual MUX list
-	unsigned int ai_act_chanlist_pos;	// actual position in MUX list
-	unsigned int ai_poll_ptr;	// how many sampes transfer poll
-	struct comedi_subdevice *sub_ai;	// ptr to AI subdevice
+	int irq_was_now_closed;	/*  when IRQ finish, there's stored int816_mode for last interrupt */
+	int int816_mode;	/*  who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma */
+	struct comedi_subdevice *last_int_sub;	/*  ptr to subdevice which now finish */
+	int ai_act_scan;	/*  how many scans we finished */
+	unsigned int ai_act_chanlist[16];	/*  MUX setting for actual AI operations */
+	unsigned int ai_act_chanlist_len;	/*  how long is actual MUX list */
+	unsigned int ai_act_chanlist_pos;	/*  actual position in MUX list */
+	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
+	struct comedi_subdevice *sub_ai;	/*  ptr to AI subdevice */
 #ifdef unused
-	struct timer_list rtc_irq_timer;	// timer for RTC sanity check
-	unsigned long rtc_freq;	// RTC int freq
+	struct timer_list rtc_irq_timer;	/*  timer for RTC sanity check */
+	unsigned long rtc_freq;	/*  RTC int freq */
 #endif
 };
 
@@ -237,12 +237,12 @@ static int pcl816_ai_insn_read(struct comedi_device * dev, struct comedi_subdevi
 	int timeout;
 
 	DPRINTK("mode 0 analog input\n");
-	// software trigger, DMA and INT off
+	/*  software trigger, DMA and INT off */
 	outb(0, dev->iobase + PCL816_CONTROL);
-	// clear INT (conversion end) flag
+	/*  clear INT (conversion end) flag */
 	outb(0, dev->iobase + PCL816_CLRINT);
 
-	// Set the input channel
+	/*  Set the input channel */
 	outb(CR_CHAN(insn->chanspec) & 0xf, dev->iobase + PCL816_MUX);
 	outb(CR_RANGE(insn->chanspec), dev->iobase + PCL816_RANGE);	/* select gain */
 
@@ -254,7 +254,7 @@ static int pcl816_ai_insn_read(struct comedi_device * dev, struct comedi_subdevi
 		while (timeout--) {
 			if (!(inb(dev->iobase + PCL816_STATUS) &
 					PCL816_STATUS_DRDY_MASK)) {
-				// return read value
+				/*  return read value */
 				data[n] =
 					((inb(dev->iobase +
 							PCL816_AD_HI) << 8) |
@@ -265,7 +265,7 @@ static int pcl816_ai_insn_read(struct comedi_device * dev, struct comedi_subdevi
 			}
 			comedi_udelay(1);
 		}
-		// Return timeout error
+		/*  Return timeout error */
 		if (!timeout) {
 			comedi_error(dev, "A/D insn timeout\n");
 			data[0] = 0;
@@ -295,7 +295,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 			break;
 		comedi_udelay(1);
 	}
-	if (!timeout) {		// timeout, bail error
+	if (!timeout) {		/*  timeout, bail error */
 		outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
 		comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
 		pcl816_ai_cancel(dev, s);
@@ -305,7 +305,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 
 	}
 
-	// get the sample
+	/*  get the sample */
 	low = inb(dev->iobase + PCL816_AD_LO);
 	hi = inb(dev->iobase + PCL816_AD_HI);
 
@@ -352,7 +352,7 @@ static void transfer_from_dma_buf(struct comedi_device * dev, struct comedi_subd
 		}
 
 		if (!devpriv->ai_neverending)
-			if (devpriv->ai_act_scan >= devpriv->ai_scans) {	// all data sampled
+			if (devpriv->ai_act_scan >= devpriv->ai_scans) {	/*  all data sampled */
 				pcl816_ai_cancel(dev, s);
 				s->async->events |= COMEDI_CB_EOA;
 				s->async->events |= COMEDI_CB_BLOCK;
@@ -374,12 +374,12 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 	disable_dma(devpriv->dma);
 	this_dma_buf = devpriv->next_dma_buf;
 
-	if ((devpriv->dma_runs_to_end > -1) || devpriv->ai_neverending) {	// switch dma bufs
+	if ((devpriv->dma_runs_to_end > -1) || devpriv->ai_neverending) {	/*  switch dma bufs */
 
 		devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
 		set_dma_mode(devpriv->dma, DMA_MODE_READ);
 		dma_flags = claim_dma_lock();
-//  clear_dma_ff (devpriv->dma);
+/* clear_dma_ff (devpriv->dma); */
 		set_dma_addr(devpriv->dma,
 			devpriv->hwdmaptr[devpriv->next_dma_buf]);
 		if (devpriv->dma_runs_to_end) {
@@ -433,7 +433,7 @@ static irqreturn_t interrupt_pcl816(int irq, void *d PT_REGS_ARG)
 		(!devpriv->int816_mode)) {
 		if (devpriv->irq_was_now_closed) {
 			devpriv->irq_was_now_closed = 0;
-			// comedi_error(dev,"last IRQ..");
+			/*  comedi_error(dev,"last IRQ.."); */
 			return IRQ_HANDLED;
 		}
 		comedi_error(dev, "bad IRQ!");
@@ -610,7 +610,7 @@ static int pcl816_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 		return -EINVAL;
 	if (cmd->scan_end_arg != cmd->chanlist_len)
 		return -EINVAL;
-//      if(cmd->chanlist_len>MAX_CHANLIST_LEN) return -EINVAL;
+/* if(cmd->chanlist_len>MAX_CHANLIST_LEN) return -EINVAL; */
 	if (devpriv->irq_blocked)
 		return -EBUSY;
 
@@ -621,7 +621,7 @@ static int pcl816_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 		i8253_cascade_ns_to_timer(this_board->i8254_osc_base, &divisor1,
 			&divisor2, &cmd->convert_arg,
 			cmd->flags & TRIG_ROUND_MASK);
-		if (divisor1 == 1) {	// PCL816 crash if any divisor is set to 1
+		if (divisor1 == 1) {	/*  PCL816 crash if any divisor is set to 1 */
 			divisor1 = 2;
 			divisor2 /= 2;
 		}
@@ -631,7 +631,7 @@ static int pcl816_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 		}
 	}
 
-	start_pacer(dev, -1, 0, 0);	// stop pacer
+	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	if (!check_and_setup_channel_list(dev, s, cmd->chanlist,
 			cmd->chanlist_len))
@@ -652,19 +652,19 @@ static int pcl816_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 		devpriv->ai_neverending = 1;
 	}
 
-	if ((cmd->flags & TRIG_WAKE_EOS)) {	// don't we want wake up every scan?
+	if ((cmd->flags & TRIG_WAKE_EOS)) {	/*  don't we want wake up every scan? */
 		printk("pl816: You wankt WAKE_EOS but I dont want handle it");
-		//              devpriv->ai_eos=1;
-		//if (devpriv->ai_n_chan==1)
-		//      devpriv->dma=0; // DMA is useless for this situation
+		/*               devpriv->ai_eos=1; */
+		/* if (devpriv->ai_n_chan==1) */
+		/*       devpriv->dma=0; // DMA is useless for this situation */
 	}
 
 	if (devpriv->dma) {
 		bytes = devpriv->hwdmasize[0];
 		if (!devpriv->ai_neverending) {
-			bytes = s->async->cmd.chanlist_len * s->async->cmd.chanlist_len * sizeof(short);	// how many
-			devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize[0];	// how many DMA pages we must fill
-			devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];	//on last dma transfer must be moved
+			bytes = s->async->cmd.chanlist_len * s->async->cmd.chanlist_len * sizeof(short);	/*  how many */
+			devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize[0];	/*  how many DMA pages we must fill */
+			devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];	/* on last dma transfer must be moved */
 			devpriv->dma_runs_to_end--;
 			if (devpriv->dma_runs_to_end >= 0)
 				bytes = devpriv->hwdmasize[0];
@@ -687,14 +687,14 @@ static int pcl816_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 	switch (cmd->convert_src) {
 	case TRIG_TIMER:
 		devpriv->int816_mode = INT_TYPE_AI1_DMA;
-		outb(0x32, dev->iobase + PCL816_CONTROL);	// Pacer+IRQ+DMA
-		outb(dmairq, dev->iobase + PCL816_STATUS);	// write irq and DMA to card
+		outb(0x32, dev->iobase + PCL816_CONTROL);	/*  Pacer+IRQ+DMA */
+		outb(dmairq, dev->iobase + PCL816_STATUS);	/*  write irq and DMA to card */
 		break;
 
 	default:
 		devpriv->int816_mode = INT_TYPE_AI3_DMA;
-		outb(0x34, dev->iobase + PCL816_CONTROL);	// Ext trig+IRQ+DMA
-		outb(dmairq, dev->iobase + PCL816_STATUS);	// write irq to card
+		outb(0x34, dev->iobase + PCL816_CONTROL);	/*  Ext trig+IRQ+DMA */
+		outb(dmairq, dev->iobase + PCL816_STATUS);	/*  write irq to card */
 		break;
 	}
 
@@ -708,12 +708,12 @@ static int pcl816_ai_poll(struct comedi_device * dev, struct comedi_subdevice *
 	unsigned int top1, top2, i;
 
 	if (!devpriv->dma)
-		return 0;	// poll is valid only for DMA transfer
+		return 0;	/*  poll is valid only for DMA transfer */
 
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 
 	for (i = 0; i < 20; i++) {
-		top1 = get_dma_residue(devpriv->dma);	// where is now DMA
+		top1 = get_dma_residue(devpriv->dma);	/*  where is now DMA */
 		top2 = get_dma_residue(devpriv->dma);
 		if (top1 == top2)
 			break;
@@ -723,10 +723,10 @@ static int pcl816_ai_poll(struct comedi_device * dev, struct comedi_subdevice *
 		return 0;
 	}
 
-	top1 = devpriv->hwdmasize[0] - top1;	// where is now DMA in buffer
-	top1 >>= 1;		// sample position
+	top1 = devpriv->hwdmasize[0] - top1;	/*  where is now DMA in buffer */
+	top1 >>= 1;		/*  sample position */
 	top2 = top1 - devpriv->ai_poll_ptr;
-	if (top2 < 1) {		// no new samples
+	if (top2 < 1) {		/*  no new samples */
 		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 		return 0;
 	}
@@ -735,7 +735,7 @@ static int pcl816_ai_poll(struct comedi_device * dev, struct comedi_subdevice *
 		(short *) devpriv->dmabuf[devpriv->next_dma_buf],
 		devpriv->ai_poll_ptr, top2);
 
-	devpriv->ai_poll_ptr = top1;	// new buffer position
+	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return s->async->buf_write_count - s->async->buf_read_count;
@@ -747,14 +747,14 @@ static int pcl816_ai_poll(struct comedi_device * dev, struct comedi_subdevice *
 */
 static int pcl816_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-//  DEBUG(rt_printk("pcl816_ai_cancel()\n");)
+/* DEBUG(rt_printk("pcl816_ai_cancel()\n");) */
 
 	if (devpriv->irq_blocked > 0) {
 		switch (devpriv->int816_mode) {
 #ifdef unused
 		case INT_TYPE_AI1_DMA_RTC:
 		case INT_TYPE_AI3_DMA_RTC:
-			set_rtc_irq_bit(0);	// stop RTC
+			set_rtc_irq_bit(0);	/*  stop RTC */
 			del_timer(&devpriv->rtc_irq_timer);
 #endif
 		case INT_TYPE_AI1_DMA:
@@ -776,7 +776,7 @@ static int pcl816_ai_cancel(struct comedi_device * dev, struct comedi_subdevice
 			devpriv->irq_was_now_closed = devpriv->int816_mode;
 			devpriv->int816_mode = 0;
 			devpriv->last_int_sub = s;
-//        s->busy = 0;
+/* s->busy = 0; */
 			break;
 		}
 	}
@@ -795,18 +795,18 @@ static int pcl816_check(unsigned long iobase)
 	outb(0x00, iobase + PCL816_MUX);
 	comedi_udelay(1);
 	if (inb(iobase + PCL816_MUX) != 0x00)
-		return 1;	//there isn't card
+		return 1;	/* there isn't card */
 	outb(0x55, iobase + PCL816_MUX);
 	comedi_udelay(1);
 	if (inb(iobase + PCL816_MUX) != 0x55)
-		return 1;	//there isn't card
+		return 1;	/* there isn't card */
 	outb(0x00, iobase + PCL816_MUX);
 	comedi_udelay(1);
 	outb(0x18, iobase + PCL816_CONTROL);
 	comedi_udelay(1);
 	if (inb(iobase + PCL816_CONTROL) != 0x18)
-		return 1;	//there isn't card
-	return 0;		// ok, card exist
+		return 1;	/* there isn't card */
+	return 0;		/*  ok, card exist */
 }
 
 /*
@@ -815,12 +815,12 @@ static int pcl816_check(unsigned long iobase)
 */
 static void pcl816_reset(struct comedi_device * dev)
 {
-//  outb (0, dev->iobase + PCL818_DA_LO);       // DAC=0V
-//  outb (0, dev->iobase + PCL818_DA_HI);
-//  comedi_udelay (1);
-//  outb (0, dev->iobase + PCL818_DO_HI);       // DO=$0000
-//  outb (0, dev->iobase + PCL818_DO_LO);
-//  comedi_udelay (1);
+/* outb (0, dev->iobase + PCL818_DA_LO);         DAC=0V */
+/* outb (0, dev->iobase + PCL818_DA_HI); */
+/* comedi_udelay (1); */
+/* outb (0, dev->iobase + PCL818_DO_HI);        DO=$0000 */
+/* outb (0, dev->iobase + PCL818_DO_LO); */
+/* comedi_udelay (1); */
 	outb(0, dev->iobase + PCL816_CONTROL);
 	outb(0, dev->iobase + PCL816_MUX);
 	outb(0, dev->iobase + PCL816_CLRINT);
@@ -842,8 +842,8 @@ start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
 	outb(0xff, dev->iobase + PCL816_CTR0);
 	outb(0x00, dev->iobase + PCL816_CTR0);
 	comedi_udelay(1);
-	outb(0xb4, dev->iobase + PCL816_CTRCTL);	// set counter 2 as mode 3
-	outb(0x74, dev->iobase + PCL816_CTRCTL);	// set counter 1 as mode 3
+	outb(0xb4, dev->iobase + PCL816_CTRCTL);	/*  set counter 2 as mode 3 */
+	outb(0x74, dev->iobase + PCL816_CTRCTL);	/*  set counter 1 as mode 3 */
 	comedi_udelay(1);
 
 	if (mode == 1) {
@@ -856,7 +856,7 @@ start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
 	}
 
 	/* clear pending interrupts (just in case) */
-//      outb(0, dev->iobase + PCL816_CLRINT);
+/* outb(0, dev->iobase + PCL816_CLRINT); */
 }
 
 /*
@@ -871,35 +871,35 @@ check_and_setup_channel_list(struct comedi_device * dev, struct comedi_subdevice
 	unsigned int chansegment[16];
 	unsigned int i, nowmustbechan, seglen, segpos;
 
-	// correct channel and range number check itself comedi/range.c
+	/*  correct channel and range number check itself comedi/range.c */
 	if (chanlen < 1) {
 		comedi_error(dev, "range/channel list is empty!");
 		return 0;
 	}
 
 	if (chanlen > 1) {
-		chansegment[0] = chanlist[0];	// first channel is everytime ok
+		chansegment[0] = chanlist[0];	/*  first channel is everytime ok */
 		for (i = 1, seglen = 1; i < chanlen; i++, seglen++) {
-			// build part of chanlist
+			/*  build part of chanlist */
 			DEBUG(rt_printk("%d. %d %d\n", i, CR_CHAN(chanlist[i]),
 					CR_RANGE(chanlist[i]));
 				)
 				if (chanlist[0] == chanlist[i])
-				break;	// we detect loop, this must by finish
+				break;	/*  we detect loop, this must by finish */
 			nowmustbechan =
 				(CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {
-				// channel list isn't continous :-(
+				/*  channel list isn't continous :-( */
 				rt_printk
 					("comedi%d: pcl816: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
 					dev->minor, i, CR_CHAN(chanlist[i]),
 					nowmustbechan, CR_CHAN(chanlist[0]));
 				return 0;
 			}
-			chansegment[i] = chanlist[i];	// well, this is next correct channel in list
+			chansegment[i] = chanlist[i];	/*  well, this is next correct channel in list */
 		}
 
-		for (i = 0, segpos = 0; i < chanlen; i++) {	// check whole chanlist
+		for (i = 0, segpos = 0; i < chanlen; i++) {	/*  check whole chanlist */
 			DEBUG(rt_printk("%d %d=%d %d\n",
 					CR_CHAN(chansegment[i % seglen]),
 					CR_RANGE(chansegment[i % seglen]),
@@ -915,7 +915,7 @@ check_and_setup_channel_list(struct comedi_device * dev, struct comedi_subdevice
 					CR_CHAN(chanlist[i % seglen]),
 					CR_RANGE(chanlist[i % seglen]),
 					CR_AREF(chansegment[i % seglen]));
-				return 0;	// chan/gain list is strange
+				return 0;	/*  chan/gain list is strange */
 			}
 		}
 	} else {
@@ -925,7 +925,7 @@ check_and_setup_channel_list(struct comedi_device * dev, struct comedi_subdevice
 	devpriv->ai_act_chanlist_len = seglen;
 	devpriv->ai_act_chanlist_pos = 0;
 
-	for (i = 0; i < seglen; i++) {	// store range list to card
+	for (i = 0; i < seglen; i++) {	/*  store range list to card */
 		devpriv->ai_act_chanlist[i] = CR_CHAN(chanlist[i]);
 		outb(CR_CHAN(chanlist[0]) & 0xf, dev->iobase + PCL816_MUX);
 		outb(CR_RANGE(chanlist[0]), dev->iobase + PCL816_RANGE);	/* select gain */
@@ -935,7 +935,7 @@ check_and_setup_channel_list(struct comedi_device * dev, struct comedi_subdevice
 
 	outb(devpriv->ai_act_chanlist[0] | (devpriv->ai_act_chanlist[seglen - 1] << 4), dev->iobase + PCL816_MUX);	/* select channel interval to scan */
 
-	return 1;		// we can serve this with MUX logic
+	return 1;		/*  we can serve this with MUX logic */
 }
 
 #ifdef unused
@@ -981,7 +981,7 @@ static int set_rtc_irq_bit(unsigned char bit)
 */
 static void free_resources(struct comedi_device * dev)
 {
-	//rt_printk("free_resource()\n");
+	/* rt_printk("free_resource()\n"); */
 	if (dev->private) {
 		pcl816_ai_cancel(dev, devpriv->sub_ai);
 		pcl816_reset(dev);
@@ -1006,7 +1006,7 @@ static void free_resources(struct comedi_device * dev)
 		free_irq(dev->irq, dev);
 	if (dev->iobase)
 		release_region(dev->iobase, this_board->io_range);
-	//rt_printk("free_resource() end\n");
+	/* rt_printk("free_resource() end\n"); */
 }
 
 /*
@@ -1021,7 +1021,7 @@ static int pcl816_attach(struct comedi_device * dev, struct comedi_devconfig * i
 	unsigned long iobase;
 	unsigned int irq, dma;
 	unsigned long pages;
-	//int i;
+	/* int i; */
 	struct comedi_subdevice *s;
 
 	/* claim our I/O space */
@@ -1084,7 +1084,7 @@ static int pcl816_attach(struct comedi_device * dev, struct comedi_devconfig * i
 #ifdef unused
 	/* grab RTC for DMA operations */
 	devpriv->dma_rtc = 0;
-	if (it->options[2] > 0) {	// we want to use DMA
+	if (it->options[2] > 0) {	/*  we want to use DMA */
 		if (RTC_lock == 0) {
 			if (!request_region(RTC_PORT(0), RTC_IO_EXTENT,
 					"pcl816 (RTC)"))
@@ -1152,9 +1152,9 @@ static int pcl816_attach(struct comedi_device * dev, struct comedi_devconfig * i
 		devpriv->dmapages[0] = pages;
 		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
 		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
-		//rt_printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE);
+		/* rt_printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
 
-		if (devpriv->dma_rtc == 0) {	// we must do duble buff :-(
+		if (devpriv->dma_rtc == 0) {	/*  we must do duble buff :-( */
 			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 			if (!devpriv->dmabuf[1]) {
 				rt_printk
@@ -1188,7 +1188,7 @@ static int pcl816_attach(struct comedi_device * dev, struct comedi_devconfig * i
 		s->subdev_flags = SDF_READABLE | SDF_CMD_READ;
 		s->n_chan = this_board->n_aichan;
 		s->subdev_flags |= SDF_DIFF;
-		//printk (", %dchans DIFF DAC - %d", s->n_chan, i);
+		/* printk (", %dchans DIFF DAC - %d", s->n_chan, i); */
 		s->maxdata = this_board->ai_maxdata;
 		s->len_chanlist = this_board->ai_chanlist;
 		s->range_table = this_board->ai_range_type;

commit 1c7f40d91b99e73ae11056708225058afd0278d7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:17:11 2009 -0400

    Staging: comedi: pcl816: Remove boardtype typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 6ed19e21c9a4..515ba74cc7fe 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -101,7 +101,8 @@ static const struct comedi_lrange range_pcl816 = { 8, {
 			UNI_RANGE(1.25),
 	}
 };
-typedef struct {
+struct pcl816_board {
+
 	const char *name;	// board name
 	int n_ranges;		// len of range list
 	int n_aichan;		// num of A/D chans in diferencial mode
@@ -119,9 +120,10 @@ typedef struct {
 	int ai_chanlist;	// allowed len of channel list A/D
 	int ao_chanlist;	// allowed len of channel list D/A
 	int i8254_osc_base;	// 1/frequency of on board oscilator in ns
-} boardtype;
+};
+
 
-static const boardtype boardtypes[] = {
+static const struct pcl816_board boardtypes[] = {
 	{"pcl816", 8, 16, 10000, 1, 16, 16, &range_pcl816,
 			&range_pcl816, PCLx1x_RANGE,
 			0x00fc,	// IRQ mask
@@ -142,9 +144,9 @@ static const boardtype boardtypes[] = {
 		100},
 };
 
-#define n_boardtypes (sizeof(boardtypes)/sizeof(boardtype))
+#define n_boardtypes (sizeof(boardtypes)/sizeof(struct pcl816_board))
 #define devpriv ((struct pcl816_private *)dev->private)
-#define this_board ((const boardtype *)dev->board_ptr)
+#define this_board ((const struct pcl816_board *)dev->board_ptr)
 
 static int pcl816_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int pcl816_detach(struct comedi_device * dev);
@@ -161,7 +163,7 @@ static struct comedi_driver driver_pcl816 = {
       detach:pcl816_detach,
       board_name:&boardtypes[0].name,
       num_names:n_boardtypes,
-      offset:sizeof(boardtype),
+      offset:sizeof(struct pcl816_board),
 };
 
 COMEDI_INITCLEANUP(driver_pcl816);

commit fe0ff175329a83de8f9aac7c0b759cde15cb2247
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:18:43 2009 -0400

    Staging: comedi: Remove pcl816_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 1d1137f602a0..6ed19e21c9a4 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -143,7 +143,7 @@ static const boardtype boardtypes[] = {
 };
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(boardtype))
-#define devpriv ((pcl816_private *)dev->private)
+#define devpriv ((struct pcl816_private *)dev->private)
 #define this_board ((const boardtype *)dev->board_ptr)
 
 static int pcl816_attach(struct comedi_device * dev, struct comedi_devconfig * it);
@@ -166,7 +166,8 @@ static struct comedi_driver driver_pcl816 = {
 
 COMEDI_INITCLEANUP(driver_pcl816);
 
-typedef struct {
+struct pcl816_private {
+
 	unsigned int dma;	// used DMA, 0=don't use DMA
 	int dma_rtc;		// 1=RTC used with DMA, 0=no RTC alloc
 #ifdef unused
@@ -204,7 +205,8 @@ typedef struct {
 	struct timer_list rtc_irq_timer;	// timer for RTC sanity check
 	unsigned long rtc_freq;	// RTC int freq
 #endif
-} pcl816_private;
+};
+
 
 /*
 ==============================================================================
@@ -1037,7 +1039,7 @@ static int pcl816_attach(struct comedi_device * dev, struct comedi_devconfig * i
 		return -EIO;
 	}
 
-	if ((ret = alloc_private(dev, sizeof(pcl816_private))) < 0)
+	if ((ret = alloc_private(dev, sizeof(struct pcl816_private))) < 0)
 		return ret;	/* Can't alloc mem */
 
 	/* set up some name stuff */

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 9542d0e8e5fb..1d1137f602a0 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -146,7 +146,7 @@ static const boardtype boardtypes[] = {
 #define devpriv ((pcl816_private *)dev->private)
 #define this_board ((const boardtype *)dev->board_ptr)
 
-static int pcl816_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pcl816_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int pcl816_detach(struct comedi_device * dev);
 
 #ifdef unused
@@ -1011,7 +1011,7 @@ static void free_resources(struct comedi_device * dev)
    Initialization
 
 */
-static int pcl816_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int pcl816_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	int ret;
 	unsigned long iobase;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 60d7a2c1d190..9542d0e8e5fb 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -227,7 +227,7 @@ static int pcl816_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s
    ANALOG INPUT MODE0, 816 cards, slow version
 */
 static int pcl816_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	int timeout;

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index d90e2e584f63..60d7a2c1d190 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -219,7 +219,7 @@ static int set_rtc_irq_bit(unsigned char bit);
 #endif
 
 static int pcl816_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int pcl816_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 
 /*
@@ -443,7 +443,7 @@ static irqreturn_t interrupt_pcl816(int irq, void *d PT_REGS_ARG)
 ==============================================================================
    COMMAND MODE
 */
-static void pcl816_cmdtest_out(int e, comedi_cmd * cmd)
+static void pcl816_cmdtest_out(int e, struct comedi_cmd * cmd)
 {
 	rt_printk("pcl816 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
 		cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
@@ -459,7 +459,7 @@ static void pcl816_cmdtest_out(int e, comedi_cmd * cmd)
 ==============================================================================
 */
 static int pcl816_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
@@ -596,7 +596,7 @@ static int pcl816_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 static int pcl816_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned int divisor1 = 0, divisor2 = 0, dma_flags, bytes, dmairq;
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
 	if (cmd->start_src != TRIG_NOW)
 		return -EINVAL;

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index c5a969898c12..d90e2e584f63 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -90,7 +90,7 @@ Configuration Options:
 
 #define MAGIC_DMA_WORD 0x5a5a
 
-static const comedi_lrange range_pcl816 = { 8, {
+static const struct comedi_lrange range_pcl816 = { 8, {
 			BIP_RANGE(10),
 			BIP_RANGE(5),
 			BIP_RANGE(2.5),
@@ -109,8 +109,8 @@ typedef struct {
 	int n_aochan;		// num of D/A chans
 	int n_dichan;		// num of DI chans
 	int n_dochan;		// num of DO chans
-	const comedi_lrange *ai_range_type;	// default A/D rangelist
-	const comedi_lrange *ao_range_type;	// dafault D/A rangelist
+	const struct comedi_lrange *ai_range_type;	// default A/D rangelist
+	const struct comedi_lrange *ao_range_type;	// dafault D/A rangelist
 	unsigned int io_range;	// len of IO space
 	unsigned int IRQbits;	// allowed interrupts
 	unsigned int DMAbits;	// allowed DMA chans

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index f1282c68d7ef..c5a969898c12 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -154,7 +154,7 @@ static int RTC_lock = 0;	/* RTC lock */
 static int RTC_timer_lock = 0;	/* RTC int lock */
 #endif
 
-static comedi_driver driver_pcl816 = {
+static struct comedi_driver driver_pcl816 = {
       driver_name:"pcl816",
       module:THIS_MODULE,
       attach:pcl816_attach,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index 5d8509f45a08..f1282c68d7ef 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -193,13 +193,13 @@ typedef struct {
 #endif
 	int irq_was_now_closed;	// when IRQ finish, there's stored int816_mode for last interrupt
 	int int816_mode;	// who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma
-	comedi_subdevice *last_int_sub;	// ptr to subdevice which now finish
+	struct comedi_subdevice *last_int_sub;	// ptr to subdevice which now finish
 	int ai_act_scan;	// how many scans we finished
 	unsigned int ai_act_chanlist[16];	// MUX setting for actual AI operations
 	unsigned int ai_act_chanlist_len;	// how long is actual MUX list
 	unsigned int ai_act_chanlist_pos;	// actual position in MUX list
 	unsigned int ai_poll_ptr;	// how many sampes transfer poll
-	comedi_subdevice *sub_ai;	// ptr to AI subdevice
+	struct comedi_subdevice *sub_ai;	// ptr to AI subdevice
 #ifdef unused
 	struct timer_list rtc_irq_timer;	// timer for RTC sanity check
 	unsigned long rtc_freq;	// RTC int freq
@@ -210,23 +210,23 @@ typedef struct {
 ==============================================================================
 */
 static int check_and_setup_channel_list(struct comedi_device * dev,
-	comedi_subdevice * s, unsigned int *chanlist, int chanlen);
-static int pcl816_ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
+	struct comedi_subdevice * s, unsigned int *chanlist, int chanlen);
+static int pcl816_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static void start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
 	unsigned int divisor2);
 #ifdef unused
 static int set_rtc_irq_bit(unsigned char bit);
 #endif
 
-static int pcl816_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int pcl816_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int pcl816_ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int pcl816_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 
 /*
 ==============================================================================
    ANALOG INPUT MODE0, 816 cards, slow version
 */
-static int pcl816_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int pcl816_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;
@@ -281,7 +281,7 @@ static int pcl816_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	comedi_subdevice *s = dev->subdevices + 0;
+	struct comedi_subdevice *s = dev->subdevices + 0;
 	int low, hi;
 	int timeout = 50;	/* wait max 50us */
 
@@ -330,7 +330,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 ==============================================================================
    analog input dma mode 1 & 3, 816 cards
 */
-static void transfer_from_dma_buf(struct comedi_device * dev, comedi_subdevice * s,
+static void transfer_from_dma_buf(struct comedi_device * dev, struct comedi_subdevice * s,
 	short * ptr, unsigned int bufptr, unsigned int len)
 {
 	int i;
@@ -362,7 +362,7 @@ static void transfer_from_dma_buf(struct comedi_device * dev, comedi_subdevice *
 static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	comedi_subdevice *s = dev->subdevices + 0;
+	struct comedi_subdevice *s = dev->subdevices + 0;
 	int len, bufptr, this_dma_buf;
 	unsigned long dma_flags;
 	short *ptr;
@@ -458,7 +458,7 @@ static void pcl816_cmdtest_out(int e, comedi_cmd * cmd)
 /*
 ==============================================================================
 */
-static int pcl816_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int pcl816_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -593,7 +593,7 @@ static int pcl816_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int pcl816_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int pcl816_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned int divisor1 = 0, divisor2 = 0, dma_flags, bytes, dmairq;
 	comedi_cmd *cmd = &s->async->cmd;
@@ -698,7 +698,7 @@ static int pcl816_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int pcl816_ai_poll(struct comedi_device * dev, comedi_subdevice * s)
+static int pcl816_ai_poll(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long flags;
 	unsigned int top1, top2, i;
@@ -741,7 +741,7 @@ static int pcl816_ai_poll(struct comedi_device * dev, comedi_subdevice * s)
 ==============================================================================
  cancel any mode 1-4 AI
 */
-static int pcl816_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int pcl816_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 //  DEBUG(rt_printk("pcl816_ai_cancel()\n");)
 
@@ -861,7 +861,7 @@ start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
  If it's ok, then program scan/gain logic
 */
 static int
-check_and_setup_channel_list(struct comedi_device * dev, comedi_subdevice * s,
+check_and_setup_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int *chanlist, int chanlen)
 {
 	unsigned int chansegment[16];
@@ -1018,7 +1018,7 @@ static int pcl816_attach(struct comedi_device * dev, comedi_devconfig * it)
 	unsigned int irq, dma;
 	unsigned long pages;
 	//int i;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	/* claim our I/O space */
 	iobase = it->options[0];

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index cb795736300d..5d8509f45a08 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -146,8 +146,8 @@ static const boardtype boardtypes[] = {
 #define devpriv ((pcl816_private *)dev->private)
 #define this_board ((const boardtype *)dev->board_ptr)
 
-static int pcl816_attach(comedi_device * dev, comedi_devconfig * it);
-static int pcl816_detach(comedi_device * dev);
+static int pcl816_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pcl816_detach(struct comedi_device * dev);
 
 #ifdef unused
 static int RTC_lock = 0;	/* RTC lock */
@@ -209,24 +209,24 @@ typedef struct {
 /*
 ==============================================================================
 */
-static int check_and_setup_channel_list(comedi_device * dev,
+static int check_and_setup_channel_list(struct comedi_device * dev,
 	comedi_subdevice * s, unsigned int *chanlist, int chanlen);
-static int pcl816_ai_cancel(comedi_device * dev, comedi_subdevice * s);
-static void start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
+static int pcl816_ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static void start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
 	unsigned int divisor2);
 #ifdef unused
 static int set_rtc_irq_bit(unsigned char bit);
 #endif
 
-static int pcl816_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int pcl816_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int pcl816_ai_cmd(comedi_device * dev, comedi_subdevice * s);
+static int pcl816_ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
 
 /*
 ==============================================================================
    ANALOG INPUT MODE0, 816 cards, slow version
 */
-static int pcl816_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int pcl816_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;
@@ -280,7 +280,7 @@ static int pcl816_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
 */
 static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	comedi_subdevice *s = dev->subdevices + 0;
 	int low, hi;
 	int timeout = 50;	/* wait max 50us */
@@ -330,7 +330,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
 ==============================================================================
    analog input dma mode 1 & 3, 816 cards
 */
-static void transfer_from_dma_buf(comedi_device * dev, comedi_subdevice * s,
+static void transfer_from_dma_buf(struct comedi_device * dev, comedi_subdevice * s,
 	short * ptr, unsigned int bufptr, unsigned int len)
 {
 	int i;
@@ -361,7 +361,7 @@ static void transfer_from_dma_buf(comedi_device * dev, comedi_subdevice * s,
 
 static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	comedi_subdevice *s = dev->subdevices + 0;
 	int len, bufptr, this_dma_buf;
 	unsigned long dma_flags;
@@ -407,7 +407,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 */
 static irqreturn_t interrupt_pcl816(int irq, void *d PT_REGS_ARG)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	DPRINTK("<I>");
 
 	if (!dev->attached) {
@@ -458,7 +458,7 @@ static void pcl816_cmdtest_out(int e, comedi_cmd * cmd)
 /*
 ==============================================================================
 */
-static int pcl816_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int pcl816_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -593,7 +593,7 @@ static int pcl816_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int pcl816_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int pcl816_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned int divisor1 = 0, divisor2 = 0, dma_flags, bytes, dmairq;
 	comedi_cmd *cmd = &s->async->cmd;
@@ -698,7 +698,7 @@ static int pcl816_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int pcl816_ai_poll(comedi_device * dev, comedi_subdevice * s)
+static int pcl816_ai_poll(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long flags;
 	unsigned int top1, top2, i;
@@ -741,7 +741,7 @@ static int pcl816_ai_poll(comedi_device * dev, comedi_subdevice * s)
 ==============================================================================
  cancel any mode 1-4 AI
 */
-static int pcl816_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+static int pcl816_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 //  DEBUG(rt_printk("pcl816_ai_cancel()\n");)
 
@@ -809,7 +809,7 @@ static int pcl816_check(unsigned long iobase)
 ==============================================================================
  reset whole PCL-816 cards
 */
-static void pcl816_reset(comedi_device * dev)
+static void pcl816_reset(struct comedi_device * dev)
 {
 //  outb (0, dev->iobase + PCL818_DA_LO);       // DAC=0V
 //  outb (0, dev->iobase + PCL818_DA_HI);
@@ -831,7 +831,7 @@ static void pcl816_reset(comedi_device * dev)
  Start/stop pacer onboard pacer
 */
 static void
-start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
+start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
 	unsigned int divisor2)
 {
 	outb(0x32, dev->iobase + PCL816_CTRCTL);
@@ -861,7 +861,7 @@ start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
  If it's ok, then program scan/gain logic
 */
 static int
-check_and_setup_channel_list(comedi_device * dev, comedi_subdevice * s,
+check_and_setup_channel_list(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int *chanlist, int chanlen)
 {
 	unsigned int chansegment[16];
@@ -975,7 +975,7 @@ static int set_rtc_irq_bit(unsigned char bit)
 ==============================================================================
   Free any resources that we have claimed
 */
-static void free_resources(comedi_device * dev)
+static void free_resources(struct comedi_device * dev)
 {
 	//rt_printk("free_resource()\n");
 	if (dev->private) {
@@ -1011,7 +1011,7 @@ static void free_resources(comedi_device * dev)
    Initialization
 
 */
-static int pcl816_attach(comedi_device * dev, comedi_devconfig * it)
+static int pcl816_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	int ret;
 	unsigned long iobase;
@@ -1234,7 +1234,7 @@ case COMEDI_SUBD_DO:
 ==============================================================================
   Removes device
  */
-static int pcl816_detach(comedi_device * dev)
+static int pcl816_detach(struct comedi_device * dev)
 {
 	DEBUG(rt_printk("comedi%d: pcl816: remove\n", dev->minor);
 		)

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index e361f9dc5246..cb795736300d 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -227,7 +227,7 @@ static int pcl816_ai_cmd(comedi_device * dev, comedi_subdevice * s);
    ANALOG INPUT MODE0, 816 cards, slow version
 */
 static int pcl816_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	int timeout;
@@ -331,7 +331,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
    analog input dma mode 1 & 3, 816 cards
 */
 static void transfer_from_dma_buf(comedi_device * dev, comedi_subdevice * s,
-	sampl_t * ptr, unsigned int bufptr, unsigned int len)
+	short * ptr, unsigned int bufptr, unsigned int len)
 {
 	int i;
 
@@ -365,7 +365,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 	comedi_subdevice *s = dev->subdevices + 0;
 	int len, bufptr, this_dma_buf;
 	unsigned long dma_flags;
-	sampl_t *ptr;
+	short *ptr;
 
 	disable_dma(devpriv->dma);
 	this_dma_buf = devpriv->next_dma_buf;
@@ -391,7 +391,7 @@ static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
 	devpriv->dma_runs_to_end--;
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
 
-	ptr = (sampl_t *) devpriv->dmabuf[this_dma_buf];
+	ptr = (short *) devpriv->dmabuf[this_dma_buf];
 
 	len = (devpriv->hwdmasize[0] >> 1) - devpriv->ai_poll_ptr;
 	bufptr = devpriv->ai_poll_ptr;
@@ -658,7 +658,7 @@ static int pcl816_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 	if (devpriv->dma) {
 		bytes = devpriv->hwdmasize[0];
 		if (!devpriv->ai_neverending) {
-			bytes = s->async->cmd.chanlist_len * s->async->cmd.chanlist_len * sizeof(sampl_t);	// how many
+			bytes = s->async->cmd.chanlist_len * s->async->cmd.chanlist_len * sizeof(short);	// how many
 			devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize[0];	// how many DMA pages we must fill
 			devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];	//on last dma transfer must be moved
 			devpriv->dma_runs_to_end--;
@@ -728,7 +728,7 @@ static int pcl816_ai_poll(comedi_device * dev, comedi_subdevice * s)
 	}
 
 	transfer_from_dma_buf(dev, s,
-		(sampl_t *) devpriv->dmabuf[devpriv->next_dma_buf],
+		(short *) devpriv->dmabuf[devpriv->next_dma_buf],
 		devpriv->ai_poll_ptr, top2);
 
 	devpriv->ai_poll_ptr = top1;	// new buffer position

commit dd2996b38be848c5f19a5e92a9be84069f09ebd3
Author: Juan Grigera <juan@grigera.com.ar>
Date:   Thu Feb 19 09:30:57 2009 -0800

    Staging: comedi: add pcl816 driver
    
    Driver for Advantech PCL-816 and PCL-814
    
    From: Juan Grigera <juan@grigera.com.ar>
    Cc: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
new file mode 100644
index 000000000000..e361f9dc5246
--- /dev/null
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -0,0 +1,1247 @@
+/*
+   comedi/drivers/pcl816.c
+
+   Author:  Juan Grigera <juan@grigera.com.ar>
+            based on pcl818 by Michal Dobes <dobes@tesnet.cz> and bits of pcl812
+
+   hardware driver for Advantech cards:
+    card:   PCL-816, PCL814B
+    driver: pcl816
+*/
+/*
+Driver: pcl816
+Description: Advantech PCL-816 cards, PCL-814
+Author: Juan Grigera <juan@grigera.com.ar>
+Devices: [Advantech] PCL-816 (pcl816), PCL-814B (pcl814b)
+Status: works
+Updated: Tue,  2 Apr 2002 23:15:21 -0800
+
+PCL 816 and 814B have 16 SE/DIFF ADCs, 16 DACs, 16 DI and 16 DO.
+Differences are at resolution (16 vs 12 bits).
+
+The driver support AI command mode, other subdevices not written.
+
+Analog output and digital input and output are not supported.
+
+Configuration Options:
+  [0] - IO Base
+  [1] - IRQ	(0=disable, 2, 3, 4, 5, 6, 7)
+  [2] - DMA	(0=disable, 1, 3)
+  [3] - 0, 10=10MHz clock for 8254
+            1= 1MHz clock for 8254
+
+*/
+
+#include "../comedidev.h"
+
+#include <linux/ioport.h>
+#include <linux/mc146818rtc.h>
+#include <linux/delay.h>
+#include <asm/dma.h>
+
+#include "8253.h"
+
+#define DEBUG(x) x
+
+// boards constants
+// IO space len
+#define PCLx1x_RANGE 16
+
+//#define outb(x,y)  printk("OUTB(%x, 200+%d)\n", x,y-0x200); outb(x,y)
+
+// INTEL 8254 counters
+#define PCL816_CTR0 4
+#define PCL816_CTR1 5
+#define PCL816_CTR2 6
+// R: counter read-back register W: counter control
+#define PCL816_CTRCTL 7
+
+// R: A/D high byte W: A/D range control
+#define PCL816_RANGE 9
+// W: clear INT request
+#define PCL816_CLRINT 10
+// R: next mux scan channel W: mux scan channel & range control pointer
+#define PCL816_MUX 11
+// R/W: operation control register
+#define PCL816_CONTROL 12
+
+// R: return status byte  W: set DMA/IRQ
+#define PCL816_STATUS 13
+#define PCL816_STATUS_DRDY_MASK 0x80
+
+// R: low byte of A/D W: soft A/D trigger
+#define PCL816_AD_LO 8
+// R: high byte of A/D W: A/D range control
+#define PCL816_AD_HI 9
+
+// type of interrupt handler
+#define INT_TYPE_AI1_INT 1
+#define INT_TYPE_AI1_DMA 2
+#define INT_TYPE_AI3_INT 4
+#define INT_TYPE_AI3_DMA 5
+#ifdef unused
+#define INT_TYPE_AI1_DMA_RTC 9
+#define INT_TYPE_AI3_DMA_RTC 10
+
+// RTC stuff...
+#define RTC_IRQ 	8
+#define RTC_IO_EXTENT	0x10
+#endif
+
+#define MAGIC_DMA_WORD 0x5a5a
+
+static const comedi_lrange range_pcl816 = { 8, {
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25),
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2.5),
+			UNI_RANGE(1.25),
+	}
+};
+typedef struct {
+	const char *name;	// board name
+	int n_ranges;		// len of range list
+	int n_aichan;		// num of A/D chans in diferencial mode
+	unsigned int ai_ns_min;	// minimal alllowed delay between samples (in ns)
+	int n_aochan;		// num of D/A chans
+	int n_dichan;		// num of DI chans
+	int n_dochan;		// num of DO chans
+	const comedi_lrange *ai_range_type;	// default A/D rangelist
+	const comedi_lrange *ao_range_type;	// dafault D/A rangelist
+	unsigned int io_range;	// len of IO space
+	unsigned int IRQbits;	// allowed interrupts
+	unsigned int DMAbits;	// allowed DMA chans
+	int ai_maxdata;		// maxdata for A/D
+	int ao_maxdata;		// maxdata for D/A
+	int ai_chanlist;	// allowed len of channel list A/D
+	int ao_chanlist;	// allowed len of channel list D/A
+	int i8254_osc_base;	// 1/frequency of on board oscilator in ns
+} boardtype;
+
+static const boardtype boardtypes[] = {
+	{"pcl816", 8, 16, 10000, 1, 16, 16, &range_pcl816,
+			&range_pcl816, PCLx1x_RANGE,
+			0x00fc,	// IRQ mask
+			0x0a,	// DMA mask
+			0xffff,	// 16-bit card
+			0xffff,	// D/A maxdata
+			1024,
+			1,	// ao chan list
+		100},
+	{"pcl814b", 8, 16, 10000, 1, 16, 16, &range_pcl816,
+			&range_pcl816, PCLx1x_RANGE,
+			0x00fc,
+			0x0a,
+			0x3fff,	/* 14 bit card */
+			0x3fff,
+			1024,
+			1,
+		100},
+};
+
+#define n_boardtypes (sizeof(boardtypes)/sizeof(boardtype))
+#define devpriv ((pcl816_private *)dev->private)
+#define this_board ((const boardtype *)dev->board_ptr)
+
+static int pcl816_attach(comedi_device * dev, comedi_devconfig * it);
+static int pcl816_detach(comedi_device * dev);
+
+#ifdef unused
+static int RTC_lock = 0;	/* RTC lock */
+static int RTC_timer_lock = 0;	/* RTC int lock */
+#endif
+
+static comedi_driver driver_pcl816 = {
+      driver_name:"pcl816",
+      module:THIS_MODULE,
+      attach:pcl816_attach,
+      detach:pcl816_detach,
+      board_name:&boardtypes[0].name,
+      num_names:n_boardtypes,
+      offset:sizeof(boardtype),
+};
+
+COMEDI_INITCLEANUP(driver_pcl816);
+
+typedef struct {
+	unsigned int dma;	// used DMA, 0=don't use DMA
+	int dma_rtc;		// 1=RTC used with DMA, 0=no RTC alloc
+#ifdef unused
+	unsigned long rtc_iobase;	// RTC port region
+	unsigned int rtc_iosize;
+	unsigned int rtc_irq;
+#endif
+	unsigned long dmabuf[2];	// pointers to begin of DMA buffers
+	unsigned int dmapages[2];	// len of DMA buffers in PAGE_SIZEs
+	unsigned int hwdmaptr[2];	// hardware address of DMA buffers
+	unsigned int hwdmasize[2];	// len of DMA buffers in Bytes
+	unsigned int dmasamplsize;	// size in samples hwdmasize[0]/2
+	unsigned int last_top_dma;	// DMA pointer in last RTC int
+	int next_dma_buf;	// which DMA buffer will be used next round
+	long dma_runs_to_end;	// how many we must permorm DMA transfer to end of record
+	unsigned long last_dma_run;	// how many bytes we must transfer on last DMA page
+
+	unsigned int ai_scans;	// len of scanlist
+	unsigned char ai_neverending;	// if=1, then we do neverending record (you must use cancel())
+	int irq_free;		// 1=have allocated IRQ
+	int irq_blocked;	// 1=IRQ now uses any subdev
+#ifdef unused
+	int rtc_irq_blocked;	// 1=we now do AI with DMA&RTC
+#endif
+	int irq_was_now_closed;	// when IRQ finish, there's stored int816_mode for last interrupt
+	int int816_mode;	// who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma
+	comedi_subdevice *last_int_sub;	// ptr to subdevice which now finish
+	int ai_act_scan;	// how many scans we finished
+	unsigned int ai_act_chanlist[16];	// MUX setting for actual AI operations
+	unsigned int ai_act_chanlist_len;	// how long is actual MUX list
+	unsigned int ai_act_chanlist_pos;	// actual position in MUX list
+	unsigned int ai_poll_ptr;	// how many sampes transfer poll
+	comedi_subdevice *sub_ai;	// ptr to AI subdevice
+#ifdef unused
+	struct timer_list rtc_irq_timer;	// timer for RTC sanity check
+	unsigned long rtc_freq;	// RTC int freq
+#endif
+} pcl816_private;
+
+/*
+==============================================================================
+*/
+static int check_and_setup_channel_list(comedi_device * dev,
+	comedi_subdevice * s, unsigned int *chanlist, int chanlen);
+static int pcl816_ai_cancel(comedi_device * dev, comedi_subdevice * s);
+static void start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
+	unsigned int divisor2);
+#ifdef unused
+static int set_rtc_irq_bit(unsigned char bit);
+#endif
+
+static int pcl816_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int pcl816_ai_cmd(comedi_device * dev, comedi_subdevice * s);
+
+/*
+==============================================================================
+   ANALOG INPUT MODE0, 816 cards, slow version
+*/
+static int pcl816_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n;
+	int timeout;
+
+	DPRINTK("mode 0 analog input\n");
+	// software trigger, DMA and INT off
+	outb(0, dev->iobase + PCL816_CONTROL);
+	// clear INT (conversion end) flag
+	outb(0, dev->iobase + PCL816_CLRINT);
+
+	// Set the input channel
+	outb(CR_CHAN(insn->chanspec) & 0xf, dev->iobase + PCL816_MUX);
+	outb(CR_RANGE(insn->chanspec), dev->iobase + PCL816_RANGE);	/* select gain */
+
+	for (n = 0; n < insn->n; n++) {
+
+		outb(0, dev->iobase + PCL816_AD_LO);	/* start conversion */
+
+		timeout = 100;
+		while (timeout--) {
+			if (!(inb(dev->iobase + PCL816_STATUS) &
+					PCL816_STATUS_DRDY_MASK)) {
+				// return read value
+				data[n] =
+					((inb(dev->iobase +
+							PCL816_AD_HI) << 8) |
+					(inb(dev->iobase + PCL816_AD_LO)));
+
+				outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT (conversion end) flag */
+				break;
+			}
+			comedi_udelay(1);
+		}
+		// Return timeout error
+		if (!timeout) {
+			comedi_error(dev, "A/D insn timeout\n");
+			data[0] = 0;
+			outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT (conversion end) flag */
+			return -EIO;
+		}
+
+	}
+	return n;
+}
+
+/*
+==============================================================================
+   analog input interrupt mode 1 & 3, 818 cards
+   one sample per interrupt version
+*/
+static irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)
+{
+	comedi_device *dev = d;
+	comedi_subdevice *s = dev->subdevices + 0;
+	int low, hi;
+	int timeout = 50;	/* wait max 50us */
+
+	while (timeout--) {
+		if (!(inb(dev->iobase + PCL816_STATUS) &
+				PCL816_STATUS_DRDY_MASK))
+			break;
+		comedi_udelay(1);
+	}
+	if (!timeout) {		// timeout, bail error
+		outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
+		comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
+		pcl816_ai_cancel(dev, s);
+		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		comedi_event(dev, s);
+		return IRQ_HANDLED;
+
+	}
+
+	// get the sample
+	low = inb(dev->iobase + PCL816_AD_LO);
+	hi = inb(dev->iobase + PCL816_AD_HI);
+
+	comedi_buf_put(s->async, (hi << 8) | low);
+
+	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
+
+	if (++devpriv->ai_act_chanlist_pos >= devpriv->ai_act_chanlist_len)
+		devpriv->ai_act_chanlist_pos = 0;
+
+	if (s->async->cur_chan == 0) {
+		devpriv->ai_act_scan++;
+	}
+
+	if (!devpriv->ai_neverending)
+		if (devpriv->ai_act_scan >= devpriv->ai_scans) {	/* all data sampled */
+			/* all data sampled */
+			pcl816_ai_cancel(dev, s);
+			s->async->events |= COMEDI_CB_EOA;
+		}
+	comedi_event(dev, s);
+	return IRQ_HANDLED;
+}
+
+/*
+==============================================================================
+   analog input dma mode 1 & 3, 816 cards
+*/
+static void transfer_from_dma_buf(comedi_device * dev, comedi_subdevice * s,
+	sampl_t * ptr, unsigned int bufptr, unsigned int len)
+{
+	int i;
+
+	s->async->events = 0;
+
+	for (i = 0; i < len; i++) {
+
+		comedi_buf_put(s->async, ptr[bufptr++]);
+
+		if (++devpriv->ai_act_chanlist_pos >=
+			devpriv->ai_act_chanlist_len) {
+			devpriv->ai_act_chanlist_pos = 0;
+			devpriv->ai_act_scan++;
+		}
+
+		if (!devpriv->ai_neverending)
+			if (devpriv->ai_act_scan >= devpriv->ai_scans) {	// all data sampled
+				pcl816_ai_cancel(dev, s);
+				s->async->events |= COMEDI_CB_EOA;
+				s->async->events |= COMEDI_CB_BLOCK;
+				break;
+			}
+	}
+
+	comedi_event(dev, s);
+}
+
+static irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)
+{
+	comedi_device *dev = d;
+	comedi_subdevice *s = dev->subdevices + 0;
+	int len, bufptr, this_dma_buf;
+	unsigned long dma_flags;
+	sampl_t *ptr;
+
+	disable_dma(devpriv->dma);
+	this_dma_buf = devpriv->next_dma_buf;
+
+	if ((devpriv->dma_runs_to_end > -1) || devpriv->ai_neverending) {	// switch dma bufs
+
+		devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
+		set_dma_mode(devpriv->dma, DMA_MODE_READ);
+		dma_flags = claim_dma_lock();
+//  clear_dma_ff (devpriv->dma);
+		set_dma_addr(devpriv->dma,
+			devpriv->hwdmaptr[devpriv->next_dma_buf]);
+		if (devpriv->dma_runs_to_end) {
+			set_dma_count(devpriv->dma,
+				devpriv->hwdmasize[devpriv->next_dma_buf]);
+		} else {
+			set_dma_count(devpriv->dma, devpriv->last_dma_run);
+		}
+		release_dma_lock(dma_flags);
+		enable_dma(devpriv->dma);
+	}
+
+	devpriv->dma_runs_to_end--;
+	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
+
+	ptr = (sampl_t *) devpriv->dmabuf[this_dma_buf];
+
+	len = (devpriv->hwdmasize[0] >> 1) - devpriv->ai_poll_ptr;
+	bufptr = devpriv->ai_poll_ptr;
+	devpriv->ai_poll_ptr = 0;
+
+	transfer_from_dma_buf(dev, s, ptr, bufptr, len);
+	return IRQ_HANDLED;
+}
+
+/*
+==============================================================================
+    INT procedure
+*/
+static irqreturn_t interrupt_pcl816(int irq, void *d PT_REGS_ARG)
+{
+	comedi_device *dev = d;
+	DPRINTK("<I>");
+
+	if (!dev->attached) {
+		comedi_error(dev, "premature interrupt");
+		return IRQ_HANDLED;
+	}
+
+	switch (devpriv->int816_mode) {
+	case INT_TYPE_AI1_DMA:
+	case INT_TYPE_AI3_DMA:
+		return interrupt_pcl816_ai_mode13_dma(irq, d);
+	case INT_TYPE_AI1_INT:
+	case INT_TYPE_AI3_INT:
+		return interrupt_pcl816_ai_mode13_int(irq, d);
+	}
+
+	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
+	if ((!dev->irq) | (!devpriv->irq_free) | (!devpriv->irq_blocked) |
+		(!devpriv->int816_mode)) {
+		if (devpriv->irq_was_now_closed) {
+			devpriv->irq_was_now_closed = 0;
+			// comedi_error(dev,"last IRQ..");
+			return IRQ_HANDLED;
+		}
+		comedi_error(dev, "bad IRQ!");
+		return IRQ_NONE;
+	}
+	comedi_error(dev, "IRQ from unknow source!");
+	return IRQ_NONE;
+}
+
+/*
+==============================================================================
+   COMMAND MODE
+*/
+static void pcl816_cmdtest_out(int e, comedi_cmd * cmd)
+{
+	rt_printk("pcl816 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
+		cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
+	rt_printk("pcl816 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
+		cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
+	rt_printk("pcl816 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
+		cmd->scan_end_src);
+	rt_printk("pcl816 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n", e,
+		cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
+}
+
+/*
+==============================================================================
+*/
+static int pcl816_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp, divisor1, divisor2;
+
+	DEBUG(rt_printk("pcl816 pcl812_ai_cmdtest\n");
+		pcl816_cmdtest_out(-1, cmd););
+
+	/* step 1: make sure trigger sources are trivially valid */
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_FOLLOW;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	if (!cmd->convert_src & (TRIG_EXT | TRIG_TIMER))
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err) {
+		return 1;
+	}
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	if (cmd->start_src != TRIG_NOW) {
+		cmd->start_src = TRIG_NOW;
+		err++;
+	}
+
+	if (cmd->scan_begin_src != TRIG_FOLLOW) {
+		cmd->scan_begin_src = TRIG_FOLLOW;
+		err++;
+	}
+
+	if (cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_TIMER) {
+		cmd->convert_src = TRIG_TIMER;
+		err++;
+	}
+
+	if (cmd->scan_end_src != TRIG_COUNT) {
+		cmd->scan_end_src = TRIG_COUNT;
+		err++;
+	}
+
+	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
+		err++;
+
+	if (err) {
+		return 2;
+	}
+
+	/* step 3: make sure arguments are trivially compatible */
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	if (cmd->scan_begin_arg != 0) {
+		cmd->scan_begin_arg = 0;
+		err++;
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg < this_board->ai_ns_min) {
+			cmd->convert_arg = this_board->ai_ns_min;
+			err++;
+		}
+	} else {		/* TRIG_EXT */
+		if (cmd->convert_arg != 0) {
+			cmd->convert_arg = 0;
+			err++;
+		}
+	}
+
+	if (!cmd->chanlist_len) {
+		cmd->chanlist_len = 1;
+		err++;
+	}
+	if (cmd->chanlist_len > this_board->n_aichan) {
+		cmd->chanlist_len = this_board->n_aichan;
+		err++;
+	}
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_COUNT) {
+		if (!cmd->stop_arg) {
+			cmd->stop_arg = 1;
+			err++;
+		}
+	} else {		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err) {
+		return 3;
+	}
+
+	/* step 4: fix up any arguments */
+	if (cmd->convert_src == TRIG_TIMER) {
+		tmp = cmd->convert_arg;
+		i8253_cascade_ns_to_timer(this_board->i8254_osc_base,
+			&divisor1, &divisor2, &cmd->convert_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		if (cmd->convert_arg < this_board->ai_ns_min)
+			cmd->convert_arg = this_board->ai_ns_min;
+		if (tmp != cmd->convert_arg)
+			err++;
+	}
+
+	if (err) {
+		return 4;
+	}
+
+	return 0;
+}
+
+static int pcl816_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned int divisor1 = 0, divisor2 = 0, dma_flags, bytes, dmairq;
+	comedi_cmd *cmd = &s->async->cmd;
+
+	if (cmd->start_src != TRIG_NOW)
+		return -EINVAL;
+	if (cmd->scan_begin_src != TRIG_FOLLOW)
+		return -EINVAL;
+	if (cmd->scan_end_src != TRIG_COUNT)
+		return -EINVAL;
+	if (cmd->scan_end_arg != cmd->chanlist_len)
+		return -EINVAL;
+//      if(cmd->chanlist_len>MAX_CHANLIST_LEN) return -EINVAL;
+	if (devpriv->irq_blocked)
+		return -EBUSY;
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg < this_board->ai_ns_min)
+			cmd->convert_arg = this_board->ai_ns_min;
+
+		i8253_cascade_ns_to_timer(this_board->i8254_osc_base, &divisor1,
+			&divisor2, &cmd->convert_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		if (divisor1 == 1) {	// PCL816 crash if any divisor is set to 1
+			divisor1 = 2;
+			divisor2 /= 2;
+		}
+		if (divisor2 == 1) {
+			divisor2 = 2;
+			divisor1 /= 2;
+		}
+	}
+
+	start_pacer(dev, -1, 0, 0);	// stop pacer
+
+	if (!check_and_setup_channel_list(dev, s, cmd->chanlist,
+			cmd->chanlist_len))
+		return -EINVAL;
+	comedi_udelay(1);
+
+	devpriv->ai_act_scan = 0;
+	s->async->cur_chan = 0;
+	devpriv->irq_blocked = 1;
+	devpriv->ai_poll_ptr = 0;
+	devpriv->irq_was_now_closed = 0;
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		devpriv->ai_scans = cmd->stop_arg;
+		devpriv->ai_neverending = 0;
+	} else {
+		devpriv->ai_scans = 0;
+		devpriv->ai_neverending = 1;
+	}
+
+	if ((cmd->flags & TRIG_WAKE_EOS)) {	// don't we want wake up every scan?
+		printk("pl816: You wankt WAKE_EOS but I dont want handle it");
+		//              devpriv->ai_eos=1;
+		//if (devpriv->ai_n_chan==1)
+		//      devpriv->dma=0; // DMA is useless for this situation
+	}
+
+	if (devpriv->dma) {
+		bytes = devpriv->hwdmasize[0];
+		if (!devpriv->ai_neverending) {
+			bytes = s->async->cmd.chanlist_len * s->async->cmd.chanlist_len * sizeof(sampl_t);	// how many
+			devpriv->dma_runs_to_end = bytes / devpriv->hwdmasize[0];	// how many DMA pages we must fill
+			devpriv->last_dma_run = bytes % devpriv->hwdmasize[0];	//on last dma transfer must be moved
+			devpriv->dma_runs_to_end--;
+			if (devpriv->dma_runs_to_end >= 0)
+				bytes = devpriv->hwdmasize[0];
+		} else
+			devpriv->dma_runs_to_end = -1;
+
+		devpriv->next_dma_buf = 0;
+		set_dma_mode(devpriv->dma, DMA_MODE_READ);
+		dma_flags = claim_dma_lock();
+		clear_dma_ff(devpriv->dma);
+		set_dma_addr(devpriv->dma, devpriv->hwdmaptr[0]);
+		set_dma_count(devpriv->dma, bytes);
+		release_dma_lock(dma_flags);
+		enable_dma(devpriv->dma);
+	}
+
+	start_pacer(dev, 1, divisor1, divisor2);
+	dmairq = ((devpriv->dma & 0x3) << 4) | (dev->irq & 0x7);
+
+	switch (cmd->convert_src) {
+	case TRIG_TIMER:
+		devpriv->int816_mode = INT_TYPE_AI1_DMA;
+		outb(0x32, dev->iobase + PCL816_CONTROL);	// Pacer+IRQ+DMA
+		outb(dmairq, dev->iobase + PCL816_STATUS);	// write irq and DMA to card
+		break;
+
+	default:
+		devpriv->int816_mode = INT_TYPE_AI3_DMA;
+		outb(0x34, dev->iobase + PCL816_CONTROL);	// Ext trig+IRQ+DMA
+		outb(dmairq, dev->iobase + PCL816_STATUS);	// write irq to card
+		break;
+	}
+
+	DPRINTK("pcl816 END: pcl812_ai_cmd()\n");
+	return 0;
+}
+
+static int pcl816_ai_poll(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long flags;
+	unsigned int top1, top2, i;
+
+	if (!devpriv->dma)
+		return 0;	// poll is valid only for DMA transfer
+
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+
+	for (i = 0; i < 20; i++) {
+		top1 = get_dma_residue(devpriv->dma);	// where is now DMA
+		top2 = get_dma_residue(devpriv->dma);
+		if (top1 == top2)
+			break;
+	}
+	if (top1 != top2) {
+		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		return 0;
+	}
+
+	top1 = devpriv->hwdmasize[0] - top1;	// where is now DMA in buffer
+	top1 >>= 1;		// sample position
+	top2 = top1 - devpriv->ai_poll_ptr;
+	if (top2 < 1) {		// no new samples
+		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		return 0;
+	}
+
+	transfer_from_dma_buf(dev, s,
+		(sampl_t *) devpriv->dmabuf[devpriv->next_dma_buf],
+		devpriv->ai_poll_ptr, top2);
+
+	devpriv->ai_poll_ptr = top1;	// new buffer position
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	return s->async->buf_write_count - s->async->buf_read_count;
+}
+
+/*
+==============================================================================
+ cancel any mode 1-4 AI
+*/
+static int pcl816_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+//  DEBUG(rt_printk("pcl816_ai_cancel()\n");)
+
+	if (devpriv->irq_blocked > 0) {
+		switch (devpriv->int816_mode) {
+#ifdef unused
+		case INT_TYPE_AI1_DMA_RTC:
+		case INT_TYPE_AI3_DMA_RTC:
+			set_rtc_irq_bit(0);	// stop RTC
+			del_timer(&devpriv->rtc_irq_timer);
+#endif
+		case INT_TYPE_AI1_DMA:
+		case INT_TYPE_AI3_DMA:
+			disable_dma(devpriv->dma);
+		case INT_TYPE_AI1_INT:
+		case INT_TYPE_AI3_INT:
+			outb(inb(dev->iobase + PCL816_CONTROL) & 0x73, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
+			comedi_udelay(1);
+			outb(0, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
+			outb(0xb0, dev->iobase + PCL816_CTRCTL);	/* Stop pacer */
+			outb(0x70, dev->iobase + PCL816_CTRCTL);
+			outb(0, dev->iobase + PCL816_AD_LO);
+			inb(dev->iobase + PCL816_AD_LO);
+			inb(dev->iobase + PCL816_AD_HI);
+			outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
+			outb(0, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
+			devpriv->irq_blocked = 0;
+			devpriv->irq_was_now_closed = devpriv->int816_mode;
+			devpriv->int816_mode = 0;
+			devpriv->last_int_sub = s;
+//        s->busy = 0;
+			break;
+		}
+	}
+
+	DEBUG(rt_printk("comedi: pcl816_ai_cancel() successful\n");
+		)
+		return 0;
+}
+
+/*
+==============================================================================
+ chech for PCL816
+*/
+static int pcl816_check(unsigned long iobase)
+{
+	outb(0x00, iobase + PCL816_MUX);
+	comedi_udelay(1);
+	if (inb(iobase + PCL816_MUX) != 0x00)
+		return 1;	//there isn't card
+	outb(0x55, iobase + PCL816_MUX);
+	comedi_udelay(1);
+	if (inb(iobase + PCL816_MUX) != 0x55)
+		return 1;	//there isn't card
+	outb(0x00, iobase + PCL816_MUX);
+	comedi_udelay(1);
+	outb(0x18, iobase + PCL816_CONTROL);
+	comedi_udelay(1);
+	if (inb(iobase + PCL816_CONTROL) != 0x18)
+		return 1;	//there isn't card
+	return 0;		// ok, card exist
+}
+
+/*
+==============================================================================
+ reset whole PCL-816 cards
+*/
+static void pcl816_reset(comedi_device * dev)
+{
+//  outb (0, dev->iobase + PCL818_DA_LO);       // DAC=0V
+//  outb (0, dev->iobase + PCL818_DA_HI);
+//  comedi_udelay (1);
+//  outb (0, dev->iobase + PCL818_DO_HI);       // DO=$0000
+//  outb (0, dev->iobase + PCL818_DO_LO);
+//  comedi_udelay (1);
+	outb(0, dev->iobase + PCL816_CONTROL);
+	outb(0, dev->iobase + PCL816_MUX);
+	outb(0, dev->iobase + PCL816_CLRINT);
+	outb(0xb0, dev->iobase + PCL816_CTRCTL);	/* Stop pacer */
+	outb(0x70, dev->iobase + PCL816_CTRCTL);
+	outb(0x30, dev->iobase + PCL816_CTRCTL);
+	outb(0, dev->iobase + PCL816_RANGE);
+}
+
+/*
+==============================================================================
+ Start/stop pacer onboard pacer
+*/
+static void
+start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
+	unsigned int divisor2)
+{
+	outb(0x32, dev->iobase + PCL816_CTRCTL);
+	outb(0xff, dev->iobase + PCL816_CTR0);
+	outb(0x00, dev->iobase + PCL816_CTR0);
+	comedi_udelay(1);
+	outb(0xb4, dev->iobase + PCL816_CTRCTL);	// set counter 2 as mode 3
+	outb(0x74, dev->iobase + PCL816_CTRCTL);	// set counter 1 as mode 3
+	comedi_udelay(1);
+
+	if (mode == 1) {
+		DPRINTK("mode %d, divisor1 %d, divisor2 %d\n", mode, divisor1,
+			divisor2);
+		outb(divisor2 & 0xff, dev->iobase + PCL816_CTR2);
+		outb((divisor2 >> 8) & 0xff, dev->iobase + PCL816_CTR2);
+		outb(divisor1 & 0xff, dev->iobase + PCL816_CTR1);
+		outb((divisor1 >> 8) & 0xff, dev->iobase + PCL816_CTR1);
+	}
+
+	/* clear pending interrupts (just in case) */
+//      outb(0, dev->iobase + PCL816_CLRINT);
+}
+
+/*
+==============================================================================
+ Check if channel list from user is builded correctly
+ If it's ok, then program scan/gain logic
+*/
+static int
+check_and_setup_channel_list(comedi_device * dev, comedi_subdevice * s,
+	unsigned int *chanlist, int chanlen)
+{
+	unsigned int chansegment[16];
+	unsigned int i, nowmustbechan, seglen, segpos;
+
+	// correct channel and range number check itself comedi/range.c
+	if (chanlen < 1) {
+		comedi_error(dev, "range/channel list is empty!");
+		return 0;
+	}
+
+	if (chanlen > 1) {
+		chansegment[0] = chanlist[0];	// first channel is everytime ok
+		for (i = 1, seglen = 1; i < chanlen; i++, seglen++) {
+			// build part of chanlist
+			DEBUG(rt_printk("%d. %d %d\n", i, CR_CHAN(chanlist[i]),
+					CR_RANGE(chanlist[i]));
+				)
+				if (chanlist[0] == chanlist[i])
+				break;	// we detect loop, this must by finish
+			nowmustbechan =
+				(CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
+			if (nowmustbechan != CR_CHAN(chanlist[i])) {
+				// channel list isn't continous :-(
+				rt_printk
+					("comedi%d: pcl816: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
+					dev->minor, i, CR_CHAN(chanlist[i]),
+					nowmustbechan, CR_CHAN(chanlist[0]));
+				return 0;
+			}
+			chansegment[i] = chanlist[i];	// well, this is next correct channel in list
+		}
+
+		for (i = 0, segpos = 0; i < chanlen; i++) {	// check whole chanlist
+			DEBUG(rt_printk("%d %d=%d %d\n",
+					CR_CHAN(chansegment[i % seglen]),
+					CR_RANGE(chansegment[i % seglen]),
+					CR_CHAN(chanlist[i]),
+					CR_RANGE(chanlist[i]));
+				)
+				if (chanlist[i] != chansegment[i % seglen]) {
+				rt_printk
+					("comedi%d: pcl816: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
+					dev->minor, i, CR_CHAN(chansegment[i]),
+					CR_RANGE(chansegment[i]),
+					CR_AREF(chansegment[i]),
+					CR_CHAN(chanlist[i % seglen]),
+					CR_RANGE(chanlist[i % seglen]),
+					CR_AREF(chansegment[i % seglen]));
+				return 0;	// chan/gain list is strange
+			}
+		}
+	} else {
+		seglen = 1;
+	}
+
+	devpriv->ai_act_chanlist_len = seglen;
+	devpriv->ai_act_chanlist_pos = 0;
+
+	for (i = 0; i < seglen; i++) {	// store range list to card
+		devpriv->ai_act_chanlist[i] = CR_CHAN(chanlist[i]);
+		outb(CR_CHAN(chanlist[0]) & 0xf, dev->iobase + PCL816_MUX);
+		outb(CR_RANGE(chanlist[0]), dev->iobase + PCL816_RANGE);	/* select gain */
+	}
+
+	comedi_udelay(1);
+
+	outb(devpriv->ai_act_chanlist[0] | (devpriv->ai_act_chanlist[seglen - 1] << 4), dev->iobase + PCL816_MUX);	/* select channel interval to scan */
+
+	return 1;		// we can serve this with MUX logic
+}
+
+#ifdef unused
+/*
+==============================================================================
+  Enable(1)/disable(0) periodic interrupts from RTC
+*/
+static int set_rtc_irq_bit(unsigned char bit)
+{
+	unsigned char val;
+	unsigned long flags;
+
+	if (bit == 1) {
+		RTC_timer_lock++;
+		if (RTC_timer_lock > 1)
+			return 0;
+	} else {
+		RTC_timer_lock--;
+		if (RTC_timer_lock < 0)
+			RTC_timer_lock = 0;
+		if (RTC_timer_lock > 0)
+			return 0;
+	}
+
+	save_flags(flags);
+	cli();
+	val = CMOS_READ(RTC_CONTROL);
+	if (bit) {
+		val |= RTC_PIE;
+	} else {
+		val &= ~RTC_PIE;
+	}
+	CMOS_WRITE(val, RTC_CONTROL);
+	CMOS_READ(RTC_INTR_FLAGS);
+	restore_flags(flags);
+	return 0;
+}
+#endif
+
+/*
+==============================================================================
+  Free any resources that we have claimed
+*/
+static void free_resources(comedi_device * dev)
+{
+	//rt_printk("free_resource()\n");
+	if (dev->private) {
+		pcl816_ai_cancel(dev, devpriv->sub_ai);
+		pcl816_reset(dev);
+		if (devpriv->dma)
+			free_dma(devpriv->dma);
+		if (devpriv->dmabuf[0])
+			free_pages(devpriv->dmabuf[0], devpriv->dmapages[0]);
+		if (devpriv->dmabuf[1])
+			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
+#ifdef unused
+		if (devpriv->rtc_irq)
+			comedi_free_irq(devpriv->rtc_irq, dev);
+		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
+			if (devpriv->rtc_iobase)
+				release_region(devpriv->rtc_iobase,
+					devpriv->rtc_iosize);
+		}
+#endif
+	}
+
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	if (dev->iobase)
+		release_region(dev->iobase, this_board->io_range);
+	//rt_printk("free_resource() end\n");
+}
+
+/*
+==============================================================================
+
+   Initialization
+
+*/
+static int pcl816_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	int ret;
+	unsigned long iobase;
+	unsigned int irq, dma;
+	unsigned long pages;
+	//int i;
+	comedi_subdevice *s;
+
+	/* claim our I/O space */
+	iobase = it->options[0];
+	printk("comedi%d: pcl816:  board=%s, ioport=0x%03lx", dev->minor,
+		this_board->name, iobase);
+
+	if (!request_region(iobase, this_board->io_range, "pcl816")) {
+		rt_printk("I/O port conflict\n");
+		return -EIO;
+	}
+
+	dev->iobase = iobase;
+
+	if (pcl816_check(iobase)) {
+		rt_printk(", I cann't detect board. FAIL!\n");
+		return -EIO;
+	}
+
+	if ((ret = alloc_private(dev, sizeof(pcl816_private))) < 0)
+		return ret;	/* Can't alloc mem */
+
+	/* set up some name stuff */
+	dev->board_name = this_board->name;
+
+	/* grab our IRQ */
+	irq = 0;
+	if (this_board->IRQbits != 0) {	/* board support IRQ */
+		irq = it->options[1];
+		if (irq) {	/* we want to use IRQ */
+			if (((1 << irq) & this_board->IRQbits) == 0) {
+				rt_printk
+					(", IRQ %u is out of allowed range, DISABLING IT",
+					irq);
+				irq = 0;	/* Bad IRQ */
+			} else {
+				if (comedi_request_irq(irq, interrupt_pcl816, 0,
+						"pcl816", dev)) {
+					rt_printk
+						(", unable to allocate IRQ %u, DISABLING IT",
+						irq);
+					irq = 0;	/* Can't use IRQ */
+				} else {
+					rt_printk(", irq=%u", irq);
+				}
+			}
+		}
+	}
+
+	dev->irq = irq;
+	if (irq) {
+		devpriv->irq_free = 1;
+	} /* 1=we have allocated irq */
+	else {
+		devpriv->irq_free = 0;
+	}
+	devpriv->irq_blocked = 0;	/* number of subdevice which use IRQ */
+	devpriv->int816_mode = 0;	/* mode of irq */
+
+#ifdef unused
+	/* grab RTC for DMA operations */
+	devpriv->dma_rtc = 0;
+	if (it->options[2] > 0) {	// we want to use DMA
+		if (RTC_lock == 0) {
+			if (!request_region(RTC_PORT(0), RTC_IO_EXTENT,
+					"pcl816 (RTC)"))
+				goto no_rtc;
+		}
+		devpriv->rtc_iobase = RTC_PORT(0);
+		devpriv->rtc_iosize = RTC_IO_EXTENT;
+		RTC_lock++;
+#ifdef UNTESTED_CODE
+		if (!comedi_request_irq(RTC_IRQ,
+				interrupt_pcl816_ai_mode13_dma_rtc, 0,
+				"pcl816 DMA (RTC)", dev)) {
+			devpriv->dma_rtc = 1;
+			devpriv->rtc_irq = RTC_IRQ;
+			rt_printk(", dma_irq=%u", devpriv->rtc_irq);
+		} else {
+			RTC_lock--;
+			if (RTC_lock == 0) {
+				if (devpriv->rtc_iobase)
+					release_region(devpriv->rtc_iobase,
+						devpriv->rtc_iosize);
+			}
+			devpriv->rtc_iobase = 0;
+			devpriv->rtc_iosize = 0;
+		}
+#else
+		printk("pcl816: RTC code missing");
+#endif
+
+	}
+
+      no_rtc:
+#endif
+	/* grab our DMA */
+	dma = 0;
+	devpriv->dma = dma;
+	if ((devpriv->irq_free == 0) && (devpriv->dma_rtc == 0))
+		goto no_dma;	/* if we haven't IRQ, we can't use DMA */
+
+	if (this_board->DMAbits != 0) {	/* board support DMA */
+		dma = it->options[2];
+		if (dma < 1)
+			goto no_dma;	/* DMA disabled */
+
+		if (((1 << dma) & this_board->DMAbits) == 0) {
+			rt_printk(", DMA is out of allowed range, FAIL!\n");
+			return -EINVAL;	/* Bad DMA */
+		}
+		ret = request_dma(dma, "pcl816");
+		if (ret) {
+			rt_printk(", unable to allocate DMA %u, FAIL!\n", dma);
+			return -EBUSY;	/* DMA isn't free */
+		}
+
+		devpriv->dma = dma;
+		rt_printk(", dma=%u", dma);
+		pages = 2;	/* we need 16KB */
+		devpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);
+
+		if (!devpriv->dmabuf[0]) {
+			rt_printk(", unable to allocate DMA buffer, FAIL!\n");
+			/* maybe experiment with try_to_free_pages() will help .... */
+			return -EBUSY;	/* no buffer :-( */
+		}
+		devpriv->dmapages[0] = pages;
+		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
+		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
+		//rt_printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE);
+
+		if (devpriv->dma_rtc == 0) {	// we must do duble buff :-(
+			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
+			if (!devpriv->dmabuf[1]) {
+				rt_printk
+					(", unable to allocate DMA buffer, FAIL!\n");
+				return -EBUSY;
+			}
+			devpriv->dmapages[1] = pages;
+			devpriv->hwdmaptr[1] =
+				virt_to_bus((void *)devpriv->dmabuf[1]);
+			devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
+		}
+	}
+
+      no_dma:
+
+/*  if (this_board->n_aochan > 0)
+    subdevs[1] = COMEDI_SUBD_AO;
+  if (this_board->n_dichan > 0)
+    subdevs[2] = COMEDI_SUBD_DI;
+  if (this_board->n_dochan > 0)
+    subdevs[3] = COMEDI_SUBD_DO;
+*/
+	if ((ret = alloc_subdevices(dev, 1)) < 0)
+		return ret;
+
+	s = dev->subdevices + 0;
+	if (this_board->n_aichan > 0) {
+		s->type = COMEDI_SUBD_AI;
+		devpriv->sub_ai = s;
+		dev->read_subdev = s;
+		s->subdev_flags = SDF_READABLE | SDF_CMD_READ;
+		s->n_chan = this_board->n_aichan;
+		s->subdev_flags |= SDF_DIFF;
+		//printk (", %dchans DIFF DAC - %d", s->n_chan, i);
+		s->maxdata = this_board->ai_maxdata;
+		s->len_chanlist = this_board->ai_chanlist;
+		s->range_table = this_board->ai_range_type;
+		s->cancel = pcl816_ai_cancel;
+		s->do_cmdtest = pcl816_ai_cmdtest;
+		s->do_cmd = pcl816_ai_cmd;
+		s->poll = pcl816_ai_poll;
+		s->insn_read = pcl816_ai_insn_read;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+#if 0
+case COMEDI_SUBD_AO:
+	s->subdev_flags = SDF_WRITABLE | SDF_GROUND;
+	s->n_chan = this_board->n_aochan;
+	s->maxdata = this_board->ao_maxdata;
+	s->len_chanlist = this_board->ao_chanlist;
+	s->range_table = this_board->ao_range_type;
+	break;
+
+case COMEDI_SUBD_DI:
+	s->subdev_flags = SDF_READABLE;
+	s->n_chan = this_board->n_dichan;
+	s->maxdata = 1;
+	s->len_chanlist = this_board->n_dichan;
+	s->range_table = &range_digital;
+	break;
+
+case COMEDI_SUBD_DO:
+	s->subdev_flags = SDF_WRITABLE;
+	s->n_chan = this_board->n_dochan;
+	s->maxdata = 1;
+	s->len_chanlist = this_board->n_dochan;
+	s->range_table = &range_digital;
+	break;
+#endif
+
+	pcl816_reset(dev);
+
+	rt_printk("\n");
+
+	return 0;
+}
+
+/*
+==============================================================================
+  Removes device
+ */
+static int pcl816_detach(comedi_device * dev)
+{
+	DEBUG(rt_printk("comedi%d: pcl816: remove\n", dev->minor);
+		)
+		free_resources(dev);
+#ifdef unused
+	if (devpriv->dma_rtc)
+		RTC_lock--;
+#endif
+	return 0;
+}
