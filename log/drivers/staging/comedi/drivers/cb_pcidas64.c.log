commit b33fc68c26a56d23b7221434dd367949420637bc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 30 14:17:12 2018 +0000

    staging: comedi: cb_pcidas64: Use insn->n in EEPROM insn_read handler
    
    The `insn_read` handler for the EEPROM subdevice (`eeprom_insn_read()`)
    currently ignores `insn->n` (the number of samples to be read) and
    assumes a single sample is to be read.  But `insn->n` could be 0,
    meaning no samples should be read, in which case `data[0]` ought not to
    be written.  (The comedi core at least ensures that `data[0]` exists,
    but we should not rely on that.)
    
    Follow the usual Comedi guidelines and interpret `insn->n` as the number
    of samples to be read, but only read the EEPROM location once and make
    `insn->n` copies, as we don't expect the contents of the EEPROM location
    to change between readings.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 44e5aaf8bae5..e1774e09a320 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3768,9 +3768,17 @@ static int eeprom_read_insn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	data[0] = read_eeprom(dev, CR_CHAN(insn->chanspec));
+	unsigned int val;
+	unsigned int i;
 
-	return 1;
+	if (insn->n) {
+		/* No point reading the same EEPROM location more than once. */
+		val = read_eeprom(dev, CR_CHAN(insn->chanspec));
+		for (i = 0; i < insn->n; i++)
+			data[i] = val;
+	}
+
+	return insn->n;
 }
 
 /* Allocate and initialize the subdevice structures. */

commit 130151991dcb14e5c383c730b3ef37a6fdc32c95
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 30 14:17:11 2018 +0000

    staging: comedi: cb_pcidas64: Use insn->n in AO insn_write handler
    
    The `insn_write` handler for the AO subdevice (`ao_winsn()` currently
    ignores `insn->n` (the number of samples to write) and assumes a single
    sample is to be written.  But `insn->n` could be 0, meaning no samples
    should be written, in which case `data[0]` is invalid.
    
    Follow the usual Comedi guidelines and change `ao_winsn()` to write the
    specified number of samples.  This fixes the assumption that `data[0]`
    is valid.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 631a703b345d..44e5aaf8bae5 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3097,8 +3097,10 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 {
 	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
-	int chan = CR_CHAN(insn->chanspec);
-	int range = CR_RANGE(insn->chanspec);
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
+	unsigned int val = s->readback[chan];
+	unsigned int i;
 
 	/* do some initializing */
 	writew(0, devpriv->main_iobase + DAC_CONTROL0_REG);
@@ -3108,20 +3110,24 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	writew(devpriv->dac_control1_bits,
 	       devpriv->main_iobase + DAC_CONTROL1_REG);
 
-	/* write to channel */
-	if (board->layout == LAYOUT_4020) {
-		writew(data[0] & 0xff,
-		       devpriv->main_iobase + dac_lsb_4020_reg(chan));
-		writew((data[0] >> 8) & 0xf,
-		       devpriv->main_iobase + dac_msb_4020_reg(chan));
-	} else {
-		writew(data[0], devpriv->main_iobase + dac_convert_reg(chan));
+	for (i = 0; i < insn->n; i++) {
+		/* write to channel */
+		val = data[i];
+		if (board->layout == LAYOUT_4020) {
+			writew(val & 0xff,
+			       devpriv->main_iobase + dac_lsb_4020_reg(chan));
+			writew((val >> 8) & 0xf,
+			       devpriv->main_iobase + dac_msb_4020_reg(chan));
+		} else {
+			writew(val,
+			       devpriv->main_iobase + dac_convert_reg(chan));
+		}
 	}
 
-	/* remember output value */
-	s->readback[chan] = data[0];
+	/* remember last output value */
+	s->readback[chan] = val;
 
-	return 1;
+	return insn->n;
 }
 
 static void set_dac_control0_reg(struct comedi_device *dev,

commit eb641b920b7508ea7911cd3b7f899ef44abf4052
Author: Gabriel Francisco Mandaji <gfmandaji@gmail.com>
Date:   Tue Apr 10 19:50:07 2018 -0300

    staging: comedi: cb_pcidas64: fix alignment of function parameters
    
    Fix most checkpatch.pl issues of type:
    
    CHECK: Alignment should match open parenthesis
    
    Signed-off-by: Gabriel Francisco Mandaji <gfmandaji@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index fdd81c3beb51..631a703b345d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2268,14 +2268,14 @@ static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 }
 
 static u32 ai_convert_counter_6xxx(const struct comedi_device *dev,
-					const struct comedi_cmd *cmd)
+				   const struct comedi_cmd *cmd)
 {
 	/* supposed to load counter with desired divisor minus 3 */
 	return cmd->convert_arg / TIMER_BASE - 3;
 }
 
 static u32 ai_scan_counter_6xxx(struct comedi_device *dev,
-				     struct comedi_cmd *cmd)
+				struct comedi_cmd *cmd)
 {
 	u32 count;
 
@@ -2296,7 +2296,7 @@ static u32 ai_scan_counter_6xxx(struct comedi_device *dev,
 }
 
 static u32 ai_convert_counter_4020(struct comedi_device *dev,
-					struct comedi_cmd *cmd)
+				   struct comedi_cmd *cmd)
 {
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int divisor;

commit 0c27d1747b9409b7fa4f0a90f10facd4577edee4
Author: Jian Zhang <kernel@ubicomp.com.au>
Date:   Fri Mar 23 18:49:09 2018 +0800

    Staging: comedi: fix multiple line dereference coding style issue in cb_pcidas64.c
    
    This is a patch to the cb_pcidas64.c file that fixes up a multiple line
    dereference warning found by the checkpatch.pl tool.
    
    Signed-off-by: Jian Zhang <kernel@ubicomp.com.au>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 942ba5cd8270..fdd81c3beb51 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2462,20 +2462,21 @@ static int setup_channel_queue(struct comedi_device *dev,
 			writew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);
 			/* load external queue */
 			for (i = 0; i < cmd->chanlist_len; i++) {
+				unsigned int chanspec = cmd->chanlist[i];
+				int use_differential;
+
 				bits = 0;
 				/* set channel */
-				bits |= adc_chan_bits(CR_CHAN(cmd->
-							      chanlist[i]));
+				bits |= adc_chan_bits(CR_CHAN(chanspec));
 				/* set gain */
 				bits |= ai_range_bits_6xxx(dev,
-							   CR_RANGE(cmd->
-								    chanlist
-								    [i]));
+							   CR_RANGE(chanspec));
 				/* set single-ended / differential */
-				bits |= se_diff_bit_6xxx(dev,
-							 CR_AREF(cmd->
-								 chanlist[i]) ==
-							 AREF_DIFF);
+				use_differential = 0;
+				if (CR_AREF(chanspec) == AREF_DIFF)
+					use_differential = 1;
+				bits |= se_diff_bit_6xxx(dev, use_differential);
+
 				if (CR_AREF(cmd->chanlist[i]) == AREF_COMMON)
 					bits |= ADC_COMMON_BIT;
 				/* mark end of queue */

commit 9eb7194690ba358db58da3180b11e526496481bc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 23 13:54:33 2018 +0000

    staging: comedi: cb_pcidas64: Fix external_ai_queue_in_use()
    
    `external_ai_queue_in_use()` is supposed to return 1 if the external
    channel sequencer is in use by an AI command, else return 0.  If the
    "read" subdevice (which is the AI subdevice) is not busy then no AI
    command is running so the external channel sequencer is not in use, so
    the function should return 0.  Unfortunately, the function's "read"
    subdevice busy test is inverted, so the function always returns 0 when
    the "read" subdevice is busy.  Worse, if the "read" subdevice is
    not busy the subsequent call to `use_internal_queue_6xxx()` results in a
    null pointer dereference if a previous AI command used a channel list
    with a length greater than 1.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index aa481c00e8e7..942ba5cd8270 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3251,7 +3251,7 @@ static inline int external_ai_queue_in_use(struct comedi_device *dev)
 {
 	const struct pcidas64_board *board = dev->board_ptr;
 
-	if (dev->read_subdev->busy)
+	if (!dev->read_subdev->busy)
 		return 0;
 	if (board->layout == LAYOUT_4020)
 		return 0;

commit 5d20e467dfadf14b9437d2b04040a3a342974ec9
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 23 13:54:32 2018 +0000

    Revert "staging: comedi: cb_pcidas64: change params to external_ai_queue_in_use()"
    
    This reverts commit f5f3a2c6569e ("staging: comedi: cb_pcidas64: change
    params to external_ai_queue_in_use()").  The
    `external_ai_queue_in_use()` was being called from `ao_cmd()` with
    pointers to the "write" subdevice and AO command, but is supposed to
    check whether the external AI queue is currently in use by the "read"
    subdevice and AI command.  In fact, the return value always indicated
    that the external AI queue was not in use in this case (because the AO
    command's channel list is sequential), so was fairly useless.  (However,
    even before the reverted commit, the logic in
    `external_ai_queue_in_use()` was wrong.  That will be corrected in a
    subsequent commit.)
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index ceef9058b59f..aa481c00e8e7 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3247,17 +3247,15 @@ static int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	return 0;
 }
 
-static inline int external_ai_queue_in_use(struct comedi_device *dev,
-					   struct comedi_subdevice *s,
-					   struct comedi_cmd *cmd)
+static inline int external_ai_queue_in_use(struct comedi_device *dev)
 {
 	const struct pcidas64_board *board = dev->board_ptr;
 
-	if (s->busy)
+	if (dev->read_subdev->busy)
 		return 0;
 	if (board->layout == LAYOUT_4020)
 		return 0;
-	else if (use_internal_queue_6xxx(cmd))
+	else if (use_internal_queue_6xxx(&dev->read_subdev->async->cmd))
 		return 0;
 	return 1;
 }
@@ -3291,7 +3289,7 @@ static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	if (external_ai_queue_in_use(dev, s, cmd)) {
+	if (external_ai_queue_in_use(dev)) {
 		warn_external_queue(dev);
 		return -EBUSY;
 	}

commit 471c3615e5633a37db1aab44e81ae7c770a8b64c
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Mon Mar 5 09:58:08 2018 +0530

    staging: comedi: Replace "dont" with "don't
    
    Replace "dont" with "don't".
    "Dont" is not same as "Do not" or "Don't".
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index c00750054ae9..ceef9058b59f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1700,7 +1700,7 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 	 * eeprom and i2c bus
 	 */
 
-	/* make sure we dont send anything to eeprom */
+	/* make sure we don't send anything to eeprom */
 	devpriv->plx_control_bits &= ~PLX_CNTRL_EECS;
 
 	i2c_stop(dev);

commit cc62f8164e2e2b546fd376b86df848c33bc115e4
Author: Eisha Chen-yen-su <chenyensu0@gmail.com>
Date:   Mon Feb 19 17:04:22 2018 +0100

    staging: comedi: Remove a newline inside a dereference
    
    Remove a new line inside a dereference so that it is not on
    multiple lines.
    And avoid making the line go over 80 columns by moving the whole
    dma_alloc_coherent() call back 4 columns. Problem found with
    checkpatch.
    
    Signed-off-by: Eisha Chen-yen-su <chenyensu0@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index b657beedd5ff..c00750054ae9 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1488,11 +1488,10 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 		if (ao_cmd_is_supported(board)) {
 			devpriv->ao_buffer[i] =
-				dma_alloc_coherent(&pcidev->dev,
-						   DMA_BUFFER_SIZE,
-						   &devpriv->
-						   ao_buffer_bus_addr[i],
-						   GFP_KERNEL);
+			    dma_alloc_coherent(&pcidev->dev,
+					       DMA_BUFFER_SIZE,
+					       &devpriv->ao_buffer_bus_addr[i],
+					       GFP_KERNEL);
 			if (!devpriv->ao_buffer[i])
 				return -ENOMEM;
 		}

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 525424efdc1b..b657beedd5ff 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -19,16 +19,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index b761f000c1dc..525424efdc1b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * comedi/drivers/cb_pcidas64.c
  * This is a driver for the ComputerBoards/MeasurementComputing PCI-DAS

commit 06cb6b5434937180251d0ddb3d9a4cb2af6015da
Author: Varsha Rao <rvarsha016@gmail.com>
Date:   Sun Mar 12 20:37:30 2017 +0530

    staging: comedi: Compress return logic into one line.
    
    Simplify function return by merging assignment and return into a single
    line. The following coccinelle script is used to fix this issue.
    
    @@
    expression e;
    local idexpression ret;
    @@
    
    -ret = e;
    -return ret;
    +return e;
    
    Signed-off-by: Varsha Rao <rvarsha016@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 3b98193de0a4..b761f000c1dc 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1417,9 +1417,7 @@ static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 	if (retval < 0)
 		return retval;
 
-	num_samples = retval * fifo->num_segments * fifo->sample_packing_ratio;
-
-	return num_samples;
+	return retval * fifo->num_segments * fifo->sample_packing_ratio;
 }
 
 /* query length of fifo */

commit 7dfc6971243430dd9edef3c4c0694d3a97b321f7
Author: simran singhal <singhalsimran0@gmail.com>
Date:   Tue Feb 21 23:58:26 2017 +0530

    staging: comedi: Using macro DIV_ROUND_UP
    
    The macro DIV_ROUND_UP performs the computation (((n) + (d) - 1) /(d)).
    It clarifies the divisor calculations. This occurence was detected using
    the coccinelle script:
    
    @@
    expression e1;
    expression e2;
    @@
    (
    - ((e1) + e2 - 1) / (e2)
    + DIV_ROUND_UP(e1,e2)
    |
    - ((e1) + (e2 - 1)) / (e2)
    + DIV_ROUND_UP(e1,e2)
    )
    
    Signed-off-by: simran singhal <singhalsimran0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index efbf27730d71..3b98193de0a4 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2007,7 +2007,7 @@ static unsigned int get_divisor(unsigned int ns, unsigned int flags)
 
 	switch (flags & CMDF_ROUND_MASK) {
 	case CMDF_ROUND_UP:
-		divisor = (ns + TIMER_BASE - 1) / TIMER_BASE;
+		divisor = DIV_ROUND_UP(ns, TIMER_BASE);
 		break;
 	case CMDF_ROUND_DOWN:
 		divisor = ns / TIMER_BASE;

commit db30e33f4a333e52cab9279cd000576f98a23451
Author: Saber Rezvani <irsaber@gmail.com>
Date:   Fri Dec 16 22:45:16 2016 +0330

    staging: comedi: cb_pcidas64: use preferred kernel type u32
    
    Fix the checkpatch.pl issue:
    CHECK: Prefer kernel type 'u32' over 'uint32_t'
    
    Signed-off-by: Saber Rezvani <irsaber@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index f60096ddb608..efbf27730d71 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1132,8 +1132,8 @@ struct pcidas64_private {
 	void __iomem *plx9080_iobase;
 	void __iomem *main_iobase;
 	/* local address (used by dma controller) */
-	uint32_t local0_iobase;
-	uint32_t local1_iobase;
+	u32 local0_iobase;
+	u32 local1_iobase;
 	/* dma buffers for analog input */
 	u16 *ai_buffer[MAX_AI_DMA_RING_COUNT];
 	/* physical addresses of ai dma buffers */
@@ -1169,9 +1169,9 @@ struct pcidas64_private {
 	u16 hw_config_bits;
 	u16 dac_control1_bits;
 	/* last bits written to plx9080 control register */
-	uint32_t plx_control_bits;
+	u32 plx_control_bits;
 	/* last bits written to plx interrupt control and status register */
-	uint32_t plx_intcsr_bits;
+	u32 plx_intcsr_bits;
 	/* index of calibration source readable through ai ch0 */
 	int calibration_source;
 	/* bits written to i2c calibration/range register */
@@ -1266,7 +1266,7 @@ static void enable_ai_interrupts(struct comedi_device *dev,
 {
 	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
-	uint32_t bits;
+	u32 bits;
 	unsigned long flags;
 
 	bits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |
@@ -1292,7 +1292,7 @@ static void init_plx9080(struct comedi_device *dev)
 {
 	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
-	uint32_t bits;
+	u32 bits;
 	void __iomem *plx_iobase = devpriv->plx9080_iobase;
 
 	devpriv->plx_control_bits =
@@ -2279,17 +2279,17 @@ static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 	return num_samples;
 }
 
-static uint32_t ai_convert_counter_6xxx(const struct comedi_device *dev,
+static u32 ai_convert_counter_6xxx(const struct comedi_device *dev,
 					const struct comedi_cmd *cmd)
 {
 	/* supposed to load counter with desired divisor minus 3 */
 	return cmd->convert_arg / TIMER_BASE - 3;
 }
 
-static uint32_t ai_scan_counter_6xxx(struct comedi_device *dev,
+static u32 ai_scan_counter_6xxx(struct comedi_device *dev,
 				     struct comedi_cmd *cmd)
 {
-	uint32_t count;
+	u32 count;
 
 	/* figure out how long we need to delay at end of scan */
 	switch (cmd->scan_begin_src) {
@@ -2307,7 +2307,7 @@ static uint32_t ai_scan_counter_6xxx(struct comedi_device *dev,
 	return count - 3;
 }
 
-static uint32_t ai_convert_counter_4020(struct comedi_device *dev,
+static u32 ai_convert_counter_4020(struct comedi_device *dev,
 					struct comedi_cmd *cmd)
 {
 	struct pcidas64_private *devpriv = dev->private;
@@ -2382,7 +2382,7 @@ static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
 	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
-	uint32_t convert_counter = 0, scan_counter = 0;
+	u32 convert_counter = 0, scan_counter = 0;
 
 	check_adc_timing(dev, cmd);
 
@@ -2572,7 +2572,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	uint32_t bits;
+	u32 bits;
 	unsigned int i;
 	unsigned long flags;
 	int retval;
@@ -2754,7 +2754,7 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int nsamples;
 	unsigned int i;
-	uint32_t fifo_data;
+	u32 fifo_data;
 	int write_code =
 		readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
 	int read_code =
@@ -2794,7 +2794,7 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	uint32_t next_transfer_addr;
+	u32 next_transfer_addr;
 	int j;
 	int num_samples = 0;
 	void __iomem *pci_addr_reg;
@@ -3056,8 +3056,8 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned short status;
-	uint32_t plx_status;
-	uint32_t plx_bits;
+	u32 plx_status;
+	u32 plx_bits;
 
 	plx_status = readl(devpriv->plx9080_iobase + PLX_REG_INTCSR);
 	status = readw(devpriv->main_iobase + HW_STATUS_REG);
@@ -3975,7 +3975,7 @@ static int auto_attach(struct comedi_device *dev,
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	const struct pcidas64_board *board = NULL;
 	struct pcidas64_private *devpriv;
-	uint32_t local_range, local_decode;
+	u32 local_range, local_decode;
 	int retval;
 
 	if (context < ARRAY_SIZE(pcidas64_boards))
@@ -4013,13 +4013,13 @@ static int auto_attach(struct comedi_device *dev,
 		      PLX_LASRR_MEM_MASK;
 	local_decode = readl(devpriv->plx9080_iobase + PLX_REG_LAS0BA) &
 		       local_range & PLX_LASBA_MEM_MASK;
-	devpriv->local0_iobase = ((uint32_t)devpriv->main_phys_iobase &
+	devpriv->local0_iobase = ((u32)devpriv->main_phys_iobase &
 				  ~local_range) | local_decode;
 	local_range = readl(devpriv->plx9080_iobase + PLX_REG_LAS1RR) &
 		      PLX_LASRR_MEM_MASK;
 	local_decode = readl(devpriv->plx9080_iobase + PLX_REG_LAS1BA) &
 		       local_range & PLX_LASBA_MEM_MASK;
-	devpriv->local1_iobase = ((uint32_t)devpriv->dio_counter_phys_iobase &
+	devpriv->local1_iobase = ((u32)devpriv->dio_counter_phys_iobase &
 				  ~local_range) | local_decode;
 
 	retval = alloc_and_init_dma_members(dev);

commit 9e23afed3579cfb1d533a55f41f69c6d67f669c6
Author: Saber Rezvani <irsaber@gmail.com>
Date:   Fri Dec 16 22:45:15 2016 +0330

    staging: comedi: cb_pcidas64: use preferred kernel type u16
    
    Fix the checkpatch.pl issue:
    CHECK: Prefer kernel type 'u16' over 'uint16_t'
    
    Signed-off-by: Saber Rezvani <irsaber@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 55e84d0b32e4..f60096ddb608 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -238,7 +238,7 @@ enum daq_atrig_low_4020_contents {
 	EXT_START_TRIG_BNC_BIT = 0x2000,
 };
 
-static inline uint16_t analog_trig_low_threshold_bits(uint16_t threshold)
+static inline u16 analog_trig_low_threshold_bits(u16 threshold)
 {
 	return threshold & 0xfff;
 }
@@ -280,17 +280,17 @@ enum adc_control1_contents {
 	ADC_MODE_MASK = 0xf000,
 };
 
-static inline uint16_t adc_lo_chan_4020_bits(unsigned int channel)
+static inline u16 adc_lo_chan_4020_bits(unsigned int channel)
 {
 	return (channel & 0x3) << 8;
 };
 
-static inline uint16_t adc_hi_chan_4020_bits(unsigned int channel)
+static inline u16 adc_hi_chan_4020_bits(unsigned int channel)
 {
 	return (channel & 0x3) << 10;
 };
 
-static inline uint16_t adc_mode_bits(unsigned int mode)
+static inline u16 adc_mode_bits(unsigned int mode)
 {
 	return (mode & 0xf) << 12;
 };
@@ -318,12 +318,12 @@ enum calibration_contents {
  *  7 : dac channel 1
  */
 
-static inline uint16_t adc_src_bits(unsigned int source)
+static inline u16 adc_src_bits(unsigned int source)
 {
 	return (source & 0xf) << 3;
 };
 
-static inline uint16_t adc_convert_chan_4020_bits(unsigned int channel)
+static inline u16 adc_convert_chan_4020_bits(unsigned int channel)
 {
 	return (channel & 0x3) << 8;
 };
@@ -337,7 +337,7 @@ enum adc_queue_load_contents {
 	QUEUE_EOSCAN_BIT = 0x8000,	/* queue end of scan */
 };
 
-static inline uint16_t adc_chan_bits(unsigned int channel)
+static inline u16 adc_chan_bits(unsigned int channel)
 {
 	return channel & 0x3f;
 };
@@ -384,22 +384,22 @@ enum hw_status_contents {
 	ADC_STOP_BIT = 0x200,
 };
 
-static inline uint16_t pipe_full_bits(uint16_t hw_status_bits)
+static inline u16 pipe_full_bits(u16 hw_status_bits)
 {
 	return (hw_status_bits >> 10) & 0x3;
 };
 
-static inline unsigned int dma_chain_flag_bits(uint16_t prepost_bits)
+static inline unsigned int dma_chain_flag_bits(u16 prepost_bits)
 {
 	return (prepost_bits >> 6) & 0x3;
 }
 
-static inline unsigned int adc_upper_read_ptr_code(uint16_t prepost_bits)
+static inline unsigned int adc_upper_read_ptr_code(u16 prepost_bits)
 {
 	return (prepost_bits >> 12) & 0x3;
 }
 
-static inline unsigned int adc_upper_write_ptr_code(uint16_t prepost_bits)
+static inline unsigned int adc_upper_write_ptr_code(u16 prepost_bits)
 {
 	return (prepost_bits >> 14) & 0x3;
 }
@@ -594,7 +594,7 @@ struct hw_fifo_info {
 	unsigned int num_segments;
 	unsigned int max_segment_length;
 	unsigned int sample_packing_ratio;
-	uint16_t fifo_size_reg_mask;
+	u16 fifo_size_reg_mask;
 };
 
 enum pcidas64_boardid {
@@ -1135,7 +1135,7 @@ struct pcidas64_private {
 	uint32_t local0_iobase;
 	uint32_t local1_iobase;
 	/* dma buffers for analog input */
-	uint16_t *ai_buffer[MAX_AI_DMA_RING_COUNT];
+	u16 *ai_buffer[MAX_AI_DMA_RING_COUNT];
 	/* physical addresses of ai dma buffers */
 	dma_addr_t ai_buffer_bus_addr[MAX_AI_DMA_RING_COUNT];
 	/*
@@ -1151,7 +1151,7 @@ struct pcidas64_private {
 	 */
 	unsigned int ai_dma_index;
 	/* dma buffers for analog output */
-	uint16_t *ao_buffer[AO_DMA_RING_COUNT];
+	u16 *ao_buffer[AO_DMA_RING_COUNT];
 	/* physical addresses of ao dma buffers */
 	dma_addr_t ao_buffer_bus_addr[AO_DMA_RING_COUNT];
 	struct plx_dma_desc *ao_dma_desc;
@@ -1162,12 +1162,12 @@ struct pcidas64_private {
 	/* last bits sent to INTR_ENABLE_REG register */
 	unsigned int intr_enable_bits;
 	/* last bits sent to ADC_CONTROL1_REG register */
-	uint16_t adc_control1_bits;
+	u16 adc_control1_bits;
 	/* last bits sent to FIFO_SIZE_REG register */
-	uint16_t fifo_size_bits;
+	u16 fifo_size_bits;
 	/* last bits sent to HW_CONFIG_REG register */
-	uint16_t hw_config_bits;
-	uint16_t dac_control1_bits;
+	u16 hw_config_bits;
+	u16 dac_control1_bits;
 	/* last bits written to plx9080 control register */
 	uint32_t plx_control_bits;
 	/* last bits written to plx interrupt control and status register */
@@ -1193,7 +1193,7 @@ static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 }
 
 static unsigned int hw_revision(const struct comedi_device *dev,
-				uint16_t hw_status_bits)
+				u16 hw_status_bits)
 {
 	const struct pcidas64_board *board = dev->board_ptr;
 
@@ -1204,7 +1204,7 @@ static unsigned int hw_revision(const struct comedi_device *dev,
 }
 
 static void set_dac_range_bits(struct comedi_device *dev,
-			       uint16_t *bits, unsigned int channel,
+			       u16 *bits, unsigned int channel,
 			       unsigned int range)
 {
 	const struct pcidas64_board *board = dev->board_ptr;
@@ -1378,7 +1378,7 @@ static int set_ai_fifo_segment_length(struct comedi_device *dev,
 	static const int increment_size = 0x100;
 	const struct hw_fifo_info *const fifo = board->ai_fifo;
 	unsigned int num_increments;
-	uint16_t bits;
+	u16 bits;
 
 	if (num_entries < increment_size)
 		num_entries = increment_size;
@@ -1437,7 +1437,7 @@ static void init_stc_registers(struct comedi_device *dev)
 {
 	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
-	uint16_t bits;
+	u16 bits;
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -2273,8 +2273,8 @@ static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 
 	num_samples = devpriv->ai_fifo_segment_length *
 		      board->ai_fifo->sample_packing_ratio;
-	if (num_samples > DMA_BUFFER_SIZE / sizeof(uint16_t))
-		num_samples = DMA_BUFFER_SIZE / sizeof(uint16_t);
+	if (num_samples > DMA_BUFFER_SIZE / sizeof(u16))
+		num_samples = DMA_BUFFER_SIZE / sizeof(u16);
 
 	return num_samples;
 }
@@ -2634,7 +2634,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		for (i = 0; i < ai_dma_ring_count(board); i++)
 			devpriv->ai_dma_desc[i].transfer_size =
 				cpu_to_le32(dma_transfer_size(dev) *
-					    sizeof(uint16_t));
+					    sizeof(u16));
 
 		/* give location of first dma descriptor */
 		load_first_dma_descriptor(dev, 1,
@@ -2691,7 +2691,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int i;
-	uint16_t prepost_bits;
+	u16 prepost_bits;
 	int read_segment, read_index, write_segment, write_index;
 	int num_samples;
 
@@ -3180,7 +3180,7 @@ static void set_dac_select_reg(struct comedi_device *dev,
 			       const struct comedi_cmd *cmd)
 {
 	struct pcidas64_private *devpriv = dev->private;
-	uint16_t bits;
+	u16 bits;
 	unsigned int first_channel, last_channel;
 
 	first_channel = CR_CHAN(cmd->chanlist[0]);
@@ -3708,7 +3708,7 @@ static int cb_pcidas64_ad8402_insn_write(struct comedi_device *dev,
 	return insn->n;
 }
 
-static uint16_t read_eeprom(struct comedi_device *dev, u8 address)
+static u16 read_eeprom(struct comedi_device *dev, u8 address)
 {
 	struct pcidas64_private *devpriv = dev->private;
 	static const int bitstream_length = 11;
@@ -3717,7 +3717,7 @@ static uint16_t read_eeprom(struct comedi_device *dev, u8 address)
 	unsigned int bit;
 	void __iomem * const plx_control_addr =
 		devpriv->plx9080_iobase + PLX_REG_CNTRL;
-	uint16_t value;
+	u16 value;
 	static const int value_length = 16;
 	static const int eeprom_udelay = 1;
 

commit 7afd6d2179346bdfbd087d39325668d5bc09aa81
Author: Saber Rezvani <irsaber@gmail.com>
Date:   Fri Dec 16 22:45:14 2016 +0330

    staging: comedi: cb_pcidas64: use preferred kernel type u8
    
    Fix the checkpatch.pl issue:
    CHECK: Prefer kernel type 'u8' over 'uint8_t'
    
    Signed-off-by: Saber Rezvani <irsaber@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index cb9c2699277e..55e84d0b32e4 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -418,12 +418,12 @@ enum range_cal_i2c_contents {
 	BNC_TRIG_THRESHOLD_0V_BIT = 0x80,
 };
 
-static inline uint8_t adc_src_4020_bits(unsigned int source)
+static inline u8 adc_src_4020_bits(unsigned int source)
 {
 	return (source << 4) & ADC_SRC_4020_MASK;
 };
 
-static inline uint8_t attenuate_bit(unsigned int channel)
+static inline u8 attenuate_bit(unsigned int channel)
 {
 	/* attenuate channel (+-5V input range) */
 	return 1 << (channel & 0x3);
@@ -443,7 +443,7 @@ static const struct comedi_lrange ai_ranges_64xx = {
 	}
 };
 
-static const uint8_t ai_range_code_64xx[8] = {
+static const u8 ai_range_code_64xx[8] = {
 	0x0, 0x1, 0x2, 0x3,	/* bipolar 10, 5, 2,5, 1.25 */
 	0x8, 0x9, 0xa, 0xb	/* unipolar 10, 5, 2.5, 1.25 */
 };
@@ -461,7 +461,7 @@ static const struct comedi_lrange ai_ranges_64_mx = {
 	}
 };
 
-static const uint8_t ai_range_code_64_mx[7] = {
+static const u8 ai_range_code_64_mx[7] = {
 	0x0, 0x1, 0x2, 0x3,	/* bipolar 5, 2.5, 1.25, 0.625 */
 	0x9, 0xa, 0xb		/* unipolar 5, 2.5, 1.25 */
 };
@@ -476,7 +476,7 @@ static const struct comedi_lrange ai_ranges_60xx = {
 	}
 };
 
-static const uint8_t ai_range_code_60xx[4] = {
+static const u8 ai_range_code_60xx[4] = {
 	0x0, 0x1, 0x4, 0x7	/* bipolar 10, 5, 0.5, 0.05 */
 };
 
@@ -500,7 +500,7 @@ static const struct comedi_lrange ai_ranges_6030 = {
 	}
 };
 
-static const uint8_t ai_range_code_6030[14] = {
+static const u8 ai_range_code_6030[14] = {
 	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, /* bip 10, 5, 2, 1, 0.5, 0.2, 0.1 */
 	0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf  /* uni 10, 5, 2, 1, 0.5, 0.2, 0.1 */
 };
@@ -526,7 +526,7 @@ static const struct comedi_lrange ai_ranges_6052 = {
 	}
 };
 
-static const uint8_t ai_range_code_6052[15] = {
+static const u8 ai_range_code_6052[15] = {
 	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,	/* bipolar 10 ... 0.05 */
 	0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf	/* unipolar 10 ... 0.1 */
 };
@@ -634,7 +634,7 @@ struct pcidas64_board {
 	int ai_bits;		/* analog input resolution */
 	int ai_speed;		/* fastest conversion period in ns */
 	const struct comedi_lrange *ai_range_table;
-	const uint8_t *ai_range_code;
+	const u8 *ai_range_code;
 	int ao_nchan;		/* number of analog out channels */
 	int ao_bits;		/* analog output resolution */
 	int ao_scan_speed;	/* analog output scan speed */
@@ -1175,7 +1175,7 @@ struct pcidas64_private {
 	/* index of calibration source readable through ai ch0 */
 	int calibration_source;
 	/* bits written to i2c calibration/range register */
-	uint8_t i2c_cal_range_bits;
+	u8 i2c_cal_range_bits;
 	/* configure digital triggers to trigger on falling edge */
 	unsigned int ext_trig_falling;
 	short ai_cmd_running;
@@ -1657,9 +1657,9 @@ static void i2c_set_scl(struct comedi_device *dev, int state)
 	}
 }
 
-static void i2c_write_byte(struct comedi_device *dev, uint8_t byte)
+static void i2c_write_byte(struct comedi_device *dev, u8 byte)
 {
-	uint8_t bit;
+	u8 bit;
 	unsigned int num_bits = 8;
 
 	for (bit = 1 << (num_bits - 1); bit; bit >>= 1) {
@@ -1700,11 +1700,11 @@ static void i2c_stop(struct comedi_device *dev)
 }
 
 static void i2c_write(struct comedi_device *dev, unsigned int address,
-		      const uint8_t *data, unsigned int length)
+		      const u8 *data, unsigned int length)
 {
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int i;
-	uint8_t bitstream;
+	u8 bitstream;
 	static const int read_bit = 0x1;
 
 	/*
@@ -1831,7 +1831,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		/* set start channel, and rest of settings */
 		writew(bits, devpriv->main_iobase + ADC_QUEUE_LOAD_REG);
 	} else {
-		uint8_t old_cal_range_bits = devpriv->i2c_cal_range_bits;
+		u8 old_cal_range_bits = devpriv->i2c_cal_range_bits;
 
 		devpriv->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;
 		if (insn->chanspec & CR_ALT_SOURCE) {
@@ -1850,7 +1850,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		 * as it is very slow
 		 */
 		if (old_cal_range_bits != devpriv->i2c_cal_range_bits) {
-			uint8_t i2c_data = devpriv->i2c_cal_range_bits;
+			u8 i2c_data = devpriv->i2c_cal_range_bits;
 
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
 				  sizeof(i2c_data));
@@ -2529,7 +2529,7 @@ static int setup_channel_queue(struct comedi_device *dev,
 		 * as it is very slow
 		 */
 		if (old_cal_range_bits != devpriv->i2c_cal_range_bits) {
-			uint8_t i2c_data = devpriv->i2c_cal_range_bits;
+			u8 i2c_data = devpriv->i2c_cal_range_bits;
 
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
 				  sizeof(i2c_data));
@@ -2831,7 +2831,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	uint8_t dma1_status;
+	u8 dma1_status;
 	unsigned long flags;
 
 	/* check for fifo overrun */
@@ -3008,7 +3008,7 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_async *async;
 	struct comedi_cmd *cmd;
-	uint8_t dma0_status;
+	u8 dma0_status;
 	unsigned long flags;
 
 	/* board might not support ao, in which case write_subdev is NULL */
@@ -3523,7 +3523,7 @@ static int dio_60xx_wbits(struct comedi_device *dev,
  */
 
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-			     uint8_t value)
+			     u8 value)
 {
 	struct pcidas64_private *devpriv = dev->private;
 	static const int num_caldac_channels = 8;
@@ -3558,8 +3558,8 @@ static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 static int caldac_i2c_write(struct comedi_device *dev,
 			    unsigned int caldac_channel, unsigned int value)
 {
-	uint8_t serial_bytes[3];
-	uint8_t i2c_addr;
+	u8 serial_bytes[3];
+	u8 i2c_addr;
 	enum pointer_bits {
 		/* manual has gain and offset bits switched */
 		OFFSET_0_2 = 0x1,
@@ -3708,7 +3708,7 @@ static int cb_pcidas64_ad8402_insn_write(struct comedi_device *dev,
 	return insn->n;
 }
 
-static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
+static uint16_t read_eeprom(struct comedi_device *dev, u8 address)
 {
 	struct pcidas64_private *devpriv = dev->private;
 	static const int bitstream_length = 11;
@@ -3813,7 +3813,7 @@ static int setup_subdevices(struct comedi_device *dev)
 	s->do_cmdtest = ai_cmdtest;
 	s->cancel = ai_cancel;
 	if (board->layout == LAYOUT_4020) {
-		uint8_t data;
+		u8 data;
 		/*
 		 * set adc to read from inputs
 		 * (not internal calibration sources)

commit 9f963096984d0296ce821727310e3cf923b1ef8d
Author: Anson Jacob <ansonjacob.aj@gmail.com>
Date:   Fri Aug 26 19:14:35 2016 -0400

    staging: comedi: cb_pcidas64: Fix checkpath warning
    
    Fix checkpatch.pl warning:
    Please use a blank line after function/struct/union/enum declarations
    
    Move macro definition to the top of the file
    Aligne macro definitions
    
    Signed-off-by: Anson Jacob <ansonjacob.aj@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index ac24c10320a6..cb9c2699277e 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -94,7 +94,8 @@
  * maybe I'll support this someday
  */
 #define PRESCALED_TIMER_BASE	10000
-#define DMA_BUFFER_SIZE 0x1000
+#define DMA_BUFFER_SIZE		0x1000
+#define DAC_FIFO_SIZE		0x2000
 
 /* maximum value that can be loaded into board's 24-bit counters */
 static const int max_counter_value = 0xffffff;
@@ -227,7 +228,6 @@ enum hw_config_contents {
 	DAC_FIFO_SIZE_MASK = 0xff00,	/* bits that set dac fifo size */
 	DAC_FIFO_BITS = 0xf800,		/* 8k sample ao fifo */
 };
-#define DAC_FIFO_SIZE 0x2000
 
 enum daq_atrig_low_4020_contents {
 	/* use trig/ext clk bnc input for analog gate signal */

commit 12f992adeb6bb1b3cc8c7190cb5b927c8ed9cc33
Author: Anson Jacob <ansonjacob.aj@gmail.com>
Date:   Fri Aug 26 19:13:04 2016 -0400

    staging: comedi: cb_pcidas64: Fix commenting style
    
    Remove additional space after /*
    Convert single line block comment into single line comment
    
    Signed-off-by: Anson Jacob <ansonjacob.aj@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 281dc56c75f1..ac24c10320a6 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -169,8 +169,8 @@ enum read_only_registers {
 };
 
 enum read_write_registers {
-	I8255_4020_REG = 0x48,	/*  8255 offset, for 4020 only */
-	/*  external channel/gain queue, uses same bits as ADC_QUEUE_LOAD_REG */
+	I8255_4020_REG = 0x48,	/* 8255 offset, for 4020 only */
+	/* external channel/gain queue, uses same bits as ADC_QUEUE_LOAD_REG */
 	ADC_QUEUE_FIFO_REG = 0x100,
 	ADC_FIFO_REG = 0x200,	/* adc data fifo */
 	/* dac data fifo, has weird interactions with external channel queue */
@@ -189,51 +189,52 @@ enum dio_counter_registers {
 /* bit definitions for write-only registers */
 
 enum intr_enable_contents {
-	ADC_INTR_SRC_MASK = 0x3,	/*  adc interrupt source mask */
-	ADC_INTR_QFULL_BITS = 0x0,	/*  interrupt fifo quarter full */
-	ADC_INTR_EOC_BITS = 0x1,	/*  interrupt end of conversion */
-	ADC_INTR_EOSCAN_BITS = 0x2,	/*  interrupt end of scan */
-	ADC_INTR_EOSEQ_BITS = 0x3,	/*  interrupt end of sequence mask */
-	EN_ADC_INTR_SRC_BIT = 0x4,	/*  enable adc interrupt source */
-	EN_ADC_DONE_INTR_BIT = 0x8,	/*  enable adc acquisition done intr */
+	ADC_INTR_SRC_MASK = 0x3,	/* adc interrupt source mask */
+	ADC_INTR_QFULL_BITS = 0x0,	/* interrupt fifo quarter full */
+	ADC_INTR_EOC_BITS = 0x1,	/* interrupt end of conversion */
+	ADC_INTR_EOSCAN_BITS = 0x2,	/* interrupt end of scan */
+	ADC_INTR_EOSEQ_BITS = 0x3,	/* interrupt end of sequence mask */
+	EN_ADC_INTR_SRC_BIT = 0x4,	/* enable adc interrupt source */
+	EN_ADC_DONE_INTR_BIT = 0x8,	/* enable adc acquisition done intr */
 	DAC_INTR_SRC_MASK = 0x30,
 	DAC_INTR_QEMPTY_BITS = 0x0,
 	DAC_INTR_HIGH_CHAN_BITS = 0x10,
-	EN_DAC_INTR_SRC_BIT = 0x40,	/*  enable dac interrupt source */
+	EN_DAC_INTR_SRC_BIT = 0x40,	/* enable dac interrupt source */
 	EN_DAC_DONE_INTR_BIT = 0x80,
-	EN_ADC_ACTIVE_INTR_BIT = 0x200,	/*  enable adc active interrupt */
-	EN_ADC_STOP_INTR_BIT = 0x400,	/*  enable adc stop trigger interrupt */
-	EN_DAC_ACTIVE_INTR_BIT = 0x800,	/*  enable dac active interrupt */
-	EN_DAC_UNDERRUN_BIT = 0x4000,	/*  enable dac underrun status bit */
-	EN_ADC_OVERRUN_BIT = 0x8000,	/*  enable adc overrun status bit */
+	EN_ADC_ACTIVE_INTR_BIT = 0x200,	/* enable adc active interrupt */
+	EN_ADC_STOP_INTR_BIT = 0x400,	/* enable adc stop trigger interrupt */
+	EN_DAC_ACTIVE_INTR_BIT = 0x800,	/* enable dac active interrupt */
+	EN_DAC_UNDERRUN_BIT = 0x4000,	/* enable dac underrun status bit */
+	EN_ADC_OVERRUN_BIT = 0x8000,	/* enable adc overrun status bit */
 };
 
 enum hw_config_contents {
-	MASTER_CLOCK_4020_MASK = 0x3,	/*  master clock source mask for 4020 */
-	INTERNAL_CLOCK_4020_BITS = 0x1,	/*  use 40 MHz internal master clock */
-	BNC_CLOCK_4020_BITS = 0x2,	/*  use BNC input for master clock */
-	EXT_CLOCK_4020_BITS = 0x3,	/*  use dio input for master clock */
-	EXT_QUEUE_BIT = 0x200,		/*  use external channel/gain queue */
-	/*  use 225 nanosec strobe when loading dac instead of 50 nanosec */
+	MASTER_CLOCK_4020_MASK = 0x3,	/* master clock source mask for 4020 */
+	INTERNAL_CLOCK_4020_BITS = 0x1,	/* use 40 MHz internal master clock */
+	BNC_CLOCK_4020_BITS = 0x2,	/* use BNC input for master clock */
+	EXT_CLOCK_4020_BITS = 0x3,	/* use dio input for master clock */
+	EXT_QUEUE_BIT = 0x200,		/* use external channel/gain queue */
+	/* use 225 nanosec strobe when loading dac instead of 50 nanosec */
 	SLOW_DAC_BIT = 0x400,
-	/*  bit with unknown function yet given as default value in pci-das64
-	 *  manual
+	/*
+	 * bit with unknown function yet given as default value in pci-das64
+	 * manual
 	 */
 	HW_CONFIG_DUMMY_BITS = 0x2000,
-	/*  bit selects channels 1/0 for analog input/output, otherwise 0/1 */
+	/* bit selects channels 1/0 for analog input/output, otherwise 0/1 */
 	DMA_CH_SELECT_BIT = 0x8000,
-	FIFO_SIZE_REG = 0x4,		/*  allows adjustment of fifo sizes */
-	DAC_FIFO_SIZE_MASK = 0xff00,	/*  bits that set dac fifo size */
-	DAC_FIFO_BITS = 0xf800,		/*  8k sample ao fifo */
+	FIFO_SIZE_REG = 0x4,		/* allows adjustment of fifo sizes */
+	DAC_FIFO_SIZE_MASK = 0xff00,	/* bits that set dac fifo size */
+	DAC_FIFO_BITS = 0xf800,		/* 8k sample ao fifo */
 };
 #define DAC_FIFO_SIZE 0x2000
 
 enum daq_atrig_low_4020_contents {
-	/*  use trig/ext clk bnc input for analog gate signal */
+	/* use trig/ext clk bnc input for analog gate signal */
 	EXT_AGATE_BNC_BIT = 0x8000,
-	/*  use trig/ext clk bnc input for external stop trigger signal */
+	/* use trig/ext clk bnc input for external stop trigger signal */
 	EXT_STOP_TRIG_BNC_BIT = 0x4000,
-	/*  use trig/ext clk bnc input for external start trigger signal */
+	/* use trig/ext clk bnc input for external start trigger signal */
 	EXT_START_TRIG_BNC_BIT = 0x2000,
 };
 
@@ -243,38 +244,38 @@ static inline uint16_t analog_trig_low_threshold_bits(uint16_t threshold)
 }
 
 enum adc_control0_contents {
-	ADC_GATE_SRC_MASK = 0x3,	/*  bits that select gate */
-	ADC_SOFT_GATE_BITS = 0x1,	/*  software gate */
-	ADC_EXT_GATE_BITS = 0x2,	/*  external digital gate */
-	ADC_ANALOG_GATE_BITS = 0x3,	/*  analog level gate */
-	/*  level-sensitive gate (for digital) */
+	ADC_GATE_SRC_MASK = 0x3,	/* bits that select gate */
+	ADC_SOFT_GATE_BITS = 0x1,	/* software gate */
+	ADC_EXT_GATE_BITS = 0x2,	/* external digital gate */
+	ADC_ANALOG_GATE_BITS = 0x3,	/* analog level gate */
+	/* level-sensitive gate (for digital) */
 	ADC_GATE_LEVEL_BIT = 0x4,
-	ADC_GATE_POLARITY_BIT = 0x8,	/*  gate active low */
+	ADC_GATE_POLARITY_BIT = 0x8,	/* gate active low */
 	ADC_START_TRIG_SOFT_BITS = 0x10,
 	ADC_START_TRIG_EXT_BITS = 0x20,
 	ADC_START_TRIG_ANALOG_BITS = 0x30,
 	ADC_START_TRIG_MASK = 0x30,
-	ADC_START_TRIG_FALLING_BIT = 0x40,	/*  trig 1 uses falling edge */
-	/*  external pacing uses falling edge */
+	ADC_START_TRIG_FALLING_BIT = 0x40,	/* trig 1 uses falling edge */
+	/* external pacing uses falling edge */
 	ADC_EXT_CONV_FALLING_BIT = 0x800,
-	/*  enable hardware scan counter */
+	/* enable hardware scan counter */
 	ADC_SAMPLE_COUNTER_EN_BIT = 0x1000,
-	ADC_DMA_DISABLE_BIT = 0x4000,	/*  disables dma */
-	ADC_ENABLE_BIT = 0x8000,	/*  master adc enable */
+	ADC_DMA_DISABLE_BIT = 0x4000,	/* disables dma */
+	ADC_ENABLE_BIT = 0x8000,	/* master adc enable */
 };
 
 enum adc_control1_contents {
-	/*  should be set for boards with > 16 channels */
+	/* should be set for boards with > 16 channels */
 	ADC_QUEUE_CONFIG_BIT = 0x1,
 	CONVERT_POLARITY_BIT = 0x10,
 	EOC_POLARITY_BIT = 0x20,
-	ADC_SW_GATE_BIT = 0x40,	/*  software gate of adc */
-	ADC_DITHER_BIT = 0x200,	/*  turn on extra noise for dithering */
+	ADC_SW_GATE_BIT = 0x40,		/* software gate of adc */
+	ADC_DITHER_BIT = 0x200,		/* turn on extra noise for dithering */
 	RETRIGGER_BIT = 0x800,
 	ADC_LO_CHANNEL_4020_MASK = 0x300,
 	ADC_HI_CHANNEL_4020_MASK = 0xc00,
-	TWO_CHANNEL_4020_BITS = 0x1000,	/*  two channel mode for 4020 */
-	FOUR_CHANNEL_4020_BITS = 0x2000, /*  four channel mode for 4020 */
+	TWO_CHANNEL_4020_BITS = 0x1000,		/* two channel mode for 4020 */
+	FOUR_CHANNEL_4020_BITS = 0x2000,	/* four channel mode for 4020 */
 	CHANNEL_MODE_4020_MASK = 0x3000,
 	ADC_MODE_MASK = 0xf000,
 };
@@ -298,10 +299,10 @@ enum calibration_contents {
 	SELECT_8800_BIT = 0x1,
 	SELECT_8402_64XX_BIT = 0x2,
 	SELECT_1590_60XX_BIT = 0x2,
-	CAL_EN_64XX_BIT = 0x40,	/*  calibration enable for 64xx series */
+	CAL_EN_64XX_BIT = 0x40,		/* calibration enable for 64xx series */
 	SERIAL_DATA_IN_BIT = 0x80,
 	SERIAL_CLOCK_BIT = 0x100,
-	CAL_EN_60XX_BIT = 0x200, /*  calibration enable for 60xx series */
+	CAL_EN_60XX_BIT = 0x200,	/* calibration enable for 60xx series */
 	CAL_GAIN_BIT = 0x800,
 };
 
@@ -328,12 +329,12 @@ static inline uint16_t adc_convert_chan_4020_bits(unsigned int channel)
 };
 
 enum adc_queue_load_contents {
-	UNIP_BIT = 0x800,	/*  unipolar/bipolar bit */
-	ADC_SE_DIFF_BIT = 0x1000,	/*  single-ended/ differential bit */
-	/*  non-referenced single-ended (common-mode input) */
+	UNIP_BIT = 0x800,		/* unipolar/bipolar bit */
+	ADC_SE_DIFF_BIT = 0x1000,	/* single-ended/ differential bit */
+	/* non-referenced single-ended (common-mode input) */
 	ADC_COMMON_BIT = 0x2000,
-	QUEUE_EOSEQ_BIT = 0x4000,	/*  queue end of sequence */
-	QUEUE_EOSCAN_BIT = 0x8000,	/*  queue end of scan */
+	QUEUE_EOSEQ_BIT = 0x4000,	/* queue end of sequence */
+	QUEUE_EOSCAN_BIT = 0x8000,	/* queue end of scan */
 };
 
 static inline uint16_t adc_chan_bits(unsigned int channel)
@@ -342,7 +343,7 @@ static inline uint16_t adc_chan_bits(unsigned int channel)
 };
 
 enum dac_control0_contents {
-	DAC_ENABLE_BIT = 0x8000,	/*  dac controller enable bit */
+	DAC_ENABLE_BIT = 0x8000,	/* dac controller enable bit */
 	DAC_CYCLIC_STOP_BIT = 0x4000,
 	DAC_WAVEFORM_MODE_BIT = 0x100,
 	DAC_EXT_UPDATE_FALLING_BIT = 0x80,
@@ -362,7 +363,7 @@ enum dac_control1_contents {
 	DAC_WRITE_POLARITY_BIT = 0x800,	/* board-dependent setting */
 	DAC1_EXT_REF_BIT = 0x200,
 	DAC0_EXT_REF_BIT = 0x100,
-	DAC_OUTPUT_ENABLE_BIT = 0x80,	/*  dac output enable bit */
+	DAC_OUTPUT_ENABLE_BIT = 0x80,	/* dac output enable bit */
 	DAC_UPDATE_POLARITY_BIT = 0x40,	/* board-dependent setting */
 	DAC_SW_GATE_BIT = 0x20,
 	DAC1_UNIPOLAR_BIT = 0x8,
@@ -411,9 +412,9 @@ enum i2c_addresses {
 };
 
 enum range_cal_i2c_contents {
-	/*  bits that set what source the adc converter measures */
+	/* bits that set what source the adc converter measures */
 	ADC_SRC_4020_MASK = 0x70,
-	/*  make bnc trig/ext clock threshold 0V instead of 2.5V */
+	/* make bnc trig/ext clock threshold 0V instead of 2.5V */
 	BNC_TRIG_THRESHOLD_0V_BIT = 0x80,
 };
 
@@ -424,7 +425,7 @@ static inline uint8_t adc_src_4020_bits(unsigned int source)
 
 static inline uint8_t attenuate_bit(unsigned int channel)
 {
-	/*  attenuate channel (+-5V input range) */
+	/* attenuate channel (+-5V input range) */
 	return 1 << (channel & 0x3);
 };
 
@@ -629,18 +630,18 @@ enum pcidas64_boardid {
 
 struct pcidas64_board {
 	const char *name;
-	int ai_se_chans;	/*  number of ai inputs in single-ended mode */
-	int ai_bits;		/*  analog input resolution */
-	int ai_speed;		/*  fastest conversion period in ns */
+	int ai_se_chans;	/* number of ai inputs in single-ended mode */
+	int ai_bits;		/* analog input resolution */
+	int ai_speed;		/* fastest conversion period in ns */
 	const struct comedi_lrange *ai_range_table;
 	const uint8_t *ai_range_code;
-	int ao_nchan;		/*  number of analog out channels */
-	int ao_bits;		/*  analog output resolution */
-	int ao_scan_speed;	/*  analog output scan speed */
+	int ao_nchan;		/* number of analog out channels */
+	int ao_bits;		/* analog output resolution */
+	int ao_scan_speed;	/* analog output scan speed */
 	const struct comedi_lrange *ao_range_table;
 	const int *ao_range_code;
 	const struct hw_fifo_info *const ai_fifo;
-	/*  different board families have slightly different registers */
+	/* different board families have slightly different registers */
 	enum register_layout layout;
 	unsigned has_8255:1;
 };
@@ -701,7 +702,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.has_8255	= 1,
 	},
 	[BOARD_PCIDAS6402_12] = {
-		.name		= "pci-das6402/12",	/*  XXX check */
+		.name		= "pci-das6402/12",	/* XXX check */
 		.ai_se_chans	= 64,
 		.ai_bits	= 12,
 		.ai_speed	= 5000,
@@ -998,7 +999,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ai_speed	= 50,
 		.ao_bits	= 12,
 		.ao_nchan	= 2,
-		.ao_scan_speed	= 0,	/*  no hardware pacing on ao */
+		.ao_scan_speed	= 0,	/* no hardware pacing on ao */
 		.layout		= LAYOUT_4020,
 		.ai_range_table	= &ai_ranges_4020,
 		.ao_range_table	= &ao_ranges_4020,
@@ -1007,9 +1008,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.has_8255	= 1,
 	},
 #if 0
-	/*
-	 * The device id for these boards is unknown
-	 */
+	/* The device id for these boards is unknown */
 
 	[BOARD_PCIDAS6402_16_JR] = {
 		.name		= "pci-das6402/16/jr",
@@ -1118,64 +1117,66 @@ static inline unsigned short se_diff_bit_6xxx(struct comedi_device *dev,
 }
 
 struct ext_clock_info {
-	/*  master clock divisor to use for scans with external master clock */
+	/* master clock divisor to use for scans with external master clock */
 	unsigned int divisor;
-	/*  chanspec for master clock input when used as scan begin src */
+	/* chanspec for master clock input when used as scan begin src */
 	unsigned int chanspec;
 };
 
 /* this structure is for data unique to this hardware driver. */
 struct pcidas64_private {
-	/*  base addresses (physical) */
+	/* base addresses (physical) */
 	resource_size_t main_phys_iobase;
 	resource_size_t dio_counter_phys_iobase;
-	/*  base addresses (ioremapped) */
+	/* base addresses (ioremapped) */
 	void __iomem *plx9080_iobase;
 	void __iomem *main_iobase;
-	/*  local address (used by dma controller) */
+	/* local address (used by dma controller) */
 	uint32_t local0_iobase;
 	uint32_t local1_iobase;
-	/*  dma buffers for analog input */
+	/* dma buffers for analog input */
 	uint16_t *ai_buffer[MAX_AI_DMA_RING_COUNT];
-	/*  physical addresses of ai dma buffers */
+	/* physical addresses of ai dma buffers */
 	dma_addr_t ai_buffer_bus_addr[MAX_AI_DMA_RING_COUNT];
-	/*  array of ai dma descriptors read by plx9080,
-	 *  allocated to get proper alignment
+	/*
+	 * array of ai dma descriptors read by plx9080,
+	 * allocated to get proper alignment
 	 */
 	struct plx_dma_desc *ai_dma_desc;
-	/*  physical address of ai dma descriptor array */
+	/* physical address of ai dma descriptor array */
 	dma_addr_t ai_dma_desc_bus_addr;
-	/*  index of the ai dma descriptor/buffer
-	 *  that is currently being used
+	/*
+	 * index of the ai dma descriptor/buffer
+	 * that is currently being used
 	 */
 	unsigned int ai_dma_index;
-	/*  dma buffers for analog output */
+	/* dma buffers for analog output */
 	uint16_t *ao_buffer[AO_DMA_RING_COUNT];
-	/*  physical addresses of ao dma buffers */
+	/* physical addresses of ao dma buffers */
 	dma_addr_t ao_buffer_bus_addr[AO_DMA_RING_COUNT];
 	struct plx_dma_desc *ao_dma_desc;
 	dma_addr_t ao_dma_desc_bus_addr;
-	/*  keeps track of buffer where the next ao sample should go */
+	/* keeps track of buffer where the next ao sample should go */
 	unsigned int ao_dma_index;
-	unsigned int hw_revision;	/*  stc chip hardware revision number */
-	/*  last bits sent to INTR_ENABLE_REG register */
+	unsigned int hw_revision;	/* stc chip hardware revision number */
+	/* last bits sent to INTR_ENABLE_REG register */
 	unsigned int intr_enable_bits;
-	/*  last bits sent to ADC_CONTROL1_REG register */
+	/* last bits sent to ADC_CONTROL1_REG register */
 	uint16_t adc_control1_bits;
-	/*  last bits sent to FIFO_SIZE_REG register */
+	/* last bits sent to FIFO_SIZE_REG register */
 	uint16_t fifo_size_bits;
-	/*  last bits sent to HW_CONFIG_REG register */
+	/* last bits sent to HW_CONFIG_REG register */
 	uint16_t hw_config_bits;
 	uint16_t dac_control1_bits;
-	/*  last bits written to plx9080 control register */
+	/* last bits written to plx9080 control register */
 	uint32_t plx_control_bits;
-	/*  last bits written to plx interrupt control and status register */
+	/* last bits written to plx interrupt control and status register */
 	uint32_t plx_intcsr_bits;
-	/*  index of calibration source readable through ai ch0 */
+	/* index of calibration source readable through ai ch0 */
 	int calibration_source;
-	/*  bits written to i2c calibration/range register */
+	/* bits written to i2c calibration/range register */
 	uint8_t i2c_cal_range_bits;
-	/*  configure digital triggers to trigger on falling edge */
+	/* configure digital triggers to trigger on falling edge */
 	unsigned int ext_trig_falling;
 	short ai_cmd_running;
 	unsigned int ai_fifo_segment_length;
@@ -1228,7 +1229,7 @@ static void abort_dma(struct comedi_device *dev, unsigned int channel)
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned long flags;
 
-	/*  spinlock for plx dma control/status reg */
+	/* spinlock for plx dma control/status reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 
 	plx9080_abort_dma(devpriv->plx9080_iobase, channel);
@@ -1275,7 +1276,7 @@ static void enable_ai_interrupts(struct comedi_device *dev,
 	 * if CMDF_WAKE_EOS flag is set.
 	 */
 	if (cmd->flags & CMDF_WAKE_EOS) {
-		/*  4020 doesn't support pio transfers except for fifo dregs */
+		/* 4020 doesn't support pio transfers except for fifo dregs */
 		if (board->layout != LAYOUT_4020)
 			bits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;
 	}
@@ -1309,38 +1310,40 @@ static void init_plx9080(struct comedi_device *dev)
 	abort_dma(dev, 0);
 	abort_dma(dev, 1);
 
-	/*  configure dma0 mode */
+	/* configure dma0 mode */
 	bits = 0;
-	/*  enable ready input, not sure if this is necessary */
+	/* enable ready input, not sure if this is necessary */
 	bits |= PLX_DMAMODE_READYIEN;
-	/*  enable bterm, not sure if this is necessary */
+	/* enable bterm, not sure if this is necessary */
 	bits |= PLX_DMAMODE_BTERMIEN;
-	/*  enable dma chaining */
+	/* enable dma chaining */
 	bits |= PLX_DMAMODE_CHAINEN;
-	/*  enable interrupt on dma done
-	 *  (probably don't need this, since chain never finishes)
+	/*
+	 * enable interrupt on dma done
+	 * (probably don't need this, since chain never finishes)
 	 */
 	bits |= PLX_DMAMODE_DONEIEN;
-	/*  don't increment local address during transfers
-	 *  (we are transferring from a fixed fifo register)
+	/*
+	 * don't increment local address during transfers
+	 * (we are transferring from a fixed fifo register)
 	 */
 	bits |= PLX_DMAMODE_LACONST;
-	/*  route dma interrupt to pci bus */
+	/* route dma interrupt to pci bus */
 	bits |= PLX_DMAMODE_INTRPCI;
-	/*  enable demand mode */
+	/* enable demand mode */
 	bits |= PLX_DMAMODE_DEMAND;
-	/*  enable local burst mode */
+	/* enable local burst mode */
 	bits |= PLX_DMAMODE_BURSTEN;
-	/*  4020 uses 32 bit dma */
+	/* 4020 uses 32 bit dma */
 	if (board->layout == LAYOUT_4020)
 		bits |= PLX_DMAMODE_WIDTH_32;
-	else		/*  localspace0 bus is 16 bits wide */
+	else				/* localspace0 bus is 16 bits wide */
 		bits |= PLX_DMAMODE_WIDTH_16;
 	writel(bits, plx_iobase + PLX_REG_DMAMODE1);
 	if (ao_cmd_is_supported(board))
 		writel(bits, plx_iobase + PLX_REG_DMAMODE0);
 
-	/*  enable interrupts on plx 9080 */
+	/* enable interrupts on plx 9080 */
 	devpriv->plx_intcsr_bits |=
 	    PLX_INTCSR_LSEABORTEN | PLX_INTCSR_LSEPARITYEN | PLX_INTCSR_PIEN |
 	    PLX_INTCSR_PLIEN | PLX_INTCSR_PABORTIEN | PLX_INTCSR_LIOEN |
@@ -1382,7 +1385,7 @@ static int set_ai_fifo_segment_length(struct comedi_device *dev,
 	if (num_entries > fifo->max_segment_length)
 		num_entries = fifo->max_segment_length;
 
-	/*  1 == 256 entries, 2 == 512 entries, etc */
+	/* 1 == 256 entries, 2 == 512 entries, etc */
 	num_increments = DIV_ROUND_CLOSEST(num_entries, increment_size);
 
 	bits = (~(num_increments - 1)) & fifo->fifo_size_reg_mask;
@@ -1448,7 +1451,7 @@ static void init_stc_registers(struct comedi_device *dev)
 	writew(devpriv->adc_control1_bits,
 	       devpriv->main_iobase + ADC_CONTROL1_REG);
 
-	/*  6402/16 manual says this register must be initialized to 0xff? */
+	/* 6402/16 manual says this register must be initialized to 0xff? */
 	writew(0xff, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
 
 	bits = SLOW_DAC_BIT | DMA_CH_SELECT_BIT;
@@ -1463,7 +1466,7 @@ static void init_stc_registers(struct comedi_device *dev)
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  set fifos to maximum size */
+	/* set fifos to maximum size */
 	devpriv->fifo_size_bits |= DAC_FIFO_BITS;
 	set_ai_fifo_segment_length(dev, board->ai_fifo->max_segment_length);
 
@@ -1484,7 +1487,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	struct pcidas64_private *devpriv = dev->private;
 	int i;
 
-	/*  allocate pci dma buffers */
+	/* allocate pci dma buffers */
 	for (i = 0; i < ai_dma_ring_count(board); i++) {
 		devpriv->ai_buffer[i] =
 			dma_alloc_coherent(&pcidev->dev, DMA_BUFFER_SIZE,
@@ -1505,7 +1508,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 				return -ENOMEM;
 		}
 	}
-	/*  allocate dma descriptors */
+	/* allocate dma descriptors */
 	devpriv->ai_dma_desc =
 		dma_alloc_coherent(&pcidev->dev, sizeof(struct plx_dma_desc) *
 				   ai_dma_ring_count(board),
@@ -1523,7 +1526,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 		if (!devpriv->ao_dma_desc)
 			return -ENOMEM;
 	}
-	/*  initialize dma descriptors */
+	/* initialize dma descriptors */
 	for (i = 0; i < ai_dma_ring_count(board); i++) {
 		devpriv->ai_dma_desc[i].pci_start_addr =
 			cpu_to_le32(devpriv->ai_buffer_bus_addr[i]);
@@ -1624,13 +1627,11 @@ static void i2c_set_sda(struct comedi_device *dev, int state)
 	void __iomem *plx_control_addr = devpriv->plx9080_iobase +
 					 PLX_REG_CNTRL;
 
-	if (state) {
-		/*  set data line high */
+	if (state) {				/* set data line high */
 		devpriv->plx_control_bits &= ~data_bit;
 		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(i2c_high_udelay);
-	} else {		/*  set data line low */
-
+	} else {				/* set data line low */
 		devpriv->plx_control_bits |= data_bit;
 		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(i2c_low_udelay);
@@ -1645,13 +1646,11 @@ static void i2c_set_scl(struct comedi_device *dev, int state)
 	void __iomem *plx_control_addr = devpriv->plx9080_iobase +
 					 PLX_REG_CNTRL;
 
-	if (state) {
-		/*  set clock line high */
+	if (state) {				/* set clock line high */
 		devpriv->plx_control_bits &= ~clock_bit;
 		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(i2c_high_udelay);
-	} else {		/*  set clock line low */
-
+	} else {				/* set clock line low */
 		devpriv->plx_control_bits |= clock_bit;
 		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(i2c_low_udelay);
@@ -1680,7 +1679,7 @@ static int i2c_read_ack(struct comedi_device *dev)
 	i2c_set_sda(dev, 1);
 	i2c_set_scl(dev, 1);
 
-	return 0;		/*  return fake acknowledge bit */
+	return 0;		/* return fake acknowledge bit */
 }
 
 /* send start bit */
@@ -1713,23 +1712,23 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 	 * eeprom and i2c bus
 	 */
 
-	/*  make sure we dont send anything to eeprom */
+	/* make sure we dont send anything to eeprom */
 	devpriv->plx_control_bits &= ~PLX_CNTRL_EECS;
 
 	i2c_stop(dev);
 	i2c_start(dev);
 
-	/*  send address and write bit */
+	/* send address and write bit */
 	bitstream = (address << 1) & ~read_bit;
 	i2c_write_byte(dev, bitstream);
 
-	/*  get acknowledge */
+	/* get acknowledge */
 	if (i2c_read_ack(dev) != 0) {
 		dev_err(dev->class_dev, "failed: no acknowledge\n");
 		i2c_stop(dev);
 		return;
 	}
-	/*  write data bytes */
+	/* write data bytes */
 	for (i = 0; i < length; i++) {
 		i2c_write_byte(dev, data[i]);
 		if (i2c_read_ack(dev) != 0) {
@@ -1776,8 +1775,8 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	range = CR_RANGE(insn->chanspec);
 	aref = CR_AREF(insn->chanspec);
 
-	/*  disable card's analog input interrupt sources and pacing */
-	/*  4020 generates dac done interrupts even though they are disabled */
+	/* disable card's analog input interrupt sources and pacing */
+	/* 4020 generates dac done interrupts even though they are disabled */
 	disable_ai_pacing(dev);
 
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -1790,12 +1789,12 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (board->layout != LAYOUT_4020) {
-		/*  use internal queue */
+		/* use internal queue */
 		devpriv->hw_config_bits &= ~EXT_QUEUE_BIT;
 		writew(devpriv->hw_config_bits,
 		       devpriv->main_iobase + HW_CONFIG_REG);
 
-		/*  ALT_SOURCE is internal calibration reference */
+		/* ALT_SOURCE is internal calibration reference */
 		if (insn->chanspec & CR_ALT_SOURCE) {
 			unsigned int cal_en_bit;
 
@@ -1817,19 +1816,19 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			 */
 			writew(0, devpriv->main_iobase + CALIBRATION_REG);
 		}
-		/*  load internal queue */
+		/* load internal queue */
 		bits = 0;
-		/*  set gain */
+		/* set gain */
 		bits |= ai_range_bits_6xxx(dev, CR_RANGE(insn->chanspec));
-		/*  set single-ended / differential */
+		/* set single-ended / differential */
 		bits |= se_diff_bit_6xxx(dev, aref == AREF_DIFF);
 		if (aref == AREF_COMMON)
 			bits |= ADC_COMMON_BIT;
 		bits |= adc_chan_bits(channel);
-		/*  set stop channel */
+		/* set stop channel */
 		writew(adc_chan_bits(channel),
 		       devpriv->main_iobase + ADC_QUEUE_HIGH_REG);
-		/*  set start channel, and rest of settings */
+		/* set start channel, and rest of settings */
 		writew(bits, devpriv->main_iobase + ADC_QUEUE_LOAD_REG);
 	} else {
 		uint8_t old_cal_range_bits = devpriv->i2c_cal_range_bits;
@@ -1841,7 +1840,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		} else {	/* select BNC inputs */
 			devpriv->i2c_cal_range_bits |= adc_src_4020_bits(4);
 		}
-		/*  select range */
+		/* select range */
 		if (range == 0)
 			devpriv->i2c_cal_range_bits |= attenuate_bit(channel);
 		else
@@ -1868,14 +1867,14 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	}
 
 	for (n = 0; n < insn->n; n++) {
-		/*  clear adc buffer (inside loop for 4020 sake) */
+		/* clear adc buffer (inside loop for 4020 sake) */
 		writew(0, devpriv->main_iobase + ADC_BUFFER_CLEAR_REG);
 
 		/* trigger conversion, bits sent only matter for 4020 */
 		writew(adc_convert_chan_4020_bits(CR_CHAN(insn->chanspec)),
 		       devpriv->main_iobase + ADC_CONVERT_REG);
 
-		/*  wait for data */
+		/* wait for data */
 		ret = comedi_timeout(dev, s, insn, cb_pcidas64_ai_eoc, 0);
 		if (ret)
 			return ret;
@@ -2255,7 +2254,7 @@ static void setup_sample_counters(struct comedi_device *dev,
 {
 	struct pcidas64_private *devpriv = dev->private;
 
-	/*  load hardware conversion counter */
+	/* load hardware conversion counter */
 	if (use_hw_sample_counter(cmd)) {
 		writew(cmd->stop_arg & 0xffff,
 		       devpriv->main_iobase + ADC_COUNT_LOWER_REG);
@@ -2283,7 +2282,7 @@ static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 static uint32_t ai_convert_counter_6xxx(const struct comedi_device *dev,
 					const struct comedi_cmd *cmd)
 {
-	/*  supposed to load counter with desired divisor minus 3 */
+	/* supposed to load counter with desired divisor minus 3 */
 	return cmd->convert_arg / TIMER_BASE - 3;
 }
 
@@ -2292,7 +2291,7 @@ static uint32_t ai_scan_counter_6xxx(struct comedi_device *dev,
 {
 	uint32_t count;
 
-	/*  figure out how long we need to delay at end of scan */
+	/* figure out how long we need to delay at end of scan */
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
 		count = (cmd->scan_begin_arg -
@@ -2321,13 +2320,13 @@ static uint32_t ai_convert_counter_4020(struct comedi_device *dev,
 	case TRIG_OTHER:
 		divisor = devpriv->ext_clock.divisor;
 		break;
-	default:		/*  should never happen */
+	default:		/* should never happen */
 		dev_err(dev->class_dev, "bug! failed to set ai pacing!\n");
 		divisor = 1000;
 		break;
 	}
 
-	/*  supposed to load counter with desired divisor minus 2 for 4020 */
+	/* supposed to load counter with desired divisor minus 2 for 4020 */
 	return divisor - 2;
 }
 
@@ -2336,7 +2335,7 @@ static void select_master_clock_4020(struct comedi_device *dev,
 {
 	struct pcidas64_private *devpriv = dev->private;
 
-	/*  select internal/external master clock */
+	/* select internal/external master clock */
 	devpriv->hw_config_bits &= ~MASTER_CLOCK_4020_MASK;
 	if (cmd->scan_begin_src == TRIG_OTHER) {
 		int chanspec = devpriv->ext_clock.chanspec;
@@ -2372,7 +2371,7 @@ static inline void dma_start_sync(struct comedi_device *dev,
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned long flags;
 
-	/*  spinlock for plx dma control/status reg */
+	/* spinlock for plx dma control/status reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	writeb(PLX_DMACSR_ENABLE | PLX_DMACSR_START | PLX_DMACSR_CLEARINTR,
 	       devpriv->plx9080_iobase + PLX_REG_DMACSR(channel));
@@ -2396,16 +2395,16 @@ static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 		scan_counter = ai_scan_counter_6xxx(dev, cmd);
 	}
 
-	/*  load lower 16 bits of convert interval */
+	/* load lower 16 bits of convert interval */
 	writew(convert_counter & 0xffff,
 	       devpriv->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
-	/*  load upper 8 bits of convert interval */
+	/* load upper 8 bits of convert interval */
 	writew((convert_counter >> 16) & 0xff,
 	       devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
-	/*  load lower 16 bits of scan delay */
+	/* load lower 16 bits of scan delay */
 	writew(scan_counter & 0xffff,
 	       devpriv->main_iobase + ADC_DELAY_INTERVAL_LOWER_REG);
-	/*  load upper 8 bits of scan delay */
+	/* load upper 8 bits of scan delay */
 	writew((scan_counter >> 16) & 0xff,
 	       devpriv->main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);
 }
@@ -2441,26 +2440,26 @@ static int setup_channel_queue(struct comedi_device *dev,
 			writew(devpriv->hw_config_bits,
 			       devpriv->main_iobase + HW_CONFIG_REG);
 			bits = 0;
-			/*  set channel */
+			/* set channel */
 			bits |= adc_chan_bits(CR_CHAN(cmd->chanlist[0]));
-			/*  set gain */
+			/* set gain */
 			bits |= ai_range_bits_6xxx(dev,
 						   CR_RANGE(cmd->chanlist[0]));
-			/*  set single-ended / differential */
+			/* set single-ended / differential */
 			bits |= se_diff_bit_6xxx(dev,
 						 CR_AREF(cmd->chanlist[0]) ==
 						 AREF_DIFF);
 			if (CR_AREF(cmd->chanlist[0]) == AREF_COMMON)
 				bits |= ADC_COMMON_BIT;
-			/*  set stop channel */
+			/* set stop channel */
 			writew(adc_chan_bits
 			       (CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])),
 			       devpriv->main_iobase + ADC_QUEUE_HIGH_REG);
-			/*  set start channel, and rest of settings */
+			/* set start channel, and rest of settings */
 			writew(bits,
 			       devpriv->main_iobase + ADC_QUEUE_LOAD_REG);
 		} else {
-			/*  use external queue */
+			/* use external queue */
 			if (dev->write_subdev && dev->write_subdev->busy) {
 				warn_external_queue(dev);
 				return -EBUSY;
@@ -2468,30 +2467,30 @@ static int setup_channel_queue(struct comedi_device *dev,
 			devpriv->hw_config_bits |= EXT_QUEUE_BIT;
 			writew(devpriv->hw_config_bits,
 			       devpriv->main_iobase + HW_CONFIG_REG);
-			/*  clear DAC buffer to prevent weird interactions */
+			/* clear DAC buffer to prevent weird interactions */
 			writew(0,
 			       devpriv->main_iobase + DAC_BUFFER_CLEAR_REG);
-			/*  clear queue pointer */
+			/* clear queue pointer */
 			writew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);
-			/*  load external queue */
+			/* load external queue */
 			for (i = 0; i < cmd->chanlist_len; i++) {
 				bits = 0;
-				/*  set channel */
+				/* set channel */
 				bits |= adc_chan_bits(CR_CHAN(cmd->
 							      chanlist[i]));
-				/*  set gain */
+				/* set gain */
 				bits |= ai_range_bits_6xxx(dev,
 							   CR_RANGE(cmd->
 								    chanlist
 								    [i]));
-				/*  set single-ended / differential */
+				/* set single-ended / differential */
 				bits |= se_diff_bit_6xxx(dev,
 							 CR_AREF(cmd->
 								 chanlist[i]) ==
 							 AREF_DIFF);
 				if (CR_AREF(cmd->chanlist[i]) == AREF_COMMON)
 					bits |= ADC_COMMON_BIT;
-				/*  mark end of queue */
+				/* mark end of queue */
 				if (i == cmd->chanlist_len - 1)
 					bits |= QUEUE_EOSCAN_BIT |
 						QUEUE_EOSEQ_BIT;
@@ -2504,7 +2503,7 @@ static int setup_channel_queue(struct comedi_device *dev,
 			 * but required for reliable operation
 			 */
 			writew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);
-			/*  prime queue holding register */
+			/* prime queue holding register */
 			writew(0, devpriv->main_iobase + ADC_QUEUE_LOAD_REG);
 		}
 	} else {
@@ -2513,7 +2512,7 @@ static int setup_channel_queue(struct comedi_device *dev,
 		devpriv->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;
 		/* select BNC inputs */
 		devpriv->i2c_cal_range_bits |= adc_src_4020_bits(4);
-		/*  select ranges */
+		/* select ranges */
 		for (i = 0; i < cmd->chanlist_len; i++) {
 			unsigned int channel = CR_CHAN(cmd->chanlist[i]);
 			unsigned int range = CR_RANGE(cmd->chanlist[i]);
@@ -2585,7 +2584,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (retval < 0)
 		return retval;
 
-	/*  make sure internal calibration source is turned off */
+	/* make sure internal calibration source is turned off */
 	writew(0, devpriv->main_iobase + CALIBRATION_REG);
 
 	set_ai_pacing(dev, cmd);
@@ -2601,10 +2600,10 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (board->layout != LAYOUT_4020) {
 		devpriv->adc_control1_bits &= ~ADC_MODE_MASK;
 		if (cmd->convert_src == TRIG_EXT)
-			/*  good old mode 13 */
+			/* good old mode 13 */
 			devpriv->adc_control1_bits |= adc_mode_bits(13);
 		else
-			/*  mode 8.  What else could you need? */
+			/* mode 8.  What else could you need? */
 			devpriv->adc_control1_bits |= adc_mode_bits(8);
 	} else {
 		devpriv->adc_control1_bits &= ~CHANNEL_MODE_4020_MASK;
@@ -2624,20 +2623,20 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	       devpriv->main_iobase + ADC_CONTROL1_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  clear adc buffer */
+	/* clear adc buffer */
 	writew(0, devpriv->main_iobase + ADC_BUFFER_CLEAR_REG);
 
 	if ((cmd->flags & CMDF_WAKE_EOS) == 0 ||
 	    board->layout == LAYOUT_4020) {
 		devpriv->ai_dma_index = 0;
 
-		/*  set dma transfer size */
+		/* set dma transfer size */
 		for (i = 0; i < ai_dma_ring_count(board); i++)
 			devpriv->ai_dma_desc[i].transfer_size =
 				cpu_to_le32(dma_transfer_size(dev) *
 					    sizeof(uint16_t));
 
-		/*  give location of first dma descriptor */
+		/* give location of first dma descriptor */
 		load_first_dma_descriptor(dev, 1,
 					  devpriv->ai_dma_desc_bus_addr |
 					  PLX_DMADPR_DESCPCI |
@@ -2663,7 +2662,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	bits = ADC_ENABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT;
 	if (cmd->flags & CMDF_WAKE_EOS)
 		bits |= ADC_DMA_DISABLE_BIT;
-	/*  set start trigger */
+	/* set start trigger */
 	if (cmd->start_src == TRIG_EXT) {
 		bits |= ADC_START_TRIG_EXT_BITS;
 		if (cmd->start_arg & CR_INVERT)
@@ -2679,7 +2678,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  start acquisition */
+	/* start acquisition */
 	if (cmd->start_src == TRIG_NOW)
 		writew(0, devpriv->main_iobase + ADC_START_REG);
 
@@ -2697,7 +2696,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 	int num_samples;
 
 	do {
-		/*  get least significant 15 bits */
+		/* get least significant 15 bits */
 		read_index = readw(devpriv->main_iobase + ADC_READ_PNTR_REG) &
 			     0x7fff;
 		write_index = readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) &
@@ -2802,14 +2801,14 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 
 	pci_addr_reg = devpriv->plx9080_iobase + PLX_REG_DMAPADR(channel);
 
-	/*  loop until we have read all the full buffers */
+	/* loop until we have read all the full buffers */
 	for (j = 0, next_transfer_addr = readl(pci_addr_reg);
 	     (next_transfer_addr <
 	      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] ||
 	      next_transfer_addr >=
 	      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] +
 	      DMA_BUFFER_SIZE) && j < ai_dma_ring_count(board); j++) {
-		/*  transfer data from dma buffer to comedi buffer */
+		/* transfer data from dma buffer to comedi buffer */
 		num_samples = comedi_nsamples_left(s, dma_transfer_size(dev));
 		comedi_buf_write_samples(s,
 				devpriv->ai_buffer[devpriv->ai_dma_index],
@@ -2835,15 +2834,15 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 	uint8_t dma1_status;
 	unsigned long flags;
 
-	/*  check for fifo overrun */
+	/* check for fifo overrun */
 	if (status & ADC_OVERRUN_BIT) {
 		dev_err(dev->class_dev, "fifo overrun\n");
 		async->events |= COMEDI_CB_ERROR;
 	}
-	/*  spin lock makes sure no one else changes plx dma control reg */
+	/* spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(devpriv->plx9080_iobase + PLX_REG_DMACSR1);
-	if (plx_status & PLX_INTCSR_DMA1IA) {	/*  dma chan 1 interrupt */
+	if (plx_status & PLX_INTCSR_DMA1IA) {	/* dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMACSR_ENABLE) | PLX_DMACSR_CLEARINTR,
 		       devpriv->plx9080_iobase + PLX_REG_DMACSR1);
 
@@ -2852,7 +2851,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  drain fifo with pio */
+	/* drain fifo with pio */
 	if ((status & ADC_DONE_BIT) ||
 	    ((cmd->flags & CMDF_WAKE_EOS) &&
 	     (status & ADC_INTR_PENDING_BIT) &&
@@ -2865,7 +2864,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 			spin_unlock_irqrestore(&dev->spinlock, flags);
 		}
 	}
-	/*  if we are have all the data, then quit */
+	/* if we are have all the data, then quit */
 	if ((cmd->stop_src == TRIG_COUNT &&
 	     async->scans_done >= cmd->stop_arg) ||
 	    (cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT)))
@@ -3018,7 +3017,7 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 	async = s->async;
 	cmd = &async->cmd;
 
-	/*  spin lock makes sure no one else changes plx dma control reg */
+	/* spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(devpriv->plx9080_iobase + PLX_REG_DMACSR0);
 	if (plx_status & PLX_INTCSR_DMA0IA) {	/*  dma chan 0 interrupt */
@@ -3112,15 +3111,15 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	int chan = CR_CHAN(insn->chanspec);
 	int range = CR_RANGE(insn->chanspec);
 
-	/*  do some initializing */
+	/* do some initializing */
 	writew(0, devpriv->main_iobase + DAC_CONTROL0_REG);
 
-	/*  set range */
+	/* set range */
 	set_dac_range_bits(dev, &devpriv->dac_control1_bits, chan, range);
 	writew(devpriv->dac_control1_bits,
 	       devpriv->main_iobase + DAC_CONTROL1_REG);
 
-	/*  write to channel */
+	/* write to channel */
 	if (board->layout == LAYOUT_4020) {
 		writew(data[0] & 0xff,
 		       devpriv->main_iobase + dac_lsb_4020_reg(chan));
@@ -3130,7 +3129,7 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		writew(data[0], devpriv->main_iobase + dac_convert_reg(chan));
 	}
 
-	/*  remember output value */
+	/* remember output value */
 	s->readback[chan] = data[0];
 
 	return 1;
@@ -3562,7 +3561,7 @@ static int caldac_i2c_write(struct comedi_device *dev,
 	uint8_t serial_bytes[3];
 	uint8_t i2c_addr;
 	enum pointer_bits {
-		/*  manual has gain and offset bits switched */
+		/* manual has gain and offset bits switched */
 		OFFSET_0_2 = 0x1,
 		GAIN_0_2 = 0x2,
 		OFFSET_1_3 = 0x4,
@@ -3573,35 +3572,35 @@ static int caldac_i2c_write(struct comedi_device *dev,
 	};
 
 	switch (caldac_channel) {
-	case 0:		/*  chan 0 offset */
+	case 0:					/* chan 0 offset */
 		i2c_addr = CALDAC0_I2C_ADDR;
 		serial_bytes[0] = OFFSET_0_2;
 		break;
-	case 1:		/*  chan 1 offset */
+	case 1:					/* chan 1 offset */
 		i2c_addr = CALDAC0_I2C_ADDR;
 		serial_bytes[0] = OFFSET_1_3;
 		break;
-	case 2:		/*  chan 2 offset */
+	case 2:					/* chan 2 offset */
 		i2c_addr = CALDAC1_I2C_ADDR;
 		serial_bytes[0] = OFFSET_0_2;
 		break;
-	case 3:		/*  chan 3 offset */
+	case 3:					/* chan 3 offset */
 		i2c_addr = CALDAC1_I2C_ADDR;
 		serial_bytes[0] = OFFSET_1_3;
 		break;
-	case 4:		/*  chan 0 gain */
+	case 4:					/* chan 0 gain */
 		i2c_addr = CALDAC0_I2C_ADDR;
 		serial_bytes[0] = GAIN_0_2;
 		break;
-	case 5:		/*  chan 1 gain */
+	case 5:					/* chan 1 gain */
 		i2c_addr = CALDAC0_I2C_ADDR;
 		serial_bytes[0] = GAIN_1_3;
 		break;
-	case 6:		/*  chan 2 gain */
+	case 6:					/* chan 2 gain */
 		i2c_addr = CALDAC1_I2C_ADDR;
 		serial_bytes[0] = GAIN_0_2;
 		break;
-	case 7:		/*  chan 3 gain */
+	case 7:					/* chan 3 gain */
 		i2c_addr = CALDAC1_I2C_ADDR;
 		serial_bytes[0] = GAIN_1_3;
 		break;
@@ -3724,24 +3723,24 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 
 	udelay(eeprom_udelay);
 	devpriv->plx_control_bits &= ~PLX_CNTRL_EESK & ~PLX_CNTRL_EECS;
-	/*  make sure we don't send anything to the i2c bus on 4020 */
+	/* make sure we don't send anything to the i2c bus on 4020 */
 	devpriv->plx_control_bits |= PLX_CNTRL_USERO;
 	writel(devpriv->plx_control_bits, plx_control_addr);
-	/*  activate serial eeprom */
+	/* activate serial eeprom */
 	udelay(eeprom_udelay);
 	devpriv->plx_control_bits |= PLX_CNTRL_EECS;
 	writel(devpriv->plx_control_bits, plx_control_addr);
 
-	/*  write read command and desired memory address */
+	/* write read command and desired memory address */
 	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
-		/*  set bit to be written */
+		/* set bit to be written */
 		udelay(eeprom_udelay);
 		if (bitstream & bit)
 			devpriv->plx_control_bits |= PLX_CNTRL_EEWB;
 		else
 			devpriv->plx_control_bits &= ~PLX_CNTRL_EEWB;
 		writel(devpriv->plx_control_bits, plx_control_addr);
-		/*  clock in bit */
+		/* clock in bit */
 		udelay(eeprom_udelay);
 		devpriv->plx_control_bits |= PLX_CNTRL_EESK;
 		writel(devpriv->plx_control_bits, plx_control_addr);
@@ -3749,10 +3748,10 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 		devpriv->plx_control_bits &= ~PLX_CNTRL_EESK;
 		writel(devpriv->plx_control_bits, plx_control_addr);
 	}
-	/*  read back value from eeprom memory location */
+	/* read back value from eeprom memory location */
 	value = 0;
 	for (bit = 1 << (value_length - 1); bit; bit >>= 1) {
-		/*  clock out bit */
+		/* clock out bit */
 		udelay(eeprom_udelay);
 		devpriv->plx_control_bits |= PLX_CNTRL_EESK;
 		writel(devpriv->plx_control_bits, plx_control_addr);
@@ -3764,7 +3763,7 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 			value |= bit;
 	}
 
-	/*  deactivate eeprom serial input */
+	/* deactivate eeprom serial input */
 	udelay(eeprom_udelay);
 	devpriv->plx_control_bits &= ~PLX_CNTRL_EECS;
 	writel(devpriv->plx_control_bits, plx_control_addr);
@@ -3781,9 +3780,7 @@ static int eeprom_read_insn(struct comedi_device *dev,
 	return 1;
 }
 
-/*
- * Allocate and initialize the subdevice structures.
- */
+/* Allocate and initialize the subdevice structures. */
 static int setup_subdevices(struct comedi_device *dev)
 {
 	const struct pcidas64_board *board = dev->board_ptr;
@@ -3822,7 +3819,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		 * (not internal calibration sources)
 		 */
 		devpriv->i2c_cal_range_bits = adc_src_4020_bits(4);
-		/*  set channels to +-5 volt input ranges */
+		/* set channels to +-5 volt input ranges */
 		for (i = 0; i < s->n_chan; i++)
 			devpriv->i2c_cal_range_bits |= attenuate_bit(i);
 		data = devpriv->i2c_cal_range_bits;
@@ -3855,7 +3852,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	/*  digital input */
+	/* digital input */
 	s = &dev->subdevices[2];
 	if (board->layout == LAYOUT_64XX) {
 		s->type = COMEDI_SUBD_DI;
@@ -3868,7 +3865,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	/*  digital output */
+	/* digital output */
 	if (board->layout == LAYOUT_64XX) {
 		s = &dev->subdevices[3];
 		s->type = COMEDI_SUBD_DO;
@@ -3897,7 +3894,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	/*  8 channel dio for 60xx */
+	/* 8 channel dio for 60xx */
 	s = &dev->subdevices[5];
 	if (board->layout == LAYOUT_60XX) {
 		s->type = COMEDI_SUBD_DIO;
@@ -3911,7 +3908,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	/*  caldac */
+	/* caldac */
 	s = &dev->subdevices[6];
 	s->type = COMEDI_SUBD_CALIB;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
@@ -3931,7 +3928,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->readback[i] = s->maxdata / 2;
 	}
 
-	/*  2 channel ad8402 potentiometer */
+	/* 2 channel ad8402 potentiometer */
 	s = &dev->subdevices[7];
 	if (board->layout == LAYOUT_64XX) {
 		s->type = COMEDI_SUBD_CALIB;
@@ -3965,7 +3962,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	/*  user counter subd XXX */
+	/* user counter subd XXX */
 	s = &dev->subdevices[9];
 	s->type = COMEDI_SUBD_UNUSED;
 
@@ -4011,7 +4008,7 @@ static int auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	}
 
-	/*  figure out what local addresses are */
+	/* figure out what local addresses are */
 	local_range = readl(devpriv->plx9080_iobase + PLX_REG_LAS0RR) &
 		      PLX_LASRR_MEM_MASK;
 	local_decode = readl(devpriv->plx9080_iobase + PLX_REG_LAS0BA) &

commit 28fec2e65f70a20082834f6f6cdbfa94545d2668
Author: Anson Jacob <ansonjacob.aj@gmail.com>
Date:   Fri Aug 26 19:12:52 2016 -0400

    staging: comedi: cb_pcidas64.c: Fix checkpatch warning
    
    Fix checkpatch.pl warning:
    Block comments use * on subsequent lines
    Block comments use a trailing */ on a separate line
    
    Signed-off-by: Anson Jacob <ansonjacob.aj@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index aae839e7726f..281dc56c75f1 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1,34 +1,34 @@
 /*
-    comedi/drivers/cb_pcidas64.c
-    This is a driver for the ComputerBoards/MeasurementComputing PCI-DAS
-    64xx, 60xx, and 4020 cards.
-
-    Author:  Frank Mori Hess <fmhess@users.sourceforge.net>
-    Copyright (C) 2001, 2002 Frank Mori Hess
-
-    Thanks also go to the following people:
-
-    Steve Rosenbluth, for providing the source code for
-    his pci-das6402 driver, and source code for working QNX pci-6402
-    drivers by Greg Laird and Mariusz Bogacz.  None of the code was
-    used directly here, but it was useful as an additional source of
-    documentation on how to program the boards.
-
-    John Sims, for much testing and feedback on pcidas-4020 support.
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
+ * comedi/drivers/cb_pcidas64.c
+ * This is a driver for the ComputerBoards/MeasurementComputing PCI-DAS
+ * 64xx, 60xx, and 4020 cards.
+ *
+ * Author:  Frank Mori Hess <fmhess@users.sourceforge.net>
+ * Copyright (C) 2001, 2002 Frank Mori Hess
+ *
+ * Thanks also go to the following people:
+ *
+ * Steve Rosenbluth, for providing the source code for
+ * his pci-das6402 driver, and source code for working QNX pci-6402
+ * drivers by Greg Laird and Mariusz Bogacz.  None of the code was
+ * used directly here, but it was useful as an additional source of
+ * documentation on how to program the boards.
+ *
+ * John Sims, for much testing and feedback on pcidas-4020 support.
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
 /*
  * Driver: cb_pcidas64
@@ -66,19 +66,18 @@
  */
 
 /*
-
-TODO:
-	make it return error if user attempts an ai command that uses the
-	external queue, and an ao command simultaneously user counter subdevice
-	there are a number of boards this driver will support when they are
-	fully released, but does not yet since the pci device id numbers
-	are not yet available.
-
-	support prescaled 100khz clock for slow pacing (not available on 6000
-	series?)
-
-	make ao fifo size adjustable like ai fifo
-*/
+ * TODO:
+ * make it return error if user attempts an ai command that uses the
+ * external queue, and an ao command simultaneously user counter subdevice
+ * there are a number of boards this driver will support when they are
+ * fully released, but does not yet since the pci device id numbers
+ * are not yet available.
+ *
+ * support prescaled 100khz clock for slow pacing (not available on 6000
+ * series?)
+ *
+ * make ao fifo size adjustable like ai fifo
+ */
 
 #include <linux/module.h>
 #include <linux/delay.h>
@@ -90,53 +89,55 @@
 #include "plx9080.h"
 
 #define TIMER_BASE 25		/*  40MHz master clock */
-/* 100kHz 'prescaled' clock for slow acquisition,
- * maybe I'll support this someday */
+/*
+ * 100kHz 'prescaled' clock for slow acquisition,
+ * maybe I'll support this someday
+ */
 #define PRESCALED_TIMER_BASE	10000
 #define DMA_BUFFER_SIZE 0x1000
 
-/* maximum value that can be loaded into board's 24-bit counters*/
+/* maximum value that can be loaded into board's 24-bit counters */
 static const int max_counter_value = 0xffffff;
 
 /* PCI-DAS64xxx base addresses */
 
 /* devpriv->main_iobase registers */
 enum write_only_registers {
-	INTR_ENABLE_REG = 0x0,	/*  interrupt enable register */
-	HW_CONFIG_REG = 0x2,	/*  hardware config register */
+	INTR_ENABLE_REG = 0x0,		/* interrupt enable register */
+	HW_CONFIG_REG = 0x2,		/* hardware config register */
 	DAQ_SYNC_REG = 0xc,
 	DAQ_ATRIG_LOW_4020_REG = 0xc,
-	ADC_CONTROL0_REG = 0x10,	/*  adc control register 0 */
-	ADC_CONTROL1_REG = 0x12,	/*  adc control register 1 */
+	ADC_CONTROL0_REG = 0x10,	/* adc control register 0 */
+	ADC_CONTROL1_REG = 0x12,	/* adc control register 1 */
 	CALIBRATION_REG = 0x14,
-	/*  lower 16 bits of adc sample interval counter */
+	/* lower 16 bits of adc sample interval counter */
 	ADC_SAMPLE_INTERVAL_LOWER_REG = 0x16,
-	/*  upper 8 bits of adc sample interval counter */
+	/* upper 8 bits of adc sample interval counter */
 	ADC_SAMPLE_INTERVAL_UPPER_REG = 0x18,
-	/*  lower 16 bits of delay interval counter */
+	/* lower 16 bits of delay interval counter */
 	ADC_DELAY_INTERVAL_LOWER_REG = 0x1a,
-	/*  upper 8 bits of delay interval counter */
+	/* upper 8 bits of delay interval counter */
 	ADC_DELAY_INTERVAL_UPPER_REG = 0x1c,
-	/*  lower 16 bits of hardware conversion/scan counter */
+	/* lower 16 bits of hardware conversion/scan counter */
 	ADC_COUNT_LOWER_REG = 0x1e,
-	/*  upper 8 bits of hardware conversion/scan counter */
+	/* upper 8 bits of hardware conversion/scan counter */
 	ADC_COUNT_UPPER_REG = 0x20,
-	ADC_START_REG = 0x22,	/*  software trigger to start acquisition */
-	ADC_CONVERT_REG = 0x24,	/*  initiates single conversion */
-	ADC_QUEUE_CLEAR_REG = 0x26,	/*  clears adc queue */
-	ADC_QUEUE_LOAD_REG = 0x28,	/*  loads adc queue */
+	ADC_START_REG = 0x22,	/* software trigger to start acquisition */
+	ADC_CONVERT_REG = 0x24,	/* initiates single conversion */
+	ADC_QUEUE_CLEAR_REG = 0x26,	/* clears adc queue */
+	ADC_QUEUE_LOAD_REG = 0x28,	/* loads adc queue */
 	ADC_BUFFER_CLEAR_REG = 0x2a,
-	/*  high channel for internal queue, use adc_chan_bits() inline above */
+	/* high channel for internal queue, use adc_chan_bits() inline above */
 	ADC_QUEUE_HIGH_REG = 0x2c,
-	DAC_CONTROL0_REG = 0x50,	/*  dac control register 0 */
-	DAC_CONTROL1_REG = 0x52,	/*  dac control register 0 */
-	/*  lower 16 bits of dac sample interval counter */
+	DAC_CONTROL0_REG = 0x50,	/* dac control register 0 */
+	DAC_CONTROL1_REG = 0x52,	/* dac control register 0 */
+	/* lower 16 bits of dac sample interval counter */
 	DAC_SAMPLE_INTERVAL_LOWER_REG = 0x54,
-	/*  upper 8 bits of dac sample interval counter */
+	/* upper 8 bits of dac sample interval counter */
 	DAC_SAMPLE_INTERVAL_UPPER_REG = 0x56,
 	DAC_SELECT_REG = 0x60,
 	DAC_START_REG = 0x64,
-	DAC_BUFFER_CLEAR_REG = 0x66,	/*  clear dac buffer */
+	DAC_BUFFER_CLEAR_REG = 0x66,	/* clear dac buffer */
 };
 
 static inline unsigned int dac_convert_reg(unsigned int channel)
@@ -216,7 +217,8 @@ enum hw_config_contents {
 	/*  use 225 nanosec strobe when loading dac instead of 50 nanosec */
 	SLOW_DAC_BIT = 0x400,
 	/*  bit with unknown function yet given as default value in pci-das64
-	 *  manual */
+	 *  manual
+	 */
 	HW_CONFIG_DUMMY_BITS = 0x2000,
 	/*  bit selects channels 1/0 for analog input/output, otherwise 0/1 */
 	DMA_CH_SELECT_BIT = 0x8000,
@@ -1138,12 +1140,14 @@ struct pcidas64_private {
 	/*  physical addresses of ai dma buffers */
 	dma_addr_t ai_buffer_bus_addr[MAX_AI_DMA_RING_COUNT];
 	/*  array of ai dma descriptors read by plx9080,
-	 *  allocated to get proper alignment */
+	 *  allocated to get proper alignment
+	 */
 	struct plx_dma_desc *ai_dma_desc;
 	/*  physical address of ai dma descriptor array */
 	dma_addr_t ai_dma_desc_bus_addr;
 	/*  index of the ai dma descriptor/buffer
-	 *  that is currently being used */
+	 *  that is currently being used
+	 */
 	unsigned int ai_dma_index;
 	/*  dma buffers for analog output */
 	uint16_t *ao_buffer[AO_DMA_RING_COUNT];
@@ -1314,10 +1318,12 @@ static void init_plx9080(struct comedi_device *dev)
 	/*  enable dma chaining */
 	bits |= PLX_DMAMODE_CHAINEN;
 	/*  enable interrupt on dma done
-	 *  (probably don't need this, since chain never finishes) */
+	 *  (probably don't need this, since chain never finishes)
+	 */
 	bits |= PLX_DMAMODE_DONEIEN;
 	/*  don't increment local address during transfers
-	 *  (we are transferring from a fixed fifo register) */
+	 *  (we are transferring from a fixed fifo register)
+	 */
 	bits |= PLX_DMAMODE_LACONST;
 	/*  route dma interrupt to pci bus */
 	bits |= PLX_DMAMODE_INTRPCI;

commit 686869b451b0b106cf6b365361fd577080fbca7a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jun 20 14:05:49 2016 +0100

    staging: comedi: plx9080.h: rename some macros for consistency
    
    Most of the macros in "plx9080.h" that define register values are
    single-bits flags of the form `PLX_<REG>_<FLAG>`, or are constant,
    multi-bit values of the form `PLX_<REG>_<FIELD>_<VAL>`, or are
    non-constant, function-like macros of the form `PLX_<REG>_<FIELD>(x)`.
    Some of the macros for constant, multi-bit values do not currently
    fit the pattern, so rename them for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 1f9c08a845b6..aae839e7726f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1327,9 +1327,9 @@ static void init_plx9080(struct comedi_device *dev)
 	bits |= PLX_DMAMODE_BURSTEN;
 	/*  4020 uses 32 bit dma */
 	if (board->layout == LAYOUT_4020)
-		bits |= PLX_DMAMODE_WIDTH32;
+		bits |= PLX_DMAMODE_WIDTH_32;
 	else		/*  localspace0 bus is 16 bits wide */
-		bits |= PLX_DMAMODE_WIDTH16;
+		bits |= PLX_DMAMODE_WIDTH_16;
 	writel(bits, plx_iobase + PLX_REG_DMAMODE1);
 	if (ao_cmd_is_supported(board))
 		writel(bits, plx_iobase + PLX_REG_DMAMODE0);

commit 3dcf1b5596603076cf127a3efdf3a33a276d8b9e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:18 2016 +0100

    staging: comedi: drivers: re-do PLX PCI 9080 DMACSRx register values
    
    Replace the existing macros in "plx9080.h" that define values for the
    DMACSR0 and DMACSR0 registers.  Use the prefix `PLX_DMACSR_` for the
    macros.  Make use of the `BIT(x)` macro to define the values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index a4d10a3480f8..1f9c08a845b6 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2368,7 +2368,7 @@ static inline void dma_start_sync(struct comedi_device *dev,
 
 	/*  spinlock for plx dma control/status reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
+	writeb(PLX_DMACSR_ENABLE | PLX_DMACSR_START | PLX_DMACSR_CLEARINTR,
 	       devpriv->plx9080_iobase + PLX_REG_DMACSR(channel));
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
@@ -2838,10 +2838,10 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(devpriv->plx9080_iobase + PLX_REG_DMACSR1);
 	if (plx_status & PLX_INTCSR_DMA1IA) {	/*  dma chan 1 interrupt */
-		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
+		writeb((dma1_status & PLX_DMACSR_ENABLE) | PLX_DMACSR_CLEARINTR,
 		       devpriv->plx9080_iobase + PLX_REG_DMACSR1);
 
-		if (dma1_status & PLX_DMA_EN_BIT)
+		if (dma1_status & PLX_DMACSR_ENABLE)
 			drain_dma_buffers(dev, 1);
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -2889,7 +2889,7 @@ static int last_ao_dma_load_completed(struct comedi_device *dev)
 
 	buffer_index = prev_ao_dma_index(dev);
 	dma_status = readb(devpriv->plx9080_iobase + PLX_REG_DMACSR0);
-	if ((dma_status & PLX_DMA_DONE_BIT) == 0)
+	if ((dma_status & PLX_DMACSR_DONE) == 0)
 		return 0;
 
 	transfer_address =
@@ -2903,8 +2903,8 @@ static int last_ao_dma_load_completed(struct comedi_device *dev)
 static inline int ao_dma_needs_restart(struct comedi_device *dev,
 				       unsigned short dma_status)
 {
-	if ((dma_status & PLX_DMA_DONE_BIT) == 0 ||
-	    (dma_status & PLX_DMA_EN_BIT) == 0)
+	if ((dma_status & PLX_DMACSR_DONE) == 0 ||
+	    (dma_status & PLX_DMACSR_ENABLE) == 0)
 		return 0;
 	if (last_ao_dma_load_completed(dev))
 		return 0;
@@ -3016,16 +3016,16 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(devpriv->plx9080_iobase + PLX_REG_DMACSR0);
 	if (plx_status & PLX_INTCSR_DMA0IA) {	/*  dma chan 0 interrupt */
-		if ((dma0_status & PLX_DMA_EN_BIT) &&
-		    !(dma0_status & PLX_DMA_DONE_BIT)) {
-			writeb(PLX_DMA_EN_BIT | PLX_CLEAR_DMA_INTR_BIT,
+		if ((dma0_status & PLX_DMACSR_ENABLE) &&
+		    !(dma0_status & PLX_DMACSR_DONE)) {
+			writeb(PLX_DMACSR_ENABLE | PLX_DMACSR_CLEARINTR,
 			       devpriv->plx9080_iobase + PLX_REG_DMACSR0);
 		} else {
-			writeb(PLX_CLEAR_DMA_INTR_BIT,
+			writeb(PLX_DMACSR_CLEARINTR,
 			       devpriv->plx9080_iobase + PLX_REG_DMACSR0);
 		}
 		spin_unlock_irqrestore(&dev->spinlock, flags);
-		if (dma0_status & PLX_DMA_EN_BIT) {
+		if (dma0_status & PLX_DMACSR_ENABLE) {
 			load_ao_dma(dev, cmd);
 			/* try to recover from dma end-of-chain event */
 			if (ao_dma_needs_restart(dev, dma0_status))

commit dde90d89ae5a98a3f1420b6c20c7f58dd95ccfa3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:17 2016 +0100

    staging: comedi: drivers: re-do PLX PCI 9080 DMADPRx register values
    
    Replace the existing macros in "plx9080.h" that define values for the
    DMADPR0 and DMADPR1 registers.  (A little-endian version of the register
    value is also placed in the `next` member of `struct plx_dma_desc`.)
    Use the prefix `PLX_DMADPR_` for the macros.  Make use of the `BIT(x)`
    and `GENMASK(h,l)` macros to define the values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 48aca0652697..a4d10a3480f8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1534,8 +1534,8 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 			cpu_to_le32((devpriv->ai_dma_desc_bus_addr +
 				     ((i + 1) % ai_dma_ring_count(board)) *
 				     sizeof(devpriv->ai_dma_desc[0])) |
-				    PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
-				    PLX_XFER_LOCAL_TO_PCI);
+				    PLX_DMADPR_DESCPCI | PLX_DMADPR_TCINTR |
+				    PLX_DMADPR_XFERL2P);
 	}
 	if (ao_cmd_is_supported(board)) {
 		for (i = 0; i < AO_DMA_RING_COUNT; i++) {
@@ -1549,8 +1549,8 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 				cpu_to_le32((devpriv->ao_dma_desc_bus_addr +
 					     ((i + 1) % (AO_DMA_RING_COUNT)) *
 					     sizeof(devpriv->ao_dma_desc[0])) |
-					    PLX_DESC_IN_PCI_BIT |
-					    PLX_INTR_TERM_COUNT);
+					    PLX_DMADPR_DESCPCI |
+					    PLX_DMADPR_TCINTR);
 		}
 	}
 	return 0;
@@ -2634,9 +2634,9 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/*  give location of first dma descriptor */
 		load_first_dma_descriptor(dev, 1,
 					  devpriv->ai_dma_desc_bus_addr |
-					  PLX_DESC_IN_PCI_BIT |
-					  PLX_INTR_TERM_COUNT |
-					  PLX_XFER_LOCAL_TO_PCI);
+					  PLX_DMADPR_DESCPCI |
+					  PLX_DMADPR_TCINTR |
+					  PLX_DMADPR_XFERL2P);
 
 		dma_start_sync(dev, 1);
 	}
@@ -2918,7 +2918,7 @@ static void restart_ao_dma(struct comedi_device *dev)
 	unsigned int dma_desc_bits;
 
 	dma_desc_bits = readl(devpriv->plx9080_iobase + PLX_REG_DMADPR0);
-	dma_desc_bits &= ~PLX_END_OF_CHAIN_BIT;
+	dma_desc_bits &= ~PLX_DMADPR_CHAINEND;
 	load_first_dma_descriptor(dev, 0, dma_desc_bits);
 
 	dma_start_sync(dev, 0);
@@ -2959,14 +2959,14 @@ static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 	devpriv->ao_dma_desc[buffer_index].transfer_size = cpu_to_le32(nbytes);
 	/* set end of chain bit so we catch underruns */
 	next_bits = le32_to_cpu(devpriv->ao_dma_desc[buffer_index].next);
-	next_bits |= PLX_END_OF_CHAIN_BIT;
+	next_bits |= PLX_DMADPR_CHAINEND;
 	devpriv->ao_dma_desc[buffer_index].next = cpu_to_le32(next_bits);
 	/*
 	 * clear end of chain bit on previous buffer now that we have set it
 	 * for the last buffer
 	 */
 	next_bits = le32_to_cpu(devpriv->ao_dma_desc[prev_buffer_index].next);
-	next_bits &= ~PLX_END_OF_CHAIN_BIT;
+	next_bits &= ~PLX_DMADPR_CHAINEND;
 	devpriv->ao_dma_desc[prev_buffer_index].next = cpu_to_le32(next_bits);
 
 	devpriv->ao_dma_index = (buffer_index + 1) % AO_DMA_RING_COUNT;
@@ -3310,7 +3310,7 @@ static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	set_dac_select_reg(dev, cmd);
 	set_dac_interval_regs(dev, cmd);
 	load_first_dma_descriptor(dev, 0, devpriv->ao_dma_desc_bus_addr |
-				  PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT);
+				  PLX_DMADPR_DESCPCI | PLX_DMADPR_TCINTR);
 
 	set_dac_control1_reg(dev, cmd);
 	s->async->inttrig = ao_inttrig;

commit 65bf53de830063520cfbdedd56d80f1125d62271
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:16 2016 +0100

    staging: comedi: drivers: re-do PLX PCI 9080 DMAMODEx register values
    
    Replace the existing macros in "plx9080.h" that define values for the
    DMAMODE0 and DMAMODE1 registers.  Use the prefix `PLX_DMAMODE_` for the
    macros.  Make use of the `BIT(x)` and `GENMASK(h,l)` macros to define
    the values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index dfb2ae871227..48aca0652697 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1308,28 +1308,28 @@ static void init_plx9080(struct comedi_device *dev)
 	/*  configure dma0 mode */
 	bits = 0;
 	/*  enable ready input, not sure if this is necessary */
-	bits |= PLX_DMA_EN_READYIN_BIT;
+	bits |= PLX_DMAMODE_READYIEN;
 	/*  enable bterm, not sure if this is necessary */
-	bits |= PLX_EN_BTERM_BIT;
+	bits |= PLX_DMAMODE_BTERMIEN;
 	/*  enable dma chaining */
-	bits |= PLX_EN_CHAIN_BIT;
+	bits |= PLX_DMAMODE_CHAINEN;
 	/*  enable interrupt on dma done
 	 *  (probably don't need this, since chain never finishes) */
-	bits |= PLX_EN_DMA_DONE_INTR_BIT;
+	bits |= PLX_DMAMODE_DONEIEN;
 	/*  don't increment local address during transfers
 	 *  (we are transferring from a fixed fifo register) */
-	bits |= PLX_LOCAL_ADDR_CONST_BIT;
+	bits |= PLX_DMAMODE_LACONST;
 	/*  route dma interrupt to pci bus */
-	bits |= PLX_DMA_INTR_PCI_BIT;
+	bits |= PLX_DMAMODE_INTRPCI;
 	/*  enable demand mode */
-	bits |= PLX_DEMAND_MODE_BIT;
+	bits |= PLX_DMAMODE_DEMAND;
 	/*  enable local burst mode */
-	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
+	bits |= PLX_DMAMODE_BURSTEN;
 	/*  4020 uses 32 bit dma */
 	if (board->layout == LAYOUT_4020)
-		bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
+		bits |= PLX_DMAMODE_WIDTH32;
 	else		/*  localspace0 bus is 16 bits wide */
-		bits |= PLX_LOCAL_BUS_16_WIDE_BITS;
+		bits |= PLX_DMAMODE_WIDTH16;
 	writel(bits, plx_iobase + PLX_REG_DMAMODE1);
 	if (ao_cmd_is_supported(board))
 		writel(bits, plx_iobase + PLX_REG_DMAMODE0);

commit a3228bc8b7a07e7abf74b8833f3778586e30cb2f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:14 2016 +0100

    staging: comedi: drivers: re-do PLX PCI 9080 CNTRL register values
    
    Replace the existing macros in "plx9080.h" that define values for the
    CNTRL register.  Use the prefix `PLX_CNTRL_` for the macros.  Make use
    of the `BIT(x)` and `GENMASK(h,l)` macros to define the values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 6b3f4dcdff46..dfb2ae871227 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1614,7 +1614,7 @@ static const int i2c_low_udelay = 10;
 static void i2c_set_sda(struct comedi_device *dev, int state)
 {
 	struct pcidas64_private *devpriv = dev->private;
-	static const int data_bit = CTL_EE_W;
+	static const int data_bit = PLX_CNTRL_EEWB;
 	void __iomem *plx_control_addr = devpriv->plx9080_iobase +
 					 PLX_REG_CNTRL;
 
@@ -1635,7 +1635,7 @@ static void i2c_set_sda(struct comedi_device *dev, int state)
 static void i2c_set_scl(struct comedi_device *dev, int state)
 {
 	struct pcidas64_private *devpriv = dev->private;
-	static const int clock_bit = CTL_USERO;
+	static const int clock_bit = PLX_CNTRL_USERO;
 	void __iomem *plx_control_addr = devpriv->plx9080_iobase +
 					 PLX_REG_CNTRL;
 
@@ -1708,7 +1708,7 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 	 */
 
 	/*  make sure we dont send anything to eeprom */
-	devpriv->plx_control_bits &= ~CTL_EE_CS;
+	devpriv->plx_control_bits &= ~PLX_CNTRL_EECS;
 
 	i2c_stop(dev);
 	i2c_start(dev);
@@ -3717,13 +3717,13 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 	static const int eeprom_udelay = 1;
 
 	udelay(eeprom_udelay);
-	devpriv->plx_control_bits &= ~CTL_EE_CLK & ~CTL_EE_CS;
+	devpriv->plx_control_bits &= ~PLX_CNTRL_EESK & ~PLX_CNTRL_EECS;
 	/*  make sure we don't send anything to the i2c bus on 4020 */
-	devpriv->plx_control_bits |= CTL_USERO;
+	devpriv->plx_control_bits |= PLX_CNTRL_USERO;
 	writel(devpriv->plx_control_bits, plx_control_addr);
 	/*  activate serial eeprom */
 	udelay(eeprom_udelay);
-	devpriv->plx_control_bits |= CTL_EE_CS;
+	devpriv->plx_control_bits |= PLX_CNTRL_EECS;
 	writel(devpriv->plx_control_bits, plx_control_addr);
 
 	/*  write read command and desired memory address */
@@ -3731,16 +3731,16 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 		/*  set bit to be written */
 		udelay(eeprom_udelay);
 		if (bitstream & bit)
-			devpriv->plx_control_bits |= CTL_EE_W;
+			devpriv->plx_control_bits |= PLX_CNTRL_EEWB;
 		else
-			devpriv->plx_control_bits &= ~CTL_EE_W;
+			devpriv->plx_control_bits &= ~PLX_CNTRL_EEWB;
 		writel(devpriv->plx_control_bits, plx_control_addr);
 		/*  clock in bit */
 		udelay(eeprom_udelay);
-		devpriv->plx_control_bits |= CTL_EE_CLK;
+		devpriv->plx_control_bits |= PLX_CNTRL_EESK;
 		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(eeprom_udelay);
-		devpriv->plx_control_bits &= ~CTL_EE_CLK;
+		devpriv->plx_control_bits &= ~PLX_CNTRL_EESK;
 		writel(devpriv->plx_control_bits, plx_control_addr);
 	}
 	/*  read back value from eeprom memory location */
@@ -3748,19 +3748,19 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 	for (bit = 1 << (value_length - 1); bit; bit >>= 1) {
 		/*  clock out bit */
 		udelay(eeprom_udelay);
-		devpriv->plx_control_bits |= CTL_EE_CLK;
+		devpriv->plx_control_bits |= PLX_CNTRL_EESK;
 		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(eeprom_udelay);
-		devpriv->plx_control_bits &= ~CTL_EE_CLK;
+		devpriv->plx_control_bits &= ~PLX_CNTRL_EESK;
 		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(eeprom_udelay);
-		if (readl(plx_control_addr) & CTL_EE_R)
+		if (readl(plx_control_addr) & PLX_CNTRL_EERB)
 			value |= bit;
 	}
 
 	/*  deactivate eeprom serial input */
 	udelay(eeprom_udelay);
-	devpriv->plx_control_bits &= ~CTL_EE_CS;
+	devpriv->plx_control_bits &= ~PLX_CNTRL_EECS;
 	writel(devpriv->plx_control_bits, plx_control_addr);
 
 	return value;
@@ -3948,7 +3948,8 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/* serial EEPROM, if present */
 	s = &dev->subdevices[8];
-	if (readl(devpriv->plx9080_iobase + PLX_REG_CNTRL) & CTL_EECHK) {
+	if (readl(devpriv->plx9080_iobase + PLX_REG_CNTRL) &
+	    PLX_CNTRL_EEPRESENT) {
 		s->type = COMEDI_SUBD_MEMORY;
 		s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
 		s->n_chan = 128;

commit 9dc53852b10888f9032baf78d672b45ab4d791fe
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:13 2016 +0100

    staging: comedi: drivers: re-do PLX PCI 9080 INTCSR register values
    
    Replace the existing macros in "plx9080.h" that define values for the
    INTCSR register.  Use the prefix `PLX_INTCSR_` for the macros.  Make use
    of the `BIT(x)` and `GENMASK(h,l)` macros to define the values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 4a8e88aeb57f..6b3f4dcdff46 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1336,8 +1336,9 @@ static void init_plx9080(struct comedi_device *dev)
 
 	/*  enable interrupts on plx 9080 */
 	devpriv->plx_intcsr_bits |=
-	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
-	    ICS_DMA0_E | ICS_DMA1_E;
+	    PLX_INTCSR_LSEABORTEN | PLX_INTCSR_LSEPARITYEN | PLX_INTCSR_PIEN |
+	    PLX_INTCSR_PLIEN | PLX_INTCSR_PABORTIEN | PLX_INTCSR_LIOEN |
+	    PLX_INTCSR_DMA0IEN | PLX_INTCSR_DMA1IEN;
 	writel(devpriv->plx_intcsr_bits,
 	       devpriv->plx9080_iobase + PLX_REG_INTCSR);
 }
@@ -2836,7 +2837,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(devpriv->plx9080_iobase + PLX_REG_DMACSR1);
-	if (plx_status & ICS_DMA1_A) {	/*  dma chan 1 interrupt */
+	if (plx_status & PLX_INTCSR_DMA1IA) {	/*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
 		       devpriv->plx9080_iobase + PLX_REG_DMACSR1);
 
@@ -3014,7 +3015,7 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(devpriv->plx9080_iobase + PLX_REG_DMACSR0);
-	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
+	if (plx_status & PLX_INTCSR_DMA0IA) {	/*  dma chan 0 interrupt */
 		if ((dma0_status & PLX_DMA_EN_BIT) &&
 		    !(dma0_status & PLX_DMA_DONE_BIT)) {
 			writeb(PLX_DMA_EN_BIT | PLX_CLEAR_DMA_INTR_BIT,
@@ -3067,8 +3068,9 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	handle_ai_interrupt(dev, status, plx_status);
 	handle_ao_interrupt(dev, status, plx_status);
 
-	/*  clear possible plx9080 interrupt sources */
-	if (plx_status & ICS_LDIA) {	/*  clear local doorbell interrupt */
+	/* clear possible plx9080 interrupt sources */
+	if (plx_status & PLX_INTCSR_LDBIA) {
+		/* clear local doorbell interrupt */
 		plx_bits = readl(devpriv->plx9080_iobase + PLX_REG_L2PDBELL);
 		writel(plx_bits, devpriv->plx9080_iobase + PLX_REG_L2PDBELL);
 	}

commit a9c254a763e4641d41c4e4b7665d979180c8af27
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:09 2016 +0100

    staging: comedi: drivers: re-do PLX PCI 9080 BIGEND register values
    
    Replace `enum bigend_bits` in "plx9080.h" with a bunch of macros
    defining values for the BIGEND register.  Use the prefix `PLX_BIGEND_`
    for the macro names.  Make use of the `BIT(x)` and `GENMASK(h,l)` macros
    to define the values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index f997c1f85c86..4a8e88aeb57f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1294,7 +1294,7 @@ static void init_plx9080(struct comedi_device *dev)
 		readl(devpriv->plx9080_iobase + PLX_REG_CNTRL);
 
 #ifdef __BIG_ENDIAN
-	bits = BIGEND_DMA0 | BIGEND_DMA1;
+	bits = PLX_BIGEND_DMA0 | PLX_BIGEND_DMA1;
 #else
 	bits = 0;
 #endif

commit 5eaa593dbf4830cb7e2513dbbcf5bbb274da0ccd
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:07 2016 +0100

    staging: comedi: drivers: re-do macros for PLX PCI 9080 LASxBA values
    
    Replace the existing macros in "plx9080.h" that define values for the
    LAS0BA and LAS1BA registers.  Use the prefix `PLX_LASBA_` for the
    macros.  Make use of the `BIT(x)` and `GENMASK(h,l)` macros to define
    the macros.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 59d81e86a79c..f997c1f85c86 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4006,13 +4006,13 @@ static int auto_attach(struct comedi_device *dev,
 	local_range = readl(devpriv->plx9080_iobase + PLX_REG_LAS0RR) &
 		      PLX_LASRR_MEM_MASK;
 	local_decode = readl(devpriv->plx9080_iobase + PLX_REG_LAS0BA) &
-		       local_range & LMAP_MEM_MASK;
+		       local_range & PLX_LASBA_MEM_MASK;
 	devpriv->local0_iobase = ((uint32_t)devpriv->main_phys_iobase &
 				  ~local_range) | local_decode;
 	local_range = readl(devpriv->plx9080_iobase + PLX_REG_LAS1RR) &
 		      PLX_LASRR_MEM_MASK;
 	local_decode = readl(devpriv->plx9080_iobase + PLX_REG_LAS1BA) &
-		       local_range & LMAP_MEM_MASK;
+		       local_range & PLX_LASBA_MEM_MASK;
 	devpriv->local1_iobase = ((uint32_t)devpriv->dio_counter_phys_iobase &
 				  ~local_range) | local_decode;
 

commit be13e14e31c6ce247fa4d6635f53d9755a545d4b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:06 2016 +0100

    staging: comedi: drivers: re-do macros for PLX PCI 9080 LASxRR values
    
    Rename the macros for the PLX PCI 9080 LAS0RR and LAS1RR registers in
    "plx9080.h", using the prefix `PLX_LASRR_`.  Make use of the `BIT(x)`
    and `GENMASK(h,l)` macros to define the values.
    
    Define a macro `PLX_LASRR_PREFETCH` for the "prefetchable memory" bit in
    this register, and define a macro `PLX_LASRR_MLOC_MASK` to mask the PCI
    memory location control bits.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index d9468db6b51e..59d81e86a79c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4004,13 +4004,13 @@ static int auto_attach(struct comedi_device *dev,
 
 	/*  figure out what local addresses are */
 	local_range = readl(devpriv->plx9080_iobase + PLX_REG_LAS0RR) &
-		      LRNG_MEM_MASK;
+		      PLX_LASRR_MEM_MASK;
 	local_decode = readl(devpriv->plx9080_iobase + PLX_REG_LAS0BA) &
 		       local_range & LMAP_MEM_MASK;
 	devpriv->local0_iobase = ((uint32_t)devpriv->main_phys_iobase &
 				  ~local_range) | local_decode;
 	local_range = readl(devpriv->plx9080_iobase + PLX_REG_LAS1RR) &
-		      LRNG_MEM_MASK;
+		      PLX_LASRR_MEM_MASK;
 	local_decode = readl(devpriv->plx9080_iobase + PLX_REG_LAS1BA) &
 		       local_range & LMAP_MEM_MASK;
 	devpriv->local1_iobase = ((uint32_t)devpriv->dio_counter_phys_iobase &

commit c644a11aae6e36b6dbae425cdfa9630d2abaaa16
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:05 2016 +0100

    staging: comedi: drivers: rename PLX PCI 9080 register offsets
    
    Rename the macros in "plx9080.h" that define the offsets of registers,
    following the pattern `PLX_REG_<NAME>`, where `<NAME>` is the register
    name from the PLX PCI 9080 Data Book.
    
    Add defines for the "Mailbox" registers, and add parameterized macros
    for the mailbox registers and the DMA control registers.  Make use of
    the parameterized versions of the macros where it seems appropriate.
    
    The registers for supporting the I2O (Intelligent Input/Output) feature
    are largely left undefined, just defining enough to allow the I2O
    feature to be disabled.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index c773b8ca6599..d9468db6b51e 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1238,7 +1238,7 @@ static void disable_plx_interrupts(struct comedi_device *dev)
 
 	devpriv->plx_intcsr_bits = 0;
 	writel(devpriv->plx_intcsr_bits,
-	       devpriv->plx9080_iobase + PLX_INTRCS_REG);
+	       devpriv->plx9080_iobase + PLX_REG_INTCSR);
 }
 
 static void disable_ai_interrupts(struct comedi_device *dev)
@@ -1291,14 +1291,14 @@ static void init_plx9080(struct comedi_device *dev)
 	void __iomem *plx_iobase = devpriv->plx9080_iobase;
 
 	devpriv->plx_control_bits =
-		readl(devpriv->plx9080_iobase + PLX_CONTROL_REG);
+		readl(devpriv->plx9080_iobase + PLX_REG_CNTRL);
 
 #ifdef __BIG_ENDIAN
 	bits = BIGEND_DMA0 | BIGEND_DMA1;
 #else
 	bits = 0;
 #endif
-	writel(bits, devpriv->plx9080_iobase + PLX_BIGEND_REG);
+	writel(bits, devpriv->plx9080_iobase + PLX_REG_BIGEND);
 
 	disable_plx_interrupts(dev);
 
@@ -1330,16 +1330,16 @@ static void init_plx9080(struct comedi_device *dev)
 		bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
 	else		/*  localspace0 bus is 16 bits wide */
 		bits |= PLX_LOCAL_BUS_16_WIDE_BITS;
-	writel(bits, plx_iobase + PLX_DMA1_MODE_REG);
+	writel(bits, plx_iobase + PLX_REG_DMAMODE1);
 	if (ao_cmd_is_supported(board))
-		writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
+		writel(bits, plx_iobase + PLX_REG_DMAMODE0);
 
 	/*  enable interrupts on plx 9080 */
 	devpriv->plx_intcsr_bits |=
 	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
 	    ICS_DMA0_E | ICS_DMA1_E;
 	writel(devpriv->plx_intcsr_bits,
-	       devpriv->plx9080_iobase + PLX_INTRCS_REG);
+	       devpriv->plx9080_iobase + PLX_REG_INTCSR);
 }
 
 static void disable_ai_pacing(struct comedi_device *dev)
@@ -1615,7 +1615,7 @@ static void i2c_set_sda(struct comedi_device *dev, int state)
 	struct pcidas64_private *devpriv = dev->private;
 	static const int data_bit = CTL_EE_W;
 	void __iomem *plx_control_addr = devpriv->plx9080_iobase +
-					 PLX_CONTROL_REG;
+					 PLX_REG_CNTRL;
 
 	if (state) {
 		/*  set data line high */
@@ -1636,7 +1636,7 @@ static void i2c_set_scl(struct comedi_device *dev, int state)
 	struct pcidas64_private *devpriv = dev->private;
 	static const int clock_bit = CTL_USERO;
 	void __iomem *plx_control_addr = devpriv->plx9080_iobase +
-					 PLX_CONTROL_REG;
+					 PLX_REG_CNTRL;
 
 	if (state) {
 		/*  set clock line high */
@@ -2367,14 +2367,8 @@ static inline void dma_start_sync(struct comedi_device *dev,
 
 	/*  spinlock for plx dma control/status reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	if (channel)
-		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
-		       PLX_CLEAR_DMA_INTR_BIT,
-		       devpriv->plx9080_iobase + PLX_DMA1_CS_REG);
-	else
-		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
-		       PLX_CLEAR_DMA_INTR_BIT,
-		       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
+	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
+	       devpriv->plx9080_iobase + PLX_REG_DMACSR(channel));
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
@@ -2552,21 +2546,17 @@ static inline void load_first_dma_descriptor(struct comedi_device *dev,
 	 * block.  Initializing them to zero seems to fix the problem.
 	 */
 	if (dma_channel) {
-		writel(0,
-		       devpriv->plx9080_iobase + PLX_DMA1_TRANSFER_SIZE_REG);
-		writel(0, devpriv->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG);
-		writel(0,
-		       devpriv->plx9080_iobase + PLX_DMA1_LOCAL_ADDRESS_REG);
+		writel(0, devpriv->plx9080_iobase + PLX_REG_DMASIZ1);
+		writel(0, devpriv->plx9080_iobase + PLX_REG_DMAPADR1);
+		writel(0, devpriv->plx9080_iobase + PLX_REG_DMALADR1);
 		writel(descriptor_bits,
-		       devpriv->plx9080_iobase + PLX_DMA1_DESCRIPTOR_REG);
+		       devpriv->plx9080_iobase + PLX_REG_DMADPR1);
 	} else {
-		writel(0,
-		       devpriv->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
-		writel(0, devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
-		writel(0,
-		       devpriv->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
+		writel(0, devpriv->plx9080_iobase + PLX_REG_DMASIZ0);
+		writel(0, devpriv->plx9080_iobase + PLX_REG_DMAPADR0);
+		writel(0, devpriv->plx9080_iobase + PLX_REG_DMALADR0);
 		writel(descriptor_bits,
-		       devpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+		       devpriv->plx9080_iobase + PLX_REG_DMADPR0);
 	}
 }
 
@@ -2803,12 +2793,7 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 	int num_samples = 0;
 	void __iomem *pci_addr_reg;
 
-	if (channel)
-		pci_addr_reg =
-		    devpriv->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
-	else
-		pci_addr_reg =
-		    devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+	pci_addr_reg = devpriv->plx9080_iobase + PLX_REG_DMAPADR(channel);
 
 	/*  loop until we have read all the full buffers */
 	for (j = 0, next_transfer_addr = readl(pci_addr_reg);
@@ -2850,10 +2835,10 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 	}
 	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	dma1_status = readb(devpriv->plx9080_iobase + PLX_DMA1_CS_REG);
+	dma1_status = readb(devpriv->plx9080_iobase + PLX_REG_DMACSR1);
 	if (plx_status & ICS_DMA1_A) {	/*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-		       devpriv->plx9080_iobase + PLX_DMA1_CS_REG);
+		       devpriv->plx9080_iobase + PLX_REG_DMACSR1);
 
 		if (dma1_status & PLX_DMA_EN_BIT)
 			drain_dma_buffers(dev, 1);
@@ -2902,12 +2887,12 @@ static int last_ao_dma_load_completed(struct comedi_device *dev)
 	unsigned short dma_status;
 
 	buffer_index = prev_ao_dma_index(dev);
-	dma_status = readb(devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
+	dma_status = readb(devpriv->plx9080_iobase + PLX_REG_DMACSR0);
 	if ((dma_status & PLX_DMA_DONE_BIT) == 0)
 		return 0;
 
 	transfer_address =
-		readl(devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
+		readl(devpriv->plx9080_iobase + PLX_REG_DMAPADR0);
 	if (transfer_address != devpriv->ao_buffer_bus_addr[buffer_index])
 		return 0;
 
@@ -2931,8 +2916,7 @@ static void restart_ao_dma(struct comedi_device *dev)
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int dma_desc_bits;
 
-	dma_desc_bits =
-		readl(devpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+	dma_desc_bits = readl(devpriv->plx9080_iobase + PLX_REG_DMADPR0);
 	dma_desc_bits &= ~PLX_END_OF_CHAIN_BIT;
 	load_first_dma_descriptor(dev, 0, dma_desc_bits);
 
@@ -2994,8 +2978,7 @@ static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int num_bytes;
 	unsigned int next_transfer_addr;
-	void __iomem *pci_addr_reg =
-		devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+	void __iomem *pci_addr_reg = devpriv->plx9080_iobase + PLX_REG_DMAPADR0;
 	unsigned int buffer_index;
 
 	do {
@@ -3030,15 +3013,16 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 
 	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	dma0_status = readb(devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
+	dma0_status = readb(devpriv->plx9080_iobase + PLX_REG_DMACSR0);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		if ((dma0_status & PLX_DMA_EN_BIT) &&
-		    !(dma0_status & PLX_DMA_DONE_BIT))
+		    !(dma0_status & PLX_DMA_DONE_BIT)) {
 			writeb(PLX_DMA_EN_BIT | PLX_CLEAR_DMA_INTR_BIT,
-			       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
-		else
+			       devpriv->plx9080_iobase + PLX_REG_DMACSR0);
+		} else {
 			writeb(PLX_CLEAR_DMA_INTR_BIT,
-			       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
+			       devpriv->plx9080_iobase + PLX_REG_DMACSR0);
+		}
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		if (dma0_status & PLX_DMA_EN_BIT) {
 			load_ao_dma(dev, cmd);
@@ -3069,7 +3053,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	uint32_t plx_status;
 	uint32_t plx_bits;
 
-	plx_status = readl(devpriv->plx9080_iobase + PLX_INTRCS_REG);
+	plx_status = readl(devpriv->plx9080_iobase + PLX_REG_INTCSR);
 	status = readw(devpriv->main_iobase + HW_STATUS_REG);
 
 	/*
@@ -3085,8 +3069,8 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 
 	/*  clear possible plx9080 interrupt sources */
 	if (plx_status & ICS_LDIA) {	/*  clear local doorbell interrupt */
-		plx_bits = readl(devpriv->plx9080_iobase + PLX_DBR_OUT_REG);
-		writel(plx_bits, devpriv->plx9080_iobase + PLX_DBR_OUT_REG);
+		plx_bits = readl(devpriv->plx9080_iobase + PLX_REG_L2PDBELL);
+		writel(plx_bits, devpriv->plx9080_iobase + PLX_REG_L2PDBELL);
 	}
 
 	return IRQ_HANDLED;
@@ -3725,7 +3709,7 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 	unsigned int bitstream = (read_command << 8) | address;
 	unsigned int bit;
 	void __iomem * const plx_control_addr =
-		devpriv->plx9080_iobase + PLX_CONTROL_REG;
+		devpriv->plx9080_iobase + PLX_REG_CNTRL;
 	uint16_t value;
 	static const int value_length = 16;
 	static const int eeprom_udelay = 1;
@@ -3962,7 +3946,7 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/* serial EEPROM, if present */
 	s = &dev->subdevices[8];
-	if (readl(devpriv->plx9080_iobase + PLX_CONTROL_REG) & CTL_EECHK) {
+	if (readl(devpriv->plx9080_iobase + PLX_REG_CNTRL) & CTL_EECHK) {
 		s->type = COMEDI_SUBD_MEMORY;
 		s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
 		s->n_chan = 128;
@@ -4019,15 +4003,15 @@ static int auto_attach(struct comedi_device *dev,
 	}
 
 	/*  figure out what local addresses are */
-	local_range = readl(devpriv->plx9080_iobase + PLX_LAS0RNG_REG) &
+	local_range = readl(devpriv->plx9080_iobase + PLX_REG_LAS0RR) &
 		      LRNG_MEM_MASK;
-	local_decode = readl(devpriv->plx9080_iobase + PLX_LAS0MAP_REG) &
+	local_decode = readl(devpriv->plx9080_iobase + PLX_REG_LAS0BA) &
 		       local_range & LMAP_MEM_MASK;
 	devpriv->local0_iobase = ((uint32_t)devpriv->main_phys_iobase &
 				  ~local_range) | local_decode;
-	local_range = readl(devpriv->plx9080_iobase + PLX_LAS1RNG_REG) &
+	local_range = readl(devpriv->plx9080_iobase + PLX_REG_LAS1RR) &
 		      LRNG_MEM_MASK;
-	local_decode = readl(devpriv->plx9080_iobase + PLX_LAS1MAP_REG) &
+	local_decode = readl(devpriv->plx9080_iobase + PLX_REG_LAS1BA) &
 		       local_range & LMAP_MEM_MASK;
 	devpriv->local1_iobase = ((uint32_t)devpriv->dio_counter_phys_iobase &
 				  ~local_range) | local_decode;

commit d2b0fc6e29bb6015f811b7574dde64026179e57a
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Wed Feb 24 16:45:34 2016 +0530

    staging: comedi: drivers: Remove use of deprecated pci API
    
    Replace pci_[alloc|free]_consistent occurences with
    dma_[alloc|free]_coherent.
    
    The Coccinelle semantic patch that was used to make some of these
    changes is as follows:
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_KERNEL
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_KERNEL
      )
    )
    
    alloc_and_init_dma_members does not affect the interrupt status and is
    only called by auto_attach, which also does not affect the interrupt
    status. auto_attach() also contains a call to comedi_alloc_devpriv()
    which calls kzalloc with GFP_KERNEL flag.  Thus, there seems to be no
    danger that dma_alloc_coherent can be called with interrupts turned
    off, and GFP_KERNEL can be used.
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index e918d4249629..c773b8ca6599 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1480,35 +1480,39 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	/*  allocate pci dma buffers */
 	for (i = 0; i < ai_dma_ring_count(board); i++) {
 		devpriv->ai_buffer[i] =
-			pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
-					     &devpriv->ai_buffer_bus_addr[i]);
+			dma_alloc_coherent(&pcidev->dev, DMA_BUFFER_SIZE,
+					   &devpriv->ai_buffer_bus_addr[i],
+					   GFP_KERNEL);
 		if (!devpriv->ai_buffer[i])
 			return -ENOMEM;
 	}
 	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 		if (ao_cmd_is_supported(board)) {
 			devpriv->ao_buffer[i] =
-				pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
-						     &devpriv->
-						      ao_buffer_bus_addr[i]);
+				dma_alloc_coherent(&pcidev->dev,
+						   DMA_BUFFER_SIZE,
+						   &devpriv->
+						   ao_buffer_bus_addr[i],
+						   GFP_KERNEL);
 			if (!devpriv->ao_buffer[i])
 				return -ENOMEM;
 		}
 	}
 	/*  allocate dma descriptors */
 	devpriv->ai_dma_desc =
-		pci_alloc_consistent(pcidev, sizeof(struct plx_dma_desc) *
-				     ai_dma_ring_count(board),
-				     &devpriv->ai_dma_desc_bus_addr);
+		dma_alloc_coherent(&pcidev->dev, sizeof(struct plx_dma_desc) *
+				   ai_dma_ring_count(board),
+				   &devpriv->ai_dma_desc_bus_addr, GFP_KERNEL);
 	if (!devpriv->ai_dma_desc)
 		return -ENOMEM;
 
 	if (ao_cmd_is_supported(board)) {
 		devpriv->ao_dma_desc =
-			pci_alloc_consistent(pcidev,
-					     sizeof(struct plx_dma_desc) *
-					     AO_DMA_RING_COUNT,
-					     &devpriv->ao_dma_desc_bus_addr);
+			dma_alloc_coherent(&pcidev->dev,
+					   sizeof(struct plx_dma_desc) *
+					   AO_DMA_RING_COUNT,
+					   &devpriv->ao_dma_desc_bus_addr,
+					   GFP_KERNEL);
 		if (!devpriv->ao_dma_desc)
 			return -ENOMEM;
 	}
@@ -1564,31 +1568,31 @@ static void cb_pcidas64_free_dma(struct comedi_device *dev)
 	/* free pci dma buffers */
 	for (i = 0; i < ai_dma_ring_count(board); i++) {
 		if (devpriv->ai_buffer[i])
-			pci_free_consistent(pcidev,
-					    DMA_BUFFER_SIZE,
-					    devpriv->ai_buffer[i],
-					    devpriv->ai_buffer_bus_addr[i]);
+			dma_free_coherent(&pcidev->dev,
+					  DMA_BUFFER_SIZE,
+					  devpriv->ai_buffer[i],
+					  devpriv->ai_buffer_bus_addr[i]);
 	}
 	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 		if (devpriv->ao_buffer[i])
-			pci_free_consistent(pcidev,
-					    DMA_BUFFER_SIZE,
-					    devpriv->ao_buffer[i],
-					    devpriv->ao_buffer_bus_addr[i]);
+			dma_free_coherent(&pcidev->dev,
+					  DMA_BUFFER_SIZE,
+					  devpriv->ao_buffer[i],
+					  devpriv->ao_buffer_bus_addr[i]);
 	}
 	/* free dma descriptors */
 	if (devpriv->ai_dma_desc)
-		pci_free_consistent(pcidev,
-				    sizeof(struct plx_dma_desc) *
-				    ai_dma_ring_count(board),
-				    devpriv->ai_dma_desc,
-				    devpriv->ai_dma_desc_bus_addr);
+		dma_free_coherent(&pcidev->dev,
+				  sizeof(struct plx_dma_desc) *
+				  ai_dma_ring_count(board),
+				  devpriv->ai_dma_desc,
+				  devpriv->ai_dma_desc_bus_addr);
 	if (devpriv->ao_dma_desc)
-		pci_free_consistent(pcidev,
-				    sizeof(struct plx_dma_desc) *
-				    AO_DMA_RING_COUNT,
-				    devpriv->ao_dma_desc,
-				    devpriv->ao_dma_desc_bus_addr);
+		dma_free_coherent(&pcidev->dev,
+				  sizeof(struct plx_dma_desc) *
+				  AO_DMA_RING_COUNT,
+				  devpriv->ao_dma_desc,
+				  devpriv->ao_dma_desc_bus_addr);
 }
 
 static inline void warn_external_queue(struct comedi_device *dev)

commit 2ead7b32aadc83833d7cf6e9751ef56b89e90462
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Fri Feb 19 20:57:15 2016 +0530

    staging: comedi: drivers: Use DIV_ROUND_CLOSEST
    
    The kernel.h macro DIV_ROUND_CLOSEST performs the computation
    `(x +d/2)/d` but is perhaps more readable.
    
    The Coccinelle script used is as follows:
    // <smpl>
    @@
    expression x,__divisor;
    @@
    - (((x) + ((__divisor) / 2)) / (__divisor))
    + DIV_ROUND_CLOSEST(x,__divisor)
    // </smpl>
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index d33b8fe872a7..e918d4249629 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1376,7 +1376,7 @@ static int set_ai_fifo_segment_length(struct comedi_device *dev,
 		num_entries = fifo->max_segment_length;
 
 	/*  1 == 256 entries, 2 == 512 entries, etc */
-	num_increments = (num_entries + increment_size / 2) / increment_size;
+	num_increments = DIV_ROUND_CLOSEST(num_entries, increment_size);
 
 	bits = (~(num_increments - 1)) & fifo->fifo_size_reg_mask;
 	devpriv->fifo_size_bits &= ~fifo->fifo_size_reg_mask;
@@ -2004,7 +2004,7 @@ static unsigned int get_divisor(unsigned int ns, unsigned int flags)
 		break;
 	case CMDF_ROUND_NEAREST:
 	default:
-		divisor = (ns + TIMER_BASE / 2) / TIMER_BASE;
+		divisor = DIV_ROUND_CLOSEST(ns, TIMER_BASE);
 		break;
 	}
 	return divisor;

commit 52762ad12aa545000978382b13d64382d284e671
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 18 10:54:53 2015 -0700

    staging: comedi: cb_pcidas64: rename 'thisboard' variables
    
    For aesthetics, rename the 'thisboard' variables to 'board'. That name
    is more commonly used for the boardinfo pointer in comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 3d646c19f352..d33b8fe872a7 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1106,10 +1106,10 @@ static const struct pcidas64_board pcidas64_boards[] = {
 static inline unsigned short se_diff_bit_6xxx(struct comedi_device *dev,
 					      int use_differential)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 
-	if ((thisboard->layout == LAYOUT_64XX && !use_differential) ||
-	    (thisboard->layout == LAYOUT_60XX && use_differential))
+	if ((board->layout == LAYOUT_64XX && !use_differential) ||
+	    (board->layout == LAYOUT_60XX && use_differential))
 		return ADC_SE_DIFF_BIT;
 
 	return 0;
@@ -1182,17 +1182,17 @@ struct pcidas64_private {
 static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 				       unsigned int range_index)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 
-	return thisboard->ai_range_code[range_index] << 8;
+	return board->ai_range_code[range_index] << 8;
 }
 
 static unsigned int hw_revision(const struct comedi_device *dev,
 				uint16_t hw_status_bits)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 
-	if (thisboard->layout == LAYOUT_4020)
+	if (board->layout == LAYOUT_4020)
 		return (hw_status_bits >> 13) & 0x7;
 
 	return (hw_status_bits >> 12) & 0xf;
@@ -1202,8 +1202,8 @@ static void set_dac_range_bits(struct comedi_device *dev,
 			       uint16_t *bits, unsigned int channel,
 			       unsigned int range)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
-	unsigned int code = thisboard->ao_range_code[range];
+	const struct pcidas64_board *board = dev->board_ptr;
+	unsigned int code = board->ao_range_code[range];
 
 	if (channel > 1)
 		dev_err(dev->class_dev, "bug! bad channel?\n");
@@ -1259,7 +1259,7 @@ static void disable_ai_interrupts(struct comedi_device *dev)
 static void enable_ai_interrupts(struct comedi_device *dev,
 				 const struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	uint32_t bits;
 	unsigned long flags;
@@ -1272,7 +1272,7 @@ static void enable_ai_interrupts(struct comedi_device *dev,
 	 */
 	if (cmd->flags & CMDF_WAKE_EOS) {
 		/*  4020 doesn't support pio transfers except for fifo dregs */
-		if (thisboard->layout != LAYOUT_4020)
+		if (board->layout != LAYOUT_4020)
 			bits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;
 	}
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -1285,7 +1285,7 @@ static void enable_ai_interrupts(struct comedi_device *dev,
 /* initialize plx9080 chip */
 static void init_plx9080(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	uint32_t bits;
 	void __iomem *plx_iobase = devpriv->plx9080_iobase;
@@ -1326,12 +1326,12 @@ static void init_plx9080(struct comedi_device *dev)
 	/*  enable local burst mode */
 	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
 	/*  4020 uses 32 bit dma */
-	if (thisboard->layout == LAYOUT_4020)
+	if (board->layout == LAYOUT_4020)
 		bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
 	else		/*  localspace0 bus is 16 bits wide */
 		bits |= PLX_LOCAL_BUS_16_WIDE_BITS;
 	writel(bits, plx_iobase + PLX_DMA1_MODE_REG);
-	if (ao_cmd_is_supported(thisboard))
+	if (ao_cmd_is_supported(board))
 		writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
 
 	/*  enable interrupts on plx 9080 */
@@ -1363,10 +1363,10 @@ static void disable_ai_pacing(struct comedi_device *dev)
 static int set_ai_fifo_segment_length(struct comedi_device *dev,
 				      unsigned int num_entries)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	static const int increment_size = 0x100;
-	const struct hw_fifo_info *const fifo = thisboard->ai_fifo;
+	const struct hw_fifo_info *const fifo = board->ai_fifo;
 	unsigned int num_increments;
 	uint16_t bits;
 
@@ -1394,10 +1394,10 @@ static int set_ai_fifo_segment_length(struct comedi_device *dev,
  */
 static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	unsigned int num_fifo_entries;
 	int retval;
-	const struct hw_fifo_info *const fifo = thisboard->ai_fifo;
+	const struct hw_fifo_info *const fifo = board->ai_fifo;
 
 	num_fifo_entries = num_samples / fifo->sample_packing_ratio;
 
@@ -1415,17 +1415,17 @@ static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 /* query length of fifo */
 static unsigned int ai_fifo_size(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 
 	return devpriv->ai_fifo_segment_length *
-	       thisboard->ai_fifo->num_segments *
-	       thisboard->ai_fifo->sample_packing_ratio;
+	       board->ai_fifo->num_segments *
+	       board->ai_fifo->sample_packing_ratio;
 }
 
 static void init_stc_registers(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	uint16_t bits;
 	unsigned long flags;
@@ -1445,7 +1445,7 @@ static void init_stc_registers(struct comedi_device *dev)
 	writew(0xff, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
 
 	bits = SLOW_DAC_BIT | DMA_CH_SELECT_BIT;
-	if (thisboard->layout == LAYOUT_4020)
+	if (board->layout == LAYOUT_4020)
 		bits |= INTERNAL_CLOCK_4020_BITS;
 	devpriv->hw_config_bits |= bits;
 	writew(devpriv->hw_config_bits,
@@ -1458,8 +1458,7 @@ static void init_stc_registers(struct comedi_device *dev)
 
 	/*  set fifos to maximum size */
 	devpriv->fifo_size_bits |= DAC_FIFO_BITS;
-	set_ai_fifo_segment_length(dev,
-				   thisboard->ai_fifo->max_segment_length);
+	set_ai_fifo_segment_length(dev, board->ai_fifo->max_segment_length);
 
 	devpriv->dac_control1_bits = DAC_OUTPUT_ENABLE_BIT;
 	devpriv->intr_enable_bits =
@@ -1473,13 +1472,13 @@ static void init_stc_registers(struct comedi_device *dev)
 
 static int alloc_and_init_dma_members(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	int i;
 
 	/*  allocate pci dma buffers */
-	for (i = 0; i < ai_dma_ring_count(thisboard); i++) {
+	for (i = 0; i < ai_dma_ring_count(board); i++) {
 		devpriv->ai_buffer[i] =
 			pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
 					     &devpriv->ai_buffer_bus_addr[i]);
@@ -1487,7 +1486,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 			return -ENOMEM;
 	}
 	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
-		if (ao_cmd_is_supported(thisboard)) {
+		if (ao_cmd_is_supported(board)) {
 			devpriv->ao_buffer[i] =
 				pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
 						     &devpriv->
@@ -1499,12 +1498,12 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	/*  allocate dma descriptors */
 	devpriv->ai_dma_desc =
 		pci_alloc_consistent(pcidev, sizeof(struct plx_dma_desc) *
-				     ai_dma_ring_count(thisboard),
+				     ai_dma_ring_count(board),
 				     &devpriv->ai_dma_desc_bus_addr);
 	if (!devpriv->ai_dma_desc)
 		return -ENOMEM;
 
-	if (ao_cmd_is_supported(thisboard)) {
+	if (ao_cmd_is_supported(board)) {
 		devpriv->ao_dma_desc =
 			pci_alloc_consistent(pcidev,
 					     sizeof(struct plx_dma_desc) *
@@ -1514,10 +1513,10 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 			return -ENOMEM;
 	}
 	/*  initialize dma descriptors */
-	for (i = 0; i < ai_dma_ring_count(thisboard); i++) {
+	for (i = 0; i < ai_dma_ring_count(board); i++) {
 		devpriv->ai_dma_desc[i].pci_start_addr =
 			cpu_to_le32(devpriv->ai_buffer_bus_addr[i]);
-		if (thisboard->layout == LAYOUT_4020)
+		if (board->layout == LAYOUT_4020)
 			devpriv->ai_dma_desc[i].local_start_addr =
 				cpu_to_le32(devpriv->local1_iobase +
 					    ADC_FIFO_REG);
@@ -1528,12 +1527,12 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 		devpriv->ai_dma_desc[i].transfer_size = cpu_to_le32(0);
 		devpriv->ai_dma_desc[i].next =
 			cpu_to_le32((devpriv->ai_dma_desc_bus_addr +
-				     ((i + 1) % ai_dma_ring_count(thisboard)) *
+				     ((i + 1) % ai_dma_ring_count(board)) *
 				     sizeof(devpriv->ai_dma_desc[0])) |
 				    PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
 				    PLX_XFER_LOCAL_TO_PCI);
 	}
-	if (ao_cmd_is_supported(thisboard)) {
+	if (ao_cmd_is_supported(board)) {
 		for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 			devpriv->ao_dma_desc[i].pci_start_addr =
 				cpu_to_le32(devpriv->ao_buffer_bus_addr[i]);
@@ -1554,7 +1553,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 
 static void cb_pcidas64_free_dma(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	int i;
@@ -1563,7 +1562,7 @@ static void cb_pcidas64_free_dma(struct comedi_device *dev)
 		return;
 
 	/* free pci dma buffers */
-	for (i = 0; i < ai_dma_ring_count(thisboard); i++) {
+	for (i = 0; i < ai_dma_ring_count(board); i++) {
 		if (devpriv->ai_buffer[i])
 			pci_free_consistent(pcidev,
 					    DMA_BUFFER_SIZE,
@@ -1581,7 +1580,7 @@ static void cb_pcidas64_free_dma(struct comedi_device *dev)
 	if (devpriv->ai_dma_desc)
 		pci_free_consistent(pcidev,
 				    sizeof(struct plx_dma_desc) *
-				    ai_dma_ring_count(thisboard),
+				    ai_dma_ring_count(board),
 				    devpriv->ai_dma_desc,
 				    devpriv->ai_dma_desc_bus_addr);
 	if (devpriv->ao_dma_desc)
@@ -1736,12 +1735,12 @@ static int cb_pcidas64_ai_eoc(struct comedi_device *dev,
 			      struct comedi_insn *insn,
 			      unsigned long context)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int status;
 
 	status = readw(devpriv->main_iobase + HW_STATUS_REG);
-	if (thisboard->layout == LAYOUT_4020) {
+	if (board->layout == LAYOUT_4020) {
 		status = readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG);
 		if (status)
 			return 0;
@@ -1755,7 +1754,7 @@ static int cb_pcidas64_ai_eoc(struct comedi_device *dev,
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int bits = 0, n;
 	unsigned int channel, range, aref;
@@ -1779,7 +1778,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	       devpriv->main_iobase + ADC_CONTROL1_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	if (thisboard->layout != LAYOUT_4020) {
+	if (board->layout != LAYOUT_4020) {
 		/*  use internal queue */
 		devpriv->hw_config_bits &= ~EXT_QUEUE_BIT;
 		writew(devpriv->hw_config_bits,
@@ -1789,7 +1788,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (insn->chanspec & CR_ALT_SOURCE) {
 			unsigned int cal_en_bit;
 
-			if (thisboard->layout == LAYOUT_60XX)
+			if (board->layout == LAYOUT_60XX)
 				cal_en_bit = CAL_EN_60XX_BIT;
 			else
 				cal_en_bit = CAL_EN_64XX_BIT;
@@ -1870,7 +1869,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (ret)
 			return ret;
 
-		if (thisboard->layout == LAYOUT_4020)
+		if (board->layout == LAYOUT_4020)
 			data[n] = readl(dev->mmio + ADC_FIFO_REG) & 0xffff;
 		else
 			data[n] = readw(devpriv->main_iobase + PIPE1_READ_REG);
@@ -1882,12 +1881,12 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 static int ai_config_calibration_source(struct comedi_device *dev,
 					unsigned int *data)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int source = data[1];
 	int num_calibration_sources;
 
-	if (thisboard->layout == LAYOUT_60XX)
+	if (board->layout == LAYOUT_60XX)
 		num_calibration_sources = 16;
 	else
 		num_calibration_sources = 8;
@@ -1904,9 +1903,9 @@ static int ai_config_calibration_source(struct comedi_device *dev,
 
 static int ai_config_block_size(struct comedi_device *dev, unsigned int *data)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	int fifo_size;
-	const struct hw_fifo_info *const fifo = thisboard->ai_fifo;
+	const struct hw_fifo_info *const fifo = board->ai_fifo;
 	unsigned int block_size, requested_block_size;
 	int retval;
 
@@ -1957,9 +1956,9 @@ static int ai_config_master_clock_4020(struct comedi_device *dev,
 /* XXX could add support for 60xx series */
 static int ai_config_master_clock(struct comedi_device *dev, unsigned int *data)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 
-	switch (thisboard->layout) {
+	switch (board->layout) {
 	case LAYOUT_4020:
 		return ai_config_master_clock_4020(dev, data);
 	default:
@@ -2019,7 +2018,7 @@ static unsigned int get_divisor(unsigned int ns, unsigned int flags)
  */
 static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	unsigned long long convert_divisor = 0;
 	unsigned int scan_divisor;
 	static const int min_convert_divisor = 3;
@@ -2029,7 +2028,7 @@ static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 	unsigned long long max_scan_divisor, min_scan_divisor;
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		if (thisboard->layout == LAYOUT_4020) {
+		if (board->layout == LAYOUT_4020) {
 			cmd->convert_arg = 0;
 		} else {
 			convert_divisor = get_divisor(cmd->convert_arg,
@@ -2106,7 +2105,7 @@ static int cb_pcidas64_ai_check_chanlist(struct comedi_device *dev,
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	int err = 0;
 	unsigned int tmp_arg, tmp_arg2;
 	unsigned int triggers;
@@ -2116,14 +2115,14 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
 
 	triggers = TRIG_TIMER;
-	if (thisboard->layout == LAYOUT_4020)
+	if (board->layout == LAYOUT_4020)
 		triggers |= TRIG_OTHER;
 	else
 		triggers |= TRIG_FOLLOW;
 	err |= comedi_check_trigger_src(&cmd->scan_begin_src, triggers);
 
 	triggers = TRIG_TIMER;
-	if (thisboard->layout == LAYOUT_4020)
+	if (board->layout == LAYOUT_4020)
 		triggers |= TRIG_NOW;
 	else
 		triggers |= TRIG_EXT;
@@ -2165,13 +2164,12 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	}
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		if (thisboard->layout == LAYOUT_4020) {
+		if (board->layout == LAYOUT_4020) {
 			err |= comedi_check_trigger_arg_is(&cmd->convert_arg,
 							   0);
 		} else {
 			err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
-							    thisboard->
-							    ai_speed);
+							    board->ai_speed);
 			/*
 			 * if scans are timed faster than conversion rate
 			 * allows
@@ -2259,12 +2257,12 @@ static void setup_sample_counters(struct comedi_device *dev,
 
 static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int num_samples;
 
 	num_samples = devpriv->ai_fifo_segment_length *
-		      thisboard->ai_fifo->sample_packing_ratio;
+		      board->ai_fifo->sample_packing_ratio;
 	if (num_samples > DMA_BUFFER_SIZE / sizeof(uint16_t))
 		num_samples = DMA_BUFFER_SIZE / sizeof(uint16_t);
 
@@ -2346,9 +2344,9 @@ static void select_master_clock_4020(struct comedi_device *dev,
 static void select_master_clock(struct comedi_device *dev,
 				const struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 
-	switch (thisboard->layout) {
+	switch (board->layout) {
 	case LAYOUT_4020:
 		select_master_clock_4020(dev, cmd);
 		break;
@@ -2378,7 +2376,7 @@ static inline void dma_start_sync(struct comedi_device *dev,
 
 static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	uint32_t convert_counter = 0, scan_counter = 0;
 
@@ -2386,7 +2384,7 @@ static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 
 	select_master_clock(dev, cmd);
 
-	if (thisboard->layout == LAYOUT_4020) {
+	if (board->layout == LAYOUT_4020) {
 		convert_counter = ai_convert_counter_4020(dev, cmd);
 	} else {
 		convert_counter = ai_convert_counter_6xxx(dev, cmd);
@@ -2427,12 +2425,12 @@ static int use_internal_queue_6xxx(const struct comedi_cmd *cmd)
 static int setup_channel_queue(struct comedi_device *dev,
 			       const struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned short bits;
 	int i;
 
-	if (thisboard->layout != LAYOUT_4020) {
+	if (board->layout != LAYOUT_4020) {
 		if (use_internal_queue_6xxx(cmd)) {
 			devpriv->hw_config_bits &= ~EXT_QUEUE_BIT;
 			writew(devpriv->hw_config_bits,
@@ -2570,7 +2568,7 @@ static inline void load_first_dma_descriptor(struct comedi_device *dev,
 
 static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -2599,7 +2597,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* set mode, allow conversions through software gate */
 	devpriv->adc_control1_bits |= ADC_SW_GATE_BIT;
 	devpriv->adc_control1_bits &= ~ADC_DITHER_BIT;
-	if (thisboard->layout != LAYOUT_4020) {
+	if (board->layout != LAYOUT_4020) {
 		devpriv->adc_control1_bits &= ~ADC_MODE_MASK;
 		if (cmd->convert_src == TRIG_EXT)
 			/*  good old mode 13 */
@@ -2629,11 +2627,11 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	writew(0, devpriv->main_iobase + ADC_BUFFER_CLEAR_REG);
 
 	if ((cmd->flags & CMDF_WAKE_EOS) == 0 ||
-	    thisboard->layout == LAYOUT_4020) {
+	    board->layout == LAYOUT_4020) {
 		devpriv->ai_dma_index = 0;
 
 		/*  set dma transfer size */
-		for (i = 0; i < ai_dma_ring_count(thisboard); i++)
+		for (i = 0; i < ai_dma_ring_count(board); i++)
 			devpriv->ai_dma_desc[i].transfer_size =
 				cpu_to_le32(dma_transfer_size(dev) *
 					    sizeof(uint16_t));
@@ -2648,7 +2646,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		dma_start_sync(dev, 1);
 	}
 
-	if (thisboard->layout == LAYOUT_4020) {
+	if (board->layout == LAYOUT_4020) {
 		/* set source for external triggers */
 		bits = 0;
 		if (cmd->start_src == TRIG_EXT && CR_CHAN(cmd->start_arg))
@@ -2783,9 +2781,9 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 /* empty fifo */
 static void pio_drain_ai_fifo(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 
-	if (thisboard->layout == LAYOUT_4020)
+	if (board->layout == LAYOUT_4020)
 		pio_drain_ai_fifo_32(dev);
 	else
 		pio_drain_ai_fifo_16(dev);
@@ -2793,7 +2791,7 @@ static void pio_drain_ai_fifo(struct comedi_device *dev)
 
 static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	uint32_t next_transfer_addr;
@@ -2814,14 +2812,14 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 	      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] ||
 	      next_transfer_addr >=
 	      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] +
-	      DMA_BUFFER_SIZE) && j < ai_dma_ring_count(thisboard); j++) {
+	      DMA_BUFFER_SIZE) && j < ai_dma_ring_count(board); j++) {
 		/*  transfer data from dma buffer to comedi buffer */
 		num_samples = comedi_nsamples_left(s, dma_transfer_size(dev));
 		comedi_buf_write_samples(s,
 				devpriv->ai_buffer[devpriv->ai_dma_index],
 				num_samples);
 		devpriv->ai_dma_index = (devpriv->ai_dma_index + 1) %
-					ai_dma_ring_count(thisboard);
+					ai_dma_ring_count(board);
 	}
 	/*
 	 * XXX check for dma ring buffer overrun
@@ -2833,7 +2831,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 				unsigned short status,
 				unsigned int plx_status)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
@@ -2862,7 +2860,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 	if ((status & ADC_DONE_BIT) ||
 	    ((cmd->flags & CMDF_WAKE_EOS) &&
 	     (status & ADC_INTR_PENDING_BIT) &&
-	     (thisboard->layout != LAYOUT_4020))) {
+	     (board->layout != LAYOUT_4020))) {
 		spin_lock_irqsave(&dev->spinlock, flags);
 		if (devpriv->ai_cmd_running) {
 			spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -3113,7 +3111,7 @@ static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	int chan = CR_CHAN(insn->chanspec);
 	int range = CR_RANGE(insn->chanspec);
@@ -3127,7 +3125,7 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	       devpriv->main_iobase + DAC_CONTROL1_REG);
 
 	/*  write to channel */
-	if (thisboard->layout == LAYOUT_4020) {
+	if (board->layout == LAYOUT_4020) {
 		writew(data[0] & 0xff,
 		       devpriv->main_iobase + dac_lsb_4020_reg(chan));
 		writew((data[0] >> 8) & 0xf,
@@ -3270,11 +3268,11 @@ static inline int external_ai_queue_in_use(struct comedi_device *dev,
 					   struct comedi_subdevice *s,
 					   struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 
 	if (s->busy)
 		return 0;
-	if (thisboard->layout == LAYOUT_4020)
+	if (board->layout == LAYOUT_4020)
 		return 0;
 	else if (use_internal_queue_6xxx(cmd))
 		return 0;
@@ -3353,7 +3351,7 @@ static int cb_pcidas64_ao_check_chanlist(struct comedi_device *dev,
 static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	int err = 0;
 	unsigned int tmp_arg;
 
@@ -3391,7 +3389,7 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
-						    thisboard->ao_scan_speed);
+						    board->ao_scan_speed);
 		if (get_ao_divisor(cmd->scan_begin_arg, cmd->flags) >
 		    max_counter_value) {
 			cmd->scan_begin_arg = (max_counter_value + 2) *
@@ -3624,9 +3622,9 @@ static int caldac_i2c_write(struct comedi_device *dev,
 static void caldac_write(struct comedi_device *dev, unsigned int channel,
 			 unsigned int value)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 
-	switch (thisboard->layout) {
+	switch (board->layout) {
 	case LAYOUT_60XX:
 	case LAYOUT_64XX:
 		caldac_8800_write(dev, channel, value);
@@ -3792,7 +3790,7 @@ static int eeprom_read_insn(struct comedi_device *dev,
  */
 static int setup_subdevices(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = dev->board_ptr;
+	const struct pcidas64_board *board = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	int i;
@@ -3807,21 +3805,21 @@ static int setup_subdevices(struct comedi_device *dev)
 	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DITHER | SDF_CMD_READ;
-	if (thisboard->layout == LAYOUT_60XX)
+	if (board->layout == LAYOUT_60XX)
 		s->subdev_flags |= SDF_COMMON | SDF_DIFF;
-	else if (thisboard->layout == LAYOUT_64XX)
+	else if (board->layout == LAYOUT_64XX)
 		s->subdev_flags |= SDF_DIFF;
 	/* XXX Number of inputs in differential mode is ignored */
-	s->n_chan = thisboard->ai_se_chans;
+	s->n_chan = board->ai_se_chans;
 	s->len_chanlist = 0x2000;
-	s->maxdata = (1 << thisboard->ai_bits) - 1;
-	s->range_table = thisboard->ai_range_table;
+	s->maxdata = (1 << board->ai_bits) - 1;
+	s->range_table = board->ai_range_table;
 	s->insn_read = ai_rinsn;
 	s->insn_config = ai_config_insn;
 	s->do_cmd = ai_cmd;
 	s->do_cmdtest = ai_cmdtest;
 	s->cancel = ai_cancel;
-	if (thisboard->layout == LAYOUT_4020) {
+	if (board->layout == LAYOUT_4020) {
 		uint8_t data;
 		/*
 		 * set adc to read from inputs
@@ -3837,24 +3835,24 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/* analog output subdevice */
 	s = &dev->subdevices[1];
-	if (thisboard->ao_nchan) {
+	if (board->ao_nchan) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE |
 				  SDF_GROUND | SDF_CMD_WRITE;
-		s->n_chan = thisboard->ao_nchan;
-		s->maxdata = (1 << thisboard->ao_bits) - 1;
-		s->range_table = thisboard->ao_range_table;
+		s->n_chan = board->ao_nchan;
+		s->maxdata = (1 << board->ao_bits) - 1;
+		s->range_table = board->ao_range_table;
 		s->insn_write = ao_winsn;
 
 		ret = comedi_alloc_subdev_readback(s);
 		if (ret)
 			return ret;
 
-		if (ao_cmd_is_supported(thisboard)) {
+		if (ao_cmd_is_supported(board)) {
 			dev->write_subdev = s;
 			s->do_cmdtest = ao_cmdtest;
 			s->do_cmd = ao_cmd;
-			s->len_chanlist = thisboard->ao_nchan;
+			s->len_chanlist = board->ao_nchan;
 			s->cancel = ao_cancel;
 		}
 	} else {
@@ -3863,7 +3861,7 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/*  digital input */
 	s = &dev->subdevices[2];
-	if (thisboard->layout == LAYOUT_64XX) {
+	if (board->layout == LAYOUT_64XX) {
 		s->type = COMEDI_SUBD_DI;
 		s->subdev_flags = SDF_READABLE;
 		s->n_chan = 4;
@@ -3875,7 +3873,7 @@ static int setup_subdevices(struct comedi_device *dev)
 	}
 
 	/*  digital output */
-	if (thisboard->layout == LAYOUT_64XX) {
+	if (board->layout == LAYOUT_64XX) {
 		s = &dev->subdevices[3];
 		s->type = COMEDI_SUBD_DO;
 		s->subdev_flags = SDF_WRITABLE;
@@ -3889,8 +3887,8 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/* 8255 */
 	s = &dev->subdevices[4];
-	if (thisboard->has_8255) {
-		if (thisboard->layout == LAYOUT_4020) {
+	if (board->has_8255) {
+		if (board->layout == LAYOUT_4020) {
 			ret = subdev_8255_init(dev, s, dio_callback_4020,
 					       I8255_4020_REG);
 		} else {
@@ -3905,7 +3903,7 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/*  8 channel dio for 60xx */
 	s = &dev->subdevices[5];
-	if (thisboard->layout == LAYOUT_60XX) {
+	if (board->layout == LAYOUT_60XX) {
 		s->type = COMEDI_SUBD_DIO;
 		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
 		s->n_chan = 8;
@@ -3922,7 +3920,7 @@ static int setup_subdevices(struct comedi_device *dev)
 	s->type = COMEDI_SUBD_CALIB;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 	s->n_chan = 8;
-	if (thisboard->layout == LAYOUT_4020)
+	if (board->layout == LAYOUT_4020)
 		s->maxdata = 0xfff;
 	else
 		s->maxdata = 0xff;
@@ -3939,7 +3937,7 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/*  2 channel ad8402 potentiometer */
 	s = &dev->subdevices[7];
-	if (thisboard->layout == LAYOUT_64XX) {
+	if (board->layout == LAYOUT_64XX) {
 		s->type = COMEDI_SUBD_CALIB;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 		s->n_chan = 2;
@@ -3981,16 +3979,16 @@ static int auto_attach(struct comedi_device *dev,
 		       unsigned long context)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	const struct pcidas64_board *thisboard = NULL;
+	const struct pcidas64_board *board = NULL;
 	struct pcidas64_private *devpriv;
 	uint32_t local_range, local_decode;
 	int retval;
 
 	if (context < ARRAY_SIZE(pcidas64_boards))
-		thisboard = &pcidas64_boards[context];
-	if (!thisboard)
+		board = &pcidas64_boards[context];
+	if (!board)
 		return -ENODEV;
-	dev->board_ptr = thisboard;
+	dev->board_ptr = board;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
@@ -4002,7 +4000,7 @@ static int auto_attach(struct comedi_device *dev,
 	pci_set_master(pcidev);
 
 	/* Initialize dev->board_name */
-	dev->board_name = thisboard->name;
+	dev->board_name = board->name;
 
 	devpriv->main_phys_iobase = pci_resource_start(pcidev, 2);
 	devpriv->dio_counter_phys_iobase = pci_resource_start(pcidev, 3);

commit 85c12b82c6090c04838cf3ba7216afdfae6157cb
Author: Amaury Denoyelle <amaury.denoyelle@gmail.com>
Date:   Tue May 19 19:57:50 2015 +0200

    Staging: comedi: fix style for multi-line comments in cb_pcidas64.c
    
    This patch reformat multi-line comments which are not properly written
    according to the kernel coding style in cb_pcidas64.c
    
    Signed-off-by: Amaury Denoyelle <amaury.denoyelle@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index f1bba2b6c935..3d646c19f352 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -155,8 +155,10 @@ static inline unsigned int dac_msb_4020_reg(unsigned int channel)
 }
 
 enum read_only_registers {
-	/*  hardware status register,
-	 *  reading this apparently clears pending interrupts as well */
+	/*
+	 * hardware status register,
+	 * reading this apparently clears pending interrupts as well
+	 */
 	HW_STATUS_REG = 0x0,
 	PIPE1_READ_REG = 0x4,
 	ADC_READ_PNTR_REG = 0x8,
@@ -301,7 +303,8 @@ enum calibration_contents {
 	CAL_GAIN_BIT = 0x800,
 };
 
-/* calibration sources for 6025 are:
+/*
+ * calibration sources for 6025 are:
  *  0 : ground
  *  1 : 10V
  *  2 : 5V
@@ -661,8 +664,10 @@ static const struct hw_fifo_info ai_fifo_60xx = {
 	.fifo_size_reg_mask = 0x7f,
 };
 
-/* maximum number of dma transfers we will chain together into a ring
- * (and the maximum number of dma buffers we maintain) */
+/*
+ * maximum number of dma transfers we will chain together into a ring
+ * (and the maximum number of dma buffers we maintain)
+ */
 #define MAX_AI_DMA_RING_COUNT (0x80000 / DMA_BUFFER_SIZE)
 #define MIN_AI_DMA_RING_COUNT (0x10000 / DMA_BUFFER_SIZE)
 #define AO_DMA_RING_COUNT (0x10000 / DMA_BUFFER_SIZE)
@@ -1261,8 +1266,10 @@ static void enable_ai_interrupts(struct comedi_device *dev,
 
 	bits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |
 	       EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;
-	/*  Use pio transfer and interrupt on end of conversion
-	 *  if CMDF_WAKE_EOS flag is set. */
+	/*
+	 * Use pio transfer and interrupt on end of conversion
+	 * if CMDF_WAKE_EOS flag is set.
+	 */
 	if (cmd->flags & CMDF_WAKE_EOS) {
 		/*  4020 doesn't support pio transfers except for fifo dregs */
 		if (thisboard->layout != LAYOUT_4020)
@@ -1425,8 +1432,10 @@ static void init_stc_registers(struct comedi_device *dev)
 
 	spin_lock_irqsave(&dev->spinlock, flags);
 
-	/*  bit should be set for 6025,
-	 *  although docs say boards with <= 16 chans should be cleared XXX */
+	/*
+	 * bit should be set for 6025,
+	 * although docs say boards with <= 16 chans should be cleared XXX
+	 */
 	if (1)
 		devpriv->adc_control1_bits |= ADC_QUEUE_CONFIG_BIT;
 	writew(devpriv->adc_control1_bits,
@@ -1689,8 +1698,10 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 	uint8_t bitstream;
 	static const int read_bit = 0x1;
 
-	/* XXX need mutex to prevent simultaneous attempts to access
-	 * eeprom and i2c bus */
+	/*
+	 * XXX need mutex to prevent simultaneous attempts to access
+	 * eeprom and i2c bus
+	 */
 
 	/*  make sure we dont send anything to eeprom */
 	devpriv->plx_control_bits &= ~CTL_EE_CS;
@@ -1782,14 +1793,18 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 				cal_en_bit = CAL_EN_60XX_BIT;
 			else
 				cal_en_bit = CAL_EN_64XX_BIT;
-			/*  select internal reference source to connect
-			 *  to channel 0 */
+			/*
+			 * select internal reference source to connect
+			 * to channel 0
+			 */
 			writew(cal_en_bit |
 			       adc_src_bits(devpriv->calibration_source),
 			       devpriv->main_iobase + CALIBRATION_REG);
 		} else {
-			/*  make sure internal calibration source
-			 *  is turned off */
+			/*
+			 * make sure internal calibration source
+			 * is turned off
+			 */
 			writew(0, devpriv->main_iobase + CALIBRATION_REG);
 		}
 		/*  load internal queue */
@@ -1821,8 +1836,10 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			devpriv->i2c_cal_range_bits |= attenuate_bit(channel);
 		else
 			devpriv->i2c_cal_range_bits &= ~attenuate_bit(channel);
-		/*  update calibration/range i2c register only if necessary,
-		 *  as it is very slow */
+		/*
+		 * update calibration/range i2c register only if necessary,
+		 * as it is very slow
+		 */
 		if (old_cal_range_bits != devpriv->i2c_cal_range_bits) {
 			uint8_t i2c_data = devpriv->i2c_cal_range_bits;
 
@@ -1830,10 +1847,12 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 				  sizeof(i2c_data));
 		}
 
-		/* 4020 manual asks that sample interval register to be set
+		/*
+		 * 4020 manual asks that sample interval register to be set
 		 * before writing to convert register.
 		 * Using somewhat arbitrary setting of 4 master clock ticks
-		 * = 0.1 usec */
+		 * = 0.1 usec
+		 */
 		writew(0, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
 		writew(2, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
 	}
@@ -1968,9 +1987,11 @@ static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return -EINVAL;
 }
 
-/* Gets nearest achievable timing given master clock speed, does not
+/*
+ * Gets nearest achievable timing given master clock speed, does not
  * take into account possible minimum/maximum divisor values.  Used
- * by other timing checking functions. */
+ * by other timing checking functions.
+ */
 static unsigned int get_divisor(unsigned int ns, unsigned int flags)
 {
 	unsigned int divisor;
@@ -1990,7 +2011,8 @@ static unsigned int get_divisor(unsigned int ns, unsigned int flags)
 	return divisor;
 }
 
-/* utility function that rounds desired timing to an achievable time, and
+/*
+ * utility function that rounds desired timing to an achievable time, and
  * sets cmd members appropriately.
  * adc paces conversions from master clock by dividing by (x + 3) where x is
  * 24 bit number
@@ -2474,8 +2496,10 @@ static int setup_channel_queue(struct comedi_device *dev,
 				       devpriv->main_iobase +
 				       ADC_QUEUE_FIFO_REG);
 			}
-			/* doing a queue clear is not specified in board docs,
-			 * but required for reliable operation */
+			/*
+			 * doing a queue clear is not specified in board docs,
+			 * but required for reliable operation
+			 */
 			writew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);
 			/*  prime queue holding register */
 			writew(0, devpriv->main_iobase + ADC_QUEUE_LOAD_REG);
@@ -2498,8 +2522,10 @@ static int setup_channel_queue(struct comedi_device *dev,
 				devpriv->i2c_cal_range_bits &=
 					~attenuate_bit(channel);
 		}
-		/*  update calibration/range i2c register only if necessary,
-		 *  as it is very slow */
+		/*
+		 * update calibration/range i2c register only if necessary,
+		 * as it is very slow
+		 */
 		if (old_cal_range_bits != devpriv->i2c_cal_range_bits) {
 			uint8_t i2c_data = devpriv->i2c_cal_range_bits;
 
@@ -2516,11 +2542,13 @@ static inline void load_first_dma_descriptor(struct comedi_device *dev,
 {
 	struct pcidas64_private *devpriv = dev->private;
 
-	/* The transfer size, pci address, and local address registers
+	/*
+	 * The transfer size, pci address, and local address registers
 	 * are supposedly unused during chained dma,
 	 * but I have found that left over values from last operation
 	 * occasionally cause problems with transfer of first dma
-	 * block.  Initializing them to zero seems to fix the problem. */
+	 * block.  Initializing them to zero seems to fix the problem.
+	 */
 	if (dma_channel) {
 		writel(0,
 		       devpriv->plx9080_iobase + PLX_DMA1_TRANSFER_SIZE_REG);
@@ -2675,15 +2703,19 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 			     0x7fff;
 		write_index = readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) &
 			      0x7fff;
-		/* Get most significant bits (grey code).
+		/*
+		 * Get most significant bits (grey code).
 		 * Different boards use different code so use a scheme
 		 * that doesn't depend on encoding.  This read must
 		 * occur after reading least significant 15 bits to avoid race
-		 * with fifo switching to next segment. */
+		 * with fifo switching to next segment.
+		 */
 		prepost_bits = readw(devpriv->main_iobase + PREPOST_REG);
 
-		/* if read and write pointers are not on the same fifo segment,
-		 * read to the end of the read segment */
+		/*
+		 * if read and write pointers are not on the same fifo segment,
+		 * read to the end of the read segment
+		 */
 		read_segment = adc_upper_read_ptr_code(prepost_bits);
 		write_segment = adc_upper_write_ptr_code(prepost_bits);
 
@@ -2712,7 +2744,8 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 	} while (read_segment != write_segment);
 }
 
-/* Read from 32 bit wide ai fifo of 4020 - deal with insane grey coding of
+/*
+ * Read from 32 bit wide ai fifo of 4020 - deal with insane grey coding of
  * pointers.  The pci-4020 hardware only supports dma transfers (it only
  * supports the use of pio for draining the last remaining points from the
  * fifo when a data acquisition operation has completed).
@@ -2790,8 +2823,10 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 		devpriv->ai_dma_index = (devpriv->ai_dma_index + 1) %
 					ai_dma_ring_count(thisboard);
 	}
-	/* XXX check for dma ring buffer overrun
-	 * (use end-of-chain bit to mark last unused buffer) */
+	/*
+	 * XXX check for dma ring buffer overrun
+	 * (use end-of-chain bit to mark last unused buffer)
+	 */
 }
 
 static void handle_ai_interrupt(struct comedi_device *dev,
@@ -2939,8 +2974,10 @@ static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 	next_bits = le32_to_cpu(devpriv->ao_dma_desc[buffer_index].next);
 	next_bits |= PLX_END_OF_CHAIN_BIT;
 	devpriv->ao_dma_desc[buffer_index].next = cpu_to_le32(next_bits);
-	/* clear end of chain bit on previous buffer now that we have set it
-	 * for the last buffer */
+	/*
+	 * clear end of chain bit on previous buffer now that we have set it
+	 * for the last buffer
+	 */
 	next_bits = le32_to_cpu(devpriv->ao_dma_desc[prev_buffer_index].next);
 	next_bits &= ~PLX_END_OF_CHAIN_BIT;
 	devpriv->ao_dma_desc[prev_buffer_index].next = cpu_to_le32(next_bits);
@@ -3033,9 +3070,11 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	plx_status = readl(devpriv->plx9080_iobase + PLX_INTRCS_REG);
 	status = readw(devpriv->main_iobase + HW_STATUS_REG);
 
-	/* an interrupt before all the postconfig stuff gets done could
+	/*
+	 * an interrupt before all the postconfig stuff gets done could
 	 * cause a NULL dereference if we continue through the
-	 * interrupt handler */
+	 * interrupt handler
+	 */
 	if (!dev->attached)
 		return IRQ_HANDLED;
 
@@ -3195,8 +3234,10 @@ static int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	unsigned int nbytes;
 	int i;
 
-	/* clear queue pointer too, since external queue has
-	 * weird interactions with ao fifo */
+	/*
+	 * clear queue pointer too, since external queue has
+	 * weird interactions with ao fifo
+	 */
 	writew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);
 	writew(0, devpriv->main_iobase + DAC_BUFFER_CLEAR_REG);
 
@@ -3465,7 +3506,8 @@ static int dio_60xx_wbits(struct comedi_device *dev,
 	return insn->n;
 }
 
-/* pci-6025 8800 caldac:
+/*
+ * pci-6025 8800 caldac:
  * address 0 == dac channel 0 offset
  * address 1 == dac channel 0 gain
  * address 2 == dac channel 1 offset
@@ -3475,7 +3517,8 @@ static int dio_60xx_wbits(struct comedi_device *dev,
  * address 6 == coarse adc gain
  * address 7 == fine adc gain
  */
-/* pci-6402/16 uses all 8 channels for dac:
+/*
+ * pci-6402/16 uses all 8 channels for dac:
  * address 0 == dac channel 0 fine gain
  * address 1 == dac channel 0 coarse gain
  * address 2 == dac channel 0 coarse offset
@@ -3484,7 +3527,7 @@ static int dio_60xx_wbits(struct comedi_device *dev,
  * address 5 == dac channel 1 coarse gain
  * address 6 == dac channel 0 fine offset
  * address 7 == dac channel 1 fine offset
-*/
+ */
 
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 			     uint8_t value)
@@ -3744,7 +3787,8 @@ static int eeprom_read_insn(struct comedi_device *dev,
 	return 1;
 }
 
-/* Allocate and initialize the subdevice structures.
+/*
+ * Allocate and initialize the subdevice structures.
  */
 static int setup_subdevices(struct comedi_device *dev)
 {
@@ -3779,8 +3823,10 @@ static int setup_subdevices(struct comedi_device *dev)
 	s->cancel = ai_cancel;
 	if (thisboard->layout == LAYOUT_4020) {
 		uint8_t data;
-		/*  set adc to read from inputs
-		 *  (not internal calibration sources) */
+		/*
+		 * set adc to read from inputs
+		 * (not internal calibration sources)
+		 */
 		devpriv->i2c_cal_range_bits = adc_src_4020_bits(4);
 		/*  set channels to +-5 volt input ranges */
 		for (i = 0; i < s->n_chan; i++)

commit f51ff7e40645891b211ed349d142e5c028a1c5e5
Author: Amaury Denoyelle <amaury.denoyelle@gmail.com>
Date:   Tue May 19 19:57:49 2015 +0200

    Staging: comedi: fix line longer than 80 chars in cb_pcidas64.c
    
    This patch fixes coding style errors reported by checkpatch.pl for
    cb_pcidas64.c, about too long source code lines.
    
    Signed-off-by: Amaury Denoyelle <amaury.denoyelle@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index a94c33c3d962..f1bba2b6c935 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -243,7 +243,8 @@ enum adc_control0_contents {
 	ADC_SOFT_GATE_BITS = 0x1,	/*  software gate */
 	ADC_EXT_GATE_BITS = 0x2,	/*  external digital gate */
 	ADC_ANALOG_GATE_BITS = 0x3,	/*  analog level gate */
-	ADC_GATE_LEVEL_BIT = 0x4,	/*  level-sensitive gate (for digital) */
+	/*  level-sensitive gate (for digital) */
+	ADC_GATE_LEVEL_BIT = 0x4,
 	ADC_GATE_POLARITY_BIT = 0x8,	/*  gate active low */
 	ADC_START_TRIG_SOFT_BITS = 0x10,
 	ADC_START_TRIG_EXT_BITS = 0x20,
@@ -1381,7 +1382,9 @@ static int set_ai_fifo_segment_length(struct comedi_device *dev,
 	return devpriv->ai_fifo_segment_length;
 }
 
-/* adjusts the size of hardware fifo (which determines block size for dma xfers) */
+/*
+ * adjusts the size of hardware fifo (which determines block size for dma xfers)
+ */
 static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 {
 	const struct pcidas64_board *thisboard = dev->board_ptr;
@@ -1588,7 +1591,9 @@ static inline void warn_external_queue(struct comedi_device *dev)
 		"Use internal AI channel queue (channels must be consecutive and use same range/aref)\n");
 }
 
-/* Their i2c requires a huge delay on setting clock or data high for some reason */
+/*
+ * their i2c requires a huge delay on setting clock or data high for some reason
+ */
 static const int i2c_high_udelay = 1000;
 static const int i2c_low_udelay = 10;
 
@@ -1987,7 +1992,8 @@ static unsigned int get_divisor(unsigned int ns, unsigned int flags)
 
 /* utility function that rounds desired timing to an achievable time, and
  * sets cmd members appropriately.
- * adc paces conversions from master clock by dividing by (x + 3) where x is 24 bit number
+ * adc paces conversions from master clock by dividing by (x + 3) where x is
+ * 24 bit number
  */
 static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {

commit 571cea09014711d801f8a6a81a8cb18aa78eba14
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:04 2015 +0000

    staging: comedi: cb_pcidas64: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 15106d0a38b2..a94c33c3d962 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -88,7 +88,6 @@
 
 #include "8255.h"
 #include "plx9080.h"
-#include "comedi_fc.h"
 
 #define TIMER_BASE 25		/*  40MHz master clock */
 /* 100kHz 'prescaled' clock for slow acquisition,
@@ -2086,34 +2085,34 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
 
 	triggers = TRIG_TIMER;
 	if (thisboard->layout == LAYOUT_4020)
 		triggers |= TRIG_OTHER;
 	else
 		triggers |= TRIG_FOLLOW;
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, triggers);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, triggers);
 
 	triggers = TRIG_TIMER;
 	if (thisboard->layout == LAYOUT_4020)
 		triggers |= TRIG_NOW;
 	else
 		triggers |= TRIG_EXT;
-	err |= cfc_check_trigger_src(&cmd->convert_src, triggers);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src,
-				     TRIG_COUNT | TRIG_EXT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->convert_src, triggers);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src,
+					TRIG_COUNT | TRIG_EXT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -2127,7 +2126,7 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	switch (cmd->start_src) {
 	case TRIG_NOW:
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 		break;
 	case TRIG_EXT:
 		/*
@@ -2139,30 +2138,37 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		if (thisboard->layout == LAYOUT_4020) {
-			err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+			err |= comedi_check_trigger_arg_is(&cmd->convert_arg,
+							   0);
 		} else {
-			err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-							 thisboard->ai_speed);
-			/* if scans are timed faster than conversion rate allows */
-			if (cmd->scan_begin_src == TRIG_TIMER)
-				err |= cfc_check_trigger_arg_min(
+			err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
+							    thisboard->
+							    ai_speed);
+			/*
+			 * if scans are timed faster than conversion rate
+			 * allows
+			 */
+			if (cmd->scan_begin_src == TRIG_TIMER) {
+				err |= comedi_check_trigger_arg_min(
 						&cmd->scan_begin_arg,
 						cmd->convert_arg *
 						cmd->chanlist_len);
+			}
 		}
 	}
 
-	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	switch (cmd->stop_src) {
 	case TRIG_EXT:
 		break;
 	case TRIG_COUNT:
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 		break;
 	case TRIG_NONE:
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 		break;
 	default:
 		break;
@@ -3306,20 +3312,20 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
-				     TRIG_TIMER | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_TIMER | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -3334,11 +3340,11 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 thisboard->ao_scan_speed);
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    thisboard->ao_scan_speed);
 		if (get_ao_divisor(cmd->scan_begin_arg, cmd->flags) >
 		    max_counter_value) {
 			cmd->scan_begin_arg = (max_counter_value + 2) *
@@ -3347,8 +3353,9 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		}
 	}
 
-	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (err)
 		return 3;

commit 326406806cd0f69cccf3a526b6297ab4b9f97e38
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 10 16:10:47 2015 +0000

    staging: comedi: cb_pcidas64: include new "comedi_pci.h" header
    
    Include the new "../comedi_pci.h" header instead of <linux/pci.h> and
    "../comedidev.h", which will now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 2b7c50aa1e39..15106d0a38b2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -81,11 +81,10 @@
 */
 
 #include <linux/module.h>
-#include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 
-#include "../comedidev.h"
+#include "../comedi_pci.h"
 
 #include "8255.h"
 #include "plx9080.h"

commit 6ac986d098ee81b75973a0c2f46a9a4edef2a8c6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:18 2015 -0700

    staging: comedi: drivers/*.c: add missing braces {} to if/else branches
    
    According to the CodingStyle, braces should  be used on all branches
    if thet are used on any branch,
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 5033c7cddda2..2b7c50aa1e39 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2630,8 +2630,9 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		bits |= ADC_START_TRIG_EXT_BITS;
 		if (cmd->start_arg & CR_INVERT)
 			bits |= ADC_START_TRIG_FALLING_BIT;
-	} else if (cmd->start_src == TRIG_NOW)
+	} else if (cmd->start_src == TRIG_NOW) {
 		bits |= ADC_START_TRIG_SOFT_BITS;
+	}
 	if (use_hw_sample_counter(cmd))
 		bits |= ADC_SAMPLE_COUNTER_EN_BIT;
 	writew(bits, devpriv->main_iobase + ADC_CONTROL0_REG);
@@ -2820,8 +2821,9 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 		if (devpriv->ai_cmd_running) {
 			spin_unlock_irqrestore(&dev->spinlock, flags);
 			pio_drain_ai_fifo(dev);
-		} else
+		} else {
 			spin_unlock_irqrestore(&dev->spinlock, flags);
+		}
 	}
 	/*  if we are have all the data, then quit */
 	if ((cmd->stop_src == TRIG_COUNT &&
@@ -3810,8 +3812,9 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->maxdata = 1;
 		s->range_table = &range_digital;
 		s->insn_bits = di_rbits;
-	} else
+	} else {
 		s->type = COMEDI_SUBD_UNUSED;
+	}
 
 	/*  digital output */
 	if (thisboard->layout == LAYOUT_64XX) {
@@ -3822,8 +3825,9 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->maxdata = 1;
 		s->range_table = &range_digital;
 		s->insn_bits = do_wbits;
-	} else
+	} else {
 		s->type = COMEDI_SUBD_UNUSED;
+	}
 
 	/* 8255 */
 	s = &dev->subdevices[4];
@@ -3851,8 +3855,9 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->range_table = &range_digital;
 		s->insn_config = dio_60xx_config_insn;
 		s->insn_bits = dio_60xx_wbits;
-	} else
+	} else {
 		s->type = COMEDI_SUBD_UNUSED;
+	}
 
 	/*  caldac */
 	s = &dev->subdevices[6];
@@ -3891,8 +3896,9 @@ static int setup_subdevices(struct comedi_device *dev)
 			ad8402_write(dev, i, s->maxdata / 2);
 			s->readback[i] = s->maxdata / 2;
 		}
-	} else
+	} else {
 		s->type = COMEDI_SUBD_UNUSED;
+	}
 
 	/* serial EEPROM, if present */
 	s = &dev->subdevices[8];
@@ -3902,8 +3908,9 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->n_chan = 128;
 		s->maxdata = 0xffff;
 		s->insn_read = eeprom_read_insn;
-	} else
+	} else {
 		s->type = COMEDI_SUBD_UNUSED;
+	}
 
 	/*  user counter subd XXX */
 	s = &dev->subdevices[9];

commit c8f4b98f47e498a823d1b82b8f3848d81183ea22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:17 2015 -0700

    staging: comedi: drivers/*.c: remove unnecessary blank lines
    
    Blank lines are not needed before a close brace '}' or after an
    open brace '{'. Also remove any multiple blank lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index c8f4a227cc59..5033c7cddda2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1475,7 +1475,6 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 					     &devpriv->ai_buffer_bus_addr[i]);
 		if (!devpriv->ai_buffer[i])
 			return -ENOMEM;
-
 	}
 	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 		if (ao_cmd_is_supported(thisboard)) {
@@ -1485,7 +1484,6 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 						      ao_buffer_bus_addr[i]);
 			if (!devpriv->ao_buffer[i])
 				return -ENOMEM;
-
 		}
 	}
 	/*  allocate dma descriptors */
@@ -1838,7 +1836,6 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	}
 
 	for (n = 0; n < insn->n; n++) {
-
 		/*  clear adc buffer (inside loop for 4020 sake) */
 		writew(0, devpriv->main_iobase + ADC_BUFFER_CLEAR_REG);
 
@@ -1900,7 +1897,6 @@ static int ai_config_block_size(struct comedi_device *dev, unsigned int *data)
 		retval = set_ai_fifo_size(dev, fifo_size);
 		if (retval < 0)
 			return retval;
-
 	}
 
 	block_size = ai_fifo_size(dev) / fifo->num_segments * bytes_in_sample;

commit 854472c27046646f3f258970a9fee9ab1e5d7593
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 4 12:15:32 2015 -0700

    staging: comedi: cb_pcidas64: (!foo) preferred over (foo == NULL)
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index bd2405999906..c8f4a227cc59 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1473,7 +1473,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 		devpriv->ai_buffer[i] =
 			pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
 					     &devpriv->ai_buffer_bus_addr[i]);
-		if (devpriv->ai_buffer[i] == NULL)
+		if (!devpriv->ai_buffer[i])
 			return -ENOMEM;
 
 	}
@@ -1483,7 +1483,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 				pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
 						     &devpriv->
 						      ao_buffer_bus_addr[i]);
-			if (devpriv->ao_buffer[i] == NULL)
+			if (!devpriv->ao_buffer[i])
 				return -ENOMEM;
 
 		}
@@ -1493,7 +1493,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 		pci_alloc_consistent(pcidev, sizeof(struct plx_dma_desc) *
 				     ai_dma_ring_count(thisboard),
 				     &devpriv->ai_dma_desc_bus_addr);
-	if (devpriv->ai_dma_desc == NULL)
+	if (!devpriv->ai_dma_desc)
 		return -ENOMEM;
 
 	if (ao_cmd_is_supported(thisboard)) {
@@ -1502,7 +1502,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 					     sizeof(struct plx_dma_desc) *
 					     AO_DMA_RING_COUNT,
 					     &devpriv->ao_dma_desc_bus_addr);
-		if (devpriv->ao_dma_desc == NULL)
+		if (!devpriv->ao_dma_desc)
 			return -ENOMEM;
 	}
 	/*  initialize dma descriptors */
@@ -2975,7 +2975,7 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 	unsigned long flags;
 
 	/* board might not support ao, in which case write_subdev is NULL */
-	if (s == NULL)
+	if (!s)
 		return;
 	async = s->async;
 	cmd = &async->cmd;

commit cd25503f5a6f0b0d6d66185461a358e8218db745
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Thu Mar 5 13:01:49 2015 +0300

    Staging: comedi: Clean dev_err() logging
    
    This patch removes  __func__ from dev_err. dev_err includes information about:
     (devcice, driver, specific instance of device, etc) in the log printout, so there is no need for  __func__.
    This was done using Coccinelle, with the following semantic patch:
    
    @a@
    expression E;
    expression  msg;
    @@
    
    dev_err(E, msg, __func__);
    
    @script:python b@
    e << a.msg;
    y;
    @@
    
    if(e.find("%s: ") == True):
            m = e.replace("%s: ", "");
            coccinelle.y = m;
    elif(e.find("%s ") == True):
            m = e.replace("%s ", "");
            coccinelle.y = m;
    else:
            m = e.replace("%s", "");
    
    @c@
    expression a.E, a.msg;
    identifier  b.y;
    @@
    
    - dev_err(E, msg, __func__);
    + dev_err(E, y);
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 551e9d92e918..bd2405999906 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1703,8 +1703,7 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 
 	/*  get acknowledge */
 	if (i2c_read_ack(dev) != 0) {
-		dev_err(dev->class_dev, "%s failed: no acknowledge\n",
-			__func__);
+		dev_err(dev->class_dev, "failed: no acknowledge\n");
 		i2c_stop(dev);
 		return;
 	}
@@ -1712,8 +1711,7 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 	for (i = 0; i < length; i++) {
 		i2c_write_byte(dev, data[i]);
 		if (i2c_read_ack(dev) != 0) {
-			dev_err(dev->class_dev, "%s failed: no acknowledge\n",
-				__func__);
+			dev_err(dev->class_dev, "failed: no acknowledge\n");
 			i2c_stop(dev);
 			return;
 		}

commit bf9e4d5c1a9e931a86c3086d41e63b8873efaf37
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 14:57:51 2015 -0700

    staging: comedi: cb_pcidas64: remove unnecessary include
    
    The hardware supported by this driver does not have an 8254 timer. Remove the
    unnecessary include of "8253.h".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 9836c877c910..551e9d92e918 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -87,7 +87,6 @@
 
 #include "../comedidev.h"
 
-#include "8253.h"
 #include "8255.h"
 #include "plx9080.h"
 #include "comedi_fc.h"

commit 1f5fc964866dabec6db6e7eaf8865838b1436a8e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Feb 20 12:52:27 2015 -0700

    staging: comedi: cb_pcidas64: fix possible integer overflow
    
    The {min,max}_scan_divisor values could overflow due to the
    unsigned int * insigned int calculation. Change the type of the
    local variable 'convert_divisor' to unsigned long long to avoid
    the possible overflow.
    
    Reported-by: coverity (CID 200653)
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 5b43e4e6d037..9836c877c910 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2001,7 +2001,8 @@ static unsigned int get_divisor(unsigned int ns, unsigned int flags)
 static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
 	const struct pcidas64_board *thisboard = dev->board_ptr;
-	unsigned int convert_divisor = 0, scan_divisor;
+	unsigned long long convert_divisor = 0;
+	unsigned int scan_divisor;
 	static const int min_convert_divisor = 3;
 	static const int max_convert_divisor =
 		max_counter_value + min_convert_divisor;
@@ -2027,7 +2028,6 @@ static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		scan_divisor = get_divisor(cmd->scan_begin_arg, cmd->flags);
 		if (cmd->convert_src == TRIG_TIMER) {
-			/*  XXX check for integer overflows */
 			min_scan_divisor = convert_divisor * cmd->chanlist_len;
 			max_scan_divisor =
 				(convert_divisor * cmd->chanlist_len - 1) +

commit 3e6cb74f5632e1ac2b4209b4d2c64fca43e2838b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:02 2015 -0700

    staging: comedi: drivers: remove inappropriate COMEDI_CB_EOA events
    
    Hardware errors should be reported with the COMEDI_CB_ERROR event. This event
    will cause the async command to cancel. It's not necessary to also set the
    COMEDI_CB_EOA event. Remove these events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 569310a9135b..5b43e4e6d037 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2804,7 +2804,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 	/*  check for fifo overrun */
 	if (status & ADC_OVERRUN_BIT) {
 		dev_err(dev->class_dev, "fifo overrun\n");
-		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		async->events |= COMEDI_CB_ERROR;
 	}
 	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);

commit be8e89087ec2d2c8a1ad1e3db64bf4efdfc3c298
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 19 14:47:27 2015 +0000

    staging: comedi: cb_pcidas64: fix incorrect AI range code handling
    
    The hardware range code values and list of valid ranges for the AI
    subdevice is incorrect for several supported boards.  The hardware range
    code values for all boards except PCI-DAS4020/12 is determined by
    calling `ai_range_bits_6xxx()` based on the maximum voltage of the range
    and whether it is bipolar or unipolar, however it only returns the
    correct hardware range code for the PCI-DAS60xx boards.  For
    PCI-DAS6402/16 (and /12) it returns the wrong code for the unipolar
    ranges.  For PCI-DAS64/Mx/16 it returns the wrong code for all the
    ranges and the comedi range table is incorrect.
    
    Change `ai_range_bits_6xxx()` to use a look-up table pointed to by new
    member `ai_range_codes` of `struct pcidas64_board` to map the comedi
    range table indices to the hardware range codes.  Use a new comedi range
    table for the PCI-DAS64/Mx/16 boards (and the commented out variants).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: <stable@vger.kernel.org> # 3.18.x
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index eddb7ace43df..569310a9135b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -439,6 +439,29 @@ static const struct comedi_lrange ai_ranges_64xx = {
 	}
 };
 
+static const uint8_t ai_range_code_64xx[8] = {
+	0x0, 0x1, 0x2, 0x3,	/* bipolar 10, 5, 2,5, 1.25 */
+	0x8, 0x9, 0xa, 0xb	/* unipolar 10, 5, 2.5, 1.25 */
+};
+
+/* analog input ranges for 64-Mx boards */
+static const struct comedi_lrange ai_ranges_64_mx = {
+	7, {
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		BIP_RANGE(0.625),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25)
+	}
+};
+
+static const uint8_t ai_range_code_64_mx[7] = {
+	0x0, 0x1, 0x2, 0x3,	/* bipolar 5, 2.5, 1.25, 0.625 */
+	0x9, 0xa, 0xb		/* unipolar 5, 2.5, 1.25 */
+};
+
 /* analog input ranges for 60xx boards */
 static const struct comedi_lrange ai_ranges_60xx = {
 	4, {
@@ -449,6 +472,10 @@ static const struct comedi_lrange ai_ranges_60xx = {
 	}
 };
 
+static const uint8_t ai_range_code_60xx[4] = {
+	0x0, 0x1, 0x4, 0x7	/* bipolar 10, 5, 0.5, 0.05 */
+};
+
 /* analog input ranges for 6030, etc boards */
 static const struct comedi_lrange ai_ranges_6030 = {
 	14, {
@@ -469,6 +496,11 @@ static const struct comedi_lrange ai_ranges_6030 = {
 	}
 };
 
+static const uint8_t ai_range_code_6030[14] = {
+	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, /* bip 10, 5, 2, 1, 0.5, 0.2, 0.1 */
+	0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf  /* uni 10, 5, 2, 1, 0.5, 0.2, 0.1 */
+};
+
 /* analog input ranges for 6052, etc boards */
 static const struct comedi_lrange ai_ranges_6052 = {
 	15, {
@@ -490,6 +522,11 @@ static const struct comedi_lrange ai_ranges_6052 = {
 	}
 };
 
+static const uint8_t ai_range_code_6052[15] = {
+	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,	/* bipolar 10 ... 0.05 */
+	0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf	/* unipolar 10 ... 0.1 */
+};
+
 /* analog input ranges for 4020 board */
 static const struct comedi_lrange ai_ranges_4020 = {
 	2, {
@@ -593,6 +630,7 @@ struct pcidas64_board {
 	int ai_bits;		/*  analog input resolution */
 	int ai_speed;		/*  fastest conversion period in ns */
 	const struct comedi_lrange *ai_range_table;
+	const uint8_t *ai_range_code;
 	int ao_nchan;		/*  number of analog out channels */
 	int ao_bits;		/*  analog output resolution */
 	int ao_scan_speed;	/*  analog output scan speed */
@@ -651,6 +689,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
 		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_code	= ai_range_code_64xx,
 		.ao_range_table	= &ao_ranges_64xx,
 		.ao_range_code	= ao_range_code_64xx,
 		.ai_fifo	= &ai_fifo_64xx,
@@ -666,6 +705,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
 		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_code	= ai_range_code_64xx,
 		.ao_range_table	= &ao_ranges_64xx,
 		.ao_range_code	= ao_range_code_64xx,
 		.ai_fifo	= &ai_fifo_64xx,
@@ -680,7 +720,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_bits	= 16,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ao_range_table	= &ao_ranges_64xx,
 		.ao_range_code	= ao_range_code_64xx,
 		.ai_fifo	= &ai_fifo_64xx,
@@ -695,7 +736,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_bits	= 16,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ao_range_table	= &ao_ranges_64xx,
 		.ao_range_code	= ao_range_code_64xx,
 		.ai_fifo	= &ai_fifo_64xx,
@@ -710,7 +752,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_bits	= 16,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ao_range_table	= &ao_ranges_64xx,
 		.ao_range_code	= ao_range_code_64xx,
 		.ai_fifo	= &ai_fifo_64xx,
@@ -725,6 +768,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_bits	= 16,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -740,6 +784,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -754,6 +799,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -769,6 +815,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -784,6 +831,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6030,
+		.ai_range_code	= ai_range_code_6030,
 		.ao_range_table	= &ao_ranges_6030,
 		.ao_range_code	= ao_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -799,6 +847,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6030,
+		.ai_range_code	= ai_range_code_6030,
 		.ao_range_table	= &ao_ranges_6030,
 		.ao_range_code	= ao_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -812,6 +861,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 0,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6030,
+		.ai_range_code	= ai_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
 		.has_8255	= 0,
 	},
@@ -823,6 +873,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 0,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6030,
+		.ai_range_code	= ai_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
 		.has_8255	= 0,
 	},
@@ -835,6 +886,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 0,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
 		.has_8255	= 0,
 	},
@@ -848,6 +900,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -863,6 +916,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
+		.ai_range_code	= ai_range_code_60xx,
 		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -878,6 +932,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 1000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6052,
+		.ai_range_code	= ai_range_code_6052,
 		.ao_range_table	= &ao_ranges_6030,
 		.ao_range_code	= ao_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -893,6 +948,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 3333,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6052,
+		.ai_range_code	= ai_range_code_6052,
 		.ao_range_table	= &ao_ranges_6030,
 		.ao_range_code	= ao_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -908,6 +964,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 1000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6052,
+		.ai_range_code	= ai_range_code_6052,
 		.ao_range_table	= &ao_ranges_6030,
 		.ao_range_code	= ao_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -923,6 +980,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 1000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_6052,
+		.ai_range_code	= ai_range_code_6052,
 		.ao_range_table	= &ao_ranges_6030,
 		.ao_range_code	= ao_range_code_6030,
 		.ai_fifo	= &ai_fifo_60xx,
@@ -957,6 +1015,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
 		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_code	= ai_range_code_64xx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -968,7 +1027,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 0,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -980,7 +1040,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 0,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -992,7 +1053,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 0,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -1004,7 +1066,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 2,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -1016,7 +1079,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 2,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -1028,7 +1092,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_nchan	= 2,
 		.ao_scan_speed	= 10000,
 		.layout		= LAYOUT_64XX,
-		.ai_range_table	= &ai_ranges_64xx,
+		.ai_range_table	= &ai_ranges_64_mx,
+		.ai_range_code	= ai_range_code_64_mx,
 		.ai_fifo	= ai_fifo_64xx,
 		.has_8255	= 1,
 	},
@@ -1115,45 +1180,8 @@ static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 				       unsigned int range_index)
 {
 	const struct pcidas64_board *thisboard = dev->board_ptr;
-	const struct comedi_krange *range =
-		&thisboard->ai_range_table->range[range_index];
-	unsigned int bits = 0;
 
-	switch (range->max) {
-	case 10000000:
-		bits = 0x000;
-		break;
-	case 5000000:
-		bits = 0x100;
-		break;
-	case 2000000:
-	case 2500000:
-		bits = 0x200;
-		break;
-	case 1000000:
-	case 1250000:
-		bits = 0x300;
-		break;
-	case 500000:
-		bits = 0x400;
-		break;
-	case 200000:
-	case 250000:
-		bits = 0x500;
-		break;
-	case 100000:
-		bits = 0x600;
-		break;
-	case 50000:
-		bits = 0x700;
-		break;
-	default:
-		dev_err(dev->class_dev, "bug! in %s\n", __func__);
-		break;
-	}
-	if (range->min == 0)
-		bits += 0x900;
-	return bits;
+	return thisboard->ai_range_code[range_index] << 8;
 }
 
 static unsigned int hw_revision(const struct comedi_device *dev,

commit dc658fdc8a807c5b5a405277685f35e53673729c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Nov 20 15:07:22 2014 -0700

    staging: comedi: cb_pcidas64: fix ad8402_write_insn()
    
    The comedi core expects the (*insn_write) functions to write 'insn->n'
    values to the hardware and return the number of values written. Currently
    this function only writes the first value. For this subdevice it only makes
    sense to write the final data value.
    
    Fix the function to work like the core expects. For aesthetics, rename the
    function so it has namespace associated with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index d80f34d35ee3..eddb7ace43df 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3614,22 +3614,27 @@ static void ad8402_write(struct comedi_device *dev, unsigned int channel,
 }
 
 /* for pci-das6402/16, channel 0 is analog input gain and channel 1 is offset */
-static int ad8402_write_insn(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas64_ad8402_insn_write(struct comedi_device *dev,
+					 struct comedi_subdevice *s,
+					 struct comedi_insn *insn,
+					 unsigned int *data)
 {
-	int channel = CR_CHAN(insn->chanspec);
-
-	/* return immediately if setting hasn't changed, since
-	 * programming these things is slow */
-	if (s->readback[channel] == data[0])
-		return 1;
+	unsigned int chan = CR_CHAN(insn->chanspec);
 
-	s->readback[channel] = data[0];
+	/*
+	 * Programming the calib device is slow. Only write the
+	 * last data value if the value has changed.
+	 */
+	if (insn->n) {
+		unsigned int val = data[insn->n - 1];
 
-	ad8402_write(dev, channel, data[0]);
+		if (s->readback[chan] != val) {
+			ad8402_write(dev, chan, val);
+			s->readback[chan] = val;
+		}
+	}
 
-	return 1;
+	return insn->n;
 }
 
 static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
@@ -3855,7 +3860,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 		s->n_chan = 2;
 		s->maxdata = 0xff;
-		s->insn_write = ad8402_write_insn;
+		s->insn_write = cb_pcidas64_ad8402_insn_write;
 
 		ret = comedi_alloc_subdev_readback(s);
 		if (ret)

commit fe1184e49a8a4d9a32eef0d5e166dd9eec76b565
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Nov 20 15:07:21 2014 -0700

    staging: comedi: cb_pcidas64: use subdevice readback for 'ad8402_state'
    
    Use the comedi_subdevice 'readback' member and the core provided (*insn_read)
    to handle the readback of the write-only calibration subdevice. Remove the
    then unused 'ad8402_state' member from the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 17c98a59b44f..d80f34d35ee3 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1105,8 +1105,6 @@ struct pcidas64_private {
 	uint8_t i2c_cal_range_bits;
 	/*  configure digital triggers to trigger on falling edge */
 	unsigned int ext_trig_falling;
-	/*  states of various devices stored to enable read-back */
-	unsigned int ad8402_state[2];
 	short ai_cmd_running;
 	unsigned int ai_fifo_segment_length;
 	struct ext_clock_info ext_clock;
@@ -3595,8 +3593,6 @@ static void ad8402_write(struct comedi_device *dev, unsigned int channel,
 	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
 	static const int ad8402_udelay = 1;
 
-	devpriv->ad8402_state[channel] = value;
-
 	register_bits = SELECT_8402_64XX_BIT;
 	udelay(ad8402_udelay);
 	writew(register_bits, devpriv->main_iobase + CALIBRATION_REG);
@@ -3622,33 +3618,20 @@ static int ad8402_write_insn(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct pcidas64_private *devpriv = dev->private;
 	int channel = CR_CHAN(insn->chanspec);
 
 	/* return immediately if setting hasn't changed, since
 	 * programming these things is slow */
-	if (devpriv->ad8402_state[channel] == data[0])
+	if (s->readback[channel] == data[0])
 		return 1;
 
-	devpriv->ad8402_state[channel] = data[0];
+	s->readback[channel] = data[0];
 
 	ad8402_write(dev, channel, data[0]);
 
 	return 1;
 }
 
-static int ad8402_read_insn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
-{
-	struct pcidas64_private *devpriv = dev->private;
-	unsigned int channel = CR_CHAN(insn->chanspec);
-
-	data[0] = devpriv->ad8402_state[channel];
-
-	return 1;
-}
-
 static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 {
 	struct pcidas64_private *devpriv = dev->private;
@@ -3871,11 +3854,17 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->type = COMEDI_SUBD_CALIB;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 		s->n_chan = 2;
-		s->insn_read = ad8402_read_insn;
-		s->insn_write = ad8402_write_insn;
 		s->maxdata = 0xff;
-		for (i = 0; i < s->n_chan; i++)
+		s->insn_write = ad8402_write_insn;
+
+		ret = comedi_alloc_subdev_readback(s);
+		if (ret)
+			return ret;
+
+		for (i = 0; i < s->n_chan; i++) {
 			ad8402_write(dev, i, s->maxdata / 2);
+			s->readback[i] = s->maxdata / 2;
+		}
 	} else
 		s->type = COMEDI_SUBD_UNUSED;
 

commit 5e2de5e7f9f31db55399e2b4ad3b612dadaf7ebe
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Nov 20 15:07:20 2014 -0700

    staging: comedi: cb_pcidas64: fix calib_write_insn()
    
    The comedi core expects the (*insn_write) functions to write 'insn->n'
    values to the hardware and return the number of values written. Currently
    this function only writes the first value. For this subdevice it only makes
    sense to write the final data value.
    
    Fix the function to work like the core expects. For aesthetics, rename the
    function so it has namespace associated with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index c641778f3464..17c98a59b44f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3563,21 +3563,27 @@ static void caldac_write(struct comedi_device *dev, unsigned int channel,
 	}
 }
 
-static int calib_write_insn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas64_calib_insn_write(struct comedi_device *dev,
+					struct comedi_subdevice *s,
+					struct comedi_insn *insn,
+					unsigned int *data)
 {
-	int channel = CR_CHAN(insn->chanspec);
+	unsigned int chan = CR_CHAN(insn->chanspec);
 
-	/* return immediately if setting hasn't changed, since
-	 * programming these things is slow */
-	if (s->readback[channel] == data[0])
-		return 1;
+	/*
+	 * Programming the calib device is slow. Only write the
+	 * last data value if the value has changed.
+	 */
+	if (insn->n) {
+		unsigned int val = data[insn->n - 1];
 
-	caldac_write(dev, channel, data[0]);
-	s->readback[channel] = data[0];
+		if (s->readback[chan] != val) {
+			caldac_write(dev, chan, val);
+			s->readback[chan] = val;
+		}
+	}
 
-	return 1;
+	return insn->n;
 }
 
 static void ad8402_write(struct comedi_device *dev, unsigned int channel,
@@ -3848,7 +3854,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->maxdata = 0xfff;
 	else
 		s->maxdata = 0xff;
-	s->insn_write = calib_write_insn;
+	s->insn_write = cb_pcidas64_calib_insn_write;
 
 	ret = comedi_alloc_subdev_readback(s);
 	if (ret)

commit 37318bdb14aba8145644c7ca4b76b1ba3efbdcae
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Nov 20 15:07:19 2014 -0700

    staging: comedi: cb_pcidas64: use subdevice readback for 'caldac_state'
    
    Use the comedi_subdevice 'readback' member and the core provided (*insn_read)
    to handle the readback of the write-only calibration subdevice. Remove the
    then unused 'caldac_state' member from the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 4762e6a5f1b9..c641778f3464 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1107,7 +1107,6 @@ struct pcidas64_private {
 	unsigned int ext_trig_falling;
 	/*  states of various devices stored to enable read-back */
 	unsigned int ad8402_state[2];
-	unsigned int caldac_state[8];
 	short ai_cmd_running;
 	unsigned int ai_fifo_segment_length;
 	struct ext_clock_info ext_clock;
@@ -3550,9 +3549,6 @@ static void caldac_write(struct comedi_device *dev, unsigned int channel,
 			 unsigned int value)
 {
 	const struct pcidas64_board *thisboard = dev->board_ptr;
-	struct pcidas64_private *devpriv = dev->private;
-
-	devpriv->caldac_state[channel] = value;
 
 	switch (thisboard->layout) {
 	case LAYOUT_60XX:
@@ -3571,27 +3567,15 @@ static int calib_write_insn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	struct pcidas64_private *devpriv = dev->private;
 	int channel = CR_CHAN(insn->chanspec);
 
 	/* return immediately if setting hasn't changed, since
 	 * programming these things is slow */
-	if (devpriv->caldac_state[channel] == data[0])
+	if (s->readback[channel] == data[0])
 		return 1;
 
 	caldac_write(dev, channel, data[0]);
-
-	return 1;
-}
-
-static int calib_read_insn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data)
-{
-	struct pcidas64_private *devpriv = dev->private;
-	unsigned int channel = CR_CHAN(insn->chanspec);
-
-	data[0] = devpriv->caldac_state[channel];
+	s->readback[channel] = data[0];
 
 	return 1;
 }
@@ -3864,10 +3848,16 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->maxdata = 0xfff;
 	else
 		s->maxdata = 0xff;
-	s->insn_read = calib_read_insn;
 	s->insn_write = calib_write_insn;
-	for (i = 0; i < s->n_chan; i++)
+
+	ret = comedi_alloc_subdev_readback(s);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < s->n_chan; i++) {
 		caldac_write(dev, i, s->maxdata / 2);
+		s->readback[i] = s->maxdata / 2;
+	}
 
 	/*  2 channel ad8402 potentiometer */
 	s = &dev->subdevices[7];

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 05da5b33834a..4762e6a5f1b9 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3786,7 +3786,6 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->maxdata = (1 << thisboard->ao_bits) - 1;
 		s->range_table = thisboard->ao_range_table;
 		s->insn_write = ao_winsn;
-		s->insn_read = comedi_readback_insn_read;
 
 		ret = comedi_alloc_subdev_readback(s);
 		if (ret)

commit 0be887b92a1d7fce7ea62d09eefacdab9b4370e8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:31:39 2014 -0700

    staging: comedi: cb_pcidas64: use comedi_async 'scans_done' to detect AO EOA
    
    Remove the private data member 'ao_count' and use the comedi_async 'scans_done'
    member to detect the analog output end-of-acquisition.
    
    Use the comedi_nsamples_left() helper to get the number of samples to actually
    read from the async buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 375bfbb60ebb..05da5b33834a 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1085,8 +1085,6 @@ struct pcidas64_private {
 	dma_addr_t ao_dma_desc_bus_addr;
 	/*  keeps track of buffer where the next ao sample should go */
 	unsigned int ao_dma_index;
-	/*  number of analog output samples remaining */
-	unsigned long ao_count;
 	unsigned int hw_revision;	/*  stc chip hardware revision number */
 	/*  last bits sent to INTR_ENABLE_REG register */
 	unsigned int intr_enable_bits;
@@ -2848,22 +2846,6 @@ static int last_ao_dma_load_completed(struct comedi_device *dev)
 	return 1;
 }
 
-static int ao_stopped_by_error(struct comedi_device *dev,
-			       const struct comedi_cmd *cmd)
-{
-	struct pcidas64_private *devpriv = dev->private;
-
-	if (cmd->stop_src == TRIG_NONE)
-		return 1;
-	if (cmd->stop_src == TRIG_COUNT) {
-		if (devpriv->ao_count)
-			return 1;
-		if (last_ao_dma_load_completed(dev) == 0)
-			return 1;
-	}
-	return 0;
-}
-
 static inline int ao_dma_needs_restart(struct comedi_device *dev,
 				       unsigned short dma_status)
 {
@@ -2894,20 +2876,13 @@ static unsigned int cb_pcidas64_ao_fill_buffer(struct comedi_device *dev,
 					       unsigned short *dest,
 					       unsigned int max_bytes)
 {
-	struct pcidas64_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int nsamples = comedi_bytes_to_samples(s, max_bytes);
 	unsigned int actual_bytes;
 
-	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_count < nsamples)
-		nsamples = devpriv->ao_count;
-
+	nsamples = comedi_nsamples_left(s, nsamples);
 	actual_bytes = comedi_buf_read_samples(s, dest, nsamples);
-	nsamples = comedi_bytes_to_samples(s, actual_bytes);
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->ao_count -= nsamples;
 
-	return nsamples;
+	return comedi_bytes_to_samples(s, actual_bytes);
 }
 
 static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
@@ -3006,8 +2981,11 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 	}
 
 	if ((status & DAC_DONE_BIT)) {
-		async->events |= COMEDI_CB_EOA;
-		if (ao_stopped_by_error(dev, cmd))
+		if ((cmd->stop_src == TRIG_COUNT &&
+		     async->scans_done >= cmd->stop_arg) ||
+		    last_ao_dma_load_completed(dev))
+			async->events |= COMEDI_CB_EOA;
+		else
 			async->events |= COMEDI_CB_ERROR;
 	}
 	comedi_handle_events(dev, s);
@@ -3202,7 +3180,8 @@ static int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 		       devpriv->main_iobase + DAC_FIFO_REG);
 	}
 
-	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_count == 0)
+	if (cmd->stop_src == TRIG_COUNT &&
+	    s->async->scans_done >= cmd->stop_arg)
 		return 0;
 
 	nbytes = load_ao_dma_buffer(dev, cmd);
@@ -3267,7 +3246,6 @@ static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	writew(0x0, devpriv->main_iobase + DAC_CONTROL0_REG);
 
 	devpriv->ao_dma_index = 0;
-	devpriv->ao_count = cmd->stop_arg * cmd->chanlist_len;
 
 	set_dac_select_reg(dev, cmd);
 	set_dac_interval_regs(dev, cmd);

commit ccedb44075776474c5a4f0625387f3d44b562f4e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:31:38 2014 -0700

    staging: comedi: cb_pcidas64: use comedi_async 'scans_done' to detect AI EOA
    
    Remove the private data member 'ai_count' and use the comedi_async 'scans_done'
    member to detect the analog output end-of-acquisition.
    
    Use the comedi_nsamples_left() helper to get the number of samples to actually
    add to the async buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index d7b61ba6b284..375bfbb60ebb 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1065,8 +1065,6 @@ struct pcidas64_private {
 	/*  local address (used by dma controller) */
 	uint32_t local0_iobase;
 	uint32_t local1_iobase;
-	/*  number of analog input samples remaining */
-	unsigned int ai_count;
 	/*  dma buffers for analog input */
 	uint16_t *ai_buffer[MAX_AI_DMA_RING_COUNT];
 	/*  physical addresses of ai dma buffers */
@@ -2199,10 +2197,6 @@ static void setup_sample_counters(struct comedi_device *dev,
 {
 	struct pcidas64_private *devpriv = dev->private;
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		/*  set software count */
-		devpriv->ai_count = cmd->stop_arg * cmd->chanlist_len;
-	}
 	/*  load hardware conversion counter */
 	if (use_hw_sample_counter(cmd)) {
 		writew(cmd->stop_arg & 0xffff,
@@ -2642,8 +2636,6 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 {
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int i;
 	uint16_t prepost_bits;
 	int read_segment, read_index, write_segment, write_index;
@@ -2672,22 +2664,16 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 				devpriv->ai_fifo_segment_length - read_index;
 		else
 			num_samples = write_index - read_index;
-
-		if (cmd->stop_src == TRIG_COUNT) {
-			if (devpriv->ai_count == 0)
-				break;
-			if (num_samples > devpriv->ai_count)
-				num_samples = devpriv->ai_count;
-
-			devpriv->ai_count -= num_samples;
-		}
-
 		if (num_samples < 0) {
 			dev_err(dev->class_dev,
 				"cb_pcidas64: bug! num_samples < 0\n");
 			break;
 		}
 
+		num_samples = comedi_nsamples_left(s, num_samples);
+		if (num_samples == 0)
+			break;
+
 		for (i = 0; i < num_samples; i++) {
 			unsigned short val;
 
@@ -2707,29 +2693,23 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 {
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
+	unsigned int nsamples;
 	unsigned int i;
-	unsigned int max_transfer = 100000;
 	uint32_t fifo_data;
 	int write_code =
 		readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
 	int read_code =
 		readw(devpriv->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		if (max_transfer > devpriv->ai_count)
-			max_transfer = devpriv->ai_count;
-
-	}
-	for (i = 0; read_code != write_code && i < max_transfer;) {
+	nsamples = comedi_nsamples_left(s, 100000);
+	for (i = 0; read_code != write_code && i < nsamples;) {
 		unsigned short val;
 
 		fifo_data = readl(dev->mmio + ADC_FIFO_REG);
 		val = fifo_data & 0xffff;
 		comedi_buf_write_samples(s, &val, 1);
 		i++;
-		if (i < max_transfer) {
+		if (i < nsamples) {
 			val = (fifo_data >> 16) & 0xffff;
 			comedi_buf_write_samples(s, &val, 1);
 			i++;
@@ -2737,7 +2717,6 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 		read_code = readw(devpriv->main_iobase + ADC_READ_PNTR_REG) &
 			    0x7fff;
 	}
-	devpriv->ai_count -= i;
 }
 
 /* empty fifo */
@@ -2755,8 +2734,7 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 {
 	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
-	struct comedi_async *async = dev->read_subdev->async;
-	struct comedi_cmd *cmd = &async->cmd;
+	struct comedi_subdevice *s = dev->read_subdev;
 	uint32_t next_transfer_addr;
 	int j;
 	int num_samples = 0;
@@ -2777,13 +2755,8 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 	      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] +
 	      DMA_BUFFER_SIZE) && j < ai_dma_ring_count(thisboard); j++) {
 		/*  transfer data from dma buffer to comedi buffer */
-		num_samples = dma_transfer_size(dev);
-		if (cmd->stop_src == TRIG_COUNT) {
-			if (num_samples > devpriv->ai_count)
-				num_samples = devpriv->ai_count;
-			devpriv->ai_count -= num_samples;
-		}
-		comedi_buf_write_samples(dev->read_subdev,
+		num_samples = comedi_nsamples_left(s, dma_transfer_size(dev));
+		comedi_buf_write_samples(s,
 				devpriv->ai_buffer[devpriv->ai_dma_index],
 				num_samples);
 		devpriv->ai_dma_index = (devpriv->ai_dma_index + 1) %
@@ -2835,10 +2808,10 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 			spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 	/*  if we are have all the data, then quit */
-	if ((cmd->stop_src == TRIG_COUNT && (int)devpriv->ai_count <= 0) ||
-	    (cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT))) {
+	if ((cmd->stop_src == TRIG_COUNT &&
+	     async->scans_done >= cmd->stop_arg) ||
+	    (cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT)))
 		async->events |= COMEDI_CB_EOA;
-	}
 
 	comedi_handle_events(dev, s);
 }

commit c39e050d21d107d26183be0f22b89eccccdbe61c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 12:04:28 2014 -0700

    staging: comedi: remove use of 'bytes_per_sample()'
    
    This inline helper function has been replaced with comedi_bytes_per_sample().
    The same commit (bf33eb4b4f57) introduced a couple other related helper
    functions a manipulate the sample size.
    
    Use the new helper functions to remove the use of 'bytes_per_sample()' and
    remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index c8515d7f249b..d7b61ba6b284 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2923,14 +2923,14 @@ static unsigned int cb_pcidas64_ao_fill_buffer(struct comedi_device *dev,
 {
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int nsamples = max_bytes / bytes_per_sample(s);
+	unsigned int nsamples = comedi_bytes_to_samples(s, max_bytes);
 	unsigned int actual_bytes;
 
 	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_count < nsamples)
 		nsamples = devpriv->ao_count;
 
 	actual_bytes = comedi_buf_read_samples(s, dest, nsamples);
-	nsamples = actual_bytes / bytes_per_sample(s);
+	nsamples = comedi_bytes_to_samples(s, actual_bytes);
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ao_count -= nsamples;
 
@@ -2954,7 +2954,7 @@ static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 	if (nsamples == 0)
 		return 0;
 
-	nbytes = nsamples * bytes_per_sample(s);
+	nbytes = comedi_samples_to_bytes(s, nsamples);
 	devpriv->ao_dma_desc[buffer_index].transfer_size = cpu_to_le32(nbytes);
 	/* set end of chain bit so we catch underruns */
 	next_bits = le32_to_cpu(devpriv->ao_dma_desc[buffer_index].next);

commit 453fd2b395799fa2e83e3e926ff7fee810d26f92
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Oct 30 11:19:36 2014 -0700

    staging: comedi: drivers: digital output subdevices do not need SDF_READABLE
    
    The SDF_READABLE flag is not necessary for digital output subdevices. For
    consistency, remove this flag from the comedi drivers that set it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 9196680581b8..c8515d7f249b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3868,7 +3868,7 @@ static int setup_subdevices(struct comedi_device *dev)
 	if (thisboard->layout == LAYOUT_64XX) {
 		s = &dev->subdevices[3];
 		s->type = COMEDI_SUBD_DO;
-		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+		s->subdev_flags = SDF_WRITABLE;
 		s->n_chan = 4;
 		s->maxdata = 1;
 		s->range_table = &range_digital;

commit 7ba38a01444ef99e6ebeeb41167082f32991514e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:35 2014 -0700

    staging: comedi: cb_pcidas64: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() to add the samples to the async buffer.
    That function will handle single and multi samples writes by determining
    the number of bytes to add based on the bytes_per_sample().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 06e846f38992..9196680581b8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2689,9 +2689,10 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 		}
 
 		for (i = 0; i < num_samples; i++) {
-			cfc_write_to_buffer(s,
-					    readw(devpriv->main_iobase +
-						  ADC_FIFO_REG));
+			unsigned short val;
+
+			val = readw(devpriv->main_iobase + ADC_FIFO_REG);
+			comedi_buf_write_samples(s, &val, 1);
 		}
 
 	} while (read_segment != write_segment);
@@ -2722,11 +2723,15 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 
 	}
 	for (i = 0; read_code != write_code && i < max_transfer;) {
+		unsigned short val;
+
 		fifo_data = readl(dev->mmio + ADC_FIFO_REG);
-		cfc_write_to_buffer(s, fifo_data & 0xffff);
+		val = fifo_data & 0xffff;
+		comedi_buf_write_samples(s, &val, 1);
 		i++;
 		if (i < max_transfer) {
-			cfc_write_to_buffer(s, (fifo_data >> 16) & 0xffff);
+			val = (fifo_data >> 16) & 0xffff;
+			comedi_buf_write_samples(s, &val, 1);
 			i++;
 		}
 		read_code = readw(devpriv->main_iobase + ADC_READ_PNTR_REG) &
@@ -2778,10 +2783,9 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 				num_samples = devpriv->ai_count;
 			devpriv->ai_count -= num_samples;
 		}
-		cfc_write_array_to_buffer(dev->read_subdev,
-					  devpriv->ai_buffer[devpriv->
-							     ai_dma_index],
-					  num_samples * sizeof(uint16_t));
+		comedi_buf_write_samples(dev->read_subdev,
+				devpriv->ai_buffer[devpriv->ai_dma_index],
+				num_samples);
 		devpriv->ai_dma_index = (devpriv->ai_dma_index + 1) %
 					ai_dma_ring_count(thisboard);
 	}

commit 7bd7d905629a8748fa43d20b930213f54ac9177d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 14:36:37 2014 -0700

    staging: comedi: cb_pcidas: introduce cb_pcidas64_ao_fill_buffer()
    
    Introduce a helper function to read the analog output samples from the
    async buffer.
    
    This fixes a bug in load_ao_dma_buffer(). That function was decrementing
    the 'ao_count' by the number of bytes, not the number of samples, that
    were read from the async buffer.
    
    Use comedi_buf_read_samples() to read the analog output samples from
    the async buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index eafbe9f56060..06e846f38992 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2912,32 +2912,46 @@ static void restart_ao_dma(struct comedi_device *dev)
 	dma_start_sync(dev, 0);
 }
 
+static unsigned int cb_pcidas64_ao_fill_buffer(struct comedi_device *dev,
+					       struct comedi_subdevice *s,
+					       unsigned short *dest,
+					       unsigned int max_bytes)
+{
+	struct pcidas64_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int nsamples = max_bytes / bytes_per_sample(s);
+	unsigned int actual_bytes;
+
+	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_count < nsamples)
+		nsamples = devpriv->ao_count;
+
+	actual_bytes = comedi_buf_read_samples(s, dest, nsamples);
+	nsamples = actual_bytes / bytes_per_sample(s);
+	if (cmd->stop_src == TRIG_COUNT)
+		devpriv->ao_count -= nsamples;
+
+	return nsamples;
+}
+
 static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 				       const struct comedi_cmd *cmd)
 {
 	struct pcidas64_private *devpriv = dev->private;
-	unsigned int num_bytes, buffer_index, prev_buffer_index;
+	struct comedi_subdevice *s = dev->write_subdev;
+	unsigned int buffer_index = devpriv->ao_dma_index;
+	unsigned int prev_buffer_index = prev_ao_dma_index(dev);
+	unsigned int nsamples;
+	unsigned int nbytes;
 	unsigned int next_bits;
 
-	buffer_index = devpriv->ao_dma_index;
-	prev_buffer_index = prev_ao_dma_index(dev);
-
-	num_bytes = comedi_buf_read_n_available(dev->write_subdev);
-	if (num_bytes > DMA_BUFFER_SIZE)
-		num_bytes = DMA_BUFFER_SIZE;
-	if (cmd->stop_src == TRIG_COUNT && num_bytes > devpriv->ao_count)
-		num_bytes = devpriv->ao_count;
-	num_bytes -= num_bytes % bytes_in_sample;
-
-	if (num_bytes == 0)
+	nsamples = cb_pcidas64_ao_fill_buffer(dev, s,
+					      devpriv->ao_buffer[buffer_index],
+					      DMA_BUFFER_SIZE);
+	if (nsamples == 0)
 		return 0;
 
-	num_bytes = cfc_read_array_from_buffer(dev->write_subdev,
-					       devpriv->
-					       ao_buffer[buffer_index],
-					       num_bytes);
-	devpriv->ao_dma_desc[buffer_index].transfer_size =
-		cpu_to_le32(num_bytes);
+	nbytes = nsamples * bytes_per_sample(s);
+	devpriv->ao_dma_desc[buffer_index].transfer_size = cpu_to_le32(nbytes);
 	/* set end of chain bit so we catch underruns */
 	next_bits = le32_to_cpu(devpriv->ao_dma_desc[buffer_index].next);
 	next_bits |= PLX_END_OF_CHAIN_BIT;
@@ -2949,9 +2963,8 @@ static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 	devpriv->ao_dma_desc[prev_buffer_index].next = cpu_to_le32(next_bits);
 
 	devpriv->ao_dma_index = (buffer_index + 1) % AO_DMA_RING_COUNT;
-	devpriv->ao_count -= num_bytes;
 
-	return num_bytes;
+	return nbytes;
 }
 
 static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
@@ -3191,7 +3204,9 @@ static void set_dac_interval_regs(struct comedi_device *dev,
 static int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	struct pcidas64_private *devpriv = dev->private;
-	unsigned int num_bytes;
+	struct comedi_subdevice *s = dev->write_subdev;
+	unsigned int nsamples;
+	unsigned int nbytes;
 	int i;
 
 	/* clear queue pointer too, since external queue has
@@ -3199,22 +3214,22 @@ static int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	writew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);
 	writew(0, devpriv->main_iobase + DAC_BUFFER_CLEAR_REG);
 
-	num_bytes = (DAC_FIFO_SIZE / 2) * bytes_in_sample;
-	if (cmd->stop_src == TRIG_COUNT &&
-	    num_bytes / bytes_in_sample > devpriv->ao_count)
-		num_bytes = devpriv->ao_count * bytes_in_sample;
-	num_bytes = cfc_read_array_from_buffer(dev->write_subdev,
-					       devpriv->ao_bounce_buffer,
-					       num_bytes);
-	for (i = 0; i < num_bytes / bytes_in_sample; i++) {
+	nsamples = cb_pcidas64_ao_fill_buffer(dev, s,
+					      devpriv->ao_bounce_buffer,
+					      DAC_FIFO_SIZE);
+	if (nsamples == 0)
+		return -1;
+
+	for (i = 0; i < nsamples; i++) {
 		writew(devpriv->ao_bounce_buffer[i],
 		       devpriv->main_iobase + DAC_FIFO_REG);
 	}
-	devpriv->ao_count -= num_bytes / bytes_in_sample;
+
 	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_count == 0)
 		return 0;
-	num_bytes = load_ao_dma_buffer(dev, cmd);
-	if (num_bytes == 0)
+
+	nbytes = load_ao_dma_buffer(dev, cmd);
+	if (nbytes == 0)
 		return -1;
 	load_ao_dma(dev, cmd);
 

commit 62fc6407ea18267858963ee01c1238240ddce621
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:19 2014 -0700

    staging: comedi: cb_pcidas64: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 3b6bffc66918..eafbe9f56060 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2836,7 +2836,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 		async->events |= COMEDI_CB_EOA;
 	}
 
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 }
 
 static inline unsigned int prev_ao_dma_index(struct comedi_device *dev)
@@ -3020,7 +3020,7 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 		if (ao_stopped_by_error(dev, cmd))
 			async->events |= COMEDI_CB_ERROR;
 	}
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 }
 
 static irqreturn_t handle_interrupt(int irq, void *d)

commit 3bc86feba44f243900b522a4c7295dea00c51d41
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:23 2014 +0100

    staging: comedi: cb_pcidas64: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 56069d699b20..3b6bffc66918 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1038,7 +1038,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 static inline unsigned short se_diff_bit_6xxx(struct comedi_device *dev,
 					      int use_differential)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 
 	if ((thisboard->layout == LAYOUT_64XX && !use_differential) ||
 	    (thisboard->layout == LAYOUT_60XX && use_differential))
@@ -1121,7 +1121,7 @@ struct pcidas64_private {
 static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 				       unsigned int range_index)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	const struct comedi_krange *range =
 		&thisboard->ai_range_table->range[range_index];
 	unsigned int bits = 0;
@@ -1166,7 +1166,7 @@ static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 static unsigned int hw_revision(const struct comedi_device *dev,
 				uint16_t hw_status_bits)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 
 	if (thisboard->layout == LAYOUT_4020)
 		return (hw_status_bits >> 13) & 0x7;
@@ -1178,7 +1178,7 @@ static void set_dac_range_bits(struct comedi_device *dev,
 			       uint16_t *bits, unsigned int channel,
 			       unsigned int range)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	unsigned int code = thisboard->ao_range_code[range];
 
 	if (channel > 1)
@@ -1235,7 +1235,7 @@ static void disable_ai_interrupts(struct comedi_device *dev)
 static void enable_ai_interrupts(struct comedi_device *dev,
 				 const struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	uint32_t bits;
 	unsigned long flags;
@@ -1259,7 +1259,7 @@ static void enable_ai_interrupts(struct comedi_device *dev,
 /* initialize plx9080 chip */
 static void init_plx9080(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	uint32_t bits;
 	void __iomem *plx_iobase = devpriv->plx9080_iobase;
@@ -1337,7 +1337,7 @@ static void disable_ai_pacing(struct comedi_device *dev)
 static int set_ai_fifo_segment_length(struct comedi_device *dev,
 				      unsigned int num_entries)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	static const int increment_size = 0x100;
 	const struct hw_fifo_info *const fifo = thisboard->ai_fifo;
@@ -1366,7 +1366,7 @@ static int set_ai_fifo_segment_length(struct comedi_device *dev,
 /* adjusts the size of hardware fifo (which determines block size for dma xfers) */
 static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	unsigned int num_fifo_entries;
 	int retval;
 	const struct hw_fifo_info *const fifo = thisboard->ai_fifo;
@@ -1387,7 +1387,7 @@ static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 /* query length of fifo */
 static unsigned int ai_fifo_size(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 
 	return devpriv->ai_fifo_segment_length *
@@ -1397,7 +1397,7 @@ static unsigned int ai_fifo_size(struct comedi_device *dev)
 
 static void init_stc_registers(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	uint16_t bits;
 	unsigned long flags;
@@ -1443,7 +1443,7 @@ static void init_stc_registers(struct comedi_device *dev)
 
 static int alloc_and_init_dma_members(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	int i;
@@ -1526,7 +1526,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 
 static void cb_pcidas64_free_dma(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	int i;
@@ -1706,7 +1706,7 @@ static int cb_pcidas64_ai_eoc(struct comedi_device *dev,
 			      struct comedi_insn *insn,
 			      unsigned long context)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int status;
 
@@ -1725,7 +1725,7 @@ static int cb_pcidas64_ai_eoc(struct comedi_device *dev,
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int bits = 0, n;
 	unsigned int channel, range, aref;
@@ -1845,7 +1845,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 static int ai_config_calibration_source(struct comedi_device *dev,
 					unsigned int *data)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int source = data[1];
 	int num_calibration_sources;
@@ -1867,7 +1867,7 @@ static int ai_config_calibration_source(struct comedi_device *dev,
 
 static int ai_config_block_size(struct comedi_device *dev, unsigned int *data)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	int fifo_size;
 	const struct hw_fifo_info *const fifo = thisboard->ai_fifo;
 	unsigned int block_size, requested_block_size;
@@ -1921,7 +1921,7 @@ static int ai_config_master_clock_4020(struct comedi_device *dev,
 /* XXX could add support for 60xx series */
 static int ai_config_master_clock(struct comedi_device *dev, unsigned int *data)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 
 	switch (thisboard->layout) {
 	case LAYOUT_4020:
@@ -1979,7 +1979,7 @@ static unsigned int get_divisor(unsigned int ns, unsigned int flags)
  */
 static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	unsigned int convert_divisor = 0, scan_divisor;
 	static const int min_convert_divisor = 3;
 	static const int max_convert_divisor =
@@ -2027,7 +2027,7 @@ static int cb_pcidas64_ai_check_chanlist(struct comedi_device *dev,
 					 struct comedi_subdevice *s,
 					 struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *board = comedi_board(dev);
+	const struct pcidas64_board *board = dev->board_ptr;
 	unsigned int aref0 = CR_AREF(cmd->chanlist[0]);
 	int i;
 
@@ -2066,7 +2066,7 @@ static int cb_pcidas64_ai_check_chanlist(struct comedi_device *dev,
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	int err = 0;
 	unsigned int tmp_arg, tmp_arg2;
 	unsigned int triggers;
@@ -2216,7 +2216,7 @@ static void setup_sample_counters(struct comedi_device *dev,
 
 static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int num_samples;
 
@@ -2303,7 +2303,7 @@ static void select_master_clock_4020(struct comedi_device *dev,
 static void select_master_clock(struct comedi_device *dev,
 				const struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 
 	switch (thisboard->layout) {
 	case LAYOUT_4020:
@@ -2335,7 +2335,7 @@ static inline void dma_start_sync(struct comedi_device *dev,
 
 static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	uint32_t convert_counter = 0, scan_counter = 0;
 
@@ -2384,7 +2384,7 @@ static int use_internal_queue_6xxx(const struct comedi_cmd *cmd)
 static int setup_channel_queue(struct comedi_device *dev,
 			       const struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned short bits;
 	int i;
@@ -2521,7 +2521,7 @@ static inline void load_first_dma_descriptor(struct comedi_device *dev,
 
 static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -2738,7 +2738,7 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 /* empty fifo */
 static void pio_drain_ai_fifo(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 
 	if (thisboard->layout == LAYOUT_4020)
 		pio_drain_ai_fifo_32(dev);
@@ -2748,7 +2748,7 @@ static void pio_drain_ai_fifo(struct comedi_device *dev)
 
 static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_async *async = dev->read_subdev->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -2793,7 +2793,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 				unsigned short status,
 				unsigned int plx_status)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
@@ -3075,7 +3075,7 @@ static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	int chan = CR_CHAN(insn->chanspec);
 	int range = CR_RANGE(insn->chanspec);
@@ -3227,7 +3227,7 @@ static inline int external_ai_queue_in_use(struct comedi_device *dev,
 					   struct comedi_subdevice *s,
 					   struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 
 	if (s->busy)
 		return 0;
@@ -3311,7 +3311,7 @@ static int cb_pcidas64_ao_check_chanlist(struct comedi_device *dev,
 static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	int err = 0;
 	unsigned int tmp_arg;
 
@@ -3579,7 +3579,7 @@ static int caldac_i2c_write(struct comedi_device *dev,
 static void caldac_write(struct comedi_device *dev, unsigned int channel,
 			 unsigned int value)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 
 	devpriv->caldac_state[channel] = value;
@@ -3765,7 +3765,7 @@ static int eeprom_read_insn(struct comedi_device *dev,
  */
 static int setup_subdevices(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
+	const struct pcidas64_board *thisboard = dev->board_ptr;
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	int i;

commit f772bd57e6472cf9b2588c7f595669832e83f0d6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:50 2014 +0100

    staging: comedi: cb_pcidas64: use CMDF_ROUND_...
    
    Replace use of the `TRIG_ROUND_...` macros with the new names
    `CMDF_ROUND_...`.  The numeric values are unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index f1b2744d29c2..56069d699b20 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1958,14 +1958,14 @@ static unsigned int get_divisor(unsigned int ns, unsigned int flags)
 {
 	unsigned int divisor;
 
-	switch (flags & TRIG_ROUND_MASK) {
-	case TRIG_ROUND_UP:
+	switch (flags & CMDF_ROUND_MASK) {
+	case CMDF_ROUND_UP:
 		divisor = (ns + TIMER_BASE - 1) / TIMER_BASE;
 		break;
-	case TRIG_ROUND_DOWN:
+	case CMDF_ROUND_DOWN:
 		divisor = ns / TIMER_BASE;
 		break;
-	case TRIG_ROUND_NEAREST:
+	case CMDF_ROUND_NEAREST:
 	default:
 		divisor = (ns + TIMER_BASE / 2) / TIMER_BASE;
 		break;

commit 0ad08e4b269579c3b0a7f982738945562b48a13e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:36 2014 +0100

    staging: comedi: cb_pcidas64: use CMDF_WAKE_EOS
    
    Replace use of `TRIG_WAKE_EOS` command flag with the new name
    `CMDF_WAKE_EOS`.  The numeric value is unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 34771c398ca9..f1b2744d29c2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1243,8 +1243,8 @@ static void enable_ai_interrupts(struct comedi_device *dev,
 	bits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |
 	       EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;
 	/*  Use pio transfer and interrupt on end of conversion
-	 *  if TRIG_WAKE_EOS flag is set. */
-	if (cmd->flags & TRIG_WAKE_EOS) {
+	 *  if CMDF_WAKE_EOS flag is set. */
+	if (cmd->flags & CMDF_WAKE_EOS) {
 		/*  4020 doesn't support pio transfers except for fifo dregs */
 		if (thisboard->layout != LAYOUT_4020)
 			bits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;
@@ -2579,7 +2579,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  clear adc buffer */
 	writew(0, devpriv->main_iobase + ADC_BUFFER_CLEAR_REG);
 
-	if ((cmd->flags & TRIG_WAKE_EOS) == 0 ||
+	if ((cmd->flags & CMDF_WAKE_EOS) == 0 ||
 	    thisboard->layout == LAYOUT_4020) {
 		devpriv->ai_dma_index = 0;
 
@@ -2613,7 +2613,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* enable pacing, triggering, etc */
 	bits = ADC_ENABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT;
-	if (cmd->flags & TRIG_WAKE_EOS)
+	if (cmd->flags & CMDF_WAKE_EOS)
 		bits |= ADC_DMA_DISABLE_BIT;
 	/*  set start trigger */
 	if (cmd->start_src == TRIG_EXT) {
@@ -2820,7 +2820,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 
 	/*  drain fifo with pio */
 	if ((status & ADC_DONE_BIT) ||
-	    ((cmd->flags & TRIG_WAKE_EOS) &&
+	    ((cmd->flags & CMDF_WAKE_EOS) &&
 	     (status & ADC_INTR_PENDING_BIT) &&
 	     (thisboard->layout != LAYOUT_4020))) {
 		spin_lock_irqsave(&dev->spinlock, flags);

commit f9804323a84017d370b5bd048a3ddd3069500955
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 17:55:53 2014 -0700

    staging: comedi: cb_pcidas64: tidy up freeing of the dma buffers
    
    Factor the freeing of the dma buffers out of the (*detach).
    
    Move the freeing of the buffers so that it occurs after the PCI device
    has been disabled to avoid any race condition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 62f309b76760..34771c398ca9 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1524,6 +1524,46 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	return 0;
 }
 
+static void cb_pcidas64_free_dma(struct comedi_device *dev)
+{
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct pcidas64_private *devpriv = dev->private;
+	int i;
+
+	if (!devpriv)
+		return;
+
+	/* free pci dma buffers */
+	for (i = 0; i < ai_dma_ring_count(thisboard); i++) {
+		if (devpriv->ai_buffer[i])
+			pci_free_consistent(pcidev,
+					    DMA_BUFFER_SIZE,
+					    devpriv->ai_buffer[i],
+					    devpriv->ai_buffer_bus_addr[i]);
+	}
+	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
+		if (devpriv->ao_buffer[i])
+			pci_free_consistent(pcidev,
+					    DMA_BUFFER_SIZE,
+					    devpriv->ao_buffer[i],
+					    devpriv->ao_buffer_bus_addr[i]);
+	}
+	/* free dma descriptors */
+	if (devpriv->ai_dma_desc)
+		pci_free_consistent(pcidev,
+				    sizeof(struct plx_dma_desc) *
+				    ai_dma_ring_count(thisboard),
+				    devpriv->ai_dma_desc,
+				    devpriv->ai_dma_desc_bus_addr);
+	if (devpriv->ao_dma_desc)
+		pci_free_consistent(pcidev,
+				    sizeof(struct plx_dma_desc) *
+				    AO_DMA_RING_COUNT,
+				    devpriv->ao_dma_desc,
+				    devpriv->ao_dma_desc_bus_addr);
+}
+
 static inline void warn_external_queue(struct comedi_device *dev)
 {
 	dev_err(dev->class_dev,
@@ -3975,54 +4015,22 @@ static int auto_attach(struct comedi_device *dev,
 
 static void detach(struct comedi_device *dev)
 {
-	const struct pcidas64_board *thisboard = comedi_board(dev);
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct pcidas64_private *devpriv = dev->private;
-	unsigned int i;
 
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (devpriv) {
-		if (pcidev) {
-			if (devpriv->plx9080_iobase) {
-				disable_plx_interrupts(dev);
-				iounmap(devpriv->plx9080_iobase);
-			}
-			if (devpriv->main_iobase)
-				iounmap(devpriv->main_iobase);
-			if (dev->mmio)
-				iounmap(dev->mmio);
-			/*  free pci dma buffers */
-			for (i = 0; i < ai_dma_ring_count(thisboard); i++) {
-				if (devpriv->ai_buffer[i])
-					pci_free_consistent(pcidev,
-						DMA_BUFFER_SIZE,
-						devpriv->ai_buffer[i],
-						devpriv->ai_buffer_bus_addr[i]);
-			}
-			for (i = 0; i < AO_DMA_RING_COUNT; i++) {
-				if (devpriv->ao_buffer[i])
-					pci_free_consistent(pcidev,
-						DMA_BUFFER_SIZE,
-						devpriv->ao_buffer[i],
-						devpriv->ao_buffer_bus_addr[i]);
-			}
-			/*  free dma descriptors */
-			if (devpriv->ai_dma_desc)
-				pci_free_consistent(pcidev,
-					sizeof(struct plx_dma_desc) *
-					ai_dma_ring_count(thisboard),
-					devpriv->ai_dma_desc,
-					devpriv->ai_dma_desc_bus_addr);
-			if (devpriv->ao_dma_desc)
-				pci_free_consistent(pcidev,
-					sizeof(struct plx_dma_desc) *
-					AO_DMA_RING_COUNT,
-					devpriv->ao_dma_desc,
-					devpriv->ao_dma_desc_bus_addr);
+		if (devpriv->plx9080_iobase) {
+			disable_plx_interrupts(dev);
+			iounmap(devpriv->plx9080_iobase);
 		}
+		if (devpriv->main_iobase)
+			iounmap(devpriv->main_iobase);
+		if (dev->mmio)
+			iounmap(dev->mmio);
 	}
 	comedi_pci_disable(dev);
+	cb_pcidas64_free_dma(dev);
 }
 
 static struct comedi_driver cb_pcidas64_driver = {

commit f88f75fe9c89c3c627659a6cfa91918176674500
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:51 2014 -0700

    staging: comedi: cb_pcidas64: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 77b028452d93..62f309b76760 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1089,8 +1089,6 @@ struct pcidas64_private {
 	unsigned int ao_dma_index;
 	/*  number of analog output samples remaining */
 	unsigned long ao_count;
-	/*  remember what the analog outputs are set to, to allow readback */
-	unsigned int ao_value[2];
 	unsigned int hw_revision;	/*  stc chip hardware revision number */
 	/*  last bits sent to INTR_ENABLE_REG register */
 	unsigned int intr_enable_bits;
@@ -3061,18 +3059,7 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	}
 
 	/*  remember output value */
-	devpriv->ao_value[chan] = data[0];
-
-	return 1;
-}
-
-static int ao_readback_insn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
-{
-	struct pcidas64_private *devpriv = dev->private;
-
-	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
+	s->readback[chan] = data[0];
 
 	return 1;
 }
@@ -3788,8 +3775,13 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->n_chan = thisboard->ao_nchan;
 		s->maxdata = (1 << thisboard->ao_bits) - 1;
 		s->range_table = thisboard->ao_range_table;
-		s->insn_read = ao_readback_insn;
 		s->insn_write = ao_winsn;
+		s->insn_read = comedi_readback_insn_read;
+
+		ret = comedi_alloc_subdev_readback(s);
+		if (ret)
+			return ret;
+
 		if (ao_cmd_is_supported(thisboard)) {
 			dev->write_subdev = s;
 			s->do_cmdtest = ao_cmdtest;

commit 5c19084bbd4ef7c0a10e5b01145b940edf872a63
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:28 2014 -0700

    staging: comedi: 8255: handle memory mapped io
    
    The drivers that use this module with memory mapped io all have the
    ioremap'ed base address stored in the comedi_device 'mmio' member.
    
    Introduce a default (*io) function that does 8-bit memory mapped io.
    
    Modify subdev_8255_init() so that it takes a flag parameter indicating
    if the io is port or memory mapped. Make the function static and rename
    it to __subdev_8255_init().
    
    Introduce two exported wrappers for __subdev_8255_init():
    
      subdev_8255_init() - for drivers that do 8-bit port io
      subdev_8255_mm_init() - for drivers that do 8-bit memory mapped io
    
    Use subdev_8255_mm_init() in the drivers that do 8-bit memory mapped io
    and remove the private (*io) functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index e3bfbd4c5def..77b028452d93 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3369,16 +3369,6 @@ static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int dio_callback(struct comedi_device *dev,
-			int dir, int port, int data, unsigned long iobase)
-{
-	if (dir) {
-		writeb(data, dev->mmio + iobase + port);
-		return 0;
-	}
-	return readb(dev->mmio + iobase + port);
-}
-
 static int dio_callback_4020(struct comedi_device *dev,
 			     int dir, int port, int data, unsigned long iobase)
 {
@@ -3842,8 +3832,8 @@ static int setup_subdevices(struct comedi_device *dev)
 			ret = subdev_8255_init(dev, s, dio_callback_4020,
 					       I8255_4020_REG);
 		} else {
-			ret = subdev_8255_init(dev, s, dio_callback,
-					       DIO_8255_OFFSET);
+			ret = subdev_8255_mm_init(dev, s, NULL,
+						  DIO_8255_OFFSET);
 		}
 		if (ret)
 			return ret;

commit da261e1d38f5ed4baaebc45f51e628e7d84a2560
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:24 2014 -0700

    staging: comedi: cb_pcidas64: tidy up dio_callback_4020()
    
    The 8255 driver (*io) callback now includes the comedi_device pointer.
    Using this we can get the ioremap'ed base address.
    
    Instead of passing the (cast) mmio address to subdev_8255_init(), pass
    the 'iobase' of the 8255 registers (I8255_4020_REG).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 61cb560e1bec..e3bfbd4c5def 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3380,15 +3380,15 @@ static int dio_callback(struct comedi_device *dev,
 }
 
 static int dio_callback_4020(struct comedi_device *dev,
-			     int dir, int port, int data, unsigned long arg)
+			     int dir, int port, int data, unsigned long iobase)
 {
-	void __iomem *iobase = (void __iomem *)arg;
+	struct pcidas64_private *devpriv = dev->private;
 
 	if (dir) {
-		writew(data, iobase + 2 * port);
+		writew(data, devpriv->main_iobase + iobase + 2 * port);
 		return 0;
 	}
-	return readw(iobase + 2 * port);
+	return readw(devpriv->main_iobase + iobase + 2 * port);
 }
 
 static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -3751,7 +3751,6 @@ static int setup_subdevices(struct comedi_device *dev)
 	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
-	void __iomem *dio_8255_iobase;
 	int i;
 	int ret;
 
@@ -3840,9 +3839,8 @@ static int setup_subdevices(struct comedi_device *dev)
 	s = &dev->subdevices[4];
 	if (thisboard->has_8255) {
 		if (thisboard->layout == LAYOUT_4020) {
-			dio_8255_iobase = devpriv->main_iobase + I8255_4020_REG;
 			ret = subdev_8255_init(dev, s, dio_callback_4020,
-					       (unsigned long)dio_8255_iobase);
+					       I8255_4020_REG);
 		} else {
 			ret = subdev_8255_init(dev, s, dio_callback,
 					       DIO_8255_OFFSET);

commit 27fdf38574e63f21c14098b11f36d932cb3aaf25
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:23 2014 -0700

    staging: comedi: cb_pcidas64: tidy up dio_callback()
    
    The 8255 driver (*io) callback now includes the comedi_device pointer.
    Using this we can get the ioremap'ed base address.
    
    Instead of passing the (cast) mmio address to subdev_8255_init(), pass
    the 'iobase' of the 8255 registers (DIO_8255_OFFSET).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index fafde70cbb51..61cb560e1bec 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3370,15 +3370,13 @@ static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static int dio_callback(struct comedi_device *dev,
-			int dir, int port, int data, unsigned long arg)
+			int dir, int port, int data, unsigned long iobase)
 {
-	void __iomem *iobase = (void __iomem *)arg;
-
 	if (dir) {
-		writeb(data, iobase + port);
+		writeb(data, dev->mmio + iobase + port);
 		return 0;
 	}
-	return readb(iobase + port);
+	return readb(dev->mmio + iobase + port);
 }
 
 static int dio_callback_4020(struct comedi_device *dev,
@@ -3846,9 +3844,8 @@ static int setup_subdevices(struct comedi_device *dev)
 			ret = subdev_8255_init(dev, s, dio_callback_4020,
 					       (unsigned long)dio_8255_iobase);
 		} else {
-			dio_8255_iobase = dev->mmio + DIO_8255_OFFSET;
 			ret = subdev_8255_init(dev, s, dio_callback,
-					       (unsigned long)dio_8255_iobase);
+					       DIO_8255_OFFSET);
 		}
 		if (ret)
 			return ret;

commit 09d6dd7490ee7f1dda926e309df370e28679a71c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:19 2014 -0700

    staging: comedi: 8255: add a comedi_device param to the (*io) callback
    
    The 8255 driver uses an (*io) callback to read/write the registers
    of the 8255 device. The default callback provided by the driver uses
    inb()/outb() calls to access to registers based on an 'iobase' that
    was initialized during the subdev_8255_init() and a 'port' value.
    
    The users of this module can optionally provide a custom (*io) callback
    to handle the read/write in another manner.
    
    Make the (*io) callback a bit more flexible by also passing the
    comedi_device pointer as a parameter.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index fa12614cef2a..fafde70cbb51 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3369,7 +3369,8 @@ static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int dio_callback(int dir, int port, int data, unsigned long arg)
+static int dio_callback(struct comedi_device *dev,
+			int dir, int port, int data, unsigned long arg)
 {
 	void __iomem *iobase = (void __iomem *)arg;
 
@@ -3380,7 +3381,8 @@ static int dio_callback(int dir, int port, int data, unsigned long arg)
 	return readb(iobase + port);
 }
 
-static int dio_callback_4020(int dir, int port, int data, unsigned long arg)
+static int dio_callback_4020(struct comedi_device *dev,
+			     int dir, int port, int data, unsigned long arg)
 {
 	void __iomem *iobase = (void __iomem *)arg;
 

commit 9ebd1028cf79540997cc3cefcd62bfcfc2ed0603
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jul 29 15:01:33 2014 -0700

    staging: comedi: cb_pcidas64: use the comedi_device 'mmio' member
    
    Use the new 'mmio' member in the comedi_device for the ioremap'ed
    base address of PCI bar 3.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 4b332ddec022..fa12614cef2a 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -177,7 +177,7 @@ enum read_write_registers {
 	DAC_FIFO_REG = 0x300,
 };
 
-/* devpriv->dio_counter_iobase registers */
+/* dev->mmio registers */
 enum dio_counter_registers {
 	DIO_8255_OFFSET = 0x0,
 	DO_REG = 0x20,
@@ -1062,7 +1062,6 @@ struct pcidas64_private {
 	/*  base addresses (ioremapped) */
 	void __iomem *plx9080_iobase;
 	void __iomem *main_iobase;
-	void __iomem *dio_counter_iobase;
 	/*  local address (used by dma controller) */
 	uint32_t local0_iobase;
 	uint32_t local1_iobase;
@@ -1797,8 +1796,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			return ret;
 
 		if (thisboard->layout == LAYOUT_4020)
-			data[n] = readl(devpriv->dio_counter_iobase +
-					ADC_FIFO_REG) & 0xffff;
+			data[n] = readl(dev->mmio + ADC_FIFO_REG) & 0xffff;
 		else
 			data[n] = readw(devpriv->main_iobase + PIPE1_READ_REG);
 	}
@@ -2686,7 +2684,7 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 
 	}
 	for (i = 0; read_code != write_code && i < max_transfer;) {
-		fifo_data = readl(devpriv->dio_counter_iobase + ADC_FIFO_REG);
+		fifo_data = readl(dev->mmio + ADC_FIFO_REG);
 		cfc_write_to_buffer(s, fifo_data & 0xffff);
 		i++;
 		if (i < max_transfer) {
@@ -3396,10 +3394,9 @@ static int dio_callback_4020(int dir, int port, int data, unsigned long arg)
 static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
-	struct pcidas64_private *devpriv = dev->private;
 	unsigned int bits;
 
-	bits = readb(devpriv->dio_counter_iobase + DI_REG);
+	bits = readb(dev->mmio + DI_REG);
 	bits &= 0xf;
 	data[1] = bits;
 	data[0] = 0;
@@ -3412,10 +3409,8 @@ static int do_wbits(struct comedi_device *dev,
 		    struct comedi_insn *insn,
 		    unsigned int *data)
 {
-	struct pcidas64_private *devpriv = dev->private;
-
 	if (comedi_dio_update_state(s, data))
-		writeb(s->state, devpriv->dio_counter_iobase + DO_REG);
+		writeb(s->state, dev->mmio + DO_REG);
 
 	data[1] = s->state;
 
@@ -3427,15 +3422,13 @@ static int dio_60xx_config_insn(struct comedi_device *dev,
 				struct comedi_insn *insn,
 				unsigned int *data)
 {
-	struct pcidas64_private *devpriv = dev->private;
 	int ret;
 
 	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
 	if (ret)
 		return ret;
 
-	writeb(s->io_bits,
-	       devpriv->dio_counter_iobase + DIO_DIRECTION_60XX_REG);
+	writeb(s->io_bits, dev->mmio + DIO_DIRECTION_60XX_REG);
 
 	return insn->n;
 }
@@ -3445,14 +3438,10 @@ static int dio_60xx_wbits(struct comedi_device *dev,
 			  struct comedi_insn *insn,
 			  unsigned int *data)
 {
-	struct pcidas64_private *devpriv = dev->private;
-
-	if (comedi_dio_update_state(s, data)) {
-		writeb(s->state,
-		       devpriv->dio_counter_iobase + DIO_DATA_60XX_REG);
-	}
+	if (comedi_dio_update_state(s, data))
+		writeb(s->state, dev->mmio + DIO_DATA_60XX_REG);
 
-	data[1] = readb(devpriv->dio_counter_iobase + DIO_DATA_60XX_REG);
+	data[1] = readb(dev->mmio + DIO_DATA_60XX_REG);
 
 	return insn->n;
 }
@@ -3855,8 +3844,7 @@ static int setup_subdevices(struct comedi_device *dev)
 			ret = subdev_8255_init(dev, s, dio_callback_4020,
 					       (unsigned long)dio_8255_iobase);
 		} else {
-			dio_8255_iobase =
-				devpriv->dio_counter_iobase + DIO_8255_OFFSET;
+			dio_8255_iobase = dev->mmio + DIO_8255_OFFSET;
 			ret = subdev_8255_init(dev, s, dio_callback,
 					       (unsigned long)dio_8255_iobase);
 		}
@@ -3957,10 +3945,9 @@ static int auto_attach(struct comedi_device *dev,
 
 	devpriv->plx9080_iobase = pci_ioremap_bar(pcidev, 0);
 	devpriv->main_iobase = pci_ioremap_bar(pcidev, 2);
-	devpriv->dio_counter_iobase = pci_ioremap_bar(pcidev, 3);
+	dev->mmio = pci_ioremap_bar(pcidev, 3);
 
-	if (!devpriv->plx9080_iobase || !devpriv->main_iobase
-	    || !devpriv->dio_counter_iobase) {
+	if (!devpriv->plx9080_iobase || !devpriv->main_iobase || !dev->mmio) {
 		dev_warn(dev->class_dev, "failed to remap io memory\n");
 		return -ENOMEM;
 	}
@@ -4024,8 +4011,8 @@ static void detach(struct comedi_device *dev)
 			}
 			if (devpriv->main_iobase)
 				iounmap(devpriv->main_iobase);
-			if (devpriv->dio_counter_iobase)
-				iounmap(devpriv->dio_counter_iobase);
+			if (dev->mmio)
+				iounmap(dev->mmio);
 			/*  free pci dma buffers */
 			for (i = 0; i < ai_dma_ring_count(thisboard); i++) {
 				if (devpriv->ai_buffer[i])

commit 71e068743a5e4061a7a3c42cc3ac6dbda7a7f76e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:24 2014 -0700

    staging: comedi: drivers: use dev->board_name in request_irq()
    
    Most of the comedi drivers use the dev->board_name for the id string
    passed to request_irq(). Fix the couple that still pass something
    else.
    
    Also, propogate the errno from request_irq().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 4012d8cba121..4b332ddec022 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3989,12 +3989,13 @@ static int auto_attach(struct comedi_device *dev,
 		devpriv->hw_revision);
 	init_plx9080(dev);
 	init_stc_registers(dev);
-	/*  get irq */
-	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
-			"cb_pcidas64", dev)) {
+
+	retval = request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
+			     dev->board_name, dev);
+	if (retval) {
 		dev_dbg(dev->class_dev, "unable to allocate irq %u\n",
 			pcidev->irq);
-		return -EINVAL;
+		return retval;
 	}
 	dev->irq = pcidev->irq;
 	dev_dbg(dev->class_dev, "irq %u\n", dev->irq);

commit c72f57377c4168a1aed68b4250a109a2505bdd62
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 12:27:30 2014 -0700

    staging: comedi: cb_pcidas64: remove unused pr_fmt() macro
    
    This macro is not used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 1e69c82e2315..4012d8cba121 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -80,8 +80,6 @@
 	make ao fifo size adjustable like ai fifo
 */
 
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/delay.h>

commit e176d78c5cda47ff2e43fe3202eee2dc91a209f0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:37 2014 -0700

    staging: comedi: cb_pcidas64: remove use of comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character. The addition of the driver_name is just added noise
    and some of the users of comedi_error() add unnecessary additional new-line
    characters.
    
    Use dev_err() directly instead of comedi_error() to avoid any confusion
    and so that all the comedi generated kernel messages have the same format.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 0fd73e7f34c3..1e69c82e2315 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1160,7 +1160,7 @@ static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 		bits = 0x700;
 		break;
 	default:
-		comedi_error(dev, "bug! in ai_range_bits_6xxx");
+		dev_err(dev->class_dev, "bug! in %s\n", __func__);
 		break;
 	}
 	if (range->min == 0)
@@ -1187,9 +1187,9 @@ static void set_dac_range_bits(struct comedi_device *dev,
 	unsigned int code = thisboard->ao_range_code[range];
 
 	if (channel > 1)
-		comedi_error(dev, "bug! bad channel?");
+		dev_err(dev->class_dev, "bug! bad channel?\n");
 	if (code & ~0x3)
-		comedi_error(dev, "bug! bad range code?");
+		dev_err(dev->class_dev, "bug! bad range code?\n");
 
 	*bits &= ~(0x3 << (2 * channel));
 	*bits |= code << (2 * channel);
@@ -1531,10 +1531,10 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 
 static inline void warn_external_queue(struct comedi_device *dev)
 {
-	comedi_error(dev,
-		     "AO command and AI external channel queue cannot be used simultaneously.");
-	comedi_error(dev,
-		     "Use internal AI channel queue (channels must be consecutive and use same range/aref)");
+	dev_err(dev->class_dev,
+		"AO command and AI external channel queue cannot be used simultaneously\n");
+	dev_err(dev->class_dev,
+		"Use internal AI channel queue (channels must be consecutive and use same range/aref)\n");
 }
 
 /* Their i2c requires a huge delay on setting clock or data high for some reason */
@@ -1648,7 +1648,8 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 
 	/*  get acknowledge */
 	if (i2c_read_ack(dev) != 0) {
-		comedi_error(dev, "i2c write failed: no acknowledge");
+		dev_err(dev->class_dev, "%s failed: no acknowledge\n",
+			__func__);
 		i2c_stop(dev);
 		return;
 	}
@@ -1656,7 +1657,8 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 	for (i = 0; i < length; i++) {
 		i2c_write_byte(dev, data[i]);
 		if (i2c_read_ack(dev) != 0) {
-			comedi_error(dev, "i2c write failed: no acknowledge");
+			dev_err(dev->class_dev, "%s failed: no acknowledge\n",
+				__func__);
 			i2c_stop(dev);
 			return;
 		}
@@ -2234,7 +2236,7 @@ static uint32_t ai_convert_counter_4020(struct comedi_device *dev,
 		divisor = devpriv->ext_clock.divisor;
 		break;
 	default:		/*  should never happen */
-		comedi_error(dev, "bug! failed to set ai pacing!");
+		dev_err(dev->class_dev, "bug! failed to set ai pacing!\n");
 		divisor = 1000;
 		break;
 	}
@@ -2767,7 +2769,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 
 	/*  check for fifo overrun */
 	if (status & ADC_OVERRUN_BIT) {
-		comedi_error(dev, "fifo overrun");
+		dev_err(dev->class_dev, "fifo overrun\n");
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
 	/*  spin lock makes sure no one else changes plx dma control reg */
@@ -3130,7 +3132,8 @@ static void set_dac_select_reg(struct comedi_device *dev,
 	first_channel = CR_CHAN(cmd->chanlist[0]);
 	last_channel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);
 	if (last_channel < first_channel)
-		comedi_error(dev, "bug! last ao channel < first ao channel");
+		dev_err(dev->class_dev,
+			"bug! last ao channel < first ao channel\n");
 
 	bits = (first_channel & 0x7) | (last_channel & 0x7) << 3;
 
@@ -3153,7 +3156,7 @@ static void set_dac_interval_regs(struct comedi_device *dev,
 
 	divisor = get_ao_divisor(cmd->scan_begin_arg, cmd->flags);
 	if (divisor > max_counter_value) {
-		comedi_error(dev, "bug! ao divisor too big");
+		dev_err(dev->class_dev, "bug! ao divisor too big\n");
 		divisor = max_counter_value;
 	}
 	writew(divisor & 0xffff,
@@ -3488,7 +3491,7 @@ static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 	static const int caldac_8800_udelay = 1;
 
 	if (address >= num_caldac_channels) {
-		comedi_error(dev, "illegal caldac channel");
+		dev_err(dev->class_dev, "illegal caldac channel\n");
 		return -1;
 	}
 	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
@@ -3560,7 +3563,7 @@ static int caldac_i2c_write(struct comedi_device *dev,
 		serial_bytes[0] = GAIN_1_3;
 		break;
 	default:
-		comedi_error(dev, "invalid caldac channel\n");
+		dev_err(dev->class_dev, "invalid caldac channel\n");
 		return -1;
 	}
 	serial_bytes[1] = NOT_CLEAR_REGISTERS | ((value >> 8) & 0xf);

commit 350a327641f891fde438ba7e1591f8a858e524f6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:22:47 2014 -0700

    staging: comedi: cb_pcidas64: remove 'volatile' from set_dac_range_bits() param
    
    As indicated by checkpatch.pl, "WARNING: Use of volatile is usually
    wrong: ...". The 'bits' parameter to this function does not need to
    be volatile.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 781412e11da9..0fd73e7f34c3 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1180,7 +1180,7 @@ static unsigned int hw_revision(const struct comedi_device *dev,
 }
 
 static void set_dac_range_bits(struct comedi_device *dev,
-			       volatile uint16_t *bits, unsigned int channel,
+			       uint16_t *bits, unsigned int channel,
 			       unsigned int range)
 {
 	const struct pcidas64_board *thisboard = comedi_board(dev);

commit 0f99981a6da832cf3d2ddbd2ae7c7f51e8f6b1ab
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:22:46 2014 -0700

    staging: comedi: cb_pcidas64: remove 'volatile' from private data
    
    As indicated by checkpatch.pl, "WARNING: Use of volatile is usually
    wrong: ...". The variables in the private data that are marked
    volatile don't need to be. Remove the volatile.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 046336f059aa..781412e11da9 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1069,7 +1069,7 @@ struct pcidas64_private {
 	uint32_t local0_iobase;
 	uint32_t local1_iobase;
 	/*  number of analog input samples remaining */
-	volatile unsigned int ai_count;
+	unsigned int ai_count;
 	/*  dma buffers for analog input */
 	uint16_t *ai_buffer[MAX_AI_DMA_RING_COUNT];
 	/*  physical addresses of ai dma buffers */
@@ -1081,7 +1081,7 @@ struct pcidas64_private {
 	dma_addr_t ai_dma_desc_bus_addr;
 	/*  index of the ai dma descriptor/buffer
 	 *  that is currently being used */
-	volatile unsigned int ai_dma_index;
+	unsigned int ai_dma_index;
 	/*  dma buffers for analog output */
 	uint16_t *ao_buffer[AO_DMA_RING_COUNT];
 	/*  physical addresses of ao dma buffers */
@@ -1089,35 +1089,35 @@ struct pcidas64_private {
 	struct plx_dma_desc *ao_dma_desc;
 	dma_addr_t ao_dma_desc_bus_addr;
 	/*  keeps track of buffer where the next ao sample should go */
-	volatile unsigned int ao_dma_index;
+	unsigned int ao_dma_index;
 	/*  number of analog output samples remaining */
-	volatile unsigned long ao_count;
+	unsigned long ao_count;
 	/*  remember what the analog outputs are set to, to allow readback */
-	volatile unsigned int ao_value[2];
+	unsigned int ao_value[2];
 	unsigned int hw_revision;	/*  stc chip hardware revision number */
 	/*  last bits sent to INTR_ENABLE_REG register */
-	volatile unsigned int intr_enable_bits;
+	unsigned int intr_enable_bits;
 	/*  last bits sent to ADC_CONTROL1_REG register */
-	volatile uint16_t adc_control1_bits;
+	uint16_t adc_control1_bits;
 	/*  last bits sent to FIFO_SIZE_REG register */
-	volatile uint16_t fifo_size_bits;
+	uint16_t fifo_size_bits;
 	/*  last bits sent to HW_CONFIG_REG register */
-	volatile uint16_t hw_config_bits;
-	volatile uint16_t dac_control1_bits;
+	uint16_t hw_config_bits;
+	uint16_t dac_control1_bits;
 	/*  last bits written to plx9080 control register */
-	volatile uint32_t plx_control_bits;
+	uint32_t plx_control_bits;
 	/*  last bits written to plx interrupt control and status register */
-	volatile uint32_t plx_intcsr_bits;
+	uint32_t plx_intcsr_bits;
 	/*  index of calibration source readable through ai ch0 */
-	volatile int calibration_source;
+	int calibration_source;
 	/*  bits written to i2c calibration/range register */
-	volatile uint8_t i2c_cal_range_bits;
+	uint8_t i2c_cal_range_bits;
 	/*  configure digital triggers to trigger on falling edge */
-	volatile unsigned int ext_trig_falling;
+	unsigned int ext_trig_falling;
 	/*  states of various devices stored to enable read-back */
 	unsigned int ad8402_state[2];
 	unsigned int caldac_state[8];
-	volatile short ai_cmd_running;
+	short ai_cmd_running;
 	unsigned int ai_fifo_segment_length;
 	struct ext_clock_info ext_clock;
 	unsigned short ao_bounce_buffer[DAC_FIFO_SIZE];

commit a8fa9200a5e594e2c46ef6138aeab46aac68483e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:01:54 2014 -0700

    staging: comedi: cd_pcidas64: checkpatch.pl cleanup (void function return)
    
    Fix the checkpatch.pl warning:
    
    WARNING: void function return statements are not generally useful
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 171342a9197f..046336f059aa 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1985,8 +1985,6 @@ static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 			scan_divisor = min_scan_divisor;
 		cmd->scan_begin_arg = scan_divisor * TIMER_BASE;
 	}
-
-	return;
 }
 
 static int cb_pcidas64_ai_check_chanlist(struct comedi_device *dev,

commit 43358ed094deec0f13fbd873674ebc5eedc32ca1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:01:53 2014 -0700

    staging: comedi: cb_pcidas64: checkpatch.pl cleanup (missing blank line)
    
    Fix this checkpatch.pl warning:
    
    WARNING: Missing a blank line after declarations
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index f296cbc41094..171342a9197f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1769,6 +1769,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		 *  as it is very slow */
 		if (old_cal_range_bits != devpriv->i2c_cal_range_bits) {
 			uint8_t i2c_data = devpriv->i2c_cal_range_bits;
+
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
 				  sizeof(i2c_data));
 		}
@@ -2446,6 +2447,7 @@ static int setup_channel_queue(struct comedi_device *dev,
 		 *  as it is very slow */
 		if (old_cal_range_bits != devpriv->i2c_cal_range_bits) {
 			uint8_t i2c_data = devpriv->i2c_cal_range_bits;
+
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
 				  sizeof(i2c_data));
 		}
@@ -3373,6 +3375,7 @@ static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static int dio_callback(int dir, int port, int data, unsigned long arg)
 {
 	void __iomem *iobase = (void __iomem *)arg;
+
 	if (dir) {
 		writeb(data, iobase + port);
 		return 0;
@@ -3383,6 +3386,7 @@ static int dio_callback(int dir, int port, int data, unsigned long arg)
 static int dio_callback_4020(int dir, int port, int data, unsigned long arg)
 {
 	void __iomem *iobase = (void __iomem *)arg;
+
 	if (dir) {
 		writew(data, iobase + 2 * port);
 		return 0;

commit f10516768140984d66ee120060a5cf8bf04f8f71
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:28 2014 -0700

    staging: comedi: cb_pcidas64: checkpatch.pl cleanup (break not useful)
    
    Fix the checkpatch.pl warnings:
    
    WARNING: break is not useful after a goto or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index bf4c1b2eb399..f296cbc41094 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1874,7 +1874,6 @@ static int ai_config_master_clock_4020(struct comedi_device *dev,
 		break;
 	default:
 		return -EINVAL;
-		break;
 	}
 
 	data[4] = divisor;
@@ -1890,10 +1889,8 @@ static int ai_config_master_clock(struct comedi_device *dev, unsigned int *data)
 	switch (thisboard->layout) {
 	case LAYOUT_4020:
 		return ai_config_master_clock_4020(dev, data);
-		break;
 	default:
 		return -EINVAL;
-		break;
 	}
 
 	return -EINVAL;
@@ -1907,16 +1904,12 @@ static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
 	switch (id) {
 	case INSN_CONFIG_ALT_SOURCE:
 		return ai_config_calibration_source(dev, data);
-		break;
 	case INSN_CONFIG_BLOCK_SIZE:
 		return ai_config_block_size(dev, data);
-		break;
 	case INSN_CONFIG_TIMER_1:
 		return ai_config_master_clock(dev, data);
-		break;
 	default:
 		return -EINVAL;
-		break;
 	}
 	return -EINVAL;
 }
@@ -2224,7 +2217,6 @@ static uint32_t ai_scan_counter_6xxx(struct comedi_device *dev,
 		break;
 	default:
 		return 0;
-		break;
 	}
 	return count - 3;
 }
@@ -3568,7 +3560,6 @@ static int caldac_i2c_write(struct comedi_device *dev,
 	default:
 		comedi_error(dev, "invalid caldac channel\n");
 		return -1;
-		break;
 	}
 	serial_bytes[1] = NOT_CLEAR_REGISTERS | ((value >> 8) & 0xf);
 	serial_bytes[2] = value & 0xff;

commit 4ffeead33263faf598fdf965a42f873a3587f4c6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:21 2014 -0700

    staging: comedi: cb_pcidas64: checkpatch.pl cleanup (else after return)
    
    Fix these checkpatch.pl warnings:
    
    WARNING: else is not generally useful after a break or return
    
    Also, remove an unnecessary trailing ';' at the end of a function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 035c3a176005..bf4c1b2eb399 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -636,8 +636,8 @@ static inline unsigned int ai_dma_ring_count(const struct pcidas64_board *board)
 {
 	if (board->layout == LAYOUT_4020)
 		return MAX_AI_DMA_RING_COUNT;
-	else
-		return MIN_AI_DMA_RING_COUNT;
+
+	return MIN_AI_DMA_RING_COUNT;
 }
 
 static const int bytes_in_sample = 2;
@@ -1045,9 +1045,9 @@ static inline unsigned short se_diff_bit_6xxx(struct comedi_device *dev,
 	if ((thisboard->layout == LAYOUT_64XX && !use_differential) ||
 	    (thisboard->layout == LAYOUT_60XX && use_differential))
 		return ADC_SE_DIFF_BIT;
-	else
-		return 0;
-};
+
+	return 0;
+}
 
 struct ext_clock_info {
 	/*  master clock divisor to use for scans with external master clock */
@@ -2162,8 +2162,8 @@ static int use_hw_sample_counter(struct comedi_cmd *cmd)
 
 	if (cmd->stop_src == TRIG_COUNT && cmd->stop_arg <= max_counter_value)
 		return 1;
-	else
-		return 0;
+
+	return 0;
 }
 
 static void setup_sample_counters(struct comedi_device *dev,
@@ -3384,9 +3384,8 @@ static int dio_callback(int dir, int port, int data, unsigned long arg)
 	if (dir) {
 		writeb(data, iobase + port);
 		return 0;
-	} else {
-		return readb(iobase + port);
 	}
+	return readb(iobase + port);
 }
 
 static int dio_callback_4020(int dir, int port, int data, unsigned long arg)
@@ -3395,9 +3394,8 @@ static int dio_callback_4020(int dir, int port, int data, unsigned long arg)
 	if (dir) {
 		writew(data, iobase + 2 * port);
 		return 0;
-	} else {
-		return readw(iobase + 2 * port);
 	}
+	return readw(iobase + 2 * port);
 }
 
 static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,

commit f5f3a2c6569eb336e0638513ae9ccc68532c632f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:31:04 2014 -0700

    staging: comedi: cb_pcidas64: change params to external_ai_queue_in_use()
    
    The caller already has the comedi_subdevice and comedi_cmd pointers. Pass
    those variables to the helper function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 63b00cf3bd87..035c3a176005 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3205,15 +3205,17 @@ static int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	return 0;
 }
 
-static inline int external_ai_queue_in_use(struct comedi_device *dev)
+static inline int external_ai_queue_in_use(struct comedi_device *dev,
+					   struct comedi_subdevice *s,
+					   struct comedi_cmd *cmd)
 {
 	const struct pcidas64_board *thisboard = comedi_board(dev);
 
-	if (dev->read_subdev->busy)
+	if (s->busy)
 		return 0;
 	if (thisboard->layout == LAYOUT_4020)
 		return 0;
-	else if (use_internal_queue_6xxx(&dev->read_subdev->async->cmd))
+	else if (use_internal_queue_6xxx(cmd))
 		return 0;
 	return 1;
 }
@@ -3247,7 +3249,7 @@ static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	if (external_ai_queue_in_use(dev)) {
+	if (external_ai_queue_in_use(dev, s, cmd)) {
 		warn_external_queue(dev);
 		return -EBUSY;
 	}

commit 421ab41bce410854363a43afc49e5d95832ef887
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:31:03 2014 -0700

    staging: comedi: cb_pcidas64: use comedi_cmd pointer
    
    Use a local variable to access the comedi_cmd as a pointer instead
    of getting to from the comedi_async pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index aca1e69009a8..63b00cf3bd87 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2723,6 +2723,7 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_async *async = dev->read_subdev->async;
+	struct comedi_cmd *cmd = &async->cmd;
 	uint32_t next_transfer_addr;
 	int j;
 	int num_samples = 0;
@@ -2744,7 +2745,7 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 	      DMA_BUFFER_SIZE) && j < ai_dma_ring_count(thisboard); j++) {
 		/*  transfer data from dma buffer to comedi buffer */
 		num_samples = dma_transfer_size(dev);
-		if (async->cmd.stop_src == TRIG_COUNT) {
+		if (cmd->stop_src == TRIG_COUNT) {
 			if (num_samples > devpriv->ai_count)
 				num_samples = devpriv->ai_count;
 			devpriv->ai_count -= num_samples;

commit e9edef3a5454a19fd0d0c342cc88b6310b871a48
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:09 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_read_n_available()
    
    Change the parameters of `comedi_buf_read_n_available()` to pass a
    pointer to the comedi subdevice instead of a pointer to the "async"
    structure belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 0e13ac9f3473..aca1e69009a8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2893,7 +2893,7 @@ static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 	buffer_index = devpriv->ao_dma_index;
 	prev_buffer_index = prev_ao_dma_index(dev);
 
-	num_bytes = comedi_buf_read_n_available(dev->write_subdev->async);
+	num_bytes = comedi_buf_read_n_available(dev->write_subdev);
 	if (num_bytes > DMA_BUFFER_SIZE)
 		num_bytes = DMA_BUFFER_SIZE;
 	if (cmd->stop_src == TRIG_COUNT && num_bytes > devpriv->ao_count)

commit a5c9c71f8901b4ce61fd858bdcca5a8f2750b296
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 23 15:52:31 2014 -0700

    staging: comedi: cb_pcidas64: remove unnecessary Step 2b test in (*do_cmdtest)
    
    This test is unnecessary. The cfc_check_trigger_src() in Step 1 ensures that
    the trigger source is one of these values and Step 2 makes sure it's only one
    of these values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 4061f0481de2..0e13ac9f3473 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2078,9 +2078,6 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	if (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)
 		err |= -EINVAL;
-	if (cmd->stop_src != TRIG_COUNT &&
-	    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
-		err |= -EINVAL;
 
 	if (err)
 		return 2;

commit 020cb120c1c434f69d1af096ca17b690100b3b07
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:07:58 2014 -0700

    staging: comedi: cb_pcidas64: validate the ai/ao cmd->start_arg
    
    The cmd->start_arg should be trivially validated in Step 3 of the
    (*do_cmdtest) functions. Add the necessary code.
    
    For the analog output, a cmd->start_src of TRIG_NOW and TRIG_INT is
    supported. For both sources the cmd->start_arg is validated to be 0.
    For a TRIG_INT source, the cmd->start_Arg is actually the valid trig_num
    that is passed to the async (*inttrig) callback.
    
    Refactor the (*inttrig) function so that the cmd->start_arg is used to
    check the trig_num instead of the open coded value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 0a2b928bcbe8..4061f0481de2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2087,6 +2087,18 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 3: check if arguments are trivially valid */
 
+	switch (cmd->start_src) {
+	case TRIG_NOW:
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		break;
+	case TRIG_EXT:
+		/*
+		 * start_arg is the CR_CHAN | CR_INVERT of the
+		 * external trigger.
+		 */
+		break;
+	}
+
 	if (cmd->convert_src == TRIG_TIMER) {
 		if (thisboard->layout == LAYOUT_4020) {
 			err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
@@ -3215,7 +3227,7 @@ static int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
 
-	if (trig_num != 0)
+	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
 	retval = prep_ao_dma(dev, cmd);
@@ -3315,6 +3327,8 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 3: check if arguments are trivially valid */
 
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
 						 thisboard->ao_scan_speed);

commit e300e4fb86e46810b9478161101d63ab6f6d3fae
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 16 14:19:11 2014 -0700

    staging: comedi: cb_pcidas64: factor out chanlist checking from (*do_cmdtest)
    
    Step 5 of the (*do_cmdtest) validates that the cmd->chanlist is compatible
    with the hardware.
    
    For aesthetics, factor out the step 5 code for the analog input and analog
    output async command support. Tidy up the factored out code.
    
    To minimize the noise, change the comedi_error(), which is a wrapper around
    dev_err(), to dev_dbg().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index f9afcbe1da54..0a2b928bcbe8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1995,14 +1995,52 @@ static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 	return;
 }
 
+static int cb_pcidas64_ai_check_chanlist(struct comedi_device *dev,
+					 struct comedi_subdevice *s,
+					 struct comedi_cmd *cmd)
+{
+	const struct pcidas64_board *board = comedi_board(dev);
+	unsigned int aref0 = CR_AREF(cmd->chanlist[0]);
+	int i;
+
+	for (i = 1; i < cmd->chanlist_len; i++) {
+		unsigned int aref = CR_AREF(cmd->chanlist[i]);
+
+		if (aref != aref0) {
+			dev_dbg(dev->class_dev,
+				"all elements in chanlist must use the same analog reference\n");
+			return -EINVAL;
+		}
+	}
+
+	if (board->layout == LAYOUT_4020) {
+		unsigned int chan0 = CR_CHAN(cmd->chanlist[0]);
+
+		for (i = 1; i < cmd->chanlist_len; i++) {
+			unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+
+			if (chan != (chan0 + i)) {
+				dev_dbg(dev->class_dev,
+					"chanlist must use consecutive channels\n");
+				return -EINVAL;
+			}
+		}
+		if (cmd->chanlist_len == 3) {
+			dev_dbg(dev->class_dev,
+				"chanlist cannot be 3 channels long, use 1, 2, or 4 channels\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
 	const struct pcidas64_board *thisboard = comedi_board(dev);
 	int err = 0;
 	unsigned int tmp_arg, tmp_arg2;
-	int i;
-	int aref;
 	unsigned int triggers;
 
 	/* Step 1 : check if triggers are trivially valid */
@@ -2098,36 +2136,9 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 4;
 
-	/*  make sure user is doesn't change analog reference mid chanlist */
-	if (cmd->chanlist) {
-		aref = CR_AREF(cmd->chanlist[0]);
-		for (i = 1; i < cmd->chanlist_len; i++) {
-			if (aref != CR_AREF(cmd->chanlist[i])) {
-				comedi_error(dev,
-					     "all elements in chanlist must use the same analog reference");
-				err++;
-				break;
-			}
-		}
-		/*  check 4020 chanlist */
-		if (thisboard->layout == LAYOUT_4020) {
-			unsigned int first_channel = CR_CHAN(cmd->chanlist[0]);
-			for (i = 1; i < cmd->chanlist_len; i++) {
-				if (CR_CHAN(cmd->chanlist[i]) !=
-				    first_channel + i) {
-					comedi_error(dev,
-						     "chanlist must use consecutive channels");
-					err++;
-					break;
-				}
-			}
-			if (cmd->chanlist_len == 3) {
-				comedi_error(dev,
-					     "chanlist cannot be 3 channels long, use 1, 2, or 4 channels");
-				err++;
-			}
-		}
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= cb_pcidas64_ai_check_chanlist(dev, s, cmd);
 
 	if (err)
 		return 5;
@@ -3247,13 +3258,32 @@ static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static int cb_pcidas64_ao_check_chanlist(struct comedi_device *dev,
+					 struct comedi_subdevice *s,
+					 struct comedi_cmd *cmd)
+{
+	unsigned int chan0 = CR_CHAN(cmd->chanlist[0]);
+	int i;
+
+	for (i = 1; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+
+		if (chan != (chan0 + i)) {
+			dev_dbg(dev->class_dev,
+				"chanlist must use consecutive channels\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
 	const struct pcidas64_board *thisboard = comedi_board(dev);
 	int err = 0;
 	unsigned int tmp_arg;
-	int i;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -3315,17 +3345,9 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 4;
 
-	if (cmd->chanlist) {
-		unsigned int first_channel = CR_CHAN(cmd->chanlist[0]);
-		for (i = 1; i < cmd->chanlist_len; i++) {
-			if (CR_CHAN(cmd->chanlist[i]) != first_channel + i) {
-				comedi_error(dev,
-					     "chanlist must use consecutive channels");
-				err++;
-				break;
-			}
-		}
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= cb_pcidas64_ao_check_chanlist(dev, s, cmd);
 
 	if (err)
 		return 5;

commit 22ca19d93d92c79cff68270846a84bd34fe6fb34
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:45 2014 -0700

    staging: comedi: move (*insn_{read, write}) timeout debug messages to core
    
    Have the comedi core display a standard dev_dbg() message when a timeout
    occurs and remove all the driver specific messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 21e13a5cea11..f9afcbe1da54 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1792,10 +1792,8 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 		/*  wait for data */
 		ret = comedi_timeout(dev, s, insn, cb_pcidas64_ai_eoc, 0);
-		if (ret) {
-			comedi_error(dev, " analog input read insn timed out");
+		if (ret)
 			return ret;
-		}
 
 		if (thisboard->layout == LAYOUT_4020)
 			data[n] = readl(devpriv->dio_counter_iobase +

commit 96ed0850fffa361f922b081effe676b637241bee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:16 2014 -0700

    staging: comedi: cb_pcidas64: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input end-of-conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 464c783e566e..21e13a5cea11 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1664,15 +1664,36 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 	i2c_stop(dev);
 }
 
+static int cb_pcidas64_ai_eoc(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned long context)
+{
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+	struct pcidas64_private *devpriv = dev->private;
+	unsigned int status;
+
+	status = readw(devpriv->main_iobase + HW_STATUS_REG);
+	if (thisboard->layout == LAYOUT_4020) {
+		status = readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG);
+		if (status)
+			return 0;
+	} else {
+		if (pipe_full_bits(status))
+			return 0;
+	}
+	return -EBUSY;
+}
+
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
 	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
-	unsigned int bits = 0, n, i;
+	unsigned int bits = 0, n;
 	unsigned int channel, range, aref;
 	unsigned long flags;
-	static const int timeout = 100;
+	int ret;
 
 	channel = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
@@ -1770,23 +1791,12 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		       devpriv->main_iobase + ADC_CONVERT_REG);
 
 		/*  wait for data */
-		for (i = 0; i < timeout; i++) {
-			bits = readw(devpriv->main_iobase + HW_STATUS_REG);
-			if (thisboard->layout == LAYOUT_4020) {
-				if (readw(devpriv->main_iobase +
-					  ADC_WRITE_PNTR_REG))
-					break;
-			} else {
-				if (pipe_full_bits(bits))
-					break;
-			}
-			udelay(1);
-		}
-		if (i == timeout) {
+		ret = comedi_timeout(dev, s, insn, cb_pcidas64_ai_eoc, 0);
+		if (ret) {
 			comedi_error(dev, " analog input read insn timed out");
-			dev_info(dev->class_dev, "status 0x%x\n", bits);
-			return -ETIME;
+			return ret;
 		}
+
 		if (thisboard->layout == LAYOUT_4020)
 			data[n] = readl(devpriv->dio_counter_iobase +
 					ADC_FIFO_REG) & 0xffff;

commit e6439a458aa2805f05dd5fb3da8a95fd90082728
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 3 10:43:25 2014 -0700

    staging: comedi: drivers: propogate errno from subdev_8255_init()
    
    The initialization of the 8255 subdevice can fail due to the allocation
    of the private data. Make sure all callers of subdev_8255_init() propogate
    the errno.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 4fff1738e3f8..464c783e566e 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3816,16 +3816,19 @@ static int setup_subdevices(struct comedi_device *dev)
 	if (thisboard->has_8255) {
 		if (thisboard->layout == LAYOUT_4020) {
 			dio_8255_iobase = devpriv->main_iobase + I8255_4020_REG;
-			subdev_8255_init(dev, s, dio_callback_4020,
-					 (unsigned long)dio_8255_iobase);
+			ret = subdev_8255_init(dev, s, dio_callback_4020,
+					       (unsigned long)dio_8255_iobase);
 		} else {
 			dio_8255_iobase =
 				devpriv->dio_counter_iobase + DIO_8255_OFFSET;
-			subdev_8255_init(dev, s, dio_callback,
-					 (unsigned long)dio_8255_iobase);
+			ret = subdev_8255_init(dev, s, dio_callback,
+					       (unsigned long)dio_8255_iobase);
 		}
-	} else
+		if (ret)
+			return ret;
+	} else {
 		s->type = COMEDI_SUBD_UNUSED;
+	}
 
 	/*  8 channel dio for 60xx */
 	s = &dev->subdevices[5];

commit 82dc1255a71bbde214ed905ed3534dc31ccdd2bd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:31:00 2013 -0700

    staging: comedi: cb_pcidas64: tidy up comedi_lrange tables
    
    Tidy up the whitespace in the comedi_lrange tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 0fcedd050425..4fff1738e3f8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -429,91 +429,85 @@ static inline uint8_t attenuate_bit(unsigned int channel)
 
 /* analog input ranges for 64xx boards */
 static const struct comedi_lrange ai_ranges_64xx = {
-	8,
-	{
-	 BIP_RANGE(10),
-	 BIP_RANGE(5),
-	 BIP_RANGE(2.5),
-	 BIP_RANGE(1.25),
-	 UNI_RANGE(10),
-	 UNI_RANGE(5),
-	 UNI_RANGE(2.5),
-	 UNI_RANGE(1.25)
-	 }
+	8, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25)
+	}
 };
 
 /* analog input ranges for 60xx boards */
 static const struct comedi_lrange ai_ranges_60xx = {
-	4,
-	{
-	 BIP_RANGE(10),
-	 BIP_RANGE(5),
-	 BIP_RANGE(0.5),
-	 BIP_RANGE(0.05),
-	 }
+	4, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(0.5),
+		BIP_RANGE(0.05)
+	}
 };
 
 /* analog input ranges for 6030, etc boards */
 static const struct comedi_lrange ai_ranges_6030 = {
-	14,
-	{
-	 BIP_RANGE(10),
-	 BIP_RANGE(5),
-	 BIP_RANGE(2),
-	 BIP_RANGE(1),
-	 BIP_RANGE(0.5),
-	 BIP_RANGE(0.2),
-	 BIP_RANGE(0.1),
-	 UNI_RANGE(10),
-	 UNI_RANGE(5),
-	 UNI_RANGE(2),
-	 UNI_RANGE(1),
-	 UNI_RANGE(0.5),
-	 UNI_RANGE(0.2),
-	 UNI_RANGE(0.1),
-	 }
+	14, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2),
+		BIP_RANGE(1),
+		BIP_RANGE(0.5),
+		BIP_RANGE(0.2),
+		BIP_RANGE(0.1),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2),
+		UNI_RANGE(1),
+		UNI_RANGE(0.5),
+		UNI_RANGE(0.2),
+		UNI_RANGE(0.1)
+	}
 };
 
 /* analog input ranges for 6052, etc boards */
 static const struct comedi_lrange ai_ranges_6052 = {
-	15,
-	{
-	 BIP_RANGE(10),
-	 BIP_RANGE(5),
-	 BIP_RANGE(2.5),
-	 BIP_RANGE(1),
-	 BIP_RANGE(0.5),
-	 BIP_RANGE(0.25),
-	 BIP_RANGE(0.1),
-	 BIP_RANGE(0.05),
-	 UNI_RANGE(10),
-	 UNI_RANGE(5),
-	 UNI_RANGE(2),
-	 UNI_RANGE(1),
-	 UNI_RANGE(0.5),
-	 UNI_RANGE(0.2),
-	 UNI_RANGE(0.1),
-	 }
+	15, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1),
+		BIP_RANGE(0.5),
+		BIP_RANGE(0.25),
+		BIP_RANGE(0.1),
+		BIP_RANGE(0.05),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2),
+		UNI_RANGE(1),
+		UNI_RANGE(0.5),
+		UNI_RANGE(0.2),
+		UNI_RANGE(0.1)
+	}
 };
 
 /* analog input ranges for 4020 board */
 static const struct comedi_lrange ai_ranges_4020 = {
-	2,
-	{
-	 BIP_RANGE(5),
-	 BIP_RANGE(1),
-	 }
+	2, {
+		BIP_RANGE(5),
+		BIP_RANGE(1)
+	}
 };
 
 /* analog output ranges */
 static const struct comedi_lrange ao_ranges_64xx = {
-	4,
-	{
-	 BIP_RANGE(5),
-	 BIP_RANGE(10),
-	 UNI_RANGE(5),
-	 UNI_RANGE(10),
-	 }
+	4, {
+		BIP_RANGE(5),
+		BIP_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(10)
+	}
 };
 
 static const int ao_range_code_64xx[] = {
@@ -528,11 +522,10 @@ static const int ao_range_code_60xx[] = {
 };
 
 static const struct comedi_lrange ao_ranges_6030 = {
-	2,
-	{
-	 BIP_RANGE(10),
-	 UNI_RANGE(10),
-	 }
+	2, {
+		BIP_RANGE(10),
+		UNI_RANGE(10)
+	}
 };
 
 static const int ao_range_code_6030[] = {
@@ -541,11 +534,10 @@ static const int ao_range_code_6030[] = {
 };
 
 static const struct comedi_lrange ao_ranges_4020 = {
-	2,
-	{
-	 BIP_RANGE(5),
-	 BIP_RANGE(10),
-	 }
+	2, {
+		BIP_RANGE(5),
+		BIP_RANGE(10)
+	}
 };
 
 static const int ao_range_code_4020[] = {

commit 41e043fcfa2236bb2c4a8335eb09f4c8cee224b3
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Dec 3 08:26:00 2013 +0900

    staging: remove DEFINE_PCI_DEVICE_TABLE macro
    
    Don't use DEFINE_PCI_DEVICE_TABLE macro, because this macro
    is not preferred.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index a0053bbb2ede..0fcedd050425 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4041,7 +4041,7 @@ static int cb_pcidas64_pci_probe(struct pci_dev *dev,
 				      id->driver_data);
 }
 
-static DEFINE_PCI_DEVICE_TABLE(cb_pcidas64_pci_table) = {
+static const struct pci_device_id cb_pcidas64_pci_table[] = {
 	{ PCI_VDEVICE(CB, 0x001d), BOARD_PCIDAS6402_16 },
 	{ PCI_VDEVICE(CB, 0x001e), BOARD_PCIDAS6402_12 },
 	{ PCI_VDEVICE(CB, 0x0035), BOARD_PCIDAS64_M1_16 },

commit 220edb916680102048fdc6a2eda980240bda9cac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:18 2013 -0700

    staging: comedi: cb_pcidas64: remove DEBUG_PRINT
    
    The DEBUG_PRINT macro in this driver is used to output development
    debug tracing messages. These messages are just added noise. Remove
    them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index ff5206536be3..a0053bbb2ede 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -94,15 +94,6 @@
 #include "plx9080.h"
 #include "comedi_fc.h"
 
-#undef PCIDAS64_DEBUG		/*  disable debugging code */
-/* #define PCIDAS64_DEBUG         enable debugging code */
-
-#ifdef PCIDAS64_DEBUG
-#define DEBUG_PRINT(format, args...)  pr_debug(format, ## args)
-#else
-#define DEBUG_PRINT(format, args...)  no_printk(format, ## args)
-#endif
-
 #define TIMER_BASE 25		/*  40MHz master clock */
 /* 100kHz 'prescaled' clock for slow acquisition,
  * maybe I'll support this someday */
@@ -1252,8 +1243,6 @@ static void disable_ai_interrupts(struct comedi_device *dev)
 	writew(devpriv->intr_enable_bits,
 	       devpriv->main_iobase + INTR_ENABLE_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	DEBUG_PRINT("intr enable bits 0x%x\n", devpriv->intr_enable_bits);
 }
 
 static void enable_ai_interrupts(struct comedi_device *dev,
@@ -1277,7 +1266,6 @@ static void enable_ai_interrupts(struct comedi_device *dev,
 	devpriv->intr_enable_bits |= bits;
 	writew(devpriv->intr_enable_bits,
 	       devpriv->main_iobase + INTR_ENABLE_REG);
-	DEBUG_PRINT("intr enable bits 0x%x\n", devpriv->intr_enable_bits);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
@@ -1292,38 +1280,6 @@ static void init_plx9080(struct comedi_device *dev)
 	devpriv->plx_control_bits =
 		readl(devpriv->plx9080_iobase + PLX_CONTROL_REG);
 
-	/*  plx9080 dump */
-	DEBUG_PRINT(" plx interrupt status 0x%x\n",
-		    readl(plx_iobase + PLX_INTRCS_REG));
-	DEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));
-	DEBUG_PRINT(" plx control reg 0x%x\n", devpriv->plx_control_bits);
-	DEBUG_PRINT(" plx mode/arbitration reg 0x%x\n",
-		    readl(plx_iobase + PLX_MARB_REG));
-	DEBUG_PRINT(" plx region0 reg 0x%x\n",
-		    readl(plx_iobase + PLX_REGION0_REG));
-	DEBUG_PRINT(" plx region1 reg 0x%x\n",
-		    readl(plx_iobase + PLX_REGION1_REG));
-
-	DEBUG_PRINT(" plx revision 0x%x\n",
-		    readl(plx_iobase + PLX_REVISION_REG));
-	DEBUG_PRINT(" plx dma channel 0 mode 0x%x\n",
-		    readl(plx_iobase + PLX_DMA0_MODE_REG));
-	DEBUG_PRINT(" plx dma channel 1 mode 0x%x\n",
-		    readl(plx_iobase + PLX_DMA1_MODE_REG));
-	DEBUG_PRINT(" plx dma channel 0 pci address 0x%x\n",
-		    readl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));
-	DEBUG_PRINT(" plx dma channel 0 local address 0x%x\n",
-		    readl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));
-	DEBUG_PRINT(" plx dma channel 0 transfer size 0x%x\n",
-		    readl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));
-	DEBUG_PRINT(" plx dma channel 0 descriptor 0x%x\n",
-		    readl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));
-	DEBUG_PRINT(" plx dma channel 0 command status 0x%x\n",
-		    readb(plx_iobase + PLX_DMA0_CS_REG));
-	DEBUG_PRINT(" plx dma channel 0 threshold 0x%x\n",
-		    readl(plx_iobase + PLX_DMA0_THRESHOLD_REG));
-	DEBUG_PRINT(" plx bigend 0x%x\n", readl(plx_iobase + PLX_BIGEND_REG));
-
 #ifdef __BIG_ENDIAN
 	bits = BIGEND_DMA0 | BIGEND_DMA1;
 #else
@@ -1417,9 +1373,6 @@ static int set_ai_fifo_segment_length(struct comedi_device *dev,
 
 	devpriv->ai_fifo_segment_length = num_increments * increment_size;
 
-	DEBUG_PRINT("set hardware fifo segment length to %i\n",
-		    devpriv->ai_fifo_segment_length);
-
 	return devpriv->ai_fifo_segment_length;
 }
 
@@ -1441,8 +1394,6 @@ static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 
 	num_samples = retval * fifo->num_segments * fifo->sample_packing_ratio;
 
-	DEBUG_PRINT("set hardware fifo size to %i\n", num_samples);
-
 	return num_samples;
 }
 
@@ -1538,8 +1489,6 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	if (devpriv->ai_dma_desc == NULL)
 		return -ENOMEM;
 
-	DEBUG_PRINT("ai dma descriptors start at bus addr 0x%llx\n",
-		    (unsigned long long)devpriv->ai_dma_desc_bus_addr);
 	if (ao_cmd_is_supported(thisboard)) {
 		devpriv->ao_dma_desc =
 			pci_alloc_consistent(pcidev,
@@ -1548,9 +1497,6 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 					     &devpriv->ao_dma_desc_bus_addr);
 		if (devpriv->ao_dma_desc == NULL)
 			return -ENOMEM;
-
-		DEBUG_PRINT("ao dma descriptors start at bus addr 0x%llx\n",
-			    (unsigned long long)devpriv->ao_dma_desc_bus_addr);
 	}
 	/*  initialize dma descriptors */
 	for (i = 0; i < ai_dma_ring_count(thisboard); i++) {
@@ -1650,8 +1596,6 @@ static void i2c_write_byte(struct comedi_device *dev, uint8_t byte)
 	uint8_t bit;
 	unsigned int num_bits = 8;
 
-	DEBUG_PRINT("writing to i2c byte 0x%x\n", byte);
-
 	for (bit = 1 << (num_bits - 1); bit; bit >>= 1) {
 		i2c_set_scl(dev, 0);
 		if ((byte & bit))
@@ -1738,7 +1682,6 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned long flags;
 	static const int timeout = 100;
 
-	DEBUG_PRINT("chanspec 0x%x\n", insn->chanspec);
 	channel = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
 	aref = CR_AREF(insn->chanspec);
@@ -1766,7 +1709,6 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (insn->chanspec & CR_ALT_SOURCE) {
 			unsigned int cal_en_bit;
 
-			DEBUG_PRINT("reading calibration source\n");
 			if (thisboard->layout == LAYOUT_60XX)
 				cal_en_bit = CAL_EN_60XX_BIT;
 			else
@@ -1800,7 +1742,6 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 		devpriv->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;
 		if (insn->chanspec & CR_ALT_SOURCE) {
-			DEBUG_PRINT("reading calibration source\n");
 			devpriv->i2c_cal_range_bits |=
 				adc_src_4020_bits(devpriv->calibration_source);
 		} else {	/* select BNC inputs */
@@ -1839,7 +1780,6 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		/*  wait for data */
 		for (i = 0; i < timeout; i++) {
 			bits = readw(devpriv->main_iobase + HW_STATUS_REG);
-			DEBUG_PRINT(" pipe bits 0x%x\n", pipe_full_bits(bits));
 			if (thisboard->layout == LAYOUT_4020) {
 				if (readw(devpriv->main_iobase +
 					  ADC_WRITE_PNTR_REG))
@@ -1850,7 +1790,6 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			}
 			udelay(1);
 		}
-		DEBUG_PRINT(" looped %i times waiting for data\n", i);
 		if (i == timeout) {
 			comedi_error(dev, " analog input read insn timed out");
 			dev_info(dev->class_dev, "status 0x%x\n", bits);
@@ -1884,7 +1823,6 @@ static int ai_config_calibration_source(struct comedi_device *dev,
 		return -EINVAL;
 	}
 
-	DEBUG_PRINT("setting calibration source to %i\n", source);
 	devpriv->calibration_source = source;
 
 	return 2;
@@ -2368,7 +2306,6 @@ static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 	/*  load lower 16 bits of convert interval */
 	writew(convert_counter & 0xffff,
 	       devpriv->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
-	DEBUG_PRINT("convert counter 0x%x\n", convert_counter);
 	/*  load upper 8 bits of convert interval */
 	writew((convert_counter >> 16) & 0xff,
 	       devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
@@ -2378,7 +2315,6 @@ static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 	/*  load upper 8 bits of scan delay */
 	writew((scan_counter >> 16) & 0xff,
 	       devpriv->main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);
-	DEBUG_PRINT("scan counter 0x%x\n", scan_counter);
 }
 
 static int use_internal_queue_6xxx(const struct comedi_cmd *cmd)
@@ -2469,9 +2405,6 @@ static int setup_channel_queue(struct comedi_device *dev,
 				writew(bits,
 				       devpriv->main_iobase +
 				       ADC_QUEUE_FIFO_REG);
-				DEBUG_PRINT(
-					    "wrote 0x%x to external channel queue\n",
-					    bits);
 			}
 			/* doing a queue clear is not specified in board docs,
 			 * but required for reliable operation */
@@ -2593,7 +2526,6 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	writew(devpriv->adc_control1_bits,
 	       devpriv->main_iobase + ADC_CONTROL1_REG);
-	DEBUG_PRINT("control1 bits 0x%x\n", devpriv->adc_control1_bits);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  clear adc buffer */
@@ -2645,17 +2577,14 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (use_hw_sample_counter(cmd))
 		bits |= ADC_SAMPLE_COUNTER_EN_BIT;
 	writew(bits, devpriv->main_iobase + ADC_CONTROL0_REG);
-	DEBUG_PRINT("control0 bits 0x%x\n", bits);
 
 	devpriv->ai_cmd_running = 1;
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  start acquisition */
-	if (cmd->start_src == TRIG_NOW) {
+	if (cmd->start_src == TRIG_NOW)
 		writew(0, devpriv->main_iobase + ADC_START_REG);
-		DEBUG_PRINT("soft trig\n");
-	}
 
 	return 0;
 }
@@ -2690,10 +2619,6 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 		read_segment = adc_upper_read_ptr_code(prepost_bits);
 		write_segment = adc_upper_write_ptr_code(prepost_bits);
 
-		DEBUG_PRINT(" rd seg %i, wrt seg %i, rd idx %i, wrt idx %i\n",
-			    read_segment, write_segment, read_index,
-			    write_index);
-
 		if (read_segment != write_segment)
 			num_samples =
 				devpriv->ai_fifo_segment_length - read_index;
@@ -2715,8 +2640,6 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 			break;
 		}
 
-		DEBUG_PRINT(" read %i samples from fifo\n", num_samples);
-
 		for (i = 0; i < num_samples; i++) {
 			cfc_write_to_buffer(s,
 					    readw(devpriv->main_iobase +
@@ -2812,11 +2735,6 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 					  num_samples * sizeof(uint16_t));
 		devpriv->ai_dma_index = (devpriv->ai_dma_index + 1) %
 					ai_dma_ring_count(thisboard);
-
-		DEBUG_PRINT("next buffer addr 0x%lx\n",
-			    (unsigned long)devpriv->
-			    ai_buffer_bus_addr[devpriv->ai_dma_index]);
-		DEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);
 	}
 	/* XXX check for dma ring buffer overrun
 	 * (use end-of-chain bit to mark last unused buffer) */
@@ -2845,24 +2763,17 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 	if (plx_status & ICS_DMA1_A) {	/*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
 		       devpriv->plx9080_iobase + PLX_DMA1_CS_REG);
-		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
 
 		if (dma1_status & PLX_DMA_EN_BIT)
 			drain_dma_buffers(dev, 1);
-
-		DEBUG_PRINT(" cleared dma ch1 interrupt\n");
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	if (status & ADC_DONE_BIT)
-		DEBUG_PRINT("adc done interrupt\n");
-
 	/*  drain fifo with pio */
 	if ((status & ADC_DONE_BIT) ||
 	    ((cmd->flags & TRIG_WAKE_EOS) &&
 	     (status & ADC_INTR_PENDING_BIT) &&
 	     (thisboard->layout != LAYOUT_4020))) {
-		DEBUG_PRINT("pio fifo drain\n");
 		spin_lock_irqsave(&dev->spinlock, flags);
 		if (devpriv->ai_cmd_running) {
 			spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -2947,7 +2858,6 @@ static void restart_ao_dma(struct comedi_device *dev)
 	dma_desc_bits =
 		readl(devpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 	dma_desc_bits &= ~PLX_END_OF_CHAIN_BIT;
-	DEBUG_PRINT("restarting ao dma, descriptor reg 0x%x\n", dma_desc_bits);
 	load_first_dma_descriptor(dev, 0, dma_desc_bits);
 
 	dma_start_sync(dev, 0);
@@ -2963,10 +2873,6 @@ static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 	buffer_index = devpriv->ao_dma_index;
 	prev_buffer_index = prev_ao_dma_index(dev);
 
-	DEBUG_PRINT("attempting to load ao buffer %i (0x%llx)\n", buffer_index,
-		    (unsigned long long)devpriv->ao_buffer_bus_addr[
-								buffer_index]);
-
 	num_bytes = comedi_buf_read_n_available(dev->write_subdev->async);
 	if (num_bytes > DMA_BUFFER_SIZE)
 		num_bytes = DMA_BUFFER_SIZE;
@@ -2977,8 +2883,6 @@ static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 	if (num_bytes == 0)
 		return 0;
 
-	DEBUG_PRINT("loading %i bytes\n", num_bytes);
-
 	num_bytes = cfc_read_array_from_buffer(dev->write_subdev,
 					       devpriv->
 					       ao_buffer[buffer_index],
@@ -3052,14 +2956,12 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 			writeb(PLX_CLEAR_DMA_INTR_BIT,
 			       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
-		DEBUG_PRINT("dma0 status 0x%x\n", dma0_status);
 		if (dma0_status & PLX_DMA_EN_BIT) {
 			load_ao_dma(dev, cmd);
 			/* try to recover from dma end-of-chain event */
 			if (ao_dma_needs_restart(dev, dma0_status))
 				restart_ao_dma(dev);
 		}
-		DEBUG_PRINT(" cleared dma ch0 interrupt\n");
 	} else {
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
@@ -3068,12 +2970,6 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 		async->events |= COMEDI_CB_EOA;
 		if (ao_stopped_by_error(dev, cmd))
 			async->events |= COMEDI_CB_ERROR;
-		DEBUG_PRINT("plx dma0 desc reg 0x%x\n",
-			    readl(devpriv->plx9080_iobase +
-				  PLX_DMA0_DESCRIPTOR_REG));
-		DEBUG_PRINT("plx dma0 address reg 0x%x\n",
-			    readl(devpriv->plx9080_iobase +
-				  PLX_DMA0_PCI_ADDRESS_REG));
 	}
 	cfc_handle_events(dev, s);
 }
@@ -3089,15 +2985,12 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	plx_status = readl(devpriv->plx9080_iobase + PLX_INTRCS_REG);
 	status = readw(devpriv->main_iobase + HW_STATUS_REG);
 
-	DEBUG_PRINT("hw status 0x%x, plx status 0x%x\n", status, plx_status);
-
 	/* an interrupt before all the postconfig stuff gets done could
 	 * cause a NULL dereference if we continue through the
 	 * interrupt handler */
-	if (!dev->attached) {
-		DEBUG_PRINT("premature interrupt, ignoring\n");
+	if (!dev->attached)
 		return IRQ_HANDLED;
-	}
+
 	handle_ai_interrupt(dev, status, plx_status);
 	handle_ao_interrupt(dev, status, plx_status);
 
@@ -3105,11 +2998,8 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	if (plx_status & ICS_LDIA) {	/*  clear local doorbell interrupt */
 		plx_bits = readl(devpriv->plx9080_iobase + PLX_DBR_OUT_REG);
 		writel(plx_bits, devpriv->plx9080_iobase + PLX_DBR_OUT_REG);
-		DEBUG_PRINT(" cleared local doorbell bits 0x%x\n", plx_bits);
 	}
 
-	DEBUG_PRINT("exiting handler\n");
-
 	return IRQ_HANDLED;
 }
 
@@ -3130,7 +3020,6 @@ static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	abort_dma(dev, 1);
 
-	DEBUG_PRINT("ai canceled\n");
 	return 0;
 }
 
@@ -3458,7 +3347,6 @@ static int dio_callback(int dir, int port, int data, unsigned long arg)
 	void __iomem *iobase = (void __iomem *)arg;
 	if (dir) {
 		writeb(data, iobase + port);
-		DEBUG_PRINT("wrote 0x%x to port %i\n", data, port);
 		return 0;
 	} else {
 		return readb(iobase + port);
@@ -4046,11 +3934,6 @@ static int auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	}
 
-	DEBUG_PRINT(" plx9080 remapped to 0x%p\n", devpriv->plx9080_iobase);
-	DEBUG_PRINT(" main remapped to 0x%p\n", devpriv->main_iobase);
-	DEBUG_PRINT(" diocounter remapped to 0x%p\n",
-		    devpriv->dio_counter_iobase);
-
 	/*  figure out what local addresses are */
 	local_range = readl(devpriv->plx9080_iobase + PLX_LAS0RNG_REG) &
 		      LRNG_MEM_MASK;
@@ -4065,9 +3948,6 @@ static int auto_attach(struct comedi_device *dev,
 	devpriv->local1_iobase = ((uint32_t)devpriv->dio_counter_phys_iobase &
 				  ~local_range) | local_decode;
 
-	DEBUG_PRINT(" local 0 io addr 0x%x\n", devpriv->local0_iobase);
-	DEBUG_PRINT(" local 1 io addr 0x%x\n", devpriv->local1_iobase);
-
 	retval = alloc_and_init_dma_members(dev);
 	if (retval < 0)
 		return retval;

commit 0522063806aabfd498e296e4f3b94b0c93d7c16f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:15 2013 +0100

    staging: comedi: cb_pcidas64: sample types are unsigned
    
    Sample values in comedi are unsigned.  Change the element type of
    `ao_bounce_buffer[]` in `struct pcidas64_private` from `short` to
    `unsigned short` for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index e49743aed65d..ff5206536be3 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1137,7 +1137,7 @@ struct pcidas64_private {
 	volatile short ai_cmd_running;
 	unsigned int ai_fifo_segment_length;
 	struct ext_clock_info ext_clock;
-	short ao_bounce_buffer[DAC_FIFO_SIZE];
+	unsigned short ao_bounce_buffer[DAC_FIFO_SIZE];
 };
 
 static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,

commit 97f4289ad08cffe55de06d4ac4f89ac540450aee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:05:58 2013 -0700

    staging: comedi: drivers: use comedi_dio_update_state() for simple cases
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state for simple cases where the hardware is updated
    when any channel is modified.
    
    Also, fix a bug in the amplc_pc263 and amplc_pci263 drivers where the
    current state is not returned in data[1].
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 388dbd7a5d27..e49743aed65d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3490,18 +3490,15 @@ static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
 	return insn->n;
 }
 
-static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-		    struct comedi_insn *insn, unsigned int *data)
+static int do_wbits(struct comedi_device *dev,
+		    struct comedi_subdevice *s,
+		    struct comedi_insn *insn,
+		    unsigned int *data)
 {
 	struct pcidas64_private *devpriv = dev->private;
 
-	data[0] &= 0xf;
-	/*  zero bits we are going to change */
-	s->state &= ~data[0];
-	/*  set new bits */
-	s->state |= data[0] & data[1];
-
-	writeb(s->state, devpriv->dio_counter_iobase + DO_REG);
+	if (comedi_dio_update_state(s, data))
+		writeb(s->state, devpriv->dio_counter_iobase + DO_REG);
 
 	data[1] = s->state;
 
@@ -3526,14 +3523,14 @@ static int dio_60xx_config_insn(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data)
+static int dio_60xx_wbits(struct comedi_device *dev,
+			  struct comedi_subdevice *s,
+			  struct comedi_insn *insn,
+			  unsigned int *data)
 {
 	struct pcidas64_private *devpriv = dev->private;
 
-	if (data[0]) {
-		s->state &= ~data[0];
-		s->state |= (data[0] & data[1]);
+	if (comedi_dio_update_state(s, data)) {
 		writeb(s->state,
 		       devpriv->dio_counter_iobase + DIO_DATA_60XX_REG);
 	}

commit ddf62f2c7bd041d35095b525ab33e3a3e0829aaa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 6 09:32:33 2013 -0700

    staging: comedi: drivers: use comedi_dio_insn_config() for simple cases
    
    Convert the drivers with simple, per channel programmable i/o, to use the
    comedi_dio_insn_config() helper function.
    
    All of these pass a 'mask' of '0' to comedi_dio_insn_config() this causes
    the per channel mask to be used to configure the i/o direction.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index e6e456163a29..388dbd7a5d27 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3510,31 +3510,20 @@ static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int dio_60xx_config_insn(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	struct pcidas64_private *devpriv = dev->private;
-	unsigned int mask;
-
-	mask = 1 << CR_CHAN(insn->chanspec);
+	int ret;
 
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_INPUT:
-		s->io_bits &= ~mask;
-		break;
-	case INSN_CONFIG_DIO_OUTPUT:
-		s->io_bits |= mask;
-		break;
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
-		return 2;
-	default:
-		return -EINVAL;
-	}
+	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
+	if (ret)
+		return ret;
 
 	writeb(s->io_bits,
 	       devpriv->dio_counter_iobase + DIO_DIRECTION_60XX_REG);
 
-	return 1;
+	return insn->n;
 }
 
 static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index e8222b0fe841..e6e456163a29 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -82,6 +82,7 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 43c0bf58771a..e8222b0fe841 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4034,10 +4034,9 @@ static int auto_attach(struct comedi_device *dev,
 		return -ENODEV;
 	dev->board_ptr = thisboard;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	retval = comedi_pci_enable(dev);
 	if (retval)

commit 588ba6dc5fb4bdca47a3da38c2718fbb82d3eee1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 11 11:32:29 2013 -0700

    staging: comedi: drivers: let core handle freeing s->private
    
    Introduce a new subdevice runflags, SRF_FREE_SPRIV, and a new helper
    function, comedi_set_spriv(), that the drivers can use to set the
    comedi_subdevice private data pointer. The helper function will also
    set SRF_FREE_SPRIV to allow the comedi core to automatically free the
    subdevice private data during the cleanup_device() stage of the detach.
    
    Currently s->private is only allocated by the 8255, addi_watchdog,
    amplc_dio200_common, and ni_65xx drivers. All users of those drivers
    can then have the comedi_spriv_free() calls removed and in many cases
    the (*detach) can then simply be the appropriate comedi core provided
    function.
    
    The ni_65xx driver uses a helper function, ni_65xx_alloc_subdevice_private(),
    to allocate the private data. Refactor the function to return an errno
    or call comedi_set_spriv() instead of returning a pointer to the private
    data and requiring the caller to handle it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 11f8101d851a..43c0bf58771a 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4158,7 +4158,6 @@ static void detach(struct comedi_device *dev)
 					devpriv->ao_dma_desc_bus_addr);
 		}
 	}
-	comedi_spriv_free(dev, 4);
 	comedi_pci_disable(dev);
 }
 

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index c3e5495b4f06..11f8101d851a 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -28,12 +28,7 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-************************************************************************/
+*/
 
 /*
  * Driver: cb_pcidas64

commit 2f69915c728c3be41e12dbbbdd4eeb8d3388d58c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 15 16:41:57 2013 -0700

    staging: comedi: introduce, and use, comedi_spriv_free()
    
    The comedi_subdevice 'private' variable is a void * that is available
    for the subdevice to use in manner. It's common in comedi drivers for
    the driver to allocate memory for a subdevice and store the pointer
    to that memory in the 'private' variable. It's then the responsibility
    of the driver to free that memory when the device is detached.
    
    Due to how the attach/detach works in comedi, the drivers need to do
    some sanity checking before they can free the allocated memory during
    the detach.
    
    Introduce a helper function, comedi_spriv_free(), to handle freeing
    the private data allocated for a subdevice. This allows moving all the
    sanity checks into the helper function and makes it safe to call
    with any context. It also allows removing some of the boilerplate
    code in the (*detach) functions.
    
    Remove the subdev_8255_cleanup() export in the 8255 subdevice driver
    as well as the addi_watchdog_cleanup() export in the addi_watchdog
    driver and use the new helper instead.
    
    The amplc_dio200_common driver uses a number of local helper functions
    to free the private data for it's subdevices. Remove those as well and
    use the new helper.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index cfcde124143d..c3e5495b4f06 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4163,8 +4163,7 @@ static void detach(struct comedi_device *dev)
 					devpriv->ao_dma_desc_bus_addr);
 		}
 	}
-	if (dev->subdevices)
-		subdev_8255_cleanup(dev, &dev->subdevices[4]);
+	comedi_spriv_free(dev, 4);
 	comedi_pci_disable(dev);
 }
 

commit 81d985a11e9a51eb88ddea98df8d60bfdda7cafb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 10 11:28:47 2013 -0700

    staging: comedi: cb_pcidas64: tidy up the *phys_iobase
    
    This driver does not use the dev->iobase so don't bother initializing
    it.
    
    The plx9080_phys_iobase is not used in the driver. Remove it from the
    private data.
    
    Tidy up the initialization of the other phy_iobase variables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 7599053df807..cfcde124143d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1080,7 +1080,6 @@ struct ext_clock_info {
 /* this structure is for data unique to this hardware driver. */
 struct pcidas64_private {
 	/*  base addresses (physical) */
-	resource_size_t plx9080_phys_iobase;
 	resource_size_t main_phys_iobase;
 	resource_size_t dio_counter_phys_iobase;
 	/*  base addresses (ioremapped) */
@@ -4053,13 +4052,8 @@ static int auto_attach(struct comedi_device *dev,
 	/* Initialize dev->board_name */
 	dev->board_name = thisboard->name;
 
-	dev->iobase = pci_resource_start(pcidev, 2);
-
-	devpriv->plx9080_phys_iobase =
-		pci_resource_start(pcidev, 0);
-	devpriv->main_phys_iobase = dev->iobase;
-	devpriv->dio_counter_phys_iobase =
-		pci_resource_start(pcidev, 3);
+	devpriv->main_phys_iobase = pci_resource_start(pcidev, 2);
+	devpriv->dio_counter_phys_iobase = pci_resource_start(pcidev, 3);
 
 	devpriv->plx9080_iobase = pci_ioremap_bar(pcidev, 0);
 	devpriv->main_iobase = pci_ioremap_bar(pcidev, 2);

commit c71b2e52a0fb895ad709dbe8caec3dfd2a612c04
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 10 11:28:28 2013 -0700

    staging: comedi: cb_pcidas64: use pci_ioremap_bar()
    
    Use pci_ioremap_bar() to ioremap the PCI resources. That function
    just takes the pci device and a bar number. It also has some
    additional sanity checks to make sure the bar is actually a
    memory resource.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index de5c8faa91d8..7599053df807 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4061,16 +4061,9 @@ static int auto_attach(struct comedi_device *dev,
 	devpriv->dio_counter_phys_iobase =
 		pci_resource_start(pcidev, 3);
 
-	/*  remap, won't work with 2.0 kernels but who cares */
-	devpriv->plx9080_iobase =
-		ioremap(devpriv->plx9080_phys_iobase,
-			pci_resource_len(pcidev, 0));
-	devpriv->main_iobase =
-		ioremap(devpriv->main_phys_iobase,
-			pci_resource_len(pcidev, 2));
-	devpriv->dio_counter_iobase =
-		ioremap(devpriv->dio_counter_phys_iobase,
-			pci_resource_len(pcidev, 3));
+	devpriv->plx9080_iobase = pci_ioremap_bar(pcidev, 0);
+	devpriv->main_iobase = pci_ioremap_bar(pcidev, 2);
+	devpriv->dio_counter_iobase = pci_ioremap_bar(pcidev, 3);
 
 	if (!devpriv->plx9080_iobase || !devpriv->main_iobase
 	    || !devpriv->dio_counter_iobase) {

commit 8b46d7da7f5e869a39b81c3d2193e88b1b52fc99
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 10 11:28:10 2013 -0700

    staging: comedi: cb_pcidas64: remove the base_address_regions enum
    
    This enum is only used in the ioremap of the PCI resources and it
    doesn't really help make the code any clearer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 584fdffa7b61..de5c8faa91d8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -118,13 +118,6 @@ static const int max_counter_value = 0xffffff;
 
 /* PCI-DAS64xxx base addresses */
 
-/* indices of base address regions */
-enum base_address_regions {
-	PLX9080_BADDRINDEX = 0,
-	MAIN_BADDRINDEX = 2,
-	DIO_COUNTER_BADDRINDEX = 3,
-};
-
 /* devpriv->main_iobase registers */
 enum write_only_registers {
 	INTR_ENABLE_REG = 0x0,	/*  interrupt enable register */
@@ -4060,24 +4053,24 @@ static int auto_attach(struct comedi_device *dev,
 	/* Initialize dev->board_name */
 	dev->board_name = thisboard->name;
 
-	dev->iobase = pci_resource_start(pcidev, MAIN_BADDRINDEX);
+	dev->iobase = pci_resource_start(pcidev, 2);
 
 	devpriv->plx9080_phys_iobase =
-		pci_resource_start(pcidev, PLX9080_BADDRINDEX);
+		pci_resource_start(pcidev, 0);
 	devpriv->main_phys_iobase = dev->iobase;
 	devpriv->dio_counter_phys_iobase =
-		pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
+		pci_resource_start(pcidev, 3);
 
 	/*  remap, won't work with 2.0 kernels but who cares */
 	devpriv->plx9080_iobase =
 		ioremap(devpriv->plx9080_phys_iobase,
-			pci_resource_len(pcidev, PLX9080_BADDRINDEX));
+			pci_resource_len(pcidev, 0));
 	devpriv->main_iobase =
 		ioremap(devpriv->main_phys_iobase,
-			pci_resource_len(pcidev, MAIN_BADDRINDEX));
+			pci_resource_len(pcidev, 2));
 	devpriv->dio_counter_iobase =
 		ioremap(devpriv->dio_counter_phys_iobase,
-			pci_resource_len(pcidev, DIO_COUNTER_BADDRINDEX));
+			pci_resource_len(pcidev, 3));
 
 	if (!devpriv->plx9080_iobase || !devpriv->main_iobase
 	    || !devpriv->dio_counter_iobase) {

commit 7cf24bb433914c41e619ad0701d3601c0ef5eb49
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 3 13:36:26 2013 -0700

    staging: comedi: cb_pcidas64: use comedi provided range_bipolar10
    
    Remove the private range, ao_ranges_60xx, in this driver and use
    the comedi provided range_bipolar10 instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 6988f5b7fd70..584fdffa7b61 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -543,13 +543,6 @@ static const int ao_range_code_64xx[] = {
 	0x3,
 };
 
-static const struct comedi_lrange ao_ranges_60xx = {
-	1,
-	{
-	 BIP_RANGE(10),
-	 }
-};
-
 static const int ao_range_code_60xx[] = {
 	0x0,
 };
@@ -762,7 +755,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_bits	= 16,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
-		.ao_range_table	= &ao_ranges_60xx,
+		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
 		.has_8255	= 0,
@@ -777,7 +770,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
-		.ao_range_table	= &ao_ranges_60xx,
+		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
 		.has_8255	= 0,
@@ -791,7 +784,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
-		.ao_range_table	= &ao_ranges_60xx,
+		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
 		.has_8255	= 1,
@@ -806,7 +799,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
-		.ao_range_table	= &ao_ranges_60xx,
+		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
 		.has_8255	= 1,
@@ -885,7 +878,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
-		.ao_range_table	= &ao_ranges_60xx,
+		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
 		.has_8255	= 0,
@@ -900,7 +893,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.ao_scan_speed	= 100000,
 		.layout		= LAYOUT_60XX,
 		.ai_range_table	= &ai_ranges_60xx,
-		.ao_range_table	= &ao_ranges_60xx,
+		.ao_range_table	= &range_bipolar10,
 		.ao_range_code	= ao_range_code_60xx,
 		.ai_fifo	= &ai_fifo_60xx,
 		.has_8255	= 0,

commit a7401cddcdf739d3cb9598c9b3787a732fc87809
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:33 2013 +0000

    staging: comedi: make 'dev->attached' a bool bit-field
    
    Change the `attached` member of `struct comedi_device` to a 1-bit
    bit-field of type `bool`.  Change assigned values to `true` and `false`
    and replace or remove comparison operations with simple boolean tests.
    
    We'll put some extra bit-fields in the gap later to save space.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 46b6af4c517d..6988f5b7fd70 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3113,7 +3113,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	/* an interrupt before all the postconfig stuff gets done could
 	 * cause a NULL dereference if we continue through the
 	 * interrupt handler */
-	if (dev->attached == 0) {
+	if (!dev->attached) {
 		DEBUG_PRINT("premature interrupt, ignoring\n");
 		return IRQ_HANDLED;
 	}

commit 818f569fe930c5b8a05d1a44ece3c63c99c13c88
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:36:31 2013 -0700

    staging: comedi_pci: pass comedi_device to comedi_pci_enable()
    
    Make comedi_pci_enable() use the same parameter type as
    comedi_pci_disable(). This also allows comedi_pci_enable
    to automatically determine the resource name passed to
    pci_request_regions().
    
    Make sure the errno value returned is passed on instead of
    assuming an errno. Also, remove any kernel noise that is
    generated when the call fails.
    
    The National Instruments drivers that use the mite module
    currently enable the PCI device in the mite module. For
    those drivers move the call to comedi_pci_enable into the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 15a97212b158..46b6af4c517d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4059,11 +4059,9 @@ static int auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
-		dev_warn(dev->class_dev,
-			 "failed to enable PCI device and request regions\n");
-		return -EIO;
-	}
+	retval = comedi_pci_enable(dev);
+	if (retval)
+		return retval;
 	pci_set_master(pcidev);
 
 	/* Initialize dev->board_name */

commit 7f072f54ae5dc9965cbe450419b1389d13e2b849
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:35:51 2013 -0700

    staging: comedi_pci: make comedi_pci_disable() safe to call
    
    Currently all the comedi PCI drivers need to do some checking in
    their (*detach) before calling comedi_pci_disable() in order to
    make sure the PCI device has actually be enabled.
    
    Change the parameter passed to comedi_pci_disable() from a struct
    pci_dev pointer to a comedi_device pointer and have comedi_pci_disable()
    handle all the checking.
    
    For most comedi PCI drivers this also allows removing the local
    variable holding the pointer to the pci_dev. For some of the drivers
    comedi_pci_disable can now be used directly as the (*detach) function.
    
    The National Instruments drivers that use the mite module currently
    enable/disable the PCI device in the mite module. For those drivers
    move the call to comedi_pci_disable into the driver and make sure
    dev->iobase is set to a non-zero value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index e61cf71d46ef..15a97212b158 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4194,10 +4194,7 @@ static void detach(struct comedi_device *dev)
 	}
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, &dev->subdevices[4]);
-	if (pcidev) {
-		if (dev->iobase)
-			comedi_pci_disable(pcidev);
-	}
+	comedi_pci_disable(dev);
 }
 
 static struct comedi_driver cb_pcidas64_driver = {

commit 20ce161d2f53af092fe8dabfef6fb0d7af846c43
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Thu Mar 7 23:48:40 2013 +0900

    staging: comedi: Fix typo in comedi
    
    Correct spelling typos in staging/comedi
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index fe58c9c6fb33..e61cf71d46ef 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1529,7 +1529,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	struct pcidas64_private *devpriv = dev->private;
 	int i;
 
-	/*  alocate pci dma buffers */
+	/*  allocate pci dma buffers */
 	for (i = 0; i < ai_dma_ring_count(thisboard); i++) {
 		devpriv->ai_buffer[i] =
 			pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,

commit 2ccdb96442fb94342eedb9dbc7a7a180e05dbde7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 10:00:59 2013 -0700

    staging: comedi: cb_pcidas64: cleanup the boardinfo
    
    For aesthetic reasons, add some whitespace to the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index d0d6ed402474..fe58c9c6fb33 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -679,396 +679,396 @@ static const int bytes_in_sample = 2;
 
 static const struct pcidas64_board pcidas64_boards[] = {
 	[BOARD_PCIDAS6402_16] = {
-	 .name = "pci-das6402/16",
-	 .ai_se_chans = 64,
-	 .ai_bits = 16,
-	 .ai_speed = 5000,
-	 .ao_nchan = 2,
-	 .ao_bits = 16,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_64XX,
-	 .ai_range_table = &ai_ranges_64xx,
-	 .ao_range_table = &ao_ranges_64xx,
-	 .ao_range_code = ao_range_code_64xx,
-	 .ai_fifo = &ai_fifo_64xx,
-	 .has_8255 = 1,
-	 },
+		.name		= "pci-das6402/16",
+		.ai_se_chans	= 64,
+		.ai_bits	= 16,
+		.ai_speed	= 5000,
+		.ao_nchan	= 2,
+		.ao_bits	= 16,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_64XX,
+		.ai_range_table	= &ai_ranges_64xx,
+		.ao_range_table	= &ao_ranges_64xx,
+		.ao_range_code	= ao_range_code_64xx,
+		.ai_fifo	= &ai_fifo_64xx,
+		.has_8255	= 1,
+	},
 	[BOARD_PCIDAS6402_12] = {
-	 .name = "pci-das6402/12",	/*  XXX check */
-	 .ai_se_chans = 64,
-	 .ai_bits = 12,
-	 .ai_speed = 5000,
-	 .ao_nchan = 2,
-	 .ao_bits = 12,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_64XX,
-	 .ai_range_table = &ai_ranges_64xx,
-	 .ao_range_table = &ao_ranges_64xx,
-	 .ao_range_code = ao_range_code_64xx,
-	 .ai_fifo = &ai_fifo_64xx,
-	 .has_8255 = 1,
-	 },
+		.name		= "pci-das6402/12",	/*  XXX check */
+		.ai_se_chans	= 64,
+		.ai_bits	= 12,
+		.ai_speed	= 5000,
+		.ao_nchan	= 2,
+		.ao_bits	= 12,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_64XX,
+		.ai_range_table	= &ai_ranges_64xx,
+		.ao_range_table	= &ao_ranges_64xx,
+		.ao_range_code	= ao_range_code_64xx,
+		.ai_fifo	= &ai_fifo_64xx,
+		.has_8255	= 1,
+	},
 	[BOARD_PCIDAS64_M1_16] = {
-	 .name = "pci-das64/m1/16",
-	 .ai_se_chans = 64,
-	 .ai_bits = 16,
-	 .ai_speed = 1000,
-	 .ao_nchan = 2,
-	 .ao_bits = 16,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_64XX,
-	 .ai_range_table = &ai_ranges_64xx,
-	 .ao_range_table = &ao_ranges_64xx,
-	 .ao_range_code = ao_range_code_64xx,
-	 .ai_fifo = &ai_fifo_64xx,
-	 .has_8255 = 1,
-	 },
+		.name		= "pci-das64/m1/16",
+		.ai_se_chans	= 64,
+		.ai_bits	= 16,
+		.ai_speed	= 1000,
+		.ao_nchan	= 2,
+		.ao_bits	= 16,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_64XX,
+		.ai_range_table	= &ai_ranges_64xx,
+		.ao_range_table	= &ao_ranges_64xx,
+		.ao_range_code	= ao_range_code_64xx,
+		.ai_fifo	= &ai_fifo_64xx,
+		.has_8255	= 1,
+	},
 	[BOARD_PCIDAS64_M2_16] = {
-	 .name = "pci-das64/m2/16",
-	 .ai_se_chans = 64,
-	 .ai_bits = 16,
-	 .ai_speed = 500,
-	 .ao_nchan = 2,
-	 .ao_bits = 16,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_64XX,
-	 .ai_range_table = &ai_ranges_64xx,
-	 .ao_range_table = &ao_ranges_64xx,
-	 .ao_range_code = ao_range_code_64xx,
-	 .ai_fifo = &ai_fifo_64xx,
-	 .has_8255 = 1,
-	 },
+		.name = "pci-das64/m2/16",
+		.ai_se_chans	= 64,
+		.ai_bits	= 16,
+		.ai_speed	= 500,
+		.ao_nchan	= 2,
+		.ao_bits	= 16,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_64XX,
+		.ai_range_table	= &ai_ranges_64xx,
+		.ao_range_table	= &ao_ranges_64xx,
+		.ao_range_code	= ao_range_code_64xx,
+		.ai_fifo	= &ai_fifo_64xx,
+		.has_8255	= 1,
+	},
 	[BOARD_PCIDAS64_M3_16] = {
-	 .name = "pci-das64/m3/16",
-	 .ai_se_chans = 64,
-	 .ai_bits = 16,
-	 .ai_speed = 333,
-	 .ao_nchan = 2,
-	 .ao_bits = 16,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_64XX,
-	 .ai_range_table = &ai_ranges_64xx,
-	 .ao_range_table = &ao_ranges_64xx,
-	 .ao_range_code = ao_range_code_64xx,
-	 .ai_fifo = &ai_fifo_64xx,
-	 .has_8255 = 1,
-	 },
+		.name		= "pci-das64/m3/16",
+		.ai_se_chans	= 64,
+		.ai_bits	= 16,
+		.ai_speed	= 333,
+		.ao_nchan	= 2,
+		.ao_bits	= 16,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_64XX,
+		.ai_range_table	= &ai_ranges_64xx,
+		.ao_range_table	= &ao_ranges_64xx,
+		.ao_range_code	= ao_range_code_64xx,
+		.ai_fifo	= &ai_fifo_64xx,
+		.has_8255	= 1,
+	},
 	[BOARD_PCIDAS6013] = {
-	 .name = "pci-das6013",
-	 .ai_se_chans = 16,
-	 .ai_bits = 16,
-	 .ai_speed = 5000,
-	 .ao_nchan = 0,
-	 .ao_bits = 16,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_60xx,
-	 .ao_range_table = &ao_ranges_60xx,
-	 .ao_range_code = ao_range_code_60xx,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 0,
-	 },
+		.name		= "pci-das6013",
+		.ai_se_chans	= 16,
+		.ai_bits	= 16,
+		.ai_speed	= 5000,
+		.ao_nchan	= 0,
+		.ao_bits	= 16,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_60xx,
+		.ao_range_table	= &ao_ranges_60xx,
+		.ao_range_code	= ao_range_code_60xx,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 0,
+	},
 	[BOARD_PCIDAS6014] = {
-	 .name = "pci-das6014",
-	 .ai_se_chans = 16,
-	 .ai_bits = 16,
-	 .ai_speed = 5000,
-	 .ao_nchan = 2,
-	 .ao_bits = 16,
-	 .ao_scan_speed = 100000,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_60xx,
-	 .ao_range_table = &ao_ranges_60xx,
-	 .ao_range_code = ao_range_code_60xx,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 0,
-	 },
+		.name		= "pci-das6014",
+		.ai_se_chans	= 16,
+		.ai_bits	= 16,
+		.ai_speed	= 5000,
+		.ao_nchan	= 2,
+		.ao_bits	= 16,
+		.ao_scan_speed	= 100000,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_60xx,
+		.ao_range_table	= &ao_ranges_60xx,
+		.ao_range_code	= ao_range_code_60xx,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 0,
+	},
 	[BOARD_PCIDAS6023] = {
-	 .name = "pci-das6023",
-	 .ai_se_chans = 16,
-	 .ai_bits = 12,
-	 .ai_speed = 5000,
-	 .ao_nchan = 0,
-	 .ao_scan_speed = 100000,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_60xx,
-	 .ao_range_table = &ao_ranges_60xx,
-	 .ao_range_code = ao_range_code_60xx,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 1,
-	 },
+		.name		= "pci-das6023",
+		.ai_se_chans	= 16,
+		.ai_bits	= 12,
+		.ai_speed	= 5000,
+		.ao_nchan	= 0,
+		.ao_scan_speed	= 100000,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_60xx,
+		.ao_range_table	= &ao_ranges_60xx,
+		.ao_range_code	= ao_range_code_60xx,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 1,
+	},
 	[BOARD_PCIDAS6025] = {
-	 .name = "pci-das6025",
-	 .ai_se_chans = 16,
-	 .ai_bits = 12,
-	 .ai_speed = 5000,
-	 .ao_nchan = 2,
-	 .ao_bits = 12,
-	 .ao_scan_speed = 100000,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_60xx,
-	 .ao_range_table = &ao_ranges_60xx,
-	 .ao_range_code = ao_range_code_60xx,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 1,
-	 },
+		.name		= "pci-das6025",
+		.ai_se_chans	= 16,
+		.ai_bits	= 12,
+		.ai_speed	= 5000,
+		.ao_nchan	= 2,
+		.ao_bits	= 12,
+		.ao_scan_speed	= 100000,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_60xx,
+		.ao_range_table	= &ao_ranges_60xx,
+		.ao_range_code	= ao_range_code_60xx,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 1,
+	},
 	[BOARD_PCIDAS6030] = {
-	 .name = "pci-das6030",
-	 .ai_se_chans = 16,
-	 .ai_bits = 16,
-	 .ai_speed = 10000,
-	 .ao_nchan = 2,
-	 .ao_bits = 16,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_6030,
-	 .ao_range_table = &ao_ranges_6030,
-	 .ao_range_code = ao_range_code_6030,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 0,
-	 },
+		.name		= "pci-das6030",
+		.ai_se_chans	= 16,
+		.ai_bits	= 16,
+		.ai_speed	= 10000,
+		.ao_nchan	= 2,
+		.ao_bits	= 16,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_6030,
+		.ao_range_table	= &ao_ranges_6030,
+		.ao_range_code	= ao_range_code_6030,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 0,
+	},
 	[BOARD_PCIDAS6031] = {
-	 .name = "pci-das6031",
-	 .ai_se_chans = 64,
-	 .ai_bits = 16,
-	 .ai_speed = 10000,
-	 .ao_nchan = 2,
-	 .ao_bits = 16,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_6030,
-	 .ao_range_table = &ao_ranges_6030,
-	 .ao_range_code = ao_range_code_6030,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 0,
-	 },
+		.name		= "pci-das6031",
+		.ai_se_chans	= 64,
+		.ai_bits	= 16,
+		.ai_speed	= 10000,
+		.ao_nchan	= 2,
+		.ao_bits	= 16,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_6030,
+		.ao_range_table	= &ao_ranges_6030,
+		.ao_range_code	= ao_range_code_6030,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 0,
+	},
 	[BOARD_PCIDAS6032] = {
-	 .name = "pci-das6032",
-	 .ai_se_chans = 16,
-	 .ai_bits = 16,
-	 .ai_speed = 10000,
-	 .ao_nchan = 0,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_6030,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 0,
-	 },
+		.name		= "pci-das6032",
+		.ai_se_chans	= 16,
+		.ai_bits	= 16,
+		.ai_speed	= 10000,
+		.ao_nchan	= 0,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_6030,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 0,
+	},
 	[BOARD_PCIDAS6033] = {
-	 .name = "pci-das6033",
-	 .ai_se_chans = 64,
-	 .ai_bits = 16,
-	 .ai_speed = 10000,
-	 .ao_nchan = 0,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_6030,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 0,
-	 },
+		.name		= "pci-das6033",
+		.ai_se_chans	= 64,
+		.ai_bits	= 16,
+		.ai_speed	= 10000,
+		.ao_nchan	= 0,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_6030,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 0,
+	},
 	[BOARD_PCIDAS6034] = {
-	 .name = "pci-das6034",
-	 .ai_se_chans = 16,
-	 .ai_bits = 16,
-	 .ai_speed = 5000,
-	 .ao_nchan = 0,
-	 .ao_scan_speed = 0,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_60xx,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 0,
-	 },
+		.name		= "pci-das6034",
+		.ai_se_chans	= 16,
+		.ai_bits	= 16,
+		.ai_speed	= 5000,
+		.ao_nchan	= 0,
+		.ao_scan_speed	= 0,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_60xx,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 0,
+	},
 	[BOARD_PCIDAS6035] = {
-	 .name = "pci-das6035",
-	 .ai_se_chans = 16,
-	 .ai_bits = 16,
-	 .ai_speed = 5000,
-	 .ao_nchan = 2,
-	 .ao_bits = 12,
-	 .ao_scan_speed = 100000,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_60xx,
-	 .ao_range_table = &ao_ranges_60xx,
-	 .ao_range_code = ao_range_code_60xx,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 0,
-	 },
+		.name		= "pci-das6035",
+		.ai_se_chans	= 16,
+		.ai_bits	= 16,
+		.ai_speed	= 5000,
+		.ao_nchan	= 2,
+		.ao_bits	= 12,
+		.ao_scan_speed	= 100000,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_60xx,
+		.ao_range_table	= &ao_ranges_60xx,
+		.ao_range_code	= ao_range_code_60xx,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 0,
+	},
 	[BOARD_PCIDAS6036] = {
-	 .name = "pci-das6036",
-	 .ai_se_chans = 16,
-	 .ai_bits = 16,
-	 .ai_speed = 5000,
-	 .ao_nchan = 2,
-	 .ao_bits = 16,
-	 .ao_scan_speed = 100000,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_60xx,
-	 .ao_range_table = &ao_ranges_60xx,
-	 .ao_range_code = ao_range_code_60xx,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 0,
-	 },
+		.name		= "pci-das6036",
+		.ai_se_chans	= 16,
+		.ai_bits	= 16,
+		.ai_speed	= 5000,
+		.ao_nchan	= 2,
+		.ao_bits	= 16,
+		.ao_scan_speed	= 100000,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_60xx,
+		.ao_range_table	= &ao_ranges_60xx,
+		.ao_range_code	= ao_range_code_60xx,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 0,
+	},
 	[BOARD_PCIDAS6040] = {
-	 .name = "pci-das6040",
-	 .ai_se_chans = 16,
-	 .ai_bits = 12,
-	 .ai_speed = 2000,
-	 .ao_nchan = 2,
-	 .ao_bits = 12,
-	 .ao_scan_speed = 1000,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_6052,
-	 .ao_range_table = &ao_ranges_6030,
-	 .ao_range_code = ao_range_code_6030,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 0,
-	 },
+		.name		= "pci-das6040",
+		.ai_se_chans	= 16,
+		.ai_bits	= 12,
+		.ai_speed	= 2000,
+		.ao_nchan	= 2,
+		.ao_bits	= 12,
+		.ao_scan_speed	= 1000,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_6052,
+		.ao_range_table	= &ao_ranges_6030,
+		.ao_range_code	= ao_range_code_6030,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 0,
+	},
 	[BOARD_PCIDAS6052] = {
-	 .name = "pci-das6052",
-	 .ai_se_chans = 16,
-	 .ai_bits = 16,
-	 .ai_speed = 3333,
-	 .ao_nchan = 2,
-	 .ao_bits = 16,
-	 .ao_scan_speed = 3333,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_6052,
-	 .ao_range_table = &ao_ranges_6030,
-	 .ao_range_code = ao_range_code_6030,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 0,
-	 },
+		.name		= "pci-das6052",
+		.ai_se_chans	= 16,
+		.ai_bits	= 16,
+		.ai_speed	= 3333,
+		.ao_nchan	= 2,
+		.ao_bits	= 16,
+		.ao_scan_speed	= 3333,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_6052,
+		.ao_range_table	= &ao_ranges_6030,
+		.ao_range_code	= ao_range_code_6030,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 0,
+	},
 	[BOARD_PCIDAS6070] = {
-	 .name = "pci-das6070",
-	 .ai_se_chans = 16,
-	 .ai_bits = 12,
-	 .ai_speed = 800,
-	 .ao_nchan = 2,
-	 .ao_bits = 12,
-	 .ao_scan_speed = 1000,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_6052,
-	 .ao_range_table = &ao_ranges_6030,
-	 .ao_range_code = ao_range_code_6030,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 0,
-	 },
+		.name		= "pci-das6070",
+		.ai_se_chans	= 16,
+		.ai_bits	= 12,
+		.ai_speed	= 800,
+		.ao_nchan	= 2,
+		.ao_bits	= 12,
+		.ao_scan_speed	= 1000,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_6052,
+		.ao_range_table	= &ao_ranges_6030,
+		.ao_range_code	= ao_range_code_6030,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 0,
+	},
 	[BOARD_PCIDAS6071] = {
-	 .name = "pci-das6071",
-	 .ai_se_chans = 64,
-	 .ai_bits = 12,
-	 .ai_speed = 800,
-	 .ao_nchan = 2,
-	 .ao_bits = 12,
-	 .ao_scan_speed = 1000,
-	 .layout = LAYOUT_60XX,
-	 .ai_range_table = &ai_ranges_6052,
-	 .ao_range_table = &ao_ranges_6030,
-	 .ao_range_code = ao_range_code_6030,
-	 .ai_fifo = &ai_fifo_60xx,
-	 .has_8255 = 0,
-	 },
+		.name		= "pci-das6071",
+		.ai_se_chans	= 64,
+		.ai_bits	= 12,
+		.ai_speed	= 800,
+		.ao_nchan	= 2,
+		.ao_bits	= 12,
+		.ao_scan_speed	= 1000,
+		.layout		= LAYOUT_60XX,
+		.ai_range_table	= &ai_ranges_6052,
+		.ao_range_table	= &ao_ranges_6030,
+		.ao_range_code	= ao_range_code_6030,
+		.ai_fifo	= &ai_fifo_60xx,
+		.has_8255	= 0,
+	},
 	[BOARD_PCIDAS4020_12] = {
-	 .name = "pci-das4020/12",
-	 .ai_se_chans = 4,
-	 .ai_bits = 12,
-	 .ai_speed = 50,
-	 .ao_bits = 12,
-	 .ao_nchan = 2,
-	 .ao_scan_speed = 0,	/*  no hardware pacing on ao */
-	 .layout = LAYOUT_4020,
-	 .ai_range_table = &ai_ranges_4020,
-	 .ao_range_table = &ao_ranges_4020,
-	 .ao_range_code = ao_range_code_4020,
-	 .ai_fifo = &ai_fifo_4020,
-	 .has_8255 = 1,
-	 },
+		.name		= "pci-das4020/12",
+		.ai_se_chans	= 4,
+		.ai_bits	= 12,
+		.ai_speed	= 50,
+		.ao_bits	= 12,
+		.ao_nchan	= 2,
+		.ao_scan_speed	= 0,	/*  no hardware pacing on ao */
+		.layout		= LAYOUT_4020,
+		.ai_range_table	= &ai_ranges_4020,
+		.ao_range_table	= &ao_ranges_4020,
+		.ao_range_code	= ao_range_code_4020,
+		.ai_fifo	= &ai_fifo_4020,
+		.has_8255	= 1,
+	},
 #if 0
 	/*
 	 * The device id for these boards is unknown
 	 */
 
 	[BOARD_PCIDAS6402_16_JR] = {
-	 .name = "pci-das6402/16/jr",
-	 .ai_se_chans = 64,
-	 .ai_bits = 16,
-	 .ai_speed = 5000,
-	 .ao_nchan = 0,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_64XX,
-	 .ai_range_table = &ai_ranges_64xx,
-	 .ai_fifo = ai_fifo_64xx,
-	 .has_8255 = 1,
-	 },
+		.name		= "pci-das6402/16/jr",
+		.ai_se_chans	= 64,
+		.ai_bits	= 16,
+		.ai_speed	= 5000,
+		.ao_nchan	= 0,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_64XX,
+		.ai_range_table	= &ai_ranges_64xx,
+		.ai_fifo	= ai_fifo_64xx,
+		.has_8255	= 1,
+	},
 	[BOARD_PCIDAS64_M1_16_JR] = {
-	 .name = "pci-das64/m1/16/jr",
-	 .ai_se_chans = 64,
-	 .ai_bits = 16,
-	 .ai_speed = 1000,
-	 .ao_nchan = 0,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_64XX,
-	 .ai_range_table = &ai_ranges_64xx,
-	 .ai_fifo = ai_fifo_64xx,
-	 .has_8255 = 1,
-	 },
+		.name		= "pci-das64/m1/16/jr",
+		.ai_se_chans	= 64,
+		.ai_bits	= 16,
+		.ai_speed	= 1000,
+		.ao_nchan	= 0,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_64XX,
+		.ai_range_table	= &ai_ranges_64xx,
+		.ai_fifo	= ai_fifo_64xx,
+		.has_8255	= 1,
+	},
 	[BOARD_PCIDAS64_M2_16_JR] = {
-	 .name = "pci-das64/m2/16/jr",
-	 .ai_se_chans = 64,
-	 .ai_bits = 16,
-	 .ai_speed = 500,
-	 .ao_nchan = 0,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_64XX,
-	 .ai_range_table = &ai_ranges_64xx,
-	 .ai_fifo = ai_fifo_64xx,
-	 .has_8255 = 1,
-	 },
+		.name = "pci-das64/m2/16/jr",
+		.ai_se_chans	= 64,
+		.ai_bits	= 16,
+		.ai_speed	= 500,
+		.ao_nchan	= 0,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_64XX,
+		.ai_range_table	= &ai_ranges_64xx,
+		.ai_fifo	= ai_fifo_64xx,
+		.has_8255	= 1,
+	},
 	[BOARD_PCIDAS64_M3_16_JR] = {
-	 .name = "pci-das64/m3/16/jr",
-	 .ai_se_chans = 64,
-	 .ai_bits = 16,
-	 .ai_speed = 333,
-	 .ao_nchan = 0,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_64XX,
-	 .ai_range_table = &ai_ranges_64xx,
-	 .ai_fifo = ai_fifo_64xx,
-	 .has_8255 = 1,
-	 },
+		.name		= "pci-das64/m3/16/jr",
+		.ai_se_chans	= 64,
+		.ai_bits	= 16,
+		.ai_speed	= 333,
+		.ao_nchan	= 0,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_64XX,
+		.ai_range_table	= &ai_ranges_64xx,
+		.ai_fifo	= ai_fifo_64xx,
+		.has_8255	= 1,
+	},
 	[BOARD_PCIDAS64_M1_14] = {
-	 .name = "pci-das64/m1/14",
-	 .ai_se_chans = 64,
-	 .ai_bits = 14,
-	 .ai_speed = 1000,
-	 .ao_nchan = 2,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_64XX,
-	 .ai_range_table = &ai_ranges_64xx,
-	 .ai_fifo = ai_fifo_64xx,
-	 .has_8255 = 1,
-	 },
+		.name		= "pci-das64/m1/14",
+		.ai_se_chans	= 64,
+		.ai_bits	= 14,
+		.ai_speed	= 1000,
+		.ao_nchan	= 2,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_64XX,
+		.ai_range_table	= &ai_ranges_64xx,
+		.ai_fifo	= ai_fifo_64xx,
+		.has_8255	= 1,
+	},
 	[BOARD_PCIDAS64_M2_14] = {
-	 .name = "pci-das64/m2/14",
-	 .ai_se_chans = 64,
-	 .ai_bits = 14,
-	 .ai_speed = 500,
-	 .ao_nchan = 2,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_64XX,
-	 .ai_range_table = &ai_ranges_64xx,
-	 .ai_fifo = ai_fifo_64xx,
-	 .has_8255 = 1,
-	 },
+		.name		= "pci-das64/m2/14",
+		.ai_se_chans	= 64,
+		.ai_bits	= 14,
+		.ai_speed	= 500,
+		.ao_nchan	= 2,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_64XX,
+		.ai_range_table	= &ai_ranges_64xx,
+		.ai_fifo	= ai_fifo_64xx,
+		.has_8255	= 1,
+	},
 	[BOARD_PCIDAS64_M3_14] = {
-	 .name = "pci-das64/m3/14",
-	 .ai_se_chans = 64,
-	 .ai_bits = 14,
-	 .ai_speed = 333,
-	 .ao_nchan = 2,
-	 .ao_scan_speed = 10000,
-	 .layout = LAYOUT_64XX,
-	 .ai_range_table = &ai_ranges_64xx,
-	 .ai_fifo = ai_fifo_64xx,
-	 .has_8255 = 1,
-	 },
+		.name		= "pci-das64/m3/14",
+		.ai_se_chans	= 64,
+		.ai_bits	= 14,
+		.ai_speed	= 333,
+		.ao_nchan	= 2,
+		.ao_scan_speed	= 10000,
+		.layout		= LAYOUT_64XX,
+		.ai_range_table	= &ai_ranges_64xx,
+		.ai_fifo	= ai_fifo_64xx,
+		.has_8255	= 1,
+	},
 #endif
 };
 

commit 463740d48fe9804a7181b25bcbdab1c887e36173
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 10:00:39 2013 -0700

    staging: comedi: cb_pcidas64: use the pci id_table 'driver_data'
    
    Create an enum to the boardinfo and pass that enum in the pci_driver
    id_table as the driver_data.
    
    Change the macro used to fill in the device table from PCI_DEVICE() to
    PCI_VDEVICE(). This allows passing the enum as the next field.
    
    This allows removing the 'device_id' data from the boardinfo as well
    the search function that was used to locate the boardinfo for the PCI
    device.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index c085e1d80d46..d0d6ed402474 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -593,9 +593,39 @@ struct hw_fifo_info {
 	uint16_t fifo_size_reg_mask;
 };
 
+enum pcidas64_boardid {
+	BOARD_PCIDAS6402_16,
+	BOARD_PCIDAS6402_12,
+	BOARD_PCIDAS64_M1_16,
+	BOARD_PCIDAS64_M2_16,
+	BOARD_PCIDAS64_M3_16,
+	BOARD_PCIDAS6013,
+	BOARD_PCIDAS6014,
+	BOARD_PCIDAS6023,
+	BOARD_PCIDAS6025,
+	BOARD_PCIDAS6030,
+	BOARD_PCIDAS6031,
+	BOARD_PCIDAS6032,
+	BOARD_PCIDAS6033,
+	BOARD_PCIDAS6034,
+	BOARD_PCIDAS6035,
+	BOARD_PCIDAS6036,
+	BOARD_PCIDAS6040,
+	BOARD_PCIDAS6052,
+	BOARD_PCIDAS6070,
+	BOARD_PCIDAS6071,
+	BOARD_PCIDAS4020_12,
+	BOARD_PCIDAS6402_16_JR,
+	BOARD_PCIDAS64_M1_16_JR,
+	BOARD_PCIDAS64_M2_16_JR,
+	BOARD_PCIDAS64_M3_16_JR,
+	BOARD_PCIDAS64_M1_14,
+	BOARD_PCIDAS64_M2_14,
+	BOARD_PCIDAS64_M3_14,
+};
+
 struct pcidas64_board {
 	const char *name;
-	int device_id;		/*  pci device id */
 	int ai_se_chans;	/*  number of ai inputs in single-ended mode */
 	int ai_bits;		/*  analog input resolution */
 	int ai_speed;		/*  fastest conversion period in ns */
@@ -648,9 +678,8 @@ static inline unsigned int ai_dma_ring_count(const struct pcidas64_board *board)
 static const int bytes_in_sample = 2;
 
 static const struct pcidas64_board pcidas64_boards[] = {
-	{
+	[BOARD_PCIDAS6402_16] = {
 	 .name = "pci-das6402/16",
-	 .device_id = 0x1d,
 	 .ai_se_chans = 64,
 	 .ai_bits = 16,
 	 .ai_speed = 5000,
@@ -664,9 +693,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_64xx,
 	 .has_8255 = 1,
 	 },
-	{
+	[BOARD_PCIDAS6402_12] = {
 	 .name = "pci-das6402/12",	/*  XXX check */
-	 .device_id = 0x1e,
 	 .ai_se_chans = 64,
 	 .ai_bits = 12,
 	 .ai_speed = 5000,
@@ -680,9 +708,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_64xx,
 	 .has_8255 = 1,
 	 },
-	{
+	[BOARD_PCIDAS64_M1_16] = {
 	 .name = "pci-das64/m1/16",
-	 .device_id = 0x35,
 	 .ai_se_chans = 64,
 	 .ai_bits = 16,
 	 .ai_speed = 1000,
@@ -696,9 +723,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_64xx,
 	 .has_8255 = 1,
 	 },
-	{
+	[BOARD_PCIDAS64_M2_16] = {
 	 .name = "pci-das64/m2/16",
-	 .device_id = 0x36,
 	 .ai_se_chans = 64,
 	 .ai_bits = 16,
 	 .ai_speed = 500,
@@ -712,9 +738,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_64xx,
 	 .has_8255 = 1,
 	 },
-	{
+	[BOARD_PCIDAS64_M3_16] = {
 	 .name = "pci-das64/m3/16",
-	 .device_id = 0x37,
 	 .ai_se_chans = 64,
 	 .ai_bits = 16,
 	 .ai_speed = 333,
@@ -728,9 +753,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_64xx,
 	 .has_8255 = 1,
 	 },
-	{
+	[BOARD_PCIDAS6013] = {
 	 .name = "pci-das6013",
-	 .device_id = 0x78,
 	 .ai_se_chans = 16,
 	 .ai_bits = 16,
 	 .ai_speed = 5000,
@@ -743,9 +767,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 0,
 	 },
-	{
+	[BOARD_PCIDAS6014] = {
 	 .name = "pci-das6014",
-	 .device_id = 0x79,
 	 .ai_se_chans = 16,
 	 .ai_bits = 16,
 	 .ai_speed = 5000,
@@ -759,9 +782,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 0,
 	 },
-	{
+	[BOARD_PCIDAS6023] = {
 	 .name = "pci-das6023",
-	 .device_id = 0x5d,
 	 .ai_se_chans = 16,
 	 .ai_bits = 12,
 	 .ai_speed = 5000,
@@ -774,9 +796,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 1,
 	 },
-	{
+	[BOARD_PCIDAS6025] = {
 	 .name = "pci-das6025",
-	 .device_id = 0x5e,
 	 .ai_se_chans = 16,
 	 .ai_bits = 12,
 	 .ai_speed = 5000,
@@ -790,9 +811,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 1,
 	 },
-	{
+	[BOARD_PCIDAS6030] = {
 	 .name = "pci-das6030",
-	 .device_id = 0x5f,
 	 .ai_se_chans = 16,
 	 .ai_bits = 16,
 	 .ai_speed = 10000,
@@ -806,9 +826,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 0,
 	 },
-	{
+	[BOARD_PCIDAS6031] = {
 	 .name = "pci-das6031",
-	 .device_id = 0x60,
 	 .ai_se_chans = 64,
 	 .ai_bits = 16,
 	 .ai_speed = 10000,
@@ -822,9 +841,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 0,
 	 },
-	{
+	[BOARD_PCIDAS6032] = {
 	 .name = "pci-das6032",
-	 .device_id = 0x61,
 	 .ai_se_chans = 16,
 	 .ai_bits = 16,
 	 .ai_speed = 10000,
@@ -834,9 +852,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 0,
 	 },
-	{
+	[BOARD_PCIDAS6033] = {
 	 .name = "pci-das6033",
-	 .device_id = 0x62,
 	 .ai_se_chans = 64,
 	 .ai_bits = 16,
 	 .ai_speed = 10000,
@@ -846,9 +863,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 0,
 	 },
-	{
+	[BOARD_PCIDAS6034] = {
 	 .name = "pci-das6034",
-	 .device_id = 0x63,
 	 .ai_se_chans = 16,
 	 .ai_bits = 16,
 	 .ai_speed = 5000,
@@ -859,9 +875,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 0,
 	 },
-	{
+	[BOARD_PCIDAS6035] = {
 	 .name = "pci-das6035",
-	 .device_id = 0x64,
 	 .ai_se_chans = 16,
 	 .ai_bits = 16,
 	 .ai_speed = 5000,
@@ -875,9 +890,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 0,
 	 },
-	{
+	[BOARD_PCIDAS6036] = {
 	 .name = "pci-das6036",
-	 .device_id = 0x6f,
 	 .ai_se_chans = 16,
 	 .ai_bits = 16,
 	 .ai_speed = 5000,
@@ -891,9 +905,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 0,
 	 },
-	{
+	[BOARD_PCIDAS6040] = {
 	 .name = "pci-das6040",
-	 .device_id = 0x65,
 	 .ai_se_chans = 16,
 	 .ai_bits = 12,
 	 .ai_speed = 2000,
@@ -907,9 +920,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 0,
 	 },
-	{
+	[BOARD_PCIDAS6052] = {
 	 .name = "pci-das6052",
-	 .device_id = 0x66,
 	 .ai_se_chans = 16,
 	 .ai_bits = 16,
 	 .ai_speed = 3333,
@@ -923,9 +935,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 0,
 	 },
-	{
+	[BOARD_PCIDAS6070] = {
 	 .name = "pci-das6070",
-	 .device_id = 0x67,
 	 .ai_se_chans = 16,
 	 .ai_bits = 12,
 	 .ai_speed = 800,
@@ -939,9 +950,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 0,
 	 },
-	{
+	[BOARD_PCIDAS6071] = {
 	 .name = "pci-das6071",
-	 .device_id = 0x68,
 	 .ai_se_chans = 64,
 	 .ai_bits = 12,
 	 .ai_speed = 800,
@@ -955,9 +965,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = &ai_fifo_60xx,
 	 .has_8255 = 0,
 	 },
-	{
+	[BOARD_PCIDAS4020_12] = {
 	 .name = "pci-das4020/12",
-	 .device_id = 0x52,
 	 .ai_se_chans = 4,
 	 .ai_bits = 12,
 	 .ai_speed = 50,
@@ -972,9 +981,12 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .has_8255 = 1,
 	 },
 #if 0
-	{
+	/*
+	 * The device id for these boards is unknown
+	 */
+
+	[BOARD_PCIDAS6402_16_JR] = {
 	 .name = "pci-das6402/16/jr",
-	 .device_id = 0		/*  XXX, */
 	 .ai_se_chans = 64,
 	 .ai_bits = 16,
 	 .ai_speed = 5000,
@@ -985,9 +997,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = ai_fifo_64xx,
 	 .has_8255 = 1,
 	 },
-	{
+	[BOARD_PCIDAS64_M1_16_JR] = {
 	 .name = "pci-das64/m1/16/jr",
-	 .device_id = 0		/*  XXX, */
 	 .ai_se_chans = 64,
 	 .ai_bits = 16,
 	 .ai_speed = 1000,
@@ -998,9 +1009,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = ai_fifo_64xx,
 	 .has_8255 = 1,
 	 },
-	{
+	[BOARD_PCIDAS64_M2_16_JR] = {
 	 .name = "pci-das64/m2/16/jr",
-	 .device_id = 0		/*  XXX, */
 	 .ai_se_chans = 64,
 	 .ai_bits = 16,
 	 .ai_speed = 500,
@@ -1011,9 +1021,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = ai_fifo_64xx,
 	 .has_8255 = 1,
 	 },
-	{
+	[BOARD_PCIDAS64_M3_16_JR] = {
 	 .name = "pci-das64/m3/16/jr",
-	 .device_id = 0		/*  XXX, */
 	 .ai_se_chans = 64,
 	 .ai_bits = 16,
 	 .ai_speed = 333,
@@ -1024,9 +1033,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = ai_fifo_64xx,
 	 .has_8255 = 1,
 	 },
-	{
+	[BOARD_PCIDAS64_M1_14] = {
 	 .name = "pci-das64/m1/14",
-	 .device_id = 0,	/*  XXX */
 	 .ai_se_chans = 64,
 	 .ai_bits = 14,
 	 .ai_speed = 1000,
@@ -1037,9 +1045,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = ai_fifo_64xx,
 	 .has_8255 = 1,
 	 },
-	{
+	[BOARD_PCIDAS64_M2_14] = {
 	 .name = "pci-das64/m2/14",
-	 .device_id = 0,	/*  XXX */
 	 .ai_se_chans = 64,
 	 .ai_bits = 14,
 	 .ai_speed = 500,
@@ -1050,9 +1057,8 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	 .ai_fifo = ai_fifo_64xx,
 	 .has_8255 = 1,
 	 },
-	{
+	[BOARD_PCIDAS64_M3_14] = {
 	 .name = "pci-das64/m3/14",
-	 .device_id = 0,	/*  XXX */
 	 .ai_se_chans = 64,
 	 .ai_bits = 14,
 	 .ai_speed = 333,
@@ -4033,34 +4039,20 @@ static int setup_subdevices(struct comedi_device *dev)
 	return 0;
 }
 
-static const struct pcidas64_board
-*cb_pcidas64_find_pci_board(struct pci_dev *pcidev)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(pcidas64_boards); i++)
-		if (pcidev->device == pcidas64_boards[i].device_id)
-			return &pcidas64_boards[i];
-	return NULL;
-}
-
 static int auto_attach(struct comedi_device *dev,
-				 unsigned long context_unused)
+		       unsigned long context)
 {
-	const struct pcidas64_board *thisboard;
-	struct pcidas64_private *devpriv;
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	const struct pcidas64_board *thisboard = NULL;
+	struct pcidas64_private *devpriv;
 	uint32_t local_range, local_decode;
 	int retval;
 
-	dev->board_ptr = cb_pcidas64_find_pci_board(pcidev);
-	if (!dev->board_ptr) {
-		dev_err(dev->class_dev,
-			"cb_pcidas64: does not support pci %s\n",
-			pci_name(pcidev));
-		return -EINVAL;
-	}
-	thisboard = comedi_board(dev);
+	if (context < ARRAY_SIZE(pcidas64_boards))
+		thisboard = &pcidas64_boards[context];
+	if (!thisboard)
+		return -ENODEV;
+	dev->board_ptr = thisboard;
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
@@ -4223,25 +4215,27 @@ static int cb_pcidas64_pci_probe(struct pci_dev *dev,
 }
 
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas64_pci_table) = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001d) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001e) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0035) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0036) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0037) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0052) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x005d) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x005e) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x005f) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0061) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0062) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0063) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0064) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0066) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0067) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0068) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x006f) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0078) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0079) },
+	{ PCI_VDEVICE(CB, 0x001d), BOARD_PCIDAS6402_16 },
+	{ PCI_VDEVICE(CB, 0x001e), BOARD_PCIDAS6402_12 },
+	{ PCI_VDEVICE(CB, 0x0035), BOARD_PCIDAS64_M1_16 },
+	{ PCI_VDEVICE(CB, 0x0036), BOARD_PCIDAS64_M2_16 },
+	{ PCI_VDEVICE(CB, 0x0037), BOARD_PCIDAS64_M3_16 },
+	{ PCI_VDEVICE(CB, 0x0052), BOARD_PCIDAS4020_12 },
+	{ PCI_VDEVICE(CB, 0x005d), BOARD_PCIDAS6023 },
+	{ PCI_VDEVICE(CB, 0x005e), BOARD_PCIDAS6025 },
+	{ PCI_VDEVICE(CB, 0x005f), BOARD_PCIDAS6030 },
+	{ PCI_VDEVICE(CB, 0x0060), BOARD_PCIDAS6031 },
+	{ PCI_VDEVICE(CB, 0x0061), BOARD_PCIDAS6032 },
+	{ PCI_VDEVICE(CB, 0x0062), BOARD_PCIDAS6033 },
+	{ PCI_VDEVICE(CB, 0x0063), BOARD_PCIDAS6034 },
+	{ PCI_VDEVICE(CB, 0x0064), BOARD_PCIDAS6035 },
+	{ PCI_VDEVICE(CB, 0x0065), BOARD_PCIDAS6040 },
+	{ PCI_VDEVICE(CB, 0x0066), BOARD_PCIDAS6052 },
+	{ PCI_VDEVICE(CB, 0x0067), BOARD_PCIDAS6070 },
+	{ PCI_VDEVICE(CB, 0x0068), BOARD_PCIDAS6071 },
+	{ PCI_VDEVICE(CB, 0x006f), BOARD_PCIDAS6036 },
+	{ PCI_VDEVICE(CB, 0x0078), BOARD_PCIDAS6013 },
+	{ PCI_VDEVICE(CB, 0x0079), BOARD_PCIDAS6014 },
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, cb_pcidas64_pci_table);

commit b8f4ac237e382accd4b30c75043939f7ed9e79a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 09:53:41 2013 -0700

    staging: comedi: comedi_pci: change the comedi_pci_auto_config() 'context'
    
    The comedi_pci_auto_config() function is used to allow the PCI driver
    (*probe) function to automatically call the comedi driver (*auto_attach).
    This allows the comedi driver to be part of the PnP process when the
    PCI device is detected.
    
    Currently the comedi_pci_auto_config() always passes a 'context' of '0'
    to comedi_auto_config(). This makes the 'context' a bit useless.
    
    Modify comedi_pci_auto_config() to allow the comedi pci drivers to pass
    a 'context' from the PCI driver.
    
    Make all the comedi pci drivers pass the pci_device_id 'driver_data' as
    the 'context'. Since none of the comedi pci drivers currently set the
    'driver_data' the 'context' will still be '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 9f3112cb7a21..c085e1d80d46 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4216,9 +4216,10 @@ static struct comedi_driver cb_pcidas64_driver = {
 };
 
 static int cb_pcidas64_pci_probe(struct pci_dev *dev,
-					   const struct pci_device_id *ent)
+				 const struct pci_device_id *id)
 {
-	return comedi_pci_auto_config(dev, &cb_pcidas64_driver);
+	return comedi_pci_auto_config(dev, &cb_pcidas64_driver,
+				      id->driver_data);
 }
 
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas64_pci_table) = {

commit a81875dd7a6e31e69ea1f6ed22209acb8f82bf36
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Fri Feb 15 13:14:26 2013 +0100

    staging/comedi: Remove if(); statement without effect
    
    Smatch warns about:
    staging/comedi/drivers/cb_pcidas64.c:3304 prep_ao_dma() warn: if();
    
    So the check currently does nothing and can be removed, as indicated by
    Ian.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index d33fc327236f..9f3112cb7a21 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3301,7 +3301,6 @@ static int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	num_bytes = load_ao_dma_buffer(dev, cmd);
 	if (num_bytes == 0)
 		return -1;
-	if (num_bytes >= DMA_BUFFER_SIZE) ;
 	load_ao_dma(dev, cmd);
 
 	dma_start_sync(dev, 0);

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index e7d297708a5b..d33fc327236f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -87,10 +87,12 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
-#include "../comedidev.h"
+#include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 
+#include "../comedidev.h"
+
 #include "8253.h"
 #include "8255.h"
 #include "plx9080.h"

commit 9901a4d75d007686e8f6473189cafc4b216b7449
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Tue Jan 22 23:40:03 2013 +0100

    staging/comedi: Use comedi_pci_auto_unconfig directly for pci_driver.remove
    
    (Almost) all comedi pci drivers have some wrapper for their
    pci_driver.remove function which simply calls comedi_pci_auto_unconfig
    which has the same function prototype as the wrapper.
    
    -> we can remove these wrappers and call comedi_pci_auto_unconfig
    directly. This removes a lot some boilerplate code and saves some bytes.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index d72b46cc06bc..e7d297708a5b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4220,11 +4220,6 @@ static int cb_pcidas64_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &cb_pcidas64_driver);
 }
 
-static void cb_pcidas64_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas64_pci_table) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001d) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001e) },
@@ -4253,7 +4248,7 @@ static struct pci_driver cb_pcidas64_pci_driver = {
 	.name		= "cb_pcidas64",
 	.id_table	= cb_pcidas64_pci_table,
 	.probe		= cb_pcidas64_pci_probe,
-	.remove		= cb_pcidas64_pci_remove,
+	.remove		= comedi_pci_auto_unconfig,
 };
 module_comedi_pci_driver(cb_pcidas64_driver, cb_pcidas64_pci_driver);
 

commit 53b800198592b0ff96577ecc5f116f7d902a4362
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:36 2012 -0500

    staging: comedi: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 14019b3dbafb..d72b46cc06bc 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4220,7 +4220,7 @@ static int cb_pcidas64_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &cb_pcidas64_driver);
 }
 
-static void __devexit cb_pcidas64_pci_remove(struct pci_dev *dev)
+static void cb_pcidas64_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }

commit a690b7e535f2f97a3a05ee570715abeb60a8910f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:58 2012 -0500

    staging: comedi: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index ea2e1e780666..14019b3dbafb 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4043,7 +4043,7 @@ static const struct pcidas64_board
 	return NULL;
 }
 
-static int __devinit auto_attach(struct comedi_device *dev,
+static int auto_attach(struct comedi_device *dev,
 				 unsigned long context_unused)
 {
 	const struct pcidas64_board *thisboard;
@@ -4214,7 +4214,7 @@ static struct comedi_driver cb_pcidas64_driver = {
 	.detach		= detach,
 };
 
-static int __devinit cb_pcidas64_pci_probe(struct pci_dev *dev,
+static int cb_pcidas64_pci_probe(struct pci_dev *dev,
 					   const struct pci_device_id *ent)
 {
 	return comedi_pci_auto_config(dev, &cb_pcidas64_driver);

commit a471eace7baa40cdf16d3f26b2f78ddce613ca8f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:37 2012 -0500

    staging: comedi: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 17813aa6bb2e..ea2e1e780666 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4253,7 +4253,7 @@ static struct pci_driver cb_pcidas64_pci_driver = {
 	.name		= "cb_pcidas64",
 	.id_table	= cb_pcidas64_pci_table,
 	.probe		= cb_pcidas64_pci_probe,
-	.remove		= __devexit_p(cb_pcidas64_pci_remove),
+	.remove		= cb_pcidas64_pci_remove,
 };
 module_comedi_pci_driver(cb_pcidas64_driver, cb_pcidas64_pci_driver);
 

commit dba2939c8d4128664ddfddc169b32ae4b39aebc1
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Nov 14 17:47:47 2012 -0700

    staging: comedi: cb_pcidas64: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of {ai,ao}_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 68a128903224..17813aa6bb2e 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2120,56 +2120,34 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		if (thisboard->layout == LAYOUT_4020) {
-			if (cmd->convert_arg) {
-				cmd->convert_arg = 0;
-				err++;
-			}
+			err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 		} else {
-			if (cmd->convert_arg < thisboard->ai_speed) {
-				cmd->convert_arg = thisboard->ai_speed;
-				err++;
-			}
-			if (cmd->scan_begin_src == TRIG_TIMER) {
-				/*  if scans are timed faster than
-				 *  conversion rate allows */
-				if (cmd->convert_arg * cmd->chanlist_len >
-				    cmd->scan_begin_arg) {
-					cmd->scan_begin_arg =
+			err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+							 thisboard->ai_speed);
+			/* if scans are timed faster than conversion rate allows */
+			if (cmd->scan_begin_src == TRIG_TIMER)
+				err |= cfc_check_trigger_arg_min(
+						&cmd->scan_begin_arg,
 						cmd->convert_arg *
-						cmd->chanlist_len;
-					err++;
-				}
-			}
+						cmd->chanlist_len);
 		}
 	}
 
-	if (!cmd->chanlist_len) {
-		cmd->chanlist_len = 1;
-		err++;
-	}
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
 	switch (cmd->stop_src) {
 	case TRIG_EXT:
 		break;
 	case TRIG_COUNT:
-		if (!cmd->stop_arg) {
-			cmd->stop_arg = 1;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
 		break;
 	case TRIG_NONE:
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 		break;
 	default:
 		break;
@@ -3428,29 +3406,21 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		if (cmd->scan_begin_arg < thisboard->ao_scan_speed) {
-			cmd->scan_begin_arg = thisboard->ao_scan_speed;
-			err++;
-		}
-		if (get_ao_divisor(cmd->scan_begin_arg,
-				   cmd->flags) > max_counter_value) {
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+						 thisboard->ao_scan_speed);
+		if (get_ao_divisor(cmd->scan_begin_arg, cmd->flags) >
+		    max_counter_value) {
 			cmd->scan_begin_arg = (max_counter_value + 2) *
 					      TIMER_BASE;
-			err++;
+			err |= -EINVAL;
 		}
 	}
 
-	if (!cmd->chanlist_len) {
-		cmd->chanlist_len = 1;
-		err++;
-	}
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
 	if (err)
 		return 3;

commit 11aade26508cb7a06b24dfabe76f0cbafd0acf29
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 2 19:18:06 2012 +0000

    staging: comedi: cb_pcidas64: update driver comment
    
    Update the comedi driver comment to reflect the fact that manual
    attachment of devices is no longer supported.  Also replace the request
    to file a bug report about unidentified PCI device IDs with a request to
    let the maintainers know about such devices.
    
    Reformat the comment using the usual block comment style.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 771f0433a79b..68a128903224 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -36,39 +36,39 @@
 ************************************************************************/
 
 /*
-
-Driver: cb_pcidas64
-Description: MeasurementComputing PCI-DAS64xx, 60XX, and 4020 series with the PLX 9080 PCI controller
-Author: Frank Mori Hess <fmhess@users.sourceforge.net>
-Status: works
-Updated: 2002-10-09
-Devices: [Measurement Computing] PCI-DAS6402/16 (cb_pcidas64),
-  PCI-DAS6402/12, PCI-DAS64/M1/16, PCI-DAS64/M2/16,
-  PCI-DAS64/M3/16, PCI-DAS6402/16/JR, PCI-DAS64/M1/16/JR,
-  PCI-DAS64/M2/16/JR, PCI-DAS64/M3/16/JR, PCI-DAS64/M1/14,
-  PCI-DAS64/M2/14, PCI-DAS64/M3/14, PCI-DAS6013, PCI-DAS6014,
-  PCI-DAS6023, PCI-DAS6025, PCI-DAS6030,
-  PCI-DAS6031, PCI-DAS6032, PCI-DAS6033, PCI-DAS6034,
-  PCI-DAS6035, PCI-DAS6036, PCI-DAS6040, PCI-DAS6052,
-  PCI-DAS6070, PCI-DAS6071, PCI-DAS4020/12
-
-Configuration options:
-   [0] - PCI bus of device (optional)
-   [1] - PCI slot of device (optional)
-
-These boards may be autocalibrated with the comedi_calibrate utility.
-
-To select the bnc trigger input on the 4020 (instead of the dio input),
-specify a nonzero channel in the chanspec.  If you wish to use an external
-master clock on the 4020, you may do so by setting the scan_begin_src
-to TRIG_OTHER, and using an INSN_CONFIG_TIMER_1 configuration insn
-to configure the divisor to use for the external clock.
-
-Some devices are not identified because the PCI device IDs are not yet
-known. If you have such a board, please file a bug report at
-https://bugs.comedi.org.
-
-*/
+ * Driver: cb_pcidas64
+ * Description: MeasurementComputing PCI-DAS64xx, 60XX, and 4020 series
+ *   with the PLX 9080 PCI controller
+ * Author: Frank Mori Hess <fmhess@users.sourceforge.net>
+ * Status: works
+ * Updated: Fri, 02 Nov 2012 18:58:55 +0000
+ * Devices: [Measurement Computing] PCI-DAS6402/16 (cb_pcidas64),
+ *   PCI-DAS6402/12, PCI-DAS64/M1/16, PCI-DAS64/M2/16,
+ *   PCI-DAS64/M3/16, PCI-DAS6402/16/JR, PCI-DAS64/M1/16/JR,
+ *   PCI-DAS64/M2/16/JR, PCI-DAS64/M3/16/JR, PCI-DAS64/M1/14,
+ *   PCI-DAS64/M2/14, PCI-DAS64/M3/14, PCI-DAS6013, PCI-DAS6014,
+ *   PCI-DAS6023, PCI-DAS6025, PCI-DAS6030,
+ *   PCI-DAS6031, PCI-DAS6032, PCI-DAS6033, PCI-DAS6034,
+ *   PCI-DAS6035, PCI-DAS6036, PCI-DAS6040, PCI-DAS6052,
+ *   PCI-DAS6070, PCI-DAS6071, PCI-DAS4020/12
+ *
+ * Configuration options:
+ *   None.
+ *
+ * Manual attachment of PCI cards with the comedi_config utility is not
+ * supported by this driver; they are attached automatically.
+ *
+ * These boards may be autocalibrated with the comedi_calibrate utility.
+ *
+ * To select the bnc trigger input on the 4020 (instead of the dio input),
+ * specify a nonzero channel in the chanspec.  If you wish to use an external
+ * master clock on the 4020, you may do so by setting the scan_begin_src
+ * to TRIG_OTHER, and using an INSN_CONFIG_TIMER_1 configuration insn
+ * to configure the divisor to use for the external clock.
+ *
+ * Some devices are not identified because the PCI device IDs are not yet
+ * known. If you have such a board, please let the maintainers know.
+ */
 
 /*
 

commit dd379fa23feda77e3fee1a65bb65ab72019b77dc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 2 19:18:05 2012 +0000

    staging: comedi: cb_pcidas64: fix forward declararions 4
    
    Move `disable_plx_interrupts()`, `disable_ai_interrupts()`,
    `enable_ai_interrupts()`, `set_ai_fifo_segment_length()`,
    `set_ai_fifo_size()`, `ai_fifo_size()`, `load_ao_dma_buffer()`, and
    `load_ao_dma()`, and remove forward declarations of these functions.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index f767cdb9fc0b..771f0433a79b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1151,16 +1151,6 @@ struct pcidas64_private {
 	short ao_bounce_buffer[DAC_FIFO_SIZE];
 };
 
-static void disable_plx_interrupts(struct comedi_device *dev);
-static int set_ai_fifo_size(struct comedi_device *dev,
-			    unsigned int num_samples);
-static unsigned int ai_fifo_size(struct comedi_device *dev);
-static int set_ai_fifo_segment_length(struct comedi_device *dev,
-				      unsigned int num_entries);
-static void disable_ai_interrupts(struct comedi_device *dev);
-static void load_ao_dma(struct comedi_device *dev,
-			const struct comedi_cmd *cmd);
-
 static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 				       unsigned int range_index)
 {
@@ -1251,6 +1241,57 @@ static void abort_dma(struct comedi_device *dev, unsigned int channel)
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
+static void disable_plx_interrupts(struct comedi_device *dev)
+{
+	struct pcidas64_private *devpriv = dev->private;
+
+	devpriv->plx_intcsr_bits = 0;
+	writel(devpriv->plx_intcsr_bits,
+	       devpriv->plx9080_iobase + PLX_INTRCS_REG);
+}
+
+static void disable_ai_interrupts(struct comedi_device *dev)
+{
+	struct pcidas64_private *devpriv = dev->private;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->intr_enable_bits &=
+		~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &
+		~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &
+		~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;
+	writew(devpriv->intr_enable_bits,
+	       devpriv->main_iobase + INTR_ENABLE_REG);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	DEBUG_PRINT("intr enable bits 0x%x\n", devpriv->intr_enable_bits);
+}
+
+static void enable_ai_interrupts(struct comedi_device *dev,
+				 const struct comedi_cmd *cmd)
+{
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+	struct pcidas64_private *devpriv = dev->private;
+	uint32_t bits;
+	unsigned long flags;
+
+	bits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |
+	       EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;
+	/*  Use pio transfer and interrupt on end of conversion
+	 *  if TRIG_WAKE_EOS flag is set. */
+	if (cmd->flags & TRIG_WAKE_EOS) {
+		/*  4020 doesn't support pio transfers except for fifo dregs */
+		if (thisboard->layout != LAYOUT_4020)
+			bits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;
+	}
+	spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->intr_enable_bits |= bits;
+	writew(devpriv->intr_enable_bits,
+	       devpriv->main_iobase + INTR_ENABLE_REG);
+	DEBUG_PRINT("intr enable bits 0x%x\n", devpriv->intr_enable_bits);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+}
+
 /* initialize plx9080 chip */
 static void init_plx9080(struct comedi_device *dev)
 {
@@ -1343,15 +1384,6 @@ static void init_plx9080(struct comedi_device *dev)
 	       devpriv->plx9080_iobase + PLX_INTRCS_REG);
 }
 
-static void disable_plx_interrupts(struct comedi_device *dev)
-{
-	struct pcidas64_private *devpriv = dev->private;
-
-	devpriv->plx_intcsr_bits = 0;
-	writel(devpriv->plx_intcsr_bits,
-	       devpriv->plx9080_iobase + PLX_INTRCS_REG);
-}
-
 static void disable_ai_pacing(struct comedi_device *dev)
 {
 	struct pcidas64_private *devpriv = dev->private;
@@ -1370,6 +1402,72 @@ static void disable_ai_pacing(struct comedi_device *dev)
 	       devpriv->main_iobase + ADC_CONTROL0_REG);
 }
 
+static int set_ai_fifo_segment_length(struct comedi_device *dev,
+				      unsigned int num_entries)
+{
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+	struct pcidas64_private *devpriv = dev->private;
+	static const int increment_size = 0x100;
+	const struct hw_fifo_info *const fifo = thisboard->ai_fifo;
+	unsigned int num_increments;
+	uint16_t bits;
+
+	if (num_entries < increment_size)
+		num_entries = increment_size;
+	if (num_entries > fifo->max_segment_length)
+		num_entries = fifo->max_segment_length;
+
+	/*  1 == 256 entries, 2 == 512 entries, etc */
+	num_increments = (num_entries + increment_size / 2) / increment_size;
+
+	bits = (~(num_increments - 1)) & fifo->fifo_size_reg_mask;
+	devpriv->fifo_size_bits &= ~fifo->fifo_size_reg_mask;
+	devpriv->fifo_size_bits |= bits;
+	writew(devpriv->fifo_size_bits,
+	       devpriv->main_iobase + FIFO_SIZE_REG);
+
+	devpriv->ai_fifo_segment_length = num_increments * increment_size;
+
+	DEBUG_PRINT("set hardware fifo segment length to %i\n",
+		    devpriv->ai_fifo_segment_length);
+
+	return devpriv->ai_fifo_segment_length;
+}
+
+/* adjusts the size of hardware fifo (which determines block size for dma xfers) */
+static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
+{
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+	unsigned int num_fifo_entries;
+	int retval;
+	const struct hw_fifo_info *const fifo = thisboard->ai_fifo;
+
+	num_fifo_entries = num_samples / fifo->sample_packing_ratio;
+
+	retval = set_ai_fifo_segment_length(dev,
+					    num_fifo_entries /
+					    fifo->num_segments);
+	if (retval < 0)
+		return retval;
+
+	num_samples = retval * fifo->num_segments * fifo->sample_packing_ratio;
+
+	DEBUG_PRINT("set hardware fifo size to %i\n", num_samples);
+
+	return num_samples;
+}
+
+/* query length of fifo */
+static unsigned int ai_fifo_size(struct comedi_device *dev)
+{
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+	struct pcidas64_private *devpriv = dev->private;
+
+	return devpriv->ai_fifo_segment_length *
+	       thisboard->ai_fifo->num_segments *
+	       thisboard->ai_fifo->sample_packing_ratio;
+}
+
 static void init_stc_registers(struct comedi_device *dev)
 {
 	const struct pcidas64_board *thisboard = comedi_board(dev);
@@ -2177,48 +2275,6 @@ static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 	return num_samples;
 }
 
-static void disable_ai_interrupts(struct comedi_device *dev)
-{
-	struct pcidas64_private *devpriv = dev->private;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->intr_enable_bits &=
-		~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &
-		~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &
-		~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;
-	writew(devpriv->intr_enable_bits,
-	       devpriv->main_iobase + INTR_ENABLE_REG);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	DEBUG_PRINT("intr enable bits 0x%x\n", devpriv->intr_enable_bits);
-}
-
-static void enable_ai_interrupts(struct comedi_device *dev,
-				 const struct comedi_cmd *cmd)
-{
-	const struct pcidas64_board *thisboard = comedi_board(dev);
-	struct pcidas64_private *devpriv = dev->private;
-	uint32_t bits;
-	unsigned long flags;
-
-	bits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |
-	       EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;
-	/*  Use pio transfer and interrupt on end of conversion
-	 *  if TRIG_WAKE_EOS flag is set. */
-	if (cmd->flags & TRIG_WAKE_EOS) {
-		/*  4020 doesn't support pio transfers except for fifo dregs */
-		if (thisboard->layout != LAYOUT_4020)
-			bits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;
-	}
-	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->intr_enable_bits |= bits;
-	writew(devpriv->intr_enable_bits,
-	       devpriv->main_iobase + INTR_ENABLE_REG);
-	DEBUG_PRINT("intr enable bits 0x%x\n", devpriv->intr_enable_bits);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-}
-
 static uint32_t ai_convert_counter_6xxx(const struct comedi_device *dev,
 					const struct comedi_cmd *cmd)
 {
@@ -2930,6 +2986,77 @@ static void restart_ao_dma(struct comedi_device *dev)
 	dma_start_sync(dev, 0);
 }
 
+static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
+				       const struct comedi_cmd *cmd)
+{
+	struct pcidas64_private *devpriv = dev->private;
+	unsigned int num_bytes, buffer_index, prev_buffer_index;
+	unsigned int next_bits;
+
+	buffer_index = devpriv->ao_dma_index;
+	prev_buffer_index = prev_ao_dma_index(dev);
+
+	DEBUG_PRINT("attempting to load ao buffer %i (0x%llx)\n", buffer_index,
+		    (unsigned long long)devpriv->ao_buffer_bus_addr[
+								buffer_index]);
+
+	num_bytes = comedi_buf_read_n_available(dev->write_subdev->async);
+	if (num_bytes > DMA_BUFFER_SIZE)
+		num_bytes = DMA_BUFFER_SIZE;
+	if (cmd->stop_src == TRIG_COUNT && num_bytes > devpriv->ao_count)
+		num_bytes = devpriv->ao_count;
+	num_bytes -= num_bytes % bytes_in_sample;
+
+	if (num_bytes == 0)
+		return 0;
+
+	DEBUG_PRINT("loading %i bytes\n", num_bytes);
+
+	num_bytes = cfc_read_array_from_buffer(dev->write_subdev,
+					       devpriv->
+					       ao_buffer[buffer_index],
+					       num_bytes);
+	devpriv->ao_dma_desc[buffer_index].transfer_size =
+		cpu_to_le32(num_bytes);
+	/* set end of chain bit so we catch underruns */
+	next_bits = le32_to_cpu(devpriv->ao_dma_desc[buffer_index].next);
+	next_bits |= PLX_END_OF_CHAIN_BIT;
+	devpriv->ao_dma_desc[buffer_index].next = cpu_to_le32(next_bits);
+	/* clear end of chain bit on previous buffer now that we have set it
+	 * for the last buffer */
+	next_bits = le32_to_cpu(devpriv->ao_dma_desc[prev_buffer_index].next);
+	next_bits &= ~PLX_END_OF_CHAIN_BIT;
+	devpriv->ao_dma_desc[prev_buffer_index].next = cpu_to_le32(next_bits);
+
+	devpriv->ao_dma_index = (buffer_index + 1) % AO_DMA_RING_COUNT;
+	devpriv->ao_count -= num_bytes;
+
+	return num_bytes;
+}
+
+static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
+{
+	struct pcidas64_private *devpriv = dev->private;
+	unsigned int num_bytes;
+	unsigned int next_transfer_addr;
+	void __iomem *pci_addr_reg =
+		devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+	unsigned int buffer_index;
+
+	do {
+		buffer_index = devpriv->ao_dma_index;
+		/* don't overwrite data that hasn't been transferred yet */
+		next_transfer_addr = readl(pci_addr_reg);
+		if (next_transfer_addr >=
+		    devpriv->ao_buffer_bus_addr[buffer_index] &&
+		    next_transfer_addr <
+		    devpriv->ao_buffer_bus_addr[buffer_index] +
+		    DMA_BUFFER_SIZE)
+			return;
+		num_bytes = load_ao_dma_buffer(dev, cmd);
+	} while (num_bytes >= DMA_BUFFER_SIZE);
+}
+
 static void handle_ao_interrupt(struct comedi_device *dev,
 				unsigned short status, unsigned int plx_status)
 {
@@ -3166,77 +3293,6 @@ static void set_dac_interval_regs(struct comedi_device *dev,
 	       devpriv->main_iobase + DAC_SAMPLE_INTERVAL_UPPER_REG);
 }
 
-static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
-				       const struct comedi_cmd *cmd)
-{
-	struct pcidas64_private *devpriv = dev->private;
-	unsigned int num_bytes, buffer_index, prev_buffer_index;
-	unsigned int next_bits;
-
-	buffer_index = devpriv->ao_dma_index;
-	prev_buffer_index = prev_ao_dma_index(dev);
-
-	DEBUG_PRINT("attempting to load ao buffer %i (0x%llx)\n", buffer_index,
-		    (unsigned long long)devpriv->ao_buffer_bus_addr[
-								buffer_index]);
-
-	num_bytes = comedi_buf_read_n_available(dev->write_subdev->async);
-	if (num_bytes > DMA_BUFFER_SIZE)
-		num_bytes = DMA_BUFFER_SIZE;
-	if (cmd->stop_src == TRIG_COUNT && num_bytes > devpriv->ao_count)
-		num_bytes = devpriv->ao_count;
-	num_bytes -= num_bytes % bytes_in_sample;
-
-	if (num_bytes == 0)
-		return 0;
-
-	DEBUG_PRINT("loading %i bytes\n", num_bytes);
-
-	num_bytes = cfc_read_array_from_buffer(dev->write_subdev,
-					       devpriv->
-					       ao_buffer[buffer_index],
-					       num_bytes);
-	devpriv->ao_dma_desc[buffer_index].transfer_size =
-		cpu_to_le32(num_bytes);
-	/* set end of chain bit so we catch underruns */
-	next_bits = le32_to_cpu(devpriv->ao_dma_desc[buffer_index].next);
-	next_bits |= PLX_END_OF_CHAIN_BIT;
-	devpriv->ao_dma_desc[buffer_index].next = cpu_to_le32(next_bits);
-	/* clear end of chain bit on previous buffer now that we have set it
-	 * for the last buffer */
-	next_bits = le32_to_cpu(devpriv->ao_dma_desc[prev_buffer_index].next);
-	next_bits &= ~PLX_END_OF_CHAIN_BIT;
-	devpriv->ao_dma_desc[prev_buffer_index].next = cpu_to_le32(next_bits);
-
-	devpriv->ao_dma_index = (buffer_index + 1) % AO_DMA_RING_COUNT;
-	devpriv->ao_count -= num_bytes;
-
-	return num_bytes;
-}
-
-static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
-{
-	struct pcidas64_private *devpriv = dev->private;
-	unsigned int num_bytes;
-	unsigned int next_transfer_addr;
-	void __iomem *pci_addr_reg =
-		devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
-	unsigned int buffer_index;
-
-	do {
-		buffer_index = devpriv->ao_dma_index;
-		/* don't overwrite data that hasn't been transferred yet */
-		next_transfer_addr = readl(pci_addr_reg);
-		if (next_transfer_addr >=
-		    devpriv->ao_buffer_bus_addr[buffer_index] &&
-		    next_transfer_addr <
-		    devpriv->ao_buffer_bus_addr[buffer_index] +
-		    DMA_BUFFER_SIZE)
-			return;
-		num_bytes = load_ao_dma_buffer(dev, cmd);
-	} while (num_bytes >= DMA_BUFFER_SIZE);
-}
-
 static int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	struct pcidas64_private *devpriv = dev->private;
@@ -3839,72 +3895,6 @@ static int eeprom_read_insn(struct comedi_device *dev,
 	return 1;
 }
 
-/* adjusts the size of hardware fifo (which determines block size for dma xfers) */
-static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
-{
-	const struct pcidas64_board *thisboard = comedi_board(dev);
-	unsigned int num_fifo_entries;
-	int retval;
-	const struct hw_fifo_info *const fifo = thisboard->ai_fifo;
-
-	num_fifo_entries = num_samples / fifo->sample_packing_ratio;
-
-	retval = set_ai_fifo_segment_length(dev,
-					    num_fifo_entries /
-					    fifo->num_segments);
-	if (retval < 0)
-		return retval;
-
-	num_samples = retval * fifo->num_segments * fifo->sample_packing_ratio;
-
-	DEBUG_PRINT("set hardware fifo size to %i\n", num_samples);
-
-	return num_samples;
-}
-
-/* query length of fifo */
-static unsigned int ai_fifo_size(struct comedi_device *dev)
-{
-	const struct pcidas64_board *thisboard = comedi_board(dev);
-	struct pcidas64_private *devpriv = dev->private;
-
-	return devpriv->ai_fifo_segment_length *
-	       thisboard->ai_fifo->num_segments *
-	       thisboard->ai_fifo->sample_packing_ratio;
-}
-
-static int set_ai_fifo_segment_length(struct comedi_device *dev,
-				      unsigned int num_entries)
-{
-	const struct pcidas64_board *thisboard = comedi_board(dev);
-	struct pcidas64_private *devpriv = dev->private;
-	static const int increment_size = 0x100;
-	const struct hw_fifo_info *const fifo = thisboard->ai_fifo;
-	unsigned int num_increments;
-	uint16_t bits;
-
-	if (num_entries < increment_size)
-		num_entries = increment_size;
-	if (num_entries > fifo->max_segment_length)
-		num_entries = fifo->max_segment_length;
-
-	/*  1 == 256 entries, 2 == 512 entries, etc */
-	num_increments = (num_entries + increment_size / 2) / increment_size;
-
-	bits = (~(num_increments - 1)) & fifo->fifo_size_reg_mask;
-	devpriv->fifo_size_bits &= ~fifo->fifo_size_reg_mask;
-	devpriv->fifo_size_bits |= bits;
-	writew(devpriv->fifo_size_bits,
-	       devpriv->main_iobase + FIFO_SIZE_REG);
-
-	devpriv->ai_fifo_segment_length = num_increments * increment_size;
-
-	DEBUG_PRINT("set hardware fifo segment length to %i\n",
-		    devpriv->ai_fifo_segment_length);
-
-	return devpriv->ai_fifo_segment_length;
-}
-
 /* Allocate and initialize the subdevice structures.
  */
 static int setup_subdevices(struct comedi_device *dev)

commit 012e642c01d3c11ac5e50187a0684bd006d29f71
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 2 19:18:04 2012 +0000

    staging: comedi: cb_pcidas64: fix forward declarations 3
    
    Move `abort_dma()`, `disable_ai_pacing()`, `i2c_high_udelay`,
    `i2c_low_udelay`, `i2c_set_sda()`, `i2c_set_scl()`, `i2c_write_byte()`,
    `i2c_read_ack()`, `i2c_start()`, `i2c_stop()`, `i2c_write()`,
    `get_divisor()`, `check_adc_timing()`, `disable_ai_pacing()`,
    `abort_dma()`, `get_ao_divisor()`, `ao_inttrig()`,
    `caldac_8800_write()`, `caldac_i2c_write()`, `check_adc_timing()`,
    `get_divisor()`, and `get_ao_divisor()`, and remove their forward
    declarations.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index a88e879c8d90..f767cdb9fc0b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1151,27 +1151,13 @@ struct pcidas64_private {
 	short ao_bounce_buffer[DAC_FIFO_SIZE];
 };
 
-static int ao_inttrig(struct comedi_device *dev,
-		      struct comedi_subdevice *subdev, unsigned int trig_num);
-static irqreturn_t handle_interrupt(int irq, void *d);
-static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd);
-static unsigned int get_divisor(unsigned int ns, unsigned int flags);
-static void i2c_write(struct comedi_device *dev, unsigned int address,
-		      const uint8_t *data, unsigned int length);
-static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-			     uint8_t value);
-static int caldac_i2c_write(struct comedi_device *dev,
-			    unsigned int caldac_channel, unsigned int value);
-static void abort_dma(struct comedi_device *dev, unsigned int channel);
 static void disable_plx_interrupts(struct comedi_device *dev);
 static int set_ai_fifo_size(struct comedi_device *dev,
 			    unsigned int num_samples);
 static unsigned int ai_fifo_size(struct comedi_device *dev);
 static int set_ai_fifo_segment_length(struct comedi_device *dev,
 				      unsigned int num_entries);
-static void disable_ai_pacing(struct comedi_device *dev);
 static void disable_ai_interrupts(struct comedi_device *dev);
-static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags);
 static void load_ao_dma(struct comedi_device *dev,
 			const struct comedi_cmd *cmd);
 
@@ -1252,6 +1238,19 @@ static inline int ao_cmd_is_supported(const struct pcidas64_board *board)
 	return board->ao_nchan && board->layout != LAYOUT_4020;
 }
 
+static void abort_dma(struct comedi_device *dev, unsigned int channel)
+{
+	struct pcidas64_private *devpriv = dev->private;
+	unsigned long flags;
+
+	/*  spinlock for plx dma control/status reg */
+	spin_lock_irqsave(&dev->spinlock, flags);
+
+	plx9080_abort_dma(devpriv->plx9080_iobase, channel);
+
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+}
+
 /* initialize plx9080 chip */
 static void init_plx9080(struct comedi_device *dev)
 {
@@ -1353,6 +1352,24 @@ static void disable_plx_interrupts(struct comedi_device *dev)
 	       devpriv->plx9080_iobase + PLX_INTRCS_REG);
 }
 
+static void disable_ai_pacing(struct comedi_device *dev)
+{
+	struct pcidas64_private *devpriv = dev->private;
+	unsigned long flags;
+
+	disable_ai_interrupts(dev);
+
+	spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->adc_control1_bits &= ~ADC_SW_GATE_BIT;
+	writew(devpriv->adc_control1_bits,
+	       devpriv->main_iobase + ADC_CONTROL1_REG);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	/* disable pacing, triggering, etc */
+	writew(ADC_DMA_DISABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT,
+	       devpriv->main_iobase + ADC_CONTROL0_REG);
+}
+
 static void init_stc_registers(struct comedi_device *dev)
 {
 	const struct pcidas64_board *thisboard = comedi_board(dev);
@@ -1495,6 +1512,135 @@ static inline void warn_external_queue(struct comedi_device *dev)
 		     "Use internal AI channel queue (channels must be consecutive and use same range/aref)");
 }
 
+/* Their i2c requires a huge delay on setting clock or data high for some reason */
+static const int i2c_high_udelay = 1000;
+static const int i2c_low_udelay = 10;
+
+/* set i2c data line high or low */
+static void i2c_set_sda(struct comedi_device *dev, int state)
+{
+	struct pcidas64_private *devpriv = dev->private;
+	static const int data_bit = CTL_EE_W;
+	void __iomem *plx_control_addr = devpriv->plx9080_iobase +
+					 PLX_CONTROL_REG;
+
+	if (state) {
+		/*  set data line high */
+		devpriv->plx_control_bits &= ~data_bit;
+		writel(devpriv->plx_control_bits, plx_control_addr);
+		udelay(i2c_high_udelay);
+	} else {		/*  set data line low */
+
+		devpriv->plx_control_bits |= data_bit;
+		writel(devpriv->plx_control_bits, plx_control_addr);
+		udelay(i2c_low_udelay);
+	}
+}
+
+/* set i2c clock line high or low */
+static void i2c_set_scl(struct comedi_device *dev, int state)
+{
+	struct pcidas64_private *devpriv = dev->private;
+	static const int clock_bit = CTL_USERO;
+	void __iomem *plx_control_addr = devpriv->plx9080_iobase +
+					 PLX_CONTROL_REG;
+
+	if (state) {
+		/*  set clock line high */
+		devpriv->plx_control_bits &= ~clock_bit;
+		writel(devpriv->plx_control_bits, plx_control_addr);
+		udelay(i2c_high_udelay);
+	} else {		/*  set clock line low */
+
+		devpriv->plx_control_bits |= clock_bit;
+		writel(devpriv->plx_control_bits, plx_control_addr);
+		udelay(i2c_low_udelay);
+	}
+}
+
+static void i2c_write_byte(struct comedi_device *dev, uint8_t byte)
+{
+	uint8_t bit;
+	unsigned int num_bits = 8;
+
+	DEBUG_PRINT("writing to i2c byte 0x%x\n", byte);
+
+	for (bit = 1 << (num_bits - 1); bit; bit >>= 1) {
+		i2c_set_scl(dev, 0);
+		if ((byte & bit))
+			i2c_set_sda(dev, 1);
+		else
+			i2c_set_sda(dev, 0);
+		i2c_set_scl(dev, 1);
+	}
+}
+
+/* we can't really read the lines, so fake it */
+static int i2c_read_ack(struct comedi_device *dev)
+{
+	i2c_set_scl(dev, 0);
+	i2c_set_sda(dev, 1);
+	i2c_set_scl(dev, 1);
+
+	return 0;		/*  return fake acknowledge bit */
+}
+
+/* send start bit */
+static void i2c_start(struct comedi_device *dev)
+{
+	i2c_set_scl(dev, 1);
+	i2c_set_sda(dev, 1);
+	i2c_set_sda(dev, 0);
+}
+
+/* send stop bit */
+static void i2c_stop(struct comedi_device *dev)
+{
+	i2c_set_scl(dev, 0);
+	i2c_set_sda(dev, 0);
+	i2c_set_scl(dev, 1);
+	i2c_set_sda(dev, 1);
+}
+
+static void i2c_write(struct comedi_device *dev, unsigned int address,
+		      const uint8_t *data, unsigned int length)
+{
+	struct pcidas64_private *devpriv = dev->private;
+	unsigned int i;
+	uint8_t bitstream;
+	static const int read_bit = 0x1;
+
+	/* XXX need mutex to prevent simultaneous attempts to access
+	 * eeprom and i2c bus */
+
+	/*  make sure we dont send anything to eeprom */
+	devpriv->plx_control_bits &= ~CTL_EE_CS;
+
+	i2c_stop(dev);
+	i2c_start(dev);
+
+	/*  send address and write bit */
+	bitstream = (address << 1) & ~read_bit;
+	i2c_write_byte(dev, bitstream);
+
+	/*  get acknowledge */
+	if (i2c_read_ack(dev) != 0) {
+		comedi_error(dev, "i2c write failed: no acknowledge");
+		i2c_stop(dev);
+		return;
+	}
+	/*  write data bytes */
+	for (i = 0; i < length; i++) {
+		i2c_write_byte(dev, data[i]);
+		if (i2c_read_ack(dev) != 0) {
+			comedi_error(dev, "i2c write failed: no acknowledge");
+			i2c_stop(dev);
+			return;
+		}
+	}
+	i2c_stop(dev);
+}
+
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
@@ -1750,6 +1896,80 @@ static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return -EINVAL;
 }
 
+/* Gets nearest achievable timing given master clock speed, does not
+ * take into account possible minimum/maximum divisor values.  Used
+ * by other timing checking functions. */
+static unsigned int get_divisor(unsigned int ns, unsigned int flags)
+{
+	unsigned int divisor;
+
+	switch (flags & TRIG_ROUND_MASK) {
+	case TRIG_ROUND_UP:
+		divisor = (ns + TIMER_BASE - 1) / TIMER_BASE;
+		break;
+	case TRIG_ROUND_DOWN:
+		divisor = ns / TIMER_BASE;
+		break;
+	case TRIG_ROUND_NEAREST:
+	default:
+		divisor = (ns + TIMER_BASE / 2) / TIMER_BASE;
+		break;
+	}
+	return divisor;
+}
+
+/* utility function that rounds desired timing to an achievable time, and
+ * sets cmd members appropriately.
+ * adc paces conversions from master clock by dividing by (x + 3) where x is 24 bit number
+ */
+static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
+{
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+	unsigned int convert_divisor = 0, scan_divisor;
+	static const int min_convert_divisor = 3;
+	static const int max_convert_divisor =
+		max_counter_value + min_convert_divisor;
+	static const int min_scan_divisor_4020 = 2;
+	unsigned long long max_scan_divisor, min_scan_divisor;
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (thisboard->layout == LAYOUT_4020) {
+			cmd->convert_arg = 0;
+		} else {
+			convert_divisor = get_divisor(cmd->convert_arg,
+						      cmd->flags);
+			if (convert_divisor > max_convert_divisor)
+				convert_divisor = max_convert_divisor;
+			if (convert_divisor < min_convert_divisor)
+				convert_divisor = min_convert_divisor;
+			cmd->convert_arg = convert_divisor * TIMER_BASE;
+		}
+	} else if (cmd->convert_src == TRIG_NOW) {
+		cmd->convert_arg = 0;
+	}
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		scan_divisor = get_divisor(cmd->scan_begin_arg, cmd->flags);
+		if (cmd->convert_src == TRIG_TIMER) {
+			/*  XXX check for integer overflows */
+			min_scan_divisor = convert_divisor * cmd->chanlist_len;
+			max_scan_divisor =
+				(convert_divisor * cmd->chanlist_len - 1) +
+				max_counter_value;
+		} else {
+			min_scan_divisor = min_scan_divisor_4020;
+			max_scan_divisor = max_counter_value + min_scan_divisor;
+		}
+		if (scan_divisor > max_scan_divisor)
+			scan_divisor = max_scan_divisor;
+		if (scan_divisor < min_scan_divisor)
+			scan_divisor = min_scan_divisor;
+		cmd->scan_begin_arg = scan_divisor * TIMER_BASE;
+	}
+
+	return;
+}
+
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
@@ -1957,24 +2177,6 @@ static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 	return num_samples;
 }
 
-static void disable_ai_pacing(struct comedi_device *dev)
-{
-	struct pcidas64_private *devpriv = dev->private;
-	unsigned long flags;
-
-	disable_ai_interrupts(dev);
-
-	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->adc_control1_bits &= ~ADC_SW_GATE_BIT;
-	writew(devpriv->adc_control1_bits,
-	       devpriv->main_iobase + ADC_CONTROL1_REG);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	/* disable pacing, triggering, etc */
-	writew(ADC_DMA_DISABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT,
-	       devpriv->main_iobase + ADC_CONTROL0_REG);
-}
-
 static void disable_ai_interrupts(struct comedi_device *dev)
 {
 	struct pcidas64_private *devpriv = dev->private;
@@ -2817,19 +3019,6 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void abort_dma(struct comedi_device *dev, unsigned int channel)
-{
-	struct pcidas64_private *devpriv = dev->private;
-	unsigned long flags;
-
-	/*  spinlock for plx dma control/status reg */
-	spin_lock_irqsave(&dev->spinlock, flags);
-
-	plx9080_abort_dma(devpriv->plx9080_iobase, channel);
-
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-}
-
 static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pcidas64_private *devpriv = dev->private;
@@ -2952,6 +3141,11 @@ static void set_dac_select_reg(struct comedi_device *dev,
 	writew(bits, devpriv->main_iobase + DAC_SELECT_REG);
 }
 
+static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags)
+{
+	return get_divisor(ns, flags) - 2;
+}
+
 static void set_dac_interval_regs(struct comedi_device *dev,
 				  const struct comedi_cmd *cmd)
 {
@@ -3092,6 +3286,30 @@ static inline int external_ai_queue_in_use(struct comedi_device *dev)
 	return 1;
 }
 
+static int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
+		      unsigned int trig_num)
+{
+	struct pcidas64_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	int retval;
+
+	if (trig_num != 0)
+		return -EINVAL;
+
+	retval = prep_ao_dma(dev, cmd);
+	if (retval < 0)
+		return -EPIPE;
+
+	set_dac_control0_reg(dev, cmd);
+
+	if (cmd->start_src == TRIG_INT)
+		writew(0, devpriv->main_iobase + DAC_START_REG);
+
+	s->async->inttrig = NULL;
+
+	return 0;
+}
+
 static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pcidas64_private *devpriv = dev->private;
@@ -3118,30 +3336,6 @@ static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-		      unsigned int trig_num)
-{
-	struct pcidas64_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
-	int retval;
-
-	if (trig_num != 0)
-		return -EINVAL;
-
-	retval = prep_ao_dma(dev, cmd);
-	if (retval < 0)
-		return -EPIPE;
-
-	set_dac_control0_reg(dev, cmd);
-
-	if (cmd->start_src == TRIG_INT)
-		writew(0, devpriv->main_iobase + DAC_START_REG);
-
-	s->async->inttrig = NULL;
-
-	return 0;
-}
-
 static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
@@ -3346,6 +3540,120 @@ static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
 	return insn->n;
 }
 
+/* pci-6025 8800 caldac:
+ * address 0 == dac channel 0 offset
+ * address 1 == dac channel 0 gain
+ * address 2 == dac channel 1 offset
+ * address 3 == dac channel 1 gain
+ * address 4 == fine adc offset
+ * address 5 == coarse adc offset
+ * address 6 == coarse adc gain
+ * address 7 == fine adc gain
+ */
+/* pci-6402/16 uses all 8 channels for dac:
+ * address 0 == dac channel 0 fine gain
+ * address 1 == dac channel 0 coarse gain
+ * address 2 == dac channel 0 coarse offset
+ * address 3 == dac channel 1 coarse offset
+ * address 4 == dac channel 1 fine gain
+ * address 5 == dac channel 1 coarse gain
+ * address 6 == dac channel 0 fine offset
+ * address 7 == dac channel 1 fine offset
+*/
+
+static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
+			     uint8_t value)
+{
+	struct pcidas64_private *devpriv = dev->private;
+	static const int num_caldac_channels = 8;
+	static const int bitstream_length = 11;
+	unsigned int bitstream = ((address & 0x7) << 8) | value;
+	unsigned int bit, register_bits;
+	static const int caldac_8800_udelay = 1;
+
+	if (address >= num_caldac_channels) {
+		comedi_error(dev, "illegal caldac channel");
+		return -1;
+	}
+	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
+		register_bits = 0;
+		if (bitstream & bit)
+			register_bits |= SERIAL_DATA_IN_BIT;
+		udelay(caldac_8800_udelay);
+		writew(register_bits, devpriv->main_iobase + CALIBRATION_REG);
+		register_bits |= SERIAL_CLOCK_BIT;
+		udelay(caldac_8800_udelay);
+		writew(register_bits, devpriv->main_iobase + CALIBRATION_REG);
+	}
+	udelay(caldac_8800_udelay);
+	writew(SELECT_8800_BIT, devpriv->main_iobase + CALIBRATION_REG);
+	udelay(caldac_8800_udelay);
+	writew(0, devpriv->main_iobase + CALIBRATION_REG);
+	udelay(caldac_8800_udelay);
+	return 0;
+}
+
+/* 4020 caldacs */
+static int caldac_i2c_write(struct comedi_device *dev,
+			    unsigned int caldac_channel, unsigned int value)
+{
+	uint8_t serial_bytes[3];
+	uint8_t i2c_addr;
+	enum pointer_bits {
+		/*  manual has gain and offset bits switched */
+		OFFSET_0_2 = 0x1,
+		GAIN_0_2 = 0x2,
+		OFFSET_1_3 = 0x4,
+		GAIN_1_3 = 0x8,
+	};
+	enum data_bits {
+		NOT_CLEAR_REGISTERS = 0x20,
+	};
+
+	switch (caldac_channel) {
+	case 0:		/*  chan 0 offset */
+		i2c_addr = CALDAC0_I2C_ADDR;
+		serial_bytes[0] = OFFSET_0_2;
+		break;
+	case 1:		/*  chan 1 offset */
+		i2c_addr = CALDAC0_I2C_ADDR;
+		serial_bytes[0] = OFFSET_1_3;
+		break;
+	case 2:		/*  chan 2 offset */
+		i2c_addr = CALDAC1_I2C_ADDR;
+		serial_bytes[0] = OFFSET_0_2;
+		break;
+	case 3:		/*  chan 3 offset */
+		i2c_addr = CALDAC1_I2C_ADDR;
+		serial_bytes[0] = OFFSET_1_3;
+		break;
+	case 4:		/*  chan 0 gain */
+		i2c_addr = CALDAC0_I2C_ADDR;
+		serial_bytes[0] = GAIN_0_2;
+		break;
+	case 5:		/*  chan 1 gain */
+		i2c_addr = CALDAC0_I2C_ADDR;
+		serial_bytes[0] = GAIN_1_3;
+		break;
+	case 6:		/*  chan 2 gain */
+		i2c_addr = CALDAC1_I2C_ADDR;
+		serial_bytes[0] = GAIN_0_2;
+		break;
+	case 7:		/*  chan 3 gain */
+		i2c_addr = CALDAC1_I2C_ADDR;
+		serial_bytes[0] = GAIN_1_3;
+		break;
+	default:
+		comedi_error(dev, "invalid caldac channel\n");
+		return -1;
+		break;
+	}
+	serial_bytes[1] = NOT_CLEAR_REGISTERS | ((value >> 8) & 0xf);
+	serial_bytes[2] = value & 0xff;
+	i2c_write(dev, i2c_addr, serial_bytes, 3);
+	return 0;
+}
+
 static void caldac_write(struct comedi_device *dev, unsigned int channel,
 			 unsigned int value)
 {
@@ -3531,85 +3839,6 @@ static int eeprom_read_insn(struct comedi_device *dev,
 	return 1;
 }
 
-/* utility function that rounds desired timing to an achievable time, and
- * sets cmd members appropriately.
- * adc paces conversions from master clock by dividing by (x + 3) where x is 24 bit number
- */
-static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
-{
-	const struct pcidas64_board *thisboard = comedi_board(dev);
-	unsigned int convert_divisor = 0, scan_divisor;
-	static const int min_convert_divisor = 3;
-	static const int max_convert_divisor =
-		max_counter_value + min_convert_divisor;
-	static const int min_scan_divisor_4020 = 2;
-	unsigned long long max_scan_divisor, min_scan_divisor;
-
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (thisboard->layout == LAYOUT_4020) {
-			cmd->convert_arg = 0;
-		} else {
-			convert_divisor = get_divisor(cmd->convert_arg,
-						      cmd->flags);
-			if (convert_divisor > max_convert_divisor)
-				convert_divisor = max_convert_divisor;
-			if (convert_divisor < min_convert_divisor)
-				convert_divisor = min_convert_divisor;
-			cmd->convert_arg = convert_divisor * TIMER_BASE;
-		}
-	} else if (cmd->convert_src == TRIG_NOW) {
-		cmd->convert_arg = 0;
-	}
-
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		scan_divisor = get_divisor(cmd->scan_begin_arg, cmd->flags);
-		if (cmd->convert_src == TRIG_TIMER) {
-			/*  XXX check for integer overflows */
-			min_scan_divisor = convert_divisor * cmd->chanlist_len;
-			max_scan_divisor =
-				(convert_divisor * cmd->chanlist_len - 1) +
-				max_counter_value;
-		} else {
-			min_scan_divisor = min_scan_divisor_4020;
-			max_scan_divisor = max_counter_value + min_scan_divisor;
-		}
-		if (scan_divisor > max_scan_divisor)
-			scan_divisor = max_scan_divisor;
-		if (scan_divisor < min_scan_divisor)
-			scan_divisor = min_scan_divisor;
-		cmd->scan_begin_arg = scan_divisor * TIMER_BASE;
-	}
-
-	return;
-}
-
-/* Gets nearest achievable timing given master clock speed, does not
- * take into account possible minimum/maximum divisor values.  Used
- * by other timing checking functions. */
-static unsigned int get_divisor(unsigned int ns, unsigned int flags)
-{
-	unsigned int divisor;
-
-	switch (flags & TRIG_ROUND_MASK) {
-	case TRIG_ROUND_UP:
-		divisor = (ns + TIMER_BASE - 1) / TIMER_BASE;
-		break;
-	case TRIG_ROUND_DOWN:
-		divisor = ns / TIMER_BASE;
-		break;
-	case TRIG_ROUND_NEAREST:
-	default:
-		divisor = (ns + TIMER_BASE / 2) / TIMER_BASE;
-		break;
-	}
-	return divisor;
-}
-
-static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags)
-{
-	return get_divisor(ns, flags) - 2;
-}
-
 /* adjusts the size of hardware fifo (which determines block size for dma xfers) */
 static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 {
@@ -3676,249 +3905,6 @@ static int set_ai_fifo_segment_length(struct comedi_device *dev,
 	return devpriv->ai_fifo_segment_length;
 }
 
-/* pci-6025 8800 caldac:
- * address 0 == dac channel 0 offset
- * address 1 == dac channel 0 gain
- * address 2 == dac channel 1 offset
- * address 3 == dac channel 1 gain
- * address 4 == fine adc offset
- * address 5 == coarse adc offset
- * address 6 == coarse adc gain
- * address 7 == fine adc gain
- */
-/* pci-6402/16 uses all 8 channels for dac:
- * address 0 == dac channel 0 fine gain
- * address 1 == dac channel 0 coarse gain
- * address 2 == dac channel 0 coarse offset
- * address 3 == dac channel 1 coarse offset
- * address 4 == dac channel 1 fine gain
- * address 5 == dac channel 1 coarse gain
- * address 6 == dac channel 0 fine offset
- * address 7 == dac channel 1 fine offset
-*/
-
-static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-			     uint8_t value)
-{
-	struct pcidas64_private *devpriv = dev->private;
-	static const int num_caldac_channels = 8;
-	static const int bitstream_length = 11;
-	unsigned int bitstream = ((address & 0x7) << 8) | value;
-	unsigned int bit, register_bits;
-	static const int caldac_8800_udelay = 1;
-
-	if (address >= num_caldac_channels) {
-		comedi_error(dev, "illegal caldac channel");
-		return -1;
-	}
-	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
-		register_bits = 0;
-		if (bitstream & bit)
-			register_bits |= SERIAL_DATA_IN_BIT;
-		udelay(caldac_8800_udelay);
-		writew(register_bits, devpriv->main_iobase + CALIBRATION_REG);
-		register_bits |= SERIAL_CLOCK_BIT;
-		udelay(caldac_8800_udelay);
-		writew(register_bits, devpriv->main_iobase + CALIBRATION_REG);
-	}
-	udelay(caldac_8800_udelay);
-	writew(SELECT_8800_BIT, devpriv->main_iobase + CALIBRATION_REG);
-	udelay(caldac_8800_udelay);
-	writew(0, devpriv->main_iobase + CALIBRATION_REG);
-	udelay(caldac_8800_udelay);
-	return 0;
-}
-
-/* 4020 caldacs */
-static int caldac_i2c_write(struct comedi_device *dev,
-			    unsigned int caldac_channel, unsigned int value)
-{
-	uint8_t serial_bytes[3];
-	uint8_t i2c_addr;
-	enum pointer_bits {
-		/*  manual has gain and offset bits switched */
-		OFFSET_0_2 = 0x1,
-		GAIN_0_2 = 0x2,
-		OFFSET_1_3 = 0x4,
-		GAIN_1_3 = 0x8,
-	};
-	enum data_bits {
-		NOT_CLEAR_REGISTERS = 0x20,
-	};
-
-	switch (caldac_channel) {
-	case 0:		/*  chan 0 offset */
-		i2c_addr = CALDAC0_I2C_ADDR;
-		serial_bytes[0] = OFFSET_0_2;
-		break;
-	case 1:		/*  chan 1 offset */
-		i2c_addr = CALDAC0_I2C_ADDR;
-		serial_bytes[0] = OFFSET_1_3;
-		break;
-	case 2:		/*  chan 2 offset */
-		i2c_addr = CALDAC1_I2C_ADDR;
-		serial_bytes[0] = OFFSET_0_2;
-		break;
-	case 3:		/*  chan 3 offset */
-		i2c_addr = CALDAC1_I2C_ADDR;
-		serial_bytes[0] = OFFSET_1_3;
-		break;
-	case 4:		/*  chan 0 gain */
-		i2c_addr = CALDAC0_I2C_ADDR;
-		serial_bytes[0] = GAIN_0_2;
-		break;
-	case 5:		/*  chan 1 gain */
-		i2c_addr = CALDAC0_I2C_ADDR;
-		serial_bytes[0] = GAIN_1_3;
-		break;
-	case 6:		/*  chan 2 gain */
-		i2c_addr = CALDAC1_I2C_ADDR;
-		serial_bytes[0] = GAIN_0_2;
-		break;
-	case 7:		/*  chan 3 gain */
-		i2c_addr = CALDAC1_I2C_ADDR;
-		serial_bytes[0] = GAIN_1_3;
-		break;
-	default:
-		comedi_error(dev, "invalid caldac channel\n");
-		return -1;
-		break;
-	}
-	serial_bytes[1] = NOT_CLEAR_REGISTERS | ((value >> 8) & 0xf);
-	serial_bytes[2] = value & 0xff;
-	i2c_write(dev, i2c_addr, serial_bytes, 3);
-	return 0;
-}
-
-/* Their i2c requires a huge delay on setting clock or data high for some reason */
-static const int i2c_high_udelay = 1000;
-static const int i2c_low_udelay = 10;
-
-/* set i2c data line high or low */
-static void i2c_set_sda(struct comedi_device *dev, int state)
-{
-	struct pcidas64_private *devpriv = dev->private;
-	static const int data_bit = CTL_EE_W;
-	void __iomem *plx_control_addr = devpriv->plx9080_iobase +
-					 PLX_CONTROL_REG;
-
-	if (state) {
-		/*  set data line high */
-		devpriv->plx_control_bits &= ~data_bit;
-		writel(devpriv->plx_control_bits, plx_control_addr);
-		udelay(i2c_high_udelay);
-	} else {		/*  set data line low */
-
-		devpriv->plx_control_bits |= data_bit;
-		writel(devpriv->plx_control_bits, plx_control_addr);
-		udelay(i2c_low_udelay);
-	}
-}
-
-/* set i2c clock line high or low */
-static void i2c_set_scl(struct comedi_device *dev, int state)
-{
-	struct pcidas64_private *devpriv = dev->private;
-	static const int clock_bit = CTL_USERO;
-	void __iomem *plx_control_addr = devpriv->plx9080_iobase +
-					 PLX_CONTROL_REG;
-
-	if (state) {
-		/*  set clock line high */
-		devpriv->plx_control_bits &= ~clock_bit;
-		writel(devpriv->plx_control_bits, plx_control_addr);
-		udelay(i2c_high_udelay);
-	} else {		/*  set clock line low */
-
-		devpriv->plx_control_bits |= clock_bit;
-		writel(devpriv->plx_control_bits, plx_control_addr);
-		udelay(i2c_low_udelay);
-	}
-}
-
-static void i2c_write_byte(struct comedi_device *dev, uint8_t byte)
-{
-	uint8_t bit;
-	unsigned int num_bits = 8;
-
-	DEBUG_PRINT("writing to i2c byte 0x%x\n", byte);
-
-	for (bit = 1 << (num_bits - 1); bit; bit >>= 1) {
-		i2c_set_scl(dev, 0);
-		if ((byte & bit))
-			i2c_set_sda(dev, 1);
-		else
-			i2c_set_sda(dev, 0);
-		i2c_set_scl(dev, 1);
-	}
-}
-
-/* we can't really read the lines, so fake it */
-static int i2c_read_ack(struct comedi_device *dev)
-{
-	i2c_set_scl(dev, 0);
-	i2c_set_sda(dev, 1);
-	i2c_set_scl(dev, 1);
-
-	return 0;		/*  return fake acknowledge bit */
-}
-
-/* send start bit */
-static void i2c_start(struct comedi_device *dev)
-{
-	i2c_set_scl(dev, 1);
-	i2c_set_sda(dev, 1);
-	i2c_set_sda(dev, 0);
-}
-
-/* send stop bit */
-static void i2c_stop(struct comedi_device *dev)
-{
-	i2c_set_scl(dev, 0);
-	i2c_set_sda(dev, 0);
-	i2c_set_scl(dev, 1);
-	i2c_set_sda(dev, 1);
-}
-
-static void i2c_write(struct comedi_device *dev, unsigned int address,
-		      const uint8_t *data, unsigned int length)
-{
-	struct pcidas64_private *devpriv = dev->private;
-	unsigned int i;
-	uint8_t bitstream;
-	static const int read_bit = 0x1;
-
-	/* XXX need mutex to prevent simultaneous attempts to access
-	 * eeprom and i2c bus */
-
-	/*  make sure we dont send anything to eeprom */
-	devpriv->plx_control_bits &= ~CTL_EE_CS;
-
-	i2c_stop(dev);
-	i2c_start(dev);
-
-	/*  send address and write bit */
-	bitstream = (address << 1) & ~read_bit;
-	i2c_write_byte(dev, bitstream);
-
-	/*  get acknowledge */
-	if (i2c_read_ack(dev) != 0) {
-		comedi_error(dev, "i2c write failed: no acknowledge");
-		i2c_stop(dev);
-		return;
-	}
-	/*  write data bytes */
-	for (i = 0; i < length; i++) {
-		i2c_write_byte(dev, data[i]);
-		if (i2c_read_ack(dev) != 0) {
-			comedi_error(dev, "i2c write failed: no acknowledge");
-			i2c_stop(dev);
-			return;
-		}
-	}
-	i2c_stop(dev);
-}
-
 /* Allocate and initialize the subdevice structures.
  */
 static int setup_subdevices(struct comedi_device *dev)

commit a299d8817d9656bc5fc9192f0369b2202d5b5a01
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 2 19:18:03 2012 +0000

    staging: comedi: cb_pcidas64: fix forward declarations 2
    
    Move `cb_pcidas64_find_pci_board()`, `auto_attach()` and `detach()` and
    remove the forward declaration of `setup_subdevices()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 2d3f58628ee2..a88e879c8d90 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1151,7 +1151,6 @@ struct pcidas64_private {
 	short ao_bounce_buffer[DAC_FIFO_SIZE];
 };
 
-static int setup_subdevices(struct comedi_device *dev);
 static int ao_inttrig(struct comedi_device *dev,
 		      struct comedi_subdevice *subdev, unsigned int trig_num);
 static irqreturn_t handle_interrupt(int irq, void *d);
@@ -1496,181 +1495,6 @@ static inline void warn_external_queue(struct comedi_device *dev)
 		     "Use internal AI channel queue (channels must be consecutive and use same range/aref)");
 }
 
-static const struct pcidas64_board
-*cb_pcidas64_find_pci_board(struct pci_dev *pcidev)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(pcidas64_boards); i++)
-		if (pcidev->device == pcidas64_boards[i].device_id)
-			return &pcidas64_boards[i];
-	return NULL;
-}
-
-static int __devinit auto_attach(struct comedi_device *dev,
-				 unsigned long context_unused)
-{
-	const struct pcidas64_board *thisboard;
-	struct pcidas64_private *devpriv;
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	uint32_t local_range, local_decode;
-	int retval;
-
-	dev->board_ptr = cb_pcidas64_find_pci_board(pcidev);
-	if (!dev->board_ptr) {
-		dev_err(dev->class_dev,
-			"cb_pcidas64: does not support pci %s\n",
-			pci_name(pcidev));
-		return -EINVAL;
-	}
-	thisboard = comedi_board(dev);
-
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
-	if (!devpriv)
-		return -ENOMEM;
-	dev->private = devpriv;
-
-	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
-		dev_warn(dev->class_dev,
-			 "failed to enable PCI device and request regions\n");
-		return -EIO;
-	}
-	pci_set_master(pcidev);
-
-	/* Initialize dev->board_name */
-	dev->board_name = thisboard->name;
-
-	dev->iobase = pci_resource_start(pcidev, MAIN_BADDRINDEX);
-
-	devpriv->plx9080_phys_iobase =
-		pci_resource_start(pcidev, PLX9080_BADDRINDEX);
-	devpriv->main_phys_iobase = dev->iobase;
-	devpriv->dio_counter_phys_iobase =
-		pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
-
-	/*  remap, won't work with 2.0 kernels but who cares */
-	devpriv->plx9080_iobase =
-		ioremap(devpriv->plx9080_phys_iobase,
-			pci_resource_len(pcidev, PLX9080_BADDRINDEX));
-	devpriv->main_iobase =
-		ioremap(devpriv->main_phys_iobase,
-			pci_resource_len(pcidev, MAIN_BADDRINDEX));
-	devpriv->dio_counter_iobase =
-		ioremap(devpriv->dio_counter_phys_iobase,
-			pci_resource_len(pcidev, DIO_COUNTER_BADDRINDEX));
-
-	if (!devpriv->plx9080_iobase || !devpriv->main_iobase
-	    || !devpriv->dio_counter_iobase) {
-		dev_warn(dev->class_dev, "failed to remap io memory\n");
-		return -ENOMEM;
-	}
-
-	DEBUG_PRINT(" plx9080 remapped to 0x%p\n", devpriv->plx9080_iobase);
-	DEBUG_PRINT(" main remapped to 0x%p\n", devpriv->main_iobase);
-	DEBUG_PRINT(" diocounter remapped to 0x%p\n",
-		    devpriv->dio_counter_iobase);
-
-	/*  figure out what local addresses are */
-	local_range = readl(devpriv->plx9080_iobase + PLX_LAS0RNG_REG) &
-		      LRNG_MEM_MASK;
-	local_decode = readl(devpriv->plx9080_iobase + PLX_LAS0MAP_REG) &
-		       local_range & LMAP_MEM_MASK;
-	devpriv->local0_iobase = ((uint32_t)devpriv->main_phys_iobase &
-				  ~local_range) | local_decode;
-	local_range = readl(devpriv->plx9080_iobase + PLX_LAS1RNG_REG) &
-		      LRNG_MEM_MASK;
-	local_decode = readl(devpriv->plx9080_iobase + PLX_LAS1MAP_REG) &
-		       local_range & LMAP_MEM_MASK;
-	devpriv->local1_iobase = ((uint32_t)devpriv->dio_counter_phys_iobase &
-				  ~local_range) | local_decode;
-
-	DEBUG_PRINT(" local 0 io addr 0x%x\n", devpriv->local0_iobase);
-	DEBUG_PRINT(" local 1 io addr 0x%x\n", devpriv->local1_iobase);
-
-	retval = alloc_and_init_dma_members(dev);
-	if (retval < 0)
-		return retval;
-
-	devpriv->hw_revision =
-		hw_revision(dev, readw(devpriv->main_iobase + HW_STATUS_REG));
-	dev_dbg(dev->class_dev, "stc hardware revision %i\n",
-		devpriv->hw_revision);
-	init_plx9080(dev);
-	init_stc_registers(dev);
-	/*  get irq */
-	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
-			"cb_pcidas64", dev)) {
-		dev_dbg(dev->class_dev, "unable to allocate irq %u\n",
-			pcidev->irq);
-		return -EINVAL;
-	}
-	dev->irq = pcidev->irq;
-	dev_dbg(dev->class_dev, "irq %u\n", dev->irq);
-
-	retval = setup_subdevices(dev);
-	if (retval < 0)
-		return retval;
-
-	return 0;
-}
-
-static void detach(struct comedi_device *dev)
-{
-	const struct pcidas64_board *thisboard = comedi_board(dev);
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	struct pcidas64_private *devpriv = dev->private;
-	unsigned int i;
-
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	if (devpriv) {
-		if (pcidev) {
-			if (devpriv->plx9080_iobase) {
-				disable_plx_interrupts(dev);
-				iounmap(devpriv->plx9080_iobase);
-			}
-			if (devpriv->main_iobase)
-				iounmap(devpriv->main_iobase);
-			if (devpriv->dio_counter_iobase)
-				iounmap(devpriv->dio_counter_iobase);
-			/*  free pci dma buffers */
-			for (i = 0; i < ai_dma_ring_count(thisboard); i++) {
-				if (devpriv->ai_buffer[i])
-					pci_free_consistent(pcidev,
-						DMA_BUFFER_SIZE,
-						devpriv->ai_buffer[i],
-						devpriv->ai_buffer_bus_addr[i]);
-			}
-			for (i = 0; i < AO_DMA_RING_COUNT; i++) {
-				if (devpriv->ao_buffer[i])
-					pci_free_consistent(pcidev,
-						DMA_BUFFER_SIZE,
-						devpriv->ao_buffer[i],
-						devpriv->ao_buffer_bus_addr[i]);
-			}
-			/*  free dma descriptors */
-			if (devpriv->ai_dma_desc)
-				pci_free_consistent(pcidev,
-					sizeof(struct plx_dma_desc) *
-					ai_dma_ring_count(thisboard),
-					devpriv->ai_dma_desc,
-					devpriv->ai_dma_desc_bus_addr);
-			if (devpriv->ao_dma_desc)
-				pci_free_consistent(pcidev,
-					sizeof(struct plx_dma_desc) *
-					AO_DMA_RING_COUNT,
-					devpriv->ao_dma_desc,
-					devpriv->ao_dma_desc_bus_addr);
-		}
-	}
-	if (dev->subdevices)
-		subdev_8255_cleanup(dev, &dev->subdevices[4]);
-	if (pcidev) {
-		if (dev->iobase)
-			comedi_pci_disable(pcidev);
-	}
-}
-
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
@@ -4262,6 +4086,181 @@ static int setup_subdevices(struct comedi_device *dev)
 	return 0;
 }
 
+static const struct pcidas64_board
+*cb_pcidas64_find_pci_board(struct pci_dev *pcidev)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(pcidas64_boards); i++)
+		if (pcidev->device == pcidas64_boards[i].device_id)
+			return &pcidas64_boards[i];
+	return NULL;
+}
+
+static int __devinit auto_attach(struct comedi_device *dev,
+				 unsigned long context_unused)
+{
+	const struct pcidas64_board *thisboard;
+	struct pcidas64_private *devpriv;
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	uint32_t local_range, local_decode;
+	int retval;
+
+	dev->board_ptr = cb_pcidas64_find_pci_board(pcidev);
+	if (!dev->board_ptr) {
+		dev_err(dev->class_dev,
+			"cb_pcidas64: does not support pci %s\n",
+			pci_name(pcidev));
+		return -EINVAL;
+	}
+	thisboard = comedi_board(dev);
+
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
+
+	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
+		dev_warn(dev->class_dev,
+			 "failed to enable PCI device and request regions\n");
+		return -EIO;
+	}
+	pci_set_master(pcidev);
+
+	/* Initialize dev->board_name */
+	dev->board_name = thisboard->name;
+
+	dev->iobase = pci_resource_start(pcidev, MAIN_BADDRINDEX);
+
+	devpriv->plx9080_phys_iobase =
+		pci_resource_start(pcidev, PLX9080_BADDRINDEX);
+	devpriv->main_phys_iobase = dev->iobase;
+	devpriv->dio_counter_phys_iobase =
+		pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
+
+	/*  remap, won't work with 2.0 kernels but who cares */
+	devpriv->plx9080_iobase =
+		ioremap(devpriv->plx9080_phys_iobase,
+			pci_resource_len(pcidev, PLX9080_BADDRINDEX));
+	devpriv->main_iobase =
+		ioremap(devpriv->main_phys_iobase,
+			pci_resource_len(pcidev, MAIN_BADDRINDEX));
+	devpriv->dio_counter_iobase =
+		ioremap(devpriv->dio_counter_phys_iobase,
+			pci_resource_len(pcidev, DIO_COUNTER_BADDRINDEX));
+
+	if (!devpriv->plx9080_iobase || !devpriv->main_iobase
+	    || !devpriv->dio_counter_iobase) {
+		dev_warn(dev->class_dev, "failed to remap io memory\n");
+		return -ENOMEM;
+	}
+
+	DEBUG_PRINT(" plx9080 remapped to 0x%p\n", devpriv->plx9080_iobase);
+	DEBUG_PRINT(" main remapped to 0x%p\n", devpriv->main_iobase);
+	DEBUG_PRINT(" diocounter remapped to 0x%p\n",
+		    devpriv->dio_counter_iobase);
+
+	/*  figure out what local addresses are */
+	local_range = readl(devpriv->plx9080_iobase + PLX_LAS0RNG_REG) &
+		      LRNG_MEM_MASK;
+	local_decode = readl(devpriv->plx9080_iobase + PLX_LAS0MAP_REG) &
+		       local_range & LMAP_MEM_MASK;
+	devpriv->local0_iobase = ((uint32_t)devpriv->main_phys_iobase &
+				  ~local_range) | local_decode;
+	local_range = readl(devpriv->plx9080_iobase + PLX_LAS1RNG_REG) &
+		      LRNG_MEM_MASK;
+	local_decode = readl(devpriv->plx9080_iobase + PLX_LAS1MAP_REG) &
+		       local_range & LMAP_MEM_MASK;
+	devpriv->local1_iobase = ((uint32_t)devpriv->dio_counter_phys_iobase &
+				  ~local_range) | local_decode;
+
+	DEBUG_PRINT(" local 0 io addr 0x%x\n", devpriv->local0_iobase);
+	DEBUG_PRINT(" local 1 io addr 0x%x\n", devpriv->local1_iobase);
+
+	retval = alloc_and_init_dma_members(dev);
+	if (retval < 0)
+		return retval;
+
+	devpriv->hw_revision =
+		hw_revision(dev, readw(devpriv->main_iobase + HW_STATUS_REG));
+	dev_dbg(dev->class_dev, "stc hardware revision %i\n",
+		devpriv->hw_revision);
+	init_plx9080(dev);
+	init_stc_registers(dev);
+	/*  get irq */
+	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
+			"cb_pcidas64", dev)) {
+		dev_dbg(dev->class_dev, "unable to allocate irq %u\n",
+			pcidev->irq);
+		return -EINVAL;
+	}
+	dev->irq = pcidev->irq;
+	dev_dbg(dev->class_dev, "irq %u\n", dev->irq);
+
+	retval = setup_subdevices(dev);
+	if (retval < 0)
+		return retval;
+
+	return 0;
+}
+
+static void detach(struct comedi_device *dev)
+{
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct pcidas64_private *devpriv = dev->private;
+	unsigned int i;
+
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	if (devpriv) {
+		if (pcidev) {
+			if (devpriv->plx9080_iobase) {
+				disable_plx_interrupts(dev);
+				iounmap(devpriv->plx9080_iobase);
+			}
+			if (devpriv->main_iobase)
+				iounmap(devpriv->main_iobase);
+			if (devpriv->dio_counter_iobase)
+				iounmap(devpriv->dio_counter_iobase);
+			/*  free pci dma buffers */
+			for (i = 0; i < ai_dma_ring_count(thisboard); i++) {
+				if (devpriv->ai_buffer[i])
+					pci_free_consistent(pcidev,
+						DMA_BUFFER_SIZE,
+						devpriv->ai_buffer[i],
+						devpriv->ai_buffer_bus_addr[i]);
+			}
+			for (i = 0; i < AO_DMA_RING_COUNT; i++) {
+				if (devpriv->ao_buffer[i])
+					pci_free_consistent(pcidev,
+						DMA_BUFFER_SIZE,
+						devpriv->ao_buffer[i],
+						devpriv->ao_buffer_bus_addr[i]);
+			}
+			/*  free dma descriptors */
+			if (devpriv->ai_dma_desc)
+				pci_free_consistent(pcidev,
+					sizeof(struct plx_dma_desc) *
+					ai_dma_ring_count(thisboard),
+					devpriv->ai_dma_desc,
+					devpriv->ai_dma_desc_bus_addr);
+			if (devpriv->ao_dma_desc)
+				pci_free_consistent(pcidev,
+					sizeof(struct plx_dma_desc) *
+					AO_DMA_RING_COUNT,
+					devpriv->ao_dma_desc,
+					devpriv->ao_dma_desc_bus_addr);
+		}
+	}
+	if (dev->subdevices)
+		subdev_8255_cleanup(dev, &dev->subdevices[4]);
+	if (pcidev) {
+		if (dev->iobase)
+			comedi_pci_disable(pcidev);
+	}
+}
+
 static struct comedi_driver cb_pcidas64_driver = {
 	.driver_name	= "cb_pcidas64",
 	.module		= THIS_MODULE,

commit 9c7a00f572266305322824403241c4aa21f46b8a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 2 19:18:02 2012 +0000

    staging: comedi: cb_pcidas64: fix forward declarations 1
    
    Move `setup_subdevices()` and remove a load of forward declarations.
    Added a forward declaration of `setup_subdevices()` temporarily.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 803220be6b24..2d3f58628ee2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1151,64 +1151,16 @@ struct pcidas64_private {
 	short ao_bounce_buffer[DAC_FIFO_SIZE];
 };
 
-static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-		    struct comedi_insn *insn, unsigned int *data);
-static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data);
-static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-		    struct comedi_insn *insn, unsigned int *data);
-static int ao_readback_insn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-		      struct comedi_cmd *cmd);
-static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int setup_subdevices(struct comedi_device *dev);
 static int ao_inttrig(struct comedi_device *dev,
 		      struct comedi_subdevice *subdev, unsigned int trig_num);
-static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-		      struct comedi_cmd *cmd);
 static irqreturn_t handle_interrupt(int irq, void *d);
-static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static int dio_callback(int dir, int port, int data, unsigned long arg);
-static int dio_callback_4020(int dir, int port, int data, unsigned long arg);
-static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-		    struct comedi_insn *insn, unsigned int *data);
-static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-		    struct comedi_insn *insn, unsigned int *data);
-static int dio_60xx_config_insn(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data);
-static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data);
-static int calib_read_insn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data);
-static int calib_write_insn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-static int ad8402_read_insn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-static void ad8402_write(struct comedi_device *dev, unsigned int channel,
-			 unsigned int value);
-static int ad8402_write_insn(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data);
-static int eeprom_read_insn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
 static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd);
 static unsigned int get_divisor(unsigned int ns, unsigned int flags);
 static void i2c_write(struct comedi_device *dev, unsigned int address,
 		      const uint8_t *data, unsigned int length);
-static void caldac_write(struct comedi_device *dev, unsigned int channel,
-			 unsigned int value);
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 			     uint8_t value);
-/* static int dac_1590_write(struct comedi_device *dev, unsigned int dac_a,
- *                           unsigned int dac_b); */
 static int caldac_i2c_write(struct comedi_device *dev,
 			    unsigned int caldac_channel, unsigned int value);
 static void abort_dma(struct comedi_device *dev, unsigned int channel);
@@ -1220,8 +1172,6 @@ static int set_ai_fifo_segment_length(struct comedi_device *dev,
 				      unsigned int num_entries);
 static void disable_ai_pacing(struct comedi_device *dev);
 static void disable_ai_interrupts(struct comedi_device *dev);
-static void enable_ai_interrupts(struct comedi_device *dev,
-				 const struct comedi_cmd *cmd);
 static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags);
 static void load_ao_dma(struct comedi_device *dev,
 			const struct comedi_cmd *cmd);
@@ -1395,173 +1345,6 @@ static void init_plx9080(struct comedi_device *dev)
 	       devpriv->plx9080_iobase + PLX_INTRCS_REG);
 }
 
-/* Allocate and initialize the subdevice structures.
- */
-static int setup_subdevices(struct comedi_device *dev)
-{
-	const struct pcidas64_board *thisboard = comedi_board(dev);
-	struct pcidas64_private *devpriv = dev->private;
-	struct comedi_subdevice *s;
-	void __iomem *dio_8255_iobase;
-	int i;
-	int ret;
-
-	ret = comedi_alloc_subdevices(dev, 10);
-	if (ret)
-		return ret;
-
-	s = &dev->subdevices[0];
-	/* analog input subdevice */
-	dev->read_subdev = s;
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DITHER | SDF_CMD_READ;
-	if (thisboard->layout == LAYOUT_60XX)
-		s->subdev_flags |= SDF_COMMON | SDF_DIFF;
-	else if (thisboard->layout == LAYOUT_64XX)
-		s->subdev_flags |= SDF_DIFF;
-	/* XXX Number of inputs in differential mode is ignored */
-	s->n_chan = thisboard->ai_se_chans;
-	s->len_chanlist = 0x2000;
-	s->maxdata = (1 << thisboard->ai_bits) - 1;
-	s->range_table = thisboard->ai_range_table;
-	s->insn_read = ai_rinsn;
-	s->insn_config = ai_config_insn;
-	s->do_cmd = ai_cmd;
-	s->do_cmdtest = ai_cmdtest;
-	s->cancel = ai_cancel;
-	if (thisboard->layout == LAYOUT_4020) {
-		uint8_t data;
-		/*  set adc to read from inputs
-		 *  (not internal calibration sources) */
-		devpriv->i2c_cal_range_bits = adc_src_4020_bits(4);
-		/*  set channels to +-5 volt input ranges */
-		for (i = 0; i < s->n_chan; i++)
-			devpriv->i2c_cal_range_bits |= attenuate_bit(i);
-		data = devpriv->i2c_cal_range_bits;
-		i2c_write(dev, RANGE_CAL_I2C_ADDR, &data, sizeof(data));
-	}
-
-	/* analog output subdevice */
-	s = &dev->subdevices[1];
-	if (thisboard->ao_nchan) {
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE |
-				  SDF_GROUND | SDF_CMD_WRITE;
-		s->n_chan = thisboard->ao_nchan;
-		s->maxdata = (1 << thisboard->ao_bits) - 1;
-		s->range_table = thisboard->ao_range_table;
-		s->insn_read = ao_readback_insn;
-		s->insn_write = ao_winsn;
-		if (ao_cmd_is_supported(thisboard)) {
-			dev->write_subdev = s;
-			s->do_cmdtest = ao_cmdtest;
-			s->do_cmd = ao_cmd;
-			s->len_chanlist = thisboard->ao_nchan;
-			s->cancel = ao_cancel;
-		}
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
-
-	/*  digital input */
-	s = &dev->subdevices[2];
-	if (thisboard->layout == LAYOUT_64XX) {
-		s->type = COMEDI_SUBD_DI;
-		s->subdev_flags = SDF_READABLE;
-		s->n_chan = 4;
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->insn_bits = di_rbits;
-	} else
-		s->type = COMEDI_SUBD_UNUSED;
-
-	/*  digital output */
-	if (thisboard->layout == LAYOUT_64XX) {
-		s = &dev->subdevices[3];
-		s->type = COMEDI_SUBD_DO;
-		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-		s->n_chan = 4;
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->insn_bits = do_wbits;
-	} else
-		s->type = COMEDI_SUBD_UNUSED;
-
-	/* 8255 */
-	s = &dev->subdevices[4];
-	if (thisboard->has_8255) {
-		if (thisboard->layout == LAYOUT_4020) {
-			dio_8255_iobase = devpriv->main_iobase + I8255_4020_REG;
-			subdev_8255_init(dev, s, dio_callback_4020,
-					 (unsigned long)dio_8255_iobase);
-		} else {
-			dio_8255_iobase =
-				devpriv->dio_counter_iobase + DIO_8255_OFFSET;
-			subdev_8255_init(dev, s, dio_callback,
-					 (unsigned long)dio_8255_iobase);
-		}
-	} else
-		s->type = COMEDI_SUBD_UNUSED;
-
-	/*  8 channel dio for 60xx */
-	s = &dev->subdevices[5];
-	if (thisboard->layout == LAYOUT_60XX) {
-		s->type = COMEDI_SUBD_DIO;
-		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-		s->n_chan = 8;
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->insn_config = dio_60xx_config_insn;
-		s->insn_bits = dio_60xx_wbits;
-	} else
-		s->type = COMEDI_SUBD_UNUSED;
-
-	/*  caldac */
-	s = &dev->subdevices[6];
-	s->type = COMEDI_SUBD_CALIB;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-	s->n_chan = 8;
-	if (thisboard->layout == LAYOUT_4020)
-		s->maxdata = 0xfff;
-	else
-		s->maxdata = 0xff;
-	s->insn_read = calib_read_insn;
-	s->insn_write = calib_write_insn;
-	for (i = 0; i < s->n_chan; i++)
-		caldac_write(dev, i, s->maxdata / 2);
-
-	/*  2 channel ad8402 potentiometer */
-	s = &dev->subdevices[7];
-	if (thisboard->layout == LAYOUT_64XX) {
-		s->type = COMEDI_SUBD_CALIB;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-		s->n_chan = 2;
-		s->insn_read = ad8402_read_insn;
-		s->insn_write = ad8402_write_insn;
-		s->maxdata = 0xff;
-		for (i = 0; i < s->n_chan; i++)
-			ad8402_write(dev, i, s->maxdata / 2);
-	} else
-		s->type = COMEDI_SUBD_UNUSED;
-
-	/* serial EEPROM, if present */
-	s = &dev->subdevices[8];
-	if (readl(devpriv->plx9080_iobase + PLX_CONTROL_REG) & CTL_EECHK) {
-		s->type = COMEDI_SUBD_MEMORY;
-		s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
-		s->n_chan = 128;
-		s->maxdata = 0xffff;
-		s->insn_read = eeprom_read_insn;
-	} else
-		s->type = COMEDI_SUBD_UNUSED;
-
-	/*  user counter subd XXX */
-	s = &dev->subdevices[9];
-	s->type = COMEDI_SUBD_UNUSED;
-
-	return 0;
-}
-
 static void disable_plx_interrupts(struct comedi_device *dev)
 {
 	struct pcidas64_private *devpriv = dev->private;
@@ -4312,6 +4095,173 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 	i2c_stop(dev);
 }
 
+/* Allocate and initialize the subdevice structures.
+ */
+static int setup_subdevices(struct comedi_device *dev)
+{
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+	struct pcidas64_private *devpriv = dev->private;
+	struct comedi_subdevice *s;
+	void __iomem *dio_8255_iobase;
+	int i;
+	int ret;
+
+	ret = comedi_alloc_subdevices(dev, 10);
+	if (ret)
+		return ret;
+
+	s = &dev->subdevices[0];
+	/* analog input subdevice */
+	dev->read_subdev = s;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DITHER | SDF_CMD_READ;
+	if (thisboard->layout == LAYOUT_60XX)
+		s->subdev_flags |= SDF_COMMON | SDF_DIFF;
+	else if (thisboard->layout == LAYOUT_64XX)
+		s->subdev_flags |= SDF_DIFF;
+	/* XXX Number of inputs in differential mode is ignored */
+	s->n_chan = thisboard->ai_se_chans;
+	s->len_chanlist = 0x2000;
+	s->maxdata = (1 << thisboard->ai_bits) - 1;
+	s->range_table = thisboard->ai_range_table;
+	s->insn_read = ai_rinsn;
+	s->insn_config = ai_config_insn;
+	s->do_cmd = ai_cmd;
+	s->do_cmdtest = ai_cmdtest;
+	s->cancel = ai_cancel;
+	if (thisboard->layout == LAYOUT_4020) {
+		uint8_t data;
+		/*  set adc to read from inputs
+		 *  (not internal calibration sources) */
+		devpriv->i2c_cal_range_bits = adc_src_4020_bits(4);
+		/*  set channels to +-5 volt input ranges */
+		for (i = 0; i < s->n_chan; i++)
+			devpriv->i2c_cal_range_bits |= attenuate_bit(i);
+		data = devpriv->i2c_cal_range_bits;
+		i2c_write(dev, RANGE_CAL_I2C_ADDR, &data, sizeof(data));
+	}
+
+	/* analog output subdevice */
+	s = &dev->subdevices[1];
+	if (thisboard->ao_nchan) {
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE |
+				  SDF_GROUND | SDF_CMD_WRITE;
+		s->n_chan = thisboard->ao_nchan;
+		s->maxdata = (1 << thisboard->ao_bits) - 1;
+		s->range_table = thisboard->ao_range_table;
+		s->insn_read = ao_readback_insn;
+		s->insn_write = ao_winsn;
+		if (ao_cmd_is_supported(thisboard)) {
+			dev->write_subdev = s;
+			s->do_cmdtest = ao_cmdtest;
+			s->do_cmd = ao_cmd;
+			s->len_chanlist = thisboard->ao_nchan;
+			s->cancel = ao_cancel;
+		}
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/*  digital input */
+	s = &dev->subdevices[2];
+	if (thisboard->layout == LAYOUT_64XX) {
+		s->type = COMEDI_SUBD_DI;
+		s->subdev_flags = SDF_READABLE;
+		s->n_chan = 4;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->insn_bits = di_rbits;
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	/*  digital output */
+	if (thisboard->layout == LAYOUT_64XX) {
+		s = &dev->subdevices[3];
+		s->type = COMEDI_SUBD_DO;
+		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+		s->n_chan = 4;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->insn_bits = do_wbits;
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	/* 8255 */
+	s = &dev->subdevices[4];
+	if (thisboard->has_8255) {
+		if (thisboard->layout == LAYOUT_4020) {
+			dio_8255_iobase = devpriv->main_iobase + I8255_4020_REG;
+			subdev_8255_init(dev, s, dio_callback_4020,
+					 (unsigned long)dio_8255_iobase);
+		} else {
+			dio_8255_iobase =
+				devpriv->dio_counter_iobase + DIO_8255_OFFSET;
+			subdev_8255_init(dev, s, dio_callback,
+					 (unsigned long)dio_8255_iobase);
+		}
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	/*  8 channel dio for 60xx */
+	s = &dev->subdevices[5];
+	if (thisboard->layout == LAYOUT_60XX) {
+		s->type = COMEDI_SUBD_DIO;
+		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+		s->n_chan = 8;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->insn_config = dio_60xx_config_insn;
+		s->insn_bits = dio_60xx_wbits;
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	/*  caldac */
+	s = &dev->subdevices[6];
+	s->type = COMEDI_SUBD_CALIB;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+	s->n_chan = 8;
+	if (thisboard->layout == LAYOUT_4020)
+		s->maxdata = 0xfff;
+	else
+		s->maxdata = 0xff;
+	s->insn_read = calib_read_insn;
+	s->insn_write = calib_write_insn;
+	for (i = 0; i < s->n_chan; i++)
+		caldac_write(dev, i, s->maxdata / 2);
+
+	/*  2 channel ad8402 potentiometer */
+	s = &dev->subdevices[7];
+	if (thisboard->layout == LAYOUT_64XX) {
+		s->type = COMEDI_SUBD_CALIB;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+		s->n_chan = 2;
+		s->insn_read = ad8402_read_insn;
+		s->insn_write = ad8402_write_insn;
+		s->maxdata = 0xff;
+		for (i = 0; i < s->n_chan; i++)
+			ad8402_write(dev, i, s->maxdata / 2);
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	/* serial EEPROM, if present */
+	s = &dev->subdevices[8];
+	if (readl(devpriv->plx9080_iobase + PLX_CONTROL_REG) & CTL_EECHK) {
+		s->type = COMEDI_SUBD_MEMORY;
+		s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
+		s->n_chan = 128;
+		s->maxdata = 0xffff;
+		s->insn_read = eeprom_read_insn;
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	/*  user counter subd XXX */
+	s = &dev->subdevices[9];
+	s->type = COMEDI_SUBD_UNUSED;
+
+	return 0;
+}
+
 static struct comedi_driver cb_pcidas64_driver = {
 	.driver_name	= "cb_pcidas64",
 	.module		= THIS_MODULE,

commit b07244ceeadd30be344cb49f9bc96f8b8b36a6a4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 2 19:18:01 2012 +0000

    staging: comedi: cb_pcidas64: remove board(dev) inline
    
    The `board(dev)` inline function returns `dev->board_ptr` cast from
    `const void *` to `struct pcidas64_board *`.  It really ought to return
    a `const struct pcidas64_board *`.  Rather than fix the function, just
    remove it and replace the calls with a local variable `thisboard` in the
    functions that call it.  `thisboard` is set to the result of the common
    inline function `comedi_board(dev)` defined in "comedidev.h".
    
    Fix a little resulting fall-out from the inline function
    `ai_dma_ring_count(board)` whose parameter should have been a const
    pointer.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index c95756f0eb6d..803220be6b24 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -635,7 +635,7 @@ static const struct hw_fifo_info ai_fifo_60xx = {
 #define MAX_AI_DMA_RING_COUNT (0x80000 / DMA_BUFFER_SIZE)
 #define MIN_AI_DMA_RING_COUNT (0x10000 / DMA_BUFFER_SIZE)
 #define AO_DMA_RING_COUNT (0x10000 / DMA_BUFFER_SIZE)
-static inline unsigned int ai_dma_ring_count(struct pcidas64_board *board)
+static inline unsigned int ai_dma_ring_count(const struct pcidas64_board *board)
 {
 	if (board->layout == LAYOUT_4020)
 		return MAX_AI_DMA_RING_COUNT;
@@ -1064,16 +1064,13 @@ static const struct pcidas64_board pcidas64_boards[] = {
 #endif
 };
 
-static inline struct pcidas64_board *board(const struct comedi_device *dev)
-{
-	return (struct pcidas64_board *)dev->board_ptr;
-}
-
 static inline unsigned short se_diff_bit_6xxx(struct comedi_device *dev,
 					      int use_differential)
 {
-	if ((board(dev)->layout == LAYOUT_64XX && !use_differential) ||
-	    (board(dev)->layout == LAYOUT_60XX && use_differential))
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+
+	if ((thisboard->layout == LAYOUT_64XX && !use_differential) ||
+	    (thisboard->layout == LAYOUT_60XX && use_differential))
 		return ADC_SE_DIFF_BIT;
 	else
 		return 0;
@@ -1232,8 +1229,9 @@ static void load_ao_dma(struct comedi_device *dev,
 static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 				       unsigned int range_index)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	const struct comedi_krange *range =
-		&board(dev)->ai_range_table->range[range_index];
+		&thisboard->ai_range_table->range[range_index];
 	unsigned int bits = 0;
 
 	switch (range->max) {
@@ -1276,7 +1274,9 @@ static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 static unsigned int hw_revision(const struct comedi_device *dev,
 				uint16_t hw_status_bits)
 {
-	if (board(dev)->layout == LAYOUT_4020)
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+
+	if (thisboard->layout == LAYOUT_4020)
 		return (hw_status_bits >> 13) & 0x7;
 
 	return (hw_status_bits >> 12) & 0xf;
@@ -1286,7 +1286,8 @@ static void set_dac_range_bits(struct comedi_device *dev,
 			       volatile uint16_t *bits, unsigned int channel,
 			       unsigned int range)
 {
-	unsigned int code = board(dev)->ao_range_code[range];
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+	unsigned int code = thisboard->ao_range_code[range];
 
 	if (channel > 1)
 		comedi_error(dev, "bug! bad channel?");
@@ -1305,6 +1306,7 @@ static inline int ao_cmd_is_supported(const struct pcidas64_board *board)
 /* initialize plx9080 chip */
 static void init_plx9080(struct comedi_device *dev)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	uint32_t bits;
 	void __iomem *plx_iobase = devpriv->plx9080_iobase;
@@ -1377,12 +1379,12 @@ static void init_plx9080(struct comedi_device *dev)
 	/*  enable local burst mode */
 	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
 	/*  4020 uses 32 bit dma */
-	if (board(dev)->layout == LAYOUT_4020)
+	if (thisboard->layout == LAYOUT_4020)
 		bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
 	else		/*  localspace0 bus is 16 bits wide */
 		bits |= PLX_LOCAL_BUS_16_WIDE_BITS;
 	writel(bits, plx_iobase + PLX_DMA1_MODE_REG);
-	if (ao_cmd_is_supported(board(dev)))
+	if (ao_cmd_is_supported(thisboard))
 		writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
 
 	/*  enable interrupts on plx 9080 */
@@ -1397,6 +1399,7 @@ static void init_plx9080(struct comedi_device *dev)
  */
 static int setup_subdevices(struct comedi_device *dev)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	void __iomem *dio_8255_iobase;
@@ -1412,21 +1415,21 @@ static int setup_subdevices(struct comedi_device *dev)
 	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DITHER | SDF_CMD_READ;
-	if (board(dev)->layout == LAYOUT_60XX)
+	if (thisboard->layout == LAYOUT_60XX)
 		s->subdev_flags |= SDF_COMMON | SDF_DIFF;
-	else if (board(dev)->layout == LAYOUT_64XX)
+	else if (thisboard->layout == LAYOUT_64XX)
 		s->subdev_flags |= SDF_DIFF;
 	/* XXX Number of inputs in differential mode is ignored */
-	s->n_chan = board(dev)->ai_se_chans;
+	s->n_chan = thisboard->ai_se_chans;
 	s->len_chanlist = 0x2000;
-	s->maxdata = (1 << board(dev)->ai_bits) - 1;
-	s->range_table = board(dev)->ai_range_table;
+	s->maxdata = (1 << thisboard->ai_bits) - 1;
+	s->range_table = thisboard->ai_range_table;
 	s->insn_read = ai_rinsn;
 	s->insn_config = ai_config_insn;
 	s->do_cmd = ai_cmd;
 	s->do_cmdtest = ai_cmdtest;
 	s->cancel = ai_cancel;
-	if (board(dev)->layout == LAYOUT_4020) {
+	if (thisboard->layout == LAYOUT_4020) {
 		uint8_t data;
 		/*  set adc to read from inputs
 		 *  (not internal calibration sources) */
@@ -1440,20 +1443,20 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/* analog output subdevice */
 	s = &dev->subdevices[1];
-	if (board(dev)->ao_nchan) {
+	if (thisboard->ao_nchan) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE |
 				  SDF_GROUND | SDF_CMD_WRITE;
-		s->n_chan = board(dev)->ao_nchan;
-		s->maxdata = (1 << board(dev)->ao_bits) - 1;
-		s->range_table = board(dev)->ao_range_table;
+		s->n_chan = thisboard->ao_nchan;
+		s->maxdata = (1 << thisboard->ao_bits) - 1;
+		s->range_table = thisboard->ao_range_table;
 		s->insn_read = ao_readback_insn;
 		s->insn_write = ao_winsn;
-		if (ao_cmd_is_supported(board(dev))) {
+		if (ao_cmd_is_supported(thisboard)) {
 			dev->write_subdev = s;
 			s->do_cmdtest = ao_cmdtest;
 			s->do_cmd = ao_cmd;
-			s->len_chanlist = board(dev)->ao_nchan;
+			s->len_chanlist = thisboard->ao_nchan;
 			s->cancel = ao_cancel;
 		}
 	} else {
@@ -1462,7 +1465,7 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/*  digital input */
 	s = &dev->subdevices[2];
-	if (board(dev)->layout == LAYOUT_64XX) {
+	if (thisboard->layout == LAYOUT_64XX) {
 		s->type = COMEDI_SUBD_DI;
 		s->subdev_flags = SDF_READABLE;
 		s->n_chan = 4;
@@ -1473,7 +1476,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->type = COMEDI_SUBD_UNUSED;
 
 	/*  digital output */
-	if (board(dev)->layout == LAYOUT_64XX) {
+	if (thisboard->layout == LAYOUT_64XX) {
 		s = &dev->subdevices[3];
 		s->type = COMEDI_SUBD_DO;
 		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
@@ -1486,8 +1489,8 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/* 8255 */
 	s = &dev->subdevices[4];
-	if (board(dev)->has_8255) {
-		if (board(dev)->layout == LAYOUT_4020) {
+	if (thisboard->has_8255) {
+		if (thisboard->layout == LAYOUT_4020) {
 			dio_8255_iobase = devpriv->main_iobase + I8255_4020_REG;
 			subdev_8255_init(dev, s, dio_callback_4020,
 					 (unsigned long)dio_8255_iobase);
@@ -1502,7 +1505,7 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/*  8 channel dio for 60xx */
 	s = &dev->subdevices[5];
-	if (board(dev)->layout == LAYOUT_60XX) {
+	if (thisboard->layout == LAYOUT_60XX) {
 		s->type = COMEDI_SUBD_DIO;
 		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
 		s->n_chan = 8;
@@ -1518,7 +1521,7 @@ static int setup_subdevices(struct comedi_device *dev)
 	s->type = COMEDI_SUBD_CALIB;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 	s->n_chan = 8;
-	if (board(dev)->layout == LAYOUT_4020)
+	if (thisboard->layout == LAYOUT_4020)
 		s->maxdata = 0xfff;
 	else
 		s->maxdata = 0xff;
@@ -1529,7 +1532,7 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/*  2 channel ad8402 potentiometer */
 	s = &dev->subdevices[7];
-	if (board(dev)->layout == LAYOUT_64XX) {
+	if (thisboard->layout == LAYOUT_64XX) {
 		s->type = COMEDI_SUBD_CALIB;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 		s->n_chan = 2;
@@ -1570,6 +1573,7 @@ static void disable_plx_interrupts(struct comedi_device *dev)
 
 static void init_stc_registers(struct comedi_device *dev)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	uint16_t bits;
 	unsigned long flags;
@@ -1587,7 +1591,7 @@ static void init_stc_registers(struct comedi_device *dev)
 	writew(0xff, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
 
 	bits = SLOW_DAC_BIT | DMA_CH_SELECT_BIT;
-	if (board(dev)->layout == LAYOUT_4020)
+	if (thisboard->layout == LAYOUT_4020)
 		bits |= INTERNAL_CLOCK_4020_BITS;
 	devpriv->hw_config_bits |= bits;
 	writew(devpriv->hw_config_bits,
@@ -1601,7 +1605,7 @@ static void init_stc_registers(struct comedi_device *dev)
 	/*  set fifos to maximum size */
 	devpriv->fifo_size_bits |= DAC_FIFO_BITS;
 	set_ai_fifo_segment_length(dev,
-				   board(dev)->ai_fifo->max_segment_length);
+				   thisboard->ai_fifo->max_segment_length);
 
 	devpriv->dac_control1_bits = DAC_OUTPUT_ENABLE_BIT;
 	devpriv->intr_enable_bits =
@@ -1615,12 +1619,13 @@ static void init_stc_registers(struct comedi_device *dev)
 
 static int alloc_and_init_dma_members(struct comedi_device *dev)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	int i;
 
 	/*  alocate pci dma buffers */
-	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
+	for (i = 0; i < ai_dma_ring_count(thisboard); i++) {
 		devpriv->ai_buffer[i] =
 			pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
 					     &devpriv->ai_buffer_bus_addr[i]);
@@ -1629,7 +1634,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 
 	}
 	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
-		if (ao_cmd_is_supported(board(dev))) {
+		if (ao_cmd_is_supported(thisboard)) {
 			devpriv->ao_buffer[i] =
 				pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
 						     &devpriv->
@@ -1642,14 +1647,14 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	/*  allocate dma descriptors */
 	devpriv->ai_dma_desc =
 		pci_alloc_consistent(pcidev, sizeof(struct plx_dma_desc) *
-				     ai_dma_ring_count(board(dev)),
+				     ai_dma_ring_count(thisboard),
 				     &devpriv->ai_dma_desc_bus_addr);
 	if (devpriv->ai_dma_desc == NULL)
 		return -ENOMEM;
 
 	DEBUG_PRINT("ai dma descriptors start at bus addr 0x%llx\n",
 		    (unsigned long long)devpriv->ai_dma_desc_bus_addr);
-	if (ao_cmd_is_supported(board(dev))) {
+	if (ao_cmd_is_supported(thisboard)) {
 		devpriv->ao_dma_desc =
 			pci_alloc_consistent(pcidev,
 					     sizeof(struct plx_dma_desc) *
@@ -1662,10 +1667,10 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 			    (unsigned long long)devpriv->ao_dma_desc_bus_addr);
 	}
 	/*  initialize dma descriptors */
-	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
+	for (i = 0; i < ai_dma_ring_count(thisboard); i++) {
 		devpriv->ai_dma_desc[i].pci_start_addr =
 			cpu_to_le32(devpriv->ai_buffer_bus_addr[i]);
-		if (board(dev)->layout == LAYOUT_4020)
+		if (thisboard->layout == LAYOUT_4020)
 			devpriv->ai_dma_desc[i].local_start_addr =
 				cpu_to_le32(devpriv->local1_iobase +
 					    ADC_FIFO_REG);
@@ -1676,12 +1681,12 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 		devpriv->ai_dma_desc[i].transfer_size = cpu_to_le32(0);
 		devpriv->ai_dma_desc[i].next =
 			cpu_to_le32((devpriv->ai_dma_desc_bus_addr +
-				     ((i + 1) % ai_dma_ring_count(board(dev))) *
+				     ((i + 1) % ai_dma_ring_count(thisboard)) *
 				     sizeof(devpriv->ai_dma_desc[0])) |
 				    PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
 				    PLX_XFER_LOCAL_TO_PCI);
 	}
-	if (ao_cmd_is_supported(board(dev))) {
+	if (ao_cmd_is_supported(thisboard)) {
 		for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 			devpriv->ao_dma_desc[i].pci_start_addr =
 				cpu_to_le32(devpriv->ao_buffer_bus_addr[i]);
@@ -1722,6 +1727,7 @@ static const struct pcidas64_board
 static int __devinit auto_attach(struct comedi_device *dev,
 				 unsigned long context_unused)
 {
+	const struct pcidas64_board *thisboard;
 	struct pcidas64_private *devpriv;
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	uint32_t local_range, local_decode;
@@ -1734,6 +1740,7 @@ static int __devinit auto_attach(struct comedi_device *dev,
 			pci_name(pcidev));
 		return -EINVAL;
 	}
+	thisboard = comedi_board(dev);
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
@@ -1748,7 +1755,7 @@ static int __devinit auto_attach(struct comedi_device *dev,
 	pci_set_master(pcidev);
 
 	/* Initialize dev->board_name */
-	dev->board_name = board(dev)->name;
+	dev->board_name = thisboard->name;
 
 	dev->iobase = pci_resource_start(pcidev, MAIN_BADDRINDEX);
 
@@ -1826,6 +1833,7 @@ static int __devinit auto_attach(struct comedi_device *dev,
 
 static void detach(struct comedi_device *dev)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int i;
@@ -1843,7 +1851,7 @@ static void detach(struct comedi_device *dev)
 			if (devpriv->dio_counter_iobase)
 				iounmap(devpriv->dio_counter_iobase);
 			/*  free pci dma buffers */
-			for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
+			for (i = 0; i < ai_dma_ring_count(thisboard); i++) {
 				if (devpriv->ai_buffer[i])
 					pci_free_consistent(pcidev,
 						DMA_BUFFER_SIZE,
@@ -1861,7 +1869,7 @@ static void detach(struct comedi_device *dev)
 			if (devpriv->ai_dma_desc)
 				pci_free_consistent(pcidev,
 					sizeof(struct plx_dma_desc) *
-					ai_dma_ring_count(board(dev)),
+					ai_dma_ring_count(thisboard),
 					devpriv->ai_dma_desc,
 					devpriv->ai_dma_desc_bus_addr);
 			if (devpriv->ao_dma_desc)
@@ -1883,6 +1891,7 @@ static void detach(struct comedi_device *dev)
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int bits = 0, n, i;
 	unsigned int channel, range, aref;
@@ -1907,7 +1916,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	       devpriv->main_iobase + ADC_CONTROL1_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	if (board(dev)->layout != LAYOUT_4020) {
+	if (thisboard->layout != LAYOUT_4020) {
 		/*  use internal queue */
 		devpriv->hw_config_bits &= ~EXT_QUEUE_BIT;
 		writew(devpriv->hw_config_bits,
@@ -1918,7 +1927,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			unsigned int cal_en_bit;
 
 			DEBUG_PRINT("reading calibration source\n");
-			if (board(dev)->layout == LAYOUT_60XX)
+			if (thisboard->layout == LAYOUT_60XX)
 				cal_en_bit = CAL_EN_60XX_BIT;
 			else
 				cal_en_bit = CAL_EN_64XX_BIT;
@@ -1991,7 +2000,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		for (i = 0; i < timeout; i++) {
 			bits = readw(devpriv->main_iobase + HW_STATUS_REG);
 			DEBUG_PRINT(" pipe bits 0x%x\n", pipe_full_bits(bits));
-			if (board(dev)->layout == LAYOUT_4020) {
+			if (thisboard->layout == LAYOUT_4020) {
 				if (readw(devpriv->main_iobase +
 					  ADC_WRITE_PNTR_REG))
 					break;
@@ -2007,7 +2016,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			dev_info(dev->class_dev, "status 0x%x\n", bits);
 			return -ETIME;
 		}
-		if (board(dev)->layout == LAYOUT_4020)
+		if (thisboard->layout == LAYOUT_4020)
 			data[n] = readl(devpriv->dio_counter_iobase +
 					ADC_FIFO_REG) & 0xffff;
 		else
@@ -2020,11 +2029,12 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 static int ai_config_calibration_source(struct comedi_device *dev,
 					unsigned int *data)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int source = data[1];
 	int num_calibration_sources;
 
-	if (board(dev)->layout == LAYOUT_60XX)
+	if (thisboard->layout == LAYOUT_60XX)
 		num_calibration_sources = 16;
 	else
 		num_calibration_sources = 8;
@@ -2042,8 +2052,9 @@ static int ai_config_calibration_source(struct comedi_device *dev,
 
 static int ai_config_block_size(struct comedi_device *dev, unsigned int *data)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	int fifo_size;
-	const struct hw_fifo_info *const fifo = board(dev)->ai_fifo;
+	const struct hw_fifo_info *const fifo = thisboard->ai_fifo;
 	unsigned int block_size, requested_block_size;
 	int retval;
 
@@ -2096,8 +2107,9 @@ static int ai_config_master_clock_4020(struct comedi_device *dev,
 /* XXX could add support for 60xx series */
 static int ai_config_master_clock(struct comedi_device *dev, unsigned int *data)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 
-	switch (board(dev)->layout) {
+	switch (thisboard->layout) {
 	case LAYOUT_4020:
 		return ai_config_master_clock_4020(dev, data);
 		break;
@@ -2134,6 +2146,7 @@ static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	int err = 0;
 	unsigned int tmp_arg, tmp_arg2;
 	int i;
@@ -2145,14 +2158,14 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
 
 	triggers = TRIG_TIMER;
-	if (board(dev)->layout == LAYOUT_4020)
+	if (thisboard->layout == LAYOUT_4020)
 		triggers |= TRIG_OTHER;
 	else
 		triggers |= TRIG_FOLLOW;
 	err |= cfc_check_trigger_src(&cmd->scan_begin_src, triggers);
 
 	triggers = TRIG_TIMER;
-	if (board(dev)->layout == LAYOUT_4020)
+	if (thisboard->layout == LAYOUT_4020)
 		triggers |= TRIG_NOW;
 	else
 		triggers |= TRIG_EXT;
@@ -2185,14 +2198,14 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* step 3: make sure arguments are trivially compatible */
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		if (board(dev)->layout == LAYOUT_4020) {
+		if (thisboard->layout == LAYOUT_4020) {
 			if (cmd->convert_arg) {
 				cmd->convert_arg = 0;
 				err++;
 			}
 		} else {
-			if (cmd->convert_arg < board(dev)->ai_speed) {
-				cmd->convert_arg = board(dev)->ai_speed;
+			if (cmd->convert_arg < thisboard->ai_speed) {
+				cmd->convert_arg = thisboard->ai_speed;
 				err++;
 			}
 			if (cmd->scan_begin_src == TRIG_TIMER) {
@@ -2267,7 +2280,7 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			}
 		}
 		/*  check 4020 chanlist */
-		if (board(dev)->layout == LAYOUT_4020) {
+		if (thisboard->layout == LAYOUT_4020) {
 			unsigned int first_channel = CR_CHAN(cmd->chanlist[0]);
 			for (i = 1; i < cmd->chanlist_len; i++) {
 				if (CR_CHAN(cmd->chanlist[i]) !=
@@ -2325,11 +2338,12 @@ static void setup_sample_counters(struct comedi_device *dev,
 
 static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int num_samples;
 
 	num_samples = devpriv->ai_fifo_segment_length *
-		      board(dev)->ai_fifo->sample_packing_ratio;
+		      thisboard->ai_fifo->sample_packing_ratio;
 	if (num_samples > DMA_BUFFER_SIZE / sizeof(uint16_t))
 		num_samples = DMA_BUFFER_SIZE / sizeof(uint16_t);
 
@@ -2374,6 +2388,7 @@ static void disable_ai_interrupts(struct comedi_device *dev)
 static void enable_ai_interrupts(struct comedi_device *dev,
 				 const struct comedi_cmd *cmd)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	uint32_t bits;
 	unsigned long flags;
@@ -2384,7 +2399,7 @@ static void enable_ai_interrupts(struct comedi_device *dev,
 	 *  if TRIG_WAKE_EOS flag is set. */
 	if (cmd->flags & TRIG_WAKE_EOS) {
 		/*  4020 doesn't support pio transfers except for fifo dregs */
-		if (board(dev)->layout != LAYOUT_4020)
+		if (thisboard->layout != LAYOUT_4020)
 			bits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;
 	}
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -2471,7 +2486,9 @@ static void select_master_clock_4020(struct comedi_device *dev,
 static void select_master_clock(struct comedi_device *dev,
 				const struct comedi_cmd *cmd)
 {
-	switch (board(dev)->layout) {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+
+	switch (thisboard->layout) {
 	case LAYOUT_4020:
 		select_master_clock_4020(dev, cmd);
 		break;
@@ -2501,6 +2518,7 @@ static inline void dma_start_sync(struct comedi_device *dev,
 
 static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	uint32_t convert_counter = 0, scan_counter = 0;
 
@@ -2508,7 +2526,7 @@ static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 
 	select_master_clock(dev, cmd);
 
-	if (board(dev)->layout == LAYOUT_4020) {
+	if (thisboard->layout == LAYOUT_4020) {
 		convert_counter = ai_convert_counter_4020(dev, cmd);
 	} else {
 		convert_counter = ai_convert_counter_6xxx(dev, cmd);
@@ -2551,11 +2569,12 @@ static int use_internal_queue_6xxx(const struct comedi_cmd *cmd)
 static int setup_channel_queue(struct comedi_device *dev,
 			       const struct comedi_cmd *cmd)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned short bits;
 	int i;
 
-	if (board(dev)->layout != LAYOUT_4020) {
+	if (thisboard->layout != LAYOUT_4020) {
 		if (use_internal_queue_6xxx(cmd)) {
 			devpriv->hw_config_bits &= ~EXT_QUEUE_BIT;
 			writew(devpriv->hw_config_bits,
@@ -2689,6 +2708,7 @@ static inline void load_first_dma_descriptor(struct comedi_device *dev,
 
 static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -2717,7 +2737,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* set mode, allow conversions through software gate */
 	devpriv->adc_control1_bits |= ADC_SW_GATE_BIT;
 	devpriv->adc_control1_bits &= ~ADC_DITHER_BIT;
-	if (board(dev)->layout != LAYOUT_4020) {
+	if (thisboard->layout != LAYOUT_4020) {
 		devpriv->adc_control1_bits &= ~ADC_MODE_MASK;
 		if (cmd->convert_src == TRIG_EXT)
 			/*  good old mode 13 */
@@ -2748,11 +2768,11 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	writew(0, devpriv->main_iobase + ADC_BUFFER_CLEAR_REG);
 
 	if ((cmd->flags & TRIG_WAKE_EOS) == 0 ||
-	    board(dev)->layout == LAYOUT_4020) {
+	    thisboard->layout == LAYOUT_4020) {
 		devpriv->ai_dma_index = 0;
 
 		/*  set dma transfer size */
-		for (i = 0; i < ai_dma_ring_count(board(dev)); i++)
+		for (i = 0; i < ai_dma_ring_count(thisboard); i++)
 			devpriv->ai_dma_desc[i].transfer_size =
 				cpu_to_le32(dma_transfer_size(dev) *
 					    sizeof(uint16_t));
@@ -2767,7 +2787,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		dma_start_sync(dev, 1);
 	}
 
-	if (board(dev)->layout == LAYOUT_4020) {
+	if (thisboard->layout == LAYOUT_4020) {
 		/* set source for external triggers */
 		bits = 0;
 		if (cmd->start_src == TRIG_EXT && CR_CHAN(cmd->start_arg))
@@ -2915,7 +2935,9 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 /* empty fifo */
 static void pio_drain_ai_fifo(struct comedi_device *dev)
 {
-	if (board(dev)->layout == LAYOUT_4020)
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+
+	if (thisboard->layout == LAYOUT_4020)
 		pio_drain_ai_fifo_32(dev);
 	else
 		pio_drain_ai_fifo_16(dev);
@@ -2923,6 +2945,7 @@ static void pio_drain_ai_fifo(struct comedi_device *dev)
 
 static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_async *async = dev->read_subdev->async;
 	uint32_t next_transfer_addr;
@@ -2943,7 +2966,7 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 	      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] ||
 	      next_transfer_addr >=
 	      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] +
-	      DMA_BUFFER_SIZE) && j < ai_dma_ring_count(board(dev)); j++) {
+	      DMA_BUFFER_SIZE) && j < ai_dma_ring_count(thisboard); j++) {
 		/*  transfer data from dma buffer to comedi buffer */
 		num_samples = dma_transfer_size(dev);
 		if (async->cmd.stop_src == TRIG_COUNT) {
@@ -2956,7 +2979,7 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 							     ai_dma_index],
 					  num_samples * sizeof(uint16_t));
 		devpriv->ai_dma_index = (devpriv->ai_dma_index + 1) %
-					ai_dma_ring_count(board(dev));
+					ai_dma_ring_count(thisboard);
 
 		DEBUG_PRINT("next buffer addr 0x%lx\n",
 			    (unsigned long)devpriv->
@@ -2971,6 +2994,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 				unsigned short status,
 				unsigned int plx_status)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
@@ -3005,7 +3029,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 	if ((status & ADC_DONE_BIT) ||
 	    ((cmd->flags & TRIG_WAKE_EOS) &&
 	     (status & ADC_INTR_PENDING_BIT) &&
-	     (board(dev)->layout != LAYOUT_4020))) {
+	     (thisboard->layout != LAYOUT_4020))) {
 		DEBUG_PRINT("pio fifo drain\n");
 		spin_lock_irqsave(&dev->spinlock, flags);
 		if (devpriv->ai_cmd_running) {
@@ -3223,6 +3247,7 @@ static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	int chan = CR_CHAN(insn->chanspec);
 	int range = CR_RANGE(insn->chanspec);
@@ -3236,7 +3261,7 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	       devpriv->main_iobase + DAC_CONTROL1_REG);
 
 	/*  write to channel */
-	if (board(dev)->layout == LAYOUT_4020) {
+	if (thisboard->layout == LAYOUT_4020) {
 		writew(data[0] & 0xff,
 		       devpriv->main_iobase + dac_lsb_4020_reg(chan));
 		writew((data[0] >> 8) & 0xf,
@@ -3449,9 +3474,11 @@ static int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 
 static inline int external_ai_queue_in_use(struct comedi_device *dev)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
+
 	if (dev->read_subdev->busy)
 		return 0;
-	if (board(dev)->layout == LAYOUT_4020)
+	if (thisboard->layout == LAYOUT_4020)
 		return 0;
 	else if (use_internal_queue_6xxx(&dev->read_subdev->async->cmd))
 		return 0;
@@ -3511,6 +3538,7 @@ static int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	int err = 0;
 	unsigned int tmp_arg;
 	int i;
@@ -3546,8 +3574,8 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* step 3: make sure arguments are trivially compatible */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		if (cmd->scan_begin_arg < board(dev)->ao_scan_speed) {
-			cmd->scan_begin_arg = board(dev)->ao_scan_speed;
+		if (cmd->scan_begin_arg < thisboard->ao_scan_speed) {
+			cmd->scan_begin_arg = thisboard->ao_scan_speed;
 			err++;
 		}
 		if (get_ao_divisor(cmd->scan_begin_arg,
@@ -3714,11 +3742,12 @@ static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
 static void caldac_write(struct comedi_device *dev, unsigned int channel,
 			 unsigned int value)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 
 	devpriv->caldac_state[channel] = value;
 
-	switch (board(dev)->layout) {
+	switch (thisboard->layout) {
 	case LAYOUT_60XX:
 	case LAYOUT_64XX:
 		caldac_8800_write(dev, channel, value);
@@ -3901,6 +3930,7 @@ static int eeprom_read_insn(struct comedi_device *dev,
  */
 static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	unsigned int convert_divisor = 0, scan_divisor;
 	static const int min_convert_divisor = 3;
 	static const int max_convert_divisor =
@@ -3909,7 +3939,7 @@ static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 	unsigned long long max_scan_divisor, min_scan_divisor;
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		if (board(dev)->layout == LAYOUT_4020) {
+		if (thisboard->layout == LAYOUT_4020) {
 			cmd->convert_arg = 0;
 		} else {
 			convert_divisor = get_divisor(cmd->convert_arg,
@@ -3976,9 +4006,10 @@ static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags)
 /* adjusts the size of hardware fifo (which determines block size for dma xfers) */
 static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	unsigned int num_fifo_entries;
 	int retval;
-	const struct hw_fifo_info *const fifo = board(dev)->ai_fifo;
+	const struct hw_fifo_info *const fifo = thisboard->ai_fifo;
 
 	num_fifo_entries = num_samples / fifo->sample_packing_ratio;
 
@@ -3998,19 +4029,21 @@ static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 /* query length of fifo */
 static unsigned int ai_fifo_size(struct comedi_device *dev)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 
 	return devpriv->ai_fifo_segment_length *
-	       board(dev)->ai_fifo->num_segments *
-	       board(dev)->ai_fifo->sample_packing_ratio;
+	       thisboard->ai_fifo->num_segments *
+	       thisboard->ai_fifo->sample_packing_ratio;
 }
 
 static int set_ai_fifo_segment_length(struct comedi_device *dev,
 				      unsigned int num_entries)
 {
+	const struct pcidas64_board *thisboard = comedi_board(dev);
 	struct pcidas64_private *devpriv = dev->private;
 	static const int increment_size = 0x100;
-	const struct hw_fifo_info *const fifo = board(dev)->ai_fifo;
+	const struct hw_fifo_info *const fifo = thisboard->ai_fifo;
 	unsigned int num_increments;
 	uint16_t bits;
 

commit 46ca84c4659f24776f7b901dd6054e3c6dfc115e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 2 19:17:59 2012 +0000

    staging: comedi: cb_pcidas64: whitespace/brace changes
    
    Some whitespace changes, mostly to fix lines > 80 characters and
    operator placement.  Add/remove some braces according to CodingStyle.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index a431b6d3eae1..c95756f0eb6d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -74,12 +74,14 @@ known. If you have such a board, please file a bug report at
 
 TODO:
 	make it return error if user attempts an ai command that uses the
-		external queue, and an ao command simultaneously
-	user counter subdevice
+	external queue, and an ao command simultaneously user counter subdevice
 	there are a number of boards this driver will support when they are
-		fully released, but does not yet since the pci device id numbers
-		are not yet available.
-	support prescaled 100khz clock for slow pacing (not available on 6000 series?)
+	fully released, but does not yet since the pci device id numbers
+	are not yet available.
+
+	support prescaled 100khz clock for slow pacing (not available on 6000
+	series?)
+
 	make ao fifo size adjustable like ai fifo
 */
 
@@ -104,7 +106,9 @@ known. If you have such a board, please file a bug report at
 #endif
 
 #define TIMER_BASE 25		/*  40MHz master clock */
-#define PRESCALED_TIMER_BASE	10000	/*  100kHz 'prescaled' clock for slow acquisition, maybe I'll support this someday */
+/* 100kHz 'prescaled' clock for slow acquisition,
+ * maybe I'll support this someday */
+#define PRESCALED_TIMER_BASE	10000
 #define DMA_BUFFER_SIZE 0x1000
 
 /* maximum value that can be loaded into board's 24-bit counters*/
@@ -128,26 +132,36 @@ enum write_only_registers {
 	ADC_CONTROL0_REG = 0x10,	/*  adc control register 0 */
 	ADC_CONTROL1_REG = 0x12,	/*  adc control register 1 */
 	CALIBRATION_REG = 0x14,
-	ADC_SAMPLE_INTERVAL_LOWER_REG = 0x16,	/*  lower 16 bits of adc sample interval counter */
-	ADC_SAMPLE_INTERVAL_UPPER_REG = 0x18,	/*  upper 8 bits of adc sample interval counter */
-	ADC_DELAY_INTERVAL_LOWER_REG = 0x1a,	/*  lower 16 bits of delay interval counter */
-	ADC_DELAY_INTERVAL_UPPER_REG = 0x1c,	/*  upper 8 bits of delay interval counter */
-	ADC_COUNT_LOWER_REG = 0x1e,	/*  lower 16 bits of hardware conversion/scan counter */
-	ADC_COUNT_UPPER_REG = 0x20,	/*  upper 8 bits of hardware conversion/scan counter */
+	/*  lower 16 bits of adc sample interval counter */
+	ADC_SAMPLE_INTERVAL_LOWER_REG = 0x16,
+	/*  upper 8 bits of adc sample interval counter */
+	ADC_SAMPLE_INTERVAL_UPPER_REG = 0x18,
+	/*  lower 16 bits of delay interval counter */
+	ADC_DELAY_INTERVAL_LOWER_REG = 0x1a,
+	/*  upper 8 bits of delay interval counter */
+	ADC_DELAY_INTERVAL_UPPER_REG = 0x1c,
+	/*  lower 16 bits of hardware conversion/scan counter */
+	ADC_COUNT_LOWER_REG = 0x1e,
+	/*  upper 8 bits of hardware conversion/scan counter */
+	ADC_COUNT_UPPER_REG = 0x20,
 	ADC_START_REG = 0x22,	/*  software trigger to start acquisition */
 	ADC_CONVERT_REG = 0x24,	/*  initiates single conversion */
 	ADC_QUEUE_CLEAR_REG = 0x26,	/*  clears adc queue */
 	ADC_QUEUE_LOAD_REG = 0x28,	/*  loads adc queue */
 	ADC_BUFFER_CLEAR_REG = 0x2a,
-	ADC_QUEUE_HIGH_REG = 0x2c,	/*  high channel for internal queue, use adc_chan_bits() inline above */
+	/*  high channel for internal queue, use adc_chan_bits() inline above */
+	ADC_QUEUE_HIGH_REG = 0x2c,
 	DAC_CONTROL0_REG = 0x50,	/*  dac control register 0 */
 	DAC_CONTROL1_REG = 0x52,	/*  dac control register 0 */
-	DAC_SAMPLE_INTERVAL_LOWER_REG = 0x54,	/*  lower 16 bits of dac sample interval counter */
-	DAC_SAMPLE_INTERVAL_UPPER_REG = 0x56,	/*  upper 8 bits of dac sample interval counter */
+	/*  lower 16 bits of dac sample interval counter */
+	DAC_SAMPLE_INTERVAL_LOWER_REG = 0x54,
+	/*  upper 8 bits of dac sample interval counter */
+	DAC_SAMPLE_INTERVAL_UPPER_REG = 0x56,
 	DAC_SELECT_REG = 0x60,
 	DAC_START_REG = 0x64,
 	DAC_BUFFER_CLEAR_REG = 0x66,	/*  clear dac buffer */
 };
+
 static inline unsigned int dac_convert_reg(unsigned int channel)
 {
 	return 0x70 + (2 * (channel & 0x1));
@@ -164,7 +178,9 @@ static inline unsigned int dac_msb_4020_reg(unsigned int channel)
 }
 
 enum read_only_registers {
-	HW_STATUS_REG = 0x0,	/*  hardware status register, reading this apparently clears pending interrupts as well */
+	/*  hardware status register,
+	 *  reading this apparently clears pending interrupts as well */
+	HW_STATUS_REG = 0x0,
 	PIPE1_READ_REG = 0x4,
 	ADC_READ_PNTR_REG = 0x8,
 	LOWER_XFER_REG = 0x10,
@@ -174,9 +190,11 @@ enum read_only_registers {
 
 enum read_write_registers {
 	I8255_4020_REG = 0x48,	/*  8255 offset, for 4020 only */
-	ADC_QUEUE_FIFO_REG = 0x100,	/*  external channel/gain queue, uses same bits as ADC_QUEUE_LOAD_REG */
+	/*  external channel/gain queue, uses same bits as ADC_QUEUE_LOAD_REG */
+	ADC_QUEUE_FIFO_REG = 0x100,
 	ADC_FIFO_REG = 0x200,	/* adc data fifo */
-	DAC_FIFO_REG = 0x300,	/* dac data fifo, has weird interactions with external channel queue */
+	/* dac data fifo, has weird interactions with external channel queue */
+	DAC_FIFO_REG = 0x300,
 };
 
 /* devpriv->dio_counter_iobase registers */
@@ -191,13 +209,13 @@ enum dio_counter_registers {
 /* bit definitions for write-only registers */
 
 enum intr_enable_contents {
-	ADC_INTR_SRC_MASK = 0x3,	/*  bits that set adc interrupt source */
-	ADC_INTR_QFULL_BITS = 0x0,	/*  interrupt fifo quater full */
+	ADC_INTR_SRC_MASK = 0x3,	/*  adc interrupt source mask */
+	ADC_INTR_QFULL_BITS = 0x0,	/*  interrupt fifo quarter full */
 	ADC_INTR_EOC_BITS = 0x1,	/*  interrupt end of conversion */
 	ADC_INTR_EOSCAN_BITS = 0x2,	/*  interrupt end of scan */
-	ADC_INTR_EOSEQ_BITS = 0x3,	/*  interrupt end of sequence (probably wont use this it's pretty fancy) */
+	ADC_INTR_EOSEQ_BITS = 0x3,	/*  interrupt end of sequence mask */
 	EN_ADC_INTR_SRC_BIT = 0x4,	/*  enable adc interrupt source */
-	EN_ADC_DONE_INTR_BIT = 0x8,	/*  enable adc acquisition done interrupt */
+	EN_ADC_DONE_INTR_BIT = 0x8,	/*  enable adc acquisition done intr */
 	DAC_INTR_SRC_MASK = 0x30,
 	DAC_INTR_QEMPTY_BITS = 0x0,
 	DAC_INTR_HIGH_CHAN_BITS = 0x10,
@@ -211,25 +229,33 @@ enum intr_enable_contents {
 };
 
 enum hw_config_contents {
-	MASTER_CLOCK_4020_MASK = 0x3,	/*  bits that specify master clock source for 4020 */
-	INTERNAL_CLOCK_4020_BITS = 0x1,	/*  use 40 MHz internal master clock for 4020 */
+	MASTER_CLOCK_4020_MASK = 0x3,	/*  master clock source mask for 4020 */
+	INTERNAL_CLOCK_4020_BITS = 0x1,	/*  use 40 MHz internal master clock */
 	BNC_CLOCK_4020_BITS = 0x2,	/*  use BNC input for master clock */
 	EXT_CLOCK_4020_BITS = 0x3,	/*  use dio input for master clock */
-	EXT_QUEUE_BIT = 0x200,	/*  use external channel/gain queue (more versatile than internal queue) */
-	SLOW_DAC_BIT = 0x400,	/*  use 225 nanosec strobe when loading dac instead of 50 nanosec */
-	HW_CONFIG_DUMMY_BITS = 0x2000,	/*  bit with unknown function yet given as default value in pci-das64 manual */
-	DMA_CH_SELECT_BIT = 0x8000,	/*  bit selects channels 1/0 for analog input/output, otherwise 0/1 */
-	FIFO_SIZE_REG = 0x4,	/*  allows adjustment of fifo sizes */
+	EXT_QUEUE_BIT = 0x200,		/*  use external channel/gain queue */
+	/*  use 225 nanosec strobe when loading dac instead of 50 nanosec */
+	SLOW_DAC_BIT = 0x400,
+	/*  bit with unknown function yet given as default value in pci-das64
+	 *  manual */
+	HW_CONFIG_DUMMY_BITS = 0x2000,
+	/*  bit selects channels 1/0 for analog input/output, otherwise 0/1 */
+	DMA_CH_SELECT_BIT = 0x8000,
+	FIFO_SIZE_REG = 0x4,		/*  allows adjustment of fifo sizes */
 	DAC_FIFO_SIZE_MASK = 0xff00,	/*  bits that set dac fifo size */
-	DAC_FIFO_BITS = 0xf800,	/* 8k sample ao fifo */
+	DAC_FIFO_BITS = 0xf800,		/*  8k sample ao fifo */
 };
 #define DAC_FIFO_SIZE 0x2000
 
 enum daq_atrig_low_4020_contents {
-	EXT_AGATE_BNC_BIT = 0x8000,	/*  use trig/ext clk bnc input for analog gate signal */
-	EXT_STOP_TRIG_BNC_BIT = 0x4000,	/*  use trig/ext clk bnc input for external stop trigger signal */
-	EXT_START_TRIG_BNC_BIT = 0x2000,	/*  use trig/ext clk bnc input for external start trigger signal */
+	/*  use trig/ext clk bnc input for analog gate signal */
+	EXT_AGATE_BNC_BIT = 0x8000,
+	/*  use trig/ext clk bnc input for external stop trigger signal */
+	EXT_STOP_TRIG_BNC_BIT = 0x4000,
+	/*  use trig/ext clk bnc input for external start trigger signal */
+	EXT_START_TRIG_BNC_BIT = 0x2000,
 };
+
 static inline uint16_t analog_trig_low_threshold_bits(uint16_t threshold)
 {
 	return threshold & 0xfff;
@@ -247,14 +273,17 @@ enum adc_control0_contents {
 	ADC_START_TRIG_ANALOG_BITS = 0x30,
 	ADC_START_TRIG_MASK = 0x30,
 	ADC_START_TRIG_FALLING_BIT = 0x40,	/*  trig 1 uses falling edge */
-	ADC_EXT_CONV_FALLING_BIT = 0x800,	/*  external pacing uses falling edge */
-	ADC_SAMPLE_COUNTER_EN_BIT = 0x1000,	/*  enable hardware scan counter */
+	/*  external pacing uses falling edge */
+	ADC_EXT_CONV_FALLING_BIT = 0x800,
+	/*  enable hardware scan counter */
+	ADC_SAMPLE_COUNTER_EN_BIT = 0x1000,
 	ADC_DMA_DISABLE_BIT = 0x4000,	/*  disables dma */
 	ADC_ENABLE_BIT = 0x8000,	/*  master adc enable */
 };
 
 enum adc_control1_contents {
-	ADC_QUEUE_CONFIG_BIT = 0x1,	/*  should be set for boards with > 16 channels */
+	/*  should be set for boards with > 16 channels */
+	ADC_QUEUE_CONFIG_BIT = 0x1,
 	CONVERT_POLARITY_BIT = 0x10,
 	EOC_POLARITY_BIT = 0x20,
 	ADC_SW_GATE_BIT = 0x40,	/*  software gate of adc */
@@ -263,10 +292,11 @@ enum adc_control1_contents {
 	ADC_LO_CHANNEL_4020_MASK = 0x300,
 	ADC_HI_CHANNEL_4020_MASK = 0xc00,
 	TWO_CHANNEL_4020_BITS = 0x1000,	/*  two channel mode for 4020 */
-	FOUR_CHANNEL_4020_BITS = 0x2000,	/*  four channel mode for 4020 */
+	FOUR_CHANNEL_4020_BITS = 0x2000, /*  four channel mode for 4020 */
 	CHANNEL_MODE_4020_MASK = 0x3000,
 	ADC_MODE_MASK = 0xf000,
 };
+
 static inline uint16_t adc_lo_chan_4020_bits(unsigned int channel)
 {
 	return (channel & 0x3) << 8;
@@ -289,9 +319,10 @@ enum calibration_contents {
 	CAL_EN_64XX_BIT = 0x40,	/*  calibration enable for 64xx series */
 	SERIAL_DATA_IN_BIT = 0x80,
 	SERIAL_CLOCK_BIT = 0x100,
-	CAL_EN_60XX_BIT = 0x200,	/*  calibration enable for 60xx series */
+	CAL_EN_60XX_BIT = 0x200, /*  calibration enable for 60xx series */
 	CAL_GAIN_BIT = 0x800,
 };
+
 /* calibration sources for 6025 are:
  *  0 : ground
  *  1 : 10V
@@ -302,6 +333,7 @@ enum calibration_contents {
  *  6 : dac channel 0
  *  7 : dac channel 1
  */
+
 static inline uint16_t adc_src_bits(unsigned int source)
 {
 	return (source & 0xf) << 3;
@@ -315,10 +347,12 @@ static inline uint16_t adc_convert_chan_4020_bits(unsigned int channel)
 enum adc_queue_load_contents {
 	UNIP_BIT = 0x800,	/*  unipolar/bipolar bit */
 	ADC_SE_DIFF_BIT = 0x1000,	/*  single-ended/ differential bit */
-	ADC_COMMON_BIT = 0x2000,	/*  non-referenced single-ended (common-mode input) */
+	/*  non-referenced single-ended (common-mode input) */
+	ADC_COMMON_BIT = 0x2000,
 	QUEUE_EOSEQ_BIT = 0x4000,	/*  queue end of sequence */
 	QUEUE_EOSCAN_BIT = 0x8000,	/*  queue end of scan */
 };
+
 static inline uint16_t adc_chan_bits(unsigned int channel)
 {
 	return channel & 0x3f;
@@ -365,6 +399,7 @@ enum hw_status_contents {
 	EXT_INTR_PENDING_BIT = 0x100,
 	ADC_STOP_BIT = 0x200,
 };
+
 static inline uint16_t pipe_full_bits(uint16_t hw_status_bits)
 {
 	return (hw_status_bits >> 10) & 0x3;
@@ -393,9 +428,12 @@ enum i2c_addresses {
 };
 
 enum range_cal_i2c_contents {
-	ADC_SRC_4020_MASK = 0x70,	/*  bits that set what source the adc converter measures */
-	BNC_TRIG_THRESHOLD_0V_BIT = 0x80,	/*  make bnc trig/ext clock threshold 0V instead of 2.5V */
+	/*  bits that set what source the adc converter measures */
+	ADC_SRC_4020_MASK = 0x70,
+	/*  make bnc trig/ext clock threshold 0V instead of 2.5V */
+	BNC_TRIG_THRESHOLD_0V_BIT = 0x80,
 };
+
 static inline uint8_t adc_src_4020_bits(unsigned int source)
 {
 	return (source << 4) & ADC_SRC_4020_MASK;
@@ -562,11 +600,12 @@ struct pcidas64_board {
 	const struct comedi_lrange *ai_range_table;
 	int ao_nchan;		/*  number of analog out channels */
 	int ao_bits;		/*  analog output resolution */
-	int ao_scan_speed;	/*  analog output speed (for a scan, not conversion) */
+	int ao_scan_speed;	/*  analog output scan speed */
 	const struct comedi_lrange *ao_range_table;
 	const int *ao_range_code;
 	const struct hw_fifo_info *const ai_fifo;
-	enum register_layout layout;	/*  different board families have slightly different registers */
+	/*  different board families have slightly different registers */
+	enum register_layout layout;
 	unsigned has_8255:1;
 };
 
@@ -1041,8 +1080,10 @@ static inline unsigned short se_diff_bit_6xxx(struct comedi_device *dev,
 };
 
 struct ext_clock_info {
-	unsigned int divisor;	/*  master clock divisor to use for scans with external master clock */
-	unsigned int chanspec;	/*  chanspec for master clock input when used as scan begin src */
+	/*  master clock divisor to use for scans with external master clock */
+	unsigned int divisor;
+	/*  chanspec for master clock input when used as scan begin src */
+	unsigned int chanspec;
 };
 
 /* this structure is for data unique to this hardware driver. */
@@ -1058,30 +1099,52 @@ struct pcidas64_private {
 	/*  local address (used by dma controller) */
 	uint32_t local0_iobase;
 	uint32_t local1_iobase;
-	volatile unsigned int ai_count;	/*  number of analog input samples remaining */
-	uint16_t *ai_buffer[MAX_AI_DMA_RING_COUNT];	/*  dma buffers for analog input */
-	dma_addr_t ai_buffer_bus_addr[MAX_AI_DMA_RING_COUNT];	/*  physical addresses of ai dma buffers */
-	struct plx_dma_desc *ai_dma_desc;	/*  array of ai dma descriptors read by plx9080, allocated to get proper alignment */
-	dma_addr_t ai_dma_desc_bus_addr;	/*  physical address of ai dma descriptor array */
-	volatile unsigned int ai_dma_index;	/*  index of the ai dma descriptor/buffer that is currently being used */
-	uint16_t *ao_buffer[AO_DMA_RING_COUNT];	/*  dma buffers for analog output */
-	dma_addr_t ao_buffer_bus_addr[AO_DMA_RING_COUNT];	/*  physical addresses of ao dma buffers */
+	/*  number of analog input samples remaining */
+	volatile unsigned int ai_count;
+	/*  dma buffers for analog input */
+	uint16_t *ai_buffer[MAX_AI_DMA_RING_COUNT];
+	/*  physical addresses of ai dma buffers */
+	dma_addr_t ai_buffer_bus_addr[MAX_AI_DMA_RING_COUNT];
+	/*  array of ai dma descriptors read by plx9080,
+	 *  allocated to get proper alignment */
+	struct plx_dma_desc *ai_dma_desc;
+	/*  physical address of ai dma descriptor array */
+	dma_addr_t ai_dma_desc_bus_addr;
+	/*  index of the ai dma descriptor/buffer
+	 *  that is currently being used */
+	volatile unsigned int ai_dma_index;
+	/*  dma buffers for analog output */
+	uint16_t *ao_buffer[AO_DMA_RING_COUNT];
+	/*  physical addresses of ao dma buffers */
+	dma_addr_t ao_buffer_bus_addr[AO_DMA_RING_COUNT];
 	struct plx_dma_desc *ao_dma_desc;
 	dma_addr_t ao_dma_desc_bus_addr;
-	volatile unsigned int ao_dma_index;	/*  keeps track of buffer where the next ao sample should go */
-	volatile unsigned long ao_count;	/*  number of analog output samples remaining */
-	volatile unsigned int ao_value[2];	/*  remember what the analog outputs are set to, to allow readback */
+	/*  keeps track of buffer where the next ao sample should go */
+	volatile unsigned int ao_dma_index;
+	/*  number of analog output samples remaining */
+	volatile unsigned long ao_count;
+	/*  remember what the analog outputs are set to, to allow readback */
+	volatile unsigned int ao_value[2];
 	unsigned int hw_revision;	/*  stc chip hardware revision number */
-	volatile unsigned int intr_enable_bits;	/*  last bits sent to INTR_ENABLE_REG register */
-	volatile uint16_t adc_control1_bits;	/*  last bits sent to ADC_CONTROL1_REG register */
-	volatile uint16_t fifo_size_bits;	/*  last bits sent to FIFO_SIZE_REG register */
-	volatile uint16_t hw_config_bits;	/*  last bits sent to HW_CONFIG_REG register */
+	/*  last bits sent to INTR_ENABLE_REG register */
+	volatile unsigned int intr_enable_bits;
+	/*  last bits sent to ADC_CONTROL1_REG register */
+	volatile uint16_t adc_control1_bits;
+	/*  last bits sent to FIFO_SIZE_REG register */
+	volatile uint16_t fifo_size_bits;
+	/*  last bits sent to HW_CONFIG_REG register */
+	volatile uint16_t hw_config_bits;
 	volatile uint16_t dac_control1_bits;
-	volatile uint32_t plx_control_bits;	/*  last bits written to plx9080 control register */
-	volatile uint32_t plx_intcsr_bits;	/*  last bits written to plx interrupt control and status register */
-	volatile int calibration_source;	/*  index of calibration source readable through ai ch0 */
-	volatile uint8_t i2c_cal_range_bits;	/*  bits written to i2c calibration/range register */
-	volatile unsigned int ext_trig_falling;	/*  configure digital triggers to trigger on falling edge */
+	/*  last bits written to plx9080 control register */
+	volatile uint32_t plx_control_bits;
+	/*  last bits written to plx interrupt control and status register */
+	volatile uint32_t plx_intcsr_bits;
+	/*  index of calibration source readable through ai ch0 */
+	volatile int calibration_source;
+	/*  bits written to i2c calibration/range register */
+	volatile uint8_t i2c_cal_range_bits;
+	/*  configure digital triggers to trigger on falling edge */
+	volatile unsigned int ext_trig_falling;
 	/*  states of various devices stored to enable read-back */
 	unsigned int ad8402_state[2];
 	unsigned int caldac_state[8];
@@ -1147,7 +1210,8 @@ static void caldac_write(struct comedi_device *dev, unsigned int channel,
 			 unsigned int value);
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 			     uint8_t value);
-/* static int dac_1590_write(struct comedi_device *dev, unsigned int dac_a, unsigned int dac_b); */
+/* static int dac_1590_write(struct comedi_device *dev, unsigned int dac_a,
+ *                           unsigned int dac_b); */
 static int caldac_i2c_write(struct comedi_device *dev,
 			    unsigned int caldac_channel, unsigned int value);
 static void abort_dma(struct comedi_device *dev, unsigned int channel);
@@ -1169,7 +1233,7 @@ static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 				       unsigned int range_index)
 {
 	const struct comedi_krange *range =
-	    &board(dev)->ai_range_table->range[range_index];
+		&board(dev)->ai_range_table->range[range_index];
 	unsigned int bits = 0;
 
 	switch (range->max) {
@@ -1246,7 +1310,7 @@ static void init_plx9080(struct comedi_device *dev)
 	void __iomem *plx_iobase = devpriv->plx9080_iobase;
 
 	devpriv->plx_control_bits =
-	    readl(devpriv->plx9080_iobase + PLX_CONTROL_REG);
+		readl(devpriv->plx9080_iobase + PLX_CONTROL_REG);
 
 	/*  plx9080 dump */
 	DEBUG_PRINT(" plx interrupt status 0x%x\n",
@@ -1300,9 +1364,11 @@ static void init_plx9080(struct comedi_device *dev)
 	bits |= PLX_EN_BTERM_BIT;
 	/*  enable dma chaining */
 	bits |= PLX_EN_CHAIN_BIT;
-	/*  enable interrupt on dma done (probably don't need this, since chain never finishes) */
+	/*  enable interrupt on dma done
+	 *  (probably don't need this, since chain never finishes) */
 	bits |= PLX_EN_DMA_DONE_INTR_BIT;
-	/*  don't increment local address during transfers (we are transferring from a fixed fifo register) */
+	/*  don't increment local address during transfers
+	 *  (we are transferring from a fixed fifo register) */
 	bits |= PLX_LOCAL_ADDR_CONST_BIT;
 	/*  route dma interrupt to pci bus */
 	bits |= PLX_DMA_INTR_PCI_BIT;
@@ -1311,11 +1377,10 @@ static void init_plx9080(struct comedi_device *dev)
 	/*  enable local burst mode */
 	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
 	/*  4020 uses 32 bit dma */
-	if (board(dev)->layout == LAYOUT_4020) {
+	if (board(dev)->layout == LAYOUT_4020)
 		bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
-	} else {		/*  localspace0 bus is 16 bits wide */
+	else		/*  localspace0 bus is 16 bits wide */
 		bits |= PLX_LOCAL_BUS_16_WIDE_BITS;
-	}
 	writel(bits, plx_iobase + PLX_DMA1_MODE_REG);
 	if (ao_cmd_is_supported(board(dev)))
 		writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
@@ -1363,7 +1428,8 @@ static int setup_subdevices(struct comedi_device *dev)
 	s->cancel = ai_cancel;
 	if (board(dev)->layout == LAYOUT_4020) {
 		uint8_t data;
-		/*  set adc to read from inputs (not internal calibration sources) */
+		/*  set adc to read from inputs
+		 *  (not internal calibration sources) */
 		devpriv->i2c_cal_range_bits = adc_src_4020_bits(4);
 		/*  set channels to +-5 volt input ranges */
 		for (i = 0; i < s->n_chan; i++)
@@ -1376,8 +1442,8 @@ static int setup_subdevices(struct comedi_device *dev)
 	s = &dev->subdevices[1];
 	if (board(dev)->ao_nchan) {
 		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags =
-		    SDF_READABLE | SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE |
+				  SDF_GROUND | SDF_CMD_WRITE;
 		s->n_chan = board(dev)->ao_nchan;
 		s->maxdata = (1 << board(dev)->ao_bits) - 1;
 		s->range_table = board(dev)->ao_range_table;
@@ -1422,13 +1488,12 @@ static int setup_subdevices(struct comedi_device *dev)
 	s = &dev->subdevices[4];
 	if (board(dev)->has_8255) {
 		if (board(dev)->layout == LAYOUT_4020) {
-			dio_8255_iobase =
-			    devpriv->main_iobase + I8255_4020_REG;
+			dio_8255_iobase = devpriv->main_iobase + I8255_4020_REG;
 			subdev_8255_init(dev, s, dio_callback_4020,
 					 (unsigned long)dio_8255_iobase);
 		} else {
 			dio_8255_iobase =
-			    devpriv->dio_counter_iobase + DIO_8255_OFFSET;
+				devpriv->dio_counter_iobase + DIO_8255_OFFSET;
 			subdev_8255_init(dev, s, dio_callback,
 					 (unsigned long)dio_8255_iobase);
 		}
@@ -1511,7 +1576,8 @@ static void init_stc_registers(struct comedi_device *dev)
 
 	spin_lock_irqsave(&dev->spinlock, flags);
 
-	/*  bit should be set for 6025, although docs say boards with <= 16 chans should be cleared XXX */
+	/*  bit should be set for 6025,
+	 *  although docs say boards with <= 16 chans should be cleared XXX */
 	if (1)
 		devpriv->adc_control1_bits |= ADC_QUEUE_CONFIG_BIT;
 	writew(devpriv->adc_control1_bits,
@@ -1538,8 +1604,9 @@ static void init_stc_registers(struct comedi_device *dev)
 				   board(dev)->ai_fifo->max_segment_length);
 
 	devpriv->dac_control1_bits = DAC_OUTPUT_ENABLE_BIT;
-	devpriv->intr_enable_bits =	/* EN_DAC_INTR_SRC_BIT | DAC_INTR_QEMPTY_BITS | */
-	    EN_DAC_DONE_INTR_BIT | EN_DAC_UNDERRUN_BIT;
+	devpriv->intr_enable_bits =
+		/* EN_DAC_INTR_SRC_BIT | DAC_INTR_QEMPTY_BITS | */
+		EN_DAC_DONE_INTR_BIT | EN_DAC_UNDERRUN_BIT;
 	writew(devpriv->intr_enable_bits,
 	       devpriv->main_iobase + INTR_ENABLE_REG);
 
@@ -1555,8 +1622,8 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	/*  alocate pci dma buffers */
 	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 		devpriv->ai_buffer[i] =
-		    pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
-					 &devpriv->ai_buffer_bus_addr[i]);
+			pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
+					     &devpriv->ai_buffer_bus_addr[i]);
 		if (devpriv->ai_buffer[i] == NULL)
 			return -ENOMEM;
 
@@ -1564,10 +1631,9 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 		if (ao_cmd_is_supported(board(dev))) {
 			devpriv->ao_buffer[i] =
-			    pci_alloc_consistent(pcidev,
-						 DMA_BUFFER_SIZE,
-						 &devpriv->
-						 ao_buffer_bus_addr[i]);
+				pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
+						     &devpriv->
+						      ao_buffer_bus_addr[i]);
 			if (devpriv->ao_buffer[i] == NULL)
 				return -ENOMEM;
 
@@ -1575,10 +1641,9 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	}
 	/*  allocate dma descriptors */
 	devpriv->ai_dma_desc =
-	    pci_alloc_consistent(pcidev,
-				 sizeof(struct plx_dma_desc) *
-				 ai_dma_ring_count(board(dev)),
-				 &devpriv->ai_dma_desc_bus_addr);
+		pci_alloc_consistent(pcidev, sizeof(struct plx_dma_desc) *
+				     ai_dma_ring_count(board(dev)),
+				     &devpriv->ai_dma_desc_bus_addr);
 	if (devpriv->ai_dma_desc == NULL)
 		return -ENOMEM;
 
@@ -1586,10 +1651,10 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 		    (unsigned long long)devpriv->ai_dma_desc_bus_addr);
 	if (ao_cmd_is_supported(board(dev))) {
 		devpriv->ao_dma_desc =
-		    pci_alloc_consistent(pcidev,
-					 sizeof(struct plx_dma_desc) *
-					 AO_DMA_RING_COUNT,
-					 &devpriv->ao_dma_desc_bus_addr);
+			pci_alloc_consistent(pcidev,
+					     sizeof(struct plx_dma_desc) *
+					     AO_DMA_RING_COUNT,
+					     &devpriv->ao_dma_desc_bus_addr);
 		if (devpriv->ao_dma_desc == NULL)
 			return -ENOMEM;
 
@@ -1599,41 +1664,37 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	/*  initialize dma descriptors */
 	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 		devpriv->ai_dma_desc[i].pci_start_addr =
-		    cpu_to_le32(devpriv->ai_buffer_bus_addr[i]);
+			cpu_to_le32(devpriv->ai_buffer_bus_addr[i]);
 		if (board(dev)->layout == LAYOUT_4020)
 			devpriv->ai_dma_desc[i].local_start_addr =
-			    cpu_to_le32(devpriv->local1_iobase +
-					ADC_FIFO_REG);
+				cpu_to_le32(devpriv->local1_iobase +
+					    ADC_FIFO_REG);
 		else
 			devpriv->ai_dma_desc[i].local_start_addr =
-			    cpu_to_le32(devpriv->local0_iobase +
-					ADC_FIFO_REG);
+				cpu_to_le32(devpriv->local0_iobase +
+					    ADC_FIFO_REG);
 		devpriv->ai_dma_desc[i].transfer_size = cpu_to_le32(0);
 		devpriv->ai_dma_desc[i].next =
-		    cpu_to_le32((devpriv->ai_dma_desc_bus_addr + ((i +
-								     1) %
-								    ai_dma_ring_count
-								    (board
-								     (dev))) *
-				 sizeof(devpriv->ai_dma_desc[0])) |
-				PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
-				PLX_XFER_LOCAL_TO_PCI);
+			cpu_to_le32((devpriv->ai_dma_desc_bus_addr +
+				     ((i + 1) % ai_dma_ring_count(board(dev))) *
+				     sizeof(devpriv->ai_dma_desc[0])) |
+				    PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
+				    PLX_XFER_LOCAL_TO_PCI);
 	}
 	if (ao_cmd_is_supported(board(dev))) {
 		for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 			devpriv->ao_dma_desc[i].pci_start_addr =
-			    cpu_to_le32(devpriv->ao_buffer_bus_addr[i]);
+				cpu_to_le32(devpriv->ao_buffer_bus_addr[i]);
 			devpriv->ao_dma_desc[i].local_start_addr =
-			    cpu_to_le32(devpriv->local0_iobase +
-					DAC_FIFO_REG);
-			devpriv->ao_dma_desc[i].transfer_size =
-			    cpu_to_le32(0);
+				cpu_to_le32(devpriv->local0_iobase +
+					    DAC_FIFO_REG);
+			devpriv->ao_dma_desc[i].transfer_size = cpu_to_le32(0);
 			devpriv->ao_dma_desc[i].next =
-			    cpu_to_le32((devpriv->ao_dma_desc_bus_addr +
-					 ((i + 1) % (AO_DMA_RING_COUNT)) *
-					 sizeof(devpriv->ao_dma_desc[0])) |
-					PLX_DESC_IN_PCI_BIT |
-					PLX_INTR_TERM_COUNT);
+				cpu_to_le32((devpriv->ao_dma_desc_bus_addr +
+					     ((i + 1) % (AO_DMA_RING_COUNT)) *
+					     sizeof(devpriv->ao_dma_desc[0])) |
+					    PLX_DESC_IN_PCI_BIT |
+					    PLX_INTR_TERM_COUNT);
 		}
 	}
 	return 0;
@@ -1692,21 +1753,21 @@ static int __devinit auto_attach(struct comedi_device *dev,
 	dev->iobase = pci_resource_start(pcidev, MAIN_BADDRINDEX);
 
 	devpriv->plx9080_phys_iobase =
-	    pci_resource_start(pcidev, PLX9080_BADDRINDEX);
+		pci_resource_start(pcidev, PLX9080_BADDRINDEX);
 	devpriv->main_phys_iobase = dev->iobase;
 	devpriv->dio_counter_phys_iobase =
-	    pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
+		pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
 
 	/*  remap, won't work with 2.0 kernels but who cares */
-	devpriv->plx9080_iobase = ioremap(devpriv->plx9080_phys_iobase,
-					    pci_resource_len(pcidev,
-							     PLX9080_BADDRINDEX));
+	devpriv->plx9080_iobase =
+		ioremap(devpriv->plx9080_phys_iobase,
+			pci_resource_len(pcidev, PLX9080_BADDRINDEX));
 	devpriv->main_iobase =
-	    ioremap(devpriv->main_phys_iobase,
-		    pci_resource_len(pcidev, MAIN_BADDRINDEX));
+		ioremap(devpriv->main_phys_iobase,
+			pci_resource_len(pcidev, MAIN_BADDRINDEX));
 	devpriv->dio_counter_iobase =
-	    ioremap(devpriv->dio_counter_phys_iobase,
-		    pci_resource_len(pcidev, DIO_COUNTER_BADDRINDEX));
+		ioremap(devpriv->dio_counter_phys_iobase,
+			pci_resource_len(pcidev, DIO_COUNTER_BADDRINDEX));
 
 	if (!devpriv->plx9080_iobase || !devpriv->main_iobase
 	    || !devpriv->dio_counter_iobase) {
@@ -1720,22 +1781,18 @@ static int __devinit auto_attach(struct comedi_device *dev,
 		    devpriv->dio_counter_iobase);
 
 	/*  figure out what local addresses are */
-	local_range =
-	    readl(devpriv->plx9080_iobase + PLX_LAS0RNG_REG) & LRNG_MEM_MASK;
-	local_decode =
-	    readl(devpriv->plx9080_iobase +
-		  PLX_LAS0MAP_REG) & local_range & LMAP_MEM_MASK;
-	devpriv->local0_iobase =
-	    ((uint32_t) devpriv->main_phys_iobase & ~local_range) |
-	    local_decode;
-	local_range =
-	    readl(devpriv->plx9080_iobase + PLX_LAS1RNG_REG) & LRNG_MEM_MASK;
-	local_decode =
-	    readl(devpriv->plx9080_iobase +
-		  PLX_LAS1MAP_REG) & local_range & LMAP_MEM_MASK;
-	devpriv->local1_iobase =
-	    ((uint32_t) devpriv->dio_counter_phys_iobase & ~local_range) |
-	    local_decode;
+	local_range = readl(devpriv->plx9080_iobase + PLX_LAS0RNG_REG) &
+		      LRNG_MEM_MASK;
+	local_decode = readl(devpriv->plx9080_iobase + PLX_LAS0MAP_REG) &
+		       local_range & LMAP_MEM_MASK;
+	devpriv->local0_iobase = ((uint32_t)devpriv->main_phys_iobase &
+				  ~local_range) | local_decode;
+	local_range = readl(devpriv->plx9080_iobase + PLX_LAS1RNG_REG) &
+		      LRNG_MEM_MASK;
+	local_decode = readl(devpriv->plx9080_iobase + PLX_LAS1MAP_REG) &
+		       local_range & LMAP_MEM_MASK;
+	devpriv->local1_iobase = ((uint32_t)devpriv->dio_counter_phys_iobase &
+				  ~local_range) | local_decode;
 
 	DEBUG_PRINT(" local 0 io addr 0x%x\n", devpriv->local0_iobase);
 	DEBUG_PRINT(" local 1 io addr 0x%x\n", devpriv->local1_iobase);
@@ -1745,7 +1802,7 @@ static int __devinit auto_attach(struct comedi_device *dev,
 		return retval;
 
 	devpriv->hw_revision =
-	    hw_revision(dev, readw(devpriv->main_iobase + HW_STATUS_REG));
+		hw_revision(dev, readw(devpriv->main_iobase + HW_STATUS_REG));
 	dev_dbg(dev->class_dev, "stc hardware revision %i\n",
 		devpriv->hw_revision);
 	init_plx9080(dev);
@@ -1764,7 +1821,6 @@ static int __devinit auto_attach(struct comedi_device *dev,
 	if (retval < 0)
 		return retval;
 
-
 	return 0;
 }
 
@@ -1866,12 +1922,14 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 				cal_en_bit = CAL_EN_60XX_BIT;
 			else
 				cal_en_bit = CAL_EN_64XX_BIT;
-			/*  select internal reference source to connect to channel 0 */
+			/*  select internal reference source to connect
+			 *  to channel 0 */
 			writew(cal_en_bit |
 			       adc_src_bits(devpriv->calibration_source),
 			       devpriv->main_iobase + CALIBRATION_REG);
 		} else {
-			/*  make sure internal calibration source is turned off */
+			/*  make sure internal calibration source
+			 *  is turned off */
 			writew(0, devpriv->main_iobase + CALIBRATION_REG);
 		}
 		/*  load internal queue */
@@ -1895,7 +1953,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (insn->chanspec & CR_ALT_SOURCE) {
 			DEBUG_PRINT("reading calibration source\n");
 			devpriv->i2c_cal_range_bits |=
-			    adc_src_4020_bits(devpriv->calibration_source);
+				adc_src_4020_bits(devpriv->calibration_source);
 		} else {	/* select BNC inputs */
 			devpriv->i2c_cal_range_bits |= adc_src_4020_bits(4);
 		}
@@ -1903,21 +1961,21 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (range == 0)
 			devpriv->i2c_cal_range_bits |= attenuate_bit(channel);
 		else
-			devpriv->i2c_cal_range_bits &=
-			    ~attenuate_bit(channel);
-		/*  update calibration/range i2c register only if necessary, as it is very slow */
+			devpriv->i2c_cal_range_bits &= ~attenuate_bit(channel);
+		/*  update calibration/range i2c register only if necessary,
+		 *  as it is very slow */
 		if (old_cal_range_bits != devpriv->i2c_cal_range_bits) {
 			uint8_t i2c_data = devpriv->i2c_cal_range_bits;
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
 				  sizeof(i2c_data));
 		}
 
-		/* 4020 manual asks that sample interval register to be set before writing to convert register.
-		 * Using somewhat arbitrary setting of 4 master clock ticks = 0.1 usec */
-		writew(0,
-		       devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
-		writew(2,
-		       devpriv->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
+		/* 4020 manual asks that sample interval register to be set
+		 * before writing to convert register.
+		 * Using somewhat arbitrary setting of 4 master clock ticks
+		 * = 0.1 usec */
+		writew(0, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
+		writew(2, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
 	}
 
 	for (n = 0; n < insn->n; n++) {
@@ -1950,12 +2008,10 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			return -ETIME;
 		}
 		if (board(dev)->layout == LAYOUT_4020)
-			data[n] =
-			    readl(devpriv->dio_counter_iobase +
-				  ADC_FIFO_REG) & 0xffff;
+			data[n] = readl(devpriv->dio_counter_iobase +
+					ADC_FIFO_REG) & 0xffff;
 		else
-			data[n] =
-			    readw(devpriv->main_iobase + PIPE1_READ_REG);
+			data[n] = readw(devpriv->main_iobase + PIPE1_READ_REG);
 	}
 
 	return n;
@@ -1994,8 +2050,8 @@ static int ai_config_block_size(struct comedi_device *dev, unsigned int *data)
 	requested_block_size = data[1];
 
 	if (requested_block_size) {
-		fifo_size =
-		    requested_block_size * fifo->num_segments / bytes_in_sample;
+		fifo_size = requested_block_size * fifo->num_segments /
+			    bytes_in_sample;
 
 		retval = set_ai_fifo_size(dev, fifo_size);
 		if (retval < 0)
@@ -2101,10 +2157,9 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	else
 		triggers |= TRIG_EXT;
 	err |= cfc_check_trigger_src(&cmd->convert_src, triggers);
-
 	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 	err |= cfc_check_trigger_src(&cmd->stop_src,
-					TRIG_COUNT | TRIG_EXT | TRIG_NONE);
+				     TRIG_COUNT | TRIG_EXT | TRIG_NONE);
 
 	if (err)
 		return 1;
@@ -2141,12 +2196,13 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 				err++;
 			}
 			if (cmd->scan_begin_src == TRIG_TIMER) {
-				/*  if scans are timed faster than conversion rate allows */
+				/*  if scans are timed faster than
+				 *  conversion rate allows */
 				if (cmd->convert_arg * cmd->chanlist_len >
 				    cmd->scan_begin_arg) {
 					cmd->scan_begin_arg =
-					    cmd->convert_arg *
-					    cmd->chanlist_len;
+						cmd->convert_arg *
+						cmd->chanlist_len;
 					err++;
 				}
 			}
@@ -2272,9 +2328,8 @@ static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int num_samples;
 
-	num_samples =
-	    devpriv->ai_fifo_segment_length *
-	    board(dev)->ai_fifo->sample_packing_ratio;
+	num_samples = devpriv->ai_fifo_segment_length *
+		      board(dev)->ai_fifo->sample_packing_ratio;
 	if (num_samples > DMA_BUFFER_SIZE / sizeof(uint16_t))
 		num_samples = DMA_BUFFER_SIZE / sizeof(uint16_t);
 
@@ -2306,9 +2361,9 @@ static void disable_ai_interrupts(struct comedi_device *dev)
 
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->intr_enable_bits &=
-	    ~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &
-	    ~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &
-	    ~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;
+		~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &
+		~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &
+		~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;
 	writew(devpriv->intr_enable_bits,
 	       devpriv->main_iobase + INTR_ENABLE_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -2324,8 +2379,9 @@ static void enable_ai_interrupts(struct comedi_device *dev,
 	unsigned long flags;
 
 	bits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |
-	    EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;
-	/*  Use pio transfer and interrupt on end of conversion if TRIG_WAKE_EOS flag is set. */
+	       EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;
+	/*  Use pio transfer and interrupt on end of conversion
+	 *  if TRIG_WAKE_EOS flag is set. */
 	if (cmd->flags & TRIG_WAKE_EOS) {
 		/*  4020 doesn't support pio transfers except for fifo dregs */
 		if (board(dev)->layout != LAYOUT_4020)
@@ -2350,12 +2406,13 @@ static uint32_t ai_scan_counter_6xxx(struct comedi_device *dev,
 				     struct comedi_cmd *cmd)
 {
 	uint32_t count;
+
 	/*  figure out how long we need to delay at end of scan */
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
 		count = (cmd->scan_begin_arg -
-			 (cmd->convert_arg * (cmd->chanlist_len - 1)))
-		    / TIMER_BASE;
+			 (cmd->convert_arg * (cmd->chanlist_len - 1))) /
+			TIMER_BASE;
 		break;
 	case TRIG_FOLLOW:
 		count = cmd->convert_arg / TIMER_BASE;
@@ -2477,6 +2534,7 @@ static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 static int use_internal_queue_6xxx(const struct comedi_cmd *cmd)
 {
 	int i;
+
 	for (i = 0; i + 1 < cmd->chanlist_len; i++) {
 		if (CR_CHAN(cmd->chanlist[i + 1]) !=
 		    CR_CHAN(cmd->chanlist[i]) + 1)
@@ -2539,8 +2597,8 @@ static int setup_channel_queue(struct comedi_device *dev,
 			for (i = 0; i < cmd->chanlist_len; i++) {
 				bits = 0;
 				/*  set channel */
-				bits |=
-				    adc_chan_bits(CR_CHAN(cmd->chanlist[i]));
+				bits |= adc_chan_bits(CR_CHAN(cmd->
+							      chanlist[i]));
 				/*  set gain */
 				bits |= ai_range_bits_6xxx(dev,
 							   CR_RANGE(cmd->
@@ -2556,13 +2614,13 @@ static int setup_channel_queue(struct comedi_device *dev,
 				/*  mark end of queue */
 				if (i == cmd->chanlist_len - 1)
 					bits |= QUEUE_EOSCAN_BIT |
-					    QUEUE_EOSEQ_BIT;
+						QUEUE_EOSEQ_BIT;
 				writew(bits,
 				       devpriv->main_iobase +
 				       ADC_QUEUE_FIFO_REG);
-				DEBUG_PRINT
-				    ("wrote 0x%x to external channel queue\n",
-				     bits);
+				DEBUG_PRINT(
+					    "wrote 0x%x to external channel queue\n",
+					    bits);
 			}
 			/* doing a queue clear is not specified in board docs,
 			 * but required for reliable operation */
@@ -2571,8 +2629,7 @@ static int setup_channel_queue(struct comedi_device *dev,
 			writew(0, devpriv->main_iobase + ADC_QUEUE_LOAD_REG);
 		}
 	} else {
-		unsigned short old_cal_range_bits =
-		    devpriv->i2c_cal_range_bits;
+		unsigned short old_cal_range_bits = devpriv->i2c_cal_range_bits;
 
 		devpriv->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;
 		/* select BNC inputs */
@@ -2584,12 +2641,13 @@ static int setup_channel_queue(struct comedi_device *dev,
 
 			if (range == 0)
 				devpriv->i2c_cal_range_bits |=
-				    attenuate_bit(channel);
+					attenuate_bit(channel);
 			else
 				devpriv->i2c_cal_range_bits &=
-				    ~attenuate_bit(channel);
+					~attenuate_bit(channel);
 		}
-		/*  update calibration/range i2c register only if necessary, as it is very slow */
+		/*  update calibration/range i2c register only if necessary,
+		 *  as it is very slow */
 		if (old_cal_range_bits != devpriv->i2c_cal_range_bits) {
 			uint8_t i2c_data = devpriv->i2c_cal_range_bits;
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
@@ -2662,9 +2720,11 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (board(dev)->layout != LAYOUT_4020) {
 		devpriv->adc_control1_bits &= ~ADC_MODE_MASK;
 		if (cmd->convert_src == TRIG_EXT)
-			devpriv->adc_control1_bits |= adc_mode_bits(13);	/*  good old mode 13 */
+			/*  good old mode 13 */
+			devpriv->adc_control1_bits |= adc_mode_bits(13);
 		else
-			devpriv->adc_control1_bits |= adc_mode_bits(8);	/*  mode 8.  What else could you need? */
+			/*  mode 8.  What else could you need? */
+			devpriv->adc_control1_bits |= adc_mode_bits(8);
 	} else {
 		devpriv->adc_control1_bits &= ~CHANNEL_MODE_4020_MASK;
 		if (cmd->chanlist_len == 4)
@@ -2673,12 +2733,11 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			devpriv->adc_control1_bits |= TWO_CHANNEL_4020_BITS;
 		devpriv->adc_control1_bits &= ~ADC_LO_CHANNEL_4020_MASK;
 		devpriv->adc_control1_bits |=
-		    adc_lo_chan_4020_bits(CR_CHAN(cmd->chanlist[0]));
+			adc_lo_chan_4020_bits(CR_CHAN(cmd->chanlist[0]));
 		devpriv->adc_control1_bits &= ~ADC_HI_CHANNEL_4020_MASK;
 		devpriv->adc_control1_bits |=
-		    adc_hi_chan_4020_bits(CR_CHAN
-					  (cmd->
-					   chanlist[cmd->chanlist_len - 1]));
+			adc_hi_chan_4020_bits(CR_CHAN(cmd->chanlist
+						      [cmd->chanlist_len - 1]));
 	}
 	writew(devpriv->adc_control1_bits,
 	       devpriv->main_iobase + ADC_CONTROL1_REG);
@@ -2695,8 +2754,8 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/*  set dma transfer size */
 		for (i = 0; i < ai_dma_ring_count(board(dev)); i++)
 			devpriv->ai_dma_desc[i].transfer_size =
-			    cpu_to_le32(dma_transfer_size(dev) *
-					sizeof(uint16_t));
+				cpu_to_le32(dma_transfer_size(dev) *
+					    sizeof(uint16_t));
 
 		/*  give location of first dma descriptor */
 		load_first_dma_descriptor(dev, 1,
@@ -2763,18 +2822,19 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 
 	do {
 		/*  get least significant 15 bits */
-		read_index =
-		    readw(devpriv->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
-		write_index =
-		    readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
-		/* Get most significant bits (grey code).  Different boards use different code
-		 * so use a scheme that doesn't depend on encoding.  This read must
+		read_index = readw(devpriv->main_iobase + ADC_READ_PNTR_REG) &
+			     0x7fff;
+		write_index = readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) &
+			      0x7fff;
+		/* Get most significant bits (grey code).
+		 * Different boards use different code so use a scheme
+		 * that doesn't depend on encoding.  This read must
 		 * occur after reading least significant 15 bits to avoid race
 		 * with fifo switching to next segment. */
 		prepost_bits = readw(devpriv->main_iobase + PREPOST_REG);
 
-		/* if read and write pointers are not on the same fifo segment, read to the
-		 * end of the read segment */
+		/* if read and write pointers are not on the same fifo segment,
+		 * read to the end of the read segment */
 		read_segment = adc_upper_read_ptr_code(prepost_bits);
 		write_segment = adc_upper_write_ptr_code(prepost_bits);
 
@@ -2784,7 +2844,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 
 		if (read_segment != write_segment)
 			num_samples =
-			    devpriv->ai_fifo_segment_length - read_index;
+				devpriv->ai_fifo_segment_length - read_index;
 		else
 			num_samples = write_index - read_index;
 
@@ -2814,10 +2874,10 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 	} while (read_segment != write_segment);
 }
 
-/* Read from 32 bit wide ai fifo of 4020 - deal with insane grey coding of pointers.
- * The pci-4020 hardware only supports
- * dma transfers (it only supports the use of pio for draining the last remaining
- * points from the fifo when a data acquisition operation has completed).
+/* Read from 32 bit wide ai fifo of 4020 - deal with insane grey coding of
+ * pointers.  The pci-4020 hardware only supports dma transfers (it only
+ * supports the use of pio for draining the last remaining points from the
+ * fifo when a data acquisition operation has completed).
  */
 static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 {
@@ -2829,9 +2889,9 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 	unsigned int max_transfer = 100000;
 	uint32_t fifo_data;
 	int write_code =
-	    readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
+		readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
 	int read_code =
-	    readw(devpriv->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
+		readw(devpriv->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		if (max_transfer > devpriv->ai_count)
@@ -2846,8 +2906,8 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 			cfc_write_to_buffer(s, (fifo_data >> 16) & 0xffff);
 			i++;
 		}
-		read_code =
-		    readw(devpriv->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
+		read_code = readw(devpriv->main_iobase + ADC_READ_PNTR_REG) &
+			    0x7fff;
 	}
 	devpriv->ai_count -= i;
 }
@@ -2880,8 +2940,8 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 	/*  loop until we have read all the full buffers */
 	for (j = 0, next_transfer_addr = readl(pci_addr_reg);
 	     (next_transfer_addr <
-	      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index]
-	      || next_transfer_addr >=
+	      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] ||
+	      next_transfer_addr >=
 	      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] +
 	      DMA_BUFFER_SIZE) && j < ai_dma_ring_count(board(dev)); j++) {
 		/*  transfer data from dma buffer to comedi buffer */
@@ -2893,19 +2953,18 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 		}
 		cfc_write_array_to_buffer(dev->read_subdev,
 					  devpriv->ai_buffer[devpriv->
-							       ai_dma_index],
+							     ai_dma_index],
 					  num_samples * sizeof(uint16_t));
-		devpriv->ai_dma_index =
-		    (devpriv->ai_dma_index +
-		     1) % ai_dma_ring_count(board(dev));
+		devpriv->ai_dma_index = (devpriv->ai_dma_index + 1) %
+					ai_dma_ring_count(board(dev));
 
 		DEBUG_PRINT("next buffer addr 0x%lx\n",
 			    (unsigned long)devpriv->
 			    ai_buffer_bus_addr[devpriv->ai_dma_index]);
 		DEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);
 	}
-	/* XXX check for dma ring buffer overrun (use end-of-chain bit to mark last
-	 * unused buffer) */
+	/* XXX check for dma ring buffer overrun
+	 * (use end-of-chain bit to mark last unused buffer) */
 }
 
 static void handle_ai_interrupt(struct comedi_device *dev,
@@ -2989,7 +3048,7 @@ static int last_ao_dma_load_completed(struct comedi_device *dev)
 		return 0;
 
 	transfer_address =
-	    readl(devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
+		readl(devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
 	if (transfer_address != devpriv->ao_buffer_bus_addr[buffer_index])
 		return 0;
 
@@ -3030,7 +3089,7 @@ static void restart_ao_dma(struct comedi_device *dev)
 	unsigned int dma_desc_bits;
 
 	dma_desc_bits =
-	    readl(devpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+		readl(devpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 	dma_desc_bits &= ~PLX_END_OF_CHAIN_BIT;
 	DEBUG_PRINT("restarting ao dma, descriptor reg 0x%x\n", dma_desc_bits);
 	load_first_dma_descriptor(dev, 0, dma_desc_bits);
@@ -3058,8 +3117,8 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
-		if ((dma0_status & PLX_DMA_EN_BIT)
-		    && !(dma0_status & PLX_DMA_DONE_BIT))
+		if ((dma0_status & PLX_DMA_EN_BIT) &&
+		    !(dma0_status & PLX_DMA_DONE_BIT))
 			writeb(PLX_DMA_EN_BIT | PLX_CLEAR_DMA_INTR_BIT,
 			       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
 		else
@@ -3074,8 +3133,9 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 				restart_ao_dma(dev);
 		}
 		DEBUG_PRINT(" cleared dma ch0 interrupt\n");
-	} else
+	} else {
 		spin_unlock_irqrestore(&dev->spinlock, flags);
+	}
 
 	if ((status & DAC_DONE_BIT)) {
 		async->events |= COMEDI_CB_EOA;
@@ -3207,7 +3267,7 @@ static void set_dac_control0_reg(struct comedi_device *dev,
 {
 	struct pcidas64_private *devpriv = dev->private;
 	unsigned int bits = DAC_ENABLE_BIT | WAVEFORM_GATE_LEVEL_BIT |
-	    WAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;
+			    WAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;
 
 	if (cmd->start_src == TRIG_EXT) {
 		bits |= WAVEFORM_TRIG_EXT_BITS;
@@ -3311,7 +3371,7 @@ static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 					       ao_buffer[buffer_index],
 					       num_bytes);
 	devpriv->ao_dma_desc[buffer_index].transfer_size =
-	    cpu_to_le32(num_bytes);
+		cpu_to_le32(num_bytes);
 	/* set end of chain bit so we catch underruns */
 	next_bits = le32_to_cpu(devpriv->ao_dma_desc[buffer_index].next);
 	next_bits |= PLX_END_OF_CHAIN_BIT;
@@ -3334,7 +3394,7 @@ static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	unsigned int num_bytes;
 	unsigned int next_transfer_addr;
 	void __iomem *pci_addr_reg =
-	    devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+		devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 	unsigned int buffer_index;
 
 	do {
@@ -3342,8 +3402,8 @@ static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 		/* don't overwrite data that hasn't been transferred yet */
 		next_transfer_addr = readl(pci_addr_reg);
 		if (next_transfer_addr >=
-		    devpriv->ao_buffer_bus_addr[buffer_index]
-		    && next_transfer_addr <
+		    devpriv->ao_buffer_bus_addr[buffer_index] &&
+		    next_transfer_addr <
 		    devpriv->ao_buffer_bus_addr[buffer_index] +
 		    DMA_BUFFER_SIZE)
 			return;
@@ -3459,7 +3519,7 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);
 	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
-					TRIG_TIMER | TRIG_EXT);
+				     TRIG_TIMER | TRIG_EXT);
 	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
 	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);
@@ -3492,8 +3552,8 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		}
 		if (get_ao_divisor(cmd->scan_begin_arg,
 				   cmd->flags) > max_counter_value) {
-			cmd->scan_begin_arg =
-			    (max_counter_value + 2) * TIMER_BASE;
+			cmd->scan_begin_arg = (max_counter_value + 2) *
+					      TIMER_BASE;
 			err++;
 		}
 	}
@@ -3514,8 +3574,8 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp_arg = cmd->scan_begin_arg;
-		cmd->scan_begin_arg =
-		    get_divisor(cmd->scan_begin_arg, cmd->flags) * TIMER_BASE;
+		cmd->scan_begin_arg = get_divisor(cmd->scan_begin_arg,
+						  cmd->flags) * TIMER_BASE;
 		if (tmp_arg != cmd->scan_begin_arg)
 			err++;
 	}
@@ -3771,7 +3831,7 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 	unsigned int bitstream = (read_command << 8) | address;
 	unsigned int bit;
 	void __iomem * const plx_control_addr =
-	    devpriv->plx9080_iobase + PLX_CONTROL_REG;
+		devpriv->plx9080_iobase + PLX_CONTROL_REG;
 	uint16_t value;
 	static const int value_length = 16;
 	static const int eeprom_udelay = 1;
@@ -3844,7 +3904,7 @@ static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 	unsigned int convert_divisor = 0, scan_divisor;
 	static const int min_convert_divisor = 3;
 	static const int max_convert_divisor =
-	    max_counter_value + min_convert_divisor;
+		max_counter_value + min_convert_divisor;
 	static const int min_scan_divisor_4020 = 2;
 	unsigned long long max_scan_divisor, min_scan_divisor;
 
@@ -3852,16 +3912,17 @@ static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 		if (board(dev)->layout == LAYOUT_4020) {
 			cmd->convert_arg = 0;
 		} else {
-			convert_divisor =
-			    get_divisor(cmd->convert_arg, cmd->flags);
+			convert_divisor = get_divisor(cmd->convert_arg,
+						      cmd->flags);
 			if (convert_divisor > max_convert_divisor)
 				convert_divisor = max_convert_divisor;
 			if (convert_divisor < min_convert_divisor)
 				convert_divisor = min_convert_divisor;
 			cmd->convert_arg = convert_divisor * TIMER_BASE;
 		}
-	} else if (cmd->convert_src == TRIG_NOW)
+	} else if (cmd->convert_src == TRIG_NOW) {
 		cmd->convert_arg = 0;
+	}
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		scan_divisor = get_divisor(cmd->scan_begin_arg, cmd->flags);
@@ -3869,8 +3930,8 @@ static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 			/*  XXX check for integer overflows */
 			min_scan_divisor = convert_divisor * cmd->chanlist_len;
 			max_scan_divisor =
-			    (convert_divisor * cmd->chanlist_len - 1) +
-			    max_counter_value;
+				(convert_divisor * cmd->chanlist_len - 1) +
+				max_counter_value;
 		} else {
 			min_scan_divisor = min_scan_divisor_4020;
 			max_scan_divisor = max_counter_value + min_scan_divisor;
@@ -3940,8 +4001,8 @@ static unsigned int ai_fifo_size(struct comedi_device *dev)
 	struct pcidas64_private *devpriv = dev->private;
 
 	return devpriv->ai_fifo_segment_length *
-	    board(dev)->ai_fifo->num_segments *
-	    board(dev)->ai_fifo->sample_packing_ratio;
+	       board(dev)->ai_fifo->num_segments *
+	       board(dev)->ai_fifo->sample_packing_ratio;
 }
 
 static int set_ai_fifo_segment_length(struct comedi_device *dev,
@@ -4187,7 +4248,8 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 	uint8_t bitstream;
 	static const int read_bit = 0x1;
 
-/* XXX need mutex to prevent simultaneous attempts to access eeprom and i2c bus */
+	/* XXX need mutex to prevent simultaneous attempts to access
+	 * eeprom and i2c bus */
 
 	/*  make sure we dont send anything to eeprom */
 	devpriv->plx_control_bits &= ~CTL_EE_CS;

commit 65998b1ba4908115e86d490a7decea60e708be75
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 2 19:17:58 2012 +0000

    staging: comedi: cb_pcidas64: fix printks
    
    Replace `printk` calls with something else.  For the `DEBUG_PRINT()`
    macro, use `pr_debug()` (if `PCIDAS64_DEBUG macro defined) or
    `no_printk()`.
    
    Fix a few `DEBUG_PRINT()` calls due to compiler warnings and add
    newlines where they are missing.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 69db96ff3d55..a431b6d3eae1 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -83,6 +83,8 @@ known. If you have such a board, please file a bug report at
 	make ao fifo size adjustable like ai fifo
 */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include "../comedidev.h"
 #include <linux/delay.h>
 #include <linux/interrupt.h>
@@ -96,9 +98,9 @@ known. If you have such a board, please file a bug report at
 /* #define PCIDAS64_DEBUG         enable debugging code */
 
 #ifdef PCIDAS64_DEBUG
-#define DEBUG_PRINT(format, args...)  printk(format , ## args)
+#define DEBUG_PRINT(format, args...)  pr_debug(format, ## args)
 #else
-#define DEBUG_PRINT(format, args...)
+#define DEBUG_PRINT(format, args...)  no_printk(format, ## args)
 #endif
 
 #define TIMER_BASE 25		/*  40MHz master clock */
@@ -1580,8 +1582,8 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	if (devpriv->ai_dma_desc == NULL)
 		return -ENOMEM;
 
-	DEBUG_PRINT("ai dma descriptors start at bus addr 0x%x\n",
-		    devpriv->ai_dma_desc_bus_addr);
+	DEBUG_PRINT("ai dma descriptors start at bus addr 0x%llx\n",
+		    (unsigned long long)devpriv->ai_dma_desc_bus_addr);
 	if (ao_cmd_is_supported(board(dev))) {
 		devpriv->ao_dma_desc =
 		    pci_alloc_consistent(pcidev,
@@ -1591,8 +1593,8 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 		if (devpriv->ao_dma_desc == NULL)
 			return -ENOMEM;
 
-		DEBUG_PRINT("ao dma descriptors start at bus addr 0x%x\n",
-			    devpriv->ao_dma_desc_bus_addr);
+		DEBUG_PRINT("ao dma descriptors start at bus addr 0x%llx\n",
+			    (unsigned long long)devpriv->ao_dma_desc_bus_addr);
 	}
 	/*  initialize dma descriptors */
 	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
@@ -1944,7 +1946,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		DEBUG_PRINT(" looped %i times waiting for data\n", i);
 		if (i == timeout) {
 			comedi_error(dev, " analog input read insn timed out");
-			printk(" status 0x%x\n", bits);
+			dev_info(dev->class_dev, "status 0x%x\n", bits);
 			return -ETIME;
 		}
 		if (board(dev)->layout == LAYOUT_4020)
@@ -3100,15 +3102,13 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	plx_status = readl(devpriv->plx9080_iobase + PLX_INTRCS_REG);
 	status = readw(devpriv->main_iobase + HW_STATUS_REG);
 
-	DEBUG_PRINT("cb_pcidas64: hw status 0x%x ", status);
-	DEBUG_PRINT("plx status 0x%x\n", plx_status);
+	DEBUG_PRINT("hw status 0x%x, plx status 0x%x\n", status, plx_status);
 
 	/* an interrupt before all the postconfig stuff gets done could
 	 * cause a NULL dereference if we continue through the
 	 * interrupt handler */
 	if (dev->attached == 0) {
-		DEBUG_PRINT("cb_pcidas64: premature interrupt, ignoring",
-			    status);
+		DEBUG_PRINT("premature interrupt, ignoring\n");
 		return IRQ_HANDLED;
 	}
 	handle_ai_interrupt(dev, status, plx_status);
@@ -3290,8 +3290,9 @@ static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 	buffer_index = devpriv->ao_dma_index;
 	prev_buffer_index = prev_ao_dma_index(dev);
 
-	DEBUG_PRINT("attempting to load ao buffer %i (0x%x)\n", buffer_index,
-		    devpriv->ao_buffer_bus_addr[buffer_index]);
+	DEBUG_PRINT("attempting to load ao buffer %i (0x%llx)\n", buffer_index,
+		    (unsigned long long)devpriv->ao_buffer_bus_addr[
+								buffer_index]);
 
 	num_bytes = comedi_buf_read_n_available(dev->write_subdev->async);
 	if (num_bytes > DMA_BUFFER_SIZE)

commit b91524ee48771586b99bfbed9d4607c3e407d7cb
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 2 19:17:57 2012 +0000

    staging: comedi: cb_pcidas64: use auto_attach method
    
    This driver does not need to support manual attachment of supported PCI
    devices.  Replace the `attach()` hook with an `auto_attach()` hook.
    This will be called via `comedi_pci_auto_config()` at PCI probe time.
    
    The `auto_attach()` calls new function `cb_pcidas64_find_pci_board()` to
    find the correct entry in `pcidas64_boards[]` for the PCI device.
    
    This driver no longer increments the PCI reference count during
    attachment, so remove the call to `pci_dev_put()` when detaching the
    device.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 0ae7ef5856c6..69db96ff3d55 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1645,57 +1645,38 @@ static inline void warn_external_queue(struct comedi_device *dev)
 		     "Use internal AI channel queue (channels must be consecutive and use same range/aref)");
 }
 
-static struct pci_dev *cb_pcidas64_find_pci_dev(struct comedi_device *dev,
-						struct comedi_devconfig *it)
+static const struct pcidas64_board
+*cb_pcidas64_find_pci_board(struct pci_dev *pcidev)
 {
-	struct pci_dev *pcidev = NULL;
-	int bus = it->options[0];
-	int slot = it->options[1];
-	int i;
+	unsigned int i;
 
-	for_each_pci_dev(pcidev) {
-		if (bus || slot) {
-			if (bus != pcidev->bus->number ||
-			    slot != PCI_SLOT(pcidev->devfn))
-				continue;
-		}
-		if (pcidev->vendor != PCI_VENDOR_ID_CB)
-			continue;
-
-		for (i = 0; i < ARRAY_SIZE(pcidas64_boards); i++) {
-			if (pcidas64_boards[i].device_id != pcidev->device)
-				continue;
-			dev->board_ptr = pcidas64_boards + i;
-			return pcidev;
-		}
-	}
-	dev_err(dev->class_dev,
-		"No supported board found! (req. bus %d, slot %d)\n",
-		bus, slot);
+	for (i = 0; i < ARRAY_SIZE(pcidas64_boards); i++)
+		if (pcidev->device == pcidas64_boards[i].device_id)
+			return &pcidas64_boards[i];
 	return NULL;
 }
 
-/*
- * Attach is called by the Comedi core to configure the driver
- * for a particular board.
- */
-static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int __devinit auto_attach(struct comedi_device *dev,
+				 unsigned long context_unused)
 {
 	struct pcidas64_private *devpriv;
-	struct pci_dev *pcidev;
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	uint32_t local_range, local_decode;
 	int retval;
 
+	dev->board_ptr = cb_pcidas64_find_pci_board(pcidev);
+	if (!dev->board_ptr) {
+		dev_err(dev->class_dev,
+			"cb_pcidas64: does not support pci %s\n",
+			pci_name(pcidev));
+		return -EINVAL;
+	}
+
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	pcidev = cb_pcidas64_find_pci_dev(dev, it);
-	if (!pcidev)
-		return -EIO;
-	comedi_set_hw_dev(dev, &pcidev->dev);
-
 	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
 		dev_warn(dev->class_dev,
 			 "failed to enable PCI device and request regions\n");
@@ -1838,8 +1819,6 @@ static void detach(struct comedi_device *dev)
 	if (pcidev) {
 		if (dev->iobase)
 			comedi_pci_disable(pcidev);
-
-		pci_dev_put(pcidev);
 	}
 }
 
@@ -4240,7 +4219,7 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 static struct comedi_driver cb_pcidas64_driver = {
 	.driver_name	= "cb_pcidas64",
 	.module		= THIS_MODULE,
-	.attach		= attach,
+	.auto_attach	= auto_attach,
 	.detach		= detach,
 };
 

commit cb3e9d86945181a2d9154543f402dccf35d8dd58
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Oct 24 16:29:32 2012 -0700

    staging: comedi: comedidev.h: add PCI_VENDOR_ID_CB
    
    Add a define for the ComputerBoards/Measurement Computing PCI
    vendor id. Remove the duplicates in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index a6f5e5e92c8e..0ae7ef5856c6 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -105,8 +105,6 @@ known. If you have such a board, please file a bug report at
 #define PRESCALED_TIMER_BASE	10000	/*  100kHz 'prescaled' clock for slow acquisition, maybe I'll support this someday */
 #define DMA_BUFFER_SIZE 0x1000
 
-#define PCI_VENDOR_ID_COMPUTERBOARDS	0x1307
-
 /* maximum value that can be loaded into board's 24-bit counters*/
 static const int max_counter_value = 0xffffff;
 
@@ -1661,7 +1659,7 @@ static struct pci_dev *cb_pcidas64_find_pci_dev(struct comedi_device *dev,
 			    slot != PCI_SLOT(pcidev->devfn))
 				continue;
 		}
-		if (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
+		if (pcidev->vendor != PCI_VENDOR_ID_CB)
 			continue;
 
 		for (i = 0; i < ARRAY_SIZE(pcidas64_boards); i++) {
@@ -4258,25 +4256,25 @@ static void __devexit cb_pcidas64_pci_remove(struct pci_dev *dev)
 }
 
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas64_pci_table) = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x001d) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x001e) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0035) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0036) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0037) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0052) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x005d) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x005e) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x005f) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0061) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0062) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0063) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0064) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0066) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0067) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0068) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x006f) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0078) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0079) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001d) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001e) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0035) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0036) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0037) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0052) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x005d) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x005e) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x005f) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0061) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0062) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0063) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0064) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0066) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0067) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0068) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x006f) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0078) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0079) },
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, cb_pcidas64_pci_table);

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 08546a1091a2..a6f5e5e92c8e 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1688,10 +1688,10 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	uint32_t local_range, local_decode;
 	int retval;
 
-	retval = alloc_private(dev, sizeof(*devpriv));
-	if (retval)
-		return retval;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	pcidev = cb_pcidas64_find_pci_dev(dev, it);
 	if (!pcidev)

commit 681d335ab5819a5cca8b74bea06f2804d2cb5a81
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:13:12 2012 -0700

    staging: comedi: cb_pcidas64: remove inline priv() function
    
    The inline priv() function simply returns the dev->private pointer
    to the private data.
    
    Remove the inline funciton and just use a local variable where the
    private data is used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 0472a9088abe..08546a1091a2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -119,7 +119,7 @@ enum base_address_regions {
 	DIO_COUNTER_BADDRINDEX = 3,
 };
 
-/* priv(dev)->main_iobase registers */
+/* devpriv->main_iobase registers */
 enum write_only_registers {
 	INTR_ENABLE_REG = 0x0,	/*  interrupt enable register */
 	HW_CONFIG_REG = 0x2,	/*  hardware config register */
@@ -179,7 +179,7 @@ enum read_write_registers {
 	DAC_FIFO_REG = 0x300,	/* dac data fifo, has weird interactions with external channel queue */
 };
 
-/* priv(dev)->dio_counter_iobase registers */
+/* devpriv->dio_counter_iobase registers */
 enum dio_counter_registers {
 	DIO_8255_OFFSET = 0x0,
 	DO_REG = 0x20,
@@ -1091,14 +1091,6 @@ struct pcidas64_private {
 	short ao_bounce_buffer[DAC_FIFO_SIZE];
 };
 
-/* inline function that makes it easier to
- * access the private structure.
- */
-static inline struct pcidas64_private *priv(struct comedi_device *dev)
-{
-	return dev->private;
-}
-
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data);
 static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -1249,17 +1241,18 @@ static inline int ao_cmd_is_supported(const struct pcidas64_board *board)
 /* initialize plx9080 chip */
 static void init_plx9080(struct comedi_device *dev)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	uint32_t bits;
-	void __iomem *plx_iobase = priv(dev)->plx9080_iobase;
+	void __iomem *plx_iobase = devpriv->plx9080_iobase;
 
-	priv(dev)->plx_control_bits =
-	    readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG);
+	devpriv->plx_control_bits =
+	    readl(devpriv->plx9080_iobase + PLX_CONTROL_REG);
 
 	/*  plx9080 dump */
 	DEBUG_PRINT(" plx interrupt status 0x%x\n",
 		    readl(plx_iobase + PLX_INTRCS_REG));
 	DEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));
-	DEBUG_PRINT(" plx control reg 0x%x\n", priv(dev)->plx_control_bits);
+	DEBUG_PRINT(" plx control reg 0x%x\n", devpriv->plx_control_bits);
 	DEBUG_PRINT(" plx mode/arbitration reg 0x%x\n",
 		    readl(plx_iobase + PLX_MARB_REG));
 	DEBUG_PRINT(" plx region0 reg 0x%x\n",
@@ -1292,7 +1285,7 @@ static void init_plx9080(struct comedi_device *dev)
 #else
 	bits = 0;
 #endif
-	writel(bits, priv(dev)->plx9080_iobase + PLX_BIGEND_REG);
+	writel(bits, devpriv->plx9080_iobase + PLX_BIGEND_REG);
 
 	disable_plx_interrupts(dev);
 
@@ -1328,17 +1321,18 @@ static void init_plx9080(struct comedi_device *dev)
 		writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
 
 	/*  enable interrupts on plx 9080 */
-	priv(dev)->plx_intcsr_bits |=
+	devpriv->plx_intcsr_bits |=
 	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
 	    ICS_DMA0_E | ICS_DMA1_E;
-	writel(priv(dev)->plx_intcsr_bits,
-	       priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+	writel(devpriv->plx_intcsr_bits,
+	       devpriv->plx9080_iobase + PLX_INTRCS_REG);
 }
 
 /* Allocate and initialize the subdevice structures.
  */
 static int setup_subdevices(struct comedi_device *dev)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	void __iomem *dio_8255_iobase;
 	int i;
@@ -1370,11 +1364,11 @@ static int setup_subdevices(struct comedi_device *dev)
 	if (board(dev)->layout == LAYOUT_4020) {
 		uint8_t data;
 		/*  set adc to read from inputs (not internal calibration sources) */
-		priv(dev)->i2c_cal_range_bits = adc_src_4020_bits(4);
+		devpriv->i2c_cal_range_bits = adc_src_4020_bits(4);
 		/*  set channels to +-5 volt input ranges */
 		for (i = 0; i < s->n_chan; i++)
-			priv(dev)->i2c_cal_range_bits |= attenuate_bit(i);
-		data = priv(dev)->i2c_cal_range_bits;
+			devpriv->i2c_cal_range_bits |= attenuate_bit(i);
+		data = devpriv->i2c_cal_range_bits;
 		i2c_write(dev, RANGE_CAL_I2C_ADDR, &data, sizeof(data));
 	}
 
@@ -1429,12 +1423,12 @@ static int setup_subdevices(struct comedi_device *dev)
 	if (board(dev)->has_8255) {
 		if (board(dev)->layout == LAYOUT_4020) {
 			dio_8255_iobase =
-			    priv(dev)->main_iobase + I8255_4020_REG;
+			    devpriv->main_iobase + I8255_4020_REG;
 			subdev_8255_init(dev, s, dio_callback_4020,
 					 (unsigned long)dio_8255_iobase);
 		} else {
 			dio_8255_iobase =
-			    priv(dev)->dio_counter_iobase + DIO_8255_OFFSET;
+			    devpriv->dio_counter_iobase + DIO_8255_OFFSET;
 			subdev_8255_init(dev, s, dio_callback,
 					 (unsigned long)dio_8255_iobase);
 		}
@@ -1484,7 +1478,7 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/* serial EEPROM, if present */
 	s = &dev->subdevices[8];
-	if (readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG) & CTL_EECHK) {
+	if (readl(devpriv->plx9080_iobase + PLX_CONTROL_REG) & CTL_EECHK) {
 		s->type = COMEDI_SUBD_MEMORY;
 		s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
 		s->n_chan = 128;
@@ -1502,13 +1496,16 @@ static int setup_subdevices(struct comedi_device *dev)
 
 static void disable_plx_interrupts(struct comedi_device *dev)
 {
-	priv(dev)->plx_intcsr_bits = 0;
-	writel(priv(dev)->plx_intcsr_bits,
-	       priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+	struct pcidas64_private *devpriv = dev->private;
+
+	devpriv->plx_intcsr_bits = 0;
+	writel(devpriv->plx_intcsr_bits,
+	       devpriv->plx9080_iobase + PLX_INTRCS_REG);
 }
 
 static void init_stc_registers(struct comedi_device *dev)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	uint16_t bits;
 	unsigned long flags;
 
@@ -1516,35 +1513,35 @@ static void init_stc_registers(struct comedi_device *dev)
 
 	/*  bit should be set for 6025, although docs say boards with <= 16 chans should be cleared XXX */
 	if (1)
-		priv(dev)->adc_control1_bits |= ADC_QUEUE_CONFIG_BIT;
-	writew(priv(dev)->adc_control1_bits,
-	       priv(dev)->main_iobase + ADC_CONTROL1_REG);
+		devpriv->adc_control1_bits |= ADC_QUEUE_CONFIG_BIT;
+	writew(devpriv->adc_control1_bits,
+	       devpriv->main_iobase + ADC_CONTROL1_REG);
 
 	/*  6402/16 manual says this register must be initialized to 0xff? */
-	writew(0xff, priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
+	writew(0xff, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
 
 	bits = SLOW_DAC_BIT | DMA_CH_SELECT_BIT;
 	if (board(dev)->layout == LAYOUT_4020)
 		bits |= INTERNAL_CLOCK_4020_BITS;
-	priv(dev)->hw_config_bits |= bits;
-	writew(priv(dev)->hw_config_bits,
-	       priv(dev)->main_iobase + HW_CONFIG_REG);
+	devpriv->hw_config_bits |= bits;
+	writew(devpriv->hw_config_bits,
+	       devpriv->main_iobase + HW_CONFIG_REG);
 
-	writew(0, priv(dev)->main_iobase + DAQ_SYNC_REG);
-	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
+	writew(0, devpriv->main_iobase + DAQ_SYNC_REG);
+	writew(0, devpriv->main_iobase + CALIBRATION_REG);
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  set fifos to maximum size */
-	priv(dev)->fifo_size_bits |= DAC_FIFO_BITS;
+	devpriv->fifo_size_bits |= DAC_FIFO_BITS;
 	set_ai_fifo_segment_length(dev,
 				   board(dev)->ai_fifo->max_segment_length);
 
-	priv(dev)->dac_control1_bits = DAC_OUTPUT_ENABLE_BIT;
-	priv(dev)->intr_enable_bits =	/* EN_DAC_INTR_SRC_BIT | DAC_INTR_QEMPTY_BITS | */
+	devpriv->dac_control1_bits = DAC_OUTPUT_ENABLE_BIT;
+	devpriv->intr_enable_bits =	/* EN_DAC_INTR_SRC_BIT | DAC_INTR_QEMPTY_BITS | */
 	    EN_DAC_DONE_INTR_BIT | EN_DAC_UNDERRUN_BIT;
-	writew(priv(dev)->intr_enable_bits,
-	       priv(dev)->main_iobase + INTR_ENABLE_REG);
+	writew(devpriv->intr_enable_bits,
+	       devpriv->main_iobase + INTR_ENABLE_REG);
 
 	disable_ai_pacing(dev);
 };
@@ -1552,88 +1549,89 @@ static void init_stc_registers(struct comedi_device *dev)
 static int alloc_and_init_dma_members(struct comedi_device *dev)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct pcidas64_private *devpriv = dev->private;
 	int i;
 
 	/*  alocate pci dma buffers */
 	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
-		priv(dev)->ai_buffer[i] =
+		devpriv->ai_buffer[i] =
 		    pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
-					 &priv(dev)->ai_buffer_bus_addr[i]);
-		if (priv(dev)->ai_buffer[i] == NULL)
+					 &devpriv->ai_buffer_bus_addr[i]);
+		if (devpriv->ai_buffer[i] == NULL)
 			return -ENOMEM;
 
 	}
 	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 		if (ao_cmd_is_supported(board(dev))) {
-			priv(dev)->ao_buffer[i] =
+			devpriv->ao_buffer[i] =
 			    pci_alloc_consistent(pcidev,
 						 DMA_BUFFER_SIZE,
-						 &priv(dev)->
+						 &devpriv->
 						 ao_buffer_bus_addr[i]);
-			if (priv(dev)->ao_buffer[i] == NULL)
+			if (devpriv->ao_buffer[i] == NULL)
 				return -ENOMEM;
 
 		}
 	}
 	/*  allocate dma descriptors */
-	priv(dev)->ai_dma_desc =
+	devpriv->ai_dma_desc =
 	    pci_alloc_consistent(pcidev,
 				 sizeof(struct plx_dma_desc) *
 				 ai_dma_ring_count(board(dev)),
-				 &priv(dev)->ai_dma_desc_bus_addr);
-	if (priv(dev)->ai_dma_desc == NULL)
+				 &devpriv->ai_dma_desc_bus_addr);
+	if (devpriv->ai_dma_desc == NULL)
 		return -ENOMEM;
 
 	DEBUG_PRINT("ai dma descriptors start at bus addr 0x%x\n",
-		    priv(dev)->ai_dma_desc_bus_addr);
+		    devpriv->ai_dma_desc_bus_addr);
 	if (ao_cmd_is_supported(board(dev))) {
-		priv(dev)->ao_dma_desc =
+		devpriv->ao_dma_desc =
 		    pci_alloc_consistent(pcidev,
 					 sizeof(struct plx_dma_desc) *
 					 AO_DMA_RING_COUNT,
-					 &priv(dev)->ao_dma_desc_bus_addr);
-		if (priv(dev)->ao_dma_desc == NULL)
+					 &devpriv->ao_dma_desc_bus_addr);
+		if (devpriv->ao_dma_desc == NULL)
 			return -ENOMEM;
 
 		DEBUG_PRINT("ao dma descriptors start at bus addr 0x%x\n",
-			    priv(dev)->ao_dma_desc_bus_addr);
+			    devpriv->ao_dma_desc_bus_addr);
 	}
 	/*  initialize dma descriptors */
 	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
-		priv(dev)->ai_dma_desc[i].pci_start_addr =
-		    cpu_to_le32(priv(dev)->ai_buffer_bus_addr[i]);
+		devpriv->ai_dma_desc[i].pci_start_addr =
+		    cpu_to_le32(devpriv->ai_buffer_bus_addr[i]);
 		if (board(dev)->layout == LAYOUT_4020)
-			priv(dev)->ai_dma_desc[i].local_start_addr =
-			    cpu_to_le32(priv(dev)->local1_iobase +
+			devpriv->ai_dma_desc[i].local_start_addr =
+			    cpu_to_le32(devpriv->local1_iobase +
 					ADC_FIFO_REG);
 		else
-			priv(dev)->ai_dma_desc[i].local_start_addr =
-			    cpu_to_le32(priv(dev)->local0_iobase +
+			devpriv->ai_dma_desc[i].local_start_addr =
+			    cpu_to_le32(devpriv->local0_iobase +
 					ADC_FIFO_REG);
-		priv(dev)->ai_dma_desc[i].transfer_size = cpu_to_le32(0);
-		priv(dev)->ai_dma_desc[i].next =
-		    cpu_to_le32((priv(dev)->ai_dma_desc_bus_addr + ((i +
+		devpriv->ai_dma_desc[i].transfer_size = cpu_to_le32(0);
+		devpriv->ai_dma_desc[i].next =
+		    cpu_to_le32((devpriv->ai_dma_desc_bus_addr + ((i +
 								     1) %
 								    ai_dma_ring_count
 								    (board
 								     (dev))) *
-				 sizeof(priv(dev)->ai_dma_desc[0])) |
+				 sizeof(devpriv->ai_dma_desc[0])) |
 				PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
 				PLX_XFER_LOCAL_TO_PCI);
 	}
 	if (ao_cmd_is_supported(board(dev))) {
 		for (i = 0; i < AO_DMA_RING_COUNT; i++) {
-			priv(dev)->ao_dma_desc[i].pci_start_addr =
-			    cpu_to_le32(priv(dev)->ao_buffer_bus_addr[i]);
-			priv(dev)->ao_dma_desc[i].local_start_addr =
-			    cpu_to_le32(priv(dev)->local0_iobase +
+			devpriv->ao_dma_desc[i].pci_start_addr =
+			    cpu_to_le32(devpriv->ao_buffer_bus_addr[i]);
+			devpriv->ao_dma_desc[i].local_start_addr =
+			    cpu_to_le32(devpriv->local0_iobase +
 					DAC_FIFO_REG);
-			priv(dev)->ao_dma_desc[i].transfer_size =
+			devpriv->ao_dma_desc[i].transfer_size =
 			    cpu_to_le32(0);
-			priv(dev)->ao_dma_desc[i].next =
-			    cpu_to_le32((priv(dev)->ao_dma_desc_bus_addr +
+			devpriv->ao_dma_desc[i].next =
+			    cpu_to_le32((devpriv->ao_dma_desc_bus_addr +
 					 ((i + 1) % (AO_DMA_RING_COUNT)) *
-					 sizeof(priv(dev)->ao_dma_desc[0])) |
+					 sizeof(devpriv->ao_dma_desc[0])) |
 					PLX_DESC_IN_PCI_BIT |
 					PLX_INTR_TERM_COUNT);
 		}
@@ -1685,15 +1683,15 @@ static struct pci_dev *cb_pcidas64_find_pci_dev(struct comedi_device *dev,
  */
 static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	struct pcidas64_private *devpriv;
 	struct pci_dev *pcidev;
 	uint32_t local_range, local_decode;
 	int retval;
 
-/*
- * Allocate the private structure area.
- */
-	if (alloc_private(dev, sizeof(struct pcidas64_private)) < 0)
-		return -ENOMEM;
+	retval = alloc_private(dev, sizeof(*devpriv));
+	if (retval)
+		return retval;
+	devpriv = dev->private;
 
 	pcidev = cb_pcidas64_find_pci_dev(dev, it);
 	if (!pcidev)
@@ -1712,63 +1710,63 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	dev->iobase = pci_resource_start(pcidev, MAIN_BADDRINDEX);
 
-	priv(dev)->plx9080_phys_iobase =
+	devpriv->plx9080_phys_iobase =
 	    pci_resource_start(pcidev, PLX9080_BADDRINDEX);
-	priv(dev)->main_phys_iobase = dev->iobase;
-	priv(dev)->dio_counter_phys_iobase =
+	devpriv->main_phys_iobase = dev->iobase;
+	devpriv->dio_counter_phys_iobase =
 	    pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
 
 	/*  remap, won't work with 2.0 kernels but who cares */
-	priv(dev)->plx9080_iobase = ioremap(priv(dev)->plx9080_phys_iobase,
+	devpriv->plx9080_iobase = ioremap(devpriv->plx9080_phys_iobase,
 					    pci_resource_len(pcidev,
 							     PLX9080_BADDRINDEX));
-	priv(dev)->main_iobase =
-	    ioremap(priv(dev)->main_phys_iobase,
+	devpriv->main_iobase =
+	    ioremap(devpriv->main_phys_iobase,
 		    pci_resource_len(pcidev, MAIN_BADDRINDEX));
-	priv(dev)->dio_counter_iobase =
-	    ioremap(priv(dev)->dio_counter_phys_iobase,
+	devpriv->dio_counter_iobase =
+	    ioremap(devpriv->dio_counter_phys_iobase,
 		    pci_resource_len(pcidev, DIO_COUNTER_BADDRINDEX));
 
-	if (!priv(dev)->plx9080_iobase || !priv(dev)->main_iobase
-	    || !priv(dev)->dio_counter_iobase) {
+	if (!devpriv->plx9080_iobase || !devpriv->main_iobase
+	    || !devpriv->dio_counter_iobase) {
 		dev_warn(dev->class_dev, "failed to remap io memory\n");
 		return -ENOMEM;
 	}
 
-	DEBUG_PRINT(" plx9080 remapped to 0x%p\n", priv(dev)->plx9080_iobase);
-	DEBUG_PRINT(" main remapped to 0x%p\n", priv(dev)->main_iobase);
+	DEBUG_PRINT(" plx9080 remapped to 0x%p\n", devpriv->plx9080_iobase);
+	DEBUG_PRINT(" main remapped to 0x%p\n", devpriv->main_iobase);
 	DEBUG_PRINT(" diocounter remapped to 0x%p\n",
-		    priv(dev)->dio_counter_iobase);
+		    devpriv->dio_counter_iobase);
 
 	/*  figure out what local addresses are */
 	local_range =
-	    readl(priv(dev)->plx9080_iobase + PLX_LAS0RNG_REG) & LRNG_MEM_MASK;
+	    readl(devpriv->plx9080_iobase + PLX_LAS0RNG_REG) & LRNG_MEM_MASK;
 	local_decode =
-	    readl(priv(dev)->plx9080_iobase +
+	    readl(devpriv->plx9080_iobase +
 		  PLX_LAS0MAP_REG) & local_range & LMAP_MEM_MASK;
-	priv(dev)->local0_iobase =
-	    ((uint32_t) priv(dev)->main_phys_iobase & ~local_range) |
+	devpriv->local0_iobase =
+	    ((uint32_t) devpriv->main_phys_iobase & ~local_range) |
 	    local_decode;
 	local_range =
-	    readl(priv(dev)->plx9080_iobase + PLX_LAS1RNG_REG) & LRNG_MEM_MASK;
+	    readl(devpriv->plx9080_iobase + PLX_LAS1RNG_REG) & LRNG_MEM_MASK;
 	local_decode =
-	    readl(priv(dev)->plx9080_iobase +
+	    readl(devpriv->plx9080_iobase +
 		  PLX_LAS1MAP_REG) & local_range & LMAP_MEM_MASK;
-	priv(dev)->local1_iobase =
-	    ((uint32_t) priv(dev)->dio_counter_phys_iobase & ~local_range) |
+	devpriv->local1_iobase =
+	    ((uint32_t) devpriv->dio_counter_phys_iobase & ~local_range) |
 	    local_decode;
 
-	DEBUG_PRINT(" local 0 io addr 0x%x\n", priv(dev)->local0_iobase);
-	DEBUG_PRINT(" local 1 io addr 0x%x\n", priv(dev)->local1_iobase);
+	DEBUG_PRINT(" local 0 io addr 0x%x\n", devpriv->local0_iobase);
+	DEBUG_PRINT(" local 1 io addr 0x%x\n", devpriv->local1_iobase);
 
 	retval = alloc_and_init_dma_members(dev);
 	if (retval < 0)
 		return retval;
 
-	priv(dev)->hw_revision =
-	    hw_revision(dev, readw(priv(dev)->main_iobase + HW_STATUS_REG));
+	devpriv->hw_revision =
+	    hw_revision(dev, readw(devpriv->main_iobase + HW_STATUS_REG));
 	dev_dbg(dev->class_dev, "stc hardware revision %i\n",
-		priv(dev)->hw_revision);
+		devpriv->hw_revision);
 	init_plx9080(dev);
 	init_stc_registers(dev);
 	/*  get irq */
@@ -1792,58 +1790,49 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 static void detach(struct comedi_device *dev)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int i;
 
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (priv(dev)) {
+	if (devpriv) {
 		if (pcidev) {
-			if (priv(dev)->plx9080_iobase) {
+			if (devpriv->plx9080_iobase) {
 				disable_plx_interrupts(dev);
-				iounmap(priv(dev)->plx9080_iobase);
+				iounmap(devpriv->plx9080_iobase);
 			}
-			if (priv(dev)->main_iobase)
-				iounmap(priv(dev)->main_iobase);
-			if (priv(dev)->dio_counter_iobase)
-				iounmap(priv(dev)->dio_counter_iobase);
+			if (devpriv->main_iobase)
+				iounmap(devpriv->main_iobase);
+			if (devpriv->dio_counter_iobase)
+				iounmap(devpriv->dio_counter_iobase);
 			/*  free pci dma buffers */
 			for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
-				if (priv(dev)->ai_buffer[i])
+				if (devpriv->ai_buffer[i])
 					pci_free_consistent(pcidev,
-							    DMA_BUFFER_SIZE,
-							    priv(dev)->
-							    ai_buffer[i],
-							    priv
-							    (dev)->ai_buffer_bus_addr
-							    [i]);
+						DMA_BUFFER_SIZE,
+						devpriv->ai_buffer[i],
+						devpriv->ai_buffer_bus_addr[i]);
 			}
 			for (i = 0; i < AO_DMA_RING_COUNT; i++) {
-				if (priv(dev)->ao_buffer[i])
+				if (devpriv->ao_buffer[i])
 					pci_free_consistent(pcidev,
-							    DMA_BUFFER_SIZE,
-							    priv(dev)->
-							    ao_buffer[i],
-							    priv
-							    (dev)->ao_buffer_bus_addr
-							    [i]);
+						DMA_BUFFER_SIZE,
+						devpriv->ao_buffer[i],
+						devpriv->ao_buffer_bus_addr[i]);
 			}
 			/*  free dma descriptors */
-			if (priv(dev)->ai_dma_desc)
+			if (devpriv->ai_dma_desc)
 				pci_free_consistent(pcidev,
-						    sizeof(struct plx_dma_desc)
-						    *
-						    ai_dma_ring_count(board
-								      (dev)),
-						    priv(dev)->ai_dma_desc,
-						    priv(dev)->
-						    ai_dma_desc_bus_addr);
-			if (priv(dev)->ao_dma_desc)
+					sizeof(struct plx_dma_desc) *
+					ai_dma_ring_count(board(dev)),
+					devpriv->ai_dma_desc,
+					devpriv->ai_dma_desc_bus_addr);
+			if (devpriv->ao_dma_desc)
 				pci_free_consistent(pcidev,
-						    sizeof(struct plx_dma_desc)
-						    * AO_DMA_RING_COUNT,
-						    priv(dev)->ao_dma_desc,
-						    priv(dev)->
-						    ao_dma_desc_bus_addr);
+					sizeof(struct plx_dma_desc) *
+					AO_DMA_RING_COUNT,
+					devpriv->ao_dma_desc,
+					devpriv->ao_dma_desc_bus_addr);
 		}
 	}
 	if (dev->subdevices)
@@ -1859,6 +1848,7 @@ static void detach(struct comedi_device *dev)
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int bits = 0, n, i;
 	unsigned int channel, range, aref;
 	unsigned long flags;
@@ -1875,18 +1865,18 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	spin_lock_irqsave(&dev->spinlock, flags);
 	if (insn->chanspec & CR_ALT_FILTER)
-		priv(dev)->adc_control1_bits |= ADC_DITHER_BIT;
+		devpriv->adc_control1_bits |= ADC_DITHER_BIT;
 	else
-		priv(dev)->adc_control1_bits &= ~ADC_DITHER_BIT;
-	writew(priv(dev)->adc_control1_bits,
-	       priv(dev)->main_iobase + ADC_CONTROL1_REG);
+		devpriv->adc_control1_bits &= ~ADC_DITHER_BIT;
+	writew(devpriv->adc_control1_bits,
+	       devpriv->main_iobase + ADC_CONTROL1_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (board(dev)->layout != LAYOUT_4020) {
 		/*  use internal queue */
-		priv(dev)->hw_config_bits &= ~EXT_QUEUE_BIT;
-		writew(priv(dev)->hw_config_bits,
-		       priv(dev)->main_iobase + HW_CONFIG_REG);
+		devpriv->hw_config_bits &= ~EXT_QUEUE_BIT;
+		writew(devpriv->hw_config_bits,
+		       devpriv->main_iobase + HW_CONFIG_REG);
 
 		/*  ALT_SOURCE is internal calibration reference */
 		if (insn->chanspec & CR_ALT_SOURCE) {
@@ -1899,11 +1889,11 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 				cal_en_bit = CAL_EN_64XX_BIT;
 			/*  select internal reference source to connect to channel 0 */
 			writew(cal_en_bit |
-			       adc_src_bits(priv(dev)->calibration_source),
-			       priv(dev)->main_iobase + CALIBRATION_REG);
+			       adc_src_bits(devpriv->calibration_source),
+			       devpriv->main_iobase + CALIBRATION_REG);
 		} else {
 			/*  make sure internal calibration source is turned off */
-			writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
+			writew(0, devpriv->main_iobase + CALIBRATION_REG);
 		}
 		/*  load internal queue */
 		bits = 0;
@@ -1916,29 +1906,29 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		bits |= adc_chan_bits(channel);
 		/*  set stop channel */
 		writew(adc_chan_bits(channel),
-		       priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
+		       devpriv->main_iobase + ADC_QUEUE_HIGH_REG);
 		/*  set start channel, and rest of settings */
-		writew(bits, priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
+		writew(bits, devpriv->main_iobase + ADC_QUEUE_LOAD_REG);
 	} else {
-		uint8_t old_cal_range_bits = priv(dev)->i2c_cal_range_bits;
+		uint8_t old_cal_range_bits = devpriv->i2c_cal_range_bits;
 
-		priv(dev)->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;
+		devpriv->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;
 		if (insn->chanspec & CR_ALT_SOURCE) {
 			DEBUG_PRINT("reading calibration source\n");
-			priv(dev)->i2c_cal_range_bits |=
-			    adc_src_4020_bits(priv(dev)->calibration_source);
+			devpriv->i2c_cal_range_bits |=
+			    adc_src_4020_bits(devpriv->calibration_source);
 		} else {	/* select BNC inputs */
-			priv(dev)->i2c_cal_range_bits |= adc_src_4020_bits(4);
+			devpriv->i2c_cal_range_bits |= adc_src_4020_bits(4);
 		}
 		/*  select range */
 		if (range == 0)
-			priv(dev)->i2c_cal_range_bits |= attenuate_bit(channel);
+			devpriv->i2c_cal_range_bits |= attenuate_bit(channel);
 		else
-			priv(dev)->i2c_cal_range_bits &=
+			devpriv->i2c_cal_range_bits &=
 			    ~attenuate_bit(channel);
 		/*  update calibration/range i2c register only if necessary, as it is very slow */
-		if (old_cal_range_bits != priv(dev)->i2c_cal_range_bits) {
-			uint8_t i2c_data = priv(dev)->i2c_cal_range_bits;
+		if (old_cal_range_bits != devpriv->i2c_cal_range_bits) {
+			uint8_t i2c_data = devpriv->i2c_cal_range_bits;
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
 				  sizeof(i2c_data));
 		}
@@ -1946,26 +1936,26 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		/* 4020 manual asks that sample interval register to be set before writing to convert register.
 		 * Using somewhat arbitrary setting of 4 master clock ticks = 0.1 usec */
 		writew(0,
-		       priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
+		       devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
 		writew(2,
-		       priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
+		       devpriv->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
 	}
 
 	for (n = 0; n < insn->n; n++) {
 
 		/*  clear adc buffer (inside loop for 4020 sake) */
-		writew(0, priv(dev)->main_iobase + ADC_BUFFER_CLEAR_REG);
+		writew(0, devpriv->main_iobase + ADC_BUFFER_CLEAR_REG);
 
 		/* trigger conversion, bits sent only matter for 4020 */
 		writew(adc_convert_chan_4020_bits(CR_CHAN(insn->chanspec)),
-		       priv(dev)->main_iobase + ADC_CONVERT_REG);
+		       devpriv->main_iobase + ADC_CONVERT_REG);
 
 		/*  wait for data */
 		for (i = 0; i < timeout; i++) {
-			bits = readw(priv(dev)->main_iobase + HW_STATUS_REG);
+			bits = readw(devpriv->main_iobase + HW_STATUS_REG);
 			DEBUG_PRINT(" pipe bits 0x%x\n", pipe_full_bits(bits));
 			if (board(dev)->layout == LAYOUT_4020) {
-				if (readw(priv(dev)->main_iobase +
+				if (readw(devpriv->main_iobase +
 					  ADC_WRITE_PNTR_REG))
 					break;
 			} else {
@@ -1982,11 +1972,11 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		}
 		if (board(dev)->layout == LAYOUT_4020)
 			data[n] =
-			    readl(priv(dev)->dio_counter_iobase +
+			    readl(devpriv->dio_counter_iobase +
 				  ADC_FIFO_REG) & 0xffff;
 		else
 			data[n] =
-			    readw(priv(dev)->main_iobase + PIPE1_READ_REG);
+			    readw(devpriv->main_iobase + PIPE1_READ_REG);
 	}
 
 	return n;
@@ -1995,6 +1985,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 static int ai_config_calibration_source(struct comedi_device *dev,
 					unsigned int *data)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int source = data[1];
 	int num_calibration_sources;
 
@@ -2009,7 +2000,7 @@ static int ai_config_calibration_source(struct comedi_device *dev,
 	}
 
 	DEBUG_PRINT("setting calibration source to %i\n", source);
-	priv(dev)->calibration_source = source;
+	devpriv->calibration_source = source;
 
 	return 2;
 }
@@ -2043,6 +2034,7 @@ static int ai_config_block_size(struct comedi_device *dev, unsigned int *data)
 static int ai_config_master_clock_4020(struct comedi_device *dev,
 				       unsigned int *data)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int divisor = data[4];
 	int retval = 0;
 
@@ -2053,8 +2045,8 @@ static int ai_config_master_clock_4020(struct comedi_device *dev,
 
 	switch (data[1]) {
 	case COMEDI_EV_SCAN_BEGIN:
-		priv(dev)->ext_clock.divisor = divisor;
-		priv(dev)->ext_clock.chanspec = data[2];
+		devpriv->ext_clock.divisor = divisor;
+		devpriv->ext_clock.chanspec = data[2];
 		break;
 	default:
 		return -EINVAL;
@@ -2279,27 +2271,30 @@ static int use_hw_sample_counter(struct comedi_cmd *cmd)
 static void setup_sample_counters(struct comedi_device *dev,
 				  struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
+
 	if (cmd->stop_src == TRIG_COUNT) {
 		/*  set software count */
-		priv(dev)->ai_count = cmd->stop_arg * cmd->chanlist_len;
+		devpriv->ai_count = cmd->stop_arg * cmd->chanlist_len;
 	}
 	/*  load hardware conversion counter */
 	if (use_hw_sample_counter(cmd)) {
 		writew(cmd->stop_arg & 0xffff,
-		       priv(dev)->main_iobase + ADC_COUNT_LOWER_REG);
+		       devpriv->main_iobase + ADC_COUNT_LOWER_REG);
 		writew((cmd->stop_arg >> 16) & 0xff,
-		       priv(dev)->main_iobase + ADC_COUNT_UPPER_REG);
+		       devpriv->main_iobase + ADC_COUNT_UPPER_REG);
 	} else {
-		writew(1, priv(dev)->main_iobase + ADC_COUNT_LOWER_REG);
+		writew(1, devpriv->main_iobase + ADC_COUNT_LOWER_REG);
 	}
 }
 
 static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int num_samples;
 
 	num_samples =
-	    priv(dev)->ai_fifo_segment_length *
+	    devpriv->ai_fifo_segment_length *
 	    board(dev)->ai_fifo->sample_packing_ratio;
 	if (num_samples > DMA_BUFFER_SIZE / sizeof(uint16_t))
 		num_samples = DMA_BUFFER_SIZE / sizeof(uint16_t);
@@ -2309,40 +2304,43 @@ static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 
 static void disable_ai_pacing(struct comedi_device *dev)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned long flags;
 
 	disable_ai_interrupts(dev);
 
 	spin_lock_irqsave(&dev->spinlock, flags);
-	priv(dev)->adc_control1_bits &= ~ADC_SW_GATE_BIT;
-	writew(priv(dev)->adc_control1_bits,
-	       priv(dev)->main_iobase + ADC_CONTROL1_REG);
+	devpriv->adc_control1_bits &= ~ADC_SW_GATE_BIT;
+	writew(devpriv->adc_control1_bits,
+	       devpriv->main_iobase + ADC_CONTROL1_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* disable pacing, triggering, etc */
 	writew(ADC_DMA_DISABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT,
-	       priv(dev)->main_iobase + ADC_CONTROL0_REG);
+	       devpriv->main_iobase + ADC_CONTROL0_REG);
 }
 
 static void disable_ai_interrupts(struct comedi_device *dev)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->spinlock, flags);
-	priv(dev)->intr_enable_bits &=
+	devpriv->intr_enable_bits &=
 	    ~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &
 	    ~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &
 	    ~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;
-	writew(priv(dev)->intr_enable_bits,
-	       priv(dev)->main_iobase + INTR_ENABLE_REG);
+	writew(devpriv->intr_enable_bits,
+	       devpriv->main_iobase + INTR_ENABLE_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
+	DEBUG_PRINT("intr enable bits 0x%x\n", devpriv->intr_enable_bits);
 }
 
 static void enable_ai_interrupts(struct comedi_device *dev,
 				 const struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	uint32_t bits;
 	unsigned long flags;
 
@@ -2355,10 +2353,10 @@ static void enable_ai_interrupts(struct comedi_device *dev,
 			bits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;
 	}
 	spin_lock_irqsave(&dev->spinlock, flags);
-	priv(dev)->intr_enable_bits |= bits;
-	writew(priv(dev)->intr_enable_bits,
-	       priv(dev)->main_iobase + INTR_ENABLE_REG);
-	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
+	devpriv->intr_enable_bits |= bits;
+	writew(devpriv->intr_enable_bits,
+	       devpriv->main_iobase + INTR_ENABLE_REG);
+	DEBUG_PRINT("intr enable bits 0x%x\n", devpriv->intr_enable_bits);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
@@ -2393,6 +2391,7 @@ static uint32_t ai_scan_counter_6xxx(struct comedi_device *dev,
 static uint32_t ai_convert_counter_4020(struct comedi_device *dev,
 					struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int divisor;
 
 	switch (cmd->scan_begin_src) {
@@ -2400,7 +2399,7 @@ static uint32_t ai_convert_counter_4020(struct comedi_device *dev,
 		divisor = cmd->scan_begin_arg / TIMER_BASE;
 		break;
 	case TRIG_OTHER:
-		divisor = priv(dev)->ext_clock.divisor;
+		divisor = devpriv->ext_clock.divisor;
 		break;
 	default:		/*  should never happen */
 		comedi_error(dev, "bug! failed to set ai pacing!");
@@ -2415,20 +2414,22 @@ static uint32_t ai_convert_counter_4020(struct comedi_device *dev,
 static void select_master_clock_4020(struct comedi_device *dev,
 				     const struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
+
 	/*  select internal/external master clock */
-	priv(dev)->hw_config_bits &= ~MASTER_CLOCK_4020_MASK;
+	devpriv->hw_config_bits &= ~MASTER_CLOCK_4020_MASK;
 	if (cmd->scan_begin_src == TRIG_OTHER) {
-		int chanspec = priv(dev)->ext_clock.chanspec;
+		int chanspec = devpriv->ext_clock.chanspec;
 
 		if (CR_CHAN(chanspec))
-			priv(dev)->hw_config_bits |= BNC_CLOCK_4020_BITS;
+			devpriv->hw_config_bits |= BNC_CLOCK_4020_BITS;
 		else
-			priv(dev)->hw_config_bits |= EXT_CLOCK_4020_BITS;
+			devpriv->hw_config_bits |= EXT_CLOCK_4020_BITS;
 	} else {
-		priv(dev)->hw_config_bits |= INTERNAL_CLOCK_4020_BITS;
+		devpriv->hw_config_bits |= INTERNAL_CLOCK_4020_BITS;
 	}
-	writew(priv(dev)->hw_config_bits,
-	       priv(dev)->main_iobase + HW_CONFIG_REG);
+	writew(devpriv->hw_config_bits,
+	       devpriv->main_iobase + HW_CONFIG_REG);
 }
 
 static void select_master_clock(struct comedi_device *dev,
@@ -2446,6 +2447,7 @@ static void select_master_clock(struct comedi_device *dev,
 static inline void dma_start_sync(struct comedi_device *dev,
 				  unsigned int channel)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned long flags;
 
 	/*  spinlock for plx dma control/status reg */
@@ -2453,16 +2455,17 @@ static inline void dma_start_sync(struct comedi_device *dev,
 	if (channel)
 		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
 		       PLX_CLEAR_DMA_INTR_BIT,
-		       priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+		       devpriv->plx9080_iobase + PLX_DMA1_CS_REG);
 	else
 		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
 		       PLX_CLEAR_DMA_INTR_BIT,
-		       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+		       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	uint32_t convert_counter = 0, scan_counter = 0;
 
 	check_adc_timing(dev, cmd);
@@ -2478,17 +2481,17 @@ static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 
 	/*  load lower 16 bits of convert interval */
 	writew(convert_counter & 0xffff,
-	       priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
+	       devpriv->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
 	DEBUG_PRINT("convert counter 0x%x\n", convert_counter);
 	/*  load upper 8 bits of convert interval */
 	writew((convert_counter >> 16) & 0xff,
-	       priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
+	       devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
 	/*  load lower 16 bits of scan delay */
 	writew(scan_counter & 0xffff,
-	       priv(dev)->main_iobase + ADC_DELAY_INTERVAL_LOWER_REG);
+	       devpriv->main_iobase + ADC_DELAY_INTERVAL_LOWER_REG);
 	/*  load upper 8 bits of scan delay */
 	writew((scan_counter >> 16) & 0xff,
-	       priv(dev)->main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);
+	       devpriv->main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);
 	DEBUG_PRINT("scan counter 0x%x\n", scan_counter);
 }
 
@@ -2511,14 +2514,15 @@ static int use_internal_queue_6xxx(const struct comedi_cmd *cmd)
 static int setup_channel_queue(struct comedi_device *dev,
 			       const struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned short bits;
 	int i;
 
 	if (board(dev)->layout != LAYOUT_4020) {
 		if (use_internal_queue_6xxx(cmd)) {
-			priv(dev)->hw_config_bits &= ~EXT_QUEUE_BIT;
-			writew(priv(dev)->hw_config_bits,
-			       priv(dev)->main_iobase + HW_CONFIG_REG);
+			devpriv->hw_config_bits &= ~EXT_QUEUE_BIT;
+			writew(devpriv->hw_config_bits,
+			       devpriv->main_iobase + HW_CONFIG_REG);
 			bits = 0;
 			/*  set channel */
 			bits |= adc_chan_bits(CR_CHAN(cmd->chanlist[0]));
@@ -2534,24 +2538,24 @@ static int setup_channel_queue(struct comedi_device *dev,
 			/*  set stop channel */
 			writew(adc_chan_bits
 			       (CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])),
-			       priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
+			       devpriv->main_iobase + ADC_QUEUE_HIGH_REG);
 			/*  set start channel, and rest of settings */
 			writew(bits,
-			       priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
+			       devpriv->main_iobase + ADC_QUEUE_LOAD_REG);
 		} else {
 			/*  use external queue */
 			if (dev->write_subdev && dev->write_subdev->busy) {
 				warn_external_queue(dev);
 				return -EBUSY;
 			}
-			priv(dev)->hw_config_bits |= EXT_QUEUE_BIT;
-			writew(priv(dev)->hw_config_bits,
-			       priv(dev)->main_iobase + HW_CONFIG_REG);
+			devpriv->hw_config_bits |= EXT_QUEUE_BIT;
+			writew(devpriv->hw_config_bits,
+			       devpriv->main_iobase + HW_CONFIG_REG);
 			/*  clear DAC buffer to prevent weird interactions */
 			writew(0,
-			       priv(dev)->main_iobase + DAC_BUFFER_CLEAR_REG);
+			       devpriv->main_iobase + DAC_BUFFER_CLEAR_REG);
 			/*  clear queue pointer */
-			writew(0, priv(dev)->main_iobase + ADC_QUEUE_CLEAR_REG);
+			writew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);
 			/*  load external queue */
 			for (i = 0; i < cmd->chanlist_len; i++) {
 				bits = 0;
@@ -2575,7 +2579,7 @@ static int setup_channel_queue(struct comedi_device *dev,
 					bits |= QUEUE_EOSCAN_BIT |
 					    QUEUE_EOSEQ_BIT;
 				writew(bits,
-				       priv(dev)->main_iobase +
+				       devpriv->main_iobase +
 				       ADC_QUEUE_FIFO_REG);
 				DEBUG_PRINT
 				    ("wrote 0x%x to external channel queue\n",
@@ -2583,32 +2587,32 @@ static int setup_channel_queue(struct comedi_device *dev,
 			}
 			/* doing a queue clear is not specified in board docs,
 			 * but required for reliable operation */
-			writew(0, priv(dev)->main_iobase + ADC_QUEUE_CLEAR_REG);
+			writew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);
 			/*  prime queue holding register */
-			writew(0, priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
+			writew(0, devpriv->main_iobase + ADC_QUEUE_LOAD_REG);
 		}
 	} else {
 		unsigned short old_cal_range_bits =
-		    priv(dev)->i2c_cal_range_bits;
+		    devpriv->i2c_cal_range_bits;
 
-		priv(dev)->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;
+		devpriv->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;
 		/* select BNC inputs */
-		priv(dev)->i2c_cal_range_bits |= adc_src_4020_bits(4);
+		devpriv->i2c_cal_range_bits |= adc_src_4020_bits(4);
 		/*  select ranges */
 		for (i = 0; i < cmd->chanlist_len; i++) {
 			unsigned int channel = CR_CHAN(cmd->chanlist[i]);
 			unsigned int range = CR_RANGE(cmd->chanlist[i]);
 
 			if (range == 0)
-				priv(dev)->i2c_cal_range_bits |=
+				devpriv->i2c_cal_range_bits |=
 				    attenuate_bit(channel);
 			else
-				priv(dev)->i2c_cal_range_bits &=
+				devpriv->i2c_cal_range_bits &=
 				    ~attenuate_bit(channel);
 		}
 		/*  update calibration/range i2c register only if necessary, as it is very slow */
-		if (old_cal_range_bits != priv(dev)->i2c_cal_range_bits) {
-			uint8_t i2c_data = priv(dev)->i2c_cal_range_bits;
+		if (old_cal_range_bits != devpriv->i2c_cal_range_bits) {
+			uint8_t i2c_data = devpriv->i2c_cal_range_bits;
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
 				  sizeof(i2c_data));
 		}
@@ -2620,6 +2624,8 @@ static inline void load_first_dma_descriptor(struct comedi_device *dev,
 					     unsigned int dma_channel,
 					     unsigned int descriptor_bits)
 {
+	struct pcidas64_private *devpriv = dev->private;
+
 	/* The transfer size, pci address, and local address registers
 	 * are supposedly unused during chained dma,
 	 * but I have found that left over values from last operation
@@ -2627,25 +2633,26 @@ static inline void load_first_dma_descriptor(struct comedi_device *dev,
 	 * block.  Initializing them to zero seems to fix the problem. */
 	if (dma_channel) {
 		writel(0,
-		       priv(dev)->plx9080_iobase + PLX_DMA1_TRANSFER_SIZE_REG);
-		writel(0, priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG);
+		       devpriv->plx9080_iobase + PLX_DMA1_TRANSFER_SIZE_REG);
+		writel(0, devpriv->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG);
 		writel(0,
-		       priv(dev)->plx9080_iobase + PLX_DMA1_LOCAL_ADDRESS_REG);
+		       devpriv->plx9080_iobase + PLX_DMA1_LOCAL_ADDRESS_REG);
 		writel(descriptor_bits,
-		       priv(dev)->plx9080_iobase + PLX_DMA1_DESCRIPTOR_REG);
+		       devpriv->plx9080_iobase + PLX_DMA1_DESCRIPTOR_REG);
 	} else {
 		writel(0,
-		       priv(dev)->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
-		writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
+		       devpriv->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
+		writel(0, devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
 		writel(0,
-		       priv(dev)->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
+		       devpriv->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
 		writel(descriptor_bits,
-		       priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+		       devpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 	}
 }
 
 static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	uint32_t bits;
@@ -2661,7 +2668,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return retval;
 
 	/*  make sure internal calibration source is turned off */
-	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
+	writew(0, devpriv->main_iobase + CALIBRATION_REG);
 
 	set_ai_pacing(dev, cmd);
 
@@ -2671,50 +2678,50 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	spin_lock_irqsave(&dev->spinlock, flags);
 	/* set mode, allow conversions through software gate */
-	priv(dev)->adc_control1_bits |= ADC_SW_GATE_BIT;
-	priv(dev)->adc_control1_bits &= ~ADC_DITHER_BIT;
+	devpriv->adc_control1_bits |= ADC_SW_GATE_BIT;
+	devpriv->adc_control1_bits &= ~ADC_DITHER_BIT;
 	if (board(dev)->layout != LAYOUT_4020) {
-		priv(dev)->adc_control1_bits &= ~ADC_MODE_MASK;
+		devpriv->adc_control1_bits &= ~ADC_MODE_MASK;
 		if (cmd->convert_src == TRIG_EXT)
-			priv(dev)->adc_control1_bits |= adc_mode_bits(13);	/*  good old mode 13 */
+			devpriv->adc_control1_bits |= adc_mode_bits(13);	/*  good old mode 13 */
 		else
-			priv(dev)->adc_control1_bits |= adc_mode_bits(8);	/*  mode 8.  What else could you need? */
+			devpriv->adc_control1_bits |= adc_mode_bits(8);	/*  mode 8.  What else could you need? */
 	} else {
-		priv(dev)->adc_control1_bits &= ~CHANNEL_MODE_4020_MASK;
+		devpriv->adc_control1_bits &= ~CHANNEL_MODE_4020_MASK;
 		if (cmd->chanlist_len == 4)
-			priv(dev)->adc_control1_bits |= FOUR_CHANNEL_4020_BITS;
+			devpriv->adc_control1_bits |= FOUR_CHANNEL_4020_BITS;
 		else if (cmd->chanlist_len == 2)
-			priv(dev)->adc_control1_bits |= TWO_CHANNEL_4020_BITS;
-		priv(dev)->adc_control1_bits &= ~ADC_LO_CHANNEL_4020_MASK;
-		priv(dev)->adc_control1_bits |=
+			devpriv->adc_control1_bits |= TWO_CHANNEL_4020_BITS;
+		devpriv->adc_control1_bits &= ~ADC_LO_CHANNEL_4020_MASK;
+		devpriv->adc_control1_bits |=
 		    adc_lo_chan_4020_bits(CR_CHAN(cmd->chanlist[0]));
-		priv(dev)->adc_control1_bits &= ~ADC_HI_CHANNEL_4020_MASK;
-		priv(dev)->adc_control1_bits |=
+		devpriv->adc_control1_bits &= ~ADC_HI_CHANNEL_4020_MASK;
+		devpriv->adc_control1_bits |=
 		    adc_hi_chan_4020_bits(CR_CHAN
 					  (cmd->
 					   chanlist[cmd->chanlist_len - 1]));
 	}
-	writew(priv(dev)->adc_control1_bits,
-	       priv(dev)->main_iobase + ADC_CONTROL1_REG);
-	DEBUG_PRINT("control1 bits 0x%x\n", priv(dev)->adc_control1_bits);
+	writew(devpriv->adc_control1_bits,
+	       devpriv->main_iobase + ADC_CONTROL1_REG);
+	DEBUG_PRINT("control1 bits 0x%x\n", devpriv->adc_control1_bits);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  clear adc buffer */
-	writew(0, priv(dev)->main_iobase + ADC_BUFFER_CLEAR_REG);
+	writew(0, devpriv->main_iobase + ADC_BUFFER_CLEAR_REG);
 
 	if ((cmd->flags & TRIG_WAKE_EOS) == 0 ||
 	    board(dev)->layout == LAYOUT_4020) {
-		priv(dev)->ai_dma_index = 0;
+		devpriv->ai_dma_index = 0;
 
 		/*  set dma transfer size */
 		for (i = 0; i < ai_dma_ring_count(board(dev)); i++)
-			priv(dev)->ai_dma_desc[i].transfer_size =
+			devpriv->ai_dma_desc[i].transfer_size =
 			    cpu_to_le32(dma_transfer_size(dev) *
 					sizeof(uint16_t));
 
 		/*  give location of first dma descriptor */
 		load_first_dma_descriptor(dev, 1,
-					  priv(dev)->ai_dma_desc_bus_addr |
+					  devpriv->ai_dma_desc_bus_addr |
 					  PLX_DESC_IN_PCI_BIT |
 					  PLX_INTR_TERM_COUNT |
 					  PLX_XFER_LOCAL_TO_PCI);
@@ -2729,7 +2736,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			bits |= EXT_START_TRIG_BNC_BIT;
 		if (cmd->stop_src == TRIG_EXT && CR_CHAN(cmd->stop_arg))
 			bits |= EXT_STOP_TRIG_BNC_BIT;
-		writew(bits, priv(dev)->main_iobase + DAQ_ATRIG_LOW_4020_REG);
+		writew(bits, devpriv->main_iobase + DAQ_ATRIG_LOW_4020_REG);
 	}
 
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -2747,16 +2754,16 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		bits |= ADC_START_TRIG_SOFT_BITS;
 	if (use_hw_sample_counter(cmd))
 		bits |= ADC_SAMPLE_COUNTER_EN_BIT;
-	writew(bits, priv(dev)->main_iobase + ADC_CONTROL0_REG);
+	writew(bits, devpriv->main_iobase + ADC_CONTROL0_REG);
 	DEBUG_PRINT("control0 bits 0x%x\n", bits);
 
-	priv(dev)->ai_cmd_running = 1;
+	devpriv->ai_cmd_running = 1;
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  start acquisition */
 	if (cmd->start_src == TRIG_NOW) {
-		writew(0, priv(dev)->main_iobase + ADC_START_REG);
+		writew(0, devpriv->main_iobase + ADC_START_REG);
 		DEBUG_PRINT("soft trig\n");
 	}
 
@@ -2766,6 +2773,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 /* read num_samples from 16 bit wide ai fifo */
 static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -2777,14 +2785,14 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 	do {
 		/*  get least significant 15 bits */
 		read_index =
-		    readw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
+		    readw(devpriv->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
 		write_index =
-		    readw(priv(dev)->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
+		    readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
 		/* Get most significant bits (grey code).  Different boards use different code
 		 * so use a scheme that doesn't depend on encoding.  This read must
 		 * occur after reading least significant 15 bits to avoid race
 		 * with fifo switching to next segment. */
-		prepost_bits = readw(priv(dev)->main_iobase + PREPOST_REG);
+		prepost_bits = readw(devpriv->main_iobase + PREPOST_REG);
 
 		/* if read and write pointers are not on the same fifo segment, read to the
 		 * end of the read segment */
@@ -2797,17 +2805,17 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 
 		if (read_segment != write_segment)
 			num_samples =
-			    priv(dev)->ai_fifo_segment_length - read_index;
+			    devpriv->ai_fifo_segment_length - read_index;
 		else
 			num_samples = write_index - read_index;
 
 		if (cmd->stop_src == TRIG_COUNT) {
-			if (priv(dev)->ai_count == 0)
+			if (devpriv->ai_count == 0)
 				break;
-			if (num_samples > priv(dev)->ai_count)
-				num_samples = priv(dev)->ai_count;
+			if (num_samples > devpriv->ai_count)
+				num_samples = devpriv->ai_count;
 
-			priv(dev)->ai_count -= num_samples;
+			devpriv->ai_count -= num_samples;
 		}
 
 		if (num_samples < 0) {
@@ -2820,7 +2828,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 
 		for (i = 0; i < num_samples; i++) {
 			cfc_write_to_buffer(s,
-					    readw(priv(dev)->main_iobase +
+					    readw(devpriv->main_iobase +
 						  ADC_FIFO_REG));
 		}
 
@@ -2834,6 +2842,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
  */
 static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -2841,17 +2850,17 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 	unsigned int max_transfer = 100000;
 	uint32_t fifo_data;
 	int write_code =
-	    readw(priv(dev)->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
+	    readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
 	int read_code =
-	    readw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
+	    readw(devpriv->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		if (max_transfer > priv(dev)->ai_count)
-			max_transfer = priv(dev)->ai_count;
+		if (max_transfer > devpriv->ai_count)
+			max_transfer = devpriv->ai_count;
 
 	}
 	for (i = 0; read_code != write_code && i < max_transfer;) {
-		fifo_data = readl(priv(dev)->dio_counter_iobase + ADC_FIFO_REG);
+		fifo_data = readl(devpriv->dio_counter_iobase + ADC_FIFO_REG);
 		cfc_write_to_buffer(s, fifo_data & 0xffff);
 		i++;
 		if (i < max_transfer) {
@@ -2859,9 +2868,9 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 			i++;
 		}
 		read_code =
-		    readw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
+		    readw(devpriv->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
 	}
-	priv(dev)->ai_count -= i;
+	devpriv->ai_count -= i;
 }
 
 /* empty fifo */
@@ -2875,6 +2884,7 @@ static void pio_drain_ai_fifo(struct comedi_device *dev)
 
 static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_async *async = dev->read_subdev->async;
 	uint32_t next_transfer_addr;
 	int j;
@@ -2883,36 +2893,36 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 
 	if (channel)
 		pci_addr_reg =
-		    priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
+		    devpriv->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
 	else
 		pci_addr_reg =
-		    priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+		    devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 
 	/*  loop until we have read all the full buffers */
 	for (j = 0, next_transfer_addr = readl(pci_addr_reg);
 	     (next_transfer_addr <
-	      priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index]
+	      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index]
 	      || next_transfer_addr >=
-	      priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index] +
+	      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] +
 	      DMA_BUFFER_SIZE) && j < ai_dma_ring_count(board(dev)); j++) {
 		/*  transfer data from dma buffer to comedi buffer */
 		num_samples = dma_transfer_size(dev);
 		if (async->cmd.stop_src == TRIG_COUNT) {
-			if (num_samples > priv(dev)->ai_count)
-				num_samples = priv(dev)->ai_count;
-			priv(dev)->ai_count -= num_samples;
+			if (num_samples > devpriv->ai_count)
+				num_samples = devpriv->ai_count;
+			devpriv->ai_count -= num_samples;
 		}
 		cfc_write_array_to_buffer(dev->read_subdev,
-					  priv(dev)->ai_buffer[priv(dev)->
+					  devpriv->ai_buffer[devpriv->
 							       ai_dma_index],
 					  num_samples * sizeof(uint16_t));
-		priv(dev)->ai_dma_index =
-		    (priv(dev)->ai_dma_index +
+		devpriv->ai_dma_index =
+		    (devpriv->ai_dma_index +
 		     1) % ai_dma_ring_count(board(dev));
 
 		DEBUG_PRINT("next buffer addr 0x%lx\n",
-			    (unsigned long)priv(dev)->
-			    ai_buffer_bus_addr[priv(dev)->ai_dma_index]);
+			    (unsigned long)devpriv->
+			    ai_buffer_bus_addr[devpriv->ai_dma_index]);
 		DEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);
 	}
 	/* XXX check for dma ring buffer overrun (use end-of-chain bit to mark last
@@ -2923,6 +2933,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 				unsigned short status,
 				unsigned int plx_status)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -2936,10 +2947,10 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 	}
 	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+	dma1_status = readb(devpriv->plx9080_iobase + PLX_DMA1_CS_REG);
 	if (plx_status & ICS_DMA1_A) {	/*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-		       priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+		       devpriv->plx9080_iobase + PLX_DMA1_CS_REG);
 		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
 
 		if (dma1_status & PLX_DMA_EN_BIT)
@@ -2959,14 +2970,14 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 	     (board(dev)->layout != LAYOUT_4020))) {
 		DEBUG_PRINT("pio fifo drain\n");
 		spin_lock_irqsave(&dev->spinlock, flags);
-		if (priv(dev)->ai_cmd_running) {
+		if (devpriv->ai_cmd_running) {
 			spin_unlock_irqrestore(&dev->spinlock, flags);
 			pio_drain_ai_fifo(dev);
 		} else
 			spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 	/*  if we are have all the data, then quit */
-	if ((cmd->stop_src == TRIG_COUNT && (int)priv(dev)->ai_count <= 0) ||
+	if ((cmd->stop_src == TRIG_COUNT && (int)devpriv->ai_count <= 0) ||
 	    (cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT))) {
 		async->events |= COMEDI_CB_EOA;
 	}
@@ -2976,29 +2987,31 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 
 static inline unsigned int prev_ao_dma_index(struct comedi_device *dev)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int buffer_index;
 
-	if (priv(dev)->ao_dma_index == 0)
+	if (devpriv->ao_dma_index == 0)
 		buffer_index = AO_DMA_RING_COUNT - 1;
 	else
-		buffer_index = priv(dev)->ao_dma_index - 1;
+		buffer_index = devpriv->ao_dma_index - 1;
 	return buffer_index;
 }
 
 static int last_ao_dma_load_completed(struct comedi_device *dev)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int buffer_index;
 	unsigned int transfer_address;
 	unsigned short dma_status;
 
 	buffer_index = prev_ao_dma_index(dev);
-	dma_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+	dma_status = readb(devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
 	if ((dma_status & PLX_DMA_DONE_BIT) == 0)
 		return 0;
 
 	transfer_address =
-	    readl(priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
-	if (transfer_address != priv(dev)->ao_buffer_bus_addr[buffer_index])
+	    readl(devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
+	if (transfer_address != devpriv->ao_buffer_bus_addr[buffer_index])
 		return 0;
 
 	return 1;
@@ -3007,10 +3020,12 @@ static int last_ao_dma_load_completed(struct comedi_device *dev)
 static int ao_stopped_by_error(struct comedi_device *dev,
 			       const struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
+
 	if (cmd->stop_src == TRIG_NONE)
 		return 1;
 	if (cmd->stop_src == TRIG_COUNT) {
-		if (priv(dev)->ao_count)
+		if (devpriv->ao_count)
 			return 1;
 		if (last_ao_dma_load_completed(dev) == 0)
 			return 1;
@@ -3032,10 +3047,11 @@ static inline int ao_dma_needs_restart(struct comedi_device *dev,
 
 static void restart_ao_dma(struct comedi_device *dev)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int dma_desc_bits;
 
 	dma_desc_bits =
-	    readl(priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+	    readl(devpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 	dma_desc_bits &= ~PLX_END_OF_CHAIN_BIT;
 	DEBUG_PRINT("restarting ao dma, descriptor reg 0x%x\n", dma_desc_bits);
 	load_first_dma_descriptor(dev, 0, dma_desc_bits);
@@ -3046,6 +3062,7 @@ static void restart_ao_dma(struct comedi_device *dev)
 static void handle_ao_interrupt(struct comedi_device *dev,
 				unsigned short status, unsigned int plx_status)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_async *async;
 	struct comedi_cmd *cmd;
@@ -3060,15 +3077,15 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 
 	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+	dma0_status = readb(devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		if ((dma0_status & PLX_DMA_EN_BIT)
 		    && !(dma0_status & PLX_DMA_DONE_BIT))
 			writeb(PLX_DMA_EN_BIT | PLX_CLEAR_DMA_INTR_BIT,
-			       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+			       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
 		else
 			writeb(PLX_CLEAR_DMA_INTR_BIT,
-			       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+			       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		DEBUG_PRINT("dma0 status 0x%x\n", dma0_status);
 		if (dma0_status & PLX_DMA_EN_BIT) {
@@ -3086,10 +3103,10 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 		if (ao_stopped_by_error(dev, cmd))
 			async->events |= COMEDI_CB_ERROR;
 		DEBUG_PRINT("plx dma0 desc reg 0x%x\n",
-			    readl(priv(dev)->plx9080_iobase +
+			    readl(devpriv->plx9080_iobase +
 				  PLX_DMA0_DESCRIPTOR_REG));
 		DEBUG_PRINT("plx dma0 address reg 0x%x\n",
-			    readl(priv(dev)->plx9080_iobase +
+			    readl(devpriv->plx9080_iobase +
 				  PLX_DMA0_PCI_ADDRESS_REG));
 	}
 	cfc_handle_events(dev, s);
@@ -3098,12 +3115,13 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 static irqreturn_t handle_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned short status;
 	uint32_t plx_status;
 	uint32_t plx_bits;
 
-	plx_status = readl(priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
-	status = readw(priv(dev)->main_iobase + HW_STATUS_REG);
+	plx_status = readl(devpriv->plx9080_iobase + PLX_INTRCS_REG);
+	status = readw(devpriv->main_iobase + HW_STATUS_REG);
 
 	DEBUG_PRINT("cb_pcidas64: hw status 0x%x ", status);
 	DEBUG_PRINT("plx status 0x%x\n", plx_status);
@@ -3121,8 +3139,8 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 
 	/*  clear possible plx9080 interrupt sources */
 	if (plx_status & ICS_LDIA) {	/*  clear local doorbell interrupt */
-		plx_bits = readl(priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);
-		writel(plx_bits, priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);
+		plx_bits = readl(devpriv->plx9080_iobase + PLX_DBR_OUT_REG);
+		writel(plx_bits, devpriv->plx9080_iobase + PLX_DBR_OUT_REG);
 		DEBUG_PRINT(" cleared local doorbell bits 0x%x\n", plx_bits);
 	}
 
@@ -3133,26 +3151,28 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 
 static void abort_dma(struct comedi_device *dev, unsigned int channel)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned long flags;
 
 	/*  spinlock for plx dma control/status reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 
-	plx9080_abort_dma(priv(dev)->plx9080_iobase, channel);
+	plx9080_abort_dma(devpriv->plx9080_iobase, channel);
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->spinlock, flags);
-	if (priv(dev)->ai_cmd_running == 0) {
+	if (devpriv->ai_cmd_running == 0) {
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		return 0;
 	}
-	priv(dev)->ai_cmd_running = 0;
+	devpriv->ai_cmd_running = 0;
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	disable_ai_pacing(dev);
@@ -3166,29 +3186,30 @@ static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	int chan = CR_CHAN(insn->chanspec);
 	int range = CR_RANGE(insn->chanspec);
 
 	/*  do some initializing */
-	writew(0, priv(dev)->main_iobase + DAC_CONTROL0_REG);
+	writew(0, devpriv->main_iobase + DAC_CONTROL0_REG);
 
 	/*  set range */
-	set_dac_range_bits(dev, &priv(dev)->dac_control1_bits, chan, range);
-	writew(priv(dev)->dac_control1_bits,
-	       priv(dev)->main_iobase + DAC_CONTROL1_REG);
+	set_dac_range_bits(dev, &devpriv->dac_control1_bits, chan, range);
+	writew(devpriv->dac_control1_bits,
+	       devpriv->main_iobase + DAC_CONTROL1_REG);
 
 	/*  write to channel */
 	if (board(dev)->layout == LAYOUT_4020) {
 		writew(data[0] & 0xff,
-		       priv(dev)->main_iobase + dac_lsb_4020_reg(chan));
+		       devpriv->main_iobase + dac_lsb_4020_reg(chan));
 		writew((data[0] >> 8) & 0xf,
-		       priv(dev)->main_iobase + dac_msb_4020_reg(chan));
+		       devpriv->main_iobase + dac_msb_4020_reg(chan));
 	} else {
-		writew(data[0], priv(dev)->main_iobase + dac_convert_reg(chan));
+		writew(data[0], devpriv->main_iobase + dac_convert_reg(chan));
 	}
 
 	/*  remember output value */
-	priv(dev)->ao_value[chan] = data[0];
+	devpriv->ao_value[chan] = data[0];
 
 	return 1;
 }
@@ -3197,7 +3218,9 @@ static int ao_readback_insn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	data[0] = priv(dev)->ao_value[CR_CHAN(insn->chanspec)];
+	struct pcidas64_private *devpriv = dev->private;
+
+	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
@@ -3205,6 +3228,7 @@ static int ao_readback_insn(struct comedi_device *dev,
 static void set_dac_control0_reg(struct comedi_device *dev,
 				 const struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int bits = DAC_ENABLE_BIT | WAVEFORM_GATE_LEVEL_BIT |
 	    WAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;
 
@@ -3220,12 +3244,13 @@ static void set_dac_control0_reg(struct comedi_device *dev,
 		if (cmd->scan_begin_arg & CR_INVERT)
 			bits |= DAC_EXT_UPDATE_FALLING_BIT;
 	}
-	writew(bits, priv(dev)->main_iobase + DAC_CONTROL0_REG);
+	writew(bits, devpriv->main_iobase + DAC_CONTROL0_REG);
 }
 
 static void set_dac_control1_reg(struct comedi_device *dev,
 				 const struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	int i;
 
 	for (i = 0; i < cmd->chanlist_len; i++) {
@@ -3233,17 +3258,18 @@ static void set_dac_control1_reg(struct comedi_device *dev,
 
 		channel = CR_CHAN(cmd->chanlist[i]);
 		range = CR_RANGE(cmd->chanlist[i]);
-		set_dac_range_bits(dev, &priv(dev)->dac_control1_bits, channel,
+		set_dac_range_bits(dev, &devpriv->dac_control1_bits, channel,
 				   range);
 	}
-	priv(dev)->dac_control1_bits |= DAC_SW_GATE_BIT;
-	writew(priv(dev)->dac_control1_bits,
-	       priv(dev)->main_iobase + DAC_CONTROL1_REG);
+	devpriv->dac_control1_bits |= DAC_SW_GATE_BIT;
+	writew(devpriv->dac_control1_bits,
+	       devpriv->main_iobase + DAC_CONTROL1_REG);
 }
 
 static void set_dac_select_reg(struct comedi_device *dev,
 			       const struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	uint16_t bits;
 	unsigned int first_channel, last_channel;
 
@@ -3254,12 +3280,13 @@ static void set_dac_select_reg(struct comedi_device *dev,
 
 	bits = (first_channel & 0x7) | (last_channel & 0x7) << 3;
 
-	writew(bits, priv(dev)->main_iobase + DAC_SELECT_REG);
+	writew(bits, devpriv->main_iobase + DAC_SELECT_REG);
 }
 
 static void set_dac_interval_regs(struct comedi_device *dev,
 				  const struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int divisor;
 
 	if (cmd->scan_begin_src != TRIG_TIMER)
@@ -3271,28 +3298,29 @@ static void set_dac_interval_regs(struct comedi_device *dev,
 		divisor = max_counter_value;
 	}
 	writew(divisor & 0xffff,
-	       priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_LOWER_REG);
+	       devpriv->main_iobase + DAC_SAMPLE_INTERVAL_LOWER_REG);
 	writew((divisor >> 16) & 0xff,
-	       priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_UPPER_REG);
+	       devpriv->main_iobase + DAC_SAMPLE_INTERVAL_UPPER_REG);
 }
 
 static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 				       const struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int num_bytes, buffer_index, prev_buffer_index;
 	unsigned int next_bits;
 
-	buffer_index = priv(dev)->ao_dma_index;
+	buffer_index = devpriv->ao_dma_index;
 	prev_buffer_index = prev_ao_dma_index(dev);
 
 	DEBUG_PRINT("attempting to load ao buffer %i (0x%x)\n", buffer_index,
-		    priv(dev)->ao_buffer_bus_addr[buffer_index]);
+		    devpriv->ao_buffer_bus_addr[buffer_index]);
 
 	num_bytes = comedi_buf_read_n_available(dev->write_subdev->async);
 	if (num_bytes > DMA_BUFFER_SIZE)
 		num_bytes = DMA_BUFFER_SIZE;
-	if (cmd->stop_src == TRIG_COUNT && num_bytes > priv(dev)->ao_count)
-		num_bytes = priv(dev)->ao_count;
+	if (cmd->stop_src == TRIG_COUNT && num_bytes > devpriv->ao_count)
+		num_bytes = devpriv->ao_count;
 	num_bytes -= num_bytes % bytes_in_sample;
 
 	if (num_bytes == 0)
@@ -3301,43 +3329,44 @@ static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 	DEBUG_PRINT("loading %i bytes\n", num_bytes);
 
 	num_bytes = cfc_read_array_from_buffer(dev->write_subdev,
-					       priv(dev)->
+					       devpriv->
 					       ao_buffer[buffer_index],
 					       num_bytes);
-	priv(dev)->ao_dma_desc[buffer_index].transfer_size =
+	devpriv->ao_dma_desc[buffer_index].transfer_size =
 	    cpu_to_le32(num_bytes);
 	/* set end of chain bit so we catch underruns */
-	next_bits = le32_to_cpu(priv(dev)->ao_dma_desc[buffer_index].next);
+	next_bits = le32_to_cpu(devpriv->ao_dma_desc[buffer_index].next);
 	next_bits |= PLX_END_OF_CHAIN_BIT;
-	priv(dev)->ao_dma_desc[buffer_index].next = cpu_to_le32(next_bits);
+	devpriv->ao_dma_desc[buffer_index].next = cpu_to_le32(next_bits);
 	/* clear end of chain bit on previous buffer now that we have set it
 	 * for the last buffer */
-	next_bits = le32_to_cpu(priv(dev)->ao_dma_desc[prev_buffer_index].next);
+	next_bits = le32_to_cpu(devpriv->ao_dma_desc[prev_buffer_index].next);
 	next_bits &= ~PLX_END_OF_CHAIN_BIT;
-	priv(dev)->ao_dma_desc[prev_buffer_index].next = cpu_to_le32(next_bits);
+	devpriv->ao_dma_desc[prev_buffer_index].next = cpu_to_le32(next_bits);
 
-	priv(dev)->ao_dma_index = (buffer_index + 1) % AO_DMA_RING_COUNT;
-	priv(dev)->ao_count -= num_bytes;
+	devpriv->ao_dma_index = (buffer_index + 1) % AO_DMA_RING_COUNT;
+	devpriv->ao_count -= num_bytes;
 
 	return num_bytes;
 }
 
 static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int num_bytes;
 	unsigned int next_transfer_addr;
 	void __iomem *pci_addr_reg =
-	    priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+	    devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 	unsigned int buffer_index;
 
 	do {
-		buffer_index = priv(dev)->ao_dma_index;
+		buffer_index = devpriv->ao_dma_index;
 		/* don't overwrite data that hasn't been transferred yet */
 		next_transfer_addr = readl(pci_addr_reg);
 		if (next_transfer_addr >=
-		    priv(dev)->ao_buffer_bus_addr[buffer_index]
+		    devpriv->ao_buffer_bus_addr[buffer_index]
 		    && next_transfer_addr <
-		    priv(dev)->ao_buffer_bus_addr[buffer_index] +
+		    devpriv->ao_buffer_bus_addr[buffer_index] +
 		    DMA_BUFFER_SIZE)
 			return;
 		num_bytes = load_ao_dma_buffer(dev, cmd);
@@ -3346,27 +3375,28 @@ static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 
 static int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int num_bytes;
 	int i;
 
 	/* clear queue pointer too, since external queue has
 	 * weird interactions with ao fifo */
-	writew(0, priv(dev)->main_iobase + ADC_QUEUE_CLEAR_REG);
-	writew(0, priv(dev)->main_iobase + DAC_BUFFER_CLEAR_REG);
+	writew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);
+	writew(0, devpriv->main_iobase + DAC_BUFFER_CLEAR_REG);
 
 	num_bytes = (DAC_FIFO_SIZE / 2) * bytes_in_sample;
 	if (cmd->stop_src == TRIG_COUNT &&
-	    num_bytes / bytes_in_sample > priv(dev)->ao_count)
-		num_bytes = priv(dev)->ao_count * bytes_in_sample;
+	    num_bytes / bytes_in_sample > devpriv->ao_count)
+		num_bytes = devpriv->ao_count * bytes_in_sample;
 	num_bytes = cfc_read_array_from_buffer(dev->write_subdev,
-					       priv(dev)->ao_bounce_buffer,
+					       devpriv->ao_bounce_buffer,
 					       num_bytes);
 	for (i = 0; i < num_bytes / bytes_in_sample; i++) {
-		writew(priv(dev)->ao_bounce_buffer[i],
-		       priv(dev)->main_iobase + DAC_FIFO_REG);
+		writew(devpriv->ao_bounce_buffer[i],
+		       devpriv->main_iobase + DAC_FIFO_REG);
 	}
-	priv(dev)->ao_count -= num_bytes / bytes_in_sample;
-	if (cmd->stop_src == TRIG_COUNT && priv(dev)->ao_count == 0)
+	devpriv->ao_count -= num_bytes / bytes_in_sample;
+	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_count == 0)
 		return 0;
 	num_bytes = load_ao_dma_buffer(dev, cmd);
 	if (num_bytes == 0)
@@ -3392,6 +3422,7 @@ static inline int external_ai_queue_in_use(struct comedi_device *dev)
 
 static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
 	if (external_ai_queue_in_use(dev)) {
@@ -3399,14 +3430,14 @@ static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EBUSY;
 	}
 	/* disable analog output system during setup */
-	writew(0x0, priv(dev)->main_iobase + DAC_CONTROL0_REG);
+	writew(0x0, devpriv->main_iobase + DAC_CONTROL0_REG);
 
-	priv(dev)->ao_dma_index = 0;
-	priv(dev)->ao_count = cmd->stop_arg * cmd->chanlist_len;
+	devpriv->ao_dma_index = 0;
+	devpriv->ao_count = cmd->stop_arg * cmd->chanlist_len;
 
 	set_dac_select_reg(dev, cmd);
 	set_dac_interval_regs(dev, cmd);
-	load_first_dma_descriptor(dev, 0, priv(dev)->ao_dma_desc_bus_addr |
+	load_first_dma_descriptor(dev, 0, devpriv->ao_dma_desc_bus_addr |
 				  PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT);
 
 	set_dac_control1_reg(dev, cmd);
@@ -3418,6 +3449,7 @@ static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 		      unsigned int trig_num)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
 
@@ -3431,7 +3463,7 @@ static int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	set_dac_control0_reg(dev, cmd);
 
 	if (cmd->start_src == TRIG_INT)
-		writew(0, priv(dev)->main_iobase + DAC_START_REG);
+		writew(0, devpriv->main_iobase + DAC_START_REG);
 
 	s->async->inttrig = NULL;
 
@@ -3533,7 +3565,9 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	writew(0x0, priv(dev)->main_iobase + DAC_CONTROL0_REG);
+	struct pcidas64_private *devpriv = dev->private;
+
+	writew(0x0, devpriv->main_iobase + DAC_CONTROL0_REG);
 	abort_dma(dev, 0);
 	return 0;
 }
@@ -3564,9 +3598,10 @@ static int dio_callback_4020(int dir, int port, int data, unsigned long arg)
 static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int bits;
 
-	bits = readb(priv(dev)->dio_counter_iobase + DI_REG);
+	bits = readb(devpriv->dio_counter_iobase + DI_REG);
 	bits &= 0xf;
 	data[1] = bits;
 	data[0] = 0;
@@ -3577,13 +3612,15 @@ static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
 static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcidas64_private *devpriv = dev->private;
+
 	data[0] &= 0xf;
 	/*  zero bits we are going to change */
 	s->state &= ~data[0];
 	/*  set new bits */
 	s->state |= data[0] & data[1];
 
-	writeb(s->state, priv(dev)->dio_counter_iobase + DO_REG);
+	writeb(s->state, devpriv->dio_counter_iobase + DO_REG);
 
 	data[1] = s->state;
 
@@ -3594,6 +3631,7 @@ static int dio_60xx_config_insn(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int mask;
 
 	mask = 1 << CR_CHAN(insn->chanspec);
@@ -3613,7 +3651,7 @@ static int dio_60xx_config_insn(struct comedi_device *dev,
 	}
 
 	writeb(s->io_bits,
-	       priv(dev)->dio_counter_iobase + DIO_DIRECTION_60XX_REG);
+	       devpriv->dio_counter_iobase + DIO_DIRECTION_60XX_REG);
 
 	return 1;
 }
@@ -3621,14 +3659,16 @@ static int dio_60xx_config_insn(struct comedi_device *dev,
 static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcidas64_private *devpriv = dev->private;
+
 	if (data[0]) {
 		s->state &= ~data[0];
 		s->state |= (data[0] & data[1]);
 		writeb(s->state,
-		       priv(dev)->dio_counter_iobase + DIO_DATA_60XX_REG);
+		       devpriv->dio_counter_iobase + DIO_DATA_60XX_REG);
 	}
 
-	data[1] = readb(priv(dev)->dio_counter_iobase + DIO_DATA_60XX_REG);
+	data[1] = readb(devpriv->dio_counter_iobase + DIO_DATA_60XX_REG);
 
 	return insn->n;
 }
@@ -3636,7 +3676,9 @@ static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
 static void caldac_write(struct comedi_device *dev, unsigned int channel,
 			 unsigned int value)
 {
-	priv(dev)->caldac_state[channel] = value;
+	struct pcidas64_private *devpriv = dev->private;
+
+	devpriv->caldac_state[channel] = value;
 
 	switch (board(dev)->layout) {
 	case LAYOUT_60XX:
@@ -3655,11 +3697,12 @@ static int calib_write_insn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	int channel = CR_CHAN(insn->chanspec);
 
 	/* return immediately if setting hasn't changed, since
 	 * programming these things is slow */
-	if (priv(dev)->caldac_state[channel] == data[0])
+	if (devpriv->caldac_state[channel] == data[0])
 		return 1;
 
 	caldac_write(dev, channel, data[0]);
@@ -3671,9 +3714,10 @@ static int calib_read_insn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
-	data[0] = priv(dev)->caldac_state[channel];
+	data[0] = devpriv->caldac_state[channel];
 
 	return 1;
 }
@@ -3681,16 +3725,17 @@ static int calib_read_insn(struct comedi_device *dev,
 static void ad8402_write(struct comedi_device *dev, unsigned int channel,
 			 unsigned int value)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	static const int bitstream_length = 10;
 	unsigned int bit, register_bits;
 	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
 	static const int ad8402_udelay = 1;
 
-	priv(dev)->ad8402_state[channel] = value;
+	devpriv->ad8402_state[channel] = value;
 
 	register_bits = SELECT_8402_64XX_BIT;
 	udelay(ad8402_udelay);
-	writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
+	writew(register_bits, devpriv->main_iobase + CALIBRATION_REG);
 
 	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
 		if (bitstream & bit)
@@ -3698,14 +3743,14 @@ static void ad8402_write(struct comedi_device *dev, unsigned int channel,
 		else
 			register_bits &= ~SERIAL_DATA_IN_BIT;
 		udelay(ad8402_udelay);
-		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
+		writew(register_bits, devpriv->main_iobase + CALIBRATION_REG);
 		udelay(ad8402_udelay);
 		writew(register_bits | SERIAL_CLOCK_BIT,
-		       priv(dev)->main_iobase + CALIBRATION_REG);
+		       devpriv->main_iobase + CALIBRATION_REG);
 	}
 
 	udelay(ad8402_udelay);
-	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
+	writew(0, devpriv->main_iobase + CALIBRATION_REG);
 }
 
 /* for pci-das6402/16, channel 0 is analog input gain and channel 1 is offset */
@@ -3713,14 +3758,15 @@ static int ad8402_write_insn(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	int channel = CR_CHAN(insn->chanspec);
 
 	/* return immediately if setting hasn't changed, since
 	 * programming these things is slow */
-	if (priv(dev)->ad8402_state[channel] == data[0])
+	if (devpriv->ad8402_state[channel] == data[0])
 		return 1;
 
-	priv(dev)->ad8402_state[channel] = data[0];
+	devpriv->ad8402_state[channel] = data[0];
 
 	ad8402_write(dev, channel, data[0]);
 
@@ -3731,62 +3777,64 @@ static int ad8402_read_insn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
-	data[0] = priv(dev)->ad8402_state[channel];
+	data[0] = devpriv->ad8402_state[channel];
 
 	return 1;
 }
 
 static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	static const int bitstream_length = 11;
 	static const int read_command = 0x6;
 	unsigned int bitstream = (read_command << 8) | address;
 	unsigned int bit;
 	void __iomem * const plx_control_addr =
-	    priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
+	    devpriv->plx9080_iobase + PLX_CONTROL_REG;
 	uint16_t value;
 	static const int value_length = 16;
 	static const int eeprom_udelay = 1;
 
 	udelay(eeprom_udelay);
-	priv(dev)->plx_control_bits &= ~CTL_EE_CLK & ~CTL_EE_CS;
+	devpriv->plx_control_bits &= ~CTL_EE_CLK & ~CTL_EE_CS;
 	/*  make sure we don't send anything to the i2c bus on 4020 */
-	priv(dev)->plx_control_bits |= CTL_USERO;
-	writel(priv(dev)->plx_control_bits, plx_control_addr);
+	devpriv->plx_control_bits |= CTL_USERO;
+	writel(devpriv->plx_control_bits, plx_control_addr);
 	/*  activate serial eeprom */
 	udelay(eeprom_udelay);
-	priv(dev)->plx_control_bits |= CTL_EE_CS;
-	writel(priv(dev)->plx_control_bits, plx_control_addr);
+	devpriv->plx_control_bits |= CTL_EE_CS;
+	writel(devpriv->plx_control_bits, plx_control_addr);
 
 	/*  write read command and desired memory address */
 	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
 		/*  set bit to be written */
 		udelay(eeprom_udelay);
 		if (bitstream & bit)
-			priv(dev)->plx_control_bits |= CTL_EE_W;
+			devpriv->plx_control_bits |= CTL_EE_W;
 		else
-			priv(dev)->plx_control_bits &= ~CTL_EE_W;
-		writel(priv(dev)->plx_control_bits, plx_control_addr);
+			devpriv->plx_control_bits &= ~CTL_EE_W;
+		writel(devpriv->plx_control_bits, plx_control_addr);
 		/*  clock in bit */
 		udelay(eeprom_udelay);
-		priv(dev)->plx_control_bits |= CTL_EE_CLK;
-		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		devpriv->plx_control_bits |= CTL_EE_CLK;
+		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(eeprom_udelay);
-		priv(dev)->plx_control_bits &= ~CTL_EE_CLK;
-		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		devpriv->plx_control_bits &= ~CTL_EE_CLK;
+		writel(devpriv->plx_control_bits, plx_control_addr);
 	}
 	/*  read back value from eeprom memory location */
 	value = 0;
 	for (bit = 1 << (value_length - 1); bit; bit >>= 1) {
 		/*  clock out bit */
 		udelay(eeprom_udelay);
-		priv(dev)->plx_control_bits |= CTL_EE_CLK;
-		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		devpriv->plx_control_bits |= CTL_EE_CLK;
+		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(eeprom_udelay);
-		priv(dev)->plx_control_bits &= ~CTL_EE_CLK;
-		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		devpriv->plx_control_bits &= ~CTL_EE_CLK;
+		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(eeprom_udelay);
 		if (readl(plx_control_addr) & CTL_EE_R)
 			value |= bit;
@@ -3794,8 +3842,8 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 
 	/*  deactivate eeprom serial input */
 	udelay(eeprom_udelay);
-	priv(dev)->plx_control_bits &= ~CTL_EE_CS;
-	writel(priv(dev)->plx_control_bits, plx_control_addr);
+	devpriv->plx_control_bits &= ~CTL_EE_CS;
+	writel(devpriv->plx_control_bits, plx_control_addr);
 
 	return value;
 }
@@ -3911,7 +3959,9 @@ static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 /* query length of fifo */
 static unsigned int ai_fifo_size(struct comedi_device *dev)
 {
-	return priv(dev)->ai_fifo_segment_length *
+	struct pcidas64_private *devpriv = dev->private;
+
+	return devpriv->ai_fifo_segment_length *
 	    board(dev)->ai_fifo->num_segments *
 	    board(dev)->ai_fifo->sample_packing_ratio;
 }
@@ -3919,6 +3969,7 @@ static unsigned int ai_fifo_size(struct comedi_device *dev)
 static int set_ai_fifo_segment_length(struct comedi_device *dev,
 				      unsigned int num_entries)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	static const int increment_size = 0x100;
 	const struct hw_fifo_info *const fifo = board(dev)->ai_fifo;
 	unsigned int num_increments;
@@ -3933,17 +3984,17 @@ static int set_ai_fifo_segment_length(struct comedi_device *dev,
 	num_increments = (num_entries + increment_size / 2) / increment_size;
 
 	bits = (~(num_increments - 1)) & fifo->fifo_size_reg_mask;
-	priv(dev)->fifo_size_bits &= ~fifo->fifo_size_reg_mask;
-	priv(dev)->fifo_size_bits |= bits;
-	writew(priv(dev)->fifo_size_bits,
-	       priv(dev)->main_iobase + FIFO_SIZE_REG);
+	devpriv->fifo_size_bits &= ~fifo->fifo_size_reg_mask;
+	devpriv->fifo_size_bits |= bits;
+	writew(devpriv->fifo_size_bits,
+	       devpriv->main_iobase + FIFO_SIZE_REG);
 
-	priv(dev)->ai_fifo_segment_length = num_increments * increment_size;
+	devpriv->ai_fifo_segment_length = num_increments * increment_size;
 
 	DEBUG_PRINT("set hardware fifo segment length to %i\n",
-		    priv(dev)->ai_fifo_segment_length);
+		    devpriv->ai_fifo_segment_length);
 
-	return priv(dev)->ai_fifo_segment_length;
+	return devpriv->ai_fifo_segment_length;
 }
 
 /* pci-6025 8800 caldac:
@@ -3970,6 +4021,7 @@ static int set_ai_fifo_segment_length(struct comedi_device *dev,
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 			     uint8_t value)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	static const int num_caldac_channels = 8;
 	static const int bitstream_length = 11;
 	unsigned int bitstream = ((address & 0x7) << 8) | value;
@@ -3985,15 +4037,15 @@ static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 		if (bitstream & bit)
 			register_bits |= SERIAL_DATA_IN_BIT;
 		udelay(caldac_8800_udelay);
-		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
+		writew(register_bits, devpriv->main_iobase + CALIBRATION_REG);
 		register_bits |= SERIAL_CLOCK_BIT;
 		udelay(caldac_8800_udelay);
-		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
+		writew(register_bits, devpriv->main_iobase + CALIBRATION_REG);
 	}
 	udelay(caldac_8800_udelay);
-	writew(SELECT_8800_BIT, priv(dev)->main_iobase + CALIBRATION_REG);
+	writew(SELECT_8800_BIT, devpriv->main_iobase + CALIBRATION_REG);
 	udelay(caldac_8800_udelay);
-	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
+	writew(0, devpriv->main_iobase + CALIBRATION_REG);
 	udelay(caldac_8800_udelay);
 	return 0;
 }
@@ -4066,19 +4118,20 @@ static const int i2c_low_udelay = 10;
 /* set i2c data line high or low */
 static void i2c_set_sda(struct comedi_device *dev, int state)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	static const int data_bit = CTL_EE_W;
-	void __iomem *plx_control_addr = priv(dev)->plx9080_iobase +
+	void __iomem *plx_control_addr = devpriv->plx9080_iobase +
 					 PLX_CONTROL_REG;
 
 	if (state) {
 		/*  set data line high */
-		priv(dev)->plx_control_bits &= ~data_bit;
-		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		devpriv->plx_control_bits &= ~data_bit;
+		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(i2c_high_udelay);
 	} else {		/*  set data line low */
 
-		priv(dev)->plx_control_bits |= data_bit;
-		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		devpriv->plx_control_bits |= data_bit;
+		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(i2c_low_udelay);
 	}
 }
@@ -4086,19 +4139,20 @@ static void i2c_set_sda(struct comedi_device *dev, int state)
 /* set i2c clock line high or low */
 static void i2c_set_scl(struct comedi_device *dev, int state)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	static const int clock_bit = CTL_USERO;
-	void __iomem *plx_control_addr = priv(dev)->plx9080_iobase +
+	void __iomem *plx_control_addr = devpriv->plx9080_iobase +
 					 PLX_CONTROL_REG;
 
 	if (state) {
 		/*  set clock line high */
-		priv(dev)->plx_control_bits &= ~clock_bit;
-		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		devpriv->plx_control_bits &= ~clock_bit;
+		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(i2c_high_udelay);
 	} else {		/*  set clock line low */
 
-		priv(dev)->plx_control_bits |= clock_bit;
-		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		devpriv->plx_control_bits |= clock_bit;
+		writel(devpriv->plx_control_bits, plx_control_addr);
 		udelay(i2c_low_udelay);
 	}
 }
@@ -4150,6 +4204,7 @@ static void i2c_stop(struct comedi_device *dev)
 static void i2c_write(struct comedi_device *dev, unsigned int address,
 		      const uint8_t *data, unsigned int length)
 {
+	struct pcidas64_private *devpriv = dev->private;
 	unsigned int i;
 	uint8_t bitstream;
 	static const int read_bit = 0x1;
@@ -4157,7 +4212,7 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 /* XXX need mutex to prevent simultaneous attempts to access eeprom and i2c bus */
 
 	/*  make sure we dont send anything to eeprom */
-	priv(dev)->plx_control_bits &= ~CTL_EE_CS;
+	devpriv->plx_control_bits &= ~CTL_EE_CS;
 
 	i2c_stop(dev);
 	i2c_start(dev);

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 7168883eed41..0472a9088abe 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2108,74 +2108,50 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int tmp;
 	unsigned int tmp_arg, tmp_arg2;
 	int i;
 	int aref;
 	unsigned int triggers;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_EXT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
 
-	tmp = cmd->scan_begin_src;
 	triggers = TRIG_TIMER;
 	if (board(dev)->layout == LAYOUT_4020)
 		triggers |= TRIG_OTHER;
 	else
 		triggers |= TRIG_FOLLOW;
-	cmd->scan_begin_src &= triggers;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, triggers);
 
-	tmp = cmd->convert_src;
 	triggers = TRIG_TIMER;
 	if (board(dev)->layout == LAYOUT_4020)
 		triggers |= TRIG_NOW;
 	else
 		triggers |= TRIG_EXT;
-	cmd->convert_src &= triggers;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->convert_src, triggers);
 
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_EXT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src,
+					TRIG_COUNT | TRIG_EXT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* Step 2a : make sure trigger sources are unique */
 
-	/*  uniqueness check */
-	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
-		err++;
-	if (cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_OTHER &&
-	    cmd->scan_begin_src != TRIG_FOLLOW)
-		err++;
-	if (cmd->convert_src != TRIG_TIMER &&
-	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT &&
-	    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
-	/*  compatibility check */
 	if (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)
-		err++;
+		err |= -EINVAL;
 	if (cmd->stop_src != TRIG_COUNT &&
 	    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
-		err++;
+		err |= -EINVAL;
 
 	if (err)
 		return 2;
@@ -3466,55 +3442,33 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		      struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int tmp;
 	unsigned int tmp_arg;
 	int i;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_INT | TRIG_EXT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_TIMER | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* Step 2a : make sure trigger sources are unique */
 
-	/*  uniqueness check */
-	if (cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)
-		err++;
-	if (cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_EXT)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+
+	/* Step 2b : and mutually compatible */
 
-	/*  compatibility check */
 	if (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)
-		err++;
+		err |= -EINVAL;
 	if (cmd->stop_src != TRIG_COUNT &&
 	    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
-		err++;
+		err |= -EINVAL;
 
 	if (err)
 		return 2;

commit e4eb9523efb89dc22f7db02df7495e89fac61416
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:32:04 2012 -0700

    staging: comedi: cb_pcidas64: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 65cbaabf6456..7168883eed41 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1348,7 +1348,7 @@ static int setup_subdevices(struct comedi_device *dev)
 	if (ret)
 		return ret;
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	/* analog input subdevice */
 	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
@@ -1379,7 +1379,7 @@ static int setup_subdevices(struct comedi_device *dev)
 	}
 
 	/* analog output subdevice */
-	s = dev->subdevices + 1;
+	s = &dev->subdevices[1];
 	if (board(dev)->ao_nchan) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags =
@@ -1401,7 +1401,7 @@ static int setup_subdevices(struct comedi_device *dev)
 	}
 
 	/*  digital input */
-	s = dev->subdevices + 2;
+	s = &dev->subdevices[2];
 	if (board(dev)->layout == LAYOUT_64XX) {
 		s->type = COMEDI_SUBD_DI;
 		s->subdev_flags = SDF_READABLE;
@@ -1414,7 +1414,7 @@ static int setup_subdevices(struct comedi_device *dev)
 
 	/*  digital output */
 	if (board(dev)->layout == LAYOUT_64XX) {
-		s = dev->subdevices + 3;
+		s = &dev->subdevices[3];
 		s->type = COMEDI_SUBD_DO;
 		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
 		s->n_chan = 4;
@@ -1425,7 +1425,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->type = COMEDI_SUBD_UNUSED;
 
 	/* 8255 */
-	s = dev->subdevices + 4;
+	s = &dev->subdevices[4];
 	if (board(dev)->has_8255) {
 		if (board(dev)->layout == LAYOUT_4020) {
 			dio_8255_iobase =
@@ -1442,7 +1442,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->type = COMEDI_SUBD_UNUSED;
 
 	/*  8 channel dio for 60xx */
-	s = dev->subdevices + 5;
+	s = &dev->subdevices[5];
 	if (board(dev)->layout == LAYOUT_60XX) {
 		s->type = COMEDI_SUBD_DIO;
 		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
@@ -1455,7 +1455,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->type = COMEDI_SUBD_UNUSED;
 
 	/*  caldac */
-	s = dev->subdevices + 6;
+	s = &dev->subdevices[6];
 	s->type = COMEDI_SUBD_CALIB;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 	s->n_chan = 8;
@@ -1469,7 +1469,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		caldac_write(dev, i, s->maxdata / 2);
 
 	/*  2 channel ad8402 potentiometer */
-	s = dev->subdevices + 7;
+	s = &dev->subdevices[7];
 	if (board(dev)->layout == LAYOUT_64XX) {
 		s->type = COMEDI_SUBD_CALIB;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
@@ -1483,7 +1483,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->type = COMEDI_SUBD_UNUSED;
 
 	/* serial EEPROM, if present */
-	s = dev->subdevices + 8;
+	s = &dev->subdevices[8];
 	if (readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG) & CTL_EECHK) {
 		s->type = COMEDI_SUBD_MEMORY;
 		s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
@@ -1494,7 +1494,7 @@ static int setup_subdevices(struct comedi_device *dev)
 		s->type = COMEDI_SUBD_UNUSED;
 
 	/*  user counter subd XXX */
-	s = dev->subdevices + 9;
+	s = &dev->subdevices[9];
 	s->type = COMEDI_SUBD_UNUSED;
 
 	return 0;
@@ -1847,7 +1847,7 @@ static void detach(struct comedi_device *dev)
 		}
 	}
 	if (dev->subdevices)
-		subdev_8255_cleanup(dev, dev->subdevices + 4);
+		subdev_8255_cleanup(dev, &dev->subdevices[4]);
 	if (pcidev) {
 		if (dev->iobase)
 			comedi_pci_disable(pcidev);

commit 000e2635028bf8a1537383c5c27bf1bff27bc2f6
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jul 18 18:43:18 2012 -0700

    staging: comedi: cb_pcidas64: store the pci_dev in the comedi_device
    
    Use the hw_dev pointer in the comedi_device struct to hold the
    pci_dev instead of carrying it in the private data.
    
    Save the pci bar in dev->iobase so the detach is consistent with
    the other comedi pci drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index d1b0327b6d13..65cbaabf6456 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1047,8 +1047,6 @@ struct ext_clock_info {
 
 /* this structure is for data unique to this hardware driver. */
 struct pcidas64_private {
-
-	struct pci_dev *hw_dev;	/*  pointer to board's pci_dev struct */
 	/*  base addresses (physical) */
 	resource_size_t plx9080_phys_iobase;
 	resource_size_t main_phys_iobase;
@@ -1553,12 +1551,13 @@ static void init_stc_registers(struct comedi_device *dev)
 
 static int alloc_and_init_dma_members(struct comedi_device *dev)
 {
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	int i;
 
 	/*  alocate pci dma buffers */
 	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 		priv(dev)->ai_buffer[i] =
-		    pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
+		    pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
 					 &priv(dev)->ai_buffer_bus_addr[i]);
 		if (priv(dev)->ai_buffer[i] == NULL)
 			return -ENOMEM;
@@ -1567,7 +1566,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 		if (ao_cmd_is_supported(board(dev))) {
 			priv(dev)->ao_buffer[i] =
-			    pci_alloc_consistent(priv(dev)->hw_dev,
+			    pci_alloc_consistent(pcidev,
 						 DMA_BUFFER_SIZE,
 						 &priv(dev)->
 						 ao_buffer_bus_addr[i]);
@@ -1578,7 +1577,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 	}
 	/*  allocate dma descriptors */
 	priv(dev)->ai_dma_desc =
-	    pci_alloc_consistent(priv(dev)->hw_dev,
+	    pci_alloc_consistent(pcidev,
 				 sizeof(struct plx_dma_desc) *
 				 ai_dma_ring_count(board(dev)),
 				 &priv(dev)->ai_dma_desc_bus_addr);
@@ -1589,7 +1588,7 @@ static int alloc_and_init_dma_members(struct comedi_device *dev)
 		    priv(dev)->ai_dma_desc_bus_addr);
 	if (ao_cmd_is_supported(board(dev))) {
 		priv(dev)->ao_dma_desc =
-		    pci_alloc_consistent(priv(dev)->hw_dev,
+		    pci_alloc_consistent(pcidev,
 					 sizeof(struct plx_dma_desc) *
 					 AO_DMA_RING_COUNT,
 					 &priv(dev)->ao_dma_desc_bus_addr);
@@ -1699,7 +1698,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	pcidev = cb_pcidas64_find_pci_dev(dev, it);
 	if (!pcidev)
 		return -EIO;
-	priv(dev)->hw_dev = pcidev;
+	comedi_set_hw_dev(dev, &pcidev->dev);
 
 	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
 		dev_warn(dev->class_dev,
@@ -1711,10 +1710,11 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* Initialize dev->board_name */
 	dev->board_name = board(dev)->name;
 
+	dev->iobase = pci_resource_start(pcidev, MAIN_BADDRINDEX);
+
 	priv(dev)->plx9080_phys_iobase =
 	    pci_resource_start(pcidev, PLX9080_BADDRINDEX);
-	priv(dev)->main_phys_iobase =
-	    pci_resource_start(pcidev, MAIN_BADDRINDEX);
+	priv(dev)->main_phys_iobase = dev->iobase;
 	priv(dev)->dio_counter_phys_iobase =
 	    pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
 
@@ -1791,12 +1791,13 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void detach(struct comedi_device *dev)
 {
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	unsigned int i;
 
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (priv(dev)) {
-		if (priv(dev)->hw_dev) {
+		if (pcidev) {
 			if (priv(dev)->plx9080_iobase) {
 				disable_plx_interrupts(dev);
 				iounmap(priv(dev)->plx9080_iobase);
@@ -1808,7 +1809,7 @@ static void detach(struct comedi_device *dev)
 			/*  free pci dma buffers */
 			for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 				if (priv(dev)->ai_buffer[i])
-					pci_free_consistent(priv(dev)->hw_dev,
+					pci_free_consistent(pcidev,
 							    DMA_BUFFER_SIZE,
 							    priv(dev)->
 							    ai_buffer[i],
@@ -1818,7 +1819,7 @@ static void detach(struct comedi_device *dev)
 			}
 			for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 				if (priv(dev)->ao_buffer[i])
-					pci_free_consistent(priv(dev)->hw_dev,
+					pci_free_consistent(pcidev,
 							    DMA_BUFFER_SIZE,
 							    priv(dev)->
 							    ao_buffer[i],
@@ -1828,7 +1829,7 @@ static void detach(struct comedi_device *dev)
 			}
 			/*  free dma descriptors */
 			if (priv(dev)->ai_dma_desc)
-				pci_free_consistent(priv(dev)->hw_dev,
+				pci_free_consistent(pcidev,
 						    sizeof(struct plx_dma_desc)
 						    *
 						    ai_dma_ring_count(board
@@ -1837,20 +1838,22 @@ static void detach(struct comedi_device *dev)
 						    priv(dev)->
 						    ai_dma_desc_bus_addr);
 			if (priv(dev)->ao_dma_desc)
-				pci_free_consistent(priv(dev)->hw_dev,
+				pci_free_consistent(pcidev,
 						    sizeof(struct plx_dma_desc)
 						    * AO_DMA_RING_COUNT,
 						    priv(dev)->ao_dma_desc,
 						    priv(dev)->
 						    ao_dma_desc_bus_addr);
-			if (priv(dev)->main_phys_iobase)
-				comedi_pci_disable(priv(dev)->hw_dev);
-
-			pci_dev_put(priv(dev)->hw_dev);
 		}
 	}
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, dev->subdevices + 4);
+	if (pcidev) {
+		if (dev->iobase)
+			comedi_pci_disable(pcidev);
+
+		pci_dev_put(pcidev);
+	}
 }
 
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,

commit 88262703416be01d6770fbf55737e73edb60ee16
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jul 18 18:42:57 2012 -0700

    staging: comedi: cb_pcidas64: cleanup "find pci device" code
    
    Add a couple local variables to make the tests more concise.
    Reorder the tests to make the for() loop checking for a
    matching boardtype quicker.
    
    Drop the dev_dbg for a match. It's just add noise.
    Reword the dev_err when no match is found.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 704f5ea2e9cd..d1b0327b6d13 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1654,33 +1654,29 @@ static struct pci_dev *cb_pcidas64_find_pci_dev(struct comedi_device *dev,
 						struct comedi_devconfig *it)
 {
 	struct pci_dev *pcidev = NULL;
-	int index;
+	int bus = it->options[0];
+	int slot = it->options[1];
+	int i;
 
 	for_each_pci_dev(pcidev) {
-		/*  is it not a computer boards card? */
+		if (bus || slot) {
+			if (bus != pcidev->bus->number ||
+			    slot != PCI_SLOT(pcidev->devfn))
+				continue;
+		}
 		if (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
 			continue;
-		/*  loop through cards supported by this driver */
-		for (index = 0; index < ARRAY_SIZE(pcidas64_boards); index++) {
-			if (pcidas64_boards[index].device_id != pcidev->device)
+
+		for (i = 0; i < ARRAY_SIZE(pcidas64_boards); i++) {
+			if (pcidas64_boards[i].device_id != pcidev->device)
 				continue;
-			/*  was a particular bus/slot requested? */
-			if (it->options[0] || it->options[1]) {
-				/*  are we on the wrong bus/slot? */
-				if (pcidev->bus->number != it->options[0] ||
-				    PCI_SLOT(pcidev->devfn) != it->options[1]) {
-					continue;
-				}
-			}
-			dev->board_ptr = pcidas64_boards + index;
-			dev_dbg(dev->class_dev, "Found %s on bus %i, slot %i\n",
-				board(dev)->name,
-				pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+			dev->board_ptr = pcidas64_boards + i;
 			return pcidev;
 		}
 	}
-
-	printk("No supported ComputerBoards/MeasurementComputing card found\n");
+	dev_err(dev->class_dev,
+		"No supported board found! (req. bus %d, slot %d)\n",
+		bus, slot);
 	return NULL;
 }
 

commit eeff9dbc6f7513b88163253b782b7e5a4b087cdd
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jul 18 18:42:36 2012 -0700

    staging: comedi: cb_pcidas64: factor out the "find pci device" code
    
    Factor the "find pci device" code out of the attach function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 11ce3fdff195..704f5ea2e9cd 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1650,26 +1650,11 @@ static inline void warn_external_queue(struct comedi_device *dev)
 		     "Use internal AI channel queue (channels must be consecutive and use same range/aref)");
 }
 
-/*
- * Attach is called by the Comedi core to configure the driver
- * for a particular board.
- */
-static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static struct pci_dev *cb_pcidas64_find_pci_dev(struct comedi_device *dev,
+						struct comedi_devconfig *it)
 {
 	struct pci_dev *pcidev = NULL;
 	int index;
-	uint32_t local_range, local_decode;
-	int retval;
-
-/*
- * Allocate the private structure area.
- */
-	if (alloc_private(dev, sizeof(struct pcidas64_private)) < 0)
-		return -ENOMEM;
-
-/*
- * Probe the device to determine what device in the series it is.
- */
 
 	for_each_pci_dev(pcidev) {
 		/*  is it not a computer boards card? */
@@ -1687,22 +1672,38 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 					continue;
 				}
 			}
-			priv(dev)->hw_dev = pcidev;
 			dev->board_ptr = pcidas64_boards + index;
-			break;
+			dev_dbg(dev->class_dev, "Found %s on bus %i, slot %i\n",
+				board(dev)->name,
+				pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+			return pcidev;
 		}
-		if (dev->board_ptr)
-			break;
 	}
 
-	if (dev->board_ptr == NULL) {
-		printk
-		    ("No supported ComputerBoards/MeasurementComputing card found\n");
-		return -EIO;
-	}
+	printk("No supported ComputerBoards/MeasurementComputing card found\n");
+	return NULL;
+}
+
+/*
+ * Attach is called by the Comedi core to configure the driver
+ * for a particular board.
+ */
+static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
+{
+	struct pci_dev *pcidev;
+	uint32_t local_range, local_decode;
+	int retval;
 
-	dev_dbg(dev->class_dev, "Found %s on bus %i, slot %i\n",
-		board(dev)->name, pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+/*
+ * Allocate the private structure area.
+ */
+	if (alloc_private(dev, sizeof(struct pcidas64_private)) < 0)
+		return -ENOMEM;
+
+	pcidev = cb_pcidas64_find_pci_dev(dev, it);
+	if (!pcidev)
+		return -EIO;
+	priv(dev)->hw_dev = pcidev;
 
 	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
 		dev_warn(dev->class_dev,

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 7aacff3292c2..11ce3fdff195 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3617,7 +3617,7 @@ static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
 	data[1] = bits;
 	data[0] = 0;
 
-	return 2;
+	return insn->n;
 }
 
 static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -3633,7 +3633,7 @@ static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	data[1] = s->state;
 
-	return 2;
+	return insn->n;
 }
 
 static int dio_60xx_config_insn(struct comedi_device *dev,
@@ -3676,7 +3676,7 @@ static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	data[1] = readb(priv(dev)->dio_counter_iobase + DIO_DATA_60XX_REG);
 
-	return 2;
+	return insn->n;
 }
 
 static void caldac_write(struct comedi_device *dev, unsigned int channel,

commit f41ad6675f2d5705a0fc1e210af8eb4a27dbacb4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jun 18 14:05:34 2012 +0100

    staging: comedi: change device used in dev_...() calls
    
    A previous set of patches by Ravishankar Karkala Mallikarjunayya
    replaced a load of printk() calls with dev_info(), dev_err(), etc.
    Unfortunately, these used the 'struct device *hw_dev' member of 'struct
    comedi_device') as the first parameter of these dev_...() calls, but
    that pointer is usually NULL, so the kernel log messages come out a bit
    wrong (they contain the phrase "(NULL device *)").
    
    Use the 'struct device *class_dev' member of 'struct comedi_device'
    instead for these dev_...() calls.  It will be non-NULL and somewhat
    meaningful to users.  It's also consistent with those comedi drivers
    that already use the class_dev member in their dev_...() calls.
    
    Some of the messages included the format "comedi%d" with the minor
    device number used for the "%d".  This is now redundant as it will be
    the same as the dev_name() part of the kernel log message produced by
    the dev_...() calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 3aab75b5217d..7aacff3292c2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1701,11 +1701,12 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EIO;
 	}
 
-	dev_dbg(dev->hw_dev, "Found %s on bus %i, slot %i\n", board(dev)->name,
-		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+	dev_dbg(dev->class_dev, "Found %s on bus %i, slot %i\n",
+		board(dev)->name, pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
 	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
-		dev_warn(dev->hw_dev, "failed to enable PCI device and request regions\n");
+		dev_warn(dev->class_dev,
+			 "failed to enable PCI device and request regions\n");
 		return -EIO;
 	}
 	pci_set_master(pcidev);
@@ -1733,7 +1734,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	if (!priv(dev)->plx9080_iobase || !priv(dev)->main_iobase
 	    || !priv(dev)->dio_counter_iobase) {
-		dev_warn(dev->hw_dev, "failed to remap io memory\n");
+		dev_warn(dev->class_dev, "failed to remap io memory\n");
 		return -ENOMEM;
 	}
 
@@ -1769,19 +1770,19 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	priv(dev)->hw_revision =
 	    hw_revision(dev, readw(priv(dev)->main_iobase + HW_STATUS_REG));
-	dev_dbg(dev->hw_dev, "stc hardware revision %i\n",
+	dev_dbg(dev->class_dev, "stc hardware revision %i\n",
 		priv(dev)->hw_revision);
 	init_plx9080(dev);
 	init_stc_registers(dev);
 	/*  get irq */
 	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
 			"cb_pcidas64", dev)) {
-		dev_dbg(dev->hw_dev, "unable to allocate irq %u\n",
+		dev_dbg(dev->class_dev, "unable to allocate irq %u\n",
 			pcidev->irq);
 		return -EINVAL;
 	}
 	dev->irq = pcidev->irq;
-	dev_dbg(dev->hw_dev, "irq %u\n", dev->irq);
+	dev_dbg(dev->class_dev, "irq %u\n", dev->irq);
 
 	retval = setup_subdevices(dev);
 	if (retval < 0)
@@ -2002,7 +2003,7 @@ static int ai_config_calibration_source(struct comedi_device *dev,
 	else
 		num_calibration_sources = 8;
 	if (source >= num_calibration_sources) {
-		dev_dbg(dev->hw_dev, "invalid calibration source: %i\n",
+		dev_dbg(dev->class_dev, "invalid calibration source: %i\n",
 			source);
 		return -EINVAL;
 	}
@@ -2834,7 +2835,8 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 		}
 
 		if (num_samples < 0) {
-			dev_err(dev->hw_dev, "cb_pcidas64: bug! num_samples < 0\n");
+			dev_err(dev->class_dev,
+				"cb_pcidas64: bug! num_samples < 0\n");
 			break;
 		}
 

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 6b2f153980a9..3aab75b5217d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1344,9 +1344,11 @@ static int setup_subdevices(struct comedi_device *dev)
 	struct comedi_subdevice *s;
 	void __iomem *dio_8255_iobase;
 	int i;
+	int ret;
 
-	if (comedi_alloc_subdevices(dev, 10) < 0)
-		return -ENOMEM;
+	ret = comedi_alloc_subdevices(dev, 10);
+	if (ret)
+		return ret;
 
 	s = dev->subdevices + 0;
 	/* analog input subdevice */

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 5bcadcb00c99..6b2f153980a9 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1345,7 +1345,7 @@ static int setup_subdevices(struct comedi_device *dev)
 	void __iomem *dio_8255_iobase;
 	int i;
 
-	if (alloc_subdevices(dev, 10) < 0)
+	if (comedi_alloc_subdevices(dev, 10) < 0)
 		return -ENOMEM;
 
 	s = dev->subdevices + 0;

commit 856ff77e3307eb89ba68e7cc3c1fa91112efff89
Author: Dimitrios Semitsoglou-Tsiapos <dimitrios.semitsoglou@gmail.com>
Date:   Tue May 29 00:51:44 2012 +0300

    staging: comedi: cb_pcidas64: Fixed coding style errors
    
    Fixed a few coding style errors in cb_pcidas64.
    
    Signed-off-by: Dimitrios Semitsoglou-Tsiapos <dimitrios.semitsoglou@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 1e30f227e98e..5bcadcb00c99 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1152,7 +1152,7 @@ static int eeprom_read_insn(struct comedi_device *dev,
 static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd);
 static unsigned int get_divisor(unsigned int ns, unsigned int flags);
 static void i2c_write(struct comedi_device *dev, unsigned int address,
-		      const uint8_t * data, unsigned int length);
+		      const uint8_t *data, unsigned int length);
 static void caldac_write(struct comedi_device *dev, unsigned int channel,
 			 unsigned int value);
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
@@ -1229,7 +1229,7 @@ static unsigned int hw_revision(const struct comedi_device *dev,
 }
 
 static void set_dac_range_bits(struct comedi_device *dev,
-			       volatile uint16_t * bits, unsigned int channel,
+			       volatile uint16_t *bits, unsigned int channel,
 			       unsigned int range)
 {
 	unsigned int code = board(dev)->ao_range_code[range];
@@ -4190,7 +4190,7 @@ static void i2c_stop(struct comedi_device *dev)
 }
 
 static void i2c_write(struct comedi_device *dev, unsigned int address,
-		      const uint8_t * data, unsigned int length)
+		      const uint8_t *data, unsigned int length)
 {
 	unsigned int i;
 	uint8_t bitstream;

commit 55c03cff7fd73349473cc0a964df9d55b312dbbc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon May 21 17:12:12 2012 -0700

    staging: comedi: remove private header comedi_pci.h
    
    Remove the private header, comedi_pci.h, by moving the two
    helper functions into divers.c and providing the prototypes
    in comedidev.h.
    
    This allows the comedi_pci_enable/disable helper functions
    to be shared instead of having an inline version in every
    comedi pci driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 9d0b8754ff5b..1e30f227e98e 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -87,7 +87,6 @@ known. If you have such a board, please file a bug report at
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 
-#include "comedi_pci.h"
 #include "8253.h"
 #include "8255.h"
 #include "plx9080.h"

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index bea5120efd85..9d0b8754ff5b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1790,15 +1790,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 0;
 }
 
-/*
- * _detach is called to deconfigure a device.  It should deallocate
- * resources.
- * This function is also called when _attach() fails, so it should be
- * careful not to release resources that were not necessarily
- * allocated by _attach().  dev->private and dev->subdevices are
- * deallocated automatically by the core.
- */
-static int detach(struct comedi_device *dev)
+static void detach(struct comedi_device *dev)
 {
 	unsigned int i;
 
@@ -1860,8 +1852,6 @@ static int detach(struct comedi_device *dev)
 	}
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, dev->subdevices + 4);
-
-	return 0;
 }
 
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,

commit bdc7cc500aee9b29117a1249e6ad709c75223222
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 15 14:32:21 2012 -0700

    staging: comedi: refactor cb_pcidas64 driver and use module_comedi_pci_driver
    
    Move the module_init/module_exit routines and the associated
    struct comedi_drive and struct pci_driver to the end of the
    source. This is more typical of how other drivers are written
    and removes the need for the forward declarations.
    
    Convert the driver to use the module_comedi_pci_driver() macro
    which makes the code smaller and a bit simpler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index ff79fd4259f0..bea5120efd85 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1026,31 +1026,6 @@ static const struct pcidas64_board pcidas64_boards[] = {
 #endif
 };
 
-static DEFINE_PCI_DEVICE_TABLE(pcidas64_pci_table) = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x001d) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x001e) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0035) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0036) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0037) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0052) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x005d) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x005e) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x005f) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0061) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0062) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0063) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0064) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0066) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0067) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0068) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x006f) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0078) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0079) },
-	{ 0 }
-};
-
-MODULE_DEVICE_TABLE(pci, pcidas64_pci_table);
-
 static inline struct pcidas64_board *board(const struct comedi_device *dev)
 {
 	return (struct pcidas64_board *)dev->board_ptr;
@@ -1127,21 +1102,6 @@ static inline struct pcidas64_private *priv(struct comedi_device *dev)
 	return dev->private;
 }
 
-/*
- * The comedi_driver structure tells the Comedi core module
- * which functions to call to configure/deconfigure (attach/detach)
- * the board, and also about the kernel module that contains
- * the device code.
- */
-static int attach(struct comedi_device *dev, struct comedi_devconfig *it);
-static int detach(struct comedi_device *dev);
-static struct comedi_driver driver_cb_pcidas = {
-	.driver_name = "cb_pcidas64",
-	.module = THIS_MODULE,
-	.attach = attach,
-	.detach = detach,
-};
-
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data);
 static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -1216,44 +1176,6 @@ static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags);
 static void load_ao_dma(struct comedi_device *dev,
 			const struct comedi_cmd *cmd);
 
-static int __devinit driver_cb_pcidas_pci_probe(struct pci_dev *dev,
-						const struct pci_device_id *ent)
-{
-	return comedi_pci_auto_config(dev, &driver_cb_pcidas);
-}
-
-static void __devexit driver_cb_pcidas_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
-static struct pci_driver driver_cb_pcidas_pci_driver = {
-	.id_table = pcidas64_pci_table,
-	.probe = &driver_cb_pcidas_pci_probe,
-	.remove = __devexit_p(&driver_cb_pcidas_pci_remove)
-};
-
-static int __init driver_cb_pcidas_init_module(void)
-{
-	int retval;
-
-	retval = comedi_driver_register(&driver_cb_pcidas);
-	if (retval < 0)
-		return retval;
-
-	driver_cb_pcidas_pci_driver.name = (char *)driver_cb_pcidas.driver_name;
-	return pci_register_driver(&driver_cb_pcidas_pci_driver);
-}
-
-static void __exit driver_cb_pcidas_cleanup_module(void)
-{
-	pci_unregister_driver(&driver_cb_pcidas_pci_driver);
-	comedi_driver_unregister(&driver_cb_pcidas);
-}
-
-module_init(driver_cb_pcidas_init_module);
-module_exit(driver_cb_pcidas_cleanup_module);
-
 static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 				       unsigned int range_index)
 {
@@ -1781,7 +1703,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev_dbg(dev->hw_dev, "Found %s on bus %i, slot %i\n", board(dev)->name,
 		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
-	if (comedi_pci_enable(pcidev, driver_cb_pcidas.driver_name)) {
+	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
 		dev_warn(dev->hw_dev, "failed to enable PCI device and request regions\n");
 		return -EIO;
 	}
@@ -4315,6 +4237,56 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 	i2c_stop(dev);
 }
 
+static struct comedi_driver cb_pcidas64_driver = {
+	.driver_name	= "cb_pcidas64",
+	.module		= THIS_MODULE,
+	.attach		= attach,
+	.detach		= detach,
+};
+
+static int __devinit cb_pcidas64_pci_probe(struct pci_dev *dev,
+					   const struct pci_device_id *ent)
+{
+	return comedi_pci_auto_config(dev, &cb_pcidas64_driver);
+}
+
+static void __devexit cb_pcidas64_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static DEFINE_PCI_DEVICE_TABLE(cb_pcidas64_pci_table) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x001d) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x001e) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0035) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0036) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0037) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0052) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x005d) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x005e) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x005f) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0061) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0062) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0063) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0064) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0066) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0067) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0068) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x006f) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0078) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0079) },
+	{ 0 }
+};
+MODULE_DEVICE_TABLE(pci, cb_pcidas64_pci_table);
+
+static struct pci_driver cb_pcidas64_pci_driver = {
+	.name		= "cb_pcidas64",
+	.id_table	= cb_pcidas64_pci_table,
+	.probe		= cb_pcidas64_pci_probe,
+	.remove		= __devexit_p(cb_pcidas64_pci_remove),
+};
+module_comedi_pci_driver(cb_pcidas64_driver, cb_pcidas64_pci_driver);
+
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");
 MODULE_LICENSE("GPL");

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 915157d47805..ff79fd4259f0 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1219,7 +1219,7 @@ static void load_ao_dma(struct comedi_device *dev,
 static int __devinit driver_cb_pcidas_pci_probe(struct pci_dev *dev,
 						const struct pci_device_id *ent)
 {
-	return comedi_pci_auto_config(dev, driver_cb_pcidas.driver_name);
+	return comedi_pci_auto_config(dev, &driver_cb_pcidas);
 }
 
 static void __devexit driver_cb_pcidas_pci_remove(struct pci_dev *dev)

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index c9e8c4785768..915157d47805 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -86,7 +86,6 @@ known. If you have such a board, please file a bug report at
 #include "../comedidev.h"
 #include <linux/delay.h>
 #include <linux/interrupt.h>
-#include <asm/system.h>
 
 #include "comedi_pci.h"
 #include "8253.h"

commit 6c6c227d2a4cb6d7b8c925d2e9e0333cbfd4cf27
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Dec 12 10:49:36 2011 +0530

    Staging: comedi: fix printk issue in cb_pcidas64.c
    
    This is a patch to the cb_pcidas64.c file that fixes up a
    printk warning found by the checkpatch.pl tool.
    
    Converted printks to dev_<levels> and Removed unnecessary
    printk statements.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index b68c5874b2e5..c9e8c4785768 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1881,8 +1881,6 @@ static int detach(struct comedi_device *dev)
 {
 	unsigned int i;
 
-	printk("comedi%d: cb_pcidas: remove\n", dev->minor);
-
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (priv(dev)) {
@@ -2092,7 +2090,8 @@ static int ai_config_calibration_source(struct comedi_device *dev,
 	else
 		num_calibration_sources = 8;
 	if (source >= num_calibration_sources) {
-		printk("invalid calibration source: %i\n", source);
+		dev_dbg(dev->hw_dev, "invalid calibration source: %i\n",
+			source);
 		return -EINVAL;
 	}
 
@@ -2923,7 +2922,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 		}
 
 		if (num_samples < 0) {
-			printk(" cb_pcidas64: bug! num_samples < 0\n");
+			dev_err(dev->hw_dev, "cb_pcidas64: bug! num_samples < 0\n");
 			break;
 		}
 

commit d78678dad325b40258b8d38cf90b24e66d1e52e8
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Dec 12 10:49:35 2011 +0530

    Staging: comedi: fix printk issue in cb_pcidas64.c
    
    This is a patch to the cb_pcidas64.c file that fixes up a
    printk warning found by the checkpatch.pl tool.
    
    Converted printks to dev_<levels> and Removed unnecessary
    printk statements.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 1e324198996c..b68c5874b2e5 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1739,8 +1739,6 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	uint32_t local_range, local_decode;
 	int retval;
 
-	printk("comedi%d: cb_pcidas64\n", dev->minor);
-
 /*
  * Allocate the private structure area.
  */
@@ -1781,12 +1779,11 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EIO;
 	}
 
-	printk("Found %s on bus %i, slot %i\n", board(dev)->name,
-	       pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+	dev_dbg(dev->hw_dev, "Found %s on bus %i, slot %i\n", board(dev)->name,
+		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
 	if (comedi_pci_enable(pcidev, driver_cb_pcidas.driver_name)) {
-		printk(KERN_WARNING
-		       " failed to enable PCI device and request regions\n");
+		dev_warn(dev->hw_dev, "failed to enable PCI device and request regions\n");
 		return -EIO;
 	}
 	pci_set_master(pcidev);
@@ -1814,7 +1811,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	if (!priv(dev)->plx9080_iobase || !priv(dev)->main_iobase
 	    || !priv(dev)->dio_counter_iobase) {
-		printk(" failed to remap io memory\n");
+		dev_warn(dev->hw_dev, "failed to remap io memory\n");
 		return -ENOMEM;
 	}
 
@@ -1850,17 +1847,19 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	priv(dev)->hw_revision =
 	    hw_revision(dev, readw(priv(dev)->main_iobase + HW_STATUS_REG));
-	printk(" stc hardware revision %i\n", priv(dev)->hw_revision);
+	dev_dbg(dev->hw_dev, "stc hardware revision %i\n",
+		priv(dev)->hw_revision);
 	init_plx9080(dev);
 	init_stc_registers(dev);
 	/*  get irq */
 	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
 			"cb_pcidas64", dev)) {
-		printk(" unable to allocate irq %u\n", pcidev->irq);
+		dev_dbg(dev->hw_dev, "unable to allocate irq %u\n",
+			pcidev->irq);
 		return -EINVAL;
 	}
 	dev->irq = pcidev->irq;
-	printk(" irq %u\n", dev->irq);
+	dev_dbg(dev->hw_dev, "irq %u\n", dev->irq);
 
 	retval = setup_subdevices(dev);
 	if (retval < 0)

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 2583e16cd02a..1e324198996c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -104,7 +104,7 @@ known. If you have such a board, please file a bug report at
 #endif
 
 #define TIMER_BASE 25		/*  40MHz master clock */
-#define PRESCALED_TIMER_BASE	10000	/*  100kHz 'prescaled' clock for slow aquisition, maybe I'll support this someday */
+#define PRESCALED_TIMER_BASE	10000	/*  100kHz 'prescaled' clock for slow acquisition, maybe I'll support this someday */
 #define DMA_BUFFER_SIZE 0x1000
 
 #define PCI_VENDOR_ID_COMPUTERBOARDS	0x1307
@@ -136,7 +136,7 @@ enum write_only_registers {
 	ADC_DELAY_INTERVAL_UPPER_REG = 0x1c,	/*  upper 8 bits of delay interval counter */
 	ADC_COUNT_LOWER_REG = 0x1e,	/*  lower 16 bits of hardware conversion/scan counter */
 	ADC_COUNT_UPPER_REG = 0x20,	/*  upper 8 bits of hardware conversion/scan counter */
-	ADC_START_REG = 0x22,	/*  software trigger to start aquisition */
+	ADC_START_REG = 0x22,	/*  software trigger to start acquisition */
 	ADC_CONVERT_REG = 0x24,	/*  initiates single conversion */
 	ADC_QUEUE_CLEAR_REG = 0x26,	/*  clears adc queue */
 	ADC_QUEUE_LOAD_REG = 0x28,	/*  loads adc queue */
@@ -199,7 +199,7 @@ enum intr_enable_contents {
 	ADC_INTR_EOSCAN_BITS = 0x2,	/*  interrupt end of scan */
 	ADC_INTR_EOSEQ_BITS = 0x3,	/*  interrupt end of sequence (probably wont use this it's pretty fancy) */
 	EN_ADC_INTR_SRC_BIT = 0x4,	/*  enable adc interrupt source */
-	EN_ADC_DONE_INTR_BIT = 0x8,	/*  enable adc aquisition done interrupt */
+	EN_ADC_DONE_INTR_BIT = 0x8,	/*  enable adc acquisition done interrupt */
 	DAC_INTR_SRC_MASK = 0x30,
 	DAC_INTR_QEMPTY_BITS = 0x0,
 	DAC_INTR_HIGH_CHAN_BITS = 0x10,
@@ -2867,7 +2867,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  start aquisition */
+	/*  start acquisition */
 	if (cmd->start_src == TRIG_NOW) {
 		writew(0, priv(dev)->main_iobase + ADC_START_REG);
 		DEBUG_PRINT("soft trig\n");
@@ -2942,7 +2942,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 /* Read from 32 bit wide ai fifo of 4020 - deal with insane grey coding of pointers.
  * The pci-4020 hardware only supports
  * dma transfers (it only supports the use of pio for draining the last remaining
- * points from the fifo when a data aquisition operation has completed).
+ * points from the fifo when a data acquisition operation has completed).
  */
 static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 {
@@ -3046,7 +3046,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 		comedi_error(dev, "fifo overrun");
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
-	/*  spin lock makes sure noone else changes plx dma control reg */
+	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 	if (plx_status & ICS_DMA1_A) {	/*  dma chan 1 interrupt */
@@ -3170,7 +3170,7 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 	async = s->async;
 	cmd = &async->cmd;
 
-	/*  spin lock makes sure noone else changes plx dma control reg */
+	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */

commit 2503a26554c7e73c544fc97f47c1d41faa88bd07
Author: Vasiliy Kulikov <segooon@gmail.com>
Date:   Sun Sep 12 22:56:35 2010 +0400

    staging: comedi: fix signess bug
    
    ai_count and ao_counter are unsigned, check for < 0 doesn't make sense.
    Cast them to int.
    
    Signed-off-by: Vasiliy Kulikov <segooon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 9b1dd3cc2120..2583e16cd02a 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -3078,7 +3078,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 			spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 	/*  if we are have all the data, then quit */
-	if ((cmd->stop_src == TRIG_COUNT && priv(dev)->ai_count <= 0) ||
+	if ((cmd->stop_src == TRIG_COUNT && (int)priv(dev)->ai_count <= 0) ||
 	    (cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT))) {
 		async->events |= COMEDI_CB_EOA;
 	}

commit 7feb75ac052d6c6df6b28ea7dcd7b9ab50b76586
Author: Javier Martinez Canillas <martinez.javier@gmail.com>
Date:   Sat Aug 7 02:42:55 2010 -0400

    staging: comedi (cb_pcidas64): use PCI_DEVICE() macro
    
    Use PCI_DEVICE() macro for pci table entries on comedi driver and thus improves readability.
    
    Signed-off-by: Javier Martinez Canillas <martinez.javier@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 53e7015869fc..9b1dd3cc2120 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1028,46 +1028,26 @@ static const struct pcidas64_board pcidas64_boards[] = {
 };
 
 static DEFINE_PCI_DEVICE_TABLE(pcidas64_pci_table) = {
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x001d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x001e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0035, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0036, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0037, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0052, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x005d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x005e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x005f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0061, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0062, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0063, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0064, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0066, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0067, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0068, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x006f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0078, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0079, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{
-	0}
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x001d) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x001e) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0035) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0036) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0037) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0052) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x005d) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x005e) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x005f) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0061) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0062) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0063) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0064) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0066) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0067) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0068) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x006f) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0078) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTERBOARDS, 0x0079) },
+	{ 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, pcidas64_pci_table);

commit 20fb2280815510533cbd7785b53821ca7209345b
Author: Kulikov Vasiliy <segooon@gmail.com>
Date:   Sat Jul 3 19:20:47 2010 +0400

    Staging: comedi: use for_each_pci_dev()
    
    Use for_each_pci_dev() to simplify the code.
    
    Signed-off-by: Kulikov Vasiliy <segooon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index ba7c48ab6d92..53e7015869fc 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1754,7 +1754,7 @@ static inline void warn_external_queue(struct comedi_device *dev)
  */
 static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	struct pci_dev *pcidev;
+	struct pci_dev *pcidev = NULL;
 	int index;
 	uint32_t local_range, local_decode;
 	int retval;
@@ -1771,9 +1771,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
  * Probe the device to determine what device in the series it is.
  */
 
-	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-	     pcidev != NULL;
-	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	for_each_pci_dev(pcidev) {
 		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
 			continue;

commit 727b286b44ea359d66f47d241cc2cdad36ed7bdc
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:31 2010 +0200

    Staging: comedi: Remove COMEDI_PCI_INITCLEANUP macro
    
    Move the PCI devinit/devexit routines to the respective C source files
    instead of calling COMEDI_PCI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 168a33511648..ba7c48ab6d92 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1237,7 +1237,43 @@ static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags);
 static void load_ao_dma(struct comedi_device *dev,
 			const struct comedi_cmd *cmd);
 
-COMEDI_PCI_INITCLEANUP(driver_cb_pcidas, pcidas64_pci_table);
+static int __devinit driver_cb_pcidas_pci_probe(struct pci_dev *dev,
+						const struct pci_device_id *ent)
+{
+	return comedi_pci_auto_config(dev, driver_cb_pcidas.driver_name);
+}
+
+static void __devexit driver_cb_pcidas_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static struct pci_driver driver_cb_pcidas_pci_driver = {
+	.id_table = pcidas64_pci_table,
+	.probe = &driver_cb_pcidas_pci_probe,
+	.remove = __devexit_p(&driver_cb_pcidas_pci_remove)
+};
+
+static int __init driver_cb_pcidas_init_module(void)
+{
+	int retval;
+
+	retval = comedi_driver_register(&driver_cb_pcidas);
+	if (retval < 0)
+		return retval;
+
+	driver_cb_pcidas_pci_driver.name = (char *)driver_cb_pcidas.driver_name;
+	return pci_register_driver(&driver_cb_pcidas_pci_driver);
+}
+
+static void __exit driver_cb_pcidas_cleanup_module(void)
+{
+	pci_unregister_driver(&driver_cb_pcidas_pci_driver);
+	comedi_driver_unregister(&driver_cb_pcidas);
+}
+
+module_init(driver_cb_pcidas_init_module);
+module_exit(driver_cb_pcidas_cleanup_module);
 
 static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 				       unsigned int range_index)

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 79aa286e9bb4..168a33511648 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -4303,3 +4303,7 @@ static void i2c_write(struct comedi_device *dev, unsigned int address,
 	}
 	i2c_stop(dev);
 }
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 318a5b2a505fe7a99f0d89889e7a84d57ec49b15
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 5 09:12:13 2010 -0700

    Staging: comedi: cb_pcidas64: fix up build warnings
    
    Now that the 8255.h file is being included properly, we were
    using the incorrect function prototypes, which causes a build
    warning now.  This fixes it up and preserves the __iomem markings that
    sparse wants to see.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 3443fc1b9186..79aa286e9bb4 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1183,8 +1183,8 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 static irqreturn_t handle_interrupt(int irq, void *d);
 static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static int dio_callback(int dir, int port, int data, void __iomem *base);
-static int dio_callback_4020(int dir, int port, int data, void __iomem *base);
+static int dio_callback(int dir, int port, int data, unsigned long arg);
+static int dio_callback_4020(int dir, int port, int data, unsigned long arg);
 static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data);
 static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -3658,8 +3658,9 @@ static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int dio_callback(int dir, int port, int data, void __iomem *iobase)
+static int dio_callback(int dir, int port, int data, unsigned long arg)
 {
+	void __iomem *iobase = (void __iomem *)arg;
 	if (dir) {
 		writeb(data, iobase + port);
 		DEBUG_PRINT("wrote 0x%x to port %i\n", data, port);
@@ -3669,8 +3670,9 @@ static int dio_callback(int dir, int port, int data, void __iomem *iobase)
 	}
 }
 
-static int dio_callback_4020(int dir, int port, int data, void __iomem *iobase)
+static int dio_callback_4020(int dir, int port, int data, unsigned long arg)
 {
+	void __iomem *iobase = (void __iomem *)arg;
 	if (dir) {
 		writew(data, iobase + 2 * port);
 		return 0;

commit f31d0008cef0df52d1a2662ef56a24bdd88b0105
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue May 4 16:07:03 2010 -0700

    Staging: comedi: cb_pcidas64.c: fix sparse warnings
    
    This fixes a bunch of iomem and other sparse warnings.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 0d9e92e59f9d..3443fc1b9186 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1101,9 +1101,9 @@ struct pcidas64_private {
 	resource_size_t main_phys_iobase;
 	resource_size_t dio_counter_phys_iobase;
 	/*  base addresses (ioremapped) */
-	void *plx9080_iobase;
-	void *main_iobase;
-	void *dio_counter_iobase;
+	void __iomem *plx9080_iobase;
+	void __iomem *main_iobase;
+	void __iomem *dio_counter_iobase;
 	/*  local address (used by dma controller) */
 	uint32_t local0_iobase;
 	uint32_t local1_iobase;
@@ -1183,8 +1183,8 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 static irqreturn_t handle_interrupt(int irq, void *d);
 static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static int dio_callback(int dir, int port, int data, unsigned long arg);
-static int dio_callback_4020(int dir, int port, int data, unsigned long arg);
+static int dio_callback(int dir, int port, int data, void __iomem *base);
+static int dio_callback_4020(int dir, int port, int data, void __iomem *base);
 static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data);
 static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -1316,7 +1316,7 @@ static inline int ao_cmd_is_supported(const struct pcidas64_board *board)
 static void init_plx9080(struct comedi_device *dev)
 {
 	uint32_t bits;
-	void *plx_iobase = priv(dev)->plx9080_iobase;
+	void __iomem *plx_iobase = priv(dev)->plx9080_iobase;
 
 	priv(dev)->plx_control_bits =
 	    readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG);
@@ -1406,7 +1406,7 @@ static void init_plx9080(struct comedi_device *dev)
 static int setup_subdevices(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s;
-	void *dio_8255_iobase;
+	void __iomem *dio_8255_iobase;
 	int i;
 
 	if (alloc_subdevices(dev, 10) < 0)
@@ -1432,7 +1432,6 @@ static int setup_subdevices(struct comedi_device *dev)
 	s->do_cmdtest = ai_cmdtest;
 	s->cancel = ai_cancel;
 	if (board(dev)->layout == LAYOUT_4020) {
-		unsigned int i;
 		uint8_t data;
 		/*  set adc to read from inputs (not internal calibration sources) */
 		priv(dev)->i2c_cal_range_bits = adc_src_4020_bits(4);
@@ -1614,7 +1613,7 @@ static void init_stc_registers(struct comedi_device *dev)
 	disable_ai_pacing(dev);
 };
 
-int alloc_and_init_dma_members(struct comedi_device *dev)
+static int alloc_and_init_dma_members(struct comedi_device *dev)
 {
 	int i;
 
@@ -1877,12 +1876,12 @@ static int detach(struct comedi_device *dev)
 		if (priv(dev)->hw_dev) {
 			if (priv(dev)->plx9080_iobase) {
 				disable_plx_interrupts(dev);
-				iounmap((void *)priv(dev)->plx9080_iobase);
+				iounmap(priv(dev)->plx9080_iobase);
 			}
 			if (priv(dev)->main_iobase)
-				iounmap((void *)priv(dev)->main_iobase);
+				iounmap(priv(dev)->main_iobase);
 			if (priv(dev)->dio_counter_iobase)
-				iounmap((void *)priv(dev)->dio_counter_iobase);
+				iounmap(priv(dev)->dio_counter_iobase);
 			/*  free pci dma buffers */
 			for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 				if (priv(dev)->ai_buffer[i])
@@ -2978,7 +2977,7 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 	uint32_t next_transfer_addr;
 	int j;
 	int num_samples = 0;
-	void *pci_addr_reg;
+	void __iomem *pci_addr_reg;
 
 	if (channel)
 		pci_addr_reg =
@@ -3018,8 +3017,9 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 	 * unused buffer) */
 }
 
-void handle_ai_interrupt(struct comedi_device *dev, unsigned short status,
-			 unsigned int plx_status)
+static void handle_ai_interrupt(struct comedi_device *dev,
+				unsigned short status,
+				unsigned int plx_status)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
@@ -3229,7 +3229,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-void abort_dma(struct comedi_device *dev, unsigned int channel)
+static void abort_dma(struct comedi_device *dev, unsigned int channel)
 {
 	unsigned long flags;
 
@@ -3424,7 +3424,7 @@ static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	unsigned int num_bytes;
 	unsigned int next_transfer_addr;
-	void *pci_addr_reg =
+	void __iomem *pci_addr_reg =
 	    priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 	unsigned int buffer_index;
 
@@ -3658,24 +3658,24 @@ static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int dio_callback(int dir, int port, int data, unsigned long iobase)
+static int dio_callback(int dir, int port, int data, void __iomem *iobase)
 {
 	if (dir) {
-		writeb(data, (void *)(iobase + port));
+		writeb(data, iobase + port);
 		DEBUG_PRINT("wrote 0x%x to port %i\n", data, port);
 		return 0;
 	} else {
-		return readb((void *)(iobase + port));
+		return readb(iobase + port);
 	}
 }
 
-static int dio_callback_4020(int dir, int port, int data, unsigned long iobase)
+static int dio_callback_4020(int dir, int port, int data, void __iomem *iobase)
 {
 	if (dir) {
-		writew(data, (void *)(iobase + 2 * port));
+		writew(data, iobase + 2 * port);
 		return 0;
 	} else {
-		return readw((void *)(iobase + 2 * port));
+		return readw(iobase + 2 * port);
 	}
 }
 
@@ -3862,7 +3862,7 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 	static const int read_command = 0x6;
 	unsigned int bitstream = (read_command << 8) | address;
 	unsigned int bit;
-	void *const plx_control_addr =
+	void __iomem * const plx_control_addr =
 	    priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
 	uint16_t value;
 	static const int value_length = 16;
@@ -4185,7 +4185,8 @@ static const int i2c_low_udelay = 10;
 static void i2c_set_sda(struct comedi_device *dev, int state)
 {
 	static const int data_bit = CTL_EE_W;
-	void *plx_control_addr = priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
+	void __iomem *plx_control_addr = priv(dev)->plx9080_iobase +
+					 PLX_CONTROL_REG;
 
 	if (state) {
 		/*  set data line high */
@@ -4204,7 +4205,8 @@ static void i2c_set_sda(struct comedi_device *dev, int state)
 static void i2c_set_scl(struct comedi_device *dev, int state)
 {
 	static const int clock_bit = CTL_USERO;
-	void *plx_control_addr = priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
+	void __iomem *plx_control_addr = priv(dev)->plx9080_iobase +
+					 PLX_CONTROL_REG;
 
 	if (state) {
 		/*  set clock line high */

commit 558587e2d96a4f5439a609509e4ea88f7536203b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 30 17:23:51 2010 -0700

    Staging: comedi: move another pci device id to the driver
    
    Put a pci vendor id into the drivers that need them.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index f17cb09acb28..0d9e92e59f9d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -107,6 +107,8 @@ known. If you have such a board, please file a bug report at
 #define PRESCALED_TIMER_BASE	10000	/*  100kHz 'prescaled' clock for slow aquisition, maybe I'll support this someday */
 #define DMA_BUFFER_SIZE 0x1000
 
+#define PCI_VENDOR_ID_COMPUTERBOARDS	0x1307
+
 /* maximum value that can be loaded into board's 24-bit counters*/
 static const int max_counter_value = 0xffffff;
 

commit 003b3e9408425b6bd0b807108ee4cff5498125d3
Author: Jason Wong <tsanghan@gmail.com>
Date:   Sat Mar 27 09:48:43 2010 +0800

    Staging: comedi: cb_pcidas64: fixed a coding style missed in the previous patch
    
    Fixed a coding style issue.
    
    Signed-off-by: Jason Wong <tsanghan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 1d43d0d6f07d..f17cb09acb28 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1921,7 +1921,7 @@ static int detach(struct comedi_device *dev)
 						    ao_dma_desc_bus_addr);
 			if (priv(dev)->main_phys_iobase)
 				comedi_pci_disable(priv(dev)->hw_dev);
-	
+
 			pci_dev_put(priv(dev)->hw_dev);
 		}
 	}

commit 90cae7944011b7a09b2d248e85ee11e987cc25f8
Author: Jason Wong <tsanghan@gmail.com>
Date:   Sat Mar 27 09:48:42 2010 +0800

    Staging: comedi: cb_pcidas64: fixed multiple brace coding style issues
    
    Fixed multiple coding style issues.
    
    Signed-off-by: Jason Wong <tsanghan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 82295e0f07f9..1d43d0d6f07d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1621,9 +1621,9 @@ int alloc_and_init_dma_members(struct comedi_device *dev)
 		priv(dev)->ai_buffer[i] =
 		    pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
 					 &priv(dev)->ai_buffer_bus_addr[i]);
-		if (priv(dev)->ai_buffer[i] == NULL) {
+		if (priv(dev)->ai_buffer[i] == NULL)
 			return -ENOMEM;
-		}
+
 	}
 	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 		if (ao_cmd_is_supported(board(dev))) {
@@ -1632,9 +1632,9 @@ int alloc_and_init_dma_members(struct comedi_device *dev)
 						 DMA_BUFFER_SIZE,
 						 &priv(dev)->
 						 ao_buffer_bus_addr[i]);
-			if (priv(dev)->ao_buffer[i] == NULL) {
+			if (priv(dev)->ao_buffer[i] == NULL)
 				return -ENOMEM;
-			}
+
 		}
 	}
 	/*  allocate dma descriptors */
@@ -1643,9 +1643,9 @@ int alloc_and_init_dma_members(struct comedi_device *dev)
 				 sizeof(struct plx_dma_desc) *
 				 ai_dma_ring_count(board(dev)),
 				 &priv(dev)->ai_dma_desc_bus_addr);
-	if (priv(dev)->ai_dma_desc == NULL) {
+	if (priv(dev)->ai_dma_desc == NULL)
 		return -ENOMEM;
-	}
+
 	DEBUG_PRINT("ai dma descriptors start at bus addr 0x%x\n",
 		    priv(dev)->ai_dma_desc_bus_addr);
 	if (ao_cmd_is_supported(board(dev))) {
@@ -1654,9 +1654,9 @@ int alloc_and_init_dma_members(struct comedi_device *dev)
 					 sizeof(struct plx_dma_desc) *
 					 AO_DMA_RING_COUNT,
 					 &priv(dev)->ao_dma_desc_bus_addr);
-		if (priv(dev)->ao_dma_desc == NULL) {
+		if (priv(dev)->ao_dma_desc == NULL)
 			return -ENOMEM;
-		}
+
 		DEBUG_PRINT("ao dma descriptors start at bus addr 0x%x\n",
 			    priv(dev)->ao_dma_desc_bus_addr);
 	}
@@ -1848,9 +1848,9 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	printk(" irq %u\n", dev->irq);
 
 	retval = setup_subdevices(dev);
-	if (retval < 0) {
+	if (retval < 0)
 		return retval;
-	}
+
 
 	return 0;
 }
@@ -1919,9 +1919,9 @@ static int detach(struct comedi_device *dev)
 						    priv(dev)->ao_dma_desc,
 						    priv(dev)->
 						    ao_dma_desc_bus_addr);
-			if (priv(dev)->main_phys_iobase) {
+			if (priv(dev)->main_phys_iobase)
 				comedi_pci_disable(priv(dev)->hw_dev);
-			}
+	
 			pci_dev_put(priv(dev)->hw_dev);
 		}
 	}
@@ -2902,9 +2902,9 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 		if (cmd->stop_src == TRIG_COUNT) {
 			if (priv(dev)->ai_count == 0)
 				break;
-			if (num_samples > priv(dev)->ai_count) {
+			if (num_samples > priv(dev)->ai_count)
 				num_samples = priv(dev)->ai_count;
-			}
+
 			priv(dev)->ai_count -= num_samples;
 		}
 
@@ -2943,9 +2943,9 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 	    readw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		if (max_transfer > priv(dev)->ai_count) {
+		if (max_transfer > priv(dev)->ai_count)
 			max_transfer = priv(dev)->ai_count;
-		}
+
 	}
 	for (i = 0; read_code != write_code && i < max_transfer;) {
 		fifo_data = readl(priv(dev)->dio_counter_iobase + ADC_FIFO_REG);
@@ -2964,9 +2964,9 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 /* empty fifo */
 static void pio_drain_ai_fifo(struct comedi_device *dev)
 {
-	if (board(dev)->layout == LAYOUT_4020) {
+	if (board(dev)->layout == LAYOUT_4020)
 		pio_drain_ai_fifo_32(dev);
-	} else
+	else
 		pio_drain_ai_fifo_16(dev);
 }
 
@@ -3038,9 +3038,9 @@ void handle_ai_interrupt(struct comedi_device *dev, unsigned short status,
 		       priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
 
-		if (dma1_status & PLX_DMA_EN_BIT) {
+		if (dma1_status & PLX_DMA_EN_BIT)
 			drain_dma_buffers(dev, 1);
-		}
+
 		DEBUG_PRINT(" cleared dma ch1 interrupt\n");
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 210b462868b7..82295e0f07f9 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -152,10 +152,12 @@ static inline unsigned int dac_convert_reg(unsigned int channel)
 {
 	return 0x70 + (2 * (channel & 0x1));
 }
+
 static inline unsigned int dac_lsb_4020_reg(unsigned int channel)
 {
 	return 0x70 + (4 * (channel & 0x1));
 }
+
 static inline unsigned int dac_msb_4020_reg(unsigned int channel)
 {
 	return 0x72 + (4 * (channel & 0x1));
@@ -269,10 +271,12 @@ static inline uint16_t adc_lo_chan_4020_bits(unsigned int channel)
 {
 	return (channel & 0x3) << 8;
 };
+
 static inline uint16_t adc_hi_chan_4020_bits(unsigned int channel)
 {
 	return (channel & 0x3) << 10;
 };
+
 static inline uint16_t adc_mode_bits(unsigned int mode)
 {
 	return (mode & 0xf) << 12;
@@ -370,10 +374,12 @@ static inline unsigned int dma_chain_flag_bits(uint16_t prepost_bits)
 {
 	return (prepost_bits >> 6) & 0x3;
 }
+
 static inline unsigned int adc_upper_read_ptr_code(uint16_t prepost_bits)
 {
 	return (prepost_bits >> 12) & 0x3;
 }
+
 static inline unsigned int adc_upper_write_ptr_code(uint16_t prepost_bits)
 {
 	return (prepost_bits >> 14) & 0x3;
@@ -394,6 +400,7 @@ static inline uint8_t adc_src_4020_bits(unsigned int source)
 {
 	return (source << 4) & ADC_SRC_4020_MASK;
 };
+
 static inline uint8_t attenuate_bit(unsigned int channel)
 {
 	/*  attenuate channel (+-5V input range) */
@@ -404,90 +411,91 @@ static inline uint8_t attenuate_bit(unsigned int channel)
 static const struct comedi_lrange ai_ranges_64xx = {
 	8,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25)
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1.25),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2.5),
+	 UNI_RANGE(1.25)
+	 }
 };
 
 /* analog input ranges for 60xx boards */
 static const struct comedi_lrange ai_ranges_60xx = {
 	4,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.05),
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(0.5),
+	 BIP_RANGE(0.05),
+	 }
 };
 
 /* analog input ranges for 6030, etc boards */
 static const struct comedi_lrange ai_ranges_6030 = {
 	14,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2),
-			BIP_RANGE(1),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.2),
-			BIP_RANGE(0.1),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2),
-			UNI_RANGE(1),
-			UNI_RANGE(0.5),
-			UNI_RANGE(0.2),
-			UNI_RANGE(0.1),
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2),
+	 BIP_RANGE(1),
+	 BIP_RANGE(0.5),
+	 BIP_RANGE(0.2),
+	 BIP_RANGE(0.1),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2),
+	 UNI_RANGE(1),
+	 UNI_RANGE(0.5),
+	 UNI_RANGE(0.2),
+	 UNI_RANGE(0.1),
+	 }
 };
 
 /* analog input ranges for 6052, etc boards */
 static const struct comedi_lrange ai_ranges_6052 = {
 	15,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.25),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.05),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2),
-			UNI_RANGE(1),
-			UNI_RANGE(0.5),
-			UNI_RANGE(0.2),
-			UNI_RANGE(0.1),
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1),
+	 BIP_RANGE(0.5),
+	 BIP_RANGE(0.25),
+	 BIP_RANGE(0.1),
+	 BIP_RANGE(0.05),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2),
+	 UNI_RANGE(1),
+	 UNI_RANGE(0.5),
+	 UNI_RANGE(0.2),
+	 UNI_RANGE(0.1),
+	 }
 };
 
 /* analog input ranges for 4020 board */
 static const struct comedi_lrange ai_ranges_4020 = {
 	2,
 	{
-			BIP_RANGE(5),
-			BIP_RANGE(1),
-		}
+	 BIP_RANGE(5),
+	 BIP_RANGE(1),
+	 }
 };
 
 /* analog output ranges */
 static const struct comedi_lrange ao_ranges_64xx = {
 	4,
 	{
-			BIP_RANGE(5),
-			BIP_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(10),
-		}
+	 BIP_RANGE(5),
+	 BIP_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(10),
+	 }
 };
+
 static const int ao_range_code_64xx[] = {
 	0x0,
 	0x1,
@@ -498,9 +506,10 @@ static const int ao_range_code_64xx[] = {
 static const struct comedi_lrange ao_ranges_60xx = {
 	1,
 	{
-			BIP_RANGE(10),
-		}
+	 BIP_RANGE(10),
+	 }
 };
+
 static const int ao_range_code_60xx[] = {
 	0x0,
 };
@@ -508,10 +517,11 @@ static const int ao_range_code_60xx[] = {
 static const struct comedi_lrange ao_ranges_6030 = {
 	2,
 	{
-			BIP_RANGE(10),
-			UNI_RANGE(10),
-		}
+	 BIP_RANGE(10),
+	 UNI_RANGE(10),
+	 }
 };
+
 static const int ao_range_code_6030[] = {
 	0x0,
 	0x2,
@@ -520,10 +530,11 @@ static const int ao_range_code_6030[] = {
 static const struct comedi_lrange ao_ranges_4020 = {
 	2,
 	{
-			BIP_RANGE(5),
-			BIP_RANGE(10),
-		}
+	 BIP_RANGE(5),
+	 BIP_RANGE(10),
+	 }
 };
+
 static const int ao_range_code_4020[] = {
 	0x1,
 	0x0,
@@ -597,458 +608,478 @@ static const int bytes_in_sample = 2;
 
 static const struct pcidas64_board pcidas64_boards[] = {
 	{
-	.name = "pci-das6402/16",
-	.device_id = 0x1d,
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ao_range_table = &ao_ranges_64xx,
-	.ao_range_code = ao_range_code_64xx,
-	.ai_fifo = &ai_fifo_64xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das6402/16",
+	 .device_id = 0x1d,
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ao_range_table = &ao_ranges_64xx,
+	 .ao_range_code = ao_range_code_64xx,
+	 .ai_fifo = &ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
 	{
-	.name = "pci-das6402/12",	/*  XXX check */
-	.device_id = 0x1e,
-	.ai_se_chans = 64,
-	.ai_bits = 12,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.ao_bits = 12,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ao_range_table = &ao_ranges_64xx,
-	.ao_range_code = ao_range_code_64xx,
-	.ai_fifo = &ai_fifo_64xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das6402/12",	/*  XXX check */
+	 .device_id = 0x1e,
+	 .ai_se_chans = 64,
+	 .ai_bits = 12,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .ao_bits = 12,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ao_range_table = &ao_ranges_64xx,
+	 .ao_range_code = ao_range_code_64xx,
+	 .ai_fifo = &ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
 	{
-	.name = "pci-das64/m1/16",
-	.device_id = 0x35,
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 1000,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ao_range_table = &ao_ranges_64xx,
-	.ao_range_code = ao_range_code_64xx,
-	.ai_fifo = &ai_fifo_64xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das64/m1/16",
+	 .device_id = 0x35,
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 1000,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ao_range_table = &ao_ranges_64xx,
+	 .ao_range_code = ao_range_code_64xx,
+	 .ai_fifo = &ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
 	{
-	.name = "pci-das64/m2/16",
-	.device_id = 0x36,
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 500,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ao_range_table = &ao_ranges_64xx,
-	.ao_range_code = ao_range_code_64xx,
-	.ai_fifo = &ai_fifo_64xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das64/m2/16",
+	 .device_id = 0x36,
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 500,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ao_range_table = &ao_ranges_64xx,
+	 .ao_range_code = ao_range_code_64xx,
+	 .ai_fifo = &ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
 	{
-	.name = "pci-das64/m3/16",
-	.device_id = 0x37,
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 333,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ao_range_table = &ao_ranges_64xx,
-	.ao_range_code = ao_range_code_64xx,
-	.ai_fifo = &ai_fifo_64xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das64/m3/16",
+	 .device_id = 0x37,
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 333,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ao_range_table = &ao_ranges_64xx,
+	 .ao_range_code = ao_range_code_64xx,
+	 .ai_fifo = &ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
 	{
-		.name = "pci-das6013",
-		.device_id = 0x78,
-		.ai_se_chans = 16,
-		.ai_bits = 16,
-		.ai_speed = 5000,
-		.ao_nchan = 0,
-		.ao_bits = 16,
-		.layout = LAYOUT_60XX,
-		.ai_range_table = &ai_ranges_60xx,
-		.ao_range_table = &ao_ranges_60xx,
-		.ao_range_code = ao_range_code_60xx,
-		.ai_fifo = &ai_fifo_60xx,
-		.has_8255 = 0,
-		},
+	 .name = "pci-das6013",
+	 .device_id = 0x78,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 0,
+	 .ao_bits = 16,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ao_range_table = &ao_ranges_60xx,
+	 .ao_range_code = ao_range_code_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "pci-das6014",
-	.device_id = 0x79,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 100000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_60xx,
-	.ao_range_table = &ao_ranges_60xx,
-	.ao_range_code = ao_range_code_60xx,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
+	 .name = "pci-das6014",
+	 .device_id = 0x79,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 100000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ao_range_table = &ao_ranges_60xx,
+	 .ao_range_code = ao_range_code_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "pci-das6023",
-	.device_id = 0x5d,
-	.ai_se_chans = 16,
-	.ai_bits = 12,
-	.ai_speed = 5000,
-	.ao_nchan = 0,
-	.ao_scan_speed = 100000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_60xx,
-	.ao_range_table = &ao_ranges_60xx,
-	.ao_range_code = ao_range_code_60xx,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das6023",
+	 .device_id = 0x5d,
+	 .ai_se_chans = 16,
+	 .ai_bits = 12,
+	 .ai_speed = 5000,
+	 .ao_nchan = 0,
+	 .ao_scan_speed = 100000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ao_range_table = &ao_ranges_60xx,
+	 .ao_range_code = ao_range_code_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 1,
+	 },
 	{
-	.name = "pci-das6025",
-	.device_id = 0x5e,
-	.ai_se_chans = 16,
-	.ai_bits = 12,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.ao_bits = 12,
-	.ao_scan_speed = 100000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_60xx,
-	.ao_range_table = &ao_ranges_60xx,
-	.ao_range_code = ao_range_code_60xx,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das6025",
+	 .device_id = 0x5e,
+	 .ai_se_chans = 16,
+	 .ai_bits = 12,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .ao_bits = 12,
+	 .ao_scan_speed = 100000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ao_range_table = &ao_ranges_60xx,
+	 .ao_range_code = ao_range_code_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 1,
+	 },
 	{
-	.name = "pci-das6030",
-	.device_id = 0x5f,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 10000,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6030,
-	.ao_range_table = &ao_ranges_6030,
-	.ao_range_code = ao_range_code_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
+	 .name = "pci-das6030",
+	 .device_id = 0x5f,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 10000,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6030,
+	 .ao_range_table = &ao_ranges_6030,
+	 .ao_range_code = ao_range_code_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "pci-das6031",
-	.device_id = 0x60,
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 10000,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6030,
-	.ao_range_table = &ao_ranges_6030,
-	.ao_range_code = ao_range_code_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
+	 .name = "pci-das6031",
+	 .device_id = 0x60,
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 10000,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6030,
+	 .ao_range_table = &ao_ranges_6030,
+	 .ao_range_code = ao_range_code_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "pci-das6032",
-	.device_id = 0x61,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 10000,
-	.ao_nchan = 0,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
+	 .name = "pci-das6032",
+	 .device_id = 0x61,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 10000,
+	 .ao_nchan = 0,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "pci-das6033",
-	.device_id = 0x62,
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 10000,
-	.ao_nchan = 0,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
+	 .name = "pci-das6033",
+	 .device_id = 0x62,
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 10000,
+	 .ao_nchan = 0,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "pci-das6034",
-	.device_id = 0x63,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 0,
-	.ao_scan_speed = 0,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_60xx,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
+	 .name = "pci-das6034",
+	 .device_id = 0x63,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 0,
+	 .ao_scan_speed = 0,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "pci-das6035",
-	.device_id = 0x64,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.ao_bits = 12,
-	.ao_scan_speed = 100000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_60xx,
-	.ao_range_table = &ao_ranges_60xx,
-	.ao_range_code = ao_range_code_60xx,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
+	 .name = "pci-das6035",
+	 .device_id = 0x64,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .ao_bits = 12,
+	 .ao_scan_speed = 100000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ao_range_table = &ao_ranges_60xx,
+	 .ao_range_code = ao_range_code_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "pci-das6036",
-	.device_id = 0x6f,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 100000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_60xx,
-	.ao_range_table = &ao_ranges_60xx,
-	.ao_range_code = ao_range_code_60xx,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
+	 .name = "pci-das6036",
+	 .device_id = 0x6f,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 100000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ao_range_table = &ao_ranges_60xx,
+	 .ao_range_code = ao_range_code_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "pci-das6040",
-	.device_id = 0x65,
-	.ai_se_chans = 16,
-	.ai_bits = 12,
-	.ai_speed = 2000,
-	.ao_nchan = 2,
-	.ao_bits = 12,
-	.ao_scan_speed = 1000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6052,
-	.ao_range_table = &ao_ranges_6030,
-	.ao_range_code = ao_range_code_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
+	 .name = "pci-das6040",
+	 .device_id = 0x65,
+	 .ai_se_chans = 16,
+	 .ai_bits = 12,
+	 .ai_speed = 2000,
+	 .ao_nchan = 2,
+	 .ao_bits = 12,
+	 .ao_scan_speed = 1000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6052,
+	 .ao_range_table = &ao_ranges_6030,
+	 .ao_range_code = ao_range_code_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "pci-das6052",
-	.device_id = 0x66,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 3333,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 3333,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6052,
-	.ao_range_table = &ao_ranges_6030,
-	.ao_range_code = ao_range_code_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
+	 .name = "pci-das6052",
+	 .device_id = 0x66,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 3333,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 3333,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6052,
+	 .ao_range_table = &ao_ranges_6030,
+	 .ao_range_code = ao_range_code_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "pci-das6070",
-	.device_id = 0x67,
-	.ai_se_chans = 16,
-	.ai_bits = 12,
-	.ai_speed = 800,
-	.ao_nchan = 2,
-	.ao_bits = 12,
-	.ao_scan_speed = 1000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6052,
-	.ao_range_table = &ao_ranges_6030,
-	.ao_range_code = ao_range_code_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
+	 .name = "pci-das6070",
+	 .device_id = 0x67,
+	 .ai_se_chans = 16,
+	 .ai_bits = 12,
+	 .ai_speed = 800,
+	 .ao_nchan = 2,
+	 .ao_bits = 12,
+	 .ao_scan_speed = 1000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6052,
+	 .ao_range_table = &ao_ranges_6030,
+	 .ao_range_code = ao_range_code_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "pci-das6071",
-	.device_id = 0x68,
-	.ai_se_chans = 64,
-	.ai_bits = 12,
-	.ai_speed = 800,
-	.ao_nchan = 2,
-	.ao_bits = 12,
-	.ao_scan_speed = 1000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6052,
-	.ao_range_table = &ao_ranges_6030,
-	.ao_range_code = ao_range_code_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
+	 .name = "pci-das6071",
+	 .device_id = 0x68,
+	 .ai_se_chans = 64,
+	 .ai_bits = 12,
+	 .ai_speed = 800,
+	 .ao_nchan = 2,
+	 .ao_bits = 12,
+	 .ao_scan_speed = 1000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6052,
+	 .ao_range_table = &ao_ranges_6030,
+	 .ao_range_code = ao_range_code_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "pci-das4020/12",
-	.device_id = 0x52,
-	.ai_se_chans = 4,
-	.ai_bits = 12,
-	.ai_speed = 50,
-	.ao_bits = 12,
-	.ao_nchan = 2,
-	.ao_scan_speed = 0,	/*  no hardware pacing on ao */
-	.layout = LAYOUT_4020,
-	.ai_range_table = &ai_ranges_4020,
-	.ao_range_table = &ao_ranges_4020,
-	.ao_range_code = ao_range_code_4020,
-	.ai_fifo = &ai_fifo_4020,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das4020/12",
+	 .device_id = 0x52,
+	 .ai_se_chans = 4,
+	 .ai_bits = 12,
+	 .ai_speed = 50,
+	 .ao_bits = 12,
+	 .ao_nchan = 2,
+	 .ao_scan_speed = 0,	/*  no hardware pacing on ao */
+	 .layout = LAYOUT_4020,
+	 .ai_range_table = &ai_ranges_4020,
+	 .ao_range_table = &ao_ranges_4020,
+	 .ao_range_code = ao_range_code_4020,
+	 .ai_fifo = &ai_fifo_4020,
+	 .has_8255 = 1,
+	 },
 #if 0
 	{
-	.name = "pci-das6402/16/jr",
-	.device_id = 0	/*  XXX, */
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 0,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das6402/16/jr",
+	 .device_id = 0		/*  XXX, */
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 0,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
 	{
-	.name = "pci-das64/m1/16/jr",
-	.device_id = 0	/*  XXX, */
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 1000,
-	.ao_nchan = 0,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das64/m1/16/jr",
+	 .device_id = 0		/*  XXX, */
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 1000,
+	 .ao_nchan = 0,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
 	{
-	.name = "pci-das64/m2/16/jr",
-	.device_id = 0	/*  XXX, */
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 500,
-	.ao_nchan = 0,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das64/m2/16/jr",
+	 .device_id = 0		/*  XXX, */
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 500,
+	 .ao_nchan = 0,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
 	{
-	.name = "pci-das64/m3/16/jr",
-	.device_id = 0	/*  XXX, */
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 333,
-	.ao_nchan = 0,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das64/m3/16/jr",
+	 .device_id = 0		/*  XXX, */
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 333,
+	 .ao_nchan = 0,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
 	{
-	.name = "pci-das64/m1/14",
-	.device_id = 0,	/*  XXX */
-	.ai_se_chans = 64,
-	.ai_bits = 14,
-	.ai_speed = 1000,
-	.ao_nchan = 2,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das64/m1/14",
+	 .device_id = 0,	/*  XXX */
+	 .ai_se_chans = 64,
+	 .ai_bits = 14,
+	 .ai_speed = 1000,
+	 .ao_nchan = 2,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
 	{
-	.name = "pci-das64/m2/14",
-	.device_id = 0,	/*  XXX */
-	.ai_se_chans = 64,
-	.ai_bits = 14,
-	.ai_speed = 500,
-	.ao_nchan = 2,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das64/m2/14",
+	 .device_id = 0,	/*  XXX */
+	 .ai_se_chans = 64,
+	 .ai_bits = 14,
+	 .ai_speed = 500,
+	 .ao_nchan = 2,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
 	{
-	.name = "pci-das64/m3/14",
-	.device_id = 0,	/*  XXX */
-	.ai_se_chans = 64,
-	.ai_bits = 14,
-	.ai_speed = 333,
-	.ao_nchan = 2,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das64/m3/14",
+	 .device_id = 0,	/*  XXX */
+	 .ai_se_chans = 64,
+	 .ai_bits = 14,
+	 .ai_speed = 333,
+	 .ao_nchan = 2,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
 #endif
 };
 
 static DEFINE_PCI_DEVICE_TABLE(pcidas64_pci_table) = {
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x001d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x001e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0035, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0036, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0037, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0052, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x005d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x005e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x005f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0061, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0062, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0063, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0064, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0066, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0067, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0068, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x006f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0078, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0079, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x001d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x001e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0035, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0036, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0037, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0052, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x005d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x005e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x005f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0061, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0062, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0063, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0064, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0066, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0067, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0068, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x006f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0078, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0079, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pcidas64_pci_table);
 
-static inline struct pcidas64_board *board(const struct comedi_device * dev)
+static inline struct pcidas64_board *board(const struct comedi_device *dev)
 {
-	return (struct pcidas64_board *) dev->board_ptr;
+	return (struct pcidas64_board *)dev->board_ptr;
 }
 
 static inline unsigned short se_diff_bit_6xxx(struct comedi_device *dev,
-	int use_differential)
+					      int use_differential)
 {
 	if ((board(dev)->layout == LAYOUT_64XX && !use_differential) ||
-		(board(dev)->layout == LAYOUT_60XX && use_differential))
+	    (board(dev)->layout == LAYOUT_60XX && use_differential))
 		return ADC_SE_DIFF_BIT;
 	else
 		return 0;
@@ -1107,11 +1138,10 @@ struct pcidas64_private {
 	short ao_bounce_buffer[DAC_FIFO_SIZE];
 };
 
-
 /* inline function that makes it easier to
  * access the private structure.
  */
-static inline struct pcidas64_private *priv(struct comedi_device * dev)
+static inline struct pcidas64_private *priv(struct comedi_device *dev)
 {
 	return dev->private;
 }
@@ -1132,76 +1162,86 @@ static struct comedi_driver driver_cb_pcidas = {
 };
 
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+		    struct comedi_insn *insn, unsigned int *data);
 static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ao_readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+		    struct comedi_insn *insn, unsigned int *data);
+static int ao_readback_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
 static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+		      struct comedi_cmd *cmd);
 static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *subdev,
-	unsigned int trig_num);
+static int ao_inttrig(struct comedi_device *dev,
+		      struct comedi_subdevice *subdev, unsigned int trig_num);
 static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+		      struct comedi_cmd *cmd);
 static irqreturn_t handle_interrupt(int irq, void *d);
 static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int dio_callback(int dir, int port, int data, unsigned long arg);
 static int dio_callback_4020(int dir, int port, int data, unsigned long arg);
 static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+		    struct comedi_insn *insn, unsigned int *data);
 static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dio_60xx_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+		    struct comedi_insn *insn, unsigned int *data);
+static int dio_60xx_config_insn(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
 static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int calib_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int calib_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ad8402_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
+static int calib_read_insn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int calib_write_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int ad8402_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
 static void ad8402_write(struct comedi_device *dev, unsigned int channel,
-	unsigned int value);
-static int ad8402_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 unsigned int value);
+static int ad8402_write_insn(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
+static int eeprom_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
 static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd);
 static unsigned int get_divisor(unsigned int ns, unsigned int flags);
 static void i2c_write(struct comedi_device *dev, unsigned int address,
-	const uint8_t *data, unsigned int length);
+		      const uint8_t * data, unsigned int length);
 static void caldac_write(struct comedi_device *dev, unsigned int channel,
-	unsigned int value);
+			 unsigned int value);
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-	uint8_t value);
+			     uint8_t value);
 /* static int dac_1590_write(struct comedi_device *dev, unsigned int dac_a, unsigned int dac_b); */
-static int caldac_i2c_write(struct comedi_device *dev, unsigned int caldac_channel,
-	unsigned int value);
+static int caldac_i2c_write(struct comedi_device *dev,
+			    unsigned int caldac_channel, unsigned int value);
 static void abort_dma(struct comedi_device *dev, unsigned int channel);
 static void disable_plx_interrupts(struct comedi_device *dev);
-static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples);
+static int set_ai_fifo_size(struct comedi_device *dev,
+			    unsigned int num_samples);
 static unsigned int ai_fifo_size(struct comedi_device *dev);
 static int set_ai_fifo_segment_length(struct comedi_device *dev,
-	unsigned int num_entries);
+				      unsigned int num_entries);
 static void disable_ai_pacing(struct comedi_device *dev);
 static void disable_ai_interrupts(struct comedi_device *dev);
-static void enable_ai_interrupts(struct comedi_device *dev, const struct comedi_cmd *cmd);
+static void enable_ai_interrupts(struct comedi_device *dev,
+				 const struct comedi_cmd *cmd);
 static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags);
-static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd);
+static void load_ao_dma(struct comedi_device *dev,
+			const struct comedi_cmd *cmd);
 
 COMEDI_PCI_INITCLEANUP(driver_cb_pcidas, pcidas64_pci_table);
 
 static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
-	unsigned int range_index)
+				       unsigned int range_index)
 {
 	const struct comedi_krange *range =
-		&board(dev)->ai_range_table->range[range_index];
+	    &board(dev)->ai_range_table->range[range_index];
 	unsigned int bits = 0;
 
 	switch (range->max) {
@@ -1242,7 +1282,7 @@ static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 }
 
 static unsigned int hw_revision(const struct comedi_device *dev,
-	uint16_t hw_status_bits)
+				uint16_t hw_status_bits)
 {
 	if (board(dev)->layout == LAYOUT_4020)
 		return (hw_status_bits >> 13) & 0x7;
@@ -1250,8 +1290,9 @@ static unsigned int hw_revision(const struct comedi_device *dev,
 	return (hw_status_bits >> 12) & 0xf;
 }
 
-static void set_dac_range_bits(struct comedi_device *dev, volatile uint16_t *bits,
-	unsigned int channel, unsigned int range)
+static void set_dac_range_bits(struct comedi_device *dev,
+			       volatile uint16_t * bits, unsigned int channel,
+			       unsigned int range)
 {
 	unsigned int code = board(dev)->ao_range_code[range];
 
@@ -1276,38 +1317,38 @@ static void init_plx9080(struct comedi_device *dev)
 	void *plx_iobase = priv(dev)->plx9080_iobase;
 
 	priv(dev)->plx_control_bits =
-		readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG);
+	    readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG);
 
 	/*  plx9080 dump */
 	DEBUG_PRINT(" plx interrupt status 0x%x\n",
-		readl(plx_iobase + PLX_INTRCS_REG));
+		    readl(plx_iobase + PLX_INTRCS_REG));
 	DEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));
 	DEBUG_PRINT(" plx control reg 0x%x\n", priv(dev)->plx_control_bits);
 	DEBUG_PRINT(" plx mode/arbitration reg 0x%x\n",
-		readl(plx_iobase + PLX_MARB_REG));
+		    readl(plx_iobase + PLX_MARB_REG));
 	DEBUG_PRINT(" plx region0 reg 0x%x\n",
-		readl(plx_iobase + PLX_REGION0_REG));
+		    readl(plx_iobase + PLX_REGION0_REG));
 	DEBUG_PRINT(" plx region1 reg 0x%x\n",
-		readl(plx_iobase + PLX_REGION1_REG));
+		    readl(plx_iobase + PLX_REGION1_REG));
 
 	DEBUG_PRINT(" plx revision 0x%x\n",
-		readl(plx_iobase + PLX_REVISION_REG));
+		    readl(plx_iobase + PLX_REVISION_REG));
 	DEBUG_PRINT(" plx dma channel 0 mode 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_MODE_REG));
+		    readl(plx_iobase + PLX_DMA0_MODE_REG));
 	DEBUG_PRINT(" plx dma channel 1 mode 0x%x\n",
-		readl(plx_iobase + PLX_DMA1_MODE_REG));
+		    readl(plx_iobase + PLX_DMA1_MODE_REG));
 	DEBUG_PRINT(" plx dma channel 0 pci address 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));
+		    readl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));
 	DEBUG_PRINT(" plx dma channel 0 local address 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));
+		    readl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));
 	DEBUG_PRINT(" plx dma channel 0 transfer size 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));
+		    readl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));
 	DEBUG_PRINT(" plx dma channel 0 descriptor 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));
+		    readl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));
 	DEBUG_PRINT(" plx dma channel 0 command status 0x%x\n",
-		readb(plx_iobase + PLX_DMA0_CS_REG));
+		    readb(plx_iobase + PLX_DMA0_CS_REG));
 	DEBUG_PRINT(" plx dma channel 0 threshold 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_THRESHOLD_REG));
+		    readl(plx_iobase + PLX_DMA0_THRESHOLD_REG));
 	DEBUG_PRINT(" plx bigend 0x%x\n", readl(plx_iobase + PLX_BIGEND_REG));
 
 #ifdef __BIG_ENDIAN
@@ -1352,10 +1393,10 @@ static void init_plx9080(struct comedi_device *dev)
 
 	/*  enable interrupts on plx 9080 */
 	priv(dev)->plx_intcsr_bits |=
-		ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
-		ICS_DMA0_E | ICS_DMA1_E;
+	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
+	    ICS_DMA0_E | ICS_DMA1_E;
 	writel(priv(dev)->plx_intcsr_bits,
-		priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+	       priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
 }
 
 /* Allocate and initialize the subdevice structures.
@@ -1405,8 +1446,7 @@ static int setup_subdevices(struct comedi_device *dev)
 	if (board(dev)->ao_nchan) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags =
-			SDF_READABLE | SDF_WRITABLE | SDF_GROUND |
-			SDF_CMD_WRITE;
+		    SDF_READABLE | SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
 		s->n_chan = board(dev)->ao_nchan;
 		s->maxdata = (1 << board(dev)->ao_bits) - 1;
 		s->range_table = board(dev)->ao_range_table;
@@ -1452,14 +1492,14 @@ static int setup_subdevices(struct comedi_device *dev)
 	if (board(dev)->has_8255) {
 		if (board(dev)->layout == LAYOUT_4020) {
 			dio_8255_iobase =
-				priv(dev)->main_iobase + I8255_4020_REG;
+			    priv(dev)->main_iobase + I8255_4020_REG;
 			subdev_8255_init(dev, s, dio_callback_4020,
-				(unsigned long)dio_8255_iobase);
+					 (unsigned long)dio_8255_iobase);
 		} else {
 			dio_8255_iobase =
-				priv(dev)->dio_counter_iobase + DIO_8255_OFFSET;
+			    priv(dev)->dio_counter_iobase + DIO_8255_OFFSET;
 			subdev_8255_init(dev, s, dio_callback,
-				(unsigned long)dio_8255_iobase);
+					 (unsigned long)dio_8255_iobase);
 		}
 	} else
 		s->type = COMEDI_SUBD_UNUSED;
@@ -1527,7 +1567,7 @@ static void disable_plx_interrupts(struct comedi_device *dev)
 {
 	priv(dev)->plx_intcsr_bits = 0;
 	writel(priv(dev)->plx_intcsr_bits,
-		priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+	       priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
 }
 
 static void init_stc_registers(struct comedi_device *dev)
@@ -1541,7 +1581,7 @@ static void init_stc_registers(struct comedi_device *dev)
 	if (1)
 		priv(dev)->adc_control1_bits |= ADC_QUEUE_CONFIG_BIT;
 	writew(priv(dev)->adc_control1_bits,
-		priv(dev)->main_iobase + ADC_CONTROL1_REG);
+	       priv(dev)->main_iobase + ADC_CONTROL1_REG);
 
 	/*  6402/16 manual says this register must be initialized to 0xff? */
 	writew(0xff, priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
@@ -1551,7 +1591,7 @@ static void init_stc_registers(struct comedi_device *dev)
 		bits |= INTERNAL_CLOCK_4020_BITS;
 	priv(dev)->hw_config_bits |= bits;
 	writew(priv(dev)->hw_config_bits,
-		priv(dev)->main_iobase + HW_CONFIG_REG);
+	       priv(dev)->main_iobase + HW_CONFIG_REG);
 
 	writew(0, priv(dev)->main_iobase + DAQ_SYNC_REG);
 	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
@@ -1561,13 +1601,13 @@ static void init_stc_registers(struct comedi_device *dev)
 	/*  set fifos to maximum size */
 	priv(dev)->fifo_size_bits |= DAC_FIFO_BITS;
 	set_ai_fifo_segment_length(dev,
-		board(dev)->ai_fifo->max_segment_length);
+				   board(dev)->ai_fifo->max_segment_length);
 
 	priv(dev)->dac_control1_bits = DAC_OUTPUT_ENABLE_BIT;
 	priv(dev)->intr_enable_bits =	/* EN_DAC_INTR_SRC_BIT | DAC_INTR_QEMPTY_BITS | */
-		EN_DAC_DONE_INTR_BIT | EN_DAC_UNDERRUN_BIT;
+	    EN_DAC_DONE_INTR_BIT | EN_DAC_UNDERRUN_BIT;
 	writew(priv(dev)->intr_enable_bits,
-		priv(dev)->main_iobase + INTR_ENABLE_REG);
+	       priv(dev)->main_iobase + INTR_ENABLE_REG);
 
 	disable_ai_pacing(dev);
 };
@@ -1579,8 +1619,8 @@ int alloc_and_init_dma_members(struct comedi_device *dev)
 	/*  alocate pci dma buffers */
 	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 		priv(dev)->ai_buffer[i] =
-			pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
-			&priv(dev)->ai_buffer_bus_addr[i]);
+		    pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
+					 &priv(dev)->ai_buffer_bus_addr[i]);
 		if (priv(dev)->ai_buffer[i] == NULL) {
 			return -ENOMEM;
 		}
@@ -1588,9 +1628,10 @@ int alloc_and_init_dma_members(struct comedi_device *dev)
 	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 		if (ao_cmd_is_supported(board(dev))) {
 			priv(dev)->ao_buffer[i] =
-				pci_alloc_consistent(priv(dev)->hw_dev,
-				DMA_BUFFER_SIZE,
-				&priv(dev)->ao_buffer_bus_addr[i]);
+			    pci_alloc_consistent(priv(dev)->hw_dev,
+						 DMA_BUFFER_SIZE,
+						 &priv(dev)->
+						 ao_buffer_bus_addr[i]);
 			if (priv(dev)->ao_buffer[i] == NULL) {
 				return -ENOMEM;
 			}
@@ -1598,61 +1639,65 @@ int alloc_and_init_dma_members(struct comedi_device *dev)
 	}
 	/*  allocate dma descriptors */
 	priv(dev)->ai_dma_desc =
-		pci_alloc_consistent(priv(dev)->hw_dev,
-		sizeof(struct plx_dma_desc) * ai_dma_ring_count(board(dev)),
-		&priv(dev)->ai_dma_desc_bus_addr);
+	    pci_alloc_consistent(priv(dev)->hw_dev,
+				 sizeof(struct plx_dma_desc) *
+				 ai_dma_ring_count(board(dev)),
+				 &priv(dev)->ai_dma_desc_bus_addr);
 	if (priv(dev)->ai_dma_desc == NULL) {
 		return -ENOMEM;
 	}
 	DEBUG_PRINT("ai dma descriptors start at bus addr 0x%x\n",
-		priv(dev)->ai_dma_desc_bus_addr);
+		    priv(dev)->ai_dma_desc_bus_addr);
 	if (ao_cmd_is_supported(board(dev))) {
 		priv(dev)->ao_dma_desc =
-			pci_alloc_consistent(priv(dev)->hw_dev,
-			sizeof(struct plx_dma_desc) * AO_DMA_RING_COUNT,
-			&priv(dev)->ao_dma_desc_bus_addr);
+		    pci_alloc_consistent(priv(dev)->hw_dev,
+					 sizeof(struct plx_dma_desc) *
+					 AO_DMA_RING_COUNT,
+					 &priv(dev)->ao_dma_desc_bus_addr);
 		if (priv(dev)->ao_dma_desc == NULL) {
 			return -ENOMEM;
 		}
 		DEBUG_PRINT("ao dma descriptors start at bus addr 0x%x\n",
-			priv(dev)->ao_dma_desc_bus_addr);
+			    priv(dev)->ao_dma_desc_bus_addr);
 	}
 	/*  initialize dma descriptors */
 	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 		priv(dev)->ai_dma_desc[i].pci_start_addr =
-			cpu_to_le32(priv(dev)->ai_buffer_bus_addr[i]);
+		    cpu_to_le32(priv(dev)->ai_buffer_bus_addr[i]);
 		if (board(dev)->layout == LAYOUT_4020)
 			priv(dev)->ai_dma_desc[i].local_start_addr =
-				cpu_to_le32(priv(dev)->local1_iobase +
-				ADC_FIFO_REG);
+			    cpu_to_le32(priv(dev)->local1_iobase +
+					ADC_FIFO_REG);
 		else
 			priv(dev)->ai_dma_desc[i].local_start_addr =
-				cpu_to_le32(priv(dev)->local0_iobase +
-				ADC_FIFO_REG);
+			    cpu_to_le32(priv(dev)->local0_iobase +
+					ADC_FIFO_REG);
 		priv(dev)->ai_dma_desc[i].transfer_size = cpu_to_le32(0);
 		priv(dev)->ai_dma_desc[i].next =
-			cpu_to_le32((priv(dev)->ai_dma_desc_bus_addr + ((i +
-						1) %
-					ai_dma_ring_count(board(dev))) *
-				sizeof(priv(dev)->
-					ai_dma_desc[0])) | PLX_DESC_IN_PCI_BIT |
-			PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI);
+		    cpu_to_le32((priv(dev)->ai_dma_desc_bus_addr + ((i +
+								     1) %
+								    ai_dma_ring_count
+								    (board
+								     (dev))) *
+				 sizeof(priv(dev)->ai_dma_desc[0])) |
+				PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
+				PLX_XFER_LOCAL_TO_PCI);
 	}
 	if (ao_cmd_is_supported(board(dev))) {
 		for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 			priv(dev)->ao_dma_desc[i].pci_start_addr =
-				cpu_to_le32(priv(dev)->ao_buffer_bus_addr[i]);
+			    cpu_to_le32(priv(dev)->ao_buffer_bus_addr[i]);
 			priv(dev)->ao_dma_desc[i].local_start_addr =
-				cpu_to_le32(priv(dev)->local0_iobase +
-				DAC_FIFO_REG);
+			    cpu_to_le32(priv(dev)->local0_iobase +
+					DAC_FIFO_REG);
 			priv(dev)->ao_dma_desc[i].transfer_size =
-				cpu_to_le32(0);
+			    cpu_to_le32(0);
 			priv(dev)->ao_dma_desc[i].next =
-				cpu_to_le32((priv(dev)->ao_dma_desc_bus_addr +
-					((i + 1) % (AO_DMA_RING_COUNT)) *
-					sizeof(priv(dev)->
-						ao_dma_desc[0])) |
-				PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT);
+			    cpu_to_le32((priv(dev)->ao_dma_desc_bus_addr +
+					 ((i + 1) % (AO_DMA_RING_COUNT)) *
+					 sizeof(priv(dev)->ao_dma_desc[0])) |
+					PLX_DESC_IN_PCI_BIT |
+					PLX_INTR_TERM_COUNT);
 		}
 	}
 	return 0;
@@ -1661,9 +1706,9 @@ int alloc_and_init_dma_members(struct comedi_device *dev)
 static inline void warn_external_queue(struct comedi_device *dev)
 {
 	comedi_error(dev,
-		"AO command and AI external channel queue cannot be used simultaneously.");
+		     "AO command and AI external channel queue cannot be used simultaneously.");
 	comedi_error(dev,
-		"Use internal AI channel queue (channels must be consecutive and use same range/aref)");
+		     "Use internal AI channel queue (channels must be consecutive and use same range/aref)");
 }
 
 /*
@@ -1690,8 +1735,8 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
  */
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
 			continue;
@@ -1703,8 +1748,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			if (it->options[0] || it->options[1]) {
 				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
-					PCI_SLOT(pcidev->devfn) !=
-					it->options[1]) {
+				    PCI_SLOT(pcidev->devfn) != it->options[1]) {
 					continue;
 				}
 			}
@@ -1717,16 +1761,17 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	if (dev->board_ptr == NULL) {
-		printk("No supported ComputerBoards/MeasurementComputing card found\n");
+		printk
+		    ("No supported ComputerBoards/MeasurementComputing card found\n");
 		return -EIO;
 	}
 
 	printk("Found %s on bus %i, slot %i\n", board(dev)->name,
-		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+	       pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
 	if (comedi_pci_enable(pcidev, driver_cb_pcidas.driver_name)) {
 		printk(KERN_WARNING
-			" failed to enable PCI device and request regions\n");
+		       " failed to enable PCI device and request regions\n");
 		return -EIO;
 	}
 	pci_set_master(pcidev);
@@ -1735,23 +1780,25 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->board_name = board(dev)->name;
 
 	priv(dev)->plx9080_phys_iobase =
-		pci_resource_start(pcidev, PLX9080_BADDRINDEX);
+	    pci_resource_start(pcidev, PLX9080_BADDRINDEX);
 	priv(dev)->main_phys_iobase =
-		pci_resource_start(pcidev, MAIN_BADDRINDEX);
+	    pci_resource_start(pcidev, MAIN_BADDRINDEX);
 	priv(dev)->dio_counter_phys_iobase =
-		pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
+	    pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
 
 	/*  remap, won't work with 2.0 kernels but who cares */
 	priv(dev)->plx9080_iobase = ioremap(priv(dev)->plx9080_phys_iobase,
-		pci_resource_len(pcidev, PLX9080_BADDRINDEX));
-	priv(dev)->main_iobase = ioremap(priv(dev)->main_phys_iobase,
-		pci_resource_len(pcidev, MAIN_BADDRINDEX));
+					    pci_resource_len(pcidev,
+							     PLX9080_BADDRINDEX));
+	priv(dev)->main_iobase =
+	    ioremap(priv(dev)->main_phys_iobase,
+		    pci_resource_len(pcidev, MAIN_BADDRINDEX));
 	priv(dev)->dio_counter_iobase =
-		ioremap(priv(dev)->dio_counter_phys_iobase,
-		pci_resource_len(pcidev, DIO_COUNTER_BADDRINDEX));
+	    ioremap(priv(dev)->dio_counter_phys_iobase,
+		    pci_resource_len(pcidev, DIO_COUNTER_BADDRINDEX));
 
 	if (!priv(dev)->plx9080_iobase || !priv(dev)->main_iobase
-		|| !priv(dev)->dio_counter_iobase) {
+	    || !priv(dev)->dio_counter_iobase) {
 		printk(" failed to remap io memory\n");
 		return -ENOMEM;
 	}
@@ -1759,27 +1806,25 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	DEBUG_PRINT(" plx9080 remapped to 0x%p\n", priv(dev)->plx9080_iobase);
 	DEBUG_PRINT(" main remapped to 0x%p\n", priv(dev)->main_iobase);
 	DEBUG_PRINT(" diocounter remapped to 0x%p\n",
-		priv(dev)->dio_counter_iobase);
+		    priv(dev)->dio_counter_iobase);
 
 	/*  figure out what local addresses are */
 	local_range =
-		readl(priv(dev)->plx9080_iobase +
-		PLX_LAS0RNG_REG) & LRNG_MEM_MASK;
+	    readl(priv(dev)->plx9080_iobase + PLX_LAS0RNG_REG) & LRNG_MEM_MASK;
 	local_decode =
-		readl(priv(dev)->plx9080_iobase +
-		PLX_LAS0MAP_REG) & local_range & LMAP_MEM_MASK;
+	    readl(priv(dev)->plx9080_iobase +
+		  PLX_LAS0MAP_REG) & local_range & LMAP_MEM_MASK;
 	priv(dev)->local0_iobase =
-		((uint32_t) priv(dev)->
-		main_phys_iobase & ~local_range) | local_decode;
+	    ((uint32_t) priv(dev)->main_phys_iobase & ~local_range) |
+	    local_decode;
 	local_range =
-		readl(priv(dev)->plx9080_iobase +
-		PLX_LAS1RNG_REG) & LRNG_MEM_MASK;
+	    readl(priv(dev)->plx9080_iobase + PLX_LAS1RNG_REG) & LRNG_MEM_MASK;
 	local_decode =
-		readl(priv(dev)->plx9080_iobase +
-		PLX_LAS1MAP_REG) & local_range & LMAP_MEM_MASK;
+	    readl(priv(dev)->plx9080_iobase +
+		  PLX_LAS1MAP_REG) & local_range & LMAP_MEM_MASK;
 	priv(dev)->local1_iobase =
-		((uint32_t) priv(dev)->
-		dio_counter_phys_iobase & ~local_range) | local_decode;
+	    ((uint32_t) priv(dev)->dio_counter_phys_iobase & ~local_range) |
+	    local_decode;
 
 	DEBUG_PRINT(" local 0 io addr 0x%x\n", priv(dev)->local0_iobase);
 	DEBUG_PRINT(" local 1 io addr 0x%x\n", priv(dev)->local1_iobase);
@@ -1789,7 +1834,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return retval;
 
 	priv(dev)->hw_revision =
-		hw_revision(dev, readw(priv(dev)->main_iobase + HW_STATUS_REG));
+	    hw_revision(dev, readw(priv(dev)->main_iobase + HW_STATUS_REG));
 	printk(" stc hardware revision %i\n", priv(dev)->hw_revision);
 	init_plx9080(dev);
 	init_stc_registers(dev);
@@ -1840,32 +1885,40 @@ static int detach(struct comedi_device *dev)
 			for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 				if (priv(dev)->ai_buffer[i])
 					pci_free_consistent(priv(dev)->hw_dev,
-						DMA_BUFFER_SIZE,
-						priv(dev)->ai_buffer[i],
-						priv(dev)->
-						ai_buffer_bus_addr[i]);
+							    DMA_BUFFER_SIZE,
+							    priv(dev)->
+							    ai_buffer[i],
+							    priv
+							    (dev)->ai_buffer_bus_addr
+							    [i]);
 			}
 			for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 				if (priv(dev)->ao_buffer[i])
 					pci_free_consistent(priv(dev)->hw_dev,
-						DMA_BUFFER_SIZE,
-						priv(dev)->ao_buffer[i],
-						priv(dev)->
-						ao_buffer_bus_addr[i]);
+							    DMA_BUFFER_SIZE,
+							    priv(dev)->
+							    ao_buffer[i],
+							    priv
+							    (dev)->ao_buffer_bus_addr
+							    [i]);
 			}
 			/*  free dma descriptors */
 			if (priv(dev)->ai_dma_desc)
 				pci_free_consistent(priv(dev)->hw_dev,
-					sizeof(struct plx_dma_desc) *
-					ai_dma_ring_count(board(dev)),
-					priv(dev)->ai_dma_desc,
-					priv(dev)->ai_dma_desc_bus_addr);
+						    sizeof(struct plx_dma_desc)
+						    *
+						    ai_dma_ring_count(board
+								      (dev)),
+						    priv(dev)->ai_dma_desc,
+						    priv(dev)->
+						    ai_dma_desc_bus_addr);
 			if (priv(dev)->ao_dma_desc)
 				pci_free_consistent(priv(dev)->hw_dev,
-					sizeof(struct plx_dma_desc) *
-					AO_DMA_RING_COUNT,
-					priv(dev)->ao_dma_desc,
-					priv(dev)->ao_dma_desc_bus_addr);
+						    sizeof(struct plx_dma_desc)
+						    * AO_DMA_RING_COUNT,
+						    priv(dev)->ao_dma_desc,
+						    priv(dev)->
+						    ao_dma_desc_bus_addr);
 			if (priv(dev)->main_phys_iobase) {
 				comedi_pci_disable(priv(dev)->hw_dev);
 			}
@@ -1879,7 +1932,7 @@ static int detach(struct comedi_device *dev)
 }
 
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bits = 0, n, i;
 	unsigned int channel, range, aref;
@@ -1901,14 +1954,14 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	else
 		priv(dev)->adc_control1_bits &= ~ADC_DITHER_BIT;
 	writew(priv(dev)->adc_control1_bits,
-		priv(dev)->main_iobase + ADC_CONTROL1_REG);
+	       priv(dev)->main_iobase + ADC_CONTROL1_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (board(dev)->layout != LAYOUT_4020) {
 		/*  use internal queue */
 		priv(dev)->hw_config_bits &= ~EXT_QUEUE_BIT;
 		writew(priv(dev)->hw_config_bits,
-			priv(dev)->main_iobase + HW_CONFIG_REG);
+		       priv(dev)->main_iobase + HW_CONFIG_REG);
 
 		/*  ALT_SOURCE is internal calibration reference */
 		if (insn->chanspec & CR_ALT_SOURCE) {
@@ -1920,9 +1973,9 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			else
 				cal_en_bit = CAL_EN_64XX_BIT;
 			/*  select internal reference source to connect to channel 0 */
-			writew(cal_en_bit | adc_src_bits(priv(dev)->
-					calibration_source),
-				priv(dev)->main_iobase + CALIBRATION_REG);
+			writew(cal_en_bit |
+			       adc_src_bits(priv(dev)->calibration_source),
+			       priv(dev)->main_iobase + CALIBRATION_REG);
 		} else {
 			/*  make sure internal calibration source is turned off */
 			writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
@@ -1938,7 +1991,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		bits |= adc_chan_bits(channel);
 		/*  set stop channel */
 		writew(adc_chan_bits(channel),
-			priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
+		       priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
 		/*  set start channel, and rest of settings */
 		writew(bits, priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
 	} else {
@@ -1948,8 +2001,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (insn->chanspec & CR_ALT_SOURCE) {
 			DEBUG_PRINT("reading calibration source\n");
 			priv(dev)->i2c_cal_range_bits |=
-				adc_src_4020_bits(priv(dev)->
-				calibration_source);
+			    adc_src_4020_bits(priv(dev)->calibration_source);
 		} else {	/* select BNC inputs */
 			priv(dev)->i2c_cal_range_bits |= adc_src_4020_bits(4);
 		}
@@ -1958,20 +2010,20 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			priv(dev)->i2c_cal_range_bits |= attenuate_bit(channel);
 		else
 			priv(dev)->i2c_cal_range_bits &=
-				~attenuate_bit(channel);
+			    ~attenuate_bit(channel);
 		/*  update calibration/range i2c register only if necessary, as it is very slow */
 		if (old_cal_range_bits != priv(dev)->i2c_cal_range_bits) {
 			uint8_t i2c_data = priv(dev)->i2c_cal_range_bits;
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
-				sizeof(i2c_data));
+				  sizeof(i2c_data));
 		}
 
 		/* 4020 manual asks that sample interval register to be set before writing to convert register.
 		 * Using somewhat arbitrary setting of 4 master clock ticks = 0.1 usec */
 		writew(0,
-			priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
+		       priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
 		writew(2,
-			priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
+		       priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
 	}
 
 	for (n = 0; n < insn->n; n++) {
@@ -1981,7 +2033,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 		/* trigger conversion, bits sent only matter for 4020 */
 		writew(adc_convert_chan_4020_bits(CR_CHAN(insn->chanspec)),
-			priv(dev)->main_iobase + ADC_CONVERT_REG);
+		       priv(dev)->main_iobase + ADC_CONVERT_REG);
 
 		/*  wait for data */
 		for (i = 0; i < timeout; i++) {
@@ -1989,7 +2041,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			DEBUG_PRINT(" pipe bits 0x%x\n", pipe_full_bits(bits));
 			if (board(dev)->layout == LAYOUT_4020) {
 				if (readw(priv(dev)->main_iobase +
-						ADC_WRITE_PNTR_REG))
+					  ADC_WRITE_PNTR_REG))
 					break;
 			} else {
 				if (pipe_full_bits(bits))
@@ -2005,17 +2057,18 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		}
 		if (board(dev)->layout == LAYOUT_4020)
 			data[n] =
-				readl(priv(dev)->dio_counter_iobase +
-				ADC_FIFO_REG) & 0xffff;
+			    readl(priv(dev)->dio_counter_iobase +
+				  ADC_FIFO_REG) & 0xffff;
 		else
 			data[n] =
-				readw(priv(dev)->main_iobase + PIPE1_READ_REG);
+			    readw(priv(dev)->main_iobase + PIPE1_READ_REG);
 	}
 
 	return n;
 }
 
-static int ai_config_calibration_source(struct comedi_device *dev, unsigned int *data)
+static int ai_config_calibration_source(struct comedi_device *dev,
+					unsigned int *data)
 {
 	unsigned int source = data[1];
 	int num_calibration_sources;
@@ -2046,8 +2099,7 @@ static int ai_config_block_size(struct comedi_device *dev, unsigned int *data)
 
 	if (requested_block_size) {
 		fifo_size =
-			requested_block_size * fifo->num_segments /
-			bytes_in_sample;
+		    requested_block_size * fifo->num_segments / bytes_in_sample;
 
 		retval = set_ai_fifo_size(dev, fifo_size);
 		if (retval < 0)
@@ -2062,7 +2114,8 @@ static int ai_config_block_size(struct comedi_device *dev, unsigned int *data)
 	return 2;
 }
 
-static int ai_config_master_clock_4020(struct comedi_device *dev, unsigned int *data)
+static int ai_config_master_clock_4020(struct comedi_device *dev,
+				       unsigned int *data)
 {
 	unsigned int divisor = data[4];
 	int retval = 0;
@@ -2104,7 +2157,7 @@ static int ai_config_master_clock(struct comedi_device *dev, unsigned int *data)
 }
 
 static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int id = data[0];
 
@@ -2126,7 +2179,7 @@ static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+		      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -2181,21 +2234,21 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_OTHER &&
-		cmd->scan_begin_src != TRIG_FOLLOW)
+	    cmd->scan_begin_src != TRIG_OTHER &&
+	    cmd->scan_begin_src != TRIG_FOLLOW)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
+	    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
 		err++;
 
 	/*  compatibility check */
 	if (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
+	    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
 		err++;
 
 	if (err)
@@ -2217,10 +2270,10 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			if (cmd->scan_begin_src == TRIG_TIMER) {
 				/*  if scans are timed faster than conversion rate allows */
 				if (cmd->convert_arg * cmd->chanlist_len >
-					cmd->scan_begin_arg) {
+				    cmd->scan_begin_arg) {
 					cmd->scan_begin_arg =
-						cmd->convert_arg *
-						cmd->chanlist_len;
+					    cmd->convert_arg *
+					    cmd->chanlist_len;
 					err++;
 				}
 			}
@@ -2279,7 +2332,7 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (aref != CR_AREF(cmd->chanlist[i])) {
 				comedi_error(dev,
-					"all elements in chanlist must use the same analog reference");
+					     "all elements in chanlist must use the same analog reference");
 				err++;
 				break;
 			}
@@ -2289,16 +2342,16 @@ static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			unsigned int first_channel = CR_CHAN(cmd->chanlist[0]);
 			for (i = 1; i < cmd->chanlist_len; i++) {
 				if (CR_CHAN(cmd->chanlist[i]) !=
-					first_channel + i) {
+				    first_channel + i) {
 					comedi_error(dev,
-						"chanlist must use consecutive channels");
+						     "chanlist must use consecutive channels");
 					err++;
 					break;
 				}
 			}
 			if (cmd->chanlist_len == 3) {
 				comedi_error(dev,
-					"chanlist cannot be 3 channels long, use 1, 2, or 4 channels");
+					     "chanlist cannot be 3 channels long, use 1, 2, or 4 channels");
 				err++;
 			}
 		}
@@ -2321,7 +2374,8 @@ static int use_hw_sample_counter(struct comedi_cmd *cmd)
 		return 0;
 }
 
-static void setup_sample_counters(struct comedi_device *dev, struct comedi_cmd *cmd)
+static void setup_sample_counters(struct comedi_device *dev,
+				  struct comedi_cmd *cmd)
 {
 	if (cmd->stop_src == TRIG_COUNT) {
 		/*  set software count */
@@ -2330,9 +2384,9 @@ static void setup_sample_counters(struct comedi_device *dev, struct comedi_cmd *
 	/*  load hardware conversion counter */
 	if (use_hw_sample_counter(cmd)) {
 		writew(cmd->stop_arg & 0xffff,
-			priv(dev)->main_iobase + ADC_COUNT_LOWER_REG);
+		       priv(dev)->main_iobase + ADC_COUNT_LOWER_REG);
 		writew((cmd->stop_arg >> 16) & 0xff,
-			priv(dev)->main_iobase + ADC_COUNT_UPPER_REG);
+		       priv(dev)->main_iobase + ADC_COUNT_UPPER_REG);
 	} else {
 		writew(1, priv(dev)->main_iobase + ADC_COUNT_LOWER_REG);
 	}
@@ -2343,8 +2397,8 @@ static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 	unsigned int num_samples;
 
 	num_samples =
-		priv(dev)->ai_fifo_segment_length *
-		board(dev)->ai_fifo->sample_packing_ratio;
+	    priv(dev)->ai_fifo_segment_length *
+	    board(dev)->ai_fifo->sample_packing_ratio;
 	if (num_samples > DMA_BUFFER_SIZE / sizeof(uint16_t))
 		num_samples = DMA_BUFFER_SIZE / sizeof(uint16_t);
 
@@ -2360,12 +2414,12 @@ static void disable_ai_pacing(struct comedi_device *dev)
 	spin_lock_irqsave(&dev->spinlock, flags);
 	priv(dev)->adc_control1_bits &= ~ADC_SW_GATE_BIT;
 	writew(priv(dev)->adc_control1_bits,
-		priv(dev)->main_iobase + ADC_CONTROL1_REG);
+	       priv(dev)->main_iobase + ADC_CONTROL1_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* disable pacing, triggering, etc */
 	writew(ADC_DMA_DISABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT,
-		priv(dev)->main_iobase + ADC_CONTROL0_REG);
+	       priv(dev)->main_iobase + ADC_CONTROL0_REG);
 }
 
 static void disable_ai_interrupts(struct comedi_device *dev)
@@ -2374,23 +2428,24 @@ static void disable_ai_interrupts(struct comedi_device *dev)
 
 	spin_lock_irqsave(&dev->spinlock, flags);
 	priv(dev)->intr_enable_bits &=
-		~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &
-		~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &
-		~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;
+	    ~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &
+	    ~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &
+	    ~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;
 	writew(priv(dev)->intr_enable_bits,
-		priv(dev)->main_iobase + INTR_ENABLE_REG);
+	       priv(dev)->main_iobase + INTR_ENABLE_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
 }
 
-static void enable_ai_interrupts(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static void enable_ai_interrupts(struct comedi_device *dev,
+				 const struct comedi_cmd *cmd)
 {
 	uint32_t bits;
 	unsigned long flags;
 
 	bits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |
-		EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;
+	    EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;
 	/*  Use pio transfer and interrupt on end of conversion if TRIG_WAKE_EOS flag is set. */
 	if (cmd->flags & TRIG_WAKE_EOS) {
 		/*  4020 doesn't support pio transfers except for fifo dregs */
@@ -2400,27 +2455,28 @@ static void enable_ai_interrupts(struct comedi_device *dev, const struct comedi_
 	spin_lock_irqsave(&dev->spinlock, flags);
 	priv(dev)->intr_enable_bits |= bits;
 	writew(priv(dev)->intr_enable_bits,
-		priv(dev)->main_iobase + INTR_ENABLE_REG);
+	       priv(dev)->main_iobase + INTR_ENABLE_REG);
 	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static uint32_t ai_convert_counter_6xxx(const struct comedi_device *dev,
-	const struct comedi_cmd *cmd)
+					const struct comedi_cmd *cmd)
 {
 	/*  supposed to load counter with desired divisor minus 3 */
 	return cmd->convert_arg / TIMER_BASE - 3;
 }
 
-static uint32_t ai_scan_counter_6xxx(struct comedi_device *dev, struct comedi_cmd *cmd)
+static uint32_t ai_scan_counter_6xxx(struct comedi_device *dev,
+				     struct comedi_cmd *cmd)
 {
 	uint32_t count;
 	/*  figure out how long we need to delay at end of scan */
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
 		count = (cmd->scan_begin_arg -
-			(cmd->convert_arg * (cmd->chanlist_len - 1)))
-			/ TIMER_BASE;
+			 (cmd->convert_arg * (cmd->chanlist_len - 1)))
+		    / TIMER_BASE;
 		break;
 	case TRIG_FOLLOW:
 		count = cmd->convert_arg / TIMER_BASE;
@@ -2432,7 +2488,8 @@ static uint32_t ai_scan_counter_6xxx(struct comedi_device *dev, struct comedi_cm
 	return count - 3;
 }
 
-static uint32_t ai_convert_counter_4020(struct comedi_device *dev, struct comedi_cmd *cmd)
+static uint32_t ai_convert_counter_4020(struct comedi_device *dev,
+					struct comedi_cmd *cmd)
 {
 	unsigned int divisor;
 
@@ -2454,7 +2511,7 @@ static uint32_t ai_convert_counter_4020(struct comedi_device *dev, struct comedi
 }
 
 static void select_master_clock_4020(struct comedi_device *dev,
-	const struct comedi_cmd *cmd)
+				     const struct comedi_cmd *cmd)
 {
 	/*  select internal/external master clock */
 	priv(dev)->hw_config_bits &= ~MASTER_CLOCK_4020_MASK;
@@ -2469,10 +2526,11 @@ static void select_master_clock_4020(struct comedi_device *dev,
 		priv(dev)->hw_config_bits |= INTERNAL_CLOCK_4020_BITS;
 	}
 	writew(priv(dev)->hw_config_bits,
-		priv(dev)->main_iobase + HW_CONFIG_REG);
+	       priv(dev)->main_iobase + HW_CONFIG_REG);
 }
 
-static void select_master_clock(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static void select_master_clock(struct comedi_device *dev,
+				const struct comedi_cmd *cmd)
 {
 	switch (board(dev)->layout) {
 	case LAYOUT_4020:
@@ -2483,7 +2541,8 @@ static void select_master_clock(struct comedi_device *dev, const struct comedi_c
 	}
 }
 
-static inline void dma_start_sync(struct comedi_device *dev, unsigned int channel)
+static inline void dma_start_sync(struct comedi_device *dev,
+				  unsigned int channel)
 {
 	unsigned long flags;
 
@@ -2491,12 +2550,12 @@ static inline void dma_start_sync(struct comedi_device *dev, unsigned int channe
 	spin_lock_irqsave(&dev->spinlock, flags);
 	if (channel)
 		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
-			PLX_CLEAR_DMA_INTR_BIT,
-			priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+		       PLX_CLEAR_DMA_INTR_BIT,
+		       priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 	else
 		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
-			PLX_CLEAR_DMA_INTR_BIT,
-			priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+		       PLX_CLEAR_DMA_INTR_BIT,
+		       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
@@ -2517,17 +2576,17 @@ static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 
 	/*  load lower 16 bits of convert interval */
 	writew(convert_counter & 0xffff,
-		priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
+	       priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
 	DEBUG_PRINT("convert counter 0x%x\n", convert_counter);
 	/*  load upper 8 bits of convert interval */
 	writew((convert_counter >> 16) & 0xff,
-		priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
+	       priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
 	/*  load lower 16 bits of scan delay */
 	writew(scan_counter & 0xffff,
-		priv(dev)->main_iobase + ADC_DELAY_INTERVAL_LOWER_REG);
+	       priv(dev)->main_iobase + ADC_DELAY_INTERVAL_LOWER_REG);
 	/*  load upper 8 bits of scan delay */
 	writew((scan_counter >> 16) & 0xff,
-		priv(dev)->main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);
+	       priv(dev)->main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);
 	DEBUG_PRINT("scan counter 0x%x\n", scan_counter);
 }
 
@@ -2536,10 +2595,10 @@ static int use_internal_queue_6xxx(const struct comedi_cmd *cmd)
 	int i;
 	for (i = 0; i + 1 < cmd->chanlist_len; i++) {
 		if (CR_CHAN(cmd->chanlist[i + 1]) !=
-			CR_CHAN(cmd->chanlist[i]) + 1)
+		    CR_CHAN(cmd->chanlist[i]) + 1)
 			return 0;
 		if (CR_RANGE(cmd->chanlist[i + 1]) !=
-			CR_RANGE(cmd->chanlist[i]))
+		    CR_RANGE(cmd->chanlist[i]))
 			return 0;
 		if (CR_AREF(cmd->chanlist[i + 1]) != CR_AREF(cmd->chanlist[i]))
 			return 0;
@@ -2547,7 +2606,8 @@ static int use_internal_queue_6xxx(const struct comedi_cmd *cmd)
 	return 1;
 }
 
-static int setup_channel_queue(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static int setup_channel_queue(struct comedi_device *dev,
+			       const struct comedi_cmd *cmd)
 {
 	unsigned short bits;
 	int i;
@@ -2556,25 +2616,26 @@ static int setup_channel_queue(struct comedi_device *dev, const struct comedi_cm
 		if (use_internal_queue_6xxx(cmd)) {
 			priv(dev)->hw_config_bits &= ~EXT_QUEUE_BIT;
 			writew(priv(dev)->hw_config_bits,
-				priv(dev)->main_iobase + HW_CONFIG_REG);
+			       priv(dev)->main_iobase + HW_CONFIG_REG);
 			bits = 0;
 			/*  set channel */
 			bits |= adc_chan_bits(CR_CHAN(cmd->chanlist[0]));
 			/*  set gain */
 			bits |= ai_range_bits_6xxx(dev,
-				CR_RANGE(cmd->chanlist[0]));
+						   CR_RANGE(cmd->chanlist[0]));
 			/*  set single-ended / differential */
 			bits |= se_diff_bit_6xxx(dev,
-				CR_AREF(cmd->chanlist[0]) == AREF_DIFF);
+						 CR_AREF(cmd->chanlist[0]) ==
+						 AREF_DIFF);
 			if (CR_AREF(cmd->chanlist[0]) == AREF_COMMON)
 				bits |= ADC_COMMON_BIT;
 			/*  set stop channel */
-			writew(adc_chan_bits(CR_CHAN(cmd->chanlist[cmd->
-							chanlist_len - 1])),
-				priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
+			writew(adc_chan_bits
+			       (CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])),
+			       priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
 			/*  set start channel, and rest of settings */
 			writew(bits,
-				priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
+			       priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
 		} else {
 			/*  use external queue */
 			if (dev->write_subdev && dev->write_subdev->busy) {
@@ -2583,36 +2644,40 @@ static int setup_channel_queue(struct comedi_device *dev, const struct comedi_cm
 			}
 			priv(dev)->hw_config_bits |= EXT_QUEUE_BIT;
 			writew(priv(dev)->hw_config_bits,
-				priv(dev)->main_iobase + HW_CONFIG_REG);
+			       priv(dev)->main_iobase + HW_CONFIG_REG);
 			/*  clear DAC buffer to prevent weird interactions */
 			writew(0,
-				priv(dev)->main_iobase + DAC_BUFFER_CLEAR_REG);
+			       priv(dev)->main_iobase + DAC_BUFFER_CLEAR_REG);
 			/*  clear queue pointer */
 			writew(0, priv(dev)->main_iobase + ADC_QUEUE_CLEAR_REG);
 			/*  load external queue */
 			for (i = 0; i < cmd->chanlist_len; i++) {
 				bits = 0;
 				/*  set channel */
-				bits |= adc_chan_bits(CR_CHAN(cmd->
-						chanlist[i]));
+				bits |=
+				    adc_chan_bits(CR_CHAN(cmd->chanlist[i]));
 				/*  set gain */
 				bits |= ai_range_bits_6xxx(dev,
-					CR_RANGE(cmd->chanlist[i]));
+							   CR_RANGE(cmd->
+								    chanlist
+								    [i]));
 				/*  set single-ended / differential */
 				bits |= se_diff_bit_6xxx(dev,
-					CR_AREF(cmd->chanlist[i]) == AREF_DIFF);
+							 CR_AREF(cmd->
+								 chanlist[i]) ==
+							 AREF_DIFF);
 				if (CR_AREF(cmd->chanlist[i]) == AREF_COMMON)
 					bits |= ADC_COMMON_BIT;
 				/*  mark end of queue */
 				if (i == cmd->chanlist_len - 1)
 					bits |= QUEUE_EOSCAN_BIT |
-						QUEUE_EOSEQ_BIT;
+					    QUEUE_EOSEQ_BIT;
 				writew(bits,
-					priv(dev)->main_iobase +
-					ADC_QUEUE_FIFO_REG);
+				       priv(dev)->main_iobase +
+				       ADC_QUEUE_FIFO_REG);
 				DEBUG_PRINT
-					("wrote 0x%x to external channel queue\n",
-					bits);
+				    ("wrote 0x%x to external channel queue\n",
+				     bits);
 			}
 			/* doing a queue clear is not specified in board docs,
 			 * but required for reliable operation */
@@ -2622,7 +2687,7 @@ static int setup_channel_queue(struct comedi_device *dev, const struct comedi_cm
 		}
 	} else {
 		unsigned short old_cal_range_bits =
-			priv(dev)->i2c_cal_range_bits;
+		    priv(dev)->i2c_cal_range_bits;
 
 		priv(dev)->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;
 		/* select BNC inputs */
@@ -2634,23 +2699,24 @@ static int setup_channel_queue(struct comedi_device *dev, const struct comedi_cm
 
 			if (range == 0)
 				priv(dev)->i2c_cal_range_bits |=
-					attenuate_bit(channel);
+				    attenuate_bit(channel);
 			else
 				priv(dev)->i2c_cal_range_bits &=
-					~attenuate_bit(channel);
+				    ~attenuate_bit(channel);
 		}
 		/*  update calibration/range i2c register only if necessary, as it is very slow */
 		if (old_cal_range_bits != priv(dev)->i2c_cal_range_bits) {
 			uint8_t i2c_data = priv(dev)->i2c_cal_range_bits;
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
-				sizeof(i2c_data));
+				  sizeof(i2c_data));
 		}
 	}
 	return 0;
 }
 
 static inline void load_first_dma_descriptor(struct comedi_device *dev,
-	unsigned int dma_channel, unsigned int descriptor_bits)
+					     unsigned int dma_channel,
+					     unsigned int descriptor_bits)
 {
 	/* The transfer size, pci address, and local address registers
 	 * are supposedly unused during chained dma,
@@ -2659,20 +2725,20 @@ static inline void load_first_dma_descriptor(struct comedi_device *dev,
 	 * block.  Initializing them to zero seems to fix the problem. */
 	if (dma_channel) {
 		writel(0,
-			priv(dev)->plx9080_iobase + PLX_DMA1_TRANSFER_SIZE_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA1_TRANSFER_SIZE_REG);
 		writel(0, priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG);
 		writel(0,
-			priv(dev)->plx9080_iobase + PLX_DMA1_LOCAL_ADDRESS_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA1_LOCAL_ADDRESS_REG);
 		writel(descriptor_bits,
-			priv(dev)->plx9080_iobase + PLX_DMA1_DESCRIPTOR_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA1_DESCRIPTOR_REG);
 	} else {
 		writel(0,
-			priv(dev)->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
 		writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
 		writel(0,
-			priv(dev)->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
 		writel(descriptor_bits,
-			priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 	}
 }
 
@@ -2719,14 +2785,15 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			priv(dev)->adc_control1_bits |= TWO_CHANNEL_4020_BITS;
 		priv(dev)->adc_control1_bits &= ~ADC_LO_CHANNEL_4020_MASK;
 		priv(dev)->adc_control1_bits |=
-			adc_lo_chan_4020_bits(CR_CHAN(cmd->chanlist[0]));
+		    adc_lo_chan_4020_bits(CR_CHAN(cmd->chanlist[0]));
 		priv(dev)->adc_control1_bits &= ~ADC_HI_CHANNEL_4020_MASK;
 		priv(dev)->adc_control1_bits |=
-			adc_hi_chan_4020_bits(CR_CHAN(cmd->chanlist[cmd->
-					chanlist_len - 1]));
+		    adc_hi_chan_4020_bits(CR_CHAN
+					  (cmd->
+					   chanlist[cmd->chanlist_len - 1]));
 	}
 	writew(priv(dev)->adc_control1_bits,
-		priv(dev)->main_iobase + ADC_CONTROL1_REG);
+	       priv(dev)->main_iobase + ADC_CONTROL1_REG);
 	DEBUG_PRINT("control1 bits 0x%x\n", priv(dev)->adc_control1_bits);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -2734,20 +2801,21 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	writew(0, priv(dev)->main_iobase + ADC_BUFFER_CLEAR_REG);
 
 	if ((cmd->flags & TRIG_WAKE_EOS) == 0 ||
-		board(dev)->layout == LAYOUT_4020) {
+	    board(dev)->layout == LAYOUT_4020) {
 		priv(dev)->ai_dma_index = 0;
 
 		/*  set dma transfer size */
 		for (i = 0; i < ai_dma_ring_count(board(dev)); i++)
 			priv(dev)->ai_dma_desc[i].transfer_size =
-				cpu_to_le32(dma_transfer_size(dev) *
-				sizeof(uint16_t));
+			    cpu_to_le32(dma_transfer_size(dev) *
+					sizeof(uint16_t));
 
 		/*  give location of first dma descriptor */
 		load_first_dma_descriptor(dev, 1,
-			priv(dev)->
-			ai_dma_desc_bus_addr | PLX_DESC_IN_PCI_BIT |
-			PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI);
+					  priv(dev)->ai_dma_desc_bus_addr |
+					  PLX_DESC_IN_PCI_BIT |
+					  PLX_INTR_TERM_COUNT |
+					  PLX_XFER_LOCAL_TO_PCI);
 
 		dma_start_sync(dev, 1);
 	}
@@ -2807,11 +2875,9 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 	do {
 		/*  get least significant 15 bits */
 		read_index =
-			readw(priv(dev)->main_iobase +
-			ADC_READ_PNTR_REG) & 0x7fff;
+		    readw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
 		write_index =
-			readw(priv(dev)->main_iobase +
-			ADC_WRITE_PNTR_REG) & 0x7fff;
+		    readw(priv(dev)->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
 		/* Get most significant bits (grey code).  Different boards use different code
 		 * so use a scheme that doesn't depend on encoding.  This read must
 		 * occur after reading least significant 15 bits to avoid race
@@ -2824,11 +2890,12 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 		write_segment = adc_upper_write_ptr_code(prepost_bits);
 
 		DEBUG_PRINT(" rd seg %i, wrt seg %i, rd idx %i, wrt idx %i\n",
-			read_segment, write_segment, read_index, write_index);
+			    read_segment, write_segment, read_index,
+			    write_index);
 
 		if (read_segment != write_segment)
 			num_samples =
-				priv(dev)->ai_fifo_segment_length - read_index;
+			    priv(dev)->ai_fifo_segment_length - read_index;
 		else
 			num_samples = write_index - read_index;
 
@@ -2850,7 +2917,8 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 
 		for (i = 0; i < num_samples; i++) {
 			cfc_write_to_buffer(s,
-				readw(priv(dev)->main_iobase + ADC_FIFO_REG));
+					    readw(priv(dev)->main_iobase +
+						  ADC_FIFO_REG));
 		}
 
 	} while (read_segment != write_segment);
@@ -2870,9 +2938,9 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 	unsigned int max_transfer = 100000;
 	uint32_t fifo_data;
 	int write_code =
-		readw(priv(dev)->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
+	    readw(priv(dev)->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
 	int read_code =
-		readw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
+	    readw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		if (max_transfer > priv(dev)->ai_count) {
@@ -2888,8 +2956,7 @@ static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 			i++;
 		}
 		read_code =
-			readw(priv(dev)->main_iobase +
-			ADC_READ_PNTR_REG) & 0x7fff;
+		    readw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
 	}
 	priv(dev)->ai_count -= i;
 }
@@ -2913,19 +2980,18 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 
 	if (channel)
 		pci_addr_reg =
-			priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
+		    priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
 	else
 		pci_addr_reg =
-			priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+		    priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 
 	/*  loop until we have read all the full buffers */
 	for (j = 0, next_transfer_addr = readl(pci_addr_reg);
-		(next_transfer_addr <
-			priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index]
-			|| next_transfer_addr >=
-			priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index] +
-			DMA_BUFFER_SIZE) && j < ai_dma_ring_count(board(dev));
-		j++) {
+	     (next_transfer_addr <
+	      priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index]
+	      || next_transfer_addr >=
+	      priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index] +
+	      DMA_BUFFER_SIZE) && j < ai_dma_ring_count(board(dev)); j++) {
 		/*  transfer data from dma buffer to comedi buffer */
 		num_samples = dma_transfer_size(dev);
 		if (async->cmd.stop_src == TRIG_COUNT) {
@@ -2934,15 +3000,16 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 			priv(dev)->ai_count -= num_samples;
 		}
 		cfc_write_array_to_buffer(dev->read_subdev,
-			priv(dev)->ai_buffer[priv(dev)->ai_dma_index],
-			num_samples * sizeof(uint16_t));
+					  priv(dev)->ai_buffer[priv(dev)->
+							       ai_dma_index],
+					  num_samples * sizeof(uint16_t));
 		priv(dev)->ai_dma_index =
-			(priv(dev)->ai_dma_index +
-			1) % ai_dma_ring_count(board(dev));
+		    (priv(dev)->ai_dma_index +
+		     1) % ai_dma_ring_count(board(dev));
 
 		DEBUG_PRINT("next buffer addr 0x%lx\n",
-			(unsigned long)priv(dev)->ai_buffer_bus_addr[priv(dev)->
-				ai_dma_index]);
+			    (unsigned long)priv(dev)->
+			    ai_buffer_bus_addr[priv(dev)->ai_dma_index]);
 		DEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);
 	}
 	/* XXX check for dma ring buffer overrun (use end-of-chain bit to mark last
@@ -2950,7 +3017,7 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 }
 
 void handle_ai_interrupt(struct comedi_device *dev, unsigned short status,
-	unsigned int plx_status)
+			 unsigned int plx_status)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
@@ -2968,7 +3035,7 @@ void handle_ai_interrupt(struct comedi_device *dev, unsigned short status,
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 	if (plx_status & ICS_DMA1_A) {	/*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-			priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
 
 		if (dma1_status & PLX_DMA_EN_BIT) {
@@ -2983,9 +3050,9 @@ void handle_ai_interrupt(struct comedi_device *dev, unsigned short status,
 
 	/*  drain fifo with pio */
 	if ((status & ADC_DONE_BIT) ||
-		((cmd->flags & TRIG_WAKE_EOS) &&
-			(status & ADC_INTR_PENDING_BIT) &&
-			(board(dev)->layout != LAYOUT_4020))) {
+	    ((cmd->flags & TRIG_WAKE_EOS) &&
+	     (status & ADC_INTR_PENDING_BIT) &&
+	     (board(dev)->layout != LAYOUT_4020))) {
 		DEBUG_PRINT("pio fifo drain\n");
 		spin_lock_irqsave(&dev->spinlock, flags);
 		if (priv(dev)->ai_cmd_running) {
@@ -2996,7 +3063,7 @@ void handle_ai_interrupt(struct comedi_device *dev, unsigned short status,
 	}
 	/*  if we are have all the data, then quit */
 	if ((cmd->stop_src == TRIG_COUNT && priv(dev)->ai_count <= 0) ||
-		(cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT))) {
+	    (cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT))) {
 		async->events |= COMEDI_CB_EOA;
 	}
 
@@ -3026,14 +3093,15 @@ static int last_ao_dma_load_completed(struct comedi_device *dev)
 		return 0;
 
 	transfer_address =
-		readl(priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
+	    readl(priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
 	if (transfer_address != priv(dev)->ao_buffer_bus_addr[buffer_index])
 		return 0;
 
 	return 1;
 }
 
-static int ao_stopped_by_error(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static int ao_stopped_by_error(struct comedi_device *dev,
+			       const struct comedi_cmd *cmd)
 {
 	if (cmd->stop_src == TRIG_NONE)
 		return 1;
@@ -3047,10 +3115,10 @@ static int ao_stopped_by_error(struct comedi_device *dev, const struct comedi_cm
 }
 
 static inline int ao_dma_needs_restart(struct comedi_device *dev,
-	unsigned short dma_status)
+				       unsigned short dma_status)
 {
 	if ((dma_status & PLX_DMA_DONE_BIT) == 0 ||
-		(dma_status & PLX_DMA_EN_BIT) == 0)
+	    (dma_status & PLX_DMA_EN_BIT) == 0)
 		return 0;
 	if (last_ao_dma_load_completed(dev))
 		return 0;
@@ -3063,7 +3131,7 @@ static void restart_ao_dma(struct comedi_device *dev)
 	unsigned int dma_desc_bits;
 
 	dma_desc_bits =
-		readl(priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+	    readl(priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 	dma_desc_bits &= ~PLX_END_OF_CHAIN_BIT;
 	DEBUG_PRINT("restarting ao dma, descriptor reg 0x%x\n", dma_desc_bits);
 	load_first_dma_descriptor(dev, 0, dma_desc_bits);
@@ -3071,8 +3139,8 @@ static void restart_ao_dma(struct comedi_device *dev)
 	dma_start_sync(dev, 0);
 }
 
-static void handle_ao_interrupt(struct comedi_device *dev, unsigned short status,
-	unsigned int plx_status)
+static void handle_ao_interrupt(struct comedi_device *dev,
+				unsigned short status, unsigned int plx_status)
 {
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_async *async;
@@ -3091,12 +3159,12 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned short status
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		if ((dma0_status & PLX_DMA_EN_BIT)
-			&& !(dma0_status & PLX_DMA_DONE_BIT))
+		    && !(dma0_status & PLX_DMA_DONE_BIT))
 			writeb(PLX_DMA_EN_BIT | PLX_CLEAR_DMA_INTR_BIT,
-				priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+			       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 		else
 			writeb(PLX_CLEAR_DMA_INTR_BIT,
-				priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+			       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		DEBUG_PRINT("dma0 status 0x%x\n", dma0_status);
 		if (dma0_status & PLX_DMA_EN_BIT) {
@@ -3114,11 +3182,11 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned short status
 		if (ao_stopped_by_error(dev, cmd))
 			async->events |= COMEDI_CB_ERROR;
 		DEBUG_PRINT("plx dma0 desc reg 0x%x\n",
-			readl(priv(dev)->plx9080_iobase +
-				PLX_DMA0_DESCRIPTOR_REG));
+			    readl(priv(dev)->plx9080_iobase +
+				  PLX_DMA0_DESCRIPTOR_REG));
 		DEBUG_PRINT("plx dma0 address reg 0x%x\n",
-			readl(priv(dev)->plx9080_iobase +
-				PLX_DMA0_PCI_ADDRESS_REG));
+			    readl(priv(dev)->plx9080_iobase +
+				  PLX_DMA0_PCI_ADDRESS_REG));
 	}
 	cfc_handle_events(dev, s);
 }
@@ -3141,7 +3209,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	 * interrupt handler */
 	if (dev->attached == 0) {
 		DEBUG_PRINT("cb_pcidas64: premature interrupt, ignoring",
-			status);
+			    status);
 		return IRQ_HANDLED;
 	}
 	handle_ai_interrupt(dev, status, plx_status);
@@ -3192,7 +3260,7 @@ static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	int range = CR_RANGE(insn->chanspec);
@@ -3203,14 +3271,14 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	/*  set range */
 	set_dac_range_bits(dev, &priv(dev)->dac_control1_bits, chan, range);
 	writew(priv(dev)->dac_control1_bits,
-		priv(dev)->main_iobase + DAC_CONTROL1_REG);
+	       priv(dev)->main_iobase + DAC_CONTROL1_REG);
 
 	/*  write to channel */
 	if (board(dev)->layout == LAYOUT_4020) {
 		writew(data[0] & 0xff,
-			priv(dev)->main_iobase + dac_lsb_4020_reg(chan));
+		       priv(dev)->main_iobase + dac_lsb_4020_reg(chan));
 		writew((data[0] >> 8) & 0xf,
-			priv(dev)->main_iobase + dac_msb_4020_reg(chan));
+		       priv(dev)->main_iobase + dac_msb_4020_reg(chan));
 	} else {
 		writew(data[0], priv(dev)->main_iobase + dac_convert_reg(chan));
 	}
@@ -3221,18 +3289,20 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return 1;
 }
 
-static int ao_readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ao_readback_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = priv(dev)->ao_value[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static void set_dac_control0_reg(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static void set_dac_control0_reg(struct comedi_device *dev,
+				 const struct comedi_cmd *cmd)
 {
 	unsigned int bits = DAC_ENABLE_BIT | WAVEFORM_GATE_LEVEL_BIT |
-		WAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;
+	    WAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;
 
 	if (cmd->start_src == TRIG_EXT) {
 		bits |= WAVEFORM_TRIG_EXT_BITS;
@@ -3249,7 +3319,8 @@ static void set_dac_control0_reg(struct comedi_device *dev, const struct comedi_
 	writew(bits, priv(dev)->main_iobase + DAC_CONTROL0_REG);
 }
 
-static void set_dac_control1_reg(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static void set_dac_control1_reg(struct comedi_device *dev,
+				 const struct comedi_cmd *cmd)
 {
 	int i;
 
@@ -3259,14 +3330,15 @@ static void set_dac_control1_reg(struct comedi_device *dev, const struct comedi_
 		channel = CR_CHAN(cmd->chanlist[i]);
 		range = CR_RANGE(cmd->chanlist[i]);
 		set_dac_range_bits(dev, &priv(dev)->dac_control1_bits, channel,
-			range);
+				   range);
 	}
 	priv(dev)->dac_control1_bits |= DAC_SW_GATE_BIT;
 	writew(priv(dev)->dac_control1_bits,
-		priv(dev)->main_iobase + DAC_CONTROL1_REG);
+	       priv(dev)->main_iobase + DAC_CONTROL1_REG);
 }
 
-static void set_dac_select_reg(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static void set_dac_select_reg(struct comedi_device *dev,
+			       const struct comedi_cmd *cmd)
 {
 	uint16_t bits;
 	unsigned int first_channel, last_channel;
@@ -3281,7 +3353,8 @@ static void set_dac_select_reg(struct comedi_device *dev, const struct comedi_cm
 	writew(bits, priv(dev)->main_iobase + DAC_SELECT_REG);
 }
 
-static void set_dac_interval_regs(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static void set_dac_interval_regs(struct comedi_device *dev,
+				  const struct comedi_cmd *cmd)
 {
 	unsigned int divisor;
 
@@ -3294,13 +3367,13 @@ static void set_dac_interval_regs(struct comedi_device *dev, const struct comedi
 		divisor = max_counter_value;
 	}
 	writew(divisor & 0xffff,
-		priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_LOWER_REG);
+	       priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_LOWER_REG);
 	writew((divisor >> 16) & 0xff,
-		priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_UPPER_REG);
+	       priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_UPPER_REG);
 }
 
 static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
-	const struct comedi_cmd *cmd)
+				       const struct comedi_cmd *cmd)
 {
 	unsigned int num_bytes, buffer_index, prev_buffer_index;
 	unsigned int next_bits;
@@ -3309,7 +3382,7 @@ static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 	prev_buffer_index = prev_ao_dma_index(dev);
 
 	DEBUG_PRINT("attempting to load ao buffer %i (0x%x)\n", buffer_index,
-		priv(dev)->ao_buffer_bus_addr[buffer_index]);
+		    priv(dev)->ao_buffer_bus_addr[buffer_index]);
 
 	num_bytes = comedi_buf_read_n_available(dev->write_subdev->async);
 	if (num_bytes > DMA_BUFFER_SIZE)
@@ -3324,9 +3397,11 @@ static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
 	DEBUG_PRINT("loading %i bytes\n", num_bytes);
 
 	num_bytes = cfc_read_array_from_buffer(dev->write_subdev,
-		priv(dev)->ao_buffer[buffer_index], num_bytes);
+					       priv(dev)->
+					       ao_buffer[buffer_index],
+					       num_bytes);
 	priv(dev)->ao_dma_desc[buffer_index].transfer_size =
-		cpu_to_le32(num_bytes);
+	    cpu_to_le32(num_bytes);
 	/* set end of chain bit so we catch underruns */
 	next_bits = le32_to_cpu(priv(dev)->ao_dma_desc[buffer_index].next);
 	next_bits |= PLX_END_OF_CHAIN_BIT;
@@ -3348,7 +3423,7 @@ static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	unsigned int num_bytes;
 	unsigned int next_transfer_addr;
 	void *pci_addr_reg =
-		priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+	    priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 	unsigned int buffer_index;
 
 	do {
@@ -3356,10 +3431,10 @@ static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 		/* don't overwrite data that hasn't been transferred yet */
 		next_transfer_addr = readl(pci_addr_reg);
 		if (next_transfer_addr >=
-			priv(dev)->ao_buffer_bus_addr[buffer_index]
-			&& next_transfer_addr <
-			priv(dev)->ao_buffer_bus_addr[buffer_index] +
-			DMA_BUFFER_SIZE)
+		    priv(dev)->ao_buffer_bus_addr[buffer_index]
+		    && next_transfer_addr <
+		    priv(dev)->ao_buffer_bus_addr[buffer_index] +
+		    DMA_BUFFER_SIZE)
 			return;
 		num_bytes = load_ao_dma_buffer(dev, cmd);
 	} while (num_bytes >= DMA_BUFFER_SIZE);
@@ -3377,13 +3452,14 @@ static int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 
 	num_bytes = (DAC_FIFO_SIZE / 2) * bytes_in_sample;
 	if (cmd->stop_src == TRIG_COUNT &&
-		num_bytes / bytes_in_sample > priv(dev)->ao_count)
+	    num_bytes / bytes_in_sample > priv(dev)->ao_count)
 		num_bytes = priv(dev)->ao_count * bytes_in_sample;
 	num_bytes = cfc_read_array_from_buffer(dev->write_subdev,
-		priv(dev)->ao_bounce_buffer, num_bytes);
+					       priv(dev)->ao_bounce_buffer,
+					       num_bytes);
 	for (i = 0; i < num_bytes / bytes_in_sample; i++) {
 		writew(priv(dev)->ao_bounce_buffer[i],
-			priv(dev)->main_iobase + DAC_FIFO_REG);
+		       priv(dev)->main_iobase + DAC_FIFO_REG);
 	}
 	priv(dev)->ao_count -= num_bytes / bytes_in_sample;
 	if (cmd->stop_src == TRIG_COUNT && priv(dev)->ao_count == 0)
@@ -3427,7 +3503,7 @@ static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	set_dac_select_reg(dev, cmd);
 	set_dac_interval_regs(dev, cmd);
 	load_first_dma_descriptor(dev, 0, priv(dev)->ao_dma_desc_bus_addr |
-		PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT);
+				  PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT);
 
 	set_dac_control1_reg(dev, cmd);
 	s->async->inttrig = ao_inttrig;
@@ -3436,7 +3512,7 @@ static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trig_num)
+		      unsigned int trig_num)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
@@ -3459,7 +3535,7 @@ static int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+		      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -3502,14 +3578,14 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 
 	/*  compatibility check */
 	if (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
+	    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
 		err++;
 
 	if (err)
@@ -3523,9 +3599,9 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			err++;
 		}
 		if (get_ao_divisor(cmd->scan_begin_arg,
-				cmd->flags) > max_counter_value) {
+				   cmd->flags) > max_counter_value) {
 			cmd->scan_begin_arg =
-				(max_counter_value + 2) * TIMER_BASE;
+			    (max_counter_value + 2) * TIMER_BASE;
 			err++;
 		}
 	}
@@ -3547,8 +3623,7 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp_arg = cmd->scan_begin_arg;
 		cmd->scan_begin_arg =
-			get_divisor(cmd->scan_begin_arg,
-			cmd->flags) * TIMER_BASE;
+		    get_divisor(cmd->scan_begin_arg, cmd->flags) * TIMER_BASE;
 		if (tmp_arg != cmd->scan_begin_arg)
 			err++;
 	}
@@ -3561,7 +3636,7 @@ static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) != first_channel + i) {
 				comedi_error(dev,
-					"chanlist must use consecutive channels");
+					     "chanlist must use consecutive channels");
 				err++;
 				break;
 			}
@@ -3603,7 +3678,7 @@ static int dio_callback_4020(int dir, int port, int data, unsigned long iobase)
 }
 
 static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bits;
 
@@ -3616,7 +3691,7 @@ static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] &= 0xf;
 	/*  zero bits we are going to change */
@@ -3631,8 +3706,9 @@ static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
 	return 2;
 }
 
-static int dio_60xx_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dio_60xx_config_insn(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int mask;
 
@@ -3653,19 +3729,19 @@ static int dio_60xx_config_insn(struct comedi_device *dev, struct comedi_subdevi
 	}
 
 	writeb(s->io_bits,
-		priv(dev)->dio_counter_iobase + DIO_DIRECTION_60XX_REG);
+	       priv(dev)->dio_counter_iobase + DIO_DIRECTION_60XX_REG);
 
 	return 1;
 }
 
 static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
 		s->state |= (data[0] & data[1]);
 		writeb(s->state,
-			priv(dev)->dio_counter_iobase + DIO_DATA_60XX_REG);
+		       priv(dev)->dio_counter_iobase + DIO_DATA_60XX_REG);
 	}
 
 	data[1] = readb(priv(dev)->dio_counter_iobase + DIO_DATA_60XX_REG);
@@ -3674,7 +3750,7 @@ static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static void caldac_write(struct comedi_device *dev, unsigned int channel,
-	unsigned int value)
+			 unsigned int value)
 {
 	priv(dev)->caldac_state[channel] = value;
 
@@ -3691,8 +3767,9 @@ static void caldac_write(struct comedi_device *dev, unsigned int channel,
 	}
 }
 
-static int calib_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int calib_write_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -3706,8 +3783,9 @@ static int calib_write_insn(struct comedi_device *dev, struct comedi_subdevice *
 	return 1;
 }
 
-static int calib_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int calib_read_insn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -3717,7 +3795,7 @@ static int calib_read_insn(struct comedi_device *dev, struct comedi_subdevice *s
 }
 
 static void ad8402_write(struct comedi_device *dev, unsigned int channel,
-	unsigned int value)
+			 unsigned int value)
 {
 	static const int bitstream_length = 10;
 	unsigned int bit, register_bits;
@@ -3739,7 +3817,7 @@ static void ad8402_write(struct comedi_device *dev, unsigned int channel,
 		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
 		udelay(ad8402_udelay);
 		writew(register_bits | SERIAL_CLOCK_BIT,
-			priv(dev)->main_iobase + CALIBRATION_REG);
+		       priv(dev)->main_iobase + CALIBRATION_REG);
 	}
 
 	udelay(ad8402_udelay);
@@ -3747,8 +3825,9 @@ static void ad8402_write(struct comedi_device *dev, unsigned int channel,
 }
 
 /* for pci-das6402/16, channel 0 is analog input gain and channel 1 is offset */
-static int ad8402_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ad8402_write_insn(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -3764,8 +3843,9 @@ static int ad8402_write_insn(struct comedi_device *dev, struct comedi_subdevice
 	return 1;
 }
 
-static int ad8402_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ad8402_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -3781,7 +3861,7 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 	unsigned int bitstream = (read_command << 8) | address;
 	unsigned int bit;
 	void *const plx_control_addr =
-		priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
+	    priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
 	uint16_t value;
 	static const int value_length = 16;
 	static const int eeprom_udelay = 1;
@@ -3836,8 +3916,9 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 	return value;
 }
 
-static int eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int eeprom_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = read_eeprom(dev, CR_CHAN(insn->chanspec));
 
@@ -3853,7 +3934,7 @@ static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 	unsigned int convert_divisor = 0, scan_divisor;
 	static const int min_convert_divisor = 3;
 	static const int max_convert_divisor =
-		max_counter_value + min_convert_divisor;
+	    max_counter_value + min_convert_divisor;
 	static const int min_scan_divisor_4020 = 2;
 	unsigned long long max_scan_divisor, min_scan_divisor;
 
@@ -3862,7 +3943,7 @@ static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 			cmd->convert_arg = 0;
 		} else {
 			convert_divisor =
-				get_divisor(cmd->convert_arg, cmd->flags);
+			    get_divisor(cmd->convert_arg, cmd->flags);
 			if (convert_divisor > max_convert_divisor)
 				convert_divisor = max_convert_divisor;
 			if (convert_divisor < min_convert_divisor)
@@ -3878,8 +3959,8 @@ static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 			/*  XXX check for integer overflows */
 			min_scan_divisor = convert_divisor * cmd->chanlist_len;
 			max_scan_divisor =
-				(convert_divisor * cmd->chanlist_len - 1) +
-				max_counter_value;
+			    (convert_divisor * cmd->chanlist_len - 1) +
+			    max_counter_value;
 		} else {
 			min_scan_divisor = min_scan_divisor_4020;
 			max_scan_divisor = max_counter_value + min_scan_divisor;
@@ -3931,7 +4012,8 @@ static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 	num_fifo_entries = num_samples / fifo->sample_packing_ratio;
 
 	retval = set_ai_fifo_segment_length(dev,
-		num_fifo_entries / fifo->num_segments);
+					    num_fifo_entries /
+					    fifo->num_segments);
 	if (retval < 0)
 		return retval;
 
@@ -3946,12 +4028,12 @@ static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 static unsigned int ai_fifo_size(struct comedi_device *dev)
 {
 	return priv(dev)->ai_fifo_segment_length *
-		board(dev)->ai_fifo->num_segments *
-		board(dev)->ai_fifo->sample_packing_ratio;
+	    board(dev)->ai_fifo->num_segments *
+	    board(dev)->ai_fifo->sample_packing_ratio;
 }
 
 static int set_ai_fifo_segment_length(struct comedi_device *dev,
-	unsigned int num_entries)
+				      unsigned int num_entries)
 {
 	static const int increment_size = 0x100;
 	const struct hw_fifo_info *const fifo = board(dev)->ai_fifo;
@@ -3970,12 +4052,12 @@ static int set_ai_fifo_segment_length(struct comedi_device *dev,
 	priv(dev)->fifo_size_bits &= ~fifo->fifo_size_reg_mask;
 	priv(dev)->fifo_size_bits |= bits;
 	writew(priv(dev)->fifo_size_bits,
-		priv(dev)->main_iobase + FIFO_SIZE_REG);
+	       priv(dev)->main_iobase + FIFO_SIZE_REG);
 
 	priv(dev)->ai_fifo_segment_length = num_increments * increment_size;
 
 	DEBUG_PRINT("set hardware fifo segment length to %i\n",
-		priv(dev)->ai_fifo_segment_length);
+		    priv(dev)->ai_fifo_segment_length);
 
 	return priv(dev)->ai_fifo_segment_length;
 }
@@ -4002,7 +4084,7 @@ static int set_ai_fifo_segment_length(struct comedi_device *dev,
 */
 
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-	uint8_t value)
+			     uint8_t value)
 {
 	static const int num_caldac_channels = 8;
 	static const int bitstream_length = 11;
@@ -4033,8 +4115,8 @@ static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 }
 
 /* 4020 caldacs */
-static int caldac_i2c_write(struct comedi_device *dev, unsigned int caldac_channel,
-	unsigned int value)
+static int caldac_i2c_write(struct comedi_device *dev,
+			    unsigned int caldac_channel, unsigned int value)
 {
 	uint8_t serial_bytes[3];
 	uint8_t i2c_addr;
@@ -4108,8 +4190,8 @@ static void i2c_set_sda(struct comedi_device *dev, int state)
 		priv(dev)->plx_control_bits &= ~data_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 		udelay(i2c_high_udelay);
-	} else			/*  set data line low */
-	{
+	} else {		/*  set data line low */
+
 		priv(dev)->plx_control_bits |= data_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 		udelay(i2c_low_udelay);
@@ -4127,8 +4209,8 @@ static void i2c_set_scl(struct comedi_device *dev, int state)
 		priv(dev)->plx_control_bits &= ~clock_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 		udelay(i2c_high_udelay);
-	} else			/*  set clock line low */
-	{
+	} else {		/*  set clock line low */
+
 		priv(dev)->plx_control_bits |= clock_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 		udelay(i2c_low_udelay);
@@ -4180,7 +4262,7 @@ static void i2c_stop(struct comedi_device *dev)
 }
 
 static void i2c_write(struct comedi_device *dev, unsigned int address,
-	const uint8_t *data, unsigned int length)
+		      const uint8_t * data, unsigned int length)
 {
 	unsigned int i;
 	uint8_t bitstream;

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index caa8b568871d..210b462868b7 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -98,7 +98,7 @@ known. If you have such a board, please file a bug report at
 /* #define PCIDAS64_DEBUG         enable debugging code */
 
 #ifdef PCIDAS64_DEBUG
-#define DEBUG_PRINT(format, args...)  rt_printk(format , ## args)
+#define DEBUG_PRINT(format, args...)  printk(format , ## args)
 #else
 #define DEBUG_PRINT(format, args...)
 #endif
@@ -1535,7 +1535,7 @@ static void init_stc_registers(struct comedi_device *dev)
 	uint16_t bits;
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 
 	/*  bit should be set for 6025, although docs say boards with <= 16 chans should be cleared XXX */
 	if (1)
@@ -1556,7 +1556,7 @@ static void init_stc_registers(struct comedi_device *dev)
 	writew(0, priv(dev)->main_iobase + DAQ_SYNC_REG);
 	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  set fifos to maximum size */
 	priv(dev)->fifo_size_bits |= DAC_FIFO_BITS;
@@ -1794,7 +1794,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	init_plx9080(dev);
 	init_stc_registers(dev);
 	/*  get irq */
-	if (comedi_request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
+	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
 			"cb_pcidas64", dev)) {
 		printk(" unable to allocate irq %u\n", pcidev->irq);
 		return -EINVAL;
@@ -1825,7 +1825,7 @@ static int detach(struct comedi_device *dev)
 	printk("comedi%d: cb_pcidas: remove\n", dev->minor);
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (priv(dev)) {
 		if (priv(dev)->hw_dev) {
 			if (priv(dev)->plx9080_iobase) {
@@ -1895,14 +1895,14 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	/*  4020 generates dac done interrupts even though they are disabled */
 	disable_ai_pacing(dev);
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	if (insn->chanspec & CR_ALT_FILTER)
 		priv(dev)->adc_control1_bits |= ADC_DITHER_BIT;
 	else
 		priv(dev)->adc_control1_bits &= ~ADC_DITHER_BIT;
 	writew(priv(dev)->adc_control1_bits,
 		priv(dev)->main_iobase + ADC_CONTROL1_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (board(dev)->layout != LAYOUT_4020) {
 		/*  use internal queue */
@@ -1995,12 +1995,12 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 				if (pipe_full_bits(bits))
 					break;
 			}
-			comedi_udelay(1);
+			udelay(1);
 		}
 		DEBUG_PRINT(" looped %i times waiting for data\n", i);
 		if (i == timeout) {
 			comedi_error(dev, " analog input read insn timed out");
-			rt_printk(" status 0x%x\n", bits);
+			printk(" status 0x%x\n", bits);
 			return -ETIME;
 		}
 		if (board(dev)->layout == LAYOUT_4020)
@@ -2357,11 +2357,11 @@ static void disable_ai_pacing(struct comedi_device *dev)
 
 	disable_ai_interrupts(dev);
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	priv(dev)->adc_control1_bits &= ~ADC_SW_GATE_BIT;
 	writew(priv(dev)->adc_control1_bits,
 		priv(dev)->main_iobase + ADC_CONTROL1_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* disable pacing, triggering, etc */
 	writew(ADC_DMA_DISABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT,
@@ -2372,14 +2372,14 @@ static void disable_ai_interrupts(struct comedi_device *dev)
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	priv(dev)->intr_enable_bits &=
 		~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &
 		~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &
 		~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;
 	writew(priv(dev)->intr_enable_bits,
 		priv(dev)->main_iobase + INTR_ENABLE_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
 }
@@ -2397,12 +2397,12 @@ static void enable_ai_interrupts(struct comedi_device *dev, const struct comedi_
 		if (board(dev)->layout != LAYOUT_4020)
 			bits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;
 	}
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	priv(dev)->intr_enable_bits |= bits;
 	writew(priv(dev)->intr_enable_bits,
 		priv(dev)->main_iobase + INTR_ENABLE_REG);
 	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static uint32_t ai_convert_counter_6xxx(const struct comedi_device *dev,
@@ -2488,7 +2488,7 @@ static inline void dma_start_sync(struct comedi_device *dev, unsigned int channe
 	unsigned long flags;
 
 	/*  spinlock for plx dma control/status reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	if (channel)
 		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
 			PLX_CLEAR_DMA_INTR_BIT,
@@ -2497,7 +2497,7 @@ static inline void dma_start_sync(struct comedi_device *dev, unsigned int channe
 		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
 			PLX_CLEAR_DMA_INTR_BIT,
 			priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
@@ -2701,7 +2701,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	enable_ai_interrupts(dev, cmd);
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	/* set mode, allow conversions through software gate */
 	priv(dev)->adc_control1_bits |= ADC_SW_GATE_BIT;
 	priv(dev)->adc_control1_bits &= ~ADC_DITHER_BIT;
@@ -2728,7 +2728,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	writew(priv(dev)->adc_control1_bits,
 		priv(dev)->main_iobase + ADC_CONTROL1_REG);
 	DEBUG_PRINT("control1 bits 0x%x\n", priv(dev)->adc_control1_bits);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  clear adc buffer */
 	writew(0, priv(dev)->main_iobase + ADC_BUFFER_CLEAR_REG);
@@ -2762,7 +2762,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		writew(bits, priv(dev)->main_iobase + DAQ_ATRIG_LOW_4020_REG);
 	}
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 
 	/* enable pacing, triggering, etc */
 	bits = ADC_ENABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT;
@@ -2782,7 +2782,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	priv(dev)->ai_cmd_running = 1;
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  start aquisition */
 	if (cmd->start_src == TRIG_NOW) {
@@ -2842,7 +2842,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 		}
 
 		if (num_samples < 0) {
-			rt_printk(" cb_pcidas64: bug! num_samples < 0\n");
+			printk(" cb_pcidas64: bug! num_samples < 0\n");
 			break;
 		}
 
@@ -2964,7 +2964,7 @@ void handle_ai_interrupt(struct comedi_device *dev, unsigned short status,
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
 	/*  spin lock makes sure noone else changes plx dma control reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 	if (plx_status & ICS_DMA1_A) {	/*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
@@ -2976,7 +2976,7 @@ void handle_ai_interrupt(struct comedi_device *dev, unsigned short status,
 		}
 		DEBUG_PRINT(" cleared dma ch1 interrupt\n");
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (status & ADC_DONE_BIT)
 		DEBUG_PRINT("adc done interrupt\n");
@@ -2987,12 +2987,12 @@ void handle_ai_interrupt(struct comedi_device *dev, unsigned short status,
 			(status & ADC_INTR_PENDING_BIT) &&
 			(board(dev)->layout != LAYOUT_4020))) {
 		DEBUG_PRINT("pio fifo drain\n");
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		if (priv(dev)->ai_cmd_running) {
-			comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+			spin_unlock_irqrestore(&dev->spinlock, flags);
 			pio_drain_ai_fifo(dev);
 		} else
-			comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+			spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 	/*  if we are have all the data, then quit */
 	if ((cmd->stop_src == TRIG_COUNT && priv(dev)->ai_count <= 0) ||
@@ -3087,7 +3087,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned short status
 	cmd = &async->cmd;
 
 	/*  spin lock makes sure noone else changes plx dma control reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		if ((dma0_status & PLX_DMA_EN_BIT)
@@ -3097,7 +3097,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned short status
 		else
 			writeb(PLX_CLEAR_DMA_INTR_BIT,
 				priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		DEBUG_PRINT("dma0 status 0x%x\n", dma0_status);
 		if (dma0_status & PLX_DMA_EN_BIT) {
 			load_ao_dma(dev, cmd);
@@ -3107,7 +3107,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned short status
 		}
 		DEBUG_PRINT(" cleared dma ch0 interrupt\n");
 	} else
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if ((status & DAC_DONE_BIT)) {
 		async->events |= COMEDI_CB_EOA;
@@ -3164,24 +3164,24 @@ void abort_dma(struct comedi_device *dev, unsigned int channel)
 	unsigned long flags;
 
 	/*  spinlock for plx dma control/status reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 
 	plx9080_abort_dma(priv(dev)->plx9080_iobase, channel);
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	if (priv(dev)->ai_cmd_running == 0) {
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		return 0;
 	}
 	priv(dev)->ai_cmd_running = 0;
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	disable_ai_pacing(dev);
 
@@ -3722,12 +3722,12 @@ static void ad8402_write(struct comedi_device *dev, unsigned int channel,
 	static const int bitstream_length = 10;
 	unsigned int bit, register_bits;
 	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
-	static const int ad8402_comedi_udelay = 1;
+	static const int ad8402_udelay = 1;
 
 	priv(dev)->ad8402_state[channel] = value;
 
 	register_bits = SELECT_8402_64XX_BIT;
-	comedi_udelay(ad8402_comedi_udelay);
+	udelay(ad8402_udelay);
 	writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
 
 	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
@@ -3735,14 +3735,14 @@ static void ad8402_write(struct comedi_device *dev, unsigned int channel,
 			register_bits |= SERIAL_DATA_IN_BIT;
 		else
 			register_bits &= ~SERIAL_DATA_IN_BIT;
-		comedi_udelay(ad8402_comedi_udelay);
+		udelay(ad8402_udelay);
 		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
-		comedi_udelay(ad8402_comedi_udelay);
+		udelay(ad8402_udelay);
 		writew(register_bits | SERIAL_CLOCK_BIT,
 			priv(dev)->main_iobase + CALIBRATION_REG);
 	}
 
-	comedi_udelay(ad8402_comedi_udelay);
+	udelay(ad8402_udelay);
 	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
 }
 
@@ -3784,32 +3784,32 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 		priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
 	uint16_t value;
 	static const int value_length = 16;
-	static const int eeprom_comedi_udelay = 1;
+	static const int eeprom_udelay = 1;
 
-	comedi_udelay(eeprom_comedi_udelay);
+	udelay(eeprom_udelay);
 	priv(dev)->plx_control_bits &= ~CTL_EE_CLK & ~CTL_EE_CS;
 	/*  make sure we don't send anything to the i2c bus on 4020 */
 	priv(dev)->plx_control_bits |= CTL_USERO;
 	writel(priv(dev)->plx_control_bits, plx_control_addr);
 	/*  activate serial eeprom */
-	comedi_udelay(eeprom_comedi_udelay);
+	udelay(eeprom_udelay);
 	priv(dev)->plx_control_bits |= CTL_EE_CS;
 	writel(priv(dev)->plx_control_bits, plx_control_addr);
 
 	/*  write read command and desired memory address */
 	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
 		/*  set bit to be written */
-		comedi_udelay(eeprom_comedi_udelay);
+		udelay(eeprom_udelay);
 		if (bitstream & bit)
 			priv(dev)->plx_control_bits |= CTL_EE_W;
 		else
 			priv(dev)->plx_control_bits &= ~CTL_EE_W;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 		/*  clock in bit */
-		comedi_udelay(eeprom_comedi_udelay);
+		udelay(eeprom_udelay);
 		priv(dev)->plx_control_bits |= CTL_EE_CLK;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(eeprom_comedi_udelay);
+		udelay(eeprom_udelay);
 		priv(dev)->plx_control_bits &= ~CTL_EE_CLK;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 	}
@@ -3817,19 +3817,19 @@ static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 	value = 0;
 	for (bit = 1 << (value_length - 1); bit; bit >>= 1) {
 		/*  clock out bit */
-		comedi_udelay(eeprom_comedi_udelay);
+		udelay(eeprom_udelay);
 		priv(dev)->plx_control_bits |= CTL_EE_CLK;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(eeprom_comedi_udelay);
+		udelay(eeprom_udelay);
 		priv(dev)->plx_control_bits &= ~CTL_EE_CLK;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(eeprom_comedi_udelay);
+		udelay(eeprom_udelay);
 		if (readl(plx_control_addr) & CTL_EE_R)
 			value |= bit;
 	}
 
 	/*  deactivate eeprom serial input */
-	comedi_udelay(eeprom_comedi_udelay);
+	udelay(eeprom_udelay);
 	priv(dev)->plx_control_bits &= ~CTL_EE_CS;
 	writel(priv(dev)->plx_control_bits, plx_control_addr);
 
@@ -4018,17 +4018,17 @@ static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 		register_bits = 0;
 		if (bitstream & bit)
 			register_bits |= SERIAL_DATA_IN_BIT;
-		comedi_udelay(caldac_8800_udelay);
+		udelay(caldac_8800_udelay);
 		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
 		register_bits |= SERIAL_CLOCK_BIT;
-		comedi_udelay(caldac_8800_udelay);
+		udelay(caldac_8800_udelay);
 		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
 	}
-	comedi_udelay(caldac_8800_udelay);
+	udelay(caldac_8800_udelay);
 	writew(SELECT_8800_BIT, priv(dev)->main_iobase + CALIBRATION_REG);
-	comedi_udelay(caldac_8800_udelay);
+	udelay(caldac_8800_udelay);
 	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
-	comedi_udelay(caldac_8800_udelay);
+	udelay(caldac_8800_udelay);
 	return 0;
 }
 
@@ -4094,8 +4094,8 @@ static int caldac_i2c_write(struct comedi_device *dev, unsigned int caldac_chann
 }
 
 /* Their i2c requires a huge delay on setting clock or data high for some reason */
-static const int i2c_high_comedi_udelay = 1000;
-static const int i2c_low_comedi_udelay = 10;
+static const int i2c_high_udelay = 1000;
+static const int i2c_low_udelay = 10;
 
 /* set i2c data line high or low */
 static void i2c_set_sda(struct comedi_device *dev, int state)
@@ -4107,12 +4107,12 @@ static void i2c_set_sda(struct comedi_device *dev, int state)
 		/*  set data line high */
 		priv(dev)->plx_control_bits &= ~data_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(i2c_high_comedi_udelay);
+		udelay(i2c_high_udelay);
 	} else			/*  set data line low */
 	{
 		priv(dev)->plx_control_bits |= data_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(i2c_low_comedi_udelay);
+		udelay(i2c_low_udelay);
 	}
 }
 
@@ -4126,12 +4126,12 @@ static void i2c_set_scl(struct comedi_device *dev, int state)
 		/*  set clock line high */
 		priv(dev)->plx_control_bits &= ~clock_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(i2c_high_comedi_udelay);
+		udelay(i2c_high_udelay);
 	} else			/*  set clock line low */
 	{
 		priv(dev)->plx_control_bits |= clock_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(i2c_low_comedi_udelay);
+		udelay(i2c_low_udelay);
 	}
 }
 

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index adce530adc53..caa8b568871d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1014,12 +1014,6 @@ static const struct pcidas64_board pcidas64_boards[] = {
 #endif
 };
 
-/* Number of boards in cb_pcidas_boards */
-static inline unsigned int num_boards(void)
-{
-	return sizeof(pcidas64_boards) / sizeof(struct pcidas64_board);
-}
-
 static DEFINE_PCI_DEVICE_TABLE(pcidas64_pci_table) = {
 	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x001d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x001e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
@@ -1702,7 +1696,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
 			continue;
 		/*  loop through cards supported by this driver */
-		for (index = 0; index < num_boards(); index++) {
+		for (index = 0; index < ARRAY_SIZE(pcidas64_boards); index++) {
 			if (pcidas64_boards[index].device_id != pcidev->device)
 				continue;
 			/*  was a particular bus/slot requested? */

commit 814900c904140cfe7f3e48cabec06b3eec57e0ea
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:54 2009 -0400

    Staging: comedi: more fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 49dfd8f09e27..adce530adc53 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1137,73 +1137,73 @@ static struct comedi_driver driver_cb_pcidas = {
 	.detach = detach,
 };
 
-static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * subdev,
+static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ao_readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *subdev,
 	unsigned int trig_num);
-static int ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
+static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
 static irqreturn_t handle_interrupt(int irq, void *d);
-static int ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static int ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int dio_callback(int dir, int port, int data, unsigned long arg);
 static int dio_callback_4020(int dir, int port, int data, unsigned long arg);
-static int di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int dio_60xx_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int dio_60xx_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int calib_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int calib_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ad8402_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static void ad8402_write(struct comedi_device * dev, unsigned int channel,
+static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int dio_60xx_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int calib_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int calib_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int ad8402_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static void ad8402_write(struct comedi_device *dev, unsigned int channel,
 	unsigned int value);
-static int ad8402_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static void check_adc_timing(struct comedi_device * dev, struct comedi_cmd * cmd);
+static int ad8402_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd);
 static unsigned int get_divisor(unsigned int ns, unsigned int flags);
-static void i2c_write(struct comedi_device * dev, unsigned int address,
-	const uint8_t * data, unsigned int length);
-static void caldac_write(struct comedi_device * dev, unsigned int channel,
+static void i2c_write(struct comedi_device *dev, unsigned int address,
+	const uint8_t *data, unsigned int length);
+static void caldac_write(struct comedi_device *dev, unsigned int channel,
 	unsigned int value);
-static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
+static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 	uint8_t value);
 /* static int dac_1590_write(struct comedi_device *dev, unsigned int dac_a, unsigned int dac_b); */
-static int caldac_i2c_write(struct comedi_device * dev, unsigned int caldac_channel,
+static int caldac_i2c_write(struct comedi_device *dev, unsigned int caldac_channel,
 	unsigned int value);
-static void abort_dma(struct comedi_device * dev, unsigned int channel);
-static void disable_plx_interrupts(struct comedi_device * dev);
-static int set_ai_fifo_size(struct comedi_device * dev, unsigned int num_samples);
-static unsigned int ai_fifo_size(struct comedi_device * dev);
-static int set_ai_fifo_segment_length(struct comedi_device * dev,
+static void abort_dma(struct comedi_device *dev, unsigned int channel);
+static void disable_plx_interrupts(struct comedi_device *dev);
+static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples);
+static unsigned int ai_fifo_size(struct comedi_device *dev);
+static int set_ai_fifo_segment_length(struct comedi_device *dev,
 	unsigned int num_entries);
-static void disable_ai_pacing(struct comedi_device * dev);
-static void disable_ai_interrupts(struct comedi_device * dev);
-static void enable_ai_interrupts(struct comedi_device * dev, const struct comedi_cmd * cmd);
+static void disable_ai_pacing(struct comedi_device *dev);
+static void disable_ai_interrupts(struct comedi_device *dev);
+static void enable_ai_interrupts(struct comedi_device *dev, const struct comedi_cmd *cmd);
 static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags);
-static void load_ao_dma(struct comedi_device * dev, const struct comedi_cmd * cmd);
+static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd);
 
 COMEDI_PCI_INITCLEANUP(driver_cb_pcidas, pcidas64_pci_table);
 
-static unsigned int ai_range_bits_6xxx(const struct comedi_device * dev,
+static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
 	unsigned int range_index)
 {
 	const struct comedi_krange *range =

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 425c0f296455..49dfd8f09e27 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -560,24 +560,24 @@ struct pcidas64_board {
 };
 
 static const struct hw_fifo_info ai_fifo_4020 = {
-      num_segments:2,
-      max_segment_length:0x8000,
-      sample_packing_ratio:2,
-      fifo_size_reg_mask:0x7f,
+	.num_segments = 2,
+	.max_segment_length = 0x8000,
+	.sample_packing_ratio = 2,
+	.fifo_size_reg_mask = 0x7f,
 };
 
 static const struct hw_fifo_info ai_fifo_64xx = {
-      num_segments:4,
-      max_segment_length:0x800,
-      sample_packing_ratio:1,
-      fifo_size_reg_mask:0x3f,
+	.num_segments = 4,
+	.max_segment_length = 0x800,
+	.sample_packing_ratio = 1,
+	.fifo_size_reg_mask = 0x3f,
 };
 
 static const struct hw_fifo_info ai_fifo_60xx = {
-      num_segments:4,
-      max_segment_length:0x800,
-      sample_packing_ratio:1,
-      fifo_size_reg_mask:0x7f,
+	.num_segments = 4,
+	.max_segment_length = 0x800,
+	.sample_packing_ratio = 1,
+	.fifo_size_reg_mask = 0x7f,
 };
 
 /* maximum number of dma transfers we will chain together into a ring
@@ -597,84 +597,84 @@ static const int bytes_in_sample = 2;
 
 static const struct pcidas64_board pcidas64_boards[] = {
 	{
-	      name:	"pci-das6402/16",
-	      device_id:0x1d,
-	      ai_se_chans:64,
-	      ai_bits:	16,
-	      ai_speed:5000,
-	      ao_nchan:2,
-	      ao_bits:	16,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_64XX,
-	      ai_range_table:&ai_ranges_64xx,
-	      ao_range_table:&ao_ranges_64xx,
-	      ao_range_code:ao_range_code_64xx,
-	      ai_fifo:	&ai_fifo_64xx,
-	      has_8255:1,
+	.name = "pci-das6402/16",
+	.device_id = 0x1d,
+	.ai_se_chans = 64,
+	.ai_bits = 16,
+	.ai_speed = 5000,
+	.ao_nchan = 2,
+	.ao_bits = 16,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_64XX,
+	.ai_range_table = &ai_ranges_64xx,
+	.ao_range_table = &ao_ranges_64xx,
+	.ao_range_code = ao_range_code_64xx,
+	.ai_fifo = &ai_fifo_64xx,
+	.has_8255 = 1,
 		},
 	{
-	      name:	"pci-das6402/12",	/*  XXX check */
-	      device_id:0x1e,
-	      ai_se_chans:64,
-	      ai_bits:	12,
-	      ai_speed:5000,
-	      ao_nchan:2,
-	      ao_bits:	12,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_64XX,
-	      ai_range_table:&ai_ranges_64xx,
-	      ao_range_table:&ao_ranges_64xx,
-	      ao_range_code:ao_range_code_64xx,
-	      ai_fifo:	&ai_fifo_64xx,
-	      has_8255:1,
+	.name = "pci-das6402/12",	/*  XXX check */
+	.device_id = 0x1e,
+	.ai_se_chans = 64,
+	.ai_bits = 12,
+	.ai_speed = 5000,
+	.ao_nchan = 2,
+	.ao_bits = 12,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_64XX,
+	.ai_range_table = &ai_ranges_64xx,
+	.ao_range_table = &ao_ranges_64xx,
+	.ao_range_code = ao_range_code_64xx,
+	.ai_fifo = &ai_fifo_64xx,
+	.has_8255 = 1,
 		},
 	{
-	      name:	"pci-das64/m1/16",
-	      device_id:0x35,
-	      ai_se_chans:64,
-	      ai_bits:	16,
-	      ai_speed:1000,
-	      ao_nchan:2,
-	      ao_bits:	16,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_64XX,
-	      ai_range_table:&ai_ranges_64xx,
-	      ao_range_table:&ao_ranges_64xx,
-	      ao_range_code:ao_range_code_64xx,
-	      ai_fifo:	&ai_fifo_64xx,
-	      has_8255:1,
+	.name = "pci-das64/m1/16",
+	.device_id = 0x35,
+	.ai_se_chans = 64,
+	.ai_bits = 16,
+	.ai_speed = 1000,
+	.ao_nchan = 2,
+	.ao_bits = 16,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_64XX,
+	.ai_range_table = &ai_ranges_64xx,
+	.ao_range_table = &ao_ranges_64xx,
+	.ao_range_code = ao_range_code_64xx,
+	.ai_fifo = &ai_fifo_64xx,
+	.has_8255 = 1,
 		},
 	{
-	      name:	"pci-das64/m2/16",
-	      device_id:0x36,
-	      ai_se_chans:64,
-	      ai_bits:	16,
-	      ai_speed:500,
-	      ao_nchan:2,
-	      ao_bits:	16,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_64XX,
-	      ai_range_table:&ai_ranges_64xx,
-	      ao_range_table:&ao_ranges_64xx,
-	      ao_range_code:ao_range_code_64xx,
-	      ai_fifo:	&ai_fifo_64xx,
-	      has_8255:1,
+	.name = "pci-das64/m2/16",
+	.device_id = 0x36,
+	.ai_se_chans = 64,
+	.ai_bits = 16,
+	.ai_speed = 500,
+	.ao_nchan = 2,
+	.ao_bits = 16,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_64XX,
+	.ai_range_table = &ai_ranges_64xx,
+	.ao_range_table = &ao_ranges_64xx,
+	.ao_range_code = ao_range_code_64xx,
+	.ai_fifo = &ai_fifo_64xx,
+	.has_8255 = 1,
 		},
 	{
-	      name:	"pci-das64/m3/16",
-	      device_id:0x37,
-	      ai_se_chans:64,
-	      ai_bits:	16,
-	      ai_speed:333,
-	      ao_nchan:2,
-	      ao_bits:	16,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_64XX,
-	      ai_range_table:&ai_ranges_64xx,
-	      ao_range_table:&ao_ranges_64xx,
-	      ao_range_code:ao_range_code_64xx,
-	      ai_fifo:	&ai_fifo_64xx,
-	      has_8255:1,
+	.name = "pci-das64/m3/16",
+	.device_id = 0x37,
+	.ai_se_chans = 64,
+	.ai_bits = 16,
+	.ai_speed = 333,
+	.ao_nchan = 2,
+	.ao_bits = 16,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_64XX,
+	.ai_range_table = &ai_ranges_64xx,
+	.ao_range_table = &ao_ranges_64xx,
+	.ao_range_code = ao_range_code_64xx,
+	.ai_fifo = &ai_fifo_64xx,
+	.has_8255 = 1,
 		},
 	{
 		.name = "pci-das6013",
@@ -692,324 +692,324 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		.has_8255 = 0,
 		},
 	{
-	      name:	"pci-das6014",
-	      device_id:0x79,
-	      ai_se_chans:16,
-	      ai_bits:	16,
-	      ai_speed:5000,
-	      ao_nchan:2,
-	      ao_bits:	16,
-	      ao_scan_speed:100000,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_60xx,
-	      ao_range_table:&ao_ranges_60xx,
-	      ao_range_code:ao_range_code_60xx,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:0,
+	.name = "pci-das6014",
+	.device_id = 0x79,
+	.ai_se_chans = 16,
+	.ai_bits = 16,
+	.ai_speed = 5000,
+	.ao_nchan = 2,
+	.ao_bits = 16,
+	.ao_scan_speed = 100000,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_60xx,
+	.ao_range_table = &ao_ranges_60xx,
+	.ao_range_code = ao_range_code_60xx,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 0,
 		},
 	{
-	      name:	"pci-das6023",
-	      device_id:0x5d,
-	      ai_se_chans:16,
-	      ai_bits:	12,
-	      ai_speed:5000,
-	      ao_nchan:0,
-	      ao_scan_speed:100000,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_60xx,
-	      ao_range_table:&ao_ranges_60xx,
-	      ao_range_code:ao_range_code_60xx,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:1,
+	.name = "pci-das6023",
+	.device_id = 0x5d,
+	.ai_se_chans = 16,
+	.ai_bits = 12,
+	.ai_speed = 5000,
+	.ao_nchan = 0,
+	.ao_scan_speed = 100000,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_60xx,
+	.ao_range_table = &ao_ranges_60xx,
+	.ao_range_code = ao_range_code_60xx,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 1,
 		},
 	{
-	      name:	"pci-das6025",
-	      device_id:0x5e,
-	      ai_se_chans:16,
-	      ai_bits:	12,
-	      ai_speed:5000,
-	      ao_nchan:2,
-	      ao_bits:	12,
-	      ao_scan_speed:100000,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_60xx,
-	      ao_range_table:&ao_ranges_60xx,
-	      ao_range_code:ao_range_code_60xx,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:1,
+	.name = "pci-das6025",
+	.device_id = 0x5e,
+	.ai_se_chans = 16,
+	.ai_bits = 12,
+	.ai_speed = 5000,
+	.ao_nchan = 2,
+	.ao_bits = 12,
+	.ao_scan_speed = 100000,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_60xx,
+	.ao_range_table = &ao_ranges_60xx,
+	.ao_range_code = ao_range_code_60xx,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 1,
 		},
 	{
-	      name:	"pci-das6030",
-	      device_id:0x5f,
-	      ai_se_chans:16,
-	      ai_bits:	16,
-	      ai_speed:10000,
-	      ao_nchan:2,
-	      ao_bits:	16,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_6030,
-	      ao_range_table:&ao_ranges_6030,
-	      ao_range_code:ao_range_code_6030,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:0,
+	.name = "pci-das6030",
+	.device_id = 0x5f,
+	.ai_se_chans = 16,
+	.ai_bits = 16,
+	.ai_speed = 10000,
+	.ao_nchan = 2,
+	.ao_bits = 16,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_6030,
+	.ao_range_table = &ao_ranges_6030,
+	.ao_range_code = ao_range_code_6030,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 0,
 		},
 	{
-	      name:	"pci-das6031",
-	      device_id:0x60,
-	      ai_se_chans:64,
-	      ai_bits:	16,
-	      ai_speed:10000,
-	      ao_nchan:2,
-	      ao_bits:	16,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_6030,
-	      ao_range_table:&ao_ranges_6030,
-	      ao_range_code:ao_range_code_6030,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:0,
+	.name = "pci-das6031",
+	.device_id = 0x60,
+	.ai_se_chans = 64,
+	.ai_bits = 16,
+	.ai_speed = 10000,
+	.ao_nchan = 2,
+	.ao_bits = 16,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_6030,
+	.ao_range_table = &ao_ranges_6030,
+	.ao_range_code = ao_range_code_6030,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 0,
 		},
 	{
-	      name:	"pci-das6032",
-	      device_id:0x61,
-	      ai_se_chans:16,
-	      ai_bits:	16,
-	      ai_speed:10000,
-	      ao_nchan:0,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_6030,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:0,
+	.name = "pci-das6032",
+	.device_id = 0x61,
+	.ai_se_chans = 16,
+	.ai_bits = 16,
+	.ai_speed = 10000,
+	.ao_nchan = 0,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_6030,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 0,
 		},
 	{
-	      name:	"pci-das6033",
-	      device_id:0x62,
-	      ai_se_chans:64,
-	      ai_bits:	16,
-	      ai_speed:10000,
-	      ao_nchan:0,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_6030,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:0,
+	.name = "pci-das6033",
+	.device_id = 0x62,
+	.ai_se_chans = 64,
+	.ai_bits = 16,
+	.ai_speed = 10000,
+	.ao_nchan = 0,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_6030,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 0,
 		},
 	{
-	      name:	"pci-das6034",
-	      device_id:0x63,
-	      ai_se_chans:16,
-	      ai_bits:	16,
-	      ai_speed:5000,
-	      ao_nchan:0,
-	      ao_scan_speed:0,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_60xx,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:0,
+	.name = "pci-das6034",
+	.device_id = 0x63,
+	.ai_se_chans = 16,
+	.ai_bits = 16,
+	.ai_speed = 5000,
+	.ao_nchan = 0,
+	.ao_scan_speed = 0,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_60xx,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 0,
 		},
 	{
-	      name:	"pci-das6035",
-	      device_id:0x64,
-	      ai_se_chans:16,
-	      ai_bits:	16,
-	      ai_speed:5000,
-	      ao_nchan:2,
-	      ao_bits:	12,
-	      ao_scan_speed:100000,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_60xx,
-	      ao_range_table:&ao_ranges_60xx,
-	      ao_range_code:ao_range_code_60xx,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:0,
+	.name = "pci-das6035",
+	.device_id = 0x64,
+	.ai_se_chans = 16,
+	.ai_bits = 16,
+	.ai_speed = 5000,
+	.ao_nchan = 2,
+	.ao_bits = 12,
+	.ao_scan_speed = 100000,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_60xx,
+	.ao_range_table = &ao_ranges_60xx,
+	.ao_range_code = ao_range_code_60xx,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 0,
 		},
 	{
-	      name:	"pci-das6036",
-	      device_id:0x6f,
-	      ai_se_chans:16,
-	      ai_bits:	16,
-	      ai_speed:5000,
-	      ao_nchan:2,
-	      ao_bits:	16,
-	      ao_scan_speed:100000,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_60xx,
-	      ao_range_table:&ao_ranges_60xx,
-	      ao_range_code:ao_range_code_60xx,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:0,
+	.name = "pci-das6036",
+	.device_id = 0x6f,
+	.ai_se_chans = 16,
+	.ai_bits = 16,
+	.ai_speed = 5000,
+	.ao_nchan = 2,
+	.ao_bits = 16,
+	.ao_scan_speed = 100000,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_60xx,
+	.ao_range_table = &ao_ranges_60xx,
+	.ao_range_code = ao_range_code_60xx,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 0,
 		},
 	{
-	      name:	"pci-das6040",
-	      device_id:0x65,
-	      ai_se_chans:16,
-	      ai_bits:	12,
-	      ai_speed:2000,
-	      ao_nchan:2,
-	      ao_bits:	12,
-	      ao_scan_speed:1000,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_6052,
-	      ao_range_table:&ao_ranges_6030,
-	      ao_range_code:ao_range_code_6030,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:0,
+	.name = "pci-das6040",
+	.device_id = 0x65,
+	.ai_se_chans = 16,
+	.ai_bits = 12,
+	.ai_speed = 2000,
+	.ao_nchan = 2,
+	.ao_bits = 12,
+	.ao_scan_speed = 1000,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_6052,
+	.ao_range_table = &ao_ranges_6030,
+	.ao_range_code = ao_range_code_6030,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 0,
 		},
 	{
-	      name:	"pci-das6052",
-	      device_id:0x66,
-	      ai_se_chans:16,
-	      ai_bits:	16,
-	      ai_speed:3333,
-	      ao_nchan:2,
-	      ao_bits:	16,
-	      ao_scan_speed:3333,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_6052,
-	      ao_range_table:&ao_ranges_6030,
-	      ao_range_code:ao_range_code_6030,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:0,
+	.name = "pci-das6052",
+	.device_id = 0x66,
+	.ai_se_chans = 16,
+	.ai_bits = 16,
+	.ai_speed = 3333,
+	.ao_nchan = 2,
+	.ao_bits = 16,
+	.ao_scan_speed = 3333,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_6052,
+	.ao_range_table = &ao_ranges_6030,
+	.ao_range_code = ao_range_code_6030,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 0,
 		},
 	{
-	      name:	"pci-das6070",
-	      device_id:0x67,
-	      ai_se_chans:16,
-	      ai_bits:	12,
-	      ai_speed:800,
-	      ao_nchan:2,
-	      ao_bits:	12,
-	      ao_scan_speed:1000,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_6052,
-	      ao_range_table:&ao_ranges_6030,
-	      ao_range_code:ao_range_code_6030,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:0,
+	.name = "pci-das6070",
+	.device_id = 0x67,
+	.ai_se_chans = 16,
+	.ai_bits = 12,
+	.ai_speed = 800,
+	.ao_nchan = 2,
+	.ao_bits = 12,
+	.ao_scan_speed = 1000,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_6052,
+	.ao_range_table = &ao_ranges_6030,
+	.ao_range_code = ao_range_code_6030,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 0,
 		},
 	{
-	      name:	"pci-das6071",
-	      device_id:0x68,
-	      ai_se_chans:64,
-	      ai_bits:	12,
-	      ai_speed:800,
-	      ao_nchan:2,
-	      ao_bits:	12,
-	      ao_scan_speed:1000,
-	      layout:	LAYOUT_60XX,
-	      ai_range_table:&ai_ranges_6052,
-	      ao_range_table:&ao_ranges_6030,
-	      ao_range_code:ao_range_code_6030,
-	      ai_fifo:	&ai_fifo_60xx,
-	      has_8255:0,
+	.name = "pci-das6071",
+	.device_id = 0x68,
+	.ai_se_chans = 64,
+	.ai_bits = 12,
+	.ai_speed = 800,
+	.ao_nchan = 2,
+	.ao_bits = 12,
+	.ao_scan_speed = 1000,
+	.layout = LAYOUT_60XX,
+	.ai_range_table = &ai_ranges_6052,
+	.ao_range_table = &ao_ranges_6030,
+	.ao_range_code = ao_range_code_6030,
+	.ai_fifo = &ai_fifo_60xx,
+	.has_8255 = 0,
 		},
 	{
-	      name:	"pci-das4020/12",
-	      device_id:0x52,
-	      ai_se_chans:4,
-	      ai_bits:	12,
-	      ai_speed:50,
-	      ao_bits:	12,
-	      ao_nchan:2,
-	      ao_scan_speed:0,	/*  no hardware pacing on ao */
-	      layout:	LAYOUT_4020,
-	      ai_range_table:&ai_ranges_4020,
-	      ao_range_table:&ao_ranges_4020,
-	      ao_range_code:ao_range_code_4020,
-	      ai_fifo:	&ai_fifo_4020,
-	      has_8255:1,
+	.name = "pci-das4020/12",
+	.device_id = 0x52,
+	.ai_se_chans = 4,
+	.ai_bits = 12,
+	.ai_speed = 50,
+	.ao_bits = 12,
+	.ao_nchan = 2,
+	.ao_scan_speed = 0,	/*  no hardware pacing on ao */
+	.layout = LAYOUT_4020,
+	.ai_range_table = &ai_ranges_4020,
+	.ao_range_table = &ao_ranges_4020,
+	.ao_range_code = ao_range_code_4020,
+	.ai_fifo = &ai_fifo_4020,
+	.has_8255 = 1,
 		},
 #if 0
 	{
-	      name:	"pci-das6402/16/jr",
-	      device_id:0	/*  XXX, */
-	      ai_se_chans:64,
-	      ai_bits:	16,
-	      ai_speed:5000,
-	      ao_nchan:0,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_64XX,
-	      ai_range_table:&ai_ranges_64xx,
-	      ai_fifo:	ai_fifo_64xx,
-	      has_8255:1,
+	.name = "pci-das6402/16/jr",
+	.device_id = 0	/*  XXX, */
+	.ai_se_chans = 64,
+	.ai_bits = 16,
+	.ai_speed = 5000,
+	.ao_nchan = 0,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_64XX,
+	.ai_range_table = &ai_ranges_64xx,
+	.ai_fifo = ai_fifo_64xx,
+	.has_8255 = 1,
 		},
 	{
-	      name:	"pci-das64/m1/16/jr",
-	      device_id:0	/*  XXX, */
-	      ai_se_chans:64,
-	      ai_bits:	16,
-	      ai_speed:1000,
-	      ao_nchan:0,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_64XX,
-	      ai_range_table:&ai_ranges_64xx,
-	      ai_fifo:	ai_fifo_64xx,
-	      has_8255:1,
+	.name = "pci-das64/m1/16/jr",
+	.device_id = 0	/*  XXX, */
+	.ai_se_chans = 64,
+	.ai_bits = 16,
+	.ai_speed = 1000,
+	.ao_nchan = 0,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_64XX,
+	.ai_range_table = &ai_ranges_64xx,
+	.ai_fifo = ai_fifo_64xx,
+	.has_8255 = 1,
 		},
 	{
-	      name:	"pci-das64/m2/16/jr",
-	      device_id:0	/*  XXX, */
-	      ai_se_chans:64,
-	      ai_bits:	16,
-	      ai_speed:500,
-	      ao_nchan:0,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_64XX,
-	      ai_range_table:&ai_ranges_64xx,
-	      ai_fifo:	ai_fifo_64xx,
-	      has_8255:1,
+	.name = "pci-das64/m2/16/jr",
+	.device_id = 0	/*  XXX, */
+	.ai_se_chans = 64,
+	.ai_bits = 16,
+	.ai_speed = 500,
+	.ao_nchan = 0,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_64XX,
+	.ai_range_table = &ai_ranges_64xx,
+	.ai_fifo = ai_fifo_64xx,
+	.has_8255 = 1,
 		},
 	{
-	      name:	"pci-das64/m3/16/jr",
-	      device_id:0	/*  XXX, */
-	      ai_se_chans:64,
-	      ai_bits:	16,
-	      ai_speed:333,
-	      ao_nchan:0,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_64XX,
-	      ai_range_table:&ai_ranges_64xx,
-	      ai_fifo:	ai_fifo_64xx,
-	      has_8255:1,
+	.name = "pci-das64/m3/16/jr",
+	.device_id = 0	/*  XXX, */
+	.ai_se_chans = 64,
+	.ai_bits = 16,
+	.ai_speed = 333,
+	.ao_nchan = 0,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_64XX,
+	.ai_range_table = &ai_ranges_64xx,
+	.ai_fifo = ai_fifo_64xx,
+	.has_8255 = 1,
 		},
 	{
-	      name:	"pci-das64/m1/14",
-	      device_id:0,	/*  XXX */
-	      ai_se_chans:64,
-	      ai_bits:	14,
-	      ai_speed:1000,
-	      ao_nchan:2,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_64XX,
-	      ai_range_table:&ai_ranges_64xx,
-	      ai_fifo:	ai_fifo_64xx,
-	      has_8255:1,
+	.name = "pci-das64/m1/14",
+	.device_id = 0,	/*  XXX */
+	.ai_se_chans = 64,
+	.ai_bits = 14,
+	.ai_speed = 1000,
+	.ao_nchan = 2,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_64XX,
+	.ai_range_table = &ai_ranges_64xx,
+	.ai_fifo = ai_fifo_64xx,
+	.has_8255 = 1,
 		},
 	{
-	      name:	"pci-das64/m2/14",
-	      device_id:0,	/*  XXX */
-	      ai_se_chans:64,
-	      ai_bits:	14,
-	      ai_speed:500,
-	      ao_nchan:2,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_64XX,
-	      ai_range_table:&ai_ranges_64xx,
-	      ai_fifo:	ai_fifo_64xx,
-	      has_8255:1,
+	.name = "pci-das64/m2/14",
+	.device_id = 0,	/*  XXX */
+	.ai_se_chans = 64,
+	.ai_bits = 14,
+	.ai_speed = 500,
+	.ao_nchan = 2,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_64XX,
+	.ai_range_table = &ai_ranges_64xx,
+	.ai_fifo = ai_fifo_64xx,
+	.has_8255 = 1,
 		},
 	{
-	      name:	"pci-das64/m3/14",
-	      device_id:0,	/*  XXX */
-	      ai_se_chans:64,
-	      ai_bits:	14,
-	      ai_speed:333,
-	      ao_nchan:2,
-	      ao_scan_speed:10000,
-	      layout:	LAYOUT_64XX,
-	      ai_range_table:&ai_ranges_64xx,
-	      ai_fifo:	ai_fifo_64xx,
-	      has_8255:1,
+	.name = "pci-das64/m3/14",
+	.device_id = 0,	/*  XXX */
+	.ai_se_chans = 64,
+	.ai_bits = 14,
+	.ai_speed = 333,
+	.ao_nchan = 2,
+	.ao_scan_speed = 10000,
+	.layout = LAYOUT_64XX,
+	.ai_range_table = &ai_ranges_64xx,
+	.ai_fifo = ai_fifo_64xx,
+	.has_8255 = 1,
 		},
 #endif
 };
@@ -1131,10 +1131,10 @@ static inline struct pcidas64_private *priv(struct comedi_device * dev)
 static int attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int detach(struct comedi_device *dev);
 static struct comedi_driver driver_cb_pcidas = {
-      driver_name:"cb_pcidas64",
-      module:THIS_MODULE,
-      attach:attach,
-      detach:detach,
+	.driver_name = "cb_pcidas64",
+	.module = THIS_MODULE,
+	.attach = attach,
+	.detach = detach,
 };
 
 static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,

commit 53106ae68acf6eda9593150a25fc44e30fd5ff68
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:21 2009 -0400

    Staging Comedi: fix spacing around parens
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index ba465c432402..425c0f296455 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -98,7 +98,7 @@ known. If you have such a board, please file a bug report at
 /* #define PCIDAS64_DEBUG         enable debugging code */
 
 #ifdef PCIDAS64_DEBUG
-#define DEBUG_PRINT(format, args...)  rt_printk(format , ## args )
+#define DEBUG_PRINT(format, args...)  rt_printk(format , ## args)
 #else
 #define DEBUG_PRINT(format, args...)
 #endif

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 10401d91113e..ba465c432402 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -585,7 +585,7 @@ static const struct hw_fifo_info ai_fifo_60xx = {
 #define MAX_AI_DMA_RING_COUNT (0x80000 / DMA_BUFFER_SIZE)
 #define MIN_AI_DMA_RING_COUNT (0x10000 / DMA_BUFFER_SIZE)
 #define AO_DMA_RING_COUNT (0x10000 / DMA_BUFFER_SIZE)
-static inline unsigned int ai_dma_ring_count(struct pcidas64_board * board)
+static inline unsigned int ai_dma_ring_count(struct pcidas64_board *board)
 {
 	if (board->layout == LAYOUT_4020)
 		return MAX_AI_DMA_RING_COUNT;
@@ -1050,7 +1050,7 @@ static inline struct pcidas64_board *board(const struct comedi_device * dev)
 	return (struct pcidas64_board *) dev->board_ptr;
 }
 
-static inline unsigned short se_diff_bit_6xxx(struct comedi_device * dev,
+static inline unsigned short se_diff_bit_6xxx(struct comedi_device *dev,
 	int use_differential)
 {
 	if ((board(dev)->layout == LAYOUT_64XX && !use_differential) ||
@@ -1128,8 +1128,8 @@ static inline struct pcidas64_private *priv(struct comedi_device * dev)
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int detach(struct comedi_device * dev);
+static int attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int detach(struct comedi_device *dev);
 static struct comedi_driver driver_cb_pcidas = {
       driver_name:"cb_pcidas64",
       module:THIS_MODULE,
@@ -1247,7 +1247,7 @@ static unsigned int ai_range_bits_6xxx(const struct comedi_device * dev,
 	return bits;
 }
 
-static unsigned int hw_revision(const struct comedi_device * dev,
+static unsigned int hw_revision(const struct comedi_device *dev,
 	uint16_t hw_status_bits)
 {
 	if (board(dev)->layout == LAYOUT_4020)
@@ -1256,7 +1256,7 @@ static unsigned int hw_revision(const struct comedi_device * dev,
 	return (hw_status_bits >> 12) & 0xf;
 }
 
-static void set_dac_range_bits(struct comedi_device * dev, volatile uint16_t * bits,
+static void set_dac_range_bits(struct comedi_device *dev, volatile uint16_t *bits,
 	unsigned int channel, unsigned int range)
 {
 	unsigned int code = board(dev)->ao_range_code[range];
@@ -1270,13 +1270,13 @@ static void set_dac_range_bits(struct comedi_device * dev, volatile uint16_t * b
 	*bits |= code << (2 * channel);
 };
 
-static inline int ao_cmd_is_supported(const struct pcidas64_board * board)
+static inline int ao_cmd_is_supported(const struct pcidas64_board *board)
 {
 	return board->ao_nchan && board->layout != LAYOUT_4020;
 }
 
 /* initialize plx9080 chip */
-static void init_plx9080(struct comedi_device * dev)
+static void init_plx9080(struct comedi_device *dev)
 {
 	uint32_t bits;
 	void *plx_iobase = priv(dev)->plx9080_iobase;
@@ -1366,7 +1366,7 @@ static void init_plx9080(struct comedi_device * dev)
 
 /* Allocate and initialize the subdevice structures.
  */
-static int setup_subdevices(struct comedi_device * dev)
+static int setup_subdevices(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s;
 	void *dio_8255_iobase;
@@ -1529,14 +1529,14 @@ static int setup_subdevices(struct comedi_device * dev)
 	return 0;
 }
 
-static void disable_plx_interrupts(struct comedi_device * dev)
+static void disable_plx_interrupts(struct comedi_device *dev)
 {
 	priv(dev)->plx_intcsr_bits = 0;
 	writel(priv(dev)->plx_intcsr_bits,
 		priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
 }
 
-static void init_stc_registers(struct comedi_device * dev)
+static void init_stc_registers(struct comedi_device *dev)
 {
 	uint16_t bits;
 	unsigned long flags;
@@ -1578,7 +1578,7 @@ static void init_stc_registers(struct comedi_device * dev)
 	disable_ai_pacing(dev);
 };
 
-int alloc_and_init_dma_members(struct comedi_device * dev)
+int alloc_and_init_dma_members(struct comedi_device *dev)
 {
 	int i;
 
@@ -1664,7 +1664,7 @@ int alloc_and_init_dma_members(struct comedi_device * dev)
 	return 0;
 }
 
-static inline void warn_external_queue(struct comedi_device * dev)
+static inline void warn_external_queue(struct comedi_device *dev)
 {
 	comedi_error(dev,
 		"AO command and AI external channel queue cannot be used simultaneously.");
@@ -1824,7 +1824,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int detach(struct comedi_device * dev)
+static int detach(struct comedi_device *dev)
 {
 	unsigned int i;
 
@@ -1884,8 +1884,8 @@ static int detach(struct comedi_device * dev)
 	return 0;
 }
 
-static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bits = 0, n, i;
 	unsigned int channel, range, aref;
@@ -2021,7 +2021,7 @@ static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	return n;
 }
 
-static int ai_config_calibration_source(struct comedi_device * dev, unsigned int * data)
+static int ai_config_calibration_source(struct comedi_device *dev, unsigned int *data)
 {
 	unsigned int source = data[1];
 	int num_calibration_sources;
@@ -2041,7 +2041,7 @@ static int ai_config_calibration_source(struct comedi_device * dev, unsigned int
 	return 2;
 }
 
-static int ai_config_block_size(struct comedi_device * dev, unsigned int * data)
+static int ai_config_block_size(struct comedi_device *dev, unsigned int *data)
 {
 	int fifo_size;
 	const struct hw_fifo_info *const fifo = board(dev)->ai_fifo;
@@ -2068,7 +2068,7 @@ static int ai_config_block_size(struct comedi_device * dev, unsigned int * data)
 	return 2;
 }
 
-static int ai_config_master_clock_4020(struct comedi_device * dev, unsigned int * data)
+static int ai_config_master_clock_4020(struct comedi_device *dev, unsigned int *data)
 {
 	unsigned int divisor = data[4];
 	int retval = 0;
@@ -2094,7 +2094,7 @@ static int ai_config_master_clock_4020(struct comedi_device * dev, unsigned int
 }
 
 /* XXX could add support for 60xx series */
-static int ai_config_master_clock(struct comedi_device * dev, unsigned int * data)
+static int ai_config_master_clock(struct comedi_device *dev, unsigned int *data)
 {
 
 	switch (board(dev)->layout) {
@@ -2109,8 +2109,8 @@ static int ai_config_master_clock(struct comedi_device * dev, unsigned int * dat
 	return -EINVAL;
 }
 
-static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int id = data[0];
 
@@ -2131,8 +2131,8 @@ static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice *
 	return -EINVAL;
 }
 
-static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -2316,7 +2316,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	return 0;
 }
 
-static int use_hw_sample_counter(struct comedi_cmd * cmd)
+static int use_hw_sample_counter(struct comedi_cmd *cmd)
 {
 /* disable for now until I work out a race */
 	return 0;
@@ -2327,7 +2327,7 @@ static int use_hw_sample_counter(struct comedi_cmd * cmd)
 		return 0;
 }
 
-static void setup_sample_counters(struct comedi_device * dev, struct comedi_cmd * cmd)
+static void setup_sample_counters(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
 	if (cmd->stop_src == TRIG_COUNT) {
 		/*  set software count */
@@ -2344,7 +2344,7 @@ static void setup_sample_counters(struct comedi_device * dev, struct comedi_cmd
 	}
 }
 
-static inline unsigned int dma_transfer_size(struct comedi_device * dev)
+static inline unsigned int dma_transfer_size(struct comedi_device *dev)
 {
 	unsigned int num_samples;
 
@@ -2357,7 +2357,7 @@ static inline unsigned int dma_transfer_size(struct comedi_device * dev)
 	return num_samples;
 }
 
-static void disable_ai_pacing(struct comedi_device * dev)
+static void disable_ai_pacing(struct comedi_device *dev)
 {
 	unsigned long flags;
 
@@ -2374,7 +2374,7 @@ static void disable_ai_pacing(struct comedi_device * dev)
 		priv(dev)->main_iobase + ADC_CONTROL0_REG);
 }
 
-static void disable_ai_interrupts(struct comedi_device * dev)
+static void disable_ai_interrupts(struct comedi_device *dev)
 {
 	unsigned long flags;
 
@@ -2390,7 +2390,7 @@ static void disable_ai_interrupts(struct comedi_device * dev)
 	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
 }
 
-static void enable_ai_interrupts(struct comedi_device * dev, const struct comedi_cmd * cmd)
+static void enable_ai_interrupts(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	uint32_t bits;
 	unsigned long flags;
@@ -2411,14 +2411,14 @@ static void enable_ai_interrupts(struct comedi_device * dev, const struct comedi
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
-static uint32_t ai_convert_counter_6xxx(const struct comedi_device * dev,
-	const struct comedi_cmd * cmd)
+static uint32_t ai_convert_counter_6xxx(const struct comedi_device *dev,
+	const struct comedi_cmd *cmd)
 {
 	/*  supposed to load counter with desired divisor minus 3 */
 	return cmd->convert_arg / TIMER_BASE - 3;
 }
 
-static uint32_t ai_scan_counter_6xxx(struct comedi_device * dev, struct comedi_cmd * cmd)
+static uint32_t ai_scan_counter_6xxx(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
 	uint32_t count;
 	/*  figure out how long we need to delay at end of scan */
@@ -2438,7 +2438,7 @@ static uint32_t ai_scan_counter_6xxx(struct comedi_device * dev, struct comedi_c
 	return count - 3;
 }
 
-static uint32_t ai_convert_counter_4020(struct comedi_device * dev, struct comedi_cmd * cmd)
+static uint32_t ai_convert_counter_4020(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
 	unsigned int divisor;
 
@@ -2459,8 +2459,8 @@ static uint32_t ai_convert_counter_4020(struct comedi_device * dev, struct comed
 	return divisor - 2;
 }
 
-static void select_master_clock_4020(struct comedi_device * dev,
-	const struct comedi_cmd * cmd)
+static void select_master_clock_4020(struct comedi_device *dev,
+	const struct comedi_cmd *cmd)
 {
 	/*  select internal/external master clock */
 	priv(dev)->hw_config_bits &= ~MASTER_CLOCK_4020_MASK;
@@ -2478,7 +2478,7 @@ static void select_master_clock_4020(struct comedi_device * dev,
 		priv(dev)->main_iobase + HW_CONFIG_REG);
 }
 
-static void select_master_clock(struct comedi_device * dev, const struct comedi_cmd * cmd)
+static void select_master_clock(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	switch (board(dev)->layout) {
 	case LAYOUT_4020:
@@ -2489,7 +2489,7 @@ static void select_master_clock(struct comedi_device * dev, const struct comedi_
 	}
 }
 
-static inline void dma_start_sync(struct comedi_device * dev, unsigned int channel)
+static inline void dma_start_sync(struct comedi_device *dev, unsigned int channel)
 {
 	unsigned long flags;
 
@@ -2506,7 +2506,7 @@ static inline void dma_start_sync(struct comedi_device * dev, unsigned int chann
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
-static void set_ai_pacing(struct comedi_device * dev, struct comedi_cmd * cmd)
+static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
 	uint32_t convert_counter = 0, scan_counter = 0;
 
@@ -2537,7 +2537,7 @@ static void set_ai_pacing(struct comedi_device * dev, struct comedi_cmd * cmd)
 	DEBUG_PRINT("scan counter 0x%x\n", scan_counter);
 }
 
-static int use_internal_queue_6xxx(const struct comedi_cmd * cmd)
+static int use_internal_queue_6xxx(const struct comedi_cmd *cmd)
 {
 	int i;
 	for (i = 0; i + 1 < cmd->chanlist_len; i++) {
@@ -2553,7 +2553,7 @@ static int use_internal_queue_6xxx(const struct comedi_cmd * cmd)
 	return 1;
 }
 
-static int setup_channel_queue(struct comedi_device * dev, const struct comedi_cmd * cmd)
+static int setup_channel_queue(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	unsigned short bits;
 	int i;
@@ -2655,7 +2655,7 @@ static int setup_channel_queue(struct comedi_device * dev, const struct comedi_c
 	return 0;
 }
 
-static inline void load_first_dma_descriptor(struct comedi_device * dev,
+static inline void load_first_dma_descriptor(struct comedi_device *dev,
 	unsigned int dma_channel, unsigned int descriptor_bits)
 {
 	/* The transfer size, pci address, and local address registers
@@ -2682,7 +2682,7 @@ static inline void load_first_dma_descriptor(struct comedi_device * dev,
 	}
 }
 
-static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -2800,7 +2800,7 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 }
 
 /* read num_samples from 16 bit wide ai fifo */
-static void pio_drain_ai_fifo_16(struct comedi_device * dev)
+static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
@@ -2867,7 +2867,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device * dev)
  * dma transfers (it only supports the use of pio for draining the last remaining
  * points from the fifo when a data aquisition operation has completed).
  */
-static void pio_drain_ai_fifo_32(struct comedi_device * dev)
+static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
@@ -2901,7 +2901,7 @@ static void pio_drain_ai_fifo_32(struct comedi_device * dev)
 }
 
 /* empty fifo */
-static void pio_drain_ai_fifo(struct comedi_device * dev)
+static void pio_drain_ai_fifo(struct comedi_device *dev)
 {
 	if (board(dev)->layout == LAYOUT_4020) {
 		pio_drain_ai_fifo_32(dev);
@@ -2909,7 +2909,7 @@ static void pio_drain_ai_fifo(struct comedi_device * dev)
 		pio_drain_ai_fifo_16(dev);
 }
 
-static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
+static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 {
 	struct comedi_async *async = dev->read_subdev->async;
 	uint32_t next_transfer_addr;
@@ -2955,7 +2955,7 @@ static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 	 * unused buffer) */
 }
 
-void handle_ai_interrupt(struct comedi_device * dev, unsigned short status,
+void handle_ai_interrupt(struct comedi_device *dev, unsigned short status,
 	unsigned int plx_status)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
@@ -3009,7 +3009,7 @@ void handle_ai_interrupt(struct comedi_device * dev, unsigned short status,
 	cfc_handle_events(dev, s);
 }
 
-static inline unsigned int prev_ao_dma_index(struct comedi_device * dev)
+static inline unsigned int prev_ao_dma_index(struct comedi_device *dev)
 {
 	unsigned int buffer_index;
 
@@ -3020,7 +3020,7 @@ static inline unsigned int prev_ao_dma_index(struct comedi_device * dev)
 	return buffer_index;
 }
 
-static int last_ao_dma_load_completed(struct comedi_device * dev)
+static int last_ao_dma_load_completed(struct comedi_device *dev)
 {
 	unsigned int buffer_index;
 	unsigned int transfer_address;
@@ -3039,7 +3039,7 @@ static int last_ao_dma_load_completed(struct comedi_device * dev)
 	return 1;
 }
 
-static int ao_stopped_by_error(struct comedi_device * dev, const struct comedi_cmd * cmd)
+static int ao_stopped_by_error(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	if (cmd->stop_src == TRIG_NONE)
 		return 1;
@@ -3052,7 +3052,7 @@ static int ao_stopped_by_error(struct comedi_device * dev, const struct comedi_c
 	return 0;
 }
 
-static inline int ao_dma_needs_restart(struct comedi_device * dev,
+static inline int ao_dma_needs_restart(struct comedi_device *dev,
 	unsigned short dma_status)
 {
 	if ((dma_status & PLX_DMA_DONE_BIT) == 0 ||
@@ -3064,7 +3064,7 @@ static inline int ao_dma_needs_restart(struct comedi_device * dev,
 	return 1;
 }
 
-static void restart_ao_dma(struct comedi_device * dev)
+static void restart_ao_dma(struct comedi_device *dev)
 {
 	unsigned int dma_desc_bits;
 
@@ -3077,7 +3077,7 @@ static void restart_ao_dma(struct comedi_device * dev)
 	dma_start_sync(dev, 0);
 }
 
-static void handle_ao_interrupt(struct comedi_device * dev, unsigned short status,
+static void handle_ao_interrupt(struct comedi_device *dev, unsigned short status,
 	unsigned int plx_status)
 {
 	struct comedi_subdevice *s = dev->write_subdev;
@@ -3165,7 +3165,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-void abort_dma(struct comedi_device * dev, unsigned int channel)
+void abort_dma(struct comedi_device *dev, unsigned int channel)
 {
 	unsigned long flags;
 
@@ -3177,7 +3177,7 @@ void abort_dma(struct comedi_device * dev, unsigned int channel)
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
-static int ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -3197,8 +3197,8 @@ static int ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	int range = CR_RANGE(insn->chanspec);
@@ -3227,15 +3227,15 @@ static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	return 1;
 }
 
-static int ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ao_readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = priv(dev)->ao_value[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static void set_dac_control0_reg(struct comedi_device * dev, const struct comedi_cmd * cmd)
+static void set_dac_control0_reg(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	unsigned int bits = DAC_ENABLE_BIT | WAVEFORM_GATE_LEVEL_BIT |
 		WAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;
@@ -3255,7 +3255,7 @@ static void set_dac_control0_reg(struct comedi_device * dev, const struct comedi
 	writew(bits, priv(dev)->main_iobase + DAC_CONTROL0_REG);
 }
 
-static void set_dac_control1_reg(struct comedi_device * dev, const struct comedi_cmd * cmd)
+static void set_dac_control1_reg(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	int i;
 
@@ -3272,7 +3272,7 @@ static void set_dac_control1_reg(struct comedi_device * dev, const struct comedi
 		priv(dev)->main_iobase + DAC_CONTROL1_REG);
 }
 
-static void set_dac_select_reg(struct comedi_device * dev, const struct comedi_cmd * cmd)
+static void set_dac_select_reg(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	uint16_t bits;
 	unsigned int first_channel, last_channel;
@@ -3287,7 +3287,7 @@ static void set_dac_select_reg(struct comedi_device * dev, const struct comedi_c
 	writew(bits, priv(dev)->main_iobase + DAC_SELECT_REG);
 }
 
-static void set_dac_interval_regs(struct comedi_device * dev, const struct comedi_cmd * cmd)
+static void set_dac_interval_regs(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	unsigned int divisor;
 
@@ -3305,8 +3305,8 @@ static void set_dac_interval_regs(struct comedi_device * dev, const struct comed
 		priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_UPPER_REG);
 }
 
-static unsigned int load_ao_dma_buffer(struct comedi_device * dev,
-	const struct comedi_cmd * cmd)
+static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
+	const struct comedi_cmd *cmd)
 {
 	unsigned int num_bytes, buffer_index, prev_buffer_index;
 	unsigned int next_bits;
@@ -3349,7 +3349,7 @@ static unsigned int load_ao_dma_buffer(struct comedi_device * dev,
 	return num_bytes;
 }
 
-static void load_ao_dma(struct comedi_device * dev, const struct comedi_cmd * cmd)
+static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	unsigned int num_bytes;
 	unsigned int next_transfer_addr;
@@ -3371,7 +3371,7 @@ static void load_ao_dma(struct comedi_device * dev, const struct comedi_cmd * cm
 	} while (num_bytes >= DMA_BUFFER_SIZE);
 }
 
-static int prep_ao_dma(struct comedi_device * dev, const struct comedi_cmd * cmd)
+static int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	unsigned int num_bytes;
 	int i;
@@ -3405,7 +3405,7 @@ static int prep_ao_dma(struct comedi_device * dev, const struct comedi_cmd * cmd
 	return 0;
 }
 
-static inline int external_ai_queue_in_use(struct comedi_device * dev)
+static inline int external_ai_queue_in_use(struct comedi_device *dev)
 {
 	if (dev->read_subdev->busy)
 		return 0;
@@ -3416,7 +3416,7 @@ static inline int external_ai_queue_in_use(struct comedi_device * dev)
 	return 1;
 }
 
-static int ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 
@@ -3441,7 +3441,7 @@ static int ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-static int ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
+static int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trig_num)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -3464,8 +3464,8 @@ static int ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 	return 0;
 }
 
-static int ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -3580,7 +3580,7 @@ static int ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	return 0;
 }
 
-static int ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	writew(0x0, priv(dev)->main_iobase + DAC_CONTROL0_REG);
 	abort_dma(dev, 0);
@@ -3608,8 +3608,8 @@ static int dio_callback_4020(int dir, int port, int data, unsigned long iobase)
 	}
 }
 
-static int di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bits;
 
@@ -3621,8 +3621,8 @@ static int di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	return 2;
 }
 
-static int do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] &= 0xf;
 	/*  zero bits we are going to change */
@@ -3637,8 +3637,8 @@ static int do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	return 2;
 }
 
-static int dio_60xx_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dio_60xx_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int mask;
 
@@ -3664,8 +3664,8 @@ static int dio_60xx_config_insn(struct comedi_device * dev, struct comedi_subdev
 	return 1;
 }
 
-static int dio_60xx_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -3679,7 +3679,7 @@ static int dio_60xx_wbits(struct comedi_device * dev, struct comedi_subdevice *
 	return 2;
 }
 
-static void caldac_write(struct comedi_device * dev, unsigned int channel,
+static void caldac_write(struct comedi_device *dev, unsigned int channel,
 	unsigned int value)
 {
 	priv(dev)->caldac_state[channel] = value;
@@ -3697,8 +3697,8 @@ static void caldac_write(struct comedi_device * dev, unsigned int channel,
 	}
 }
 
-static int calib_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int calib_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -3712,8 +3712,8 @@ static int calib_write_insn(struct comedi_device * dev, struct comedi_subdevice
 	return 1;
 }
 
-static int calib_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int calib_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -3722,7 +3722,7 @@ static int calib_read_insn(struct comedi_device * dev, struct comedi_subdevice *
 	return 1;
 }
 
-static void ad8402_write(struct comedi_device * dev, unsigned int channel,
+static void ad8402_write(struct comedi_device *dev, unsigned int channel,
 	unsigned int value)
 {
 	static const int bitstream_length = 10;
@@ -3753,8 +3753,8 @@ static void ad8402_write(struct comedi_device * dev, unsigned int channel,
 }
 
 /* for pci-das6402/16, channel 0 is analog input gain and channel 1 is offset */
-static int ad8402_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ad8402_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -3770,8 +3770,8 @@ static int ad8402_write_insn(struct comedi_device * dev, struct comedi_subdevice
 	return 1;
 }
 
-static int ad8402_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ad8402_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -3780,7 +3780,7 @@ static int ad8402_read_insn(struct comedi_device * dev, struct comedi_subdevice
 	return 1;
 }
 
-static uint16_t read_eeprom(struct comedi_device * dev, uint8_t address)
+static uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)
 {
 	static const int bitstream_length = 11;
 	static const int read_command = 0x6;
@@ -3842,8 +3842,8 @@ static uint16_t read_eeprom(struct comedi_device * dev, uint8_t address)
 	return value;
 }
 
-static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = read_eeprom(dev, CR_CHAN(insn->chanspec));
 
@@ -3928,7 +3928,7 @@ static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags)
 }
 
 /* adjusts the size of hardware fifo (which determines block size for dma xfers) */
-static int set_ai_fifo_size(struct comedi_device * dev, unsigned int num_samples)
+static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)
 {
 	unsigned int num_fifo_entries;
 	int retval;
@@ -3949,14 +3949,14 @@ static int set_ai_fifo_size(struct comedi_device * dev, unsigned int num_samples
 }
 
 /* query length of fifo */
-static unsigned int ai_fifo_size(struct comedi_device * dev)
+static unsigned int ai_fifo_size(struct comedi_device *dev)
 {
 	return priv(dev)->ai_fifo_segment_length *
 		board(dev)->ai_fifo->num_segments *
 		board(dev)->ai_fifo->sample_packing_ratio;
 }
 
-static int set_ai_fifo_segment_length(struct comedi_device * dev,
+static int set_ai_fifo_segment_length(struct comedi_device *dev,
 	unsigned int num_entries)
 {
 	static const int increment_size = 0x100;
@@ -4007,7 +4007,7 @@ static int set_ai_fifo_segment_length(struct comedi_device * dev,
  * address 7 == dac channel 1 fine offset
 */
 
-static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
+static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 	uint8_t value)
 {
 	static const int num_caldac_channels = 8;
@@ -4039,7 +4039,7 @@ static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
 }
 
 /* 4020 caldacs */
-static int caldac_i2c_write(struct comedi_device * dev, unsigned int caldac_channel,
+static int caldac_i2c_write(struct comedi_device *dev, unsigned int caldac_channel,
 	unsigned int value)
 {
 	uint8_t serial_bytes[3];
@@ -4104,7 +4104,7 @@ static const int i2c_high_comedi_udelay = 1000;
 static const int i2c_low_comedi_udelay = 10;
 
 /* set i2c data line high or low */
-static void i2c_set_sda(struct comedi_device * dev, int state)
+static void i2c_set_sda(struct comedi_device *dev, int state)
 {
 	static const int data_bit = CTL_EE_W;
 	void *plx_control_addr = priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
@@ -4123,7 +4123,7 @@ static void i2c_set_sda(struct comedi_device * dev, int state)
 }
 
 /* set i2c clock line high or low */
-static void i2c_set_scl(struct comedi_device * dev, int state)
+static void i2c_set_scl(struct comedi_device *dev, int state)
 {
 	static const int clock_bit = CTL_USERO;
 	void *plx_control_addr = priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
@@ -4141,7 +4141,7 @@ static void i2c_set_scl(struct comedi_device * dev, int state)
 	}
 }
 
-static void i2c_write_byte(struct comedi_device * dev, uint8_t byte)
+static void i2c_write_byte(struct comedi_device *dev, uint8_t byte)
 {
 	uint8_t bit;
 	unsigned int num_bits = 8;
@@ -4159,7 +4159,7 @@ static void i2c_write_byte(struct comedi_device * dev, uint8_t byte)
 }
 
 /* we can't really read the lines, so fake it */
-static int i2c_read_ack(struct comedi_device * dev)
+static int i2c_read_ack(struct comedi_device *dev)
 {
 	i2c_set_scl(dev, 0);
 	i2c_set_sda(dev, 1);
@@ -4169,7 +4169,7 @@ static int i2c_read_ack(struct comedi_device * dev)
 }
 
 /* send start bit */
-static void i2c_start(struct comedi_device * dev)
+static void i2c_start(struct comedi_device *dev)
 {
 	i2c_set_scl(dev, 1);
 	i2c_set_sda(dev, 1);
@@ -4177,7 +4177,7 @@ static void i2c_start(struct comedi_device * dev)
 }
 
 /* send stop bit */
-static void i2c_stop(struct comedi_device * dev)
+static void i2c_stop(struct comedi_device *dev)
 {
 	i2c_set_scl(dev, 0);
 	i2c_set_sda(dev, 0);
@@ -4185,8 +4185,8 @@ static void i2c_stop(struct comedi_device * dev)
 	i2c_set_sda(dev, 1);
 }
 
-static void i2c_write(struct comedi_device * dev, unsigned int address,
-	const uint8_t * data, unsigned int length)
+static void i2c_write(struct comedi_device *dev, unsigned int address,
+	const uint8_t *data, unsigned int length)
 {
 	unsigned int i;
 	uint8_t bitstream;

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 7b57e3ab79c2..10401d91113e 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -85,6 +85,7 @@ known. If you have such a board, please file a bug report at
 
 #include "../comedidev.h"
 #include <linux/delay.h>
+#include <linux/interrupt.h>
 #include <asm/system.h>
 
 #include "comedi_pci.h"
@@ -1152,7 +1153,7 @@ static int ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * subd
 	unsigned int trig_num);
 static int ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_cmd * cmd);
-static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG);
+static irqreturn_t handle_interrupt(int irq, void *d);
 static int ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int dio_callback(int dir, int port, int data, unsigned long arg);
@@ -3128,7 +3129,7 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned short statu
 	cfc_handle_events(dev, s);
 }
 
-static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
+static irqreturn_t handle_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	unsigned short status;

commit 9ef4dea6eb9ff671ffd62f5304c7d8de716807a2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:30:39 2009 -0400

    Staging: comedi: remove C99 comments in cb_pcidas64.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 1a580bd2247a..7b57e3ab79c2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -93,8 +93,8 @@ known. If you have such a board, please file a bug report at
 #include "plx9080.h"
 #include "comedi_fc.h"
 
-#undef PCIDAS64_DEBUG		// disable debugging code
-//#define PCIDAS64_DEBUG        // enable debugging code
+#undef PCIDAS64_DEBUG		/*  disable debugging code */
+/* #define PCIDAS64_DEBUG         enable debugging code */
 
 #ifdef PCIDAS64_DEBUG
 #define DEBUG_PRINT(format, args...)  rt_printk(format , ## args )
@@ -102,8 +102,8 @@ known. If you have such a board, please file a bug report at
 #define DEBUG_PRINT(format, args...)
 #endif
 
-#define TIMER_BASE 25		// 40MHz master clock
-#define PRESCALED_TIMER_BASE	10000	// 100kHz 'prescaled' clock for slow aquisition, maybe I'll support this someday
+#define TIMER_BASE 25		/*  40MHz master clock */
+#define PRESCALED_TIMER_BASE	10000	/*  100kHz 'prescaled' clock for slow aquisition, maybe I'll support this someday */
 #define DMA_BUFFER_SIZE 0x1000
 
 /* maximum value that can be loaded into board's 24-bit counters*/
@@ -111,41 +111,41 @@ static const int max_counter_value = 0xffffff;
 
 /* PCI-DAS64xxx base addresses */
 
-// indices of base address regions
+/* indices of base address regions */
 enum base_address_regions {
 	PLX9080_BADDRINDEX = 0,
 	MAIN_BADDRINDEX = 2,
 	DIO_COUNTER_BADDRINDEX = 3,
 };
 
-// priv(dev)->main_iobase registers
+/* priv(dev)->main_iobase registers */
 enum write_only_registers {
-	INTR_ENABLE_REG = 0x0,	// interrupt enable register
-	HW_CONFIG_REG = 0x2,	// hardware config register
+	INTR_ENABLE_REG = 0x0,	/*  interrupt enable register */
+	HW_CONFIG_REG = 0x2,	/*  hardware config register */
 	DAQ_SYNC_REG = 0xc,
 	DAQ_ATRIG_LOW_4020_REG = 0xc,
-	ADC_CONTROL0_REG = 0x10,	// adc control register 0
-	ADC_CONTROL1_REG = 0x12,	// adc control register 1
+	ADC_CONTROL0_REG = 0x10,	/*  adc control register 0 */
+	ADC_CONTROL1_REG = 0x12,	/*  adc control register 1 */
 	CALIBRATION_REG = 0x14,
-	ADC_SAMPLE_INTERVAL_LOWER_REG = 0x16,	// lower 16 bits of adc sample interval counter
-	ADC_SAMPLE_INTERVAL_UPPER_REG = 0x18,	// upper 8 bits of adc sample interval counter
-	ADC_DELAY_INTERVAL_LOWER_REG = 0x1a,	// lower 16 bits of delay interval counter
-	ADC_DELAY_INTERVAL_UPPER_REG = 0x1c,	// upper 8 bits of delay interval counter
-	ADC_COUNT_LOWER_REG = 0x1e,	// lower 16 bits of hardware conversion/scan counter
-	ADC_COUNT_UPPER_REG = 0x20,	// upper 8 bits of hardware conversion/scan counter
-	ADC_START_REG = 0x22,	// software trigger to start aquisition
-	ADC_CONVERT_REG = 0x24,	// initiates single conversion
-	ADC_QUEUE_CLEAR_REG = 0x26,	// clears adc queue
-	ADC_QUEUE_LOAD_REG = 0x28,	// loads adc queue
+	ADC_SAMPLE_INTERVAL_LOWER_REG = 0x16,	/*  lower 16 bits of adc sample interval counter */
+	ADC_SAMPLE_INTERVAL_UPPER_REG = 0x18,	/*  upper 8 bits of adc sample interval counter */
+	ADC_DELAY_INTERVAL_LOWER_REG = 0x1a,	/*  lower 16 bits of delay interval counter */
+	ADC_DELAY_INTERVAL_UPPER_REG = 0x1c,	/*  upper 8 bits of delay interval counter */
+	ADC_COUNT_LOWER_REG = 0x1e,	/*  lower 16 bits of hardware conversion/scan counter */
+	ADC_COUNT_UPPER_REG = 0x20,	/*  upper 8 bits of hardware conversion/scan counter */
+	ADC_START_REG = 0x22,	/*  software trigger to start aquisition */
+	ADC_CONVERT_REG = 0x24,	/*  initiates single conversion */
+	ADC_QUEUE_CLEAR_REG = 0x26,	/*  clears adc queue */
+	ADC_QUEUE_LOAD_REG = 0x28,	/*  loads adc queue */
 	ADC_BUFFER_CLEAR_REG = 0x2a,
-	ADC_QUEUE_HIGH_REG = 0x2c,	// high channel for internal queue, use adc_chan_bits() inline above
-	DAC_CONTROL0_REG = 0x50,	// dac control register 0
-	DAC_CONTROL1_REG = 0x52,	// dac control register 0
-	DAC_SAMPLE_INTERVAL_LOWER_REG = 0x54,	// lower 16 bits of dac sample interval counter
-	DAC_SAMPLE_INTERVAL_UPPER_REG = 0x56,	// upper 8 bits of dac sample interval counter
+	ADC_QUEUE_HIGH_REG = 0x2c,	/*  high channel for internal queue, use adc_chan_bits() inline above */
+	DAC_CONTROL0_REG = 0x50,	/*  dac control register 0 */
+	DAC_CONTROL1_REG = 0x52,	/*  dac control register 0 */
+	DAC_SAMPLE_INTERVAL_LOWER_REG = 0x54,	/*  lower 16 bits of dac sample interval counter */
+	DAC_SAMPLE_INTERVAL_UPPER_REG = 0x56,	/*  upper 8 bits of dac sample interval counter */
 	DAC_SELECT_REG = 0x60,
 	DAC_START_REG = 0x64,
-	DAC_BUFFER_CLEAR_REG = 0x66,	// clear dac buffer
+	DAC_BUFFER_CLEAR_REG = 0x66,	/*  clear dac buffer */
 };
 static inline unsigned int dac_convert_reg(unsigned int channel)
 {
@@ -161,7 +161,7 @@ static inline unsigned int dac_msb_4020_reg(unsigned int channel)
 }
 
 enum read_only_registers {
-	HW_STATUS_REG = 0x0,	// hardware status register, reading this apparently clears pending interrupts as well
+	HW_STATUS_REG = 0x0,	/*  hardware status register, reading this apparently clears pending interrupts as well */
 	PIPE1_READ_REG = 0x4,
 	ADC_READ_PNTR_REG = 0x8,
 	LOWER_XFER_REG = 0x10,
@@ -170,13 +170,13 @@ enum read_only_registers {
 };
 
 enum read_write_registers {
-	I8255_4020_REG = 0x48,	// 8255 offset, for 4020 only
-	ADC_QUEUE_FIFO_REG = 0x100,	// external channel/gain queue, uses same bits as ADC_QUEUE_LOAD_REG
+	I8255_4020_REG = 0x48,	/*  8255 offset, for 4020 only */
+	ADC_QUEUE_FIFO_REG = 0x100,	/*  external channel/gain queue, uses same bits as ADC_QUEUE_LOAD_REG */
 	ADC_FIFO_REG = 0x200,	/* adc data fifo */
 	DAC_FIFO_REG = 0x300,	/* dac data fifo, has weird interactions with external channel queue */
 };
 
-// priv(dev)->dio_counter_iobase registers
+/* priv(dev)->dio_counter_iobase registers */
 enum dio_counter_registers {
 	DIO_8255_OFFSET = 0x0,
 	DO_REG = 0x20,
@@ -185,47 +185,47 @@ enum dio_counter_registers {
 	DIO_DATA_60XX_REG = 0x48,
 };
 
-// bit definitions for write-only registers
+/* bit definitions for write-only registers */
 
 enum intr_enable_contents {
-	ADC_INTR_SRC_MASK = 0x3,	// bits that set adc interrupt source
-	ADC_INTR_QFULL_BITS = 0x0,	// interrupt fifo quater full
-	ADC_INTR_EOC_BITS = 0x1,	// interrupt end of conversion
-	ADC_INTR_EOSCAN_BITS = 0x2,	// interrupt end of scan
-	ADC_INTR_EOSEQ_BITS = 0x3,	// interrupt end of sequence (probably wont use this it's pretty fancy)
-	EN_ADC_INTR_SRC_BIT = 0x4,	// enable adc interrupt source
-	EN_ADC_DONE_INTR_BIT = 0x8,	// enable adc aquisition done interrupt
+	ADC_INTR_SRC_MASK = 0x3,	/*  bits that set adc interrupt source */
+	ADC_INTR_QFULL_BITS = 0x0,	/*  interrupt fifo quater full */
+	ADC_INTR_EOC_BITS = 0x1,	/*  interrupt end of conversion */
+	ADC_INTR_EOSCAN_BITS = 0x2,	/*  interrupt end of scan */
+	ADC_INTR_EOSEQ_BITS = 0x3,	/*  interrupt end of sequence (probably wont use this it's pretty fancy) */
+	EN_ADC_INTR_SRC_BIT = 0x4,	/*  enable adc interrupt source */
+	EN_ADC_DONE_INTR_BIT = 0x8,	/*  enable adc aquisition done interrupt */
 	DAC_INTR_SRC_MASK = 0x30,
 	DAC_INTR_QEMPTY_BITS = 0x0,
 	DAC_INTR_HIGH_CHAN_BITS = 0x10,
-	EN_DAC_INTR_SRC_BIT = 0x40,	// enable dac interrupt source
+	EN_DAC_INTR_SRC_BIT = 0x40,	/*  enable dac interrupt source */
 	EN_DAC_DONE_INTR_BIT = 0x80,
-	EN_ADC_ACTIVE_INTR_BIT = 0x200,	// enable adc active interrupt
-	EN_ADC_STOP_INTR_BIT = 0x400,	// enable adc stop trigger interrupt
-	EN_DAC_ACTIVE_INTR_BIT = 0x800,	// enable dac active interrupt
-	EN_DAC_UNDERRUN_BIT = 0x4000,	// enable dac underrun status bit
-	EN_ADC_OVERRUN_BIT = 0x8000,	// enable adc overrun status bit
+	EN_ADC_ACTIVE_INTR_BIT = 0x200,	/*  enable adc active interrupt */
+	EN_ADC_STOP_INTR_BIT = 0x400,	/*  enable adc stop trigger interrupt */
+	EN_DAC_ACTIVE_INTR_BIT = 0x800,	/*  enable dac active interrupt */
+	EN_DAC_UNDERRUN_BIT = 0x4000,	/*  enable dac underrun status bit */
+	EN_ADC_OVERRUN_BIT = 0x8000,	/*  enable adc overrun status bit */
 };
 
 enum hw_config_contents {
-	MASTER_CLOCK_4020_MASK = 0x3,	// bits that specify master clock source for 4020
-	INTERNAL_CLOCK_4020_BITS = 0x1,	// use 40 MHz internal master clock for 4020
-	BNC_CLOCK_4020_BITS = 0x2,	// use BNC input for master clock
-	EXT_CLOCK_4020_BITS = 0x3,	// use dio input for master clock
-	EXT_QUEUE_BIT = 0x200,	// use external channel/gain queue (more versatile than internal queue)
-	SLOW_DAC_BIT = 0x400,	// use 225 nanosec strobe when loading dac instead of 50 nanosec
-	HW_CONFIG_DUMMY_BITS = 0x2000,	// bit with unknown function yet given as default value in pci-das64 manual
-	DMA_CH_SELECT_BIT = 0x8000,	// bit selects channels 1/0 for analog input/output, otherwise 0/1
-	FIFO_SIZE_REG = 0x4,	// allows adjustment of fifo sizes
-	DAC_FIFO_SIZE_MASK = 0xff00,	// bits that set dac fifo size
+	MASTER_CLOCK_4020_MASK = 0x3,	/*  bits that specify master clock source for 4020 */
+	INTERNAL_CLOCK_4020_BITS = 0x1,	/*  use 40 MHz internal master clock for 4020 */
+	BNC_CLOCK_4020_BITS = 0x2,	/*  use BNC input for master clock */
+	EXT_CLOCK_4020_BITS = 0x3,	/*  use dio input for master clock */
+	EXT_QUEUE_BIT = 0x200,	/*  use external channel/gain queue (more versatile than internal queue) */
+	SLOW_DAC_BIT = 0x400,	/*  use 225 nanosec strobe when loading dac instead of 50 nanosec */
+	HW_CONFIG_DUMMY_BITS = 0x2000,	/*  bit with unknown function yet given as default value in pci-das64 manual */
+	DMA_CH_SELECT_BIT = 0x8000,	/*  bit selects channels 1/0 for analog input/output, otherwise 0/1 */
+	FIFO_SIZE_REG = 0x4,	/*  allows adjustment of fifo sizes */
+	DAC_FIFO_SIZE_MASK = 0xff00,	/*  bits that set dac fifo size */
 	DAC_FIFO_BITS = 0xf800,	/* 8k sample ao fifo */
 };
 #define DAC_FIFO_SIZE 0x2000
 
 enum daq_atrig_low_4020_contents {
-	EXT_AGATE_BNC_BIT = 0x8000,	// use trig/ext clk bnc input for analog gate signal
-	EXT_STOP_TRIG_BNC_BIT = 0x4000,	// use trig/ext clk bnc input for external stop trigger signal
-	EXT_START_TRIG_BNC_BIT = 0x2000,	// use trig/ext clk bnc input for external start trigger signal
+	EXT_AGATE_BNC_BIT = 0x8000,	/*  use trig/ext clk bnc input for analog gate signal */
+	EXT_STOP_TRIG_BNC_BIT = 0x4000,	/*  use trig/ext clk bnc input for external stop trigger signal */
+	EXT_START_TRIG_BNC_BIT = 0x2000,	/*  use trig/ext clk bnc input for external start trigger signal */
 };
 static inline uint16_t analog_trig_low_threshold_bits(uint16_t threshold)
 {
@@ -233,34 +233,34 @@ static inline uint16_t analog_trig_low_threshold_bits(uint16_t threshold)
 }
 
 enum adc_control0_contents {
-	ADC_GATE_SRC_MASK = 0x3,	// bits that select gate
-	ADC_SOFT_GATE_BITS = 0x1,	// software gate
-	ADC_EXT_GATE_BITS = 0x2,	// external digital gate
-	ADC_ANALOG_GATE_BITS = 0x3,	// analog level gate
-	ADC_GATE_LEVEL_BIT = 0x4,	// level-sensitive gate (for digital)
-	ADC_GATE_POLARITY_BIT = 0x8,	// gate active low
+	ADC_GATE_SRC_MASK = 0x3,	/*  bits that select gate */
+	ADC_SOFT_GATE_BITS = 0x1,	/*  software gate */
+	ADC_EXT_GATE_BITS = 0x2,	/*  external digital gate */
+	ADC_ANALOG_GATE_BITS = 0x3,	/*  analog level gate */
+	ADC_GATE_LEVEL_BIT = 0x4,	/*  level-sensitive gate (for digital) */
+	ADC_GATE_POLARITY_BIT = 0x8,	/*  gate active low */
 	ADC_START_TRIG_SOFT_BITS = 0x10,
 	ADC_START_TRIG_EXT_BITS = 0x20,
 	ADC_START_TRIG_ANALOG_BITS = 0x30,
 	ADC_START_TRIG_MASK = 0x30,
-	ADC_START_TRIG_FALLING_BIT = 0x40,	// trig 1 uses falling edge
-	ADC_EXT_CONV_FALLING_BIT = 0x800,	// external pacing uses falling edge
-	ADC_SAMPLE_COUNTER_EN_BIT = 0x1000,	// enable hardware scan counter
-	ADC_DMA_DISABLE_BIT = 0x4000,	// disables dma
-	ADC_ENABLE_BIT = 0x8000,	// master adc enable
+	ADC_START_TRIG_FALLING_BIT = 0x40,	/*  trig 1 uses falling edge */
+	ADC_EXT_CONV_FALLING_BIT = 0x800,	/*  external pacing uses falling edge */
+	ADC_SAMPLE_COUNTER_EN_BIT = 0x1000,	/*  enable hardware scan counter */
+	ADC_DMA_DISABLE_BIT = 0x4000,	/*  disables dma */
+	ADC_ENABLE_BIT = 0x8000,	/*  master adc enable */
 };
 
 enum adc_control1_contents {
-	ADC_QUEUE_CONFIG_BIT = 0x1,	// should be set for boards with > 16 channels
+	ADC_QUEUE_CONFIG_BIT = 0x1,	/*  should be set for boards with > 16 channels */
 	CONVERT_POLARITY_BIT = 0x10,
 	EOC_POLARITY_BIT = 0x20,
-	ADC_SW_GATE_BIT = 0x40,	// software gate of adc
-	ADC_DITHER_BIT = 0x200,	// turn on extra noise for dithering
+	ADC_SW_GATE_BIT = 0x40,	/*  software gate of adc */
+	ADC_DITHER_BIT = 0x200,	/*  turn on extra noise for dithering */
 	RETRIGGER_BIT = 0x800,
 	ADC_LO_CHANNEL_4020_MASK = 0x300,
 	ADC_HI_CHANNEL_4020_MASK = 0xc00,
-	TWO_CHANNEL_4020_BITS = 0x1000,	// two channel mode for 4020
-	FOUR_CHANNEL_4020_BITS = 0x2000,	// four channel mode for 4020
+	TWO_CHANNEL_4020_BITS = 0x1000,	/*  two channel mode for 4020 */
+	FOUR_CHANNEL_4020_BITS = 0x2000,	/*  four channel mode for 4020 */
 	CHANNEL_MODE_4020_MASK = 0x3000,
 	ADC_MODE_MASK = 0xf000,
 };
@@ -281,10 +281,10 @@ enum calibration_contents {
 	SELECT_8800_BIT = 0x1,
 	SELECT_8402_64XX_BIT = 0x2,
 	SELECT_1590_60XX_BIT = 0x2,
-	CAL_EN_64XX_BIT = 0x40,	// calibration enable for 64xx series
+	CAL_EN_64XX_BIT = 0x40,	/*  calibration enable for 64xx series */
 	SERIAL_DATA_IN_BIT = 0x80,
 	SERIAL_CLOCK_BIT = 0x100,
-	CAL_EN_60XX_BIT = 0x200,	// calibration enable for 60xx series
+	CAL_EN_60XX_BIT = 0x200,	/*  calibration enable for 60xx series */
 	CAL_GAIN_BIT = 0x800,
 };
 /* calibration sources for 6025 are:
@@ -308,11 +308,11 @@ static inline uint16_t adc_convert_chan_4020_bits(unsigned int channel)
 };
 
 enum adc_queue_load_contents {
-	UNIP_BIT = 0x800,	// unipolar/bipolar bit
-	ADC_SE_DIFF_BIT = 0x1000,	// single-ended/ differential bit
-	ADC_COMMON_BIT = 0x2000,	// non-referenced single-ended (common-mode input)
-	QUEUE_EOSEQ_BIT = 0x4000,	// queue end of sequence
-	QUEUE_EOSCAN_BIT = 0x8000,	// queue end of scan
+	UNIP_BIT = 0x800,	/*  unipolar/bipolar bit */
+	ADC_SE_DIFF_BIT = 0x1000,	/*  single-ended/ differential bit */
+	ADC_COMMON_BIT = 0x2000,	/*  non-referenced single-ended (common-mode input) */
+	QUEUE_EOSEQ_BIT = 0x4000,	/*  queue end of sequence */
+	QUEUE_EOSCAN_BIT = 0x8000,	/*  queue end of scan */
 };
 static inline uint16_t adc_chan_bits(unsigned int channel)
 {
@@ -320,7 +320,7 @@ static inline uint16_t adc_chan_bits(unsigned int channel)
 };
 
 enum dac_control0_contents {
-	DAC_ENABLE_BIT = 0x8000,	// dac controller enable bit
+	DAC_ENABLE_BIT = 0x8000,	/*  dac controller enable bit */
 	DAC_CYCLIC_STOP_BIT = 0x4000,
 	DAC_WAVEFORM_MODE_BIT = 0x100,
 	DAC_EXT_UPDATE_FALLING_BIT = 0x80,
@@ -340,14 +340,14 @@ enum dac_control1_contents {
 	DAC_WRITE_POLARITY_BIT = 0x800,	/* board-dependent setting */
 	DAC1_EXT_REF_BIT = 0x200,
 	DAC0_EXT_REF_BIT = 0x100,
-	DAC_OUTPUT_ENABLE_BIT = 0x80,	// dac output enable bit
+	DAC_OUTPUT_ENABLE_BIT = 0x80,	/*  dac output enable bit */
 	DAC_UPDATE_POLARITY_BIT = 0x40,	/* board-dependent setting */
 	DAC_SW_GATE_BIT = 0x20,
 	DAC1_UNIPOLAR_BIT = 0x8,
 	DAC0_UNIPOLAR_BIT = 0x2,
 };
 
-// bit definitions for read-only registers
+/* bit definitions for read-only registers */
 enum hw_status_contents {
 	DAC_UNDERRUN_BIT = 0x1,
 	ADC_OVERRUN_BIT = 0x2,
@@ -378,7 +378,7 @@ static inline unsigned int adc_upper_write_ptr_code(uint16_t prepost_bits)
 	return (prepost_bits >> 14) & 0x3;
 }
 
-// I2C addresses for 4020
+/* I2C addresses for 4020 */
 enum i2c_addresses {
 	RANGE_CAL_I2C_ADDR = 0x20,
 	CALDAC0_I2C_ADDR = 0xc,
@@ -386,8 +386,8 @@ enum i2c_addresses {
 };
 
 enum range_cal_i2c_contents {
-	ADC_SRC_4020_MASK = 0x70,	// bits that set what source the adc converter measures
-	BNC_TRIG_THRESHOLD_0V_BIT = 0x80,	// make bnc trig/ext clock threshold 0V instead of 2.5V
+	ADC_SRC_4020_MASK = 0x70,	/*  bits that set what source the adc converter measures */
+	BNC_TRIG_THRESHOLD_0V_BIT = 0x80,	/*  make bnc trig/ext clock threshold 0V instead of 2.5V */
 };
 static inline uint8_t adc_src_4020_bits(unsigned int source)
 {
@@ -395,11 +395,11 @@ static inline uint8_t adc_src_4020_bits(unsigned int source)
 };
 static inline uint8_t attenuate_bit(unsigned int channel)
 {
-	// attenuate channel (+-5V input range)
+	/*  attenuate channel (+-5V input range) */
 	return 1 << (channel & 0x3);
 };
 
-// analog input ranges for 64xx boards
+/* analog input ranges for 64xx boards */
 static const struct comedi_lrange ai_ranges_64xx = {
 	8,
 	{
@@ -468,7 +468,7 @@ static const struct comedi_lrange ai_ranges_6052 = {
 		}
 };
 
-// analog input ranges for 4020 board
+/* analog input ranges for 4020 board */
 static const struct comedi_lrange ai_ranges_4020 = {
 	2,
 	{
@@ -477,7 +477,7 @@ static const struct comedi_lrange ai_ranges_4020 = {
 		}
 };
 
-// analog output ranges
+/* analog output ranges */
 static const struct comedi_lrange ao_ranges_64xx = {
 	4,
 	{
@@ -543,18 +543,18 @@ struct hw_fifo_info {
 
 struct pcidas64_board {
 	const char *name;
-	int device_id;		// pci device id
-	int ai_se_chans;	// number of ai inputs in single-ended mode
-	int ai_bits;		// analog input resolution
-	int ai_speed;		// fastest conversion period in ns
+	int device_id;		/*  pci device id */
+	int ai_se_chans;	/*  number of ai inputs in single-ended mode */
+	int ai_bits;		/*  analog input resolution */
+	int ai_speed;		/*  fastest conversion period in ns */
 	const struct comedi_lrange *ai_range_table;
-	int ao_nchan;		// number of analog out channels
-	int ao_bits;		// analog output resolution
-	int ao_scan_speed;	// analog output speed (for a scan, not conversion)
+	int ao_nchan;		/*  number of analog out channels */
+	int ao_bits;		/*  analog output resolution */
+	int ao_scan_speed;	/*  analog output speed (for a scan, not conversion) */
 	const struct comedi_lrange *ao_range_table;
 	const int *ao_range_code;
 	const struct hw_fifo_info *const ai_fifo;
-	enum register_layout layout;	// different board families have slightly different registers
+	enum register_layout layout;	/*  different board families have slightly different registers */
 	unsigned has_8255:1;
 };
 
@@ -612,7 +612,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	      has_8255:1,
 		},
 	{
-	      name:	"pci-das6402/12",	// XXX check
+	      name:	"pci-das6402/12",	/*  XXX check */
 	      device_id:0x1e,
 	      ai_se_chans:64,
 	      ai_bits:	12,
@@ -910,7 +910,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	      ai_speed:50,
 	      ao_bits:	12,
 	      ao_nchan:2,
-	      ao_scan_speed:0,	// no hardware pacing on ao
+	      ao_scan_speed:0,	/*  no hardware pacing on ao */
 	      layout:	LAYOUT_4020,
 	      ai_range_table:&ai_ranges_4020,
 	      ao_range_table:&ao_ranges_4020,
@@ -921,7 +921,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 #if 0
 	{
 	      name:	"pci-das6402/16/jr",
-	      device_id:0	// XXX,
+	      device_id:0	/*  XXX, */
 	      ai_se_chans:64,
 	      ai_bits:	16,
 	      ai_speed:5000,
@@ -934,7 +934,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		},
 	{
 	      name:	"pci-das64/m1/16/jr",
-	      device_id:0	// XXX,
+	      device_id:0	/*  XXX, */
 	      ai_se_chans:64,
 	      ai_bits:	16,
 	      ai_speed:1000,
@@ -947,7 +947,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		},
 	{
 	      name:	"pci-das64/m2/16/jr",
-	      device_id:0	// XXX,
+	      device_id:0	/*  XXX, */
 	      ai_se_chans:64,
 	      ai_bits:	16,
 	      ai_speed:500,
@@ -960,7 +960,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		},
 	{
 	      name:	"pci-das64/m3/16/jr",
-	      device_id:0	// XXX,
+	      device_id:0	/*  XXX, */
 	      ai_se_chans:64,
 	      ai_bits:	16,
 	      ai_speed:333,
@@ -973,7 +973,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		},
 	{
 	      name:	"pci-das64/m1/14",
-	      device_id:0,	// XXX
+	      device_id:0,	/*  XXX */
 	      ai_se_chans:64,
 	      ai_bits:	14,
 	      ai_speed:1000,
@@ -986,7 +986,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		},
 	{
 	      name:	"pci-das64/m2/14",
-	      device_id:0,	// XXX
+	      device_id:0,	/*  XXX */
 	      ai_se_chans:64,
 	      ai_bits:	14,
 	      ai_speed:500,
@@ -999,7 +999,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		},
 	{
 	      name:	"pci-das64/m3/14",
-	      device_id:0,	// XXX
+	      device_id:0,	/*  XXX */
 	      ai_se_chans:64,
 	      ai_bits:	14,
 	      ai_speed:333,
@@ -1013,7 +1013,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 #endif
 };
 
-// Number of boards in cb_pcidas_boards
+/* Number of boards in cb_pcidas_boards */
 static inline unsigned int num_boards(void)
 {
 	return sizeof(pcidas64_boards) / sizeof(struct pcidas64_board);
@@ -1060,50 +1060,50 @@ static inline unsigned short se_diff_bit_6xxx(struct comedi_device * dev,
 };
 
 struct ext_clock_info {
-	unsigned int divisor;	// master clock divisor to use for scans with external master clock
-	unsigned int chanspec;	// chanspec for master clock input when used as scan begin src
+	unsigned int divisor;	/*  master clock divisor to use for scans with external master clock */
+	unsigned int chanspec;	/*  chanspec for master clock input when used as scan begin src */
 };
 
 /* this structure is for data unique to this hardware driver. */
 struct pcidas64_private {
 
-	struct pci_dev *hw_dev;	// pointer to board's pci_dev struct
-	// base addresses (physical)
+	struct pci_dev *hw_dev;	/*  pointer to board's pci_dev struct */
+	/*  base addresses (physical) */
 	resource_size_t plx9080_phys_iobase;
 	resource_size_t main_phys_iobase;
 	resource_size_t dio_counter_phys_iobase;
-	// base addresses (ioremapped)
+	/*  base addresses (ioremapped) */
 	void *plx9080_iobase;
 	void *main_iobase;
 	void *dio_counter_iobase;
-	// local address (used by dma controller)
+	/*  local address (used by dma controller) */
 	uint32_t local0_iobase;
 	uint32_t local1_iobase;
-	volatile unsigned int ai_count;	// number of analog input samples remaining
-	uint16_t *ai_buffer[MAX_AI_DMA_RING_COUNT];	// dma buffers for analog input
-	dma_addr_t ai_buffer_bus_addr[MAX_AI_DMA_RING_COUNT];	// physical addresses of ai dma buffers
-	struct plx_dma_desc *ai_dma_desc;	// array of ai dma descriptors read by plx9080, allocated to get proper alignment
-	dma_addr_t ai_dma_desc_bus_addr;	// physical address of ai dma descriptor array
-	volatile unsigned int ai_dma_index;	// index of the ai dma descriptor/buffer that is currently being used
-	uint16_t *ao_buffer[AO_DMA_RING_COUNT];	// dma buffers for analog output
-	dma_addr_t ao_buffer_bus_addr[AO_DMA_RING_COUNT];	// physical addresses of ao dma buffers
+	volatile unsigned int ai_count;	/*  number of analog input samples remaining */
+	uint16_t *ai_buffer[MAX_AI_DMA_RING_COUNT];	/*  dma buffers for analog input */
+	dma_addr_t ai_buffer_bus_addr[MAX_AI_DMA_RING_COUNT];	/*  physical addresses of ai dma buffers */
+	struct plx_dma_desc *ai_dma_desc;	/*  array of ai dma descriptors read by plx9080, allocated to get proper alignment */
+	dma_addr_t ai_dma_desc_bus_addr;	/*  physical address of ai dma descriptor array */
+	volatile unsigned int ai_dma_index;	/*  index of the ai dma descriptor/buffer that is currently being used */
+	uint16_t *ao_buffer[AO_DMA_RING_COUNT];	/*  dma buffers for analog output */
+	dma_addr_t ao_buffer_bus_addr[AO_DMA_RING_COUNT];	/*  physical addresses of ao dma buffers */
 	struct plx_dma_desc *ao_dma_desc;
 	dma_addr_t ao_dma_desc_bus_addr;
-	volatile unsigned int ao_dma_index;	// keeps track of buffer where the next ao sample should go
-	volatile unsigned long ao_count;	// number of analog output samples remaining
-	volatile unsigned int ao_value[2];	// remember what the analog outputs are set to, to allow readback
-	unsigned int hw_revision;	// stc chip hardware revision number
-	volatile unsigned int intr_enable_bits;	// last bits sent to INTR_ENABLE_REG register
-	volatile uint16_t adc_control1_bits;	// last bits sent to ADC_CONTROL1_REG register
-	volatile uint16_t fifo_size_bits;	// last bits sent to FIFO_SIZE_REG register
-	volatile uint16_t hw_config_bits;	// last bits sent to HW_CONFIG_REG register
+	volatile unsigned int ao_dma_index;	/*  keeps track of buffer where the next ao sample should go */
+	volatile unsigned long ao_count;	/*  number of analog output samples remaining */
+	volatile unsigned int ao_value[2];	/*  remember what the analog outputs are set to, to allow readback */
+	unsigned int hw_revision;	/*  stc chip hardware revision number */
+	volatile unsigned int intr_enable_bits;	/*  last bits sent to INTR_ENABLE_REG register */
+	volatile uint16_t adc_control1_bits;	/*  last bits sent to ADC_CONTROL1_REG register */
+	volatile uint16_t fifo_size_bits;	/*  last bits sent to FIFO_SIZE_REG register */
+	volatile uint16_t hw_config_bits;	/*  last bits sent to HW_CONFIG_REG register */
 	volatile uint16_t dac_control1_bits;
-	volatile uint32_t plx_control_bits;	// last bits written to plx9080 control register
-	volatile uint32_t plx_intcsr_bits;	// last bits written to plx interrupt control and status register
-	volatile int calibration_source;	// index of calibration source readable through ai ch0
-	volatile uint8_t i2c_cal_range_bits;	// bits written to i2c calibration/range register
-	volatile unsigned int ext_trig_falling;	// configure digital triggers to trigger on falling edge
-	// states of various devices stored to enable read-back
+	volatile uint32_t plx_control_bits;	/*  last bits written to plx9080 control register */
+	volatile uint32_t plx_intcsr_bits;	/*  last bits written to plx interrupt control and status register */
+	volatile int calibration_source;	/*  index of calibration source readable through ai ch0 */
+	volatile uint8_t i2c_cal_range_bits;	/*  bits written to i2c calibration/range register */
+	volatile unsigned int ext_trig_falling;	/*  configure digital triggers to trigger on falling edge */
+	/*  states of various devices stored to enable read-back */
 	unsigned int ad8402_state[2];
 	unsigned int caldac_state[8];
 	volatile short ai_cmd_running;
@@ -1185,7 +1185,7 @@ static void caldac_write(struct comedi_device * dev, unsigned int channel,
 	unsigned int value);
 static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
 	uint8_t value);
-//static int dac_1590_write(struct comedi_device *dev, unsigned int dac_a, unsigned int dac_b);
+/* static int dac_1590_write(struct comedi_device *dev, unsigned int dac_a, unsigned int dac_b); */
 static int caldac_i2c_write(struct comedi_device * dev, unsigned int caldac_channel,
 	unsigned int value);
 static void abort_dma(struct comedi_device * dev, unsigned int channel);
@@ -1274,7 +1274,7 @@ static inline int ao_cmd_is_supported(const struct pcidas64_board * board)
 	return board->ao_nchan && board->layout != LAYOUT_4020;
 }
 
-// initialize plx9080 chip
+/* initialize plx9080 chip */
 static void init_plx9080(struct comedi_device * dev)
 {
 	uint32_t bits;
@@ -1283,7 +1283,7 @@ static void init_plx9080(struct comedi_device * dev)
 	priv(dev)->plx_control_bits =
 		readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG);
 
-	// plx9080 dump
+	/*  plx9080 dump */
 	DEBUG_PRINT(" plx interrupt status 0x%x\n",
 		readl(plx_iobase + PLX_INTRCS_REG));
 	DEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));
@@ -1327,35 +1327,35 @@ static void init_plx9080(struct comedi_device * dev)
 	abort_dma(dev, 0);
 	abort_dma(dev, 1);
 
-	// configure dma0 mode
+	/*  configure dma0 mode */
 	bits = 0;
-	// enable ready input, not sure if this is necessary
+	/*  enable ready input, not sure if this is necessary */
 	bits |= PLX_DMA_EN_READYIN_BIT;
-	// enable bterm, not sure if this is necessary
+	/*  enable bterm, not sure if this is necessary */
 	bits |= PLX_EN_BTERM_BIT;
-	// enable dma chaining
+	/*  enable dma chaining */
 	bits |= PLX_EN_CHAIN_BIT;
-	// enable interrupt on dma done (probably don't need this, since chain never finishes)
+	/*  enable interrupt on dma done (probably don't need this, since chain never finishes) */
 	bits |= PLX_EN_DMA_DONE_INTR_BIT;
-	// don't increment local address during transfers (we are transferring from a fixed fifo register)
+	/*  don't increment local address during transfers (we are transferring from a fixed fifo register) */
 	bits |= PLX_LOCAL_ADDR_CONST_BIT;
-	// route dma interrupt to pci bus
+	/*  route dma interrupt to pci bus */
 	bits |= PLX_DMA_INTR_PCI_BIT;
-	// enable demand mode
+	/*  enable demand mode */
 	bits |= PLX_DEMAND_MODE_BIT;
-	// enable local burst mode
+	/*  enable local burst mode */
 	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
-	// 4020 uses 32 bit dma
+	/*  4020 uses 32 bit dma */
 	if (board(dev)->layout == LAYOUT_4020) {
 		bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
-	} else {		// localspace0 bus is 16 bits wide
+	} else {		/*  localspace0 bus is 16 bits wide */
 		bits |= PLX_LOCAL_BUS_16_WIDE_BITS;
 	}
 	writel(bits, plx_iobase + PLX_DMA1_MODE_REG);
 	if (ao_cmd_is_supported(board(dev)))
 		writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
 
-	// enable interrupts on plx 9080
+	/*  enable interrupts on plx 9080 */
 	priv(dev)->plx_intcsr_bits |=
 		ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
 		ICS_DMA0_E | ICS_DMA1_E;
@@ -1396,9 +1396,9 @@ static int setup_subdevices(struct comedi_device * dev)
 	if (board(dev)->layout == LAYOUT_4020) {
 		unsigned int i;
 		uint8_t data;
-		// set adc to read from inputs (not internal calibration sources)
+		/*  set adc to read from inputs (not internal calibration sources) */
 		priv(dev)->i2c_cal_range_bits = adc_src_4020_bits(4);
-		// set channels to +-5 volt input ranges
+		/*  set channels to +-5 volt input ranges */
 		for (i = 0; i < s->n_chan; i++)
 			priv(dev)->i2c_cal_range_bits |= attenuate_bit(i);
 		data = priv(dev)->i2c_cal_range_bits;
@@ -1428,7 +1428,7 @@ static int setup_subdevices(struct comedi_device * dev)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	// digital input
+	/*  digital input */
 	s = dev->subdevices + 2;
 	if (board(dev)->layout == LAYOUT_64XX) {
 		s->type = COMEDI_SUBD_DI;
@@ -1440,7 +1440,7 @@ static int setup_subdevices(struct comedi_device * dev)
 	} else
 		s->type = COMEDI_SUBD_UNUSED;
 
-	// digital output
+	/*  digital output */
 	if (board(dev)->layout == LAYOUT_64XX) {
 		s = dev->subdevices + 3;
 		s->type = COMEDI_SUBD_DO;
@@ -1469,7 +1469,7 @@ static int setup_subdevices(struct comedi_device * dev)
 	} else
 		s->type = COMEDI_SUBD_UNUSED;
 
-	// 8 channel dio for 60xx
+	/*  8 channel dio for 60xx */
 	s = dev->subdevices + 5;
 	if (board(dev)->layout == LAYOUT_60XX) {
 		s->type = COMEDI_SUBD_DIO;
@@ -1482,7 +1482,7 @@ static int setup_subdevices(struct comedi_device * dev)
 	} else
 		s->type = COMEDI_SUBD_UNUSED;
 
-	// caldac
+	/*  caldac */
 	s = dev->subdevices + 6;
 	s->type = COMEDI_SUBD_CALIB;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
@@ -1496,7 +1496,7 @@ static int setup_subdevices(struct comedi_device * dev)
 	for (i = 0; i < s->n_chan; i++)
 		caldac_write(dev, i, s->maxdata / 2);
 
-	// 2 channel ad8402 potentiometer
+	/*  2 channel ad8402 potentiometer */
 	s = dev->subdevices + 7;
 	if (board(dev)->layout == LAYOUT_64XX) {
 		s->type = COMEDI_SUBD_CALIB;
@@ -1510,7 +1510,7 @@ static int setup_subdevices(struct comedi_device * dev)
 	} else
 		s->type = COMEDI_SUBD_UNUSED;
 
-	//serial EEPROM, if present
+	/* serial EEPROM, if present */
 	s = dev->subdevices + 8;
 	if (readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG) & CTL_EECHK) {
 		s->type = COMEDI_SUBD_MEMORY;
@@ -1521,7 +1521,7 @@ static int setup_subdevices(struct comedi_device * dev)
 	} else
 		s->type = COMEDI_SUBD_UNUSED;
 
-	// user counter subd XXX
+	/*  user counter subd XXX */
 	s = dev->subdevices + 9;
 	s->type = COMEDI_SUBD_UNUSED;
 
@@ -1542,13 +1542,13 @@ static void init_stc_registers(struct comedi_device * dev)
 
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 
-	// bit should be set for 6025, although docs say boards with <= 16 chans should be cleared XXX
+	/*  bit should be set for 6025, although docs say boards with <= 16 chans should be cleared XXX */
 	if (1)
 		priv(dev)->adc_control1_bits |= ADC_QUEUE_CONFIG_BIT;
 	writew(priv(dev)->adc_control1_bits,
 		priv(dev)->main_iobase + ADC_CONTROL1_REG);
 
-	// 6402/16 manual says this register must be initialized to 0xff?
+	/*  6402/16 manual says this register must be initialized to 0xff? */
 	writew(0xff, priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
 
 	bits = SLOW_DAC_BIT | DMA_CH_SELECT_BIT;
@@ -1563,7 +1563,7 @@ static void init_stc_registers(struct comedi_device * dev)
 
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// set fifos to maximum size
+	/*  set fifos to maximum size */
 	priv(dev)->fifo_size_bits |= DAC_FIFO_BITS;
 	set_ai_fifo_segment_length(dev,
 		board(dev)->ai_fifo->max_segment_length);
@@ -1581,7 +1581,7 @@ int alloc_and_init_dma_members(struct comedi_device * dev)
 {
 	int i;
 
-	// alocate pci dma buffers
+	/*  alocate pci dma buffers */
 	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 		priv(dev)->ai_buffer[i] =
 			pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
@@ -1601,7 +1601,7 @@ int alloc_and_init_dma_members(struct comedi_device * dev)
 			}
 		}
 	}
-	// allocate dma descriptors
+	/*  allocate dma descriptors */
 	priv(dev)->ai_dma_desc =
 		pci_alloc_consistent(priv(dev)->hw_dev,
 		sizeof(struct plx_dma_desc) * ai_dma_ring_count(board(dev)),
@@ -1622,7 +1622,7 @@ int alloc_and_init_dma_members(struct comedi_device * dev)
 		DEBUG_PRINT("ao dma descriptors start at bus addr 0x%x\n",
 			priv(dev)->ao_dma_desc_bus_addr);
 	}
-	// initialize dma descriptors
+	/*  initialize dma descriptors */
 	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 		priv(dev)->ai_dma_desc[i].pci_start_addr =
 			cpu_to_le32(priv(dev)->ai_buffer_bus_addr[i]);
@@ -1697,16 +1697,16 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
 		pcidev != NULL;
 		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
-		// is it not a computer boards card?
+		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
 			continue;
-		// loop through cards supported by this driver
+		/*  loop through cards supported by this driver */
 		for (index = 0; index < num_boards(); index++) {
 			if (pcidas64_boards[index].device_id != pcidev->device)
 				continue;
-			// was a particular bus/slot requested?
+			/*  was a particular bus/slot requested? */
 			if (it->options[0] || it->options[1]) {
-				// are we on the wrong bus/slot?
+				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
 					PCI_SLOT(pcidev->devfn) !=
 					it->options[1]) {
@@ -1736,7 +1736,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	pci_set_master(pcidev);
 
-	//Initialize dev->board_name
+	/* Initialize dev->board_name */
 	dev->board_name = board(dev)->name;
 
 	priv(dev)->plx9080_phys_iobase =
@@ -1746,7 +1746,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	priv(dev)->dio_counter_phys_iobase =
 		pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
 
-	// remap, won't work with 2.0 kernels but who cares
+	/*  remap, won't work with 2.0 kernels but who cares */
 	priv(dev)->plx9080_iobase = ioremap(priv(dev)->plx9080_phys_iobase,
 		pci_resource_len(pcidev, PLX9080_BADDRINDEX));
 	priv(dev)->main_iobase = ioremap(priv(dev)->main_phys_iobase,
@@ -1766,7 +1766,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	DEBUG_PRINT(" diocounter remapped to 0x%p\n",
 		priv(dev)->dio_counter_iobase);
 
-	// figure out what local addresses are
+	/*  figure out what local addresses are */
 	local_range =
 		readl(priv(dev)->plx9080_iobase +
 		PLX_LAS0RNG_REG) & LRNG_MEM_MASK;
@@ -1798,7 +1798,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	printk(" stc hardware revision %i\n", priv(dev)->hw_revision);
 	init_plx9080(dev);
 	init_stc_registers(dev);
-	// get irq
+	/*  get irq */
 	if (comedi_request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
 			"cb_pcidas64", dev)) {
 		printk(" unable to allocate irq %u\n", pcidev->irq);
@@ -1841,7 +1841,7 @@ static int detach(struct comedi_device * dev)
 				iounmap((void *)priv(dev)->main_iobase);
 			if (priv(dev)->dio_counter_iobase)
 				iounmap((void *)priv(dev)->dio_counter_iobase);
-			// free pci dma buffers
+			/*  free pci dma buffers */
 			for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 				if (priv(dev)->ai_buffer[i])
 					pci_free_consistent(priv(dev)->hw_dev,
@@ -1858,7 +1858,7 @@ static int detach(struct comedi_device * dev)
 						priv(dev)->
 						ao_buffer_bus_addr[i]);
 			}
-			// free dma descriptors
+			/*  free dma descriptors */
 			if (priv(dev)->ai_dma_desc)
 				pci_free_consistent(priv(dev)->hw_dev,
 					sizeof(struct plx_dma_desc) *
@@ -1896,8 +1896,8 @@ static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	range = CR_RANGE(insn->chanspec);
 	aref = CR_AREF(insn->chanspec);
 
-	// disable card's analog input interrupt sources and pacing
-	// 4020 generates dac done interrupts even though they are disabled
+	/*  disable card's analog input interrupt sources and pacing */
+	/*  4020 generates dac done interrupts even though they are disabled */
 	disable_ai_pacing(dev);
 
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
@@ -1910,12 +1910,12 @@ static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (board(dev)->layout != LAYOUT_4020) {
-		// use internal queue
+		/*  use internal queue */
 		priv(dev)->hw_config_bits &= ~EXT_QUEUE_BIT;
 		writew(priv(dev)->hw_config_bits,
 			priv(dev)->main_iobase + HW_CONFIG_REG);
 
-		// ALT_SOURCE is internal calibration reference
+		/*  ALT_SOURCE is internal calibration reference */
 		if (insn->chanspec & CR_ALT_SOURCE) {
 			unsigned int cal_en_bit;
 
@@ -1924,27 +1924,27 @@ static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 				cal_en_bit = CAL_EN_60XX_BIT;
 			else
 				cal_en_bit = CAL_EN_64XX_BIT;
-			// select internal reference source to connect to channel 0
+			/*  select internal reference source to connect to channel 0 */
 			writew(cal_en_bit | adc_src_bits(priv(dev)->
 					calibration_source),
 				priv(dev)->main_iobase + CALIBRATION_REG);
 		} else {
-			// make sure internal calibration source is turned off
+			/*  make sure internal calibration source is turned off */
 			writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
 		}
-		// load internal queue
+		/*  load internal queue */
 		bits = 0;
-		// set gain
+		/*  set gain */
 		bits |= ai_range_bits_6xxx(dev, CR_RANGE(insn->chanspec));
-		// set single-ended / differential
+		/*  set single-ended / differential */
 		bits |= se_diff_bit_6xxx(dev, aref == AREF_DIFF);
 		if (aref == AREF_COMMON)
 			bits |= ADC_COMMON_BIT;
 		bits |= adc_chan_bits(channel);
-		// set stop channel
+		/*  set stop channel */
 		writew(adc_chan_bits(channel),
 			priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
-		// set start channel, and rest of settings
+		/*  set start channel, and rest of settings */
 		writew(bits, priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
 	} else {
 		uint8_t old_cal_range_bits = priv(dev)->i2c_cal_range_bits;
@@ -1955,16 +1955,16 @@ static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 			priv(dev)->i2c_cal_range_bits |=
 				adc_src_4020_bits(priv(dev)->
 				calibration_source);
-		} else {	//select BNC inputs
+		} else {	/* select BNC inputs */
 			priv(dev)->i2c_cal_range_bits |= adc_src_4020_bits(4);
 		}
-		// select range
+		/*  select range */
 		if (range == 0)
 			priv(dev)->i2c_cal_range_bits |= attenuate_bit(channel);
 		else
 			priv(dev)->i2c_cal_range_bits &=
 				~attenuate_bit(channel);
-		// update calibration/range i2c register only if necessary, as it is very slow
+		/*  update calibration/range i2c register only if necessary, as it is very slow */
 		if (old_cal_range_bits != priv(dev)->i2c_cal_range_bits) {
 			uint8_t i2c_data = priv(dev)->i2c_cal_range_bits;
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
@@ -1981,14 +1981,14 @@ static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 
 	for (n = 0; n < insn->n; n++) {
 
-		// clear adc buffer (inside loop for 4020 sake)
+		/*  clear adc buffer (inside loop for 4020 sake) */
 		writew(0, priv(dev)->main_iobase + ADC_BUFFER_CLEAR_REG);
 
 		/* trigger conversion, bits sent only matter for 4020 */
 		writew(adc_convert_chan_4020_bits(CR_CHAN(insn->chanspec)),
 			priv(dev)->main_iobase + ADC_CONVERT_REG);
 
-		// wait for data
+		/*  wait for data */
 		for (i = 0; i < timeout; i++) {
 			bits = readw(priv(dev)->main_iobase + HW_STATUS_REG);
 			DEBUG_PRINT(" pipe bits 0x%x\n", pipe_full_bits(bits));
@@ -2092,7 +2092,7 @@ static int ai_config_master_clock_4020(struct comedi_device * dev, unsigned int
 	return retval ? retval : 5;
 }
 
-// XXX could add support for 60xx series
+/* XXX could add support for 60xx series */
 static int ai_config_master_clock(struct comedi_device * dev, unsigned int * data)
 {
 
@@ -2182,7 +2182,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
-	// uniqueness check
+	/*  uniqueness check */
 	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
@@ -2196,7 +2196,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
 		err++;
 
-	// compatibility check
+	/*  compatibility check */
 	if (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
@@ -2220,7 +2220,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 				err++;
 			}
 			if (cmd->scan_begin_src == TRIG_TIMER) {
-				// if scans are timed faster than conversion rate allows
+				/*  if scans are timed faster than conversion rate allows */
 				if (cmd->convert_arg * cmd->chanlist_len >
 					cmd->scan_begin_arg) {
 					cmd->scan_begin_arg =
@@ -2278,7 +2278,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	if (err)
 		return 4;
 
-	// make sure user is doesn't change analog reference mid chanlist
+	/*  make sure user is doesn't change analog reference mid chanlist */
 	if (cmd->chanlist) {
 		aref = CR_AREF(cmd->chanlist[0]);
 		for (i = 1; i < cmd->chanlist_len; i++) {
@@ -2289,7 +2289,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 				break;
 			}
 		}
-		// check 4020 chanlist
+		/*  check 4020 chanlist */
 		if (board(dev)->layout == LAYOUT_4020) {
 			unsigned int first_channel = CR_CHAN(cmd->chanlist[0]);
 			for (i = 1; i < cmd->chanlist_len; i++) {
@@ -2317,7 +2317,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 
 static int use_hw_sample_counter(struct comedi_cmd * cmd)
 {
-// disable for now until I work out a race
+/* disable for now until I work out a race */
 	return 0;
 
 	if (cmd->stop_src == TRIG_COUNT && cmd->stop_arg <= max_counter_value)
@@ -2329,10 +2329,10 @@ static int use_hw_sample_counter(struct comedi_cmd * cmd)
 static void setup_sample_counters(struct comedi_device * dev, struct comedi_cmd * cmd)
 {
 	if (cmd->stop_src == TRIG_COUNT) {
-		// set software count
+		/*  set software count */
 		priv(dev)->ai_count = cmd->stop_arg * cmd->chanlist_len;
 	}
-	// load hardware conversion counter
+	/*  load hardware conversion counter */
 	if (use_hw_sample_counter(cmd)) {
 		writew(cmd->stop_arg & 0xffff,
 			priv(dev)->main_iobase + ADC_COUNT_LOWER_REG);
@@ -2396,9 +2396,9 @@ static void enable_ai_interrupts(struct comedi_device * dev, const struct comedi
 
 	bits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |
 		EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;
-	// Use pio transfer and interrupt on end of conversion if TRIG_WAKE_EOS flag is set.
+	/*  Use pio transfer and interrupt on end of conversion if TRIG_WAKE_EOS flag is set. */
 	if (cmd->flags & TRIG_WAKE_EOS) {
-		// 4020 doesn't support pio transfers except for fifo dregs
+		/*  4020 doesn't support pio transfers except for fifo dregs */
 		if (board(dev)->layout != LAYOUT_4020)
 			bits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;
 	}
@@ -2413,14 +2413,14 @@ static void enable_ai_interrupts(struct comedi_device * dev, const struct comedi
 static uint32_t ai_convert_counter_6xxx(const struct comedi_device * dev,
 	const struct comedi_cmd * cmd)
 {
-	// supposed to load counter with desired divisor minus 3
+	/*  supposed to load counter with desired divisor minus 3 */
 	return cmd->convert_arg / TIMER_BASE - 3;
 }
 
 static uint32_t ai_scan_counter_6xxx(struct comedi_device * dev, struct comedi_cmd * cmd)
 {
 	uint32_t count;
-	// figure out how long we need to delay at end of scan
+	/*  figure out how long we need to delay at end of scan */
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
 		count = (cmd->scan_begin_arg -
@@ -2448,20 +2448,20 @@ static uint32_t ai_convert_counter_4020(struct comedi_device * dev, struct comed
 	case TRIG_OTHER:
 		divisor = priv(dev)->ext_clock.divisor;
 		break;
-	default:		// should never happen
+	default:		/*  should never happen */
 		comedi_error(dev, "bug! failed to set ai pacing!");
 		divisor = 1000;
 		break;
 	}
 
-	// supposed to load counter with desired divisor minus 2 for 4020
+	/*  supposed to load counter with desired divisor minus 2 for 4020 */
 	return divisor - 2;
 }
 
 static void select_master_clock_4020(struct comedi_device * dev,
 	const struct comedi_cmd * cmd)
 {
-	// select internal/external master clock
+	/*  select internal/external master clock */
 	priv(dev)->hw_config_bits &= ~MASTER_CLOCK_4020_MASK;
 	if (cmd->scan_begin_src == TRIG_OTHER) {
 		int chanspec = priv(dev)->ext_clock.chanspec;
@@ -2492,7 +2492,7 @@ static inline void dma_start_sync(struct comedi_device * dev, unsigned int chann
 {
 	unsigned long flags;
 
-	// spinlock for plx dma control/status reg
+	/*  spinlock for plx dma control/status reg */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	if (channel)
 		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
@@ -2520,17 +2520,17 @@ static void set_ai_pacing(struct comedi_device * dev, struct comedi_cmd * cmd)
 		scan_counter = ai_scan_counter_6xxx(dev, cmd);
 	}
 
-	// load lower 16 bits of convert interval
+	/*  load lower 16 bits of convert interval */
 	writew(convert_counter & 0xffff,
 		priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
 	DEBUG_PRINT("convert counter 0x%x\n", convert_counter);
-	// load upper 8 bits of convert interval
+	/*  load upper 8 bits of convert interval */
 	writew((convert_counter >> 16) & 0xff,
 		priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
-	// load lower 16 bits of scan delay
+	/*  load lower 16 bits of scan delay */
 	writew(scan_counter & 0xffff,
 		priv(dev)->main_iobase + ADC_DELAY_INTERVAL_LOWER_REG);
-	// load upper 8 bits of scan delay
+	/*  load upper 8 bits of scan delay */
 	writew((scan_counter >> 16) & 0xff,
 		priv(dev)->main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);
 	DEBUG_PRINT("scan counter 0x%x\n", scan_counter);
@@ -2563,25 +2563,25 @@ static int setup_channel_queue(struct comedi_device * dev, const struct comedi_c
 			writew(priv(dev)->hw_config_bits,
 				priv(dev)->main_iobase + HW_CONFIG_REG);
 			bits = 0;
-			// set channel
+			/*  set channel */
 			bits |= adc_chan_bits(CR_CHAN(cmd->chanlist[0]));
-			// set gain
+			/*  set gain */
 			bits |= ai_range_bits_6xxx(dev,
 				CR_RANGE(cmd->chanlist[0]));
-			// set single-ended / differential
+			/*  set single-ended / differential */
 			bits |= se_diff_bit_6xxx(dev,
 				CR_AREF(cmd->chanlist[0]) == AREF_DIFF);
 			if (CR_AREF(cmd->chanlist[0]) == AREF_COMMON)
 				bits |= ADC_COMMON_BIT;
-			// set stop channel
+			/*  set stop channel */
 			writew(adc_chan_bits(CR_CHAN(cmd->chanlist[cmd->
 							chanlist_len - 1])),
 				priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
-			// set start channel, and rest of settings
+			/*  set start channel, and rest of settings */
 			writew(bits,
 				priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
 		} else {
-			// use external queue
+			/*  use external queue */
 			if (dev->write_subdev && dev->write_subdev->busy) {
 				warn_external_queue(dev);
 				return -EBUSY;
@@ -2589,26 +2589,26 @@ static int setup_channel_queue(struct comedi_device * dev, const struct comedi_c
 			priv(dev)->hw_config_bits |= EXT_QUEUE_BIT;
 			writew(priv(dev)->hw_config_bits,
 				priv(dev)->main_iobase + HW_CONFIG_REG);
-			// clear DAC buffer to prevent weird interactions
+			/*  clear DAC buffer to prevent weird interactions */
 			writew(0,
 				priv(dev)->main_iobase + DAC_BUFFER_CLEAR_REG);
-			// clear queue pointer
+			/*  clear queue pointer */
 			writew(0, priv(dev)->main_iobase + ADC_QUEUE_CLEAR_REG);
-			// load external queue
+			/*  load external queue */
 			for (i = 0; i < cmd->chanlist_len; i++) {
 				bits = 0;
-				// set channel
+				/*  set channel */
 				bits |= adc_chan_bits(CR_CHAN(cmd->
 						chanlist[i]));
-				// set gain
+				/*  set gain */
 				bits |= ai_range_bits_6xxx(dev,
 					CR_RANGE(cmd->chanlist[i]));
-				// set single-ended / differential
+				/*  set single-ended / differential */
 				bits |= se_diff_bit_6xxx(dev,
 					CR_AREF(cmd->chanlist[i]) == AREF_DIFF);
 				if (CR_AREF(cmd->chanlist[i]) == AREF_COMMON)
 					bits |= ADC_COMMON_BIT;
-				// mark end of queue
+				/*  mark end of queue */
 				if (i == cmd->chanlist_len - 1)
 					bits |= QUEUE_EOSCAN_BIT |
 						QUEUE_EOSEQ_BIT;
@@ -2622,7 +2622,7 @@ static int setup_channel_queue(struct comedi_device * dev, const struct comedi_c
 			/* doing a queue clear is not specified in board docs,
 			 * but required for reliable operation */
 			writew(0, priv(dev)->main_iobase + ADC_QUEUE_CLEAR_REG);
-			// prime queue holding register
+			/*  prime queue holding register */
 			writew(0, priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
 		}
 	} else {
@@ -2630,9 +2630,9 @@ static int setup_channel_queue(struct comedi_device * dev, const struct comedi_c
 			priv(dev)->i2c_cal_range_bits;
 
 		priv(dev)->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;
-		//select BNC inputs
+		/* select BNC inputs */
 		priv(dev)->i2c_cal_range_bits |= adc_src_4020_bits(4);
-		// select ranges
+		/*  select ranges */
 		for (i = 0; i < cmd->chanlist_len; i++) {
 			unsigned int channel = CR_CHAN(cmd->chanlist[i]);
 			unsigned int range = CR_RANGE(cmd->chanlist[i]);
@@ -2644,7 +2644,7 @@ static int setup_channel_queue(struct comedi_device * dev, const struct comedi_c
 				priv(dev)->i2c_cal_range_bits &=
 					~attenuate_bit(channel);
 		}
-		// update calibration/range i2c register only if necessary, as it is very slow
+		/*  update calibration/range i2c register only if necessary, as it is very slow */
 		if (old_cal_range_bits != priv(dev)->i2c_cal_range_bits) {
 			uint8_t i2c_data = priv(dev)->i2c_cal_range_bits;
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
@@ -2697,7 +2697,7 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	if (retval < 0)
 		return retval;
 
-	// make sure internal calibration source is turned off
+	/*  make sure internal calibration source is turned off */
 	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
 
 	set_ai_pacing(dev, cmd);
@@ -2713,9 +2713,9 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	if (board(dev)->layout != LAYOUT_4020) {
 		priv(dev)->adc_control1_bits &= ~ADC_MODE_MASK;
 		if (cmd->convert_src == TRIG_EXT)
-			priv(dev)->adc_control1_bits |= adc_mode_bits(13);	// good old mode 13
+			priv(dev)->adc_control1_bits |= adc_mode_bits(13);	/*  good old mode 13 */
 		else
-			priv(dev)->adc_control1_bits |= adc_mode_bits(8);	// mode 8.  What else could you need?
+			priv(dev)->adc_control1_bits |= adc_mode_bits(8);	/*  mode 8.  What else could you need? */
 	} else {
 		priv(dev)->adc_control1_bits &= ~CHANNEL_MODE_4020_MASK;
 		if (cmd->chanlist_len == 4)
@@ -2735,20 +2735,20 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	DEBUG_PRINT("control1 bits 0x%x\n", priv(dev)->adc_control1_bits);
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// clear adc buffer
+	/*  clear adc buffer */
 	writew(0, priv(dev)->main_iobase + ADC_BUFFER_CLEAR_REG);
 
 	if ((cmd->flags & TRIG_WAKE_EOS) == 0 ||
 		board(dev)->layout == LAYOUT_4020) {
 		priv(dev)->ai_dma_index = 0;
 
-		// set dma transfer size
+		/*  set dma transfer size */
 		for (i = 0; i < ai_dma_ring_count(board(dev)); i++)
 			priv(dev)->ai_dma_desc[i].transfer_size =
 				cpu_to_le32(dma_transfer_size(dev) *
 				sizeof(uint16_t));
 
-		// give location of first dma descriptor
+		/*  give location of first dma descriptor */
 		load_first_dma_descriptor(dev, 1,
 			priv(dev)->
 			ai_dma_desc_bus_addr | PLX_DESC_IN_PCI_BIT |
@@ -2773,7 +2773,7 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	bits = ADC_ENABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT;
 	if (cmd->flags & TRIG_WAKE_EOS)
 		bits |= ADC_DMA_DISABLE_BIT;
-	// set start trigger
+	/*  set start trigger */
 	if (cmd->start_src == TRIG_EXT) {
 		bits |= ADC_START_TRIG_EXT_BITS;
 		if (cmd->start_arg & CR_INVERT)
@@ -2789,7 +2789,7 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// start aquisition
+	/*  start aquisition */
 	if (cmd->start_src == TRIG_NOW) {
 		writew(0, priv(dev)->main_iobase + ADC_START_REG);
 		DEBUG_PRINT("soft trig\n");
@@ -2798,7 +2798,7 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-// read num_samples from 16 bit wide ai fifo
+/* read num_samples from 16 bit wide ai fifo */
 static void pio_drain_ai_fifo_16(struct comedi_device * dev)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
@@ -2810,7 +2810,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device * dev)
 	int num_samples;
 
 	do {
-		// get least significant 15 bits
+		/*  get least significant 15 bits */
 		read_index =
 			readw(priv(dev)->main_iobase +
 			ADC_READ_PNTR_REG) & 0x7fff;
@@ -2899,7 +2899,7 @@ static void pio_drain_ai_fifo_32(struct comedi_device * dev)
 	priv(dev)->ai_count -= i;
 }
 
-// empty fifo
+/* empty fifo */
 static void pio_drain_ai_fifo(struct comedi_device * dev)
 {
 	if (board(dev)->layout == LAYOUT_4020) {
@@ -2923,7 +2923,7 @@ static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 		pci_addr_reg =
 			priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 
-	// loop until we have read all the full buffers
+	/*  loop until we have read all the full buffers */
 	for (j = 0, next_transfer_addr = readl(pci_addr_reg);
 		(next_transfer_addr <
 			priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index]
@@ -2931,7 +2931,7 @@ static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 			priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index] +
 			DMA_BUFFER_SIZE) && j < ai_dma_ring_count(board(dev));
 		j++) {
-		// transfer data from dma buffer to comedi buffer
+		/*  transfer data from dma buffer to comedi buffer */
 		num_samples = dma_transfer_size(dev);
 		if (async->cmd.stop_src == TRIG_COUNT) {
 			if (num_samples > priv(dev)->ai_count)
@@ -2963,15 +2963,15 @@ void handle_ai_interrupt(struct comedi_device * dev, unsigned short status,
 	uint8_t dma1_status;
 	unsigned long flags;
 
-	// check for fifo overrun
+	/*  check for fifo overrun */
 	if (status & ADC_OVERRUN_BIT) {
 		comedi_error(dev, "fifo overrun");
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
-	// spin lock makes sure noone else changes plx dma control reg
+	/*  spin lock makes sure noone else changes plx dma control reg */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
-	if (plx_status & ICS_DMA1_A) {	// dma chan 1 interrupt
+	if (plx_status & ICS_DMA1_A) {	/*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
 			priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
@@ -2986,7 +2986,7 @@ void handle_ai_interrupt(struct comedi_device * dev, unsigned short status,
 	if (status & ADC_DONE_BIT)
 		DEBUG_PRINT("adc done interrupt\n");
 
-	// drain fifo with pio
+	/*  drain fifo with pio */
 	if ((status & ADC_DONE_BIT) ||
 		((cmd->flags & TRIG_WAKE_EOS) &&
 			(status & ADC_INTR_PENDING_BIT) &&
@@ -2999,7 +2999,7 @@ void handle_ai_interrupt(struct comedi_device * dev, unsigned short status,
 		} else
 			comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
-	// if we are have all the data, then quit
+	/*  if we are have all the data, then quit */
 	if ((cmd->stop_src == TRIG_COUNT && priv(dev)->ai_count <= 0) ||
 		(cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT))) {
 		async->events |= COMEDI_CB_EOA;
@@ -3091,10 +3091,10 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned short statu
 	async = s->async;
 	cmd = &async->cmd;
 
-	// spin lock makes sure noone else changes plx dma control reg
+	/*  spin lock makes sure noone else changes plx dma control reg */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
-	if (plx_status & ICS_DMA0_A) {	// dma chan 0 interrupt
+	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		if ((dma0_status & PLX_DMA_EN_BIT)
 			&& !(dma0_status & PLX_DMA_DONE_BIT))
 			writeb(PLX_DMA_EN_BIT | PLX_CLEAR_DMA_INTR_BIT,
@@ -3152,8 +3152,8 @@ static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
 	handle_ai_interrupt(dev, status, plx_status);
 	handle_ao_interrupt(dev, status, plx_status);
 
-	// clear possible plx9080 interrupt sources
-	if (plx_status & ICS_LDIA) {	// clear local doorbell interrupt
+	/*  clear possible plx9080 interrupt sources */
+	if (plx_status & ICS_LDIA) {	/*  clear local doorbell interrupt */
 		plx_bits = readl(priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);
 		writel(plx_bits, priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);
 		DEBUG_PRINT(" cleared local doorbell bits 0x%x\n", plx_bits);
@@ -3168,7 +3168,7 @@ void abort_dma(struct comedi_device * dev, unsigned int channel)
 {
 	unsigned long flags;
 
-	// spinlock for plx dma control/status reg
+	/*  spinlock for plx dma control/status reg */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 
 	plx9080_abort_dma(priv(dev)->plx9080_iobase, channel);
@@ -3202,15 +3202,15 @@ static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	int chan = CR_CHAN(insn->chanspec);
 	int range = CR_RANGE(insn->chanspec);
 
-	// do some initializing
+	/*  do some initializing */
 	writew(0, priv(dev)->main_iobase + DAC_CONTROL0_REG);
 
-	// set range
+	/*  set range */
 	set_dac_range_bits(dev, &priv(dev)->dac_control1_bits, chan, range);
 	writew(priv(dev)->dac_control1_bits,
 		priv(dev)->main_iobase + DAC_CONTROL1_REG);
 
-	// write to channel
+	/*  write to channel */
 	if (board(dev)->layout == LAYOUT_4020) {
 		writew(data[0] & 0xff,
 			priv(dev)->main_iobase + dac_lsb_4020_reg(chan));
@@ -3220,7 +3220,7 @@ static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 		writew(data[0], priv(dev)->main_iobase + dac_convert_reg(chan));
 	}
 
-	// remember output value
+	/*  remember output value */
 	priv(dev)->ao_value[chan] = data[0];
 
 	return 1;
@@ -3503,14 +3503,14 @@ static int ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
-	// uniqueness check
+	/*  uniqueness check */
 	if (cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
 		cmd->scan_begin_src != TRIG_EXT)
 		err++;
 
-	// compatibility check
+	/*  compatibility check */
 	if (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
@@ -3624,9 +3624,9 @@ static int do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] &= 0xf;
-	// zero bits we are going to change
+	/*  zero bits we are going to change */
 	s->state &= ~data[0];
-	// set new bits
+	/*  set new bits */
 	s->state |= data[0] & data[1];
 
 	writeb(s->state, priv(dev)->dio_counter_iobase + DO_REG);
@@ -3793,24 +3793,24 @@ static uint16_t read_eeprom(struct comedi_device * dev, uint8_t address)
 
 	comedi_udelay(eeprom_comedi_udelay);
 	priv(dev)->plx_control_bits &= ~CTL_EE_CLK & ~CTL_EE_CS;
-	// make sure we don't send anything to the i2c bus on 4020
+	/*  make sure we don't send anything to the i2c bus on 4020 */
 	priv(dev)->plx_control_bits |= CTL_USERO;
 	writel(priv(dev)->plx_control_bits, plx_control_addr);
-	// activate serial eeprom
+	/*  activate serial eeprom */
 	comedi_udelay(eeprom_comedi_udelay);
 	priv(dev)->plx_control_bits |= CTL_EE_CS;
 	writel(priv(dev)->plx_control_bits, plx_control_addr);
 
-	// write read command and desired memory address
+	/*  write read command and desired memory address */
 	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
-		// set bit to be written
+		/*  set bit to be written */
 		comedi_udelay(eeprom_comedi_udelay);
 		if (bitstream & bit)
 			priv(dev)->plx_control_bits |= CTL_EE_W;
 		else
 			priv(dev)->plx_control_bits &= ~CTL_EE_W;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		// clock in bit
+		/*  clock in bit */
 		comedi_udelay(eeprom_comedi_udelay);
 		priv(dev)->plx_control_bits |= CTL_EE_CLK;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
@@ -3818,10 +3818,10 @@ static uint16_t read_eeprom(struct comedi_device * dev, uint8_t address)
 		priv(dev)->plx_control_bits &= ~CTL_EE_CLK;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 	}
-	// read back value from eeprom memory location
+	/*  read back value from eeprom memory location */
 	value = 0;
 	for (bit = 1 << (value_length - 1); bit; bit >>= 1) {
-		// clock out bit
+		/*  clock out bit */
 		comedi_udelay(eeprom_comedi_udelay);
 		priv(dev)->plx_control_bits |= CTL_EE_CLK;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
@@ -3833,7 +3833,7 @@ static uint16_t read_eeprom(struct comedi_device * dev, uint8_t address)
 			value |= bit;
 	}
 
-	// deactivate eeprom serial input
+	/*  deactivate eeprom serial input */
 	comedi_udelay(eeprom_comedi_udelay);
 	priv(dev)->plx_control_bits &= ~CTL_EE_CS;
 	writel(priv(dev)->plx_control_bits, plx_control_addr);
@@ -3880,7 +3880,7 @@ static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		scan_divisor = get_divisor(cmd->scan_begin_arg, cmd->flags);
 		if (cmd->convert_src == TRIG_TIMER) {
-			// XXX check for integer overflows
+			/*  XXX check for integer overflows */
 			min_scan_divisor = convert_divisor * cmd->chanlist_len;
 			max_scan_divisor =
 				(convert_divisor * cmd->chanlist_len - 1) +
@@ -3926,7 +3926,7 @@ static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags)
 	return get_divisor(ns, flags) - 2;
 }
 
-// adjusts the size of hardware fifo (which determines block size for dma xfers)
+/* adjusts the size of hardware fifo (which determines block size for dma xfers) */
 static int set_ai_fifo_size(struct comedi_device * dev, unsigned int num_samples)
 {
 	unsigned int num_fifo_entries;
@@ -3947,7 +3947,7 @@ static int set_ai_fifo_size(struct comedi_device * dev, unsigned int num_samples
 	return num_samples;
 }
 
-// query length of fifo
+/* query length of fifo */
 static unsigned int ai_fifo_size(struct comedi_device * dev)
 {
 	return priv(dev)->ai_fifo_segment_length *
@@ -3968,7 +3968,7 @@ static int set_ai_fifo_segment_length(struct comedi_device * dev,
 	if (num_entries > fifo->max_segment_length)
 		num_entries = fifo->max_segment_length;
 
-	// 1 == 256 entries, 2 == 512 entries, etc
+	/*  1 == 256 entries, 2 == 512 entries, etc */
 	num_increments = (num_entries + increment_size / 2) / increment_size;
 
 	bits = (~(num_increments - 1)) & fifo->fifo_size_reg_mask;
@@ -4037,14 +4037,14 @@ static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
 	return 0;
 }
 
-// 4020 caldacs
+/* 4020 caldacs */
 static int caldac_i2c_write(struct comedi_device * dev, unsigned int caldac_channel,
 	unsigned int value)
 {
 	uint8_t serial_bytes[3];
 	uint8_t i2c_addr;
 	enum pointer_bits {
-		// manual has gain and offset bits switched
+		/*  manual has gain and offset bits switched */
 		OFFSET_0_2 = 0x1,
 		GAIN_0_2 = 0x2,
 		OFFSET_1_3 = 0x4,
@@ -4055,35 +4055,35 @@ static int caldac_i2c_write(struct comedi_device * dev, unsigned int caldac_chan
 	};
 
 	switch (caldac_channel) {
-	case 0:		// chan 0 offset
+	case 0:		/*  chan 0 offset */
 		i2c_addr = CALDAC0_I2C_ADDR;
 		serial_bytes[0] = OFFSET_0_2;
 		break;
-	case 1:		// chan 1 offset
+	case 1:		/*  chan 1 offset */
 		i2c_addr = CALDAC0_I2C_ADDR;
 		serial_bytes[0] = OFFSET_1_3;
 		break;
-	case 2:		// chan 2 offset
+	case 2:		/*  chan 2 offset */
 		i2c_addr = CALDAC1_I2C_ADDR;
 		serial_bytes[0] = OFFSET_0_2;
 		break;
-	case 3:		// chan 3 offset
+	case 3:		/*  chan 3 offset */
 		i2c_addr = CALDAC1_I2C_ADDR;
 		serial_bytes[0] = OFFSET_1_3;
 		break;
-	case 4:		// chan 0 gain
+	case 4:		/*  chan 0 gain */
 		i2c_addr = CALDAC0_I2C_ADDR;
 		serial_bytes[0] = GAIN_0_2;
 		break;
-	case 5:		// chan 1 gain
+	case 5:		/*  chan 1 gain */
 		i2c_addr = CALDAC0_I2C_ADDR;
 		serial_bytes[0] = GAIN_1_3;
 		break;
-	case 6:		// chan 2 gain
+	case 6:		/*  chan 2 gain */
 		i2c_addr = CALDAC1_I2C_ADDR;
 		serial_bytes[0] = GAIN_0_2;
 		break;
-	case 7:		// chan 3 gain
+	case 7:		/*  chan 3 gain */
 		i2c_addr = CALDAC1_I2C_ADDR;
 		serial_bytes[0] = GAIN_1_3;
 		break;
@@ -4098,22 +4098,22 @@ static int caldac_i2c_write(struct comedi_device * dev, unsigned int caldac_chan
 	return 0;
 }
 
-// Their i2c requires a huge delay on setting clock or data high for some reason
+/* Their i2c requires a huge delay on setting clock or data high for some reason */
 static const int i2c_high_comedi_udelay = 1000;
 static const int i2c_low_comedi_udelay = 10;
 
-// set i2c data line high or low
+/* set i2c data line high or low */
 static void i2c_set_sda(struct comedi_device * dev, int state)
 {
 	static const int data_bit = CTL_EE_W;
 	void *plx_control_addr = priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
 
 	if (state) {
-		// set data line high
+		/*  set data line high */
 		priv(dev)->plx_control_bits &= ~data_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 		comedi_udelay(i2c_high_comedi_udelay);
-	} else			// set data line low
+	} else			/*  set data line low */
 	{
 		priv(dev)->plx_control_bits |= data_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
@@ -4121,18 +4121,18 @@ static void i2c_set_sda(struct comedi_device * dev, int state)
 	}
 }
 
-// set i2c clock line high or low
+/* set i2c clock line high or low */
 static void i2c_set_scl(struct comedi_device * dev, int state)
 {
 	static const int clock_bit = CTL_USERO;
 	void *plx_control_addr = priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
 
 	if (state) {
-		// set clock line high
+		/*  set clock line high */
 		priv(dev)->plx_control_bits &= ~clock_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 		comedi_udelay(i2c_high_comedi_udelay);
-	} else			// set clock line low
+	} else			/*  set clock line low */
 	{
 		priv(dev)->plx_control_bits |= clock_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
@@ -4157,17 +4157,17 @@ static void i2c_write_byte(struct comedi_device * dev, uint8_t byte)
 	}
 }
 
-// we can't really read the lines, so fake it
+/* we can't really read the lines, so fake it */
 static int i2c_read_ack(struct comedi_device * dev)
 {
 	i2c_set_scl(dev, 0);
 	i2c_set_sda(dev, 1);
 	i2c_set_scl(dev, 1);
 
-	return 0;		// return fake acknowledge bit
+	return 0;		/*  return fake acknowledge bit */
 }
 
-// send start bit
+/* send start bit */
 static void i2c_start(struct comedi_device * dev)
 {
 	i2c_set_scl(dev, 1);
@@ -4175,7 +4175,7 @@ static void i2c_start(struct comedi_device * dev)
 	i2c_set_sda(dev, 0);
 }
 
-// send stop bit
+/* send stop bit */
 static void i2c_stop(struct comedi_device * dev)
 {
 	i2c_set_scl(dev, 0);
@@ -4191,25 +4191,25 @@ static void i2c_write(struct comedi_device * dev, unsigned int address,
 	uint8_t bitstream;
 	static const int read_bit = 0x1;
 
-//XXX need mutex to prevent simultaneous attempts to access eeprom and i2c bus
+/* XXX need mutex to prevent simultaneous attempts to access eeprom and i2c bus */
 
-	// make sure we dont send anything to eeprom
+	/*  make sure we dont send anything to eeprom */
 	priv(dev)->plx_control_bits &= ~CTL_EE_CS;
 
 	i2c_stop(dev);
 	i2c_start(dev);
 
-	// send address and write bit
+	/*  send address and write bit */
 	bitstream = (address << 1) & ~read_bit;
 	i2c_write_byte(dev, bitstream);
 
-	// get acknowledge
+	/*  get acknowledge */
 	if (i2c_read_ack(dev) != 0) {
 		comedi_error(dev, "i2c write failed: no acknowledge");
 		i2c_stop(dev);
 		return;
 	}
-	// write data bytes
+	/*  write data bytes */
 	for (i = 0; i < length; i++) {
 		i2c_write_byte(dev, data[i]);
 		if (i2c_read_ack(dev) != 0) {

commit 450032a318ebfc95121fc548442217592803f4a7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Mar 19 17:57:22 2009 -0400

    Staging: comedi: Remove pcidas64_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 4c2e97302a35..1a580bd2247a 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1065,7 +1065,8 @@ struct ext_clock_info {
 };
 
 /* this structure is for data unique to this hardware driver. */
-typedef struct {
+struct pcidas64_private {
+
 	struct pci_dev *hw_dev;	// pointer to board's pci_dev struct
 	// base addresses (physical)
 	resource_size_t plx9080_phys_iobase;
@@ -1109,12 +1110,13 @@ typedef struct {
 	unsigned int ai_fifo_segment_length;
 	struct ext_clock_info ext_clock;
 	short ao_bounce_buffer[DAC_FIFO_SIZE];
-} pcidas64_private;
+};
+
 
 /* inline function that makes it easier to
  * access the private structure.
  */
-static inline pcidas64_private *priv(struct comedi_device * dev)
+static inline struct pcidas64_private *priv(struct comedi_device * dev)
 {
 	return dev->private;
 }
@@ -1685,7 +1687,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 /*
  * Allocate the private structure area.
  */
-	if (alloc_private(dev, sizeof(pcidas64_private)) < 0)
+	if (alloc_private(dev, sizeof(struct pcidas64_private)) < 0)
 		return -ENOMEM;
 
 /*

commit 222ab1bc78dd8a48576e904da37fd6f71cb41a7e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Mar 19 17:57:11 2009 -0400

    Staging: comedi: Remove pcidas64_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 0e9eeefc93bd..4c2e97302a35 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -541,7 +541,7 @@ struct hw_fifo_info {
 	uint16_t fifo_size_reg_mask;
 };
 
-typedef struct pcidas64_board_struct {
+struct pcidas64_board {
 	const char *name;
 	int device_id;		// pci device id
 	int ai_se_chans;	// number of ai inputs in single-ended mode
@@ -556,7 +556,7 @@ typedef struct pcidas64_board_struct {
 	const struct hw_fifo_info *const ai_fifo;
 	enum register_layout layout;	// different board families have slightly different registers
 	unsigned has_8255:1;
-} pcidas64_board;
+};
 
 static const struct hw_fifo_info ai_fifo_4020 = {
       num_segments:2,
@@ -584,7 +584,7 @@ static const struct hw_fifo_info ai_fifo_60xx = {
 #define MAX_AI_DMA_RING_COUNT (0x80000 / DMA_BUFFER_SIZE)
 #define MIN_AI_DMA_RING_COUNT (0x10000 / DMA_BUFFER_SIZE)
 #define AO_DMA_RING_COUNT (0x10000 / DMA_BUFFER_SIZE)
-static inline unsigned int ai_dma_ring_count(pcidas64_board * board)
+static inline unsigned int ai_dma_ring_count(struct pcidas64_board * board)
 {
 	if (board->layout == LAYOUT_4020)
 		return MAX_AI_DMA_RING_COUNT;
@@ -594,7 +594,7 @@ static inline unsigned int ai_dma_ring_count(pcidas64_board * board)
 
 static const int bytes_in_sample = 2;
 
-static const pcidas64_board pcidas64_boards[] = {
+static const struct pcidas64_board pcidas64_boards[] = {
 	{
 	      name:	"pci-das6402/16",
 	      device_id:0x1d,
@@ -1016,7 +1016,7 @@ static const pcidas64_board pcidas64_boards[] = {
 // Number of boards in cb_pcidas_boards
 static inline unsigned int num_boards(void)
 {
-	return sizeof(pcidas64_boards) / sizeof(pcidas64_board);
+	return sizeof(pcidas64_boards) / sizeof(struct pcidas64_board);
 }
 
 static DEFINE_PCI_DEVICE_TABLE(pcidas64_pci_table) = {
@@ -1044,9 +1044,9 @@ static DEFINE_PCI_DEVICE_TABLE(pcidas64_pci_table) = {
 
 MODULE_DEVICE_TABLE(pci, pcidas64_pci_table);
 
-static inline pcidas64_board *board(const struct comedi_device * dev)
+static inline struct pcidas64_board *board(const struct comedi_device * dev)
 {
-	return (pcidas64_board *) dev->board_ptr;
+	return (struct pcidas64_board *) dev->board_ptr;
 }
 
 static inline unsigned short se_diff_bit_6xxx(struct comedi_device * dev,
@@ -1267,7 +1267,7 @@ static void set_dac_range_bits(struct comedi_device * dev, volatile uint16_t * b
 	*bits |= code << (2 * channel);
 };
 
-static inline int ao_cmd_is_supported(const pcidas64_board * board)
+static inline int ao_cmd_is_supported(const struct pcidas64_board * board)
 {
 	return board->ao_nchan && board->layout != LAYOUT_4020;
 }

commit 675935dd95cf24e81982e57021d03d5bf8bdac60
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Mar 19 17:57:06 2009 -0400

    Staging: comedi: Remove hw_fifo_info_t typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 707e3ccc9d72..0e9eeefc93bd 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -534,12 +534,12 @@ enum register_layout {
 	LAYOUT_4020,
 };
 
-typedef struct hw_fifo_info_struct {
+struct hw_fifo_info {
 	unsigned int num_segments;
 	unsigned int max_segment_length;
 	unsigned int sample_packing_ratio;
 	uint16_t fifo_size_reg_mask;
-} hw_fifo_info_t;
+};
 
 typedef struct pcidas64_board_struct {
 	const char *name;
@@ -553,26 +553,26 @@ typedef struct pcidas64_board_struct {
 	int ao_scan_speed;	// analog output speed (for a scan, not conversion)
 	const struct comedi_lrange *ao_range_table;
 	const int *ao_range_code;
-	const hw_fifo_info_t *const ai_fifo;
+	const struct hw_fifo_info *const ai_fifo;
 	enum register_layout layout;	// different board families have slightly different registers
 	unsigned has_8255:1;
 } pcidas64_board;
 
-static const hw_fifo_info_t ai_fifo_4020 = {
+static const struct hw_fifo_info ai_fifo_4020 = {
       num_segments:2,
       max_segment_length:0x8000,
       sample_packing_ratio:2,
       fifo_size_reg_mask:0x7f,
 };
 
-static const hw_fifo_info_t ai_fifo_64xx = {
+static const struct hw_fifo_info ai_fifo_64xx = {
       num_segments:4,
       max_segment_length:0x800,
       sample_packing_ratio:1,
       fifo_size_reg_mask:0x3f,
 };
 
-static const hw_fifo_info_t ai_fifo_60xx = {
+static const struct hw_fifo_info ai_fifo_60xx = {
       num_segments:4,
       max_segment_length:0x800,
       sample_packing_ratio:1,
@@ -2041,7 +2041,7 @@ static int ai_config_calibration_source(struct comedi_device * dev, unsigned int
 static int ai_config_block_size(struct comedi_device * dev, unsigned int * data)
 {
 	int fifo_size;
-	const hw_fifo_info_t *const fifo = board(dev)->ai_fifo;
+	const struct hw_fifo_info *const fifo = board(dev)->ai_fifo;
 	unsigned int block_size, requested_block_size;
 	int retval;
 
@@ -3929,7 +3929,7 @@ static int set_ai_fifo_size(struct comedi_device * dev, unsigned int num_samples
 {
 	unsigned int num_fifo_entries;
 	int retval;
-	const hw_fifo_info_t *const fifo = board(dev)->ai_fifo;
+	const struct hw_fifo_info *const fifo = board(dev)->ai_fifo;
 
 	num_fifo_entries = num_samples / fifo->sample_packing_ratio;
 
@@ -3957,7 +3957,7 @@ static int set_ai_fifo_segment_length(struct comedi_device * dev,
 	unsigned int num_entries)
 {
 	static const int increment_size = 0x100;
-	const hw_fifo_info_t *const fifo = board(dev)->ai_fifo;
+	const struct hw_fifo_info *const fifo = board(dev)->ai_fifo;
 	unsigned int num_increments;
 	uint16_t bits;
 

commit 1f6325d629ce03501e8927480495685828561f26
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:31 2009 -0400

    Staging: comedi: Remove comedi_krange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index b6fc5c119701..707e3ccc9d72 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1203,7 +1203,7 @@ COMEDI_PCI_INITCLEANUP(driver_cb_pcidas, pcidas64_pci_table);
 static unsigned int ai_range_bits_6xxx(const struct comedi_device * dev,
 	unsigned int range_index)
 {
-	const comedi_krange *range =
+	const struct comedi_krange *range =
 		&board(dev)->ai_range_table->range[range_index];
 	unsigned int bits = 0;
 

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 40d97134e384..b6fc5c119701 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1125,7 +1125,7 @@ static inline pcidas64_private *priv(struct comedi_device * dev)
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int attach(struct comedi_device * dev, comedi_devconfig * it);
+static int attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int detach(struct comedi_device * dev);
 static struct comedi_driver driver_cb_pcidas = {
       driver_name:"cb_pcidas64",
@@ -1673,7 +1673,7 @@ static inline void warn_external_queue(struct comedi_device * dev)
  * Attach is called by the Comedi core to configure the driver
  * for a particular board.
  */
-static int attach(struct comedi_device * dev, comedi_devconfig * it)
+static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct pci_dev *pcidev;
 	int index;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index dd7a35cf7d5d..40d97134e384 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1135,13 +1135,13 @@ static struct comedi_driver driver_cb_pcidas = {
 };
 
 static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_cmd * cmd);
@@ -1156,25 +1156,25 @@ static int ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int dio_callback(int dir, int port, int data, unsigned long arg);
 static int dio_callback_4020(int dir, int port, int data, unsigned long arg);
 static int di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int dio_60xx_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int dio_60xx_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int calib_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int calib_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ad8402_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static void ad8402_write(struct comedi_device * dev, unsigned int channel,
 	unsigned int value);
 static int ad8402_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static void check_adc_timing(struct comedi_device * dev, struct comedi_cmd * cmd);
 static unsigned int get_divisor(unsigned int ns, unsigned int flags);
 static void i2c_write(struct comedi_device * dev, unsigned int address,
@@ -1882,7 +1882,7 @@ static int detach(struct comedi_device * dev)
 }
 
 static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int bits = 0, n, i;
 	unsigned int channel, range, aref;
@@ -2107,7 +2107,7 @@ static int ai_config_master_clock(struct comedi_device * dev, unsigned int * dat
 }
 
 static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int id = data[0];
 
@@ -3195,7 +3195,7 @@ static int ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 }
 
 static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	int range = CR_RANGE(insn->chanspec);
@@ -3225,7 +3225,7 @@ static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 }
 
 static int ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = priv(dev)->ao_value[CR_CHAN(insn->chanspec)];
 
@@ -3606,7 +3606,7 @@ static int dio_callback_4020(int dir, int port, int data, unsigned long iobase)
 }
 
 static int di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int bits;
 
@@ -3619,7 +3619,7 @@ static int di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
 }
 
 static int do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] &= 0xf;
 	// zero bits we are going to change
@@ -3635,7 +3635,7 @@ static int do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 }
 
 static int dio_60xx_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int mask;
 
@@ -3662,7 +3662,7 @@ static int dio_60xx_config_insn(struct comedi_device * dev, struct comedi_subdev
 }
 
 static int dio_60xx_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -3695,7 +3695,7 @@ static void caldac_write(struct comedi_device * dev, unsigned int channel,
 }
 
 static int calib_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -3710,7 +3710,7 @@ static int calib_write_insn(struct comedi_device * dev, struct comedi_subdevice
 }
 
 static int calib_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -3751,7 +3751,7 @@ static void ad8402_write(struct comedi_device * dev, unsigned int channel,
 
 /* for pci-das6402/16, channel 0 is analog input gain and channel 1 is offset */
 static int ad8402_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -3768,7 +3768,7 @@ static int ad8402_write_insn(struct comedi_device * dev, struct comedi_subdevice
 }
 
 static int ad8402_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -3840,7 +3840,7 @@ static uint16_t read_eeprom(struct comedi_device * dev, uint8_t address)
 }
 
 static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = read_eeprom(dev, CR_CHAN(insn->chanspec));
 

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index ce1638d72d6b..dd7a35cf7d5d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1144,12 +1144,12 @@ static int ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice
 	comedi_insn * insn, unsigned int * data);
 static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * subdev,
 	unsigned int trig_num);
 static int ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG);
 static int ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
@@ -1175,7 +1175,7 @@ static int ad8402_write_insn(struct comedi_device * dev, struct comedi_subdevice
 	comedi_insn * insn, unsigned int * data);
 static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static void check_adc_timing(struct comedi_device * dev, comedi_cmd * cmd);
+static void check_adc_timing(struct comedi_device * dev, struct comedi_cmd * cmd);
 static unsigned int get_divisor(unsigned int ns, unsigned int flags);
 static void i2c_write(struct comedi_device * dev, unsigned int address,
 	const uint8_t * data, unsigned int length);
@@ -1194,9 +1194,9 @@ static int set_ai_fifo_segment_length(struct comedi_device * dev,
 	unsigned int num_entries);
 static void disable_ai_pacing(struct comedi_device * dev);
 static void disable_ai_interrupts(struct comedi_device * dev);
-static void enable_ai_interrupts(struct comedi_device * dev, const comedi_cmd * cmd);
+static void enable_ai_interrupts(struct comedi_device * dev, const struct comedi_cmd * cmd);
 static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags);
-static void load_ao_dma(struct comedi_device * dev, const comedi_cmd * cmd);
+static void load_ao_dma(struct comedi_device * dev, const struct comedi_cmd * cmd);
 
 COMEDI_PCI_INITCLEANUP(driver_cb_pcidas, pcidas64_pci_table);
 
@@ -2129,7 +2129,7 @@ static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -2313,7 +2313,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	return 0;
 }
 
-static int use_hw_sample_counter(comedi_cmd * cmd)
+static int use_hw_sample_counter(struct comedi_cmd * cmd)
 {
 // disable for now until I work out a race
 	return 0;
@@ -2324,7 +2324,7 @@ static int use_hw_sample_counter(comedi_cmd * cmd)
 		return 0;
 }
 
-static void setup_sample_counters(struct comedi_device * dev, comedi_cmd * cmd)
+static void setup_sample_counters(struct comedi_device * dev, struct comedi_cmd * cmd)
 {
 	if (cmd->stop_src == TRIG_COUNT) {
 		// set software count
@@ -2387,7 +2387,7 @@ static void disable_ai_interrupts(struct comedi_device * dev)
 	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
 }
 
-static void enable_ai_interrupts(struct comedi_device * dev, const comedi_cmd * cmd)
+static void enable_ai_interrupts(struct comedi_device * dev, const struct comedi_cmd * cmd)
 {
 	uint32_t bits;
 	unsigned long flags;
@@ -2409,13 +2409,13 @@ static void enable_ai_interrupts(struct comedi_device * dev, const comedi_cmd *
 }
 
 static uint32_t ai_convert_counter_6xxx(const struct comedi_device * dev,
-	const comedi_cmd * cmd)
+	const struct comedi_cmd * cmd)
 {
 	// supposed to load counter with desired divisor minus 3
 	return cmd->convert_arg / TIMER_BASE - 3;
 }
 
-static uint32_t ai_scan_counter_6xxx(struct comedi_device * dev, comedi_cmd * cmd)
+static uint32_t ai_scan_counter_6xxx(struct comedi_device * dev, struct comedi_cmd * cmd)
 {
 	uint32_t count;
 	// figure out how long we need to delay at end of scan
@@ -2435,7 +2435,7 @@ static uint32_t ai_scan_counter_6xxx(struct comedi_device * dev, comedi_cmd * cm
 	return count - 3;
 }
 
-static uint32_t ai_convert_counter_4020(struct comedi_device * dev, comedi_cmd * cmd)
+static uint32_t ai_convert_counter_4020(struct comedi_device * dev, struct comedi_cmd * cmd)
 {
 	unsigned int divisor;
 
@@ -2457,7 +2457,7 @@ static uint32_t ai_convert_counter_4020(struct comedi_device * dev, comedi_cmd *
 }
 
 static void select_master_clock_4020(struct comedi_device * dev,
-	const comedi_cmd * cmd)
+	const struct comedi_cmd * cmd)
 {
 	// select internal/external master clock
 	priv(dev)->hw_config_bits &= ~MASTER_CLOCK_4020_MASK;
@@ -2475,7 +2475,7 @@ static void select_master_clock_4020(struct comedi_device * dev,
 		priv(dev)->main_iobase + HW_CONFIG_REG);
 }
 
-static void select_master_clock(struct comedi_device * dev, const comedi_cmd * cmd)
+static void select_master_clock(struct comedi_device * dev, const struct comedi_cmd * cmd)
 {
 	switch (board(dev)->layout) {
 	case LAYOUT_4020:
@@ -2503,7 +2503,7 @@ static inline void dma_start_sync(struct comedi_device * dev, unsigned int chann
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
-static void set_ai_pacing(struct comedi_device * dev, comedi_cmd * cmd)
+static void set_ai_pacing(struct comedi_device * dev, struct comedi_cmd * cmd)
 {
 	uint32_t convert_counter = 0, scan_counter = 0;
 
@@ -2534,7 +2534,7 @@ static void set_ai_pacing(struct comedi_device * dev, comedi_cmd * cmd)
 	DEBUG_PRINT("scan counter 0x%x\n", scan_counter);
 }
 
-static int use_internal_queue_6xxx(const comedi_cmd * cmd)
+static int use_internal_queue_6xxx(const struct comedi_cmd * cmd)
 {
 	int i;
 	for (i = 0; i + 1 < cmd->chanlist_len; i++) {
@@ -2550,7 +2550,7 @@ static int use_internal_queue_6xxx(const comedi_cmd * cmd)
 	return 1;
 }
 
-static int setup_channel_queue(struct comedi_device * dev, const comedi_cmd * cmd)
+static int setup_channel_queue(struct comedi_device * dev, const struct comedi_cmd * cmd)
 {
 	unsigned short bits;
 	int i;
@@ -2682,7 +2682,7 @@ static inline void load_first_dma_descriptor(struct comedi_device * dev,
 static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	uint32_t bits;
 	unsigned int i;
 	unsigned long flags;
@@ -2801,7 +2801,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device * dev)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int i;
 	uint16_t prepost_bits;
 	int read_segment, read_index, write_segment, write_index;
@@ -2868,7 +2868,7 @@ static void pio_drain_ai_fifo_32(struct comedi_device * dev)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int i;
 	unsigned int max_transfer = 100000;
 	uint32_t fifo_data;
@@ -2957,7 +2957,7 @@ void handle_ai_interrupt(struct comedi_device * dev, unsigned short status,
 {
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	uint8_t dma1_status;
 	unsigned long flags;
 
@@ -3036,7 +3036,7 @@ static int last_ao_dma_load_completed(struct comedi_device * dev)
 	return 1;
 }
 
-static int ao_stopped_by_error(struct comedi_device * dev, const comedi_cmd * cmd)
+static int ao_stopped_by_error(struct comedi_device * dev, const struct comedi_cmd * cmd)
 {
 	if (cmd->stop_src == TRIG_NONE)
 		return 1;
@@ -3079,7 +3079,7 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned short statu
 {
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_async *async;
-	comedi_cmd *cmd;
+	struct comedi_cmd *cmd;
 	uint8_t dma0_status;
 	unsigned long flags;
 
@@ -3232,7 +3232,7 @@ static int ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice
 	return 1;
 }
 
-static void set_dac_control0_reg(struct comedi_device * dev, const comedi_cmd * cmd)
+static void set_dac_control0_reg(struct comedi_device * dev, const struct comedi_cmd * cmd)
 {
 	unsigned int bits = DAC_ENABLE_BIT | WAVEFORM_GATE_LEVEL_BIT |
 		WAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;
@@ -3252,7 +3252,7 @@ static void set_dac_control0_reg(struct comedi_device * dev, const comedi_cmd *
 	writew(bits, priv(dev)->main_iobase + DAC_CONTROL0_REG);
 }
 
-static void set_dac_control1_reg(struct comedi_device * dev, const comedi_cmd * cmd)
+static void set_dac_control1_reg(struct comedi_device * dev, const struct comedi_cmd * cmd)
 {
 	int i;
 
@@ -3269,7 +3269,7 @@ static void set_dac_control1_reg(struct comedi_device * dev, const comedi_cmd *
 		priv(dev)->main_iobase + DAC_CONTROL1_REG);
 }
 
-static void set_dac_select_reg(struct comedi_device * dev, const comedi_cmd * cmd)
+static void set_dac_select_reg(struct comedi_device * dev, const struct comedi_cmd * cmd)
 {
 	uint16_t bits;
 	unsigned int first_channel, last_channel;
@@ -3284,7 +3284,7 @@ static void set_dac_select_reg(struct comedi_device * dev, const comedi_cmd * cm
 	writew(bits, priv(dev)->main_iobase + DAC_SELECT_REG);
 }
 
-static void set_dac_interval_regs(struct comedi_device * dev, const comedi_cmd * cmd)
+static void set_dac_interval_regs(struct comedi_device * dev, const struct comedi_cmd * cmd)
 {
 	unsigned int divisor;
 
@@ -3303,7 +3303,7 @@ static void set_dac_interval_regs(struct comedi_device * dev, const comedi_cmd *
 }
 
 static unsigned int load_ao_dma_buffer(struct comedi_device * dev,
-	const comedi_cmd * cmd)
+	const struct comedi_cmd * cmd)
 {
 	unsigned int num_bytes, buffer_index, prev_buffer_index;
 	unsigned int next_bits;
@@ -3346,7 +3346,7 @@ static unsigned int load_ao_dma_buffer(struct comedi_device * dev,
 	return num_bytes;
 }
 
-static void load_ao_dma(struct comedi_device * dev, const comedi_cmd * cmd)
+static void load_ao_dma(struct comedi_device * dev, const struct comedi_cmd * cmd)
 {
 	unsigned int num_bytes;
 	unsigned int next_transfer_addr;
@@ -3368,7 +3368,7 @@ static void load_ao_dma(struct comedi_device * dev, const comedi_cmd * cmd)
 	} while (num_bytes >= DMA_BUFFER_SIZE);
 }
 
-static int prep_ao_dma(struct comedi_device * dev, const comedi_cmd * cmd)
+static int prep_ao_dma(struct comedi_device * dev, const struct comedi_cmd * cmd)
 {
 	unsigned int num_bytes;
 	int i;
@@ -3415,7 +3415,7 @@ static inline int external_ai_queue_in_use(struct comedi_device * dev)
 
 static int ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
 	if (external_ai_queue_in_use(dev)) {
 		warn_external_queue(dev);
@@ -3441,7 +3441,7 @@ static int ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 static int ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trig_num)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
 
 	if (trig_num != 0)
@@ -3462,7 +3462,7 @@ static int ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 }
 
 static int ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -3851,7 +3851,7 @@ static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice
  * sets cmd members appropriately.
  * adc paces conversions from master clock by dividing by (x + 3) where x is 24 bit number
  */
-static void check_adc_timing(struct comedi_device * dev, comedi_cmd * cmd)
+static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
 	unsigned int convert_divisor = 0, scan_divisor;
 	static const int min_convert_divisor = 3;

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index ea55c2bf3e78..ce1638d72d6b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -400,7 +400,7 @@ static inline uint8_t attenuate_bit(unsigned int channel)
 };
 
 // analog input ranges for 64xx boards
-static const comedi_lrange ai_ranges_64xx = {
+static const struct comedi_lrange ai_ranges_64xx = {
 	8,
 	{
 			BIP_RANGE(10),
@@ -415,7 +415,7 @@ static const comedi_lrange ai_ranges_64xx = {
 };
 
 /* analog input ranges for 60xx boards */
-static const comedi_lrange ai_ranges_60xx = {
+static const struct comedi_lrange ai_ranges_60xx = {
 	4,
 	{
 			BIP_RANGE(10),
@@ -426,7 +426,7 @@ static const comedi_lrange ai_ranges_60xx = {
 };
 
 /* analog input ranges for 6030, etc boards */
-static const comedi_lrange ai_ranges_6030 = {
+static const struct comedi_lrange ai_ranges_6030 = {
 	14,
 	{
 			BIP_RANGE(10),
@@ -447,7 +447,7 @@ static const comedi_lrange ai_ranges_6030 = {
 };
 
 /* analog input ranges for 6052, etc boards */
-static const comedi_lrange ai_ranges_6052 = {
+static const struct comedi_lrange ai_ranges_6052 = {
 	15,
 	{
 			BIP_RANGE(10),
@@ -469,7 +469,7 @@ static const comedi_lrange ai_ranges_6052 = {
 };
 
 // analog input ranges for 4020 board
-static const comedi_lrange ai_ranges_4020 = {
+static const struct comedi_lrange ai_ranges_4020 = {
 	2,
 	{
 			BIP_RANGE(5),
@@ -478,7 +478,7 @@ static const comedi_lrange ai_ranges_4020 = {
 };
 
 // analog output ranges
-static const comedi_lrange ao_ranges_64xx = {
+static const struct comedi_lrange ao_ranges_64xx = {
 	4,
 	{
 			BIP_RANGE(5),
@@ -494,7 +494,7 @@ static const int ao_range_code_64xx[] = {
 	0x3,
 };
 
-static const comedi_lrange ao_ranges_60xx = {
+static const struct comedi_lrange ao_ranges_60xx = {
 	1,
 	{
 			BIP_RANGE(10),
@@ -504,7 +504,7 @@ static const int ao_range_code_60xx[] = {
 	0x0,
 };
 
-static const comedi_lrange ao_ranges_6030 = {
+static const struct comedi_lrange ao_ranges_6030 = {
 	2,
 	{
 			BIP_RANGE(10),
@@ -516,7 +516,7 @@ static const int ao_range_code_6030[] = {
 	0x2,
 };
 
-static const comedi_lrange ao_ranges_4020 = {
+static const struct comedi_lrange ao_ranges_4020 = {
 	2,
 	{
 			BIP_RANGE(5),
@@ -547,11 +547,11 @@ typedef struct pcidas64_board_struct {
 	int ai_se_chans;	// number of ai inputs in single-ended mode
 	int ai_bits;		// analog input resolution
 	int ai_speed;		// fastest conversion period in ns
-	const comedi_lrange *ai_range_table;
+	const struct comedi_lrange *ai_range_table;
 	int ao_nchan;		// number of analog out channels
 	int ao_bits;		// analog output resolution
 	int ao_scan_speed;	// analog output speed (for a scan, not conversion)
-	const comedi_lrange *ao_range_table;
+	const struct comedi_lrange *ao_range_table;
 	const int *ao_range_code;
 	const hw_fifo_info_t *const ai_fifo;
 	enum register_layout layout;	// different board families have slightly different registers

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 345eeb6241bf..ea55c2bf3e78 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1127,7 +1127,7 @@ static inline pcidas64_private *priv(struct comedi_device * dev)
  */
 static int attach(struct comedi_device * dev, comedi_devconfig * it);
 static int detach(struct comedi_device * dev);
-static comedi_driver driver_cb_pcidas = {
+static struct comedi_driver driver_cb_pcidas = {
       driver_name:"cb_pcidas64",
       module:THIS_MODULE,
       attach:attach,

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index f1e121110332..345eeb6241bf 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -2681,7 +2681,7 @@ static inline void load_first_dma_descriptor(struct comedi_device * dev,
 
 static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	uint32_t bits;
 	unsigned int i;
@@ -2800,7 +2800,7 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 static void pio_drain_ai_fifo_16(struct comedi_device * dev)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned int i;
 	uint16_t prepost_bits;
@@ -2867,7 +2867,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device * dev)
 static void pio_drain_ai_fifo_32(struct comedi_device * dev)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned int i;
 	unsigned int max_transfer = 100000;
@@ -2908,7 +2908,7 @@ static void pio_drain_ai_fifo(struct comedi_device * dev)
 
 static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 {
-	comedi_async *async = dev->read_subdev->async;
+	struct comedi_async *async = dev->read_subdev->async;
 	uint32_t next_transfer_addr;
 	int j;
 	int num_samples = 0;
@@ -2956,7 +2956,7 @@ void handle_ai_interrupt(struct comedi_device * dev, unsigned short status,
 	unsigned int plx_status)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	uint8_t dma1_status;
 	unsigned long flags;
@@ -3078,7 +3078,7 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned short statu
 	unsigned int plx_status)
 {
 	struct comedi_subdevice *s = dev->write_subdev;
-	comedi_async *async;
+	struct comedi_async *async;
 	comedi_cmd *cmd;
 	uint8_t dma0_status;
 	unsigned long flags;

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 4095381f201e..f1e121110332 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1134,46 +1134,46 @@ static comedi_driver driver_cb_pcidas = {
       detach:detach,
 };
 
-static int ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ai_config_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ao_readback_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int ao_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int ao_inttrig(struct comedi_device * dev, comedi_subdevice * subdev,
+static int ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * subdev,
 	unsigned int trig_num);
-static int ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
 static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG);
-static int ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
-static int ao_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static int ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int dio_callback(int dir, int port, int data, unsigned long arg);
 static int dio_callback_4020(int dir, int port, int data, unsigned long arg);
-static int di_rbits(struct comedi_device * dev, comedi_subdevice * s,
+static int di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int do_wbits(struct comedi_device * dev, comedi_subdevice * s,
+static int do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dio_60xx_config_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int dio_60xx_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dio_60xx_wbits(struct comedi_device * dev, comedi_subdevice * s,
+static int dio_60xx_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int calib_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int calib_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int calib_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int calib_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ad8402_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int ad8402_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static void ad8402_write(struct comedi_device * dev, unsigned int channel,
 	unsigned int value);
-static int ad8402_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int ad8402_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int eeprom_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static void check_adc_timing(struct comedi_device * dev, comedi_cmd * cmd);
 static unsigned int get_divisor(unsigned int ns, unsigned int flags);
@@ -1365,7 +1365,7 @@ static void init_plx9080(struct comedi_device * dev)
  */
 static int setup_subdevices(struct comedi_device * dev)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	void *dio_8255_iobase;
 	int i;
 
@@ -1881,7 +1881,7 @@ static int detach(struct comedi_device * dev)
 	return 0;
 }
 
-static int ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int bits = 0, n, i;
@@ -2106,7 +2106,7 @@ static int ai_config_master_clock(struct comedi_device * dev, unsigned int * dat
 	return -EINVAL;
 }
 
-static int ai_config_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int id = data[0];
@@ -2128,7 +2128,7 @@ static int ai_config_insn(struct comedi_device * dev, comedi_subdevice * s,
 	return -EINVAL;
 }
 
-static int ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -2679,7 +2679,7 @@ static inline void load_first_dma_descriptor(struct comedi_device * dev,
 	}
 }
 
-static int ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -2799,7 +2799,7 @@ static int ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 // read num_samples from 16 bit wide ai fifo
 static void pio_drain_ai_fifo_16(struct comedi_device * dev)
 {
-	comedi_subdevice *s = dev->read_subdev;
+	struct comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned int i;
@@ -2866,7 +2866,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device * dev)
  */
 static void pio_drain_ai_fifo_32(struct comedi_device * dev)
 {
-	comedi_subdevice *s = dev->read_subdev;
+	struct comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned int i;
@@ -2955,7 +2955,7 @@ static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 void handle_ai_interrupt(struct comedi_device * dev, unsigned short status,
 	unsigned int plx_status)
 {
-	comedi_subdevice *s = dev->read_subdev;
+	struct comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	uint8_t dma1_status;
@@ -3077,7 +3077,7 @@ static void restart_ao_dma(struct comedi_device * dev)
 static void handle_ao_interrupt(struct comedi_device * dev, unsigned short status,
 	unsigned int plx_status)
 {
-	comedi_subdevice *s = dev->write_subdev;
+	struct comedi_subdevice *s = dev->write_subdev;
 	comedi_async *async;
 	comedi_cmd *cmd;
 	uint8_t dma0_status;
@@ -3174,7 +3174,7 @@ void abort_dma(struct comedi_device * dev, unsigned int channel)
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
-static int ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -3194,7 +3194,7 @@ static int ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec);
@@ -3224,7 +3224,7 @@ static int ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ao_readback_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = priv(dev)->ao_value[CR_CHAN(insn->chanspec)];
@@ -3413,7 +3413,7 @@ static inline int external_ai_queue_in_use(struct comedi_device * dev)
 	return 1;
 }
 
-static int ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 
@@ -3438,7 +3438,7 @@ static int ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int ao_inttrig(struct comedi_device * dev, comedi_subdevice * s,
+static int ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trig_num)
 {
 	comedi_cmd *cmd = &s->async->cmd;
@@ -3461,7 +3461,7 @@ static int ao_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -3577,7 +3577,7 @@ static int ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int ao_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	writew(0x0, priv(dev)->main_iobase + DAC_CONTROL0_REG);
 	abort_dma(dev, 0);
@@ -3605,7 +3605,7 @@ static int dio_callback_4020(int dir, int port, int data, unsigned long iobase)
 	}
 }
 
-static int di_rbits(struct comedi_device * dev, comedi_subdevice * s,
+static int di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int bits;
@@ -3618,7 +3618,7 @@ static int di_rbits(struct comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int do_wbits(struct comedi_device * dev, comedi_subdevice * s,
+static int do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] &= 0xf;
@@ -3634,7 +3634,7 @@ static int do_wbits(struct comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int dio_60xx_config_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int dio_60xx_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int mask;
@@ -3661,7 +3661,7 @@ static int dio_60xx_config_insn(struct comedi_device * dev, comedi_subdevice * s
 	return 1;
 }
 
-static int dio_60xx_wbits(struct comedi_device * dev, comedi_subdevice * s,
+static int dio_60xx_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (data[0]) {
@@ -3694,7 +3694,7 @@ static void caldac_write(struct comedi_device * dev, unsigned int channel,
 	}
 }
 
-static int calib_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int calib_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
@@ -3709,7 +3709,7 @@ static int calib_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int calib_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int calib_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
@@ -3750,7 +3750,7 @@ static void ad8402_write(struct comedi_device * dev, unsigned int channel,
 }
 
 /* for pci-das6402/16, channel 0 is analog input gain and channel 1 is offset */
-static int ad8402_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int ad8402_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
@@ -3767,7 +3767,7 @@ static int ad8402_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ad8402_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int ad8402_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
@@ -3839,7 +3839,7 @@ static uint16_t read_eeprom(struct comedi_device * dev, uint8_t address)
 	return value;
 }
 
-static int eeprom_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = read_eeprom(dev, CR_CHAN(insn->chanspec));

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 4b1afce04d92..4095381f201e 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1044,12 +1044,12 @@ static DEFINE_PCI_DEVICE_TABLE(pcidas64_pci_table) = {
 
 MODULE_DEVICE_TABLE(pci, pcidas64_pci_table);
 
-static inline pcidas64_board *board(const comedi_device * dev)
+static inline pcidas64_board *board(const struct comedi_device * dev)
 {
 	return (pcidas64_board *) dev->board_ptr;
 }
 
-static inline unsigned short se_diff_bit_6xxx(comedi_device * dev,
+static inline unsigned short se_diff_bit_6xxx(struct comedi_device * dev,
 	int use_differential)
 {
 	if ((board(dev)->layout == LAYOUT_64XX && !use_differential) ||
@@ -1114,7 +1114,7 @@ typedef struct {
 /* inline function that makes it easier to
  * access the private structure.
  */
-static inline pcidas64_private *priv(comedi_device * dev)
+static inline pcidas64_private *priv(struct comedi_device * dev)
 {
 	return dev->private;
 }
@@ -1125,8 +1125,8 @@ static inline pcidas64_private *priv(comedi_device * dev)
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int attach(comedi_device * dev, comedi_devconfig * it);
-static int detach(comedi_device * dev);
+static int attach(struct comedi_device * dev, comedi_devconfig * it);
+static int detach(struct comedi_device * dev);
 static comedi_driver driver_cb_pcidas = {
       driver_name:"cb_pcidas64",
       module:THIS_MODULE,
@@ -1134,73 +1134,73 @@ static comedi_driver driver_cb_pcidas = {
       detach:detach,
 };
 
-static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
+static int ai_config_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
+static int ao_readback_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ai_cmd(comedi_device * dev, comedi_subdevice * s);
-static int ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int ao_cmd(comedi_device * dev, comedi_subdevice * s);
-static int ao_inttrig(comedi_device * dev, comedi_subdevice * subdev,
+static int ao_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int ao_inttrig(struct comedi_device * dev, comedi_subdevice * subdev,
 	unsigned int trig_num);
-static int ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
 static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG);
-static int ai_cancel(comedi_device * dev, comedi_subdevice * s);
-static int ao_cancel(comedi_device * dev, comedi_subdevice * s);
+static int ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int ao_cancel(struct comedi_device * dev, comedi_subdevice * s);
 static int dio_callback(int dir, int port, int data, unsigned long arg);
 static int dio_callback_4020(int dir, int port, int data, unsigned long arg);
-static int di_rbits(comedi_device * dev, comedi_subdevice * s,
+static int di_rbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int do_wbits(comedi_device * dev, comedi_subdevice * s,
+static int do_wbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dio_60xx_config_insn(comedi_device * dev, comedi_subdevice * s,
+static int dio_60xx_config_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dio_60xx_wbits(comedi_device * dev, comedi_subdevice * s,
+static int dio_60xx_wbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int calib_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int calib_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int calib_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int calib_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ad8402_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int ad8402_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static void ad8402_write(comedi_device * dev, unsigned int channel,
+static void ad8402_write(struct comedi_device * dev, unsigned int channel,
 	unsigned int value);
-static int ad8402_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int ad8402_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int eeprom_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static void check_adc_timing(comedi_device * dev, comedi_cmd * cmd);
+static void check_adc_timing(struct comedi_device * dev, comedi_cmd * cmd);
 static unsigned int get_divisor(unsigned int ns, unsigned int flags);
-static void i2c_write(comedi_device * dev, unsigned int address,
+static void i2c_write(struct comedi_device * dev, unsigned int address,
 	const uint8_t * data, unsigned int length);
-static void caldac_write(comedi_device * dev, unsigned int channel,
+static void caldac_write(struct comedi_device * dev, unsigned int channel,
 	unsigned int value);
-static int caldac_8800_write(comedi_device * dev, unsigned int address,
+static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
 	uint8_t value);
-//static int dac_1590_write(comedi_device *dev, unsigned int dac_a, unsigned int dac_b);
-static int caldac_i2c_write(comedi_device * dev, unsigned int caldac_channel,
+//static int dac_1590_write(struct comedi_device *dev, unsigned int dac_a, unsigned int dac_b);
+static int caldac_i2c_write(struct comedi_device * dev, unsigned int caldac_channel,
 	unsigned int value);
-static void abort_dma(comedi_device * dev, unsigned int channel);
-static void disable_plx_interrupts(comedi_device * dev);
-static int set_ai_fifo_size(comedi_device * dev, unsigned int num_samples);
-static unsigned int ai_fifo_size(comedi_device * dev);
-static int set_ai_fifo_segment_length(comedi_device * dev,
+static void abort_dma(struct comedi_device * dev, unsigned int channel);
+static void disable_plx_interrupts(struct comedi_device * dev);
+static int set_ai_fifo_size(struct comedi_device * dev, unsigned int num_samples);
+static unsigned int ai_fifo_size(struct comedi_device * dev);
+static int set_ai_fifo_segment_length(struct comedi_device * dev,
 	unsigned int num_entries);
-static void disable_ai_pacing(comedi_device * dev);
-static void disable_ai_interrupts(comedi_device * dev);
-static void enable_ai_interrupts(comedi_device * dev, const comedi_cmd * cmd);
+static void disable_ai_pacing(struct comedi_device * dev);
+static void disable_ai_interrupts(struct comedi_device * dev);
+static void enable_ai_interrupts(struct comedi_device * dev, const comedi_cmd * cmd);
 static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags);
-static void load_ao_dma(comedi_device * dev, const comedi_cmd * cmd);
+static void load_ao_dma(struct comedi_device * dev, const comedi_cmd * cmd);
 
 COMEDI_PCI_INITCLEANUP(driver_cb_pcidas, pcidas64_pci_table);
 
-static unsigned int ai_range_bits_6xxx(const comedi_device * dev,
+static unsigned int ai_range_bits_6xxx(const struct comedi_device * dev,
 	unsigned int range_index)
 {
 	const comedi_krange *range =
@@ -1244,7 +1244,7 @@ static unsigned int ai_range_bits_6xxx(const comedi_device * dev,
 	return bits;
 }
 
-static unsigned int hw_revision(const comedi_device * dev,
+static unsigned int hw_revision(const struct comedi_device * dev,
 	uint16_t hw_status_bits)
 {
 	if (board(dev)->layout == LAYOUT_4020)
@@ -1253,7 +1253,7 @@ static unsigned int hw_revision(const comedi_device * dev,
 	return (hw_status_bits >> 12) & 0xf;
 }
 
-static void set_dac_range_bits(comedi_device * dev, volatile uint16_t * bits,
+static void set_dac_range_bits(struct comedi_device * dev, volatile uint16_t * bits,
 	unsigned int channel, unsigned int range)
 {
 	unsigned int code = board(dev)->ao_range_code[range];
@@ -1273,7 +1273,7 @@ static inline int ao_cmd_is_supported(const pcidas64_board * board)
 }
 
 // initialize plx9080 chip
-static void init_plx9080(comedi_device * dev)
+static void init_plx9080(struct comedi_device * dev)
 {
 	uint32_t bits;
 	void *plx_iobase = priv(dev)->plx9080_iobase;
@@ -1363,7 +1363,7 @@ static void init_plx9080(comedi_device * dev)
 
 /* Allocate and initialize the subdevice structures.
  */
-static int setup_subdevices(comedi_device * dev)
+static int setup_subdevices(struct comedi_device * dev)
 {
 	comedi_subdevice *s;
 	void *dio_8255_iobase;
@@ -1526,14 +1526,14 @@ static int setup_subdevices(comedi_device * dev)
 	return 0;
 }
 
-static void disable_plx_interrupts(comedi_device * dev)
+static void disable_plx_interrupts(struct comedi_device * dev)
 {
 	priv(dev)->plx_intcsr_bits = 0;
 	writel(priv(dev)->plx_intcsr_bits,
 		priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
 }
 
-static void init_stc_registers(comedi_device * dev)
+static void init_stc_registers(struct comedi_device * dev)
 {
 	uint16_t bits;
 	unsigned long flags;
@@ -1575,7 +1575,7 @@ static void init_stc_registers(comedi_device * dev)
 	disable_ai_pacing(dev);
 };
 
-int alloc_and_init_dma_members(comedi_device * dev)
+int alloc_and_init_dma_members(struct comedi_device * dev)
 {
 	int i;
 
@@ -1661,7 +1661,7 @@ int alloc_and_init_dma_members(comedi_device * dev)
 	return 0;
 }
 
-static inline void warn_external_queue(comedi_device * dev)
+static inline void warn_external_queue(struct comedi_device * dev)
 {
 	comedi_error(dev,
 		"AO command and AI external channel queue cannot be used simultaneously.");
@@ -1673,7 +1673,7 @@ static inline void warn_external_queue(comedi_device * dev)
  * Attach is called by the Comedi core to configure the driver
  * for a particular board.
  */
-static int attach(comedi_device * dev, comedi_devconfig * it)
+static int attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	struct pci_dev *pcidev;
 	int index;
@@ -1821,7 +1821,7 @@ static int attach(comedi_device * dev, comedi_devconfig * it)
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int detach(comedi_device * dev)
+static int detach(struct comedi_device * dev)
 {
 	unsigned int i;
 
@@ -1881,7 +1881,7 @@ static int detach(comedi_device * dev)
 	return 0;
 }
 
-static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int bits = 0, n, i;
@@ -2018,7 +2018,7 @@ static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int ai_config_calibration_source(comedi_device * dev, unsigned int * data)
+static int ai_config_calibration_source(struct comedi_device * dev, unsigned int * data)
 {
 	unsigned int source = data[1];
 	int num_calibration_sources;
@@ -2038,7 +2038,7 @@ static int ai_config_calibration_source(comedi_device * dev, unsigned int * data
 	return 2;
 }
 
-static int ai_config_block_size(comedi_device * dev, unsigned int * data)
+static int ai_config_block_size(struct comedi_device * dev, unsigned int * data)
 {
 	int fifo_size;
 	const hw_fifo_info_t *const fifo = board(dev)->ai_fifo;
@@ -2065,7 +2065,7 @@ static int ai_config_block_size(comedi_device * dev, unsigned int * data)
 	return 2;
 }
 
-static int ai_config_master_clock_4020(comedi_device * dev, unsigned int * data)
+static int ai_config_master_clock_4020(struct comedi_device * dev, unsigned int * data)
 {
 	unsigned int divisor = data[4];
 	int retval = 0;
@@ -2091,7 +2091,7 @@ static int ai_config_master_clock_4020(comedi_device * dev, unsigned int * data)
 }
 
 // XXX could add support for 60xx series
-static int ai_config_master_clock(comedi_device * dev, unsigned int * data)
+static int ai_config_master_clock(struct comedi_device * dev, unsigned int * data)
 {
 
 	switch (board(dev)->layout) {
@@ -2106,7 +2106,7 @@ static int ai_config_master_clock(comedi_device * dev, unsigned int * data)
 	return -EINVAL;
 }
 
-static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
+static int ai_config_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int id = data[0];
@@ -2128,7 +2128,7 @@ static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
 	return -EINVAL;
 }
 
-static int ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -2324,7 +2324,7 @@ static int use_hw_sample_counter(comedi_cmd * cmd)
 		return 0;
 }
 
-static void setup_sample_counters(comedi_device * dev, comedi_cmd * cmd)
+static void setup_sample_counters(struct comedi_device * dev, comedi_cmd * cmd)
 {
 	if (cmd->stop_src == TRIG_COUNT) {
 		// set software count
@@ -2341,7 +2341,7 @@ static void setup_sample_counters(comedi_device * dev, comedi_cmd * cmd)
 	}
 }
 
-static inline unsigned int dma_transfer_size(comedi_device * dev)
+static inline unsigned int dma_transfer_size(struct comedi_device * dev)
 {
 	unsigned int num_samples;
 
@@ -2354,7 +2354,7 @@ static inline unsigned int dma_transfer_size(comedi_device * dev)
 	return num_samples;
 }
 
-static void disable_ai_pacing(comedi_device * dev)
+static void disable_ai_pacing(struct comedi_device * dev)
 {
 	unsigned long flags;
 
@@ -2371,7 +2371,7 @@ static void disable_ai_pacing(comedi_device * dev)
 		priv(dev)->main_iobase + ADC_CONTROL0_REG);
 }
 
-static void disable_ai_interrupts(comedi_device * dev)
+static void disable_ai_interrupts(struct comedi_device * dev)
 {
 	unsigned long flags;
 
@@ -2387,7 +2387,7 @@ static void disable_ai_interrupts(comedi_device * dev)
 	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
 }
 
-static void enable_ai_interrupts(comedi_device * dev, const comedi_cmd * cmd)
+static void enable_ai_interrupts(struct comedi_device * dev, const comedi_cmd * cmd)
 {
 	uint32_t bits;
 	unsigned long flags;
@@ -2408,14 +2408,14 @@ static void enable_ai_interrupts(comedi_device * dev, const comedi_cmd * cmd)
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
-static uint32_t ai_convert_counter_6xxx(const comedi_device * dev,
+static uint32_t ai_convert_counter_6xxx(const struct comedi_device * dev,
 	const comedi_cmd * cmd)
 {
 	// supposed to load counter with desired divisor minus 3
 	return cmd->convert_arg / TIMER_BASE - 3;
 }
 
-static uint32_t ai_scan_counter_6xxx(comedi_device * dev, comedi_cmd * cmd)
+static uint32_t ai_scan_counter_6xxx(struct comedi_device * dev, comedi_cmd * cmd)
 {
 	uint32_t count;
 	// figure out how long we need to delay at end of scan
@@ -2435,7 +2435,7 @@ static uint32_t ai_scan_counter_6xxx(comedi_device * dev, comedi_cmd * cmd)
 	return count - 3;
 }
 
-static uint32_t ai_convert_counter_4020(comedi_device * dev, comedi_cmd * cmd)
+static uint32_t ai_convert_counter_4020(struct comedi_device * dev, comedi_cmd * cmd)
 {
 	unsigned int divisor;
 
@@ -2456,7 +2456,7 @@ static uint32_t ai_convert_counter_4020(comedi_device * dev, comedi_cmd * cmd)
 	return divisor - 2;
 }
 
-static void select_master_clock_4020(comedi_device * dev,
+static void select_master_clock_4020(struct comedi_device * dev,
 	const comedi_cmd * cmd)
 {
 	// select internal/external master clock
@@ -2475,7 +2475,7 @@ static void select_master_clock_4020(comedi_device * dev,
 		priv(dev)->main_iobase + HW_CONFIG_REG);
 }
 
-static void select_master_clock(comedi_device * dev, const comedi_cmd * cmd)
+static void select_master_clock(struct comedi_device * dev, const comedi_cmd * cmd)
 {
 	switch (board(dev)->layout) {
 	case LAYOUT_4020:
@@ -2486,7 +2486,7 @@ static void select_master_clock(comedi_device * dev, const comedi_cmd * cmd)
 	}
 }
 
-static inline void dma_start_sync(comedi_device * dev, unsigned int channel)
+static inline void dma_start_sync(struct comedi_device * dev, unsigned int channel)
 {
 	unsigned long flags;
 
@@ -2503,7 +2503,7 @@ static inline void dma_start_sync(comedi_device * dev, unsigned int channel)
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
-static void set_ai_pacing(comedi_device * dev, comedi_cmd * cmd)
+static void set_ai_pacing(struct comedi_device * dev, comedi_cmd * cmd)
 {
 	uint32_t convert_counter = 0, scan_counter = 0;
 
@@ -2550,7 +2550,7 @@ static int use_internal_queue_6xxx(const comedi_cmd * cmd)
 	return 1;
 }
 
-static int setup_channel_queue(comedi_device * dev, const comedi_cmd * cmd)
+static int setup_channel_queue(struct comedi_device * dev, const comedi_cmd * cmd)
 {
 	unsigned short bits;
 	int i;
@@ -2652,7 +2652,7 @@ static int setup_channel_queue(comedi_device * dev, const comedi_cmd * cmd)
 	return 0;
 }
 
-static inline void load_first_dma_descriptor(comedi_device * dev,
+static inline void load_first_dma_descriptor(struct comedi_device * dev,
 	unsigned int dma_channel, unsigned int descriptor_bits)
 {
 	/* The transfer size, pci address, and local address registers
@@ -2679,7 +2679,7 @@ static inline void load_first_dma_descriptor(comedi_device * dev,
 	}
 }
 
-static int ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -2797,7 +2797,7 @@ static int ai_cmd(comedi_device * dev, comedi_subdevice * s)
 }
 
 // read num_samples from 16 bit wide ai fifo
-static void pio_drain_ai_fifo_16(comedi_device * dev)
+static void pio_drain_ai_fifo_16(struct comedi_device * dev)
 {
 	comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async = s->async;
@@ -2864,7 +2864,7 @@ static void pio_drain_ai_fifo_16(comedi_device * dev)
  * dma transfers (it only supports the use of pio for draining the last remaining
  * points from the fifo when a data aquisition operation has completed).
  */
-static void pio_drain_ai_fifo_32(comedi_device * dev)
+static void pio_drain_ai_fifo_32(struct comedi_device * dev)
 {
 	comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async = s->async;
@@ -2898,7 +2898,7 @@ static void pio_drain_ai_fifo_32(comedi_device * dev)
 }
 
 // empty fifo
-static void pio_drain_ai_fifo(comedi_device * dev)
+static void pio_drain_ai_fifo(struct comedi_device * dev)
 {
 	if (board(dev)->layout == LAYOUT_4020) {
 		pio_drain_ai_fifo_32(dev);
@@ -2906,7 +2906,7 @@ static void pio_drain_ai_fifo(comedi_device * dev)
 		pio_drain_ai_fifo_16(dev);
 }
 
-static void drain_dma_buffers(comedi_device * dev, unsigned int channel)
+static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 {
 	comedi_async *async = dev->read_subdev->async;
 	uint32_t next_transfer_addr;
@@ -2952,7 +2952,7 @@ static void drain_dma_buffers(comedi_device * dev, unsigned int channel)
 	 * unused buffer) */
 }
 
-void handle_ai_interrupt(comedi_device * dev, unsigned short status,
+void handle_ai_interrupt(struct comedi_device * dev, unsigned short status,
 	unsigned int plx_status)
 {
 	comedi_subdevice *s = dev->read_subdev;
@@ -3006,7 +3006,7 @@ void handle_ai_interrupt(comedi_device * dev, unsigned short status,
 	cfc_handle_events(dev, s);
 }
 
-static inline unsigned int prev_ao_dma_index(comedi_device * dev)
+static inline unsigned int prev_ao_dma_index(struct comedi_device * dev)
 {
 	unsigned int buffer_index;
 
@@ -3017,7 +3017,7 @@ static inline unsigned int prev_ao_dma_index(comedi_device * dev)
 	return buffer_index;
 }
 
-static int last_ao_dma_load_completed(comedi_device * dev)
+static int last_ao_dma_load_completed(struct comedi_device * dev)
 {
 	unsigned int buffer_index;
 	unsigned int transfer_address;
@@ -3036,7 +3036,7 @@ static int last_ao_dma_load_completed(comedi_device * dev)
 	return 1;
 }
 
-static int ao_stopped_by_error(comedi_device * dev, const comedi_cmd * cmd)
+static int ao_stopped_by_error(struct comedi_device * dev, const comedi_cmd * cmd)
 {
 	if (cmd->stop_src == TRIG_NONE)
 		return 1;
@@ -3049,7 +3049,7 @@ static int ao_stopped_by_error(comedi_device * dev, const comedi_cmd * cmd)
 	return 0;
 }
 
-static inline int ao_dma_needs_restart(comedi_device * dev,
+static inline int ao_dma_needs_restart(struct comedi_device * dev,
 	unsigned short dma_status)
 {
 	if ((dma_status & PLX_DMA_DONE_BIT) == 0 ||
@@ -3061,7 +3061,7 @@ static inline int ao_dma_needs_restart(comedi_device * dev,
 	return 1;
 }
 
-static void restart_ao_dma(comedi_device * dev)
+static void restart_ao_dma(struct comedi_device * dev)
 {
 	unsigned int dma_desc_bits;
 
@@ -3074,7 +3074,7 @@ static void restart_ao_dma(comedi_device * dev)
 	dma_start_sync(dev, 0);
 }
 
-static void handle_ao_interrupt(comedi_device * dev, unsigned short status,
+static void handle_ao_interrupt(struct comedi_device * dev, unsigned short status,
 	unsigned int plx_status)
 {
 	comedi_subdevice *s = dev->write_subdev;
@@ -3128,7 +3128,7 @@ static void handle_ao_interrupt(comedi_device * dev, unsigned short status,
 
 static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	unsigned short status;
 	uint32_t plx_status;
 	uint32_t plx_bits;
@@ -3162,7 +3162,7 @@ static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-void abort_dma(comedi_device * dev, unsigned int channel)
+void abort_dma(struct comedi_device * dev, unsigned int channel)
 {
 	unsigned long flags;
 
@@ -3174,7 +3174,7 @@ void abort_dma(comedi_device * dev, unsigned int channel)
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
-static int ai_cancel(comedi_device * dev, comedi_subdevice * s)
+static int ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -3194,7 +3194,7 @@ static int ai_cancel(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec);
@@ -3224,7 +3224,7 @@ static int ao_winsn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
+static int ao_readback_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = priv(dev)->ao_value[CR_CHAN(insn->chanspec)];
@@ -3232,7 +3232,7 @@ static int ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static void set_dac_control0_reg(comedi_device * dev, const comedi_cmd * cmd)
+static void set_dac_control0_reg(struct comedi_device * dev, const comedi_cmd * cmd)
 {
 	unsigned int bits = DAC_ENABLE_BIT | WAVEFORM_GATE_LEVEL_BIT |
 		WAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;
@@ -3252,7 +3252,7 @@ static void set_dac_control0_reg(comedi_device * dev, const comedi_cmd * cmd)
 	writew(bits, priv(dev)->main_iobase + DAC_CONTROL0_REG);
 }
 
-static void set_dac_control1_reg(comedi_device * dev, const comedi_cmd * cmd)
+static void set_dac_control1_reg(struct comedi_device * dev, const comedi_cmd * cmd)
 {
 	int i;
 
@@ -3269,7 +3269,7 @@ static void set_dac_control1_reg(comedi_device * dev, const comedi_cmd * cmd)
 		priv(dev)->main_iobase + DAC_CONTROL1_REG);
 }
 
-static void set_dac_select_reg(comedi_device * dev, const comedi_cmd * cmd)
+static void set_dac_select_reg(struct comedi_device * dev, const comedi_cmd * cmd)
 {
 	uint16_t bits;
 	unsigned int first_channel, last_channel;
@@ -3284,7 +3284,7 @@ static void set_dac_select_reg(comedi_device * dev, const comedi_cmd * cmd)
 	writew(bits, priv(dev)->main_iobase + DAC_SELECT_REG);
 }
 
-static void set_dac_interval_regs(comedi_device * dev, const comedi_cmd * cmd)
+static void set_dac_interval_regs(struct comedi_device * dev, const comedi_cmd * cmd)
 {
 	unsigned int divisor;
 
@@ -3302,7 +3302,7 @@ static void set_dac_interval_regs(comedi_device * dev, const comedi_cmd * cmd)
 		priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_UPPER_REG);
 }
 
-static unsigned int load_ao_dma_buffer(comedi_device * dev,
+static unsigned int load_ao_dma_buffer(struct comedi_device * dev,
 	const comedi_cmd * cmd)
 {
 	unsigned int num_bytes, buffer_index, prev_buffer_index;
@@ -3346,7 +3346,7 @@ static unsigned int load_ao_dma_buffer(comedi_device * dev,
 	return num_bytes;
 }
 
-static void load_ao_dma(comedi_device * dev, const comedi_cmd * cmd)
+static void load_ao_dma(struct comedi_device * dev, const comedi_cmd * cmd)
 {
 	unsigned int num_bytes;
 	unsigned int next_transfer_addr;
@@ -3368,7 +3368,7 @@ static void load_ao_dma(comedi_device * dev, const comedi_cmd * cmd)
 	} while (num_bytes >= DMA_BUFFER_SIZE);
 }
 
-static int prep_ao_dma(comedi_device * dev, const comedi_cmd * cmd)
+static int prep_ao_dma(struct comedi_device * dev, const comedi_cmd * cmd)
 {
 	unsigned int num_bytes;
 	int i;
@@ -3402,7 +3402,7 @@ static int prep_ao_dma(comedi_device * dev, const comedi_cmd * cmd)
 	return 0;
 }
 
-static inline int external_ai_queue_in_use(comedi_device * dev)
+static inline int external_ai_queue_in_use(struct comedi_device * dev)
 {
 	if (dev->read_subdev->busy)
 		return 0;
@@ -3413,7 +3413,7 @@ static inline int external_ai_queue_in_use(comedi_device * dev)
 	return 1;
 }
 
-static int ao_cmd(comedi_device * dev, comedi_subdevice * s)
+static int ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 
@@ -3438,7 +3438,7 @@ static int ao_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int ao_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int ao_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trig_num)
 {
 	comedi_cmd *cmd = &s->async->cmd;
@@ -3461,7 +3461,7 @@ static int ao_inttrig(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -3577,7 +3577,7 @@ static int ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int ao_cancel(comedi_device * dev, comedi_subdevice * s)
+static int ao_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	writew(0x0, priv(dev)->main_iobase + DAC_CONTROL0_REG);
 	abort_dma(dev, 0);
@@ -3605,7 +3605,7 @@ static int dio_callback_4020(int dir, int port, int data, unsigned long iobase)
 	}
 }
 
-static int di_rbits(comedi_device * dev, comedi_subdevice * s,
+static int di_rbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int bits;
@@ -3618,7 +3618,7 @@ static int di_rbits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int do_wbits(comedi_device * dev, comedi_subdevice * s,
+static int do_wbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] &= 0xf;
@@ -3634,7 +3634,7 @@ static int do_wbits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int dio_60xx_config_insn(comedi_device * dev, comedi_subdevice * s,
+static int dio_60xx_config_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int mask;
@@ -3661,7 +3661,7 @@ static int dio_60xx_config_insn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int dio_60xx_wbits(comedi_device * dev, comedi_subdevice * s,
+static int dio_60xx_wbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (data[0]) {
@@ -3676,7 +3676,7 @@ static int dio_60xx_wbits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static void caldac_write(comedi_device * dev, unsigned int channel,
+static void caldac_write(struct comedi_device * dev, unsigned int channel,
 	unsigned int value)
 {
 	priv(dev)->caldac_state[channel] = value;
@@ -3694,7 +3694,7 @@ static void caldac_write(comedi_device * dev, unsigned int channel,
 	}
 }
 
-static int calib_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int calib_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
@@ -3709,7 +3709,7 @@ static int calib_write_insn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int calib_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int calib_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
@@ -3719,7 +3719,7 @@ static int calib_read_insn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static void ad8402_write(comedi_device * dev, unsigned int channel,
+static void ad8402_write(struct comedi_device * dev, unsigned int channel,
 	unsigned int value)
 {
 	static const int bitstream_length = 10;
@@ -3750,7 +3750,7 @@ static void ad8402_write(comedi_device * dev, unsigned int channel,
 }
 
 /* for pci-das6402/16, channel 0 is analog input gain and channel 1 is offset */
-static int ad8402_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int ad8402_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
@@ -3767,7 +3767,7 @@ static int ad8402_write_insn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int ad8402_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int ad8402_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
@@ -3777,7 +3777,7 @@ static int ad8402_read_insn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static uint16_t read_eeprom(comedi_device * dev, uint8_t address)
+static uint16_t read_eeprom(struct comedi_device * dev, uint8_t address)
 {
 	static const int bitstream_length = 11;
 	static const int read_command = 0x6;
@@ -3839,7 +3839,7 @@ static uint16_t read_eeprom(comedi_device * dev, uint8_t address)
 	return value;
 }
 
-static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int eeprom_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = read_eeprom(dev, CR_CHAN(insn->chanspec));
@@ -3851,7 +3851,7 @@ static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
  * sets cmd members appropriately.
  * adc paces conversions from master clock by dividing by (x + 3) where x is 24 bit number
  */
-static void check_adc_timing(comedi_device * dev, comedi_cmd * cmd)
+static void check_adc_timing(struct comedi_device * dev, comedi_cmd * cmd)
 {
 	unsigned int convert_divisor = 0, scan_divisor;
 	static const int min_convert_divisor = 3;
@@ -3925,7 +3925,7 @@ static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags)
 }
 
 // adjusts the size of hardware fifo (which determines block size for dma xfers)
-static int set_ai_fifo_size(comedi_device * dev, unsigned int num_samples)
+static int set_ai_fifo_size(struct comedi_device * dev, unsigned int num_samples)
 {
 	unsigned int num_fifo_entries;
 	int retval;
@@ -3946,14 +3946,14 @@ static int set_ai_fifo_size(comedi_device * dev, unsigned int num_samples)
 }
 
 // query length of fifo
-static unsigned int ai_fifo_size(comedi_device * dev)
+static unsigned int ai_fifo_size(struct comedi_device * dev)
 {
 	return priv(dev)->ai_fifo_segment_length *
 		board(dev)->ai_fifo->num_segments *
 		board(dev)->ai_fifo->sample_packing_ratio;
 }
 
-static int set_ai_fifo_segment_length(comedi_device * dev,
+static int set_ai_fifo_segment_length(struct comedi_device * dev,
 	unsigned int num_entries)
 {
 	static const int increment_size = 0x100;
@@ -4004,7 +4004,7 @@ static int set_ai_fifo_segment_length(comedi_device * dev,
  * address 7 == dac channel 1 fine offset
 */
 
-static int caldac_8800_write(comedi_device * dev, unsigned int address,
+static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
 	uint8_t value)
 {
 	static const int num_caldac_channels = 8;
@@ -4036,7 +4036,7 @@ static int caldac_8800_write(comedi_device * dev, unsigned int address,
 }
 
 // 4020 caldacs
-static int caldac_i2c_write(comedi_device * dev, unsigned int caldac_channel,
+static int caldac_i2c_write(struct comedi_device * dev, unsigned int caldac_channel,
 	unsigned int value)
 {
 	uint8_t serial_bytes[3];
@@ -4101,7 +4101,7 @@ static const int i2c_high_comedi_udelay = 1000;
 static const int i2c_low_comedi_udelay = 10;
 
 // set i2c data line high or low
-static void i2c_set_sda(comedi_device * dev, int state)
+static void i2c_set_sda(struct comedi_device * dev, int state)
 {
 	static const int data_bit = CTL_EE_W;
 	void *plx_control_addr = priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
@@ -4120,7 +4120,7 @@ static void i2c_set_sda(comedi_device * dev, int state)
 }
 
 // set i2c clock line high or low
-static void i2c_set_scl(comedi_device * dev, int state)
+static void i2c_set_scl(struct comedi_device * dev, int state)
 {
 	static const int clock_bit = CTL_USERO;
 	void *plx_control_addr = priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
@@ -4138,7 +4138,7 @@ static void i2c_set_scl(comedi_device * dev, int state)
 	}
 }
 
-static void i2c_write_byte(comedi_device * dev, uint8_t byte)
+static void i2c_write_byte(struct comedi_device * dev, uint8_t byte)
 {
 	uint8_t bit;
 	unsigned int num_bits = 8;
@@ -4156,7 +4156,7 @@ static void i2c_write_byte(comedi_device * dev, uint8_t byte)
 }
 
 // we can't really read the lines, so fake it
-static int i2c_read_ack(comedi_device * dev)
+static int i2c_read_ack(struct comedi_device * dev)
 {
 	i2c_set_scl(dev, 0);
 	i2c_set_sda(dev, 1);
@@ -4166,7 +4166,7 @@ static int i2c_read_ack(comedi_device * dev)
 }
 
 // send start bit
-static void i2c_start(comedi_device * dev)
+static void i2c_start(struct comedi_device * dev)
 {
 	i2c_set_scl(dev, 1);
 	i2c_set_sda(dev, 1);
@@ -4174,7 +4174,7 @@ static void i2c_start(comedi_device * dev)
 }
 
 // send stop bit
-static void i2c_stop(comedi_device * dev)
+static void i2c_stop(struct comedi_device * dev)
 {
 	i2c_set_scl(dev, 0);
 	i2c_set_sda(dev, 0);
@@ -4182,7 +4182,7 @@ static void i2c_stop(comedi_device * dev)
 	i2c_set_sda(dev, 1);
 }
 
-static void i2c_write(comedi_device * dev, unsigned int address,
+static void i2c_write(struct comedi_device * dev, unsigned int address,
 	const uint8_t * data, unsigned int length)
 {
 	unsigned int i;

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 9f056aa44f5d..4b1afce04d92 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -1108,7 +1108,7 @@ typedef struct {
 	volatile short ai_cmd_running;
 	unsigned int ai_fifo_segment_length;
 	struct ext_clock_info ext_clock;
-	sampl_t ao_bounce_buffer[DAC_FIFO_SIZE];
+	short ao_bounce_buffer[DAC_FIFO_SIZE];
 } pcidas64_private;
 
 /* inline function that makes it easier to
@@ -1135,13 +1135,13 @@ static comedi_driver driver_cb_pcidas = {
 };
 
 static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ai_cmd(comedi_device * dev, comedi_subdevice * s);
 static int ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
@@ -1156,25 +1156,25 @@ static int ao_cancel(comedi_device * dev, comedi_subdevice * s);
 static int dio_callback(int dir, int port, int data, unsigned long arg);
 static int dio_callback_4020(int dir, int port, int data, unsigned long arg);
 static int di_rbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int do_wbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int dio_60xx_config_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int dio_60xx_wbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int calib_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int calib_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ad8402_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static void ad8402_write(comedi_device * dev, unsigned int channel,
 	unsigned int value);
 static int ad8402_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static void check_adc_timing(comedi_device * dev, comedi_cmd * cmd);
 static unsigned int get_divisor(unsigned int ns, unsigned int flags);
 static void i2c_write(comedi_device * dev, unsigned int address,
@@ -1882,7 +1882,7 @@ static int detach(comedi_device * dev)
 }
 
 static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int bits = 0, n, i;
 	unsigned int channel, range, aref;
@@ -2018,9 +2018,9 @@ static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int ai_config_calibration_source(comedi_device * dev, lsampl_t * data)
+static int ai_config_calibration_source(comedi_device * dev, unsigned int * data)
 {
-	lsampl_t source = data[1];
+	unsigned int source = data[1];
 	int num_calibration_sources;
 
 	if (board(dev)->layout == LAYOUT_60XX)
@@ -2038,7 +2038,7 @@ static int ai_config_calibration_source(comedi_device * dev, lsampl_t * data)
 	return 2;
 }
 
-static int ai_config_block_size(comedi_device * dev, lsampl_t * data)
+static int ai_config_block_size(comedi_device * dev, unsigned int * data)
 {
 	int fifo_size;
 	const hw_fifo_info_t *const fifo = board(dev)->ai_fifo;
@@ -2065,7 +2065,7 @@ static int ai_config_block_size(comedi_device * dev, lsampl_t * data)
 	return 2;
 }
 
-static int ai_config_master_clock_4020(comedi_device * dev, lsampl_t * data)
+static int ai_config_master_clock_4020(comedi_device * dev, unsigned int * data)
 {
 	unsigned int divisor = data[4];
 	int retval = 0;
@@ -2091,7 +2091,7 @@ static int ai_config_master_clock_4020(comedi_device * dev, lsampl_t * data)
 }
 
 // XXX could add support for 60xx series
-static int ai_config_master_clock(comedi_device * dev, lsampl_t * data)
+static int ai_config_master_clock(comedi_device * dev, unsigned int * data)
 {
 
 	switch (board(dev)->layout) {
@@ -2107,7 +2107,7 @@ static int ai_config_master_clock(comedi_device * dev, lsampl_t * data)
 }
 
 static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int id = data[0];
 
@@ -3195,7 +3195,7 @@ static int ai_cancel(comedi_device * dev, comedi_subdevice * s)
 }
 
 static int ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	int range = CR_RANGE(insn->chanspec);
@@ -3225,7 +3225,7 @@ static int ao_winsn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = priv(dev)->ao_value[CR_CHAN(insn->chanspec)];
 
@@ -3606,9 +3606,9 @@ static int dio_callback_4020(int dir, int port, int data, unsigned long iobase)
 }
 
 static int di_rbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
-	lsampl_t bits;
+	unsigned int bits;
 
 	bits = readb(priv(dev)->dio_counter_iobase + DI_REG);
 	bits &= 0xf;
@@ -3619,7 +3619,7 @@ static int di_rbits(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int do_wbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[0] &= 0xf;
 	// zero bits we are going to change
@@ -3635,7 +3635,7 @@ static int do_wbits(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int dio_60xx_config_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int mask;
 
@@ -3662,7 +3662,7 @@ static int dio_60xx_config_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int dio_60xx_wbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -3695,7 +3695,7 @@ static void caldac_write(comedi_device * dev, unsigned int channel,
 }
 
 static int calib_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -3710,7 +3710,7 @@ static int calib_write_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int calib_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -3751,7 +3751,7 @@ static void ad8402_write(comedi_device * dev, unsigned int channel,
 
 /* for pci-das6402/16, channel 0 is analog input gain and channel 1 is offset */
 static int ad8402_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -3768,7 +3768,7 @@ static int ad8402_write_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ad8402_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -3840,7 +3840,7 @@ static uint16_t read_eeprom(comedi_device * dev, uint8_t address)
 }
 
 static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = read_eeprom(dev, CR_CHAN(insn->chanspec));
 

commit 88b12a9a66a4714a572d415cc4d6b257a8da61d4
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Thu Feb 19 09:32:42 2009 -0800

    Staging: comedi: add cb_pcidas64 driver
    
    Driver for the ComputerBoards/MeasurementComputing PCI-DAS
    64xx, 60xx, and 4020 cards.
    
    From: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
new file mode 100644
index 000000000000..9f056aa44f5d
--- /dev/null
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -0,0 +1,4220 @@
+/*
+    comedi/drivers/cb_pcidas64.c
+    This is a driver for the ComputerBoards/MeasurementComputing PCI-DAS
+    64xx, 60xx, and 4020 cards.
+
+    Author:  Frank Mori Hess <fmhess@users.sourceforge.net>
+    Copyright (C) 2001, 2002 Frank Mori Hess
+
+    Thanks also go to the following people:
+
+    Steve Rosenbluth, for providing the source code for
+    his pci-das6402 driver, and source code for working QNX pci-6402
+    drivers by Greg Laird and Mariusz Bogacz.  None of the code was
+    used directly here, but it was useful as an additional source of
+    documentation on how to program the boards.
+
+    John Sims, for much testing and feedback on pcidas-4020 support.
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+************************************************************************/
+
+/*
+
+Driver: cb_pcidas64
+Description: MeasurementComputing PCI-DAS64xx, 60XX, and 4020 series with the PLX 9080 PCI controller
+Author: Frank Mori Hess <fmhess@users.sourceforge.net>
+Status: works
+Updated: 2002-10-09
+Devices: [Measurement Computing] PCI-DAS6402/16 (cb_pcidas64),
+  PCI-DAS6402/12, PCI-DAS64/M1/16, PCI-DAS64/M2/16,
+  PCI-DAS64/M3/16, PCI-DAS6402/16/JR, PCI-DAS64/M1/16/JR,
+  PCI-DAS64/M2/16/JR, PCI-DAS64/M3/16/JR, PCI-DAS64/M1/14,
+  PCI-DAS64/M2/14, PCI-DAS64/M3/14, PCI-DAS6013, PCI-DAS6014,
+  PCI-DAS6023, PCI-DAS6025, PCI-DAS6030,
+  PCI-DAS6031, PCI-DAS6032, PCI-DAS6033, PCI-DAS6034,
+  PCI-DAS6035, PCI-DAS6036, PCI-DAS6040, PCI-DAS6052,
+  PCI-DAS6070, PCI-DAS6071, PCI-DAS4020/12
+
+Configuration options:
+   [0] - PCI bus of device (optional)
+   [1] - PCI slot of device (optional)
+
+These boards may be autocalibrated with the comedi_calibrate utility.
+
+To select the bnc trigger input on the 4020 (instead of the dio input),
+specify a nonzero channel in the chanspec.  If you wish to use an external
+master clock on the 4020, you may do so by setting the scan_begin_src
+to TRIG_OTHER, and using an INSN_CONFIG_TIMER_1 configuration insn
+to configure the divisor to use for the external clock.
+
+Some devices are not identified because the PCI device IDs are not yet
+known. If you have such a board, please file a bug report at
+https://bugs.comedi.org.
+
+*/
+
+/*
+
+TODO:
+	make it return error if user attempts an ai command that uses the
+		external queue, and an ao command simultaneously
+	user counter subdevice
+	there are a number of boards this driver will support when they are
+		fully released, but does not yet since the pci device id numbers
+		are not yet available.
+	support prescaled 100khz clock for slow pacing (not available on 6000 series?)
+	make ao fifo size adjustable like ai fifo
+*/
+
+#include "../comedidev.h"
+#include <linux/delay.h>
+#include <asm/system.h>
+
+#include "comedi_pci.h"
+#include "8253.h"
+#include "8255.h"
+#include "plx9080.h"
+#include "comedi_fc.h"
+
+#undef PCIDAS64_DEBUG		// disable debugging code
+//#define PCIDAS64_DEBUG        // enable debugging code
+
+#ifdef PCIDAS64_DEBUG
+#define DEBUG_PRINT(format, args...)  rt_printk(format , ## args )
+#else
+#define DEBUG_PRINT(format, args...)
+#endif
+
+#define TIMER_BASE 25		// 40MHz master clock
+#define PRESCALED_TIMER_BASE	10000	// 100kHz 'prescaled' clock for slow aquisition, maybe I'll support this someday
+#define DMA_BUFFER_SIZE 0x1000
+
+/* maximum value that can be loaded into board's 24-bit counters*/
+static const int max_counter_value = 0xffffff;
+
+/* PCI-DAS64xxx base addresses */
+
+// indices of base address regions
+enum base_address_regions {
+	PLX9080_BADDRINDEX = 0,
+	MAIN_BADDRINDEX = 2,
+	DIO_COUNTER_BADDRINDEX = 3,
+};
+
+// priv(dev)->main_iobase registers
+enum write_only_registers {
+	INTR_ENABLE_REG = 0x0,	// interrupt enable register
+	HW_CONFIG_REG = 0x2,	// hardware config register
+	DAQ_SYNC_REG = 0xc,
+	DAQ_ATRIG_LOW_4020_REG = 0xc,
+	ADC_CONTROL0_REG = 0x10,	// adc control register 0
+	ADC_CONTROL1_REG = 0x12,	// adc control register 1
+	CALIBRATION_REG = 0x14,
+	ADC_SAMPLE_INTERVAL_LOWER_REG = 0x16,	// lower 16 bits of adc sample interval counter
+	ADC_SAMPLE_INTERVAL_UPPER_REG = 0x18,	// upper 8 bits of adc sample interval counter
+	ADC_DELAY_INTERVAL_LOWER_REG = 0x1a,	// lower 16 bits of delay interval counter
+	ADC_DELAY_INTERVAL_UPPER_REG = 0x1c,	// upper 8 bits of delay interval counter
+	ADC_COUNT_LOWER_REG = 0x1e,	// lower 16 bits of hardware conversion/scan counter
+	ADC_COUNT_UPPER_REG = 0x20,	// upper 8 bits of hardware conversion/scan counter
+	ADC_START_REG = 0x22,	// software trigger to start aquisition
+	ADC_CONVERT_REG = 0x24,	// initiates single conversion
+	ADC_QUEUE_CLEAR_REG = 0x26,	// clears adc queue
+	ADC_QUEUE_LOAD_REG = 0x28,	// loads adc queue
+	ADC_BUFFER_CLEAR_REG = 0x2a,
+	ADC_QUEUE_HIGH_REG = 0x2c,	// high channel for internal queue, use adc_chan_bits() inline above
+	DAC_CONTROL0_REG = 0x50,	// dac control register 0
+	DAC_CONTROL1_REG = 0x52,	// dac control register 0
+	DAC_SAMPLE_INTERVAL_LOWER_REG = 0x54,	// lower 16 bits of dac sample interval counter
+	DAC_SAMPLE_INTERVAL_UPPER_REG = 0x56,	// upper 8 bits of dac sample interval counter
+	DAC_SELECT_REG = 0x60,
+	DAC_START_REG = 0x64,
+	DAC_BUFFER_CLEAR_REG = 0x66,	// clear dac buffer
+};
+static inline unsigned int dac_convert_reg(unsigned int channel)
+{
+	return 0x70 + (2 * (channel & 0x1));
+}
+static inline unsigned int dac_lsb_4020_reg(unsigned int channel)
+{
+	return 0x70 + (4 * (channel & 0x1));
+}
+static inline unsigned int dac_msb_4020_reg(unsigned int channel)
+{
+	return 0x72 + (4 * (channel & 0x1));
+}
+
+enum read_only_registers {
+	HW_STATUS_REG = 0x0,	// hardware status register, reading this apparently clears pending interrupts as well
+	PIPE1_READ_REG = 0x4,
+	ADC_READ_PNTR_REG = 0x8,
+	LOWER_XFER_REG = 0x10,
+	ADC_WRITE_PNTR_REG = 0xc,
+	PREPOST_REG = 0x14,
+};
+
+enum read_write_registers {
+	I8255_4020_REG = 0x48,	// 8255 offset, for 4020 only
+	ADC_QUEUE_FIFO_REG = 0x100,	// external channel/gain queue, uses same bits as ADC_QUEUE_LOAD_REG
+	ADC_FIFO_REG = 0x200,	/* adc data fifo */
+	DAC_FIFO_REG = 0x300,	/* dac data fifo, has weird interactions with external channel queue */
+};
+
+// priv(dev)->dio_counter_iobase registers
+enum dio_counter_registers {
+	DIO_8255_OFFSET = 0x0,
+	DO_REG = 0x20,
+	DI_REG = 0x28,
+	DIO_DIRECTION_60XX_REG = 0x40,
+	DIO_DATA_60XX_REG = 0x48,
+};
+
+// bit definitions for write-only registers
+
+enum intr_enable_contents {
+	ADC_INTR_SRC_MASK = 0x3,	// bits that set adc interrupt source
+	ADC_INTR_QFULL_BITS = 0x0,	// interrupt fifo quater full
+	ADC_INTR_EOC_BITS = 0x1,	// interrupt end of conversion
+	ADC_INTR_EOSCAN_BITS = 0x2,	// interrupt end of scan
+	ADC_INTR_EOSEQ_BITS = 0x3,	// interrupt end of sequence (probably wont use this it's pretty fancy)
+	EN_ADC_INTR_SRC_BIT = 0x4,	// enable adc interrupt source
+	EN_ADC_DONE_INTR_BIT = 0x8,	// enable adc aquisition done interrupt
+	DAC_INTR_SRC_MASK = 0x30,
+	DAC_INTR_QEMPTY_BITS = 0x0,
+	DAC_INTR_HIGH_CHAN_BITS = 0x10,
+	EN_DAC_INTR_SRC_BIT = 0x40,	// enable dac interrupt source
+	EN_DAC_DONE_INTR_BIT = 0x80,
+	EN_ADC_ACTIVE_INTR_BIT = 0x200,	// enable adc active interrupt
+	EN_ADC_STOP_INTR_BIT = 0x400,	// enable adc stop trigger interrupt
+	EN_DAC_ACTIVE_INTR_BIT = 0x800,	// enable dac active interrupt
+	EN_DAC_UNDERRUN_BIT = 0x4000,	// enable dac underrun status bit
+	EN_ADC_OVERRUN_BIT = 0x8000,	// enable adc overrun status bit
+};
+
+enum hw_config_contents {
+	MASTER_CLOCK_4020_MASK = 0x3,	// bits that specify master clock source for 4020
+	INTERNAL_CLOCK_4020_BITS = 0x1,	// use 40 MHz internal master clock for 4020
+	BNC_CLOCK_4020_BITS = 0x2,	// use BNC input for master clock
+	EXT_CLOCK_4020_BITS = 0x3,	// use dio input for master clock
+	EXT_QUEUE_BIT = 0x200,	// use external channel/gain queue (more versatile than internal queue)
+	SLOW_DAC_BIT = 0x400,	// use 225 nanosec strobe when loading dac instead of 50 nanosec
+	HW_CONFIG_DUMMY_BITS = 0x2000,	// bit with unknown function yet given as default value in pci-das64 manual
+	DMA_CH_SELECT_BIT = 0x8000,	// bit selects channels 1/0 for analog input/output, otherwise 0/1
+	FIFO_SIZE_REG = 0x4,	// allows adjustment of fifo sizes
+	DAC_FIFO_SIZE_MASK = 0xff00,	// bits that set dac fifo size
+	DAC_FIFO_BITS = 0xf800,	/* 8k sample ao fifo */
+};
+#define DAC_FIFO_SIZE 0x2000
+
+enum daq_atrig_low_4020_contents {
+	EXT_AGATE_BNC_BIT = 0x8000,	// use trig/ext clk bnc input for analog gate signal
+	EXT_STOP_TRIG_BNC_BIT = 0x4000,	// use trig/ext clk bnc input for external stop trigger signal
+	EXT_START_TRIG_BNC_BIT = 0x2000,	// use trig/ext clk bnc input for external start trigger signal
+};
+static inline uint16_t analog_trig_low_threshold_bits(uint16_t threshold)
+{
+	return threshold & 0xfff;
+}
+
+enum adc_control0_contents {
+	ADC_GATE_SRC_MASK = 0x3,	// bits that select gate
+	ADC_SOFT_GATE_BITS = 0x1,	// software gate
+	ADC_EXT_GATE_BITS = 0x2,	// external digital gate
+	ADC_ANALOG_GATE_BITS = 0x3,	// analog level gate
+	ADC_GATE_LEVEL_BIT = 0x4,	// level-sensitive gate (for digital)
+	ADC_GATE_POLARITY_BIT = 0x8,	// gate active low
+	ADC_START_TRIG_SOFT_BITS = 0x10,
+	ADC_START_TRIG_EXT_BITS = 0x20,
+	ADC_START_TRIG_ANALOG_BITS = 0x30,
+	ADC_START_TRIG_MASK = 0x30,
+	ADC_START_TRIG_FALLING_BIT = 0x40,	// trig 1 uses falling edge
+	ADC_EXT_CONV_FALLING_BIT = 0x800,	// external pacing uses falling edge
+	ADC_SAMPLE_COUNTER_EN_BIT = 0x1000,	// enable hardware scan counter
+	ADC_DMA_DISABLE_BIT = 0x4000,	// disables dma
+	ADC_ENABLE_BIT = 0x8000,	// master adc enable
+};
+
+enum adc_control1_contents {
+	ADC_QUEUE_CONFIG_BIT = 0x1,	// should be set for boards with > 16 channels
+	CONVERT_POLARITY_BIT = 0x10,
+	EOC_POLARITY_BIT = 0x20,
+	ADC_SW_GATE_BIT = 0x40,	// software gate of adc
+	ADC_DITHER_BIT = 0x200,	// turn on extra noise for dithering
+	RETRIGGER_BIT = 0x800,
+	ADC_LO_CHANNEL_4020_MASK = 0x300,
+	ADC_HI_CHANNEL_4020_MASK = 0xc00,
+	TWO_CHANNEL_4020_BITS = 0x1000,	// two channel mode for 4020
+	FOUR_CHANNEL_4020_BITS = 0x2000,	// four channel mode for 4020
+	CHANNEL_MODE_4020_MASK = 0x3000,
+	ADC_MODE_MASK = 0xf000,
+};
+static inline uint16_t adc_lo_chan_4020_bits(unsigned int channel)
+{
+	return (channel & 0x3) << 8;
+};
+static inline uint16_t adc_hi_chan_4020_bits(unsigned int channel)
+{
+	return (channel & 0x3) << 10;
+};
+static inline uint16_t adc_mode_bits(unsigned int mode)
+{
+	return (mode & 0xf) << 12;
+};
+
+enum calibration_contents {
+	SELECT_8800_BIT = 0x1,
+	SELECT_8402_64XX_BIT = 0x2,
+	SELECT_1590_60XX_BIT = 0x2,
+	CAL_EN_64XX_BIT = 0x40,	// calibration enable for 64xx series
+	SERIAL_DATA_IN_BIT = 0x80,
+	SERIAL_CLOCK_BIT = 0x100,
+	CAL_EN_60XX_BIT = 0x200,	// calibration enable for 60xx series
+	CAL_GAIN_BIT = 0x800,
+};
+/* calibration sources for 6025 are:
+ *  0 : ground
+ *  1 : 10V
+ *  2 : 5V
+ *  3 : 0.5V
+ *  4 : 0.05V
+ *  5 : ground
+ *  6 : dac channel 0
+ *  7 : dac channel 1
+ */
+static inline uint16_t adc_src_bits(unsigned int source)
+{
+	return (source & 0xf) << 3;
+};
+
+static inline uint16_t adc_convert_chan_4020_bits(unsigned int channel)
+{
+	return (channel & 0x3) << 8;
+};
+
+enum adc_queue_load_contents {
+	UNIP_BIT = 0x800,	// unipolar/bipolar bit
+	ADC_SE_DIFF_BIT = 0x1000,	// single-ended/ differential bit
+	ADC_COMMON_BIT = 0x2000,	// non-referenced single-ended (common-mode input)
+	QUEUE_EOSEQ_BIT = 0x4000,	// queue end of sequence
+	QUEUE_EOSCAN_BIT = 0x8000,	// queue end of scan
+};
+static inline uint16_t adc_chan_bits(unsigned int channel)
+{
+	return channel & 0x3f;
+};
+
+enum dac_control0_contents {
+	DAC_ENABLE_BIT = 0x8000,	// dac controller enable bit
+	DAC_CYCLIC_STOP_BIT = 0x4000,
+	DAC_WAVEFORM_MODE_BIT = 0x100,
+	DAC_EXT_UPDATE_FALLING_BIT = 0x80,
+	DAC_EXT_UPDATE_ENABLE_BIT = 0x40,
+	WAVEFORM_TRIG_MASK = 0x30,
+	WAVEFORM_TRIG_DISABLED_BITS = 0x0,
+	WAVEFORM_TRIG_SOFT_BITS = 0x10,
+	WAVEFORM_TRIG_EXT_BITS = 0x20,
+	WAVEFORM_TRIG_ADC1_BITS = 0x30,
+	WAVEFORM_TRIG_FALLING_BIT = 0x8,
+	WAVEFORM_GATE_LEVEL_BIT = 0x4,
+	WAVEFORM_GATE_ENABLE_BIT = 0x2,
+	WAVEFORM_GATE_SELECT_BIT = 0x1,
+};
+
+enum dac_control1_contents {
+	DAC_WRITE_POLARITY_BIT = 0x800,	/* board-dependent setting */
+	DAC1_EXT_REF_BIT = 0x200,
+	DAC0_EXT_REF_BIT = 0x100,
+	DAC_OUTPUT_ENABLE_BIT = 0x80,	// dac output enable bit
+	DAC_UPDATE_POLARITY_BIT = 0x40,	/* board-dependent setting */
+	DAC_SW_GATE_BIT = 0x20,
+	DAC1_UNIPOLAR_BIT = 0x8,
+	DAC0_UNIPOLAR_BIT = 0x2,
+};
+
+// bit definitions for read-only registers
+enum hw_status_contents {
+	DAC_UNDERRUN_BIT = 0x1,
+	ADC_OVERRUN_BIT = 0x2,
+	DAC_ACTIVE_BIT = 0x4,
+	ADC_ACTIVE_BIT = 0x8,
+	DAC_INTR_PENDING_BIT = 0x10,
+	ADC_INTR_PENDING_BIT = 0x20,
+	DAC_DONE_BIT = 0x40,
+	ADC_DONE_BIT = 0x80,
+	EXT_INTR_PENDING_BIT = 0x100,
+	ADC_STOP_BIT = 0x200,
+};
+static inline uint16_t pipe_full_bits(uint16_t hw_status_bits)
+{
+	return (hw_status_bits >> 10) & 0x3;
+};
+
+static inline unsigned int dma_chain_flag_bits(uint16_t prepost_bits)
+{
+	return (prepost_bits >> 6) & 0x3;
+}
+static inline unsigned int adc_upper_read_ptr_code(uint16_t prepost_bits)
+{
+	return (prepost_bits >> 12) & 0x3;
+}
+static inline unsigned int adc_upper_write_ptr_code(uint16_t prepost_bits)
+{
+	return (prepost_bits >> 14) & 0x3;
+}
+
+// I2C addresses for 4020
+enum i2c_addresses {
+	RANGE_CAL_I2C_ADDR = 0x20,
+	CALDAC0_I2C_ADDR = 0xc,
+	CALDAC1_I2C_ADDR = 0xd,
+};
+
+enum range_cal_i2c_contents {
+	ADC_SRC_4020_MASK = 0x70,	// bits that set what source the adc converter measures
+	BNC_TRIG_THRESHOLD_0V_BIT = 0x80,	// make bnc trig/ext clock threshold 0V instead of 2.5V
+};
+static inline uint8_t adc_src_4020_bits(unsigned int source)
+{
+	return (source << 4) & ADC_SRC_4020_MASK;
+};
+static inline uint8_t attenuate_bit(unsigned int channel)
+{
+	// attenuate channel (+-5V input range)
+	return 1 << (channel & 0x3);
+};
+
+// analog input ranges for 64xx boards
+static const comedi_lrange ai_ranges_64xx = {
+	8,
+	{
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25),
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2.5),
+			UNI_RANGE(1.25)
+		}
+};
+
+/* analog input ranges for 60xx boards */
+static const comedi_lrange ai_ranges_60xx = {
+	4,
+	{
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(0.5),
+			BIP_RANGE(0.05),
+		}
+};
+
+/* analog input ranges for 6030, etc boards */
+static const comedi_lrange ai_ranges_6030 = {
+	14,
+	{
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(2),
+			BIP_RANGE(1),
+			BIP_RANGE(0.5),
+			BIP_RANGE(0.2),
+			BIP_RANGE(0.1),
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2),
+			UNI_RANGE(1),
+			UNI_RANGE(0.5),
+			UNI_RANGE(0.2),
+			UNI_RANGE(0.1),
+		}
+};
+
+/* analog input ranges for 6052, etc boards */
+static const comedi_lrange ai_ranges_6052 = {
+	15,
+	{
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1),
+			BIP_RANGE(0.5),
+			BIP_RANGE(0.25),
+			BIP_RANGE(0.1),
+			BIP_RANGE(0.05),
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2),
+			UNI_RANGE(1),
+			UNI_RANGE(0.5),
+			UNI_RANGE(0.2),
+			UNI_RANGE(0.1),
+		}
+};
+
+// analog input ranges for 4020 board
+static const comedi_lrange ai_ranges_4020 = {
+	2,
+	{
+			BIP_RANGE(5),
+			BIP_RANGE(1),
+		}
+};
+
+// analog output ranges
+static const comedi_lrange ao_ranges_64xx = {
+	4,
+	{
+			BIP_RANGE(5),
+			BIP_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(10),
+		}
+};
+static const int ao_range_code_64xx[] = {
+	0x0,
+	0x1,
+	0x2,
+	0x3,
+};
+
+static const comedi_lrange ao_ranges_60xx = {
+	1,
+	{
+			BIP_RANGE(10),
+		}
+};
+static const int ao_range_code_60xx[] = {
+	0x0,
+};
+
+static const comedi_lrange ao_ranges_6030 = {
+	2,
+	{
+			BIP_RANGE(10),
+			UNI_RANGE(10),
+		}
+};
+static const int ao_range_code_6030[] = {
+	0x0,
+	0x2,
+};
+
+static const comedi_lrange ao_ranges_4020 = {
+	2,
+	{
+			BIP_RANGE(5),
+			BIP_RANGE(10),
+		}
+};
+static const int ao_range_code_4020[] = {
+	0x1,
+	0x0,
+};
+
+enum register_layout {
+	LAYOUT_60XX,
+	LAYOUT_64XX,
+	LAYOUT_4020,
+};
+
+typedef struct hw_fifo_info_struct {
+	unsigned int num_segments;
+	unsigned int max_segment_length;
+	unsigned int sample_packing_ratio;
+	uint16_t fifo_size_reg_mask;
+} hw_fifo_info_t;
+
+typedef struct pcidas64_board_struct {
+	const char *name;
+	int device_id;		// pci device id
+	int ai_se_chans;	// number of ai inputs in single-ended mode
+	int ai_bits;		// analog input resolution
+	int ai_speed;		// fastest conversion period in ns
+	const comedi_lrange *ai_range_table;
+	int ao_nchan;		// number of analog out channels
+	int ao_bits;		// analog output resolution
+	int ao_scan_speed;	// analog output speed (for a scan, not conversion)
+	const comedi_lrange *ao_range_table;
+	const int *ao_range_code;
+	const hw_fifo_info_t *const ai_fifo;
+	enum register_layout layout;	// different board families have slightly different registers
+	unsigned has_8255:1;
+} pcidas64_board;
+
+static const hw_fifo_info_t ai_fifo_4020 = {
+      num_segments:2,
+      max_segment_length:0x8000,
+      sample_packing_ratio:2,
+      fifo_size_reg_mask:0x7f,
+};
+
+static const hw_fifo_info_t ai_fifo_64xx = {
+      num_segments:4,
+      max_segment_length:0x800,
+      sample_packing_ratio:1,
+      fifo_size_reg_mask:0x3f,
+};
+
+static const hw_fifo_info_t ai_fifo_60xx = {
+      num_segments:4,
+      max_segment_length:0x800,
+      sample_packing_ratio:1,
+      fifo_size_reg_mask:0x7f,
+};
+
+/* maximum number of dma transfers we will chain together into a ring
+ * (and the maximum number of dma buffers we maintain) */
+#define MAX_AI_DMA_RING_COUNT (0x80000 / DMA_BUFFER_SIZE)
+#define MIN_AI_DMA_RING_COUNT (0x10000 / DMA_BUFFER_SIZE)
+#define AO_DMA_RING_COUNT (0x10000 / DMA_BUFFER_SIZE)
+static inline unsigned int ai_dma_ring_count(pcidas64_board * board)
+{
+	if (board->layout == LAYOUT_4020)
+		return MAX_AI_DMA_RING_COUNT;
+	else
+		return MIN_AI_DMA_RING_COUNT;
+}
+
+static const int bytes_in_sample = 2;
+
+static const pcidas64_board pcidas64_boards[] = {
+	{
+	      name:	"pci-das6402/16",
+	      device_id:0x1d,
+	      ai_se_chans:64,
+	      ai_bits:	16,
+	      ai_speed:5000,
+	      ao_nchan:2,
+	      ao_bits:	16,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_64XX,
+	      ai_range_table:&ai_ranges_64xx,
+	      ao_range_table:&ao_ranges_64xx,
+	      ao_range_code:ao_range_code_64xx,
+	      ai_fifo:	&ai_fifo_64xx,
+	      has_8255:1,
+		},
+	{
+	      name:	"pci-das6402/12",	// XXX check
+	      device_id:0x1e,
+	      ai_se_chans:64,
+	      ai_bits:	12,
+	      ai_speed:5000,
+	      ao_nchan:2,
+	      ao_bits:	12,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_64XX,
+	      ai_range_table:&ai_ranges_64xx,
+	      ao_range_table:&ao_ranges_64xx,
+	      ao_range_code:ao_range_code_64xx,
+	      ai_fifo:	&ai_fifo_64xx,
+	      has_8255:1,
+		},
+	{
+	      name:	"pci-das64/m1/16",
+	      device_id:0x35,
+	      ai_se_chans:64,
+	      ai_bits:	16,
+	      ai_speed:1000,
+	      ao_nchan:2,
+	      ao_bits:	16,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_64XX,
+	      ai_range_table:&ai_ranges_64xx,
+	      ao_range_table:&ao_ranges_64xx,
+	      ao_range_code:ao_range_code_64xx,
+	      ai_fifo:	&ai_fifo_64xx,
+	      has_8255:1,
+		},
+	{
+	      name:	"pci-das64/m2/16",
+	      device_id:0x36,
+	      ai_se_chans:64,
+	      ai_bits:	16,
+	      ai_speed:500,
+	      ao_nchan:2,
+	      ao_bits:	16,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_64XX,
+	      ai_range_table:&ai_ranges_64xx,
+	      ao_range_table:&ao_ranges_64xx,
+	      ao_range_code:ao_range_code_64xx,
+	      ai_fifo:	&ai_fifo_64xx,
+	      has_8255:1,
+		},
+	{
+	      name:	"pci-das64/m3/16",
+	      device_id:0x37,
+	      ai_se_chans:64,
+	      ai_bits:	16,
+	      ai_speed:333,
+	      ao_nchan:2,
+	      ao_bits:	16,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_64XX,
+	      ai_range_table:&ai_ranges_64xx,
+	      ao_range_table:&ao_ranges_64xx,
+	      ao_range_code:ao_range_code_64xx,
+	      ai_fifo:	&ai_fifo_64xx,
+	      has_8255:1,
+		},
+	{
+		.name = "pci-das6013",
+		.device_id = 0x78,
+		.ai_se_chans = 16,
+		.ai_bits = 16,
+		.ai_speed = 5000,
+		.ao_nchan = 0,
+		.ao_bits = 16,
+		.layout = LAYOUT_60XX,
+		.ai_range_table = &ai_ranges_60xx,
+		.ao_range_table = &ao_ranges_60xx,
+		.ao_range_code = ao_range_code_60xx,
+		.ai_fifo = &ai_fifo_60xx,
+		.has_8255 = 0,
+		},
+	{
+	      name:	"pci-das6014",
+	      device_id:0x79,
+	      ai_se_chans:16,
+	      ai_bits:	16,
+	      ai_speed:5000,
+	      ao_nchan:2,
+	      ao_bits:	16,
+	      ao_scan_speed:100000,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_60xx,
+	      ao_range_table:&ao_ranges_60xx,
+	      ao_range_code:ao_range_code_60xx,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:0,
+		},
+	{
+	      name:	"pci-das6023",
+	      device_id:0x5d,
+	      ai_se_chans:16,
+	      ai_bits:	12,
+	      ai_speed:5000,
+	      ao_nchan:0,
+	      ao_scan_speed:100000,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_60xx,
+	      ao_range_table:&ao_ranges_60xx,
+	      ao_range_code:ao_range_code_60xx,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:1,
+		},
+	{
+	      name:	"pci-das6025",
+	      device_id:0x5e,
+	      ai_se_chans:16,
+	      ai_bits:	12,
+	      ai_speed:5000,
+	      ao_nchan:2,
+	      ao_bits:	12,
+	      ao_scan_speed:100000,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_60xx,
+	      ao_range_table:&ao_ranges_60xx,
+	      ao_range_code:ao_range_code_60xx,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:1,
+		},
+	{
+	      name:	"pci-das6030",
+	      device_id:0x5f,
+	      ai_se_chans:16,
+	      ai_bits:	16,
+	      ai_speed:10000,
+	      ao_nchan:2,
+	      ao_bits:	16,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_6030,
+	      ao_range_table:&ao_ranges_6030,
+	      ao_range_code:ao_range_code_6030,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:0,
+		},
+	{
+	      name:	"pci-das6031",
+	      device_id:0x60,
+	      ai_se_chans:64,
+	      ai_bits:	16,
+	      ai_speed:10000,
+	      ao_nchan:2,
+	      ao_bits:	16,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_6030,
+	      ao_range_table:&ao_ranges_6030,
+	      ao_range_code:ao_range_code_6030,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:0,
+		},
+	{
+	      name:	"pci-das6032",
+	      device_id:0x61,
+	      ai_se_chans:16,
+	      ai_bits:	16,
+	      ai_speed:10000,
+	      ao_nchan:0,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_6030,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:0,
+		},
+	{
+	      name:	"pci-das6033",
+	      device_id:0x62,
+	      ai_se_chans:64,
+	      ai_bits:	16,
+	      ai_speed:10000,
+	      ao_nchan:0,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_6030,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:0,
+		},
+	{
+	      name:	"pci-das6034",
+	      device_id:0x63,
+	      ai_se_chans:16,
+	      ai_bits:	16,
+	      ai_speed:5000,
+	      ao_nchan:0,
+	      ao_scan_speed:0,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_60xx,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:0,
+		},
+	{
+	      name:	"pci-das6035",
+	      device_id:0x64,
+	      ai_se_chans:16,
+	      ai_bits:	16,
+	      ai_speed:5000,
+	      ao_nchan:2,
+	      ao_bits:	12,
+	      ao_scan_speed:100000,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_60xx,
+	      ao_range_table:&ao_ranges_60xx,
+	      ao_range_code:ao_range_code_60xx,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:0,
+		},
+	{
+	      name:	"pci-das6036",
+	      device_id:0x6f,
+	      ai_se_chans:16,
+	      ai_bits:	16,
+	      ai_speed:5000,
+	      ao_nchan:2,
+	      ao_bits:	16,
+	      ao_scan_speed:100000,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_60xx,
+	      ao_range_table:&ao_ranges_60xx,
+	      ao_range_code:ao_range_code_60xx,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:0,
+		},
+	{
+	      name:	"pci-das6040",
+	      device_id:0x65,
+	      ai_se_chans:16,
+	      ai_bits:	12,
+	      ai_speed:2000,
+	      ao_nchan:2,
+	      ao_bits:	12,
+	      ao_scan_speed:1000,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_6052,
+	      ao_range_table:&ao_ranges_6030,
+	      ao_range_code:ao_range_code_6030,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:0,
+		},
+	{
+	      name:	"pci-das6052",
+	      device_id:0x66,
+	      ai_se_chans:16,
+	      ai_bits:	16,
+	      ai_speed:3333,
+	      ao_nchan:2,
+	      ao_bits:	16,
+	      ao_scan_speed:3333,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_6052,
+	      ao_range_table:&ao_ranges_6030,
+	      ao_range_code:ao_range_code_6030,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:0,
+		},
+	{
+	      name:	"pci-das6070",
+	      device_id:0x67,
+	      ai_se_chans:16,
+	      ai_bits:	12,
+	      ai_speed:800,
+	      ao_nchan:2,
+	      ao_bits:	12,
+	      ao_scan_speed:1000,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_6052,
+	      ao_range_table:&ao_ranges_6030,
+	      ao_range_code:ao_range_code_6030,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:0,
+		},
+	{
+	      name:	"pci-das6071",
+	      device_id:0x68,
+	      ai_se_chans:64,
+	      ai_bits:	12,
+	      ai_speed:800,
+	      ao_nchan:2,
+	      ao_bits:	12,
+	      ao_scan_speed:1000,
+	      layout:	LAYOUT_60XX,
+	      ai_range_table:&ai_ranges_6052,
+	      ao_range_table:&ao_ranges_6030,
+	      ao_range_code:ao_range_code_6030,
+	      ai_fifo:	&ai_fifo_60xx,
+	      has_8255:0,
+		},
+	{
+	      name:	"pci-das4020/12",
+	      device_id:0x52,
+	      ai_se_chans:4,
+	      ai_bits:	12,
+	      ai_speed:50,
+	      ao_bits:	12,
+	      ao_nchan:2,
+	      ao_scan_speed:0,	// no hardware pacing on ao
+	      layout:	LAYOUT_4020,
+	      ai_range_table:&ai_ranges_4020,
+	      ao_range_table:&ao_ranges_4020,
+	      ao_range_code:ao_range_code_4020,
+	      ai_fifo:	&ai_fifo_4020,
+	      has_8255:1,
+		},
+#if 0
+	{
+	      name:	"pci-das6402/16/jr",
+	      device_id:0	// XXX,
+	      ai_se_chans:64,
+	      ai_bits:	16,
+	      ai_speed:5000,
+	      ao_nchan:0,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_64XX,
+	      ai_range_table:&ai_ranges_64xx,
+	      ai_fifo:	ai_fifo_64xx,
+	      has_8255:1,
+		},
+	{
+	      name:	"pci-das64/m1/16/jr",
+	      device_id:0	// XXX,
+	      ai_se_chans:64,
+	      ai_bits:	16,
+	      ai_speed:1000,
+	      ao_nchan:0,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_64XX,
+	      ai_range_table:&ai_ranges_64xx,
+	      ai_fifo:	ai_fifo_64xx,
+	      has_8255:1,
+		},
+	{
+	      name:	"pci-das64/m2/16/jr",
+	      device_id:0	// XXX,
+	      ai_se_chans:64,
+	      ai_bits:	16,
+	      ai_speed:500,
+	      ao_nchan:0,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_64XX,
+	      ai_range_table:&ai_ranges_64xx,
+	      ai_fifo:	ai_fifo_64xx,
+	      has_8255:1,
+		},
+	{
+	      name:	"pci-das64/m3/16/jr",
+	      device_id:0	// XXX,
+	      ai_se_chans:64,
+	      ai_bits:	16,
+	      ai_speed:333,
+	      ao_nchan:0,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_64XX,
+	      ai_range_table:&ai_ranges_64xx,
+	      ai_fifo:	ai_fifo_64xx,
+	      has_8255:1,
+		},
+	{
+	      name:	"pci-das64/m1/14",
+	      device_id:0,	// XXX
+	      ai_se_chans:64,
+	      ai_bits:	14,
+	      ai_speed:1000,
+	      ao_nchan:2,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_64XX,
+	      ai_range_table:&ai_ranges_64xx,
+	      ai_fifo:	ai_fifo_64xx,
+	      has_8255:1,
+		},
+	{
+	      name:	"pci-das64/m2/14",
+	      device_id:0,	// XXX
+	      ai_se_chans:64,
+	      ai_bits:	14,
+	      ai_speed:500,
+	      ao_nchan:2,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_64XX,
+	      ai_range_table:&ai_ranges_64xx,
+	      ai_fifo:	ai_fifo_64xx,
+	      has_8255:1,
+		},
+	{
+	      name:	"pci-das64/m3/14",
+	      device_id:0,	// XXX
+	      ai_se_chans:64,
+	      ai_bits:	14,
+	      ai_speed:333,
+	      ao_nchan:2,
+	      ao_scan_speed:10000,
+	      layout:	LAYOUT_64XX,
+	      ai_range_table:&ai_ranges_64xx,
+	      ai_fifo:	ai_fifo_64xx,
+	      has_8255:1,
+		},
+#endif
+};
+
+// Number of boards in cb_pcidas_boards
+static inline unsigned int num_boards(void)
+{
+	return sizeof(pcidas64_boards) / sizeof(pcidas64_board);
+}
+
+static DEFINE_PCI_DEVICE_TABLE(pcidas64_pci_table) = {
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x001d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x001e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0035, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0036, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0037, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0052, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x005d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x005e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x005f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0061, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0062, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0063, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0064, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0066, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0067, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0068, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x006f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0078, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0079, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, pcidas64_pci_table);
+
+static inline pcidas64_board *board(const comedi_device * dev)
+{
+	return (pcidas64_board *) dev->board_ptr;
+}
+
+static inline unsigned short se_diff_bit_6xxx(comedi_device * dev,
+	int use_differential)
+{
+	if ((board(dev)->layout == LAYOUT_64XX && !use_differential) ||
+		(board(dev)->layout == LAYOUT_60XX && use_differential))
+		return ADC_SE_DIFF_BIT;
+	else
+		return 0;
+};
+
+struct ext_clock_info {
+	unsigned int divisor;	// master clock divisor to use for scans with external master clock
+	unsigned int chanspec;	// chanspec for master clock input when used as scan begin src
+};
+
+/* this structure is for data unique to this hardware driver. */
+typedef struct {
+	struct pci_dev *hw_dev;	// pointer to board's pci_dev struct
+	// base addresses (physical)
+	resource_size_t plx9080_phys_iobase;
+	resource_size_t main_phys_iobase;
+	resource_size_t dio_counter_phys_iobase;
+	// base addresses (ioremapped)
+	void *plx9080_iobase;
+	void *main_iobase;
+	void *dio_counter_iobase;
+	// local address (used by dma controller)
+	uint32_t local0_iobase;
+	uint32_t local1_iobase;
+	volatile unsigned int ai_count;	// number of analog input samples remaining
+	uint16_t *ai_buffer[MAX_AI_DMA_RING_COUNT];	// dma buffers for analog input
+	dma_addr_t ai_buffer_bus_addr[MAX_AI_DMA_RING_COUNT];	// physical addresses of ai dma buffers
+	struct plx_dma_desc *ai_dma_desc;	// array of ai dma descriptors read by plx9080, allocated to get proper alignment
+	dma_addr_t ai_dma_desc_bus_addr;	// physical address of ai dma descriptor array
+	volatile unsigned int ai_dma_index;	// index of the ai dma descriptor/buffer that is currently being used
+	uint16_t *ao_buffer[AO_DMA_RING_COUNT];	// dma buffers for analog output
+	dma_addr_t ao_buffer_bus_addr[AO_DMA_RING_COUNT];	// physical addresses of ao dma buffers
+	struct plx_dma_desc *ao_dma_desc;
+	dma_addr_t ao_dma_desc_bus_addr;
+	volatile unsigned int ao_dma_index;	// keeps track of buffer where the next ao sample should go
+	volatile unsigned long ao_count;	// number of analog output samples remaining
+	volatile unsigned int ao_value[2];	// remember what the analog outputs are set to, to allow readback
+	unsigned int hw_revision;	// stc chip hardware revision number
+	volatile unsigned int intr_enable_bits;	// last bits sent to INTR_ENABLE_REG register
+	volatile uint16_t adc_control1_bits;	// last bits sent to ADC_CONTROL1_REG register
+	volatile uint16_t fifo_size_bits;	// last bits sent to FIFO_SIZE_REG register
+	volatile uint16_t hw_config_bits;	// last bits sent to HW_CONFIG_REG register
+	volatile uint16_t dac_control1_bits;
+	volatile uint32_t plx_control_bits;	// last bits written to plx9080 control register
+	volatile uint32_t plx_intcsr_bits;	// last bits written to plx interrupt control and status register
+	volatile int calibration_source;	// index of calibration source readable through ai ch0
+	volatile uint8_t i2c_cal_range_bits;	// bits written to i2c calibration/range register
+	volatile unsigned int ext_trig_falling;	// configure digital triggers to trigger on falling edge
+	// states of various devices stored to enable read-back
+	unsigned int ad8402_state[2];
+	unsigned int caldac_state[8];
+	volatile short ai_cmd_running;
+	unsigned int ai_fifo_segment_length;
+	struct ext_clock_info ext_clock;
+	sampl_t ao_bounce_buffer[DAC_FIFO_SIZE];
+} pcidas64_private;
+
+/* inline function that makes it easier to
+ * access the private structure.
+ */
+static inline pcidas64_private *priv(comedi_device * dev)
+{
+	return dev->private;
+}
+
+/*
+ * The comedi_driver structure tells the Comedi core module
+ * which functions to call to configure/deconfigure (attach/detach)
+ * the board, and also about the kernel module that contains
+ * the device code.
+ */
+static int attach(comedi_device * dev, comedi_devconfig * it);
+static int detach(comedi_device * dev);
+static comedi_driver driver_cb_pcidas = {
+      driver_name:"cb_pcidas64",
+      module:THIS_MODULE,
+      attach:attach,
+      detach:detach,
+};
+
+static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ai_cmd(comedi_device * dev, comedi_subdevice * s);
+static int ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int ao_cmd(comedi_device * dev, comedi_subdevice * s);
+static int ao_inttrig(comedi_device * dev, comedi_subdevice * subdev,
+	unsigned int trig_num);
+static int ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG);
+static int ai_cancel(comedi_device * dev, comedi_subdevice * s);
+static int ao_cancel(comedi_device * dev, comedi_subdevice * s);
+static int dio_callback(int dir, int port, int data, unsigned long arg);
+static int dio_callback_4020(int dir, int port, int data, unsigned long arg);
+static int di_rbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int do_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int dio_60xx_config_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int dio_60xx_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int calib_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int calib_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ad8402_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static void ad8402_write(comedi_device * dev, unsigned int channel,
+	unsigned int value);
+static int ad8402_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static void check_adc_timing(comedi_device * dev, comedi_cmd * cmd);
+static unsigned int get_divisor(unsigned int ns, unsigned int flags);
+static void i2c_write(comedi_device * dev, unsigned int address,
+	const uint8_t * data, unsigned int length);
+static void caldac_write(comedi_device * dev, unsigned int channel,
+	unsigned int value);
+static int caldac_8800_write(comedi_device * dev, unsigned int address,
+	uint8_t value);
+//static int dac_1590_write(comedi_device *dev, unsigned int dac_a, unsigned int dac_b);
+static int caldac_i2c_write(comedi_device * dev, unsigned int caldac_channel,
+	unsigned int value);
+static void abort_dma(comedi_device * dev, unsigned int channel);
+static void disable_plx_interrupts(comedi_device * dev);
+static int set_ai_fifo_size(comedi_device * dev, unsigned int num_samples);
+static unsigned int ai_fifo_size(comedi_device * dev);
+static int set_ai_fifo_segment_length(comedi_device * dev,
+	unsigned int num_entries);
+static void disable_ai_pacing(comedi_device * dev);
+static void disable_ai_interrupts(comedi_device * dev);
+static void enable_ai_interrupts(comedi_device * dev, const comedi_cmd * cmd);
+static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags);
+static void load_ao_dma(comedi_device * dev, const comedi_cmd * cmd);
+
+COMEDI_PCI_INITCLEANUP(driver_cb_pcidas, pcidas64_pci_table);
+
+static unsigned int ai_range_bits_6xxx(const comedi_device * dev,
+	unsigned int range_index)
+{
+	const comedi_krange *range =
+		&board(dev)->ai_range_table->range[range_index];
+	unsigned int bits = 0;
+
+	switch (range->max) {
+	case 10000000:
+		bits = 0x000;
+		break;
+	case 5000000:
+		bits = 0x100;
+		break;
+	case 2000000:
+	case 2500000:
+		bits = 0x200;
+		break;
+	case 1000000:
+	case 1250000:
+		bits = 0x300;
+		break;
+	case 500000:
+		bits = 0x400;
+		break;
+	case 200000:
+	case 250000:
+		bits = 0x500;
+		break;
+	case 100000:
+		bits = 0x600;
+		break;
+	case 50000:
+		bits = 0x700;
+		break;
+	default:
+		comedi_error(dev, "bug! in ai_range_bits_6xxx");
+		break;
+	}
+	if (range->min == 0)
+		bits += 0x900;
+	return bits;
+}
+
+static unsigned int hw_revision(const comedi_device * dev,
+	uint16_t hw_status_bits)
+{
+	if (board(dev)->layout == LAYOUT_4020)
+		return (hw_status_bits >> 13) & 0x7;
+
+	return (hw_status_bits >> 12) & 0xf;
+}
+
+static void set_dac_range_bits(comedi_device * dev, volatile uint16_t * bits,
+	unsigned int channel, unsigned int range)
+{
+	unsigned int code = board(dev)->ao_range_code[range];
+
+	if (channel > 1)
+		comedi_error(dev, "bug! bad channel?");
+	if (code & ~0x3)
+		comedi_error(dev, "bug! bad range code?");
+
+	*bits &= ~(0x3 << (2 * channel));
+	*bits |= code << (2 * channel);
+};
+
+static inline int ao_cmd_is_supported(const pcidas64_board * board)
+{
+	return board->ao_nchan && board->layout != LAYOUT_4020;
+}
+
+// initialize plx9080 chip
+static void init_plx9080(comedi_device * dev)
+{
+	uint32_t bits;
+	void *plx_iobase = priv(dev)->plx9080_iobase;
+
+	priv(dev)->plx_control_bits =
+		readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG);
+
+	// plx9080 dump
+	DEBUG_PRINT(" plx interrupt status 0x%x\n",
+		readl(plx_iobase + PLX_INTRCS_REG));
+	DEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));
+	DEBUG_PRINT(" plx control reg 0x%x\n", priv(dev)->plx_control_bits);
+	DEBUG_PRINT(" plx mode/arbitration reg 0x%x\n",
+		readl(plx_iobase + PLX_MARB_REG));
+	DEBUG_PRINT(" plx region0 reg 0x%x\n",
+		readl(plx_iobase + PLX_REGION0_REG));
+	DEBUG_PRINT(" plx region1 reg 0x%x\n",
+		readl(plx_iobase + PLX_REGION1_REG));
+
+	DEBUG_PRINT(" plx revision 0x%x\n",
+		readl(plx_iobase + PLX_REVISION_REG));
+	DEBUG_PRINT(" plx dma channel 0 mode 0x%x\n",
+		readl(plx_iobase + PLX_DMA0_MODE_REG));
+	DEBUG_PRINT(" plx dma channel 1 mode 0x%x\n",
+		readl(plx_iobase + PLX_DMA1_MODE_REG));
+	DEBUG_PRINT(" plx dma channel 0 pci address 0x%x\n",
+		readl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));
+	DEBUG_PRINT(" plx dma channel 0 local address 0x%x\n",
+		readl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));
+	DEBUG_PRINT(" plx dma channel 0 transfer size 0x%x\n",
+		readl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));
+	DEBUG_PRINT(" plx dma channel 0 descriptor 0x%x\n",
+		readl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));
+	DEBUG_PRINT(" plx dma channel 0 command status 0x%x\n",
+		readb(plx_iobase + PLX_DMA0_CS_REG));
+	DEBUG_PRINT(" plx dma channel 0 threshold 0x%x\n",
+		readl(plx_iobase + PLX_DMA0_THRESHOLD_REG));
+	DEBUG_PRINT(" plx bigend 0x%x\n", readl(plx_iobase + PLX_BIGEND_REG));
+
+#ifdef __BIG_ENDIAN
+	bits = BIGEND_DMA0 | BIGEND_DMA1;
+#else
+	bits = 0;
+#endif
+	writel(bits, priv(dev)->plx9080_iobase + PLX_BIGEND_REG);
+
+	disable_plx_interrupts(dev);
+
+	abort_dma(dev, 0);
+	abort_dma(dev, 1);
+
+	// configure dma0 mode
+	bits = 0;
+	// enable ready input, not sure if this is necessary
+	bits |= PLX_DMA_EN_READYIN_BIT;
+	// enable bterm, not sure if this is necessary
+	bits |= PLX_EN_BTERM_BIT;
+	// enable dma chaining
+	bits |= PLX_EN_CHAIN_BIT;
+	// enable interrupt on dma done (probably don't need this, since chain never finishes)
+	bits |= PLX_EN_DMA_DONE_INTR_BIT;
+	// don't increment local address during transfers (we are transferring from a fixed fifo register)
+	bits |= PLX_LOCAL_ADDR_CONST_BIT;
+	// route dma interrupt to pci bus
+	bits |= PLX_DMA_INTR_PCI_BIT;
+	// enable demand mode
+	bits |= PLX_DEMAND_MODE_BIT;
+	// enable local burst mode
+	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
+	// 4020 uses 32 bit dma
+	if (board(dev)->layout == LAYOUT_4020) {
+		bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
+	} else {		// localspace0 bus is 16 bits wide
+		bits |= PLX_LOCAL_BUS_16_WIDE_BITS;
+	}
+	writel(bits, plx_iobase + PLX_DMA1_MODE_REG);
+	if (ao_cmd_is_supported(board(dev)))
+		writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
+
+	// enable interrupts on plx 9080
+	priv(dev)->plx_intcsr_bits |=
+		ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
+		ICS_DMA0_E | ICS_DMA1_E;
+	writel(priv(dev)->plx_intcsr_bits,
+		priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+}
+
+/* Allocate and initialize the subdevice structures.
+ */
+static int setup_subdevices(comedi_device * dev)
+{
+	comedi_subdevice *s;
+	void *dio_8255_iobase;
+	int i;
+
+	if (alloc_subdevices(dev, 10) < 0)
+		return -ENOMEM;
+
+	s = dev->subdevices + 0;
+	/* analog input subdevice */
+	dev->read_subdev = s;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DITHER | SDF_CMD_READ;
+	if (board(dev)->layout == LAYOUT_60XX)
+		s->subdev_flags |= SDF_COMMON | SDF_DIFF;
+	else if (board(dev)->layout == LAYOUT_64XX)
+		s->subdev_flags |= SDF_DIFF;
+	/* XXX Number of inputs in differential mode is ignored */
+	s->n_chan = board(dev)->ai_se_chans;
+	s->len_chanlist = 0x2000;
+	s->maxdata = (1 << board(dev)->ai_bits) - 1;
+	s->range_table = board(dev)->ai_range_table;
+	s->insn_read = ai_rinsn;
+	s->insn_config = ai_config_insn;
+	s->do_cmd = ai_cmd;
+	s->do_cmdtest = ai_cmdtest;
+	s->cancel = ai_cancel;
+	if (board(dev)->layout == LAYOUT_4020) {
+		unsigned int i;
+		uint8_t data;
+		// set adc to read from inputs (not internal calibration sources)
+		priv(dev)->i2c_cal_range_bits = adc_src_4020_bits(4);
+		// set channels to +-5 volt input ranges
+		for (i = 0; i < s->n_chan; i++)
+			priv(dev)->i2c_cal_range_bits |= attenuate_bit(i);
+		data = priv(dev)->i2c_cal_range_bits;
+		i2c_write(dev, RANGE_CAL_I2C_ADDR, &data, sizeof(data));
+	}
+
+	/* analog output subdevice */
+	s = dev->subdevices + 1;
+	if (board(dev)->ao_nchan) {
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags =
+			SDF_READABLE | SDF_WRITABLE | SDF_GROUND |
+			SDF_CMD_WRITE;
+		s->n_chan = board(dev)->ao_nchan;
+		s->maxdata = (1 << board(dev)->ao_bits) - 1;
+		s->range_table = board(dev)->ao_range_table;
+		s->insn_read = ao_readback_insn;
+		s->insn_write = ao_winsn;
+		if (ao_cmd_is_supported(board(dev))) {
+			dev->write_subdev = s;
+			s->do_cmdtest = ao_cmdtest;
+			s->do_cmd = ao_cmd;
+			s->len_chanlist = board(dev)->ao_nchan;
+			s->cancel = ao_cancel;
+		}
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	// digital input
+	s = dev->subdevices + 2;
+	if (board(dev)->layout == LAYOUT_64XX) {
+		s->type = COMEDI_SUBD_DI;
+		s->subdev_flags = SDF_READABLE;
+		s->n_chan = 4;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->insn_bits = di_rbits;
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	// digital output
+	if (board(dev)->layout == LAYOUT_64XX) {
+		s = dev->subdevices + 3;
+		s->type = COMEDI_SUBD_DO;
+		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+		s->n_chan = 4;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->insn_bits = do_wbits;
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	/* 8255 */
+	s = dev->subdevices + 4;
+	if (board(dev)->has_8255) {
+		if (board(dev)->layout == LAYOUT_4020) {
+			dio_8255_iobase =
+				priv(dev)->main_iobase + I8255_4020_REG;
+			subdev_8255_init(dev, s, dio_callback_4020,
+				(unsigned long)dio_8255_iobase);
+		} else {
+			dio_8255_iobase =
+				priv(dev)->dio_counter_iobase + DIO_8255_OFFSET;
+			subdev_8255_init(dev, s, dio_callback,
+				(unsigned long)dio_8255_iobase);
+		}
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	// 8 channel dio for 60xx
+	s = dev->subdevices + 5;
+	if (board(dev)->layout == LAYOUT_60XX) {
+		s->type = COMEDI_SUBD_DIO;
+		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+		s->n_chan = 8;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->insn_config = dio_60xx_config_insn;
+		s->insn_bits = dio_60xx_wbits;
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	// caldac
+	s = dev->subdevices + 6;
+	s->type = COMEDI_SUBD_CALIB;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+	s->n_chan = 8;
+	if (board(dev)->layout == LAYOUT_4020)
+		s->maxdata = 0xfff;
+	else
+		s->maxdata = 0xff;
+	s->insn_read = calib_read_insn;
+	s->insn_write = calib_write_insn;
+	for (i = 0; i < s->n_chan; i++)
+		caldac_write(dev, i, s->maxdata / 2);
+
+	// 2 channel ad8402 potentiometer
+	s = dev->subdevices + 7;
+	if (board(dev)->layout == LAYOUT_64XX) {
+		s->type = COMEDI_SUBD_CALIB;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+		s->n_chan = 2;
+		s->insn_read = ad8402_read_insn;
+		s->insn_write = ad8402_write_insn;
+		s->maxdata = 0xff;
+		for (i = 0; i < s->n_chan; i++)
+			ad8402_write(dev, i, s->maxdata / 2);
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	//serial EEPROM, if present
+	s = dev->subdevices + 8;
+	if (readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG) & CTL_EECHK) {
+		s->type = COMEDI_SUBD_MEMORY;
+		s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
+		s->n_chan = 128;
+		s->maxdata = 0xffff;
+		s->insn_read = eeprom_read_insn;
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	// user counter subd XXX
+	s = dev->subdevices + 9;
+	s->type = COMEDI_SUBD_UNUSED;
+
+	return 0;
+}
+
+static void disable_plx_interrupts(comedi_device * dev)
+{
+	priv(dev)->plx_intcsr_bits = 0;
+	writel(priv(dev)->plx_intcsr_bits,
+		priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+}
+
+static void init_stc_registers(comedi_device * dev)
+{
+	uint16_t bits;
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+
+	// bit should be set for 6025, although docs say boards with <= 16 chans should be cleared XXX
+	if (1)
+		priv(dev)->adc_control1_bits |= ADC_QUEUE_CONFIG_BIT;
+	writew(priv(dev)->adc_control1_bits,
+		priv(dev)->main_iobase + ADC_CONTROL1_REG);
+
+	// 6402/16 manual says this register must be initialized to 0xff?
+	writew(0xff, priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
+
+	bits = SLOW_DAC_BIT | DMA_CH_SELECT_BIT;
+	if (board(dev)->layout == LAYOUT_4020)
+		bits |= INTERNAL_CLOCK_4020_BITS;
+	priv(dev)->hw_config_bits |= bits;
+	writew(priv(dev)->hw_config_bits,
+		priv(dev)->main_iobase + HW_CONFIG_REG);
+
+	writew(0, priv(dev)->main_iobase + DAQ_SYNC_REG);
+	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
+
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	// set fifos to maximum size
+	priv(dev)->fifo_size_bits |= DAC_FIFO_BITS;
+	set_ai_fifo_segment_length(dev,
+		board(dev)->ai_fifo->max_segment_length);
+
+	priv(dev)->dac_control1_bits = DAC_OUTPUT_ENABLE_BIT;
+	priv(dev)->intr_enable_bits =	/* EN_DAC_INTR_SRC_BIT | DAC_INTR_QEMPTY_BITS | */
+		EN_DAC_DONE_INTR_BIT | EN_DAC_UNDERRUN_BIT;
+	writew(priv(dev)->intr_enable_bits,
+		priv(dev)->main_iobase + INTR_ENABLE_REG);
+
+	disable_ai_pacing(dev);
+};
+
+int alloc_and_init_dma_members(comedi_device * dev)
+{
+	int i;
+
+	// alocate pci dma buffers
+	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
+		priv(dev)->ai_buffer[i] =
+			pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
+			&priv(dev)->ai_buffer_bus_addr[i]);
+		if (priv(dev)->ai_buffer[i] == NULL) {
+			return -ENOMEM;
+		}
+	}
+	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
+		if (ao_cmd_is_supported(board(dev))) {
+			priv(dev)->ao_buffer[i] =
+				pci_alloc_consistent(priv(dev)->hw_dev,
+				DMA_BUFFER_SIZE,
+				&priv(dev)->ao_buffer_bus_addr[i]);
+			if (priv(dev)->ao_buffer[i] == NULL) {
+				return -ENOMEM;
+			}
+		}
+	}
+	// allocate dma descriptors
+	priv(dev)->ai_dma_desc =
+		pci_alloc_consistent(priv(dev)->hw_dev,
+		sizeof(struct plx_dma_desc) * ai_dma_ring_count(board(dev)),
+		&priv(dev)->ai_dma_desc_bus_addr);
+	if (priv(dev)->ai_dma_desc == NULL) {
+		return -ENOMEM;
+	}
+	DEBUG_PRINT("ai dma descriptors start at bus addr 0x%x\n",
+		priv(dev)->ai_dma_desc_bus_addr);
+	if (ao_cmd_is_supported(board(dev))) {
+		priv(dev)->ao_dma_desc =
+			pci_alloc_consistent(priv(dev)->hw_dev,
+			sizeof(struct plx_dma_desc) * AO_DMA_RING_COUNT,
+			&priv(dev)->ao_dma_desc_bus_addr);
+		if (priv(dev)->ao_dma_desc == NULL) {
+			return -ENOMEM;
+		}
+		DEBUG_PRINT("ao dma descriptors start at bus addr 0x%x\n",
+			priv(dev)->ao_dma_desc_bus_addr);
+	}
+	// initialize dma descriptors
+	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
+		priv(dev)->ai_dma_desc[i].pci_start_addr =
+			cpu_to_le32(priv(dev)->ai_buffer_bus_addr[i]);
+		if (board(dev)->layout == LAYOUT_4020)
+			priv(dev)->ai_dma_desc[i].local_start_addr =
+				cpu_to_le32(priv(dev)->local1_iobase +
+				ADC_FIFO_REG);
+		else
+			priv(dev)->ai_dma_desc[i].local_start_addr =
+				cpu_to_le32(priv(dev)->local0_iobase +
+				ADC_FIFO_REG);
+		priv(dev)->ai_dma_desc[i].transfer_size = cpu_to_le32(0);
+		priv(dev)->ai_dma_desc[i].next =
+			cpu_to_le32((priv(dev)->ai_dma_desc_bus_addr + ((i +
+						1) %
+					ai_dma_ring_count(board(dev))) *
+				sizeof(priv(dev)->
+					ai_dma_desc[0])) | PLX_DESC_IN_PCI_BIT |
+			PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI);
+	}
+	if (ao_cmd_is_supported(board(dev))) {
+		for (i = 0; i < AO_DMA_RING_COUNT; i++) {
+			priv(dev)->ao_dma_desc[i].pci_start_addr =
+				cpu_to_le32(priv(dev)->ao_buffer_bus_addr[i]);
+			priv(dev)->ao_dma_desc[i].local_start_addr =
+				cpu_to_le32(priv(dev)->local0_iobase +
+				DAC_FIFO_REG);
+			priv(dev)->ao_dma_desc[i].transfer_size =
+				cpu_to_le32(0);
+			priv(dev)->ao_dma_desc[i].next =
+				cpu_to_le32((priv(dev)->ao_dma_desc_bus_addr +
+					((i + 1) % (AO_DMA_RING_COUNT)) *
+					sizeof(priv(dev)->
+						ao_dma_desc[0])) |
+				PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT);
+		}
+	}
+	return 0;
+}
+
+static inline void warn_external_queue(comedi_device * dev)
+{
+	comedi_error(dev,
+		"AO command and AI external channel queue cannot be used simultaneously.");
+	comedi_error(dev,
+		"Use internal AI channel queue (channels must be consecutive and use same range/aref)");
+}
+
+/*
+ * Attach is called by the Comedi core to configure the driver
+ * for a particular board.
+ */
+static int attach(comedi_device * dev, comedi_devconfig * it)
+{
+	struct pci_dev *pcidev;
+	int index;
+	uint32_t local_range, local_decode;
+	int retval;
+
+	printk("comedi%d: cb_pcidas64\n", dev->minor);
+
+/*
+ * Allocate the private structure area.
+ */
+	if (alloc_private(dev, sizeof(pcidas64_private)) < 0)
+		return -ENOMEM;
+
+/*
+ * Probe the device to determine what device in the series it is.
+ */
+
+	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
+		pcidev != NULL;
+		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+		// is it not a computer boards card?
+		if (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
+			continue;
+		// loop through cards supported by this driver
+		for (index = 0; index < num_boards(); index++) {
+			if (pcidas64_boards[index].device_id != pcidev->device)
+				continue;
+			// was a particular bus/slot requested?
+			if (it->options[0] || it->options[1]) {
+				// are we on the wrong bus/slot?
+				if (pcidev->bus->number != it->options[0] ||
+					PCI_SLOT(pcidev->devfn) !=
+					it->options[1]) {
+					continue;
+				}
+			}
+			priv(dev)->hw_dev = pcidev;
+			dev->board_ptr = pcidas64_boards + index;
+			break;
+		}
+		if (dev->board_ptr)
+			break;
+	}
+
+	if (dev->board_ptr == NULL) {
+		printk("No supported ComputerBoards/MeasurementComputing card found\n");
+		return -EIO;
+	}
+
+	printk("Found %s on bus %i, slot %i\n", board(dev)->name,
+		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+
+	if (comedi_pci_enable(pcidev, driver_cb_pcidas.driver_name)) {
+		printk(KERN_WARNING
+			" failed to enable PCI device and request regions\n");
+		return -EIO;
+	}
+	pci_set_master(pcidev);
+
+	//Initialize dev->board_name
+	dev->board_name = board(dev)->name;
+
+	priv(dev)->plx9080_phys_iobase =
+		pci_resource_start(pcidev, PLX9080_BADDRINDEX);
+	priv(dev)->main_phys_iobase =
+		pci_resource_start(pcidev, MAIN_BADDRINDEX);
+	priv(dev)->dio_counter_phys_iobase =
+		pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
+
+	// remap, won't work with 2.0 kernels but who cares
+	priv(dev)->plx9080_iobase = ioremap(priv(dev)->plx9080_phys_iobase,
+		pci_resource_len(pcidev, PLX9080_BADDRINDEX));
+	priv(dev)->main_iobase = ioremap(priv(dev)->main_phys_iobase,
+		pci_resource_len(pcidev, MAIN_BADDRINDEX));
+	priv(dev)->dio_counter_iobase =
+		ioremap(priv(dev)->dio_counter_phys_iobase,
+		pci_resource_len(pcidev, DIO_COUNTER_BADDRINDEX));
+
+	if (!priv(dev)->plx9080_iobase || !priv(dev)->main_iobase
+		|| !priv(dev)->dio_counter_iobase) {
+		printk(" failed to remap io memory\n");
+		return -ENOMEM;
+	}
+
+	DEBUG_PRINT(" plx9080 remapped to 0x%p\n", priv(dev)->plx9080_iobase);
+	DEBUG_PRINT(" main remapped to 0x%p\n", priv(dev)->main_iobase);
+	DEBUG_PRINT(" diocounter remapped to 0x%p\n",
+		priv(dev)->dio_counter_iobase);
+
+	// figure out what local addresses are
+	local_range =
+		readl(priv(dev)->plx9080_iobase +
+		PLX_LAS0RNG_REG) & LRNG_MEM_MASK;
+	local_decode =
+		readl(priv(dev)->plx9080_iobase +
+		PLX_LAS0MAP_REG) & local_range & LMAP_MEM_MASK;
+	priv(dev)->local0_iobase =
+		((uint32_t) priv(dev)->
+		main_phys_iobase & ~local_range) | local_decode;
+	local_range =
+		readl(priv(dev)->plx9080_iobase +
+		PLX_LAS1RNG_REG) & LRNG_MEM_MASK;
+	local_decode =
+		readl(priv(dev)->plx9080_iobase +
+		PLX_LAS1MAP_REG) & local_range & LMAP_MEM_MASK;
+	priv(dev)->local1_iobase =
+		((uint32_t) priv(dev)->
+		dio_counter_phys_iobase & ~local_range) | local_decode;
+
+	DEBUG_PRINT(" local 0 io addr 0x%x\n", priv(dev)->local0_iobase);
+	DEBUG_PRINT(" local 1 io addr 0x%x\n", priv(dev)->local1_iobase);
+
+	retval = alloc_and_init_dma_members(dev);
+	if (retval < 0)
+		return retval;
+
+	priv(dev)->hw_revision =
+		hw_revision(dev, readw(priv(dev)->main_iobase + HW_STATUS_REG));
+	printk(" stc hardware revision %i\n", priv(dev)->hw_revision);
+	init_plx9080(dev);
+	init_stc_registers(dev);
+	// get irq
+	if (comedi_request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
+			"cb_pcidas64", dev)) {
+		printk(" unable to allocate irq %u\n", pcidev->irq);
+		return -EINVAL;
+	}
+	dev->irq = pcidev->irq;
+	printk(" irq %u\n", dev->irq);
+
+	retval = setup_subdevices(dev);
+	if (retval < 0) {
+		return retval;
+	}
+
+	return 0;
+}
+
+/*
+ * _detach is called to deconfigure a device.  It should deallocate
+ * resources.
+ * This function is also called when _attach() fails, so it should be
+ * careful not to release resources that were not necessarily
+ * allocated by _attach().  dev->private and dev->subdevices are
+ * deallocated automatically by the core.
+ */
+static int detach(comedi_device * dev)
+{
+	unsigned int i;
+
+	printk("comedi%d: cb_pcidas: remove\n", dev->minor);
+
+	if (dev->irq)
+		comedi_free_irq(dev->irq, dev);
+	if (priv(dev)) {
+		if (priv(dev)->hw_dev) {
+			if (priv(dev)->plx9080_iobase) {
+				disable_plx_interrupts(dev);
+				iounmap((void *)priv(dev)->plx9080_iobase);
+			}
+			if (priv(dev)->main_iobase)
+				iounmap((void *)priv(dev)->main_iobase);
+			if (priv(dev)->dio_counter_iobase)
+				iounmap((void *)priv(dev)->dio_counter_iobase);
+			// free pci dma buffers
+			for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
+				if (priv(dev)->ai_buffer[i])
+					pci_free_consistent(priv(dev)->hw_dev,
+						DMA_BUFFER_SIZE,
+						priv(dev)->ai_buffer[i],
+						priv(dev)->
+						ai_buffer_bus_addr[i]);
+			}
+			for (i = 0; i < AO_DMA_RING_COUNT; i++) {
+				if (priv(dev)->ao_buffer[i])
+					pci_free_consistent(priv(dev)->hw_dev,
+						DMA_BUFFER_SIZE,
+						priv(dev)->ao_buffer[i],
+						priv(dev)->
+						ao_buffer_bus_addr[i]);
+			}
+			// free dma descriptors
+			if (priv(dev)->ai_dma_desc)
+				pci_free_consistent(priv(dev)->hw_dev,
+					sizeof(struct plx_dma_desc) *
+					ai_dma_ring_count(board(dev)),
+					priv(dev)->ai_dma_desc,
+					priv(dev)->ai_dma_desc_bus_addr);
+			if (priv(dev)->ao_dma_desc)
+				pci_free_consistent(priv(dev)->hw_dev,
+					sizeof(struct plx_dma_desc) *
+					AO_DMA_RING_COUNT,
+					priv(dev)->ao_dma_desc,
+					priv(dev)->ao_dma_desc_bus_addr);
+			if (priv(dev)->main_phys_iobase) {
+				comedi_pci_disable(priv(dev)->hw_dev);
+			}
+			pci_dev_put(priv(dev)->hw_dev);
+		}
+	}
+	if (dev->subdevices)
+		subdev_8255_cleanup(dev, dev->subdevices + 4);
+
+	return 0;
+}
+
+static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned int bits = 0, n, i;
+	unsigned int channel, range, aref;
+	unsigned long flags;
+	static const int timeout = 100;
+
+	DEBUG_PRINT("chanspec 0x%x\n", insn->chanspec);
+	channel = CR_CHAN(insn->chanspec);
+	range = CR_RANGE(insn->chanspec);
+	aref = CR_AREF(insn->chanspec);
+
+	// disable card's analog input interrupt sources and pacing
+	// 4020 generates dac done interrupts even though they are disabled
+	disable_ai_pacing(dev);
+
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	if (insn->chanspec & CR_ALT_FILTER)
+		priv(dev)->adc_control1_bits |= ADC_DITHER_BIT;
+	else
+		priv(dev)->adc_control1_bits &= ~ADC_DITHER_BIT;
+	writew(priv(dev)->adc_control1_bits,
+		priv(dev)->main_iobase + ADC_CONTROL1_REG);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	if (board(dev)->layout != LAYOUT_4020) {
+		// use internal queue
+		priv(dev)->hw_config_bits &= ~EXT_QUEUE_BIT;
+		writew(priv(dev)->hw_config_bits,
+			priv(dev)->main_iobase + HW_CONFIG_REG);
+
+		// ALT_SOURCE is internal calibration reference
+		if (insn->chanspec & CR_ALT_SOURCE) {
+			unsigned int cal_en_bit;
+
+			DEBUG_PRINT("reading calibration source\n");
+			if (board(dev)->layout == LAYOUT_60XX)
+				cal_en_bit = CAL_EN_60XX_BIT;
+			else
+				cal_en_bit = CAL_EN_64XX_BIT;
+			// select internal reference source to connect to channel 0
+			writew(cal_en_bit | adc_src_bits(priv(dev)->
+					calibration_source),
+				priv(dev)->main_iobase + CALIBRATION_REG);
+		} else {
+			// make sure internal calibration source is turned off
+			writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
+		}
+		// load internal queue
+		bits = 0;
+		// set gain
+		bits |= ai_range_bits_6xxx(dev, CR_RANGE(insn->chanspec));
+		// set single-ended / differential
+		bits |= se_diff_bit_6xxx(dev, aref == AREF_DIFF);
+		if (aref == AREF_COMMON)
+			bits |= ADC_COMMON_BIT;
+		bits |= adc_chan_bits(channel);
+		// set stop channel
+		writew(adc_chan_bits(channel),
+			priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
+		// set start channel, and rest of settings
+		writew(bits, priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
+	} else {
+		uint8_t old_cal_range_bits = priv(dev)->i2c_cal_range_bits;
+
+		priv(dev)->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;
+		if (insn->chanspec & CR_ALT_SOURCE) {
+			DEBUG_PRINT("reading calibration source\n");
+			priv(dev)->i2c_cal_range_bits |=
+				adc_src_4020_bits(priv(dev)->
+				calibration_source);
+		} else {	//select BNC inputs
+			priv(dev)->i2c_cal_range_bits |= adc_src_4020_bits(4);
+		}
+		// select range
+		if (range == 0)
+			priv(dev)->i2c_cal_range_bits |= attenuate_bit(channel);
+		else
+			priv(dev)->i2c_cal_range_bits &=
+				~attenuate_bit(channel);
+		// update calibration/range i2c register only if necessary, as it is very slow
+		if (old_cal_range_bits != priv(dev)->i2c_cal_range_bits) {
+			uint8_t i2c_data = priv(dev)->i2c_cal_range_bits;
+			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
+				sizeof(i2c_data));
+		}
+
+		/* 4020 manual asks that sample interval register to be set before writing to convert register.
+		 * Using somewhat arbitrary setting of 4 master clock ticks = 0.1 usec */
+		writew(0,
+			priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
+		writew(2,
+			priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
+	}
+
+	for (n = 0; n < insn->n; n++) {
+
+		// clear adc buffer (inside loop for 4020 sake)
+		writew(0, priv(dev)->main_iobase + ADC_BUFFER_CLEAR_REG);
+
+		/* trigger conversion, bits sent only matter for 4020 */
+		writew(adc_convert_chan_4020_bits(CR_CHAN(insn->chanspec)),
+			priv(dev)->main_iobase + ADC_CONVERT_REG);
+
+		// wait for data
+		for (i = 0; i < timeout; i++) {
+			bits = readw(priv(dev)->main_iobase + HW_STATUS_REG);
+			DEBUG_PRINT(" pipe bits 0x%x\n", pipe_full_bits(bits));
+			if (board(dev)->layout == LAYOUT_4020) {
+				if (readw(priv(dev)->main_iobase +
+						ADC_WRITE_PNTR_REG))
+					break;
+			} else {
+				if (pipe_full_bits(bits))
+					break;
+			}
+			comedi_udelay(1);
+		}
+		DEBUG_PRINT(" looped %i times waiting for data\n", i);
+		if (i == timeout) {
+			comedi_error(dev, " analog input read insn timed out");
+			rt_printk(" status 0x%x\n", bits);
+			return -ETIME;
+		}
+		if (board(dev)->layout == LAYOUT_4020)
+			data[n] =
+				readl(priv(dev)->dio_counter_iobase +
+				ADC_FIFO_REG) & 0xffff;
+		else
+			data[n] =
+				readw(priv(dev)->main_iobase + PIPE1_READ_REG);
+	}
+
+	return n;
+}
+
+static int ai_config_calibration_source(comedi_device * dev, lsampl_t * data)
+{
+	lsampl_t source = data[1];
+	int num_calibration_sources;
+
+	if (board(dev)->layout == LAYOUT_60XX)
+		num_calibration_sources = 16;
+	else
+		num_calibration_sources = 8;
+	if (source >= num_calibration_sources) {
+		printk("invalid calibration source: %i\n", source);
+		return -EINVAL;
+	}
+
+	DEBUG_PRINT("setting calibration source to %i\n", source);
+	priv(dev)->calibration_source = source;
+
+	return 2;
+}
+
+static int ai_config_block_size(comedi_device * dev, lsampl_t * data)
+{
+	int fifo_size;
+	const hw_fifo_info_t *const fifo = board(dev)->ai_fifo;
+	unsigned int block_size, requested_block_size;
+	int retval;
+
+	requested_block_size = data[1];
+
+	if (requested_block_size) {
+		fifo_size =
+			requested_block_size * fifo->num_segments /
+			bytes_in_sample;
+
+		retval = set_ai_fifo_size(dev, fifo_size);
+		if (retval < 0)
+			return retval;
+
+	}
+
+	block_size = ai_fifo_size(dev) / fifo->num_segments * bytes_in_sample;
+
+	data[1] = block_size;
+
+	return 2;
+}
+
+static int ai_config_master_clock_4020(comedi_device * dev, lsampl_t * data)
+{
+	unsigned int divisor = data[4];
+	int retval = 0;
+
+	if (divisor < 2) {
+		divisor = 2;
+		retval = -EAGAIN;
+	}
+
+	switch (data[1]) {
+	case COMEDI_EV_SCAN_BEGIN:
+		priv(dev)->ext_clock.divisor = divisor;
+		priv(dev)->ext_clock.chanspec = data[2];
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	data[4] = divisor;
+
+	return retval ? retval : 5;
+}
+
+// XXX could add support for 60xx series
+static int ai_config_master_clock(comedi_device * dev, lsampl_t * data)
+{
+
+	switch (board(dev)->layout) {
+	case LAYOUT_4020:
+		return ai_config_master_clock_4020(dev, data);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	return -EINVAL;
+}
+
+static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int id = data[0];
+
+	switch (id) {
+	case INSN_CONFIG_ALT_SOURCE:
+		return ai_config_calibration_source(dev, data);
+		break;
+	case INSN_CONFIG_BLOCK_SIZE:
+		return ai_config_block_size(dev, data);
+		break;
+	case INSN_CONFIG_TIMER_1:
+		return ai_config_master_clock(dev, data);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return -EINVAL;
+}
+
+static int ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+	unsigned int tmp_arg, tmp_arg2;
+	int i;
+	int aref;
+	unsigned int triggers;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_EXT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	triggers = TRIG_TIMER;
+	if (board(dev)->layout == LAYOUT_4020)
+		triggers |= TRIG_OTHER;
+	else
+		triggers |= TRIG_FOLLOW;
+	cmd->scan_begin_src &= triggers;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	triggers = TRIG_TIMER;
+	if (board(dev)->layout == LAYOUT_4020)
+		triggers |= TRIG_NOW;
+	else
+		triggers |= TRIG_EXT;
+	cmd->convert_src &= triggers;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_EXT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	// uniqueness check
+	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
+		err++;
+	if (cmd->scan_begin_src != TRIG_TIMER &&
+		cmd->scan_begin_src != TRIG_OTHER &&
+		cmd->scan_begin_src != TRIG_FOLLOW)
+		err++;
+	if (cmd->convert_src != TRIG_TIMER &&
+		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT &&
+		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
+		err++;
+
+	// compatibility check
+	if (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT &&
+		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (board(dev)->layout == LAYOUT_4020) {
+			if (cmd->convert_arg) {
+				cmd->convert_arg = 0;
+				err++;
+			}
+		} else {
+			if (cmd->convert_arg < board(dev)->ai_speed) {
+				cmd->convert_arg = board(dev)->ai_speed;
+				err++;
+			}
+			if (cmd->scan_begin_src == TRIG_TIMER) {
+				// if scans are timed faster than conversion rate allows
+				if (cmd->convert_arg * cmd->chanlist_len >
+					cmd->scan_begin_arg) {
+					cmd->scan_begin_arg =
+						cmd->convert_arg *
+						cmd->chanlist_len;
+					err++;
+				}
+			}
+		}
+	}
+
+	if (!cmd->chanlist_len) {
+		cmd->chanlist_len = 1;
+		err++;
+	}
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	switch (cmd->stop_src) {
+	case TRIG_EXT:
+		break;
+	case TRIG_COUNT:
+		if (!cmd->stop_arg) {
+			cmd->stop_arg = 1;
+			err++;
+		}
+		break;
+	case TRIG_NONE:
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		tmp_arg = cmd->convert_arg;
+		tmp_arg2 = cmd->scan_begin_arg;
+		check_adc_timing(dev, cmd);
+		if (tmp_arg != cmd->convert_arg)
+			err++;
+		if (tmp_arg2 != cmd->scan_begin_arg)
+			err++;
+	}
+
+	if (err)
+		return 4;
+
+	// make sure user is doesn't change analog reference mid chanlist
+	if (cmd->chanlist) {
+		aref = CR_AREF(cmd->chanlist[0]);
+		for (i = 1; i < cmd->chanlist_len; i++) {
+			if (aref != CR_AREF(cmd->chanlist[i])) {
+				comedi_error(dev,
+					"all elements in chanlist must use the same analog reference");
+				err++;
+				break;
+			}
+		}
+		// check 4020 chanlist
+		if (board(dev)->layout == LAYOUT_4020) {
+			unsigned int first_channel = CR_CHAN(cmd->chanlist[0]);
+			for (i = 1; i < cmd->chanlist_len; i++) {
+				if (CR_CHAN(cmd->chanlist[i]) !=
+					first_channel + i) {
+					comedi_error(dev,
+						"chanlist must use consecutive channels");
+					err++;
+					break;
+				}
+			}
+			if (cmd->chanlist_len == 3) {
+				comedi_error(dev,
+					"chanlist cannot be 3 channels long, use 1, 2, or 4 channels");
+				err++;
+			}
+		}
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+static int use_hw_sample_counter(comedi_cmd * cmd)
+{
+// disable for now until I work out a race
+	return 0;
+
+	if (cmd->stop_src == TRIG_COUNT && cmd->stop_arg <= max_counter_value)
+		return 1;
+	else
+		return 0;
+}
+
+static void setup_sample_counters(comedi_device * dev, comedi_cmd * cmd)
+{
+	if (cmd->stop_src == TRIG_COUNT) {
+		// set software count
+		priv(dev)->ai_count = cmd->stop_arg * cmd->chanlist_len;
+	}
+	// load hardware conversion counter
+	if (use_hw_sample_counter(cmd)) {
+		writew(cmd->stop_arg & 0xffff,
+			priv(dev)->main_iobase + ADC_COUNT_LOWER_REG);
+		writew((cmd->stop_arg >> 16) & 0xff,
+			priv(dev)->main_iobase + ADC_COUNT_UPPER_REG);
+	} else {
+		writew(1, priv(dev)->main_iobase + ADC_COUNT_LOWER_REG);
+	}
+}
+
+static inline unsigned int dma_transfer_size(comedi_device * dev)
+{
+	unsigned int num_samples;
+
+	num_samples =
+		priv(dev)->ai_fifo_segment_length *
+		board(dev)->ai_fifo->sample_packing_ratio;
+	if (num_samples > DMA_BUFFER_SIZE / sizeof(uint16_t))
+		num_samples = DMA_BUFFER_SIZE / sizeof(uint16_t);
+
+	return num_samples;
+}
+
+static void disable_ai_pacing(comedi_device * dev)
+{
+	unsigned long flags;
+
+	disable_ai_interrupts(dev);
+
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	priv(dev)->adc_control1_bits &= ~ADC_SW_GATE_BIT;
+	writew(priv(dev)->adc_control1_bits,
+		priv(dev)->main_iobase + ADC_CONTROL1_REG);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	/* disable pacing, triggering, etc */
+	writew(ADC_DMA_DISABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT,
+		priv(dev)->main_iobase + ADC_CONTROL0_REG);
+}
+
+static void disable_ai_interrupts(comedi_device * dev)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	priv(dev)->intr_enable_bits &=
+		~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &
+		~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &
+		~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;
+	writew(priv(dev)->intr_enable_bits,
+		priv(dev)->main_iobase + INTR_ENABLE_REG);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
+}
+
+static void enable_ai_interrupts(comedi_device * dev, const comedi_cmd * cmd)
+{
+	uint32_t bits;
+	unsigned long flags;
+
+	bits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |
+		EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;
+	// Use pio transfer and interrupt on end of conversion if TRIG_WAKE_EOS flag is set.
+	if (cmd->flags & TRIG_WAKE_EOS) {
+		// 4020 doesn't support pio transfers except for fifo dregs
+		if (board(dev)->layout != LAYOUT_4020)
+			bits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;
+	}
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	priv(dev)->intr_enable_bits |= bits;
+	writew(priv(dev)->intr_enable_bits,
+		priv(dev)->main_iobase + INTR_ENABLE_REG);
+	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+}
+
+static uint32_t ai_convert_counter_6xxx(const comedi_device * dev,
+	const comedi_cmd * cmd)
+{
+	// supposed to load counter with desired divisor minus 3
+	return cmd->convert_arg / TIMER_BASE - 3;
+}
+
+static uint32_t ai_scan_counter_6xxx(comedi_device * dev, comedi_cmd * cmd)
+{
+	uint32_t count;
+	// figure out how long we need to delay at end of scan
+	switch (cmd->scan_begin_src) {
+	case TRIG_TIMER:
+		count = (cmd->scan_begin_arg -
+			(cmd->convert_arg * (cmd->chanlist_len - 1)))
+			/ TIMER_BASE;
+		break;
+	case TRIG_FOLLOW:
+		count = cmd->convert_arg / TIMER_BASE;
+		break;
+	default:
+		return 0;
+		break;
+	}
+	return count - 3;
+}
+
+static uint32_t ai_convert_counter_4020(comedi_device * dev, comedi_cmd * cmd)
+{
+	unsigned int divisor;
+
+	switch (cmd->scan_begin_src) {
+	case TRIG_TIMER:
+		divisor = cmd->scan_begin_arg / TIMER_BASE;
+		break;
+	case TRIG_OTHER:
+		divisor = priv(dev)->ext_clock.divisor;
+		break;
+	default:		// should never happen
+		comedi_error(dev, "bug! failed to set ai pacing!");
+		divisor = 1000;
+		break;
+	}
+
+	// supposed to load counter with desired divisor minus 2 for 4020
+	return divisor - 2;
+}
+
+static void select_master_clock_4020(comedi_device * dev,
+	const comedi_cmd * cmd)
+{
+	// select internal/external master clock
+	priv(dev)->hw_config_bits &= ~MASTER_CLOCK_4020_MASK;
+	if (cmd->scan_begin_src == TRIG_OTHER) {
+		int chanspec = priv(dev)->ext_clock.chanspec;
+
+		if (CR_CHAN(chanspec))
+			priv(dev)->hw_config_bits |= BNC_CLOCK_4020_BITS;
+		else
+			priv(dev)->hw_config_bits |= EXT_CLOCK_4020_BITS;
+	} else {
+		priv(dev)->hw_config_bits |= INTERNAL_CLOCK_4020_BITS;
+	}
+	writew(priv(dev)->hw_config_bits,
+		priv(dev)->main_iobase + HW_CONFIG_REG);
+}
+
+static void select_master_clock(comedi_device * dev, const comedi_cmd * cmd)
+{
+	switch (board(dev)->layout) {
+	case LAYOUT_4020:
+		select_master_clock_4020(dev, cmd);
+		break;
+	default:
+		break;
+	}
+}
+
+static inline void dma_start_sync(comedi_device * dev, unsigned int channel)
+{
+	unsigned long flags;
+
+	// spinlock for plx dma control/status reg
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	if (channel)
+		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
+			PLX_CLEAR_DMA_INTR_BIT,
+			priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+	else
+		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
+			PLX_CLEAR_DMA_INTR_BIT,
+			priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+}
+
+static void set_ai_pacing(comedi_device * dev, comedi_cmd * cmd)
+{
+	uint32_t convert_counter = 0, scan_counter = 0;
+
+	check_adc_timing(dev, cmd);
+
+	select_master_clock(dev, cmd);
+
+	if (board(dev)->layout == LAYOUT_4020) {
+		convert_counter = ai_convert_counter_4020(dev, cmd);
+	} else {
+		convert_counter = ai_convert_counter_6xxx(dev, cmd);
+		scan_counter = ai_scan_counter_6xxx(dev, cmd);
+	}
+
+	// load lower 16 bits of convert interval
+	writew(convert_counter & 0xffff,
+		priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
+	DEBUG_PRINT("convert counter 0x%x\n", convert_counter);
+	// load upper 8 bits of convert interval
+	writew((convert_counter >> 16) & 0xff,
+		priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
+	// load lower 16 bits of scan delay
+	writew(scan_counter & 0xffff,
+		priv(dev)->main_iobase + ADC_DELAY_INTERVAL_LOWER_REG);
+	// load upper 8 bits of scan delay
+	writew((scan_counter >> 16) & 0xff,
+		priv(dev)->main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);
+	DEBUG_PRINT("scan counter 0x%x\n", scan_counter);
+}
+
+static int use_internal_queue_6xxx(const comedi_cmd * cmd)
+{
+	int i;
+	for (i = 0; i + 1 < cmd->chanlist_len; i++) {
+		if (CR_CHAN(cmd->chanlist[i + 1]) !=
+			CR_CHAN(cmd->chanlist[i]) + 1)
+			return 0;
+		if (CR_RANGE(cmd->chanlist[i + 1]) !=
+			CR_RANGE(cmd->chanlist[i]))
+			return 0;
+		if (CR_AREF(cmd->chanlist[i + 1]) != CR_AREF(cmd->chanlist[i]))
+			return 0;
+	}
+	return 1;
+}
+
+static int setup_channel_queue(comedi_device * dev, const comedi_cmd * cmd)
+{
+	unsigned short bits;
+	int i;
+
+	if (board(dev)->layout != LAYOUT_4020) {
+		if (use_internal_queue_6xxx(cmd)) {
+			priv(dev)->hw_config_bits &= ~EXT_QUEUE_BIT;
+			writew(priv(dev)->hw_config_bits,
+				priv(dev)->main_iobase + HW_CONFIG_REG);
+			bits = 0;
+			// set channel
+			bits |= adc_chan_bits(CR_CHAN(cmd->chanlist[0]));
+			// set gain
+			bits |= ai_range_bits_6xxx(dev,
+				CR_RANGE(cmd->chanlist[0]));
+			// set single-ended / differential
+			bits |= se_diff_bit_6xxx(dev,
+				CR_AREF(cmd->chanlist[0]) == AREF_DIFF);
+			if (CR_AREF(cmd->chanlist[0]) == AREF_COMMON)
+				bits |= ADC_COMMON_BIT;
+			// set stop channel
+			writew(adc_chan_bits(CR_CHAN(cmd->chanlist[cmd->
+							chanlist_len - 1])),
+				priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
+			// set start channel, and rest of settings
+			writew(bits,
+				priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
+		} else {
+			// use external queue
+			if (dev->write_subdev && dev->write_subdev->busy) {
+				warn_external_queue(dev);
+				return -EBUSY;
+			}
+			priv(dev)->hw_config_bits |= EXT_QUEUE_BIT;
+			writew(priv(dev)->hw_config_bits,
+				priv(dev)->main_iobase + HW_CONFIG_REG);
+			// clear DAC buffer to prevent weird interactions
+			writew(0,
+				priv(dev)->main_iobase + DAC_BUFFER_CLEAR_REG);
+			// clear queue pointer
+			writew(0, priv(dev)->main_iobase + ADC_QUEUE_CLEAR_REG);
+			// load external queue
+			for (i = 0; i < cmd->chanlist_len; i++) {
+				bits = 0;
+				// set channel
+				bits |= adc_chan_bits(CR_CHAN(cmd->
+						chanlist[i]));
+				// set gain
+				bits |= ai_range_bits_6xxx(dev,
+					CR_RANGE(cmd->chanlist[i]));
+				// set single-ended / differential
+				bits |= se_diff_bit_6xxx(dev,
+					CR_AREF(cmd->chanlist[i]) == AREF_DIFF);
+				if (CR_AREF(cmd->chanlist[i]) == AREF_COMMON)
+					bits |= ADC_COMMON_BIT;
+				// mark end of queue
+				if (i == cmd->chanlist_len - 1)
+					bits |= QUEUE_EOSCAN_BIT |
+						QUEUE_EOSEQ_BIT;
+				writew(bits,
+					priv(dev)->main_iobase +
+					ADC_QUEUE_FIFO_REG);
+				DEBUG_PRINT
+					("wrote 0x%x to external channel queue\n",
+					bits);
+			}
+			/* doing a queue clear is not specified in board docs,
+			 * but required for reliable operation */
+			writew(0, priv(dev)->main_iobase + ADC_QUEUE_CLEAR_REG);
+			// prime queue holding register
+			writew(0, priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
+		}
+	} else {
+		unsigned short old_cal_range_bits =
+			priv(dev)->i2c_cal_range_bits;
+
+		priv(dev)->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;
+		//select BNC inputs
+		priv(dev)->i2c_cal_range_bits |= adc_src_4020_bits(4);
+		// select ranges
+		for (i = 0; i < cmd->chanlist_len; i++) {
+			unsigned int channel = CR_CHAN(cmd->chanlist[i]);
+			unsigned int range = CR_RANGE(cmd->chanlist[i]);
+
+			if (range == 0)
+				priv(dev)->i2c_cal_range_bits |=
+					attenuate_bit(channel);
+			else
+				priv(dev)->i2c_cal_range_bits &=
+					~attenuate_bit(channel);
+		}
+		// update calibration/range i2c register only if necessary, as it is very slow
+		if (old_cal_range_bits != priv(dev)->i2c_cal_range_bits) {
+			uint8_t i2c_data = priv(dev)->i2c_cal_range_bits;
+			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
+				sizeof(i2c_data));
+		}
+	}
+	return 0;
+}
+
+static inline void load_first_dma_descriptor(comedi_device * dev,
+	unsigned int dma_channel, unsigned int descriptor_bits)
+{
+	/* The transfer size, pci address, and local address registers
+	 * are supposedly unused during chained dma,
+	 * but I have found that left over values from last operation
+	 * occasionally cause problems with transfer of first dma
+	 * block.  Initializing them to zero seems to fix the problem. */
+	if (dma_channel) {
+		writel(0,
+			priv(dev)->plx9080_iobase + PLX_DMA1_TRANSFER_SIZE_REG);
+		writel(0, priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG);
+		writel(0,
+			priv(dev)->plx9080_iobase + PLX_DMA1_LOCAL_ADDRESS_REG);
+		writel(descriptor_bits,
+			priv(dev)->plx9080_iobase + PLX_DMA1_DESCRIPTOR_REG);
+	} else {
+		writel(0,
+			priv(dev)->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
+		writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
+		writel(0,
+			priv(dev)->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
+		writel(descriptor_bits,
+			priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+	}
+}
+
+static int ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	uint32_t bits;
+	unsigned int i;
+	unsigned long flags;
+	int retval;
+
+	disable_ai_pacing(dev);
+	abort_dma(dev, 1);
+
+	retval = setup_channel_queue(dev, cmd);
+	if (retval < 0)
+		return retval;
+
+	// make sure internal calibration source is turned off
+	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
+
+	set_ai_pacing(dev, cmd);
+
+	setup_sample_counters(dev, cmd);
+
+	enable_ai_interrupts(dev, cmd);
+
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	/* set mode, allow conversions through software gate */
+	priv(dev)->adc_control1_bits |= ADC_SW_GATE_BIT;
+	priv(dev)->adc_control1_bits &= ~ADC_DITHER_BIT;
+	if (board(dev)->layout != LAYOUT_4020) {
+		priv(dev)->adc_control1_bits &= ~ADC_MODE_MASK;
+		if (cmd->convert_src == TRIG_EXT)
+			priv(dev)->adc_control1_bits |= adc_mode_bits(13);	// good old mode 13
+		else
+			priv(dev)->adc_control1_bits |= adc_mode_bits(8);	// mode 8.  What else could you need?
+	} else {
+		priv(dev)->adc_control1_bits &= ~CHANNEL_MODE_4020_MASK;
+		if (cmd->chanlist_len == 4)
+			priv(dev)->adc_control1_bits |= FOUR_CHANNEL_4020_BITS;
+		else if (cmd->chanlist_len == 2)
+			priv(dev)->adc_control1_bits |= TWO_CHANNEL_4020_BITS;
+		priv(dev)->adc_control1_bits &= ~ADC_LO_CHANNEL_4020_MASK;
+		priv(dev)->adc_control1_bits |=
+			adc_lo_chan_4020_bits(CR_CHAN(cmd->chanlist[0]));
+		priv(dev)->adc_control1_bits &= ~ADC_HI_CHANNEL_4020_MASK;
+		priv(dev)->adc_control1_bits |=
+			adc_hi_chan_4020_bits(CR_CHAN(cmd->chanlist[cmd->
+					chanlist_len - 1]));
+	}
+	writew(priv(dev)->adc_control1_bits,
+		priv(dev)->main_iobase + ADC_CONTROL1_REG);
+	DEBUG_PRINT("control1 bits 0x%x\n", priv(dev)->adc_control1_bits);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	// clear adc buffer
+	writew(0, priv(dev)->main_iobase + ADC_BUFFER_CLEAR_REG);
+
+	if ((cmd->flags & TRIG_WAKE_EOS) == 0 ||
+		board(dev)->layout == LAYOUT_4020) {
+		priv(dev)->ai_dma_index = 0;
+
+		// set dma transfer size
+		for (i = 0; i < ai_dma_ring_count(board(dev)); i++)
+			priv(dev)->ai_dma_desc[i].transfer_size =
+				cpu_to_le32(dma_transfer_size(dev) *
+				sizeof(uint16_t));
+
+		// give location of first dma descriptor
+		load_first_dma_descriptor(dev, 1,
+			priv(dev)->
+			ai_dma_desc_bus_addr | PLX_DESC_IN_PCI_BIT |
+			PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI);
+
+		dma_start_sync(dev, 1);
+	}
+
+	if (board(dev)->layout == LAYOUT_4020) {
+		/* set source for external triggers */
+		bits = 0;
+		if (cmd->start_src == TRIG_EXT && CR_CHAN(cmd->start_arg))
+			bits |= EXT_START_TRIG_BNC_BIT;
+		if (cmd->stop_src == TRIG_EXT && CR_CHAN(cmd->stop_arg))
+			bits |= EXT_STOP_TRIG_BNC_BIT;
+		writew(bits, priv(dev)->main_iobase + DAQ_ATRIG_LOW_4020_REG);
+	}
+
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+
+	/* enable pacing, triggering, etc */
+	bits = ADC_ENABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT;
+	if (cmd->flags & TRIG_WAKE_EOS)
+		bits |= ADC_DMA_DISABLE_BIT;
+	// set start trigger
+	if (cmd->start_src == TRIG_EXT) {
+		bits |= ADC_START_TRIG_EXT_BITS;
+		if (cmd->start_arg & CR_INVERT)
+			bits |= ADC_START_TRIG_FALLING_BIT;
+	} else if (cmd->start_src == TRIG_NOW)
+		bits |= ADC_START_TRIG_SOFT_BITS;
+	if (use_hw_sample_counter(cmd))
+		bits |= ADC_SAMPLE_COUNTER_EN_BIT;
+	writew(bits, priv(dev)->main_iobase + ADC_CONTROL0_REG);
+	DEBUG_PRINT("control0 bits 0x%x\n", bits);
+
+	priv(dev)->ai_cmd_running = 1;
+
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	// start aquisition
+	if (cmd->start_src == TRIG_NOW) {
+		writew(0, priv(dev)->main_iobase + ADC_START_REG);
+		DEBUG_PRINT("soft trig\n");
+	}
+
+	return 0;
+}
+
+// read num_samples from 16 bit wide ai fifo
+static void pio_drain_ai_fifo_16(comedi_device * dev)
+{
+	comedi_subdevice *s = dev->read_subdev;
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	unsigned int i;
+	uint16_t prepost_bits;
+	int read_segment, read_index, write_segment, write_index;
+	int num_samples;
+
+	do {
+		// get least significant 15 bits
+		read_index =
+			readw(priv(dev)->main_iobase +
+			ADC_READ_PNTR_REG) & 0x7fff;
+		write_index =
+			readw(priv(dev)->main_iobase +
+			ADC_WRITE_PNTR_REG) & 0x7fff;
+		/* Get most significant bits (grey code).  Different boards use different code
+		 * so use a scheme that doesn't depend on encoding.  This read must
+		 * occur after reading least significant 15 bits to avoid race
+		 * with fifo switching to next segment. */
+		prepost_bits = readw(priv(dev)->main_iobase + PREPOST_REG);
+
+		/* if read and write pointers are not on the same fifo segment, read to the
+		 * end of the read segment */
+		read_segment = adc_upper_read_ptr_code(prepost_bits);
+		write_segment = adc_upper_write_ptr_code(prepost_bits);
+
+		DEBUG_PRINT(" rd seg %i, wrt seg %i, rd idx %i, wrt idx %i\n",
+			read_segment, write_segment, read_index, write_index);
+
+		if (read_segment != write_segment)
+			num_samples =
+				priv(dev)->ai_fifo_segment_length - read_index;
+		else
+			num_samples = write_index - read_index;
+
+		if (cmd->stop_src == TRIG_COUNT) {
+			if (priv(dev)->ai_count == 0)
+				break;
+			if (num_samples > priv(dev)->ai_count) {
+				num_samples = priv(dev)->ai_count;
+			}
+			priv(dev)->ai_count -= num_samples;
+		}
+
+		if (num_samples < 0) {
+			rt_printk(" cb_pcidas64: bug! num_samples < 0\n");
+			break;
+		}
+
+		DEBUG_PRINT(" read %i samples from fifo\n", num_samples);
+
+		for (i = 0; i < num_samples; i++) {
+			cfc_write_to_buffer(s,
+				readw(priv(dev)->main_iobase + ADC_FIFO_REG));
+		}
+
+	} while (read_segment != write_segment);
+}
+
+/* Read from 32 bit wide ai fifo of 4020 - deal with insane grey coding of pointers.
+ * The pci-4020 hardware only supports
+ * dma transfers (it only supports the use of pio for draining the last remaining
+ * points from the fifo when a data aquisition operation has completed).
+ */
+static void pio_drain_ai_fifo_32(comedi_device * dev)
+{
+	comedi_subdevice *s = dev->read_subdev;
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	unsigned int i;
+	unsigned int max_transfer = 100000;
+	uint32_t fifo_data;
+	int write_code =
+		readw(priv(dev)->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
+	int read_code =
+		readw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		if (max_transfer > priv(dev)->ai_count) {
+			max_transfer = priv(dev)->ai_count;
+		}
+	}
+	for (i = 0; read_code != write_code && i < max_transfer;) {
+		fifo_data = readl(priv(dev)->dio_counter_iobase + ADC_FIFO_REG);
+		cfc_write_to_buffer(s, fifo_data & 0xffff);
+		i++;
+		if (i < max_transfer) {
+			cfc_write_to_buffer(s, (fifo_data >> 16) & 0xffff);
+			i++;
+		}
+		read_code =
+			readw(priv(dev)->main_iobase +
+			ADC_READ_PNTR_REG) & 0x7fff;
+	}
+	priv(dev)->ai_count -= i;
+}
+
+// empty fifo
+static void pio_drain_ai_fifo(comedi_device * dev)
+{
+	if (board(dev)->layout == LAYOUT_4020) {
+		pio_drain_ai_fifo_32(dev);
+	} else
+		pio_drain_ai_fifo_16(dev);
+}
+
+static void drain_dma_buffers(comedi_device * dev, unsigned int channel)
+{
+	comedi_async *async = dev->read_subdev->async;
+	uint32_t next_transfer_addr;
+	int j;
+	int num_samples = 0;
+	void *pci_addr_reg;
+
+	if (channel)
+		pci_addr_reg =
+			priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
+	else
+		pci_addr_reg =
+			priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+
+	// loop until we have read all the full buffers
+	for (j = 0, next_transfer_addr = readl(pci_addr_reg);
+		(next_transfer_addr <
+			priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index]
+			|| next_transfer_addr >=
+			priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index] +
+			DMA_BUFFER_SIZE) && j < ai_dma_ring_count(board(dev));
+		j++) {
+		// transfer data from dma buffer to comedi buffer
+		num_samples = dma_transfer_size(dev);
+		if (async->cmd.stop_src == TRIG_COUNT) {
+			if (num_samples > priv(dev)->ai_count)
+				num_samples = priv(dev)->ai_count;
+			priv(dev)->ai_count -= num_samples;
+		}
+		cfc_write_array_to_buffer(dev->read_subdev,
+			priv(dev)->ai_buffer[priv(dev)->ai_dma_index],
+			num_samples * sizeof(uint16_t));
+		priv(dev)->ai_dma_index =
+			(priv(dev)->ai_dma_index +
+			1) % ai_dma_ring_count(board(dev));
+
+		DEBUG_PRINT("next buffer addr 0x%lx\n",
+			(unsigned long)priv(dev)->ai_buffer_bus_addr[priv(dev)->
+				ai_dma_index]);
+		DEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);
+	}
+	/* XXX check for dma ring buffer overrun (use end-of-chain bit to mark last
+	 * unused buffer) */
+}
+
+void handle_ai_interrupt(comedi_device * dev, unsigned short status,
+	unsigned int plx_status)
+{
+	comedi_subdevice *s = dev->read_subdev;
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	uint8_t dma1_status;
+	unsigned long flags;
+
+	// check for fifo overrun
+	if (status & ADC_OVERRUN_BIT) {
+		comedi_error(dev, "fifo overrun");
+		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+	}
+	// spin lock makes sure noone else changes plx dma control reg
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+	if (plx_status & ICS_DMA1_A) {	// dma chan 1 interrupt
+		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
+			priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
+
+		if (dma1_status & PLX_DMA_EN_BIT) {
+			drain_dma_buffers(dev, 1);
+		}
+		DEBUG_PRINT(" cleared dma ch1 interrupt\n");
+	}
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	if (status & ADC_DONE_BIT)
+		DEBUG_PRINT("adc done interrupt\n");
+
+	// drain fifo with pio
+	if ((status & ADC_DONE_BIT) ||
+		((cmd->flags & TRIG_WAKE_EOS) &&
+			(status & ADC_INTR_PENDING_BIT) &&
+			(board(dev)->layout != LAYOUT_4020))) {
+		DEBUG_PRINT("pio fifo drain\n");
+		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		if (priv(dev)->ai_cmd_running) {
+			comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+			pio_drain_ai_fifo(dev);
+		} else
+			comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	}
+	// if we are have all the data, then quit
+	if ((cmd->stop_src == TRIG_COUNT && priv(dev)->ai_count <= 0) ||
+		(cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT))) {
+		async->events |= COMEDI_CB_EOA;
+	}
+
+	cfc_handle_events(dev, s);
+}
+
+static inline unsigned int prev_ao_dma_index(comedi_device * dev)
+{
+	unsigned int buffer_index;
+
+	if (priv(dev)->ao_dma_index == 0)
+		buffer_index = AO_DMA_RING_COUNT - 1;
+	else
+		buffer_index = priv(dev)->ao_dma_index - 1;
+	return buffer_index;
+}
+
+static int last_ao_dma_load_completed(comedi_device * dev)
+{
+	unsigned int buffer_index;
+	unsigned int transfer_address;
+	unsigned short dma_status;
+
+	buffer_index = prev_ao_dma_index(dev);
+	dma_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+	if ((dma_status & PLX_DMA_DONE_BIT) == 0)
+		return 0;
+
+	transfer_address =
+		readl(priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
+	if (transfer_address != priv(dev)->ao_buffer_bus_addr[buffer_index])
+		return 0;
+
+	return 1;
+}
+
+static int ao_stopped_by_error(comedi_device * dev, const comedi_cmd * cmd)
+{
+	if (cmd->stop_src == TRIG_NONE)
+		return 1;
+	if (cmd->stop_src == TRIG_COUNT) {
+		if (priv(dev)->ao_count)
+			return 1;
+		if (last_ao_dma_load_completed(dev) == 0)
+			return 1;
+	}
+	return 0;
+}
+
+static inline int ao_dma_needs_restart(comedi_device * dev,
+	unsigned short dma_status)
+{
+	if ((dma_status & PLX_DMA_DONE_BIT) == 0 ||
+		(dma_status & PLX_DMA_EN_BIT) == 0)
+		return 0;
+	if (last_ao_dma_load_completed(dev))
+		return 0;
+
+	return 1;
+}
+
+static void restart_ao_dma(comedi_device * dev)
+{
+	unsigned int dma_desc_bits;
+
+	dma_desc_bits =
+		readl(priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+	dma_desc_bits &= ~PLX_END_OF_CHAIN_BIT;
+	DEBUG_PRINT("restarting ao dma, descriptor reg 0x%x\n", dma_desc_bits);
+	load_first_dma_descriptor(dev, 0, dma_desc_bits);
+
+	dma_start_sync(dev, 0);
+}
+
+static void handle_ao_interrupt(comedi_device * dev, unsigned short status,
+	unsigned int plx_status)
+{
+	comedi_subdevice *s = dev->write_subdev;
+	comedi_async *async;
+	comedi_cmd *cmd;
+	uint8_t dma0_status;
+	unsigned long flags;
+
+	/* board might not support ao, in which case write_subdev is NULL */
+	if (s == NULL)
+		return;
+	async = s->async;
+	cmd = &async->cmd;
+
+	// spin lock makes sure noone else changes plx dma control reg
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+	if (plx_status & ICS_DMA0_A) {	// dma chan 0 interrupt
+		if ((dma0_status & PLX_DMA_EN_BIT)
+			&& !(dma0_status & PLX_DMA_DONE_BIT))
+			writeb(PLX_DMA_EN_BIT | PLX_CLEAR_DMA_INTR_BIT,
+				priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+		else
+			writeb(PLX_CLEAR_DMA_INTR_BIT,
+				priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		DEBUG_PRINT("dma0 status 0x%x\n", dma0_status);
+		if (dma0_status & PLX_DMA_EN_BIT) {
+			load_ao_dma(dev, cmd);
+			/* try to recover from dma end-of-chain event */
+			if (ao_dma_needs_restart(dev, dma0_status))
+				restart_ao_dma(dev);
+		}
+		DEBUG_PRINT(" cleared dma ch0 interrupt\n");
+	} else
+		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	if ((status & DAC_DONE_BIT)) {
+		async->events |= COMEDI_CB_EOA;
+		if (ao_stopped_by_error(dev, cmd))
+			async->events |= COMEDI_CB_ERROR;
+		DEBUG_PRINT("plx dma0 desc reg 0x%x\n",
+			readl(priv(dev)->plx9080_iobase +
+				PLX_DMA0_DESCRIPTOR_REG));
+		DEBUG_PRINT("plx dma0 address reg 0x%x\n",
+			readl(priv(dev)->plx9080_iobase +
+				PLX_DMA0_PCI_ADDRESS_REG));
+	}
+	cfc_handle_events(dev, s);
+}
+
+static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
+{
+	comedi_device *dev = d;
+	unsigned short status;
+	uint32_t plx_status;
+	uint32_t plx_bits;
+
+	plx_status = readl(priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+	status = readw(priv(dev)->main_iobase + HW_STATUS_REG);
+
+	DEBUG_PRINT("cb_pcidas64: hw status 0x%x ", status);
+	DEBUG_PRINT("plx status 0x%x\n", plx_status);
+
+	/* an interrupt before all the postconfig stuff gets done could
+	 * cause a NULL dereference if we continue through the
+	 * interrupt handler */
+	if (dev->attached == 0) {
+		DEBUG_PRINT("cb_pcidas64: premature interrupt, ignoring",
+			status);
+		return IRQ_HANDLED;
+	}
+	handle_ai_interrupt(dev, status, plx_status);
+	handle_ao_interrupt(dev, status, plx_status);
+
+	// clear possible plx9080 interrupt sources
+	if (plx_status & ICS_LDIA) {	// clear local doorbell interrupt
+		plx_bits = readl(priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);
+		writel(plx_bits, priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);
+		DEBUG_PRINT(" cleared local doorbell bits 0x%x\n", plx_bits);
+	}
+
+	DEBUG_PRINT("exiting handler\n");
+
+	return IRQ_HANDLED;
+}
+
+void abort_dma(comedi_device * dev, unsigned int channel)
+{
+	unsigned long flags;
+
+	// spinlock for plx dma control/status reg
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+
+	plx9080_abort_dma(priv(dev)->plx9080_iobase, channel);
+
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+}
+
+static int ai_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	if (priv(dev)->ai_cmd_running == 0) {
+		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		return 0;
+	}
+	priv(dev)->ai_cmd_running = 0;
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	disable_ai_pacing(dev);
+
+	abort_dma(dev, 1);
+
+	DEBUG_PRINT("ai canceled\n");
+	return 0;
+}
+
+static int ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int chan = CR_CHAN(insn->chanspec);
+	int range = CR_RANGE(insn->chanspec);
+
+	// do some initializing
+	writew(0, priv(dev)->main_iobase + DAC_CONTROL0_REG);
+
+	// set range
+	set_dac_range_bits(dev, &priv(dev)->dac_control1_bits, chan, range);
+	writew(priv(dev)->dac_control1_bits,
+		priv(dev)->main_iobase + DAC_CONTROL1_REG);
+
+	// write to channel
+	if (board(dev)->layout == LAYOUT_4020) {
+		writew(data[0] & 0xff,
+			priv(dev)->main_iobase + dac_lsb_4020_reg(chan));
+		writew((data[0] >> 8) & 0xf,
+			priv(dev)->main_iobase + dac_msb_4020_reg(chan));
+	} else {
+		writew(data[0], priv(dev)->main_iobase + dac_convert_reg(chan));
+	}
+
+	// remember output value
+	priv(dev)->ao_value[chan] = data[0];
+
+	return 1;
+}
+
+static int ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = priv(dev)->ao_value[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
+static void set_dac_control0_reg(comedi_device * dev, const comedi_cmd * cmd)
+{
+	unsigned int bits = DAC_ENABLE_BIT | WAVEFORM_GATE_LEVEL_BIT |
+		WAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;
+
+	if (cmd->start_src == TRIG_EXT) {
+		bits |= WAVEFORM_TRIG_EXT_BITS;
+		if (cmd->start_arg & CR_INVERT)
+			bits |= WAVEFORM_TRIG_FALLING_BIT;
+	} else {
+		bits |= WAVEFORM_TRIG_SOFT_BITS;
+	}
+	if (cmd->scan_begin_src == TRIG_EXT) {
+		bits |= DAC_EXT_UPDATE_ENABLE_BIT;
+		if (cmd->scan_begin_arg & CR_INVERT)
+			bits |= DAC_EXT_UPDATE_FALLING_BIT;
+	}
+	writew(bits, priv(dev)->main_iobase + DAC_CONTROL0_REG);
+}
+
+static void set_dac_control1_reg(comedi_device * dev, const comedi_cmd * cmd)
+{
+	int i;
+
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		int channel, range;
+
+		channel = CR_CHAN(cmd->chanlist[i]);
+		range = CR_RANGE(cmd->chanlist[i]);
+		set_dac_range_bits(dev, &priv(dev)->dac_control1_bits, channel,
+			range);
+	}
+	priv(dev)->dac_control1_bits |= DAC_SW_GATE_BIT;
+	writew(priv(dev)->dac_control1_bits,
+		priv(dev)->main_iobase + DAC_CONTROL1_REG);
+}
+
+static void set_dac_select_reg(comedi_device * dev, const comedi_cmd * cmd)
+{
+	uint16_t bits;
+	unsigned int first_channel, last_channel;
+
+	first_channel = CR_CHAN(cmd->chanlist[0]);
+	last_channel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);
+	if (last_channel < first_channel)
+		comedi_error(dev, "bug! last ao channel < first ao channel");
+
+	bits = (first_channel & 0x7) | (last_channel & 0x7) << 3;
+
+	writew(bits, priv(dev)->main_iobase + DAC_SELECT_REG);
+}
+
+static void set_dac_interval_regs(comedi_device * dev, const comedi_cmd * cmd)
+{
+	unsigned int divisor;
+
+	if (cmd->scan_begin_src != TRIG_TIMER)
+		return;
+
+	divisor = get_ao_divisor(cmd->scan_begin_arg, cmd->flags);
+	if (divisor > max_counter_value) {
+		comedi_error(dev, "bug! ao divisor too big");
+		divisor = max_counter_value;
+	}
+	writew(divisor & 0xffff,
+		priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_LOWER_REG);
+	writew((divisor >> 16) & 0xff,
+		priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_UPPER_REG);
+}
+
+static unsigned int load_ao_dma_buffer(comedi_device * dev,
+	const comedi_cmd * cmd)
+{
+	unsigned int num_bytes, buffer_index, prev_buffer_index;
+	unsigned int next_bits;
+
+	buffer_index = priv(dev)->ao_dma_index;
+	prev_buffer_index = prev_ao_dma_index(dev);
+
+	DEBUG_PRINT("attempting to load ao buffer %i (0x%x)\n", buffer_index,
+		priv(dev)->ao_buffer_bus_addr[buffer_index]);
+
+	num_bytes = comedi_buf_read_n_available(dev->write_subdev->async);
+	if (num_bytes > DMA_BUFFER_SIZE)
+		num_bytes = DMA_BUFFER_SIZE;
+	if (cmd->stop_src == TRIG_COUNT && num_bytes > priv(dev)->ao_count)
+		num_bytes = priv(dev)->ao_count;
+	num_bytes -= num_bytes % bytes_in_sample;
+
+	if (num_bytes == 0)
+		return 0;
+
+	DEBUG_PRINT("loading %i bytes\n", num_bytes);
+
+	num_bytes = cfc_read_array_from_buffer(dev->write_subdev,
+		priv(dev)->ao_buffer[buffer_index], num_bytes);
+	priv(dev)->ao_dma_desc[buffer_index].transfer_size =
+		cpu_to_le32(num_bytes);
+	/* set end of chain bit so we catch underruns */
+	next_bits = le32_to_cpu(priv(dev)->ao_dma_desc[buffer_index].next);
+	next_bits |= PLX_END_OF_CHAIN_BIT;
+	priv(dev)->ao_dma_desc[buffer_index].next = cpu_to_le32(next_bits);
+	/* clear end of chain bit on previous buffer now that we have set it
+	 * for the last buffer */
+	next_bits = le32_to_cpu(priv(dev)->ao_dma_desc[prev_buffer_index].next);
+	next_bits &= ~PLX_END_OF_CHAIN_BIT;
+	priv(dev)->ao_dma_desc[prev_buffer_index].next = cpu_to_le32(next_bits);
+
+	priv(dev)->ao_dma_index = (buffer_index + 1) % AO_DMA_RING_COUNT;
+	priv(dev)->ao_count -= num_bytes;
+
+	return num_bytes;
+}
+
+static void load_ao_dma(comedi_device * dev, const comedi_cmd * cmd)
+{
+	unsigned int num_bytes;
+	unsigned int next_transfer_addr;
+	void *pci_addr_reg =
+		priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+	unsigned int buffer_index;
+
+	do {
+		buffer_index = priv(dev)->ao_dma_index;
+		/* don't overwrite data that hasn't been transferred yet */
+		next_transfer_addr = readl(pci_addr_reg);
+		if (next_transfer_addr >=
+			priv(dev)->ao_buffer_bus_addr[buffer_index]
+			&& next_transfer_addr <
+			priv(dev)->ao_buffer_bus_addr[buffer_index] +
+			DMA_BUFFER_SIZE)
+			return;
+		num_bytes = load_ao_dma_buffer(dev, cmd);
+	} while (num_bytes >= DMA_BUFFER_SIZE);
+}
+
+static int prep_ao_dma(comedi_device * dev, const comedi_cmd * cmd)
+{
+	unsigned int num_bytes;
+	int i;
+
+	/* clear queue pointer too, since external queue has
+	 * weird interactions with ao fifo */
+	writew(0, priv(dev)->main_iobase + ADC_QUEUE_CLEAR_REG);
+	writew(0, priv(dev)->main_iobase + DAC_BUFFER_CLEAR_REG);
+
+	num_bytes = (DAC_FIFO_SIZE / 2) * bytes_in_sample;
+	if (cmd->stop_src == TRIG_COUNT &&
+		num_bytes / bytes_in_sample > priv(dev)->ao_count)
+		num_bytes = priv(dev)->ao_count * bytes_in_sample;
+	num_bytes = cfc_read_array_from_buffer(dev->write_subdev,
+		priv(dev)->ao_bounce_buffer, num_bytes);
+	for (i = 0; i < num_bytes / bytes_in_sample; i++) {
+		writew(priv(dev)->ao_bounce_buffer[i],
+			priv(dev)->main_iobase + DAC_FIFO_REG);
+	}
+	priv(dev)->ao_count -= num_bytes / bytes_in_sample;
+	if (cmd->stop_src == TRIG_COUNT && priv(dev)->ao_count == 0)
+		return 0;
+	num_bytes = load_ao_dma_buffer(dev, cmd);
+	if (num_bytes == 0)
+		return -1;
+	if (num_bytes >= DMA_BUFFER_SIZE) ;
+	load_ao_dma(dev, cmd);
+
+	dma_start_sync(dev, 0);
+
+	return 0;
+}
+
+static inline int external_ai_queue_in_use(comedi_device * dev)
+{
+	if (dev->read_subdev->busy)
+		return 0;
+	if (board(dev)->layout == LAYOUT_4020)
+		return 0;
+	else if (use_internal_queue_6xxx(&dev->read_subdev->async->cmd))
+		return 0;
+	return 1;
+}
+
+static int ao_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+
+	if (external_ai_queue_in_use(dev)) {
+		warn_external_queue(dev);
+		return -EBUSY;
+	}
+	/* disable analog output system during setup */
+	writew(0x0, priv(dev)->main_iobase + DAC_CONTROL0_REG);
+
+	priv(dev)->ao_dma_index = 0;
+	priv(dev)->ao_count = cmd->stop_arg * cmd->chanlist_len;
+
+	set_dac_select_reg(dev, cmd);
+	set_dac_interval_regs(dev, cmd);
+	load_first_dma_descriptor(dev, 0, priv(dev)->ao_dma_desc_bus_addr |
+		PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT);
+
+	set_dac_control1_reg(dev, cmd);
+	s->async->inttrig = ao_inttrig;
+
+	return 0;
+}
+
+static int ao_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trig_num)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	int retval;
+
+	if (trig_num != 0)
+		return -EINVAL;
+
+	retval = prep_ao_dma(dev, cmd);
+	if (retval < 0)
+		return -EPIPE;
+
+	set_dac_control0_reg(dev, cmd);
+
+	if (cmd->start_src == TRIG_INT)
+		writew(0, priv(dev)->main_iobase + DAC_START_REG);
+
+	s->async->inttrig = NULL;
+
+	return 0;
+}
+
+static int ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+	unsigned int tmp_arg;
+	int i;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_INT | TRIG_EXT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	// uniqueness check
+	if (cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)
+		err++;
+	if (cmd->scan_begin_src != TRIG_TIMER &&
+		cmd->scan_begin_src != TRIG_EXT)
+		err++;
+
+	// compatibility check
+	if (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT &&
+		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		if (cmd->scan_begin_arg < board(dev)->ao_scan_speed) {
+			cmd->scan_begin_arg = board(dev)->ao_scan_speed;
+			err++;
+		}
+		if (get_ao_divisor(cmd->scan_begin_arg,
+				cmd->flags) > max_counter_value) {
+			cmd->scan_begin_arg =
+				(max_counter_value + 2) * TIMER_BASE;
+			err++;
+		}
+	}
+
+	if (!cmd->chanlist_len) {
+		cmd->chanlist_len = 1;
+		err++;
+	}
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		tmp_arg = cmd->scan_begin_arg;
+		cmd->scan_begin_arg =
+			get_divisor(cmd->scan_begin_arg,
+			cmd->flags) * TIMER_BASE;
+		if (tmp_arg != cmd->scan_begin_arg)
+			err++;
+	}
+
+	if (err)
+		return 4;
+
+	if (cmd->chanlist) {
+		unsigned int first_channel = CR_CHAN(cmd->chanlist[0]);
+		for (i = 1; i < cmd->chanlist_len; i++) {
+			if (CR_CHAN(cmd->chanlist[i]) != first_channel + i) {
+				comedi_error(dev,
+					"chanlist must use consecutive channels");
+				err++;
+				break;
+			}
+		}
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+static int ao_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	writew(0x0, priv(dev)->main_iobase + DAC_CONTROL0_REG);
+	abort_dma(dev, 0);
+	return 0;
+}
+
+static int dio_callback(int dir, int port, int data, unsigned long iobase)
+{
+	if (dir) {
+		writeb(data, (void *)(iobase + port));
+		DEBUG_PRINT("wrote 0x%x to port %i\n", data, port);
+		return 0;
+	} else {
+		return readb((void *)(iobase + port));
+	}
+}
+
+static int dio_callback_4020(int dir, int port, int data, unsigned long iobase)
+{
+	if (dir) {
+		writew(data, (void *)(iobase + 2 * port));
+		return 0;
+	} else {
+		return readw((void *)(iobase + 2 * port));
+	}
+}
+
+static int di_rbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	lsampl_t bits;
+
+	bits = readb(priv(dev)->dio_counter_iobase + DI_REG);
+	bits &= 0xf;
+	data[1] = bits;
+	data[0] = 0;
+
+	return 2;
+}
+
+static int do_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] &= 0xf;
+	// zero bits we are going to change
+	s->state &= ~data[0];
+	// set new bits
+	s->state |= data[0] & data[1];
+
+	writeb(s->state, priv(dev)->dio_counter_iobase + DO_REG);
+
+	data[1] = s->state;
+
+	return 2;
+}
+
+static int dio_60xx_config_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned int mask;
+
+	mask = 1 << CR_CHAN(insn->chanspec);
+
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_INPUT:
+		s->io_bits &= ~mask;
+		break;
+	case INSN_CONFIG_DIO_OUTPUT:
+		s->io_bits |= mask;
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		return 2;
+	default:
+		return -EINVAL;
+	}
+
+	writeb(s->io_bits,
+		priv(dev)->dio_counter_iobase + DIO_DIRECTION_60XX_REG);
+
+	return 1;
+}
+
+static int dio_60xx_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	if (data[0]) {
+		s->state &= ~data[0];
+		s->state |= (data[0] & data[1]);
+		writeb(s->state,
+			priv(dev)->dio_counter_iobase + DIO_DATA_60XX_REG);
+	}
+
+	data[1] = readb(priv(dev)->dio_counter_iobase + DIO_DATA_60XX_REG);
+
+	return 2;
+}
+
+static void caldac_write(comedi_device * dev, unsigned int channel,
+	unsigned int value)
+{
+	priv(dev)->caldac_state[channel] = value;
+
+	switch (board(dev)->layout) {
+	case LAYOUT_60XX:
+	case LAYOUT_64XX:
+		caldac_8800_write(dev, channel, value);
+		break;
+	case LAYOUT_4020:
+		caldac_i2c_write(dev, channel, value);
+		break;
+	default:
+		break;
+	}
+}
+
+static int calib_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int channel = CR_CHAN(insn->chanspec);
+
+	/* return immediately if setting hasn't changed, since
+	 * programming these things is slow */
+	if (priv(dev)->caldac_state[channel] == data[0])
+		return 1;
+
+	caldac_write(dev, channel, data[0]);
+
+	return 1;
+}
+
+static int calib_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned int channel = CR_CHAN(insn->chanspec);
+
+	data[0] = priv(dev)->caldac_state[channel];
+
+	return 1;
+}
+
+static void ad8402_write(comedi_device * dev, unsigned int channel,
+	unsigned int value)
+{
+	static const int bitstream_length = 10;
+	unsigned int bit, register_bits;
+	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
+	static const int ad8402_comedi_udelay = 1;
+
+	priv(dev)->ad8402_state[channel] = value;
+
+	register_bits = SELECT_8402_64XX_BIT;
+	comedi_udelay(ad8402_comedi_udelay);
+	writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
+
+	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
+		if (bitstream & bit)
+			register_bits |= SERIAL_DATA_IN_BIT;
+		else
+			register_bits &= ~SERIAL_DATA_IN_BIT;
+		comedi_udelay(ad8402_comedi_udelay);
+		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
+		comedi_udelay(ad8402_comedi_udelay);
+		writew(register_bits | SERIAL_CLOCK_BIT,
+			priv(dev)->main_iobase + CALIBRATION_REG);
+	}
+
+	comedi_udelay(ad8402_comedi_udelay);
+	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
+}
+
+/* for pci-das6402/16, channel 0 is analog input gain and channel 1 is offset */
+static int ad8402_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int channel = CR_CHAN(insn->chanspec);
+
+	/* return immediately if setting hasn't changed, since
+	 * programming these things is slow */
+	if (priv(dev)->ad8402_state[channel] == data[0])
+		return 1;
+
+	priv(dev)->ad8402_state[channel] = data[0];
+
+	ad8402_write(dev, channel, data[0]);
+
+	return 1;
+}
+
+static int ad8402_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned int channel = CR_CHAN(insn->chanspec);
+
+	data[0] = priv(dev)->ad8402_state[channel];
+
+	return 1;
+}
+
+static uint16_t read_eeprom(comedi_device * dev, uint8_t address)
+{
+	static const int bitstream_length = 11;
+	static const int read_command = 0x6;
+	unsigned int bitstream = (read_command << 8) | address;
+	unsigned int bit;
+	void *const plx_control_addr =
+		priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
+	uint16_t value;
+	static const int value_length = 16;
+	static const int eeprom_comedi_udelay = 1;
+
+	comedi_udelay(eeprom_comedi_udelay);
+	priv(dev)->plx_control_bits &= ~CTL_EE_CLK & ~CTL_EE_CS;
+	// make sure we don't send anything to the i2c bus on 4020
+	priv(dev)->plx_control_bits |= CTL_USERO;
+	writel(priv(dev)->plx_control_bits, plx_control_addr);
+	// activate serial eeprom
+	comedi_udelay(eeprom_comedi_udelay);
+	priv(dev)->plx_control_bits |= CTL_EE_CS;
+	writel(priv(dev)->plx_control_bits, plx_control_addr);
+
+	// write read command and desired memory address
+	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
+		// set bit to be written
+		comedi_udelay(eeprom_comedi_udelay);
+		if (bitstream & bit)
+			priv(dev)->plx_control_bits |= CTL_EE_W;
+		else
+			priv(dev)->plx_control_bits &= ~CTL_EE_W;
+		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		// clock in bit
+		comedi_udelay(eeprom_comedi_udelay);
+		priv(dev)->plx_control_bits |= CTL_EE_CLK;
+		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		comedi_udelay(eeprom_comedi_udelay);
+		priv(dev)->plx_control_bits &= ~CTL_EE_CLK;
+		writel(priv(dev)->plx_control_bits, plx_control_addr);
+	}
+	// read back value from eeprom memory location
+	value = 0;
+	for (bit = 1 << (value_length - 1); bit; bit >>= 1) {
+		// clock out bit
+		comedi_udelay(eeprom_comedi_udelay);
+		priv(dev)->plx_control_bits |= CTL_EE_CLK;
+		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		comedi_udelay(eeprom_comedi_udelay);
+		priv(dev)->plx_control_bits &= ~CTL_EE_CLK;
+		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		comedi_udelay(eeprom_comedi_udelay);
+		if (readl(plx_control_addr) & CTL_EE_R)
+			value |= bit;
+	}
+
+	// deactivate eeprom serial input
+	comedi_udelay(eeprom_comedi_udelay);
+	priv(dev)->plx_control_bits &= ~CTL_EE_CS;
+	writel(priv(dev)->plx_control_bits, plx_control_addr);
+
+	return value;
+}
+
+static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = read_eeprom(dev, CR_CHAN(insn->chanspec));
+
+	return 1;
+}
+
+/* utility function that rounds desired timing to an achievable time, and
+ * sets cmd members appropriately.
+ * adc paces conversions from master clock by dividing by (x + 3) where x is 24 bit number
+ */
+static void check_adc_timing(comedi_device * dev, comedi_cmd * cmd)
+{
+	unsigned int convert_divisor = 0, scan_divisor;
+	static const int min_convert_divisor = 3;
+	static const int max_convert_divisor =
+		max_counter_value + min_convert_divisor;
+	static const int min_scan_divisor_4020 = 2;
+	unsigned long long max_scan_divisor, min_scan_divisor;
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (board(dev)->layout == LAYOUT_4020) {
+			cmd->convert_arg = 0;
+		} else {
+			convert_divisor =
+				get_divisor(cmd->convert_arg, cmd->flags);
+			if (convert_divisor > max_convert_divisor)
+				convert_divisor = max_convert_divisor;
+			if (convert_divisor < min_convert_divisor)
+				convert_divisor = min_convert_divisor;
+			cmd->convert_arg = convert_divisor * TIMER_BASE;
+		}
+	} else if (cmd->convert_src == TRIG_NOW)
+		cmd->convert_arg = 0;
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		scan_divisor = get_divisor(cmd->scan_begin_arg, cmd->flags);
+		if (cmd->convert_src == TRIG_TIMER) {
+			// XXX check for integer overflows
+			min_scan_divisor = convert_divisor * cmd->chanlist_len;
+			max_scan_divisor =
+				(convert_divisor * cmd->chanlist_len - 1) +
+				max_counter_value;
+		} else {
+			min_scan_divisor = min_scan_divisor_4020;
+			max_scan_divisor = max_counter_value + min_scan_divisor;
+		}
+		if (scan_divisor > max_scan_divisor)
+			scan_divisor = max_scan_divisor;
+		if (scan_divisor < min_scan_divisor)
+			scan_divisor = min_scan_divisor;
+		cmd->scan_begin_arg = scan_divisor * TIMER_BASE;
+	}
+
+	return;
+}
+
+/* Gets nearest achievable timing given master clock speed, does not
+ * take into account possible minimum/maximum divisor values.  Used
+ * by other timing checking functions. */
+static unsigned int get_divisor(unsigned int ns, unsigned int flags)
+{
+	unsigned int divisor;
+
+	switch (flags & TRIG_ROUND_MASK) {
+	case TRIG_ROUND_UP:
+		divisor = (ns + TIMER_BASE - 1) / TIMER_BASE;
+		break;
+	case TRIG_ROUND_DOWN:
+		divisor = ns / TIMER_BASE;
+		break;
+	case TRIG_ROUND_NEAREST:
+	default:
+		divisor = (ns + TIMER_BASE / 2) / TIMER_BASE;
+		break;
+	}
+	return divisor;
+}
+
+static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags)
+{
+	return get_divisor(ns, flags) - 2;
+}
+
+// adjusts the size of hardware fifo (which determines block size for dma xfers)
+static int set_ai_fifo_size(comedi_device * dev, unsigned int num_samples)
+{
+	unsigned int num_fifo_entries;
+	int retval;
+	const hw_fifo_info_t *const fifo = board(dev)->ai_fifo;
+
+	num_fifo_entries = num_samples / fifo->sample_packing_ratio;
+
+	retval = set_ai_fifo_segment_length(dev,
+		num_fifo_entries / fifo->num_segments);
+	if (retval < 0)
+		return retval;
+
+	num_samples = retval * fifo->num_segments * fifo->sample_packing_ratio;
+
+	DEBUG_PRINT("set hardware fifo size to %i\n", num_samples);
+
+	return num_samples;
+}
+
+// query length of fifo
+static unsigned int ai_fifo_size(comedi_device * dev)
+{
+	return priv(dev)->ai_fifo_segment_length *
+		board(dev)->ai_fifo->num_segments *
+		board(dev)->ai_fifo->sample_packing_ratio;
+}
+
+static int set_ai_fifo_segment_length(comedi_device * dev,
+	unsigned int num_entries)
+{
+	static const int increment_size = 0x100;
+	const hw_fifo_info_t *const fifo = board(dev)->ai_fifo;
+	unsigned int num_increments;
+	uint16_t bits;
+
+	if (num_entries < increment_size)
+		num_entries = increment_size;
+	if (num_entries > fifo->max_segment_length)
+		num_entries = fifo->max_segment_length;
+
+	// 1 == 256 entries, 2 == 512 entries, etc
+	num_increments = (num_entries + increment_size / 2) / increment_size;
+
+	bits = (~(num_increments - 1)) & fifo->fifo_size_reg_mask;
+	priv(dev)->fifo_size_bits &= ~fifo->fifo_size_reg_mask;
+	priv(dev)->fifo_size_bits |= bits;
+	writew(priv(dev)->fifo_size_bits,
+		priv(dev)->main_iobase + FIFO_SIZE_REG);
+
+	priv(dev)->ai_fifo_segment_length = num_increments * increment_size;
+
+	DEBUG_PRINT("set hardware fifo segment length to %i\n",
+		priv(dev)->ai_fifo_segment_length);
+
+	return priv(dev)->ai_fifo_segment_length;
+}
+
+/* pci-6025 8800 caldac:
+ * address 0 == dac channel 0 offset
+ * address 1 == dac channel 0 gain
+ * address 2 == dac channel 1 offset
+ * address 3 == dac channel 1 gain
+ * address 4 == fine adc offset
+ * address 5 == coarse adc offset
+ * address 6 == coarse adc gain
+ * address 7 == fine adc gain
+ */
+/* pci-6402/16 uses all 8 channels for dac:
+ * address 0 == dac channel 0 fine gain
+ * address 1 == dac channel 0 coarse gain
+ * address 2 == dac channel 0 coarse offset
+ * address 3 == dac channel 1 coarse offset
+ * address 4 == dac channel 1 fine gain
+ * address 5 == dac channel 1 coarse gain
+ * address 6 == dac channel 0 fine offset
+ * address 7 == dac channel 1 fine offset
+*/
+
+static int caldac_8800_write(comedi_device * dev, unsigned int address,
+	uint8_t value)
+{
+	static const int num_caldac_channels = 8;
+	static const int bitstream_length = 11;
+	unsigned int bitstream = ((address & 0x7) << 8) | value;
+	unsigned int bit, register_bits;
+	static const int caldac_8800_udelay = 1;
+
+	if (address >= num_caldac_channels) {
+		comedi_error(dev, "illegal caldac channel");
+		return -1;
+	}
+	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
+		register_bits = 0;
+		if (bitstream & bit)
+			register_bits |= SERIAL_DATA_IN_BIT;
+		comedi_udelay(caldac_8800_udelay);
+		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
+		register_bits |= SERIAL_CLOCK_BIT;
+		comedi_udelay(caldac_8800_udelay);
+		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
+	}
+	comedi_udelay(caldac_8800_udelay);
+	writew(SELECT_8800_BIT, priv(dev)->main_iobase + CALIBRATION_REG);
+	comedi_udelay(caldac_8800_udelay);
+	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
+	comedi_udelay(caldac_8800_udelay);
+	return 0;
+}
+
+// 4020 caldacs
+static int caldac_i2c_write(comedi_device * dev, unsigned int caldac_channel,
+	unsigned int value)
+{
+	uint8_t serial_bytes[3];
+	uint8_t i2c_addr;
+	enum pointer_bits {
+		// manual has gain and offset bits switched
+		OFFSET_0_2 = 0x1,
+		GAIN_0_2 = 0x2,
+		OFFSET_1_3 = 0x4,
+		GAIN_1_3 = 0x8,
+	};
+	enum data_bits {
+		NOT_CLEAR_REGISTERS = 0x20,
+	};
+
+	switch (caldac_channel) {
+	case 0:		// chan 0 offset
+		i2c_addr = CALDAC0_I2C_ADDR;
+		serial_bytes[0] = OFFSET_0_2;
+		break;
+	case 1:		// chan 1 offset
+		i2c_addr = CALDAC0_I2C_ADDR;
+		serial_bytes[0] = OFFSET_1_3;
+		break;
+	case 2:		// chan 2 offset
+		i2c_addr = CALDAC1_I2C_ADDR;
+		serial_bytes[0] = OFFSET_0_2;
+		break;
+	case 3:		// chan 3 offset
+		i2c_addr = CALDAC1_I2C_ADDR;
+		serial_bytes[0] = OFFSET_1_3;
+		break;
+	case 4:		// chan 0 gain
+		i2c_addr = CALDAC0_I2C_ADDR;
+		serial_bytes[0] = GAIN_0_2;
+		break;
+	case 5:		// chan 1 gain
+		i2c_addr = CALDAC0_I2C_ADDR;
+		serial_bytes[0] = GAIN_1_3;
+		break;
+	case 6:		// chan 2 gain
+		i2c_addr = CALDAC1_I2C_ADDR;
+		serial_bytes[0] = GAIN_0_2;
+		break;
+	case 7:		// chan 3 gain
+		i2c_addr = CALDAC1_I2C_ADDR;
+		serial_bytes[0] = GAIN_1_3;
+		break;
+	default:
+		comedi_error(dev, "invalid caldac channel\n");
+		return -1;
+		break;
+	}
+	serial_bytes[1] = NOT_CLEAR_REGISTERS | ((value >> 8) & 0xf);
+	serial_bytes[2] = value & 0xff;
+	i2c_write(dev, i2c_addr, serial_bytes, 3);
+	return 0;
+}
+
+// Their i2c requires a huge delay on setting clock or data high for some reason
+static const int i2c_high_comedi_udelay = 1000;
+static const int i2c_low_comedi_udelay = 10;
+
+// set i2c data line high or low
+static void i2c_set_sda(comedi_device * dev, int state)
+{
+	static const int data_bit = CTL_EE_W;
+	void *plx_control_addr = priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
+
+	if (state) {
+		// set data line high
+		priv(dev)->plx_control_bits &= ~data_bit;
+		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		comedi_udelay(i2c_high_comedi_udelay);
+	} else			// set data line low
+	{
+		priv(dev)->plx_control_bits |= data_bit;
+		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		comedi_udelay(i2c_low_comedi_udelay);
+	}
+}
+
+// set i2c clock line high or low
+static void i2c_set_scl(comedi_device * dev, int state)
+{
+	static const int clock_bit = CTL_USERO;
+	void *plx_control_addr = priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
+
+	if (state) {
+		// set clock line high
+		priv(dev)->plx_control_bits &= ~clock_bit;
+		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		comedi_udelay(i2c_high_comedi_udelay);
+	} else			// set clock line low
+	{
+		priv(dev)->plx_control_bits |= clock_bit;
+		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		comedi_udelay(i2c_low_comedi_udelay);
+	}
+}
+
+static void i2c_write_byte(comedi_device * dev, uint8_t byte)
+{
+	uint8_t bit;
+	unsigned int num_bits = 8;
+
+	DEBUG_PRINT("writing to i2c byte 0x%x\n", byte);
+
+	for (bit = 1 << (num_bits - 1); bit; bit >>= 1) {
+		i2c_set_scl(dev, 0);
+		if ((byte & bit))
+			i2c_set_sda(dev, 1);
+		else
+			i2c_set_sda(dev, 0);
+		i2c_set_scl(dev, 1);
+	}
+}
+
+// we can't really read the lines, so fake it
+static int i2c_read_ack(comedi_device * dev)
+{
+	i2c_set_scl(dev, 0);
+	i2c_set_sda(dev, 1);
+	i2c_set_scl(dev, 1);
+
+	return 0;		// return fake acknowledge bit
+}
+
+// send start bit
+static void i2c_start(comedi_device * dev)
+{
+	i2c_set_scl(dev, 1);
+	i2c_set_sda(dev, 1);
+	i2c_set_sda(dev, 0);
+}
+
+// send stop bit
+static void i2c_stop(comedi_device * dev)
+{
+	i2c_set_scl(dev, 0);
+	i2c_set_sda(dev, 0);
+	i2c_set_scl(dev, 1);
+	i2c_set_sda(dev, 1);
+}
+
+static void i2c_write(comedi_device * dev, unsigned int address,
+	const uint8_t * data, unsigned int length)
+{
+	unsigned int i;
+	uint8_t bitstream;
+	static const int read_bit = 0x1;
+
+//XXX need mutex to prevent simultaneous attempts to access eeprom and i2c bus
+
+	// make sure we dont send anything to eeprom
+	priv(dev)->plx_control_bits &= ~CTL_EE_CS;
+
+	i2c_stop(dev);
+	i2c_start(dev);
+
+	// send address and write bit
+	bitstream = (address << 1) & ~read_bit;
+	i2c_write_byte(dev, bitstream);
+
+	// get acknowledge
+	if (i2c_read_ack(dev) != 0) {
+		comedi_error(dev, "i2c write failed: no acknowledge");
+		i2c_stop(dev);
+		return;
+	}
+	// write data bytes
+	for (i = 0; i < length; i++) {
+		i2c_write_byte(dev, data[i]);
+		if (i2c_read_ack(dev) != 0) {
+			comedi_error(dev, "i2c write failed: no acknowledge");
+			i2c_stop(dev);
+			return;
+		}
+	}
+	i2c_stop(dev);
+}
