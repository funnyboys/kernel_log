commit 663d294b4768bfd89e529e069bffa544a830b5bf
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Apr 15 12:52:30 2019 +0100

    staging: comedi: vmk80xx: Fix possible double-free of ->usb_rx_buf
    
    `vmk80xx_alloc_usb_buffers()` is called from `vmk80xx_auto_attach()` to
    allocate RX and TX buffers for USB transfers.  It allocates
    `devpriv->usb_rx_buf` followed by `devpriv->usb_tx_buf`.  If the
    allocation of `devpriv->usb_tx_buf` fails, it frees
    `devpriv->usb_rx_buf`,  leaving the pointer set dangling, and returns an
    error.  Later, `vmk80xx_detach()` will be called from the core comedi
    module code to clean up.  `vmk80xx_detach()` also frees both
    `devpriv->usb_rx_buf` and `devpriv->usb_tx_buf`, but
    `devpriv->usb_rx_buf` may have already been freed, leading to a
    double-free error.  Fix it by removing the call to
    `kfree(devpriv->usb_rx_buf)` from `vmk80xx_alloc_usb_buffers()`, relying
    on `vmk80xx_detach()` to free the memory.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index b035d662390b..65dc6c51037e 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -682,10 +682,8 @@ static int vmk80xx_alloc_usb_buffers(struct comedi_device *dev)
 
 	size = usb_endpoint_maxp(devpriv->ep_tx);
 	devpriv->usb_tx_buf = kzalloc(size, GFP_KERNEL);
-	if (!devpriv->usb_tx_buf) {
-		kfree(devpriv->usb_rx_buf);
+	if (!devpriv->usb_tx_buf)
 		return -ENOMEM;
-	}
 
 	return 0;
 }

commit 08b7c2f9208f0e2a32159e4e7a4831b7adb10a3e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Apr 15 12:10:14 2019 +0100

    staging: comedi: vmk80xx: Fix use of uninitialized semaphore
    
    If `vmk80xx_auto_attach()` returns an error, the core comedi module code
    will call `vmk80xx_detach()` to clean up.  If `vmk80xx_auto_attach()`
    successfully allocated the comedi device private data,
    `vmk80xx_detach()` assumes that a `struct semaphore limit_sem` contained
    in the private data has been initialized and uses it.  Unfortunately,
    there are a couple of places where `vmk80xx_auto_attach()` can return an
    error after allocating the device private data but before initializing
    the semaphore, so this assumption is invalid.  Fix it by initializing
    the semaphore just after allocating the private data in
    `vmk80xx_auto_attach()` before any other errors can be returned.
    
    I believe this was the cause of the following syzbot crash report
    <https://syzkaller.appspot.com/bug?extid=54c2f58f15fe6876b6ad>:
    
    usb 1-1: config 0 has no interface number 0
    usb 1-1: New USB device found, idVendor=10cf, idProduct=8068, bcdDevice=e6.8d
    usb 1-1: New USB device strings: Mfr=0, Product=0, SerialNumber=0
    usb 1-1: config 0 descriptor??
    vmk80xx 1-1:0.117: driver 'vmk80xx' failed to auto-configure device.
    INFO: trying to register non-static key.
    the code is fine but needs lockdep annotation.
    turning off the locking correctness validator.
    CPU: 0 PID: 12 Comm: kworker/0:1 Not tainted 5.1.0-rc4-319354-g9a33b36 #3
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: usb_hub_wq hub_event
    Call Trace:
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0xe8/0x16e lib/dump_stack.c:113
     assign_lock_key kernel/locking/lockdep.c:786 [inline]
     register_lock_class+0x11b8/0x1250 kernel/locking/lockdep.c:1095
     __lock_acquire+0xfb/0x37c0 kernel/locking/lockdep.c:3582
     lock_acquire+0x10d/0x2f0 kernel/locking/lockdep.c:4211
     __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]
     _raw_spin_lock_irqsave+0x44/0x60 kernel/locking/spinlock.c:152
     down+0x12/0x80 kernel/locking/semaphore.c:58
     vmk80xx_detach+0x59/0x100 drivers/staging/comedi/drivers/vmk80xx.c:829
     comedi_device_detach+0xed/0x800 drivers/staging/comedi/drivers.c:204
     comedi_device_cleanup.part.0+0x68/0x140 drivers/staging/comedi/comedi_fops.c:156
     comedi_device_cleanup drivers/staging/comedi/comedi_fops.c:187 [inline]
     comedi_free_board_dev.part.0+0x16/0x90 drivers/staging/comedi/comedi_fops.c:190
     comedi_free_board_dev drivers/staging/comedi/comedi_fops.c:189 [inline]
     comedi_release_hardware_device+0x111/0x140 drivers/staging/comedi/comedi_fops.c:2880
     comedi_auto_config.cold+0x124/0x1b0 drivers/staging/comedi/drivers.c:1068
     usb_probe_interface+0x31d/0x820 drivers/usb/core/driver.c:361
     really_probe+0x2da/0xb10 drivers/base/dd.c:509
     driver_probe_device+0x21d/0x350 drivers/base/dd.c:671
     __device_attach_driver+0x1d8/0x290 drivers/base/dd.c:778
     bus_for_each_drv+0x163/0x1e0 drivers/base/bus.c:454
     __device_attach+0x223/0x3a0 drivers/base/dd.c:844
     bus_probe_device+0x1f1/0x2a0 drivers/base/bus.c:514
     device_add+0xad2/0x16e0 drivers/base/core.c:2106
     usb_set_configuration+0xdf7/0x1740 drivers/usb/core/message.c:2021
     generic_probe+0xa2/0xda drivers/usb/core/generic.c:210
     usb_probe_device+0xc0/0x150 drivers/usb/core/driver.c:266
     really_probe+0x2da/0xb10 drivers/base/dd.c:509
     driver_probe_device+0x21d/0x350 drivers/base/dd.c:671
     __device_attach_driver+0x1d8/0x290 drivers/base/dd.c:778
     bus_for_each_drv+0x163/0x1e0 drivers/base/bus.c:454
     __device_attach+0x223/0x3a0 drivers/base/dd.c:844
     bus_probe_device+0x1f1/0x2a0 drivers/base/bus.c:514
     device_add+0xad2/0x16e0 drivers/base/core.c:2106
     usb_new_device.cold+0x537/0xccf drivers/usb/core/hub.c:2534
     hub_port_connect drivers/usb/core/hub.c:5089 [inline]
     hub_port_connect_change drivers/usb/core/hub.c:5204 [inline]
     port_event drivers/usb/core/hub.c:5350 [inline]
     hub_event+0x138e/0x3b00 drivers/usb/core/hub.c:5432
     process_one_work+0x90f/0x1580 kernel/workqueue.c:2269
     worker_thread+0x9b/0xe20 kernel/workqueue.c:2415
     kthread+0x313/0x420 kernel/kthread.c:253
     ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:352
    
    Reported-by: syzbot+54c2f58f15fe6876b6ad@syzkaller.appspotmail.com
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 6234b649d887..b035d662390b 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -800,6 +800,8 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 
 	devpriv->model = board->model;
 
+	sema_init(&devpriv->limit_sem, 8);
+
 	ret = vmk80xx_find_usb_endpoints(dev);
 	if (ret)
 		return ret;
@@ -808,8 +810,6 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	sema_init(&devpriv->limit_sem, 8);
-
 	usb_set_intfdata(intf, devpriv);
 
 	if (devpriv->model == VMK8055_MODEL)

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 50c12e5db259..6234b649d887 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -7,16 +7,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index a004aed0147a..50c12e5db259 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * vmk80xx.c
  * Velleman USB Board Low-Level Driver

commit 62190d498c1d1cee970176840f24822fc14d27d1
Author: Cheah Kok Cheong <thrust73@gmail.com>
Date:   Fri Jul 22 23:29:39 2016 +0800

    staging: comedi: drivers: replace le16_to_cpu() with usb_endpoint_maxp()
    
    Use macro introduced in commit 939f325f4a0f
    ("usb: add usb_endpoint_maxp() macro")
    
    Signed-off-by: Cheah Kok Cheong <thrust73@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 8c7393ef762d..a004aed0147a 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -177,7 +177,7 @@ static void vmk80xx_do_bulk_msg(struct comedi_device *dev)
 	 * The max packet size attributes of the K8061
 	 * input/output endpoints are identical
 	 */
-	size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
+	size = usb_endpoint_maxp(devpriv->ep_tx);
 
 	usb_bulk_msg(usb, tx_pipe, devpriv->usb_tx_buf,
 		     size, NULL, devpriv->ep_tx->bInterval);
@@ -199,7 +199,7 @@ static int vmk80xx_read_packet(struct comedi_device *dev)
 	ep = devpriv->ep_rx;
 	pipe = usb_rcvintpipe(usb, ep->bEndpointAddress);
 	return usb_interrupt_msg(usb, pipe, devpriv->usb_rx_buf,
-				 le16_to_cpu(ep->wMaxPacketSize), NULL,
+				 usb_endpoint_maxp(ep), NULL,
 				 HZ * 10);
 }
 
@@ -220,7 +220,7 @@ static int vmk80xx_write_packet(struct comedi_device *dev, int cmd)
 	ep = devpriv->ep_tx;
 	pipe = usb_sndintpipe(usb, ep->bEndpointAddress);
 	return usb_interrupt_msg(usb, pipe, devpriv->usb_tx_buf,
-				 le16_to_cpu(ep->wMaxPacketSize), NULL,
+				 usb_endpoint_maxp(ep), NULL,
 				 HZ * 10);
 }
 
@@ -230,7 +230,7 @@ static int vmk80xx_reset_device(struct comedi_device *dev)
 	size_t size;
 	int retval;
 
-	size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
+	size = usb_endpoint_maxp(devpriv->ep_tx);
 	memset(devpriv->usb_tx_buf, 0, size);
 	retval = vmk80xx_write_packet(dev, VMK8055_CMD_RST);
 	if (retval)
@@ -684,12 +684,12 @@ static int vmk80xx_alloc_usb_buffers(struct comedi_device *dev)
 	struct vmk80xx_private *devpriv = dev->private;
 	size_t size;
 
-	size = le16_to_cpu(devpriv->ep_rx->wMaxPacketSize);
+	size = usb_endpoint_maxp(devpriv->ep_rx);
 	devpriv->usb_rx_buf = kzalloc(size, GFP_KERNEL);
 	if (!devpriv->usb_rx_buf)
 		return -ENOMEM;
 
-	size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
+	size = usb_endpoint_maxp(devpriv->ep_tx);
 	devpriv->usb_tx_buf = kzalloc(size, GFP_KERNEL);
 	if (!devpriv->usb_tx_buf) {
 		kfree(devpriv->usb_rx_buf);

commit c9b9cfe792feace71a2e0b4c079124b3f5f26ff2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 14 14:35:29 2015 -0700

    staging: comedi: vmk80xx: tidy up defines
    
    For aesthetics, use tabs instead of spaces for the whitespace.
    
    Convert the bit defines to use the preferred BIT macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 3293f1acebe3..8c7393ef762d 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -52,52 +52,52 @@ enum {
 	DEVICE_VMK8061
 };
 
-#define VMK8055_DI_REG          0x00
-#define VMK8055_DO_REG          0x01
-#define VMK8055_AO1_REG         0x02
-#define VMK8055_AO2_REG         0x03
-#define VMK8055_AI1_REG         0x02
-#define VMK8055_AI2_REG         0x03
-#define VMK8055_CNT1_REG        0x04
-#define VMK8055_CNT2_REG        0x06
-
-#define VMK8061_CH_REG          0x01
-#define VMK8061_DI_REG          0x01
-#define VMK8061_DO_REG          0x01
-#define VMK8061_PWM_REG1        0x01
-#define VMK8061_PWM_REG2        0x02
-#define VMK8061_CNT_REG         0x02
-#define VMK8061_AO_REG          0x02
-#define VMK8061_AI_REG1         0x02
-#define VMK8061_AI_REG2         0x03
-
-#define VMK8055_CMD_RST         0x00
-#define VMK8055_CMD_DEB1_TIME   0x01
-#define VMK8055_CMD_DEB2_TIME   0x02
-#define VMK8055_CMD_RST_CNT1    0x03
-#define VMK8055_CMD_RST_CNT2    0x04
-#define VMK8055_CMD_WRT_AD      0x05
-
-#define VMK8061_CMD_RD_AI       0x00
-#define VMK8061_CMR_RD_ALL_AI   0x01	/* !non-active! */
-#define VMK8061_CMD_SET_AO      0x02
-#define VMK8061_CMD_SET_ALL_AO  0x03	/* !non-active! */
-#define VMK8061_CMD_OUT_PWM     0x04
-#define VMK8061_CMD_RD_DI       0x05
-#define VMK8061_CMD_DO          0x06	/* !non-active! */
-#define VMK8061_CMD_CLR_DO      0x07
-#define VMK8061_CMD_SET_DO      0x08
-#define VMK8061_CMD_RD_CNT      0x09	/* TODO: completely pointless? */
-#define VMK8061_CMD_RST_CNT     0x0a	/* TODO: completely pointless? */
-#define VMK8061_CMD_RD_VERSION  0x0b	/* internal usage */
-#define VMK8061_CMD_RD_JMP_STAT 0x0c	/* TODO: not implemented yet */
-#define VMK8061_CMD_RD_PWR_STAT 0x0d	/* internal usage */
-#define VMK8061_CMD_RD_DO       0x0e
-#define VMK8061_CMD_RD_AO       0x0f
-#define VMK8061_CMD_RD_PWM      0x10
-
-#define IC3_VERSION             (1 << 0)
-#define IC6_VERSION             (1 << 1)
+#define VMK8055_DI_REG		0x00
+#define VMK8055_DO_REG		0x01
+#define VMK8055_AO1_REG		0x02
+#define VMK8055_AO2_REG		0x03
+#define VMK8055_AI1_REG		0x02
+#define VMK8055_AI2_REG		0x03
+#define VMK8055_CNT1_REG	0x04
+#define VMK8055_CNT2_REG	0x06
+
+#define VMK8061_CH_REG		0x01
+#define VMK8061_DI_REG		0x01
+#define VMK8061_DO_REG		0x01
+#define VMK8061_PWM_REG1	0x01
+#define VMK8061_PWM_REG2	0x02
+#define VMK8061_CNT_REG		0x02
+#define VMK8061_AO_REG		0x02
+#define VMK8061_AI_REG1		0x02
+#define VMK8061_AI_REG2		0x03
+
+#define VMK8055_CMD_RST		0x00
+#define VMK8055_CMD_DEB1_TIME	0x01
+#define VMK8055_CMD_DEB2_TIME	0x02
+#define VMK8055_CMD_RST_CNT1	0x03
+#define VMK8055_CMD_RST_CNT2	0x04
+#define VMK8055_CMD_WRT_AD	0x05
+
+#define VMK8061_CMD_RD_AI	0x00
+#define VMK8061_CMR_RD_ALL_AI	0x01	/* !non-active! */
+#define VMK8061_CMD_SET_AO	0x02
+#define VMK8061_CMD_SET_ALL_AO	0x03	/* !non-active! */
+#define VMK8061_CMD_OUT_PWM	0x04
+#define VMK8061_CMD_RD_DI	0x05
+#define VMK8061_CMD_DO		0x06	/* !non-active! */
+#define VMK8061_CMD_CLR_DO	0x07
+#define VMK8061_CMD_SET_DO	0x08
+#define VMK8061_CMD_RD_CNT	0x09	/* TODO: completely pointless? */
+#define VMK8061_CMD_RST_CNT	0x0a	/* TODO: completely pointless? */
+#define VMK8061_CMD_RD_VERSION	0x0b	/* internal usage */
+#define VMK8061_CMD_RD_JMP_STAT	0x0c	/* TODO: not implemented yet */
+#define VMK8061_CMD_RD_PWR_STAT	0x0d	/* internal usage */
+#define VMK8061_CMD_RD_DO	0x0e
+#define VMK8061_CMD_RD_AO	0x0f
+#define VMK8061_CMD_RD_PWM	0x10
+
+#define IC3_VERSION		BIT(0)
+#define IC6_VERSION		BIT(1)
 
 enum vmk80xx_model {
 	VMK8055_MODEL,

commit 0726f06d176c015f4ed5f27b661eb1da1ea6f633
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 14 14:35:28 2015 -0700

    staging: comedi: vmk80xx: cleanup multi-line comment
    
    Reformat the multi-line comment in the kernel CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 3af075aa3946..3293f1acebe3 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1,22 +1,23 @@
 /*
-    comedi/drivers/vmk80xx.c
-    Velleman USB Board Low-Level Driver
-
-    Copyright (C) 2009 Manuel Gebele <forensixs@gmx.de>, Germany
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
+ * vmk80xx.c
+ * Velleman USB Board Low-Level Driver
+ *
+ * Copyright (C) 2009 Manuel Gebele <forensixs@gmx.de>, Germany
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
 /*
  * Driver: vmk80xx
  * Description: Velleman USB Board Low-Level Driver

commit e38576ce7301ddd5e39b969e3f2a136002fb429d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 18 10:54:57 2015 -0700

    staging: comedi: vmk80xx: sanity check context used to get the boardinfo
    
    As done in all the comedi drivers that auto attach, sanity check the
    passed context that is used to get the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index a87b1523165e..3af075aa3946 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -795,7 +795,10 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 	struct vmk80xx_private *devpriv;
 	int ret;
 
-	board = &vmk80xx_boardinfo[context];
+	if (context < ARRAY_SIZE(vmk80xx_boardinfo))
+		board = &vmk80xx_boardinfo[context];
+	if (!board)
+		return -ENODEV;
 	dev->board_ptr = board;
 	dev->board_name = board->name;
 

commit adda9ab042326572237df7fd6be42f746206a385
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 18 10:54:56 2015 -0700

    staging: comedi: vmk80xx: rename 'boardinfo' variables
    
    For aesthetics, rename the 'boardinfo' variables to 'board'. That name
    is more commonly used for the boardinfo pointer in comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index a0906685e27f..a87b1523165e 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -700,7 +700,7 @@ static int vmk80xx_alloc_usb_buffers(struct comedi_device *dev)
 
 static int vmk80xx_init_subdevices(struct comedi_device *dev)
 {
-	const struct vmk80xx_board *boardinfo = dev->board_ptr;
+	const struct vmk80xx_board *board = dev->board_ptr;
 	struct vmk80xx_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	int n_subd;
@@ -722,18 +722,18 @@ static int vmk80xx_init_subdevices(struct comedi_device *dev)
 	s = &dev->subdevices[0];
 	s->type		= COMEDI_SUBD_AI;
 	s->subdev_flags	= SDF_READABLE | SDF_GROUND;
-	s->n_chan	= boardinfo->ai_nchans;
-	s->maxdata	= boardinfo->ai_maxdata;
-	s->range_table	= boardinfo->range;
+	s->n_chan	= board->ai_nchans;
+	s->maxdata	= board->ai_maxdata;
+	s->range_table	= board->range;
 	s->insn_read	= vmk80xx_ai_insn_read;
 
 	/* Analog output subdevice */
 	s = &dev->subdevices[1];
 	s->type		= COMEDI_SUBD_AO;
 	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND;
-	s->n_chan	= boardinfo->ao_nchans;
+	s->n_chan	= board->ao_nchans;
 	s->maxdata	= 0x00ff;
-	s->range_table	= boardinfo->range;
+	s->range_table	= board->range;
 	s->insn_write	= vmk80xx_ao_insn_write;
 	if (devpriv->model == VMK8061_MODEL) {
 		s->subdev_flags	|= SDF_READABLE;
@@ -744,7 +744,7 @@ static int vmk80xx_init_subdevices(struct comedi_device *dev)
 	s = &dev->subdevices[2];
 	s->type		= COMEDI_SUBD_DI;
 	s->subdev_flags	= SDF_READABLE;
-	s->n_chan	= boardinfo->di_nchans;
+	s->n_chan	= board->di_nchans;
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
 	s->insn_bits	= vmk80xx_di_insn_bits;
@@ -763,7 +763,7 @@ static int vmk80xx_init_subdevices(struct comedi_device *dev)
 	s->type		= COMEDI_SUBD_COUNTER;
 	s->subdev_flags	= SDF_READABLE;
 	s->n_chan	= 2;
-	s->maxdata	= boardinfo->cnt_maxdata;
+	s->maxdata	= board->cnt_maxdata;
 	s->insn_read	= vmk80xx_cnt_insn_read;
 	s->insn_config	= vmk80xx_cnt_insn_config;
 	if (devpriv->model == VMK8055_MODEL) {
@@ -776,8 +776,8 @@ static int vmk80xx_init_subdevices(struct comedi_device *dev)
 		s = &dev->subdevices[5];
 		s->type		= COMEDI_SUBD_PWM;
 		s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
-		s->n_chan	= boardinfo->pwm_nchans;
-		s->maxdata	= boardinfo->pwm_maxdata;
+		s->n_chan	= board->pwm_nchans;
+		s->maxdata	= board->pwm_maxdata;
 		s->insn_read	= vmk80xx_pwm_insn_read;
 		s->insn_write	= vmk80xx_pwm_insn_write;
 	}
@@ -791,19 +791,19 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 			       unsigned long context)
 {
 	struct usb_interface *intf = comedi_to_usb_interface(dev);
-	const struct vmk80xx_board *boardinfo;
+	const struct vmk80xx_board *board = NULL;
 	struct vmk80xx_private *devpriv;
 	int ret;
 
-	boardinfo = &vmk80xx_boardinfo[context];
-	dev->board_ptr = boardinfo;
-	dev->board_name = boardinfo->name;
+	board = &vmk80xx_boardinfo[context];
+	dev->board_ptr = board;
+	dev->board_name = board->name;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
 
-	devpriv->model = boardinfo->model;
+	devpriv->model = board->model;
 
 	ret = vmk80xx_find_usb_endpoints(dev);
 	if (ret)

commit 981c1fe9ae20e5fb7c1ee7038efa03933e637925
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 15:13:49 2015 -0700

    staging: comedi: vmk80xx: remove "firmware version" kernel messages
    
    During the attach of this driver a couple commands are sent to the hardware
    with usb_bulk_msg() to read the firmware version information. This information
    is then dumped as dev_info() kernel messages. Thee messages are just added
    noise and don't effect the operation of the driver.
    
    For simplicity, remove the messages as well as the then unused functions
    vmk80xx_read_eeprom() and vmk80xx_check_data_link().
    
    This also fixes an issue reported by coverity about an out-of-bounds write
    in vmk80xx_read_eeprom().
    
    Reported-by: coverity (CID 711413)
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index e37118321a27..a0906685e27f 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -103,11 +103,6 @@ enum vmk80xx_model {
 	VMK8061_MODEL
 };
 
-struct firmware_version {
-	unsigned char ic3_vers[32];	/* USB-Controller */
-	unsigned char ic6_vers[32];	/* CPU */
-};
-
 static const struct comedi_lrange vmk8061_range = {
 	2, {
 		UNI_RANGE(5),
@@ -156,68 +151,12 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 struct vmk80xx_private {
 	struct usb_endpoint_descriptor *ep_rx;
 	struct usb_endpoint_descriptor *ep_tx;
-	struct firmware_version fw;
 	struct semaphore limit_sem;
 	unsigned char *usb_rx_buf;
 	unsigned char *usb_tx_buf;
 	enum vmk80xx_model model;
 };
 
-static int vmk80xx_check_data_link(struct comedi_device *dev)
-{
-	struct vmk80xx_private *devpriv = dev->private;
-	struct usb_device *usb = comedi_to_usb_dev(dev);
-	unsigned int tx_pipe;
-	unsigned int rx_pipe;
-	unsigned char tx[1];
-	unsigned char rx[2];
-
-	tx_pipe = usb_sndbulkpipe(usb, 0x01);
-	rx_pipe = usb_rcvbulkpipe(usb, 0x81);
-
-	tx[0] = VMK8061_CMD_RD_PWR_STAT;
-
-	/*
-	 * Check that IC6 (PIC16F871) is powered and
-	 * running and the data link between IC3 and
-	 * IC6 is working properly
-	 */
-	usb_bulk_msg(usb, tx_pipe, tx, 1, NULL, devpriv->ep_tx->bInterval);
-	usb_bulk_msg(usb, rx_pipe, rx, 2, NULL, HZ * 10);
-
-	return (int)rx[1];
-}
-
-static void vmk80xx_read_eeprom(struct comedi_device *dev, int flag)
-{
-	struct vmk80xx_private *devpriv = dev->private;
-	struct usb_device *usb = comedi_to_usb_dev(dev);
-	unsigned int tx_pipe;
-	unsigned int rx_pipe;
-	unsigned char tx[1];
-	unsigned char rx[64];
-	int cnt;
-
-	tx_pipe = usb_sndbulkpipe(usb, 0x01);
-	rx_pipe = usb_rcvbulkpipe(usb, 0x81);
-
-	tx[0] = VMK8061_CMD_RD_VERSION;
-
-	/*
-	 * Read the firmware version info of IC3 and
-	 * IC6 from the internal EEPROM of the IC
-	 */
-	usb_bulk_msg(usb, tx_pipe, tx, 1, NULL, devpriv->ep_tx->bInterval);
-	usb_bulk_msg(usb, rx_pipe, rx, 64, &cnt, HZ * 10);
-
-	rx[cnt] = '\0';
-
-	if (flag & IC3_VERSION)
-		strncpy(devpriv->fw.ic3_vers, rx + 1, 24);
-	else			/* IC6_VERSION */
-		strncpy(devpriv->fw.ic6_vers, rx + 25, 24);
-}
-
 static void vmk80xx_do_bulk_msg(struct comedi_device *dev)
 {
 	struct vmk80xx_private *devpriv = dev->private;
@@ -878,16 +817,6 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 
 	usb_set_intfdata(intf, devpriv);
 
-	if (devpriv->model == VMK8061_MODEL) {
-		vmk80xx_read_eeprom(dev, IC3_VERSION);
-		dev_info(&intf->dev, "%s\n", devpriv->fw.ic3_vers);
-
-		if (vmk80xx_check_data_link(dev)) {
-			vmk80xx_read_eeprom(dev, IC6_VERSION);
-			dev_info(&intf->dev, "%s\n", devpriv->fw.ic6_vers);
-		}
-	}
-
 	if (devpriv->model == VMK8055_MODEL)
 		vmk80xx_reset_device(dev);
 

commit cf7661c74e2a051132f64440fc40cd46c06b60dc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jan 27 17:49:08 2015 +0000

    staging: comedi: vmk80xx: include new "comedi_usb.h" header
    
    Include the new "../comedi_usb.h" header instead of <linux/usb.h> and
    "../comedidev.h", which will now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index eb76460e806f..e37118321a27 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -42,10 +42,9 @@
 #include <linux/input.h>
 #include <linux/slab.h>
 #include <linux/poll.h>
-#include <linux/usb.h>
 #include <linux/uaccess.h>
 
-#include "../comedidev.h"
+#include "../comedi_usb.h"
 
 enum {
 	DEVICE_VMK8055,

commit a4a75b21014bfb4ab977e461e17d2c759472f84b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 21 17:22:14 2015 -0700

    staging: comedi: vmk80xx: tidy up vmk80xx_cnt_insn_config()
    
    Tidy up this (*insn_config) function to follow the normal format in
    comedi drivers.
    
    INSN_CONFIG_RESET instructions do not have any extra parameters (insn->n is
    always 1) so the for loop used to write the packet doesn't make any sense.
    Remove it and just write the single packet.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index d200ad52e728..eb76460e806f 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -551,41 +551,35 @@ static int vmk80xx_cnt_insn_config(struct comedi_device *dev,
 				   unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
-	unsigned int insn_cmd;
-	int chan;
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	int cmd;
 	int reg;
-	int n;
-
-	insn_cmd = data[0];
-	if (insn_cmd != INSN_CONFIG_RESET)
-		return -EINVAL;
+	int ret;
 
 	down(&devpriv->limit_sem);
-
-	chan = CR_CHAN(insn->chanspec);
-
-	if (devpriv->model == VMK8055_MODEL) {
-		if (!chan) {
-			cmd = VMK8055_CMD_RST_CNT1;
-			reg = VMK8055_CNT1_REG;
+	switch (data[0]) {
+	case INSN_CONFIG_RESET:
+		if (devpriv->model == VMK8055_MODEL) {
+			if (!chan) {
+				cmd = VMK8055_CMD_RST_CNT1;
+				reg = VMK8055_CNT1_REG;
+			} else {
+				cmd = VMK8055_CMD_RST_CNT2;
+				reg = VMK8055_CNT2_REG;
+			}
+			devpriv->usb_tx_buf[reg] = 0x00;
 		} else {
-			cmd = VMK8055_CMD_RST_CNT2;
-			reg = VMK8055_CNT2_REG;
+			cmd = VMK8061_CMD_RST_CNT;
 		}
-
-		devpriv->usb_tx_buf[reg] = 0x00;
-	} else {
-		cmd = VMK8061_CMD_RST_CNT;
+		ret = vmk80xx_write_packet(dev, cmd);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
 	}
-
-	for (n = 0; n < insn->n; n++)
-		if (vmk80xx_write_packet(dev, cmd))
-			break;
-
 	up(&devpriv->limit_sem);
 
-	return n;
+	return ret ? ret : insn->n;
 }
 
 static int vmk80xx_cnt_insn_write(struct comedi_device *dev,

commit 8518a52c4456c697033bf81f0df73c026200ad8e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 21 17:22:13 2015 -0700

    staging: comedi: vmk80xx: GPCT_RESET is not an (*insn_config) instruction
    
    The data[0] parameter to (*insn_config) functions is the "configuration instruction"
    that should be handled. These are defined by the enum configuration_ids in comedi.h.
    
    This driver is currently checking the data[0] value to be INSN_CONFIG_RESET or
    GPCT_RESET in order to reset a counter channel. GPCT_RESET is defined as 0x0001
    which would match the configuration instruction INSN_CONFIG_DIO_OUTPUT. That doesn't
    make any sense for a counter.
    
    Remove GPCT_RESET from the insn_cmd test.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 5312e0fff79c..d200ad52e728 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -558,7 +558,7 @@ static int vmk80xx_cnt_insn_config(struct comedi_device *dev,
 	int n;
 
 	insn_cmd = data[0];
-	if (insn_cmd != INSN_CONFIG_RESET && insn_cmd != GPCT_RESET)
+	if (insn_cmd != INSN_CONFIG_RESET)
 		return -EINVAL;
 
 	down(&devpriv->limit_sem);

commit b1ad96846bc08ded159dfd9700727c225abb9c04
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 5 17:55:13 2015 +0000

    staging: comedi: vm80xx: rewrite comedi driver comment block
    
    Rewrite the comedi "driver" comment block to conform to the usual format
    for comedi driver comment blocks and reformat it to use the usual block
    comment style.  In particular, the "Devices:" line should be a
    comma-separated list where the first item is in the following format:
    
      [Manufacturer] BOARD-NAME (comedi-board-name)
    
    The "[Manufacturer]" and/or "(comedi-board-name)" parts may be omitted
    from following items, in which case the parts from the preceding item
    are used.  The "Devices:" line may be continued continued over several
    lines by using one or more spaces at the start of each continuation line
    (not counting the space after the "*" in the block comment).
    
    Note that the comedi board names I've added to the "Devices:" line don't
    quite match the board names reported by the driver itself, as they
    contain parentheses and I don't want nested parentheses on the
    "Devices:" line (mostly because it confuses a script I use to extract
    supported devices from the driver comments).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index a19a56ee0eef..5312e0fff79c 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -18,21 +18,22 @@
     GNU General Public License for more details.
 */
 /*
-Driver: vmk80xx
-Description: Velleman USB Board Low-Level Driver
-Devices: K8055/K8061 aka VM110/VM140
-Author: Manuel Gebele <forensixs@gmx.de>
-Updated: Sun, 10 May 2009 11:14:59 +0200
-Status: works
-
-Supports:
- - analog input
- - analog output
- - digital input
- - digital output
- - counter
- - pwm
-*/
+ * Driver: vmk80xx
+ * Description: Velleman USB Board Low-Level Driver
+ * Devices: [Velleman] K8055 (K8055/VM110), K8061 (K8061/VM140),
+ *   VM110 (K8055/VM110), VM140 (K8061/VM140)
+ * Author: Manuel Gebele <forensixs@gmx.de>
+ * Updated: Sun, 10 May 2009 11:14:59 +0200
+ * Status: works
+ *
+ * Supports:
+ *  - analog input
+ *  - analog output
+ *  - digital input
+ *  - digital output
+ *  - counter
+ *  - pwm
+ */
 
 #include <linux/kernel.h>
 #include <linux/module.h>

commit ef49d8329e25ee1686520315713b86419cddcb45
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Oct 30 11:19:34 2014 -0700

    staging: comedi: drivers: replace SDF_WRITEABLE with SDF_WRITABLE
    
    As indicated in the comedi.h uapi header, SDF_WRITEABLE was a spelling
    error in the API, SDF_WRITABLE is prefered.
    
    For aesthetics, replace all the SDF_WRITEABLE uses with SDF_WRITABLE.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 71003416edcf..a19a56ee0eef 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -797,7 +797,7 @@ static int vmk80xx_init_subdevices(struct comedi_device *dev)
 	/* Analog output subdevice */
 	s = &dev->subdevices[1];
 	s->type		= COMEDI_SUBD_AO;
-	s->subdev_flags	= SDF_WRITEABLE | SDF_GROUND;
+	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND;
 	s->n_chan	= boardinfo->ao_nchans;
 	s->maxdata	= 0x00ff;
 	s->range_table	= boardinfo->range;
@@ -819,7 +819,7 @@ static int vmk80xx_init_subdevices(struct comedi_device *dev)
 	/* Digital output subdevice */
 	s = &dev->subdevices[3];
 	s->type		= COMEDI_SUBD_DO;
-	s->subdev_flags	= SDF_WRITEABLE;
+	s->subdev_flags	= SDF_WRITABLE;
 	s->n_chan	= 8;
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
@@ -834,7 +834,7 @@ static int vmk80xx_init_subdevices(struct comedi_device *dev)
 	s->insn_read	= vmk80xx_cnt_insn_read;
 	s->insn_config	= vmk80xx_cnt_insn_config;
 	if (devpriv->model == VMK8055_MODEL) {
-		s->subdev_flags	|= SDF_WRITEABLE;
+		s->subdev_flags	|= SDF_WRITABLE;
 		s->insn_write	= vmk80xx_cnt_insn_write;
 	}
 
@@ -842,7 +842,7 @@ static int vmk80xx_init_subdevices(struct comedi_device *dev)
 	if (devpriv->model == VMK8061_MODEL) {
 		s = &dev->subdevices[5];
 		s->type		= COMEDI_SUBD_PWM;
-		s->subdev_flags	= SDF_READABLE | SDF_WRITEABLE;
+		s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
 		s->n_chan	= boardinfo->pwm_nchans;
 		s->maxdata	= boardinfo->pwm_maxdata;
 		s->insn_read	= vmk80xx_pwm_insn_read;

commit 957b9f8b41473f113c64ca234120de52d8bf59f8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:57 2014 +0100

    staging: comedi: vmk80xx: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 831c3b702899..71003416edcf 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -767,7 +767,7 @@ static int vmk80xx_alloc_usb_buffers(struct comedi_device *dev)
 
 static int vmk80xx_init_subdevices(struct comedi_device *dev)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(dev);
+	const struct vmk80xx_board *boardinfo = dev->board_ptr;
 	struct vmk80xx_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	int n_subd;

commit 99948ba7c8eef166979cf5b0c466f48cabba82f2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 10 12:45:43 2014 +0100

    staging: comedi: vmk80xx: remove MODULE_VERSION() from in-kernel module
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 0adf3cffddb0..831c3b702899 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -959,5 +959,4 @@ module_comedi_usb_driver(vmk80xx_driver, vmk80xx_usb_driver);
 MODULE_AUTHOR("Manuel Gebele <forensixs@gmx.de>");
 MODULE_DESCRIPTION("Velleman USB Board Low-Level Driver");
 MODULE_SUPPORTED_DEVICE("K8055/K8061 aka VM110/VM140");
-MODULE_VERSION("0.8.01");
 MODULE_LICENSE("GPL");

commit c16975a06cfbbdedfde89e81bd00c7e0ad9de377
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Mon Nov 11 12:31:51 2013 +0100

    staging: comedi: fix potentially uninitialised variable
    
    If none of the if conditions take a true path, the ret variable will
    never be assigned a value.
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 933b01a0f03d..0adf3cffddb0 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -465,7 +465,7 @@ static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 	unsigned char *rx_buf = devpriv->usb_rx_buf;
 	unsigned char *tx_buf = devpriv->usb_tx_buf;
 	int reg, cmd;
-	int ret;
+	int ret = 0;
 
 	if (devpriv->model == VMK8061_MODEL) {
 		reg = VMK8061_DO_REG;

commit 6f617e544b26d4232659402da42924e8cd6b1eaf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:06:58 2013 -0700

    staging: comedi: vmk80xx: use comedi_dio_update_state()
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state.
    
    Tidy up the vmk80xx_do_insn_bits() function a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 06efa16b9af2..933b01a0f03d 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -462,9 +462,10 @@ static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 				unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
-	unsigned char *rx_buf, *tx_buf;
+	unsigned char *rx_buf = devpriv->usb_rx_buf;
+	unsigned char *tx_buf = devpriv->usb_tx_buf;
 	int reg, cmd;
-	int retval;
+	int ret;
 
 	if (devpriv->model == VMK8061_MODEL) {
 		reg = VMK8061_DO_REG;
@@ -476,37 +477,27 @@ static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 
 	down(&devpriv->limit_sem);
 
-	rx_buf = devpriv->usb_rx_buf;
-	tx_buf = devpriv->usb_tx_buf;
-
-	if (data[0]) {
-		tx_buf[reg] &= ~data[0];
-		tx_buf[reg] |= (data[0] & data[1]);
-
-		retval = vmk80xx_write_packet(dev, cmd);
-
-		if (retval)
+	if (comedi_dio_update_state(s, data)) {
+		tx_buf[reg] = s->state;
+		ret = vmk80xx_write_packet(dev, cmd);
+		if (ret)
 			goto out;
 	}
 
 	if (devpriv->model == VMK8061_MODEL) {
 		tx_buf[0] = VMK8061_CMD_RD_DO;
-
-		retval = vmk80xx_read_packet(dev);
-
-		if (!retval) {
-			data[1] = rx_buf[reg];
-			retval = 2;
-		}
+		ret = vmk80xx_read_packet(dev);
+		if (ret)
+			goto out;
+		data[1] = rx_buf[reg];
 	} else {
-		data[1] = tx_buf[reg];
-		retval = 2;
+		data[1] = s->state;
 	}
 
 out:
 	up(&devpriv->limit_sem);
 
-	return retval;
+	return ret ? ret : insn->n;
 }
 
 static int vmk80xx_cnt_insn_read(struct comedi_device *dev,

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 0ab04c0dd410..06efa16b9af2 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -875,10 +875,9 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 	dev->board_ptr = boardinfo;
 	dev->board_name = boardinfo->name;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	devpriv->model = boardinfo->model;
 

commit e23322e43a271cb8ebf1bc750dffffeebfe46043
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 20 14:27:13 2013 -0700

    staging: comedi: vmk80xx: remove usb_interface from private data
    
    This driver uses the comedi auto attach mechanism so the comedi_device
    will always have an associated usb_interface and usb_device.
    
    Remove the unnecessary checks if the comedi_device has a usb_interface
    attached. This also allows removing the usb_interface from the private
    data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 2cf0e50592cf..0ab04c0dd410 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -154,7 +154,6 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 };
 
 struct vmk80xx_private {
-	struct usb_interface *intf;
 	struct usb_endpoint_descriptor *ep_rx;
 	struct usb_endpoint_descriptor *ep_tx;
 	struct firmware_version fw;
@@ -252,9 +251,6 @@ static int vmk80xx_read_packet(struct comedi_device *dev)
 	struct usb_endpoint_descriptor *ep;
 	unsigned int pipe;
 
-	if (!devpriv->intf)
-		return -ENODEV;
-
 	if (devpriv->model == VMK8061_MODEL) {
 		vmk80xx_do_bulk_msg(dev);
 		return 0;
@@ -274,9 +270,6 @@ static int vmk80xx_write_packet(struct comedi_device *dev, int cmd)
 	struct usb_endpoint_descriptor *ep;
 	unsigned int pipe;
 
-	if (!devpriv->intf)
-		return -ENODEV;
-
 	devpriv->usb_tx_buf[0] = cmd;
 
 	if (devpriv->model == VMK8061_MODEL) {
@@ -729,7 +722,7 @@ static int vmk80xx_pwm_insn_write(struct comedi_device *dev,
 static int vmk80xx_find_usb_endpoints(struct comedi_device *dev)
 {
 	struct vmk80xx_private *devpriv = dev->private;
-	struct usb_interface *intf = devpriv->intf;
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usb_host_interface *iface_desc = intf->cur_altsetting;
 	struct usb_endpoint_descriptor *ep_desc;
 	int i;
@@ -887,7 +880,6 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	devpriv->intf = intf;
 	devpriv->model = boardinfo->model;
 
 	ret = vmk80xx_find_usb_endpoints(dev);
@@ -920,6 +912,7 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 
 static void vmk80xx_detach(struct comedi_device *dev)
 {
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct vmk80xx_private *devpriv = dev->private;
 
 	if (!devpriv)
@@ -927,7 +920,7 @@ static void vmk80xx_detach(struct comedi_device *dev)
 
 	down(&devpriv->limit_sem);
 
-	usb_set_intfdata(devpriv->intf, NULL);
+	usb_set_intfdata(intf, NULL);
 
 	kfree(devpriv->usb_rx_buf);
 	kfree(devpriv->usb_tx_buf);

commit db4c3eb795696b7f6132d183b1bbe561b54c98c6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 20 14:26:01 2013 -0700

    staging: comedi: vmk80xx: use comedi_to_usb_dev()
    
    Use the helper function to get a usb_device pointer from a
    comedi_device pointer. This removes the need carring the
    usb_device pointer in the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 5e67877601da..2cf0e50592cf 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -154,7 +154,6 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 };
 
 struct vmk80xx_private {
-	struct usb_device *usb;
 	struct usb_interface *intf;
 	struct usb_endpoint_descriptor *ep_rx;
 	struct usb_endpoint_descriptor *ep_tx;
@@ -168,7 +167,7 @@ struct vmk80xx_private {
 static int vmk80xx_check_data_link(struct comedi_device *dev)
 {
 	struct vmk80xx_private *devpriv = dev->private;
-	struct usb_device *usb = devpriv->usb;
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	unsigned int tx_pipe;
 	unsigned int rx_pipe;
 	unsigned char tx[1];
@@ -193,7 +192,7 @@ static int vmk80xx_check_data_link(struct comedi_device *dev)
 static void vmk80xx_read_eeprom(struct comedi_device *dev, int flag)
 {
 	struct vmk80xx_private *devpriv = dev->private;
-	struct usb_device *usb = devpriv->usb;
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	unsigned int tx_pipe;
 	unsigned int rx_pipe;
 	unsigned char tx[1];
@@ -223,7 +222,7 @@ static void vmk80xx_read_eeprom(struct comedi_device *dev, int flag)
 static void vmk80xx_do_bulk_msg(struct comedi_device *dev)
 {
 	struct vmk80xx_private *devpriv = dev->private;
-	struct usb_device *usb = devpriv->usb;
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	__u8 tx_addr;
 	__u8 rx_addr;
 	unsigned int tx_pipe;
@@ -249,7 +248,7 @@ static void vmk80xx_do_bulk_msg(struct comedi_device *dev)
 static int vmk80xx_read_packet(struct comedi_device *dev)
 {
 	struct vmk80xx_private *devpriv = dev->private;
-	struct usb_device *usb;
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usb_endpoint_descriptor *ep;
 	unsigned int pipe;
 
@@ -261,7 +260,6 @@ static int vmk80xx_read_packet(struct comedi_device *dev)
 		return 0;
 	}
 
-	usb = devpriv->usb;
 	ep = devpriv->ep_rx;
 	pipe = usb_rcvintpipe(usb, ep->bEndpointAddress);
 	return usb_interrupt_msg(usb, pipe, devpriv->usb_rx_buf,
@@ -272,7 +270,7 @@ static int vmk80xx_read_packet(struct comedi_device *dev)
 static int vmk80xx_write_packet(struct comedi_device *dev, int cmd)
 {
 	struct vmk80xx_private *devpriv = dev->private;
-	struct usb_device *usb;
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usb_endpoint_descriptor *ep;
 	unsigned int pipe;
 
@@ -286,7 +284,6 @@ static int vmk80xx_write_packet(struct comedi_device *dev, int cmd)
 		return 0;
 	}
 
-	usb = devpriv->usb;
 	ep = devpriv->ep_tx;
 	pipe = usb_sndintpipe(usb, ep->bEndpointAddress);
 	return usb_interrupt_msg(usb, pipe, devpriv->usb_tx_buf,
@@ -890,7 +887,6 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	devpriv->usb = interface_to_usbdev(intf);
 	devpriv->intf = intf;
 	devpriv->model = boardinfo->model;
 

commit 0703c9553847b31cf34a7a04a839806fb361422f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 20 14:24:32 2013 -0700

    staging: comedi: vmk80xx: don't pass the private data directly
    
    Instead of passing the private data to the internal functions. pass
    the comedi_device pointer and get the private data from it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index f55c656d053c..5e67877601da 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -165,8 +165,9 @@ struct vmk80xx_private {
 	enum vmk80xx_model model;
 };
 
-static int vmk80xx_check_data_link(struct vmk80xx_private *devpriv)
+static int vmk80xx_check_data_link(struct comedi_device *dev)
 {
+	struct vmk80xx_private *devpriv = dev->private;
 	struct usb_device *usb = devpriv->usb;
 	unsigned int tx_pipe;
 	unsigned int rx_pipe;
@@ -189,8 +190,9 @@ static int vmk80xx_check_data_link(struct vmk80xx_private *devpriv)
 	return (int)rx[1];
 }
 
-static void vmk80xx_read_eeprom(struct vmk80xx_private *devpriv, int flag)
+static void vmk80xx_read_eeprom(struct comedi_device *dev, int flag)
 {
+	struct vmk80xx_private *devpriv = dev->private;
 	struct usb_device *usb = devpriv->usb;
 	unsigned int tx_pipe;
 	unsigned int rx_pipe;
@@ -218,8 +220,9 @@ static void vmk80xx_read_eeprom(struct vmk80xx_private *devpriv, int flag)
 		strncpy(devpriv->fw.ic6_vers, rx + 25, 24);
 }
 
-static void vmk80xx_do_bulk_msg(struct vmk80xx_private *devpriv)
+static void vmk80xx_do_bulk_msg(struct comedi_device *dev)
 {
+	struct vmk80xx_private *devpriv = dev->private;
 	struct usb_device *usb = devpriv->usb;
 	__u8 tx_addr;
 	__u8 rx_addr;
@@ -243,8 +246,9 @@ static void vmk80xx_do_bulk_msg(struct vmk80xx_private *devpriv)
 	usb_bulk_msg(usb, rx_pipe, devpriv->usb_rx_buf, size, NULL, HZ * 10);
 }
 
-static int vmk80xx_read_packet(struct vmk80xx_private *devpriv)
+static int vmk80xx_read_packet(struct comedi_device *dev)
 {
+	struct vmk80xx_private *devpriv = dev->private;
 	struct usb_device *usb;
 	struct usb_endpoint_descriptor *ep;
 	unsigned int pipe;
@@ -253,7 +257,7 @@ static int vmk80xx_read_packet(struct vmk80xx_private *devpriv)
 		return -ENODEV;
 
 	if (devpriv->model == VMK8061_MODEL) {
-		vmk80xx_do_bulk_msg(devpriv);
+		vmk80xx_do_bulk_msg(dev);
 		return 0;
 	}
 
@@ -265,8 +269,9 @@ static int vmk80xx_read_packet(struct vmk80xx_private *devpriv)
 				 HZ * 10);
 }
 
-static int vmk80xx_write_packet(struct vmk80xx_private *devpriv, int cmd)
+static int vmk80xx_write_packet(struct comedi_device *dev, int cmd)
 {
+	struct vmk80xx_private *devpriv = dev->private;
 	struct usb_device *usb;
 	struct usb_endpoint_descriptor *ep;
 	unsigned int pipe;
@@ -277,7 +282,7 @@ static int vmk80xx_write_packet(struct vmk80xx_private *devpriv, int cmd)
 	devpriv->usb_tx_buf[0] = cmd;
 
 	if (devpriv->model == VMK8061_MODEL) {
-		vmk80xx_do_bulk_msg(devpriv);
+		vmk80xx_do_bulk_msg(dev);
 		return 0;
 	}
 
@@ -289,18 +294,19 @@ static int vmk80xx_write_packet(struct vmk80xx_private *devpriv, int cmd)
 				 HZ * 10);
 }
 
-static int vmk80xx_reset_device(struct vmk80xx_private *devpriv)
+static int vmk80xx_reset_device(struct comedi_device *dev)
 {
+	struct vmk80xx_private *devpriv = dev->private;
 	size_t size;
 	int retval;
 
 	size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
 	memset(devpriv->usb_tx_buf, 0, size);
-	retval = vmk80xx_write_packet(devpriv, VMK8055_CMD_RST);
+	retval = vmk80xx_write_packet(dev, VMK8055_CMD_RST);
 	if (retval)
 		return retval;
 	/* set outputs to known state as we cannot read them */
-	return vmk80xx_write_packet(devpriv, VMK8055_CMD_WRT_AD);
+	return vmk80xx_write_packet(dev, VMK8055_CMD_WRT_AD);
 }
 
 static int vmk80xx_ai_insn_read(struct comedi_device *dev,
@@ -333,7 +339,7 @@ static int vmk80xx_ai_insn_read(struct comedi_device *dev,
 	}
 
 	for (n = 0; n < insn->n; n++) {
-		if (vmk80xx_read_packet(devpriv))
+		if (vmk80xx_read_packet(dev))
 			break;
 
 		if (devpriv->model == VMK8055_MODEL) {
@@ -383,7 +389,7 @@ static int vmk80xx_ao_insn_write(struct comedi_device *dev,
 	for (n = 0; n < insn->n; n++) {
 		devpriv->usb_tx_buf[reg] = data[n];
 
-		if (vmk80xx_write_packet(devpriv, cmd))
+		if (vmk80xx_write_packet(dev, cmd))
 			break;
 	}
 
@@ -410,7 +416,7 @@ static int vmk80xx_ao_insn_read(struct comedi_device *dev,
 	devpriv->usb_tx_buf[0] = VMK8061_CMD_RD_AO;
 
 	for (n = 0; n < insn->n; n++) {
-		if (vmk80xx_read_packet(devpriv))
+		if (vmk80xx_read_packet(dev))
 			break;
 
 		data[n] = devpriv->usb_rx_buf[reg + chan];
@@ -442,7 +448,7 @@ static int vmk80xx_di_insn_bits(struct comedi_device *dev,
 		reg = VMK8055_DI_REG;
 	}
 
-	retval = vmk80xx_read_packet(devpriv);
+	retval = vmk80xx_read_packet(dev);
 
 	if (!retval) {
 		if (devpriv->model == VMK8055_MODEL)
@@ -487,7 +493,7 @@ static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 		tx_buf[reg] &= ~data[0];
 		tx_buf[reg] |= (data[0] & data[1]);
 
-		retval = vmk80xx_write_packet(devpriv, cmd);
+		retval = vmk80xx_write_packet(dev, cmd);
 
 		if (retval)
 			goto out;
@@ -496,7 +502,7 @@ static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 	if (devpriv->model == VMK8061_MODEL) {
 		tx_buf[0] = VMK8061_CMD_RD_DO;
 
-		retval = vmk80xx_read_packet(devpriv);
+		retval = vmk80xx_read_packet(dev);
 
 		if (!retval) {
 			data[1] = rx_buf[reg];
@@ -542,7 +548,7 @@ static int vmk80xx_cnt_insn_read(struct comedi_device *dev,
 	}
 
 	for (n = 0; n < insn->n; n++) {
-		if (vmk80xx_read_packet(devpriv))
+		if (vmk80xx_read_packet(dev))
 			break;
 
 		if (devpriv->model == VMK8055_MODEL)
@@ -592,7 +598,7 @@ static int vmk80xx_cnt_insn_config(struct comedi_device *dev,
 	}
 
 	for (n = 0; n < insn->n; n++)
-		if (vmk80xx_write_packet(devpriv, cmd))
+		if (vmk80xx_write_packet(dev, cmd))
 			break;
 
 	up(&devpriv->limit_sem);
@@ -635,7 +641,7 @@ static int vmk80xx_cnt_insn_write(struct comedi_device *dev,
 
 		devpriv->usb_tx_buf[6 + chan] = val;
 
-		if (vmk80xx_write_packet(devpriv, cmd))
+		if (vmk80xx_write_packet(dev, cmd))
 			break;
 	}
 
@@ -666,7 +672,7 @@ static int vmk80xx_pwm_insn_read(struct comedi_device *dev,
 	tx_buf[0] = VMK8061_CMD_RD_PWM;
 
 	for (n = 0; n < insn->n; n++) {
-		if (vmk80xx_read_packet(devpriv))
+		if (vmk80xx_read_packet(dev))
 			break;
 
 		data[n] = rx_buf[reg[0]] + 4 * rx_buf[reg[1]];
@@ -714,7 +720,7 @@ static int vmk80xx_pwm_insn_write(struct comedi_device *dev,
 		tx_buf[reg[0]] = (unsigned char)(data[n] & 0x03);
 		tx_buf[reg[1]] = (unsigned char)(data[n] >> 2) & 0xff;
 
-		if (vmk80xx_write_packet(devpriv, cmd))
+		if (vmk80xx_write_packet(dev, cmd))
 			break;
 	}
 
@@ -901,17 +907,17 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 	usb_set_intfdata(intf, devpriv);
 
 	if (devpriv->model == VMK8061_MODEL) {
-		vmk80xx_read_eeprom(devpriv, IC3_VERSION);
+		vmk80xx_read_eeprom(dev, IC3_VERSION);
 		dev_info(&intf->dev, "%s\n", devpriv->fw.ic3_vers);
 
-		if (vmk80xx_check_data_link(devpriv)) {
-			vmk80xx_read_eeprom(devpriv, IC6_VERSION);
+		if (vmk80xx_check_data_link(dev)) {
+			vmk80xx_read_eeprom(dev, IC6_VERSION);
 			dev_info(&intf->dev, "%s\n", devpriv->fw.ic6_vers);
 		}
 	}
 
 	if (devpriv->model == VMK8055_MODEL)
-		vmk80xx_reset_device(devpriv);
+		vmk80xx_reset_device(dev);
 
 	return vmk80xx_init_subdevices(dev);
 }

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 2be5087414f6..f55c656d053c 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -16,11 +16,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
 */
 /*
 Driver: vmk80xx

commit 951348b377385475aa256c27e1c9e2564c9ec160
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Feb 18 11:15:55 2013 +0000

    staging: comedi: vmk80xx: wait for URBs to complete
    
    For Velleman K8055 (aka VM110), `vmk80xx_read_packet()` and
    `vmk8055_write_packet()` send an URB asynchronously and do not wait for
    it complete.  However, callers of `vmk80xx_read_packet()` are assuming
    the contents of the data buffer `devpriv->usb_rx_buf` are valid
    immediately after that function returns.
    
    For Velleman K8061 (aka VM140), `vmk80xx_read_packet()` and
    `vmk80xx_write_packet()` punt the requests to `vmk80xx_do_bulk_msg()`
    which *does* wait for the URBs to complete (albeit with no error
    checking!).
    
    Change `vmk80xx_read_packet()` and `vmk80xx_write_packet()` to use
    `usb_interrupt_msg()` for the K8055, so the callers of
    `vmk80xx_read_packet()` can assume the data buffer contents are valid
    (if no error occurred).  Remove all the code for checking for transfers
    in progress and busy waiting, as it's no longer needed.  Pretty much all
    the callers of `vmk80xx_read_packet()` and `vmk80xx_write_packet()` hold
    the same semaphore anyway, and the only caller that doesn't
    (`vmk80xx_reset_device()` called during initialization of the device)
    doesn't really matter.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 7984e036c041..2be5087414f6 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -100,16 +100,9 @@ enum {
 #define VMK8061_CMD_RD_AO       0x0f
 #define VMK8061_CMD_RD_PWM      0x10
 
-#define TRANS_OUT_BUSY          1
-#define TRANS_IN_BUSY           2
-#define TRANS_IN_RUNNING        3
-
 #define IC3_VERSION             (1 << 0)
 #define IC6_VERSION             (1 << 1)
 
-#define URB_RCV_FLAG            (1 << 0)
-#define URB_SND_FLAG            (1 << 1)
-
 enum vmk80xx_model {
 	VMK8055_MODEL,
 	VMK8061_MODEL
@@ -170,60 +163,13 @@ struct vmk80xx_private {
 	struct usb_interface *intf;
 	struct usb_endpoint_descriptor *ep_rx;
 	struct usb_endpoint_descriptor *ep_tx;
-	struct usb_anchor rx_anchor;
-	struct usb_anchor tx_anchor;
 	struct firmware_version fw;
 	struct semaphore limit_sem;
-	wait_queue_head_t read_wait;
-	wait_queue_head_t write_wait;
 	unsigned char *usb_rx_buf;
 	unsigned char *usb_tx_buf;
-	unsigned long flags;
 	enum vmk80xx_model model;
 };
 
-static void vmk80xx_tx_callback(struct urb *urb)
-{
-	struct vmk80xx_private *devpriv = urb->context;
-	unsigned long *flags = &devpriv->flags;
-
-	if (!test_bit(TRANS_OUT_BUSY, flags))
-		return;
-
-	clear_bit(TRANS_OUT_BUSY, flags);
-
-	wake_up_interruptible(&devpriv->write_wait);
-}
-
-static void vmk80xx_rx_callback(struct urb *urb)
-{
-	struct vmk80xx_private *devpriv = urb->context;
-	unsigned long *flags = &devpriv->flags;
-	int stat = urb->status;
-
-	switch (stat) {
-	case 0:
-		break;
-	case -ENOENT:
-	case -ECONNRESET:
-	case -ESHUTDOWN:
-		break;
-	default:
-		/* Try to resubmit the urb */
-		if (test_bit(TRANS_IN_RUNNING, flags) && devpriv->intf) {
-			usb_anchor_urb(urb, &devpriv->rx_anchor);
-
-			if (usb_submit_urb(urb, GFP_KERNEL))
-				usb_unanchor_urb(urb);
-		}
-		break;
-	}
-
-	clear_bit(TRANS_IN_BUSY, flags);
-
-	wake_up_interruptible(&devpriv->read_wait);
-}
-
 static int vmk80xx_check_data_link(struct vmk80xx_private *devpriv)
 {
 	struct usb_device *usb = devpriv->usb;
@@ -277,50 +223,15 @@ static void vmk80xx_read_eeprom(struct vmk80xx_private *devpriv, int flag)
 		strncpy(devpriv->fw.ic6_vers, rx + 25, 24);
 }
 
-static void vmk80xx_build_int_urb(struct urb *urb, int flag)
-{
-	struct vmk80xx_private *devpriv = urb->context;
-	struct usb_device *usb = devpriv->usb;
-	__u8 rx_addr;
-	__u8 tx_addr;
-	unsigned int pipe;
-	unsigned char *buf;
-	size_t size;
-	void (*callback) (struct urb *);
-	int ival;
-
-	if (flag & URB_RCV_FLAG) {
-		rx_addr = devpriv->ep_rx->bEndpointAddress;
-		pipe = usb_rcvintpipe(usb, rx_addr);
-		buf = devpriv->usb_rx_buf;
-		size = le16_to_cpu(devpriv->ep_rx->wMaxPacketSize);
-		callback = vmk80xx_rx_callback;
-		ival = devpriv->ep_rx->bInterval;
-	} else {		/* URB_SND_FLAG */
-		tx_addr = devpriv->ep_tx->bEndpointAddress;
-		pipe = usb_sndintpipe(usb, tx_addr);
-		buf = devpriv->usb_tx_buf;
-		size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
-		callback = vmk80xx_tx_callback;
-		ival = devpriv->ep_tx->bInterval;
-	}
-
-	usb_fill_int_urb(urb, usb, pipe, buf, size, callback, devpriv, ival);
-}
-
 static void vmk80xx_do_bulk_msg(struct vmk80xx_private *devpriv)
 {
 	struct usb_device *usb = devpriv->usb;
-	unsigned long *flags = &devpriv->flags;
 	__u8 tx_addr;
 	__u8 rx_addr;
 	unsigned int tx_pipe;
 	unsigned int rx_pipe;
 	size_t size;
 
-	set_bit(TRANS_IN_BUSY, flags);
-	set_bit(TRANS_OUT_BUSY, flags);
-
 	tx_addr = devpriv->ep_tx->bEndpointAddress;
 	rx_addr = devpriv->ep_rx->bEndpointAddress;
 	tx_pipe = usb_sndbulkpipe(usb, tx_addr);
@@ -335,102 +246,52 @@ static void vmk80xx_do_bulk_msg(struct vmk80xx_private *devpriv)
 	usb_bulk_msg(usb, tx_pipe, devpriv->usb_tx_buf,
 		     size, NULL, devpriv->ep_tx->bInterval);
 	usb_bulk_msg(usb, rx_pipe, devpriv->usb_rx_buf, size, NULL, HZ * 10);
-
-	clear_bit(TRANS_OUT_BUSY, flags);
-	clear_bit(TRANS_IN_BUSY, flags);
 }
 
 static int vmk80xx_read_packet(struct vmk80xx_private *devpriv)
 {
-	unsigned long *flags = &devpriv->flags;
-	struct urb *urb;
-	int retval;
+	struct usb_device *usb;
+	struct usb_endpoint_descriptor *ep;
+	unsigned int pipe;
 
 	if (!devpriv->intf)
 		return -ENODEV;
 
-	/* Only useful for interrupt transfers */
-	if (test_bit(TRANS_IN_BUSY, flags))
-		if (wait_event_interruptible(devpriv->read_wait,
-					     !test_bit(TRANS_IN_BUSY, flags)))
-			return -ERESTART;
-
 	if (devpriv->model == VMK8061_MODEL) {
 		vmk80xx_do_bulk_msg(devpriv);
-
 		return 0;
 	}
 
-	urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!urb)
-		return -ENOMEM;
-
-	urb->context = devpriv;
-	vmk80xx_build_int_urb(urb, URB_RCV_FLAG);
-
-	set_bit(TRANS_IN_RUNNING, flags);
-	set_bit(TRANS_IN_BUSY, flags);
-
-	usb_anchor_urb(urb, &devpriv->rx_anchor);
-
-	retval = usb_submit_urb(urb, GFP_KERNEL);
-	if (!retval)
-		goto exit;
-
-	clear_bit(TRANS_IN_RUNNING, flags);
-	usb_unanchor_urb(urb);
-
-exit:
-	usb_free_urb(urb);
-
-	return retval;
+	usb = devpriv->usb;
+	ep = devpriv->ep_rx;
+	pipe = usb_rcvintpipe(usb, ep->bEndpointAddress);
+	return usb_interrupt_msg(usb, pipe, devpriv->usb_rx_buf,
+				 le16_to_cpu(ep->wMaxPacketSize), NULL,
+				 HZ * 10);
 }
 
 static int vmk80xx_write_packet(struct vmk80xx_private *devpriv, int cmd)
 {
-	unsigned long *flags = &devpriv->flags;
-	struct urb *urb;
-	int retval;
+	struct usb_device *usb;
+	struct usb_endpoint_descriptor *ep;
+	unsigned int pipe;
 
 	if (!devpriv->intf)
 		return -ENODEV;
 
-	if (test_bit(TRANS_OUT_BUSY, flags))
-		if (wait_event_interruptible(devpriv->write_wait,
-					     !test_bit(TRANS_OUT_BUSY, flags)))
-			return -ERESTART;
+	devpriv->usb_tx_buf[0] = cmd;
 
 	if (devpriv->model == VMK8061_MODEL) {
-		devpriv->usb_tx_buf[0] = cmd;
 		vmk80xx_do_bulk_msg(devpriv);
-
 		return 0;
 	}
 
-	urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!urb)
-		return -ENOMEM;
-
-	urb->context = devpriv;
-	vmk80xx_build_int_urb(urb, URB_SND_FLAG);
-
-	set_bit(TRANS_OUT_BUSY, flags);
-
-	usb_anchor_urb(urb, &devpriv->tx_anchor);
-
-	devpriv->usb_tx_buf[0] = cmd;
-
-	retval = usb_submit_urb(urb, GFP_KERNEL);
-	if (!retval)
-		goto exit;
-
-	clear_bit(TRANS_OUT_BUSY, flags);
-	usb_unanchor_urb(urb);
-
-exit:
-	usb_free_urb(urb);
-
-	return retval;
+	usb = devpriv->usb;
+	ep = devpriv->ep_tx;
+	pipe = usb_sndintpipe(usb, ep->bEndpointAddress);
+	return usb_interrupt_msg(usb, pipe, devpriv->usb_tx_buf,
+				 le16_to_cpu(ep->wMaxPacketSize), NULL,
+				 HZ * 10);
 }
 
 static int vmk80xx_reset_device(struct vmk80xx_private *devpriv)
@@ -447,25 +308,6 @@ static int vmk80xx_reset_device(struct vmk80xx_private *devpriv)
 	return vmk80xx_write_packet(devpriv, VMK8055_CMD_WRT_AD);
 }
 
-#define DIR_IN  1
-#define DIR_OUT 2
-
-static int rudimentary_check(struct vmk80xx_private *devpriv, int dir)
-{
-	if (!devpriv)
-		return -EFAULT;
-	if (dir & DIR_IN) {
-		if (test_bit(TRANS_IN_BUSY, &devpriv->flags))
-			return -EBUSY;
-	}
-	if (dir & DIR_OUT) {
-		if (test_bit(TRANS_OUT_BUSY, &devpriv->flags))
-			return -EBUSY;
-	}
-
-	return 0;
-}
-
 static int vmk80xx_ai_insn_read(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn,
@@ -476,10 +318,6 @@ static int vmk80xx_ai_insn_read(struct comedi_device *dev,
 	int reg[2];
 	int n;
 
-	n = rudimentary_check(devpriv, DIR_IN);
-	if (n)
-		return n;
-
 	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
@@ -529,10 +367,6 @@ static int vmk80xx_ao_insn_write(struct comedi_device *dev,
 	int reg;
 	int n;
 
-	n = rudimentary_check(devpriv, DIR_OUT);
-	if (n)
-		return n;
-
 	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
@@ -573,10 +407,6 @@ static int vmk80xx_ao_insn_read(struct comedi_device *dev,
 	int reg;
 	int n;
 
-	n = rudimentary_check(devpriv, DIR_IN);
-	if (n)
-		return n;
-
 	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
@@ -606,10 +436,6 @@ static int vmk80xx_di_insn_bits(struct comedi_device *dev,
 	int reg;
 	int retval;
 
-	retval = rudimentary_check(devpriv, DIR_IN);
-	if (retval)
-		return retval;
-
 	down(&devpriv->limit_sem);
 
 	rx_buf = devpriv->usb_rx_buf;
@@ -646,16 +472,10 @@ static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	unsigned char *rx_buf, *tx_buf;
-	int dir, reg, cmd;
+	int reg, cmd;
 	int retval;
 
-	dir = 0;
-
-	if (data[0])
-		dir |= DIR_OUT;
-
 	if (devpriv->model == VMK8061_MODEL) {
-		dir |= DIR_IN;
 		reg = VMK8061_DO_REG;
 		cmd = VMK8061_CMD_DO;
 	} else { /* VMK8055_MODEL */
@@ -663,10 +483,6 @@ static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 		cmd = VMK8055_CMD_WRT_AD;
 	}
 
-	retval = rudimentary_check(devpriv, dir);
-	if (retval)
-		return retval;
-
 	down(&devpriv->limit_sem);
 
 	rx_buf = devpriv->usb_rx_buf;
@@ -712,10 +528,6 @@ static int vmk80xx_cnt_insn_read(struct comedi_device *dev,
 	int reg[2];
 	int n;
 
-	n = rudimentary_check(devpriv, DIR_IN);
-	if (n)
-		return n;
-
 	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
@@ -762,10 +574,6 @@ static int vmk80xx_cnt_insn_config(struct comedi_device *dev,
 	int reg;
 	int n;
 
-	n = rudimentary_check(devpriv, DIR_OUT);
-	if (n)
-		return n;
-
 	insn_cmd = data[0];
 	if (insn_cmd != INSN_CONFIG_RESET && insn_cmd != GPCT_RESET)
 		return -EINVAL;
@@ -809,10 +617,6 @@ static int vmk80xx_cnt_insn_write(struct comedi_device *dev,
 	int cmd;
 	int n;
 
-	n = rudimentary_check(devpriv, DIR_OUT);
-	if (n)
-		return n;
-
 	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
@@ -856,10 +660,6 @@ static int vmk80xx_pwm_insn_read(struct comedi_device *dev,
 	int reg[2];
 	int n;
 
-	n = rudimentary_check(devpriv, DIR_IN);
-	if (n)
-		return n;
-
 	down(&devpriv->limit_sem);
 
 	tx_buf = devpriv->usb_tx_buf;
@@ -893,10 +693,6 @@ static int vmk80xx_pwm_insn_write(struct comedi_device *dev,
 	int cmd;
 	int n;
 
-	n = rudimentary_check(devpriv, DIR_OUT);
-	if (n)
-		return n;
-
 	down(&devpriv->limit_sem);
 
 	tx_buf = devpriv->usb_tx_buf;
@@ -1106,11 +902,6 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 		return ret;
 
 	sema_init(&devpriv->limit_sem, 8);
-	init_waitqueue_head(&devpriv->read_wait);
-	init_waitqueue_head(&devpriv->write_wait);
-
-	init_usb_anchor(&devpriv->rx_anchor);
-	init_usb_anchor(&devpriv->tx_anchor);
 
 	usb_set_intfdata(intf, devpriv);
 
@@ -1141,9 +932,6 @@ static void vmk80xx_detach(struct comedi_device *dev)
 
 	usb_set_intfdata(devpriv->intf, NULL);
 
-	usb_kill_anchored_urbs(&devpriv->rx_anchor);
-	usb_kill_anchored_urbs(&devpriv->tx_anchor);
-
 	kfree(devpriv->usb_rx_buf);
 	kfree(devpriv->usb_tx_buf);
 

commit f06a23c93b900c37ef14858868c00dc8f061fa22
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Feb 14 16:42:15 2013 +0000

    staging: comedi: vmk80xx: initialize K8055 outputs to known state
    
    vmk8055_reset_device() is called during initialization of a Velleman
    K8055 (aka VM110) to send a reset command to the hardware.  I don't know
    what this does, but I know that it doesn't reset the digital outputs as
    I've tried it.  Since the hardware does not have any way to query the
    current output values and there is only the one command to update all
    the analog and digital outputs simultaneously (VMK8055_CMD_WRT_AD), send
    this command during initialization to set all the analog and digital
    outputs to a known state.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 057d840b90de..7984e036c041 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -436,10 +436,15 @@ static int vmk80xx_write_packet(struct vmk80xx_private *devpriv, int cmd)
 static int vmk80xx_reset_device(struct vmk80xx_private *devpriv)
 {
 	size_t size;
+	int retval;
 
 	size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
 	memset(devpriv->usb_tx_buf, 0, size);
-	return vmk80xx_write_packet(devpriv, VMK8055_CMD_RST);
+	retval = vmk80xx_write_packet(devpriv, VMK8055_CMD_RST);
+	if (retval)
+		return retval;
+	/* set outputs to known state as we cannot read them */
+	return vmk80xx_write_packet(devpriv, VMK8055_CMD_WRT_AD);
 }
 
 #define DIR_IN  1

commit e8f311a5b6b9163f6aeba2524eaab92dc3b0fb6f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Feb 14 16:42:14 2013 +0000

    staging: comedi: vmk80xx: simplify vmk80xx_reset_device()
    
    vmk80xx_reset_device() is called during initialization of a Velleman
    K8055 (aka VM110) to send a reset command to the hardware.  The current
    function is a bit long-winded and doesn't set the TRANS_OUT_BUSY flag to
    prevent re-use of the transmit buffer while the URB is in progress.
    
    Rewrite the function to use vmk80xx_write_packet() to send the command.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 78228f6a2056..057d840b90de 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -277,41 +277,6 @@ static void vmk80xx_read_eeprom(struct vmk80xx_private *devpriv, int flag)
 		strncpy(devpriv->fw.ic6_vers, rx + 25, 24);
 }
 
-static int vmk80xx_reset_device(struct vmk80xx_private *devpriv)
-{
-	struct usb_device *usb = devpriv->usb;
-	unsigned char *tx_buf = devpriv->usb_tx_buf;
-	struct urb *urb;
-	unsigned int tx_pipe;
-	int ival;
-	size_t size;
-
-	urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!urb)
-		return -ENOMEM;
-
-	tx_pipe = usb_sndintpipe(usb, 0x01);
-
-	ival = devpriv->ep_tx->bInterval;
-	size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
-
-	tx_buf[0] = VMK8055_CMD_RST;
-	tx_buf[1] = 0x00;
-	tx_buf[2] = 0x00;
-	tx_buf[3] = 0x00;
-	tx_buf[4] = 0x00;
-	tx_buf[5] = 0x00;
-	tx_buf[6] = 0x00;
-	tx_buf[7] = 0x00;
-
-	usb_fill_int_urb(urb, usb, tx_pipe, tx_buf, size,
-			 vmk80xx_tx_callback, devpriv, ival);
-
-	usb_anchor_urb(urb, &devpriv->tx_anchor);
-
-	return usb_submit_urb(urb, GFP_KERNEL);
-}
-
 static void vmk80xx_build_int_urb(struct urb *urb, int flag)
 {
 	struct vmk80xx_private *devpriv = urb->context;
@@ -468,6 +433,15 @@ static int vmk80xx_write_packet(struct vmk80xx_private *devpriv, int cmd)
 	return retval;
 }
 
+static int vmk80xx_reset_device(struct vmk80xx_private *devpriv)
+{
+	size_t size;
+
+	size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
+	memset(devpriv->usb_tx_buf, 0, size);
+	return vmk80xx_write_packet(devpriv, VMK8055_CMD_RST);
+}
+
 #define DIR_IN  1
 #define DIR_OUT 2
 

commit 0cbfc8269b980adafa7b529bb529a2fc316c5405
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Feb 14 16:42:13 2013 +0000

    staging: comedi: vmk80xx: zero buffers on allocation
    
    Zero out `devpriv->usb_tx_buf` and `devpriv->usb_rx_buf` on allocation.
    When sending data to the USB device, this ensures any unused part of the
    buffer will not contain random crap.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index eed46ee4f710..78228f6a2056 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -994,12 +994,12 @@ static int vmk80xx_alloc_usb_buffers(struct comedi_device *dev)
 	size_t size;
 
 	size = le16_to_cpu(devpriv->ep_rx->wMaxPacketSize);
-	devpriv->usb_rx_buf = kmalloc(size, GFP_KERNEL);
+	devpriv->usb_rx_buf = kzalloc(size, GFP_KERNEL);
 	if (!devpriv->usb_rx_buf)
 		return -ENOMEM;
 
 	size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
-	devpriv->usb_tx_buf = kmalloc(size, GFP_KERNEL);
+	devpriv->usb_tx_buf = kzalloc(size, GFP_KERNEL);
 	if (!devpriv->usb_tx_buf) {
 		kfree(devpriv->usb_rx_buf);
 		return -ENOMEM;

commit fc9ca48eb60f4a516f59bbde1dc7685744ceb310
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Wed Feb 13 15:28:14 2013 +0100

    staging/comedi: Fix undefined array subscript
    
    In vmk80xx_do_insn_bits the local variable reg, which is used as an
    index to the tx_buf array, can be used uninitialized if
    - data[0] == 0
    and
    - devpriv->model != VMK8061_MODEL
    -> we get into the else branch without having reg initialized.
    
    Since the driver usually differentiates between VMK8061_MODEL and
    VMK8055_MODEL it's safe to assume that VMK8055_DO_REG was meant as an
    initial value.
    
    And to avoid duplication we can move the assignments to the top.
    
    Acked-by: Ian Abbott <abbotti@mev.co.uk>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index ebf2d4824860..eed46ee4f710 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -675,8 +675,14 @@ static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 	if (data[0])
 		dir |= DIR_OUT;
 
-	if (devpriv->model == VMK8061_MODEL)
+	if (devpriv->model == VMK8061_MODEL) {
 		dir |= DIR_IN;
+		reg = VMK8061_DO_REG;
+		cmd = VMK8061_CMD_DO;
+	} else { /* VMK8055_MODEL */
+		reg = VMK8055_DO_REG;
+		cmd = VMK8055_CMD_WRT_AD;
+	}
 
 	retval = rudimentary_check(devpriv, dir);
 	if (retval)
@@ -688,14 +694,6 @@ static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 	tx_buf = devpriv->usb_tx_buf;
 
 	if (data[0]) {
-		if (devpriv->model == VMK8055_MODEL) {
-			reg = VMK8055_DO_REG;
-			cmd = VMK8055_CMD_WRT_AD;
-		} else { /* VMK8061_MODEL */
-			reg = VMK8061_DO_REG;
-			cmd = VMK8061_CMD_DO;
-		}
-
 		tx_buf[reg] &= ~data[0];
 		tx_buf[reg] |= (data[0] & data[1]);
 
@@ -706,7 +704,6 @@ static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 	}
 
 	if (devpriv->model == VMK8061_MODEL) {
-		reg = VMK8061_DO_REG;
 		tx_buf[0] = VMK8061_CMD_RD_DO;
 
 		retval = vmk80xx_read_packet(devpriv);

commit 66dbc7b1b00499285793143b44b979e26141204d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:31:10 2013 -0700

    staging: comedi: vmk80xx: rename vmk80xx_attach_common()
    
    In comedi drivers typically *_attach_common() is used as the 'common'
    part of the comedi_driver attach code for drivers that support various
    bus types (ISA, PCI, etc.). This driver is specific to a USB device.
    
    To avoid confusion when grepping, rename this function to something
    more appropriate.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index d0ff0e7b119d..ebf2d4824860 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1011,7 +1011,7 @@ static int vmk80xx_alloc_usb_buffers(struct comedi_device *dev)
 	return 0;
 }
 
-static int vmk80xx_attach_common(struct comedi_device *dev)
+static int vmk80xx_init_subdevices(struct comedi_device *dev)
 {
 	const struct vmk80xx_board *boardinfo = comedi_board(dev);
 	struct vmk80xx_private *devpriv = dev->private;
@@ -1151,7 +1151,7 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 	if (devpriv->model == VMK8055_MODEL)
 		vmk80xx_reset_device(devpriv);
 
-	return vmk80xx_attach_common(dev);
+	return vmk80xx_init_subdevices(dev);
 }
 
 static void vmk80xx_detach(struct comedi_device *dev)

commit 6dcbe00df71bd0559c32ef7e838eac1458ad24d6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:30:48 2013 -0700

    staging: comedi: vmk80xx: remove the 'Changelog' comments
    
    git history provides a better Changelog for the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 23715f651025..d0ff0e7b119d 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -38,19 +38,6 @@ Status: works
  - counter
  - pwm
 */
-/*
-Changelog:
-
-0.8.81	-3-  code completely rewritten (adjust driver logic)
-0.8.81  -2-  full support for K8061
-0.8.81  -1-  fix some mistaken among others the number of
-	     supported boards and I/O handling
-
-0.7.76  -4-  renamed to vmk80xx
-0.7.76  -3-  detect K8061 (only theoretically supported)
-0.7.76  -2-  code completely rewritten (adjust driver logic)
-0.7.76  -1-  support for digital and counter subdevice
-*/
 
 #include <linux/kernel.h>
 #include <linux/module.h>

commit f45787c687adcf3c01599bf8f32667fab5271e0d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:30:21 2013 -0700

    staging: comedi: vmk80xx: cleanup the comedi_lrange tables
    
    The vmk8055_range table is a duplicate of the comedi core provided
    range_unipolar5 table. Use that instead.
    
    For aesthetic reasons, clean up the formating of the vmk8061_range
    table.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 8ec5985121ee..23715f651025 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -133,12 +133,11 @@ struct firmware_version {
 	unsigned char ic6_vers[32];	/* CPU */
 };
 
-static const struct comedi_lrange vmk8055_range = {
-	1, {UNI_RANGE(5)}
-};
-
 static const struct comedi_lrange vmk8061_range = {
-	2, {UNI_RANGE(5), UNI_RANGE(10)}
+	2, {
+		UNI_RANGE(5),
+		UNI_RANGE(10)
+	}
 };
 
 struct vmk80xx_board {
@@ -158,7 +157,7 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 	[DEVICE_VMK8055] = {
 		.name		= "K8055 (VM110)",
 		.model		= VMK8055_MODEL,
-		.range		= &vmk8055_range,
+		.range		= &range_unipolar5,
 		.ai_nchans	= 2,
 		.ai_maxdata	= 0x00ff,
 		.ao_nchans	= 2,

commit 4c56a2b63979ec1992fddc087c4660fde7d8e6c0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:30:01 2013 -0700

    staging: comedi: vmk80xx: remove CONFIG_COMEDI_DEBUG code
    
    If CONFIG_COMEDI_DEBUG is defined a macro is enabled to output some
    printk(KERN_REBUG ...) messages. These are just added noise. Remove
    it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 5ba963281cfe..8ec5985121ee 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -123,18 +123,6 @@ enum {
 #define URB_RCV_FLAG            (1 << 0)
 #define URB_SND_FLAG            (1 << 1)
 
-#ifdef CONFIG_COMEDI_DEBUG
-static int dbgcm = 1;
-#else
-static int dbgcm;
-#endif
-
-#define dbgcm(fmt, arg...)                     \
-do {                                           \
-	if (dbgcm)                             \
-		printk(KERN_DEBUG fmt, ##arg); \
-} while (0)
-
 enum vmk80xx_model {
 	VMK8055_MODEL,
 	VMK8061_MODEL
@@ -212,12 +200,6 @@ static void vmk80xx_tx_callback(struct urb *urb)
 {
 	struct vmk80xx_private *devpriv = urb->context;
 	unsigned long *flags = &devpriv->flags;
-	int stat = urb->status;
-
-	if (stat && !(stat == -ENOENT
-		      || stat == -ECONNRESET || stat == -ESHUTDOWN))
-		dbgcm("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",
-		      __func__, stat);
 
 	if (!test_bit(TRANS_OUT_BUSY, flags))
 		return;
@@ -241,26 +223,16 @@ static void vmk80xx_rx_callback(struct urb *urb)
 	case -ESHUTDOWN:
 		break;
 	default:
-		dbgcm("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",
-		      __func__, stat);
-		goto resubmit;
-	}
-
-	goto exit;
-resubmit:
-	if (test_bit(TRANS_IN_RUNNING, flags) && devpriv->intf) {
-		usb_anchor_urb(urb, &devpriv->rx_anchor);
-
-		if (!usb_submit_urb(urb, GFP_KERNEL))
-			goto exit;
+		/* Try to resubmit the urb */
+		if (test_bit(TRANS_IN_RUNNING, flags) && devpriv->intf) {
+			usb_anchor_urb(urb, &devpriv->rx_anchor);
 
-		dev_err(&urb->dev->dev,
-			"comedi#: vmk80xx: %s - submit urb failed\n",
-			__func__);
-
-		usb_unanchor_urb(urb);
+			if (usb_submit_urb(urb, GFP_KERNEL))
+				usb_unanchor_urb(urb);
+		}
+		break;
 	}
-exit:
+
 	clear_bit(TRANS_IN_BUSY, flags);
 
 	wake_up_interruptible(&devpriv->read_wait);
@@ -1187,8 +1159,6 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 		if (vmk80xx_check_data_link(devpriv)) {
 			vmk80xx_read_eeprom(devpriv, IC6_VERSION);
 			dev_info(&intf->dev, "%s\n", devpriv->fw.ic6_vers);
-		} else {
-			dbgcm("comedi#: vmk80xx: no conn. to CPU\n");
 		}
 	}
 

commit 6f25a527eac10d9ba277a2de7a2a9d3e92c08a52
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:29:35 2013 -0700

    staging: comedi: vmk80xx: remove unused #define
    
    This define is no longer used by the driver. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index d728c057f09e..5ba963281cfe 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -113,8 +113,6 @@ enum {
 #define VMK8061_CMD_RD_AO       0x0f
 #define VMK8061_CMD_RD_PWM      0x10
 
-#define VMK80XX_MAX_BOARDS      COMEDI_NUM_BOARD_MINORS
-
 #define TRANS_OUT_BUSY          1
 #define TRANS_IN_BUSY           2
 #define TRANS_IN_RUNNING        3

commit 0f97889c19bfedf102ec6e1fdd7f99a8342d4f22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:29:13 2013 -0700

    staging: comedi: vmk80xx: remove digital input (*insn_read)
    
    The comedi core can use the (*insn_bits) function to emulate the
    (*insn_read) function. Remove the unnecessary (*insn_read) function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index ba4fd5202791..d728c057f09e 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -704,52 +704,6 @@ static int vmk80xx_di_insn_bits(struct comedi_device *dev,
 	return retval;
 }
 
-static int vmk80xx_di_insn_read(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn,
-				unsigned int *data)
-{
-	struct vmk80xx_private *devpriv = dev->private;
-	int chan;
-	unsigned char *rx_buf;
-	int reg;
-	int inp;
-	int n;
-
-	n = rudimentary_check(devpriv, DIR_IN);
-	if (n)
-		return n;
-
-	down(&devpriv->limit_sem);
-	chan = CR_CHAN(insn->chanspec);
-
-	rx_buf = devpriv->usb_rx_buf;
-
-	if (devpriv->model == VMK8061_MODEL) {
-		reg = VMK8061_DI_REG;
-		devpriv->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
-	} else {
-		reg = VMK8055_DI_REG;
-	}
-	for (n = 0; n < insn->n; n++) {
-		if (vmk80xx_read_packet(devpriv))
-			break;
-
-		if (devpriv->model == VMK8055_MODEL)
-			inp = (((rx_buf[reg] >> 4) & 0x03) |
-			       ((rx_buf[reg] << 2) & 0x04) |
-			       ((rx_buf[reg] >> 3) & 0x18));
-		else
-			inp = rx_buf[reg];
-
-		data[n] = (inp >> chan) & 1;
-	}
-
-	up(&devpriv->limit_sem);
-
-	return n;
-}
-
 static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn,
@@ -1150,7 +1104,6 @@ static int vmk80xx_attach_common(struct comedi_device *dev)
 	s->n_chan	= boardinfo->di_nchans;
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
-	s->insn_read	= vmk80xx_di_insn_read;
 	s->insn_bits	= vmk80xx_di_insn_bits;
 
 	/* Digital output subdevice */

commit a348b72eae946dd5d2cc9e00c4344c7814979eb0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:28:51 2013 -0700

    staging: comedi: vmk80xx: remove digital output (*insn_write)
    
    The comedi core can use the (*insn_bits) function to emulate the
    (*insn_write) function. Remove the unnecessary (*insn_read)
    function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 4f32bad0136f..ba4fd5202791 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -750,55 +750,6 @@ static int vmk80xx_di_insn_read(struct comedi_device *dev,
 	return n;
 }
 
-static int vmk80xx_do_insn_write(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn,
-				 unsigned int *data)
-{
-	struct vmk80xx_private *devpriv = dev->private;
-	int chan;
-	unsigned char *tx_buf;
-	int reg;
-	int cmd;
-	int n;
-
-	n = rudimentary_check(devpriv, DIR_OUT);
-	if (n)
-		return n;
-
-	down(&devpriv->limit_sem);
-	chan = CR_CHAN(insn->chanspec);
-
-	tx_buf = devpriv->usb_tx_buf;
-
-	for (n = 0; n < insn->n; n++) {
-		if (devpriv->model == VMK8055_MODEL) {
-			reg = VMK8055_DO_REG;
-			cmd = VMK8055_CMD_WRT_AD;
-			if (data[n] == 1)
-				tx_buf[reg] |= (1 << chan);
-			else
-				tx_buf[reg] ^= (1 << chan);
-		} else { /* VMK8061_MODEL */
-			reg = VMK8061_DO_REG;
-			if (data[n] == 1) {
-				cmd = VMK8061_CMD_SET_DO;
-				tx_buf[reg] = 1 << chan;
-			} else {
-				cmd = VMK8061_CMD_CLR_DO;
-				tx_buf[reg] = 0xff - (1 << chan);
-			}
-		}
-
-		if (vmk80xx_write_packet(devpriv, cmd))
-			break;
-	}
-
-	up(&devpriv->limit_sem);
-
-	return n;
-}
-
 static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn,
@@ -1209,7 +1160,6 @@ static int vmk80xx_attach_common(struct comedi_device *dev)
 	s->n_chan	= 8;
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
-	s->insn_write	= vmk80xx_do_insn_write;
 	s->insn_bits	= vmk80xx_do_insn_bits;
 
 	/* Counter subdevice */

commit 03754bdbb10a8045b2c18cfec8f2272d7df004c6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:28:27 2013 -0700

    staging: comedi: vmk80xx: remove digital output (*insn_read)
    
    The comedi core can use the (*insn_bits) function to emulate the
    (*insn_read) function.
    
    The digital output (*insn_bits) function properly handles the
    VMK8061_MODEL to read the digital output states before returning.
    
    Remove the unnecessary (*insn_read) function. It's also not
    necessary to set the SDF_READABLE flag so remove the entire
    conditional in the attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 00f5784f0b59..4f32bad0136f 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -799,39 +799,6 @@ static int vmk80xx_do_insn_write(struct comedi_device *dev,
 	return n;
 }
 
-static int vmk80xx_do_insn_read(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn,
-				unsigned int *data)
-{
-	struct vmk80xx_private *devpriv = dev->private;
-	int chan;
-	int reg;
-	int n;
-
-	n = rudimentary_check(devpriv, DIR_IN);
-	if (n)
-		return n;
-
-	down(&devpriv->limit_sem);
-	chan = CR_CHAN(insn->chanspec);
-
-	reg = VMK8061_DO_REG;
-
-	devpriv->usb_tx_buf[0] = VMK8061_CMD_RD_DO;
-
-	for (n = 0; n < insn->n; n++) {
-		if (vmk80xx_read_packet(devpriv))
-			break;
-
-		data[n] = (devpriv->usb_rx_buf[reg] >> chan) & 1;
-	}
-
-	up(&devpriv->limit_sem);
-
-	return n;
-}
-
 static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn,
@@ -1244,10 +1211,6 @@ static int vmk80xx_attach_common(struct comedi_device *dev)
 	s->range_table	= &range_digital;
 	s->insn_write	= vmk80xx_do_insn_write;
 	s->insn_bits	= vmk80xx_do_insn_bits;
-	if (devpriv->model == VMK8061_MODEL) {
-		s->subdev_flags	|= SDF_READABLE;
-		s->insn_read	= vmk80xx_do_insn_read;
-	}
 
 	/* Counter subdevice */
 	s = &dev->subdevices[4];

commit 9a23a7481ea860096acbc032dcb1159b8864fbf5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:27:56 2013 -0700

    staging: comedi: vmk80xx: cleanup pwm subdevice init
    
    Change the 'pwm_bits' in the boardinfo to 'pwm_maxdata' so that the
    calculation of s->maxdata can be removed. Also, change the type to
    match the comedi_subdevice type. For aesthetic reasons, rename the
    'pwm_chans' boardinfo and change its type also.
    
    Remove the '0' values in the boardinfo.
    
    Rename the (*insn_read) and (*insn_write) functions for the pwm
    subdevice to make grepping easier.
    
    For aesthetic reasons, add some whitespace to the subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 26a9a9607f35..00f5784f0b59 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -164,8 +164,8 @@ struct vmk80xx_board {
 	int ao_nchans;
 	int di_nchans;
 	unsigned int cnt_maxdata;
-	__u8 pwm_chans;
-	__le16 pwm_bits;
+	int pwm_nchans;
+	unsigned int pwm_maxdata;
 };
 
 static const struct vmk80xx_board vmk80xx_boardinfo[] = {
@@ -178,8 +178,6 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 		.ao_nchans	= 2,
 		.di_nchans	= 6,
 		.cnt_maxdata	= 0xffff,
-		.pwm_chans	= 0,
-		.pwm_bits	= 0,
 	},
 	[DEVICE_VMK8061] = {
 		.name		= "K8061 (VM140)",
@@ -190,8 +188,8 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 		.ao_nchans	= 8,
 		.di_nchans	= 8,
 		.cnt_maxdata	= 0,	/* unknown, device is not writeable */
-		.pwm_chans	= 1,
-		.pwm_bits	= 10,
+		.pwm_nchans	= 1,
+		.pwm_maxdata	= 0x03ff,
 	},
 };
 
@@ -1043,9 +1041,10 @@ static int vmk80xx_cnt_insn_write(struct comedi_device *dev,
 	return n;
 }
 
-static int vmk80xx_pwm_rinsn(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_pwm_insn_read(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	unsigned char *tx_buf;
@@ -1079,9 +1078,10 @@ static int vmk80xx_pwm_rinsn(struct comedi_device *dev,
 	return n;
 }
 
-static int vmk80xx_pwm_winsn(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_pwm_insn_write(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn,
+				  unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	unsigned char *tx_buf;
@@ -1265,12 +1265,12 @@ static int vmk80xx_attach_common(struct comedi_device *dev)
 	/* PWM subdevice */
 	if (devpriv->model == VMK8061_MODEL) {
 		s = &dev->subdevices[5];
-		s->type = COMEDI_SUBD_PWM;
-		s->subdev_flags = SDF_READABLE | SDF_WRITEABLE;
-		s->n_chan = boardinfo->pwm_chans;
-		s->maxdata = (1 << boardinfo->pwm_bits) - 1;
-		s->insn_read = vmk80xx_pwm_rinsn;
-		s->insn_write = vmk80xx_pwm_winsn;
+		s->type		= COMEDI_SUBD_PWM;
+		s->subdev_flags	= SDF_READABLE | SDF_WRITEABLE;
+		s->n_chan	= boardinfo->pwm_nchans;
+		s->maxdata	= boardinfo->pwm_maxdata;
+		s->insn_read	= vmk80xx_pwm_insn_read;
+		s->insn_write	= vmk80xx_pwm_insn_write;
 	}
 
 	up(&devpriv->limit_sem);

commit 75a45d924dd33882caf80d3a78dd96c370a6580b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:27:37 2013 -0700

    staging: comedi: vmk80xx: cleanup counter subdevice init
    
    Change the 'cnt_bits' in the boardinfo to 'cnt_maxdata' so that the
    calculation of s->maxdata can be removed. Also, change the type to
    match the comedi_subdevice type. Add a comment about the '0' value
    for DEVICE_VMK8061.
    
    The s->maxdata should always be set for the subdevice. Move it out
    of the conditional.
    
    Rename the (*insn_read), (*insn_config_, and (*insn_write) functions
    for the counter subdevice to make grepping easier.
    
    For aesthetic reasons, add some whitespace to the subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 4d51f6c9d1f9..26a9a9607f35 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -163,7 +163,7 @@ struct vmk80xx_board {
 	unsigned int ai_maxdata;
 	int ao_nchans;
 	int di_nchans;
-	__le16 cnt_bits;
+	unsigned int cnt_maxdata;
 	__u8 pwm_chans;
 	__le16 pwm_bits;
 };
@@ -177,7 +177,7 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 		.ai_maxdata	= 0x00ff,
 		.ao_nchans	= 2,
 		.di_nchans	= 6,
-		.cnt_bits	= 16,
+		.cnt_maxdata	= 0xffff,
 		.pwm_chans	= 0,
 		.pwm_bits	= 0,
 	},
@@ -189,7 +189,7 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 		.ai_maxdata	= 0x03ff,
 		.ao_nchans	= 8,
 		.di_nchans	= 8,
-		.cnt_bits	= 0,
+		.cnt_maxdata	= 0,	/* unknown, device is not writeable */
 		.pwm_chans	= 1,
 		.pwm_bits	= 10,
 	},
@@ -900,9 +900,10 @@ static int vmk80xx_do_insn_bits(struct comedi_device *dev,
 	return retval;
 }
 
-static int vmk80xx_cnt_rinsn(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_cnt_insn_read(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
@@ -947,9 +948,10 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *dev,
 	return n;
 }
 
-static int vmk80xx_cnt_cinsn(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_cnt_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	unsigned int insn_cmd;
@@ -993,9 +995,10 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *dev,
 	return n;
 }
 
-static int vmk80xx_cnt_winsn(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_cnt_insn_write(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn,
+				  unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	unsigned long debtime;
@@ -1248,15 +1251,15 @@ static int vmk80xx_attach_common(struct comedi_device *dev)
 
 	/* Counter subdevice */
 	s = &dev->subdevices[4];
-	s->type = COMEDI_SUBD_COUNTER;
-	s->subdev_flags = SDF_READABLE;
-	s->n_chan = 2;
-	s->insn_read = vmk80xx_cnt_rinsn;
-	s->insn_config = vmk80xx_cnt_cinsn;
+	s->type		= COMEDI_SUBD_COUNTER;
+	s->subdev_flags	= SDF_READABLE;
+	s->n_chan	= 2;
+	s->maxdata	= boardinfo->cnt_maxdata;
+	s->insn_read	= vmk80xx_cnt_insn_read;
+	s->insn_config	= vmk80xx_cnt_insn_config;
 	if (devpriv->model == VMK8055_MODEL) {
-		s->subdev_flags |= SDF_WRITEABLE;
-		s->maxdata = (1 << boardinfo->cnt_bits) - 1;
-		s->insn_write = vmk80xx_cnt_winsn;
+		s->subdev_flags	|= SDF_WRITEABLE;
+		s->insn_write	= vmk80xx_cnt_insn_write;
 	}
 
 	/* PWM subdevice */

commit b639e09608f0103761751d707e837a7ca01d82a7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:25:49 2013 -0700

    staging: comedi: vmk80xx: cleanup digital input subdevice init
    
    Remove the SDF_GROUND flag from s->subdev_flags. This flag only has
    meaning for analog subdevices.
    
    Add the missing s->range_table for the subdevice.
    
    Rename the (*insn_write), (*insn_bits), and (*insn_read) functions
    for the digital input subdevice to make grepping easier.
    
    For aesthetic reasons, add some whitespace to the subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index d34e9adf4d23..4d51f6c9d1f9 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -752,9 +752,10 @@ static int vmk80xx_di_insn_read(struct comedi_device *dev,
 	return n;
 }
 
-static int vmk80xx_do_winsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_do_insn_write(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
@@ -800,9 +801,10 @@ static int vmk80xx_do_winsn(struct comedi_device *dev,
 	return n;
 }
 
-static int vmk80xx_do_rinsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_do_insn_read(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
@@ -832,9 +834,10 @@ static int vmk80xx_do_rinsn(struct comedi_device *dev,
 	return n;
 }
 
-static int vmk80xx_do_bits(struct comedi_device *dev,
-			   struct comedi_subdevice *s,
-			   struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_do_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	unsigned char *rx_buf, *tx_buf;
@@ -1231,15 +1234,16 @@ static int vmk80xx_attach_common(struct comedi_device *dev)
 
 	/* Digital output subdevice */
 	s = &dev->subdevices[3];
-	s->type = COMEDI_SUBD_DO;
-	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
-	s->n_chan = 8;
-	s->maxdata = 1;
-	s->insn_write = vmk80xx_do_winsn;
-	s->insn_bits = vmk80xx_do_bits;
+	s->type		= COMEDI_SUBD_DO;
+	s->subdev_flags	= SDF_WRITEABLE;
+	s->n_chan	= 8;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_write	= vmk80xx_do_insn_write;
+	s->insn_bits	= vmk80xx_do_insn_bits;
 	if (devpriv->model == VMK8061_MODEL) {
-		s->subdev_flags |= SDF_READABLE;
-		s->insn_read = vmk80xx_do_rinsn;
+		s->subdev_flags	|= SDF_READABLE;
+		s->insn_read	= vmk80xx_do_insn_read;
 	}
 
 	/* Counter subdevice */

commit 268e5148aac3108ad1347f9ecf637be3d83e525e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:25:28 2013 -0700

    staging: comedi: vmk80xx: cleanup digital input subdevice init
    
    Change the type for the digital input 'di_chans' boardinfo to match
    the comedi_subdevice type it is set to. For aesthetic reasons, rename
    the variable also.
    
    Remove the SDF_GROUND flag from s->subdev_flags. This flag only has
    meaning for analog subdevices.
    
    Add the missing s->range_table for the subdevice.
    
    Rename the (*insn_read) and (*insn_bits) functions for the digital
    input subdevice to make grepping easier.
    
    For aesthetic reasons, add some whitespace to the subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index be65da1de242..d34e9adf4d23 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -162,7 +162,7 @@ struct vmk80xx_board {
 	int ai_nchans;
 	unsigned int ai_maxdata;
 	int ao_nchans;
-	__u8 di_chans;
+	int di_nchans;
 	__le16 cnt_bits;
 	__u8 pwm_chans;
 	__le16 pwm_bits;
@@ -176,7 +176,7 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 		.ai_nchans	= 2,
 		.ai_maxdata	= 0x00ff,
 		.ao_nchans	= 2,
-		.di_chans	= 6,
+		.di_nchans	= 6,
 		.cnt_bits	= 16,
 		.pwm_chans	= 0,
 		.pwm_bits	= 0,
@@ -188,7 +188,7 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 		.ai_nchans	= 8,
 		.ai_maxdata	= 0x03ff,
 		.ao_nchans	= 8,
-		.di_chans	= 8,
+		.di_nchans	= 8,
 		.cnt_bits	= 0,
 		.pwm_chans	= 1,
 		.pwm_bits	= 10,
@@ -663,9 +663,10 @@ static int vmk80xx_ao_insn_read(struct comedi_device *dev,
 	return n;
 }
 
-static int vmk80xx_di_bits(struct comedi_device *dev,
-			   struct comedi_subdevice *s,
-			   struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_di_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	unsigned char *rx_buf;
@@ -705,9 +706,10 @@ static int vmk80xx_di_bits(struct comedi_device *dev,
 	return retval;
 }
 
-static int vmk80xx_di_rinsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_di_insn_read(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
@@ -1219,12 +1221,13 @@ static int vmk80xx_attach_common(struct comedi_device *dev)
 
 	/* Digital input subdevice */
 	s = &dev->subdevices[2];
-	s->type = COMEDI_SUBD_DI;
-	s->subdev_flags = SDF_READABLE | SDF_GROUND;
-	s->n_chan = boardinfo->di_chans;
-	s->maxdata = 1;
-	s->insn_read = vmk80xx_di_rinsn;
-	s->insn_bits = vmk80xx_di_bits;
+	s->type		= COMEDI_SUBD_DI;
+	s->subdev_flags	= SDF_READABLE;
+	s->n_chan	= boardinfo->di_nchans;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_read	= vmk80xx_di_insn_read;
+	s->insn_bits	= vmk80xx_di_insn_bits;
 
 	/* Digital output subdevice */
 	s = &dev->subdevices[3];

commit 8b3ec9f155cf564e0f2320b6a895d8684f2874fe
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:25:07 2013 -0700

    staging: comedi: vmk80xx: cleanup analog output subdevice init
    
    Change the type for the analog output 'ao_chans' boardinfo to match
    the comedi_subdevice type it is set to. For aesthetic reasons, rename
    the variable also.
    
    Rename the (*insn_write) and (*insn_read) functions for the analog
    output subdevice to make grepping easier.
    
    For aesthetic reasons, add some whitespace to the subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 9eae0a06cc72..be65da1de242 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -161,7 +161,7 @@ struct vmk80xx_board {
 	const struct comedi_lrange *range;
 	int ai_nchans;
 	unsigned int ai_maxdata;
-	__u8 ao_chans;
+	int ao_nchans;
 	__u8 di_chans;
 	__le16 cnt_bits;
 	__u8 pwm_chans;
@@ -175,7 +175,7 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 		.range		= &vmk8055_range,
 		.ai_nchans	= 2,
 		.ai_maxdata	= 0x00ff,
-		.ao_chans	= 2,
+		.ao_nchans	= 2,
 		.di_chans	= 6,
 		.cnt_bits	= 16,
 		.pwm_chans	= 0,
@@ -187,7 +187,7 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 		.range		= &vmk8061_range,
 		.ai_nchans	= 8,
 		.ai_maxdata	= 0x03ff,
-		.ao_chans	= 8,
+		.ao_nchans	= 8,
 		.di_chans	= 8,
 		.cnt_bits	= 0,
 		.pwm_chans	= 1,
@@ -585,9 +585,10 @@ static int vmk80xx_ai_insn_read(struct comedi_device *dev,
 	return n;
 }
 
-static int vmk80xx_ao_winsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_ao_insn_write(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
@@ -629,9 +630,10 @@ static int vmk80xx_ao_winsn(struct comedi_device *dev,
 	return n;
 }
 
-static int vmk80xx_ao_rinsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_ao_insn_read(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
@@ -1204,15 +1206,15 @@ static int vmk80xx_attach_common(struct comedi_device *dev)
 
 	/* Analog output subdevice */
 	s = &dev->subdevices[1];
-	s->type = COMEDI_SUBD_AO;
-	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
-	s->n_chan = boardinfo->ao_chans;
-	s->maxdata = 0x00ff;
-	s->range_table = boardinfo->range;
-	s->insn_write = vmk80xx_ao_winsn;
+	s->type		= COMEDI_SUBD_AO;
+	s->subdev_flags	= SDF_WRITEABLE | SDF_GROUND;
+	s->n_chan	= boardinfo->ao_nchans;
+	s->maxdata	= 0x00ff;
+	s->range_table	= boardinfo->range;
+	s->insn_write	= vmk80xx_ao_insn_write;
 	if (devpriv->model == VMK8061_MODEL) {
-		s->subdev_flags |= SDF_READABLE;
-		s->insn_read = vmk80xx_ao_rinsn;
+		s->subdev_flags	|= SDF_READABLE;
+		s->insn_read	= vmk80xx_ao_insn_read;
 	}
 
 	/* Digital input subdevice */

commit 658cd3ac2e31d637f50402611976bdaab74c28f8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:24:45 2013 -0700

    staging: comedi: vmk80xx: cleanup analog input subdevice init
    
    Change the 'ai_bits' in the boardinfo to 'ai_maxdata' so that the
    calculation of s->maxdata can be removed.
    
    Change the types for the analog input boardinfo to match the
    comedi_subdevice types they are set to.
    
    Rename the (*insn_read) function for the analog input subdevice from
    vmk80xx_ai_rinsn to vmk80xx_ai_insn_read to make grepping easier.
    
    For aesthetic reasons, add some whitespace to the subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 80864a7c7260..9eae0a06cc72 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -159,8 +159,8 @@ struct vmk80xx_board {
 	const char *name;
 	enum vmk80xx_model model;
 	const struct comedi_lrange *range;
-	__u8 ai_chans;
-	__le16 ai_bits;
+	int ai_nchans;
+	unsigned int ai_maxdata;
 	__u8 ao_chans;
 	__u8 di_chans;
 	__le16 cnt_bits;
@@ -173,8 +173,8 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 		.name		= "K8055 (VM110)",
 		.model		= VMK8055_MODEL,
 		.range		= &vmk8055_range,
-		.ai_chans	= 2,
-		.ai_bits	= 8,
+		.ai_nchans	= 2,
+		.ai_maxdata	= 0x00ff,
 		.ao_chans	= 2,
 		.di_chans	= 6,
 		.cnt_bits	= 16,
@@ -185,8 +185,8 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 		.name		= "K8061 (VM140)",
 		.model		= VMK8061_MODEL,
 		.range		= &vmk8061_range,
-		.ai_chans	= 8,
-		.ai_bits	= 10,
+		.ai_nchans	= 8,
+		.ai_maxdata	= 0x03ff,
 		.ao_chans	= 8,
 		.di_chans	= 8,
 		.cnt_bits	= 0,
@@ -533,9 +533,10 @@ static int rudimentary_check(struct vmk80xx_private *devpriv, int dir)
 	return 0;
 }
 
-static int vmk80xx_ai_rinsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_ai_insn_read(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
@@ -1194,12 +1195,12 @@ static int vmk80xx_attach_common(struct comedi_device *dev)
 
 	/* Analog input subdevice */
 	s = &dev->subdevices[0];
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_GROUND;
-	s->n_chan = boardinfo->ai_chans;
-	s->maxdata = (1 << boardinfo->ai_bits) - 1;
-	s->range_table = boardinfo->range;
-	s->insn_read = vmk80xx_ai_rinsn;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND;
+	s->n_chan	= boardinfo->ai_nchans;
+	s->maxdata	= boardinfo->ai_maxdata;
+	s->range_table	= boardinfo->range;
+	s->insn_read	= vmk80xx_ai_insn_read;
 
 	/* Analog output subdevice */
 	s = &dev->subdevices[1];

commit 52d895d3672dd58c0067c2efca4b825e4d733d0c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:24:24 2013 -0700

    staging: comedi: vmk80xx: remove need for boardinfo in private_data
    
    The only information in the boardinfo that is used outside of the
    attach of the driver is the 'model' of the device.
    
    Remove the 'board' pointer from the private data and replace it with
    the 'model' enum and just copy that information over during the attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 6ed70eef149c..80864a7c7260 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -202,7 +202,6 @@ struct vmk80xx_private {
 	struct usb_endpoint_descriptor *ep_tx;
 	struct usb_anchor rx_anchor;
 	struct usb_anchor tx_anchor;
-	const struct vmk80xx_board *board;
 	struct firmware_version fw;
 	struct semaphore limit_sem;
 	wait_queue_head_t read_wait;
@@ -210,6 +209,7 @@ struct vmk80xx_private {
 	unsigned char *usb_rx_buf;
 	unsigned char *usb_tx_buf;
 	unsigned long flags;
+	enum vmk80xx_model model;
 };
 
 static void vmk80xx_tx_callback(struct urb *urb)
@@ -423,7 +423,6 @@ static void vmk80xx_do_bulk_msg(struct vmk80xx_private *devpriv)
 
 static int vmk80xx_read_packet(struct vmk80xx_private *devpriv)
 {
-	const struct vmk80xx_board *boardinfo = devpriv->board;
 	unsigned long *flags = &devpriv->flags;
 	struct urb *urb;
 	int retval;
@@ -437,7 +436,7 @@ static int vmk80xx_read_packet(struct vmk80xx_private *devpriv)
 					     !test_bit(TRANS_IN_BUSY, flags)))
 			return -ERESTART;
 
-	if (boardinfo->model == VMK8061_MODEL) {
+	if (devpriv->model == VMK8061_MODEL) {
 		vmk80xx_do_bulk_msg(devpriv);
 
 		return 0;
@@ -470,7 +469,6 @@ static int vmk80xx_read_packet(struct vmk80xx_private *devpriv)
 
 static int vmk80xx_write_packet(struct vmk80xx_private *devpriv, int cmd)
 {
-	const struct vmk80xx_board *boardinfo = devpriv->board;
 	unsigned long *flags = &devpriv->flags;
 	struct urb *urb;
 	int retval;
@@ -483,7 +481,7 @@ static int vmk80xx_write_packet(struct vmk80xx_private *devpriv, int cmd)
 					     !test_bit(TRANS_OUT_BUSY, flags)))
 			return -ERESTART;
 
-	if (boardinfo->model == VMK8061_MODEL) {
+	if (devpriv->model == VMK8061_MODEL) {
 		devpriv->usb_tx_buf[0] = cmd;
 		vmk80xx_do_bulk_msg(devpriv);
 
@@ -539,7 +537,6 @@ static int vmk80xx_ai_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(dev);
 	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
 	int reg[2];
@@ -552,7 +549,7 @@ static int vmk80xx_ai_rinsn(struct comedi_device *dev,
 	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
-	switch (boardinfo->model) {
+	switch (devpriv->model) {
 	case VMK8055_MODEL:
 		if (!chan)
 			reg[0] = VMK8055_AI1_REG;
@@ -572,7 +569,7 @@ static int vmk80xx_ai_rinsn(struct comedi_device *dev,
 		if (vmk80xx_read_packet(devpriv))
 			break;
 
-		if (boardinfo->model == VMK8055_MODEL) {
+		if (devpriv->model == VMK8055_MODEL) {
 			data[n] = devpriv->usb_rx_buf[reg[0]];
 			continue;
 		}
@@ -591,7 +588,6 @@ static int vmk80xx_ao_winsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(dev);
 	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
 	int cmd;
@@ -605,7 +601,7 @@ static int vmk80xx_ao_winsn(struct comedi_device *dev,
 	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
-	switch (boardinfo->model) {
+	switch (devpriv->model) {
 	case VMK8055_MODEL:
 		cmd = VMK8055_CMD_WRT_AD;
 		if (!chan)
@@ -668,7 +664,6 @@ static int vmk80xx_di_bits(struct comedi_device *dev,
 			   struct comedi_subdevice *s,
 			   struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(dev);
 	struct vmk80xx_private *devpriv = dev->private;
 	unsigned char *rx_buf;
 	int reg;
@@ -682,7 +677,7 @@ static int vmk80xx_di_bits(struct comedi_device *dev,
 
 	rx_buf = devpriv->usb_rx_buf;
 
-	if (boardinfo->model == VMK8061_MODEL) {
+	if (devpriv->model == VMK8061_MODEL) {
 		reg = VMK8061_DI_REG;
 		devpriv->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
 	} else {
@@ -692,7 +687,7 @@ static int vmk80xx_di_bits(struct comedi_device *dev,
 	retval = vmk80xx_read_packet(devpriv);
 
 	if (!retval) {
-		if (boardinfo->model == VMK8055_MODEL)
+		if (devpriv->model == VMK8055_MODEL)
 			data[1] = (((rx_buf[reg] >> 4) & 0x03) |
 				  ((rx_buf[reg] << 2) & 0x04) |
 				  ((rx_buf[reg] >> 3) & 0x18));
@@ -711,7 +706,6 @@ static int vmk80xx_di_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(dev);
 	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
 	unsigned char *rx_buf;
@@ -728,7 +722,7 @@ static int vmk80xx_di_rinsn(struct comedi_device *dev,
 
 	rx_buf = devpriv->usb_rx_buf;
 
-	if (boardinfo->model == VMK8061_MODEL) {
+	if (devpriv->model == VMK8061_MODEL) {
 		reg = VMK8061_DI_REG;
 		devpriv->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
 	} else {
@@ -738,7 +732,7 @@ static int vmk80xx_di_rinsn(struct comedi_device *dev,
 		if (vmk80xx_read_packet(devpriv))
 			break;
 
-		if (boardinfo->model == VMK8055_MODEL)
+		if (devpriv->model == VMK8055_MODEL)
 			inp = (((rx_buf[reg] >> 4) & 0x03) |
 			       ((rx_buf[reg] << 2) & 0x04) |
 			       ((rx_buf[reg] >> 3) & 0x18));
@@ -757,7 +751,6 @@ static int vmk80xx_do_winsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(dev);
 	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
 	unsigned char *tx_buf;
@@ -775,7 +768,7 @@ static int vmk80xx_do_winsn(struct comedi_device *dev,
 	tx_buf = devpriv->usb_tx_buf;
 
 	for (n = 0; n < insn->n; n++) {
-		if (boardinfo->model == VMK8055_MODEL) {
+		if (devpriv->model == VMK8055_MODEL) {
 			reg = VMK8055_DO_REG;
 			cmd = VMK8055_CMD_WRT_AD;
 			if (data[n] == 1)
@@ -838,7 +831,6 @@ static int vmk80xx_do_bits(struct comedi_device *dev,
 			   struct comedi_subdevice *s,
 			   struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(dev);
 	struct vmk80xx_private *devpriv = dev->private;
 	unsigned char *rx_buf, *tx_buf;
 	int dir, reg, cmd;
@@ -849,7 +841,7 @@ static int vmk80xx_do_bits(struct comedi_device *dev,
 	if (data[0])
 		dir |= DIR_OUT;
 
-	if (boardinfo->model == VMK8061_MODEL)
+	if (devpriv->model == VMK8061_MODEL)
 		dir |= DIR_IN;
 
 	retval = rudimentary_check(devpriv, dir);
@@ -862,7 +854,7 @@ static int vmk80xx_do_bits(struct comedi_device *dev,
 	tx_buf = devpriv->usb_tx_buf;
 
 	if (data[0]) {
-		if (boardinfo->model == VMK8055_MODEL) {
+		if (devpriv->model == VMK8055_MODEL) {
 			reg = VMK8055_DO_REG;
 			cmd = VMK8055_CMD_WRT_AD;
 		} else { /* VMK8061_MODEL */
@@ -879,7 +871,7 @@ static int vmk80xx_do_bits(struct comedi_device *dev,
 			goto out;
 	}
 
-	if (boardinfo->model == VMK8061_MODEL) {
+	if (devpriv->model == VMK8061_MODEL) {
 		reg = VMK8061_DO_REG;
 		tx_buf[0] = VMK8061_CMD_RD_DO;
 
@@ -904,7 +896,6 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(dev);
 	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
 	int reg[2];
@@ -917,7 +908,7 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *dev,
 	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
-	switch (boardinfo->model) {
+	switch (devpriv->model) {
 	case VMK8055_MODEL:
 		if (!chan)
 			reg[0] = VMK8055_CNT1_REG;
@@ -936,7 +927,7 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *dev,
 		if (vmk80xx_read_packet(devpriv))
 			break;
 
-		if (boardinfo->model == VMK8055_MODEL)
+		if (devpriv->model == VMK8055_MODEL)
 			data[n] = devpriv->usb_rx_buf[reg[0]];
 		else /* VMK8061_MODEL */
 			data[n] = devpriv->usb_rx_buf[reg[0] * (chan + 1) + 1]
@@ -952,7 +943,6 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(dev);
 	struct vmk80xx_private *devpriv = dev->private;
 	unsigned int insn_cmd;
 	int chan;
@@ -972,7 +962,7 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *dev,
 
 	chan = CR_CHAN(insn->chanspec);
 
-	if (boardinfo->model == VMK8055_MODEL) {
+	if (devpriv->model == VMK8055_MODEL) {
 		if (!chan) {
 			cmd = VMK8055_CMD_RST_CNT1;
 			reg = VMK8055_CNT1_REG;
@@ -1192,7 +1182,7 @@ static int vmk80xx_attach_common(struct comedi_device *dev)
 
 	down(&devpriv->limit_sem);
 
-	if (boardinfo->model == VMK8055_MODEL)
+	if (devpriv->model == VMK8055_MODEL)
 		n_subd = 5;
 	else
 		n_subd = 6;
@@ -1219,7 +1209,7 @@ static int vmk80xx_attach_common(struct comedi_device *dev)
 	s->maxdata = 0x00ff;
 	s->range_table = boardinfo->range;
 	s->insn_write = vmk80xx_ao_winsn;
-	if (boardinfo->model == VMK8061_MODEL) {
+	if (devpriv->model == VMK8061_MODEL) {
 		s->subdev_flags |= SDF_READABLE;
 		s->insn_read = vmk80xx_ao_rinsn;
 	}
@@ -1241,7 +1231,7 @@ static int vmk80xx_attach_common(struct comedi_device *dev)
 	s->maxdata = 1;
 	s->insn_write = vmk80xx_do_winsn;
 	s->insn_bits = vmk80xx_do_bits;
-	if (boardinfo->model == VMK8061_MODEL) {
+	if (devpriv->model == VMK8061_MODEL) {
 		s->subdev_flags |= SDF_READABLE;
 		s->insn_read = vmk80xx_do_rinsn;
 	}
@@ -1253,14 +1243,14 @@ static int vmk80xx_attach_common(struct comedi_device *dev)
 	s->n_chan = 2;
 	s->insn_read = vmk80xx_cnt_rinsn;
 	s->insn_config = vmk80xx_cnt_cinsn;
-	if (boardinfo->model == VMK8055_MODEL) {
+	if (devpriv->model == VMK8055_MODEL) {
 		s->subdev_flags |= SDF_WRITEABLE;
 		s->maxdata = (1 << boardinfo->cnt_bits) - 1;
 		s->insn_write = vmk80xx_cnt_winsn;
 	}
 
 	/* PWM subdevice */
-	if (boardinfo->model == VMK8061_MODEL) {
+	if (devpriv->model == VMK8061_MODEL) {
 		s = &dev->subdevices[5];
 		s->type = COMEDI_SUBD_PWM;
 		s->subdev_flags = SDF_READABLE | SDF_WRITEABLE;
@@ -1294,7 +1284,7 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 
 	devpriv->usb = interface_to_usbdev(intf);
 	devpriv->intf = intf;
-	devpriv->board = boardinfo;
+	devpriv->model = boardinfo->model;
 
 	ret = vmk80xx_find_usb_endpoints(dev);
 	if (ret)
@@ -1313,7 +1303,7 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 
 	usb_set_intfdata(intf, devpriv);
 
-	if (boardinfo->model == VMK8061_MODEL) {
+	if (devpriv->model == VMK8061_MODEL) {
 		vmk80xx_read_eeprom(devpriv, IC3_VERSION);
 		dev_info(&intf->dev, "%s\n", devpriv->fw.ic3_vers);
 
@@ -1325,7 +1315,7 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 		}
 	}
 
-	if (boardinfo->model == VMK8055_MODEL)
+	if (devpriv->model == VMK8055_MODEL)
 		vmk80xx_reset_device(devpriv);
 
 	return vmk80xx_attach_common(dev);

commit 57cf09aeeeadf35ef7f678a870139894d67a794f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:24:03 2013 -0700

    staging: comedi: vmk80xx: push usb (*probe) into comedi (*auto_attach)
    
    Make the usb_driver (*probe) simply call comedi_usb_auto_config()
    and move all the (*probe) code into the (*auto_attach) function.
    
    This allows getting rid of the static private data array since we
    no longer do part of the initialization in the (*probe) and then
    finish it in the (*auto_attach). We can simply kzalloc the private
    data instead. The comedi core will then handle the kfree of the
    data when the driver is detached.
    
    We can also get rid of the static 'glb_mutex' since this mutex was
    only used to protect the static private data array.
    
    Change the parameters for a couple of the helper functions used
    during the auto attach. Now that the comedi_device is available
    we can simply pass that pointer and get the specific pointers
    needed by the helper functions from it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index c20202c5cb77..6ed70eef149c 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -212,10 +212,6 @@ struct vmk80xx_private {
 	unsigned long flags;
 };
 
-static struct vmk80xx_private vmb[VMK80XX_MAX_BOARDS];
-
-static DEFINE_MUTEX(glb_mutex);
-
 static void vmk80xx_tx_callback(struct urb *urb)
 {
 	struct vmk80xx_private *devpriv = urb->context;
@@ -1131,9 +1127,10 @@ static int vmk80xx_pwm_winsn(struct comedi_device *dev,
 	return n;
 }
 
-static int vmk80xx_find_usb_endpoints(struct vmk80xx_private *devpriv,
-				      struct usb_interface *intf)
+static int vmk80xx_find_usb_endpoints(struct comedi_device *dev)
 {
+	struct vmk80xx_private *devpriv = dev->private;
+	struct usb_interface *intf = devpriv->intf;
 	struct usb_host_interface *iface_desc = intf->cur_altsetting;
 	struct usb_endpoint_descriptor *ep_desc;
 	int i;
@@ -1165,8 +1162,9 @@ static int vmk80xx_find_usb_endpoints(struct vmk80xx_private *devpriv,
 	return 0;
 }
 
-static int vmk80xx_alloc_usb_buffers(struct vmk80xx_private *devpriv)
+static int vmk80xx_alloc_usb_buffers(struct comedi_device *dev)
 {
+	struct vmk80xx_private *devpriv = dev->private;
 	size_t size;
 
 	size = le16_to_cpu(devpriv->ep_rx->wMaxPacketSize);
@@ -1184,21 +1182,16 @@ static int vmk80xx_alloc_usb_buffers(struct vmk80xx_private *devpriv)
 	return 0;
 }
 
-static int vmk80xx_attach_common(struct comedi_device *dev,
-				 struct vmk80xx_private *devpriv)
+static int vmk80xx_attach_common(struct comedi_device *dev)
 {
-	const struct vmk80xx_board *boardinfo;
-	int n_subd;
+	const struct vmk80xx_board *boardinfo = comedi_board(dev);
+	struct vmk80xx_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
+	int n_subd;
 	int ret;
 
 	down(&devpriv->limit_sem);
 
-	boardinfo = devpriv->board;
-	dev->board_ptr = boardinfo;
-	dev->board_name = boardinfo->name;
-	dev->private = devpriv;
-
 	if (boardinfo->model == VMK8055_MODEL)
 		n_subd = 5;
 	else
@@ -1283,94 +1276,33 @@ static int vmk80xx_attach_common(struct comedi_device *dev,
 }
 
 static int vmk80xx_auto_attach(struct comedi_device *dev,
-			       unsigned long context_unused)
+			       unsigned long context)
 {
 	struct usb_interface *intf = comedi_to_usb_interface(dev);
-	int i;
-	int ret;
-
-	mutex_lock(&glb_mutex);
-	for (i = 0; i < VMK80XX_MAX_BOARDS; i++)
-		if (vmb[i].intf == intf)
-			break;
-	if (i == VMK80XX_MAX_BOARDS)
-		ret = -ENODEV;
-	else
-		ret = vmk80xx_attach_common(dev, &vmb[i]);
-	mutex_unlock(&glb_mutex);
-	return ret;
-}
-
-static void vmk80xx_detach(struct comedi_device *dev)
-{
-	struct vmk80xx_private *devpriv = dev->private;
-
-	if (!devpriv)
-		return;
-
-	mutex_lock(&glb_mutex);
-	down(&devpriv->limit_sem);
-
-	dev->private = NULL;
-
-	usb_set_intfdata(devpriv->intf, NULL);
-
-	usb_kill_anchored_urbs(&devpriv->rx_anchor);
-	usb_kill_anchored_urbs(&devpriv->tx_anchor);
-
-	kfree(devpriv->usb_rx_buf);
-	kfree(devpriv->usb_tx_buf);
-
-	up(&devpriv->limit_sem);
-
-	/*
-	 * Since 'devpriv' points to an element of the static vmb array
-	 * we can't kfree it. Instead memset it to all '0' so subsequent
-	 * usb probes don't find any garbage in it.
-	 */
-	memset(devpriv, 0x00, sizeof(*devpriv));
-
-	mutex_unlock(&glb_mutex);
-}
-
-static struct comedi_driver vmk80xx_driver = {
-	.module		= THIS_MODULE,
-	.driver_name	= "vmk80xx",
-	.auto_attach	= vmk80xx_auto_attach,
-	.detach		= vmk80xx_detach,
-};
-
-static int vmk80xx_usb_probe(struct usb_interface *intf,
-			     const struct usb_device_id *id)
-{
 	const struct vmk80xx_board *boardinfo;
 	struct vmk80xx_private *devpriv;
 	int ret;
-	int i;
-
-	mutex_lock(&glb_mutex);
 
-	for (i = 0; i < VMK80XX_MAX_BOARDS; i++)
-		if (!vmb[i].intf)
-			break;
+	boardinfo = &vmk80xx_boardinfo[context];
+	dev->board_ptr = boardinfo;
+	dev->board_name = boardinfo->name;
 
-	if (i == VMK80XX_MAX_BOARDS) {
-		ret = -EMFILE;
-		goto fail;
-	}
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
-	devpriv = &vmb[i];
+	devpriv->usb = interface_to_usbdev(intf);
+	devpriv->intf = intf;
+	devpriv->board = boardinfo;
 
-	ret = vmk80xx_find_usb_endpoints(devpriv, intf);
+	ret = vmk80xx_find_usb_endpoints(dev);
 	if (ret)
-		goto error;
+		return ret;
 
-	ret = vmk80xx_alloc_usb_buffers(devpriv);
+	ret = vmk80xx_alloc_usb_buffers(dev);
 	if (ret)
-		goto error;
-
-	devpriv->usb = interface_to_usbdev(intf);
-	devpriv->intf = intf;
+		return ret;
 
 	sema_init(&devpriv->limit_sem, 8);
 	init_waitqueue_head(&devpriv->read_wait);
@@ -1381,9 +1313,6 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 
 	usb_set_intfdata(intf, devpriv);
 
-	boardinfo = &vmk80xx_boardinfo[id->driver_info];
-	devpriv->board = boardinfo;
-
 	if (boardinfo->model == VMK8061_MODEL) {
 		vmk80xx_read_eeprom(devpriv, IC3_VERSION);
 		dev_info(&intf->dev, "%s\n", devpriv->fw.ic3_vers);
@@ -1399,22 +1328,40 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 	if (boardinfo->model == VMK8055_MODEL)
 		vmk80xx_reset_device(devpriv);
 
-	mutex_unlock(&glb_mutex);
+	return vmk80xx_attach_common(dev);
+}
 
-	comedi_usb_auto_config(intf, &vmk80xx_driver, id->driver_info);
+static void vmk80xx_detach(struct comedi_device *dev)
+{
+	struct vmk80xx_private *devpriv = dev->private;
 
-	return 0;
+	if (!devpriv)
+		return;
 
-error:
-	/*
-	 * Since 'devpriv' points to an element of the static vmb array
-	 * we can't kfree it. Instead memset it to all '0' so subsequent
-	 * usb probes don't find any garbage in it.
-	 */
-	memset(devpriv, 0x00, sizeof(*devpriv));
-fail:
-	mutex_unlock(&glb_mutex);
-	return ret;
+	down(&devpriv->limit_sem);
+
+	usb_set_intfdata(devpriv->intf, NULL);
+
+	usb_kill_anchored_urbs(&devpriv->rx_anchor);
+	usb_kill_anchored_urbs(&devpriv->tx_anchor);
+
+	kfree(devpriv->usb_rx_buf);
+	kfree(devpriv->usb_tx_buf);
+
+	up(&devpriv->limit_sem);
+}
+
+static struct comedi_driver vmk80xx_driver = {
+	.module		= THIS_MODULE,
+	.driver_name	= "vmk80xx",
+	.auto_attach	= vmk80xx_auto_attach,
+	.detach		= vmk80xx_detach,
+};
+
+static int vmk80xx_usb_probe(struct usb_interface *intf,
+			     const struct usb_device_id *id)
+{
+	return comedi_usb_auto_config(intf, &vmk80xx_driver, id->driver_info);
 }
 
 static const struct usb_device_id vmk80xx_usb_id_table[] = {

commit 55ab4f641a3bfbdb7c59b80e194c7242234bbb1f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:23:40 2013 -0700

    staging: comedi: comedi_usb: allow comedi usb drivers to pass a 'context'
    
    Allow the comedi usb drivers to pass a 'context' from their (*probe)
    functions to the comedi core's comedi_usb_auto_config(). This 'context'
    is then passed to comedi_auto_config() and then to the comedi_driver's
    (*auto_attach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 00a115d988dc..c20202c5cb77 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1401,7 +1401,7 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 
 	mutex_unlock(&glb_mutex);
 
-	comedi_usb_auto_config(intf, &vmk80xx_driver);
+	comedi_usb_auto_config(intf, &vmk80xx_driver, id->driver_info);
 
 	return 0;
 

commit 29d6dd3310641f7dc0dbd9b55f651eb9846f2aa6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:23:16 2013 -0700

    staging: comedi: vmk80xx: remove private data 'attached'
    
    The 'attached' flag in the private data is set after the comedi_driver
    (*auto_attach) function has completed successfully.
    
    The only places it's checked are in rudimentary_check(), which does
    some basic sanity checks before doing any of the subdevice operations,
    and vmk80xx_auto_attach(), which is the comedi_driver (*auto_attach)
    function.
    
    The (*auto_attach) function can only be called as the result of a
    successfull usb_driver (*probe). Part of the probe is to locate a
    free slot in the static private data array. All free slots are
    initialized to '0' so the 'attached' flag will always be cleared.
    
    Remove the unneccessary 'attached' flag in the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index a9aa9885fc86..00a115d988dc 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -210,7 +210,6 @@ struct vmk80xx_private {
 	unsigned char *usb_rx_buf;
 	unsigned char *usb_tx_buf;
 	unsigned long flags;
-	int attached;
 };
 
 static struct vmk80xx_private vmb[VMK80XX_MAX_BOARDS];
@@ -528,8 +527,6 @@ static int rudimentary_check(struct vmk80xx_private *devpriv, int dir)
 {
 	if (!devpriv)
 		return -EFAULT;
-	if (!devpriv->attached)
-		return -ENODEV;
 	if (dir & DIR_IN) {
 		if (test_bit(TRANS_IN_BUSY, &devpriv->flags))
 			return -EBUSY;
@@ -1280,8 +1277,6 @@ static int vmk80xx_attach_common(struct comedi_device *dev,
 		s->insn_write = vmk80xx_pwm_winsn;
 	}
 
-	devpriv->attached = 1;
-
 	up(&devpriv->limit_sem);
 
 	return 0;
@@ -1300,8 +1295,6 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 			break;
 	if (i == VMK80XX_MAX_BOARDS)
 		ret = -ENODEV;
-	else if (vmb[i].attached)
-		ret = -EBUSY;
 	else
 		ret = vmk80xx_attach_common(dev, &vmb[i]);
 	mutex_unlock(&glb_mutex);

commit b105ad8a78456fbcdb81e98076e9c3813cdb0be0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:22:49 2013 -0700

    staging: comedi: vmk80xx: remove private data 'probed'
    
    The 'probed' variable is used in the usb driver (*probe) to detect an
    unused element in the static private data arry. This variable is then
    set after the usb driver has completed its (*probe) before calling
    comedi_usb_auto_config(). When the comedi core does the auto config
    it will call the (*auto_attach) function, vmk80xx_auto_attach(), which
    then locates the correct private data in the static array by checking
    to see if it has been 'probed' and that the 'intf' variable matches
    the usb_interface pointer for the usb device.
    
    Now that the private data is clean after failed usb probes and disconnects
    we don't have to worry about have a garbage 'intf' value in the private
    data that might match.
    
    Remove the 'probed' flag from the private data and just use the 'intf'
    pointer to detect the match.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index e82319b28992..a9aa9885fc86 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -210,7 +210,6 @@ struct vmk80xx_private {
 	unsigned char *usb_rx_buf;
 	unsigned char *usb_tx_buf;
 	unsigned long flags;
-	int probed;
 	int attached;
 };
 
@@ -529,8 +528,6 @@ static int rudimentary_check(struct vmk80xx_private *devpriv, int dir)
 {
 	if (!devpriv)
 		return -EFAULT;
-	if (!devpriv->probed)
-		return -ENODEV;
 	if (!devpriv->attached)
 		return -ENODEV;
 	if (dir & DIR_IN) {
@@ -1299,7 +1296,7 @@ static int vmk80xx_auto_attach(struct comedi_device *dev,
 
 	mutex_lock(&glb_mutex);
 	for (i = 0; i < VMK80XX_MAX_BOARDS; i++)
-		if (vmb[i].probed && vmb[i].intf == intf)
+		if (vmb[i].intf == intf)
 			break;
 	if (i == VMK80XX_MAX_BOARDS)
 		ret = -ENODEV;
@@ -1361,7 +1358,7 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 	mutex_lock(&glb_mutex);
 
 	for (i = 0; i < VMK80XX_MAX_BOARDS; i++)
-		if (!vmb[i].probed)
+		if (!vmb[i].intf)
 			break;
 
 	if (i == VMK80XX_MAX_BOARDS) {
@@ -1409,8 +1406,6 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 	if (boardinfo->model == VMK8055_MODEL)
 		vmk80xx_reset_device(devpriv);
 
-	devpriv->probed = 1;
-
 	mutex_unlock(&glb_mutex);
 
 	comedi_usb_auto_config(intf, &vmk80xx_driver);

commit db7dabf707f1eb3c4288ca8bedd4b2aa6701ca7b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:22:27 2013 -0700

    staging: comedi: vmk80xx: make sure private data is clean when detached
    
    Currently the private data used in this driver is stored in a static
    array. During the usb (*probe) and empty location is found in this
    array for use by the usb device. Some initialization of the private
    data is then done before comedi_usb_auto_config() is called to allow
    the comedi core to attach its comedi_device to the usb device.
    
    The (*probe) can fail for various reasons. If it does, make sure that
    the private data is clean before returning an error.
    
    The usb (*disconnect) simply calls comedi_usb_auto_unconfig() to
    allow the comedi core to disconnect its comedi_device from the usb
    device. Since the private data points to the static array it cannot
    be kfree'ed during the detach. Instead make sure it clean before
    leaving the detach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index ec9ff0d2a4c0..e82319b28992 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1323,8 +1323,6 @@ static void vmk80xx_detach(struct comedi_device *dev)
 
 	dev->private = NULL;
 
-	devpriv->attached = 0;
-	devpriv->probed = 0;
 	usb_set_intfdata(devpriv->intf, NULL);
 
 	usb_kill_anchored_urbs(&devpriv->rx_anchor);
@@ -1334,6 +1332,14 @@ static void vmk80xx_detach(struct comedi_device *dev)
 	kfree(devpriv->usb_tx_buf);
 
 	up(&devpriv->limit_sem);
+
+	/*
+	 * Since 'devpriv' points to an element of the static vmb array
+	 * we can't kfree it. Instead memset it to all '0' so subsequent
+	 * usb probes don't find any garbage in it.
+	 */
+	memset(devpriv, 0x00, sizeof(*devpriv));
+
 	mutex_unlock(&glb_mutex);
 }
 
@@ -1359,25 +1365,19 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 			break;
 
 	if (i == VMK80XX_MAX_BOARDS) {
-		mutex_unlock(&glb_mutex);
-		return -EMFILE;
+		ret = -EMFILE;
+		goto fail;
 	}
 
 	devpriv = &vmb[i];
 
-	memset(devpriv, 0x00, sizeof(*devpriv));
-
 	ret = vmk80xx_find_usb_endpoints(devpriv, intf);
-	if (ret) {
-		mutex_unlock(&glb_mutex);
-		return ret;
-	}
+	if (ret)
+		goto error;
 
 	ret = vmk80xx_alloc_usb_buffers(devpriv);
-	if (ret) {
-		mutex_unlock(&glb_mutex);
-		return ret;
-	}
+	if (ret)
+		goto error;
 
 	devpriv->usb = interface_to_usbdev(intf);
 	devpriv->intf = intf;
@@ -1416,6 +1416,17 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 	comedi_usb_auto_config(intf, &vmk80xx_driver);
 
 	return 0;
+
+error:
+	/*
+	 * Since 'devpriv' points to an element of the static vmb array
+	 * we can't kfree it. Instead memset it to all '0' so subsequent
+	 * usb probes don't find any garbage in it.
+	 */
+	memset(devpriv, 0x00, sizeof(*devpriv));
+fail:
+	mutex_unlock(&glb_mutex);
+	return ret;
 }
 
 static const struct usb_device_id vmk80xx_usb_id_table[] = {

commit 1cc8f8854c86b77637b1300b22e553028c6f2668
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:22:03 2013 -0700

    staging: comedi: vmk80xx: remove private data 'count'
    
    The 'count' in the private data is only used in a couple dev_info()
    kernel messages. These messages are just added noise.
    
    Remove the 'count' variable in the private data as well as the
    dev_info() messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index f52d34d1bddf..ec9ff0d2a4c0 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -212,7 +212,6 @@ struct vmk80xx_private {
 	unsigned long flags;
 	int probed;
 	int attached;
-	int count;
 };
 
 static struct vmk80xx_private vmb[VMK80XX_MAX_BOARDS];
@@ -1285,8 +1284,6 @@ static int vmk80xx_attach_common(struct comedi_device *dev,
 	}
 
 	devpriv->attached = 1;
-	dev_info(dev->class_dev, "vmk80xx: board #%d [%s] attached\n",
-		 devpriv->count, boardinfo->name);
 
 	up(&devpriv->limit_sem);
 
@@ -1369,7 +1366,6 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 	devpriv = &vmb[i];
 
 	memset(devpriv, 0x00, sizeof(*devpriv));
-	devpriv->count = i;
 
 	ret = vmk80xx_find_usb_endpoints(devpriv, intf);
 	if (ret) {
@@ -1415,9 +1411,6 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 
 	devpriv->probed = 1;
 
-	dev_info(&intf->dev, "board #%d [%s] now attached\n",
-		 devpriv->count, boardinfo->name);
-
 	mutex_unlock(&glb_mutex);
 
 	comedi_usb_auto_config(intf, &vmk80xx_driver);

commit 78f8fa7f00689f4385c28b1b2be30c83f331c497
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:21:40 2013 -0700

    staging: comedi: vmk80xx: factor out usb buffer allocation
    
    Factor the code that allocates the usb buffers out of vmk80xx_usb_probe().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 26c10a864684..f52d34d1bddf 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1172,6 +1172,25 @@ static int vmk80xx_find_usb_endpoints(struct vmk80xx_private *devpriv,
 	return 0;
 }
 
+static int vmk80xx_alloc_usb_buffers(struct vmk80xx_private *devpriv)
+{
+	size_t size;
+
+	size = le16_to_cpu(devpriv->ep_rx->wMaxPacketSize);
+	devpriv->usb_rx_buf = kmalloc(size, GFP_KERNEL);
+	if (!devpriv->usb_rx_buf)
+		return -ENOMEM;
+
+	size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
+	devpriv->usb_tx_buf = kmalloc(size, GFP_KERNEL);
+	if (!devpriv->usb_tx_buf) {
+		kfree(devpriv->usb_rx_buf);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
 static int vmk80xx_attach_common(struct comedi_device *dev,
 				 struct vmk80xx_private *devpriv)
 {
@@ -1333,7 +1352,6 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 {
 	const struct vmk80xx_board *boardinfo;
 	struct vmk80xx_private *devpriv;
-	size_t size;
 	int ret;
 	int i;
 
@@ -1359,19 +1377,10 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 		return ret;
 	}
 
-	size = le16_to_cpu(devpriv->ep_rx->wMaxPacketSize);
-	devpriv->usb_rx_buf = kmalloc(size, GFP_KERNEL);
-	if (!devpriv->usb_rx_buf) {
-		mutex_unlock(&glb_mutex);
-		return -ENOMEM;
-	}
-
-	size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
-	devpriv->usb_tx_buf = kmalloc(size, GFP_KERNEL);
-	if (!devpriv->usb_tx_buf) {
-		kfree(devpriv->usb_rx_buf);
+	ret = vmk80xx_alloc_usb_buffers(devpriv);
+	if (ret) {
 		mutex_unlock(&glb_mutex);
-		return -ENOMEM;
+		return ret;
 	}
 
 	devpriv->usb = interface_to_usbdev(intf);

commit 49253d542cc0f5f771dc254d248162a2a666649d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:21:19 2013 -0700

    staging: comedi: vmk80xx: factor out usb endpoint detection
    
    Factor the code that detects the usb endpoints out of vmk80xx_usb_probe().
    
    Cleanup the detection code in the new function,
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 76b99ad7e240..26c10a864684 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1138,6 +1138,40 @@ static int vmk80xx_pwm_winsn(struct comedi_device *dev,
 	return n;
 }
 
+static int vmk80xx_find_usb_endpoints(struct vmk80xx_private *devpriv,
+				      struct usb_interface *intf)
+{
+	struct usb_host_interface *iface_desc = intf->cur_altsetting;
+	struct usb_endpoint_descriptor *ep_desc;
+	int i;
+
+	if (iface_desc->desc.bNumEndpoints != 2)
+		return -ENODEV;
+
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
+		ep_desc = &iface_desc->endpoint[i].desc;
+
+		if (usb_endpoint_is_int_in(ep_desc) ||
+		    usb_endpoint_is_bulk_in(ep_desc)) {
+			if (!devpriv->ep_rx)
+				devpriv->ep_rx = ep_desc;
+			continue;
+		}
+
+		if (usb_endpoint_is_int_out(ep_desc) ||
+		    usb_endpoint_is_bulk_out(ep_desc)) {
+			if (!devpriv->ep_tx)
+				devpriv->ep_tx = ep_desc;
+			continue;
+		}
+	}
+
+	if (!devpriv->ep_rx || !devpriv->ep_tx)
+		return -ENODEV;
+
+	return 0;
+}
+
 static int vmk80xx_attach_common(struct comedi_device *dev,
 				 struct vmk80xx_private *devpriv)
 {
@@ -1299,9 +1333,8 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 {
 	const struct vmk80xx_board *boardinfo;
 	struct vmk80xx_private *devpriv;
-	struct usb_host_interface *iface_desc;
-	struct usb_endpoint_descriptor *ep_desc;
 	size_t size;
+	int ret;
 	int i;
 
 	mutex_lock(&glb_mutex);
@@ -1320,37 +1353,12 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 	memset(devpriv, 0x00, sizeof(*devpriv));
 	devpriv->count = i;
 
-	iface_desc = intf->cur_altsetting;
-	if (iface_desc->desc.bNumEndpoints != 2)
-		goto error;
-
-	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
-		ep_desc = &iface_desc->endpoint[i].desc;
-
-		if (usb_endpoint_is_int_in(ep_desc)) {
-			devpriv->ep_rx = ep_desc;
-			continue;
-		}
-
-		if (usb_endpoint_is_int_out(ep_desc)) {
-			devpriv->ep_tx = ep_desc;
-			continue;
-		}
-
-		if (usb_endpoint_is_bulk_in(ep_desc)) {
-			devpriv->ep_rx = ep_desc;
-			continue;
-		}
-
-		if (usb_endpoint_is_bulk_out(ep_desc)) {
-			devpriv->ep_tx = ep_desc;
-			continue;
-		}
+	ret = vmk80xx_find_usb_endpoints(devpriv, intf);
+	if (ret) {
+		mutex_unlock(&glb_mutex);
+		return ret;
 	}
 
-	if (!devpriv->ep_rx || !devpriv->ep_tx)
-		goto error;
-
 	size = le16_to_cpu(devpriv->ep_rx->wMaxPacketSize);
 	devpriv->usb_rx_buf = kmalloc(size, GFP_KERNEL);
 	if (!devpriv->usb_rx_buf) {
@@ -1406,10 +1414,6 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 	comedi_usb_auto_config(intf, &vmk80xx_driver);
 
 	return 0;
-error:
-	mutex_unlock(&glb_mutex);
-
-	return -ENODEV;
 }
 
 static const struct usb_device_id vmk80xx_usb_id_table[] = {

commit da7b18ee8b552b9b340c44fa8f6de1372a251a78
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:20:58 2013 -0700

    staging: comedi: vmk80xx: consistently use the same local var names
    
    Rename some of the local variables used in this driver to make the
    code easier to maintain and understand.
    
    s/udev/usb      the usb_device that the comedi_driver is attached to
    s/dev/devpriv   the private data of the comedi_device
    s/cdev/dev      the comedi_device
    
    Also, use some local variables in a couple of the functions to tidy
    up the code a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index a14528613249..76b99ad7e240 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -196,7 +196,7 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 };
 
 struct vmk80xx_private {
-	struct usb_device *udev;
+	struct usb_device *usb;
 	struct usb_interface *intf;
 	struct usb_endpoint_descriptor *ep_rx;
 	struct usb_endpoint_descriptor *ep_tx;
@@ -221,7 +221,8 @@ static DEFINE_MUTEX(glb_mutex);
 
 static void vmk80xx_tx_callback(struct urb *urb)
 {
-	struct vmk80xx_private *dev = urb->context;
+	struct vmk80xx_private *devpriv = urb->context;
+	unsigned long *flags = &devpriv->flags;
 	int stat = urb->status;
 
 	if (stat && !(stat == -ENOENT
@@ -229,17 +230,18 @@ static void vmk80xx_tx_callback(struct urb *urb)
 		dbgcm("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",
 		      __func__, stat);
 
-	if (!test_bit(TRANS_OUT_BUSY, &dev->flags))
+	if (!test_bit(TRANS_OUT_BUSY, flags))
 		return;
 
-	clear_bit(TRANS_OUT_BUSY, &dev->flags);
+	clear_bit(TRANS_OUT_BUSY, flags);
 
-	wake_up_interruptible(&dev->write_wait);
+	wake_up_interruptible(&devpriv->write_wait);
 }
 
 static void vmk80xx_rx_callback(struct urb *urb)
 {
-	struct vmk80xx_private *dev = urb->context;
+	struct vmk80xx_private *devpriv = urb->context;
+	unsigned long *flags = &devpriv->flags;
 	int stat = urb->status;
 
 	switch (stat) {
@@ -257,8 +259,8 @@ static void vmk80xx_rx_callback(struct urb *urb)
 
 	goto exit;
 resubmit:
-	if (test_bit(TRANS_IN_RUNNING, &dev->flags) && dev->intf) {
-		usb_anchor_urb(urb, &dev->rx_anchor);
+	if (test_bit(TRANS_IN_RUNNING, flags) && devpriv->intf) {
+		usb_anchor_urb(urb, &devpriv->rx_anchor);
 
 		if (!usb_submit_urb(urb, GFP_KERNEL))
 			goto exit;
@@ -270,20 +272,21 @@ static void vmk80xx_rx_callback(struct urb *urb)
 		usb_unanchor_urb(urb);
 	}
 exit:
-	clear_bit(TRANS_IN_BUSY, &dev->flags);
+	clear_bit(TRANS_IN_BUSY, flags);
 
-	wake_up_interruptible(&dev->read_wait);
+	wake_up_interruptible(&devpriv->read_wait);
 }
 
-static int vmk80xx_check_data_link(struct vmk80xx_private *dev)
+static int vmk80xx_check_data_link(struct vmk80xx_private *devpriv)
 {
+	struct usb_device *usb = devpriv->usb;
 	unsigned int tx_pipe;
 	unsigned int rx_pipe;
 	unsigned char tx[1];
 	unsigned char rx[2];
 
-	tx_pipe = usb_sndbulkpipe(dev->udev, 0x01);
-	rx_pipe = usb_rcvbulkpipe(dev->udev, 0x81);
+	tx_pipe = usb_sndbulkpipe(usb, 0x01);
+	rx_pipe = usb_rcvbulkpipe(usb, 0x81);
 
 	tx[0] = VMK8061_CMD_RD_PWR_STAT;
 
@@ -292,22 +295,23 @@ static int vmk80xx_check_data_link(struct vmk80xx_private *dev)
 	 * running and the data link between IC3 and
 	 * IC6 is working properly
 	 */
-	usb_bulk_msg(dev->udev, tx_pipe, tx, 1, NULL, dev->ep_tx->bInterval);
-	usb_bulk_msg(dev->udev, rx_pipe, rx, 2, NULL, HZ * 10);
+	usb_bulk_msg(usb, tx_pipe, tx, 1, NULL, devpriv->ep_tx->bInterval);
+	usb_bulk_msg(usb, rx_pipe, rx, 2, NULL, HZ * 10);
 
 	return (int)rx[1];
 }
 
-static void vmk80xx_read_eeprom(struct vmk80xx_private *dev, int flag)
+static void vmk80xx_read_eeprom(struct vmk80xx_private *devpriv, int flag)
 {
+	struct usb_device *usb = devpriv->usb;
 	unsigned int tx_pipe;
 	unsigned int rx_pipe;
 	unsigned char tx[1];
 	unsigned char rx[64];
 	int cnt;
 
-	tx_pipe = usb_sndbulkpipe(dev->udev, 0x01);
-	rx_pipe = usb_rcvbulkpipe(dev->udev, 0x81);
+	tx_pipe = usb_sndbulkpipe(usb, 0x01);
+	rx_pipe = usb_rcvbulkpipe(usb, 0x81);
 
 	tx[0] = VMK8061_CMD_RD_VERSION;
 
@@ -315,19 +319,21 @@ static void vmk80xx_read_eeprom(struct vmk80xx_private *dev, int flag)
 	 * Read the firmware version info of IC3 and
 	 * IC6 from the internal EEPROM of the IC
 	 */
-	usb_bulk_msg(dev->udev, tx_pipe, tx, 1, NULL, dev->ep_tx->bInterval);
-	usb_bulk_msg(dev->udev, rx_pipe, rx, 64, &cnt, HZ * 10);
+	usb_bulk_msg(usb, tx_pipe, tx, 1, NULL, devpriv->ep_tx->bInterval);
+	usb_bulk_msg(usb, rx_pipe, rx, 64, &cnt, HZ * 10);
 
 	rx[cnt] = '\0';
 
 	if (flag & IC3_VERSION)
-		strncpy(dev->fw.ic3_vers, rx + 1, 24);
+		strncpy(devpriv->fw.ic3_vers, rx + 1, 24);
 	else			/* IC6_VERSION */
-		strncpy(dev->fw.ic6_vers, rx + 25, 24);
+		strncpy(devpriv->fw.ic6_vers, rx + 25, 24);
 }
 
-static int vmk80xx_reset_device(struct vmk80xx_private *dev)
+static int vmk80xx_reset_device(struct vmk80xx_private *devpriv)
 {
+	struct usb_device *usb = devpriv->usb;
+	unsigned char *tx_buf = devpriv->usb_tx_buf;
 	struct urb *urb;
 	unsigned int tx_pipe;
 	int ival;
@@ -337,31 +343,32 @@ static int vmk80xx_reset_device(struct vmk80xx_private *dev)
 	if (!urb)
 		return -ENOMEM;
 
-	tx_pipe = usb_sndintpipe(dev->udev, 0x01);
+	tx_pipe = usb_sndintpipe(usb, 0x01);
 
-	ival = dev->ep_tx->bInterval;
-	size = le16_to_cpu(dev->ep_tx->wMaxPacketSize);
+	ival = devpriv->ep_tx->bInterval;
+	size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
 
-	dev->usb_tx_buf[0] = VMK8055_CMD_RST;
-	dev->usb_tx_buf[1] = 0x00;
-	dev->usb_tx_buf[2] = 0x00;
-	dev->usb_tx_buf[3] = 0x00;
-	dev->usb_tx_buf[4] = 0x00;
-	dev->usb_tx_buf[5] = 0x00;
-	dev->usb_tx_buf[6] = 0x00;
-	dev->usb_tx_buf[7] = 0x00;
+	tx_buf[0] = VMK8055_CMD_RST;
+	tx_buf[1] = 0x00;
+	tx_buf[2] = 0x00;
+	tx_buf[3] = 0x00;
+	tx_buf[4] = 0x00;
+	tx_buf[5] = 0x00;
+	tx_buf[6] = 0x00;
+	tx_buf[7] = 0x00;
 
-	usb_fill_int_urb(urb, dev->udev, tx_pipe, dev->usb_tx_buf,
-			 size, vmk80xx_tx_callback, dev, ival);
+	usb_fill_int_urb(urb, usb, tx_pipe, tx_buf, size,
+			 vmk80xx_tx_callback, devpriv, ival);
 
-	usb_anchor_urb(urb, &dev->tx_anchor);
+	usb_anchor_urb(urb, &devpriv->tx_anchor);
 
 	return usb_submit_urb(urb, GFP_KERNEL);
 }
 
 static void vmk80xx_build_int_urb(struct urb *urb, int flag)
 {
-	struct vmk80xx_private *dev = urb->context;
+	struct vmk80xx_private *devpriv = urb->context;
+	struct usb_device *usb = devpriv->usb;
 	__u8 rx_addr;
 	__u8 tx_addr;
 	unsigned int pipe;
@@ -371,72 +378,74 @@ static void vmk80xx_build_int_urb(struct urb *urb, int flag)
 	int ival;
 
 	if (flag & URB_RCV_FLAG) {
-		rx_addr = dev->ep_rx->bEndpointAddress;
-		pipe = usb_rcvintpipe(dev->udev, rx_addr);
-		buf = dev->usb_rx_buf;
-		size = le16_to_cpu(dev->ep_rx->wMaxPacketSize);
+		rx_addr = devpriv->ep_rx->bEndpointAddress;
+		pipe = usb_rcvintpipe(usb, rx_addr);
+		buf = devpriv->usb_rx_buf;
+		size = le16_to_cpu(devpriv->ep_rx->wMaxPacketSize);
 		callback = vmk80xx_rx_callback;
-		ival = dev->ep_rx->bInterval;
+		ival = devpriv->ep_rx->bInterval;
 	} else {		/* URB_SND_FLAG */
-		tx_addr = dev->ep_tx->bEndpointAddress;
-		pipe = usb_sndintpipe(dev->udev, tx_addr);
-		buf = dev->usb_tx_buf;
-		size = le16_to_cpu(dev->ep_tx->wMaxPacketSize);
+		tx_addr = devpriv->ep_tx->bEndpointAddress;
+		pipe = usb_sndintpipe(usb, tx_addr);
+		buf = devpriv->usb_tx_buf;
+		size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
 		callback = vmk80xx_tx_callback;
-		ival = dev->ep_tx->bInterval;
+		ival = devpriv->ep_tx->bInterval;
 	}
 
-	usb_fill_int_urb(urb, dev->udev, pipe, buf, size, callback, dev, ival);
+	usb_fill_int_urb(urb, usb, pipe, buf, size, callback, devpriv, ival);
 }
 
-static void vmk80xx_do_bulk_msg(struct vmk80xx_private *dev)
+static void vmk80xx_do_bulk_msg(struct vmk80xx_private *devpriv)
 {
+	struct usb_device *usb = devpriv->usb;
+	unsigned long *flags = &devpriv->flags;
 	__u8 tx_addr;
 	__u8 rx_addr;
 	unsigned int tx_pipe;
 	unsigned int rx_pipe;
 	size_t size;
 
-	set_bit(TRANS_IN_BUSY, &dev->flags);
-	set_bit(TRANS_OUT_BUSY, &dev->flags);
+	set_bit(TRANS_IN_BUSY, flags);
+	set_bit(TRANS_OUT_BUSY, flags);
 
-	tx_addr = dev->ep_tx->bEndpointAddress;
-	rx_addr = dev->ep_rx->bEndpointAddress;
-	tx_pipe = usb_sndbulkpipe(dev->udev, tx_addr);
-	rx_pipe = usb_rcvbulkpipe(dev->udev, rx_addr);
+	tx_addr = devpriv->ep_tx->bEndpointAddress;
+	rx_addr = devpriv->ep_rx->bEndpointAddress;
+	tx_pipe = usb_sndbulkpipe(usb, tx_addr);
+	rx_pipe = usb_rcvbulkpipe(usb, rx_addr);
 
 	/*
 	 * The max packet size attributes of the K8061
 	 * input/output endpoints are identical
 	 */
-	size = le16_to_cpu(dev->ep_tx->wMaxPacketSize);
+	size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
 
-	usb_bulk_msg(dev->udev, tx_pipe, dev->usb_tx_buf,
-		     size, NULL, dev->ep_tx->bInterval);
-	usb_bulk_msg(dev->udev, rx_pipe, dev->usb_rx_buf, size, NULL, HZ * 10);
+	usb_bulk_msg(usb, tx_pipe, devpriv->usb_tx_buf,
+		     size, NULL, devpriv->ep_tx->bInterval);
+	usb_bulk_msg(usb, rx_pipe, devpriv->usb_rx_buf, size, NULL, HZ * 10);
 
-	clear_bit(TRANS_OUT_BUSY, &dev->flags);
-	clear_bit(TRANS_IN_BUSY, &dev->flags);
+	clear_bit(TRANS_OUT_BUSY, flags);
+	clear_bit(TRANS_IN_BUSY, flags);
 }
 
-static int vmk80xx_read_packet(struct vmk80xx_private *dev)
+static int vmk80xx_read_packet(struct vmk80xx_private *devpriv)
 {
-	const struct vmk80xx_board *boardinfo = dev->board;
+	const struct vmk80xx_board *boardinfo = devpriv->board;
+	unsigned long *flags = &devpriv->flags;
 	struct urb *urb;
 	int retval;
 
-	if (!dev->intf)
+	if (!devpriv->intf)
 		return -ENODEV;
 
 	/* Only useful for interrupt transfers */
-	if (test_bit(TRANS_IN_BUSY, &dev->flags))
-		if (wait_event_interruptible(dev->read_wait,
-					     !test_bit(TRANS_IN_BUSY,
-						       &dev->flags)))
+	if (test_bit(TRANS_IN_BUSY, flags))
+		if (wait_event_interruptible(devpriv->read_wait,
+					     !test_bit(TRANS_IN_BUSY, flags)))
 			return -ERESTART;
 
 	if (boardinfo->model == VMK8061_MODEL) {
-		vmk80xx_do_bulk_msg(dev);
+		vmk80xx_do_bulk_msg(devpriv);
 
 		return 0;
 	}
@@ -445,19 +454,19 @@ static int vmk80xx_read_packet(struct vmk80xx_private *dev)
 	if (!urb)
 		return -ENOMEM;
 
-	urb->context = dev;
+	urb->context = devpriv;
 	vmk80xx_build_int_urb(urb, URB_RCV_FLAG);
 
-	set_bit(TRANS_IN_RUNNING, &dev->flags);
-	set_bit(TRANS_IN_BUSY, &dev->flags);
+	set_bit(TRANS_IN_RUNNING, flags);
+	set_bit(TRANS_IN_BUSY, flags);
 
-	usb_anchor_urb(urb, &dev->rx_anchor);
+	usb_anchor_urb(urb, &devpriv->rx_anchor);
 
 	retval = usb_submit_urb(urb, GFP_KERNEL);
 	if (!retval)
 		goto exit;
 
-	clear_bit(TRANS_IN_RUNNING, &dev->flags);
+	clear_bit(TRANS_IN_RUNNING, flags);
 	usb_unanchor_urb(urb);
 
 exit:
@@ -466,24 +475,24 @@ static int vmk80xx_read_packet(struct vmk80xx_private *dev)
 	return retval;
 }
 
-static int vmk80xx_write_packet(struct vmk80xx_private *dev, int cmd)
+static int vmk80xx_write_packet(struct vmk80xx_private *devpriv, int cmd)
 {
-	const struct vmk80xx_board *boardinfo = dev->board;
+	const struct vmk80xx_board *boardinfo = devpriv->board;
+	unsigned long *flags = &devpriv->flags;
 	struct urb *urb;
 	int retval;
 
-	if (!dev->intf)
+	if (!devpriv->intf)
 		return -ENODEV;
 
-	if (test_bit(TRANS_OUT_BUSY, &dev->flags))
-		if (wait_event_interruptible(dev->write_wait,
-					     !test_bit(TRANS_OUT_BUSY,
-						       &dev->flags)))
+	if (test_bit(TRANS_OUT_BUSY, flags))
+		if (wait_event_interruptible(devpriv->write_wait,
+					     !test_bit(TRANS_OUT_BUSY, flags)))
 			return -ERESTART;
 
 	if (boardinfo->model == VMK8061_MODEL) {
-		dev->usb_tx_buf[0] = cmd;
-		vmk80xx_do_bulk_msg(dev);
+		devpriv->usb_tx_buf[0] = cmd;
+		vmk80xx_do_bulk_msg(devpriv);
 
 		return 0;
 	}
@@ -492,20 +501,20 @@ static int vmk80xx_write_packet(struct vmk80xx_private *dev, int cmd)
 	if (!urb)
 		return -ENOMEM;
 
-	urb->context = dev;
+	urb->context = devpriv;
 	vmk80xx_build_int_urb(urb, URB_SND_FLAG);
 
-	set_bit(TRANS_OUT_BUSY, &dev->flags);
+	set_bit(TRANS_OUT_BUSY, flags);
 
-	usb_anchor_urb(urb, &dev->tx_anchor);
+	usb_anchor_urb(urb, &devpriv->tx_anchor);
 
-	dev->usb_tx_buf[0] = cmd;
+	devpriv->usb_tx_buf[0] = cmd;
 
 	retval = usb_submit_urb(urb, GFP_KERNEL);
 	if (!retval)
 		goto exit;
 
-	clear_bit(TRANS_OUT_BUSY, &dev->flags);
+	clear_bit(TRANS_OUT_BUSY, flags);
 	usb_unanchor_urb(urb);
 
 exit:
@@ -517,41 +526,41 @@ static int vmk80xx_write_packet(struct vmk80xx_private *dev, int cmd)
 #define DIR_IN  1
 #define DIR_OUT 2
 
-static int rudimentary_check(struct vmk80xx_private *dev, int dir)
+static int rudimentary_check(struct vmk80xx_private *devpriv, int dir)
 {
-	if (!dev)
+	if (!devpriv)
 		return -EFAULT;
-	if (!dev->probed)
+	if (!devpriv->probed)
 		return -ENODEV;
-	if (!dev->attached)
+	if (!devpriv->attached)
 		return -ENODEV;
 	if (dir & DIR_IN) {
-		if (test_bit(TRANS_IN_BUSY, &dev->flags))
+		if (test_bit(TRANS_IN_BUSY, &devpriv->flags))
 			return -EBUSY;
 	}
 	if (dir & DIR_OUT) {
-		if (test_bit(TRANS_OUT_BUSY, &dev->flags))
+		if (test_bit(TRANS_OUT_BUSY, &devpriv->flags))
 			return -EBUSY;
 	}
 
 	return 0;
 }
 
-static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
+static int vmk80xx_ai_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_private *dev = cdev->private;
+	const struct vmk80xx_board *boardinfo = comedi_board(dev);
+	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
 	int reg[2];
 	int n;
 
-	n = rudimentary_check(dev, DIR_IN);
+	n = rudimentary_check(devpriv, DIR_IN);
 	if (n)
 		return n;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
 	switch (boardinfo->model) {
@@ -565,46 +574,46 @@ static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
 	default:
 		reg[0] = VMK8061_AI_REG1;
 		reg[1] = VMK8061_AI_REG2;
-		dev->usb_tx_buf[0] = VMK8061_CMD_RD_AI;
-		dev->usb_tx_buf[VMK8061_CH_REG] = chan;
+		devpriv->usb_tx_buf[0] = VMK8061_CMD_RD_AI;
+		devpriv->usb_tx_buf[VMK8061_CH_REG] = chan;
 		break;
 	}
 
 	for (n = 0; n < insn->n; n++) {
-		if (vmk80xx_read_packet(dev))
+		if (vmk80xx_read_packet(devpriv))
 			break;
 
 		if (boardinfo->model == VMK8055_MODEL) {
-			data[n] = dev->usb_rx_buf[reg[0]];
+			data[n] = devpriv->usb_rx_buf[reg[0]];
 			continue;
 		}
 
 		/* VMK8061_MODEL */
-		data[n] = dev->usb_rx_buf[reg[0]] + 256 *
-		    dev->usb_rx_buf[reg[1]];
+		data[n] = devpriv->usb_rx_buf[reg[0]] + 256 *
+		    devpriv->usb_rx_buf[reg[1]];
 	}
 
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return n;
 }
 
-static int vmk80xx_ao_winsn(struct comedi_device *cdev,
+static int vmk80xx_ao_winsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_private *dev = cdev->private;
+	const struct vmk80xx_board *boardinfo = comedi_board(dev);
+	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
 	int cmd;
 	int reg;
 	int n;
 
-	n = rudimentary_check(dev, DIR_OUT);
+	n = rudimentary_check(devpriv, DIR_OUT);
 	if (n)
 		return n;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
 	switch (boardinfo->model) {
@@ -618,80 +627,80 @@ static int vmk80xx_ao_winsn(struct comedi_device *cdev,
 	default:		/* NOTE: avoid compiler warnings */
 		cmd = VMK8061_CMD_SET_AO;
 		reg = VMK8061_AO_REG;
-		dev->usb_tx_buf[VMK8061_CH_REG] = chan;
+		devpriv->usb_tx_buf[VMK8061_CH_REG] = chan;
 		break;
 	}
 
 	for (n = 0; n < insn->n; n++) {
-		dev->usb_tx_buf[reg] = data[n];
+		devpriv->usb_tx_buf[reg] = data[n];
 
-		if (vmk80xx_write_packet(dev, cmd))
+		if (vmk80xx_write_packet(devpriv, cmd))
 			break;
 	}
 
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return n;
 }
 
-static int vmk80xx_ao_rinsn(struct comedi_device *cdev,
+static int vmk80xx_ao_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_private *dev = cdev->private;
+	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
 	int reg;
 	int n;
 
-	n = rudimentary_check(dev, DIR_IN);
+	n = rudimentary_check(devpriv, DIR_IN);
 	if (n)
 		return n;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
 	reg = VMK8061_AO_REG - 1;
 
-	dev->usb_tx_buf[0] = VMK8061_CMD_RD_AO;
+	devpriv->usb_tx_buf[0] = VMK8061_CMD_RD_AO;
 
 	for (n = 0; n < insn->n; n++) {
-		if (vmk80xx_read_packet(dev))
+		if (vmk80xx_read_packet(devpriv))
 			break;
 
-		data[n] = dev->usb_rx_buf[reg + chan];
+		data[n] = devpriv->usb_rx_buf[reg + chan];
 	}
 
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return n;
 }
 
-static int vmk80xx_di_bits(struct comedi_device *cdev,
+static int vmk80xx_di_bits(struct comedi_device *dev,
 			   struct comedi_subdevice *s,
 			   struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_private *dev = cdev->private;
+	const struct vmk80xx_board *boardinfo = comedi_board(dev);
+	struct vmk80xx_private *devpriv = dev->private;
 	unsigned char *rx_buf;
 	int reg;
 	int retval;
 
-	retval = rudimentary_check(dev, DIR_IN);
+	retval = rudimentary_check(devpriv, DIR_IN);
 	if (retval)
 		return retval;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
 
-	rx_buf = dev->usb_rx_buf;
+	rx_buf = devpriv->usb_rx_buf;
 
 	if (boardinfo->model == VMK8061_MODEL) {
 		reg = VMK8061_DI_REG;
-		dev->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
+		devpriv->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
 	} else {
 		reg = VMK8055_DI_REG;
 	}
 
-	retval = vmk80xx_read_packet(dev);
+	retval = vmk80xx_read_packet(devpriv);
 
 	if (!retval) {
 		if (boardinfo->model == VMK8055_MODEL)
@@ -704,40 +713,40 @@ static int vmk80xx_di_bits(struct comedi_device *cdev,
 		retval = 2;
 	}
 
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return retval;
 }
 
-static int vmk80xx_di_rinsn(struct comedi_device *cdev,
+static int vmk80xx_di_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_private *dev = cdev->private;
+	const struct vmk80xx_board *boardinfo = comedi_board(dev);
+	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
 	unsigned char *rx_buf;
 	int reg;
 	int inp;
 	int n;
 
-	n = rudimentary_check(dev, DIR_IN);
+	n = rudimentary_check(devpriv, DIR_IN);
 	if (n)
 		return n;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
-	rx_buf = dev->usb_rx_buf;
+	rx_buf = devpriv->usb_rx_buf;
 
 	if (boardinfo->model == VMK8061_MODEL) {
 		reg = VMK8061_DI_REG;
-		dev->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
+		devpriv->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
 	} else {
 		reg = VMK8055_DI_REG;
 	}
 	for (n = 0; n < insn->n; n++) {
-		if (vmk80xx_read_packet(dev))
+		if (vmk80xx_read_packet(devpriv))
 			break;
 
 		if (boardinfo->model == VMK8055_MODEL)
@@ -750,31 +759,31 @@ static int vmk80xx_di_rinsn(struct comedi_device *cdev,
 		data[n] = (inp >> chan) & 1;
 	}
 
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return n;
 }
 
-static int vmk80xx_do_winsn(struct comedi_device *cdev,
+static int vmk80xx_do_winsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_private *dev = cdev->private;
+	const struct vmk80xx_board *boardinfo = comedi_board(dev);
+	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
 	unsigned char *tx_buf;
 	int reg;
 	int cmd;
 	int n;
 
-	n = rudimentary_check(dev, DIR_OUT);
+	n = rudimentary_check(devpriv, DIR_OUT);
 	if (n)
 		return n;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
-	tx_buf = dev->usb_tx_buf;
+	tx_buf = devpriv->usb_tx_buf;
 
 	for (n = 0; n < insn->n; n++) {
 		if (boardinfo->model == VMK8055_MODEL) {
@@ -795,53 +804,53 @@ static int vmk80xx_do_winsn(struct comedi_device *cdev,
 			}
 		}
 
-		if (vmk80xx_write_packet(dev, cmd))
+		if (vmk80xx_write_packet(devpriv, cmd))
 			break;
 	}
 
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return n;
 }
 
-static int vmk80xx_do_rinsn(struct comedi_device *cdev,
+static int vmk80xx_do_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_private *dev = cdev->private;
+	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
 	int reg;
 	int n;
 
-	n = rudimentary_check(dev, DIR_IN);
+	n = rudimentary_check(devpriv, DIR_IN);
 	if (n)
 		return n;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
 	reg = VMK8061_DO_REG;
 
-	dev->usb_tx_buf[0] = VMK8061_CMD_RD_DO;
+	devpriv->usb_tx_buf[0] = VMK8061_CMD_RD_DO;
 
 	for (n = 0; n < insn->n; n++) {
-		if (vmk80xx_read_packet(dev))
+		if (vmk80xx_read_packet(devpriv))
 			break;
 
-		data[n] = (dev->usb_rx_buf[reg] >> chan) & 1;
+		data[n] = (devpriv->usb_rx_buf[reg] >> chan) & 1;
 	}
 
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return n;
 }
 
-static int vmk80xx_do_bits(struct comedi_device *cdev,
+static int vmk80xx_do_bits(struct comedi_device *dev,
 			   struct comedi_subdevice *s,
 			   struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_private *dev = cdev->private;
+	const struct vmk80xx_board *boardinfo = comedi_board(dev);
+	struct vmk80xx_private *devpriv = dev->private;
 	unsigned char *rx_buf, *tx_buf;
 	int dir, reg, cmd;
 	int retval;
@@ -854,14 +863,14 @@ static int vmk80xx_do_bits(struct comedi_device *cdev,
 	if (boardinfo->model == VMK8061_MODEL)
 		dir |= DIR_IN;
 
-	retval = rudimentary_check(dev, dir);
+	retval = rudimentary_check(devpriv, dir);
 	if (retval)
 		return retval;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
 
-	rx_buf = dev->usb_rx_buf;
-	tx_buf = dev->usb_tx_buf;
+	rx_buf = devpriv->usb_rx_buf;
+	tx_buf = devpriv->usb_tx_buf;
 
 	if (data[0]) {
 		if (boardinfo->model == VMK8055_MODEL) {
@@ -875,7 +884,7 @@ static int vmk80xx_do_bits(struct comedi_device *cdev,
 		tx_buf[reg] &= ~data[0];
 		tx_buf[reg] |= (data[0] & data[1]);
 
-		retval = vmk80xx_write_packet(dev, cmd);
+		retval = vmk80xx_write_packet(devpriv, cmd);
 
 		if (retval)
 			goto out;
@@ -885,7 +894,7 @@ static int vmk80xx_do_bits(struct comedi_device *cdev,
 		reg = VMK8061_DO_REG;
 		tx_buf[0] = VMK8061_CMD_RD_DO;
 
-		retval = vmk80xx_read_packet(dev);
+		retval = vmk80xx_read_packet(devpriv);
 
 		if (!retval) {
 			data[1] = rx_buf[reg];
@@ -897,26 +906,26 @@ static int vmk80xx_do_bits(struct comedi_device *cdev,
 	}
 
 out:
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return retval;
 }
 
-static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
+static int vmk80xx_cnt_rinsn(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_private *dev = cdev->private;
+	const struct vmk80xx_board *boardinfo = comedi_board(dev);
+	struct vmk80xx_private *devpriv = dev->private;
 	int chan;
 	int reg[2];
 	int n;
 
-	n = rudimentary_check(dev, DIR_IN);
+	n = rudimentary_check(devpriv, DIR_IN);
 	if (n)
 		return n;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
 	switch (boardinfo->model) {
@@ -930,39 +939,39 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 	default:
 		reg[0] = VMK8061_CNT_REG;
 		reg[1] = VMK8061_CNT_REG;
-		dev->usb_tx_buf[0] = VMK8061_CMD_RD_CNT;
+		devpriv->usb_tx_buf[0] = VMK8061_CMD_RD_CNT;
 		break;
 	}
 
 	for (n = 0; n < insn->n; n++) {
-		if (vmk80xx_read_packet(dev))
+		if (vmk80xx_read_packet(devpriv))
 			break;
 
 		if (boardinfo->model == VMK8055_MODEL)
-			data[n] = dev->usb_rx_buf[reg[0]];
+			data[n] = devpriv->usb_rx_buf[reg[0]];
 		else /* VMK8061_MODEL */
-			data[n] = dev->usb_rx_buf[reg[0] * (chan + 1) + 1]
-			    + 256 * dev->usb_rx_buf[reg[1] * 2 + 2];
+			data[n] = devpriv->usb_rx_buf[reg[0] * (chan + 1) + 1]
+			    + 256 * devpriv->usb_rx_buf[reg[1] * 2 + 2];
 	}
 
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return n;
 }
 
-static int vmk80xx_cnt_cinsn(struct comedi_device *cdev,
+static int vmk80xx_cnt_cinsn(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_private *dev = cdev->private;
+	const struct vmk80xx_board *boardinfo = comedi_board(dev);
+	struct vmk80xx_private *devpriv = dev->private;
 	unsigned int insn_cmd;
 	int chan;
 	int cmd;
 	int reg;
 	int n;
 
-	n = rudimentary_check(dev, DIR_OUT);
+	n = rudimentary_check(devpriv, DIR_OUT);
 	if (n)
 		return n;
 
@@ -970,7 +979,7 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *cdev,
 	if (insn_cmd != INSN_CONFIG_RESET && insn_cmd != GPCT_RESET)
 		return -EINVAL;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
 
 	chan = CR_CHAN(insn->chanspec);
 
@@ -983,36 +992,36 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *cdev,
 			reg = VMK8055_CNT2_REG;
 		}
 
-		dev->usb_tx_buf[reg] = 0x00;
+		devpriv->usb_tx_buf[reg] = 0x00;
 	} else {
 		cmd = VMK8061_CMD_RST_CNT;
 	}
 
 	for (n = 0; n < insn->n; n++)
-		if (vmk80xx_write_packet(dev, cmd))
+		if (vmk80xx_write_packet(devpriv, cmd))
 			break;
 
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return n;
 }
 
-static int vmk80xx_cnt_winsn(struct comedi_device *cdev,
+static int vmk80xx_cnt_winsn(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_private *dev = cdev->private;
+	struct vmk80xx_private *devpriv = dev->private;
 	unsigned long debtime;
 	unsigned long val;
 	int chan;
 	int cmd;
 	int n;
 
-	n = rudimentary_check(dev, DIR_OUT);
+	n = rudimentary_check(devpriv, DIR_OUT);
 	if (n)
 		return n;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
 	if (!chan)
@@ -1033,65 +1042,70 @@ static int vmk80xx_cnt_winsn(struct comedi_device *cdev,
 		if (((val + 1) * val) < debtime * 1000 / 115)
 			val += 1;
 
-		dev->usb_tx_buf[6 + chan] = val;
+		devpriv->usb_tx_buf[6 + chan] = val;
 
-		if (vmk80xx_write_packet(dev, cmd))
+		if (vmk80xx_write_packet(devpriv, cmd))
 			break;
 	}
 
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return n;
 }
 
-static int vmk80xx_pwm_rinsn(struct comedi_device *cdev,
+static int vmk80xx_pwm_rinsn(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_private *dev = cdev->private;
+	struct vmk80xx_private *devpriv = dev->private;
+	unsigned char *tx_buf;
+	unsigned char *rx_buf;
 	int reg[2];
 	int n;
 
-	n = rudimentary_check(dev, DIR_IN);
+	n = rudimentary_check(devpriv, DIR_IN);
 	if (n)
 		return n;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
+
+	tx_buf = devpriv->usb_tx_buf;
+	rx_buf = devpriv->usb_rx_buf;
 
 	reg[0] = VMK8061_PWM_REG1;
 	reg[1] = VMK8061_PWM_REG2;
 
-	dev->usb_tx_buf[0] = VMK8061_CMD_RD_PWM;
+	tx_buf[0] = VMK8061_CMD_RD_PWM;
 
 	for (n = 0; n < insn->n; n++) {
-		if (vmk80xx_read_packet(dev))
+		if (vmk80xx_read_packet(devpriv))
 			break;
 
-		data[n] = dev->usb_rx_buf[reg[0]] + 4 * dev->usb_rx_buf[reg[1]];
+		data[n] = rx_buf[reg[0]] + 4 * rx_buf[reg[1]];
 	}
 
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return n;
 }
 
-static int vmk80xx_pwm_winsn(struct comedi_device *cdev,
+static int vmk80xx_pwm_winsn(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_private *dev = cdev->private;
+	struct vmk80xx_private *devpriv = dev->private;
 	unsigned char *tx_buf;
 	int reg[2];
 	int cmd;
 	int n;
 
-	n = rudimentary_check(dev, DIR_OUT);
+	n = rudimentary_check(devpriv, DIR_OUT);
 	if (n)
 		return n;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
 
-	tx_buf = dev->usb_tx_buf;
+	tx_buf = devpriv->usb_tx_buf;
 
 	reg[0] = VMK8061_PWM_REG1;
 	reg[1] = VMK8061_PWM_REG2;
@@ -1115,42 +1129,42 @@ static int vmk80xx_pwm_winsn(struct comedi_device *cdev,
 		tx_buf[reg[0]] = (unsigned char)(data[n] & 0x03);
 		tx_buf[reg[1]] = (unsigned char)(data[n] >> 2) & 0xff;
 
-		if (vmk80xx_write_packet(dev, cmd))
+		if (vmk80xx_write_packet(devpriv, cmd))
 			break;
 	}
 
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return n;
 }
 
-static int vmk80xx_attach_common(struct comedi_device *cdev,
-				 struct vmk80xx_private *dev)
+static int vmk80xx_attach_common(struct comedi_device *dev,
+				 struct vmk80xx_private *devpriv)
 {
 	const struct vmk80xx_board *boardinfo;
 	int n_subd;
 	struct comedi_subdevice *s;
 	int ret;
 
-	down(&dev->limit_sem);
+	down(&devpriv->limit_sem);
 
-	boardinfo = dev->board;
-	cdev->board_ptr = boardinfo;
-	cdev->board_name = boardinfo->name;
-	cdev->private = dev;
+	boardinfo = devpriv->board;
+	dev->board_ptr = boardinfo;
+	dev->board_name = boardinfo->name;
+	dev->private = devpriv;
 
 	if (boardinfo->model == VMK8055_MODEL)
 		n_subd = 5;
 	else
 		n_subd = 6;
-	ret = comedi_alloc_subdevices(cdev, n_subd);
+	ret = comedi_alloc_subdevices(dev, n_subd);
 	if (ret) {
-		up(&dev->limit_sem);
+		up(&devpriv->limit_sem);
 		return ret;
 	}
 
 	/* Analog input subdevice */
-	s = &cdev->subdevices[0];
+	s = &dev->subdevices[0];
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
 	s->n_chan = boardinfo->ai_chans;
@@ -1159,7 +1173,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	s->insn_read = vmk80xx_ai_rinsn;
 
 	/* Analog output subdevice */
-	s = &cdev->subdevices[1];
+	s = &dev->subdevices[1];
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
 	s->n_chan = boardinfo->ao_chans;
@@ -1172,7 +1186,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	}
 
 	/* Digital input subdevice */
-	s = &cdev->subdevices[2];
+	s = &dev->subdevices[2];
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
 	s->n_chan = boardinfo->di_chans;
@@ -1181,7 +1195,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	s->insn_bits = vmk80xx_di_bits;
 
 	/* Digital output subdevice */
-	s = &cdev->subdevices[3];
+	s = &dev->subdevices[3];
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
 	s->n_chan = 8;
@@ -1194,7 +1208,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	}
 
 	/* Counter subdevice */
-	s = &cdev->subdevices[4];
+	s = &dev->subdevices[4];
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_READABLE;
 	s->n_chan = 2;
@@ -1208,7 +1222,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 
 	/* PWM subdevice */
 	if (boardinfo->model == VMK8061_MODEL) {
-		s = &cdev->subdevices[5];
+		s = &dev->subdevices[5];
 		s->type = COMEDI_SUBD_PWM;
 		s->subdev_flags = SDF_READABLE | SDF_WRITEABLE;
 		s->n_chan = boardinfo->pwm_chans;
@@ -1217,19 +1231,19 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 		s->insn_write = vmk80xx_pwm_winsn;
 	}
 
-	dev->attached = 1;
-	dev_info(cdev->class_dev, "vmk80xx: board #%d [%s] attached\n",
-		 dev->count, boardinfo->name);
+	devpriv->attached = 1;
+	dev_info(dev->class_dev, "vmk80xx: board #%d [%s] attached\n",
+		 devpriv->count, boardinfo->name);
 
-	up(&dev->limit_sem);
+	up(&devpriv->limit_sem);
 
 	return 0;
 }
 
-static int vmk80xx_auto_attach(struct comedi_device *cdev,
+static int vmk80xx_auto_attach(struct comedi_device *dev,
 			       unsigned long context_unused)
 {
-	struct usb_interface *intf = comedi_to_usb_interface(cdev);
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	int i;
 	int ret;
 
@@ -1242,34 +1256,34 @@ static int vmk80xx_auto_attach(struct comedi_device *cdev,
 	else if (vmb[i].attached)
 		ret = -EBUSY;
 	else
-		ret = vmk80xx_attach_common(cdev, &vmb[i]);
+		ret = vmk80xx_attach_common(dev, &vmb[i]);
 	mutex_unlock(&glb_mutex);
 	return ret;
 }
 
 static void vmk80xx_detach(struct comedi_device *dev)
 {
-	struct vmk80xx_private *usb = dev->private;
+	struct vmk80xx_private *devpriv = dev->private;
 
-	if (!usb)
+	if (!devpriv)
 		return;
 
 	mutex_lock(&glb_mutex);
-	down(&usb->limit_sem);
+	down(&devpriv->limit_sem);
 
 	dev->private = NULL;
 
-	usb->attached = 0;
-	usb->probed = 0;
-	usb_set_intfdata(usb->intf, NULL);
+	devpriv->attached = 0;
+	devpriv->probed = 0;
+	usb_set_intfdata(devpriv->intf, NULL);
 
-	usb_kill_anchored_urbs(&usb->rx_anchor);
-	usb_kill_anchored_urbs(&usb->tx_anchor);
+	usb_kill_anchored_urbs(&devpriv->rx_anchor);
+	usb_kill_anchored_urbs(&devpriv->tx_anchor);
 
-	kfree(usb->usb_rx_buf);
-	kfree(usb->usb_tx_buf);
+	kfree(devpriv->usb_rx_buf);
+	kfree(devpriv->usb_tx_buf);
 
-	up(&usb->limit_sem);
+	up(&devpriv->limit_sem);
 	mutex_unlock(&glb_mutex);
 }
 
@@ -1284,11 +1298,11 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 			     const struct usb_device_id *id)
 {
 	const struct vmk80xx_board *boardinfo;
-	int i;
-	struct vmk80xx_private *dev;
+	struct vmk80xx_private *devpriv;
 	struct usb_host_interface *iface_desc;
 	struct usb_endpoint_descriptor *ep_desc;
 	size_t size;
+	int i;
 
 	mutex_lock(&glb_mutex);
 
@@ -1301,10 +1315,10 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 		return -EMFILE;
 	}
 
-	dev = &vmb[i];
+	devpriv = &vmb[i];
 
-	memset(dev, 0x00, sizeof(*dev));
-	dev->count = i;
+	memset(devpriv, 0x00, sizeof(*devpriv));
+	devpriv->count = i;
 
 	iface_desc = intf->cur_altsetting;
 	if (iface_desc->desc.bNumEndpoints != 2)
@@ -1314,78 +1328,78 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 		ep_desc = &iface_desc->endpoint[i].desc;
 
 		if (usb_endpoint_is_int_in(ep_desc)) {
-			dev->ep_rx = ep_desc;
+			devpriv->ep_rx = ep_desc;
 			continue;
 		}
 
 		if (usb_endpoint_is_int_out(ep_desc)) {
-			dev->ep_tx = ep_desc;
+			devpriv->ep_tx = ep_desc;
 			continue;
 		}
 
 		if (usb_endpoint_is_bulk_in(ep_desc)) {
-			dev->ep_rx = ep_desc;
+			devpriv->ep_rx = ep_desc;
 			continue;
 		}
 
 		if (usb_endpoint_is_bulk_out(ep_desc)) {
-			dev->ep_tx = ep_desc;
+			devpriv->ep_tx = ep_desc;
 			continue;
 		}
 	}
 
-	if (!dev->ep_rx || !dev->ep_tx)
+	if (!devpriv->ep_rx || !devpriv->ep_tx)
 		goto error;
 
-	size = le16_to_cpu(dev->ep_rx->wMaxPacketSize);
-	dev->usb_rx_buf = kmalloc(size, GFP_KERNEL);
-	if (!dev->usb_rx_buf) {
+	size = le16_to_cpu(devpriv->ep_rx->wMaxPacketSize);
+	devpriv->usb_rx_buf = kmalloc(size, GFP_KERNEL);
+	if (!devpriv->usb_rx_buf) {
 		mutex_unlock(&glb_mutex);
 		return -ENOMEM;
 	}
 
-	size = le16_to_cpu(dev->ep_tx->wMaxPacketSize);
-	dev->usb_tx_buf = kmalloc(size, GFP_KERNEL);
-	if (!dev->usb_tx_buf) {
-		kfree(dev->usb_rx_buf);
+	size = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);
+	devpriv->usb_tx_buf = kmalloc(size, GFP_KERNEL);
+	if (!devpriv->usb_tx_buf) {
+		kfree(devpriv->usb_rx_buf);
 		mutex_unlock(&glb_mutex);
 		return -ENOMEM;
 	}
 
-	dev->udev = interface_to_usbdev(intf);
-	dev->intf = intf;
+	devpriv->usb = interface_to_usbdev(intf);
+	devpriv->intf = intf;
 
-	sema_init(&dev->limit_sem, 8);
-	init_waitqueue_head(&dev->read_wait);
-	init_waitqueue_head(&dev->write_wait);
+	sema_init(&devpriv->limit_sem, 8);
+	init_waitqueue_head(&devpriv->read_wait);
+	init_waitqueue_head(&devpriv->write_wait);
 
-	init_usb_anchor(&dev->rx_anchor);
-	init_usb_anchor(&dev->tx_anchor);
+	init_usb_anchor(&devpriv->rx_anchor);
+	init_usb_anchor(&devpriv->tx_anchor);
 
-	usb_set_intfdata(intf, dev);
+	usb_set_intfdata(intf, devpriv);
 
 	boardinfo = &vmk80xx_boardinfo[id->driver_info];
-	dev->board = boardinfo;
+	devpriv->board = boardinfo;
 
 	if (boardinfo->model == VMK8061_MODEL) {
-		vmk80xx_read_eeprom(dev, IC3_VERSION);
-		dev_info(&intf->dev, "%s\n", dev->fw.ic3_vers);
+		vmk80xx_read_eeprom(devpriv, IC3_VERSION);
+		dev_info(&intf->dev, "%s\n", devpriv->fw.ic3_vers);
 
-		if (vmk80xx_check_data_link(dev)) {
-			vmk80xx_read_eeprom(dev, IC6_VERSION);
-			dev_info(&intf->dev, "%s\n", dev->fw.ic6_vers);
+		if (vmk80xx_check_data_link(devpriv)) {
+			vmk80xx_read_eeprom(devpriv, IC6_VERSION);
+			dev_info(&intf->dev, "%s\n", devpriv->fw.ic6_vers);
 		} else {
 			dbgcm("comedi#: vmk80xx: no conn. to CPU\n");
 		}
 	}
 
 	if (boardinfo->model == VMK8055_MODEL)
-		vmk80xx_reset_device(dev);
+		vmk80xx_reset_device(devpriv);
 
-	dev->probed = 1;
+	devpriv->probed = 1;
 
 	dev_info(&intf->dev, "board #%d [%s] now attached\n",
-		 dev->count, boardinfo->name);
+		 devpriv->count, boardinfo->name);
 
 	mutex_unlock(&glb_mutex);
 

commit dc49cbfc67f6d85020715901c88d128d02429791
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:20:22 2013 -0700

    staging: comedi: vmk80xx: rename struct vmk80xx_usb
    
    The struct vmk80xx_usb is actually the private data for the
    comedi_device. For aesthetic reasons, rename the struct to
    vmk80xx_private.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index e0b9a5166504..a14528613249 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -195,7 +195,7 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 	},
 };
 
-struct vmk80xx_usb {
+struct vmk80xx_private {
 	struct usb_device *udev;
 	struct usb_interface *intf;
 	struct usb_endpoint_descriptor *ep_rx;
@@ -215,13 +215,13 @@ struct vmk80xx_usb {
 	int count;
 };
 
-static struct vmk80xx_usb vmb[VMK80XX_MAX_BOARDS];
+static struct vmk80xx_private vmb[VMK80XX_MAX_BOARDS];
 
 static DEFINE_MUTEX(glb_mutex);
 
 static void vmk80xx_tx_callback(struct urb *urb)
 {
-	struct vmk80xx_usb *dev = urb->context;
+	struct vmk80xx_private *dev = urb->context;
 	int stat = urb->status;
 
 	if (stat && !(stat == -ENOENT
@@ -239,7 +239,7 @@ static void vmk80xx_tx_callback(struct urb *urb)
 
 static void vmk80xx_rx_callback(struct urb *urb)
 {
-	struct vmk80xx_usb *dev = urb->context;
+	struct vmk80xx_private *dev = urb->context;
 	int stat = urb->status;
 
 	switch (stat) {
@@ -275,7 +275,7 @@ static void vmk80xx_rx_callback(struct urb *urb)
 	wake_up_interruptible(&dev->read_wait);
 }
 
-static int vmk80xx_check_data_link(struct vmk80xx_usb *dev)
+static int vmk80xx_check_data_link(struct vmk80xx_private *dev)
 {
 	unsigned int tx_pipe;
 	unsigned int rx_pipe;
@@ -298,7 +298,7 @@ static int vmk80xx_check_data_link(struct vmk80xx_usb *dev)
 	return (int)rx[1];
 }
 
-static void vmk80xx_read_eeprom(struct vmk80xx_usb *dev, int flag)
+static void vmk80xx_read_eeprom(struct vmk80xx_private *dev, int flag)
 {
 	unsigned int tx_pipe;
 	unsigned int rx_pipe;
@@ -326,7 +326,7 @@ static void vmk80xx_read_eeprom(struct vmk80xx_usb *dev, int flag)
 		strncpy(dev->fw.ic6_vers, rx + 25, 24);
 }
 
-static int vmk80xx_reset_device(struct vmk80xx_usb *dev)
+static int vmk80xx_reset_device(struct vmk80xx_private *dev)
 {
 	struct urb *urb;
 	unsigned int tx_pipe;
@@ -361,7 +361,7 @@ static int vmk80xx_reset_device(struct vmk80xx_usb *dev)
 
 static void vmk80xx_build_int_urb(struct urb *urb, int flag)
 {
-	struct vmk80xx_usb *dev = urb->context;
+	struct vmk80xx_private *dev = urb->context;
 	__u8 rx_addr;
 	__u8 tx_addr;
 	unsigned int pipe;
@@ -389,7 +389,7 @@ static void vmk80xx_build_int_urb(struct urb *urb, int flag)
 	usb_fill_int_urb(urb, dev->udev, pipe, buf, size, callback, dev, ival);
 }
 
-static void vmk80xx_do_bulk_msg(struct vmk80xx_usb *dev)
+static void vmk80xx_do_bulk_msg(struct vmk80xx_private *dev)
 {
 	__u8 tx_addr;
 	__u8 rx_addr;
@@ -419,7 +419,7 @@ static void vmk80xx_do_bulk_msg(struct vmk80xx_usb *dev)
 	clear_bit(TRANS_IN_BUSY, &dev->flags);
 }
 
-static int vmk80xx_read_packet(struct vmk80xx_usb *dev)
+static int vmk80xx_read_packet(struct vmk80xx_private *dev)
 {
 	const struct vmk80xx_board *boardinfo = dev->board;
 	struct urb *urb;
@@ -466,7 +466,7 @@ static int vmk80xx_read_packet(struct vmk80xx_usb *dev)
 	return retval;
 }
 
-static int vmk80xx_write_packet(struct vmk80xx_usb *dev, int cmd)
+static int vmk80xx_write_packet(struct vmk80xx_private *dev, int cmd)
 {
 	const struct vmk80xx_board *boardinfo = dev->board;
 	struct urb *urb;
@@ -517,7 +517,7 @@ static int vmk80xx_write_packet(struct vmk80xx_usb *dev, int cmd)
 #define DIR_IN  1
 #define DIR_OUT 2
 
-static int rudimentary_check(struct vmk80xx_usb *dev, int dir)
+static int rudimentary_check(struct vmk80xx_private *dev, int dir)
 {
 	if (!dev)
 		return -EFAULT;
@@ -542,7 +542,7 @@ static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
 			    struct comedi_insn *insn, unsigned int *data)
 {
 	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_usb *dev = cdev->private;
+	struct vmk80xx_private *dev = cdev->private;
 	int chan;
 	int reg[2];
 	int n;
@@ -594,7 +594,7 @@ static int vmk80xx_ao_winsn(struct comedi_device *cdev,
 			    struct comedi_insn *insn, unsigned int *data)
 {
 	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_usb *dev = cdev->private;
+	struct vmk80xx_private *dev = cdev->private;
 	int chan;
 	int cmd;
 	int reg;
@@ -638,7 +638,7 @@ static int vmk80xx_ao_rinsn(struct comedi_device *cdev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_usb *dev = cdev->private;
+	struct vmk80xx_private *dev = cdev->private;
 	int chan;
 	int reg;
 	int n;
@@ -671,7 +671,7 @@ static int vmk80xx_di_bits(struct comedi_device *cdev,
 			   struct comedi_insn *insn, unsigned int *data)
 {
 	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_usb *dev = cdev->private;
+	struct vmk80xx_private *dev = cdev->private;
 	unsigned char *rx_buf;
 	int reg;
 	int retval;
@@ -714,7 +714,7 @@ static int vmk80xx_di_rinsn(struct comedi_device *cdev,
 			    struct comedi_insn *insn, unsigned int *data)
 {
 	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_usb *dev = cdev->private;
+	struct vmk80xx_private *dev = cdev->private;
 	int chan;
 	unsigned char *rx_buf;
 	int reg;
@@ -760,7 +760,7 @@ static int vmk80xx_do_winsn(struct comedi_device *cdev,
 			    struct comedi_insn *insn, unsigned int *data)
 {
 	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_usb *dev = cdev->private;
+	struct vmk80xx_private *dev = cdev->private;
 	int chan;
 	unsigned char *tx_buf;
 	int reg;
@@ -808,7 +808,7 @@ static int vmk80xx_do_rinsn(struct comedi_device *cdev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_usb *dev = cdev->private;
+	struct vmk80xx_private *dev = cdev->private;
 	int chan;
 	int reg;
 	int n;
@@ -841,7 +841,7 @@ static int vmk80xx_do_bits(struct comedi_device *cdev,
 			   struct comedi_insn *insn, unsigned int *data)
 {
 	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_usb *dev = cdev->private;
+	struct vmk80xx_private *dev = cdev->private;
 	unsigned char *rx_buf, *tx_buf;
 	int dir, reg, cmd;
 	int retval;
@@ -907,7 +907,7 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 			     struct comedi_insn *insn, unsigned int *data)
 {
 	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_usb *dev = cdev->private;
+	struct vmk80xx_private *dev = cdev->private;
 	int chan;
 	int reg[2];
 	int n;
@@ -955,7 +955,7 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *cdev,
 			     struct comedi_insn *insn, unsigned int *data)
 {
 	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
-	struct vmk80xx_usb *dev = cdev->private;
+	struct vmk80xx_private *dev = cdev->private;
 	unsigned int insn_cmd;
 	int chan;
 	int cmd;
@@ -1001,7 +1001,7 @@ static int vmk80xx_cnt_winsn(struct comedi_device *cdev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_usb *dev = cdev->private;
+	struct vmk80xx_private *dev = cdev->private;
 	unsigned long debtime;
 	unsigned long val;
 	int chan;
@@ -1048,7 +1048,7 @@ static int vmk80xx_pwm_rinsn(struct comedi_device *cdev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_usb *dev = cdev->private;
+	struct vmk80xx_private *dev = cdev->private;
 	int reg[2];
 	int n;
 
@@ -1079,7 +1079,7 @@ static int vmk80xx_pwm_winsn(struct comedi_device *cdev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_usb *dev = cdev->private;
+	struct vmk80xx_private *dev = cdev->private;
 	unsigned char *tx_buf;
 	int reg[2];
 	int cmd;
@@ -1125,7 +1125,7 @@ static int vmk80xx_pwm_winsn(struct comedi_device *cdev,
 }
 
 static int vmk80xx_attach_common(struct comedi_device *cdev,
-				 struct vmk80xx_usb *dev)
+				 struct vmk80xx_private *dev)
 {
 	const struct vmk80xx_board *boardinfo;
 	int n_subd;
@@ -1249,7 +1249,7 @@ static int vmk80xx_auto_attach(struct comedi_device *cdev,
 
 static void vmk80xx_detach(struct comedi_device *dev)
 {
-	struct vmk80xx_usb *usb = dev->private;
+	struct vmk80xx_private *usb = dev->private;
 
 	if (!usb)
 		return;
@@ -1285,7 +1285,7 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 {
 	const struct vmk80xx_board *boardinfo;
 	int i;
-	struct vmk80xx_usb *dev;
+	struct vmk80xx_private *dev;
 	struct usb_host_interface *iface_desc;
 	struct usb_endpoint_descriptor *ep_desc;
 	size_t size;
@@ -1303,7 +1303,7 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 
 	dev = &vmb[i];
 
-	memset(dev, 0x00, sizeof(struct vmk80xx_usb));
+	memset(dev, 0x00, sizeof(*dev));
 	dev->count = i;
 
 	iface_desc = intf->cur_altsetting;

commit 9f4d4de3080116173256ce86a32b4c4d472ab1e9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:20:01 2013 -0700

    staging: comedi: vmk80xx: remove VMK80XX_SUBD_* enum
    
    These enum values are only used in the initialization of the
    comedi_subdevices. They don't help make the code any clearer
    so just remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 947c8d08110b..e0b9a5166504 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -195,15 +195,6 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 	},
 };
 
-enum {
-	VMK80XX_SUBD_AI,
-	VMK80XX_SUBD_AO,
-	VMK80XX_SUBD_DI,
-	VMK80XX_SUBD_DO,
-	VMK80XX_SUBD_CNT,
-	VMK80XX_SUBD_PWM,
-};
-
 struct vmk80xx_usb {
 	struct usb_device *udev;
 	struct usb_interface *intf;
@@ -1159,7 +1150,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	}
 
 	/* Analog input subdevice */
-	s = &cdev->subdevices[VMK80XX_SUBD_AI];
+	s = &cdev->subdevices[0];
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
 	s->n_chan = boardinfo->ai_chans;
@@ -1168,7 +1159,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	s->insn_read = vmk80xx_ai_rinsn;
 
 	/* Analog output subdevice */
-	s = &cdev->subdevices[VMK80XX_SUBD_AO];
+	s = &cdev->subdevices[1];
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
 	s->n_chan = boardinfo->ao_chans;
@@ -1181,7 +1172,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	}
 
 	/* Digital input subdevice */
-	s = &cdev->subdevices[VMK80XX_SUBD_DI];
+	s = &cdev->subdevices[2];
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
 	s->n_chan = boardinfo->di_chans;
@@ -1190,7 +1181,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	s->insn_bits = vmk80xx_di_bits;
 
 	/* Digital output subdevice */
-	s = &cdev->subdevices[VMK80XX_SUBD_DO];
+	s = &cdev->subdevices[3];
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
 	s->n_chan = 8;
@@ -1203,7 +1194,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	}
 
 	/* Counter subdevice */
-	s = &cdev->subdevices[VMK80XX_SUBD_CNT];
+	s = &cdev->subdevices[4];
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_READABLE;
 	s->n_chan = 2;
@@ -1217,7 +1208,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 
 	/* PWM subdevice */
 	if (boardinfo->model == VMK8061_MODEL) {
-		s = &cdev->subdevices[VMK80XX_SUBD_PWM];
+		s = &cdev->subdevices[5];
 		s->type = COMEDI_SUBD_PWM;
 		s->subdev_flags = SDF_READABLE | SDF_WRITEABLE;
 		s->n_chan = boardinfo->pwm_chans;

commit 70ba1a599333c576e9dea7dfdcd9a4446d958093
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:19:40 2013 -0700

    staging: comedi: vmk80xx: remove common and unused boardinfo
    
    Some of the information in the boardinfo is common for both boards
    supported by this driver. Remove that information from the boardinfo
    and just initialize the subdevice values directly.
    
    Also, remove any information in the boardinfo that is not used in
    the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 2ed4ddf9f4de..947c8d08110b 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -162,12 +162,7 @@ struct vmk80xx_board {
 	__u8 ai_chans;
 	__le16 ai_bits;
 	__u8 ao_chans;
-	__le16 ao_bits;
 	__u8 di_chans;
-	__le16 di_bits;
-	__u8 do_chans;
-	__le16 do_bits;
-	__u8 cnt_chans;
 	__le16 cnt_bits;
 	__u8 pwm_chans;
 	__le16 pwm_bits;
@@ -181,12 +176,7 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 		.ai_chans	= 2,
 		.ai_bits	= 8,
 		.ao_chans	= 2,
-		.ao_bits	= 8,
 		.di_chans	= 6,
-		.di_bits	= 1,
-		.do_chans	= 8,
-		.do_bits	= 1,
-		.cnt_chans	= 2,
 		.cnt_bits	= 16,
 		.pwm_chans	= 0,
 		.pwm_bits	= 0,
@@ -198,12 +188,7 @@ static const struct vmk80xx_board vmk80xx_boardinfo[] = {
 		.ai_chans	= 8,
 		.ai_bits	= 10,
 		.ao_chans	= 8,
-		.ao_bits	= 8,
 		.di_chans	= 8,
-		.di_bits	= 1,
-		.do_chans	= 8,
-		.do_bits	= 1,
-		.cnt_chans	= 2,
 		.cnt_bits	= 0,
 		.pwm_chans	= 1,
 		.pwm_bits	= 10,
@@ -1187,7 +1172,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
 	s->n_chan = boardinfo->ao_chans;
-	s->maxdata = (1 << boardinfo->ao_bits) - 1;
+	s->maxdata = 0x00ff;
 	s->range_table = boardinfo->range;
 	s->insn_write = vmk80xx_ao_winsn;
 	if (boardinfo->model == VMK8061_MODEL) {
@@ -1208,7 +1193,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	s = &cdev->subdevices[VMK80XX_SUBD_DO];
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
-	s->n_chan = boardinfo->do_chans;
+	s->n_chan = 8;
 	s->maxdata = 1;
 	s->insn_write = vmk80xx_do_winsn;
 	s->insn_bits = vmk80xx_do_bits;
@@ -1221,7 +1206,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	s = &cdev->subdevices[VMK80XX_SUBD_CNT];
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_READABLE;
-	s->n_chan = boardinfo->cnt_chans;
+	s->n_chan = 2;
 	s->insn_read = vmk80xx_cnt_rinsn;
 	s->insn_config = vmk80xx_cnt_cinsn;
 	if (boardinfo->model == VMK8055_MODEL) {

commit 0dd772bf76fca8d76a963de5bc378535e4d3cd39
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:19:18 2013 -0700

    staging: comedi: vmk80xx: save the boardinfo in the comedi_device
    
    Save a copy of the boardinfo pointer in the comedi_device 'board_ptr'.
    The subdevice functions can then simply get it using the comedi_board()
    helper.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index dc2efc09deac..2ed4ddf9f4de 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -445,6 +445,7 @@ static void vmk80xx_do_bulk_msg(struct vmk80xx_usb *dev)
 
 static int vmk80xx_read_packet(struct vmk80xx_usb *dev)
 {
+	const struct vmk80xx_board *boardinfo = dev->board;
 	struct urb *urb;
 	int retval;
 
@@ -458,7 +459,7 @@ static int vmk80xx_read_packet(struct vmk80xx_usb *dev)
 						       &dev->flags)))
 			return -ERESTART;
 
-	if (dev->board->model == VMK8061_MODEL) {
+	if (boardinfo->model == VMK8061_MODEL) {
 		vmk80xx_do_bulk_msg(dev);
 
 		return 0;
@@ -491,6 +492,7 @@ static int vmk80xx_read_packet(struct vmk80xx_usb *dev)
 
 static int vmk80xx_write_packet(struct vmk80xx_usb *dev, int cmd)
 {
+	const struct vmk80xx_board *boardinfo = dev->board;
 	struct urb *urb;
 	int retval;
 
@@ -503,7 +505,7 @@ static int vmk80xx_write_packet(struct vmk80xx_usb *dev, int cmd)
 						       &dev->flags)))
 			return -ERESTART;
 
-	if (dev->board->model == VMK8061_MODEL) {
+	if (boardinfo->model == VMK8061_MODEL) {
 		dev->usb_tx_buf[0] = cmd;
 		vmk80xx_do_bulk_msg(dev);
 
@@ -563,6 +565,7 @@ static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
 	struct vmk80xx_usb *dev = cdev->private;
 	int chan;
 	int reg[2];
@@ -575,7 +578,7 @@ static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
-	switch (dev->board->model) {
+	switch (boardinfo->model) {
 	case VMK8055_MODEL:
 		if (!chan)
 			reg[0] = VMK8055_AI1_REG;
@@ -595,7 +598,7 @@ static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
 		if (vmk80xx_read_packet(dev))
 			break;
 
-		if (dev->board->model == VMK8055_MODEL) {
+		if (boardinfo->model == VMK8055_MODEL) {
 			data[n] = dev->usb_rx_buf[reg[0]];
 			continue;
 		}
@@ -614,6 +617,7 @@ static int vmk80xx_ao_winsn(struct comedi_device *cdev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
 	struct vmk80xx_usb *dev = cdev->private;
 	int chan;
 	int cmd;
@@ -627,7 +631,7 @@ static int vmk80xx_ao_winsn(struct comedi_device *cdev,
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
-	switch (dev->board->model) {
+	switch (boardinfo->model) {
 	case VMK8055_MODEL:
 		cmd = VMK8055_CMD_WRT_AD;
 		if (!chan)
@@ -690,6 +694,7 @@ static int vmk80xx_di_bits(struct comedi_device *cdev,
 			   struct comedi_subdevice *s,
 			   struct comedi_insn *insn, unsigned int *data)
 {
+	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
 	struct vmk80xx_usb *dev = cdev->private;
 	unsigned char *rx_buf;
 	int reg;
@@ -703,7 +708,7 @@ static int vmk80xx_di_bits(struct comedi_device *cdev,
 
 	rx_buf = dev->usb_rx_buf;
 
-	if (dev->board->model == VMK8061_MODEL) {
+	if (boardinfo->model == VMK8061_MODEL) {
 		reg = VMK8061_DI_REG;
 		dev->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
 	} else {
@@ -713,7 +718,7 @@ static int vmk80xx_di_bits(struct comedi_device *cdev,
 	retval = vmk80xx_read_packet(dev);
 
 	if (!retval) {
-		if (dev->board->model == VMK8055_MODEL)
+		if (boardinfo->model == VMK8055_MODEL)
 			data[1] = (((rx_buf[reg] >> 4) & 0x03) |
 				  ((rx_buf[reg] << 2) & 0x04) |
 				  ((rx_buf[reg] >> 3) & 0x18));
@@ -732,6 +737,7 @@ static int vmk80xx_di_rinsn(struct comedi_device *cdev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
 	struct vmk80xx_usb *dev = cdev->private;
 	int chan;
 	unsigned char *rx_buf;
@@ -748,7 +754,7 @@ static int vmk80xx_di_rinsn(struct comedi_device *cdev,
 
 	rx_buf = dev->usb_rx_buf;
 
-	if (dev->board->model == VMK8061_MODEL) {
+	if (boardinfo->model == VMK8061_MODEL) {
 		reg = VMK8061_DI_REG;
 		dev->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
 	} else {
@@ -758,7 +764,7 @@ static int vmk80xx_di_rinsn(struct comedi_device *cdev,
 		if (vmk80xx_read_packet(dev))
 			break;
 
-		if (dev->board->model == VMK8055_MODEL)
+		if (boardinfo->model == VMK8055_MODEL)
 			inp = (((rx_buf[reg] >> 4) & 0x03) |
 			       ((rx_buf[reg] << 2) & 0x04) |
 			       ((rx_buf[reg] >> 3) & 0x18));
@@ -777,6 +783,7 @@ static int vmk80xx_do_winsn(struct comedi_device *cdev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
 	struct vmk80xx_usb *dev = cdev->private;
 	int chan;
 	unsigned char *tx_buf;
@@ -794,7 +801,7 @@ static int vmk80xx_do_winsn(struct comedi_device *cdev,
 	tx_buf = dev->usb_tx_buf;
 
 	for (n = 0; n < insn->n; n++) {
-		if (dev->board->model == VMK8055_MODEL) {
+		if (boardinfo->model == VMK8055_MODEL) {
 			reg = VMK8055_DO_REG;
 			cmd = VMK8055_CMD_WRT_AD;
 			if (data[n] == 1)
@@ -857,6 +864,7 @@ static int vmk80xx_do_bits(struct comedi_device *cdev,
 			   struct comedi_subdevice *s,
 			   struct comedi_insn *insn, unsigned int *data)
 {
+	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
 	struct vmk80xx_usb *dev = cdev->private;
 	unsigned char *rx_buf, *tx_buf;
 	int dir, reg, cmd;
@@ -867,7 +875,7 @@ static int vmk80xx_do_bits(struct comedi_device *cdev,
 	if (data[0])
 		dir |= DIR_OUT;
 
-	if (dev->board->model == VMK8061_MODEL)
+	if (boardinfo->model == VMK8061_MODEL)
 		dir |= DIR_IN;
 
 	retval = rudimentary_check(dev, dir);
@@ -880,7 +888,7 @@ static int vmk80xx_do_bits(struct comedi_device *cdev,
 	tx_buf = dev->usb_tx_buf;
 
 	if (data[0]) {
-		if (dev->board->model == VMK8055_MODEL) {
+		if (boardinfo->model == VMK8055_MODEL) {
 			reg = VMK8055_DO_REG;
 			cmd = VMK8055_CMD_WRT_AD;
 		} else { /* VMK8061_MODEL */
@@ -897,7 +905,7 @@ static int vmk80xx_do_bits(struct comedi_device *cdev,
 			goto out;
 	}
 
-	if (dev->board->model == VMK8061_MODEL) {
+	if (boardinfo->model == VMK8061_MODEL) {
 		reg = VMK8061_DO_REG;
 		tx_buf[0] = VMK8061_CMD_RD_DO;
 
@@ -922,6 +930,7 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
+	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
 	struct vmk80xx_usb *dev = cdev->private;
 	int chan;
 	int reg[2];
@@ -934,7 +943,7 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
-	switch (dev->board->model) {
+	switch (boardinfo->model) {
 	case VMK8055_MODEL:
 		if (!chan)
 			reg[0] = VMK8055_CNT1_REG;
@@ -953,7 +962,7 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 		if (vmk80xx_read_packet(dev))
 			break;
 
-		if (dev->board->model == VMK8055_MODEL)
+		if (boardinfo->model == VMK8055_MODEL)
 			data[n] = dev->usb_rx_buf[reg[0]];
 		else /* VMK8061_MODEL */
 			data[n] = dev->usb_rx_buf[reg[0] * (chan + 1) + 1]
@@ -969,6 +978,7 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *cdev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
+	const struct vmk80xx_board *boardinfo = comedi_board(cdev);
 	struct vmk80xx_usb *dev = cdev->private;
 	unsigned int insn_cmd;
 	int chan;
@@ -988,7 +998,7 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *cdev,
 
 	chan = CR_CHAN(insn->chanspec);
 
-	if (dev->board->model == VMK8055_MODEL) {
+	if (boardinfo->model == VMK8055_MODEL) {
 		if (!chan) {
 			cmd = VMK8055_CMD_RST_CNT1;
 			reg = VMK8055_CNT1_REG;
@@ -1141,14 +1151,19 @@ static int vmk80xx_pwm_winsn(struct comedi_device *cdev,
 static int vmk80xx_attach_common(struct comedi_device *cdev,
 				 struct vmk80xx_usb *dev)
 {
+	const struct vmk80xx_board *boardinfo;
 	int n_subd;
 	struct comedi_subdevice *s;
 	int ret;
 
 	down(&dev->limit_sem);
-	cdev->board_name = dev->board->name;
+
+	boardinfo = dev->board;
+	cdev->board_ptr = boardinfo;
+	cdev->board_name = boardinfo->name;
 	cdev->private = dev;
-	if (dev->board->model == VMK8055_MODEL)
+
+	if (boardinfo->model == VMK8055_MODEL)
 		n_subd = 5;
 	else
 		n_subd = 6;
@@ -1157,72 +1172,81 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 		up(&dev->limit_sem);
 		return ret;
 	}
+
 	/* Analog input subdevice */
 	s = &cdev->subdevices[VMK80XX_SUBD_AI];
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
-	s->n_chan = dev->board->ai_chans;
-	s->maxdata = (1 << dev->board->ai_bits) - 1;
-	s->range_table = dev->board->range;
+	s->n_chan = boardinfo->ai_chans;
+	s->maxdata = (1 << boardinfo->ai_bits) - 1;
+	s->range_table = boardinfo->range;
 	s->insn_read = vmk80xx_ai_rinsn;
+
 	/* Analog output subdevice */
 	s = &cdev->subdevices[VMK80XX_SUBD_AO];
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
-	s->n_chan = dev->board->ao_chans;
-	s->maxdata = (1 << dev->board->ao_bits) - 1;
-	s->range_table = dev->board->range;
+	s->n_chan = boardinfo->ao_chans;
+	s->maxdata = (1 << boardinfo->ao_bits) - 1;
+	s->range_table = boardinfo->range;
 	s->insn_write = vmk80xx_ao_winsn;
-	if (dev->board->model == VMK8061_MODEL) {
+	if (boardinfo->model == VMK8061_MODEL) {
 		s->subdev_flags |= SDF_READABLE;
 		s->insn_read = vmk80xx_ao_rinsn;
 	}
+
 	/* Digital input subdevice */
 	s = &cdev->subdevices[VMK80XX_SUBD_DI];
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
-	s->n_chan = dev->board->di_chans;
+	s->n_chan = boardinfo->di_chans;
 	s->maxdata = 1;
 	s->insn_read = vmk80xx_di_rinsn;
 	s->insn_bits = vmk80xx_di_bits;
+
 	/* Digital output subdevice */
 	s = &cdev->subdevices[VMK80XX_SUBD_DO];
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
-	s->n_chan = dev->board->do_chans;
+	s->n_chan = boardinfo->do_chans;
 	s->maxdata = 1;
 	s->insn_write = vmk80xx_do_winsn;
 	s->insn_bits = vmk80xx_do_bits;
-	if (dev->board->model == VMK8061_MODEL) {
+	if (boardinfo->model == VMK8061_MODEL) {
 		s->subdev_flags |= SDF_READABLE;
 		s->insn_read = vmk80xx_do_rinsn;
 	}
+
 	/* Counter subdevice */
 	s = &cdev->subdevices[VMK80XX_SUBD_CNT];
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_READABLE;
-	s->n_chan = dev->board->cnt_chans;
+	s->n_chan = boardinfo->cnt_chans;
 	s->insn_read = vmk80xx_cnt_rinsn;
 	s->insn_config = vmk80xx_cnt_cinsn;
-	if (dev->board->model == VMK8055_MODEL) {
+	if (boardinfo->model == VMK8055_MODEL) {
 		s->subdev_flags |= SDF_WRITEABLE;
-		s->maxdata = (1 << dev->board->cnt_bits) - 1;
+		s->maxdata = (1 << boardinfo->cnt_bits) - 1;
 		s->insn_write = vmk80xx_cnt_winsn;
 	}
+
 	/* PWM subdevice */
-	if (dev->board->model == VMK8061_MODEL) {
+	if (boardinfo->model == VMK8061_MODEL) {
 		s = &cdev->subdevices[VMK80XX_SUBD_PWM];
 		s->type = COMEDI_SUBD_PWM;
 		s->subdev_flags = SDF_READABLE | SDF_WRITEABLE;
-		s->n_chan = dev->board->pwm_chans;
-		s->maxdata = (1 << dev->board->pwm_bits) - 1;
+		s->n_chan = boardinfo->pwm_chans;
+		s->maxdata = (1 << boardinfo->pwm_bits) - 1;
 		s->insn_read = vmk80xx_pwm_rinsn;
 		s->insn_write = vmk80xx_pwm_winsn;
 	}
+
 	dev->attached = 1;
 	dev_info(cdev->class_dev, "vmk80xx: board #%d [%s] attached\n",
-		 dev->count, dev->board->name);
+		 dev->count, boardinfo->name);
+
 	up(&dev->limit_sem);
+
 	return 0;
 }
 
@@ -1283,6 +1307,7 @@ static struct comedi_driver vmk80xx_driver = {
 static int vmk80xx_usb_probe(struct usb_interface *intf,
 			     const struct usb_device_id *id)
 {
+	const struct vmk80xx_board *boardinfo;
 	int i;
 	struct vmk80xx_usb *dev;
 	struct usb_host_interface *iface_desc;
@@ -1363,9 +1388,10 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 
 	usb_set_intfdata(intf, dev);
 
-	dev->board = &vmk80xx_boardinfo[id->driver_info];
+	boardinfo = &vmk80xx_boardinfo[id->driver_info];
+	dev->board = boardinfo;
 
-	if (dev->board->model == VMK8061_MODEL) {
+	if (boardinfo->model == VMK8061_MODEL) {
 		vmk80xx_read_eeprom(dev, IC3_VERSION);
 		dev_info(&intf->dev, "%s\n", dev->fw.ic3_vers);
 
@@ -1377,13 +1403,13 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 		}
 	}
 
-	if (dev->board->model == VMK8055_MODEL)
+	if (boardinfo->model == VMK8055_MODEL)
 		vmk80xx_reset_device(dev);
 
 	dev->probed = 1;
 
 	dev_info(&intf->dev, "board #%d [%s] now attached\n",
-		 dev->count, dev->board->name);
+		 dev->count, boardinfo->name);
 
 	mutex_unlock(&glb_mutex);
 

commit 20d6007755cb665d75ba34d6b9075b4cc02e816a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:18:52 2013 -0700

    staging: comedi: vmk80xx: move boardinfo into a const array
    
    The normal way of presenting the board specific information in comedi
    drivers is store the data in a static const array. This data is then
    accessed using a pointer, normally the comedi_device 'board_ptr',
    
    Move the boardinfo for the two boards supported by this driver from
    the vmk80xx_usb_probe() function into a static const array.
    
    Change the access of this information so a pointer is used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 448c11e57159..dc2efc09deac 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -173,6 +173,43 @@ struct vmk80xx_board {
 	__le16 pwm_bits;
 };
 
+static const struct vmk80xx_board vmk80xx_boardinfo[] = {
+	[DEVICE_VMK8055] = {
+		.name		= "K8055 (VM110)",
+		.model		= VMK8055_MODEL,
+		.range		= &vmk8055_range,
+		.ai_chans	= 2,
+		.ai_bits	= 8,
+		.ao_chans	= 2,
+		.ao_bits	= 8,
+		.di_chans	= 6,
+		.di_bits	= 1,
+		.do_chans	= 8,
+		.do_bits	= 1,
+		.cnt_chans	= 2,
+		.cnt_bits	= 16,
+		.pwm_chans	= 0,
+		.pwm_bits	= 0,
+	},
+	[DEVICE_VMK8061] = {
+		.name		= "K8061 (VM140)",
+		.model		= VMK8061_MODEL,
+		.range		= &vmk8061_range,
+		.ai_chans	= 8,
+		.ai_bits	= 10,
+		.ao_chans	= 8,
+		.ao_bits	= 8,
+		.di_chans	= 8,
+		.di_bits	= 1,
+		.do_chans	= 8,
+		.do_bits	= 1,
+		.cnt_chans	= 2,
+		.cnt_bits	= 0,
+		.pwm_chans	= 1,
+		.pwm_bits	= 10,
+	},
+};
+
 enum {
 	VMK80XX_SUBD_AI,
 	VMK80XX_SUBD_AO,
@@ -189,7 +226,7 @@ struct vmk80xx_usb {
 	struct usb_endpoint_descriptor *ep_tx;
 	struct usb_anchor rx_anchor;
 	struct usb_anchor tx_anchor;
-	struct vmk80xx_board board;
+	const struct vmk80xx_board *board;
 	struct firmware_version fw;
 	struct semaphore limit_sem;
 	wait_queue_head_t read_wait;
@@ -421,7 +458,7 @@ static int vmk80xx_read_packet(struct vmk80xx_usb *dev)
 						       &dev->flags)))
 			return -ERESTART;
 
-	if (dev->board.model == VMK8061_MODEL) {
+	if (dev->board->model == VMK8061_MODEL) {
 		vmk80xx_do_bulk_msg(dev);
 
 		return 0;
@@ -466,7 +503,7 @@ static int vmk80xx_write_packet(struct vmk80xx_usb *dev, int cmd)
 						       &dev->flags)))
 			return -ERESTART;
 
-	if (dev->board.model == VMK8061_MODEL) {
+	if (dev->board->model == VMK8061_MODEL) {
 		dev->usb_tx_buf[0] = cmd;
 		vmk80xx_do_bulk_msg(dev);
 
@@ -538,7 +575,7 @@ static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
-	switch (dev->board.model) {
+	switch (dev->board->model) {
 	case VMK8055_MODEL:
 		if (!chan)
 			reg[0] = VMK8055_AI1_REG;
@@ -558,7 +595,7 @@ static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
 		if (vmk80xx_read_packet(dev))
 			break;
 
-		if (dev->board.model == VMK8055_MODEL) {
+		if (dev->board->model == VMK8055_MODEL) {
 			data[n] = dev->usb_rx_buf[reg[0]];
 			continue;
 		}
@@ -590,7 +627,7 @@ static int vmk80xx_ao_winsn(struct comedi_device *cdev,
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
-	switch (dev->board.model) {
+	switch (dev->board->model) {
 	case VMK8055_MODEL:
 		cmd = VMK8055_CMD_WRT_AD;
 		if (!chan)
@@ -666,7 +703,7 @@ static int vmk80xx_di_bits(struct comedi_device *cdev,
 
 	rx_buf = dev->usb_rx_buf;
 
-	if (dev->board.model == VMK8061_MODEL) {
+	if (dev->board->model == VMK8061_MODEL) {
 		reg = VMK8061_DI_REG;
 		dev->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
 	} else {
@@ -676,7 +713,7 @@ static int vmk80xx_di_bits(struct comedi_device *cdev,
 	retval = vmk80xx_read_packet(dev);
 
 	if (!retval) {
-		if (dev->board.model == VMK8055_MODEL)
+		if (dev->board->model == VMK8055_MODEL)
 			data[1] = (((rx_buf[reg] >> 4) & 0x03) |
 				  ((rx_buf[reg] << 2) & 0x04) |
 				  ((rx_buf[reg] >> 3) & 0x18));
@@ -711,7 +748,7 @@ static int vmk80xx_di_rinsn(struct comedi_device *cdev,
 
 	rx_buf = dev->usb_rx_buf;
 
-	if (dev->board.model == VMK8061_MODEL) {
+	if (dev->board->model == VMK8061_MODEL) {
 		reg = VMK8061_DI_REG;
 		dev->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
 	} else {
@@ -721,7 +758,7 @@ static int vmk80xx_di_rinsn(struct comedi_device *cdev,
 		if (vmk80xx_read_packet(dev))
 			break;
 
-		if (dev->board.model == VMK8055_MODEL)
+		if (dev->board->model == VMK8055_MODEL)
 			inp = (((rx_buf[reg] >> 4) & 0x03) |
 			       ((rx_buf[reg] << 2) & 0x04) |
 			       ((rx_buf[reg] >> 3) & 0x18));
@@ -757,7 +794,7 @@ static int vmk80xx_do_winsn(struct comedi_device *cdev,
 	tx_buf = dev->usb_tx_buf;
 
 	for (n = 0; n < insn->n; n++) {
-		if (dev->board.model == VMK8055_MODEL) {
+		if (dev->board->model == VMK8055_MODEL) {
 			reg = VMK8055_DO_REG;
 			cmd = VMK8055_CMD_WRT_AD;
 			if (data[n] == 1)
@@ -830,7 +867,7 @@ static int vmk80xx_do_bits(struct comedi_device *cdev,
 	if (data[0])
 		dir |= DIR_OUT;
 
-	if (dev->board.model == VMK8061_MODEL)
+	if (dev->board->model == VMK8061_MODEL)
 		dir |= DIR_IN;
 
 	retval = rudimentary_check(dev, dir);
@@ -843,7 +880,7 @@ static int vmk80xx_do_bits(struct comedi_device *cdev,
 	tx_buf = dev->usb_tx_buf;
 
 	if (data[0]) {
-		if (dev->board.model == VMK8055_MODEL) {
+		if (dev->board->model == VMK8055_MODEL) {
 			reg = VMK8055_DO_REG;
 			cmd = VMK8055_CMD_WRT_AD;
 		} else { /* VMK8061_MODEL */
@@ -860,7 +897,7 @@ static int vmk80xx_do_bits(struct comedi_device *cdev,
 			goto out;
 	}
 
-	if (dev->board.model == VMK8061_MODEL) {
+	if (dev->board->model == VMK8061_MODEL) {
 		reg = VMK8061_DO_REG;
 		tx_buf[0] = VMK8061_CMD_RD_DO;
 
@@ -897,7 +934,7 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
 
-	switch (dev->board.model) {
+	switch (dev->board->model) {
 	case VMK8055_MODEL:
 		if (!chan)
 			reg[0] = VMK8055_CNT1_REG;
@@ -916,7 +953,7 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 		if (vmk80xx_read_packet(dev))
 			break;
 
-		if (dev->board.model == VMK8055_MODEL)
+		if (dev->board->model == VMK8055_MODEL)
 			data[n] = dev->usb_rx_buf[reg[0]];
 		else /* VMK8061_MODEL */
 			data[n] = dev->usb_rx_buf[reg[0] * (chan + 1) + 1]
@@ -951,7 +988,7 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *cdev,
 
 	chan = CR_CHAN(insn->chanspec);
 
-	if (dev->board.model == VMK8055_MODEL) {
+	if (dev->board->model == VMK8055_MODEL) {
 		if (!chan) {
 			cmd = VMK8055_CMD_RST_CNT1;
 			reg = VMK8055_CNT1_REG;
@@ -1109,9 +1146,9 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	int ret;
 
 	down(&dev->limit_sem);
-	cdev->board_name = dev->board.name;
+	cdev->board_name = dev->board->name;
 	cdev->private = dev;
-	if (dev->board.model == VMK8055_MODEL)
+	if (dev->board->model == VMK8055_MODEL)
 		n_subd = 5;
 	else
 		n_subd = 6;
@@ -1124,19 +1161,19 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	s = &cdev->subdevices[VMK80XX_SUBD_AI];
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
-	s->n_chan = dev->board.ai_chans;
-	s->maxdata = (1 << dev->board.ai_bits) - 1;
-	s->range_table = dev->board.range;
+	s->n_chan = dev->board->ai_chans;
+	s->maxdata = (1 << dev->board->ai_bits) - 1;
+	s->range_table = dev->board->range;
 	s->insn_read = vmk80xx_ai_rinsn;
 	/* Analog output subdevice */
 	s = &cdev->subdevices[VMK80XX_SUBD_AO];
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
-	s->n_chan = dev->board.ao_chans;
-	s->maxdata = (1 << dev->board.ao_bits) - 1;
-	s->range_table = dev->board.range;
+	s->n_chan = dev->board->ao_chans;
+	s->maxdata = (1 << dev->board->ao_bits) - 1;
+	s->range_table = dev->board->range;
 	s->insn_write = vmk80xx_ao_winsn;
-	if (dev->board.model == VMK8061_MODEL) {
+	if (dev->board->model == VMK8061_MODEL) {
 		s->subdev_flags |= SDF_READABLE;
 		s->insn_read = vmk80xx_ao_rinsn;
 	}
@@ -1144,7 +1181,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	s = &cdev->subdevices[VMK80XX_SUBD_DI];
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
-	s->n_chan = dev->board.di_chans;
+	s->n_chan = dev->board->di_chans;
 	s->maxdata = 1;
 	s->insn_read = vmk80xx_di_rinsn;
 	s->insn_bits = vmk80xx_di_bits;
@@ -1152,11 +1189,11 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	s = &cdev->subdevices[VMK80XX_SUBD_DO];
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
-	s->n_chan = dev->board.do_chans;
+	s->n_chan = dev->board->do_chans;
 	s->maxdata = 1;
 	s->insn_write = vmk80xx_do_winsn;
 	s->insn_bits = vmk80xx_do_bits;
-	if (dev->board.model == VMK8061_MODEL) {
+	if (dev->board->model == VMK8061_MODEL) {
 		s->subdev_flags |= SDF_READABLE;
 		s->insn_read = vmk80xx_do_rinsn;
 	}
@@ -1164,27 +1201,27 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	s = &cdev->subdevices[VMK80XX_SUBD_CNT];
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_READABLE;
-	s->n_chan = dev->board.cnt_chans;
+	s->n_chan = dev->board->cnt_chans;
 	s->insn_read = vmk80xx_cnt_rinsn;
 	s->insn_config = vmk80xx_cnt_cinsn;
-	if (dev->board.model == VMK8055_MODEL) {
+	if (dev->board->model == VMK8055_MODEL) {
 		s->subdev_flags |= SDF_WRITEABLE;
-		s->maxdata = (1 << dev->board.cnt_bits) - 1;
+		s->maxdata = (1 << dev->board->cnt_bits) - 1;
 		s->insn_write = vmk80xx_cnt_winsn;
 	}
 	/* PWM subdevice */
-	if (dev->board.model == VMK8061_MODEL) {
+	if (dev->board->model == VMK8061_MODEL) {
 		s = &cdev->subdevices[VMK80XX_SUBD_PWM];
 		s->type = COMEDI_SUBD_PWM;
 		s->subdev_flags = SDF_READABLE | SDF_WRITEABLE;
-		s->n_chan = dev->board.pwm_chans;
-		s->maxdata = (1 << dev->board.pwm_bits) - 1;
+		s->n_chan = dev->board->pwm_chans;
+		s->maxdata = (1 << dev->board->pwm_bits) - 1;
 		s->insn_read = vmk80xx_pwm_rinsn;
 		s->insn_write = vmk80xx_pwm_winsn;
 	}
 	dev->attached = 1;
 	dev_info(cdev->class_dev, "vmk80xx: board #%d [%s] attached\n",
-		 dev->count, dev->board.name);
+		 dev->count, dev->board->name);
 	up(&dev->limit_sem);
 	return 0;
 }
@@ -1326,44 +1363,9 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 
 	usb_set_intfdata(intf, dev);
 
-	switch (id->driver_info) {
-	case DEVICE_VMK8055:
-		dev->board.name = "K8055 (VM110)";
-		dev->board.model = VMK8055_MODEL;
-		dev->board.range = &vmk8055_range;
-		dev->board.ai_chans = 2;
-		dev->board.ai_bits = 8;
-		dev->board.ao_chans = 2;
-		dev->board.ao_bits = 8;
-		dev->board.di_chans = 5;
-		dev->board.di_bits = 1;
-		dev->board.do_chans = 8;
-		dev->board.do_bits = 1;
-		dev->board.cnt_chans = 2;
-		dev->board.cnt_bits = 16;
-		dev->board.pwm_chans = 0;
-		dev->board.pwm_bits = 0;
-		break;
-	case DEVICE_VMK8061:
-		dev->board.name = "K8061 (VM140)";
-		dev->board.model = VMK8061_MODEL;
-		dev->board.range = &vmk8061_range;
-		dev->board.ai_chans = 8;
-		dev->board.ai_bits = 10;
-		dev->board.ao_chans = 8;
-		dev->board.ao_bits = 8;
-		dev->board.di_chans = 8;
-		dev->board.di_bits = 1;
-		dev->board.do_chans = 8;
-		dev->board.do_bits = 1;
-		dev->board.cnt_chans = 2;
-		dev->board.cnt_bits = 0;
-		dev->board.pwm_chans = 1;
-		dev->board.pwm_bits = 10;
-		break;
-	}
+	dev->board = &vmk80xx_boardinfo[id->driver_info];
 
-	if (dev->board.model == VMK8061_MODEL) {
+	if (dev->board->model == VMK8061_MODEL) {
 		vmk80xx_read_eeprom(dev, IC3_VERSION);
 		dev_info(&intf->dev, "%s\n", dev->fw.ic3_vers);
 
@@ -1375,13 +1377,13 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 		}
 	}
 
-	if (dev->board.model == VMK8055_MODEL)
+	if (dev->board->model == VMK8055_MODEL)
 		vmk80xx_reset_device(dev);
 
 	dev->probed = 1;
 
 	dev_info(&intf->dev, "board #%d [%s] now attached\n",
-		 dev->count, dev->board.name);
+		 dev->count, dev->board->name);
 
 	mutex_unlock(&glb_mutex);
 

commit ce87422743608b436da9e0ce34d01519cd75ea3e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:18:26 2013 -0700

    staging: comedi: vmk80xx: use comedi_auto_unconfig() for (*disconnect)
    
    The usb_driver (*disconnect) in this driver is simply a wrapper around
    comedi_auto_unconfig(). Just use comedi_auto_unconfig() directly for
    the (*disconnect).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 8cd49715581a..448c11e57159 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1394,11 +1394,6 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 	return -ENODEV;
 }
 
-static void vmk80xx_usb_disconnect(struct usb_interface *intf)
-{
-	comedi_usb_auto_unconfig(intf);
-}
-
 static const struct usb_device_id vmk80xx_usb_id_table[] = {
 	{ USB_DEVICE(0x10cf, 0x5500), .driver_info = DEVICE_VMK8055 },
 	{ USB_DEVICE(0x10cf, 0x5501), .driver_info = DEVICE_VMK8055 },
@@ -1416,13 +1411,11 @@ static const struct usb_device_id vmk80xx_usb_id_table[] = {
 };
 MODULE_DEVICE_TABLE(usb, vmk80xx_usb_id_table);
 
-/* TODO: Add support for suspend, resume, pre_reset,
- * post_reset and flush */
 static struct usb_driver vmk80xx_usb_driver = {
 	.name		= "vmk80xx",
-	.probe		= vmk80xx_usb_probe,
-	.disconnect	= vmk80xx_usb_disconnect,
 	.id_table	= vmk80xx_usb_id_table,
+	.probe		= vmk80xx_usb_probe,
+	.disconnect	= comedi_usb_auto_unconfig,
 };
 module_comedi_usb_driver(vmk80xx_driver, vmk80xx_usb_driver);
 

commit 9377b9234f159773a53c7277559cc24397dd9803
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:18:04 2013 -0700

    staging: comedi: vmk80xx: move usb_driver (*disconnect) code
    
    The usb_driver (*disconnect) in this driver calls the comedi core
    comedi_usb_auto_unconfig() which calls the comedi_driver (*detach).
    
    Move the code in the (*disconnect) to the (*detach) to get all the
    disconnect/detach in one place.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index f5a999c60763..8cd49715581a 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1214,12 +1214,26 @@ static void vmk80xx_detach(struct comedi_device *dev)
 {
 	struct vmk80xx_usb *usb = dev->private;
 
-	if (usb) {
-		down(&usb->limit_sem);
-		dev->private = NULL;
-		usb->attached = 0;
-		up(&usb->limit_sem);
-	}
+	if (!usb)
+		return;
+
+	mutex_lock(&glb_mutex);
+	down(&usb->limit_sem);
+
+	dev->private = NULL;
+
+	usb->attached = 0;
+	usb->probed = 0;
+	usb_set_intfdata(usb->intf, NULL);
+
+	usb_kill_anchored_urbs(&usb->rx_anchor);
+	usb_kill_anchored_urbs(&usb->tx_anchor);
+
+	kfree(usb->usb_rx_buf);
+	kfree(usb->usb_tx_buf);
+
+	up(&usb->limit_sem);
+	mutex_unlock(&glb_mutex);
 }
 
 static struct comedi_driver vmk80xx_driver = {
@@ -1382,30 +1396,7 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 
 static void vmk80xx_usb_disconnect(struct usb_interface *intf)
 {
-	struct vmk80xx_usb *dev = usb_get_intfdata(intf);
-
-	if (!dev)
-		return;
-
 	comedi_usb_auto_unconfig(intf);
-
-	mutex_lock(&glb_mutex);
-	down(&dev->limit_sem);
-
-	dev->probed = 0;
-	usb_set_intfdata(dev->intf, NULL);
-
-	usb_kill_anchored_urbs(&dev->rx_anchor);
-	usb_kill_anchored_urbs(&dev->tx_anchor);
-
-	kfree(dev->usb_rx_buf);
-	kfree(dev->usb_tx_buf);
-
-	dev_info(&intf->dev, "board #%d [%s] now detached\n",
-		 dev->count, dev->board.name);
-
-	up(&dev->limit_sem);
-	mutex_unlock(&glb_mutex);
 }
 
 static const struct usb_device_id vmk80xx_usb_id_table[] = {

commit 07b502f50bfc290222fe4032501619a44bbd777e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:17:36 2013 -0700

    staging: comedi: vmk80xx: remove support for manual attaching
    
    This comedi USB driver supports attaching with the auto config
    mechanism. Remove the manual attaching support using the
    COMEDI_DEVCONFIG ioctl.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 609dc6915997..f5a999c60763 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1189,26 +1189,6 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	return 0;
 }
 
-/* called for COMEDI_DEVCONFIG ioctl for board_name "vmk80xx" */
-static int vmk80xx_attach(struct comedi_device *cdev,
-			  struct comedi_devconfig *it)
-{
-	int i;
-	int ret;
-
-	mutex_lock(&glb_mutex);
-	for (i = 0; i < VMK80XX_MAX_BOARDS; i++)
-		if (vmb[i].probed && !vmb[i].attached)
-			break;
-	if (i == VMK80XX_MAX_BOARDS)
-		ret = -ENODEV;
-	else
-		ret = vmk80xx_attach_common(cdev, &vmb[i]);
-	mutex_unlock(&glb_mutex);
-	return ret;
-}
-
-/* called via comedi_usb_auto_config() */
 static int vmk80xx_auto_attach(struct comedi_device *cdev,
 			       unsigned long context_unused)
 {
@@ -1245,9 +1225,8 @@ static void vmk80xx_detach(struct comedi_device *dev)
 static struct comedi_driver vmk80xx_driver = {
 	.module		= THIS_MODULE,
 	.driver_name	= "vmk80xx",
-	.attach		= vmk80xx_attach,
-	.detach		= vmk80xx_detach,
 	.auto_attach	= vmk80xx_auto_attach,
+	.detach		= vmk80xx_detach,
 };
 
 static int vmk80xx_usb_probe(struct usb_interface *intf,

commit 392ba7bc37b453ae056542045fd7b8b349c7978e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Sat Oct 27 21:44:17 2012 +0100

    staging: comedi: vmk80xx: use auto_attach() hook
    
    Use the new `auto_attach()` hook in the `struct comedi_driver` instead
    of the old `attach_usb()` hook.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 366490776c5a..609dc6915997 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1209,9 +1209,10 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 }
 
 /* called via comedi_usb_auto_config() */
-static int vmk80xx_attach_usb(struct comedi_device *cdev,
-			      struct usb_interface *intf)
+static int vmk80xx_auto_attach(struct comedi_device *cdev,
+			       unsigned long context_unused)
 {
+	struct usb_interface *intf = comedi_to_usb_interface(cdev);
 	int i;
 	int ret;
 
@@ -1246,7 +1247,7 @@ static struct comedi_driver vmk80xx_driver = {
 	.driver_name	= "vmk80xx",
 	.attach		= vmk80xx_attach,
 	.detach		= vmk80xx_detach,
-	.attach_usb	= vmk80xx_attach_usb,
+	.auto_attach	= vmk80xx_auto_attach,
 };
 
 static int vmk80xx_usb_probe(struct usb_interface *intf,

commit 7194d0e107fa70ca46b2a03b27b8b7ad2266d8bf
Author: YAMANE Toshiaki <yamanetoshi@gmail.com>
Date:   Wed Oct 24 14:21:51 2012 +0900

    staging/comedi: Use dev_ printks in drivers/vmk80xx.c
    
    fixed below checkpatch warning.
    - Prefer netdev_info(netdev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
    
    Signed-off-by: YAMANE Toshiaki <yamanetoshi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index df277aa591bb..366490776c5a 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1371,12 +1371,11 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 
 	if (dev->board.model == VMK8061_MODEL) {
 		vmk80xx_read_eeprom(dev, IC3_VERSION);
-		printk(KERN_INFO "comedi#: vmk80xx: %s\n", dev->fw.ic3_vers);
+		dev_info(&intf->dev, "%s\n", dev->fw.ic3_vers);
 
 		if (vmk80xx_check_data_link(dev)) {
 			vmk80xx_read_eeprom(dev, IC6_VERSION);
-			printk(KERN_INFO "comedi#: vmk80xx: %s\n",
-			       dev->fw.ic6_vers);
+			dev_info(&intf->dev, "%s\n", dev->fw.ic6_vers);
 		} else {
 			dbgcm("comedi#: vmk80xx: no conn. to CPU\n");
 		}
@@ -1387,8 +1386,8 @@ static int vmk80xx_usb_probe(struct usb_interface *intf,
 
 	dev->probed = 1;
 
-	printk(KERN_INFO "comedi#: vmk80xx: board #%d [%s] now attached\n",
-	       dev->count, dev->board.name);
+	dev_info(&intf->dev, "board #%d [%s] now attached\n",
+		 dev->count, dev->board.name);
 
 	mutex_unlock(&glb_mutex);
 
@@ -1422,8 +1421,8 @@ static void vmk80xx_usb_disconnect(struct usb_interface *intf)
 	kfree(dev->usb_rx_buf);
 	kfree(dev->usb_tx_buf);
 
-	printk(KERN_INFO "comedi#: vmk80xx: board #%d [%s] now detached\n",
-	       dev->count, dev->board.name);
+	dev_info(&intf->dev, "board #%d [%s] now detached\n",
+		 dev->count, dev->board.name);
 
 	up(&dev->limit_sem);
 	mutex_unlock(&glb_mutex);

commit 13f7952f8f13fb1bbd18b85988e3a5bbbed00879
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Sep 6 11:21:48 2012 -0700

    staging: comedi: vmk80xx: fix compiler warning
    
    gcc complains about some potentially uninitalized variables here, yet it
    can not happen, due to an enumerated type (either the board is one type
    or the other.)  Make the compiler happy by providing a default case
    option that makes the logic a bit simpler for it to determine that there
    really isn't a problem here.
    
    Cc: H Hartley Sweeten <hartleys@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index f9fef26db3aa..df277aa591bb 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -546,6 +546,7 @@ static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
 			reg[0] = VMK8055_AI2_REG;
 		break;
 	case VMK8061_MODEL:
+	default:
 		reg[0] = VMK8061_AI_REG1;
 		reg[1] = VMK8061_AI_REG2;
 		dev->usb_tx_buf[0] = VMK8061_CMD_RD_AI;
@@ -904,6 +905,7 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 			reg[0] = VMK8055_CNT2_REG;
 		break;
 	case VMK8061_MODEL:
+	default:
 		reg[0] = VMK8061_CNT_REG;
 		reg[1] = VMK8061_CNT_REG;
 		dev->usb_tx_buf[0] = VMK8061_CMD_RD_CNT;

commit d3d1e2532f33b49515bf9ea9e2b4cc1dbb1d47c9
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:59:09 2012 -0700

    staging: comedi: vmk80xx: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 94010fc05905..f9fef26db3aa 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1119,7 +1119,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 		return ret;
 	}
 	/* Analog input subdevice */
-	s = cdev->subdevices + VMK80XX_SUBD_AI;
+	s = &cdev->subdevices[VMK80XX_SUBD_AI];
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
 	s->n_chan = dev->board.ai_chans;
@@ -1127,7 +1127,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	s->range_table = dev->board.range;
 	s->insn_read = vmk80xx_ai_rinsn;
 	/* Analog output subdevice */
-	s = cdev->subdevices + VMK80XX_SUBD_AO;
+	s = &cdev->subdevices[VMK80XX_SUBD_AO];
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
 	s->n_chan = dev->board.ao_chans;
@@ -1139,7 +1139,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 		s->insn_read = vmk80xx_ao_rinsn;
 	}
 	/* Digital input subdevice */
-	s = cdev->subdevices + VMK80XX_SUBD_DI;
+	s = &cdev->subdevices[VMK80XX_SUBD_DI];
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
 	s->n_chan = dev->board.di_chans;
@@ -1147,7 +1147,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	s->insn_read = vmk80xx_di_rinsn;
 	s->insn_bits = vmk80xx_di_bits;
 	/* Digital output subdevice */
-	s = cdev->subdevices + VMK80XX_SUBD_DO;
+	s = &cdev->subdevices[VMK80XX_SUBD_DO];
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
 	s->n_chan = dev->board.do_chans;
@@ -1159,7 +1159,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 		s->insn_read = vmk80xx_do_rinsn;
 	}
 	/* Counter subdevice */
-	s = cdev->subdevices + VMK80XX_SUBD_CNT;
+	s = &cdev->subdevices[VMK80XX_SUBD_CNT];
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_READABLE;
 	s->n_chan = dev->board.cnt_chans;
@@ -1172,7 +1172,7 @@ static int vmk80xx_attach_common(struct comedi_device *cdev,
 	}
 	/* PWM subdevice */
 	if (dev->board.model == VMK8061_MODEL) {
-		s = cdev->subdevices + VMK80XX_SUBD_PWM;
+		s = &cdev->subdevices[VMK80XX_SUBD_PWM];
 		s->type = COMEDI_SUBD_PWM;
 		s->subdev_flags = SDF_READABLE | SDF_WRITEABLE;
 		s->n_chan = dev->board.pwm_chans;

commit 007ff2af216090b4c20ebd2b9d94c528102ec135
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 12:01:57 2012 -0700

    staging: comedi: vmk80xx: refactor init code
    
    Refactor the usb driver probe/disconnect and comedi driver attach/
    detach to follow the style of the other comedi driver types to
    improve maintainability.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 14fb50a49d44..94010fc05905 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -64,37 +64,11 @@ Status: works
 
 #include "../comedidev.h"
 
-#define BOARDNAME "vmk80xx"
-
-MODULE_AUTHOR("Manuel Gebele <forensixs@gmx.de>");
-MODULE_DESCRIPTION("Velleman USB Board Low-Level Driver");
-MODULE_SUPPORTED_DEVICE("K8055/K8061 aka VM110/VM140");
-MODULE_VERSION("0.8.01");
-MODULE_LICENSE("GPL");
-
 enum {
 	DEVICE_VMK8055,
 	DEVICE_VMK8061
 };
 
-static const struct usb_device_id vmk80xx_id_table[] = {
-	{USB_DEVICE(0x10cf, 0x5500), .driver_info = DEVICE_VMK8055},
-	{USB_DEVICE(0x10cf, 0x5501), .driver_info = DEVICE_VMK8055},
-	{USB_DEVICE(0x10cf, 0x5502), .driver_info = DEVICE_VMK8055},
-	{USB_DEVICE(0x10cf, 0x5503), .driver_info = DEVICE_VMK8055},
-	{USB_DEVICE(0x10cf, 0x8061), .driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8062), .driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8063), .driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8064), .driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8065), .driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8066), .driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8067), .driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8068), .driver_info = DEVICE_VMK8061},
-	{}			/* terminating entry */
-};
-
-MODULE_DEVICE_TABLE(usb, vmk80xx_id_table);
-
 #define VMK8055_DI_REG          0x00
 #define VMK8055_DO_REG          0x01
 #define VMK8055_AO1_REG         0x02
@@ -232,8 +206,6 @@ static struct vmk80xx_usb vmb[VMK80XX_MAX_BOARDS];
 
 static DEFINE_MUTEX(glb_mutex);
 
-static struct comedi_driver vmk80xx_driver;	/* see below for initializer */
-
 static void vmk80xx_tx_callback(struct urb *urb)
 {
 	struct vmk80xx_usb *dev = urb->context;
@@ -1267,8 +1239,16 @@ static void vmk80xx_detach(struct comedi_device *dev)
 	}
 }
 
-static int vmk80xx_probe(struct usb_interface *intf,
-			 const struct usb_device_id *id)
+static struct comedi_driver vmk80xx_driver = {
+	.module		= THIS_MODULE,
+	.driver_name	= "vmk80xx",
+	.attach		= vmk80xx_attach,
+	.detach		= vmk80xx_detach,
+	.attach_usb	= vmk80xx_attach_usb,
+};
+
+static int vmk80xx_usb_probe(struct usb_interface *intf,
+			     const struct usb_device_id *id)
 {
 	int i;
 	struct vmk80xx_usb *dev;
@@ -1419,7 +1399,7 @@ static int vmk80xx_probe(struct usb_interface *intf,
 	return -ENODEV;
 }
 
-static void vmk80xx_disconnect(struct usb_interface *intf)
+static void vmk80xx_usb_disconnect(struct usb_interface *intf)
 {
 	struct vmk80xx_usb *dev = usb_get_intfdata(intf);
 
@@ -1447,20 +1427,35 @@ static void vmk80xx_disconnect(struct usb_interface *intf)
 	mutex_unlock(&glb_mutex);
 }
 
+static const struct usb_device_id vmk80xx_usb_id_table[] = {
+	{ USB_DEVICE(0x10cf, 0x5500), .driver_info = DEVICE_VMK8055 },
+	{ USB_DEVICE(0x10cf, 0x5501), .driver_info = DEVICE_VMK8055 },
+	{ USB_DEVICE(0x10cf, 0x5502), .driver_info = DEVICE_VMK8055 },
+	{ USB_DEVICE(0x10cf, 0x5503), .driver_info = DEVICE_VMK8055 },
+	{ USB_DEVICE(0x10cf, 0x8061), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8062), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8063), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8064), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8065), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8066), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8067), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8068), .driver_info = DEVICE_VMK8061 },
+	{ }
+};
+MODULE_DEVICE_TABLE(usb, vmk80xx_usb_id_table);
+
 /* TODO: Add support for suspend, resume, pre_reset,
  * post_reset and flush */
 static struct usb_driver vmk80xx_usb_driver = {
 	.name		= "vmk80xx",
-	.probe		= vmk80xx_probe,
-	.disconnect	= vmk80xx_disconnect,
-	.id_table	= vmk80xx_id_table
-};
-
-static struct comedi_driver vmk80xx_driver = {
-	.module		= THIS_MODULE,
-	.driver_name	= "vmk80xx",
-	.attach		= vmk80xx_attach,
-	.detach		= vmk80xx_detach,
-	.attach_usb	= vmk80xx_attach_usb,
+	.probe		= vmk80xx_usb_probe,
+	.disconnect	= vmk80xx_usb_disconnect,
+	.id_table	= vmk80xx_usb_id_table,
 };
 module_comedi_usb_driver(vmk80xx_driver, vmk80xx_usb_driver);
+
+MODULE_AUTHOR("Manuel Gebele <forensixs@gmx.de>");
+MODULE_DESCRIPTION("Velleman USB Board Low-Level Driver");
+MODULE_SUPPORTED_DEVICE("K8055/K8061 aka VM110/VM140");
+MODULE_VERSION("0.8.01");
+MODULE_LICENSE("GPL");

commit d6cc3ec8e727de15ac59e7a184f9d51bf476147b
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 12:01:44 2012 -0700

    staging: comedi: vmk80xx: use module_comedi_usb_driver()
    
    Use the module_comedi_usb_driver helper macro to initialize this
    module. Rename the driver structs to follow the pattern of the
    other comedi driver types and add some whitespace to improve
    readability.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 7d3cb3a035e6..14fb50a49d44 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -232,7 +232,7 @@ static struct vmk80xx_usb vmb[VMK80XX_MAX_BOARDS];
 
 static DEFINE_MUTEX(glb_mutex);
 
-static struct comedi_driver driver_vmk80xx;	/* see below for initializer */
+static struct comedi_driver vmk80xx_driver;	/* see below for initializer */
 
 static void vmk80xx_tx_callback(struct urb *urb)
 {
@@ -1410,7 +1410,7 @@ static int vmk80xx_probe(struct usb_interface *intf,
 
 	mutex_unlock(&glb_mutex);
 
-	comedi_usb_auto_config(intf, &driver_vmk80xx);
+	comedi_usb_auto_config(intf, &vmk80xx_driver);
 
 	return 0;
 error:
@@ -1449,40 +1449,18 @@ static void vmk80xx_disconnect(struct usb_interface *intf)
 
 /* TODO: Add support for suspend, resume, pre_reset,
  * post_reset and flush */
-static struct usb_driver vmk80xx_driver = {
-	.name = "vmk80xx",
-	.probe = vmk80xx_probe,
-	.disconnect = vmk80xx_disconnect,
-	.id_table = vmk80xx_id_table
+static struct usb_driver vmk80xx_usb_driver = {
+	.name		= "vmk80xx",
+	.probe		= vmk80xx_probe,
+	.disconnect	= vmk80xx_disconnect,
+	.id_table	= vmk80xx_id_table
 };
 
-static struct comedi_driver driver_vmk80xx = {
-	.module = THIS_MODULE,
-	.driver_name = "vmk80xx",
-	.attach = vmk80xx_attach,
-	.detach = vmk80xx_detach,
-	.attach_usb = vmk80xx_attach_usb,
+static struct comedi_driver vmk80xx_driver = {
+	.module		= THIS_MODULE,
+	.driver_name	= "vmk80xx",
+	.attach		= vmk80xx_attach,
+	.detach		= vmk80xx_detach,
+	.attach_usb	= vmk80xx_attach_usb,
 };
-
-static int __init vmk80xx_init(void)
-{
-	int retval;
-
-	printk(KERN_INFO "vmk80xx: version 0.8.01 "
-	       "Manuel Gebele <forensixs@gmx.de>\n");
-
-	retval = comedi_driver_register(&driver_vmk80xx);
-	if (retval < 0)
-		return retval;
-
-	return usb_register(&vmk80xx_driver);
-}
-
-static void __exit vmk80xx_exit(void)
-{
-	comedi_driver_unregister(&driver_vmk80xx);
-	usb_deregister(&vmk80xx_driver);
-}
-
-module_init(vmk80xx_init);
-module_exit(vmk80xx_exit);
+module_comedi_usb_driver(vmk80xx_driver, vmk80xx_usb_driver);

commit f7d4d3bc0c5e30ac58e9e41c695852bfdcb8cb95
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jun 18 17:36:58 2012 +0100

    staging: comedi: vmk80xx: use attach_usb() hook
    
    Change the vmv80xx driver to use the new attach_usb() hook in struct
    comedi_driver to auto-configure probed USB devices after the firmware is
    loaded.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 69402dade14b..7d3cb3a035e6 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1127,46 +1127,25 @@ static int vmk80xx_pwm_winsn(struct comedi_device *cdev,
 	return n;
 }
 
-static int vmk80xx_attach(struct comedi_device *cdev,
-			  struct comedi_devconfig *it)
+static int vmk80xx_attach_common(struct comedi_device *cdev,
+				 struct vmk80xx_usb *dev)
 {
-	int i;
-	struct vmk80xx_usb *dev;
 	int n_subd;
 	struct comedi_subdevice *s;
-	int minor;
 	int ret;
 
-	mutex_lock(&glb_mutex);
-
-	for (i = 0; i < VMK80XX_MAX_BOARDS; i++)
-		if (vmb[i].probed && !vmb[i].attached)
-			break;
-
-	if (i == VMK80XX_MAX_BOARDS) {
-		mutex_unlock(&glb_mutex);
-		return -ENODEV;
-	}
-
-	dev = &vmb[i];
-
 	down(&dev->limit_sem);
-
 	cdev->board_name = dev->board.name;
 	cdev->private = dev;
-
 	if (dev->board.model == VMK8055_MODEL)
 		n_subd = 5;
 	else
 		n_subd = 6;
-
 	ret = comedi_alloc_subdevices(cdev, n_subd);
 	if (ret) {
 		up(&dev->limit_sem);
-		mutex_unlock(&glb_mutex);
 		return ret;
 	}
-
 	/* Analog input subdevice */
 	s = cdev->subdevices + VMK80XX_SUBD_AI;
 	s->type = COMEDI_SUBD_AI;
@@ -1175,7 +1154,6 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	s->maxdata = (1 << dev->board.ai_bits) - 1;
 	s->range_table = dev->board.range;
 	s->insn_read = vmk80xx_ai_rinsn;
-
 	/* Analog output subdevice */
 	s = cdev->subdevices + VMK80XX_SUBD_AO;
 	s->type = COMEDI_SUBD_AO;
@@ -1184,12 +1162,10 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	s->maxdata = (1 << dev->board.ao_bits) - 1;
 	s->range_table = dev->board.range;
 	s->insn_write = vmk80xx_ao_winsn;
-
 	if (dev->board.model == VMK8061_MODEL) {
 		s->subdev_flags |= SDF_READABLE;
 		s->insn_read = vmk80xx_ao_rinsn;
 	}
-
 	/* Digital input subdevice */
 	s = cdev->subdevices + VMK80XX_SUBD_DI;
 	s->type = COMEDI_SUBD_DI;
@@ -1198,7 +1174,6 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	s->maxdata = 1;
 	s->insn_read = vmk80xx_di_rinsn;
 	s->insn_bits = vmk80xx_di_bits;
-
 	/* Digital output subdevice */
 	s = cdev->subdevices + VMK80XX_SUBD_DO;
 	s->type = COMEDI_SUBD_DO;
@@ -1207,12 +1182,10 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	s->maxdata = 1;
 	s->insn_write = vmk80xx_do_winsn;
 	s->insn_bits = vmk80xx_do_bits;
-
 	if (dev->board.model == VMK8061_MODEL) {
 		s->subdev_flags |= SDF_READABLE;
 		s->insn_read = vmk80xx_do_rinsn;
 	}
-
 	/* Counter subdevice */
 	s = cdev->subdevices + VMK80XX_SUBD_CNT;
 	s->type = COMEDI_SUBD_COUNTER;
@@ -1220,13 +1193,11 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	s->n_chan = dev->board.cnt_chans;
 	s->insn_read = vmk80xx_cnt_rinsn;
 	s->insn_config = vmk80xx_cnt_cinsn;
-
 	if (dev->board.model == VMK8055_MODEL) {
 		s->subdev_flags |= SDF_WRITEABLE;
 		s->maxdata = (1 << dev->board.cnt_bits) - 1;
 		s->insn_write = vmk80xx_cnt_winsn;
 	}
-
 	/* PWM subdevice */
 	if (dev->board.model == VMK8061_MODEL) {
 		s = cdev->subdevices + VMK80XX_SUBD_PWM;
@@ -1237,19 +1208,51 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 		s->insn_read = vmk80xx_pwm_rinsn;
 		s->insn_write = vmk80xx_pwm_winsn;
 	}
-
 	dev->attached = 1;
+	dev_info(cdev->class_dev, "vmk80xx: board #%d [%s] attached\n",
+		 dev->count, dev->board.name);
+	up(&dev->limit_sem);
+	return 0;
+}
 
-	minor = cdev->minor;
-
-	printk(KERN_INFO
-	       "comedi%d: vmk80xx: board #%d [%s] attached to comedi\n",
-	       minor, dev->count, dev->board.name);
+/* called for COMEDI_DEVCONFIG ioctl for board_name "vmk80xx" */
+static int vmk80xx_attach(struct comedi_device *cdev,
+			  struct comedi_devconfig *it)
+{
+	int i;
+	int ret;
 
-	up(&dev->limit_sem);
+	mutex_lock(&glb_mutex);
+	for (i = 0; i < VMK80XX_MAX_BOARDS; i++)
+		if (vmb[i].probed && !vmb[i].attached)
+			break;
+	if (i == VMK80XX_MAX_BOARDS)
+		ret = -ENODEV;
+	else
+		ret = vmk80xx_attach_common(cdev, &vmb[i]);
 	mutex_unlock(&glb_mutex);
+	return ret;
+}
 
-	return 0;
+/* called via comedi_usb_auto_config() */
+static int vmk80xx_attach_usb(struct comedi_device *cdev,
+			      struct usb_interface *intf)
+{
+	int i;
+	int ret;
+
+	mutex_lock(&glb_mutex);
+	for (i = 0; i < VMK80XX_MAX_BOARDS; i++)
+		if (vmb[i].probed && vmb[i].intf == intf)
+			break;
+	if (i == VMK80XX_MAX_BOARDS)
+		ret = -ENODEV;
+	else if (vmb[i].attached)
+		ret = -EBUSY;
+	else
+		ret = vmk80xx_attach_common(cdev, &vmb[i]);
+	mutex_unlock(&glb_mutex);
+	return ret;
 }
 
 static void vmk80xx_detach(struct comedi_device *dev)
@@ -1457,7 +1460,8 @@ static struct comedi_driver driver_vmk80xx = {
 	.module = THIS_MODULE,
 	.driver_name = "vmk80xx",
 	.attach = vmk80xx_attach,
-	.detach = vmk80xx_detach
+	.detach = vmk80xx_detach,
+	.attach_usb = vmk80xx_attach_usb,
 };
 
 static int __init vmk80xx_init(void)

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 5a3e33d83c84..69402dade14b 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1135,6 +1135,7 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	int n_subd;
 	struct comedi_subdevice *s;
 	int minor;
+	int ret;
 
 	mutex_lock(&glb_mutex);
 
@@ -1159,10 +1160,11 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	else
 		n_subd = 6;
 
-	if (comedi_alloc_subdevices(cdev, n_subd) < 0) {
+	ret = comedi_alloc_subdevices(cdev, n_subd);
+	if (ret) {
 		up(&dev->limit_sem);
 		mutex_unlock(&glb_mutex);
-		return -ENOMEM;
+		return ret;
 	}
 
 	/* Analog input subdevice */

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index baee8d767636..5a3e33d83c84 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1159,7 +1159,7 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	else
 		n_subd = 6;
 
-	if (alloc_subdevices(cdev, n_subd) < 0) {
+	if (comedi_alloc_subdevices(cdev, n_subd) < 0) {
 		up(&dev->limit_sem);
 		mutex_unlock(&glb_mutex);
 		return -ENOMEM;

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index d0e106523a56..baee8d767636 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1250,32 +1250,16 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	return 0;
 }
 
-static int vmk80xx_detach(struct comedi_device *cdev)
+static void vmk80xx_detach(struct comedi_device *dev)
 {
-	struct vmk80xx_usb *dev;
-	int minor;
-
-	if (!cdev)
-		return -EFAULT;
-
-	dev = cdev->private;
-	if (!dev)
-		return -EFAULT;
-
-	down(&dev->limit_sem);
-
-	cdev->private = NULL;
-	dev->attached = 0;
+	struct vmk80xx_usb *usb = dev->private;
 
-	minor = cdev->minor;
-
-	printk(KERN_INFO
-	       "comedi%d: vmk80xx: board #%d [%s] detached from comedi\n",
-	       minor, dev->count, dev->board.name);
-
-	up(&dev->limit_sem);
-
-	return 0;
+	if (usb) {
+		down(&usb->limit_sem);
+		dev->private = NULL;
+		usb->attached = 0;
+		up(&usb->limit_sem);
+	}
 }
 
 static int vmk80xx_probe(struct usb_interface *intf,

commit 98b08941b20e41fcbd3aaa577381e656e1c41291
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri May 4 11:23:54 2012 -0700

    staging: comedi: remove debug tracing in vmk80xx driver
    
    The vmk80xx driver uses a non-existant Kconfig symbol to enable
    function call debug tracing. This output is really just noise
    and doesn't serve any useful purpose. Remove all it's uses in
    the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index a7db6862f75c..d0e106523a56 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -151,27 +151,12 @@ MODULE_DEVICE_TABLE(usb, vmk80xx_id_table);
 #define URB_RCV_FLAG            (1 << 0)
 #define URB_SND_FLAG            (1 << 1)
 
-#define CONFIG_VMK80XX_DEBUG
-#undef CONFIG_VMK80XX_DEBUG
-
-#ifdef CONFIG_VMK80XX_DEBUG
-static int dbgvm = 1;
-#else
-static int dbgvm;
-#endif
-
 #ifdef CONFIG_COMEDI_DEBUG
 static int dbgcm = 1;
 #else
 static int dbgcm;
 #endif
 
-#define dbgvm(fmt, arg...)                     \
-do {                                           \
-	if (dbgvm)                             \
-		printk(KERN_DEBUG fmt, ##arg); \
-} while (0)
-
 #define dbgcm(fmt, arg...)                     \
 do {                                           \
 	if (dbgcm)                             \
@@ -254,8 +239,6 @@ static void vmk80xx_tx_callback(struct urb *urb)
 	struct vmk80xx_usb *dev = urb->context;
 	int stat = urb->status;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	if (stat && !(stat == -ENOENT
 		      || stat == -ECONNRESET || stat == -ESHUTDOWN))
 		dbgcm("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",
@@ -274,8 +257,6 @@ static void vmk80xx_rx_callback(struct urb *urb)
 	struct vmk80xx_usb *dev = urb->context;
 	int stat = urb->status;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	switch (stat) {
 	case 0:
 		break;
@@ -316,8 +297,6 @@ static int vmk80xx_check_data_link(struct vmk80xx_usb *dev)
 	unsigned char tx[1];
 	unsigned char rx[2];
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	tx_pipe = usb_sndbulkpipe(dev->udev, 0x01);
 	rx_pipe = usb_rcvbulkpipe(dev->udev, 0x81);
 
@@ -342,8 +321,6 @@ static void vmk80xx_read_eeprom(struct vmk80xx_usb *dev, int flag)
 	unsigned char rx[64];
 	int cnt;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	tx_pipe = usb_sndbulkpipe(dev->udev, 0x01);
 	rx_pipe = usb_rcvbulkpipe(dev->udev, 0x81);
 
@@ -371,8 +348,6 @@ static int vmk80xx_reset_device(struct vmk80xx_usb *dev)
 	int ival;
 	size_t size;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!urb)
 		return -ENOMEM;
@@ -410,8 +385,6 @@ static void vmk80xx_build_int_urb(struct urb *urb, int flag)
 	void (*callback) (struct urb *);
 	int ival;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	if (flag & URB_RCV_FLAG) {
 		rx_addr = dev->ep_rx->bEndpointAddress;
 		pipe = usb_rcvintpipe(dev->udev, rx_addr);
@@ -439,8 +412,6 @@ static void vmk80xx_do_bulk_msg(struct vmk80xx_usb *dev)
 	unsigned int rx_pipe;
 	size_t size;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	set_bit(TRANS_IN_BUSY, &dev->flags);
 	set_bit(TRANS_OUT_BUSY, &dev->flags);
 
@@ -468,8 +439,6 @@ static int vmk80xx_read_packet(struct vmk80xx_usb *dev)
 	struct urb *urb;
 	int retval;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	if (!dev->intf)
 		return -ENODEV;
 
@@ -516,8 +485,6 @@ static int vmk80xx_write_packet(struct vmk80xx_usb *dev, int cmd)
 	struct urb *urb;
 	int retval;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	if (!dev->intf)
 		return -ENODEV;
 
@@ -592,8 +559,6 @@ static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
 	int reg[2];
 	int n;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	n = rudimentary_check(dev, DIR_IN);
 	if (n)
 		return n;
@@ -645,8 +610,6 @@ static int vmk80xx_ao_winsn(struct comedi_device *cdev,
 	int reg;
 	int n;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	n = rudimentary_check(dev, DIR_OUT);
 	if (n)
 		return n;
@@ -690,8 +653,6 @@ static int vmk80xx_ao_rinsn(struct comedi_device *cdev,
 	int reg;
 	int n;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	n = rudimentary_check(dev, DIR_IN);
 	if (n)
 		return n;
@@ -724,8 +685,6 @@ static int vmk80xx_di_bits(struct comedi_device *cdev,
 	int reg;
 	int retval;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	retval = rudimentary_check(dev, DIR_IN);
 	if (retval)
 		return retval;
@@ -770,8 +729,6 @@ static int vmk80xx_di_rinsn(struct comedi_device *cdev,
 	int inp;
 	int n;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	n = rudimentary_check(dev, DIR_IN);
 	if (n)
 		return n;
@@ -817,8 +774,6 @@ static int vmk80xx_do_winsn(struct comedi_device *cdev,
 	int cmd;
 	int n;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	n = rudimentary_check(dev, DIR_OUT);
 	if (n)
 		return n;
@@ -865,8 +820,6 @@ static int vmk80xx_do_rinsn(struct comedi_device *cdev,
 	int reg;
 	int n;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	n = rudimentary_check(dev, DIR_IN);
 	if (n)
 		return n;
@@ -899,8 +852,6 @@ static int vmk80xx_do_bits(struct comedi_device *cdev,
 	int dir, reg, cmd;
 	int retval;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	dir = 0;
 
 	if (data[0])
@@ -966,8 +917,6 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 	int reg[2];
 	int n;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	n = rudimentary_check(dev, DIR_IN);
 	if (n)
 		return n;
@@ -1016,8 +965,6 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *cdev,
 	int reg;
 	int n;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	n = rudimentary_check(dev, DIR_OUT);
 	if (n)
 		return n;
@@ -1064,8 +1011,6 @@ static int vmk80xx_cnt_winsn(struct comedi_device *cdev,
 	int cmd;
 	int n;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	n = rudimentary_check(dev, DIR_OUT);
 	if (n)
 		return n;
@@ -1110,8 +1055,6 @@ static int vmk80xx_pwm_rinsn(struct comedi_device *cdev,
 	int reg[2];
 	int n;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	n = rudimentary_check(dev, DIR_IN);
 	if (n)
 		return n;
@@ -1145,8 +1088,6 @@ static int vmk80xx_pwm_winsn(struct comedi_device *cdev,
 	int cmd;
 	int n;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	n = rudimentary_check(dev, DIR_OUT);
 	if (n)
 		return n;
@@ -1195,8 +1136,6 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	struct comedi_subdevice *s;
 	int minor;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	mutex_lock(&glb_mutex);
 
 	for (i = 0; i < VMK80XX_MAX_BOARDS; i++)
@@ -1316,8 +1255,6 @@ static int vmk80xx_detach(struct comedi_device *cdev)
 	struct vmk80xx_usb *dev;
 	int minor;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	if (!cdev)
 		return -EFAULT;
 
@@ -1350,8 +1287,6 @@ static int vmk80xx_probe(struct usb_interface *intf,
 	struct usb_endpoint_descriptor *ep_desc;
 	size_t size;
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	mutex_lock(&glb_mutex);
 
 	for (i = 0; i < VMK80XX_MAX_BOARDS; i++)
@@ -1499,8 +1434,6 @@ static void vmk80xx_disconnect(struct usb_interface *intf)
 {
 	struct vmk80xx_usb *dev = usb_get_intfdata(intf);
 
-	dbgvm("vmk80xx: %s\n", __func__);
-
 	if (!dev)
 		return;
 

commit 151373aaff439ab4b1ff7f43cff2cbdd9f4a94f5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Apr 20 16:53:22 2012 -0700

    staging: comedi: vmk80xx.c: remove err() usage
    
    err() was a very old USB-specific macro that I thought had
    gone away.  This patch removes it from being used in the
    driver and uses dev_err() instead.
    
    CC: Ian Abbott <abbotti@mev.co.uk>
    CC: Mori Hess <fmhess@users.sourceforge.net>
    CC: "J. Ali Harlow" <ali@avrc.city.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 856d0ea6007f..a7db6862f75c 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -297,7 +297,9 @@ static void vmk80xx_rx_callback(struct urb *urb)
 		if (!usb_submit_urb(urb, GFP_KERNEL))
 			goto exit;
 
-		err("comedi#: vmk80xx: %s - submit urb failed\n", __func__);
+		dev_err(&urb->dev->dev,
+			"comedi#: vmk80xx: %s - submit urb failed\n",
+			__func__);
 
 		usb_unanchor_urb(urb);
 	}

commit 8f9064a8a3b9f0dfd53bb0dfb3bbbfb457dda4bb
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Apr 20 14:46:27 2012 +0300

    staging: comedi vmk80xx: lock held on error path
    
    If the user passes an invalid command, then we don't drop the lock
    before returning.  The check for invalid commands doesn't need to be
    done under lock so I moved it forward a couple lines.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 10ac58d0cddd..856d0ea6007f 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1020,12 +1020,12 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *cdev,
 	if (n)
 		return n;
 
-	down(&dev->limit_sem);
-
 	insn_cmd = data[0];
 	if (insn_cmd != INSN_CONFIG_RESET && insn_cmd != GPCT_RESET)
 		return -EINVAL;
 
+	down(&dev->limit_sem);
+
 	chan = CR_CHAN(insn->chanspec);
 
 	if (dev->board.model == VMK8055_MODEL) {

commit d8b6ca0850c558f21989d468801ad1414b1372c4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:59 2012 +0100

    staging: comedi: pass usb interface to comedi_usb_auto_config
    
    The comedi_usb_auto_config() and comedi_usb_auto_unconfig() functions
    currently take a 'struct usb_device *'.  It makes more sense to pass a
    'struct usb_interface *' to allow for composite USB devices.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 4bda1e8a007a..10ac58d0cddd 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1484,7 +1484,7 @@ static int vmk80xx_probe(struct usb_interface *intf,
 
 	mutex_unlock(&glb_mutex);
 
-	comedi_usb_auto_config(dev->udev, &driver_vmk80xx);
+	comedi_usb_auto_config(intf, &driver_vmk80xx);
 
 	return 0;
 error:
@@ -1502,7 +1502,7 @@ static void vmk80xx_disconnect(struct usb_interface *intf)
 	if (!dev)
 		return;
 
-	comedi_usb_auto_unconfig(dev->udev);
+	comedi_usb_auto_unconfig(intf);
 
 	mutex_lock(&glb_mutex);
 	down(&dev->limit_sem);

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 3d13ca6e1670..4bda1e8a007a 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -247,6 +247,8 @@ static struct vmk80xx_usb vmb[VMK80XX_MAX_BOARDS];
 
 static DEFINE_MUTEX(glb_mutex);
 
+static struct comedi_driver driver_vmk80xx;	/* see below for initializer */
+
 static void vmk80xx_tx_callback(struct urb *urb)
 {
 	struct vmk80xx_usb *dev = urb->context;
@@ -1482,7 +1484,7 @@ static int vmk80xx_probe(struct usb_interface *intf,
 
 	mutex_unlock(&glb_mutex);
 
-	comedi_usb_auto_config(dev->udev, BOARDNAME);
+	comedi_usb_auto_config(dev->udev, &driver_vmk80xx);
 
 	return 0;
 error:

commit 8ba69ce4b3567de881514c61ea8b04b14d8e68ae
Author: J. Ali Harlow <ali@avrc.city.ac.uk>
Date:   Wed May 18 19:18:56 2011 +0100

    comedi vmk80xx: support comedi auto-configuration
    
    Add support for automatically associating a vmk8055 device with a
    comedi device (previously the user had to use comedi_num_legacy_minors
    to reserve device slots and then associate them with vmk8055 devices
    using comedi_config).
    Tested on multiple K8055s, but not on K8061s.
    
    Signed-off-by: J. Ali Harlow <ali@avrc.city.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 04c085fd790d..3d13ca6e1670 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -64,6 +64,8 @@ Status: works
 
 #include "../comedidev.h"
 
+#define BOARDNAME "vmk80xx"
+
 MODULE_AUTHOR("Manuel Gebele <forensixs@gmx.de>");
 MODULE_DESCRIPTION("Velleman USB Board Low-Level Driver");
 MODULE_SUPPORTED_DEVICE("K8055/K8061 aka VM110/VM140");
@@ -1480,6 +1482,8 @@ static int vmk80xx_probe(struct usb_interface *intf,
 
 	mutex_unlock(&glb_mutex);
 
+	comedi_usb_auto_config(dev->udev, BOARDNAME);
+
 	return 0;
 error:
 	mutex_unlock(&glb_mutex);
@@ -1496,6 +1500,8 @@ static void vmk80xx_disconnect(struct usb_interface *intf)
 	if (!dev)
 		return;
 
+	comedi_usb_auto_unconfig(dev->udev);
+
 	mutex_lock(&glb_mutex);
 	down(&dev->limit_sem);
 
@@ -1533,10 +1539,16 @@ static struct comedi_driver driver_vmk80xx = {
 
 static int __init vmk80xx_init(void)
 {
+	int retval;
+
 	printk(KERN_INFO "vmk80xx: version 0.8.01 "
 	       "Manuel Gebele <forensixs@gmx.de>\n");
-	usb_register(&vmk80xx_driver);
-	return comedi_driver_register(&driver_vmk80xx);
+
+	retval = comedi_driver_register(&driver_vmk80xx);
+	if (retval < 0)
+		return retval;
+
+	return usb_register(&vmk80xx_driver);
 }
 
 static void __exit vmk80xx_exit(void)

commit c647ed568af52cc75ece267ff02937d9263d1d27
Author: J. Ali Harlow <ali@avrc.city.ac.uk>
Date:   Wed May 18 19:18:55 2011 +0100

    comedi vmk80xx: support bits instruction
    
    Calling comedi_dio_bifield2() returns EBUSY permanently. Implementing
    the insn_bits call fixes the problem and is good in its own right since
    one can then read and write to all the digitial lines at the same time.
    Tested on a K8055, but not on a K8061.
    
    Signed-off-by: J. Ali Harlow <ali@avrc.city.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 669ebf85f575..04c085fd790d 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -709,6 +709,50 @@ static int vmk80xx_ao_rinsn(struct comedi_device *cdev,
 	return n;
 }
 
+static int vmk80xx_di_bits(struct comedi_device *cdev,
+			   struct comedi_subdevice *s,
+			   struct comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *dev = cdev->private;
+	unsigned char *rx_buf;
+	int reg;
+	int retval;
+
+	dbgvm("vmk80xx: %s\n", __func__);
+
+	retval = rudimentary_check(dev, DIR_IN);
+	if (retval)
+		return retval;
+
+	down(&dev->limit_sem);
+
+	rx_buf = dev->usb_rx_buf;
+
+	if (dev->board.model == VMK8061_MODEL) {
+		reg = VMK8061_DI_REG;
+		dev->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
+	} else {
+		reg = VMK8055_DI_REG;
+	}
+
+	retval = vmk80xx_read_packet(dev);
+
+	if (!retval) {
+		if (dev->board.model == VMK8055_MODEL)
+			data[1] = (((rx_buf[reg] >> 4) & 0x03) |
+				  ((rx_buf[reg] << 2) & 0x04) |
+				  ((rx_buf[reg] >> 3) & 0x18));
+		else
+			data[1] = rx_buf[reg];
+
+		retval = 2;
+	}
+
+	up(&dev->limit_sem);
+
+	return retval;
+}
+
 static int vmk80xx_di_rinsn(struct comedi_device *cdev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
@@ -840,6 +884,73 @@ static int vmk80xx_do_rinsn(struct comedi_device *cdev,
 	return n;
 }
 
+static int vmk80xx_do_bits(struct comedi_device *cdev,
+			   struct comedi_subdevice *s,
+			   struct comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *dev = cdev->private;
+	unsigned char *rx_buf, *tx_buf;
+	int dir, reg, cmd;
+	int retval;
+
+	dbgvm("vmk80xx: %s\n", __func__);
+
+	dir = 0;
+
+	if (data[0])
+		dir |= DIR_OUT;
+
+	if (dev->board.model == VMK8061_MODEL)
+		dir |= DIR_IN;
+
+	retval = rudimentary_check(dev, dir);
+	if (retval)
+		return retval;
+
+	down(&dev->limit_sem);
+
+	rx_buf = dev->usb_rx_buf;
+	tx_buf = dev->usb_tx_buf;
+
+	if (data[0]) {
+		if (dev->board.model == VMK8055_MODEL) {
+			reg = VMK8055_DO_REG;
+			cmd = VMK8055_CMD_WRT_AD;
+		} else { /* VMK8061_MODEL */
+			reg = VMK8061_DO_REG;
+			cmd = VMK8061_CMD_DO;
+		}
+
+		tx_buf[reg] &= ~data[0];
+		tx_buf[reg] |= (data[0] & data[1]);
+
+		retval = vmk80xx_write_packet(dev, cmd);
+
+		if (retval)
+			goto out;
+	}
+
+	if (dev->board.model == VMK8061_MODEL) {
+		reg = VMK8061_DO_REG;
+		tx_buf[0] = VMK8061_CMD_RD_DO;
+
+		retval = vmk80xx_read_packet(dev);
+
+		if (!retval) {
+			data[1] = rx_buf[reg];
+			retval = 2;
+		}
+	} else {
+		data[1] = tx_buf[reg];
+		retval = 2;
+	}
+
+out:
+	up(&dev->limit_sem);
+
+	return retval;
+}
+
 static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
@@ -1139,6 +1250,7 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	s->n_chan = dev->board.di_chans;
 	s->maxdata = 1;
 	s->insn_read = vmk80xx_di_rinsn;
+	s->insn_bits = vmk80xx_di_bits;
 
 	/* Digital output subdevice */
 	s = cdev->subdevices + VMK80XX_SUBD_DO;
@@ -1147,6 +1259,7 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	s->n_chan = dev->board.do_chans;
 	s->maxdata = 1;
 	s->insn_write = vmk80xx_do_winsn;
+	s->insn_bits = vmk80xx_do_bits;
 
 	if (dev->board.model == VMK8061_MODEL) {
 		s->subdev_flags |= SDF_READABLE;

commit 510b9be374a4b589e7f6182d306b3c8ec9575e05
Author: J. Ali Harlow <ali@avrc.city.ac.uk>
Date:   Wed May 18 19:18:54 2011 +0100

    comedi vmk80xx: extend rudimentary_check to check both directions
    
    rudimentary_check() can currently check whether the input or
    output direction is currently available (no pending transaction),
    but not both at the same time. We need this facility for do_bits().
    
    Signed-off-by: J. Ali Harlow <ali@avrc.city.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index c86c8664101b..669ebf85f575 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -568,7 +568,8 @@ static int rudimentary_check(struct vmk80xx_usb *dev, int dir)
 	if (dir & DIR_IN) {
 		if (test_bit(TRANS_IN_BUSY, &dev->flags))
 			return -EBUSY;
-	} else {  /* DIR_OUT */
+	}
+	if (dir & DIR_OUT) {
 		if (test_bit(TRANS_OUT_BUSY, &dev->flags))
 			return -EBUSY;
 	}

commit 9dc99895ef2bd96bad9674e4a0a6228c0690c912
Author: J. Ali Harlow <ali@avrc.city.ac.uk>
Date:   Wed May 18 19:18:53 2011 +0100

    comedi vmk80xx: simplify rinsn output calculation
    
    vmk80xx_di_rinsn() and vmk80xx_do_rinsn() extract the required channel
    data by inconsistent and overly-complex algorithms. Simplify them both.
    
    Signed-off-by: J. Ali Harlow <ali@avrc.city.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 01cfb7695f7c..c86c8664101b 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -747,7 +747,7 @@ static int vmk80xx_di_rinsn(struct comedi_device *cdev,
 		else
 			inp = rx_buf[reg];
 
-		data[n] = ((inp & (1 << chan)) > 0);
+		data[n] = (inp >> chan) & 1;
 	}
 
 	up(&dev->limit_sem);
@@ -812,7 +812,6 @@ static int vmk80xx_do_rinsn(struct comedi_device *cdev,
 	struct vmk80xx_usb *dev = cdev->private;
 	int chan;
 	int reg;
-	int mask;
 	int n;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -825,7 +824,6 @@ static int vmk80xx_do_rinsn(struct comedi_device *cdev,
 	chan = CR_CHAN(insn->chanspec);
 
 	reg = VMK8061_DO_REG;
-	mask = 1 << chan;
 
 	dev->usb_tx_buf[0] = VMK8061_CMD_RD_DO;
 
@@ -833,7 +831,7 @@ static int vmk80xx_do_rinsn(struct comedi_device *cdev,
 		if (vmk80xx_read_packet(dev))
 			break;
 
-		data[n] = (dev->usb_rx_buf[reg] & mask) >> chan;
+		data[n] = (dev->usb_rx_buf[reg] >> chan) & 1;
 	}
 
 	up(&dev->limit_sem);

commit 85a2f34f4ecd48ce27f8ecc2d58ab66c05d55a9a
Author: J. Ali Harlow <ali@avrc.city.ac.uk>
Date:   Wed May 18 19:18:52 2011 +0100

    comedi vmk80xx: Digitial I/O should have a maxdata of 1
    
    Digitial input and output sub-devices were reporting a maxdata of
    0x1F and 0xFF respectively. They should both be 1.
    
    Signed-off-by: J. Ali Harlow <ali@avrc.city.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 5d83bb667144..01cfb7695f7c 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1138,7 +1138,7 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
 	s->n_chan = dev->board.di_chans;
-	s->maxdata = (1 << dev->board.di_bits) - 1;
+	s->maxdata = 1;
 	s->insn_read = vmk80xx_di_rinsn;
 
 	/* Digital output subdevice */
@@ -1146,7 +1146,7 @@ static int vmk80xx_attach(struct comedi_device *cdev,
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
 	s->n_chan = dev->board.do_chans;
-	s->maxdata = (1 << dev->board.do_bits) - 1;
+	s->maxdata = 1;
 	s->insn_write = vmk80xx_do_winsn;
 
 	if (dev->board.model == VMK8061_MODEL) {

commit 587e500c40aef11163bf09d367b5c3b3aba820cc
Author: J. Ali Harlow <ali@avrc.city.ac.uk>
Date:   Wed May 18 19:18:51 2011 +0100

    comedi vmk80xx: make rudimentary_check a static function
    
    rudimentary_check is a macro with side-effects (it returns
    on error) which is contary to CodingStyle. Replace it with
    a static function.
    
    Signed-off-by: J. Ali Harlow <ali@avrc.city.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index e4751334c563..5d83bb667144 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -557,22 +557,24 @@ static int vmk80xx_write_packet(struct vmk80xx_usb *dev, int cmd)
 #define DIR_IN  1
 #define DIR_OUT 2
 
-#define rudimentary_check(dir)                             \
-do {                                                       \
-	if (!dev)                                          \
-		return -EFAULT;                            \
-	if (!dev->probed)                                  \
-		return -ENODEV;                            \
-	if (!dev->attached)                                \
-		return -ENODEV;                            \
-	if ((dir) & DIR_IN) {                              \
-		if (test_bit(TRANS_IN_BUSY, &dev->flags))  \
-			return -EBUSY;                     \
-	} else {  /* DIR_OUT */                            \
-		if (test_bit(TRANS_OUT_BUSY, &dev->flags)) \
-			return -EBUSY;                     \
-	}                                                  \
-} while (0)
+static int rudimentary_check(struct vmk80xx_usb *dev, int dir)
+{
+	if (!dev)
+		return -EFAULT;
+	if (!dev->probed)
+		return -ENODEV;
+	if (!dev->attached)
+		return -ENODEV;
+	if (dir & DIR_IN) {
+		if (test_bit(TRANS_IN_BUSY, &dev->flags))
+			return -EBUSY;
+	} else {  /* DIR_OUT */
+		if (test_bit(TRANS_OUT_BUSY, &dev->flags))
+			return -EBUSY;
+	}
+
+	return 0;
+}
 
 static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
 			    struct comedi_subdevice *s,
@@ -585,7 +587,9 @@ static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
 
 	dbgvm("vmk80xx: %s\n", __func__);
 
-	rudimentary_check(DIR_IN);
+	n = rudimentary_check(dev, DIR_IN);
+	if (n)
+		return n;
 
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
@@ -636,7 +640,9 @@ static int vmk80xx_ao_winsn(struct comedi_device *cdev,
 
 	dbgvm("vmk80xx: %s\n", __func__);
 
-	rudimentary_check(DIR_OUT);
+	n = rudimentary_check(dev, DIR_OUT);
+	if (n)
+		return n;
 
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
@@ -679,7 +685,9 @@ static int vmk80xx_ao_rinsn(struct comedi_device *cdev,
 
 	dbgvm("vmk80xx: %s\n", __func__);
 
-	rudimentary_check(DIR_IN);
+	n = rudimentary_check(dev, DIR_IN);
+	if (n)
+		return n;
 
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
@@ -713,7 +721,9 @@ static int vmk80xx_di_rinsn(struct comedi_device *cdev,
 
 	dbgvm("vmk80xx: %s\n", __func__);
 
-	rudimentary_check(DIR_IN);
+	n = rudimentary_check(dev, DIR_IN);
+	if (n)
+		return n;
 
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
@@ -758,7 +768,9 @@ static int vmk80xx_do_winsn(struct comedi_device *cdev,
 
 	dbgvm("vmk80xx: %s\n", __func__);
 
-	rudimentary_check(DIR_OUT);
+	n = rudimentary_check(dev, DIR_OUT);
+	if (n)
+		return n;
 
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
@@ -805,7 +817,9 @@ static int vmk80xx_do_rinsn(struct comedi_device *cdev,
 
 	dbgvm("vmk80xx: %s\n", __func__);
 
-	rudimentary_check(DIR_IN);
+	n = rudimentary_check(dev, DIR_IN);
+	if (n)
+		return n;
 
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
@@ -838,7 +852,9 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 
 	dbgvm("vmk80xx: %s\n", __func__);
 
-	rudimentary_check(DIR_IN);
+	n = rudimentary_check(dev, DIR_IN);
+	if (n)
+		return n;
 
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
@@ -886,7 +902,9 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *cdev,
 
 	dbgvm("vmk80xx: %s\n", __func__);
 
-	rudimentary_check(DIR_OUT);
+	n = rudimentary_check(dev, DIR_OUT);
+	if (n)
+		return n;
 
 	down(&dev->limit_sem);
 
@@ -932,7 +950,9 @@ static int vmk80xx_cnt_winsn(struct comedi_device *cdev,
 
 	dbgvm("vmk80xx: %s\n", __func__);
 
-	rudimentary_check(DIR_OUT);
+	n = rudimentary_check(dev, DIR_OUT);
+	if (n)
+		return n;
 
 	down(&dev->limit_sem);
 	chan = CR_CHAN(insn->chanspec);
@@ -976,7 +996,9 @@ static int vmk80xx_pwm_rinsn(struct comedi_device *cdev,
 
 	dbgvm("vmk80xx: %s\n", __func__);
 
-	rudimentary_check(DIR_IN);
+	n = rudimentary_check(dev, DIR_IN);
+	if (n)
+		return n;
 
 	down(&dev->limit_sem);
 
@@ -1009,7 +1031,9 @@ static int vmk80xx_pwm_winsn(struct comedi_device *cdev,
 
 	dbgvm("vmk80xx: %s\n", __func__);
 
-	rudimentary_check(DIR_OUT);
+	n = rudimentary_check(dev, DIR_OUT);
+	if (n)
+		return n;
 
 	down(&dev->limit_sem);
 

commit 3a229fd54db17f39ce14348c9de898b3671771ca
Author: J. Ali Harlow <ali@avrc.city.ac.uk>
Date:   Thu May 12 19:09:57 2011 +0100

    comedi vmk80xx: Style improvements
    
    Style improvements to comedi driver vmk80xx:
     * One variable definition per line
     * Block quotes start and end with near-empty lines
     * If..else statements use braces for both branches
     * Egregious blank lines removed
     * Use if..else rather than goto where trivial
     * Don't put function return type on a separate line
    
    Signed-off-by: J. Ali Harlow <ali@avrc.city.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 6479c38d0278..e4751334c563 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -305,8 +305,10 @@ static void vmk80xx_rx_callback(struct urb *urb)
 
 static int vmk80xx_check_data_link(struct vmk80xx_usb *dev)
 {
-	unsigned int tx_pipe, rx_pipe;
-	unsigned char tx[1], rx[2];
+	unsigned int tx_pipe;
+	unsigned int rx_pipe;
+	unsigned char tx[1];
+	unsigned char rx[2];
 
 	dbgvm("vmk80xx: %s\n", __func__);
 
@@ -315,9 +317,11 @@ static int vmk80xx_check_data_link(struct vmk80xx_usb *dev)
 
 	tx[0] = VMK8061_CMD_RD_PWR_STAT;
 
-	/* Check that IC6 (PIC16F871) is powered and
+	/*
+	 * Check that IC6 (PIC16F871) is powered and
 	 * running and the data link between IC3 and
-	 * IC6 is working properly */
+	 * IC6 is working properly
+	 */
 	usb_bulk_msg(dev->udev, tx_pipe, tx, 1, NULL, dev->ep_tx->bInterval);
 	usb_bulk_msg(dev->udev, rx_pipe, rx, 2, NULL, HZ * 10);
 
@@ -326,8 +330,10 @@ static int vmk80xx_check_data_link(struct vmk80xx_usb *dev)
 
 static void vmk80xx_read_eeprom(struct vmk80xx_usb *dev, int flag)
 {
-	unsigned int tx_pipe, rx_pipe;
-	unsigned char tx[1], rx[64];
+	unsigned int tx_pipe;
+	unsigned int rx_pipe;
+	unsigned char tx[1];
+	unsigned char rx[64];
 	int cnt;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -337,8 +343,10 @@ static void vmk80xx_read_eeprom(struct vmk80xx_usb *dev, int flag)
 
 	tx[0] = VMK8061_CMD_RD_VERSION;
 
-	/* Read the firmware version info of IC3 and
-	 * IC6 from the internal EEPROM of the IC */
+	/*
+	 * Read the firmware version info of IC3 and
+	 * IC6 from the internal EEPROM of the IC
+	 */
 	usb_bulk_msg(dev->udev, tx_pipe, tx, 1, NULL, dev->ep_tx->bInterval);
 	usb_bulk_msg(dev->udev, rx_pipe, rx, 64, &cnt, HZ * 10);
 
@@ -388,7 +396,8 @@ static int vmk80xx_reset_device(struct vmk80xx_usb *dev)
 static void vmk80xx_build_int_urb(struct urb *urb, int flag)
 {
 	struct vmk80xx_usb *dev = urb->context;
-	__u8 rx_addr, tx_addr;
+	__u8 rx_addr;
+	__u8 tx_addr;
 	unsigned int pipe;
 	unsigned char *buf;
 	size_t size;
@@ -418,8 +427,10 @@ static void vmk80xx_build_int_urb(struct urb *urb, int flag)
 
 static void vmk80xx_do_bulk_msg(struct vmk80xx_usb *dev)
 {
-	__u8 tx_addr, rx_addr;
-	unsigned int tx_pipe, rx_pipe;
+	__u8 tx_addr;
+	__u8 rx_addr;
+	unsigned int tx_pipe;
+	unsigned int rx_pipe;
 	size_t size;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -432,8 +443,10 @@ static void vmk80xx_do_bulk_msg(struct vmk80xx_usb *dev)
 	tx_pipe = usb_sndbulkpipe(dev->udev, tx_addr);
 	rx_pipe = usb_rcvbulkpipe(dev->udev, rx_addr);
 
-	/* The max packet size attributes of the K8061
-	 * input/output endpoints are identical */
+	/*
+	 * The max packet size attributes of the K8061
+	 * input/output endpoints are identical
+	 */
 	size = le16_to_cpu(dev->ep_tx->wMaxPacketSize);
 
 	usb_bulk_msg(dev->udev, tx_pipe, dev->usb_tx_buf,
@@ -566,7 +579,8 @@ static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
 			    struct comedi_insn *insn, unsigned int *data)
 {
 	struct vmk80xx_usb *dev = cdev->private;
-	int chan, reg[2];
+	int chan;
+	int reg[2];
 	int n;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -615,7 +629,9 @@ static int vmk80xx_ao_winsn(struct comedi_device *cdev,
 			    struct comedi_insn *insn, unsigned int *data)
 {
 	struct vmk80xx_usb *dev = cdev->private;
-	int chan, cmd, reg;
+	int chan;
+	int cmd;
+	int reg;
 	int n;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -657,7 +673,8 @@ static int vmk80xx_ao_rinsn(struct comedi_device *cdev,
 			    struct comedi_insn *insn, unsigned int *data)
 {
 	struct vmk80xx_usb *dev = cdev->private;
-	int chan, reg;
+	int chan;
+	int reg;
 	int n;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -690,7 +707,8 @@ static int vmk80xx_di_rinsn(struct comedi_device *cdev,
 	struct vmk80xx_usb *dev = cdev->private;
 	int chan;
 	unsigned char *rx_buf;
-	int reg, inp;
+	int reg;
+	int inp;
 	int n;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -705,9 +723,9 @@ static int vmk80xx_di_rinsn(struct comedi_device *cdev,
 	if (dev->board.model == VMK8061_MODEL) {
 		reg = VMK8061_DI_REG;
 		dev->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
-	} else
+	} else {
 		reg = VMK8055_DI_REG;
-
+	}
 	for (n = 0; n < insn->n; n++) {
 		if (vmk80xx_read_packet(dev))
 			break;
@@ -731,11 +749,11 @@ static int vmk80xx_do_winsn(struct comedi_device *cdev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-
 	struct vmk80xx_usb *dev = cdev->private;
 	int chan;
 	unsigned char *tx_buf;
-	int reg, cmd;
+	int reg;
+	int cmd;
 	int n;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -755,21 +773,17 @@ static int vmk80xx_do_winsn(struct comedi_device *cdev,
 				tx_buf[reg] |= (1 << chan);
 			else
 				tx_buf[reg] ^= (1 << chan);
-
-			goto write_packet;
-		}
-
-		/* VMK8061_MODEL */
-		reg = VMK8061_DO_REG;
-		if (data[n] == 1) {
-			cmd = VMK8061_CMD_SET_DO;
-			tx_buf[reg] = 1 << chan;
-		} else {
-			cmd = VMK8061_CMD_CLR_DO;
-			tx_buf[reg] = 0xff - (1 << chan);
+		} else { /* VMK8061_MODEL */
+			reg = VMK8061_DO_REG;
+			if (data[n] == 1) {
+				cmd = VMK8061_CMD_SET_DO;
+				tx_buf[reg] = 1 << chan;
+			} else {
+				cmd = VMK8061_CMD_CLR_DO;
+				tx_buf[reg] = 0xff - (1 << chan);
+			}
 		}
 
-write_packet:
 		if (vmk80xx_write_packet(dev, cmd))
 			break;
 	}
@@ -784,7 +798,9 @@ static int vmk80xx_do_rinsn(struct comedi_device *cdev,
 			    struct comedi_insn *insn, unsigned int *data)
 {
 	struct vmk80xx_usb *dev = cdev->private;
-	int chan, reg, mask;
+	int chan;
+	int reg;
+	int mask;
 	int n;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -816,7 +832,8 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 			     struct comedi_insn *insn, unsigned int *data)
 {
 	struct vmk80xx_usb *dev = cdev->private;
-	int chan, reg[2];
+	int chan;
+	int reg[2];
 	int n;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -844,14 +861,11 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 		if (vmk80xx_read_packet(dev))
 			break;
 
-		if (dev->board.model == VMK8055_MODEL) {
+		if (dev->board.model == VMK8055_MODEL)
 			data[n] = dev->usb_rx_buf[reg[0]];
-			continue;
-		}
-
-		/* VMK8061_MODEL */
-		data[n] = dev->usb_rx_buf[reg[0] * (chan + 1) + 1]
-		    + 256 * dev->usb_rx_buf[reg[1] * 2 + 2];
+		else /* VMK8061_MODEL */
+			data[n] = dev->usb_rx_buf[reg[0] * (chan + 1) + 1]
+			    + 256 * dev->usb_rx_buf[reg[1] * 2 + 2];
 	}
 
 	up(&dev->limit_sem);
@@ -865,7 +879,9 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *cdev,
 {
 	struct vmk80xx_usb *dev = cdev->private;
 	unsigned int insn_cmd;
-	int chan, cmd, reg;
+	int chan;
+	int cmd;
+	int reg;
 	int n;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -890,8 +906,9 @@ static int vmk80xx_cnt_cinsn(struct comedi_device *cdev,
 		}
 
 		dev->usb_tx_buf[reg] = 0x00;
-	} else
+	} else {
 		cmd = VMK8061_CMD_RST_CNT;
+	}
 
 	for (n = 0; n < insn->n; n++)
 		if (vmk80xx_write_packet(dev, cmd))
@@ -907,8 +924,10 @@ static int vmk80xx_cnt_winsn(struct comedi_device *cdev,
 			     struct comedi_insn *insn, unsigned int *data)
 {
 	struct vmk80xx_usb *dev = cdev->private;
-	unsigned long debtime, val;
-	int chan, cmd;
+	unsigned long debtime;
+	unsigned long val;
+	int chan;
+	int cmd;
 	int n;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -984,7 +1003,8 @@ static int vmk80xx_pwm_winsn(struct comedi_device *cdev,
 {
 	struct vmk80xx_usb *dev = cdev->private;
 	unsigned char *tx_buf;
-	int reg[2], cmd;
+	int reg[2];
+	int cmd;
 	int n;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -1026,8 +1046,8 @@ static int vmk80xx_pwm_winsn(struct comedi_device *cdev,
 	return n;
 }
 
-static int
-vmk80xx_attach(struct comedi_device *cdev, struct comedi_devconfig *it)
+static int vmk80xx_attach(struct comedi_device *cdev,
+			  struct comedi_devconfig *it)
 {
 	int i;
 	struct vmk80xx_usb *dev;
@@ -1179,8 +1199,8 @@ static int vmk80xx_detach(struct comedi_device *cdev)
 	return 0;
 }
 
-static int
-vmk80xx_probe(struct usb_interface *intf, const struct usb_device_id *id)
+static int vmk80xx_probe(struct usb_interface *intf,
+			 const struct usb_device_id *id)
 {
 	int i;
 	struct vmk80xx_usb *dev;
@@ -1309,8 +1329,9 @@ vmk80xx_probe(struct usb_interface *intf, const struct usb_device_id *id)
 			vmk80xx_read_eeprom(dev, IC6_VERSION);
 			printk(KERN_INFO "comedi#: vmk80xx: %s\n",
 			       dev->fw.ic6_vers);
-		} else
+		} else {
 			dbgcm("comedi#: vmk80xx: no conn. to CPU\n");
+		}
 	}
 
 	if (dev->board.model == VMK8055_MODEL)

commit a457732b836b970c82c7ba35b4cfc938c9c543f9
Author: Nmeth Mrton <nm127@freemail.hu>
Date:   Sun Jan 10 00:18:34 2010 +0100

    staging: make USB device id constant
    
    The id_table field of the struct usb_device_id is constant in <linux/usb.h>
    so it is worth to make the initialization data also constant.
    
    The semantic match that finds this kind of pattern is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    disable decl_init,const_decl_init;
    identifier I1, I2, x;
    @@
            struct I1 {
              ...
              const struct I2 *x;
              ...
            };
    @s@
    identifier r.I1, y;
    identifier r.x, E;
    @@
            struct I1 y = {
              .x = E,
            };
    @c@
    identifier r.I2;
    identifier s.E;
    @@
            const struct I2 E[] = ... ;
    @depends on !c@
    identifier r.I2;
    identifier s.E;
    @@
    +       const
            struct I2 E[] = ...;
    // </smpl>
    
    Signed-off-by: Nmeth Mrton <nm127@freemail.hu>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: cocci@diku.dk
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index c34a0b9141e2..6479c38d0278 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -75,7 +75,7 @@ enum {
 	DEVICE_VMK8061
 };
 
-static struct usb_device_id vmk80xx_id_table[] = {
+static const struct usb_device_id vmk80xx_id_table[] = {
 	{USB_DEVICE(0x10cf, 0x5500), .driver_info = DEVICE_VMK8055},
 	{USB_DEVICE(0x10cf, 0x5501), .driver_info = DEVICE_VMK8055},
 	{USB_DEVICE(0x10cf, 0x5502), .driver_info = DEVICE_VMK8055},

commit 6dd60bc62988fab9977b7fd0cd14eedc6e27eecd
Author: Bruce Jones <brucej97223@gmail.com>
Date:   Thu Sep 24 15:39:52 2009 -0700

    Staging: comedi: vmk80xx: cleanup formatting
    
    Clean up formatting of a struct initializer, as per the
    standard conventions.
    
    Signed-off-by: Bruce Jones <brucej@linux.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index c335040778f0..c34a0b9141e2 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -76,18 +76,18 @@ enum {
 };
 
 static struct usb_device_id vmk80xx_id_table[] = {
-	{USB_DEVICE(0x10cf, 0x5500),.driver_info = DEVICE_VMK8055},
-	{USB_DEVICE(0x10cf, 0x5501),.driver_info = DEVICE_VMK8055},
-	{USB_DEVICE(0x10cf, 0x5502),.driver_info = DEVICE_VMK8055},
-	{USB_DEVICE(0x10cf, 0x5503),.driver_info = DEVICE_VMK8055},
-	{USB_DEVICE(0x10cf, 0x8061),.driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8062),.driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8063),.driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8064),.driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8065),.driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8066),.driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8067),.driver_info = DEVICE_VMK8061},
-	{USB_DEVICE(0x10cf, 0x8068),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x5500), .driver_info = DEVICE_VMK8055},
+	{USB_DEVICE(0x10cf, 0x5501), .driver_info = DEVICE_VMK8055},
+	{USB_DEVICE(0x10cf, 0x5502), .driver_info = DEVICE_VMK8055},
+	{USB_DEVICE(0x10cf, 0x5503), .driver_info = DEVICE_VMK8055},
+	{USB_DEVICE(0x10cf, 0x8061), .driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8062), .driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8063), .driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8064), .driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8065), .driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8066), .driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8067), .driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8068), .driver_info = DEVICE_VMK8061},
 	{}			/* terminating entry */
 };
 

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 9de43b5310d7..c335040778f0 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -76,19 +76,19 @@ enum {
 };
 
 static struct usb_device_id vmk80xx_id_table[] = {
-	{ USB_DEVICE(0x10cf, 0x5500), .driver_info = DEVICE_VMK8055 },
-	{ USB_DEVICE(0x10cf, 0x5501), .driver_info = DEVICE_VMK8055 },
-	{ USB_DEVICE(0x10cf, 0x5502), .driver_info = DEVICE_VMK8055 },
-	{ USB_DEVICE(0x10cf, 0x5503), .driver_info = DEVICE_VMK8055 },
-	{ USB_DEVICE(0x10cf, 0x8061), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8062), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8063), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8064), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8065), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8066), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8067), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8068), .driver_info = DEVICE_VMK8061 },
-	{ } /* terminating entry */
+	{USB_DEVICE(0x10cf, 0x5500),.driver_info = DEVICE_VMK8055},
+	{USB_DEVICE(0x10cf, 0x5501),.driver_info = DEVICE_VMK8055},
+	{USB_DEVICE(0x10cf, 0x5502),.driver_info = DEVICE_VMK8055},
+	{USB_DEVICE(0x10cf, 0x5503),.driver_info = DEVICE_VMK8055},
+	{USB_DEVICE(0x10cf, 0x8061),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8062),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8063),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8064),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8065),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8066),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8067),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8068),.driver_info = DEVICE_VMK8061},
+	{}			/* terminating entry */
 };
 
 MODULE_DEVICE_TABLE(usb, vmk80xx_id_table);
@@ -120,19 +120,19 @@ MODULE_DEVICE_TABLE(usb, vmk80xx_id_table);
 #define VMK8055_CMD_WRT_AD      0x05
 
 #define VMK8061_CMD_RD_AI       0x00
-#define VMK8061_CMR_RD_ALL_AI   0x01    /* !non-active! */
+#define VMK8061_CMR_RD_ALL_AI   0x01	/* !non-active! */
 #define VMK8061_CMD_SET_AO      0x02
-#define VMK8061_CMD_SET_ALL_AO  0x03    /* !non-active! */
+#define VMK8061_CMD_SET_ALL_AO  0x03	/* !non-active! */
 #define VMK8061_CMD_OUT_PWM     0x04
 #define VMK8061_CMD_RD_DI       0x05
-#define VMK8061_CMD_DO          0x06    /* !non-active! */
+#define VMK8061_CMD_DO          0x06	/* !non-active! */
 #define VMK8061_CMD_CLR_DO      0x07
 #define VMK8061_CMD_SET_DO      0x08
-#define VMK8061_CMD_RD_CNT      0x09    /* TODO: completely pointless? */
-#define VMK8061_CMD_RST_CNT     0x0a    /* TODO: completely pointless? */
-#define VMK8061_CMD_RD_VERSION  0x0b    /* internal usage */
-#define VMK8061_CMD_RD_JMP_STAT 0x0c    /* TODO: not implemented yet */
-#define VMK8061_CMD_RD_PWR_STAT 0x0d    /* internal usage */
+#define VMK8061_CMD_RD_CNT      0x09	/* TODO: completely pointless? */
+#define VMK8061_CMD_RST_CNT     0x0a	/* TODO: completely pointless? */
+#define VMK8061_CMD_RD_VERSION  0x0b	/* internal usage */
+#define VMK8061_CMD_RD_JMP_STAT 0x0c	/* TODO: not implemented yet */
+#define VMK8061_CMD_RD_PWR_STAT 0x0d	/* internal usage */
 #define VMK8061_CMD_RD_DO       0x0e
 #define VMK8061_CMD_RD_AO       0x0f
 #define VMK8061_CMD_RD_PWM      0x10
@@ -153,15 +153,15 @@ MODULE_DEVICE_TABLE(usb, vmk80xx_id_table);
 #undef CONFIG_VMK80XX_DEBUG
 
 #ifdef CONFIG_VMK80XX_DEBUG
- static int dbgvm = 1;
+static int dbgvm = 1;
 #else
- static int dbgvm;
+static int dbgvm;
 #endif
 
 #ifdef CONFIG_COMEDI_DEBUG
- static int dbgcm = 1;
+static int dbgcm = 1;
 #else
- static int dbgcm;
+static int dbgcm;
 #endif
 
 #define dbgvm(fmt, arg...)                     \
@@ -182,33 +182,33 @@ enum vmk80xx_model {
 };
 
 struct firmware_version {
-	unsigned char ic3_vers[32]; /* USB-Controller */
-	unsigned char ic6_vers[32]; /* CPU */
+	unsigned char ic3_vers[32];	/* USB-Controller */
+	unsigned char ic6_vers[32];	/* CPU */
 };
 
 static const struct comedi_lrange vmk8055_range = {
-	1, { UNI_RANGE(5) }
+	1, {UNI_RANGE(5)}
 };
 
 static const struct comedi_lrange vmk8061_range = {
-	2, { UNI_RANGE(5), UNI_RANGE(10) }
+	2, {UNI_RANGE(5), UNI_RANGE(10)}
 };
 
 struct vmk80xx_board {
 	const char *name;
 	enum vmk80xx_model model;
 	const struct comedi_lrange *range;
-	__u8   ai_chans;
+	__u8 ai_chans;
 	__le16 ai_bits;
-	__u8   ao_chans;
+	__u8 ao_chans;
 	__le16 ao_bits;
-	__u8   di_chans;
+	__u8 di_chans;
 	__le16 di_bits;
-	__u8   do_chans;
+	__u8 do_chans;
 	__le16 do_bits;
-	__u8   cnt_chans;
+	__u8 cnt_chans;
 	__le16 cnt_bits;
-	__u8   pwm_chans;
+	__u8 pwm_chans;
 	__le16 pwm_bits;
 };
 
@@ -253,8 +253,7 @@ static void vmk80xx_tx_callback(struct urb *urb)
 	dbgvm("vmk80xx: %s\n", __func__);
 
 	if (stat && !(stat == -ENOENT
-		 ||   stat == -ECONNRESET
-		 ||   stat == -ESHUTDOWN))
+		      || stat == -ECONNRESET || stat == -ESHUTDOWN))
 		dbgcm("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",
 		      __func__, stat);
 
@@ -319,10 +318,8 @@ static int vmk80xx_check_data_link(struct vmk80xx_usb *dev)
 	/* Check that IC6 (PIC16F871) is powered and
 	 * running and the data link between IC3 and
 	 * IC6 is working properly */
-	usb_bulk_msg(dev->udev, tx_pipe, tx, 1, NULL,
-		     dev->ep_tx->bInterval);
-	usb_bulk_msg(dev->udev, rx_pipe, rx, 2, NULL,
-		     HZ * 10);
+	usb_bulk_msg(dev->udev, tx_pipe, tx, 1, NULL, dev->ep_tx->bInterval);
+	usb_bulk_msg(dev->udev, rx_pipe, rx, 2, NULL, HZ * 10);
 
 	return (int)rx[1];
 }
@@ -342,16 +339,14 @@ static void vmk80xx_read_eeprom(struct vmk80xx_usb *dev, int flag)
 
 	/* Read the firmware version info of IC3 and
 	 * IC6 from the internal EEPROM of the IC */
-	usb_bulk_msg(dev->udev, tx_pipe, tx,  1, NULL,
-		     dev->ep_tx->bInterval);
-	usb_bulk_msg(dev->udev, rx_pipe, rx, 64, &cnt,
-		     HZ * 10);
+	usb_bulk_msg(dev->udev, tx_pipe, tx, 1, NULL, dev->ep_tx->bInterval);
+	usb_bulk_msg(dev->udev, rx_pipe, rx, 64, &cnt, HZ * 10);
 
 	rx[cnt] = '\0';
 
 	if (flag & IC3_VERSION)
-		strncpy(dev->fw.ic3_vers, rx +  1, 24);
-	else /* IC6_VERSION */
+		strncpy(dev->fw.ic3_vers, rx + 1, 24);
+	else			/* IC6_VERSION */
 		strncpy(dev->fw.ic6_vers, rx + 25, 24);
 }
 
@@ -397,7 +392,7 @@ static void vmk80xx_build_int_urb(struct urb *urb, int flag)
 	unsigned int pipe;
 	unsigned char *buf;
 	size_t size;
-	void (*callback)(struct urb *);
+	void (*callback) (struct urb *);
 	int ival;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -409,7 +404,7 @@ static void vmk80xx_build_int_urb(struct urb *urb, int flag)
 		size = le16_to_cpu(dev->ep_rx->wMaxPacketSize);
 		callback = vmk80xx_rx_callback;
 		ival = dev->ep_rx->bInterval;
-	} else { /* URB_SND_FLAG */
+	} else {		/* URB_SND_FLAG */
 		tx_addr = dev->ep_tx->bEndpointAddress;
 		pipe = usb_sndintpipe(dev->udev, tx_addr);
 		buf = dev->usb_tx_buf;
@@ -418,8 +413,7 @@ static void vmk80xx_build_int_urb(struct urb *urb, int flag)
 		ival = dev->ep_tx->bInterval;
 	}
 
-	usb_fill_int_urb(urb, dev->udev, pipe, buf,
-			 size, callback, dev, ival);
+	usb_fill_int_urb(urb, dev->udev, pipe, buf, size, callback, dev, ival);
 }
 
 static void vmk80xx_do_bulk_msg(struct vmk80xx_usb *dev)
@@ -444,8 +438,7 @@ static void vmk80xx_do_bulk_msg(struct vmk80xx_usb *dev)
 
 	usb_bulk_msg(dev->udev, tx_pipe, dev->usb_tx_buf,
 		     size, NULL, dev->ep_tx->bInterval);
-	usb_bulk_msg(dev->udev, rx_pipe, dev->usb_rx_buf,
-		     size, NULL, HZ * 10);
+	usb_bulk_msg(dev->udev, rx_pipe, dev->usb_rx_buf, size, NULL, HZ * 10);
 
 	clear_bit(TRANS_OUT_BUSY, &dev->flags);
 	clear_bit(TRANS_IN_BUSY, &dev->flags);
@@ -464,7 +457,8 @@ static int vmk80xx_read_packet(struct vmk80xx_usb *dev)
 	/* Only useful for interrupt transfers */
 	if (test_bit(TRANS_IN_BUSY, &dev->flags))
 		if (wait_event_interruptible(dev->read_wait,
-			!test_bit(TRANS_IN_BUSY, &dev->flags)))
+					     !test_bit(TRANS_IN_BUSY,
+						       &dev->flags)))
 			return -ERESTART;
 
 	if (dev->board.model == VMK8061_MODEL) {
@@ -510,7 +504,8 @@ static int vmk80xx_write_packet(struct vmk80xx_usb *dev, int cmd)
 
 	if (test_bit(TRANS_OUT_BUSY, &dev->flags))
 		if (wait_event_interruptible(dev->write_wait,
-			!test_bit(TRANS_OUT_BUSY, &dev->flags)))
+					     !test_bit(TRANS_OUT_BUSY,
+						       &dev->flags)))
 			return -ERESTART;
 
 	if (dev->board.model == VMK8061_MODEL) {
@@ -607,7 +602,7 @@ static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
 
 		/* VMK8061_MODEL */
 		data[n] = dev->usb_rx_buf[reg[0]] + 256 *
-			  dev->usb_rx_buf[reg[1]];
+		    dev->usb_rx_buf[reg[1]];
 	}
 
 	up(&dev->limit_sem);
@@ -638,7 +633,7 @@ static int vmk80xx_ao_winsn(struct comedi_device *cdev,
 		else
 			reg = VMK8055_AO2_REG;
 		break;
-	default: /* NOTE: avoid compiler warnings */
+	default:		/* NOTE: avoid compiler warnings */
 		cmd = VMK8061_CMD_SET_AO;
 		reg = VMK8061_AO_REG;
 		dev->usb_tx_buf[VMK8061_CH_REG] = chan;
@@ -680,7 +675,7 @@ static int vmk80xx_ao_rinsn(struct comedi_device *cdev,
 		if (vmk80xx_read_packet(dev))
 			break;
 
-		data[n] = dev->usb_rx_buf[reg+chan];
+		data[n] = dev->usb_rx_buf[reg + chan];
 	}
 
 	up(&dev->limit_sem);
@@ -855,8 +850,8 @@ static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
 		}
 
 		/* VMK8061_MODEL */
-		data[n] = dev->usb_rx_buf[reg[0]*(chan+1)+1]
-		  + 256 * dev->usb_rx_buf[reg[1]*2+2];
+		data[n] = dev->usb_rx_buf[reg[0] * (chan + 1) + 1]
+		    + 256 * dev->usb_rx_buf[reg[1] * 2 + 2];
 	}
 
 	up(&dev->limit_sem);
@@ -941,7 +936,7 @@ static int vmk80xx_cnt_winsn(struct comedi_device *cdev,
 		if (((val + 1) * val) < debtime * 1000 / 115)
 			val += 1;
 
-		dev->usb_tx_buf[6+chan] = val;
+		dev->usb_tx_buf[6 + chan] = val;
 
 		if (vmk80xx_write_packet(dev, cmd))
 			break;
@@ -975,8 +970,7 @@ static int vmk80xx_pwm_rinsn(struct comedi_device *cdev,
 		if (vmk80xx_read_packet(dev))
 			break;
 
-		data[n] = dev->usb_rx_buf[reg[0]] + 4 *
-			  dev->usb_rx_buf[reg[1]];
+		data[n] = dev->usb_rx_buf[reg[0]] + 4 * dev->usb_rx_buf[reg[1]];
 	}
 
 	up(&dev->limit_sem);
@@ -1309,8 +1303,7 @@ vmk80xx_probe(struct usb_interface *intf, const struct usb_device_id *id)
 
 	if (dev->board.model == VMK8061_MODEL) {
 		vmk80xx_read_eeprom(dev, IC3_VERSION);
-		printk(KERN_INFO "comedi#: vmk80xx: %s\n",
-		       dev->fw.ic3_vers);
+		printk(KERN_INFO "comedi#: vmk80xx: %s\n", dev->fw.ic3_vers);
 
 		if (vmk80xx_check_data_link(dev)) {
 			vmk80xx_read_eeprom(dev, IC6_VERSION);
@@ -1368,17 +1361,17 @@ static void vmk80xx_disconnect(struct usb_interface *intf)
 /* TODO: Add support for suspend, resume, pre_reset,
  * post_reset and flush */
 static struct usb_driver vmk80xx_driver = {
-	.name       = "vmk80xx",
-	.probe      = vmk80xx_probe,
+	.name = "vmk80xx",
+	.probe = vmk80xx_probe,
 	.disconnect = vmk80xx_disconnect,
-	.id_table   = vmk80xx_id_table
+	.id_table = vmk80xx_id_table
 };
 
 static struct comedi_driver driver_vmk80xx = {
-	.module      = THIS_MODULE,
+	.module = THIS_MODULE,
 	.driver_name = "vmk80xx",
-	.attach      = vmk80xx_attach,
-	.detach      = vmk80xx_detach
+	.attach = vmk80xx_attach,
+	.detach = vmk80xx_detach
 };
 
 static int __init vmk80xx_init(void)

commit 985cafccbf9b7f862aa1c5ee566801e18b5161fb
Author: Manuel Gebele <forensixs@gmx.de>
Date:   Sun May 10 12:00:43 2009 +0200

    Staging: Comedi: vmk80xx: Add k8061 support
    
    This patch adds support for the Velleman K8061 USB board
            http://www.velleman.be/ot/en/product/view/?id=364910
    
    
    Signed-off-by: Manuel Gebele <forensixs@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 533b625021ad..9de43b5310d7 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -1,6 +1,6 @@
 /*
     comedi/drivers/vmk80xx.c
-    Velleman USB Interface Board Kernel-Space Driver
+    Velleman USB Board Low-Level Driver
 
     Copyright (C) 2009 Manuel Gebele <forensixs@gmx.de>, Germany
 
@@ -24,11 +24,32 @@
 */
 /*
 Driver: vmk80xx
-Description: Velleman USB Interface Board Kernel-Space Driver
-Devices: K8055, K8061 (in development)
+Description: Velleman USB Board Low-Level Driver
+Devices: K8055/K8061 aka VM110/VM140
 Author: Manuel Gebele <forensixs@gmx.de>
-Updated: Tue, 21 Apr 2009 19:40:55 +0200
+Updated: Sun, 10 May 2009 11:14:59 +0200
 Status: works
+
+Supports:
+ - analog input
+ - analog output
+ - digital input
+ - digital output
+ - counter
+ - pwm
+*/
+/*
+Changelog:
+
+0.8.81	-3-  code completely rewritten (adjust driver logic)
+0.8.81  -2-  full support for K8061
+0.8.81  -1-  fix some mistaken among others the number of
+	     supported boards and I/O handling
+
+0.7.76  -4-  renamed to vmk80xx
+0.7.76  -3-  detect K8061 (only theoretically supported)
+0.7.76  -2-  code completely rewritten (adjust driver logic)
+0.7.76  -1-  support for digital and counter subdevice
 */
 
 #include <linux/kernel.h>
@@ -39,1078 +60,1340 @@ Status: works
 #include <linux/slab.h>
 #include <linux/poll.h>
 #include <linux/usb.h>
-#include <asm/uaccess.h>
-
-#include "../comedidev.h"	/* comedi definitions */
-
-/* ------------------------------------------------------------------------ */
-#define VMK80XX_MODULE_DESC "Velleman USB Interface Board Kernel-Space Driver"
-#define VMK80XX_MODULE_DEVICE "Velleman K8055/K8061 USB Interface Board"
-#define VMK80XX_MODULE_AUTHOR "Copyright (C) 2009 Manuel Gebele, Germany"
-#define VMK80XX_MODULE_LICENSE "GPL"
-#define VMK80XX_MODULE_VERSION "0.7.76"
-
-/* Module device ID's */
-static struct usb_device_id vm_id_table[] = {
-	/* k8055 */
-	{ USB_DEVICE(0x10cf, 0x5500 + 0x00) }, /* @ddr. 0 */
-	{ USB_DEVICE(0x10cf, 0x5500 + 0x01) }, /* @ddr. 1 */
-	{ USB_DEVICE(0x10cf, 0x5500 + 0x02) }, /* @ddr. 2 */
-	{ USB_DEVICE(0x10cf, 0x5500 + 0x03) }, /* @ddr. 3 */
-	/* k8061 */
-	{ USB_DEVICE(0x10cf, 0x8061 + 0x00) }, /* @ddr. 0 */
-	{ USB_DEVICE(0x10cf, 0x8061 + 0x01) }, /* @ddr. 1 */
-	{ USB_DEVICE(0x10cf, 0x8061 + 0x02) }, /* @ddr. 2 */
-	{ USB_DEVICE(0x10cf, 0x8061 + 0x03) }, /* @ddr. 3 */
-	{ USB_DEVICE(0x10cf, 0x8061 + 0x04) }, /* @ddr. 4 */
-	{ USB_DEVICE(0x10cf, 0x8061 + 0x05) }, /* @ddr. 5 */
-	{ USB_DEVICE(0x10cf, 0x8061 + 0x06) }, /* @ddr. 6 */
-	{ USB_DEVICE(0x10cf, 0x8061 + 0x07) }, /* @ddr. 7 */
+#include <linux/uaccess.h>
+
+#include "../comedidev.h"
+
+MODULE_AUTHOR("Manuel Gebele <forensixs@gmx.de>");
+MODULE_DESCRIPTION("Velleman USB Board Low-Level Driver");
+MODULE_SUPPORTED_DEVICE("K8055/K8061 aka VM110/VM140");
+MODULE_VERSION("0.8.01");
+MODULE_LICENSE("GPL");
+
+enum {
+	DEVICE_VMK8055,
+	DEVICE_VMK8061
+};
+
+static struct usb_device_id vmk80xx_id_table[] = {
+	{ USB_DEVICE(0x10cf, 0x5500), .driver_info = DEVICE_VMK8055 },
+	{ USB_DEVICE(0x10cf, 0x5501), .driver_info = DEVICE_VMK8055 },
+	{ USB_DEVICE(0x10cf, 0x5502), .driver_info = DEVICE_VMK8055 },
+	{ USB_DEVICE(0x10cf, 0x5503), .driver_info = DEVICE_VMK8055 },
+	{ USB_DEVICE(0x10cf, 0x8061), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8062), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8063), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8064), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8065), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8066), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8067), .driver_info = DEVICE_VMK8061 },
+	{ USB_DEVICE(0x10cf, 0x8068), .driver_info = DEVICE_VMK8061 },
 	{ } /* terminating entry */
 };
-MODULE_DEVICE_TABLE(usb, vm_id_table);
 
-MODULE_AUTHOR(VMK80XX_MODULE_AUTHOR);
-MODULE_DESCRIPTION(VMK80XX_MODULE_DESC);
-MODULE_SUPPORTED_DEVICE(VMK80XX_MODULE_DEVICE);
-MODULE_VERSION(VMK80XX_MODULE_VERSION);
-MODULE_LICENSE(VMK80XX_MODULE_LICENSE);
-/* ------------------------------------------------------------------------ */
+MODULE_DEVICE_TABLE(usb, vmk80xx_id_table);
+
+#define VMK8055_DI_REG          0x00
+#define VMK8055_DO_REG          0x01
+#define VMK8055_AO1_REG         0x02
+#define VMK8055_AO2_REG         0x03
+#define VMK8055_AI1_REG         0x02
+#define VMK8055_AI2_REG         0x03
+#define VMK8055_CNT1_REG        0x04
+#define VMK8055_CNT2_REG        0x06
+
+#define VMK8061_CH_REG          0x01
+#define VMK8061_DI_REG          0x01
+#define VMK8061_DO_REG          0x01
+#define VMK8061_PWM_REG1        0x01
+#define VMK8061_PWM_REG2        0x02
+#define VMK8061_CNT_REG         0x02
+#define VMK8061_AO_REG          0x02
+#define VMK8061_AI_REG1         0x02
+#define VMK8061_AI_REG2         0x03
+
+#define VMK8055_CMD_RST         0x00
+#define VMK8055_CMD_DEB1_TIME   0x01
+#define VMK8055_CMD_DEB2_TIME   0x02
+#define VMK8055_CMD_RST_CNT1    0x03
+#define VMK8055_CMD_RST_CNT2    0x04
+#define VMK8055_CMD_WRT_AD      0x05
+
+#define VMK8061_CMD_RD_AI       0x00
+#define VMK8061_CMR_RD_ALL_AI   0x01    /* !non-active! */
+#define VMK8061_CMD_SET_AO      0x02
+#define VMK8061_CMD_SET_ALL_AO  0x03    /* !non-active! */
+#define VMK8061_CMD_OUT_PWM     0x04
+#define VMK8061_CMD_RD_DI       0x05
+#define VMK8061_CMD_DO          0x06    /* !non-active! */
+#define VMK8061_CMD_CLR_DO      0x07
+#define VMK8061_CMD_SET_DO      0x08
+#define VMK8061_CMD_RD_CNT      0x09    /* TODO: completely pointless? */
+#define VMK8061_CMD_RST_CNT     0x0a    /* TODO: completely pointless? */
+#define VMK8061_CMD_RD_VERSION  0x0b    /* internal usage */
+#define VMK8061_CMD_RD_JMP_STAT 0x0c    /* TODO: not implemented yet */
+#define VMK8061_CMD_RD_PWR_STAT 0x0d    /* internal usage */
+#define VMK8061_CMD_RD_DO       0x0e
+#define VMK8061_CMD_RD_AO       0x0f
+#define VMK8061_CMD_RD_PWM      0x10
+
+#define VMK80XX_MAX_BOARDS      COMEDI_NUM_BOARD_MINORS
+
+#define TRANS_OUT_BUSY          1
+#define TRANS_IN_BUSY           2
+#define TRANS_IN_RUNNING        3
+
+#define IC3_VERSION             (1 << 0)
+#define IC6_VERSION             (1 << 1)
+
+#define URB_RCV_FLAG            (1 << 0)
+#define URB_SND_FLAG            (1 << 1)
 
 #define CONFIG_VMK80XX_DEBUG
+#undef CONFIG_VMK80XX_DEBUG
 
-//#undef CONFIG_COMEDI_DEBUG /* Uncommend this line to disable comedi debug */
-#undef CONFIG_VMK80XX_DEBUG  /* Commend this line to enable vmk80xx debug */
+#ifdef CONFIG_VMK80XX_DEBUG
+ static int dbgvm = 1;
+#else
+ static int dbgvm;
+#endif
 
 #ifdef CONFIG_COMEDI_DEBUG
- static int cm_dbg = 1;
-#else   /* !CONFIG_COMEDI_DEBUG */
- static int cm_dbg = 0;
-#endif  /* !CONFIG_COMEDI_DEBUG */
+ static int dbgcm = 1;
+#else
+ static int dbgcm;
+#endif
+
+#define dbgvm(fmt, arg...)                     \
+do {                                           \
+	if (dbgvm)                             \
+		printk(KERN_DEBUG fmt, ##arg); \
+} while (0)
+
+#define dbgcm(fmt, arg...)                     \
+do {                                           \
+	if (dbgcm)                             \
+		printk(KERN_DEBUG fmt, ##arg); \
+} while (0)
+
+enum vmk80xx_model {
+	VMK8055_MODEL,
+	VMK8061_MODEL
+};
 
-#ifdef CONFIG_VMK80XX_DEBUG
- static int vm_dbg = 1;
-#else   /* !CONFIG_VMK80XX_DEBUG */
- static int vm_dbg = 0;
-#endif  /* !CONFIG_VMK80XX_DEBUG */
-
-/* Define our own debug macros */
-#define DBGCM(fmt, arg...) do { if (cm_dbg) printk(fmt, ##arg); } while (0)
-#define DBGVM(fmt, arg...) do { if (vm_dbg) printk(fmt, ##arg); } while (0)
-
-/* Velleman K8055 specific stuff */
-#define VMK8055_DI              0 /* digital input offset */
-#define VMK8055_DO              1 /* digital output offset */
-#define VMK8055_AO1             2 /* analog output channel 1 offset */
-#define VMK8055_AO2             3 /* analog output channel 2 offset */
-#define VMK8055_CNT1            4 /* counter 1 offset */
-#define VMK8055_CNT2            6 /* counter 2 offset */
-#define VMK8055_CMD_RST      0x00 /* reset device registers */
-#define VMK8055_CMD_DEB1     0x01 /* debounce time for pulse counter 1 */
-#define VMK8055_CMD_DEB2     0x02 /* debounce time for pulse counter 2 */
-#define VMK8055_CMD_RST_CNT1 0x03 /* reset pulse counter 1 */
-#define VMK8055_CMD_RST_CNT2 0x04 /* reset pulse counter 2 */
-#define VMK8055_CMD_AD       0x05 /* write to analog or digital channel */
-#define VMK8055_EP_OUT       0x01 /* out endpoint address */
-#define VMK8055_EP_IN        0x81 /* in endpoint address */
-#define VMK8055_EP_SIZE         8 /* endpoint max packet size */
-#define VMK8055_EP_INTERVAL    20 /* general conversion time per command */
-#define VMK8055_MAX_BOARDS     16
-
-/* Structure to hold all of our device specific stuff */
-struct vmk80xx_usb {
-	struct usb_interface	*intf;
-	struct semaphore	limit_sem;
-	wait_queue_head_t	read_wait;
-	wait_queue_head_t	write_wait;
-	size_t			irq_out_endpoint_size;
-	__u8			irq_out_endpoint;
-	int			irq_out_interval;
-	unsigned char		*irq_out_buf;
-	struct urb		*irq_out_urb;
-	int			irq_out_busy;
-	size_t			irq_in_endpoint_size;
-	__u8			irq_in_endpoint;
-	int			irq_in_interval;
-	unsigned char		*irq_in_buf;
-	struct urb		*irq_in_urb;
-	int			irq_in_busy;
-	int			irq_in_running;
-	int			probed;
-	int			attached;
-	int			id;
+struct firmware_version {
+	unsigned char ic3_vers[32]; /* USB-Controller */
+	unsigned char ic6_vers[32]; /* CPU */
 };
 
-static struct vmk80xx_usb vm_boards[VMK8055_MAX_BOARDS];
+static const struct comedi_lrange vmk8055_range = {
+	1, { UNI_RANGE(5) }
+};
 
-/* ---------------------------------------------------------------------------
- * Abort active transfers and tidy up allocated resources.
---------------------------------------------------------------------------- */
-static void vm_abort_transfers(struct vmk80xx_usb *vm)
-{
-	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+static const struct comedi_lrange vmk8061_range = {
+	2, { UNI_RANGE(5), UNI_RANGE(10) }
+};
 
-	if (vm->irq_in_running) {
-		vm->irq_in_running = 0;
-		if (vm->intf)
-			usb_kill_urb(vm->irq_in_urb);
-	}
+struct vmk80xx_board {
+	const char *name;
+	enum vmk80xx_model model;
+	const struct comedi_lrange *range;
+	__u8   ai_chans;
+	__le16 ai_bits;
+	__u8   ao_chans;
+	__le16 ao_bits;
+	__u8   di_chans;
+	__le16 di_bits;
+	__u8   do_chans;
+	__le16 do_bits;
+	__u8   cnt_chans;
+	__le16 cnt_bits;
+	__u8   pwm_chans;
+	__le16 pwm_bits;
+};
 
-	if (vm->irq_out_busy && vm->intf)
-		usb_kill_urb(vm->irq_out_urb);
-}
+enum {
+	VMK80XX_SUBD_AI,
+	VMK80XX_SUBD_AO,
+	VMK80XX_SUBD_DI,
+	VMK80XX_SUBD_DO,
+	VMK80XX_SUBD_CNT,
+	VMK80XX_SUBD_PWM,
+};
 
-static void vm_delete(struct vmk80xx_usb *vm)
+struct vmk80xx_usb {
+	struct usb_device *udev;
+	struct usb_interface *intf;
+	struct usb_endpoint_descriptor *ep_rx;
+	struct usb_endpoint_descriptor *ep_tx;
+	struct usb_anchor rx_anchor;
+	struct usb_anchor tx_anchor;
+	struct vmk80xx_board board;
+	struct firmware_version fw;
+	struct semaphore limit_sem;
+	wait_queue_head_t read_wait;
+	wait_queue_head_t write_wait;
+	unsigned char *usb_rx_buf;
+	unsigned char *usb_tx_buf;
+	unsigned long flags;
+	int probed;
+	int attached;
+	int count;
+};
+
+static struct vmk80xx_usb vmb[VMK80XX_MAX_BOARDS];
+
+static DEFINE_MUTEX(glb_mutex);
+
+static void vmk80xx_tx_callback(struct urb *urb)
 {
-	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+	struct vmk80xx_usb *dev = urb->context;
+	int stat = urb->status;
 
-	vm_abort_transfers(vm);
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	/* Deallocate usb urbs and kernel buffers */
-	if (vm->irq_in_urb)
-		usb_free_urb(vm->irq_in_urb);
+	if (stat && !(stat == -ENOENT
+		 ||   stat == -ECONNRESET
+		 ||   stat == -ESHUTDOWN))
+		dbgcm("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",
+		      __func__, stat);
 
-	if (vm->irq_out_urb);
-		usb_free_urb(vm->irq_out_urb);
+	if (!test_bit(TRANS_OUT_BUSY, &dev->flags))
+		return;
 
-	if (vm->irq_in_buf)
-		kfree(vm->irq_in_buf);
+	clear_bit(TRANS_OUT_BUSY, &dev->flags);
 
-	if (vm->irq_out_buf)
-		kfree(vm->irq_out_buf);
+	wake_up_interruptible(&dev->write_wait);
 }
 
-/* ---------------------------------------------------------------------------
- * Interrupt in and interrupt out callback for usb data transfer.
---------------------------------------------------------------------------- */
-static void vm_irq_in_callback(struct urb *urb)
+static void vmk80xx_rx_callback(struct urb *urb)
 {
-	struct vmk80xx_usb *vm = (struct vmk80xx_usb *)urb->context;
-	int err;
+	struct vmk80xx_usb *dev = urb->context;
+	int stat = urb->status;
 
-	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	switch (urb->status) {
-	case 0: /* success */
+	switch (stat) {
+	case 0:
 		break;
 	case -ENOENT:
 	case -ECONNRESET:
 	case -ESHUTDOWN:
 		break;
 	default:
-		DBGCM("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",
-		      __func__, urb->status);
-		goto resubmit; /* maybe we can recover */
+		dbgcm("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",
+		      __func__, stat);
+		goto resubmit;
 	}
 
 	goto exit;
 resubmit:
-	if (vm->irq_in_running && vm->intf) {
-		err = usb_submit_urb(vm->irq_in_urb, GFP_ATOMIC);
-		if (!err) goto exit;
-		/* FALL THROUGH */
-		DBGCM("comedi#: vmk80xx: %s - submit urb failed (err# %d)\n",
-		      __func__, err);
+	if (test_bit(TRANS_IN_RUNNING, &dev->flags) && dev->intf) {
+		usb_anchor_urb(urb, &dev->rx_anchor);
+
+		if (!usb_submit_urb(urb, GFP_KERNEL))
+			goto exit;
+
+		err("comedi#: vmk80xx: %s - submit urb failed\n", __func__);
+
+		usb_unanchor_urb(urb);
 	}
 exit:
-	vm->irq_in_busy = 0;
+	clear_bit(TRANS_IN_BUSY, &dev->flags);
 
-	/* interrupt-in pipe is available again */
-	wake_up_interruptible(&vm->read_wait);
+	wake_up_interruptible(&dev->read_wait);
 }
 
-static void vm_irq_out_callback(struct urb *urb)
+static int vmk80xx_check_data_link(struct vmk80xx_usb *dev)
 {
-	struct vmk80xx_usb *vm;
+	unsigned int tx_pipe, rx_pipe;
+	unsigned char tx[1], rx[2];
+
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+	tx_pipe = usb_sndbulkpipe(dev->udev, 0x01);
+	rx_pipe = usb_rcvbulkpipe(dev->udev, 0x81);
 
-	/* sync/async unlink (hardware going away) faults  aren't errors */
-	if (urb->status && !(urb->status == -ENOENT
-			||   urb->status == -ECONNRESET
-			||   urb->status == -ESHUTDOWN))
-		DBGCM("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",
-		      __func__, urb->status);
+	tx[0] = VMK8061_CMD_RD_PWR_STAT;
 
-	vm = (struct vmk80xx_usb *)urb->context;
-	vm->irq_out_busy = 0;
+	/* Check that IC6 (PIC16F871) is powered and
+	 * running and the data link between IC3 and
+	 * IC6 is working properly */
+	usb_bulk_msg(dev->udev, tx_pipe, tx, 1, NULL,
+		     dev->ep_tx->bInterval);
+	usb_bulk_msg(dev->udev, rx_pipe, rx, 2, NULL,
+		     HZ * 10);
 
-	/* interrupt-out pipe is available again */
-	wake_up_interruptible(&vm->write_wait);
+	return (int)rx[1];
 }
 
-/* ---------------------------------------------------------------------------
- * Interface for digital/analog input/output and counter funcs (see below).
---------------------------------------------------------------------------- */
-static int vm_read(struct vmk80xx_usb *vm)
+static void vmk80xx_read_eeprom(struct vmk80xx_usb *dev, int flag)
 {
-	struct usb_device *udev;
-	int retval = -ENODEV;
+	unsigned int tx_pipe, rx_pipe;
+	unsigned char tx[1], rx[64];
+	int cnt;
 
-	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	/* Verify that the device wasn't un-plugged */
-	if (!vm->intf) {
-		DBGCM("comedi#: vmk80xx: %s - No dev or dev un-plugged\n",
-		      __func__);
-		goto exit;
-	}
+	tx_pipe = usb_sndbulkpipe(dev->udev, 0x01);
+	rx_pipe = usb_rcvbulkpipe(dev->udev, 0x81);
 
-	if (vm->irq_in_busy) {
-		retval = wait_event_interruptible(vm->read_wait,
-						 !vm->irq_in_busy);
-		if (retval < 0) { /* we were interrupted by a signal */
-			retval = -ERESTART;
-			goto exit;
-		}
+	tx[0] = VMK8061_CMD_RD_VERSION;
+
+	/* Read the firmware version info of IC3 and
+	 * IC6 from the internal EEPROM of the IC */
+	usb_bulk_msg(dev->udev, tx_pipe, tx,  1, NULL,
+		     dev->ep_tx->bInterval);
+	usb_bulk_msg(dev->udev, rx_pipe, rx, 64, &cnt,
+		     HZ * 10);
+
+	rx[cnt] = '\0';
+
+	if (flag & IC3_VERSION)
+		strncpy(dev->fw.ic3_vers, rx +  1, 24);
+	else /* IC6_VERSION */
+		strncpy(dev->fw.ic6_vers, rx + 25, 24);
+}
+
+static int vmk80xx_reset_device(struct vmk80xx_usb *dev)
+{
+	struct urb *urb;
+	unsigned int tx_pipe;
+	int ival;
+	size_t size;
+
+	dbgvm("vmk80xx: %s\n", __func__);
+
+	urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!urb)
+		return -ENOMEM;
+
+	tx_pipe = usb_sndintpipe(dev->udev, 0x01);
+
+	ival = dev->ep_tx->bInterval;
+	size = le16_to_cpu(dev->ep_tx->wMaxPacketSize);
+
+	dev->usb_tx_buf[0] = VMK8055_CMD_RST;
+	dev->usb_tx_buf[1] = 0x00;
+	dev->usb_tx_buf[2] = 0x00;
+	dev->usb_tx_buf[3] = 0x00;
+	dev->usb_tx_buf[4] = 0x00;
+	dev->usb_tx_buf[5] = 0x00;
+	dev->usb_tx_buf[6] = 0x00;
+	dev->usb_tx_buf[7] = 0x00;
+
+	usb_fill_int_urb(urb, dev->udev, tx_pipe, dev->usb_tx_buf,
+			 size, vmk80xx_tx_callback, dev, ival);
+
+	usb_anchor_urb(urb, &dev->tx_anchor);
+
+	return usb_submit_urb(urb, GFP_KERNEL);
+}
+
+static void vmk80xx_build_int_urb(struct urb *urb, int flag)
+{
+	struct vmk80xx_usb *dev = urb->context;
+	__u8 rx_addr, tx_addr;
+	unsigned int pipe;
+	unsigned char *buf;
+	size_t size;
+	void (*callback)(struct urb *);
+	int ival;
+
+	dbgvm("vmk80xx: %s\n", __func__);
+
+	if (flag & URB_RCV_FLAG) {
+		rx_addr = dev->ep_rx->bEndpointAddress;
+		pipe = usb_rcvintpipe(dev->udev, rx_addr);
+		buf = dev->usb_rx_buf;
+		size = le16_to_cpu(dev->ep_rx->wMaxPacketSize);
+		callback = vmk80xx_rx_callback;
+		ival = dev->ep_rx->bInterval;
+	} else { /* URB_SND_FLAG */
+		tx_addr = dev->ep_tx->bEndpointAddress;
+		pipe = usb_sndintpipe(dev->udev, tx_addr);
+		buf = dev->usb_tx_buf;
+		size = le16_to_cpu(dev->ep_tx->wMaxPacketSize);
+		callback = vmk80xx_tx_callback;
+		ival = dev->ep_tx->bInterval;
 	}
 
-	udev = interface_to_usbdev(vm->intf);
+	usb_fill_int_urb(urb, dev->udev, pipe, buf,
+			 size, callback, dev, ival);
+}
 
-	/* Fill the urb and send off */
-	usb_fill_int_urb(vm->irq_in_urb,
-			 udev,
-			 usb_rcvintpipe(udev, vm->irq_in_endpoint),
-			 vm->irq_in_buf,
-			 vm->irq_in_endpoint_size,
-			 vm_irq_in_callback,
-			 vm,
-			 vm->irq_in_interval);
+static void vmk80xx_do_bulk_msg(struct vmk80xx_usb *dev)
+{
+	__u8 tx_addr, rx_addr;
+	unsigned int tx_pipe, rx_pipe;
+	size_t size;
 
-	vm->irq_in_running = 1;
-	vm->irq_in_busy = 1; /* disallow following read request's */
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	retval = usb_submit_urb(vm->irq_in_urb, GFP_KERNEL);
-	if (!retval) goto exit; /* success */
-	/* FALL TROUGH */
-	vm->irq_in_running = 0;
-	DBGCM("comedi#: vmk80xx: %s - submit urb failed (err# %d)\n",
-	      __func__, retval);
+	set_bit(TRANS_IN_BUSY, &dev->flags);
+	set_bit(TRANS_OUT_BUSY, &dev->flags);
 
-exit:
-	return retval;
+	tx_addr = dev->ep_tx->bEndpointAddress;
+	rx_addr = dev->ep_rx->bEndpointAddress;
+	tx_pipe = usb_sndbulkpipe(dev->udev, tx_addr);
+	rx_pipe = usb_rcvbulkpipe(dev->udev, rx_addr);
+
+	/* The max packet size attributes of the K8061
+	 * input/output endpoints are identical */
+	size = le16_to_cpu(dev->ep_tx->wMaxPacketSize);
+
+	usb_bulk_msg(dev->udev, tx_pipe, dev->usb_tx_buf,
+		     size, NULL, dev->ep_tx->bInterval);
+	usb_bulk_msg(dev->udev, rx_pipe, dev->usb_rx_buf,
+		     size, NULL, HZ * 10);
+
+	clear_bit(TRANS_OUT_BUSY, &dev->flags);
+	clear_bit(TRANS_IN_BUSY, &dev->flags);
 }
 
-static int vm_write(struct vmk80xx_usb *vm, unsigned char cmd)
+static int vmk80xx_read_packet(struct vmk80xx_usb *dev)
 {
-	struct usb_device *udev;
-	int retval = -ENODEV;
+	struct urb *urb;
+	int retval;
 
-	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	/* Verify that the device wasn't un-plugged */
-	if (!vm->intf) {
-		DBGCM("comedi#: vmk80xx: %s - No dev or dev un-plugged\n",
-		      __func__);
-		goto exit;
-	}
+	if (!dev->intf)
+		return -ENODEV;
 
-	if (vm->irq_out_busy) {
-		retval = wait_event_interruptible(vm->write_wait,
-						 !vm->irq_out_busy);
-		if (retval < 0) { /* we were interrupted by a signal */
-			retval = -ERESTART;
-			goto exit;
-		}
+	/* Only useful for interrupt transfers */
+	if (test_bit(TRANS_IN_BUSY, &dev->flags))
+		if (wait_event_interruptible(dev->read_wait,
+			!test_bit(TRANS_IN_BUSY, &dev->flags)))
+			return -ERESTART;
+
+	if (dev->board.model == VMK8061_MODEL) {
+		vmk80xx_do_bulk_msg(dev);
+
+		return 0;
 	}
 
-	udev = interface_to_usbdev(vm->intf);
+	urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!urb)
+		return -ENOMEM;
 
-	/* Set the command which should send to the device */
-	vm->irq_out_buf[0] = cmd;
+	urb->context = dev;
+	vmk80xx_build_int_urb(urb, URB_RCV_FLAG);
 
-	/* Fill the urb and send off */
-	usb_fill_int_urb(vm->irq_out_urb,
-			 udev,
-			 usb_sndintpipe(udev, vm->irq_out_endpoint),
-			 vm->irq_out_buf,
-			 vm->irq_out_endpoint_size,
-			 vm_irq_out_callback,
-			 vm,
-			 vm->irq_out_interval);
+	set_bit(TRANS_IN_RUNNING, &dev->flags);
+	set_bit(TRANS_IN_BUSY, &dev->flags);
 
-	vm->irq_out_busy = 1; /* disallow following write request's */
+	usb_anchor_urb(urb, &dev->rx_anchor);
 
-	wmb();
+	retval = usb_submit_urb(urb, GFP_KERNEL);
+	if (!retval)
+		goto exit;
 
-	retval = usb_submit_urb(vm->irq_out_urb, GFP_KERNEL);
-	if (!retval) goto exit; /* success */
-	/* FALL THROUGH */
-	vm->irq_out_busy = 0;
-	DBGCM("comedi#: vmk80xx: %s - submit urb failed (err# %d)\n",
-	      __func__, retval);
+	clear_bit(TRANS_IN_RUNNING, &dev->flags);
+	usb_unanchor_urb(urb);
 
 exit:
+	usb_free_urb(urb);
+
 	return retval;
 }
 
-/* ---------------------------------------------------------------------------
- * COMEDI-Interface (callback functions for the userspacs apps).
---------------------------------------------------------------------------- */
-static int vm_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-		       struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_write_packet(struct vmk80xx_usb *dev, int cmd)
 {
-	struct vmk80xx_usb *vm;
-	int minor = dev->minor;
-	int ch, ch_offs, i;
-	int retval = -EFAULT;
+	struct urb *urb;
+	int retval;
 
-	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	if (!(vm = (struct vmk80xx_usb *)dev->private))
-		return retval;
+	if (!dev->intf)
+		return -ENODEV;
 
-	down(&vm->limit_sem);
+	if (test_bit(TRANS_OUT_BUSY, &dev->flags))
+		if (wait_event_interruptible(dev->write_wait,
+			!test_bit(TRANS_OUT_BUSY, &dev->flags)))
+			return -ERESTART;
 
-	/* We have an attached board ? */
-	if (!vm->probed) {
-		retval = -ENODEV;
-		goto error;
-	}
+	if (dev->board.model == VMK8061_MODEL) {
+		dev->usb_tx_buf[0] = cmd;
+		vmk80xx_do_bulk_msg(dev);
 
-	/* interrupt-in pipe busy ? */
-	if (vm->irq_in_busy) {
-		retval = -EBUSY;
-		goto error;
+		return 0;
 	}
 
-	ch = CR_CHAN(insn->chanspec);
-	ch_offs = (!ch) ? VMK8055_AO1 : VMK8055_AO2;
+	urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!urb)
+		return -ENOMEM;
+
+	urb->context = dev;
+	vmk80xx_build_int_urb(urb, URB_SND_FLAG);
 
-	for (i = 0; i < insn->n; i++) {
-		retval = vm_read(vm);
-		if (retval)
-			goto error;
+	set_bit(TRANS_OUT_BUSY, &dev->flags);
 
-		/* NOTE:
-		 * The input voltage of the selected 8-bit AD channel
-		 * is converted to a value which lies between
-		 * 0 and 255.
-		 */
-		data[i] = vm->irq_in_buf[ch_offs];
-	}
+	usb_anchor_urb(urb, &dev->tx_anchor);
 
-	up(&vm->limit_sem);
+	dev->usb_tx_buf[0] = cmd;
 
-	/* Return the number of samples read */
-	return i;
-error:
-	up(&vm->limit_sem);
+	retval = usb_submit_urb(urb, GFP_KERNEL);
+	if (!retval)
+		goto exit;
+
+	clear_bit(TRANS_OUT_BUSY, &dev->flags);
+	usb_unanchor_urb(urb);
+
+exit:
+	usb_free_urb(urb);
 
 	return retval;
 }
 
-static int vm_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-		       struct comedi_insn *insn, unsigned int *data)
+#define DIR_IN  1
+#define DIR_OUT 2
+
+#define rudimentary_check(dir)                             \
+do {                                                       \
+	if (!dev)                                          \
+		return -EFAULT;                            \
+	if (!dev->probed)                                  \
+		return -ENODEV;                            \
+	if (!dev->attached)                                \
+		return -ENODEV;                            \
+	if ((dir) & DIR_IN) {                              \
+		if (test_bit(TRANS_IN_BUSY, &dev->flags))  \
+			return -EBUSY;                     \
+	} else {  /* DIR_OUT */                            \
+		if (test_bit(TRANS_OUT_BUSY, &dev->flags)) \
+			return -EBUSY;                     \
+	}                                                  \
+} while (0)
+
+static int vmk80xx_ai_rinsn(struct comedi_device *cdev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_usb *vm;
-	int minor = dev->minor;
-	int ch, ch_offs, i;
-	int retval = -EFAULT;
+	struct vmk80xx_usb *dev = cdev->private;
+	int chan, reg[2];
+	int n;
 
-	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	if (!(vm = (struct vmk80xx_usb *)dev->private))
-		return retval;
+	rudimentary_check(DIR_IN);
 
-	down(&vm->limit_sem);
+	down(&dev->limit_sem);
+	chan = CR_CHAN(insn->chanspec);
 
-	/* We have an attached board ? */
-	if (!vm->probed) {
-		retval = -ENODEV;
-		goto error;
+	switch (dev->board.model) {
+	case VMK8055_MODEL:
+		if (!chan)
+			reg[0] = VMK8055_AI1_REG;
+		else
+			reg[0] = VMK8055_AI2_REG;
+		break;
+	case VMK8061_MODEL:
+		reg[0] = VMK8061_AI_REG1;
+		reg[1] = VMK8061_AI_REG2;
+		dev->usb_tx_buf[0] = VMK8061_CMD_RD_AI;
+		dev->usb_tx_buf[VMK8061_CH_REG] = chan;
+		break;
 	}
 
-	/* interrupt-out pipe busy ? */
-	if (vm->irq_out_busy) {
-		retval = -EBUSY;
-		goto error;
-	}
+	for (n = 0; n < insn->n; n++) {
+		if (vmk80xx_read_packet(dev))
+			break;
 
-	ch = CR_CHAN(insn->chanspec);
-	ch_offs = (!ch) ? VMK8055_AO1 : VMK8055_AO2;
-
-	for (i = 0; i < insn->n; i++) {
-		/* NOTE:
-		 * The indicated 8-bit DA channel is altered according
-		 * to the new data. This means that the data corresponds
-		 * to a specific voltage. The value 0 corresponds to a
-		 * minimum output voltage (+-0 Volt) and the value 255
-		 * corresponds to a maximum output voltage (+5 Volt).
-		 */
-		vm->irq_out_buf[ch_offs] = data[i];
-
-		retval = vm_write(vm, VMK8055_CMD_AD);
-		if (retval)
-			goto error;
-	}
+		if (dev->board.model == VMK8055_MODEL) {
+			data[n] = dev->usb_rx_buf[reg[0]];
+			continue;
+		}
 
-	up(&vm->limit_sem);
+		/* VMK8061_MODEL */
+		data[n] = dev->usb_rx_buf[reg[0]] + 256 *
+			  dev->usb_rx_buf[reg[1]];
+	}
 
-	/* Return the number of samples write */
-	return i;
-error:
-	up(&vm->limit_sem);
+	up(&dev->limit_sem);
 
-	return retval;
+	return n;
 }
 
-static int vm_di_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-		       struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_ao_winsn(struct comedi_device *cdev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_usb *vm;
-	int minor = dev->minor;
-	int ch, i, inp;
-	int retval = -EFAULT;
+	struct vmk80xx_usb *dev = cdev->private;
+	int chan, cmd, reg;
+	int n;
 
-	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	if (!(vm = (struct vmk80xx_usb *)dev->private))
-		return retval;
+	rudimentary_check(DIR_OUT);
 
-	down(&vm->limit_sem);
+	down(&dev->limit_sem);
+	chan = CR_CHAN(insn->chanspec);
 
-	/* We have an attached board ? */
-	if (!vm->probed) {
-		retval = -ENODEV;
-		goto error;
+	switch (dev->board.model) {
+	case VMK8055_MODEL:
+		cmd = VMK8055_CMD_WRT_AD;
+		if (!chan)
+			reg = VMK8055_AO1_REG;
+		else
+			reg = VMK8055_AO2_REG;
+		break;
+	default: /* NOTE: avoid compiler warnings */
+		cmd = VMK8061_CMD_SET_AO;
+		reg = VMK8061_AO_REG;
+		dev->usb_tx_buf[VMK8061_CH_REG] = chan;
+		break;
 	}
 
-	/* interrupt-in pipe busy ? */
-	if (vm->irq_in_busy) {
-		retval = -EBUSY;
-		goto error;
-	}
+	for (n = 0; n < insn->n; n++) {
+		dev->usb_tx_buf[reg] = data[n];
 
-	for (i = 0, ch = CR_CHAN(insn->chanspec); i < insn->n; i++) {
-		retval = vm_read(vm);
-		if (retval)
-			goto error;
-
-		/* NOTE:
-		 * The status of the selected digital input channel is read.
-		 */
-		inp = (((vm->irq_in_buf[VMK8055_DI] >> 4) & 0x03) |
-		       ((vm->irq_in_buf[VMK8055_DI] << 2) & 0x04) |
-		       ((vm->irq_in_buf[VMK8055_DI] >> 3) & 0x18));
-		data[i] = ((inp & (1 << ch)) > 0);
+		if (vmk80xx_write_packet(dev, cmd))
+			break;
 	}
 
-	up(&vm->limit_sem);
-
-	return i;
-error:
-	up(&vm->limit_sem);
+	up(&dev->limit_sem);
 
-	return retval;
+	return n;
 }
 
-static int vm_do_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-		       struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_ao_rinsn(struct comedi_device *cdev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_usb *vm;
-	int minor = dev->minor;
-	int ch, i, mask;
-	int retval = -EFAULT;
+	struct vmk80xx_usb *dev = cdev->private;
+	int chan, reg;
+	int n;
 
-	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	if (!(vm = (struct vmk80xx_usb *)dev->private))
-		return retval;
+	rudimentary_check(DIR_IN);
 
-	down(&vm->limit_sem);
+	down(&dev->limit_sem);
+	chan = CR_CHAN(insn->chanspec);
 
-	/* We have an attached board ? */
-	if (!vm->probed) {
-		retval = -ENODEV;
-		goto error;
-	}
+	reg = VMK8061_AO_REG - 1;
 
-	/* interrupt-out pipe busy ? */
-	if (vm->irq_out_busy) {
-		retval = -EBUSY;
-		goto error;
+	dev->usb_tx_buf[0] = VMK8061_CMD_RD_AO;
+
+	for (n = 0; n < insn->n; n++) {
+		if (vmk80xx_read_packet(dev))
+			break;
+
+		data[n] = dev->usb_rx_buf[reg+chan];
 	}
 
-	for (i = 0, ch = CR_CHAN(insn->chanspec); i < insn->n; i++) {
-		/* NOTE:
-		 * The selected digital output channel is set or cleared.
-		 */
-		mask = (data[i] == 1)
-		     ? vm->irq_out_buf[VMK8055_DO] | (1 << ch)
-		     : vm->irq_out_buf[VMK8055_DO] ^ (1 << ch);
+	up(&dev->limit_sem);
 
-		vm->irq_out_buf[VMK8055_DO] = mask;
+	return n;
+}
 
-		retval = vm_write(vm, VMK8055_CMD_AD);
-		if (retval)
-			goto error;
-	}
+static int vmk80xx_di_rinsn(struct comedi_device *cdev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *dev = cdev->private;
+	int chan;
+	unsigned char *rx_buf;
+	int reg, inp;
+	int n;
 
-	up(&vm->limit_sem);
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	return i;
-error:
-	up(&vm->limit_sem);
+	rudimentary_check(DIR_IN);
 
-	return retval;
+	down(&dev->limit_sem);
+	chan = CR_CHAN(insn->chanspec);
+
+	rx_buf = dev->usb_rx_buf;
+
+	if (dev->board.model == VMK8061_MODEL) {
+		reg = VMK8061_DI_REG;
+		dev->usb_tx_buf[0] = VMK8061_CMD_RD_DI;
+	} else
+		reg = VMK8055_DI_REG;
+
+	for (n = 0; n < insn->n; n++) {
+		if (vmk80xx_read_packet(dev))
+			break;
+
+		if (dev->board.model == VMK8055_MODEL)
+			inp = (((rx_buf[reg] >> 4) & 0x03) |
+			       ((rx_buf[reg] << 2) & 0x04) |
+			       ((rx_buf[reg] >> 3) & 0x18));
+		else
+			inp = rx_buf[reg];
+
+		data[n] = ((inp & (1 << chan)) > 0);
+	}
+
+	up(&dev->limit_sem);
+
+	return n;
 }
 
-static int vm_cnt_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_do_winsn(struct comedi_device *cdev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_usb *vm;
-	int minor = dev->minor;
-	int cnt, cnt_offs, i;
-	int retval = -EFAULT;
 
-	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+	struct vmk80xx_usb *dev = cdev->private;
+	int chan;
+	unsigned char *tx_buf;
+	int reg, cmd;
+	int n;
 
-	if (!(vm = (struct vmk80xx_usb *)dev->private))
-		return retval;
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	down(&vm->limit_sem);
+	rudimentary_check(DIR_OUT);
 
-	/* We have an attached board ? */
-	if (!vm->probed) {
-		retval = -ENODEV;
-		goto error;
-	}
+	down(&dev->limit_sem);
+	chan = CR_CHAN(insn->chanspec);
 
-	/* interrupt-in pipe busy ? */
-	if (vm->irq_in_busy) {
-		retval = -EBUSY;
-		goto error;
-	}
+	tx_buf = dev->usb_tx_buf;
 
-	cnt = CR_CHAN(insn->chanspec);
-	cnt_offs = (!cnt) ? VMK8055_CNT1 : VMK8055_CNT2;
-
-	for (i = 0; i < insn->n; i++) {
-		retval = vm_read(vm);
-		if (retval)
-			goto error;
-
-		/* NOTE:
-		 * The status of the selected 16-bit pulse counter is
-		 * read. The counter # 1 counts the pulses fed to the
-		 * input Inp1 and the counter # 2 counts the pulses fed
-		 * to the input Inp2.
-		 */
-		data[i] = vm->irq_in_buf[cnt_offs];
-	}
+	for (n = 0; n < insn->n; n++) {
+		if (dev->board.model == VMK8055_MODEL) {
+			reg = VMK8055_DO_REG;
+			cmd = VMK8055_CMD_WRT_AD;
+			if (data[n] == 1)
+				tx_buf[reg] |= (1 << chan);
+			else
+				tx_buf[reg] ^= (1 << chan);
 
-	up(&vm->limit_sem);
+			goto write_packet;
+		}
 
-	return i;
-error:
-	up(&vm->limit_sem);
+		/* VMK8061_MODEL */
+		reg = VMK8061_DO_REG;
+		if (data[n] == 1) {
+			cmd = VMK8061_CMD_SET_DO;
+			tx_buf[reg] = 1 << chan;
+		} else {
+			cmd = VMK8061_CMD_CLR_DO;
+			tx_buf[reg] = 0xff - (1 << chan);
+		}
 
-	return retval;
+write_packet:
+		if (vmk80xx_write_packet(dev, cmd))
+			break;
+	}
+
+	up(&dev->limit_sem);
+
+	return n;
 }
 
-static int vm_cnt_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_do_rinsn(struct comedi_device *cdev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_usb *vm;
-	int minor = dev->minor;
-	int cnt, cnt_offs, cmd, i;
-	int retval = -EFAULT;
+	struct vmk80xx_usb *dev = cdev->private;
+	int chan, reg, mask;
+	int n;
 
-	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	if (!(vm = (struct vmk80xx_usb *)dev->private))
-		return retval;
+	rudimentary_check(DIR_IN);
 
-	down(&vm->limit_sem);
+	down(&dev->limit_sem);
+	chan = CR_CHAN(insn->chanspec);
 
-	/* We have an attached board ? */
-	if (!vm->probed) {
-		retval = -ENODEV;
-		goto error;
-	}
+	reg = VMK8061_DO_REG;
+	mask = 1 << chan;
 
-	/* interrupt-out pipe busy ? */
-	if (vm->irq_out_busy) {
-		retval = -EBUSY;
-		goto error;
+	dev->usb_tx_buf[0] = VMK8061_CMD_RD_DO;
+
+	for (n = 0; n < insn->n; n++) {
+		if (vmk80xx_read_packet(dev))
+			break;
+
+		data[n] = (dev->usb_rx_buf[reg] & mask) >> chan;
 	}
 
-	cnt = CR_CHAN(insn->chanspec);
-	cnt_offs = (!cnt) ? VMK8055_CNT1 : VMK8055_CNT2;
-	cmd = (!cnt) ? VMK8055_CMD_RST_CNT1 : VMK8055_CMD_RST_CNT2;
+	up(&dev->limit_sem);
+
+	return n;
+}
+
+static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *dev = cdev->private;
+	int chan, reg[2];
+	int n;
+
+	dbgvm("vmk80xx: %s\n", __func__);
+
+	rudimentary_check(DIR_IN);
 
-	for (i = 0; i < insn->n; i++) {
-		/* NOTE:
-		 * The selected 16-bit pulse counter is reset.
-		 */
-		vm->irq_out_buf[cnt_offs] = 0x00;
+	down(&dev->limit_sem);
+	chan = CR_CHAN(insn->chanspec);
 
-		retval = vm_write(vm, cmd);
-		if (retval)
-			goto error;
+	switch (dev->board.model) {
+	case VMK8055_MODEL:
+		if (!chan)
+			reg[0] = VMK8055_CNT1_REG;
+		else
+			reg[0] = VMK8055_CNT2_REG;
+		break;
+	case VMK8061_MODEL:
+		reg[0] = VMK8061_CNT_REG;
+		reg[1] = VMK8061_CNT_REG;
+		dev->usb_tx_buf[0] = VMK8061_CMD_RD_CNT;
+		break;
 	}
 
-	up(&vm->limit_sem);
+	for (n = 0; n < insn->n; n++) {
+		if (vmk80xx_read_packet(dev))
+			break;
 
-	return i;
-error:
-	up(&vm->limit_sem);
+		if (dev->board.model == VMK8055_MODEL) {
+			data[n] = dev->usb_rx_buf[reg[0]];
+			continue;
+		}
 
-	return retval;
+		/* VMK8061_MODEL */
+		data[n] = dev->usb_rx_buf[reg[0]*(chan+1)+1]
+		  + 256 * dev->usb_rx_buf[reg[1]*2+2];
+	}
+
+	up(&dev->limit_sem);
+
+	return n;
 }
 
-static int vm_cnt_cinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			struct comedi_insn *insn, unsigned int *data)
+static int vmk80xx_cnt_cinsn(struct comedi_device *cdev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct vmk80xx_usb *vm;
-	int minor = dev->minor;
-	int cnt, cmd, i;
-	unsigned int debtime, val;
-	int retval = -EFAULT;
+	struct vmk80xx_usb *dev = cdev->private;
+	unsigned int insn_cmd;
+	int chan, cmd, reg;
+	int n;
 
-	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	if (!(vm = (struct vmk80xx_usb *)dev->private))
-		return retval;
+	rudimentary_check(DIR_OUT);
 
-	down(&vm->limit_sem);
+	down(&dev->limit_sem);
 
-	/* We have an attached board ? */
-	if (!vm->probed) {
-		retval = -ENODEV;
-		goto error;
-	}
+	insn_cmd = data[0];
+	if (insn_cmd != INSN_CONFIG_RESET && insn_cmd != GPCT_RESET)
+		return -EINVAL;
 
-	/* interrupt-out pipe busy ? */
-	if (vm->irq_out_busy) {
-		retval = -EBUSY;
-		goto error;
-	}
+	chan = CR_CHAN(insn->chanspec);
 
-	cnt = CR_CHAN(insn->chanspec);
-	cmd = (!cnt) ? VMK8055_CMD_DEB1 : VMK8055_CMD_DEB2;
-
-	/* NOTE:
-	 * The counter inputs are debounced in the software to prevent
-	 * false triggering when mechanical switches or relay inputs
-	 * are used. The debounce time is equal for both falling and
-	 * rising edges. The default debounce time is 2ms. This means
-	 * the counter input must be stable for at least 2ms before it
-	 * is recognised , giving the maximum count rate of about 200
-	 * counts per second. If the debounce time is set to 0, then
-	 * the maximum counting rate is about 2000 counts per second.
-	 */
-	for (i = 0; i < insn->n; i++) {
-		debtime = data[i];
+	if (dev->board.model == VMK8055_MODEL) {
+		if (!chan) {
+			cmd = VMK8055_CMD_RST_CNT1;
+			reg = VMK8055_CNT1_REG;
+		} else {
+			cmd = VMK8055_CMD_RST_CNT2;
+			reg = VMK8055_CNT2_REG;
+		}
+
+		dev->usb_tx_buf[reg] = 0x00;
+	} else
+		cmd = VMK8061_CMD_RST_CNT;
+
+	for (n = 0; n < insn->n; n++)
+		if (vmk80xx_write_packet(dev, cmd))
+			break;
+
+	up(&dev->limit_sem);
+
+	return n;
+}
+
+static int vmk80xx_cnt_winsn(struct comedi_device *cdev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *dev = cdev->private;
+	unsigned long debtime, val;
+	int chan, cmd;
+	int n;
+
+	dbgvm("vmk80xx: %s\n", __func__);
+
+	rudimentary_check(DIR_OUT);
+
+	down(&dev->limit_sem);
+	chan = CR_CHAN(insn->chanspec);
+
+	if (!chan)
+		cmd = VMK8055_CMD_DEB1_TIME;
+	else
+		cmd = VMK8055_CMD_DEB2_TIME;
+
+	for (n = 0; n < insn->n; n++) {
+		debtime = data[n];
 		if (debtime == 0)
 			debtime = 1;
-		/* --------------------------------------------------
-		 * From libk8055.c
-		 * ---------------
-		 * Copyleft (C) 2005 by Sven Lindberg;
-		 * Copyright (C) 2007 by Pjetur G. Hjaltason:
-		 * By testing and measuring on the other hand I found
-		 * the formula dbt=0.115*x^2.........
-		 *
-		 * I'm using here an adapted formula to avoid floating
-		 * point operations inside the kernel. The time set
-		 * with this formula is within +-4% +- 1.
-		 * ------------------------------------------------ */
+
+		/* TODO: Prevent overflows */
+		if (debtime > 7450)
+			debtime = 7450;
+
 		val = int_sqrt(debtime * 1000 / 115);
 		if (((val + 1) * val) < debtime * 1000 / 115)
 			val += 1;
 
-		vm->irq_out_buf[cnt+6] = val;
+		dev->usb_tx_buf[6+chan] = val;
 
-		retval = vm_write(vm, cmd);
-		if (retval)
-			goto error;
+		if (vmk80xx_write_packet(dev, cmd))
+			break;
 	}
 
-	up(&vm->limit_sem);
+	up(&dev->limit_sem);
 
-	return i;
-error:
-	up(&vm->limit_sem);
+	return n;
+}
 
-	return retval;
+static int vmk80xx_pwm_rinsn(struct comedi_device *cdev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *dev = cdev->private;
+	int reg[2];
+	int n;
+
+	dbgvm("vmk80xx: %s\n", __func__);
+
+	rudimentary_check(DIR_IN);
+
+	down(&dev->limit_sem);
+
+	reg[0] = VMK8061_PWM_REG1;
+	reg[1] = VMK8061_PWM_REG2;
+
+	dev->usb_tx_buf[0] = VMK8061_CMD_RD_PWM;
+
+	for (n = 0; n < insn->n; n++) {
+		if (vmk80xx_read_packet(dev))
+			break;
+
+		data[n] = dev->usb_rx_buf[reg[0]] + 4 *
+			  dev->usb_rx_buf[reg[1]];
+	}
+
+	up(&dev->limit_sem);
+
+	return n;
 }
 
-/* Comedi subdevice offsets */
-#define VMK8055_SUBD_AI_OFFSET	0
-#define VMK8055_SUBD_AO_OFFSET	1
-#define VMK8055_SUBD_DI_OFFSET	2
-#define VMK8055_SUBD_DO_OFFSET	3
-#define VMK8055_SUBD_CT_OFFSET	4
+static int vmk80xx_pwm_winsn(struct comedi_device *cdev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *dev = cdev->private;
+	unsigned char *tx_buf;
+	int reg[2], cmd;
+	int n;
 
-static DEFINE_MUTEX(glb_mutex);
+	dbgvm("vmk80xx: %s\n", __func__);
+
+	rudimentary_check(DIR_OUT);
+
+	down(&dev->limit_sem);
+
+	tx_buf = dev->usb_tx_buf;
+
+	reg[0] = VMK8061_PWM_REG1;
+	reg[1] = VMK8061_PWM_REG2;
+
+	cmd = VMK8061_CMD_OUT_PWM;
+
+	/*
+	 * The followin piece of code was translated from the inline
+	 * assembler code in the DLL source code.
+	 *
+	 * asm
+	 *   mov eax, k  ; k is the value (data[n])
+	 *   and al, 03h ; al are the lower 8 bits of eax
+	 *   mov lo, al  ; lo is the low part (tx_buf[reg[0]])
+	 *   mov eax, k
+	 *   shr eax, 2  ; right shift eax register by 2
+	 *   mov hi, al  ; hi is the high part (tx_buf[reg[1]])
+	 * end;
+	 */
+	for (n = 0; n < insn->n; n++) {
+		tx_buf[reg[0]] = (unsigned char)(data[n] & 0x03);
+		tx_buf[reg[1]] = (unsigned char)(data[n] >> 2) & 0xff;
+
+		if (vmk80xx_write_packet(dev, cmd))
+			break;
+	}
 
-/* ---------------------------------------------------------------------------
- * Hook-up (or deallocate) the virtual device file '/dev/comedi[minor]' with
- * the vmk80xx driver (comedi_config/rmmod).
---------------------------------------------------------------------------- */
-static int vm_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+	up(&dev->limit_sem);
+
+	return n;
+}
+
+static int
+vmk80xx_attach(struct comedi_device *cdev, struct comedi_devconfig *it)
 {
+	int i;
+	struct vmk80xx_usb *dev;
+	int n_subd;
 	struct comedi_subdevice *s;
-	int minor = dev->minor;
-	int idx, i;
+	int minor;
 
-	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+	dbgvm("vmk80xx: %s\n", __func__);
 
 	mutex_lock(&glb_mutex);
 
-	/* Prepare user info... */
-	printk("comedi%d: vmk80xx: ", minor);
-
-	idx = -1;
-
-	/* Find the last valid device which has been detected
-	 * by the probe function */;
-	for (i = 0; i < VMK8055_MAX_BOARDS; i++)
-		if (vm_boards[i].probed && !vm_boards[i].attached) {
-			idx = i;
+	for (i = 0; i < VMK80XX_MAX_BOARDS; i++)
+		if (vmb[i].probed && !vmb[i].attached)
 			break;
-		}
 
-	if (idx == -1) {
-		printk("no boards attached\n");
+	if (i == VMK80XX_MAX_BOARDS) {
 		mutex_unlock(&glb_mutex);
 		return -ENODEV;
 	}
 
-	down(&vm_boards[idx].limit_sem);
+	dev = &vmb[i];
+
+	down(&dev->limit_sem);
 
-	/* OK, at that time we've an attached board and this is
-	 * the first execution of the comedi_config command for
-	 * this board */
-	printk("board #%d is attached to comedi\n", vm_boards[idx].id);
+	cdev->board_name = dev->board.name;
+	cdev->private = dev;
 
-	dev->board_name = "vmk80xx";
-	dev->private = vm_boards + idx; /* will be allocated in vm_probe */
+	if (dev->board.model == VMK8055_MODEL)
+		n_subd = 5;
+	else
+		n_subd = 6;
 
-	/* Subdevices section -> set properties */
-	if (alloc_subdevices(dev, 5) < 0) {
-		printk("comedi%d: vmk80xx: couldn't allocate subdevs\n",
-		       minor);
-		up(&vm_boards[idx].limit_sem);
+	if (alloc_subdevices(cdev, n_subd) < 0) {
+		up(&dev->limit_sem);
 		mutex_unlock(&glb_mutex);
 		return -ENOMEM;
 	}
 
-	s = dev->subdevices + VMK8055_SUBD_AI_OFFSET;
+	/* Analog input subdevice */
+	s = cdev->subdevices + VMK80XX_SUBD_AI;
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
-	s->n_chan = 2;
-	s->maxdata = 0xff; /* +5 Volt */
-	s->range_table = &range_unipolar5; /* +-0 Volt - +5 Volt */
-	s->insn_read = vm_ai_rinsn;
+	s->n_chan = dev->board.ai_chans;
+	s->maxdata = (1 << dev->board.ai_bits) - 1;
+	s->range_table = dev->board.range;
+	s->insn_read = vmk80xx_ai_rinsn;
 
-	s = dev->subdevices + VMK8055_SUBD_AO_OFFSET;
+	/* Analog output subdevice */
+	s = cdev->subdevices + VMK80XX_SUBD_AO;
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
-	s->n_chan = 2;
-	s->maxdata = 0xff;
-	s->range_table = &range_unipolar5;
-	s->insn_write = vm_ao_winsn;
+	s->n_chan = dev->board.ao_chans;
+	s->maxdata = (1 << dev->board.ao_bits) - 1;
+	s->range_table = dev->board.range;
+	s->insn_write = vmk80xx_ao_winsn;
+
+	if (dev->board.model == VMK8061_MODEL) {
+		s->subdev_flags |= SDF_READABLE;
+		s->insn_read = vmk80xx_ao_rinsn;
+	}
 
-	s = dev->subdevices + VMK8055_SUBD_DI_OFFSET;
+	/* Digital input subdevice */
+	s = cdev->subdevices + VMK80XX_SUBD_DI;
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
-	s->n_chan = 5;
-	s->insn_read = vm_di_rinsn;
+	s->n_chan = dev->board.di_chans;
+	s->maxdata = (1 << dev->board.di_bits) - 1;
+	s->insn_read = vmk80xx_di_rinsn;
 
-	s = dev->subdevices + VMK8055_SUBD_DO_OFFSET;
+	/* Digital output subdevice */
+	s = cdev->subdevices + VMK80XX_SUBD_DO;
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
-	s->n_chan = 8;
-	s->maxdata = 1;
-	s->insn_write = vm_do_winsn;
+	s->n_chan = dev->board.do_chans;
+	s->maxdata = (1 << dev->board.do_bits) - 1;
+	s->insn_write = vmk80xx_do_winsn;
 
-	s = dev->subdevices + VMK8055_SUBD_CT_OFFSET;
+	if (dev->board.model == VMK8061_MODEL) {
+		s->subdev_flags |= SDF_READABLE;
+		s->insn_read = vmk80xx_do_rinsn;
+	}
+
+	/* Counter subdevice */
+	s = cdev->subdevices + VMK80XX_SUBD_CNT;
 	s->type = COMEDI_SUBD_COUNTER;
-	s->subdev_flags = SDF_READABLE | SDF_WRITEABLE;
-	s->n_chan = 2;
-	s->insn_read = vm_cnt_rinsn;
-	s->insn_write = vm_cnt_winsn; /* accept only a channel # as arg */
-	s->insn_config = vm_cnt_cinsn;
+	s->subdev_flags = SDF_READABLE;
+	s->n_chan = dev->board.cnt_chans;
+	s->insn_read = vmk80xx_cnt_rinsn;
+	s->insn_config = vmk80xx_cnt_cinsn;
+
+	if (dev->board.model == VMK8055_MODEL) {
+		s->subdev_flags |= SDF_WRITEABLE;
+		s->maxdata = (1 << dev->board.cnt_bits) - 1;
+		s->insn_write = vmk80xx_cnt_winsn;
+	}
+
+	/* PWM subdevice */
+	if (dev->board.model == VMK8061_MODEL) {
+		s = cdev->subdevices + VMK80XX_SUBD_PWM;
+		s->type = COMEDI_SUBD_PWM;
+		s->subdev_flags = SDF_READABLE | SDF_WRITEABLE;
+		s->n_chan = dev->board.pwm_chans;
+		s->maxdata = (1 << dev->board.pwm_bits) - 1;
+		s->insn_read = vmk80xx_pwm_rinsn;
+		s->insn_write = vmk80xx_pwm_winsn;
+	}
 
-	/* Register the comedi board connection */
-	vm_boards[idx].attached = 1;
+	dev->attached = 1;
 
-	up(&vm_boards[idx].limit_sem);
+	minor = cdev->minor;
 
+	printk(KERN_INFO
+	       "comedi%d: vmk80xx: board #%d [%s] attached to comedi\n",
+	       minor, dev->count, dev->board.name);
+
+	up(&dev->limit_sem);
 	mutex_unlock(&glb_mutex);
 
 	return 0;
 }
 
-static int vm_detach(struct comedi_device *dev)
+static int vmk80xx_detach(struct comedi_device *cdev)
 {
-	struct vmk80xx_usb *vm;
-	int minor = dev->minor;
+	struct vmk80xx_usb *dev;
+	int minor;
 
-	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	if (!dev) { /* FIXME: I don't know if i need that here */
-		printk("comedi%d: vmk80xx: %s - dev is NULL\n",
-		       minor, __func__);
+	if (!cdev)
 		return -EFAULT;
-	}
 
-	if (!(vm = (struct vmk80xx_usb *)dev->private)) {
-		printk("comedi%d: vmk80xx: %s - dev->private is NULL\n",
-		       minor, __func__);
+	dev = cdev->private;
+	if (!dev)
 		return -EFAULT;
-	}
 
-	/* NOTE: dev->private and dev->subdevices are deallocated
-	 * automatically by the comedi core */
+	down(&dev->limit_sem);
 
-	down(&vm->limit_sem);
+	cdev->private = NULL;
+	dev->attached = 0;
 
-	dev->private = NULL;
-	vm->attached = 0;
+	minor = cdev->minor;
 
-	printk("comedi%d: vmk80xx: board #%d removed from comedi core\n",
-	       minor, vm->id);
+	printk(KERN_INFO
+	       "comedi%d: vmk80xx: board #%d [%s] detached from comedi\n",
+	       minor, dev->count, dev->board.name);
 
-	up(&vm->limit_sem);
+	up(&dev->limit_sem);
 
 	return 0;
 }
 
-/* ---------------------------------------------------------------------------
- * Hook-up or remove the Velleman board from the usb.
---------------------------------------------------------------------------- */
-static int vm_probe(struct usb_interface *itf, const struct usb_device_id *id)
+static int
+vmk80xx_probe(struct usb_interface *intf, const struct usb_device_id *id)
 {
-	struct usb_device *udev;
-	int idx, i;
-	u16 product_id;
-	int retval = -ENOMEM;
+	int i;
+	struct vmk80xx_usb *dev;
+	struct usb_host_interface *iface_desc;
+	struct usb_endpoint_descriptor *ep_desc;
+	size_t size;
 
-	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+	dbgvm("vmk80xx: %s\n", __func__);
 
 	mutex_lock(&glb_mutex);
 
-	udev = interface_to_usbdev(itf);
-
-	idx = -1;
+	for (i = 0; i < VMK80XX_MAX_BOARDS; i++)
+		if (!vmb[i].probed)
+			break;
 
-	/* TODO: k8061 only theoretically supported yet */
-	product_id = le16_to_cpu(udev->descriptor.idProduct);
-	if (product_id == 0x8061) {
-		printk("comedi#: vmk80xx: Velleman K8061 detected "
-		       "(no COMEDI support available yet)\n");
+	if (i == VMK80XX_MAX_BOARDS) {
 		mutex_unlock(&glb_mutex);
-		return -ENODEV;
+		return -EMFILE;
 	}
 
-	/* Look for a free place to put the board into the array */
-	for (i = 0; i < VMK8055_MAX_BOARDS; i++) {
-		if (!vm_boards[i].probed) {
-			idx = i;
-			i = VMK8055_MAX_BOARDS;
+	dev = &vmb[i];
+
+	memset(dev, 0x00, sizeof(struct vmk80xx_usb));
+	dev->count = i;
+
+	iface_desc = intf->cur_altsetting;
+	if (iface_desc->desc.bNumEndpoints != 2)
+		goto error;
+
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
+		ep_desc = &iface_desc->endpoint[i].desc;
+
+		if (usb_endpoint_is_int_in(ep_desc)) {
+			dev->ep_rx = ep_desc;
+			continue;
 		}
-	}
 
-	if (idx == -1) {
-		printk("comedi#: vmk80xx: only FOUR boards supported\n");
-		mutex_unlock(&glb_mutex);
-		return -EMFILE;
-	}
+		if (usb_endpoint_is_int_out(ep_desc)) {
+			dev->ep_tx = ep_desc;
+			continue;
+		}
 
-	/* Initialize device states (hard coded) */
-	vm_boards[idx].intf = itf;
+		if (usb_endpoint_is_bulk_in(ep_desc)) {
+			dev->ep_rx = ep_desc;
+			continue;
+		}
 
-	/* interrupt-in context */
-	vm_boards[idx].irq_in_endpoint = VMK8055_EP_IN;
-	vm_boards[idx].irq_in_interval = VMK8055_EP_INTERVAL;
-	vm_boards[idx].irq_in_endpoint_size = VMK8055_EP_SIZE;
-	vm_boards[idx].irq_in_buf = kmalloc(VMK8055_EP_SIZE, GFP_KERNEL);
-	if (!vm_boards[idx].irq_in_buf) {
-		err("comedi#: vmk80xx: couldn't alloc irq_in_buf\n");
-		goto error;
+		if (usb_endpoint_is_bulk_out(ep_desc)) {
+			dev->ep_tx = ep_desc;
+			continue;
+		}
 	}
 
-	/* interrupt-out context */
-	vm_boards[idx].irq_out_endpoint = VMK8055_EP_OUT;
-	vm_boards[idx].irq_out_interval = VMK8055_EP_INTERVAL;
-	vm_boards[idx].irq_out_endpoint_size = VMK8055_EP_SIZE;
-	vm_boards[idx].irq_out_buf = kmalloc(VMK8055_EP_SIZE, GFP_KERNEL);
-	if (!vm_boards[idx].irq_out_buf) {
-		err("comedi#: vmk80xx: couldn't alloc irq_out_buf\n");
+	if (!dev->ep_rx || !dev->ep_tx)
 		goto error;
-	}
 
-	/* Endpoints located ? */
-	if (!vm_boards[idx].irq_in_endpoint) {
-		err("comedi#: vmk80xx: int-in endpoint not found\n");
-		goto error;
+	size = le16_to_cpu(dev->ep_rx->wMaxPacketSize);
+	dev->usb_rx_buf = kmalloc(size, GFP_KERNEL);
+	if (!dev->usb_rx_buf) {
+		mutex_unlock(&glb_mutex);
+		return -ENOMEM;
 	}
 
-	if (!vm_boards[idx].irq_out_endpoint) {
-		err("comedi#: vmk80xx: int-out endpoint not found\n");
-		goto error;
+	size = le16_to_cpu(dev->ep_tx->wMaxPacketSize);
+	dev->usb_tx_buf = kmalloc(size, GFP_KERNEL);
+	if (!dev->usb_tx_buf) {
+		kfree(dev->usb_rx_buf);
+		mutex_unlock(&glb_mutex);
+		return -ENOMEM;
 	}
 
-	/* Try to allocate in/out urbs */
-	vm_boards[idx].irq_in_urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!vm_boards[idx].irq_in_urb) {
-		err("comedi#: vmk80xx: couldn't alloc irq_in_urb\n");
-		goto error;
+	dev->udev = interface_to_usbdev(intf);
+	dev->intf = intf;
+
+	sema_init(&dev->limit_sem, 8);
+	init_waitqueue_head(&dev->read_wait);
+	init_waitqueue_head(&dev->write_wait);
+
+	init_usb_anchor(&dev->rx_anchor);
+	init_usb_anchor(&dev->tx_anchor);
+
+	usb_set_intfdata(intf, dev);
+
+	switch (id->driver_info) {
+	case DEVICE_VMK8055:
+		dev->board.name = "K8055 (VM110)";
+		dev->board.model = VMK8055_MODEL;
+		dev->board.range = &vmk8055_range;
+		dev->board.ai_chans = 2;
+		dev->board.ai_bits = 8;
+		dev->board.ao_chans = 2;
+		dev->board.ao_bits = 8;
+		dev->board.di_chans = 5;
+		dev->board.di_bits = 1;
+		dev->board.do_chans = 8;
+		dev->board.do_bits = 1;
+		dev->board.cnt_chans = 2;
+		dev->board.cnt_bits = 16;
+		dev->board.pwm_chans = 0;
+		dev->board.pwm_bits = 0;
+		break;
+	case DEVICE_VMK8061:
+		dev->board.name = "K8061 (VM140)";
+		dev->board.model = VMK8061_MODEL;
+		dev->board.range = &vmk8061_range;
+		dev->board.ai_chans = 8;
+		dev->board.ai_bits = 10;
+		dev->board.ao_chans = 8;
+		dev->board.ao_bits = 8;
+		dev->board.di_chans = 8;
+		dev->board.di_bits = 1;
+		dev->board.do_chans = 8;
+		dev->board.do_bits = 1;
+		dev->board.cnt_chans = 2;
+		dev->board.cnt_bits = 0;
+		dev->board.pwm_chans = 1;
+		dev->board.pwm_bits = 10;
+		break;
 	}
 
-	vm_boards[idx].irq_out_urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!vm_boards[idx].irq_out_urb) {
-		err("comedi#: vmk80xx: couldn't alloc irq_out_urb\n");
-		goto error;
+	if (dev->board.model == VMK8061_MODEL) {
+		vmk80xx_read_eeprom(dev, IC3_VERSION);
+		printk(KERN_INFO "comedi#: vmk80xx: %s\n",
+		       dev->fw.ic3_vers);
+
+		if (vmk80xx_check_data_link(dev)) {
+			vmk80xx_read_eeprom(dev, IC6_VERSION);
+			printk(KERN_INFO "comedi#: vmk80xx: %s\n",
+			       dev->fw.ic6_vers);
+		} else
+			dbgcm("comedi#: vmk80xx: no conn. to CPU\n");
 	}
 
-	/* Reset the device */
-	vm_boards[idx].irq_out_buf[0] = VMK8055_CMD_RST;
-	vm_boards[idx].irq_out_buf[1] = 0x00;
-	vm_boards[idx].irq_out_buf[2] = 0x00;
-	vm_boards[idx].irq_out_buf[3] = 0x00;
-	vm_boards[idx].irq_out_buf[4] = 0x00;
-	vm_boards[idx].irq_out_buf[5] = 0x00;
-	vm_boards[idx].irq_out_buf[6] = 0x00;
-	vm_boards[idx].irq_out_buf[7] = 0x00;
-
-	usb_fill_int_urb(vm_boards[idx].irq_out_urb,
-			 udev,
-			 usb_sndintpipe(udev,
-					vm_boards[idx].irq_out_endpoint),
-			 vm_boards[idx].irq_out_buf,
-			 vm_boards[idx].irq_out_endpoint_size,
-			 vm_irq_out_callback,
-			 &vm_boards[idx],
-			 vm_boards[idx].irq_out_interval);
-
-	retval = usb_submit_urb(vm_boards[idx].irq_out_urb, GFP_KERNEL);
-	if (retval)
-		DBGCM("comedi#: vmk80xx: device reset failed (err #%d)\n",
-		      retval);
-	else
-		DBGCM("comedi#: vmk80xx: device reset success\n");
-
+	if (dev->board.model == VMK8055_MODEL)
+		vmk80xx_reset_device(dev);
 
-	usb_set_intfdata(itf, &vm_boards[idx]);
+	dev->probed = 1;
 
-	/* Show some debugging messages if required */
-	DBGCM("comedi#: vmk80xx: [<-] ep addr 0x%02x size %d interval %d\n",
-	      vm_boards[idx].irq_in_endpoint,
-	      vm_boards[idx].irq_in_endpoint_size,
-	      vm_boards[idx].irq_in_interval);
-	DBGCM("comedi#: vmk80xx: [->] ep addr 0x%02x size %d interval %d\n",
-	      vm_boards[idx].irq_out_endpoint,
-	      vm_boards[idx].irq_out_endpoint_size,
-	      vm_boards[idx].irq_out_interval);
-
-	vm_boards[idx].id = idx;
-
-	/* Let the user know that the device is now attached */
-	printk("comedi#: vmk80xx: K8055 board #%d now attached\n",
-	       vm_boards[idx].id);
-
-	/* We have an attached velleman board */
-	vm_boards[idx].probed = 1;
+	printk(KERN_INFO "comedi#: vmk80xx: board #%d [%s] now attached\n",
+	       dev->count, dev->board.name);
 
 	mutex_unlock(&glb_mutex);
 
-	return retval;
+	return 0;
 error:
-	vm_delete(&vm_boards[idx]);
-
 	mutex_unlock(&glb_mutex);
 
-	return retval;
+	return -ENODEV;
 }
 
-static void vm_disconnect(struct usb_interface *intf)
+static void vmk80xx_disconnect(struct usb_interface *intf)
 {
-	struct vmk80xx_usb *vm;
+	struct vmk80xx_usb *dev = usb_get_intfdata(intf);
 
-	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+	dbgvm("vmk80xx: %s\n", __func__);
 
-	vm = (struct vmk80xx_usb *)usb_get_intfdata(intf);
-	if (!vm) {
-		printk("comedi#: vmk80xx: %s - vm is NULL\n", __func__);
-		return; /* -EFAULT */
-	}
+	if (!dev)
+		return;
 
 	mutex_lock(&glb_mutex);
-	/* Twill be needed if the driver supports more than one board */
-	down(&vm->limit_sem);
+	down(&dev->limit_sem);
 
-	vm->probed = 0; /* we have -1 attached boards */
-	usb_set_intfdata(vm->intf, NULL);
+	dev->probed = 0;
+	usb_set_intfdata(dev->intf, NULL);
 
-	vm_delete(vm); /* tidy up */
+	usb_kill_anchored_urbs(&dev->rx_anchor);
+	usb_kill_anchored_urbs(&dev->tx_anchor);
 
-	/* Twill be needed if the driver supports more than one board */
-	up(&vm->limit_sem);
-	mutex_unlock(&glb_mutex);
+	kfree(dev->usb_rx_buf);
+	kfree(dev->usb_tx_buf);
 
-	printk("comedi#: vmk80xx: Velleman board #%d now detached\n",
-	       vm->id);
+	printk(KERN_INFO "comedi#: vmk80xx: board #%d [%s] now detached\n",
+	       dev->count, dev->board.name);
+
+	up(&dev->limit_sem);
+	mutex_unlock(&glb_mutex);
 }
 
-/* ---------------------------------------------------------------------------
- * Register/Deregister this driver with/from the usb subsystem and the comedi.
---------------------------------------------------------------------------- */
-static struct usb_driver vm_driver = {
-	.name =		"vmk80xx",
-	.probe =	vm_probe,
-	.disconnect =	vm_disconnect,
-	.id_table =	vm_id_table,
+/* TODO: Add support for suspend, resume, pre_reset,
+ * post_reset and flush */
+static struct usb_driver vmk80xx_driver = {
+	.name       = "vmk80xx",
+	.probe      = vmk80xx_probe,
+	.disconnect = vmk80xx_disconnect,
+	.id_table   = vmk80xx_id_table
 };
 
-static struct comedi_driver driver_vm = {
-	.module =	THIS_MODULE,
-	.driver_name =	"vmk80xx",
-	.attach =	vm_attach,
-	.detach =	vm_detach,
+static struct comedi_driver driver_vmk80xx = {
+	.module      = THIS_MODULE,
+	.driver_name = "vmk80xx",
+	.attach      = vmk80xx_attach,
+	.detach      = vmk80xx_detach
 };
 
-static int __init vm_init(void)
+static int __init vmk80xx_init(void)
 {
-	int retval, idx;
-
-	printk("vmk80xx: version " VMK80XX_MODULE_VERSION " -"
-				 " Manuel Gebele <forensixs@gmx.de>\n");
-
-	for (idx = 0; idx < VMK8055_MAX_BOARDS; idx++) {
-		memset(&vm_boards[idx], 0x00, sizeof(vm_boards[idx]));
-		init_MUTEX(&vm_boards[idx].limit_sem);
-		init_waitqueue_head(&vm_boards[idx].read_wait);
-		init_waitqueue_head(&vm_boards[idx].write_wait);
-	}
-
-	/* Register with the usb subsystem */
-	retval = usb_register(&vm_driver);
-	if (retval) {
-		err("vmk80xx: usb subsystem registration failed (err #%d)\n",
-		    retval);
-		return retval;
-	}
-
-	/* Register with the comedi core */
-	retval = comedi_driver_register(&driver_vm);
-	if (retval) {
-		err("vmk80xx: comedi core registration failed (err #%d)\n",
-		    retval);
-		usb_deregister(&vm_driver);
-	}
-
-	return retval;
+	printk(KERN_INFO "vmk80xx: version 0.8.01 "
+	       "Manuel Gebele <forensixs@gmx.de>\n");
+	usb_register(&vmk80xx_driver);
+	return comedi_driver_register(&driver_vmk80xx);
 }
 
-static void __exit vm_exit(void)
+static void __exit vmk80xx_exit(void)
 {
-	comedi_driver_unregister(&driver_vm);
-	usb_deregister(&vm_driver);
+	comedi_driver_unregister(&driver_vmk80xx);
+	usb_deregister(&vmk80xx_driver);
 }
-module_init(vm_init);
-module_exit(vm_exit);
+
+module_init(vmk80xx_init);
+module_exit(vmk80xx_exit);

commit b153d83efb3d0ea15f5e6c7dced98fadc66531de
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Apr 22 10:29:33 2009 -0700

    Staging: comedi: vmk80xx.c: get the driver to build properly
    
    There have been changes in the comedi core, this fixes the vmk80xx.c
    driver to work properly with them, so it now will build properly.
    
    Cc: Manuel Gebele <forensixs@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
index 64d90a16d830..533b625021ad 100644
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -32,7 +32,6 @@ Status: works
 */
 
 #include <linux/kernel.h>
-#include <linux/comedidev.h> /* comedi definitions */
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/errno.h>
@@ -42,6 +41,8 @@ Status: works
 #include <linux/usb.h>
 #include <asm/uaccess.h>
 
+#include "../comedidev.h"	/* comedi definitions */
+
 /* ------------------------------------------------------------------------ */
 #define VMK80XX_MODULE_DESC "Velleman USB Interface Board Kernel-Space Driver"
 #define VMK80XX_MODULE_DEVICE "Velleman K8055/K8061 USB Interface Board"
@@ -346,8 +347,8 @@ static int vm_write(struct vmk80xx_usb *vm, unsigned char cmd)
 /* ---------------------------------------------------------------------------
  * COMEDI-Interface (callback functions for the userspacs apps).
 --------------------------------------------------------------------------- */
-static int vm_ai_rinsn(comedi_device *dev, comedi_subdevice *s,
-		       comedi_insn *insn, unsigned int *data)
+static int vm_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+		       struct comedi_insn *insn, unsigned int *data)
 {
 	struct vmk80xx_usb *vm;
 	int minor = dev->minor;
@@ -399,8 +400,8 @@ static int vm_ai_rinsn(comedi_device *dev, comedi_subdevice *s,
 	return retval;
 }
 
-static int vm_ao_winsn(comedi_device *dev, comedi_subdevice *s,
-                       comedi_insn *insn, unsigned int *data)
+static int vm_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+		       struct comedi_insn *insn, unsigned int *data)
 {
 	struct vmk80xx_usb *vm;
 	int minor = dev->minor;
@@ -454,8 +455,8 @@ static int vm_ao_winsn(comedi_device *dev, comedi_subdevice *s,
 	return retval;
 }
 
-static int vm_di_rinsn(comedi_device *dev, comedi_subdevice *s,
-		       comedi_insn *insn, unsigned int *data)
+static int vm_di_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+		       struct comedi_insn *insn, unsigned int *data)
 {
 	struct vmk80xx_usb *vm;
 	int minor = dev->minor;
@@ -504,8 +505,8 @@ static int vm_di_rinsn(comedi_device *dev, comedi_subdevice *s,
 	return retval;
 }
 
-static int vm_do_winsn(comedi_device *dev, comedi_subdevice *s,
-		       comedi_insn *insn, unsigned int *data)
+static int vm_do_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+		       struct comedi_insn *insn, unsigned int *data)
 {
 	struct vmk80xx_usb *vm;
 	int minor = dev->minor;
@@ -555,8 +556,8 @@ static int vm_do_winsn(comedi_device *dev, comedi_subdevice *s,
 	return retval;
 }
 
-static int vm_cnt_rinsn(comedi_device *dev, comedi_subdevice *s,
-			comedi_insn *insn, unsigned int *data)
+static int vm_cnt_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+			struct comedi_insn *insn, unsigned int *data)
 {
 	struct vmk80xx_usb *vm;
 	int minor = dev->minor;
@@ -608,8 +609,8 @@ static int vm_cnt_rinsn(comedi_device *dev, comedi_subdevice *s,
 	return retval;
 }
 
-static int vm_cnt_winsn(comedi_device *dev, comedi_subdevice *s,
-			comedi_insn *insn, unsigned int *data)
+static int vm_cnt_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+			struct comedi_insn *insn, unsigned int *data)
 {
 	struct vmk80xx_usb *vm;
 	int minor = dev->minor;
@@ -659,8 +660,8 @@ static int vm_cnt_winsn(comedi_device *dev, comedi_subdevice *s,
 	return retval;
 }
 
-static int vm_cnt_cinsn(comedi_device *dev, comedi_subdevice *s,
-			comedi_insn *insn, unsigned int *data)
+static int vm_cnt_cinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+			struct comedi_insn *insn, unsigned int *data)
 {
 	struct vmk80xx_usb *vm;
 	int minor = dev->minor;
@@ -749,9 +750,9 @@ static DEFINE_MUTEX(glb_mutex);
  * Hook-up (or deallocate) the virtual device file '/dev/comedi[minor]' with
  * the vmk80xx driver (comedi_config/rmmod).
 --------------------------------------------------------------------------- */
-static int vm_attach(comedi_device *dev, comedi_devconfig *it)
+static int vm_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	int minor = dev->minor;
 	int idx, i;
 
@@ -844,7 +845,7 @@ static int vm_attach(comedi_device *dev, comedi_devconfig *it)
 	return 0;
 }
 
-static int vm_detach(comedi_device *dev)
+static int vm_detach(struct comedi_device *dev)
 {
 	struct vmk80xx_usb *vm;
 	int minor = dev->minor;
@@ -1060,16 +1061,13 @@ static void vm_disconnect(struct usb_interface *intf)
  * Register/Deregister this driver with/from the usb subsystem and the comedi.
 --------------------------------------------------------------------------- */
 static struct usb_driver vm_driver = {
-#ifdef COMEDI_HAVE_USB_DRIVER_OWNER
-	.owner =	THIS_MODULE,
-#endif
 	.name =		"vmk80xx",
 	.probe =	vm_probe,
 	.disconnect =	vm_disconnect,
 	.id_table =	vm_id_table,
 };
 
-static comedi_driver driver_vm = {
+static struct comedi_driver driver_vm = {
 	.module =	THIS_MODULE,
 	.driver_name =	"vmk80xx",
 	.attach =	vm_attach,

commit 3faad67335e16863b2a143a61eedb5ac055c74c6
Author: Manuel Gebele <forensixs@gmx.de>
Date:   Wed Apr 22 10:28:18 2009 -0700

    Staging: comedi: add vmk80xx USB driver
    
    The k80xx module was completely revised again. The update contains the
    following new main features:
    - support for digital input
    - support for digital output
    - support for pulse counters
    - support up to 16 boards (by the way, the windows driver and the k8055
      library (libk8055) has support for only 4 boards)
    
    The driver can now manage all features what the board has to offer:
    - analog input/output
    - digital input/output
    - pulse counters (read, reset, set debounce time)
    
    I've also fixed some mistaken in the drivers source code/logic.
    
    By testing all of the driver features i got no errors or something else.
    The driver works fine....
    
    
    From: Manuel Gebele <forensixs@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c
new file mode 100644
index 000000000000..64d90a16d830
--- /dev/null
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -0,0 +1,1118 @@
+/*
+    comedi/drivers/vmk80xx.c
+    Velleman USB Interface Board Kernel-Space Driver
+
+    Copyright (C) 2009 Manuel Gebele <forensixs@gmx.de>, Germany
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+/*
+Driver: vmk80xx
+Description: Velleman USB Interface Board Kernel-Space Driver
+Devices: K8055, K8061 (in development)
+Author: Manuel Gebele <forensixs@gmx.de>
+Updated: Tue, 21 Apr 2009 19:40:55 +0200
+Status: works
+*/
+
+#include <linux/kernel.h>
+#include <linux/comedidev.h> /* comedi definitions */
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/errno.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/usb.h>
+#include <asm/uaccess.h>
+
+/* ------------------------------------------------------------------------ */
+#define VMK80XX_MODULE_DESC "Velleman USB Interface Board Kernel-Space Driver"
+#define VMK80XX_MODULE_DEVICE "Velleman K8055/K8061 USB Interface Board"
+#define VMK80XX_MODULE_AUTHOR "Copyright (C) 2009 Manuel Gebele, Germany"
+#define VMK80XX_MODULE_LICENSE "GPL"
+#define VMK80XX_MODULE_VERSION "0.7.76"
+
+/* Module device ID's */
+static struct usb_device_id vm_id_table[] = {
+	/* k8055 */
+	{ USB_DEVICE(0x10cf, 0x5500 + 0x00) }, /* @ddr. 0 */
+	{ USB_DEVICE(0x10cf, 0x5500 + 0x01) }, /* @ddr. 1 */
+	{ USB_DEVICE(0x10cf, 0x5500 + 0x02) }, /* @ddr. 2 */
+	{ USB_DEVICE(0x10cf, 0x5500 + 0x03) }, /* @ddr. 3 */
+	/* k8061 */
+	{ USB_DEVICE(0x10cf, 0x8061 + 0x00) }, /* @ddr. 0 */
+	{ USB_DEVICE(0x10cf, 0x8061 + 0x01) }, /* @ddr. 1 */
+	{ USB_DEVICE(0x10cf, 0x8061 + 0x02) }, /* @ddr. 2 */
+	{ USB_DEVICE(0x10cf, 0x8061 + 0x03) }, /* @ddr. 3 */
+	{ USB_DEVICE(0x10cf, 0x8061 + 0x04) }, /* @ddr. 4 */
+	{ USB_DEVICE(0x10cf, 0x8061 + 0x05) }, /* @ddr. 5 */
+	{ USB_DEVICE(0x10cf, 0x8061 + 0x06) }, /* @ddr. 6 */
+	{ USB_DEVICE(0x10cf, 0x8061 + 0x07) }, /* @ddr. 7 */
+	{ } /* terminating entry */
+};
+MODULE_DEVICE_TABLE(usb, vm_id_table);
+
+MODULE_AUTHOR(VMK80XX_MODULE_AUTHOR);
+MODULE_DESCRIPTION(VMK80XX_MODULE_DESC);
+MODULE_SUPPORTED_DEVICE(VMK80XX_MODULE_DEVICE);
+MODULE_VERSION(VMK80XX_MODULE_VERSION);
+MODULE_LICENSE(VMK80XX_MODULE_LICENSE);
+/* ------------------------------------------------------------------------ */
+
+#define CONFIG_VMK80XX_DEBUG
+
+//#undef CONFIG_COMEDI_DEBUG /* Uncommend this line to disable comedi debug */
+#undef CONFIG_VMK80XX_DEBUG  /* Commend this line to enable vmk80xx debug */
+
+#ifdef CONFIG_COMEDI_DEBUG
+ static int cm_dbg = 1;
+#else   /* !CONFIG_COMEDI_DEBUG */
+ static int cm_dbg = 0;
+#endif  /* !CONFIG_COMEDI_DEBUG */
+
+#ifdef CONFIG_VMK80XX_DEBUG
+ static int vm_dbg = 1;
+#else   /* !CONFIG_VMK80XX_DEBUG */
+ static int vm_dbg = 0;
+#endif  /* !CONFIG_VMK80XX_DEBUG */
+
+/* Define our own debug macros */
+#define DBGCM(fmt, arg...) do { if (cm_dbg) printk(fmt, ##arg); } while (0)
+#define DBGVM(fmt, arg...) do { if (vm_dbg) printk(fmt, ##arg); } while (0)
+
+/* Velleman K8055 specific stuff */
+#define VMK8055_DI              0 /* digital input offset */
+#define VMK8055_DO              1 /* digital output offset */
+#define VMK8055_AO1             2 /* analog output channel 1 offset */
+#define VMK8055_AO2             3 /* analog output channel 2 offset */
+#define VMK8055_CNT1            4 /* counter 1 offset */
+#define VMK8055_CNT2            6 /* counter 2 offset */
+#define VMK8055_CMD_RST      0x00 /* reset device registers */
+#define VMK8055_CMD_DEB1     0x01 /* debounce time for pulse counter 1 */
+#define VMK8055_CMD_DEB2     0x02 /* debounce time for pulse counter 2 */
+#define VMK8055_CMD_RST_CNT1 0x03 /* reset pulse counter 1 */
+#define VMK8055_CMD_RST_CNT2 0x04 /* reset pulse counter 2 */
+#define VMK8055_CMD_AD       0x05 /* write to analog or digital channel */
+#define VMK8055_EP_OUT       0x01 /* out endpoint address */
+#define VMK8055_EP_IN        0x81 /* in endpoint address */
+#define VMK8055_EP_SIZE         8 /* endpoint max packet size */
+#define VMK8055_EP_INTERVAL    20 /* general conversion time per command */
+#define VMK8055_MAX_BOARDS     16
+
+/* Structure to hold all of our device specific stuff */
+struct vmk80xx_usb {
+	struct usb_interface	*intf;
+	struct semaphore	limit_sem;
+	wait_queue_head_t	read_wait;
+	wait_queue_head_t	write_wait;
+	size_t			irq_out_endpoint_size;
+	__u8			irq_out_endpoint;
+	int			irq_out_interval;
+	unsigned char		*irq_out_buf;
+	struct urb		*irq_out_urb;
+	int			irq_out_busy;
+	size_t			irq_in_endpoint_size;
+	__u8			irq_in_endpoint;
+	int			irq_in_interval;
+	unsigned char		*irq_in_buf;
+	struct urb		*irq_in_urb;
+	int			irq_in_busy;
+	int			irq_in_running;
+	int			probed;
+	int			attached;
+	int			id;
+};
+
+static struct vmk80xx_usb vm_boards[VMK8055_MAX_BOARDS];
+
+/* ---------------------------------------------------------------------------
+ * Abort active transfers and tidy up allocated resources.
+--------------------------------------------------------------------------- */
+static void vm_abort_transfers(struct vmk80xx_usb *vm)
+{
+	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+
+	if (vm->irq_in_running) {
+		vm->irq_in_running = 0;
+		if (vm->intf)
+			usb_kill_urb(vm->irq_in_urb);
+	}
+
+	if (vm->irq_out_busy && vm->intf)
+		usb_kill_urb(vm->irq_out_urb);
+}
+
+static void vm_delete(struct vmk80xx_usb *vm)
+{
+	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+
+	vm_abort_transfers(vm);
+
+	/* Deallocate usb urbs and kernel buffers */
+	if (vm->irq_in_urb)
+		usb_free_urb(vm->irq_in_urb);
+
+	if (vm->irq_out_urb);
+		usb_free_urb(vm->irq_out_urb);
+
+	if (vm->irq_in_buf)
+		kfree(vm->irq_in_buf);
+
+	if (vm->irq_out_buf)
+		kfree(vm->irq_out_buf);
+}
+
+/* ---------------------------------------------------------------------------
+ * Interrupt in and interrupt out callback for usb data transfer.
+--------------------------------------------------------------------------- */
+static void vm_irq_in_callback(struct urb *urb)
+{
+	struct vmk80xx_usb *vm = (struct vmk80xx_usb *)urb->context;
+	int err;
+
+	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+
+	switch (urb->status) {
+	case 0: /* success */
+		break;
+	case -ENOENT:
+	case -ECONNRESET:
+	case -ESHUTDOWN:
+		break;
+	default:
+		DBGCM("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",
+		      __func__, urb->status);
+		goto resubmit; /* maybe we can recover */
+	}
+
+	goto exit;
+resubmit:
+	if (vm->irq_in_running && vm->intf) {
+		err = usb_submit_urb(vm->irq_in_urb, GFP_ATOMIC);
+		if (!err) goto exit;
+		/* FALL THROUGH */
+		DBGCM("comedi#: vmk80xx: %s - submit urb failed (err# %d)\n",
+		      __func__, err);
+	}
+exit:
+	vm->irq_in_busy = 0;
+
+	/* interrupt-in pipe is available again */
+	wake_up_interruptible(&vm->read_wait);
+}
+
+static void vm_irq_out_callback(struct urb *urb)
+{
+	struct vmk80xx_usb *vm;
+
+	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+
+	/* sync/async unlink (hardware going away) faults  aren't errors */
+	if (urb->status && !(urb->status == -ENOENT
+			||   urb->status == -ECONNRESET
+			||   urb->status == -ESHUTDOWN))
+		DBGCM("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",
+		      __func__, urb->status);
+
+	vm = (struct vmk80xx_usb *)urb->context;
+	vm->irq_out_busy = 0;
+
+	/* interrupt-out pipe is available again */
+	wake_up_interruptible(&vm->write_wait);
+}
+
+/* ---------------------------------------------------------------------------
+ * Interface for digital/analog input/output and counter funcs (see below).
+--------------------------------------------------------------------------- */
+static int vm_read(struct vmk80xx_usb *vm)
+{
+	struct usb_device *udev;
+	int retval = -ENODEV;
+
+	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+
+	/* Verify that the device wasn't un-plugged */
+	if (!vm->intf) {
+		DBGCM("comedi#: vmk80xx: %s - No dev or dev un-plugged\n",
+		      __func__);
+		goto exit;
+	}
+
+	if (vm->irq_in_busy) {
+		retval = wait_event_interruptible(vm->read_wait,
+						 !vm->irq_in_busy);
+		if (retval < 0) { /* we were interrupted by a signal */
+			retval = -ERESTART;
+			goto exit;
+		}
+	}
+
+	udev = interface_to_usbdev(vm->intf);
+
+	/* Fill the urb and send off */
+	usb_fill_int_urb(vm->irq_in_urb,
+			 udev,
+			 usb_rcvintpipe(udev, vm->irq_in_endpoint),
+			 vm->irq_in_buf,
+			 vm->irq_in_endpoint_size,
+			 vm_irq_in_callback,
+			 vm,
+			 vm->irq_in_interval);
+
+	vm->irq_in_running = 1;
+	vm->irq_in_busy = 1; /* disallow following read request's */
+
+	retval = usb_submit_urb(vm->irq_in_urb, GFP_KERNEL);
+	if (!retval) goto exit; /* success */
+	/* FALL TROUGH */
+	vm->irq_in_running = 0;
+	DBGCM("comedi#: vmk80xx: %s - submit urb failed (err# %d)\n",
+	      __func__, retval);
+
+exit:
+	return retval;
+}
+
+static int vm_write(struct vmk80xx_usb *vm, unsigned char cmd)
+{
+	struct usb_device *udev;
+	int retval = -ENODEV;
+
+	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+
+	/* Verify that the device wasn't un-plugged */
+	if (!vm->intf) {
+		DBGCM("comedi#: vmk80xx: %s - No dev or dev un-plugged\n",
+		      __func__);
+		goto exit;
+	}
+
+	if (vm->irq_out_busy) {
+		retval = wait_event_interruptible(vm->write_wait,
+						 !vm->irq_out_busy);
+		if (retval < 0) { /* we were interrupted by a signal */
+			retval = -ERESTART;
+			goto exit;
+		}
+	}
+
+	udev = interface_to_usbdev(vm->intf);
+
+	/* Set the command which should send to the device */
+	vm->irq_out_buf[0] = cmd;
+
+	/* Fill the urb and send off */
+	usb_fill_int_urb(vm->irq_out_urb,
+			 udev,
+			 usb_sndintpipe(udev, vm->irq_out_endpoint),
+			 vm->irq_out_buf,
+			 vm->irq_out_endpoint_size,
+			 vm_irq_out_callback,
+			 vm,
+			 vm->irq_out_interval);
+
+	vm->irq_out_busy = 1; /* disallow following write request's */
+
+	wmb();
+
+	retval = usb_submit_urb(vm->irq_out_urb, GFP_KERNEL);
+	if (!retval) goto exit; /* success */
+	/* FALL THROUGH */
+	vm->irq_out_busy = 0;
+	DBGCM("comedi#: vmk80xx: %s - submit urb failed (err# %d)\n",
+	      __func__, retval);
+
+exit:
+	return retval;
+}
+
+/* ---------------------------------------------------------------------------
+ * COMEDI-Interface (callback functions for the userspacs apps).
+--------------------------------------------------------------------------- */
+static int vm_ai_rinsn(comedi_device *dev, comedi_subdevice *s,
+		       comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *vm;
+	int minor = dev->minor;
+	int ch, ch_offs, i;
+	int retval = -EFAULT;
+
+	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+
+	if (!(vm = (struct vmk80xx_usb *)dev->private))
+		return retval;
+
+	down(&vm->limit_sem);
+
+	/* We have an attached board ? */
+	if (!vm->probed) {
+		retval = -ENODEV;
+		goto error;
+	}
+
+	/* interrupt-in pipe busy ? */
+	if (vm->irq_in_busy) {
+		retval = -EBUSY;
+		goto error;
+	}
+
+	ch = CR_CHAN(insn->chanspec);
+	ch_offs = (!ch) ? VMK8055_AO1 : VMK8055_AO2;
+
+	for (i = 0; i < insn->n; i++) {
+		retval = vm_read(vm);
+		if (retval)
+			goto error;
+
+		/* NOTE:
+		 * The input voltage of the selected 8-bit AD channel
+		 * is converted to a value which lies between
+		 * 0 and 255.
+		 */
+		data[i] = vm->irq_in_buf[ch_offs];
+	}
+
+	up(&vm->limit_sem);
+
+	/* Return the number of samples read */
+	return i;
+error:
+	up(&vm->limit_sem);
+
+	return retval;
+}
+
+static int vm_ao_winsn(comedi_device *dev, comedi_subdevice *s,
+                       comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *vm;
+	int minor = dev->minor;
+	int ch, ch_offs, i;
+	int retval = -EFAULT;
+
+	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+
+	if (!(vm = (struct vmk80xx_usb *)dev->private))
+		return retval;
+
+	down(&vm->limit_sem);
+
+	/* We have an attached board ? */
+	if (!vm->probed) {
+		retval = -ENODEV;
+		goto error;
+	}
+
+	/* interrupt-out pipe busy ? */
+	if (vm->irq_out_busy) {
+		retval = -EBUSY;
+		goto error;
+	}
+
+	ch = CR_CHAN(insn->chanspec);
+	ch_offs = (!ch) ? VMK8055_AO1 : VMK8055_AO2;
+
+	for (i = 0; i < insn->n; i++) {
+		/* NOTE:
+		 * The indicated 8-bit DA channel is altered according
+		 * to the new data. This means that the data corresponds
+		 * to a specific voltage. The value 0 corresponds to a
+		 * minimum output voltage (+-0 Volt) and the value 255
+		 * corresponds to a maximum output voltage (+5 Volt).
+		 */
+		vm->irq_out_buf[ch_offs] = data[i];
+
+		retval = vm_write(vm, VMK8055_CMD_AD);
+		if (retval)
+			goto error;
+	}
+
+	up(&vm->limit_sem);
+
+	/* Return the number of samples write */
+	return i;
+error:
+	up(&vm->limit_sem);
+
+	return retval;
+}
+
+static int vm_di_rinsn(comedi_device *dev, comedi_subdevice *s,
+		       comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *vm;
+	int minor = dev->minor;
+	int ch, i, inp;
+	int retval = -EFAULT;
+
+	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+
+	if (!(vm = (struct vmk80xx_usb *)dev->private))
+		return retval;
+
+	down(&vm->limit_sem);
+
+	/* We have an attached board ? */
+	if (!vm->probed) {
+		retval = -ENODEV;
+		goto error;
+	}
+
+	/* interrupt-in pipe busy ? */
+	if (vm->irq_in_busy) {
+		retval = -EBUSY;
+		goto error;
+	}
+
+	for (i = 0, ch = CR_CHAN(insn->chanspec); i < insn->n; i++) {
+		retval = vm_read(vm);
+		if (retval)
+			goto error;
+
+		/* NOTE:
+		 * The status of the selected digital input channel is read.
+		 */
+		inp = (((vm->irq_in_buf[VMK8055_DI] >> 4) & 0x03) |
+		       ((vm->irq_in_buf[VMK8055_DI] << 2) & 0x04) |
+		       ((vm->irq_in_buf[VMK8055_DI] >> 3) & 0x18));
+		data[i] = ((inp & (1 << ch)) > 0);
+	}
+
+	up(&vm->limit_sem);
+
+	return i;
+error:
+	up(&vm->limit_sem);
+
+	return retval;
+}
+
+static int vm_do_winsn(comedi_device *dev, comedi_subdevice *s,
+		       comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *vm;
+	int minor = dev->minor;
+	int ch, i, mask;
+	int retval = -EFAULT;
+
+	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+
+	if (!(vm = (struct vmk80xx_usb *)dev->private))
+		return retval;
+
+	down(&vm->limit_sem);
+
+	/* We have an attached board ? */
+	if (!vm->probed) {
+		retval = -ENODEV;
+		goto error;
+	}
+
+	/* interrupt-out pipe busy ? */
+	if (vm->irq_out_busy) {
+		retval = -EBUSY;
+		goto error;
+	}
+
+	for (i = 0, ch = CR_CHAN(insn->chanspec); i < insn->n; i++) {
+		/* NOTE:
+		 * The selected digital output channel is set or cleared.
+		 */
+		mask = (data[i] == 1)
+		     ? vm->irq_out_buf[VMK8055_DO] | (1 << ch)
+		     : vm->irq_out_buf[VMK8055_DO] ^ (1 << ch);
+
+		vm->irq_out_buf[VMK8055_DO] = mask;
+
+		retval = vm_write(vm, VMK8055_CMD_AD);
+		if (retval)
+			goto error;
+	}
+
+	up(&vm->limit_sem);
+
+	return i;
+error:
+	up(&vm->limit_sem);
+
+	return retval;
+}
+
+static int vm_cnt_rinsn(comedi_device *dev, comedi_subdevice *s,
+			comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *vm;
+	int minor = dev->minor;
+	int cnt, cnt_offs, i;
+	int retval = -EFAULT;
+
+	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+
+	if (!(vm = (struct vmk80xx_usb *)dev->private))
+		return retval;
+
+	down(&vm->limit_sem);
+
+	/* We have an attached board ? */
+	if (!vm->probed) {
+		retval = -ENODEV;
+		goto error;
+	}
+
+	/* interrupt-in pipe busy ? */
+	if (vm->irq_in_busy) {
+		retval = -EBUSY;
+		goto error;
+	}
+
+	cnt = CR_CHAN(insn->chanspec);
+	cnt_offs = (!cnt) ? VMK8055_CNT1 : VMK8055_CNT2;
+
+	for (i = 0; i < insn->n; i++) {
+		retval = vm_read(vm);
+		if (retval)
+			goto error;
+
+		/* NOTE:
+		 * The status of the selected 16-bit pulse counter is
+		 * read. The counter # 1 counts the pulses fed to the
+		 * input Inp1 and the counter # 2 counts the pulses fed
+		 * to the input Inp2.
+		 */
+		data[i] = vm->irq_in_buf[cnt_offs];
+	}
+
+	up(&vm->limit_sem);
+
+	return i;
+error:
+	up(&vm->limit_sem);
+
+	return retval;
+}
+
+static int vm_cnt_winsn(comedi_device *dev, comedi_subdevice *s,
+			comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *vm;
+	int minor = dev->minor;
+	int cnt, cnt_offs, cmd, i;
+	int retval = -EFAULT;
+
+	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+
+	if (!(vm = (struct vmk80xx_usb *)dev->private))
+		return retval;
+
+	down(&vm->limit_sem);
+
+	/* We have an attached board ? */
+	if (!vm->probed) {
+		retval = -ENODEV;
+		goto error;
+	}
+
+	/* interrupt-out pipe busy ? */
+	if (vm->irq_out_busy) {
+		retval = -EBUSY;
+		goto error;
+	}
+
+	cnt = CR_CHAN(insn->chanspec);
+	cnt_offs = (!cnt) ? VMK8055_CNT1 : VMK8055_CNT2;
+	cmd = (!cnt) ? VMK8055_CMD_RST_CNT1 : VMK8055_CMD_RST_CNT2;
+
+	for (i = 0; i < insn->n; i++) {
+		/* NOTE:
+		 * The selected 16-bit pulse counter is reset.
+		 */
+		vm->irq_out_buf[cnt_offs] = 0x00;
+
+		retval = vm_write(vm, cmd);
+		if (retval)
+			goto error;
+	}
+
+	up(&vm->limit_sem);
+
+	return i;
+error:
+	up(&vm->limit_sem);
+
+	return retval;
+}
+
+static int vm_cnt_cinsn(comedi_device *dev, comedi_subdevice *s,
+			comedi_insn *insn, unsigned int *data)
+{
+	struct vmk80xx_usb *vm;
+	int minor = dev->minor;
+	int cnt, cmd, i;
+	unsigned int debtime, val;
+	int retval = -EFAULT;
+
+	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+
+	if (!(vm = (struct vmk80xx_usb *)dev->private))
+		return retval;
+
+	down(&vm->limit_sem);
+
+	/* We have an attached board ? */
+	if (!vm->probed) {
+		retval = -ENODEV;
+		goto error;
+	}
+
+	/* interrupt-out pipe busy ? */
+	if (vm->irq_out_busy) {
+		retval = -EBUSY;
+		goto error;
+	}
+
+	cnt = CR_CHAN(insn->chanspec);
+	cmd = (!cnt) ? VMK8055_CMD_DEB1 : VMK8055_CMD_DEB2;
+
+	/* NOTE:
+	 * The counter inputs are debounced in the software to prevent
+	 * false triggering when mechanical switches or relay inputs
+	 * are used. The debounce time is equal for both falling and
+	 * rising edges. The default debounce time is 2ms. This means
+	 * the counter input must be stable for at least 2ms before it
+	 * is recognised , giving the maximum count rate of about 200
+	 * counts per second. If the debounce time is set to 0, then
+	 * the maximum counting rate is about 2000 counts per second.
+	 */
+	for (i = 0; i < insn->n; i++) {
+		debtime = data[i];
+		if (debtime == 0)
+			debtime = 1;
+		/* --------------------------------------------------
+		 * From libk8055.c
+		 * ---------------
+		 * Copyleft (C) 2005 by Sven Lindberg;
+		 * Copyright (C) 2007 by Pjetur G. Hjaltason:
+		 * By testing and measuring on the other hand I found
+		 * the formula dbt=0.115*x^2.........
+		 *
+		 * I'm using here an adapted formula to avoid floating
+		 * point operations inside the kernel. The time set
+		 * with this formula is within +-4% +- 1.
+		 * ------------------------------------------------ */
+		val = int_sqrt(debtime * 1000 / 115);
+		if (((val + 1) * val) < debtime * 1000 / 115)
+			val += 1;
+
+		vm->irq_out_buf[cnt+6] = val;
+
+		retval = vm_write(vm, cmd);
+		if (retval)
+			goto error;
+	}
+
+	up(&vm->limit_sem);
+
+	return i;
+error:
+	up(&vm->limit_sem);
+
+	return retval;
+}
+
+/* Comedi subdevice offsets */
+#define VMK8055_SUBD_AI_OFFSET	0
+#define VMK8055_SUBD_AO_OFFSET	1
+#define VMK8055_SUBD_DI_OFFSET	2
+#define VMK8055_SUBD_DO_OFFSET	3
+#define VMK8055_SUBD_CT_OFFSET	4
+
+static DEFINE_MUTEX(glb_mutex);
+
+/* ---------------------------------------------------------------------------
+ * Hook-up (or deallocate) the virtual device file '/dev/comedi[minor]' with
+ * the vmk80xx driver (comedi_config/rmmod).
+--------------------------------------------------------------------------- */
+static int vm_attach(comedi_device *dev, comedi_devconfig *it)
+{
+	comedi_subdevice *s;
+	int minor = dev->minor;
+	int idx, i;
+
+	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+
+	mutex_lock(&glb_mutex);
+
+	/* Prepare user info... */
+	printk("comedi%d: vmk80xx: ", minor);
+
+	idx = -1;
+
+	/* Find the last valid device which has been detected
+	 * by the probe function */;
+	for (i = 0; i < VMK8055_MAX_BOARDS; i++)
+		if (vm_boards[i].probed && !vm_boards[i].attached) {
+			idx = i;
+			break;
+		}
+
+	if (idx == -1) {
+		printk("no boards attached\n");
+		mutex_unlock(&glb_mutex);
+		return -ENODEV;
+	}
+
+	down(&vm_boards[idx].limit_sem);
+
+	/* OK, at that time we've an attached board and this is
+	 * the first execution of the comedi_config command for
+	 * this board */
+	printk("board #%d is attached to comedi\n", vm_boards[idx].id);
+
+	dev->board_name = "vmk80xx";
+	dev->private = vm_boards + idx; /* will be allocated in vm_probe */
+
+	/* Subdevices section -> set properties */
+	if (alloc_subdevices(dev, 5) < 0) {
+		printk("comedi%d: vmk80xx: couldn't allocate subdevs\n",
+		       minor);
+		up(&vm_boards[idx].limit_sem);
+		mutex_unlock(&glb_mutex);
+		return -ENOMEM;
+	}
+
+	s = dev->subdevices + VMK8055_SUBD_AI_OFFSET;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND;
+	s->n_chan = 2;
+	s->maxdata = 0xff; /* +5 Volt */
+	s->range_table = &range_unipolar5; /* +-0 Volt - +5 Volt */
+	s->insn_read = vm_ai_rinsn;
+
+	s = dev->subdevices + VMK8055_SUBD_AO_OFFSET;
+	s->type = COMEDI_SUBD_AO;
+	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
+	s->n_chan = 2;
+	s->maxdata = 0xff;
+	s->range_table = &range_unipolar5;
+	s->insn_write = vm_ao_winsn;
+
+	s = dev->subdevices + VMK8055_SUBD_DI_OFFSET;
+	s->type = COMEDI_SUBD_DI;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND;
+	s->n_chan = 5;
+	s->insn_read = vm_di_rinsn;
+
+	s = dev->subdevices + VMK8055_SUBD_DO_OFFSET;
+	s->type = COMEDI_SUBD_DO;
+	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND;
+	s->n_chan = 8;
+	s->maxdata = 1;
+	s->insn_write = vm_do_winsn;
+
+	s = dev->subdevices + VMK8055_SUBD_CT_OFFSET;
+	s->type = COMEDI_SUBD_COUNTER;
+	s->subdev_flags = SDF_READABLE | SDF_WRITEABLE;
+	s->n_chan = 2;
+	s->insn_read = vm_cnt_rinsn;
+	s->insn_write = vm_cnt_winsn; /* accept only a channel # as arg */
+	s->insn_config = vm_cnt_cinsn;
+
+	/* Register the comedi board connection */
+	vm_boards[idx].attached = 1;
+
+	up(&vm_boards[idx].limit_sem);
+
+	mutex_unlock(&glb_mutex);
+
+	return 0;
+}
+
+static int vm_detach(comedi_device *dev)
+{
+	struct vmk80xx_usb *vm;
+	int minor = dev->minor;
+
+	DBGVM("comedi%d: vmk80xx: %s\n", minor,  __func__);
+
+	if (!dev) { /* FIXME: I don't know if i need that here */
+		printk("comedi%d: vmk80xx: %s - dev is NULL\n",
+		       minor, __func__);
+		return -EFAULT;
+	}
+
+	if (!(vm = (struct vmk80xx_usb *)dev->private)) {
+		printk("comedi%d: vmk80xx: %s - dev->private is NULL\n",
+		       minor, __func__);
+		return -EFAULT;
+	}
+
+	/* NOTE: dev->private and dev->subdevices are deallocated
+	 * automatically by the comedi core */
+
+	down(&vm->limit_sem);
+
+	dev->private = NULL;
+	vm->attached = 0;
+
+	printk("comedi%d: vmk80xx: board #%d removed from comedi core\n",
+	       minor, vm->id);
+
+	up(&vm->limit_sem);
+
+	return 0;
+}
+
+/* ---------------------------------------------------------------------------
+ * Hook-up or remove the Velleman board from the usb.
+--------------------------------------------------------------------------- */
+static int vm_probe(struct usb_interface *itf, const struct usb_device_id *id)
+{
+	struct usb_device *udev;
+	int idx, i;
+	u16 product_id;
+	int retval = -ENOMEM;
+
+	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+
+	mutex_lock(&glb_mutex);
+
+	udev = interface_to_usbdev(itf);
+
+	idx = -1;
+
+	/* TODO: k8061 only theoretically supported yet */
+	product_id = le16_to_cpu(udev->descriptor.idProduct);
+	if (product_id == 0x8061) {
+		printk("comedi#: vmk80xx: Velleman K8061 detected "
+		       "(no COMEDI support available yet)\n");
+		mutex_unlock(&glb_mutex);
+		return -ENODEV;
+	}
+
+	/* Look for a free place to put the board into the array */
+	for (i = 0; i < VMK8055_MAX_BOARDS; i++) {
+		if (!vm_boards[i].probed) {
+			idx = i;
+			i = VMK8055_MAX_BOARDS;
+		}
+	}
+
+	if (idx == -1) {
+		printk("comedi#: vmk80xx: only FOUR boards supported\n");
+		mutex_unlock(&glb_mutex);
+		return -EMFILE;
+	}
+
+	/* Initialize device states (hard coded) */
+	vm_boards[idx].intf = itf;
+
+	/* interrupt-in context */
+	vm_boards[idx].irq_in_endpoint = VMK8055_EP_IN;
+	vm_boards[idx].irq_in_interval = VMK8055_EP_INTERVAL;
+	vm_boards[idx].irq_in_endpoint_size = VMK8055_EP_SIZE;
+	vm_boards[idx].irq_in_buf = kmalloc(VMK8055_EP_SIZE, GFP_KERNEL);
+	if (!vm_boards[idx].irq_in_buf) {
+		err("comedi#: vmk80xx: couldn't alloc irq_in_buf\n");
+		goto error;
+	}
+
+	/* interrupt-out context */
+	vm_boards[idx].irq_out_endpoint = VMK8055_EP_OUT;
+	vm_boards[idx].irq_out_interval = VMK8055_EP_INTERVAL;
+	vm_boards[idx].irq_out_endpoint_size = VMK8055_EP_SIZE;
+	vm_boards[idx].irq_out_buf = kmalloc(VMK8055_EP_SIZE, GFP_KERNEL);
+	if (!vm_boards[idx].irq_out_buf) {
+		err("comedi#: vmk80xx: couldn't alloc irq_out_buf\n");
+		goto error;
+	}
+
+	/* Endpoints located ? */
+	if (!vm_boards[idx].irq_in_endpoint) {
+		err("comedi#: vmk80xx: int-in endpoint not found\n");
+		goto error;
+	}
+
+	if (!vm_boards[idx].irq_out_endpoint) {
+		err("comedi#: vmk80xx: int-out endpoint not found\n");
+		goto error;
+	}
+
+	/* Try to allocate in/out urbs */
+	vm_boards[idx].irq_in_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!vm_boards[idx].irq_in_urb) {
+		err("comedi#: vmk80xx: couldn't alloc irq_in_urb\n");
+		goto error;
+	}
+
+	vm_boards[idx].irq_out_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!vm_boards[idx].irq_out_urb) {
+		err("comedi#: vmk80xx: couldn't alloc irq_out_urb\n");
+		goto error;
+	}
+
+	/* Reset the device */
+	vm_boards[idx].irq_out_buf[0] = VMK8055_CMD_RST;
+	vm_boards[idx].irq_out_buf[1] = 0x00;
+	vm_boards[idx].irq_out_buf[2] = 0x00;
+	vm_boards[idx].irq_out_buf[3] = 0x00;
+	vm_boards[idx].irq_out_buf[4] = 0x00;
+	vm_boards[idx].irq_out_buf[5] = 0x00;
+	vm_boards[idx].irq_out_buf[6] = 0x00;
+	vm_boards[idx].irq_out_buf[7] = 0x00;
+
+	usb_fill_int_urb(vm_boards[idx].irq_out_urb,
+			 udev,
+			 usb_sndintpipe(udev,
+					vm_boards[idx].irq_out_endpoint),
+			 vm_boards[idx].irq_out_buf,
+			 vm_boards[idx].irq_out_endpoint_size,
+			 vm_irq_out_callback,
+			 &vm_boards[idx],
+			 vm_boards[idx].irq_out_interval);
+
+	retval = usb_submit_urb(vm_boards[idx].irq_out_urb, GFP_KERNEL);
+	if (retval)
+		DBGCM("comedi#: vmk80xx: device reset failed (err #%d)\n",
+		      retval);
+	else
+		DBGCM("comedi#: vmk80xx: device reset success\n");
+
+
+	usb_set_intfdata(itf, &vm_boards[idx]);
+
+	/* Show some debugging messages if required */
+	DBGCM("comedi#: vmk80xx: [<-] ep addr 0x%02x size %d interval %d\n",
+	      vm_boards[idx].irq_in_endpoint,
+	      vm_boards[idx].irq_in_endpoint_size,
+	      vm_boards[idx].irq_in_interval);
+	DBGCM("comedi#: vmk80xx: [->] ep addr 0x%02x size %d interval %d\n",
+	      vm_boards[idx].irq_out_endpoint,
+	      vm_boards[idx].irq_out_endpoint_size,
+	      vm_boards[idx].irq_out_interval);
+
+	vm_boards[idx].id = idx;
+
+	/* Let the user know that the device is now attached */
+	printk("comedi#: vmk80xx: K8055 board #%d now attached\n",
+	       vm_boards[idx].id);
+
+	/* We have an attached velleman board */
+	vm_boards[idx].probed = 1;
+
+	mutex_unlock(&glb_mutex);
+
+	return retval;
+error:
+	vm_delete(&vm_boards[idx]);
+
+	mutex_unlock(&glb_mutex);
+
+	return retval;
+}
+
+static void vm_disconnect(struct usb_interface *intf)
+{
+	struct vmk80xx_usb *vm;
+
+	DBGVM("comedi#: vmk80xx: %s\n", __func__);
+
+	vm = (struct vmk80xx_usb *)usb_get_intfdata(intf);
+	if (!vm) {
+		printk("comedi#: vmk80xx: %s - vm is NULL\n", __func__);
+		return; /* -EFAULT */
+	}
+
+	mutex_lock(&glb_mutex);
+	/* Twill be needed if the driver supports more than one board */
+	down(&vm->limit_sem);
+
+	vm->probed = 0; /* we have -1 attached boards */
+	usb_set_intfdata(vm->intf, NULL);
+
+	vm_delete(vm); /* tidy up */
+
+	/* Twill be needed if the driver supports more than one board */
+	up(&vm->limit_sem);
+	mutex_unlock(&glb_mutex);
+
+	printk("comedi#: vmk80xx: Velleman board #%d now detached\n",
+	       vm->id);
+}
+
+/* ---------------------------------------------------------------------------
+ * Register/Deregister this driver with/from the usb subsystem and the comedi.
+--------------------------------------------------------------------------- */
+static struct usb_driver vm_driver = {
+#ifdef COMEDI_HAVE_USB_DRIVER_OWNER
+	.owner =	THIS_MODULE,
+#endif
+	.name =		"vmk80xx",
+	.probe =	vm_probe,
+	.disconnect =	vm_disconnect,
+	.id_table =	vm_id_table,
+};
+
+static comedi_driver driver_vm = {
+	.module =	THIS_MODULE,
+	.driver_name =	"vmk80xx",
+	.attach =	vm_attach,
+	.detach =	vm_detach,
+};
+
+static int __init vm_init(void)
+{
+	int retval, idx;
+
+	printk("vmk80xx: version " VMK80XX_MODULE_VERSION " -"
+				 " Manuel Gebele <forensixs@gmx.de>\n");
+
+	for (idx = 0; idx < VMK8055_MAX_BOARDS; idx++) {
+		memset(&vm_boards[idx], 0x00, sizeof(vm_boards[idx]));
+		init_MUTEX(&vm_boards[idx].limit_sem);
+		init_waitqueue_head(&vm_boards[idx].read_wait);
+		init_waitqueue_head(&vm_boards[idx].write_wait);
+	}
+
+	/* Register with the usb subsystem */
+	retval = usb_register(&vm_driver);
+	if (retval) {
+		err("vmk80xx: usb subsystem registration failed (err #%d)\n",
+		    retval);
+		return retval;
+	}
+
+	/* Register with the comedi core */
+	retval = comedi_driver_register(&driver_vm);
+	if (retval) {
+		err("vmk80xx: comedi core registration failed (err #%d)\n",
+		    retval);
+		usb_deregister(&vm_driver);
+	}
+
+	return retval;
+}
+
+static void __exit vm_exit(void)
+{
+	comedi_driver_unregister(&driver_vm);
+	usb_deregister(&vm_driver);
+}
+module_init(vm_init);
+module_exit(vm_exit);
