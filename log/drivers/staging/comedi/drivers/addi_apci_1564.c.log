commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 1956a169f78b..10501fe6bb25 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -10,16 +10,6 @@
  *	Fax: +49(0)7223/9493-92
  *	http://www.addi-data.com
  *	info@addi-data.com
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License as published by the Free Software
- * Foundation; either version 2 of the License, or (at your option) any later
- * version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
- * details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 9bfb79c2e5c8..1956a169f78b 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * addi_apci_1564.c
  * Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.

commit 20cefae2d278a056417c24315d0b0cd8d3e97c9a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jun 8 11:26:43 2016 -0700

    staging: comedi: addi_apci_1564: remove unnecessary wdog register defines
    
    The watchdog subdevice is supported using the addi_watchdog module and
    it uses the register defines from addi_tcw.h. The only register define
    needed it the iobase offset to the register block.
    
    Remove the unnecessary defines and rename the iobase define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 5813de51faf1..9bfb79c2e5c8 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -144,14 +144,7 @@
 #define APCI1564_DO_INT_STATUS_VCC		BIT(0)
 #define APCI1564_DO_IRQ_REG			0x20
 #define APCI1564_DO_IRQ_INTR			BIT(0)
-#define APCI1564_WDOG_REG			0x24
-#define APCI1564_WDOG_RELOAD_REG		0x28
-#define APCI1564_WDOG_TIMEBASE_REG		0x2c
-#define APCI1564_WDOG_CTRL_REG			0x30
-#define APCI1564_WDOG_STATUS_REG		0x34
-#define APCI1564_WDOG_IRQ_REG			0x38
-#define APCI1564_WDOG_WARN_TIMEVAL_REG		0x3c
-#define APCI1564_WDOG_WARN_TIMEBASE_REG		0x40
+#define APCI1564_WDOG_IOBASE			0x24
 
 /*
  * devpriv->timer Register Map (see addi_tcw.h for register/bit defines)
@@ -198,7 +191,7 @@ static int apci1564_reset(struct comedi_device *dev)
 	outl(0x0, dev->iobase + APCI1564_DO_INT_CTRL_REG);
 
 	/* Reset the watchdog registers */
-	addi_watchdog_reset(dev->iobase + APCI1564_WDOG_REG);
+	addi_watchdog_reset(dev->iobase + APCI1564_WDOG_IOBASE);
 
 	/* Reset the timer registers */
 	outl(0x0, devpriv->timer + ADDI_TCW_CTRL_REG);
@@ -773,7 +766,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 	/* Initialize the watchdog subdevice */
 	s = &dev->subdevices[5];
-	ret = addi_watchdog_init(s, dev->iobase + APCI1564_WDOG_REG);
+	ret = addi_watchdog_init(s, dev->iobase + APCI1564_WDOG_IOBASE);
 	if (ret)
 		return ret;
 

commit 2ec19efbc8d4c5646b8205564678568fa26e4b32
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jun 8 11:26:42 2016 -0700

    staging: comedi: addi_apci_1564: rewrite the counter subdevice support
    
    Like the timer, the support functions for the counter subdevice are broken.
    
    Rewrite the code to follow the comedi API.
    
    The new implementation is based on the (minimal) datasheet I have from
    ADDI-DATA.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 3e8ac67fcb50..5813de51faf1 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -67,6 +67,12 @@
  * the raw data[1] to this register along with the raw data[2] value to the
  * ADDI_TCW_RELOAD_REG. If anyone tests this and can determine the actual
  * timebase/reload operation please let me know.
+ *
+ * The counter subdevice also does not use an async command. All control is
+ * handled by the (*insn_config).
+ *
+ * FIXME: The operation of the counters is not really described in the
+ * datasheet I have. The (*insn_config) needs more work.
  */
 
 #include <linux/module.h>
@@ -177,8 +183,6 @@ struct apci1564_private {
 	unsigned int ctrl;	/* interrupt mode OR (edge) . AND (level) */
 };
 
-#include "addi-data/hwdrv_apci1564.c"
-
 static int apci1564_reset(struct comedi_device *dev)
 {
 	struct apci1564_private *devpriv = dev->private;
@@ -573,6 +577,92 @@ static int apci1564_timer_insn_read(struct comedi_device *dev,
 	return insn->n;
 }
 
+static int apci1564_counter_insn_config(struct comedi_device *dev,
+					struct comedi_subdevice *s,
+					struct comedi_insn *insn,
+					unsigned int *data)
+{
+	struct apci1564_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned long iobase = devpriv->counters + APCI1564_COUNTER(chan);
+	unsigned int val;
+
+	switch (data[0]) {
+	case INSN_CONFIG_ARM:
+		val = inl(iobase + ADDI_TCW_CTRL_REG);
+		val |= ADDI_TCW_CTRL_IRQ_ENA | ADDI_TCW_CTRL_CNTR_ENA;
+		outl(data[1], iobase + ADDI_TCW_RELOAD_REG);
+		outl(val, iobase + ADDI_TCW_CTRL_REG);
+		break;
+	case INSN_CONFIG_DISARM:
+		val = inl(iobase + ADDI_TCW_CTRL_REG);
+		val &= ~(ADDI_TCW_CTRL_IRQ_ENA | ADDI_TCW_CTRL_CNTR_ENA);
+		outl(val, iobase + ADDI_TCW_CTRL_REG);
+		break;
+	case INSN_CONFIG_SET_COUNTER_MODE:
+		/*
+		 * FIXME: The counter operation is not described in the
+		 * datasheet. For now just write the raw data[1] value to
+		 * the control register.
+		 */
+		outl(data[1], iobase + ADDI_TCW_CTRL_REG);
+		break;
+	case INSN_CONFIG_GET_COUNTER_STATUS:
+		data[1] = 0;
+		val = inl(iobase + ADDI_TCW_CTRL_REG);
+		if (val & ADDI_TCW_CTRL_IRQ_ENA)
+			data[1] |= COMEDI_COUNTER_ARMED;
+		if (val & ADDI_TCW_CTRL_CNTR_ENA)
+			data[1] |= COMEDI_COUNTER_COUNTING;
+		val = inl(iobase + ADDI_TCW_STATUS_REG);
+		if (val & ADDI_TCW_STATUS_OVERFLOW)
+			data[1] |= COMEDI_COUNTER_TERMINAL_COUNT;
+		data[2] = COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING |
+			  COMEDI_COUNTER_TERMINAL_COUNT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return insn->n;
+}
+
+static int apci1564_counter_insn_write(struct comedi_device *dev,
+				       struct comedi_subdevice *s,
+				       struct comedi_insn *insn,
+				       unsigned int *data)
+{
+	struct apci1564_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned long iobase = devpriv->counters + APCI1564_COUNTER(chan);
+
+	/* just write the last last to the reload register */
+	if (insn->n) {
+		unsigned int val = data[insn->n - 1];
+
+		outl(val, iobase + ADDI_TCW_RELOAD_REG);
+	}
+
+	return insn->n;
+}
+
+static int apci1564_counter_insn_read(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
+{
+	struct apci1564_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned long iobase = devpriv->counters + APCI1564_COUNTER(chan);
+	int i;
+
+	/* return the actual value of the counter */
+	for (i = 0; i < insn->n; i++)
+		data[i] = inl(iobase + ADDI_TCW_VAL_REG);
+
+	return insn->n;
+}
+
 static int apci1564_auto_attach(struct comedi_device *dev,
 				unsigned long context_unused)
 {

commit 05704ffafaea7b5176b4469d48487c86cba4861b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jun 8 11:26:41 2016 -0700

    staging: comedi: addi_apci_1564: rewrite the timer subdevice support
    
    The support functions for the timer subdevice are broken.
    
    1) The (*insn_write) assumes that insn->n is always 2 (data[1] is used)
    2) The (*insn_read) assumes that insn->n is always 2 (data can be returned in
       data[0] and data[1]).
    3) The (*insn_config) does not follow the API. It assumes insn->n is always 4
       (data[1], data[2] and data[3] are used). It also doesn't use data[0] to
       determine what the config "instruction" is.
    
    Rewrite the code to follow the comedi API and add the missing comedi driver
    comment block.
    
    The new implementation is based on the (minimal) datasheet I have from
    ADDI-DATA.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 4af45d8bf3ec..3e8ac67fcb50 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -21,6 +21,54 @@
  * details.
  */
 
+/*
+ * Driver: addi_apci_1564
+ * Description: ADDI-DATA APCI-1564 Digital I/O board
+ * Devices: [ADDI-DATA] APCI-1564 (addi_apci_1564)
+ * Author: H Hartley Sweeten <hsweeten@visionengravers.com>
+ * Updated: Thu, 02 Jun 2016 13:12:46 -0700
+ * Status: untested
+ *
+ * Configuration Options: not applicable, uses comedi PCI auto config
+ *
+ * This board has the following features:
+ *   - 32 optically isolated digital inputs (24V), 16 of which can
+ *     generate change-of-state (COS) interrupts (channels 4 to 19)
+ *   - 32 optically isolated digital outputs (10V to 36V)
+ *   - 1 8-bit watchdog for resetting the outputs
+ *   - 1 12-bit timer
+ *   - 3 32-bit counters
+ *   - 2 diagnostic inputs
+ *
+ * The COS, timer, and counter subdevices all use the dev->read_subdev to
+ * return the interrupt status. The sample data is updated and returned when
+ * any of these subdevices generate an interrupt. The sample data format is:
+ *
+ *    Bit   Description
+ *   -----  ------------------------------------------
+ *    31    COS interrupt
+ *    30    timer interrupt
+ *    29    counter 2 interrupt
+ *    28    counter 1 interrupt
+ *    27    counter 0 interrupt
+ *   26:20  not used
+ *   19:4   COS digital input state (channels 19 to 4)
+ *    3:0   not used
+ *
+ * The COS interrupts must be configured using an INSN_CONFIG_DIGITAL_TRIG
+ * instruction before they can be enabled by an async command. The COS
+ * interrupts will stay active until canceled.
+ *
+ * The timer subdevice does not use an async command. All control is handled
+ * by the (*insn_config).
+ *
+ * FIXME: The format of the ADDI_TCW_TIMEBASE_REG is not descibed in the
+ * datasheet I have. The INSN_CONFIG_SET_CLOCK_SRC currently just writes
+ * the raw data[1] to this register along with the raw data[2] value to the
+ * ADDI_TCW_RELOAD_REG. If anyone tests this and can determine the actual
+ * timebase/reload operation please let me know.
+ */
+
 #include <linux/module.h>
 #include <linux/interrupt.h>
 
@@ -444,6 +492,87 @@ static int apci1564_cos_cancel(struct comedi_device *dev,
 	return 0;
 }
 
+static int apci1564_timer_insn_config(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
+{
+	struct apci1564_private *devpriv = dev->private;
+	unsigned int val;
+
+	switch (data[0]) {
+	case INSN_CONFIG_ARM:
+		if (data[1] > s->maxdata)
+			return -EINVAL;
+		outl(data[1], devpriv->timer + ADDI_TCW_RELOAD_REG);
+		outl(ADDI_TCW_CTRL_IRQ_ENA | ADDI_TCW_CTRL_TIMER_ENA,
+		     devpriv->timer + ADDI_TCW_CTRL_REG);
+		break;
+	case INSN_CONFIG_DISARM:
+		outl(0x0, devpriv->timer + ADDI_TCW_CTRL_REG);
+		break;
+	case INSN_CONFIG_GET_COUNTER_STATUS:
+		data[1] = 0;
+		val = inl(devpriv->timer + ADDI_TCW_CTRL_REG);
+		if (val & ADDI_TCW_CTRL_IRQ_ENA)
+			data[1] |= COMEDI_COUNTER_ARMED;
+		if (val & ADDI_TCW_CTRL_TIMER_ENA)
+			data[1] |= COMEDI_COUNTER_COUNTING;
+		val = inl(devpriv->timer + ADDI_TCW_STATUS_REG);
+		if (val & ADDI_TCW_STATUS_OVERFLOW)
+			data[1] |= COMEDI_COUNTER_TERMINAL_COUNT;
+		data[2] = COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING |
+			  COMEDI_COUNTER_TERMINAL_COUNT;
+		break;
+	case INSN_CONFIG_SET_CLOCK_SRC:
+		if (data[2] > s->maxdata)
+			return -EINVAL;
+		outl(data[1], devpriv->timer + ADDI_TCW_TIMEBASE_REG);
+		outl(data[2], devpriv->timer + ADDI_TCW_RELOAD_REG);
+		break;
+	case INSN_CONFIG_GET_CLOCK_SRC:
+		data[1] = inl(devpriv->timer + ADDI_TCW_TIMEBASE_REG);
+		data[2] = inl(devpriv->timer + ADDI_TCW_RELOAD_REG);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return insn->n;
+}
+
+static int apci1564_timer_insn_write(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
+{
+	struct apci1564_private *devpriv = dev->private;
+
+	/* just write the last last to the reload register */
+	if (insn->n) {
+		unsigned int val = data[insn->n - 1];
+
+		outl(val, devpriv->timer + ADDI_TCW_RELOAD_REG);
+	}
+
+	return insn->n;
+}
+
+static int apci1564_timer_insn_read(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
+{
+	struct apci1564_private *devpriv = dev->private;
+	int i;
+
+	/* return the actual value of the timer */
+	for (i = 0; i < insn->n; i++)
+		data[i] = inl(devpriv->timer + ADDI_TCW_VAL_REG);
+
+	return insn->n;
+}
+
 static int apci1564_auto_attach(struct comedi_device *dev,
 				unsigned long context_unused)
 {

commit a23b85a5ab9f19936ac673104f0e5b57a7ab13a1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jun 8 11:26:40 2016 -0700

    staging: comedi: addi_apci_1564: use comedi_handle_event() for counters
    
    The counter subdevice can generate an interrupt. Currently send_sig() is used
    to let the task know when the interrupt occurs. Use the dev->read_subdev and
    comedi_handle_events() instead.
    
    Remove the, now unused, 'tsk_current' member from the private data and the
    unnecessary include of <linux/sched.h>.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 45c1558a4961..4af45d8bf3ec 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -23,7 +23,6 @@
 
 #include <linux/module.h>
 #include <linux/interrupt.h>
-#include <linux/sched.h>
 
 #include "../comedi_pci.h"
 #include "addi_tcw.h"
@@ -118,6 +117,7 @@
  */
 #define APCI1564_EVENT_COS			BIT(31)
 #define APCI1564_EVENT_TIMER			BIT(30)
+#define APCI1564_EVENT_COUNTER(x)		BIT(27 + (x)) /* counter 0-2 */
 #define APCI1564_EVENT_MASK			0xfff0000f /* all but [19:4] */
 
 struct apci1564_private {
@@ -127,7 +127,6 @@ struct apci1564_private {
 	unsigned int mode1;	/* rising-edge/high level channels */
 	unsigned int mode2;	/* falling-edge/low level channels */
 	unsigned int ctrl;	/* interrupt mode OR (edge) . AND (level) */
-	struct task_struct *tsk_current;
 };
 
 #include "addi-data/hwdrv_apci1564.c"
@@ -200,21 +199,18 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 	}
 
 	if (devpriv->counters) {
-		for (chan = 0; chan < 4; chan++) {
+		for (chan = 0; chan < 3; chan++) {
 			unsigned long iobase;
 
 			iobase = devpriv->counters + APCI1564_COUNTER(chan);
 
 			status = inl(iobase + ADDI_TCW_IRQ_REG);
-			if (status & 0x01) {
-				/*  Disable Counter Interrupt */
+			if (status & ADDI_TCW_IRQ) {
+				s->state |= APCI1564_EVENT_COUNTER(chan);
+
+				/* clear the interrupt */
 				ctrl = inl(iobase + ADDI_TCW_CTRL_REG);
 				outl(0x0, iobase + ADDI_TCW_CTRL_REG);
-
-				/* Send a signal to from kernel to user space */
-				send_sig(SIGIO, devpriv->tsk_current, 0);
-
-				/*  Enable Counter Interrupt */
 				outl(ctrl, iobase + ADDI_TCW_CTRL_REG);
 			}
 		}

commit ff9842b651c501a2f13295035c5eb48d4b8e49b3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jun 8 11:26:39 2016 -0700

    staging: comedi: addi_apci_1564: use comedi_handle_event() for timer
    
    The timer subdevice can generate an interrupt. Currently send_sig() is used
    to let the task know when the interrupt occurs. Use the dev->read_subdev
    and comedi_handle_events() instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 9350f592c8b6..45c1558a4961 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -117,6 +117,7 @@
  * the state of the interrupt capable inputs.
  */
 #define APCI1564_EVENT_COS			BIT(31)
+#define APCI1564_EVENT_TIMER			BIT(30)
 #define APCI1564_EVENT_MASK			0xfff0000f /* all but [19:4] */
 
 struct apci1564_private {
@@ -189,15 +190,12 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 	}
 
 	status = inl(devpriv->timer + ADDI_TCW_IRQ_REG);
-	if (status & 0x01) {
-		/*  Disable Timer Interrupt */
+	if (status & ADDI_TCW_IRQ) {
+		s->state |= APCI1564_EVENT_TIMER;
+
+		/* clear the interrupt */
 		ctrl = inl(devpriv->timer + ADDI_TCW_CTRL_REG);
 		outl(0x0, devpriv->timer + ADDI_TCW_CTRL_REG);
-
-		/* Send a signal to from kernel to user space */
-		send_sig(SIGIO, devpriv->tsk_current, 0);
-
-		/*  Enable Timer Interrupt */
 		outl(ctrl, devpriv->timer + ADDI_TCW_CTRL_REG);
 	}
 

commit 931987a0c6da7404f64e650fa3fd2d5659c61280
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jun 8 11:26:38 2016 -0700

    staging: comedi: addi_apci_1564: clarify change-of-state interrupt support
    
    This board supports change-of-state interrupts on digital inputs 4 to 19
    not 0 to 15.
    
    The current code "works" but it could set inappropriate bits in the mode1
    and mode2 registers that setup which channels are enabled. It also doesn't
    return the status of the upper 4 channels (19 to 16).
    
    Fix the comment and mask the mode1/mode2 values so that only the interrupt
    capable channels can be enabled.
    
    Add the SDF_LSAMPL flag to the subdevice so that 32-bit samples are used
    instead of 16-bit ones. This allows returning the upper 4 channels. Use
    the remaining bits in the sample to return "event" flags to the user.
    
    The timer and counter subdevices can also generate interrupts and are a bit
    hacked. They don't currently follow the comedi API and they use send_sig()
    to let the task that know that the interrupt occured. The "event" flags will
    be used instead when these subdevices are fixed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index f1ccfbd4c578..9350f592c8b6 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -77,6 +77,7 @@
 #define APCI1564_DI_REG				0x00
 #define APCI1564_DI_INT_MODE1_REG		0x04
 #define APCI1564_DI_INT_MODE2_REG		0x08
+#define APCI1564_DI_INT_MODE_MASK		0x000ffff0 /* chans [19:4] */
 #define APCI1564_DI_INT_STATUS_REG		0x0c
 #define APCI1564_DI_IRQ_REG			0x10
 #define APCI1564_DI_IRQ_ENA			BIT(2)
@@ -111,11 +112,18 @@
  */
 #define APCI1564_COUNTER(x)			((x) * 0x20)
 
+/*
+ * The dev->read_subdev is used to return the interrupt events along with
+ * the state of the interrupt capable inputs.
+ */
+#define APCI1564_EVENT_COS			BIT(31)
+#define APCI1564_EVENT_MASK			0xfff0000f /* all but [19:4] */
+
 struct apci1564_private {
 	unsigned long eeprom;	/* base address of EEPROM register */
 	unsigned long timer;	/* base address of 12-bit timer */
 	unsigned long counters;	/* base address of 32-bit counters */
-	unsigned int mode1;	/* riding-edge/high level channels */
+	unsigned int mode1;	/* rising-edge/high level channels */
 	unsigned int mode2;	/* falling-edge/low level channels */
 	unsigned int ctrl;	/* interrupt mode OR (edge) . AND (level) */
 	struct task_struct *tsk_current;
@@ -165,18 +173,18 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 	unsigned int ctrl;
 	unsigned int chan;
 
+	s->state &= ~APCI1564_EVENT_MASK;
+
 	status = inl(dev->iobase + APCI1564_DI_IRQ_REG);
 	if (status & APCI1564_DI_IRQ_ENA) {
-		/* disable the interrupt */
+		/* get the COS interrupt state and set the event flag */
+		s->state = inl(dev->iobase + APCI1564_DI_INT_STATUS_REG);
+		s->state &= APCI1564_DI_INT_MODE_MASK;
+		s->state |= APCI1564_EVENT_COS;
+
+		/* clear the interrupt */
 		outl(status & ~APCI1564_DI_IRQ_ENA,
 		     dev->iobase + APCI1564_DI_IRQ_REG);
-
-		s->state = inl(dev->iobase + APCI1564_DI_INT_STATUS_REG) &
-			   0xffff;
-		comedi_buf_write_samples(s, &s->state, 1);
-		comedi_handle_events(dev, s);
-
-		/* enable the interrupt */
 		outl(status, dev->iobase + APCI1564_DI_IRQ_REG);
 	}
 
@@ -214,6 +222,11 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 		}
 	}
 
+	if (s->state & APCI1564_EVENT_MASK) {
+		comedi_buf_write_samples(s, &s->state, 1);
+		comedi_handle_events(dev, s);
+	}
+
 	return IRQ_HANDLED;
 }
 
@@ -255,7 +268,7 @@ static int apci1564_diag_insn_bits(struct comedi_device *dev,
 /*
  * Change-Of-State (COS) interrupt configuration
  *
- * Channels 0 to 15 are interruptible. These channels can be configured
+ * Channels 4 to 19 are interruptible. These channels can be configured
  * to generate interrupts based on AND/OR logic for the desired channels.
  *
  *	OR logic
@@ -343,6 +356,10 @@ static int apci1564_cos_insn_config(struct comedi_device *dev,
 		default:
 			return -EINVAL;
 		}
+
+		/* ensure the mode bits are in-range for channels [19:4] */
+		devpriv->mode1 &= APCI1564_DI_INT_MODE_MASK;
+		devpriv->mode2 &= APCI1564_DI_INT_MODE_MASK;
 		break;
 	default:
 		return -EINVAL;
@@ -409,7 +426,7 @@ static int apci1564_cos_cmd(struct comedi_device *dev,
 {
 	struct apci1564_private *devpriv = dev->private;
 
-	if (!devpriv->ctrl) {
+	if (!devpriv->ctrl && !(devpriv->mode1 || devpriv->mode2)) {
 		dev_warn(dev->class_dev,
 			 "Interrupts disabled due to mode configuration!\n");
 		return -EINVAL;
@@ -501,7 +518,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	if (dev->irq) {
 		dev->read_subdev = s;
 		s->type		= COMEDI_SUBD_DI;
-		s->subdev_flags	= SDF_READABLE | SDF_CMD_READ;
+		s->subdev_flags	= SDF_READABLE | SDF_CMD_READ | SDF_LSAMPL;
 		s->n_chan	= 1;
 		s->maxdata	= 1;
 		s->range_table	= &range_digital;

commit 836b8f2304a0363e98631f8cbccbe962d7dc23ab
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 7 11:45:07 2015 -0700

    staging: comedi: addi_apci_1564: tidy up APCI1564_EEPROM_REG bit defines
    
    Use the BIT() macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index ae8446ec213e..f1ccfbd4c578 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -44,12 +44,12 @@
  *   0x48 - 0x64  Timer 12-Bit
  */
 #define APCI1564_EEPROM_REG			0x00
-#define APCI1564_EEPROM_VCC_STATUS		(1 << 8)
+#define APCI1564_EEPROM_VCC_STATUS		BIT(8)
 #define APCI1564_EEPROM_TO_REV(x)		(((x) >> 4) & 0xf)
-#define APCI1564_EEPROM_DI			(1 << 3)
-#define APCI1564_EEPROM_DO			(1 << 2)
-#define APCI1564_EEPROM_CS			(1 << 1)
-#define APCI1564_EEPROM_CLK			(1 << 0)
+#define APCI1564_EEPROM_DI			BIT(3)
+#define APCI1564_EEPROM_DO			BIT(2)
+#define APCI1564_EEPROM_CS			BIT(1)
+#define APCI1564_EEPROM_CLK			BIT(0)
 #define APCI1564_REV1_TIMER_IOBASE		0x04
 #define APCI1564_REV2_MAIN_IOBASE		0x04
 #define APCI1564_REV2_TIMER_IOBASE		0x48

commit 9f750d15a1d8387605745c89c21cf46d4ddd4cd0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 7 11:45:06 2015 -0700

    staging: comedi: addi_apci_1564: define the APCI1564_DI_IRQ_REG bits
    
    Define the bits in this register. Remove the old defines in hwdrv_apci1564.c.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 2664bfa7b8f1..ae8446ec213e 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -79,6 +79,8 @@
 #define APCI1564_DI_INT_MODE2_REG		0x08
 #define APCI1564_DI_INT_STATUS_REG		0x0c
 #define APCI1564_DI_IRQ_REG			0x10
+#define APCI1564_DI_IRQ_ENA			BIT(2)
+#define APCI1564_DI_IRQ_MODE			BIT(1)	/* 1=AND, 0=OR */
 #define APCI1564_DO_REG				0x14
 #define APCI1564_DO_INT_CTRL_REG		0x18
 #define APCI1564_DO_INT_CTRL_CC_INT_ENA		BIT(1)
@@ -164,9 +166,9 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 	unsigned int chan;
 
 	status = inl(dev->iobase + APCI1564_DI_IRQ_REG);
-	if (status & APCI1564_DI_INT_ENABLE) {
+	if (status & APCI1564_DI_IRQ_ENA) {
 		/* disable the interrupt */
-		outl(status & APCI1564_DI_INT_DISABLE,
+		outl(status & ~APCI1564_DI_IRQ_ENA,
 		     dev->iobase + APCI1564_DI_IRQ_REG);
 
 		s->state = inl(dev->iobase + APCI1564_DI_INT_STATUS_REG) &
@@ -305,11 +307,9 @@ static int apci1564_cos_insn_config(struct comedi_device *dev,
 			outl(0x0, dev->iobase + APCI1564_DI_INT_MODE2_REG);
 			break;
 		case COMEDI_DIGITAL_TRIG_ENABLE_EDGES:
-			if (devpriv->ctrl != (APCI1564_DI_INT_ENABLE |
-					      APCI1564_DI_INT_OR)) {
+			if (devpriv->ctrl != APCI1564_DI_IRQ_ENA) {
 				/* switching to 'OR' mode */
-				devpriv->ctrl = APCI1564_DI_INT_ENABLE |
-						APCI1564_DI_INT_OR;
+				devpriv->ctrl = APCI1564_DI_IRQ_ENA;
 				/* wipe old channels */
 				devpriv->mode1 = 0;
 				devpriv->mode2 = 0;
@@ -323,11 +323,11 @@ static int apci1564_cos_insn_config(struct comedi_device *dev,
 			devpriv->mode2 |= data[5] << shift;
 			break;
 		case COMEDI_DIGITAL_TRIG_ENABLE_LEVELS:
-			if (devpriv->ctrl != (APCI1564_DI_INT_ENABLE |
-					      APCI1564_DI_INT_AND)) {
+			if (devpriv->ctrl != (APCI1564_DI_IRQ_ENA |
+					      APCI1564_DI_IRQ_MODE)) {
 				/* switching to 'AND' mode */
-				devpriv->ctrl = APCI1564_DI_INT_ENABLE |
-						APCI1564_DI_INT_AND;
+				devpriv->ctrl = APCI1564_DI_IRQ_ENA |
+						APCI1564_DI_IRQ_MODE;
 				/* wipe old channels */
 				devpriv->mode1 = 0;
 				devpriv->mode2 = 0;

commit dbaa1490f989380b2e7a492d324441cc917628cb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 7 11:45:05 2015 -0700

    staging: comedi: addi_apci_1564: define the APCI1564_DO_IRQ_REG bits
    
    Define the bits in this register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 3e8377a3b67b..2664bfa7b8f1 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -87,6 +87,7 @@
 #define APCI1564_DO_INT_STATUS_CC		BIT(1)
 #define APCI1564_DO_INT_STATUS_VCC		BIT(0)
 #define APCI1564_DO_IRQ_REG			0x20
+#define APCI1564_DO_IRQ_INTR			BIT(0)
 #define APCI1564_WDOG_REG			0x24
 #define APCI1564_WDOG_RELOAD_REG		0x28
 #define APCI1564_WDOG_TIMEBASE_REG		0x2c

commit fa1219e03e73fb1ebba87eeb2aa1edbea518622d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 7 11:45:04 2015 -0700

    staging: comedi: addi_apci_1564: define the APCI1564_DO_INT_STATUS_REG bits
    
    Define the bits in this register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 873e329f4bfd..3e8377a3b67b 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -84,6 +84,8 @@
 #define APCI1564_DO_INT_CTRL_CC_INT_ENA		BIT(1)
 #define APCI1564_DO_INT_CTRL_VCC_INT_ENA	BIT(0)
 #define APCI1564_DO_INT_STATUS_REG		0x1c
+#define APCI1564_DO_INT_STATUS_CC		BIT(1)
+#define APCI1564_DO_INT_STATUS_VCC		BIT(0)
 #define APCI1564_DO_IRQ_REG			0x20
 #define APCI1564_WDOG_REG			0x24
 #define APCI1564_WDOG_RELOAD_REG		0x28

commit 59c8f0dd76ac1358086ac79e177791683b1823d0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 7 11:45:03 2015 -0700

    staging: comedi: addi_apci_1564: define the APCI1564_DO_INT_CTRL_REG bits
    
    Define the bits in this register. Remove the old defines in hwdrv_apci1564.c.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 33e58b9a21b2..873e329f4bfd 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -81,6 +81,8 @@
 #define APCI1564_DI_IRQ_REG			0x10
 #define APCI1564_DO_REG				0x14
 #define APCI1564_DO_INT_CTRL_REG		0x18
+#define APCI1564_DO_INT_CTRL_CC_INT_ENA		BIT(1)
+#define APCI1564_DO_INT_CTRL_VCC_INT_ENA	BIT(0)
 #define APCI1564_DO_INT_STATUS_REG		0x1c
 #define APCI1564_DO_IRQ_REG			0x20
 #define APCI1564_WDOG_REG			0x24

commit 39a89e14697a82678ecfd68155ad2494b21d8d04
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:13:52 2015 +0000

    staging: comedi: addi_apci_1564: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index c1d00212d9b7..33e58b9a21b2 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -26,7 +26,6 @@
 #include <linux/sched.h>
 
 #include "../comedi_pci.h"
-#include "comedi_fc.h"
 #include "addi_tcw.h"
 #include "addi_watchdog.h"
 
@@ -364,11 +363,11 @@ static int apci1564_cos_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_FOLLOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_FOLLOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE);
 
 	if (err)
 		return 1;
@@ -378,11 +377,12 @@ static int apci1564_cos_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
-	err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit ecfd2267311ebe3fb2fe5e173dfd8f84f981ba0f
Author: Charlie Wong Super <1213charlie@gmail.com>
Date:   Thu Apr 2 18:10:04 2015 +0800

    Staging: comedi: addi_apci_1564: Delete a tap
    
    Fix the checkpatch.pl WARNING: line over 80 characters
    
    Signed-off-by: Charlie Wong Super <1213charlie@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index c481c48cdbde..c1d00212d9b7 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -106,12 +106,12 @@
 #define APCI1564_COUNTER(x)			((x) * 0x20)
 
 struct apci1564_private {
-	unsigned long eeprom;		/* base address of EEPROM register */
-	unsigned long timer;		/* base address of 12-bit timer */
-	unsigned long counters;		/* base address of 32-bit counters */
-	unsigned int mode1;		/* riding-edge/high level channels */
-	unsigned int mode2;		/* falling-edge/low level channels */
-	unsigned int ctrl;		/* interrupt mode OR (edge) . AND (level) */
+	unsigned long eeprom;	/* base address of EEPROM register */
+	unsigned long timer;	/* base address of 12-bit timer */
+	unsigned long counters;	/* base address of 32-bit counters */
+	unsigned int mode1;	/* riding-edge/high level channels */
+	unsigned int mode2;	/* falling-edge/low level channels */
+	unsigned int ctrl;	/* interrupt mode OR (edge) . AND (level) */
 	struct task_struct *tsk_current;
 };
 

commit 526a8e3b279cfd6a92d7146b769d023e841f9852
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 10 16:10:26 2015 +0000

    staging: comedi: addi_apci_1564: include new "comedi_pci.h" header
    
    Include the new "../comedi_pci.h" header instead of <linux/pci.h> and
    "../comedidev.h", which will now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 2de5e8320957..c481c48cdbde 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -22,11 +22,10 @@
  */
 
 #include <linux/module.h>
-#include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/sched.h>
 
-#include "../comedidev.h"
+#include "../comedi_pci.h"
 #include "comedi_fc.h"
 #include "addi_tcw.h"
 #include "addi_watchdog.h"

commit 6c7d2c8b5230272b394d51462c8cae46df09f126
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:16 2015 -0700

    staging: comedi: drivers/*.c: alignment should match open parenthesis
    
    Fix the alignment issues in all the comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 6872b69da5db..2de5e8320957 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -407,7 +407,7 @@ static int apci1564_cos_cmd(struct comedi_device *dev,
 
 	if (!devpriv->ctrl) {
 		dev_warn(dev->class_dev,
-			"Interrupts disabled due to mode configuration!\n");
+			 "Interrupts disabled due to mode configuration!\n");
 		return -EINVAL;
 	}
 
@@ -430,7 +430,7 @@ static int apci1564_cos_cancel(struct comedi_device *dev,
 }
 
 static int apci1564_auto_attach(struct comedi_device *dev,
-				      unsigned long context_unused)
+				unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct apci1564_private *devpriv;

commit e8dbe0c4c2566c4db885c24dbc1f603d9c703b41
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 16:20:20 2014 -0700

    staging: comedi: addi_apci_1564: enable support for PLD Rev 1.0 I/O mapping
    
    Remove the error return in the (*auto_attach) and allow the driver to
    attach to APC-1564 boards that use the PLD Rev 1.0 I/O mapping.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 18f38f00fb12..6872b69da5db 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -454,9 +454,6 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 		dev->iobase = pci_resource_start(pcidev, 1) +
 			      APCI1564_REV1_MAIN_IOBASE;
 		devpriv->timer = devpriv->eeprom + APCI1564_REV1_TIMER_IOBASE;
-		dev_err(dev->class_dev,
-			"PLD Revision 1.0 detected, not yet supported\n");
-		return -ENXIO;
 	} else {
 		/* PLD Revision 2.x I/O Mapping */
 		dev->iobase = devpriv->eeprom + APCI1564_REV2_MAIN_IOBASE;

commit 7d6156ed3be0fe9484f36004e81aab0b0eca69b5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 16:20:19 2014 -0700

    staging: comedi: addi_apci_1564: use addi_tcw.h defines for counters
    
    Use the generic TCW (timer/counter/watchdog) defines for the 32-bit counters.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index d47904ee98de..18f38f00fb12 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -101,17 +101,10 @@
  */
 
 /*
- * devpriv->counters Register Map
+ * devpriv->counters Register Map (see addi_tcw.h for register/bit defines)
  *   PLD Revision 2.x - PCI BAR 1 + 0x00
  */
-#define APCI1564_COUNTER_REG(x)			(0x00 + ((x) * 0x20))
-#define APCI1564_COUNTER_RELOAD_REG(x)		(0x04 + ((x) * 0x20))
-#define APCI1564_COUNTER_TIMEBASE_REG(x)	(0x08 + ((x) * 0x20))
-#define APCI1564_COUNTER_CTRL_REG(x)		(0x0c + ((x) * 0x20))
-#define APCI1564_COUNTER_STATUS_REG(x)		(0x10 + ((x) * 0x20))
-#define APCI1564_COUNTER_IRQ_REG(x)		(0x14 + ((x) * 0x20))
-#define APCI1564_COUNTER_WARN_TIMEVAL_REG(x)	(0x18 + ((x) * 0x20))
-#define APCI1564_COUNTER_WARN_TIMEBASE_REG(x)	(0x1c + ((x) * 0x20))
+#define APCI1564_COUNTER(x)			((x) * 0x20)
 
 struct apci1564_private {
 	unsigned long eeprom;		/* base address of EEPROM register */
@@ -147,10 +140,12 @@ static int apci1564_reset(struct comedi_device *dev)
 	outl(0x0, devpriv->timer + ADDI_TCW_RELOAD_REG);
 
 	if (devpriv->counters) {
+		unsigned long iobase = devpriv->counters + ADDI_TCW_CTRL_REG;
+
 		/* Reset the counter registers */
-		outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(0));
-		outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(1));
-		outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(2));
+		outl(0x0, iobase + APCI1564_COUNTER(0));
+		outl(0x0, iobase + APCI1564_COUNTER(1));
+		outl(0x0, iobase + APCI1564_COUNTER(2));
 	}
 
 	return 0;
@@ -195,21 +190,21 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 
 	if (devpriv->counters) {
 		for (chan = 0; chan < 4; chan++) {
-			status = inl(devpriv->counters +
-				     APCI1564_COUNTER_IRQ_REG(chan));
+			unsigned long iobase;
+
+			iobase = devpriv->counters + APCI1564_COUNTER(chan);
+
+			status = inl(iobase + ADDI_TCW_IRQ_REG);
 			if (status & 0x01) {
 				/*  Disable Counter Interrupt */
-				ctrl = inl(devpriv->counters +
-					   APCI1564_COUNTER_CTRL_REG(chan));
-				outl(0x0, devpriv->counters +
-				          APCI1564_COUNTER_CTRL_REG(chan));
+				ctrl = inl(iobase + ADDI_TCW_CTRL_REG);
+				outl(0x0, iobase + ADDI_TCW_CTRL_REG);
 
 				/* Send a signal to from kernel to user space */
 				send_sig(SIGIO, devpriv->tsk_current, 0);
 
 				/*  Enable Counter Interrupt */
-				outl(ctrl, devpriv->counters +
-					   APCI1564_COUNTER_CTRL_REG(chan));
+				outl(ctrl, iobase + ADDI_TCW_CTRL_REG);
 			}
 		}
 	}

commit e23337dcbb539420f35b0c7569ab123068e742fc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 16:20:18 2014 -0700

    staging: comedi: addi_apci_1564: use addi_tcw.h defines for timer
    
    Use the generic TCW (timer/counter/watchdog) defines for the 12-bit timer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 359880d422f2..d47904ee98de 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -28,6 +28,7 @@
 
 #include "../comedidev.h"
 #include "comedi_fc.h"
+#include "addi_tcw.h"
 #include "addi_watchdog.h"
 
 /*
@@ -94,18 +95,10 @@
 #define APCI1564_WDOG_WARN_TIMEBASE_REG		0x40
 
 /*
- * devpriv->timer Register Map
+ * devpriv->timer Register Map (see addi_tcw.h for register/bit defines)
  *   PLD Revision 1.0 - PCI BAR 0 + 0x04
  *   PLD Revision 2.x - PCI BAR 0 + 0x48
  */
-#define APCI1564_TIMER_REG			0x00
-#define APCI1564_TIMER_RELOAD_REG		0x04
-#define APCI1564_TIMER_TIMEBASE_REG		0x08
-#define APCI1564_TIMER_CTRL_REG			0x0c
-#define APCI1564_TIMER_STATUS_REG		0x10
-#define APCI1564_TIMER_IRQ_REG			0x14
-#define APCI1564_TIMER_WARN_TIMEVAL_REG		0x18  /* Rev 2.x only */
-#define APCI1564_TIMER_WARN_TIMEBASE_REG	0x1c  /* Rev 2.x only */
 
 /*
  * devpriv->counters Register Map
@@ -150,8 +143,8 @@ static int apci1564_reset(struct comedi_device *dev)
 	addi_watchdog_reset(dev->iobase + APCI1564_WDOG_REG);
 
 	/* Reset the timer registers */
-	outl(0x0, devpriv->timer + APCI1564_TIMER_CTRL_REG);
-	outl(0x0, devpriv->timer + APCI1564_TIMER_RELOAD_REG);
+	outl(0x0, devpriv->timer + ADDI_TCW_CTRL_REG);
+	outl(0x0, devpriv->timer + ADDI_TCW_RELOAD_REG);
 
 	if (devpriv->counters) {
 		/* Reset the counter registers */
@@ -187,17 +180,17 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 		outl(status, dev->iobase + APCI1564_DI_IRQ_REG);
 	}
 
-	status = inl(devpriv->timer + APCI1564_TIMER_IRQ_REG);
+	status = inl(devpriv->timer + ADDI_TCW_IRQ_REG);
 	if (status & 0x01) {
 		/*  Disable Timer Interrupt */
-		ctrl = inl(devpriv->timer + APCI1564_TIMER_CTRL_REG);
-		outl(0x0, devpriv->timer + APCI1564_TIMER_CTRL_REG);
+		ctrl = inl(devpriv->timer + ADDI_TCW_CTRL_REG);
+		outl(0x0, devpriv->timer + ADDI_TCW_CTRL_REG);
 
 		/* Send a signal to from kernel to user space */
 		send_sig(SIGIO, devpriv->tsk_current, 0);
 
 		/*  Enable Timer Interrupt */
-		outl(ctrl, devpriv->timer + APCI1564_TIMER_CTRL_REG);
+		outl(ctrl, devpriv->timer + ADDI_TCW_CTRL_REG);
 	}
 
 	if (devpriv->counters) {

commit 0658d6de9c9750201a5728f25dd3037a73941077
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 16:20:16 2014 -0700

    staging: comedi: addi_apci_1564: split timer and counter subdevices
    
    The timer subdevice is currently broken in this driver.
    
    The Rev 1.0 and 2.x versions of the board both have a 12-bit timer. But only
    the Rev 2.x boards have the 3 32-bit counters.
    
    Split the current timer subdevice into two separate subdevices:
      1) A single channel 12-bit timer subdevice
      2) A three channel 32-bit counter subdevice
    
    This represents the hardware correctly and the counters can be disabled on
    the Rev 1.0 boards.
    
    Split up the current (*insn_config), (*insn_write), and (*insn_read) so they
    only deal with the hardware associated with the subdevice.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 958eb7d29be2..359880d422f2 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -127,7 +127,6 @@ struct apci1564_private {
 	unsigned int mode1;		/* riding-edge/high level channels */
 	unsigned int mode2;		/* falling-edge/low level channels */
 	unsigned int ctrl;		/* interrupt mode OR (edge) . AND (level) */
-	unsigned char timer_select_mode;
 	struct task_struct *tsk_current;
 };
 
@@ -486,7 +485,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 			dev->irq = pcidev->irq;
 	}
 
-	ret = comedi_alloc_subdevices(dev, 6);
+	ret = comedi_alloc_subdevices(dev, 7);
 	if (ret)
 		return ret;
 
@@ -527,25 +526,40 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
-	/*  Allocate and Initialise Timer Subdevice Structures */
+	/* Timer subdevice */
 	s = &dev->subdevices[3];
 	s->type		= COMEDI_SUBD_TIMER;
-	s->subdev_flags	= SDF_WRITABLE;
-	s->n_chan	= 3;
-	s->maxdata	= 0;
+	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE;
+	s->n_chan	= 1;
+	s->maxdata	= 0x0fff;
 	s->range_table	= &range_digital;
-	s->insn_write	= apci1564_timer_write;
-	s->insn_read	= apci1564_timer_read;
-	s->insn_config	= apci1564_timer_config;
+	s->insn_config	= apci1564_timer_insn_config;
+	s->insn_write	= apci1564_timer_insn_write;
+	s->insn_read	= apci1564_timer_insn_read;
 
-	/* Initialize the watchdog subdevice */
+	/* Counter subdevice */
 	s = &dev->subdevices[4];
+	if (devpriv->counters) {
+		s->type		= COMEDI_SUBD_COUNTER;
+		s->subdev_flags	= SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;
+		s->n_chan	= 3;
+		s->maxdata	= 0xffffffff;
+		s->range_table	= &range_digital;
+		s->insn_config	= apci1564_counter_insn_config;
+		s->insn_write	= apci1564_counter_insn_write;
+		s->insn_read	= apci1564_counter_insn_read;
+	} else {
+		s->type		= COMEDI_SUBD_UNUSED;
+	}
+
+	/* Initialize the watchdog subdevice */
+	s = &dev->subdevices[5];
 	ret = addi_watchdog_init(s, dev->iobase + APCI1564_WDOG_REG);
 	if (ret)
 		return ret;
 
 	/* Initialize the diagnostic status subdevice */
-	s = &dev->subdevices[5];
+	s = &dev->subdevices[6];
 	s->type		= COMEDI_SUBD_DI;
 	s->subdev_flags	= SDF_READABLE;
 	s->n_chan	= 2;

commit 1a69a887d69250778e5493fcebc6e95d1c625d20
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 16:20:15 2014 -0700

    staging: comedi: addi_apci_1564: move counter register defines to driver
    
    Move the defines for the counter registers from the included source
    file to the main driver source file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 3fb9cc06973d..958eb7d29be2 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -107,6 +107,19 @@
 #define APCI1564_TIMER_WARN_TIMEVAL_REG		0x18  /* Rev 2.x only */
 #define APCI1564_TIMER_WARN_TIMEBASE_REG	0x1c  /* Rev 2.x only */
 
+/*
+ * devpriv->counters Register Map
+ *   PLD Revision 2.x - PCI BAR 1 + 0x00
+ */
+#define APCI1564_COUNTER_REG(x)			(0x00 + ((x) * 0x20))
+#define APCI1564_COUNTER_RELOAD_REG(x)		(0x04 + ((x) * 0x20))
+#define APCI1564_COUNTER_TIMEBASE_REG(x)	(0x08 + ((x) * 0x20))
+#define APCI1564_COUNTER_CTRL_REG(x)		(0x0c + ((x) * 0x20))
+#define APCI1564_COUNTER_STATUS_REG(x)		(0x10 + ((x) * 0x20))
+#define APCI1564_COUNTER_IRQ_REG(x)		(0x14 + ((x) * 0x20))
+#define APCI1564_COUNTER_WARN_TIMEVAL_REG(x)	(0x18 + ((x) * 0x20))
+#define APCI1564_COUNTER_WARN_TIMEBASE_REG(x)	(0x1c + ((x) * 0x20))
+
 struct apci1564_private {
 	unsigned long eeprom;		/* base address of EEPROM register */
 	unsigned long timer;		/* base address of 12-bit timer */

commit 3a2cf2f971b7128b1daff50abbd88c766b458544
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 16:20:14 2014 -0700

    staging: comedi: addi_apci_1564: fix counter code in main driver source
    
    The Rev 1.0 APCI-1564 boards do not have counters.
    
    Fix the code in the main driver source so that the I/O accesses to the
    counters do not happen if the devpriv->counters member is not initialized.
    
    This does not fix the code in hwdrv_apci1564.c. That code violates the
    comedi API and is currently broken.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index b74e6c62eb24..3fb9cc06973d 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -141,10 +141,12 @@ static int apci1564_reset(struct comedi_device *dev)
 	outl(0x0, devpriv->timer + APCI1564_TIMER_CTRL_REG);
 	outl(0x0, devpriv->timer + APCI1564_TIMER_RELOAD_REG);
 
-	/* Reset the counter registers */
-	outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(0));
-	outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(1));
-	outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(2));
+	if (devpriv->counters) {
+		/* Reset the counter registers */
+		outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(0));
+		outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(1));
+		outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(2));
+	}
 
 	return 0;
 }
@@ -186,22 +188,24 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 		outl(ctrl, devpriv->timer + APCI1564_TIMER_CTRL_REG);
 	}
 
-	for (chan = 0; chan < 4; chan++) {
-		status = inl(devpriv->counters +
-			     APCI1564_COUNTER_IRQ_REG(chan));
-		if (status & 0x01) {
-			/*  Disable Counter Interrupt */
-			ctrl = inl(devpriv->counters +
-				   APCI1564_COUNTER_CTRL_REG(chan));
-			outl(0x0, devpriv->counters +
-			     APCI1564_COUNTER_CTRL_REG(chan));
-
-			/* Send a signal to from kernel to user space */
-			send_sig(SIGIO, devpriv->tsk_current, 0);
-
-			/*  Enable Counter Interrupt */
-			outl(ctrl, devpriv->counters +
-			     APCI1564_COUNTER_CTRL_REG(chan));
+	if (devpriv->counters) {
+		for (chan = 0; chan < 4; chan++) {
+			status = inl(devpriv->counters +
+				     APCI1564_COUNTER_IRQ_REG(chan));
+			if (status & 0x01) {
+				/*  Disable Counter Interrupt */
+				ctrl = inl(devpriv->counters +
+					   APCI1564_COUNTER_CTRL_REG(chan));
+				outl(0x0, devpriv->counters +
+				          APCI1564_COUNTER_CTRL_REG(chan));
+
+				/* Send a signal to from kernel to user space */
+				send_sig(SIGIO, devpriv->tsk_current, 0);
+
+				/*  Enable Counter Interrupt */
+				outl(ctrl, devpriv->counters +
+					   APCI1564_COUNTER_CTRL_REG(chan));
+			}
 		}
 	}
 

commit 6cf8ea2ebfb4421927cd7f1c66247d6980b5ac4c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 16:20:13 2014 -0700

    staging: comedi: addi_apci_1564: fix timer iobase for all PLD revisions
    
    The APCI-1564 has different I/O mapping depending on if the PLD revision
    is Rev 1.0 or Rev 2.x.
    
    Add a member, 'timer', to the private data for the base address of the
    12-bit timer. Fix the register defines so they will work for all PLD
    revisions and initialize the devpriv->timer appropriately.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 0fa7f72da10e..b74e6c62eb24 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -51,7 +51,9 @@
 #define APCI1564_EEPROM_DO			(1 << 2)
 #define APCI1564_EEPROM_CS			(1 << 1)
 #define APCI1564_EEPROM_CLK			(1 << 0)
+#define APCI1564_REV1_TIMER_IOBASE		0x04
 #define APCI1564_REV2_MAIN_IOBASE		0x04
+#define APCI1564_REV2_TIMER_IOBASE		0x48
 
 /*
  * PCI BAR 1
@@ -90,18 +92,24 @@
 #define APCI1564_WDOG_IRQ_REG			0x38
 #define APCI1564_WDOG_WARN_TIMEVAL_REG		0x3c
 #define APCI1564_WDOG_WARN_TIMEBASE_REG		0x40
-#define APCI1564_TIMER_REG			0x44
-#define APCI1564_TIMER_RELOAD_REG		0x48
-#define APCI1564_TIMER_TIMEBASE_REG		0x4c
-#define APCI1564_TIMER_CTRL_REG			0x50
-#define APCI1564_TIMER_STATUS_REG		0x54
-#define APCI1564_TIMER_IRQ_REG			0x58
-#define APCI1564_TIMER_WARN_TIMEVAL_REG		0x5c  /* Rev 2.x only */
-#define APCI1564_TIMER_WARN_TIMEBASE_REG	0x60  /* Rev 2.x only */
 
+/*
+ * devpriv->timer Register Map
+ *   PLD Revision 1.0 - PCI BAR 0 + 0x04
+ *   PLD Revision 2.x - PCI BAR 0 + 0x48
+ */
+#define APCI1564_TIMER_REG			0x00
+#define APCI1564_TIMER_RELOAD_REG		0x04
+#define APCI1564_TIMER_TIMEBASE_REG		0x08
+#define APCI1564_TIMER_CTRL_REG			0x0c
+#define APCI1564_TIMER_STATUS_REG		0x10
+#define APCI1564_TIMER_IRQ_REG			0x14
+#define APCI1564_TIMER_WARN_TIMEVAL_REG		0x18  /* Rev 2.x only */
+#define APCI1564_TIMER_WARN_TIMEBASE_REG	0x1c  /* Rev 2.x only */
 
 struct apci1564_private {
 	unsigned long eeprom;		/* base address of EEPROM register */
+	unsigned long timer;		/* base address of 12-bit timer */
 	unsigned long counters;		/* base address of 32-bit counters */
 	unsigned int mode1;		/* riding-edge/high level channels */
 	unsigned int mode2;		/* falling-edge/low level channels */
@@ -130,8 +138,8 @@ static int apci1564_reset(struct comedi_device *dev)
 	addi_watchdog_reset(dev->iobase + APCI1564_WDOG_REG);
 
 	/* Reset the timer registers */
-	outl(0x0, dev->iobase + APCI1564_TIMER_CTRL_REG);
-	outl(0x0, dev->iobase + APCI1564_TIMER_RELOAD_REG);
+	outl(0x0, devpriv->timer + APCI1564_TIMER_CTRL_REG);
+	outl(0x0, devpriv->timer + APCI1564_TIMER_RELOAD_REG);
 
 	/* Reset the counter registers */
 	outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(0));
@@ -165,17 +173,17 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 		outl(status, dev->iobase + APCI1564_DI_IRQ_REG);
 	}
 
-	status = inl(dev->iobase + APCI1564_TIMER_IRQ_REG);
+	status = inl(devpriv->timer + APCI1564_TIMER_IRQ_REG);
 	if (status & 0x01) {
 		/*  Disable Timer Interrupt */
-		ctrl = inl(dev->iobase + APCI1564_TIMER_CTRL_REG);
-		outl(0x0, dev->iobase + APCI1564_TIMER_CTRL_REG);
+		ctrl = inl(devpriv->timer + APCI1564_TIMER_CTRL_REG);
+		outl(0x0, devpriv->timer + APCI1564_TIMER_CTRL_REG);
 
 		/* Send a signal to from kernel to user space */
 		send_sig(SIGIO, devpriv->tsk_current, 0);
 
 		/*  Enable Timer Interrupt */
-		outl(ctrl, dev->iobase + APCI1564_TIMER_CTRL_REG);
+		outl(ctrl, devpriv->timer + APCI1564_TIMER_CTRL_REG);
 	}
 
 	for (chan = 0; chan < 4; chan++) {
@@ -441,12 +449,14 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 		/* PLD Revision 1.0 I/O Mapping */
 		dev->iobase = pci_resource_start(pcidev, 1) +
 			      APCI1564_REV1_MAIN_IOBASE;
+		devpriv->timer = devpriv->eeprom + APCI1564_REV1_TIMER_IOBASE;
 		dev_err(dev->class_dev,
 			"PLD Revision 1.0 detected, not yet supported\n");
 		return -ENXIO;
 	} else {
 		/* PLD Revision 2.x I/O Mapping */
 		dev->iobase = devpriv->eeprom + APCI1564_REV2_MAIN_IOBASE;
+		devpriv->timer = devpriv->eeprom + APCI1564_REV2_TIMER_IOBASE;
 		devpriv->counters = pci_resource_start(pcidev, 1);
 	}
 

commit 37436196525239c61816a5b9e009a7aeab11ad2c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 16:20:12 2014 -0700

    staging: comedi: addi_apci_1564: fix dev->iobase for all PLD revisions
    
    The APCI-1564 has different I/O mapping depending on if the PLD revision is
    Rev 1.0 or Rev 2.x.
    
    Fix the main register defines so they will work for all PLD revisions and
    initialie the dev->iobase appropriately. Move the register defines to the
    main driver source file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index f75803a39449..0fa7f72da10e 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -51,6 +51,7 @@
 #define APCI1564_EEPROM_DO			(1 << 2)
 #define APCI1564_EEPROM_CS			(1 << 1)
 #define APCI1564_EEPROM_CLK			(1 << 0)
+#define APCI1564_REV2_MAIN_IOBASE		0x04
 
 /*
  * PCI BAR 1
@@ -65,6 +66,39 @@
  *   0x20         Counter_1
  *   0x30         Counter_3
  */
+#define APCI1564_REV1_MAIN_IOBASE		0x00
+
+/*
+ * dev->iobase Register Map
+ *   PLD Revision 1.0 - PCI BAR 1 + 0x00
+ *   PLD Revision 2.x - PCI BAR 0 + 0x04
+ */
+#define APCI1564_DI_REG				0x00
+#define APCI1564_DI_INT_MODE1_REG		0x04
+#define APCI1564_DI_INT_MODE2_REG		0x08
+#define APCI1564_DI_INT_STATUS_REG		0x0c
+#define APCI1564_DI_IRQ_REG			0x10
+#define APCI1564_DO_REG				0x14
+#define APCI1564_DO_INT_CTRL_REG		0x18
+#define APCI1564_DO_INT_STATUS_REG		0x1c
+#define APCI1564_DO_IRQ_REG			0x20
+#define APCI1564_WDOG_REG			0x24
+#define APCI1564_WDOG_RELOAD_REG		0x28
+#define APCI1564_WDOG_TIMEBASE_REG		0x2c
+#define APCI1564_WDOG_CTRL_REG			0x30
+#define APCI1564_WDOG_STATUS_REG		0x34
+#define APCI1564_WDOG_IRQ_REG			0x38
+#define APCI1564_WDOG_WARN_TIMEVAL_REG		0x3c
+#define APCI1564_WDOG_WARN_TIMEBASE_REG		0x40
+#define APCI1564_TIMER_REG			0x44
+#define APCI1564_TIMER_RELOAD_REG		0x48
+#define APCI1564_TIMER_TIMEBASE_REG		0x4c
+#define APCI1564_TIMER_CTRL_REG			0x50
+#define APCI1564_TIMER_STATUS_REG		0x54
+#define APCI1564_TIMER_IRQ_REG			0x58
+#define APCI1564_TIMER_WARN_TIMEVAL_REG		0x5c  /* Rev 2.x only */
+#define APCI1564_TIMER_WARN_TIMEBASE_REG	0x60  /* Rev 2.x only */
+
 
 struct apci1564_private {
 	unsigned long eeprom;		/* base address of EEPROM register */
@@ -405,12 +439,14 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	val = inl(devpriv->eeprom + APCI1564_EEPROM_REG);
 	if (APCI1564_EEPROM_TO_REV(val) == 0) {
 		/* PLD Revision 1.0 I/O Mapping */
+		dev->iobase = pci_resource_start(pcidev, 1) +
+			      APCI1564_REV1_MAIN_IOBASE;
 		dev_err(dev->class_dev,
 			"PLD Revision 1.0 detected, not yet supported\n");
 		return -ENXIO;
 	} else {
 		/* PLD Revision 2.x I/O Mapping */
-		dev->iobase = devpriv->eeprom;
+		dev->iobase = devpriv->eeprom + APCI1564_REV2_MAIN_IOBASE;
 		devpriv->counters = pci_resource_start(pcidev, 1);
 	}
 

commit 951fd40b28444e273404c2fb0b28d8e3cf5660b2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 16:20:11 2014 -0700

    staging: comedi: addi_apci_1564: detect PLD revision for I/O mapping
    
    The APCI-1564 has different I/O mapping depending on if the PLD revision is
    Rev 1.0 or Rev 2.x. The revision can be determined by reading the EEPROM
    register at offset 0x00 of PCI BAR 0 and checking the value of bits 7 to 4.
    
    Add this check to apci1564_auto_attach(). Currently this driver is coded
    to work with the Rev 2.x I/O mapping. For now, fail the attach if a Rev 1.0
    PLD is detected. Document the I/O mapping for both revisions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 4252054e86ea..f75803a39449 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -30,7 +30,44 @@
 #include "comedi_fc.h"
 #include "addi_watchdog.h"
 
+/*
+ * PCI BAR 0
+ *
+ * PLD Revision 1.0 I/O Mapping
+ *   0x00         93C76 EEPROM
+ *   0x04 - 0x18  Timer 12-Bit
+ *
+ * PLD Revision 2.x I/O Mapping
+ *   0x00         93C76 EEPROM
+ *   0x04 - 0x14  Digital Input
+ *   0x18 - 0x25  Digital Output
+ *   0x28 - 0x44  Watchdog 8-Bit
+ *   0x48 - 0x64  Timer 12-Bit
+ */
+#define APCI1564_EEPROM_REG			0x00
+#define APCI1564_EEPROM_VCC_STATUS		(1 << 8)
+#define APCI1564_EEPROM_TO_REV(x)		(((x) >> 4) & 0xf)
+#define APCI1564_EEPROM_DI			(1 << 3)
+#define APCI1564_EEPROM_DO			(1 << 2)
+#define APCI1564_EEPROM_CS			(1 << 1)
+#define APCI1564_EEPROM_CLK			(1 << 0)
+
+/*
+ * PCI BAR 1
+ *
+ * PLD Revision 1.0 I/O Mapping
+ *   0x00 - 0x10  Digital Input
+ *   0x14 - 0x20  Digital Output
+ *   0x24 - 0x3c  Watchdog 8-Bit
+ *
+ * PLD Revision 2.x I/O Mapping
+ *   0x00         Counter_0
+ *   0x20         Counter_1
+ *   0x30         Counter_3
+ */
+
 struct apci1564_private {
+	unsigned long eeprom;		/* base address of EEPROM register */
 	unsigned long counters;		/* base address of 32-bit counters */
 	unsigned int mode1;		/* riding-edge/high level channels */
 	unsigned int mode2;		/* falling-edge/low level channels */
@@ -352,6 +389,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct apci1564_private *devpriv;
 	struct comedi_subdevice *s;
+	unsigned int val;
 	int ret;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
@@ -362,9 +400,19 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	/* PLD Revision 2.x I/O Mapping */
-	dev->iobase = pci_resource_start(pcidev, 0);
-	devpriv->counters = pci_resource_start(pcidev, 1);
+	/* read the EEPROM register and check the I/O map revision */
+	devpriv->eeprom = pci_resource_start(pcidev, 0);
+	val = inl(devpriv->eeprom + APCI1564_EEPROM_REG);
+	if (APCI1564_EEPROM_TO_REV(val) == 0) {
+		/* PLD Revision 1.0 I/O Mapping */
+		dev_err(dev->class_dev,
+			"PLD Revision 1.0 detected, not yet supported\n");
+		return -ENXIO;
+	} else {
+		/* PLD Revision 2.x I/O Mapping */
+		dev->iobase = devpriv->eeprom;
+		devpriv->counters = pci_resource_start(pcidev, 1);
+	}
 
 	apci1564_reset(dev);
 

commit 4484a23907724ad524d41e11dafa2a6be993420a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 16:20:10 2014 -0700

    staging: comedi: addi_apci_1564: use dev->iobase for main registers
    
    According to ADDI-DATA, the PLD Revision 2.x versions of the APCI-1564 use
    PCI BAR 0 for the main registers of the board.
    
    Remove the 'amcc_iobase' member of the private data and use the dev->iobase
    to store the base address of PCI BAR 1.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index ecdbc880a31a..4252054e86ea 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -32,7 +32,6 @@
 
 struct apci1564_private {
 	unsigned long counters;		/* base address of 32-bit counters */
-	unsigned int amcc_iobase;	/* base of AMCC I/O registers */
 	unsigned int mode1;		/* riding-edge/high level channels */
 	unsigned int mode2;		/* falling-edge/low level channels */
 	unsigned int ctrl;		/* interrupt mode OR (edge) . AND (level) */
@@ -47,21 +46,21 @@ static int apci1564_reset(struct comedi_device *dev)
 	struct apci1564_private *devpriv = dev->private;
 
 	/* Disable the input interrupts and reset status register */
-	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
-	inl(devpriv->amcc_iobase + APCI1564_DI_INT_STATUS_REG);
-	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE1_REG);
-	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE2_REG);
+	outl(0x0, dev->iobase + APCI1564_DI_IRQ_REG);
+	inl(dev->iobase + APCI1564_DI_INT_STATUS_REG);
+	outl(0x0, dev->iobase + APCI1564_DI_INT_MODE1_REG);
+	outl(0x0, dev->iobase + APCI1564_DI_INT_MODE2_REG);
 
 	/* Reset the output channels and disable interrupts */
-	outl(0x0, devpriv->amcc_iobase + APCI1564_DO_REG);
-	outl(0x0, devpriv->amcc_iobase + APCI1564_DO_INT_CTRL_REG);
+	outl(0x0, dev->iobase + APCI1564_DO_REG);
+	outl(0x0, dev->iobase + APCI1564_DO_INT_CTRL_REG);
 
 	/* Reset the watchdog registers */
-	addi_watchdog_reset(devpriv->amcc_iobase + APCI1564_WDOG_REG);
+	addi_watchdog_reset(dev->iobase + APCI1564_WDOG_REG);
 
 	/* Reset the timer registers */
-	outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
-	outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_RELOAD_REG);
+	outl(0x0, dev->iobase + APCI1564_TIMER_CTRL_REG);
+	outl(0x0, dev->iobase + APCI1564_TIMER_RELOAD_REG);
 
 	/* Reset the counter registers */
 	outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(0));
@@ -80,32 +79,32 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 	unsigned int ctrl;
 	unsigned int chan;
 
-	status = inl(devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+	status = inl(dev->iobase + APCI1564_DI_IRQ_REG);
 	if (status & APCI1564_DI_INT_ENABLE) {
 		/* disable the interrupt */
 		outl(status & APCI1564_DI_INT_DISABLE,
-		     devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+		     dev->iobase + APCI1564_DI_IRQ_REG);
 
-		s->state = inl(devpriv->amcc_iobase +
-			       APCI1564_DI_INT_STATUS_REG) & 0xffff;
+		s->state = inl(dev->iobase + APCI1564_DI_INT_STATUS_REG) &
+			   0xffff;
 		comedi_buf_write_samples(s, &s->state, 1);
 		comedi_handle_events(dev, s);
 
 		/* enable the interrupt */
-		outl(status, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+		outl(status, dev->iobase + APCI1564_DI_IRQ_REG);
 	}
 
-	status = inl(devpriv->amcc_iobase + APCI1564_TIMER_IRQ_REG);
+	status = inl(dev->iobase + APCI1564_TIMER_IRQ_REG);
 	if (status & 0x01) {
 		/*  Disable Timer Interrupt */
-		ctrl = inl(devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
-		outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
+		ctrl = inl(dev->iobase + APCI1564_TIMER_CTRL_REG);
+		outl(0x0, dev->iobase + APCI1564_TIMER_CTRL_REG);
 
 		/* Send a signal to from kernel to user space */
 		send_sig(SIGIO, devpriv->tsk_current, 0);
 
 		/*  Enable Timer Interrupt */
-		outl(ctrl, devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
+		outl(ctrl, dev->iobase + APCI1564_TIMER_CTRL_REG);
 	}
 
 	for (chan = 0; chan < 4; chan++) {
@@ -135,9 +134,7 @@ static int apci1564_di_insn_bits(struct comedi_device *dev,
 				 struct comedi_insn *insn,
 				 unsigned int *data)
 {
-	struct apci1564_private *devpriv = dev->private;
-
-	data[1] = inl(devpriv->amcc_iobase + APCI1564_DI_REG);
+	data[1] = inl(dev->iobase + APCI1564_DI_REG);
 
 	return insn->n;
 }
@@ -147,12 +144,10 @@ static int apci1564_do_insn_bits(struct comedi_device *dev,
 				 struct comedi_insn *insn,
 				 unsigned int *data)
 {
-	struct apci1564_private *devpriv = dev->private;
-
-	s->state = inl(devpriv->amcc_iobase + APCI1564_DO_REG);
+	s->state = inl(dev->iobase + APCI1564_DO_REG);
 
 	if (comedi_dio_update_state(s, data))
-		outl(s->state, devpriv->amcc_iobase + APCI1564_DO_REG);
+		outl(s->state, dev->iobase + APCI1564_DO_REG);
 
 	data[1] = s->state;
 
@@ -164,9 +159,7 @@ static int apci1564_diag_insn_bits(struct comedi_device *dev,
 				   struct comedi_insn *insn,
 				   unsigned int *data)
 {
-	struct apci1564_private *devpriv = dev->private;
-
-	data[1] = inl(devpriv->amcc_iobase + APCI1564_DO_INT_STATUS_REG) & 3;
+	data[1] = inl(dev->iobase + APCI1564_DO_INT_STATUS_REG) & 3;
 
 	return insn->n;
 }
@@ -220,10 +213,10 @@ static int apci1564_cos_insn_config(struct comedi_device *dev,
 			devpriv->ctrl = 0;
 			devpriv->mode1 = 0;
 			devpriv->mode2 = 0;
-			outl(0x0, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
-			inl(devpriv->amcc_iobase + APCI1564_DI_INT_STATUS_REG);
-			outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE1_REG);
-			outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE2_REG);
+			outl(0x0, dev->iobase + APCI1564_DI_IRQ_REG);
+			inl(dev->iobase + APCI1564_DI_INT_STATUS_REG);
+			outl(0x0, dev->iobase + APCI1564_DI_INT_MODE1_REG);
+			outl(0x0, dev->iobase + APCI1564_DI_INT_MODE2_REG);
 			break;
 		case COMEDI_DIGITAL_TRIG_ENABLE_EDGES:
 			if (devpriv->ctrl != (APCI1564_DI_INT_ENABLE |
@@ -335,9 +328,9 @@ static int apci1564_cos_cmd(struct comedi_device *dev,
 		return -EINVAL;
 	}
 
-	outl(devpriv->mode1, devpriv->amcc_iobase + APCI1564_DI_INT_MODE1_REG);
-	outl(devpriv->mode2, devpriv->amcc_iobase + APCI1564_DI_INT_MODE2_REG);
-	outl(devpriv->ctrl, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+	outl(devpriv->mode1, dev->iobase + APCI1564_DI_INT_MODE1_REG);
+	outl(devpriv->mode2, dev->iobase + APCI1564_DI_INT_MODE2_REG);
+	outl(devpriv->ctrl, dev->iobase + APCI1564_DI_IRQ_REG);
 
 	return 0;
 }
@@ -345,12 +338,10 @@ static int apci1564_cos_cmd(struct comedi_device *dev,
 static int apci1564_cos_cancel(struct comedi_device *dev,
 			       struct comedi_subdevice *s)
 {
-	struct apci1564_private *devpriv = dev->private;
-
-	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
-	inl(devpriv->amcc_iobase + APCI1564_DI_INT_STATUS_REG);
-	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE1_REG);
-	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE2_REG);
+	outl(0x0, dev->iobase + APCI1564_DI_IRQ_REG);
+	inl(dev->iobase + APCI1564_DI_INT_STATUS_REG);
+	outl(0x0, dev->iobase + APCI1564_DI_INT_MODE1_REG);
+	outl(0x0, dev->iobase + APCI1564_DI_INT_MODE2_REG);
 
 	return 0;
 }
@@ -372,7 +363,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 		return ret;
 
 	/* PLD Revision 2.x I/O Mapping */
-	devpriv->amcc_iobase = pci_resource_start(pcidev, 0);
+	dev->iobase = pci_resource_start(pcidev, 0);
 	devpriv->counters = pci_resource_start(pcidev, 1);
 
 	apci1564_reset(dev);
@@ -438,7 +429,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 	/* Initialize the watchdog subdevice */
 	s = &dev->subdevices[4];
-	ret = addi_watchdog_init(s, devpriv->amcc_iobase + APCI1564_WDOG_REG);
+	ret = addi_watchdog_init(s, dev->iobase + APCI1564_WDOG_REG);
 	if (ret)
 		return ret;
 

commit 63f9c51a5273daf5619ef0eae23d9f6317e01bcd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 16:20:09 2014 -0700

    staging: comedi: addi_apci_1564: store PCI BAR 1 base address in private data
    
    According to ADDI-DATA, only the PLD Revision 2.x versions of the APCI-1564
    have the 3 counters. The base address for these counters is found in PCI BAR 1.
    
    For aesthetics, save this base address in the private data. The dev->iobase
    can then be used for the main registers of the board.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 467e27838b56..ecdbc880a31a 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -31,6 +31,7 @@
 #include "addi_watchdog.h"
 
 struct apci1564_private {
+	unsigned long counters;		/* base address of 32-bit counters */
 	unsigned int amcc_iobase;	/* base of AMCC I/O registers */
 	unsigned int mode1;		/* riding-edge/high level channels */
 	unsigned int mode2;		/* falling-edge/low level channels */
@@ -63,9 +64,9 @@ static int apci1564_reset(struct comedi_device *dev)
 	outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_RELOAD_REG);
 
 	/* Reset the counter registers */
-	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(0));
-	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(1));
-	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(2));
+	outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(0));
+	outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(1));
+	outl(0x0, devpriv->counters + APCI1564_COUNTER_CTRL_REG(2));
 
 	return 0;
 }
@@ -108,20 +109,21 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 	}
 
 	for (chan = 0; chan < 4; chan++) {
-		status = inl(dev->iobase + APCI1564_COUNTER_IRQ_REG(chan));
+		status = inl(devpriv->counters +
+			     APCI1564_COUNTER_IRQ_REG(chan));
 		if (status & 0x01) {
 			/*  Disable Counter Interrupt */
-			ctrl = inl(dev->iobase +
-				  APCI1564_COUNTER_CTRL_REG(chan));
-			outl(0x0, dev->iobase +
-			    APCI1564_COUNTER_CTRL_REG(chan));
+			ctrl = inl(devpriv->counters +
+				   APCI1564_COUNTER_CTRL_REG(chan));
+			outl(0x0, devpriv->counters +
+			     APCI1564_COUNTER_CTRL_REG(chan));
 
 			/* Send a signal to from kernel to user space */
 			send_sig(SIGIO, devpriv->tsk_current, 0);
 
 			/*  Enable Counter Interrupt */
-			outl(ctrl, dev->iobase +
-			    APCI1564_COUNTER_CTRL_REG(chan));
+			outl(ctrl, devpriv->counters +
+			     APCI1564_COUNTER_CTRL_REG(chan));
 		}
 	}
 
@@ -369,8 +371,9 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	dev->iobase = pci_resource_start(pcidev, 1);
+	/* PLD Revision 2.x I/O Mapping */
 	devpriv->amcc_iobase = pci_resource_start(pcidev, 0);
+	devpriv->counters = pci_resource_start(pcidev, 1);
 
 	apci1564_reset(dev);
 

commit 950a6f8714fd73d4348036413f21e056de4b10bd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 16:20:08 2014 -0700

    staging: comedi: addi_apci_1564: use correct I/O base for APCI1564_DI_INT_STATUS_REG
    
    The APCI1564_DI_INT_STATUS_REG is located in the PCI BAR 0 I/O space. That
    base address is stored in devpriv->amcc_iobase. Use that to correctly read
    the register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index cf14b0a923d4..467e27838b56 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -85,8 +85,8 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 		outl(status & APCI1564_DI_INT_DISABLE,
 		     devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
 
-		s->state = inl(dev->iobase + APCI1564_DI_INT_STATUS_REG)
-			       & 0xffff;
+		s->state = inl(devpriv->amcc_iobase +
+			       APCI1564_DI_INT_STATUS_REG) & 0xffff;
 		comedi_buf_write_samples(s, &s->state, 1);
 		comedi_handle_events(dev, s);
 

commit aff24b999554d048d3105fefdd0bd89dbfc312af
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 16:20:07 2014 -0700

    staging: comedi: addi_apci_1564: board does not use an AMCC PCI controller
    
    According to ADDI-DATA, the APCI-1564 board has a FPGA with a PCI core, it
    does not use an AMCC PCI controller chip.
    
    Remove the amcc_s5933.h include as well as the read of the AMCC_OP_REG_INTCSR
    register. That offset would actually read APCI1564_WDOG_STATUS_REG register
    in the FPGA which has nothing to do with the interrupt status.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index aa908a4a24cf..cf14b0a923d4 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -28,7 +28,6 @@
 
 #include "../comedidev.h"
 #include "comedi_fc.h"
-#include "amcc_s5933.h"
 #include "addi_watchdog.h"
 
 struct apci1564_private {
@@ -80,11 +79,6 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 	unsigned int ctrl;
 	unsigned int chan;
 
-	/* check interrupt is from this device */
-	if ((inl(devpriv->amcc_iobase + AMCC_OP_REG_INTCSR) &
-	     INTCSR_INTR_ASSERTED) == 0)
-		return IRQ_NONE;
-
 	status = inl(devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
 	if (status & APCI1564_DI_INT_ENABLE) {
 		/* disable the interrupt */

commit ef49d8329e25ee1686520315713b86419cddcb45
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Oct 30 11:19:34 2014 -0700

    staging: comedi: drivers: replace SDF_WRITEABLE with SDF_WRITABLE
    
    As indicated in the comedi.h uapi header, SDF_WRITEABLE was a spelling
    error in the API, SDF_WRITABLE is prefered.
    
    For aesthetics, replace all the SDF_WRITEABLE uses with SDF_WRITABLE.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index c328230b85ec..aa908a4a24cf 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -403,7 +403,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	/*  Allocate and Initialise DO Subdevice Structures */
 	s = &dev->subdevices[1];
 	s->type		= COMEDI_SUBD_DO;
-	s->subdev_flags	= SDF_WRITEABLE;
+	s->subdev_flags	= SDF_WRITABLE;
 	s->n_chan	= 32;
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
@@ -431,7 +431,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	/*  Allocate and Initialise Timer Subdevice Structures */
 	s = &dev->subdevices[3];
 	s->type		= COMEDI_SUBD_TIMER;
-	s->subdev_flags	= SDF_WRITEABLE;
+	s->subdev_flags	= SDF_WRITABLE;
 	s->n_chan	= 3;
 	s->maxdata	= 0;
 	s->range_table	= &range_digital;

commit 7885b070b83ce5c8fb42bf65047e7dd6388d7b20
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 24 10:26:05 2014 -0700

    staging: comedi: addi_apci_1564: remove private data 'mode_select_register'
    
    This driver currently passes the timer channel as the data[5] element to the
    timer (*insn_config) function. This is stored in the private data and use in
    the timer (*insn_read) and (*insn_write) functions to read/write the timer.
    
    This is just wrong, comedi passes the channel number in the insn->chanspec.
    Use that instead and remove the private data member.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index b95da410a8e3..c328230b85ec 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -37,7 +37,6 @@ struct apci1564_private {
 	unsigned int mode2;		/* falling-edge/low level channels */
 	unsigned int ctrl;		/* interrupt mode OR (edge) . AND (level) */
 	unsigned char timer_select_mode;
-	unsigned char mode_select_register;
 	struct task_struct *tsk_current;
 };
 

commit 367ff14edd97bbd0d54e5bdfeb10201cbe491d0b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 24 10:26:06 2014 -0700

    staging: comedi: addi_apci_1564: board has 3 timers
    
    According to ADDI-DATA, the APCI-1564 only has 3 timers. There are some
    customer specific boards with 4 timers but they use out of tree drivers.
    
    Now that the timer 'channels' are handled correctly in the subdevice
    functions, fix the number of timer channels for the subdevice and remove
    the code that would access a 4th timer.
    
    Also, remove the unnecessary initialzation of the subdevice 'len_chanlist'.
    That member is only used by subdevices that support async commands.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 61a7b27b37a1..b95da410a8e3 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -68,7 +68,6 @@ static int apci1564_reset(struct comedi_device *dev)
 	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(0));
 	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(1));
 	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(2));
-	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(3));
 
 	return 0;
 }
@@ -434,9 +433,8 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	s = &dev->subdevices[3];
 	s->type		= COMEDI_SUBD_TIMER;
 	s->subdev_flags	= SDF_WRITEABLE;
-	s->n_chan	= 1;
+	s->n_chan	= 3;
 	s->maxdata	= 0;
-	s->len_chanlist	= 1;
 	s->range_table	= &range_digital;
 	s->insn_write	= apci1564_timer_write;
 	s->insn_read	= apci1564_timer_read;

commit b3ba2be24cf197cadf3614ee5203ee42ac1109a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 24 10:26:04 2014 -0700

    staging: comedi: addi_apci_1564: remove APCI1564_COUNTER[1234] defines
    
    These defines don't add any significant clarity to the driver. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 47b63e176c08..61a7b27b37a1 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -65,10 +65,10 @@ static int apci1564_reset(struct comedi_device *dev)
 	outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_RELOAD_REG);
 
 	/* Reset the counter registers */
-	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(APCI1564_COUNTER1));
-	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(APCI1564_COUNTER2));
-	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(APCI1564_COUNTER3));
-	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(APCI1564_COUNTER4));
+	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(0));
+	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(1));
+	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(2));
+	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(3));
 
 	return 0;
 }

commit c4a58f281a0c657310541dfccf176d1f40fc1add
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:48 2014 -0700

    staging: comedi: addi_apci_1564: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() to add the sample to the async buffer.
    
    The async events COMEDI_CB_BLOCK and COMEDI_CB_EOS will be detected and set
    by the core. Remove the unnecessary events in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index cf544ab1fc65..47b63e176c08 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -95,8 +95,7 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 
 		s->state = inl(dev->iobase + APCI1564_DI_INT_STATUS_REG)
 			       & 0xffff;
-		comedi_buf_put(s, s->state);
-		s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
+		comedi_buf_write_samples(s, &s->state, 1);
 		comedi_handle_events(dev, s);
 
 		/* enable the interrupt */

commit 5b6f0e9482921c4c8eeae2c01f246147b2cb4faa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:35:20 2014 -0700

    staging: comedi: addi_apci_1564: use comedi_handle_events()
    
    Use comedi_handle_events() to automatically (*cancel) the async command
    for an end-of-acquisition or if an error/overflow occurs.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 688b015a834e..cf544ab1fc65 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -97,7 +97,7 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 			       & 0xffff;
 		comedi_buf_put(s, s->state);
 		s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
-		comedi_event(dev, s);
+		comedi_handle_events(dev, s);
 
 		/* enable the interrupt */
 		outl(status, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);

commit 71f81efb22bc68533fe7a25e98361413d446850a
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat Aug 30 00:55:01 2014 -0500

    staging: comedi: addi_apci_1564: move boilerplate text to addi_apci_1564.c
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index fb6a78153529..688b015a834e 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -1,3 +1,26 @@
+/*
+ * addi_apci_1564.c
+ * Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.
+ *
+ *	ADDI-DATA GmbH
+ *	Dieselstrasse 3
+ *	D-77833 Ottersweier
+ *	Tel: +19(0)7223/9493-0
+ *	Fax: +49(0)7223/9493-92
+ *	http://www.addi-data.com
+ *	info@addi-data.com
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ */
+
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>

commit aac307f9dd5ce1fe651140a036ab4b0a0571b54a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 17:55:48 2014 -0700

    staging: comedi: comedi_pci: introduce comedi_pci_detach()
    
    Introduce a generic (*detach) function for comedi PCI drivers to handle
    the boilerplate code needed to detach a PCI driver.
    
    This function works similar to comedi_legacy_detach() where it will:
    
      * free the dev->irq if it has been requested
      * iounmap the dev->mmio addres if it has been ioremap'ed
    
    The helper then calls comedi_pci_disable() to release the regions and
    disable the PCI device.
    
    Use the new helper directly for the (*detach) in the following cases:
    
      * where comedi_pci_disable() is used directly for the (*detach)
      * where the detach function is just boilerplate
    
    Use the new helper in the (*detach) of the simpler PCI drivers. Call
    the helper after disabling interrupts (reset) and before any additional
    cleanup (kfree) to avoid any race conditions with the interrupt handler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 0940c0da96d5..fb6a78153529 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -442,9 +442,7 @@ static void apci1564_detach(struct comedi_device *dev)
 {
 	if (dev->iobase)
 		apci1564_reset(dev);
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	comedi_pci_disable(dev);
+	comedi_pci_detach(dev);
 }
 
 static struct comedi_driver apci1564_driver = {

commit cc67b0167a366f4b13935fe05abd58d396c30375
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 15:24:02 2014 -0700

    staging: comedi: addi_apci_1564: remove deadcode in apci1564_cos_cmdtest()
    
    Reported by: coverity
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index ce826456a232..0940c0da96d5 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -285,9 +285,6 @@ static int apci1564_cos_cmdtest(struct comedi_device *dev,
 	/* Step 2a : make sure trigger sources are unique */
 	/* Step 2b : and mutually compatible */
 
-	if (err)
-		return 2;
-
 	/* Step 3: check if arguments are trivially valid */
 
 	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
@@ -299,10 +296,9 @@ static int apci1564_cos_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-	/* step 4: ignored */
+	/* Step 4: fix up any arguments */
 
-	if (err)
-		return 4;
+	/* Step 5: check channel list if it exists */
 
 	return 0;
 }

commit 6caf60158821699e772a9545b030c7254519078e
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat Aug 16 23:25:16 2014 -0500

    staging: comedi: addi_apci_1564: add whitespace to subdevice init
    
    For purely aesthetic purposes, add some whitespace to subdevice initialization.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 16c02c855a65..ce826456a232 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -377,52 +377,52 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 	/*  Allocate and Initialise DI Subdevice Structures */
 	s = &dev->subdevices[0];
-	s->type = COMEDI_SUBD_DI;
-	s->subdev_flags = SDF_READABLE;
-	s->n_chan = 32;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_bits = apci1564_di_insn_bits;
+	s->type		= COMEDI_SUBD_DI;
+	s->subdev_flags	= SDF_READABLE;
+	s->n_chan	= 32;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= apci1564_di_insn_bits;
 
 	/*  Allocate and Initialise DO Subdevice Structures */
 	s = &dev->subdevices[1];
-	s->type = COMEDI_SUBD_DO;
-	s->subdev_flags = SDF_WRITEABLE;
-	s->n_chan = 32;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_bits = apci1564_do_insn_bits;
+	s->type		= COMEDI_SUBD_DO;
+	s->subdev_flags	= SDF_WRITEABLE;
+	s->n_chan	= 32;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= apci1564_do_insn_bits;
 
 	/* Change-Of-State (COS) interrupt subdevice */
 	s = &dev->subdevices[2];
 	if (dev->irq) {
 		dev->read_subdev = s;
-		s->type = COMEDI_SUBD_DI;
-		s->subdev_flags = SDF_READABLE | SDF_CMD_READ;
-		s->n_chan = 1;
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->len_chanlist = 1;
-		s->insn_config = apci1564_cos_insn_config;
-		s->insn_bits = apci1564_cos_insn_bits;
-		s->do_cmdtest = apci1564_cos_cmdtest;
-		s->do_cmd = apci1564_cos_cmd;
-		s->cancel = apci1564_cos_cancel;
+		s->type		= COMEDI_SUBD_DI;
+		s->subdev_flags	= SDF_READABLE | SDF_CMD_READ;
+		s->n_chan	= 1;
+		s->maxdata	= 1;
+		s->range_table	= &range_digital;
+		s->len_chanlist	= 1;
+		s->insn_config	= apci1564_cos_insn_config;
+		s->insn_bits	= apci1564_cos_insn_bits;
+		s->do_cmdtest	= apci1564_cos_cmdtest;
+		s->do_cmd	= apci1564_cos_cmd;
+		s->cancel	= apci1564_cos_cancel;
 	} else {
-		s->type = COMEDI_SUBD_UNUSED;
+		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
 	/*  Allocate and Initialise Timer Subdevice Structures */
 	s = &dev->subdevices[3];
-	s->type = COMEDI_SUBD_TIMER;
-	s->subdev_flags = SDF_WRITEABLE;
-	s->n_chan = 1;
-	s->maxdata = 0;
-	s->len_chanlist = 1;
-	s->range_table = &range_digital;
-	s->insn_write = apci1564_timer_write;
-	s->insn_read = apci1564_timer_read;
-	s->insn_config = apci1564_timer_config;
+	s->type		= COMEDI_SUBD_TIMER;
+	s->subdev_flags	= SDF_WRITEABLE;
+	s->n_chan	= 1;
+	s->maxdata	= 0;
+	s->len_chanlist	= 1;
+	s->range_table	= &range_digital;
+	s->insn_write	= apci1564_timer_write;
+	s->insn_read	= apci1564_timer_read;
+	s->insn_config	= apci1564_timer_config;
 
 	/* Initialize the watchdog subdevice */
 	s = &dev->subdevices[4];
@@ -432,12 +432,12 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 	/* Initialize the diagnostic status subdevice */
 	s = &dev->subdevices[5];
-	s->type = COMEDI_SUBD_DI;
-	s->subdev_flags = SDF_READABLE;
-	s->n_chan = 2;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_bits = apci1564_diag_insn_bits;
+	s->type		= COMEDI_SUBD_DI;
+	s->subdev_flags	= SDF_READABLE;
+	s->n_chan	= 2;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= apci1564_diag_insn_bits;
 
 	return 0;
 }

commit 85d7c9ab5129e96d25b455d7bf45066c376e8e2d
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Mon Aug 11 21:03:48 2014 -0500

    staging: comedi: addi_apci_1564: tidy register map defines
    
    This commit performs a final tidying of the register map defines, bringing
    them to a state that is ready for merging into addi_apci_1564.c when the
    time comes.  Actions performed include:
    
    *Removes the APCI1564_ADDRESS_RANGE macro, which is no longer needed/used.
    *Renames the APCI1564_DIGITAL_OP_{VCC,CC}_INTERRUPT_{ENABLE,DISABLE}
    macros to shorter names which are more consistent with the digital input
    interrupt macros.
    *Fixes a typo in a comment (dev>iobase changed to dev->iobase).
    *Renames the APCI1564_TCW_* macros to APCI1564_COUNTER_* names to more
    accurately reflect that they are only offsets to counter registers (since
    only the counters are offset from dev->iobase).
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengraver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 555e0a9f04c5..16c02c855a65 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -42,10 +42,10 @@ static int apci1564_reset(struct comedi_device *dev)
 	outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_RELOAD_REG);
 
 	/* Reset the counter registers */
-	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER1));
-	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER2));
-	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER3));
-	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER4));
+	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(APCI1564_COUNTER1));
+	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(APCI1564_COUNTER2));
+	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(APCI1564_COUNTER3));
+	outl(0x0, dev->iobase + APCI1564_COUNTER_CTRL_REG(APCI1564_COUNTER4));
 
 	return 0;
 }
@@ -94,17 +94,20 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 	}
 
 	for (chan = 0; chan < 4; chan++) {
-		status = inl(dev->iobase + APCI1564_TCW_IRQ_REG(chan));
+		status = inl(dev->iobase + APCI1564_COUNTER_IRQ_REG(chan));
 		if (status & 0x01) {
 			/*  Disable Counter Interrupt */
-			ctrl = inl(dev->iobase + APCI1564_TCW_CTRL_REG(chan));
-			outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(chan));
+			ctrl = inl(dev->iobase +
+				  APCI1564_COUNTER_CTRL_REG(chan));
+			outl(0x0, dev->iobase +
+			    APCI1564_COUNTER_CTRL_REG(chan));
 
 			/* Send a signal to from kernel to user space */
 			send_sig(SIGIO, devpriv->tsk_current, 0);
 
 			/*  Enable Counter Interrupt */
-			outl(ctrl, dev->iobase + APCI1564_TCW_CTRL_REG(chan));
+			outl(ctrl, dev->iobase +
+			    APCI1564_COUNTER_CTRL_REG(chan));
 		}
 	}
 

commit ecc33af33ea8f71e691db1c1000ead675dc4d34f
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Mon Aug 11 21:02:58 2014 -0500

    staging: comedi: addi_apci_1564: remove apci1564_do_config
    
    The DO config function served the purpose of configuring the diagnostic
    interrupts for the board.  As the driver currently does not support
    diagnostic interrupts, the digital output subdevice does not need an
    insn_config operation and this function can be safely removed.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 543cb074213a..555e0a9f04c5 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -388,7 +388,6 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	s->n_chan = 32;
 	s->maxdata = 1;
 	s->range_table = &range_digital;
-	s->insn_config = apci1564_do_config;
 	s->insn_bits = apci1564_do_insn_bits;
 
 	/* Change-Of-State (COS) interrupt subdevice */

commit b9aaea39f65e242303103b5283abeaefd8e538a4
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Thu Jul 31 20:56:47 2014 -0500

    staging: comedi: addi_apci_1564: remove diagnostic interrupt support code
    
    As per Ian, at this point in time it is not worth implementing an async
    command interface for diagnostic interrupts for this board.  As this is
    the case, this patch removes the code which supports such interrupts as it
    is now unused.
    
    This includes removing apci1564_do_read(), which was the insn_read
    operation for the digital output subdevice, since all it was doing was
    reading the current diagnostic interrupt type and returning it in 'data'.
    This doesn't follow the comedi API and this operation can be emulated by
    the comedi core anyway since the insn_bits operation follows the comedi
    API.  So it is safe to simply remove this function.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 819255b2d67c..543cb074213a 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -13,7 +13,6 @@ struct apci1564_private {
 	unsigned int mode1;		/* riding-edge/high level channels */
 	unsigned int mode2;		/* falling-edge/low level channels */
 	unsigned int ctrl;		/* interrupt mode OR (edge) . AND (level) */
-	unsigned int do_int_type;
 	unsigned char timer_select_mode;
 	unsigned char mode_select_register;
 	struct task_struct *tsk_current;
@@ -25,8 +24,6 @@ static int apci1564_reset(struct comedi_device *dev)
 {
 	struct apci1564_private *devpriv = dev->private;
 
-	devpriv->do_int_type = 0;
-
 	/* Disable the input interrupts and reset status register */
 	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
 	inl(devpriv->amcc_iobase + APCI1564_DI_INT_STATUS_REG);
@@ -83,20 +80,6 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 		outl(status, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
 	}
 
-	status = inl(devpriv->amcc_iobase + APCI1564_DO_IRQ_REG);
-	if (status & 0x01) {
-		/* Check for Digital Output interrupt Type */
-		/* 1: VCC interrupt			   */
-		/* 2: CC interrupt			   */
-		devpriv->do_int_type = inl(devpriv->amcc_iobase +
-					  APCI1564_DO_INT_STATUS_REG) & 0x3;
-		/* Disable the  Interrupt */
-		outl(0x0, devpriv->amcc_iobase + APCI1564_DO_INT_CTRL_REG);
-
-		/* Sends signal to user space */
-		send_sig(SIGIO, devpriv->tsk_current, 0);
-	}
-
 	status = inl(devpriv->amcc_iobase + APCI1564_TIMER_IRQ_REG);
 	if (status & 0x01) {
 		/*  Disable Timer Interrupt */
@@ -407,7 +390,6 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	s->range_table = &range_digital;
 	s->insn_config = apci1564_do_config;
 	s->insn_bits = apci1564_do_insn_bits;
-	s->insn_read = apci1564_do_read;
 
 	/* Change-Of-State (COS) interrupt subdevice */
 	s = &dev->subdevices[2];

commit 6347fc88ec4453934a5428e21051ff95cad01180
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Thu Jul 31 20:56:15 2014 -0500

    staging: comedi: addi_apci_1564: add subdevice to check diagnostic status
    
    This board provides VCC/CC diagnostic information, and it also supports
    diagnostic interrupts.  However, as per Ian, these interrupts aren't very
    useful and it is enough to simply provide an interface for accessing the
    diagnostic status on-demand.  This patch adds a 2-channel digital input
    subdevice with an insn_bits handler to access this information.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 190b02663bd0..819255b2d67c 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -157,6 +157,18 @@ static int apci1564_do_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
+static int apci1564_diag_insn_bits(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data)
+{
+	struct apci1564_private *devpriv = dev->private;
+
+	data[1] = inl(devpriv->amcc_iobase + APCI1564_DO_INT_STATUS_REG) & 3;
+
+	return insn->n;
+}
+
 /*
  * Change-Of-State (COS) interrupt configuration
  *
@@ -373,7 +385,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 			dev->irq = pcidev->irq;
 	}
 
-	ret = comedi_alloc_subdevices(dev, 5);
+	ret = comedi_alloc_subdevices(dev, 6);
 	if (ret)
 		return ret;
 
@@ -434,6 +446,15 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
+	/* Initialize the diagnostic status subdevice */
+	s = &dev->subdevices[5];
+	s->type = COMEDI_SUBD_DI;
+	s->subdev_flags = SDF_READABLE;
+	s->n_chan = 2;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_bits = apci1564_diag_insn_bits;
+
 	return 0;
 }
 

commit 1496e5961113860e97e8fc39c4fdc0e83c1fbcab
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat Jul 12 17:44:09 2014 -0500

    staging: comedi: addi_apci_1564: use addi_watchdog module to init watchdog subdevice
    
    Use the addi_watchdog module to provide support for the watchdog
    subdevice.
    
    Also, rearrange the subdevice init blocks so that the order makes sense.
    Digital input/output subdevices and subdevices for DI/DO interrupt
    support, followed by timer/counter/watchdog subdevices is the new order.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 16f3b69871ef..190b02663bd0 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -373,7 +373,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 			dev->irq = pcidev->irq;
 	}
 
-	ret = comedi_alloc_subdevices(dev, 4);
+	ret = comedi_alloc_subdevices(dev, 5);
 	if (ret)
 		return ret;
 
@@ -397,20 +397,8 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	s->insn_bits = apci1564_do_insn_bits;
 	s->insn_read = apci1564_do_read;
 
-	/*  Allocate and Initialise Timer Subdevice Structures */
-	s = &dev->subdevices[2];
-	s->type = COMEDI_SUBD_TIMER;
-	s->subdev_flags = SDF_WRITEABLE;
-	s->n_chan = 1;
-	s->maxdata = 0;
-	s->len_chanlist = 1;
-	s->range_table = &range_digital;
-	s->insn_write = apci1564_timer_write;
-	s->insn_read = apci1564_timer_read;
-	s->insn_config = apci1564_timer_config;
-
 	/* Change-Of-State (COS) interrupt subdevice */
-	s = &dev->subdevices[3];
+	s = &dev->subdevices[2];
 	if (dev->irq) {
 		dev->read_subdev = s;
 		s->type = COMEDI_SUBD_DI;
@@ -428,6 +416,24 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
+	/*  Allocate and Initialise Timer Subdevice Structures */
+	s = &dev->subdevices[3];
+	s->type = COMEDI_SUBD_TIMER;
+	s->subdev_flags = SDF_WRITEABLE;
+	s->n_chan = 1;
+	s->maxdata = 0;
+	s->len_chanlist = 1;
+	s->range_table = &range_digital;
+	s->insn_write = apci1564_timer_write;
+	s->insn_read = apci1564_timer_read;
+	s->insn_config = apci1564_timer_config;
+
+	/* Initialize the watchdog subdevice */
+	s = &dev->subdevices[4];
+	ret = addi_watchdog_init(s, devpriv->amcc_iobase + APCI1564_WDOG_REG);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 

commit 99acc5ae9b9e544adb0921c16640293010360566
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat Jul 12 17:42:36 2014 -0500

    staging: comedi: addi_apci_1564: driver no longer needs to include addi_common.h
    
    This driver no longer depends on anything in addi_common.h, save for a
    few headers that it was including indirectly.  Remove the include of
    addi_common.h and add the includes of <linux/interrupt.h>
    and <linux/sched.h> directly.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 1e25342ebc81..16f3b69871ef 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -1,13 +1,13 @@
 #include <linux/module.h>
 #include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
 
 #include "../comedidev.h"
 #include "comedi_fc.h"
 #include "amcc_s5933.h"
 #include "addi_watchdog.h"
 
-#include "addi-data/addi_common.h"
-
 struct apci1564_private {
 	unsigned int amcc_iobase;	/* base of AMCC I/O registers */
 	unsigned int mode1;		/* riding-edge/high level channels */

commit 389e4dea54e2303059dff4eacd36188d4b6fe6c3
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Thu Jul 10 23:02:55 2014 -0500

    staging: comedi: addi_apci_1564: fix s->maxdata assignment in do subdevice init.
    
    s->maxdata for the do subdevice should be 1, however currently it is
    being set to 0xffffffff.  Fix this.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index f91aedd9c869..1e25342ebc81 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -391,7 +391,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITEABLE;
 	s->n_chan = 32;
-	s->maxdata = 0xffffffff;
+	s->maxdata = 1;
 	s->range_table = &range_digital;
 	s->insn_config = apci1564_do_config;
 	s->insn_bits = apci1564_do_insn_bits;

commit 71893bb077a61c7b590bf7780422407a01a409c0
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Thu Jul 10 23:02:27 2014 -0500

    staging: comedi: addi_apci_1564: remove null check of devpriv in apci1564_detach()
    
    There is no need to test whether devpriv is null in this function.  The
    check looks left over and we can just remove it.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index e3dcab76a3bc..f91aedd9c869 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -433,14 +433,10 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 static void apci1564_detach(struct comedi_device *dev)
 {
-	struct apci1564_private *devpriv = dev->private;
-
-	if (devpriv) {
-		if (dev->iobase)
-			apci1564_reset(dev);
-		if (dev->irq)
-			free_irq(dev->irq, dev);
-	}
+	if (dev->iobase)
+		apci1564_reset(dev);
+	if (dev->irq)
+		free_irq(dev->irq, dev);
 	comedi_pci_disable(dev);
 }
 

commit eb2547db7525d14f67c6c4ad19b1ccfe14ef63ac
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Thu Jul 10 23:02:04 2014 -0500

    staging: comedi: addi_apci_1564: remove unnecessary dev->board_name initialization
    
    The dev->board_name is now initialized by the comedi core before calling
    the(*attach) or (*auto_attach) function in a driver. As long as the driver
    does no additional probing, it's no longer necessary initialize the board_name.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 675054f080d7..e3dcab76a3bc 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -353,8 +353,6 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	int ret;
 
-	dev->board_name = dev->driver->driver_name;
-
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;

commit a42ed4a564d8ff7eec3e96d02796aeb43204f9e1
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Thu Jul 10 23:01:26 2014 -0500

    staging: comedi: addi_apci_1564: remove len_chanlist from di and do subdevices
    
    This value is only needed for subdevices that support async commands.
    The comedi core will default the value to 1 when it is not initialized.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 5924421bc949..675054f080d7 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -385,7 +385,6 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	s->subdev_flags = SDF_READABLE;
 	s->n_chan = 32;
 	s->maxdata = 1;
-	s->len_chanlist = 32;
 	s->range_table = &range_digital;
 	s->insn_bits = apci1564_di_insn_bits;
 
@@ -395,7 +394,6 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	s->subdev_flags = SDF_WRITEABLE;
 	s->n_chan = 32;
 	s->maxdata = 0xffffffff;
-	s->len_chanlist = 32;
 	s->range_table = &range_digital;
 	s->insn_config = apci1564_do_config;
 	s->insn_bits = apci1564_do_insn_bits;

commit b11771aa4c22074df2b804c02433c5357514f5c5
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Wed Jul 2 21:17:21 2014 -0500

    staging: comedi: addi_apci_1564: clean up apci1564_interrupt()
    
    Remove the checks for interrupts from unknown sources.  This situation
    should never occur and the checks were doing nothing to help the
    situation.
    
    Also, the portion of the function for handling counter interrupts is
    reapeated four times (once for each counter), but is completely identical
    save for the register is is accessing, so we can handle all four counters
    with a for loop.
    
    Finally, the interrupt handler is incorrectly setting and then checking
    devpriv->timer_select_mode before processing some of the triggered
    interrupts, so just remove all occurrences of this.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk.>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 0141ed9592da..5924421bc949 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -58,48 +58,33 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct apci1564_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	unsigned int ui_DO, ui_DI;
-	unsigned int ui_Timer;
-	unsigned int ui_C1, ui_C2, ui_C3, ui_C4;
-	unsigned int ul_Command2 = 0;
+	unsigned int status;
+	unsigned int ctrl;
+	unsigned int chan;
 
 	/* check interrupt is from this device */
 	if ((inl(devpriv->amcc_iobase + AMCC_OP_REG_INTCSR) &
 	     INTCSR_INTR_ASSERTED) == 0)
 		return IRQ_NONE;
 
-	/* check which interrupt was triggered */
-	ui_DI = inl(devpriv->amcc_iobase + APCI1564_DI_IRQ_REG) &
-		   APCI1564_DI_INT_ENABLE;
-	ui_DO = inl(devpriv->amcc_iobase + APCI1564_DO_IRQ_REG) & 0x01;
-	ui_Timer = inl(devpriv->amcc_iobase + APCI1564_TIMER_IRQ_REG) & 0x01;
-	ui_C1 =
-		inl(dev->iobase + APCI1564_TCW_IRQ_REG(APCI1564_COUNTER1)) & 0x1;
-	ui_C2 =
-		inl(dev->iobase + APCI1564_TCW_IRQ_REG(APCI1564_COUNTER2)) & 0x1;
-	ui_C3 =
-		inl(dev->iobase + APCI1564_TCW_IRQ_REG(APCI1564_COUNTER3)) & 0x1;
-	ui_C4 =
-		inl(dev->iobase + APCI1564_TCW_IRQ_REG(APCI1564_COUNTER4)) & 0x1;
-	if (ui_DI == 0 && ui_DO == 0 && ui_Timer == 0 && ui_C1 == 0
-		&& ui_C2 == 0 && ui_C3 == 0 && ui_C4 == 0) {
-		return IRQ_HANDLED;
-	}
-
-	if (ui_DI) {
+	status = inl(devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+	if (status & APCI1564_DI_INT_ENABLE) {
 		/* disable the interrupt */
-		outl(ui_DI & APCI1564_DI_INT_DISABLE, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+		outl(status & APCI1564_DI_INT_DISABLE,
+		     devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
 
-		s->state = inl(dev->iobase + APCI1564_DI_INT_STATUS_REG) & 0xffff;
+		s->state = inl(dev->iobase + APCI1564_DI_INT_STATUS_REG)
+			       & 0xffff;
 		comedi_buf_put(s, s->state);
 		s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
 		comedi_event(dev, s);
 
 		/* enable the interrupt */
-		outl(ui_DI, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+		outl(status, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
 	}
 
-	if (ui_DO == 1) {
+	status = inl(devpriv->amcc_iobase + APCI1564_DO_IRQ_REG);
+	if (status & 0x01) {
 		/* Check for Digital Output interrupt Type */
 		/* 1: VCC interrupt			   */
 		/* 2: CC interrupt			   */
@@ -112,98 +97,34 @@ static irqreturn_t apci1564_interrupt(int irq, void *d)
 		send_sig(SIGIO, devpriv->tsk_current, 0);
 	}
 
-	if (ui_Timer == 1) {
-		devpriv->timer_select_mode = ADDIDATA_TIMER;
-		if (devpriv->timer_select_mode) {
-
-			/*  Disable Timer Interrupt */
-			ul_Command2 = inl(devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
-			outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
-
-			/* Send a signal to from kernel to user space */
-			send_sig(SIGIO, devpriv->tsk_current, 0);
-
-			/*  Enable Timer Interrupt */
-
-			outl(ul_Command2, devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
-		}
-	}
-
-	if (ui_C1 == 1) {
-		devpriv->timer_select_mode = ADDIDATA_COUNTER;
-		if (devpriv->timer_select_mode) {
-
-			/*  Disable Counter Interrupt */
-			ul_Command2 =
-				inl(dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER1));
-			outl(0x0,
-			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER1));
-
-			/* Send a signal to from kernel to user space */
-			send_sig(SIGIO, devpriv->tsk_current, 0);
-
-			/*  Enable Counter Interrupt */
-			outl(ul_Command2,
-			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER1));
-		}
-	}
-
-	if (ui_C2 == 1) {
-		devpriv->timer_select_mode = ADDIDATA_COUNTER;
-		if (devpriv->timer_select_mode) {
+	status = inl(devpriv->amcc_iobase + APCI1564_TIMER_IRQ_REG);
+	if (status & 0x01) {
+		/*  Disable Timer Interrupt */
+		ctrl = inl(devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
+		outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
 
-			/*  Disable Counter Interrupt */
-			ul_Command2 =
-				inl(dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER2));
-			outl(0x0,
-			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER2));
-
-			/* Send a signal to from kernel to user space */
-			send_sig(SIGIO, devpriv->tsk_current, 0);
+		/* Send a signal to from kernel to user space */
+		send_sig(SIGIO, devpriv->tsk_current, 0);
 
-			/*  Enable Counter Interrupt */
-			outl(ul_Command2,
-			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER2));
-		}
+		/*  Enable Timer Interrupt */
+		outl(ctrl, devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
 	}
 
-	if (ui_C3 == 1) {
-		devpriv->timer_select_mode = ADDIDATA_COUNTER;
-		if (devpriv->timer_select_mode) {
-
+	for (chan = 0; chan < 4; chan++) {
+		status = inl(dev->iobase + APCI1564_TCW_IRQ_REG(chan));
+		if (status & 0x01) {
 			/*  Disable Counter Interrupt */
-			ul_Command2 =
-				inl(dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER3));
-			outl(0x0,
-			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER3));
+			ctrl = inl(dev->iobase + APCI1564_TCW_CTRL_REG(chan));
+			outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(chan));
 
 			/* Send a signal to from kernel to user space */
 			send_sig(SIGIO, devpriv->tsk_current, 0);
 
 			/*  Enable Counter Interrupt */
-			outl(ul_Command2,
-			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER3));
+			outl(ctrl, dev->iobase + APCI1564_TCW_CTRL_REG(chan));
 		}
 	}
 
-	if (ui_C4 == 1) {
-		devpriv->timer_select_mode = ADDIDATA_COUNTER;
-		if (devpriv->timer_select_mode) {
-
-			/*  Disable Counter Interrupt */
-			ul_Command2 =
-				inl(dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER4));
-			outl(0x0,
-			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER4));
-
-			/* Send a signal to from kernel to user space */
-			send_sig(SIGIO, devpriv->tsk_current, 0);
-
-			/*  Enable Counter Interrupt */
-			outl(ul_Command2,
-			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER4));
-		}
-	}
 	return IRQ_HANDLED;
 }
 

commit f89ced89d8c0d155e8d802612e3860a440d04afe
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Wed Jul 2 21:17:04 2014 -0500

    staging: comedi: addi_apci_1564: fix use of apci1564_reset() to disable DI interrupts
    
    apci1564_cos_insn_config() is currently using apci1564_reset() to disable
    digital input interrupts when the configuration operation is
    COMEDI_DIGITAL_TRIG_DISABLE.  However, this is incorrect as the device reset
    function also resets the registers for the digital outputs, timer, watchdog, and
    counters as well.  Replace the reset function call with a direct disabling of
    just the digital input interrupts.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk.>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 59786e7c9582..0141ed9592da 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -285,7 +285,10 @@ static int apci1564_cos_insn_config(struct comedi_device *dev,
 			devpriv->ctrl = 0;
 			devpriv->mode1 = 0;
 			devpriv->mode2 = 0;
-			apci1564_reset(dev);
+			outl(0x0, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+			inl(devpriv->amcc_iobase + APCI1564_DI_INT_STATUS_REG);
+			outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE1_REG);
+			outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE2_REG);
 			break;
 		case COMEDI_DIGITAL_TRIG_ENABLE_EDGES:
 			if (devpriv->ctrl != (APCI1564_DI_INT_ENABLE |

commit f94f771cc667bdf9ab6a4869bcd19de41c180602
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Wed Jul 2 21:16:39 2014 -0500

    staging: comedi: addi_apci_1564: move addi_watchdog.h include to addi_apci_1564.c
    
    Commit aed3f9d (staging: comedi: addi_apci_1564: absorb apci1564_reset()) moved
    the only use of addi_watchdog.h from hwdrv_apci1564.c to addi_apci_1564.c, but
    left the include statement itself in the former file.  Move this include to the
    file which actually uses it.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk.>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index f71ee02ed626..59786e7c9582 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -4,6 +4,7 @@
 #include "../comedidev.h"
 #include "comedi_fc.h"
 #include "amcc_s5933.h"
+#include "addi_watchdog.h"
 
 #include "addi-data/addi_common.h"
 

commit 860ba36cbeadee9064e2925be11dfb8368b9b25d
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat Jun 21 17:26:10 2014 -0500

    staging: comedi: addi_apci_1564: move apci1564_interrupt() into addi_apci_1564.c
    
    On moving the function into the driver proper, also check the device is
    asserting the shared interrupt line.
    
    This patch also fixes the interrupt handling for the digital input
    change-of-state interrupts.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index fec478c6cf40..f71ee02ed626 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -3,6 +3,7 @@
 
 #include "../comedidev.h"
 #include "comedi_fc.h"
+#include "amcc_s5933.h"
 
 #include "addi-data/addi_common.h"
 
@@ -51,10 +52,158 @@ static int apci1564_reset(struct comedi_device *dev)
 	return 0;
 }
 
-static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
+static irqreturn_t apci1564_interrupt(int irq, void *d)
 {
-	apci1564_interrupt(irq, d);
-	return IRQ_RETVAL(1);
+	struct comedi_device *dev = d;
+	struct apci1564_private *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->read_subdev;
+	unsigned int ui_DO, ui_DI;
+	unsigned int ui_Timer;
+	unsigned int ui_C1, ui_C2, ui_C3, ui_C4;
+	unsigned int ul_Command2 = 0;
+
+	/* check interrupt is from this device */
+	if ((inl(devpriv->amcc_iobase + AMCC_OP_REG_INTCSR) &
+	     INTCSR_INTR_ASSERTED) == 0)
+		return IRQ_NONE;
+
+	/* check which interrupt was triggered */
+	ui_DI = inl(devpriv->amcc_iobase + APCI1564_DI_IRQ_REG) &
+		   APCI1564_DI_INT_ENABLE;
+	ui_DO = inl(devpriv->amcc_iobase + APCI1564_DO_IRQ_REG) & 0x01;
+	ui_Timer = inl(devpriv->amcc_iobase + APCI1564_TIMER_IRQ_REG) & 0x01;
+	ui_C1 =
+		inl(dev->iobase + APCI1564_TCW_IRQ_REG(APCI1564_COUNTER1)) & 0x1;
+	ui_C2 =
+		inl(dev->iobase + APCI1564_TCW_IRQ_REG(APCI1564_COUNTER2)) & 0x1;
+	ui_C3 =
+		inl(dev->iobase + APCI1564_TCW_IRQ_REG(APCI1564_COUNTER3)) & 0x1;
+	ui_C4 =
+		inl(dev->iobase + APCI1564_TCW_IRQ_REG(APCI1564_COUNTER4)) & 0x1;
+	if (ui_DI == 0 && ui_DO == 0 && ui_Timer == 0 && ui_C1 == 0
+		&& ui_C2 == 0 && ui_C3 == 0 && ui_C4 == 0) {
+		return IRQ_HANDLED;
+	}
+
+	if (ui_DI) {
+		/* disable the interrupt */
+		outl(ui_DI & APCI1564_DI_INT_DISABLE, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+
+		s->state = inl(dev->iobase + APCI1564_DI_INT_STATUS_REG) & 0xffff;
+		comedi_buf_put(s, s->state);
+		s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
+		comedi_event(dev, s);
+
+		/* enable the interrupt */
+		outl(ui_DI, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+	}
+
+	if (ui_DO == 1) {
+		/* Check for Digital Output interrupt Type */
+		/* 1: VCC interrupt			   */
+		/* 2: CC interrupt			   */
+		devpriv->do_int_type = inl(devpriv->amcc_iobase +
+					  APCI1564_DO_INT_STATUS_REG) & 0x3;
+		/* Disable the  Interrupt */
+		outl(0x0, devpriv->amcc_iobase + APCI1564_DO_INT_CTRL_REG);
+
+		/* Sends signal to user space */
+		send_sig(SIGIO, devpriv->tsk_current, 0);
+	}
+
+	if (ui_Timer == 1) {
+		devpriv->timer_select_mode = ADDIDATA_TIMER;
+		if (devpriv->timer_select_mode) {
+
+			/*  Disable Timer Interrupt */
+			ul_Command2 = inl(devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
+			outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
+
+			/* Send a signal to from kernel to user space */
+			send_sig(SIGIO, devpriv->tsk_current, 0);
+
+			/*  Enable Timer Interrupt */
+
+			outl(ul_Command2, devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
+		}
+	}
+
+	if (ui_C1 == 1) {
+		devpriv->timer_select_mode = ADDIDATA_COUNTER;
+		if (devpriv->timer_select_mode) {
+
+			/*  Disable Counter Interrupt */
+			ul_Command2 =
+				inl(dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER1));
+			outl(0x0,
+			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER1));
+
+			/* Send a signal to from kernel to user space */
+			send_sig(SIGIO, devpriv->tsk_current, 0);
+
+			/*  Enable Counter Interrupt */
+			outl(ul_Command2,
+			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER1));
+		}
+	}
+
+	if (ui_C2 == 1) {
+		devpriv->timer_select_mode = ADDIDATA_COUNTER;
+		if (devpriv->timer_select_mode) {
+
+			/*  Disable Counter Interrupt */
+			ul_Command2 =
+				inl(dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER2));
+			outl(0x0,
+			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER2));
+
+			/* Send a signal to from kernel to user space */
+			send_sig(SIGIO, devpriv->tsk_current, 0);
+
+			/*  Enable Counter Interrupt */
+			outl(ul_Command2,
+			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER2));
+		}
+	}
+
+	if (ui_C3 == 1) {
+		devpriv->timer_select_mode = ADDIDATA_COUNTER;
+		if (devpriv->timer_select_mode) {
+
+			/*  Disable Counter Interrupt */
+			ul_Command2 =
+				inl(dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER3));
+			outl(0x0,
+			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER3));
+
+			/* Send a signal to from kernel to user space */
+			send_sig(SIGIO, devpriv->tsk_current, 0);
+
+			/*  Enable Counter Interrupt */
+			outl(ul_Command2,
+			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER3));
+		}
+	}
+
+	if (ui_C4 == 1) {
+		devpriv->timer_select_mode = ADDIDATA_COUNTER;
+		if (devpriv->timer_select_mode) {
+
+			/*  Disable Counter Interrupt */
+			ul_Command2 =
+				inl(dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER4));
+			outl(0x0,
+			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER4));
+
+			/* Send a signal to from kernel to user space */
+			send_sig(SIGIO, devpriv->tsk_current, 0);
+
+			/*  Enable Counter Interrupt */
+			outl(ul_Command2,
+			     dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER4));
+		}
+	}
+	return IRQ_HANDLED;
 }
 
 static int apci1564_di_insn_bits(struct comedi_device *dev,
@@ -295,7 +444,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	apci1564_reset(dev);
 
 	if (pcidev->irq > 0) {
-		ret = request_irq(pcidev->irq, v_ADDI_Interrupt, IRQF_SHARED,
+		ret = request_irq(pcidev->irq, apci1564_interrupt, IRQF_SHARED,
 				  dev->board_name, dev);
 		if (ret == 0)
 			dev->irq = pcidev->irq;

commit 1e15687ea472614d48416c53bebcf213c07a5532
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat Jun 21 17:25:58 2014 -0500

    staging: comedi: addi_apci_1564: add Change-of-State interrupt subdevice and required functions
    
    This board supports an interrupt that can be generated by an AND/OR
    combination of 16 of the input channels.
    
    Create a separate subdevice to handle this interrupt.
    
    The apci1564_di_config() function is used to configure which
    inputs are used to generate the interrupt. Currently this function
    is broken since it does not follow the comedi API for insn_config
    functions. Fix this function by implementing the config instruction
    INSN_CONFIG_DIGITAL_TRIG.
    
    Add the remaining subdevice operations necessary for the interrupt
    subdevice to support async commands.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 1971da361b1d..fec478c6cf40 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -8,6 +8,9 @@
 
 struct apci1564_private {
 	unsigned int amcc_iobase;	/* base of AMCC I/O registers */
+	unsigned int mode1;		/* riding-edge/high level channels */
+	unsigned int mode2;		/* falling-edge/low level channels */
+	unsigned int ctrl;		/* interrupt mode OR (edge) . AND (level) */
 	unsigned int do_int_type;
 	unsigned char timer_select_mode;
 	unsigned char mode_select_register;
@@ -16,6 +19,38 @@ struct apci1564_private {
 
 #include "addi-data/hwdrv_apci1564.c"
 
+static int apci1564_reset(struct comedi_device *dev)
+{
+	struct apci1564_private *devpriv = dev->private;
+
+	devpriv->do_int_type = 0;
+
+	/* Disable the input interrupts and reset status register */
+	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+	inl(devpriv->amcc_iobase + APCI1564_DI_INT_STATUS_REG);
+	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE1_REG);
+	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE2_REG);
+
+	/* Reset the output channels and disable interrupts */
+	outl(0x0, devpriv->amcc_iobase + APCI1564_DO_REG);
+	outl(0x0, devpriv->amcc_iobase + APCI1564_DO_INT_CTRL_REG);
+
+	/* Reset the watchdog registers */
+	addi_watchdog_reset(devpriv->amcc_iobase + APCI1564_WDOG_REG);
+
+	/* Reset the timer registers */
+	outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
+	outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_RELOAD_REG);
+
+	/* Reset the counter registers */
+	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER1));
+	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER2));
+	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER3));
+	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER4));
+
+	return 0;
+}
+
 static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
 {
 	apci1564_interrupt(irq, d);
@@ -51,34 +86,187 @@ static int apci1564_do_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int apci1564_reset(struct comedi_device *dev)
+/*
+ * Change-Of-State (COS) interrupt configuration
+ *
+ * Channels 0 to 15 are interruptible. These channels can be configured
+ * to generate interrupts based on AND/OR logic for the desired channels.
+ *
+ *	OR logic
+ *		- reacts to rising or falling edges
+ *		- interrupt is generated when any enabled channel
+ *		  meet the desired interrupt condition
+ *
+ *	AND logic
+ *		- reacts to changes in level of the selected inputs
+ *		- interrupt is generated when all enabled channels
+ *		  meet the desired interrupt condition
+ *		- after an interrupt, a change in level must occur on
+ *		  the selected inputs to release the IRQ logic
+ *
+ * The COS interrupt must be configured before it can be enabled.
+ *
+ *	data[0] : INSN_CONFIG_DIGITAL_TRIG
+ *	data[1] : trigger number (= 0)
+ *	data[2] : configuration operation:
+ *	          COMEDI_DIGITAL_TRIG_DISABLE = no interrupts
+ *	          COMEDI_DIGITAL_TRIG_ENABLE_EDGES = OR (edge) interrupts
+ *	          COMEDI_DIGITAL_TRIG_ENABLE_LEVELS = AND (level) interrupts
+ *	data[3] : left-shift for data[4] and data[5]
+ *	data[4] : rising-edge/high level channels
+ *	data[5] : falling-edge/low level channels
+ */
+static int apci1564_cos_insn_config(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
 	struct apci1564_private *devpriv = dev->private;
+	unsigned int shift, oldmask;
+
+	switch (data[0]) {
+	case INSN_CONFIG_DIGITAL_TRIG:
+		if (data[1] != 0)
+			return -EINVAL;
+		shift = data[3];
+		oldmask = (1U << shift) - 1;
+		switch (data[2]) {
+		case COMEDI_DIGITAL_TRIG_DISABLE:
+			devpriv->ctrl = 0;
+			devpriv->mode1 = 0;
+			devpriv->mode2 = 0;
+			apci1564_reset(dev);
+			break;
+		case COMEDI_DIGITAL_TRIG_ENABLE_EDGES:
+			if (devpriv->ctrl != (APCI1564_DI_INT_ENABLE |
+					      APCI1564_DI_INT_OR)) {
+				/* switching to 'OR' mode */
+				devpriv->ctrl = APCI1564_DI_INT_ENABLE |
+						APCI1564_DI_INT_OR;
+				/* wipe old channels */
+				devpriv->mode1 = 0;
+				devpriv->mode2 = 0;
+			} else {
+				/* preserve unspecified channels */
+				devpriv->mode1 &= oldmask;
+				devpriv->mode2 &= oldmask;
+			}
+			/* configure specified channels */
+			devpriv->mode1 |= data[4] << shift;
+			devpriv->mode2 |= data[5] << shift;
+			break;
+		case COMEDI_DIGITAL_TRIG_ENABLE_LEVELS:
+			if (devpriv->ctrl != (APCI1564_DI_INT_ENABLE |
+					      APCI1564_DI_INT_AND)) {
+				/* switching to 'AND' mode */
+				devpriv->ctrl = APCI1564_DI_INT_ENABLE |
+						APCI1564_DI_INT_AND;
+				/* wipe old channels */
+				devpriv->mode1 = 0;
+				devpriv->mode2 = 0;
+			} else {
+				/* preserve unspecified channels */
+				devpriv->mode1 &= oldmask;
+				devpriv->mode2 &= oldmask;
+			}
+			/* configure specified channels */
+			devpriv->mode1 |= data[4] << shift;
+			devpriv->mode2 |= data[5] << shift;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return insn->n;
+}
 
-	devpriv->do_int_type = 0;
+static int apci1564_cos_insn_bits(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn,
+				  unsigned int *data)
+{
+	data[1] = s->state;
 
-	/* Disable the input interrupts and reset status register */
-	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
-	inl(devpriv->amcc_iobase + APCI1564_DI_INT_STATUS_REG);
-	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE1_REG);
-	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE2_REG);
+	return 0;
+}
 
-	/* Reset the output channels and disable interrupts */
-	outl(0x0, devpriv->amcc_iobase + APCI1564_DO_REG);
-	outl(0x0, devpriv->amcc_iobase + APCI1564_DO_INT_CTRL_REG);
+static int apci1564_cos_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd)
+{
+	int err = 0;
 
-	/* Reset the watchdog registers */
-	addi_watchdog_reset(devpriv->amcc_iobase + APCI1564_WDOG_REG);
+	/* Step 1 : check if triggers are trivially valid */
 
-	/* Reset the timer registers */
-	outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
-	outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_RELOAD_REG);
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_FOLLOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);
 
-	/* Reset the counter registers */
-	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER1));
-	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER2));
-	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER3));
-	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER4));
+	if (err)
+		return 1;
+
+	/* Step 2a : make sure trigger sources are unique */
+	/* Step 2b : and mutually compatible */
+
+	if (err)
+		return 2;
+
+	/* Step 3: check if arguments are trivially valid */
+
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+
+	if (err)
+		return 3;
+
+	/* step 4: ignored */
+
+	if (err)
+		return 4;
+
+	return 0;
+}
+
+/*
+ * Change-Of-State (COS) 'do_cmd' operation
+ *
+ * Enable the COS interrupt as configured by apci1564_cos_insn_config().
+ */
+static int apci1564_cos_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
+{
+	struct apci1564_private *devpriv = dev->private;
+
+	if (!devpriv->ctrl) {
+		dev_warn(dev->class_dev,
+			"Interrupts disabled due to mode configuration!\n");
+		return -EINVAL;
+	}
+
+	outl(devpriv->mode1, devpriv->amcc_iobase + APCI1564_DI_INT_MODE1_REG);
+	outl(devpriv->mode2, devpriv->amcc_iobase + APCI1564_DI_INT_MODE2_REG);
+	outl(devpriv->ctrl, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+
+	return 0;
+}
+
+static int apci1564_cos_cancel(struct comedi_device *dev,
+			       struct comedi_subdevice *s)
+{
+	struct apci1564_private *devpriv = dev->private;
+
+	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+	inl(devpriv->amcc_iobase + APCI1564_DI_INT_STATUS_REG);
+	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE1_REG);
+	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE2_REG);
 
 	return 0;
 }
@@ -113,7 +301,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 			dev->irq = pcidev->irq;
 	}
 
-	ret = comedi_alloc_subdevices(dev, 3);
+	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
 		return ret;
 
@@ -125,7 +313,6 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	s->maxdata = 1;
 	s->len_chanlist = 32;
 	s->range_table = &range_digital;
-	s->insn_config = apci1564_di_config;
 	s->insn_bits = apci1564_di_insn_bits;
 
 	/*  Allocate and Initialise DO Subdevice Structures */
@@ -152,6 +339,25 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	s->insn_read = apci1564_timer_read;
 	s->insn_config = apci1564_timer_config;
 
+	/* Change-Of-State (COS) interrupt subdevice */
+	s = &dev->subdevices[3];
+	if (dev->irq) {
+		dev->read_subdev = s;
+		s->type = COMEDI_SUBD_DI;
+		s->subdev_flags = SDF_READABLE | SDF_CMD_READ;
+		s->n_chan = 1;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->len_chanlist = 1;
+		s->insn_config = apci1564_cos_insn_config;
+		s->insn_bits = apci1564_cos_insn_bits;
+		s->do_cmdtest = apci1564_cos_cmdtest;
+		s->do_cmd = apci1564_cos_cmd;
+		s->cancel = apci1564_cos_cancel;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
 	return 0;
 }
 

commit 4c95a2b6b531e2caae211803d0ef88600c5d5f06
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat Jun 21 17:25:43 2014 -0500

    staging: comedi: addi_apci_1564: introduce apci1564_private struct
    
    The addi_private struct defined in addi-data/addi_common.h is very bloated
    and contains many fields which addi_apci_1564 does not require.  In the
    interest of eventually removing this driver's dependency on
    addi_common.h, we can create a private data struct specifically for
    addi_apci_1564 containing only the fields it will actually use.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 13d9962b47ec..1971da361b1d 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -6,6 +6,14 @@
 
 #include "addi-data/addi_common.h"
 
+struct apci1564_private {
+	unsigned int amcc_iobase;	/* base of AMCC I/O registers */
+	unsigned int do_int_type;
+	unsigned char timer_select_mode;
+	unsigned char mode_select_register;
+	struct task_struct *tsk_current;
+};
+
 #include "addi-data/hwdrv_apci1564.c"
 
 static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
@@ -19,9 +27,9 @@ static int apci1564_di_insn_bits(struct comedi_device *dev,
 				 struct comedi_insn *insn,
 				 unsigned int *data)
 {
-	struct addi_private *devpriv = dev->private;
+	struct apci1564_private *devpriv = dev->private;
 
-	data[1] = inl(devpriv->i_IobaseAmcc + APCI1564_DI_REG);
+	data[1] = inl(devpriv->amcc_iobase + APCI1564_DI_REG);
 
 	return insn->n;
 }
@@ -31,12 +39,12 @@ static int apci1564_do_insn_bits(struct comedi_device *dev,
 				 struct comedi_insn *insn,
 				 unsigned int *data)
 {
-	struct addi_private *devpriv = dev->private;
+	struct apci1564_private *devpriv = dev->private;
 
-	s->state = inl(devpriv->i_IobaseAmcc + APCI1564_DO_REG);
+	s->state = inl(devpriv->amcc_iobase + APCI1564_DO_REG);
 
 	if (comedi_dio_update_state(s, data))
-		outl(s->state, devpriv->i_IobaseAmcc + APCI1564_DO_REG);
+		outl(s->state, devpriv->amcc_iobase + APCI1564_DO_REG);
 
 	data[1] = s->state;
 
@@ -45,26 +53,26 @@ static int apci1564_do_insn_bits(struct comedi_device *dev,
 
 static int apci1564_reset(struct comedi_device *dev)
 {
-	struct addi_private *devpriv = dev->private;
+	struct apci1564_private *devpriv = dev->private;
 
-	ui_Type = 0;
+	devpriv->do_int_type = 0;
 
 	/* Disable the input interrupts and reset status register */
-	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_DI_IRQ_REG);
-	inl(devpriv->i_IobaseAmcc + APCI1564_DI_INT_STATUS_REG);
-	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_DI_INT_MODE1_REG);
-	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_DI_INT_MODE2_REG);
+	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_IRQ_REG);
+	inl(devpriv->amcc_iobase + APCI1564_DI_INT_STATUS_REG);
+	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE1_REG);
+	outl(0x0, devpriv->amcc_iobase + APCI1564_DI_INT_MODE2_REG);
 
 	/* Reset the output channels and disable interrupts */
-	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_DO_REG);
-	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_DO_INT_CTRL_REG);
+	outl(0x0, devpriv->amcc_iobase + APCI1564_DO_REG);
+	outl(0x0, devpriv->amcc_iobase + APCI1564_DO_INT_CTRL_REG);
 
 	/* Reset the watchdog registers */
-	addi_watchdog_reset(devpriv->i_IobaseAmcc + APCI1564_WDOG_REG);
+	addi_watchdog_reset(devpriv->amcc_iobase + APCI1564_WDOG_REG);
 
 	/* Reset the timer registers */
-	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_TIMER_CTRL_REG);
-	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_TIMER_RELOAD_REG);
+	outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_CTRL_REG);
+	outl(0x0, devpriv->amcc_iobase + APCI1564_TIMER_RELOAD_REG);
 
 	/* Reset the counter registers */
 	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER1));
@@ -79,7 +87,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 				      unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	struct addi_private *devpriv;
+	struct apci1564_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
 
@@ -94,7 +102,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 		return ret;
 
 	dev->iobase = pci_resource_start(pcidev, 1);
-	devpriv->i_IobaseAmcc = pci_resource_start(pcidev, 0);
+	devpriv->amcc_iobase = pci_resource_start(pcidev, 0);
 
 	apci1564_reset(dev);
 
@@ -149,7 +157,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 static void apci1564_detach(struct comedi_device *dev)
 {
-	struct addi_private *devpriv = dev->private;
+	struct apci1564_private *devpriv = dev->private;
 
 	if (devpriv) {
 		if (dev->iobase)

commit 96211ca58a5d43e6cb527b2a110fbc5df4d15949
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Wed May 21 19:41:15 2014 -0500

    staging: comedi: addi_apci_1564: move apci1564_do_insn_bits() to addi_apci_1564.c
    
    This function is already compliant with the comedi API and is behaving as
    comedi core expects.  This patch moves it out of
    addi-data/hwdrv_apci1564.c and into the driver proper since no further
    work needs to be done on it.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index fe477cc55af7..13d9962b47ec 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -26,6 +26,23 @@ static int apci1564_di_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
+static int apci1564_do_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
+{
+	struct addi_private *devpriv = dev->private;
+
+	s->state = inl(devpriv->i_IobaseAmcc + APCI1564_DO_REG);
+
+	if (comedi_dio_update_state(s, data))
+		outl(s->state, devpriv->i_IobaseAmcc + APCI1564_DO_REG);
+
+	data[1] = s->state;
+
+	return insn->n;
+}
+
 static int apci1564_reset(struct comedi_device *dev)
 {
 	struct addi_private *devpriv = dev->private;

commit 36682e575c7db04549ae504dd13896dd31c5a014
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Wed May 21 19:40:09 2014 -0500

    staging: comedi: addi_apci_1564: move apci1564_di_insn_bits() to addi_apci_1564.c
    
    This function is already compliant with the comedi API and is behaving as
    comedi core expects.  This patch moves it out of
    addi-data/hwdrv_apci1564.c and into the driver proper since no further
    work needs to be done on it.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index cbccbb6a2b76..fe477cc55af7 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -14,6 +14,18 @@ static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
 	return IRQ_RETVAL(1);
 }
 
+static int apci1564_di_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
+{
+	struct addi_private *devpriv = dev->private;
+
+	data[1] = inl(devpriv->i_IobaseAmcc + APCI1564_DI_REG);
+
+	return insn->n;
+}
+
 static int apci1564_reset(struct comedi_device *dev)
 {
 	struct addi_private *devpriv = dev->private;

commit 55292b3d543a313aee456b3acb4cb0290ca2977c
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Wed May 7 02:04:17 2014 -0500

    staging: comedi: addi_apci_1564: remove boardinfo
    
    This driver only supports a single board type.  Remove the boardinfo and
    its use in the driver.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index d7a5c2f9d6e3..cbccbb6a2b76 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -8,16 +8,6 @@
 
 #include "addi-data/hwdrv_apci1564.c"
 
-static const struct addi_board apci1564_boardtypes[] = {
-	{
-		.pc_DriverName		= "apci1564",
-		.i_NbrDiChannel		= 32,
-		.i_NbrDoChannel		= 32,
-		.i_DoMaxdata		= 0xffffffff,
-		.i_Timer		= 1,
-	},
-};
-
 static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
 {
 	apci1564_interrupt(irq, d);
@@ -60,12 +50,11 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 				      unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	const struct addi_board *this_board = comedi_board(dev);
 	struct addi_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
 
-	dev->board_name = this_board->pc_DriverName;
+	dev->board_name = dev->driver->driver_name;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)

commit 7af6741938c2c7dd9315fbd109172d6ca0ed6b15
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Wed May 7 02:03:32 2014 -0500

    staging: comedi: addi_apci_1564: remove check for timer subdevice
    
    The only board served by this driver always has a timer, so we can init
    the timer subdevice without checking first.
    
    The boardinfo about the timer can also be removed and the data used
    directly.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 86276cdb6f47..d7a5c2f9d6e3 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -15,9 +15,6 @@ static const struct addi_board apci1564_boardtypes[] = {
 		.i_NbrDoChannel		= 32,
 		.i_DoMaxdata		= 0xffffffff,
 		.i_Timer		= 1,
-		.timer_config		= apci1564_timer_config,
-		.timer_write		= apci1564_timer_write,
-		.timer_read		= apci1564_timer_read,
 	},
 };
 
@@ -119,21 +116,15 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 	/*  Allocate and Initialise Timer Subdevice Structures */
 	s = &dev->subdevices[2];
-	if (this_board->i_Timer) {
-		s->type = COMEDI_SUBD_TIMER;
-		s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
-		s->n_chan = 1;
-		s->maxdata = 0;
-		s->len_chanlist = 1;
-		s->range_table = &range_digital;
-
-		s->insn_write = this_board->timer_write;
-		s->insn_read = this_board->timer_read;
-		s->insn_config = this_board->timer_config;
-		s->insn_bits = this_board->timer_bits;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_TIMER;
+	s->subdev_flags = SDF_WRITEABLE;
+	s->n_chan = 1;
+	s->maxdata = 0;
+	s->len_chanlist = 1;
+	s->range_table = &range_digital;
+	s->insn_write = apci1564_timer_write;
+	s->insn_read = apci1564_timer_read;
+	s->insn_config = apci1564_timer_config;
 
 	return 0;
 }

commit 49e66262d9296e618b25d8a8128f2dff1ca59637
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat May 3 02:57:41 2014 -0500

    staging: comedi: addi_apci_1564: call apci1564_interrupt() directly
    
    Remove the boardinfo about the interrupt function and just call it
    directly.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index f1dc3710aba1..86276cdb6f47 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -15,7 +15,6 @@ static const struct addi_board apci1564_boardtypes[] = {
 		.i_NbrDoChannel		= 32,
 		.i_DoMaxdata		= 0xffffffff,
 		.i_Timer		= 1,
-		.interrupt		= apci1564_interrupt,
 		.timer_config		= apci1564_timer_config,
 		.timer_write		= apci1564_timer_write,
 		.timer_read		= apci1564_timer_read,
@@ -24,10 +23,7 @@ static const struct addi_board apci1564_boardtypes[] = {
 
 static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
 {
-	struct comedi_device *dev = d;
-	const struct addi_board *this_board = comedi_board(dev);
-
-	this_board->interrupt(irq, d);
+	apci1564_interrupt(irq, d);
 	return IRQ_RETVAL(1);
 }
 

commit aed3f9d498babd9cf4f0656e4a415cd25c725aa3
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat May 3 02:57:01 2014 -0500

    staging: comedi: addi_apci_1564: absorb apci1564_reset()
    
    This is the only reset fuction used by this driver.  We can remove it from
    the boardinfo and absorb the code from hwdrv_apci1564.c into the driver.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 1198540e0a2d..f1dc3710aba1 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -16,7 +16,6 @@ static const struct addi_board apci1564_boardtypes[] = {
 		.i_DoMaxdata		= 0xffffffff,
 		.i_Timer		= 1,
 		.interrupt		= apci1564_interrupt,
-		.reset			= apci1564_reset,
 		.timer_config		= apci1564_timer_config,
 		.timer_write		= apci1564_timer_write,
 		.timer_read		= apci1564_timer_read,
@@ -32,11 +31,35 @@ static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
 	return IRQ_RETVAL(1);
 }
 
-static int i_ADDI_Reset(struct comedi_device *dev)
+static int apci1564_reset(struct comedi_device *dev)
 {
-	const struct addi_board *this_board = comedi_board(dev);
+	struct addi_private *devpriv = dev->private;
+
+	ui_Type = 0;
+
+	/* Disable the input interrupts and reset status register */
+	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_DI_IRQ_REG);
+	inl(devpriv->i_IobaseAmcc + APCI1564_DI_INT_STATUS_REG);
+	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_DI_INT_MODE1_REG);
+	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_DI_INT_MODE2_REG);
+
+	/* Reset the output channels and disable interrupts */
+	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_DO_REG);
+	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_DO_INT_CTRL_REG);
+
+	/* Reset the watchdog registers */
+	addi_watchdog_reset(devpriv->i_IobaseAmcc + APCI1564_WDOG_REG);
+
+	/* Reset the timer registers */
+	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_TIMER_CTRL_REG);
+	outl(0x0, devpriv->i_IobaseAmcc + APCI1564_TIMER_RELOAD_REG);
+
+	/* Reset the counter registers */
+	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER1));
+	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER2));
+	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER3));
+	outl(0x0, dev->iobase + APCI1564_TCW_CTRL_REG(APCI1564_COUNTER4));
 
-	this_board->reset(dev);
 	return 0;
 }
 
@@ -62,6 +85,8 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	dev->iobase = pci_resource_start(pcidev, 1);
 	devpriv->i_IobaseAmcc = pci_resource_start(pcidev, 0);
 
+	apci1564_reset(dev);
+
 	if (pcidev->irq > 0) {
 		ret = request_irq(pcidev->irq, v_ADDI_Interrupt, IRQF_SHARED,
 				  dev->board_name, dev);
@@ -114,7 +139,6 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	i_ADDI_Reset(dev);
 	return 0;
 }
 
@@ -124,7 +148,7 @@ static void apci1564_detach(struct comedi_device *dev)
 
 	if (devpriv) {
 		if (dev->iobase)
-			i_ADDI_Reset(dev);
+			apci1564_reset(dev);
 		if (dev->irq)
 			free_irq(dev->irq, dev);
 	}

commit 9f2dbefb0ddb548b9a062f6ca729534efc15b0d6
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat May 3 02:56:27 2014 -0500

    staging: comedi: addi_apci_1564: don't allocate unused subdevices
    
    The addi-data common code always allocates 7 subdevices.  This driver
    cannot or will not use the ones we are currently allocating for analog
    input and output or EEPROM, so just don't allocate these subdevices at
    all.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index fbc82ad0de3a..1198540e0a2d 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -47,7 +47,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	const struct addi_board *this_board = comedi_board(dev);
 	struct addi_private *devpriv;
 	struct comedi_subdevice *s;
-	int ret, n_subdevices;
+	int ret;
 
 	dev->board_name = this_board->pc_DriverName;
 
@@ -69,21 +69,12 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 			dev->irq = pcidev->irq;
 	}
 
-	n_subdevices = 7;
-	ret = comedi_alloc_subdevices(dev, n_subdevices);
+	ret = comedi_alloc_subdevices(dev, 3);
 	if (ret)
 		return ret;
 
-	/*  Allocate and Initialise AI Subdevice Structures */
-	s = &dev->subdevices[0];
-	s->type = COMEDI_SUBD_UNUSED;
-
-	/*  Allocate and Initialise AO Subdevice Structures */
-	s = &dev->subdevices[1];
-	s->type = COMEDI_SUBD_UNUSED;
-
 	/*  Allocate and Initialise DI Subdevice Structures */
-	s = &dev->subdevices[2];
+	s = &dev->subdevices[0];
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE;
 	s->n_chan = 32;
@@ -94,7 +85,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	s->insn_bits = apci1564_di_insn_bits;
 
 	/*  Allocate and Initialise DO Subdevice Structures */
-	s = &dev->subdevices[3];
+	s = &dev->subdevices[1];
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITEABLE;
 	s->n_chan = 32;
@@ -106,7 +97,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	s->insn_read = apci1564_do_read;
 
 	/*  Allocate and Initialise Timer Subdevice Structures */
-	s = &dev->subdevices[4];
+	s = &dev->subdevices[2];
 	if (this_board->i_Timer) {
 		s->type = COMEDI_SUBD_TIMER;
 		s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
@@ -123,14 +114,6 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	/*  Allocate and Initialise TTL */
-	s = &dev->subdevices[5];
-	s->type = COMEDI_SUBD_UNUSED;
-
-	/* EEPROM */
-	s = &dev->subdevices[6];
-	s->type = COMEDI_SUBD_UNUSED;
-
 	i_ADDI_Reset(dev);
 	return 0;
 }

commit 33ae8a5ed3017cfca5742deff4039dd912690015
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat May 3 02:55:29 2014 -0500

    staging: comedi: addi_apci_1564: board has 32 digital outputs
    
    This board always has 32 digital outputs.  Remove the test when
    initializing the subdevice.
    
    Also, since this board is the only one supported by this driver, remove
    the boardinfo about the digital outputs and just use the data directly in
    the subdevice init.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index ea22530a5cbd..fbc82ad0de3a 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -17,9 +17,6 @@ static const struct addi_board apci1564_boardtypes[] = {
 		.i_Timer		= 1,
 		.interrupt		= apci1564_interrupt,
 		.reset			= apci1564_reset,
-		.do_config		= apci1564_do_config,
-		.do_bits		= apci1564_do_insn_bits,
-		.do_read		= apci1564_do_read,
 		.timer_config		= apci1564_timer_config,
 		.timer_write		= apci1564_timer_write,
 		.timer_read		= apci1564_timer_read,
@@ -98,23 +95,15 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 	/*  Allocate and Initialise DO Subdevice Structures */
 	s = &dev->subdevices[3];
-	if (this_board->i_NbrDoChannel) {
-		s->type = COMEDI_SUBD_DO;
-		s->subdev_flags =
-			SDF_READABLE | SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
-		s->n_chan = this_board->i_NbrDoChannel;
-		s->maxdata = this_board->i_DoMaxdata;
-		s->len_chanlist = this_board->i_NbrDoChannel;
-		s->range_table = &range_digital;
-
-		/* insn_config - for digital output memory */
-		s->insn_config = this_board->do_config;
-		s->insn_write = this_board->do_write;
-		s->insn_bits = this_board->do_bits;
-		s->insn_read = this_board->do_read;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_DO;
+	s->subdev_flags = SDF_WRITEABLE;
+	s->n_chan = 32;
+	s->maxdata = 0xffffffff;
+	s->len_chanlist = 32;
+	s->range_table = &range_digital;
+	s->insn_config = apci1564_do_config;
+	s->insn_bits = apci1564_do_insn_bits;
+	s->insn_read = apci1564_do_read;
 
 	/*  Allocate and Initialise Timer Subdevice Structures */
 	s = &dev->subdevices[4];

commit 66d76f19d6aa863ac5b3e38be345daf9b609f226
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat May 3 02:49:15 2014 -0500

    staging: comedi: addi_apci_1564: remove use of devpriv->s_EeParameters
    
    This driver no longer reads the eeprom to find the board specific data,
    all the necessary data is in the boardinfo. Use the boardinfo directly
    instead of passing through devpriv->s_EeParameters.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 4ac3afa87697..ea22530a5cbd 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -65,22 +65,6 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	dev->iobase = pci_resource_start(pcidev, 1);
 	devpriv->i_IobaseAmcc = pci_resource_start(pcidev, 0);
 
-	/* Initialize parameters that can be overridden in EEPROM */
-	devpriv->s_EeParameters.i_NbrAiChannel = this_board->i_NbrAiChannel;
-	devpriv->s_EeParameters.i_NbrAoChannel = this_board->i_NbrAoChannel;
-	devpriv->s_EeParameters.i_AiMaxdata = this_board->i_AiMaxdata;
-	devpriv->s_EeParameters.i_AoMaxdata = this_board->i_AoMaxdata;
-	devpriv->s_EeParameters.i_NbrDiChannel = this_board->i_NbrDiChannel;
-	devpriv->s_EeParameters.i_NbrDoChannel = this_board->i_NbrDoChannel;
-	devpriv->s_EeParameters.i_DoMaxdata = this_board->i_DoMaxdata;
-	devpriv->s_EeParameters.i_Timer = this_board->i_Timer;
-	devpriv->s_EeParameters.ui_MinAcquisitiontimeNs =
-		this_board->ui_MinAcquisitiontimeNs;
-	devpriv->s_EeParameters.ui_MinDelaytimeNs =
-		this_board->ui_MinDelaytimeNs;
-
-	/* ## */
-
 	if (pcidev->irq > 0) {
 		ret = request_irq(pcidev->irq, v_ADDI_Interrupt, IRQF_SHARED,
 				  dev->board_name, dev);
@@ -114,14 +98,13 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 	/*  Allocate and Initialise DO Subdevice Structures */
 	s = &dev->subdevices[3];
-	if (devpriv->s_EeParameters.i_NbrDoChannel) {
+	if (this_board->i_NbrDoChannel) {
 		s->type = COMEDI_SUBD_DO;
 		s->subdev_flags =
 			SDF_READABLE | SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
-		s->n_chan = devpriv->s_EeParameters.i_NbrDoChannel;
-		s->maxdata = devpriv->s_EeParameters.i_DoMaxdata;
-		s->len_chanlist =
-			devpriv->s_EeParameters.i_NbrDoChannel;
+		s->n_chan = this_board->i_NbrDoChannel;
+		s->maxdata = this_board->i_DoMaxdata;
+		s->len_chanlist = this_board->i_NbrDoChannel;
 		s->range_table = &range_digital;
 
 		/* insn_config - for digital output memory */
@@ -135,7 +118,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 	/*  Allocate and Initialise Timer Subdevice Structures */
 	s = &dev->subdevices[4];
-	if (devpriv->s_EeParameters.i_Timer) {
+	if (this_board->i_Timer) {
 		s->type = COMEDI_SUBD_TIMER;
 		s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
 		s->n_chan = 1;

commit a7e04a080831087e1413e5651c0bf59f5dcfa409
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Tue Apr 29 03:37:17 2014 -0500

    staging: comedi: addi_apci_1564: remove unnecessary info from boardinfo
    
    The i_IorangeBase1, i_PCIEeprom, and pc_EepromChip data in the boardinfo
    was only needed to work out the usage of the PCI bars.  Now that that is
    squared away, this info is no longer needed and can be removed.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 9962c28a0de0..4ac3afa87697 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -11,9 +11,6 @@
 static const struct addi_board apci1564_boardtypes[] = {
 	{
 		.pc_DriverName		= "apci1564",
-		.i_IorangeBase1		= APCI1564_ADDRESS_RANGE,
-		.i_PCIEeprom		= ADDIDATA_EEPROM,
-		.pc_EepromChip		= ADDIDATA_93C76,
 		.i_NbrDiChannel		= 32,
 		.i_NbrDoChannel		= 32,
 		.i_DoMaxdata		= 0xffffffff,

commit 128f798918c398b5ae84e5734c3b5df8c35d5d94
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Wed Apr 30 02:57:59 2014 -0500

    staging: comedi: addi_apci_1564: simplify the PCI bar reading and don't read the unused bars
    
    This driver only uses PCI bar 0 (devpriv->i_IobaseAmcc), and PCI bar 1
    (dev->iobase), don't bother reading the unused PCI bars.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index fe42f9d8f1d1..9962c28a0de0 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -65,15 +65,8 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	if (this_board->i_IorangeBase1)
-		dev->iobase = pci_resource_start(pcidev, 1);
-	else
-		dev->iobase = pci_resource_start(pcidev, 0);
-
-	devpriv->iobase = dev->iobase;
+	dev->iobase = pci_resource_start(pcidev, 1);
 	devpriv->i_IobaseAmcc = pci_resource_start(pcidev, 0);
-	devpriv->i_IobaseAddon = pci_resource_start(pcidev, 2);
-	devpriv->i_IobaseReserved = pci_resource_start(pcidev, 3);
 
 	/* Initialize parameters that can be overridden in EEPROM */
 	devpriv->s_EeParameters.i_NbrAiChannel = this_board->i_NbrAiChannel;

commit cffd83b6d1e6e403a77c5babf1443cdfd1a080ef
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Tue Apr 29 03:34:23 2014 -0500

    staging: comedi: addi_apci_1564: board has 32 digital inputs
    
    This board always has 32 digital inputs. Remove the test when
    initializing the subdevice.
    
    Also, since this board is the only one supported by this driver,
    remove the boardinfo about the digital inputs and just use the
    data directly in the subdevice init.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index c84e17c60cec..fe42f9d8f1d1 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -20,8 +20,6 @@ static const struct addi_board apci1564_boardtypes[] = {
 		.i_Timer		= 1,
 		.interrupt		= apci1564_interrupt,
 		.reset			= apci1564_reset,
-		.di_config		= apci1564_di_config,
-		.di_bits		= apci1564_di_insn_bits,
 		.do_config		= apci1564_do_config,
 		.do_bits		= apci1564_do_insn_bits,
 		.do_read		= apci1564_do_read,
@@ -115,21 +113,15 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 	/*  Allocate and Initialise DI Subdevice Structures */
 	s = &dev->subdevices[2];
-	if (devpriv->s_EeParameters.i_NbrDiChannel) {
-		s->type = COMEDI_SUBD_DI;
-		s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON;
-		s->n_chan = devpriv->s_EeParameters.i_NbrDiChannel;
-		s->maxdata = 1;
-		s->len_chanlist =
-			devpriv->s_EeParameters.i_NbrDiChannel;
-		s->range_table = &range_digital;
-		s->insn_config = this_board->di_config;
-		s->insn_read = this_board->di_read;
-		s->insn_write = this_board->di_write;
-		s->insn_bits = this_board->di_bits;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_DI;
+	s->subdev_flags = SDF_READABLE;
+	s->n_chan = 32;
+	s->maxdata = 1;
+	s->len_chanlist = 32;
+	s->range_table = &range_digital;
+	s->insn_config = apci1564_di_config;
+	s->insn_bits = apci1564_di_insn_bits;
+
 	/*  Allocate and Initialise DO Subdevice Structures */
 	s = &dev->subdevices[3];
 	if (devpriv->s_EeParameters.i_NbrDoChannel) {

commit 6aa4f14c1febf0f602c5516857303de9cc05d6e6
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat Apr 26 20:36:44 2014 -0500

    staging: comedi: addi_apci_1564: remove unnecessary include
    
    This include is no longer needed.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index df8833b741f5..c84e17c60cec 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -3,7 +3,6 @@
 
 #include "../comedidev.h"
 #include "comedi_fc.h"
-#include "amcc_s5933.h"
 
 #include "addi-data/addi_common.h"
 

commit 4ae63178637d03bca6b58336ad3e4b3af9e60339
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sat Apr 26 20:35:58 2014 -0500

    staging: comedi: addi_apci_1564: remove eeprom support code
    
    Reading the eeprom on this board is not necessary.  All information
    required is in the boardinfo.
    
    Remove the eeprom support code which is not really useful here.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 5f6d3b56fad2..df8833b741f5 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -7,7 +7,6 @@
 
 #include "addi-data/addi_common.h"
 
-#include "addi-data/addi_eeprom.c"
 #include "addi-data/hwdrv_apci1564.c"
 
 static const struct addi_board apci1564_boardtypes[] = {
@@ -33,23 +32,6 @@ static const struct addi_board apci1564_boardtypes[] = {
 	},
 };
 
-static int i_ADDIDATA_InsnReadEeprom(struct comedi_device *dev,
-				     struct comedi_subdevice *s,
-				     struct comedi_insn *insn,
-				     unsigned int *data)
-{
-	const struct addi_board *this_board = comedi_board(dev);
-	struct addi_private *devpriv = dev->private;
-	unsigned short w_Address = CR_CHAN(insn->chanspec);
-	unsigned short w_Data;
-
-	w_Data = addi_eeprom_readw(devpriv->i_IobaseAmcc,
-		this_board->pc_EepromChip, 2 * w_Address);
-	data[0] = w_Data;
-
-	return insn->n;
-}
-
 static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -75,7 +57,6 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 	struct addi_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret, n_subdevices;
-	unsigned int dw_Dummy;
 
 	dev->board_name = this_board->pc_DriverName;
 
@@ -120,23 +101,6 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 			dev->irq = pcidev->irq;
 	}
 
-	/*  Read eepeom and fill addi_board Structure */
-
-	if (this_board->i_PCIEeprom) {
-		if (!(strcmp(this_board->pc_EepromChip, "S5920"))) {
-			/*  Set 3 wait stait */
-			if (!(strcmp(dev->board_name, "apci035")))
-				outl(0x80808082, devpriv->i_IobaseAmcc + 0x60);
-			else
-				outl(0x83838383, devpriv->i_IobaseAmcc + 0x60);
-
-			/*  Enable the interrupt for the controller */
-			dw_Dummy = inl(devpriv->i_IobaseAmcc + 0x38);
-			outl(dw_Dummy | 0x2000, devpriv->i_IobaseAmcc + 0x38);
-		}
-		addi_eeprom_read_info(dev, pci_resource_start(pcidev, 0));
-	}
-
 	n_subdevices = 7;
 	ret = comedi_alloc_subdevices(dev, n_subdevices);
 	if (ret)
@@ -212,15 +176,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 	/* EEPROM */
 	s = &dev->subdevices[6];
-	if (this_board->i_PCIEeprom) {
-		s->type = COMEDI_SUBD_MEMORY;
-		s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
-		s->n_chan = 256;
-		s->maxdata = 0xffff;
-		s->insn_read = i_ADDIDATA_InsnReadEeprom;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_UNUSED;
 
 	i_ADDI_Reset(dev);
 	return 0;

commit 66037ce98d911bc2b15b23128e4447ea719f26e3
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Fri Apr 25 03:18:10 2014 -0500

    staging: comedi: addi_apci_1564: board does not have analog outputs
    
    The board supported by this driver does not have analog outputs.  Remove
    the subdevice init for it.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index eee10cc68af1..5f6d3b56fad2 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -148,17 +148,8 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 	/*  Allocate and Initialise AO Subdevice Structures */
 	s = &dev->subdevices[1];
-	if (devpriv->s_EeParameters.i_NbrAoChannel) {
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
-		s->n_chan = devpriv->s_EeParameters.i_NbrAoChannel;
-		s->maxdata = devpriv->s_EeParameters.i_AoMaxdata;
-		s->len_chanlist =
-			devpriv->s_EeParameters.i_NbrAoChannel;
-		s->insn_write = this_board->ao_write;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_UNUSED;
+
 	/*  Allocate and Initialise DI Subdevice Structures */
 	s = &dev->subdevices[2];
 	if (devpriv->s_EeParameters.i_NbrDiChannel) {

commit 0ca26722f5b5bb2a763be65c38021cb6dc8289a4
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Fri Apr 25 03:17:06 2014 -0500

    staging: comedi: addi_apci_1564: board does not have analog inputs
    
    This board does not have analog inputs.  Remove the subdevice init for
    them.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 792916d230e1..eee10cc68af1 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -144,36 +144,7 @@ static int apci1564_auto_attach(struct comedi_device *dev,
 
 	/*  Allocate and Initialise AI Subdevice Structures */
 	s = &dev->subdevices[0];
-	if ((devpriv->s_EeParameters.i_NbrAiChannel)
-		|| (this_board->i_NbrAiChannelDiff)) {
-		dev->read_subdev = s;
-		s->type = COMEDI_SUBD_AI;
-		s->subdev_flags =
-			SDF_READABLE | SDF_COMMON | SDF_GROUND
-			| SDF_DIFF;
-		if (devpriv->s_EeParameters.i_NbrAiChannel) {
-			s->n_chan =
-				devpriv->s_EeParameters.i_NbrAiChannel;
-			devpriv->b_SingelDiff = 0;
-		} else {
-			s->n_chan = this_board->i_NbrAiChannelDiff;
-			devpriv->b_SingelDiff = 1;
-		}
-		s->maxdata = devpriv->s_EeParameters.i_AiMaxdata;
-		s->len_chanlist = this_board->i_AiChannelList;
-		s->range_table = this_board->pr_AiRangelist;
-
-		s->insn_config = this_board->ai_config;
-		s->insn_read = this_board->ai_read;
-		s->insn_write = this_board->ai_write;
-		s->insn_bits = this_board->ai_bits;
-		s->do_cmdtest = this_board->ai_cmdtest;
-		s->do_cmd = this_board->ai_cmd;
-		s->cancel = this_board->ai_cancel;
-
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_UNUSED;
 
 	/*  Allocate and Initialise AO Subdevice Structures */
 	s = &dev->subdevices[1];

commit b30c3e824ebaa142bf7361c567612727d24af717
Author: Chase Southwood <chase.southwood@yahoo.com>
Date:   Thu Apr 24 02:19:01 2014 -0500

    staging: comedi: addi_apci_1564: separate from addi_common.c
    
    Using the addi-data "common" code in addi_apci_1564 introduces a lot of
    bloat.  By separating this driver off from addi_common.c, a lot of the
    common code can be stripped out.  This patch copies the code over from
    addi_common.c, and removes the #include of the file.  The auto_attach
    function from the common code replaces the one that was previously in this
    driver, though renamed to that it stays within the namespace associated
    with this driver, and the detach function has been renamed for this reason
    as well.
    
    Signed-off-by: Chase Southwood <chase.southwood@yahoo.com>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 11aa0bd5d7b1..792916d230e1 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -9,7 +9,6 @@
 
 #include "addi-data/addi_eeprom.c"
 #include "addi-data/hwdrv_apci1564.c"
-#include "addi-data/addi_common.c"
 
 static const struct addi_board apci1564_boardtypes[] = {
 	{
@@ -34,19 +33,255 @@ static const struct addi_board apci1564_boardtypes[] = {
 	},
 };
 
+static int i_ADDIDATA_InsnReadEeprom(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
+{
+	const struct addi_board *this_board = comedi_board(dev);
+	struct addi_private *devpriv = dev->private;
+	unsigned short w_Address = CR_CHAN(insn->chanspec);
+	unsigned short w_Data;
+
+	w_Data = addi_eeprom_readw(devpriv->i_IobaseAmcc,
+		this_board->pc_EepromChip, 2 * w_Address);
+	data[0] = w_Data;
+
+	return insn->n;
+}
+
+static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
+{
+	struct comedi_device *dev = d;
+	const struct addi_board *this_board = comedi_board(dev);
+
+	this_board->interrupt(irq, d);
+	return IRQ_RETVAL(1);
+}
+
+static int i_ADDI_Reset(struct comedi_device *dev)
+{
+	const struct addi_board *this_board = comedi_board(dev);
+
+	this_board->reset(dev);
+	return 0;
+}
+
 static int apci1564_auto_attach(struct comedi_device *dev,
-				unsigned long context)
+				      unsigned long context_unused)
+{
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	const struct addi_board *this_board = comedi_board(dev);
+	struct addi_private *devpriv;
+	struct comedi_subdevice *s;
+	int ret, n_subdevices;
+	unsigned int dw_Dummy;
+
+	dev->board_name = this_board->pc_DriverName;
+
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
+	if (!devpriv)
+		return -ENOMEM;
+
+	ret = comedi_pci_enable(dev);
+	if (ret)
+		return ret;
+
+	if (this_board->i_IorangeBase1)
+		dev->iobase = pci_resource_start(pcidev, 1);
+	else
+		dev->iobase = pci_resource_start(pcidev, 0);
+
+	devpriv->iobase = dev->iobase;
+	devpriv->i_IobaseAmcc = pci_resource_start(pcidev, 0);
+	devpriv->i_IobaseAddon = pci_resource_start(pcidev, 2);
+	devpriv->i_IobaseReserved = pci_resource_start(pcidev, 3);
+
+	/* Initialize parameters that can be overridden in EEPROM */
+	devpriv->s_EeParameters.i_NbrAiChannel = this_board->i_NbrAiChannel;
+	devpriv->s_EeParameters.i_NbrAoChannel = this_board->i_NbrAoChannel;
+	devpriv->s_EeParameters.i_AiMaxdata = this_board->i_AiMaxdata;
+	devpriv->s_EeParameters.i_AoMaxdata = this_board->i_AoMaxdata;
+	devpriv->s_EeParameters.i_NbrDiChannel = this_board->i_NbrDiChannel;
+	devpriv->s_EeParameters.i_NbrDoChannel = this_board->i_NbrDoChannel;
+	devpriv->s_EeParameters.i_DoMaxdata = this_board->i_DoMaxdata;
+	devpriv->s_EeParameters.i_Timer = this_board->i_Timer;
+	devpriv->s_EeParameters.ui_MinAcquisitiontimeNs =
+		this_board->ui_MinAcquisitiontimeNs;
+	devpriv->s_EeParameters.ui_MinDelaytimeNs =
+		this_board->ui_MinDelaytimeNs;
+
+	/* ## */
+
+	if (pcidev->irq > 0) {
+		ret = request_irq(pcidev->irq, v_ADDI_Interrupt, IRQF_SHARED,
+				  dev->board_name, dev);
+		if (ret == 0)
+			dev->irq = pcidev->irq;
+	}
+
+	/*  Read eepeom and fill addi_board Structure */
+
+	if (this_board->i_PCIEeprom) {
+		if (!(strcmp(this_board->pc_EepromChip, "S5920"))) {
+			/*  Set 3 wait stait */
+			if (!(strcmp(dev->board_name, "apci035")))
+				outl(0x80808082, devpriv->i_IobaseAmcc + 0x60);
+			else
+				outl(0x83838383, devpriv->i_IobaseAmcc + 0x60);
+
+			/*  Enable the interrupt for the controller */
+			dw_Dummy = inl(devpriv->i_IobaseAmcc + 0x38);
+			outl(dw_Dummy | 0x2000, devpriv->i_IobaseAmcc + 0x38);
+		}
+		addi_eeprom_read_info(dev, pci_resource_start(pcidev, 0));
+	}
+
+	n_subdevices = 7;
+	ret = comedi_alloc_subdevices(dev, n_subdevices);
+	if (ret)
+		return ret;
+
+	/*  Allocate and Initialise AI Subdevice Structures */
+	s = &dev->subdevices[0];
+	if ((devpriv->s_EeParameters.i_NbrAiChannel)
+		|| (this_board->i_NbrAiChannelDiff)) {
+		dev->read_subdev = s;
+		s->type = COMEDI_SUBD_AI;
+		s->subdev_flags =
+			SDF_READABLE | SDF_COMMON | SDF_GROUND
+			| SDF_DIFF;
+		if (devpriv->s_EeParameters.i_NbrAiChannel) {
+			s->n_chan =
+				devpriv->s_EeParameters.i_NbrAiChannel;
+			devpriv->b_SingelDiff = 0;
+		} else {
+			s->n_chan = this_board->i_NbrAiChannelDiff;
+			devpriv->b_SingelDiff = 1;
+		}
+		s->maxdata = devpriv->s_EeParameters.i_AiMaxdata;
+		s->len_chanlist = this_board->i_AiChannelList;
+		s->range_table = this_board->pr_AiRangelist;
+
+		s->insn_config = this_board->ai_config;
+		s->insn_read = this_board->ai_read;
+		s->insn_write = this_board->ai_write;
+		s->insn_bits = this_board->ai_bits;
+		s->do_cmdtest = this_board->ai_cmdtest;
+		s->do_cmd = this_board->ai_cmd;
+		s->cancel = this_board->ai_cancel;
+
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/*  Allocate and Initialise AO Subdevice Structures */
+	s = &dev->subdevices[1];
+	if (devpriv->s_EeParameters.i_NbrAoChannel) {
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
+		s->n_chan = devpriv->s_EeParameters.i_NbrAoChannel;
+		s->maxdata = devpriv->s_EeParameters.i_AoMaxdata;
+		s->len_chanlist =
+			devpriv->s_EeParameters.i_NbrAoChannel;
+		s->insn_write = this_board->ao_write;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+	/*  Allocate and Initialise DI Subdevice Structures */
+	s = &dev->subdevices[2];
+	if (devpriv->s_EeParameters.i_NbrDiChannel) {
+		s->type = COMEDI_SUBD_DI;
+		s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON;
+		s->n_chan = devpriv->s_EeParameters.i_NbrDiChannel;
+		s->maxdata = 1;
+		s->len_chanlist =
+			devpriv->s_EeParameters.i_NbrDiChannel;
+		s->range_table = &range_digital;
+		s->insn_config = this_board->di_config;
+		s->insn_read = this_board->di_read;
+		s->insn_write = this_board->di_write;
+		s->insn_bits = this_board->di_bits;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+	/*  Allocate and Initialise DO Subdevice Structures */
+	s = &dev->subdevices[3];
+	if (devpriv->s_EeParameters.i_NbrDoChannel) {
+		s->type = COMEDI_SUBD_DO;
+		s->subdev_flags =
+			SDF_READABLE | SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
+		s->n_chan = devpriv->s_EeParameters.i_NbrDoChannel;
+		s->maxdata = devpriv->s_EeParameters.i_DoMaxdata;
+		s->len_chanlist =
+			devpriv->s_EeParameters.i_NbrDoChannel;
+		s->range_table = &range_digital;
+
+		/* insn_config - for digital output memory */
+		s->insn_config = this_board->do_config;
+		s->insn_write = this_board->do_write;
+		s->insn_bits = this_board->do_bits;
+		s->insn_read = this_board->do_read;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/*  Allocate and Initialise Timer Subdevice Structures */
+	s = &dev->subdevices[4];
+	if (devpriv->s_EeParameters.i_Timer) {
+		s->type = COMEDI_SUBD_TIMER;
+		s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
+		s->n_chan = 1;
+		s->maxdata = 0;
+		s->len_chanlist = 1;
+		s->range_table = &range_digital;
+
+		s->insn_write = this_board->timer_write;
+		s->insn_read = this_board->timer_read;
+		s->insn_config = this_board->timer_config;
+		s->insn_bits = this_board->timer_bits;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/*  Allocate and Initialise TTL */
+	s = &dev->subdevices[5];
+	s->type = COMEDI_SUBD_UNUSED;
+
+	/* EEPROM */
+	s = &dev->subdevices[6];
+	if (this_board->i_PCIEeprom) {
+		s->type = COMEDI_SUBD_MEMORY;
+		s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
+		s->n_chan = 256;
+		s->maxdata = 0xffff;
+		s->insn_read = i_ADDIDATA_InsnReadEeprom;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	i_ADDI_Reset(dev);
+	return 0;
+}
+
+static void apci1564_detach(struct comedi_device *dev)
 {
-	dev->board_ptr = &apci1564_boardtypes[0];
+	struct addi_private *devpriv = dev->private;
 
-	return addi_auto_attach(dev, context);
+	if (devpriv) {
+		if (dev->iobase)
+			i_ADDI_Reset(dev);
+		if (dev->irq)
+			free_irq(dev->irq, dev);
+	}
+	comedi_pci_disable(dev);
 }
 
 static struct comedi_driver apci1564_driver = {
 	.driver_name	= "addi_apci_1564",
 	.module		= THIS_MODULE,
 	.auto_attach	= apci1564_auto_attach,
-	.detach		= i_ADDI_Detach,
+	.detach		= apci1564_detach,
 };
 
 static int apci1564_pci_probe(struct pci_dev *dev,

commit b5ebcaa8d3405e14ca431257fd6c6cdc30df13c5
Author: Georg Gast <georg@schorsch-tech.de>
Date:   Tue Apr 8 18:52:58 2014 +0200

    staging: comedi: more descriptive names for addi-data drivers
    
    - more descriptive module description for following boards:
      ADDI-DATA APCI 1032/1500/1564/2032/3120
    
    Signed-off-by: Georg Gast <georg@schorsch-tech.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 27aa9ae1bdd9..11aa0bd5d7b1 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -70,5 +70,5 @@ static struct pci_driver apci1564_pci_driver = {
 module_comedi_pci_driver(apci1564_driver, apci1564_pci_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_DESCRIPTION("ADDI-DATA APCI-1564, 32 channel DI / 32 channel DO boards");
 MODULE_LICENSE("GPL");

commit 805077b90c5a290ec050d5003a4ea9e37be48453
Author: Fred Akers <knivey@botops.net>
Date:   Tue Mar 11 18:19:12 2014 -0400

    Staging: comedi: addi-data: Fix long CamelCase function names
    
    This patch fixes a few function names that are very long and are
    not in the correct naming style
    
    Signed-off-by: Fred Akers <knivey@botops.net>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 6248284caaf5..27aa9ae1bdd9 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -21,16 +21,16 @@ static const struct addi_board apci1564_boardtypes[] = {
 		.i_NbrDoChannel		= 32,
 		.i_DoMaxdata		= 0xffffffff,
 		.i_Timer		= 1,
-		.interrupt		= v_APCI1564_Interrupt,
-		.reset			= i_APCI1564_Reset,
-		.di_config		= i_APCI1564_ConfigDigitalInput,
+		.interrupt		= apci1564_interrupt,
+		.reset			= apci1564_reset,
+		.di_config		= apci1564_di_config,
 		.di_bits		= apci1564_di_insn_bits,
-		.do_config		= i_APCI1564_ConfigDigitalOutput,
+		.do_config		= apci1564_do_config,
 		.do_bits		= apci1564_do_insn_bits,
-		.do_read		= i_APCI1564_ReadInterruptStatus,
-		.timer_config		= i_APCI1564_ConfigTimerCounterWatchdog,
-		.timer_write		= i_APCI1564_StartStopWriteTimerCounterWatchdog,
-		.timer_read		= i_APCI1564_ReadTimerCounterWatchdog,
+		.do_read		= apci1564_do_read,
+		.timer_config		= apci1564_timer_config,
+		.timer_write		= apci1564_timer_write,
+		.timer_read		= apci1564_timer_read,
 	},
 };
 

commit 41e043fcfa2236bb2c4a8335eb09f4c8cee224b3
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Dec 3 08:26:00 2013 +0900

    staging: remove DEFINE_PCI_DEVICE_TABLE macro
    
    Don't use DEFINE_PCI_DEVICE_TABLE macro, because this macro
    is not preferred.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index c5717d63e16a..6248284caaf5 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -55,7 +55,7 @@ static int apci1564_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &apci1564_driver, id->driver_data);
 }
 
-static DEFINE_PCI_DEVICE_TABLE(apci1564_pci_table) = {
+static const struct pci_device_id apci1564_pci_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_ADDIDATA, 0x1006) },
 	{ 0 }
 };

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 22bace62210c..c5717d63e16a 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -1,3 +1,4 @@
+#include <linux/module.h>
 #include <linux/pci.h>
 
 #include "../comedidev.h"

commit 53362177da474ead9b11a4cdbbfc1556067fa2a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 10 11:32:30 2013 -0700

    staging: comedi: addi_common: remove i_IorangeBase0 from boardinfo
    
    The i_IorangeBase0 boardinfo is not used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 8de7b4875b0d..22bace62210c 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -13,7 +13,6 @@
 static const struct addi_board apci1564_boardtypes[] = {
 	{
 		.pc_DriverName		= "apci1564",
-		.i_IorangeBase0		= 128,
 		.i_IorangeBase1		= APCI1564_ADDRESS_RANGE,
 		.i_PCIEeprom		= ADDIDATA_EEPROM,
 		.pc_EepromChip		= ADDIDATA_93C76,

commit b9beb6c7e76a2ab4153b4c6eb675fe3c481300cf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 10:26:44 2013 -0700

    staging: comedi: addi_common: remove 'i_VendorId' and 'i_Device Id'
    
    The vendor/device ids in the boardinfo are not longer needed. Remove
    them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 97e389f4e5c6..8de7b4875b0d 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -13,8 +13,6 @@
 static const struct addi_board apci1564_boardtypes[] = {
 	{
 		.pc_DriverName		= "apci1564",
-		.i_VendorId		= PCI_VENDOR_ID_ADDIDATA,
-		.i_DeviceId		= 0x1006,
 		.i_IorangeBase0		= 128,
 		.i_IorangeBase1		= APCI1564_ADDRESS_RANGE,
 		.i_PCIEeprom		= ADDIDATA_EEPROM,

commit 43ba213156dba3afb4c8367da16c3d90aa87d2f8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 10:24:21 2013 -0700

    staging: comedi: addi_apci_1564: set board_ptr before calling addi_auto_attach()
    
    This driver only supports a single PCI device. If we set the
    dev->board_ptr before calling addi_auto_attach() we remove
    the need for the common code to search for the boardinfo.
    
    Since the search is not done we can remove the unnecessary
    board information from the comedi_driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index b2b3bdbb9f30..97e389f4e5c6 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -36,14 +36,19 @@ static const struct addi_board apci1564_boardtypes[] = {
 	},
 };
 
+static int apci1564_auto_attach(struct comedi_device *dev,
+				unsigned long context)
+{
+	dev->board_ptr = &apci1564_boardtypes[0];
+
+	return addi_auto_attach(dev, context);
+}
+
 static struct comedi_driver apci1564_driver = {
 	.driver_name	= "addi_apci_1564",
 	.module		= THIS_MODULE,
-	.auto_attach	= addi_auto_attach,
+	.auto_attach	= apci1564_auto_attach,
 	.detach		= i_ADDI_Detach,
-	.num_names	= ARRAY_SIZE(apci1564_boardtypes),
-	.board_name	= &apci1564_boardtypes[0].pc_DriverName,
-	.offset		= sizeof(struct addi_board),
 };
 
 static int apci1564_pci_probe(struct pci_dev *dev,

commit b8f4ac237e382accd4b30c75043939f7ed9e79a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 09:53:41 2013 -0700

    staging: comedi: comedi_pci: change the comedi_pci_auto_config() 'context'
    
    The comedi_pci_auto_config() function is used to allow the PCI driver
    (*probe) function to automatically call the comedi driver (*auto_attach).
    This allows the comedi driver to be part of the PnP process when the
    PCI device is detected.
    
    Currently the comedi_pci_auto_config() always passes a 'context' of '0'
    to comedi_auto_config(). This makes the 'context' a bit useless.
    
    Modify comedi_pci_auto_config() to allow the comedi pci drivers to pass
    a 'context' from the PCI driver.
    
    Make all the comedi pci drivers pass the pci_device_id 'driver_data' as
    the 'context'. Since none of the comedi pci drivers currently set the
    'driver_data' the 'context' will still be '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index ddea64df9180..b2b3bdbb9f30 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -47,9 +47,9 @@ static struct comedi_driver apci1564_driver = {
 };
 
 static int apci1564_pci_probe(struct pci_dev *dev,
-					const struct pci_device_id *ent)
+			      const struct pci_device_id *id)
 {
-	return comedi_pci_auto_config(dev, &apci1564_driver);
+	return comedi_pci_auto_config(dev, &apci1564_driver, id->driver_data);
 }
 
 static DEFINE_PCI_DEVICE_TABLE(apci1564_pci_table) = {

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 3556c61551b9..ddea64df9180 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -1,3 +1,5 @@
+#include <linux/pci.h>
+
 #include "../comedidev.h"
 #include "comedi_fc.h"
 #include "amcc_s5933.h"

commit 9901a4d75d007686e8f6473189cafc4b216b7449
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Tue Jan 22 23:40:03 2013 +0100

    staging/comedi: Use comedi_pci_auto_unconfig directly for pci_driver.remove
    
    (Almost) all comedi pci drivers have some wrapper for their
    pci_driver.remove function which simply calls comedi_pci_auto_unconfig
    which has the same function prototype as the wrapper.
    
    -> we can remove these wrappers and call comedi_pci_auto_unconfig
    directly. This removes a lot some boilerplate code and saves some bytes.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 513e536f292f..3556c61551b9 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -50,11 +50,6 @@ static int apci1564_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &apci1564_driver);
 }
 
-static void apci1564_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
 static DEFINE_PCI_DEVICE_TABLE(apci1564_pci_table) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_ADDIDATA, 0x1006) },
 	{ 0 }
@@ -65,7 +60,7 @@ static struct pci_driver apci1564_pci_driver = {
 	.name		= "addi_apci_1564",
 	.id_table	= apci1564_pci_table,
 	.probe		= apci1564_pci_probe,
-	.remove		= apci1564_pci_remove,
+	.remove		= comedi_pci_auto_unconfig,
 };
 module_comedi_pci_driver(apci1564_driver, apci1564_pci_driver);
 

commit 53b800198592b0ff96577ecc5f116f7d902a4362
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:36 2012 -0500

    staging: comedi: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index d03579a1659e..513e536f292f 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -50,7 +50,7 @@ static int apci1564_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &apci1564_driver);
 }
 
-static void __devexit apci1564_pci_remove(struct pci_dev *dev)
+static void apci1564_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }

commit a690b7e535f2f97a3a05ee570715abeb60a8910f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:58 2012 -0500

    staging: comedi: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 1d51233ca78e..d03579a1659e 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -44,7 +44,7 @@ static struct comedi_driver apci1564_driver = {
 	.offset		= sizeof(struct addi_board),
 };
 
-static int __devinit apci1564_pci_probe(struct pci_dev *dev,
+static int apci1564_pci_probe(struct pci_dev *dev,
 					const struct pci_device_id *ent)
 {
 	return comedi_pci_auto_config(dev, &apci1564_driver);

commit a471eace7baa40cdf16d3f26b2f78ddce613ca8f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:37 2012 -0500

    staging: comedi: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 926fa088392f..1d51233ca78e 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -65,7 +65,7 @@ static struct pci_driver apci1564_pci_driver = {
 	.name		= "addi_apci_1564",
 	.id_table	= apci1564_pci_table,
 	.probe		= apci1564_pci_probe,
-	.remove		= __devexit_p(apci1564_pci_remove),
+	.remove		= apci1564_pci_remove,
 };
 module_comedi_pci_driver(apci1564_driver, apci1564_pci_driver);
 

commit 92cba8f3b42e1cb8211b64e91618102ecc8f0a6d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 6 11:16:42 2012 -0700

    staging: comedi: addi-data: use auto_attach instead of attach_pci
    
    Change the addi-data drivers that use the "common" code so they
    attach using the generic 'auto_attach' method instead the pci
    specific 'attach_pci' method. The 'attach_pci' is deprecated and
    is going to be removed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 2fd335b2aad5..926fa088392f 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -37,7 +37,7 @@ static const struct addi_board apci1564_boardtypes[] = {
 static struct comedi_driver apci1564_driver = {
 	.driver_name	= "addi_apci_1564",
 	.module		= THIS_MODULE,
-	.attach_pci	= addi_attach_pci,
+	.auto_attach	= addi_auto_attach,
 	.detach		= i_ADDI_Detach,
 	.num_names	= ARRAY_SIZE(apci1564_boardtypes),
 	.board_name	= &apci1564_boardtypes[0].pc_DriverName,

commit a4a257039fb580142a30872537a03f4d7d7627e3
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 6 10:11:02 2012 -0700

    staging: comedi: addi_apci_1564: fix digital output 'insn_bits' function
    
    This driver does not follow the comedi API. The digital output 'insn_bits'
    function is passed a mask value in data[0] indicating which output bits in
    data[1] are changing. The function is then supposed to update the outputs
    accordingly and then return the current state of the outputs in data[1].
    
    Currently this driver uses the 'insn_write' function to update either a
    single or all the output channels. And it uses the 'insn_bits' function
    to read either a single or all the output channel states.
    
    Fix the 'insn_bits' function so it works like the comedi core expects. The
    core can then use the function to emulate the 'insn_read' and 'insn_write'
    functions for individual channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 42aea51f4619..2fd335b2aad5 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -26,8 +26,7 @@ static const struct addi_board apci1564_boardtypes[] = {
 		.di_config		= i_APCI1564_ConfigDigitalInput,
 		.di_bits		= apci1564_di_insn_bits,
 		.do_config		= i_APCI1564_ConfigDigitalOutput,
-		.do_write		= i_APCI1564_WriteDigitalOutput,
-		.do_bits		= i_APCI1564_ReadDigitalOutput,
+		.do_bits		= apci1564_do_insn_bits,
 		.do_read		= i_APCI1564_ReadInterruptStatus,
 		.timer_config		= i_APCI1564_ConfigTimerCounterWatchdog,
 		.timer_write		= i_APCI1564_StartStopWriteTimerCounterWatchdog,

commit 6b5d432852d030320cdd41571ab37df0d6f6e823
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 6 10:09:37 2012 -0700

    staging: comedi: addi_apci_1564: fix digital input 'insn_bits' function
    
    This driver does not follow the comedi API. The digital input 'insn_bits'
    function is supposed to return the status of all the input channels in
    data[1]. Currently this function returns the status in data[0].
    
    Fix the function so it works like the comedi core expects. The core can
    then use the function to emulate the 'insn_read' function for individual
    channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 1dcaadade21c..42aea51f4619 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -24,8 +24,7 @@ static const struct addi_board apci1564_boardtypes[] = {
 		.interrupt		= v_APCI1564_Interrupt,
 		.reset			= i_APCI1564_Reset,
 		.di_config		= i_APCI1564_ConfigDigitalInput,
-		.di_read		= i_APCI1564_Read1DigitalInput,
-		.di_bits		= i_APCI1564_ReadMoreDigitalInput,
+		.di_bits		= apci1564_di_insn_bits,
 		.do_config		= i_APCI1564_ConfigDigitalOutput,
 		.do_write		= i_APCI1564_WriteDigitalOutput,
 		.do_bits		= i_APCI1564_ReadDigitalOutput,

commit bf36f012c7ddaff083bb0ef187feddf4d85507a0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Oct 31 16:58:40 2012 -0700

    staging: comedi: addi-data: remove addi_amcc_s5933.h
    
    Now that the PCI bus walking has been removed from the addi-data
    drivers, the only differenced between addi_amcc_s9533.h and the
    standard comedi amcc_s5933.h is the additional defines for the
    apci3120 "ADDON RELATED ADDITIONS". Move those defines to
    hwdrv_apci3120.c.
    
    Modify all the addi-data drivers to then include the standard
    comedi amcc_s5933.h header and delete the duplicate in addi-data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 10a7dbcbf995..1dcaadade21c 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -1,8 +1,8 @@
 #include "../comedidev.h"
 #include "comedi_fc.h"
+#include "amcc_s5933.h"
 
 #include "addi-data/addi_common.h"
-#include "addi-data/addi_amcc_s5933.h"
 
 #include "addi-data/addi_eeprom.c"
 #include "addi-data/hwdrv_apci1564.c"

commit 41be28db534330192bbbec9783e6d43d4432a7fb
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Oct 31 16:57:37 2012 -0700

    staging: comedi: addi-data: use attach_pci callback
    
    Use the comedi pci auto config mechanism to attach the addi-data
    drivers. This allows removing all the PCI bus walking code.
    
    Add a function, addi_find_boardinfo(), to find the driver specific
    boardinfo. Since this function is currently in the common code we
    have to use the pointer to the boardinfo that is stored in the
    comedi_driver pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index c44007b0c914..10a7dbcbf995 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -39,7 +39,7 @@ static const struct addi_board apci1564_boardtypes[] = {
 static struct comedi_driver apci1564_driver = {
 	.driver_name	= "addi_apci_1564",
 	.module		= THIS_MODULE,
-	.attach		= i_ADDI_Attach,
+	.attach_pci	= addi_attach_pci,
 	.detach		= i_ADDI_Detach,
 	.num_names	= ARRAY_SIZE(apci1564_boardtypes),
 	.board_name	= &apci1564_boardtypes[0].pc_DriverName,

commit 20a22b706b8ee37d1a2282f2c9bf7f2c73a5a7a5
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 30 18:06:33 2012 -0700

    staging: comedi: addi_apci_*: add module_comedi_pci_driver()
    
    Pull the module init code out of addi_common.c and add it to
    each addi-data driver. Rename the data and functions so they
    have namespace associated with the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 0a631e1fe786..c44007b0c914 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -4,12 +4,11 @@
 #include "addi-data/addi_common.h"
 #include "addi-data/addi_amcc_s5933.h"
 
-#define ADDIDATA_DRIVER_NAME	"addi_apci_1564"
-
 #include "addi-data/addi_eeprom.c"
 #include "addi-data/hwdrv_apci1564.c"
+#include "addi-data/addi_common.c"
 
-static const struct addi_board boardtypes[] = {
+static const struct addi_board apci1564_boardtypes[] = {
 	{
 		.pc_DriverName		= "apci1564",
 		.i_VendorId		= PCI_VENDOR_ID_ADDIDATA,
@@ -37,13 +36,40 @@ static const struct addi_board boardtypes[] = {
 	},
 };
 
-static DEFINE_PCI_DEVICE_TABLE(addi_apci_tbl) = {
+static struct comedi_driver apci1564_driver = {
+	.driver_name	= "addi_apci_1564",
+	.module		= THIS_MODULE,
+	.attach		= i_ADDI_Attach,
+	.detach		= i_ADDI_Detach,
+	.num_names	= ARRAY_SIZE(apci1564_boardtypes),
+	.board_name	= &apci1564_boardtypes[0].pc_DriverName,
+	.offset		= sizeof(struct addi_board),
+};
+
+static int __devinit apci1564_pci_probe(struct pci_dev *dev,
+					const struct pci_device_id *ent)
+{
+	return comedi_pci_auto_config(dev, &apci1564_driver);
+}
+
+static void __devexit apci1564_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static DEFINE_PCI_DEVICE_TABLE(apci1564_pci_table) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_ADDIDATA, 0x1006) },
 	{ 0 }
 };
-MODULE_DEVICE_TABLE(pci, addi_apci_tbl);
+MODULE_DEVICE_TABLE(pci, apci1564_pci_table);
 
-#include "addi-data/addi_common.c"
+static struct pci_driver apci1564_pci_driver = {
+	.name		= "addi_apci_1564",
+	.id_table	= apci1564_pci_table,
+	.probe		= apci1564_pci_probe,
+	.remove		= __devexit_p(apci1564_pci_remove),
+};
+module_comedi_pci_driver(apci1564_driver, apci1564_pci_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit c33ef61ff9f731efa4a630a9566a4cdf8945f4af
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 30 18:06:13 2012 -0700

    staging: comedi: addi_apci_*: remove unneeded CONFIG_APCI_* defines
    
    These defines were needed for the #ifdef'ery that used to exist
    in addi_common.c. Since that has been removed these are no longer
    used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 6bdbf205847d..0a631e1fe786 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -4,8 +4,6 @@
 #include "addi-data/addi_common.h"
 #include "addi-data/addi_amcc_s5933.h"
 
-#define CONFIG_APCI_1564 1
-
 #define ADDIDATA_DRIVER_NAME	"addi_apci_1564"
 
 #include "addi-data/addi_eeprom.c"

commit c0a053b8b24d72413a82a16a41f635e6040ccf34
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 29 16:52:36 2012 -0700

    staging: comedi: addi-data: remove the boardinfo #ifdef'ery
    
    Move the boardinfo for each addi-data driver from addi_common.c to
    the individual driver files. This removes the need #ifdef'ery.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 811647b0053e..6bdbf205847d 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -11,6 +11,34 @@
 #include "addi-data/addi_eeprom.c"
 #include "addi-data/hwdrv_apci1564.c"
 
+static const struct addi_board boardtypes[] = {
+	{
+		.pc_DriverName		= "apci1564",
+		.i_VendorId		= PCI_VENDOR_ID_ADDIDATA,
+		.i_DeviceId		= 0x1006,
+		.i_IorangeBase0		= 128,
+		.i_IorangeBase1		= APCI1564_ADDRESS_RANGE,
+		.i_PCIEeprom		= ADDIDATA_EEPROM,
+		.pc_EepromChip		= ADDIDATA_93C76,
+		.i_NbrDiChannel		= 32,
+		.i_NbrDoChannel		= 32,
+		.i_DoMaxdata		= 0xffffffff,
+		.i_Timer		= 1,
+		.interrupt		= v_APCI1564_Interrupt,
+		.reset			= i_APCI1564_Reset,
+		.di_config		= i_APCI1564_ConfigDigitalInput,
+		.di_read		= i_APCI1564_Read1DigitalInput,
+		.di_bits		= i_APCI1564_ReadMoreDigitalInput,
+		.do_config		= i_APCI1564_ConfigDigitalOutput,
+		.do_write		= i_APCI1564_WriteDigitalOutput,
+		.do_bits		= i_APCI1564_ReadDigitalOutput,
+		.do_read		= i_APCI1564_ReadInterruptStatus,
+		.timer_config		= i_APCI1564_ConfigTimerCounterWatchdog,
+		.timer_write		= i_APCI1564_StartStopWriteTimerCounterWatchdog,
+		.timer_read		= i_APCI1564_ReadTimerCounterWatchdog,
+	},
+};
+
 static DEFINE_PCI_DEVICE_TABLE(addi_apci_tbl) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_ADDIDATA, 0x1006) },
 	{ 0 }

commit 317285d71acccbda2fbab7e53d6b33c52a151a32
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 29 16:52:20 2012 -0700

    staging: comedi: addi-data: remove the MODULE_DEVICE_TABLE #ifdef'ery
    
    Move the MODULE_DEVICE_TABLE for each addi-data driver from addi_common.c
    to the individual driver files. This removes the need #ifdef'ery.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index a37b3c4a9351..811647b0053e 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -10,6 +10,13 @@
 
 #include "addi-data/addi_eeprom.c"
 #include "addi-data/hwdrv_apci1564.c"
+
+static DEFINE_PCI_DEVICE_TABLE(addi_apci_tbl) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_ADDIDATA, 0x1006) },
+	{ 0 }
+};
+MODULE_DEVICE_TABLE(pci, addi_apci_tbl);
+
 #include "addi-data/addi_common.c"
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");

commit bf6a1578c10a4f3ef94a3c744267f18f9c3642bd
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 29 16:52:03 2012 -0700

    staging: comedi: addi-data: remove the addi-data #include ifdef'ery
    
    Move the addi-data specific #include's from addi_common.h to the
    individual driver files.
    
    The apci-1710, apci-3200, and apci-3300 drivers still have floating
    point code in them and are currently disabled in the Kconfig and
    Makefile. For now, move the fpu_{begin,end} functions from addi_common.c
    to the main driver file so we can get rid of the #ifdef'ery.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 72c626352834..a37b3c4a9351 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -8,6 +8,8 @@
 
 #define ADDIDATA_DRIVER_NAME	"addi_apci_1564"
 
+#include "addi-data/addi_eeprom.c"
+#include "addi-data/hwdrv_apci1564.c"
 #include "addi-data/addi_common.c"
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");

commit 3d41c44370a9a1e78e53c9997289347ec97d46ee
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 29 16:51:33 2012 -0700

    staging: comedi: addi-data: move the main #include's to the drivers
    
    The addi-data drivers are all built by the main driver files including
    addi-data/addi_common.c. That file then includes other files depending
    on what driver is being compiled. This is makes the code quite messy
    and hard to follow.
    
    Start cleaning it up by removing the unneeded #include's in addi_common.c
    and moving the some of the comedi #include's into the individual driver
    files.
    
    This is the first step in getting rid of the #ifdef'ery in addi_common.c.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 1b9d598fb6ca..72c626352834 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -1,3 +1,9 @@
+#include "../comedidev.h"
+#include "comedi_fc.h"
+
+#include "addi-data/addi_common.h"
+#include "addi-data/addi_amcc_s5933.h"
+
 #define CONFIG_APCI_1564 1
 
 #define ADDIDATA_DRIVER_NAME	"addi_apci_1564"

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 6f5c923ac226..1b9d598fb6ca 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -3,3 +3,7 @@
 #define ADDIDATA_DRIVER_NAME	"addi_apci_1564"
 
 #include "addi-data/addi_common.c"
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 6d8b0f5be5108f6a3fc922ca4acfbf10e14d6cd0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed May 19 15:11:57 2010 +0100

    Staging: comedi: Give the addi_apci_* drivers different driver names
    
    It is not currently possible for more than one of the addi_apci_*
    drivers to register themselves with comedi at once because they all use
    the same comedi driver name "addi_common".  Give them different names.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
index 0351cdde1026..6f5c923ac226 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1564.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -1,3 +1,5 @@
 #define CONFIG_APCI_1564 1
 
+#define ADDIDATA_DRIVER_NAME	"addi_apci_1564"
+
 #include "addi-data/addi_common.c"

commit c995fe9475e062bab6f5a45ed28cd2d3d955ef43
Author: ADDI-DATA GmbH <info@addi-data.com>
Date:   Thu Feb 12 15:14:18 2009 -0800

    Staging: comedi: add addi-data drivers
    
    This adds the addi-data family of comedi drivers to the staging tree
    
    From: ADDI-DATA GmbH <info@addi-data.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/addi_apci_1564.c b/drivers/staging/comedi/drivers/addi_apci_1564.c
new file mode 100644
index 000000000000..0351cdde1026
--- /dev/null
+++ b/drivers/staging/comedi/drivers/addi_apci_1564.c
@@ -0,0 +1,3 @@
+#define CONFIG_APCI_1564 1
+
+#include "addi-data/addi_common.c"
