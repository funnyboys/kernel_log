commit b276527539188f1f61c082ebef27803db93e536d
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Mar 10 14:02:40 2020 +0100

    staging: most: move core files out of the staging area
    
    This patch moves the core module to the /drivers/most directory
    and makes all necessary changes in order to not break the build.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Link: https://lore.kernel.org/r/1583845362-26707-2-git-send-email-christian.gromm@microchip.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index 2980f7065846..893a8babdb2f 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -13,8 +13,7 @@
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
 #include <linux/err.h>
-
-#include "../most.h"
+#include <linux/most.h>
 
 enum { CH_RX, CH_TX, NUM_CHANNELS };
 

commit 532c29190795178bb02d2671b5e8a288c16a4649
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Thu Jan 16 01:44:51 2020 +0900

    staging: most: remove header include path to drivers/staging
    
    There is no need to add "ccflags-y += -I $(srctree)/drivers/staging"
    just for including <most/most.h>.
    
    Use the #include "..." directive with the correct relative path.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Link: https://lore.kernel.org/r/20200115164451.13203-1-masahiroy@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index d07719c38fc9..2980f7065846 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -14,7 +14,7 @@
 #include <linux/interrupt.h>
 #include <linux/err.h>
 
-#include <most/most.h>
+#include "../most.h"
 
 enum { CH_RX, CH_TX, NUM_CHANNELS };
 

commit 6f4d22d76baa73c5bc99d669d68c862b60a04a3d
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Fri Dec 13 13:04:19 2019 +0100

    staging: most: use angle brackets in include path
    
    This patch replaces the double quotes in all include paths
    with angle brackets.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Link: https://lore.kernel.org/r/1576238662-16512-7-git-send-email-christian.gromm@microchip.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index d4606acba942..d07719c38fc9 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -14,7 +14,7 @@
 #include <linux/interrupt.h>
 #include <linux/err.h>
 
-#include "most/most.h"
+#include <most/most.h>
 
 enum { CH_RX, CH_TX, NUM_CHANNELS };
 

commit c1d3fb8abe667cd9aa59f3a176ca4d0636d9b44b
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Fri Dec 13 13:04:14 2019 +0100

    staging: most: rename core.h to most.h
    
    This patch renames the core header file core.h to most.h. The intention
    behind this is to have a meaningful name once this file is moved to the
    /include/linux directory.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Link: https://lore.kernel.org/r/1576238662-16512-2-git-send-email-christian.gromm@microchip.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index 4a4fc1005932..d4606acba942 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -14,7 +14,7 @@
 #include <linux/interrupt.h>
 #include <linux/err.h>
 
-#include "most/core.h"
+#include "most/most.h"
 
 enum { CH_RX, CH_TX, NUM_CHANNELS };
 

commit 7e6e228873945ccb46895f1f5e29187814ea1d8d
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:45:02 2018 +0200

    staging: most: i2c: reduce parameters inconsistency
    
    Currently, there are two module parameters for the i2c driver:
      - polling_req: boolean irq/polling mode;
      - scan_rate: polling rate, that is used in the case where the polling
        mode is active
    
    This model is misconfiguration-prone.  For example, it is possible to
    select polling mode with the zero polling rate or configure non-zero
    polling rate in a combination with the IRQ mode.
    
    This patch replaces the 'polling_req' and 'scan_rate' by the
    'polling_rate', where the value zero means the interrupt driven mode and
    other values are used as the polling rate in the polling mode.
    
    Signed-off-by: Andrey Shvetsov <andrey.shvetsov@k2l.de>
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index f0d5b222f40a..4a4fc1005932 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -28,18 +28,11 @@ enum { CH_RX, CH_TX, NUM_CHANNELS };
 #define list_first_mbo(ptr) \
 	list_first_entry(ptr, struct mbo, list)
 
-/* IRQ / Polling option */
-static bool polling_req;
-module_param(polling_req, bool, 0444);
-MODULE_PARM_DESC(polling_req, "Request Polling. Default = 0 (use irq)");
-
-/* Polling Rate */
-static int scan_rate = 100;
-module_param(scan_rate, int, 0644);
-MODULE_PARM_DESC(scan_rate, "Polling rate in times/sec. Default = 100");
+static unsigned int polling_rate;
+module_param(polling_rate, uint, 0644);
+MODULE_PARM_DESC(polling_rate, "Polling rate [Hz]. Default = 0 (use IRQ)");
 
 struct hdm_i2c {
-	bool polling_mode;
 	struct most_interface most_iface;
 	struct most_channel_capability capabilities[NUM_CHANNELS];
 	struct i2c_client *client;
@@ -89,8 +82,7 @@ static int configure_channel(struct most_interface *most_iface,
 	}
 
 	if (channel_config->direction == MOST_CH_RX) {
-		dev->polling_mode = polling_req;
-		if (!dev->polling_mode) {
+		if (!polling_rate) {
 			if (dev->client->irq <= 0) {
 				pr_err("bad irq: %d\n", dev->client->irq);
 				return -ENOENT;
@@ -103,8 +95,8 @@ static int configure_channel(struct most_interface *most_iface,
 				       dev->client->irq, ret);
 				return ret;
 			}
-		} else if (scan_rate) {
-			delay = msecs_to_jiffies(MSEC_PER_SEC / scan_rate);
+		} else {
+			delay = msecs_to_jiffies(MSEC_PER_SEC / polling_rate);
 			dev->rx.delay = delay ? delay : 1;
 			pr = MSEC_PER_SEC / jiffies_to_msecs(dev->rx.delay);
 			pr_info("polling rate is %u Hz\n", pr);
@@ -135,13 +127,13 @@ static int enqueue(struct most_interface *most_iface,
 
 	if (ch_idx == CH_RX) {
 		/* RX */
-		if (!dev->polling_mode)
+		if (!polling_rate)
 			disable_irq(dev->client->irq);
 		cancel_delayed_work_sync(&dev->rx.dwork);
 		list_add_tail(&mbo->list, &dev->rx.list);
-		if (dev->rx.int_disabled || dev->polling_mode)
+		if (dev->rx.int_disabled || polling_rate)
 			pending_rx_work(&dev->rx.dwork.work);
-		if (!dev->polling_mode)
+		if (!polling_rate)
 			enable_irq(dev->client->irq);
 	} else {
 		/* TX */
@@ -179,7 +171,7 @@ static int poison_channel(struct most_interface *most_iface,
 	BUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);
 
 	if (ch_idx == CH_RX) {
-		if (!dev->polling_mode)
+		if (!polling_rate)
 			free_irq(dev->client->irq, dev);
 		cancel_delayed_work_sync(&dev->rx.dwork);
 
@@ -247,9 +239,8 @@ static void pending_rx_work(struct work_struct *work)
 
 	do_rx_work(dev);
 
-	if (dev->polling_mode) {
-		if (scan_rate)
-			schedule_delayed_work(&dev->rx.dwork, dev->rx.delay);
+	if (polling_rate) {
+		schedule_delayed_work(&dev->rx.dwork, dev->rx.delay);
 	} else {
 		dev->rx.int_disabled = false;
 		enable_irq(dev->client->irq);

commit eb50842c5f5cf880bef97816cf5732de47a591bb
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:45:01 2018 +0200

    staging: most: i2c: remove redundant list_mutex
    
    The elements of the dev->rx.list are consumed in the pending_rx_work and
    populated in the function enqueue() that cancels the pending_rx_work.
    
    The function enqueue() and poison_channel() do not race anyway.
    
    Signed-off-by: Andrey Shvetsov <andrey.shvetsov@k2l.de>
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index 8edced998f5a..f0d5b222f40a 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -46,7 +46,6 @@ struct hdm_i2c {
 	struct rx {
 		struct delayed_work dwork;
 		struct list_head list;
-		struct mutex list_mutex;
 		bool int_disabled;
 		unsigned int delay;
 	} rx;
@@ -139,9 +138,7 @@ static int enqueue(struct most_interface *most_iface,
 		if (!dev->polling_mode)
 			disable_irq(dev->client->irq);
 		cancel_delayed_work_sync(&dev->rx.dwork);
-		mutex_lock(&dev->rx.list_mutex);
 		list_add_tail(&mbo->list, &dev->rx.list);
-		mutex_unlock(&dev->rx.list_mutex);
 		if (dev->rx.int_disabled || dev->polling_mode)
 			pending_rx_work(&dev->rx.dwork.work);
 		if (!dev->polling_mode)
@@ -186,19 +183,14 @@ static int poison_channel(struct most_interface *most_iface,
 			free_irq(dev->client->irq, dev);
 		cancel_delayed_work_sync(&dev->rx.dwork);
 
-		mutex_lock(&dev->rx.list_mutex);
 		while (!list_empty(&dev->rx.list)) {
 			mbo = list_first_mbo(&dev->rx.list);
 			list_del(&mbo->list);
-			mutex_unlock(&dev->rx.list_mutex);
 
 			mbo->processed_length = 0;
 			mbo->status = MBO_E_CLOSE;
 			mbo->complete(mbo);
-
-			mutex_lock(&dev->rx.list_mutex);
 		}
-		mutex_unlock(&dev->rx.list_mutex);
 	}
 
 	return 0;
@@ -231,10 +223,8 @@ static void do_rx_work(struct hdm_i2c *dev)
 		return;
 	}
 
-	mutex_lock(&dev->rx.list_mutex);
 	mbo = list_first_mbo(&dev->rx.list);
 	list_del(&mbo->list);
-	mutex_unlock(&dev->rx.list_mutex);
 
 	mbo->processed_length = min(data_size, mbo->buffer_length);
 	memcpy(mbo->virt_address, msg, mbo->processed_length);
@@ -251,12 +241,8 @@ static void do_rx_work(struct hdm_i2c *dev)
 static void pending_rx_work(struct work_struct *work)
 {
 	struct hdm_i2c *dev = container_of(work, struct hdm_i2c, rx.dwork.work);
-	bool empty;
 
-	mutex_lock(&dev->rx.list_mutex);
-	empty = list_empty(&dev->rx.list);
-	mutex_unlock(&dev->rx.list_mutex);
-	if (empty)
+	if (list_empty(&dev->rx.list))
 		return;
 
 	do_rx_work(dev);
@@ -340,7 +326,6 @@ static int i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	dev->most_iface.poison_channel = poison_channel;
 
 	INIT_LIST_HEAD(&dev->rx.list);
-	mutex_init(&dev->rx.list_mutex);
 
 	INIT_DELAYED_WORK(&dev->rx.dwork, pending_rx_work);
 

commit 6471c2693f4e28004cee5ad96cad3bf975f7bfd6
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:45:00 2018 +0200

    staging: most: i2c: remove redundant is_open
    
    The variable is_open is checked only in the work function
    pending_rx_work() that is only active between the calls
    configure_channel() and poison_channel().
    
    Signed-off-by: Andrey Shvetsov <andrey.shvetsov@k2l.de>
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index 39b15908b476..8edced998f5a 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -39,7 +39,6 @@ module_param(scan_rate, int, 0644);
 MODULE_PARM_DESC(scan_rate, "Polling rate in times/sec. Default = 100");
 
 struct hdm_i2c {
-	bool is_open[NUM_CHANNELS];
 	bool polling_mode;
 	struct most_interface most_iface;
 	struct most_channel_capability capabilities[NUM_CHANNELS];
@@ -79,7 +78,6 @@ static int configure_channel(struct most_interface *most_iface,
 	unsigned int delay, pr;
 
 	BUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);
-	BUG_ON(dev->is_open[ch_idx]);
 
 	if (channel_config->data_type != MOST_CH_CONTROL) {
 		pr_err("bad data type for channel %d\n", ch_idx);
@@ -113,7 +111,6 @@ static int configure_channel(struct most_interface *most_iface,
 			pr_info("polling rate is %u Hz\n", pr);
 		}
 	}
-	dev->is_open[ch_idx] = true;
 
 	return 0;
 }
@@ -136,7 +133,6 @@ static int enqueue(struct most_interface *most_iface,
 	int ret;
 
 	BUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);
-	BUG_ON(!dev->is_open[ch_idx]);
 
 	if (ch_idx == CH_RX) {
 		/* RX */
@@ -184,9 +180,6 @@ static int poison_channel(struct most_interface *most_iface,
 	struct mbo *mbo;
 
 	BUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);
-	BUG_ON(!dev->is_open[ch_idx]);
-
-	dev->is_open[ch_idx] = false;
 
 	if (ch_idx == CH_RX) {
 		if (!dev->polling_mode)
@@ -269,7 +262,7 @@ static void pending_rx_work(struct work_struct *work)
 	do_rx_work(dev);
 
 	if (dev->polling_mode) {
-		if (dev->is_open[CH_RX] && scan_rate)
+		if (scan_rate)
 			schedule_delayed_work(&dev->rx.dwork, dev->rx.delay);
 	} else {
 		dev->rx.int_disabled = false;
@@ -329,7 +322,6 @@ static int i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		 client->adapter->nr, client->addr);
 
 	for (i = 0; i < NUM_CHANNELS; i++) {
-		dev->is_open[i] = false;
 		dev->capabilities[i].data_type = MOST_CH_CONTROL;
 		dev->capabilities[i].num_buffers_packet = MAX_BUFFERS_CONTROL;
 		dev->capabilities[i].buffer_size_packet = MAX_BUF_SIZE_CONTROL;

commit 0003718c92a3d05a8ae100aecffb1e18b3dd9850
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:44:59 2018 +0200

    staging: most: i2c: trace real polling rate
    
    The real polling rate depends on the CONFIG_HZ and may differ from the
    required polling rate.
    
    Signed-off-by: Andrey Shvetsov <andrey.shvetsov@k2l.de>
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index 30d18cc5f072..39b15908b476 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -76,7 +76,7 @@ static int configure_channel(struct most_interface *most_iface,
 {
 	int ret;
 	struct hdm_i2c *dev = to_hdm(most_iface);
-	unsigned int delay;
+	unsigned int delay, pr;
 
 	BUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);
 	BUG_ON(dev->is_open[ch_idx]);
@@ -109,7 +109,8 @@ static int configure_channel(struct most_interface *most_iface,
 		} else if (scan_rate) {
 			delay = msecs_to_jiffies(MSEC_PER_SEC / scan_rate);
 			dev->rx.delay = delay ? delay : 1;
-			pr_info("polling rate is %d Hz\n", scan_rate);
+			pr = MSEC_PER_SEC / jiffies_to_msecs(dev->rx.delay);
+			pr_info("polling rate is %u Hz\n", pr);
 		}
 	}
 	dev->is_open[ch_idx] = true;

commit ea8bcd5282d9dc683d7a544c42bcc057c168d315
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:44:58 2018 +0200

    staging: most: i2c: prevent zero delay polling
    
    This patch avoids that a configured scan_rate of more than MSEC_PER_SEC
    might result in a polling delay of zero.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index e03cb6c65c88..30d18cc5f072 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -49,6 +49,7 @@ struct hdm_i2c {
 		struct list_head list;
 		struct mutex list_mutex;
 		bool int_disabled;
+		unsigned int delay;
 	} rx;
 	char name[64];
 };
@@ -75,6 +76,7 @@ static int configure_channel(struct most_interface *most_iface,
 {
 	int ret;
 	struct hdm_i2c *dev = to_hdm(most_iface);
+	unsigned int delay;
 
 	BUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);
 	BUG_ON(dev->is_open[ch_idx]);
@@ -105,6 +107,8 @@ static int configure_channel(struct most_interface *most_iface,
 				return ret;
 			}
 		} else if (scan_rate) {
+			delay = msecs_to_jiffies(MSEC_PER_SEC / scan_rate);
+			dev->rx.delay = delay ? delay : 1;
 			pr_info("polling rate is %d Hz\n", scan_rate);
 		}
 	}
@@ -265,9 +269,7 @@ static void pending_rx_work(struct work_struct *work)
 
 	if (dev->polling_mode) {
 		if (dev->is_open[CH_RX] && scan_rate)
-			schedule_delayed_work(&dev->rx.dwork,
-					      msecs_to_jiffies(MSEC_PER_SEC
-							       / scan_rate));
+			schedule_delayed_work(&dev->rx.dwork, dev->rx.delay);
 	} else {
 		dev->rx.int_disabled = false;
 		enable_irq(dev->client->irq);

commit cd2e7148e77d45cad32b8cb18bc55bfa66491181
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:44:57 2018 +0200

    staging: most: i2c: avoid polling in case of misconfig
    
    This patch prevents the driver from falling back to polling mode
    in case of IRQ misconfiguration.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index a993e8e7c740..e03cb6c65c88 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -90,22 +90,24 @@ static int configure_channel(struct most_interface *most_iface,
 	}
 
 	if (channel_config->direction == MOST_CH_RX) {
-		dev->polling_mode = polling_req || dev->client->irq <= 0;
+		dev->polling_mode = polling_req;
 		if (!dev->polling_mode) {
-			pr_info("Requesting IRQ: %d\n", dev->client->irq);
+			if (dev->client->irq <= 0) {
+				pr_err("bad irq: %d\n", dev->client->irq);
+				return -ENOENT;
+			}
 			dev->rx.int_disabled = false;
 			ret = request_irq(dev->client->irq, most_irq_handler, 0,
 					  dev->client->name, dev);
 			if (ret) {
-				pr_info("IRQ request failed: %d, falling back to polling\n",
-					ret);
-				dev->polling_mode = true;
+				pr_err("request_irq(%d) failed: %d\n",
+				       dev->client->irq, ret);
+				return ret;
 			}
+		} else if (scan_rate) {
+			pr_info("polling rate is %d Hz\n", scan_rate);
 		}
 	}
-	if ((channel_config->direction == MOST_CH_RX) && (dev->polling_mode)) {
-		pr_info("Using polling at rate: %d times/sec\n", scan_rate);
-	}
 	dev->is_open[ch_idx] = true;
 
 	return 0;

commit 795ce21892585ed113fd63a6e06a4fea3ccdaf7b
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:44:56 2018 +0200

    staging: most: i2c: do not wait in work function
    
    This patch removes the function wait_event_interruptible from the
    work function to avoid waiting.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index b382f094a901..a993e8e7c740 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -11,7 +11,6 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
-#include <linux/sched.h>
 #include <linux/interrupt.h>
 #include <linux/err.h>
 
@@ -47,9 +46,9 @@ struct hdm_i2c {
 	struct i2c_client *client;
 	struct rx {
 		struct delayed_work dwork;
-		wait_queue_head_t waitq;
 		struct list_head list;
 		struct mutex list_mutex;
+		bool int_disabled;
 	} rx;
 	char name[64];
 };
@@ -57,6 +56,7 @@ struct hdm_i2c {
 #define to_hdm(iface) container_of(iface, struct hdm_i2c, most_iface)
 
 static irqreturn_t most_irq_handler(int, void *);
+static void pending_rx_work(struct work_struct *);
 
 /**
  * configure_channel - called from MOST core to configure a channel
@@ -93,6 +93,7 @@ static int configure_channel(struct most_interface *most_iface,
 		dev->polling_mode = polling_req || dev->client->irq <= 0;
 		if (!dev->polling_mode) {
 			pr_info("Requesting IRQ: %d\n", dev->client->irq);
+			dev->rx.int_disabled = false;
 			ret = request_irq(dev->client->irq, most_irq_handler, 0,
 					  dev->client->name, dev);
 			if (ret) {
@@ -104,8 +105,6 @@ static int configure_channel(struct most_interface *most_iface,
 	}
 	if ((channel_config->direction == MOST_CH_RX) && (dev->polling_mode)) {
 		pr_info("Using polling at rate: %d times/sec\n", scan_rate);
-		schedule_delayed_work(&dev->rx.dwork,
-				      msecs_to_jiffies(MSEC_PER_SEC / 4));
 	}
 	dev->is_open[ch_idx] = true;
 
@@ -134,10 +133,16 @@ static int enqueue(struct most_interface *most_iface,
 
 	if (ch_idx == CH_RX) {
 		/* RX */
+		if (!dev->polling_mode)
+			disable_irq(dev->client->irq);
+		cancel_delayed_work_sync(&dev->rx.dwork);
 		mutex_lock(&dev->rx.list_mutex);
 		list_add_tail(&mbo->list, &dev->rx.list);
 		mutex_unlock(&dev->rx.list_mutex);
-		wake_up_interruptible(&dev->rx.waitq);
+		if (dev->rx.int_disabled || dev->polling_mode)
+			pending_rx_work(&dev->rx.dwork.work);
+		if (!dev->polling_mode)
+			enable_irq(dev->client->irq);
 	} else {
 		/* TX */
 		ret = i2c_master_send(dev->client, mbo->virt_address,
@@ -194,7 +199,6 @@ static int poison_channel(struct most_interface *most_iface,
 			mutex_lock(&dev->rx.list_mutex);
 		}
 		mutex_unlock(&dev->rx.list_mutex);
-		wake_up_interruptible(&dev->rx.waitq);
 	}
 
 	return 0;
@@ -204,7 +208,7 @@ static void do_rx_work(struct hdm_i2c *dev)
 {
 	struct mbo *mbo;
 	unsigned char msg[MAX_BUF_SIZE_CONTROL];
-	int ret, ch_idx = CH_RX;
+	int ret;
 	u16 pml, data_size;
 
 	/* Read PML (2 bytes) */
@@ -227,29 +231,7 @@ static void do_rx_work(struct hdm_i2c *dev)
 		return;
 	}
 
-	for (;;) {
-		/* Conditions to wait for: poisoned channel or free buffer
-		 * available for reading
-		 */
-		if (wait_event_interruptible(dev->rx.waitq,
-					     !dev->is_open[ch_idx] ||
-					     !list_empty(&dev->rx.list))) {
-			pr_err("wait_event_interruptible() failed\n");
-			return;
-		}
-
-		if (!dev->is_open[ch_idx])
-			return;
-
-		mutex_lock(&dev->rx.list_mutex);
-
-		/* list may be empty if poison or remove is called */
-		if (!list_empty(&dev->rx.list))
-			break;
-
-		mutex_unlock(&dev->rx.list_mutex);
-	}
-
+	mutex_lock(&dev->rx.list_mutex);
 	mbo = list_first_mbo(&dev->rx.list);
 	list_del(&mbo->list);
 	mutex_unlock(&dev->rx.list_mutex);
@@ -269,6 +251,13 @@ static void do_rx_work(struct hdm_i2c *dev)
 static void pending_rx_work(struct work_struct *work)
 {
 	struct hdm_i2c *dev = container_of(work, struct hdm_i2c, rx.dwork.work);
+	bool empty;
+
+	mutex_lock(&dev->rx.list_mutex);
+	empty = list_empty(&dev->rx.list);
+	mutex_unlock(&dev->rx.list_mutex);
+	if (empty)
+		return;
 
 	do_rx_work(dev);
 
@@ -278,6 +267,7 @@ static void pending_rx_work(struct work_struct *work)
 					      msecs_to_jiffies(MSEC_PER_SEC
 							       / scan_rate));
 	} else {
+		dev->rx.int_disabled = false;
 		enable_irq(dev->client->irq);
 	}
 }
@@ -305,7 +295,7 @@ static irqreturn_t most_irq_handler(int irq, void *_dev)
 	struct hdm_i2c *dev = _dev;
 
 	disable_irq_nosync(irq);
-
+	dev->rx.int_disabled = true;
 	schedule_delayed_work(&dev->rx.dwork, 0);
 
 	return IRQ_HANDLED;
@@ -354,7 +344,6 @@ static int i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
 
 	INIT_LIST_HEAD(&dev->rx.list);
 	mutex_init(&dev->rx.list_mutex);
-	init_waitqueue_head(&dev->rx.waitq);
 
 	INIT_DELAYED_WORK(&dev->rx.dwork, pending_rx_work);
 
@@ -407,7 +396,6 @@ static struct i2c_driver i2c_driver = {
 
 module_i2c_driver(i2c_driver);
 
-MODULE_AUTHOR("Jain Roy Ambi <JainRoy.Ambi@microchip.com>");
 MODULE_AUTHOR("Andrey Shvetsov <andrey.shvetsov@k2l.de>");
 MODULE_DESCRIPTION("I2C Hardware Dependent Module");
 MODULE_LICENSE("GPL");

commit 0ecbf7fc366a5c4e6cfef49572739f1e2544faf5
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:44:55 2018 +0200

    staging: most: i2c: shorten lifetime of IRQ handler
    
    Currently the IRQ handler used for the rx channel lives between the
    functions i2c_probe and i2c_remove. This patch shortens the lifetime
    and keeps the handler alive only between the functions configure_channel
    and poison_channel.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index 8ec660bd2990..b382f094a901 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -56,6 +56,8 @@ struct hdm_i2c {
 
 #define to_hdm(iface) container_of(iface, struct hdm_i2c, most_iface)
 
+static irqreturn_t most_irq_handler(int, void *);
+
 /**
  * configure_channel - called from MOST core to configure a channel
  * @iface: interface the channel belongs to
@@ -71,6 +73,7 @@ static int configure_channel(struct most_interface *most_iface,
 			     int ch_idx,
 			     struct most_channel_config *channel_config)
 {
+	int ret;
 	struct hdm_i2c *dev = to_hdm(most_iface);
 
 	BUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);
@@ -86,7 +89,21 @@ static int configure_channel(struct most_interface *most_iface,
 		return -EPERM;
 	}
 
+	if (channel_config->direction == MOST_CH_RX) {
+		dev->polling_mode = polling_req || dev->client->irq <= 0;
+		if (!dev->polling_mode) {
+			pr_info("Requesting IRQ: %d\n", dev->client->irq);
+			ret = request_irq(dev->client->irq, most_irq_handler, 0,
+					  dev->client->name, dev);
+			if (ret) {
+				pr_info("IRQ request failed: %d, falling back to polling\n",
+					ret);
+				dev->polling_mode = true;
+			}
+		}
+	}
 	if ((channel_config->direction == MOST_CH_RX) && (dev->polling_mode)) {
+		pr_info("Using polling at rate: %d times/sec\n", scan_rate);
 		schedule_delayed_work(&dev->rx.dwork,
 				      msecs_to_jiffies(MSEC_PER_SEC / 4));
 	}
@@ -160,6 +177,10 @@ static int poison_channel(struct most_interface *most_iface,
 	dev->is_open[ch_idx] = false;
 
 	if (ch_idx == CH_RX) {
+		if (!dev->polling_mode)
+			free_irq(dev->client->irq, dev);
+		cancel_delayed_work_sync(&dev->rx.dwork);
+
 		mutex_lock(&dev->rx.list_mutex);
 		while (!list_empty(&dev->rx.list)) {
 			mbo = list_first_mbo(&dev->rx.list);
@@ -347,21 +368,6 @@ static int i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		return ret;
 	}
 
-	dev->polling_mode = polling_req || client->irq <= 0;
-	if (!dev->polling_mode) {
-		pr_info("Requesting IRQ: %d\n", client->irq);
-		ret = request_irq(client->irq, most_irq_handler, 0,
-				  client->name, dev);
-		if (ret) {
-			pr_info("IRQ request failed: %d, falling back to polling\n",
-				ret);
-			dev->polling_mode = true;
-		}
-	}
-
-	if (dev->polling_mode)
-		pr_info("Using polling at rate: %d times/sec\n", scan_rate);
-
 	return 0;
 }
 
@@ -377,11 +383,7 @@ static int i2c_remove(struct i2c_client *client)
 {
 	struct hdm_i2c *dev = i2c_get_clientdata(client);
 
-	if (!dev->polling_mode)
-		free_irq(client->irq, dev);
-
 	most_deregister_interface(&dev->most_iface);
-	cancel_delayed_work_sync(&dev->rx.dwork);
 	kfree(dev);
 
 	return 0;

commit 95b2f82d63f6d0888db188dddf76433dce32affe
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:44:52 2018 +0200

    staging: most: i2c: remove unnecessary poison_channel call
    
    This removes call of the poison_channel that is:
      - not allowed after most_deregister_interface;
      - is made during the most_deregister_interface call.
    
    Signed-off-by: Andrey Shvetsov <andrey.shvetsov@k2l.de>
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index 501eec0783a1..8ec660bd2990 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -376,16 +376,11 @@ static int i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
 static int i2c_remove(struct i2c_client *client)
 {
 	struct hdm_i2c *dev = i2c_get_clientdata(client);
-	int i;
 
 	if (!dev->polling_mode)
 		free_irq(client->irq, dev);
 
 	most_deregister_interface(&dev->most_iface);
-
-	for (i = 0 ; i < NUM_CHANNELS; i++)
-		if (dev->is_open[i])
-			poison_channel(&dev->most_iface, i);
 	cancel_delayed_work_sync(&dev->rx.dwork);
 	kfree(dev);
 

commit ceb1edc2a0a52b6f4285fbfc8f29a42b6109e52d
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:44:51 2018 +0200

    staging: most: i2c: prevent division by zero
    
    This prevents division by zero scan_rate.
    
    The zero scan_rate does not need any special action as it actually means
    "never poll again".
    
    Signed-off-by: Andrey Shvetsov <andrey.shvetsov@k2l.de>
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index 141239fc9f51..501eec0783a1 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -252,7 +252,7 @@ static void pending_rx_work(struct work_struct *work)
 	do_rx_work(dev);
 
 	if (dev->polling_mode) {
-		if (dev->is_open[CH_RX])
+		if (dev->is_open[CH_RX] && scan_rate)
 			schedule_delayed_work(&dev->rx.dwork,
 					      msecs_to_jiffies(MSEC_PER_SEC
 							       / scan_rate));

commit 4d5f022f3a664ee5987118b754058ff31df03835
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Nov 21 15:04:43 2017 +0100

    staging: most: remove proprietary kobjects
    
    This patch removes the proprietary kobjects used by the driver modules and
    replaces them with device structs. The patch is needed to have the driver
    being integrated into the kernel's device model.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index 156b2b1bdba9..141239fc9f51 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -303,7 +303,6 @@ static int i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
 	struct hdm_i2c *dev;
 	int ret, i;
-	struct kobject *kobj;
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev)
@@ -341,11 +340,11 @@ static int i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	dev->client = client;
 	i2c_set_clientdata(client, dev);
 
-	kobj = most_register_interface(&dev->most_iface);
-	if (IS_ERR(kobj)) {
+	ret = most_register_interface(&dev->most_iface);
+	if (ret) {
 		pr_err("Failed to register i2c as a MOST interface\n");
 		kfree(dev);
-		return PTR_ERR(kobj);
+		return ret;
 	}
 
 	dev->polling_mode = polling_req || client->irq <= 0;

commit 77550c20121f07b0f2389c39e076e034660724e0
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Nov 21 15:04:37 2017 +0100

    staging: most: i2c: rename module
    
    This patch renames the folder of the i2c module. It is needed
    to clear the directory layout.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
new file mode 100644
index 000000000000..156b2b1bdba9
--- /dev/null
+++ b/drivers/staging/most/i2c/i2c.c
@@ -0,0 +1,417 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * i2c.c - Hardware Dependent Module for I2C Interface
+ *
+ * Copyright (C) 2013-2015, Microchip Technology Germany II GmbH & Co. KG
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+
+#include "most/core.h"
+
+enum { CH_RX, CH_TX, NUM_CHANNELS };
+
+#define MAX_BUFFERS_CONTROL 32
+#define MAX_BUF_SIZE_CONTROL 256
+
+/**
+ * list_first_mbo - get the first mbo from a list
+ * @ptr:	the list head to take the mbo from.
+ */
+#define list_first_mbo(ptr) \
+	list_first_entry(ptr, struct mbo, list)
+
+/* IRQ / Polling option */
+static bool polling_req;
+module_param(polling_req, bool, 0444);
+MODULE_PARM_DESC(polling_req, "Request Polling. Default = 0 (use irq)");
+
+/* Polling Rate */
+static int scan_rate = 100;
+module_param(scan_rate, int, 0644);
+MODULE_PARM_DESC(scan_rate, "Polling rate in times/sec. Default = 100");
+
+struct hdm_i2c {
+	bool is_open[NUM_CHANNELS];
+	bool polling_mode;
+	struct most_interface most_iface;
+	struct most_channel_capability capabilities[NUM_CHANNELS];
+	struct i2c_client *client;
+	struct rx {
+		struct delayed_work dwork;
+		wait_queue_head_t waitq;
+		struct list_head list;
+		struct mutex list_mutex;
+	} rx;
+	char name[64];
+};
+
+#define to_hdm(iface) container_of(iface, struct hdm_i2c, most_iface)
+
+/**
+ * configure_channel - called from MOST core to configure a channel
+ * @iface: interface the channel belongs to
+ * @channel: channel to be configured
+ * @channel_config: structure that holds the configuration information
+ *
+ * Return 0 on success, negative on failure.
+ *
+ * Receives configuration information from MOST core and initialize the
+ * corresponding channel.
+ */
+static int configure_channel(struct most_interface *most_iface,
+			     int ch_idx,
+			     struct most_channel_config *channel_config)
+{
+	struct hdm_i2c *dev = to_hdm(most_iface);
+
+	BUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);
+	BUG_ON(dev->is_open[ch_idx]);
+
+	if (channel_config->data_type != MOST_CH_CONTROL) {
+		pr_err("bad data type for channel %d\n", ch_idx);
+		return -EPERM;
+	}
+
+	if (channel_config->direction != dev->capabilities[ch_idx].direction) {
+		pr_err("bad direction for channel %d\n", ch_idx);
+		return -EPERM;
+	}
+
+	if ((channel_config->direction == MOST_CH_RX) && (dev->polling_mode)) {
+		schedule_delayed_work(&dev->rx.dwork,
+				      msecs_to_jiffies(MSEC_PER_SEC / 4));
+	}
+	dev->is_open[ch_idx] = true;
+
+	return 0;
+}
+
+/**
+ * enqueue - called from MOST core to enqueue a buffer for data transfer
+ * @iface: intended interface
+ * @channel: ID of the channel the buffer is intended for
+ * @mbo: pointer to the buffer object
+ *
+ * Return 0 on success, negative on failure.
+ *
+ * Transmit the data over I2C if it is a "write" request or push the buffer into
+ * list if it is an "read" request
+ */
+static int enqueue(struct most_interface *most_iface,
+		   int ch_idx, struct mbo *mbo)
+{
+	struct hdm_i2c *dev = to_hdm(most_iface);
+	int ret;
+
+	BUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);
+	BUG_ON(!dev->is_open[ch_idx]);
+
+	if (ch_idx == CH_RX) {
+		/* RX */
+		mutex_lock(&dev->rx.list_mutex);
+		list_add_tail(&mbo->list, &dev->rx.list);
+		mutex_unlock(&dev->rx.list_mutex);
+		wake_up_interruptible(&dev->rx.waitq);
+	} else {
+		/* TX */
+		ret = i2c_master_send(dev->client, mbo->virt_address,
+				      mbo->buffer_length);
+		if (ret <= 0) {
+			mbo->processed_length = 0;
+			mbo->status = MBO_E_INVAL;
+		} else {
+			mbo->processed_length = mbo->buffer_length;
+			mbo->status = MBO_SUCCESS;
+		}
+		mbo->complete(mbo);
+	}
+
+	return 0;
+}
+
+/**
+ * poison_channel - called from MOST core to poison buffers of a channel
+ * @iface: pointer to the interface the channel to be poisoned belongs to
+ * @channel_id: corresponding channel ID
+ *
+ * Return 0 on success, negative on failure.
+ *
+ * If channel direction is RX, complete the buffers in list with
+ * status MBO_E_CLOSE
+ */
+static int poison_channel(struct most_interface *most_iface,
+			  int ch_idx)
+{
+	struct hdm_i2c *dev = to_hdm(most_iface);
+	struct mbo *mbo;
+
+	BUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);
+	BUG_ON(!dev->is_open[ch_idx]);
+
+	dev->is_open[ch_idx] = false;
+
+	if (ch_idx == CH_RX) {
+		mutex_lock(&dev->rx.list_mutex);
+		while (!list_empty(&dev->rx.list)) {
+			mbo = list_first_mbo(&dev->rx.list);
+			list_del(&mbo->list);
+			mutex_unlock(&dev->rx.list_mutex);
+
+			mbo->processed_length = 0;
+			mbo->status = MBO_E_CLOSE;
+			mbo->complete(mbo);
+
+			mutex_lock(&dev->rx.list_mutex);
+		}
+		mutex_unlock(&dev->rx.list_mutex);
+		wake_up_interruptible(&dev->rx.waitq);
+	}
+
+	return 0;
+}
+
+static void do_rx_work(struct hdm_i2c *dev)
+{
+	struct mbo *mbo;
+	unsigned char msg[MAX_BUF_SIZE_CONTROL];
+	int ret, ch_idx = CH_RX;
+	u16 pml, data_size;
+
+	/* Read PML (2 bytes) */
+	ret = i2c_master_recv(dev->client, msg, 2);
+	if (ret <= 0) {
+		pr_err("Failed to receive PML\n");
+		return;
+	}
+
+	pml = (msg[0] << 8) | msg[1];
+	if (!pml)
+		return;
+
+	data_size = pml + 2;
+
+	/* Read the whole message, including PML */
+	ret = i2c_master_recv(dev->client, msg, data_size);
+	if (ret <= 0) {
+		pr_err("Failed to receive a Port Message\n");
+		return;
+	}
+
+	for (;;) {
+		/* Conditions to wait for: poisoned channel or free buffer
+		 * available for reading
+		 */
+		if (wait_event_interruptible(dev->rx.waitq,
+					     !dev->is_open[ch_idx] ||
+					     !list_empty(&dev->rx.list))) {
+			pr_err("wait_event_interruptible() failed\n");
+			return;
+		}
+
+		if (!dev->is_open[ch_idx])
+			return;
+
+		mutex_lock(&dev->rx.list_mutex);
+
+		/* list may be empty if poison or remove is called */
+		if (!list_empty(&dev->rx.list))
+			break;
+
+		mutex_unlock(&dev->rx.list_mutex);
+	}
+
+	mbo = list_first_mbo(&dev->rx.list);
+	list_del(&mbo->list);
+	mutex_unlock(&dev->rx.list_mutex);
+
+	mbo->processed_length = min(data_size, mbo->buffer_length);
+	memcpy(mbo->virt_address, msg, mbo->processed_length);
+	mbo->status = MBO_SUCCESS;
+	mbo->complete(mbo);
+}
+
+/**
+ * pending_rx_work - Read pending messages through I2C
+ * @work: definition of this work item
+ *
+ * Invoked by the Interrupt Service Routine, most_irq_handler()
+ */
+static void pending_rx_work(struct work_struct *work)
+{
+	struct hdm_i2c *dev = container_of(work, struct hdm_i2c, rx.dwork.work);
+
+	do_rx_work(dev);
+
+	if (dev->polling_mode) {
+		if (dev->is_open[CH_RX])
+			schedule_delayed_work(&dev->rx.dwork,
+					      msecs_to_jiffies(MSEC_PER_SEC
+							       / scan_rate));
+	} else {
+		enable_irq(dev->client->irq);
+	}
+}
+
+/*
+ * most_irq_handler - Interrupt Service Routine
+ * @irq: irq number
+ * @_dev: private data
+ *
+ * Schedules a delayed work
+ *
+ * By default the interrupt line behavior is Active Low. Once an interrupt is
+ * generated by the device, until driver clears the interrupt (by reading
+ * the PMP message), device keeps the interrupt line in low state. Since i2c
+ * read is done in work queue, the interrupt line must be disabled temporarily
+ * to avoid ISR being called repeatedly. Re-enable the interrupt in workqueue,
+ * after reading the message.
+ *
+ * Note: If we use the interrupt line in Falling edge mode, there is a
+ * possibility to miss interrupts when ISR is getting executed.
+ *
+ */
+static irqreturn_t most_irq_handler(int irq, void *_dev)
+{
+	struct hdm_i2c *dev = _dev;
+
+	disable_irq_nosync(irq);
+
+	schedule_delayed_work(&dev->rx.dwork, 0);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * i2c_probe - i2c probe handler
+ * @client: i2c client device structure
+ * @id: i2c client device id
+ *
+ * Return 0 on success, negative on failure.
+ *
+ * Register the i2c client device as a MOST interface
+ */
+static int i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct hdm_i2c *dev;
+	int ret, i;
+	struct kobject *kobj;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	/* ID format: i2c-<bus>-<address> */
+	snprintf(dev->name, sizeof(dev->name), "i2c-%d-%04x",
+		 client->adapter->nr, client->addr);
+
+	for (i = 0; i < NUM_CHANNELS; i++) {
+		dev->is_open[i] = false;
+		dev->capabilities[i].data_type = MOST_CH_CONTROL;
+		dev->capabilities[i].num_buffers_packet = MAX_BUFFERS_CONTROL;
+		dev->capabilities[i].buffer_size_packet = MAX_BUF_SIZE_CONTROL;
+	}
+	dev->capabilities[CH_RX].direction = MOST_CH_RX;
+	dev->capabilities[CH_RX].name_suffix = "rx";
+	dev->capabilities[CH_TX].direction = MOST_CH_TX;
+	dev->capabilities[CH_TX].name_suffix = "tx";
+
+	dev->most_iface.interface = ITYPE_I2C;
+	dev->most_iface.description = dev->name;
+	dev->most_iface.num_channels = NUM_CHANNELS;
+	dev->most_iface.channel_vector = dev->capabilities;
+	dev->most_iface.configure = configure_channel;
+	dev->most_iface.enqueue = enqueue;
+	dev->most_iface.poison_channel = poison_channel;
+
+	INIT_LIST_HEAD(&dev->rx.list);
+	mutex_init(&dev->rx.list_mutex);
+	init_waitqueue_head(&dev->rx.waitq);
+
+	INIT_DELAYED_WORK(&dev->rx.dwork, pending_rx_work);
+
+	dev->client = client;
+	i2c_set_clientdata(client, dev);
+
+	kobj = most_register_interface(&dev->most_iface);
+	if (IS_ERR(kobj)) {
+		pr_err("Failed to register i2c as a MOST interface\n");
+		kfree(dev);
+		return PTR_ERR(kobj);
+	}
+
+	dev->polling_mode = polling_req || client->irq <= 0;
+	if (!dev->polling_mode) {
+		pr_info("Requesting IRQ: %d\n", client->irq);
+		ret = request_irq(client->irq, most_irq_handler, 0,
+				  client->name, dev);
+		if (ret) {
+			pr_info("IRQ request failed: %d, falling back to polling\n",
+				ret);
+			dev->polling_mode = true;
+		}
+	}
+
+	if (dev->polling_mode)
+		pr_info("Using polling at rate: %d times/sec\n", scan_rate);
+
+	return 0;
+}
+
+/*
+ * i2c_remove - i2c remove handler
+ * @client: i2c client device structure
+ *
+ * Return 0 on success.
+ *
+ * Unregister the i2c client device as a MOST interface
+ */
+static int i2c_remove(struct i2c_client *client)
+{
+	struct hdm_i2c *dev = i2c_get_clientdata(client);
+	int i;
+
+	if (!dev->polling_mode)
+		free_irq(client->irq, dev);
+
+	most_deregister_interface(&dev->most_iface);
+
+	for (i = 0 ; i < NUM_CHANNELS; i++)
+		if (dev->is_open[i])
+			poison_channel(&dev->most_iface, i);
+	cancel_delayed_work_sync(&dev->rx.dwork);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id i2c_id[] = {
+	{ "most_i2c", 0 },
+	{ }, /* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(i2c, i2c_id);
+
+static struct i2c_driver i2c_driver = {
+	.driver = {
+		.name = "hdm_i2c",
+	},
+	.probe = i2c_probe,
+	.remove = i2c_remove,
+	.id_table = i2c_id,
+};
+
+module_i2c_driver(i2c_driver);
+
+MODULE_AUTHOR("Jain Roy Ambi <JainRoy.Ambi@microchip.com>");
+MODULE_AUTHOR("Andrey Shvetsov <andrey.shvetsov@k2l.de>");
+MODULE_DESCRIPTION("I2C Hardware Dependent Module");
+MODULE_LICENSE("GPL");
