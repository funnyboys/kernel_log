commit b276527539188f1f61c082ebef27803db93e536d
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Mar 10 14:02:40 2020 +0100

    staging: most: move core files out of the staging area
    
    This patch moves the core module to the /drivers/most directory
    and makes all necessary changes in order to not break the build.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Link: https://lore.kernel.org/r/1583845362-26707-2-git-send-email-christian.gromm@microchip.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 71943d17f825..cc1e3dea196d 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -16,8 +16,7 @@
 #include <linux/kfifo.h>
 #include <linux/uaccess.h>
 #include <linux/idr.h>
-
-#include "../most.h"
+#include <linux/most.h>
 
 #define CHRDEV_REGION_SIZE 50
 

commit 532c29190795178bb02d2671b5e8a288c16a4649
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Thu Jan 16 01:44:51 2020 +0900

    staging: most: remove header include path to drivers/staging
    
    There is no need to add "ccflags-y += -I $(srctree)/drivers/staging"
    just for including <most/most.h>.
    
    Use the #include "..." directive with the correct relative path.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Link: https://lore.kernel.org/r/20200115164451.13203-1-masahiroy@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 59f346d1f4af..71943d17f825 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -16,7 +16,8 @@
 #include <linux/kfifo.h>
 #include <linux/uaccess.h>
 #include <linux/idr.h>
-#include <most/most.h>
+
+#include "../most.h"
 
 #define CHRDEV_REGION_SIZE 50
 

commit 6f4d22d76baa73c5bc99d669d68c862b60a04a3d
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Fri Dec 13 13:04:19 2019 +0100

    staging: most: use angle brackets in include path
    
    This patch replaces the double quotes in all include paths
    with angle brackets.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Link: https://lore.kernel.org/r/1576238662-16512-7-git-send-email-christian.gromm@microchip.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 9ce2f23dcaed..59f346d1f4af 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -16,7 +16,7 @@
 #include <linux/kfifo.h>
 #include <linux/uaccess.h>
 #include <linux/idr.h>
-#include "most/most.h"
+#include <most/most.h>
 
 #define CHRDEV_REGION_SIZE 50
 

commit 45917e79202c7a0b67f1331c154afba77a3d4a1e
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Fri Dec 13 13:04:15 2019 +0100

    staging: most: rename struct core_component
    
    The stuctures defined in the most.h header file will be exposed to the
    kernel once the file is moved out of the staging area. That's why the name
    is changed into something more descriptive.
    
    Reported-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Link: https://lore.kernel.org/r/1576238662-16512-3-git-send-email-christian.gromm@microchip.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index df4cb5a3818e..9ce2f23dcaed 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -25,7 +25,7 @@ static struct cdev_component {
 	struct ida minor_id;
 	unsigned int major;
 	struct class *class;
-	struct core_component cc;
+	struct most_component cc;
 } comp;
 
 struct comp_channel {

commit c1d3fb8abe667cd9aa59f3a176ca4d0636d9b44b
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Fri Dec 13 13:04:14 2019 +0100

    staging: most: rename core.h to most.h
    
    This patch renames the core header file core.h to most.h. The intention
    behind this is to have a meaningful name once this file is moved to the
    /include/linux directory.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Link: https://lore.kernel.org/r/1576238662-16512-2-git-send-email-christian.gromm@microchip.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index f880147c82fd..df4cb5a3818e 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -16,7 +16,7 @@
 #include <linux/kfifo.h>
 #include <linux/uaccess.h>
 #include <linux/idr.h>
-#include "most/core.h"
+#include "most/most.h"
 
 #define CHRDEV_REGION_SIZE 50
 

commit 08283d30744434d8f30d386622372e8f5b03bcf2
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Fri Nov 8 17:21:08 2019 +0100

    staging: most: block module removal while having active configfs items
    
    This patch avoids that core component modules are being unloaded
    while the related configfs interface has active items in its directories.
    It is needed to prevent the situation where the core module cannot
    be unloaded anymore, because the reference count 'used by' indicates that
    the module is still being used and the usage count cannot be decreased by
    calling rmdir, as the configfs directory has already been removed.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Link: https://lore.kernel.org/r/1573230068-27658-3-git-send-email-christian.gromm@microchip.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 724d098aeef0..f880147c82fd 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -494,6 +494,7 @@ static int comp_probe(struct most_interface *iface, int channel_id,
 
 static struct cdev_component comp = {
 	.cc = {
+		.mod = THIS_MODULE,
 		.name = "cdev",
 		.probe_channel = comp_probe,
 		.disconnect_channel = comp_disconnect_channel,

commit ebf256e36754fc5c4a259bb28f3c0a081eb70467
Author: Keyur Patel <iamkeyur96@gmail.com>
Date:   Sun Jul 14 13:27:06 2019 -0400

    staging: most: Delete an error message for a failed memory allocation
    
    The kfifo_alloc() failure generates enough information and doesn't need
    to be accompanied by another error statement.
    
    Signed-off-by: Keyur Patel <iamkeyur96@gmail.com>
    Link: https://lore.kernel.org/r/20190714172708.5067-1-iamkeyur96@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index d0cc0b746107..724d098aeef0 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -463,10 +463,8 @@ static int comp_probe(struct most_interface *iface, int channel_id,
 	spin_lock_init(&c->unlink);
 	INIT_KFIFO(c->fifo);
 	retval = kfifo_alloc(&c->fifo, cfg->num_buffers, GFP_KERNEL);
-	if (retval) {
-		pr_info("failed to alloc channel kfifo");
+	if (retval)
 		goto err_del_cdev_and_free_channel;
-	}
 	init_waitqueue_head(&c->wq);
 	mutex_init(&c->io_mutex);
 	spin_lock_irqsave(&ch_list_lock, cl_flags);

commit af708900e9a48c0aa46070c8a8cdf0608a1d2025
Author: Suresh Udipi <sudipi@jp.adit-jv.com>
Date:   Wed Apr 24 21:23:43 2019 +0200

    staging: most: cdev: fix chrdev_region leak in mod_exit
    
    It looks like v4.18-rc1 commit [0] which upstreams mld-1.8.0
    commit [1] missed to fix the memory leak in mod_exit function.
    
    Do it now.
    
    [0] aba258b7310167 ("staging: most: cdev: fix chrdev_region leak")
    [1] https://github.com/microchip-ais/linux/commit/a2d8f7ae7ea381
        ("staging: most: cdev: fix leak for chrdev_region")
    
    Signed-off-by: Suresh Udipi <sudipi@jp.adit-jv.com>
    Signed-off-by: Eugeniu Rosca <erosca@de.adit-jv.com>
    Acked-by: Christian Gromm <christian.gromm@microchip.com>
    Fixes: aba258b73101 ("staging: most: cdev: fix chrdev_region leak")
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index d98977c57a4b..d0cc0b746107 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -555,7 +555,7 @@ static void __exit mod_exit(void)
 		destroy_cdev(c);
 		destroy_channel(c);
 	}
-	unregister_chrdev_region(comp.devno, 1);
+	unregister_chrdev_region(comp.devno, CHRDEV_REGION_SIZE);
 	ida_destroy(&comp.minor_id);
 	class_destroy(comp.class);
 }

commit 919c03ae11b98681aedc2ac7d00110c387b92f16
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Wed Apr 3 15:19:48 2019 +0200

    staging: most: enable configfs support
    
    This patch enables the configfs functionality of the driver by
    registering the configfs subsystems and compiling the configfs
    part of the sources.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 97408ecc182b..d98977c57a4b 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -527,8 +527,13 @@ static int __init mod_init(void)
 	err = most_register_component(&comp.cc);
 	if (err)
 		goto free_cdev;
+	err = most_register_configfs_subsys(&comp.cc);
+	if (err)
+		goto deregister_comp;
 	return 0;
 
+deregister_comp:
+	most_deregister_component(&comp.cc);
 free_cdev:
 	unregister_chrdev_region(comp.devno, CHRDEV_REGION_SIZE);
 dest_ida:
@@ -543,6 +548,7 @@ static void __exit mod_exit(void)
 
 	pr_info("exit module\n");
 
+	most_deregister_configfs_subsys(&comp.cc);
 	most_deregister_component(&comp.cc);
 
 	list_for_each_entry_safe(c, tmp, &channel_list, list) {

commit dfee92dd50464cbce3d3df2b1ca3eb6c39fb9467
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Wed Apr 3 15:19:45 2019 +0200

    staging: most: change signature of function probe_channel
    
    This patch adds the param argument to the function parameter of
    the call-back probe_channel. This parameter is needed to configure
    the channels of an attached device.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index f2b347cda8b7..97408ecc182b 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -425,7 +425,7 @@ static int comp_tx_completion(struct most_interface *iface, int channel_id)
  * Returns 0 on success or error code otherwise.
  */
 static int comp_probe(struct most_interface *iface, int channel_id,
-		      struct most_channel_config *cfg, char *name)
+		      struct most_channel_config *cfg, char *name, char *args)
 {
 	struct comp_channel *c;
 	unsigned long cl_flags;

commit 5ae890780e1b4d08f2c0c5d4ea96fc3928fc0ee9
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Feb 2 22:34:49 2019 +0000

    staging: most: cdev: add missing check for cdev_add failure
    
    Currently the call to cdev_add is missing a check for failure. Fix this by
    checking for failure and exiting via a new error path that ensures the
    allocated comp_channel struct is kfree'd.
    
    Detected by CoverityScan, CID#1462359 ("Unchecked return value")
    
    Fixes: 9bc79bbcd0c5 ("Staging: most: add MOST driver's aim-cdev module")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index ea64aabda94e..f2b347cda8b7 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -453,7 +453,9 @@ static int comp_probe(struct most_interface *iface, int channel_id,
 	c->devno = MKDEV(comp.major, current_minor);
 	cdev_init(&c->cdev, &channel_fops);
 	c->cdev.owner = THIS_MODULE;
-	cdev_add(&c->cdev, c->devno, 1);
+	retval = cdev_add(&c->cdev, c->devno, 1);
+	if (retval < 0)
+		goto err_free_c;
 	c->iface = iface;
 	c->cfg = cfg;
 	c->channel_id = channel_id;
@@ -485,6 +487,7 @@ static int comp_probe(struct most_interface *iface, int channel_id,
 	list_del(&c->list);
 err_del_cdev_and_free_channel:
 	cdev_del(&c->cdev);
+err_free_c:
 	kfree(c);
 err_remove_ida:
 	ida_simple_remove(&comp.minor_id, current_minor);

commit bddd3c2546e9c46e59160bbfdc49c82f9220212e
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Fri Sep 21 11:28:51 2018 +0200

    staging: most: fix label names
    
    This patch makes use of label names that say what the goto
    actually does, as recommended in the kernel documentation.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 4569838f27a0..ea64aabda94e 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -447,7 +447,7 @@ static int comp_probe(struct most_interface *iface, int channel_id,
 	c = kzalloc(sizeof(*c), GFP_KERNEL);
 	if (!c) {
 		retval = -ENOMEM;
-		goto error_alloc_channel;
+		goto err_remove_ida;
 	}
 
 	c->devno = MKDEV(comp.major, current_minor);
@@ -463,7 +463,7 @@ static int comp_probe(struct most_interface *iface, int channel_id,
 	retval = kfifo_alloc(&c->fifo, cfg->num_buffers, GFP_KERNEL);
 	if (retval) {
 		pr_info("failed to alloc channel kfifo");
-		goto error_alloc_kfifo;
+		goto err_del_cdev_and_free_channel;
 	}
 	init_waitqueue_head(&c->wq);
 	mutex_init(&c->io_mutex);
@@ -475,18 +475,18 @@ static int comp_probe(struct most_interface *iface, int channel_id,
 	if (IS_ERR(c->dev)) {
 		retval = PTR_ERR(c->dev);
 		pr_info("failed to create new device node %s\n", name);
-		goto error_create_device;
+		goto err_free_kfifo_and_del_list;
 	}
 	kobject_uevent(&c->dev->kobj, KOBJ_ADD);
 	return 0;
 
-error_create_device:
+err_free_kfifo_and_del_list:
 	kfifo_free(&c->fifo);
 	list_del(&c->list);
-error_alloc_kfifo:
+err_del_cdev_and_free_channel:
 	cdev_del(&c->cdev);
 	kfree(c);
-error_alloc_channel:
+err_remove_ida:
 	ida_simple_remove(&comp.minor_id, current_minor);
 	return retval;
 }

commit 993c1637a08f436eacc7b3f4eacbda8dac0b304b
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:45:10 2018 +0200

    staging: most: cdev: fix race condition
    
    This patch fixes a race condition between the functions disconnect and poll.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 8e7652545402..4569838f27a0 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -292,13 +292,15 @@ static __poll_t comp_poll(struct file *filp, poll_table *wait)
 
 	poll_wait(filp, &c->wq, wait);
 
+	mutex_lock(&c->io_mutex);
 	if (c->cfg->direction == MOST_CH_RX) {
-		if (!kfifo_is_empty(&c->fifo))
+		if (!c->dev || !kfifo_is_empty(&c->fifo))
 			mask |= EPOLLIN | EPOLLRDNORM;
 	} else {
-		if (!kfifo_is_empty(&c->fifo) || ch_has_mbo(c))
+		if (!c->dev || !kfifo_is_empty(&c->fifo) || ch_has_mbo(c))
 			mask |= EPOLLOUT | EPOLLWRNORM;
 	}
+	mutex_unlock(&c->io_mutex);
 	return mask;
 }
 

commit 7d56f62d3c4c3217049ef687827303356c8b1766
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:45:08 2018 +0200

    staging: most: cdev: fix function return value
    
    The function ch_get_mbo declares its return value as type bool,
    but returns a pointer to mbo.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 9ce7fd2a07e7..8e7652545402 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -53,7 +53,7 @@ static inline bool ch_has_mbo(struct comp_channel *c)
 	return channel_has_mbo(c->iface, c->channel_id, &comp.cc) > 0;
 }
 
-static inline bool ch_get_mbo(struct comp_channel *c, struct mbo **mbo)
+static inline struct mbo *ch_get_mbo(struct comp_channel *c, struct mbo **mbo)
 {
 	if (!kfifo_peek(&c->fifo, mbo)) {
 		*mbo = most_get_mbo(c->iface, c->channel_id, &comp.cc);

commit aba258b73101670c06b1dd700e500ed0a3fa0e8e
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:45:06 2018 +0200

    staging: most: cdev: fix chrdev_region leak
    
    The function unregister_chrdev_region is called with a different counter
    as the alloc_chrdev_region. To fix this, this patch introduces the
    constant CHRDEV_REGION_SIZE that is used in both functions.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 89d7fc7eb4b3..9ce7fd2a07e7 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -18,6 +18,8 @@
 #include <linux/idr.h>
 #include "most/core.h"
 
+#define CHRDEV_REGION_SIZE 50
+
 static struct cdev_component {
 	dev_t devno;
 	struct ida minor_id;
@@ -513,7 +515,7 @@ static int __init mod_init(void)
 	spin_lock_init(&ch_list_lock);
 	ida_init(&comp.minor_id);
 
-	err = alloc_chrdev_region(&comp.devno, 0, 50, "cdev");
+	err = alloc_chrdev_region(&comp.devno, 0, CHRDEV_REGION_SIZE, "cdev");
 	if (err < 0)
 		goto dest_ida;
 	comp.major = MAJOR(comp.devno);
@@ -523,7 +525,7 @@ static int __init mod_init(void)
 	return 0;
 
 free_cdev:
-	unregister_chrdev_region(comp.devno, 1);
+	unregister_chrdev_region(comp.devno, CHRDEV_REGION_SIZE);
 dest_ida:
 	ida_destroy(&comp.minor_id);
 	class_destroy(comp.class);

commit 8463d9fab6e25a77b640caada74af29f936a8ea4
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue May 8 11:45:05 2018 +0200

    staging: most: cdev: avoid warning about potentially uninitialized variable
    
    This patch avoids the warning that the pointer mbo might be used
    uninitialized that some environmens throw.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 4d7fce8731fe..89d7fc7eb4b3 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -242,7 +242,7 @@ static ssize_t
 comp_read(struct file *filp, char __user *buf, size_t count, loff_t *offset)
 {
 	size_t to_copy, not_copied, copied;
-	struct mbo *mbo;
+	struct mbo *mbo = NULL;
 	struct comp_channel *c = filp->private_data;
 
 	mutex_lock(&c->io_mutex);

commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index c183489c4a1c..4d7fce8731fe 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -292,10 +292,10 @@ static __poll_t comp_poll(struct file *filp, poll_table *wait)
 
 	if (c->cfg->direction == MOST_CH_RX) {
 		if (!kfifo_is_empty(&c->fifo))
-			mask |= POLLIN | POLLRDNORM;
+			mask |= EPOLLIN | EPOLLRDNORM;
 	} else {
 		if (!kfifo_is_empty(&c->fifo) || ch_has_mbo(c))
-			mask |= POLLOUT | POLLWRNORM;
+			mask |= EPOLLOUT | EPOLLWRNORM;
 	}
 	return mask;
 }

commit 5d8515bc232172963a4cef007e97b08c5e4d0533
Merge: db5933225f2f 3384e01179ef
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 1 09:51:57 2018 -0800

    Merge tag 'staging-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging/IIO updates from Greg KH:
     "Here is the big Staging and IIO driver patches for 4.16-rc1.
    
      There is the normal amount of new IIO drivers added, like all
      releases.
    
      The networking IPX and the ncpfs filesystem are moved into the staging
      tree, as they are on their way out of the kernel due to lack of use
      anymore.
    
      The visorbus subsystem finall has started moving out of the staging
      tree to the "real" part of the kernel, and the most and fsl-mc
      codebases are almost ready to move out, that will probably happen for
      4.17-rc1 if all goes well.
    
      Other than that, there is a bunch of license header cleanups in the
      tree, along with the normal amount of coding style churn that we all
      know and love for this codebase. I also got frustrated at the
      Meltdown/Spectre mess and took it out on the dgnc tty driver, deleting
      huge chunks of it that were never even being used.
    
      Full details of everything is in the shortlog.
    
      All of these patches have been in linux-next for a while with no
      reported issues"
    
    * tag 'staging-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (627 commits)
      staging: rtlwifi: remove redundant initialization of 'cfg_cmd'
      staging: rtl8723bs: remove a couple of redundant initializations
      staging: comedi: reformat lines to 80 chars or less
      staging: lustre: separate a connection destroy from free struct kib_conn
      Staging: rtl8723bs: Use !x instead of NULL comparison
      Staging: rtl8723bs: Remove dead code
      Staging: rtl8723bs: Change names to conform to the kernel code
      staging: ccree: Fix missing blank line after declaration
      staging: rtl8188eu: remove redundant initialization of 'pwrcfgcmd'
      staging: rtlwifi: remove unused RTLHALMAC_ST and RTLPHYDM_ST
      staging: fbtft: remove unused FB_TFT_SSD1325 kconfig
      staging: comedi: dt2811: remove redundant initialization of 'ns'
      staging: wilc1000: fix alignments to match open parenthesis
      staging: wilc1000: removed unnecessary defined enums typedef
      staging: wilc1000: remove unnecessary use of parentheses
      staging: rtl8192u: remove redundant initialization of 'timeout'
      staging: sm750fb: fix CamelCase for dispSet var
      staging: lustre: lnet/selftest: fix compile error on UP build
      staging: rtl8723bs: hal_com_phycfg: Remove unneeded semicolons
      staging: rts5208: Fix "seg_no" calculation in reset_ms_card()
      ...

commit c73d915dd293a42f45df1d1c19fc85f93ba48784
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Nov 21 15:05:20 2017 +0100

    staging: most: cdev: bundle module variables in structure
    
    This patch creates the structure comp to put the module variables for
    encapsulation purposes. For an improved readability some variables are
    renamed.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 6f58eee5c8d5..dd9456fd2cd6 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -18,11 +18,13 @@
 #include <linux/idr.h>
 #include "most/core.h"
 
-static dev_t comp_devno;
-static struct class *comp_class;
-static struct ida minor_id;
-static unsigned int major;
-static struct core_component cdev_comp;
+static struct cdev_component {
+	dev_t devno;
+	struct ida minor_id;
+	unsigned int major;
+	struct class *class;
+	struct core_component cc;
+} comp;
 
 struct comp_channel {
 	wait_queue_head_t wq;
@@ -46,13 +48,13 @@ static spinlock_t ch_list_lock;
 
 static inline bool ch_has_mbo(struct comp_channel *c)
 {
-	return channel_has_mbo(c->iface, c->channel_id, &cdev_comp) > 0;
+	return channel_has_mbo(c->iface, c->channel_id, &comp.cc) > 0;
 }
 
 static inline bool ch_get_mbo(struct comp_channel *c, struct mbo **mbo)
 {
 	if (!kfifo_peek(&c->fifo, mbo)) {
-		*mbo = most_get_mbo(c->iface, c->channel_id, &cdev_comp);
+		*mbo = most_get_mbo(c->iface, c->channel_id, &comp.cc);
 		if (*mbo)
 			kfifo_in(&c->fifo, mbo, 1);
 	}
@@ -84,14 +86,14 @@ static void stop_channel(struct comp_channel *c)
 
 	while (kfifo_out((struct kfifo *)&c->fifo, &mbo, 1))
 		most_put_mbo(mbo);
-	most_stop_channel(c->iface, c->channel_id, &cdev_comp);
+	most_stop_channel(c->iface, c->channel_id, &comp.cc);
 }
 
 static void destroy_cdev(struct comp_channel *c)
 {
 	unsigned long flags;
 
-	device_destroy(comp_class, c->devno);
+	device_destroy(comp.class, c->devno);
 	cdev_del(&c->cdev);
 	spin_lock_irqsave(&ch_list_lock, flags);
 	list_del(&c->list);
@@ -100,7 +102,7 @@ static void destroy_cdev(struct comp_channel *c)
 
 static void destroy_channel(struct comp_channel *c)
 {
-	ida_simple_remove(&minor_id, MINOR(c->devno));
+	ida_simple_remove(&comp.minor_id, MINOR(c->devno));
 	kfifo_free(&c->fifo);
 	kfree(c);
 }
@@ -143,7 +145,7 @@ static int comp_open(struct inode *inode, struct file *filp)
 	}
 
 	c->mbo_offs = 0;
-	ret = most_start_channel(c->iface, c->channel_id, &cdev_comp);
+	ret = most_start_channel(c->iface, c->channel_id, &comp.cc);
 	if (!ret)
 		c->access_ref = 1;
 	mutex_unlock(&c->io_mutex);
@@ -434,7 +436,7 @@ static int comp_probe(struct most_interface *iface, int channel_id,
 	if (c)
 		return -EEXIST;
 
-	current_minor = ida_simple_get(&minor_id, 0, 0, GFP_KERNEL);
+	current_minor = ida_simple_get(&comp.minor_id, 0, 0, GFP_KERNEL);
 	if (current_minor < 0)
 		return current_minor;
 
@@ -444,7 +446,7 @@ static int comp_probe(struct most_interface *iface, int channel_id,
 		goto error_alloc_channel;
 	}
 
-	c->devno = MKDEV(major, current_minor);
+	c->devno = MKDEV(comp.major, current_minor);
 	cdev_init(&c->cdev, &channel_fops);
 	c->cdev.owner = THIS_MODULE;
 	cdev_add(&c->cdev, c->devno, 1);
@@ -464,11 +466,7 @@ static int comp_probe(struct most_interface *iface, int channel_id,
 	spin_lock_irqsave(&ch_list_lock, cl_flags);
 	list_add_tail(&c->list, &channel_list);
 	spin_unlock_irqrestore(&ch_list_lock, cl_flags);
-	c->dev = device_create(comp_class,
-				     NULL,
-				     c->devno,
-				     NULL,
-				     "%s", name);
+	c->dev = device_create(comp.class, NULL, c->devno, NULL, "%s", name);
 
 	if (IS_ERR(c->dev)) {
 		retval = PTR_ERR(c->dev);
@@ -485,16 +483,18 @@ static int comp_probe(struct most_interface *iface, int channel_id,
 	cdev_del(&c->cdev);
 	kfree(c);
 error_alloc_channel:
-	ida_simple_remove(&minor_id, current_minor);
+	ida_simple_remove(&comp.minor_id, current_minor);
 	return retval;
 }
 
-static struct core_component cdev_comp = {
-	.name = "cdev",
-	.probe_channel = comp_probe,
-	.disconnect_channel = comp_disconnect_channel,
-	.rx_completion = comp_rx_completion,
-	.tx_completion = comp_tx_completion,
+static struct cdev_component comp = {
+	.cc = {
+		.name = "cdev",
+		.probe_channel = comp_probe,
+		.disconnect_channel = comp_disconnect_channel,
+		.rx_completion = comp_rx_completion,
+		.tx_completion = comp_tx_completion,
+	},
 };
 
 static int __init mod_init(void)
@@ -503,32 +503,30 @@ static int __init mod_init(void)
 
 	pr_info("init()\n");
 
+	comp.class = class_create(THIS_MODULE, "most_cdev");
+	if (IS_ERR(comp.class)) {
+		pr_info("No udev support.\n");
+		return PTR_ERR(comp.class);
+	}
+
 	INIT_LIST_HEAD(&channel_list);
 	spin_lock_init(&ch_list_lock);
-	ida_init(&minor_id);
+	ida_init(&comp.minor_id);
 
-	err = alloc_chrdev_region(&comp_devno, 0, 50, "cdev");
+	err = alloc_chrdev_region(&comp.devno, 0, 50, "cdev");
 	if (err < 0)
 		goto dest_ida;
-	major = MAJOR(comp_devno);
-
-	comp_class = class_create(THIS_MODULE, "most_cdev_comp");
-	if (IS_ERR(comp_class)) {
-		pr_err("no udev support\n");
-		err = PTR_ERR(comp_class);
-		goto free_cdev;
-	}
-	err = most_register_component(&cdev_comp);
+	comp.major = MAJOR(comp.devno);
+	err = most_register_component(&comp.cc);
 	if (err)
-		goto dest_class;
+		goto free_cdev;
 	return 0;
 
-dest_class:
-	class_destroy(comp_class);
 free_cdev:
-	unregister_chrdev_region(comp_devno, 1);
+	unregister_chrdev_region(comp.devno, 1);
 dest_ida:
-	ida_destroy(&minor_id);
+	ida_destroy(&comp.minor_id);
+	class_destroy(comp.class);
 	return err;
 }
 
@@ -538,15 +536,15 @@ static void __exit mod_exit(void)
 
 	pr_info("exit module\n");
 
-	most_deregister_component(&cdev_comp);
+	most_deregister_component(&comp.cc);
 
 	list_for_each_entry_safe(c, tmp, &channel_list, list) {
 		destroy_cdev(c);
 		destroy_channel(c);
 	}
-	class_destroy(comp_class);
-	unregister_chrdev_region(comp_devno, 1);
-	ida_destroy(&minor_id);
+	unregister_chrdev_region(comp.devno, 1);
+	ida_destroy(&comp.minor_id);
+	class_destroy(comp.class);
 }
 
 module_init(mod_init);

commit 1fd923f38610a802f4b6f4dc30ada9c80cd52d9e
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Nov 21 15:05:19 2017 +0100

    staging: most: cdev: replace function prefix
    
    This patch replaces the function prefixes aim_* with comp_*. It is needed
    to complete the process of changing the module designator from AIM to
    Component.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 266e2bb6ecf7..6f58eee5c8d5 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -106,14 +106,14 @@ static void destroy_channel(struct comp_channel *c)
 }
 
 /**
- * aim_open - implements the syscall to open the device
+ * comp_open - implements the syscall to open the device
  * @inode: inode pointer
  * @filp: file pointer
  *
  * This stores the channel pointer in the private data field of
  * the file structure and activates the channel within the core.
  */
-static int aim_open(struct inode *inode, struct file *filp)
+static int comp_open(struct inode *inode, struct file *filp)
 {
 	struct comp_channel *c;
 	int ret;
@@ -151,13 +151,13 @@ static int aim_open(struct inode *inode, struct file *filp)
 }
 
 /**
- * aim_close - implements the syscall to close the device
+ * comp_close - implements the syscall to close the device
  * @inode: inode pointer
  * @filp: file pointer
  *
  * This stops the channel within the core.
  */
-static int aim_close(struct inode *inode, struct file *filp)
+static int comp_close(struct inode *inode, struct file *filp)
 {
 	struct comp_channel *c = to_channel(inode->i_cdev);
 
@@ -176,14 +176,14 @@ static int aim_close(struct inode *inode, struct file *filp)
 }
 
 /**
- * aim_write - implements the syscall to write to the device
+ * comp_write - implements the syscall to write to the device
  * @filp: file pointer
  * @buf: pointer to user buffer
  * @count: number of bytes to write
  * @offset: offset from where to start writing
  */
-static ssize_t aim_write(struct file *filp, const char __user *buf,
-			 size_t count, loff_t *offset)
+static ssize_t comp_write(struct file *filp, const char __user *buf,
+			  size_t count, loff_t *offset)
 {
 	int ret;
 	size_t to_copy, left;
@@ -230,14 +230,14 @@ static ssize_t aim_write(struct file *filp, const char __user *buf,
 }
 
 /**
- * aim_read - implements the syscall to read from the device
+ * comp_read - implements the syscall to read from the device
  * @filp: file pointer
  * @buf: pointer to user buffer
  * @count: number of bytes to read
  * @offset: offset from where to start reading
  */
 static ssize_t
-aim_read(struct file *filp, char __user *buf, size_t count, loff_t *offset)
+comp_read(struct file *filp, char __user *buf, size_t count, loff_t *offset)
 {
 	size_t to_copy, not_copied, copied;
 	struct mbo *mbo;
@@ -281,7 +281,7 @@ aim_read(struct file *filp, char __user *buf, size_t count, loff_t *offset)
 	return copied;
 }
 
-static unsigned int aim_poll(struct file *filp, poll_table *wait)
+static unsigned int comp_poll(struct file *filp, poll_table *wait)
 {
 	struct comp_channel *c = filp->private_data;
 	unsigned int mask = 0;
@@ -303,22 +303,22 @@ static unsigned int aim_poll(struct file *filp, poll_table *wait)
  */
 static const struct file_operations channel_fops = {
 	.owner = THIS_MODULE,
-	.read = aim_read,
-	.write = aim_write,
-	.open = aim_open,
-	.release = aim_close,
-	.poll = aim_poll,
+	.read = comp_read,
+	.write = comp_write,
+	.open = comp_open,
+	.release = comp_close,
+	.poll = comp_poll,
 };
 
 /**
- * aim_disconnect_channel - disconnect a channel
+ * comp_disconnect_channel - disconnect a channel
  * @iface: pointer to interface instance
  * @channel_id: channel index
  *
  * This frees allocated memory and removes the cdev that represents this
  * channel in user space.
  */
-static int aim_disconnect_channel(struct most_interface *iface, int channel_id)
+static int comp_disconnect_channel(struct most_interface *iface, int channel_id)
 {
 	struct comp_channel *c;
 
@@ -348,13 +348,13 @@ static int aim_disconnect_channel(struct most_interface *iface, int channel_id)
 }
 
 /**
- * aim_rx_completion - completion handler for rx channels
+ * comp_rx_completion - completion handler for rx channels
  * @mbo: pointer to buffer object that has completed
  *
  * This searches for the channel linked to this MBO and stores it in the local
  * fifo buffer.
  */
-static int aim_rx_completion(struct mbo *mbo)
+static int comp_rx_completion(struct mbo *mbo)
 {
 	struct comp_channel *c;
 
@@ -381,13 +381,13 @@ static int aim_rx_completion(struct mbo *mbo)
 }
 
 /**
- * aim_tx_completion - completion handler for tx channels
+ * comp_tx_completion - completion handler for tx channels
  * @iface: pointer to interface instance
  * @channel_id: channel index/ID
  *
  * This wakes sleeping processes in the wait-queue.
  */
-static int aim_tx_completion(struct most_interface *iface, int channel_id)
+static int comp_tx_completion(struct most_interface *iface, int channel_id)
 {
 	struct comp_channel *c;
 
@@ -408,7 +408,7 @@ static int aim_tx_completion(struct most_interface *iface, int channel_id)
 }
 
 /**
- * aim_probe - probe function of the driver module
+ * comp_probe - probe function of the driver module
  * @iface: pointer to interface instance
  * @channel_id: channel index/ID
  * @cfg: pointer to actual channel configuration
@@ -418,8 +418,8 @@ static int aim_tx_completion(struct most_interface *iface, int channel_id)
  *
  * Returns 0 on success or error code otherwise.
  */
-static int aim_probe(struct most_interface *iface, int channel_id,
-		     struct most_channel_config *cfg, char *name)
+static int comp_probe(struct most_interface *iface, int channel_id,
+		      struct most_channel_config *cfg, char *name)
 {
 	struct comp_channel *c;
 	unsigned long cl_flags;
@@ -427,7 +427,7 @@ static int aim_probe(struct most_interface *iface, int channel_id,
 	int current_minor;
 
 	if ((!iface) || (!cfg) || (!name)) {
-		pr_info("Probing AIM with bad arguments");
+		pr_info("Probing component with bad arguments");
 		return -EINVAL;
 	}
 	c = get_channel(iface, channel_id);
@@ -491,10 +491,10 @@ static int aim_probe(struct most_interface *iface, int channel_id,
 
 static struct core_component cdev_comp = {
 	.name = "cdev",
-	.probe_channel = aim_probe,
-	.disconnect_channel = aim_disconnect_channel,
-	.rx_completion = aim_rx_completion,
-	.tx_completion = aim_tx_completion,
+	.probe_channel = comp_probe,
+	.disconnect_channel = comp_disconnect_channel,
+	.rx_completion = comp_rx_completion,
+	.tx_completion = comp_tx_completion,
 };
 
 static int __init mod_init(void)

commit b7937dc41362f73cb1ed228fdd3ac32a69b17794
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Nov 21 15:05:12 2017 +0100

    staging: most: fix comment sections
    
    This patch updates and corrects the comment sections of the code.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 8a4ed753beae..266e2bb6ecf7 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * cdev.c - Application interfacing module for character devices
+ * cdev.c - Character device component for Mostcore
  *
  * Copyright (C) 2013-2015 Microchip Technology Germany II GmbH & Co. KG
  */
@@ -553,4 +553,4 @@ module_init(mod_init);
 module_exit(mod_exit);
 MODULE_AUTHOR("Christian Gromm <christian.gromm@microchip.com>");
 MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("character device AIM for mostcore");
+MODULE_DESCRIPTION("character device component for mostcore");

commit 6822ba8a6739011f37a51f18c159ce5d35681cc6
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Nov 21 15:05:11 2017 +0100

    staging: most: cdev: rename variable cdev_aim
    
    This patch renames the variable cdev_aim to cdev_comp. It is needed to
    complete the process of changing the module designator from AIM to
    Component.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index dfc6a6abbd54..8a4ed753beae 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -22,7 +22,7 @@ static dev_t comp_devno;
 static struct class *comp_class;
 static struct ida minor_id;
 static unsigned int major;
-static struct core_component cdev_aim;
+static struct core_component cdev_comp;
 
 struct comp_channel {
 	wait_queue_head_t wq;
@@ -46,13 +46,13 @@ static spinlock_t ch_list_lock;
 
 static inline bool ch_has_mbo(struct comp_channel *c)
 {
-	return channel_has_mbo(c->iface, c->channel_id, &cdev_aim) > 0;
+	return channel_has_mbo(c->iface, c->channel_id, &cdev_comp) > 0;
 }
 
 static inline bool ch_get_mbo(struct comp_channel *c, struct mbo **mbo)
 {
 	if (!kfifo_peek(&c->fifo, mbo)) {
-		*mbo = most_get_mbo(c->iface, c->channel_id, &cdev_aim);
+		*mbo = most_get_mbo(c->iface, c->channel_id, &cdev_comp);
 		if (*mbo)
 			kfifo_in(&c->fifo, mbo, 1);
 	}
@@ -84,7 +84,7 @@ static void stop_channel(struct comp_channel *c)
 
 	while (kfifo_out((struct kfifo *)&c->fifo, &mbo, 1))
 		most_put_mbo(mbo);
-	most_stop_channel(c->iface, c->channel_id, &cdev_aim);
+	most_stop_channel(c->iface, c->channel_id, &cdev_comp);
 }
 
 static void destroy_cdev(struct comp_channel *c)
@@ -143,7 +143,7 @@ static int aim_open(struct inode *inode, struct file *filp)
 	}
 
 	c->mbo_offs = 0;
-	ret = most_start_channel(c->iface, c->channel_id, &cdev_aim);
+	ret = most_start_channel(c->iface, c->channel_id, &cdev_comp);
 	if (!ret)
 		c->access_ref = 1;
 	mutex_unlock(&c->io_mutex);
@@ -489,7 +489,7 @@ static int aim_probe(struct most_interface *iface, int channel_id,
 	return retval;
 }
 
-static struct core_component cdev_aim = {
+static struct core_component cdev_comp = {
 	.name = "cdev",
 	.probe_channel = aim_probe,
 	.disconnect_channel = aim_disconnect_channel,
@@ -512,13 +512,13 @@ static int __init mod_init(void)
 		goto dest_ida;
 	major = MAJOR(comp_devno);
 
-	comp_class = class_create(THIS_MODULE, "most_cdev_aim");
+	comp_class = class_create(THIS_MODULE, "most_cdev_comp");
 	if (IS_ERR(comp_class)) {
 		pr_err("no udev support\n");
 		err = PTR_ERR(comp_class);
 		goto free_cdev;
 	}
-	err = most_register_component(&cdev_aim);
+	err = most_register_component(&cdev_comp);
 	if (err)
 		goto dest_class;
 	return 0;
@@ -538,7 +538,7 @@ static void __exit mod_exit(void)
 
 	pr_info("exit module\n");
 
-	most_deregister_component(&cdev_aim);
+	most_deregister_component(&cdev_comp);
 
 	list_for_each_entry_safe(c, tmp, &channel_list, list) {
 		destroy_cdev(c);

commit eaf03a2875bdd85c3b0cf45cea5844bdf6f2dc79
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Nov 21 15:05:10 2017 +0100

    staging: most: cdev: rename class instance aim_class
    
    This patch renames the instance  aim_class of struct class to comp_class.
    It is needed to complete the process of changing the module designator from
    AIM to Component.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index e39fca614593..dfc6a6abbd54 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -19,7 +19,7 @@
 #include "most/core.h"
 
 static dev_t comp_devno;
-static struct class *aim_class;
+static struct class *comp_class;
 static struct ida minor_id;
 static unsigned int major;
 static struct core_component cdev_aim;
@@ -91,7 +91,7 @@ static void destroy_cdev(struct comp_channel *c)
 {
 	unsigned long flags;
 
-	device_destroy(aim_class, c->devno);
+	device_destroy(comp_class, c->devno);
 	cdev_del(&c->cdev);
 	spin_lock_irqsave(&ch_list_lock, flags);
 	list_del(&c->list);
@@ -464,7 +464,7 @@ static int aim_probe(struct most_interface *iface, int channel_id,
 	spin_lock_irqsave(&ch_list_lock, cl_flags);
 	list_add_tail(&c->list, &channel_list);
 	spin_unlock_irqrestore(&ch_list_lock, cl_flags);
-	c->dev = device_create(aim_class,
+	c->dev = device_create(comp_class,
 				     NULL,
 				     c->devno,
 				     NULL,
@@ -512,10 +512,10 @@ static int __init mod_init(void)
 		goto dest_ida;
 	major = MAJOR(comp_devno);
 
-	aim_class = class_create(THIS_MODULE, "most_cdev_aim");
-	if (IS_ERR(aim_class)) {
+	comp_class = class_create(THIS_MODULE, "most_cdev_aim");
+	if (IS_ERR(comp_class)) {
 		pr_err("no udev support\n");
-		err = PTR_ERR(aim_class);
+		err = PTR_ERR(comp_class);
 		goto free_cdev;
 	}
 	err = most_register_component(&cdev_aim);
@@ -524,7 +524,7 @@ static int __init mod_init(void)
 	return 0;
 
 dest_class:
-	class_destroy(aim_class);
+	class_destroy(comp_class);
 free_cdev:
 	unregister_chrdev_region(comp_devno, 1);
 dest_ida:
@@ -544,7 +544,7 @@ static void __exit mod_exit(void)
 		destroy_cdev(c);
 		destroy_channel(c);
 	}
-	class_destroy(aim_class);
+	class_destroy(comp_class);
 	unregister_chrdev_region(comp_devno, 1);
 	ida_destroy(&minor_id);
 }

commit 90c8d77fcb24d7611cfff5931fcd8f0a3b756c3a
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Nov 21 15:05:09 2017 +0100

    staging: most: cdev: rename variable aim_devno
    
    This patch renames the variable aim_devno to comp_devno. It is needed
    to complete the process of changing the module designator from AIM to
    Component.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 7507b38f8e35..e39fca614593 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -18,7 +18,7 @@
 #include <linux/idr.h>
 #include "most/core.h"
 
-static dev_t aim_devno;
+static dev_t comp_devno;
 static struct class *aim_class;
 static struct ida minor_id;
 static unsigned int major;
@@ -507,10 +507,10 @@ static int __init mod_init(void)
 	spin_lock_init(&ch_list_lock);
 	ida_init(&minor_id);
 
-	err = alloc_chrdev_region(&aim_devno, 0, 50, "cdev");
+	err = alloc_chrdev_region(&comp_devno, 0, 50, "cdev");
 	if (err < 0)
 		goto dest_ida;
-	major = MAJOR(aim_devno);
+	major = MAJOR(comp_devno);
 
 	aim_class = class_create(THIS_MODULE, "most_cdev_aim");
 	if (IS_ERR(aim_class)) {
@@ -526,7 +526,7 @@ static int __init mod_init(void)
 dest_class:
 	class_destroy(aim_class);
 free_cdev:
-	unregister_chrdev_region(aim_devno, 1);
+	unregister_chrdev_region(comp_devno, 1);
 dest_ida:
 	ida_destroy(&minor_id);
 	return err;
@@ -545,7 +545,7 @@ static void __exit mod_exit(void)
 		destroy_channel(c);
 	}
 	class_destroy(aim_class);
-	unregister_chrdev_region(aim_devno, 1);
+	unregister_chrdev_region(comp_devno, 1);
 	ida_destroy(&minor_id);
 }
 

commit ef0fbbbb9a6004af07bbb76aac718dd6dfc2d80e
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Nov 21 15:05:08 2017 +0100

    staging: most: cdev: rename struct aim_channel
    
    This patch renames the structure aim_channel to comp_channel. It is needed
    to complete the process of changing the module designator from AIM to
    Component.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 2447fbfd201e..7507b38f8e35 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -24,7 +24,7 @@ static struct ida minor_id;
 static unsigned int major;
 static struct core_component cdev_aim;
 
-struct aim_channel {
+struct comp_channel {
 	wait_queue_head_t wq;
 	spinlock_t unlink;	/* synchronization lock to unlink channels */
 	struct cdev cdev;
@@ -40,16 +40,16 @@ struct aim_channel {
 	struct list_head list;
 };
 
-#define to_channel(d) container_of(d, struct aim_channel, cdev)
+#define to_channel(d) container_of(d, struct comp_channel, cdev)
 static struct list_head channel_list;
 static spinlock_t ch_list_lock;
 
-static inline bool ch_has_mbo(struct aim_channel *c)
+static inline bool ch_has_mbo(struct comp_channel *c)
 {
 	return channel_has_mbo(c->iface, c->channel_id, &cdev_aim) > 0;
 }
 
-static inline bool ch_get_mbo(struct aim_channel *c, struct mbo **mbo)
+static inline bool ch_get_mbo(struct comp_channel *c, struct mbo **mbo)
 {
 	if (!kfifo_peek(&c->fifo, mbo)) {
 		*mbo = most_get_mbo(c->iface, c->channel_id, &cdev_aim);
@@ -59,9 +59,9 @@ static inline bool ch_get_mbo(struct aim_channel *c, struct mbo **mbo)
 	return *mbo;
 }
 
-static struct aim_channel *get_channel(struct most_interface *iface, int id)
+static struct comp_channel *get_channel(struct most_interface *iface, int id)
 {
-	struct aim_channel *c, *tmp;
+	struct comp_channel *c, *tmp;
 	unsigned long flags;
 	int found_channel = 0;
 
@@ -78,7 +78,7 @@ static struct aim_channel *get_channel(struct most_interface *iface, int id)
 	return c;
 }
 
-static void stop_channel(struct aim_channel *c)
+static void stop_channel(struct comp_channel *c)
 {
 	struct mbo *mbo;
 
@@ -87,7 +87,7 @@ static void stop_channel(struct aim_channel *c)
 	most_stop_channel(c->iface, c->channel_id, &cdev_aim);
 }
 
-static void destroy_cdev(struct aim_channel *c)
+static void destroy_cdev(struct comp_channel *c)
 {
 	unsigned long flags;
 
@@ -98,7 +98,7 @@ static void destroy_cdev(struct aim_channel *c)
 	spin_unlock_irqrestore(&ch_list_lock, flags);
 }
 
-static void destroy_channel(struct aim_channel *c)
+static void destroy_channel(struct comp_channel *c)
 {
 	ida_simple_remove(&minor_id, MINOR(c->devno));
 	kfifo_free(&c->fifo);
@@ -115,7 +115,7 @@ static void destroy_channel(struct aim_channel *c)
  */
 static int aim_open(struct inode *inode, struct file *filp)
 {
-	struct aim_channel *c;
+	struct comp_channel *c;
 	int ret;
 
 	c = to_channel(inode->i_cdev);
@@ -159,7 +159,7 @@ static int aim_open(struct inode *inode, struct file *filp)
  */
 static int aim_close(struct inode *inode, struct file *filp)
 {
-	struct aim_channel *c = to_channel(inode->i_cdev);
+	struct comp_channel *c = to_channel(inode->i_cdev);
 
 	mutex_lock(&c->io_mutex);
 	spin_lock(&c->unlink);
@@ -188,7 +188,7 @@ static ssize_t aim_write(struct file *filp, const char __user *buf,
 	int ret;
 	size_t to_copy, left;
 	struct mbo *mbo = NULL;
-	struct aim_channel *c = filp->private_data;
+	struct comp_channel *c = filp->private_data;
 
 	mutex_lock(&c->io_mutex);
 	while (c->dev && !ch_get_mbo(c, &mbo)) {
@@ -241,7 +241,7 @@ aim_read(struct file *filp, char __user *buf, size_t count, loff_t *offset)
 {
 	size_t to_copy, not_copied, copied;
 	struct mbo *mbo;
-	struct aim_channel *c = filp->private_data;
+	struct comp_channel *c = filp->private_data;
 
 	mutex_lock(&c->io_mutex);
 	while (c->dev && !kfifo_peek(&c->fifo, &mbo)) {
@@ -283,7 +283,7 @@ aim_read(struct file *filp, char __user *buf, size_t count, loff_t *offset)
 
 static unsigned int aim_poll(struct file *filp, poll_table *wait)
 {
-	struct aim_channel *c = filp->private_data;
+	struct comp_channel *c = filp->private_data;
 	unsigned int mask = 0;
 
 	poll_wait(filp, &c->wq, wait);
@@ -320,7 +320,7 @@ static const struct file_operations channel_fops = {
  */
 static int aim_disconnect_channel(struct most_interface *iface, int channel_id)
 {
-	struct aim_channel *c;
+	struct comp_channel *c;
 
 	if (!iface) {
 		pr_info("Bad interface pointer\n");
@@ -356,7 +356,7 @@ static int aim_disconnect_channel(struct most_interface *iface, int channel_id)
  */
 static int aim_rx_completion(struct mbo *mbo)
 {
-	struct aim_channel *c;
+	struct comp_channel *c;
 
 	if (!mbo)
 		return -EINVAL;
@@ -389,7 +389,7 @@ static int aim_rx_completion(struct mbo *mbo)
  */
 static int aim_tx_completion(struct most_interface *iface, int channel_id)
 {
-	struct aim_channel *c;
+	struct comp_channel *c;
 
 	if (!iface) {
 		pr_info("Bad interface pointer\n");
@@ -421,7 +421,7 @@ static int aim_tx_completion(struct most_interface *iface, int channel_id)
 static int aim_probe(struct most_interface *iface, int channel_id,
 		     struct most_channel_config *cfg, char *name)
 {
-	struct aim_channel *c;
+	struct comp_channel *c;
 	unsigned long cl_flags;
 	int retval;
 	int current_minor;
@@ -534,7 +534,7 @@ static int __init mod_init(void)
 
 static void __exit mod_exit(void)
 {
-	struct aim_channel *c, *tmp;
+	struct comp_channel *c, *tmp;
 
 	pr_info("exit module\n");
 

commit ed021a0f8e5b1ac2966a997e908c6a7824da6baa
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Nov 21 15:05:01 2017 +0100

    staging: most: rename functions to register a driver with most_core
    
    This patch renames the functions to register and deregister a component
    module with the core. It is needed because the modules that interface the
    userspace are referred to as components.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index a45a4dcbeb9b..2447fbfd201e 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -518,7 +518,7 @@ static int __init mod_init(void)
 		err = PTR_ERR(aim_class);
 		goto free_cdev;
 	}
-	err = most_register_aim(&cdev_aim);
+	err = most_register_component(&cdev_aim);
 	if (err)
 		goto dest_class;
 	return 0;
@@ -538,7 +538,7 @@ static void __exit mod_exit(void)
 
 	pr_info("exit module\n");
 
-	most_deregister_aim(&cdev_aim);
+	most_deregister_component(&cdev_aim);
 
 	list_for_each_entry_safe(c, tmp, &channel_list, list) {
 		destroy_cdev(c);

commit a12844410c4350305b9ae1c1e0c5d6bd87297e6b
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Nov 21 15:05:00 2017 +0100

    staging: most: rename struct most_aim
    
    The designator of a module that proivdes means to interface userspace is
    called an AIM. Since this name seems to be unappropiate, this kind of
    moduels are going to be referred to as componetns. This is done because
    such modules function as components to enhance the core with new features.
    This patch renames the struct most_aim to core_component.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index cd23db574d5f..a45a4dcbeb9b 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -22,7 +22,7 @@ static dev_t aim_devno;
 static struct class *aim_class;
 static struct ida minor_id;
 static unsigned int major;
-static struct most_aim cdev_aim;
+static struct core_component cdev_aim;
 
 struct aim_channel {
 	wait_queue_head_t wq;
@@ -489,7 +489,7 @@ static int aim_probe(struct most_interface *iface, int channel_id,
 	return retval;
 }
 
-static struct most_aim cdev_aim = {
+static struct core_component cdev_aim = {
 	.name = "cdev",
 	.probe_channel = aim_probe,
 	.disconnect_channel = aim_disconnect_channel,

commit 4d5f022f3a664ee5987118b754058ff31df03835
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Nov 21 15:04:43 2017 +0100

    staging: most: remove proprietary kobjects
    
    This patch removes the proprietary kobjects used by the driver modules and
    replaces them with device structs. The patch is needed to have the driver
    being integrated into the kernel's device model.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
index 3ae9246c0c5c..cd23db574d5f 100644
--- a/drivers/staging/most/cdev/cdev.c
+++ b/drivers/staging/most/cdev/cdev.c
@@ -412,7 +412,6 @@ static int aim_tx_completion(struct most_interface *iface, int channel_id)
  * @iface: pointer to interface instance
  * @channel_id: channel index/ID
  * @cfg: pointer to actual channel configuration
- * @parent: pointer to kobject (needed for sysfs hook-up)
  * @name: name of the device to be created
  *
  * This allocates achannel object and creates the device node in /dev
@@ -420,15 +419,14 @@ static int aim_tx_completion(struct most_interface *iface, int channel_id)
  * Returns 0 on success or error code otherwise.
  */
 static int aim_probe(struct most_interface *iface, int channel_id,
-		     struct most_channel_config *cfg,
-		     struct kobject *parent, char *name)
+		     struct most_channel_config *cfg, char *name)
 {
 	struct aim_channel *c;
 	unsigned long cl_flags;
 	int retval;
 	int current_minor;
 
-	if ((!iface) || (!cfg) || (!parent) || (!name)) {
+	if ((!iface) || (!cfg) || (!name)) {
 		pr_info("Probing AIM with bad arguments");
 		return -EINVAL;
 	}

commit 7b9cdcf6ea8062b4a003b0a06601d94a52f95eeb
Author: Christian Gromm <christian.gromm@microchip.com>
Date:   Tue Nov 21 15:04:36 2017 +0100

    staging: most: cdev: rename module
    
    This patch renames the folder of the cdev module. This is needed
    to clear the directory layout.
    
    Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/most/cdev/cdev.c b/drivers/staging/most/cdev/cdev.c
new file mode 100644
index 000000000000..3ae9246c0c5c
--- /dev/null
+++ b/drivers/staging/most/cdev/cdev.c
@@ -0,0 +1,558 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * cdev.c - Application interfacing module for character devices
+ *
+ * Copyright (C) 2013-2015 Microchip Technology Germany II GmbH & Co. KG
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/poll.h>
+#include <linux/kfifo.h>
+#include <linux/uaccess.h>
+#include <linux/idr.h>
+#include "most/core.h"
+
+static dev_t aim_devno;
+static struct class *aim_class;
+static struct ida minor_id;
+static unsigned int major;
+static struct most_aim cdev_aim;
+
+struct aim_channel {
+	wait_queue_head_t wq;
+	spinlock_t unlink;	/* synchronization lock to unlink channels */
+	struct cdev cdev;
+	struct device *dev;
+	struct mutex io_mutex;
+	struct most_interface *iface;
+	struct most_channel_config *cfg;
+	unsigned int channel_id;
+	dev_t devno;
+	size_t mbo_offs;
+	DECLARE_KFIFO_PTR(fifo, typeof(struct mbo *));
+	int access_ref;
+	struct list_head list;
+};
+
+#define to_channel(d) container_of(d, struct aim_channel, cdev)
+static struct list_head channel_list;
+static spinlock_t ch_list_lock;
+
+static inline bool ch_has_mbo(struct aim_channel *c)
+{
+	return channel_has_mbo(c->iface, c->channel_id, &cdev_aim) > 0;
+}
+
+static inline bool ch_get_mbo(struct aim_channel *c, struct mbo **mbo)
+{
+	if (!kfifo_peek(&c->fifo, mbo)) {
+		*mbo = most_get_mbo(c->iface, c->channel_id, &cdev_aim);
+		if (*mbo)
+			kfifo_in(&c->fifo, mbo, 1);
+	}
+	return *mbo;
+}
+
+static struct aim_channel *get_channel(struct most_interface *iface, int id)
+{
+	struct aim_channel *c, *tmp;
+	unsigned long flags;
+	int found_channel = 0;
+
+	spin_lock_irqsave(&ch_list_lock, flags);
+	list_for_each_entry_safe(c, tmp, &channel_list, list) {
+		if ((c->iface == iface) && (c->channel_id == id)) {
+			found_channel = 1;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&ch_list_lock, flags);
+	if (!found_channel)
+		return NULL;
+	return c;
+}
+
+static void stop_channel(struct aim_channel *c)
+{
+	struct mbo *mbo;
+
+	while (kfifo_out((struct kfifo *)&c->fifo, &mbo, 1))
+		most_put_mbo(mbo);
+	most_stop_channel(c->iface, c->channel_id, &cdev_aim);
+}
+
+static void destroy_cdev(struct aim_channel *c)
+{
+	unsigned long flags;
+
+	device_destroy(aim_class, c->devno);
+	cdev_del(&c->cdev);
+	spin_lock_irqsave(&ch_list_lock, flags);
+	list_del(&c->list);
+	spin_unlock_irqrestore(&ch_list_lock, flags);
+}
+
+static void destroy_channel(struct aim_channel *c)
+{
+	ida_simple_remove(&minor_id, MINOR(c->devno));
+	kfifo_free(&c->fifo);
+	kfree(c);
+}
+
+/**
+ * aim_open - implements the syscall to open the device
+ * @inode: inode pointer
+ * @filp: file pointer
+ *
+ * This stores the channel pointer in the private data field of
+ * the file structure and activates the channel within the core.
+ */
+static int aim_open(struct inode *inode, struct file *filp)
+{
+	struct aim_channel *c;
+	int ret;
+
+	c = to_channel(inode->i_cdev);
+	filp->private_data = c;
+
+	if (((c->cfg->direction == MOST_CH_RX) &&
+	     ((filp->f_flags & O_ACCMODE) != O_RDONLY)) ||
+	     ((c->cfg->direction == MOST_CH_TX) &&
+		((filp->f_flags & O_ACCMODE) != O_WRONLY))) {
+		pr_info("WARN: Access flags mismatch\n");
+		return -EACCES;
+	}
+
+	mutex_lock(&c->io_mutex);
+	if (!c->dev) {
+		pr_info("WARN: Device is destroyed\n");
+		mutex_unlock(&c->io_mutex);
+		return -ENODEV;
+	}
+
+	if (c->access_ref) {
+		pr_info("WARN: Device is busy\n");
+		mutex_unlock(&c->io_mutex);
+		return -EBUSY;
+	}
+
+	c->mbo_offs = 0;
+	ret = most_start_channel(c->iface, c->channel_id, &cdev_aim);
+	if (!ret)
+		c->access_ref = 1;
+	mutex_unlock(&c->io_mutex);
+	return ret;
+}
+
+/**
+ * aim_close - implements the syscall to close the device
+ * @inode: inode pointer
+ * @filp: file pointer
+ *
+ * This stops the channel within the core.
+ */
+static int aim_close(struct inode *inode, struct file *filp)
+{
+	struct aim_channel *c = to_channel(inode->i_cdev);
+
+	mutex_lock(&c->io_mutex);
+	spin_lock(&c->unlink);
+	c->access_ref = 0;
+	spin_unlock(&c->unlink);
+	if (c->dev) {
+		stop_channel(c);
+		mutex_unlock(&c->io_mutex);
+	} else {
+		mutex_unlock(&c->io_mutex);
+		destroy_channel(c);
+	}
+	return 0;
+}
+
+/**
+ * aim_write - implements the syscall to write to the device
+ * @filp: file pointer
+ * @buf: pointer to user buffer
+ * @count: number of bytes to write
+ * @offset: offset from where to start writing
+ */
+static ssize_t aim_write(struct file *filp, const char __user *buf,
+			 size_t count, loff_t *offset)
+{
+	int ret;
+	size_t to_copy, left;
+	struct mbo *mbo = NULL;
+	struct aim_channel *c = filp->private_data;
+
+	mutex_lock(&c->io_mutex);
+	while (c->dev && !ch_get_mbo(c, &mbo)) {
+		mutex_unlock(&c->io_mutex);
+
+		if ((filp->f_flags & O_NONBLOCK))
+			return -EAGAIN;
+		if (wait_event_interruptible(c->wq, ch_has_mbo(c) || !c->dev))
+			return -ERESTARTSYS;
+		mutex_lock(&c->io_mutex);
+	}
+
+	if (unlikely(!c->dev)) {
+		ret = -ENODEV;
+		goto unlock;
+	}
+
+	to_copy = min(count, c->cfg->buffer_size - c->mbo_offs);
+	left = copy_from_user(mbo->virt_address + c->mbo_offs, buf, to_copy);
+	if (left == to_copy) {
+		ret = -EFAULT;
+		goto unlock;
+	}
+
+	c->mbo_offs += to_copy - left;
+	if (c->mbo_offs >= c->cfg->buffer_size ||
+	    c->cfg->data_type == MOST_CH_CONTROL ||
+	    c->cfg->data_type == MOST_CH_ASYNC) {
+		kfifo_skip(&c->fifo);
+		mbo->buffer_length = c->mbo_offs;
+		c->mbo_offs = 0;
+		most_submit_mbo(mbo);
+	}
+
+	ret = to_copy - left;
+unlock:
+	mutex_unlock(&c->io_mutex);
+	return ret;
+}
+
+/**
+ * aim_read - implements the syscall to read from the device
+ * @filp: file pointer
+ * @buf: pointer to user buffer
+ * @count: number of bytes to read
+ * @offset: offset from where to start reading
+ */
+static ssize_t
+aim_read(struct file *filp, char __user *buf, size_t count, loff_t *offset)
+{
+	size_t to_copy, not_copied, copied;
+	struct mbo *mbo;
+	struct aim_channel *c = filp->private_data;
+
+	mutex_lock(&c->io_mutex);
+	while (c->dev && !kfifo_peek(&c->fifo, &mbo)) {
+		mutex_unlock(&c->io_mutex);
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		if (wait_event_interruptible(c->wq,
+					     (!kfifo_is_empty(&c->fifo) ||
+					      (!c->dev))))
+			return -ERESTARTSYS;
+		mutex_lock(&c->io_mutex);
+	}
+
+	/* make sure we don't submit to gone devices */
+	if (unlikely(!c->dev)) {
+		mutex_unlock(&c->io_mutex);
+		return -ENODEV;
+	}
+
+	to_copy = min_t(size_t,
+			count,
+			mbo->processed_length - c->mbo_offs);
+
+	not_copied = copy_to_user(buf,
+				  mbo->virt_address + c->mbo_offs,
+				  to_copy);
+
+	copied = to_copy - not_copied;
+
+	c->mbo_offs += copied;
+	if (c->mbo_offs >= mbo->processed_length) {
+		kfifo_skip(&c->fifo);
+		most_put_mbo(mbo);
+		c->mbo_offs = 0;
+	}
+	mutex_unlock(&c->io_mutex);
+	return copied;
+}
+
+static unsigned int aim_poll(struct file *filp, poll_table *wait)
+{
+	struct aim_channel *c = filp->private_data;
+	unsigned int mask = 0;
+
+	poll_wait(filp, &c->wq, wait);
+
+	if (c->cfg->direction == MOST_CH_RX) {
+		if (!kfifo_is_empty(&c->fifo))
+			mask |= POLLIN | POLLRDNORM;
+	} else {
+		if (!kfifo_is_empty(&c->fifo) || ch_has_mbo(c))
+			mask |= POLLOUT | POLLWRNORM;
+	}
+	return mask;
+}
+
+/**
+ * Initialization of struct file_operations
+ */
+static const struct file_operations channel_fops = {
+	.owner = THIS_MODULE,
+	.read = aim_read,
+	.write = aim_write,
+	.open = aim_open,
+	.release = aim_close,
+	.poll = aim_poll,
+};
+
+/**
+ * aim_disconnect_channel - disconnect a channel
+ * @iface: pointer to interface instance
+ * @channel_id: channel index
+ *
+ * This frees allocated memory and removes the cdev that represents this
+ * channel in user space.
+ */
+static int aim_disconnect_channel(struct most_interface *iface, int channel_id)
+{
+	struct aim_channel *c;
+
+	if (!iface) {
+		pr_info("Bad interface pointer\n");
+		return -EINVAL;
+	}
+
+	c = get_channel(iface, channel_id);
+	if (!c)
+		return -ENXIO;
+
+	mutex_lock(&c->io_mutex);
+	spin_lock(&c->unlink);
+	c->dev = NULL;
+	spin_unlock(&c->unlink);
+	destroy_cdev(c);
+	if (c->access_ref) {
+		stop_channel(c);
+		wake_up_interruptible(&c->wq);
+		mutex_unlock(&c->io_mutex);
+	} else {
+		mutex_unlock(&c->io_mutex);
+		destroy_channel(c);
+	}
+	return 0;
+}
+
+/**
+ * aim_rx_completion - completion handler for rx channels
+ * @mbo: pointer to buffer object that has completed
+ *
+ * This searches for the channel linked to this MBO and stores it in the local
+ * fifo buffer.
+ */
+static int aim_rx_completion(struct mbo *mbo)
+{
+	struct aim_channel *c;
+
+	if (!mbo)
+		return -EINVAL;
+
+	c = get_channel(mbo->ifp, mbo->hdm_channel_id);
+	if (!c)
+		return -ENXIO;
+
+	spin_lock(&c->unlink);
+	if (!c->access_ref || !c->dev) {
+		spin_unlock(&c->unlink);
+		return -ENODEV;
+	}
+	kfifo_in(&c->fifo, &mbo, 1);
+	spin_unlock(&c->unlink);
+#ifdef DEBUG_MESG
+	if (kfifo_is_full(&c->fifo))
+		pr_info("WARN: Fifo is full\n");
+#endif
+	wake_up_interruptible(&c->wq);
+	return 0;
+}
+
+/**
+ * aim_tx_completion - completion handler for tx channels
+ * @iface: pointer to interface instance
+ * @channel_id: channel index/ID
+ *
+ * This wakes sleeping processes in the wait-queue.
+ */
+static int aim_tx_completion(struct most_interface *iface, int channel_id)
+{
+	struct aim_channel *c;
+
+	if (!iface) {
+		pr_info("Bad interface pointer\n");
+		return -EINVAL;
+	}
+	if ((channel_id < 0) || (channel_id >= iface->num_channels)) {
+		pr_info("Channel ID out of range\n");
+		return -EINVAL;
+	}
+
+	c = get_channel(iface, channel_id);
+	if (!c)
+		return -ENXIO;
+	wake_up_interruptible(&c->wq);
+	return 0;
+}
+
+/**
+ * aim_probe - probe function of the driver module
+ * @iface: pointer to interface instance
+ * @channel_id: channel index/ID
+ * @cfg: pointer to actual channel configuration
+ * @parent: pointer to kobject (needed for sysfs hook-up)
+ * @name: name of the device to be created
+ *
+ * This allocates achannel object and creates the device node in /dev
+ *
+ * Returns 0 on success or error code otherwise.
+ */
+static int aim_probe(struct most_interface *iface, int channel_id,
+		     struct most_channel_config *cfg,
+		     struct kobject *parent, char *name)
+{
+	struct aim_channel *c;
+	unsigned long cl_flags;
+	int retval;
+	int current_minor;
+
+	if ((!iface) || (!cfg) || (!parent) || (!name)) {
+		pr_info("Probing AIM with bad arguments");
+		return -EINVAL;
+	}
+	c = get_channel(iface, channel_id);
+	if (c)
+		return -EEXIST;
+
+	current_minor = ida_simple_get(&minor_id, 0, 0, GFP_KERNEL);
+	if (current_minor < 0)
+		return current_minor;
+
+	c = kzalloc(sizeof(*c), GFP_KERNEL);
+	if (!c) {
+		retval = -ENOMEM;
+		goto error_alloc_channel;
+	}
+
+	c->devno = MKDEV(major, current_minor);
+	cdev_init(&c->cdev, &channel_fops);
+	c->cdev.owner = THIS_MODULE;
+	cdev_add(&c->cdev, c->devno, 1);
+	c->iface = iface;
+	c->cfg = cfg;
+	c->channel_id = channel_id;
+	c->access_ref = 0;
+	spin_lock_init(&c->unlink);
+	INIT_KFIFO(c->fifo);
+	retval = kfifo_alloc(&c->fifo, cfg->num_buffers, GFP_KERNEL);
+	if (retval) {
+		pr_info("failed to alloc channel kfifo");
+		goto error_alloc_kfifo;
+	}
+	init_waitqueue_head(&c->wq);
+	mutex_init(&c->io_mutex);
+	spin_lock_irqsave(&ch_list_lock, cl_flags);
+	list_add_tail(&c->list, &channel_list);
+	spin_unlock_irqrestore(&ch_list_lock, cl_flags);
+	c->dev = device_create(aim_class,
+				     NULL,
+				     c->devno,
+				     NULL,
+				     "%s", name);
+
+	if (IS_ERR(c->dev)) {
+		retval = PTR_ERR(c->dev);
+		pr_info("failed to create new device node %s\n", name);
+		goto error_create_device;
+	}
+	kobject_uevent(&c->dev->kobj, KOBJ_ADD);
+	return 0;
+
+error_create_device:
+	kfifo_free(&c->fifo);
+	list_del(&c->list);
+error_alloc_kfifo:
+	cdev_del(&c->cdev);
+	kfree(c);
+error_alloc_channel:
+	ida_simple_remove(&minor_id, current_minor);
+	return retval;
+}
+
+static struct most_aim cdev_aim = {
+	.name = "cdev",
+	.probe_channel = aim_probe,
+	.disconnect_channel = aim_disconnect_channel,
+	.rx_completion = aim_rx_completion,
+	.tx_completion = aim_tx_completion,
+};
+
+static int __init mod_init(void)
+{
+	int err;
+
+	pr_info("init()\n");
+
+	INIT_LIST_HEAD(&channel_list);
+	spin_lock_init(&ch_list_lock);
+	ida_init(&minor_id);
+
+	err = alloc_chrdev_region(&aim_devno, 0, 50, "cdev");
+	if (err < 0)
+		goto dest_ida;
+	major = MAJOR(aim_devno);
+
+	aim_class = class_create(THIS_MODULE, "most_cdev_aim");
+	if (IS_ERR(aim_class)) {
+		pr_err("no udev support\n");
+		err = PTR_ERR(aim_class);
+		goto free_cdev;
+	}
+	err = most_register_aim(&cdev_aim);
+	if (err)
+		goto dest_class;
+	return 0;
+
+dest_class:
+	class_destroy(aim_class);
+free_cdev:
+	unregister_chrdev_region(aim_devno, 1);
+dest_ida:
+	ida_destroy(&minor_id);
+	return err;
+}
+
+static void __exit mod_exit(void)
+{
+	struct aim_channel *c, *tmp;
+
+	pr_info("exit module\n");
+
+	most_deregister_aim(&cdev_aim);
+
+	list_for_each_entry_safe(c, tmp, &channel_list, list) {
+		destroy_cdev(c);
+		destroy_channel(c);
+	}
+	class_destroy(aim_class);
+	unregister_chrdev_region(aim_devno, 1);
+	ida_destroy(&minor_id);
+}
+
+module_init(mod_init);
+module_exit(mod_exit);
+MODULE_AUTHOR("Christian Gromm <christian.gromm@microchip.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("character device AIM for mostcore");
