commit e8014d83f60479d3981baeaa3a21c993ff832f3f
Merge: 41aef04524d3 6a8b55ed4056
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Apr 27 12:20:40 2020 +0200

    Merge 5.7-rc3 into staging-next
    
    We need the staging fixes in here too, and this resolves a merge issue
    with the vt6656 driver.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e3436ce60cf5f5eaedda2b8c622f69feb97595e2
Author: Xiyu Yang <xiyuyang19@fudan.edu.cn>
Date:   Thu Apr 23 13:15:40 2020 +0800

    staging: gasket: Fix mapping refcnt leak when register/store fails
    
    gasket_sysfs_register_store() invokes get_mapping(), which returns a
    reference of the specified gasket_sysfs_mapping object to "mapping" with
    increased refcnt.
    
    When gasket_sysfs_register_store() returns, local variable "mapping"
    becomes invalid, so the refcount should be decreased to keep refcount
    balanced.
    
    The reference counting issue happens in one exception handling path of
    gasket_sysfs_register_store(). When gasket_dev is NULL, the function
    forgets to decrease the refcnt increased by get_mapping(), causing a
    refcnt leak.
    
    Fix this issue by calling put_mapping() when gasket_dev is NULL.
    
    Signed-off-by: Xiyu Yang <xiyuyang19@fudan.edu.cn>
    Signed-off-by: Xin Tan <tanxin.ctf@gmail.com>
    Link: https://lore.kernel.org/r/1587618941-13718-1-git-send-email-xiyuyang19@fudan.edu.cn
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index f24edc38c27b..b4aa8c2ba2c0 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -374,6 +374,7 @@ ssize_t gasket_sysfs_register_store(struct device *device,
 	gasket_dev = mapping->gasket_dev;
 	if (!gasket_dev) {
 		dev_err(device, "Device driver may have been removed\n");
+		put_mapping(mapping);
 		return 0;
 	}
 

commit 57a66838e1494cd881b7f4e110ec685736e8e3ca
Author: Xiyu Yang <xiyuyang19@fudan.edu.cn>
Date:   Thu Apr 23 13:14:55 2020 +0800

    staging: gasket: Fix mapping refcnt leak when put attribute fails
    
    gasket_sysfs_put_attr() invokes get_mapping(), which returns a reference
    of the specified gasket_sysfs_mapping object to "mapping" with increased
    refcnt.
    
    When gasket_sysfs_put_attr() returns, local variable "mapping" becomes
    invalid, so the refcount should be decreased to keep refcount balanced.
    
    The reference counting issue happens in one path of
    gasket_sysfs_put_attr(). When mapping attribute is unknown, the function
    forgets to decrease the refcnt increased by get_mapping(), causing a
    refcnt leak.
    
    Fix this issue by calling put_mapping() when put attribute fails due to
    unknown attribute.
    
    Signed-off-by: Xiyu Yang <xiyuyang19@fudan.edu.cn>
    Signed-off-by: Xin Tan <tanxin.ctf@gmail.com>
    Link: https://lore.kernel.org/r/1587618895-13660-1-git-send-email-xiyuyang19@fudan.edu.cn
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index a2d67c28f530..f24edc38c27b 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -340,6 +340,7 @@ void gasket_sysfs_put_attr(struct device *device,
 
 	dev_err(device, "Unable to put unknown attribute: %s\n",
 		attr->attr.attr.name);
+	put_mapping(mapping);
 }
 EXPORT_SYMBOL(gasket_sysfs_put_attr);
 

commit 9195d762042b0e5e4ded63606b4b30a93cba4400
Author: Luis Mendes <luis.p.mendes@gmail.com>
Date:   Fri Apr 3 16:15:34 2020 +0100

    staging: gasket: Fix incongruency in handling of sysfs entries creation
    
    Fix incongruency in handling of sysfs entries creation.
    This issue could cause invalid memory accesses, by not properly
    detecting the end of the sysfs attributes array.
    
    Fixes: 84c45d5f3bf1 ("staging: gasket: Replace macro __ATTR with __ATTR_NULL")
    Signed-off-by: Luis Mendes <luis.p.mendes@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200403151534.20753-1-luis.p.mendes@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index a2d67c28f530..5f0e089573a2 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -228,8 +228,7 @@ int gasket_sysfs_create_entries(struct device *device,
 	}
 
 	mutex_lock(&mapping->mutex);
-	for (i = 0; strcmp(attrs[i].attr.attr.name, GASKET_ARRAY_END_MARKER);
-		i++) {
+	for (i = 0; attrs[i].attr.attr.name != NULL; i++) {
 		if (mapping->attribute_count == GASKET_SYSFS_MAX_NODES) {
 			dev_err(device,
 				"Maximum number of sysfs nodes reached for device\n");

commit c127e22f4cc1b093c9ee882ddc887b9cb08982d7
Author: Sanjana Sanikommu <sanjana99reddy99@gmail.com>
Date:   Mon Mar 18 21:48:40 2019 +0530

    Staging: gasket: gasket_sysfs.c: Fix string split issue.
    
    Concatenate a multi-line string constant into a single
    line.Issue found by checkpatch.pl.
    
    WARNING:quoted string split across line.
    
    Signed-off-by: Sanjana Sanikommu <sanjana99reddy99@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index fc45f0d13e87..a2d67c28f530 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -223,8 +223,7 @@ int gasket_sysfs_create_entries(struct device *device,
 
 	if (!mapping) {
 		dev_dbg(device,
-			"Creating entries for device without first "
-			"initializing mapping\n");
+			"Creating entries for device without first initializing mapping\n");
 		return -EINVAL;
 	}
 
@@ -233,8 +232,7 @@ int gasket_sysfs_create_entries(struct device *device,
 		i++) {
 		if (mapping->attribute_count == GASKET_SYSFS_MAX_NODES) {
 			dev_err(device,
-				"Maximum number of sysfs nodes reached for "
-				"device\n");
+				"Maximum number of sysfs nodes reached for device\n");
 			mutex_unlock(&mapping->mutex);
 			put_mapping(mapping);
 			return -ENOMEM;
@@ -264,8 +262,7 @@ void gasket_sysfs_remove_mapping(struct device *device)
 
 	if (!mapping) {
 		dev_err(device,
-			"Attempted to remove non-existent sysfs mapping to "
-			"device\n");
+			"Attempted to remove non-existent sysfs mapping to device\n");
 		return;
 	}
 

commit a81d678949471d5b7f399cfcf2e48e0382427805
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:35 2018 -0700

    staging: gasket: sysfs: clean up state if ENOMEM removing mapping
    
    If kcalloc() returns NULL in put_mapping(), continue to clean up state,
    including dropping the reference on the struct device and free attribute
    memory.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index 56d62aea5111..fc45f0d13e87 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -101,13 +101,12 @@ static void put_mapping(struct gasket_sysfs_mapping *mapping)
 		files_to_remove = kcalloc(num_files_to_remove,
 					  sizeof(*files_to_remove),
 					  GFP_KERNEL);
-		if (!files_to_remove) {
-			mutex_unlock(&mapping->mutex);
-			return;
-		}
-
-		for (i = 0; i < num_files_to_remove; i++)
-			files_to_remove[i] = mapping->attributes[i].attr;
+		if (files_to_remove)
+			for (i = 0; i < num_files_to_remove; i++)
+				files_to_remove[i] =
+				    mapping->attributes[i].attr;
+		else
+			num_files_to_remove = 0;
 
 		kfree(mapping->attributes);
 		mapping->attributes = NULL;

commit 548b9f03f007ae654055644cff844b2b4fd2b5d2
Author: Ivan Bornyakov <brnkv.i1@gmail.com>
Date:   Wed Aug 1 21:37:44 2018 +0300

    staging: gasket: sysfs: fix potential null dereference
    
    Add handling of possible allocation failure.
    
    Reported by smatch:
    
      drivers/staging/gasket/gasket_sysfs.c:105 put_mapping() error: potential null dereference 'files_to_remove'. (kcalloc returns null)
    
    Signed-off-by: Ivan Bornyakov <brnkv.i1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index a4bfca43cd03..56d62aea5111 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -101,6 +101,11 @@ static void put_mapping(struct gasket_sysfs_mapping *mapping)
 		files_to_remove = kcalloc(num_files_to_remove,
 					  sizeof(*files_to_remove),
 					  GFP_KERNEL);
+		if (!files_to_remove) {
+			mutex_unlock(&mapping->mutex);
+			return;
+		}
+
 		for (i = 0; i < num_files_to_remove; i++)
 			files_to_remove[i] = mapping->attributes[i].attr;
 

commit 46b77a6b6922113add0a0b9711f5044b1e6aa6a1
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 31 13:24:42 2018 -0700

    staging: gasket: sysfs: fix function param line continuation style
    
    Fix multi-line alignment formatting to look like:
          int ret = long_function_name(device, VARIABLE1, VARIABLE2,
                                       VARIABLE3, VARIABLE4);
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index ef4eca02afa6..a4bfca43cd03 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -145,8 +145,8 @@ void gasket_sysfs_init(void)
 	}
 }
 
-int gasket_sysfs_create_mapping(
-	struct device *device, struct gasket_dev *gasket_dev)
+int gasket_sysfs_create_mapping(struct device *device,
+				struct gasket_dev *gasket_dev)
 {
 	struct gasket_sysfs_mapping *mapping;
 	int map_idx = -1;
@@ -210,8 +210,8 @@ int gasket_sysfs_create_mapping(
 	return 0;
 }
 
-int gasket_sysfs_create_entries(
-	struct device *device, const struct gasket_sysfs_attribute *attrs)
+int gasket_sysfs_create_entries(struct device *device,
+				const struct gasket_sysfs_attribute *attrs)
 {
 	int i;
 	int ret;
@@ -293,8 +293,8 @@ void gasket_sysfs_put_device_data(struct device *device, struct gasket_dev *dev)
 }
 EXPORT_SYMBOL(gasket_sysfs_put_device_data);
 
-struct gasket_sysfs_attribute *gasket_sysfs_get_attr(
-	struct device *device, struct device_attribute *attr)
+struct gasket_sysfs_attribute *
+gasket_sysfs_get_attr(struct device *device, struct device_attribute *attr)
 {
 	int i;
 	int num_attrs;
@@ -317,8 +317,8 @@ struct gasket_sysfs_attribute *gasket_sysfs_get_attr(
 }
 EXPORT_SYMBOL(gasket_sysfs_get_attr);
 
-void gasket_sysfs_put_attr(
-	struct device *device, struct gasket_sysfs_attribute *attr)
+void gasket_sysfs_put_attr(struct device *device,
+			   struct gasket_sysfs_attribute *attr)
 {
 	int i;
 	int num_attrs;
@@ -342,9 +342,9 @@ void gasket_sysfs_put_attr(
 }
 EXPORT_SYMBOL(gasket_sysfs_put_attr);
 
-ssize_t gasket_sysfs_register_store(
-	struct device *device, struct device_attribute *attr, const char *buf,
-	size_t count)
+ssize_t gasket_sysfs_register_store(struct device *device,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
 {
 	ulong parsed_value = 0;
 	struct gasket_sysfs_mapping *mapping;
@@ -386,8 +386,8 @@ ssize_t gasket_sysfs_register_store(
 			    gasket_attr->data.bar_address.offset);
 
 	if (gasket_attr->write_callback)
-		gasket_attr->write_callback(
-			gasket_dev, gasket_attr, parsed_value);
+		gasket_attr->write_callback(gasket_dev, gasket_attr,
+					    parsed_value);
 
 	gasket_sysfs_put_attr(device, gasket_attr);
 	put_mapping(mapping);

commit cef7330217ac56d68b3658af84d1d5d9a5121316
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Jul 29 12:36:43 2018 -0700

    staging: gasket: sysfs: simplify comments for static functions
    
    Static functions don't need kernel doc formatting, can be simplified.
    Reformat comments that can be single-line.  Remove extraneous text.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index fde04658419b..ef4eca02afa6 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -47,22 +47,13 @@ struct gasket_sysfs_mapping {
  */
 static struct gasket_sysfs_mapping dev_mappings[GASKET_SYSFS_NUM_MAPPINGS];
 
-/*
- * Callback when a mapping's refcount goes to zero.
- * @ref: The reference count of the containing sysfs mapping.
- */
+/* Callback when a mapping's refcount goes to zero. */
 static void release_entry(struct kref *ref)
 {
 	/* All work is done after the return from kref_put. */
 }
 
-/*
- * Looks up mapping information for the given device.
- * @device: The device whose mapping to look for.
- *
- * Looks up the requested device and takes a reference and returns it if found,
- * and returns NULL otherwise.
- */
+/* Look up mapping information for the given device. */
 static struct gasket_sysfs_mapping *get_mapping(struct device *device)
 {
 	int i;
@@ -82,17 +73,7 @@ static struct gasket_sysfs_mapping *get_mapping(struct device *device)
 	return NULL;
 }
 
-/*
- * Returns a reference to a mapping.
- * @mapping: The mapping we're returning.
- *
- * Decrements the refcount for the given mapping (if valid). If the refcount is
- * zero, then it cleans up the mapping - in this function as opposed to the
- * kref_put callback, due to a potential deadlock.
- *
- * Although put_mapping_n exists, this function is left here (as an implicit
- * put_mapping_n(..., 1) for convenience.
- */
+/* Put a reference to a mapping. */
 static void put_mapping(struct gasket_sysfs_mapping *mapping)
 {
 	int i;
@@ -140,8 +121,7 @@ static void put_mapping(struct gasket_sysfs_mapping *mapping)
 }
 
 /*
- * Returns a reference N times.
- * @mapping: The mapping to return.
+ * Put a reference to a mapping N times.
  *
  * In higher-level resource acquire/release function pairs, the release function
  * will need to release a mapping 2x - once for the refcount taken in the

commit 34cf3ea8dae7f0aa2ab544c1d30a803016af779e
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Jul 29 12:36:35 2018 -0700

    staging: gasket: sysfs: hold reference to device while in use
    
    Hold a reference to the struct device while a gasket sysfs mapping
    exists for the device and a pointer to the struct is kept in the mapping
    data structures.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index da972ce0e0db..fde04658419b 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -126,6 +126,7 @@ static void put_mapping(struct gasket_sysfs_mapping *mapping)
 		kfree(mapping->attributes);
 		mapping->attributes = NULL;
 		mapping->attribute_count = 0;
+		put_device(mapping->device);
 		mapping->device = NULL;
 		mapping->gasket_dev = NULL;
 	}
@@ -208,22 +209,20 @@ int gasket_sysfs_create_mapping(
 		device->kobj.name);
 
 	mapping = &dev_mappings[map_idx];
-	kref_init(&mapping->refcount);
-	mapping->device = device;
-	mapping->gasket_dev = gasket_dev;
 	mapping->attributes = kcalloc(GASKET_SYSFS_MAX_NODES,
 				      sizeof(*mapping->attributes),
 				      GFP_KERNEL);
-	mapping->attribute_count = 0;
 	if (!mapping->attributes) {
 		dev_dbg(device, "Unable to allocate sysfs attribute array\n");
-		mapping->device = NULL;
-		mapping->gasket_dev = NULL;
 		mutex_unlock(&mapping->mutex);
 		mutex_unlock(&function_mutex);
 		return -ENOMEM;
 	}
 
+	kref_init(&mapping->refcount);
+	mapping->device = get_device(device);
+	mapping->gasket_dev = gasket_dev;
+	mapping->attribute_count = 0;
 	mutex_unlock(&mapping->mutex);
 	mutex_unlock(&function_mutex);
 

commit 14d70229777f17fe3c22deb559821038663bae78
Author: Todd Poynor <toddpoynor@google.com>
Date:   Fri Jul 27 22:21:58 2018 -0700

    staging: gasket: sysfs: remove unnecessary NULL check on device ptr
    
    The device pointer passed into get_mapping() will never be NULL; the
    check is unnecessary.
    
    Reported-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index 2d8647de697c..da972ce0e0db 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -67,11 +67,6 @@ static struct gasket_sysfs_mapping *get_mapping(struct device *device)
 {
 	int i;
 
-	if (!device) {
-		pr_debug("%s: Received NULL device\n", __func__);
-		return NULL;
-	}
-
 	for (i = 0; i < GASKET_SYSFS_NUM_MAPPINGS; i++) {
 		mutex_lock(&dev_mappings[i].mutex);
 		if (dev_mappings[i].device == device) {

commit e7cffa03b34265e17de55d5ef8983c91482643a0
Author: Todd Poynor <toddpoynor@google.com>
Date:   Fri Jul 27 22:21:56 2018 -0700

    staging: gasket: sysfs: remove check for refcount already zero
    
    Remove the check for refcount already zero, which shouldn't be
    necessary.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index 418b81797e63..2d8647de697c 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -111,8 +111,6 @@ static void put_mapping(struct gasket_sysfs_mapping *mapping)
 	}
 
 	mutex_lock(&mapping->mutex);
-	if (refcount_read(&mapping->refcount.refcount) == 0)
-		dev_err(mapping->device, "Refcount is already 0\n");
 	if (kref_put(&mapping->refcount, release_entry)) {
 		dev_dbg(mapping->device, "Removing Gasket sysfs mapping\n");
 		/*

commit 0f647805c070c5d74b91ae1f914d7fabc485cbc8
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 26 20:07:33 2018 -0700

    staging: gasket: sysfs: convert to standard logging
    
    Drop gasket logging calls in favor of standard logging.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index 1c5f7502e0d5..418b81797e63 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -3,7 +3,9 @@
 #include "gasket_sysfs.h"
 
 #include "gasket_core.h"
-#include "gasket_logging.h"
+
+#include <linux/device.h>
+#include <linux/printk.h>
 
 /*
  * Pair of kernel device and user-specified pointer. Used in lookups in sysfs
@@ -66,7 +68,7 @@ static struct gasket_sysfs_mapping *get_mapping(struct device *device)
 	int i;
 
 	if (!device) {
-		gasket_nodev_error("Received NULL device!");
+		pr_debug("%s: Received NULL device\n", __func__);
 		return NULL;
 	}
 
@@ -80,7 +82,8 @@ static struct gasket_sysfs_mapping *get_mapping(struct device *device)
 		mutex_unlock(&dev_mappings[i].mutex);
 	}
 
-	gasket_nodev_info("Mapping to device %s not found.", device->kobj.name);
+	dev_dbg(device, "%s: Mapping to device %s not found\n",
+		__func__, device->kobj.name);
 	return NULL;
 }
 
@@ -103,16 +106,15 @@ static void put_mapping(struct gasket_sysfs_mapping *mapping)
 	struct device *device;
 
 	if (!mapping) {
-		gasket_nodev_info("Mapping should not be NULL.");
+		pr_debug("%s: Mapping should not be NULL\n", __func__);
 		return;
 	}
 
 	mutex_lock(&mapping->mutex);
 	if (refcount_read(&mapping->refcount.refcount) == 0)
-		gasket_nodev_error("Refcount is already 0!");
+		dev_err(mapping->device, "Refcount is already 0\n");
 	if (kref_put(&mapping->refcount, release_entry)) {
-		gasket_nodev_info("Removing Gasket sysfs mapping, device %s",
-				  mapping->device->kobj.name);
+		dev_dbg(mapping->device, "Removing Gasket sysfs mapping\n");
 		/*
 		 * We can't remove the sysfs nodes in the kref callback, since
 		 * device_remove_file() blocks until the node is free.
@@ -182,16 +184,13 @@ int gasket_sysfs_create_mapping(
 	static DEFINE_MUTEX(function_mutex);
 
 	mutex_lock(&function_mutex);
-
-	gasket_nodev_info(
-		"Creating sysfs entries for device pointer 0x%p.", device);
+	dev_dbg(device, "Creating sysfs entries for device\n");
 
 	/* Check that the device we're adding hasn't already been added. */
 	mapping = get_mapping(device);
 	if (mapping) {
-		gasket_nodev_error(
-			"Attempting to re-initialize sysfs mapping for device "
-			"0x%p.", device);
+		dev_err(device,
+			"Attempting to re-initialize sysfs mapping for device\n");
 		put_mapping(mapping);
 		mutex_unlock(&function_mutex);
 		return -EBUSY;
@@ -207,13 +206,13 @@ int gasket_sysfs_create_mapping(
 	}
 
 	if (map_idx == GASKET_SYSFS_NUM_MAPPINGS) {
-		gasket_nodev_error("All mappings have been exhausted!");
+		dev_err(device, "All mappings have been exhausted\n");
 		mutex_unlock(&function_mutex);
 		return -ENOMEM;
 	}
 
-	gasket_nodev_info(
-		"Creating sysfs mapping for device %s.", device->kobj.name);
+	dev_dbg(device, "Creating sysfs mapping for device %s\n",
+		device->kobj.name);
 
 	mapping = &dev_mappings[map_idx];
 	kref_init(&mapping->refcount);
@@ -224,7 +223,7 @@ int gasket_sysfs_create_mapping(
 				      GFP_KERNEL);
 	mapping->attribute_count = 0;
 	if (!mapping->attributes) {
-		gasket_nodev_error("Unable to allocate sysfs attribute array.");
+		dev_dbg(device, "Unable to allocate sysfs attribute array\n");
 		mapping->device = NULL;
 		mapping->gasket_dev = NULL;
 		mutex_unlock(&mapping->mutex);
@@ -247,10 +246,9 @@ int gasket_sysfs_create_entries(
 	struct gasket_sysfs_mapping *mapping = get_mapping(device);
 
 	if (!mapping) {
-		gasket_nodev_error(
-			"Creating entries for device 0x%p without first "
-			"initializing mapping.",
-			device);
+		dev_dbg(device,
+			"Creating entries for device without first "
+			"initializing mapping\n");
 		return -EINVAL;
 	}
 
@@ -258,9 +256,9 @@ int gasket_sysfs_create_entries(
 	for (i = 0; strcmp(attrs[i].attr.attr.name, GASKET_ARRAY_END_MARKER);
 		i++) {
 		if (mapping->attribute_count == GASKET_SYSFS_MAX_NODES) {
-			gasket_nodev_error(
+			dev_err(device,
 				"Maximum number of sysfs nodes reached for "
-				"device.");
+				"device\n");
 			mutex_unlock(&mapping->mutex);
 			put_mapping(mapping);
 			return -ENOMEM;
@@ -268,7 +266,7 @@ int gasket_sysfs_create_entries(
 
 		ret = device_create_file(device, &attrs[i].attr);
 		if (ret) {
-			gasket_nodev_error("Unable to create device entries");
+			dev_dbg(device, "Unable to create device entries\n");
 			mutex_unlock(&mapping->mutex);
 			put_mapping(mapping);
 			return ret;
@@ -289,10 +287,9 @@ void gasket_sysfs_remove_mapping(struct device *device)
 	struct gasket_sysfs_mapping *mapping = get_mapping(device);
 
 	if (!mapping) {
-		gasket_nodev_error(
+		dev_err(device,
 			"Attempted to remove non-existent sysfs mapping to "
-			"device 0x%p",
-			device);
+			"device\n");
 		return;
 	}
 
@@ -304,7 +301,7 @@ struct gasket_dev *gasket_sysfs_get_device_data(struct device *device)
 	struct gasket_sysfs_mapping *mapping = get_mapping(device);
 
 	if (!mapping) {
-		gasket_nodev_error("device %p not registered.", device);
+		dev_err(device, "device not registered\n");
 		return NULL;
 	}
 
@@ -342,8 +339,8 @@ struct gasket_sysfs_attribute *gasket_sysfs_get_attr(
 			return &attrs[i];
 	}
 
-	gasket_nodev_error("Unable to find match for device_attribute %s",
-			   attr->attr.name);
+	dev_err(device, "Unable to find match for device_attribute %s\n",
+		attr->attr.name);
 	return NULL;
 }
 EXPORT_SYMBOL(gasket_sysfs_get_attr);
@@ -368,8 +365,8 @@ void gasket_sysfs_put_attr(
 		}
 	}
 
-	gasket_nodev_error(
-		"Unable to put unknown attribute: %s", attr->attr.attr.name);
+	dev_err(device, "Unable to put unknown attribute: %s\n",
+		attr->attr.attr.name);
 }
 EXPORT_SYMBOL(gasket_sysfs_put_attr);
 
@@ -383,26 +380,26 @@ ssize_t gasket_sysfs_register_store(
 	struct gasket_sysfs_attribute *gasket_attr;
 
 	if (count < 3 || buf[0] != '0' || buf[1] != 'x') {
-		gasket_nodev_error(
-			"sysfs register write format: \"0x<hex value>\".");
+		dev_err(device,
+			"sysfs register write format: \"0x<hex value>\"\n");
 		return -EINVAL;
 	}
 
 	if (kstrtoul(buf, 16, &parsed_value) != 0) {
-		gasket_nodev_error(
-			"Unable to parse input as 64-bit hex value: %s.", buf);
+		dev_err(device,
+			"Unable to parse input as 64-bit hex value: %s\n", buf);
 		return -EINVAL;
 	}
 
 	mapping = get_mapping(device);
 	if (!mapping) {
-		gasket_nodev_info("Device driver may have been removed.");
+		dev_err(device, "Device driver may have been removed\n");
 		return 0;
 	}
 
 	gasket_dev = mapping->gasket_dev;
 	if (!gasket_dev) {
-		gasket_nodev_info("Device driver may have been removed.");
+		dev_err(device, "Device driver may have been removed\n");
 		return 0;
 	}
 

commit 03c25b3ad0405063f8e82871cfaef627dff4d26b
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 17 13:56:48 2018 -0700

    staging: gasket: Remove stale pointers on error allocating attr array
    
    If gasket_sysfs_create_mapping() hits errors allocating the attribute
    array, remove stale pointers to device info from the mapping object.
    
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index dd4d3aaa57e2..1c5f7502e0d5 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -225,6 +225,8 @@ int gasket_sysfs_create_mapping(
 	mapping->attribute_count = 0;
 	if (!mapping->attributes) {
 		gasket_nodev_error("Unable to allocate sysfs attribute array.");
+		mapping->device = NULL;
+		mapping->gasket_dev = NULL;
 		mutex_unlock(&mapping->mutex);
 		mutex_unlock(&function_mutex);
 		return -ENOMEM;

commit cf2865a0c70c645c50d2665ca66228872e225ed0
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 17 13:56:47 2018 -0700

    staging: gasket: Return EBUSY on mapping create when already in use
    
    gasket_sysfs_create_mapping() return EBUSY if sysfs mapping already in
    use, as a more appropriate error code than the current return of EINVAL,
    which would indicate invalid parameters.
    
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index e3d770630961..dd4d3aaa57e2 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -194,7 +194,7 @@ int gasket_sysfs_create_mapping(
 			"0x%p.", device);
 		put_mapping(mapping);
 		mutex_unlock(&function_mutex);
-		return -EINVAL;
+		return -EBUSY;
 	}
 
 	/* Find the first empty entry in the array. */

commit 2e008cd075ba8c2b2212b9e8f3c75d79fa1ee44b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jul 13 10:29:04 2018 +0200

    staging: gasket: sysfs: remove legacy_device field
    
    This field is only ever checked, never actually set, and looks to be
    left-over from some old interface of some sort.  As it's not being used
    at all here, and is just adding to the complexity, delete it.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index 39f9595c85e8..e3d770630961 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -17,9 +17,6 @@ struct gasket_sysfs_mapping {
 	 */
 	struct device *device;
 
-	/* Legacy device struct, if used by this mapping's driver. */
-	struct device *legacy_device;
-
 	/* The Gasket descriptor for this device. */
 	struct gasket_dev *gasket_dev;
 
@@ -75,8 +72,7 @@ static struct gasket_sysfs_mapping *get_mapping(struct device *device)
 
 	for (i = 0; i < GASKET_SYSFS_NUM_MAPPINGS; i++) {
 		mutex_lock(&dev_mappings[i].mutex);
-		if (dev_mappings[i].device == device ||
-		    dev_mappings[i].legacy_device == device) {
+		if (dev_mappings[i].device == device) {
 			kref_get(&dev_mappings[i].refcount);
 			mutex_unlock(&dev_mappings[i].mutex);
 			return &dev_mappings[i];
@@ -105,7 +101,6 @@ static void put_mapping(struct gasket_sysfs_mapping *mapping)
 	int num_files_to_remove = 0;
 	struct device_attribute *files_to_remove;
 	struct device *device;
-	struct device *legacy_device;
 
 	if (!mapping) {
 		gasket_nodev_info("Mapping should not be NULL.");
@@ -126,7 +121,6 @@ static void put_mapping(struct gasket_sysfs_mapping *mapping)
 		 * sysfs nodes are removed outside the lock.
 		 */
 		device = mapping->device;
-		legacy_device = mapping->legacy_device;
 		num_files_to_remove = mapping->attribute_count;
 		files_to_remove = kcalloc(num_files_to_remove,
 					  sizeof(*files_to_remove),
@@ -143,12 +137,8 @@ static void put_mapping(struct gasket_sysfs_mapping *mapping)
 	mutex_unlock(&mapping->mutex);
 
 	if (num_files_to_remove != 0) {
-		for (i = 0; i < num_files_to_remove; ++i) {
+		for (i = 0; i < num_files_to_remove; ++i)
 			device_remove_file(device, &files_to_remove[i]);
-			if (legacy_device)
-				device_remove_file(
-					legacy_device, &files_to_remove[i]);
-		}
 		kfree(files_to_remove);
 	}
 }
@@ -282,21 +272,6 @@ int gasket_sysfs_create_entries(
 			return ret;
 		}
 
-		if (mapping->legacy_device) {
-			ret = device_create_file(mapping->legacy_device,
-						 &attrs[i].attr);
-			if (ret) {
-				gasket_log_error(
-					mapping->gasket_dev,
-					"Unable to create legacy sysfs entries;"
-					" rc: %d",
-					ret);
-				mutex_unlock(&mapping->mutex);
-				put_mapping(mapping);
-				return ret;
-			}
-		}
-
 		mapping->attributes[mapping->attribute_count] = attrs[i];
 		++mapping->attribute_count;
 	}

commit 3adb0e35a4d86b442a55eabfa6ab7b67059e514f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jul 13 10:29:03 2018 +0200

    staging: gasket: remove gasket_sysfs_register_show()
    
    In an attempt to start to clean up the monstrosity of the sysfs abuse in
    the gasket driver, let's remove code that is not used at all.  The
    gasket_sysfs_register_show() function is never used, so delete it.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index 94e55f19b43f..39f9595c85e8 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -396,44 +396,6 @@ void gasket_sysfs_put_attr(
 }
 EXPORT_SYMBOL(gasket_sysfs_put_attr);
 
-ssize_t gasket_sysfs_register_show(
-	struct device *device, struct device_attribute *attr, char *buf)
-{
-	ulong reg_address, reg_bar, reg_value;
-	struct gasket_sysfs_mapping *mapping;
-	struct gasket_dev *gasket_dev;
-	struct gasket_sysfs_attribute *gasket_attr;
-
-	mapping = get_mapping(device);
-	if (!mapping) {
-		gasket_nodev_info("Device driver may have been removed.");
-		return 0;
-	}
-
-	gasket_dev = mapping->gasket_dev;
-	if (!gasket_dev) {
-		gasket_nodev_error(
-			"No sysfs mapping found for device 0x%p", device);
-		put_mapping(mapping);
-		return 0;
-	}
-
-	gasket_attr = gasket_sysfs_get_attr(device, attr);
-	if (!gasket_attr) {
-		put_mapping(mapping);
-		return 0;
-	}
-
-	reg_address = gasket_attr->data.bar_address.offset;
-	reg_bar = gasket_attr->data.bar_address.bar;
-	reg_value = gasket_dev_read_64(gasket_dev, reg_bar, reg_address);
-
-	gasket_sysfs_put_attr(device, gasket_attr);
-	put_mapping(mapping);
-	return snprintf(buf, PAGE_SIZE, "0x%lX\n", reg_value);
-}
-EXPORT_SYMBOL(gasket_sysfs_register_show);
-
 ssize_t gasket_sysfs_register_store(
 	struct device *device, struct device_attribute *attr, const char *buf,
 	size_t count)

commit bf9c7a8673831acd67ad4a92b6acd85ffcde174c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 11 13:39:11 2018 +0200

    staging: gasket: remove redundant license information
    
    Now that the SPDX tag is in all gasket files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index b16ecac87cee..94e55f19b43f 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -1,15 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright (C) 2018 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
+/* Copyright (C) 2018 Google, Inc. */
 #include "gasket_sysfs.h"
 
 #include "gasket_core.h"

commit 2dec0644e0c8083e0a9d3bbdd11aad2d850859e9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 11 13:39:10 2018 +0200

    staging: gasket: add SPDX identifiers to all files.
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the all of the staging gasket files to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index a3705d6e088a..b16ecac87cee 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /* Copyright (C) 2018 Google, Inc.
  *
  * This software is licensed under the terms of the GNU General Public

commit 4cc4dbbc0946c31b0988bb44eea19d759b054351
Author: Todd Poynor <toddpoynor@google.com>
Date:   Fri Jul 6 23:43:10 2018 -0700

    drivers/staging/gasket: Use refcount_read()
    
    Use the refcount_read accessor function, avoid reaching into refcount
    and atomic struct fields.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index 40268fb50fc3..a3705d6e088a 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -122,7 +122,7 @@ static void put_mapping(struct gasket_sysfs_mapping *mapping)
 	}
 
 	mutex_lock(&mapping->mutex);
-	if (mapping->refcount.refcount.refs.counter == 0)
+	if (refcount_read(&mapping->refcount.refcount) == 0)
 		gasket_nodev_error("Refcount is already 0!");
 	if (kref_put(&mapping->refcount, release_entry)) {
 		gasket_nodev_info("Removing Gasket sysfs mapping, device %s",

commit 9f2378d94d0f026389fff351848f2adc484650fe
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 4 10:31:25 2018 -0700

    drivers/staging/gasket: Use 2-factor allocator calls
    
    As already done treewide, switch from open-coded multiplication to using
    2-factor allocator helpers.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
index d45098c90b4b..40268fb50fc3 100644
--- a/drivers/staging/gasket/gasket_sysfs.c
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -137,9 +137,9 @@ static void put_mapping(struct gasket_sysfs_mapping *mapping)
 		device = mapping->device;
 		legacy_device = mapping->legacy_device;
 		num_files_to_remove = mapping->attribute_count;
-		files_to_remove = kzalloc(
-			num_files_to_remove * sizeof(*files_to_remove),
-			GFP_KERNEL);
+		files_to_remove = kcalloc(num_files_to_remove,
+					  sizeof(*files_to_remove),
+					  GFP_KERNEL);
 		for (i = 0; i < num_files_to_remove; i++)
 			files_to_remove[i] = mapping->attributes[i].attr;
 
@@ -238,9 +238,9 @@ int gasket_sysfs_create_mapping(
 	kref_init(&mapping->refcount);
 	mapping->device = device;
 	mapping->gasket_dev = gasket_dev;
-	mapping->attributes = kzalloc(
-		GASKET_SYSFS_MAX_NODES * sizeof(*mapping->attributes),
-		GFP_KERNEL);
+	mapping->attributes = kcalloc(GASKET_SYSFS_MAX_NODES,
+				      sizeof(*mapping->attributes),
+				      GFP_KERNEL);
 	mapping->attribute_count = 0;
 	if (!mapping->attributes) {
 		gasket_nodev_error("Unable to allocate sysfs attribute array.");

commit 9a69f5087ccc20bb411025decab455836df04168
Author: Simon Que <sque@chromium.org>
Date:   Fri Jun 29 22:49:38 2018 -0400

    drivers/staging: Gasket driver framework + Apex driver
    
    The Gasket (Google ASIC Software, Kernel Extensions, and Tools) kernel
    framework is a generic, flexible system that supports thin kernel
    drivers. Gasket kernel drivers are expected to handle opening and
    closing devices, mmap'ing BAR space as requested, a small selection of
    ioctls, and handling page table translation (covered below). Any other
    functions should be handled by userspace code.
    
    The Gasket common module is not enough to run a device. In order to
    customize the Gasket code for a given piece of hardware, a device
    specific module must be created. At a minimum, this module must define a
    struct gasket_driver_desc containing the device-specific data for use by
    the framework; in addition, the module must declare an __init function
    that calls gasket_register_device with the module's gasket_driver_desc
    struct. Finally, the driver must define an exit function that calls
    gasket_unregister_device with the module's gasket_driver_desc struct.
    
    One of the core assumptions of the Gasket framework is that precisely
    one process is allowed to have an open write handle to the device node
    at any given time. (That process may, once it has one write handle, open
    any number of additional write handles.) This is accomplished by
    tracking open and close data for each driver instance.
    
    Signed-off-by: Rob Springer <rspringer@google.com>
    Signed-off-by: John Joseph <jnjoseph@google.com>
    Signed-off-by: Simon Que <sque@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_sysfs.c b/drivers/staging/gasket/gasket_sysfs.c
new file mode 100644
index 000000000000..d45098c90b4b
--- /dev/null
+++ b/drivers/staging/gasket/gasket_sysfs.c
@@ -0,0 +1,497 @@
+/* Copyright (C) 2018 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include "gasket_sysfs.h"
+
+#include "gasket_core.h"
+#include "gasket_logging.h"
+
+/*
+ * Pair of kernel device and user-specified pointer. Used in lookups in sysfs
+ * "show" functions to return user data.
+ */
+
+struct gasket_sysfs_mapping {
+	/*
+	 * The device bound to this mapping. If this is NULL, then this mapping
+	 * is free.
+	 */
+	struct device *device;
+
+	/* Legacy device struct, if used by this mapping's driver. */
+	struct device *legacy_device;
+
+	/* The Gasket descriptor for this device. */
+	struct gasket_dev *gasket_dev;
+
+	/* This device's set of sysfs attributes/nodes. */
+	struct gasket_sysfs_attribute *attributes;
+
+	/* The number of live elements in "attributes". */
+	int attribute_count;
+
+	/* Protects structure from simultaneous access. */
+	struct mutex mutex;
+
+	/* Tracks active users of this mapping. */
+	struct kref refcount;
+};
+
+/*
+ * Data needed to manage users of this sysfs utility.
+ * Currently has a fixed size; if space is a concern, this can be dynamically
+ * allocated.
+ */
+/*
+ * 'Global' (file-scoped) list of mappings between devices and gasket_data
+ * pointers. This removes the requirement to have a gasket_sysfs_data
+ * handle in all files.
+ */
+static struct gasket_sysfs_mapping dev_mappings[GASKET_SYSFS_NUM_MAPPINGS];
+
+/*
+ * Callback when a mapping's refcount goes to zero.
+ * @ref: The reference count of the containing sysfs mapping.
+ */
+static void release_entry(struct kref *ref)
+{
+	/* All work is done after the return from kref_put. */
+}
+
+/*
+ * Looks up mapping information for the given device.
+ * @device: The device whose mapping to look for.
+ *
+ * Looks up the requested device and takes a reference and returns it if found,
+ * and returns NULL otherwise.
+ */
+static struct gasket_sysfs_mapping *get_mapping(struct device *device)
+{
+	int i;
+
+	if (!device) {
+		gasket_nodev_error("Received NULL device!");
+		return NULL;
+	}
+
+	for (i = 0; i < GASKET_SYSFS_NUM_MAPPINGS; i++) {
+		mutex_lock(&dev_mappings[i].mutex);
+		if (dev_mappings[i].device == device ||
+		    dev_mappings[i].legacy_device == device) {
+			kref_get(&dev_mappings[i].refcount);
+			mutex_unlock(&dev_mappings[i].mutex);
+			return &dev_mappings[i];
+		}
+		mutex_unlock(&dev_mappings[i].mutex);
+	}
+
+	gasket_nodev_info("Mapping to device %s not found.", device->kobj.name);
+	return NULL;
+}
+
+/*
+ * Returns a reference to a mapping.
+ * @mapping: The mapping we're returning.
+ *
+ * Decrements the refcount for the given mapping (if valid). If the refcount is
+ * zero, then it cleans up the mapping - in this function as opposed to the
+ * kref_put callback, due to a potential deadlock.
+ *
+ * Although put_mapping_n exists, this function is left here (as an implicit
+ * put_mapping_n(..., 1) for convenience.
+ */
+static void put_mapping(struct gasket_sysfs_mapping *mapping)
+{
+	int i;
+	int num_files_to_remove = 0;
+	struct device_attribute *files_to_remove;
+	struct device *device;
+	struct device *legacy_device;
+
+	if (!mapping) {
+		gasket_nodev_info("Mapping should not be NULL.");
+		return;
+	}
+
+	mutex_lock(&mapping->mutex);
+	if (mapping->refcount.refcount.refs.counter == 0)
+		gasket_nodev_error("Refcount is already 0!");
+	if (kref_put(&mapping->refcount, release_entry)) {
+		gasket_nodev_info("Removing Gasket sysfs mapping, device %s",
+				  mapping->device->kobj.name);
+		/*
+		 * We can't remove the sysfs nodes in the kref callback, since
+		 * device_remove_file() blocks until the node is free.
+		 * Readers/writers of sysfs nodes, though, will be blocked on
+		 * the mapping mutex, resulting in deadlock. To fix this, the
+		 * sysfs nodes are removed outside the lock.
+		 */
+		device = mapping->device;
+		legacy_device = mapping->legacy_device;
+		num_files_to_remove = mapping->attribute_count;
+		files_to_remove = kzalloc(
+			num_files_to_remove * sizeof(*files_to_remove),
+			GFP_KERNEL);
+		for (i = 0; i < num_files_to_remove; i++)
+			files_to_remove[i] = mapping->attributes[i].attr;
+
+		kfree(mapping->attributes);
+		mapping->attributes = NULL;
+		mapping->attribute_count = 0;
+		mapping->device = NULL;
+		mapping->gasket_dev = NULL;
+	}
+	mutex_unlock(&mapping->mutex);
+
+	if (num_files_to_remove != 0) {
+		for (i = 0; i < num_files_to_remove; ++i) {
+			device_remove_file(device, &files_to_remove[i]);
+			if (legacy_device)
+				device_remove_file(
+					legacy_device, &files_to_remove[i]);
+		}
+		kfree(files_to_remove);
+	}
+}
+
+/*
+ * Returns a reference N times.
+ * @mapping: The mapping to return.
+ *
+ * In higher-level resource acquire/release function pairs, the release function
+ * will need to release a mapping 2x - once for the refcount taken in the
+ * release function itself, and once for the count taken in the acquire call.
+ */
+static void put_mapping_n(struct gasket_sysfs_mapping *mapping, int times)
+{
+	int i;
+
+	for (i = 0; i < times; i++)
+		put_mapping(mapping);
+}
+
+void gasket_sysfs_init(void)
+{
+	int i;
+
+	for (i = 0; i < GASKET_SYSFS_NUM_MAPPINGS; i++) {
+		dev_mappings[i].device = NULL;
+		mutex_init(&dev_mappings[i].mutex);
+	}
+}
+
+int gasket_sysfs_create_mapping(
+	struct device *device, struct gasket_dev *gasket_dev)
+{
+	struct gasket_sysfs_mapping *mapping;
+	int map_idx = -1;
+
+	/*
+	 * We need a function-level mutex to protect against the same device
+	 * being added [multiple times] simultaneously.
+	 */
+	static DEFINE_MUTEX(function_mutex);
+
+	mutex_lock(&function_mutex);
+
+	gasket_nodev_info(
+		"Creating sysfs entries for device pointer 0x%p.", device);
+
+	/* Check that the device we're adding hasn't already been added. */
+	mapping = get_mapping(device);
+	if (mapping) {
+		gasket_nodev_error(
+			"Attempting to re-initialize sysfs mapping for device "
+			"0x%p.", device);
+		put_mapping(mapping);
+		mutex_unlock(&function_mutex);
+		return -EINVAL;
+	}
+
+	/* Find the first empty entry in the array. */
+	for (map_idx = 0; map_idx < GASKET_SYSFS_NUM_MAPPINGS; ++map_idx) {
+		mutex_lock(&dev_mappings[map_idx].mutex);
+		if (!dev_mappings[map_idx].device)
+			/* Break with the mutex held! */
+			break;
+		mutex_unlock(&dev_mappings[map_idx].mutex);
+	}
+
+	if (map_idx == GASKET_SYSFS_NUM_MAPPINGS) {
+		gasket_nodev_error("All mappings have been exhausted!");
+		mutex_unlock(&function_mutex);
+		return -ENOMEM;
+	}
+
+	gasket_nodev_info(
+		"Creating sysfs mapping for device %s.", device->kobj.name);
+
+	mapping = &dev_mappings[map_idx];
+	kref_init(&mapping->refcount);
+	mapping->device = device;
+	mapping->gasket_dev = gasket_dev;
+	mapping->attributes = kzalloc(
+		GASKET_SYSFS_MAX_NODES * sizeof(*mapping->attributes),
+		GFP_KERNEL);
+	mapping->attribute_count = 0;
+	if (!mapping->attributes) {
+		gasket_nodev_error("Unable to allocate sysfs attribute array.");
+		mutex_unlock(&mapping->mutex);
+		mutex_unlock(&function_mutex);
+		return -ENOMEM;
+	}
+
+	mutex_unlock(&mapping->mutex);
+	mutex_unlock(&function_mutex);
+
+	/* Don't decrement the refcount here! One open count keeps it alive! */
+	return 0;
+}
+
+int gasket_sysfs_create_entries(
+	struct device *device, const struct gasket_sysfs_attribute *attrs)
+{
+	int i;
+	int ret;
+	struct gasket_sysfs_mapping *mapping = get_mapping(device);
+
+	if (!mapping) {
+		gasket_nodev_error(
+			"Creating entries for device 0x%p without first "
+			"initializing mapping.",
+			device);
+		return -EINVAL;
+	}
+
+	mutex_lock(&mapping->mutex);
+	for (i = 0; strcmp(attrs[i].attr.attr.name, GASKET_ARRAY_END_MARKER);
+		i++) {
+		if (mapping->attribute_count == GASKET_SYSFS_MAX_NODES) {
+			gasket_nodev_error(
+				"Maximum number of sysfs nodes reached for "
+				"device.");
+			mutex_unlock(&mapping->mutex);
+			put_mapping(mapping);
+			return -ENOMEM;
+		}
+
+		ret = device_create_file(device, &attrs[i].attr);
+		if (ret) {
+			gasket_nodev_error("Unable to create device entries");
+			mutex_unlock(&mapping->mutex);
+			put_mapping(mapping);
+			return ret;
+		}
+
+		if (mapping->legacy_device) {
+			ret = device_create_file(mapping->legacy_device,
+						 &attrs[i].attr);
+			if (ret) {
+				gasket_log_error(
+					mapping->gasket_dev,
+					"Unable to create legacy sysfs entries;"
+					" rc: %d",
+					ret);
+				mutex_unlock(&mapping->mutex);
+				put_mapping(mapping);
+				return ret;
+			}
+		}
+
+		mapping->attributes[mapping->attribute_count] = attrs[i];
+		++mapping->attribute_count;
+	}
+
+	mutex_unlock(&mapping->mutex);
+	put_mapping(mapping);
+	return 0;
+}
+EXPORT_SYMBOL(gasket_sysfs_create_entries);
+
+void gasket_sysfs_remove_mapping(struct device *device)
+{
+	struct gasket_sysfs_mapping *mapping = get_mapping(device);
+
+	if (!mapping) {
+		gasket_nodev_error(
+			"Attempted to remove non-existent sysfs mapping to "
+			"device 0x%p",
+			device);
+		return;
+	}
+
+	put_mapping_n(mapping, 2);
+}
+
+struct gasket_dev *gasket_sysfs_get_device_data(struct device *device)
+{
+	struct gasket_sysfs_mapping *mapping = get_mapping(device);
+
+	if (!mapping) {
+		gasket_nodev_error("device %p not registered.", device);
+		return NULL;
+	}
+
+	return mapping->gasket_dev;
+}
+EXPORT_SYMBOL(gasket_sysfs_get_device_data);
+
+void gasket_sysfs_put_device_data(struct device *device, struct gasket_dev *dev)
+{
+	struct gasket_sysfs_mapping *mapping = get_mapping(device);
+
+	if (!mapping)
+		return;
+
+	/* See comment of put_mapping_n() for why the '2' is necessary. */
+	put_mapping_n(mapping, 2);
+}
+EXPORT_SYMBOL(gasket_sysfs_put_device_data);
+
+struct gasket_sysfs_attribute *gasket_sysfs_get_attr(
+	struct device *device, struct device_attribute *attr)
+{
+	int i;
+	int num_attrs;
+	struct gasket_sysfs_mapping *mapping = get_mapping(device);
+	struct gasket_sysfs_attribute *attrs = NULL;
+
+	if (!mapping)
+		return NULL;
+
+	attrs = mapping->attributes;
+	num_attrs = mapping->attribute_count;
+	for (i = 0; i < num_attrs; ++i) {
+		if (!strcmp(attrs[i].attr.attr.name, attr->attr.name))
+			return &attrs[i];
+	}
+
+	gasket_nodev_error("Unable to find match for device_attribute %s",
+			   attr->attr.name);
+	return NULL;
+}
+EXPORT_SYMBOL(gasket_sysfs_get_attr);
+
+void gasket_sysfs_put_attr(
+	struct device *device, struct gasket_sysfs_attribute *attr)
+{
+	int i;
+	int num_attrs;
+	struct gasket_sysfs_mapping *mapping = get_mapping(device);
+	struct gasket_sysfs_attribute *attrs = NULL;
+
+	if (!mapping)
+		return;
+
+	attrs = mapping->attributes;
+	num_attrs = mapping->attribute_count;
+	for (i = 0; i < num_attrs; ++i) {
+		if (&attrs[i] == attr) {
+			put_mapping_n(mapping, 2);
+			return;
+		}
+	}
+
+	gasket_nodev_error(
+		"Unable to put unknown attribute: %s", attr->attr.attr.name);
+}
+EXPORT_SYMBOL(gasket_sysfs_put_attr);
+
+ssize_t gasket_sysfs_register_show(
+	struct device *device, struct device_attribute *attr, char *buf)
+{
+	ulong reg_address, reg_bar, reg_value;
+	struct gasket_sysfs_mapping *mapping;
+	struct gasket_dev *gasket_dev;
+	struct gasket_sysfs_attribute *gasket_attr;
+
+	mapping = get_mapping(device);
+	if (!mapping) {
+		gasket_nodev_info("Device driver may have been removed.");
+		return 0;
+	}
+
+	gasket_dev = mapping->gasket_dev;
+	if (!gasket_dev) {
+		gasket_nodev_error(
+			"No sysfs mapping found for device 0x%p", device);
+		put_mapping(mapping);
+		return 0;
+	}
+
+	gasket_attr = gasket_sysfs_get_attr(device, attr);
+	if (!gasket_attr) {
+		put_mapping(mapping);
+		return 0;
+	}
+
+	reg_address = gasket_attr->data.bar_address.offset;
+	reg_bar = gasket_attr->data.bar_address.bar;
+	reg_value = gasket_dev_read_64(gasket_dev, reg_bar, reg_address);
+
+	gasket_sysfs_put_attr(device, gasket_attr);
+	put_mapping(mapping);
+	return snprintf(buf, PAGE_SIZE, "0x%lX\n", reg_value);
+}
+EXPORT_SYMBOL(gasket_sysfs_register_show);
+
+ssize_t gasket_sysfs_register_store(
+	struct device *device, struct device_attribute *attr, const char *buf,
+	size_t count)
+{
+	ulong parsed_value = 0;
+	struct gasket_sysfs_mapping *mapping;
+	struct gasket_dev *gasket_dev;
+	struct gasket_sysfs_attribute *gasket_attr;
+
+	if (count < 3 || buf[0] != '0' || buf[1] != 'x') {
+		gasket_nodev_error(
+			"sysfs register write format: \"0x<hex value>\".");
+		return -EINVAL;
+	}
+
+	if (kstrtoul(buf, 16, &parsed_value) != 0) {
+		gasket_nodev_error(
+			"Unable to parse input as 64-bit hex value: %s.", buf);
+		return -EINVAL;
+	}
+
+	mapping = get_mapping(device);
+	if (!mapping) {
+		gasket_nodev_info("Device driver may have been removed.");
+		return 0;
+	}
+
+	gasket_dev = mapping->gasket_dev;
+	if (!gasket_dev) {
+		gasket_nodev_info("Device driver may have been removed.");
+		return 0;
+	}
+
+	gasket_attr = gasket_sysfs_get_attr(device, attr);
+	if (!gasket_attr) {
+		put_mapping(mapping);
+		return count;
+	}
+
+	gasket_dev_write_64(gasket_dev, parsed_value,
+			    gasket_attr->data.bar_address.bar,
+			    gasket_attr->data.bar_address.offset);
+
+	if (gasket_attr->write_callback)
+		gasket_attr->write_callback(
+			gasket_dev, gasket_attr, parsed_value);
+
+	gasket_sysfs_put_attr(device, gasket_attr);
+	put_mapping(mapping);
+	return count;
+}
+EXPORT_SYMBOL(gasket_sysfs_register_store);
