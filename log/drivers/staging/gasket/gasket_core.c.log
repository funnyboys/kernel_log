commit 769acc3656d93aaacada814939743361d284fd87
Author: Oscar Carter <oscar.carter@gmx.com>
Date:   Fri May 1 17:51:18 2020 +0200

    staging: gasket: Check the return value of gasket_get_bar_index()
    
    Check the return value of gasket_get_bar_index function as it can return
    a negative one (-EINVAL). If this happens, a negative index is used in
    the "gasket_dev->bar_data" array.
    
    Addresses-Coverity-ID: 1438542 ("Negative array index read")
    Fixes: 9a69f5087ccc2 ("drivers/staging: Gasket driver framework + Apex driver")
    Signed-off-by: Oscar Carter <oscar.carter@gmx.com>
    Cc: stable <stable@vger.kernel.org>
    Reviewed-by: Richard Yeh <rcy@google.com>
    Link: https://lore.kernel.org/r/20200501155118.13380-1-oscar.carter@gmx.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 8e0575fcb4c8..67325fbaf760 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -925,6 +925,10 @@ do_map_region(const struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
 		gasket_get_bar_index(gasket_dev,
 				     (vma->vm_pgoff << PAGE_SHIFT) +
 				     driver_desc->legacy_mmap_address_offset);
+
+	if (bar_index < 0)
+		return DO_MAP_REGION_INVALID;
+
 	phys_base = gasket_dev->bar_data[bar_index].phys_base + phys_offset;
 	while (mapped_bytes < map_length) {
 		/*

commit 6cb4d9a2870d2062e34c93bfef4d52fca3fe42d1
Author: Anshuman Khandual <anshuman.khandual@arm.com>
Date:   Fri Apr 10 14:33:09 2020 -0700

    mm/vma: introduce VM_ACCESS_FLAGS
    
    There are many places where all basic VMA access flags (read, write,
    exec) are initialized or checked against as a group.  One such example
    is during page fault.  Existing vma_is_accessible() wrapper already
    creates the notion of VMA accessibility as a group access permissions.
    
    Hence lets just create VM_ACCESS_FLAGS (VM_READ|VM_WRITE|VM_EXEC) which
    will not only reduce code duplication but also extend the VMA
    accessibility concept in general.
    
    Signed-off-by: Anshuman Khandual <anshuman.khandual@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Vlastimil Babka <vbabka@suse.cz>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Rob Springer <rspringer@google.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Link: http://lkml.kernel.org/r/1583391014-8170-3-git-send-email-anshuman.khandual@arm.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index cd181a64f737..8e0575fcb4c8 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -689,7 +689,7 @@ static bool gasket_mmap_has_permissions(struct gasket_dev *gasket_dev,
 
 	/* Make sure that no wrong flags are set. */
 	requested_permissions =
-		(vma->vm_flags & (VM_WRITE | VM_READ | VM_EXEC));
+		(vma->vm_flags & VM_ACCESS_FLAGS);
 	if (requested_permissions & ~(bar_permissions)) {
 		dev_dbg(gasket_dev->dev,
 			"Attempting to map a region with requested permissions 0x%x, but region has permissions 0x%x.\n",

commit 0e35fa615e0baf5d95dafc4362b349b8406676ab
Author: Kaaira Gupta <kgupta@es.iitr.ac.in>
Date:   Wed Feb 12 23:28:26 2020 +0530

    staging: gasket: unify multi-line string
    
    Fix three checkpatch.pl warnings of 'quoted string split across lines'
    in gasket_core.c by merging the strings in one line.
    Though some strings
    are over 80 characters long, fixing this warning is necessary to ease
    grep-ing the source for printk.
    
    Signed-off-by: Kaaira Gupta <kgupta@es.iitr.ac.in>
    Link: https://lore.kernel.org/r/20200212175826.GA5967@kaaira-HP-Pavilion-Notebook
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index be6b50f454b4..cd181a64f737 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -692,8 +692,7 @@ static bool gasket_mmap_has_permissions(struct gasket_dev *gasket_dev,
 		(vma->vm_flags & (VM_WRITE | VM_READ | VM_EXEC));
 	if (requested_permissions & ~(bar_permissions)) {
 		dev_dbg(gasket_dev->dev,
-			"Attempting to map a region with requested permissions "
-			"0x%x, but region has permissions 0x%x.\n",
+			"Attempting to map a region with requested permissions 0x%x, but region has permissions 0x%x.\n",
 			requested_permissions, bar_permissions);
 		return false;
 	}
@@ -1180,8 +1179,7 @@ static int gasket_open(struct inode *inode, struct file *filp)
 	inode->i_size = 0;
 
 	dev_dbg(gasket_dev->dev,
-		"Attempting to open with tgid %u (%s) (f_mode: 0%03o, "
-		"fmode_write: %d is_root: %u)\n",
+		"Attempting to open with tgid %u (%s) (f_mode: 0%03o, fmode_write: %d is_root: %u)\n",
 		current->tgid, task_name, filp->f_mode,
 		(filp->f_mode & FMODE_WRITE), is_root);
 
@@ -1258,8 +1256,7 @@ static int gasket_release(struct inode *inode, struct file *file)
 	mutex_lock(&gasket_dev->mutex);
 
 	dev_dbg(gasket_dev->dev,
-		"Releasing device node. Call origin: tgid %u (%s) "
-		"(f_mode: 0%03o, fmode_write: %d, is_root: %u)\n",
+		"Releasing device node. Call origin: tgid %u (%s) (f_mode: 0%03o, fmode_write: %d, is_root: %u)\n",
 		current->tgid, task_name, file->f_mode,
 		(file->f_mode & FMODE_WRITE), is_root);
 	dev_dbg(gasket_dev->dev, "Current open count (owning tgid %u): %d\n",

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index cd8be80d2076..be6b50f454b4 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -303,7 +303,7 @@ static int gasket_map_pci_bar(struct gasket_dev *gasket_dev, int bar_num)
 	}
 
 	gasket_dev->bar_data[bar_num].virt_base =
-		ioremap_nocache(gasket_dev->bar_data[bar_num].phys_base,
+		ioremap(gasket_dev->bar_data[bar_num].phys_base,
 				gasket_dev->bar_data[bar_num].length_bytes);
 	if (!gasket_dev->bar_data[bar_num].virt_base) {
 		dev_err(gasket_dev->dev,

commit c9c13ba428ef90a9b408a6cdf874e14ab5754516
Author: Denis Efremov <efremov@linux.com>
Date:   Sat Sep 28 02:43:08 2019 +0300

    PCI: Add PCI_STD_NUM_BARS for the number of standard BARs
    
    Code that iterates over all standard PCI BARs typically uses
    PCI_STD_RESOURCE_END.  However, that requires the unusual test
    "i <= PCI_STD_RESOURCE_END" rather than something the typical
    "i < PCI_STD_NUM_BARS".
    
    Add a definition for PCI_STD_NUM_BARS and change loops to use the more
    idiomatic C style to help avoid fencepost errors.
    
    Link: https://lore.kernel.org/r/20190927234026.23342-1-efremov@linux.com
    Link: https://lore.kernel.org/r/20190927234308.23935-1-efremov@linux.com
    Link: https://lore.kernel.org/r/20190916204158.6889-3-efremov@linux.com
    Signed-off-by: Denis Efremov <efremov@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Sebastian Ott <sebott@linux.ibm.com>                  # arch/s390/
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>  # video/fbdev/
    Acked-by: Gustavo Pimentel <gustavo.pimentel@synopsys.com>      # pci/controller/dwc/
    Acked-by: Jack Wang <jinpu.wang@cloud.ionos.com>                # scsi/pm8001/
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>       # scsi/pm8001/
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>                  # memstick/

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 13179f063a61..cd8be80d2076 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -371,7 +371,7 @@ static int gasket_setup_pci(struct pci_dev *pci_dev,
 {
 	int i, mapped_bars, ret;
 
-	for (i = 0; i < GASKET_NUM_BARS; i++) {
+	for (i = 0; i < PCI_STD_NUM_BARS; i++) {
 		ret = gasket_map_pci_bar(gasket_dev, i);
 		if (ret) {
 			mapped_bars = i;
@@ -393,7 +393,7 @@ static void gasket_cleanup_pci(struct gasket_dev *gasket_dev)
 {
 	int i;
 
-	for (i = 0; i < GASKET_NUM_BARS; i++)
+	for (i = 0; i < PCI_STD_NUM_BARS; i++)
 		gasket_unmap_pci_bar(gasket_dev, i);
 }
 
@@ -493,7 +493,7 @@ static ssize_t gasket_sysfs_data_show(struct device *device,
 		(enum gasket_sysfs_attribute_type)gasket_attr->data.attr_type;
 	switch (sysfs_type) {
 	case ATTR_BAR_OFFSETS:
-		for (i = 0; i < GASKET_NUM_BARS; i++) {
+		for (i = 0; i < PCI_STD_NUM_BARS; i++) {
 			bar_desc = &driver_desc->bar_descriptions[i];
 			if (bar_desc->size == 0)
 				continue;
@@ -505,7 +505,7 @@ static ssize_t gasket_sysfs_data_show(struct device *device,
 		}
 		break;
 	case ATTR_BAR_SIZES:
-		for (i = 0; i < GASKET_NUM_BARS; i++) {
+		for (i = 0; i < PCI_STD_NUM_BARS; i++) {
 			bar_desc = &driver_desc->bar_descriptions[i];
 			if (bar_desc->size == 0)
 				continue;
@@ -556,7 +556,7 @@ static ssize_t gasket_sysfs_data_show(struct device *device,
 		ret = snprintf(buf, PAGE_SIZE, "%d\n", gasket_dev->reset_count);
 		break;
 	case ATTR_USER_MEM_RANGES:
-		for (i = 0; i < GASKET_NUM_BARS; ++i) {
+		for (i = 0; i < PCI_STD_NUM_BARS; ++i) {
 			current_written =
 				gasket_write_mappable_regions(buf, driver_desc,
 							      i);
@@ -736,7 +736,7 @@ static int gasket_get_bar_index(const struct gasket_dev *gasket_dev,
 	const struct gasket_driver_desc *driver_desc;
 
 	driver_desc = gasket_dev->internal_desc->driver_desc;
-	for (i = 0; i < GASKET_NUM_BARS; ++i) {
+	for (i = 0; i < PCI_STD_NUM_BARS; ++i) {
 		struct gasket_bar_desc bar_desc =
 			driver_desc->bar_descriptions[i];
 

commit 1b96f846db31e18e062ae4eb9e22ae58d6588c2f
Author: Tianzheng Li <ltz0302@gmail.com>
Date:   Fri May 24 13:31:05 2019 +0200

    staging/gasket: Fix string split
    
    This patch removes unnecessary quoted string splits.
    
    Co-developed-by: Jie Zhang <zhangjie.cnde@gmail.com>
    Signed-off-by: Jie Zhang <zhangjie.cnde@gmail.com>
    Signed-off-by: Tianzheng Li <ltz0302@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index a445d58fb399..13179f063a61 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -702,8 +702,7 @@ static bool gasket_mmap_has_permissions(struct gasket_dev *gasket_dev,
 	if ((vma->vm_flags & VM_WRITE) &&
 	    !gasket_owned_by_current_tgid(&gasket_dev->dev_info)) {
 		dev_dbg(gasket_dev->dev,
-			"Attempting to mmap a region for write without owning "
-			"device.\n");
+			"Attempting to mmap a region for write without owning device.\n");
 		return false;
 	}
 
@@ -1054,8 +1053,7 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	}
 	if (bar_index > 0 && is_coherent_region) {
 		dev_err(gasket_dev->dev,
-			"double matching bar and coherent buffers for address "
-			"0x%lx\n",
+			"double matching bar and coherent buffers for address 0x%lx\n",
 			raw_offset);
 		trace_gasket_mmap_exit(bar_index);
 		return -EINVAL;

commit 8ae925f02553240a4c15a1e80a6dfc5c0fa95e67
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Oct 16 05:03:07 2018 -0700

    staging: gasket: remove debug logs for callback invocation
    
    Debug logs for device-specific callback invocation aren't very useful,
    remove.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index f230bec76ae4..a445d58fb399 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -109,8 +109,6 @@ check_and_invoke_callback(struct gasket_dev *gasket_dev,
 {
 	int ret = 0;
 
-	dev_dbg(gasket_dev->dev, "check_and_invoke_callback %p\n",
-		cb_function);
 	if (cb_function) {
 		mutex_lock(&gasket_dev->mutex);
 		ret = cb_function(gasket_dev);
@@ -126,11 +124,8 @@ gasket_check_and_invoke_callback_nolock(struct gasket_dev *gasket_dev,
 {
 	int ret = 0;
 
-	if (cb_function) {
-		dev_dbg(gasket_dev->dev,
-			"Invoking device-specific callback.\n");
+	if (cb_function)
 		ret = cb_function(gasket_dev);
-	}
 	return ret;
 }
 

commit 8b872d6f06c20d58058afb457cc266c578c431b2
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:21:10 2018 -0700

    staging: gasket: interrupt: simplify interrupt init parameters
    
    Pass the gasket driver descriptor to the interrupt init function, rather
    than exploding out separate parameters from various fields of that
    structure.  This allows us to make more localized changes to the types
    of interrupts supported (MSIX vs. wire, etc.) without affecting the
    calling sequence, and seems nicer for simplification purposes.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 99f3f11d75ce..f230bec76ae4 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1357,13 +1357,7 @@ int gasket_enable_device(struct gasket_dev *gasket_dev)
 	const struct gasket_driver_desc *driver_desc =
 		gasket_dev->internal_desc->driver_desc;
 
-	ret = gasket_interrupt_init(gasket_dev, driver_desc->name,
-				    driver_desc->interrupt_type,
-				    driver_desc->interrupts,
-				    driver_desc->num_interrupts,
-				    driver_desc->interrupt_pack_width,
-				    driver_desc->interrupt_bar_index,
-				    driver_desc->wire_interrupt_offsets);
+	ret = gasket_interrupt_init(gasket_dev);
 	if (ret) {
 		dev_err(gasket_dev->dev,
 			"Critical failure to allocate interrupts: %d\n", ret);

commit 97fead8c90961390902ec7a9780775b9e87908bc
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:21:08 2018 -0700

    staging: gasket: core: rename lookup_internal_desc to be PCI-specific
    
    Rename lookup_internal_desc() to lookup_pci_internal_desc() to reflect
    use for PCI devices only, in prep for non-PCI devices in the future.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 5e048f6e16e1..99f3f11d75ce 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -651,13 +651,13 @@ void gasket_disable_device(struct gasket_dev *gasket_dev)
 EXPORT_SYMBOL(gasket_disable_device);
 
 /*
- * Registered descriptor lookup.
+ * Registered driver descriptor lookup for PCI devices.
  *
  * Precondition: Called with g_mutex held (to avoid a race on return).
  * Returns NULL if no matching device was found.
  */
 static struct gasket_internal_desc *
-lookup_internal_desc(struct pci_dev *pci_dev)
+lookup_pci_internal_desc(struct pci_dev *pci_dev)
 {
 	int i;
 
@@ -1488,7 +1488,7 @@ int gasket_pci_add_device(struct pci_dev *pci_dev,
 	dev_dbg(&pci_dev->dev, "add PCI gasket device\n");
 
 	mutex_lock(&g_mutex);
-	internal_desc = lookup_internal_desc(pci_dev);
+	internal_desc = lookup_pci_internal_desc(pci_dev);
 	mutex_unlock(&g_mutex);
 	if (!internal_desc) {
 		dev_err(&pci_dev->dev,
@@ -1536,7 +1536,7 @@ void gasket_pci_remove_device(struct pci_dev *pci_dev)
 	struct gasket_dev *gasket_dev = NULL;
 	/* Find the device desc. */
 	mutex_lock(&g_mutex);
-	internal_desc = lookup_internal_desc(pci_dev);
+	internal_desc = lookup_pci_internal_desc(pci_dev);
 	if (!internal_desc) {
 		mutex_unlock(&g_mutex);
 		return;

commit 1fb5e1c92e7d81497da3627671e119b44cb7a175
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:21:07 2018 -0700

    staging: gasket: core: factor out generic device remove code from PCI
    
    Separate code for generic parts of gasket device removal sequence from
    the PCI device removal code, in prep for non-PCI devices later.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index ce8ae226f82d..5e048f6e16e1 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1461,6 +1461,14 @@ static int __gasket_add_device(struct device *parent_dev,
 	return ret;
 }
 
+static void __gasket_remove_device(struct gasket_internal_desc *internal_desc,
+				   struct gasket_dev *gasket_dev)
+{
+	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
+	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
+	gasket_free_dev(gasket_dev);
+}
+
 /*
  * Add PCI gasket device.
  *
@@ -1515,9 +1523,7 @@ int gasket_pci_add_device(struct pci_dev *pci_dev,
 
 cleanup_pci:
 	gasket_cleanup_pci(gasket_dev);
-	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
-	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
-	gasket_free_dev(gasket_dev);
+	__gasket_remove_device(internal_desc, gasket_dev);
 	return ret;
 }
 EXPORT_SYMBOL(gasket_pci_add_device);
@@ -1528,7 +1534,6 @@ void gasket_pci_remove_device(struct pci_dev *pci_dev)
 	int i;
 	struct gasket_internal_desc *internal_desc;
 	struct gasket_dev *gasket_dev = NULL;
-	const struct gasket_driver_desc *driver_desc;
 	/* Find the device desc. */
 	mutex_lock(&g_mutex);
 	internal_desc = lookup_internal_desc(pci_dev);
@@ -1538,8 +1543,6 @@ void gasket_pci_remove_device(struct pci_dev *pci_dev)
 	}
 	mutex_unlock(&g_mutex);
 
-	driver_desc = internal_desc->driver_desc;
-
 	/* Now find the specific device */
 	mutex_lock(&internal_desc->mutex);
 	for (i = 0; i < GASKET_DEV_MAX; i++) {
@@ -1558,10 +1561,7 @@ void gasket_pci_remove_device(struct pci_dev *pci_dev)
 		internal_desc->driver_desc->name);
 
 	gasket_cleanup_pci(gasket_dev);
-
-	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
-	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
-	gasket_free_dev(gasket_dev);
+	__gasket_remove_device(internal_desc, gasket_dev);
 }
 EXPORT_SYMBOL(gasket_pci_remove_device);
 

commit 9c34e95c6f03f581dcb3a209ea475972fcb67998
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:21:06 2018 -0700

    staging: gasket: core: factor out generic device add code from PCI code
    
    Split out generic gasket device add code from the code for adding a PCI
    gasket device, in prep for other gasket device types in the future.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index aee819f379e9..ce8ae226f82d 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1419,6 +1419,48 @@ int gasket_enable_device(struct gasket_dev *gasket_dev)
 }
 EXPORT_SYMBOL(gasket_enable_device);
 
+static int __gasket_add_device(struct device *parent_dev,
+			       struct gasket_internal_desc *internal_desc,
+			       struct gasket_dev **gasket_devp)
+{
+	int ret;
+	struct gasket_dev *gasket_dev;
+	const struct gasket_driver_desc *driver_desc =
+	    internal_desc->driver_desc;
+
+	ret = gasket_alloc_dev(internal_desc, parent_dev, &gasket_dev);
+	if (ret)
+		return ret;
+	if (IS_ERR(gasket_dev->dev_info.device)) {
+		dev_err(parent_dev, "Cannot create %s device %s [ret = %ld]\n",
+			driver_desc->name, gasket_dev->dev_info.name,
+			PTR_ERR(gasket_dev->dev_info.device));
+		ret = -ENODEV;
+		goto free_gasket_dev;
+	}
+
+	ret = gasket_sysfs_create_mapping(gasket_dev->dev_info.device,
+					  gasket_dev);
+	if (ret)
+		goto remove_device;
+
+	ret = gasket_sysfs_create_entries(gasket_dev->dev_info.device,
+					  gasket_sysfs_generic_attrs);
+	if (ret)
+		goto remove_sysfs_mapping;
+
+	*gasket_devp = gasket_dev;
+	return 0;
+
+remove_sysfs_mapping:
+	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
+remove_device:
+	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
+free_gasket_dev:
+	gasket_free_dev(gasket_dev);
+	return ret;
+}
+
 /*
  * Add PCI gasket device.
  *
@@ -1433,7 +1475,6 @@ int gasket_pci_add_device(struct pci_dev *pci_dev,
 	int ret;
 	struct gasket_internal_desc *internal_desc;
 	struct gasket_dev *gasket_dev;
-	const struct gasket_driver_desc *driver_desc;
 	struct device *parent;
 
 	dev_dbg(&pci_dev->dev, "add PCI gasket device\n");
@@ -1447,29 +1488,15 @@ int gasket_pci_add_device(struct pci_dev *pci_dev,
 		return -ENODEV;
 	}
 
-	driver_desc = internal_desc->driver_desc;
-
 	parent = &pci_dev->dev;
-	ret = gasket_alloc_dev(internal_desc, parent, &gasket_dev);
+	ret = __gasket_add_device(parent, internal_desc, &gasket_dev);
 	if (ret)
 		return ret;
-	gasket_dev->pci_dev = pci_dev;
-	if (IS_ERR_OR_NULL(gasket_dev->dev_info.device)) {
-		pr_err("Cannot create %s device %s [ret = %ld]\n",
-		       driver_desc->name, gasket_dev->dev_info.name,
-		       PTR_ERR(gasket_dev->dev_info.device));
-		ret = -ENODEV;
-		goto fail1;
-	}
 
+	gasket_dev->pci_dev = pci_dev;
 	ret = gasket_setup_pci(pci_dev, gasket_dev);
 	if (ret)
-		goto fail2;
-
-	ret = gasket_sysfs_create_mapping(gasket_dev->dev_info.device,
-					  gasket_dev);
-	if (ret)
-		goto fail3;
+		goto cleanup_pci;
 
 	/*
 	 * Once we've created the mapping structures successfully, attempt to
@@ -1480,23 +1507,16 @@ int gasket_pci_add_device(struct pci_dev *pci_dev,
 	if (ret) {
 		dev_err(gasket_dev->dev,
 			"Cannot create sysfs pci link: %d\n", ret);
-		goto fail3;
+		goto cleanup_pci;
 	}
-	ret = gasket_sysfs_create_entries(gasket_dev->dev_info.device,
-					  gasket_sysfs_generic_attrs);
-	if (ret)
-		goto fail4;
 
 	*gasket_devp = gasket_dev;
 	return 0;
 
-fail4:
-fail3:
-	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
-fail2:
+cleanup_pci:
 	gasket_cleanup_pci(gasket_dev);
+	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
 	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
-fail1:
 	gasket_free_dev(gasket_dev);
 	return ret;
 }

commit 1fdd6d720cdc31b569189f6c534250b9deb1152d
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:21:01 2018 -0700

    staging: gasket: remove gasket_exit()
    
    Remove now-empty gasket_exit() function.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 0fe5b86b294c..aee819f379e9 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1801,12 +1801,8 @@ static int __init gasket_init(void)
 	return 0;
 }
 
-static void __exit gasket_exit(void)
-{
-}
 MODULE_DESCRIPTION("Google Gasket driver framework");
 MODULE_VERSION(GASKET_FRAMEWORK_VERSION);
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Rob Springer <rspringer@google.com>");
 module_init(gasket_init);
-module_exit(gasket_exit);

commit 1fb227bf2ed2834fb0a3e9baf5aba34a19b111f6
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:21:00 2018 -0700

    staging: gasket: core: remove ftrace-style debug logs
    
    Remove debug logs that only indicate the name of the entered function,
    in favor of using ftrace for function tracing style logs.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 5f54b3615f67..0fe5b86b294c 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1789,7 +1789,6 @@ static int __init gasket_init(void)
 {
 	int i;
 
-	pr_debug("%s\n", __func__);
 	mutex_lock(&g_mutex);
 	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
 		g_descs[i].driver_desc = NULL;
@@ -1804,7 +1803,6 @@ static int __init gasket_init(void)
 
 static void __exit gasket_exit(void)
 {
-	pr_debug("%s\n", __func__);
 }
 MODULE_DESCRIPTION("Google Gasket driver framework");
 MODULE_VERSION(GASKET_FRAMEWORK_VERSION);

commit 57db4be3bbe45bdbd0b073ed6048e86830ded865
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:20:59 2018 -0700

    staging: gasket: core: remove kobj_name param from gasket_alloc_dev
    
    gasket_alloc_dev can retrieve the device name from the parent parameter,
    a separate parameter isn't needed for this.  Rename the variable to
    better reflect its meaning, as the name of the parent device for which a
    gasket device is being allocated.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 3fb805204d70..5f54b3615f67 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -189,26 +189,26 @@ static int gasket_find_dev_slot(struct gasket_internal_desc *internal_desc,
  * Returns 0 if successful, a negative error code otherwise.
  */
 static int gasket_alloc_dev(struct gasket_internal_desc *internal_desc,
-			    struct device *parent, struct gasket_dev **pdev,
-			    const char *kobj_name)
+			    struct device *parent, struct gasket_dev **pdev)
 {
 	int dev_idx;
 	const struct gasket_driver_desc *driver_desc =
 		internal_desc->driver_desc;
 	struct gasket_dev *gasket_dev;
 	struct gasket_cdev_info *dev_info;
+	const char *parent_name = dev_name(parent);
 
-	pr_debug("Allocating a Gasket device %s.\n", kobj_name);
+	pr_debug("Allocating a Gasket device, parent %s.\n", parent_name);
 
 	*pdev = NULL;
 
-	dev_idx = gasket_find_dev_slot(internal_desc, kobj_name);
+	dev_idx = gasket_find_dev_slot(internal_desc, parent_name);
 	if (dev_idx < 0)
 		return dev_idx;
 
 	gasket_dev = *pdev = kzalloc(sizeof(*gasket_dev), GFP_KERNEL);
 	if (!gasket_dev) {
-		pr_err("no memory for device %s\n", kobj_name);
+		pr_err("no memory for device, parent %s\n", parent_name);
 		return -ENOMEM;
 	}
 	internal_desc->devs[dev_idx] = gasket_dev;
@@ -217,7 +217,7 @@ static int gasket_alloc_dev(struct gasket_internal_desc *internal_desc,
 
 	gasket_dev->internal_desc = internal_desc;
 	gasket_dev->dev_idx = dev_idx;
-	snprintf(gasket_dev->kobj_name, GASKET_NAME_MAX, "%s", kobj_name);
+	snprintf(gasket_dev->kobj_name, GASKET_NAME_MAX, "%s", parent_name);
 	gasket_dev->dev = get_device(parent);
 	/* gasket_bar_data is uninitialized. */
 	gasket_dev->num_page_tables = driver_desc->num_page_tables;
@@ -1431,13 +1431,12 @@ int gasket_pci_add_device(struct pci_dev *pci_dev,
 			  struct gasket_dev **gasket_devp)
 {
 	int ret;
-	const char *kobj_name = dev_name(&pci_dev->dev);
 	struct gasket_internal_desc *internal_desc;
 	struct gasket_dev *gasket_dev;
 	const struct gasket_driver_desc *driver_desc;
 	struct device *parent;
 
-	pr_debug("add PCI device %s\n", kobj_name);
+	dev_dbg(&pci_dev->dev, "add PCI gasket device\n");
 
 	mutex_lock(&g_mutex);
 	internal_desc = lookup_internal_desc(pci_dev);
@@ -1451,7 +1450,7 @@ int gasket_pci_add_device(struct pci_dev *pci_dev,
 	driver_desc = internal_desc->driver_desc;
 
 	parent = &pci_dev->dev;
-	ret = gasket_alloc_dev(internal_desc, parent, &gasket_dev, kobj_name);
+	ret = gasket_alloc_dev(internal_desc, parent, &gasket_dev);
 	if (ret)
 		return ret;
 	gasket_dev->pci_dev = pci_dev;

commit c5e0a62ad80aac638f222e8d574f0994c4425f30
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:20:58 2018 -0700

    staging: gasket: core: fix line continuation indent in gasket_alloc_dev
    
    Previous cleanups missed a case of multi-line function call with line
    continuation parameters not aligned per kernel style.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 37d14e30ffa2..3fb805204d70 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -231,8 +231,9 @@ static int gasket_alloc_dev(struct gasket_internal_desc *internal_desc,
 	dev_info->devt =
 		MKDEV(driver_desc->major, driver_desc->minor +
 		      gasket_dev->dev_idx);
-	dev_info->device = device_create(internal_desc->class, parent,
-		dev_info->devt, gasket_dev, dev_info->name);
+	dev_info->device =
+		device_create(internal_desc->class, parent, dev_info->devt,
+			      gasket_dev, dev_info->name);
 
 	/* cdev has not yet been added; cdev_added is 0 */
 	dev_info->gasket_dev_ptr = gasket_dev;

commit 4cfc2bff29cadf9c0df9723adbce1fce7ee33281
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:20:57 2018 -0700

    staging: gasket: core: remove debug log that could crash
    
    A debug log in gasket_alloc_dev() is issued regardless of whether the
    device pointer used returned success or error.  The log isn't that
    useful anyway, remove it.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Reviewed-by: Rob Springer <rspringer@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index d12ab560411f..37d14e30ffa2 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -234,8 +234,6 @@ static int gasket_alloc_dev(struct gasket_internal_desc *internal_desc,
 	dev_info->device = device_create(internal_desc->class, parent,
 		dev_info->devt, gasket_dev, dev_info->name);
 
-	dev_dbg(dev_info->device, "Gasket device allocated.\n");
-
 	/* cdev has not yet been added; cdev_added is 0 */
 	dev_info->gasket_dev_ptr = gasket_dev;
 	/* ownership is all 0, indicating no owner or opens. */

commit d37d2dd41f7ad0bc0996e600727480ffaaad6fd3
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:49 2018 -0700

    staging: gasket: core: remove incorrect extraneous comment
    
    A copy-and-pasted comment from another code sequence is removed from
    gasket core init sequence.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index a6462b6d702f..d12ab560411f 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1792,7 +1792,6 @@ static int __init gasket_init(void)
 	int i;
 
 	pr_debug("%s\n", __func__);
-	/* Check for duplicates and find a free slot. */
 	mutex_lock(&g_mutex);
 	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
 		g_descs[i].driver_desc = NULL;

commit 95a2c279b2c7c2e59977d5b0773a15ba26b7ce4b
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:47 2018 -0700

    staging: gasket: core: protect against races during unregister
    
    Keep mutex held across the unregistration operation, until the
    driver_desc field of the global table is removed, to prevent a
    concurrent accessor from looking up the driver_desc while
    gasket_unregister_device() is in the processing of removing it.
    
    Reported-by: Guenter Roeck <groeck@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index ace92f107ed5..a6462b6d702f 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1765,9 +1765,9 @@ void gasket_unregister_device(const struct gasket_driver_desc *driver_desc)
 			break;
 		}
 	}
-	mutex_unlock(&g_mutex);
 
 	if (!internal_desc) {
+		mutex_unlock(&g_mutex);
 		pr_err("request to unregister unknown desc: %s, %d:%d\n",
 		       driver_desc->name, driver_desc->major,
 		       driver_desc->minor);
@@ -1780,7 +1780,6 @@ void gasket_unregister_device(const struct gasket_driver_desc *driver_desc)
 	class_destroy(internal_desc->class);
 
 	/* Finally, effectively "remove" the driver. */
-	mutex_lock(&g_mutex);
 	g_descs[desc_idx].driver_desc = NULL;
 	mutex_unlock(&g_mutex);
 

commit 565eeedaa0c1b2b0d8abd3845e349de29065a5d2
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:45 2018 -0700

    staging: gasket: core: remove sysfs setup and cleanup callbacks
    
    Gasket device drivers now call into the gasket framework to initialize
    and de-initialize, rather than the other way around.  The calling code
    can perform sysfs setup and cleanup actions without callbacks from the
    framework.  Remove the sysfs setup and cleanup callbacks.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 0d76e18fcde5..ace92f107ed5 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1489,18 +1489,9 @@ int gasket_pci_add_device(struct pci_dev *pci_dev,
 	if (ret)
 		goto fail4;
 
-	ret = check_and_invoke_callback(gasket_dev,
-					driver_desc->sysfs_setup_cb);
-	if (ret) {
-		dev_err(gasket_dev->dev, "Error in sysfs setup cb: %d\n", ret);
-		goto fail5;
-	}
-
 	*gasket_devp = gasket_dev;
 	return 0;
 
-fail5:
-	check_and_invoke_callback(gasket_dev, driver_desc->sysfs_cleanup_cb);
 fail4:
 fail3:
 	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
@@ -1550,7 +1541,6 @@ void gasket_pci_remove_device(struct pci_dev *pci_dev)
 
 	gasket_cleanup_pci(gasket_dev);
 
-	check_and_invoke_callback(gasket_dev, driver_desc->sysfs_cleanup_cb);
 	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
 	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
 	gasket_free_dev(gasket_dev);

commit 4420ea9366a5df61cbb0bb2ad827ff6391904f56
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:43 2018 -0700

    staging: gasket: core: delete device add and remove callbacks
    
    Gasket device drivers are now in charge of orchestrating the device add
    and removal sequences, so the callbacks from the framework to the device
    drivers for these events are no longer needed.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index fad4883e6332..0d76e18fcde5 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1468,12 +1468,6 @@ int gasket_pci_add_device(struct pci_dev *pci_dev,
 	if (ret)
 		goto fail2;
 
-	ret = check_and_invoke_callback(gasket_dev, driver_desc->add_dev_cb);
-	if (ret) {
-		dev_err(gasket_dev->dev, "Error in add device cb: %d\n", ret);
-		goto fail2;
-	}
-
 	ret = gasket_sysfs_create_mapping(gasket_dev->dev_info.device,
 					  gasket_dev);
 	if (ret)
@@ -1512,7 +1506,6 @@ int gasket_pci_add_device(struct pci_dev *pci_dev,
 	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
 fail2:
 	gasket_cleanup_pci(gasket_dev);
-	check_and_invoke_callback(gasket_dev, driver_desc->remove_dev_cb);
 	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
 fail1:
 	gasket_free_dev(gasket_dev);
@@ -1559,9 +1552,6 @@ void gasket_pci_remove_device(struct pci_dev *pci_dev)
 
 	check_and_invoke_callback(gasket_dev, driver_desc->sysfs_cleanup_cb);
 	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
-
-	check_and_invoke_callback(gasket_dev, driver_desc->remove_dev_cb);
-
 	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
 	gasket_free_dev(gasket_dev);
 }

commit 39091410d0d8eeb07f3b08ff4e44400ccd434762
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:41 2018 -0700

    staging: gasket: core: let device driver enable/disable gasket device
    
    Move gasket device enable/disable functions from internal calls to
    external calls from the gasket device drivers.  The device driver will
    call these functions at appropriate times in its processing, placing
    the device driver in control of this sequence and reducing the need for
    callbacks from framework back to the device drivers during the
    enable/disable sequences.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index b070efaf0d41..fad4883e6332 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -628,7 +628,7 @@ static int gasket_add_cdev(struct gasket_cdev_info *dev_info,
 }
 
 /* Disable device operations. */
-static void gasket_disable_dev(struct gasket_dev *gasket_dev)
+void gasket_disable_device(struct gasket_dev *gasket_dev)
 {
 	const struct gasket_driver_desc *driver_desc =
 		gasket_dev->internal_desc->driver_desc;
@@ -649,6 +649,7 @@ static void gasket_disable_dev(struct gasket_dev *gasket_dev)
 		}
 	}
 }
+EXPORT_SYMBOL(gasket_disable_device);
 
 /*
  * Registered descriptor lookup.
@@ -1350,13 +1351,12 @@ static const struct file_operations gasket_file_ops = {
 };
 
 /* Perform final init and marks the device as active. */
-static int gasket_enable_dev(struct gasket_internal_desc *internal_desc,
-			     struct gasket_dev *gasket_dev)
+int gasket_enable_device(struct gasket_dev *gasket_dev)
 {
 	int tbl_idx;
 	int ret;
 	const struct gasket_driver_desc *driver_desc =
-		internal_desc->driver_desc;
+		gasket_dev->internal_desc->driver_desc;
 
 	ret = gasket_interrupt_init(gasket_dev, driver_desc->name,
 				    driver_desc->interrupt_type,
@@ -1418,13 +1418,15 @@ static int gasket_enable_dev(struct gasket_internal_desc *internal_desc,
 
 	return 0;
 }
+EXPORT_SYMBOL(gasket_enable_device);
 
 /*
  * Add PCI gasket device.
  *
  * Called by Gasket device probe function.
- * Allocates device metadata, maps device memory, and calls gasket_enable_dev
- * to prepare the device for active use.
+ * Allocates device metadata and maps device memory.  The device driver must
+ * call gasket_enable_device after driver init is complete to place the device
+ * in active use.
  */
 int gasket_pci_add_device(struct pci_dev *pci_dev,
 			  struct gasket_dev **gasket_devp)
@@ -1500,13 +1502,6 @@ int gasket_pci_add_device(struct pci_dev *pci_dev,
 		goto fail5;
 	}
 
-	ret = gasket_enable_dev(internal_desc, gasket_dev);
-	if (ret) {
-		pr_err("cannot setup %s device\n", driver_desc->name);
-		gasket_disable_dev(gasket_dev);
-		goto fail5;
-	}
-
 	*gasket_devp = gasket_dev;
 	return 0;
 
@@ -1560,7 +1555,6 @@ void gasket_pci_remove_device(struct pci_dev *pci_dev)
 	dev_dbg(gasket_dev->dev, "remove %s PCI gasket device\n",
 		internal_desc->driver_desc->name);
 
-	gasket_disable_dev(gasket_dev);
 	gasket_cleanup_pci(gasket_dev);
 
 	check_and_invoke_callback(gasket_dev, driver_desc->sysfs_cleanup_cb);

commit 1b25e6e81aab048107ed20c218c2b04261fd94ec
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:39 2018 -0700

    staging: gasket: core: remove device enable and disable callbacks
    
    Device enable/disable operations are moving from being initiated through
    the gasket framework to being initiated by the gasket device driver.
    The driver can perform any processing needed for these operations before
    or after the calls into the framework.  Neither of these callbacks are
    implemented for the only gasket driver upstream today, apex.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 2741256eacfe..b070efaf0d41 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -648,8 +648,6 @@ static void gasket_disable_dev(struct gasket_dev *gasket_dev)
 			gasket_page_table_cleanup(gasket_dev->page_table[i]);
 		}
 	}
-
-	check_and_invoke_callback(gasket_dev, driver_desc->disable_dev_cb);
 }
 
 /*
@@ -1408,13 +1406,6 @@ static int gasket_enable_dev(struct gasket_internal_desc *internal_desc,
 	}
 	gasket_dev->hardware_revision = ret;
 
-	ret = check_and_invoke_callback(gasket_dev, driver_desc->enable_dev_cb);
-	if (ret) {
-		dev_err(gasket_dev->dev, "Error in enable device cb: %d\n",
-			ret);
-		return ret;
-	}
-
 	/* device_status_cb returns a device status, not an error code. */
 	gasket_dev->status = gasket_get_hw_status(gasket_dev);
 	if (gasket_dev->status == GASKET_STATUS_DEAD)

commit c75e2bb32fd04ebcdeaa907144027c0b9c416f05
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:38 2018 -0700

    staging: gasket: core: convert remaining info logs to debug
    
    Remaining info-level logs in gasket core converted to debug-level; the
    information is not needed during normal system operation.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 01cafe1ff660..2741256eacfe 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1819,7 +1819,7 @@ void gasket_unregister_device(const struct gasket_driver_desc *driver_desc)
 	g_descs[desc_idx].driver_desc = NULL;
 	mutex_unlock(&g_mutex);
 
-	pr_info("removed %s driver\n", driver_desc->name);
+	pr_debug("removed %s driver\n", driver_desc->name);
 }
 EXPORT_SYMBOL(gasket_unregister_device);
 
@@ -1827,7 +1827,7 @@ static int __init gasket_init(void)
 {
 	int i;
 
-	pr_info("Performing one-time init of the Gasket framework.\n");
+	pr_debug("%s\n", __func__);
 	/* Check for duplicates and find a free slot. */
 	mutex_lock(&g_mutex);
 	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
@@ -1843,8 +1843,7 @@ static int __init gasket_init(void)
 
 static void __exit gasket_exit(void)
 {
-	/* No deinit/dealloc needed at present. */
-	pr_info("Removing Gasket framework module.\n");
+	pr_debug("%s\n", __func__);
 }
 MODULE_DESCRIPTION("Google Gasket driver framework");
 MODULE_VERSION(GASKET_FRAMEWORK_VERSION);

commit b7072b24fa61f42c356ffdfaa0544065d6f1c23b
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:36 2018 -0700

    staging: gasket: core: move core PCI calls to device drivers
    
    Remove gasket wrapping of PCI probe, enable, disable, and remove
    functions.  Replace with calls to add and remove PCI gasket devices,
    to be called by the gasket device drivers.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 2d209e36cf37..01cafe1ff660 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -51,9 +51,6 @@ struct gasket_internal_desc {
 	/* Kernel-internal device class. */
 	struct class *class;
 
-	/* PCI subsystem metadata associated with this driver. */
-	struct pci_driver pci;
-
 	/* Instantiated / present devices of this type. */
 	struct gasket_dev *devs[GASKET_DEV_MAX];
 };
@@ -368,10 +365,10 @@ static void gasket_unmap_pci_bar(struct gasket_dev *dev, int bar_num)
 }
 
 /*
- * Setup PCI & set up memory mapping for the specified device.
+ * Setup PCI memory mapping for the specified device.
  *
- * Enables the PCI device, reads the BAR registers and sets up pointers to the
- * device's memory mapped IO space.
+ * Reads the BAR registers and sets up pointers to the device's memory mapped
+ * IO space.
  *
  * Returns 0 on success and a negative value otherwise.
  */
@@ -380,14 +377,6 @@ static int gasket_setup_pci(struct pci_dev *pci_dev,
 {
 	int i, mapped_bars, ret;
 
-	ret = pci_enable_device(pci_dev);
-	if (ret) {
-		dev_err(gasket_dev->dev, "cannot enable PCI device\n");
-		return ret;
-	}
-
-	pci_set_master(pci_dev);
-
 	for (i = 0; i < GASKET_NUM_BARS; i++) {
 		ret = gasket_map_pci_bar(gasket_dev, i);
 		if (ret) {
@@ -402,19 +391,16 @@ static int gasket_setup_pci(struct pci_dev *pci_dev,
 	for (i = 0; i < mapped_bars; i++)
 		gasket_unmap_pci_bar(gasket_dev, i);
 
-	pci_disable_device(pci_dev);
 	return -ENOMEM;
 }
 
-/* Unmaps memory and cleans up PCI for the specified device. */
+/* Unmaps memory for the specified device. */
 static void gasket_cleanup_pci(struct gasket_dev *gasket_dev)
 {
 	int i;
 
 	for (i = 0; i < GASKET_NUM_BARS; i++)
 		gasket_unmap_pci_bar(gasket_dev, i);
-
-	pci_disable_device(gasket_dev->pci_dev);
 }
 
 /* Determine the health of the Gasket device. */
@@ -1443,15 +1429,14 @@ static int gasket_enable_dev(struct gasket_internal_desc *internal_desc,
 }
 
 /*
- * PCI subsystem probe function.
- *
- * Called when a Gasket device is found. Allocates device metadata, maps device
- * memory, and calls gasket_enable_dev to prepare the device for active use.
+ * Add PCI gasket device.
  *
- * Returns 0 if successful and a negative value otherwise.
+ * Called by Gasket device probe function.
+ * Allocates device metadata, maps device memory, and calls gasket_enable_dev
+ * to prepare the device for active use.
  */
-static int gasket_pci_probe(struct pci_dev *pci_dev,
-			    const struct pci_device_id *id)
+int gasket_pci_add_device(struct pci_dev *pci_dev,
+			  struct gasket_dev **gasket_devp)
 {
 	int ret;
 	const char *kobj_name = dev_name(&pci_dev->dev);
@@ -1460,13 +1445,14 @@ static int gasket_pci_probe(struct pci_dev *pci_dev,
 	const struct gasket_driver_desc *driver_desc;
 	struct device *parent;
 
-	pr_info("Add Gasket device %s\n", kobj_name);
+	pr_debug("add PCI device %s\n", kobj_name);
 
 	mutex_lock(&g_mutex);
 	internal_desc = lookup_internal_desc(pci_dev);
 	mutex_unlock(&g_mutex);
 	if (!internal_desc) {
-		pr_err("PCI probe called for unknown driver type\n");
+		dev_err(&pci_dev->dev,
+			"PCI add device called for unknown driver type\n");
 		return -ENODEV;
 	}
 
@@ -1530,6 +1516,7 @@ static int gasket_pci_probe(struct pci_dev *pci_dev,
 		goto fail5;
 	}
 
+	*gasket_devp = gasket_dev;
 	return 0;
 
 fail5:
@@ -1545,14 +1532,10 @@ static int gasket_pci_probe(struct pci_dev *pci_dev,
 	gasket_free_dev(gasket_dev);
 	return ret;
 }
+EXPORT_SYMBOL(gasket_pci_add_device);
 
-/*
- * PCI subsystem remove function.
- *
- * Called to remove a Gasket device. Finds the device in the device list and
- * cleans up metadata.
- */
-static void gasket_pci_remove(struct pci_dev *pci_dev)
+/* Remove a PCI gasket device. */
+void gasket_pci_remove_device(struct pci_dev *pci_dev)
 {
 	int i;
 	struct gasket_internal_desc *internal_desc;
@@ -1583,8 +1566,8 @@ static void gasket_pci_remove(struct pci_dev *pci_dev)
 	if (!gasket_dev)
 		return;
 
-	pr_info("remove %s device %s\n", internal_desc->driver_desc->name,
-		gasket_dev->kobj_name);
+	dev_dbg(gasket_dev->dev, "remove %s PCI gasket device\n",
+		internal_desc->driver_desc->name);
 
 	gasket_disable_dev(gasket_dev);
 	gasket_cleanup_pci(gasket_dev);
@@ -1597,6 +1580,7 @@ static void gasket_pci_remove(struct pci_dev *pci_dev)
 	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
 	gasket_free_dev(gasket_dev);
 }
+EXPORT_SYMBOL(gasket_pci_remove_device);
 
 /**
  * Lookup a name by number in a num_name table.
@@ -1770,11 +1754,6 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 	internal = &g_descs[desc_idx];
 	mutex_init(&internal->mutex);
 	memset(internal->devs, 0, sizeof(struct gasket_dev *) * GASKET_DEV_MAX);
-	memset(&internal->pci, 0, sizeof(internal->pci));
-	internal->pci.name = driver_desc->name;
-	internal->pci.id_table = driver_desc->pci_id_table;
-	internal->pci.probe = gasket_pci_probe;
-	internal->pci.remove = gasket_pci_remove;
 	internal->class =
 		class_create(driver_desc->module, driver_desc->name);
 
@@ -1785,33 +1764,18 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 		goto unregister_gasket_driver;
 	}
 
-	/*
-	 * Not using pci_register_driver() (without underscores), as it
-	 * depends on KBUILD_MODNAME, and this is a shared file.
-	 */
-	ret = __pci_register_driver(&internal->pci, driver_desc->module,
-				    driver_desc->name);
-	if (ret) {
-		pr_err("cannot register %s pci driver [ret=%d]\n",
-		       driver_desc->name, ret);
-		goto fail1;
-	}
-
 	ret = register_chrdev_region(MKDEV(driver_desc->major,
 					   driver_desc->minor), GASKET_DEV_MAX,
 				     driver_desc->name);
 	if (ret) {
 		pr_err("cannot register %s char driver [ret=%d]\n",
 		       driver_desc->name, ret);
-		goto fail2;
+		goto destroy_class;
 	}
 
 	return 0;
 
-fail2:
-	pci_unregister_driver(&internal->pci);
-
-fail1:
+destroy_class:
 	class_destroy(internal->class);
 
 unregister_gasket_driver:
@@ -1848,8 +1812,6 @@ void gasket_unregister_device(const struct gasket_driver_desc *driver_desc)
 	unregister_chrdev_region(MKDEV(driver_desc->major, driver_desc->minor),
 				 GASKET_DEV_MAX);
 
-	pci_unregister_driver(&internal_desc->pci);
-
 	class_destroy(internal_desc->class);
 
 	/* Finally, effectively "remove" the driver. */

commit 515bc432e4a5b597e36d915df9fb3194c7083078
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 2 18:49:52 2018 -0700

    Revert "staging: gasket: core: hold reference to pci_dev while used"
    
    There's no need to take an additional reference on the pci_dev structure
    for the pointer copy saved in gasket data structures.
    
    This reverts commit:
    8dd8a48b9a7d ("staging: gasket: core: hold reference to pci_dev while used")
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 93a4d9f08eaa..2d209e36cf37 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -255,7 +255,6 @@ static void gasket_free_dev(struct gasket_dev *gasket_dev)
 	internal_desc->devs[gasket_dev->dev_idx] = NULL;
 	mutex_unlock(&internal_desc->mutex);
 	put_device(gasket_dev->dev);
-	pci_dev_put(gasket_dev->pci_dev);
 	kfree(gasket_dev);
 }
 
@@ -1477,7 +1476,7 @@ static int gasket_pci_probe(struct pci_dev *pci_dev,
 	ret = gasket_alloc_dev(internal_desc, parent, &gasket_dev, kobj_name);
 	if (ret)
 		return ret;
-	gasket_dev->pci_dev = pci_dev_get(pci_dev);
+	gasket_dev->pci_dev = pci_dev;
 	if (IS_ERR_OR_NULL(gasket_dev->dev_info.device)) {
 		pr_err("Cannot create %s device %s [ret = %ld]\n",
 		       driver_desc->name, gasket_dev->dev_info.name,

commit a43a98da75ff2821e484e5cb2a7f3ad0354255c8
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 2 18:49:51 2018 -0700

    staging: gasket: core: add subsystem and device info to logs
    
    Identify gasket as the subsystem printing various messages.
    Add the driver name to appropriate messages to indicate which driver
    has a problem.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 91db71c23880..93a4d9f08eaa 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -6,6 +6,9 @@
  *
  * Copyright (C) 2018 Google, Inc.
  */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include "gasket_core.h"
 
 #include "gasket_interrupt.h"
@@ -208,7 +211,7 @@ static int gasket_alloc_dev(struct gasket_internal_desc *internal_desc,
 
 	gasket_dev = *pdev = kzalloc(sizeof(*gasket_dev), GFP_KERNEL);
 	if (!gasket_dev) {
-		pr_err("no memory for device\n");
+		pr_err("no memory for device %s\n", kobj_name);
 		return -ENOMEM;
 	}
 	internal_desc->devs[dev_idx] = gasket_dev;
@@ -1760,7 +1763,7 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 	mutex_unlock(&g_mutex);
 
 	if (desc_idx == -1) {
-		pr_err("Too many Gasket drivers loaded: %d\n",
+		pr_err("too many drivers loaded, max %d\n",
 		       GASKET_FRAMEWORK_DESC_MAX);
 		return -EBUSY;
 	}
@@ -1790,7 +1793,8 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 	ret = __pci_register_driver(&internal->pci, driver_desc->module,
 				    driver_desc->name);
 	if (ret) {
-		pr_err("cannot register pci driver [ret=%d]\n", ret);
+		pr_err("cannot register %s pci driver [ret=%d]\n",
+		       driver_desc->name, ret);
 		goto fail1;
 	}
 
@@ -1798,7 +1802,8 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 					   driver_desc->minor), GASKET_DEV_MAX,
 				     driver_desc->name);
 	if (ret) {
-		pr_err("cannot register char driver [ret=%d]\n", ret);
+		pr_err("cannot register %s char driver [ret=%d]\n",
+		       driver_desc->name, ret);
 		goto fail2;
 	}
 

commit 8445a07db8784cfc5b11d7ceebfe698d1ee086ea
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 2 18:49:50 2018 -0700

    staging: gasket: core: device register debug log cleanups
    
    At device/driver registration time, convert a not-very-informative
    info message to a more informative debug message, drop some not overly
    helpful debug messages.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index fa477d0c3c74..91db71c23880 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1735,7 +1735,8 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 	int desc_idx = -1;
 	struct gasket_internal_desc *internal;
 
-	pr_info("Initializing Gasket framework device\n");
+	pr_debug("Loading %s driver version %s\n", driver_desc->name,
+		 driver_desc->driver_version);
 	/* Check for duplicates and find a free slot. */
 	mutex_lock(&g_mutex);
 
@@ -1764,8 +1765,6 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 		return -EBUSY;
 	}
 
-	/* Internal structure setup. */
-	pr_debug("Performing initial internal structure setup.\n");
 	internal = &g_descs[desc_idx];
 	mutex_init(&internal->mutex);
 	memset(internal->devs, 0, sizeof(struct gasket_dev *) * GASKET_DEV_MAX);
@@ -1788,7 +1787,6 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 	 * Not using pci_register_driver() (without underscores), as it
 	 * depends on KBUILD_MODNAME, and this is a shared file.
 	 */
-	pr_debug("Registering PCI driver.\n");
 	ret = __pci_register_driver(&internal->pci, driver_desc->module,
 				    driver_desc->name);
 	if (ret) {
@@ -1796,7 +1794,6 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 		goto fail1;
 	}
 
-	pr_debug("Registering char driver.\n");
 	ret = register_chrdev_region(MKDEV(driver_desc->major,
 					   driver_desc->minor), GASKET_DEV_MAX,
 				     driver_desc->name);

commit 5bf553b671cfab548185ee0b75cc80eda816f81c
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 2 18:49:49 2018 -0700

    staging: gasket: core: remove registration logs
    
    Remove logs for loading gasket drivers.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 2b75f100da4d..fa477d0c3c74 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1758,9 +1758,6 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 	}
 	mutex_unlock(&g_mutex);
 
-	pr_info("Loaded %s driver, framework version %s\n",
-		driver_desc->name, GASKET_FRAMEWORK_VERSION);
-
 	if (desc_idx == -1) {
 		pr_err("Too many Gasket drivers loaded: %d\n",
 		       GASKET_FRAMEWORK_DESC_MAX);
@@ -1808,7 +1805,6 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 		goto fail2;
 	}
 
-	pr_info("Driver registered successfully.\n");
 	return 0;
 
 fail2:

commit 1c65a2e2f68eae5d73b41dee003b8135dfcf6928
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 2 01:42:43 2018 -0700

    staging: gasket: remove "reset type" param from framework
    
    The "type of reset" parameter to the gasket device reset APIs isn't
    required by the only gasket device submitted upstream, apex.
    
    The framework documents the param as private to the device driver and a
    pass-through at the gasket layer, but the gasket core calls the device
    driver with a hardcoded reset type of zero, which is not documented as
    having a predefined meaning.
    
    In light of all this, remove the reset type parameter from the
    framework.  Remove the reset ioctl reset type parameter, and bump the
    framework version number to reflect the interface change.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index f76f4a0ecbac..2b75f100da4d 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1294,7 +1294,7 @@ static int gasket_release(struct inode *inode, struct file *file)
 			ownership->owner = 0;
 
 			/* Forces chip reset before we unmap the page tables. */
-			driver_desc->device_reset_cb(gasket_dev, 0);
+			driver_desc->device_reset_cb(gasket_dev);
 
 			for (i = 0; i < driver_desc->num_page_tables; ++i) {
 				gasket_page_table_unmap_all(gasket_dev->page_table[i]);
@@ -1622,18 +1622,18 @@ const char *gasket_num_name_lookup(uint num,
 }
 EXPORT_SYMBOL(gasket_num_name_lookup);
 
-int gasket_reset(struct gasket_dev *gasket_dev, uint reset_type)
+int gasket_reset(struct gasket_dev *gasket_dev)
 {
 	int ret;
 
 	mutex_lock(&gasket_dev->mutex);
-	ret = gasket_reset_nolock(gasket_dev, reset_type);
+	ret = gasket_reset_nolock(gasket_dev);
 	mutex_unlock(&gasket_dev->mutex);
 	return ret;
 }
 EXPORT_SYMBOL(gasket_reset);
 
-int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
+int gasket_reset_nolock(struct gasket_dev *gasket_dev)
 {
 	int ret;
 	int i;
@@ -1643,8 +1643,7 @@ int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
 	if (!driver_desc->device_reset_cb)
 		return 0;
 
-	/* Perform a device reset of the requested type. */
-	ret = driver_desc->device_reset_cb(gasket_dev, reset_type);
+	ret = driver_desc->device_reset_cb(gasket_dev);
 	if (ret) {
 		dev_dbg(gasket_dev->dev, "Device reset cb returned %d.\n",
 			ret);

commit e02fed16b3f430d89cdb9b2eda69906dafb507b3
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 31 13:24:46 2018 -0700

    staging: gasket: core: use bool type for ns_capable result
    
    When gasket core was converted from using capable() to use ns_capable()
    instead, the type of the variable holding the result should have been
    converted from int to bool.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 44344528cd88..f76f4a0ecbac 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1191,7 +1191,7 @@ static int gasket_open(struct inode *inode, struct file *filp)
 	struct gasket_cdev_info *dev_info =
 	    container_of(inode->i_cdev, struct gasket_cdev_info, cdev);
 	struct pid_namespace *pid_ns = task_active_pid_ns(current);
-	int is_root = ns_capable(pid_ns->user_ns, CAP_SYS_ADMIN);
+	bool is_root = ns_capable(pid_ns->user_ns, CAP_SYS_ADMIN);
 
 	gasket_dev = dev_info->gasket_dev_ptr;
 	driver_desc = gasket_dev->internal_desc->driver_desc;
@@ -1270,7 +1270,7 @@ static int gasket_release(struct inode *inode, struct file *file)
 	struct gasket_cdev_info *dev_info =
 		container_of(inode->i_cdev, struct gasket_cdev_info, cdev);
 	struct pid_namespace *pid_ns = task_active_pid_ns(current);
-	int is_root = ns_capable(pid_ns->user_ns, CAP_SYS_ADMIN);
+	bool is_root = ns_capable(pid_ns->user_ns, CAP_SYS_ADMIN);
 
 	gasket_dev = dev_info->gasket_dev_ptr;
 	driver_desc = gasket_dev->internal_desc->driver_desc;

commit 88c8a377c00ff3a69bf5a4abfdf6fc5f041089e1
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 31 13:24:39 2018 -0700

    staging: gasket: core: fix function param line continuation style
    
    Fix multi-line alignment formatting to look like:
          int ret = long_function_name(device, VARIABLE1, VARIABLE2,
                                       VARIABLE3, VARIABLE4);
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index b5a7254fbfb3..44344528cd88 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -103,8 +103,9 @@ enum gasket_sysfs_attribute_type {
 };
 
 /* Perform a standard Gasket callback. */
-static inline int check_and_invoke_callback(
-	struct gasket_dev *gasket_dev, int (*cb_function)(struct gasket_dev *))
+static inline int
+check_and_invoke_callback(struct gasket_dev *gasket_dev,
+			  int (*cb_function)(struct gasket_dev *))
 {
 	int ret = 0;
 
@@ -119,8 +120,9 @@ static inline int check_and_invoke_callback(
 }
 
 /* Perform a standard Gasket callback without grabbing gasket_dev->mutex. */
-static inline int gasket_check_and_invoke_callback_nolock(
-	struct gasket_dev *gasket_dev, int (*cb_function)(struct gasket_dev *))
+static inline int
+gasket_check_and_invoke_callback_nolock(struct gasket_dev *gasket_dev,
+					int (*cb_function)(struct gasket_dev *))
 {
 	int ret = 0;
 
@@ -147,8 +149,8 @@ static int gasket_owned_by_current_tgid(struct gasket_cdev_info *info)
  *
  * Returns the located slot number on success or a negative number on failure.
  */
-static int gasket_find_dev_slot(
-	struct gasket_internal_desc *internal_desc, const char *kobj_name)
+static int gasket_find_dev_slot(struct gasket_internal_desc *internal_desc,
+				const char *kobj_name)
 {
 	int i;
 
@@ -186,9 +188,9 @@ static int gasket_find_dev_slot(
  *
  * Returns 0 if successful, a negative error code otherwise.
  */
-static int gasket_alloc_dev(
-	struct gasket_internal_desc *internal_desc, struct device *parent,
-	struct gasket_dev **pdev, const char *kobj_name)
+static int gasket_alloc_dev(struct gasket_internal_desc *internal_desc,
+			    struct device *parent, struct gasket_dev **pdev,
+			    const char *kobj_name)
 {
 	int dev_idx;
 	const struct gasket_driver_desc *driver_desc =
@@ -228,7 +230,7 @@ static int gasket_alloc_dev(
 		 gasket_dev->dev_idx);
 	dev_info->devt =
 		MKDEV(driver_desc->major, driver_desc->minor +
-			gasket_dev->dev_idx);
+		      gasket_dev->dev_idx);
 	dev_info->device = device_create(internal_desc->class, parent,
 		dev_info->devt, gasket_dev, dev_info->name);
 
@@ -371,8 +373,8 @@ static void gasket_unmap_pci_bar(struct gasket_dev *dev, int bar_num)
  *
  * Returns 0 on success and a negative value otherwise.
  */
-static int gasket_setup_pci(
-	struct pci_dev *pci_dev, struct gasket_dev *gasket_dev)
+static int gasket_setup_pci(struct pci_dev *pci_dev,
+			    struct gasket_dev *gasket_dev)
 {
 	int i, mapped_bars, ret;
 
@@ -421,8 +423,8 @@ static int gasket_get_hw_status(struct gasket_dev *gasket_dev)
 	const struct gasket_driver_desc *driver_desc =
 		gasket_dev->internal_desc->driver_desc;
 
-	status = gasket_check_and_invoke_callback_nolock(
-		gasket_dev, driver_desc->device_status_cb);
+	status = gasket_check_and_invoke_callback_nolock(gasket_dev,
+							 driver_desc->device_status_cb);
 	if (status != GASKET_STATUS_ALIVE) {
 		dev_dbg(gasket_dev->dev, "Hardware reported status %d.\n",
 			status);
@@ -437,8 +439,7 @@ static int gasket_get_hw_status(struct gasket_dev *gasket_dev)
 	}
 
 	for (i = 0; i < driver_desc->num_page_tables; ++i) {
-		status = gasket_page_table_system_status(
-			gasket_dev->page_table[i]);
+		status = gasket_page_table_system_status(gasket_dev->page_table[i]);
 		if (status != GASKET_STATUS_ALIVE) {
 			dev_dbg(gasket_dev->dev,
 				"Page table %d reported status %d.\n",
@@ -450,8 +451,10 @@ static int gasket_get_hw_status(struct gasket_dev *gasket_dev)
 	return GASKET_STATUS_ALIVE;
 }
 
-static ssize_t gasket_write_mappable_regions(
-	char *buf, const struct gasket_driver_desc *driver_desc, int bar_index)
+static ssize_t
+gasket_write_mappable_regions(char *buf,
+			      const struct gasket_driver_desc *driver_desc,
+			      int bar_index)
 {
 	int i;
 	ssize_t written;
@@ -478,8 +481,8 @@ static ssize_t gasket_write_mappable_regions(
 	return total_written;
 }
 
-static ssize_t gasket_sysfs_data_show(
-	struct device *device, struct device_attribute *attr, char *buf)
+static ssize_t gasket_sysfs_data_show(struct device *device,
+				      struct device_attribute *attr, char *buf)
 {
 	int i, ret = 0;
 	ssize_t current_written = 0;
@@ -532,54 +535,49 @@ static ssize_t gasket_sysfs_data_show(
 		}
 		break;
 	case ATTR_DRIVER_VERSION:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%s\n",
-			gasket_dev->internal_desc->driver_desc->driver_version);
+		ret = snprintf(buf, PAGE_SIZE, "%s\n",
+			       gasket_dev->internal_desc->driver_desc->driver_version);
 		break;
 	case ATTR_FRAMEWORK_VERSION:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%s\n", GASKET_FRAMEWORK_VERSION);
+		ret = snprintf(buf, PAGE_SIZE, "%s\n",
+			       GASKET_FRAMEWORK_VERSION);
 		break;
 	case ATTR_DEVICE_TYPE:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%s\n",
-			gasket_dev->internal_desc->driver_desc->name);
+		ret = snprintf(buf, PAGE_SIZE, "%s\n",
+			       gasket_dev->internal_desc->driver_desc->name);
 		break;
 	case ATTR_HARDWARE_REVISION:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%d\n", gasket_dev->hardware_revision);
+		ret = snprintf(buf, PAGE_SIZE, "%d\n",
+			       gasket_dev->hardware_revision);
 		break;
 	case ATTR_PCI_ADDRESS:
 		ret = snprintf(buf, PAGE_SIZE, "%s\n", gasket_dev->kobj_name);
 		break;
 	case ATTR_STATUS:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%s\n",
-			gasket_num_name_lookup(
-				gasket_dev->status, gasket_status_name_table));
+		ret = snprintf(buf, PAGE_SIZE, "%s\n",
+			       gasket_num_name_lookup(gasket_dev->status,
+						      gasket_status_name_table));
 		break;
 	case ATTR_IS_DEVICE_OWNED:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%d\n",
-			gasket_dev->dev_info.ownership.is_owned);
+		ret = snprintf(buf, PAGE_SIZE, "%d\n",
+			       gasket_dev->dev_info.ownership.is_owned);
 		break;
 	case ATTR_DEVICE_OWNER:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%d\n",
-			gasket_dev->dev_info.ownership.owner);
+		ret = snprintf(buf, PAGE_SIZE, "%d\n",
+			       gasket_dev->dev_info.ownership.owner);
 		break;
 	case ATTR_WRITE_OPEN_COUNT:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%d\n",
-			gasket_dev->dev_info.ownership.write_open_count);
+		ret = snprintf(buf, PAGE_SIZE, "%d\n",
+			       gasket_dev->dev_info.ownership.write_open_count);
 		break;
 	case ATTR_RESET_COUNT:
 		ret = snprintf(buf, PAGE_SIZE, "%d\n", gasket_dev->reset_count);
 		break;
 	case ATTR_USER_MEM_RANGES:
 		for (i = 0; i < GASKET_NUM_BARS; ++i) {
-			current_written = gasket_write_mappable_regions(
-				buf, driver_desc, i);
+			current_written =
+				gasket_write_mappable_regions(buf, driver_desc,
+							      i);
 			buf += current_written;
 			ret += current_written;
 		}
@@ -622,9 +620,9 @@ static const struct gasket_sysfs_attribute gasket_sysfs_generic_attrs[] = {
 };
 
 /* Add a char device and related info. */
-static int gasket_add_cdev(
-	struct gasket_cdev_info *dev_info,
-	const struct file_operations *file_ops, struct module *owner)
+static int gasket_add_cdev(struct gasket_cdev_info *dev_info,
+			   const struct file_operations *file_ops,
+			   struct module *owner)
 {
 	int ret;
 
@@ -672,8 +670,8 @@ static void gasket_disable_dev(struct gasket_dev *gasket_dev)
  * Precondition: Called with g_mutex held (to avoid a race on return).
  * Returns NULL if no matching device was found.
  */
-static struct gasket_internal_desc *lookup_internal_desc(
-	struct pci_dev *pci_dev)
+static struct gasket_internal_desc *
+lookup_internal_desc(struct pci_dev *pci_dev)
 {
 	int i;
 
@@ -693,9 +691,9 @@ static struct gasket_internal_desc *lookup_internal_desc(
  * that the provided descriptor/range is of adequate size to hold the range to
  * be mapped.
  */
-static bool gasket_mmap_has_permissions(
-	struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
-	int bar_permissions)
+static bool gasket_mmap_has_permissions(struct gasket_dev *gasket_dev,
+					struct vm_area_struct *vma,
+					int bar_permissions)
 {
 	int requested_permissions;
 	/* Always allow sysadmin to access. */
@@ -735,8 +733,9 @@ static bool gasket_mmap_has_permissions(
  * Verifies that the input address is within the region allocated to coherent
  * buffer.
  */
-static bool gasket_is_coherent_region(
-	const struct gasket_driver_desc *driver_desc, ulong address)
+static bool
+gasket_is_coherent_region(const struct gasket_driver_desc *driver_desc,
+			  ulong address)
 {
 	struct gasket_coherent_buffer_desc coh_buff_desc =
 		driver_desc->coherent_buffer_description;
@@ -750,8 +749,8 @@ static bool gasket_is_coherent_region(
 	return false;
 }
 
-static int gasket_get_bar_index(
-	const struct gasket_dev *gasket_dev, ulong phys_addr)
+static int gasket_get_bar_index(const struct gasket_dev *gasket_dev,
+				ulong phys_addr)
 {
 	int i;
 	const struct gasket_driver_desc *driver_desc;
@@ -786,10 +785,11 @@ static int gasket_get_bar_index(
  *
  * Returns true if there's anything to map, and false otherwise.
  */
-static bool gasket_mm_get_mapping_addrs(
-	const struct gasket_mappable_region *region, ulong bar_offset,
-	ulong requested_length, struct gasket_mappable_region *mappable_region,
-	ulong *virt_offset)
+static bool
+gasket_mm_get_mapping_addrs(const struct gasket_mappable_region *region,
+			    ulong bar_offset, ulong requested_length,
+			    struct gasket_mappable_region *mappable_region,
+			    ulong *virt_offset)
 {
 	ulong range_start = region->start;
 	ulong range_length = region->length_bytes;
@@ -835,8 +835,8 @@ static bool gasket_mm_get_mapping_addrs(
 		 */
 		mappable_region->start = bar_offset;
 		*virt_offset = 0;
-		mappable_region->length_bytes = min(
-			requested_length, range_end - bar_offset);
+		mappable_region->length_bytes =
+			min(requested_length, range_end - bar_offset);
 		return true;
 	}
 
@@ -852,9 +852,9 @@ static bool gasket_mm_get_mapping_addrs(
  * The offset is written into bar_offset on success.
  * Returns zero on success, anything else on error.
  */
-static int gasket_mm_vma_bar_offset(
-	const struct gasket_dev *gasket_dev, const struct vm_area_struct *vma,
-	ulong *bar_offset)
+static int gasket_mm_vma_bar_offset(const struct gasket_dev *gasket_dev,
+				    const struct vm_area_struct *vma,
+				    ulong *bar_offset)
 {
 	ulong raw_offset;
 	int bar_index;
@@ -877,9 +877,9 @@ static int gasket_mm_vma_bar_offset(
 	return 0;
 }
 
-int gasket_mm_unmap_region(
-	const struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
-	const struct gasket_mappable_region *map_region)
+int gasket_mm_unmap_region(const struct gasket_dev *gasket_dev,
+			   struct vm_area_struct *vma,
+			   const struct gasket_mappable_region *map_region)
 {
 	ulong bar_offset;
 	ulong virt_offset;
@@ -893,9 +893,9 @@ int gasket_mm_unmap_region(
 	if (ret)
 		return ret;
 
-	if (!gasket_mm_get_mapping_addrs(
-		map_region, bar_offset, vma->vm_end - vma->vm_start,
-		&mappable_region, &virt_offset))
+	if (!gasket_mm_get_mapping_addrs(map_region, bar_offset,
+					 vma->vm_end - vma->vm_start,
+					 &mappable_region, &virt_offset))
 		return 1;
 
 	/*
@@ -904,18 +904,17 @@ int gasket_mm_unmap_region(
 	 *
 	 * Next multiple of y: ceil_div(x, y) * y
 	 */
-	zap_vma_ptes(
-		vma, vma->vm_start + virt_offset,
-		DIV_ROUND_UP(mappable_region.length_bytes, PAGE_SIZE) *
-			PAGE_SIZE);
+	zap_vma_ptes(vma, vma->vm_start + virt_offset,
+		     DIV_ROUND_UP(mappable_region.length_bytes, PAGE_SIZE) *
+		     PAGE_SIZE);
 	return 0;
 }
 EXPORT_SYMBOL(gasket_mm_unmap_region);
 
 /* Maps a virtual address + range to a physical offset of a BAR. */
-static enum do_map_region_status do_map_region(
-	const struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
-	struct gasket_mappable_region *mappable_region)
+static enum do_map_region_status
+do_map_region(const struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
+	      struct gasket_mappable_region *mappable_region)
 {
 	/* Maximum size of a single call to io_remap_pfn_range. */
 	/* I pulled this number out of thin air. */
@@ -944,10 +943,9 @@ static enum do_map_region_status do_map_region(
 
 	virt_base = vma->vm_start + virt_offset;
 	bar_index =
-		gasket_get_bar_index(
-			gasket_dev,
-			(vma->vm_pgoff << PAGE_SHIFT) +
-				driver_desc->legacy_mmap_address_offset);
+		gasket_get_bar_index(gasket_dev,
+				     (vma->vm_pgoff << PAGE_SHIFT) +
+				     driver_desc->legacy_mmap_address_offset);
 	phys_base = gasket_dev->bar_data[bar_index].phys_base + phys_offset;
 	while (mapped_bytes < map_length) {
 		/*
@@ -957,10 +955,10 @@ static enum do_map_region_status do_map_region(
 		chunk_size = min(max_chunk_size, map_length - mapped_bytes);
 
 		cond_resched();
-		ret = io_remap_pfn_range(
-			vma, virt_base + mapped_bytes,
-			(phys_base + mapped_bytes) >> PAGE_SHIFT,
-			chunk_size, vma->vm_page_prot);
+		ret = io_remap_pfn_range(vma, virt_base + mapped_bytes,
+					 (phys_base + mapped_bytes) >>
+					 PAGE_SHIFT, chunk_size,
+					 vma->vm_page_prot);
 		if (ret) {
 			dev_err(gasket_dev->dev,
 				"Error remapping PFN range.\n");
@@ -984,8 +982,8 @@ static enum do_map_region_status do_map_region(
 }
 
 /* Map a region of coherent memory. */
-static int gasket_mmap_coherent(
-	struct gasket_dev *gasket_dev, struct vm_area_struct *vma)
+static int gasket_mmap_coherent(struct gasket_dev *gasket_dev,
+				struct vm_area_struct *vma)
 {
 	const struct gasket_driver_desc *driver_desc =
 		gasket_dev->internal_desc->driver_desc;
@@ -1008,10 +1006,9 @@ static int gasket_mmap_coherent(
 
 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 
-	ret = remap_pfn_range(
-		vma, vma->vm_start,
-		(gasket_dev->coherent_buffer.phys_base) >> PAGE_SHIFT,
-		requested_length, vma->vm_page_prot);
+	ret = remap_pfn_range(vma, vma->vm_start,
+			      (gasket_dev->coherent_buffer.phys_base) >>
+			      PAGE_SHIFT, requested_length, vma->vm_page_prot);
 	if (ret) {
 		dev_err(gasket_dev->dev, "Error remapping PFN range err=%d.\n",
 			ret);
@@ -1022,9 +1019,9 @@ static int gasket_mmap_coherent(
 	/* Record the user virtual to dma_address mapping that was
 	 * created by the kernel.
 	 */
-	gasket_set_user_virt(
-		gasket_dev, requested_length,
-		gasket_dev->coherent_buffer.phys_base, vma->vm_start);
+	gasket_set_user_virt(gasket_dev, requested_length,
+			     gasket_dev->coherent_buffer.phys_base,
+			     vma->vm_start);
 	return 0;
 }
 
@@ -1058,8 +1055,8 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	raw_offset = (vma->vm_pgoff << PAGE_SHIFT) +
 		driver_desc->legacy_mmap_address_offset;
 	vma_size = vma->vm_end - vma->vm_start;
-	trace_gasket_mmap_entry(
-		gasket_dev->dev_info.name, raw_offset, vma_size);
+	trace_gasket_mmap_entry(gasket_dev->dev_info.name, raw_offset,
+				vma_size);
 
 	/*
 	 * Check if the raw offset is within a bar region. If not, check if it
@@ -1103,8 +1100,10 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	}
 
 	if (driver_desc->get_mappable_regions_cb) {
-		ret = driver_desc->get_mappable_regions_cb(
-			gasket_dev, bar_index, &map_regions, &num_map_regions);
+		ret = driver_desc->get_mappable_regions_cb(gasket_dev,
+							   bar_index,
+							   &map_regions,
+							   &num_map_regions);
 		if (ret)
 			return ret;
 	} else {
@@ -1231,8 +1230,8 @@ static int gasket_open(struct inode *inode, struct file *filp)
 
 	/* If the node is not owned, assign it to the current TGID. */
 	if (!ownership->is_owned) {
-		ret = gasket_check_and_invoke_callback_nolock(
-			gasket_dev, driver_desc->device_open_cb);
+		ret = gasket_check_and_invoke_callback_nolock(gasket_dev,
+							      driver_desc->device_open_cb);
 		if (ret) {
 			dev_err(gasket_dev->dev,
 				"Error in device open cb: %d\n", ret);
@@ -1298,16 +1297,14 @@ static int gasket_release(struct inode *inode, struct file *file)
 			driver_desc->device_reset_cb(gasket_dev, 0);
 
 			for (i = 0; i < driver_desc->num_page_tables; ++i) {
-				gasket_page_table_unmap_all(
-					gasket_dev->page_table[i]);
-				gasket_page_table_garbage_collect(
-					gasket_dev->page_table[i]);
+				gasket_page_table_unmap_all(gasket_dev->page_table[i]);
+				gasket_page_table_garbage_collect(gasket_dev->page_table[i]);
 				gasket_free_coherent_memory_all(gasket_dev, i);
 			}
 
 			/* Closes device, enters power save. */
-			gasket_check_and_invoke_callback_nolock(
-				gasket_dev, driver_desc->device_close_cb);
+			gasket_check_and_invoke_callback_nolock(gasket_dev,
+								driver_desc->device_close_cb);
 		}
 	}
 
@@ -1367,21 +1364,21 @@ static const struct file_operations gasket_file_ops = {
 };
 
 /* Perform final init and marks the device as active. */
-static int gasket_enable_dev(
-	struct gasket_internal_desc *internal_desc,
-	struct gasket_dev *gasket_dev)
+static int gasket_enable_dev(struct gasket_internal_desc *internal_desc,
+			     struct gasket_dev *gasket_dev)
 {
 	int tbl_idx;
 	int ret;
 	const struct gasket_driver_desc *driver_desc =
 		internal_desc->driver_desc;
 
-	ret = gasket_interrupt_init(
-		gasket_dev, driver_desc->name,
-		driver_desc->interrupt_type, driver_desc->interrupts,
-		driver_desc->num_interrupts, driver_desc->interrupt_pack_width,
-		driver_desc->interrupt_bar_index,
-		driver_desc->wire_interrupt_offsets);
+	ret = gasket_interrupt_init(gasket_dev, driver_desc->name,
+				    driver_desc->interrupt_type,
+				    driver_desc->interrupts,
+				    driver_desc->num_interrupts,
+				    driver_desc->interrupt_pack_width,
+				    driver_desc->interrupt_bar_index,
+				    driver_desc->wire_interrupt_offsets);
 	if (ret) {
 		dev_err(gasket_dev->dev,
 			"Critical failure to allocate interrupts: %d\n", ret);
@@ -1392,12 +1389,11 @@ static int gasket_enable_dev(
 	for (tbl_idx = 0; tbl_idx < driver_desc->num_page_tables; tbl_idx++) {
 		dev_dbg(gasket_dev->dev, "Initializing page table %d.\n",
 			tbl_idx);
-		ret = gasket_page_table_init(
-			&gasket_dev->page_table[tbl_idx],
-			&gasket_dev->bar_data[
-				driver_desc->page_table_bar_index],
-			&driver_desc->page_table_configs[tbl_idx],
-			gasket_dev->dev, gasket_dev->pci_dev);
+		ret = gasket_page_table_init(&gasket_dev->page_table[tbl_idx],
+					     &gasket_dev->bar_data[driver_desc->page_table_bar_index],
+					     &driver_desc->page_table_configs[tbl_idx],
+					     gasket_dev->dev,
+					     gasket_dev->pci_dev);
 		if (ret) {
 			dev_err(gasket_dev->dev,
 				"Couldn't init page table %d: %d\n",
@@ -1415,8 +1411,8 @@ static int gasket_enable_dev(
 	 * hardware_revision_cb returns a positive integer (the rev) if
 	 * successful.)
 	 */
-	ret = check_and_invoke_callback(
-		gasket_dev, driver_desc->hardware_revision_cb);
+	ret = check_and_invoke_callback(gasket_dev,
+					driver_desc->hardware_revision_cb);
 	if (ret < 0) {
 		dev_err(gasket_dev->dev,
 			"Error getting hardware revision: %d\n", ret);
@@ -1436,8 +1432,8 @@ static int gasket_enable_dev(
 	if (gasket_dev->status == GASKET_STATUS_DEAD)
 		dev_err(gasket_dev->dev, "Device reported as unhealthy.\n");
 
-	ret = gasket_add_cdev(
-		&gasket_dev->dev_info, &gasket_file_ops, driver_desc->module);
+	ret = gasket_add_cdev(&gasket_dev->dev_info, &gasket_file_ops,
+			      driver_desc->module);
 	if (ret)
 		return ret;
 
@@ -1452,8 +1448,8 @@ static int gasket_enable_dev(
  *
  * Returns 0 if successful and a negative value otherwise.
  */
-static int gasket_pci_probe(
-	struct pci_dev *pci_dev, const struct pci_device_id *id)
+static int gasket_pci_probe(struct pci_dev *pci_dev,
+			    const struct pci_device_id *id)
 {
 	int ret;
 	const char *kobj_name = dev_name(&pci_dev->dev);
@@ -1497,8 +1493,8 @@ static int gasket_pci_probe(
 		goto fail2;
 	}
 
-	ret = gasket_sysfs_create_mapping(
-		gasket_dev->dev_info.device, gasket_dev);
+	ret = gasket_sysfs_create_mapping(gasket_dev->dev_info.device,
+					  gasket_dev);
 	if (ret)
 		goto fail3;
 
@@ -1513,13 +1509,13 @@ static int gasket_pci_probe(
 			"Cannot create sysfs pci link: %d\n", ret);
 		goto fail3;
 	}
-	ret = gasket_sysfs_create_entries(
-		gasket_dev->dev_info.device, gasket_sysfs_generic_attrs);
+	ret = gasket_sysfs_create_entries(gasket_dev->dev_info.device,
+					  gasket_sysfs_generic_attrs);
 	if (ret)
 		goto fail4;
 
-	ret = check_and_invoke_callback(
-		gasket_dev, driver_desc->sysfs_setup_cb);
+	ret = check_and_invoke_callback(gasket_dev,
+					driver_desc->sysfs_setup_cb);
 	if (ret) {
 		dev_err(gasket_dev->dev, "Error in sysfs setup cb: %d\n", ret);
 		goto fail5;
@@ -1611,8 +1607,8 @@ static void gasket_pci_remove(struct pci_dev *pci_dev)
  *
  *		The table must have a NULL name pointer at the end.
  */
-const char *gasket_num_name_lookup(
-	uint num, const struct gasket_num_name *table)
+const char *gasket_num_name_lookup(uint num,
+				   const struct gasket_num_name *table)
 {
 	uint i = 0;
 
@@ -1677,8 +1673,8 @@ int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
 }
 EXPORT_SYMBOL(gasket_reset_nolock);
 
-gasket_ioctl_permissions_cb_t gasket_get_ioctl_permissions_cb(
-	struct gasket_dev *gasket_dev)
+gasket_ioctl_permissions_cb_t
+gasket_get_ioctl_permissions_cb(struct gasket_dev *gasket_dev)
 {
 	return gasket_dev->internal_desc->driver_desc->ioctl_permissions_cb;
 }
@@ -1713,9 +1709,9 @@ struct device *gasket_get_device(struct gasket_dev *dev)
  * Description: Busy waits for a specific combination of bits to be set on a
  * Gasket register.
  **/
-int gasket_wait_with_reschedule(
-	struct gasket_dev *gasket_dev, int bar, u64 offset, u64 mask, u64 val,
-	uint max_retries, u64 delay_ms)
+int gasket_wait_with_reschedule(struct gasket_dev *gasket_dev, int bar,
+				u64 offset, u64 mask, u64 val,
+				uint max_retries, u64 delay_ms)
 {
 	uint retries = 0;
 	u64 tmp;
@@ -1797,17 +1793,17 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 	 * depends on KBUILD_MODNAME, and this is a shared file.
 	 */
 	pr_debug("Registering PCI driver.\n");
-	ret = __pci_register_driver(
-		&internal->pci, driver_desc->module, driver_desc->name);
+	ret = __pci_register_driver(&internal->pci, driver_desc->module,
+				    driver_desc->name);
 	if (ret) {
 		pr_err("cannot register pci driver [ret=%d]\n", ret);
 		goto fail1;
 	}
 
 	pr_debug("Registering char driver.\n");
-	ret = register_chrdev_region(
-		MKDEV(driver_desc->major, driver_desc->minor), GASKET_DEV_MAX,
-		driver_desc->name);
+	ret = register_chrdev_region(MKDEV(driver_desc->major,
+					   driver_desc->minor), GASKET_DEV_MAX,
+				     driver_desc->name);
 	if (ret) {
 		pr_err("cannot register char driver [ret=%d]\n", ret);
 		goto fail2;
@@ -1853,8 +1849,8 @@ void gasket_unregister_device(const struct gasket_driver_desc *driver_desc)
 		return;
 	}
 
-	unregister_chrdev_region(
-		MKDEV(driver_desc->major, driver_desc->minor), GASKET_DEV_MAX);
+	unregister_chrdev_region(MKDEV(driver_desc->major, driver_desc->minor),
+				 GASKET_DEV_MAX);
 
 	pci_unregister_driver(&internal_desc->pci);
 

commit 80666096eb78f0eb54abb1991c23488a276fa1c6
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 31 13:24:34 2018 -0700

    staging: gasket: core: remove static function forward declarations
    
    Remove forward declarations of static functions, move code to avoid
    forward references, for kernel style.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index c00774059f9e..b5a7254fbfb3 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -67,61 +67,6 @@ enum do_map_region_status {
 	DO_MAP_REGION_INVALID,
 };
 
-/* Function declarations; comments are with definitions. */
-static int __init gasket_init(void);
-static void __exit gasket_exit(void);
-
-static int gasket_pci_probe(
-	struct pci_dev *pci_dev, const struct pci_device_id *id);
-static void gasket_pci_remove(struct pci_dev *pci_dev);
-
-static int gasket_setup_pci(struct pci_dev *pci_dev, struct gasket_dev *dev);
-static void gasket_cleanup_pci(struct gasket_dev *dev);
-
-static int gasket_map_pci_bar(struct gasket_dev *dev, int bar_num);
-static void gasket_unmap_pci_bar(struct gasket_dev *dev, int bar_num);
-
-static int gasket_alloc_dev(
-	struct gasket_internal_desc *internal_desc, struct device *dev,
-	struct gasket_dev **pdev, const char *kobj_name);
-static void gasket_free_dev(struct gasket_dev *dev);
-
-static int gasket_find_dev_slot(
-	struct gasket_internal_desc *internal_desc, const char *kobj_name);
-
-static int gasket_add_cdev(
-	struct gasket_cdev_info *dev_info,
-	const struct file_operations *file_ops, struct module *owner);
-
-static int gasket_enable_dev(
-	struct gasket_internal_desc *internal_desc,
-	struct gasket_dev *gasket_dev);
-static void gasket_disable_dev(struct gasket_dev *gasket_dev);
-
-static struct gasket_internal_desc *lookup_internal_desc(
-	struct pci_dev *pci_dev);
-
-static ssize_t gasket_sysfs_data_show(
-	struct device *device, struct device_attribute *attr, char *buf);
-
-static int gasket_mmap(struct file *filp, struct vm_area_struct *vma);
-static int gasket_open(struct inode *inode, struct file *file);
-static int gasket_release(struct inode *inode, struct file *file);
-static long gasket_ioctl(struct file *filp, uint cmd, ulong arg);
-
-static int gasket_mm_vma_bar_offset(
-	const struct gasket_dev *gasket_dev, const struct vm_area_struct *vma,
-	ulong *bar_offset);
-static bool gasket_mm_get_mapping_addrs(
-	const struct gasket_mappable_region *region, ulong bar_offset,
-	ulong requested_length, struct gasket_mappable_region *mappable_region,
-	ulong *virt_offset);
-static enum do_map_region_status do_map_region(
-	const struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
-	struct gasket_mappable_region *map_region);
-
-static int gasket_get_hw_status(struct gasket_dev *gasket_dev);
-
 /* Global data definitions. */
 /* Mutex - only for framework-wide data. Other data should be protected by
  * finer-grained locks.
@@ -157,48 +102,6 @@ enum gasket_sysfs_attribute_type {
 	ATTR_USER_MEM_RANGES
 };
 
-/* File operations for all Gasket devices. */
-static const struct file_operations gasket_file_ops = {
-	.owner = THIS_MODULE,
-	.llseek = no_llseek,
-	.mmap = gasket_mmap,
-	.open = gasket_open,
-	.release = gasket_release,
-	.unlocked_ioctl = gasket_ioctl,
-};
-
-/* These attributes apply to all Gasket driver instances. */
-static const struct gasket_sysfs_attribute gasket_sysfs_generic_attrs[] = {
-	GASKET_SYSFS_RO(bar_offsets, gasket_sysfs_data_show, ATTR_BAR_OFFSETS),
-	GASKET_SYSFS_RO(bar_sizes, gasket_sysfs_data_show, ATTR_BAR_SIZES),
-	GASKET_SYSFS_RO(driver_version, gasket_sysfs_data_show,
-			ATTR_DRIVER_VERSION),
-	GASKET_SYSFS_RO(framework_version, gasket_sysfs_data_show,
-			ATTR_FRAMEWORK_VERSION),
-	GASKET_SYSFS_RO(device_type, gasket_sysfs_data_show, ATTR_DEVICE_TYPE),
-	GASKET_SYSFS_RO(revision, gasket_sysfs_data_show,
-			ATTR_HARDWARE_REVISION),
-	GASKET_SYSFS_RO(pci_address, gasket_sysfs_data_show, ATTR_PCI_ADDRESS),
-	GASKET_SYSFS_RO(status, gasket_sysfs_data_show, ATTR_STATUS),
-	GASKET_SYSFS_RO(is_device_owned, gasket_sysfs_data_show,
-			ATTR_IS_DEVICE_OWNED),
-	GASKET_SYSFS_RO(device_owner, gasket_sysfs_data_show,
-			ATTR_DEVICE_OWNER),
-	GASKET_SYSFS_RO(write_open_count, gasket_sysfs_data_show,
-			ATTR_WRITE_OPEN_COUNT),
-	GASKET_SYSFS_RO(reset_count, gasket_sysfs_data_show, ATTR_RESET_COUNT),
-	GASKET_SYSFS_RO(user_mem_ranges, gasket_sysfs_data_show,
-			ATTR_USER_MEM_RANGES),
-	GASKET_END_OF_ATTR_ARRAY
-};
-
-MODULE_DESCRIPTION("Google Gasket driver framework");
-MODULE_VERSION(GASKET_FRAMEWORK_VERSION);
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Rob Springer <rspringer@google.com>");
-module_init(gasket_init);
-module_exit(gasket_exit);
-
 /* Perform a standard Gasket callback. */
 static inline int check_and_invoke_callback(
 	struct gasket_dev *gasket_dev, int (*cb_function)(struct gasket_dev *))
@@ -239,165 +142,43 @@ static int gasket_owned_by_current_tgid(struct gasket_cdev_info *info)
 		(info->ownership.owner == current->tgid));
 }
 
-static int __init gasket_init(void)
+/*
+ * Find the next free gasket_internal_dev slot.
+ *
+ * Returns the located slot number on success or a negative number on failure.
+ */
+static int gasket_find_dev_slot(
+	struct gasket_internal_desc *internal_desc, const char *kobj_name)
 {
 	int i;
 
-	pr_info("Performing one-time init of the Gasket framework.\n");
-	/* Check for duplicates and find a free slot. */
-	mutex_lock(&g_mutex);
-	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
-		g_descs[i].driver_desc = NULL;
-		mutex_init(&g_descs[i].mutex);
-	}
-
-	gasket_sysfs_init();
-
-	mutex_unlock(&g_mutex);
-	return 0;
-}
-
-static void __exit gasket_exit(void)
-{
-	/* No deinit/dealloc needed at present. */
-	pr_info("Removing Gasket framework module.\n");
-}
-
-/* See gasket_core.h for description. */
-int gasket_register_device(const struct gasket_driver_desc *driver_desc)
-{
-	int i, ret;
-	int desc_idx = -1;
-	struct gasket_internal_desc *internal;
-
-	pr_info("Initializing Gasket framework device\n");
-	/* Check for duplicates and find a free slot. */
-	mutex_lock(&g_mutex);
+	mutex_lock(&internal_desc->mutex);
 
-	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
-		if (g_descs[i].driver_desc == driver_desc) {
-			pr_err("%s driver already loaded/registered\n",
-			       driver_desc->name);
-			mutex_unlock(&g_mutex);
+	/* Search for a previous instance of this device. */
+	for (i = 0; i < GASKET_DEV_MAX; i++) {
+		if (internal_desc->devs[i] &&
+		    strcmp(internal_desc->devs[i]->kobj_name, kobj_name) == 0) {
+			pr_err("Duplicate device %s\n", kobj_name);
+			mutex_unlock(&internal_desc->mutex);
 			return -EBUSY;
 		}
 	}
 
-	/* This and the above loop could be combined, but this reads easier. */
-	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
-		if (!g_descs[i].driver_desc) {
-			g_descs[i].driver_desc = driver_desc;
-			desc_idx = i;
+	/* Find a free device slot. */
+	for (i = 0; i < GASKET_DEV_MAX; i++) {
+		if (!internal_desc->devs[i])
 			break;
-		}
 	}
-	mutex_unlock(&g_mutex);
-
-	pr_info("Loaded %s driver, framework version %s\n",
-		driver_desc->name, GASKET_FRAMEWORK_VERSION);
 
-	if (desc_idx == -1) {
-		pr_err("Too many Gasket drivers loaded: %d\n",
-		       GASKET_FRAMEWORK_DESC_MAX);
+	if (i == GASKET_DEV_MAX) {
+		pr_err("Too many registered devices; max %d\n", GASKET_DEV_MAX);
+		mutex_unlock(&internal_desc->mutex);
 		return -EBUSY;
 	}
 
-	/* Internal structure setup. */
-	pr_debug("Performing initial internal structure setup.\n");
-	internal = &g_descs[desc_idx];
-	mutex_init(&internal->mutex);
-	memset(internal->devs, 0, sizeof(struct gasket_dev *) * GASKET_DEV_MAX);
-	memset(&internal->pci, 0, sizeof(internal->pci));
-	internal->pci.name = driver_desc->name;
-	internal->pci.id_table = driver_desc->pci_id_table;
-	internal->pci.probe = gasket_pci_probe;
-	internal->pci.remove = gasket_pci_remove;
-	internal->class =
-		class_create(driver_desc->module, driver_desc->name);
-
-	if (IS_ERR(internal->class)) {
-		pr_err("Cannot register %s class [ret=%ld]\n",
-		       driver_desc->name, PTR_ERR(internal->class));
-		ret = PTR_ERR(internal->class);
-		goto unregister_gasket_driver;
-	}
-
-	/*
-	 * Not using pci_register_driver() (without underscores), as it
-	 * depends on KBUILD_MODNAME, and this is a shared file.
-	 */
-	pr_debug("Registering PCI driver.\n");
-	ret = __pci_register_driver(
-		&internal->pci, driver_desc->module, driver_desc->name);
-	if (ret) {
-		pr_err("cannot register pci driver [ret=%d]\n", ret);
-		goto fail1;
-	}
-
-	pr_debug("Registering char driver.\n");
-	ret = register_chrdev_region(
-		MKDEV(driver_desc->major, driver_desc->minor), GASKET_DEV_MAX,
-		driver_desc->name);
-	if (ret) {
-		pr_err("cannot register char driver [ret=%d]\n", ret);
-		goto fail2;
-	}
-
-	pr_info("Driver registered successfully.\n");
-	return 0;
-
-fail2:
-	pci_unregister_driver(&internal->pci);
-
-fail1:
-	class_destroy(internal->class);
-
-unregister_gasket_driver:
-	mutex_lock(&g_mutex);
-	g_descs[desc_idx].driver_desc = NULL;
-	mutex_unlock(&g_mutex);
-	return ret;
-}
-EXPORT_SYMBOL(gasket_register_device);
-
-/* See gasket_core.h for description. */
-void gasket_unregister_device(const struct gasket_driver_desc *driver_desc)
-{
-	int i, desc_idx;
-	struct gasket_internal_desc *internal_desc = NULL;
-
-	mutex_lock(&g_mutex);
-	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
-		if (g_descs[i].driver_desc == driver_desc) {
-			internal_desc = &g_descs[i];
-			desc_idx = i;
-			break;
-		}
-	}
-	mutex_unlock(&g_mutex);
-
-	if (!internal_desc) {
-		pr_err("request to unregister unknown desc: %s, %d:%d\n",
-		       driver_desc->name, driver_desc->major,
-		       driver_desc->minor);
-		return;
-	}
-
-	unregister_chrdev_region(
-		MKDEV(driver_desc->major, driver_desc->minor), GASKET_DEV_MAX);
-
-	pci_unregister_driver(&internal_desc->pci);
-
-	class_destroy(internal_desc->class);
-
-	/* Finally, effectively "remove" the driver. */
-	mutex_lock(&g_mutex);
-	g_descs[desc_idx].driver_desc = NULL;
-	mutex_unlock(&g_mutex);
-
-	pr_info("removed %s driver\n", driver_desc->name);
+	mutex_unlock(&internal_desc->mutex);
+	return i;
 }
-EXPORT_SYMBOL(gasket_unregister_device);
 
 /*
  * Allocate and initialize a Gasket device structure, add the device to the
@@ -474,265 +255,21 @@ static void gasket_free_dev(struct gasket_dev *gasket_dev)
 }
 
 /*
- * Find the next free gasket_internal_dev slot.
+ * Maps the specified bar into kernel space.
  *
- * Returns the located slot number on success or a negative number on failure.
+ * Returns 0 on success, a negative error code otherwise.
+ * A zero-sized BAR will not be mapped, but is not an error.
  */
-static int gasket_find_dev_slot(
-	struct gasket_internal_desc *internal_desc, const char *kobj_name)
+static int gasket_map_pci_bar(struct gasket_dev *gasket_dev, int bar_num)
 {
-	int i;
+	struct gasket_internal_desc *internal_desc = gasket_dev->internal_desc;
+	const struct gasket_driver_desc *driver_desc =
+		internal_desc->driver_desc;
+	ulong desc_bytes = driver_desc->bar_descriptions[bar_num].size;
+	int ret;
 
-	mutex_lock(&internal_desc->mutex);
-
-	/* Search for a previous instance of this device. */
-	for (i = 0; i < GASKET_DEV_MAX; i++) {
-		if (internal_desc->devs[i] &&
-		    strcmp(internal_desc->devs[i]->kobj_name, kobj_name) == 0) {
-			pr_err("Duplicate device %s\n", kobj_name);
-			mutex_unlock(&internal_desc->mutex);
-			return -EBUSY;
-		}
-	}
-
-	/* Find a free device slot. */
-	for (i = 0; i < GASKET_DEV_MAX; i++) {
-		if (!internal_desc->devs[i])
-			break;
-	}
-
-	if (i == GASKET_DEV_MAX) {
-		pr_err("Too many registered devices; max %d\n", GASKET_DEV_MAX);
-		mutex_unlock(&internal_desc->mutex);
-		return -EBUSY;
-	}
-
-	mutex_unlock(&internal_desc->mutex);
-	return i;
-}
-
-/*
- * PCI subsystem probe function.
- *
- * Called when a Gasket device is found. Allocates device metadata, maps device
- * memory, and calls gasket_enable_dev to prepare the device for active use.
- *
- * Returns 0 if successful and a negative value otherwise.
- */
-static int gasket_pci_probe(
-	struct pci_dev *pci_dev, const struct pci_device_id *id)
-{
-	int ret;
-	const char *kobj_name = dev_name(&pci_dev->dev);
-	struct gasket_internal_desc *internal_desc;
-	struct gasket_dev *gasket_dev;
-	const struct gasket_driver_desc *driver_desc;
-	struct device *parent;
-
-	pr_info("Add Gasket device %s\n", kobj_name);
-
-	mutex_lock(&g_mutex);
-	internal_desc = lookup_internal_desc(pci_dev);
-	mutex_unlock(&g_mutex);
-	if (!internal_desc) {
-		pr_err("PCI probe called for unknown driver type\n");
-		return -ENODEV;
-	}
-
-	driver_desc = internal_desc->driver_desc;
-
-	parent = &pci_dev->dev;
-	ret = gasket_alloc_dev(internal_desc, parent, &gasket_dev, kobj_name);
-	if (ret)
-		return ret;
-	gasket_dev->pci_dev = pci_dev_get(pci_dev);
-	if (IS_ERR_OR_NULL(gasket_dev->dev_info.device)) {
-		pr_err("Cannot create %s device %s [ret = %ld]\n",
-		       driver_desc->name, gasket_dev->dev_info.name,
-		       PTR_ERR(gasket_dev->dev_info.device));
-		ret = -ENODEV;
-		goto fail1;
-	}
-
-	ret = gasket_setup_pci(pci_dev, gasket_dev);
-	if (ret)
-		goto fail2;
-
-	ret = check_and_invoke_callback(gasket_dev, driver_desc->add_dev_cb);
-	if (ret) {
-		dev_err(gasket_dev->dev, "Error in add device cb: %d\n", ret);
-		goto fail2;
-	}
-
-	ret = gasket_sysfs_create_mapping(
-		gasket_dev->dev_info.device, gasket_dev);
-	if (ret)
-		goto fail3;
-
-	/*
-	 * Once we've created the mapping structures successfully, attempt to
-	 * create a symlink to the pci directory of this object.
-	 */
-	ret = sysfs_create_link(&gasket_dev->dev_info.device->kobj,
-				&pci_dev->dev.kobj, dev_name(&pci_dev->dev));
-	if (ret) {
-		dev_err(gasket_dev->dev,
-			"Cannot create sysfs pci link: %d\n", ret);
-		goto fail3;
-	}
-	ret = gasket_sysfs_create_entries(
-		gasket_dev->dev_info.device, gasket_sysfs_generic_attrs);
-	if (ret)
-		goto fail4;
-
-	ret = check_and_invoke_callback(
-		gasket_dev, driver_desc->sysfs_setup_cb);
-	if (ret) {
-		dev_err(gasket_dev->dev, "Error in sysfs setup cb: %d\n", ret);
-		goto fail5;
-	}
-
-	ret = gasket_enable_dev(internal_desc, gasket_dev);
-	if (ret) {
-		pr_err("cannot setup %s device\n", driver_desc->name);
-		gasket_disable_dev(gasket_dev);
-		goto fail5;
-	}
-
-	return 0;
-
-fail5:
-	check_and_invoke_callback(gasket_dev, driver_desc->sysfs_cleanup_cb);
-fail4:
-fail3:
-	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
-fail2:
-	gasket_cleanup_pci(gasket_dev);
-	check_and_invoke_callback(gasket_dev, driver_desc->remove_dev_cb);
-	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
-fail1:
-	gasket_free_dev(gasket_dev);
-	return ret;
-}
-
-/*
- * PCI subsystem remove function.
- *
- * Called to remove a Gasket device. Finds the device in the device list and
- * cleans up metadata.
- */
-static void gasket_pci_remove(struct pci_dev *pci_dev)
-{
-	int i;
-	struct gasket_internal_desc *internal_desc;
-	struct gasket_dev *gasket_dev = NULL;
-	const struct gasket_driver_desc *driver_desc;
-	/* Find the device desc. */
-	mutex_lock(&g_mutex);
-	internal_desc = lookup_internal_desc(pci_dev);
-	if (!internal_desc) {
-		mutex_unlock(&g_mutex);
-		return;
-	}
-	mutex_unlock(&g_mutex);
-
-	driver_desc = internal_desc->driver_desc;
-
-	/* Now find the specific device */
-	mutex_lock(&internal_desc->mutex);
-	for (i = 0; i < GASKET_DEV_MAX; i++) {
-		if (internal_desc->devs[i] &&
-		    internal_desc->devs[i]->pci_dev == pci_dev) {
-			gasket_dev = internal_desc->devs[i];
-			break;
-		}
-	}
-	mutex_unlock(&internal_desc->mutex);
-
-	if (!gasket_dev)
-		return;
-
-	pr_info("remove %s device %s\n", internal_desc->driver_desc->name,
-		gasket_dev->kobj_name);
-
-	gasket_disable_dev(gasket_dev);
-	gasket_cleanup_pci(gasket_dev);
-
-	check_and_invoke_callback(gasket_dev, driver_desc->sysfs_cleanup_cb);
-	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
-
-	check_and_invoke_callback(gasket_dev, driver_desc->remove_dev_cb);
-
-	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
-	gasket_free_dev(gasket_dev);
-}
-
-/*
- * Setup PCI & set up memory mapping for the specified device.
- *
- * Enables the PCI device, reads the BAR registers and sets up pointers to the
- * device's memory mapped IO space.
- *
- * Returns 0 on success and a negative value otherwise.
- */
-static int gasket_setup_pci(
-	struct pci_dev *pci_dev, struct gasket_dev *gasket_dev)
-{
-	int i, mapped_bars, ret;
-
-	ret = pci_enable_device(pci_dev);
-	if (ret) {
-		dev_err(gasket_dev->dev, "cannot enable PCI device\n");
-		return ret;
-	}
-
-	pci_set_master(pci_dev);
-
-	for (i = 0; i < GASKET_NUM_BARS; i++) {
-		ret = gasket_map_pci_bar(gasket_dev, i);
-		if (ret) {
-			mapped_bars = i;
-			goto fail;
-		}
-	}
-
-	return 0;
-
-fail:
-	for (i = 0; i < mapped_bars; i++)
-		gasket_unmap_pci_bar(gasket_dev, i);
-
-	pci_disable_device(pci_dev);
-	return -ENOMEM;
-}
-
-/* Unmaps memory and cleans up PCI for the specified device. */
-static void gasket_cleanup_pci(struct gasket_dev *gasket_dev)
-{
-	int i;
-
-	for (i = 0; i < GASKET_NUM_BARS; i++)
-		gasket_unmap_pci_bar(gasket_dev, i);
-
-	pci_disable_device(gasket_dev->pci_dev);
-}
-
-/*
- * Maps the specified bar into kernel space.
- *
- * Returns 0 on success, a negative error code otherwise.
- * A zero-sized BAR will not be mapped, but is not an error.
- */
-static int gasket_map_pci_bar(struct gasket_dev *gasket_dev, int bar_num)
-{
-	struct gasket_internal_desc *internal_desc = gasket_dev->internal_desc;
-	const struct gasket_driver_desc *driver_desc =
-		internal_desc->driver_desc;
-	ulong desc_bytes = driver_desc->bar_descriptions[bar_num].size;
-	int ret;
-
-	if (desc_bytes == 0)
-		return 0;
+	if (desc_bytes == 0)
+		return 0;
 
 	if (driver_desc->bar_descriptions[bar_num].type != PCI_BAR) {
 		/* not PCI: skip this entry */
@@ -826,320 +363,329 @@ static void gasket_unmap_pci_bar(struct gasket_dev *dev, int bar_num)
 	release_mem_region(base, bytes);
 }
 
-/* Add a char device and related info. */
-static int gasket_add_cdev(
-	struct gasket_cdev_info *dev_info,
-	const struct file_operations *file_ops, struct module *owner)
-{
-	int ret;
-
-	cdev_init(&dev_info->cdev, file_ops);
-	dev_info->cdev.owner = owner;
-	ret = cdev_add(&dev_info->cdev, dev_info->devt, 1);
-	if (ret) {
-		dev_err(dev_info->gasket_dev_ptr->dev,
-			"cannot add char device [ret=%d]\n", ret);
-		return ret;
-	}
-	dev_info->cdev_added = 1;
-
-	return 0;
-}
-
-/* Perform final init and marks the device as active. */
-static int gasket_enable_dev(
-	struct gasket_internal_desc *internal_desc,
-	struct gasket_dev *gasket_dev)
+/*
+ * Setup PCI & set up memory mapping for the specified device.
+ *
+ * Enables the PCI device, reads the BAR registers and sets up pointers to the
+ * device's memory mapped IO space.
+ *
+ * Returns 0 on success and a negative value otherwise.
+ */
+static int gasket_setup_pci(
+	struct pci_dev *pci_dev, struct gasket_dev *gasket_dev)
 {
-	int tbl_idx;
-	int ret;
-	const struct gasket_driver_desc *driver_desc =
-		internal_desc->driver_desc;
+	int i, mapped_bars, ret;
 
-	ret = gasket_interrupt_init(
-		gasket_dev, driver_desc->name,
-		driver_desc->interrupt_type, driver_desc->interrupts,
-		driver_desc->num_interrupts, driver_desc->interrupt_pack_width,
-		driver_desc->interrupt_bar_index,
-		driver_desc->wire_interrupt_offsets);
+	ret = pci_enable_device(pci_dev);
 	if (ret) {
-		dev_err(gasket_dev->dev,
-			"Critical failure to allocate interrupts: %d\n", ret);
-		gasket_interrupt_cleanup(gasket_dev);
+		dev_err(gasket_dev->dev, "cannot enable PCI device\n");
 		return ret;
 	}
 
-	for (tbl_idx = 0; tbl_idx < driver_desc->num_page_tables; tbl_idx++) {
-		dev_dbg(gasket_dev->dev, "Initializing page table %d.\n",
-			tbl_idx);
-		ret = gasket_page_table_init(
-			&gasket_dev->page_table[tbl_idx],
-			&gasket_dev->bar_data[
-				driver_desc->page_table_bar_index],
-			&driver_desc->page_table_configs[tbl_idx],
-			gasket_dev->dev, gasket_dev->pci_dev);
+	pci_set_master(pci_dev);
+
+	for (i = 0; i < GASKET_NUM_BARS; i++) {
+		ret = gasket_map_pci_bar(gasket_dev, i);
 		if (ret) {
-			dev_err(gasket_dev->dev,
-				"Couldn't init page table %d: %d\n",
-				tbl_idx, ret);
-			return ret;
+			mapped_bars = i;
+			goto fail;
 		}
-		/*
-		 * Make sure that the page table is clear and set to simple
-		 * addresses.
-		 */
-		gasket_page_table_reset(gasket_dev->page_table[tbl_idx]);
 	}
 
-	/*
-	 * hardware_revision_cb returns a positive integer (the rev) if
-	 * successful.)
-	 */
-	ret = check_and_invoke_callback(
-		gasket_dev, driver_desc->hardware_revision_cb);
-	if (ret < 0) {
-		dev_err(gasket_dev->dev,
-			"Error getting hardware revision: %d\n", ret);
-		return ret;
-	}
-	gasket_dev->hardware_revision = ret;
+	return 0;
 
-	ret = check_and_invoke_callback(gasket_dev, driver_desc->enable_dev_cb);
-	if (ret) {
-		dev_err(gasket_dev->dev, "Error in enable device cb: %d\n",
-			ret);
-		return ret;
-	}
+fail:
+	for (i = 0; i < mapped_bars; i++)
+		gasket_unmap_pci_bar(gasket_dev, i);
 
-	/* device_status_cb returns a device status, not an error code. */
-	gasket_dev->status = gasket_get_hw_status(gasket_dev);
-	if (gasket_dev->status == GASKET_STATUS_DEAD)
-		dev_err(gasket_dev->dev, "Device reported as unhealthy.\n");
+	pci_disable_device(pci_dev);
+	return -ENOMEM;
+}
 
-	ret = gasket_add_cdev(
-		&gasket_dev->dev_info, &gasket_file_ops, driver_desc->module);
-	if (ret)
-		return ret;
+/* Unmaps memory and cleans up PCI for the specified device. */
+static void gasket_cleanup_pci(struct gasket_dev *gasket_dev)
+{
+	int i;
 
-	return 0;
+	for (i = 0; i < GASKET_NUM_BARS; i++)
+		gasket_unmap_pci_bar(gasket_dev, i);
+
+	pci_disable_device(gasket_dev->pci_dev);
 }
 
-/* Disable device operations. */
-static void gasket_disable_dev(struct gasket_dev *gasket_dev)
+/* Determine the health of the Gasket device. */
+static int gasket_get_hw_status(struct gasket_dev *gasket_dev)
 {
+	int status;
+	int i;
 	const struct gasket_driver_desc *driver_desc =
 		gasket_dev->internal_desc->driver_desc;
-	int i;
-
-	/* Only delete the device if it has been successfully added. */
-	if (gasket_dev->dev_info.cdev_added)
-		cdev_del(&gasket_dev->dev_info.cdev);
 
-	gasket_dev->status = GASKET_STATUS_DEAD;
+	status = gasket_check_and_invoke_callback_nolock(
+		gasket_dev, driver_desc->device_status_cb);
+	if (status != GASKET_STATUS_ALIVE) {
+		dev_dbg(gasket_dev->dev, "Hardware reported status %d.\n",
+			status);
+		return status;
+	}
 
-	gasket_interrupt_cleanup(gasket_dev);
+	status = gasket_interrupt_system_status(gasket_dev);
+	if (status != GASKET_STATUS_ALIVE) {
+		dev_dbg(gasket_dev->dev,
+			"Interrupt system reported status %d.\n", status);
+		return status;
+	}
 
 	for (i = 0; i < driver_desc->num_page_tables; ++i) {
-		if (gasket_dev->page_table[i]) {
-			gasket_page_table_reset(gasket_dev->page_table[i]);
-			gasket_page_table_cleanup(gasket_dev->page_table[i]);
+		status = gasket_page_table_system_status(
+			gasket_dev->page_table[i]);
+		if (status != GASKET_STATUS_ALIVE) {
+			dev_dbg(gasket_dev->dev,
+				"Page table %d reported status %d.\n",
+				i, status);
+			return status;
 		}
 	}
 
-	check_and_invoke_callback(gasket_dev, driver_desc->disable_dev_cb);
+	return GASKET_STATUS_ALIVE;
 }
 
-/*
- * Registered descriptor lookup.
- *
- * Precondition: Called with g_mutex held (to avoid a race on return).
- * Returns NULL if no matching device was found.
- */
-static struct gasket_internal_desc *lookup_internal_desc(
-	struct pci_dev *pci_dev)
+static ssize_t gasket_write_mappable_regions(
+	char *buf, const struct gasket_driver_desc *driver_desc, int bar_index)
 {
 	int i;
+	ssize_t written;
+	ssize_t total_written = 0;
+	ulong min_addr, max_addr;
+	struct gasket_bar_desc bar_desc =
+		driver_desc->bar_descriptions[bar_index];
 
-	__must_hold(&g_mutex);
-	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
-		if (g_descs[i].driver_desc &&
-		    g_descs[i].driver_desc->pci_id_table &&
-		    pci_match_id(g_descs[i].driver_desc->pci_id_table, pci_dev))
-			return &g_descs[i];
+	if (bar_desc.permissions == GASKET_NOMAP)
+		return 0;
+	for (i = 0;
+	     i < bar_desc.num_mappable_regions && total_written < PAGE_SIZE;
+	     i++) {
+		min_addr = bar_desc.mappable_regions[i].start -
+			   driver_desc->legacy_mmap_address_offset;
+		max_addr = bar_desc.mappable_regions[i].start -
+			   driver_desc->legacy_mmap_address_offset +
+			   bar_desc.mappable_regions[i].length_bytes;
+		written = scnprintf(buf, PAGE_SIZE - total_written,
+				    "0x%08lx-0x%08lx\n", min_addr, max_addr);
+		total_written += written;
+		buf += written;
 	}
-
-	return NULL;
+	return total_written;
 }
 
-/**
- * Lookup a name by number in a num_name table.
- * @num: Number to lookup.
- * @table: Array of num_name structures, the table for the lookup.
- *
- * Description: Searches for num in the table.  If found, the
- *		corresponding name is returned; otherwise NULL
- *		is returned.
- *
- *		The table must have a NULL name pointer at the end.
- */
-const char *gasket_num_name_lookup(
-	uint num, const struct gasket_num_name *table)
+static ssize_t gasket_sysfs_data_show(
+	struct device *device, struct device_attribute *attr, char *buf)
 {
-	uint i = 0;
+	int i, ret = 0;
+	ssize_t current_written = 0;
+	const struct gasket_driver_desc *driver_desc;
+	struct gasket_dev *gasket_dev;
+	struct gasket_sysfs_attribute *gasket_attr;
+	const struct gasket_bar_desc *bar_desc;
+	enum gasket_sysfs_attribute_type sysfs_type;
 
-	while (table[i].snn_name) {
-		if (num == table[i].snn_num)
-			break;
-		++i;
+	gasket_dev = gasket_sysfs_get_device_data(device);
+	if (!gasket_dev) {
+		dev_err(device, "No sysfs mapping found for device\n");
+		return 0;
 	}
 
-	return table[i].snn_name;
-}
-EXPORT_SYMBOL(gasket_num_name_lookup);
-
-/*
- * Open the char device file.
- *
- * If the open is for writing, and the device is not owned, this process becomes
- * the owner.  If the open is for writing and the device is already owned by
- * some other process, it is an error.  If this process is the owner, increment
- * the open count.
- *
- * Returns 0 if successful, a negative error number otherwise.
- */
-static int gasket_open(struct inode *inode, struct file *filp)
-{
-	int ret;
-	struct gasket_dev *gasket_dev;
-	const struct gasket_driver_desc *driver_desc;
-	struct gasket_ownership *ownership;
-	char task_name[TASK_COMM_LEN];
-	struct gasket_cdev_info *dev_info =
-	    container_of(inode->i_cdev, struct gasket_cdev_info, cdev);
-	struct pid_namespace *pid_ns = task_active_pid_ns(current);
-	int is_root = ns_capable(pid_ns->user_ns, CAP_SYS_ADMIN);
+	gasket_attr = gasket_sysfs_get_attr(device, attr);
+	if (!gasket_attr) {
+		dev_err(device, "No sysfs attr found for device\n");
+		gasket_sysfs_put_device_data(device, gasket_dev);
+		return 0;
+	}
 
-	gasket_dev = dev_info->gasket_dev_ptr;
 	driver_desc = gasket_dev->internal_desc->driver_desc;
-	ownership = &dev_info->ownership;
-	get_task_comm(task_name, current);
-	filp->private_data = gasket_dev;
-	inode->i_size = 0;
-
-	dev_dbg(gasket_dev->dev,
-		"Attempting to open with tgid %u (%s) (f_mode: 0%03o, "
-		"fmode_write: %d is_root: %u)\n",
-		current->tgid, task_name, filp->f_mode,
-		(filp->f_mode & FMODE_WRITE), is_root);
 
-	/* Always allow non-writing accesses. */
-	if (!(filp->f_mode & FMODE_WRITE)) {
-		dev_dbg(gasket_dev->dev, "Allowing read-only opening.\n");
-		return 0;
+	sysfs_type =
+		(enum gasket_sysfs_attribute_type)gasket_attr->data.attr_type;
+	switch (sysfs_type) {
+	case ATTR_BAR_OFFSETS:
+		for (i = 0; i < GASKET_NUM_BARS; i++) {
+			bar_desc = &driver_desc->bar_descriptions[i];
+			if (bar_desc->size == 0)
+				continue;
+			current_written =
+				snprintf(buf, PAGE_SIZE - ret, "%d: 0x%lx\n", i,
+					 (ulong)bar_desc->base);
+			buf += current_written;
+			ret += current_written;
+		}
+		break;
+	case ATTR_BAR_SIZES:
+		for (i = 0; i < GASKET_NUM_BARS; i++) {
+			bar_desc = &driver_desc->bar_descriptions[i];
+			if (bar_desc->size == 0)
+				continue;
+			current_written =
+				snprintf(buf, PAGE_SIZE - ret, "%d: 0x%lx\n", i,
+					 (ulong)bar_desc->size);
+			buf += current_written;
+			ret += current_written;
+		}
+		break;
+	case ATTR_DRIVER_VERSION:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%s\n",
+			gasket_dev->internal_desc->driver_desc->driver_version);
+		break;
+	case ATTR_FRAMEWORK_VERSION:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%s\n", GASKET_FRAMEWORK_VERSION);
+		break;
+	case ATTR_DEVICE_TYPE:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%s\n",
+			gasket_dev->internal_desc->driver_desc->name);
+		break;
+	case ATTR_HARDWARE_REVISION:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%d\n", gasket_dev->hardware_revision);
+		break;
+	case ATTR_PCI_ADDRESS:
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", gasket_dev->kobj_name);
+		break;
+	case ATTR_STATUS:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%s\n",
+			gasket_num_name_lookup(
+				gasket_dev->status, gasket_status_name_table));
+		break;
+	case ATTR_IS_DEVICE_OWNED:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%d\n",
+			gasket_dev->dev_info.ownership.is_owned);
+		break;
+	case ATTR_DEVICE_OWNER:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%d\n",
+			gasket_dev->dev_info.ownership.owner);
+		break;
+	case ATTR_WRITE_OPEN_COUNT:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%d\n",
+			gasket_dev->dev_info.ownership.write_open_count);
+		break;
+	case ATTR_RESET_COUNT:
+		ret = snprintf(buf, PAGE_SIZE, "%d\n", gasket_dev->reset_count);
+		break;
+	case ATTR_USER_MEM_RANGES:
+		for (i = 0; i < GASKET_NUM_BARS; ++i) {
+			current_written = gasket_write_mappable_regions(
+				buf, driver_desc, i);
+			buf += current_written;
+			ret += current_written;
+		}
+		break;
+	default:
+		dev_dbg(gasket_dev->dev, "Unknown attribute: %s\n",
+			attr->attr.name);
+		ret = 0;
+		break;
 	}
 
-	mutex_lock(&gasket_dev->mutex);
+	gasket_sysfs_put_attr(device, gasket_attr);
+	gasket_sysfs_put_device_data(device, gasket_dev);
+	return ret;
+}
 
-	dev_dbg(gasket_dev->dev,
-		"Current owner open count (owning tgid %u): %d.\n",
-		ownership->owner, ownership->write_open_count);
+/* These attributes apply to all Gasket driver instances. */
+static const struct gasket_sysfs_attribute gasket_sysfs_generic_attrs[] = {
+	GASKET_SYSFS_RO(bar_offsets, gasket_sysfs_data_show, ATTR_BAR_OFFSETS),
+	GASKET_SYSFS_RO(bar_sizes, gasket_sysfs_data_show, ATTR_BAR_SIZES),
+	GASKET_SYSFS_RO(driver_version, gasket_sysfs_data_show,
+			ATTR_DRIVER_VERSION),
+	GASKET_SYSFS_RO(framework_version, gasket_sysfs_data_show,
+			ATTR_FRAMEWORK_VERSION),
+	GASKET_SYSFS_RO(device_type, gasket_sysfs_data_show, ATTR_DEVICE_TYPE),
+	GASKET_SYSFS_RO(revision, gasket_sysfs_data_show,
+			ATTR_HARDWARE_REVISION),
+	GASKET_SYSFS_RO(pci_address, gasket_sysfs_data_show, ATTR_PCI_ADDRESS),
+	GASKET_SYSFS_RO(status, gasket_sysfs_data_show, ATTR_STATUS),
+	GASKET_SYSFS_RO(is_device_owned, gasket_sysfs_data_show,
+			ATTR_IS_DEVICE_OWNED),
+	GASKET_SYSFS_RO(device_owner, gasket_sysfs_data_show,
+			ATTR_DEVICE_OWNER),
+	GASKET_SYSFS_RO(write_open_count, gasket_sysfs_data_show,
+			ATTR_WRITE_OPEN_COUNT),
+	GASKET_SYSFS_RO(reset_count, gasket_sysfs_data_show, ATTR_RESET_COUNT),
+	GASKET_SYSFS_RO(user_mem_ranges, gasket_sysfs_data_show,
+			ATTR_USER_MEM_RANGES),
+	GASKET_END_OF_ATTR_ARRAY
+};
 
-	/* Opening a node owned by another TGID is an error (unless root) */
-	if (ownership->is_owned && ownership->owner != current->tgid &&
-	    !is_root) {
-		dev_err(gasket_dev->dev,
-			"Process %u is opening a node held by %u.\n",
-			current->tgid, ownership->owner);
-		mutex_unlock(&gasket_dev->mutex);
-		return -EPERM;
-	}
+/* Add a char device and related info. */
+static int gasket_add_cdev(
+	struct gasket_cdev_info *dev_info,
+	const struct file_operations *file_ops, struct module *owner)
+{
+	int ret;
 
-	/* If the node is not owned, assign it to the current TGID. */
-	if (!ownership->is_owned) {
-		ret = gasket_check_and_invoke_callback_nolock(
-			gasket_dev, driver_desc->device_open_cb);
-		if (ret) {
-			dev_err(gasket_dev->dev,
-				"Error in device open cb: %d\n", ret);
-			mutex_unlock(&gasket_dev->mutex);
-			return ret;
-		}
-		ownership->is_owned = 1;
-		ownership->owner = current->tgid;
-		dev_dbg(gasket_dev->dev, "Device owner is now tgid %u\n",
-			ownership->owner);
+	cdev_init(&dev_info->cdev, file_ops);
+	dev_info->cdev.owner = owner;
+	ret = cdev_add(&dev_info->cdev, dev_info->devt, 1);
+	if (ret) {
+		dev_err(dev_info->gasket_dev_ptr->dev,
+			"cannot add char device [ret=%d]\n", ret);
+		return ret;
 	}
+	dev_info->cdev_added = 1;
 
-	ownership->write_open_count++;
-
-	dev_dbg(gasket_dev->dev, "New open count (owning tgid %u): %d\n",
-		ownership->owner, ownership->write_open_count);
-
-	mutex_unlock(&gasket_dev->mutex);
 	return 0;
 }
 
-/*
- * Called on a close of the device file.  If this process is the owner,
- * decrement the open count.  On last close by the owner, free up buffers and
- * eventfd contexts, and release ownership.
- *
- * Returns 0 if successful, a negative error number otherwise.
- */
-static int gasket_release(struct inode *inode, struct file *file)
+/* Disable device operations. */
+static void gasket_disable_dev(struct gasket_dev *gasket_dev)
 {
+	const struct gasket_driver_desc *driver_desc =
+		gasket_dev->internal_desc->driver_desc;
 	int i;
-	struct gasket_dev *gasket_dev;
-	struct gasket_ownership *ownership;
-	const struct gasket_driver_desc *driver_desc;
-	char task_name[TASK_COMM_LEN];
-	struct gasket_cdev_info *dev_info =
-		container_of(inode->i_cdev, struct gasket_cdev_info, cdev);
-	struct pid_namespace *pid_ns = task_active_pid_ns(current);
-	int is_root = ns_capable(pid_ns->user_ns, CAP_SYS_ADMIN);
 
-	gasket_dev = dev_info->gasket_dev_ptr;
-	driver_desc = gasket_dev->internal_desc->driver_desc;
-	ownership = &dev_info->ownership;
-	get_task_comm(task_name, current);
-	mutex_lock(&gasket_dev->mutex);
+	/* Only delete the device if it has been successfully added. */
+	if (gasket_dev->dev_info.cdev_added)
+		cdev_del(&gasket_dev->dev_info.cdev);
 
-	dev_dbg(gasket_dev->dev,
-		"Releasing device node. Call origin: tgid %u (%s) "
-		"(f_mode: 0%03o, fmode_write: %d, is_root: %u)\n",
-		current->tgid, task_name, file->f_mode,
-		(file->f_mode & FMODE_WRITE), is_root);
-	dev_dbg(gasket_dev->dev, "Current open count (owning tgid %u): %d\n",
-		ownership->owner, ownership->write_open_count);
+	gasket_dev->status = GASKET_STATUS_DEAD;
 
-	if (file->f_mode & FMODE_WRITE) {
-		ownership->write_open_count--;
-		if (ownership->write_open_count == 0) {
-			dev_dbg(gasket_dev->dev, "Device is now free\n");
-			ownership->is_owned = 0;
-			ownership->owner = 0;
+	gasket_interrupt_cleanup(gasket_dev);
 
-			/* Forces chip reset before we unmap the page tables. */
-			driver_desc->device_reset_cb(gasket_dev, 0);
+	for (i = 0; i < driver_desc->num_page_tables; ++i) {
+		if (gasket_dev->page_table[i]) {
+			gasket_page_table_reset(gasket_dev->page_table[i]);
+			gasket_page_table_cleanup(gasket_dev->page_table[i]);
+		}
+	}
 
-			for (i = 0; i < driver_desc->num_page_tables; ++i) {
-				gasket_page_table_unmap_all(
-					gasket_dev->page_table[i]);
-				gasket_page_table_garbage_collect(
-					gasket_dev->page_table[i]);
-				gasket_free_coherent_memory_all(gasket_dev, i);
-			}
+	check_and_invoke_callback(gasket_dev, driver_desc->disable_dev_cb);
+}
 
-			/* Closes device, enters power save. */
-			gasket_check_and_invoke_callback_nolock(
-				gasket_dev, driver_desc->device_close_cb);
-		}
+/*
+ * Registered descriptor lookup.
+ *
+ * Precondition: Called with g_mutex held (to avoid a race on return).
+ * Returns NULL if no matching device was found.
+ */
+static struct gasket_internal_desc *lookup_internal_desc(
+	struct pci_dev *pci_dev)
+{
+	int i;
+
+	__must_hold(&g_mutex);
+	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
+		if (g_descs[i].driver_desc &&
+		    g_descs[i].driver_desc->pci_id_table &&
+		    pci_match_id(g_descs[i].driver_desc->pci_id_table, pci_dev))
+			return &g_descs[i];
 	}
 
-	dev_dbg(gasket_dev->dev, "New open count (owning tgid %u): %d\n",
-		ownership->owner, ownership->write_open_count);
-	mutex_unlock(&gasket_dev->mutex);
-	return 0;
+	return NULL;
 }
 
 /*
@@ -1301,12 +847,42 @@ static bool gasket_mm_get_mapping_addrs(
 	return false;
 }
 
-int gasket_mm_unmap_region(
-	const struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
-	const struct gasket_mappable_region *map_region)
-{
-	ulong bar_offset;
-	ulong virt_offset;
+/*
+ * Calculates the offset where the VMA range begins in its containing BAR.
+ * The offset is written into bar_offset on success.
+ * Returns zero on success, anything else on error.
+ */
+static int gasket_mm_vma_bar_offset(
+	const struct gasket_dev *gasket_dev, const struct vm_area_struct *vma,
+	ulong *bar_offset)
+{
+	ulong raw_offset;
+	int bar_index;
+	const struct gasket_driver_desc *driver_desc =
+		gasket_dev->internal_desc->driver_desc;
+
+	raw_offset = (vma->vm_pgoff << PAGE_SHIFT) +
+		driver_desc->legacy_mmap_address_offset;
+	bar_index = gasket_get_bar_index(gasket_dev, raw_offset);
+	if (bar_index < 0) {
+		dev_err(gasket_dev->dev,
+			"Unable to find matching bar for address 0x%lx\n",
+			raw_offset);
+		trace_gasket_mmap_exit(bar_index);
+		return bar_index;
+	}
+	*bar_offset =
+		raw_offset - driver_desc->bar_descriptions[bar_index].base;
+
+	return 0;
+}
+
+int gasket_mm_unmap_region(
+	const struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
+	const struct gasket_mappable_region *map_region)
+{
+	ulong bar_offset;
+	ulong virt_offset;
 	struct gasket_mappable_region mappable_region;
 	int ret;
 
@@ -1407,36 +983,6 @@ static enum do_map_region_status do_map_region(
 	return DO_MAP_REGION_FAILURE;
 }
 
-/*
- * Calculates the offset where the VMA range begins in its containing BAR.
- * The offset is written into bar_offset on success.
- * Returns zero on success, anything else on error.
- */
-static int gasket_mm_vma_bar_offset(
-	const struct gasket_dev *gasket_dev, const struct vm_area_struct *vma,
-	ulong *bar_offset)
-{
-	ulong raw_offset;
-	int bar_index;
-	const struct gasket_driver_desc *driver_desc =
-		gasket_dev->internal_desc->driver_desc;
-
-	raw_offset = (vma->vm_pgoff << PAGE_SHIFT) +
-		driver_desc->legacy_mmap_address_offset;
-	bar_index = gasket_get_bar_index(gasket_dev, raw_offset);
-	if (bar_index < 0) {
-		dev_err(gasket_dev->dev,
-			"Unable to find matching bar for address 0x%lx\n",
-			raw_offset);
-		trace_gasket_mmap_exit(bar_index);
-		return bar_index;
-	}
-	*bar_offset =
-		raw_offset - driver_desc->bar_descriptions[bar_index].base;
-
-	return 0;
-}
-
 /* Map a region of coherent memory. */
 static int gasket_mmap_coherent(
 	struct gasket_dev *gasket_dev, struct vm_area_struct *vma)
@@ -1626,41 +1172,149 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	return ret;
 }
 
-/* Determine the health of the Gasket device. */
-static int gasket_get_hw_status(struct gasket_dev *gasket_dev)
+/*
+ * Open the char device file.
+ *
+ * If the open is for writing, and the device is not owned, this process becomes
+ * the owner.  If the open is for writing and the device is already owned by
+ * some other process, it is an error.  If this process is the owner, increment
+ * the open count.
+ *
+ * Returns 0 if successful, a negative error number otherwise.
+ */
+static int gasket_open(struct inode *inode, struct file *filp)
 {
-	int status;
-	int i;
-	const struct gasket_driver_desc *driver_desc =
-		gasket_dev->internal_desc->driver_desc;
+	int ret;
+	struct gasket_dev *gasket_dev;
+	const struct gasket_driver_desc *driver_desc;
+	struct gasket_ownership *ownership;
+	char task_name[TASK_COMM_LEN];
+	struct gasket_cdev_info *dev_info =
+	    container_of(inode->i_cdev, struct gasket_cdev_info, cdev);
+	struct pid_namespace *pid_ns = task_active_pid_ns(current);
+	int is_root = ns_capable(pid_ns->user_ns, CAP_SYS_ADMIN);
 
-	status = gasket_check_and_invoke_callback_nolock(
-		gasket_dev, driver_desc->device_status_cb);
-	if (status != GASKET_STATUS_ALIVE) {
-		dev_dbg(gasket_dev->dev, "Hardware reported status %d.\n",
-			status);
-		return status;
+	gasket_dev = dev_info->gasket_dev_ptr;
+	driver_desc = gasket_dev->internal_desc->driver_desc;
+	ownership = &dev_info->ownership;
+	get_task_comm(task_name, current);
+	filp->private_data = gasket_dev;
+	inode->i_size = 0;
+
+	dev_dbg(gasket_dev->dev,
+		"Attempting to open with tgid %u (%s) (f_mode: 0%03o, "
+		"fmode_write: %d is_root: %u)\n",
+		current->tgid, task_name, filp->f_mode,
+		(filp->f_mode & FMODE_WRITE), is_root);
+
+	/* Always allow non-writing accesses. */
+	if (!(filp->f_mode & FMODE_WRITE)) {
+		dev_dbg(gasket_dev->dev, "Allowing read-only opening.\n");
+		return 0;
 	}
 
-	status = gasket_interrupt_system_status(gasket_dev);
-	if (status != GASKET_STATUS_ALIVE) {
-		dev_dbg(gasket_dev->dev,
-			"Interrupt system reported status %d.\n", status);
-		return status;
+	mutex_lock(&gasket_dev->mutex);
+
+	dev_dbg(gasket_dev->dev,
+		"Current owner open count (owning tgid %u): %d.\n",
+		ownership->owner, ownership->write_open_count);
+
+	/* Opening a node owned by another TGID is an error (unless root) */
+	if (ownership->is_owned && ownership->owner != current->tgid &&
+	    !is_root) {
+		dev_err(gasket_dev->dev,
+			"Process %u is opening a node held by %u.\n",
+			current->tgid, ownership->owner);
+		mutex_unlock(&gasket_dev->mutex);
+		return -EPERM;
 	}
 
-	for (i = 0; i < driver_desc->num_page_tables; ++i) {
-		status = gasket_page_table_system_status(
-			gasket_dev->page_table[i]);
-		if (status != GASKET_STATUS_ALIVE) {
-			dev_dbg(gasket_dev->dev,
-				"Page table %d reported status %d.\n",
-				i, status);
-			return status;
+	/* If the node is not owned, assign it to the current TGID. */
+	if (!ownership->is_owned) {
+		ret = gasket_check_and_invoke_callback_nolock(
+			gasket_dev, driver_desc->device_open_cb);
+		if (ret) {
+			dev_err(gasket_dev->dev,
+				"Error in device open cb: %d\n", ret);
+			mutex_unlock(&gasket_dev->mutex);
+			return ret;
 		}
+		ownership->is_owned = 1;
+		ownership->owner = current->tgid;
+		dev_dbg(gasket_dev->dev, "Device owner is now tgid %u\n",
+			ownership->owner);
 	}
 
-	return GASKET_STATUS_ALIVE;
+	ownership->write_open_count++;
+
+	dev_dbg(gasket_dev->dev, "New open count (owning tgid %u): %d\n",
+		ownership->owner, ownership->write_open_count);
+
+	mutex_unlock(&gasket_dev->mutex);
+	return 0;
+}
+
+/*
+ * Called on a close of the device file.  If this process is the owner,
+ * decrement the open count.  On last close by the owner, free up buffers and
+ * eventfd contexts, and release ownership.
+ *
+ * Returns 0 if successful, a negative error number otherwise.
+ */
+static int gasket_release(struct inode *inode, struct file *file)
+{
+	int i;
+	struct gasket_dev *gasket_dev;
+	struct gasket_ownership *ownership;
+	const struct gasket_driver_desc *driver_desc;
+	char task_name[TASK_COMM_LEN];
+	struct gasket_cdev_info *dev_info =
+		container_of(inode->i_cdev, struct gasket_cdev_info, cdev);
+	struct pid_namespace *pid_ns = task_active_pid_ns(current);
+	int is_root = ns_capable(pid_ns->user_ns, CAP_SYS_ADMIN);
+
+	gasket_dev = dev_info->gasket_dev_ptr;
+	driver_desc = gasket_dev->internal_desc->driver_desc;
+	ownership = &dev_info->ownership;
+	get_task_comm(task_name, current);
+	mutex_lock(&gasket_dev->mutex);
+
+	dev_dbg(gasket_dev->dev,
+		"Releasing device node. Call origin: tgid %u (%s) "
+		"(f_mode: 0%03o, fmode_write: %d, is_root: %u)\n",
+		current->tgid, task_name, file->f_mode,
+		(file->f_mode & FMODE_WRITE), is_root);
+	dev_dbg(gasket_dev->dev, "Current open count (owning tgid %u): %d\n",
+		ownership->owner, ownership->write_open_count);
+
+	if (file->f_mode & FMODE_WRITE) {
+		ownership->write_open_count--;
+		if (ownership->write_open_count == 0) {
+			dev_dbg(gasket_dev->dev, "Device is now free\n");
+			ownership->is_owned = 0;
+			ownership->owner = 0;
+
+			/* Forces chip reset before we unmap the page tables. */
+			driver_desc->device_reset_cb(gasket_dev, 0);
+
+			for (i = 0; i < driver_desc->num_page_tables; ++i) {
+				gasket_page_table_unmap_all(
+					gasket_dev->page_table[i]);
+				gasket_page_table_garbage_collect(
+					gasket_dev->page_table[i]);
+				gasket_free_coherent_memory_all(gasket_dev, i);
+			}
+
+			/* Closes device, enters power save. */
+			gasket_check_and_invoke_callback_nolock(
+				gasket_dev, driver_desc->device_close_cb);
+		}
+	}
+
+	dev_dbg(gasket_dev->dev, "New open count (owning tgid %u): %d\n",
+		ownership->owner, ownership->write_open_count);
+	mutex_unlock(&gasket_dev->mutex);
+	return 0;
 }
 
 /*
@@ -1702,209 +1356,333 @@ static long gasket_ioctl(struct file *filp, uint cmd, ulong arg)
 	return gasket_handle_ioctl(filp, cmd, argp);
 }
 
-int gasket_reset(struct gasket_dev *gasket_dev, uint reset_type)
-{
-	int ret;
-
-	mutex_lock(&gasket_dev->mutex);
-	ret = gasket_reset_nolock(gasket_dev, reset_type);
-	mutex_unlock(&gasket_dev->mutex);
-	return ret;
-}
-EXPORT_SYMBOL(gasket_reset);
+/* File operations for all Gasket devices. */
+static const struct file_operations gasket_file_ops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.mmap = gasket_mmap,
+	.open = gasket_open,
+	.release = gasket_release,
+	.unlocked_ioctl = gasket_ioctl,
+};
 
-int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
+/* Perform final init and marks the device as active. */
+static int gasket_enable_dev(
+	struct gasket_internal_desc *internal_desc,
+	struct gasket_dev *gasket_dev)
 {
+	int tbl_idx;
 	int ret;
-	int i;
-	const struct gasket_driver_desc *driver_desc;
+	const struct gasket_driver_desc *driver_desc =
+		internal_desc->driver_desc;
 
-	driver_desc = gasket_dev->internal_desc->driver_desc;
-	if (!driver_desc->device_reset_cb)
-		return 0;
-
-	/* Perform a device reset of the requested type. */
-	ret = driver_desc->device_reset_cb(gasket_dev, reset_type);
+	ret = gasket_interrupt_init(
+		gasket_dev, driver_desc->name,
+		driver_desc->interrupt_type, driver_desc->interrupts,
+		driver_desc->num_interrupts, driver_desc->interrupt_pack_width,
+		driver_desc->interrupt_bar_index,
+		driver_desc->wire_interrupt_offsets);
 	if (ret) {
-		dev_dbg(gasket_dev->dev, "Device reset cb returned %d.\n",
-			ret);
+		dev_err(gasket_dev->dev,
+			"Critical failure to allocate interrupts: %d\n", ret);
+		gasket_interrupt_cleanup(gasket_dev);
 		return ret;
 	}
 
-	/* Reinitialize the page tables and interrupt framework. */
-	for (i = 0; i < driver_desc->num_page_tables; ++i)
-		gasket_page_table_reset(gasket_dev->page_table[i]);
+	for (tbl_idx = 0; tbl_idx < driver_desc->num_page_tables; tbl_idx++) {
+		dev_dbg(gasket_dev->dev, "Initializing page table %d.\n",
+			tbl_idx);
+		ret = gasket_page_table_init(
+			&gasket_dev->page_table[tbl_idx],
+			&gasket_dev->bar_data[
+				driver_desc->page_table_bar_index],
+			&driver_desc->page_table_configs[tbl_idx],
+			gasket_dev->dev, gasket_dev->pci_dev);
+		if (ret) {
+			dev_err(gasket_dev->dev,
+				"Couldn't init page table %d: %d\n",
+				tbl_idx, ret);
+			return ret;
+		}
+		/*
+		 * Make sure that the page table is clear and set to simple
+		 * addresses.
+		 */
+		gasket_page_table_reset(gasket_dev->page_table[tbl_idx]);
+	}
 
-	ret = gasket_interrupt_reinit(gasket_dev);
+	/*
+	 * hardware_revision_cb returns a positive integer (the rev) if
+	 * successful.)
+	 */
+	ret = check_and_invoke_callback(
+		gasket_dev, driver_desc->hardware_revision_cb);
+	if (ret < 0) {
+		dev_err(gasket_dev->dev,
+			"Error getting hardware revision: %d\n", ret);
+		return ret;
+	}
+	gasket_dev->hardware_revision = ret;
+
+	ret = check_and_invoke_callback(gasket_dev, driver_desc->enable_dev_cb);
 	if (ret) {
-		dev_dbg(gasket_dev->dev, "Unable to reinit interrupts: %d.\n",
+		dev_err(gasket_dev->dev, "Error in enable device cb: %d\n",
 			ret);
 		return ret;
 	}
 
-	/* Get current device health. */
+	/* device_status_cb returns a device status, not an error code. */
 	gasket_dev->status = gasket_get_hw_status(gasket_dev);
-	if (gasket_dev->status == GASKET_STATUS_DEAD) {
-		dev_dbg(gasket_dev->dev, "Device reported as dead.\n");
-		return -EINVAL;
-	}
+	if (gasket_dev->status == GASKET_STATUS_DEAD)
+		dev_err(gasket_dev->dev, "Device reported as unhealthy.\n");
+
+	ret = gasket_add_cdev(
+		&gasket_dev->dev_info, &gasket_file_ops, driver_desc->module);
+	if (ret)
+		return ret;
 
 	return 0;
 }
-EXPORT_SYMBOL(gasket_reset_nolock);
 
-gasket_ioctl_permissions_cb_t gasket_get_ioctl_permissions_cb(
-	struct gasket_dev *gasket_dev)
+/*
+ * PCI subsystem probe function.
+ *
+ * Called when a Gasket device is found. Allocates device metadata, maps device
+ * memory, and calls gasket_enable_dev to prepare the device for active use.
+ *
+ * Returns 0 if successful and a negative value otherwise.
+ */
+static int gasket_pci_probe(
+	struct pci_dev *pci_dev, const struct pci_device_id *id)
 {
-	return gasket_dev->internal_desc->driver_desc->ioctl_permissions_cb;
-}
-EXPORT_SYMBOL(gasket_get_ioctl_permissions_cb);
+	int ret;
+	const char *kobj_name = dev_name(&pci_dev->dev);
+	struct gasket_internal_desc *internal_desc;
+	struct gasket_dev *gasket_dev;
+	const struct gasket_driver_desc *driver_desc;
+	struct device *parent;
 
-static ssize_t gasket_write_mappable_regions(
-	char *buf, const struct gasket_driver_desc *driver_desc, int bar_index)
-{
-	int i;
-	ssize_t written;
-	ssize_t total_written = 0;
-	ulong min_addr, max_addr;
-	struct gasket_bar_desc bar_desc =
-		driver_desc->bar_descriptions[bar_index];
+	pr_info("Add Gasket device %s\n", kobj_name);
 
-	if (bar_desc.permissions == GASKET_NOMAP)
-		return 0;
-	for (i = 0;
-	     i < bar_desc.num_mappable_regions && total_written < PAGE_SIZE;
-	     i++) {
-		min_addr = bar_desc.mappable_regions[i].start -
-			   driver_desc->legacy_mmap_address_offset;
-		max_addr = bar_desc.mappable_regions[i].start -
-			   driver_desc->legacy_mmap_address_offset +
-			   bar_desc.mappable_regions[i].length_bytes;
-		written = scnprintf(buf, PAGE_SIZE - total_written,
-				    "0x%08lx-0x%08lx\n", min_addr, max_addr);
-		total_written += written;
-		buf += written;
+	mutex_lock(&g_mutex);
+	internal_desc = lookup_internal_desc(pci_dev);
+	mutex_unlock(&g_mutex);
+	if (!internal_desc) {
+		pr_err("PCI probe called for unknown driver type\n");
+		return -ENODEV;
 	}
-	return total_written;
+
+	driver_desc = internal_desc->driver_desc;
+
+	parent = &pci_dev->dev;
+	ret = gasket_alloc_dev(internal_desc, parent, &gasket_dev, kobj_name);
+	if (ret)
+		return ret;
+	gasket_dev->pci_dev = pci_dev_get(pci_dev);
+	if (IS_ERR_OR_NULL(gasket_dev->dev_info.device)) {
+		pr_err("Cannot create %s device %s [ret = %ld]\n",
+		       driver_desc->name, gasket_dev->dev_info.name,
+		       PTR_ERR(gasket_dev->dev_info.device));
+		ret = -ENODEV;
+		goto fail1;
+	}
+
+	ret = gasket_setup_pci(pci_dev, gasket_dev);
+	if (ret)
+		goto fail2;
+
+	ret = check_and_invoke_callback(gasket_dev, driver_desc->add_dev_cb);
+	if (ret) {
+		dev_err(gasket_dev->dev, "Error in add device cb: %d\n", ret);
+		goto fail2;
+	}
+
+	ret = gasket_sysfs_create_mapping(
+		gasket_dev->dev_info.device, gasket_dev);
+	if (ret)
+		goto fail3;
+
+	/*
+	 * Once we've created the mapping structures successfully, attempt to
+	 * create a symlink to the pci directory of this object.
+	 */
+	ret = sysfs_create_link(&gasket_dev->dev_info.device->kobj,
+				&pci_dev->dev.kobj, dev_name(&pci_dev->dev));
+	if (ret) {
+		dev_err(gasket_dev->dev,
+			"Cannot create sysfs pci link: %d\n", ret);
+		goto fail3;
+	}
+	ret = gasket_sysfs_create_entries(
+		gasket_dev->dev_info.device, gasket_sysfs_generic_attrs);
+	if (ret)
+		goto fail4;
+
+	ret = check_and_invoke_callback(
+		gasket_dev, driver_desc->sysfs_setup_cb);
+	if (ret) {
+		dev_err(gasket_dev->dev, "Error in sysfs setup cb: %d\n", ret);
+		goto fail5;
+	}
+
+	ret = gasket_enable_dev(internal_desc, gasket_dev);
+	if (ret) {
+		pr_err("cannot setup %s device\n", driver_desc->name);
+		gasket_disable_dev(gasket_dev);
+		goto fail5;
+	}
+
+	return 0;
+
+fail5:
+	check_and_invoke_callback(gasket_dev, driver_desc->sysfs_cleanup_cb);
+fail4:
+fail3:
+	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
+fail2:
+	gasket_cleanup_pci(gasket_dev);
+	check_and_invoke_callback(gasket_dev, driver_desc->remove_dev_cb);
+	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
+fail1:
+	gasket_free_dev(gasket_dev);
+	return ret;
 }
 
-static ssize_t gasket_sysfs_data_show(
-	struct device *device, struct device_attribute *attr, char *buf)
+/*
+ * PCI subsystem remove function.
+ *
+ * Called to remove a Gasket device. Finds the device in the device list and
+ * cleans up metadata.
+ */
+static void gasket_pci_remove(struct pci_dev *pci_dev)
 {
-	int i, ret = 0;
-	ssize_t current_written = 0;
+	int i;
+	struct gasket_internal_desc *internal_desc;
+	struct gasket_dev *gasket_dev = NULL;
 	const struct gasket_driver_desc *driver_desc;
-	struct gasket_dev *gasket_dev;
-	struct gasket_sysfs_attribute *gasket_attr;
-	const struct gasket_bar_desc *bar_desc;
-	enum gasket_sysfs_attribute_type sysfs_type;
-
-	gasket_dev = gasket_sysfs_get_device_data(device);
-	if (!gasket_dev) {
-		dev_err(device, "No sysfs mapping found for device\n");
-		return 0;
+	/* Find the device desc. */
+	mutex_lock(&g_mutex);
+	internal_desc = lookup_internal_desc(pci_dev);
+	if (!internal_desc) {
+		mutex_unlock(&g_mutex);
+		return;
 	}
+	mutex_unlock(&g_mutex);
 
-	gasket_attr = gasket_sysfs_get_attr(device, attr);
-	if (!gasket_attr) {
-		dev_err(device, "No sysfs attr found for device\n");
-		gasket_sysfs_put_device_data(device, gasket_dev);
-		return 0;
+	driver_desc = internal_desc->driver_desc;
+
+	/* Now find the specific device */
+	mutex_lock(&internal_desc->mutex);
+	for (i = 0; i < GASKET_DEV_MAX; i++) {
+		if (internal_desc->devs[i] &&
+		    internal_desc->devs[i]->pci_dev == pci_dev) {
+			gasket_dev = internal_desc->devs[i];
+			break;
+		}
 	}
+	mutex_unlock(&internal_desc->mutex);
 
-	driver_desc = gasket_dev->internal_desc->driver_desc;
+	if (!gasket_dev)
+		return;
 
-	sysfs_type =
-		(enum gasket_sysfs_attribute_type)gasket_attr->data.attr_type;
-	switch (sysfs_type) {
-	case ATTR_BAR_OFFSETS:
-		for (i = 0; i < GASKET_NUM_BARS; i++) {
-			bar_desc = &driver_desc->bar_descriptions[i];
-			if (bar_desc->size == 0)
-				continue;
-			current_written =
-				snprintf(buf, PAGE_SIZE - ret, "%d: 0x%lx\n", i,
-					 (ulong)bar_desc->base);
-			buf += current_written;
-			ret += current_written;
-		}
-		break;
-	case ATTR_BAR_SIZES:
-		for (i = 0; i < GASKET_NUM_BARS; i++) {
-			bar_desc = &driver_desc->bar_descriptions[i];
-			if (bar_desc->size == 0)
-				continue;
-			current_written =
-				snprintf(buf, PAGE_SIZE - ret, "%d: 0x%lx\n", i,
-					 (ulong)bar_desc->size);
-			buf += current_written;
-			ret += current_written;
-		}
-		break;
-	case ATTR_DRIVER_VERSION:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%s\n",
-			gasket_dev->internal_desc->driver_desc->driver_version);
-		break;
-	case ATTR_FRAMEWORK_VERSION:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%s\n", GASKET_FRAMEWORK_VERSION);
-		break;
-	case ATTR_DEVICE_TYPE:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%s\n",
-			gasket_dev->internal_desc->driver_desc->name);
-		break;
-	case ATTR_HARDWARE_REVISION:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%d\n", gasket_dev->hardware_revision);
-		break;
-	case ATTR_PCI_ADDRESS:
-		ret = snprintf(buf, PAGE_SIZE, "%s\n", gasket_dev->kobj_name);
-		break;
-	case ATTR_STATUS:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%s\n",
-			gasket_num_name_lookup(
-				gasket_dev->status, gasket_status_name_table));
-		break;
-	case ATTR_IS_DEVICE_OWNED:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%d\n",
-			gasket_dev->dev_info.ownership.is_owned);
-		break;
-	case ATTR_DEVICE_OWNER:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%d\n",
-			gasket_dev->dev_info.ownership.owner);
-		break;
-	case ATTR_WRITE_OPEN_COUNT:
-		ret = snprintf(
-			buf, PAGE_SIZE, "%d\n",
-			gasket_dev->dev_info.ownership.write_open_count);
-		break;
-	case ATTR_RESET_COUNT:
-		ret = snprintf(buf, PAGE_SIZE, "%d\n", gasket_dev->reset_count);
-		break;
-	case ATTR_USER_MEM_RANGES:
-		for (i = 0; i < GASKET_NUM_BARS; ++i) {
-			current_written = gasket_write_mappable_regions(
-				buf, driver_desc, i);
-			buf += current_written;
-			ret += current_written;
-		}
-		break;
-	default:
-		dev_dbg(gasket_dev->dev, "Unknown attribute: %s\n",
-			attr->attr.name);
-		ret = 0;
-		break;
+	pr_info("remove %s device %s\n", internal_desc->driver_desc->name,
+		gasket_dev->kobj_name);
+
+	gasket_disable_dev(gasket_dev);
+	gasket_cleanup_pci(gasket_dev);
+
+	check_and_invoke_callback(gasket_dev, driver_desc->sysfs_cleanup_cb);
+	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
+
+	check_and_invoke_callback(gasket_dev, driver_desc->remove_dev_cb);
+
+	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
+	gasket_free_dev(gasket_dev);
+}
+
+/**
+ * Lookup a name by number in a num_name table.
+ * @num: Number to lookup.
+ * @table: Array of num_name structures, the table for the lookup.
+ *
+ * Description: Searches for num in the table.  If found, the
+ *		corresponding name is returned; otherwise NULL
+ *		is returned.
+ *
+ *		The table must have a NULL name pointer at the end.
+ */
+const char *gasket_num_name_lookup(
+	uint num, const struct gasket_num_name *table)
+{
+	uint i = 0;
+
+	while (table[i].snn_name) {
+		if (num == table[i].snn_num)
+			break;
+		++i;
 	}
 
-	gasket_sysfs_put_attr(device, gasket_attr);
-	gasket_sysfs_put_device_data(device, gasket_dev);
+	return table[i].snn_name;
+}
+EXPORT_SYMBOL(gasket_num_name_lookup);
+
+int gasket_reset(struct gasket_dev *gasket_dev, uint reset_type)
+{
+	int ret;
+
+	mutex_lock(&gasket_dev->mutex);
+	ret = gasket_reset_nolock(gasket_dev, reset_type);
+	mutex_unlock(&gasket_dev->mutex);
 	return ret;
 }
+EXPORT_SYMBOL(gasket_reset);
+
+int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
+{
+	int ret;
+	int i;
+	const struct gasket_driver_desc *driver_desc;
+
+	driver_desc = gasket_dev->internal_desc->driver_desc;
+	if (!driver_desc->device_reset_cb)
+		return 0;
+
+	/* Perform a device reset of the requested type. */
+	ret = driver_desc->device_reset_cb(gasket_dev, reset_type);
+	if (ret) {
+		dev_dbg(gasket_dev->dev, "Device reset cb returned %d.\n",
+			ret);
+		return ret;
+	}
+
+	/* Reinitialize the page tables and interrupt framework. */
+	for (i = 0; i < driver_desc->num_page_tables; ++i)
+		gasket_page_table_reset(gasket_dev->page_table[i]);
+
+	ret = gasket_interrupt_reinit(gasket_dev);
+	if (ret) {
+		dev_dbg(gasket_dev->dev, "Unable to reinit interrupts: %d.\n",
+			ret);
+		return ret;
+	}
+
+	/* Get current device health. */
+	gasket_dev->status = gasket_get_hw_status(gasket_dev);
+	if (gasket_dev->status == GASKET_STATUS_DEAD) {
+		dev_dbg(gasket_dev->dev, "Device reported as dead.\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(gasket_reset_nolock);
+
+gasket_ioctl_permissions_cb_t gasket_get_ioctl_permissions_cb(
+	struct gasket_dev *gasket_dev)
+{
+	return gasket_dev->internal_desc->driver_desc->ioctl_permissions_cb;
+}
+EXPORT_SYMBOL(gasket_get_ioctl_permissions_cb);
 
 /* Get the driver structure for a given gasket_dev.
  * @dev: pointer to gasket_dev, implementing the requested driver.
@@ -1954,3 +1732,169 @@ int gasket_wait_with_reschedule(
 	return -ETIMEDOUT;
 }
 EXPORT_SYMBOL(gasket_wait_with_reschedule);
+
+/* See gasket_core.h for description. */
+int gasket_register_device(const struct gasket_driver_desc *driver_desc)
+{
+	int i, ret;
+	int desc_idx = -1;
+	struct gasket_internal_desc *internal;
+
+	pr_info("Initializing Gasket framework device\n");
+	/* Check for duplicates and find a free slot. */
+	mutex_lock(&g_mutex);
+
+	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
+		if (g_descs[i].driver_desc == driver_desc) {
+			pr_err("%s driver already loaded/registered\n",
+			       driver_desc->name);
+			mutex_unlock(&g_mutex);
+			return -EBUSY;
+		}
+	}
+
+	/* This and the above loop could be combined, but this reads easier. */
+	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
+		if (!g_descs[i].driver_desc) {
+			g_descs[i].driver_desc = driver_desc;
+			desc_idx = i;
+			break;
+		}
+	}
+	mutex_unlock(&g_mutex);
+
+	pr_info("Loaded %s driver, framework version %s\n",
+		driver_desc->name, GASKET_FRAMEWORK_VERSION);
+
+	if (desc_idx == -1) {
+		pr_err("Too many Gasket drivers loaded: %d\n",
+		       GASKET_FRAMEWORK_DESC_MAX);
+		return -EBUSY;
+	}
+
+	/* Internal structure setup. */
+	pr_debug("Performing initial internal structure setup.\n");
+	internal = &g_descs[desc_idx];
+	mutex_init(&internal->mutex);
+	memset(internal->devs, 0, sizeof(struct gasket_dev *) * GASKET_DEV_MAX);
+	memset(&internal->pci, 0, sizeof(internal->pci));
+	internal->pci.name = driver_desc->name;
+	internal->pci.id_table = driver_desc->pci_id_table;
+	internal->pci.probe = gasket_pci_probe;
+	internal->pci.remove = gasket_pci_remove;
+	internal->class =
+		class_create(driver_desc->module, driver_desc->name);
+
+	if (IS_ERR(internal->class)) {
+		pr_err("Cannot register %s class [ret=%ld]\n",
+		       driver_desc->name, PTR_ERR(internal->class));
+		ret = PTR_ERR(internal->class);
+		goto unregister_gasket_driver;
+	}
+
+	/*
+	 * Not using pci_register_driver() (without underscores), as it
+	 * depends on KBUILD_MODNAME, and this is a shared file.
+	 */
+	pr_debug("Registering PCI driver.\n");
+	ret = __pci_register_driver(
+		&internal->pci, driver_desc->module, driver_desc->name);
+	if (ret) {
+		pr_err("cannot register pci driver [ret=%d]\n", ret);
+		goto fail1;
+	}
+
+	pr_debug("Registering char driver.\n");
+	ret = register_chrdev_region(
+		MKDEV(driver_desc->major, driver_desc->minor), GASKET_DEV_MAX,
+		driver_desc->name);
+	if (ret) {
+		pr_err("cannot register char driver [ret=%d]\n", ret);
+		goto fail2;
+	}
+
+	pr_info("Driver registered successfully.\n");
+	return 0;
+
+fail2:
+	pci_unregister_driver(&internal->pci);
+
+fail1:
+	class_destroy(internal->class);
+
+unregister_gasket_driver:
+	mutex_lock(&g_mutex);
+	g_descs[desc_idx].driver_desc = NULL;
+	mutex_unlock(&g_mutex);
+	return ret;
+}
+EXPORT_SYMBOL(gasket_register_device);
+
+/* See gasket_core.h for description. */
+void gasket_unregister_device(const struct gasket_driver_desc *driver_desc)
+{
+	int i, desc_idx;
+	struct gasket_internal_desc *internal_desc = NULL;
+
+	mutex_lock(&g_mutex);
+	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
+		if (g_descs[i].driver_desc == driver_desc) {
+			internal_desc = &g_descs[i];
+			desc_idx = i;
+			break;
+		}
+	}
+	mutex_unlock(&g_mutex);
+
+	if (!internal_desc) {
+		pr_err("request to unregister unknown desc: %s, %d:%d\n",
+		       driver_desc->name, driver_desc->major,
+		       driver_desc->minor);
+		return;
+	}
+
+	unregister_chrdev_region(
+		MKDEV(driver_desc->major, driver_desc->minor), GASKET_DEV_MAX);
+
+	pci_unregister_driver(&internal_desc->pci);
+
+	class_destroy(internal_desc->class);
+
+	/* Finally, effectively "remove" the driver. */
+	mutex_lock(&g_mutex);
+	g_descs[desc_idx].driver_desc = NULL;
+	mutex_unlock(&g_mutex);
+
+	pr_info("removed %s driver\n", driver_desc->name);
+}
+EXPORT_SYMBOL(gasket_unregister_device);
+
+static int __init gasket_init(void)
+{
+	int i;
+
+	pr_info("Performing one-time init of the Gasket framework.\n");
+	/* Check for duplicates and find a free slot. */
+	mutex_lock(&g_mutex);
+	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
+		g_descs[i].driver_desc = NULL;
+		mutex_init(&g_descs[i].mutex);
+	}
+
+	gasket_sysfs_init();
+
+	mutex_unlock(&g_mutex);
+	return 0;
+}
+
+static void __exit gasket_exit(void)
+{
+	/* No deinit/dealloc needed at present. */
+	pr_info("Removing Gasket framework module.\n");
+}
+MODULE_DESCRIPTION("Google Gasket driver framework");
+MODULE_VERSION(GASKET_FRAMEWORK_VERSION);
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Rob Springer <rspringer@google.com>");
+module_init(gasket_init);
+module_exit(gasket_exit);

commit f975c995e76be54c14fd742b816bc1b2123e625d
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Jul 29 12:36:39 2018 -0700

    staging: gasket: core: simplify comments for static functions
    
    Static functions don't need kernel doc formatting, can be simplified.
    Reformat comments that can be single-line.  Remove extraneous text.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 291cd6d074a2..c00774059f9e 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -199,11 +199,7 @@ MODULE_AUTHOR("Rob Springer <rspringer@google.com>");
 module_init(gasket_init);
 module_exit(gasket_exit);
 
-/*
- * Perform a standard Gasket callback.
- * @gasket_dev: Device specific pointer to forward.
- * @cb_function: Standard callback to perform.
- */
+/* Perform a standard Gasket callback. */
 static inline int check_and_invoke_callback(
 	struct gasket_dev *gasket_dev, int (*cb_function)(struct gasket_dev *))
 {
@@ -219,13 +215,7 @@ static inline int check_and_invoke_callback(
 	return ret;
 }
 
-/*
- * Perform a standard Gasket callback
- * without grabbing gasket_dev->mutex.
- * @gasket_dev: Device specific pointer to forward.
- * @cb_function: Standard callback to perform.
- *
- */
+/* Perform a standard Gasket callback without grabbing gasket_dev->mutex. */
 static inline int gasket_check_and_invoke_callback_nolock(
 	struct gasket_dev *gasket_dev, int (*cb_function)(struct gasket_dev *))
 {
@@ -240,9 +230,8 @@ static inline int gasket_check_and_invoke_callback_nolock(
 }
 
 /*
- * Returns nonzero if the gasket_cdev_info is owned by the current thread group
+ * Return nonzero if the gasket_cdev_info is owned by the current thread group
  * ID.
- * @info: Device node info.
  */
 static int gasket_owned_by_current_tgid(struct gasket_cdev_info *info)
 {
@@ -410,14 +399,9 @@ void gasket_unregister_device(const struct gasket_driver_desc *driver_desc)
 }
 EXPORT_SYMBOL(gasket_unregister_device);
 
-/**
- * Allocate a Gasket device.
- * @internal_desc: Pointer to the internal data for the device driver.
- * @pdev: Pointer to the Gasket device pointer, the allocated device.
- * @kobj_name: PCIe name for the device
- *
- * Description: Allocates and initializes a Gasket device structure.
- *              Adds the device to the device list.
+/*
+ * Allocate and initialize a Gasket device structure, add the device to the
+ * device list.
  *
  * Returns 0 if successful, a negative error code otherwise.
  */
@@ -476,13 +460,7 @@ static int gasket_alloc_dev(
 	return 0;
 }
 
-/*
- * Free a Gasket device.
- * @internal_dev: Gasket device pointer; the device to unregister and free.
- *
- * Description: Removes the device from the device list and frees
- *              the Gasket device structure.
- */
+/* Free a Gasket device. */
 static void gasket_free_dev(struct gasket_dev *gasket_dev)
 {
 	struct gasket_internal_desc *internal_desc = gasket_dev->internal_desc;
@@ -496,7 +474,7 @@ static void gasket_free_dev(struct gasket_dev *gasket_dev)
 }
 
 /*
- * Finds the next free gasket_internal_dev slot.
+ * Find the next free gasket_internal_dev slot.
  *
  * Returns the located slot number on success or a negative number on failure.
  */
@@ -533,10 +511,8 @@ static int gasket_find_dev_slot(
 	return i;
 }
 
-/**
+/*
  * PCI subsystem probe function.
- * @pci_dev: PCI device pointer to the new device.
- * @id: PCI device id structure pointer, the vendor and device ids.
  *
  * Called when a Gasket device is found. Allocates device metadata, maps device
  * memory, and calls gasket_enable_dev to prepare the device for active use.
@@ -641,7 +617,6 @@ static int gasket_pci_probe(
 
 /*
  * PCI subsystem remove function.
- * @pci_dev: PCI device pointer; the device to remove.
  *
  * Called to remove a Gasket device. Finds the device in the device list and
  * cleans up metadata.
@@ -694,8 +669,6 @@ static void gasket_pci_remove(struct pci_dev *pci_dev)
 
 /*
  * Setup PCI & set up memory mapping for the specified device.
- * @pci_dev: pointer to the particular PCI device.
- * @internal_dev: Corresponding Gasket device pointer.
  *
  * Enables the PCI device, reads the BAR registers and sets up pointers to the
  * device's memory mapped IO space.
@@ -746,8 +719,6 @@ static void gasket_cleanup_pci(struct gasket_dev *gasket_dev)
 
 /*
  * Maps the specified bar into kernel space.
- * @internal_dev: Device possessing the BAR to map.
- * @bar_num: The BAR to map.
  *
  * Returns 0 on success, a negative error code otherwise.
  * A zero-sized BAR will not be mapped, but is not an error.
@@ -824,7 +795,6 @@ static int gasket_map_pci_bar(struct gasket_dev *gasket_dev, int bar_num)
 
 /*
  * Releases PCI BAR mapping.
- * @internal_dev: Device possessing the BAR to unmap.
  *
  * A zero-sized or not-mapped BAR will not be unmapped, but is not an error.
  */
@@ -856,12 +826,7 @@ static void gasket_unmap_pci_bar(struct gasket_dev *dev, int bar_num)
 	release_mem_region(base, bytes);
 }
 
-/*
- * Handle adding a char device and related info.
- * @dev_info: Pointer to the dev_info struct for this device.
- * @file_ops: The file operations for this device.
- * @owner: The owning module for this device.
- */
+/* Add a char device and related info. */
 static int gasket_add_cdev(
 	struct gasket_cdev_info *dev_info,
 	const struct file_operations *file_ops, struct module *owner)
@@ -881,14 +846,7 @@ static int gasket_add_cdev(
 	return 0;
 }
 
-/*
- * Performs final init and marks the device as active.
- * @internal_desc: Pointer to Gasket [internal] driver descriptor structure.
- * @internal_dev: Pointer to Gasket [internal] device structure.
- *
- * Currently forwards all work to device-specific callback; a future phase will
- * extract elements of character device registration here.
- */
+/* Perform final init and marks the device as active. */
 static int gasket_enable_dev(
 	struct gasket_internal_desc *internal_desc,
 	struct gasket_dev *gasket_dev)
@@ -966,13 +924,7 @@ static int gasket_enable_dev(
 	return 0;
 }
 
-/*
- * Disable device operations.
- * @gasket_dev: Pointer to Gasket device structure.
- *
- * Currently forwards all work to device-specific callback; a future phase will
- * extract elements of character device unregistration here.
- */
+/* Disable device operations. */
 static void gasket_disable_dev(struct gasket_dev *gasket_dev)
 {
 	const struct gasket_driver_desc *driver_desc =
@@ -997,7 +949,7 @@ static void gasket_disable_dev(struct gasket_dev *gasket_dev)
 	check_and_invoke_callback(gasket_dev, driver_desc->disable_dev_cb);
 }
 
-/**
+/*
  * Registered descriptor lookup.
  *
  * Precondition: Called with g_mutex held (to avoid a race on return).
@@ -1045,18 +997,15 @@ const char *gasket_num_name_lookup(
 }
 EXPORT_SYMBOL(gasket_num_name_lookup);
 
-/**
- * Opens the char device file.
- * @inode: Inode structure pointer of the device file.
- * @file: File structure pointer.
+/*
+ * Open the char device file.
  *
- * Description: Called on an open of the device file.  If the open is for
- *              writing, and the device is not owned, this process becomes
- *              the owner.  If the open is for writing and the device is
- *              already owned by some other process, it is an error.  If
- *              this process is the owner, increment the open count.
+ * If the open is for writing, and the device is not owned, this process becomes
+ * the owner.  If the open is for writing and the device is already owned by
+ * some other process, it is an error.  If this process is the owner, increment
+ * the open count.
  *
- *              Returns 0 if successful, a negative error number otherwise.
+ * Returns 0 if successful, a negative error number otherwise.
  */
 static int gasket_open(struct inode *inode, struct file *filp)
 {
@@ -1130,17 +1079,12 @@ static int gasket_open(struct inode *inode, struct file *filp)
 	return 0;
 }
 
-/**
- * gasket_release - Close of the char device file.
- * @inode: Inode structure pointer of the device file.
- * @file: File structure pointer.
- *
- * Description: Called on a close of the device file.  If this process
- *              is the owner, decrement the open count.  On last close
- *              by the owner, free up buffers and eventfd contexts, and
- *              release ownership.
+/*
+ * Called on a close of the device file.  If this process is the owner,
+ * decrement the open count.  On last close by the owner, free up buffers and
+ * eventfd contexts, and release ownership.
  *
- *              Returns 0 if successful, a negative error number otherwise.
+ * Returns 0 if successful, a negative error number otherwise.
  */
 static int gasket_release(struct inode *inode, struct file *file)
 {
@@ -1199,10 +1143,6 @@ static int gasket_release(struct inode *inode, struct file *file)
 }
 
 /*
- * Permission and validity checking for mmap ops.
- * @gasket_dev: Gasket device information structure.
- * @vma: Standard virtual memory area descriptor.
- *
  * Verifies that the user has permissions to perform the requested mapping and
  * that the provided descriptor/range is of adequate size to hold the range to
  * be mapped.
@@ -1246,11 +1186,6 @@ static bool gasket_mmap_has_permissions(
 }
 
 /*
- * Checks if an address is within the region
- * allocated for coherent buffer.
- * @driver_desc: driver description.
- * @address: offset of address to check.
- *
  * Verifies that the input address is within the region allocated to coherent
  * buffer.
  */
@@ -1502,11 +1437,7 @@ static int gasket_mm_vma_bar_offset(
 	return 0;
 }
 
-/*
- * Map a region of coherent memory.
- * @gasket_dev: Gasket device handle.
- * @vma: Virtual memory area descriptor with region to map.
- */
+/* Map a region of coherent memory. */
 static int gasket_mmap_coherent(
 	struct gasket_dev *gasket_dev, struct vm_area_struct *vma)
 {
@@ -1551,16 +1482,7 @@ static int gasket_mmap_coherent(
 	return 0;
 }
 
-/*
- * Maps a device's BARs into user space.
- * @filp: File structure pointer describing this node usage session.
- * @vma: Standard virtual memory area descriptor.
- *
- * Maps the entirety of each of the device's BAR ranges into the user memory
- * range specified by vma.
- *
- * Returns 0 on success, a negative errno on error.
- */
+/* Map a device's BARs into user space. */
 static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 {
 	int i, ret;
@@ -1704,14 +1626,7 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	return ret;
 }
 
-/*
- * Determine the health of the Gasket device.
- * @gasket_dev: Gasket device structure.
- *
- * Checks the underlying device health (via the device_status_cb)
- * and the status of initialized Gasket code systems (currently
- * only interrupts), then returns a gasket_status appropriately.
- */
+/* Determine the health of the Gasket device. */
 static int gasket_get_hw_status(struct gasket_dev *gasket_dev)
 {
 	int status;
@@ -1750,14 +1665,10 @@ static int gasket_get_hw_status(struct gasket_dev *gasket_dev)
 
 /*
  * Gasket ioctl dispatch function.
- * @filp: File structure pointer describing this node usage session.
- * @cmd: ioctl number to handle.
- * @arg: ioctl-specific data pointer.
  *
- * First, checks if the ioctl is a generic ioctl. If not, it passes
- * the ioctl to the ioctl_handler_cb registered in the driver description.
- * If the ioctl is a generic ioctl, the function passes it to the
- * gasket_ioctl_handler in gasket_ioctl.c.
+ * Check if the ioctl is a generic ioctl. If not, pass the ioctl to the
+ * ioctl_handler_cb registered in the driver description.
+ * If the ioctl is a generic ioctl, pass it to gasket_ioctl_handler.
  */
 static long gasket_ioctl(struct file *filp, uint cmd, ulong arg)
 {

commit f9a4963019291b8ea7f2bb473b2caa7ff2238633
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Jul 29 12:36:37 2018 -0700

    staging: gasket: core: allow root access based on user namespace
    
    Use user namespace to determine whether gasket device file opener is
    root, allowing root access to containers, if necessary.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index b832a4f529f2..291cd6d074a2 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -13,13 +13,16 @@
 #include "gasket_page_table.h"
 #include "gasket_sysfs.h"
 
+#include <linux/capability.h>
 #include <linux/compiler.h>
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/init.h>
 #include <linux/of.h>
+#include <linux/pid_namespace.h>
 #include <linux/printk.h>
+#include <linux/sched.h>
 
 #ifdef GASKET_KERNEL_TRACE_SUPPORT
 #define CREATE_TRACE_POINTS
@@ -1064,7 +1067,8 @@ static int gasket_open(struct inode *inode, struct file *filp)
 	char task_name[TASK_COMM_LEN];
 	struct gasket_cdev_info *dev_info =
 	    container_of(inode->i_cdev, struct gasket_cdev_info, cdev);
-	int is_root = capable(CAP_SYS_ADMIN);
+	struct pid_namespace *pid_ns = task_active_pid_ns(current);
+	int is_root = ns_capable(pid_ns->user_ns, CAP_SYS_ADMIN);
 
 	gasket_dev = dev_info->gasket_dev_ptr;
 	driver_desc = gasket_dev->internal_desc->driver_desc;
@@ -1147,6 +1151,8 @@ static int gasket_release(struct inode *inode, struct file *file)
 	char task_name[TASK_COMM_LEN];
 	struct gasket_cdev_info *dev_info =
 		container_of(inode->i_cdev, struct gasket_cdev_info, cdev);
+	struct pid_namespace *pid_ns = task_active_pid_ns(current);
+	int is_root = ns_capable(pid_ns->user_ns, CAP_SYS_ADMIN);
 
 	gasket_dev = dev_info->gasket_dev_ptr;
 	driver_desc = gasket_dev->internal_desc->driver_desc;
@@ -1158,7 +1164,7 @@ static int gasket_release(struct inode *inode, struct file *file)
 		"Releasing device node. Call origin: tgid %u (%s) "
 		"(f_mode: 0%03o, fmode_write: %d, is_root: %u)\n",
 		current->tgid, task_name, file->f_mode,
-		(file->f_mode & FMODE_WRITE), capable(CAP_SYS_ADMIN));
+		(file->f_mode & FMODE_WRITE), is_root);
 	dev_dbg(gasket_dev->dev, "Current open count (owning tgid %u): %d\n",
 		ownership->owner, ownership->write_open_count);
 

commit 8dd8a48b9a7dae5493494a8603adddfdf1914716
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Jul 29 12:36:34 2018 -0700

    staging: gasket: core: hold reference to pci_dev while used
    
    Hold a reference on the struct pci_dev while a pointer to it is held in
    the gasket data structures.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 2b484d067c38..b832a4f529f2 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -488,6 +488,7 @@ static void gasket_free_dev(struct gasket_dev *gasket_dev)
 	internal_desc->devs[gasket_dev->dev_idx] = NULL;
 	mutex_unlock(&internal_desc->mutex);
 	put_device(gasket_dev->dev);
+	pci_dev_put(gasket_dev->pci_dev);
 	kfree(gasket_dev);
 }
 
@@ -565,6 +566,7 @@ static int gasket_pci_probe(
 	ret = gasket_alloc_dev(internal_desc, parent, &gasket_dev, kobj_name);
 	if (ret)
 		return ret;
+	gasket_dev->pci_dev = pci_dev_get(pci_dev);
 	if (IS_ERR_OR_NULL(gasket_dev->dev_info.device)) {
 		pr_err("Cannot create %s device %s [ret = %ld]\n",
 		       driver_desc->name, gasket_dev->dev_info.name,
@@ -572,7 +574,6 @@ static int gasket_pci_probe(
 		ret = -ENODEV;
 		goto fail1;
 	}
-	gasket_dev->pci_dev = pci_dev;
 
 	ret = gasket_setup_pci(pci_dev, gasket_dev);
 	if (ret)
@@ -703,7 +704,6 @@ static int gasket_setup_pci(
 {
 	int i, mapped_bars, ret;
 
-	gasket_dev->pci_dev = pci_dev;
 	ret = pci_enable_device(pci_dev);
 	if (ret) {
 		dev_err(gasket_dev->dev, "cannot enable PCI device\n");

commit 5b6e80cc9806a5cf78f68df2b6b64812b51d91c9
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sat Jul 28 12:33:24 2018 -0700

    staging: gasket: core: hold reference on device while in use
    
    Hold a reference on the struct device while a pointer to that
    device is in use by gasket.
    
    Reported-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 859a6df9e12d..2b484d067c38 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -448,7 +448,7 @@ static int gasket_alloc_dev(
 	gasket_dev->internal_desc = internal_desc;
 	gasket_dev->dev_idx = dev_idx;
 	snprintf(gasket_dev->kobj_name, GASKET_NAME_MAX, "%s", kobj_name);
-	gasket_dev->dev = parent;
+	gasket_dev->dev = get_device(parent);
 	/* gasket_bar_data is uninitialized. */
 	gasket_dev->num_page_tables = driver_desc->num_page_tables;
 	/* max_page_table_size and *page table are uninit'ed */
@@ -487,7 +487,7 @@ static void gasket_free_dev(struct gasket_dev *gasket_dev)
 	mutex_lock(&internal_desc->mutex);
 	internal_desc->devs[gasket_dev->dev_idx] = NULL;
 	mutex_unlock(&internal_desc->mutex);
-
+	put_device(gasket_dev->dev);
 	kfree(gasket_dev);
 }
 

commit 758c579ec631ce5efd8de3d3d35483416ae2cad1
Author: Todd Poynor <toddpoynor@google.com>
Date:   Fri Jul 27 22:21:59 2018 -0700

    staging: gasket: page table: remove code for "no dma_ops"
    
    Remove code with TODOs on it for working around apparent problems
    previously seen in a qemu environment where dma_ops was not set
    correctly.  There is no user of this in the current code.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index f44805c38159..859a6df9e12d 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -916,7 +916,7 @@ static int gasket_enable_dev(
 			&gasket_dev->bar_data[
 				driver_desc->page_table_bar_index],
 			&driver_desc->page_table_configs[tbl_idx],
-			gasket_dev->dev, gasket_dev->pci_dev, true);
+			gasket_dev->dev, gasket_dev->pci_dev);
 		if (ret) {
 			dev_err(gasket_dev->dev,
 				"Couldn't init page table %d: %d\n",

commit 803ff424e46260d058daa998cc474639ca017f38
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 26 20:07:29 2018 -0700

    staging: gasket: core: convert to standard logging
    
    Use standard logging functions, drop use of gasket log functions.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index e8f3b021c20d..f44805c38159 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -10,15 +10,16 @@
 
 #include "gasket_interrupt.h"
 #include "gasket_ioctl.h"
-#include "gasket_logging.h"
 #include "gasket_page_table.h"
 #include "gasket_sysfs.h"
 
 #include <linux/compiler.h>
 #include <linux/delay.h>
+#include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/init.h>
 #include <linux/of.h>
+#include <linux/printk.h>
 
 #ifdef GASKET_KERNEL_TRACE_SUPPORT
 #define CREATE_TRACE_POINTS
@@ -205,8 +206,8 @@ static inline int check_and_invoke_callback(
 {
 	int ret = 0;
 
-	gasket_log_debug(gasket_dev, "check_and_invoke_callback %p",
-			 cb_function);
+	dev_dbg(gasket_dev->dev, "check_and_invoke_callback %p\n",
+		cb_function);
 	if (cb_function) {
 		mutex_lock(&gasket_dev->mutex);
 		ret = cb_function(gasket_dev);
@@ -228,8 +229,8 @@ static inline int gasket_check_and_invoke_callback_nolock(
 	int ret = 0;
 
 	if (cb_function) {
-		gasket_log_debug(
-			gasket_dev, "Invoking device-specific callback.");
+		dev_dbg(gasket_dev->dev,
+			"Invoking device-specific callback.\n");
 		ret = cb_function(gasket_dev);
 	}
 	return ret;
@@ -250,7 +251,7 @@ static int __init gasket_init(void)
 {
 	int i;
 
-	gasket_nodev_info("Performing one-time init of the Gasket framework.");
+	pr_info("Performing one-time init of the Gasket framework.\n");
 	/* Check for duplicates and find a free slot. */
 	mutex_lock(&g_mutex);
 	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
@@ -267,7 +268,7 @@ static int __init gasket_init(void)
 static void __exit gasket_exit(void)
 {
 	/* No deinit/dealloc needed at present. */
-	gasket_nodev_info("Removing Gasket framework module.");
+	pr_info("Removing Gasket framework module.\n");
 }
 
 /* See gasket_core.h for description. */
@@ -277,15 +278,14 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 	int desc_idx = -1;
 	struct gasket_internal_desc *internal;
 
-	gasket_nodev_info("Initializing Gasket framework device");
+	pr_info("Initializing Gasket framework device\n");
 	/* Check for duplicates and find a free slot. */
 	mutex_lock(&g_mutex);
 
 	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
 		if (g_descs[i].driver_desc == driver_desc) {
-			gasket_nodev_error(
-				"%s driver already loaded/registered",
-				driver_desc->name);
+			pr_err("%s driver already loaded/registered\n",
+			       driver_desc->name);
 			mutex_unlock(&g_mutex);
 			return -EBUSY;
 		}
@@ -301,17 +301,17 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 	}
 	mutex_unlock(&g_mutex);
 
-	gasket_nodev_info("Loaded %s driver, framework version %s",
-			  driver_desc->name, GASKET_FRAMEWORK_VERSION);
+	pr_info("Loaded %s driver, framework version %s\n",
+		driver_desc->name, GASKET_FRAMEWORK_VERSION);
 
 	if (desc_idx == -1) {
-		gasket_nodev_error("Too many Gasket drivers loaded: %d\n",
-				   GASKET_FRAMEWORK_DESC_MAX);
+		pr_err("Too many Gasket drivers loaded: %d\n",
+		       GASKET_FRAMEWORK_DESC_MAX);
 		return -EBUSY;
 	}
 
 	/* Internal structure setup. */
-	gasket_nodev_info("Performing initial internal structure setup.");
+	pr_debug("Performing initial internal structure setup.\n");
 	internal = &g_descs[desc_idx];
 	mutex_init(&internal->mutex);
 	memset(internal->devs, 0, sizeof(struct gasket_dev *) * GASKET_DEV_MAX);
@@ -324,8 +324,8 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 		class_create(driver_desc->module, driver_desc->name);
 
 	if (IS_ERR(internal->class)) {
-		gasket_nodev_error("Cannot register %s class [ret=%ld]",
-				   driver_desc->name, PTR_ERR(internal->class));
+		pr_err("Cannot register %s class [ret=%ld]\n",
+		       driver_desc->name, PTR_ERR(internal->class));
 		ret = PTR_ERR(internal->class);
 		goto unregister_gasket_driver;
 	}
@@ -334,25 +334,24 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 	 * Not using pci_register_driver() (without underscores), as it
 	 * depends on KBUILD_MODNAME, and this is a shared file.
 	 */
-	gasket_nodev_info("Registering PCI driver.");
+	pr_debug("Registering PCI driver.\n");
 	ret = __pci_register_driver(
 		&internal->pci, driver_desc->module, driver_desc->name);
 	if (ret) {
-		gasket_nodev_error(
-			"cannot register pci driver [ret=%d]", ret);
+		pr_err("cannot register pci driver [ret=%d]\n", ret);
 		goto fail1;
 	}
 
-	gasket_nodev_info("Registering char driver.");
+	pr_debug("Registering char driver.\n");
 	ret = register_chrdev_region(
 		MKDEV(driver_desc->major, driver_desc->minor), GASKET_DEV_MAX,
 		driver_desc->name);
 	if (ret) {
-		gasket_nodev_error("cannot register char driver [ret=%d]", ret);
+		pr_err("cannot register char driver [ret=%d]\n", ret);
 		goto fail2;
 	}
 
-	gasket_nodev_info("Driver registered successfully.");
+	pr_info("Driver registered successfully.\n");
 	return 0;
 
 fail2:
@@ -386,10 +385,9 @@ void gasket_unregister_device(const struct gasket_driver_desc *driver_desc)
 	mutex_unlock(&g_mutex);
 
 	if (!internal_desc) {
-		gasket_nodev_error(
-			"request to unregister unknown desc: %s, %d:%d",
-			driver_desc->name, driver_desc->major,
-			driver_desc->minor);
+		pr_err("request to unregister unknown desc: %s, %d:%d\n",
+		       driver_desc->name, driver_desc->major,
+		       driver_desc->minor);
 		return;
 	}
 
@@ -405,7 +403,7 @@ void gasket_unregister_device(const struct gasket_driver_desc *driver_desc)
 	g_descs[desc_idx].driver_desc = NULL;
 	mutex_unlock(&g_mutex);
 
-	gasket_nodev_info("removed %s driver", driver_desc->name);
+	pr_info("removed %s driver\n", driver_desc->name);
 }
 EXPORT_SYMBOL(gasket_unregister_device);
 
@@ -430,7 +428,7 @@ static int gasket_alloc_dev(
 	struct gasket_dev *gasket_dev;
 	struct gasket_cdev_info *dev_info;
 
-	gasket_nodev_info("Allocating a Gasket device %s.", kobj_name);
+	pr_debug("Allocating a Gasket device %s.\n", kobj_name);
 
 	*pdev = NULL;
 
@@ -440,7 +438,7 @@ static int gasket_alloc_dev(
 
 	gasket_dev = *pdev = kzalloc(sizeof(*gasket_dev), GFP_KERNEL);
 	if (!gasket_dev) {
-		gasket_nodev_error("no memory for device");
+		pr_err("no memory for device\n");
 		return -ENOMEM;
 	}
 	internal_desc->devs[dev_idx] = gasket_dev;
@@ -466,7 +464,7 @@ static int gasket_alloc_dev(
 	dev_info->device = device_create(internal_desc->class, parent,
 		dev_info->devt, gasket_dev, dev_info->name);
 
-	gasket_nodev_info("Gasket device allocated: %p.", dev_info->device);
+	dev_dbg(dev_info->device, "Gasket device allocated.\n");
 
 	/* cdev has not yet been added; cdev_added is 0 */
 	dev_info->gasket_dev_ptr = gasket_dev;
@@ -509,7 +507,7 @@ static int gasket_find_dev_slot(
 	for (i = 0; i < GASKET_DEV_MAX; i++) {
 		if (internal_desc->devs[i] &&
 		    strcmp(internal_desc->devs[i]->kobj_name, kobj_name) == 0) {
-			gasket_nodev_error("Duplicate device %s", kobj_name);
+			pr_err("Duplicate device %s\n", kobj_name);
 			mutex_unlock(&internal_desc->mutex);
 			return -EBUSY;
 		}
@@ -522,8 +520,7 @@ static int gasket_find_dev_slot(
 	}
 
 	if (i == GASKET_DEV_MAX) {
-		gasket_nodev_info(
-			"Too many registered devices; max %d", GASKET_DEV_MAX);
+		pr_err("Too many registered devices; max %d\n", GASKET_DEV_MAX);
 		mutex_unlock(&internal_desc->mutex);
 		return -EBUSY;
 	}
@@ -552,13 +549,13 @@ static int gasket_pci_probe(
 	const struct gasket_driver_desc *driver_desc;
 	struct device *parent;
 
-	gasket_nodev_info("Add Gasket device %s", kobj_name);
+	pr_info("Add Gasket device %s\n", kobj_name);
 
 	mutex_lock(&g_mutex);
 	internal_desc = lookup_internal_desc(pci_dev);
 	mutex_unlock(&g_mutex);
 	if (!internal_desc) {
-		gasket_nodev_info("PCI probe called for unknown driver type");
+		pr_err("PCI probe called for unknown driver type\n");
 		return -ENODEV;
 	}
 
@@ -569,9 +566,9 @@ static int gasket_pci_probe(
 	if (ret)
 		return ret;
 	if (IS_ERR_OR_NULL(gasket_dev->dev_info.device)) {
-		gasket_nodev_error("Cannot create %s device %s [ret = %ld]",
-				   driver_desc->name, gasket_dev->dev_info.name,
-				   PTR_ERR(gasket_dev->dev_info.device));
+		pr_err("Cannot create %s device %s [ret = %ld]\n",
+		       driver_desc->name, gasket_dev->dev_info.name,
+		       PTR_ERR(gasket_dev->dev_info.device));
 		ret = -ENODEV;
 		goto fail1;
 	}
@@ -583,7 +580,7 @@ static int gasket_pci_probe(
 
 	ret = check_and_invoke_callback(gasket_dev, driver_desc->add_dev_cb);
 	if (ret) {
-		gasket_log_error(gasket_dev, "Error in add device cb: %d", ret);
+		dev_err(gasket_dev->dev, "Error in add device cb: %d\n", ret);
 		goto fail2;
 	}
 
@@ -599,8 +596,8 @@ static int gasket_pci_probe(
 	ret = sysfs_create_link(&gasket_dev->dev_info.device->kobj,
 				&pci_dev->dev.kobj, dev_name(&pci_dev->dev));
 	if (ret) {
-		gasket_log_error(
-			gasket_dev, "Cannot create sysfs pci link: %d", ret);
+		dev_err(gasket_dev->dev,
+			"Cannot create sysfs pci link: %d\n", ret);
 		goto fail3;
 	}
 	ret = gasket_sysfs_create_entries(
@@ -611,14 +608,13 @@ static int gasket_pci_probe(
 	ret = check_and_invoke_callback(
 		gasket_dev, driver_desc->sysfs_setup_cb);
 	if (ret) {
-		gasket_log_error(
-			gasket_dev, "Error in sysfs setup cb: %d", ret);
+		dev_err(gasket_dev->dev, "Error in sysfs setup cb: %d\n", ret);
 		goto fail5;
 	}
 
 	ret = gasket_enable_dev(internal_desc, gasket_dev);
 	if (ret) {
-		gasket_nodev_error("cannot setup %s device", driver_desc->name);
+		pr_err("cannot setup %s device\n", driver_desc->name);
 		gasket_disable_dev(gasket_dev);
 		goto fail5;
 	}
@@ -677,8 +673,7 @@ static void gasket_pci_remove(struct pci_dev *pci_dev)
 	if (!gasket_dev)
 		return;
 
-	gasket_nodev_info(
-		"remove %s device %s", internal_desc->driver_desc->name,
+	pr_info("remove %s device %s\n", internal_desc->driver_desc->name,
 		gasket_dev->kobj_name);
 
 	gasket_disable_dev(gasket_dev);
@@ -711,7 +706,7 @@ static int gasket_setup_pci(
 	gasket_dev->pci_dev = pci_dev;
 	ret = pci_enable_device(pci_dev);
 	if (ret) {
-		gasket_log_error(gasket_dev, "cannot enable PCI device");
+		dev_err(gasket_dev->dev, "cannot enable PCI device\n");
 		return ret;
 	}
 
@@ -777,17 +772,16 @@ static int gasket_map_pci_bar(struct gasket_dev *gasket_dev, int bar_num)
 	gasket_dev->bar_data[bar_num].phys_base =
 		(ulong)pci_resource_start(gasket_dev->pci_dev, bar_num);
 	if (!gasket_dev->bar_data[bar_num].phys_base) {
-		gasket_log_error(gasket_dev, "Cannot get BAR%u base address",
-				 bar_num);
+		dev_err(gasket_dev->dev, "Cannot get BAR%u base address\n",
+			bar_num);
 		return -EINVAL;
 	}
 
 	gasket_dev->bar_data[bar_num].length_bytes =
 		(ulong)pci_resource_len(gasket_dev->pci_dev, bar_num);
 	if (gasket_dev->bar_data[bar_num].length_bytes < desc_bytes) {
-		gasket_log_error(
-			gasket_dev,
-			"PCI BAR %u space is too small: %lu; expected >= %lu",
+		dev_err(gasket_dev->dev,
+			"PCI BAR %u space is too small: %lu; expected >= %lu\n",
 			bar_num, gasket_dev->bar_data[bar_num].length_bytes,
 			desc_bytes);
 		return -ENOMEM;
@@ -796,9 +790,8 @@ static int gasket_map_pci_bar(struct gasket_dev *gasket_dev, int bar_num)
 	if (!request_mem_region(gasket_dev->bar_data[bar_num].phys_base,
 				gasket_dev->bar_data[bar_num].length_bytes,
 				gasket_dev->dev_info.name)) {
-		gasket_log_error(
-			gasket_dev,
-			"Cannot get BAR %d memory region %p",
+		dev_err(gasket_dev->dev,
+			"Cannot get BAR %d memory region %p\n",
 			bar_num, &gasket_dev->pci_dev->resource[bar_num]);
 		return -EINVAL;
 	}
@@ -807,9 +800,8 @@ static int gasket_map_pci_bar(struct gasket_dev *gasket_dev, int bar_num)
 		ioremap_nocache(gasket_dev->bar_data[bar_num].phys_base,
 				gasket_dev->bar_data[bar_num].length_bytes);
 	if (!gasket_dev->bar_data[bar_num].virt_base) {
-		gasket_log_error(
-			gasket_dev,
-			"Cannot remap BAR %d memory region %p",
+		dev_err(gasket_dev->dev,
+			"Cannot remap BAR %d memory region %p\n",
 			bar_num, &gasket_dev->pci_dev->resource[bar_num]);
 		ret = -ENOMEM;
 		goto fail;
@@ -852,8 +844,8 @@ static void gasket_unmap_pci_bar(struct gasket_dev *dev, int bar_num)
 
 	base = pci_resource_start(dev->pci_dev, bar_num);
 	if (!base) {
-		gasket_log_error(
-			dev, "cannot get PCI BAR%u base address", bar_num);
+		dev_err(dev->dev, "cannot get PCI BAR%u base address\n",
+			bar_num);
 		return;
 	}
 
@@ -877,9 +869,8 @@ static int gasket_add_cdev(
 	dev_info->cdev.owner = owner;
 	ret = cdev_add(&dev_info->cdev, dev_info->devt, 1);
 	if (ret) {
-		gasket_log_error(
-			dev_info->gasket_dev_ptr,
-			"cannot add char device [ret=%d]", ret);
+		dev_err(dev_info->gasket_dev_ptr->dev,
+			"cannot add char device [ret=%d]\n", ret);
 		return ret;
 	}
 	dev_info->cdev_added = 1;
@@ -911,16 +902,15 @@ static int gasket_enable_dev(
 		driver_desc->interrupt_bar_index,
 		driver_desc->wire_interrupt_offsets);
 	if (ret) {
-		gasket_log_error(gasket_dev,
-				 "Critical failure to allocate interrupts: %d",
-				 ret);
+		dev_err(gasket_dev->dev,
+			"Critical failure to allocate interrupts: %d\n", ret);
 		gasket_interrupt_cleanup(gasket_dev);
 		return ret;
 	}
 
 	for (tbl_idx = 0; tbl_idx < driver_desc->num_page_tables; tbl_idx++) {
-		gasket_log_debug(
-			gasket_dev, "Initializing page table %d.", tbl_idx);
+		dev_dbg(gasket_dev->dev, "Initializing page table %d.\n",
+			tbl_idx);
 		ret = gasket_page_table_init(
 			&gasket_dev->page_table[tbl_idx],
 			&gasket_dev->bar_data[
@@ -928,9 +918,8 @@ static int gasket_enable_dev(
 			&driver_desc->page_table_configs[tbl_idx],
 			gasket_dev->dev, gasket_dev->pci_dev, true);
 		if (ret) {
-			gasket_log_error(
-				gasket_dev,
-				"Couldn't init page table %d: %d",
+			dev_err(gasket_dev->dev,
+				"Couldn't init page table %d: %d\n",
 				tbl_idx, ret);
 			return ret;
 		}
@@ -948,23 +937,23 @@ static int gasket_enable_dev(
 	ret = check_and_invoke_callback(
 		gasket_dev, driver_desc->hardware_revision_cb);
 	if (ret < 0) {
-		gasket_log_error(
-			gasket_dev, "Error getting hardware revision: %d", ret);
+		dev_err(gasket_dev->dev,
+			"Error getting hardware revision: %d\n", ret);
 		return ret;
 	}
 	gasket_dev->hardware_revision = ret;
 
 	ret = check_and_invoke_callback(gasket_dev, driver_desc->enable_dev_cb);
 	if (ret) {
-		gasket_log_error(
-			gasket_dev, "Error in enable device cb: %d", ret);
+		dev_err(gasket_dev->dev, "Error in enable device cb: %d\n",
+			ret);
 		return ret;
 	}
 
 	/* device_status_cb returns a device status, not an error code. */
 	gasket_dev->status = gasket_get_hw_status(gasket_dev);
 	if (gasket_dev->status == GASKET_STATUS_DEAD)
-		gasket_log_error(gasket_dev, "Device reported as unhealthy.");
+		dev_err(gasket_dev->dev, "Device reported as unhealthy.\n");
 
 	ret = gasket_add_cdev(
 		&gasket_dev->dev_info, &gasket_file_ops, driver_desc->module);
@@ -1084,31 +1073,29 @@ static int gasket_open(struct inode *inode, struct file *filp)
 	filp->private_data = gasket_dev;
 	inode->i_size = 0;
 
-	gasket_log_debug(
-		gasket_dev,
+	dev_dbg(gasket_dev->dev,
 		"Attempting to open with tgid %u (%s) (f_mode: 0%03o, "
-		"fmode_write: %d is_root: %u)",
+		"fmode_write: %d is_root: %u)\n",
 		current->tgid, task_name, filp->f_mode,
 		(filp->f_mode & FMODE_WRITE), is_root);
 
 	/* Always allow non-writing accesses. */
 	if (!(filp->f_mode & FMODE_WRITE)) {
-		gasket_log_debug(gasket_dev, "Allowing read-only opening.");
+		dev_dbg(gasket_dev->dev, "Allowing read-only opening.\n");
 		return 0;
 	}
 
 	mutex_lock(&gasket_dev->mutex);
 
-	gasket_log_debug(
-		gasket_dev, "Current owner open count (owning tgid %u): %d.",
+	dev_dbg(gasket_dev->dev,
+		"Current owner open count (owning tgid %u): %d.\n",
 		ownership->owner, ownership->write_open_count);
 
 	/* Opening a node owned by another TGID is an error (unless root) */
 	if (ownership->is_owned && ownership->owner != current->tgid &&
 	    !is_root) {
-		gasket_log_error(
-			gasket_dev,
-			"Process %u is opening a node held by %u.",
+		dev_err(gasket_dev->dev,
+			"Process %u is opening a node held by %u.\n",
 			current->tgid, ownership->owner);
 		mutex_unlock(&gasket_dev->mutex);
 		return -EPERM;
@@ -1119,21 +1106,21 @@ static int gasket_open(struct inode *inode, struct file *filp)
 		ret = gasket_check_and_invoke_callback_nolock(
 			gasket_dev, driver_desc->device_open_cb);
 		if (ret) {
-			gasket_log_error(
-				gasket_dev, "Error in device open cb: %d", ret);
+			dev_err(gasket_dev->dev,
+				"Error in device open cb: %d\n", ret);
 			mutex_unlock(&gasket_dev->mutex);
 			return ret;
 		}
 		ownership->is_owned = 1;
 		ownership->owner = current->tgid;
-		gasket_log_debug(gasket_dev, "Device owner is now tgid %u",
-				 ownership->owner);
+		dev_dbg(gasket_dev->dev, "Device owner is now tgid %u\n",
+			ownership->owner);
 	}
 
 	ownership->write_open_count++;
 
-	gasket_log_debug(gasket_dev, "New open count (owning tgid %u): %d",
-			 ownership->owner, ownership->write_open_count);
+	dev_dbg(gasket_dev->dev, "New open count (owning tgid %u): %d\n",
+		ownership->owner, ownership->write_open_count);
 
 	mutex_unlock(&gasket_dev->mutex);
 	return 0;
@@ -1167,19 +1154,18 @@ static int gasket_release(struct inode *inode, struct file *file)
 	get_task_comm(task_name, current);
 	mutex_lock(&gasket_dev->mutex);
 
-	gasket_log_debug(
-		gasket_dev,
+	dev_dbg(gasket_dev->dev,
 		"Releasing device node. Call origin: tgid %u (%s) "
-		"(f_mode: 0%03o, fmode_write: %d, is_root: %u)",
+		"(f_mode: 0%03o, fmode_write: %d, is_root: %u)\n",
 		current->tgid, task_name, file->f_mode,
 		(file->f_mode & FMODE_WRITE), capable(CAP_SYS_ADMIN));
-	gasket_log_debug(gasket_dev, "Current open count (owning tgid %u): %d",
-			 ownership->owner, ownership->write_open_count);
+	dev_dbg(gasket_dev->dev, "Current open count (owning tgid %u): %d\n",
+		ownership->owner, ownership->write_open_count);
 
 	if (file->f_mode & FMODE_WRITE) {
 		ownership->write_open_count--;
 		if (ownership->write_open_count == 0) {
-			gasket_log_debug(gasket_dev, "Device is now free");
+			dev_dbg(gasket_dev->dev, "Device is now free\n");
 			ownership->is_owned = 0;
 			ownership->owner = 0;
 
@@ -1200,8 +1186,7 @@ static int gasket_release(struct inode *inode, struct file *file)
 		}
 	}
 
-	gasket_log_debug(
-		gasket_dev, "New open count (owning tgid %u): %d",
+	dev_dbg(gasket_dev->dev, "New open count (owning tgid %u): %d\n",
 		ownership->owner, ownership->write_open_count);
 	mutex_unlock(&gasket_dev->mutex);
 	return 0;
@@ -1227,7 +1212,7 @@ static bool gasket_mmap_has_permissions(
 
 	/* Never allow non-sysadmins to access to a dead device. */
 	if (gasket_dev->status != GASKET_STATUS_ALIVE) {
-		gasket_log_debug(gasket_dev, "Device is dead.");
+		dev_dbg(gasket_dev->dev, "Device is dead.\n");
 		return false;
 	}
 
@@ -1235,10 +1220,9 @@ static bool gasket_mmap_has_permissions(
 	requested_permissions =
 		(vma->vm_flags & (VM_WRITE | VM_READ | VM_EXEC));
 	if (requested_permissions & ~(bar_permissions)) {
-		gasket_log_debug(
-			gasket_dev,
+		dev_dbg(gasket_dev->dev,
 			"Attempting to map a region with requested permissions "
-			"0x%x, but region has permissions 0x%x.",
+			"0x%x, but region has permissions 0x%x.\n",
 			requested_permissions, bar_permissions);
 		return false;
 	}
@@ -1246,10 +1230,9 @@ static bool gasket_mmap_has_permissions(
 	/* Do not allow a non-owner to write. */
 	if ((vma->vm_flags & VM_WRITE) &&
 	    !gasket_owned_by_current_tgid(&gasket_dev->dev_info)) {
-		gasket_log_debug(
-			gasket_dev,
+		dev_dbg(gasket_dev->dev,
 			"Attempting to mmap a region for write without owning "
-			"device.");
+			"device.\n");
 		return false;
 	}
 
@@ -1462,8 +1445,8 @@ static enum do_map_region_status do_map_region(
 			(phys_base + mapped_bytes) >> PAGE_SHIFT,
 			chunk_size, vma->vm_page_prot);
 		if (ret) {
-			gasket_log_error(
-				gasket_dev, "Error remapping PFN range.");
+			dev_err(gasket_dev->dev,
+				"Error remapping PFN range.\n");
 			goto fail;
 		}
 		mapped_bytes += chunk_size;
@@ -1475,9 +1458,8 @@ static enum do_map_region_status do_map_region(
 	/* Unmap the partial chunk we mapped. */
 	mappable_region->length_bytes = mapped_bytes;
 	if (gasket_mm_unmap_region(gasket_dev, vma, mappable_region))
-		gasket_log_error(
-			gasket_dev,
-			"Error unmapping partial region 0x%lx (0x%lx bytes)",
+		dev_err(gasket_dev->dev,
+			"Error unmapping partial region 0x%lx (0x%lx bytes)\n",
 			(ulong)virt_offset,
 			(ulong)mapped_bytes);
 
@@ -1502,9 +1484,8 @@ static int gasket_mm_vma_bar_offset(
 		driver_desc->legacy_mmap_address_offset;
 	bar_index = gasket_get_bar_index(gasket_dev, raw_offset);
 	if (bar_index < 0) {
-		gasket_log_error(
-			gasket_dev,
-			"Unable to find matching bar for address 0x%lx",
+		dev_err(gasket_dev->dev,
+			"Unable to find matching bar for address 0x%lx\n",
 			raw_offset);
 		trace_gasket_mmap_exit(bar_index);
 		return bar_index;
@@ -1537,7 +1518,7 @@ static int gasket_mmap_coherent(
 
 	permissions = driver_desc->coherent_buffer_description.permissions;
 	if (!gasket_mmap_has_permissions(gasket_dev, vma, permissions)) {
-		gasket_log_error(gasket_dev, "Permission checking failed.");
+		dev_err(gasket_dev->dev, "Permission checking failed.\n");
 		trace_gasket_mmap_exit(-EPERM);
 		return -EPERM;
 	}
@@ -1549,8 +1530,8 @@ static int gasket_mmap_coherent(
 		(gasket_dev->coherent_buffer.phys_base) >> PAGE_SHIFT,
 		requested_length, vma->vm_page_prot);
 	if (ret) {
-		gasket_log_error(
-			gasket_dev, "Error remapping PFN range err=%d.", ret);
+		dev_err(gasket_dev->dev, "Error remapping PFN range err=%d.\n",
+			ret);
 		trace_gasket_mmap_exit(ret);
 		return ret;
 	}
@@ -1592,8 +1573,8 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	driver_desc = gasket_dev->internal_desc->driver_desc;
 
 	if (vma->vm_start & ~PAGE_MASK) {
-		gasket_log_error(
-			gasket_dev, "Base address not page-aligned: 0x%lx\n",
+		dev_err(gasket_dev->dev,
+			"Base address not page-aligned: 0x%lx\n",
 			vma->vm_start);
 		trace_gasket_mmap_exit(-EINVAL);
 		return -EINVAL;
@@ -1613,18 +1594,16 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	bar_index = gasket_get_bar_index(gasket_dev, raw_offset);
 	is_coherent_region = gasket_is_coherent_region(driver_desc, raw_offset);
 	if (bar_index < 0 && !is_coherent_region) {
-		gasket_log_error(
-			gasket_dev,
-			"Unable to find matching bar for address 0x%lx",
+		dev_err(gasket_dev->dev,
+			"Unable to find matching bar for address 0x%lx\n",
 			raw_offset);
 		trace_gasket_mmap_exit(bar_index);
 		return bar_index;
 	}
 	if (bar_index > 0 && is_coherent_region) {
-		gasket_log_error(
-			gasket_dev,
+		dev_err(gasket_dev->dev,
 			"double matching bar and coherent buffers for address "
-			"0x%lx",
+			"0x%lx\n",
 			raw_offset);
 		trace_gasket_mmap_exit(bar_index);
 		return -EINVAL;
@@ -1644,7 +1623,7 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	bar_desc = &driver_desc->bar_descriptions[bar_index];
 	permissions = bar_desc->permissions;
 	if (!gasket_mmap_has_permissions(gasket_dev, vma, permissions)) {
-		gasket_log_error(gasket_dev, "Permission checking failed.");
+		dev_err(gasket_dev->dev, "Permission checking failed.\n");
 		trace_gasket_mmap_exit(-EPERM);
 		return -EPERM;
 	}
@@ -1657,8 +1636,8 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	} else {
 		if (!gasket_mmap_has_permissions(gasket_dev, vma,
 						 bar_desc->permissions)) {
-			gasket_log_error(
-				gasket_dev, "Permission checking failed.");
+			dev_err(gasket_dev->dev,
+				"Permission checking failed.\n");
 			trace_gasket_mmap_exit(-EPERM);
 			return -EPERM;
 		}
@@ -1674,7 +1653,7 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	}
 
 	if (!map_regions || num_map_regions == 0) {
-		gasket_log_error(gasket_dev, "No mappable regions returned!");
+		dev_err(gasket_dev->dev, "No mappable regions returned!\n");
 		return -EINVAL;
 	}
 
@@ -1697,9 +1676,8 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 
 	/* If we could not map any memory, the request was invalid. */
 	if (!has_mapped_anything) {
-		gasket_log_error(
-			gasket_dev,
-			"Map request did not contain a valid region.");
+		dev_err(gasket_dev->dev,
+			"Map request did not contain a valid region.\n");
 		trace_gasket_mmap_exit(-EINVAL);
 		return -EINVAL;
 	}
@@ -1713,8 +1691,8 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	for (i = 0; i < num_map_regions; i++)
 		if (gasket_mm_unmap_region(gasket_dev, vma,
 					   &bar_desc->mappable_regions[i]))
-			gasket_log_error(
-				gasket_dev, "Error unmapping range %d.", i);
+			dev_err(gasket_dev->dev, "Error unmapping range %d.\n",
+				i);
 	kfree(map_regions);
 
 	return ret;
@@ -1738,16 +1716,15 @@ static int gasket_get_hw_status(struct gasket_dev *gasket_dev)
 	status = gasket_check_and_invoke_callback_nolock(
 		gasket_dev, driver_desc->device_status_cb);
 	if (status != GASKET_STATUS_ALIVE) {
-		gasket_log_debug(gasket_dev, "Hardware reported status %d.",
-				 status);
+		dev_dbg(gasket_dev->dev, "Hardware reported status %d.\n",
+			status);
 		return status;
 	}
 
 	status = gasket_interrupt_system_status(gasket_dev);
 	if (status != GASKET_STATUS_ALIVE) {
-		gasket_log_debug(gasket_dev,
-				 "Interrupt system reported status %d.",
-				 status);
+		dev_dbg(gasket_dev->dev,
+			"Interrupt system reported status %d.\n", status);
 		return status;
 	}
 
@@ -1755,8 +1732,8 @@ static int gasket_get_hw_status(struct gasket_dev *gasket_dev)
 		status = gasket_page_table_system_status(
 			gasket_dev->page_table[i]);
 		if (status != GASKET_STATUS_ALIVE) {
-			gasket_log_debug(
-				gasket_dev, "Page table %d reported status %d.",
+			dev_dbg(gasket_dev->dev,
+				"Page table %d reported status %d.\n",
 				i, status);
 			return status;
 		}
@@ -1786,9 +1763,8 @@ static long gasket_ioctl(struct file *filp, uint cmd, ulong arg)
 	gasket_dev = (struct gasket_dev *)filp->private_data;
 	driver_desc = gasket_dev->internal_desc->driver_desc;
 	if (!driver_desc) {
-		gasket_log_debug(
-			gasket_dev,
-			"Unable to find device descriptor for file %s",
+		dev_dbg(gasket_dev->dev,
+			"Unable to find device descriptor for file %s\n",
 			d_path(&filp->f_path, path, 256));
 		return -ENODEV;
 	}
@@ -1802,8 +1778,7 @@ static long gasket_ioctl(struct file *filp, uint cmd, ulong arg)
 		if (driver_desc->ioctl_handler_cb)
 			return driver_desc->ioctl_handler_cb(filp, cmd, argp);
 
-		gasket_log_debug(
-			gasket_dev, "Received unknown ioctl 0x%x", cmd);
+		dev_dbg(gasket_dev->dev, "Received unknown ioctl 0x%x\n", cmd);
 		return -EINVAL;
 	}
 
@@ -1834,8 +1809,8 @@ int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
 	/* Perform a device reset of the requested type. */
 	ret = driver_desc->device_reset_cb(gasket_dev, reset_type);
 	if (ret) {
-		gasket_log_debug(
-			gasket_dev, "Device reset cb returned %d.", ret);
+		dev_dbg(gasket_dev->dev, "Device reset cb returned %d.\n",
+			ret);
 		return ret;
 	}
 
@@ -1845,15 +1820,15 @@ int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
 
 	ret = gasket_interrupt_reinit(gasket_dev);
 	if (ret) {
-		gasket_log_debug(
-			gasket_dev, "Unable to reinit interrupts: %d.", ret);
+		dev_dbg(gasket_dev->dev, "Unable to reinit interrupts: %d.\n",
+			ret);
 		return ret;
 	}
 
 	/* Get current device health. */
 	gasket_dev->status = gasket_get_hw_status(gasket_dev);
 	if (gasket_dev->status == GASKET_STATUS_DEAD) {
-		gasket_log_debug(gasket_dev, "Device reported as dead.");
+		dev_dbg(gasket_dev->dev, "Device reported as dead.\n");
 		return -EINVAL;
 	}
 
@@ -1909,15 +1884,13 @@ static ssize_t gasket_sysfs_data_show(
 
 	gasket_dev = gasket_sysfs_get_device_data(device);
 	if (!gasket_dev) {
-		gasket_nodev_error(
-			"No sysfs mapping found for device 0x%p", device);
+		dev_err(device, "No sysfs mapping found for device\n");
 		return 0;
 	}
 
 	gasket_attr = gasket_sysfs_get_attr(device, attr);
 	if (!gasket_attr) {
-		gasket_nodev_error(
-			"No sysfs attr found for device 0x%p", device);
+		dev_err(device, "No sysfs attr found for device\n");
 		gasket_sysfs_put_device_data(device, gasket_dev);
 		return 0;
 	}
@@ -2005,8 +1978,8 @@ static ssize_t gasket_sysfs_data_show(
 		}
 		break;
 	default:
-		gasket_log_debug(
-			gasket_dev, "Unknown attribute: %s", attr->attr.name);
+		dev_dbg(gasket_dev->dev, "Unknown attribute: %s\n",
+			attr->attr.name);
 		ret = 0;
 		break;
 	}
@@ -2059,8 +2032,8 @@ int gasket_wait_with_reschedule(
 		msleep(delay_ms);
 		retries++;
 	}
-	gasket_log_debug(gasket_dev, "%s timeout: reg %llx timeout (%llu ms)",
-			 __func__, offset, max_retries * delay_ms);
+	dev_dbg(gasket_dev->dev, "%s timeout: reg %llx timeout (%llu ms)\n",
+		__func__, offset, max_retries * delay_ms);
 	return -ETIMEDOUT;
 }
 EXPORT_SYMBOL(gasket_wait_with_reschedule);

commit 6cefe675f12f1b53f963f6b867d40aa4237a35d9
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 26 20:07:28 2018 -0700

    staging: gasket: save struct device for a gasket device
    
    Save the struct device pointer to a gasket device in gasket's metadata,
    to facilitate use of standard logging calls and in anticipation of
    non-PCI gasket devices in the future.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 732218773c3c..e8f3b021c20d 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -450,6 +450,7 @@ static int gasket_alloc_dev(
 	gasket_dev->internal_desc = internal_desc;
 	gasket_dev->dev_idx = dev_idx;
 	snprintf(gasket_dev->kobj_name, GASKET_NAME_MAX, "%s", kobj_name);
+	gasket_dev->dev = parent;
 	/* gasket_bar_data is uninitialized. */
 	gasket_dev->num_page_tables = driver_desc->num_page_tables;
 	/* max_page_table_size and *page table are uninit'ed */
@@ -925,7 +926,7 @@ static int gasket_enable_dev(
 			&gasket_dev->bar_data[
 				driver_desc->page_table_bar_index],
 			&driver_desc->page_table_configs[tbl_idx],
-			&gasket_dev->pci_dev->dev, gasket_dev->pci_dev, true);
+			gasket_dev->dev, gasket_dev->pci_dev, true);
 		if (ret) {
 			gasket_log_error(
 				gasket_dev,
@@ -2028,7 +2029,7 @@ const struct gasket_driver_desc *gasket_get_driver_desc(struct gasket_dev *dev)
  */
 struct device *gasket_get_device(struct gasket_dev *dev)
 {
-	return &dev->pci_dev->dev;
+	return dev->dev;
 }
 
 /**

commit 1d079f20d5aaab58ac6ccc3afd849f7ccebf28a1
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sat Jul 21 06:35:04 2018 -0700

    staging: gasket: ioctl common: convert various logs to debug level
    
    Debugging information is improperly logged at non-debug log level in a
    number of places, and some logs regarding error conditions may be
    generated too frequently, such that these could cause performance
    problems and/or obscure other logs.  Convert these to debug log level.
    
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 1d04fd0990e4..732218773c3c 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1801,7 +1801,7 @@ static long gasket_ioctl(struct file *filp, uint cmd, ulong arg)
 		if (driver_desc->ioctl_handler_cb)
 			return driver_desc->ioctl_handler_cb(filp, cmd, argp);
 
-		gasket_log_error(
+		gasket_log_debug(
 			gasket_dev, "Received unknown ioctl 0x%x", cmd);
 		return -EINVAL;
 	}

commit 6b18580bad320fe96e32216bd91ba9f036119d25
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sat Jul 21 06:35:02 2018 -0700

    staging: gasket: core: convert various logs to debug level
    
    Debugging information is improperly logged at non-debug log level in a
    number of places, and some logs regarding error conditions may be
    generated too frequently, such that these could cause performance
    problems and/or obscure other logs.  Convert these to debug log level.
    
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 8265d543623d..1d04fd0990e4 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -205,7 +205,8 @@ static inline int check_and_invoke_callback(
 {
 	int ret = 0;
 
-	gasket_nodev_error("check_and_invoke_callback %p", cb_function);
+	gasket_log_debug(gasket_dev, "check_and_invoke_callback %p",
+			 cb_function);
 	if (cb_function) {
 		mutex_lock(&gasket_dev->mutex);
 		ret = cb_function(gasket_dev);
@@ -227,7 +228,7 @@ static inline int gasket_check_and_invoke_callback_nolock(
 	int ret = 0;
 
 	if (cb_function) {
-		gasket_log_info(
+		gasket_log_debug(
 			gasket_dev, "Invoking device-specific callback.");
 		ret = cb_function(gasket_dev);
 	}
@@ -1177,7 +1178,7 @@ static int gasket_release(struct inode *inode, struct file *file)
 	if (file->f_mode & FMODE_WRITE) {
 		ownership->write_open_count--;
 		if (ownership->write_open_count == 0) {
-			gasket_log_info(gasket_dev, "Device is now free");
+			gasket_log_debug(gasket_dev, "Device is now free");
 			ownership->is_owned = 0;
 			ownership->owner = 0;
 
@@ -1198,7 +1199,7 @@ static int gasket_release(struct inode *inode, struct file *file)
 		}
 	}
 
-	gasket_log_info(
+	gasket_log_debug(
 		gasket_dev, "New open count (owning tgid %u): %d",
 		ownership->owner, ownership->write_open_count);
 	mutex_unlock(&gasket_dev->mutex);
@@ -1225,7 +1226,7 @@ static bool gasket_mmap_has_permissions(
 
 	/* Never allow non-sysadmins to access to a dead device. */
 	if (gasket_dev->status != GASKET_STATUS_ALIVE) {
-		gasket_log_info(gasket_dev, "Device is dead.");
+		gasket_log_debug(gasket_dev, "Device is dead.");
 		return false;
 	}
 
@@ -1233,7 +1234,7 @@ static bool gasket_mmap_has_permissions(
 	requested_permissions =
 		(vma->vm_flags & (VM_WRITE | VM_READ | VM_EXEC));
 	if (requested_permissions & ~(bar_permissions)) {
-		gasket_log_info(
+		gasket_log_debug(
 			gasket_dev,
 			"Attempting to map a region with requested permissions "
 			"0x%x, but region has permissions 0x%x.",
@@ -1244,7 +1245,7 @@ static bool gasket_mmap_has_permissions(
 	/* Do not allow a non-owner to write. */
 	if ((vma->vm_flags & VM_WRITE) &&
 	    !gasket_owned_by_current_tgid(&gasket_dev->dev_info)) {
-		gasket_log_info(
+		gasket_log_debug(
 			gasket_dev,
 			"Attempting to mmap a region for write without owning "
 			"device.");
@@ -1736,15 +1737,16 @@ static int gasket_get_hw_status(struct gasket_dev *gasket_dev)
 	status = gasket_check_and_invoke_callback_nolock(
 		gasket_dev, driver_desc->device_status_cb);
 	if (status != GASKET_STATUS_ALIVE) {
-		gasket_log_info(gasket_dev, "Hardware reported status %d.",
-				status);
+		gasket_log_debug(gasket_dev, "Hardware reported status %d.",
+				 status);
 		return status;
 	}
 
 	status = gasket_interrupt_system_status(gasket_dev);
 	if (status != GASKET_STATUS_ALIVE) {
-		gasket_log_info(gasket_dev,
-				"Interrupt system reported status %d.", status);
+		gasket_log_debug(gasket_dev,
+				 "Interrupt system reported status %d.",
+				 status);
 		return status;
 	}
 
@@ -1752,7 +1754,7 @@ static int gasket_get_hw_status(struct gasket_dev *gasket_dev)
 		status = gasket_page_table_system_status(
 			gasket_dev->page_table[i]);
 		if (status != GASKET_STATUS_ALIVE) {
-			gasket_log_info(
+			gasket_log_debug(
 				gasket_dev, "Page table %d reported status %d.",
 				i, status);
 			return status;
@@ -1783,7 +1785,7 @@ static long gasket_ioctl(struct file *filp, uint cmd, ulong arg)
 	gasket_dev = (struct gasket_dev *)filp->private_data;
 	driver_desc = gasket_dev->internal_desc->driver_desc;
 	if (!driver_desc) {
-		gasket_log_error(
+		gasket_log_debug(
 			gasket_dev,
 			"Unable to find device descriptor for file %s",
 			d_path(&filp->f_path, path, 256));
@@ -1831,7 +1833,7 @@ int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
 	/* Perform a device reset of the requested type. */
 	ret = driver_desc->device_reset_cb(gasket_dev, reset_type);
 	if (ret) {
-		gasket_log_error(
+		gasket_log_debug(
 			gasket_dev, "Device reset cb returned %d.", ret);
 		return ret;
 	}
@@ -1842,7 +1844,7 @@ int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
 
 	ret = gasket_interrupt_reinit(gasket_dev);
 	if (ret) {
-		gasket_log_error(
+		gasket_log_debug(
 			gasket_dev, "Unable to reinit interrupts: %d.", ret);
 		return ret;
 	}
@@ -1850,7 +1852,7 @@ int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
 	/* Get current device health. */
 	gasket_dev->status = gasket_get_hw_status(gasket_dev);
 	if (gasket_dev->status == GASKET_STATUS_DEAD) {
-		gasket_log_error(gasket_dev, "Device reported as dead.");
+		gasket_log_debug(gasket_dev, "Device reported as dead.");
 		return -EINVAL;
 	}
 
@@ -2002,7 +2004,7 @@ static ssize_t gasket_sysfs_data_show(
 		}
 		break;
 	default:
-		gasket_log_error(
+		gasket_log_debug(
 			gasket_dev, "Unknown attribute: %s", attr->attr.name);
 		ret = 0;
 		break;
@@ -2056,7 +2058,7 @@ int gasket_wait_with_reschedule(
 		msleep(delay_ms);
 		retries++;
 	}
-	gasket_log_error(gasket_dev, "%s timeout: reg %llx timeout (%llu ms)",
+	gasket_log_debug(gasket_dev, "%s timeout: reg %llx timeout (%llu ms)",
 			 __func__, offset, max_retries * delay_ms);
 	return -ETIMEDOUT;
 }

commit e2f00f0b9876387e38849e7b1338ac684a7a6562
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sat Jul 21 06:35:00 2018 -0700

    staging: gasket: gasket_get_device drop check for NULL pci_dev
    
    The pci_dev field of a struct gasket_dev can never be NULL, there's no
    need to check for this in gasket_get_device().
    
    Reported-by: Guenter Roeck <groeck@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index e82f8ce39c9f..8265d543623d 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -2026,9 +2026,7 @@ const struct gasket_driver_desc *gasket_get_driver_desc(struct gasket_dev *dev)
  */
 struct device *gasket_get_device(struct gasket_dev *dev)
 {
-	if (dev->pci_dev)
-		return &dev->pci_dev->dev;
-	return NULL;
+	return &dev->pci_dev->dev;
 }
 
 /**

commit 99ccddf5af6f32f501e719024e5e699565c6552e
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sat Jul 21 06:34:59 2018 -0700

    staging: gasket: remove unnecessary NULL checks on calls from VFS
    
    Remove unneeded checks for NULL pointers in struct file pointers passed
    from the VFS layer or the private_data that must have been properly set
    at file open time.
    
    Reported-by: Guenter Roeck <groeck@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 11ab04985449..e82f8ce39c9f 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1587,11 +1587,6 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	int num_map_regions = 0;
 	enum do_map_region_status map_status;
 
-	if (!gasket_dev) {
-		gasket_nodev_error("Unable to retrieve device data");
-		trace_gasket_mmap_exit(-EINVAL);
-		return -EINVAL;
-	}
 	driver_desc = gasket_dev->internal_desc->driver_desc;
 
 	if (vma->vm_start & ~PAGE_MASK) {
@@ -1785,17 +1780,7 @@ static long gasket_ioctl(struct file *filp, uint cmd, ulong arg)
 	void __user *argp = (void __user *)arg;
 	char path[256];
 
-	if (!filp)
-		return -ENODEV;
-
 	gasket_dev = (struct gasket_dev *)filp->private_data;
-	if (!gasket_dev) {
-		gasket_nodev_error(
-			"Unable to find Gasket structure for file %s",
-			d_path(&filp->f_path, path, 256));
-		return -ENODEV;
-	}
-
 	driver_desc = gasket_dev->internal_desc->driver_desc;
 	if (!driver_desc) {
 		gasket_log_error(

commit a1978fa2d632c9001d1d68dac3926177af96c64e
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sat Jul 21 06:34:58 2018 -0700

    staging: gasket: print mmap starting address as unsigned long
    
    Page alignment error log should print the offending value as an unsigned
    long, not as a kernel pointer.
    
    Reported-by: Guenter Roeck <groeck@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 2cd232230845..11ab04985449 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1596,8 +1596,8 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 
 	if (vma->vm_start & ~PAGE_MASK) {
 		gasket_log_error(
-			gasket_dev, "Base address not page-aligned: 0x%p\n",
-			(void *)vma->vm_start);
+			gasket_dev, "Base address not page-aligned: 0x%lx\n",
+			vma->vm_start);
 		trace_gasket_mmap_exit(-EINVAL);
 		return -EINVAL;
 	}

commit 59ab5af731565762189d2f923887933fc1e84bcf
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sat Jul 21 06:34:54 2018 -0700

    staging: gasket: fix check_and_invoke_callback log param
    
    The message should be passed the callback function pointer, not
    the pointer to the gasket device.
    
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 40e46ca5228c..2cd232230845 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -205,7 +205,7 @@ static inline int check_and_invoke_callback(
 {
 	int ret = 0;
 
-	gasket_nodev_error("check_and_invoke_callback %p", gasket_dev);
+	gasket_nodev_error("check_and_invoke_callback %p", cb_function);
 	if (cb_function) {
 		mutex_lock(&gasket_dev->mutex);
 		ret = cb_function(gasket_dev);

commit 761d8db71436d8c67bcac85aa62860cb5848fecf
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:17 2018 -0700

    staging: gasket: top ioctl handler add __user annotations
    
    Add __user annotation to gasket_core top-level ioctl handling pointer
    arguments, for sparse checking.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 254fb392c05c..40e46ca5228c 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -14,6 +14,7 @@
 #include "gasket_page_table.h"
 #include "gasket_sysfs.h"
 
+#include <linux/compiler.h>
 #include <linux/delay.h>
 #include <linux/fs.h>
 #include <linux/init.h>
@@ -1781,6 +1782,7 @@ static long gasket_ioctl(struct file *filp, uint cmd, ulong arg)
 {
 	struct gasket_dev *gasket_dev;
 	const struct gasket_driver_desc *driver_desc;
+	void __user *argp = (void __user *)arg;
 	char path[256];
 
 	if (!filp)
@@ -1810,14 +1812,14 @@ static long gasket_ioctl(struct file *filp, uint cmd, ulong arg)
 		 * check_and_invoke_callback.
 		 */
 		if (driver_desc->ioctl_handler_cb)
-			return driver_desc->ioctl_handler_cb(filp, cmd, arg);
+			return driver_desc->ioctl_handler_cb(filp, cmd, argp);
 
 		gasket_log_error(
 			gasket_dev, "Received unknown ioctl 0x%x", cmd);
 		return -EINVAL;
 	}
 
-	return gasket_handle_ioctl(filp, cmd, arg);
+	return gasket_handle_ioctl(filp, cmd, argp);
 }
 
 int gasket_reset(struct gasket_dev *gasket_dev, uint reset_type)

commit ed74277bd80a47ec552ccf3581583421c3a4df5d
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:16 2018 -0700

    staging: gasket: always allow root open for write
    
    Always allow root to open device for writing.
    
    Drop special-casing of ioctl permissions for root vs. owner.
    
    Convert to bool types as appropriate.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index ba48a379b0ad..254fb392c05c 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1072,6 +1072,7 @@ static int gasket_open(struct inode *inode, struct file *filp)
 	char task_name[TASK_COMM_LEN];
 	struct gasket_cdev_info *dev_info =
 	    container_of(inode->i_cdev, struct gasket_cdev_info, cdev);
+	int is_root = capable(CAP_SYS_ADMIN);
 
 	gasket_dev = dev_info->gasket_dev_ptr;
 	driver_desc = gasket_dev->internal_desc->driver_desc;
@@ -1085,7 +1086,7 @@ static int gasket_open(struct inode *inode, struct file *filp)
 		"Attempting to open with tgid %u (%s) (f_mode: 0%03o, "
 		"fmode_write: %d is_root: %u)",
 		current->tgid, task_name, filp->f_mode,
-		(filp->f_mode & FMODE_WRITE), capable(CAP_SYS_ADMIN));
+		(filp->f_mode & FMODE_WRITE), is_root);
 
 	/* Always allow non-writing accesses. */
 	if (!(filp->f_mode & FMODE_WRITE)) {
@@ -1099,8 +1100,9 @@ static int gasket_open(struct inode *inode, struct file *filp)
 		gasket_dev, "Current owner open count (owning tgid %u): %d.",
 		ownership->owner, ownership->write_open_count);
 
-	/* Opening a node owned by another TGID is an error (even root.) */
-	if (ownership->is_owned && ownership->owner != current->tgid) {
+	/* Opening a node owned by another TGID is an error (unless root) */
+	if (ownership->is_owned && ownership->owner != current->tgid &&
+	    !is_root) {
 		gasket_log_error(
 			gasket_dev,
 			"Process %u is opening a node held by %u.",

commit 40eb35023179e90b123f8c4b0bc5e1a412ff2d21
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:14 2018 -0700

    staging: gasket: remove extra parens in gasket_write_mappable_regions
    
    Remove unneeded parentheses around subexpressions.
    
    Reported-by: Guenter Roeck <groeck@chromium.org>
    Signed-off-by: Simon Que <sque@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index ae5febec8844..ba48a379b0ad 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1889,7 +1889,7 @@ static ssize_t gasket_write_mappable_regions(
 	if (bar_desc.permissions == GASKET_NOMAP)
 		return 0;
 	for (i = 0;
-	     (i < bar_desc.num_mappable_regions) && (total_written < PAGE_SIZE);
+	     i < bar_desc.num_mappable_regions && total_written < PAGE_SIZE;
 	     i++) {
 		min_addr = bar_desc.mappable_regions[i].start -
 			   driver_desc->legacy_mmap_address_offset;

commit fd5d76ab69a565ebcab94f11f185ea3dc5588249
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:13 2018 -0700

    staging: gasket: gasket_mmap use PAGE_MASK
    
    gasket_mmap use PAGE_MASK, instead of performing math on PAGE_SIZE, for
    simplicity and clarity.
    
    Reported-by: Guenter Roeck <groeck@chromium.org>
    Signed-off-by: Simon Que <sque@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 3cf918f9d260..ae5febec8844 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1591,7 +1591,7 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	}
 	driver_desc = gasket_dev->internal_desc->driver_desc;
 
-	if (vma->vm_start & (PAGE_SIZE - 1)) {
+	if (vma->vm_start & ~PAGE_MASK) {
 		gasket_log_error(
 			gasket_dev, "Base address not page-aligned: 0x%p\n",
 			(void *)vma->vm_start);

commit e80d8afc97fb243833d9939b5098a89379433b3c
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:07 2018 -0700

    staging: gasket: gasket_mmap return error instead of valid BAR index
    
    When offset to be mapped matches both a BAR region and a coherent mapped
    region return an error as intended, not the BAR index.
    
    Signed-off-by: Simon Que <sque@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index eb5ad161ccda..3cf918f9d260 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1627,7 +1627,7 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 			"0x%lx",
 			raw_offset);
 		trace_gasket_mmap_exit(bar_index);
-		return bar_index;
+		return -EINVAL;
 	}
 
 	vma->vm_private_data = gasket_dev;

commit ec45f01668e42f3dc3f18e11fa8655ad150ca250
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:06 2018 -0700

    staging: gasket: don't treat no device reset callback as an error
    
    It is not an error for a device to not have a reset callback registered.
    
    Signed-off-by: Simon Que <sque@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 53236e1ba4e4..eb5ad161ccda 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1836,11 +1836,8 @@ int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
 	const struct gasket_driver_desc *driver_desc;
 
 	driver_desc = gasket_dev->internal_desc->driver_desc;
-	if (!driver_desc->device_reset_cb) {
-		gasket_log_error(
-			gasket_dev, "No device reset callback was registered.");
-		return -EINVAL;
-	}
+	if (!driver_desc->device_reset_cb)
+		return 0;
 
 	/* Perform a device reset of the requested type. */
 	ret = driver_desc->device_reset_cb(gasket_dev, reset_type);

commit ae27b2f9f76afc7bf77ef6001ba47fad43a9fce3
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:04 2018 -0700

    staging: gasket: fix class create bug handling
    
    class_create() never returns NULL, and this driver should never return
    PTR_ERR(NULL) anyway.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Reviewed-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 18cc8e3283b3..53236e1ba4e4 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -321,7 +321,7 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 	internal->class =
 		class_create(driver_desc->module, driver_desc->name);
 
-	if (IS_ERR_OR_NULL(internal->class)) {
+	if (IS_ERR(internal->class)) {
 		gasket_nodev_error("Cannot register %s class [ret=%ld]",
 				   driver_desc->name, PTR_ERR(internal->class));
 		ret = PTR_ERR(internal->class);

commit b6fdbbb743ce86030d0898b53d64ff009fd50faa
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:03 2018 -0700

    staging: gasket: remove code for no physical device
    
    gasket_enable_dev code for enabling a gasket device with no physical PCI
    device registered shouldn't be necessary.
    
    Reported-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index f327c9d7f90a..18cc8e3283b3 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -898,7 +898,6 @@ static int gasket_enable_dev(
 {
 	int tbl_idx;
 	int ret;
-	struct device *ddev;
 	const struct gasket_driver_desc *driver_desc =
 		internal_desc->driver_desc;
 
@@ -919,21 +918,12 @@ static int gasket_enable_dev(
 	for (tbl_idx = 0; tbl_idx < driver_desc->num_page_tables; tbl_idx++) {
 		gasket_log_debug(
 			gasket_dev, "Initializing page table %d.", tbl_idx);
-		if (gasket_dev->pci_dev) {
-			ddev = &gasket_dev->pci_dev->dev;
-		} else {
-			gasket_log_error(
-				gasket_dev,
-				"%s with no physical device!!", __func__);
-			WARN_ON(1);
-			ddev = NULL;
-		}
 		ret = gasket_page_table_init(
 			&gasket_dev->page_table[tbl_idx],
 			&gasket_dev->bar_data[
 				driver_desc->page_table_bar_index],
 			&driver_desc->page_table_configs[tbl_idx],
-			ddev, gasket_dev->pci_dev, true);
+			&gasket_dev->pci_dev->dev, gasket_dev->pci_dev, true);
 		if (ret) {
 			gasket_log_error(
 				gasket_dev,

commit 7a013c5026df8fea863c13f414b5bda93039a906
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:02 2018 -0700

    staging: gasket: gasket_enable_dev remove unnecessary variable
    
    Remove unnecessary variable, pass constant param instead.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 0d5ba7359af7..f327c9d7f90a 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -898,7 +898,6 @@ static int gasket_enable_dev(
 {
 	int tbl_idx;
 	int ret;
-	bool has_dma_ops;
 	struct device *ddev;
 	const struct gasket_driver_desc *driver_desc =
 		internal_desc->driver_desc;
@@ -917,8 +916,6 @@ static int gasket_enable_dev(
 		return ret;
 	}
 
-	has_dma_ops = true;
-
 	for (tbl_idx = 0; tbl_idx < driver_desc->num_page_tables; tbl_idx++) {
 		gasket_log_debug(
 			gasket_dev, "Initializing page table %d.", tbl_idx);
@@ -936,7 +933,7 @@ static int gasket_enable_dev(
 			&gasket_dev->bar_data[
 				driver_desc->page_table_bar_index],
 			&driver_desc->page_table_configs[tbl_idx],
-			ddev, gasket_dev->pci_dev, has_dma_ops);
+			ddev, gasket_dev->pci_dev, true);
 		if (ret) {
 			gasket_log_error(
 				gasket_dev,

commit d7db5843bc09c4d8a7d30c09b18c03a1dd5fd713
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 17 13:56:55 2018 -0700

    staging: gasket: drop gasket_cdev_get_info, use container_of
    
    Remove gasket_cdev_get_info(), use container_of() directly instead,
    drop unnecessary NULL checks.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index bc3662eafb63..0d5ba7359af7 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -233,18 +233,6 @@ static inline int gasket_check_and_invoke_callback_nolock(
 	return ret;
 }
 
-/*
- * Retrieve device-specific data via cdev pointer.
- * @cdev_ptr: Character device pointer associated with the device.
- *
- * This function returns the pointer to the device-specific data allocated in
- * add_dev_cb for the device associated with cdev_ptr.
- */
-static struct gasket_cdev_info *gasket_cdev_get_info(struct cdev *cdev_ptr)
-{
-	return container_of(cdev_ptr, struct gasket_cdev_info, cdev);
-}
-
 /*
  * Returns nonzero if the gasket_cdev_info is owned by the current thread group
  * ID.
@@ -1095,12 +1083,9 @@ static int gasket_open(struct inode *inode, struct file *filp)
 	const struct gasket_driver_desc *driver_desc;
 	struct gasket_ownership *ownership;
 	char task_name[TASK_COMM_LEN];
-	struct gasket_cdev_info *dev_info = gasket_cdev_get_info(inode->i_cdev);
+	struct gasket_cdev_info *dev_info =
+	    container_of(inode->i_cdev, struct gasket_cdev_info, cdev);
 
-	if (!dev_info) {
-		gasket_nodev_error("Unable to retrieve device data");
-		return -EINVAL;
-	}
 	gasket_dev = dev_info->gasket_dev_ptr;
 	driver_desc = gasket_dev->internal_desc->driver_desc;
 	ownership = &dev_info->ownership;
@@ -1182,11 +1167,8 @@ static int gasket_release(struct inode *inode, struct file *file)
 	const struct gasket_driver_desc *driver_desc;
 	char task_name[TASK_COMM_LEN];
 	struct gasket_cdev_info *dev_info =
-		(struct gasket_cdev_info *)gasket_cdev_get_info(inode->i_cdev);
-	if (!dev_info) {
-		gasket_nodev_error("Unable to retrieve device data");
-		return -EINVAL;
-	}
+		container_of(inode->i_cdev, struct gasket_cdev_info, cdev);
+
 	gasket_dev = dev_info->gasket_dev_ptr;
 	driver_desc = gasket_dev->internal_desc->driver_desc;
 	ownership = &dev_info->ownership;

commit 45042402ae97682b965d88f2393f317f48bb0042
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 17 13:56:54 2018 -0700

    staging: gasket: bail out of reset sequence on device callback error
    
    If device reset callback returns an error, error out at the gasket
    level.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 94e64b900380..bc3662eafb63 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1875,9 +1875,11 @@ int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
 
 	/* Perform a device reset of the requested type. */
 	ret = driver_desc->device_reset_cb(gasket_dev, reset_type);
-	if (ret)
+	if (ret) {
 		gasket_log_error(
 			gasket_dev, "Device reset cb returned %d.", ret);
+		return ret;
+	}
 
 	/* Reinitialize the page tables and interrupt framework. */
 	for (i = 0; i < driver_desc->num_page_tables; ++i)

commit 72a23054a95c5439b779930b6ffa129437178ac9
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 17 13:56:53 2018 -0700

    staging: gasket: gasket_wait_with_reschedule use 32 bits of retry count
    
    Don't need a 64-bit retry counter.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 5ae3d44f6166..94e64b900380 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -2089,9 +2089,9 @@ struct device *gasket_get_device(struct gasket_dev *dev)
  **/
 int gasket_wait_with_reschedule(
 	struct gasket_dev *gasket_dev, int bar, u64 offset, u64 mask, u64 val,
-	u64 max_retries, u64 delay_ms)
+	uint max_retries, u64 delay_ms)
 {
-	u64 retries = 0;
+	uint retries = 0;
 	u64 tmp;
 
 	while (retries < max_retries) {

commit a42ea3d61c65946f7ccb1fbba7361e31eb367026
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 17 13:56:52 2018 -0700

    staging: gasket: gasket_wait_with_reschedule simplify logic
    
    gasket_wait_with_reschedule() is a little more clear if we just return
    directly when the waited-for condition is hit.  This also allows the
    following condition check to be removed and identation of the
    conditionally-executed code to be reduced.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 442543573f6e..5ae3d44f6166 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -2097,18 +2097,12 @@ int gasket_wait_with_reschedule(
 	while (retries < max_retries) {
 		tmp = gasket_dev_read_64(gasket_dev, bar, offset);
 		if ((tmp & mask) == val)
-			break;
+			return 0;
 		msleep(delay_ms);
 		retries++;
 	}
-	if (retries == max_retries) {
-		gasket_log_error(
-			gasket_dev,
-			"%s timeout: reg %llx timeout (%llu ms)",
-			__func__,
-			offset, max_retries * delay_ms);
-		return -ETIMEDOUT;
-	}
-	return 0;
+	gasket_log_error(gasket_dev, "%s timeout: reg %llx timeout (%llu ms)",
+			 __func__, offset, max_retries * delay_ms);
+	return -ETIMEDOUT;
 }
 EXPORT_SYMBOL(gasket_wait_with_reschedule);

commit c17acfdf4ad544144bd1a9fa3d19725cad0b236d
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 17 13:56:51 2018 -0700

    staging: gasket: gasket_wait_with_reschedule use msleep
    
    Replace schedule_timeout() call with msleep() for simplicity.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 803566229bfc..442543573f6e 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -14,6 +14,7 @@
 #include "gasket_page_table.h"
 #include "gasket_sysfs.h"
 
+#include <linux/delay.h>
 #include <linux/fs.h>
 #include <linux/init.h>
 #include <linux/of.h>
@@ -2097,7 +2098,7 @@ int gasket_wait_with_reschedule(
 		tmp = gasket_dev_read_64(gasket_dev, bar, offset);
 		if ((tmp & mask) == val)
 			break;
-		schedule_timeout(msecs_to_jiffies(delay_ms));
+		msleep(delay_ms);
 		retries++;
 	}
 	if (retries == max_retries) {

commit 24dfee40e6c4b558437db1bdb3c4927cec1bda51
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 17 13:56:50 2018 -0700

    staging: gasket: fix gasket_wait_with_reschedule timeout return code
    
    Return -ETIMEDOUT, not -EINVAL, on timeout, including callers.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 248d717e1df6..803566229bfc 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -2106,7 +2106,7 @@ int gasket_wait_with_reschedule(
 			"%s timeout: reg %llx timeout (%llu ms)",
 			__func__,
 			offset, max_retries * delay_ms);
-		return -EINVAL;
+		return -ETIMEDOUT;
 	}
 	return 0;
 }

commit e24fbaf73f0541994ab3a947bcf6feb5258c9204
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 17 13:56:49 2018 -0700

    staging: gasket: convert gasket_mmap_has_permissions to bool return
    
    gasket_mmap_has_permissions() should return a boolean value.
    
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 2ff328652356..248d717e1df6 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1241,19 +1241,19 @@ static int gasket_release(struct inode *inode, struct file *file)
  * that the provided descriptor/range is of adequate size to hold the range to
  * be mapped.
  */
-static int gasket_mmap_has_permissions(
+static bool gasket_mmap_has_permissions(
 	struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
 	int bar_permissions)
 {
 	int requested_permissions;
 	/* Always allow sysadmin to access. */
 	if (capable(CAP_SYS_ADMIN))
-		return 1;
+		return true;
 
 	/* Never allow non-sysadmins to access to a dead device. */
 	if (gasket_dev->status != GASKET_STATUS_ALIVE) {
 		gasket_log_info(gasket_dev, "Device is dead.");
-		return 0;
+		return false;
 	}
 
 	/* Make sure that no wrong flags are set. */
@@ -1265,7 +1265,7 @@ static int gasket_mmap_has_permissions(
 			"Attempting to map a region with requested permissions "
 			"0x%x, but region has permissions 0x%x.",
 			requested_permissions, bar_permissions);
-		return 0;
+		return false;
 	}
 
 	/* Do not allow a non-owner to write. */
@@ -1275,10 +1275,10 @@ static int gasket_mmap_has_permissions(
 			gasket_dev,
 			"Attempting to mmap a region for write without owning "
 			"device.");
-		return 0;
+		return false;
 	}
 
-	return 1;
+	return true;
 }
 
 /*

commit 722c902aacfefcda4aa0517be82af5cfd2ec4bb0
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 17 13:56:46 2018 -0700

    staging: gasket: hold mutex on gasket driver unregistration
    
    Take the global mutex on driver unregistration updates for proper
    ordering of updates and consistent access procedures.
    
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index cbadab7544c8..2ff328652356 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -371,7 +371,9 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 	class_destroy(internal->class);
 
 unregister_gasket_driver:
+	mutex_lock(&g_mutex);
 	g_descs[desc_idx].driver_desc = NULL;
+	mutex_unlock(&g_mutex);
 	return ret;
 }
 EXPORT_SYMBOL(gasket_register_device);
@@ -408,7 +410,9 @@ void gasket_unregister_device(const struct gasket_driver_desc *driver_desc)
 	class_destroy(internal_desc->class);
 
 	/* Finally, effectively "remove" the driver. */
+	mutex_lock(&g_mutex);
 	g_descs[desc_idx].driver_desc = NULL;
+	mutex_unlock(&g_mutex);
 
 	gasket_nodev_info("removed %s driver", driver_desc->name);
 }

commit ba6585847ebc432e0c808c2bd194e620017b5901
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 17 13:56:45 2018 -0700

    staging: gasket: remove driver registration on class creation failure
    
    If class_create() fails, remove the gasket driver from the global
    registration table.
    
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index b69b630f1b79..cbadab7544c8 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -335,7 +335,8 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 	if (IS_ERR_OR_NULL(internal->class)) {
 		gasket_nodev_error("Cannot register %s class [ret=%ld]",
 				   driver_desc->name, PTR_ERR(internal->class));
-		return PTR_ERR(internal->class);
+		ret = PTR_ERR(internal->class);
+		goto unregister_gasket_driver;
 	}
 
 	/*
@@ -369,6 +370,7 @@ int gasket_register_device(const struct gasket_driver_desc *driver_desc)
 fail1:
 	class_destroy(internal->class);
 
+unregister_gasket_driver:
 	g_descs[desc_idx].driver_desc = NULL;
 	return ret;
 }

commit bfd727f3a59c3696d6fbe086589376a16a5cdf05
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jul 13 17:46:17 2018 +0200

    staging: gasket: remove gasket_wait_sync()
    
    This function is not called anywhere, so just remove it.
    
    Also, as an added benifit, Arnd points out that it doesn't even work
    properly:
            This code won't work correct during leap seconds or a concurrent
            settimeofday() call, and it probably doesn't do what the author intended
            even for the normal case, as it passes a timeout in nanoseconds but
            reads the time using a jiffies-granularity accessor.
    
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 14649a794e35..b69b630f1b79 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -2067,51 +2067,6 @@ struct device *gasket_get_device(struct gasket_dev *dev)
 	return NULL;
 }
 
-/**
- * Synchronously waits on device.
- * @gasket_dev: Device struct.
- * @bar: Bar
- * @offset: Register offset
- * @mask: Register mask
- * @val: Expected value
- * @timeout_ns: Timeout in nanoseconds
- *
- * Description: Busy waits for a specific combination of bits to be set
- * on a Gasket register.
- **/
-int gasket_wait_sync(
-	struct gasket_dev *gasket_dev, int bar, u64 offset, u64 mask, u64 val,
-	u64 timeout_ns)
-{
-	u64 reg;
-	struct timespec start_time, cur_time;
-	u64 diff_nanosec;
-	int count = 0;
-
-	reg = gasket_dev_read_64(gasket_dev, bar, offset);
-	start_time = current_kernel_time();
-	while ((reg & mask) != val) {
-		count++;
-		cur_time = current_kernel_time();
-		diff_nanosec = (u64)(cur_time.tv_sec - start_time.tv_sec) *
-				       1000000000LL +
-			       (u64)(cur_time.tv_nsec) -
-			       (u64)(start_time.tv_nsec);
-		if (diff_nanosec > timeout_ns) {
-			gasket_log_error(
-				gasket_dev,
-				"%s timeout: reg %llx count %x "
-				"dma %lld ns\n",
-				__func__,
-				offset, count, diff_nanosec);
-			return -1;
-		}
-		reg = gasket_dev_read_64(gasket_dev, bar, offset);
-	}
-	return 0;
-}
-EXPORT_SYMBOL(gasket_wait_sync);
-
 /**
  * Asynchronously waits on device.
  * @gasket_dev: Device struct.

commit 948fd537bd3d6f347ff1c87b82479873d1fcc77f
Author: Felix Siegel <felix.siegel@posteo.de>
Date:   Fri Jul 13 00:58:49 2018 +0200

    staging: gasket: Use __func__ instead of hardcoded string - Style
    
    Changed logging statements to use %s and __func__ instead of hard coding
    the function name in a string.
    
    Signed-off-by: Felix Siegel <felix.siegel@posteo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 4ca6e53116ea..14649a794e35 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -932,7 +932,7 @@ static int gasket_enable_dev(
 		} else {
 			gasket_log_error(
 				gasket_dev,
-				"gasket_enable_dev with no physical device!!");
+				"%s with no physical device!!", __func__);
 			WARN_ON(1);
 			ddev = NULL;
 		}
@@ -2100,8 +2100,9 @@ int gasket_wait_sync(
 		if (diff_nanosec > timeout_ns) {
 			gasket_log_error(
 				gasket_dev,
-				"gasket_wait_sync timeout: reg %llx count %x "
+				"%s timeout: reg %llx count %x "
 				"dma %lld ns\n",
+				__func__,
 				offset, count, diff_nanosec);
 			return -1;
 		}
@@ -2141,7 +2142,8 @@ int gasket_wait_with_reschedule(
 	if (retries == max_retries) {
 		gasket_log_error(
 			gasket_dev,
-			"gasket_wait_with_reschedule timeout: reg %llx timeout (%llu ms)",
+			"%s timeout: reg %llx timeout (%llu ms)",
+			__func__,
 			offset, max_retries * delay_ms);
 		return -EINVAL;
 	}

commit e96a31cee962d766409d7da25d1831b3348b0a61
Author: Felix Siegel <felix.siegel@posteo.de>
Date:   Thu Jul 12 21:27:14 2018 +0200

    staging: gasket: fix multi line comments style
    
    This patch fixes checkpatch.pl warnings:
    
    WARNING: Block comments should align the * on each line
    
    Signed-off-by: Felix Siegel <felix.siegel@posteo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 5863a3f79ff4..4ca6e53116ea 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1347,9 +1347,9 @@ static bool gasket_mm_get_mapping_addrs(
 	*virt_offset = 0;
 	if (bar_offset + requested_length < range_start) {
 		/*
-		* If the requested region is completely below the range,
-		* there is nothing to map.
-		*/
+		 * If the requested region is completely below the range,
+		 * there is nothing to map.
+		 */
 		return false;
 	} else if (bar_offset <= range_start) {
 		/* If the bar offset is below this range's start
@@ -1507,7 +1507,7 @@ static enum do_map_region_status do_map_region(
  * Calculates the offset where the VMA range begins in its containing BAR.
  * The offset is written into bar_offset on success.
  * Returns zero on success, anything else on error.
-*/
+ */
 static int gasket_mm_vma_bar_offset(
 	const struct gasket_dev *gasket_dev, const struct vm_area_struct *vma,
 	ulong *bar_offset)

commit 5c60ce7b6ae9a056ddcdee318142b60c0e09aed1
Author: Felix Siegel <felix.siegel@posteo.de>
Date:   Thu Jul 12 21:27:13 2018 +0200

    staging: gasket: Move open-curly brace to match kernel code style
    
    Move open open-curly brace to the next line following function
    definition to match the kernel's coding style
    
    Signed-off-by: Felix Siegel <felix.siegel@posteo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 926113b7d6af..5863a3f79ff4 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1895,7 +1895,8 @@ int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
 EXPORT_SYMBOL(gasket_reset_nolock);
 
 gasket_ioctl_permissions_cb_t gasket_get_ioctl_permissions_cb(
-	struct gasket_dev *gasket_dev) {
+	struct gasket_dev *gasket_dev)
+{
 	return gasket_dev->internal_desc->driver_desc->ioctl_permissions_cb;
 }
 EXPORT_SYMBOL(gasket_get_ioctl_permissions_cb);

commit bf9c7a8673831acd67ad4a92b6acd85ffcde174c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 11 13:39:11 2018 +0200

    staging: gasket: remove redundant license information
    
    Now that the SPDX tag is in all gasket files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index a09f491296fb..926113b7d6af 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1,18 +1,10 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Gasket generic driver framework. This file contains the implementation
+/*
+ * Gasket generic driver framework. This file contains the implementation
  * for the Gasket generic driver framework - the functionality that is common
  * across Gasket devices.
  *
  * Copyright (C) 2018 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 #include "gasket_core.h"
 

commit 2dec0644e0c8083e0a9d3bbdd11aad2d850859e9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 11 13:39:10 2018 +0200

    staging: gasket: add SPDX identifiers to all files.
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the all of the staging gasket files to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 45914ebc8f44..a09f491296fb 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /* Gasket generic driver framework. This file contains the implementation
  * for the Gasket generic driver framework - the functionality that is common
  * across Gasket devices.

commit 5a2c3ebe749d91136e4fe7a6a51f10f2d0703665
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Jul 11 11:40:05 2018 +0100

    staging: gasket: remove redundant pointer bar_data
    
    Pointer bar_data is being assigned but is never used hence it is redundant
    and can be removed.
    
    Cleans up clang warning:
    warning: variable 'bar_data' set but not used [-Wunused-but-set-variable]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index ad9442a5bb9d..45914ebc8f44 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1610,7 +1610,6 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	bool is_coherent_region;
 	const struct gasket_driver_desc *driver_desc;
 	struct gasket_dev *gasket_dev = (struct gasket_dev *)filp->private_data;
-	struct gasket_bar_data *bar_data;
 	const struct gasket_bar_desc *bar_desc;
 	struct gasket_mappable_region *map_regions = NULL;
 	int num_map_regions = 0;
@@ -1673,8 +1672,6 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 	 * Subtract the base of the bar from the raw offset to get the
 	 * memory location within the bar to map.
 	 */
-	bar_data = &gasket_dev->bar_data[bar_index];
-
 	bar_desc = &driver_desc->bar_descriptions[bar_index];
 	permissions = bar_desc->permissions;
 	if (!gasket_mmap_has_permissions(gasket_dev, vma, permissions)) {

commit 97b23455ccd53a632585d0fd06ff9d30877c810a
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jul 6 11:37:56 2018 +0300

    Staging: Gasket: uninitialized return in gasket_mmap()
    
    We forgot to set the error code on this error path so ret can be
    uninitialized.
    
    Fixes: 9a69f5087ccc ("drivers/staging: Gasket driver framework + Apex driver")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 82b3eca7774e..ad9442a5bb9d 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1719,8 +1719,10 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 		/* Try the next region if this one was not mappable. */
 		if (map_status == DO_MAP_REGION_INVALID)
 			continue;
-		if (map_status == DO_MAP_REGION_FAILURE)
+		if (map_status == DO_MAP_REGION_FAILURE) {
+			ret = -ENOMEM;
 			goto fail;
+		}
 
 		has_mapped_anything = 1;
 	}

commit 9f2378d94d0f026389fff351848f2adc484650fe
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 4 10:31:25 2018 -0700

    drivers/staging/gasket: Use 2-factor allocator calls
    
    As already done treewide, switch from open-coded multiplication to using
    2-factor allocator helpers.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
index 6511a33eb658..82b3eca7774e 100644
--- a/drivers/staging/gasket/gasket_core.c
+++ b/drivers/staging/gasket/gasket_core.c
@@ -1697,9 +1697,9 @@ static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
 			return -EPERM;
 		}
 		num_map_regions = bar_desc->num_mappable_regions;
-		map_regions = kzalloc(
-			num_map_regions * sizeof(*bar_desc->mappable_regions),
-			GFP_KERNEL);
+		map_regions = kcalloc(num_map_regions,
+				      sizeof(*bar_desc->mappable_regions),
+				      GFP_KERNEL);
 		if (map_regions) {
 			memcpy(map_regions, bar_desc->mappable_regions,
 			       num_map_regions *

commit 9a69f5087ccc20bb411025decab455836df04168
Author: Simon Que <sque@chromium.org>
Date:   Fri Jun 29 22:49:38 2018 -0400

    drivers/staging: Gasket driver framework + Apex driver
    
    The Gasket (Google ASIC Software, Kernel Extensions, and Tools) kernel
    framework is a generic, flexible system that supports thin kernel
    drivers. Gasket kernel drivers are expected to handle opening and
    closing devices, mmap'ing BAR space as requested, a small selection of
    ioctls, and handling page table translation (covered below). Any other
    functions should be handled by userspace code.
    
    The Gasket common module is not enough to run a device. In order to
    customize the Gasket code for a given piece of hardware, a device
    specific module must be created. At a minimum, this module must define a
    struct gasket_driver_desc containing the device-specific data for use by
    the framework; in addition, the module must declare an __init function
    that calls gasket_register_device with the module's gasket_driver_desc
    struct. Finally, the driver must define an exit function that calls
    gasket_unregister_device with the module's gasket_driver_desc struct.
    
    One of the core assumptions of the Gasket framework is that precisely
    one process is allowed to have an open write handle to the device node
    at any given time. (That process may, once it has one write handle, open
    any number of additional write handles.) This is accomplished by
    tracking open and close data for each driver instance.
    
    Signed-off-by: Rob Springer <rspringer@google.com>
    Signed-off-by: John Joseph <jnjoseph@google.com>
    Signed-off-by: Simon Que <sque@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.c b/drivers/staging/gasket/gasket_core.c
new file mode 100644
index 000000000000..6511a33eb658
--- /dev/null
+++ b/drivers/staging/gasket/gasket_core.c
@@ -0,0 +1,2157 @@
+/* Gasket generic driver framework. This file contains the implementation
+ * for the Gasket generic driver framework - the functionality that is common
+ * across Gasket devices.
+ *
+ * Copyright (C) 2018 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include "gasket_core.h"
+
+#include "gasket_interrupt.h"
+#include "gasket_ioctl.h"
+#include "gasket_logging.h"
+#include "gasket_page_table.h"
+#include "gasket_sysfs.h"
+
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/of.h>
+
+#ifdef GASKET_KERNEL_TRACE_SUPPORT
+#define CREATE_TRACE_POINTS
+#include <trace/events/gasket_mmap.h>
+#else
+#define trace_gasket_mmap_exit(x)
+#define trace_gasket_mmap_entry(x, ...)
+#endif
+
+/*
+ * "Private" members of gasket_driver_desc.
+ *
+ * Contains internal per-device type tracking data, i.e., data not appropriate
+ * as part of the public interface for the generic framework.
+ */
+struct gasket_internal_desc {
+	/* Device-specific-driver-provided configuration information. */
+	const struct gasket_driver_desc *driver_desc;
+
+	/* Protects access to per-driver data (i.e. this structure). */
+	struct mutex mutex;
+
+	/* Kernel-internal device class. */
+	struct class *class;
+
+	/* PCI subsystem metadata associated with this driver. */
+	struct pci_driver pci;
+
+	/* Instantiated / present devices of this type. */
+	struct gasket_dev *devs[GASKET_DEV_MAX];
+};
+
+/* do_map_region() needs be able to return more than just true/false. */
+enum do_map_region_status {
+	/* The region was successfully mapped. */
+	DO_MAP_REGION_SUCCESS,
+
+	/* Attempted to map region and failed. */
+	DO_MAP_REGION_FAILURE,
+
+	/* The requested region to map was not part of a mappable region. */
+	DO_MAP_REGION_INVALID,
+};
+
+/* Function declarations; comments are with definitions. */
+static int __init gasket_init(void);
+static void __exit gasket_exit(void);
+
+static int gasket_pci_probe(
+	struct pci_dev *pci_dev, const struct pci_device_id *id);
+static void gasket_pci_remove(struct pci_dev *pci_dev);
+
+static int gasket_setup_pci(struct pci_dev *pci_dev, struct gasket_dev *dev);
+static void gasket_cleanup_pci(struct gasket_dev *dev);
+
+static int gasket_map_pci_bar(struct gasket_dev *dev, int bar_num);
+static void gasket_unmap_pci_bar(struct gasket_dev *dev, int bar_num);
+
+static int gasket_alloc_dev(
+	struct gasket_internal_desc *internal_desc, struct device *dev,
+	struct gasket_dev **pdev, const char *kobj_name);
+static void gasket_free_dev(struct gasket_dev *dev);
+
+static int gasket_find_dev_slot(
+	struct gasket_internal_desc *internal_desc, const char *kobj_name);
+
+static int gasket_add_cdev(
+	struct gasket_cdev_info *dev_info,
+	const struct file_operations *file_ops, struct module *owner);
+
+static int gasket_enable_dev(
+	struct gasket_internal_desc *internal_desc,
+	struct gasket_dev *gasket_dev);
+static void gasket_disable_dev(struct gasket_dev *gasket_dev);
+
+static struct gasket_internal_desc *lookup_internal_desc(
+	struct pci_dev *pci_dev);
+
+static ssize_t gasket_sysfs_data_show(
+	struct device *device, struct device_attribute *attr, char *buf);
+
+static int gasket_mmap(struct file *filp, struct vm_area_struct *vma);
+static int gasket_open(struct inode *inode, struct file *file);
+static int gasket_release(struct inode *inode, struct file *file);
+static long gasket_ioctl(struct file *filp, uint cmd, ulong arg);
+
+static int gasket_mm_vma_bar_offset(
+	const struct gasket_dev *gasket_dev, const struct vm_area_struct *vma,
+	ulong *bar_offset);
+static bool gasket_mm_get_mapping_addrs(
+	const struct gasket_mappable_region *region, ulong bar_offset,
+	ulong requested_length, struct gasket_mappable_region *mappable_region,
+	ulong *virt_offset);
+static enum do_map_region_status do_map_region(
+	const struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
+	struct gasket_mappable_region *map_region);
+
+static int gasket_get_hw_status(struct gasket_dev *gasket_dev);
+
+/* Global data definitions. */
+/* Mutex - only for framework-wide data. Other data should be protected by
+ * finer-grained locks.
+ */
+static DEFINE_MUTEX(g_mutex);
+
+/* List of all registered device descriptions & their supporting data. */
+static struct gasket_internal_desc g_descs[GASKET_FRAMEWORK_DESC_MAX];
+
+/* Mapping of statuses to human-readable strings. Must end with {0,NULL}. */
+static const struct gasket_num_name gasket_status_name_table[] = {
+	{ GASKET_STATUS_DEAD, "DEAD" },
+	{ GASKET_STATUS_ALIVE, "ALIVE" },
+	{ GASKET_STATUS_LAMED, "LAMED" },
+	{ GASKET_STATUS_DRIVER_EXIT, "DRIVER_EXITING" },
+	{ 0, NULL },
+};
+
+/* Enumeration of the automatic Gasket framework sysfs nodes. */
+enum gasket_sysfs_attribute_type {
+	ATTR_BAR_OFFSETS,
+	ATTR_BAR_SIZES,
+	ATTR_DRIVER_VERSION,
+	ATTR_FRAMEWORK_VERSION,
+	ATTR_DEVICE_TYPE,
+	ATTR_HARDWARE_REVISION,
+	ATTR_PCI_ADDRESS,
+	ATTR_STATUS,
+	ATTR_IS_DEVICE_OWNED,
+	ATTR_DEVICE_OWNER,
+	ATTR_WRITE_OPEN_COUNT,
+	ATTR_RESET_COUNT,
+	ATTR_USER_MEM_RANGES
+};
+
+/* File operations for all Gasket devices. */
+static const struct file_operations gasket_file_ops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.mmap = gasket_mmap,
+	.open = gasket_open,
+	.release = gasket_release,
+	.unlocked_ioctl = gasket_ioctl,
+};
+
+/* These attributes apply to all Gasket driver instances. */
+static const struct gasket_sysfs_attribute gasket_sysfs_generic_attrs[] = {
+	GASKET_SYSFS_RO(bar_offsets, gasket_sysfs_data_show, ATTR_BAR_OFFSETS),
+	GASKET_SYSFS_RO(bar_sizes, gasket_sysfs_data_show, ATTR_BAR_SIZES),
+	GASKET_SYSFS_RO(driver_version, gasket_sysfs_data_show,
+			ATTR_DRIVER_VERSION),
+	GASKET_SYSFS_RO(framework_version, gasket_sysfs_data_show,
+			ATTR_FRAMEWORK_VERSION),
+	GASKET_SYSFS_RO(device_type, gasket_sysfs_data_show, ATTR_DEVICE_TYPE),
+	GASKET_SYSFS_RO(revision, gasket_sysfs_data_show,
+			ATTR_HARDWARE_REVISION),
+	GASKET_SYSFS_RO(pci_address, gasket_sysfs_data_show, ATTR_PCI_ADDRESS),
+	GASKET_SYSFS_RO(status, gasket_sysfs_data_show, ATTR_STATUS),
+	GASKET_SYSFS_RO(is_device_owned, gasket_sysfs_data_show,
+			ATTR_IS_DEVICE_OWNED),
+	GASKET_SYSFS_RO(device_owner, gasket_sysfs_data_show,
+			ATTR_DEVICE_OWNER),
+	GASKET_SYSFS_RO(write_open_count, gasket_sysfs_data_show,
+			ATTR_WRITE_OPEN_COUNT),
+	GASKET_SYSFS_RO(reset_count, gasket_sysfs_data_show, ATTR_RESET_COUNT),
+	GASKET_SYSFS_RO(user_mem_ranges, gasket_sysfs_data_show,
+			ATTR_USER_MEM_RANGES),
+	GASKET_END_OF_ATTR_ARRAY
+};
+
+MODULE_DESCRIPTION("Google Gasket driver framework");
+MODULE_VERSION(GASKET_FRAMEWORK_VERSION);
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Rob Springer <rspringer@google.com>");
+module_init(gasket_init);
+module_exit(gasket_exit);
+
+/*
+ * Perform a standard Gasket callback.
+ * @gasket_dev: Device specific pointer to forward.
+ * @cb_function: Standard callback to perform.
+ */
+static inline int check_and_invoke_callback(
+	struct gasket_dev *gasket_dev, int (*cb_function)(struct gasket_dev *))
+{
+	int ret = 0;
+
+	gasket_nodev_error("check_and_invoke_callback %p", gasket_dev);
+	if (cb_function) {
+		mutex_lock(&gasket_dev->mutex);
+		ret = cb_function(gasket_dev);
+		mutex_unlock(&gasket_dev->mutex);
+	}
+	return ret;
+}
+
+/*
+ * Perform a standard Gasket callback
+ * without grabbing gasket_dev->mutex.
+ * @gasket_dev: Device specific pointer to forward.
+ * @cb_function: Standard callback to perform.
+ *
+ */
+static inline int gasket_check_and_invoke_callback_nolock(
+	struct gasket_dev *gasket_dev, int (*cb_function)(struct gasket_dev *))
+{
+	int ret = 0;
+
+	if (cb_function) {
+		gasket_log_info(
+			gasket_dev, "Invoking device-specific callback.");
+		ret = cb_function(gasket_dev);
+	}
+	return ret;
+}
+
+/*
+ * Retrieve device-specific data via cdev pointer.
+ * @cdev_ptr: Character device pointer associated with the device.
+ *
+ * This function returns the pointer to the device-specific data allocated in
+ * add_dev_cb for the device associated with cdev_ptr.
+ */
+static struct gasket_cdev_info *gasket_cdev_get_info(struct cdev *cdev_ptr)
+{
+	return container_of(cdev_ptr, struct gasket_cdev_info, cdev);
+}
+
+/*
+ * Returns nonzero if the gasket_cdev_info is owned by the current thread group
+ * ID.
+ * @info: Device node info.
+ */
+static int gasket_owned_by_current_tgid(struct gasket_cdev_info *info)
+{
+	return (info->ownership.is_owned &&
+		(info->ownership.owner == current->tgid));
+}
+
+static int __init gasket_init(void)
+{
+	int i;
+
+	gasket_nodev_info("Performing one-time init of the Gasket framework.");
+	/* Check for duplicates and find a free slot. */
+	mutex_lock(&g_mutex);
+	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
+		g_descs[i].driver_desc = NULL;
+		mutex_init(&g_descs[i].mutex);
+	}
+
+	gasket_sysfs_init();
+
+	mutex_unlock(&g_mutex);
+	return 0;
+}
+
+static void __exit gasket_exit(void)
+{
+	/* No deinit/dealloc needed at present. */
+	gasket_nodev_info("Removing Gasket framework module.");
+}
+
+/* See gasket_core.h for description. */
+int gasket_register_device(const struct gasket_driver_desc *driver_desc)
+{
+	int i, ret;
+	int desc_idx = -1;
+	struct gasket_internal_desc *internal;
+
+	gasket_nodev_info("Initializing Gasket framework device");
+	/* Check for duplicates and find a free slot. */
+	mutex_lock(&g_mutex);
+
+	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
+		if (g_descs[i].driver_desc == driver_desc) {
+			gasket_nodev_error(
+				"%s driver already loaded/registered",
+				driver_desc->name);
+			mutex_unlock(&g_mutex);
+			return -EBUSY;
+		}
+	}
+
+	/* This and the above loop could be combined, but this reads easier. */
+	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
+		if (!g_descs[i].driver_desc) {
+			g_descs[i].driver_desc = driver_desc;
+			desc_idx = i;
+			break;
+		}
+	}
+	mutex_unlock(&g_mutex);
+
+	gasket_nodev_info("Loaded %s driver, framework version %s",
+			  driver_desc->name, GASKET_FRAMEWORK_VERSION);
+
+	if (desc_idx == -1) {
+		gasket_nodev_error("Too many Gasket drivers loaded: %d\n",
+				   GASKET_FRAMEWORK_DESC_MAX);
+		return -EBUSY;
+	}
+
+	/* Internal structure setup. */
+	gasket_nodev_info("Performing initial internal structure setup.");
+	internal = &g_descs[desc_idx];
+	mutex_init(&internal->mutex);
+	memset(internal->devs, 0, sizeof(struct gasket_dev *) * GASKET_DEV_MAX);
+	memset(&internal->pci, 0, sizeof(internal->pci));
+	internal->pci.name = driver_desc->name;
+	internal->pci.id_table = driver_desc->pci_id_table;
+	internal->pci.probe = gasket_pci_probe;
+	internal->pci.remove = gasket_pci_remove;
+	internal->class =
+		class_create(driver_desc->module, driver_desc->name);
+
+	if (IS_ERR_OR_NULL(internal->class)) {
+		gasket_nodev_error("Cannot register %s class [ret=%ld]",
+				   driver_desc->name, PTR_ERR(internal->class));
+		return PTR_ERR(internal->class);
+	}
+
+	/*
+	 * Not using pci_register_driver() (without underscores), as it
+	 * depends on KBUILD_MODNAME, and this is a shared file.
+	 */
+	gasket_nodev_info("Registering PCI driver.");
+	ret = __pci_register_driver(
+		&internal->pci, driver_desc->module, driver_desc->name);
+	if (ret) {
+		gasket_nodev_error(
+			"cannot register pci driver [ret=%d]", ret);
+		goto fail1;
+	}
+
+	gasket_nodev_info("Registering char driver.");
+	ret = register_chrdev_region(
+		MKDEV(driver_desc->major, driver_desc->minor), GASKET_DEV_MAX,
+		driver_desc->name);
+	if (ret) {
+		gasket_nodev_error("cannot register char driver [ret=%d]", ret);
+		goto fail2;
+	}
+
+	gasket_nodev_info("Driver registered successfully.");
+	return 0;
+
+fail2:
+	pci_unregister_driver(&internal->pci);
+
+fail1:
+	class_destroy(internal->class);
+
+	g_descs[desc_idx].driver_desc = NULL;
+	return ret;
+}
+EXPORT_SYMBOL(gasket_register_device);
+
+/* See gasket_core.h for description. */
+void gasket_unregister_device(const struct gasket_driver_desc *driver_desc)
+{
+	int i, desc_idx;
+	struct gasket_internal_desc *internal_desc = NULL;
+
+	mutex_lock(&g_mutex);
+	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
+		if (g_descs[i].driver_desc == driver_desc) {
+			internal_desc = &g_descs[i];
+			desc_idx = i;
+			break;
+		}
+	}
+	mutex_unlock(&g_mutex);
+
+	if (!internal_desc) {
+		gasket_nodev_error(
+			"request to unregister unknown desc: %s, %d:%d",
+			driver_desc->name, driver_desc->major,
+			driver_desc->minor);
+		return;
+	}
+
+	unregister_chrdev_region(
+		MKDEV(driver_desc->major, driver_desc->minor), GASKET_DEV_MAX);
+
+	pci_unregister_driver(&internal_desc->pci);
+
+	class_destroy(internal_desc->class);
+
+	/* Finally, effectively "remove" the driver. */
+	g_descs[desc_idx].driver_desc = NULL;
+
+	gasket_nodev_info("removed %s driver", driver_desc->name);
+}
+EXPORT_SYMBOL(gasket_unregister_device);
+
+/**
+ * Allocate a Gasket device.
+ * @internal_desc: Pointer to the internal data for the device driver.
+ * @pdev: Pointer to the Gasket device pointer, the allocated device.
+ * @kobj_name: PCIe name for the device
+ *
+ * Description: Allocates and initializes a Gasket device structure.
+ *              Adds the device to the device list.
+ *
+ * Returns 0 if successful, a negative error code otherwise.
+ */
+static int gasket_alloc_dev(
+	struct gasket_internal_desc *internal_desc, struct device *parent,
+	struct gasket_dev **pdev, const char *kobj_name)
+{
+	int dev_idx;
+	const struct gasket_driver_desc *driver_desc =
+		internal_desc->driver_desc;
+	struct gasket_dev *gasket_dev;
+	struct gasket_cdev_info *dev_info;
+
+	gasket_nodev_info("Allocating a Gasket device %s.", kobj_name);
+
+	*pdev = NULL;
+
+	dev_idx = gasket_find_dev_slot(internal_desc, kobj_name);
+	if (dev_idx < 0)
+		return dev_idx;
+
+	gasket_dev = *pdev = kzalloc(sizeof(*gasket_dev), GFP_KERNEL);
+	if (!gasket_dev) {
+		gasket_nodev_error("no memory for device");
+		return -ENOMEM;
+	}
+	internal_desc->devs[dev_idx] = gasket_dev;
+
+	mutex_init(&gasket_dev->mutex);
+
+	gasket_dev->internal_desc = internal_desc;
+	gasket_dev->dev_idx = dev_idx;
+	snprintf(gasket_dev->kobj_name, GASKET_NAME_MAX, "%s", kobj_name);
+	/* gasket_bar_data is uninitialized. */
+	gasket_dev->num_page_tables = driver_desc->num_page_tables;
+	/* max_page_table_size and *page table are uninit'ed */
+	/* interrupt_data is not initialized. */
+	/* status is 0, or GASKET_STATUS_DEAD */
+
+	dev_info = &gasket_dev->dev_info;
+	snprintf(dev_info->name, GASKET_NAME_MAX, "%s_%u", driver_desc->name,
+		 gasket_dev->dev_idx);
+	dev_info->devt =
+		MKDEV(driver_desc->major, driver_desc->minor +
+			gasket_dev->dev_idx);
+	dev_info->device = device_create(internal_desc->class, parent,
+		dev_info->devt, gasket_dev, dev_info->name);
+
+	gasket_nodev_info("Gasket device allocated: %p.", dev_info->device);
+
+	/* cdev has not yet been added; cdev_added is 0 */
+	dev_info->gasket_dev_ptr = gasket_dev;
+	/* ownership is all 0, indicating no owner or opens. */
+
+	return 0;
+}
+
+/*
+ * Free a Gasket device.
+ * @internal_dev: Gasket device pointer; the device to unregister and free.
+ *
+ * Description: Removes the device from the device list and frees
+ *              the Gasket device structure.
+ */
+static void gasket_free_dev(struct gasket_dev *gasket_dev)
+{
+	struct gasket_internal_desc *internal_desc = gasket_dev->internal_desc;
+
+	mutex_lock(&internal_desc->mutex);
+	internal_desc->devs[gasket_dev->dev_idx] = NULL;
+	mutex_unlock(&internal_desc->mutex);
+
+	kfree(gasket_dev);
+}
+
+/*
+ * Finds the next free gasket_internal_dev slot.
+ *
+ * Returns the located slot number on success or a negative number on failure.
+ */
+static int gasket_find_dev_slot(
+	struct gasket_internal_desc *internal_desc, const char *kobj_name)
+{
+	int i;
+
+	mutex_lock(&internal_desc->mutex);
+
+	/* Search for a previous instance of this device. */
+	for (i = 0; i < GASKET_DEV_MAX; i++) {
+		if (internal_desc->devs[i] &&
+		    strcmp(internal_desc->devs[i]->kobj_name, kobj_name) == 0) {
+			gasket_nodev_error("Duplicate device %s", kobj_name);
+			mutex_unlock(&internal_desc->mutex);
+			return -EBUSY;
+		}
+	}
+
+	/* Find a free device slot. */
+	for (i = 0; i < GASKET_DEV_MAX; i++) {
+		if (!internal_desc->devs[i])
+			break;
+	}
+
+	if (i == GASKET_DEV_MAX) {
+		gasket_nodev_info(
+			"Too many registered devices; max %d", GASKET_DEV_MAX);
+		mutex_unlock(&internal_desc->mutex);
+		return -EBUSY;
+	}
+
+	mutex_unlock(&internal_desc->mutex);
+	return i;
+}
+
+/**
+ * PCI subsystem probe function.
+ * @pci_dev: PCI device pointer to the new device.
+ * @id: PCI device id structure pointer, the vendor and device ids.
+ *
+ * Called when a Gasket device is found. Allocates device metadata, maps device
+ * memory, and calls gasket_enable_dev to prepare the device for active use.
+ *
+ * Returns 0 if successful and a negative value otherwise.
+ */
+static int gasket_pci_probe(
+	struct pci_dev *pci_dev, const struct pci_device_id *id)
+{
+	int ret;
+	const char *kobj_name = dev_name(&pci_dev->dev);
+	struct gasket_internal_desc *internal_desc;
+	struct gasket_dev *gasket_dev;
+	const struct gasket_driver_desc *driver_desc;
+	struct device *parent;
+
+	gasket_nodev_info("Add Gasket device %s", kobj_name);
+
+	mutex_lock(&g_mutex);
+	internal_desc = lookup_internal_desc(pci_dev);
+	mutex_unlock(&g_mutex);
+	if (!internal_desc) {
+		gasket_nodev_info("PCI probe called for unknown driver type");
+		return -ENODEV;
+	}
+
+	driver_desc = internal_desc->driver_desc;
+
+	parent = &pci_dev->dev;
+	ret = gasket_alloc_dev(internal_desc, parent, &gasket_dev, kobj_name);
+	if (ret)
+		return ret;
+	if (IS_ERR_OR_NULL(gasket_dev->dev_info.device)) {
+		gasket_nodev_error("Cannot create %s device %s [ret = %ld]",
+				   driver_desc->name, gasket_dev->dev_info.name,
+				   PTR_ERR(gasket_dev->dev_info.device));
+		ret = -ENODEV;
+		goto fail1;
+	}
+	gasket_dev->pci_dev = pci_dev;
+
+	ret = gasket_setup_pci(pci_dev, gasket_dev);
+	if (ret)
+		goto fail2;
+
+	ret = check_and_invoke_callback(gasket_dev, driver_desc->add_dev_cb);
+	if (ret) {
+		gasket_log_error(gasket_dev, "Error in add device cb: %d", ret);
+		goto fail2;
+	}
+
+	ret = gasket_sysfs_create_mapping(
+		gasket_dev->dev_info.device, gasket_dev);
+	if (ret)
+		goto fail3;
+
+	/*
+	 * Once we've created the mapping structures successfully, attempt to
+	 * create a symlink to the pci directory of this object.
+	 */
+	ret = sysfs_create_link(&gasket_dev->dev_info.device->kobj,
+				&pci_dev->dev.kobj, dev_name(&pci_dev->dev));
+	if (ret) {
+		gasket_log_error(
+			gasket_dev, "Cannot create sysfs pci link: %d", ret);
+		goto fail3;
+	}
+	ret = gasket_sysfs_create_entries(
+		gasket_dev->dev_info.device, gasket_sysfs_generic_attrs);
+	if (ret)
+		goto fail4;
+
+	ret = check_and_invoke_callback(
+		gasket_dev, driver_desc->sysfs_setup_cb);
+	if (ret) {
+		gasket_log_error(
+			gasket_dev, "Error in sysfs setup cb: %d", ret);
+		goto fail5;
+	}
+
+	ret = gasket_enable_dev(internal_desc, gasket_dev);
+	if (ret) {
+		gasket_nodev_error("cannot setup %s device", driver_desc->name);
+		gasket_disable_dev(gasket_dev);
+		goto fail5;
+	}
+
+	return 0;
+
+fail5:
+	check_and_invoke_callback(gasket_dev, driver_desc->sysfs_cleanup_cb);
+fail4:
+fail3:
+	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
+fail2:
+	gasket_cleanup_pci(gasket_dev);
+	check_and_invoke_callback(gasket_dev, driver_desc->remove_dev_cb);
+	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
+fail1:
+	gasket_free_dev(gasket_dev);
+	return ret;
+}
+
+/*
+ * PCI subsystem remove function.
+ * @pci_dev: PCI device pointer; the device to remove.
+ *
+ * Called to remove a Gasket device. Finds the device in the device list and
+ * cleans up metadata.
+ */
+static void gasket_pci_remove(struct pci_dev *pci_dev)
+{
+	int i;
+	struct gasket_internal_desc *internal_desc;
+	struct gasket_dev *gasket_dev = NULL;
+	const struct gasket_driver_desc *driver_desc;
+	/* Find the device desc. */
+	mutex_lock(&g_mutex);
+	internal_desc = lookup_internal_desc(pci_dev);
+	if (!internal_desc) {
+		mutex_unlock(&g_mutex);
+		return;
+	}
+	mutex_unlock(&g_mutex);
+
+	driver_desc = internal_desc->driver_desc;
+
+	/* Now find the specific device */
+	mutex_lock(&internal_desc->mutex);
+	for (i = 0; i < GASKET_DEV_MAX; i++) {
+		if (internal_desc->devs[i] &&
+		    internal_desc->devs[i]->pci_dev == pci_dev) {
+			gasket_dev = internal_desc->devs[i];
+			break;
+		}
+	}
+	mutex_unlock(&internal_desc->mutex);
+
+	if (!gasket_dev)
+		return;
+
+	gasket_nodev_info(
+		"remove %s device %s", internal_desc->driver_desc->name,
+		gasket_dev->kobj_name);
+
+	gasket_disable_dev(gasket_dev);
+	gasket_cleanup_pci(gasket_dev);
+
+	check_and_invoke_callback(gasket_dev, driver_desc->sysfs_cleanup_cb);
+	gasket_sysfs_remove_mapping(gasket_dev->dev_info.device);
+
+	check_and_invoke_callback(gasket_dev, driver_desc->remove_dev_cb);
+
+	device_destroy(internal_desc->class, gasket_dev->dev_info.devt);
+	gasket_free_dev(gasket_dev);
+}
+
+/*
+ * Setup PCI & set up memory mapping for the specified device.
+ * @pci_dev: pointer to the particular PCI device.
+ * @internal_dev: Corresponding Gasket device pointer.
+ *
+ * Enables the PCI device, reads the BAR registers and sets up pointers to the
+ * device's memory mapped IO space.
+ *
+ * Returns 0 on success and a negative value otherwise.
+ */
+static int gasket_setup_pci(
+	struct pci_dev *pci_dev, struct gasket_dev *gasket_dev)
+{
+	int i, mapped_bars, ret;
+
+	gasket_dev->pci_dev = pci_dev;
+	ret = pci_enable_device(pci_dev);
+	if (ret) {
+		gasket_log_error(gasket_dev, "cannot enable PCI device");
+		return ret;
+	}
+
+	pci_set_master(pci_dev);
+
+	for (i = 0; i < GASKET_NUM_BARS; i++) {
+		ret = gasket_map_pci_bar(gasket_dev, i);
+		if (ret) {
+			mapped_bars = i;
+			goto fail;
+		}
+	}
+
+	return 0;
+
+fail:
+	for (i = 0; i < mapped_bars; i++)
+		gasket_unmap_pci_bar(gasket_dev, i);
+
+	pci_disable_device(pci_dev);
+	return -ENOMEM;
+}
+
+/* Unmaps memory and cleans up PCI for the specified device. */
+static void gasket_cleanup_pci(struct gasket_dev *gasket_dev)
+{
+	int i;
+
+	for (i = 0; i < GASKET_NUM_BARS; i++)
+		gasket_unmap_pci_bar(gasket_dev, i);
+
+	pci_disable_device(gasket_dev->pci_dev);
+}
+
+/*
+ * Maps the specified bar into kernel space.
+ * @internal_dev: Device possessing the BAR to map.
+ * @bar_num: The BAR to map.
+ *
+ * Returns 0 on success, a negative error code otherwise.
+ * A zero-sized BAR will not be mapped, but is not an error.
+ */
+static int gasket_map_pci_bar(struct gasket_dev *gasket_dev, int bar_num)
+{
+	struct gasket_internal_desc *internal_desc = gasket_dev->internal_desc;
+	const struct gasket_driver_desc *driver_desc =
+		internal_desc->driver_desc;
+	ulong desc_bytes = driver_desc->bar_descriptions[bar_num].size;
+	int ret;
+
+	if (desc_bytes == 0)
+		return 0;
+
+	if (driver_desc->bar_descriptions[bar_num].type != PCI_BAR) {
+		/* not PCI: skip this entry */
+		return 0;
+	}
+	/*
+	 * pci_resource_start and pci_resource_len return a "resource_size_t",
+	 * which is safely castable to ulong (which itself is the arg to
+	 * request_mem_region).
+	 */
+	gasket_dev->bar_data[bar_num].phys_base =
+		(ulong)pci_resource_start(gasket_dev->pci_dev, bar_num);
+	if (!gasket_dev->bar_data[bar_num].phys_base) {
+		gasket_log_error(gasket_dev, "Cannot get BAR%u base address",
+				 bar_num);
+		return -EINVAL;
+	}
+
+	gasket_dev->bar_data[bar_num].length_bytes =
+		(ulong)pci_resource_len(gasket_dev->pci_dev, bar_num);
+	if (gasket_dev->bar_data[bar_num].length_bytes < desc_bytes) {
+		gasket_log_error(
+			gasket_dev,
+			"PCI BAR %u space is too small: %lu; expected >= %lu",
+			bar_num, gasket_dev->bar_data[bar_num].length_bytes,
+			desc_bytes);
+		return -ENOMEM;
+	}
+
+	if (!request_mem_region(gasket_dev->bar_data[bar_num].phys_base,
+				gasket_dev->bar_data[bar_num].length_bytes,
+				gasket_dev->dev_info.name)) {
+		gasket_log_error(
+			gasket_dev,
+			"Cannot get BAR %d memory region %p",
+			bar_num, &gasket_dev->pci_dev->resource[bar_num]);
+		return -EINVAL;
+	}
+
+	gasket_dev->bar_data[bar_num].virt_base =
+		ioremap_nocache(gasket_dev->bar_data[bar_num].phys_base,
+				gasket_dev->bar_data[bar_num].length_bytes);
+	if (!gasket_dev->bar_data[bar_num].virt_base) {
+		gasket_log_error(
+			gasket_dev,
+			"Cannot remap BAR %d memory region %p",
+			bar_num, &gasket_dev->pci_dev->resource[bar_num]);
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	dma_set_mask(&gasket_dev->pci_dev->dev, DMA_BIT_MASK(64));
+	dma_set_coherent_mask(&gasket_dev->pci_dev->dev, DMA_BIT_MASK(64));
+
+	return 0;
+
+fail:
+	iounmap(gasket_dev->bar_data[bar_num].virt_base);
+	release_mem_region(gasket_dev->bar_data[bar_num].phys_base,
+			   gasket_dev->bar_data[bar_num].length_bytes);
+	return ret;
+}
+
+/*
+ * Releases PCI BAR mapping.
+ * @internal_dev: Device possessing the BAR to unmap.
+ *
+ * A zero-sized or not-mapped BAR will not be unmapped, but is not an error.
+ */
+static void gasket_unmap_pci_bar(struct gasket_dev *dev, int bar_num)
+{
+	ulong base, bytes;
+	struct gasket_internal_desc *internal_desc = dev->internal_desc;
+	const struct gasket_driver_desc *driver_desc =
+		internal_desc->driver_desc;
+
+	if (driver_desc->bar_descriptions[bar_num].size == 0 ||
+	    !dev->bar_data[bar_num].virt_base)
+		return;
+
+	if (driver_desc->bar_descriptions[bar_num].type != PCI_BAR)
+		return;
+
+	iounmap(dev->bar_data[bar_num].virt_base);
+	dev->bar_data[bar_num].virt_base = NULL;
+
+	base = pci_resource_start(dev->pci_dev, bar_num);
+	if (!base) {
+		gasket_log_error(
+			dev, "cannot get PCI BAR%u base address", bar_num);
+		return;
+	}
+
+	bytes = pci_resource_len(dev->pci_dev, bar_num);
+	release_mem_region(base, bytes);
+}
+
+/*
+ * Handle adding a char device and related info.
+ * @dev_info: Pointer to the dev_info struct for this device.
+ * @file_ops: The file operations for this device.
+ * @owner: The owning module for this device.
+ */
+static int gasket_add_cdev(
+	struct gasket_cdev_info *dev_info,
+	const struct file_operations *file_ops, struct module *owner)
+{
+	int ret;
+
+	cdev_init(&dev_info->cdev, file_ops);
+	dev_info->cdev.owner = owner;
+	ret = cdev_add(&dev_info->cdev, dev_info->devt, 1);
+	if (ret) {
+		gasket_log_error(
+			dev_info->gasket_dev_ptr,
+			"cannot add char device [ret=%d]", ret);
+		return ret;
+	}
+	dev_info->cdev_added = 1;
+
+	return 0;
+}
+
+/*
+ * Performs final init and marks the device as active.
+ * @internal_desc: Pointer to Gasket [internal] driver descriptor structure.
+ * @internal_dev: Pointer to Gasket [internal] device structure.
+ *
+ * Currently forwards all work to device-specific callback; a future phase will
+ * extract elements of character device registration here.
+ */
+static int gasket_enable_dev(
+	struct gasket_internal_desc *internal_desc,
+	struct gasket_dev *gasket_dev)
+{
+	int tbl_idx;
+	int ret;
+	bool has_dma_ops;
+	struct device *ddev;
+	const struct gasket_driver_desc *driver_desc =
+		internal_desc->driver_desc;
+
+	ret = gasket_interrupt_init(
+		gasket_dev, driver_desc->name,
+		driver_desc->interrupt_type, driver_desc->interrupts,
+		driver_desc->num_interrupts, driver_desc->interrupt_pack_width,
+		driver_desc->interrupt_bar_index,
+		driver_desc->wire_interrupt_offsets);
+	if (ret) {
+		gasket_log_error(gasket_dev,
+				 "Critical failure to allocate interrupts: %d",
+				 ret);
+		gasket_interrupt_cleanup(gasket_dev);
+		return ret;
+	}
+
+	has_dma_ops = true;
+
+	for (tbl_idx = 0; tbl_idx < driver_desc->num_page_tables; tbl_idx++) {
+		gasket_log_debug(
+			gasket_dev, "Initializing page table %d.", tbl_idx);
+		if (gasket_dev->pci_dev) {
+			ddev = &gasket_dev->pci_dev->dev;
+		} else {
+			gasket_log_error(
+				gasket_dev,
+				"gasket_enable_dev with no physical device!!");
+			WARN_ON(1);
+			ddev = NULL;
+		}
+		ret = gasket_page_table_init(
+			&gasket_dev->page_table[tbl_idx],
+			&gasket_dev->bar_data[
+				driver_desc->page_table_bar_index],
+			&driver_desc->page_table_configs[tbl_idx],
+			ddev, gasket_dev->pci_dev, has_dma_ops);
+		if (ret) {
+			gasket_log_error(
+				gasket_dev,
+				"Couldn't init page table %d: %d",
+				tbl_idx, ret);
+			return ret;
+		}
+		/*
+		 * Make sure that the page table is clear and set to simple
+		 * addresses.
+		 */
+		gasket_page_table_reset(gasket_dev->page_table[tbl_idx]);
+	}
+
+	/*
+	 * hardware_revision_cb returns a positive integer (the rev) if
+	 * successful.)
+	 */
+	ret = check_and_invoke_callback(
+		gasket_dev, driver_desc->hardware_revision_cb);
+	if (ret < 0) {
+		gasket_log_error(
+			gasket_dev, "Error getting hardware revision: %d", ret);
+		return ret;
+	}
+	gasket_dev->hardware_revision = ret;
+
+	ret = check_and_invoke_callback(gasket_dev, driver_desc->enable_dev_cb);
+	if (ret) {
+		gasket_log_error(
+			gasket_dev, "Error in enable device cb: %d", ret);
+		return ret;
+	}
+
+	/* device_status_cb returns a device status, not an error code. */
+	gasket_dev->status = gasket_get_hw_status(gasket_dev);
+	if (gasket_dev->status == GASKET_STATUS_DEAD)
+		gasket_log_error(gasket_dev, "Device reported as unhealthy.");
+
+	ret = gasket_add_cdev(
+		&gasket_dev->dev_info, &gasket_file_ops, driver_desc->module);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+/*
+ * Disable device operations.
+ * @gasket_dev: Pointer to Gasket device structure.
+ *
+ * Currently forwards all work to device-specific callback; a future phase will
+ * extract elements of character device unregistration here.
+ */
+static void gasket_disable_dev(struct gasket_dev *gasket_dev)
+{
+	const struct gasket_driver_desc *driver_desc =
+		gasket_dev->internal_desc->driver_desc;
+	int i;
+
+	/* Only delete the device if it has been successfully added. */
+	if (gasket_dev->dev_info.cdev_added)
+		cdev_del(&gasket_dev->dev_info.cdev);
+
+	gasket_dev->status = GASKET_STATUS_DEAD;
+
+	gasket_interrupt_cleanup(gasket_dev);
+
+	for (i = 0; i < driver_desc->num_page_tables; ++i) {
+		if (gasket_dev->page_table[i]) {
+			gasket_page_table_reset(gasket_dev->page_table[i]);
+			gasket_page_table_cleanup(gasket_dev->page_table[i]);
+		}
+	}
+
+	check_and_invoke_callback(gasket_dev, driver_desc->disable_dev_cb);
+}
+
+/**
+ * Registered descriptor lookup.
+ *
+ * Precondition: Called with g_mutex held (to avoid a race on return).
+ * Returns NULL if no matching device was found.
+ */
+static struct gasket_internal_desc *lookup_internal_desc(
+	struct pci_dev *pci_dev)
+{
+	int i;
+
+	__must_hold(&g_mutex);
+	for (i = 0; i < GASKET_FRAMEWORK_DESC_MAX; i++) {
+		if (g_descs[i].driver_desc &&
+		    g_descs[i].driver_desc->pci_id_table &&
+		    pci_match_id(g_descs[i].driver_desc->pci_id_table, pci_dev))
+			return &g_descs[i];
+	}
+
+	return NULL;
+}
+
+/**
+ * Lookup a name by number in a num_name table.
+ * @num: Number to lookup.
+ * @table: Array of num_name structures, the table for the lookup.
+ *
+ * Description: Searches for num in the table.  If found, the
+ *		corresponding name is returned; otherwise NULL
+ *		is returned.
+ *
+ *		The table must have a NULL name pointer at the end.
+ */
+const char *gasket_num_name_lookup(
+	uint num, const struct gasket_num_name *table)
+{
+	uint i = 0;
+
+	while (table[i].snn_name) {
+		if (num == table[i].snn_num)
+			break;
+		++i;
+	}
+
+	return table[i].snn_name;
+}
+EXPORT_SYMBOL(gasket_num_name_lookup);
+
+/**
+ * Opens the char device file.
+ * @inode: Inode structure pointer of the device file.
+ * @file: File structure pointer.
+ *
+ * Description: Called on an open of the device file.  If the open is for
+ *              writing, and the device is not owned, this process becomes
+ *              the owner.  If the open is for writing and the device is
+ *              already owned by some other process, it is an error.  If
+ *              this process is the owner, increment the open count.
+ *
+ *              Returns 0 if successful, a negative error number otherwise.
+ */
+static int gasket_open(struct inode *inode, struct file *filp)
+{
+	int ret;
+	struct gasket_dev *gasket_dev;
+	const struct gasket_driver_desc *driver_desc;
+	struct gasket_ownership *ownership;
+	char task_name[TASK_COMM_LEN];
+	struct gasket_cdev_info *dev_info = gasket_cdev_get_info(inode->i_cdev);
+
+	if (!dev_info) {
+		gasket_nodev_error("Unable to retrieve device data");
+		return -EINVAL;
+	}
+	gasket_dev = dev_info->gasket_dev_ptr;
+	driver_desc = gasket_dev->internal_desc->driver_desc;
+	ownership = &dev_info->ownership;
+	get_task_comm(task_name, current);
+	filp->private_data = gasket_dev;
+	inode->i_size = 0;
+
+	gasket_log_debug(
+		gasket_dev,
+		"Attempting to open with tgid %u (%s) (f_mode: 0%03o, "
+		"fmode_write: %d is_root: %u)",
+		current->tgid, task_name, filp->f_mode,
+		(filp->f_mode & FMODE_WRITE), capable(CAP_SYS_ADMIN));
+
+	/* Always allow non-writing accesses. */
+	if (!(filp->f_mode & FMODE_WRITE)) {
+		gasket_log_debug(gasket_dev, "Allowing read-only opening.");
+		return 0;
+	}
+
+	mutex_lock(&gasket_dev->mutex);
+
+	gasket_log_debug(
+		gasket_dev, "Current owner open count (owning tgid %u): %d.",
+		ownership->owner, ownership->write_open_count);
+
+	/* Opening a node owned by another TGID is an error (even root.) */
+	if (ownership->is_owned && ownership->owner != current->tgid) {
+		gasket_log_error(
+			gasket_dev,
+			"Process %u is opening a node held by %u.",
+			current->tgid, ownership->owner);
+		mutex_unlock(&gasket_dev->mutex);
+		return -EPERM;
+	}
+
+	/* If the node is not owned, assign it to the current TGID. */
+	if (!ownership->is_owned) {
+		ret = gasket_check_and_invoke_callback_nolock(
+			gasket_dev, driver_desc->device_open_cb);
+		if (ret) {
+			gasket_log_error(
+				gasket_dev, "Error in device open cb: %d", ret);
+			mutex_unlock(&gasket_dev->mutex);
+			return ret;
+		}
+		ownership->is_owned = 1;
+		ownership->owner = current->tgid;
+		gasket_log_debug(gasket_dev, "Device owner is now tgid %u",
+				 ownership->owner);
+	}
+
+	ownership->write_open_count++;
+
+	gasket_log_debug(gasket_dev, "New open count (owning tgid %u): %d",
+			 ownership->owner, ownership->write_open_count);
+
+	mutex_unlock(&gasket_dev->mutex);
+	return 0;
+}
+
+/**
+ * gasket_release - Close of the char device file.
+ * @inode: Inode structure pointer of the device file.
+ * @file: File structure pointer.
+ *
+ * Description: Called on a close of the device file.  If this process
+ *              is the owner, decrement the open count.  On last close
+ *              by the owner, free up buffers and eventfd contexts, and
+ *              release ownership.
+ *
+ *              Returns 0 if successful, a negative error number otherwise.
+ */
+static int gasket_release(struct inode *inode, struct file *file)
+{
+	int i;
+	struct gasket_dev *gasket_dev;
+	struct gasket_ownership *ownership;
+	const struct gasket_driver_desc *driver_desc;
+	char task_name[TASK_COMM_LEN];
+	struct gasket_cdev_info *dev_info =
+		(struct gasket_cdev_info *)gasket_cdev_get_info(inode->i_cdev);
+	if (!dev_info) {
+		gasket_nodev_error("Unable to retrieve device data");
+		return -EINVAL;
+	}
+	gasket_dev = dev_info->gasket_dev_ptr;
+	driver_desc = gasket_dev->internal_desc->driver_desc;
+	ownership = &dev_info->ownership;
+	get_task_comm(task_name, current);
+	mutex_lock(&gasket_dev->mutex);
+
+	gasket_log_debug(
+		gasket_dev,
+		"Releasing device node. Call origin: tgid %u (%s) "
+		"(f_mode: 0%03o, fmode_write: %d, is_root: %u)",
+		current->tgid, task_name, file->f_mode,
+		(file->f_mode & FMODE_WRITE), capable(CAP_SYS_ADMIN));
+	gasket_log_debug(gasket_dev, "Current open count (owning tgid %u): %d",
+			 ownership->owner, ownership->write_open_count);
+
+	if (file->f_mode & FMODE_WRITE) {
+		ownership->write_open_count--;
+		if (ownership->write_open_count == 0) {
+			gasket_log_info(gasket_dev, "Device is now free");
+			ownership->is_owned = 0;
+			ownership->owner = 0;
+
+			/* Forces chip reset before we unmap the page tables. */
+			driver_desc->device_reset_cb(gasket_dev, 0);
+
+			for (i = 0; i < driver_desc->num_page_tables; ++i) {
+				gasket_page_table_unmap_all(
+					gasket_dev->page_table[i]);
+				gasket_page_table_garbage_collect(
+					gasket_dev->page_table[i]);
+				gasket_free_coherent_memory_all(gasket_dev, i);
+			}
+
+			/* Closes device, enters power save. */
+			gasket_check_and_invoke_callback_nolock(
+				gasket_dev, driver_desc->device_close_cb);
+		}
+	}
+
+	gasket_log_info(
+		gasket_dev, "New open count (owning tgid %u): %d",
+		ownership->owner, ownership->write_open_count);
+	mutex_unlock(&gasket_dev->mutex);
+	return 0;
+}
+
+/*
+ * Permission and validity checking for mmap ops.
+ * @gasket_dev: Gasket device information structure.
+ * @vma: Standard virtual memory area descriptor.
+ *
+ * Verifies that the user has permissions to perform the requested mapping and
+ * that the provided descriptor/range is of adequate size to hold the range to
+ * be mapped.
+ */
+static int gasket_mmap_has_permissions(
+	struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
+	int bar_permissions)
+{
+	int requested_permissions;
+	/* Always allow sysadmin to access. */
+	if (capable(CAP_SYS_ADMIN))
+		return 1;
+
+	/* Never allow non-sysadmins to access to a dead device. */
+	if (gasket_dev->status != GASKET_STATUS_ALIVE) {
+		gasket_log_info(gasket_dev, "Device is dead.");
+		return 0;
+	}
+
+	/* Make sure that no wrong flags are set. */
+	requested_permissions =
+		(vma->vm_flags & (VM_WRITE | VM_READ | VM_EXEC));
+	if (requested_permissions & ~(bar_permissions)) {
+		gasket_log_info(
+			gasket_dev,
+			"Attempting to map a region with requested permissions "
+			"0x%x, but region has permissions 0x%x.",
+			requested_permissions, bar_permissions);
+		return 0;
+	}
+
+	/* Do not allow a non-owner to write. */
+	if ((vma->vm_flags & VM_WRITE) &&
+	    !gasket_owned_by_current_tgid(&gasket_dev->dev_info)) {
+		gasket_log_info(
+			gasket_dev,
+			"Attempting to mmap a region for write without owning "
+			"device.");
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * Checks if an address is within the region
+ * allocated for coherent buffer.
+ * @driver_desc: driver description.
+ * @address: offset of address to check.
+ *
+ * Verifies that the input address is within the region allocated to coherent
+ * buffer.
+ */
+static bool gasket_is_coherent_region(
+	const struct gasket_driver_desc *driver_desc, ulong address)
+{
+	struct gasket_coherent_buffer_desc coh_buff_desc =
+		driver_desc->coherent_buffer_description;
+
+	if (coh_buff_desc.permissions != GASKET_NOMAP) {
+		if ((address >= coh_buff_desc.base) &&
+		    (address < coh_buff_desc.base + coh_buff_desc.size)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+static int gasket_get_bar_index(
+	const struct gasket_dev *gasket_dev, ulong phys_addr)
+{
+	int i;
+	const struct gasket_driver_desc *driver_desc;
+
+	driver_desc = gasket_dev->internal_desc->driver_desc;
+	for (i = 0; i < GASKET_NUM_BARS; ++i) {
+		struct gasket_bar_desc bar_desc =
+			driver_desc->bar_descriptions[i];
+
+		if (bar_desc.permissions != GASKET_NOMAP) {
+			if (phys_addr >= bar_desc.base &&
+			    phys_addr < (bar_desc.base + bar_desc.size)) {
+				return i;
+			}
+		}
+	}
+	/* If we haven't found the address by now, it is invalid. */
+	return -EINVAL;
+}
+
+/*
+ * Sets the actual bounds to map, given the device's mappable region.
+ *
+ * Given the device's mappable region, along with the user-requested mapping
+ * start offset and length of the user region, determine how much of this
+ * mappable region can be mapped into the user's region (start/end offsets),
+ * and the physical offset (phys_offset) into the BAR where the mapping should
+ * begin (either the VMA's or region lower bound).
+ *
+ * In other words, this calculates the overlap between the VMA
+ * (bar_offset, requested_length) and the given gasket_mappable_region.
+ *
+ * Returns true if there's anything to map, and false otherwise.
+ */
+static bool gasket_mm_get_mapping_addrs(
+	const struct gasket_mappable_region *region, ulong bar_offset,
+	ulong requested_length, struct gasket_mappable_region *mappable_region,
+	ulong *virt_offset)
+{
+	ulong range_start = region->start;
+	ulong range_length = region->length_bytes;
+	ulong range_end = range_start + range_length;
+
+	*virt_offset = 0;
+	if (bar_offset + requested_length < range_start) {
+		/*
+		* If the requested region is completely below the range,
+		* there is nothing to map.
+		*/
+		return false;
+	} else if (bar_offset <= range_start) {
+		/* If the bar offset is below this range's start
+		 * but the requested length continues into it:
+		 * 1) Only map starting from the beginning of this
+		 *      range's phys. offset, so we don't map unmappable
+		 *	memory.
+		 * 2) The length of the virtual memory to not map is the
+		 *	delta between the bar offset and the
+		 *	mappable start (and since the mappable start is
+		 *	bigger, start - req.)
+		 * 3) The map length is the minimum of the mappable
+		 *	requested length (requested_length - virt_offset)
+		 *	and the actual mappable length of the range.
+		 */
+		mappable_region->start = range_start;
+		*virt_offset = range_start - bar_offset;
+		mappable_region->length_bytes =
+			min(requested_length - *virt_offset, range_length);
+		return true;
+	} else if (bar_offset > range_start &&
+		   bar_offset < range_end) {
+		/*
+		 * If the bar offset is within this range:
+		 * 1) Map starting from the bar offset.
+		 * 2) Because there is no forbidden memory between the
+		 *	bar offset and the range start,
+		 *	virt_offset is 0.
+		 * 3) The map length is the minimum of the requested
+		 *	length and the remaining length in the buffer
+		 *	(range_end - bar_offset)
+		 */
+		mappable_region->start = bar_offset;
+		*virt_offset = 0;
+		mappable_region->length_bytes = min(
+			requested_length, range_end - bar_offset);
+		return true;
+	}
+
+	/*
+	 * If the requested [start] offset is above range_end,
+	 * there's nothing to map.
+	 */
+	return false;
+}
+
+int gasket_mm_unmap_region(
+	const struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
+	const struct gasket_mappable_region *map_region)
+{
+	ulong bar_offset;
+	ulong virt_offset;
+	struct gasket_mappable_region mappable_region;
+	int ret;
+
+	if (map_region->length_bytes == 0)
+		return 0;
+
+	ret = gasket_mm_vma_bar_offset(gasket_dev, vma, &bar_offset);
+	if (ret)
+		return ret;
+
+	if (!gasket_mm_get_mapping_addrs(
+		map_region, bar_offset, vma->vm_end - vma->vm_start,
+		&mappable_region, &virt_offset))
+		return 1;
+
+	/*
+	 * The length passed to zap_vma_ptes MUST BE A MULTIPLE OF
+	 * PAGE_SIZE! Trust me. I have the scars.
+	 *
+	 * Next multiple of y: ceil_div(x, y) * y
+	 */
+	zap_vma_ptes(
+		vma, vma->vm_start + virt_offset,
+		DIV_ROUND_UP(mappable_region.length_bytes, PAGE_SIZE) *
+			PAGE_SIZE);
+	return 0;
+}
+EXPORT_SYMBOL(gasket_mm_unmap_region);
+
+/* Maps a virtual address + range to a physical offset of a BAR. */
+static enum do_map_region_status do_map_region(
+	const struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
+	struct gasket_mappable_region *mappable_region)
+{
+	/* Maximum size of a single call to io_remap_pfn_range. */
+	/* I pulled this number out of thin air. */
+	const ulong max_chunk_size = 64 * 1024 * 1024;
+	ulong chunk_size, mapped_bytes = 0;
+
+	const struct gasket_driver_desc *driver_desc =
+		gasket_dev->internal_desc->driver_desc;
+
+	ulong bar_offset, virt_offset;
+	struct gasket_mappable_region region_to_map;
+	ulong phys_offset, map_length;
+	ulong virt_base, phys_base;
+	int bar_index, ret;
+
+	ret = gasket_mm_vma_bar_offset(gasket_dev, vma, &bar_offset);
+	if (ret)
+		return DO_MAP_REGION_INVALID;
+
+	if (!gasket_mm_get_mapping_addrs(mappable_region, bar_offset,
+					 vma->vm_end - vma->vm_start,
+					 &region_to_map, &virt_offset))
+		return DO_MAP_REGION_INVALID;
+	phys_offset = region_to_map.start;
+	map_length = region_to_map.length_bytes;
+
+	virt_base = vma->vm_start + virt_offset;
+	bar_index =
+		gasket_get_bar_index(
+			gasket_dev,
+			(vma->vm_pgoff << PAGE_SHIFT) +
+				driver_desc->legacy_mmap_address_offset);
+	phys_base = gasket_dev->bar_data[bar_index].phys_base + phys_offset;
+	while (mapped_bytes < map_length) {
+		/*
+		 * io_remap_pfn_range can take a while, so we chunk its
+		 * calls and call cond_resched between each.
+		 */
+		chunk_size = min(max_chunk_size, map_length - mapped_bytes);
+
+		cond_resched();
+		ret = io_remap_pfn_range(
+			vma, virt_base + mapped_bytes,
+			(phys_base + mapped_bytes) >> PAGE_SHIFT,
+			chunk_size, vma->vm_page_prot);
+		if (ret) {
+			gasket_log_error(
+				gasket_dev, "Error remapping PFN range.");
+			goto fail;
+		}
+		mapped_bytes += chunk_size;
+	}
+
+	return DO_MAP_REGION_SUCCESS;
+
+fail:
+	/* Unmap the partial chunk we mapped. */
+	mappable_region->length_bytes = mapped_bytes;
+	if (gasket_mm_unmap_region(gasket_dev, vma, mappable_region))
+		gasket_log_error(
+			gasket_dev,
+			"Error unmapping partial region 0x%lx (0x%lx bytes)",
+			(ulong)virt_offset,
+			(ulong)mapped_bytes);
+
+	return DO_MAP_REGION_FAILURE;
+}
+
+/*
+ * Calculates the offset where the VMA range begins in its containing BAR.
+ * The offset is written into bar_offset on success.
+ * Returns zero on success, anything else on error.
+*/
+static int gasket_mm_vma_bar_offset(
+	const struct gasket_dev *gasket_dev, const struct vm_area_struct *vma,
+	ulong *bar_offset)
+{
+	ulong raw_offset;
+	int bar_index;
+	const struct gasket_driver_desc *driver_desc =
+		gasket_dev->internal_desc->driver_desc;
+
+	raw_offset = (vma->vm_pgoff << PAGE_SHIFT) +
+		driver_desc->legacy_mmap_address_offset;
+	bar_index = gasket_get_bar_index(gasket_dev, raw_offset);
+	if (bar_index < 0) {
+		gasket_log_error(
+			gasket_dev,
+			"Unable to find matching bar for address 0x%lx",
+			raw_offset);
+		trace_gasket_mmap_exit(bar_index);
+		return bar_index;
+	}
+	*bar_offset =
+		raw_offset - driver_desc->bar_descriptions[bar_index].base;
+
+	return 0;
+}
+
+/*
+ * Map a region of coherent memory.
+ * @gasket_dev: Gasket device handle.
+ * @vma: Virtual memory area descriptor with region to map.
+ */
+static int gasket_mmap_coherent(
+	struct gasket_dev *gasket_dev, struct vm_area_struct *vma)
+{
+	const struct gasket_driver_desc *driver_desc =
+		gasket_dev->internal_desc->driver_desc;
+	const ulong requested_length = vma->vm_end - vma->vm_start;
+	int ret;
+	ulong permissions;
+
+	if (requested_length == 0 || requested_length >
+	    gasket_dev->coherent_buffer.length_bytes) {
+		trace_gasket_mmap_exit(-EINVAL);
+		return -EINVAL;
+	}
+
+	permissions = driver_desc->coherent_buffer_description.permissions;
+	if (!gasket_mmap_has_permissions(gasket_dev, vma, permissions)) {
+		gasket_log_error(gasket_dev, "Permission checking failed.");
+		trace_gasket_mmap_exit(-EPERM);
+		return -EPERM;
+	}
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	ret = remap_pfn_range(
+		vma, vma->vm_start,
+		(gasket_dev->coherent_buffer.phys_base) >> PAGE_SHIFT,
+		requested_length, vma->vm_page_prot);
+	if (ret) {
+		gasket_log_error(
+			gasket_dev, "Error remapping PFN range err=%d.", ret);
+		trace_gasket_mmap_exit(ret);
+		return ret;
+	}
+
+	/* Record the user virtual to dma_address mapping that was
+	 * created by the kernel.
+	 */
+	gasket_set_user_virt(
+		gasket_dev, requested_length,
+		gasket_dev->coherent_buffer.phys_base, vma->vm_start);
+	return 0;
+}
+
+/*
+ * Maps a device's BARs into user space.
+ * @filp: File structure pointer describing this node usage session.
+ * @vma: Standard virtual memory area descriptor.
+ *
+ * Maps the entirety of each of the device's BAR ranges into the user memory
+ * range specified by vma.
+ *
+ * Returns 0 on success, a negative errno on error.
+ */
+static int gasket_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	int i, ret;
+	int bar_index;
+	int has_mapped_anything = 0;
+	ulong permissions;
+	ulong raw_offset, vma_size;
+	bool is_coherent_region;
+	const struct gasket_driver_desc *driver_desc;
+	struct gasket_dev *gasket_dev = (struct gasket_dev *)filp->private_data;
+	struct gasket_bar_data *bar_data;
+	const struct gasket_bar_desc *bar_desc;
+	struct gasket_mappable_region *map_regions = NULL;
+	int num_map_regions = 0;
+	enum do_map_region_status map_status;
+
+	if (!gasket_dev) {
+		gasket_nodev_error("Unable to retrieve device data");
+		trace_gasket_mmap_exit(-EINVAL);
+		return -EINVAL;
+	}
+	driver_desc = gasket_dev->internal_desc->driver_desc;
+
+	if (vma->vm_start & (PAGE_SIZE - 1)) {
+		gasket_log_error(
+			gasket_dev, "Base address not page-aligned: 0x%p\n",
+			(void *)vma->vm_start);
+		trace_gasket_mmap_exit(-EINVAL);
+		return -EINVAL;
+	}
+
+	/* Calculate the offset of this range into physical mem. */
+	raw_offset = (vma->vm_pgoff << PAGE_SHIFT) +
+		driver_desc->legacy_mmap_address_offset;
+	vma_size = vma->vm_end - vma->vm_start;
+	trace_gasket_mmap_entry(
+		gasket_dev->dev_info.name, raw_offset, vma_size);
+
+	/*
+	 * Check if the raw offset is within a bar region. If not, check if it
+	 * is a coherent region.
+	 */
+	bar_index = gasket_get_bar_index(gasket_dev, raw_offset);
+	is_coherent_region = gasket_is_coherent_region(driver_desc, raw_offset);
+	if (bar_index < 0 && !is_coherent_region) {
+		gasket_log_error(
+			gasket_dev,
+			"Unable to find matching bar for address 0x%lx",
+			raw_offset);
+		trace_gasket_mmap_exit(bar_index);
+		return bar_index;
+	}
+	if (bar_index > 0 && is_coherent_region) {
+		gasket_log_error(
+			gasket_dev,
+			"double matching bar and coherent buffers for address "
+			"0x%lx",
+			raw_offset);
+		trace_gasket_mmap_exit(bar_index);
+		return bar_index;
+	}
+
+	vma->vm_private_data = gasket_dev;
+
+	if (is_coherent_region)
+		return gasket_mmap_coherent(gasket_dev, vma);
+
+	/* Everything in the rest of this function is for normal BAR mapping. */
+
+	/*
+	 * Subtract the base of the bar from the raw offset to get the
+	 * memory location within the bar to map.
+	 */
+	bar_data = &gasket_dev->bar_data[bar_index];
+
+	bar_desc = &driver_desc->bar_descriptions[bar_index];
+	permissions = bar_desc->permissions;
+	if (!gasket_mmap_has_permissions(gasket_dev, vma, permissions)) {
+		gasket_log_error(gasket_dev, "Permission checking failed.");
+		trace_gasket_mmap_exit(-EPERM);
+		return -EPERM;
+	}
+
+	if (driver_desc->get_mappable_regions_cb) {
+		ret = driver_desc->get_mappable_regions_cb(
+			gasket_dev, bar_index, &map_regions, &num_map_regions);
+		if (ret)
+			return ret;
+	} else {
+		if (!gasket_mmap_has_permissions(gasket_dev, vma,
+						 bar_desc->permissions)) {
+			gasket_log_error(
+				gasket_dev, "Permission checking failed.");
+			trace_gasket_mmap_exit(-EPERM);
+			return -EPERM;
+		}
+		num_map_regions = bar_desc->num_mappable_regions;
+		map_regions = kzalloc(
+			num_map_regions * sizeof(*bar_desc->mappable_regions),
+			GFP_KERNEL);
+		if (map_regions) {
+			memcpy(map_regions, bar_desc->mappable_regions,
+			       num_map_regions *
+					sizeof(*bar_desc->mappable_regions));
+		}
+	}
+
+	if (!map_regions || num_map_regions == 0) {
+		gasket_log_error(gasket_dev, "No mappable regions returned!");
+		return -EINVAL;
+	}
+
+	/* Marks the VMA's pages as uncacheable. */
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	for (i = 0; i < num_map_regions; i++) {
+		map_status = do_map_region(gasket_dev, vma, &map_regions[i]);
+		/* Try the next region if this one was not mappable. */
+		if (map_status == DO_MAP_REGION_INVALID)
+			continue;
+		if (map_status == DO_MAP_REGION_FAILURE)
+			goto fail;
+
+		has_mapped_anything = 1;
+	}
+
+	kfree(map_regions);
+
+	/* If we could not map any memory, the request was invalid. */
+	if (!has_mapped_anything) {
+		gasket_log_error(
+			gasket_dev,
+			"Map request did not contain a valid region.");
+		trace_gasket_mmap_exit(-EINVAL);
+		return -EINVAL;
+	}
+
+	trace_gasket_mmap_exit(0);
+	return 0;
+
+fail:
+	/* Need to unmap any mapped ranges. */
+	num_map_regions = i;
+	for (i = 0; i < num_map_regions; i++)
+		if (gasket_mm_unmap_region(gasket_dev, vma,
+					   &bar_desc->mappable_regions[i]))
+			gasket_log_error(
+				gasket_dev, "Error unmapping range %d.", i);
+	kfree(map_regions);
+
+	return ret;
+}
+
+/*
+ * Determine the health of the Gasket device.
+ * @gasket_dev: Gasket device structure.
+ *
+ * Checks the underlying device health (via the device_status_cb)
+ * and the status of initialized Gasket code systems (currently
+ * only interrupts), then returns a gasket_status appropriately.
+ */
+static int gasket_get_hw_status(struct gasket_dev *gasket_dev)
+{
+	int status;
+	int i;
+	const struct gasket_driver_desc *driver_desc =
+		gasket_dev->internal_desc->driver_desc;
+
+	status = gasket_check_and_invoke_callback_nolock(
+		gasket_dev, driver_desc->device_status_cb);
+	if (status != GASKET_STATUS_ALIVE) {
+		gasket_log_info(gasket_dev, "Hardware reported status %d.",
+				status);
+		return status;
+	}
+
+	status = gasket_interrupt_system_status(gasket_dev);
+	if (status != GASKET_STATUS_ALIVE) {
+		gasket_log_info(gasket_dev,
+				"Interrupt system reported status %d.", status);
+		return status;
+	}
+
+	for (i = 0; i < driver_desc->num_page_tables; ++i) {
+		status = gasket_page_table_system_status(
+			gasket_dev->page_table[i]);
+		if (status != GASKET_STATUS_ALIVE) {
+			gasket_log_info(
+				gasket_dev, "Page table %d reported status %d.",
+				i, status);
+			return status;
+		}
+	}
+
+	return GASKET_STATUS_ALIVE;
+}
+
+/*
+ * Gasket ioctl dispatch function.
+ * @filp: File structure pointer describing this node usage session.
+ * @cmd: ioctl number to handle.
+ * @arg: ioctl-specific data pointer.
+ *
+ * First, checks if the ioctl is a generic ioctl. If not, it passes
+ * the ioctl to the ioctl_handler_cb registered in the driver description.
+ * If the ioctl is a generic ioctl, the function passes it to the
+ * gasket_ioctl_handler in gasket_ioctl.c.
+ */
+static long gasket_ioctl(struct file *filp, uint cmd, ulong arg)
+{
+	struct gasket_dev *gasket_dev;
+	const struct gasket_driver_desc *driver_desc;
+	char path[256];
+
+	if (!filp)
+		return -ENODEV;
+
+	gasket_dev = (struct gasket_dev *)filp->private_data;
+	if (!gasket_dev) {
+		gasket_nodev_error(
+			"Unable to find Gasket structure for file %s",
+			d_path(&filp->f_path, path, 256));
+		return -ENODEV;
+	}
+
+	driver_desc = gasket_dev->internal_desc->driver_desc;
+	if (!driver_desc) {
+		gasket_log_error(
+			gasket_dev,
+			"Unable to find device descriptor for file %s",
+			d_path(&filp->f_path, path, 256));
+		return -ENODEV;
+	}
+
+	if (!gasket_is_supported_ioctl(cmd)) {
+		/*
+		 * The ioctl handler is not a standard Gasket callback, since
+		 * it requires different arguments. This means we can't use
+		 * check_and_invoke_callback.
+		 */
+		if (driver_desc->ioctl_handler_cb)
+			return driver_desc->ioctl_handler_cb(filp, cmd, arg);
+
+		gasket_log_error(
+			gasket_dev, "Received unknown ioctl 0x%x", cmd);
+		return -EINVAL;
+	}
+
+	return gasket_handle_ioctl(filp, cmd, arg);
+}
+
+int gasket_reset(struct gasket_dev *gasket_dev, uint reset_type)
+{
+	int ret;
+
+	mutex_lock(&gasket_dev->mutex);
+	ret = gasket_reset_nolock(gasket_dev, reset_type);
+	mutex_unlock(&gasket_dev->mutex);
+	return ret;
+}
+EXPORT_SYMBOL(gasket_reset);
+
+int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type)
+{
+	int ret;
+	int i;
+	const struct gasket_driver_desc *driver_desc;
+
+	driver_desc = gasket_dev->internal_desc->driver_desc;
+	if (!driver_desc->device_reset_cb) {
+		gasket_log_error(
+			gasket_dev, "No device reset callback was registered.");
+		return -EINVAL;
+	}
+
+	/* Perform a device reset of the requested type. */
+	ret = driver_desc->device_reset_cb(gasket_dev, reset_type);
+	if (ret)
+		gasket_log_error(
+			gasket_dev, "Device reset cb returned %d.", ret);
+
+	/* Reinitialize the page tables and interrupt framework. */
+	for (i = 0; i < driver_desc->num_page_tables; ++i)
+		gasket_page_table_reset(gasket_dev->page_table[i]);
+
+	ret = gasket_interrupt_reinit(gasket_dev);
+	if (ret) {
+		gasket_log_error(
+			gasket_dev, "Unable to reinit interrupts: %d.", ret);
+		return ret;
+	}
+
+	/* Get current device health. */
+	gasket_dev->status = gasket_get_hw_status(gasket_dev);
+	if (gasket_dev->status == GASKET_STATUS_DEAD) {
+		gasket_log_error(gasket_dev, "Device reported as dead.");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(gasket_reset_nolock);
+
+gasket_ioctl_permissions_cb_t gasket_get_ioctl_permissions_cb(
+	struct gasket_dev *gasket_dev) {
+	return gasket_dev->internal_desc->driver_desc->ioctl_permissions_cb;
+}
+EXPORT_SYMBOL(gasket_get_ioctl_permissions_cb);
+
+static ssize_t gasket_write_mappable_regions(
+	char *buf, const struct gasket_driver_desc *driver_desc, int bar_index)
+{
+	int i;
+	ssize_t written;
+	ssize_t total_written = 0;
+	ulong min_addr, max_addr;
+	struct gasket_bar_desc bar_desc =
+		driver_desc->bar_descriptions[bar_index];
+
+	if (bar_desc.permissions == GASKET_NOMAP)
+		return 0;
+	for (i = 0;
+	     (i < bar_desc.num_mappable_regions) && (total_written < PAGE_SIZE);
+	     i++) {
+		min_addr = bar_desc.mappable_regions[i].start -
+			   driver_desc->legacy_mmap_address_offset;
+		max_addr = bar_desc.mappable_regions[i].start -
+			   driver_desc->legacy_mmap_address_offset +
+			   bar_desc.mappable_regions[i].length_bytes;
+		written = scnprintf(buf, PAGE_SIZE - total_written,
+				    "0x%08lx-0x%08lx\n", min_addr, max_addr);
+		total_written += written;
+		buf += written;
+	}
+	return total_written;
+}
+
+static ssize_t gasket_sysfs_data_show(
+	struct device *device, struct device_attribute *attr, char *buf)
+{
+	int i, ret = 0;
+	ssize_t current_written = 0;
+	const struct gasket_driver_desc *driver_desc;
+	struct gasket_dev *gasket_dev;
+	struct gasket_sysfs_attribute *gasket_attr;
+	const struct gasket_bar_desc *bar_desc;
+	enum gasket_sysfs_attribute_type sysfs_type;
+
+	gasket_dev = gasket_sysfs_get_device_data(device);
+	if (!gasket_dev) {
+		gasket_nodev_error(
+			"No sysfs mapping found for device 0x%p", device);
+		return 0;
+	}
+
+	gasket_attr = gasket_sysfs_get_attr(device, attr);
+	if (!gasket_attr) {
+		gasket_nodev_error(
+			"No sysfs attr found for device 0x%p", device);
+		gasket_sysfs_put_device_data(device, gasket_dev);
+		return 0;
+	}
+
+	driver_desc = gasket_dev->internal_desc->driver_desc;
+
+	sysfs_type =
+		(enum gasket_sysfs_attribute_type)gasket_attr->data.attr_type;
+	switch (sysfs_type) {
+	case ATTR_BAR_OFFSETS:
+		for (i = 0; i < GASKET_NUM_BARS; i++) {
+			bar_desc = &driver_desc->bar_descriptions[i];
+			if (bar_desc->size == 0)
+				continue;
+			current_written =
+				snprintf(buf, PAGE_SIZE - ret, "%d: 0x%lx\n", i,
+					 (ulong)bar_desc->base);
+			buf += current_written;
+			ret += current_written;
+		}
+		break;
+	case ATTR_BAR_SIZES:
+		for (i = 0; i < GASKET_NUM_BARS; i++) {
+			bar_desc = &driver_desc->bar_descriptions[i];
+			if (bar_desc->size == 0)
+				continue;
+			current_written =
+				snprintf(buf, PAGE_SIZE - ret, "%d: 0x%lx\n", i,
+					 (ulong)bar_desc->size);
+			buf += current_written;
+			ret += current_written;
+		}
+		break;
+	case ATTR_DRIVER_VERSION:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%s\n",
+			gasket_dev->internal_desc->driver_desc->driver_version);
+		break;
+	case ATTR_FRAMEWORK_VERSION:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%s\n", GASKET_FRAMEWORK_VERSION);
+		break;
+	case ATTR_DEVICE_TYPE:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%s\n",
+			gasket_dev->internal_desc->driver_desc->name);
+		break;
+	case ATTR_HARDWARE_REVISION:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%d\n", gasket_dev->hardware_revision);
+		break;
+	case ATTR_PCI_ADDRESS:
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", gasket_dev->kobj_name);
+		break;
+	case ATTR_STATUS:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%s\n",
+			gasket_num_name_lookup(
+				gasket_dev->status, gasket_status_name_table));
+		break;
+	case ATTR_IS_DEVICE_OWNED:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%d\n",
+			gasket_dev->dev_info.ownership.is_owned);
+		break;
+	case ATTR_DEVICE_OWNER:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%d\n",
+			gasket_dev->dev_info.ownership.owner);
+		break;
+	case ATTR_WRITE_OPEN_COUNT:
+		ret = snprintf(
+			buf, PAGE_SIZE, "%d\n",
+			gasket_dev->dev_info.ownership.write_open_count);
+		break;
+	case ATTR_RESET_COUNT:
+		ret = snprintf(buf, PAGE_SIZE, "%d\n", gasket_dev->reset_count);
+		break;
+	case ATTR_USER_MEM_RANGES:
+		for (i = 0; i < GASKET_NUM_BARS; ++i) {
+			current_written = gasket_write_mappable_regions(
+				buf, driver_desc, i);
+			buf += current_written;
+			ret += current_written;
+		}
+		break;
+	default:
+		gasket_log_error(
+			gasket_dev, "Unknown attribute: %s", attr->attr.name);
+		ret = 0;
+		break;
+	}
+
+	gasket_sysfs_put_attr(device, gasket_attr);
+	gasket_sysfs_put_device_data(device, gasket_dev);
+	return ret;
+}
+
+/* Get the driver structure for a given gasket_dev.
+ * @dev: pointer to gasket_dev, implementing the requested driver.
+ */
+const struct gasket_driver_desc *gasket_get_driver_desc(struct gasket_dev *dev)
+{
+	return dev->internal_desc->driver_desc;
+}
+
+/* Get the device structure for a given gasket_dev.
+ * @dev: pointer to gasket_dev, implementing the requested driver.
+ */
+struct device *gasket_get_device(struct gasket_dev *dev)
+{
+	if (dev->pci_dev)
+		return &dev->pci_dev->dev;
+	return NULL;
+}
+
+/**
+ * Synchronously waits on device.
+ * @gasket_dev: Device struct.
+ * @bar: Bar
+ * @offset: Register offset
+ * @mask: Register mask
+ * @val: Expected value
+ * @timeout_ns: Timeout in nanoseconds
+ *
+ * Description: Busy waits for a specific combination of bits to be set
+ * on a Gasket register.
+ **/
+int gasket_wait_sync(
+	struct gasket_dev *gasket_dev, int bar, u64 offset, u64 mask, u64 val,
+	u64 timeout_ns)
+{
+	u64 reg;
+	struct timespec start_time, cur_time;
+	u64 diff_nanosec;
+	int count = 0;
+
+	reg = gasket_dev_read_64(gasket_dev, bar, offset);
+	start_time = current_kernel_time();
+	while ((reg & mask) != val) {
+		count++;
+		cur_time = current_kernel_time();
+		diff_nanosec = (u64)(cur_time.tv_sec - start_time.tv_sec) *
+				       1000000000LL +
+			       (u64)(cur_time.tv_nsec) -
+			       (u64)(start_time.tv_nsec);
+		if (diff_nanosec > timeout_ns) {
+			gasket_log_error(
+				gasket_dev,
+				"gasket_wait_sync timeout: reg %llx count %x "
+				"dma %lld ns\n",
+				offset, count, diff_nanosec);
+			return -1;
+		}
+		reg = gasket_dev_read_64(gasket_dev, bar, offset);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(gasket_wait_sync);
+
+/**
+ * Asynchronously waits on device.
+ * @gasket_dev: Device struct.
+ * @bar: Bar
+ * @offset: Register offset
+ * @mask: Register mask
+ * @val: Expected value
+ * @max_retries: number of sleep periods
+ * @delay_ms: Timeout in milliseconds
+ *
+ * Description: Busy waits for a specific combination of bits to be set on a
+ * Gasket register.
+ **/
+int gasket_wait_with_reschedule(
+	struct gasket_dev *gasket_dev, int bar, u64 offset, u64 mask, u64 val,
+	u64 max_retries, u64 delay_ms)
+{
+	u64 retries = 0;
+	u64 tmp;
+
+	while (retries < max_retries) {
+		tmp = gasket_dev_read_64(gasket_dev, bar, offset);
+		if ((tmp & mask) == val)
+			break;
+		schedule_timeout(msecs_to_jiffies(delay_ms));
+		retries++;
+	}
+	if (retries == max_retries) {
+		gasket_log_error(
+			gasket_dev,
+			"gasket_wait_with_reschedule timeout: reg %llx timeout (%llu ms)",
+			offset, max_retries * delay_ms);
+		return -EINVAL;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(gasket_wait_with_reschedule);
