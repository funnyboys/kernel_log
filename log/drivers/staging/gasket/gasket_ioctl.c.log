commit 351567d29c56ef6343f73a88e8982438481537e8
Author: Cristiane Naves <cristianenavescardoso09@gmail.com>
Date:   Sat Oct 26 16:11:01 2019 -0300

    staging: gasket: Fix lines ending with a '('
    
    Fix lines ending with a '('. Issue found by checkpatch.
    
    Signed-off-by: Cristiane Naves <cristianenavescardoso09@gmail.com>
    Link: https://lore.kernel.org/r/20191026191101.GA8973@cristiane-Inspiron-5420
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 4d086d92cddb..e3047d36d8db 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -34,8 +34,8 @@ static int gasket_set_event_fd(struct gasket_dev *gasket_dev,
 
 	trace_gasket_ioctl_eventfd_data(die.interrupt, die.event_fd);
 
-	return gasket_interrupt_set_eventfd(
-		gasket_dev->interrupt_data, die.interrupt, die.event_fd);
+	return gasket_interrupt_set_eventfd(gasket_dev->interrupt_data,
+					    die.interrupt, die.event_fd);
 }
 
 /* Read the size of the page table. */

commit 76fe47940e607a4a1071dbb37073463974b89802
Author: CristianeNaves <cristianenavescardoso09@gmail.com>
Date:   Thu Oct 24 11:46:23 2019 -0200

    staging: gasket: Fix lines ending with a '('
    
    Fix lines ending with a '('. Issue found by checkpatch.
    
    Signed-off-by: CristianeNaves <cristianenavescardoso09@gmail.com>
    Link: https://lore.kernel.org/r/20191024134623.GA4506@cristiane-Inspiron-5420
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 240f9bb10b71..4d086d92cddb 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -54,9 +54,9 @@ static int gasket_read_page_table_size(struct gasket_dev *gasket_dev,
 	ibuf.size = gasket_page_table_num_entries(
 		gasket_dev->page_table[ibuf.page_table_index]);
 
-	trace_gasket_ioctl_page_table_data(
-		ibuf.page_table_index, ibuf.size, ibuf.host_address,
-		ibuf.device_address);
+	trace_gasket_ioctl_page_table_data(ibuf.page_table_index, ibuf.size,
+					   ibuf.host_address,
+					   ibuf.device_address);
 
 	if (copy_to_user(argp, &ibuf, sizeof(ibuf)))
 		return -EFAULT;
@@ -101,9 +101,9 @@ static int gasket_partition_page_table(struct gasket_dev *gasket_dev,
 	if (copy_from_user(&ibuf, argp, sizeof(struct gasket_page_table_ioctl)))
 		return -EFAULT;
 
-	trace_gasket_ioctl_page_table_data(
-		ibuf.page_table_index, ibuf.size, ibuf.host_address,
-		ibuf.device_address);
+	trace_gasket_ioctl_page_table_data(ibuf.page_table_index, ibuf.size,
+					   ibuf.host_address,
+					   ibuf.device_address);
 
 	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
 		return -EFAULT;

commit 87b42aa3cb5512036ca98028c6f6b914a96743ba
Author: Sumera Priyadarsini <sylphrenadin@gmail.com>
Date:   Sat Aug 17 03:07:02 2019 +0530

    staging: gasket: Remove unnecessary line-breaks in function signatures
    
    This patch fixes the function signatures for gasket_read_page_table_size,
    gasket_read_simple_page_table_size, gasket_partition_page_table,
    gasket_config_coherent_allocator to avoid  the checkpatch.pl warning:
    
            CHECK: Lines should not end with a '('
    
    Signed-off-by: Sumera Priyadarsini <sylphrenadin@gmail.com>
    Link: https://lore.kernel.org/r/20190816213702.32116-1-sylphrenadin@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 7ecfba4f2b06..240f9bb10b71 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -39,8 +39,7 @@ static int gasket_set_event_fd(struct gasket_dev *gasket_dev,
 }
 
 /* Read the size of the page table. */
-static int gasket_read_page_table_size(
-	struct gasket_dev *gasket_dev,
+static int gasket_read_page_table_size(struct gasket_dev *gasket_dev,
 	struct gasket_page_table_ioctl __user *argp)
 {
 	int ret = 0;
@@ -66,8 +65,7 @@ static int gasket_read_page_table_size(
 }
 
 /* Read the size of the simple page table. */
-static int gasket_read_simple_page_table_size(
-	struct gasket_dev *gasket_dev,
+static int gasket_read_simple_page_table_size(struct gasket_dev *gasket_dev,
 	struct gasket_page_table_ioctl __user *argp)
 {
 	int ret = 0;
@@ -93,8 +91,7 @@ static int gasket_read_simple_page_table_size(
 }
 
 /* Set the boundary between the simple and extended page tables. */
-static int gasket_partition_page_table(
-	struct gasket_dev *gasket_dev,
+static int gasket_partition_page_table(struct gasket_dev *gasket_dev,
 	struct gasket_page_table_ioctl __user *argp)
 {
 	int ret;
@@ -185,8 +182,7 @@ static int gasket_unmap_buffers(struct gasket_dev *gasket_dev,
  * Reserve structures for coherent allocation, and allocate or free the
  * corresponding memory.
  */
-static int gasket_config_coherent_allocator(
-	struct gasket_dev *gasket_dev,
+static int gasket_config_coherent_allocator(struct gasket_dev *gasket_dev,
 	struct gasket_coherent_alloc_config_ioctl __user *argp)
 {
 	int ret;

commit 1b96f846db31e18e062ae4eb9e22ae58d6588c2f
Author: Tianzheng Li <ltz0302@gmail.com>
Date:   Fri May 24 13:31:05 2019 +0200

    staging/gasket: Fix string split
    
    This patch removes unnecessary quoted string splits.
    
    Co-developed-by: Jie Zhang <zhangjie.cnde@gmail.com>
    Signed-off-by: Jie Zhang <zhangjie.cnde@gmail.com>
    Signed-off-by: Tianzheng Li <ltz0302@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 0ca48e688818..7ecfba4f2b06 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -353,8 +353,7 @@ long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
 		 */
 		trace_gasket_ioctl_integer_data(arg);
 		dev_dbg(gasket_dev->dev,
-			"Unknown ioctl cmd=0x%x not caught by "
-			"gasket_is_supported_ioctl\n",
+			"Unknown ioctl cmd=0x%x not caught by gasket_is_supported_ioctl\n",
 			cmd);
 		retval = -EINVAL;
 		break;

commit 1c65a2e2f68eae5d73b41dee003b8135dfcf6928
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 2 01:42:43 2018 -0700

    staging: gasket: remove "reset type" param from framework
    
    The "type of reset" parameter to the gasket device reset APIs isn't
    required by the only gasket device submitted upstream, apex.
    
    The framework documents the param as private to the device driver and a
    pass-through at the gasket layer, but the gasket core calls the device
    driver with a hardcoded reset type of zero, which is not documented as
    having a predefined meaning.
    
    In light of all this, remove the reset type parameter from the
    framework.  Remove the reset ioctl reset type parameter, and bump the
    framework version number to reflect the interface change.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index d3397cc74e69..0ca48e688818 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -304,8 +304,7 @@ long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
 	 */
 	switch (cmd) {
 	case GASKET_IOCTL_RESET:
-		trace_gasket_ioctl_integer_data(arg);
-		retval = gasket_reset(gasket_dev, arg);
+		retval = gasket_reset(gasket_dev);
 		break;
 	case GASKET_IOCTL_SET_EVENTFD:
 		retval = gasket_set_event_fd(gasket_dev, argp);

commit 3e845083131224934b6833642aa1c9a0754b4e61
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 31 13:24:40 2018 -0700

    staging: gasket: ioctl: fix function param line continuation style
    
    Fix multi-line alignment formatting to look like:
          int ret = long_function_name(device, VARIABLE1, VARIABLE2,
                                       VARIABLE3, VARIABLE4);
    
    Many of these TODO items were previously cleaned up during the conversion
    to standard logging functions.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 134d45a281ac..d3397cc74e69 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -79,12 +79,12 @@ static int gasket_read_simple_page_table_size(
 	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
 		return -EFAULT;
 
-	ibuf.size = gasket_page_table_num_simple_entries(
-		gasket_dev->page_table[ibuf.page_table_index]);
+	ibuf.size =
+		gasket_page_table_num_simple_entries(gasket_dev->page_table[ibuf.page_table_index]);
 
-	trace_gasket_ioctl_page_table_data(
-		ibuf.page_table_index, ibuf.size, ibuf.host_address,
-		ibuf.device_address);
+	trace_gasket_ioctl_page_table_data(ibuf.page_table_index, ibuf.size,
+					   ibuf.host_address,
+					   ibuf.device_address);
 
 	if (copy_to_user(argp, &ibuf, sizeof(ibuf)))
 		return -EFAULT;
@@ -138,21 +138,21 @@ static int gasket_map_buffers(struct gasket_dev *gasket_dev,
 	if (copy_from_user(&ibuf, argp, sizeof(struct gasket_page_table_ioctl)))
 		return -EFAULT;
 
-	trace_gasket_ioctl_page_table_data(
-		ibuf.page_table_index, ibuf.size, ibuf.host_address,
-		ibuf.device_address);
+	trace_gasket_ioctl_page_table_data(ibuf.page_table_index, ibuf.size,
+					   ibuf.host_address,
+					   ibuf.device_address);
 
 	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
 		return -EFAULT;
 
-	if (gasket_page_table_are_addrs_bad(
-		    gasket_dev->page_table[ibuf.page_table_index],
-		    ibuf.host_address, ibuf.device_address, ibuf.size))
+	if (gasket_page_table_are_addrs_bad(gasket_dev->page_table[ibuf.page_table_index],
+					    ibuf.host_address,
+					    ibuf.device_address, ibuf.size))
 		return -EINVAL;
 
-	return gasket_page_table_map(
-		gasket_dev->page_table[ibuf.page_table_index],
-		ibuf.host_address, ibuf.device_address, ibuf.size / PAGE_SIZE);
+	return gasket_page_table_map(gasket_dev->page_table[ibuf.page_table_index],
+				     ibuf.host_address, ibuf.device_address,
+				     ibuf.size / PAGE_SIZE);
 }
 
 /* Unmap a userspace buffer from a device virtual address. */
@@ -164,16 +164,15 @@ static int gasket_unmap_buffers(struct gasket_dev *gasket_dev,
 	if (copy_from_user(&ibuf, argp, sizeof(struct gasket_page_table_ioctl)))
 		return -EFAULT;
 
-	trace_gasket_ioctl_page_table_data(
-		ibuf.page_table_index, ibuf.size, ibuf.host_address,
-		ibuf.device_address);
+	trace_gasket_ioctl_page_table_data(ibuf.page_table_index, ibuf.size,
+					   ibuf.host_address,
+					   ibuf.device_address);
 
 	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
 		return -EFAULT;
 
-	if (gasket_page_table_is_dev_addr_bad(
-		    gasket_dev->page_table[ibuf.page_table_index],
-		    ibuf.device_address, ibuf.size))
+	if (gasket_page_table_is_dev_addr_bad(gasket_dev->page_table[ibuf.page_table_index],
+					      ibuf.device_address, ibuf.size))
 		return -EINVAL;
 
 	gasket_page_table_unmap(gasket_dev->page_table[ibuf.page_table_index],
@@ -197,8 +196,8 @@ static int gasket_config_coherent_allocator(
 			   sizeof(struct gasket_coherent_alloc_config_ioctl)))
 		return -EFAULT;
 
-	trace_gasket_ioctl_config_coherent_allocator(
-		ibuf.enable, ibuf.size, ibuf.dma_address);
+	trace_gasket_ioctl_config_coherent_allocator(ibuf.enable, ibuf.size,
+						     ibuf.dma_address);
 
 	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
 		return -EFAULT;
@@ -207,13 +206,13 @@ static int gasket_config_coherent_allocator(
 		return -ENOMEM;
 
 	if (ibuf.enable == 0) {
-		ret = gasket_free_coherent_memory(
-			gasket_dev, ibuf.size, ibuf.dma_address,
-			ibuf.page_table_index);
+		ret = gasket_free_coherent_memory(gasket_dev, ibuf.size,
+						  ibuf.dma_address,
+						  ibuf.page_table_index);
 	} else {
-		ret = gasket_alloc_coherent_memory(
-			gasket_dev, ibuf.size, &ibuf.dma_address,
-			ibuf.page_table_index);
+		ret = gasket_alloc_coherent_memory(gasket_dev, ibuf.size,
+						   &ibuf.dma_address,
+						   ibuf.page_table_index);
 	}
 	if (ret)
 		return ret;
@@ -313,8 +312,9 @@ long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
 		break;
 	case GASKET_IOCTL_CLEAR_EVENTFD:
 		trace_gasket_ioctl_integer_data(arg);
-		retval = gasket_interrupt_clear_eventfd(
-			gasket_dev->interrupt_data, (int)arg);
+		retval =
+			gasket_interrupt_clear_eventfd(gasket_dev->interrupt_data,
+						       (int)arg);
 		break;
 	case GASKET_IOCTL_PARTITION_PAGE_TABLE:
 		trace_gasket_ioctl_integer_data(arg);

commit ea174ccd2a1144c6bc02943220a916e4a556f5ff
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 31 13:24:35 2018 -0700

    staging: gasket: ioctl: remove static function forward declarations
    
    Remove forward declarations of static functions, move code to avoid
    forward references, for kernel style.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 55bdd7bfac86..134d45a281ac 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -23,194 +23,6 @@
 #define trace_gasket_ioctl_config_coherent_allocator(x, ...)
 #endif
 
-static bool gasket_ioctl_check_permissions(struct file *filp, uint cmd);
-static int gasket_set_event_fd(struct gasket_dev *dev,
-			       struct gasket_interrupt_eventfd __user *argp);
-static int gasket_read_page_table_size(
-	struct gasket_dev *gasket_dev,
-	struct gasket_page_table_ioctl __user *argp);
-static int gasket_read_simple_page_table_size(
-	struct gasket_dev *gasket_dev,
-	struct gasket_page_table_ioctl __user *argp);
-static int gasket_partition_page_table(
-	struct gasket_dev *gasket_dev,
-	struct gasket_page_table_ioctl __user *argp);
-static int gasket_map_buffers(struct gasket_dev *gasket_dev,
-			      struct gasket_page_table_ioctl __user *argp);
-static int gasket_unmap_buffers(struct gasket_dev *gasket_dev,
-				struct gasket_page_table_ioctl __user *argp);
-static int gasket_config_coherent_allocator(
-	struct gasket_dev *gasket_dev,
-	struct gasket_coherent_alloc_config_ioctl __user *argp);
-
-/*
- * standard ioctl dispatch function.
- * @filp: File structure pointer describing this node usage session.
- * @cmd: ioctl number to handle.
- * @argp: ioctl-specific data pointer.
- *
- * Standard ioctl dispatcher; forwards operations to individual handlers.
- */
-long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
-{
-	struct gasket_dev *gasket_dev;
-	unsigned long arg = (unsigned long)argp;
-	gasket_ioctl_permissions_cb_t ioctl_permissions_cb;
-	int retval;
-
-	gasket_dev = (struct gasket_dev *)filp->private_data;
-	trace_gasket_ioctl_entry(gasket_dev->dev_info.name, cmd);
-
-	ioctl_permissions_cb = gasket_get_ioctl_permissions_cb(gasket_dev);
-	if (ioctl_permissions_cb) {
-		retval = ioctl_permissions_cb(filp, cmd, argp);
-		if (retval < 0) {
-			trace_gasket_ioctl_exit(retval);
-			return retval;
-		} else if (retval == 0) {
-			trace_gasket_ioctl_exit(-EPERM);
-			return -EPERM;
-		}
-	} else if (!gasket_ioctl_check_permissions(filp, cmd)) {
-		trace_gasket_ioctl_exit(-EPERM);
-		dev_dbg(gasket_dev->dev, "ioctl cmd=%x noperm\n", cmd);
-		return -EPERM;
-	}
-
-	/* Tracing happens in this switch statement for all ioctls with
-	 * an integer argrument, but ioctls with a struct argument
-	 * that needs copying and decoding, that tracing is done within
-	 * the handler call.
-	 */
-	switch (cmd) {
-	case GASKET_IOCTL_RESET:
-		trace_gasket_ioctl_integer_data(arg);
-		retval = gasket_reset(gasket_dev, arg);
-		break;
-	case GASKET_IOCTL_SET_EVENTFD:
-		retval = gasket_set_event_fd(gasket_dev, argp);
-		break;
-	case GASKET_IOCTL_CLEAR_EVENTFD:
-		trace_gasket_ioctl_integer_data(arg);
-		retval = gasket_interrupt_clear_eventfd(
-			gasket_dev->interrupt_data, (int)arg);
-		break;
-	case GASKET_IOCTL_PARTITION_PAGE_TABLE:
-		trace_gasket_ioctl_integer_data(arg);
-		retval = gasket_partition_page_table(gasket_dev, argp);
-		break;
-	case GASKET_IOCTL_NUMBER_PAGE_TABLES:
-		trace_gasket_ioctl_integer_data(gasket_dev->num_page_tables);
-		if (copy_to_user(argp, &gasket_dev->num_page_tables,
-				 sizeof(uint64_t)))
-			retval = -EFAULT;
-		else
-			retval = 0;
-		break;
-	case GASKET_IOCTL_PAGE_TABLE_SIZE:
-		retval = gasket_read_page_table_size(gasket_dev, argp);
-		break;
-	case GASKET_IOCTL_SIMPLE_PAGE_TABLE_SIZE:
-		retval = gasket_read_simple_page_table_size(gasket_dev, argp);
-		break;
-	case GASKET_IOCTL_MAP_BUFFER:
-		retval = gasket_map_buffers(gasket_dev, argp);
-		break;
-	case GASKET_IOCTL_CONFIG_COHERENT_ALLOCATOR:
-		retval = gasket_config_coherent_allocator(gasket_dev, argp);
-		break;
-	case GASKET_IOCTL_UNMAP_BUFFER:
-		retval = gasket_unmap_buffers(gasket_dev, argp);
-		break;
-	case GASKET_IOCTL_CLEAR_INTERRUPT_COUNTS:
-		/* Clear interrupt counts doesn't take an arg, so use 0. */
-		trace_gasket_ioctl_integer_data(0);
-		retval = gasket_interrupt_reset_counts(gasket_dev);
-		break;
-	default:
-		/* If we don't understand the ioctl, the best we can do is trace
-		 * the arg.
-		 */
-		trace_gasket_ioctl_integer_data(arg);
-		dev_dbg(gasket_dev->dev,
-			"Unknown ioctl cmd=0x%x not caught by "
-			"gasket_is_supported_ioctl\n",
-			cmd);
-		retval = -EINVAL;
-		break;
-	}
-
-	trace_gasket_ioctl_exit(retval);
-	return retval;
-}
-
-/*
- * Determines if an ioctl is part of the standard Gasket framework.
- * @cmd: The ioctl number to handle.
- *
- * Returns 1 if the ioctl is supported and 0 otherwise.
- */
-long gasket_is_supported_ioctl(uint cmd)
-{
-	switch (cmd) {
-	case GASKET_IOCTL_RESET:
-	case GASKET_IOCTL_SET_EVENTFD:
-	case GASKET_IOCTL_CLEAR_EVENTFD:
-	case GASKET_IOCTL_PARTITION_PAGE_TABLE:
-	case GASKET_IOCTL_NUMBER_PAGE_TABLES:
-	case GASKET_IOCTL_PAGE_TABLE_SIZE:
-	case GASKET_IOCTL_SIMPLE_PAGE_TABLE_SIZE:
-	case GASKET_IOCTL_MAP_BUFFER:
-	case GASKET_IOCTL_UNMAP_BUFFER:
-	case GASKET_IOCTL_CLEAR_INTERRUPT_COUNTS:
-	case GASKET_IOCTL_CONFIG_COHERENT_ALLOCATOR:
-		return 1;
-	default:
-		return 0;
-	}
-}
-
-/* Check permissions for Gasket ioctls. */
-static bool gasket_ioctl_check_permissions(struct file *filp, uint cmd)
-{
-	bool alive;
-	bool read, write;
-	struct gasket_dev *gasket_dev = (struct gasket_dev *)filp->private_data;
-
-	alive = (gasket_dev->status == GASKET_STATUS_ALIVE);
-	if (!alive)
-		dev_dbg(gasket_dev->dev, "%s alive %d status %d\n",
-			__func__, alive, gasket_dev->status);
-
-	read = !!(filp->f_mode & FMODE_READ);
-	write = !!(filp->f_mode & FMODE_WRITE);
-
-	switch (cmd) {
-	case GASKET_IOCTL_RESET:
-	case GASKET_IOCTL_CLEAR_INTERRUPT_COUNTS:
-		return write;
-
-	case GASKET_IOCTL_PAGE_TABLE_SIZE:
-	case GASKET_IOCTL_SIMPLE_PAGE_TABLE_SIZE:
-	case GASKET_IOCTL_NUMBER_PAGE_TABLES:
-		return read;
-
-	case GASKET_IOCTL_PARTITION_PAGE_TABLE:
-	case GASKET_IOCTL_CONFIG_COHERENT_ALLOCATOR:
-		return alive && write;
-
-	case GASKET_IOCTL_MAP_BUFFER:
-	case GASKET_IOCTL_UNMAP_BUFFER:
-		return alive && write;
-
-	case GASKET_IOCTL_CLEAR_EVENTFD:
-	case GASKET_IOCTL_SET_EVENTFD:
-		return alive && write;
-	}
-
-	return false; /* unknown permissions */
-}
-
 /* Associate an eventfd with an interrupt. */
 static int gasket_set_event_fd(struct gasket_dev *gasket_dev,
 			       struct gasket_interrupt_eventfd __user *argp)
@@ -410,3 +222,171 @@ static int gasket_config_coherent_allocator(
 
 	return 0;
 }
+
+/* Check permissions for Gasket ioctls. */
+static bool gasket_ioctl_check_permissions(struct file *filp, uint cmd)
+{
+	bool alive;
+	bool read, write;
+	struct gasket_dev *gasket_dev = (struct gasket_dev *)filp->private_data;
+
+	alive = (gasket_dev->status == GASKET_STATUS_ALIVE);
+	if (!alive)
+		dev_dbg(gasket_dev->dev, "%s alive %d status %d\n",
+			__func__, alive, gasket_dev->status);
+
+	read = !!(filp->f_mode & FMODE_READ);
+	write = !!(filp->f_mode & FMODE_WRITE);
+
+	switch (cmd) {
+	case GASKET_IOCTL_RESET:
+	case GASKET_IOCTL_CLEAR_INTERRUPT_COUNTS:
+		return write;
+
+	case GASKET_IOCTL_PAGE_TABLE_SIZE:
+	case GASKET_IOCTL_SIMPLE_PAGE_TABLE_SIZE:
+	case GASKET_IOCTL_NUMBER_PAGE_TABLES:
+		return read;
+
+	case GASKET_IOCTL_PARTITION_PAGE_TABLE:
+	case GASKET_IOCTL_CONFIG_COHERENT_ALLOCATOR:
+		return alive && write;
+
+	case GASKET_IOCTL_MAP_BUFFER:
+	case GASKET_IOCTL_UNMAP_BUFFER:
+		return alive && write;
+
+	case GASKET_IOCTL_CLEAR_EVENTFD:
+	case GASKET_IOCTL_SET_EVENTFD:
+		return alive && write;
+	}
+
+	return false; /* unknown permissions */
+}
+
+/*
+ * standard ioctl dispatch function.
+ * @filp: File structure pointer describing this node usage session.
+ * @cmd: ioctl number to handle.
+ * @argp: ioctl-specific data pointer.
+ *
+ * Standard ioctl dispatcher; forwards operations to individual handlers.
+ */
+long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
+{
+	struct gasket_dev *gasket_dev;
+	unsigned long arg = (unsigned long)argp;
+	gasket_ioctl_permissions_cb_t ioctl_permissions_cb;
+	int retval;
+
+	gasket_dev = (struct gasket_dev *)filp->private_data;
+	trace_gasket_ioctl_entry(gasket_dev->dev_info.name, cmd);
+
+	ioctl_permissions_cb = gasket_get_ioctl_permissions_cb(gasket_dev);
+	if (ioctl_permissions_cb) {
+		retval = ioctl_permissions_cb(filp, cmd, argp);
+		if (retval < 0) {
+			trace_gasket_ioctl_exit(retval);
+			return retval;
+		} else if (retval == 0) {
+			trace_gasket_ioctl_exit(-EPERM);
+			return -EPERM;
+		}
+	} else if (!gasket_ioctl_check_permissions(filp, cmd)) {
+		trace_gasket_ioctl_exit(-EPERM);
+		dev_dbg(gasket_dev->dev, "ioctl cmd=%x noperm\n", cmd);
+		return -EPERM;
+	}
+
+	/* Tracing happens in this switch statement for all ioctls with
+	 * an integer argrument, but ioctls with a struct argument
+	 * that needs copying and decoding, that tracing is done within
+	 * the handler call.
+	 */
+	switch (cmd) {
+	case GASKET_IOCTL_RESET:
+		trace_gasket_ioctl_integer_data(arg);
+		retval = gasket_reset(gasket_dev, arg);
+		break;
+	case GASKET_IOCTL_SET_EVENTFD:
+		retval = gasket_set_event_fd(gasket_dev, argp);
+		break;
+	case GASKET_IOCTL_CLEAR_EVENTFD:
+		trace_gasket_ioctl_integer_data(arg);
+		retval = gasket_interrupt_clear_eventfd(
+			gasket_dev->interrupt_data, (int)arg);
+		break;
+	case GASKET_IOCTL_PARTITION_PAGE_TABLE:
+		trace_gasket_ioctl_integer_data(arg);
+		retval = gasket_partition_page_table(gasket_dev, argp);
+		break;
+	case GASKET_IOCTL_NUMBER_PAGE_TABLES:
+		trace_gasket_ioctl_integer_data(gasket_dev->num_page_tables);
+		if (copy_to_user(argp, &gasket_dev->num_page_tables,
+				 sizeof(uint64_t)))
+			retval = -EFAULT;
+		else
+			retval = 0;
+		break;
+	case GASKET_IOCTL_PAGE_TABLE_SIZE:
+		retval = gasket_read_page_table_size(gasket_dev, argp);
+		break;
+	case GASKET_IOCTL_SIMPLE_PAGE_TABLE_SIZE:
+		retval = gasket_read_simple_page_table_size(gasket_dev, argp);
+		break;
+	case GASKET_IOCTL_MAP_BUFFER:
+		retval = gasket_map_buffers(gasket_dev, argp);
+		break;
+	case GASKET_IOCTL_CONFIG_COHERENT_ALLOCATOR:
+		retval = gasket_config_coherent_allocator(gasket_dev, argp);
+		break;
+	case GASKET_IOCTL_UNMAP_BUFFER:
+		retval = gasket_unmap_buffers(gasket_dev, argp);
+		break;
+	case GASKET_IOCTL_CLEAR_INTERRUPT_COUNTS:
+		/* Clear interrupt counts doesn't take an arg, so use 0. */
+		trace_gasket_ioctl_integer_data(0);
+		retval = gasket_interrupt_reset_counts(gasket_dev);
+		break;
+	default:
+		/* If we don't understand the ioctl, the best we can do is trace
+		 * the arg.
+		 */
+		trace_gasket_ioctl_integer_data(arg);
+		dev_dbg(gasket_dev->dev,
+			"Unknown ioctl cmd=0x%x not caught by "
+			"gasket_is_supported_ioctl\n",
+			cmd);
+		retval = -EINVAL;
+		break;
+	}
+
+	trace_gasket_ioctl_exit(retval);
+	return retval;
+}
+
+/*
+ * Determines if an ioctl is part of the standard Gasket framework.
+ * @cmd: The ioctl number to handle.
+ *
+ * Returns 1 if the ioctl is supported and 0 otherwise.
+ */
+long gasket_is_supported_ioctl(uint cmd)
+{
+	switch (cmd) {
+	case GASKET_IOCTL_RESET:
+	case GASKET_IOCTL_SET_EVENTFD:
+	case GASKET_IOCTL_CLEAR_EVENTFD:
+	case GASKET_IOCTL_PARTITION_PAGE_TABLE:
+	case GASKET_IOCTL_NUMBER_PAGE_TABLES:
+	case GASKET_IOCTL_PAGE_TABLE_SIZE:
+	case GASKET_IOCTL_SIMPLE_PAGE_TABLE_SIZE:
+	case GASKET_IOCTL_MAP_BUFFER:
+	case GASKET_IOCTL_UNMAP_BUFFER:
+	case GASKET_IOCTL_CLEAR_INTERRUPT_COUNTS:
+	case GASKET_IOCTL_CONFIG_COHERENT_ALLOCATOR:
+		return 1;
+	default:
+		return 0;
+	}
+}

commit 73832cf08fdbd190782c011a5e34908f7acf0e71
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Jul 29 12:36:40 2018 -0700

    staging: gasket: ioctl: simplify comments for static functions
    
    Static functions don't need kernel doc formatting, can be simplified.
    Reformat comments that can be single-line.  Remove extraneous text.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 78a132a60cc4..55bdd7bfac86 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -170,14 +170,7 @@ long gasket_is_supported_ioctl(uint cmd)
 	}
 }
 
-/*
- * Permission checker for Gasket ioctls.
- * @filp: File structure pointer describing this node usage session.
- * @cmd: ioctl number to handle.
- *
- * Check permissions for Gasket ioctls.
- * Returns true if the file opener may execute this ioctl, or false otherwise.
- */
+/* Check permissions for Gasket ioctls. */
 static bool gasket_ioctl_check_permissions(struct file *filp, uint cmd)
 {
 	bool alive;
@@ -218,11 +211,7 @@ static bool gasket_ioctl_check_permissions(struct file *filp, uint cmd)
 	return false; /* unknown permissions */
 }
 
-/*
- * Associate an eventfd with an interrupt.
- * @gasket_dev: Pointer to the current gasket_dev we're using.
- * @argp: Pointer to gasket_interrupt_eventfd struct in userspace.
- */
+/* Associate an eventfd with an interrupt. */
 static int gasket_set_event_fd(struct gasket_dev *gasket_dev,
 			       struct gasket_interrupt_eventfd __user *argp)
 {
@@ -237,11 +226,7 @@ static int gasket_set_event_fd(struct gasket_dev *gasket_dev,
 		gasket_dev->interrupt_data, die.interrupt, die.event_fd);
 }
 
-/*
- * Reads the size of the page table.
- * @gasket_dev: Pointer to the current gasket_dev we're using.
- * @argp: Pointer to gasket_page_table_ioctl struct in userspace.
- */
+/* Read the size of the page table. */
 static int gasket_read_page_table_size(
 	struct gasket_dev *gasket_dev,
 	struct gasket_page_table_ioctl __user *argp)
@@ -268,11 +253,7 @@ static int gasket_read_page_table_size(
 	return ret;
 }
 
-/*
- * Reads the size of the simple page table.
- * @gasket_dev: Pointer to the current gasket_dev we're using.
- * @argp: Pointer to gasket_page_table_ioctl struct in userspace.
- */
+/* Read the size of the simple page table. */
 static int gasket_read_simple_page_table_size(
 	struct gasket_dev *gasket_dev,
 	struct gasket_page_table_ioctl __user *argp)
@@ -299,11 +280,7 @@ static int gasket_read_simple_page_table_size(
 	return ret;
 }
 
-/*
- * Sets the boundary between the simple and extended page tables.
- * @gasket_dev: Pointer to the current gasket_dev we're using.
- * @argp: Pointer to gasket_page_table_ioctl struct in userspace.
- */
+/* Set the boundary between the simple and extended page tables. */
 static int gasket_partition_page_table(
 	struct gasket_dev *gasket_dev,
 	struct gasket_page_table_ioctl __user *argp)
@@ -340,11 +317,7 @@ static int gasket_partition_page_table(
 	return ret;
 }
 
-/*
- * Maps a userspace buffer to a device virtual address.
- * @gasket_dev: Pointer to the current gasket_dev we're using.
- * @argp: Pointer to a gasket_page_table_ioctl struct in userspace.
- */
+/* Map a userspace buffer to a device virtual address. */
 static int gasket_map_buffers(struct gasket_dev *gasket_dev,
 			      struct gasket_page_table_ioctl __user *argp)
 {
@@ -370,11 +343,7 @@ static int gasket_map_buffers(struct gasket_dev *gasket_dev,
 		ibuf.host_address, ibuf.device_address, ibuf.size / PAGE_SIZE);
 }
 
-/*
- * Unmaps a userspace buffer from a device virtual address.
- * @gasket_dev: Pointer to the current gasket_dev we're using.
- * @argp: Pointer to a gasket_page_table_ioctl struct in userspace.
- */
+/* Unmap a userspace buffer from a device virtual address. */
 static int gasket_unmap_buffers(struct gasket_dev *gasket_dev,
 				struct gasket_page_table_ioctl __user *argp)
 {
@@ -402,10 +371,8 @@ static int gasket_unmap_buffers(struct gasket_dev *gasket_dev,
 }
 
 /*
- * Tell the driver to reserve structures for coherent allocation, and allocate
- * or free the corresponding memory.
- * @dev: Pointer to the current gasket_dev we're using.
- * @argp: Pointer to a gasket_coherent_alloc_config_ioctl struct in userspace.
+ * Reserve structures for coherent allocation, and allocate or free the
+ * corresponding memory.
  */
 static int gasket_config_coherent_allocator(
 	struct gasket_dev *gasket_dev,

commit e25bed80b618c41bcb3ec1db38f373f91aed2550
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 26 20:07:31 2018 -0700

    staging: gasket: ioctl: convert to standard logging
    
    Replace gasket logging calls with standard logging calls.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 63e139ab7ff8..78a132a60cc4 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -5,9 +5,9 @@
 #include "gasket_constants.h"
 #include "gasket_core.h"
 #include "gasket_interrupt.h"
-#include "gasket_logging.h"
 #include "gasket_page_table.h"
 #include <linux/compiler.h>
+#include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/uaccess.h>
 
@@ -73,7 +73,7 @@ long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
 		}
 	} else if (!gasket_ioctl_check_permissions(filp, cmd)) {
 		trace_gasket_ioctl_exit(-EPERM);
-		gasket_log_debug(gasket_dev, "ioctl cmd=%x noperm.", cmd);
+		dev_dbg(gasket_dev->dev, "ioctl cmd=%x noperm\n", cmd);
 		return -EPERM;
 	}
 
@@ -132,10 +132,9 @@ long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
 		 * the arg.
 		 */
 		trace_gasket_ioctl_integer_data(arg);
-		gasket_log_debug(
-			gasket_dev,
+		dev_dbg(gasket_dev->dev,
 			"Unknown ioctl cmd=0x%x not caught by "
-			"gasket_is_supported_ioctl",
+			"gasket_is_supported_ioctl\n",
 			cmd);
 		retval = -EINVAL;
 		break;
@@ -186,12 +185,9 @@ static bool gasket_ioctl_check_permissions(struct file *filp, uint cmd)
 	struct gasket_dev *gasket_dev = (struct gasket_dev *)filp->private_data;
 
 	alive = (gasket_dev->status == GASKET_STATUS_ALIVE);
-	if (!alive) {
-		gasket_nodev_error(
-			"%s alive %d status %d.",
-			__func__,
-			alive, gasket_dev->status);
-	}
+	if (!alive)
+		dev_dbg(gasket_dev->dev, "%s alive %d status %d\n",
+			__func__, alive, gasket_dev->status);
 
 	read = !!(filp->f_mode & FMODE_READ);
 	write = !!(filp->f_mode & FMODE_WRITE);
@@ -329,9 +325,8 @@ static int gasket_partition_page_table(
 		gasket_dev->page_table[ibuf.page_table_index]);
 
 	if (ibuf.size > max_page_table_size) {
-		gasket_log_debug(
-			gasket_dev,
-			"Partition request 0x%llx too large, max is 0x%x.",
+		dev_dbg(gasket_dev->dev,
+			"Partition request 0x%llx too large, max is 0x%x\n",
 			ibuf.size, max_page_table_size);
 		return -EINVAL;
 	}

commit 1d079f20d5aaab58ac6ccc3afd849f7ccebf28a1
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sat Jul 21 06:35:04 2018 -0700

    staging: gasket: ioctl common: convert various logs to debug level
    
    Debugging information is improperly logged at non-debug log level in a
    number of places, and some logs regarding error conditions may be
    generated too frequently, such that these could cause performance
    problems and/or obscure other logs.  Convert these to debug log level.
    
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 8cf094b90cdb..63e139ab7ff8 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -73,7 +73,7 @@ long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
 		}
 	} else if (!gasket_ioctl_check_permissions(filp, cmd)) {
 		trace_gasket_ioctl_exit(-EPERM);
-		gasket_log_error(gasket_dev, "ioctl cmd=%x noperm.", cmd);
+		gasket_log_debug(gasket_dev, "ioctl cmd=%x noperm.", cmd);
 		return -EPERM;
 	}
 
@@ -132,7 +132,7 @@ long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
 		 * the arg.
 		 */
 		trace_gasket_ioctl_integer_data(arg);
-		gasket_log_warn(
+		gasket_log_debug(
 			gasket_dev,
 			"Unknown ioctl cmd=0x%x not caught by "
 			"gasket_is_supported_ioctl",
@@ -329,7 +329,7 @@ static int gasket_partition_page_table(
 		gasket_dev->page_table[ibuf.page_table_index]);
 
 	if (ibuf.size > max_page_table_size) {
-		gasket_log_error(
+		gasket_log_debug(
 			gasket_dev,
 			"Partition request 0x%llx too large, max is 0x%x.",
 			ibuf.size, max_page_table_size);

commit 5c4a5d3ddd724d1c4f27c3b52ad0980c4c750999
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sat Jul 21 06:34:57 2018 -0700

    staging: gasket: avoid copy to user on error in coherent alloc config
    
    gasket_config_coherent_allocator() on error return the error to caller
    without copying a possibly-update DMA address back to userspace.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 1b164ac7a049..8cf094b90cdb 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -441,8 +441,10 @@ static int gasket_config_coherent_allocator(
 			gasket_dev, ibuf.size, &ibuf.dma_address,
 			ibuf.page_table_index);
 	}
+	if (ret)
+		return ret;
 	if (copy_to_user(argp, &ibuf, sizeof(ibuf)))
 		return -EFAULT;
 
-	return ret;
+	return 0;
 }

commit 8fc1cb4cef287fd61391adcc48f4a6bdc369bf49
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sat Jul 21 06:34:56 2018 -0700

    staging: gasket: gasket_handle_ioctl fix ioctl exit trace param
    
    Pass the return value from the device ioctl permissions callback to the
    tracepoint when the callback returns an error.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index dbe9fdef0c26..1b164ac7a049 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -65,7 +65,7 @@ long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
 	if (ioctl_permissions_cb) {
 		retval = ioctl_permissions_cb(filp, cmd, argp);
 		if (retval < 0) {
-			trace_gasket_ioctl_exit(-EPERM);
+			trace_gasket_ioctl_exit(retval);
 			return retval;
 		} else if (retval == 0) {
 			trace_gasket_ioctl_exit(-EPERM);

commit 996e650030857e791416af81d7d9171d9652bd9d
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sat Jul 21 06:34:55 2018 -0700

    staging: gasket: remove duplicate call to retrieve device callback
    
    gasket_handle_ioctl() calls gasket_get_ioctl_permissions_cb() twice;
    simplify the code and avoid duplicated work by fetching the callback
    pointer only once.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 2e2c9b997093..dbe9fdef0c26 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -55,14 +55,15 @@ long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
 {
 	struct gasket_dev *gasket_dev;
 	unsigned long arg = (unsigned long)argp;
+	gasket_ioctl_permissions_cb_t ioctl_permissions_cb;
 	int retval;
 
 	gasket_dev = (struct gasket_dev *)filp->private_data;
 	trace_gasket_ioctl_entry(gasket_dev->dev_info.name, cmd);
 
-	if (gasket_get_ioctl_permissions_cb(gasket_dev)) {
-		retval = gasket_get_ioctl_permissions_cb(gasket_dev)(
-			filp, cmd, argp);
+	ioctl_permissions_cb = gasket_get_ioctl_permissions_cb(gasket_dev);
+	if (ioctl_permissions_cb) {
+		retval = ioctl_permissions_cb(filp, cmd, argp);
 		if (retval < 0) {
 			trace_gasket_ioctl_exit(-EPERM);
 			return retval;

commit 56edc4e3f909cf8d37e9aa16ce0b5dbc66734995
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:20 2018 -0700

    staging: gasket: common ioctls add __user annotations
    
    Add __user annotation to gasket common ioctl pointer arguments for
    sparse checking.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 998d0e215523..2e2c9b997093 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -24,17 +24,24 @@
 #endif
 
 static bool gasket_ioctl_check_permissions(struct file *filp, uint cmd);
-static int gasket_set_event_fd(struct gasket_dev *dev, ulong arg);
+static int gasket_set_event_fd(struct gasket_dev *dev,
+			       struct gasket_interrupt_eventfd __user *argp);
 static int gasket_read_page_table_size(
-	struct gasket_dev *gasket_dev, ulong arg);
+	struct gasket_dev *gasket_dev,
+	struct gasket_page_table_ioctl __user *argp);
 static int gasket_read_simple_page_table_size(
-	struct gasket_dev *gasket_dev, ulong arg);
+	struct gasket_dev *gasket_dev,
+	struct gasket_page_table_ioctl __user *argp);
 static int gasket_partition_page_table(
-	struct gasket_dev *gasket_dev, ulong arg);
-static int gasket_map_buffers(struct gasket_dev *gasket_dev, ulong arg);
-static int gasket_unmap_buffers(struct gasket_dev *gasket_dev, ulong arg);
+	struct gasket_dev *gasket_dev,
+	struct gasket_page_table_ioctl __user *argp);
+static int gasket_map_buffers(struct gasket_dev *gasket_dev,
+			      struct gasket_page_table_ioctl __user *argp);
+static int gasket_unmap_buffers(struct gasket_dev *gasket_dev,
+				struct gasket_page_table_ioctl __user *argp);
 static int gasket_config_coherent_allocator(
-	struct gasket_dev *gasket_dev, ulong arg);
+	struct gasket_dev *gasket_dev,
+	struct gasket_coherent_alloc_config_ioctl __user *argp);
 
 /*
  * standard ioctl dispatch function.
@@ -80,7 +87,7 @@ long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
 		retval = gasket_reset(gasket_dev, arg);
 		break;
 	case GASKET_IOCTL_SET_EVENTFD:
-		retval = gasket_set_event_fd(gasket_dev, arg);
+		retval = gasket_set_event_fd(gasket_dev, argp);
 		break;
 	case GASKET_IOCTL_CLEAR_EVENTFD:
 		trace_gasket_ioctl_integer_data(arg);
@@ -89,31 +96,30 @@ long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
 		break;
 	case GASKET_IOCTL_PARTITION_PAGE_TABLE:
 		trace_gasket_ioctl_integer_data(arg);
-		retval = gasket_partition_page_table(gasket_dev, arg);
+		retval = gasket_partition_page_table(gasket_dev, argp);
 		break;
 	case GASKET_IOCTL_NUMBER_PAGE_TABLES:
 		trace_gasket_ioctl_integer_data(gasket_dev->num_page_tables);
-		if (copy_to_user((void __user *)arg,
-				 &gasket_dev->num_page_tables,
+		if (copy_to_user(argp, &gasket_dev->num_page_tables,
 				 sizeof(uint64_t)))
 			retval = -EFAULT;
 		else
 			retval = 0;
 		break;
 	case GASKET_IOCTL_PAGE_TABLE_SIZE:
-		retval = gasket_read_page_table_size(gasket_dev, arg);
+		retval = gasket_read_page_table_size(gasket_dev, argp);
 		break;
 	case GASKET_IOCTL_SIMPLE_PAGE_TABLE_SIZE:
-		retval = gasket_read_simple_page_table_size(gasket_dev, arg);
+		retval = gasket_read_simple_page_table_size(gasket_dev, argp);
 		break;
 	case GASKET_IOCTL_MAP_BUFFER:
-		retval = gasket_map_buffers(gasket_dev, arg);
+		retval = gasket_map_buffers(gasket_dev, argp);
 		break;
 	case GASKET_IOCTL_CONFIG_COHERENT_ALLOCATOR:
-		retval = gasket_config_coherent_allocator(gasket_dev, arg);
+		retval = gasket_config_coherent_allocator(gasket_dev, argp);
 		break;
 	case GASKET_IOCTL_UNMAP_BUFFER:
-		retval = gasket_unmap_buffers(gasket_dev, arg);
+		retval = gasket_unmap_buffers(gasket_dev, argp);
 		break;
 	case GASKET_IOCTL_CLEAR_INTERRUPT_COUNTS:
 		/* Clear interrupt counts doesn't take an arg, so use 0. */
@@ -218,16 +224,15 @@ static bool gasket_ioctl_check_permissions(struct file *filp, uint cmd)
 /*
  * Associate an eventfd with an interrupt.
  * @gasket_dev: Pointer to the current gasket_dev we're using.
- * @arg: Pointer to gasket_interrupt_eventfd struct in userspace.
+ * @argp: Pointer to gasket_interrupt_eventfd struct in userspace.
  */
-static int gasket_set_event_fd(struct gasket_dev *gasket_dev, ulong arg)
+static int gasket_set_event_fd(struct gasket_dev *gasket_dev,
+			       struct gasket_interrupt_eventfd __user *argp)
 {
 	struct gasket_interrupt_eventfd die;
 
-	if (copy_from_user(&die, (void __user *)arg,
-			   sizeof(struct gasket_interrupt_eventfd))) {
+	if (copy_from_user(&die, argp, sizeof(struct gasket_interrupt_eventfd)))
 		return -EFAULT;
-	}
 
 	trace_gasket_ioctl_eventfd_data(die.interrupt, die.event_fd);
 
@@ -238,15 +243,16 @@ static int gasket_set_event_fd(struct gasket_dev *gasket_dev, ulong arg)
 /*
  * Reads the size of the page table.
  * @gasket_dev: Pointer to the current gasket_dev we're using.
- * @arg: Pointer to gasket_page_table_ioctl struct in userspace.
+ * @argp: Pointer to gasket_page_table_ioctl struct in userspace.
  */
-static int gasket_read_page_table_size(struct gasket_dev *gasket_dev, ulong arg)
+static int gasket_read_page_table_size(
+	struct gasket_dev *gasket_dev,
+	struct gasket_page_table_ioctl __user *argp)
 {
 	int ret = 0;
 	struct gasket_page_table_ioctl ibuf;
 
-	if (copy_from_user(&ibuf, (void __user *)arg,
-			   sizeof(struct gasket_page_table_ioctl)))
+	if (copy_from_user(&ibuf, argp, sizeof(struct gasket_page_table_ioctl)))
 		return -EFAULT;
 
 	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
@@ -259,7 +265,7 @@ static int gasket_read_page_table_size(struct gasket_dev *gasket_dev, ulong arg)
 		ibuf.page_table_index, ibuf.size, ibuf.host_address,
 		ibuf.device_address);
 
-	if (copy_to_user((void __user *)arg, &ibuf, sizeof(ibuf)))
+	if (copy_to_user(argp, &ibuf, sizeof(ibuf)))
 		return -EFAULT;
 
 	return ret;
@@ -268,16 +274,16 @@ static int gasket_read_page_table_size(struct gasket_dev *gasket_dev, ulong arg)
 /*
  * Reads the size of the simple page table.
  * @gasket_dev: Pointer to the current gasket_dev we're using.
- * @arg: Pointer to gasket_page_table_ioctl struct in userspace.
+ * @argp: Pointer to gasket_page_table_ioctl struct in userspace.
  */
 static int gasket_read_simple_page_table_size(
-	struct gasket_dev *gasket_dev, ulong arg)
+	struct gasket_dev *gasket_dev,
+	struct gasket_page_table_ioctl __user *argp)
 {
 	int ret = 0;
 	struct gasket_page_table_ioctl ibuf;
 
-	if (copy_from_user(&ibuf, (void __user *)arg,
-			   sizeof(struct gasket_page_table_ioctl)))
+	if (copy_from_user(&ibuf, argp, sizeof(struct gasket_page_table_ioctl)))
 		return -EFAULT;
 
 	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
@@ -290,7 +296,7 @@ static int gasket_read_simple_page_table_size(
 		ibuf.page_table_index, ibuf.size, ibuf.host_address,
 		ibuf.device_address);
 
-	if (copy_to_user((void __user *)arg, &ibuf, sizeof(ibuf)))
+	if (copy_to_user(argp, &ibuf, sizeof(ibuf)))
 		return -EFAULT;
 
 	return ret;
@@ -299,16 +305,17 @@ static int gasket_read_simple_page_table_size(
 /*
  * Sets the boundary between the simple and extended page tables.
  * @gasket_dev: Pointer to the current gasket_dev we're using.
- * @arg: Pointer to gasket_page_table_ioctl struct in userspace.
+ * @argp: Pointer to gasket_page_table_ioctl struct in userspace.
  */
-static int gasket_partition_page_table(struct gasket_dev *gasket_dev, ulong arg)
+static int gasket_partition_page_table(
+	struct gasket_dev *gasket_dev,
+	struct gasket_page_table_ioctl __user *argp)
 {
 	int ret;
 	struct gasket_page_table_ioctl ibuf;
 	uint max_page_table_size;
 
-	if (copy_from_user(&ibuf, (void __user *)arg,
-			   sizeof(struct gasket_page_table_ioctl)))
+	if (copy_from_user(&ibuf, argp, sizeof(struct gasket_page_table_ioctl)))
 		return -EFAULT;
 
 	trace_gasket_ioctl_page_table_data(
@@ -340,14 +347,14 @@ static int gasket_partition_page_table(struct gasket_dev *gasket_dev, ulong arg)
 /*
  * Maps a userspace buffer to a device virtual address.
  * @gasket_dev: Pointer to the current gasket_dev we're using.
- * @arg: Pointer to a gasket_page_table_ioctl struct in userspace.
+ * @argp: Pointer to a gasket_page_table_ioctl struct in userspace.
  */
-static int gasket_map_buffers(struct gasket_dev *gasket_dev, ulong arg)
+static int gasket_map_buffers(struct gasket_dev *gasket_dev,
+			      struct gasket_page_table_ioctl __user *argp)
 {
 	struct gasket_page_table_ioctl ibuf;
 
-	if (copy_from_user(&ibuf, (void __user *)arg,
-			   sizeof(struct gasket_page_table_ioctl)))
+	if (copy_from_user(&ibuf, argp, sizeof(struct gasket_page_table_ioctl)))
 		return -EFAULT;
 
 	trace_gasket_ioctl_page_table_data(
@@ -370,14 +377,14 @@ static int gasket_map_buffers(struct gasket_dev *gasket_dev, ulong arg)
 /*
  * Unmaps a userspace buffer from a device virtual address.
  * @gasket_dev: Pointer to the current gasket_dev we're using.
- * @arg: Pointer to a gasket_page_table_ioctl struct in userspace.
+ * @argp: Pointer to a gasket_page_table_ioctl struct in userspace.
  */
-static int gasket_unmap_buffers(struct gasket_dev *gasket_dev, ulong arg)
+static int gasket_unmap_buffers(struct gasket_dev *gasket_dev,
+				struct gasket_page_table_ioctl __user *argp)
 {
 	struct gasket_page_table_ioctl ibuf;
 
-	if (copy_from_user(&ibuf, (void __user *)arg,
-			   sizeof(struct gasket_page_table_ioctl)))
+	if (copy_from_user(&ibuf, argp, sizeof(struct gasket_page_table_ioctl)))
 		return -EFAULT;
 
 	trace_gasket_ioctl_page_table_data(
@@ -402,15 +409,16 @@ static int gasket_unmap_buffers(struct gasket_dev *gasket_dev, ulong arg)
  * Tell the driver to reserve structures for coherent allocation, and allocate
  * or free the corresponding memory.
  * @dev: Pointer to the current gasket_dev we're using.
- * @arg: Pointer to a gasket_coherent_alloc_config_ioctl struct in userspace.
+ * @argp: Pointer to a gasket_coherent_alloc_config_ioctl struct in userspace.
  */
 static int gasket_config_coherent_allocator(
-	struct gasket_dev *gasket_dev, ulong arg)
+	struct gasket_dev *gasket_dev,
+	struct gasket_coherent_alloc_config_ioctl __user *argp)
 {
 	int ret;
 	struct gasket_coherent_alloc_config_ioctl ibuf;
 
-	if (copy_from_user(&ibuf, (void __user *)arg,
+	if (copy_from_user(&ibuf, argp,
 			   sizeof(struct gasket_coherent_alloc_config_ioctl)))
 		return -EFAULT;
 
@@ -432,7 +440,7 @@ static int gasket_config_coherent_allocator(
 			gasket_dev, ibuf.size, &ibuf.dma_address,
 			ibuf.page_table_index);
 	}
-	if (copy_to_user((void __user *)arg, &ibuf, sizeof(ibuf)))
+	if (copy_to_user(argp, &ibuf, sizeof(ibuf)))
 		return -EFAULT;
 
 	return ret;

commit de3690d025fced530a587b820f00f67cd964289e
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:19 2018 -0700

    staging: gasket: common ioctl dispatcher add __user annotations
    
    Add __user annotation to gasket core common ioctl pointer arguments for
    sparse checking.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 8fd44979fe71..998d0e215523 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -7,6 +7,7 @@
 #include "gasket_interrupt.h"
 #include "gasket_logging.h"
 #include "gasket_page_table.h"
+#include <linux/compiler.h>
 #include <linux/fs.h>
 #include <linux/uaccess.h>
 
@@ -39,13 +40,14 @@ static int gasket_config_coherent_allocator(
  * standard ioctl dispatch function.
  * @filp: File structure pointer describing this node usage session.
  * @cmd: ioctl number to handle.
- * @arg: ioctl-specific data pointer.
+ * @argp: ioctl-specific data pointer.
  *
  * Standard ioctl dispatcher; forwards operations to individual handlers.
  */
-long gasket_handle_ioctl(struct file *filp, uint cmd, ulong arg)
+long gasket_handle_ioctl(struct file *filp, uint cmd, void __user *argp)
 {
 	struct gasket_dev *gasket_dev;
+	unsigned long arg = (unsigned long)argp;
 	int retval;
 
 	gasket_dev = (struct gasket_dev *)filp->private_data;
@@ -53,7 +55,7 @@ long gasket_handle_ioctl(struct file *filp, uint cmd, ulong arg)
 
 	if (gasket_get_ioctl_permissions_cb(gasket_dev)) {
 		retval = gasket_get_ioctl_permissions_cb(gasket_dev)(
-			filp, cmd, arg);
+			filp, cmd, argp);
 		if (retval < 0) {
 			trace_gasket_ioctl_exit(-EPERM);
 			return retval;

commit ed74277bd80a47ec552ccf3581583421c3a4df5d
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:16 2018 -0700

    staging: gasket: always allow root open for write
    
    Always allow root to open device for writing.
    
    Drop special-casing of ioctl permissions for root vs. owner.
    
    Convert to bool types as appropriate.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index d0142ed048a6..8fd44979fe71 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -22,7 +22,7 @@
 #define trace_gasket_ioctl_config_coherent_allocator(x, ...)
 #endif
 
-static uint gasket_ioctl_check_permissions(struct file *filp, uint cmd);
+static bool gasket_ioctl_check_permissions(struct file *filp, uint cmd);
 static int gasket_set_event_fd(struct gasket_dev *dev, ulong arg);
 static int gasket_read_page_table_size(
 	struct gasket_dev *gasket_dev, ulong arg);
@@ -167,12 +167,13 @@ long gasket_is_supported_ioctl(uint cmd)
  * @filp: File structure pointer describing this node usage session.
  * @cmd: ioctl number to handle.
  *
- * Standard permissions checker.
+ * Check permissions for Gasket ioctls.
+ * Returns true if the file opener may execute this ioctl, or false otherwise.
  */
-static uint gasket_ioctl_check_permissions(struct file *filp, uint cmd)
+static bool gasket_ioctl_check_permissions(struct file *filp, uint cmd)
 {
-	uint alive, root, device_owner;
-	fmode_t read, write;
+	bool alive;
+	bool read, write;
 	struct gasket_dev *gasket_dev = (struct gasket_dev *)filp->private_data;
 
 	alive = (gasket_dev->status == GASKET_STATUS_ALIVE);
@@ -183,36 +184,33 @@ static uint gasket_ioctl_check_permissions(struct file *filp, uint cmd)
 			alive, gasket_dev->status);
 	}
 
-	root = capable(CAP_SYS_ADMIN);
-	read = filp->f_mode & FMODE_READ;
-	write = filp->f_mode & FMODE_WRITE;
-	device_owner = (gasket_dev->dev_info.ownership.is_owned &&
-			current->tgid == gasket_dev->dev_info.ownership.owner);
+	read = !!(filp->f_mode & FMODE_READ);
+	write = !!(filp->f_mode & FMODE_WRITE);
 
 	switch (cmd) {
 	case GASKET_IOCTL_RESET:
 	case GASKET_IOCTL_CLEAR_INTERRUPT_COUNTS:
-		return root || (write && device_owner);
+		return write;
 
 	case GASKET_IOCTL_PAGE_TABLE_SIZE:
 	case GASKET_IOCTL_SIMPLE_PAGE_TABLE_SIZE:
 	case GASKET_IOCTL_NUMBER_PAGE_TABLES:
-		return root || read;
+		return read;
 
 	case GASKET_IOCTL_PARTITION_PAGE_TABLE:
 	case GASKET_IOCTL_CONFIG_COHERENT_ALLOCATOR:
-		return alive && (root || (write && device_owner));
+		return alive && write;
 
 	case GASKET_IOCTL_MAP_BUFFER:
 	case GASKET_IOCTL_UNMAP_BUFFER:
-		return alive && (root || (write && device_owner));
+		return alive && write;
 
 	case GASKET_IOCTL_CLEAR_EVENTFD:
 	case GASKET_IOCTL_SET_EVENTFD:
-		return alive && (root || (write && device_owner));
+		return alive && write;
 	}
 
-	return 0; /* unknown permissions */
+	return false; /* unknown permissions */
 }
 
 /*

commit ed6e96c7951b85bb5c6a50503baa2fd9bfbb0510
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:05 2018 -0700

    staging: gasket: remove unnecessary code in coherent allocator
    
    Remove extraneous statement in gasket_config_coherent_allocator()
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 0c2f85cf5448..d0142ed048a6 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -420,10 +420,8 @@ static int gasket_config_coherent_allocator(
 	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
 		return -EFAULT;
 
-	if (ibuf.size > PAGE_SIZE * MAX_NUM_COHERENT_PAGES) {
-		ibuf.size = PAGE_SIZE * MAX_NUM_COHERENT_PAGES;
+	if (ibuf.size > PAGE_SIZE * MAX_NUM_COHERENT_PAGES)
 		return -ENOMEM;
-	}
 
 	if (ibuf.enable == 0) {
 		ret = gasket_free_coherent_memory(

commit 948fd537bd3d6f347ff1c87b82479873d1fcc77f
Author: Felix Siegel <felix.siegel@posteo.de>
Date:   Fri Jul 13 00:58:49 2018 +0200

    staging: gasket: Use __func__ instead of hardcoded string - Style
    
    Changed logging statements to use %s and __func__ instead of hard coding
    the function name in a string.
    
    Signed-off-by: Felix Siegel <felix.siegel@posteo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 3c54542610f7..0c2f85cf5448 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -178,7 +178,8 @@ static uint gasket_ioctl_check_permissions(struct file *filp, uint cmd)
 	alive = (gasket_dev->status == GASKET_STATUS_ALIVE);
 	if (!alive) {
 		gasket_nodev_error(
-			"gasket_ioctl_check_permissions alive %d status %d.",
+			"%s alive %d status %d.",
+			__func__,
 			alive, gasket_dev->status);
 	}
 

commit bf9c7a8673831acd67ad4a92b6acd85ffcde174c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 11 13:39:11 2018 +0200

    staging: gasket: remove redundant license information
    
    Now that the SPDX tag is in all gasket files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index c5d7beefc3ff..3c54542610f7 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -1,15 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright (C) 2018 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
+/* Copyright (C) 2018 Google, Inc. */
 #include "gasket.h"
 #include "gasket_ioctl.h"
 #include "gasket_constants.h"

commit 2dec0644e0c8083e0a9d3bbdd11aad2d850859e9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 11 13:39:10 2018 +0200

    staging: gasket: add SPDX identifiers to all files.
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the all of the staging gasket files to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
index 4758083fb19b..c5d7beefc3ff 100644
--- a/drivers/staging/gasket/gasket_ioctl.c
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /* Copyright (C) 2018 Google, Inc.
  *
  * This software is licensed under the terms of the GNU General Public

commit 9a69f5087ccc20bb411025decab455836df04168
Author: Simon Que <sque@chromium.org>
Date:   Fri Jun 29 22:49:38 2018 -0400

    drivers/staging: Gasket driver framework + Apex driver
    
    The Gasket (Google ASIC Software, Kernel Extensions, and Tools) kernel
    framework is a generic, flexible system that supports thin kernel
    drivers. Gasket kernel drivers are expected to handle opening and
    closing devices, mmap'ing BAR space as requested, a small selection of
    ioctls, and handling page table translation (covered below). Any other
    functions should be handled by userspace code.
    
    The Gasket common module is not enough to run a device. In order to
    customize the Gasket code for a given piece of hardware, a device
    specific module must be created. At a minimum, this module must define a
    struct gasket_driver_desc containing the device-specific data for use by
    the framework; in addition, the module must declare an __init function
    that calls gasket_register_device with the module's gasket_driver_desc
    struct. Finally, the driver must define an exit function that calls
    gasket_unregister_device with the module's gasket_driver_desc struct.
    
    One of the core assumptions of the Gasket framework is that precisely
    one process is allowed to have an open write handle to the device node
    at any given time. (That process may, once it has one write handle, open
    any number of additional write handles.) This is accomplished by
    tracking open and close data for each driver instance.
    
    Signed-off-by: Rob Springer <rspringer@google.com>
    Signed-off-by: John Joseph <jnjoseph@google.com>
    Signed-off-by: Simon Que <sque@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_ioctl.c b/drivers/staging/gasket/gasket_ioctl.c
new file mode 100644
index 000000000000..4758083fb19b
--- /dev/null
+++ b/drivers/staging/gasket/gasket_ioctl.c
@@ -0,0 +1,449 @@
+/* Copyright (C) 2018 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include "gasket.h"
+#include "gasket_ioctl.h"
+#include "gasket_constants.h"
+#include "gasket_core.h"
+#include "gasket_interrupt.h"
+#include "gasket_logging.h"
+#include "gasket_page_table.h"
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+
+#ifdef GASKET_KERNEL_TRACE_SUPPORT
+#define CREATE_TRACE_POINTS
+#include <trace/events/gasket_ioctl.h>
+#else
+#define trace_gasket_ioctl_entry(x, ...)
+#define trace_gasket_ioctl_exit(x)
+#define trace_gasket_ioctl_integer_data(x)
+#define trace_gasket_ioctl_eventfd_data(x, ...)
+#define trace_gasket_ioctl_page_table_data(x, ...)
+#define trace_gasket_ioctl_config_coherent_allocator(x, ...)
+#endif
+
+static uint gasket_ioctl_check_permissions(struct file *filp, uint cmd);
+static int gasket_set_event_fd(struct gasket_dev *dev, ulong arg);
+static int gasket_read_page_table_size(
+	struct gasket_dev *gasket_dev, ulong arg);
+static int gasket_read_simple_page_table_size(
+	struct gasket_dev *gasket_dev, ulong arg);
+static int gasket_partition_page_table(
+	struct gasket_dev *gasket_dev, ulong arg);
+static int gasket_map_buffers(struct gasket_dev *gasket_dev, ulong arg);
+static int gasket_unmap_buffers(struct gasket_dev *gasket_dev, ulong arg);
+static int gasket_config_coherent_allocator(
+	struct gasket_dev *gasket_dev, ulong arg);
+
+/*
+ * standard ioctl dispatch function.
+ * @filp: File structure pointer describing this node usage session.
+ * @cmd: ioctl number to handle.
+ * @arg: ioctl-specific data pointer.
+ *
+ * Standard ioctl dispatcher; forwards operations to individual handlers.
+ */
+long gasket_handle_ioctl(struct file *filp, uint cmd, ulong arg)
+{
+	struct gasket_dev *gasket_dev;
+	int retval;
+
+	gasket_dev = (struct gasket_dev *)filp->private_data;
+	trace_gasket_ioctl_entry(gasket_dev->dev_info.name, cmd);
+
+	if (gasket_get_ioctl_permissions_cb(gasket_dev)) {
+		retval = gasket_get_ioctl_permissions_cb(gasket_dev)(
+			filp, cmd, arg);
+		if (retval < 0) {
+			trace_gasket_ioctl_exit(-EPERM);
+			return retval;
+		} else if (retval == 0) {
+			trace_gasket_ioctl_exit(-EPERM);
+			return -EPERM;
+		}
+	} else if (!gasket_ioctl_check_permissions(filp, cmd)) {
+		trace_gasket_ioctl_exit(-EPERM);
+		gasket_log_error(gasket_dev, "ioctl cmd=%x noperm.", cmd);
+		return -EPERM;
+	}
+
+	/* Tracing happens in this switch statement for all ioctls with
+	 * an integer argrument, but ioctls with a struct argument
+	 * that needs copying and decoding, that tracing is done within
+	 * the handler call.
+	 */
+	switch (cmd) {
+	case GASKET_IOCTL_RESET:
+		trace_gasket_ioctl_integer_data(arg);
+		retval = gasket_reset(gasket_dev, arg);
+		break;
+	case GASKET_IOCTL_SET_EVENTFD:
+		retval = gasket_set_event_fd(gasket_dev, arg);
+		break;
+	case GASKET_IOCTL_CLEAR_EVENTFD:
+		trace_gasket_ioctl_integer_data(arg);
+		retval = gasket_interrupt_clear_eventfd(
+			gasket_dev->interrupt_data, (int)arg);
+		break;
+	case GASKET_IOCTL_PARTITION_PAGE_TABLE:
+		trace_gasket_ioctl_integer_data(arg);
+		retval = gasket_partition_page_table(gasket_dev, arg);
+		break;
+	case GASKET_IOCTL_NUMBER_PAGE_TABLES:
+		trace_gasket_ioctl_integer_data(gasket_dev->num_page_tables);
+		if (copy_to_user((void __user *)arg,
+				 &gasket_dev->num_page_tables,
+				 sizeof(uint64_t)))
+			retval = -EFAULT;
+		else
+			retval = 0;
+		break;
+	case GASKET_IOCTL_PAGE_TABLE_SIZE:
+		retval = gasket_read_page_table_size(gasket_dev, arg);
+		break;
+	case GASKET_IOCTL_SIMPLE_PAGE_TABLE_SIZE:
+		retval = gasket_read_simple_page_table_size(gasket_dev, arg);
+		break;
+	case GASKET_IOCTL_MAP_BUFFER:
+		retval = gasket_map_buffers(gasket_dev, arg);
+		break;
+	case GASKET_IOCTL_CONFIG_COHERENT_ALLOCATOR:
+		retval = gasket_config_coherent_allocator(gasket_dev, arg);
+		break;
+	case GASKET_IOCTL_UNMAP_BUFFER:
+		retval = gasket_unmap_buffers(gasket_dev, arg);
+		break;
+	case GASKET_IOCTL_CLEAR_INTERRUPT_COUNTS:
+		/* Clear interrupt counts doesn't take an arg, so use 0. */
+		trace_gasket_ioctl_integer_data(0);
+		retval = gasket_interrupt_reset_counts(gasket_dev);
+		break;
+	default:
+		/* If we don't understand the ioctl, the best we can do is trace
+		 * the arg.
+		 */
+		trace_gasket_ioctl_integer_data(arg);
+		gasket_log_warn(
+			gasket_dev,
+			"Unknown ioctl cmd=0x%x not caught by "
+			"gasket_is_supported_ioctl",
+			cmd);
+		retval = -EINVAL;
+		break;
+	}
+
+	trace_gasket_ioctl_exit(retval);
+	return retval;
+}
+
+/*
+ * Determines if an ioctl is part of the standard Gasket framework.
+ * @cmd: The ioctl number to handle.
+ *
+ * Returns 1 if the ioctl is supported and 0 otherwise.
+ */
+long gasket_is_supported_ioctl(uint cmd)
+{
+	switch (cmd) {
+	case GASKET_IOCTL_RESET:
+	case GASKET_IOCTL_SET_EVENTFD:
+	case GASKET_IOCTL_CLEAR_EVENTFD:
+	case GASKET_IOCTL_PARTITION_PAGE_TABLE:
+	case GASKET_IOCTL_NUMBER_PAGE_TABLES:
+	case GASKET_IOCTL_PAGE_TABLE_SIZE:
+	case GASKET_IOCTL_SIMPLE_PAGE_TABLE_SIZE:
+	case GASKET_IOCTL_MAP_BUFFER:
+	case GASKET_IOCTL_UNMAP_BUFFER:
+	case GASKET_IOCTL_CLEAR_INTERRUPT_COUNTS:
+	case GASKET_IOCTL_CONFIG_COHERENT_ALLOCATOR:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+/*
+ * Permission checker for Gasket ioctls.
+ * @filp: File structure pointer describing this node usage session.
+ * @cmd: ioctl number to handle.
+ *
+ * Standard permissions checker.
+ */
+static uint gasket_ioctl_check_permissions(struct file *filp, uint cmd)
+{
+	uint alive, root, device_owner;
+	fmode_t read, write;
+	struct gasket_dev *gasket_dev = (struct gasket_dev *)filp->private_data;
+
+	alive = (gasket_dev->status == GASKET_STATUS_ALIVE);
+	if (!alive) {
+		gasket_nodev_error(
+			"gasket_ioctl_check_permissions alive %d status %d.",
+			alive, gasket_dev->status);
+	}
+
+	root = capable(CAP_SYS_ADMIN);
+	read = filp->f_mode & FMODE_READ;
+	write = filp->f_mode & FMODE_WRITE;
+	device_owner = (gasket_dev->dev_info.ownership.is_owned &&
+			current->tgid == gasket_dev->dev_info.ownership.owner);
+
+	switch (cmd) {
+	case GASKET_IOCTL_RESET:
+	case GASKET_IOCTL_CLEAR_INTERRUPT_COUNTS:
+		return root || (write && device_owner);
+
+	case GASKET_IOCTL_PAGE_TABLE_SIZE:
+	case GASKET_IOCTL_SIMPLE_PAGE_TABLE_SIZE:
+	case GASKET_IOCTL_NUMBER_PAGE_TABLES:
+		return root || read;
+
+	case GASKET_IOCTL_PARTITION_PAGE_TABLE:
+	case GASKET_IOCTL_CONFIG_COHERENT_ALLOCATOR:
+		return alive && (root || (write && device_owner));
+
+	case GASKET_IOCTL_MAP_BUFFER:
+	case GASKET_IOCTL_UNMAP_BUFFER:
+		return alive && (root || (write && device_owner));
+
+	case GASKET_IOCTL_CLEAR_EVENTFD:
+	case GASKET_IOCTL_SET_EVENTFD:
+		return alive && (root || (write && device_owner));
+	}
+
+	return 0; /* unknown permissions */
+}
+
+/*
+ * Associate an eventfd with an interrupt.
+ * @gasket_dev: Pointer to the current gasket_dev we're using.
+ * @arg: Pointer to gasket_interrupt_eventfd struct in userspace.
+ */
+static int gasket_set_event_fd(struct gasket_dev *gasket_dev, ulong arg)
+{
+	struct gasket_interrupt_eventfd die;
+
+	if (copy_from_user(&die, (void __user *)arg,
+			   sizeof(struct gasket_interrupt_eventfd))) {
+		return -EFAULT;
+	}
+
+	trace_gasket_ioctl_eventfd_data(die.interrupt, die.event_fd);
+
+	return gasket_interrupt_set_eventfd(
+		gasket_dev->interrupt_data, die.interrupt, die.event_fd);
+}
+
+/*
+ * Reads the size of the page table.
+ * @gasket_dev: Pointer to the current gasket_dev we're using.
+ * @arg: Pointer to gasket_page_table_ioctl struct in userspace.
+ */
+static int gasket_read_page_table_size(struct gasket_dev *gasket_dev, ulong arg)
+{
+	int ret = 0;
+	struct gasket_page_table_ioctl ibuf;
+
+	if (copy_from_user(&ibuf, (void __user *)arg,
+			   sizeof(struct gasket_page_table_ioctl)))
+		return -EFAULT;
+
+	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
+		return -EFAULT;
+
+	ibuf.size = gasket_page_table_num_entries(
+		gasket_dev->page_table[ibuf.page_table_index]);
+
+	trace_gasket_ioctl_page_table_data(
+		ibuf.page_table_index, ibuf.size, ibuf.host_address,
+		ibuf.device_address);
+
+	if (copy_to_user((void __user *)arg, &ibuf, sizeof(ibuf)))
+		return -EFAULT;
+
+	return ret;
+}
+
+/*
+ * Reads the size of the simple page table.
+ * @gasket_dev: Pointer to the current gasket_dev we're using.
+ * @arg: Pointer to gasket_page_table_ioctl struct in userspace.
+ */
+static int gasket_read_simple_page_table_size(
+	struct gasket_dev *gasket_dev, ulong arg)
+{
+	int ret = 0;
+	struct gasket_page_table_ioctl ibuf;
+
+	if (copy_from_user(&ibuf, (void __user *)arg,
+			   sizeof(struct gasket_page_table_ioctl)))
+		return -EFAULT;
+
+	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
+		return -EFAULT;
+
+	ibuf.size = gasket_page_table_num_simple_entries(
+		gasket_dev->page_table[ibuf.page_table_index]);
+
+	trace_gasket_ioctl_page_table_data(
+		ibuf.page_table_index, ibuf.size, ibuf.host_address,
+		ibuf.device_address);
+
+	if (copy_to_user((void __user *)arg, &ibuf, sizeof(ibuf)))
+		return -EFAULT;
+
+	return ret;
+}
+
+/*
+ * Sets the boundary between the simple and extended page tables.
+ * @gasket_dev: Pointer to the current gasket_dev we're using.
+ * @arg: Pointer to gasket_page_table_ioctl struct in userspace.
+ */
+static int gasket_partition_page_table(struct gasket_dev *gasket_dev, ulong arg)
+{
+	int ret;
+	struct gasket_page_table_ioctl ibuf;
+	uint max_page_table_size;
+
+	if (copy_from_user(&ibuf, (void __user *)arg,
+			   sizeof(struct gasket_page_table_ioctl)))
+		return -EFAULT;
+
+	trace_gasket_ioctl_page_table_data(
+		ibuf.page_table_index, ibuf.size, ibuf.host_address,
+		ibuf.device_address);
+
+	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
+		return -EFAULT;
+	max_page_table_size = gasket_page_table_max_size(
+		gasket_dev->page_table[ibuf.page_table_index]);
+
+	if (ibuf.size > max_page_table_size) {
+		gasket_log_error(
+			gasket_dev,
+			"Partition request 0x%llx too large, max is 0x%x.",
+			ibuf.size, max_page_table_size);
+		return -EINVAL;
+	}
+
+	mutex_lock(&gasket_dev->mutex);
+
+	ret = gasket_page_table_partition(
+		gasket_dev->page_table[ibuf.page_table_index], ibuf.size);
+	mutex_unlock(&gasket_dev->mutex);
+
+	return ret;
+}
+
+/*
+ * Maps a userspace buffer to a device virtual address.
+ * @gasket_dev: Pointer to the current gasket_dev we're using.
+ * @arg: Pointer to a gasket_page_table_ioctl struct in userspace.
+ */
+static int gasket_map_buffers(struct gasket_dev *gasket_dev, ulong arg)
+{
+	struct gasket_page_table_ioctl ibuf;
+
+	if (copy_from_user(&ibuf, (void __user *)arg,
+			   sizeof(struct gasket_page_table_ioctl)))
+		return -EFAULT;
+
+	trace_gasket_ioctl_page_table_data(
+		ibuf.page_table_index, ibuf.size, ibuf.host_address,
+		ibuf.device_address);
+
+	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
+		return -EFAULT;
+
+	if (gasket_page_table_are_addrs_bad(
+		    gasket_dev->page_table[ibuf.page_table_index],
+		    ibuf.host_address, ibuf.device_address, ibuf.size))
+		return -EINVAL;
+
+	return gasket_page_table_map(
+		gasket_dev->page_table[ibuf.page_table_index],
+		ibuf.host_address, ibuf.device_address, ibuf.size / PAGE_SIZE);
+}
+
+/*
+ * Unmaps a userspace buffer from a device virtual address.
+ * @gasket_dev: Pointer to the current gasket_dev we're using.
+ * @arg: Pointer to a gasket_page_table_ioctl struct in userspace.
+ */
+static int gasket_unmap_buffers(struct gasket_dev *gasket_dev, ulong arg)
+{
+	struct gasket_page_table_ioctl ibuf;
+
+	if (copy_from_user(&ibuf, (void __user *)arg,
+			   sizeof(struct gasket_page_table_ioctl)))
+		return -EFAULT;
+
+	trace_gasket_ioctl_page_table_data(
+		ibuf.page_table_index, ibuf.size, ibuf.host_address,
+		ibuf.device_address);
+
+	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
+		return -EFAULT;
+
+	if (gasket_page_table_is_dev_addr_bad(
+		    gasket_dev->page_table[ibuf.page_table_index],
+		    ibuf.device_address, ibuf.size))
+		return -EINVAL;
+
+	gasket_page_table_unmap(gasket_dev->page_table[ibuf.page_table_index],
+				ibuf.device_address, ibuf.size / PAGE_SIZE);
+
+	return 0;
+}
+
+/*
+ * Tell the driver to reserve structures for coherent allocation, and allocate
+ * or free the corresponding memory.
+ * @dev: Pointer to the current gasket_dev we're using.
+ * @arg: Pointer to a gasket_coherent_alloc_config_ioctl struct in userspace.
+ */
+static int gasket_config_coherent_allocator(
+	struct gasket_dev *gasket_dev, ulong arg)
+{
+	int ret;
+	struct gasket_coherent_alloc_config_ioctl ibuf;
+
+	if (copy_from_user(&ibuf, (void __user *)arg,
+			   sizeof(struct gasket_coherent_alloc_config_ioctl)))
+		return -EFAULT;
+
+	trace_gasket_ioctl_config_coherent_allocator(
+		ibuf.enable, ibuf.size, ibuf.dma_address);
+
+	if (ibuf.page_table_index >= gasket_dev->num_page_tables)
+		return -EFAULT;
+
+	if (ibuf.size > PAGE_SIZE * MAX_NUM_COHERENT_PAGES) {
+		ibuf.size = PAGE_SIZE * MAX_NUM_COHERENT_PAGES;
+		return -ENOMEM;
+	}
+
+	if (ibuf.enable == 0) {
+		ret = gasket_free_coherent_memory(
+			gasket_dev, ibuf.size, ibuf.dma_address,
+			ibuf.page_table_index);
+	} else {
+		ret = gasket_alloc_coherent_memory(
+			gasket_dev, ibuf.size, &ibuf.dma_address,
+			ibuf.page_table_index);
+	}
+	if (copy_to_user((void __user *)arg, &ibuf, sizeof(ibuf)))
+		return -EFAULT;
+
+	return ret;
+}
