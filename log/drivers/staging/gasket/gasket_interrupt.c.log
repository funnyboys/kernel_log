commit f21cf4601404285b3e72263836ba01cdade8a62d
Author: Sanjana Sanikommu <sanjana99reddy99@gmail.com>
Date:   Sun Mar 17 23:43:28 2019 +0530

    staging: gasket: gasket_interuppt.c: Fix string split issue.
    
    Remove string " across the line.
    Issue found by checkpatch.pl semantic patch results for rtw_ap.c
    
    Signed-off-by: Sanjana Sanikommu <sanjana99reddy99@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index ff61b782df30..2d6195f7300e 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -97,8 +97,7 @@ static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 		 * modify-write and shift based on the packing index.
 		 */
 		dev_dbg(gasket_dev->dev,
-			"Setting up interrupt index %d with index 0x%llx and "
-			"packing %d\n",
+			"Setting up interrupt index %d with index 0x%llx and packing %d\n",
 			interrupt_data->interrupts[i].index,
 			interrupt_data->interrupts[i].reg,
 			interrupt_data->interrupts[i].packing);
@@ -120,8 +119,7 @@ static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 				break;
 			default:
 				dev_dbg(gasket_dev->dev,
-					"Found interrupt description with "
-					"unknown enum %d\n",
+					"Found interrupt description with unknown enum %d\n",
 					interrupt_data->interrupts[i].packing);
 				return;
 			}

commit da217871edb2d31c602c6b69cc6ce15a74debce7
Author: Yue Haibing <yuehaibing@huawei.com>
Date:   Mon Jan 21 08:26:37 2019 +0000

    staging: gasket: interrupt: remove unused including <linux/version.h>
    
    Remove including <linux/version.h> that don't need it.
    
    Signed-off-by: Yue Haibing <yuehaibing@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index ad5657d213f0..ff61b782df30 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -9,7 +9,6 @@
 #include <linux/device.h>
 #include <linux/interrupt.h>
 #include <linux/printk.h>
-#include <linux/version.h>
 #ifdef GASKET_KERNEL_TRACE_SUPPORT
 #define CREATE_TRACE_POINTS
 #include <trace/events/gasket_interrupt.h>

commit cd27f56fce4fedc975663ecebb8166444a80b75c
Author: Kimberly Brown <kimbrownkd@gmail.com>
Date:   Thu Oct 25 20:04:55 2018 -0400

    staging: gasket: use sizeof(*p) for memory allocation
    
    Use sizeof(*p) instead of sizeof(struct P) for memory allocation. This
    change complies with the Linux kernel coding style. It improves
    readability and decreases the opportunity for bugs if the pointer
    variable type is changed. Issue found by checkpatch.
    
    Signed-off-by: Kimberly Brown <kimbrownkd@gmail.com>
    Acked-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index 49d47afad64f..ad5657d213f0 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -184,7 +184,7 @@ gasket_interrupt_msix_init(struct gasket_interrupt_data *interrupt_data)
 
 	interrupt_data->msix_entries =
 		kcalloc(interrupt_data->num_interrupts,
-			sizeof(struct msix_entry), GFP_KERNEL);
+			sizeof(*interrupt_data->msix_entries), GFP_KERNEL);
 	if (!interrupt_data->msix_entries)
 		return -ENOMEM;
 
@@ -322,8 +322,7 @@ int gasket_interrupt_init(struct gasket_dev *gasket_dev)
 	const struct gasket_driver_desc *driver_desc =
 		gasket_get_driver_desc(gasket_dev);
 
-	interrupt_data = kzalloc(sizeof(struct gasket_interrupt_data),
-				 GFP_KERNEL);
+	interrupt_data = kzalloc(sizeof(*interrupt_data), GFP_KERNEL);
 	if (!interrupt_data)
 		return -ENOMEM;
 	gasket_dev->interrupt_data = interrupt_data;
@@ -336,17 +335,17 @@ int gasket_interrupt_init(struct gasket_dev *gasket_dev)
 	interrupt_data->pack_width = driver_desc->interrupt_pack_width;
 	interrupt_data->num_configured = 0;
 
-	interrupt_data->eventfd_ctxs = kcalloc(driver_desc->num_interrupts,
-					       sizeof(struct eventfd_ctx *),
-					       GFP_KERNEL);
+	interrupt_data->eventfd_ctxs =
+		kcalloc(driver_desc->num_interrupts,
+			sizeof(*interrupt_data->eventfd_ctxs), GFP_KERNEL);
 	if (!interrupt_data->eventfd_ctxs) {
 		kfree(interrupt_data);
 		return -ENOMEM;
 	}
 
-	interrupt_data->interrupt_counts = kcalloc(driver_desc->num_interrupts,
-						   sizeof(ulong),
-						   GFP_KERNEL);
+	interrupt_data->interrupt_counts =
+		kcalloc(driver_desc->num_interrupts,
+			sizeof(*interrupt_data->interrupt_counts), GFP_KERNEL);
 	if (!interrupt_data->interrupt_counts) {
 		kfree(interrupt_data->eventfd_ctxs);
 		kfree(interrupt_data);

commit 467976ff6e566a695c2964bb2ca24eba154a1d82
Author: Todd Poynor <toddpoynor@google.com>
Date:   Mon Sep 17 05:38:57 2018 -0700

    staging: gasket: interrupt: remove PCI-MSIX-specific status check
    
    Devices not using MSIX don't use the msix_initialized field, so don't
    require it to be set in the interrupt system status check. The general
    check for interrupts configured that follows can cover both MSIX and
    device-managed interrupts.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index 2cd262be65ca..49d47afad64f 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -478,11 +478,6 @@ int gasket_interrupt_system_status(struct gasket_dev *gasket_dev)
 		return GASKET_STATUS_DEAD;
 	}
 
-	if (!gasket_dev->interrupt_data->msix_configured) {
-		dev_dbg(gasket_dev->dev, "Interrupt not initialized\n");
-		return GASKET_STATUS_LAMED;
-	}
-
 	if (gasket_dev->interrupt_data->num_configured !=
 		gasket_dev->interrupt_data->num_interrupts) {
 		dev_dbg(gasket_dev->dev,

commit cca5dd879075e95b706376123ea22231190aefe9
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:21:11 2018 -0700

    staging: gasket: interrupt: remove unimplemented interrupt types
    
    Interrupt types PCI_MSI and PLATFORM_WIRE are unused and unimplemented.
    Remove these.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index eb5dfbe08e21..2cd262be65ca 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -45,9 +45,6 @@ struct gasket_interrupt_data {
 	/* The width of a single interrupt in a packed interrupt register. */
 	int pack_width;
 
-	/* offset of wire interrupt registers */
-	const struct gasket_wire_interrupt_offsets *wire_interrupt_offsets;
-
 	/*
 	 * Design-wise, these elements should be bundled together, but
 	 * pci_enable_msix's interface requires that they be managed
@@ -92,19 +89,6 @@ static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 
 	dev_dbg(gasket_dev->dev, "Running interrupt setup\n");
 
-	if (interrupt_data->type == PLATFORM_WIRE ||
-	    interrupt_data->type == PCI_MSI) {
-		/* Nothing needs to be done for platform or PCI devices. */
-		return;
-	}
-
-	if (interrupt_data->type != PCI_MSIX) {
-		dev_dbg(gasket_dev->dev,
-			"Cannot handle unsupported interrupt type %d\n",
-			interrupt_data->type);
-		return;
-	}
-
 	/* Setup the MSIX table. */
 
 	for (i = 0; i < interrupt_data->num_interrupts; i++) {
@@ -351,8 +335,6 @@ int gasket_interrupt_init(struct gasket_dev *gasket_dev)
 	interrupt_data->interrupt_bar_index = driver_desc->interrupt_bar_index;
 	interrupt_data->pack_width = driver_desc->interrupt_pack_width;
 	interrupt_data->num_configured = 0;
-	interrupt_data->wire_interrupt_offsets =
-	    driver_desc->wire_interrupt_offsets;
 
 	interrupt_data->eventfd_ctxs = kcalloc(driver_desc->num_interrupts,
 					       sizeof(struct eventfd_ctx *),
@@ -379,12 +361,7 @@ int gasket_interrupt_init(struct gasket_dev *gasket_dev)
 		force_msix_interrupt_unmasking(gasket_dev);
 		break;
 
-	case PCI_MSI:
-	case PLATFORM_WIRE:
 	default:
-		dev_err(gasket_dev->dev,
-			"Cannot handle unsupported interrupt type %d\n",
-			interrupt_data->type);
 		ret = -EINVAL;
 	}
 
@@ -439,12 +416,7 @@ int gasket_interrupt_reinit(struct gasket_dev *gasket_dev)
 		force_msix_interrupt_unmasking(gasket_dev);
 		break;
 
-	case PCI_MSI:
-	case PLATFORM_WIRE:
 	default:
-		dev_dbg(gasket_dev->dev,
-			"Cannot handle unsupported interrupt type %d\n",
-			gasket_dev->interrupt_data->type);
 		ret = -EINVAL;
 	}
 
@@ -489,12 +461,8 @@ void gasket_interrupt_cleanup(struct gasket_dev *gasket_dev)
 		gasket_interrupt_msix_cleanup(interrupt_data);
 		break;
 
-	case PCI_MSI:
-	case PLATFORM_WIRE:
 	default:
-		dev_dbg(gasket_dev->dev,
-			"Cannot handle unsupported interrupt type %d\n",
-			interrupt_data->type);
+		break;
 	}
 
 	kfree(interrupt_data->interrupt_counts);

commit 8b872d6f06c20d58058afb457cc266c578c431b2
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:21:10 2018 -0700

    staging: gasket: interrupt: simplify interrupt init parameters
    
    Pass the gasket driver descriptor to the interrupt init function, rather
    than exploding out separate parameters from various fields of that
    structure.  This allows us to make more localized changes to the types
    of interrupts supported (MSIX vs. wire, etc.) without affecting the
    calling sequence, and seems nicer for simplification purposes.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index f94e4ea9a7de..eb5dfbe08e21 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -331,31 +331,30 @@ static struct gasket_sysfs_attribute interrupt_sysfs_attrs[] = {
 	GASKET_END_OF_ATTR_ARRAY,
 };
 
-int gasket_interrupt_init(struct gasket_dev *gasket_dev, const char *name,
-			  int type,
-			  const struct gasket_interrupt_desc *interrupts,
-			  int num_interrupts, int pack_width, int bar_index,
-			  const struct gasket_wire_interrupt_offsets *wire_int_offsets)
+int gasket_interrupt_init(struct gasket_dev *gasket_dev)
 {
 	int ret;
 	struct gasket_interrupt_data *interrupt_data;
+	const struct gasket_driver_desc *driver_desc =
+		gasket_get_driver_desc(gasket_dev);
 
 	interrupt_data = kzalloc(sizeof(struct gasket_interrupt_data),
 				 GFP_KERNEL);
 	if (!interrupt_data)
 		return -ENOMEM;
 	gasket_dev->interrupt_data = interrupt_data;
-	interrupt_data->name = name;
-	interrupt_data->type = type;
+	interrupt_data->name = driver_desc->name;
+	interrupt_data->type = driver_desc->interrupt_type;
 	interrupt_data->pci_dev = gasket_dev->pci_dev;
-	interrupt_data->num_interrupts = num_interrupts;
-	interrupt_data->interrupts = interrupts;
-	interrupt_data->interrupt_bar_index = bar_index;
-	interrupt_data->pack_width = pack_width;
+	interrupt_data->num_interrupts = driver_desc->num_interrupts;
+	interrupt_data->interrupts = driver_desc->interrupts;
+	interrupt_data->interrupt_bar_index = driver_desc->interrupt_bar_index;
+	interrupt_data->pack_width = driver_desc->interrupt_pack_width;
 	interrupt_data->num_configured = 0;
-	interrupt_data->wire_interrupt_offsets = wire_int_offsets;
+	interrupt_data->wire_interrupt_offsets =
+	    driver_desc->wire_interrupt_offsets;
 
-	interrupt_data->eventfd_ctxs = kcalloc(num_interrupts,
+	interrupt_data->eventfd_ctxs = kcalloc(driver_desc->num_interrupts,
 					       sizeof(struct eventfd_ctx *),
 					       GFP_KERNEL);
 	if (!interrupt_data->eventfd_ctxs) {
@@ -363,7 +362,7 @@ int gasket_interrupt_init(struct gasket_dev *gasket_dev, const char *name,
 		return -ENOMEM;
 	}
 
-	interrupt_data->interrupt_counts = kcalloc(num_interrupts,
+	interrupt_data->interrupt_counts = kcalloc(driver_desc->num_interrupts,
 						   sizeof(ulong),
 						   GFP_KERNEL);
 	if (!interrupt_data->interrupt_counts) {

commit 62af16524ced2f38b754a9a31a9b93854012d38c
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:21:09 2018 -0700

    staging: gasket: interrupt: refactor PCI MSIX-specific handler code
    
    Split interrupt handler into PCI MSIX-specific and generic functions,
    for adding non-MSIX handlers in the future.  Move MSIX init code
    together,, out of generic init path.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index 1cfbc120f228..f94e4ea9a7de 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -157,9 +157,22 @@ static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 	}
 }
 
-static irqreturn_t gasket_msix_interrupt_handler(int irq, void *dev_id)
+static void
+gasket_handle_interrupt(struct gasket_interrupt_data *interrupt_data,
+			int interrupt_index)
 {
 	struct eventfd_ctx *ctx;
+
+	trace_gasket_interrupt_event(interrupt_data->name, interrupt_index);
+	ctx = interrupt_data->eventfd_ctxs[interrupt_index];
+	if (ctx)
+		eventfd_signal(ctx, 1);
+
+	++(interrupt_data->interrupt_counts[interrupt_index]);
+}
+
+static irqreturn_t gasket_msix_interrupt_handler(int irq, void *dev_id)
+{
 	struct gasket_interrupt_data *interrupt_data = dev_id;
 	int interrupt = -1;
 	int i;
@@ -175,14 +188,7 @@ static irqreturn_t gasket_msix_interrupt_handler(int irq, void *dev_id)
 		pr_err("Received unknown irq %d\n", irq);
 		return IRQ_HANDLED;
 	}
-	trace_gasket_interrupt_event(interrupt_data->name, interrupt);
-
-	ctx = interrupt_data->eventfd_ctxs[interrupt];
-	if (ctx)
-		eventfd_signal(ctx, 1);
-
-	++(interrupt_data->interrupt_counts[interrupt]);
-
+	gasket_handle_interrupt(interrupt_data, interrupt);
 	return IRQ_HANDLED;
 }
 
@@ -192,6 +198,12 @@ gasket_interrupt_msix_init(struct gasket_interrupt_data *interrupt_data)
 	int ret = 1;
 	int i;
 
+	interrupt_data->msix_entries =
+		kcalloc(interrupt_data->num_interrupts,
+			sizeof(struct msix_entry), GFP_KERNEL);
+	if (!interrupt_data->msix_entries)
+		return -ENOMEM;
+
 	for (i = 0; i < interrupt_data->num_interrupts; i++) {
 		interrupt_data->msix_entries[i].entry = i;
 		interrupt_data->msix_entries[i].vector = 0;
@@ -343,20 +355,10 @@ int gasket_interrupt_init(struct gasket_dev *gasket_dev, const char *name,
 	interrupt_data->num_configured = 0;
 	interrupt_data->wire_interrupt_offsets = wire_int_offsets;
 
-	/* Allocate all dynamic structures. */
-	interrupt_data->msix_entries = kcalloc(num_interrupts,
-					       sizeof(struct msix_entry),
-					       GFP_KERNEL);
-	if (!interrupt_data->msix_entries) {
-		kfree(interrupt_data);
-		return -ENOMEM;
-	}
-
 	interrupt_data->eventfd_ctxs = kcalloc(num_interrupts,
 					       sizeof(struct eventfd_ctx *),
 					       GFP_KERNEL);
 	if (!interrupt_data->eventfd_ctxs) {
-		kfree(interrupt_data->msix_entries);
 		kfree(interrupt_data);
 		return -ENOMEM;
 	}
@@ -366,7 +368,6 @@ int gasket_interrupt_init(struct gasket_dev *gasket_dev, const char *name,
 						   GFP_KERNEL);
 	if (!interrupt_data->interrupt_counts) {
 		kfree(interrupt_data->eventfd_ctxs);
-		kfree(interrupt_data->msix_entries);
 		kfree(interrupt_data);
 		return -ENOMEM;
 	}
@@ -417,6 +418,7 @@ gasket_interrupt_msix_cleanup(struct gasket_interrupt_data *interrupt_data)
 	if (interrupt_data->msix_configured)
 		pci_disable_msix(interrupt_data->pci_dev);
 	interrupt_data->msix_configured = 0;
+	kfree(interrupt_data->msix_entries);
 }
 
 int gasket_interrupt_reinit(struct gasket_dev *gasket_dev)
@@ -448,10 +450,11 @@ int gasket_interrupt_reinit(struct gasket_dev *gasket_dev)
 	}
 
 	if (ret) {
-		/* Failing to setup MSIx will cause the device
+		/* Failing to setup interrupts will cause the device
 		 * to report GASKET_STATUS_LAMED, but is not fatal.
 		 */
-		dev_warn(gasket_dev->dev, "Couldn't init msix: %d\n", ret);
+		dev_warn(gasket_dev->dev, "Couldn't reinit interrupts: %d\n",
+			 ret);
 		return 0;
 	}
 
@@ -497,7 +500,6 @@ void gasket_interrupt_cleanup(struct gasket_dev *gasket_dev)
 
 	kfree(interrupt_data->interrupt_counts);
 	kfree(interrupt_data->eventfd_ctxs);
-	kfree(interrupt_data->msix_entries);
 	kfree(interrupt_data);
 	gasket_dev->interrupt_data = NULL;
 }

commit ec6e6925fc2adb98ef351d7c25a7e41caa4d5b77
Author: zhong jiang <zhongjiang@huawei.com>
Date:   Mon Aug 6 11:10:19 2018 +0800

    staging: gasket: remove some extra semicolon
    
    That semicolons are unneeded, Just remove them.
    
    Signed-off-by: zhong jiang <zhongjiang@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index 09c3d0747af6..1cfbc120f228 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -386,7 +386,7 @@ int gasket_interrupt_init(struct gasket_dev *gasket_dev, const char *name,
 			"Cannot handle unsupported interrupt type %d\n",
 			interrupt_data->type);
 		ret = -EINVAL;
-	};
+	}
 
 	if (ret) {
 		/* Failing to setup interrupts will cause the device to report
@@ -445,7 +445,7 @@ int gasket_interrupt_reinit(struct gasket_dev *gasket_dev)
 			"Cannot handle unsupported interrupt type %d\n",
 			gasket_dev->interrupt_data->type);
 		ret = -EINVAL;
-	};
+	}
 
 	if (ret) {
 		/* Failing to setup MSIx will cause the device
@@ -493,7 +493,7 @@ void gasket_interrupt_cleanup(struct gasket_dev *gasket_dev)
 		dev_dbg(gasket_dev->dev,
 			"Cannot handle unsupported interrupt type %d\n",
 			interrupt_data->type);
-	};
+	}
 
 	kfree(interrupt_data->interrupt_counts);
 	kfree(interrupt_data->eventfd_ctxs);

commit 21cfa72cddee4cfd6a091968517fdbb4263f71d3
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 31 13:24:43 2018 -0700

    staging: gasket: interrupt: fix function param line continuation style
    
    Fix multi-line alignment formatting to look like:
          int ret = long_function_name(device, VARIABLE1, VARIABLE2,
                                       VARIABLE3, VARIABLE4);
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index 3079b59b122b..09c3d0747af6 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -144,11 +144,10 @@ static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 			}
 
 			mask = ~(0xFFFF << pack_shift);
-			value = gasket_dev_read_64(
-					gasket_dev,
-					interrupt_data->interrupt_bar_index,
-					interrupt_data->interrupts[i].reg) &
-				mask;
+			value = gasket_dev_read_64(gasket_dev,
+						   interrupt_data->interrupt_bar_index,
+						   interrupt_data->interrupts[i].reg);
+			value &= mask;
 			value |= interrupt_data->interrupts[i].index
 				 << pack_shift;
 		}
@@ -187,8 +186,8 @@ static irqreturn_t gasket_msix_interrupt_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int gasket_interrupt_msix_init(
-	struct gasket_interrupt_data *interrupt_data)
+static int
+gasket_interrupt_msix_init(struct gasket_interrupt_data *interrupt_data)
 {
 	int ret = 1;
 	int i;
@@ -210,10 +209,9 @@ static int gasket_interrupt_msix_init(
 	interrupt_data->msix_configured = 1;
 
 	for (i = 0; i < interrupt_data->num_interrupts; i++) {
-		ret = request_irq(
-			interrupt_data->msix_entries[i].vector,
-			gasket_msix_interrupt_handler, 0, interrupt_data->name,
-			interrupt_data);
+		ret = request_irq(interrupt_data->msix_entries[i].vector,
+				  gasket_msix_interrupt_handler, 0,
+				  interrupt_data->name, interrupt_data);
 
 		if (ret) {
 			dev_err(&interrupt_data->pci_dev->dev,
@@ -250,25 +248,23 @@ static void force_msix_interrupt_unmasking(struct gasket_dev *gasket_dev)
 		ulong location = APEX_BAR2_REG_KERNEL_HIB_MSIX_TABLE +
 				 MSIX_MASK_BIT_OFFSET + i * MSIX_VECTOR_SIZE;
 		u32 mask =
-			gasket_dev_read_32(
-				gasket_dev,
-				gasket_dev->interrupt_data->interrupt_bar_index,
-				location);
+			gasket_dev_read_32(gasket_dev,
+					   gasket_dev->interrupt_data->interrupt_bar_index,
+					   location);
 		if (!(mask & 1))
 			continue;
 		/* Unmask the msix vector (clear 32 bits) */
-		gasket_dev_write_32(
-			gasket_dev, 0,
-			gasket_dev->interrupt_data->interrupt_bar_index,
-			location);
+		gasket_dev_write_32(gasket_dev, 0,
+				    gasket_dev->interrupt_data->interrupt_bar_index,
+				    location);
 	}
 #undef MSIX_VECTOR_SIZE
 #undef MSIX_MASK_BIT_OFFSET
 #undef APEX_BAR2_REG_KERNEL_HIB_MSIX_TABLE
 }
 
-static ssize_t interrupt_sysfs_show(
-	struct device *device, struct device_attribute *attr, char *buf)
+static ssize_t interrupt_sysfs_show(struct device *device,
+				    struct device_attribute *attr, char *buf)
 {
 	int i, ret;
 	ssize_t written = 0, total_written = 0;
@@ -318,22 +314,22 @@ static ssize_t interrupt_sysfs_show(
 }
 
 static struct gasket_sysfs_attribute interrupt_sysfs_attrs[] = {
-	GASKET_SYSFS_RO(
-		interrupt_counts, interrupt_sysfs_show, ATTR_INTERRUPT_COUNTS),
+	GASKET_SYSFS_RO(interrupt_counts, interrupt_sysfs_show,
+			ATTR_INTERRUPT_COUNTS),
 	GASKET_END_OF_ATTR_ARRAY,
 };
 
-int gasket_interrupt_init(
-	struct gasket_dev *gasket_dev, const char *name, int type,
-	const struct gasket_interrupt_desc *interrupts,
-	int num_interrupts, int pack_width, int bar_index,
-	const struct gasket_wire_interrupt_offsets *wire_int_offsets)
+int gasket_interrupt_init(struct gasket_dev *gasket_dev, const char *name,
+			  int type,
+			  const struct gasket_interrupt_desc *interrupts,
+			  int num_interrupts, int pack_width, int bar_index,
+			  const struct gasket_wire_interrupt_offsets *wire_int_offsets)
 {
 	int ret;
 	struct gasket_interrupt_data *interrupt_data;
 
-	interrupt_data = kzalloc(
-		sizeof(struct gasket_interrupt_data), GFP_KERNEL);
+	interrupt_data = kzalloc(sizeof(struct gasket_interrupt_data),
+				 GFP_KERNEL);
 	if (!interrupt_data)
 		return -ENOMEM;
 	gasket_dev->interrupt_data = interrupt_data;
@@ -402,14 +398,14 @@ int gasket_interrupt_init(
 	}
 
 	gasket_interrupt_setup(gasket_dev);
-	gasket_sysfs_create_entries(
-		gasket_dev->dev_info.device, interrupt_sysfs_attrs);
+	gasket_sysfs_create_entries(gasket_dev->dev_info.device,
+				    interrupt_sysfs_attrs);
 
 	return 0;
 }
 
-static void gasket_interrupt_msix_cleanup(
-	struct gasket_interrupt_data *interrupt_data)
+static void
+gasket_interrupt_msix_cleanup(struct gasket_interrupt_data *interrupt_data)
 {
 	int i;
 
@@ -528,9 +524,8 @@ int gasket_interrupt_system_status(struct gasket_dev *gasket_dev)
 	return GASKET_STATUS_ALIVE;
 }
 
-int gasket_interrupt_set_eventfd(
-	struct gasket_interrupt_data *interrupt_data, int interrupt,
-	int event_fd)
+int gasket_interrupt_set_eventfd(struct gasket_interrupt_data *interrupt_data,
+				 int interrupt, int event_fd)
 {
 	struct eventfd_ctx *ctx = eventfd_ctx_fdget(event_fd);
 
@@ -544,8 +539,8 @@ int gasket_interrupt_set_eventfd(
 	return 0;
 }
 
-int gasket_interrupt_clear_eventfd(
-	struct gasket_interrupt_data *interrupt_data, int interrupt)
+int gasket_interrupt_clear_eventfd(struct gasket_interrupt_data *interrupt_data,
+				   int interrupt)
 {
 	if (interrupt < 0 || interrupt >= interrupt_data->num_interrupts)
 		return -EINVAL;

commit d821f8eb92ef500cee280e9467e8d89c8de5da0b
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 31 13:24:36 2018 -0700

    staging: gasket: interrupt: remove static function forward declarations
    
    Remove forward declarations of static functions, move code to avoid
    forward references, for kernel style.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index 27fde991edc6..3079b59b122b 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -70,32 +70,259 @@ struct gasket_interrupt_data {
 	int irq;
 };
 
-/* Function definitions. */
-static ssize_t interrupt_sysfs_show(
-	struct device *device, struct device_attribute *attr, char *buf);
-
-static irqreturn_t gasket_msix_interrupt_handler(int irq, void *dev_id);
-
 /* Structures to display interrupt counts in sysfs. */
 enum interrupt_sysfs_attribute_type {
 	ATTR_INTERRUPT_COUNTS,
 };
 
+/* Set up device registers for interrupt handling. */
+static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
+{
+	int i;
+	int pack_shift;
+	ulong mask;
+	ulong value;
+	struct gasket_interrupt_data *interrupt_data =
+		gasket_dev->interrupt_data;
+
+	if (!interrupt_data) {
+		dev_dbg(gasket_dev->dev, "Interrupt data is not initialized\n");
+		return;
+	}
+
+	dev_dbg(gasket_dev->dev, "Running interrupt setup\n");
+
+	if (interrupt_data->type == PLATFORM_WIRE ||
+	    interrupt_data->type == PCI_MSI) {
+		/* Nothing needs to be done for platform or PCI devices. */
+		return;
+	}
+
+	if (interrupt_data->type != PCI_MSIX) {
+		dev_dbg(gasket_dev->dev,
+			"Cannot handle unsupported interrupt type %d\n",
+			interrupt_data->type);
+		return;
+	}
+
+	/* Setup the MSIX table. */
+
+	for (i = 0; i < interrupt_data->num_interrupts; i++) {
+		/*
+		 * If the interrupt is not packed, we can write the index into
+		 * the register directly. If not, we need to deal with a read-
+		 * modify-write and shift based on the packing index.
+		 */
+		dev_dbg(gasket_dev->dev,
+			"Setting up interrupt index %d with index 0x%llx and "
+			"packing %d\n",
+			interrupt_data->interrupts[i].index,
+			interrupt_data->interrupts[i].reg,
+			interrupt_data->interrupts[i].packing);
+		if (interrupt_data->interrupts[i].packing == UNPACKED) {
+			value = interrupt_data->interrupts[i].index;
+		} else {
+			switch (interrupt_data->interrupts[i].packing) {
+			case PACK_0:
+				pack_shift = 0;
+				break;
+			case PACK_1:
+				pack_shift = interrupt_data->pack_width;
+				break;
+			case PACK_2:
+				pack_shift = 2 * interrupt_data->pack_width;
+				break;
+			case PACK_3:
+				pack_shift = 3 * interrupt_data->pack_width;
+				break;
+			default:
+				dev_dbg(gasket_dev->dev,
+					"Found interrupt description with "
+					"unknown enum %d\n",
+					interrupt_data->interrupts[i].packing);
+				return;
+			}
+
+			mask = ~(0xFFFF << pack_shift);
+			value = gasket_dev_read_64(
+					gasket_dev,
+					interrupt_data->interrupt_bar_index,
+					interrupt_data->interrupts[i].reg) &
+				mask;
+			value |= interrupt_data->interrupts[i].index
+				 << pack_shift;
+		}
+		gasket_dev_write_64(gasket_dev, value,
+				    interrupt_data->interrupt_bar_index,
+				    interrupt_data->interrupts[i].reg);
+	}
+}
+
+static irqreturn_t gasket_msix_interrupt_handler(int irq, void *dev_id)
+{
+	struct eventfd_ctx *ctx;
+	struct gasket_interrupt_data *interrupt_data = dev_id;
+	int interrupt = -1;
+	int i;
+
+	/* If this linear lookup is a problem, we can maintain a map/hash. */
+	for (i = 0; i < interrupt_data->num_interrupts; i++) {
+		if (interrupt_data->msix_entries[i].vector == irq) {
+			interrupt = interrupt_data->msix_entries[i].entry;
+			break;
+		}
+	}
+	if (interrupt == -1) {
+		pr_err("Received unknown irq %d\n", irq);
+		return IRQ_HANDLED;
+	}
+	trace_gasket_interrupt_event(interrupt_data->name, interrupt);
+
+	ctx = interrupt_data->eventfd_ctxs[interrupt];
+	if (ctx)
+		eventfd_signal(ctx, 1);
+
+	++(interrupt_data->interrupt_counts[interrupt]);
+
+	return IRQ_HANDLED;
+}
+
+static int gasket_interrupt_msix_init(
+	struct gasket_interrupt_data *interrupt_data)
+{
+	int ret = 1;
+	int i;
+
+	for (i = 0; i < interrupt_data->num_interrupts; i++) {
+		interrupt_data->msix_entries[i].entry = i;
+		interrupt_data->msix_entries[i].vector = 0;
+		interrupt_data->eventfd_ctxs[i] = NULL;
+	}
+
+	/* Retry MSIX_RETRY_COUNT times if not enough IRQs are available. */
+	for (i = 0; i < MSIX_RETRY_COUNT && ret > 0; i++)
+		ret = pci_enable_msix_exact(interrupt_data->pci_dev,
+					    interrupt_data->msix_entries,
+					    interrupt_data->num_interrupts);
+
+	if (ret)
+		return ret > 0 ? -EBUSY : ret;
+	interrupt_data->msix_configured = 1;
+
+	for (i = 0; i < interrupt_data->num_interrupts; i++) {
+		ret = request_irq(
+			interrupt_data->msix_entries[i].vector,
+			gasket_msix_interrupt_handler, 0, interrupt_data->name,
+			interrupt_data);
+
+		if (ret) {
+			dev_err(&interrupt_data->pci_dev->dev,
+				"Cannot get IRQ for interrupt %d, vector %d; "
+				"%d\n",
+				i, interrupt_data->msix_entries[i].vector, ret);
+			return ret;
+		}
+
+		interrupt_data->num_configured++;
+	}
+
+	return 0;
+}
+
+/*
+ * On QCM DragonBoard, we exit gasket_interrupt_msix_init() and kernel interrupt
+ * setup code with MSIX vectors masked. This is wrong because nothing else in
+ * the driver will normally touch the MSIX vectors.
+ *
+ * As a temporary hack, force unmasking there.
+ *
+ * TODO: Figure out why QCM kernel doesn't unmask the MSIX vectors, after
+ * gasket_interrupt_msix_init(), and remove this code.
+ */
+static void force_msix_interrupt_unmasking(struct gasket_dev *gasket_dev)
+{
+	int i;
+#define MSIX_VECTOR_SIZE 16
+#define MSIX_MASK_BIT_OFFSET 12
+#define APEX_BAR2_REG_KERNEL_HIB_MSIX_TABLE 0x46800
+	for (i = 0; i < gasket_dev->interrupt_data->num_configured; i++) {
+		/* Check if the MSIX vector is unmasked */
+		ulong location = APEX_BAR2_REG_KERNEL_HIB_MSIX_TABLE +
+				 MSIX_MASK_BIT_OFFSET + i * MSIX_VECTOR_SIZE;
+		u32 mask =
+			gasket_dev_read_32(
+				gasket_dev,
+				gasket_dev->interrupt_data->interrupt_bar_index,
+				location);
+		if (!(mask & 1))
+			continue;
+		/* Unmask the msix vector (clear 32 bits) */
+		gasket_dev_write_32(
+			gasket_dev, 0,
+			gasket_dev->interrupt_data->interrupt_bar_index,
+			location);
+	}
+#undef MSIX_VECTOR_SIZE
+#undef MSIX_MASK_BIT_OFFSET
+#undef APEX_BAR2_REG_KERNEL_HIB_MSIX_TABLE
+}
+
+static ssize_t interrupt_sysfs_show(
+	struct device *device, struct device_attribute *attr, char *buf)
+{
+	int i, ret;
+	ssize_t written = 0, total_written = 0;
+	struct gasket_interrupt_data *interrupt_data;
+	struct gasket_dev *gasket_dev;
+	struct gasket_sysfs_attribute *gasket_attr;
+	enum interrupt_sysfs_attribute_type sysfs_type;
+
+	gasket_dev = gasket_sysfs_get_device_data(device);
+	if (!gasket_dev) {
+		dev_dbg(device, "No sysfs mapping found for device\n");
+		return 0;
+	}
+
+	gasket_attr = gasket_sysfs_get_attr(device, attr);
+	if (!gasket_attr) {
+		dev_dbg(device, "No sysfs attr data found for device\n");
+		gasket_sysfs_put_device_data(device, gasket_dev);
+		return 0;
+	}
+
+	sysfs_type = (enum interrupt_sysfs_attribute_type)
+		gasket_attr->data.attr_type;
+	interrupt_data = gasket_dev->interrupt_data;
+	switch (sysfs_type) {
+	case ATTR_INTERRUPT_COUNTS:
+		for (i = 0; i < interrupt_data->num_interrupts; ++i) {
+			written =
+				scnprintf(buf, PAGE_SIZE - total_written,
+					  "0x%02x: %ld\n", i,
+					  interrupt_data->interrupt_counts[i]);
+			total_written += written;
+			buf += written;
+		}
+		ret = total_written;
+		break;
+	default:
+		dev_dbg(gasket_dev->dev, "Unknown attribute: %s\n",
+			attr->attr.name);
+		ret = 0;
+		break;
+	}
+
+	gasket_sysfs_put_attr(device, gasket_attr);
+	gasket_sysfs_put_device_data(device, gasket_dev);
+	return ret;
+}
+
 static struct gasket_sysfs_attribute interrupt_sysfs_attrs[] = {
 	GASKET_SYSFS_RO(
 		interrupt_counts, interrupt_sysfs_show, ATTR_INTERRUPT_COUNTS),
 	GASKET_END_OF_ATTR_ARRAY,
 };
 
-static void gasket_interrupt_setup(struct gasket_dev *gasket_dev);
-
-/* MSIX init and cleanup. */
-static int gasket_interrupt_msix_init(
-	struct gasket_interrupt_data *interrupt_data);
-static void gasket_interrupt_msix_cleanup(
-	struct gasket_interrupt_data *interrupt_data);
-static void force_msix_interrupt_unmasking(struct gasket_dev *gasket_dev);
-
 int gasket_interrupt_init(
 	struct gasket_dev *gasket_dev, const char *name, int type,
 	const struct gasket_interrupt_desc *interrupts,
@@ -181,48 +408,6 @@ int gasket_interrupt_init(
 	return 0;
 }
 
-static int gasket_interrupt_msix_init(
-	struct gasket_interrupt_data *interrupt_data)
-{
-	int ret = 1;
-	int i;
-
-	for (i = 0; i < interrupt_data->num_interrupts; i++) {
-		interrupt_data->msix_entries[i].entry = i;
-		interrupt_data->msix_entries[i].vector = 0;
-		interrupt_data->eventfd_ctxs[i] = NULL;
-	}
-
-	/* Retry MSIX_RETRY_COUNT times if not enough IRQs are available. */
-	for (i = 0; i < MSIX_RETRY_COUNT && ret > 0; i++)
-		ret = pci_enable_msix_exact(interrupt_data->pci_dev,
-					    interrupt_data->msix_entries,
-					    interrupt_data->num_interrupts);
-
-	if (ret)
-		return ret > 0 ? -EBUSY : ret;
-	interrupt_data->msix_configured = 1;
-
-	for (i = 0; i < interrupt_data->num_interrupts; i++) {
-		ret = request_irq(
-			interrupt_data->msix_entries[i].vector,
-			gasket_msix_interrupt_handler, 0, interrupt_data->name,
-			interrupt_data);
-
-		if (ret) {
-			dev_err(&interrupt_data->pci_dev->dev,
-				"Cannot get IRQ for interrupt %d, vector %d; "
-				"%d\n",
-				i, interrupt_data->msix_entries[i].vector, ret);
-			return ret;
-		}
-
-		interrupt_data->num_configured++;
-	}
-
-	return 0;
-}
-
 static void gasket_interrupt_msix_cleanup(
 	struct gasket_interrupt_data *interrupt_data)
 {
@@ -238,44 +423,6 @@ static void gasket_interrupt_msix_cleanup(
 	interrupt_data->msix_configured = 0;
 }
 
-/*
- * On QCM DragonBoard, we exit gasket_interrupt_msix_init() and kernel interrupt
- * setup code with MSIX vectors masked. This is wrong because nothing else in
- * the driver will normally touch the MSIX vectors.
- *
- * As a temporary hack, force unmasking there.
- *
- * TODO: Figure out why QCM kernel doesn't unmask the MSIX vectors, after
- * gasket_interrupt_msix_init(), and remove this code.
- */
-static void force_msix_interrupt_unmasking(struct gasket_dev *gasket_dev)
-{
-	int i;
-#define MSIX_VECTOR_SIZE 16
-#define MSIX_MASK_BIT_OFFSET 12
-#define APEX_BAR2_REG_KERNEL_HIB_MSIX_TABLE 0x46800
-	for (i = 0; i < gasket_dev->interrupt_data->num_configured; i++) {
-		/* Check if the MSIX vector is unmasked */
-		ulong location = APEX_BAR2_REG_KERNEL_HIB_MSIX_TABLE +
-				 MSIX_MASK_BIT_OFFSET + i * MSIX_VECTOR_SIZE;
-		u32 mask =
-			gasket_dev_read_32(
-				gasket_dev,
-				gasket_dev->interrupt_data->interrupt_bar_index,
-				location);
-		if (!(mask & 1))
-			continue;
-		/* Unmask the msix vector (clear 32 bits) */
-		gasket_dev_write_32(
-			gasket_dev, 0,
-			gasket_dev->interrupt_data->interrupt_bar_index,
-			location);
-	}
-#undef MSIX_VECTOR_SIZE
-#undef MSIX_MASK_BIT_OFFSET
-#undef APEX_BAR2_REG_KERNEL_HIB_MSIX_TABLE
-}
-
 int gasket_interrupt_reinit(struct gasket_dev *gasket_dev)
 {
 	int ret;
@@ -327,89 +474,6 @@ int gasket_interrupt_reset_counts(struct gasket_dev *gasket_dev)
 	return 0;
 }
 
-/* Set up device registers for interrupt handling. */
-static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
-{
-	int i;
-	int pack_shift;
-	ulong mask;
-	ulong value;
-	struct gasket_interrupt_data *interrupt_data =
-		gasket_dev->interrupt_data;
-
-	if (!interrupt_data) {
-		dev_dbg(gasket_dev->dev, "Interrupt data is not initialized\n");
-		return;
-	}
-
-	dev_dbg(gasket_dev->dev, "Running interrupt setup\n");
-
-	if (interrupt_data->type == PLATFORM_WIRE ||
-	    interrupt_data->type == PCI_MSI) {
-		/* Nothing needs to be done for platform or PCI devices. */
-		return;
-	}
-
-	if (interrupt_data->type != PCI_MSIX) {
-		dev_dbg(gasket_dev->dev,
-			"Cannot handle unsupported interrupt type %d\n",
-			interrupt_data->type);
-		return;
-	}
-
-	/* Setup the MSIX table. */
-
-	for (i = 0; i < interrupt_data->num_interrupts; i++) {
-		/*
-		 * If the interrupt is not packed, we can write the index into
-		 * the register directly. If not, we need to deal with a read-
-		 * modify-write and shift based on the packing index.
-		 */
-		dev_dbg(gasket_dev->dev,
-			"Setting up interrupt index %d with index 0x%llx and "
-			"packing %d\n",
-			interrupt_data->interrupts[i].index,
-			interrupt_data->interrupts[i].reg,
-			interrupt_data->interrupts[i].packing);
-		if (interrupt_data->interrupts[i].packing == UNPACKED) {
-			value = interrupt_data->interrupts[i].index;
-		} else {
-			switch (interrupt_data->interrupts[i].packing) {
-			case PACK_0:
-				pack_shift = 0;
-				break;
-			case PACK_1:
-				pack_shift = interrupt_data->pack_width;
-				break;
-			case PACK_2:
-				pack_shift = 2 * interrupt_data->pack_width;
-				break;
-			case PACK_3:
-				pack_shift = 3 * interrupt_data->pack_width;
-				break;
-			default:
-				dev_dbg(gasket_dev->dev,
-					"Found interrupt description with "
-					"unknown enum %d\n",
-					interrupt_data->interrupts[i].packing);
-				return;
-			}
-
-			mask = ~(0xFFFF << pack_shift);
-			value = gasket_dev_read_64(
-					gasket_dev,
-					interrupt_data->interrupt_bar_index,
-					interrupt_data->interrupts[i].reg) &
-				mask;
-			value |= interrupt_data->interrupts[i].index
-				 << pack_shift;
-		}
-		gasket_dev_write_64(gasket_dev, value,
-				    interrupt_data->interrupt_bar_index,
-				    interrupt_data->interrupts[i].reg);
-	}
-}
-
 /* See gasket_interrupt.h for description. */
 void gasket_interrupt_cleanup(struct gasket_dev *gasket_dev)
 {
@@ -489,82 +553,3 @@ int gasket_interrupt_clear_eventfd(
 	interrupt_data->eventfd_ctxs[interrupt] = NULL;
 	return 0;
 }
-
-static ssize_t interrupt_sysfs_show(
-	struct device *device, struct device_attribute *attr, char *buf)
-{
-	int i, ret;
-	ssize_t written = 0, total_written = 0;
-	struct gasket_interrupt_data *interrupt_data;
-	struct gasket_dev *gasket_dev;
-	struct gasket_sysfs_attribute *gasket_attr;
-	enum interrupt_sysfs_attribute_type sysfs_type;
-
-	gasket_dev = gasket_sysfs_get_device_data(device);
-	if (!gasket_dev) {
-		dev_dbg(device, "No sysfs mapping found for device\n");
-		return 0;
-	}
-
-	gasket_attr = gasket_sysfs_get_attr(device, attr);
-	if (!gasket_attr) {
-		dev_dbg(device, "No sysfs attr data found for device\n");
-		gasket_sysfs_put_device_data(device, gasket_dev);
-		return 0;
-	}
-
-	sysfs_type = (enum interrupt_sysfs_attribute_type)
-		gasket_attr->data.attr_type;
-	interrupt_data = gasket_dev->interrupt_data;
-	switch (sysfs_type) {
-	case ATTR_INTERRUPT_COUNTS:
-		for (i = 0; i < interrupt_data->num_interrupts; ++i) {
-			written =
-				scnprintf(buf, PAGE_SIZE - total_written,
-					  "0x%02x: %ld\n", i,
-					  interrupt_data->interrupt_counts[i]);
-			total_written += written;
-			buf += written;
-		}
-		ret = total_written;
-		break;
-	default:
-		dev_dbg(gasket_dev->dev, "Unknown attribute: %s\n",
-			attr->attr.name);
-		ret = 0;
-		break;
-	}
-
-	gasket_sysfs_put_attr(device, gasket_attr);
-	gasket_sysfs_put_device_data(device, gasket_dev);
-	return ret;
-}
-
-static irqreturn_t gasket_msix_interrupt_handler(int irq, void *dev_id)
-{
-	struct eventfd_ctx *ctx;
-	struct gasket_interrupt_data *interrupt_data = dev_id;
-	int interrupt = -1;
-	int i;
-
-	/* If this linear lookup is a problem, we can maintain a map/hash. */
-	for (i = 0; i < interrupt_data->num_interrupts; i++) {
-		if (interrupt_data->msix_entries[i].vector == irq) {
-			interrupt = interrupt_data->msix_entries[i].entry;
-			break;
-		}
-	}
-	if (interrupt == -1) {
-		pr_err("Received unknown irq %d\n", irq);
-		return IRQ_HANDLED;
-	}
-	trace_gasket_interrupt_event(interrupt_data->name, interrupt);
-
-	ctx = interrupt_data->eventfd_ctxs[interrupt];
-	if (ctx)
-		eventfd_signal(ctx, 1);
-
-	++(interrupt_data->interrupt_counts[interrupt]);
-
-	return IRQ_HANDLED;
-}

commit e4c4afa8db90155ad1ed5c597a1bf63994961ca9
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Jul 29 12:36:42 2018 -0700

    staging: gasket: interrupt: simplify comments for static functions
    
    Static functions don't need kernel doc formatting, can be simplified.
    Reformat comments that can be single-line.  Remove extraneous text.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index 3be8e24c126d..27fde991edc6 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -87,13 +87,6 @@ static struct gasket_sysfs_attribute interrupt_sysfs_attrs[] = {
 	GASKET_END_OF_ATTR_ARRAY,
 };
 
-/*
- * Set up device registers for interrupt handling.
- * @gasket_dev: The Gasket information structure for this device.
- *
- * Sets up the device registers with the correct indices for the relevant
- * interrupts.
- */
 static void gasket_interrupt_setup(struct gasket_dev *gasket_dev);
 
 /* MSIX init and cleanup. */
@@ -334,13 +327,7 @@ int gasket_interrupt_reset_counts(struct gasket_dev *gasket_dev)
 	return 0;
 }
 
-/*
- * Set up device registers for interrupt handling.
- * @gasket_dev: The Gasket information structure for this device.
- *
- * Sets up the device registers with the correct indices for the relevant
- * interrupts.
- */
+/* Set up device registers for interrupt handling. */
 static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 {
 	int i;
@@ -553,9 +540,6 @@ static ssize_t interrupt_sysfs_show(
 	return ret;
 }
 
-/*
- * MSIX interrupt handler, used with PCI driver.
- */
 static irqreturn_t gasket_msix_interrupt_handler(int irq, void *dev_id)
 {
 	struct eventfd_ctx *ctx;

commit 952b02a281764f41491759e529e62a59628133b5
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 26 20:07:30 2018 -0700

    staging: gasket: interrupt: convert to standard logging
    
    Convert gasket logging calls to standard functions.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index 2b8c26d06533..3be8e24c126d 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -5,9 +5,10 @@
 
 #include "gasket_constants.h"
 #include "gasket_core.h"
-#include "gasket_logging.h"
 #include "gasket_sysfs.h"
+#include <linux/device.h>
 #include <linux/interrupt.h>
+#include <linux/printk.h>
 #include <linux/version.h>
 #ifdef GASKET_KERNEL_TRACE_SUPPORT
 #define CREATE_TRACE_POINTS
@@ -165,8 +166,8 @@ int gasket_interrupt_init(
 	case PCI_MSI:
 	case PLATFORM_WIRE:
 	default:
-		gasket_nodev_error(
-			"Cannot handle unsupported interrupt type %d.",
+		dev_err(gasket_dev->dev,
+			"Cannot handle unsupported interrupt type %d\n",
 			interrupt_data->type);
 		ret = -EINVAL;
 	};
@@ -175,8 +176,8 @@ int gasket_interrupt_init(
 		/* Failing to setup interrupts will cause the device to report
 		 * GASKET_STATUS_LAMED. But it is not fatal.
 		 */
-		gasket_log_warn(
-			gasket_dev, "Couldn't initialize interrupts: %d", ret);
+		dev_warn(gasket_dev->dev,
+			 "Couldn't initialize interrupts: %d\n", ret);
 		return 0;
 	}
 
@@ -216,7 +217,7 @@ static int gasket_interrupt_msix_init(
 			interrupt_data);
 
 		if (ret) {
-			gasket_nodev_error(
+			dev_err(&interrupt_data->pci_dev->dev,
 				"Cannot get IRQ for interrupt %d, vector %d; "
 				"%d\n",
 				i, interrupt_data->msix_entries[i].vector, ret);
@@ -287,9 +288,8 @@ int gasket_interrupt_reinit(struct gasket_dev *gasket_dev)
 	int ret;
 
 	if (!gasket_dev->interrupt_data) {
-		gasket_log_debug(
-			gasket_dev,
-			"Attempted to reinit uninitialized interrupt data.");
+		dev_dbg(gasket_dev->dev,
+			"Attempted to reinit uninitialized interrupt data\n");
 		return -EINVAL;
 	}
 
@@ -305,8 +305,8 @@ int gasket_interrupt_reinit(struct gasket_dev *gasket_dev)
 	case PCI_MSI:
 	case PLATFORM_WIRE:
 	default:
-		gasket_nodev_debug(
-			"Cannot handle unsupported interrupt type %d.",
+		dev_dbg(gasket_dev->dev,
+			"Cannot handle unsupported interrupt type %d\n",
 			gasket_dev->interrupt_data->type);
 		ret = -EINVAL;
 	};
@@ -315,7 +315,7 @@ int gasket_interrupt_reinit(struct gasket_dev *gasket_dev)
 		/* Failing to setup MSIx will cause the device
 		 * to report GASKET_STATUS_LAMED, but is not fatal.
 		 */
-		gasket_log_warn(gasket_dev, "Couldn't init msix: %d", ret);
+		dev_warn(gasket_dev->dev, "Couldn't init msix: %d\n", ret);
 		return 0;
 	}
 
@@ -327,7 +327,7 @@ int gasket_interrupt_reinit(struct gasket_dev *gasket_dev)
 /* See gasket_interrupt.h for description. */
 int gasket_interrupt_reset_counts(struct gasket_dev *gasket_dev)
 {
-	gasket_log_debug(gasket_dev, "Clearing interrupt counts.");
+	dev_dbg(gasket_dev->dev, "Clearing interrupt counts\n");
 	memset(gasket_dev->interrupt_data->interrupt_counts, 0,
 	       gasket_dev->interrupt_data->num_interrupts *
 			sizeof(*gasket_dev->interrupt_data->interrupt_counts));
@@ -351,12 +351,11 @@ static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 		gasket_dev->interrupt_data;
 
 	if (!interrupt_data) {
-		gasket_log_debug(
-			gasket_dev, "Interrupt data is not initialized.");
+		dev_dbg(gasket_dev->dev, "Interrupt data is not initialized\n");
 		return;
 	}
 
-	gasket_log_debug(gasket_dev, "Running interrupt setup.");
+	dev_dbg(gasket_dev->dev, "Running interrupt setup\n");
 
 	if (interrupt_data->type == PLATFORM_WIRE ||
 	    interrupt_data->type == PCI_MSI) {
@@ -365,8 +364,8 @@ static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 	}
 
 	if (interrupt_data->type != PCI_MSIX) {
-		gasket_nodev_debug(
-			"Cannot handle unsupported interrupt type %d.",
+		dev_dbg(gasket_dev->dev,
+			"Cannot handle unsupported interrupt type %d\n",
 			interrupt_data->type);
 		return;
 	}
@@ -379,10 +378,9 @@ static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 		 * the register directly. If not, we need to deal with a read-
 		 * modify-write and shift based on the packing index.
 		 */
-		gasket_log_debug(
-			gasket_dev,
+		dev_dbg(gasket_dev->dev,
 			"Setting up interrupt index %d with index 0x%llx and "
-			"packing %d",
+			"packing %d\n",
 			interrupt_data->interrupts[i].index,
 			interrupt_data->interrupts[i].reg,
 			interrupt_data->interrupts[i].packing);
@@ -403,9 +401,9 @@ static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 				pack_shift = 3 * interrupt_data->pack_width;
 				break;
 			default:
-				gasket_nodev_debug(
+				dev_dbg(gasket_dev->dev,
 					"Found interrupt description with "
-					"unknown enum %d.",
+					"unknown enum %d\n",
 					interrupt_data->interrupts[i].packing);
 				return;
 			}
@@ -445,8 +443,8 @@ void gasket_interrupt_cleanup(struct gasket_dev *gasket_dev)
 	case PCI_MSI:
 	case PLATFORM_WIRE:
 	default:
-		gasket_nodev_debug(
-			"Cannot handle unsupported interrupt type %d.",
+		dev_dbg(gasket_dev->dev,
+			"Cannot handle unsupported interrupt type %d\n",
 			interrupt_data->type);
 	};
 
@@ -460,18 +458,19 @@ void gasket_interrupt_cleanup(struct gasket_dev *gasket_dev)
 int gasket_interrupt_system_status(struct gasket_dev *gasket_dev)
 {
 	if (!gasket_dev->interrupt_data) {
-		gasket_nodev_debug("Interrupt data is null.");
+		dev_dbg(gasket_dev->dev, "Interrupt data is null\n");
 		return GASKET_STATUS_DEAD;
 	}
 
 	if (!gasket_dev->interrupt_data->msix_configured) {
-		gasket_nodev_debug("Interrupt not initialized.");
+		dev_dbg(gasket_dev->dev, "Interrupt not initialized\n");
 		return GASKET_STATUS_LAMED;
 	}
 
 	if (gasket_dev->interrupt_data->num_configured !=
 		gasket_dev->interrupt_data->num_interrupts) {
-		gasket_nodev_debug("Not all interrupts were configured.");
+		dev_dbg(gasket_dev->dev,
+			"Not all interrupts were configured\n");
 		return GASKET_STATUS_LAMED;
 	}
 
@@ -516,15 +515,13 @@ static ssize_t interrupt_sysfs_show(
 
 	gasket_dev = gasket_sysfs_get_device_data(device);
 	if (!gasket_dev) {
-		gasket_nodev_debug(
-			"No sysfs mapping found for device 0x%p", device);
+		dev_dbg(device, "No sysfs mapping found for device\n");
 		return 0;
 	}
 
 	gasket_attr = gasket_sysfs_get_attr(device, attr);
 	if (!gasket_attr) {
-		gasket_nodev_debug(
-			"No sysfs attr data found for device 0x%p", device);
+		dev_dbg(device, "No sysfs attr data found for device\n");
 		gasket_sysfs_put_device_data(device, gasket_dev);
 		return 0;
 	}
@@ -545,8 +542,8 @@ static ssize_t interrupt_sysfs_show(
 		ret = total_written;
 		break;
 	default:
-		gasket_log_debug(
-			gasket_dev, "Unknown attribute: %s", attr->attr.name);
+		dev_dbg(gasket_dev->dev, "Unknown attribute: %s\n",
+			attr->attr.name);
 		ret = 0;
 		break;
 	}
@@ -574,7 +571,7 @@ static irqreturn_t gasket_msix_interrupt_handler(int irq, void *dev_id)
 		}
 	}
 	if (interrupt == -1) {
-		gasket_nodev_error("Received unknown irq %d", irq);
+		pr_err("Received unknown irq %d\n", irq);
 		return IRQ_HANDLED;
 	}
 	trace_gasket_interrupt_event(interrupt_data->name, interrupt);

commit 040c626008e9e2f332caf16f25f2ca708cfcc480
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sat Jul 21 06:35:03 2018 -0700

    staging: gasket: interrupts: convert various logs to debug level
    
    Debugging information is improperly logged at non-debug log level in a
    number of places, and some logs regarding error conditions may be
    generated too frequently, such that these could cause performance
    problems and/or obscure other logs.  Convert these to debug log level.
    
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index d096ce73cc8b..2b8c26d06533 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -287,7 +287,7 @@ int gasket_interrupt_reinit(struct gasket_dev *gasket_dev)
 	int ret;
 
 	if (!gasket_dev->interrupt_data) {
-		gasket_log_error(
+		gasket_log_debug(
 			gasket_dev,
 			"Attempted to reinit uninitialized interrupt data.");
 		return -EINVAL;
@@ -305,7 +305,7 @@ int gasket_interrupt_reinit(struct gasket_dev *gasket_dev)
 	case PCI_MSI:
 	case PLATFORM_WIRE:
 	default:
-		gasket_nodev_error(
+		gasket_nodev_debug(
 			"Cannot handle unsupported interrupt type %d.",
 			gasket_dev->interrupt_data->type);
 		ret = -EINVAL;
@@ -351,7 +351,7 @@ static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 		gasket_dev->interrupt_data;
 
 	if (!interrupt_data) {
-		gasket_log_error(
+		gasket_log_debug(
 			gasket_dev, "Interrupt data is not initialized.");
 		return;
 	}
@@ -365,7 +365,7 @@ static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 	}
 
 	if (interrupt_data->type != PCI_MSIX) {
-		gasket_nodev_error(
+		gasket_nodev_debug(
 			"Cannot handle unsupported interrupt type %d.",
 			interrupt_data->type);
 		return;
@@ -403,7 +403,7 @@ static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 				pack_shift = 3 * interrupt_data->pack_width;
 				break;
 			default:
-				gasket_nodev_error(
+				gasket_nodev_debug(
 					"Found interrupt description with "
 					"unknown enum %d.",
 					interrupt_data->interrupts[i].packing);
@@ -445,7 +445,7 @@ void gasket_interrupt_cleanup(struct gasket_dev *gasket_dev)
 	case PCI_MSI:
 	case PLATFORM_WIRE:
 	default:
-		gasket_nodev_error(
+		gasket_nodev_debug(
 			"Cannot handle unsupported interrupt type %d.",
 			interrupt_data->type);
 	};
@@ -460,18 +460,18 @@ void gasket_interrupt_cleanup(struct gasket_dev *gasket_dev)
 int gasket_interrupt_system_status(struct gasket_dev *gasket_dev)
 {
 	if (!gasket_dev->interrupt_data) {
-		gasket_nodev_info("Interrupt data is null.");
+		gasket_nodev_debug("Interrupt data is null.");
 		return GASKET_STATUS_DEAD;
 	}
 
 	if (!gasket_dev->interrupt_data->msix_configured) {
-		gasket_nodev_info("Interrupt not initialized.");
+		gasket_nodev_debug("Interrupt not initialized.");
 		return GASKET_STATUS_LAMED;
 	}
 
 	if (gasket_dev->interrupt_data->num_configured !=
 		gasket_dev->interrupt_data->num_interrupts) {
-		gasket_nodev_info("Not all interrupts were configured.");
+		gasket_nodev_debug("Not all interrupts were configured.");
 		return GASKET_STATUS_LAMED;
 	}
 
@@ -516,14 +516,14 @@ static ssize_t interrupt_sysfs_show(
 
 	gasket_dev = gasket_sysfs_get_device_data(device);
 	if (!gasket_dev) {
-		gasket_nodev_error(
+		gasket_nodev_debug(
 			"No sysfs mapping found for device 0x%p", device);
 		return 0;
 	}
 
 	gasket_attr = gasket_sysfs_get_attr(device, attr);
 	if (!gasket_attr) {
-		gasket_nodev_error(
+		gasket_nodev_debug(
 			"No sysfs attr data found for device 0x%p", device);
 		gasket_sysfs_put_device_data(device, gasket_dev);
 		return 0;
@@ -545,7 +545,7 @@ static ssize_t interrupt_sysfs_show(
 		ret = total_written;
 		break;
 	default:
-		gasket_log_error(
+		gasket_log_debug(
 			gasket_dev, "Unknown attribute: %s", attr->attr.name);
 		ret = 0;
 		break;

commit 4c89a44dd907644743fe24ad92fdf1f15889fb60
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jul 13 12:05:54 2018 +0200

    staging: gasket: remove gasket_interrupt_get_msix_entries()
    
    No one calls it, it is claimed to be "legacy", whatever that means, so
    just remove the dead code.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index 691996d84cad..d096ce73cc8b 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -504,12 +504,6 @@ int gasket_interrupt_clear_eventfd(
 	return 0;
 }
 
-struct msix_entry *gasket_interrupt_get_msix_entries(
-	struct gasket_interrupt_data *interrupt_data)
-{
-	return interrupt_data->msix_entries;
-}
-
 static ssize_t interrupt_sysfs_show(
 	struct device *device, struct device_attribute *attr, char *buf)
 {

commit b19409549bffc4e5b4e3940d825cec5edb606959
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jul 13 12:05:53 2018 +0200

    staging: gasket: remove gasket_interrupt_trigger_eventfd()
    
    No one calls it, so just remove the dead code.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index 3ea168fd9b51..691996d84cad 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -504,18 +504,6 @@ int gasket_interrupt_clear_eventfd(
 	return 0;
 }
 
-int gasket_interrupt_trigger_eventfd(
-	struct gasket_interrupt_data *interrupt_data, int interrupt)
-{
-	struct eventfd_ctx *ctx = interrupt_data->eventfd_ctxs[interrupt];
-
-	if (!ctx)
-		return -EINVAL;
-
-	eventfd_signal(ctx, 1);
-	return 0;
-}
-
 struct msix_entry *gasket_interrupt_get_msix_entries(
 	struct gasket_interrupt_data *interrupt_data)
 {

commit f09b915b37ed827854d904b50dccd531da8dcc99
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jul 13 12:05:52 2018 +0200

    staging: gasket: remove gasket_interrupt_get_eventfd_ctxs()
    
    It is exported, yet no one calls it so just remove the dead code.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index 922ffd5836cd..3ea168fd9b51 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -522,13 +522,6 @@ struct msix_entry *gasket_interrupt_get_msix_entries(
 	return interrupt_data->msix_entries;
 }
 
-struct eventfd_ctx **gasket_interrupt_get_eventfd_ctxs(
-	struct gasket_interrupt_data *interrupt_data)
-{
-	return interrupt_data->eventfd_ctxs;
-}
-EXPORT_SYMBOL(gasket_interrupt_get_eventfd_ctxs);
-
 static ssize_t interrupt_sysfs_show(
 	struct device *device, struct device_attribute *attr, char *buf)
 {

commit 7faa7d57b2f0fe4e1f2ac3501d343e9429ce0a32
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jul 13 12:05:51 2018 +0200

    staging: gasket: remove pointless gasket_interrupt_pause()
    
    gasket_interrupt_pause() does nothing, and no one calls it, so remove it
    as it is dead-weight.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index faaabdce4720..922ffd5836cd 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -426,24 +426,6 @@ static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
 }
 
 /* See gasket_interrupt.h for description. */
-void gasket_interrupt_pause(struct gasket_dev *gasket_dev, int enable_pause)
-{
-	WARN_ON(!gasket_dev);
-
-	if (!gasket_dev->interrupt_data)
-		return; /* nothing to do */
-
-	if (gasket_dev->interrupt_data->type == PCI_MSI ||
-	    gasket_dev->interrupt_data->type == PCI_MSIX) {
-		/* Nothing to be done for MSI/MSIX just yet. */
-	}
-
-	if (gasket_dev->interrupt_data->type == PLATFORM_WIRE) {
-		/* Nothing to be done for PLATFORM_WIRE */
-	}
-}
-EXPORT_SYMBOL(gasket_interrupt_pause);
-
 void gasket_interrupt_cleanup(struct gasket_dev *gasket_dev)
 {
 	struct gasket_interrupt_data *interrupt_data =

commit bf9c7a8673831acd67ad4a92b6acd85ffcde174c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 11 13:39:11 2018 +0200

    staging: gasket: remove redundant license information
    
    Now that the SPDX tag is in all gasket files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index 28bb80de22bf..faaabdce4720 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -1,15 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright (C) 2018 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
+/* Copyright (C) 2018 Google, Inc. */
 
 #include "gasket_interrupt.h"
 

commit 2dec0644e0c8083e0a9d3bbdd11aad2d850859e9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 11 13:39:10 2018 +0200

    staging: gasket: add SPDX identifiers to all files.
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the all of the staging gasket files to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index d1461b36f091..28bb80de22bf 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /* Copyright (C) 2018 Google, Inc.
  *
  * This software is licensed under the terms of the GNU General Public

commit 7cc6dfd076e84359a96a851c41ac8dc696565a3f
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jul 6 11:38:25 2018 +0300

    Staging: Gasket: fix a couple off by one bugs
    
    The > should be >= or we end up writing one element beyond the end of
    the interrupt_data->eventfd_ctxs[] array.
    
    Fixes: 9a69f5087ccc ("drivers/staging: Gasket driver framework + Apex driver")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index 1fd7bee5db2f..d1461b36f091 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -514,7 +514,7 @@ int gasket_interrupt_set_eventfd(
 	if (IS_ERR(ctx))
 		return PTR_ERR(ctx);
 
-	if (interrupt < 0 || interrupt > interrupt_data->num_interrupts)
+	if (interrupt < 0 || interrupt >= interrupt_data->num_interrupts)
 		return -EINVAL;
 
 	interrupt_data->eventfd_ctxs[interrupt] = ctx;
@@ -524,7 +524,7 @@ int gasket_interrupt_set_eventfd(
 int gasket_interrupt_clear_eventfd(
 	struct gasket_interrupt_data *interrupt_data, int interrupt)
 {
-	if (interrupt < 0 || interrupt > interrupt_data->num_interrupts)
+	if (interrupt < 0 || interrupt >= interrupt_data->num_interrupts)
 		return -EINVAL;
 
 	interrupt_data->eventfd_ctxs[interrupt] = NULL;

commit 9f2378d94d0f026389fff351848f2adc484650fe
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 4 10:31:25 2018 -0700

    drivers/staging/gasket: Use 2-factor allocator calls
    
    As already done treewide, switch from open-coded multiplication to using
    2-factor allocator helpers.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
index b74eefe41d72..1fd7bee5db2f 100644
--- a/drivers/staging/gasket/gasket_interrupt.c
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -136,23 +136,26 @@ int gasket_interrupt_init(
 	interrupt_data->wire_interrupt_offsets = wire_int_offsets;
 
 	/* Allocate all dynamic structures. */
-	interrupt_data->msix_entries = kzalloc(
-		sizeof(struct msix_entry) * num_interrupts, GFP_KERNEL);
+	interrupt_data->msix_entries = kcalloc(num_interrupts,
+					       sizeof(struct msix_entry),
+					       GFP_KERNEL);
 	if (!interrupt_data->msix_entries) {
 		kfree(interrupt_data);
 		return -ENOMEM;
 	}
 
-	interrupt_data->eventfd_ctxs = kzalloc(
-		sizeof(struct eventfd_ctx *) * num_interrupts, GFP_KERNEL);
+	interrupt_data->eventfd_ctxs = kcalloc(num_interrupts,
+					       sizeof(struct eventfd_ctx *),
+					       GFP_KERNEL);
 	if (!interrupt_data->eventfd_ctxs) {
 		kfree(interrupt_data->msix_entries);
 		kfree(interrupt_data);
 		return -ENOMEM;
 	}
 
-	interrupt_data->interrupt_counts = kzalloc(
-		sizeof(ulong) * num_interrupts, GFP_KERNEL);
+	interrupt_data->interrupt_counts = kcalloc(num_interrupts,
+						   sizeof(ulong),
+						   GFP_KERNEL);
 	if (!interrupt_data->interrupt_counts) {
 		kfree(interrupt_data->eventfd_ctxs);
 		kfree(interrupt_data->msix_entries);

commit 9a69f5087ccc20bb411025decab455836df04168
Author: Simon Que <sque@chromium.org>
Date:   Fri Jun 29 22:49:38 2018 -0400

    drivers/staging: Gasket driver framework + Apex driver
    
    The Gasket (Google ASIC Software, Kernel Extensions, and Tools) kernel
    framework is a generic, flexible system that supports thin kernel
    drivers. Gasket kernel drivers are expected to handle opening and
    closing devices, mmap'ing BAR space as requested, a small selection of
    ioctls, and handling page table translation (covered below). Any other
    functions should be handled by userspace code.
    
    The Gasket common module is not enough to run a device. In order to
    customize the Gasket code for a given piece of hardware, a device
    specific module must be created. At a minimum, this module must define a
    struct gasket_driver_desc containing the device-specific data for use by
    the framework; in addition, the module must declare an __init function
    that calls gasket_register_device with the module's gasket_driver_desc
    struct. Finally, the driver must define an exit function that calls
    gasket_unregister_device with the module's gasket_driver_desc struct.
    
    One of the core assumptions of the Gasket framework is that precisely
    one process is allowed to have an open write handle to the device node
    at any given time. (That process may, once it has one write handle, open
    any number of additional write handles.) This is accomplished by
    tracking open and close data for each driver instance.
    
    Signed-off-by: Rob Springer <rspringer@google.com>
    Signed-off-by: John Joseph <jnjoseph@google.com>
    Signed-off-by: Simon Que <sque@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_interrupt.c b/drivers/staging/gasket/gasket_interrupt.c
new file mode 100644
index 000000000000..b74eefe41d72
--- /dev/null
+++ b/drivers/staging/gasket/gasket_interrupt.c
@@ -0,0 +1,638 @@
+/* Copyright (C) 2018 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "gasket_interrupt.h"
+
+#include "gasket_constants.h"
+#include "gasket_core.h"
+#include "gasket_logging.h"
+#include "gasket_sysfs.h"
+#include <linux/interrupt.h>
+#include <linux/version.h>
+#ifdef GASKET_KERNEL_TRACE_SUPPORT
+#define CREATE_TRACE_POINTS
+#include <trace/events/gasket_interrupt.h>
+#else
+#define trace_gasket_interrupt_event(x, ...)
+#endif
+/* Retry attempts if the requested number of interrupts aren't available. */
+#define MSIX_RETRY_COUNT 3
+
+/* Instance interrupt management data. */
+struct gasket_interrupt_data {
+	/* The name associated with this interrupt data. */
+	const char *name;
+
+	/* Interrupt type. See gasket_interrupt_type in gasket_core.h */
+	int type;
+
+	/* The PCI device [if any] associated with the owning device. */
+	struct pci_dev *pci_dev;
+
+	/* Set to 1 if MSI-X has successfully been configred, 0 otherwise. */
+	int msix_configured;
+
+	/* The number of interrupts requested by the owning device. */
+	int num_interrupts;
+
+	/* A pointer to the interrupt descriptor struct for this device. */
+	const struct gasket_interrupt_desc *interrupts;
+
+	/* The index of the bar into which interrupts should be mapped. */
+	int interrupt_bar_index;
+
+	/* The width of a single interrupt in a packed interrupt register. */
+	int pack_width;
+
+	/* offset of wire interrupt registers */
+	const struct gasket_wire_interrupt_offsets *wire_interrupt_offsets;
+
+	/*
+	 * Design-wise, these elements should be bundled together, but
+	 * pci_enable_msix's interface requires that they be managed
+	 * individually (requires array of struct msix_entry).
+	 */
+
+	/* The number of successfully configured interrupts. */
+	int num_configured;
+
+	/* The MSI-X data for each requested/configured interrupt. */
+	struct msix_entry *msix_entries;
+
+	/* The eventfd "callback" data for each interrupt. */
+	struct eventfd_ctx **eventfd_ctxs;
+
+	/* The number of times each interrupt has been called. */
+	ulong *interrupt_counts;
+
+	/* Linux IRQ number. */
+	int irq;
+};
+
+/* Function definitions. */
+static ssize_t interrupt_sysfs_show(
+	struct device *device, struct device_attribute *attr, char *buf);
+
+static irqreturn_t gasket_msix_interrupt_handler(int irq, void *dev_id);
+
+/* Structures to display interrupt counts in sysfs. */
+enum interrupt_sysfs_attribute_type {
+	ATTR_INTERRUPT_COUNTS,
+};
+
+static struct gasket_sysfs_attribute interrupt_sysfs_attrs[] = {
+	GASKET_SYSFS_RO(
+		interrupt_counts, interrupt_sysfs_show, ATTR_INTERRUPT_COUNTS),
+	GASKET_END_OF_ATTR_ARRAY,
+};
+
+/*
+ * Set up device registers for interrupt handling.
+ * @gasket_dev: The Gasket information structure for this device.
+ *
+ * Sets up the device registers with the correct indices for the relevant
+ * interrupts.
+ */
+static void gasket_interrupt_setup(struct gasket_dev *gasket_dev);
+
+/* MSIX init and cleanup. */
+static int gasket_interrupt_msix_init(
+	struct gasket_interrupt_data *interrupt_data);
+static void gasket_interrupt_msix_cleanup(
+	struct gasket_interrupt_data *interrupt_data);
+static void force_msix_interrupt_unmasking(struct gasket_dev *gasket_dev);
+
+int gasket_interrupt_init(
+	struct gasket_dev *gasket_dev, const char *name, int type,
+	const struct gasket_interrupt_desc *interrupts,
+	int num_interrupts, int pack_width, int bar_index,
+	const struct gasket_wire_interrupt_offsets *wire_int_offsets)
+{
+	int ret;
+	struct gasket_interrupt_data *interrupt_data;
+
+	interrupt_data = kzalloc(
+		sizeof(struct gasket_interrupt_data), GFP_KERNEL);
+	if (!interrupt_data)
+		return -ENOMEM;
+	gasket_dev->interrupt_data = interrupt_data;
+	interrupt_data->name = name;
+	interrupt_data->type = type;
+	interrupt_data->pci_dev = gasket_dev->pci_dev;
+	interrupt_data->num_interrupts = num_interrupts;
+	interrupt_data->interrupts = interrupts;
+	interrupt_data->interrupt_bar_index = bar_index;
+	interrupt_data->pack_width = pack_width;
+	interrupt_data->num_configured = 0;
+	interrupt_data->wire_interrupt_offsets = wire_int_offsets;
+
+	/* Allocate all dynamic structures. */
+	interrupt_data->msix_entries = kzalloc(
+		sizeof(struct msix_entry) * num_interrupts, GFP_KERNEL);
+	if (!interrupt_data->msix_entries) {
+		kfree(interrupt_data);
+		return -ENOMEM;
+	}
+
+	interrupt_data->eventfd_ctxs = kzalloc(
+		sizeof(struct eventfd_ctx *) * num_interrupts, GFP_KERNEL);
+	if (!interrupt_data->eventfd_ctxs) {
+		kfree(interrupt_data->msix_entries);
+		kfree(interrupt_data);
+		return -ENOMEM;
+	}
+
+	interrupt_data->interrupt_counts = kzalloc(
+		sizeof(ulong) * num_interrupts, GFP_KERNEL);
+	if (!interrupt_data->interrupt_counts) {
+		kfree(interrupt_data->eventfd_ctxs);
+		kfree(interrupt_data->msix_entries);
+		kfree(interrupt_data);
+		return -ENOMEM;
+	}
+
+	switch (interrupt_data->type) {
+	case PCI_MSIX:
+		ret = gasket_interrupt_msix_init(interrupt_data);
+		if (ret)
+			break;
+		force_msix_interrupt_unmasking(gasket_dev);
+		break;
+
+	case PCI_MSI:
+	case PLATFORM_WIRE:
+	default:
+		gasket_nodev_error(
+			"Cannot handle unsupported interrupt type %d.",
+			interrupt_data->type);
+		ret = -EINVAL;
+	};
+
+	if (ret) {
+		/* Failing to setup interrupts will cause the device to report
+		 * GASKET_STATUS_LAMED. But it is not fatal.
+		 */
+		gasket_log_warn(
+			gasket_dev, "Couldn't initialize interrupts: %d", ret);
+		return 0;
+	}
+
+	gasket_interrupt_setup(gasket_dev);
+	gasket_sysfs_create_entries(
+		gasket_dev->dev_info.device, interrupt_sysfs_attrs);
+
+	return 0;
+}
+
+static int gasket_interrupt_msix_init(
+	struct gasket_interrupt_data *interrupt_data)
+{
+	int ret = 1;
+	int i;
+
+	for (i = 0; i < interrupt_data->num_interrupts; i++) {
+		interrupt_data->msix_entries[i].entry = i;
+		interrupt_data->msix_entries[i].vector = 0;
+		interrupt_data->eventfd_ctxs[i] = NULL;
+	}
+
+	/* Retry MSIX_RETRY_COUNT times if not enough IRQs are available. */
+	for (i = 0; i < MSIX_RETRY_COUNT && ret > 0; i++)
+		ret = pci_enable_msix_exact(interrupt_data->pci_dev,
+					    interrupt_data->msix_entries,
+					    interrupt_data->num_interrupts);
+
+	if (ret)
+		return ret > 0 ? -EBUSY : ret;
+	interrupt_data->msix_configured = 1;
+
+	for (i = 0; i < interrupt_data->num_interrupts; i++) {
+		ret = request_irq(
+			interrupt_data->msix_entries[i].vector,
+			gasket_msix_interrupt_handler, 0, interrupt_data->name,
+			interrupt_data);
+
+		if (ret) {
+			gasket_nodev_error(
+				"Cannot get IRQ for interrupt %d, vector %d; "
+				"%d\n",
+				i, interrupt_data->msix_entries[i].vector, ret);
+			return ret;
+		}
+
+		interrupt_data->num_configured++;
+	}
+
+	return 0;
+}
+
+static void gasket_interrupt_msix_cleanup(
+	struct gasket_interrupt_data *interrupt_data)
+{
+	int i;
+
+	for (i = 0; i < interrupt_data->num_configured; i++)
+		free_irq(interrupt_data->msix_entries[i].vector,
+			 interrupt_data);
+	interrupt_data->num_configured = 0;
+
+	if (interrupt_data->msix_configured)
+		pci_disable_msix(interrupt_data->pci_dev);
+	interrupt_data->msix_configured = 0;
+}
+
+/*
+ * On QCM DragonBoard, we exit gasket_interrupt_msix_init() and kernel interrupt
+ * setup code with MSIX vectors masked. This is wrong because nothing else in
+ * the driver will normally touch the MSIX vectors.
+ *
+ * As a temporary hack, force unmasking there.
+ *
+ * TODO: Figure out why QCM kernel doesn't unmask the MSIX vectors, after
+ * gasket_interrupt_msix_init(), and remove this code.
+ */
+static void force_msix_interrupt_unmasking(struct gasket_dev *gasket_dev)
+{
+	int i;
+#define MSIX_VECTOR_SIZE 16
+#define MSIX_MASK_BIT_OFFSET 12
+#define APEX_BAR2_REG_KERNEL_HIB_MSIX_TABLE 0x46800
+	for (i = 0; i < gasket_dev->interrupt_data->num_configured; i++) {
+		/* Check if the MSIX vector is unmasked */
+		ulong location = APEX_BAR2_REG_KERNEL_HIB_MSIX_TABLE +
+				 MSIX_MASK_BIT_OFFSET + i * MSIX_VECTOR_SIZE;
+		u32 mask =
+			gasket_dev_read_32(
+				gasket_dev,
+				gasket_dev->interrupt_data->interrupt_bar_index,
+				location);
+		if (!(mask & 1))
+			continue;
+		/* Unmask the msix vector (clear 32 bits) */
+		gasket_dev_write_32(
+			gasket_dev, 0,
+			gasket_dev->interrupt_data->interrupt_bar_index,
+			location);
+	}
+#undef MSIX_VECTOR_SIZE
+#undef MSIX_MASK_BIT_OFFSET
+#undef APEX_BAR2_REG_KERNEL_HIB_MSIX_TABLE
+}
+
+int gasket_interrupt_reinit(struct gasket_dev *gasket_dev)
+{
+	int ret;
+
+	if (!gasket_dev->interrupt_data) {
+		gasket_log_error(
+			gasket_dev,
+			"Attempted to reinit uninitialized interrupt data.");
+		return -EINVAL;
+	}
+
+	switch (gasket_dev->interrupt_data->type) {
+	case PCI_MSIX:
+		gasket_interrupt_msix_cleanup(gasket_dev->interrupt_data);
+		ret = gasket_interrupt_msix_init(gasket_dev->interrupt_data);
+		if (ret)
+			break;
+		force_msix_interrupt_unmasking(gasket_dev);
+		break;
+
+	case PCI_MSI:
+	case PLATFORM_WIRE:
+	default:
+		gasket_nodev_error(
+			"Cannot handle unsupported interrupt type %d.",
+			gasket_dev->interrupt_data->type);
+		ret = -EINVAL;
+	};
+
+	if (ret) {
+		/* Failing to setup MSIx will cause the device
+		 * to report GASKET_STATUS_LAMED, but is not fatal.
+		 */
+		gasket_log_warn(gasket_dev, "Couldn't init msix: %d", ret);
+		return 0;
+	}
+
+	gasket_interrupt_setup(gasket_dev);
+
+	return 0;
+}
+
+/* See gasket_interrupt.h for description. */
+int gasket_interrupt_reset_counts(struct gasket_dev *gasket_dev)
+{
+	gasket_log_debug(gasket_dev, "Clearing interrupt counts.");
+	memset(gasket_dev->interrupt_data->interrupt_counts, 0,
+	       gasket_dev->interrupt_data->num_interrupts *
+			sizeof(*gasket_dev->interrupt_data->interrupt_counts));
+	return 0;
+}
+
+/*
+ * Set up device registers for interrupt handling.
+ * @gasket_dev: The Gasket information structure for this device.
+ *
+ * Sets up the device registers with the correct indices for the relevant
+ * interrupts.
+ */
+static void gasket_interrupt_setup(struct gasket_dev *gasket_dev)
+{
+	int i;
+	int pack_shift;
+	ulong mask;
+	ulong value;
+	struct gasket_interrupt_data *interrupt_data =
+		gasket_dev->interrupt_data;
+
+	if (!interrupt_data) {
+		gasket_log_error(
+			gasket_dev, "Interrupt data is not initialized.");
+		return;
+	}
+
+	gasket_log_debug(gasket_dev, "Running interrupt setup.");
+
+	if (interrupt_data->type == PLATFORM_WIRE ||
+	    interrupt_data->type == PCI_MSI) {
+		/* Nothing needs to be done for platform or PCI devices. */
+		return;
+	}
+
+	if (interrupt_data->type != PCI_MSIX) {
+		gasket_nodev_error(
+			"Cannot handle unsupported interrupt type %d.",
+			interrupt_data->type);
+		return;
+	}
+
+	/* Setup the MSIX table. */
+
+	for (i = 0; i < interrupt_data->num_interrupts; i++) {
+		/*
+		 * If the interrupt is not packed, we can write the index into
+		 * the register directly. If not, we need to deal with a read-
+		 * modify-write and shift based on the packing index.
+		 */
+		gasket_log_debug(
+			gasket_dev,
+			"Setting up interrupt index %d with index 0x%llx and "
+			"packing %d",
+			interrupt_data->interrupts[i].index,
+			interrupt_data->interrupts[i].reg,
+			interrupt_data->interrupts[i].packing);
+		if (interrupt_data->interrupts[i].packing == UNPACKED) {
+			value = interrupt_data->interrupts[i].index;
+		} else {
+			switch (interrupt_data->interrupts[i].packing) {
+			case PACK_0:
+				pack_shift = 0;
+				break;
+			case PACK_1:
+				pack_shift = interrupt_data->pack_width;
+				break;
+			case PACK_2:
+				pack_shift = 2 * interrupt_data->pack_width;
+				break;
+			case PACK_3:
+				pack_shift = 3 * interrupt_data->pack_width;
+				break;
+			default:
+				gasket_nodev_error(
+					"Found interrupt description with "
+					"unknown enum %d.",
+					interrupt_data->interrupts[i].packing);
+				return;
+			}
+
+			mask = ~(0xFFFF << pack_shift);
+			value = gasket_dev_read_64(
+					gasket_dev,
+					interrupt_data->interrupt_bar_index,
+					interrupt_data->interrupts[i].reg) &
+				mask;
+			value |= interrupt_data->interrupts[i].index
+				 << pack_shift;
+		}
+		gasket_dev_write_64(gasket_dev, value,
+				    interrupt_data->interrupt_bar_index,
+				    interrupt_data->interrupts[i].reg);
+	}
+}
+
+/* See gasket_interrupt.h for description. */
+void gasket_interrupt_pause(struct gasket_dev *gasket_dev, int enable_pause)
+{
+	WARN_ON(!gasket_dev);
+
+	if (!gasket_dev->interrupt_data)
+		return; /* nothing to do */
+
+	if (gasket_dev->interrupt_data->type == PCI_MSI ||
+	    gasket_dev->interrupt_data->type == PCI_MSIX) {
+		/* Nothing to be done for MSI/MSIX just yet. */
+	}
+
+	if (gasket_dev->interrupt_data->type == PLATFORM_WIRE) {
+		/* Nothing to be done for PLATFORM_WIRE */
+	}
+}
+EXPORT_SYMBOL(gasket_interrupt_pause);
+
+void gasket_interrupt_cleanup(struct gasket_dev *gasket_dev)
+{
+	struct gasket_interrupt_data *interrupt_data =
+		gasket_dev->interrupt_data;
+	/*
+	 * It is possible to get an error code from gasket_interrupt_init
+	 * before interrupt_data has been allocated, so check it.
+	 */
+	if (!interrupt_data)
+		return;
+
+	switch (interrupt_data->type) {
+	case PCI_MSIX:
+		gasket_interrupt_msix_cleanup(interrupt_data);
+		break;
+
+	case PCI_MSI:
+	case PLATFORM_WIRE:
+	default:
+		gasket_nodev_error(
+			"Cannot handle unsupported interrupt type %d.",
+			interrupt_data->type);
+	};
+
+	kfree(interrupt_data->interrupt_counts);
+	kfree(interrupt_data->eventfd_ctxs);
+	kfree(interrupt_data->msix_entries);
+	kfree(interrupt_data);
+	gasket_dev->interrupt_data = NULL;
+}
+
+int gasket_interrupt_system_status(struct gasket_dev *gasket_dev)
+{
+	if (!gasket_dev->interrupt_data) {
+		gasket_nodev_info("Interrupt data is null.");
+		return GASKET_STATUS_DEAD;
+	}
+
+	if (!gasket_dev->interrupt_data->msix_configured) {
+		gasket_nodev_info("Interrupt not initialized.");
+		return GASKET_STATUS_LAMED;
+	}
+
+	if (gasket_dev->interrupt_data->num_configured !=
+		gasket_dev->interrupt_data->num_interrupts) {
+		gasket_nodev_info("Not all interrupts were configured.");
+		return GASKET_STATUS_LAMED;
+	}
+
+	return GASKET_STATUS_ALIVE;
+}
+
+int gasket_interrupt_set_eventfd(
+	struct gasket_interrupt_data *interrupt_data, int interrupt,
+	int event_fd)
+{
+	struct eventfd_ctx *ctx = eventfd_ctx_fdget(event_fd);
+
+	if (IS_ERR(ctx))
+		return PTR_ERR(ctx);
+
+	if (interrupt < 0 || interrupt > interrupt_data->num_interrupts)
+		return -EINVAL;
+
+	interrupt_data->eventfd_ctxs[interrupt] = ctx;
+	return 0;
+}
+
+int gasket_interrupt_clear_eventfd(
+	struct gasket_interrupt_data *interrupt_data, int interrupt)
+{
+	if (interrupt < 0 || interrupt > interrupt_data->num_interrupts)
+		return -EINVAL;
+
+	interrupt_data->eventfd_ctxs[interrupt] = NULL;
+	return 0;
+}
+
+int gasket_interrupt_trigger_eventfd(
+	struct gasket_interrupt_data *interrupt_data, int interrupt)
+{
+	struct eventfd_ctx *ctx = interrupt_data->eventfd_ctxs[interrupt];
+
+	if (!ctx)
+		return -EINVAL;
+
+	eventfd_signal(ctx, 1);
+	return 0;
+}
+
+struct msix_entry *gasket_interrupt_get_msix_entries(
+	struct gasket_interrupt_data *interrupt_data)
+{
+	return interrupt_data->msix_entries;
+}
+
+struct eventfd_ctx **gasket_interrupt_get_eventfd_ctxs(
+	struct gasket_interrupt_data *interrupt_data)
+{
+	return interrupt_data->eventfd_ctxs;
+}
+EXPORT_SYMBOL(gasket_interrupt_get_eventfd_ctxs);
+
+static ssize_t interrupt_sysfs_show(
+	struct device *device, struct device_attribute *attr, char *buf)
+{
+	int i, ret;
+	ssize_t written = 0, total_written = 0;
+	struct gasket_interrupt_data *interrupt_data;
+	struct gasket_dev *gasket_dev;
+	struct gasket_sysfs_attribute *gasket_attr;
+	enum interrupt_sysfs_attribute_type sysfs_type;
+
+	gasket_dev = gasket_sysfs_get_device_data(device);
+	if (!gasket_dev) {
+		gasket_nodev_error(
+			"No sysfs mapping found for device 0x%p", device);
+		return 0;
+	}
+
+	gasket_attr = gasket_sysfs_get_attr(device, attr);
+	if (!gasket_attr) {
+		gasket_nodev_error(
+			"No sysfs attr data found for device 0x%p", device);
+		gasket_sysfs_put_device_data(device, gasket_dev);
+		return 0;
+	}
+
+	sysfs_type = (enum interrupt_sysfs_attribute_type)
+		gasket_attr->data.attr_type;
+	interrupt_data = gasket_dev->interrupt_data;
+	switch (sysfs_type) {
+	case ATTR_INTERRUPT_COUNTS:
+		for (i = 0; i < interrupt_data->num_interrupts; ++i) {
+			written =
+				scnprintf(buf, PAGE_SIZE - total_written,
+					  "0x%02x: %ld\n", i,
+					  interrupt_data->interrupt_counts[i]);
+			total_written += written;
+			buf += written;
+		}
+		ret = total_written;
+		break;
+	default:
+		gasket_log_error(
+			gasket_dev, "Unknown attribute: %s", attr->attr.name);
+		ret = 0;
+		break;
+	}
+
+	gasket_sysfs_put_attr(device, gasket_attr);
+	gasket_sysfs_put_device_data(device, gasket_dev);
+	return ret;
+}
+
+/*
+ * MSIX interrupt handler, used with PCI driver.
+ */
+static irqreturn_t gasket_msix_interrupt_handler(int irq, void *dev_id)
+{
+	struct eventfd_ctx *ctx;
+	struct gasket_interrupt_data *interrupt_data = dev_id;
+	int interrupt = -1;
+	int i;
+
+	/* If this linear lookup is a problem, we can maintain a map/hash. */
+	for (i = 0; i < interrupt_data->num_interrupts; i++) {
+		if (interrupt_data->msix_entries[i].vector == irq) {
+			interrupt = interrupt_data->msix_entries[i].entry;
+			break;
+		}
+	}
+	if (interrupt == -1) {
+		gasket_nodev_error("Received unknown irq %d", irq);
+		return IRQ_HANDLED;
+	}
+	trace_gasket_interrupt_event(interrupt_data->name, interrupt);
+
+	ctx = interrupt_data->eventfd_ctxs[interrupt];
+	if (ctx)
+		eventfd_signal(ctx, 1);
+
+	++(interrupt_data->interrupt_counts[interrupt]);
+
+	return IRQ_HANDLED;
+}
