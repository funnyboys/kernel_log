commit c9c13ba428ef90a9b408a6cdf874e14ab5754516
Author: Denis Efremov <efremov@linux.com>
Date:   Sat Sep 28 02:43:08 2019 +0300

    PCI: Add PCI_STD_NUM_BARS for the number of standard BARs
    
    Code that iterates over all standard PCI BARs typically uses
    PCI_STD_RESOURCE_END.  However, that requires the unusual test
    "i <= PCI_STD_RESOURCE_END" rather than something the typical
    "i < PCI_STD_NUM_BARS".
    
    Add a definition for PCI_STD_NUM_BARS and change loops to use the more
    idiomatic C style to help avoid fencepost errors.
    
    Link: https://lore.kernel.org/r/20190927234026.23342-1-efremov@linux.com
    Link: https://lore.kernel.org/r/20190927234308.23935-1-efremov@linux.com
    Link: https://lore.kernel.org/r/20190916204158.6889-3-efremov@linux.com
    Signed-off-by: Denis Efremov <efremov@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Sebastian Ott <sebott@linux.ibm.com>                  # arch/s390/
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>  # video/fbdev/
    Acked-by: Gustavo Pimentel <gustavo.pimentel@synopsys.com>      # pci/controller/dwc/
    Acked-by: Jack Wang <jinpu.wang@cloud.ionos.com>                # scsi/pm8001/
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>       # scsi/pm8001/
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>                  # memstick/

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index be44ac1e3118..c417acadb0d5 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -268,7 +268,7 @@ struct gasket_dev {
 	char kobj_name[GASKET_NAME_MAX];
 
 	/* Virtual address of mapped BAR memory range. */
-	struct gasket_bar_data bar_data[GASKET_NUM_BARS];
+	struct gasket_bar_data bar_data[PCI_STD_NUM_BARS];
 
 	/* Coherent buffer. */
 	struct gasket_coherent_buffer coherent_buffer;
@@ -369,7 +369,7 @@ struct gasket_driver_desc {
 	/* Set of 6 bar descriptions that describe all PCIe bars.
 	 * Note that BUS/AXI devices (i.e. non PCI devices) use those.
 	 */
-	struct gasket_bar_desc bar_descriptions[GASKET_NUM_BARS];
+	struct gasket_bar_desc bar_descriptions[PCI_STD_NUM_BARS];
 
 	/*
 	 * Coherent buffer description.

commit 4ab7e05dd070600833680bd318d6d962f010caa2
Author: Laurence Rochfort <laurence.rochfort@gmail.com>
Date:   Wed Oct 10 22:24:26 2018 +0100

    staging: gasket: Fix sparse "incorrect type in assignment" warnings.
    
    Remove the coherent buffer __iomem cookie because the buffer is
    allocated from dma_alloc_coherent().
    
    warning: incorrect type in assignment (different address spaces)
       expected unsigned char [noderef] [usertype] <asn:2>*virt_base
       got void *[assigned] mem
    warning: incorrect type in argument 3 (different address spaces)
       expected void *cpu_addr
       got unsigned char [noderef] [usertype] <asn:2>*virt_base
    
    Signed-off-by: Laurence Rochfort <laurence.rochfort@gmail.com>
    Reviewed-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 0203460f4895..be44ac1e3118 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -223,7 +223,7 @@ struct gasket_coherent_buffer_desc {
 /* Coherent buffer structure. */
 struct gasket_coherent_buffer {
 	/* Virtual base address. */
-	u8 __iomem *virt_base;
+	u8 *virt_base;
 
 	/* Physical base address. */
 	ulong phys_base;

commit cca5dd879075e95b706376123ea22231190aefe9
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:21:11 2018 -0700

    staging: gasket: interrupt: remove unimplemented interrupt types
    
    Interrupt types PCI_MSI and PLATFORM_WIRE are unused and unimplemented.
    Remove these.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index fd7e75b765a6..0203460f4895 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -50,8 +50,6 @@ enum gasket_interrupt_packing {
 /* Type of the interrupt supported by the device. */
 enum gasket_interrupt_type {
 	PCI_MSIX = 0,
-	PCI_MSI = 1,
-	PLATFORM_WIRE = 2,
 };
 
 /*
@@ -69,12 +67,6 @@ struct gasket_interrupt_desc {
 	int packing;
 };
 
-/* Offsets to the wire interrupt handling registers */
-struct gasket_wire_interrupt_offsets {
-	u64 pending_bit_array;
-	u64 mask_array;
-};
-
 /*
  * This enum is used to identify memory regions being part of the physical
  * memory that belongs to a device.
@@ -384,9 +376,6 @@ struct gasket_driver_desc {
 	 */
 	struct gasket_coherent_buffer_desc coherent_buffer_description;
 
-	/* Offset of wire interrupt registers. */
-	const struct gasket_wire_interrupt_offsets *wire_interrupt_offsets;
-
 	/* Interrupt type. (One of gasket_interrupt_type). */
 	int interrupt_type;
 

commit 717264bab46e774e196574c77aae5f103b9b2f26
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 9 20:21:04 2018 -0700

    staging: gasket: core: switch to relaxed memory-mapped I/O
    
    Use of readl() is deprecated; readl_relaxed() with appropriate memory
    barriers is preferred.  Switch to relaxed reads and writes for better
    performance as well.  Memory barriers required for I/O vs. normal
    memory access on Apex devices have already been explicitly coded in the
    page table routines.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 275fd0b345b6..fd7e75b765a6 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -590,25 +590,25 @@ const char *gasket_num_name_lookup(uint num,
 static inline ulong gasket_dev_read_64(struct gasket_dev *gasket_dev, int bar,
 				       ulong location)
 {
-	return readq(&gasket_dev->bar_data[bar].virt_base[location]);
+	return readq_relaxed(&gasket_dev->bar_data[bar].virt_base[location]);
 }
 
 static inline void gasket_dev_write_64(struct gasket_dev *dev, u64 value,
 				       int bar, ulong location)
 {
-	writeq(value, &dev->bar_data[bar].virt_base[location]);
+	writeq_relaxed(value, &dev->bar_data[bar].virt_base[location]);
 }
 
 static inline void gasket_dev_write_32(struct gasket_dev *dev, u32 value,
 				       int bar, ulong location)
 {
-	writel(value, &dev->bar_data[bar].virt_base[location]);
+	writel_relaxed(value, &dev->bar_data[bar].virt_base[location]);
 }
 
 static inline u32 gasket_dev_read_32(struct gasket_dev *dev, int bar,
 				     ulong location)
 {
-	return readl(&dev->bar_data[bar].virt_base[location]);
+	return readl_relaxed(&dev->bar_data[bar].virt_base[location]);
 }
 
 static inline void gasket_read_modify_write_64(struct gasket_dev *dev, int bar,

commit 565eeedaa0c1b2b0d8abd3845e349de29065a5d2
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:45 2018 -0700

    staging: gasket: core: remove sysfs setup and cleanup callbacks
    
    Gasket device drivers now call into the gasket framework to initialize
    and de-initialize, rather than the other way around.  The calling code
    can perform sysfs setup and cleanup actions without callbacks from the
    framework.  Remove the sysfs setup and cleanup callbacks.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 0ef0a2640f0f..275fd0b345b6 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -444,24 +444,6 @@ struct gasket_driver_desc {
 	 */
 	int (*device_close_cb)(struct gasket_dev *dev);
 
-	/*
-	 * sysfs_setup_cb: Callback to set up driver-specific sysfs nodes.
-	 * @dev: Pointer to the gasket_dev struct for this device.
-	 *
-	 * Called during the add gasket device call.
-	 *
-	 */
-	int (*sysfs_setup_cb)(struct gasket_dev *dev);
-
-	/*
-	 * sysfs_cleanup_cb: Callback to clean up driver-specific sysfs nodes.
-	 * @dev: Pointer to the gasket_dev struct for this device.
-	 *
-	 * Called during device disable processing.
-	 *
-	 */
-	int (*sysfs_cleanup_cb)(struct gasket_dev *dev);
-
 	/*
 	 * get_mappable_regions_cb: Get descriptors of mappable device memory.
 	 * @gasket_dev: Pointer to the struct gasket_dev for this device.

commit 4420ea9366a5df61cbb0bb2ad827ff6391904f56
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:43 2018 -0700

    staging: gasket: core: delete device add and remove callbacks
    
    Gasket device drivers are now in charge of orchestrating the device add
    and removal sequences, so the callbacks from the framework to the device
    drivers for these events are no longer needed.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 9c143ebeba45..0ef0a2640f0f 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -302,12 +302,6 @@ struct gasket_dev {
 	/* Hardware revision value for this device. */
 	int hardware_revision;
 
-	/*
-	 * Device-specific data; allocated in gasket_driver_desc.add_dev_cb()
-	 * and freed in gasket_driver_desc.remove_dev_cb().
-	 */
-	void *cb_data;
-
 	/* Protects access to per-device data (i.e. this structure). */
 	struct mutex mutex;
 
@@ -415,29 +409,6 @@ struct gasket_driver_desc {
 	int interrupt_pack_width;
 
 	/* Driver callback functions - all may be NULL */
-	/*
-	 * add_dev_cb: Callback when a device is found.
-	 * @dev: The gasket_dev struct for this driver instance.
-	 *
-	 * This callback should initialize the device-specific cb_data.
-	 * Called when a device is found by the driver,
-	 * before any BAR ranges have been mapped. If this call fails (returns
-	 * nonzero), remove_dev_cb will be called.
-	 *
-	 */
-	int (*add_dev_cb)(struct gasket_dev *dev);
-
-	/*
-	 * remove_dev_cb: Callback for when a device is removed from the system.
-	 * @dev: The gasket_dev struct for this driver instance.
-	 *
-	 * This callback should free data allocated in add_dev_cb.
-	 * Called immediately before a device is unregistered by the driver.
-	 * All framework-managed resources will have been cleaned up by the time
-	 * this callback is invoked (PCI BARs, character devices, ...).
-	 */
-	int (*remove_dev_cb)(struct gasket_dev *dev);
-
 	/*
 	 * device_open_cb: Callback for when a device node is opened in write
 	 * mode.

commit 39091410d0d8eeb07f3b08ff4e44400ccd434762
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:41 2018 -0700

    staging: gasket: core: let device driver enable/disable gasket device
    
    Move gasket device enable/disable functions from internal calls to
    external calls from the gasket device drivers.  The device driver will
    call these functions at appropriate times in its processing, placing
    the device driver in control of this sequence and reducing the need for
    callbacks from framework back to the device drivers during the
    enable/disable sequences.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 5d40bc7f52e9..9c143ebeba45 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -590,6 +590,12 @@ int gasket_pci_add_device(struct pci_dev *pci_dev,
 /* Remove a PCI gasket device. */
 void gasket_pci_remove_device(struct pci_dev *pci_dev);
 
+/* Enable a Gasket device. */
+int gasket_enable_device(struct gasket_dev *gasket_dev);
+
+/* Disable a Gasket device. */
+void gasket_disable_device(struct gasket_dev *gasket_dev);
+
 /*
  * Reset the Gasket device.
  * @gasket_dev: Gasket device struct.

commit 1b25e6e81aab048107ed20c218c2b04261fd94ec
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:39 2018 -0700

    staging: gasket: core: remove device enable and disable callbacks
    
    Device enable/disable operations are moving from being initiated through
    the gasket framework to being initiated by the gasket device driver.
    The driver can perform any processing needed for these operations before
    or after the calls into the framework.  Neither of these callbacks are
    implemented for the only gasket driver upstream today, apex.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 9f9bc66a0daa..5d40bc7f52e9 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -473,34 +473,11 @@ struct gasket_driver_desc {
 	 */
 	int (*device_close_cb)(struct gasket_dev *dev);
 
-	/*
-	 * enable_dev_cb: Callback immediately before enabling the device.
-	 * @dev: Pointer to the gasket_dev struct for this driver instance.
-	 *
-	 * This callback is invoked after the device has been added and all BAR
-	 * spaces mapped, immediately before registering and enabling the
-	 * [character] device via cdev_add. If this call fails (returns
-	 * nonzero), disable_dev_cb will be called.
-	 *
-	 * Note that cdev are initialized but not active
-	 * (cdev_add has not yet been called) when this callback is invoked.
-	 */
-	int (*enable_dev_cb)(struct gasket_dev *dev);
-
-	/*
-	 * disable_dev_cb: Callback immediately after disabling the device.
-	 * @dev: Pointer to the gasket_dev struct for this driver instance.
-	 *
-	 * Called during device shutdown, immediately after disabling device
-	 * operations via cdev_del.
-	 */
-	int (*disable_dev_cb)(struct gasket_dev *dev);
-
 	/*
 	 * sysfs_setup_cb: Callback to set up driver-specific sysfs nodes.
 	 * @dev: Pointer to the gasket_dev struct for this device.
 	 *
-	 * Called just before enable_dev_cb.
+	 * Called during the add gasket device call.
 	 *
 	 */
 	int (*sysfs_setup_cb)(struct gasket_dev *dev);
@@ -509,7 +486,7 @@ struct gasket_driver_desc {
 	 * sysfs_cleanup_cb: Callback to clean up driver-specific sysfs nodes.
 	 * @dev: Pointer to the gasket_dev struct for this device.
 	 *
-	 * Called just before disable_dev_cb.
+	 * Called during device disable processing.
 	 *
 	 */
 	int (*sysfs_cleanup_cb)(struct gasket_dev *dev);

commit b7072b24fa61f42c356ffdfaa0544065d6f1c23b
Author: Todd Poynor <toddpoynor@google.com>
Date:   Sun Aug 5 13:07:36 2018 -0700

    staging: gasket: core: move core PCI calls to device drivers
    
    Remove gasket wrapping of PCI probe, enable, disable, and remove
    functions.  Replace with calls to add and remove PCI gasket devices,
    to be called by the gasket device drivers.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 67f5960943a8..9f9bc66a0daa 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -607,6 +607,12 @@ int gasket_register_device(const struct gasket_driver_desc *desc);
  */
 void gasket_unregister_device(const struct gasket_driver_desc *desc);
 
+/* Add a PCI gasket device. */
+int gasket_pci_add_device(struct pci_dev *pci_dev,
+			  struct gasket_dev **gasket_devp);
+/* Remove a PCI gasket device. */
+void gasket_pci_remove_device(struct pci_dev *pci_dev);
+
 /*
  * Reset the Gasket device.
  * @gasket_dev: Gasket device struct.

commit 1c65a2e2f68eae5d73b41dee003b8135dfcf6928
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Aug 2 01:42:43 2018 -0700

    staging: gasket: remove "reset type" param from framework
    
    The "type of reset" parameter to the gasket device reset APIs isn't
    required by the only gasket device submitted upstream, apex.
    
    The framework documents the param as private to the device driver and a
    pass-through at the gasket layer, but the gasket core calls the device
    driver with a hardcoded reset type of zero, which is not documented as
    having a predefined meaning.
    
    In light of all this, remove the reset type parameter from the
    framework.  Remove the reset ioctl reset type parameter, and bump the
    framework version number to reflect the interface change.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 713bf42de41a..67f5960943a8 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -580,17 +580,12 @@ struct gasket_driver_desc {
 	/*
 	 * device_reset_cb: Reset the hardware in question.
 	 * @dev: Pointer to the gasket_dev structure for this device.
-	 * @type: Integer representing reset type. (All
-	 * Gasket resets have an integer representing their type
-	 * defined in (device)_ioctl.h; the specific resets are
-	 * device-dependent, but are handled in the device-specific
-	 * callback anyways.)
 	 *
 	 * Called by reset ioctls. This function should not
 	 * lock the gasket_dev mutex. It should return 0 on success
 	 * and an error on failure.
 	 */
-	int (*device_reset_cb)(struct gasket_dev *dev, uint reset_type);
+	int (*device_reset_cb)(struct gasket_dev *dev);
 };
 
 /*
@@ -615,15 +610,13 @@ void gasket_unregister_device(const struct gasket_driver_desc *desc);
 /*
  * Reset the Gasket device.
  * @gasket_dev: Gasket device struct.
- * @reset_type: Uint representing requested reset type. Should be
- * valid in the underlying callback.
  *
  * Calls device_reset_cb. Returns 0 on success and an error code othewrise.
  * gasket_reset_nolock will not lock the mutex, gasket_reset will.
  *
  */
-int gasket_reset(struct gasket_dev *gasket_dev, uint reset_type);
-int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type);
+int gasket_reset(struct gasket_dev *gasket_dev);
+int gasket_reset_nolock(struct gasket_dev *gasket_dev);
 
 /*
  * Memory management functions. These will likely be spun off into their own

commit 88c8a377c00ff3a69bf5a4abfdf6fc5f041089e1
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 31 13:24:39 2018 -0700

    staging: gasket: core: fix function param line continuation style
    
    Fix multi-line alignment formatting to look like:
          int ret = long_function_name(device, VARIABLE1, VARIABLE2,
                                       VARIABLE3, VARIABLE4);
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 8bd431ad3b58..713bf42de41a 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -318,11 +318,11 @@ struct gasket_dev {
 };
 
 /* Type of the ioctl handler callback. */
-typedef long (*gasket_ioctl_handler_cb_t)
-		(struct file *file, uint cmd, void __user *argp);
+typedef long (*gasket_ioctl_handler_cb_t)(struct file *file, uint cmd,
+					  void __user *argp);
 /* Type of the ioctl permissions check callback. See below. */
-typedef int (*gasket_ioctl_permissions_cb_t)(
-	struct file *filp, uint cmd, void __user *argp);
+typedef int (*gasket_ioctl_permissions_cb_t)(struct file *filp, uint cmd,
+					     void __user *argp);
 
 /*
  * Device type descriptor.
@@ -457,8 +457,8 @@ struct gasket_driver_desc {
 	 * descriptor for an open file is closed. This call is intended to
 	 * handle any per-user or per-fd cleanup.
 	 */
-	int (*device_release_cb)(
-		struct gasket_dev *gasket_dev, struct file *file);
+	int (*device_release_cb)(struct gasket_dev *gasket_dev,
+				 struct file *file);
 
 	/*
 	 * device_close_cb: Callback for when a device node is closed for the
@@ -527,10 +527,10 @@ struct gasket_driver_desc {
 	 * information is then compared to mmap request to determine which
 	 * regions to actually map.
 	 */
-	int (*get_mappable_regions_cb)(
-		struct gasket_dev *gasket_dev, int bar_index,
-		struct gasket_mappable_region **mappable_regions,
-		int *num_mappable_regions);
+	int (*get_mappable_regions_cb)(struct gasket_dev *gasket_dev,
+				       int bar_index,
+				       struct gasket_mappable_region **mappable_regions,
+				       int *num_mappable_regions);
 
 	/*
 	 * ioctl_permissions_cb: Check permissions for generic ioctls.
@@ -631,16 +631,16 @@ int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type);
  */
 
 /* Unmaps the specified mappable region from a VMA. */
-int gasket_mm_unmap_region(
-	const struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
-	const struct gasket_mappable_region *map_region);
+int gasket_mm_unmap_region(const struct gasket_dev *gasket_dev,
+			   struct vm_area_struct *vma,
+			   const struct gasket_mappable_region *map_region);
 
 /*
  * Get the ioctl permissions callback.
  * @gasket_dev: Gasket device structure.
  */
-gasket_ioctl_permissions_cb_t gasket_get_ioctl_permissions_cb(
-	struct gasket_dev *gasket_dev);
+gasket_ioctl_permissions_cb_t
+gasket_get_ioctl_permissions_cb(struct gasket_dev *gasket_dev);
 
 /**
  * Lookup a name by number in a num_name table.
@@ -648,37 +648,37 @@ gasket_ioctl_permissions_cb_t gasket_get_ioctl_permissions_cb(
  * @table: Array of num_name structures, the table for the lookup.
  *
  */
-const char *gasket_num_name_lookup(
-	uint num, const struct gasket_num_name *table);
+const char *gasket_num_name_lookup(uint num,
+				   const struct gasket_num_name *table);
 
 /* Handy inlines */
-static inline ulong gasket_dev_read_64(
-	struct gasket_dev *gasket_dev, int bar, ulong location)
+static inline ulong gasket_dev_read_64(struct gasket_dev *gasket_dev, int bar,
+				       ulong location)
 {
 	return readq(&gasket_dev->bar_data[bar].virt_base[location]);
 }
 
-static inline void gasket_dev_write_64(
-	struct gasket_dev *dev, u64 value, int bar, ulong location)
+static inline void gasket_dev_write_64(struct gasket_dev *dev, u64 value,
+				       int bar, ulong location)
 {
 	writeq(value, &dev->bar_data[bar].virt_base[location]);
 }
 
-static inline void gasket_dev_write_32(
-	struct gasket_dev *dev, u32 value, int bar, ulong location)
+static inline void gasket_dev_write_32(struct gasket_dev *dev, u32 value,
+				       int bar, ulong location)
 {
 	writel(value, &dev->bar_data[bar].virt_base[location]);
 }
 
-static inline u32 gasket_dev_read_32(
-	struct gasket_dev *dev, int bar, ulong location)
+static inline u32 gasket_dev_read_32(struct gasket_dev *dev, int bar,
+				     ulong location)
 {
 	return readl(&dev->bar_data[bar].virt_base[location]);
 }
 
-static inline void gasket_read_modify_write_64(
-	struct gasket_dev *dev, int bar, ulong location, u64 value,
-	u64 mask_width, u64 mask_shift)
+static inline void gasket_read_modify_write_64(struct gasket_dev *dev, int bar,
+					       ulong location, u64 value,
+					       u64 mask_width, u64 mask_shift)
 {
 	u64 mask, tmp;
 
@@ -688,9 +688,9 @@ static inline void gasket_read_modify_write_64(
 	gasket_dev_write_64(dev, tmp, bar, location);
 }
 
-static inline void gasket_read_modify_write_32(
-	struct gasket_dev *dev, int bar, ulong location, u32 value,
-	u32 mask_width, u32 mask_shift)
+static inline void gasket_read_modify_write_32(struct gasket_dev *dev, int bar,
+					       ulong location, u32 value,
+					       u32 mask_width, u32 mask_shift)
 {
 	u32 mask, tmp;
 
@@ -707,8 +707,8 @@ const struct gasket_driver_desc *gasket_get_driver_desc(struct gasket_dev *dev);
 struct device *gasket_get_device(struct gasket_dev *dev);
 
 /* Helper function, Asynchronous waits on a given set of bits. */
-int gasket_wait_with_reschedule(
-	struct gasket_dev *gasket_dev, int bar, u64 offset, u64 mask, u64 val,
-	uint max_retries, u64 delay_ms);
+int gasket_wait_with_reschedule(struct gasket_dev *gasket_dev, int bar,
+				u64 offset, u64 mask, u64 val,
+				uint max_retries, u64 delay_ms);
 
 #endif /* __GASKET_CORE_H__ */

commit 6cefe675f12f1b53f963f6b867d40aa4237a35d9
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 26 20:07:28 2018 -0700

    staging: gasket: save struct device for a gasket device
    
    Save the struct device pointer to a gasket device in gasket's metadata,
    to facilitate use of standard logging calls and in anticipation of
    non-PCI gasket devices in the future.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index bf4ed3769efb..8bd431ad3b58 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -263,6 +263,9 @@ struct gasket_dev {
 	/* Pointer to the internal driver description for this device. */
 	struct gasket_internal_desc *internal_desc;
 
+	/* Device info */
+	struct device *dev;
+
 	/* PCI subsystem metadata. */
 	struct pci_dev *pci_dev;
 

commit 761d8db71436d8c67bcac85aa62860cb5848fecf
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:17 2018 -0700

    staging: gasket: top ioctl handler add __user annotations
    
    Add __user annotation to gasket_core top-level ioctl handling pointer
    arguments, for sparse checking.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 7ea1df123ba5..bf4ed3769efb 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -314,9 +314,12 @@ struct gasket_dev {
 	struct hlist_node legacy_hlist_node;
 };
 
+/* Type of the ioctl handler callback. */
+typedef long (*gasket_ioctl_handler_cb_t)
+		(struct file *file, uint cmd, void __user *argp);
 /* Type of the ioctl permissions check callback. See below. */
 typedef int (*gasket_ioctl_permissions_cb_t)(
-	struct file *filp, uint cmd, ulong arg);
+	struct file *filp, uint cmd, void __user *argp);
 
 /*
  * Device type descriptor.
@@ -550,7 +553,7 @@ struct gasket_driver_desc {
 	 * return -EINVAL. Should return an error status (either -EINVAL or
 	 * the error result of the ioctl being handled).
 	 */
-	long (*ioctl_handler_cb)(struct file *filp, uint cmd, ulong arg);
+	gasket_ioctl_handler_cb_t ioctl_handler_cb;
 
 	/*
 	 * device_status_cb: Callback to determine device health.

commit 563f3bb51f59e288879c099b2e8ee1496b7c3234
Author: Todd Poynor <toddpoynor@google.com>
Date:   Thu Jul 19 20:49:15 2018 -0700

    staging: gasket: fix multi-line comment syntax in gasket_core.h
    
    Use consistent kernel-style multi-line comment syntax.
    
    Reported-by: Guenter Roeck <groeck@chromium.org>
    Signed-off-by: Simon Que <sque@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 50ad0c885318..7ea1df123ba5 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -54,7 +54,8 @@ enum gasket_interrupt_type {
 	PLATFORM_WIRE = 2,
 };
 
-/* Used to describe a Gasket interrupt. Contains an interrupt index, a register,
+/*
+ * Used to describe a Gasket interrupt. Contains an interrupt index, a register,
  * and packing data for that interrupt. The register and packing data
  * fields are relevant only for PCI_MSIX interrupt type and can be
  * set to 0 for everything else.

commit 72a23054a95c5439b779930b6ffa129437178ac9
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 17 13:56:53 2018 -0700

    staging: gasket: gasket_wait_with_reschedule use 32 bits of retry count
    
    Don't need a 64-bit retry counter.
    
    Reported-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Zhongze Hu <frankhu@chromium.org>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 94a5537bff2c..50ad0c885318 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -702,6 +702,6 @@ struct device *gasket_get_device(struct gasket_dev *dev);
 /* Helper function, Asynchronous waits on a given set of bits. */
 int gasket_wait_with_reschedule(
 	struct gasket_dev *gasket_dev, int bar, u64 offset, u64 mask, u64 val,
-	u64 max_retries, u64 delay_ms);
+	uint max_retries, u64 delay_ms);
 
 #endif /* __GASKET_CORE_H__ */

commit 920953ab4ed51fb2c971822dc593ca132913a4d2
Author: Todd Poynor <toddpoynor@google.com>
Date:   Tue Jul 17 13:56:43 2018 -0700

    staging: gasket: fix typo in gasket_core.h comments
    
    Grammar fixup in gasket_core.h comments describing struct
    gasket_interrupt_desc.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index e51acadc0fc4..94a5537bff2c 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -56,7 +56,7 @@ enum gasket_interrupt_type {
 
 /* Used to describe a Gasket interrupt. Contains an interrupt index, a register,
  * and packing data for that interrupt. The register and packing data
- * fields is relevant only for PCI_MSIX interrupt type and can be
+ * fields are relevant only for PCI_MSIX interrupt type and can be
  * set to 0 for everything else.
  */
 struct gasket_interrupt_desc {

commit bfd727f3a59c3696d6fbe086589376a16a5cdf05
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jul 13 17:46:17 2018 +0200

    staging: gasket: remove gasket_wait_sync()
    
    This function is not called anywhere, so just remove it.
    
    Also, as an added benifit, Arnd points out that it doesn't even work
    properly:
            This code won't work correct during leap seconds or a concurrent
            settimeofday() call, and it probably doesn't do what the author intended
            even for the normal case, as it passes a timeout in nanoseconds but
            reads the time using a jiffies-granularity accessor.
    
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 45013446b8c5..e51acadc0fc4 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -699,11 +699,6 @@ const struct gasket_driver_desc *gasket_get_driver_desc(struct gasket_dev *dev);
 /* Get the device structure for a given device. */
 struct device *gasket_get_device(struct gasket_dev *dev);
 
-/* Helper function, Synchronous waits on a given set of bits. */
-int gasket_wait_sync(
-	struct gasket_dev *gasket_dev, int bar, u64 offset, u64 mask, u64 val,
-	u64 timeout_ns);
-
 /* Helper function, Asynchronous waits on a given set of bits. */
 int gasket_wait_with_reschedule(
 	struct gasket_dev *gasket_dev, int bar, u64 offset, u64 mask, u64 val,

commit bf9c7a8673831acd67ad4a92b6acd85ffcde174c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 11 13:39:11 2018 +0200

    staging: gasket: remove redundant license information
    
    Now that the SPDX tag is in all gasket files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index be25d9389237..45013446b8c5 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -1,17 +1,9 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Gasket generic driver. Defines the set of data types and functions necessary
+/*
+ * Gasket generic driver. Defines the set of data types and functions necessary
  * to define a driver using the Gasket generic driver framework.
  *
  * Copyright (C) 2018 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 #ifndef __GASKET_CORE_H__
 #define __GASKET_CORE_H__

commit 2dec0644e0c8083e0a9d3bbdd11aad2d850859e9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 11 13:39:10 2018 +0200

    staging: gasket: add SPDX identifiers to all files.
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the all of the staging gasket files to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    Cc: Rob Springer <rspringer@google.com>
    Cc: John Joseph <jnjoseph@google.com>
    Cc: Ben Chan <benchan@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 5d6535a0f254..be25d9389237 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /* Gasket generic driver. Defines the set of data types and functions necessary
  * to define a driver using the Gasket generic driver framework.
  *

commit c37a192ef442fc34e9aa7c9e479f20eb4cd6f7af
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jul 6 11:39:21 2018 +0300

    Staging: Gasket: shift wrapping bug in gasket_read_modify_write_64()
    
    This function only has one caller so mask_width is 1 and mask_shift is
    32.  Shifting an int by 32 bits is undefined, but I guess on GCC it
    wraps to 0x1?  Anyway it's supposed to be 0x100000000.
    
    Fixes: 9a69f5087ccc ("drivers/staging: Gasket driver framework + Apex driver")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
index 203b9a31377b..5d6535a0f254 100644
--- a/drivers/staging/gasket/gasket_core.h
+++ b/drivers/staging/gasket/gasket_core.h
@@ -683,7 +683,7 @@ static inline void gasket_read_modify_write_64(
 	u64 mask, tmp;
 
 	tmp = gasket_dev_read_64(dev, bar, location);
-	mask = ((1 << mask_width) - 1) << mask_shift;
+	mask = ((1ULL << mask_width) - 1) << mask_shift;
 	tmp = (tmp & ~mask) | (value << mask_shift);
 	gasket_dev_write_64(dev, tmp, bar, location);
 }

commit 9a69f5087ccc20bb411025decab455836df04168
Author: Simon Que <sque@chromium.org>
Date:   Fri Jun 29 22:49:38 2018 -0400

    drivers/staging: Gasket driver framework + Apex driver
    
    The Gasket (Google ASIC Software, Kernel Extensions, and Tools) kernel
    framework is a generic, flexible system that supports thin kernel
    drivers. Gasket kernel drivers are expected to handle opening and
    closing devices, mmap'ing BAR space as requested, a small selection of
    ioctls, and handling page table translation (covered below). Any other
    functions should be handled by userspace code.
    
    The Gasket common module is not enough to run a device. In order to
    customize the Gasket code for a given piece of hardware, a device
    specific module must be created. At a minimum, this module must define a
    struct gasket_driver_desc containing the device-specific data for use by
    the framework; in addition, the module must declare an __init function
    that calls gasket_register_device with the module's gasket_driver_desc
    struct. Finally, the driver must define an exit function that calls
    gasket_unregister_device with the module's gasket_driver_desc struct.
    
    One of the core assumptions of the Gasket framework is that precisely
    one process is allowed to have an open write handle to the device node
    at any given time. (That process may, once it has one write handle, open
    any number of additional write handles.) This is accomplished by
    tracking open and close data for each driver instance.
    
    Signed-off-by: Rob Springer <rspringer@google.com>
    Signed-off-by: John Joseph <jnjoseph@google.com>
    Signed-off-by: Simon Que <sque@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gasket/gasket_core.h b/drivers/staging/gasket/gasket_core.h
new file mode 100644
index 000000000000..203b9a31377b
--- /dev/null
+++ b/drivers/staging/gasket/gasket_core.h
@@ -0,0 +1,719 @@
+/* Gasket generic driver. Defines the set of data types and functions necessary
+ * to define a driver using the Gasket generic driver framework.
+ *
+ * Copyright (C) 2018 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __GASKET_CORE_H__
+#define __GASKET_CORE_H__
+
+#include <linux/cdev.h>
+#include <linux/compiler.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+#include "gasket_constants.h"
+
+/**
+ * struct gasket_num_name - Map numbers to names.
+ * @ein_num: Number.
+ * @ein_name: Name associated with the number, a char pointer.
+ *
+ * This structure maps numbers to names. It is used to provide printable enum
+ * names, e.g {0, "DEAD"} or {1, "ALIVE"}.
+ */
+struct gasket_num_name {
+	uint snn_num;
+	const char *snn_name;
+};
+
+/*
+ * Register location for packed interrupts.
+ * Each value indicates the location of an interrupt field (in units of
+ * gasket_driver_desc->interrupt_pack_width) within the containing register.
+ * In other words, this indicates the shift to use when creating a mask to
+ * extract/set bits within a register for a given interrupt.
+ */
+enum gasket_interrupt_packing {
+	PACK_0 = 0,
+	PACK_1 = 1,
+	PACK_2 = 2,
+	PACK_3 = 3,
+	UNPACKED = 4,
+};
+
+/* Type of the interrupt supported by the device. */
+enum gasket_interrupt_type {
+	PCI_MSIX = 0,
+	PCI_MSI = 1,
+	PLATFORM_WIRE = 2,
+};
+
+/* Used to describe a Gasket interrupt. Contains an interrupt index, a register,
+ * and packing data for that interrupt. The register and packing data
+ * fields is relevant only for PCI_MSIX interrupt type and can be
+ * set to 0 for everything else.
+ */
+struct gasket_interrupt_desc {
+	/* Device-wide interrupt index/number. */
+	int index;
+	/* The register offset controlling this interrupt. */
+	u64 reg;
+	/* The location of this interrupt inside register reg, if packed. */
+	int packing;
+};
+
+/* Offsets to the wire interrupt handling registers */
+struct gasket_wire_interrupt_offsets {
+	u64 pending_bit_array;
+	u64 mask_array;
+};
+
+/*
+ * This enum is used to identify memory regions being part of the physical
+ * memory that belongs to a device.
+ */
+enum mappable_area_type {
+	PCI_BAR = 0, /* Default */
+	BUS_REGION,  /* For SYSBUS devices, i.e. AXI etc... */
+	COHERENT_MEMORY
+};
+
+/*
+ * Metadata for each BAR mapping.
+ * This struct is used so as to track PCI memory, I/O space, AXI and coherent
+ * memory area... i.e. memory objects which can be referenced in the device's
+ * mmap function.
+ */
+struct gasket_bar_data {
+	/* Virtual base address. */
+	u8 __iomem *virt_base;
+
+	/* Physical base address. */
+	ulong phys_base;
+
+	/* Length of the mapping. */
+	ulong length_bytes;
+
+	/* Type of mappable area */
+	enum mappable_area_type type;
+};
+
+/* Maintains device open ownership data. */
+struct gasket_ownership {
+	/* 1 if the device is owned, 0 otherwise. */
+	int is_owned;
+
+	/* TGID of the owner. */
+	pid_t owner;
+
+	/* Count of current device opens in write mode. */
+	int write_open_count;
+};
+
+/* Page table modes of operation. */
+enum gasket_page_table_mode {
+	/* The page table is partitionable as normal, all simple by default. */
+	GASKET_PAGE_TABLE_MODE_NORMAL,
+
+	/* All entries are always simple. */
+	GASKET_PAGE_TABLE_MODE_SIMPLE,
+
+	/* All entries are always extended. No extended bit is used. */
+	GASKET_PAGE_TABLE_MODE_EXTENDED,
+};
+
+/* Page table configuration. One per table. */
+struct gasket_page_table_config {
+	/* The identifier/index of this page table. */
+	int id;
+
+	/* The operation mode of this page table. */
+	enum gasket_page_table_mode mode;
+
+	/* Total (first-level) entries in this page table. */
+	ulong total_entries;
+
+	/* Base register for the page table. */
+	int base_reg;
+
+	/*
+	 * Register containing the extended page table. This value is unused in
+	 * GASKET_PAGE_TABLE_MODE_SIMPLE and GASKET_PAGE_TABLE_MODE_EXTENDED
+	 * modes.
+	 */
+	int extended_reg;
+
+	/* The bit index indicating whether a PT entry is extended. */
+	int extended_bit;
+};
+
+/* Maintains information about a device node. */
+struct gasket_cdev_info {
+	/* The internal name of this device. */
+	char name[GASKET_NAME_MAX];
+
+	/* Device number. */
+	dev_t devt;
+
+	/* Kernel-internal device structure. */
+	struct device *device;
+
+	/* Character device for real. */
+	struct cdev cdev;
+
+	/* Flag indicating if cdev_add has been called for the devices. */
+	int cdev_added;
+
+	/* Pointer to the overall gasket_dev struct for this device. */
+	struct gasket_dev *gasket_dev_ptr;
+
+	/* Ownership data for the device in question. */
+	struct gasket_ownership ownership;
+};
+
+/* Describes the offset and length of mmapable device BAR regions. */
+struct gasket_mappable_region {
+	u64 start;
+	u64 length_bytes;
+};
+
+/* Describe the offset, size, and permissions for a device bar. */
+struct gasket_bar_desc {
+	/*
+	 * The size of each PCI BAR range, in bytes. If a value is 0, that BAR
+	 * will not be mapped into kernel space at all.
+	 * For devices with 64 bit BARs, only elements 0, 2, and 4 should be
+	 * populated, and 1, 3, and 5 should be set to 0.
+	 * For example, for a device mapping 1M in each of the first two 64-bit
+	 * BARs, this field would be set as { 0x100000, 0, 0x100000, 0, 0, 0 }
+	 * (one number per bar_desc struct.)
+	 */
+	u64 size;
+	/* The permissions for this bar. (Should be VM_WRITE/VM_READ/VM_EXEC,
+	 * and can be or'd.) If set to GASKET_NOMAP, the bar will
+	 * not be used for mmapping.
+	 */
+	ulong permissions;
+	/* The memory address corresponding to the base of this bar, if used. */
+	u64 base;
+	/* The number of mappable regions in this bar. */
+	int num_mappable_regions;
+
+	/* The mappable subregions of this bar. */
+	const struct gasket_mappable_region *mappable_regions;
+
+	/* Type of mappable area */
+	enum mappable_area_type type;
+};
+
+/* Describes the offset, size, and permissions for a coherent buffer. */
+struct gasket_coherent_buffer_desc {
+	/* The size of the coherent buffer. */
+	u64 size;
+
+	/* The permissions for this bar. (Should be VM_WRITE/VM_READ/VM_EXEC,
+	 * and can be or'd.) If set to GASKET_NOMAP, the bar will
+	 * not be used for mmaping.
+	 */
+	ulong permissions;
+
+	/* device side address. */
+	u64 base;
+};
+
+/* Coherent buffer structure. */
+struct gasket_coherent_buffer {
+	/* Virtual base address. */
+	u8 __iomem *virt_base;
+
+	/* Physical base address. */
+	ulong phys_base;
+
+	/* Length of the mapping. */
+	ulong length_bytes;
+};
+
+/* Description of Gasket-specific permissions in the mmap field. */
+enum gasket_mapping_options { GASKET_NOMAP = 0 };
+
+/* This struct represents an undefined bar that should never be mapped. */
+#define GASKET_UNUSED_BAR                                                      \
+	{                                                                      \
+		0, GASKET_NOMAP, 0, 0, NULL, 0                                 \
+	}
+
+/* Internal data for a Gasket device. See gasket_core.c for more information. */
+struct gasket_internal_desc;
+
+#define MAX_NUM_COHERENT_PAGES 16
+
+/*
+ * Device data for Gasket device instances.
+ *
+ * This structure contains the data required to manage a Gasket device.
+ */
+struct gasket_dev {
+	/* Pointer to the internal driver description for this device. */
+	struct gasket_internal_desc *internal_desc;
+
+	/* PCI subsystem metadata. */
+	struct pci_dev *pci_dev;
+
+	/* This device's index into internal_desc->devs. */
+	int dev_idx;
+
+	/* The name of this device, as reported by the kernel. */
+	char kobj_name[GASKET_NAME_MAX];
+
+	/* Virtual address of mapped BAR memory range. */
+	struct gasket_bar_data bar_data[GASKET_NUM_BARS];
+
+	/* Coherent buffer. */
+	struct gasket_coherent_buffer coherent_buffer;
+
+	/* Number of page tables for this device. */
+	int num_page_tables;
+
+	/* Address translations. Page tables have a private implementation. */
+	struct gasket_page_table *page_table[GASKET_MAX_NUM_PAGE_TABLES];
+
+	/* Interrupt data for this device. */
+	struct gasket_interrupt_data *interrupt_data;
+
+	/* Status for this device - GASKET_STATUS_ALIVE or _DEAD. */
+	uint status;
+
+	/* Number of times this device has been reset. */
+	uint reset_count;
+
+	/* Dev information for the cdev node. */
+	struct gasket_cdev_info dev_info;
+
+	/* Hardware revision value for this device. */
+	int hardware_revision;
+
+	/*
+	 * Device-specific data; allocated in gasket_driver_desc.add_dev_cb()
+	 * and freed in gasket_driver_desc.remove_dev_cb().
+	 */
+	void *cb_data;
+
+	/* Protects access to per-device data (i.e. this structure). */
+	struct mutex mutex;
+
+	/* cdev hash tracking/membership structure, Accel and legacy. */
+	/* Unused until Accel is upstreamed. */
+	struct hlist_node hlist_node;
+	struct hlist_node legacy_hlist_node;
+};
+
+/* Type of the ioctl permissions check callback. See below. */
+typedef int (*gasket_ioctl_permissions_cb_t)(
+	struct file *filp, uint cmd, ulong arg);
+
+/*
+ * Device type descriptor.
+ *
+ * This structure contains device-specific data needed to identify and address a
+ * type of device to be administered via the Gasket generic driver.
+ *
+ * Device IDs are per-driver. In other words, two drivers using the Gasket
+ * framework will each have a distinct device 0 (for example).
+ */
+struct gasket_driver_desc {
+	/* The name of this device type. */
+	const char *name;
+
+	/* The name of this specific device model. */
+	const char *chip_model;
+
+	/* The version of the chip specified in chip_model. */
+	const char *chip_version;
+
+	/* The version of this driver: "1.0.0", "2.1.3", etc. */
+	const char *driver_version;
+
+	/*
+	 * Non-zero if we should create "legacy" (device and device-class-
+	 * specific) character devices and sysfs nodes.
+	 */
+	/* Unused until Accel is upstreamed. */
+	int legacy_support;
+
+	/* Major and minor numbers identifying the device. */
+	int major, minor;
+
+	/* Module structure for this driver. */
+	struct module *module;
+
+	/* PCI ID table. */
+	const struct pci_device_id *pci_id_table;
+
+	/* The number of page tables handled by this driver. */
+	int num_page_tables;
+
+	/* The index of the bar containing the page tables. */
+	int page_table_bar_index;
+
+	/* Registers used to control each page table. */
+	const struct gasket_page_table_config *page_table_configs;
+
+	/* The bit index indicating whether a PT entry is extended. */
+	int page_table_extended_bit;
+
+	/*
+	 * Legacy mmap address adjusment for legacy devices only. Should be 0
+	 * for any new device.
+	 */
+	ulong legacy_mmap_address_offset;
+
+	/* Set of 6 bar descriptions that describe all PCIe bars.
+	 * Note that BUS/AXI devices (i.e. non PCI devices) use those.
+	 */
+	struct gasket_bar_desc bar_descriptions[GASKET_NUM_BARS];
+
+	/*
+	 * Coherent buffer description.
+	 */
+	struct gasket_coherent_buffer_desc coherent_buffer_description;
+
+	/* Offset of wire interrupt registers. */
+	const struct gasket_wire_interrupt_offsets *wire_interrupt_offsets;
+
+	/* Interrupt type. (One of gasket_interrupt_type). */
+	int interrupt_type;
+
+	/* Index of the bar containing the interrupt registers to program. */
+	int interrupt_bar_index;
+
+	/* Number of interrupts in the gasket_interrupt_desc array */
+	int num_interrupts;
+
+	/* Description of the interrupts for this device. */
+	const struct gasket_interrupt_desc *interrupts;
+
+	/*
+	 * If this device packs multiple interrupt->MSI-X mappings into a
+	 * single register (i.e., "uses packed interrupts"), only a single bit
+	 * width is supported for each interrupt mapping (unpacked/"full-width"
+	 * interrupts are always supported). This value specifies that width. If
+	 * packed interrupts are not used, this value is ignored.
+	 */
+	int interrupt_pack_width;
+
+	/* Driver callback functions - all may be NULL */
+	/*
+	 * add_dev_cb: Callback when a device is found.
+	 * @dev: The gasket_dev struct for this driver instance.
+	 *
+	 * This callback should initialize the device-specific cb_data.
+	 * Called when a device is found by the driver,
+	 * before any BAR ranges have been mapped. If this call fails (returns
+	 * nonzero), remove_dev_cb will be called.
+	 *
+	 */
+	int (*add_dev_cb)(struct gasket_dev *dev);
+
+	/*
+	 * remove_dev_cb: Callback for when a device is removed from the system.
+	 * @dev: The gasket_dev struct for this driver instance.
+	 *
+	 * This callback should free data allocated in add_dev_cb.
+	 * Called immediately before a device is unregistered by the driver.
+	 * All framework-managed resources will have been cleaned up by the time
+	 * this callback is invoked (PCI BARs, character devices, ...).
+	 */
+	int (*remove_dev_cb)(struct gasket_dev *dev);
+
+	/*
+	 * device_open_cb: Callback for when a device node is opened in write
+	 * mode.
+	 * @dev: The gasket_dev struct for this driver instance.
+	 *
+	 * This callback should perform device-specific setup that needs to
+	 * occur only once when a device is first opened.
+	 */
+	int (*device_open_cb)(struct gasket_dev *dev);
+
+	/*
+	 * device_release_cb: Callback when a device is closed.
+	 * @gasket_dev: The gasket_dev struct for this driver instance.
+	 *
+	 * This callback is called whenever a device node fd is closed, as
+	 * opposed to device_close_cb, which is called when the _last_
+	 * descriptor for an open file is closed. This call is intended to
+	 * handle any per-user or per-fd cleanup.
+	 */
+	int (*device_release_cb)(
+		struct gasket_dev *gasket_dev, struct file *file);
+
+	/*
+	 * device_close_cb: Callback for when a device node is closed for the
+	 * last time.
+	 * @dev: The gasket_dev struct for this driver instance.
+	 *
+	 * This callback should perform device-specific cleanup that only
+	 * needs to occur when the last reference to a device node is closed.
+	 *
+	 * This call is intended to handle and device-wide cleanup, as opposed
+	 * to per-fd cleanup (which should be handled by device_release_cb).
+	 */
+	int (*device_close_cb)(struct gasket_dev *dev);
+
+	/*
+	 * enable_dev_cb: Callback immediately before enabling the device.
+	 * @dev: Pointer to the gasket_dev struct for this driver instance.
+	 *
+	 * This callback is invoked after the device has been added and all BAR
+	 * spaces mapped, immediately before registering and enabling the
+	 * [character] device via cdev_add. If this call fails (returns
+	 * nonzero), disable_dev_cb will be called.
+	 *
+	 * Note that cdev are initialized but not active
+	 * (cdev_add has not yet been called) when this callback is invoked.
+	 */
+	int (*enable_dev_cb)(struct gasket_dev *dev);
+
+	/*
+	 * disable_dev_cb: Callback immediately after disabling the device.
+	 * @dev: Pointer to the gasket_dev struct for this driver instance.
+	 *
+	 * Called during device shutdown, immediately after disabling device
+	 * operations via cdev_del.
+	 */
+	int (*disable_dev_cb)(struct gasket_dev *dev);
+
+	/*
+	 * sysfs_setup_cb: Callback to set up driver-specific sysfs nodes.
+	 * @dev: Pointer to the gasket_dev struct for this device.
+	 *
+	 * Called just before enable_dev_cb.
+	 *
+	 */
+	int (*sysfs_setup_cb)(struct gasket_dev *dev);
+
+	/*
+	 * sysfs_cleanup_cb: Callback to clean up driver-specific sysfs nodes.
+	 * @dev: Pointer to the gasket_dev struct for this device.
+	 *
+	 * Called just before disable_dev_cb.
+	 *
+	 */
+	int (*sysfs_cleanup_cb)(struct gasket_dev *dev);
+
+	/*
+	 * get_mappable_regions_cb: Get descriptors of mappable device memory.
+	 * @gasket_dev: Pointer to the struct gasket_dev for this device.
+	 * @bar_index: BAR for which to retrieve memory ranges.
+	 * @mappable_regions: Out-pointer to the list of mappable regions on the
+	 * device/BAR for this process.
+	 * @num_mappable_regions: Out-pointer for the size of mappable_regions.
+	 *
+	 * Called when handling mmap(), this callback is used to determine which
+	 * regions of device memory may be mapped by the current process. This
+	 * information is then compared to mmap request to determine which
+	 * regions to actually map.
+	 */
+	int (*get_mappable_regions_cb)(
+		struct gasket_dev *gasket_dev, int bar_index,
+		struct gasket_mappable_region **mappable_regions,
+		int *num_mappable_regions);
+
+	/*
+	 * ioctl_permissions_cb: Check permissions for generic ioctls.
+	 * @filp: File structure pointer describing this node usage session.
+	 * @cmd: ioctl number to handle.
+	 * @arg: ioctl-specific data pointer.
+	 *
+	 * Returns 1 if the ioctl may be executed, 0 otherwise. If this callback
+	 * isn't specified a default routine will be used, that only allows the
+	 * original device opener (i.e, the "owner") to execute state-affecting
+	 * ioctls.
+	 */
+	gasket_ioctl_permissions_cb_t ioctl_permissions_cb;
+
+	/*
+	 * ioctl_handler_cb: Callback to handle device-specific ioctls.
+	 * @filp: File structure pointer describing this node usage session.
+	 * @cmd: ioctl number to handle.
+	 * @arg: ioctl-specific data pointer.
+	 *
+	 * Invoked whenever an ioctl is called that the generic Gasket
+	 * framework doesn't support. If no cb is registered, unknown ioctls
+	 * return -EINVAL. Should return an error status (either -EINVAL or
+	 * the error result of the ioctl being handled).
+	 */
+	long (*ioctl_handler_cb)(struct file *filp, uint cmd, ulong arg);
+
+	/*
+	 * device_status_cb: Callback to determine device health.
+	 * @dev: Pointer to the gasket_dev struct for this device.
+	 *
+	 * Called to determine if the device is healthy or not. Should return
+	 * a member of the gasket_status_type enum.
+	 *
+	 */
+	int (*device_status_cb)(struct gasket_dev *dev);
+
+	/*
+	 * hardware_revision_cb: Get the device's hardware revision.
+	 * @dev: Pointer to the gasket_dev struct for this device.
+	 *
+	 * Called to determine the reported rev of the physical hardware.
+	 * Revision should be >0. A negative return value is an error.
+	 */
+	int (*hardware_revision_cb)(struct gasket_dev *dev);
+
+	/*
+	 * device_reset_cb: Reset the hardware in question.
+	 * @dev: Pointer to the gasket_dev structure for this device.
+	 * @type: Integer representing reset type. (All
+	 * Gasket resets have an integer representing their type
+	 * defined in (device)_ioctl.h; the specific resets are
+	 * device-dependent, but are handled in the device-specific
+	 * callback anyways.)
+	 *
+	 * Called by reset ioctls. This function should not
+	 * lock the gasket_dev mutex. It should return 0 on success
+	 * and an error on failure.
+	 */
+	int (*device_reset_cb)(struct gasket_dev *dev, uint reset_type);
+};
+
+/*
+ * Register the specified device type with the framework.
+ * @desc: Populated/initialized device type descriptor.
+ *
+ * This function does _not_ take ownership of desc; the underlying struct must
+ * exist until the matching call to gasket_unregister_device.
+ * This function should be called from your driver's module_init function.
+ */
+int gasket_register_device(const struct gasket_driver_desc *desc);
+
+/*
+ * Remove the specified device type from the framework.
+ * @desc: Descriptor for the device type to unregister; it should have been
+ *        passed to gasket_register_device in a previous call.
+ *
+ * This function should be called from your driver's module_exit function.
+ */
+void gasket_unregister_device(const struct gasket_driver_desc *desc);
+
+/*
+ * Reset the Gasket device.
+ * @gasket_dev: Gasket device struct.
+ * @reset_type: Uint representing requested reset type. Should be
+ * valid in the underlying callback.
+ *
+ * Calls device_reset_cb. Returns 0 on success and an error code othewrise.
+ * gasket_reset_nolock will not lock the mutex, gasket_reset will.
+ *
+ */
+int gasket_reset(struct gasket_dev *gasket_dev, uint reset_type);
+int gasket_reset_nolock(struct gasket_dev *gasket_dev, uint reset_type);
+
+/*
+ * Memory management functions. These will likely be spun off into their own
+ * file in the future.
+ */
+
+/* Unmaps the specified mappable region from a VMA. */
+int gasket_mm_unmap_region(
+	const struct gasket_dev *gasket_dev, struct vm_area_struct *vma,
+	const struct gasket_mappable_region *map_region);
+
+/*
+ * Get the ioctl permissions callback.
+ * @gasket_dev: Gasket device structure.
+ */
+gasket_ioctl_permissions_cb_t gasket_get_ioctl_permissions_cb(
+	struct gasket_dev *gasket_dev);
+
+/**
+ * Lookup a name by number in a num_name table.
+ * @num: Number to lookup.
+ * @table: Array of num_name structures, the table for the lookup.
+ *
+ */
+const char *gasket_num_name_lookup(
+	uint num, const struct gasket_num_name *table);
+
+/* Handy inlines */
+static inline ulong gasket_dev_read_64(
+	struct gasket_dev *gasket_dev, int bar, ulong location)
+{
+	return readq(&gasket_dev->bar_data[bar].virt_base[location]);
+}
+
+static inline void gasket_dev_write_64(
+	struct gasket_dev *dev, u64 value, int bar, ulong location)
+{
+	writeq(value, &dev->bar_data[bar].virt_base[location]);
+}
+
+static inline void gasket_dev_write_32(
+	struct gasket_dev *dev, u32 value, int bar, ulong location)
+{
+	writel(value, &dev->bar_data[bar].virt_base[location]);
+}
+
+static inline u32 gasket_dev_read_32(
+	struct gasket_dev *dev, int bar, ulong location)
+{
+	return readl(&dev->bar_data[bar].virt_base[location]);
+}
+
+static inline void gasket_read_modify_write_64(
+	struct gasket_dev *dev, int bar, ulong location, u64 value,
+	u64 mask_width, u64 mask_shift)
+{
+	u64 mask, tmp;
+
+	tmp = gasket_dev_read_64(dev, bar, location);
+	mask = ((1 << mask_width) - 1) << mask_shift;
+	tmp = (tmp & ~mask) | (value << mask_shift);
+	gasket_dev_write_64(dev, tmp, bar, location);
+}
+
+static inline void gasket_read_modify_write_32(
+	struct gasket_dev *dev, int bar, ulong location, u32 value,
+	u32 mask_width, u32 mask_shift)
+{
+	u32 mask, tmp;
+
+	tmp = gasket_dev_read_32(dev, bar, location);
+	mask = ((1 << mask_width) - 1) << mask_shift;
+	tmp = (tmp & ~mask) | (value << mask_shift);
+	gasket_dev_write_32(dev, tmp, bar, location);
+}
+
+/* Get the Gasket driver structure for a given device. */
+const struct gasket_driver_desc *gasket_get_driver_desc(struct gasket_dev *dev);
+
+/* Get the device structure for a given device. */
+struct device *gasket_get_device(struct gasket_dev *dev);
+
+/* Helper function, Synchronous waits on a given set of bits. */
+int gasket_wait_sync(
+	struct gasket_dev *gasket_dev, int bar, u64 offset, u64 mask, u64 val,
+	u64 timeout_ns);
+
+/* Helper function, Asynchronous waits on a given set of bits. */
+int gasket_wait_with_reschedule(
+	struct gasket_dev *gasket_dev, int bar, u64 offset, u64 mask, u64 val,
+	u64 max_retries, u64 delay_ms);
+
+#endif /* __GASKET_CORE_H__ */
