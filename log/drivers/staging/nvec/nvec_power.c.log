commit d6d69c824efb134918c373343f4ea841467ffcf6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 11 11:08:43 2018 +0100

    staging: nvec: remove redundant license text
    
    Now that the SPDX tag is in all drivers/staging/nvec/ files, that
    identifies the license in a specific and legally-defined manner.  So the
    extra GPL text wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index 94ac2c2def0a..0e861c4bfcbf 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -6,11 +6,6 @@
  *
  * Authors:  Ilya Petrov <ilya.muromec@gmail.com>
  *           Marc Dietrich <marvin24@gmx.de>
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
  */
 
 #include <linux/module.h>

commit 971bcfca1f8db18681668b970f2e7cc6cb531eae
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 11 11:08:42 2018 +0100

    staging: nvec: add SPDX identifier.
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the staging nvec driver to have a proper SPDX identifiers, based
    on the license text in the file itself.  The SPDX identifier is a
    legally binding shorthand, which can be used instead of the full boiler
    plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index 3b144a9ea055..94ac2c2def0a 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * nvec_power: power supply driver for a NVIDIA compliant embedded controller
  *

commit 5a30502c869e81dc0e577eecde097d9090f08734
Author: Matthew Smith <matthew11235@outlook.com>
Date:   Fri Dec 16 17:16:47 2016 +0000

    staging: nvec: fix indent issue in nvec_power.c
    
    Fixes "WARNING: Statements should start on a tabstop" from checkpatch.pl
    
    Signed-off-by: Matthew Smith <matthew11235@outlook.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index fcbb0fa03765..3b144a9ea055 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -442,7 +442,7 @@ static struct platform_driver nvec_power_driver = {
 	.remove = nvec_power_remove,
 	.driver = {
 		   .name = "nvec-power",
-		   }
+	}
 };
 
 module_platform_driver(nvec_power_driver);

commit a3dac5a35cc54fa983e3de56ec010734c87315c4
Author: Ben Marsh <bmarsh94@gmail.com>
Date:   Tue Mar 15 19:37:54 2016 +0100

    Staging: nvec: removes a useless cast on a void pointer
    
    Remove an unnecessary cast on a void pointer in nvec_power.c
    
    Signed-off-by: Ben Marsh <bmarsh94@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index b4a0545e8806..fcbb0fa03765 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -90,7 +90,7 @@ static int nvec_power_notifier(struct notifier_block *nb,
 {
 	struct nvec_power *power =
 	    container_of(nb, struct nvec_power, notifier);
-	struct bat_response *res = (struct bat_response *)data;
+	struct bat_response *res = data;
 
 	if (event_type != NVEC_SYS)
 		return NOTIFY_DONE;
@@ -126,7 +126,7 @@ static int nvec_power_bat_notifier(struct notifier_block *nb,
 {
 	struct nvec_power *power =
 	    container_of(nb, struct nvec_power, notifier);
-	struct bat_response *res = (struct bat_response *)data;
+	struct bat_response *res = data;
 	int status_changed = 0;
 
 	if (event_type != NVEC_BAT)

commit 66ad85d13f56b464ca91de269b067fcc9b5f3313
Author: Simon Guinot <simon.guinot@sequanux.org>
Date:   Wed Dec 9 08:14:06 2015 +0100

    staging: nvec: fix block comments
    
    This patch fixes a couple of checkpatch warnings about block comments.
    
    Signed-off-by: Simon Guinot <simon.guinot@sequanux.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index 04a7402ae2df..b4a0545e8806 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -207,8 +207,10 @@ static int nvec_power_bat_notifier(struct notifier_block *nb,
 	case TYPE:
 		memcpy(power->bat_type, &res->plc, res->length - 2);
 		power->bat_type[res->length - 2] = '\0';
-		/* this differs a little from the spec
-		   fill in more if you find some */
+		/*
+		 * This differs a little from the spec fill in more if you find
+		 * some.
+		 */
 		if (!strncmp(power->bat_type, "Li", 30))
 			power->bat_type_enum = POWER_SUPPLY_TECHNOLOGY_LION;
 		else
@@ -356,12 +358,14 @@ static void nvec_power_poll(struct work_struct *work)
 	if (counter >= ARRAY_SIZE(bat_iter))
 		counter = 0;
 
-/* AC status via sys req */
+	/* AC status via sys req */
 	nvec_write_async(power->nvec, buf, 2);
 	msleep(100);
 
-/* select a battery request function via round robin
-   doing it all at once seems to overload the power supply */
+	/*
+	 * Select a battery request function via round robin doing it all at
+	 * once seems to overload the power supply.
+	 */
 	buf[0] = NVEC_BAT;
 	buf[1] = bat_iter[counter++];
 	nvec_write_async(power->nvec, buf, 2);

commit b79013b2449c23f1f505bdf39c5a6c330338b244
Merge: c4be50eee2bd c610f7f772aa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 13 17:37:33 2015 -0700

    Merge tag 'staging-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging driver updates from Greg KH:
     "Here's the big staging driver patchset for 4.1-rc1.
    
      There's a lot of patches here, the Outreachy application period
      happened during this development cycle, so that means that there was a
      lot of cleanup patches accepted.  Other than the normal coding style
      and sparse fixes here, there are some driver updates and work toward
      making some of the drivers into "mergable" shape (like the Unisys
      drivers.)
    
      All of these have been in linux-next for a while"
    
    * tag 'staging-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (1214 commits)
      staging: lustre: orthography & coding style
      staging: lustre: lnet: lnet: fix error return code
      staging: lustre: fix sparse warning
      Revert "Staging: sm750fb: Fix C99 Comments"
      Staging: rtl8192u: use correct array for debug output
      staging: rtl8192e: Remove dead code
      staging: rtl8192e: Comment cleanup (style/format)
      staging: rtl8192e: Fix indentation in rtllib_rx_auth_resp()
      staging: rtl8192e: Decrease nesting of rtllib_rx_auth_resp()
      staging: rtl8192e: Divide rtllib_rx_auth()
      staging: rtl8192e: Fix PRINTK_WITHOUT_KERN_LEVEL warnings
      staging: rtl8192e: Fix DO_WHILE_MACRO_WITH_TRAILING_SEMICOLON warning
      staging: rtl8192e: Fix BRACES warning
      staging: rtl8192e: Fix LINE_CONTINUATIONS warning
      staging: rtl8192e: Fix UNNECESSARY_PARENTHESES warnings
      staging: rtl8192e: remove unused EXPORT_SYMBOL_RSL macro
      staging: rtl8192e: Fix RETURN_VOID warnings
      staging: rtl8192e: Fix UNNECESSARY_ELSE warning
      staging: rtl8723au: Remove unneeded comments
      staging: rtl8723au: Use __func__ in trace logs
      ...

commit 4c42d979816a0bc1d87aaabc4089d857942ddfe2
Author: Somya Anand <somyaanand214@gmail.com>
Date:   Mon Mar 16 19:34:11 2015 +0530

    Staging: nvec: use !x instead of x == NULL
    
    Functions like devm_kzalloc, kmalloc_array, devm_ioremap,
    usb_alloc_urb, alloc_netdev return NULL as a return value on failure.
    Generally, When NULL represents failure, !x is commonly used.
    
    This patch cleans up the tests on the results of these functions, thereby
    using !x instead of x == NULL or NULL == x. This is done via following
    coccinelle script:
    @prob_7@
    identifier x;
    statement S;
    @@
    
    (
     x = devm_kzalloc(...);
    |
     x = usb_alloc_urb(...);
    |
     x = kmalloc_array(...);
    |
     x = devm_ioremap(...);
    |
     x = alloc_netdev(...);
    )
     ...
    - if(NULL == x)
    + if(!x)
            S
    Further we have used isomorphism characteristics of coccinelle to
    indicate x == NULL and NULL == x are equivalent. This is done via
    following iso script.
    
    Expression
    @ is_null @ expression X; @@
    X == NULL <=> NULL == X
    
    Signed-off-by: Somya Anand <somyaanand214@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index 6a1459d4f8fb..3621b661aba8 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -378,7 +378,7 @@ static int nvec_power_probe(struct platform_device *pdev)
 	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
 
 	power = devm_kzalloc(&pdev->dev, sizeof(struct nvec_power), GFP_NOWAIT);
-	if (power == NULL)
+	if (!power)
 		return -ENOMEM;
 
 	dev_set_drvdata(&pdev->dev, power);

commit 297d716f6260cc9421d971b124ca196b957ee458
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Thu Mar 12 08:44:11 2015 +0100

    power_supply: Change ownership from driver to core
    
    Change the ownership of power_supply structure from each driver
    implementing the class to the power supply core.
    
    The patch changes power_supply_register() function thus all drivers
    implementing power supply class are adjusted.
    
    Each driver provides the implementation of power supply. However it
    should not be the owner of power supply class instance because it is
    exposed by core to other subsystems with power_supply_get_by_name().
    These other subsystems have no knowledge when the driver will unregister
    the power supply. This leads to several issues when driver is unbound -
    mostly because user of power supply accesses freed memory.
    
    Instead let the core own the instance of struct 'power_supply'.  Other
    users of this power supply will still access valid memory because it
    will be freed when device reference count reaches 0. Currently this
    means "it will leak" but power_supply_put() call in next patches will
    solve it.
    
    This solves invalid memory references in following race condition
    scenario:
    
    Thread 1: charger manager
    Thread 2: power supply driver, used by charger manager
    
    THREAD 1 (charger manager)         THREAD 2 (power supply driver)
    ==========================         ==============================
    psy = power_supply_get_by_name()
                                       Driver unbind, .remove
                                         power_supply_unregister()
                                         Device fully removed
    psy->get_property()
    
    The 'get_property' call is executed in invalid context because the driver was
    unbound and struct 'power_supply' memory was freed.
    
    This could be observed easily with charger manager driver (here compiled
    with max17040 fuel gauge):
    
    $ cat /sys/devices/virtual/power_supply/cm-battery/capacity &
    $ echo "1-0036" > /sys/bus/i2c/drivers/max17040/unbind
    [   55.725123] Unable to handle kernel NULL pointer dereference at virtual address 00000000
    [   55.732584] pgd = d98d4000
    [   55.734060] [00000000] *pgd=5afa2831, *pte=00000000, *ppte=00000000
    [   55.740318] Internal error: Oops: 80000007 [#1] PREEMPT SMP ARM
    [   55.746210] Modules linked in:
    [   55.749259] CPU: 1 PID: 2936 Comm: cat Tainted: G        W       3.19.0-rc1-next-20141226-00048-gf79f475f3c44-dirty #1496
    [   55.760190] Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [   55.766270] task: d9b76f00 ti: daf54000 task.ti: daf54000
    [   55.771647] PC is at 0x0
    [   55.774182] LR is at charger_get_property+0x2f4/0x36c
    [   55.779201] pc : [<00000000>]    lr : [<c034b0b4>]    psr: 60000013
    [   55.779201] sp : daf55e90  ip : 00000003  fp : 00000000
    [   55.790657] r10: 00000000  r9 : c06e2878  r8 : d9b26c68
    [   55.795865] r7 : dad81610  r6 : daec7410  r5 : daf55ebc  r4 : 00000000
    [   55.802367] r3 : 00000000  r2 : daf55ebc  r1 : 0000002a  r0 : d9b26c68
    [   55.808879] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
    [   55.815994] Control: 10c5387d  Table: 598d406a  DAC: 00000015
    [   55.821723] Process cat (pid: 2936, stack limit = 0xdaf54210)
    [   55.827451] Stack: (0xdaf55e90 to 0xdaf56000)
    [   55.831795] 5e80:                                     60000013 c01459c4 0000002a c06f8ef8
    [   55.839956] 5ea0: db651000 c06f8ef8 daebac00 c04cb668 daebac08 c0346864 00000000 c01459c4
    [   55.848115] 5ec0: d99eaa80 c06f8ef8 00000fff 00001000 db651000 c027f25c c027f240 d99eaa80
    [   55.856274] 5ee0: d9a06c00 c0146218 daf55f18 00001000 d99eaa80 db4c18c0 00000001 00000001
    [   55.864468] 5f00: daf55f80 c0144c78 c0144c54 c0107f90 00015000 d99eaab0 00000000 00000000
    [   55.872603] 5f20: 000051c7 00000000 db4c18c0 c04a9370 00015000 00001000 daf55f80 00001000
    [   55.880763] 5f40: daf54000 00015000 00000000 c00e53dc db4c18c0 c00e548c 0000000d 00008124
    [   55.888937] 5f60: 00000001 00000000 00000000 db4c18c0 db4c18c0 00001000 00015000 c00e5550
    [   55.897099] 5f80: 00000000 00000000 00001000 00001000 00015000 00000003 00000003 c000f364
    [   55.905239] 5fa0: 00000000 c000f1a0 00001000 00015000 00000003 00015000 00001000 0001333c
    [   55.913399] 5fc0: 00001000 00015000 00000003 00000003 00000002 00000000 00000000 00000000
    [   55.921560] 5fe0: 7fffe000 be999850 0000a225 b6f3c19c 60000010 00000003 00000000 00000000
    [   55.929744] [<c034b0b4>] (charger_get_property) from [<c0346864>] (power_supply_show_property+0x48/0x20c)
    [   55.939286] [<c0346864>] (power_supply_show_property) from [<c027f25c>] (dev_attr_show+0x1c/0x48)
    [   55.948130] [<c027f25c>] (dev_attr_show) from [<c0146218>] (sysfs_kf_seq_show+0x84/0x104)
    [   55.956298] [<c0146218>] (sysfs_kf_seq_show) from [<c0144c78>] (kernfs_seq_show+0x24/0x28)
    [   55.964536] [<c0144c78>] (kernfs_seq_show) from [<c0107f90>] (seq_read+0x1b0/0x484)
    [   55.972172] [<c0107f90>] (seq_read) from [<c00e53dc>] (__vfs_read+0x18/0x4c)
    [   55.979188] [<c00e53dc>] (__vfs_read) from [<c00e548c>] (vfs_read+0x7c/0x100)
    [   55.986304] [<c00e548c>] (vfs_read) from [<c00e5550>] (SyS_read+0x40/0x8c)
    [   55.993164] [<c00e5550>] (SyS_read) from [<c000f1a0>] (ret_fast_syscall+0x0/0x48)
    [   56.000626] Code: bad PC value
    [   56.011652] ---[ end trace 7b64343fbdae8ef1 ]---
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    
    [for the nvec part]
    Reviewed-by: Marc Dietrich <marvin24@gmx.de>
    
    [for compal-laptop.c]
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    
    [for the mfd part]
    Acked-by: Lee Jones <lee.jones@linaro.org>
    
    [for the hid part]
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    
    [for the acpi part]
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index 4bfa84672818..30b66c3c9b73 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -82,8 +82,8 @@ struct bat_response {
 	};
 };
 
-static struct power_supply nvec_bat_psy;
-static struct power_supply nvec_psy;
+static struct power_supply *nvec_bat_psy;
+static struct power_supply *nvec_psy;
 
 static int nvec_power_notifier(struct notifier_block *nb,
 			       unsigned long event_type, void *data)
@@ -98,7 +98,7 @@ static int nvec_power_notifier(struct notifier_block *nb,
 	if (res->sub_type == 0) {
 		if (power->on != res->plu) {
 			power->on = res->plu;
-			power_supply_changed(&nvec_psy);
+			power_supply_changed(nvec_psy);
 		}
 		return NOTIFY_STOP;
 	}
@@ -167,7 +167,7 @@ static int nvec_power_bat_notifier(struct notifier_block *nb,
 		}
 		power->bat_cap = res->plc[1];
 		if (status_changed)
-			power_supply_changed(&nvec_bat_psy);
+			power_supply_changed(nvec_bat_psy);
 		break;
 	case VOLTAGE:
 		power->bat_voltage_now = res->plu * 1000;
@@ -225,7 +225,7 @@ static int nvec_power_get_property(struct power_supply *psy,
 				   enum power_supply_property psp,
 				   union power_supply_propval *val)
 {
-	struct nvec_power *power = dev_get_drvdata(psy->dev->parent);
+	struct nvec_power *power = dev_get_drvdata(psy->dev.parent);
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_ONLINE:
@@ -241,7 +241,7 @@ static int nvec_battery_get_property(struct power_supply *psy,
 				     enum power_supply_property psp,
 				     union power_supply_propval *val)
 {
-	struct nvec_power *power = dev_get_drvdata(psy->dev->parent);
+	struct nvec_power *power = dev_get_drvdata(psy->dev.parent);
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_STATUS:
@@ -323,7 +323,7 @@ static char *nvec_power_supplied_to[] = {
 	"battery",
 };
 
-static struct power_supply nvec_bat_psy = {
+static const struct power_supply_desc nvec_bat_psy_desc = {
 	.name = "battery",
 	.type = POWER_SUPPLY_TYPE_BATTERY,
 	.properties = nvec_battery_props,
@@ -331,7 +331,7 @@ static struct power_supply nvec_bat_psy = {
 	.get_property = nvec_battery_get_property,
 };
 
-static struct power_supply nvec_psy = {
+static const struct power_supply_desc nvec_psy_desc = {
 	.name = "ac",
 	.type = POWER_SUPPLY_TYPE_MAINS,
 	.properties = nvec_power_props,
@@ -371,7 +371,8 @@ static void nvec_power_poll(struct work_struct *work)
 
 static int nvec_power_probe(struct platform_device *pdev)
 {
-	struct power_supply *psy;
+	struct power_supply **psy;
+	const struct power_supply_desc *psy_desc;
 	struct nvec_power *power;
 	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
 	struct power_supply_config psy_cfg = {};
@@ -386,6 +387,7 @@ static int nvec_power_probe(struct platform_device *pdev)
 	switch (pdev->id) {
 	case AC:
 		psy = &nvec_psy;
+		psy_desc = &nvec_psy_desc;
 		psy_cfg.supplied_to = nvec_power_supplied_to;
 		psy_cfg.num_supplicants = ARRAY_SIZE(nvec_power_supplied_to);
 
@@ -396,6 +398,7 @@ static int nvec_power_probe(struct platform_device *pdev)
 		break;
 	case BAT:
 		psy = &nvec_bat_psy;
+		psy_desc = &nvec_bat_psy_desc;
 
 		power->notifier.notifier_call = nvec_power_bat_notifier;
 		break;
@@ -408,7 +411,9 @@ static int nvec_power_probe(struct platform_device *pdev)
 	if (pdev->id == BAT)
 		get_bat_mfg_data(power);
 
-	return power_supply_register(&pdev->dev, psy, &psy_cfg);
+	*psy = power_supply_register(&pdev->dev, psy_desc, &psy_cfg);
+
+	return PTR_ERR_OR_ZERO(*psy);
 }
 
 static int nvec_power_remove(struct platform_device *pdev)
@@ -419,10 +424,10 @@ static int nvec_power_remove(struct platform_device *pdev)
 	nvec_unregister_notifier(power->nvec, &power->notifier);
 	switch (pdev->id) {
 	case AC:
-		power_supply_unregister(&nvec_psy);
+		power_supply_unregister(nvec_psy);
 		break;
 	case BAT:
-		power_supply_unregister(&nvec_bat_psy);
+		power_supply_unregister(nvec_bat_psy);
 	}
 
 	return 0;

commit 2dc9215d7c94f7f9f34ccf8b1710ad73d82f6216
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Thu Mar 12 08:44:02 2015 +0100

    power_supply: Move run-time configuration to separate structure
    
    Add new structure 'power_supply_config' for holding run-time
    initialization data like of_node, supplies and private driver data.
    
    The power_supply_register() function is changed so all power supply
    drivers need updating.
    
    When registering the power supply this new 'power_supply_config' should be
    used instead of directly initializing 'struct power_supply'. This allows
    changing the ownership of power_supply structure from driver to the
    power supply core in next patches.
    
    When a driver does not use of_node or supplies then it should use NULL
    as config. If driver uses of_node or supplies then it should allocate
    config on stack and initialize it with proper values.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    
    [for the nvec part]
    Reviewed-by: Marc Dietrich <marvin24@gmx.de>
    
    [for drivers/platform/x86/compal-laptop.c]
    Reviewed-by: Darren Hart <dvhart@linux.intel.com>
    
    [for drivers/hid/*]
    Reviewed-by: Jiri Kosina <jkosina@suse.cz>
    
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index 6a1459d4f8fb..4bfa84672818 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -334,8 +334,6 @@ static struct power_supply nvec_bat_psy = {
 static struct power_supply nvec_psy = {
 	.name = "ac",
 	.type = POWER_SUPPLY_TYPE_MAINS,
-	.supplied_to = nvec_power_supplied_to,
-	.num_supplicants = ARRAY_SIZE(nvec_power_supplied_to),
 	.properties = nvec_power_props,
 	.num_properties = ARRAY_SIZE(nvec_power_props),
 	.get_property = nvec_power_get_property,
@@ -376,6 +374,7 @@ static int nvec_power_probe(struct platform_device *pdev)
 	struct power_supply *psy;
 	struct nvec_power *power;
 	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
+	struct power_supply_config psy_cfg = {};
 
 	power = devm_kzalloc(&pdev->dev, sizeof(struct nvec_power), GFP_NOWAIT);
 	if (power == NULL)
@@ -387,6 +386,8 @@ static int nvec_power_probe(struct platform_device *pdev)
 	switch (pdev->id) {
 	case AC:
 		psy = &nvec_psy;
+		psy_cfg.supplied_to = nvec_power_supplied_to;
+		psy_cfg.num_supplicants = ARRAY_SIZE(nvec_power_supplied_to);
 
 		power->notifier.notifier_call = nvec_power_notifier;
 
@@ -407,7 +408,7 @@ static int nvec_power_probe(struct platform_device *pdev)
 	if (pdev->id == BAT)
 		get_bat_mfg_data(power);
 
-	return power_supply_register(&pdev->dev, psy);
+	return power_supply_register(&pdev->dev, psy, &psy_cfg);
 }
 
 static int nvec_power_remove(struct platform_device *pdev)

commit d5dbc0245a7da65b95fc14f99ccfc5f1fad078f0
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:41 2014 +0200

    staging: nvec: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index 6446e151866f..6a1459d4f8fb 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -432,7 +432,6 @@ static struct platform_driver nvec_power_driver = {
 	.remove = nvec_power_remove,
 	.driver = {
 		   .name = "nvec-power",
-		   .owner = THIS_MODULE,
 		   }
 };
 

commit fa7996178650377994b1e42ea6c00df304d48065
Author: Pawel Lebioda <pawel.lebioda89@gmail.com>
Date:   Thu Jul 3 21:15:57 2014 +0200

    staging: nvec: insert blank lines after declarations
    
    This patch fixes coding style warnings reported by checkpatch.pl:
    "Missing a blank line after declarations".
    
    Signed-off-by: Pawel Lebioda <pawel.lebioda89@gmail.com>
    Acked-by: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index aacfcd6954a3..6446e151866f 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -226,6 +226,7 @@ static int nvec_power_get_property(struct power_supply *psy,
 				   union power_supply_propval *val)
 {
 	struct nvec_power *power = dev_get_drvdata(psy->dev->parent);
+
 	switch (psp) {
 	case POWER_SUPPLY_PROP_ONLINE:
 		val->intval = power->on;

commit c2b62f60f67e0375c09d3c385ba90999d39d3dce
Author: Marc Dietrich <marvin24@gmx.de>
Date:   Mon Apr 29 23:14:52 2013 +0200

    staging: nvec: cleanup childs on remove
    
    Disable device functions and unregister notifier if available. The
    serio device must not be "kzallocated". Otherwise serio_unregister_port
    will fail because the device is already freed.
    
    Signed-off-by: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index 296f7b9a8c8c..aacfcd6954a3 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -414,6 +414,7 @@ static int nvec_power_remove(struct platform_device *pdev)
 	struct nvec_power *power = platform_get_drvdata(pdev);
 
 	cancel_delayed_work_sync(&power->poller);
+	nvec_unregister_notifier(power->nvec, &power->notifier);
 	switch (pdev->id) {
 	case AC:
 		power_supply_unregister(&nvec_psy);

commit 93eff83ff1640bef8062568687b5e0e41a0d4c42
Author: Marc Dietrich <marvin24@gmx.de>
Date:   Sun Jan 27 17:43:43 2013 +0100

    staging: nvec: cleanup the string mess
    
    Replace the various command strings by named constants.
    
    Signed-off-by: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index b7b6d54f58ec..296f7b9a8c8c 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -22,6 +22,8 @@
 
 #include "nvec.h"
 
+#define GET_SYSTEM_STATUS 0x00
+
 struct nvec_power {
 	struct notifier_block notifier;
 	struct delayed_work poller;
@@ -111,7 +113,7 @@ static const int bat_init[] = {
 static void get_bat_mfg_data(struct nvec_power *power)
 {
 	int i;
-	char buf[] = { '\x02', '\x00' };
+	char buf[] = { NVEC_BAT, SLOT_STATUS };
 
 	for (i = 0; i < ARRAY_SIZE(bat_init); i++) {
 		buf[1] = bat_init[i];
@@ -348,7 +350,7 @@ static int const bat_iter[] = {
 
 static void nvec_power_poll(struct work_struct *work)
 {
-	char buf[] = { '\x01', '\x00' };
+	char buf[] = { NVEC_SYS, GET_SYSTEM_STATUS };
 	struct nvec_power *power = container_of(work, struct nvec_power,
 						poller.work);
 
@@ -361,7 +363,7 @@ static void nvec_power_poll(struct work_struct *work)
 
 /* select a battery request function via round robin
    doing it all at once seems to overload the power supply */
-	buf[0] = '\x02';	/* battery */
+	buf[0] = NVEC_BAT;
 	buf[1] = bat_iter[counter++];
 	nvec_write_async(power->nvec, buf, 2);
 

commit 1a6a8a8414f740f1dfde762837eeb3f2ce835919
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:41 2012 -0500

    staging: nvec: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Julian Andres Klode <jak@jak-linux.org>
    Acked-by: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index 6c702ed7463d..b7b6d54f58ec 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -407,7 +407,7 @@ static int nvec_power_probe(struct platform_device *pdev)
 	return power_supply_register(&pdev->dev, psy);
 }
 
-static int __devexit nvec_power_remove(struct platform_device *pdev)
+static int nvec_power_remove(struct platform_device *pdev)
 {
 	struct nvec_power *power = platform_get_drvdata(pdev);
 

commit 46620803c309d2bc10814b903b39d7647057b440
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:22:07 2012 -0500

    staging: nvec: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Julian Andres Klode <jak@jak-linux.org>
    Acked-by: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index 99e06f661c19..6c702ed7463d 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -368,7 +368,7 @@ static void nvec_power_poll(struct work_struct *work)
 	schedule_delayed_work(to_delayed_work(work), msecs_to_jiffies(5000));
 };
 
-static int __devinit nvec_power_probe(struct platform_device *pdev)
+static int nvec_power_probe(struct platform_device *pdev)
 {
 	struct power_supply *psy;
 	struct nvec_power *power;

commit 44b90a3fbcac0f233b71b4041fa76ea325caca33
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:20:55 2012 -0500

    staging: nvec: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Julian Andres Klode <jak@jak-linux.org>
    Acked-by: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index cc8ccd75e7f4..99e06f661c19 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -425,7 +425,7 @@ static int __devexit nvec_power_remove(struct platform_device *pdev)
 
 static struct platform_driver nvec_power_driver = {
 	.probe = nvec_power_probe,
-	.remove = __devexit_p(nvec_power_remove),
+	.remove = nvec_power_remove,
 	.driver = {
 		   .name = "nvec-power",
 		   .owner = THIS_MODULE,

commit 3cdde3a3d55e64e6d1ae3465701c8d9f226775f3
Author: Marc Dietrich <marvin24@gmx.de>
Date:   Sun Jun 24 23:25:21 2012 +0200

    staging: nvec: add remove function to nvec childs
    
    This patch cleanups registered devices on remove.
    
    Signed-off-by: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index 063f6d5e8ab1..cc8ccd75e7f4 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -407,8 +407,25 @@ static int __devinit nvec_power_probe(struct platform_device *pdev)
 	return power_supply_register(&pdev->dev, psy);
 }
 
+static int __devexit nvec_power_remove(struct platform_device *pdev)
+{
+	struct nvec_power *power = platform_get_drvdata(pdev);
+
+	cancel_delayed_work_sync(&power->poller);
+	switch (pdev->id) {
+	case AC:
+		power_supply_unregister(&nvec_psy);
+		break;
+	case BAT:
+		power_supply_unregister(&nvec_bat_psy);
+	}
+
+	return 0;
+}
+
 static struct platform_driver nvec_power_driver = {
 	.probe = nvec_power_probe,
+	.remove = __devexit_p(nvec_power_remove),
 	.driver = {
 		   .name = "nvec-power",
 		   .owner = THIS_MODULE,

commit 9891b1ce6276912c54f66b7b0c8c1bcc42ca75eb
Author: Marc Dietrich <marvin24@gmx.de>
Date:   Sun Jun 24 23:25:18 2012 +0200

    staging: nvec: cleanup driver registration
    
    This patch simplifies code by using the module_platform_driver
    macro.
    
    Signed-off-by: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index a23e5485c279..063f6d5e8ab1 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -415,12 +415,7 @@ static struct platform_driver nvec_power_driver = {
 		   }
 };
 
-static int __init nvec_power_init(void)
-{
-	return platform_driver_register(&nvec_power_driver);
-}
-
-module_init(nvec_power_init);
+module_platform_driver(nvec_power_driver);
 
 MODULE_AUTHOR("Ilya Petrov <ilya.muromec@gmail.com>");
 MODULE_LICENSE("GPL");

commit f5e3352e5185ef37700da9a51c333559381fe8fd
Author: Marc Dietrich <marvin24@gmx.de>
Date:   Sun Jun 24 23:25:16 2012 +0200

    staging: nvec: convert to devm_ functions
    
    This patch cleanups the nvec and its childs by replacing calls to
    resource allocations by their devm_* equivalents.
    
    Signed-off-by: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index dfa966f6189d..a23e5485c279 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -371,10 +371,13 @@ static void nvec_power_poll(struct work_struct *work)
 static int __devinit nvec_power_probe(struct platform_device *pdev)
 {
 	struct power_supply *psy;
-	struct nvec_power *power =
-	    kzalloc(sizeof(struct nvec_power), GFP_NOWAIT);
+	struct nvec_power *power;
 	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
 
+	power = devm_kzalloc(&pdev->dev, sizeof(struct nvec_power), GFP_NOWAIT);
+	if (power == NULL)
+		return -ENOMEM;
+
 	dev_set_drvdata(&pdev->dev, power);
 	power->nvec = nvec;
 
@@ -393,7 +396,6 @@ static int __devinit nvec_power_probe(struct platform_device *pdev)
 		power->notifier.notifier_call = nvec_power_bat_notifier;
 		break;
 	default:
-		kfree(power);
 		return -ENODEV;
 	}
 

commit 162c7d8c4be2d599583c42c2a8fe99bed6d87f67
Author: Marc Dietrich <marvin24@gmx.de>
Date:   Tue Sep 27 19:00:40 2011 +0200

    staging: nvec: coding style fixes / add copyright notice
    
    This patch fixes coding style and adds copyright notices.
    
    Signed-off-by: Marc Dietrich <marvin24@gmx.de>
    [jak@jak-linux.org: Merge later cleanup into that patch]
    Signed-off-by: Julian Andres Klode <jak@jak-linux.org>
    Acked-by: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index df164add837b..dfa966f6189d 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -1,3 +1,17 @@
+/*
+ * nvec_power: power supply driver for a NVIDIA compliant embedded controller
+ *
+ * Copyright (C) 2011 The AC100 Kernel Team <ac100@lists.launchpad.net>
+ *
+ * Authors:  Ilya Petrov <ilya.muromec@gmail.com>
+ *           Marc Dietrich <marvin24@gmx.de>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/err.h>
@@ -5,10 +19,10 @@
 #include <linux/slab.h>
 #include <linux/workqueue.h>
 #include <linux/delay.h>
+
 #include "nvec.h"
 
-struct nvec_power
-{
+struct nvec_power {
 	struct notifier_block notifier;
 	struct delayed_work poller;
 	struct nvec_chip *nvec;
@@ -58,7 +72,8 @@ struct bat_response {
 	u8 length;
 	u8 sub_type;
 	u8 status;
-	union { /* payload */
+	/* payload */
+	union {
 		char plc[30];
 		u16 plu;
 		s16 pls;
@@ -69,18 +84,17 @@ static struct power_supply nvec_bat_psy;
 static struct power_supply nvec_psy;
 
 static int nvec_power_notifier(struct notifier_block *nb,
-				 unsigned long event_type, void *data)
+			       unsigned long event_type, void *data)
 {
-	struct nvec_power *power = container_of(nb, struct nvec_power, notifier);
+	struct nvec_power *power =
+	    container_of(nb, struct nvec_power, notifier);
 	struct bat_response *res = (struct bat_response *)data;
 
 	if (event_type != NVEC_SYS)
 		return NOTIFY_DONE;
 
-	if(res->sub_type == 0)
-	{
-		if (power->on != res->plu)
-		{
+	if (res->sub_type == 0) {
+		if (power->on != res->plu) {
 			power->on = res->plu;
 			power_supply_changed(&nvec_psy);
 		}
@@ -89,8 +103,7 @@ static int nvec_power_notifier(struct notifier_block *nb,
 	return NOTIFY_OK;
 }
 
-static const int bat_init[] =
-{
+static const int bat_init[] = {
 	LAST_FULL_CHARGE_CAPACITY, DESIGN_CAPACITY, CRITICAL_CAPACITY,
 	MANUFACTURER, MODEL, TYPE,
 };
@@ -100,116 +113,115 @@ static void get_bat_mfg_data(struct nvec_power *power)
 	int i;
 	char buf[] = { '\x02', '\x00' };
 
-	for (i = 0; i < ARRAY_SIZE(bat_init); i++)
-	{
+	for (i = 0; i < ARRAY_SIZE(bat_init); i++) {
 		buf[1] = bat_init[i];
 		nvec_write_async(power->nvec, buf, 2);
 	}
 }
 
 static int nvec_power_bat_notifier(struct notifier_block *nb,
-				 unsigned long event_type, void *data)
+				   unsigned long event_type, void *data)
 {
-	struct nvec_power *power = container_of(nb, struct nvec_power, notifier);
+	struct nvec_power *power =
+	    container_of(nb, struct nvec_power, notifier);
 	struct bat_response *res = (struct bat_response *)data;
 	int status_changed = 0;
 
 	if (event_type != NVEC_BAT)
 		return NOTIFY_DONE;
 
-	switch(res->sub_type)
-	{
-		case SLOT_STATUS:
-			if (res->plc[0] & 1)
-			{
-				if (power->bat_present == 0)
-				{
-					status_changed = 1;
-					get_bat_mfg_data(power);
-				}
-
-				power->bat_present = 1;
-
-				switch ((res->plc[0] >> 1) & 3)
-				{
-					case 0:
-						power->bat_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
-						break;
-					case 1:
-						power->bat_status = POWER_SUPPLY_STATUS_CHARGING;
-						break;
-					case 2:
-						power->bat_status = POWER_SUPPLY_STATUS_DISCHARGING;
-						break;
-					default:
-						power->bat_status = POWER_SUPPLY_STATUS_UNKNOWN;
-				}
-			} else {
-				if (power->bat_present == 1)
-					status_changed = 1;
-
-				power->bat_present = 0;
+	switch (res->sub_type) {
+	case SLOT_STATUS:
+		if (res->plc[0] & 1) {
+			if (power->bat_present == 0) {
+				status_changed = 1;
+				get_bat_mfg_data(power);
+			}
+
+			power->bat_present = 1;
+
+			switch ((res->plc[0] >> 1) & 3) {
+			case 0:
+				power->bat_status =
+				    POWER_SUPPLY_STATUS_NOT_CHARGING;
+				break;
+			case 1:
+				power->bat_status =
+				    POWER_SUPPLY_STATUS_CHARGING;
+				break;
+			case 2:
+				power->bat_status =
+				    POWER_SUPPLY_STATUS_DISCHARGING;
+				break;
+			default:
 				power->bat_status = POWER_SUPPLY_STATUS_UNKNOWN;
 			}
-			power->bat_cap = res->plc[1];
-			if (status_changed)
-				power_supply_changed(&nvec_bat_psy);
-			break;
-		case VOLTAGE:
-			power->bat_voltage_now = res->plu * 1000;
-			break;
-		case TIME_REMAINING:
-			power->time_remain = res->plu * 3600;
-			break;
-		case CURRENT:
-			power->bat_current_now = res->pls * 1000;
-			break;
-		case AVERAGE_CURRENT:
-			power->bat_current_avg = res->pls * 1000;
-			break;
-		case CAPACITY_REMAINING:
-			power->capacity_remain = res->plu * 1000;
-			break;
-		case LAST_FULL_CHARGE_CAPACITY:
-			power->charge_last_full = res->plu * 1000;
-			break;
-		case DESIGN_CAPACITY:
-			power->charge_full_design = res->plu * 1000;
-			break;
-		case CRITICAL_CAPACITY:
-			power->critical_capacity = res->plu * 1000;
-			break;
-		case TEMPERATURE:
-			power->bat_temperature = res->plu - 2732;
-			break;
-		case MANUFACTURER:
-			memcpy(power->bat_manu, &res->plc, res->length-2);
-			power->bat_model[res->length-2] = '\0';
-			break;
-		case MODEL:
-			memcpy(power->bat_model, &res->plc, res->length-2);
-			power->bat_model[res->length-2] = '\0';
-			break;
-		case TYPE:
-			memcpy(power->bat_type, &res->plc, res->length-2);
-			power->bat_type[res->length-2] = '\0';
-			/* this differs a little from the spec
-			   fill in more if you find some */
-			if (!strncmp(power->bat_type, "Li", 30))
-				power->bat_type_enum = POWER_SUPPLY_TECHNOLOGY_LION;
-			else
-				power->bat_type_enum = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;
-			break;
-		default:
-			return NOTIFY_STOP;
+		} else {
+			if (power->bat_present == 1)
+				status_changed = 1;
+
+			power->bat_present = 0;
+			power->bat_status = POWER_SUPPLY_STATUS_UNKNOWN;
+		}
+		power->bat_cap = res->plc[1];
+		if (status_changed)
+			power_supply_changed(&nvec_bat_psy);
+		break;
+	case VOLTAGE:
+		power->bat_voltage_now = res->plu * 1000;
+		break;
+	case TIME_REMAINING:
+		power->time_remain = res->plu * 3600;
+		break;
+	case CURRENT:
+		power->bat_current_now = res->pls * 1000;
+		break;
+	case AVERAGE_CURRENT:
+		power->bat_current_avg = res->pls * 1000;
+		break;
+	case CAPACITY_REMAINING:
+		power->capacity_remain = res->plu * 1000;
+		break;
+	case LAST_FULL_CHARGE_CAPACITY:
+		power->charge_last_full = res->plu * 1000;
+		break;
+	case DESIGN_CAPACITY:
+		power->charge_full_design = res->plu * 1000;
+		break;
+	case CRITICAL_CAPACITY:
+		power->critical_capacity = res->plu * 1000;
+		break;
+	case TEMPERATURE:
+		power->bat_temperature = res->plu - 2732;
+		break;
+	case MANUFACTURER:
+		memcpy(power->bat_manu, &res->plc, res->length - 2);
+		power->bat_model[res->length - 2] = '\0';
+		break;
+	case MODEL:
+		memcpy(power->bat_model, &res->plc, res->length - 2);
+		power->bat_model[res->length - 2] = '\0';
+		break;
+	case TYPE:
+		memcpy(power->bat_type, &res->plc, res->length - 2);
+		power->bat_type[res->length - 2] = '\0';
+		/* this differs a little from the spec
+		   fill in more if you find some */
+		if (!strncmp(power->bat_type, "Li", 30))
+			power->bat_type_enum = POWER_SUPPLY_TECHNOLOGY_LION;
+		else
+			power->bat_type_enum = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;
+		break;
+	default:
+		return NOTIFY_STOP;
 	}
 
 	return NOTIFY_STOP;
 }
 
 static int nvec_power_get_property(struct power_supply *psy,
-				enum power_supply_property psp,
-				union power_supply_propval *val)
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
 {
 	struct nvec_power *power = dev_get_drvdata(psy->dev->parent);
 	switch (psp) {
@@ -223,61 +235,60 @@ static int nvec_power_get_property(struct power_supply *psy,
 }
 
 static int nvec_battery_get_property(struct power_supply *psy,
-				enum power_supply_property psp,
-				union power_supply_propval *val)
+				     enum power_supply_property psp,
+				     union power_supply_propval *val)
 {
 	struct nvec_power *power = dev_get_drvdata(psy->dev->parent);
 
-	switch(psp)
-	{
-		case POWER_SUPPLY_PROP_STATUS:
-			val->intval = power->bat_status;
-			break;
-		case POWER_SUPPLY_PROP_CAPACITY:
-			val->intval = power->bat_cap;
-			break;
-		case POWER_SUPPLY_PROP_PRESENT:
-			val->intval = power->bat_present;
-			break;
-		case POWER_SUPPLY_PROP_VOLTAGE_NOW:
-			val->intval = power->bat_voltage_now;
-			break;
-		case POWER_SUPPLY_PROP_CURRENT_NOW:
-			val->intval = power->bat_current_now;
-			break;
-		case POWER_SUPPLY_PROP_CURRENT_AVG:
-			val->intval = power->bat_current_avg;
-			break;
-		case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
-			val->intval = power->time_remain;
-			break;
-		case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
-			val->intval = power->charge_full_design;
-			break;
-		case POWER_SUPPLY_PROP_CHARGE_FULL:
-			val->intval = power->charge_last_full;
-			break;
-		case POWER_SUPPLY_PROP_CHARGE_EMPTY:
-			val->intval = power->critical_capacity;
-			break;
-		case POWER_SUPPLY_PROP_CHARGE_NOW:
-			val->intval = power->capacity_remain;
-			break;
-		case POWER_SUPPLY_PROP_TEMP:
-			val->intval = power->bat_temperature;
-			break;
-		case POWER_SUPPLY_PROP_MANUFACTURER:
-			val->strval = power->bat_manu;
-			break;
-		case POWER_SUPPLY_PROP_MODEL_NAME:
-			val->strval = power->bat_model;
-			break;
-		case POWER_SUPPLY_PROP_TECHNOLOGY:
-			val->intval = power->bat_type_enum;
-			break;
-		default:
-			return -EINVAL;
-		}
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = power->bat_status;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = power->bat_cap;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = power->bat_present;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = power->bat_voltage_now;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = power->bat_current_now;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = power->bat_current_avg;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
+		val->intval = power->time_remain;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = power->charge_full_design;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		val->intval = power->charge_last_full;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_EMPTY:
+		val->intval = power->critical_capacity;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+		val->intval = power->capacity_remain;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = power->bat_temperature;
+		break;
+	case POWER_SUPPLY_PROP_MANUFACTURER:
+		val->strval = power->bat_manu;
+		break;
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = power->bat_model;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = power->bat_type_enum;
+		break;
+	default:
+		return -EINVAL;
+	}
 	return 0;
 }
 
@@ -310,11 +321,11 @@ static char *nvec_power_supplied_to[] = {
 };
 
 static struct power_supply nvec_bat_psy = {
-	.name		= "battery",
-	.type		= POWER_SUPPLY_TYPE_BATTERY,
-	.properties	= nvec_battery_props,
-	.num_properties	= ARRAY_SIZE(nvec_battery_props),
-	.get_property	= nvec_battery_get_property,
+	.name = "battery",
+	.type = POWER_SUPPLY_TYPE_BATTERY,
+	.properties = nvec_battery_props,
+	.num_properties = ARRAY_SIZE(nvec_battery_props),
+	.get_property = nvec_battery_get_property,
 };
 
 static struct power_supply nvec_psy = {
@@ -327,9 +338,8 @@ static struct power_supply nvec_psy = {
 	.get_property = nvec_power_get_property,
 };
 
-static int counter = 0;
-static int const bat_iter[] =
-{
+static int counter;
+static int const bat_iter[] = {
 	SLOT_STATUS, VOLTAGE, CURRENT, CAPACITY_REMAINING,
 #ifdef EC_FULL_DIAG
 	AVERAGE_CURRENT, TEMPERATURE, TIME_REMAINING,
@@ -340,7 +350,7 @@ static void nvec_power_poll(struct work_struct *work)
 {
 	char buf[] = { '\x01', '\x00' };
 	struct nvec_power *power = container_of(work, struct nvec_power,
-		 poller.work);
+						poller.work);
 
 	if (counter >= ARRAY_SIZE(bat_iter))
 		counter = 0;
@@ -351,19 +361,18 @@ static void nvec_power_poll(struct work_struct *work)
 
 /* select a battery request function via round robin
    doing it all at once seems to overload the power supply */
-	buf[0] = '\x02'; /* battery */
-        buf[1] = bat_iter[counter++];
+	buf[0] = '\x02';	/* battery */
+	buf[1] = bat_iter[counter++];
 	nvec_write_async(power->nvec, buf, 2);
 
-//	printk("%02x %02x\n", buf[0], buf[1]);
-
 	schedule_delayed_work(to_delayed_work(work), msecs_to_jiffies(5000));
 };
 
 static int __devinit nvec_power_probe(struct platform_device *pdev)
 {
 	struct power_supply *psy;
-	struct nvec_power *power = kzalloc(sizeof(struct nvec_power), GFP_NOWAIT);
+	struct nvec_power *power =
+	    kzalloc(sizeof(struct nvec_power), GFP_NOWAIT);
 	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
 
 	dev_set_drvdata(&pdev->dev, power);
@@ -381,7 +390,7 @@ static int __devinit nvec_power_probe(struct platform_device *pdev)
 	case BAT:
 		psy = &nvec_bat_psy;
 
-                power->notifier.notifier_call = nvec_power_bat_notifier;
+		power->notifier.notifier_call = nvec_power_bat_notifier;
 		break;
 	default:
 		kfree(power);
@@ -398,14 +407,13 @@ static int __devinit nvec_power_probe(struct platform_device *pdev)
 
 static struct platform_driver nvec_power_driver = {
 	.probe = nvec_power_probe,
-//	.remove = __devexit_p(nvec_power_remove),
 	.driver = {
-		.name = "nvec-power",
-		.owner = THIS_MODULE,
-	}
+		   .name = "nvec-power",
+		   .owner = THIS_MODULE,
+		   }
 };
 
-static int __init nvec_power_init(void) 
+static int __init nvec_power_init(void)
 {
 	return platform_driver_register(&nvec_power_driver);
 }

commit 32890b983086136fef8721363a2d3860f337ad53
Author: Marc Dietrich <marvin24@gmx.de>
Date:   Thu May 19 16:34:42 2011 +0200

    Staging: initial version of the nvec driver
    
    This is an implementation of a NVidia compliant embedded controller
    protocol driver. It is used on some ARM-Tegra boards for device
    communication.
    
    Signed-off-by: Marc Dietrich <marvin24@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
new file mode 100644
index 000000000000..df164add837b
--- /dev/null
+++ b/drivers/staging/nvec/nvec_power.c
@@ -0,0 +1,418 @@
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/power_supply.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include "nvec.h"
+
+struct nvec_power
+{
+	struct notifier_block notifier;
+	struct delayed_work poller;
+	struct nvec_chip *nvec;
+	int on;
+	int bat_present;
+	int bat_status;
+	int bat_voltage_now;
+	int bat_current_now;
+	int bat_current_avg;
+	int time_remain;
+	int charge_full_design;
+	int charge_last_full;
+	int critical_capacity;
+	int capacity_remain;
+	int bat_temperature;
+	int bat_cap;
+	int bat_type_enum;
+	char bat_manu[30];
+	char bat_model[30];
+	char bat_type[30];
+};
+
+enum {
+	SLOT_STATUS,
+	VOLTAGE,
+	TIME_REMAINING,
+	CURRENT,
+	AVERAGE_CURRENT,
+	AVERAGING_TIME_INTERVAL,
+	CAPACITY_REMAINING,
+	LAST_FULL_CHARGE_CAPACITY,
+	DESIGN_CAPACITY,
+	CRITICAL_CAPACITY,
+	TEMPERATURE,
+	MANUFACTURER,
+	MODEL,
+	TYPE,
+};
+
+enum {
+	AC,
+	BAT,
+};
+
+struct bat_response {
+	u8 event_type;
+	u8 length;
+	u8 sub_type;
+	u8 status;
+	union { /* payload */
+		char plc[30];
+		u16 plu;
+		s16 pls;
+	};
+};
+
+static struct power_supply nvec_bat_psy;
+static struct power_supply nvec_psy;
+
+static int nvec_power_notifier(struct notifier_block *nb,
+				 unsigned long event_type, void *data)
+{
+	struct nvec_power *power = container_of(nb, struct nvec_power, notifier);
+	struct bat_response *res = (struct bat_response *)data;
+
+	if (event_type != NVEC_SYS)
+		return NOTIFY_DONE;
+
+	if(res->sub_type == 0)
+	{
+		if (power->on != res->plu)
+		{
+			power->on = res->plu;
+			power_supply_changed(&nvec_psy);
+		}
+		return NOTIFY_STOP;
+	}
+	return NOTIFY_OK;
+}
+
+static const int bat_init[] =
+{
+	LAST_FULL_CHARGE_CAPACITY, DESIGN_CAPACITY, CRITICAL_CAPACITY,
+	MANUFACTURER, MODEL, TYPE,
+};
+
+static void get_bat_mfg_data(struct nvec_power *power)
+{
+	int i;
+	char buf[] = { '\x02', '\x00' };
+
+	for (i = 0; i < ARRAY_SIZE(bat_init); i++)
+	{
+		buf[1] = bat_init[i];
+		nvec_write_async(power->nvec, buf, 2);
+	}
+}
+
+static int nvec_power_bat_notifier(struct notifier_block *nb,
+				 unsigned long event_type, void *data)
+{
+	struct nvec_power *power = container_of(nb, struct nvec_power, notifier);
+	struct bat_response *res = (struct bat_response *)data;
+	int status_changed = 0;
+
+	if (event_type != NVEC_BAT)
+		return NOTIFY_DONE;
+
+	switch(res->sub_type)
+	{
+		case SLOT_STATUS:
+			if (res->plc[0] & 1)
+			{
+				if (power->bat_present == 0)
+				{
+					status_changed = 1;
+					get_bat_mfg_data(power);
+				}
+
+				power->bat_present = 1;
+
+				switch ((res->plc[0] >> 1) & 3)
+				{
+					case 0:
+						power->bat_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+						break;
+					case 1:
+						power->bat_status = POWER_SUPPLY_STATUS_CHARGING;
+						break;
+					case 2:
+						power->bat_status = POWER_SUPPLY_STATUS_DISCHARGING;
+						break;
+					default:
+						power->bat_status = POWER_SUPPLY_STATUS_UNKNOWN;
+				}
+			} else {
+				if (power->bat_present == 1)
+					status_changed = 1;
+
+				power->bat_present = 0;
+				power->bat_status = POWER_SUPPLY_STATUS_UNKNOWN;
+			}
+			power->bat_cap = res->plc[1];
+			if (status_changed)
+				power_supply_changed(&nvec_bat_psy);
+			break;
+		case VOLTAGE:
+			power->bat_voltage_now = res->plu * 1000;
+			break;
+		case TIME_REMAINING:
+			power->time_remain = res->plu * 3600;
+			break;
+		case CURRENT:
+			power->bat_current_now = res->pls * 1000;
+			break;
+		case AVERAGE_CURRENT:
+			power->bat_current_avg = res->pls * 1000;
+			break;
+		case CAPACITY_REMAINING:
+			power->capacity_remain = res->plu * 1000;
+			break;
+		case LAST_FULL_CHARGE_CAPACITY:
+			power->charge_last_full = res->plu * 1000;
+			break;
+		case DESIGN_CAPACITY:
+			power->charge_full_design = res->plu * 1000;
+			break;
+		case CRITICAL_CAPACITY:
+			power->critical_capacity = res->plu * 1000;
+			break;
+		case TEMPERATURE:
+			power->bat_temperature = res->plu - 2732;
+			break;
+		case MANUFACTURER:
+			memcpy(power->bat_manu, &res->plc, res->length-2);
+			power->bat_model[res->length-2] = '\0';
+			break;
+		case MODEL:
+			memcpy(power->bat_model, &res->plc, res->length-2);
+			power->bat_model[res->length-2] = '\0';
+			break;
+		case TYPE:
+			memcpy(power->bat_type, &res->plc, res->length-2);
+			power->bat_type[res->length-2] = '\0';
+			/* this differs a little from the spec
+			   fill in more if you find some */
+			if (!strncmp(power->bat_type, "Li", 30))
+				power->bat_type_enum = POWER_SUPPLY_TECHNOLOGY_LION;
+			else
+				power->bat_type_enum = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;
+			break;
+		default:
+			return NOTIFY_STOP;
+	}
+
+	return NOTIFY_STOP;
+}
+
+static int nvec_power_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct nvec_power *power = dev_get_drvdata(psy->dev->parent);
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = power->on;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int nvec_battery_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct nvec_power *power = dev_get_drvdata(psy->dev->parent);
+
+	switch(psp)
+	{
+		case POWER_SUPPLY_PROP_STATUS:
+			val->intval = power->bat_status;
+			break;
+		case POWER_SUPPLY_PROP_CAPACITY:
+			val->intval = power->bat_cap;
+			break;
+		case POWER_SUPPLY_PROP_PRESENT:
+			val->intval = power->bat_present;
+			break;
+		case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+			val->intval = power->bat_voltage_now;
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_NOW:
+			val->intval = power->bat_current_now;
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_AVG:
+			val->intval = power->bat_current_avg;
+			break;
+		case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
+			val->intval = power->time_remain;
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+			val->intval = power->charge_full_design;
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_FULL:
+			val->intval = power->charge_last_full;
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_EMPTY:
+			val->intval = power->critical_capacity;
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_NOW:
+			val->intval = power->capacity_remain;
+			break;
+		case POWER_SUPPLY_PROP_TEMP:
+			val->intval = power->bat_temperature;
+			break;
+		case POWER_SUPPLY_PROP_MANUFACTURER:
+			val->strval = power->bat_manu;
+			break;
+		case POWER_SUPPLY_PROP_MODEL_NAME:
+			val->strval = power->bat_model;
+			break;
+		case POWER_SUPPLY_PROP_TECHNOLOGY:
+			val->intval = power->bat_type_enum;
+			break;
+		default:
+			return -EINVAL;
+		}
+	return 0;
+}
+
+static enum power_supply_property nvec_power_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static enum power_supply_property nvec_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+#ifdef EC_FULL_DIAG
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,
+#endif
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CHARGE_EMPTY,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_MANUFACTURER,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+};
+
+static char *nvec_power_supplied_to[] = {
+	"battery",
+};
+
+static struct power_supply nvec_bat_psy = {
+	.name		= "battery",
+	.type		= POWER_SUPPLY_TYPE_BATTERY,
+	.properties	= nvec_battery_props,
+	.num_properties	= ARRAY_SIZE(nvec_battery_props),
+	.get_property	= nvec_battery_get_property,
+};
+
+static struct power_supply nvec_psy = {
+	.name = "ac",
+	.type = POWER_SUPPLY_TYPE_MAINS,
+	.supplied_to = nvec_power_supplied_to,
+	.num_supplicants = ARRAY_SIZE(nvec_power_supplied_to),
+	.properties = nvec_power_props,
+	.num_properties = ARRAY_SIZE(nvec_power_props),
+	.get_property = nvec_power_get_property,
+};
+
+static int counter = 0;
+static int const bat_iter[] =
+{
+	SLOT_STATUS, VOLTAGE, CURRENT, CAPACITY_REMAINING,
+#ifdef EC_FULL_DIAG
+	AVERAGE_CURRENT, TEMPERATURE, TIME_REMAINING,
+#endif
+};
+
+static void nvec_power_poll(struct work_struct *work)
+{
+	char buf[] = { '\x01', '\x00' };
+	struct nvec_power *power = container_of(work, struct nvec_power,
+		 poller.work);
+
+	if (counter >= ARRAY_SIZE(bat_iter))
+		counter = 0;
+
+/* AC status via sys req */
+	nvec_write_async(power->nvec, buf, 2);
+	msleep(100);
+
+/* select a battery request function via round robin
+   doing it all at once seems to overload the power supply */
+	buf[0] = '\x02'; /* battery */
+        buf[1] = bat_iter[counter++];
+	nvec_write_async(power->nvec, buf, 2);
+
+//	printk("%02x %02x\n", buf[0], buf[1]);
+
+	schedule_delayed_work(to_delayed_work(work), msecs_to_jiffies(5000));
+};
+
+static int __devinit nvec_power_probe(struct platform_device *pdev)
+{
+	struct power_supply *psy;
+	struct nvec_power *power = kzalloc(sizeof(struct nvec_power), GFP_NOWAIT);
+	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
+
+	dev_set_drvdata(&pdev->dev, power);
+	power->nvec = nvec;
+
+	switch (pdev->id) {
+	case AC:
+		psy = &nvec_psy;
+
+		power->notifier.notifier_call = nvec_power_notifier;
+
+		INIT_DELAYED_WORK(&power->poller, nvec_power_poll);
+		schedule_delayed_work(&power->poller, msecs_to_jiffies(5000));
+		break;
+	case BAT:
+		psy = &nvec_bat_psy;
+
+                power->notifier.notifier_call = nvec_power_bat_notifier;
+		break;
+	default:
+		kfree(power);
+		return -ENODEV;
+	}
+
+	nvec_register_notifier(nvec, &power->notifier, NVEC_SYS);
+
+	if (pdev->id == BAT)
+		get_bat_mfg_data(power);
+
+	return power_supply_register(&pdev->dev, psy);
+}
+
+static struct platform_driver nvec_power_driver = {
+	.probe = nvec_power_probe,
+//	.remove = __devexit_p(nvec_power_remove),
+	.driver = {
+		.name = "nvec-power",
+		.owner = THIS_MODULE,
+	}
+};
+
+static int __init nvec_power_init(void) 
+{
+	return platform_driver_register(&nvec_power_driver);
+}
+
+module_init(nvec_power_init);
+
+MODULE_AUTHOR("Ilya Petrov <ilya.muromec@gmail.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("NVEC battery and AC driver");
+MODULE_ALIAS("platform:nvec-power");
