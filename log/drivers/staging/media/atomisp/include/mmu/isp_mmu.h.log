commit f5fbb83feba2a91c4b19389ba995175d71c51df9
Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Date:   Sat May 30 07:38:24 2020 +0200

    media: atomisp: add SPDX headers
    
    This driver is licensed under GPL 2.0, as stated inside their
    headers.
    
    Add the proper tag there. We should probably latter cleanup
    the reduntant licensing text, but this could be done later,
    after we get rid of other abstraction layers.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/staging/media/atomisp/include/mmu/isp_mmu.h b/drivers/staging/media/atomisp/include/mmu/isp_mmu.h
index d9662c515236..268560954792 100644
--- a/drivers/staging/media/atomisp/include/mmu/isp_mmu.h
+++ b/drivers/staging/media/atomisp/include/mmu/isp_mmu.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Support for Medifield PNW Camera Imaging ISP subsystem.
  *

commit 1985e93802d271bd658833585fffb896c4976910
Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Date:   Wed May 20 07:55:45 2020 +0200

    media: atomisp: isp_mmu: don't use kmem_cache
    
    Instead of using it only if system memory is below 2GB,
    don't use it at all. The problem is that the code there is not
    compatible anymore with modern Kernels:
    
    [  179.552797] virt_to_cache: Object is not a Slab page!
    [  179.552821] WARNING: CPU: 0 PID: 1414 at mm/slab.h:475 cache_from_obj+0xab/0xf0
    [  179.552824] Modules linked in: ccm(E) nft_fib_inet(E) nft_fib_ipv4(E) nft_fib_ipv6(E) nft_fib(E) nft_reject_inet(E) nf_reject_ipv4(E) nf_reject_ipv6(E) nft_reject(E) nft_ct(E) nft_chain_nat(E) ip6table_nat(E) ip6table_mangle(E) ip6table_raw(E) ip6table_security(E) iptable_nat(E) nf_nat(E) nf_conntrack(E) nf_defrag_ipv6(E) libcrc32c(E) nf_defrag_ipv4(E) iptable_mangle(E) iptable_raw(E) iptable_security(E) ip_set(E) nf_tables(E) nfnetlink(E) ip6table_filter(E) ip6_tables(E) iptable_filter(E) cmac(E) bnep(E) sunrpc(E) vfat(E) fat(E) mei_hdcp(E) snd_soc_sst_cht_bsw_rt5645(E) gpio_keys(E) intel_rapl_msr(E) intel_powerclamp(E) coretemp(E) kvm_intel(E) kvm(E) irqbypass(E) crct10dif_pclmul(E) crc32_pclmul(E) asus_nb_wmi(E) ath10k_pci(E) ghash_clmulni_intel(E) ath10k_core(E) intel_cstate(E) wdat_wdt(E) pcspkr(E) ath(E) mac80211(E) intel_chtdc_ti_pwrbtn(E) joydev(E) btusb(E) btrtl(E) btbcm(E) btintel(E) libarc4(E) bluetooth(E) cfg80211(E) ecdh_generic(E) ecc(E) mei_txe(E) mei(E) lpc_ich(E)
    [  179.552887]  hid_sensor_accel_3d(E) hid_sensor_gyro_3d(E) hid_sensor_trigger(E) hid_sensor_iio_common(E) industrialio_triggered_buffer(E) kfifo_buf(E) industrialio(E) atomisp_ov2680(CE) snd_soc_rt5645(E) snd_intel_sst_acpi(E) snd_soc_rl6231(E) snd_intel_sst_core(E) snd_soc_sst_atom_hifi2_platform(E) intel_hid(E) snd_soc_acpi_intel_match(E) spi_pxa2xx_platform(E) snd_soc_acpi(E) snd_soc_core(E) snd_compress(E) dw_dmac(E) snd_hdmi_lpe_audio(E) int3400_thermal(E) int3406_thermal(E) snd_seq(E) acpi_thermal_rel(E) int3403_thermal(E) atomisp(CE) snd_seq_device(E) snd_pcm(E) intel_int0002_vgpio(E) soc_button_array(E) acpi_pad(E) intel_xhci_usb_role_switch(E) snd_timer(E) videobuf_vmalloc(E) videobuf_core(E) snd(E) atomisp_gmin_platform(CE) soundcore(E) videodev(E) processor_thermal_device(E) intel_soc_dts_iosf(E) mc(E) intel_rapl_common(E) int340x_thermal_zone(E) ip_tables(E) hid_sensor_hub(E) intel_ishtp_loader(E) intel_ishtp_hid(E) mmc_block(E) hid_multitouch(E) crc32c_intel(E) i915(E)
    [  179.552936]  hid_asus(E) i2c_algo_bit(E) asus_wmi(E) sparse_keymap(E) rfkill(E) drm_kms_helper(E) intel_ish_ipc(E) intel_ishtp(E) drm(E) wmi(E) video(E) i2c_hid(E) pwm_lpss_platform(E) pwm_lpss(E) sdhci_acpi(E) sdhci(E) mmc_core(E) fuse(E)
    [  179.552961] CPU: 0 PID: 1414 Comm: v4l2grab Tainted: G         C  EL    5.7.0-rc2+ #42
    [  179.552963] Hardware name: ASUSTeK COMPUTER INC. T101HA/T101HA, BIOS T101HA.306 04/23/2019
    [  179.552968] RIP: 0010:cache_from_obj+0xab/0xf0
    [  179.552973] Code: c3 31 c0 80 3d 1c 38 72 01 00 75 f0 48 c7 c6 20 12 06 9f 48 c7 c7 10 f3 37 9f 48 89 04 24 c6 05 01 38 72 01 01 e8 2c 99 e0 ff <0f> 0b 48 8b 04 24 eb ca 48 8b 57 58 48 8b 48 58 48 c7 c6 30 12 06
    [  179.552976] RSP: 0018:ffffaf1f00c3fae0 EFLAGS: 00010282
    [  179.552980] RAX: 0000000000000029 RBX: 00000000000003ff RCX: 0000000000000007
    [  179.552983] RDX: 00000000fffffff8 RSI: 0000000000000082 RDI: ffff9cb6bbc19cc0
    [  179.552985] RBP: 0000000001000000 R08: 00000000000005a4 R09: ffffaf1f00c3f970
    [  179.552988] R10: 0000000000000005 R11: 0000000000000000 R12: ffffffffc0713da0
    [  179.552991] R13: ffff9cb5a7bb1000 R14: 0000000001000000 R15: ffff9cb5a7bb1000
    [  179.552995] FS:  0000000000000000(0000) GS:ffff9cb6bbc00000(0000) knlGS:0000000000000000
    [  179.552998] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  179.553000] CR2: 00007fe780544400 CR3: 000000002480a000 CR4: 00000000001006f0
    [  179.553003] Call Trace:
    [  179.553015]  kmem_cache_free+0x19/0x180
    [  179.553070]  mmu_l2_unmap+0xd1/0x100 [atomisp]
    [  179.553113]  ? __bo_merge+0x8f/0xa0 [atomisp]
    [  179.553155]  mmu_unmap+0xd0/0xf0 [atomisp]
    [  179.553198]  hmm_bo_unbind+0x62/0xb0 [atomisp]
    [  179.553240]  hmm_free+0x44/0x60 [atomisp]
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/staging/media/atomisp/include/mmu/isp_mmu.h b/drivers/staging/media/atomisp/include/mmu/isp_mmu.h
index c94df9012ac7..d9662c515236 100644
--- a/drivers/staging/media/atomisp/include/mmu/isp_mmu.h
+++ b/drivers/staging/media/atomisp/include/mmu/isp_mmu.h
@@ -113,7 +113,6 @@ struct isp_mmu {
 	phys_addr_t base_address;
 
 	struct mutex pt_mutex;
-	struct kmem_cache *tbl_cache;
 };
 
 /* flags for PDE and PTE */

commit 9d4fa1a16b28b1d12b0378993d2d48f572a045d9
Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Date:   Thu Apr 30 09:49:43 2020 +0200

    media: atomisp: cleanup directory hierarchy
    
    This driver has very long directories without a good
    reason (IMHO). Let's drop two directories from such hierarchy,
    in order to simplify things a little bit and make the dir
    output a bit more readable.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/drivers/staging/media/atomisp/include/mmu/isp_mmu.h b/drivers/staging/media/atomisp/include/mmu/isp_mmu.h
new file mode 100644
index 000000000000..c94df9012ac7
--- /dev/null
+++ b/drivers/staging/media/atomisp/include/mmu/isp_mmu.h
@@ -0,0 +1,169 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ */
+/*
+ * ISP MMU driver for classic two-level page tables
+ */
+#ifndef	__ISP_MMU_H__
+#define	__ISP_MMU_H__
+
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+
+/*
+ * do not change these values, the page size for ISP must be the
+ * same as kernel's page size.
+ */
+#define	ISP_PAGE_OFFSET		12
+#define	ISP_PAGE_SIZE		BIT(ISP_PAGE_OFFSET)
+#define	ISP_PAGE_MASK		(~(phys_addr_t)(ISP_PAGE_SIZE - 1))
+
+#define	ISP_L1PT_OFFSET		22
+#define	ISP_L1PT_MASK		(~((1U << ISP_L1PT_OFFSET) - 1))
+
+#define	ISP_L2PT_OFFSET		12
+#define	ISP_L2PT_MASK		(~(ISP_L1PT_MASK | (~(ISP_PAGE_MASK))))
+
+#define	ISP_L1PT_PTES		1024
+#define	ISP_L2PT_PTES		1024
+
+#define	ISP_PTR_TO_L1_IDX(x)	((((x) & ISP_L1PT_MASK)) \
+					>> ISP_L1PT_OFFSET)
+
+#define	ISP_PTR_TO_L2_IDX(x)	((((x) & ISP_L2PT_MASK)) \
+					>> ISP_L2PT_OFFSET)
+
+#define	ISP_PAGE_ALIGN(x)	(((x) + (ISP_PAGE_SIZE - 1)) \
+					& ISP_PAGE_MASK)
+
+#define	ISP_PT_TO_VIRT(l1_idx, l2_idx, offset) do {\
+		((l1_idx) << ISP_L1PT_OFFSET) | \
+		((l2_idx) << ISP_L2PT_OFFSET) | \
+		(offset)\
+} while (0)
+
+#define	pgnr_to_size(pgnr)	((pgnr) << ISP_PAGE_OFFSET)
+#define	size_to_pgnr_ceil(size)	(((size) + (1 << ISP_PAGE_OFFSET) - 1)\
+						>> ISP_PAGE_OFFSET)
+#define	size_to_pgnr_bottom(size)	((size) >> ISP_PAGE_OFFSET)
+
+struct isp_mmu;
+
+struct isp_mmu_client {
+	/*
+	 * const value
+	 *
+	 * @name:
+	 *      driver name
+	 * @pte_valid_mask:
+	 *      should be 1 bit valid data, meaning the value should
+	 *      be power of 2.
+	 */
+	char *name;
+	unsigned int pte_valid_mask;
+	unsigned int null_pte;
+
+	/*
+	 * get page directory base address (physical address).
+	 *
+	 * must be provided.
+	 */
+	unsigned int (*get_pd_base)(struct isp_mmu *mmu, phys_addr_t pd_base);
+	/*
+	 * callback to flush tlb.
+	 *
+	 * tlb_flush_range will at least flush TLBs containing
+	 * address mapping from addr to addr + size.
+	 *
+	 * tlb_flush_all will flush all TLBs.
+	 *
+	 * tlb_flush_all is must be provided. if tlb_flush_range is
+	 * not valid, it will set to tlb_flush_all by default.
+	 */
+	void (*tlb_flush_range)(struct isp_mmu *mmu,
+				unsigned int addr, unsigned int size);
+	void (*tlb_flush_all)(struct isp_mmu *mmu);
+	unsigned int (*phys_to_pte)(struct isp_mmu *mmu,
+				    phys_addr_t phys);
+	phys_addr_t (*pte_to_phys)(struct isp_mmu *mmu,
+				   unsigned int pte);
+
+};
+
+struct isp_mmu {
+	struct isp_mmu_client *driver;
+	unsigned int l1_pte;
+	int l2_pgt_refcount[ISP_L1PT_PTES];
+	phys_addr_t base_address;
+
+	struct mutex pt_mutex;
+	struct kmem_cache *tbl_cache;
+};
+
+/* flags for PDE and PTE */
+#define	ISP_PTE_VALID_MASK(mmu)	\
+	((mmu)->driver->pte_valid_mask)
+
+#define	ISP_PTE_VALID(mmu, pte)	\
+	((pte) & ISP_PTE_VALID_MASK(mmu))
+
+#define	NULL_PAGE	((phys_addr_t)(-1) & ISP_PAGE_MASK)
+#define	PAGE_VALID(page)	((page) != NULL_PAGE)
+
+/*
+ * init mmu with specific mmu driver.
+ */
+int isp_mmu_init(struct isp_mmu *mmu, struct isp_mmu_client *driver);
+/*
+ * cleanup all mmu related things.
+ */
+void isp_mmu_exit(struct isp_mmu *mmu);
+
+/*
+ * setup/remove address mapping for pgnr continuous physical pages
+ * and isp_virt.
+ *
+ * map/unmap is mutex lock protected, and caller does not have
+ * to do lock/unlock operation.
+ *
+ * map/unmap will not flush tlb, and caller needs to deal with
+ * this itself.
+ */
+int isp_mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
+		phys_addr_t phys, unsigned int pgnr);
+
+void isp_mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,
+		   unsigned int pgnr);
+
+static inline void isp_mmu_flush_tlb_all(struct isp_mmu *mmu)
+{
+	if (mmu->driver && mmu->driver->tlb_flush_all)
+		mmu->driver->tlb_flush_all(mmu);
+}
+
+#define isp_mmu_flush_tlb isp_mmu_flush_tlb_all
+
+static inline void isp_mmu_flush_tlb_range(struct isp_mmu *mmu,
+	unsigned int start, unsigned int size)
+{
+	if (mmu->driver && mmu->driver->tlb_flush_range)
+		mmu->driver->tlb_flush_range(mmu, start, size);
+}
+
+#endif /* ISP_MMU_H_ */
