commit 4ed6aba987bc573c0b70b952522843c511080c3c
Author: Sumera Priyadarsini <sylphrenadin@gmail.com>
Date:   Sun Feb 9 13:00:20 2020 +0530

    staging: rtl8192u: Add space to fix style issue
    
    This patch fixes the file r8190_rtl8256.c to avoid the following
    checkpatch.pl warnings:
            CHECK: spaces preferred around that '>>' (ctx:VxV)
    
    Signed-off-by: Sumera Priyadarsini <sylphrenadin@gmail.com>
    Link: https://lore.kernel.org/r/20200209073020.13423-1-sylphrenadin@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 555e52522be6..37b99cf4b35f 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1531,7 +1531,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 		rtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x1);
 		rtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x1);
 		rtl8192_setBBreg(dev, rCCK0_System, bCCKSideBand,
-				 priv->nCur40MhzPrimeSC>>1);
+				 priv->nCur40MhzPrimeSC >> 1);
 		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);
 		rtl8192_setBBreg(dev, rOFDM1_LSTF, 0xC00,
 				 priv->nCur40MhzPrimeSC);

commit 71fe59536e8a4b649c5d78d3ac58a66c03d34f38
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Sun Jan 5 01:21:35 2020 +0900

    staging: rtl8192u: remove header include path to ieee80211/
    
    There is no need to add "ccflags-y += -I $(srctree)/$(src)/ieee80211"
    just for including "dot11d.h".
    
    Use the correct relative path for the #include "..." directive.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Link: https://lore.kernel.org/r/20200104162136.19170-2-masahiroy@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index c04d8eca0cfb..555e52522be6 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -7,7 +7,7 @@
 #include "r8192U_dm.h"
 #include "r819xU_firmware_img.h"
 
-#include "dot11d.h"
+#include "ieee80211/dot11d.h"
 #include <linux/bitops.h>
 
 static u32 RF_CHANNEL_TABLE_ZEBRA[] = {

commit 684c215dd06eccc515dfd786347ac556c00f895a
Author: Stephen Brennan <stephen@brennan.io>
Date:   Fri Aug 23 09:24:10 2019 -0700

    staging: rtl8192u: remove code under TO_DO_LIST
    
    Several blocks of code are guarded by #ifdef TO_DO_LIST. If this is
    defined, compilation fails. No machinery exists to define this, and no
    documenation on the in-progress feature exists. Since this code is dead,
    let's delete it.
    
    Signed-off-by: Stephen Brennan <stephen@brennan.io>
    Link: https://lore.kernel.org/r/20190823162410.10038-1-stephen@brennan.io
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 5f04afe53d69..c04d8eca0cfb 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -516,16 +516,6 @@ static void rtl8192_phyConfigBB(struct net_device *dev,
 {
 	u32 i;
 
-#ifdef TO_DO_LIST
-	u32 *rtl8192PhyRegArrayTable = NULL, *rtl8192AgcTabArrayTable = NULL;
-
-	if (Adapter->bInHctTest) {
-		PHY_REGArrayLen = PHY_REGArrayLengthDTM;
-		AGCTAB_ArrayLen = AGCTAB_ArrayLengthDTM;
-		Rtl8190PHY_REGArray_Table = Rtl819XPHY_REGArrayDTM;
-		Rtl8190AGCTAB_Array_Table = Rtl819XAGCTAB_ArrayDTM;
-	}
-#endif
 	if (ConfigType == BASEBAND_CONFIG_PHY_REG) {
 		for (i = 0; i < PHY_REG_1T2RArrayLength; i += 2) {
 			rtl8192_setBBreg(dev, Rtl8192UsbPHY_REG_1T2RArray[i],
@@ -1059,10 +1049,6 @@ static void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
 
 	switch (priv->rf_chip) {
 	case RF_8225:
-#ifdef TO_DO_LIST
-		PHY_SetRF8225CckTxPower(Adapter, powerlevel);
-		PHY_SetRF8225OfdmTxPower(Adapter, powerlevelOFDM24G);
-#endif
 		break;
 
 	case RF_8256:
@@ -1160,48 +1146,6 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 		RT_TRACE(COMP_ERR, "Not support rf_chip(%x)\n", priv->rf_chip);
 		break;
 	}
-#ifdef TO_DO_LIST
-	if (bResult) {
-		/* Update current RF state variable. */
-		pHalData->eRFPowerState = eRFPowerState;
-		switch (pHalData->RFChipID) {
-		case RF_8256:
-			switch (pHalData->eRFPowerState) {
-			case eRfOff:
-				/* If Rf off reason is from IPS,
-				 * LED should blink with no link
-				 */
-				if (pMgntInfo->RfOffReason == RF_CHANGE_BY_IPS)
-					Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);
-				else
-					/* Turn off LED if RF is not ON. */
-					Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_POWER_OFF);
-				break;
-
-			case eRfOn:
-				/* Turn on RF we are still linked, which might
-				 * happen when we quickly turn off and on HW RF.
-				 */
-				if (pMgntInfo->bMediaConnect)
-					Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_LINK);
-				else
-					/* Turn off LED if RF is not ON. */
-					Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);
-				break;
-
-			default:
-				break;
-			}
-			break;
-
-		default:
-			RT_TRACE(COMP_RF, DBG_LOUD, "%s(): Unknown RF type\n",
-				 __func__);
-			break;
-		}
-
-	}
-#endif
 	priv->SetRFPowerStateInProgress = false;
 
 	return bResult;
@@ -1628,9 +1572,6 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	/* <3> Set RF related register */
 	switch (priv->rf_chip) {
 	case RF_8225:
-#ifdef TO_DO_LIST
-		PHY_SetRF8225Bandwidth(Adapter, pHalData->CurrentChannelBW);
-#endif
 		break;
 
 	case RF_8256:

commit 071327fc42793e9b9e9f5ee164f75854e70140d1
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Sun Aug 26 23:45:32 2018 +0100

    staging:rtl8192u: Rename PHY_SetRF8256OFDMTxPower() - Style
    
    Rename function PHY_SetRF8256OFDMTxPower() to
    phy_set_rf8256_ofdm_tx_power(), to clear the checkpatch issue with
    CamelCase naming.
    
    This is a coding style change which should have no impact on runtime
    code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 4d09d3513dde..5f04afe53d69 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -919,7 +919,7 @@ void rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)
 	case RF_8256:
 		/* need further implement */
 		phy_set_rf8256_cck_tx_power(dev, powerlevel);
-		PHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);
+		phy_set_rf8256_ofdm_tx_power(dev, powerlevelOFDM24G);
 		break;
 	default:
 		RT_TRACE((COMP_PHY|COMP_ERR),
@@ -1067,7 +1067,7 @@ static void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
 
 	case RF_8256:
 		phy_set_rf8256_cck_tx_power(dev, powerlevel);
-		PHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);
+		phy_set_rf8256_ofdm_tx_power(dev, powerlevelOFDM24G);
 		break;
 
 	case RF_8258:

commit 3942039a65170b21737596d32d7acf5894ba03bc
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Sun Aug 26 23:45:31 2018 +0100

    staging:rtl8192u: Rename PHY_SetRF8256CCKTxPower() - Style
    
    Rename the function PHY_SetRF8256CCKTxPower() to
    phy_set_rf8256_cck_tx_power(), to clear the checkpatch issue with
    CamelCase naming.
    
    This is a purely coding style change which should have no impact
    on runtime code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index eeaa77fa1d30..4d09d3513dde 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -918,7 +918,7 @@ void rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)
 	switch (priv->rf_chip) {
 	case RF_8256:
 		/* need further implement */
-		PHY_SetRF8256CCKTxPower(dev, powerlevel);
+		phy_set_rf8256_cck_tx_power(dev, powerlevel);
 		PHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);
 		break;
 	default:
@@ -1066,7 +1066,7 @@ static void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
 		break;
 
 	case RF_8256:
-		PHY_SetRF8256CCKTxPower(dev, powerlevel);
+		phy_set_rf8256_cck_tx_power(dev, powerlevel);
 		PHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);
 		break;
 

commit 9980fd11f16ad427ee4b3e88e848f65ebcca07dd
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Sun Aug 26 23:45:29 2018 +0100

    staging:rtl8192u: Rename function PHY_RF8256_Config() - Style
    
    Rename the function PHY_RF8256_Config() to phy_rf8256_config(). This
    change clears the checkpatch issue with CamelCase naming.
    
    This is a simple coding style change which should have no impact on
    runtime code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 33a3eb7a318f..eeaa77fa1d30 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -794,7 +794,7 @@ static void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 						  (enum rf90_radio_path_e)0);
 		if (status != 0) {
 			RT_TRACE((COMP_ERR | COMP_PHY),
-				 "PHY_RF8256_Config(): Check PHY%d Fail!!\n",
+				 "phy_rf8256_config(): Check PHY%d Fail!!\n",
 				 eCheckItem-1);
 			return;
 		}
@@ -941,7 +941,7 @@ void rtl8192_phy_RFConfig(struct net_device *dev)
 
 	switch (priv->rf_chip) {
 	case RF_8256:
-		PHY_RF8256_Config(dev);
+		phy_rf8256_config(dev);
 		break;
 	default:
 		RT_TRACE(COMP_ERR, "error chip id\n");

commit 7c67160857a2eeb6241f71271e2a8af62a15a3df
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Sun Aug 26 23:45:28 2018 +0100

    staging:rtl8192u: Rename PHY_SetRF8256Bandwidth() - Style
    
    Rename the function PHY_SetRF8256Bandwidth() to
    phy_set_rf8256_bandwidth(). This change clears the checkpatch issue
    with CamelCase naming.
    
    The parameter Bandwidth has been renamed to bandwidth, for the
    same reason.
    
    Additionally a new line has been added to the parameter list of the
    function declaration in r8190_rtl8256.h to truncate the line length
    to the checkpatch limit.
    
    These changes are simple coding style changes which should have no
    impact on runtime code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 9c9dba6e73bc..33a3eb7a318f 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1634,7 +1634,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 		break;
 
 	case RF_8256:
-		PHY_SetRF8256Bandwidth(dev, priv->CurrentChannelBW);
+		phy_set_rf8256_bandwidth(dev, priv->CurrentChannelBW);
 		break;
 
 	case RF_8258:

commit 111118af91c4bf06791a902789bd03992b41faf0
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Sun Aug 26 22:14:22 2018 +0100

    staging:rtl8192u: Refactor BaseBand_Config_Type - Style
    
    Rename the type to baseband_config_type to clear the checkpatch issue
    with CamelCase naming. Remove the 'typedef' directive to clear the
    issue with defining new types.
    
    As it is only used in the file r819xU_phy.c the type has been moved
    to the r819xU_phy.h file.
    
    The enumerated type is only used as a parameter to the function
    rtl8192_phyConfigBB. Previously that parameter used type 'u8' so no
    compiler typechecking was being performed. The parameter type has been
    corrected.
    
    These changes are coding style changes and as such should have no
    impact on runtime code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 97d3cdcd7fb0..9c9dba6e73bc 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -511,7 +511,8 @@ void rtl8192_phy_configmac(struct net_device *dev)
  * notice:    BB parameters may change all the time, so please make
  *            sure it has been synced with the newest.
  *****************************************************************************/
-static void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
+static void rtl8192_phyConfigBB(struct net_device *dev,
+				enum baseband_config_type ConfigType)
 {
 	u32 i;
 
@@ -525,7 +526,7 @@ static void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 		Rtl8190AGCTAB_Array_Table = Rtl819XAGCTAB_ArrayDTM;
 	}
 #endif
-	if (ConfigType == BaseBand_Config_PHY_REG) {
+	if (ConfigType == BASEBAND_CONFIG_PHY_REG) {
 		for (i = 0; i < PHY_REG_1T2RArrayLength; i += 2) {
 			rtl8192_setBBreg(dev, Rtl8192UsbPHY_REG_1T2RArray[i],
 					 bMaskDWord,
@@ -535,7 +536,7 @@ static void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 				 i, Rtl8192UsbPHY_REG_1T2RArray[i],
 				 Rtl8192UsbPHY_REG_1T2RArray[i+1]);
 		}
-	} else if (ConfigType == BaseBand_Config_AGC_TAB) {
+	} else if (ConfigType == BASEBAND_CONFIG_AGC_TAB) {
 		for (i = 0; i < AGCTAB_ArrayLength; i += 2) {
 			rtl8192_setBBreg(dev, Rtl8192UsbAGCTAB_Array[i],
 					 bMaskDWord, Rtl8192UsbAGCTAB_Array[i+1]);
@@ -802,7 +803,7 @@ static void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	rtl8192_setBBreg(dev, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x0);
 	/* ----BB Register Initilazation---- */
 	/* ==m==>Set PHY REG From Header<==m== */
-	rtl8192_phyConfigBB(dev, BaseBand_Config_PHY_REG);
+	rtl8192_phyConfigBB(dev, BASEBAND_CONFIG_PHY_REG);
 
 	/* ----Set BB reset de-Active---- */
 	read_nic_dword(dev, CPU_GEN, &reg_u32);
@@ -810,7 +811,7 @@ static void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 
 	/* ----BB AGC table Initialization---- */
 	/* ==m==>Set PHY REG From Header<==m== */
-	rtl8192_phyConfigBB(dev, BaseBand_Config_AGC_TAB);
+	rtl8192_phyConfigBB(dev, BASEBAND_CONFIG_AGC_TAB);
 
 	/* ----Enable XSTAL ---- */
 	write_nic_byte_E(dev, 0x5e, 0x00);

commit 4a4c1b7ceb8a9c36a45a04dc26232d25f804120b
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Sun Aug 26 22:14:21 2018 +0100

    staging:rtl8192u: Make function rtl8192_phyConfigBB static
    
    The function rtl8192_phyConfigBB is only used in the file in which it
    is defined so can be declared static. Additionally the prototype has
    been removed from the header file, as it is not used.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index e7c3582f550e..97d3cdcd7fb0 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -511,7 +511,7 @@ void rtl8192_phy_configmac(struct net_device *dev)
  * notice:    BB parameters may change all the time, so please make
  *            sure it has been synced with the newest.
  *****************************************************************************/
-void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
+static void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 {
 	u32 i;
 

commit 64749a7e54e36bf33b0c9c69a567d3f682587107
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Sun Aug 26 22:14:19 2018 +0100

    staging:rtl8192u: Refactor enum VERSION_819xU - Style
    
    Rename enumerated type VERSION_819xU to version_819xu to clear
    checkpatch issue with CamelCase naming. Additionally the constants
    defined by the type are renamed for the same reason.
    
    Remove the 'typedef' directive to clear the checkpatch issue with
    defining new types.
    
    The enumerated type has been moved to the file where the type is
    actually used, r8192U.h
    
    Additionally the memeber variable, which uses the type
    (card_8192_version), has been changed to use the type to enable
    compiler typechecking.
    
    These are coding style changes which should not impact runtime code
    execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 0a13a1f8a14d..e7c3582f550e 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -814,7 +814,7 @@ static void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 
 	/* ----Enable XSTAL ---- */
 	write_nic_byte_E(dev, 0x5e, 0x00);
-	if (priv->card_8192_version == (u8)VERSION_819xU_A) {
+	if (priv->card_8192_version == VERSION_819XU_A) {
 		/* Antenna gain offset from B/C/D to A */
 		reg_u32 = priv->AntennaTxPwDiff[1]<<4 |
 			   priv->AntennaTxPwDiff[0];
@@ -1367,7 +1367,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 
 		switch (CurrentCmd->cmd_id) {
 		case CMD_ID_SET_TX_PWR_LEVEL:
-			if (priv->card_8192_version == (u8)VERSION_819xU_A)
+			if (priv->card_8192_version == VERSION_819XU_A)
 				/* consider it later! */
 				rtl8192_SetTxPowerLevel(dev, channel);
 			break;

commit b56b1438a103a6ab80c29dbce2a0033999ac30c1
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Wed Aug 8 22:00:35 2018 +0100

    staging:rtl8192u: Rename IsLegalChannel - Style
    
    The function IsLegalChannel causes a checkpatch issue due to its use
    of CamelCase naming. The function has been renamed to is_legal_channel.
    
    This is a coding style change which should have no impact on runtime
    code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 7ee10d49894b..0a13a1f8a14d 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1271,7 +1271,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 
 	RT_TRACE(COMP_CH, "%s() stage: %d, step: %d, channel: %d\n",
 		 __func__, *stage, *step, channel);
-	if (!IsLegalChannel(priv->ieee80211, channel)) {
+	if (!is_legal_channel(priv->ieee80211, channel)) {
 		RT_TRACE(COMP_ERR, "set to illegal channel: %d\n", channel);
 		/* return true to tell upper caller function this channel
 		 * setting is finished! Or it will in while loop.

commit cc29db86378e131d13859529b7285ae92ae3143f
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:26 2018 +0100

    staging:rtl8192u: Rename eRFPath - Style
    
    Rename the variable eRFPath to e_rfpath. This change resolves a
    checkpatch issue with CamelCase naming. The variable name is used both
    as a parameter name in function definitions, function prototypes and as
    a local variable.
    
    This change is purely a coding style change which should have no impact
    on runtime code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index fb74b749fbcf..7ee10d49894b 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -34,11 +34,11 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
  * function:  This function checks different RF type to execute legal judgement.
  *            If RF Path is illegal, we will return false.
  * input:     net_device	 *dev
- *            u32		 eRFPath
+ *            u32		 e_rfpath
  * output:    none
  * return:    0(illegal, false), 1(legal, true)
  *****************************************************************************/
-u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 eRFPath)
+u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 e_rfpath)
 {
 	u8 ret = 1;
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -46,9 +46,9 @@ u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 eRFPath)
 	if (priv->rf_type == RF_2T4R) {
 		ret = 0;
 	} else if (priv->rf_type == RF_1T2R) {
-		if (eRFPath == RF90_PATH_A || eRFPath == RF90_PATH_B)
+		if (e_rfpath == RF90_PATH_A || e_rfpath == RF90_PATH_B)
 			ret = 1;
-		else if (eRFPath == RF90_PATH_C || eRFPath == RF90_PATH_D)
+		else if (e_rfpath == RF90_PATH_C || e_rfpath == RF90_PATH_D)
 			ret = 0;
 	}
 	return ret;
@@ -101,18 +101,18 @@ u32 rtl8192_QueryBBReg(struct net_device *dev, u32 reg_addr, u32 bitmask)
 }
 
 static u32 phy_FwRFSerialRead(struct net_device *dev,
-			      enum rf90_radio_path_e eRFPath,
+			      enum rf90_radio_path_e e_rfpath,
 			      u32 offset);
 
 static void phy_FwRFSerialWrite(struct net_device *dev,
-				enum rf90_radio_path_e eRFPath,
+				enum rf90_radio_path_e e_rfpath,
 				u32  offset,
 				u32  data);
 
 /******************************************************************************
  * function:  This function reads register from RF chip
  * input:     net_device        *dev
- *            rf90_radio_path_e eRFPath    //radio path of A/B/C/D
+ *            rf90_radio_path_e e_rfpath    //radio path of A/B/C/D
  *            u32               offset     //target address to be read
  * output:    none
  * return:    u32               readback value
@@ -124,12 +124,12 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
  *            ---need more spec for this information.
  ******************************************************************************/
 static u32 rtl8192_phy_RFSerialRead(struct net_device *dev,
-				    enum rf90_radio_path_e eRFPath, u32 offset)
+				    enum rf90_radio_path_e e_rfpath, u32 offset)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 ret = 0;
 	u32 new_offset = 0;
-	BB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[eRFPath];
+	BB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[e_rfpath];
 
 	rtl8192_setBBreg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData, 0);
 	/* Make sure RF register offset is correct */
@@ -138,20 +138,20 @@ static u32 rtl8192_phy_RFSerialRead(struct net_device *dev,
 	/* Switch page for 8256 RF IC */
 	if (priv->rf_chip == RF_8256) {
 		if (offset >= 31) {
-			priv->RfReg0Value[eRFPath] |= 0x140;
+			priv->RfReg0Value[e_rfpath] |= 0x140;
 			/* Switch to Reg_Mode2 for Reg 31-45 */
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,
 					 bMaskDWord,
-					 priv->RfReg0Value[eRFPath]<<16);
+					 priv->RfReg0Value[e_rfpath]<<16);
 			/* Modify offset */
 			new_offset = offset - 30;
 		} else if (offset >= 16) {
-			priv->RfReg0Value[eRFPath] |= 0x100;
-			priv->RfReg0Value[eRFPath] &= (~0x40);
+			priv->RfReg0Value[e_rfpath] |= 0x100;
+			priv->RfReg0Value[e_rfpath] &= (~0x40);
 			/* Switch to Reg_Mode1 for Reg16-30 */
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,
 					 bMaskDWord,
-					 priv->RfReg0Value[eRFPath]<<16);
+					 priv->RfReg0Value[e_rfpath]<<16);
 
 			new_offset = offset - 15;
 		} else {
@@ -179,10 +179,10 @@ static u32 rtl8192_phy_RFSerialRead(struct net_device *dev,
 
 	/* Switch back to Reg_Mode0 */
 	if (priv->rf_chip == RF_8256) {
-		priv->RfReg0Value[eRFPath] &= 0xebf;
+		priv->RfReg0Value[e_rfpath] &= 0xebf;
 
 		rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord,
-				 priv->RfReg0Value[eRFPath] << 16);
+				 priv->RfReg0Value[e_rfpath] << 16);
 	}
 
 	return ret;
@@ -191,7 +191,7 @@ static u32 rtl8192_phy_RFSerialRead(struct net_device *dev,
 /******************************************************************************
  * function:  This function writes data to RF register
  * input:     net_device        *dev
- *            rf90_radio_path_e eRFPath  //radio path of A/B/C/D
+ *            rf90_radio_path_e e_rfpath  //radio path of A/B/C/D
  *            u32               offset   //target address to be written
  *            u32               data	 //the new register data to be written
  * output:    none
@@ -209,29 +209,29 @@ static u32 rtl8192_phy_RFSerialRead(struct net_device *dev,
  * ---------------------------------------------------------------------------
  *****************************************************************************/
 static void rtl8192_phy_RFSerialWrite(struct net_device *dev,
-				      enum rf90_radio_path_e eRFPath,
+				      enum rf90_radio_path_e e_rfpath,
 				      u32 offset,
 				      u32 data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 DataAndAddr = 0, new_offset = 0;
-	BB_REGISTER_DEFINITION_T	*pPhyReg = &priv->PHYRegDef[eRFPath];
+	BB_REGISTER_DEFINITION_T	*pPhyReg = &priv->PHYRegDef[e_rfpath];
 
 	offset &= 0x3f;
 	if (priv->rf_chip == RF_8256) {
 
 		if (offset >= 31) {
-			priv->RfReg0Value[eRFPath] |= 0x140;
+			priv->RfReg0Value[e_rfpath] |= 0x140;
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,
 					 bMaskDWord,
-					 priv->RfReg0Value[eRFPath] << 16);
+					 priv->RfReg0Value[e_rfpath] << 16);
 			new_offset = offset - 30;
 		} else if (offset >= 16) {
-			priv->RfReg0Value[eRFPath] |= 0x100;
-			priv->RfReg0Value[eRFPath] &= (~0x40);
+			priv->RfReg0Value[e_rfpath] |= 0x100;
+			priv->RfReg0Value[e_rfpath] &= (~0x40);
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,
 					 bMaskDWord,
-					 priv->RfReg0Value[eRFPath]<<16);
+					 priv->RfReg0Value[e_rfpath]<<16);
 			new_offset = offset - 15;
 		} else {
 			new_offset = offset;
@@ -250,15 +250,15 @@ static void rtl8192_phy_RFSerialWrite(struct net_device *dev,
 
 
 	if (offset == 0x0)
-		priv->RfReg0Value[eRFPath] = data;
+		priv->RfReg0Value[e_rfpath] = data;
 
 	/* Switch back to Reg_Mode0 */
 	if (priv->rf_chip == RF_8256) {
 		if (offset != 0) {
-			priv->RfReg0Value[eRFPath] &= 0xebf;
+			priv->RfReg0Value[e_rfpath] &= 0xebf;
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,
 					 bMaskDWord,
-					 priv->RfReg0Value[eRFPath] << 16);
+					 priv->RfReg0Value[e_rfpath] << 16);
 		}
 	}
 }
@@ -266,7 +266,7 @@ static void rtl8192_phy_RFSerialWrite(struct net_device *dev,
 /******************************************************************************
  * function:  This function set specific bits to RF register
  * input:     net_device        dev
- *            rf90_radio_path_e eRFPath  //radio path of A/B/C/D
+ *            rf90_radio_path_e e_rfpath  //radio path of A/B/C/D
  *            u32               reg_addr //target addr to be modified
  *            u32               bitmask  //taget bit pos to be modified
  *            u32               data     //value to be written
@@ -275,26 +275,26 @@ static void rtl8192_phy_RFSerialWrite(struct net_device *dev,
  * notice:
  *****************************************************************************/
 void rtl8192_phy_SetRFReg(struct net_device *dev,
-			  enum rf90_radio_path_e eRFPath,
+			  enum rf90_radio_path_e e_rfpath,
 			  u32 reg_addr, u32 bitmask, u32 data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 reg, bitshift;
 
-	if (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))
+	if (!rtl8192_phy_CheckIsLegalRFPath(dev, e_rfpath))
 		return;
 
 	if (priv->Rf_Mode == RF_OP_By_FW) {
 		if (bitmask != bMask12Bits) {
 			/* RF data is 12 bits only */
-			reg = phy_FwRFSerialRead(dev, eRFPath, reg_addr);
+			reg = phy_FwRFSerialRead(dev, e_rfpath, reg_addr);
 			bitshift =  ffs(bitmask) - 1;
 			reg &= ~bitmask;
 			reg |= data << bitshift;
 
-			phy_FwRFSerialWrite(dev, eRFPath, reg_addr, reg);
+			phy_FwRFSerialWrite(dev, e_rfpath, reg_addr, reg);
 		} else {
-			phy_FwRFSerialWrite(dev, eRFPath, reg_addr, data);
+			phy_FwRFSerialWrite(dev, e_rfpath, reg_addr, data);
 		}
 
 		udelay(200);
@@ -302,14 +302,14 @@ void rtl8192_phy_SetRFReg(struct net_device *dev,
 	} else {
 		if (bitmask != bMask12Bits) {
 			/* RF data is 12 bits only */
-			reg = rtl8192_phy_RFSerialRead(dev, eRFPath, reg_addr);
+			reg = rtl8192_phy_RFSerialRead(dev, e_rfpath, reg_addr);
 			bitshift =  ffs(bitmask) - 1;
 			reg &= ~bitmask;
 			reg |= data << bitshift;
 
-			rtl8192_phy_RFSerialWrite(dev, eRFPath, reg_addr, reg);
+			rtl8192_phy_RFSerialWrite(dev, e_rfpath, reg_addr, reg);
 		} else {
-			rtl8192_phy_RFSerialWrite(dev, eRFPath, reg_addr, data);
+			rtl8192_phy_RFSerialWrite(dev, e_rfpath, reg_addr, data);
 		}
 	}
 }
@@ -324,20 +324,20 @@ void rtl8192_phy_SetRFReg(struct net_device *dev,
  * notice:
  *****************************************************************************/
 u32 rtl8192_phy_QueryRFReg(struct net_device *dev,
-			   enum rf90_radio_path_e eRFPath,
+			   enum rf90_radio_path_e e_rfpath,
 			   u32 reg_addr, u32 bitmask)
 {
 	u32 reg, bitshift;
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
 
-	if (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))
+	if (!rtl8192_phy_CheckIsLegalRFPath(dev, e_rfpath))
 		return 0;
 	if (priv->Rf_Mode == RF_OP_By_FW) {
-		reg = phy_FwRFSerialRead(dev, eRFPath, reg_addr);
+		reg = phy_FwRFSerialRead(dev, e_rfpath, reg_addr);
 		udelay(200);
 	} else {
-		reg = rtl8192_phy_RFSerialRead(dev, eRFPath, reg_addr);
+		reg = rtl8192_phy_RFSerialRead(dev, e_rfpath, reg_addr);
 	}
 	bitshift =  ffs(bitmask) - 1;
 	reg = (reg & bitmask) >> bitshift;
@@ -348,14 +348,14 @@ u32 rtl8192_phy_QueryRFReg(struct net_device *dev,
 /******************************************************************************
  * function:  We support firmware to execute RF-R/W.
  * input:     net_device        *dev
- *            rf90_radio_path_e eRFPath
+ *            rf90_radio_path_e e_rfpath
  *            u32               offset
  * output:    none
  * return:    u32
  * notice:
  ****************************************************************************/
 static u32 phy_FwRFSerialRead(struct net_device *dev,
-			      enum rf90_radio_path_e eRFPath,
+			      enum rf90_radio_path_e e_rfpath,
 			      u32 offset)
 {
 	u32		reg = 0;
@@ -372,7 +372,7 @@ static u32 phy_FwRFSerialRead(struct net_device *dev,
 	/* 2. Write RF register address. bit 12-19 */
 	data |= ((offset&0xFF)<<12);
 	/* 3. Write RF path.  bit 20-21 */
-	data |= ((eRFPath&0x3)<<20);
+	data |= ((e_rfpath&0x3)<<20);
 	/* 4. Set RF read indicator. bit 22=0 */
 	/* 5. Trigger Fw to operate the command. bit 31 */
 	data |= 0x80000000;
@@ -412,7 +412,7 @@ static u32 phy_FwRFSerialRead(struct net_device *dev,
 /******************************************************************************
  * function:  We support firmware to execute RF-R/W.
  * input:     net_device        *dev
- *            rf90_radio_path_e eRFPath
+ *            rf90_radio_path_e e_rfpath
  *            u32               offset
  *            u32               data
  * output:    none
@@ -420,7 +420,7 @@ static u32 phy_FwRFSerialRead(struct net_device *dev,
  * notice:
  ****************************************************************************/
 static void phy_FwRFSerialWrite(struct net_device *dev,
-				enum rf90_radio_path_e eRFPath,
+				enum rf90_radio_path_e e_rfpath,
 				u32 offset, u32 data)
 {
 	u8	time = 0;
@@ -436,7 +436,7 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
 	/* 2. Write RF register address. bit 12-19 */
 	data |= ((offset&0xFF)<<12);
 	/* 3. Write RF path.  bit 20-21 */
-	data |= ((eRFPath&0x3)<<20);
+	data |= ((e_rfpath&0x3)<<20);
 	/* 4. Set RF write indicator. bit 22=1 */
 	data |= 0x400000;
 	/* 5. Trigger Fw to operate the command. bit 31=1 */
@@ -688,14 +688,14 @@ static void rtl8192_InitBBRFRegDef(struct net_device *dev)
  *            sure whether BB and RF is OK
  * input:     net_device        *dev
  *            hw90_block_e      CheckBlock
- *            rf90_radio_path_e eRFPath  //only used when checkblock is
+ *            rf90_radio_path_e e_rfpath  //only used when checkblock is
  *                                       //HW90_BLOCK_RF
  * output:    none
  * return:    return whether BB and RF is ok (0:OK, 1:Fail)
  * notice:    This function may be removed in the ASIC
  ******************************************************************************/
 u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, enum hw90_block_e CheckBlock,
-			    enum rf90_radio_path_e eRFPath)
+			    enum rf90_radio_path_e e_rfpath)
 {
 	u8 ret = 0;
 	u32 i, CheckTimes = 4, reg = 0;
@@ -726,14 +726,14 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, enum hw90_block_e CheckBlock
 
 		case HW90_BLOCK_RF:
 			WriteData[i] &= 0xfff;
-			rtl8192_phy_SetRFReg(dev, eRFPath,
+			rtl8192_phy_SetRFReg(dev, e_rfpath,
 					     WriteAddr[HW90_BLOCK_RF],
 					     bMask12Bits, WriteData[i]);
 			/* TODO: we should not delay for such a long time.
 			 * Ask SD3
 			 */
 			usleep_range(1000, 1000);
-			reg = rtl8192_phy_QueryRFReg(dev, eRFPath,
+			reg = rtl8192_phy_QueryRFReg(dev, e_rfpath,
 						     WriteAddr[HW90_BLOCK_RF],
 						     bMask12Bits);
 			usleep_range(1000, 1000);
@@ -962,18 +962,18 @@ void rtl8192_phy_updateInitGain(struct net_device *dev)
  * function:  This function read RF parameters from general head file,
  *            and do RF 3-wire
  * input:     net_device	*dev
- *            rf90_radio_path_e eRFPath
+ *            rf90_radio_path_e e_rfpath
  * output:    none
  * return:    return code show if RF configuration is successful(0:pass, 1:fail)
  * notice:    Delay may be required for RF configuration
  *****************************************************************************/
 u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
-				      enum rf90_radio_path_e	eRFPath)
+				      enum rf90_radio_path_e	e_rfpath)
 {
 
 	int i;
 
-	switch (eRFPath) {
+	switch (e_rfpath) {
 	case RF90_PATH_A:
 		for (i = 0; i < RadioA_ArrayLength; i = i+2) {
 
@@ -981,7 +981,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 				mdelay(100);
 				continue;
 			}
-			rtl8192_phy_SetRFReg(dev, eRFPath,
+			rtl8192_phy_SetRFReg(dev, e_rfpath,
 					     Rtl8192UsbRadioA_Array[i],
 					     bMask12Bits,
 					     Rtl8192UsbRadioA_Array[i+1]);
@@ -996,7 +996,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 				mdelay(100);
 				continue;
 			}
-			rtl8192_phy_SetRFReg(dev, eRFPath,
+			rtl8192_phy_SetRFReg(dev, e_rfpath,
 					     Rtl8192UsbRadioB_Array[i],
 					     bMask12Bits,
 					     Rtl8192UsbRadioB_Array[i+1]);
@@ -1011,7 +1011,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 				mdelay(100);
 				continue;
 			}
-			rtl8192_phy_SetRFReg(dev, eRFPath,
+			rtl8192_phy_SetRFReg(dev, e_rfpath,
 					     Rtl8192UsbRadioC_Array[i],
 					     bMask12Bits,
 					     Rtl8192UsbRadioC_Array[i+1]);
@@ -1026,7 +1026,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 				mdelay(100);
 				continue;
 			}
-			rtl8192_phy_SetRFReg(dev, eRFPath,
+			rtl8192_phy_SetRFReg(dev, e_rfpath,
 					     Rtl8192UsbRadioD_Array[i],
 					     bMask12Bits,
 					     Rtl8192UsbRadioD_Array[i+1]);
@@ -1267,7 +1267,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 	struct sw_chnl_cmd   RfDependCmd[MAX_RFDEPENDCMD_CNT];
 	u32		   RfDependCmdCnt;
 	struct sw_chnl_cmd  *CurrentCmd = NULL;
-	u8		   eRFPath;
+	u8		   e_rfpath;
 
 	RT_TRACE(COMP_CH, "%s() stage: %d, step: %d, channel: %d\n",
 		 __func__, *stage, *step, channel);
@@ -1384,9 +1384,9 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 				       (u8)CurrentCmd->para_2);
 			break;
 		case CMD_ID_RF_WRITE_REG:
-			for (eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {
+			for (e_rfpath = 0; e_rfpath < RF90_PATH_MAX; e_rfpath++) {
 				rtl8192_phy_SetRFReg(dev,
-						     (enum rf90_radio_path_e)eRFPath,
+						     (enum rf90_radio_path_e)e_rfpath,
 						     CurrentCmd->para_1,
 						     bZebra1_ChannelNum,
 						     CurrentCmd->para_2);

commit fb37edcfcba7088d07a0ebb79f2991cd190d0a99
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:24 2018 +0100

    staging:rtl8192u: Rename RF90_RADIO_PATH_E - Style
    
    Rename the enumerated type RF90_RADIO_PATH_E to rf90_radio_path_e.
    Whilst it is not flagged as an issue by checkpatch, types are meant
    to be named in lowercase.
    
    This change is purely a coding style change which should have no
    impact on runtime code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index c8c54484eab5..fb74b749fbcf 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -101,18 +101,18 @@ u32 rtl8192_QueryBBReg(struct net_device *dev, u32 reg_addr, u32 bitmask)
 }
 
 static u32 phy_FwRFSerialRead(struct net_device *dev,
-			      enum RF90_RADIO_PATH_E eRFPath,
+			      enum rf90_radio_path_e eRFPath,
 			      u32 offset);
 
 static void phy_FwRFSerialWrite(struct net_device *dev,
-				enum RF90_RADIO_PATH_E eRFPath,
+				enum rf90_radio_path_e eRFPath,
 				u32  offset,
 				u32  data);
 
 /******************************************************************************
  * function:  This function reads register from RF chip
  * input:     net_device        *dev
- *            RF90_RADIO_PATH_E eRFPath    //radio path of A/B/C/D
+ *            rf90_radio_path_e eRFPath    //radio path of A/B/C/D
  *            u32               offset     //target address to be read
  * output:    none
  * return:    u32               readback value
@@ -124,7 +124,7 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
  *            ---need more spec for this information.
  ******************************************************************************/
 static u32 rtl8192_phy_RFSerialRead(struct net_device *dev,
-				    enum RF90_RADIO_PATH_E eRFPath, u32 offset)
+				    enum rf90_radio_path_e eRFPath, u32 offset)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 ret = 0;
@@ -191,7 +191,7 @@ static u32 rtl8192_phy_RFSerialRead(struct net_device *dev,
 /******************************************************************************
  * function:  This function writes data to RF register
  * input:     net_device        *dev
- *            RF90_RADIO_PATH_E eRFPath  //radio path of A/B/C/D
+ *            rf90_radio_path_e eRFPath  //radio path of A/B/C/D
  *            u32               offset   //target address to be written
  *            u32               data	 //the new register data to be written
  * output:    none
@@ -209,7 +209,7 @@ static u32 rtl8192_phy_RFSerialRead(struct net_device *dev,
  * ---------------------------------------------------------------------------
  *****************************************************************************/
 static void rtl8192_phy_RFSerialWrite(struct net_device *dev,
-				      enum RF90_RADIO_PATH_E eRFPath,
+				      enum rf90_radio_path_e eRFPath,
 				      u32 offset,
 				      u32 data)
 {
@@ -266,7 +266,7 @@ static void rtl8192_phy_RFSerialWrite(struct net_device *dev,
 /******************************************************************************
  * function:  This function set specific bits to RF register
  * input:     net_device        dev
- *            RF90_RADIO_PATH_E eRFPath  //radio path of A/B/C/D
+ *            rf90_radio_path_e eRFPath  //radio path of A/B/C/D
  *            u32               reg_addr //target addr to be modified
  *            u32               bitmask  //taget bit pos to be modified
  *            u32               data     //value to be written
@@ -275,7 +275,7 @@ static void rtl8192_phy_RFSerialWrite(struct net_device *dev,
  * notice:
  *****************************************************************************/
 void rtl8192_phy_SetRFReg(struct net_device *dev,
-			  enum RF90_RADIO_PATH_E eRFPath,
+			  enum rf90_radio_path_e eRFPath,
 			  u32 reg_addr, u32 bitmask, u32 data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -324,7 +324,7 @@ void rtl8192_phy_SetRFReg(struct net_device *dev,
  * notice:
  *****************************************************************************/
 u32 rtl8192_phy_QueryRFReg(struct net_device *dev,
-			   enum RF90_RADIO_PATH_E eRFPath,
+			   enum rf90_radio_path_e eRFPath,
 			   u32 reg_addr, u32 bitmask)
 {
 	u32 reg, bitshift;
@@ -348,14 +348,14 @@ u32 rtl8192_phy_QueryRFReg(struct net_device *dev,
 /******************************************************************************
  * function:  We support firmware to execute RF-R/W.
  * input:     net_device        *dev
- *            RF90_RADIO_PATH_E eRFPath
+ *            rf90_radio_path_e eRFPath
  *            u32               offset
  * output:    none
  * return:    u32
  * notice:
  ****************************************************************************/
 static u32 phy_FwRFSerialRead(struct net_device *dev,
-			      enum RF90_RADIO_PATH_E eRFPath,
+			      enum rf90_radio_path_e eRFPath,
 			      u32 offset)
 {
 	u32		reg = 0;
@@ -412,7 +412,7 @@ static u32 phy_FwRFSerialRead(struct net_device *dev,
 /******************************************************************************
  * function:  We support firmware to execute RF-R/W.
  * input:     net_device        *dev
- *            RF90_RADIO_PATH_E eRFPath
+ *            rf90_radio_path_e eRFPath
  *            u32               offset
  *            u32               data
  * output:    none
@@ -420,7 +420,7 @@ static u32 phy_FwRFSerialRead(struct net_device *dev,
  * notice:
  ****************************************************************************/
 static void phy_FwRFSerialWrite(struct net_device *dev,
-				enum RF90_RADIO_PATH_E eRFPath,
+				enum rf90_radio_path_e eRFPath,
 				u32 offset, u32 data)
 {
 	u8	time = 0;
@@ -688,14 +688,14 @@ static void rtl8192_InitBBRFRegDef(struct net_device *dev)
  *            sure whether BB and RF is OK
  * input:     net_device        *dev
  *            hw90_block_e      CheckBlock
- *            RF90_RADIO_PATH_E eRFPath  //only used when checkblock is
+ *            rf90_radio_path_e eRFPath  //only used when checkblock is
  *                                       //HW90_BLOCK_RF
  * output:    none
  * return:    return whether BB and RF is ok (0:OK, 1:Fail)
  * notice:    This function may be removed in the ASIC
  ******************************************************************************/
 u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, enum hw90_block_e CheckBlock,
-			    enum RF90_RADIO_PATH_E eRFPath)
+			    enum rf90_radio_path_e eRFPath)
 {
 	u8 ret = 0;
 	u32 i, CheckTimes = 4, reg = 0;
@@ -790,7 +790,7 @@ static void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	     eCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {
 		/* don't care RF path */
 		status = rtl8192_phy_checkBBAndRF(dev, (enum hw90_block_e)eCheckItem,
-						  (enum RF90_RADIO_PATH_E)0);
+						  (enum rf90_radio_path_e)0);
 		if (status != 0) {
 			RT_TRACE((COMP_ERR | COMP_PHY),
 				 "PHY_RF8256_Config(): Check PHY%d Fail!!\n",
@@ -962,13 +962,13 @@ void rtl8192_phy_updateInitGain(struct net_device *dev)
  * function:  This function read RF parameters from general head file,
  *            and do RF 3-wire
  * input:     net_device	*dev
- *            RF90_RADIO_PATH_E eRFPath
+ *            rf90_radio_path_e eRFPath
  * output:    none
  * return:    return code show if RF configuration is successful(0:pass, 1:fail)
  * notice:    Delay may be required for RF configuration
  *****************************************************************************/
 u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
-				      enum RF90_RADIO_PATH_E	eRFPath)
+				      enum rf90_radio_path_e	eRFPath)
 {
 
 	int i;
@@ -1386,7 +1386,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 		case CMD_ID_RF_WRITE_REG:
 			for (eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {
 				rtl8192_phy_SetRFReg(dev,
-						     (enum RF90_RADIO_PATH_E)eRFPath,
+						     (enum rf90_radio_path_e)eRFPath,
 						     CurrentCmd->para_1,
 						     bZebra1_ChannelNum,
 						     CurrentCmd->para_2);

commit b714c8c0b0558406950fb936a47c8868a917c164
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:23 2018 +0100

    staging:rtl8192u: Rename HW90_BLOCK_E - Style
    
    Rename the enumerated type HW90_BLOCK_E to hw90_block_e. Whilst this is
    not flagged by checkpatch types are meant to be in lowercase.
    
    This is a coding style change which should have no impact on runtime
    code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 983520b3aa25..c8c54484eab5 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -687,14 +687,14 @@ static void rtl8192_InitBBRFRegDef(struct net_device *dev)
  * function:  This function is to write register and then readback to make
  *            sure whether BB and RF is OK
  * input:     net_device        *dev
- *            HW90_BLOCK_E      CheckBlock
+ *            hw90_block_e      CheckBlock
  *            RF90_RADIO_PATH_E eRFPath  //only used when checkblock is
  *                                       //HW90_BLOCK_RF
  * output:    none
  * return:    return whether BB and RF is ok (0:OK, 1:Fail)
  * notice:    This function may be removed in the ASIC
  ******************************************************************************/
-u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, enum HW90_BLOCK_E CheckBlock,
+u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, enum hw90_block_e CheckBlock,
 			    enum RF90_RADIO_PATH_E eRFPath)
 {
 	u8 ret = 0;
@@ -786,10 +786,10 @@ static void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 
 	/* ----Ckeck FPGAPHY0 and PHY1 board is OK---- */
 	/* TODO: this function should be removed on ASIC */
-	for (eCheckItem = (enum HW90_BLOCK_E)HW90_BLOCK_PHY0;
+	for (eCheckItem = (enum hw90_block_e)HW90_BLOCK_PHY0;
 	     eCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {
 		/* don't care RF path */
-		status = rtl8192_phy_checkBBAndRF(dev, (enum HW90_BLOCK_E)eCheckItem,
+		status = rtl8192_phy_checkBBAndRF(dev, (enum hw90_block_e)eCheckItem,
 						  (enum RF90_RADIO_PATH_E)0);
 		if (status != 0) {
 			RT_TRACE((COMP_ERR | COMP_PHY),

commit a99d02401f2493fb0ddaa34b94e30e9437d2726f
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:22 2018 +0100

    staging:rtl8192u: Remove proxy rtl819XRadioD_Array - Style
    
    Remove the array rtl819XRadioD_Array which is only acting as a proxy to
    the real array Rtl8192UsbRadioD_Array.
    
    This is a coding style change which should have no impact on runtime
    code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 3ed48d6095d7..983520b3aa25 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -29,7 +29,6 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 };
 
 #define rtl819XMACPHY_Array Rtl8192UsbMACPHY_Array
-#define rtl819XRadioD_Array Rtl8192UsbRadioD_Array
 
 /******************************************************************************
  * function:  This function checks different RF type to execute legal judgement.
@@ -1023,14 +1022,14 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 	case RF90_PATH_D:
 		for (i = 0; i < RadioD_ArrayLength; i = i+2) {
 
-			if (rtl819XRadioD_Array[i] == 0xfe) {
+			if (Rtl8192UsbRadioD_Array[i] == 0xfe) {
 				mdelay(100);
 				continue;
 			}
 			rtl8192_phy_SetRFReg(dev, eRFPath,
-					     rtl819XRadioD_Array[i],
+					     Rtl8192UsbRadioD_Array[i],
 					     bMask12Bits,
-					     rtl819XRadioD_Array[i+1]);
+					     Rtl8192UsbRadioD_Array[i+1]);
 			mdelay(1);
 
 		}

commit 281da5305b051ea5dd4a8a9dfec5a3b4b7688125
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:21 2018 +0100

    staging:rtl8192u: Remove proxy rtl819XRadioC_Array - Style
    
    Remove the array rtl819XRadioC_Array which is only serving as a proxy for
    the real array Rtl8192UsbRadioC_Array. This is a coding style change and
    should have no impact on runtime code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 1cbb48c5c110..3ed48d6095d7 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -29,7 +29,6 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 };
 
 #define rtl819XMACPHY_Array Rtl8192UsbMACPHY_Array
-#define rtl819XRadioC_Array Rtl8192UsbRadioC_Array
 #define rtl819XRadioD_Array Rtl8192UsbRadioD_Array
 
 /******************************************************************************
@@ -1009,14 +1008,14 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 	case RF90_PATH_C:
 		for (i = 0; i < RadioC_ArrayLength; i = i+2) {
 
-			if (rtl819XRadioC_Array[i] == 0xfe) {
+			if (Rtl8192UsbRadioC_Array[i] == 0xfe) {
 				mdelay(100);
 				continue;
 			}
 			rtl8192_phy_SetRFReg(dev, eRFPath,
-					     rtl819XRadioC_Array[i],
+					     Rtl8192UsbRadioC_Array[i],
 					     bMask12Bits,
-					     rtl819XRadioC_Array[i+1]);
+					     Rtl8192UsbRadioC_Array[i+1]);
 			mdelay(1);
 
 		}

commit 416599d096ae05b164b5112b064df91fdd9dd980
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:20 2018 +0100

    staging:rtl8192u: Remove proxy rtl819XRadioB_Array - Style
    
    Remove the array rtl819XRadioB_Array Rtl8192UsbRadioB_Array which acts
    as a proxy the actual array Rtl8192UsbRadioB_Array. The only purpose, I
    can see for this implementation is to obscure the actual array being
    used Rtl8192UsbRadioB_Array.
    
    This is a coding style change which should have no impact on runtime
    code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 775dfa847b93..1cbb48c5c110 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -29,7 +29,6 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 };
 
 #define rtl819XMACPHY_Array Rtl8192UsbMACPHY_Array
-#define rtl819XRadioB_Array Rtl8192UsbRadioB_Array
 #define rtl819XRadioC_Array Rtl8192UsbRadioC_Array
 #define rtl819XRadioD_Array Rtl8192UsbRadioD_Array
 
@@ -995,14 +994,14 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 	case RF90_PATH_B:
 		for (i = 0; i < RadioB_ArrayLength; i = i+2) {
 
-			if (rtl819XRadioB_Array[i] == 0xfe) {
+			if (Rtl8192UsbRadioB_Array[i] == 0xfe) {
 				mdelay(100);
 				continue;
 			}
 			rtl8192_phy_SetRFReg(dev, eRFPath,
-					     rtl819XRadioB_Array[i],
+					     Rtl8192UsbRadioB_Array[i],
 					     bMask12Bits,
-					     rtl819XRadioB_Array[i+1]);
+					     Rtl8192UsbRadioB_Array[i+1]);
 			mdelay(1);
 
 		}

commit be208c7695ffb0c873435048c849d7d8323a5a96
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:19 2018 +0100

    staging:rtl8192u: Remove proxy rtl819XRadioA_Array - Style
    
    The array rtl819XRadioA_Array serves as a proxy array for the actual
    array Rtl8192UsbRadioA_Array. This implementation seems to serve no
    other purpose then to obscure the actually array Rtl8192UsbRadioA_Array.
    
    This is a coding style change which should have no impact on runtime
    code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index cf7b09f9818a..775dfa847b93 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -29,7 +29,6 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 };
 
 #define rtl819XMACPHY_Array Rtl8192UsbMACPHY_Array
-#define rtl819XRadioA_Array  Rtl8192UsbRadioA_Array
 #define rtl819XRadioB_Array Rtl8192UsbRadioB_Array
 #define rtl819XRadioC_Array Rtl8192UsbRadioC_Array
 #define rtl819XRadioD_Array Rtl8192UsbRadioD_Array
@@ -981,14 +980,14 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 	case RF90_PATH_A:
 		for (i = 0; i < RadioA_ArrayLength; i = i+2) {
 
-			if (rtl819XRadioA_Array[i] == 0xfe) {
+			if (Rtl8192UsbRadioA_Array[i] == 0xfe) {
 				mdelay(100);
 				continue;
 			}
 			rtl8192_phy_SetRFReg(dev, eRFPath,
-					     rtl819XRadioA_Array[i],
+					     Rtl8192UsbRadioA_Array[i],
 					     bMask12Bits,
-					     rtl819XRadioA_Array[i+1]);
+					     Rtl8192UsbRadioA_Array[i+1]);
 			mdelay(1);
 
 		}

commit def6b79f3f2d0439822a2eab5ddfe8696e999ad4
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:18 2018 +0100

    staging:rtl8192u: Remove proxy array rtl819XAGCTAB_Array - Style
    
    Remove the array rtl819XAGCTAB_Array which is only a proxy to the
    array Rtl8192UsbAGCTAB_Array. There appears to be no purpose
    served by this implementation, other then to obscure the
    Rtl8192UsbAGCTAB_Array structure, which is actually written to and
    read from.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 8d44bbe90221..cf7b09f9818a 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -33,7 +33,6 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 #define rtl819XRadioB_Array Rtl8192UsbRadioB_Array
 #define rtl819XRadioC_Array Rtl8192UsbRadioC_Array
 #define rtl819XRadioD_Array Rtl8192UsbRadioD_Array
-#define rtl819XAGCTAB_Array Rtl8192UsbAGCTAB_Array
 
 /******************************************************************************
  * function:  This function checks different RF type to execute legal judgement.
@@ -542,12 +541,12 @@ void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 		}
 	} else if (ConfigType == BaseBand_Config_AGC_TAB) {
 		for (i = 0; i < AGCTAB_ArrayLength; i += 2) {
-			rtl8192_setBBreg(dev, rtl819XAGCTAB_Array[i],
-					 bMaskDWord, rtl819XAGCTAB_Array[i+1]);
+			rtl8192_setBBreg(dev, Rtl8192UsbAGCTAB_Array[i],
+					 bMaskDWord, Rtl8192UsbAGCTAB_Array[i+1]);
 			RT_TRACE(COMP_DBG,
-				 "i: %x, rtl819XAGCTAB_Array[0]=%x rtl819XAGCTAB_Array[1]=%x\n",
-				 i, rtl819XAGCTAB_Array[i],
-				 rtl819XAGCTAB_Array[i+1]);
+				 "i: %x, Rtl8192UsbAGCTAB_Array[0]=%x Rtl8192UsbAGCTAB_Array[1]=%x\n",
+				 i, Rtl8192UsbAGCTAB_Array[i],
+				 Rtl8192UsbAGCTAB_Array[i+1]);
 		}
 	}
 }

commit 22be361aa9045a60c47fcd9b001e2d478f387989
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:17 2018 +0100

    staging:rtl8192u: Remove proxy struct rtl819XPHY_REG_1T2RArray - Style
    
    Remove the struct rtl819XPHY_REG_1T2RArray which is simply a proxy for
    the struct Rtl8192UsbPHY_REG_1T2RArray. There appears to be no purpose
    served by this implementation, other then to obscure the
    Rtl8192UsbPHY_REG_1T2RArray structure.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index cc35ca7b9140..8d44bbe90221 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -28,8 +28,6 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 	0x0f72, /* 2484    */
 };
 
-
-#define rtl819XPHY_REG_1T2RArray Rtl8192UsbPHY_REG_1T2RArray
 #define rtl819XMACPHY_Array Rtl8192UsbMACPHY_Array
 #define rtl819XRadioA_Array  Rtl8192UsbRadioA_Array
 #define rtl819XRadioB_Array Rtl8192UsbRadioB_Array
@@ -534,13 +532,13 @@ void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 #endif
 	if (ConfigType == BaseBand_Config_PHY_REG) {
 		for (i = 0; i < PHY_REG_1T2RArrayLength; i += 2) {
-			rtl8192_setBBreg(dev, rtl819XPHY_REG_1T2RArray[i],
+			rtl8192_setBBreg(dev, Rtl8192UsbPHY_REG_1T2RArray[i],
 					 bMaskDWord,
-					 rtl819XPHY_REG_1T2RArray[i+1]);
+					 Rtl8192UsbPHY_REG_1T2RArray[i+1]);
 			RT_TRACE(COMP_DBG,
 				 "i: %x, Rtl819xUsbPHY_REGArray[0]=%x Rtl819xUsbPHY_REGArray[1]=%x\n",
-				 i, rtl819XPHY_REG_1T2RArray[i],
-				 rtl819XPHY_REG_1T2RArray[i+1]);
+				 i, Rtl8192UsbPHY_REG_1T2RArray[i],
+				 Rtl8192UsbPHY_REG_1T2RArray[i+1]);
 		}
 	} else if (ConfigType == BaseBand_Config_AGC_TAB) {
 		for (i = 0; i < AGCTAB_ArrayLength; i += 2) {

commit 4531f1934bf6aefee296c783a42d8d4867800d99
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:16 2018 +0100

    staging:rtl8192u: Remove proxy struct rtl819XMACPHY_Array_PG - Style
    
    Remove the struct rtl819XMACPHY_Array_PG which is simply a proxy for
    the struct Rtl8192UsbMACPHY_Array_PG. There appears to be no purpose
    served by this implementation, other then to obscure the
    Rtl8192UsbMACPHY_Array_PG structure.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 496f42b8f425..cc35ca7b9140 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -30,7 +30,6 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 
 
 #define rtl819XPHY_REG_1T2RArray Rtl8192UsbPHY_REG_1T2RArray
-#define rtl819XMACPHY_Array_PG Rtl8192UsbMACPHY_Array_PG
 #define rtl819XMACPHY_Array Rtl8192UsbMACPHY_Array
 #define rtl819XRadioA_Array  Rtl8192UsbRadioA_Array
 #define rtl819XRadioB_Array Rtl8192UsbRadioB_Array
@@ -491,7 +490,7 @@ void rtl8192_phy_configmac(struct net_device *dev)
 	if (priv->btxpowerdata_readfromEEPORM) {
 		RT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array_PG\n");
 		dwArrayLen = MACPHY_Array_PGLength;
-		pdwArray = rtl819XMACPHY_Array_PG;
+		pdwArray = Rtl8192UsbMACPHY_Array_PG;
 
 	} else {
 		RT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array\n");

commit e918443caf095387a8ccf57e8b38fc858e4b231f
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:15 2018 +0100

    staging:rtl8192u: Rename msDelay to ms_delay - Style
    
    Rename the member variable msDelay to ms_delay. This change clears the
    checkpatch issue with CamelCase naming. The change is purely a coding
    style change which should not impact runtime code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 904cc8c1a83b..496f42b8f425 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1247,7 +1247,7 @@ static u8 rtl8192_phy_SetSwChnlCmdArray(struct sw_chnl_cmd *CmdTable, u32 CmdTab
 	pCmd->cmd_id = CmdID;
 	pCmd->para_1 = Para1;
 	pCmd->para_2 = Para2;
-	pCmd->msDelay = msDelay;
+	pCmd->ms_delay = msDelay;
 
 	return true;
 }
@@ -1365,7 +1365,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 
 		if (CurrentCmd->cmd_id == CMD_ID_END) {
 			if ((*stage) == 2) {
-				(*delay) = CurrentCmd->msDelay;
+				(*delay) = CurrentCmd->ms_delay;
 				return true;
 			}
 			(*stage)++;
@@ -1407,7 +1407,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 		break;
 	} while (true);
 
-	(*delay) = CurrentCmd->msDelay;
+	(*delay) = CurrentCmd->ms_delay;
 	(*step)++;
 	return false;
 }

commit 21807031af7c9bd66d134787811677eb8b6ae50c
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:14 2018 +0100

    staging:rtl8192u: Rename Para2 to para_2 - style
    
    Rename member variable Para2 to para_2. This change clears the checkpatch
    issue with CamelCase naming. The change is purely a coding style change
    and should have no impact on runtime code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index c2a73ec90f70..904cc8c1a83b 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1246,7 +1246,7 @@ static u8 rtl8192_phy_SetSwChnlCmdArray(struct sw_chnl_cmd *CmdTable, u32 CmdTab
 	pCmd = CmdTable + CmdTableIdx;
 	pCmd->cmd_id = CmdID;
 	pCmd->para_1 = Para1;
-	pCmd->Para2 = Para2;
+	pCmd->para_2 = Para2;
 	pCmd->msDelay = msDelay;
 
 	return true;
@@ -1381,15 +1381,15 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 			break;
 		case CMD_ID_WRITE_PORT_ULONG:
 			write_nic_dword(dev, CurrentCmd->para_1,
-					CurrentCmd->Para2);
+					CurrentCmd->para_2);
 			break;
 		case CMD_ID_WRITE_PORT_USHORT:
 			write_nic_word(dev, CurrentCmd->para_1,
-				       (u16)CurrentCmd->Para2);
+				       (u16)CurrentCmd->para_2);
 			break;
 		case CMD_ID_WRITE_PORT_UCHAR:
 			write_nic_byte(dev, CurrentCmd->para_1,
-				       (u8)CurrentCmd->Para2);
+				       (u8)CurrentCmd->para_2);
 			break;
 		case CMD_ID_RF_WRITE_REG:
 			for (eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {
@@ -1397,7 +1397,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 						     (enum RF90_RADIO_PATH_E)eRFPath,
 						     CurrentCmd->para_1,
 						     bZebra1_ChannelNum,
-						     CurrentCmd->Para2);
+						     CurrentCmd->para_2);
 			}
 			break;
 		default:

commit 33f28ab7a0b72c79c67b7c677fcadc5e63fa2282
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:13 2018 +0100

    staging:rtl8192u: Rename Para1 > para_1 - Style
    
    Rename the member variable Para1 to para_1. This change clears the
    checkpatch issue with CamelCase naming. The change is purely a coding
    style change and should have no impact on runtime code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 17cc47e20145..c2a73ec90f70 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1245,7 +1245,7 @@ static u8 rtl8192_phy_SetSwChnlCmdArray(struct sw_chnl_cmd *CmdTable, u32 CmdTab
 
 	pCmd = CmdTable + CmdTableIdx;
 	pCmd->cmd_id = CmdID;
-	pCmd->Para1 = Para1;
+	pCmd->para_1 = Para1;
 	pCmd->Para2 = Para2;
 	pCmd->msDelay = msDelay;
 
@@ -1380,22 +1380,22 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 				rtl8192_SetTxPowerLevel(dev, channel);
 			break;
 		case CMD_ID_WRITE_PORT_ULONG:
-			write_nic_dword(dev, CurrentCmd->Para1,
+			write_nic_dword(dev, CurrentCmd->para_1,
 					CurrentCmd->Para2);
 			break;
 		case CMD_ID_WRITE_PORT_USHORT:
-			write_nic_word(dev, CurrentCmd->Para1,
+			write_nic_word(dev, CurrentCmd->para_1,
 				       (u16)CurrentCmd->Para2);
 			break;
 		case CMD_ID_WRITE_PORT_UCHAR:
-			write_nic_byte(dev, CurrentCmd->Para1,
+			write_nic_byte(dev, CurrentCmd->para_1,
 				       (u8)CurrentCmd->Para2);
 			break;
 		case CMD_ID_RF_WRITE_REG:
 			for (eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {
 				rtl8192_phy_SetRFReg(dev,
 						     (enum RF90_RADIO_PATH_E)eRFPath,
-						     CurrentCmd->Para1,
+						     CurrentCmd->para_1,
 						     bZebra1_ChannelNum,
 						     CurrentCmd->Para2);
 			}

commit d2a5c987e7f25461cbd87d679155d19047920898
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:12 2018 +0100

    staging:rtl8192u: Rename CmdID - Style
    
    Rename the member variable CmdId to cmd_id. This change clears the
    checkpatch issue with CamelCase naming. The change is purely a coding
    style change which should have no impact on runtime code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 4a49bc1f139c..17cc47e20145 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1244,7 +1244,7 @@ static u8 rtl8192_phy_SetSwChnlCmdArray(struct sw_chnl_cmd *CmdTable, u32 CmdTab
 	}
 
 	pCmd = CmdTable + CmdTableIdx;
-	pCmd->CmdID = CmdID;
+	pCmd->cmd_id = CmdID;
 	pCmd->Para1 = Para1;
 	pCmd->Para2 = Para2;
 	pCmd->msDelay = msDelay;
@@ -1363,7 +1363,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 			break;
 		}
 
-		if (CurrentCmd->CmdID == CMD_ID_END) {
+		if (CurrentCmd->cmd_id == CMD_ID_END) {
 			if ((*stage) == 2) {
 				(*delay) = CurrentCmd->msDelay;
 				return true;
@@ -1373,7 +1373,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 			continue;
 		}
 
-		switch (CurrentCmd->CmdID) {
+		switch (CurrentCmd->cmd_id) {
 		case CMD_ID_SET_TX_PWR_LEVEL:
 			if (priv->card_8192_version == (u8)VERSION_819xU_A)
 				/* consider it later! */

commit a1b34e427c5602f7e21ea449e6561165a0c4b7dc
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Thu Jul 26 20:24:11 2018 +0100

    staging:rtl8192u: Rename SwChnlCmd - Style
    
    Rename the structure SwChnlCmd to sw_chnl_cmd. This change clears the
    checkpatch issue with CamelCase naming. The change is purely a coding
    style change and should have no impact on runtime code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 75fcd3134b6d..4a49bc1f139c 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1215,8 +1215,8 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 }
 
 /******************************************************************************
- * function:  This function sets command table variable (struct SwChnlCmd).
- * input:     SwChnlCmd      *CmdTable    //table to be set
+ * function:  This function sets command table variable (struct sw_chnl_cmd).
+ * input:     sw_chnl_cmd      *CmdTable    //table to be set
  *            u32            CmdTableIdx  //variable index in table to be set
  *            u32            CmdTableSz   //table size
  *            switch_chan_cmd_id    CmdID        //command ID to set
@@ -1227,11 +1227,11 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
  * return:    true if finished, false otherwise
  * notice:
  ******************************************************************************/
-static u8 rtl8192_phy_SetSwChnlCmdArray(struct SwChnlCmd *CmdTable, u32 CmdTableIdx,
+static u8 rtl8192_phy_SetSwChnlCmdArray(struct sw_chnl_cmd *CmdTable, u32 CmdTableIdx,
 					u32 CmdTableSz, enum switch_chan_cmd_id CmdID,
 					u32 Para1, u32 Para2, u32 msDelay)
 {
-	struct SwChnlCmd *pCmd;
+	struct sw_chnl_cmd *pCmd;
 
 	if (CmdTable == NULL) {
 		RT_TRACE(COMP_ERR, "%s(): CmdTable cannot be NULL\n", __func__);
@@ -1268,13 +1268,13 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 				       u8 *stage, u8 *step, u32 *delay)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	struct SwChnlCmd   PreCommonCmd[MAX_PRECMD_CNT];
+	struct sw_chnl_cmd   PreCommonCmd[MAX_PRECMD_CNT];
 	u32		   PreCommonCmdCnt;
-	struct SwChnlCmd   PostCommonCmd[MAX_POSTCMD_CNT];
+	struct sw_chnl_cmd   PostCommonCmd[MAX_POSTCMD_CNT];
 	u32		   PostCommonCmdCnt;
-	struct SwChnlCmd   RfDependCmd[MAX_RFDEPENDCMD_CNT];
+	struct sw_chnl_cmd   RfDependCmd[MAX_RFDEPENDCMD_CNT];
 	u32		   RfDependCmdCnt;
-	struct SwChnlCmd  *CurrentCmd = NULL;
+	struct sw_chnl_cmd  *CurrentCmd = NULL;
 	u8		   eRFPath;
 
 	RT_TRACE(COMP_CH, "%s() stage: %d, step: %d, channel: %d\n",

commit f6e1472ae3b14a1e9b19ad1f9bebdfad769c9c25
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Fri Jul 13 12:23:10 2018 +0100

    staging:rtl8192u: Rename CmdID_RF_WriteReg > CMD_ID_RF_WRITE_REG - Style
    
    Rename enum label CmdID_RF_WriteReg to CMD_ID_RF_WRITE_REG. This change clears
    the checkpatch issue with CamelCase. The change is style only and should not
    impact code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 6c57c38dc9fe..75fcd3134b6d 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1315,7 +1315,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 		}
 		rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++,
 					      MAX_RFDEPENDCMD_CNT,
-					      CmdID_RF_WriteReg,
+					      CMD_ID_RF_WRITE_REG,
 					      rZebra1_Channel,
 					      RF_CHANNEL_TABLE_ZEBRA[channel],
 					      10);
@@ -1334,7 +1334,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 		}
 		rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++,
 					      MAX_RFDEPENDCMD_CNT,
-					      CmdID_RF_WriteReg,
+					      CMD_ID_RF_WRITE_REG,
 					      rZebra1_Channel, channel, 10);
 		rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++,
 					      MAX_RFDEPENDCMD_CNT,
@@ -1391,7 +1391,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 			write_nic_byte(dev, CurrentCmd->Para1,
 				       (u8)CurrentCmd->Para2);
 			break;
-		case CmdID_RF_WriteReg:
+		case CMD_ID_RF_WRITE_REG:
 			for (eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {
 				rtl8192_phy_SetRFReg(dev,
 						     (enum RF90_RADIO_PATH_E)eRFPath,

commit 64641cf65eed2f6f4f52d5d76e03482accdb1699
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Fri Jul 13 12:23:09 2018 +0100

    staging:rtl8192u: Rename CmdID_WritePortUchar > CMD_ID_WRITE_PORT_UCHAR
    
    Rename the enum label CmdID_WritePortUchar to CMD_ID_WRITE_PORT_UCHAR, to
    clear the checkpatch issue with CamelCase. The change is a coding style change
    only and should not impact code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index a681e7eab219..6c57c38dc9fe 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1387,7 +1387,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 			write_nic_word(dev, CurrentCmd->Para1,
 				       (u16)CurrentCmd->Para2);
 			break;
-		case CmdID_WritePortUchar:
+		case CMD_ID_WRITE_PORT_UCHAR:
 			write_nic_byte(dev, CurrentCmd->Para1,
 				       (u8)CurrentCmd->Para2);
 			break;

commit 61c9f41b317500d95e562726d15c640ce5b4de76
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Fri Jul 13 12:23:08 2018 +0100

    staging:rtl8192u: Rename CmdID_WritePortUshort > CMD_ID_WRITE_PORT_USHORT
    
    Rename the enum label CmdID_WritePortUshort to CMD_ID_WRITE_PORT_USHORT to
    clear the checkpatch warning on CamelCase naming. This is a coding style
    change only and should not impact code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index a10d3455b1f8..a681e7eab219 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1383,7 +1383,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 			write_nic_dword(dev, CurrentCmd->Para1,
 					CurrentCmd->Para2);
 			break;
-		case CmdID_WritePortUshort:
+		case CMD_ID_WRITE_PORT_USHORT:
 			write_nic_word(dev, CurrentCmd->Para1,
 				       (u16)CurrentCmd->Para2);
 			break;

commit 3ebdf34f548141d1d7f3a69c10b590789a0e5411
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Fri Jul 13 12:23:07 2018 +0100

    staging:rtl8192u: Rename CmdID_WritePortUlong > CMD_ID_WRITE_PORT_ULONG
    
    Rename enum label CmdID_WritePortUlong to CMD_ID_WRITE_PORT_ULONG to clear the
    checkpatch CamelCase issue. Simple syle change which should not impact code
    execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 0b850abe3533..a10d3455b1f8 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1379,7 +1379,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 				/* consider it later! */
 				rtl8192_SetTxPowerLevel(dev, channel);
 			break;
-		case CmdID_WritePortUlong:
+		case CMD_ID_WRITE_PORT_ULONG:
 			write_nic_dword(dev, CurrentCmd->Para1,
 					CurrentCmd->Para2);
 			break;

commit 1be8f4e7588f5f4272baac097f61396eeb513183
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Fri Jul 13 12:23:05 2018 +0100

    staging:rtl8192u: rename CmdID_SetTxPowerLevel > CMD_ID_SET_TX_PWR_LEVEL
    
    Rename enumeration label CmdID_SetTxPowerLevel to
    CMD_ID_SET_TX_PWR_LEVEL. This change clears a checkpatch warning on
    CamelCase. The change should not impact runtime execution, style change only.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index c67159f2d9ab..0b850abe3533 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1292,7 +1292,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 	/* <1> Fill up pre common command. */
 	PreCommonCmdCnt = 0;
 	rtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++,
-				      MAX_PRECMD_CNT, CmdID_SetTxPowerLevel,
+				      MAX_PRECMD_CNT, CMD_ID_SET_TX_PWR_LEVEL,
 				      0, 0, 0);
 	rtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++,
 				      MAX_PRECMD_CNT, CMD_ID_END, 0, 0, 0);
@@ -1374,7 +1374,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 		}
 
 		switch (CurrentCmd->CmdID) {
-		case CmdID_SetTxPowerLevel:
+		case CMD_ID_SET_TX_PWR_LEVEL:
 			if (priv->card_8192_version == (u8)VERSION_819xU_A)
 				/* consider it later! */
 				rtl8192_SetTxPowerLevel(dev, channel);

commit 8772da06f6d01636a9c6e0fb7634c19c1be9d6e5
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Fri Jul 13 12:23:04 2018 +0100

    staging:rtl8192u: Rename enum label CmdID_End > CMD_ID_END - Style
    
    Rename enum label to clear a CamelCase warning from checkpatch. This is a
    simple style change and should not impact execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index c373dbe06154..c67159f2d9ab 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1295,13 +1295,13 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 				      MAX_PRECMD_CNT, CmdID_SetTxPowerLevel,
 				      0, 0, 0);
 	rtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++,
-				      MAX_PRECMD_CNT, CmdID_End, 0, 0, 0);
+				      MAX_PRECMD_CNT, CMD_ID_END, 0, 0, 0);
 
 	/* <2> Fill up post common command. */
 	PostCommonCmdCnt = 0;
 
 	rtl8192_phy_SetSwChnlCmdArray(PostCommonCmd, PostCommonCmdCnt++,
-				      MAX_POSTCMD_CNT, CmdID_End, 0, 0, 0);
+				      MAX_POSTCMD_CNT, CMD_ID_END, 0, 0, 0);
 
 	/* <3> Fill up RF dependent command. */
 	RfDependCmdCnt = 0;
@@ -1321,7 +1321,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 					      10);
 		rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++,
 					      MAX_RFDEPENDCMD_CNT,
-					      CmdID_End, 0, 0, 0);
+					      CMD_ID_END, 0, 0, 0);
 		break;
 
 	case RF_8256:
@@ -1338,7 +1338,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 					      rZebra1_Channel, channel, 10);
 		rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++,
 					      MAX_RFDEPENDCMD_CNT,
-					      CmdID_End, 0, 0, 0);
+					      CMD_ID_END, 0, 0, 0);
 		break;
 
 	case RF_8258:
@@ -1363,7 +1363,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 			break;
 		}
 
-		if (CurrentCmd->CmdID == CmdID_End) {
+		if (CurrentCmd->CmdID == CMD_ID_END) {
 			if ((*stage) == 2) {
 				(*delay) = CurrentCmd->msDelay;
 				return true;

commit 2dad9cba09036f614f39e4c1be258d7ed78d591d
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Fri Jul 13 12:23:03 2018 +0100

    staging:rtl8192u: Rename SwChnlCmdID > switch_chan_cmd_id - Coding Style
    
    Rename enumerated type to clear a CamelCase warning from checkpatch. The
    change is style only. No impact on run time execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index d88f6c3ed46f..c373dbe06154 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1219,7 +1219,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
  * input:     SwChnlCmd      *CmdTable    //table to be set
  *            u32            CmdTableIdx  //variable index in table to be set
  *            u32            CmdTableSz   //table size
- *            SwChnlCmdID    CmdID        //command ID to set
+ *            switch_chan_cmd_id    CmdID        //command ID to set
  *            u32            Para1
  *            u32            Para2
  *            u32            msDelay
@@ -1228,7 +1228,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
  * notice:
  ******************************************************************************/
 static u8 rtl8192_phy_SetSwChnlCmdArray(struct SwChnlCmd *CmdTable, u32 CmdTableIdx,
-					u32 CmdTableSz, enum SwChnlCmdID CmdID,
+					u32 CmdTableSz, enum switch_chan_cmd_id CmdID,
 					u32 Para1, u32 Para2, u32 msDelay)
 {
 	struct SwChnlCmd *pCmd;

commit 9821cb6d9bcad7144f0596d39a97b99dd9318600
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Fri Jul 13 12:23:02 2018 +0100

    staging:rtl8192u: remove typedef from structure SwChnlCmd - Style
    
    Checkpatch warns against creation of new types in code. This patch simply
    removes the "typedef" declaration of the structure SwChnlCmd to clear this
    issue. Simple coding style issue which should not impact runtime execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 3df4775e1f99..d88f6c3ed46f 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1227,11 +1227,11 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
  * return:    true if finished, false otherwise
  * notice:
  ******************************************************************************/
-static u8 rtl8192_phy_SetSwChnlCmdArray(SwChnlCmd *CmdTable, u32 CmdTableIdx,
+static u8 rtl8192_phy_SetSwChnlCmdArray(struct SwChnlCmd *CmdTable, u32 CmdTableIdx,
 					u32 CmdTableSz, enum SwChnlCmdID CmdID,
 					u32 Para1, u32 Para2, u32 msDelay)
 {
-	SwChnlCmd *pCmd;
+	struct SwChnlCmd *pCmd;
 
 	if (CmdTable == NULL) {
 		RT_TRACE(COMP_ERR, "%s(): CmdTable cannot be NULL\n", __func__);
@@ -1268,14 +1268,14 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 				       u8 *stage, u8 *step, u32 *delay)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	SwChnlCmd	PreCommonCmd[MAX_PRECMD_CNT];
-	u32		PreCommonCmdCnt;
-	SwChnlCmd	PostCommonCmd[MAX_POSTCMD_CNT];
-	u32		PostCommonCmdCnt;
-	SwChnlCmd	RfDependCmd[MAX_RFDEPENDCMD_CNT];
-	u32		RfDependCmdCnt;
-	SwChnlCmd	*CurrentCmd = NULL;
-	u8		eRFPath;
+	struct SwChnlCmd   PreCommonCmd[MAX_PRECMD_CNT];
+	u32		   PreCommonCmdCnt;
+	struct SwChnlCmd   PostCommonCmd[MAX_POSTCMD_CNT];
+	u32		   PostCommonCmdCnt;
+	struct SwChnlCmd   RfDependCmd[MAX_RFDEPENDCMD_CNT];
+	u32		   RfDependCmdCnt;
+	struct SwChnlCmd  *CurrentCmd = NULL;
+	u8		   eRFPath;
 
 	RT_TRACE(COMP_CH, "%s() stage: %d, step: %d, channel: %d\n",
 		 __func__, *stage, *step, channel);

commit 8b5c53e62c98e52b555feb52ff8fa8fc913141e7
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Fri Jul 13 12:23:01 2018 +0100

    staging:rtl8192u: Remove typdef from enumeration RF90_RADIO_PATH_E - Style
    
    Checkpatch warns about the creation of new types. This patch simply removes
    the typedef from the enumeration RF90_RADIO_PATH_E to clear this checkpatch
    warning. There should be no impact on run time code execution, as this is a
    coding style issue only.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 0462de662eff..3df4775e1f99 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -108,11 +108,13 @@ u32 rtl8192_QueryBBReg(struct net_device *dev, u32 reg_addr, u32 bitmask)
 	return (reg & bitmask) >> bitshift;
 }
 
-static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
+static u32 phy_FwRFSerialRead(struct net_device *dev,
+			      enum RF90_RADIO_PATH_E eRFPath,
 			      u32 offset);
 
 static void phy_FwRFSerialWrite(struct net_device *dev,
-				RF90_RADIO_PATH_E eRFPath, u32  offset,
+				enum RF90_RADIO_PATH_E eRFPath,
+				u32  offset,
 				u32  data);
 
 /******************************************************************************
@@ -130,7 +132,7 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
  *            ---need more spec for this information.
  ******************************************************************************/
 static u32 rtl8192_phy_RFSerialRead(struct net_device *dev,
-				    RF90_RADIO_PATH_E eRFPath, u32 offset)
+				    enum RF90_RADIO_PATH_E eRFPath, u32 offset)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 ret = 0;
@@ -215,7 +217,8 @@ static u32 rtl8192_phy_RFSerialRead(struct net_device *dev,
  * ---------------------------------------------------------------------------
  *****************************************************************************/
 static void rtl8192_phy_RFSerialWrite(struct net_device *dev,
-				      RF90_RADIO_PATH_E eRFPath, u32 offset,
+				      enum RF90_RADIO_PATH_E eRFPath,
+				      u32 offset,
 				      u32 data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -279,7 +282,8 @@ static void rtl8192_phy_RFSerialWrite(struct net_device *dev,
  * return:    none
  * notice:
  *****************************************************************************/
-void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
+void rtl8192_phy_SetRFReg(struct net_device *dev,
+			  enum RF90_RADIO_PATH_E eRFPath,
 			  u32 reg_addr, u32 bitmask, u32 data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -327,7 +331,8 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
  * return:    u32               data     //the readback register value
  * notice:
  *****************************************************************************/
-u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
+u32 rtl8192_phy_QueryRFReg(struct net_device *dev,
+			   enum RF90_RADIO_PATH_E eRFPath,
 			   u32 reg_addr, u32 bitmask)
 {
 	u32 reg, bitshift;
@@ -357,7 +362,8 @@ u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
  * return:    u32
  * notice:
  ****************************************************************************/
-static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
+static u32 phy_FwRFSerialRead(struct net_device *dev,
+			      enum RF90_RADIO_PATH_E eRFPath,
 			      u32 offset)
 {
 	u32		reg = 0;
@@ -422,7 +428,8 @@ static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
  * notice:
  ****************************************************************************/
 static void phy_FwRFSerialWrite(struct net_device *dev,
-				RF90_RADIO_PATH_E eRFPath, u32 offset, u32 data)
+				enum RF90_RADIO_PATH_E eRFPath,
+				u32 offset, u32 data)
 {
 	u8	time = 0;
 	u32	tmp;
@@ -696,7 +703,7 @@ static void rtl8192_InitBBRFRegDef(struct net_device *dev)
  * notice:    This function may be removed in the ASIC
  ******************************************************************************/
 u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, enum HW90_BLOCK_E CheckBlock,
-			    RF90_RADIO_PATH_E eRFPath)
+			    enum RF90_RADIO_PATH_E eRFPath)
 {
 	u8 ret = 0;
 	u32 i, CheckTimes = 4, reg = 0;
@@ -791,7 +798,7 @@ static void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	     eCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {
 		/* don't care RF path */
 		status = rtl8192_phy_checkBBAndRF(dev, (enum HW90_BLOCK_E)eCheckItem,
-						  (RF90_RADIO_PATH_E)0);
+						  (enum RF90_RADIO_PATH_E)0);
 		if (status != 0) {
 			RT_TRACE((COMP_ERR | COMP_PHY),
 				 "PHY_RF8256_Config(): Check PHY%d Fail!!\n",
@@ -969,7 +976,7 @@ void rtl8192_phy_updateInitGain(struct net_device *dev)
  * notice:    Delay may be required for RF configuration
  *****************************************************************************/
 u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
-				      RF90_RADIO_PATH_E	eRFPath)
+				      enum RF90_RADIO_PATH_E	eRFPath)
 {
 
 	int i;
@@ -1387,7 +1394,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 		case CmdID_RF_WriteReg:
 			for (eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {
 				rtl8192_phy_SetRFReg(dev,
-						     (RF90_RADIO_PATH_E)eRFPath,
+						     (enum RF90_RADIO_PATH_E)eRFPath,
 						     CurrentCmd->Para1,
 						     bZebra1_ChannelNum,
 						     CurrentCmd->Para2);

commit 983e14e25443d63adf228bc0c60f1bfa2a814166
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Fri Jul 13 12:23:00 2018 +0100

    staging:rtl8192u: remove typdef from enumeration HW90_BLOCK_E - Style
    
    Checkpatch warns about the creation of new types in code. This patch simply
    removes the typedef from the enumeration HW90_BLOCK_E to clear this
    warning. There should be no impact on run time code execution.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index bc86e6bfb8f5..0462de662eff 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -695,7 +695,7 @@ static void rtl8192_InitBBRFRegDef(struct net_device *dev)
  * return:    return whether BB and RF is ok (0:OK, 1:Fail)
  * notice:    This function may be removed in the ASIC
  ******************************************************************************/
-u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
+u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, enum HW90_BLOCK_E CheckBlock,
 			    RF90_RADIO_PATH_E eRFPath)
 {
 	u8 ret = 0;
@@ -787,10 +787,10 @@ static void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 
 	/* ----Ckeck FPGAPHY0 and PHY1 board is OK---- */
 	/* TODO: this function should be removed on ASIC */
-	for (eCheckItem = (HW90_BLOCK_E)HW90_BLOCK_PHY0;
+	for (eCheckItem = (enum HW90_BLOCK_E)HW90_BLOCK_PHY0;
 	     eCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {
 		/* don't care RF path */
-		status = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem,
+		status = rtl8192_phy_checkBBAndRF(dev, (enum HW90_BLOCK_E)eCheckItem,
 						  (RF90_RADIO_PATH_E)0);
 		if (status != 0) {
 			RT_TRACE((COMP_ERR | COMP_PHY),

commit 4162433ac98e07501e42dccd176ae846dedc0e21
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Fri Jul 13 12:22:59 2018 +0100

    staging:rtl8192u: remove typedef of enumeration SwChnlCmdID - Style
    
    To clear a checkpatch issue removed the typedef of the enumeration SwChnlCmdID
    this should not impact runtime code as it's only a coding style change.
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 98cfc222e241..bc86e6bfb8f5 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1221,7 +1221,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
  * notice:
  ******************************************************************************/
 static u8 rtl8192_phy_SetSwChnlCmdArray(SwChnlCmd *CmdTable, u32 CmdTableIdx,
-					u32 CmdTableSz, SwChnlCmdID CmdID,
+					u32 CmdTableSz, enum SwChnlCmdID CmdID,
 					u32 Para1, u32 Para2, u32 msDelay)
 {
 	SwChnlCmd *pCmd;

commit 0bde13ed847923dfb55185c5280b7390f627dc80
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Sat Jul 7 15:55:07 2018 +0100

    staging:rtl8192u: rename HT_EXTCHNL_OFFSET -> enum ht_extension_chan_width
    
    remove the typedef of enumerated type HT_EXTCHNL_OFFSET and replace it with
    'enum ht_extension_chan_offset'
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 8bb14cc79d8a..98cfc222e241 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1663,8 +1663,9 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
  * notice:    I doubt whether SetBWModeInProgress flag is necessary as we can
  *	      test whether current work in the queue or not.//do I?
  *****************************************************************************/
-void rtl8192_SetBWMode(struct net_device *dev, enum ht_channel_width bandwidth,
-		       HT_EXTCHNL_OFFSET offset)
+void rtl8192_SetBWMode(struct net_device *dev,
+		       enum ht_channel_width bandwidth,
+		       enum ht_extension_chan_offset offset)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 

commit 854727247ab9fb3547d39b9b3610b682223b9bf2
Author: John Whitmore <johnfwhitmore@gmail.com>
Date:   Sat Jul 7 15:55:02 2018 +0100

    staging:rtl8192u: rename HT_CHANNEL_WIDTH -> enum ht_channel_width
    
    remove the typedef HT_CHANNEL_WIDTH and replace with 'enum ht_channel_width'
    
    Signed-off-by: John Whitmore <johnfwhitmore@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 12750671c860..8bb14cc79d8a 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1663,7 +1663,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
  * notice:    I doubt whether SetBWModeInProgress flag is necessary as we can
  *	      test whether current work in the queue or not.//do I?
  *****************************************************************************/
-void rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH bandwidth,
+void rtl8192_SetBWMode(struct net_device *dev, enum ht_channel_width bandwidth,
 		       HT_EXTCHNL_OFFSET offset)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 3874f8307117..12750671c860 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include "r8192U.h"
 #include "r8192U_hw.h"
 #include "r819xU_phy.h"

commit f78d76699fe73d6a5faf344b327e7a54bfb1b1de
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Apr 21 17:19:31 2017 +0100

    staging: rtl8192u: fix spelling mistake in variable name *attentuation
    
    Fix the spelling of a bunch of variables, from *attentuation to
    *attenuation.  No functional change.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index c99130fdb8ee..3874f8307117 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1559,17 +1559,17 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 				 0x00100000, 1);
 
 		/* Correct the tx power for CCK rate in 20M. */
-		priv->cck_present_attentuation =
-			priv->cck_present_attentuation_20Mdefault +
-			priv->cck_present_attentuation_difference;
-
-		if (priv->cck_present_attentuation > 22)
-			priv->cck_present_attentuation = 22;
-		if (priv->cck_present_attentuation < 0)
-			priv->cck_present_attentuation = 0;
+		priv->cck_present_attenuation =
+			priv->cck_present_attenuation_20Mdefault +
+			priv->cck_present_attenuation_difference;
+
+		if (priv->cck_present_attenuation > 22)
+			priv->cck_present_attenuation = 22;
+		if (priv->cck_present_attenuation < 0)
+			priv->cck_present_attenuation = 0;
 		RT_TRACE(COMP_INIT,
 			 "20M, pHalData->CCKPresentAttentuation = %d\n",
-			 priv->cck_present_attentuation);
+			 priv->cck_present_attenuation);
 
 		if (priv->chan == 14 && !priv->bcck_in_ch14) {
 			priv->bcck_in_ch14 = true;
@@ -1590,18 +1590,18 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);
 		rtl8192_setBBreg(dev, rOFDM1_LSTF, 0xC00,
 				 priv->nCur40MhzPrimeSC);
-		priv->cck_present_attentuation =
-			priv->cck_present_attentuation_40Mdefault +
-			priv->cck_present_attentuation_difference;
+		priv->cck_present_attenuation =
+			priv->cck_present_attenuation_40Mdefault +
+			priv->cck_present_attenuation_difference;
 
-		if (priv->cck_present_attentuation > 22)
-			priv->cck_present_attentuation = 22;
-		if (priv->cck_present_attentuation < 0)
-			priv->cck_present_attentuation = 0;
+		if (priv->cck_present_attenuation > 22)
+			priv->cck_present_attenuation = 22;
+		if (priv->cck_present_attenuation < 0)
+			priv->cck_present_attenuation = 0;
 
 		RT_TRACE(COMP_INIT,
 			 "40M, pHalData->CCKPresentAttentuation = %d\n",
-			 priv->cck_present_attentuation);
+			 priv->cck_present_attenuation);
 		if (priv->chan == 14 && !priv->bcck_in_ch14) {
 			priv->bcck_in_ch14 = true;
 			dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);

commit 991397d1c19d6bf7eb69e7442b97d8c49412117f
Author: Derek Robson <robsonde@gmail.com>
Date:   Sat Feb 11 22:52:40 2017 +1300

    Staging: rtl8192u: r819xU_phy.c - style fix
    
    Fixed style of block comments
    Found using checkpatch
    
    Signed-off-by: Derek Robson <robsonde@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 696df3440077..c99130fdb8ee 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -367,7 +367,8 @@ static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	/* Firmware RF Write control.
 	 * We can not execute the scheme in the initial step.
 	 * Otherwise, RF-R/W will waste much time.
-	 * This is only for site survey. */
+	 * This is only for site survey.
+	 */
 	/* 1. Read operation need not insert data. bit 0-11 */
 	/* 2. Write RF register address. bit 12-19 */
 	data |= ((offset&0xFF)<<12);
@@ -380,7 +381,8 @@ static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	read_nic_dword(dev, QPNR, &tmp);
 	while (tmp & 0x80000000) {
 		/* If FW can not finish RF-R/W for more than ?? times.
-		   We must reset FW. */
+		 * We must reset FW.
+		 */
 		if (time++ < 100) {
 			udelay(10);
 			read_nic_dword(dev, QPNR, &tmp);
@@ -394,7 +396,8 @@ static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	read_nic_dword(dev, QPNR, &tmp);
 	while (tmp & 0x80000000) {
 		/* If FW can not finish RF-R/W for more than ?? times.
-		   We must reset FW. */
+		 * We must reset FW.
+		 */
 		if (time++ < 100) {
 			udelay(10);
 			read_nic_dword(dev, QPNR, &tmp);
@@ -426,7 +429,8 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
 	/* Firmware RF Write control.
 	 * We can not execute the scheme in the initial step.
 	 * Otherwise, RF-R/W will waste much time.
-	 * This is only for site survey. */
+	 * This is only for site survey.
+	 */
 
 	/* 1. Set driver write bit and 12 bit data. bit 0-11 */
 	/* 2. Write RF register address. bit 12-19 */
@@ -442,7 +446,8 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
 	read_nic_dword(dev, QPNR, &tmp);
 	while (tmp & 0x80000000) {
 		/* If FW can not finish RF-R/W for more than ?? times.
-		   We must reset FW. */
+		 * We must reset FW.
+		 */
 		if (time++ < 100) {
 			udelay(10);
 			read_nic_dword(dev, QPNR, &tmp);
@@ -451,10 +456,12 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
 		}
 	}
 	/* 7. No matter check bit. We always force the write.
-	   Because FW will not accept the command. */
+	 * Because FW will not accept the command.
+	 */
 	write_nic_dword(dev, QPNR, data);
 	/* According to test, we must delay 20us to wait firmware
-	   to finish RF write operation. */
+	 * to finish RF write operation.
+	 */
 	/* We support delay in firmware side now. */
 }
 
@@ -723,7 +730,8 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 					     WriteAddr[HW90_BLOCK_RF],
 					     bMask12Bits, WriteData[i]);
 			/* TODO: we should not delay for such a long time.
-			   Ask SD3 */
+			 * Ask SD3
+			 */
 			usleep_range(1000, 1000);
 			reg = rtl8192_phy_QueryRFReg(dev, eRFPath,
 						     WriteAddr[HW90_BLOCK_RF],
@@ -820,7 +828,8 @@ static void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	}
 
 	/* Check if the CCK HighPower is turned ON.
-	   This is used to calculate PWDB. */
+	 * This is used to calculate PWDB.
+	 */
 	priv->bCckHighPower = (u8)rtl8192_QueryBBReg(dev,
 						     rFPGA0_XA_HSSIParameter2,
 						     0x200);
@@ -839,7 +848,8 @@ void rtl8192_BBConfig(struct net_device *dev)
 	rtl8192_InitBBRFRegDef(dev);
 	/* config BB&RF. As hardCode based initialization has not been well
 	 * implemented, so use file first.
-	 * FIXME: should implement it for hardcode? */
+	 * FIXME: should implement it for hardcode?
+	 */
 	rtl8192_BB_Config_ParaFile(dev);
 }
 
@@ -1158,7 +1168,8 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 			switch (pHalData->eRFPowerState) {
 			case eRfOff:
 				/* If Rf off reason is from IPS,
-				   LED should blink with no link */
+				 * LED should blink with no link
+				 */
 				if (pMgntInfo->RfOffReason == RF_CHANGE_BY_IPS)
 					Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);
 				else
@@ -1168,7 +1179,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 
 			case eRfOn:
 				/* Turn on RF we are still linked, which might
-				   happen when we quickly turn off and on HW RF.
+				 * happen when we quickly turn off and on HW RF.
 				 */
 				if (pMgntInfo->bMediaConnect)
 					Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_LINK);
@@ -1263,7 +1274,8 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 	if (!IsLegalChannel(priv->ieee80211, channel)) {
 		RT_TRACE(COMP_ERR, "set to illegal channel: %d\n", channel);
 		/* return true to tell upper caller function this channel
-		   setting is finished! Or it will in while loop. */
+		 * setting is finished! Or it will in while loop.
+		 */
 		return true;
 	}
 	/* FIXME: need to check whether channel is legal or not here */
@@ -1609,7 +1621,8 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 
 	}
 	/* Skip over setting of J-mode in BB register here.
-	   Default value is "None J mode". */
+	 * Default value is "None J mode".
+	 */
 
 	/* <3> Set RF related register */
 	switch (priv->rf_chip) {

commit a5959f3f12488e8ef732717d2d887f2c03ac81af
Author: Geliang Tang <geliangtang@163.com>
Date:   Mon Dec 28 23:43:38 2015 +0800

    staging: rtl8192u: use to_delayed_work
    
    Use to_delayed_work() instead of open-coding it.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index f264d88364a1..696df3440077 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1683,8 +1683,7 @@ void InitialGain819xUsb(struct net_device *dev,	u8 Operation)
 
 void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 {
-	struct delayed_work *dwork = container_of(work, struct delayed_work,
-						  work);
+	struct delayed_work *dwork = to_delayed_work(work);
 	struct r8192_priv *priv = container_of(dwork, struct r8192_priv,
 					       initialgain_operate_wq);
 	struct net_device *dev = priv->ieee80211->dev;

commit d2071984b917784f74ab32c4f054e3503bc730e5
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Sat Oct 31 20:25:29 2015 +0530

    staging: rtl8192u: Remove unnecessary function
    
    This patch solves two problems.
    The function rtl8192_CalculateBitShift() had an unnecessary variable i
    that could be removed by using a single line of code.
    
    After this change, rtl8192_CalculateBitShift() becomes a wrapper
    function, so the rtl8192_CalculateBitShift() function has been removed
    completely to replace it with a single line of code.
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 70656441c145..f264d88364a1 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -37,21 +37,6 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 #define rtl819XRadioD_Array Rtl8192UsbRadioD_Array
 #define rtl819XAGCTAB_Array Rtl8192UsbAGCTAB_Array
 
-/******************************************************************************
- * function: This function reads BB parameters from header file we generate,
- *           and does register read/write
- * input:    u32	bitmask  //taget bit pos in the addr to be modified
- * output:   none
- * return:   u32	return the shift bit position of the mask
- ******************************************************************************/
-static u32 rtl8192_CalculateBitShift(u32 bitmask)
-{
-	u32 i;
-
-	i = ffs(bitmask) - 1;
-	return i;
-}
-
 /******************************************************************************
  * function:  This function checks different RF type to execute legal judgement.
  *            If RF Path is illegal, we will return false.
@@ -94,7 +79,7 @@ void rtl8192_setBBreg(struct net_device *dev, u32 reg_addr, u32 bitmask,
 
 	if (bitmask != bMaskDWord) {
 		read_nic_dword(dev, reg_addr, &reg);
-		bitshift = rtl8192_CalculateBitShift(bitmask);
+		bitshift = ffs(bitmask) - 1;
 		reg &= ~bitmask;
 		reg |= data << bitshift;
 		write_nic_dword(dev, reg_addr, reg);
@@ -117,7 +102,7 @@ u32 rtl8192_QueryBBReg(struct net_device *dev, u32 reg_addr, u32 bitmask)
 	u32 reg, bitshift;
 
 	read_nic_dword(dev, reg_addr, &reg);
-	bitshift = rtl8192_CalculateBitShift(bitmask);
+	bitshift = ffs(bitmask) - 1;
 
 	return (reg & bitmask) >> bitshift;
 }
@@ -306,7 +291,7 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 		if (bitmask != bMask12Bits) {
 			/* RF data is 12 bits only */
 			reg = phy_FwRFSerialRead(dev, eRFPath, reg_addr);
-			bitshift =  rtl8192_CalculateBitShift(bitmask);
+			bitshift =  ffs(bitmask) - 1;
 			reg &= ~bitmask;
 			reg |= data << bitshift;
 
@@ -321,7 +306,7 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 		if (bitmask != bMask12Bits) {
 			/* RF data is 12 bits only */
 			reg = rtl8192_phy_RFSerialRead(dev, eRFPath, reg_addr);
-			bitshift =  rtl8192_CalculateBitShift(bitmask);
+			bitshift =  ffs(bitmask) - 1;
 			reg &= ~bitmask;
 			reg |= data << bitshift;
 
@@ -356,7 +341,7 @@ u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	} else {
 		reg = rtl8192_phy_RFSerialRead(dev, eRFPath, reg_addr);
 	}
-	bitshift =  rtl8192_CalculateBitShift(bitmask);
+	bitshift =  ffs(bitmask) - 1;
 	reg = (reg & bitmask) >> bitshift;
 	return reg;
 

commit 56b3152e5e8b0501ff9ef100b772df8ecb3efd82
Author: Anish Bhatt <anish@gatech.edu>
Date:   Mon Oct 12 21:02:36 2015 -0700

    rtl8192u: BIT() macro cleanup
    
    Use the BIT(x) macro directly instead using multiple
    BITX defines.
    
    Signed-off-by: Anish Bhatt <anish@gatech.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index e5dbaca9e518..70656441c145 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1110,7 +1110,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 		case eRfOn:
 			/* RF-A, RF-B */
 			/* enable RF-Chip A/B - 0x860[4] */
-			rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4,
+			rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT(4),
 					 0x1);
 			/* analog to digital on - 0x88c[9:8] */
 			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300,
@@ -1135,7 +1135,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 		case eRfOff:
 			/* RF-A, RF-B */
 			/* disable RF-Chip A/B - 0x860[4] */
-			rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4,
+			rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT(4),
 					 0x0);
 			/* analog to digital off, for power save */
 			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00,

commit d5133e75171d6b503b2491b882e00365515c6a81
Author: Hatice ERTRK <haticeerturk27@gmail.com>
Date:   Thu Mar 19 22:32:30 2015 +0200

    Staging: rtl8192u: Remove unnecessary spaces
    
    Fix checkpatch.pl issues with "unnecessary whitespace before a quoted
    newline" in r819xU_phy.c
    
    Signed-off-by: Hatice ERTURK <haticeerturk27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index a64c9fcfc46d..e5dbaca9e518 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -898,7 +898,7 @@ void rtl8192_phy_getTxPower(struct net_device *dev)
 	read_nic_byte(dev, rOFDM0_RxDetector3, &priv->framesync);
 	read_nic_byte(dev, rOFDM0_RxDetector2, &tmp);
 	priv->framesyncC34 = tmp;
-	RT_TRACE(COMP_INIT, "Default framesync (0x%x) = 0x%x \n",
+	RT_TRACE(COMP_INIT, "Default framesync (0x%x) = 0x%x\n",
 		rOFDM0_RxDetector3, priv->framesync);
 
 	/* Read SIFS (save the value read fome MACPHY_REG.txt) */
@@ -1742,13 +1742,13 @@ void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 		RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xa0a is %x\n",
 			 priv->initgain_backup.cca);
 
-		RT_TRACE(COMP_SCAN, "Write scan initial gain = 0x%x \n",
+		RT_TRACE(COMP_SCAN, "Write scan initial gain = 0x%x\n",
 			 initial_gain);
 		write_nic_byte(dev, rOFDM0_XAAGCCore1, initial_gain);
 		write_nic_byte(dev, rOFDM0_XBAGCCore1, initial_gain);
 		write_nic_byte(dev, rOFDM0_XCAGCCore1, initial_gain);
 		write_nic_byte(dev, rOFDM0_XDAGCCore1, initial_gain);
-		RT_TRACE(COMP_SCAN, "Write scan 0xa0a = 0x%x \n",
+		RT_TRACE(COMP_SCAN, "Write scan 0xa0a = 0x%x\n",
 			 POWER_DETECTION_TH);
 		write_nic_byte(dev, 0xa0a, POWER_DETECTION_TH);
 		break;
@@ -1789,7 +1789,7 @@ void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 			rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);
 		break;
 	default:
-		RT_TRACE(COMP_SCAN, "Unknown IG Operation. \n");
+		RT_TRACE(COMP_SCAN, "Unknown IG Operation.\n");
 		break;
 	}
 }

commit 2060f31ae58ea5510c432fed8a32bdef33ac4cd7
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Fri Mar 13 20:50:52 2015 +0300

    Staging: rtl8192u: Remove parentheses around right side an assignment
    
    Parentheses are not needed around the right hand side of an assignment.
    This patch remove parenthese of such occurenses. Issue was detected and
    solved using the following coccinelle script:
    
    @rule1@
    identifier x, y, z;
    expression E1, E2;
    @@
    
    (
    x = (y == z);
    |
    x = (E1 == E2);
    |
     x =
    -(
    ...
    -)
     ;
    )
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 3451ec75756c..a64c9fcfc46d 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -823,8 +823,8 @@ static void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	write_nic_byte_E(dev, 0x5e, 0x00);
 	if (priv->card_8192_version == (u8)VERSION_819xU_A) {
 		/* Antenna gain offset from B/C/D to A */
-		reg_u32 = (priv->AntennaTxPwDiff[1]<<4 |
-			   priv->AntennaTxPwDiff[0]);
+		reg_u32 = priv->AntennaTxPwDiff[1]<<4 |
+			   priv->AntennaTxPwDiff[0];
 		rtl8192_setBBreg(dev, rFPGA0_TxGainStage, (bXBTxAGC|bXCTxAGC),
 				 reg_u32);
 

commit a0886f7303310525f032debdff85877356c9a7ab
Author: Cristina Opriceana <cristina.opriceana@gmail.com>
Date:   Fri Mar 13 21:21:31 2015 +0200

    Staging: rtl8192u: Bool tests don't need comparisons
    
    This patch removes explicit true/false comparations to bool variables.
    Warning found by coccinelle:
    "WARNING: Comparison to bool"
    
    Signed-off-by: Cristina Opriceana <cristina.opriceana@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 084e04fd15f8..3451ec75756c 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1099,7 +1099,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 	if (eRFPowerState == priv->ieee80211->eRFPowerState)
 		return false;
 
-	if (priv->SetRFPowerStateInProgress == true)
+	if (priv->SetRFPowerStateInProgress)
 		return false;
 
 	priv->SetRFPowerStateInProgress = true;

commit 4b2faf80228a9e5c9b6df0315dd3e021293717db
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Sat Feb 28 00:14:34 2015 +0100

    Staging: rtl8192u: Replace TRUE and FALSE macros
    
    Replace all occurrences of TRUE and FALSE by true and false
    respectively.
    
    Signed-off-by: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 3d4f57d97d51..084e04fd15f8 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1575,10 +1575,10 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			 priv->cck_present_attentuation);
 
 		if (priv->chan == 14 && !priv->bcck_in_ch14) {
-			priv->bcck_in_ch14 = TRUE;
+			priv->bcck_in_ch14 = true;
 			dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
 		} else if (priv->chan != 14 && priv->bcck_in_ch14) {
-			priv->bcck_in_ch14 = FALSE;
+			priv->bcck_in_ch14 = false;
 			dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
 		} else {
 			dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);

commit 6a3718cfd0f6608362f5aaea37f896ff629d0f43
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Thu Feb 26 23:04:42 2015 +0100

    Staging: rtl8192u: Remove break statement
    
    This patch fixes the checkpatch.pl warning:
    WARNING: "break is not useful after a goto or return"
    
    Signed-off-by: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index c8dc648a59ee..3d4f57d97d51 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1342,7 +1342,6 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 	default:
 		RT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);
 		return true;
-		break;
 	}
 
 

commit d0049dfc88d18657da302023782473b615f3fcf4
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Fri Feb 20 18:14:30 2015 +0100

    Staging: rtl8192: Simplifying if-else statement
    
    This patch simplifies the code by not having two identical paths and
    fixes the warning given by checkpatch.pl: "else is not useful after
    a break or return".
    
    Signed-off-by: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 3b2c954ff292..c8dc648a59ee 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -352,16 +352,14 @@ u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 		return 0;
 	if (priv->Rf_Mode == RF_OP_By_FW) {
 		reg = phy_FwRFSerialRead(dev, eRFPath, reg_addr);
-		bitshift =  rtl8192_CalculateBitShift(bitmask);
-		reg = (reg & bitmask) >> bitshift;
 		udelay(200);
-		return reg;
 	} else {
 		reg = rtl8192_phy_RFSerialRead(dev, eRFPath, reg_addr);
-		bitshift =  rtl8192_CalculateBitShift(bitmask);
-		reg = (reg & bitmask) >> bitshift;
-		return reg;
 	}
+	bitshift =  rtl8192_CalculateBitShift(bitmask);
+	reg = (reg & bitmask) >> bitshift;
+	return reg;
+
 }
 
 /******************************************************************************

commit 352e579da8c9253b4cdf6d3135c6fe909a1b1f5e
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Tue Feb 24 22:21:12 2015 +0100

    Staging: rtl8192u: Simplify if condition
    
    Remove unnecessary TRUE statement. Field bMediaConnect is of bool
    type, so such change is correct.
    
    Signed-off-by: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 84a8a9a78a46..3b2c954ff292 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1187,7 +1187,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 				/* Turn on RF we are still linked, which might
 				   happen when we quickly turn off and on HW RF.
 				 */
-				if (pMgntInfo->bMediaConnect == TRUE)
+				if (pMgntInfo->bMediaConnect)
 					Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_LINK);
 				else
 					/* Turn off LED if RF is not ON. */

commit bf1c66e8158d36daf1598b9350a10b7a235252fa
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Fri Feb 20 22:54:27 2015 +0100

    Staging: rtl8192u: Remove else after return
    
    This patch simplifies the code by removing else and fixes
    the following checkpatch.pl warning: "else is not useful after
    break or return".
    
    Signed-off-by: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index dbd3321c6d4a..84a8a9a78a46 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1365,11 +1365,10 @@ static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
 			if ((*stage) == 2) {
 				(*delay) = CurrentCmd->msDelay;
 				return true;
-			} else {
-				(*stage)++;
-				(*step) = 0;
-				continue;
 			}
+			(*stage)++;
+			(*step) = 0;
+			continue;
 		}
 
 		switch (CurrentCmd->CmdID) {

commit 98bedd77dc99a1eb835ab527ce5c74b09a0f4d88
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Thu Feb 19 23:05:20 2015 +0100

    Staging: rtl8192u: Remove space before tab
    
    This patch fixes the checkpatch.pl warning:
    WARNING: "please, no space before tabs"
    
    Signed-off-by: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 058960251bac..dbd3321c6d4a 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -106,10 +106,10 @@ void rtl8192_setBBreg(struct net_device *dev, u32 reg_addr, u32 bitmask,
 /******************************************************************************
  * function:  This function reads specific bits from BB register
  * input:     net_device	*dev
- *            u32	 	reg_addr   //target addr to be readback
- *            u32	 	bitmask    //taget bit pos to be readback
+ *            u32		reg_addr   //target addr to be readback
+ *            u32		bitmask    //taget bit pos to be readback
  * output:    none
- * return:    u32	 	data       //the readback register value
+ * return:    u32		data       //the readback register value
  * notice:
  ******************************************************************************/
 u32 rtl8192_QueryBBReg(struct net_device *dev, u32 reg_addr, u32 bitmask)
@@ -478,7 +478,7 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
 /******************************************************************************
  * function:  This function reads BB parameters from header file we generate,
  *            and do register read/write
- * input:     net_device 	*dev
+ * input:     net_device	*dev
  * output:    none
  * return:    none
  * notice:    BB parameters may change all the time, so please make

commit 657eb9798aed8f62685e97ea0cd6dc6df6b9f458
Author: Melike Yurtoglu <aysemelikeyurtoglu@gmail.com>
Date:   Tue Oct 7 00:05:45 2014 +0300

    staging: rtl8192u: Missing a blank line after declarations.
    
    Missing a blank line after declarations" checkpatch.pl warning in
    r819xU_phy.c
    
    Signed-off-by: Melike Yurtoglu <aysemelikeyurtoglu@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index e9c15fe8ded5..058960251bac 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1463,6 +1463,7 @@ void rtl8192_SwChnl_WorkItem(struct net_device *dev)
 u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
+
 	RT_TRACE(COMP_CH, "%s(), SwChnlInProgress: %d\n", __func__,
 		 priv->SwChnlInProgress);
 	if (!priv->up)

commit 16ec1a20b1dc7cbe484f271589be4ecb2632cde4
Author: sanjeev sharma <sanjeev_sharma@mentor.com>
Date:   Thu Jul 10 17:54:56 2014 +0530

    staging: rtl8192u: Fixed switch and case indentation error
    
    This patch will fix switch and case indentation Error
    reported by checkpatch script.
    
    Signed-off-by: Sanjeev Sharma <Sanjeev_Sharma@mentor.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 0bcdd4e24bbd..e9c15fe8ded5 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -946,12 +946,12 @@ void rtl8192_phy_RFConfig(struct net_device *dev)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
 	switch (priv->rf_chip) {
-		case RF_8256:
-			PHY_RF8256_Config(dev);
-			break;
-		default:
-			RT_TRACE(COMP_ERR, "error chip id\n");
-			break;
+	case RF_8256:
+		PHY_RF8256_Config(dev);
+		break;
+	default:
+		RT_TRACE(COMP_ERR, "error chip id\n");
+		break;
 	}
 }
 

commit 97f9402a3ee2f50ba65cbf40ee7c20dbb1709b43
Author: sanjeev sharma <sanjeev_sharma@mentor.com>
Date:   Thu Jul 10 17:54:54 2014 +0530

    staging: rtl8192u: Remove useless return statement
    
    This patch will remove unneeded return statements in
    code.
    
    Signed-off-by: Sanjeev Sharma <Sanjeev_Sharma@mentor.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 02554c981203..0bcdd4e24bbd 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -101,7 +101,6 @@ void rtl8192_setBBreg(struct net_device *dev, u32 reg_addr, u32 bitmask,
 	} else {
 		write_nic_dword(dev, reg_addr, data);
 	}
-	return;
 }
 
 /******************************************************************************
@@ -281,7 +280,6 @@ static void rtl8192_phy_RFSerialWrite(struct net_device *dev,
 					 priv->RfReg0Value[eRFPath] << 16);
 		}
 	}
-	return;
 }
 
 /******************************************************************************
@@ -332,7 +330,6 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 			rtl8192_phy_RFSerialWrite(dev, eRFPath, reg_addr, data);
 		}
 	}
-	return;
 }
 
 /******************************************************************************
@@ -513,7 +510,6 @@ void rtl8192_phy_configmac(struct net_device *dev)
 		rtl8192_setBBreg(dev, pdwArray[i], pdwArray[i+1],
 				 pdwArray[i+2]);
 	}
-	return;
 }
 
 /******************************************************************************
@@ -559,7 +555,6 @@ void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 				 rtl819XAGCTAB_Array[i+1]);
 		}
 	}
-	return;
 }
 
 /******************************************************************************
@@ -846,7 +841,6 @@ static void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	priv->bCckHighPower = (u8)rtl8192_QueryBBReg(dev,
 						     rFPGA0_XA_HSSIParameter2,
 						     0x200);
-	return;
 }
 
 /******************************************************************************
@@ -864,7 +858,6 @@ void rtl8192_BBConfig(struct net_device *dev)
 	 * implemented, so use file first.
 	 * FIXME: should implement it for hardcode? */
 	rtl8192_BB_Config_ParaFile(dev);
-	return;
 }
 
 
@@ -912,8 +905,6 @@ void rtl8192_phy_getTxPower(struct net_device *dev)
 
 	/* Read SIFS (save the value read fome MACPHY_REG.txt) */
 	read_nic_word(dev, SIFS, &priv->SifsTime);
-
-	return;
 }
 
 /******************************************************************************
@@ -942,7 +933,6 @@ void rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)
 			 __func__);
 		break;
 	}
-	return;
 }
 
 /******************************************************************************
@@ -963,7 +953,6 @@ void rtl8192_phy_RFConfig(struct net_device *dev)
 			RT_TRACE(COMP_ERR, "error chip id\n");
 			break;
 	}
-	return;
 }
 
 /******************************************************************************
@@ -974,7 +963,6 @@ void rtl8192_phy_RFConfig(struct net_device *dev)
  ******************************************************************************/
 void rtl8192_phy_updateInitGain(struct net_device *dev)
 {
-	return;
 }
 
 /******************************************************************************
@@ -1094,7 +1082,6 @@ static void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
 		RT_TRACE(COMP_ERR, "unknown rf chip ID in %s()\n", __func__);
 		break;
 	}
-	return;
 }
 
 /******************************************************************************

commit 4764ca981b040048766e4f39a45a4b9c5cecff9c
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Mon May 26 16:08:50 2014 +0200

    drivers/staging: Remove useless return variables
    
    This patch remove variables that are initialized with a constant,
    are never updated, and are only used as parameter of return.
    Return the constant instead of using a variable.
    
    Verified by compilation only.
    
    The coccinelle script that find and fixes this issue is:
    // <smpl>
    @@
    type T;
    constant C;
    identifier ret;
    @@
    - T ret = C;
    ... when != ret
        when strict
    return
    - ret
    + C
    ;
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 87e07ba49ecd..02554c981203 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -991,7 +991,6 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 {
 
 	int i;
-	u8 ret = 0;
 
 	switch (eRFPath) {
 	case RF90_PATH_A:
@@ -1058,7 +1057,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		break;
 	}
 
-	return ret;
+	return 0;
 
 }
 

commit 2930d0b977e6b9f66e8f090c685a18991944fca6
Author: Rui Miguel Silva <rmfrfs@gmail.com>
Date:   Mon Apr 28 12:12:54 2014 +0100

    staging: rtl8192u: fix checkpatch braces warning
    
    fix some code style related to the use of braces in a one statement block
    
    Signed-off-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index b9f35313c7ab..87e07ba49ecd 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -504,9 +504,8 @@ void rtl8192_phy_configmac(struct net_device *dev)
 		pdwArray = rtl819XMACPHY_Array;
 	}
 	for (i = 0; i < dwArrayLen; i = i+3) {
-		if (pdwArray[i] == 0x318) {
+		if (pdwArray[i] == 0x318)
 			pdwArray[i+2] = 0x00000800;
-		}
 
 		RT_TRACE(COMP_DBG,
 			 "Rtl8190MACPHY_Array[0]=%x Rtl8190MACPHY_Array[1]=%x Rtl8190MACPHY_Array[2]=%x\n",

commit c92f473dad573ad88d86d1d17a612be4ac4d8f54
Author: Ana Rey <anarey@gmail.com>
Date:   Fri Mar 14 18:59:58 2014 +0100

    staging: rtl8192u: make in r819xU_phy.c some local functions static
    
    Make some local functions static and fix coding style in these function
    declarations when It is necessary
    
    These are the local functions that were made static:
    rtl8192_CalculateBitShift, rtl8192_phy_RFSerialRead,
    rtl8192_phy_RFSerialWrite, rtl8192_InitBBRFRegDef,
    rtl8192_BB_Config_ParaFile,rtl8192_SetTxPowerLevel,
    rtl8192_phy_SetSwChnlCmdArray, rtl8192_phy_SwChnlStepByStep,
    rtl8192_phy_FinishSwChnlNow
    
    Fixed the following sparse warnings in r819xU_phy.c
    
    drivers/staging/rtl8192u/r819xU_phy.c:47:5: warning: symbol 'rtl8192_CalculateBitShift' was not declared. Should it be static?
    drivers/staging/rtl8192u/r819xU_phy.c:147:5: warning: symbol 'rtl8192_phy_RFSerialRead' was not declared. Should it be static?
    drivers/staging/rtl8192u/r819xU_phy.c:232:6: warning: symbol 'rtl8192_phy_RFSerialWrite' was not declared. Should it be static?
    drivers/staging/rtl8192u/r819xU_phy.c:574:6: warning: symbol 'rtl8192_InitBBRFRegDef' was not declared. Should it be static?
    drivers/staging/rtl8192u/r819xU_phy.c:783:6: warning: symbol 'rtl8192_BB_Config_ParaFile' was not declared. Should it be static?
    drivers/staging/rtl8192u/r819xU_phy.c:1073:6: warning: symbol 'rtl8192_SetTxPowerLevel' was not declared. Should it be static?
    drivers/staging/rtl8192u/r819xU_phy.c:1242:4: warning: symbol 'rtl8192_phy_SetSwChnlCmdArray' was not declared. Should it be static?
    drivers/staging/rtl8192u/r819xU_phy.c:1279:4: warning: symbol 'rtl8192_phy_SwChnlStepByStep' was not declared. Should it be static?
    drivers/staging/rtl8192u/r819xU_phy.c:1436:6: warning: symbol 'rtl8192_phy_FinishSwChnlNow' was not declared. Should it be static?
    
    Signed-off-by: Ana Rey <anarey@gmail.com>
    Signed-off-by: Peter P Waskiewicz Jr <peter.p.waskiewicz.jr@intel.com>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 39cd426bc5e5..b9f35313c7ab 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -44,7 +44,7 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
  * output:   none
  * return:   u32	return the shift bit position of the mask
  ******************************************************************************/
-u32 rtl8192_CalculateBitShift(u32 bitmask)
+static u32 rtl8192_CalculateBitShift(u32 bitmask)
 {
 	u32 i;
 
@@ -144,8 +144,8 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
  *            Driver here need to implement (1) and (2)
  *            ---need more spec for this information.
  ******************************************************************************/
-u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
-			     u32 offset)
+static u32 rtl8192_phy_RFSerialRead(struct net_device *dev,
+				    RF90_RADIO_PATH_E eRFPath, u32 offset)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 ret = 0;
@@ -229,8 +229,9 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
  * Reg_Mode2	1		1			Reg 31 ~ 45(0x1 ~ 0xf)
  * ---------------------------------------------------------------------------
  *****************************************************************************/
-void rtl8192_phy_RFSerialWrite(struct net_device *dev,
-			       RF90_RADIO_PATH_E eRFPath, u32 offset, u32 data)
+static void rtl8192_phy_RFSerialWrite(struct net_device *dev,
+				      RF90_RADIO_PATH_E eRFPath, u32 offset,
+				      u32 data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 DataAndAddr = 0, new_offset = 0;
@@ -571,7 +572,7 @@ void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
  * notice:    Initialization value here is constant and it should never
  *            be changed
  *****************************************************************************/
-void rtl8192_InitBBRFRegDef(struct net_device *dev)
+static void rtl8192_InitBBRFRegDef(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
@@ -780,7 +781,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
  * notice:    Initialization value may change all the time, so please make
  *            sure it has been synced with the newest.
  ******************************************************************************/
-void rtl8192_BB_Config_ParaFile(struct net_device *dev)
+static void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8 reg_u8 = 0, eCheckItem = 0, status = 0;
@@ -1070,7 +1071,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
  * return:    none
  * notice:
  ******************************************************************************/
-void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
+static void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8	powerlevel = priv->TxPowerLevelCCK[channel-1];
@@ -1239,9 +1240,9 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
  * return:    true if finished, false otherwise
  * notice:
  ******************************************************************************/
-u8 rtl8192_phy_SetSwChnlCmdArray(SwChnlCmd *CmdTable, u32 CmdTableIdx,
-				 u32 CmdTableSz, SwChnlCmdID CmdID, u32 Para1,
-				 u32 Para2, u32 msDelay)
+static u8 rtl8192_phy_SetSwChnlCmdArray(SwChnlCmd *CmdTable, u32 CmdTableIdx,
+					u32 CmdTableSz, SwChnlCmdID CmdID,
+					u32 Para1, u32 Para2, u32 msDelay)
 {
 	SwChnlCmd *pCmd;
 
@@ -1276,8 +1277,8 @@ u8 rtl8192_phy_SetSwChnlCmdArray(SwChnlCmd *CmdTable, u32 CmdTableIdx,
  * return:    true if finished, false otherwise
  * notice:    Wait for simpler function to replace it
  *****************************************************************************/
-u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
-				u8 *step, u32 *delay)
+static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,
+				       u8 *stage, u8 *step, u32 *delay)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	SwChnlCmd	PreCommonCmd[MAX_PRECMD_CNT];
@@ -1433,7 +1434,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
  * return:    none
  * notice:    We should not call this function directly
  *****************************************************************************/
-void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
+static void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32	delay = 0;

commit a115ee4175c3eb33f75d5ca62d417e853702c0f3
Author: Teodora Baluta <teobaluta@gmail.com>
Date:   Wed Oct 16 23:53:32 2013 +0300

    Staging: rtl8192u: fix functions that should not be declared extern
    
    These functions are already marked extern in the header file
    
    drivers/staging/rtl8192u/r819xU_phy.c:1716:13: warning: function 'InitialGainOperateWorkItemCallBack' with external linkage has definition
    drivers/staging/rtl8192u/r819xU_cmdpkt.c:497:12: warning: function 'cmpk_message_handle_rx' with external linkage has definition
    
    Signed-off-by: Teodora Baluta <teobaluta@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 17ac1202c906..39cd426bc5e5 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1713,7 +1713,7 @@ void InitialGain819xUsb(struct net_device *dev,	u8 Operation)
 		queue_delayed_work(priv->priv_wq, &priv->initialgain_operate_wq, 0);
 }
 
-extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
+void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work, struct delayed_work,
 						  work);

commit ea1751438abdaede89c159df095a24480f9e2142
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sat Sep 21 23:42:30 2013 +0300

    staging: rtl8192u: remove code inside #ifdef RTL8190P/RTL8192E in r819xU_phy.c
    
    This patch removes the unused code inside #ifdef RTL8190P and #ifdef RTL8192E
    guards since RTL8190P and RTL8192E are not defined.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index a6fac081e42c..17ac1202c906 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1799,12 +1799,6 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 		RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xa0a is %x\n",
 			 priv->initgain_backup.cca);
 
-#ifdef RTL8190P
-		SetTxPowerLevel8190(Adapter, priv->CurrentChannel);
-#endif
-#ifdef RTL8192E
-		SetTxPowerLevel8190(Adapter, priv->CurrentChannel);
-#endif
 		rtl8192_phy_setTxPower(dev, priv->ieee80211->current_network.channel);
 
 		if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)

commit 0081fcc646d1fc1c24734dbd68923a21261d3c8d
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Tue Jun 25 02:28:57 2013 +0300

    staging: rtl8192u: fix newlines in r819xU_phy.c
    
    This patch fixes the newlines by:
    - adding a newline after variables declarations.
    - removing the newlines following the return statement.
    - removing the newlines between function header comments
      and function definitions.
    - adding one newline between function definitions.
    - adding a newline at the end of RT_TRACE messages.
    
    This was done to improve code's and logmessages'
    readability.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 92f0f90150e9..a6fac081e42c 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -47,9 +47,11 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 u32 rtl8192_CalculateBitShift(u32 bitmask)
 {
 	u32 i;
+
 	i = ffs(bitmask) - 1;
 	return i;
 }
+
 /******************************************************************************
  * function:  This function checks different RF type to execute legal judgement.
  *            If RF Path is illegal, we will return false.
@@ -62,6 +64,7 @@ u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 eRFPath)
 {
 	u8 ret = 1;
 	struct r8192_priv *priv = ieee80211_priv(dev);
+
 	if (priv->rf_type == RF_2T4R) {
 		ret = 0;
 	} else if (priv->rf_type == RF_1T2R) {
@@ -72,6 +75,7 @@ u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 eRFPath)
 	}
 	return ret;
 }
+
 /******************************************************************************
  * function:  This function sets specific bits to BB register
  * input:     net_device *dev
@@ -99,6 +103,7 @@ void rtl8192_setBBreg(struct net_device *dev, u32 reg_addr, u32 bitmask,
 	}
 	return;
 }
+
 /******************************************************************************
  * function:  This function reads specific bits from BB register
  * input:     net_device	*dev
@@ -117,6 +122,7 @@ u32 rtl8192_QueryBBReg(struct net_device *dev, u32 reg_addr, u32 bitmask)
 
 	return (reg & bitmask) >> bitshift;
 }
+
 static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 			      u32 offset);
 
@@ -145,6 +151,7 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	u32 ret = 0;
 	u32 new_offset = 0;
 	BB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[eRFPath];
+
 	rtl8192_setBBreg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData, 0);
 	/* Make sure RF register offset is correct */
 	offset &= 0x3f;
@@ -200,7 +207,6 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	}
 
 	return ret;
-
 }
 
 /******************************************************************************
@@ -359,6 +365,7 @@ u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 		return reg;
 	}
 }
+
 /******************************************************************************
  * function:  We support firmware to execute RF-R/W.
  * input:     net_device        *dev
@@ -375,6 +382,7 @@ static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	u32		data = 0;
 	u8		time = 0;
 	u32		tmp;
+
 	/* Firmware RF Write control.
 	 * We can not execute the scheme in the initial step.
 	 * Otherwise, RF-R/W will waste much time.
@@ -416,7 +424,6 @@ static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	read_nic_dword(dev, RF_DATA, &reg);
 
 	return reg;
-
 }
 
 /******************************************************************************
@@ -468,10 +475,8 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
 	/* According to test, we must delay 20us to wait firmware
 	   to finish RF write operation. */
 	/* We support delay in firmware side now. */
-
 }
 
-
 /******************************************************************************
  * function:  This function reads BB parameters from header file we generate,
  *            and do register read/write
@@ -509,7 +514,6 @@ void rtl8192_phy_configmac(struct net_device *dev)
 				 pdwArray[i+2]);
 	}
 	return;
-
 }
 
 /******************************************************************************
@@ -521,13 +525,13 @@ void rtl8192_phy_configmac(struct net_device *dev)
  * notice:    BB parameters may change all the time, so please make
  *            sure it has been synced with the newest.
  *****************************************************************************/
-
 void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 {
 	u32 i;
 
 #ifdef TO_DO_LIST
 	u32 *rtl8192PhyRegArrayTable = NULL, *rtl8192AgcTabArrayTable = NULL;
+
 	if (Adapter->bInHctTest) {
 		PHY_REGArrayLen = PHY_REGArrayLengthDTM;
 		AGCTAB_ArrayLen = AGCTAB_ArrayLengthDTM;
@@ -556,9 +560,8 @@ void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 		}
 	}
 	return;
-
-
 }
+
 /******************************************************************************
  * function:  This function initializes Register definition offset for
  *            Radio Path A/B/C/D
@@ -571,6 +574,7 @@ void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 void rtl8192_InitBBRFRegDef(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
+
 	/* RF Interface Software Control */
 	/* 16 LSBs if read 32-bit from 0x870 */
 	priv->PHYRegDef[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW;
@@ -692,8 +696,8 @@ void rtl8192_InitBBRFRegDef(struct net_device *dev)
 	priv->PHYRegDef[RF90_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;
 	priv->PHYRegDef[RF90_PATH_C].rfLSSIReadBack = rFPGA0_XC_LSSIReadBack;
 	priv->PHYRegDef[RF90_PATH_D].rfLSSIReadBack = rFPGA0_XD_LSSIReadBack;
-
 }
+
 /******************************************************************************
  * function:  This function is to write register and then readback to make
  *            sure whether BB and RF is OK
@@ -712,6 +716,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 	u32 i, CheckTimes = 4, reg = 0;
 	u32 WriteAddr[4];
 	u32 WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};
+
 	/* Initialize register address offset to be checked */
 	WriteAddr[HW90_BLOCK_MAC] = 0x100;
 	WriteAddr[HW90_BLOCK_PHY0] = 0x900;
@@ -724,7 +729,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 		switch (CheckBlock) {
 		case HW90_BLOCK_MAC:
 			RT_TRACE(COMP_ERR,
-				 "PHY_CheckBBRFOK(): Never Write 0x100 here!");
+				 "PHY_CheckBBRFOK(): Never Write 0x100 here!\n");
 			break;
 
 		case HW90_BLOCK_PHY0:
@@ -767,7 +772,6 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 	return ret;
 }
 
-
 /******************************************************************************
  * function:  This function initializes BB&RF
  * input:     net_device	*dev
@@ -781,6 +785,7 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8 reg_u8 = 0, eCheckItem = 0, status = 0;
 	u32 reg_u32 = 0;
+
 	/**************************************
 	 * <1> Initialize BaseBand
 	 *************************************/
@@ -843,6 +848,7 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 						     0x200);
 	return;
 }
+
 /******************************************************************************
  * function:  This function initializes BB&RF
  * input:     net_device	*dev
@@ -861,6 +867,7 @@ void rtl8192_BBConfig(struct net_device *dev)
 	return;
 }
 
+
 /******************************************************************************
  * function:  This function obtains the initialization value of Tx power Level
  *            offset
@@ -872,6 +879,7 @@ void rtl8192_phy_getTxPower(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8 tmp;
+
 	read_nic_dword(dev, rTxAGC_Rate18_06,
 		       &priv->MCSTxPowerLevelOriginalOffset[0]);
 	read_nic_dword(dev, rTxAGC_Rate54_24,
@@ -1053,6 +1061,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 	return ret;
 
 }
+
 /******************************************************************************
  * function:  This function sets Tx Power of the channel
  * input:     net_device        *dev
@@ -1254,6 +1263,7 @@ u8 rtl8192_phy_SetSwChnlCmdArray(SwChnlCmd *CmdTable, u32 CmdTableIdx,
 
 	return true;
 }
+
 /******************************************************************************
  * function:  This function sets channel step by step
  * input:     net_device        *dev
@@ -1434,6 +1444,7 @@ void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
 			break;
 	}
 }
+
 /******************************************************************************
  * function:  Callback routine of the work item for switch channel.
  * input:     net_device	*dev
@@ -1478,20 +1489,20 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 	case WIRELESS_MODE_A:
 	case WIRELESS_MODE_N_5G:
 		if (channel <= 14) {
-			RT_TRACE(COMP_ERR, "WIRELESS_MODE_A but channel<=14");
+			RT_TRACE(COMP_ERR, "WIRELESS_MODE_A but channel<=14\n");
 			return false;
 		}
 		break;
 	case WIRELESS_MODE_B:
 		if (channel > 14) {
-			RT_TRACE(COMP_ERR, "WIRELESS_MODE_B but channel>14");
+			RT_TRACE(COMP_ERR, "WIRELESS_MODE_B but channel>14\n");
 			return false;
 		}
 		break;
 	case WIRELESS_MODE_G:
 	case WIRELESS_MODE_N_24G:
 		if (channel > 14) {
-			RT_TRACE(COMP_ERR, "WIRELESS_MODE_G but channel>14");
+			RT_TRACE(COMP_ERR, "WIRELESS_MODE_G but channel>14\n");
 			return false;
 		}
 		break;
@@ -1513,7 +1524,6 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 	return true;
 }
 
-
 /******************************************************************************
  * function:  Callback routine of the work item for set bandwidth mode.
  * input:     net_device	 *dev
@@ -1657,7 +1667,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	}
 	priv->SetBWModeInProgress = false;
 
-	RT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb(), %d",
+	RT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb(), %d\n",
 		 atomic_read(&priv->ieee80211->atm_swbw));
 }
 

commit 26f3561db708efa91e005b8837fb3e49c17b424f
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sun Jun 23 06:15:18 2013 +0300

    staging: rtl8192u: replace msleep(1) with usleep_range() in r819xU_phy.c
    
    This patch fixes the following checkpatch warning:
    WARNING: msleep < 20ms can sleep for up to 20ms
    
    The implementation of msleep() is based on jiffies timeout
    subsystem. Hence, its resolution is constrained by the value
    of HZ tick rate. When HZ variable is configured to 100,
    the jiffies variable is updated every 10 ms, so a timeout
    of 1ms cannot be met using jiffies (it will be rounded up
    to 10ms).
    
    This patch replaces msleep(1) with usleep_range(1000, 1000).
    usleep_range() uses hrtimers subsystem which is not bound
    to HZ value and can provide microsecond-level resolution.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index edb5df2c25f5..92f0f90150e9 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -185,7 +185,7 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 
 
 	/* TODO: we should not delay such a long time. Ask for help from SD3 */
-	msleep(1);
+	usleep_range(1000, 1000);
 
 	ret = rtl8192_QueryBBReg(dev, pPhyReg->rfLSSIReadBack,
 				 bLSSIReadBackData);
@@ -741,11 +741,11 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 					     bMask12Bits, WriteData[i]);
 			/* TODO: we should not delay for such a long time.
 			   Ask SD3 */
-			msleep(1);
+			usleep_range(1000, 1000);
 			reg = rtl8192_phy_QueryRFReg(dev, eRFPath,
 						     WriteAddr[HW90_BLOCK_RF],
 						     bMask12Bits);
-			msleep(1);
+			usleep_range(1000, 1000);
 			break;
 
 		default:

commit a60d4d6896fff32da512b233e0726a6423ff1562
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sun Jun 23 06:15:17 2013 +0300

    staging: rtl8192u: rename dwRegRead and rtStatus in r819xU_phy.c
    
    This patch renames the following variables:
    'dwRegRead' into 'reg'
    'rtStatus'  into 'status'
    
    This is done primarily to reduce line length below 80 chars,
    since the size and the usage of dwRegRead variable
    can be deduced by its type and the function called
    to assign it, so it can be replaced by simply 'reg'.
    Also, rtStatus is not more informative than just status
    in the given context.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index bb67eca9773a..edb5df2c25f5 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -709,7 +709,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 			    RF90_RADIO_PATH_E eRFPath)
 {
 	u8 ret = 0;
-	u32 i, CheckTimes = 4, dwRegRead = 0;
+	u32 i, CheckTimes = 4, reg = 0;
 	u32 WriteAddr[4];
 	u32 WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};
 	/* Initialize register address offset to be checked */
@@ -731,7 +731,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 		case HW90_BLOCK_PHY1:
 			write_nic_dword(dev, WriteAddr[CheckBlock],
 					WriteData[i]);
-			read_nic_dword(dev, WriteAddr[CheckBlock], &dwRegRead);
+			read_nic_dword(dev, WriteAddr[CheckBlock], &reg);
 			break;
 
 		case HW90_BLOCK_RF:
@@ -742,9 +742,9 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 			/* TODO: we should not delay for such a long time.
 			   Ask SD3 */
 			msleep(1);
-			dwRegRead = rtl8192_phy_QueryRFReg(dev, eRFPath,
-							   WriteAddr[HW90_BLOCK_RF],
-							   bMask12Bits);
+			reg = rtl8192_phy_QueryRFReg(dev, eRFPath,
+						     WriteAddr[HW90_BLOCK_RF],
+						     bMask12Bits);
 			msleep(1);
 			break;
 
@@ -755,10 +755,10 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 
 
 		/* Check whether readback data is correct */
-		if (dwRegRead != WriteData[i]) {
+		if (reg != WriteData[i]) {
 			RT_TRACE((COMP_PHY|COMP_ERR),
-				 "error dwRegRead: %x, WriteData: %x\n",
-				 dwRegRead, WriteData[i]);
+				 "error reg: %x, WriteData: %x\n",
+				 reg, WriteData[i]);
 			ret = 1;
 			break;
 		}
@@ -779,7 +779,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	u8 reg_u8 = 0, eCheckItem = 0, rtStatus = 0;
+	u8 reg_u8 = 0, eCheckItem = 0, status = 0;
 	u32 reg_u32 = 0;
 	/**************************************
 	 * <1> Initialize BaseBand
@@ -798,9 +798,9 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	for (eCheckItem = (HW90_BLOCK_E)HW90_BLOCK_PHY0;
 	     eCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {
 		/* don't care RF path */
-		rtStatus = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem,
-						    (RF90_RADIO_PATH_E)0);
-		if (rtStatus != 0) {
+		status = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem,
+						  (RF90_RADIO_PATH_E)0);
+		if (status != 0) {
 			RT_TRACE((COMP_ERR | COMP_PHY),
 				 "PHY_RF8256_Config(): Check PHY%d Fail!!\n",
 				 eCheckItem-1);

commit 08a4cdea1956e60300b34b1cc324dc1ac256382b
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sun Jun 23 06:15:16 2013 +0300

    staging: rtl8192u: replace __FUNCTION__ in r819xU_phy.c
    
    This patch fixes the following checkpatch warning:
    WARNING: __func__ should be used instead of gcc specific __FUNCTION__
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 9931b171f2d3..bb67eca9773a 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -717,7 +717,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 	WriteAddr[HW90_BLOCK_PHY0] = 0x900;
 	WriteAddr[HW90_BLOCK_PHY1] = 0x800;
 	WriteAddr[HW90_BLOCK_RF] = 0x3;
-	RT_TRACE(COMP_PHY, "%s(), CheckBlock: %d\n", __FUNCTION__, CheckBlock);
+	RT_TRACE(COMP_PHY, "%s(), CheckBlock: %d\n", __func__, CheckBlock);
 	for (i = 0; i < CheckTimes; i++) {
 
 		/* Write data to register and readback */
@@ -931,7 +931,7 @@ void rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)
 	default:
 		RT_TRACE((COMP_PHY|COMP_ERR),
 			 "error RF chipID(8225 or 8258) in function %s()\n",
-			 __FUNCTION__);
+			 __func__);
 		break;
 	}
 	return;
@@ -1280,7 +1280,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
 	u8		eRFPath;
 
 	RT_TRACE(COMP_CH, "%s() stage: %d, step: %d, channel: %d\n",
-		 __FUNCTION__, *stage, *step, channel);
+		 __func__, *stage, *step, channel);
 	if (!IsLegalChannel(priv->ieee80211, channel)) {
 		RT_TRACE(COMP_ERR, "set to illegal channel: %d\n", channel);
 		/* return true to tell upper caller function this channel
@@ -1466,7 +1466,7 @@ void rtl8192_SwChnl_WorkItem(struct net_device *dev)
 u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	RT_TRACE(COMP_CH, "%s(), SwChnlInProgress: %d\n", __FUNCTION__,
+	RT_TRACE(COMP_CH, "%s(), SwChnlInProgress: %d\n", __func__,
 		 priv->SwChnlInProgress);
 	if (!priv->up)
 		return false;

commit 1db5aa05629820445deab2c65c872dd7b7284104
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sun Jun 23 06:15:15 2013 +0300

    staging: rtl8192u: limit line size in r819xU_phy.c
    
    This patch limits the line size below 80 characters,
    when possible without producing new checkpatch errors.
    
    This is done by adjusting identation, replacing hardcoded
    function names in messages with __func__, merging some
    trailing comments with the header comments when they both
    refer to the same line and removing some unnecessary
    parenthesis.
    
    Also, changes slightly some RT_TRACE messages to make
    them shorter without altering their content.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 627165a33620..9931b171f2d3 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -154,25 +154,31 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 		if (offset >= 31) {
 			priv->RfReg0Value[eRFPath] |= 0x140;
 			/* Switch to Reg_Mode2 for Reg 31-45 */
-			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));
+			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,
+					 bMaskDWord,
+					 priv->RfReg0Value[eRFPath]<<16);
 			/* Modify offset */
 			new_offset = offset - 30;
 		} else if (offset >= 16) {
 			priv->RfReg0Value[eRFPath] |= 0x100;
 			priv->RfReg0Value[eRFPath] &= (~0x40);
 			/* Switch to Reg_Mode1 for Reg16-30 */
-			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));
+			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,
+					 bMaskDWord,
+					 priv->RfReg0Value[eRFPath]<<16);
 
 			new_offset = offset - 15;
 		} else {
 			new_offset = offset;
 		}
 	} else {
-		RT_TRACE((COMP_PHY|COMP_ERR), "check RF type here, need to be 8256\n");
+		RT_TRACE((COMP_PHY|COMP_ERR),
+			 "check RF type here, need to be 8256\n");
 		new_offset = offset;
 	}
 	/* Put desired read addr to LSSI control Register */
-	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadAddress, new_offset);
+	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadAddress,
+			 new_offset);
 	/* Issue a posedge trigger */
 	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x0);
 	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x1);
@@ -181,18 +187,16 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	/* TODO: we should not delay such a long time. Ask for help from SD3 */
 	msleep(1);
 
-	ret = rtl8192_QueryBBReg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData);
+	ret = rtl8192_QueryBBReg(dev, pPhyReg->rfLSSIReadBack,
+				 bLSSIReadBackData);
 
 
 	/* Switch back to Reg_Mode0 */
 	if (priv->rf_chip == RF_8256) {
 		priv->RfReg0Value[eRFPath] &= 0xebf;
 
-		rtl8192_setBBreg(
-			dev,
-			pPhyReg->rf3wireOffset,
-			bMaskDWord,
-			(priv->RfReg0Value[eRFPath] << 16));
+		rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord,
+				 priv->RfReg0Value[eRFPath] << 16);
 	}
 
 	return ret;
@@ -231,18 +235,23 @@ void rtl8192_phy_RFSerialWrite(struct net_device *dev,
 
 		if (offset >= 31) {
 			priv->RfReg0Value[eRFPath] |= 0x140;
-			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath] << 16));
+			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,
+					 bMaskDWord,
+					 priv->RfReg0Value[eRFPath] << 16);
 			new_offset = offset - 30;
 		} else if (offset >= 16) {
 			priv->RfReg0Value[eRFPath] |= 0x100;
 			priv->RfReg0Value[eRFPath] &= (~0x40);
-			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));
+			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,
+					 bMaskDWord,
+					 priv->RfReg0Value[eRFPath]<<16);
 			new_offset = offset - 15;
 		} else {
 			new_offset = offset;
 		}
 	} else {
-		RT_TRACE((COMP_PHY|COMP_ERR), "check RF type here, need to be 8256\n");
+		RT_TRACE((COMP_PHY|COMP_ERR),
+			 "check RF type here, need to be 8256\n");
 		new_offset = offset;
 	}
 
@@ -260,11 +269,9 @@ void rtl8192_phy_RFSerialWrite(struct net_device *dev,
 	if (priv->rf_chip == RF_8256) {
 		if (offset != 0) {
 			priv->RfReg0Value[eRFPath] &= 0xebf;
-			rtl8192_setBBreg(
-				dev,
-				pPhyReg->rf3wireOffset,
-				bMaskDWord,
-				(priv->RfReg0Value[eRFPath] << 16));
+			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,
+					 bMaskDWord,
+					 priv->RfReg0Value[eRFPath] << 16);
 		}
 	}
 	return;
@@ -495,9 +502,11 @@ void rtl8192_phy_configmac(struct net_device *dev)
 			pdwArray[i+2] = 0x00000800;
 		}
 
-		RT_TRACE(COMP_DBG, "The Rtl8190MACPHY_Array[0] is %x Rtl8190MACPHY_Array[1] is %x Rtl8190MACPHY_Array[2] is %x\n",
-				pdwArray[i], pdwArray[i+1], pdwArray[i+2]);
-		rtl8192_setBBreg(dev, pdwArray[i], pdwArray[i+1], pdwArray[i+2]);
+		RT_TRACE(COMP_DBG,
+			 "Rtl8190MACPHY_Array[0]=%x Rtl8190MACPHY_Array[1]=%x Rtl8190MACPHY_Array[2]=%x\n",
+			 pdwArray[i], pdwArray[i+1], pdwArray[i+2]);
+		rtl8192_setBBreg(dev, pdwArray[i], pdwArray[i+1],
+				 pdwArray[i+2]);
 	}
 	return;
 
@@ -528,13 +537,22 @@ void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 #endif
 	if (ConfigType == BaseBand_Config_PHY_REG) {
 		for (i = 0; i < PHY_REG_1T2RArrayLength; i += 2) {
-			rtl8192_setBBreg(dev, rtl819XPHY_REG_1T2RArray[i], bMaskDWord, rtl819XPHY_REG_1T2RArray[i+1]);
-			RT_TRACE(COMP_DBG, "i: %x, The Rtl819xUsbPHY_REGArray[0] is %x Rtl819xUsbPHY_REGArray[1] is %x \n", i, rtl819XPHY_REG_1T2RArray[i], rtl819XPHY_REG_1T2RArray[i+1]);
+			rtl8192_setBBreg(dev, rtl819XPHY_REG_1T2RArray[i],
+					 bMaskDWord,
+					 rtl819XPHY_REG_1T2RArray[i+1]);
+			RT_TRACE(COMP_DBG,
+				 "i: %x, Rtl819xUsbPHY_REGArray[0]=%x Rtl819xUsbPHY_REGArray[1]=%x\n",
+				 i, rtl819XPHY_REG_1T2RArray[i],
+				 rtl819XPHY_REG_1T2RArray[i+1]);
 		}
 	} else if (ConfigType == BaseBand_Config_AGC_TAB) {
 		for (i = 0; i < AGCTAB_ArrayLength; i += 2) {
-			rtl8192_setBBreg(dev, rtl819XAGCTAB_Array[i], bMaskDWord, rtl819XAGCTAB_Array[i+1]);
-			RT_TRACE(COMP_DBG, "i:%x, The rtl819XAGCTAB_Array[0] is %x rtl819XAGCTAB_Array[1] is %x \n", i, rtl819XAGCTAB_Array[i], rtl819XAGCTAB_Array[i+1]);
+			rtl8192_setBBreg(dev, rtl819XAGCTAB_Array[i],
+					 bMaskDWord, rtl819XAGCTAB_Array[i+1]);
+			RT_TRACE(COMP_DBG,
+				 "i: %x, rtl819XAGCTAB_Array[0]=%x rtl819XAGCTAB_Array[1]=%x\n",
+				 i, rtl819XAGCTAB_Array[i],
+				 rtl819XAGCTAB_Array[i+1]);
 		}
 	}
 	return;
@@ -699,28 +717,34 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 	WriteAddr[HW90_BLOCK_PHY0] = 0x900;
 	WriteAddr[HW90_BLOCK_PHY1] = 0x800;
 	WriteAddr[HW90_BLOCK_RF] = 0x3;
-	RT_TRACE(COMP_PHY, "=======>%s(), CheckBlock:%d\n", __FUNCTION__, CheckBlock);
+	RT_TRACE(COMP_PHY, "%s(), CheckBlock: %d\n", __FUNCTION__, CheckBlock);
 	for (i = 0; i < CheckTimes; i++) {
 
 		/* Write data to register and readback */
 		switch (CheckBlock) {
 		case HW90_BLOCK_MAC:
-			RT_TRACE(COMP_ERR, "PHY_CheckBBRFOK(): Never Write 0x100 here!");
+			RT_TRACE(COMP_ERR,
+				 "PHY_CheckBBRFOK(): Never Write 0x100 here!");
 			break;
 
 		case HW90_BLOCK_PHY0:
 		case HW90_BLOCK_PHY1:
-			write_nic_dword(dev, WriteAddr[CheckBlock], WriteData[i]);
+			write_nic_dword(dev, WriteAddr[CheckBlock],
+					WriteData[i]);
 			read_nic_dword(dev, WriteAddr[CheckBlock], &dwRegRead);
 			break;
 
 		case HW90_BLOCK_RF:
 			WriteData[i] &= 0xfff;
-			rtl8192_phy_SetRFReg(dev, eRFPath, WriteAddr[HW90_BLOCK_RF], bMask12Bits, WriteData[i]);
+			rtl8192_phy_SetRFReg(dev, eRFPath,
+					     WriteAddr[HW90_BLOCK_RF],
+					     bMask12Bits, WriteData[i]);
 			/* TODO: we should not delay for such a long time.
 			   Ask SD3 */
 			msleep(1);
-			dwRegRead = rtl8192_phy_QueryRFReg(dev, eRFPath, WriteAddr[HW90_BLOCK_RF], bMask12Bits);
+			dwRegRead = rtl8192_phy_QueryRFReg(dev, eRFPath,
+							   WriteAddr[HW90_BLOCK_RF],
+							   bMask12Bits);
 			msleep(1);
 			break;
 
@@ -732,7 +756,9 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 
 		/* Check whether readback data is correct */
 		if (dwRegRead != WriteData[i]) {
-			RT_TRACE((COMP_PHY|COMP_ERR), "====>error=====dwRegRead: %x, WriteData: %x \n", dwRegRead, WriteData[i]);
+			RT_TRACE((COMP_PHY|COMP_ERR),
+				 "error dwRegRead: %x, WriteData: %x\n",
+				 dwRegRead, WriteData[i]);
 			ret = 1;
 			break;
 		}
@@ -769,10 +795,15 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 
 	/* ----Ckeck FPGAPHY0 and PHY1 board is OK---- */
 	/* TODO: this function should be removed on ASIC */
-	for (eCheckItem = (HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {
-		rtStatus  = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem, (RF90_RADIO_PATH_E)0); /* don't care RF path */
+	for (eCheckItem = (HW90_BLOCK_E)HW90_BLOCK_PHY0;
+	     eCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {
+		/* don't care RF path */
+		rtStatus = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem,
+						    (RF90_RADIO_PATH_E)0);
 		if (rtStatus != 0) {
-			RT_TRACE((COMP_ERR | COMP_PHY), "PHY_RF8256_Config():Check PHY%d Fail!!\n", eCheckItem-1);
+			RT_TRACE((COMP_ERR | COMP_PHY),
+				 "PHY_RF8256_Config(): Check PHY%d Fail!!\n",
+				 eCheckItem-1);
 			return;
 		}
 	}
@@ -794,17 +825,22 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	write_nic_byte_E(dev, 0x5e, 0x00);
 	if (priv->card_8192_version == (u8)VERSION_819xU_A) {
 		/* Antenna gain offset from B/C/D to A */
-		reg_u32 = (priv->AntennaTxPwDiff[1]<<4 | priv->AntennaTxPwDiff[0]);
-		rtl8192_setBBreg(dev, rFPGA0_TxGainStage, (bXBTxAGC|bXCTxAGC), reg_u32);
+		reg_u32 = (priv->AntennaTxPwDiff[1]<<4 |
+			   priv->AntennaTxPwDiff[0]);
+		rtl8192_setBBreg(dev, rFPGA0_TxGainStage, (bXBTxAGC|bXCTxAGC),
+				 reg_u32);
 
 		/* XSTALLCap */
 		reg_u32 = priv->CrystalCap & 0xf;
-		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, bXtalCap, reg_u32);
+		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, bXtalCap,
+				 reg_u32);
 	}
 
 	/* Check if the CCK HighPower is turned ON.
 	   This is used to calculate PWDB. */
-	priv->bCckHighPower = (u8)(rtl8192_QueryBBReg(dev, rFPGA0_XA_HSSIParameter2, 0x200));
+	priv->bCckHighPower = (u8)rtl8192_QueryBBReg(dev,
+						     rFPGA0_XA_HSSIParameter2,
+						     0x200);
 	return;
 }
 /******************************************************************************
@@ -836,21 +872,28 @@ void rtl8192_phy_getTxPower(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8 tmp;
-	read_nic_dword(dev, rTxAGC_Rate18_06, &priv->MCSTxPowerLevelOriginalOffset[0]);
-	read_nic_dword(dev, rTxAGC_Rate54_24, &priv->MCSTxPowerLevelOriginalOffset[1]);
-	read_nic_dword(dev, rTxAGC_Mcs03_Mcs00, &priv->MCSTxPowerLevelOriginalOffset[2]);
-	read_nic_dword(dev, rTxAGC_Mcs07_Mcs04, &priv->MCSTxPowerLevelOriginalOffset[3]);
-	read_nic_dword(dev, rTxAGC_Mcs11_Mcs08, &priv->MCSTxPowerLevelOriginalOffset[4]);
-	read_nic_dword(dev, rTxAGC_Mcs15_Mcs12, &priv->MCSTxPowerLevelOriginalOffset[5]);
+	read_nic_dword(dev, rTxAGC_Rate18_06,
+		       &priv->MCSTxPowerLevelOriginalOffset[0]);
+	read_nic_dword(dev, rTxAGC_Rate54_24,
+		       &priv->MCSTxPowerLevelOriginalOffset[1]);
+	read_nic_dword(dev, rTxAGC_Mcs03_Mcs00,
+		       &priv->MCSTxPowerLevelOriginalOffset[2]);
+	read_nic_dword(dev, rTxAGC_Mcs07_Mcs04,
+		       &priv->MCSTxPowerLevelOriginalOffset[3]);
+	read_nic_dword(dev, rTxAGC_Mcs11_Mcs08,
+		       &priv->MCSTxPowerLevelOriginalOffset[4]);
+	read_nic_dword(dev, rTxAGC_Mcs15_Mcs12,
+		       &priv->MCSTxPowerLevelOriginalOffset[5]);
 
 	/* Read rx initial gain */
 	read_nic_byte(dev, rOFDM0_XAAGCCore1, &priv->DefaultInitialGain[0]);
 	read_nic_byte(dev, rOFDM0_XBAGCCore1, &priv->DefaultInitialGain[1]);
 	read_nic_byte(dev, rOFDM0_XCAGCCore1, &priv->DefaultInitialGain[2]);
 	read_nic_byte(dev, rOFDM0_XDAGCCore1, &priv->DefaultInitialGain[3]);
-	RT_TRACE(COMP_INIT, "Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x) \n",
-		priv->DefaultInitialGain[0], priv->DefaultInitialGain[1],
-		priv->DefaultInitialGain[2], priv->DefaultInitialGain[3]);
+	RT_TRACE(COMP_INIT,
+		 "Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x)\n",
+		 priv->DefaultInitialGain[0], priv->DefaultInitialGain[1],
+		 priv->DefaultInitialGain[2], priv->DefaultInitialGain[3]);
 
 	/* Read framesync */
 	read_nic_byte(dev, rOFDM0_RxDetector3, &priv->framesync);
@@ -881,11 +924,14 @@ void rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)
 
 	switch (priv->rf_chip) {
 	case RF_8256:
-		PHY_SetRF8256CCKTxPower(dev, powerlevel); //need further implement
+		/* need further implement */
+		PHY_SetRF8256CCKTxPower(dev, powerlevel);
 		PHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);
 		break;
 	default:
-		RT_TRACE((COMP_PHY|COMP_ERR), "error RF chipID(8225 or 8258) in function %s()\n", __FUNCTION__);
+		RT_TRACE((COMP_PHY|COMP_ERR),
+			 "error RF chipID(8225 or 8258) in function %s()\n",
+			 __FUNCTION__);
 		break;
 	}
 	return;
@@ -944,10 +990,13 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		for (i = 0; i < RadioA_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioA_Array[i] == 0xfe) {
-					mdelay(100);
-					continue;
+				mdelay(100);
+				continue;
 			}
-			rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioA_Array[i], bMask12Bits, rtl819XRadioA_Array[i+1]);
+			rtl8192_phy_SetRFReg(dev, eRFPath,
+					     rtl819XRadioA_Array[i],
+					     bMask12Bits,
+					     rtl819XRadioA_Array[i+1]);
 			mdelay(1);
 
 		}
@@ -956,10 +1005,13 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		for (i = 0; i < RadioB_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioB_Array[i] == 0xfe) {
-					mdelay(100);
-					continue;
+				mdelay(100);
+				continue;
 			}
-			rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioB_Array[i], bMask12Bits, rtl819XRadioB_Array[i+1]);
+			rtl8192_phy_SetRFReg(dev, eRFPath,
+					     rtl819XRadioB_Array[i],
+					     bMask12Bits,
+					     rtl819XRadioB_Array[i+1]);
 			mdelay(1);
 
 		}
@@ -968,10 +1020,13 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		for (i = 0; i < RadioC_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioC_Array[i] == 0xfe) {
-					mdelay(100);
-					continue;
+				mdelay(100);
+				continue;
 			}
-			rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioC_Array[i], bMask12Bits, rtl819XRadioC_Array[i+1]);
+			rtl8192_phy_SetRFReg(dev, eRFPath,
+					     rtl819XRadioC_Array[i],
+					     bMask12Bits,
+					     rtl819XRadioC_Array[i+1]);
 			mdelay(1);
 
 		}
@@ -980,10 +1035,13 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		for (i = 0; i < RadioD_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioD_Array[i] == 0xfe) {
-					mdelay(100);
-					continue;
+				mdelay(100);
+				continue;
 			}
-			rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioD_Array[i], bMask12Bits, rtl819XRadioD_Array[i+1]);
+			rtl8192_phy_SetRFReg(dev, eRFPath,
+					     rtl819XRadioD_Array[i],
+					     bMask12Bits,
+					     rtl819XRadioD_Array[i+1]);
 			mdelay(1);
 
 		}
@@ -1025,7 +1083,7 @@ void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
 	case RF_8258:
 		break;
 	default:
-		RT_TRACE(COMP_ERR, "unknown rf chip ID in rtl8192_SetTxPowerLevel()\n");
+		RT_TRACE(COMP_ERR, "unknown rf chip ID in %s()\n", __func__);
 		break;
 	}
 	return;
@@ -1054,90 +1112,103 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 	priv->SetRFPowerStateInProgress = true;
 
 	switch (priv->rf_chip) {
-		case RF_8256:
+	case RF_8256:
 		switch (eRFPowerState) {
-			case eRfOn:
-				/* RF-A, RF-B */
-				/* enable RF-Chip A/B */
-				rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x1); /* 0x860[4] */
-				/* analog to digital on */
-				rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3); /* 0x88c[9:8] */
-				/* digital to analog on */
-				rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18, 0x3); /* 0x880[4:3] */
-				/* rx antenna on */
-				rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0x3, 0x3); /* 0xc04[1:0] */
-				/* rx antenna on */
-				rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0x3, 0x3); /* 0xd04[1:0] */
-				/* analog to digital part2 on */
-				rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x3); /* 0x880[6:5] */
+		case eRfOn:
+			/* RF-A, RF-B */
+			/* enable RF-Chip A/B - 0x860[4] */
+			rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4,
+					 0x1);
+			/* analog to digital on - 0x88c[9:8] */
+			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300,
+					 0x3);
+			/* digital to analog on - 0x880[4:3] */
+			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18,
+					 0x3);
+			/* rx antenna on - 0xc04[1:0] */
+			rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0x3, 0x3);
+			/* rx antenna on - 0xd04[1:0] */
+			rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0x3, 0x3);
+			/* analog to digital part2 on - 0x880[6:5] */
+			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60,
+					 0x3);
 
-				break;
-
-			case eRfSleep:
+			break;
 
-				break;
+		case eRfSleep:
 
-			case eRfOff:
-				/* RF-A, RF-B */
-				/* disable RF-Chip A/B */
-				rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x0); /* 0x860[4] */
-				/* analog to digital off, for power save */
-				rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00, 0x0); /* 0x88c[11:8] */
-				/* digital to analog off, for power save */
-				rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18, 0x0); /* 0x880[4:3] */
-				/* rx antenna off */
-				rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0x0); /* 0xc04[3:0] */
-				/* rx antenna off */
-				rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x0); /* 0xd04[3:0] */
-				/* analog to digital part2 off, for power save */
-				rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x0); /* 0x880[6:5] */
+			break;
 
-				break;
+		case eRfOff:
+			/* RF-A, RF-B */
+			/* disable RF-Chip A/B - 0x860[4] */
+			rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4,
+					 0x0);
+			/* analog to digital off, for power save */
+			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00,
+					 0x0); /* 0x88c[11:8] */
+			/* digital to analog off, for power save - 0x880[4:3] */
+			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18,
+					 0x0);
+			/* rx antenna off - 0xc04[3:0] */
+			rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0x0);
+			/* rx antenna off - 0xd04[3:0] */
+			rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x0);
+			/* analog to digital part2 off, for power save */
+			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60,
+					 0x0); /* 0x880[6:5] */
 
-			default:
-				bResult = false;
-				RT_TRACE(COMP_ERR, "SetRFPowerState819xUsb(): unknow state to set: 0x%X!!!\n", eRFPowerState);
-				break;
-		}
 			break;
+
 		default:
-			RT_TRACE(COMP_ERR, "Not support rf_chip(%x)\n", priv->rf_chip);
+			bResult = false;
+			RT_TRACE(COMP_ERR, "%s(): unknown state to set: 0x%X\n",
+				 __func__, eRFPowerState);
 			break;
+		}
+		break;
+	default:
+		RT_TRACE(COMP_ERR, "Not support rf_chip(%x)\n", priv->rf_chip);
+		break;
 	}
 #ifdef TO_DO_LIST
 	if (bResult) {
 		/* Update current RF state variable. */
 		pHalData->eRFPowerState = eRFPowerState;
 		switch (pHalData->RFChipID) {
-			case RF_8256:
-		switch (pHalData->eRFPowerState) {
-				case eRfOff:
-					/* If Rf off reason is from IPS, LED should blink with no link */
-					if (pMgntInfo->RfOffReason == RF_CHANGE_BY_IPS)
-						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);
-					else
-						/* Turn off LED if RF is not ON. */
-						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_POWER_OFF);
-					break;
-
-				case eRfOn:
-					/* Turn on RF we are still linked, which might happen when we quickly turn off and on HW RF. */
-					if (pMgntInfo->bMediaConnect == TRUE)
-						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_LINK);
-					else
-						/* Turn off LED if RF is not ON. */
-						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);
-					break;
-
-				default:
-					break;
-				}
+		case RF_8256:
+			switch (pHalData->eRFPowerState) {
+			case eRfOff:
+				/* If Rf off reason is from IPS,
+				   LED should blink with no link */
+				if (pMgntInfo->RfOffReason == RF_CHANGE_BY_IPS)
+					Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);
+				else
+					/* Turn off LED if RF is not ON. */
+					Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_POWER_OFF);
 				break;
 
-				default:
-					RT_TRACE(COMP_RF, DBG_LOUD, ("SetRFPowerState8190(): Unknown RF type\n"));
-					break;
+			case eRfOn:
+				/* Turn on RF we are still linked, which might
+				   happen when we quickly turn off and on HW RF.
+				 */
+				if (pMgntInfo->bMediaConnect == TRUE)
+					Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_LINK);
+				else
+					/* Turn off LED if RF is not ON. */
+					Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);
+				break;
+
+			default:
+				break;
 			}
+			break;
+
+		default:
+			RT_TRACE(COMP_RF, DBG_LOUD, "%s(): Unknown RF type\n",
+				 __func__);
+			break;
+		}
 
 	}
 #endif
@@ -1166,12 +1237,12 @@ u8 rtl8192_phy_SetSwChnlCmdArray(SwChnlCmd *CmdTable, u32 CmdTableIdx,
 	SwChnlCmd *pCmd;
 
 	if (CmdTable == NULL) {
-		RT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): CmdTable cannot be NULL.\n");
+		RT_TRACE(COMP_ERR, "%s(): CmdTable cannot be NULL\n", __func__);
 		return false;
 	}
 	if (CmdTableIdx >= CmdTableSz) {
-		RT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): Access invalid index, please check size of the table, CmdTableIdx:%d, CmdTableSz:%d\n",
-				CmdTableIdx, CmdTableSz);
+		RT_TRACE(COMP_ERR, "%s(): Access invalid index, please check size of the table, CmdTableIdx:%d, CmdTableSz:%d\n",
+			 __func__, CmdTableIdx, CmdTableSz);
 		return false;
 	}
 
@@ -1199,124 +1270,145 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
 				u8 *step, u32 *delay)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	SwChnlCmd				PreCommonCmd[MAX_PRECMD_CNT];
-	u32					PreCommonCmdCnt;
-	SwChnlCmd				PostCommonCmd[MAX_POSTCMD_CNT];
-	u32					PostCommonCmdCnt;
-	SwChnlCmd				RfDependCmd[MAX_RFDEPENDCMD_CNT];
-	u32					RfDependCmdCnt;
-	SwChnlCmd				*CurrentCmd = NULL;
+	SwChnlCmd	PreCommonCmd[MAX_PRECMD_CNT];
+	u32		PreCommonCmdCnt;
+	SwChnlCmd	PostCommonCmd[MAX_POSTCMD_CNT];
+	u32		PostCommonCmdCnt;
+	SwChnlCmd	RfDependCmd[MAX_RFDEPENDCMD_CNT];
+	u32		RfDependCmdCnt;
+	SwChnlCmd	*CurrentCmd = NULL;
 	u8		eRFPath;
 
-	RT_TRACE(COMP_CH, "====>%s()====stage:%d, step:%d, channel:%d\n", __FUNCTION__, *stage, *step, channel);
+	RT_TRACE(COMP_CH, "%s() stage: %d, step: %d, channel: %d\n",
+		 __FUNCTION__, *stage, *step, channel);
 	if (!IsLegalChannel(priv->ieee80211, channel)) {
-		RT_TRACE(COMP_ERR, "=============>set to illegal channel:%d\n", channel);
+		RT_TRACE(COMP_ERR, "set to illegal channel: %d\n", channel);
 		/* return true to tell upper caller function this channel
 		   setting is finished! Or it will in while loop. */
 		return true;
 	}
-/* FIXME: need to check whether channel is legal or not here */
+	/* FIXME: need to check whether channel is legal or not here */
 
 
-	        /* <1> Fill up pre common command. */
-		PreCommonCmdCnt = 0;
-		rtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT,
-					CmdID_SetTxPowerLevel, 0, 0, 0);
-		rtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT,
-					CmdID_End, 0, 0, 0);
+	/* <1> Fill up pre common command. */
+	PreCommonCmdCnt = 0;
+	rtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++,
+				      MAX_PRECMD_CNT, CmdID_SetTxPowerLevel,
+				      0, 0, 0);
+	rtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++,
+				      MAX_PRECMD_CNT, CmdID_End, 0, 0, 0);
 
-		/* <2> Fill up post common command. */
-		PostCommonCmdCnt = 0;
+	/* <2> Fill up post common command. */
+	PostCommonCmdCnt = 0;
 
-		rtl8192_phy_SetSwChnlCmdArray(PostCommonCmd, PostCommonCmdCnt++, MAX_POSTCMD_CNT,
-					CmdID_End, 0, 0, 0);
+	rtl8192_phy_SetSwChnlCmdArray(PostCommonCmd, PostCommonCmdCnt++,
+				      MAX_POSTCMD_CNT, CmdID_End, 0, 0, 0);
 
-		/* <3> Fill up RF dependent command. */
-		RfDependCmdCnt = 0;
-		switch (priv->rf_chip) {
-		case RF_8225:
-			if (!(channel >= 1 && channel <= 14)) {
-				RT_TRACE(COMP_ERR, "illegal channel for Zebra 8225: %d\n", channel);
-				return true;
-			}
-			rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
-				CmdID_RF_WriteReg, rZebra1_Channel, RF_CHANNEL_TABLE_ZEBRA[channel], 10);
-			rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
-				CmdID_End, 0, 0, 0);
-			break;
-
-		case RF_8256:
-			/* TEST!! This is not the table for 8256!! */
-			if (!(channel >= 1 && channel <= 14)) {
-				RT_TRACE(COMP_ERR, "illegal channel for Zebra 8256: %d\n", channel);
-				return true;
-			}
-			rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
-				CmdID_RF_WriteReg, rZebra1_Channel, channel, 10);
-			rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
-			CmdID_End, 0, 0, 0);
-			break;
-
-		case RF_8258:
-			break;
+	/* <3> Fill up RF dependent command. */
+	RfDependCmdCnt = 0;
+	switch (priv->rf_chip) {
+	case RF_8225:
+		if (!(channel >= 1 && channel <= 14)) {
+			RT_TRACE(COMP_ERR,
+				 "illegal channel for Zebra 8225: %d\n",
+				 channel);
+			return true;
+		}
+		rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++,
+					      MAX_RFDEPENDCMD_CNT,
+					      CmdID_RF_WriteReg,
+					      rZebra1_Channel,
+					      RF_CHANNEL_TABLE_ZEBRA[channel],
+					      10);
+		rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++,
+					      MAX_RFDEPENDCMD_CNT,
+					      CmdID_End, 0, 0, 0);
+		break;
 
-		default:
-			RT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);
+	case RF_8256:
+		/* TEST!! This is not the table for 8256!! */
+		if (!(channel >= 1 && channel <= 14)) {
+			RT_TRACE(COMP_ERR,
+				 "illegal channel for Zebra 8256: %d\n",
+				 channel);
 			return true;
-			break;
 		}
+		rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++,
+					      MAX_RFDEPENDCMD_CNT,
+					      CmdID_RF_WriteReg,
+					      rZebra1_Channel, channel, 10);
+		rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++,
+					      MAX_RFDEPENDCMD_CNT,
+					      CmdID_End, 0, 0, 0);
+		break;
 
+	case RF_8258:
+		break;
 
-		do {
-			switch (*stage) {
-			case 0:
-				CurrentCmd = &PreCommonCmd[*step];
-				break;
-			case 1:
-				CurrentCmd = &RfDependCmd[*step];
-				break;
-			case 2:
-				CurrentCmd = &PostCommonCmd[*step];
-				break;
-			}
+	default:
+		RT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);
+		return true;
+		break;
+	}
 
-			if (CurrentCmd->CmdID == CmdID_End) {
-				if ((*stage) == 2) {
-					(*delay) = CurrentCmd->msDelay;
-					return true;
-				} else {
-					(*stage)++;
-					(*step) = 0;
-					continue;
-				}
-			}
 
-			switch (CurrentCmd->CmdID) {
-			case CmdID_SetTxPowerLevel:
-				if (priv->card_8192_version == (u8)VERSION_819xU_A)
-					/* consider it later! */
-					rtl8192_SetTxPowerLevel(dev, channel);
-				break;
-			case CmdID_WritePortUlong:
-				write_nic_dword(dev, CurrentCmd->Para1, CurrentCmd->Para2);
-				break;
-			case CmdID_WritePortUshort:
-				write_nic_word(dev, CurrentCmd->Para1, (u16)CurrentCmd->Para2);
-				break;
-			case CmdID_WritePortUchar:
-				write_nic_byte(dev, CurrentCmd->Para1, (u8)CurrentCmd->Para2);
-				break;
-			case CmdID_RF_WriteReg:
-				for (eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {
-				rtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, bZebra1_ChannelNum, CurrentCmd->Para2);
-				}
-				break;
-			default:
-				break;
+	do {
+		switch (*stage) {
+		case 0:
+			CurrentCmd = &PreCommonCmd[*step];
+			break;
+		case 1:
+			CurrentCmd = &RfDependCmd[*step];
+			break;
+		case 2:
+			CurrentCmd = &PostCommonCmd[*step];
+			break;
+		}
+
+		if (CurrentCmd->CmdID == CmdID_End) {
+			if ((*stage) == 2) {
+				(*delay) = CurrentCmd->msDelay;
+				return true;
+			} else {
+				(*stage)++;
+				(*step) = 0;
+				continue;
 			}
+		}
 
+		switch (CurrentCmd->CmdID) {
+		case CmdID_SetTxPowerLevel:
+			if (priv->card_8192_version == (u8)VERSION_819xU_A)
+				/* consider it later! */
+				rtl8192_SetTxPowerLevel(dev, channel);
 			break;
-		} while (true);
+		case CmdID_WritePortUlong:
+			write_nic_dword(dev, CurrentCmd->Para1,
+					CurrentCmd->Para2);
+			break;
+		case CmdID_WritePortUshort:
+			write_nic_word(dev, CurrentCmd->Para1,
+				       (u16)CurrentCmd->Para2);
+			break;
+		case CmdID_WritePortUchar:
+			write_nic_byte(dev, CurrentCmd->Para1,
+				       (u8)CurrentCmd->Para2);
+			break;
+		case CmdID_RF_WriteReg:
+			for (eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {
+				rtl8192_phy_SetRFReg(dev,
+						     (RF90_RADIO_PATH_E)eRFPath,
+						     CurrentCmd->Para1,
+						     bZebra1_ChannelNum,
+						     CurrentCmd->Para2);
+			}
+			break;
+		default:
+			break;
+		}
+
+		break;
+	} while (true);
 
 	(*delay) = CurrentCmd->msDelay;
 	(*step)++;
@@ -1336,7 +1428,8 @@ void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32	delay = 0;
 
-	while (!rtl8192_phy_SwChnlStepByStep(dev, channel, &priv->SwChnlStage, &priv->SwChnlStep, &delay)) {
+	while (!rtl8192_phy_SwChnlStepByStep(dev, channel, &priv->SwChnlStage,
+					     &priv->SwChnlStep, &delay)) {
 		if (!priv->up)
 			break;
 	}
@@ -1353,7 +1446,8 @@ void rtl8192_SwChnl_WorkItem(struct net_device *dev)
 
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
-	RT_TRACE(COMP_CH, "==> SwChnlCallback819xUsbWorkItem(), chan:%d\n", priv->chan);
+	RT_TRACE(COMP_CH, "==> SwChnlCallback819xUsbWorkItem(), chan:%d\n",
+		 priv->chan);
 
 
 	rtl8192_phy_FinishSwChnlNow(dev, priv->chan);
@@ -1372,7 +1466,8 @@ void rtl8192_SwChnl_WorkItem(struct net_device *dev)
 u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	RT_TRACE(COMP_CH, "=====>%s(), SwChnlInProgress:%d\n", __FUNCTION__, priv->SwChnlInProgress);
+	RT_TRACE(COMP_CH, "%s(), SwChnlInProgress: %d\n", __FUNCTION__,
+		 priv->SwChnlInProgress);
 	if (!priv->up)
 		return false;
 	if (priv->SwChnlInProgress)
@@ -1412,7 +1507,7 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 	priv->SwChnlStage = 0;
 	priv->SwChnlStep = 0;
 	if (priv->up)
-	rtl8192_SwChnl_WorkItem(dev);
+		rtl8192_SwChnl_WorkItem(dev);
 
 	priv->SwChnlInProgress = false;
 	return true;
@@ -1433,7 +1528,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8 regBwOpMode;
 
-	RT_TRACE(COMP_SWBW, "==>rtl8192_SetBWModeWorkItem()  Switch to %s bandwidth\n", \
+	RT_TRACE(COMP_SWBW, "%s()  Switch to %s bandwidth\n", __func__,
 		 priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz");
 
 
@@ -1446,80 +1541,93 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	read_nic_byte(dev, BW_OPMODE, &regBwOpMode);
 
 	switch (priv->CurrentChannelBW) {
-		case HT_CHANNEL_WIDTH_20:
-			regBwOpMode |= BW_OPMODE_20MHZ;
-			/* We have not verify whether this register works */
-			write_nic_byte(dev, BW_OPMODE, regBwOpMode);
-			break;
+	case HT_CHANNEL_WIDTH_20:
+		regBwOpMode |= BW_OPMODE_20MHZ;
+		/* We have not verify whether this register works */
+		write_nic_byte(dev, BW_OPMODE, regBwOpMode);
+		break;
 
-		case HT_CHANNEL_WIDTH_20_40:
-			regBwOpMode &= ~BW_OPMODE_20MHZ;
-			/* We have not verify whether this register works */
-			write_nic_byte(dev, BW_OPMODE, regBwOpMode);
-			break;
+	case HT_CHANNEL_WIDTH_20_40:
+		regBwOpMode &= ~BW_OPMODE_20MHZ;
+		/* We have not verify whether this register works */
+		write_nic_byte(dev, BW_OPMODE, regBwOpMode);
+		break;
 
-		default:
-			RT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n", priv->CurrentChannelBW);
-			break;
+	default:
+		RT_TRACE(COMP_ERR,
+			 "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n",
+			 priv->CurrentChannelBW);
+		break;
 	}
 
 	/* <2> Set PHY related register */
 	switch (priv->CurrentChannelBW) {
-		case HT_CHANNEL_WIDTH_20:
-			rtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x0);
-			rtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x0);
-			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 1);
-
-			/* Correct the tx power for CCK rate in 20M. */
-			priv->cck_present_attentuation =
-				priv->cck_present_attentuation_20Mdefault + priv->cck_present_attentuation_difference;
-
-			if (priv->cck_present_attentuation > 22)
-				priv->cck_present_attentuation = 22;
-			if (priv->cck_present_attentuation < 0)
-				priv->cck_present_attentuation = 0;
-			RT_TRACE(COMP_INIT, "20M, pHalData->CCKPresentAttentuation = %d\n", priv->cck_present_attentuation);
-
-			if (priv->chan == 14 && !priv->bcck_in_ch14) {
-				priv->bcck_in_ch14 = TRUE;
-				dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
-			} else if (priv->chan != 14 && priv->bcck_in_ch14) {
-				priv->bcck_in_ch14 = FALSE;
-				dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
-			} else {
-				dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
-			}
+	case HT_CHANNEL_WIDTH_20:
+		rtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x0);
+		rtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x0);
+		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1,
+				 0x00100000, 1);
+
+		/* Correct the tx power for CCK rate in 20M. */
+		priv->cck_present_attentuation =
+			priv->cck_present_attentuation_20Mdefault +
+			priv->cck_present_attentuation_difference;
+
+		if (priv->cck_present_attentuation > 22)
+			priv->cck_present_attentuation = 22;
+		if (priv->cck_present_attentuation < 0)
+			priv->cck_present_attentuation = 0;
+		RT_TRACE(COMP_INIT,
+			 "20M, pHalData->CCKPresentAttentuation = %d\n",
+			 priv->cck_present_attentuation);
+
+		if (priv->chan == 14 && !priv->bcck_in_ch14) {
+			priv->bcck_in_ch14 = TRUE;
+			dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
+		} else if (priv->chan != 14 && priv->bcck_in_ch14) {
+			priv->bcck_in_ch14 = FALSE;
+			dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
+		} else {
+			dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
+		}
 
-			break;
-		case HT_CHANNEL_WIDTH_20_40:
-			rtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x1);
-			rtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x1);
-			rtl8192_setBBreg(dev, rCCK0_System, bCCKSideBand, (priv->nCur40MhzPrimeSC>>1));
-			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);
-			rtl8192_setBBreg(dev, rOFDM1_LSTF, 0xC00, priv->nCur40MhzPrimeSC);
-			priv->cck_present_attentuation =
-				priv->cck_present_attentuation_40Mdefault + priv->cck_present_attentuation_difference;
-
-			if (priv->cck_present_attentuation > 22)
-				priv->cck_present_attentuation = 22;
-			if (priv->cck_present_attentuation < 0)
-				priv->cck_present_attentuation = 0;
-
-			RT_TRACE(COMP_INIT, "40M, pHalData->CCKPresentAttentuation = %d\n", priv->cck_present_attentuation);
-			if (priv->chan == 14 && !priv->bcck_in_ch14) {
-				priv->bcck_in_ch14 = true;
-				dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
-			} else if (priv->chan != 14 && priv->bcck_in_ch14) {
-				priv->bcck_in_ch14 = false;
-				dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
-			} else {
-				dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
-			}
+		break;
+	case HT_CHANNEL_WIDTH_20_40:
+		rtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x1);
+		rtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x1);
+		rtl8192_setBBreg(dev, rCCK0_System, bCCKSideBand,
+				 priv->nCur40MhzPrimeSC>>1);
+		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);
+		rtl8192_setBBreg(dev, rOFDM1_LSTF, 0xC00,
+				 priv->nCur40MhzPrimeSC);
+		priv->cck_present_attentuation =
+			priv->cck_present_attentuation_40Mdefault +
+			priv->cck_present_attentuation_difference;
+
+		if (priv->cck_present_attentuation > 22)
+			priv->cck_present_attentuation = 22;
+		if (priv->cck_present_attentuation < 0)
+			priv->cck_present_attentuation = 0;
+
+		RT_TRACE(COMP_INIT,
+			 "40M, pHalData->CCKPresentAttentuation = %d\n",
+			 priv->cck_present_attentuation);
+		if (priv->chan == 14 && !priv->bcck_in_ch14) {
+			priv->bcck_in_ch14 = true;
+			dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
+		} else if (priv->chan != 14 && priv->bcck_in_ch14) {
+			priv->bcck_in_ch14 = false;
+			dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
+		} else {
+			dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
+		}
 
-			break;
-		default:
-			RT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n", priv->CurrentChannelBW);
-			break;
+		break;
+	default:
+		RT_TRACE(COMP_ERR,
+			 "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n",
+			 priv->CurrentChannelBW);
+		break;
 
 	}
 	/* Skip over setting of J-mode in BB register here.
@@ -1527,29 +1635,30 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 
 	/* <3> Set RF related register */
 	switch (priv->rf_chip) {
-		case RF_8225:
+	case RF_8225:
 #ifdef TO_DO_LIST
-			PHY_SetRF8225Bandwidth(Adapter, pHalData->CurrentChannelBW);
+		PHY_SetRF8225Bandwidth(Adapter, pHalData->CurrentChannelBW);
 #endif
-			break;
+		break;
 
-		case RF_8256:
-			PHY_SetRF8256Bandwidth(dev, priv->CurrentChannelBW);
-			break;
+	case RF_8256:
+		PHY_SetRF8256Bandwidth(dev, priv->CurrentChannelBW);
+		break;
 
-		case RF_8258:
-			break;
+	case RF_8258:
+		break;
 
-		case RF_PSEUDO_11N:
-			break;
+	case RF_PSEUDO_11N:
+		break;
 
-		default:
-			RT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);
-			break;
+	default:
+		RT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);
+		break;
 	}
 	priv->SetBWModeInProgress = false;
 
-	RT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb(), %d", atomic_read(&(priv->ieee80211->atm_swbw)));
+	RT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb(), %d",
+		 atomic_read(&priv->ieee80211->atm_swbw));
 }
 
 /******************************************************************************
@@ -1596,9 +1705,11 @@ void InitialGain819xUsb(struct net_device *dev,	u8 Operation)
 
 extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 {
-	struct delayed_work *dwork = container_of(work, struct delayed_work, work);
-       struct r8192_priv *priv = container_of(dwork, struct r8192_priv, initialgain_operate_wq);
-       struct net_device *dev = priv->ieee80211->dev;
+	struct delayed_work *dwork = container_of(work, struct delayed_work,
+						  work);
+	struct r8192_priv *priv = container_of(dwork, struct r8192_priv,
+					       initialgain_operate_wq);
+	struct net_device *dev = priv->ieee80211->dev;
 #define SCAN_RX_INITIAL_GAIN	0x17
 #define POWER_DETECTION_TH	0x08
 	u32	bitmask;
@@ -1608,68 +1719,90 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 	Operation = priv->InitialGainOperateType;
 
 	switch (Operation) {
-		case IG_Backup:
-			RT_TRACE(COMP_SCAN, "IG_Backup, backup the initial gain.\n");
-			initial_gain = SCAN_RX_INITIAL_GAIN;
-			bitmask = bMaskByte0;
-			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
-				/* FW DIG OFF */
-				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);
-			priv->initgain_backup.xaagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XAAGCCore1, bitmask);
-			priv->initgain_backup.xbagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XBAGCCore1, bitmask);
-			priv->initgain_backup.xcagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XCAGCCore1, bitmask);
-			priv->initgain_backup.xdagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XDAGCCore1, bitmask);
-			bitmask = bMaskByte2;
-			priv->initgain_backup.cca		= (u8)rtl8192_QueryBBReg(dev, rCCK0_CCA, bitmask);
-
-			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc50 is %x\n", priv->initgain_backup.xaagccore1);
-			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc58 is %x\n", priv->initgain_backup.xbagccore1);
-			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc60 is %x\n", priv->initgain_backup.xcagccore1);
-			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc68 is %x\n", priv->initgain_backup.xdagccore1);
-			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xa0a is %x\n", priv->initgain_backup.cca);
-
-			RT_TRACE(COMP_SCAN, "Write scan initial gain = 0x%x \n", initial_gain);
-			write_nic_byte(dev, rOFDM0_XAAGCCore1, initial_gain);
-			write_nic_byte(dev, rOFDM0_XBAGCCore1, initial_gain);
-			write_nic_byte(dev, rOFDM0_XCAGCCore1, initial_gain);
-			write_nic_byte(dev, rOFDM0_XDAGCCore1, initial_gain);
-			RT_TRACE(COMP_SCAN, "Write scan 0xa0a = 0x%x \n", POWER_DETECTION_TH);
-			write_nic_byte(dev, 0xa0a, POWER_DETECTION_TH);
-			break;
-		case IG_Restore:
-			RT_TRACE(COMP_SCAN, "IG_Restore, restore the initial gain.\n");
-			bitmask = 0x7f; /* Bit0 ~ Bit6 */
-			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
-				/* FW DIG OFF */
-				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);
-
-			rtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, bitmask, (u32)priv->initgain_backup.xaagccore1);
-			rtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, bitmask, (u32)priv->initgain_backup.xbagccore1);
-			rtl8192_setBBreg(dev, rOFDM0_XCAGCCore1, bitmask, (u32)priv->initgain_backup.xcagccore1);
-			rtl8192_setBBreg(dev, rOFDM0_XDAGCCore1, bitmask, (u32)priv->initgain_backup.xdagccore1);
-			bitmask  = bMaskByte2;
-			rtl8192_setBBreg(dev, rCCK0_CCA, bitmask, (u32)priv->initgain_backup.cca);
-
-			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc50 is %x\n", priv->initgain_backup.xaagccore1);
-			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc58 is %x\n", priv->initgain_backup.xbagccore1);
-			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc60 is %x\n", priv->initgain_backup.xcagccore1);
-			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc68 is %x\n", priv->initgain_backup.xdagccore1);
-			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xa0a is %x\n", priv->initgain_backup.cca);
+	case IG_Backup:
+		RT_TRACE(COMP_SCAN, "IG_Backup, backup the initial gain.\n");
+		initial_gain = SCAN_RX_INITIAL_GAIN;
+		bitmask = bMaskByte0;
+		if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
+			/* FW DIG OFF */
+			rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);
+		priv->initgain_backup.xaagccore1 =
+			(u8)rtl8192_QueryBBReg(dev, rOFDM0_XAAGCCore1, bitmask);
+		priv->initgain_backup.xbagccore1 =
+			(u8)rtl8192_QueryBBReg(dev, rOFDM0_XBAGCCore1, bitmask);
+		priv->initgain_backup.xcagccore1 =
+			(u8)rtl8192_QueryBBReg(dev, rOFDM0_XCAGCCore1, bitmask);
+		priv->initgain_backup.xdagccore1 =
+			(u8)rtl8192_QueryBBReg(dev, rOFDM0_XDAGCCore1, bitmask);
+		bitmask = bMaskByte2;
+		priv->initgain_backup.cca =
+			(u8)rtl8192_QueryBBReg(dev, rCCK0_CCA, bitmask);
+
+		RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc50 is %x\n",
+			 priv->initgain_backup.xaagccore1);
+		RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc58 is %x\n",
+			 priv->initgain_backup.xbagccore1);
+		RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc60 is %x\n",
+			 priv->initgain_backup.xcagccore1);
+		RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc68 is %x\n",
+			 priv->initgain_backup.xdagccore1);
+		RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xa0a is %x\n",
+			 priv->initgain_backup.cca);
+
+		RT_TRACE(COMP_SCAN, "Write scan initial gain = 0x%x \n",
+			 initial_gain);
+		write_nic_byte(dev, rOFDM0_XAAGCCore1, initial_gain);
+		write_nic_byte(dev, rOFDM0_XBAGCCore1, initial_gain);
+		write_nic_byte(dev, rOFDM0_XCAGCCore1, initial_gain);
+		write_nic_byte(dev, rOFDM0_XDAGCCore1, initial_gain);
+		RT_TRACE(COMP_SCAN, "Write scan 0xa0a = 0x%x \n",
+			 POWER_DETECTION_TH);
+		write_nic_byte(dev, 0xa0a, POWER_DETECTION_TH);
+		break;
+	case IG_Restore:
+		RT_TRACE(COMP_SCAN, "IG_Restore, restore the initial gain.\n");
+		bitmask = 0x7f; /* Bit0 ~ Bit6 */
+		if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
+			/* FW DIG OFF */
+			rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);
+
+		rtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, bitmask,
+				 (u32)priv->initgain_backup.xaagccore1);
+		rtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, bitmask,
+				 (u32)priv->initgain_backup.xbagccore1);
+		rtl8192_setBBreg(dev, rOFDM0_XCAGCCore1, bitmask,
+				 (u32)priv->initgain_backup.xcagccore1);
+		rtl8192_setBBreg(dev, rOFDM0_XDAGCCore1, bitmask,
+				 (u32)priv->initgain_backup.xdagccore1);
+		bitmask  = bMaskByte2;
+		rtl8192_setBBreg(dev, rCCK0_CCA, bitmask,
+				 (u32)priv->initgain_backup.cca);
+
+		RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc50 is %x\n",
+			 priv->initgain_backup.xaagccore1);
+		RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc58 is %x\n",
+			 priv->initgain_backup.xbagccore1);
+		RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc60 is %x\n",
+			 priv->initgain_backup.xcagccore1);
+		RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc68 is %x\n",
+			 priv->initgain_backup.xdagccore1);
+		RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xa0a is %x\n",
+			 priv->initgain_backup.cca);
 
 #ifdef RTL8190P
-			SetTxPowerLevel8190(Adapter, priv->CurrentChannel);
+		SetTxPowerLevel8190(Adapter, priv->CurrentChannel);
 #endif
 #ifdef RTL8192E
-			SetTxPowerLevel8190(Adapter, priv->CurrentChannel);
+		SetTxPowerLevel8190(Adapter, priv->CurrentChannel);
 #endif
-			rtl8192_phy_setTxPower(dev, priv->ieee80211->current_network.channel);
+		rtl8192_phy_setTxPower(dev, priv->ieee80211->current_network.channel);
 
-			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
-				/* FW DIG ON */
-				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);
-			break;
-		default:
-			RT_TRACE(COMP_SCAN, "Unknown IG Operation. \n");
-			break;
+		if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
+			/* FW DIG ON */
+			rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);
+		break;
+	default:
+		RT_TRACE(COMP_SCAN, "Unknown IG Operation. \n");
+		break;
 	}
 }

commit 5f2392b865fb3418e6d9de2cea15d64932b49fcb
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Wed Jun 19 04:58:07 2013 +0300

    staging: rtl8192u: fix comments in r819xU_phy.c
    
    This patch fixes the comments in r819xU_phy.c by:
    - replacing "// ..." with "/* .... */"
    - removing unnecessary comments, the dates and names of
      developers from comments
    - fixing some inconsistent comments
    - fixing some typos
    - fixing alignment issues
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 9bfcd2f451f7..627165a33620 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -11,20 +11,20 @@
 
 static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 	0,
-	0x085c, //2412 1
-	0x08dc, //2417 2
-	0x095c, //2422 3
-	0x09dc, //2427 4
-	0x0a5c, //2432 5
-	0x0adc, //2437 6
-	0x0b5c, //2442 7
-	0x0bdc, //2447 8
-	0x0c5c, //2452 9
-	0x0cdc, //2457 10
-	0x0d5c, //2462 11
-	0x0ddc, //2467 12
-	0x0e5c, //2472 13
-	0x0f72, //2484
+	0x085c, /* 2412 1  */
+	0x08dc, /* 2417 2  */
+	0x095c, /* 2422 3  */
+	0x09dc, /* 2427 4  */
+	0x0a5c, /* 2432 5  */
+	0x0adc, /* 2437 6  */
+	0x0b5c, /* 2442 7  */
+	0x0bdc, /* 2447 8  */
+	0x0c5c, /* 2452 9  */
+	0x0cdc, /* 2457 10 */
+	0x0d5c, /* 2462 11 */
+	0x0ddc, /* 2467 12 */
+	0x0e5c, /* 2472 13 */
+	0x0f72, /* 2484    */
 };
 
 
@@ -38,12 +38,12 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 #define rtl819XAGCTAB_Array Rtl8192UsbAGCTAB_Array
 
 /******************************************************************************
- *function:  This function read BB parameters from Header file we gen,
- *	     and do register read/write
- *   input:  u32	bitmask  //taget bit pos in the addr to be modified
- *  output:  none
- *  return:  u32	return the shift bit position of the mask
- * ****************************************************************************/
+ * function: This function reads BB parameters from header file we generate,
+ *           and does register read/write
+ * input:    u32	bitmask  //taget bit pos in the addr to be modified
+ * output:   none
+ * return:   u32	return the shift bit position of the mask
+ ******************************************************************************/
 u32 rtl8192_CalculateBitShift(u32 bitmask)
 {
 	u32 i;
@@ -51,11 +51,13 @@ u32 rtl8192_CalculateBitShift(u32 bitmask)
 	return i;
 }
 /******************************************************************************
- *function:  This function check different RF type to execute legal judgement. If RF Path is illegal, we will return false.
- *   input:  none
- *  output:  none
- *  return:  0(illegal, false), 1(legal,true)
- * ***************************************************************************/
+ * function:  This function checks different RF type to execute legal judgement.
+ *            If RF Path is illegal, we will return false.
+ * input:     net_device	 *dev
+ *            u32		 eRFPath
+ * output:    none
+ * return:    0(illegal, false), 1(legal, true)
+ *****************************************************************************/
 u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 eRFPath)
 {
 	u8 ret = 1;
@@ -71,22 +73,22 @@ u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 eRFPath)
 	return ret;
 }
 /******************************************************************************
- *function:  This function set specific bits to BB register
- *   input:  net_device dev
- *           u32	reg_addr   //target addr to be modified
- *           u32	bitmask    //taget bit pos in the addr to be modified
- *           u32	data       //value to be write
- *  output:  none
- *  return:  none
- *  notice:
- * ****************************************************************************/
+ * function:  This function sets specific bits to BB register
+ * input:     net_device *dev
+ *            u32        reg_addr   //target addr to be modified
+ *            u32        bitmask    //taget bit pos to be modified
+ *            u32        data       //value to be write
+ * output:    none
+ * return:    none
+ * notice:
+ ******************************************************************************/
 void rtl8192_setBBreg(struct net_device *dev, u32 reg_addr, u32 bitmask,
 		      u32 data)
 {
 
 	u32 reg, bitshift;
 
-	if (bitmask != bMaskDWord) { //if not "double word" write
+	if (bitmask != bMaskDWord) {
 		read_nic_dword(dev, reg_addr, &reg);
 		bitshift = rtl8192_CalculateBitShift(bitmask);
 		reg &= ~bitmask;
@@ -98,14 +100,14 @@ void rtl8192_setBBreg(struct net_device *dev, u32 reg_addr, u32 bitmask,
 	return;
 }
 /******************************************************************************
- *function:  This function reads specific bits from BB register
- *   input:  net_device dev
- *           u32	reg_addr   //target addr to be readback
- *           u32	bitmask    //taget bit pos in the addr to be readback
- *  output:  none
- *  return:  u32	data       //the readback register value
- *  notice:
- * ****************************************************************************/
+ * function:  This function reads specific bits from BB register
+ * input:     net_device	*dev
+ *            u32	 	reg_addr   //target addr to be readback
+ *            u32	 	bitmask    //taget bit pos to be readback
+ * output:    none
+ * return:    u32	 	data       //the readback register value
+ * notice:
+ ******************************************************************************/
 u32 rtl8192_QueryBBReg(struct net_device *dev, u32 reg_addr, u32 bitmask)
 {
 	u32 reg, bitshift;
@@ -123,14 +125,19 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
 				u32  data);
 
 /******************************************************************************
- *function:  This function read register from RF chip
- *   input:  net_device dev
- *	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
- *           u32	offset     //target address to be read
- *  output:  none
- *  return:  u32	readback value
- *  notice:  There are three types of serial operations:(1) Software serial write.(2)Hardware LSSI-Low Speed Serial Interface.(3)Hardware HSSI-High speed serial write. Driver here need to implement (1) and (2)---need more spec for this information.
- * ****************************************************************************/
+ * function:  This function reads register from RF chip
+ * input:     net_device        *dev
+ *            RF90_RADIO_PATH_E eRFPath    //radio path of A/B/C/D
+ *            u32               offset     //target address to be read
+ * output:    none
+ * return:    u32               readback value
+ * notice:    There are three types of serial operations:
+ *            (1) Software serial write.
+ *            (2)Hardware LSSI-Low Speed Serial Interface.
+ *            (3)Hardware HSSI-High speed serial write.
+ *            Driver here need to implement (1) and (2)
+ *            ---need more spec for this information.
+ ******************************************************************************/
 u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 			     u32 offset)
 {
@@ -139,21 +146,21 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	u32 new_offset = 0;
 	BB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[eRFPath];
 	rtl8192_setBBreg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData, 0);
-	//make sure RF register offset is correct
+	/* Make sure RF register offset is correct */
 	offset &= 0x3f;
 
-	//switch page for 8256 RF IC
+	/* Switch page for 8256 RF IC */
 	if (priv->rf_chip == RF_8256) {
 		if (offset >= 31) {
 			priv->RfReg0Value[eRFPath] |= 0x140;
-			//Switch to Reg_Mode2 for Reg 31-45
+			/* Switch to Reg_Mode2 for Reg 31-45 */
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));
-			//modify offset
+			/* Modify offset */
 			new_offset = offset - 30;
 		} else if (offset >= 16) {
 			priv->RfReg0Value[eRFPath] |= 0x100;
 			priv->RfReg0Value[eRFPath] &= (~0x40);
-			//Switch to Reg_Mode 1 for Reg16-30
+			/* Switch to Reg_Mode1 for Reg16-30 */
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));
 
 			new_offset = offset - 15;
@@ -164,21 +171,20 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 		RT_TRACE((COMP_PHY|COMP_ERR), "check RF type here, need to be 8256\n");
 		new_offset = offset;
 	}
-	//put desired read addr to LSSI control Register
+	/* Put desired read addr to LSSI control Register */
 	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadAddress, new_offset);
-	//Issue a posedge trigger
-	//
+	/* Issue a posedge trigger */
 	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x0);
 	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x1);
 
 
-	// TODO: we should not delay such a long time. Ask for help from SD3
+	/* TODO: we should not delay such a long time. Ask for help from SD3 */
 	msleep(1);
 
 	ret = rtl8192_QueryBBReg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData);
 
 
-	// Switch back to Reg_Mode0;
+	/* Switch back to Reg_Mode0 */
 	if (priv->rf_chip == RF_8256) {
 		priv->RfReg0Value[eRFPath] &= 0xebf;
 
@@ -194,25 +200,25 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 }
 
 /******************************************************************************
- *function:  This function write data to RF register
- *   input:  net_device dev
- *	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
- *           u32	offset     //target address to be written
- *           u32	data	   //The new register data to be written
- *  output:  none
- *  return:  none
- *  notice:  For RF8256 only.
-  ===========================================================
- *Reg Mode	RegCTL[1]	RegCTL[0]		Note
+ * function:  This function writes data to RF register
+ * input:     net_device        *dev
+ *            RF90_RADIO_PATH_E eRFPath  //radio path of A/B/C/D
+ *            u32               offset   //target address to be written
+ *            u32               data	 //the new register data to be written
+ * output:    none
+ * return:    none
+ * notice:    For RF8256 only.
+ * ===========================================================================
+ * Reg Mode	RegCTL[1]	RegCTL[0]		Note
  *		(Reg00[12])	(Reg00[10])
- *===========================================================
- *Reg_Mode0	0		x			Reg 0 ~15(0x0 ~ 0xf)
- *------------------------------------------------------------------
- *Reg_Mode1	1		0			Reg 16 ~30(0x1 ~ 0xf)
- *------------------------------------------------------------------
+ * ===========================================================================
+ * Reg_Mode0	0		x			Reg 0 ~ 15(0x0 ~ 0xf)
+ * ---------------------------------------------------------------------------
+ * Reg_Mode1	1		0			Reg 16 ~ 30(0x1 ~ 0xf)
+ * ---------------------------------------------------------------------------
  * Reg_Mode2	1		1			Reg 31 ~ 45(0x1 ~ 0xf)
- *------------------------------------------------------------------
- * ****************************************************************************/
+ * ---------------------------------------------------------------------------
+ *****************************************************************************/
 void rtl8192_phy_RFSerialWrite(struct net_device *dev,
 			       RF90_RADIO_PATH_E eRFPath, u32 offset, u32 data)
 {
@@ -240,17 +246,17 @@ void rtl8192_phy_RFSerialWrite(struct net_device *dev,
 		new_offset = offset;
 	}
 
-	// Put write addr in [5:0] and write data in [31:16]
+	/* Put write addr in [5:0] and write data in [31:16] */
 	DataAndAddr = (data<<16) | (new_offset&0x3f);
 
-	// Write Operation
+	/* Write operation */
 	rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);
 
 
 	if (offset == 0x0)
 		priv->RfReg0Value[eRFPath] = data;
 
-	// Switch back to Reg_Mode0;
+	/* Switch back to Reg_Mode0 */
 	if (priv->rf_chip == RF_8256) {
 		if (offset != 0) {
 			priv->RfReg0Value[eRFPath] &= 0xebf;
@@ -265,16 +271,16 @@ void rtl8192_phy_RFSerialWrite(struct net_device *dev,
 }
 
 /******************************************************************************
- *function:  This function set specific bits to RF register
- *   input:  net_device dev
- *	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
- *           u32	reg_addr //target addr to be modified
- *           u32	bitmask  //taget bit pos in the addr to be modified
- *           u32	data     //value to be write
- *  output:  none
- *  return:  none
- *  notice:
- * ****************************************************************************/
+ * function:  This function set specific bits to RF register
+ * input:     net_device        dev
+ *            RF90_RADIO_PATH_E eRFPath  //radio path of A/B/C/D
+ *            u32               reg_addr //target addr to be modified
+ *            u32               bitmask  //taget bit pos to be modified
+ *            u32               data     //value to be written
+ * output:    none
+ * return:    none
+ * notice:
+ *****************************************************************************/
 void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 			  u32 reg_addr, u32 bitmask, u32 data)
 {
@@ -285,7 +291,8 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 		return;
 
 	if (priv->Rf_Mode == RF_OP_By_FW) {
-		if (bitmask != bMask12Bits) { // RF data is 12 bits only
+		if (bitmask != bMask12Bits) {
+			/* RF data is 12 bits only */
 			reg = phy_FwRFSerialRead(dev, eRFPath, reg_addr);
 			bitshift =  rtl8192_CalculateBitShift(bitmask);
 			reg &= ~bitmask;
@@ -299,7 +306,8 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 		udelay(200);
 
 	} else {
-		if (bitmask != bMask12Bits) { // RF data is 12 bits only
+		if (bitmask != bMask12Bits) {
+			/* RF data is 12 bits only */
 			reg = rtl8192_phy_RFSerialRead(dev, eRFPath, reg_addr);
 			bitshift =  rtl8192_CalculateBitShift(bitmask);
 			reg &= ~bitmask;
@@ -314,14 +322,14 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 }
 
 /******************************************************************************
- *function:  This function reads specific bits from RF register
- *   input:  net_device dev
- *           u32	reg_addr //target addr to be readback
- *           u32	bitmask  //taget bit pos in the addr to be readback
- *  output:  none
- *  return:  u32	data	//the readback register value
- *  notice:
- * ****************************************************************************/
+ * function:  This function reads specific bits from RF register
+ * input:     net_device        *dev
+ *            u32               reg_addr //target addr to be readback
+ *            u32               bitmask  //taget bit pos to be readback
+ * output:    none
+ * return:    u32               data     //the readback register value
+ * notice:
+ *****************************************************************************/
 u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 			   u32 reg_addr, u32 bitmask)
 {
@@ -345,12 +353,14 @@ u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	}
 }
 /******************************************************************************
- *function:  We support firmware to execute RF-R/W.
- *   input:  dev
- *  output:  none
- *  return:  none
- *  notice:
- * ***************************************************************************/
+ * function:  We support firmware to execute RF-R/W.
+ * input:     net_device        *dev
+ *            RF90_RADIO_PATH_E eRFPath
+ *            u32               offset
+ * output:    none
+ * return:    u32
+ * notice:
+ ****************************************************************************/
 static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 			      u32 offset)
 {
@@ -358,21 +368,23 @@ static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	u32		data = 0;
 	u8		time = 0;
 	u32		tmp;
-	/* 2007/11/02 MH Firmware RF Write control. By Francis' suggestion, we can
-	   not execute the scheme in the initial step. Otherwise, RF-R/W will waste
-	   much time. This is only for site survey. */
-	// 1. Read operation need not insert data. bit 0-11
-	// 2. Write RF register address. Bit 12-19
+	/* Firmware RF Write control.
+	 * We can not execute the scheme in the initial step.
+	 * Otherwise, RF-R/W will waste much time.
+	 * This is only for site survey. */
+	/* 1. Read operation need not insert data. bit 0-11 */
+	/* 2. Write RF register address. bit 12-19 */
 	data |= ((offset&0xFF)<<12);
-	// 3. Write RF path.  bit 20-21
+	/* 3. Write RF path.  bit 20-21 */
 	data |= ((eRFPath&0x3)<<20);
-	// 4. Set RF read indicator. bit 22=0
-	// 5. Trigger Fw to operate the command. bit 31
+	/* 4. Set RF read indicator. bit 22=0 */
+	/* 5. Trigger Fw to operate the command. bit 31 */
 	data |= 0x80000000;
-	// 6. We can not execute read operation if bit 31 is 1.
+	/* 6. We can not execute read operation if bit 31 is 1. */
 	read_nic_dword(dev, QPNR, &tmp);
 	while (tmp & 0x80000000) {
-		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
+		/* If FW can not finish RF-R/W for more than ?? times.
+		   We must reset FW. */
 		if (time++ < 100) {
 			udelay(10);
 			read_nic_dword(dev, QPNR, &tmp);
@@ -380,12 +392,13 @@ static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 			break;
 		}
 	}
-	// 7. Execute read operation.
+	/* 7. Execute read operation. */
 	write_nic_dword(dev, QPNR, data);
-	// 8. Check if firmawre send back RF content.
+	/* 8. Check if firmware send back RF content. */
 	read_nic_dword(dev, QPNR, &tmp);
 	while (tmp & 0x80000000) {
-		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
+		/* If FW can not finish RF-R/W for more than ?? times.
+		   We must reset FW. */
 		if (time++ < 100) {
 			udelay(10);
 			read_nic_dword(dev, QPNR, &tmp);
@@ -397,39 +410,44 @@ static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 
 	return reg;
 
-}	/* phy_FwRFSerialRead */
+}
 
 /******************************************************************************
- *function:  We support firmware to execute RF-R/W.
- *   input:  dev
- *  output:  none
- *  return:  none
- *  notice:
- * ***************************************************************************/
+ * function:  We support firmware to execute RF-R/W.
+ * input:     net_device        *dev
+ *            RF90_RADIO_PATH_E eRFPath
+ *            u32               offset
+ *            u32               data
+ * output:    none
+ * return:    none
+ * notice:
+ ****************************************************************************/
 static void phy_FwRFSerialWrite(struct net_device *dev,
 				RF90_RADIO_PATH_E eRFPath, u32 offset, u32 data)
 {
 	u8	time = 0;
 	u32	tmp;
 
-	/* 2007/11/02 MH Firmware RF Write control. By Francis' suggestion, we can
-	   not execute the scheme in the initial step. Otherwise, RF-R/W will waste
-	   much time. This is only for site survey. */
+	/* Firmware RF Write control.
+	 * We can not execute the scheme in the initial step.
+	 * Otherwise, RF-R/W will waste much time.
+	 * This is only for site survey. */
 
-	// 1. Set driver write bit and 12 bit data. bit 0-11
-	// 2. Write RF register address. bit 12-19
+	/* 1. Set driver write bit and 12 bit data. bit 0-11 */
+	/* 2. Write RF register address. bit 12-19 */
 	data |= ((offset&0xFF)<<12);
-	// 3. Write RF path.  bit 20-21
+	/* 3. Write RF path.  bit 20-21 */
 	data |= ((eRFPath&0x3)<<20);
-	// 4. Set RF write indicator. bit 22=1
+	/* 4. Set RF write indicator. bit 22=1 */
 	data |= 0x400000;
-	// 5. Trigger Fw to operate the command. bit 31=1
+	/* 5. Trigger Fw to operate the command. bit 31=1 */
 	data |= 0x80000000;
 
-	// 6. Write operation. We can not write if bit 31 is 1.
+	/* 6. Write operation. We can not write if bit 31 is 1. */
 	read_nic_dword(dev, QPNR, &tmp);
 	while (tmp & 0x80000000) {
-		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
+		/* If FW can not finish RF-R/W for more than ?? times.
+		   We must reset FW. */
 		if (time++ < 100) {
 			udelay(10);
 			read_nic_dword(dev, QPNR, &tmp);
@@ -437,25 +455,25 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
 			break;
 		}
 	}
-	// 7. No matter check bit. We always force the write. Because FW will
-	//    not accept the command.
+	/* 7. No matter check bit. We always force the write.
+	   Because FW will not accept the command. */
 	write_nic_dword(dev, QPNR, data);
-	/* 2007/11/02 MH Acoording to test, we must delay 20us to wait firmware
+	/* According to test, we must delay 20us to wait firmware
 	   to finish RF write operation. */
-	/* 2008/01/17 MH We support delay in firmware side now. */
+	/* We support delay in firmware side now. */
 
-}	/* phy_FwRFSerialWrite */
+}
 
 
 /******************************************************************************
- *function:  This function read BB parameters from Header file we gen,
- *	     and do register read/write
- *   input:  dev
- *  output:  none
- *  return:  none
- *  notice:  BB parameters may change all the time, so please make
- *           sure it has been synced with the newest.
- * ***************************************************************************/
+ * function:  This function reads BB parameters from header file we generate,
+ *            and do register read/write
+ * input:     net_device 	*dev
+ * output:    none
+ * return:    none
+ * notice:    BB parameters may change all the time, so please make
+ *            sure it has been synced with the newest.
+ *****************************************************************************/
 void rtl8192_phy_configmac(struct net_device *dev)
 {
 	u32 dwArrayLen = 0, i;
@@ -486,13 +504,14 @@ void rtl8192_phy_configmac(struct net_device *dev)
 }
 
 /******************************************************************************
- *function:  This function does dirty work
- *   input:  dev
- *  output:  none
- *  return:  none
- *  notice:  BB parameters may change all the time, so please make
- *           sure it has been synced with the newest.
- * ***************************************************************************/
+ * function:  This function does dirty work
+ * input:     net_device	*dev
+ *            u8                ConfigType
+ * output:    none
+ * return:    none
+ * notice:    BB parameters may change all the time, so please make
+ *            sure it has been synced with the newest.
+ *****************************************************************************/
 
 void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 {
@@ -523,113 +542,134 @@ void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 
 }
 /******************************************************************************
- *function:  This function initialize Register definition offset for Radio Path
- *	     A/B/C/D
- *   input:  net_device dev
- *  output:  none
- *  return:  none
- *  notice:  Initialization value here is constant and it should never be changed
- * ***************************************************************************/
+ * function:  This function initializes Register definition offset for
+ *            Radio Path A/B/C/D
+ * input:     net_device	*dev
+ * output:    none
+ * return:    none
+ * notice:    Initialization value here is constant and it should never
+ *            be changed
+ *****************************************************************************/
 void rtl8192_InitBBRFRegDef(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-// RF Interface Software Control
-	priv->PHYRegDef[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW; // 16 LSBs if read 32-bit from 0x870
-	priv->PHYRegDef[RF90_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW; // 16 MSBs if read 32-bit from 0x870 (16-bit for 0x872)
-	priv->PHYRegDef[RF90_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;// 16 LSBs if read 32-bit from 0x874
-	priv->PHYRegDef[RF90_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;// 16 MSBs if read 32-bit from 0x874 (16-bit for 0x876)
-
-	// RF Interface Readback Value
-	priv->PHYRegDef[RF90_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB; // 16 LSBs if read 32-bit from 0x8E0
-	priv->PHYRegDef[RF90_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;// 16 MSBs if read 32-bit from 0x8E0 (16-bit for 0x8E2)
-	priv->PHYRegDef[RF90_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;// 16 LSBs if read 32-bit from 0x8E4
-	priv->PHYRegDef[RF90_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;// 16 MSBs if read 32-bit from 0x8E4 (16-bit for 0x8E6)
-
-	// RF Interface Output (and Enable)
-	priv->PHYRegDef[RF90_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE; // 16 LSBs if read 32-bit from 0x860
-	priv->PHYRegDef[RF90_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE; // 16 LSBs if read 32-bit from 0x864
-	priv->PHYRegDef[RF90_PATH_C].rfintfo = rFPGA0_XC_RFInterfaceOE;// 16 LSBs if read 32-bit from 0x868
-	priv->PHYRegDef[RF90_PATH_D].rfintfo = rFPGA0_XD_RFInterfaceOE;// 16 LSBs if read 32-bit from 0x86C
-
-	// RF Interface (Output and)  Enable
-	priv->PHYRegDef[RF90_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE; // 16 MSBs if read 32-bit from 0x860 (16-bit for 0x862)
-	priv->PHYRegDef[RF90_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE; // 16 MSBs if read 32-bit from 0x864 (16-bit for 0x866)
-	priv->PHYRegDef[RF90_PATH_C].rfintfe = rFPGA0_XC_RFInterfaceOE;// 16 MSBs if read 32-bit from 0x86A (16-bit for 0x86A)
-	priv->PHYRegDef[RF90_PATH_D].rfintfe = rFPGA0_XD_RFInterfaceOE;// 16 MSBs if read 32-bit from 0x86C (16-bit for 0x86E)
-
-	//Addr of LSSI. Write RF register by driver
-	priv->PHYRegDef[RF90_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter; //LSSI Parameter
+	/* RF Interface Software Control */
+	/* 16 LSBs if read 32-bit from 0x870 */
+	priv->PHYRegDef[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW;
+	/* 16 MSBs if read 32-bit from 0x870 (16-bit for 0x872) */
+	priv->PHYRegDef[RF90_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW;
+	/* 16 LSBs if read 32-bit from 0x874 */
+	priv->PHYRegDef[RF90_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;
+	/* 16 MSBs if read 32-bit from 0x874 (16-bit for 0x876) */
+	priv->PHYRegDef[RF90_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;
+
+	/* RF Interface Readback Value */
+	/* 16 LSBs if read 32-bit from 0x8E0 */
+	priv->PHYRegDef[RF90_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB;
+	/* 16 MSBs if read 32-bit from 0x8E0 (16-bit for 0x8E2) */
+	priv->PHYRegDef[RF90_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;
+	/* 16 LSBs if read 32-bit from 0x8E4 */
+	priv->PHYRegDef[RF90_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;
+	/* 16 MSBs if read 32-bit from 0x8E4 (16-bit for 0x8E6) */
+	priv->PHYRegDef[RF90_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;
+
+	/* RF Interface Output (and Enable) */
+	/* 16 LSBs if read 32-bit from 0x860 */
+	priv->PHYRegDef[RF90_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE;
+	/* 16 LSBs if read 32-bit from 0x864 */
+	priv->PHYRegDef[RF90_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE;
+	/* 16 LSBs if read 32-bit from 0x868 */
+	priv->PHYRegDef[RF90_PATH_C].rfintfo = rFPGA0_XC_RFInterfaceOE;
+	/* 16 LSBs if read 32-bit from 0x86C */
+	priv->PHYRegDef[RF90_PATH_D].rfintfo = rFPGA0_XD_RFInterfaceOE;
+
+	/* RF Interface (Output and) Enable */
+	/* 16 MSBs if read 32-bit from 0x860 (16-bit for 0x862) */
+	priv->PHYRegDef[RF90_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE;
+	/* 16 MSBs if read 32-bit from 0x864 (16-bit for 0x866) */
+	priv->PHYRegDef[RF90_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE;
+	/* 16 MSBs if read 32-bit from 0x86A (16-bit for 0x86A) */
+	priv->PHYRegDef[RF90_PATH_C].rfintfe = rFPGA0_XC_RFInterfaceOE;
+	/* 16 MSBs if read 32-bit from 0x86C (16-bit for 0x86E) */
+	priv->PHYRegDef[RF90_PATH_D].rfintfe = rFPGA0_XD_RFInterfaceOE;
+
+	/* Addr of LSSI. Write RF register by driver */
+	priv->PHYRegDef[RF90_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter;
 	priv->PHYRegDef[RF90_PATH_B].rf3wireOffset = rFPGA0_XB_LSSIParameter;
 	priv->PHYRegDef[RF90_PATH_C].rf3wireOffset = rFPGA0_XC_LSSIParameter;
 	priv->PHYRegDef[RF90_PATH_D].rf3wireOffset = rFPGA0_XD_LSSIParameter;
 
-	// RF parameter
-	priv->PHYRegDef[RF90_PATH_A].rfLSSI_Select = rFPGA0_XAB_RFParameter;  //BB Band Select
+	/* RF parameter */
+	/* BB Band Select */
+	priv->PHYRegDef[RF90_PATH_A].rfLSSI_Select = rFPGA0_XAB_RFParameter;
 	priv->PHYRegDef[RF90_PATH_B].rfLSSI_Select = rFPGA0_XAB_RFParameter;
 	priv->PHYRegDef[RF90_PATH_C].rfLSSI_Select = rFPGA0_XCD_RFParameter;
 	priv->PHYRegDef[RF90_PATH_D].rfLSSI_Select = rFPGA0_XCD_RFParameter;
 
-	// Tx AGC Gain Stage (same for all path. Should we remove this?)
-	priv->PHYRegDef[RF90_PATH_A].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
-	priv->PHYRegDef[RF90_PATH_B].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
-	priv->PHYRegDef[RF90_PATH_C].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
-	priv->PHYRegDef[RF90_PATH_D].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
-
-	// Tranceiver A~D HSSI Parameter-1
-	priv->PHYRegDef[RF90_PATH_A].rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;  //wire control parameter1
-	priv->PHYRegDef[RF90_PATH_B].rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;  //wire control parameter1
-	priv->PHYRegDef[RF90_PATH_C].rfHSSIPara1 = rFPGA0_XC_HSSIParameter1;  //wire control parameter1
-	priv->PHYRegDef[RF90_PATH_D].rfHSSIPara1 = rFPGA0_XD_HSSIParameter1;  //wire control parameter1
-
-	// Tranceiver A~D HSSI Parameter-2
-	priv->PHYRegDef[RF90_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;  //wire control parameter2
-	priv->PHYRegDef[RF90_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;  //wire control parameter2
-	priv->PHYRegDef[RF90_PATH_C].rfHSSIPara2 = rFPGA0_XC_HSSIParameter2;  //wire control parameter2
-	priv->PHYRegDef[RF90_PATH_D].rfHSSIPara2 = rFPGA0_XD_HSSIParameter2;  //wire control parameter1
-
-	// RF switch Control
-	priv->PHYRegDef[RF90_PATH_A].rfSwitchControl = rFPGA0_XAB_SwitchControl; //TR/Ant switch control
+	/* Tx AGC Gain Stage (same for all path. Should we remove this?) */
+	priv->PHYRegDef[RF90_PATH_A].rfTxGainStage = rFPGA0_TxGainStage;
+	priv->PHYRegDef[RF90_PATH_B].rfTxGainStage = rFPGA0_TxGainStage;
+	priv->PHYRegDef[RF90_PATH_C].rfTxGainStage = rFPGA0_TxGainStage;
+	priv->PHYRegDef[RF90_PATH_D].rfTxGainStage = rFPGA0_TxGainStage;
+
+	/* Tranceiver A~D HSSI Parameter-1 */
+	/* wire control parameter1 */
+	priv->PHYRegDef[RF90_PATH_A].rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;
+	priv->PHYRegDef[RF90_PATH_B].rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;
+	priv->PHYRegDef[RF90_PATH_C].rfHSSIPara1 = rFPGA0_XC_HSSIParameter1;
+	priv->PHYRegDef[RF90_PATH_D].rfHSSIPara1 = rFPGA0_XD_HSSIParameter1;
+
+	/* Tranceiver A~D HSSI Parameter-2 */
+	/* wire control parameter2 */
+	priv->PHYRegDef[RF90_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;
+	priv->PHYRegDef[RF90_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;
+	priv->PHYRegDef[RF90_PATH_C].rfHSSIPara2 = rFPGA0_XC_HSSIParameter2;
+	priv->PHYRegDef[RF90_PATH_D].rfHSSIPara2 = rFPGA0_XD_HSSIParameter2;
+
+	/* RF Switch Control */
+	/* TR/Ant switch control */
+	priv->PHYRegDef[RF90_PATH_A].rfSwitchControl = rFPGA0_XAB_SwitchControl;
 	priv->PHYRegDef[RF90_PATH_B].rfSwitchControl = rFPGA0_XAB_SwitchControl;
 	priv->PHYRegDef[RF90_PATH_C].rfSwitchControl = rFPGA0_XCD_SwitchControl;
 	priv->PHYRegDef[RF90_PATH_D].rfSwitchControl = rFPGA0_XCD_SwitchControl;
 
-	// AGC control 1
+	/* AGC control 1 */
 	priv->PHYRegDef[RF90_PATH_A].rfAGCControl1 = rOFDM0_XAAGCCore1;
 	priv->PHYRegDef[RF90_PATH_B].rfAGCControl1 = rOFDM0_XBAGCCore1;
 	priv->PHYRegDef[RF90_PATH_C].rfAGCControl1 = rOFDM0_XCAGCCore1;
 	priv->PHYRegDef[RF90_PATH_D].rfAGCControl1 = rOFDM0_XDAGCCore1;
 
-	// AGC control 2
+	/* AGC control 2 */
 	priv->PHYRegDef[RF90_PATH_A].rfAGCControl2 = rOFDM0_XAAGCCore2;
 	priv->PHYRegDef[RF90_PATH_B].rfAGCControl2 = rOFDM0_XBAGCCore2;
 	priv->PHYRegDef[RF90_PATH_C].rfAGCControl2 = rOFDM0_XCAGCCore2;
 	priv->PHYRegDef[RF90_PATH_D].rfAGCControl2 = rOFDM0_XDAGCCore2;
 
-	// RX AFE control 1
+	/* RX AFE control 1 */
 	priv->PHYRegDef[RF90_PATH_A].rfRxIQImbalance = rOFDM0_XARxIQImbalance;
 	priv->PHYRegDef[RF90_PATH_B].rfRxIQImbalance = rOFDM0_XBRxIQImbalance;
 	priv->PHYRegDef[RF90_PATH_C].rfRxIQImbalance = rOFDM0_XCRxIQImbalance;
 	priv->PHYRegDef[RF90_PATH_D].rfRxIQImbalance = rOFDM0_XDRxIQImbalance;
 
-	// RX AFE control 1
+	/* RX AFE control 1 */
 	priv->PHYRegDef[RF90_PATH_A].rfRxAFE = rOFDM0_XARxAFE;
 	priv->PHYRegDef[RF90_PATH_B].rfRxAFE = rOFDM0_XBRxAFE;
 	priv->PHYRegDef[RF90_PATH_C].rfRxAFE = rOFDM0_XCRxAFE;
 	priv->PHYRegDef[RF90_PATH_D].rfRxAFE = rOFDM0_XDRxAFE;
 
-	// Tx AFE control 1
+	/* Tx AFE control 1 */
 	priv->PHYRegDef[RF90_PATH_A].rfTxIQImbalance = rOFDM0_XATxIQImbalance;
 	priv->PHYRegDef[RF90_PATH_B].rfTxIQImbalance = rOFDM0_XBTxIQImbalance;
 	priv->PHYRegDef[RF90_PATH_C].rfTxIQImbalance = rOFDM0_XCTxIQImbalance;
 	priv->PHYRegDef[RF90_PATH_D].rfTxIQImbalance = rOFDM0_XDTxIQImbalance;
 
-	// Tx AFE control 2
+	/* Tx AFE control 2 */
 	priv->PHYRegDef[RF90_PATH_A].rfTxAFE = rOFDM0_XATxAFE;
 	priv->PHYRegDef[RF90_PATH_B].rfTxAFE = rOFDM0_XBTxAFE;
 	priv->PHYRegDef[RF90_PATH_C].rfTxAFE = rOFDM0_XCTxAFE;
 	priv->PHYRegDef[RF90_PATH_D].rfTxAFE = rOFDM0_XDTxAFE;
 
-	// Tranceiver LSSI Readback
+	/* Tranceiver LSSI Readback */
 	priv->PHYRegDef[RF90_PATH_A].rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;
 	priv->PHYRegDef[RF90_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;
 	priv->PHYRegDef[RF90_PATH_C].rfLSSIReadBack = rFPGA0_XC_LSSIReadBack;
@@ -637,14 +677,16 @@ void rtl8192_InitBBRFRegDef(struct net_device *dev)
 
 }
 /******************************************************************************
- *function:  This function is to write register and then readback to make sure whether BB and RF is OK
- *   input:  net_device dev
- *	     HW90_BLOCK_E CheckBlock
- *	     RF90_RADIO_PATH_E eRFPath  //only used when checkblock is HW90_BLOCK_RF
- *  output:  none
- *  return:  return whether BB and RF is ok(0:OK; 1:Fail)
- *  notice:  This function may be removed in the ASIC
- * ***************************************************************************/
+ * function:  This function is to write register and then readback to make
+ *            sure whether BB and RF is OK
+ * input:     net_device        *dev
+ *            HW90_BLOCK_E      CheckBlock
+ *            RF90_RADIO_PATH_E eRFPath  //only used when checkblock is
+ *                                       //HW90_BLOCK_RF
+ * output:    none
+ * return:    return whether BB and RF is ok (0:OK, 1:Fail)
+ * notice:    This function may be removed in the ASIC
+ ******************************************************************************/
 u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 			    RF90_RADIO_PATH_E eRFPath)
 {
@@ -652,7 +694,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 	u32 i, CheckTimes = 4, dwRegRead = 0;
 	u32 WriteAddr[4];
 	u32 WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};
-	// Initialize register address offset to be checked
+	/* Initialize register address offset to be checked */
 	WriteAddr[HW90_BLOCK_MAC] = 0x100;
 	WriteAddr[HW90_BLOCK_PHY0] = 0x900;
 	WriteAddr[HW90_BLOCK_PHY1] = 0x800;
@@ -660,9 +702,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 	RT_TRACE(COMP_PHY, "=======>%s(), CheckBlock:%d\n", __FUNCTION__, CheckBlock);
 	for (i = 0; i < CheckTimes; i++) {
 
-		//
-		// Write Data to register and readback
-		//
+		/* Write data to register and readback */
 		switch (CheckBlock) {
 		case HW90_BLOCK_MAC:
 			RT_TRACE(COMP_ERR, "PHY_CheckBBRFOK(): Never Write 0x100 here!");
@@ -677,7 +717,8 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 		case HW90_BLOCK_RF:
 			WriteData[i] &= 0xfff;
 			rtl8192_phy_SetRFReg(dev, eRFPath, WriteAddr[HW90_BLOCK_RF], bMask12Bits, WriteData[i]);
-			// TODO: we should not delay for such a long time. Ask SD3
+			/* TODO: we should not delay for such a long time.
+			   Ask SD3 */
 			msleep(1);
 			dwRegRead = rtl8192_phy_QueryRFReg(dev, eRFPath, WriteAddr[HW90_BLOCK_RF], bMask12Bits);
 			msleep(1);
@@ -689,9 +730,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 		}
 
 
-		//
-		// Check whether readback data is correct
-		//
+		/* Check whether readback data is correct */
 		if (dwRegRead != WriteData[i]) {
 			RT_TRACE((COMP_PHY|COMP_ERR), "====>error=====dwRegRead: %x, WriteData: %x \n", dwRegRead, WriteData[i]);
 			ret = 1;
@@ -704,93 +743,95 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 
 
 /******************************************************************************
- *function:  This function initialize BB&RF
- *   input:  net_device dev
- *  output:  none
- *  return:  none
- *  notice:  Initialization value may change all the time, so please make
- *           sure it has been synced with the newest.
- * ***************************************************************************/
+ * function:  This function initializes BB&RF
+ * input:     net_device	*dev
+ * output:    none
+ * return:    none
+ * notice:    Initialization value may change all the time, so please make
+ *            sure it has been synced with the newest.
+ ******************************************************************************/
 void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8 reg_u8 = 0, eCheckItem = 0, rtStatus = 0;
 	u32 reg_u32 = 0;
 	/**************************************
-	//<1>Initialize BaseBand
-	**************************************/
+	 * <1> Initialize BaseBand
+	 *************************************/
 
-	/*--set BB Global Reset--*/
+	/* --set BB Global Reset-- */
 	read_nic_byte(dev, BB_GLOBAL_RESET, &reg_u8);
 	write_nic_byte(dev, BB_GLOBAL_RESET, (reg_u8|BB_GLOBAL_RESET_BIT));
 	mdelay(50);
-	/*---set BB reset Active---*/
+	/* ---set BB reset Active--- */
 	read_nic_dword(dev, CPU_GEN, &reg_u32);
 	write_nic_dword(dev, CPU_GEN, (reg_u32&(~CPU_GEN_BB_RST)));
 
-	/*----Ckeck FPGAPHY0 and PHY1 board is OK----*/
-	// TODO: this function should be removed on ASIC , Emily 2007.2.2
+	/* ----Ckeck FPGAPHY0 and PHY1 board is OK---- */
+	/* TODO: this function should be removed on ASIC */
 	for (eCheckItem = (HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {
-		rtStatus  = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem, (RF90_RADIO_PATH_E)0); //don't care RF path
+		rtStatus  = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem, (RF90_RADIO_PATH_E)0); /* don't care RF path */
 		if (rtStatus != 0) {
 			RT_TRACE((COMP_ERR | COMP_PHY), "PHY_RF8256_Config():Check PHY%d Fail!!\n", eCheckItem-1);
 			return;
 		}
 	}
-	/*---- Set CCK and OFDM Block "OFF"----*/
+	/* ---- Set CCK and OFDM Block "OFF"---- */
 	rtl8192_setBBreg(dev, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x0);
-	/*----BB Register Initilazation----*/
-	//==m==>Set PHY REG From Header<==m==
+	/* ----BB Register Initilazation---- */
+	/* ==m==>Set PHY REG From Header<==m== */
 	rtl8192_phyConfigBB(dev, BaseBand_Config_PHY_REG);
 
-	/*----Set BB reset de-Active----*/
+	/* ----Set BB reset de-Active---- */
 	read_nic_dword(dev, CPU_GEN, &reg_u32);
 	write_nic_dword(dev, CPU_GEN, (reg_u32|CPU_GEN_BB_RST));
 
-	/*----BB AGC table Initialization----*/
-	//==m==>Set PHY REG From Header<==m==
+	/* ----BB AGC table Initialization---- */
+	/* ==m==>Set PHY REG From Header<==m== */
 	rtl8192_phyConfigBB(dev, BaseBand_Config_AGC_TAB);
 
-	/*----Enable XSTAL ----*/
+	/* ----Enable XSTAL ---- */
 	write_nic_byte_E(dev, 0x5e, 0x00);
 	if (priv->card_8192_version == (u8)VERSION_819xU_A) {
-		//Antenna gain offset from B/C/D to A
+		/* Antenna gain offset from B/C/D to A */
 		reg_u32 = (priv->AntennaTxPwDiff[1]<<4 | priv->AntennaTxPwDiff[0]);
 		rtl8192_setBBreg(dev, rFPGA0_TxGainStage, (bXBTxAGC|bXCTxAGC), reg_u32);
 
-		//XSTALLCap
+		/* XSTALLCap */
 		reg_u32 = priv->CrystalCap & 0xf;
 		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, bXtalCap, reg_u32);
 	}
 
-	// Check if the CCK HighPower is turned ON.
-	// This is used to calculate PWDB.
+	/* Check if the CCK HighPower is turned ON.
+	   This is used to calculate PWDB. */
 	priv->bCckHighPower = (u8)(rtl8192_QueryBBReg(dev, rFPGA0_XA_HSSIParameter2, 0x200));
 	return;
 }
 /******************************************************************************
- *function:  This function initialize BB&RF
- *   input:  net_device dev
- *  output:  none
- *  return:  none
- *  notice:  Initialization value may change all the time, so please make
- *           sure it has been synced with the newest.
- * ***************************************************************************/
+ * function:  This function initializes BB&RF
+ * input:     net_device	*dev
+ * output:    none
+ * return:    none
+ * notice:    Initialization value may change all the time, so please make
+ *            sure it has been synced with the newest.
+ *****************************************************************************/
 void rtl8192_BBConfig(struct net_device *dev)
 {
 	rtl8192_InitBBRFRegDef(dev);
-	//config BB&RF. As hardCode based initialization has not been well
-	//implemented, so use file first.FIXME:should implement it for hardcode?
+	/* config BB&RF. As hardCode based initialization has not been well
+	 * implemented, so use file first.
+	 * FIXME: should implement it for hardcode? */
 	rtl8192_BB_Config_ParaFile(dev);
 	return;
 }
 
 /******************************************************************************
- *function:  This function obtains the initialization value of Tx power Level offset
- *   input:  net_device dev
- *  output:  none
- *  return:  none
- * ***************************************************************************/
+ * function:  This function obtains the initialization value of Tx power Level
+ *            offset
+ * input:     net_device	*dev
+ * output:    none
+ * return:    none
+ *****************************************************************************/
 void rtl8192_phy_getTxPower(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -802,7 +843,7 @@ void rtl8192_phy_getTxPower(struct net_device *dev)
 	read_nic_dword(dev, rTxAGC_Mcs11_Mcs08, &priv->MCSTxPowerLevelOriginalOffset[4]);
 	read_nic_dword(dev, rTxAGC_Mcs15_Mcs12, &priv->MCSTxPowerLevelOriginalOffset[5]);
 
-	// read rx initial gain
+	/* Read rx initial gain */
 	read_nic_byte(dev, rOFDM0_XAAGCCore1, &priv->DefaultInitialGain[0]);
 	read_nic_byte(dev, rOFDM0_XBAGCCore1, &priv->DefaultInitialGain[1]);
 	read_nic_byte(dev, rOFDM0_XCAGCCore1, &priv->DefaultInitialGain[2]);
@@ -811,25 +852,27 @@ void rtl8192_phy_getTxPower(struct net_device *dev)
 		priv->DefaultInitialGain[0], priv->DefaultInitialGain[1],
 		priv->DefaultInitialGain[2], priv->DefaultInitialGain[3]);
 
-	// read framesync
+	/* Read framesync */
 	read_nic_byte(dev, rOFDM0_RxDetector3, &priv->framesync);
 	read_nic_byte(dev, rOFDM0_RxDetector2, &tmp);
 	priv->framesyncC34 = tmp;
 	RT_TRACE(COMP_INIT, "Default framesync (0x%x) = 0x%x \n",
 		rOFDM0_RxDetector3, priv->framesync);
 
-	// read SIFS (save the value read fome MACPHY_REG.txt)
+	/* Read SIFS (save the value read fome MACPHY_REG.txt) */
 	read_nic_word(dev, SIFS, &priv->SifsTime);
 
 	return;
 }
 
 /******************************************************************************
- *function:  This function obtains the initialization value of Tx power Level offset
- *   input:  net_device dev
- *  output:  none
- *  return:  none
- * ***************************************************************************/
+ * function:  This function sets the initialization value of Tx power Level
+ *            offset
+ * input:     net_device        *dev
+ *            u8                channel
+ * output:    none
+ * return:    none
+ ******************************************************************************/
 void rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -849,11 +892,11 @@ void rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)
 }
 
 /******************************************************************************
- *function:  This function check Rf chip to do RF config
- *   input:  net_device dev
- *  output:  none
- *  return:  only 8256 is supported
- * ***************************************************************************/
+ * function:  This function checks Rf chip to do RF config
+ * input:     net_device	*dev
+ * output:    none
+ * return:    only 8256 is supported
+ ******************************************************************************/
 void rtl8192_phy_RFConfig(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -870,23 +913,25 @@ void rtl8192_phy_RFConfig(struct net_device *dev)
 }
 
 /******************************************************************************
- *function:  This function update Initial gain
- *   input:  net_device dev
- *  output:  none
- *  return:  As Windows has not implemented this, wait for complement
- * ***************************************************************************/
+ * function:  This function updates Initial gain
+ * input:     net_device	*dev
+ * output:    none
+ * return:    As Windows has not implemented this, wait for complement
+ ******************************************************************************/
 void rtl8192_phy_updateInitGain(struct net_device *dev)
 {
 	return;
 }
 
 /******************************************************************************
- *function:  This function read RF parameters from general head file, and do RF 3-wire
- *   input:  net_device dev
- *  output:  none
- *  return:  return code show if RF configuration is successful(0:pass, 1:fail)
- *    Note:  Delay may be required for RF configuration
- * ***************************************************************************/
+ * function:  This function read RF parameters from general head file,
+ *            and do RF 3-wire
+ * input:     net_device	*dev
+ *            RF90_RADIO_PATH_E eRFPath
+ * output:    none
+ * return:    return code show if RF configuration is successful(0:pass, 1:fail)
+ * notice:    Delay may be required for RF configuration
+ *****************************************************************************/
 u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 				      RF90_RADIO_PATH_E	eRFPath)
 {
@@ -951,13 +996,13 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 
 }
 /******************************************************************************
- *function:  This function set Tx Power of the channel
- *   input:  struct net_device *dev
- *	     u8			channel
- *  output:  none
- *  return:  none
- *    Note:
- * ***************************************************************************/
+ * function:  This function sets Tx Power of the channel
+ * input:     net_device        *dev
+ *            u8                channel
+ * output:    none
+ * return:    none
+ * notice:
+ ******************************************************************************/
 void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -987,13 +1032,13 @@ void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
 }
 
 /******************************************************************************
- *function:  This function set RF state on or off
- *   input:  struct net_device *dev
- *	     RT_RF_POWER_STATE eRFPowerState  //Power State to set
- *  output:  none
- *  return:  none
- *    Note:
- * ***************************************************************************/
+ * function:  This function sets RF state on or off
+ * input:     net_device         *dev
+ *            RT_RF_POWER_STATE  eRFPowerState  //Power State to set
+ * output:    none
+ * return:    none
+ * notice:
+ *****************************************************************************/
 bool rtl8192_SetRFPowerState(struct net_device *dev,
 			     RT_RF_POWER_STATE eRFPowerState)
 {
@@ -1012,19 +1057,19 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 		case RF_8256:
 		switch (eRFPowerState) {
 			case eRfOn:
-	//RF-A, RF-B
-					//enable RF-Chip A/B
-					rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x1);	// 0x860[4]
-					//analog to digital on
-					rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3);// 0x88c[9:8]
-					//digital to analog on
-					rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18, 0x3); // 0x880[4:3]
-					//rx antenna on
-					rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0x3, 0x3);// 0xc04[1:0]
-					//rx antenna on
-					rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0x3, 0x3);// 0xd04[1:0]
-					//analog to digital part2 on
-					rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x3); // 0x880[6:5]
+				/* RF-A, RF-B */
+				/* enable RF-Chip A/B */
+				rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x1); /* 0x860[4] */
+				/* analog to digital on */
+				rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3); /* 0x88c[9:8] */
+				/* digital to analog on */
+				rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18, 0x3); /* 0x880[4:3] */
+				/* rx antenna on */
+				rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0x3, 0x3); /* 0xc04[1:0] */
+				/* rx antenna on */
+				rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0x3, 0x3); /* 0xd04[1:0] */
+				/* analog to digital part2 on */
+				rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x3); /* 0x880[6:5] */
 
 				break;
 
@@ -1033,19 +1078,19 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 				break;
 
 			case eRfOff:
-					//RF-A, RF-B
-					//disable RF-Chip A/B
-					rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x0);	// 0x860[4]
-					//analog to digital off, for power save
-					rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00, 0x0);// 0x88c[11:8]
-					//digital to analog off, for power save
-					rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18, 0x0); // 0x880[4:3]
-					//rx antenna off
-					rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0x0);// 0xc04[3:0]
-					//rx antenna off
-					rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x0);// 0xd04[3:0]
-					//analog to digital part2 off, for power save
-					rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x0); // 0x880[6:5]
+				/* RF-A, RF-B */
+				/* disable RF-Chip A/B */
+				rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x0); /* 0x860[4] */
+				/* analog to digital off, for power save */
+				rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00, 0x0); /* 0x88c[11:8] */
+				/* digital to analog off, for power save */
+				rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18, 0x0); /* 0x880[4:3] */
+				/* rx antenna off */
+				rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0x0); /* 0xc04[3:0] */
+				/* rx antenna off */
+				rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x0); /* 0xd04[3:0] */
+				/* analog to digital part2 off, for power save */
+				rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x0); /* 0x880[6:5] */
 
 				break;
 
@@ -1061,36 +1106,32 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 	}
 #ifdef TO_DO_LIST
 	if (bResult) {
-		// Update current RF state variable.
+		/* Update current RF state variable. */
 		pHalData->eRFPowerState = eRFPowerState;
 		switch (pHalData->RFChipID) {
 			case RF_8256:
 		switch (pHalData->eRFPowerState) {
 				case eRfOff:
-					//
-					//If Rf off reason is from IPS, Led should blink with no link, by Maddest 071015
-					//
+					/* If Rf off reason is from IPS, LED should blink with no link */
 					if (pMgntInfo->RfOffReason == RF_CHANGE_BY_IPS)
 						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);
 					else
-						// Turn off LED if RF is not ON.
+						/* Turn off LED if RF is not ON. */
 						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_POWER_OFF);
 					break;
 
 				case eRfOn:
-					// Turn on RF we are still linked, which might happen when
-					// we quickly turn off and on HW RF. 2006.05.12, by rcnjko.
+					/* Turn on RF we are still linked, which might happen when we quickly turn off and on HW RF. */
 					if (pMgntInfo->bMediaConnect == TRUE)
 						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_LINK);
 					else
-						// Turn off LED if RF is not ON.
+						/* Turn off LED if RF is not ON. */
 						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);
 					break;
 
 				default:
-					// do nothing.
 					break;
-				}// Switch RF state
+				}
 				break;
 
 				default:
@@ -1105,19 +1146,19 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 	return bResult;
 }
 
-/****************************************************************************************
- *function:  This function set command table variable(struct SwChnlCmd).
- *   input:  SwChnlCmd*		CmdTable	//table to be set.
- *	     u32		CmdTableIdx	//variable index in table to be set
- *	     u32		CmdTableSz	//table size.
- *	     SwChnlCmdID	CmdID		//command ID to set.
- *	     u32		Para1
- *	     u32		Para2
- *	     u32		msDelay
- *  output:
- *  return:  true if finished, false otherwise
- *    Note:
- * ************************************************************************************/
+/******************************************************************************
+ * function:  This function sets command table variable (struct SwChnlCmd).
+ * input:     SwChnlCmd      *CmdTable    //table to be set
+ *            u32            CmdTableIdx  //variable index in table to be set
+ *            u32            CmdTableSz   //table size
+ *            SwChnlCmdID    CmdID        //command ID to set
+ *            u32            Para1
+ *            u32            Para2
+ *            u32            msDelay
+ * output:
+ * return:    true if finished, false otherwise
+ * notice:
+ ******************************************************************************/
 u8 rtl8192_phy_SetSwChnlCmdArray(SwChnlCmd *CmdTable, u32 CmdTableIdx,
 				 u32 CmdTableSz, SwChnlCmdID CmdID, u32 Para1,
 				 u32 Para2, u32 msDelay)
@@ -1143,16 +1184,17 @@ u8 rtl8192_phy_SetSwChnlCmdArray(SwChnlCmd *CmdTable, u32 CmdTableIdx,
 	return true;
 }
 /******************************************************************************
- *function:  This function set channel step by step
- *   input:  struct net_device *dev
- *	     u8			channel
- *	     u8*		stage //3 stages
- *	     u8*		step  //
- *	     u32*		delay //whether need to delay
- *  output:  store new stage, step and delay for next step(combine with function above)
- *  return:  true if finished, false otherwise
- *    Note:  Wait for simpler function to replace it //wb
- * ***************************************************************************/
+ * function:  This function sets channel step by step
+ * input:     net_device        *dev
+ *            u8                channel
+ *            u8                *stage   //3 stages
+ *            u8                *step
+ *            u32               *delay   //whether need to delay
+ * output:    store new stage, step and delay for next step
+ *            (combine with function above)
+ * return:    true if finished, false otherwise
+ * notice:    Wait for simpler function to replace it
+ *****************************************************************************/
 u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
 				u8 *step, u32 *delay)
 {
@@ -1169,25 +1211,27 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
 	RT_TRACE(COMP_CH, "====>%s()====stage:%d, step:%d, channel:%d\n", __FUNCTION__, *stage, *step, channel);
 	if (!IsLegalChannel(priv->ieee80211, channel)) {
 		RT_TRACE(COMP_ERR, "=============>set to illegal channel:%d\n", channel);
-		return true; //return true to tell upper caller function this channel setting is finished! Or it will in while loop.
+		/* return true to tell upper caller function this channel
+		   setting is finished! Or it will in while loop. */
+		return true;
 	}
-//FIXME:need to check whether channel is legal or not here.WB
+/* FIXME: need to check whether channel is legal or not here */
 
 
-		// <1> Fill up pre common command.
+	        /* <1> Fill up pre common command. */
 		PreCommonCmdCnt = 0;
 		rtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT,
 					CmdID_SetTxPowerLevel, 0, 0, 0);
 		rtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT,
 					CmdID_End, 0, 0, 0);
 
-		// <2> Fill up post common command.
+		/* <2> Fill up post common command. */
 		PostCommonCmdCnt = 0;
 
 		rtl8192_phy_SetSwChnlCmdArray(PostCommonCmd, PostCommonCmdCnt++, MAX_POSTCMD_CNT,
 					CmdID_End, 0, 0, 0);
 
-		// <3> Fill up RF dependent command.
+		/* <3> Fill up RF dependent command. */
 		RfDependCmdCnt = 0;
 		switch (priv->rf_chip) {
 		case RF_8225:
@@ -1202,7 +1246,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
 			break;
 
 		case RF_8256:
-			// TEST!! This is not the table for 8256!!
+			/* TEST!! This is not the table for 8256!! */
 			if (!(channel >= 1 && channel <= 14)) {
 				RT_TRACE(COMP_ERR, "illegal channel for Zebra 8256: %d\n", channel);
 				return true;
@@ -1249,7 +1293,8 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
 
 			switch (CurrentCmd->CmdID) {
 			case CmdID_SetTxPowerLevel:
-				if (priv->card_8192_version == (u8)VERSION_819xU_A) //xiong: consider it later!
+				if (priv->card_8192_version == (u8)VERSION_819xU_A)
+					/* consider it later! */
 					rtl8192_SetTxPowerLevel(dev, channel);
 				break;
 			case CmdID_WritePortUlong:
@@ -1279,13 +1324,13 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
 }
 
 /******************************************************************************
- *function:  This function does actually set channel work
- *   input:  struct net_device *dev
- *	     u8			channel
- *  output:  none
- *  return:  noin
- *    Note:  We should not call this function directly
- * ***************************************************************************/
+ * function:  This function does actually set channel work
+ * input:     net_device        *dev
+ *            u8                channel
+ * output:    none
+ * return:    none
+ * notice:    We should not call this function directly
+ *****************************************************************************/
 void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -1297,12 +1342,12 @@ void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
 	}
 }
 /******************************************************************************
- *function:  Callback routine of the work item for switch channel.
- *   input:
+ * function:  Callback routine of the work item for switch channel.
+ * input:     net_device	*dev
  *
- *  output:  none
- *  return:  noin
- * ***************************************************************************/
+ * output:    none
+ * return:    none
+ *****************************************************************************/
 void rtl8192_SwChnl_WorkItem(struct net_device *dev)
 {
 
@@ -1317,13 +1362,13 @@ void rtl8192_SwChnl_WorkItem(struct net_device *dev)
 }
 
 /******************************************************************************
- *function:  This function scheduled actual work item to set channel
- *   input:  net_device dev
- *	     u8		channel //channel to set
- *  output:  none
- *  return:  return code show if workitem is scheduled(1:pass, 0:fail)
- *    Note:  Delay may be required for RF configuration
- * ***************************************************************************/
+ * function:  This function scheduled actual work item to set channel
+ * input:     net_device        *dev
+ *            u8                channel   //channel to set
+ * output:    none
+ * return:    return code show if workitem is scheduled (1:pass, 0:fail)
+ * notice:    Delay may be required for RF configuration
+ ******************************************************************************/
 u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -1333,7 +1378,7 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 	if (priv->SwChnlInProgress)
 		return false;
 
-	//--------------------------------------------
+	/* -------------------------------------------- */
 	switch (priv->ieee80211->mode) {
 	case WIRELESS_MODE_A:
 	case WIRELESS_MODE_N_5G:
@@ -1356,7 +1401,7 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 		}
 		break;
 	}
-	//--------------------------------------------
+	/* -------------------------------------------- */
 
 	priv->SwChnlInProgress = true;
 	if (channel == 0)
@@ -1374,17 +1419,14 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 }
 
 
-//
 /******************************************************************************
- *function:  Callback routine of the work item for set bandwidth mode.
- *   input:  struct net_device *dev
- *	     HT_CHANNEL_WIDTH	Bandwidth  //20M or 40M
- *	     HT_EXTCHNL_OFFSET Offset	   //Upper, Lower, or Don't care
- *  output:  none
- *  return:  none
- *    Note:  I doubt whether SetBWModeInProgress flag is necessary as we can
- *	     test whether current work in the queue or not.//do I?
- * ***************************************************************************/
+ * function:  Callback routine of the work item for set bandwidth mode.
+ * input:     net_device	 *dev
+ * output:    none
+ * return:    none
+ * notice:    I doubt whether SetBWModeInProgress flag is necessary as we can
+ *            test whether current work in the queue or not.//do I?
+ *****************************************************************************/
 void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 {
 
@@ -1400,19 +1442,19 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 		return;
 	}
 
-	//<1>Set MAC register
+	/* <1> Set MAC register */
 	read_nic_byte(dev, BW_OPMODE, &regBwOpMode);
 
 	switch (priv->CurrentChannelBW) {
 		case HT_CHANNEL_WIDTH_20:
 			regBwOpMode |= BW_OPMODE_20MHZ;
-		       // 2007/02/07 Mark by Emily because we have not verify whether this register works
+			/* We have not verify whether this register works */
 			write_nic_byte(dev, BW_OPMODE, regBwOpMode);
 			break;
 
 		case HT_CHANNEL_WIDTH_20_40:
 			regBwOpMode &= ~BW_OPMODE_20MHZ;
-			// 2007/02/07 Mark by Emily because we have not verify whether this register works
+			/* We have not verify whether this register works */
 			write_nic_byte(dev, BW_OPMODE, regBwOpMode);
 			break;
 
@@ -1421,15 +1463,14 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			break;
 	}
 
-	//<2>Set PHY related register
+	/* <2> Set PHY related register */
 	switch (priv->CurrentChannelBW) {
 		case HT_CHANNEL_WIDTH_20:
-			// Add by Vivi 20071119
 			rtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x0);
 			rtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x0);
 			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 1);
 
-			// Correct the tx power for CCK rate in 20M. Suggest by YN, 20071207
+			/* Correct the tx power for CCK rate in 20M. */
 			priv->cck_present_attentuation =
 				priv->cck_present_attentuation_20Mdefault + priv->cck_present_attentuation_difference;
 
@@ -1451,7 +1492,6 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 
 			break;
 		case HT_CHANNEL_WIDTH_20_40:
-			// Add by Vivi 20071119
 			rtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x1);
 			rtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x1);
 			rtl8192_setBBreg(dev, rCCK0_System, bCCKSideBand, (priv->nCur40MhzPrimeSC>>1));
@@ -1482,9 +1522,10 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			break;
 
 	}
-	//Skip over setting of J-mode in BB register here. Default value is "None J mode". Emily 20070315
+	/* Skip over setting of J-mode in BB register here.
+	   Default value is "None J mode". */
 
-	//<3>Set RF related register
+	/* <3> Set RF related register */
 	switch (priv->rf_chip) {
 		case RF_8225:
 #ifdef TO_DO_LIST
@@ -1497,11 +1538,9 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			break;
 
 		case RF_8258:
-			// PHY_SetRF8258Bandwidth();
 			break;
 
 		case RF_PSEUDO_11N:
-			// Do Nothing
 			break;
 
 		default:
@@ -1514,15 +1553,15 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 }
 
 /******************************************************************************
- *function:  This function schedules bandwidth switch work.
- *   input:  struct net_device *dev
- *	     HT_CHANNEL_WIDTH	bandwidth  //20M or 40M
- *	     HT_EXTCHNL_OFFSET  offset	   //Upper, Lower, or Don't care
- *  output:  none
- *  return:  none
- *    Note:  I doubt whether SetBWModeInProgress flag is necessary as we can
- *	     test whether current work in the queue or not.//do I?
- * ***************************************************************************/
+ * function:  This function schedules bandwidth switch work.
+ * input:     struct net_deviceq   *dev
+ *            HT_CHANNEL_WIDTH     bandwidth  //20M or 40M
+ *            HT_EXTCHNL_OFFSET    offset     //Upper, Lower, or Don't care
+ * output:    none
+ * return:    none
+ * notice:    I doubt whether SetBWModeInProgress flag is necessary as we can
+ *	      test whether current work in the queue or not.//do I?
+ *****************************************************************************/
 void rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH bandwidth,
 		       HT_EXTCHNL_OFFSET offset)
 {
@@ -1574,7 +1613,8 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 			initial_gain = SCAN_RX_INITIAL_GAIN;
 			bitmask = bMaskByte0;
 			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
-				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	// FW DIG OFF
+				/* FW DIG OFF */
+				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);
 			priv->initgain_backup.xaagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XAAGCCore1, bitmask);
 			priv->initgain_backup.xbagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XBAGCCore1, bitmask);
 			priv->initgain_backup.xcagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XCAGCCore1, bitmask);
@@ -1598,9 +1638,10 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 			break;
 		case IG_Restore:
 			RT_TRACE(COMP_SCAN, "IG_Restore, restore the initial gain.\n");
-			bitmask = 0x7f; //Bit0~ Bit6
+			bitmask = 0x7f; /* Bit0 ~ Bit6 */
 			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
-				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	// FW DIG OFF
+				/* FW DIG OFF */
+				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);
 
 			rtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, bitmask, (u32)priv->initgain_backup.xaagccore1);
 			rtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, bitmask, (u32)priv->initgain_backup.xbagccore1);
@@ -1624,7 +1665,8 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 			rtl8192_phy_setTxPower(dev, priv->ieee80211->current_network.channel);
 
 			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
-				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);	// FW DIG ON
+				/* FW DIG ON */
+				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);
 			break;
 		default:
 			RT_TRACE(COMP_SCAN, "Unknown IG Operation. \n");

commit 83e6d9e262aa02488b68a8fdc2f05264e28354f3
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Wed Jun 19 04:58:06 2013 +0300

    staging: rtl8192u: fix spaces around ',' in r819xU_phy.c
    
    This patch fixes the whitespace around ',' to meet the
    linux kernel coding style.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 07a178d50f02..9bfcd2f451f7 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -510,12 +510,12 @@ void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 	if (ConfigType == BaseBand_Config_PHY_REG) {
 		for (i = 0; i < PHY_REG_1T2RArrayLength; i += 2) {
 			rtl8192_setBBreg(dev, rtl819XPHY_REG_1T2RArray[i], bMaskDWord, rtl819XPHY_REG_1T2RArray[i+1]);
-			RT_TRACE(COMP_DBG, "i: %x, The Rtl819xUsbPHY_REGArray[0] is %x Rtl819xUsbPHY_REGArray[1] is %x \n",i, rtl819XPHY_REG_1T2RArray[i], rtl819XPHY_REG_1T2RArray[i+1]);
+			RT_TRACE(COMP_DBG, "i: %x, The Rtl819xUsbPHY_REGArray[0] is %x Rtl819xUsbPHY_REGArray[1] is %x \n", i, rtl819XPHY_REG_1T2RArray[i], rtl819XPHY_REG_1T2RArray[i+1]);
 		}
 	} else if (ConfigType == BaseBand_Config_AGC_TAB) {
 		for (i = 0; i < AGCTAB_ArrayLength; i += 2) {
 			rtl8192_setBBreg(dev, rtl819XAGCTAB_Array[i], bMaskDWord, rtl819XAGCTAB_Array[i+1]);
-			RT_TRACE(COMP_DBG, "i:%x, The rtl819XAGCTAB_Array[0] is %x rtl819XAGCTAB_Array[1] is %x \n",i, rtl819XAGCTAB_Array[i], rtl819XAGCTAB_Array[i+1]);
+			RT_TRACE(COMP_DBG, "i:%x, The rtl819XAGCTAB_Array[0] is %x rtl819XAGCTAB_Array[1] is %x \n", i, rtl819XAGCTAB_Array[i], rtl819XAGCTAB_Array[i+1]);
 		}
 	}
 	return;
@@ -722,7 +722,7 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 
 	/*--set BB Global Reset--*/
 	read_nic_byte(dev, BB_GLOBAL_RESET, &reg_u8);
-	write_nic_byte(dev, BB_GLOBAL_RESET,(reg_u8|BB_GLOBAL_RESET_BIT));
+	write_nic_byte(dev, BB_GLOBAL_RESET, (reg_u8|BB_GLOBAL_RESET_BIT));
 	mdelay(50);
 	/*---set BB reset Active---*/
 	read_nic_dword(dev, CPU_GEN, &reg_u32);
@@ -1071,7 +1071,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 					//If Rf off reason is from IPS, Led should blink with no link, by Maddest 071015
 					//
 					if (pMgntInfo->RfOffReason == RF_CHANGE_BY_IPS)
-						Adapter->HalFunc.LedControlHandler(Adapter,LED_CTL_NO_LINK);
+						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);
 					else
 						// Turn off LED if RF is not ON.
 						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_POWER_OFF);
@@ -1250,7 +1250,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
 			switch (CurrentCmd->CmdID) {
 			case CmdID_SetTxPowerLevel:
 				if (priv->card_8192_version == (u8)VERSION_819xU_A) //xiong: consider it later!
-					rtl8192_SetTxPowerLevel(dev,channel);
+					rtl8192_SetTxPowerLevel(dev, channel);
 				break;
 			case CmdID_WritePortUlong:
 				write_nic_dword(dev, CurrentCmd->Para1, CurrentCmd->Para2);
@@ -1291,7 +1291,7 @@ void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32	delay = 0;
 
-	while (!rtl8192_phy_SwChnlStepByStep(dev,channel,&priv->SwChnlStage,&priv->SwChnlStep,&delay)) {
+	while (!rtl8192_phy_SwChnlStepByStep(dev, channel, &priv->SwChnlStage, &priv->SwChnlStep, &delay)) {
 		if (!priv->up)
 			break;
 	}
@@ -1311,7 +1311,7 @@ void rtl8192_SwChnl_WorkItem(struct net_device *dev)
 	RT_TRACE(COMP_CH, "==> SwChnlCallback819xUsbWorkItem(), chan:%d\n", priv->chan);
 
 
-	rtl8192_phy_FinishSwChnlNow(dev , priv->chan);
+	rtl8192_phy_FinishSwChnlNow(dev, priv->chan);
 
 	RT_TRACE(COMP_CH, "<== SwChnlCallback819xUsbWorkItem()\n");
 }
@@ -1417,7 +1417,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			break;
 
 		default:
-			RT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n",priv->CurrentChannelBW);
+			RT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n", priv->CurrentChannelBW);
 			break;
 	}
 
@@ -1441,12 +1441,12 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 
 			if (priv->chan == 14 && !priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = TRUE;
-				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+				dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
 			} else if (priv->chan != 14 && priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = FALSE;
-				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+				dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
 			} else {
-				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+				dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
 			}
 
 			break;
@@ -1468,17 +1468,17 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			RT_TRACE(COMP_INIT, "40M, pHalData->CCKPresentAttentuation = %d\n", priv->cck_present_attentuation);
 			if (priv->chan == 14 && !priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = true;
-				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+				dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
 			} else if (priv->chan != 14 && priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = false;
-				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+				dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
 			} else {
-				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+				dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
 			}
 
 			break;
 		default:
-			RT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n" ,priv->CurrentChannelBW);
+			RT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n", priv->CurrentChannelBW);
 			break;
 
 	}
@@ -1552,13 +1552,13 @@ void InitialGain819xUsb(struct net_device *dev,	u8 Operation)
 	priv->InitialGainOperateType = Operation;
 
 	if (priv->up)
-		queue_delayed_work(priv->priv_wq,&priv->initialgain_operate_wq,0);
+		queue_delayed_work(priv->priv_wq, &priv->initialgain_operate_wq, 0);
 }
 
 extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 {
-	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
-       struct r8192_priv *priv = container_of(dwork,struct r8192_priv,initialgain_operate_wq);
+	struct delayed_work *dwork = container_of(work, struct delayed_work, work);
+       struct r8192_priv *priv = container_of(dwork, struct r8192_priv, initialgain_operate_wq);
        struct net_device *dev = priv->ieee80211->dev;
 #define SCAN_RX_INITIAL_GAIN	0x17
 #define POWER_DETECTION_TH	0x08
@@ -1582,11 +1582,11 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 			bitmask = bMaskByte2;
 			priv->initgain_backup.cca		= (u8)rtl8192_QueryBBReg(dev, rCCK0_CCA, bitmask);
 
-			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc50 is %x\n",priv->initgain_backup.xaagccore1);
-			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc58 is %x\n",priv->initgain_backup.xbagccore1);
-			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc60 is %x\n",priv->initgain_backup.xcagccore1);
-			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc68 is %x\n",priv->initgain_backup.xdagccore1);
-			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xa0a is %x\n",priv->initgain_backup.cca);
+			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc50 is %x\n", priv->initgain_backup.xaagccore1);
+			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc58 is %x\n", priv->initgain_backup.xbagccore1);
+			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc60 is %x\n", priv->initgain_backup.xcagccore1);
+			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc68 is %x\n", priv->initgain_backup.xdagccore1);
+			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xa0a is %x\n", priv->initgain_backup.cca);
 
 			RT_TRACE(COMP_SCAN, "Write scan initial gain = 0x%x \n", initial_gain);
 			write_nic_byte(dev, rOFDM0_XAAGCCore1, initial_gain);
@@ -1609,19 +1609,19 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 			bitmask  = bMaskByte2;
 			rtl8192_setBBreg(dev, rCCK0_CCA, bitmask, (u32)priv->initgain_backup.cca);
 
-			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc50 is %x\n",priv->initgain_backup.xaagccore1);
-			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc58 is %x\n",priv->initgain_backup.xbagccore1);
-			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc60 is %x\n",priv->initgain_backup.xcagccore1);
-			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc68 is %x\n",priv->initgain_backup.xdagccore1);
-			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xa0a is %x\n",priv->initgain_backup.cca);
+			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc50 is %x\n", priv->initgain_backup.xaagccore1);
+			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc58 is %x\n", priv->initgain_backup.xbagccore1);
+			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc60 is %x\n", priv->initgain_backup.xcagccore1);
+			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc68 is %x\n", priv->initgain_backup.xdagccore1);
+			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xa0a is %x\n", priv->initgain_backup.cca);
 
 #ifdef RTL8190P
-			SetTxPowerLevel8190(Adapter,priv->CurrentChannel);
+			SetTxPowerLevel8190(Adapter, priv->CurrentChannel);
 #endif
 #ifdef RTL8192E
-			SetTxPowerLevel8190(Adapter,priv->CurrentChannel);
+			SetTxPowerLevel8190(Adapter, priv->CurrentChannel);
 #endif
-			rtl8192_phy_setTxPower(dev,priv->ieee80211->current_network.channel);
+			rtl8192_phy_setTxPower(dev, priv->ieee80211->current_network.channel);
 
 			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
 				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);	// FW DIG ON

commit c4b5eb8c012499a13e9ec9dcb7331e7040e8d472
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Wed Jun 19 04:58:05 2013 +0300

    staging: rtl8192u: remove variable 'Ret' in r819xU_phy.c
    
    This patch removes variable 'Ret' from rtl8192_QueryBBReg()
    since its value is returned immediately after it is
    assigned. The name 'Ret', anyway, does not give any
    insight and the function description comment is sufficiently
    informative regarding the returned value.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 387d137ec9ff..07a178d50f02 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -108,13 +108,12 @@ void rtl8192_setBBreg(struct net_device *dev, u32 reg_addr, u32 bitmask,
  * ****************************************************************************/
 u32 rtl8192_QueryBBReg(struct net_device *dev, u32 reg_addr, u32 bitmask)
 {
-	u32 Ret = 0, reg, bitshift;
+	u32 reg, bitshift;
 
 	read_nic_dword(dev, reg_addr, &reg);
 	bitshift = rtl8192_CalculateBitShift(bitmask);
-	Ret = (reg & bitmask) >> bitshift;
 
-	return Ret;
+	return (reg & bitmask) >> bitshift;
 }
 static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 			      u32 offset);

commit 79931639015a79d2d0ccde4334294ad15128ea44
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Tue Jun 18 05:29:41 2013 +0300

    staging: rtl8192u: rename general variables in r819xU_phy.c
    
    This patch renames the following variables:
    - dwRegAddr and RegAddr into reg_addr
    - dwData and Data       into data
    - BitShift              into bitshift
    - Offset                into offset
    - NewOffset             into new_offset
    - Bandwidth             into bandwidth
    
    The renaming was done to remove camel case and
    unnecessary 'dw' prefix from the above variable names.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 787090adfa46..387d137ec9ff 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -73,100 +73,100 @@ u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 eRFPath)
 /******************************************************************************
  *function:  This function set specific bits to BB register
  *   input:  net_device dev
- *           u32	dwRegAddr  //target addr to be modified
+ *           u32	reg_addr   //target addr to be modified
  *           u32	bitmask    //taget bit pos in the addr to be modified
- *           u32	dwData     //value to be write
+ *           u32	data       //value to be write
  *  output:  none
  *  return:  none
  *  notice:
  * ****************************************************************************/
-void rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 bitmask,
-		      u32 dwData)
+void rtl8192_setBBreg(struct net_device *dev, u32 reg_addr, u32 bitmask,
+		      u32 data)
 {
 
-	u32 reg, BitShift;
+	u32 reg, bitshift;
 
 	if (bitmask != bMaskDWord) { //if not "double word" write
-		read_nic_dword(dev, dwRegAddr, &reg);
-		BitShift = rtl8192_CalculateBitShift(bitmask);
+		read_nic_dword(dev, reg_addr, &reg);
+		bitshift = rtl8192_CalculateBitShift(bitmask);
 		reg &= ~bitmask;
-		reg |= dwData << BitShift;
-		write_nic_dword(dev, dwRegAddr, reg);
+		reg |= data << bitshift;
+		write_nic_dword(dev, reg_addr, reg);
 	} else {
-		write_nic_dword(dev, dwRegAddr, dwData);
+		write_nic_dword(dev, reg_addr, data);
 	}
 	return;
 }
 /******************************************************************************
  *function:  This function reads specific bits from BB register
  *   input:  net_device dev
- *           u32	dwRegAddr  //target addr to be readback
+ *           u32	reg_addr   //target addr to be readback
  *           u32	bitmask    //taget bit pos in the addr to be readback
  *  output:  none
- *  return:  u32	Data	//the readback register value
+ *  return:  u32	data       //the readback register value
  *  notice:
  * ****************************************************************************/
-u32 rtl8192_QueryBBReg(struct net_device *dev, u32 dwRegAddr, u32 bitmask)
+u32 rtl8192_QueryBBReg(struct net_device *dev, u32 reg_addr, u32 bitmask)
 {
-	u32 Ret = 0, reg, BitShift;
+	u32 Ret = 0, reg, bitshift;
 
-	read_nic_dword(dev, dwRegAddr, &reg);
-	BitShift = rtl8192_CalculateBitShift(bitmask);
-	Ret = (reg & bitmask) >> BitShift;
+	read_nic_dword(dev, reg_addr, &reg);
+	bitshift = rtl8192_CalculateBitShift(bitmask);
+	Ret = (reg & bitmask) >> bitshift;
 
 	return Ret;
 }
 static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
-			      u32 Offset);
+			      u32 offset);
 
 static void phy_FwRFSerialWrite(struct net_device *dev,
-				RF90_RADIO_PATH_E eRFPath, u32  Offset,
-				u32  Data);
+				RF90_RADIO_PATH_E eRFPath, u32  offset,
+				u32  data);
 
 /******************************************************************************
  *function:  This function read register from RF chip
  *   input:  net_device dev
  *	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
- *           u32	Offset     //target address to be read
+ *           u32	offset     //target address to be read
  *  output:  none
  *  return:  u32	readback value
  *  notice:  There are three types of serial operations:(1) Software serial write.(2)Hardware LSSI-Low Speed Serial Interface.(3)Hardware HSSI-High speed serial write. Driver here need to implement (1) and (2)---need more spec for this information.
  * ****************************************************************************/
 u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
-			     u32 Offset)
+			     u32 offset)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 ret = 0;
-	u32 NewOffset = 0;
+	u32 new_offset = 0;
 	BB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[eRFPath];
 	rtl8192_setBBreg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData, 0);
 	//make sure RF register offset is correct
-	Offset &= 0x3f;
+	offset &= 0x3f;
 
 	//switch page for 8256 RF IC
 	if (priv->rf_chip == RF_8256) {
-		if (Offset >= 31) {
+		if (offset >= 31) {
 			priv->RfReg0Value[eRFPath] |= 0x140;
 			//Switch to Reg_Mode2 for Reg 31-45
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));
 			//modify offset
-			NewOffset = Offset -30;
-		} else if (Offset >= 16) {
+			new_offset = offset - 30;
+		} else if (offset >= 16) {
 			priv->RfReg0Value[eRFPath] |= 0x100;
 			priv->RfReg0Value[eRFPath] &= (~0x40);
 			//Switch to Reg_Mode 1 for Reg16-30
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));
 
-			NewOffset = Offset - 15;
+			new_offset = offset - 15;
 		} else {
-			NewOffset = Offset;
+			new_offset = offset;
 		}
 	} else {
 		RT_TRACE((COMP_PHY|COMP_ERR), "check RF type here, need to be 8256\n");
-		NewOffset = Offset;
+		new_offset = offset;
 	}
 	//put desired read addr to LSSI control Register
-	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadAddress, NewOffset);
+	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadAddress, new_offset);
 	//Issue a posedge trigger
 	//
 	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x0);
@@ -198,8 +198,8 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
  *function:  This function write data to RF register
  *   input:  net_device dev
  *	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
- *           u32	Offset     //target address to be written
- *           u32	Data	//The new register data to be written
+ *           u32	offset     //target address to be written
+ *           u32	data	   //The new register data to be written
  *  output:  none
  *  return:  none
  *  notice:  For RF8256 only.
@@ -215,45 +215,45 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
  *------------------------------------------------------------------
  * ****************************************************************************/
 void rtl8192_phy_RFSerialWrite(struct net_device *dev,
-			       RF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data)
+			       RF90_RADIO_PATH_E eRFPath, u32 offset, u32 data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	u32 DataAndAddr = 0, NewOffset = 0;
+	u32 DataAndAddr = 0, new_offset = 0;
 	BB_REGISTER_DEFINITION_T	*pPhyReg = &priv->PHYRegDef[eRFPath];
 
-	Offset &= 0x3f;
+	offset &= 0x3f;
 	if (priv->rf_chip == RF_8256) {
 
-		if (Offset >= 31) {
+		if (offset >= 31) {
 			priv->RfReg0Value[eRFPath] |= 0x140;
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath] << 16));
-			NewOffset = Offset - 30;
-		} else if (Offset >= 16) {
+			new_offset = offset - 30;
+		} else if (offset >= 16) {
 			priv->RfReg0Value[eRFPath] |= 0x100;
 			priv->RfReg0Value[eRFPath] &= (~0x40);
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));
-			NewOffset = Offset - 15;
+			new_offset = offset - 15;
 		} else {
-			NewOffset = Offset;
+			new_offset = offset;
 		}
 	} else {
 		RT_TRACE((COMP_PHY|COMP_ERR), "check RF type here, need to be 8256\n");
-		NewOffset = Offset;
+		new_offset = offset;
 	}
 
 	// Put write addr in [5:0] and write data in [31:16]
-	DataAndAddr = (Data<<16) | (NewOffset&0x3f);
+	DataAndAddr = (data<<16) | (new_offset&0x3f);
 
 	// Write Operation
 	rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);
 
 
-	if (Offset == 0x0)
-		priv->RfReg0Value[eRFPath] = Data;
+	if (offset == 0x0)
+		priv->RfReg0Value[eRFPath] = data;
 
 	// Switch back to Reg_Mode0;
 	if (priv->rf_chip == RF_8256) {
-		if (Offset != 0) {
+		if (offset != 0) {
 			priv->RfReg0Value[eRFPath] &= 0xebf;
 			rtl8192_setBBreg(
 				dev,
@@ -269,46 +269,46 @@ void rtl8192_phy_RFSerialWrite(struct net_device *dev,
  *function:  This function set specific bits to RF register
  *   input:  net_device dev
  *	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
- *           u32	RegAddr  //target addr to be modified
+ *           u32	reg_addr //target addr to be modified
  *           u32	bitmask  //taget bit pos in the addr to be modified
- *           u32	Data     //value to be write
+ *           u32	data     //value to be write
  *  output:  none
  *  return:  none
  *  notice:
  * ****************************************************************************/
 void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
-			  u32 RegAddr, u32 bitmask, u32 Data)
+			  u32 reg_addr, u32 bitmask, u32 data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	u32 reg, BitShift;
+	u32 reg, bitshift;
 
 	if (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))
 		return;
 
 	if (priv->Rf_Mode == RF_OP_By_FW) {
 		if (bitmask != bMask12Bits) { // RF data is 12 bits only
-			reg = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
-			BitShift =  rtl8192_CalculateBitShift(bitmask);
+			reg = phy_FwRFSerialRead(dev, eRFPath, reg_addr);
+			bitshift =  rtl8192_CalculateBitShift(bitmask);
 			reg &= ~bitmask;
-			reg |= Data << BitShift;
+			reg |= data << bitshift;
 
-			phy_FwRFSerialWrite(dev, eRFPath, RegAddr, reg);
+			phy_FwRFSerialWrite(dev, eRFPath, reg_addr, reg);
 		} else {
-			phy_FwRFSerialWrite(dev, eRFPath, RegAddr, Data);
+			phy_FwRFSerialWrite(dev, eRFPath, reg_addr, data);
 		}
 
 		udelay(200);
 
 	} else {
 		if (bitmask != bMask12Bits) { // RF data is 12 bits only
-			reg = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
-			BitShift =  rtl8192_CalculateBitShift(bitmask);
+			reg = rtl8192_phy_RFSerialRead(dev, eRFPath, reg_addr);
+			bitshift =  rtl8192_CalculateBitShift(bitmask);
 			reg &= ~bitmask;
-			reg |= Data << BitShift;
+			reg |= data << bitshift;
 
-			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, reg);
+			rtl8192_phy_RFSerialWrite(dev, eRFPath, reg_addr, reg);
 		} else {
-			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, Data);
+			rtl8192_phy_RFSerialWrite(dev, eRFPath, reg_addr, data);
 		}
 	}
 	return;
@@ -317,31 +317,31 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 /******************************************************************************
  *function:  This function reads specific bits from RF register
  *   input:  net_device dev
- *           u32	RegAddr  //target addr to be readback
+ *           u32	reg_addr //target addr to be readback
  *           u32	bitmask  //taget bit pos in the addr to be readback
  *  output:  none
- *  return:  u32	Data	//the readback register value
+ *  return:  u32	data	//the readback register value
  *  notice:
  * ****************************************************************************/
 u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
-			   u32 RegAddr, u32 bitmask)
+			   u32 reg_addr, u32 bitmask)
 {
-	u32 reg, BitShift;
+	u32 reg, bitshift;
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
 
 	if (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))
 		return 0;
 	if (priv->Rf_Mode == RF_OP_By_FW) {
-		reg = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
-		BitShift =  rtl8192_CalculateBitShift(bitmask);
-		reg = (reg & bitmask) >> BitShift;
+		reg = phy_FwRFSerialRead(dev, eRFPath, reg_addr);
+		bitshift =  rtl8192_CalculateBitShift(bitmask);
+		reg = (reg & bitmask) >> bitshift;
 		udelay(200);
 		return reg;
 	} else {
-		reg = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
-		BitShift =  rtl8192_CalculateBitShift(bitmask);
-		reg = (reg & bitmask) >> BitShift;
+		reg = rtl8192_phy_RFSerialRead(dev, eRFPath, reg_addr);
+		bitshift =  rtl8192_CalculateBitShift(bitmask);
+		reg = (reg & bitmask) >> bitshift;
 		return reg;
 	}
 }
@@ -353,10 +353,10 @@ u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
  *  notice:
  * ***************************************************************************/
 static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
-			      u32 Offset)
+			      u32 offset)
 {
 	u32		reg = 0;
-	u32		Data = 0;
+	u32		data = 0;
 	u8		time = 0;
 	u32		tmp;
 	/* 2007/11/02 MH Firmware RF Write control. By Francis' suggestion, we can
@@ -364,12 +364,12 @@ static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	   much time. This is only for site survey. */
 	// 1. Read operation need not insert data. bit 0-11
 	// 2. Write RF register address. Bit 12-19
-	Data |= ((Offset&0xFF)<<12);
+	data |= ((offset&0xFF)<<12);
 	// 3. Write RF path.  bit 20-21
-	Data |= ((eRFPath&0x3)<<20);
+	data |= ((eRFPath&0x3)<<20);
 	// 4. Set RF read indicator. bit 22=0
 	// 5. Trigger Fw to operate the command. bit 31
-	Data |= 0x80000000;
+	data |= 0x80000000;
 	// 6. We can not execute read operation if bit 31 is 1.
 	read_nic_dword(dev, QPNR, &tmp);
 	while (tmp & 0x80000000) {
@@ -382,7 +382,7 @@ static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 		}
 	}
 	// 7. Execute read operation.
-	write_nic_dword(dev, QPNR, Data);
+	write_nic_dword(dev, QPNR, data);
 	// 8. Check if firmawre send back RF content.
 	read_nic_dword(dev, QPNR, &tmp);
 	while (tmp & 0x80000000) {
@@ -408,7 +408,7 @@ static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
  *  notice:
  * ***************************************************************************/
 static void phy_FwRFSerialWrite(struct net_device *dev,
-				RF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data)
+				RF90_RADIO_PATH_E eRFPath, u32 offset, u32 data)
 {
 	u8	time = 0;
 	u32	tmp;
@@ -419,13 +419,13 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
 
 	// 1. Set driver write bit and 12 bit data. bit 0-11
 	// 2. Write RF register address. bit 12-19
-	Data |= ((Offset&0xFF)<<12);
+	data |= ((offset&0xFF)<<12);
 	// 3. Write RF path.  bit 20-21
-	Data |= ((eRFPath&0x3)<<20);
+	data |= ((eRFPath&0x3)<<20);
 	// 4. Set RF write indicator. bit 22=1
-	Data |= 0x400000;
+	data |= 0x400000;
 	// 5. Trigger Fw to operate the command. bit 31=1
-	Data |= 0x80000000;
+	data |= 0x80000000;
 
 	// 6. Write operation. We can not write if bit 31 is 1.
 	read_nic_dword(dev, QPNR, &tmp);
@@ -440,7 +440,7 @@ static void phy_FwRFSerialWrite(struct net_device *dev,
 	}
 	// 7. No matter check bit. We always force the write. Because FW will
 	//    not accept the command.
-	write_nic_dword(dev, QPNR, Data);
+	write_nic_dword(dev, QPNR, data);
 	/* 2007/11/02 MH Acoording to test, we must delay 20us to wait firmware
 	   to finish RF write operation. */
 	/* 2008/01/17 MH We support delay in firmware side now. */
@@ -1517,15 +1517,15 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 /******************************************************************************
  *function:  This function schedules bandwidth switch work.
  *   input:  struct net_device *dev
- *	     HT_CHANNEL_WIDTH	Bandwidth  //20M or 40M
- *	     HT_EXTCHNL_OFFSET Offset	   //Upper, Lower, or Don't care
+ *	     HT_CHANNEL_WIDTH	bandwidth  //20M or 40M
+ *	     HT_EXTCHNL_OFFSET  offset	   //Upper, Lower, or Don't care
  *  output:  none
  *  return:  none
  *    Note:  I doubt whether SetBWModeInProgress flag is necessary as we can
  *	     test whether current work in the queue or not.//do I?
  * ***************************************************************************/
-void rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH Bandwidth,
-		       HT_EXTCHNL_OFFSET Offset)
+void rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH bandwidth,
+		       HT_EXTCHNL_OFFSET offset)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
@@ -1533,11 +1533,11 @@ void rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH Bandwidth,
 		return;
 	priv->SetBWModeInProgress = true;
 
-	priv->CurrentChannelBW = Bandwidth;
+	priv->CurrentChannelBW = bandwidth;
 
-	if (Offset == HT_EXTCHNL_OFFSET_LOWER)
+	if (offset == HT_EXTCHNL_OFFSET_LOWER)
 		priv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_UPPER;
-	else if (Offset == HT_EXTCHNL_OFFSET_UPPER)
+	else if (offset == HT_EXTCHNL_OFFSET_UPPER)
 		priv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_LOWER;
 	else
 		priv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_DONT_CARE;

commit 9f66ddb5f7e30cb91e0ba44a2307768c2eacff68
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Tue Jun 18 05:29:40 2013 +0300

    staging: rtl8192u: rename *BitMask variables in r819xU_phy.c
    
    This patch renames BitMask and dwBitMask variables into
    bitmask to remove camel case.
    dwBitMask in the given context can be renamed into simply
    bitmask since its number of bits (dw->32) can be deduced
    by its type which is u32.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index c1ab59e336fc..787090adfa46 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -40,14 +40,14 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 /******************************************************************************
  *function:  This function read BB parameters from Header file we gen,
  *	     and do register read/write
- *   input:  u32	dwBitMask  //taget bit pos in the addr to be modified
+ *   input:  u32	bitmask  //taget bit pos in the addr to be modified
  *  output:  none
  *  return:  u32	return the shift bit position of the mask
  * ****************************************************************************/
-u32 rtl8192_CalculateBitShift(u32 dwBitMask)
+u32 rtl8192_CalculateBitShift(u32 bitmask)
 {
 	u32 i;
-	i = ffs(dwBitMask) - 1;
+	i = ffs(bitmask) - 1;
 	return i;
 }
 /******************************************************************************
@@ -74,22 +74,22 @@ u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 eRFPath)
  *function:  This function set specific bits to BB register
  *   input:  net_device dev
  *           u32	dwRegAddr  //target addr to be modified
- *           u32	dwBitMask  //taget bit pos in the addr to be modified
+ *           u32	bitmask    //taget bit pos in the addr to be modified
  *           u32	dwData     //value to be write
  *  output:  none
  *  return:  none
  *  notice:
  * ****************************************************************************/
-void rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask,
+void rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 bitmask,
 		      u32 dwData)
 {
 
 	u32 reg, BitShift;
 
-	if (dwBitMask != bMaskDWord) { //if not "double word" write
+	if (bitmask != bMaskDWord) { //if not "double word" write
 		read_nic_dword(dev, dwRegAddr, &reg);
-		BitShift = rtl8192_CalculateBitShift(dwBitMask);
-		reg &= ~dwBitMask;
+		BitShift = rtl8192_CalculateBitShift(bitmask);
+		reg &= ~bitmask;
 		reg |= dwData << BitShift;
 		write_nic_dword(dev, dwRegAddr, reg);
 	} else {
@@ -101,18 +101,18 @@ void rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask,
  *function:  This function reads specific bits from BB register
  *   input:  net_device dev
  *           u32	dwRegAddr  //target addr to be readback
- *           u32	dwBitMask  //taget bit pos in the addr to be readback
+ *           u32	bitmask    //taget bit pos in the addr to be readback
  *  output:  none
  *  return:  u32	Data	//the readback register value
  *  notice:
  * ****************************************************************************/
-u32 rtl8192_QueryBBReg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask)
+u32 rtl8192_QueryBBReg(struct net_device *dev, u32 dwRegAddr, u32 bitmask)
 {
 	u32 Ret = 0, reg, BitShift;
 
 	read_nic_dword(dev, dwRegAddr, &reg);
-	BitShift = rtl8192_CalculateBitShift(dwBitMask);
-	Ret = (reg & dwBitMask) >> BitShift;
+	BitShift = rtl8192_CalculateBitShift(bitmask);
+	Ret = (reg & bitmask) >> BitShift;
 
 	return Ret;
 }
@@ -270,14 +270,14 @@ void rtl8192_phy_RFSerialWrite(struct net_device *dev,
  *   input:  net_device dev
  *	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
  *           u32	RegAddr  //target addr to be modified
- *           u32	BitMask  //taget bit pos in the addr to be modified
+ *           u32	bitmask  //taget bit pos in the addr to be modified
  *           u32	Data     //value to be write
  *  output:  none
  *  return:  none
  *  notice:
  * ****************************************************************************/
 void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
-			  u32 RegAddr, u32 BitMask, u32 Data)
+			  u32 RegAddr, u32 bitmask, u32 Data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 reg, BitShift;
@@ -286,10 +286,10 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 		return;
 
 	if (priv->Rf_Mode == RF_OP_By_FW) {
-		if (BitMask != bMask12Bits) { // RF data is 12 bits only
+		if (bitmask != bMask12Bits) { // RF data is 12 bits only
 			reg = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
-			BitShift =  rtl8192_CalculateBitShift(BitMask);
-			reg &= ~BitMask;
+			BitShift =  rtl8192_CalculateBitShift(bitmask);
+			reg &= ~bitmask;
 			reg |= Data << BitShift;
 
 			phy_FwRFSerialWrite(dev, eRFPath, RegAddr, reg);
@@ -300,10 +300,10 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 		udelay(200);
 
 	} else {
-		if (BitMask != bMask12Bits) { // RF data is 12 bits only
+		if (bitmask != bMask12Bits) { // RF data is 12 bits only
 			reg = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
-			BitShift =  rtl8192_CalculateBitShift(BitMask);
-			reg &= ~BitMask;
+			BitShift =  rtl8192_CalculateBitShift(bitmask);
+			reg &= ~bitmask;
 			reg |= Data << BitShift;
 
 			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, reg);
@@ -318,13 +318,13 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
  *function:  This function reads specific bits from RF register
  *   input:  net_device dev
  *           u32	RegAddr  //target addr to be readback
- *           u32	BitMask  //taget bit pos in the addr to be readback
+ *           u32	bitmask  //taget bit pos in the addr to be readback
  *  output:  none
  *  return:  u32	Data	//the readback register value
  *  notice:
  * ****************************************************************************/
 u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
-			   u32 RegAddr, u32 BitMask)
+			   u32 RegAddr, u32 bitmask)
 {
 	u32 reg, BitShift;
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -334,14 +334,14 @@ u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 		return 0;
 	if (priv->Rf_Mode == RF_OP_By_FW) {
 		reg = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
-		BitShift =  rtl8192_CalculateBitShift(BitMask);
-		reg = (reg & BitMask) >> BitShift;
+		BitShift =  rtl8192_CalculateBitShift(bitmask);
+		reg = (reg & bitmask) >> BitShift;
 		udelay(200);
 		return reg;
 	} else {
 		reg = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
-		BitShift =  rtl8192_CalculateBitShift(BitMask);
-		reg = (reg & BitMask) >> BitShift;
+		BitShift =  rtl8192_CalculateBitShift(bitmask);
+		reg = (reg & bitmask) >> BitShift;
 		return reg;
 	}
 }
@@ -1563,7 +1563,7 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
        struct net_device *dev = priv->ieee80211->dev;
 #define SCAN_RX_INITIAL_GAIN	0x17
 #define POWER_DETECTION_TH	0x08
-	u32	BitMask;
+	u32	bitmask;
 	u8	initial_gain;
 	u8	Operation;
 
@@ -1573,15 +1573,15 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 		case IG_Backup:
 			RT_TRACE(COMP_SCAN, "IG_Backup, backup the initial gain.\n");
 			initial_gain = SCAN_RX_INITIAL_GAIN;
-			BitMask = bMaskByte0;
+			bitmask = bMaskByte0;
 			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
 				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	// FW DIG OFF
-			priv->initgain_backup.xaagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XAAGCCore1, BitMask);
-			priv->initgain_backup.xbagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XBAGCCore1, BitMask);
-			priv->initgain_backup.xcagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XCAGCCore1, BitMask);
-			priv->initgain_backup.xdagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XDAGCCore1, BitMask);
-			BitMask  = bMaskByte2;
-			priv->initgain_backup.cca		= (u8)rtl8192_QueryBBReg(dev, rCCK0_CCA, BitMask);
+			priv->initgain_backup.xaagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XAAGCCore1, bitmask);
+			priv->initgain_backup.xbagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XBAGCCore1, bitmask);
+			priv->initgain_backup.xcagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XCAGCCore1, bitmask);
+			priv->initgain_backup.xdagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XDAGCCore1, bitmask);
+			bitmask = bMaskByte2;
+			priv->initgain_backup.cca		= (u8)rtl8192_QueryBBReg(dev, rCCK0_CCA, bitmask);
 
 			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc50 is %x\n",priv->initgain_backup.xaagccore1);
 			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc58 is %x\n",priv->initgain_backup.xbagccore1);
@@ -1599,16 +1599,16 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 			break;
 		case IG_Restore:
 			RT_TRACE(COMP_SCAN, "IG_Restore, restore the initial gain.\n");
-			BitMask = 0x7f; //Bit0~ Bit6
+			bitmask = 0x7f; //Bit0~ Bit6
 			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
 				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	// FW DIG OFF
 
-			rtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, BitMask, (u32)priv->initgain_backup.xaagccore1);
-			rtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, BitMask, (u32)priv->initgain_backup.xbagccore1);
-			rtl8192_setBBreg(dev, rOFDM0_XCAGCCore1, BitMask, (u32)priv->initgain_backup.xcagccore1);
-			rtl8192_setBBreg(dev, rOFDM0_XDAGCCore1, BitMask, (u32)priv->initgain_backup.xdagccore1);
-			BitMask  = bMaskByte2;
-			rtl8192_setBBreg(dev, rCCK0_CCA, BitMask, (u32)priv->initgain_backup.cca);
+			rtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, bitmask, (u32)priv->initgain_backup.xaagccore1);
+			rtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, bitmask, (u32)priv->initgain_backup.xbagccore1);
+			rtl8192_setBBreg(dev, rOFDM0_XCAGCCore1, bitmask, (u32)priv->initgain_backup.xcagccore1);
+			rtl8192_setBBreg(dev, rOFDM0_XDAGCCore1, bitmask, (u32)priv->initgain_backup.xdagccore1);
+			bitmask  = bMaskByte2;
+			rtl8192_setBBreg(dev, rCCK0_CCA, bitmask, (u32)priv->initgain_backup.cca);
 
 			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc50 is %x\n",priv->initgain_backup.xaagccore1);
 			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc58 is %x\n",priv->initgain_backup.xbagccore1);

commit 07ecbbf1a39dfa75712367c14beb1033062c47f8
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Tue Jun 18 05:29:39 2013 +0300

    staging: rtl8192u: replace *Value variables in r819xU_phy.c
    
    This patch renames the variables OriginalValue, NewValue,
    Original_Value, New_Value and retValue to reg, and
    the variables bRegValue and dwRegValue to reg_u8 and
    reg_u32, respectively. This is done primarily in
    order to reduce the variable name length and consequently
    line length.
    
    Also, it replaces the pair of Original and New variables
    with one variable.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 5941b9a7ee3a..c1ab59e336fc 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -84,13 +84,14 @@ void rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask,
 		      u32 dwData)
 {
 
-	u32 OriginalValue, BitShift, NewValue;
+	u32 reg, BitShift;
 
 	if (dwBitMask != bMaskDWord) { //if not "double word" write
-		read_nic_dword(dev, dwRegAddr, &OriginalValue);
+		read_nic_dword(dev, dwRegAddr, &reg);
 		BitShift = rtl8192_CalculateBitShift(dwBitMask);
-		NewValue = (((OriginalValue) & (~dwBitMask)) | (dwData << BitShift));
-		write_nic_dword(dev, dwRegAddr, NewValue);
+		reg &= ~dwBitMask;
+		reg |= dwData << BitShift;
+		write_nic_dword(dev, dwRegAddr, reg);
 	} else {
 		write_nic_dword(dev, dwRegAddr, dwData);
 	}
@@ -107,11 +108,11 @@ void rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask,
  * ****************************************************************************/
 u32 rtl8192_QueryBBReg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask)
 {
-	u32 Ret = 0, OriginalValue, BitShift;
+	u32 Ret = 0, reg, BitShift;
 
-	read_nic_dword(dev, dwRegAddr, &OriginalValue);
+	read_nic_dword(dev, dwRegAddr, &reg);
 	BitShift = rtl8192_CalculateBitShift(dwBitMask);
-	Ret = (OriginalValue & dwBitMask) >> BitShift;
+	Ret = (reg & dwBitMask) >> BitShift;
 
 	return Ret;
 }
@@ -279,18 +280,19 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 			  u32 RegAddr, u32 BitMask, u32 Data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	u32 Original_Value, BitShift, New_Value;
+	u32 reg, BitShift;
 
 	if (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))
 		return;
 
 	if (priv->Rf_Mode == RF_OP_By_FW) {
 		if (BitMask != bMask12Bits) { // RF data is 12 bits only
-			Original_Value = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
+			reg = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
 			BitShift =  rtl8192_CalculateBitShift(BitMask);
-			New_Value = ((Original_Value) & (~BitMask)) | (Data<< BitShift);
+			reg &= ~BitMask;
+			reg |= Data << BitShift;
 
-			phy_FwRFSerialWrite(dev, eRFPath, RegAddr, New_Value);
+			phy_FwRFSerialWrite(dev, eRFPath, RegAddr, reg);
 		} else {
 			phy_FwRFSerialWrite(dev, eRFPath, RegAddr, Data);
 		}
@@ -299,11 +301,12 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 
 	} else {
 		if (BitMask != bMask12Bits) { // RF data is 12 bits only
-			Original_Value = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
+			reg = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
 			BitShift =  rtl8192_CalculateBitShift(BitMask);
-			New_Value = (((Original_Value) & (~BitMask)) | (Data<< BitShift));
+			reg &= ~BitMask;
+			reg |= Data << BitShift;
 
-			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, New_Value);
+			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, reg);
 		} else {
 			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, Data);
 		}
@@ -323,23 +326,23 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 			   u32 RegAddr, u32 BitMask)
 {
-	u32 Original_Value, Readback_Value, BitShift;
+	u32 reg, BitShift;
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
 
 	if (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))
 		return 0;
 	if (priv->Rf_Mode == RF_OP_By_FW) {
-		Original_Value = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
+		reg = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
 		BitShift =  rtl8192_CalculateBitShift(BitMask);
-		Readback_Value = (Original_Value & BitMask) >> BitShift;
+		reg = (reg & BitMask) >> BitShift;
 		udelay(200);
-		return Readback_Value;
+		return reg;
 	} else {
-		Original_Value = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
+		reg = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
 		BitShift =  rtl8192_CalculateBitShift(BitMask);
-		Readback_Value = (Original_Value & BitMask) >> BitShift;
-		return Readback_Value;
+		reg = (reg & BitMask) >> BitShift;
+		return reg;
 	}
 }
 /******************************************************************************
@@ -352,7 +355,7 @@ u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 			      u32 Offset)
 {
-	u32		retValue = 0;
+	u32		reg = 0;
 	u32		Data = 0;
 	u8		time = 0;
 	u32		tmp;
@@ -391,9 +394,9 @@ static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 			return 0;
 		}
 	}
-	read_nic_dword(dev, RF_DATA, &retValue);
+	read_nic_dword(dev, RF_DATA, &reg);
 
-	return retValue;
+	return reg;
 
 }	/* phy_FwRFSerialRead */
 
@@ -712,19 +715,19 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	u8 bRegValue = 0, eCheckItem = 0, rtStatus = 0;
-	u32 dwRegValue = 0;
+	u8 reg_u8 = 0, eCheckItem = 0, rtStatus = 0;
+	u32 reg_u32 = 0;
 	/**************************************
 	//<1>Initialize BaseBand
 	**************************************/
 
 	/*--set BB Global Reset--*/
-	read_nic_byte(dev, BB_GLOBAL_RESET, &bRegValue);
-	write_nic_byte(dev, BB_GLOBAL_RESET,(bRegValue|BB_GLOBAL_RESET_BIT));
+	read_nic_byte(dev, BB_GLOBAL_RESET, &reg_u8);
+	write_nic_byte(dev, BB_GLOBAL_RESET,(reg_u8|BB_GLOBAL_RESET_BIT));
 	mdelay(50);
 	/*---set BB reset Active---*/
-	read_nic_dword(dev, CPU_GEN, &dwRegValue);
-	write_nic_dword(dev, CPU_GEN, (dwRegValue&(~CPU_GEN_BB_RST)));
+	read_nic_dword(dev, CPU_GEN, &reg_u32);
+	write_nic_dword(dev, CPU_GEN, (reg_u32&(~CPU_GEN_BB_RST)));
 
 	/*----Ckeck FPGAPHY0 and PHY1 board is OK----*/
 	// TODO: this function should be removed on ASIC , Emily 2007.2.2
@@ -742,8 +745,8 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	rtl8192_phyConfigBB(dev, BaseBand_Config_PHY_REG);
 
 	/*----Set BB reset de-Active----*/
-	read_nic_dword(dev, CPU_GEN, &dwRegValue);
-	write_nic_dword(dev, CPU_GEN, (dwRegValue|CPU_GEN_BB_RST));
+	read_nic_dword(dev, CPU_GEN, &reg_u32);
+	write_nic_dword(dev, CPU_GEN, (reg_u32|CPU_GEN_BB_RST));
 
 	/*----BB AGC table Initialization----*/
 	//==m==>Set PHY REG From Header<==m==
@@ -753,12 +756,12 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	write_nic_byte_E(dev, 0x5e, 0x00);
 	if (priv->card_8192_version == (u8)VERSION_819xU_A) {
 		//Antenna gain offset from B/C/D to A
-		dwRegValue = (priv->AntennaTxPwDiff[1]<<4 | priv->AntennaTxPwDiff[0]);
-		rtl8192_setBBreg(dev, rFPGA0_TxGainStage, (bXBTxAGC|bXCTxAGC), dwRegValue);
+		reg_u32 = (priv->AntennaTxPwDiff[1]<<4 | priv->AntennaTxPwDiff[0]);
+		rtl8192_setBBreg(dev, rFPGA0_TxGainStage, (bXBTxAGC|bXCTxAGC), reg_u32);
 
 		//XSTALLCap
-		dwRegValue = priv->CrystalCap & 0xf;
-		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, bXtalCap, dwRegValue);
+		reg_u32 = priv->CrystalCap & 0xf;
+		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, bXtalCap, reg_u32);
 	}
 
 	// Check if the CCK HighPower is turned ON.

commit 9d8e79ed3262b0f7e64168f8a1b7967a03353ca7
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Tue Jun 18 05:29:38 2013 +0300

    staging: rtl8192u: fix spaces around relational operators in r819xU_phy.c
    
    This patch fixes the whitespace around relational operators
    to meet the linux kernel coding style.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index fc52c785b16e..5941b9a7ee3a 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -86,7 +86,7 @@ void rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask,
 
 	u32 OriginalValue, BitShift, NewValue;
 
-	if (dwBitMask!= bMaskDWord) { //if not "double word" write
+	if (dwBitMask != bMaskDWord) { //if not "double word" write
 		read_nic_dword(dev, dwRegAddr, &OriginalValue);
 		BitShift = rtl8192_CalculateBitShift(dwBitMask);
 		NewValue = (((OriginalValue) & (~dwBitMask)) | (dwData << BitShift));
@@ -247,7 +247,7 @@ void rtl8192_phy_RFSerialWrite(struct net_device *dev,
 	rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);
 
 
-	if (Offset==0x0)
+	if (Offset == 0x0)
 		priv->RfReg0Value[eRFPath] = Data;
 
 	// Switch back to Reg_Mode0;
@@ -470,7 +470,7 @@ void rtl8192_phy_configmac(struct net_device *dev)
 		dwArrayLen = MACPHY_ArrayLength;
 		pdwArray = rtl819XMACPHY_Array;
 	}
-	for (i = 0; i<dwArrayLen; i = i+3) {
+	for (i = 0; i < dwArrayLen; i = i+3) {
 		if (pdwArray[i] == 0x318) {
 			pdwArray[i+2] = 0x00000800;
 		}
@@ -506,12 +506,12 @@ void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 	}
 #endif
 	if (ConfigType == BaseBand_Config_PHY_REG) {
-		for (i = 0; i<PHY_REG_1T2RArrayLength; i += 2) {
+		for (i = 0; i < PHY_REG_1T2RArrayLength; i += 2) {
 			rtl8192_setBBreg(dev, rtl819XPHY_REG_1T2RArray[i], bMaskDWord, rtl819XPHY_REG_1T2RArray[i+1]);
 			RT_TRACE(COMP_DBG, "i: %x, The Rtl819xUsbPHY_REGArray[0] is %x Rtl819xUsbPHY_REGArray[1] is %x \n",i, rtl819XPHY_REG_1T2RArray[i], rtl819XPHY_REG_1T2RArray[i+1]);
 		}
 	} else if (ConfigType == BaseBand_Config_AGC_TAB) {
-		for (i = 0; i<AGCTAB_ArrayLength; i += 2) {
+		for (i = 0; i < AGCTAB_ArrayLength; i += 2) {
 			rtl8192_setBBreg(dev, rtl819XAGCTAB_Array[i], bMaskDWord, rtl819XAGCTAB_Array[i+1]);
 			RT_TRACE(COMP_DBG, "i:%x, The rtl819XAGCTAB_Array[0] is %x rtl819XAGCTAB_Array[1] is %x \n",i, rtl819XAGCTAB_Array[i], rtl819XAGCTAB_Array[i+1]);
 		}
@@ -728,7 +728,7 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 
 	/*----Ckeck FPGAPHY0 and PHY1 board is OK----*/
 	// TODO: this function should be removed on ASIC , Emily 2007.2.2
-	for (eCheckItem = (HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem<=HW90_BLOCK_PHY1; eCheckItem++) {
+	for (eCheckItem = (HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {
 		rtStatus  = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem, (RF90_RADIO_PATH_E)0); //don't care RF path
 		if (rtStatus != 0) {
 			RT_TRACE((COMP_ERR | COMP_PHY), "PHY_RF8256_Config():Check PHY%d Fail!!\n", eCheckItem-1);
@@ -894,7 +894,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 
 	switch (eRFPath) {
 	case RF90_PATH_A:
-		for (i = 0; i<RadioA_ArrayLength; i = i+2) {
+		for (i = 0; i < RadioA_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioA_Array[i] == 0xfe) {
 					mdelay(100);
@@ -906,7 +906,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		}
 		break;
 	case RF90_PATH_B:
-		for (i = 0; i<RadioB_ArrayLength; i = i+2) {
+		for (i = 0; i < RadioB_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioB_Array[i] == 0xfe) {
 					mdelay(100);
@@ -918,7 +918,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		}
 		break;
 	case RF90_PATH_C:
-		for (i = 0; i<RadioC_ArrayLength; i = i+2) {
+		for (i = 0; i < RadioC_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioC_Array[i] == 0xfe) {
 					mdelay(100);
@@ -930,7 +930,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		}
 		break;
 	case RF90_PATH_D:
-		for (i = 0; i<RadioD_ArrayLength; i = i+2) {
+		for (i = 0; i < RadioD_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioD_Array[i] == 0xfe) {
 					mdelay(100);
@@ -1068,7 +1068,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 					//
 					//If Rf off reason is from IPS, Led should blink with no link, by Maddest 071015
 					//
-					if (pMgntInfo->RfOffReason==RF_CHANGE_BY_IPS)
+					if (pMgntInfo->RfOffReason == RF_CHANGE_BY_IPS)
 						Adapter->HalFunc.LedControlHandler(Adapter,LED_CTL_NO_LINK);
 					else
 						// Turn off LED if RF is not ON.
@@ -1234,8 +1234,8 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
 				break;
 			}
 
-			if (CurrentCmd->CmdID==CmdID_End) {
-				if ((*stage)==2) {
+			if (CurrentCmd->CmdID == CmdID_End) {
+				if ((*stage) == 2) {
 					(*delay) = CurrentCmd->msDelay;
 					return true;
 				} else {
@@ -1335,20 +1335,20 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 	switch (priv->ieee80211->mode) {
 	case WIRELESS_MODE_A:
 	case WIRELESS_MODE_N_5G:
-		if (channel<=14) {
+		if (channel <= 14) {
 			RT_TRACE(COMP_ERR, "WIRELESS_MODE_A but channel<=14");
 			return false;
 		}
 		break;
 	case WIRELESS_MODE_B:
-		if (channel>14) {
+		if (channel > 14) {
 			RT_TRACE(COMP_ERR, "WIRELESS_MODE_B but channel>14");
 			return false;
 		}
 		break;
 	case WIRELESS_MODE_G:
 	case WIRELESS_MODE_N_24G:
-		if (channel>14) {
+		if (channel > 14) {
 			RT_TRACE(COMP_ERR, "WIRELESS_MODE_G but channel>14");
 			return false;
 		}
@@ -1433,7 +1433,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 
 			if (priv->cck_present_attentuation > 22)
 				priv->cck_present_attentuation = 22;
-			if (priv->cck_present_attentuation< 0)
+			if (priv->cck_present_attentuation < 0)
 				priv->cck_present_attentuation = 0;
 			RT_TRACE(COMP_INIT, "20M, pHalData->CCKPresentAttentuation = %d\n", priv->cck_present_attentuation);
 
@@ -1467,7 +1467,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			if (priv->chan == 14 && !priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = true;
 				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
-			} else if (priv->chan!= 14 && priv->bcck_in_ch14) {
+			} else if (priv->chan != 14 && priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = false;
 				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
 			} else {
@@ -1532,9 +1532,9 @@ void rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH Bandwidth,
 
 	priv->CurrentChannelBW = Bandwidth;
 
-	if (Offset==HT_EXTCHNL_OFFSET_LOWER)
+	if (Offset == HT_EXTCHNL_OFFSET_LOWER)
 		priv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_UPPER;
-	else if (Offset==HT_EXTCHNL_OFFSET_UPPER)
+	else if (Offset == HT_EXTCHNL_OFFSET_UPPER)
 		priv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_LOWER;
 	else
 		priv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_DONT_CARE;

commit 111857c983e96e7c70593d0c713985b3ece08c9d
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Tue Jun 18 05:29:37 2013 +0300

    staging: rtl8192u: fix spaces around ';' in r819xU_phy.c
    
    This patch fixes the whitespace around ';' to meet the
    linux kernel coding style.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 95f19b9808f6..fc52c785b16e 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -656,7 +656,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 	WriteAddr[HW90_BLOCK_PHY1] = 0x800;
 	WriteAddr[HW90_BLOCK_RF] = 0x3;
 	RT_TRACE(COMP_PHY, "=======>%s(), CheckBlock:%d\n", __FUNCTION__, CheckBlock);
-	for (i = 0 ; i < CheckTimes ; i++) {
+	for (i = 0; i < CheckTimes; i++) {
 
 		//
 		// Write Data to register and readback
@@ -732,7 +732,7 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 		rtStatus  = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem, (RF90_RADIO_PATH_E)0); //don't care RF path
 		if (rtStatus != 0) {
 			RT_TRACE((COMP_ERR | COMP_PHY), "PHY_RF8256_Config():Check PHY%d Fail!!\n", eCheckItem-1);
-			return ;
+			return;
 		}
 	}
 	/*---- Set CCK and OFDM Block "OFF"----*/
@@ -894,7 +894,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 
 	switch (eRFPath) {
 	case RF90_PATH_A:
-		for (i = 0;i<RadioA_ArrayLength; i = i+2) {
+		for (i = 0; i<RadioA_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioA_Array[i] == 0xfe) {
 					mdelay(100);
@@ -906,7 +906,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		}
 		break;
 	case RF90_PATH_B:
-		for (i = 0;i<RadioB_ArrayLength; i = i+2) {
+		for (i = 0; i<RadioB_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioB_Array[i] == 0xfe) {
 					mdelay(100);
@@ -918,7 +918,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		}
 		break;
 	case RF90_PATH_C:
-		for (i = 0;i<RadioC_ArrayLength; i = i+2) {
+		for (i = 0; i<RadioC_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioC_Array[i] == 0xfe) {
 					mdelay(100);
@@ -930,7 +930,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		}
 		break;
 	case RF90_PATH_D:
-		for (i = 0;i<RadioD_ArrayLength; i = i+2) {
+		for (i = 0; i<RadioD_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioD_Array[i] == 0xfe) {
 					mdelay(100);

commit ec5d319bbf508442b8b0c2bdc3f05a94b3a67f20
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Tue Jun 18 05:29:36 2013 +0300

    staging: rtl8192u: fix spaces around '=' in r819xU_phy.c
    
    This patch fixes the whitespace around the assignment
    operator to meet linux kernel coding style.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 66ab3d591f26..95f19b9808f6 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -111,7 +111,7 @@ u32 rtl8192_QueryBBReg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask)
 
 	read_nic_dword(dev, dwRegAddr, &OriginalValue);
 	BitShift = rtl8192_CalculateBitShift(dwBitMask);
-	Ret =(OriginalValue & dwBitMask) >> BitShift;
+	Ret = (OriginalValue & dwBitMask) >> BitShift;
 
 	return Ret;
 }
@@ -470,7 +470,7 @@ void rtl8192_phy_configmac(struct net_device *dev)
 		dwArrayLen = MACPHY_ArrayLength;
 		pdwArray = rtl819XMACPHY_Array;
 	}
-	for (i = 0; i<dwArrayLen; i=i+3) {
+	for (i = 0; i<dwArrayLen; i = i+3) {
 		if (pdwArray[i] == 0x318) {
 			pdwArray[i+2] = 0x00000800;
 		}
@@ -506,12 +506,12 @@ void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 	}
 #endif
 	if (ConfigType == BaseBand_Config_PHY_REG) {
-		for (i=0; i<PHY_REG_1T2RArrayLength; i+=2) {
+		for (i = 0; i<PHY_REG_1T2RArrayLength; i += 2) {
 			rtl8192_setBBreg(dev, rtl819XPHY_REG_1T2RArray[i], bMaskDWord, rtl819XPHY_REG_1T2RArray[i+1]);
 			RT_TRACE(COMP_DBG, "i: %x, The Rtl819xUsbPHY_REGArray[0] is %x Rtl819xUsbPHY_REGArray[1] is %x \n",i, rtl819XPHY_REG_1T2RArray[i], rtl819XPHY_REG_1T2RArray[i+1]);
 		}
 	} else if (ConfigType == BaseBand_Config_AGC_TAB) {
-		for (i=0; i<AGCTAB_ArrayLength; i+=2) {
+		for (i = 0; i<AGCTAB_ArrayLength; i += 2) {
 			rtl8192_setBBreg(dev, rtl819XAGCTAB_Array[i], bMaskDWord, rtl819XAGCTAB_Array[i+1]);
 			RT_TRACE(COMP_DBG, "i:%x, The rtl819XAGCTAB_Array[0] is %x rtl819XAGCTAB_Array[1] is %x \n",i, rtl819XAGCTAB_Array[i], rtl819XAGCTAB_Array[i+1]);
 		}
@@ -656,7 +656,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
 	WriteAddr[HW90_BLOCK_PHY1] = 0x800;
 	WriteAddr[HW90_BLOCK_RF] = 0x3;
 	RT_TRACE(COMP_PHY, "=======>%s(), CheckBlock:%d\n", __FUNCTION__, CheckBlock);
-	for (i=0 ; i < CheckTimes ; i++) {
+	for (i = 0 ; i < CheckTimes ; i++) {
 
 		//
 		// Write Data to register and readback
@@ -728,7 +728,7 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 
 	/*----Ckeck FPGAPHY0 and PHY1 board is OK----*/
 	// TODO: this function should be removed on ASIC , Emily 2007.2.2
-	for (eCheckItem=(HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem<=HW90_BLOCK_PHY1; eCheckItem++) {
+	for (eCheckItem = (HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem<=HW90_BLOCK_PHY1; eCheckItem++) {
 		rtStatus  = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem, (RF90_RADIO_PATH_E)0); //don't care RF path
 		if (rtStatus != 0) {
 			RT_TRACE((COMP_ERR | COMP_PHY), "PHY_RF8256_Config():Check PHY%d Fail!!\n", eCheckItem-1);
@@ -894,7 +894,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 
 	switch (eRFPath) {
 	case RF90_PATH_A:
-		for (i = 0;i<RadioA_ArrayLength; i=i+2) {
+		for (i = 0;i<RadioA_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioA_Array[i] == 0xfe) {
 					mdelay(100);
@@ -906,7 +906,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		}
 		break;
 	case RF90_PATH_B:
-		for (i = 0;i<RadioB_ArrayLength; i=i+2) {
+		for (i = 0;i<RadioB_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioB_Array[i] == 0xfe) {
 					mdelay(100);
@@ -918,7 +918,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		}
 		break;
 	case RF90_PATH_C:
-		for (i = 0;i<RadioC_ArrayLength; i=i+2) {
+		for (i = 0;i<RadioC_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioC_Array[i] == 0xfe) {
 					mdelay(100);
@@ -930,7 +930,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
 		}
 		break;
 	case RF90_PATH_D:
-		for (i = 0;i<RadioD_ArrayLength; i=i+2) {
+		for (i = 0;i<RadioD_ArrayLength; i = i+2) {
 
 			if (rtl819XRadioD_Array[i] == 0xfe) {
 					mdelay(100);
@@ -1224,23 +1224,23 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
 		do {
 			switch (*stage) {
 			case 0:
-				CurrentCmd=&PreCommonCmd[*step];
+				CurrentCmd = &PreCommonCmd[*step];
 				break;
 			case 1:
-				CurrentCmd=&RfDependCmd[*step];
+				CurrentCmd = &RfDependCmd[*step];
 				break;
 			case 2:
-				CurrentCmd=&PostCommonCmd[*step];
+				CurrentCmd = &PostCommonCmd[*step];
 				break;
 			}
 
 			if (CurrentCmd->CmdID==CmdID_End) {
 				if ((*stage)==2) {
-					(*delay)=CurrentCmd->msDelay;
+					(*delay) = CurrentCmd->msDelay;
 					return true;
 				} else {
 					(*stage)++;
-					(*step)=0;
+					(*step) = 0;
 					continue;
 				}
 			}
@@ -1271,7 +1271,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
 			break;
 		} while (true);
 
-	(*delay)=CurrentCmd->msDelay;
+	(*delay) = CurrentCmd->msDelay;
 	(*step)++;
 	return false;
 }
@@ -1360,10 +1360,10 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 	if (channel == 0)
 		channel = 1;
 
-	priv->chan=channel;
+	priv->chan = channel;
 
-	priv->SwChnlStage=0;
-	priv->SwChnlStep=0;
+	priv->SwChnlStage = 0;
+	priv->SwChnlStep = 0;
 	if (priv->up)
 	rtl8192_SwChnl_WorkItem(dev);
 
@@ -1394,7 +1394,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 
 
 	if (priv->rf_chip == RF_PSEUDO_11N) {
-		priv->SetBWModeInProgress= false;
+		priv->SetBWModeInProgress = false;
 		return;
 	}
 
@@ -1432,7 +1432,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 				priv->cck_present_attentuation_20Mdefault + priv->cck_present_attentuation_difference;
 
 			if (priv->cck_present_attentuation > 22)
-				priv->cck_present_attentuation= 22;
+				priv->cck_present_attentuation = 22;
 			if (priv->cck_present_attentuation< 0)
 				priv->cck_present_attentuation = 0;
 			RT_TRACE(COMP_INIT, "20M, pHalData->CCKPresentAttentuation = %d\n", priv->cck_present_attentuation);
@@ -1506,7 +1506,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			RT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);
 			break;
 	}
-	priv->SetBWModeInProgress= false;
+	priv->SetBWModeInProgress = false;
 
 	RT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb(), %d", atomic_read(&(priv->ieee80211->atm_swbw)));
 }
@@ -1528,7 +1528,7 @@ void rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH Bandwidth,
 
 	if (priv->SetBWModeInProgress)
 		return;
-	priv->SetBWModeInProgress= true;
+	priv->SetBWModeInProgress = true;
 
 	priv->CurrentChannelBW = Bandwidth;
 

commit 442543d78c1059f3db655e1161611a50f189b06a
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sat Jun 15 07:29:08 2013 +0300

    staging: rtl8192u: fix function arguments position in r819xU_phy.c
    
    This patch fixes the alignment of function arguments to make
    it uniform across the driver trying to keep the line size
    below 80 characters.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index d91d1dee24f3..66ab3d591f26 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -80,7 +80,8 @@ u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 eRFPath)
  *  return:  none
  *  notice:
  * ****************************************************************************/
-void rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask, u32 dwData)
+void rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask,
+		      u32 dwData)
 {
 
 	u32 OriginalValue, BitShift, NewValue;
@@ -114,9 +115,12 @@ u32 rtl8192_QueryBBReg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask)
 
 	return Ret;
 }
-static  u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E       eRFPath, u32 Offset);
+static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
+			      u32 Offset);
 
-static void phy_FwRFSerialWrite(struct net_device *dev, RF90_RADIO_PATH_E       eRFPath, u32  Offset, u32  Data);
+static void phy_FwRFSerialWrite(struct net_device *dev,
+				RF90_RADIO_PATH_E eRFPath, u32  Offset,
+				u32  Data);
 
 /******************************************************************************
  *function:  This function read register from RF chip
@@ -127,7 +131,8 @@ static void phy_FwRFSerialWrite(struct net_device *dev, RF90_RADIO_PATH_E
  *  return:  u32	readback value
  *  notice:  There are three types of serial operations:(1) Software serial write.(2)Hardware LSSI-Low Speed Serial Interface.(3)Hardware HSSI-High speed serial write. Driver here need to implement (1) and (2)---need more spec for this information.
  * ****************************************************************************/
-u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u32 Offset)
+u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
+			     u32 Offset)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 ret = 0;
@@ -208,7 +213,8 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
  * Reg_Mode2	1		1			Reg 31 ~ 45(0x1 ~ 0xf)
  *------------------------------------------------------------------
  * ****************************************************************************/
-void rtl8192_phy_RFSerialWrite(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data)
+void rtl8192_phy_RFSerialWrite(struct net_device *dev,
+			       RF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 DataAndAddr = 0, NewOffset = 0;
@@ -269,7 +275,8 @@ void rtl8192_phy_RFSerialWrite(struct net_device *dev, RF90_RADIO_PATH_E eRFPath
  *  return:  none
  *  notice:
  * ****************************************************************************/
-void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask, u32 Data)
+void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
+			  u32 RegAddr, u32 BitMask, u32 Data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 Original_Value, BitShift, New_Value;
@@ -313,7 +320,8 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u32
  *  return:  u32	Data	//the readback register value
  *  notice:
  * ****************************************************************************/
-u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask)
+u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
+			   u32 RegAddr, u32 BitMask)
 {
 	u32 Original_Value, Readback_Value, BitShift;
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -341,11 +349,8 @@ u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u3
  *  return:  none
  *  notice:
  * ***************************************************************************/
-static	u32
-phy_FwRFSerialRead(
-	struct net_device *dev,
-	RF90_RADIO_PATH_E	eRFPath,
-	u32				Offset	)
+static u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
+			      u32 Offset)
 {
 	u32		retValue = 0;
 	u32		Data = 0;
@@ -399,12 +404,8 @@ phy_FwRFSerialRead(
  *  return:  none
  *  notice:
  * ***************************************************************************/
-static void
-phy_FwRFSerialWrite(
-		struct net_device *dev,
-		RF90_RADIO_PATH_E	eRFPath,
-		u32				Offset,
-		u32				Data	)
+static void phy_FwRFSerialWrite(struct net_device *dev,
+				RF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data)
 {
 	u8	time = 0;
 	u32	tmp;
@@ -642,7 +643,8 @@ void rtl8192_InitBBRFRegDef(struct net_device *dev)
  *  return:  return whether BB and RF is ok(0:OK; 1:Fail)
  *  notice:  This function may be removed in the ASIC
  * ***************************************************************************/
-u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock, RF90_RADIO_PATH_E eRFPath)
+u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,
+			    RF90_RADIO_PATH_E eRFPath)
 {
 	u8 ret = 0;
 	u32 i, CheckTimes = 4, dwRegRead = 0;
@@ -883,7 +885,8 @@ void rtl8192_phy_updateInitGain(struct net_device *dev)
  *  return:  return code show if RF configuration is successful(0:pass, 1:fail)
  *    Note:  Delay may be required for RF configuration
  * ***************************************************************************/
-u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E	eRFPath)
+u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,
+				      RF90_RADIO_PATH_E	eRFPath)
 {
 
 	int i;
@@ -989,7 +992,8 @@ void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
  *  return:  none
  *    Note:
  * ***************************************************************************/
-bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerState)
+bool rtl8192_SetRFPowerState(struct net_device *dev,
+			     RT_RF_POWER_STATE eRFPowerState)
 {
 	bool				bResult = true;
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -1112,15 +1116,9 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
  *  return:  true if finished, false otherwise
  *    Note:
  * ************************************************************************************/
-u8 rtl8192_phy_SetSwChnlCmdArray(
-	SwChnlCmd		*CmdTable,
-	u32			CmdTableIdx,
-	u32			CmdTableSz,
-	SwChnlCmdID		CmdID,
-	u32			Para1,
-	u32			Para2,
-	u32			msDelay
-	)
+u8 rtl8192_phy_SetSwChnlCmdArray(SwChnlCmd *CmdTable, u32 CmdTableIdx,
+				 u32 CmdTableSz, SwChnlCmdID CmdID, u32 Para1,
+				 u32 Para2, u32 msDelay)
 {
 	SwChnlCmd *pCmd;
 
@@ -1153,7 +1151,8 @@ u8 rtl8192_phy_SetSwChnlCmdArray(
  *  return:  true if finished, false otherwise
  *    Note:  Wait for simpler function to replace it //wb
  * ***************************************************************************/
-u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u8 *step, u32 *delay)
+u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage,
+				u8 *step, u32 *delay)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	SwChnlCmd				PreCommonCmd[MAX_PRECMD_CNT];
@@ -1522,7 +1521,8 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
  *    Note:  I doubt whether SetBWModeInProgress flag is necessary as we can
  *	     test whether current work in the queue or not.//do I?
  * ***************************************************************************/
-void rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH	Bandwidth, HT_EXTCHNL_OFFSET Offset)
+void rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH Bandwidth,
+		       HT_EXTCHNL_OFFSET Offset)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 

commit ceb5659758bcbad16e4f385afd4314ec00a0321e
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sat Jun 15 07:29:07 2013 +0300

    staging: rtl8192u: fix spaces around ( and ) in r819xU_phy.c
    
    This patch removes whitespace after ')' and before ')'
    following the linux kernel coding style conventions.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 0d0f6226f70d..d91d1dee24f3 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -114,9 +114,9 @@ u32 rtl8192_QueryBBReg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask)
 
 	return Ret;
 }
-static  u32 phy_FwRFSerialRead( struct net_device *dev, RF90_RADIO_PATH_E       eRFPath, u32 Offset  );
+static  u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E       eRFPath, u32 Offset);
 
-static void phy_FwRFSerialWrite( struct net_device *dev, RF90_RADIO_PATH_E       eRFPath, u32  Offset, u32  Data);
+static void phy_FwRFSerialWrite(struct net_device *dev, RF90_RADIO_PATH_E       eRFPath, u32  Offset, u32  Data);
 
 /******************************************************************************
  *function:  This function read register from RF chip
@@ -142,14 +142,14 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 		if (Offset >= 31) {
 			priv->RfReg0Value[eRFPath] |= 0x140;
 			//Switch to Reg_Mode2 for Reg 31-45
-			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16) );
+			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));
 			//modify offset
 			NewOffset = Offset -30;
 		} else if (Offset >= 16) {
 			priv->RfReg0Value[eRFPath] |= 0x100;
 			priv->RfReg0Value[eRFPath] &= (~0x40);
 			//Switch to Reg_Mode 1 for Reg16-30
-			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16) );
+			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));
 
 			NewOffset = Offset - 15;
 		} else {
@@ -1004,7 +1004,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 
 	switch (priv->rf_chip) {
 		case RF_8256:
-		switch ( eRFPowerState ) {
+		switch (eRFPowerState) {
 			case eRfOn:
 	//RF-A, RF-B
 					//enable RF-Chip A/B
@@ -1057,14 +1057,14 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 	if (bResult) {
 		// Update current RF state variable.
 		pHalData->eRFPowerState = eRFPowerState;
-		switch (pHalData->RFChipID ) {
+		switch (pHalData->RFChipID) {
 			case RF_8256:
 		switch (pHalData->eRFPowerState) {
 				case eRfOff:
 					//
 					//If Rf off reason is from IPS, Led should blink with no link, by Maddest 071015
 					//
-					if (pMgntInfo->RfOffReason==RF_CHANGE_BY_IPS )
+					if (pMgntInfo->RfOffReason==RF_CHANGE_BY_IPS)
 						Adapter->HalFunc.LedControlHandler(Adapter,LED_CTL_NO_LINK);
 					else
 						// Turn off LED if RF is not ON.
@@ -1074,7 +1074,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 				case eRfOn:
 					// Turn on RF we are still linked, which might happen when
 					// we quickly turn off and on HW RF. 2006.05.12, by rcnjko.
-					if ( pMgntInfo->bMediaConnect == TRUE )
+					if (pMgntInfo->bMediaConnect == TRUE)
 						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_LINK);
 					else
 						// Turn off LED if RF is not ON.
@@ -1188,7 +1188,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 
 		// <3> Fill up RF dependent command.
 		RfDependCmdCnt = 0;
-		switch ( priv->rf_chip ) {
+		switch (priv->rf_chip) {
 		case RF_8225:
 			if (!(channel >= 1 && channel <= 14)) {
 				RT_TRACE(COMP_ERR, "illegal channel for Zebra 8225: %d\n", channel);
@@ -1484,7 +1484,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	//Skip over setting of J-mode in BB register here. Default value is "None J mode". Emily 20070315
 
 	//<3>Set RF related register
-	switch ( priv->rf_chip ) {
+	switch (priv->rf_chip) {
 		case RF_8225:
 #ifdef TO_DO_LIST
 			PHY_SetRF8225Bandwidth(Adapter, pHalData->CurrentChannelBW);
@@ -1509,7 +1509,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	}
 	priv->SetBWModeInProgress= false;
 
-	RT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb(), %d", atomic_read(&(priv->ieee80211->atm_swbw)) );
+	RT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb(), %d", atomic_read(&(priv->ieee80211->atm_swbw)));
 }
 
 /******************************************************************************

commit d75340eb052c8fb9be7fe8565accd836fb755a66
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sat Jun 15 07:29:06 2013 +0300

    staging: rtl8192u: remove commented-out code in r819xU_phy.c
    
    This patch removes commented-out code to improve code
    readability.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 1dceac4bcd6b..0d0f6226f70d 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -215,8 +215,6 @@ void rtl8192_phy_RFSerialWrite(struct net_device *dev, RF90_RADIO_PATH_E eRFPath
 	BB_REGISTER_DEFINITION_T	*pPhyReg = &priv->PHYRegDef[eRFPath];
 
 	Offset &= 0x3f;
-	//spin_lock_irqsave(&priv->rf_lock, flags);
-//	down(&priv->rf_sem);
 	if (priv->rf_chip == RF_8256) {
 
 		if (Offset >= 31) {
@@ -257,8 +255,6 @@ void rtl8192_phy_RFSerialWrite(struct net_device *dev, RF90_RADIO_PATH_E eRFPath
 				(priv->RfReg0Value[eRFPath] << 16));
 		}
 	}
-	//spin_unlock_irqrestore(&priv->rf_lock, flags);
-//	up(&priv->rf_sem);
 	return;
 }
 
@@ -277,7 +273,6 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u32
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 Original_Value, BitShift, New_Value;
-//	u8	time = 0;
 
 	if (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))
 		return;
@@ -356,18 +351,15 @@ phy_FwRFSerialRead(
 	u32		Data = 0;
 	u8		time = 0;
 	u32		tmp;
-	//DbgPrint("FW RF CTRL\n\r");
 	/* 2007/11/02 MH Firmware RF Write control. By Francis' suggestion, we can
 	   not execute the scheme in the initial step. Otherwise, RF-R/W will waste
 	   much time. This is only for site survey. */
 	// 1. Read operation need not insert data. bit 0-11
-	//Data &= bMask12Bits;
 	// 2. Write RF register address. Bit 12-19
 	Data |= ((Offset&0xFF)<<12);
 	// 3. Write RF path.  bit 20-21
 	Data |= ((eRFPath&0x3)<<20);
 	// 4. Set RF read indicator. bit 22=0
-	//Data |= 0x00000;
 	// 5. Trigger Fw to operate the command. bit 31
 	Data |= 0x80000000;
 	// 6. We can not execute read operation if bit 31 is 1.
@@ -375,7 +367,6 @@ phy_FwRFSerialRead(
 	while (tmp & 0x80000000) {
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
 		if (time++ < 100) {
-			//DbgPrint("FW not finish RF-R Time=%d\n\r", time);
 			udelay(10);
 			read_nic_dword(dev, QPNR, &tmp);
 		} else {
@@ -389,7 +380,6 @@ phy_FwRFSerialRead(
 	while (tmp & 0x80000000) {
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
 		if (time++ < 100) {
-			//DbgPrint("FW not finish RF-W Time=%d\n\r", time);
 			udelay(10);
 			read_nic_dword(dev, QPNR, &tmp);
 		} else {
@@ -419,13 +409,11 @@ phy_FwRFSerialWrite(
 	u8	time = 0;
 	u32	tmp;
 
-	//DbgPrint("N FW RF CTRL RF-%d OF%02x DATA=%03x\n\r", eRFPath, Offset, Data);
 	/* 2007/11/02 MH Firmware RF Write control. By Francis' suggestion, we can
 	   not execute the scheme in the initial step. Otherwise, RF-R/W will waste
 	   much time. This is only for site survey. */
 
 	// 1. Set driver write bit and 12 bit data. bit 0-11
-	//Data &= bMask12Bits;	// Done by uper layer.
 	// 2. Write RF register address. bit 12-19
 	Data |= ((Offset&0xFF)<<12);
 	// 3. Write RF path.  bit 20-21
@@ -440,7 +428,6 @@ phy_FwRFSerialWrite(
 	while (tmp & 0x80000000) {
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
 		if (time++ < 100) {
-			//DbgPrint("FW not finish RF-W Time=%d\n\r", time);
 			udelay(10);
 			read_nic_dword(dev, QPNR, &tmp);
 		} else {
@@ -453,7 +440,6 @@ phy_FwRFSerialWrite(
 	/* 2007/11/02 MH Acoording to test, we must delay 20us to wait firmware
 	   to finish RF write operation. */
 	/* 2008/01/17 MH We support delay in firmware side now. */
-	//delay_us(20);
 
 }	/* phy_FwRFSerialWrite */
 
@@ -486,8 +472,6 @@ void rtl8192_phy_configmac(struct net_device *dev)
 	for (i = 0; i<dwArrayLen; i=i+3) {
 		if (pdwArray[i] == 0x318) {
 			pdwArray[i+2] = 0x00000800;
-			//DbgPrint("ptrArray[i], ptrArray[i+1], ptrArray[i+2] = %x, %x, %x\n",
-			//	ptrArray[i], ptrArray[i+1], ptrArray[i+2]);
 		}
 
 		RT_TRACE(COMP_DBG, "The Rtl8190MACPHY_Array[0] is %x Rtl8190MACPHY_Array[1] is %x Rtl8190MACPHY_Array[2] is %x\n",
@@ -660,8 +644,6 @@ void rtl8192_InitBBRFRegDef(struct net_device *dev)
  * ***************************************************************************/
 u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock, RF90_RADIO_PATH_E eRFPath)
 {
-//	struct r8192_priv *priv = ieee80211_priv(dev);
-//	BB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[eRFPath];
 	u8 ret = 0;
 	u32 i, CheckTimes = 4, dwRegRead = 0;
 	u32 WriteAddr[4];
@@ -856,8 +838,6 @@ void rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)
 		PHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);
 		break;
 	default:
-//	case RF_8225:
-//	case RF_8258:
 		RT_TRACE((COMP_PHY|COMP_ERR), "error RF chipID(8225 or 8258) in function %s()\n", __FUNCTION__);
 		break;
 	}
@@ -878,8 +858,6 @@ void rtl8192_phy_RFConfig(struct net_device *dev)
 		case RF_8256:
 			PHY_RF8256_Config(dev);
 			break;
-	//	case RF_8225:
-	//	case RF_8258:
 		default:
 			RT_TRACE(COMP_ERR, "error chip id\n");
 			break;
@@ -909,7 +887,6 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 {
 
 	int i;
-	//u32* pRFArray;
 	u8 ret = 0;
 
 	switch (eRFPath) {
@@ -1015,7 +992,6 @@ void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
 bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerState)
 {
 	bool				bResult = true;
-//	u8					eRFPath;
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
 	if (eRFPowerState == priv->ieee80211->eRFPowerState)
@@ -1180,7 +1156,6 @@ u8 rtl8192_phy_SetSwChnlCmdArray(
 u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u8 *step, u32 *delay)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-//	PCHANNEL_ACCESS_SETTING	pChnlAccessSetting;
 	SwChnlCmd				PreCommonCmd[MAX_PRECMD_CNT];
 	u32					PreCommonCmdCnt;
 	SwChnlCmd				PostCommonCmd[MAX_POSTCMD_CNT];
@@ -1188,13 +1163,9 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 	SwChnlCmd				RfDependCmd[MAX_RFDEPENDCMD_CNT];
 	u32					RfDependCmdCnt;
 	SwChnlCmd				*CurrentCmd = NULL;
-	//RF90_RADIO_PATH_E		eRFPath;
 	u8		eRFPath;
-//	u32		RfRetVal;
-//	u8		RetryCnt;
 
 	RT_TRACE(COMP_CH, "====>%s()====stage:%d, step:%d, channel:%d\n", __FUNCTION__, *stage, *step, channel);
-//	RT_ASSERT(IsLegalChannel(Adapter, channel), ("illegal channel: %d\n", channel));
 	if (!IsLegalChannel(priv->ieee80211, channel)) {
 		RT_TRACE(COMP_ERR, "=============>set to illegal channel:%d\n", channel);
 		return true; //return true to tell upper caller function this channel setting is finished! Or it will in while loop.
@@ -1202,11 +1173,6 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 //FIXME:need to check whether channel is legal or not here.WB
 
 
-	//for(eRFPath = RF90_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
-//	for(eRFPath = 0; eRFPath <RF90_PATH_MAX; eRFPath++)
-//	{
-//		if (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))
-//			continue;
 		// <1> Fill up pre common command.
 		PreCommonCmdCnt = 0;
 		rtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT,
@@ -1305,7 +1271,6 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 
 			break;
 		} while (true);
-//	}/*for(Number of RF paths)*/
 
 	(*delay)=CurrentCmd->msDelay;
 	(*step)++;
@@ -1326,8 +1291,6 @@ void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
 	u32	delay = 0;
 
 	while (!rtl8192_phy_SwChnlStepByStep(dev,channel,&priv->SwChnlStage,&priv->SwChnlStep,&delay)) {
-	//	if(delay>0)
-	//		msleep(delay);//or mdelay? need further consideration
 		if (!priv->up)
 			break;
 	}
@@ -1369,8 +1332,6 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 	if (priv->SwChnlInProgress)
 		return false;
 
-//	if(pHalData->SetBWModeInProgress)
-//		return;
 	//--------------------------------------------
 	switch (priv->ieee80211->mode) {
 	case WIRELESS_MODE_A:
@@ -1404,12 +1365,8 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 
 	priv->SwChnlStage=0;
 	priv->SwChnlStep=0;
-//	schedule_work(&(priv->SwChnlWorkItem));
-//	rtl8192_SwChnl_WorkItem(dev);
-	if (priv->up) {
-//		queue_work(priv->priv_wq,&(priv->SwChnlWorkItem));
+	if (priv->up)
 	rtl8192_SwChnl_WorkItem(dev);
-	}
 
 	priv->SwChnlInProgress = false;
 	return true;
@@ -1582,8 +1539,6 @@ void rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH	Bandwidth, HT_EX
 	else
 		priv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 
-	//queue_work(priv->priv_wq, &(priv->SetBWModeWorkItem));
-	//	schedule_work(&(priv->SetBWModeWorkItem));
 	rtl8192_SetBWModeWorkItem(dev);
 
 }
@@ -1614,7 +1569,7 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 	switch (Operation) {
 		case IG_Backup:
 			RT_TRACE(COMP_SCAN, "IG_Backup, backup the initial gain.\n");
-			initial_gain = SCAN_RX_INITIAL_GAIN;//priv->DefaultInitialGain[0];//
+			initial_gain = SCAN_RX_INITIAL_GAIN;
 			BitMask = bMaskByte0;
 			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
 				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	// FW DIG OFF
@@ -1664,9 +1619,7 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 #ifdef RTL8192E
 			SetTxPowerLevel8190(Adapter,priv->CurrentChannel);
 #endif
-//#ifdef RTL8192U
 			rtl8192_phy_setTxPower(dev,priv->ieee80211->current_network.channel);
-//#endif
 
 			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
 				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);	// FW DIG ON

commit eadb188c780f0d02bf2f828191cb8d2917ef3d8c
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sat Jun 15 07:29:05 2013 +0300

    staging: rtl8192u: fix spaces around for and while in r819xU_phy.c
    
    This patch fixes whitespace around 'for' and 'while'
    following the linux kernel coding style conventions.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index c5fe552ce4a7..1dceac4bcd6b 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -483,7 +483,7 @@ void rtl8192_phy_configmac(struct net_device *dev)
 		dwArrayLen = MACPHY_ArrayLength;
 		pdwArray = rtl819XMACPHY_Array;
 	}
-	for(i = 0; i<dwArrayLen; i=i+3) {
+	for (i = 0; i<dwArrayLen; i=i+3) {
 		if (pdwArray[i] == 0x318) {
 			pdwArray[i+2] = 0x00000800;
 			//DbgPrint("ptrArray[i], ptrArray[i+1], ptrArray[i+2] = %x, %x, %x\n",
@@ -672,7 +672,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock, RF9
 	WriteAddr[HW90_BLOCK_PHY1] = 0x800;
 	WriteAddr[HW90_BLOCK_RF] = 0x3;
 	RT_TRACE(COMP_PHY, "=======>%s(), CheckBlock:%d\n", __FUNCTION__, CheckBlock);
-	for(i=0 ; i < CheckTimes ; i++) {
+	for (i=0 ; i < CheckTimes ; i++) {
 
 		//
 		// Write Data to register and readback
@@ -744,7 +744,7 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 
 	/*----Ckeck FPGAPHY0 and PHY1 board is OK----*/
 	// TODO: this function should be removed on ASIC , Emily 2007.2.2
-	for(eCheckItem=(HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem<=HW90_BLOCK_PHY1; eCheckItem++) {
+	for (eCheckItem=(HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem<=HW90_BLOCK_PHY1; eCheckItem++) {
 		rtStatus  = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem, (RF90_RADIO_PATH_E)0); //don't care RF path
 		if (rtStatus != 0) {
 			RT_TRACE((COMP_ERR | COMP_PHY), "PHY_RF8256_Config():Check PHY%d Fail!!\n", eCheckItem-1);
@@ -914,7 +914,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 
 	switch (eRFPath) {
 	case RF90_PATH_A:
-		for(i = 0;i<RadioA_ArrayLength; i=i+2) {
+		for (i = 0;i<RadioA_ArrayLength; i=i+2) {
 
 			if (rtl819XRadioA_Array[i] == 0xfe) {
 					mdelay(100);
@@ -926,7 +926,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 		}
 		break;
 	case RF90_PATH_B:
-		for(i = 0;i<RadioB_ArrayLength; i=i+2) {
+		for (i = 0;i<RadioB_ArrayLength; i=i+2) {
 
 			if (rtl819XRadioB_Array[i] == 0xfe) {
 					mdelay(100);
@@ -938,7 +938,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 		}
 		break;
 	case RF90_PATH_C:
-		for(i = 0;i<RadioC_ArrayLength; i=i+2) {
+		for (i = 0;i<RadioC_ArrayLength; i=i+2) {
 
 			if (rtl819XRadioC_Array[i] == 0xfe) {
 					mdelay(100);
@@ -950,7 +950,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 		}
 		break;
 	case RF90_PATH_D:
-		for(i = 0;i<RadioD_ArrayLength; i=i+2) {
+		for (i = 0;i<RadioD_ArrayLength; i=i+2) {
 
 			if (rtl819XRadioD_Array[i] == 0xfe) {
 					mdelay(100);
@@ -1295,7 +1295,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 				write_nic_byte(dev, CurrentCmd->Para1, (u8)CurrentCmd->Para2);
 				break;
 			case CmdID_RF_WriteReg:
-				for(eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {
+				for (eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {
 				rtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, bZebra1_ChannelNum, CurrentCmd->Para2);
 				}
 				break;
@@ -1304,7 +1304,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 			}
 
 			break;
-		} while(true);
+		} while (true);
 //	}/*for(Number of RF paths)*/
 
 	(*delay)=CurrentCmd->msDelay;
@@ -1325,7 +1325,7 @@ void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32	delay = 0;
 
-	while(!rtl8192_phy_SwChnlStepByStep(dev,channel,&priv->SwChnlStage,&priv->SwChnlStep,&delay)) {
+	while (!rtl8192_phy_SwChnlStepByStep(dev,channel,&priv->SwChnlStage,&priv->SwChnlStep,&delay)) {
 	//	if(delay>0)
 	//		msleep(delay);//or mdelay? need further consideration
 		if (!priv->up)

commit 1111b8769ac775f997b15330b06895ca95399eb0
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sat Jun 15 07:29:04 2013 +0300

    staging: rtl8192u: fix spaces around 'if' in r819xU_phy.c
    
    This patch fixes whitepace around 'if' following the linux
    kernel coding style convention.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index f97a703d1687..c5fe552ce4a7 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -85,7 +85,7 @@ void rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask, u32
 
 	u32 OriginalValue, BitShift, NewValue;
 
-	if(dwBitMask!= bMaskDWord) { //if not "double word" write
+	if (dwBitMask!= bMaskDWord) { //if not "double word" write
 		read_nic_dword(dev, dwRegAddr, &OriginalValue);
 		BitShift = rtl8192_CalculateBitShift(dwBitMask);
 		NewValue = (((OriginalValue) & (~dwBitMask)) | (dwData << BitShift));
@@ -174,7 +174,7 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 
 
 	// Switch back to Reg_Mode0;
-	if(priv->rf_chip == RF_8256) {
+	if (priv->rf_chip == RF_8256) {
 		priv->RfReg0Value[eRFPath] &= 0xebf;
 
 		rtl8192_setBBreg(
@@ -243,12 +243,12 @@ void rtl8192_phy_RFSerialWrite(struct net_device *dev, RF90_RADIO_PATH_E eRFPath
 	rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);
 
 
-	if(Offset==0x0)
+	if (Offset==0x0)
 		priv->RfReg0Value[eRFPath] = Data;
 
 	// Switch back to Reg_Mode0;
-	if(priv->rf_chip == RF_8256) {
-		if(Offset != 0) {
+	if (priv->rf_chip == RF_8256) {
+		if (Offset != 0) {
 			priv->RfReg0Value[eRFPath] &= 0xebf;
 			rtl8192_setBBreg(
 				dev,
@@ -473,7 +473,7 @@ void rtl8192_phy_configmac(struct net_device *dev)
 	u32 *pdwArray = NULL;
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
-	if(priv->btxpowerdata_readfromEEPORM) {
+	if (priv->btxpowerdata_readfromEEPORM) {
 		RT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array_PG\n");
 		dwArrayLen = MACPHY_Array_PGLength;
 		pdwArray = rtl819XMACPHY_Array_PG;
@@ -484,7 +484,7 @@ void rtl8192_phy_configmac(struct net_device *dev)
 		pdwArray = rtl819XMACPHY_Array;
 	}
 	for(i = 0; i<dwArrayLen; i=i+3) {
-		if(pdwArray[i] == 0x318) {
+		if (pdwArray[i] == 0x318) {
 			pdwArray[i+2] = 0x00000800;
 			//DbgPrint("ptrArray[i], ptrArray[i+1], ptrArray[i+2] = %x, %x, %x\n",
 			//	ptrArray[i], ptrArray[i+1], ptrArray[i+2]);
@@ -513,7 +513,7 @@ void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 
 #ifdef TO_DO_LIST
 	u32 *rtl8192PhyRegArrayTable = NULL, *rtl8192AgcTabArrayTable = NULL;
-	if(Adapter->bInHctTest) {
+	if (Adapter->bInHctTest) {
 		PHY_REGArrayLen = PHY_REGArrayLengthDTM;
 		AGCTAB_ArrayLen = AGCTAB_ArrayLengthDTM;
 		Rtl8190PHY_REGArray_Table = Rtl819XPHY_REGArrayDTM;
@@ -706,7 +706,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock, RF9
 		//
 		// Check whether readback data is correct
 		//
-		if(dwRegRead != WriteData[i]) {
+		if (dwRegRead != WriteData[i]) {
 			RT_TRACE((COMP_PHY|COMP_ERR), "====>error=====dwRegRead: %x, WriteData: %x \n", dwRegRead, WriteData[i]);
 			ret = 1;
 			break;
@@ -746,7 +746,7 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	// TODO: this function should be removed on ASIC , Emily 2007.2.2
 	for(eCheckItem=(HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem<=HW90_BLOCK_PHY1; eCheckItem++) {
 		rtStatus  = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem, (RF90_RADIO_PATH_E)0); //don't care RF path
-		if(rtStatus != 0) {
+		if (rtStatus != 0) {
 			RT_TRACE((COMP_ERR | COMP_PHY), "PHY_RF8256_Config():Check PHY%d Fail!!\n", eCheckItem-1);
 			return ;
 		}
@@ -916,7 +916,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 	case RF90_PATH_A:
 		for(i = 0;i<RadioA_ArrayLength; i=i+2) {
 
-			if(rtl819XRadioA_Array[i] == 0xfe) {
+			if (rtl819XRadioA_Array[i] == 0xfe) {
 					mdelay(100);
 					continue;
 			}
@@ -928,7 +928,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 	case RF90_PATH_B:
 		for(i = 0;i<RadioB_ArrayLength; i=i+2) {
 
-			if(rtl819XRadioB_Array[i] == 0xfe) {
+			if (rtl819XRadioB_Array[i] == 0xfe) {
 					mdelay(100);
 					continue;
 			}
@@ -940,7 +940,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 	case RF90_PATH_C:
 		for(i = 0;i<RadioC_ArrayLength; i=i+2) {
 
-			if(rtl819XRadioC_Array[i] == 0xfe) {
+			if (rtl819XRadioC_Array[i] == 0xfe) {
 					mdelay(100);
 					continue;
 			}
@@ -952,7 +952,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 	case RF90_PATH_D:
 		for(i = 0;i<RadioD_ArrayLength; i=i+2) {
 
-			if(rtl819XRadioD_Array[i] == 0xfe) {
+			if (rtl819XRadioD_Array[i] == 0xfe) {
 					mdelay(100);
 					continue;
 			}
@@ -1018,10 +1018,10 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 //	u8					eRFPath;
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
-	if(eRFPowerState == priv->ieee80211->eRFPowerState)
+	if (eRFPowerState == priv->ieee80211->eRFPowerState)
 		return false;
 
-	if(priv->SetRFPowerStateInProgress == true)
+	if (priv->SetRFPowerStateInProgress == true)
 		return false;
 
 	priv->SetRFPowerStateInProgress = true;
@@ -1078,7 +1078,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 			break;
 	}
 #ifdef TO_DO_LIST
-	if(bResult) {
+	if (bResult) {
 		// Update current RF state variable.
 		pHalData->eRFPowerState = eRFPowerState;
 		switch (pHalData->RFChipID ) {
@@ -1088,7 +1088,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 					//
 					//If Rf off reason is from IPS, Led should blink with no link, by Maddest 071015
 					//
-					if(pMgntInfo->RfOffReason==RF_CHANGE_BY_IPS )
+					if (pMgntInfo->RfOffReason==RF_CHANGE_BY_IPS )
 						Adapter->HalFunc.LedControlHandler(Adapter,LED_CTL_NO_LINK);
 					else
 						// Turn off LED if RF is not ON.
@@ -1098,7 +1098,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 				case eRfOn:
 					// Turn on RF we are still linked, which might happen when
 					// we quickly turn off and on HW RF. 2006.05.12, by rcnjko.
-					if( pMgntInfo->bMediaConnect == TRUE )
+					if ( pMgntInfo->bMediaConnect == TRUE )
 						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_LINK);
 					else
 						// Turn off LED if RF is not ON.
@@ -1148,11 +1148,11 @@ u8 rtl8192_phy_SetSwChnlCmdArray(
 {
 	SwChnlCmd *pCmd;
 
-	if(CmdTable == NULL) {
+	if (CmdTable == NULL) {
 		RT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): CmdTable cannot be NULL.\n");
 		return false;
 	}
-	if(CmdTableIdx >= CmdTableSz) {
+	if (CmdTableIdx >= CmdTableSz) {
 		RT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): Access invalid index, please check size of the table, CmdTableIdx:%d, CmdTableSz:%d\n",
 				CmdTableIdx, CmdTableSz);
 		return false;
@@ -1269,8 +1269,8 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 				break;
 			}
 
-			if(CurrentCmd->CmdID==CmdID_End) {
-				if((*stage)==2) {
+			if (CurrentCmd->CmdID==CmdID_End) {
+				if ((*stage)==2) {
 					(*delay)=CurrentCmd->msDelay;
 					return true;
 				} else {
@@ -1282,7 +1282,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 
 			switch (CurrentCmd->CmdID) {
 			case CmdID_SetTxPowerLevel:
-				if(priv->card_8192_version == (u8)VERSION_819xU_A) //xiong: consider it later!
+				if (priv->card_8192_version == (u8)VERSION_819xU_A) //xiong: consider it later!
 					rtl8192_SetTxPowerLevel(dev,channel);
 				break;
 			case CmdID_WritePortUlong:
@@ -1328,7 +1328,7 @@ void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
 	while(!rtl8192_phy_SwChnlStepByStep(dev,channel,&priv->SwChnlStage,&priv->SwChnlStep,&delay)) {
 	//	if(delay>0)
 	//		msleep(delay);//or mdelay? need further consideration
-		if(!priv->up)
+		if (!priv->up)
 			break;
 	}
 }
@@ -1364,9 +1364,9 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	RT_TRACE(COMP_CH, "=====>%s(), SwChnlInProgress:%d\n", __FUNCTION__, priv->SwChnlInProgress);
-	if(!priv->up)
+	if (!priv->up)
 		return false;
-	if(priv->SwChnlInProgress)
+	if (priv->SwChnlInProgress)
 		return false;
 
 //	if(pHalData->SetBWModeInProgress)
@@ -1397,7 +1397,7 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 	//--------------------------------------------
 
 	priv->SwChnlInProgress = true;
-	if(channel == 0)
+	if (channel == 0)
 		channel = 1;
 
 	priv->chan=channel;
@@ -1406,7 +1406,7 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 	priv->SwChnlStep=0;
 //	schedule_work(&(priv->SwChnlWorkItem));
 //	rtl8192_SwChnl_WorkItem(dev);
-	if(priv->up) {
+	if (priv->up) {
 //		queue_work(priv->priv_wq,&(priv->SwChnlWorkItem));
 	rtl8192_SwChnl_WorkItem(dev);
 	}
@@ -1437,7 +1437,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 		 priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz");
 
 
-	if(priv->rf_chip == RF_PSEUDO_11N) {
+	if (priv->rf_chip == RF_PSEUDO_11N) {
 		priv->SetBWModeInProgress= false;
 		return;
 	}
@@ -1475,16 +1475,16 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			priv->cck_present_attentuation =
 				priv->cck_present_attentuation_20Mdefault + priv->cck_present_attentuation_difference;
 
-			if(priv->cck_present_attentuation > 22)
+			if (priv->cck_present_attentuation > 22)
 				priv->cck_present_attentuation= 22;
-			if(priv->cck_present_attentuation< 0)
+			if (priv->cck_present_attentuation< 0)
 				priv->cck_present_attentuation = 0;
 			RT_TRACE(COMP_INIT, "20M, pHalData->CCKPresentAttentuation = %d\n", priv->cck_present_attentuation);
 
-			if(priv->chan == 14 && !priv->bcck_in_ch14) {
+			if (priv->chan == 14 && !priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = TRUE;
 				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
-			} else if(priv->chan != 14 && priv->bcck_in_ch14) {
+			} else if (priv->chan != 14 && priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = FALSE;
 				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
 			} else {
@@ -1502,16 +1502,16 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			priv->cck_present_attentuation =
 				priv->cck_present_attentuation_40Mdefault + priv->cck_present_attentuation_difference;
 
-			if(priv->cck_present_attentuation > 22)
+			if (priv->cck_present_attentuation > 22)
 				priv->cck_present_attentuation = 22;
-			if(priv->cck_present_attentuation < 0)
+			if (priv->cck_present_attentuation < 0)
 				priv->cck_present_attentuation = 0;
 
 			RT_TRACE(COMP_INIT, "40M, pHalData->CCKPresentAttentuation = %d\n", priv->cck_present_attentuation);
-			if(priv->chan == 14 && !priv->bcck_in_ch14) {
+			if (priv->chan == 14 && !priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = true;
 				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
-			} else if(priv->chan!= 14 && priv->bcck_in_ch14) {
+			} else if (priv->chan!= 14 && priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = false;
 				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
 			} else {
@@ -1569,15 +1569,15 @@ void rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH	Bandwidth, HT_EX
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
-	if(priv->SetBWModeInProgress)
+	if (priv->SetBWModeInProgress)
 		return;
 	priv->SetBWModeInProgress= true;
 
 	priv->CurrentChannelBW = Bandwidth;
 
-	if(Offset==HT_EXTCHNL_OFFSET_LOWER)
+	if (Offset==HT_EXTCHNL_OFFSET_LOWER)
 		priv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_UPPER;
-	else if(Offset==HT_EXTCHNL_OFFSET_UPPER)
+	else if (Offset==HT_EXTCHNL_OFFSET_UPPER)
 		priv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_LOWER;
 	else
 		priv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
@@ -1594,7 +1594,7 @@ void InitialGain819xUsb(struct net_device *dev,	u8 Operation)
 
 	priv->InitialGainOperateType = Operation;
 
-	if(priv->up)
+	if (priv->up)
 		queue_delayed_work(priv->priv_wq,&priv->initialgain_operate_wq,0);
 }
 
@@ -1616,7 +1616,7 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 			RT_TRACE(COMP_SCAN, "IG_Backup, backup the initial gain.\n");
 			initial_gain = SCAN_RX_INITIAL_GAIN;//priv->DefaultInitialGain[0];//
 			BitMask = bMaskByte0;
-			if(dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
+			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
 				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	// FW DIG OFF
 			priv->initgain_backup.xaagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XAAGCCore1, BitMask);
 			priv->initgain_backup.xbagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XBAGCCore1, BitMask);
@@ -1642,7 +1642,7 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 		case IG_Restore:
 			RT_TRACE(COMP_SCAN, "IG_Restore, restore the initial gain.\n");
 			BitMask = 0x7f; //Bit0~ Bit6
-			if(dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
+			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
 				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	// FW DIG OFF
 
 			rtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, BitMask, (u32)priv->initgain_backup.xaagccore1);
@@ -1668,7 +1668,7 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 			rtl8192_phy_setTxPower(dev,priv->ieee80211->current_network.channel);
 //#endif
 
-			if(dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
+			if (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
 				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);	// FW DIG ON
 			break;
 		default:

commit 4c8dd926200768edbc1cdb2c2e435490809e85ad
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sat Jun 15 07:29:03 2013 +0300

    staging: rtl8192u: fix return statements in r819xU_phy.c
    
    This patch fixes the following checkpatch error:
    ERROR: return is not a function, parentheses are not required
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index d1c3f0453974..f97a703d1687 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -112,7 +112,7 @@ u32 rtl8192_QueryBBReg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask)
 	BitShift = rtl8192_CalculateBitShift(dwBitMask);
 	Ret =(OriginalValue & dwBitMask) >> BitShift;
 
-	return (Ret);
+	return Ret;
 }
 static  u32 phy_FwRFSerialRead( struct net_device *dev, RF90_RADIO_PATH_E       eRFPath, u32 Offset  );
 
@@ -331,12 +331,12 @@ u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u3
 		BitShift =  rtl8192_CalculateBitShift(BitMask);
 		Readback_Value = (Original_Value & BitMask) >> BitShift;
 		udelay(200);
-		return (Readback_Value);
+		return Readback_Value;
 	} else {
 		Original_Value = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
 		BitShift =  rtl8192_CalculateBitShift(BitMask);
 		Readback_Value = (Original_Value & BitMask) >> BitShift;
-		return (Readback_Value);
+		return Readback_Value;
 	}
 }
 /******************************************************************************
@@ -393,12 +393,12 @@ phy_FwRFSerialRead(
 			udelay(10);
 			read_nic_dword(dev, QPNR, &tmp);
 		} else {
-			return	(0);
+			return 0;
 		}
 	}
 	read_nic_dword(dev, RF_DATA, &retValue);
 
-	return	(retValue);
+	return retValue;
 
 }	/* phy_FwRFSerialRead */
 

commit 4a6094c3171233f1f34ec0dfb233fb9b21e2aecf
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sat Jun 15 07:29:02 2013 +0300

    staging: rtl8192u: fix braces in r819xU_phy.c
    
    This patch fixes the brace position and the whitespace
    around braces.
    
    That corrects the following checkpatch errors:
    ERROR: that open brace { should be on the previous line
    ERROR: else should follow close brace '}'
    ERROR: space required after that close brace '}'
    
    Also, it removes completely an if(0) statement,
    instead of correcting its braces.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 70ab9cd0b29f..d1c3f0453974 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -60,10 +60,9 @@ u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 eRFPath)
 {
 	u8 ret = 1;
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	if (priv->rf_type == RF_2T4R)
+	if (priv->rf_type == RF_2T4R) {
 		ret = 0;
-	else if (priv->rf_type == RF_1T2R)
-	{
+	} else if (priv->rf_type == RF_1T2R) {
 		if (eRFPath == RF90_PATH_A || eRFPath == RF90_PATH_B)
 			ret = 1;
 		else if (eRFPath == RF90_PATH_C || eRFPath == RF90_PATH_D)
@@ -86,14 +85,14 @@ void rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask, u32
 
 	u32 OriginalValue, BitShift, NewValue;
 
-	if(dwBitMask!= bMaskDWord)
-	{//if not "double word" write
+	if(dwBitMask!= bMaskDWord) { //if not "double word" write
 		read_nic_dword(dev, dwRegAddr, &OriginalValue);
 		BitShift = rtl8192_CalculateBitShift(dwBitMask);
 		NewValue = (((OriginalValue) & (~dwBitMask)) | (dwData << BitShift));
 		write_nic_dword(dev, dwRegAddr, NewValue);
-	}else
+	} else {
 		write_nic_dword(dev, dwRegAddr, dwData);
+	}
 	return;
 }
 /******************************************************************************
@@ -139,30 +138,24 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 	Offset &= 0x3f;
 
 	//switch page for 8256 RF IC
-	if (priv->rf_chip == RF_8256)
-	{
-		if (Offset >= 31)
-		{
+	if (priv->rf_chip == RF_8256) {
+		if (Offset >= 31) {
 			priv->RfReg0Value[eRFPath] |= 0x140;
 			//Switch to Reg_Mode2 for Reg 31-45
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16) );
 			//modify offset
 			NewOffset = Offset -30;
-		}
-		else if (Offset >= 16)
-		{
+		} else if (Offset >= 16) {
 			priv->RfReg0Value[eRFPath] |= 0x100;
 			priv->RfReg0Value[eRFPath] &= (~0x40);
 			//Switch to Reg_Mode 1 for Reg16-30
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16) );
 
 			NewOffset = Offset - 15;
-		}
-		else
+		} else {
 			NewOffset = Offset;
-	}
-	else
-	{
+		}
+	} else {
 		RT_TRACE((COMP_PHY|COMP_ERR), "check RF type here, need to be 8256\n");
 		NewOffset = Offset;
 	}
@@ -181,8 +174,7 @@ u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,
 
 
 	// Switch back to Reg_Mode0;
-	if(priv->rf_chip == RF_8256)
-	{
+	if(priv->rf_chip == RF_8256) {
 		priv->RfReg0Value[eRFPath] &= 0xebf;
 
 		rtl8192_setBBreg(
@@ -225,27 +217,21 @@ void rtl8192_phy_RFSerialWrite(struct net_device *dev, RF90_RADIO_PATH_E eRFPath
 	Offset &= 0x3f;
 	//spin_lock_irqsave(&priv->rf_lock, flags);
 //	down(&priv->rf_sem);
-	if (priv->rf_chip == RF_8256)
-	{
+	if (priv->rf_chip == RF_8256) {
 
-		if (Offset >= 31)
-		{
+		if (Offset >= 31) {
 			priv->RfReg0Value[eRFPath] |= 0x140;
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath] << 16));
 			NewOffset = Offset - 30;
-		}
-		else if (Offset >= 16)
-		{
+		} else if (Offset >= 16) {
 			priv->RfReg0Value[eRFPath] |= 0x100;
 			priv->RfReg0Value[eRFPath] &= (~0x40);
 			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));
 			NewOffset = Offset - 15;
-		}
-		else
+		} else {
 			NewOffset = Offset;
-	}
-	else
-	{
+		}
+	} else {
 		RT_TRACE((COMP_PHY|COMP_ERR), "check RF type here, need to be 8256\n");
 		NewOffset = Offset;
 	}
@@ -261,10 +247,8 @@ void rtl8192_phy_RFSerialWrite(struct net_device *dev, RF90_RADIO_PATH_E eRFPath
 		priv->RfReg0Value[eRFPath] = Data;
 
 	// Switch back to Reg_Mode0;
-	if(priv->rf_chip == RF_8256)
-	{
-		if(Offset != 0)
-		{
+	if(priv->rf_chip == RF_8256) {
+		if(Offset != 0) {
 			priv->RfReg0Value[eRFPath] &= 0xebf;
 			rtl8192_setBBreg(
 				dev,
@@ -298,32 +282,29 @@ void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u32
 	if (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))
 		return;
 
-	if (priv->Rf_Mode == RF_OP_By_FW)
-	{
-		if (BitMask != bMask12Bits) // RF data is 12 bits only
-		{
+	if (priv->Rf_Mode == RF_OP_By_FW) {
+		if (BitMask != bMask12Bits) { // RF data is 12 bits only
 			Original_Value = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
 			BitShift =  rtl8192_CalculateBitShift(BitMask);
 			New_Value = ((Original_Value) & (~BitMask)) | (Data<< BitShift);
 
 			phy_FwRFSerialWrite(dev, eRFPath, RegAddr, New_Value);
-		}else
+		} else {
 			phy_FwRFSerialWrite(dev, eRFPath, RegAddr, Data);
+		}
 
 		udelay(200);
 
-	}
-	else
-	{
-		if (BitMask != bMask12Bits) // RF data is 12 bits only
-		{
+	} else {
+		if (BitMask != bMask12Bits) { // RF data is 12 bits only
 			Original_Value = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
 			BitShift =  rtl8192_CalculateBitShift(BitMask);
 			New_Value = (((Original_Value) & (~BitMask)) | (Data<< BitShift));
 
 			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, New_Value);
-		}else
+		} else {
 			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, Data);
+		}
 	}
 	return;
 }
@@ -345,16 +326,13 @@ u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u3
 
 	if (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))
 		return 0;
-	if (priv->Rf_Mode == RF_OP_By_FW)
-	{
+	if (priv->Rf_Mode == RF_OP_By_FW) {
 		Original_Value = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
 		BitShift =  rtl8192_CalculateBitShift(BitMask);
 		Readback_Value = (Original_Value & BitMask) >> BitShift;
 		udelay(200);
 		return (Readback_Value);
-	}
-	else
-	{
+	} else {
 		Original_Value = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
 		BitShift =  rtl8192_CalculateBitShift(BitMask);
 		Readback_Value = (Original_Value & BitMask) >> BitShift;
@@ -394,33 +372,29 @@ phy_FwRFSerialRead(
 	Data |= 0x80000000;
 	// 6. We can not execute read operation if bit 31 is 1.
 	read_nic_dword(dev, QPNR, &tmp);
-	while (tmp & 0x80000000)
-	{
+	while (tmp & 0x80000000) {
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
-		if (time++ < 100)
-		{
+		if (time++ < 100) {
 			//DbgPrint("FW not finish RF-R Time=%d\n\r", time);
 			udelay(10);
 			read_nic_dword(dev, QPNR, &tmp);
-		}
-		else
+		} else {
 			break;
+		}
 	}
 	// 7. Execute read operation.
 	write_nic_dword(dev, QPNR, Data);
 	// 8. Check if firmawre send back RF content.
 	read_nic_dword(dev, QPNR, &tmp);
-	while (tmp & 0x80000000)
-	{
+	while (tmp & 0x80000000) {
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
-		if (time++ < 100)
-		{
+		if (time++ < 100) {
 			//DbgPrint("FW not finish RF-W Time=%d\n\r", time);
 			udelay(10);
 			read_nic_dword(dev, QPNR, &tmp);
-		}
-		else
+		} else {
 			return	(0);
+		}
 	}
 	read_nic_dword(dev, RF_DATA, &retValue);
 
@@ -463,17 +437,15 @@ phy_FwRFSerialWrite(
 
 	// 6. Write operation. We can not write if bit 31 is 1.
 	read_nic_dword(dev, QPNR, &tmp);
-	while (tmp & 0x80000000)
-	{
+	while (tmp & 0x80000000) {
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
-		if (time++ < 100)
-		{
+		if (time++ < 100) {
 			//DbgPrint("FW not finish RF-W Time=%d\n\r", time);
 			udelay(10);
 			read_nic_dword(dev, QPNR, &tmp);
-		}
-		else
+		} else {
 			break;
+		}
 	}
 	// 7. No matter check bit. We always force the write. Because FW will
 	//    not accept the command.
@@ -501,22 +473,18 @@ void rtl8192_phy_configmac(struct net_device *dev)
 	u32 *pdwArray = NULL;
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
-	if(priv->btxpowerdata_readfromEEPORM)
-	{
+	if(priv->btxpowerdata_readfromEEPORM) {
 		RT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array_PG\n");
 		dwArrayLen = MACPHY_Array_PGLength;
 		pdwArray = rtl819XMACPHY_Array_PG;
 
-	}
-	else
-	{
+	} else {
 		RT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array\n");
 		dwArrayLen = MACPHY_ArrayLength;
 		pdwArray = rtl819XMACPHY_Array;
 	}
-	for(i = 0; i<dwArrayLen; i=i+3){
-		if(pdwArray[i] == 0x318)
-		{
+	for(i = 0; i<dwArrayLen; i=i+3) {
+		if(pdwArray[i] == 0x318) {
 			pdwArray[i+2] = 0x00000800;
 			//DbgPrint("ptrArray[i], ptrArray[i+1], ptrArray[i+2] = %x, %x, %x\n",
 			//	ptrArray[i], ptrArray[i+1], ptrArray[i+2]);
@@ -545,26 +513,20 @@ void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 
 #ifdef TO_DO_LIST
 	u32 *rtl8192PhyRegArrayTable = NULL, *rtl8192AgcTabArrayTable = NULL;
-	if(Adapter->bInHctTest)
-	{
+	if(Adapter->bInHctTest) {
 		PHY_REGArrayLen = PHY_REGArrayLengthDTM;
 		AGCTAB_ArrayLen = AGCTAB_ArrayLengthDTM;
 		Rtl8190PHY_REGArray_Table = Rtl819XPHY_REGArrayDTM;
 		Rtl8190AGCTAB_Array_Table = Rtl819XAGCTAB_ArrayDTM;
 	}
 #endif
-	if (ConfigType == BaseBand_Config_PHY_REG)
-	{
-		for (i=0; i<PHY_REG_1T2RArrayLength; i+=2)
-		{
+	if (ConfigType == BaseBand_Config_PHY_REG) {
+		for (i=0; i<PHY_REG_1T2RArrayLength; i+=2) {
 			rtl8192_setBBreg(dev, rtl819XPHY_REG_1T2RArray[i], bMaskDWord, rtl819XPHY_REG_1T2RArray[i+1]);
 			RT_TRACE(COMP_DBG, "i: %x, The Rtl819xUsbPHY_REGArray[0] is %x Rtl819xUsbPHY_REGArray[1] is %x \n",i, rtl819XPHY_REG_1T2RArray[i], rtl819XPHY_REG_1T2RArray[i+1]);
 		}
-	}
-	else if (ConfigType == BaseBand_Config_AGC_TAB)
-	{
-		for (i=0; i<AGCTAB_ArrayLength; i+=2)
-		{
+	} else if (ConfigType == BaseBand_Config_AGC_TAB) {
+		for (i=0; i<AGCTAB_ArrayLength; i+=2) {
 			rtl8192_setBBreg(dev, rtl819XAGCTAB_Array[i], bMaskDWord, rtl819XAGCTAB_Array[i+1]);
 			RT_TRACE(COMP_DBG, "i:%x, The rtl819XAGCTAB_Array[0] is %x rtl819XAGCTAB_Array[1] is %x \n",i, rtl819XAGCTAB_Array[i], rtl819XAGCTAB_Array[i+1]);
 		}
@@ -710,14 +672,12 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock, RF9
 	WriteAddr[HW90_BLOCK_PHY1] = 0x800;
 	WriteAddr[HW90_BLOCK_RF] = 0x3;
 	RT_TRACE(COMP_PHY, "=======>%s(), CheckBlock:%d\n", __FUNCTION__, CheckBlock);
-	for(i=0 ; i < CheckTimes ; i++)
-	{
+	for(i=0 ; i < CheckTimes ; i++) {
 
 		//
 		// Write Data to register and readback
 		//
-		switch (CheckBlock)
-		{
+		switch (CheckBlock) {
 		case HW90_BLOCK_MAC:
 			RT_TRACE(COMP_ERR, "PHY_CheckBBRFOK(): Never Write 0x100 here!");
 			break;
@@ -746,8 +706,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock, RF9
 		//
 		// Check whether readback data is correct
 		//
-		if(dwRegRead != WriteData[i])
-		{
+		if(dwRegRead != WriteData[i]) {
 			RT_TRACE((COMP_PHY|COMP_ERR), "====>error=====dwRegRead: %x, WriteData: %x \n", dwRegRead, WriteData[i]);
 			ret = 1;
 			break;
@@ -785,11 +744,9 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 
 	/*----Ckeck FPGAPHY0 and PHY1 board is OK----*/
 	// TODO: this function should be removed on ASIC , Emily 2007.2.2
-	for(eCheckItem=(HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem<=HW90_BLOCK_PHY1; eCheckItem++)
-	{
+	for(eCheckItem=(HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem<=HW90_BLOCK_PHY1; eCheckItem++) {
 		rtStatus  = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem, (RF90_RADIO_PATH_E)0); //don't care RF path
-		if(rtStatus != 0)
-		{
+		if(rtStatus != 0) {
 			RT_TRACE((COMP_ERR | COMP_PHY), "PHY_RF8256_Config():Check PHY%d Fail!!\n", eCheckItem-1);
 			return ;
 		}
@@ -810,8 +767,7 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 
 	/*----Enable XSTAL ----*/
 	write_nic_byte_E(dev, 0x5e, 0x00);
-	if (priv->card_8192_version == (u8)VERSION_819xU_A)
-	{
+	if (priv->card_8192_version == (u8)VERSION_819xU_A) {
 		//Antenna gain offset from B/C/D to A
 		dwRegValue = (priv->AntennaTxPwDiff[1]<<4 | priv->AntennaTxPwDiff[0]);
 		rtl8192_setBBreg(dev, rFPGA0_TxGainStage, (bXBTxAGC|bXCTxAGC), dwRegValue);
@@ -894,8 +850,7 @@ void rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)
 	u8	powerlevel = priv->TxPowerLevelCCK[channel-1];
 	u8	powerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];
 
-	switch (priv->rf_chip)
-	{
+	switch (priv->rf_chip) {
 	case RF_8256:
 		PHY_SetRF8256CCKTxPower(dev, powerlevel); //need further implement
 		PHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);
@@ -919,8 +874,7 @@ void rtl8192_phy_RFConfig(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
-	switch (priv->rf_chip)
-	{
+	switch (priv->rf_chip) {
 		case RF_8256:
 			PHY_RF8256_Config(dev);
 			break;
@@ -958,11 +912,11 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 	//u32* pRFArray;
 	u8 ret = 0;
 
-	switch (eRFPath){
+	switch (eRFPath) {
 	case RF90_PATH_A:
-		for(i = 0;i<RadioA_ArrayLength; i=i+2){
+		for(i = 0;i<RadioA_ArrayLength; i=i+2) {
 
-			if(rtl819XRadioA_Array[i] == 0xfe){
+			if(rtl819XRadioA_Array[i] == 0xfe) {
 					mdelay(100);
 					continue;
 			}
@@ -972,9 +926,9 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 		}
 		break;
 	case RF90_PATH_B:
-		for(i = 0;i<RadioB_ArrayLength; i=i+2){
+		for(i = 0;i<RadioB_ArrayLength; i=i+2) {
 
-			if(rtl819XRadioB_Array[i] == 0xfe){
+			if(rtl819XRadioB_Array[i] == 0xfe) {
 					mdelay(100);
 					continue;
 			}
@@ -984,9 +938,9 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 		}
 		break;
 	case RF90_PATH_C:
-		for(i = 0;i<RadioC_ArrayLength; i=i+2){
+		for(i = 0;i<RadioC_ArrayLength; i=i+2) {
 
-			if(rtl819XRadioC_Array[i] == 0xfe){
+			if(rtl819XRadioC_Array[i] == 0xfe) {
 					mdelay(100);
 					continue;
 			}
@@ -996,9 +950,9 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 		}
 		break;
 	case RF90_PATH_D:
-		for(i = 0;i<RadioD_ArrayLength; i=i+2){
+		for(i = 0;i<RadioD_ArrayLength; i=i+2) {
 
-			if(rtl819XRadioD_Array[i] == 0xfe){
+			if(rtl819XRadioD_Array[i] == 0xfe) {
 					mdelay(100);
 					continue;
 			}
@@ -1028,8 +982,7 @@ void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
 	u8	powerlevel = priv->TxPowerLevelCCK[channel-1];
 	u8	powerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];
 
-	switch (priv->rf_chip)
-	{
+	switch (priv->rf_chip) {
 	case RF_8225:
 #ifdef TO_DO_LIST
 		PHY_SetRF8225CckTxPower(Adapter, powerlevel);
@@ -1073,11 +1026,9 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 
 	priv->SetRFPowerStateInProgress = true;
 
-	switch (priv->rf_chip)
-	{
+	switch (priv->rf_chip) {
 		case RF_8256:
-		switch ( eRFPowerState )
-		{
+		switch ( eRFPowerState ) {
 			case eRfOn:
 	//RF-A, RF-B
 					//enable RF-Chip A/B
@@ -1127,42 +1078,31 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 			break;
 	}
 #ifdef TO_DO_LIST
-	if(bResult)
-	{
+	if(bResult) {
 		// Update current RF state variable.
 		pHalData->eRFPowerState = eRFPowerState;
-		switch (pHalData->RFChipID )
-		{
+		switch (pHalData->RFChipID ) {
 			case RF_8256:
-		switch (pHalData->eRFPowerState)
-				{
+		switch (pHalData->eRFPowerState) {
 				case eRfOff:
 					//
 					//If Rf off reason is from IPS, Led should blink with no link, by Maddest 071015
 					//
 					if(pMgntInfo->RfOffReason==RF_CHANGE_BY_IPS )
-					{
 						Adapter->HalFunc.LedControlHandler(Adapter,LED_CTL_NO_LINK);
-					}
 					else
-					{
 						// Turn off LED if RF is not ON.
 						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_POWER_OFF);
-					}
 					break;
 
 				case eRfOn:
 					// Turn on RF we are still linked, which might happen when
 					// we quickly turn off and on HW RF. 2006.05.12, by rcnjko.
 					if( pMgntInfo->bMediaConnect == TRUE )
-					{
 						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_LINK);
-					}
 					else
-					{
 						// Turn off LED if RF is not ON.
 						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);
-					}
 					break;
 
 				default:
@@ -1208,13 +1148,11 @@ u8 rtl8192_phy_SetSwChnlCmdArray(
 {
 	SwChnlCmd *pCmd;
 
-	if(CmdTable == NULL)
-	{
+	if(CmdTable == NULL) {
 		RT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): CmdTable cannot be NULL.\n");
 		return false;
 	}
-	if(CmdTableIdx >= CmdTableSz)
-	{
+	if(CmdTableIdx >= CmdTableSz) {
 		RT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): Access invalid index, please check size of the table, CmdTableIdx:%d, CmdTableSz:%d\n",
 				CmdTableIdx, CmdTableSz);
 		return false;
@@ -1257,8 +1195,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 
 	RT_TRACE(COMP_CH, "====>%s()====stage:%d, step:%d, channel:%d\n", __FUNCTION__, *stage, *step, channel);
 //	RT_ASSERT(IsLegalChannel(Adapter, channel), ("illegal channel: %d\n", channel));
-	if (!IsLegalChannel(priv->ieee80211, channel))
-	{
+	if (!IsLegalChannel(priv->ieee80211, channel)) {
 		RT_TRACE(COMP_ERR, "=============>set to illegal channel:%d\n", channel);
 		return true; //return true to tell upper caller function this channel setting is finished! Or it will in while loop.
 	}
@@ -1285,11 +1222,9 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 
 		// <3> Fill up RF dependent command.
 		RfDependCmdCnt = 0;
-		switch ( priv->rf_chip )
-		{
+		switch ( priv->rf_chip ) {
 		case RF_8225:
-			if (!(channel >= 1 && channel <= 14))
-			{
+			if (!(channel >= 1 && channel <= 14)) {
 				RT_TRACE(COMP_ERR, "illegal channel for Zebra 8225: %d\n", channel);
 				return true;
 			}
@@ -1301,8 +1236,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 
 		case RF_8256:
 			// TEST!! This is not the table for 8256!!
-			if (!(channel >= 1 && channel <= 14))
-			{
+			if (!(channel >= 1 && channel <= 14)) {
 				RT_TRACE(COMP_ERR, "illegal channel for Zebra 8256: %d\n", channel);
 				return true;
 			}
@@ -1322,9 +1256,8 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 		}
 
 
-		do{
-			switch (*stage)
-			{
+		do {
+			switch (*stage) {
 			case 0:
 				CurrentCmd=&PreCommonCmd[*step];
 				break;
@@ -1336,23 +1269,18 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 				break;
 			}
 
-			if(CurrentCmd->CmdID==CmdID_End)
-			{
-				if((*stage)==2)
-				{
+			if(CurrentCmd->CmdID==CmdID_End) {
+				if((*stage)==2) {
 					(*delay)=CurrentCmd->msDelay;
 					return true;
-				}
-				else
-				{
+				} else {
 					(*stage)++;
 					(*step)=0;
 					continue;
 				}
 			}
 
-			switch (CurrentCmd->CmdID)
-			{
+			switch (CurrentCmd->CmdID) {
 			case CmdID_SetTxPowerLevel:
 				if(priv->card_8192_version == (u8)VERSION_819xU_A) //xiong: consider it later!
 					rtl8192_SetTxPowerLevel(dev,channel);
@@ -1367,8 +1295,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 				write_nic_byte(dev, CurrentCmd->Para1, (u8)CurrentCmd->Para2);
 				break;
 			case CmdID_RF_WriteReg:
-				for(eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++)
-				{
+				for(eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {
 				rtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, bZebra1_ChannelNum, CurrentCmd->Para2);
 				}
 				break;
@@ -1377,7 +1304,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 			}
 
 			break;
-		}while(true);
+		} while(true);
 //	}/*for(Number of RF paths)*/
 
 	(*delay)=CurrentCmd->msDelay;
@@ -1398,8 +1325,7 @@ void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32	delay = 0;
 
-	while(!rtl8192_phy_SwChnlStepByStep(dev,channel,&priv->SwChnlStage,&priv->SwChnlStep,&delay))
-	{
+	while(!rtl8192_phy_SwChnlStepByStep(dev,channel,&priv->SwChnlStage,&priv->SwChnlStep,&delay)) {
 	//	if(delay>0)
 	//		msleep(delay);//or mdelay? need further consideration
 		if(!priv->up)
@@ -1445,33 +1371,24 @@ u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 
 //	if(pHalData->SetBWModeInProgress)
 //		return;
-if (0) //to test current channel from RF reg 0x7.
-{
-	u8		eRFPath;
-	for(eRFPath = 0; eRFPath < 2; eRFPath++){
-	printk("====>set channel:%x\n",rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, 0x7, bZebra1_ChannelNum));
-	udelay(10);
-	}
-}
 	//--------------------------------------------
-	switch (priv->ieee80211->mode)
-	{
+	switch (priv->ieee80211->mode) {
 	case WIRELESS_MODE_A:
 	case WIRELESS_MODE_N_5G:
-		if (channel<=14){
+		if (channel<=14) {
 			RT_TRACE(COMP_ERR, "WIRELESS_MODE_A but channel<=14");
 			return false;
 		}
 		break;
 	case WIRELESS_MODE_B:
-		if (channel>14){
+		if (channel>14) {
 			RT_TRACE(COMP_ERR, "WIRELESS_MODE_B but channel>14");
 			return false;
 		}
 		break;
 	case WIRELESS_MODE_G:
 	case WIRELESS_MODE_N_24G:
-		if (channel>14){
+		if (channel>14) {
 			RT_TRACE(COMP_ERR, "WIRELESS_MODE_G but channel>14");
 			return false;
 		}
@@ -1520,8 +1437,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 		 priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz");
 
 
-	if(priv->rf_chip == RF_PSEUDO_11N)
-	{
+	if(priv->rf_chip == RF_PSEUDO_11N) {
 		priv->SetBWModeInProgress= false;
 		return;
 	}
@@ -1529,8 +1445,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	//<1>Set MAC register
 	read_nic_byte(dev, BW_OPMODE, &regBwOpMode);
 
-	switch (priv->CurrentChannelBW)
-	{
+	switch (priv->CurrentChannelBW) {
 		case HT_CHANNEL_WIDTH_20:
 			regBwOpMode |= BW_OPMODE_20MHZ;
 		       // 2007/02/07 Mark by Emily because we have not verify whether this register works
@@ -1549,8 +1464,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	}
 
 	//<2>Set PHY related register
-	switch (priv->CurrentChannelBW)
-	{
+	switch (priv->CurrentChannelBW) {
 		case HT_CHANNEL_WIDTH_20:
 			// Add by Vivi 20071119
 			rtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x0);
@@ -1567,18 +1481,15 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 				priv->cck_present_attentuation = 0;
 			RT_TRACE(COMP_INIT, "20M, pHalData->CCKPresentAttentuation = %d\n", priv->cck_present_attentuation);
 
-			if(priv->chan == 14 && !priv->bcck_in_ch14)
-			{
+			if(priv->chan == 14 && !priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = TRUE;
 				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
-			}
-			else if(priv->chan != 14 && priv->bcck_in_ch14)
-			{
+			} else if(priv->chan != 14 && priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = FALSE;
 				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
-			}
-			else
+			} else {
 				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+			}
 
 			break;
 		case HT_CHANNEL_WIDTH_20_40:
@@ -1597,18 +1508,15 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 				priv->cck_present_attentuation = 0;
 
 			RT_TRACE(COMP_INIT, "40M, pHalData->CCKPresentAttentuation = %d\n", priv->cck_present_attentuation);
-			if(priv->chan == 14 && !priv->bcck_in_ch14)
-			{
+			if(priv->chan == 14 && !priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = true;
 				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
-			}
-			else if(priv->chan!= 14 && priv->bcck_in_ch14)
-			{
+			} else if(priv->chan!= 14 && priv->bcck_in_ch14) {
 				priv->bcck_in_ch14 = false;
 				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
-			}
-			else
+			} else {
 				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+			}
 
 			break;
 		default:
@@ -1619,8 +1527,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	//Skip over setting of J-mode in BB register here. Default value is "None J mode". Emily 20070315
 
 	//<3>Set RF related register
-	switch ( priv->rf_chip )
-	{
+	switch ( priv->rf_chip ) {
 		case RF_8225:
 #ifdef TO_DO_LIST
 			PHY_SetRF8225Bandwidth(Adapter, pHalData->CurrentChannelBW);
@@ -1688,9 +1595,7 @@ void InitialGain819xUsb(struct net_device *dev,	u8 Operation)
 	priv->InitialGainOperateType = Operation;
 
 	if(priv->up)
-	{
 		queue_delayed_work(priv->priv_wq,&priv->initialgain_operate_wq,0);
-	}
 }
 
 extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
@@ -1706,8 +1611,7 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 
 	Operation = priv->InitialGainOperateType;
 
-	switch (Operation)
-	{
+	switch (Operation) {
 		case IG_Backup:
 			RT_TRACE(COMP_SCAN, "IG_Backup, backup the initial gain.\n");
 			initial_gain = SCAN_RX_INITIAL_GAIN;//priv->DefaultInitialGain[0];//

commit 391c72a30bba9d569d5762a2f18d0dd4f3bdc5ba
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sat Jun 15 07:29:01 2013 +0300

    staging: rtl8192u: fix bitshift calculation in r819xU_phy.c
    
    This patch uses the ffs linux built-in routine in the
    computation of the bitshift to take advantage of
    architecture specific instructions that implement this
    computation more efficiently.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index d66d88cc189e..70ab9cd0b29f 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -7,6 +7,8 @@
 #include "r819xU_firmware_img.h"
 
 #include "dot11d.h"
+#include <linux/bitops.h>
+
 static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 	0,
 	0x085c, //2412 1
@@ -45,11 +47,7 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 u32 rtl8192_CalculateBitShift(u32 dwBitMask)
 {
 	u32 i;
-	for (i=0; i<=31; i++)
-	{
-		if (((dwBitMask>>i)&0x1) == 1)
-			break;
-	}
+	i = ffs(dwBitMask) - 1;
 	return i;
 }
 /******************************************************************************

commit 4a8d1135548bafe2566ceaa5032981ce6999a86c
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sun Jun 9 14:38:43 2013 +0300

    staging: rtl8192u: fix macros in r8192U.h
    
    This patch fixes the macros in r8192U.h.
    More specifically:
    
    1) removes the ';' from the end of the macro definition
       and changes according the files that are affected by
       this change by adding ';' at the end of the macro call
    2) replaces printk with pr_debug, when applicable
    3) replaces __FUNCTION__ with __func__
    4) fixes the framing when the macro contains complex expressions
    5) renames macro 'assert' as 'RTL9192U_ASSERT', so that it
       cannot be confused with the c function assert(), and changes
       accordingly the files affected by this change
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 60cba808c2fc..d66d88cc189e 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1519,7 +1519,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	u8 regBwOpMode;
 
 	RT_TRACE(COMP_SWBW, "==>rtl8192_SetBWModeWorkItem()  Switch to %s bandwidth\n", \
-					priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz")
+		 priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz");
 
 
 	if(priv->rf_chip == RF_PSEUDO_11N)

commit b3d42bf18784607b90b0661ac43f410713ff428b
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Thu Jun 6 16:40:51 2013 +0300

    staging: rtl8192u: fix read_nic_* functions
    
    read_nic_*() functions are defined in r8192U_core.c.
    They call internally usb_control_msg() to read the
    nic registers and return the value read.
    Following a remark made by Dan Carpenter, if usb_control_msg()
    fails, the value returned will be invalid.
    
    To accommodate for this, this patch changes the functions
    to take a pointer as argument to set the value read and
    return 0 on success and the error status on failure, so
    that callers of read_nic_*() can check the return status.
    
    Some other fixes introduced in read_nic_*() functions are:
    
    The expressions (1<<EPROM_*_SHIFT) used to address and set
    the individual bits of the eeprom register were replaced
    with EPROM_*_BIT bitmasks to make the code more intuitive.
    EPROM_*_BIT bitmasks were defined in r8192U_hw.h and
    EPROM_*_SHIFT were removed.
    
    In netdev_err(), which is called in case of failure,
    the hardcoded function name in the error log message was
    replaced with __func__ to reduce line size.
    Also, from the error log message, it was omitted the word
    "Timeout" and it is just reported the error code since the
    failure can not only be due to timeout expiration but also
    due to a memory allocation failure. In case of timeout
    expiration, usb_start_wait_urb() prints an appropriate log
    message when debug is enabled.
    
    Finally, some minor fixes to the coding style were applied in
    lines affected by the above changes, including the removal
    of ifdef DEBUG_RX (the debugging of reads and writes of the
    nic registers shall be done with explicit check on their
    return status which will be added in a follow on patch).
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 54f4cba08cfa..60cba808c2fc 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -90,7 +90,7 @@ void rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask, u32
 
 	if(dwBitMask!= bMaskDWord)
 	{//if not "double word" write
-		OriginalValue = read_nic_dword(dev, dwRegAddr);
+		read_nic_dword(dev, dwRegAddr, &OriginalValue);
 		BitShift = rtl8192_CalculateBitShift(dwBitMask);
 		NewValue = (((OriginalValue) & (~dwBitMask)) | (dwData << BitShift));
 		write_nic_dword(dev, dwRegAddr, NewValue);
@@ -111,7 +111,7 @@ u32 rtl8192_QueryBBReg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask)
 {
 	u32 Ret = 0, OriginalValue, BitShift;
 
-	OriginalValue = read_nic_dword(dev, dwRegAddr);
+	read_nic_dword(dev, dwRegAddr, &OriginalValue);
 	BitShift = rtl8192_CalculateBitShift(dwBitMask);
 	Ret =(OriginalValue & dwBitMask) >> BitShift;
 
@@ -379,6 +379,7 @@ phy_FwRFSerialRead(
 	u32		retValue = 0;
 	u32		Data = 0;
 	u8		time = 0;
+	u32		tmp;
 	//DbgPrint("FW RF CTRL\n\r");
 	/* 2007/11/02 MH Firmware RF Write control. By Francis' suggestion, we can
 	   not execute the scheme in the initial step. Otherwise, RF-R/W will waste
@@ -394,13 +395,15 @@ phy_FwRFSerialRead(
 	// 5. Trigger Fw to operate the command. bit 31
 	Data |= 0x80000000;
 	// 6. We can not execute read operation if bit 31 is 1.
-	while (read_nic_dword(dev, QPNR)&0x80000000)
+	read_nic_dword(dev, QPNR, &tmp);
+	while (tmp & 0x80000000)
 	{
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
 		if (time++ < 100)
 		{
 			//DbgPrint("FW not finish RF-R Time=%d\n\r", time);
 			udelay(10);
+			read_nic_dword(dev, QPNR, &tmp);
 		}
 		else
 			break;
@@ -408,18 +411,20 @@ phy_FwRFSerialRead(
 	// 7. Execute read operation.
 	write_nic_dword(dev, QPNR, Data);
 	// 8. Check if firmawre send back RF content.
-	while (read_nic_dword(dev, QPNR)&0x80000000)
+	read_nic_dword(dev, QPNR, &tmp);
+	while (tmp & 0x80000000)
 	{
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
 		if (time++ < 100)
 		{
 			//DbgPrint("FW not finish RF-W Time=%d\n\r", time);
 			udelay(10);
+			read_nic_dword(dev, QPNR, &tmp);
 		}
 		else
 			return	(0);
 	}
-	retValue = read_nic_dword(dev, RF_DATA);
+	read_nic_dword(dev, RF_DATA, &retValue);
 
 	return	(retValue);
 
@@ -440,6 +445,7 @@ phy_FwRFSerialWrite(
 		u32				Data	)
 {
 	u8	time = 0;
+	u32	tmp;
 
 	//DbgPrint("N FW RF CTRL RF-%d OF%02x DATA=%03x\n\r", eRFPath, Offset, Data);
 	/* 2007/11/02 MH Firmware RF Write control. By Francis' suggestion, we can
@@ -458,13 +464,15 @@ phy_FwRFSerialWrite(
 	Data |= 0x80000000;
 
 	// 6. Write operation. We can not write if bit 31 is 1.
-	while (read_nic_dword(dev, QPNR)&0x80000000)
+	read_nic_dword(dev, QPNR, &tmp);
+	while (tmp & 0x80000000)
 	{
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
 		if (time++ < 100)
 		{
 			//DbgPrint("FW not finish RF-W Time=%d\n\r", time);
 			udelay(10);
+			read_nic_dword(dev, QPNR, &tmp);
 		}
 		else
 			break;
@@ -719,7 +727,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock, RF9
 		case HW90_BLOCK_PHY0:
 		case HW90_BLOCK_PHY1:
 			write_nic_dword(dev, WriteAddr[CheckBlock], WriteData[i]);
-			dwRegRead = read_nic_dword(dev, WriteAddr[CheckBlock]);
+			read_nic_dword(dev, WriteAddr[CheckBlock], &dwRegRead);
 			break;
 
 		case HW90_BLOCK_RF:
@@ -770,11 +778,11 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	**************************************/
 
 	/*--set BB Global Reset--*/
-	bRegValue = read_nic_byte(dev, BB_GLOBAL_RESET);
+	read_nic_byte(dev, BB_GLOBAL_RESET, &bRegValue);
 	write_nic_byte(dev, BB_GLOBAL_RESET,(bRegValue|BB_GLOBAL_RESET_BIT));
 	mdelay(50);
 	/*---set BB reset Active---*/
-	dwRegValue = read_nic_dword(dev, CPU_GEN);
+	read_nic_dword(dev, CPU_GEN, &dwRegValue);
 	write_nic_dword(dev, CPU_GEN, (dwRegValue&(~CPU_GEN_BB_RST)));
 
 	/*----Ckeck FPGAPHY0 and PHY1 board is OK----*/
@@ -795,7 +803,7 @@ void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 	rtl8192_phyConfigBB(dev, BaseBand_Config_PHY_REG);
 
 	/*----Set BB reset de-Active----*/
-	dwRegValue = read_nic_dword(dev, CPU_GEN);
+	read_nic_dword(dev, CPU_GEN, &dwRegValue);
 	write_nic_dword(dev, CPU_GEN, (dwRegValue|CPU_GEN_BB_RST));
 
 	/*----BB AGC table Initialization----*/
@@ -846,36 +854,32 @@ void rtl8192_BBConfig(struct net_device *dev)
 void rtl8192_phy_getTxPower(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	priv->MCSTxPowerLevelOriginalOffset[0] =
-		read_nic_dword(dev, rTxAGC_Rate18_06);
-	priv->MCSTxPowerLevelOriginalOffset[1] =
-		read_nic_dword(dev, rTxAGC_Rate54_24);
-	priv->MCSTxPowerLevelOriginalOffset[2] =
-		read_nic_dword(dev, rTxAGC_Mcs03_Mcs00);
-	priv->MCSTxPowerLevelOriginalOffset[3] =
-		read_nic_dword(dev, rTxAGC_Mcs07_Mcs04);
-	priv->MCSTxPowerLevelOriginalOffset[4] =
-		read_nic_dword(dev, rTxAGC_Mcs11_Mcs08);
-	priv->MCSTxPowerLevelOriginalOffset[5] =
-		read_nic_dword(dev, rTxAGC_Mcs15_Mcs12);
+	u8 tmp;
+	read_nic_dword(dev, rTxAGC_Rate18_06, &priv->MCSTxPowerLevelOriginalOffset[0]);
+	read_nic_dword(dev, rTxAGC_Rate54_24, &priv->MCSTxPowerLevelOriginalOffset[1]);
+	read_nic_dword(dev, rTxAGC_Mcs03_Mcs00, &priv->MCSTxPowerLevelOriginalOffset[2]);
+	read_nic_dword(dev, rTxAGC_Mcs07_Mcs04, &priv->MCSTxPowerLevelOriginalOffset[3]);
+	read_nic_dword(dev, rTxAGC_Mcs11_Mcs08, &priv->MCSTxPowerLevelOriginalOffset[4]);
+	read_nic_dword(dev, rTxAGC_Mcs15_Mcs12, &priv->MCSTxPowerLevelOriginalOffset[5]);
 
 	// read rx initial gain
-	priv->DefaultInitialGain[0] = read_nic_byte(dev, rOFDM0_XAAGCCore1);
-	priv->DefaultInitialGain[1] = read_nic_byte(dev, rOFDM0_XBAGCCore1);
-	priv->DefaultInitialGain[2] = read_nic_byte(dev, rOFDM0_XCAGCCore1);
-	priv->DefaultInitialGain[3] = read_nic_byte(dev, rOFDM0_XDAGCCore1);
+	read_nic_byte(dev, rOFDM0_XAAGCCore1, &priv->DefaultInitialGain[0]);
+	read_nic_byte(dev, rOFDM0_XBAGCCore1, &priv->DefaultInitialGain[1]);
+	read_nic_byte(dev, rOFDM0_XCAGCCore1, &priv->DefaultInitialGain[2]);
+	read_nic_byte(dev, rOFDM0_XDAGCCore1, &priv->DefaultInitialGain[3]);
 	RT_TRACE(COMP_INIT, "Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x) \n",
 		priv->DefaultInitialGain[0], priv->DefaultInitialGain[1],
 		priv->DefaultInitialGain[2], priv->DefaultInitialGain[3]);
 
 	// read framesync
-	priv->framesync = read_nic_byte(dev, rOFDM0_RxDetector3);
-	priv->framesyncC34 = read_nic_byte(dev, rOFDM0_RxDetector2);
+	read_nic_byte(dev, rOFDM0_RxDetector3, &priv->framesync);
+	read_nic_byte(dev, rOFDM0_RxDetector2, &tmp);
+	priv->framesyncC34 = tmp;
 	RT_TRACE(COMP_INIT, "Default framesync (0x%x) = 0x%x \n",
 		rOFDM0_RxDetector3, priv->framesync);
 
 	// read SIFS (save the value read fome MACPHY_REG.txt)
-	priv->SifsTime = read_nic_word(dev, SIFS);
+	read_nic_word(dev, SIFS, &priv->SifsTime);
 
 	return;
 }
@@ -1525,7 +1529,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	}
 
 	//<1>Set MAC register
-	regBwOpMode = read_nic_byte(dev, BW_OPMODE);
+	read_nic_byte(dev, BW_OPMODE, &regBwOpMode);
 
 	switch (priv->CurrentChannelBW)
 	{

commit ad6384591f449026d93b136a6b5cb8b8bce6c743
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sun May 12 03:15:08 2013 +0300

    STAGING: rtl8192u: fix checkpatch error by adding space after switch
    
    This patch fixes the following checkpatch error:
    ERROR: space required before the open parenthesis '('
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index a6a8f90c2748..54f4cba08cfa 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -710,7 +710,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock, RF9
 		//
 		// Write Data to register and readback
 		//
-		switch(CheckBlock)
+		switch (CheckBlock)
 		{
 		case HW90_BLOCK_MAC:
 			RT_TRACE(COMP_ERR, "PHY_CheckBBRFOK(): Never Write 0x100 here!");
@@ -892,7 +892,7 @@ void rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)
 	u8	powerlevel = priv->TxPowerLevelCCK[channel-1];
 	u8	powerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];
 
-	switch(priv->rf_chip)
+	switch (priv->rf_chip)
 	{
 	case RF_8256:
 		PHY_SetRF8256CCKTxPower(dev, powerlevel); //need further implement
@@ -917,7 +917,7 @@ void rtl8192_phy_RFConfig(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
-	switch(priv->rf_chip)
+	switch (priv->rf_chip)
 	{
 		case RF_8256:
 			PHY_RF8256_Config(dev);
@@ -956,7 +956,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E
 	//u32* pRFArray;
 	u8 ret = 0;
 
-	switch(eRFPath){
+	switch (eRFPath){
 	case RF90_PATH_A:
 		for(i = 0;i<RadioA_ArrayLength; i=i+2){
 
@@ -1026,7 +1026,7 @@ void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
 	u8	powerlevel = priv->TxPowerLevelCCK[channel-1];
 	u8	powerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];
 
-	switch(priv->rf_chip)
+	switch (priv->rf_chip)
 	{
 	case RF_8225:
 #ifdef TO_DO_LIST
@@ -1071,10 +1071,10 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 
 	priv->SetRFPowerStateInProgress = true;
 
-	switch(priv->rf_chip)
+	switch (priv->rf_chip)
 	{
 		case RF_8256:
-		switch( eRFPowerState )
+		switch ( eRFPowerState )
 		{
 			case eRfOn:
 	//RF-A, RF-B
@@ -1129,10 +1129,10 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 	{
 		// Update current RF state variable.
 		pHalData->eRFPowerState = eRFPowerState;
-		switch(pHalData->RFChipID )
+		switch (pHalData->RFChipID )
 		{
 			case RF_8256:
-		switch(pHalData->eRFPowerState)
+		switch (pHalData->eRFPowerState)
 				{
 				case eRfOff:
 					//
@@ -1283,7 +1283,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 
 		// <3> Fill up RF dependent command.
 		RfDependCmdCnt = 0;
-		switch( priv->rf_chip )
+		switch ( priv->rf_chip )
 		{
 		case RF_8225:
 			if (!(channel >= 1 && channel <= 14))
@@ -1321,7 +1321,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 
 
 		do{
-			switch(*stage)
+			switch (*stage)
 			{
 			case 0:
 				CurrentCmd=&PreCommonCmd[*step];
@@ -1349,7 +1349,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u
 				}
 			}
 
-			switch(CurrentCmd->CmdID)
+			switch (CurrentCmd->CmdID)
 			{
 			case CmdID_SetTxPowerLevel:
 				if(priv->card_8192_version == (u8)VERSION_819xU_A) //xiong: consider it later!
@@ -1452,7 +1452,7 @@ if (0) //to test current channel from RF reg 0x7.
 	}
 }
 	//--------------------------------------------
-	switch(priv->ieee80211->mode)
+	switch (priv->ieee80211->mode)
 	{
 	case WIRELESS_MODE_A:
 	case WIRELESS_MODE_N_5G:
@@ -1527,7 +1527,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	//<1>Set MAC register
 	regBwOpMode = read_nic_byte(dev, BW_OPMODE);
 
-	switch(priv->CurrentChannelBW)
+	switch (priv->CurrentChannelBW)
 	{
 		case HT_CHANNEL_WIDTH_20:
 			regBwOpMode |= BW_OPMODE_20MHZ;
@@ -1547,7 +1547,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	}
 
 	//<2>Set PHY related register
-	switch(priv->CurrentChannelBW)
+	switch (priv->CurrentChannelBW)
 	{
 		case HT_CHANNEL_WIDTH_20:
 			// Add by Vivi 20071119
@@ -1617,7 +1617,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	//Skip over setting of J-mode in BB register here. Default value is "None J mode". Emily 20070315
 
 	//<3>Set RF related register
-	switch( priv->rf_chip )
+	switch ( priv->rf_chip )
 	{
 		case RF_8225:
 #ifdef TO_DO_LIST
@@ -1704,7 +1704,7 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 
 	Operation = priv->InitialGainOperateType;
 
-	switch(Operation)
+	switch (Operation)
 	{
 		case IG_Backup:
 			RT_TRACE(COMP_SCAN, "IG_Backup, backup the initial gain.\n");

commit 88d8fe2943de2c15a6c7873a5c36a0e02f15f426
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sat May 11 17:22:22 2013 +0300

    STAGING: rtl8192u: fix checkpatch error about pointer position in r819xU_phy
    
    This patch fixes the pointer position in r819xU_phy.h and r819xU_phy.c
    to meet the kernel coding style conventions.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 17fac41c12d9..a6a8f90c2748 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -58,7 +58,7 @@ u32 rtl8192_CalculateBitShift(u32 dwBitMask)
  *  output:  none
  *  return:  0(illegal, false), 1(legal,true)
  * ***************************************************************************/
-u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device* dev, u32 eRFPath)
+u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 eRFPath)
 {
 	u8 ret = 1;
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -83,7 +83,7 @@ u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device* dev, u32 eRFPath)
  *  return:  none
  *  notice:
  * ****************************************************************************/
-void rtl8192_setBBreg(struct net_device* dev, u32 dwRegAddr, u32 dwBitMask, u32 dwData)
+void rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask, u32 dwData)
 {
 
 	u32 OriginalValue, BitShift, NewValue;
@@ -107,7 +107,7 @@ void rtl8192_setBBreg(struct net_device* dev, u32 dwRegAddr, u32 dwBitMask, u32
  *  return:  u32	Data	//the readback register value
  *  notice:
  * ****************************************************************************/
-u32 rtl8192_QueryBBReg(struct net_device* dev, u32 dwRegAddr, u32 dwBitMask)
+u32 rtl8192_QueryBBReg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask)
 {
 	u32 Ret = 0, OriginalValue, BitShift;
 
@@ -117,9 +117,9 @@ u32 rtl8192_QueryBBReg(struct net_device* dev, u32 dwRegAddr, u32 dwBitMask)
 
 	return (Ret);
 }
-static  u32 phy_FwRFSerialRead( struct net_device* dev, RF90_RADIO_PATH_E       eRFPath, u32 Offset  );
+static  u32 phy_FwRFSerialRead( struct net_device *dev, RF90_RADIO_PATH_E       eRFPath, u32 Offset  );
 
-static void phy_FwRFSerialWrite( struct net_device* dev, RF90_RADIO_PATH_E       eRFPath, u32  Offset, u32  Data);
+static void phy_FwRFSerialWrite( struct net_device *dev, RF90_RADIO_PATH_E       eRFPath, u32  Offset, u32  Data);
 
 /******************************************************************************
  *function:  This function read register from RF chip
@@ -130,12 +130,12 @@ static void phy_FwRFSerialWrite( struct net_device* dev, RF90_RADIO_PATH_E
  *  return:  u32	readback value
  *  notice:  There are three types of serial operations:(1) Software serial write.(2)Hardware LSSI-Low Speed Serial Interface.(3)Hardware HSSI-High speed serial write. Driver here need to implement (1) and (2)---need more spec for this information.
  * ****************************************************************************/
-u32 rtl8192_phy_RFSerialRead(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset)
+u32 rtl8192_phy_RFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u32 Offset)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 ret = 0;
 	u32 NewOffset = 0;
-	BB_REGISTER_DEFINITION_T* pPhyReg = &priv->PHYRegDef[eRFPath];
+	BB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[eRFPath];
 	rtl8192_setBBreg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData, 0);
 	//make sure RF register offset is correct
 	Offset &= 0x3f;
@@ -218,7 +218,7 @@ u32 rtl8192_phy_RFSerialRead(struct net_device* dev, RF90_RADIO_PATH_E eRFPath,
  * Reg_Mode2	1		1			Reg 31 ~ 45(0x1 ~ 0xf)
  *------------------------------------------------------------------
  * ****************************************************************************/
-void rtl8192_phy_RFSerialWrite(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data)
+void rtl8192_phy_RFSerialWrite(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 DataAndAddr = 0, NewOffset = 0;
@@ -291,7 +291,7 @@ void rtl8192_phy_RFSerialWrite(struct net_device* dev, RF90_RADIO_PATH_E eRFPath
  *  return:  none
  *  notice:
  * ****************************************************************************/
-void rtl8192_phy_SetRFReg(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask, u32 Data)
+void rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask, u32 Data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 Original_Value, BitShift, New_Value;
@@ -339,7 +339,7 @@ void rtl8192_phy_SetRFReg(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32
  *  return:  u32	Data	//the readback register value
  *  notice:
  * ****************************************************************************/
-u32 rtl8192_phy_QueryRFReg(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask)
+u32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask)
 {
 	u32 Original_Value, Readback_Value, BitShift;
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -372,7 +372,7 @@ u32 rtl8192_phy_QueryRFReg(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u3
  * ***************************************************************************/
 static	u32
 phy_FwRFSerialRead(
-	struct net_device* dev,
+	struct net_device *dev,
 	RF90_RADIO_PATH_E	eRFPath,
 	u32				Offset	)
 {
@@ -434,7 +434,7 @@ phy_FwRFSerialRead(
  * ***************************************************************************/
 static void
 phy_FwRFSerialWrite(
-		struct net_device* dev,
+		struct net_device *dev,
 		RF90_RADIO_PATH_E	eRFPath,
 		u32				Offset,
 		u32				Data	)
@@ -489,10 +489,10 @@ phy_FwRFSerialWrite(
  *  notice:  BB parameters may change all the time, so please make
  *           sure it has been synced with the newest.
  * ***************************************************************************/
-void rtl8192_phy_configmac(struct net_device* dev)
+void rtl8192_phy_configmac(struct net_device *dev)
 {
 	u32 dwArrayLen = 0, i;
-	u32* pdwArray = NULL;
+	u32 *pdwArray = NULL;
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
 	if(priv->btxpowerdata_readfromEEPORM)
@@ -533,7 +533,7 @@ void rtl8192_phy_configmac(struct net_device* dev)
  *           sure it has been synced with the newest.
  * ***************************************************************************/
 
-void rtl8192_phyConfigBB(struct net_device* dev, u8 ConfigType)
+void rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)
 {
 	u32 i;
 
@@ -575,7 +575,7 @@ void rtl8192_phyConfigBB(struct net_device* dev, u8 ConfigType)
  *  return:  none
  *  notice:  Initialization value here is constant and it should never be changed
  * ***************************************************************************/
-void rtl8192_InitBBRFRegDef(struct net_device* dev)
+void rtl8192_InitBBRFRegDef(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 // RF Interface Software Control
@@ -690,7 +690,7 @@ void rtl8192_InitBBRFRegDef(struct net_device* dev)
  *  return:  return whether BB and RF is ok(0:OK; 1:Fail)
  *  notice:  This function may be removed in the ASIC
  * ***************************************************************************/
-u8 rtl8192_phy_checkBBAndRF(struct net_device* dev, HW90_BLOCK_E CheckBlock, RF90_RADIO_PATH_E eRFPath)
+u8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock, RF90_RADIO_PATH_E eRFPath)
 {
 //	struct r8192_priv *priv = ieee80211_priv(dev);
 //	BB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[eRFPath];
@@ -760,7 +760,7 @@ u8 rtl8192_phy_checkBBAndRF(struct net_device* dev, HW90_BLOCK_E CheckBlock, RF9
  *  notice:  Initialization value may change all the time, so please make
  *           sure it has been synced with the newest.
  * ***************************************************************************/
-void rtl8192_BB_Config_ParaFile(struct net_device* dev)
+void rtl8192_BB_Config_ParaFile(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8 bRegValue = 0, eCheckItem = 0, rtStatus = 0;
@@ -828,7 +828,7 @@ void rtl8192_BB_Config_ParaFile(struct net_device* dev)
  *  notice:  Initialization value may change all the time, so please make
  *           sure it has been synced with the newest.
  * ***************************************************************************/
-void rtl8192_BBConfig(struct net_device* dev)
+void rtl8192_BBConfig(struct net_device *dev)
 {
 	rtl8192_InitBBRFRegDef(dev);
 	//config BB&RF. As hardCode based initialization has not been well
@@ -843,7 +843,7 @@ void rtl8192_BBConfig(struct net_device* dev)
  *  output:  none
  *  return:  none
  * ***************************************************************************/
-void rtl8192_phy_getTxPower(struct net_device* dev)
+void rtl8192_phy_getTxPower(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	priv->MCSTxPowerLevelOriginalOffset[0] =
@@ -886,7 +886,7 @@ void rtl8192_phy_getTxPower(struct net_device* dev)
  *  output:  none
  *  return:  none
  * ***************************************************************************/
-void rtl8192_phy_setTxPower(struct net_device* dev, u8 channel)
+void rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8	powerlevel = priv->TxPowerLevelCCK[channel-1];
@@ -913,7 +913,7 @@ void rtl8192_phy_setTxPower(struct net_device* dev, u8 channel)
  *  output:  none
  *  return:  only 8256 is supported
  * ***************************************************************************/
-void rtl8192_phy_RFConfig(struct net_device* dev)
+void rtl8192_phy_RFConfig(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
@@ -937,7 +937,7 @@ void rtl8192_phy_RFConfig(struct net_device* dev)
  *  output:  none
  *  return:  As Windows has not implemented this, wait for complement
  * ***************************************************************************/
-void rtl8192_phy_updateInitGain(struct net_device* dev)
+void rtl8192_phy_updateInitGain(struct net_device *dev)
 {
 	return;
 }
@@ -949,7 +949,7 @@ void rtl8192_phy_updateInitGain(struct net_device* dev)
  *  return:  return code show if RF configuration is successful(0:pass, 1:fail)
  *    Note:  Delay may be required for RF configuration
  * ***************************************************************************/
-u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device* dev, RF90_RADIO_PATH_E	eRFPath)
+u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev, RF90_RADIO_PATH_E	eRFPath)
 {
 
 	int i;
@@ -1195,7 +1195,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
  *    Note:
  * ************************************************************************************/
 u8 rtl8192_phy_SetSwChnlCmdArray(
-	SwChnlCmd*		CmdTable,
+	SwChnlCmd		*CmdTable,
 	u32			CmdTableIdx,
 	u32			CmdTableSz,
 	SwChnlCmdID		CmdID,
@@ -1204,7 +1204,7 @@ u8 rtl8192_phy_SetSwChnlCmdArray(
 	u32			msDelay
 	)
 {
-	SwChnlCmd* pCmd;
+	SwChnlCmd *pCmd;
 
 	if(CmdTable == NULL)
 	{
@@ -1237,7 +1237,7 @@ u8 rtl8192_phy_SetSwChnlCmdArray(
  *  return:  true if finished, false otherwise
  *    Note:  Wait for simpler function to replace it //wb
  * ***************************************************************************/
-u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8* stage, u8* step, u32* delay)
+u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8 *stage, u8 *step, u32 *delay)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 //	PCHANNEL_ACCESS_SETTING	pChnlAccessSetting;
@@ -1432,7 +1432,7 @@ void rtl8192_SwChnl_WorkItem(struct net_device *dev)
  *  return:  return code show if workitem is scheduled(1:pass, 0:fail)
  *    Note:  Delay may be required for RF configuration
  * ***************************************************************************/
-u8 rtl8192_phy_SwChnl(struct net_device* dev, u8 channel)
+u8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	RT_TRACE(COMP_CH, "=====>%s(), SwChnlInProgress:%d\n", __FUNCTION__, priv->SwChnlInProgress);

commit 24fbe875256acf71ab13e869afddbc3a75d7dfbc
Author: Sebastian Hahn <snsehahn@cip.cs.fau.de>
Date:   Wed Dec 5 21:40:22 2012 +0100

    staging/rtl8192u: use same indent for switch and case
    
    Fix the checkpatch error "switch and case should be at the same indent"
    
    Signed-off-by: Sebastian Hahn <snsehahn@cip.cs.fau.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 2ff851f50e0f..17fac41c12d9 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -957,56 +957,56 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device* dev, RF90_RADIO_PATH_E
 	u8 ret = 0;
 
 	switch(eRFPath){
-		case RF90_PATH_A:
-			for(i = 0;i<RadioA_ArrayLength; i=i+2){
-
-				if(rtl819XRadioA_Array[i] == 0xfe){
-						mdelay(100);
-						continue;
-				}
-				rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioA_Array[i], bMask12Bits, rtl819XRadioA_Array[i+1]);
-				mdelay(1);
+	case RF90_PATH_A:
+		for(i = 0;i<RadioA_ArrayLength; i=i+2){
 
+			if(rtl819XRadioA_Array[i] == 0xfe){
+					mdelay(100);
+					continue;
 			}
-			break;
-		case RF90_PATH_B:
-			for(i = 0;i<RadioB_ArrayLength; i=i+2){
+			rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioA_Array[i], bMask12Bits, rtl819XRadioA_Array[i+1]);
+			mdelay(1);
 
-				if(rtl819XRadioB_Array[i] == 0xfe){
-						mdelay(100);
-						continue;
-				}
-				rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioB_Array[i], bMask12Bits, rtl819XRadioB_Array[i+1]);
-				mdelay(1);
+		}
+		break;
+	case RF90_PATH_B:
+		for(i = 0;i<RadioB_ArrayLength; i=i+2){
 
+			if(rtl819XRadioB_Array[i] == 0xfe){
+					mdelay(100);
+					continue;
 			}
-			break;
-		case RF90_PATH_C:
-			for(i = 0;i<RadioC_ArrayLength; i=i+2){
+			rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioB_Array[i], bMask12Bits, rtl819XRadioB_Array[i+1]);
+			mdelay(1);
 
-				if(rtl819XRadioC_Array[i] == 0xfe){
-						mdelay(100);
-						continue;
-				}
-				rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioC_Array[i], bMask12Bits, rtl819XRadioC_Array[i+1]);
-				mdelay(1);
+		}
+		break;
+	case RF90_PATH_C:
+		for(i = 0;i<RadioC_ArrayLength; i=i+2){
 
+			if(rtl819XRadioC_Array[i] == 0xfe){
+					mdelay(100);
+					continue;
 			}
-			break;
-		case RF90_PATH_D:
-			for(i = 0;i<RadioD_ArrayLength; i=i+2){
+			rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioC_Array[i], bMask12Bits, rtl819XRadioC_Array[i+1]);
+			mdelay(1);
 
-				if(rtl819XRadioD_Array[i] == 0xfe){
-						mdelay(100);
-						continue;
-				}
-				rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioD_Array[i], bMask12Bits, rtl819XRadioD_Array[i+1]);
-				mdelay(1);
+		}
+		break;
+	case RF90_PATH_D:
+		for(i = 0;i<RadioD_ArrayLength; i=i+2){
 
+			if(rtl819XRadioD_Array[i] == 0xfe){
+					mdelay(100);
+					continue;
 			}
-			break;
-		default:
-			break;
+			rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioD_Array[i], bMask12Bits, rtl819XRadioD_Array[i+1]);
+			mdelay(1);
+
+		}
+		break;
+	default:
+		break;
 	}
 
 	return ret;

commit 35997ff0cadda701711416abf6676b77358b0008
Author: Sebastian Hahn <snsehahn@cip.cs.fau.de>
Date:   Wed Dec 5 21:40:18 2012 +0100

    staging/rtl8192u: cleanfile run
    
    Run cleanfile on all files inside drivers/staging/rtl819u
    
    Signed-off-by: Sebastian Hahn <snsehahn@cip.cs.fau.de>
    Signed-off-by: Jennifer Naumann <Jennifer.Naumann@informatik.stud.uni-erlangen.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index dd1954daea2d..2ff851f50e0f 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -124,10 +124,10 @@ static void phy_FwRFSerialWrite( struct net_device* dev, RF90_RADIO_PATH_E
 /******************************************************************************
  *function:  This function read register from RF chip
  *   input:  net_device dev
- *   	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
+ *	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
  *           u32	Offset     //target address to be read
  *  output:  none
- *  return:  u32 	readback value
+ *  return:  u32	readback value
  *  notice:  There are three types of serial operations:(1) Software serial write.(2)Hardware LSSI-Low Speed Serial Interface.(3)Hardware HSSI-High speed serial write. Driver here need to implement (1) and (2)---need more spec for this information.
  * ****************************************************************************/
 u32 rtl8192_phy_RFSerialRead(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset)
@@ -201,7 +201,7 @@ u32 rtl8192_phy_RFSerialRead(struct net_device* dev, RF90_RADIO_PATH_E eRFPath,
 /******************************************************************************
  *function:  This function write data to RF register
  *   input:  net_device dev
- *   	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
+ *	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
  *           u32	Offset     //target address to be written
  *           u32	Data	//The new register data to be written
  *  output:  none
@@ -283,7 +283,7 @@ void rtl8192_phy_RFSerialWrite(struct net_device* dev, RF90_RADIO_PATH_E eRFPath
 /******************************************************************************
  *function:  This function set specific bits to RF register
  *   input:  net_device dev
- *   	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
+ *	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
  *           u32	RegAddr  //target addr to be modified
  *           u32	BitMask  //taget bit pos in the addr to be modified
  *           u32	Data     //value to be write
@@ -684,8 +684,8 @@ void rtl8192_InitBBRFRegDef(struct net_device* dev)
 /******************************************************************************
  *function:  This function is to write register and then readback to make sure whether BB and RF is OK
  *   input:  net_device dev
- *   	     HW90_BLOCK_E CheckBlock
- *   	     RF90_RADIO_PATH_E eRFPath  //only used when checkblock is HW90_BLOCK_RF
+ *	     HW90_BLOCK_E CheckBlock
+ *	     RF90_RADIO_PATH_E eRFPath  //only used when checkblock is HW90_BLOCK_RF
  *  output:  none
  *  return:  return whether BB and RF is ok(0:OK; 1:Fail)
  *  notice:  This function may be removed in the ASIC
@@ -1015,7 +1015,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device* dev, RF90_RADIO_PATH_E
 /******************************************************************************
  *function:  This function set Tx Power of the channel
  *   input:  struct net_device *dev
- *   	     u8 		channel
+ *	     u8			channel
  *  output:  none
  *  return:  none
  *    Note:
@@ -1052,7 +1052,7 @@ void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
 /******************************************************************************
  *function:  This function set RF state on or off
  *   input:  struct net_device *dev
- *   	     RT_RF_POWER_STATE eRFPowerState  //Power State to set
+ *	     RT_RF_POWER_STATE eRFPowerState  //Power State to set
  *  output:  none
  *  return:  none
  *    Note:
@@ -1183,10 +1183,10 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 
 /****************************************************************************************
  *function:  This function set command table variable(struct SwChnlCmd).
- *   input:  SwChnlCmd*		CmdTable 	//table to be set.
- *   	     u32		CmdTableIdx 	//variable index in table to be set
- *   	     u32		CmdTableSz	//table size.
- *   	     SwChnlCmdID	CmdID		//command ID to set.
+ *   input:  SwChnlCmd*		CmdTable	//table to be set.
+ *	     u32		CmdTableIdx	//variable index in table to be set
+ *	     u32		CmdTableSz	//table size.
+ *	     SwChnlCmdID	CmdID		//command ID to set.
  *	     u32		Para1
  *	     u32		Para2
  *	     u32		msDelay
@@ -1229,10 +1229,10 @@ u8 rtl8192_phy_SetSwChnlCmdArray(
 /******************************************************************************
  *function:  This function set channel step by step
  *   input:  struct net_device *dev
- *   	     u8 		channel
- *   	     u8* 		stage //3 stages
- *   	     u8* 		step  //
- *   	     u32* 		delay //whether need to delay
+ *	     u8			channel
+ *	     u8*		stage //3 stages
+ *	     u8*		step  //
+ *	     u32*		delay //whether need to delay
  *  output:  store new stage, step and delay for next step(combine with function above)
  *  return:  true if finished, false otherwise
  *    Note:  Wait for simpler function to replace it //wb
@@ -1386,7 +1386,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8* stage, u
 /******************************************************************************
  *function:  This function does actually set channel work
  *   input:  struct net_device *dev
- *   	     u8 		channel
+ *	     u8			channel
  *  output:  none
  *  return:  noin
  *    Note:  We should not call this function directly
@@ -1427,7 +1427,7 @@ void rtl8192_SwChnl_WorkItem(struct net_device *dev)
 /******************************************************************************
  *function:  This function scheduled actual work item to set channel
  *   input:  net_device dev
- *   	     u8		channel //channel to set
+ *	     u8		channel //channel to set
  *  output:  none
  *  return:  return code show if workitem is scheduled(1:pass, 0:fail)
  *    Note:  Delay may be required for RF configuration
@@ -1501,12 +1501,12 @@ if (0) //to test current channel from RF reg 0x7.
 /******************************************************************************
  *function:  Callback routine of the work item for set bandwidth mode.
  *   input:  struct net_device *dev
- *   	     HT_CHANNEL_WIDTH	Bandwidth  //20M or 40M
- *   	     HT_EXTCHNL_OFFSET Offset 	   //Upper, Lower, or Don't care
+ *	     HT_CHANNEL_WIDTH	Bandwidth  //20M or 40M
+ *	     HT_EXTCHNL_OFFSET Offset	   //Upper, Lower, or Don't care
  *  output:  none
  *  return:  none
  *    Note:  I doubt whether SetBWModeInProgress flag is necessary as we can
- *    	     test whether current work in the queue or not.//do I?
+ *	     test whether current work in the queue or not.//do I?
  * ***************************************************************************/
 void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 {
@@ -1649,12 +1649,12 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 /******************************************************************************
  *function:  This function schedules bandwidth switch work.
  *   input:  struct net_device *dev
- *   	     HT_CHANNEL_WIDTH	Bandwidth  //20M or 40M
- *   	     HT_EXTCHNL_OFFSET Offset 	   //Upper, Lower, or Don't care
+ *	     HT_CHANNEL_WIDTH	Bandwidth  //20M or 40M
+ *	     HT_EXTCHNL_OFFSET Offset	   //Upper, Lower, or Don't care
  *  output:  none
  *  return:  none
  *    Note:  I doubt whether SetBWModeInProgress flag is necessary as we can
- *    	     test whether current work in the queue or not.//do I?
+ *	     test whether current work in the queue or not.//do I?
  * ***************************************************************************/
 void rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH	Bandwidth, HT_EXTCHNL_OFFSET Offset)
 {
@@ -1770,4 +1770,3 @@ extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 			break;
 	}
 }
-

commit 8ef3a7ed35a09431336faf2f3ce53d4d0959cea1
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Apr 30 14:39:21 2012 -0700

    staging:rtl8192u Fix typos and comments
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 636d6fd5b704..dd1954daea2d 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -176,7 +176,7 @@ u32 rtl8192_phy_RFSerialRead(struct net_device* dev, RF90_RADIO_PATH_E eRFPath,
 	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x1);
 
 
-	// TODO: we should not delay such a long time. Ask help from SD3
+	// TODO: we should not delay such a long time. Ask for help from SD3
 	msleep(1);
 
 	ret = rtl8192_QueryBBReg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData);
@@ -1425,7 +1425,7 @@ void rtl8192_SwChnl_WorkItem(struct net_device *dev)
 }
 
 /******************************************************************************
- *function:  This function scheduled actual workitem to set channel
+ *function:  This function scheduled actual work item to set channel
  *   input:  net_device dev
  *   	     u8		channel //channel to set
  *  output:  none

commit 589b3d06fd159774f9f5c3639d8d5d938670c019
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Apr 30 07:41:36 2012 -0700

    staging: rtl8192u Fix typos.
    
     Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index c4586b0817d1..636d6fd5b704 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -40,7 +40,7 @@ static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
  *	     and do register read/write
  *   input:  u32	dwBitMask  //taget bit pos in the addr to be modified
  *  output:  none
- *  return:  u32	return the shift bit bit position of the mask
+ *  return:  u32	return the shift bit position of the mask
  * ****************************************************************************/
 u32 rtl8192_CalculateBitShift(u32 dwBitMask)
 {
@@ -176,7 +176,7 @@ u32 rtl8192_phy_RFSerialRead(struct net_device* dev, RF90_RADIO_PATH_E eRFPath,
 	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x1);
 
 
-	// TODO: we should not delay such a  long time. Ask help from SD3
+	// TODO: we should not delay such a long time. Ask help from SD3
 	msleep(1);
 
 	ret = rtl8192_QueryBBReg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData);
@@ -252,7 +252,7 @@ void rtl8192_phy_RFSerialWrite(struct net_device* dev, RF90_RADIO_PATH_E eRFPath
 		NewOffset = Offset;
 	}
 
-	// Put write addr in [5:0]  and write data in [31:16]
+	// Put write addr in [5:0] and write data in [31:16]
 	DataAndAddr = (Data<<16) | (NewOffset&0x3f);
 
 	// Write Operation
@@ -525,7 +525,7 @@ void rtl8192_phy_configmac(struct net_device* dev)
 }
 
 /******************************************************************************
- *function:  This function do dirty work
+ *function:  This function does dirty work
  *   input:  dev
  *  output:  none
  *  return:  none
@@ -578,7 +578,7 @@ void rtl8192_phyConfigBB(struct net_device* dev, u8 ConfigType)
 void rtl8192_InitBBRFRegDef(struct net_device* dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-// RF Interface Sowrtware Control
+// RF Interface Software Control
 	priv->PHYRegDef[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW; // 16 LSBs if read 32-bit from 0x870
 	priv->PHYRegDef[RF90_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW; // 16 MSBs if read 32-bit from 0x870 (16-bit for 0x872)
 	priv->PHYRegDef[RF90_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;// 16 LSBs if read 32-bit from 0x874
@@ -602,7 +602,7 @@ void rtl8192_InitBBRFRegDef(struct net_device* dev)
 	priv->PHYRegDef[RF90_PATH_C].rfintfe = rFPGA0_XC_RFInterfaceOE;// 16 MSBs if read 32-bit from 0x86A (16-bit for 0x86A)
 	priv->PHYRegDef[RF90_PATH_D].rfintfe = rFPGA0_XD_RFInterfaceOE;// 16 MSBs if read 32-bit from 0x86C (16-bit for 0x86E)
 
-	//Addr of LSSI. Wirte RF register by driver
+	//Addr of LSSI. Write RF register by driver
 	priv->PHYRegDef[RF90_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter; //LSSI Parameter
 	priv->PHYRegDef[RF90_PATH_B].rf3wireOffset = rFPGA0_XB_LSSIParameter;
 	priv->PHYRegDef[RF90_PATH_C].rf3wireOffset = rFPGA0_XC_LSSIParameter;
@@ -1384,7 +1384,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8* stage, u
 }
 
 /******************************************************************************
- *function:  This function does acturally set channel work
+ *function:  This function does actually set channel work
  *   input:  struct net_device *dev
  *   	     u8 		channel
  *  output:  none
@@ -1425,7 +1425,7 @@ void rtl8192_SwChnl_WorkItem(struct net_device *dev)
 }
 
 /******************************************************************************
- *function:  This function scheduled actural workitem to set channel
+ *function:  This function scheduled actual workitem to set channel
  *   input:  net_device dev
  *   	     u8		channel //channel to set
  *  output:  none

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 41684e8fcf4c..c4586b0817d1 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1531,13 +1531,13 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	{
 		case HT_CHANNEL_WIDTH_20:
 			regBwOpMode |= BW_OPMODE_20MHZ;
-		       // 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+		       // 2007/02/07 Mark by Emily because we have not verify whether this register works
 			write_nic_byte(dev, BW_OPMODE, regBwOpMode);
 			break;
 
 		case HT_CHANNEL_WIDTH_20_40:
 			regBwOpMode &= ~BW_OPMODE_20MHZ;
-			// 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+			// 2007/02/07 Mark by Emily because we have not verify whether this register works
 			write_nic_byte(dev, BW_OPMODE, regBwOpMode);
 			break;
 
@@ -1647,7 +1647,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 }
 
 /******************************************************************************
- *function:  This function schedules bandwith switch work.
+ *function:  This function schedules bandwidth switch work.
  *   input:  struct net_device *dev
  *   	     HT_CHANNEL_WIDTH	Bandwidth  //20M or 40M
  *   	     HT_EXTCHNL_OFFSET Offset 	   //Upper, Lower, or Don't care

commit 0e7a3e7a746b5dc6ccf9896e882441c4fdbfd09a
Author: David Chosrova <dada2372@gmail.com>
Date:   Mon Nov 29 21:50:48 2010 +0100

    Staging: rtl8192u: remove dead code to disable dot11d
    
    This patch removes all the ENABLE_DOT11D ifdefs.
    It is always defined for driver. DOT11D has to do with regulatory domains.
    
    What prompted this patch was a warning message in Sparse.
    
    drivers/staging/rtl8192u/r8192U_core.c:247:1: warning: "eqMacAddr"
    redefined in file included from drivers/staging/rtl8192u/:81:81:
    drivers/staging/rtl8192u/dot11d.h:35:1: warning: this is the location
    of the previous definition
    
    Now there are no ifdefs around dot11d.h it made no sense to have this
    second definition, so I removed that macro as well. ( Thanks Dan ;-) ).
    
    Acked-by. Dan Carpenter <error27@gmail.com>
    Signed-off-by: David Chosrova <dada2372@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 8e10992366fe..41684e8fcf4c 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -6,9 +6,7 @@
 #include "r8192U_dm.h"
 #include "r819xU_firmware_img.h"
 
-#ifdef ENABLE_DOT11D
 #include "dot11d.h"
-#endif
 static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
 	0,
 	0x085c, //2412 1
@@ -1257,13 +1255,11 @@ u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8* stage, u
 
 	RT_TRACE(COMP_CH, "====>%s()====stage:%d, step:%d, channel:%d\n", __FUNCTION__, *stage, *step, channel);
 //	RT_ASSERT(IsLegalChannel(Adapter, channel), ("illegal channel: %d\n", channel));
-#ifdef ENABLE_DOT11D
 	if (!IsLegalChannel(priv->ieee80211, channel))
 	{
 		RT_TRACE(COMP_ERR, "=============>set to illegal channel:%d\n", channel);
 		return true; //return true to tell upper caller function this channel setting is finished! Or it will in while loop.
 	}
-#endif
 //FIXME:need to check whether channel is legal or not here.WB
 
 

commit 859171ca92f2865453b4b2e17bf679c67044a833
Author: Joe Perches <joe@perches.com>
Date:   Sun Nov 14 19:04:48 2010 -0800

    drivers/staging: Remove unnecessary semicolons
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index a3adaedece9a..8e10992366fe 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1011,7 +1011,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device* dev, RF90_RADIO_PATH_E
 			break;
 	}
 
-	return ret;;
+	return ret;
 
 }
 /******************************************************************************

commit 50a09b3b099ebc8326b85b4f508fb47655e1fed3
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Tue Nov 3 07:45:50 2009 -0200

    Staging: rtl8192u: remove dead code
    
    Remove #ifse against older kernel versions;
    Remove codes marked with #if 0;
    Remove #if 1
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index beeab51a2c3b..a3adaedece9a 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1079,18 +1079,6 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 		switch( eRFPowerState )
 		{
 			case eRfOn:
-#if 0
-						rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x1);		// 0x860[4]
-						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3);		// 0x88c[4]
-						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x3); 		// 0x880[6:5]
-						rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0x3);			// 0xc04[3:0]
-						rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x3);			// 0xd04[3:0]
-						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter2, 0x7000, 0x3);	// 0x884[14:12]
-	//					for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
-		//					PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x2);
-
-						//SwChnl(Adapter->ChannelID);
-#endif
 	//RF-A, RF-B
 					//enable RF-Chip A/B
 					rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x1);	// 0x860[4]
@@ -1112,16 +1100,6 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 				break;
 
 			case eRfOff:
-#if 0
-						rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x0);		// 0x860[4]
-						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x0);		// 0x88c[4]
-						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x0); 		// 0x880[6:5]
-						rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0);			// 0xc04[3:0]
-						rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0);			// 0xd04[3:0]
-						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter2, 0x7000, 0x0);	// 0x884[14:12]
-	//					for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
-		//					PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);
-#endif
 					//RF-A, RF-B
 					//disable RF-Chip A/B
 					rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x0);	// 0x860[4]
@@ -1582,11 +1560,6 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 1);
 
 			// Correct the tx power for CCK rate in 20M. Suggest by YN, 20071207
-#if 0
-			write_nic_dword(dev, rCCK0_TxFilter1, 0x1a1b0000);
-			write_nic_dword(dev, rCCK0_TxFilter2, 0x090e1317);
-			write_nic_dword(dev, rCCK0_DebugPort, 0x00000204);
-#endif
 			priv->cck_present_attentuation =
 				priv->cck_present_attentuation_20Mdefault + priv->cck_present_attentuation_difference;
 
@@ -1617,12 +1590,6 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			rtl8192_setBBreg(dev, rCCK0_System, bCCKSideBand, (priv->nCur40MhzPrimeSC>>1));
 			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);
 			rtl8192_setBBreg(dev, rOFDM1_LSTF, 0xC00, priv->nCur40MhzPrimeSC);
-#if 0
-			// Correct the tx power for CCK rate in 40M. Suggest by YN, 20071207
-			write_nic_dword(dev, rCCK0_TxFilter1, 0x35360000);
-			write_nic_dword(dev, rCCK0_TxFilter2, 0x121c252e);
-			write_nic_dword(dev, rCCK0_DebugPort, 0x00000409);
-#endif
 			priv->cck_present_attentuation =
 				priv->cck_present_attentuation_40Mdefault + priv->cck_present_attentuation_difference;
 
@@ -1653,7 +1620,6 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	}
 	//Skip over setting of J-mode in BB register here. Default value is "None J mode". Emily 20070315
 
-#if 1
 	//<3>Set RF related register
 	switch( priv->rf_chip )
 	{
@@ -1679,7 +1645,6 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			RT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);
 			break;
 	}
-#endif
 	priv->SetBWModeInProgress= false;
 
 	RT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb(), %d", atomic_read(&(priv->ieee80211->atm_swbw)) );
@@ -1726,29 +1691,15 @@ void InitialGain819xUsb(struct net_device *dev,	u8 Operation)
 
 	if(priv->up)
 	{
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 		queue_delayed_work(priv->priv_wq,&priv->initialgain_operate_wq,0);
-	#else
-		#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-		schedule_task(&priv->initialgain_operate_wq);
-		#else
-		queue_work(priv->priv_wq,&priv->initialgain_operate_wq);
-		#endif
-	#endif
 	}
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,initialgain_operate_wq);
        struct net_device *dev = priv->ieee80211->dev;
-#else
-extern void InitialGainOperateWorkItemCallBack(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
 #define SCAN_RX_INITIAL_GAIN	0x17
 #define POWER_DETECTION_TH	0x08
 	u32	BitMask;

commit e406322b4b963e622f41d76193d8ca9e5435adb8
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Tue Nov 3 07:42:46 2009 -0200

    Staging: rtl8192u: remove bad whitespaces
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 00497d313f9b..beeab51a2c3b 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -94,7 +94,7 @@ void rtl8192_setBBreg(struct net_device* dev, u32 dwRegAddr, u32 dwBitMask, u32
 	{//if not "double word" write
 		OriginalValue = read_nic_dword(dev, dwRegAddr);
 		BitShift = rtl8192_CalculateBitShift(dwBitMask);
-            	NewValue = (((OriginalValue) & (~dwBitMask)) | (dwData << BitShift));
+		NewValue = (((OriginalValue) & (~dwBitMask)) | (dwData << BitShift));
 		write_nic_dword(dev, dwRegAddr, NewValue);
 	}else
 		write_nic_dword(dev, dwRegAddr, dwData);
@@ -265,7 +265,7 @@ void rtl8192_phy_RFSerialWrite(struct net_device* dev, RF90_RADIO_PATH_E eRFPath
 		priv->RfReg0Value[eRFPath] = Data;
 
 	// Switch back to Reg_Mode0;
- 	if(priv->rf_chip == RF_8256)
+	if(priv->rf_chip == RF_8256)
 	{
 		if(Offset != 0)
 		{
@@ -320,13 +320,13 @@ void rtl8192_phy_SetRFReg(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32
 	else
 	{
 		if (BitMask != bMask12Bits) // RF data is 12 bits only
-   	        {
+		{
 			Original_Value = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
-      			BitShift =  rtl8192_CalculateBitShift(BitMask);
-      			New_Value = (((Original_Value) & (~BitMask)) | (Data<< BitShift));
+			BitShift =  rtl8192_CalculateBitShift(BitMask);
+			New_Value = (((Original_Value) & (~BitMask)) | (Data<< BitShift));
 
 			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, New_Value);
-	        }else
+		}else
 			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, Data);
 	}
 	return;
@@ -360,8 +360,8 @@ u32 rtl8192_phy_QueryRFReg(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u3
 	else
 	{
 		Original_Value = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
-   		BitShift =  rtl8192_CalculateBitShift(BitMask);
-   		Readback_Value = (Original_Value & BitMask) >> BitShift;
+		BitShift =  rtl8192_CalculateBitShift(BitMask);
+		Readback_Value = (Original_Value & BitMask) >> BitShift;
 		return (Readback_Value);
 	}
 }
@@ -800,7 +800,7 @@ void rtl8192_BB_Config_ParaFile(struct net_device* dev)
 	dwRegValue = read_nic_dword(dev, CPU_GEN);
 	write_nic_dword(dev, CPU_GEN, (dwRegValue|CPU_GEN_BB_RST));
 
- 	/*----BB AGC table Initialization----*/
+	/*----BB AGC table Initialization----*/
 	//==m==>Set PHY REG From Header<==m==
 	rtl8192_phyConfigBB(dev, BaseBand_Config_AGC_TAB);
 
@@ -1563,7 +1563,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 
 		case HT_CHANNEL_WIDTH_20_40:
 			regBwOpMode &= ~BW_OPMODE_20MHZ;
-        		// 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+			// 2007/02/07 Mark by Emily becasue we have not verify whether this register works
 			write_nic_byte(dev, BW_OPMODE, regBwOpMode);
 			break;
 
@@ -1615,7 +1615,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			rtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x1);
 			rtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x1);
 			rtl8192_setBBreg(dev, rCCK0_System, bCCKSideBand, (priv->nCur40MhzPrimeSC>>1));
-                   	rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);
+			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);
 			rtl8192_setBBreg(dev, rOFDM1_LSTF, 0xC00, priv->nCur40MhzPrimeSC);
 #if 0
 			// Correct the tx power for CCK rate in 40M. Suggest by YN, 20071207

commit 8fc8598e61f6f384f3eaf1d9b09500c12af47b37
Author: Jerry Chuang <jerry-chuang@realtek.com>
Date:   Tue Nov 3 07:17:11 2009 -0200

    Staging: Added Realtek rtl8192u driver to staging
    
    Add Realtek linux driver for rtl8192u as provided by Realtek
    
    rtl8192u_linux_2.6.0006.1031.2008.tar.gz, send to me C/C staging ML.
    
    This version won't compile against upstream, doesn't follow
    Linux CodingStyle and has their own ieee80211 stack.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
new file mode 100644
index 000000000000..00497d313f9b
--- /dev/null
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -0,0 +1,1826 @@
+#include "r8192U.h"
+#include "r8192U_hw.h"
+#include "r819xU_phy.h"
+#include "r819xU_phyreg.h"
+#include "r8190_rtl8256.h"
+#include "r8192U_dm.h"
+#include "r819xU_firmware_img.h"
+
+#ifdef ENABLE_DOT11D
+#include "dot11d.h"
+#endif
+static u32 RF_CHANNEL_TABLE_ZEBRA[] = {
+	0,
+	0x085c, //2412 1
+	0x08dc, //2417 2
+	0x095c, //2422 3
+	0x09dc, //2427 4
+	0x0a5c, //2432 5
+	0x0adc, //2437 6
+	0x0b5c, //2442 7
+	0x0bdc, //2447 8
+	0x0c5c, //2452 9
+	0x0cdc, //2457 10
+	0x0d5c, //2462 11
+	0x0ddc, //2467 12
+	0x0e5c, //2472 13
+	0x0f72, //2484
+};
+
+
+#define rtl819XPHY_REG_1T2RArray Rtl8192UsbPHY_REG_1T2RArray
+#define rtl819XMACPHY_Array_PG Rtl8192UsbMACPHY_Array_PG
+#define rtl819XMACPHY_Array Rtl8192UsbMACPHY_Array
+#define rtl819XRadioA_Array  Rtl8192UsbRadioA_Array
+#define rtl819XRadioB_Array Rtl8192UsbRadioB_Array
+#define rtl819XRadioC_Array Rtl8192UsbRadioC_Array
+#define rtl819XRadioD_Array Rtl8192UsbRadioD_Array
+#define rtl819XAGCTAB_Array Rtl8192UsbAGCTAB_Array
+
+/******************************************************************************
+ *function:  This function read BB parameters from Header file we gen,
+ *	     and do register read/write
+ *   input:  u32	dwBitMask  //taget bit pos in the addr to be modified
+ *  output:  none
+ *  return:  u32	return the shift bit bit position of the mask
+ * ****************************************************************************/
+u32 rtl8192_CalculateBitShift(u32 dwBitMask)
+{
+	u32 i;
+	for (i=0; i<=31; i++)
+	{
+		if (((dwBitMask>>i)&0x1) == 1)
+			break;
+	}
+	return i;
+}
+/******************************************************************************
+ *function:  This function check different RF type to execute legal judgement. If RF Path is illegal, we will return false.
+ *   input:  none
+ *  output:  none
+ *  return:  0(illegal, false), 1(legal,true)
+ * ***************************************************************************/
+u8 rtl8192_phy_CheckIsLegalRFPath(struct net_device* dev, u32 eRFPath)
+{
+	u8 ret = 1;
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	if (priv->rf_type == RF_2T4R)
+		ret = 0;
+	else if (priv->rf_type == RF_1T2R)
+	{
+		if (eRFPath == RF90_PATH_A || eRFPath == RF90_PATH_B)
+			ret = 1;
+		else if (eRFPath == RF90_PATH_C || eRFPath == RF90_PATH_D)
+			ret = 0;
+	}
+	return ret;
+}
+/******************************************************************************
+ *function:  This function set specific bits to BB register
+ *   input:  net_device dev
+ *           u32	dwRegAddr  //target addr to be modified
+ *           u32	dwBitMask  //taget bit pos in the addr to be modified
+ *           u32	dwData     //value to be write
+ *  output:  none
+ *  return:  none
+ *  notice:
+ * ****************************************************************************/
+void rtl8192_setBBreg(struct net_device* dev, u32 dwRegAddr, u32 dwBitMask, u32 dwData)
+{
+
+	u32 OriginalValue, BitShift, NewValue;
+
+	if(dwBitMask!= bMaskDWord)
+	{//if not "double word" write
+		OriginalValue = read_nic_dword(dev, dwRegAddr);
+		BitShift = rtl8192_CalculateBitShift(dwBitMask);
+            	NewValue = (((OriginalValue) & (~dwBitMask)) | (dwData << BitShift));
+		write_nic_dword(dev, dwRegAddr, NewValue);
+	}else
+		write_nic_dword(dev, dwRegAddr, dwData);
+	return;
+}
+/******************************************************************************
+ *function:  This function reads specific bits from BB register
+ *   input:  net_device dev
+ *           u32	dwRegAddr  //target addr to be readback
+ *           u32	dwBitMask  //taget bit pos in the addr to be readback
+ *  output:  none
+ *  return:  u32	Data	//the readback register value
+ *  notice:
+ * ****************************************************************************/
+u32 rtl8192_QueryBBReg(struct net_device* dev, u32 dwRegAddr, u32 dwBitMask)
+{
+	u32 Ret = 0, OriginalValue, BitShift;
+
+	OriginalValue = read_nic_dword(dev, dwRegAddr);
+	BitShift = rtl8192_CalculateBitShift(dwBitMask);
+	Ret =(OriginalValue & dwBitMask) >> BitShift;
+
+	return (Ret);
+}
+static  u32 phy_FwRFSerialRead( struct net_device* dev, RF90_RADIO_PATH_E       eRFPath, u32 Offset  );
+
+static void phy_FwRFSerialWrite( struct net_device* dev, RF90_RADIO_PATH_E       eRFPath, u32  Offset, u32  Data);
+
+/******************************************************************************
+ *function:  This function read register from RF chip
+ *   input:  net_device dev
+ *   	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
+ *           u32	Offset     //target address to be read
+ *  output:  none
+ *  return:  u32 	readback value
+ *  notice:  There are three types of serial operations:(1) Software serial write.(2)Hardware LSSI-Low Speed Serial Interface.(3)Hardware HSSI-High speed serial write. Driver here need to implement (1) and (2)---need more spec for this information.
+ * ****************************************************************************/
+u32 rtl8192_phy_RFSerialRead(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u32 ret = 0;
+	u32 NewOffset = 0;
+	BB_REGISTER_DEFINITION_T* pPhyReg = &priv->PHYRegDef[eRFPath];
+	rtl8192_setBBreg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData, 0);
+	//make sure RF register offset is correct
+	Offset &= 0x3f;
+
+	//switch page for 8256 RF IC
+	if (priv->rf_chip == RF_8256)
+	{
+		if (Offset >= 31)
+		{
+			priv->RfReg0Value[eRFPath] |= 0x140;
+			//Switch to Reg_Mode2 for Reg 31-45
+			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16) );
+			//modify offset
+			NewOffset = Offset -30;
+		}
+		else if (Offset >= 16)
+		{
+			priv->RfReg0Value[eRFPath] |= 0x100;
+			priv->RfReg0Value[eRFPath] &= (~0x40);
+			//Switch to Reg_Mode 1 for Reg16-30
+			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16) );
+
+			NewOffset = Offset - 15;
+		}
+		else
+			NewOffset = Offset;
+	}
+	else
+	{
+		RT_TRACE((COMP_PHY|COMP_ERR), "check RF type here, need to be 8256\n");
+		NewOffset = Offset;
+	}
+	//put desired read addr to LSSI control Register
+	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadAddress, NewOffset);
+	//Issue a posedge trigger
+	//
+	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x0);
+	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x1);
+
+
+	// TODO: we should not delay such a  long time. Ask help from SD3
+	msleep(1);
+
+	ret = rtl8192_QueryBBReg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData);
+
+
+	// Switch back to Reg_Mode0;
+	if(priv->rf_chip == RF_8256)
+	{
+		priv->RfReg0Value[eRFPath] &= 0xebf;
+
+		rtl8192_setBBreg(
+			dev,
+			pPhyReg->rf3wireOffset,
+			bMaskDWord,
+			(priv->RfReg0Value[eRFPath] << 16));
+	}
+
+	return ret;
+
+}
+
+/******************************************************************************
+ *function:  This function write data to RF register
+ *   input:  net_device dev
+ *   	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
+ *           u32	Offset     //target address to be written
+ *           u32	Data	//The new register data to be written
+ *  output:  none
+ *  return:  none
+ *  notice:  For RF8256 only.
+  ===========================================================
+ *Reg Mode	RegCTL[1]	RegCTL[0]		Note
+ *		(Reg00[12])	(Reg00[10])
+ *===========================================================
+ *Reg_Mode0	0		x			Reg 0 ~15(0x0 ~ 0xf)
+ *------------------------------------------------------------------
+ *Reg_Mode1	1		0			Reg 16 ~30(0x1 ~ 0xf)
+ *------------------------------------------------------------------
+ * Reg_Mode2	1		1			Reg 31 ~ 45(0x1 ~ 0xf)
+ *------------------------------------------------------------------
+ * ****************************************************************************/
+void rtl8192_phy_RFSerialWrite(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u32 DataAndAddr = 0, NewOffset = 0;
+	BB_REGISTER_DEFINITION_T	*pPhyReg = &priv->PHYRegDef[eRFPath];
+
+	Offset &= 0x3f;
+	//spin_lock_irqsave(&priv->rf_lock, flags);
+//	down(&priv->rf_sem);
+	if (priv->rf_chip == RF_8256)
+	{
+
+		if (Offset >= 31)
+		{
+			priv->RfReg0Value[eRFPath] |= 0x140;
+			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath] << 16));
+			NewOffset = Offset - 30;
+		}
+		else if (Offset >= 16)
+		{
+			priv->RfReg0Value[eRFPath] |= 0x100;
+			priv->RfReg0Value[eRFPath] &= (~0x40);
+			rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));
+			NewOffset = Offset - 15;
+		}
+		else
+			NewOffset = Offset;
+	}
+	else
+	{
+		RT_TRACE((COMP_PHY|COMP_ERR), "check RF type here, need to be 8256\n");
+		NewOffset = Offset;
+	}
+
+	// Put write addr in [5:0]  and write data in [31:16]
+	DataAndAddr = (Data<<16) | (NewOffset&0x3f);
+
+	// Write Operation
+	rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);
+
+
+	if(Offset==0x0)
+		priv->RfReg0Value[eRFPath] = Data;
+
+	// Switch back to Reg_Mode0;
+ 	if(priv->rf_chip == RF_8256)
+	{
+		if(Offset != 0)
+		{
+			priv->RfReg0Value[eRFPath] &= 0xebf;
+			rtl8192_setBBreg(
+				dev,
+				pPhyReg->rf3wireOffset,
+				bMaskDWord,
+				(priv->RfReg0Value[eRFPath] << 16));
+		}
+	}
+	//spin_unlock_irqrestore(&priv->rf_lock, flags);
+//	up(&priv->rf_sem);
+	return;
+}
+
+/******************************************************************************
+ *function:  This function set specific bits to RF register
+ *   input:  net_device dev
+ *   	     RF90_RADIO_PATH_E eRFPath //radio path of A/B/C/D
+ *           u32	RegAddr  //target addr to be modified
+ *           u32	BitMask  //taget bit pos in the addr to be modified
+ *           u32	Data     //value to be write
+ *  output:  none
+ *  return:  none
+ *  notice:
+ * ****************************************************************************/
+void rtl8192_phy_SetRFReg(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask, u32 Data)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u32 Original_Value, BitShift, New_Value;
+//	u8	time = 0;
+
+	if (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))
+		return;
+
+	if (priv->Rf_Mode == RF_OP_By_FW)
+	{
+		if (BitMask != bMask12Bits) // RF data is 12 bits only
+		{
+			Original_Value = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
+			BitShift =  rtl8192_CalculateBitShift(BitMask);
+			New_Value = ((Original_Value) & (~BitMask)) | (Data<< BitShift);
+
+			phy_FwRFSerialWrite(dev, eRFPath, RegAddr, New_Value);
+		}else
+			phy_FwRFSerialWrite(dev, eRFPath, RegAddr, Data);
+
+		udelay(200);
+
+	}
+	else
+	{
+		if (BitMask != bMask12Bits) // RF data is 12 bits only
+   	        {
+			Original_Value = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
+      			BitShift =  rtl8192_CalculateBitShift(BitMask);
+      			New_Value = (((Original_Value) & (~BitMask)) | (Data<< BitShift));
+
+			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, New_Value);
+	        }else
+			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, Data);
+	}
+	return;
+}
+
+/******************************************************************************
+ *function:  This function reads specific bits from RF register
+ *   input:  net_device dev
+ *           u32	RegAddr  //target addr to be readback
+ *           u32	BitMask  //taget bit pos in the addr to be readback
+ *  output:  none
+ *  return:  u32	Data	//the readback register value
+ *  notice:
+ * ****************************************************************************/
+u32 rtl8192_phy_QueryRFReg(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask)
+{
+	u32 Original_Value, Readback_Value, BitShift;
+	struct r8192_priv *priv = ieee80211_priv(dev);
+
+
+	if (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))
+		return 0;
+	if (priv->Rf_Mode == RF_OP_By_FW)
+	{
+		Original_Value = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
+		BitShift =  rtl8192_CalculateBitShift(BitMask);
+		Readback_Value = (Original_Value & BitMask) >> BitShift;
+		udelay(200);
+		return (Readback_Value);
+	}
+	else
+	{
+		Original_Value = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
+   		BitShift =  rtl8192_CalculateBitShift(BitMask);
+   		Readback_Value = (Original_Value & BitMask) >> BitShift;
+		return (Readback_Value);
+	}
+}
+/******************************************************************************
+ *function:  We support firmware to execute RF-R/W.
+ *   input:  dev
+ *  output:  none
+ *  return:  none
+ *  notice:
+ * ***************************************************************************/
+static	u32
+phy_FwRFSerialRead(
+	struct net_device* dev,
+	RF90_RADIO_PATH_E	eRFPath,
+	u32				Offset	)
+{
+	u32		retValue = 0;
+	u32		Data = 0;
+	u8		time = 0;
+	//DbgPrint("FW RF CTRL\n\r");
+	/* 2007/11/02 MH Firmware RF Write control. By Francis' suggestion, we can
+	   not execute the scheme in the initial step. Otherwise, RF-R/W will waste
+	   much time. This is only for site survey. */
+	// 1. Read operation need not insert data. bit 0-11
+	//Data &= bMask12Bits;
+	// 2. Write RF register address. Bit 12-19
+	Data |= ((Offset&0xFF)<<12);
+	// 3. Write RF path.  bit 20-21
+	Data |= ((eRFPath&0x3)<<20);
+	// 4. Set RF read indicator. bit 22=0
+	//Data |= 0x00000;
+	// 5. Trigger Fw to operate the command. bit 31
+	Data |= 0x80000000;
+	// 6. We can not execute read operation if bit 31 is 1.
+	while (read_nic_dword(dev, QPNR)&0x80000000)
+	{
+		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
+		if (time++ < 100)
+		{
+			//DbgPrint("FW not finish RF-R Time=%d\n\r", time);
+			udelay(10);
+		}
+		else
+			break;
+	}
+	// 7. Execute read operation.
+	write_nic_dword(dev, QPNR, Data);
+	// 8. Check if firmawre send back RF content.
+	while (read_nic_dword(dev, QPNR)&0x80000000)
+	{
+		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
+		if (time++ < 100)
+		{
+			//DbgPrint("FW not finish RF-W Time=%d\n\r", time);
+			udelay(10);
+		}
+		else
+			return	(0);
+	}
+	retValue = read_nic_dword(dev, RF_DATA);
+
+	return	(retValue);
+
+}	/* phy_FwRFSerialRead */
+
+/******************************************************************************
+ *function:  We support firmware to execute RF-R/W.
+ *   input:  dev
+ *  output:  none
+ *  return:  none
+ *  notice:
+ * ***************************************************************************/
+static void
+phy_FwRFSerialWrite(
+		struct net_device* dev,
+		RF90_RADIO_PATH_E	eRFPath,
+		u32				Offset,
+		u32				Data	)
+{
+	u8	time = 0;
+
+	//DbgPrint("N FW RF CTRL RF-%d OF%02x DATA=%03x\n\r", eRFPath, Offset, Data);
+	/* 2007/11/02 MH Firmware RF Write control. By Francis' suggestion, we can
+	   not execute the scheme in the initial step. Otherwise, RF-R/W will waste
+	   much time. This is only for site survey. */
+
+	// 1. Set driver write bit and 12 bit data. bit 0-11
+	//Data &= bMask12Bits;	// Done by uper layer.
+	// 2. Write RF register address. bit 12-19
+	Data |= ((Offset&0xFF)<<12);
+	// 3. Write RF path.  bit 20-21
+	Data |= ((eRFPath&0x3)<<20);
+	// 4. Set RF write indicator. bit 22=1
+	Data |= 0x400000;
+	// 5. Trigger Fw to operate the command. bit 31=1
+	Data |= 0x80000000;
+
+	// 6. Write operation. We can not write if bit 31 is 1.
+	while (read_nic_dword(dev, QPNR)&0x80000000)
+	{
+		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
+		if (time++ < 100)
+		{
+			//DbgPrint("FW not finish RF-W Time=%d\n\r", time);
+			udelay(10);
+		}
+		else
+			break;
+	}
+	// 7. No matter check bit. We always force the write. Because FW will
+	//    not accept the command.
+	write_nic_dword(dev, QPNR, Data);
+	/* 2007/11/02 MH Acoording to test, we must delay 20us to wait firmware
+	   to finish RF write operation. */
+	/* 2008/01/17 MH We support delay in firmware side now. */
+	//delay_us(20);
+
+}	/* phy_FwRFSerialWrite */
+
+
+/******************************************************************************
+ *function:  This function read BB parameters from Header file we gen,
+ *	     and do register read/write
+ *   input:  dev
+ *  output:  none
+ *  return:  none
+ *  notice:  BB parameters may change all the time, so please make
+ *           sure it has been synced with the newest.
+ * ***************************************************************************/
+void rtl8192_phy_configmac(struct net_device* dev)
+{
+	u32 dwArrayLen = 0, i;
+	u32* pdwArray = NULL;
+	struct r8192_priv *priv = ieee80211_priv(dev);
+
+	if(priv->btxpowerdata_readfromEEPORM)
+	{
+		RT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array_PG\n");
+		dwArrayLen = MACPHY_Array_PGLength;
+		pdwArray = rtl819XMACPHY_Array_PG;
+
+	}
+	else
+	{
+		RT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array\n");
+		dwArrayLen = MACPHY_ArrayLength;
+		pdwArray = rtl819XMACPHY_Array;
+	}
+	for(i = 0; i<dwArrayLen; i=i+3){
+		if(pdwArray[i] == 0x318)
+		{
+			pdwArray[i+2] = 0x00000800;
+			//DbgPrint("ptrArray[i], ptrArray[i+1], ptrArray[i+2] = %x, %x, %x\n",
+			//	ptrArray[i], ptrArray[i+1], ptrArray[i+2]);
+		}
+
+		RT_TRACE(COMP_DBG, "The Rtl8190MACPHY_Array[0] is %x Rtl8190MACPHY_Array[1] is %x Rtl8190MACPHY_Array[2] is %x\n",
+				pdwArray[i], pdwArray[i+1], pdwArray[i+2]);
+		rtl8192_setBBreg(dev, pdwArray[i], pdwArray[i+1], pdwArray[i+2]);
+	}
+	return;
+
+}
+
+/******************************************************************************
+ *function:  This function do dirty work
+ *   input:  dev
+ *  output:  none
+ *  return:  none
+ *  notice:  BB parameters may change all the time, so please make
+ *           sure it has been synced with the newest.
+ * ***************************************************************************/
+
+void rtl8192_phyConfigBB(struct net_device* dev, u8 ConfigType)
+{
+	u32 i;
+
+#ifdef TO_DO_LIST
+	u32 *rtl8192PhyRegArrayTable = NULL, *rtl8192AgcTabArrayTable = NULL;
+	if(Adapter->bInHctTest)
+	{
+		PHY_REGArrayLen = PHY_REGArrayLengthDTM;
+		AGCTAB_ArrayLen = AGCTAB_ArrayLengthDTM;
+		Rtl8190PHY_REGArray_Table = Rtl819XPHY_REGArrayDTM;
+		Rtl8190AGCTAB_Array_Table = Rtl819XAGCTAB_ArrayDTM;
+	}
+#endif
+	if (ConfigType == BaseBand_Config_PHY_REG)
+	{
+		for (i=0; i<PHY_REG_1T2RArrayLength; i+=2)
+		{
+			rtl8192_setBBreg(dev, rtl819XPHY_REG_1T2RArray[i], bMaskDWord, rtl819XPHY_REG_1T2RArray[i+1]);
+			RT_TRACE(COMP_DBG, "i: %x, The Rtl819xUsbPHY_REGArray[0] is %x Rtl819xUsbPHY_REGArray[1] is %x \n",i, rtl819XPHY_REG_1T2RArray[i], rtl819XPHY_REG_1T2RArray[i+1]);
+		}
+	}
+	else if (ConfigType == BaseBand_Config_AGC_TAB)
+	{
+		for (i=0; i<AGCTAB_ArrayLength; i+=2)
+		{
+			rtl8192_setBBreg(dev, rtl819XAGCTAB_Array[i], bMaskDWord, rtl819XAGCTAB_Array[i+1]);
+			RT_TRACE(COMP_DBG, "i:%x, The rtl819XAGCTAB_Array[0] is %x rtl819XAGCTAB_Array[1] is %x \n",i, rtl819XAGCTAB_Array[i], rtl819XAGCTAB_Array[i+1]);
+		}
+	}
+	return;
+
+
+}
+/******************************************************************************
+ *function:  This function initialize Register definition offset for Radio Path
+ *	     A/B/C/D
+ *   input:  net_device dev
+ *  output:  none
+ *  return:  none
+ *  notice:  Initialization value here is constant and it should never be changed
+ * ***************************************************************************/
+void rtl8192_InitBBRFRegDef(struct net_device* dev)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+// RF Interface Sowrtware Control
+	priv->PHYRegDef[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW; // 16 LSBs if read 32-bit from 0x870
+	priv->PHYRegDef[RF90_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW; // 16 MSBs if read 32-bit from 0x870 (16-bit for 0x872)
+	priv->PHYRegDef[RF90_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;// 16 LSBs if read 32-bit from 0x874
+	priv->PHYRegDef[RF90_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;// 16 MSBs if read 32-bit from 0x874 (16-bit for 0x876)
+
+	// RF Interface Readback Value
+	priv->PHYRegDef[RF90_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB; // 16 LSBs if read 32-bit from 0x8E0
+	priv->PHYRegDef[RF90_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;// 16 MSBs if read 32-bit from 0x8E0 (16-bit for 0x8E2)
+	priv->PHYRegDef[RF90_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;// 16 LSBs if read 32-bit from 0x8E4
+	priv->PHYRegDef[RF90_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;// 16 MSBs if read 32-bit from 0x8E4 (16-bit for 0x8E6)
+
+	// RF Interface Output (and Enable)
+	priv->PHYRegDef[RF90_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE; // 16 LSBs if read 32-bit from 0x860
+	priv->PHYRegDef[RF90_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE; // 16 LSBs if read 32-bit from 0x864
+	priv->PHYRegDef[RF90_PATH_C].rfintfo = rFPGA0_XC_RFInterfaceOE;// 16 LSBs if read 32-bit from 0x868
+	priv->PHYRegDef[RF90_PATH_D].rfintfo = rFPGA0_XD_RFInterfaceOE;// 16 LSBs if read 32-bit from 0x86C
+
+	// RF Interface (Output and)  Enable
+	priv->PHYRegDef[RF90_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE; // 16 MSBs if read 32-bit from 0x860 (16-bit for 0x862)
+	priv->PHYRegDef[RF90_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE; // 16 MSBs if read 32-bit from 0x864 (16-bit for 0x866)
+	priv->PHYRegDef[RF90_PATH_C].rfintfe = rFPGA0_XC_RFInterfaceOE;// 16 MSBs if read 32-bit from 0x86A (16-bit for 0x86A)
+	priv->PHYRegDef[RF90_PATH_D].rfintfe = rFPGA0_XD_RFInterfaceOE;// 16 MSBs if read 32-bit from 0x86C (16-bit for 0x86E)
+
+	//Addr of LSSI. Wirte RF register by driver
+	priv->PHYRegDef[RF90_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter; //LSSI Parameter
+	priv->PHYRegDef[RF90_PATH_B].rf3wireOffset = rFPGA0_XB_LSSIParameter;
+	priv->PHYRegDef[RF90_PATH_C].rf3wireOffset = rFPGA0_XC_LSSIParameter;
+	priv->PHYRegDef[RF90_PATH_D].rf3wireOffset = rFPGA0_XD_LSSIParameter;
+
+	// RF parameter
+	priv->PHYRegDef[RF90_PATH_A].rfLSSI_Select = rFPGA0_XAB_RFParameter;  //BB Band Select
+	priv->PHYRegDef[RF90_PATH_B].rfLSSI_Select = rFPGA0_XAB_RFParameter;
+	priv->PHYRegDef[RF90_PATH_C].rfLSSI_Select = rFPGA0_XCD_RFParameter;
+	priv->PHYRegDef[RF90_PATH_D].rfLSSI_Select = rFPGA0_XCD_RFParameter;
+
+	// Tx AGC Gain Stage (same for all path. Should we remove this?)
+	priv->PHYRegDef[RF90_PATH_A].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
+	priv->PHYRegDef[RF90_PATH_B].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
+	priv->PHYRegDef[RF90_PATH_C].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
+	priv->PHYRegDef[RF90_PATH_D].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
+
+	// Tranceiver A~D HSSI Parameter-1
+	priv->PHYRegDef[RF90_PATH_A].rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;  //wire control parameter1
+	priv->PHYRegDef[RF90_PATH_B].rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;  //wire control parameter1
+	priv->PHYRegDef[RF90_PATH_C].rfHSSIPara1 = rFPGA0_XC_HSSIParameter1;  //wire control parameter1
+	priv->PHYRegDef[RF90_PATH_D].rfHSSIPara1 = rFPGA0_XD_HSSIParameter1;  //wire control parameter1
+
+	// Tranceiver A~D HSSI Parameter-2
+	priv->PHYRegDef[RF90_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;  //wire control parameter2
+	priv->PHYRegDef[RF90_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;  //wire control parameter2
+	priv->PHYRegDef[RF90_PATH_C].rfHSSIPara2 = rFPGA0_XC_HSSIParameter2;  //wire control parameter2
+	priv->PHYRegDef[RF90_PATH_D].rfHSSIPara2 = rFPGA0_XD_HSSIParameter2;  //wire control parameter1
+
+	// RF switch Control
+	priv->PHYRegDef[RF90_PATH_A].rfSwitchControl = rFPGA0_XAB_SwitchControl; //TR/Ant switch control
+	priv->PHYRegDef[RF90_PATH_B].rfSwitchControl = rFPGA0_XAB_SwitchControl;
+	priv->PHYRegDef[RF90_PATH_C].rfSwitchControl = rFPGA0_XCD_SwitchControl;
+	priv->PHYRegDef[RF90_PATH_D].rfSwitchControl = rFPGA0_XCD_SwitchControl;
+
+	// AGC control 1
+	priv->PHYRegDef[RF90_PATH_A].rfAGCControl1 = rOFDM0_XAAGCCore1;
+	priv->PHYRegDef[RF90_PATH_B].rfAGCControl1 = rOFDM0_XBAGCCore1;
+	priv->PHYRegDef[RF90_PATH_C].rfAGCControl1 = rOFDM0_XCAGCCore1;
+	priv->PHYRegDef[RF90_PATH_D].rfAGCControl1 = rOFDM0_XDAGCCore1;
+
+	// AGC control 2
+	priv->PHYRegDef[RF90_PATH_A].rfAGCControl2 = rOFDM0_XAAGCCore2;
+	priv->PHYRegDef[RF90_PATH_B].rfAGCControl2 = rOFDM0_XBAGCCore2;
+	priv->PHYRegDef[RF90_PATH_C].rfAGCControl2 = rOFDM0_XCAGCCore2;
+	priv->PHYRegDef[RF90_PATH_D].rfAGCControl2 = rOFDM0_XDAGCCore2;
+
+	// RX AFE control 1
+	priv->PHYRegDef[RF90_PATH_A].rfRxIQImbalance = rOFDM0_XARxIQImbalance;
+	priv->PHYRegDef[RF90_PATH_B].rfRxIQImbalance = rOFDM0_XBRxIQImbalance;
+	priv->PHYRegDef[RF90_PATH_C].rfRxIQImbalance = rOFDM0_XCRxIQImbalance;
+	priv->PHYRegDef[RF90_PATH_D].rfRxIQImbalance = rOFDM0_XDRxIQImbalance;
+
+	// RX AFE control 1
+	priv->PHYRegDef[RF90_PATH_A].rfRxAFE = rOFDM0_XARxAFE;
+	priv->PHYRegDef[RF90_PATH_B].rfRxAFE = rOFDM0_XBRxAFE;
+	priv->PHYRegDef[RF90_PATH_C].rfRxAFE = rOFDM0_XCRxAFE;
+	priv->PHYRegDef[RF90_PATH_D].rfRxAFE = rOFDM0_XDRxAFE;
+
+	// Tx AFE control 1
+	priv->PHYRegDef[RF90_PATH_A].rfTxIQImbalance = rOFDM0_XATxIQImbalance;
+	priv->PHYRegDef[RF90_PATH_B].rfTxIQImbalance = rOFDM0_XBTxIQImbalance;
+	priv->PHYRegDef[RF90_PATH_C].rfTxIQImbalance = rOFDM0_XCTxIQImbalance;
+	priv->PHYRegDef[RF90_PATH_D].rfTxIQImbalance = rOFDM0_XDTxIQImbalance;
+
+	// Tx AFE control 2
+	priv->PHYRegDef[RF90_PATH_A].rfTxAFE = rOFDM0_XATxAFE;
+	priv->PHYRegDef[RF90_PATH_B].rfTxAFE = rOFDM0_XBTxAFE;
+	priv->PHYRegDef[RF90_PATH_C].rfTxAFE = rOFDM0_XCTxAFE;
+	priv->PHYRegDef[RF90_PATH_D].rfTxAFE = rOFDM0_XDTxAFE;
+
+	// Tranceiver LSSI Readback
+	priv->PHYRegDef[RF90_PATH_A].rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;
+	priv->PHYRegDef[RF90_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;
+	priv->PHYRegDef[RF90_PATH_C].rfLSSIReadBack = rFPGA0_XC_LSSIReadBack;
+	priv->PHYRegDef[RF90_PATH_D].rfLSSIReadBack = rFPGA0_XD_LSSIReadBack;
+
+}
+/******************************************************************************
+ *function:  This function is to write register and then readback to make sure whether BB and RF is OK
+ *   input:  net_device dev
+ *   	     HW90_BLOCK_E CheckBlock
+ *   	     RF90_RADIO_PATH_E eRFPath  //only used when checkblock is HW90_BLOCK_RF
+ *  output:  none
+ *  return:  return whether BB and RF is ok(0:OK; 1:Fail)
+ *  notice:  This function may be removed in the ASIC
+ * ***************************************************************************/
+u8 rtl8192_phy_checkBBAndRF(struct net_device* dev, HW90_BLOCK_E CheckBlock, RF90_RADIO_PATH_E eRFPath)
+{
+//	struct r8192_priv *priv = ieee80211_priv(dev);
+//	BB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[eRFPath];
+	u8 ret = 0;
+	u32 i, CheckTimes = 4, dwRegRead = 0;
+	u32 WriteAddr[4];
+	u32 WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};
+	// Initialize register address offset to be checked
+	WriteAddr[HW90_BLOCK_MAC] = 0x100;
+	WriteAddr[HW90_BLOCK_PHY0] = 0x900;
+	WriteAddr[HW90_BLOCK_PHY1] = 0x800;
+	WriteAddr[HW90_BLOCK_RF] = 0x3;
+	RT_TRACE(COMP_PHY, "=======>%s(), CheckBlock:%d\n", __FUNCTION__, CheckBlock);
+	for(i=0 ; i < CheckTimes ; i++)
+	{
+
+		//
+		// Write Data to register and readback
+		//
+		switch(CheckBlock)
+		{
+		case HW90_BLOCK_MAC:
+			RT_TRACE(COMP_ERR, "PHY_CheckBBRFOK(): Never Write 0x100 here!");
+			break;
+
+		case HW90_BLOCK_PHY0:
+		case HW90_BLOCK_PHY1:
+			write_nic_dword(dev, WriteAddr[CheckBlock], WriteData[i]);
+			dwRegRead = read_nic_dword(dev, WriteAddr[CheckBlock]);
+			break;
+
+		case HW90_BLOCK_RF:
+			WriteData[i] &= 0xfff;
+			rtl8192_phy_SetRFReg(dev, eRFPath, WriteAddr[HW90_BLOCK_RF], bMask12Bits, WriteData[i]);
+			// TODO: we should not delay for such a long time. Ask SD3
+			msleep(1);
+			dwRegRead = rtl8192_phy_QueryRFReg(dev, eRFPath, WriteAddr[HW90_BLOCK_RF], bMask12Bits);
+			msleep(1);
+			break;
+
+		default:
+			ret = 1;
+			break;
+		}
+
+
+		//
+		// Check whether readback data is correct
+		//
+		if(dwRegRead != WriteData[i])
+		{
+			RT_TRACE((COMP_PHY|COMP_ERR), "====>error=====dwRegRead: %x, WriteData: %x \n", dwRegRead, WriteData[i]);
+			ret = 1;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+
+/******************************************************************************
+ *function:  This function initialize BB&RF
+ *   input:  net_device dev
+ *  output:  none
+ *  return:  none
+ *  notice:  Initialization value may change all the time, so please make
+ *           sure it has been synced with the newest.
+ * ***************************************************************************/
+void rtl8192_BB_Config_ParaFile(struct net_device* dev)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u8 bRegValue = 0, eCheckItem = 0, rtStatus = 0;
+	u32 dwRegValue = 0;
+	/**************************************
+	//<1>Initialize BaseBand
+	**************************************/
+
+	/*--set BB Global Reset--*/
+	bRegValue = read_nic_byte(dev, BB_GLOBAL_RESET);
+	write_nic_byte(dev, BB_GLOBAL_RESET,(bRegValue|BB_GLOBAL_RESET_BIT));
+	mdelay(50);
+	/*---set BB reset Active---*/
+	dwRegValue = read_nic_dword(dev, CPU_GEN);
+	write_nic_dword(dev, CPU_GEN, (dwRegValue&(~CPU_GEN_BB_RST)));
+
+	/*----Ckeck FPGAPHY0 and PHY1 board is OK----*/
+	// TODO: this function should be removed on ASIC , Emily 2007.2.2
+	for(eCheckItem=(HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem<=HW90_BLOCK_PHY1; eCheckItem++)
+	{
+		rtStatus  = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem, (RF90_RADIO_PATH_E)0); //don't care RF path
+		if(rtStatus != 0)
+		{
+			RT_TRACE((COMP_ERR | COMP_PHY), "PHY_RF8256_Config():Check PHY%d Fail!!\n", eCheckItem-1);
+			return ;
+		}
+	}
+	/*---- Set CCK and OFDM Block "OFF"----*/
+	rtl8192_setBBreg(dev, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x0);
+	/*----BB Register Initilazation----*/
+	//==m==>Set PHY REG From Header<==m==
+	rtl8192_phyConfigBB(dev, BaseBand_Config_PHY_REG);
+
+	/*----Set BB reset de-Active----*/
+	dwRegValue = read_nic_dword(dev, CPU_GEN);
+	write_nic_dword(dev, CPU_GEN, (dwRegValue|CPU_GEN_BB_RST));
+
+ 	/*----BB AGC table Initialization----*/
+	//==m==>Set PHY REG From Header<==m==
+	rtl8192_phyConfigBB(dev, BaseBand_Config_AGC_TAB);
+
+	/*----Enable XSTAL ----*/
+	write_nic_byte_E(dev, 0x5e, 0x00);
+	if (priv->card_8192_version == (u8)VERSION_819xU_A)
+	{
+		//Antenna gain offset from B/C/D to A
+		dwRegValue = (priv->AntennaTxPwDiff[1]<<4 | priv->AntennaTxPwDiff[0]);
+		rtl8192_setBBreg(dev, rFPGA0_TxGainStage, (bXBTxAGC|bXCTxAGC), dwRegValue);
+
+		//XSTALLCap
+		dwRegValue = priv->CrystalCap & 0xf;
+		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, bXtalCap, dwRegValue);
+	}
+
+	// Check if the CCK HighPower is turned ON.
+	// This is used to calculate PWDB.
+	priv->bCckHighPower = (u8)(rtl8192_QueryBBReg(dev, rFPGA0_XA_HSSIParameter2, 0x200));
+	return;
+}
+/******************************************************************************
+ *function:  This function initialize BB&RF
+ *   input:  net_device dev
+ *  output:  none
+ *  return:  none
+ *  notice:  Initialization value may change all the time, so please make
+ *           sure it has been synced with the newest.
+ * ***************************************************************************/
+void rtl8192_BBConfig(struct net_device* dev)
+{
+	rtl8192_InitBBRFRegDef(dev);
+	//config BB&RF. As hardCode based initialization has not been well
+	//implemented, so use file first.FIXME:should implement it for hardcode?
+	rtl8192_BB_Config_ParaFile(dev);
+	return;
+}
+
+/******************************************************************************
+ *function:  This function obtains the initialization value of Tx power Level offset
+ *   input:  net_device dev
+ *  output:  none
+ *  return:  none
+ * ***************************************************************************/
+void rtl8192_phy_getTxPower(struct net_device* dev)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	priv->MCSTxPowerLevelOriginalOffset[0] =
+		read_nic_dword(dev, rTxAGC_Rate18_06);
+	priv->MCSTxPowerLevelOriginalOffset[1] =
+		read_nic_dword(dev, rTxAGC_Rate54_24);
+	priv->MCSTxPowerLevelOriginalOffset[2] =
+		read_nic_dword(dev, rTxAGC_Mcs03_Mcs00);
+	priv->MCSTxPowerLevelOriginalOffset[3] =
+		read_nic_dword(dev, rTxAGC_Mcs07_Mcs04);
+	priv->MCSTxPowerLevelOriginalOffset[4] =
+		read_nic_dword(dev, rTxAGC_Mcs11_Mcs08);
+	priv->MCSTxPowerLevelOriginalOffset[5] =
+		read_nic_dword(dev, rTxAGC_Mcs15_Mcs12);
+
+	// read rx initial gain
+	priv->DefaultInitialGain[0] = read_nic_byte(dev, rOFDM0_XAAGCCore1);
+	priv->DefaultInitialGain[1] = read_nic_byte(dev, rOFDM0_XBAGCCore1);
+	priv->DefaultInitialGain[2] = read_nic_byte(dev, rOFDM0_XCAGCCore1);
+	priv->DefaultInitialGain[3] = read_nic_byte(dev, rOFDM0_XDAGCCore1);
+	RT_TRACE(COMP_INIT, "Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x) \n",
+		priv->DefaultInitialGain[0], priv->DefaultInitialGain[1],
+		priv->DefaultInitialGain[2], priv->DefaultInitialGain[3]);
+
+	// read framesync
+	priv->framesync = read_nic_byte(dev, rOFDM0_RxDetector3);
+	priv->framesyncC34 = read_nic_byte(dev, rOFDM0_RxDetector2);
+	RT_TRACE(COMP_INIT, "Default framesync (0x%x) = 0x%x \n",
+		rOFDM0_RxDetector3, priv->framesync);
+
+	// read SIFS (save the value read fome MACPHY_REG.txt)
+	priv->SifsTime = read_nic_word(dev, SIFS);
+
+	return;
+}
+
+/******************************************************************************
+ *function:  This function obtains the initialization value of Tx power Level offset
+ *   input:  net_device dev
+ *  output:  none
+ *  return:  none
+ * ***************************************************************************/
+void rtl8192_phy_setTxPower(struct net_device* dev, u8 channel)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u8	powerlevel = priv->TxPowerLevelCCK[channel-1];
+	u8	powerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];
+
+	switch(priv->rf_chip)
+	{
+	case RF_8256:
+		PHY_SetRF8256CCKTxPower(dev, powerlevel); //need further implement
+		PHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);
+		break;
+	default:
+//	case RF_8225:
+//	case RF_8258:
+		RT_TRACE((COMP_PHY|COMP_ERR), "error RF chipID(8225 or 8258) in function %s()\n", __FUNCTION__);
+		break;
+	}
+	return;
+}
+
+/******************************************************************************
+ *function:  This function check Rf chip to do RF config
+ *   input:  net_device dev
+ *  output:  none
+ *  return:  only 8256 is supported
+ * ***************************************************************************/
+void rtl8192_phy_RFConfig(struct net_device* dev)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+
+	switch(priv->rf_chip)
+	{
+		case RF_8256:
+			PHY_RF8256_Config(dev);
+			break;
+	//	case RF_8225:
+	//	case RF_8258:
+		default:
+			RT_TRACE(COMP_ERR, "error chip id\n");
+			break;
+	}
+	return;
+}
+
+/******************************************************************************
+ *function:  This function update Initial gain
+ *   input:  net_device dev
+ *  output:  none
+ *  return:  As Windows has not implemented this, wait for complement
+ * ***************************************************************************/
+void rtl8192_phy_updateInitGain(struct net_device* dev)
+{
+	return;
+}
+
+/******************************************************************************
+ *function:  This function read RF parameters from general head file, and do RF 3-wire
+ *   input:  net_device dev
+ *  output:  none
+ *  return:  return code show if RF configuration is successful(0:pass, 1:fail)
+ *    Note:  Delay may be required for RF configuration
+ * ***************************************************************************/
+u8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device* dev, RF90_RADIO_PATH_E	eRFPath)
+{
+
+	int i;
+	//u32* pRFArray;
+	u8 ret = 0;
+
+	switch(eRFPath){
+		case RF90_PATH_A:
+			for(i = 0;i<RadioA_ArrayLength; i=i+2){
+
+				if(rtl819XRadioA_Array[i] == 0xfe){
+						mdelay(100);
+						continue;
+				}
+				rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioA_Array[i], bMask12Bits, rtl819XRadioA_Array[i+1]);
+				mdelay(1);
+
+			}
+			break;
+		case RF90_PATH_B:
+			for(i = 0;i<RadioB_ArrayLength; i=i+2){
+
+				if(rtl819XRadioB_Array[i] == 0xfe){
+						mdelay(100);
+						continue;
+				}
+				rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioB_Array[i], bMask12Bits, rtl819XRadioB_Array[i+1]);
+				mdelay(1);
+
+			}
+			break;
+		case RF90_PATH_C:
+			for(i = 0;i<RadioC_ArrayLength; i=i+2){
+
+				if(rtl819XRadioC_Array[i] == 0xfe){
+						mdelay(100);
+						continue;
+				}
+				rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioC_Array[i], bMask12Bits, rtl819XRadioC_Array[i+1]);
+				mdelay(1);
+
+			}
+			break;
+		case RF90_PATH_D:
+			for(i = 0;i<RadioD_ArrayLength; i=i+2){
+
+				if(rtl819XRadioD_Array[i] == 0xfe){
+						mdelay(100);
+						continue;
+				}
+				rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioD_Array[i], bMask12Bits, rtl819XRadioD_Array[i+1]);
+				mdelay(1);
+
+			}
+			break;
+		default:
+			break;
+	}
+
+	return ret;;
+
+}
+/******************************************************************************
+ *function:  This function set Tx Power of the channel
+ *   input:  struct net_device *dev
+ *   	     u8 		channel
+ *  output:  none
+ *  return:  none
+ *    Note:
+ * ***************************************************************************/
+void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u8	powerlevel = priv->TxPowerLevelCCK[channel-1];
+	u8	powerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];
+
+	switch(priv->rf_chip)
+	{
+	case RF_8225:
+#ifdef TO_DO_LIST
+		PHY_SetRF8225CckTxPower(Adapter, powerlevel);
+		PHY_SetRF8225OfdmTxPower(Adapter, powerlevelOFDM24G);
+#endif
+		break;
+
+	case RF_8256:
+		PHY_SetRF8256CCKTxPower(dev, powerlevel);
+		PHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);
+		break;
+
+	case RF_8258:
+		break;
+	default:
+		RT_TRACE(COMP_ERR, "unknown rf chip ID in rtl8192_SetTxPowerLevel()\n");
+		break;
+	}
+	return;
+}
+
+/******************************************************************************
+ *function:  This function set RF state on or off
+ *   input:  struct net_device *dev
+ *   	     RT_RF_POWER_STATE eRFPowerState  //Power State to set
+ *  output:  none
+ *  return:  none
+ *    Note:
+ * ***************************************************************************/
+bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerState)
+{
+	bool				bResult = true;
+//	u8					eRFPath;
+	struct r8192_priv *priv = ieee80211_priv(dev);
+
+	if(eRFPowerState == priv->ieee80211->eRFPowerState)
+		return false;
+
+	if(priv->SetRFPowerStateInProgress == true)
+		return false;
+
+	priv->SetRFPowerStateInProgress = true;
+
+	switch(priv->rf_chip)
+	{
+		case RF_8256:
+		switch( eRFPowerState )
+		{
+			case eRfOn:
+#if 0
+						rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x1);		// 0x860[4]
+						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3);		// 0x88c[4]
+						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x3); 		// 0x880[6:5]
+						rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0x3);			// 0xc04[3:0]
+						rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x3);			// 0xd04[3:0]
+						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter2, 0x7000, 0x3);	// 0x884[14:12]
+	//					for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+		//					PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x2);
+
+						//SwChnl(Adapter->ChannelID);
+#endif
+	//RF-A, RF-B
+					//enable RF-Chip A/B
+					rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x1);	// 0x860[4]
+					//analog to digital on
+					rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3);// 0x88c[9:8]
+					//digital to analog on
+					rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18, 0x3); // 0x880[4:3]
+					//rx antenna on
+					rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0x3, 0x3);// 0xc04[1:0]
+					//rx antenna on
+					rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0x3, 0x3);// 0xd04[1:0]
+					//analog to digital part2 on
+					rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x3); // 0x880[6:5]
+
+				break;
+
+			case eRfSleep:
+
+				break;
+
+			case eRfOff:
+#if 0
+						rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x0);		// 0x860[4]
+						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x0);		// 0x88c[4]
+						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x0); 		// 0x880[6:5]
+						rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0);			// 0xc04[3:0]
+						rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0);			// 0xd04[3:0]
+						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter2, 0x7000, 0x0);	// 0x884[14:12]
+	//					for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+		//					PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);
+#endif
+					//RF-A, RF-B
+					//disable RF-Chip A/B
+					rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x0);	// 0x860[4]
+					//analog to digital off, for power save
+					rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00, 0x0);// 0x88c[11:8]
+					//digital to analog off, for power save
+					rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18, 0x0); // 0x880[4:3]
+					//rx antenna off
+					rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0x0);// 0xc04[3:0]
+					//rx antenna off
+					rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x0);// 0xd04[3:0]
+					//analog to digital part2 off, for power save
+					rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x0); // 0x880[6:5]
+
+				break;
+
+			default:
+				bResult = false;
+				RT_TRACE(COMP_ERR, "SetRFPowerState819xUsb(): unknow state to set: 0x%X!!!\n", eRFPowerState);
+				break;
+		}
+			break;
+		default:
+			RT_TRACE(COMP_ERR, "Not support rf_chip(%x)\n", priv->rf_chip);
+			break;
+	}
+#ifdef TO_DO_LIST
+	if(bResult)
+	{
+		// Update current RF state variable.
+		pHalData->eRFPowerState = eRFPowerState;
+		switch(pHalData->RFChipID )
+		{
+			case RF_8256:
+		switch(pHalData->eRFPowerState)
+				{
+				case eRfOff:
+					//
+					//If Rf off reason is from IPS, Led should blink with no link, by Maddest 071015
+					//
+					if(pMgntInfo->RfOffReason==RF_CHANGE_BY_IPS )
+					{
+						Adapter->HalFunc.LedControlHandler(Adapter,LED_CTL_NO_LINK);
+					}
+					else
+					{
+						// Turn off LED if RF is not ON.
+						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_POWER_OFF);
+					}
+					break;
+
+				case eRfOn:
+					// Turn on RF we are still linked, which might happen when
+					// we quickly turn off and on HW RF. 2006.05.12, by rcnjko.
+					if( pMgntInfo->bMediaConnect == TRUE )
+					{
+						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_LINK);
+					}
+					else
+					{
+						// Turn off LED if RF is not ON.
+						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);
+					}
+					break;
+
+				default:
+					// do nothing.
+					break;
+				}// Switch RF state
+				break;
+
+				default:
+					RT_TRACE(COMP_RF, DBG_LOUD, ("SetRFPowerState8190(): Unknown RF type\n"));
+					break;
+			}
+
+	}
+#endif
+	priv->SetRFPowerStateInProgress = false;
+
+	return bResult;
+}
+
+/****************************************************************************************
+ *function:  This function set command table variable(struct SwChnlCmd).
+ *   input:  SwChnlCmd*		CmdTable 	//table to be set.
+ *   	     u32		CmdTableIdx 	//variable index in table to be set
+ *   	     u32		CmdTableSz	//table size.
+ *   	     SwChnlCmdID	CmdID		//command ID to set.
+ *	     u32		Para1
+ *	     u32		Para2
+ *	     u32		msDelay
+ *  output:
+ *  return:  true if finished, false otherwise
+ *    Note:
+ * ************************************************************************************/
+u8 rtl8192_phy_SetSwChnlCmdArray(
+	SwChnlCmd*		CmdTable,
+	u32			CmdTableIdx,
+	u32			CmdTableSz,
+	SwChnlCmdID		CmdID,
+	u32			Para1,
+	u32			Para2,
+	u32			msDelay
+	)
+{
+	SwChnlCmd* pCmd;
+
+	if(CmdTable == NULL)
+	{
+		RT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): CmdTable cannot be NULL.\n");
+		return false;
+	}
+	if(CmdTableIdx >= CmdTableSz)
+	{
+		RT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): Access invalid index, please check size of the table, CmdTableIdx:%d, CmdTableSz:%d\n",
+				CmdTableIdx, CmdTableSz);
+		return false;
+	}
+
+	pCmd = CmdTable + CmdTableIdx;
+	pCmd->CmdID = CmdID;
+	pCmd->Para1 = Para1;
+	pCmd->Para2 = Para2;
+	pCmd->msDelay = msDelay;
+
+	return true;
+}
+/******************************************************************************
+ *function:  This function set channel step by step
+ *   input:  struct net_device *dev
+ *   	     u8 		channel
+ *   	     u8* 		stage //3 stages
+ *   	     u8* 		step  //
+ *   	     u32* 		delay //whether need to delay
+ *  output:  store new stage, step and delay for next step(combine with function above)
+ *  return:  true if finished, false otherwise
+ *    Note:  Wait for simpler function to replace it //wb
+ * ***************************************************************************/
+u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8* stage, u8* step, u32* delay)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+//	PCHANNEL_ACCESS_SETTING	pChnlAccessSetting;
+	SwChnlCmd				PreCommonCmd[MAX_PRECMD_CNT];
+	u32					PreCommonCmdCnt;
+	SwChnlCmd				PostCommonCmd[MAX_POSTCMD_CNT];
+	u32					PostCommonCmdCnt;
+	SwChnlCmd				RfDependCmd[MAX_RFDEPENDCMD_CNT];
+	u32					RfDependCmdCnt;
+	SwChnlCmd				*CurrentCmd = NULL;
+	//RF90_RADIO_PATH_E		eRFPath;
+	u8		eRFPath;
+//	u32		RfRetVal;
+//	u8		RetryCnt;
+
+	RT_TRACE(COMP_CH, "====>%s()====stage:%d, step:%d, channel:%d\n", __FUNCTION__, *stage, *step, channel);
+//	RT_ASSERT(IsLegalChannel(Adapter, channel), ("illegal channel: %d\n", channel));
+#ifdef ENABLE_DOT11D
+	if (!IsLegalChannel(priv->ieee80211, channel))
+	{
+		RT_TRACE(COMP_ERR, "=============>set to illegal channel:%d\n", channel);
+		return true; //return true to tell upper caller function this channel setting is finished! Or it will in while loop.
+	}
+#endif
+//FIXME:need to check whether channel is legal or not here.WB
+
+
+	//for(eRFPath = RF90_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+//	for(eRFPath = 0; eRFPath <RF90_PATH_MAX; eRFPath++)
+//	{
+//		if (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))
+//			continue;
+		// <1> Fill up pre common command.
+		PreCommonCmdCnt = 0;
+		rtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT,
+					CmdID_SetTxPowerLevel, 0, 0, 0);
+		rtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT,
+					CmdID_End, 0, 0, 0);
+
+		// <2> Fill up post common command.
+		PostCommonCmdCnt = 0;
+
+		rtl8192_phy_SetSwChnlCmdArray(PostCommonCmd, PostCommonCmdCnt++, MAX_POSTCMD_CNT,
+					CmdID_End, 0, 0, 0);
+
+		// <3> Fill up RF dependent command.
+		RfDependCmdCnt = 0;
+		switch( priv->rf_chip )
+		{
+		case RF_8225:
+			if (!(channel >= 1 && channel <= 14))
+			{
+				RT_TRACE(COMP_ERR, "illegal channel for Zebra 8225: %d\n", channel);
+				return true;
+			}
+			rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
+				CmdID_RF_WriteReg, rZebra1_Channel, RF_CHANNEL_TABLE_ZEBRA[channel], 10);
+			rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
+				CmdID_End, 0, 0, 0);
+			break;
+
+		case RF_8256:
+			// TEST!! This is not the table for 8256!!
+			if (!(channel >= 1 && channel <= 14))
+			{
+				RT_TRACE(COMP_ERR, "illegal channel for Zebra 8256: %d\n", channel);
+				return true;
+			}
+			rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
+				CmdID_RF_WriteReg, rZebra1_Channel, channel, 10);
+			rtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
+			CmdID_End, 0, 0, 0);
+			break;
+
+		case RF_8258:
+			break;
+
+		default:
+			RT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);
+			return true;
+			break;
+		}
+
+
+		do{
+			switch(*stage)
+			{
+			case 0:
+				CurrentCmd=&PreCommonCmd[*step];
+				break;
+			case 1:
+				CurrentCmd=&RfDependCmd[*step];
+				break;
+			case 2:
+				CurrentCmd=&PostCommonCmd[*step];
+				break;
+			}
+
+			if(CurrentCmd->CmdID==CmdID_End)
+			{
+				if((*stage)==2)
+				{
+					(*delay)=CurrentCmd->msDelay;
+					return true;
+				}
+				else
+				{
+					(*stage)++;
+					(*step)=0;
+					continue;
+				}
+			}
+
+			switch(CurrentCmd->CmdID)
+			{
+			case CmdID_SetTxPowerLevel:
+				if(priv->card_8192_version == (u8)VERSION_819xU_A) //xiong: consider it later!
+					rtl8192_SetTxPowerLevel(dev,channel);
+				break;
+			case CmdID_WritePortUlong:
+				write_nic_dword(dev, CurrentCmd->Para1, CurrentCmd->Para2);
+				break;
+			case CmdID_WritePortUshort:
+				write_nic_word(dev, CurrentCmd->Para1, (u16)CurrentCmd->Para2);
+				break;
+			case CmdID_WritePortUchar:
+				write_nic_byte(dev, CurrentCmd->Para1, (u8)CurrentCmd->Para2);
+				break;
+			case CmdID_RF_WriteReg:
+				for(eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++)
+				{
+				rtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, bZebra1_ChannelNum, CurrentCmd->Para2);
+				}
+				break;
+			default:
+				break;
+			}
+
+			break;
+		}while(true);
+//	}/*for(Number of RF paths)*/
+
+	(*delay)=CurrentCmd->msDelay;
+	(*step)++;
+	return false;
+}
+
+/******************************************************************************
+ *function:  This function does acturally set channel work
+ *   input:  struct net_device *dev
+ *   	     u8 		channel
+ *  output:  none
+ *  return:  noin
+ *    Note:  We should not call this function directly
+ * ***************************************************************************/
+void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u32	delay = 0;
+
+	while(!rtl8192_phy_SwChnlStepByStep(dev,channel,&priv->SwChnlStage,&priv->SwChnlStep,&delay))
+	{
+	//	if(delay>0)
+	//		msleep(delay);//or mdelay? need further consideration
+		if(!priv->up)
+			break;
+	}
+}
+/******************************************************************************
+ *function:  Callback routine of the work item for switch channel.
+ *   input:
+ *
+ *  output:  none
+ *  return:  noin
+ * ***************************************************************************/
+void rtl8192_SwChnl_WorkItem(struct net_device *dev)
+{
+
+	struct r8192_priv *priv = ieee80211_priv(dev);
+
+	RT_TRACE(COMP_CH, "==> SwChnlCallback819xUsbWorkItem(), chan:%d\n", priv->chan);
+
+
+	rtl8192_phy_FinishSwChnlNow(dev , priv->chan);
+
+	RT_TRACE(COMP_CH, "<== SwChnlCallback819xUsbWorkItem()\n");
+}
+
+/******************************************************************************
+ *function:  This function scheduled actural workitem to set channel
+ *   input:  net_device dev
+ *   	     u8		channel //channel to set
+ *  output:  none
+ *  return:  return code show if workitem is scheduled(1:pass, 0:fail)
+ *    Note:  Delay may be required for RF configuration
+ * ***************************************************************************/
+u8 rtl8192_phy_SwChnl(struct net_device* dev, u8 channel)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	RT_TRACE(COMP_CH, "=====>%s(), SwChnlInProgress:%d\n", __FUNCTION__, priv->SwChnlInProgress);
+	if(!priv->up)
+		return false;
+	if(priv->SwChnlInProgress)
+		return false;
+
+//	if(pHalData->SetBWModeInProgress)
+//		return;
+if (0) //to test current channel from RF reg 0x7.
+{
+	u8		eRFPath;
+	for(eRFPath = 0; eRFPath < 2; eRFPath++){
+	printk("====>set channel:%x\n",rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, 0x7, bZebra1_ChannelNum));
+	udelay(10);
+	}
+}
+	//--------------------------------------------
+	switch(priv->ieee80211->mode)
+	{
+	case WIRELESS_MODE_A:
+	case WIRELESS_MODE_N_5G:
+		if (channel<=14){
+			RT_TRACE(COMP_ERR, "WIRELESS_MODE_A but channel<=14");
+			return false;
+		}
+		break;
+	case WIRELESS_MODE_B:
+		if (channel>14){
+			RT_TRACE(COMP_ERR, "WIRELESS_MODE_B but channel>14");
+			return false;
+		}
+		break;
+	case WIRELESS_MODE_G:
+	case WIRELESS_MODE_N_24G:
+		if (channel>14){
+			RT_TRACE(COMP_ERR, "WIRELESS_MODE_G but channel>14");
+			return false;
+		}
+		break;
+	}
+	//--------------------------------------------
+
+	priv->SwChnlInProgress = true;
+	if(channel == 0)
+		channel = 1;
+
+	priv->chan=channel;
+
+	priv->SwChnlStage=0;
+	priv->SwChnlStep=0;
+//	schedule_work(&(priv->SwChnlWorkItem));
+//	rtl8192_SwChnl_WorkItem(dev);
+	if(priv->up) {
+//		queue_work(priv->priv_wq,&(priv->SwChnlWorkItem));
+	rtl8192_SwChnl_WorkItem(dev);
+	}
+
+	priv->SwChnlInProgress = false;
+	return true;
+}
+
+
+//
+/******************************************************************************
+ *function:  Callback routine of the work item for set bandwidth mode.
+ *   input:  struct net_device *dev
+ *   	     HT_CHANNEL_WIDTH	Bandwidth  //20M or 40M
+ *   	     HT_EXTCHNL_OFFSET Offset 	   //Upper, Lower, or Don't care
+ *  output:  none
+ *  return:  none
+ *    Note:  I doubt whether SetBWModeInProgress flag is necessary as we can
+ *    	     test whether current work in the queue or not.//do I?
+ * ***************************************************************************/
+void rtl8192_SetBWModeWorkItem(struct net_device *dev)
+{
+
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u8 regBwOpMode;
+
+	RT_TRACE(COMP_SWBW, "==>rtl8192_SetBWModeWorkItem()  Switch to %s bandwidth\n", \
+					priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz")
+
+
+	if(priv->rf_chip == RF_PSEUDO_11N)
+	{
+		priv->SetBWModeInProgress= false;
+		return;
+	}
+
+	//<1>Set MAC register
+	regBwOpMode = read_nic_byte(dev, BW_OPMODE);
+
+	switch(priv->CurrentChannelBW)
+	{
+		case HT_CHANNEL_WIDTH_20:
+			regBwOpMode |= BW_OPMODE_20MHZ;
+		       // 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+			write_nic_byte(dev, BW_OPMODE, regBwOpMode);
+			break;
+
+		case HT_CHANNEL_WIDTH_20_40:
+			regBwOpMode &= ~BW_OPMODE_20MHZ;
+        		// 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+			write_nic_byte(dev, BW_OPMODE, regBwOpMode);
+			break;
+
+		default:
+			RT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n",priv->CurrentChannelBW);
+			break;
+	}
+
+	//<2>Set PHY related register
+	switch(priv->CurrentChannelBW)
+	{
+		case HT_CHANNEL_WIDTH_20:
+			// Add by Vivi 20071119
+			rtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x0);
+			rtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x0);
+			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 1);
+
+			// Correct the tx power for CCK rate in 20M. Suggest by YN, 20071207
+#if 0
+			write_nic_dword(dev, rCCK0_TxFilter1, 0x1a1b0000);
+			write_nic_dword(dev, rCCK0_TxFilter2, 0x090e1317);
+			write_nic_dword(dev, rCCK0_DebugPort, 0x00000204);
+#endif
+			priv->cck_present_attentuation =
+				priv->cck_present_attentuation_20Mdefault + priv->cck_present_attentuation_difference;
+
+			if(priv->cck_present_attentuation > 22)
+				priv->cck_present_attentuation= 22;
+			if(priv->cck_present_attentuation< 0)
+				priv->cck_present_attentuation = 0;
+			RT_TRACE(COMP_INIT, "20M, pHalData->CCKPresentAttentuation = %d\n", priv->cck_present_attentuation);
+
+			if(priv->chan == 14 && !priv->bcck_in_ch14)
+			{
+				priv->bcck_in_ch14 = TRUE;
+				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+			}
+			else if(priv->chan != 14 && priv->bcck_in_ch14)
+			{
+				priv->bcck_in_ch14 = FALSE;
+				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+			}
+			else
+				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+
+			break;
+		case HT_CHANNEL_WIDTH_20_40:
+			// Add by Vivi 20071119
+			rtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x1);
+			rtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x1);
+			rtl8192_setBBreg(dev, rCCK0_System, bCCKSideBand, (priv->nCur40MhzPrimeSC>>1));
+                   	rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);
+			rtl8192_setBBreg(dev, rOFDM1_LSTF, 0xC00, priv->nCur40MhzPrimeSC);
+#if 0
+			// Correct the tx power for CCK rate in 40M. Suggest by YN, 20071207
+			write_nic_dword(dev, rCCK0_TxFilter1, 0x35360000);
+			write_nic_dword(dev, rCCK0_TxFilter2, 0x121c252e);
+			write_nic_dword(dev, rCCK0_DebugPort, 0x00000409);
+#endif
+			priv->cck_present_attentuation =
+				priv->cck_present_attentuation_40Mdefault + priv->cck_present_attentuation_difference;
+
+			if(priv->cck_present_attentuation > 22)
+				priv->cck_present_attentuation = 22;
+			if(priv->cck_present_attentuation < 0)
+				priv->cck_present_attentuation = 0;
+
+			RT_TRACE(COMP_INIT, "40M, pHalData->CCKPresentAttentuation = %d\n", priv->cck_present_attentuation);
+			if(priv->chan == 14 && !priv->bcck_in_ch14)
+			{
+				priv->bcck_in_ch14 = true;
+				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+			}
+			else if(priv->chan!= 14 && priv->bcck_in_ch14)
+			{
+				priv->bcck_in_ch14 = false;
+				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+			}
+			else
+				dm_cck_txpower_adjust(dev,priv->bcck_in_ch14);
+
+			break;
+		default:
+			RT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n" ,priv->CurrentChannelBW);
+			break;
+
+	}
+	//Skip over setting of J-mode in BB register here. Default value is "None J mode". Emily 20070315
+
+#if 1
+	//<3>Set RF related register
+	switch( priv->rf_chip )
+	{
+		case RF_8225:
+#ifdef TO_DO_LIST
+			PHY_SetRF8225Bandwidth(Adapter, pHalData->CurrentChannelBW);
+#endif
+			break;
+
+		case RF_8256:
+			PHY_SetRF8256Bandwidth(dev, priv->CurrentChannelBW);
+			break;
+
+		case RF_8258:
+			// PHY_SetRF8258Bandwidth();
+			break;
+
+		case RF_PSEUDO_11N:
+			// Do Nothing
+			break;
+
+		default:
+			RT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);
+			break;
+	}
+#endif
+	priv->SetBWModeInProgress= false;
+
+	RT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb(), %d", atomic_read(&(priv->ieee80211->atm_swbw)) );
+}
+
+/******************************************************************************
+ *function:  This function schedules bandwith switch work.
+ *   input:  struct net_device *dev
+ *   	     HT_CHANNEL_WIDTH	Bandwidth  //20M or 40M
+ *   	     HT_EXTCHNL_OFFSET Offset 	   //Upper, Lower, or Don't care
+ *  output:  none
+ *  return:  none
+ *    Note:  I doubt whether SetBWModeInProgress flag is necessary as we can
+ *    	     test whether current work in the queue or not.//do I?
+ * ***************************************************************************/
+void rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH	Bandwidth, HT_EXTCHNL_OFFSET Offset)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+
+	if(priv->SetBWModeInProgress)
+		return;
+	priv->SetBWModeInProgress= true;
+
+	priv->CurrentChannelBW = Bandwidth;
+
+	if(Offset==HT_EXTCHNL_OFFSET_LOWER)
+		priv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_UPPER;
+	else if(Offset==HT_EXTCHNL_OFFSET_UPPER)
+		priv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_LOWER;
+	else
+		priv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+	//queue_work(priv->priv_wq, &(priv->SetBWModeWorkItem));
+	//	schedule_work(&(priv->SetBWModeWorkItem));
+	rtl8192_SetBWModeWorkItem(dev);
+
+}
+
+void InitialGain819xUsb(struct net_device *dev,	u8 Operation)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+
+	priv->InitialGainOperateType = Operation;
+
+	if(priv->up)
+	{
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+		queue_delayed_work(priv->priv_wq,&priv->initialgain_operate_wq,0);
+	#else
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+		schedule_task(&priv->initialgain_operate_wq);
+		#else
+		queue_work(priv->priv_wq,&priv->initialgain_operate_wq);
+		#endif
+	#endif
+	}
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
+{
+	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
+       struct r8192_priv *priv = container_of(dwork,struct r8192_priv,initialgain_operate_wq);
+       struct net_device *dev = priv->ieee80211->dev;
+#else
+extern void InitialGainOperateWorkItemCallBack(struct net_device *dev)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+#endif
+#define SCAN_RX_INITIAL_GAIN	0x17
+#define POWER_DETECTION_TH	0x08
+	u32	BitMask;
+	u8	initial_gain;
+	u8	Operation;
+
+	Operation = priv->InitialGainOperateType;
+
+	switch(Operation)
+	{
+		case IG_Backup:
+			RT_TRACE(COMP_SCAN, "IG_Backup, backup the initial gain.\n");
+			initial_gain = SCAN_RX_INITIAL_GAIN;//priv->DefaultInitialGain[0];//
+			BitMask = bMaskByte0;
+			if(dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
+				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	// FW DIG OFF
+			priv->initgain_backup.xaagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XAAGCCore1, BitMask);
+			priv->initgain_backup.xbagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XBAGCCore1, BitMask);
+			priv->initgain_backup.xcagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XCAGCCore1, BitMask);
+			priv->initgain_backup.xdagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XDAGCCore1, BitMask);
+			BitMask  = bMaskByte2;
+			priv->initgain_backup.cca		= (u8)rtl8192_QueryBBReg(dev, rCCK0_CCA, BitMask);
+
+			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc50 is %x\n",priv->initgain_backup.xaagccore1);
+			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc58 is %x\n",priv->initgain_backup.xbagccore1);
+			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc60 is %x\n",priv->initgain_backup.xcagccore1);
+			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc68 is %x\n",priv->initgain_backup.xdagccore1);
+			RT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xa0a is %x\n",priv->initgain_backup.cca);
+
+			RT_TRACE(COMP_SCAN, "Write scan initial gain = 0x%x \n", initial_gain);
+			write_nic_byte(dev, rOFDM0_XAAGCCore1, initial_gain);
+			write_nic_byte(dev, rOFDM0_XBAGCCore1, initial_gain);
+			write_nic_byte(dev, rOFDM0_XCAGCCore1, initial_gain);
+			write_nic_byte(dev, rOFDM0_XDAGCCore1, initial_gain);
+			RT_TRACE(COMP_SCAN, "Write scan 0xa0a = 0x%x \n", POWER_DETECTION_TH);
+			write_nic_byte(dev, 0xa0a, POWER_DETECTION_TH);
+			break;
+		case IG_Restore:
+			RT_TRACE(COMP_SCAN, "IG_Restore, restore the initial gain.\n");
+			BitMask = 0x7f; //Bit0~ Bit6
+			if(dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
+				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	// FW DIG OFF
+
+			rtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, BitMask, (u32)priv->initgain_backup.xaagccore1);
+			rtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, BitMask, (u32)priv->initgain_backup.xbagccore1);
+			rtl8192_setBBreg(dev, rOFDM0_XCAGCCore1, BitMask, (u32)priv->initgain_backup.xcagccore1);
+			rtl8192_setBBreg(dev, rOFDM0_XDAGCCore1, BitMask, (u32)priv->initgain_backup.xdagccore1);
+			BitMask  = bMaskByte2;
+			rtl8192_setBBreg(dev, rCCK0_CCA, BitMask, (u32)priv->initgain_backup.cca);
+
+			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc50 is %x\n",priv->initgain_backup.xaagccore1);
+			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc58 is %x\n",priv->initgain_backup.xbagccore1);
+			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc60 is %x\n",priv->initgain_backup.xcagccore1);
+			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc68 is %x\n",priv->initgain_backup.xdagccore1);
+			RT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xa0a is %x\n",priv->initgain_backup.cca);
+
+#ifdef RTL8190P
+			SetTxPowerLevel8190(Adapter,priv->CurrentChannel);
+#endif
+#ifdef RTL8192E
+			SetTxPowerLevel8190(Adapter,priv->CurrentChannel);
+#endif
+//#ifdef RTL8192U
+			rtl8192_phy_setTxPower(dev,priv->ieee80211->current_network.channel);
+//#endif
+
+			if(dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)
+				rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);	// FW DIG ON
+			break;
+		default:
+			RT_TRACE(COMP_SCAN, "Unknown IG Operation. \n");
+			break;
+	}
+}
+
