commit e785e87b65434a243ee2197bb5038a67f8ea1426
Author: John Oldman <john.oldman@polehill.co.uk>
Date:   Sat May 23 18:28:12 2020 +0100

    staging: rtl8192e: Using comparison to true is error prone
    
    clear below issues reported by checkpatch.pl:
    
    CHECK: Using comparison to false is error prone
    
    Signed-off-by: John Oldman <john.oldman@polehill.co.uk>
    Link: https://lore.kernel.org/r/20200523172812.16473-1-john.oldman@polehill.co.uk
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index d83d72594312..8abc921ecb3e 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -371,7 +371,7 @@ void HTConstructInfoElement(struct rtllib_device *ieee, u8 *posHTInfo,
 	if ((ieee->iw_mode == IW_MODE_ADHOC) ||
 	    (ieee->iw_mode == IW_MODE_MASTER)) {
 		pHTInfoEle->ControlChl	= ieee->current_network.channel;
-		pHTInfoEle->ExtChlOffset = ((pHT->bRegBW40MHz == false) ?
+		pHTInfoEle->ExtChlOffset = ((!pHT->bRegBW40MHz) ?
 					    HT_EXTCHNL_OFFSET_NO_EXT :
 					    (ieee->current_network.channel <= 6)
 					    ? HT_EXTCHNL_OFFSET_UPPER :
@@ -526,7 +526,7 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 	static u8 EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};
 	static u8 EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};
 
-	if (pHTInfo->bCurrentHTSupport == false) {
+	if (!pHTInfo->bCurrentHTSupport) {
 		netdev_warn(ieee->dev, "%s(): HT_DISABLE\n", __func__);
 		return;
 	}
@@ -873,7 +873,7 @@ void HTSetConnectBwMode(struct rtllib_device *ieee,
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
-	if (pHTInfo->bRegBW40MHz == false)
+	if (!pHTInfo->bRegBW40MHz)
 		return;
 
 	if (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))

commit b99692f4db0b3d42266c5b95a6b7860c35b596bb
Author: Derek Robson <robsonde@gmail.com>
Date:   Sun Feb 2 20:02:43 2020 +1300

    staging: rtl8192e: style fix - Prefer using '"%s...", __func__'
    
    Fixed checkpatch warnings, Prefer using '"%s...", __func__'
    
    Signed-off-by: Derek Robson <robsonde@gmail.com>
    Link: https://lore.kernel.org/r/20200202070243.112059-1-robsonde@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index f02263af9624..d83d72594312 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -545,7 +545,7 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 
 
 #ifdef VERBOSE_DEBUG
-	print_hex_dump_bytes("HTOnAssocRsp(): ", DUMP_PREFIX_NONE,
+	print_hex_dump_bytes("%s: ", __func__, DUMP_PREFIX_NONE,
 			     pPeerHTCap, sizeof(struct ht_capab_ele));
 #endif
 	HTSetConnectBwMode(ieee, (enum ht_channel_width)(pPeerHTCap->ChlWidth),

commit 18056f34c3b755f027a0923b0bb9d50a2e339caa
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 2 12:31:58 2019 +0200

    staging: rtl8192e: add proper SPDX identifiers on files that did not have them.
    
    There were a few files for the rtl8192e driver that did not have SPDX
    identifiers on them, so fix that up.  At the same time, remove the "free
    form" text that specified the license of the file, as that is impossible
    for any tool to properly parse.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index f0e11726a72a..f02263af9624 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -1,17 +1,9 @@
-/******************************************************************************
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- ******************************************************************************/
+ * Contact Information: wlanfae <wlanfae@realtek.com>
+ */
 #include "rtllib.h"
 #include "rtl819x_HT.h"
 u8 MCS_FILTER_ALL[16] = {

commit ad3cafd7b4c2543933fedf915663637b1797c531
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Sat May 13 17:41:19 2017 +0100

    staging: rtl8192e: HTSetConnectBwMode message replace with debug.
    
    The flag status of bCurBW40MHz is printed as info and is
    only useful as debug message.
    
    Replace with netdev_dbg in line with rest of driver.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 4ae1d382ac5c..f0e11726a72a 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -908,8 +908,8 @@ void HTSetConnectBwMode(struct rtllib_device *ieee,
 		pHTInfo->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;
 	}
 
-	pr_info("%s():pHTInfo->bCurBW40MHz:%x\n", __func__,
-	       pHTInfo->bCurBW40MHz);
+	netdev_dbg(ieee->dev, "%s():pHTInfo->bCurBW40MHz:%x\n", __func__,
+		   pHTInfo->bCurBW40MHz);
 
 	pHTInfo->bSwBwInProgress = true;
 

commit 24542a004bdadd0f8e724b7da1c068f557d390c6
Author: Gargi Sharma <gs051095@gmail.com>
Date:   Wed Feb 22 20:32:12 2017 +0530

    staging: rtl8192e: Remove useless parentheses
    
    Parentheses are not needed on the right side of assignment.
    
    Additionally added space around '+'and '*' to remove
    checkpatch issue, space required around '+' and '*'.
    
    Parentheses Removed using the coccinelle script:
    @@
    binary operator bop = {+,-,>>,<<};
    expression e, e1, e2;
    @@
    
    e =
    -(
            e1 bop e2
    -)
    
    Signed-off-by: Gargi Sharma <gs051095@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index cded0f43cd33..4ae1d382ac5c 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -489,7 +489,7 @@ u8 HTGetHighestMCSRate(struct rtllib_device *ieee, u8 *pMCSRateSet,
 				if ((bitMap%2) != 0) {
 					if (HTMcsToDataRate(ieee, (8*i+j)) >
 					    HTMcsToDataRate(ieee, mcsRate))
-						mcsRate = (8*i+j);
+						mcsRate = 8 * i + j;
 				}
 				bitMap >>= 1;
 			}

commit 839396f555601270389c60c36e974f2551b77ce1
Author: Yamanappagouda Patil <goudapatilk@gmail.com>
Date:   Tue Nov 15 13:54:53 2016 +0530

    staging: rtl8192e: Fixed coding style wornings on Block comments.
    
    Fixed checkpatch.pl warnings related to Block comments in
    staging/rtl8192e/*.c files.
    
    Signed-off-by: Yamanappagouda Patil <goudapatilk@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index dd9c0c868361..cded0f43cd33 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -11,7 +11,7 @@
  *
  * Contact Information:
  * wlanfae <wlanfae@realtek.com>
-******************************************************************************/
+ ******************************************************************************/
 #include "rtllib.h"
 #include "rtl819x_HT.h"
 u8 MCS_FILTER_ALL[16] = {

commit ae6d07a5d11a6ee2153521077c4760e22bef886f
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun Sep 20 21:04:28 2015 +0200

    staging: rtl8192e: Fix FSF_MAILING_ADDRESS warnings
    
    Remove FSF address from licenses at the beginning of files.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 555745b2a75e..dd9c0c868361 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -6,10 +6,6 @@
  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  * more details.
  *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
  * The full GNU General Public License is included in this distribution in the
  * file called LICENSE.
  *

commit e0c84c1c1f0b6335184ab6ea0cdecfbf4abe173a
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Jul 14 22:04:19 2015 +0200

    staging: rtl8192e: rtllib_HTProc: Make functions static
    
    Make as many functions as possible static in rtllib_HTProc.c.
    
    The following functions were affected:
    - HTMcsToDataRate
    - HTFilterMCSRate
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index b5c3647b0f80..555745b2a75e 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -117,7 +117,7 @@ void HTUpdateDefaultSetting(struct rtllib_device *ieee)
 	pHTInfo->RxReorderPendingTime = 30;
 }
 
-u16 HTMcsToDataRate(struct rtllib_device *ieee, u8 nMcsRate)
+static u16 HTMcsToDataRate(struct rtllib_device *ieee, u8 nMcsRate)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
@@ -502,7 +502,8 @@ u8 HTGetHighestMCSRate(struct rtllib_device *ieee, u8 *pMCSRateSet,
 	return mcsRate | 0x80;
 }
 
-u8 HTFilterMCSRate(struct rtllib_device *ieee, u8 *pSupportMCS, u8 *pOperateMCS)
+static u8 HTFilterMCSRate(struct rtllib_device *ieee, u8 *pSupportMCS,
+			  u8 *pOperateMCS)
 {
 
 	u8 i;

commit bcf5b92d9bbf0b7683199615f0f184e89fa486bc
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Mon Jun 15 21:05:58 2015 +0200

    staging: rtl8192e: Remove rt_hi_throughput::ChnkOp
    
    Field was initialized and never used.
    This patch also removes chnl_op enum that was only
    referenced by ChnkOp init code.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index dcf8db1a7d29..b5c3647b0f80 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -676,7 +676,6 @@ void HTInitializeHTInfo(struct rtllib_device *ieee)
 		sizeof(pHTInfo->PeerHTInfoBuf));
 
 	pHTInfo->bSwBwInProgress = false;
-	pHTInfo->ChnlOp = CHNLOP_NONE;
 
 	pHTInfo->ePeerHTSpecVer = HT_SPEC_VER_IEEE;
 

commit 35e33b0468ab3b3f5b610bfa4fc9367a3b7c09a8
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:40 2015 +0200

    staging: rtl8192e: Fix LONG_LINE warnings
    
    Fix most of simple LONG_LINE warnings. None of the changes should affect
    behaviour of code, so several modifications are included in this patch:
    - Code is reindented where needed
    - Local variable names are compacted (priv -> p)
    - Unnecessary casts are removed
    - Nested ifs are replaced with logical and
    - a = b = c = d expressions are split
    - Replace if/then series with clamp_t()
    - Removed unneeded scopes
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 3edd5d1a05fb..dcf8db1a7d29 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -236,7 +236,8 @@ static bool HTIOTActIsDisableMCSTwoSpatialStream(struct rtllib_device *ieee)
 	return false;
 }
 
-static u8 HTIOTActIsDisableEDCATurbo(struct rtllib_device *ieee, u8 *PeerMacAddr)
+static u8 HTIOTActIsDisableEDCATurbo(struct rtllib_device *ieee,
+				     u8 *PeerMacAddr)
 {
 	return false;
 }

commit 7232141526e8c3702984bc5239e283b50c5f3d09
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:36 2015 +0200

    staging: rtl8192e: Remove RTLLIB_DEBUG_DATA()
    
    Use print_hex_dump_bytes() if VERBOSE_DEBUG is enabled.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 584f7a9af89a..3edd5d1a05fb 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -553,8 +553,11 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 	else
 		pPeerHTInfo = (struct ht_info_ele *)(pHTInfo->PeerHTInfoBuf);
 
-	RTLLIB_DEBUG_DATA(RTLLIB_DL_DATA | RTLLIB_DL_HT, pPeerHTCap,
-			  sizeof(struct ht_capab_ele));
+
+#ifdef VERBOSE_DEBUG
+	print_hex_dump_bytes("HTOnAssocRsp(): ", DUMP_PREFIX_NONE,
+			     pPeerHTCap, sizeof(struct ht_capab_ele));
+#endif
 	HTSetConnectBwMode(ieee, (enum ht_channel_width)(pPeerHTCap->ChlWidth),
 			  (enum ht_extchnl_offset)(pPeerHTInfo->ExtChlOffset));
 	pHTInfo->bCurTxBW40MHz = ((pPeerHTInfo->RecommemdedTxWidth == 1) ?

commit b94436b5d527d06403120be23570343a02b2283b
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:35 2015 +0200

    staging: rtl8192e: Remove RTLLIB_DEBUG()
    
    - Use netdev_dbg or netdev_vdbg instead of RTLLIB_DEBUG()
    - Reformat some messages for better readability
    - Remove RTLLIB_DEBUG messages that make no sense
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 2c365d334573..584f7a9af89a 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -217,8 +217,7 @@ static void HTIOTPeerDetermine(struct rtllib_device *ieee)
 	else
 		pHTInfo->IOTPeer = HT_IOT_PEER_UNKNOWN;
 
-	RTLLIB_DEBUG(RTLLIB_DL_IOT, "Joseph debug!! IOTPEER: %x\n",
-		     pHTInfo->IOTPeer);
+	netdev_dbg(ieee->dev, "IOTPEER: %x\n", pHTInfo->IOTPeer);
 }
 
 static u8 HTIOTActIsDisableMCS14(struct rtllib_device *ieee, u8 *PeerMacAddr)
@@ -328,9 +327,9 @@ void HTConstructCapabilityElement(struct rtllib_device *ieee, u8 *posHTCap,
 	pCapELE->LSigTxopProtect = 0;
 
 
-	RTLLIB_DEBUG(RTLLIB_DL_HT,
-		     "TX HT cap/info ele BW=%d MaxAMSDUSize:%d DssCCk:%d\n",
-		     pCapELE->ChlWidth, pCapELE->MaxAMSDUSize, pCapELE->DssCCk);
+	netdev_dbg(ieee->dev,
+		   "TX HT cap/info ele BW=%d MaxAMSDUSize:%d DssCCk:%d\n",
+		   pCapELE->ChlWidth, pCapELE->MaxAMSDUSize, pCapELE->DssCCk);
 
 	if (IsEncrypt) {
 		pCapELE->MPDUDensity	= 7;
@@ -541,7 +540,7 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 		netdev_warn(ieee->dev, "%s(): HT_DISABLE\n", __func__);
 		return;
 	}
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "===> HTOnAssocRsp_wq(): HT_ENABLE\n");
+	netdev_dbg(ieee->dev, "%s(): HT_ENABLE\n", __func__);
 
 	if (!memcmp(pHTInfo->PeerHTCapBuf, EWC11NHTCap, sizeof(EWC11NHTCap)))
 		pPeerHTCap = (struct ht_capab_ele *)(&pHTInfo->PeerHTCapBuf[4]);
@@ -646,7 +645,7 @@ void HTInitializeHTInfo(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "===========>%s()\n", __func__);
+	netdev_vdbg(ieee->dev, "%s()\n", __func__);
 	pHTInfo->bCurrentHTSupport = false;
 
 	pHTInfo->bCurBW40MHz = false;
@@ -716,7 +715,7 @@ void HTResetSelfAndSavePeerSetting(struct rtllib_device *ieee,
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	u8	bIOTAction = 0;
 
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "==============>%s()\n", __func__);
+	netdev_vdbg(ieee->dev, "%s()\n", __func__);
 	/* unmark bEnableHT flag here is the same reason why unmarked in
 	 * function rtllib_softmac_new_net. WB 2008.09.10
 	 */
@@ -840,8 +839,7 @@ u8 HTCCheck(struct rtllib_device *ieee, u8 *pFrame)
 {
 	if (ieee->pHTInfo->bCurrentHTSupport) {
 		if ((IsQoSDataFrame(pFrame) && Frame_Order(pFrame)) == 1) {
-			RTLLIB_DEBUG(RTLLIB_DL_HT,
-				     "HT CONTROL FILED EXIST!!\n");
+			netdev_dbg(ieee->dev, "HT CONTROL FILED EXIST!!\n");
 			return true;
 		}
 	}
@@ -852,7 +850,8 @@ static void HTSetConnectBwModeCallback(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "======>%s()\n", __func__);
+	netdev_vdbg(ieee->dev, "%s()\n", __func__);
+
 	if (pHTInfo->bCurBW40MHz) {
 		if (pHTInfo->CurSTAExtChnlOffset == HT_EXTCHNL_OFFSET_UPPER)
 			ieee->set_chan(ieee->dev,

commit 11e672c3e2d2a10189a6292678f5174597927076
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Sun May 31 20:19:26 2015 +0200

    staging: rtl8192e: Replace RTLLIB_DEBUG(DL_ERR) with netdev_*()
    
    Replace all RTLLIB_DEBUG(RTLLIB_DL_ERR, *) calls with netdev_err()
    for errors that really should be reported to user.
    Use netdev_warn() for the rest.
    Rephrase some of the messages to make them more readable/compact.
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 7f103114d5d2..2c365d334573 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -291,8 +291,8 @@ void HTConstructCapabilityElement(struct rtllib_device *ieee, u8 *posHTCap,
 	struct ht_capab_ele *pCapELE = NULL;
 
 	if ((posHTCap == NULL) || (pHT == NULL)) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR,
-			     "posHTCap or pHTInfo can't be null in HTConstructCapabilityElement()\n");
+		netdev_warn(ieee->dev,
+			    "%s(): posHTCap and pHTInfo are null\n", __func__);
 		return;
 	}
 	memset(posHTCap, 0, *len);
@@ -373,8 +373,9 @@ void HTConstructInfoElement(struct rtllib_device *ieee, u8 *posHTInfo,
 	struct ht_info_ele *pHTInfoEle = (struct ht_info_ele *)posHTInfo;
 
 	if ((posHTInfo == NULL) || (pHTInfoEle == NULL)) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR,
-			     "posHTInfo or pHTInfoEle can't be null in HTConstructInfoElement()\n");
+		netdev_warn(ieee->dev,
+			    "%s(): posHTInfo and pHTInfoEle are null\n",
+			    __func__);
 		return;
 	}
 
@@ -413,8 +414,7 @@ void HTConstructRT2RTAggElement(struct rtllib_device *ieee, u8 *posRT2RTAgg,
 				u8 *len)
 {
 	if (posRT2RTAgg == NULL) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR,
-			     "posRT2RTAgg can't be null in HTConstructRT2RTAggElement()\n");
+		netdev_warn(ieee->dev, "%s(): posRT2RTAgg is null\n", __func__);
 		return;
 	}
 	memset(posRT2RTAgg, 0, *len);
@@ -437,8 +437,7 @@ static u8 HT_PickMCSRate(struct rtllib_device *ieee, u8 *pOperateMCS)
 	u8 i;
 
 	if (pOperateMCS == NULL) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR,
-			     "pOperateMCS can't be null in HT_PickMCSRate()\n");
+		netdev_warn(ieee->dev, "%s(): pOperateMCS is null\n", __func__);
 		return false;
 	}
 
@@ -472,8 +471,9 @@ u8 HTGetHighestMCSRate(struct rtllib_device *ieee, u8 *pMCSRateSet,
 	u8		availableMcsRate[16];
 
 	if (pMCSRateSet == NULL || pMCSFilter == NULL) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR,
-			     "pMCSRateSet or pMCSFilter can't be null in HTGetHighestMCSRate()\n");
+		netdev_warn(ieee->dev,
+			    "%s(): pMCSRateSet and pMCSFilter are null\n",
+			    __func__);
 		return false;
 	}
 	for (i = 0; i < 16; i++)
@@ -538,8 +538,7 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 	static u8 EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};
 
 	if (pHTInfo->bCurrentHTSupport == false) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR,
-			     "<=== HTOnAssocRsp(): HT_DISABLE\n");
+		netdev_warn(ieee->dev, "%s(): HT_DISABLE\n", __func__);
 		return;
 	}
 	RTLLIB_DEBUG(RTLLIB_DL_HT, "===> HTOnAssocRsp_wq(): HT_ENABLE\n");

commit 14b40d92881533dca8b25647f105b9546433cda2
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:37 2015 +0200

    staging: rtl8192e: Comment cleanup (style/format)
    
    - Multiline comments use "network subsystem comment style"
    - Merge short multiline comments
    - Remove empty comments
    - Remove function name comment at the end of small (<1 screen) functions
    - Reformat 802.11 data frame format to use spaces and network format
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 573325cbd2e1..7f103114d5d2 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -719,7 +719,8 @@ void HTResetSelfAndSavePeerSetting(struct rtllib_device *ieee,
 
 	RTLLIB_DEBUG(RTLLIB_DL_HT, "==============>%s()\n", __func__);
 	/* unmark bEnableHT flag here is the same reason why unmarked in
-	 * function rtllib_softmac_new_net. WB 2008.09.10*/
+	 * function rtllib_softmac_new_net. WB 2008.09.10
+	 */
 	if (pNetwork->bssht.bdSupportHT) {
 		pHTInfo->bCurrentHTSupport = true;
 		pHTInfo->ePeerHTSpecVer = pNetwork->bssht.bdHTSpecVer;

commit 285b7c00e06b4fdd6e9ac63b9b8082508340f1ab
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Wed Apr 1 00:24:26 2015 +0200

    staging: rtl8192e: Fix UNNECESSARY_ELSE warning
    
    Fix checkpatch warnings 'else is not generally useful after a break or return'
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 9820dd2df5f3..573325cbd2e1 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -135,25 +135,22 @@ u16  TxCountToDataRate(struct rtllib_device *ieee, u8 nDataRate)
 	u8	is40MHz = 0;
 	u8	isShortGI = 0;
 
-	if (nDataRate < 12) {
+	if (nDataRate < 12)
 		return CCKOFDMRate[nDataRate];
-	} else {
-		if (nDataRate >= 0x10 && nDataRate <= 0x1f) {
-			is40MHz = 0;
-			isShortGI = 0;
-		} else if (nDataRate >= 0x20  && nDataRate <= 0x2f) {
-			is40MHz = 1;
-			isShortGI = 0;
-
-		} else if (nDataRate >= 0x30  && nDataRate <= 0x3f) {
-			is40MHz = 0;
-			isShortGI = 1;
-		} else if (nDataRate >= 0x40  && nDataRate <= 0x4f) {
-			is40MHz = 1;
-			isShortGI = 1;
-		}
-		return MCS_DATA_RATE[is40MHz][isShortGI][nDataRate&0xf];
+	if (nDataRate >= 0x10 && nDataRate <= 0x1f) {
+		is40MHz = 0;
+		isShortGI = 0;
+	} else if (nDataRate >= 0x20  && nDataRate <= 0x2f) {
+		is40MHz = 1;
+		isShortGI = 0;
+	} else if (nDataRate >= 0x30  && nDataRate <= 0x3f) {
+		is40MHz = 0;
+		isShortGI = 1;
+	} else if (nDataRate >= 0x40  && nDataRate <= 0x4f) {
+		is40MHz = 1;
+		isShortGI = 1;
 	}
+	return MCS_DATA_RATE[is40MHz][isShortGI][nDataRate&0xf];
 }
 
 bool IsHTHalfNmodeAPs(struct rtllib_device *ieee)

commit 0822339b52f6ea3f20b602362864f2a7ab9d3f7f
Author: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
Date:   Tue Mar 17 00:00:48 2015 +0100

    staging: rtl8192e: fix coding style issues (merge broken strings)
    
    Fix checkpatch.pl warnings:
    - 'WARNING: quoted string split across lines'
    - 'WARNING: break quoted strings at a space character'
    
    Signed-off-by: Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 1af4191feb4f..9820dd2df5f3 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -294,8 +294,8 @@ void HTConstructCapabilityElement(struct rtllib_device *ieee, u8 *posHTCap,
 	struct ht_capab_ele *pCapELE = NULL;
 
 	if ((posHTCap == NULL) || (pHT == NULL)) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posHTCap or pHTInfo can't be "
-			     "null in HTConstructCapabilityElement()\n");
+		RTLLIB_DEBUG(RTLLIB_DL_ERR,
+			     "posHTCap or pHTInfo can't be null in HTConstructCapabilityElement()\n");
 		return;
 	}
 	memset(posHTCap, 0, *len);
@@ -331,9 +331,9 @@ void HTConstructCapabilityElement(struct rtllib_device *ieee, u8 *posHTCap,
 	pCapELE->LSigTxopProtect = 0;
 
 
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "TX HT cap/info ele BW=%d MaxAMSDUSize:%d "
-		     "DssCCk:%d\n", pCapELE->ChlWidth, pCapELE->MaxAMSDUSize,
-		     pCapELE->DssCCk);
+	RTLLIB_DEBUG(RTLLIB_DL_HT,
+		     "TX HT cap/info ele BW=%d MaxAMSDUSize:%d DssCCk:%d\n",
+		     pCapELE->ChlWidth, pCapELE->MaxAMSDUSize, pCapELE->DssCCk);
 
 	if (IsEncrypt) {
 		pCapELE->MPDUDensity	= 7;
@@ -376,8 +376,8 @@ void HTConstructInfoElement(struct rtllib_device *ieee, u8 *posHTInfo,
 	struct ht_info_ele *pHTInfoEle = (struct ht_info_ele *)posHTInfo;
 
 	if ((posHTInfo == NULL) || (pHTInfoEle == NULL)) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posHTInfo or pHTInfoEle can't be "
-			     "null in HTConstructInfoElement()\n");
+		RTLLIB_DEBUG(RTLLIB_DL_ERR,
+			     "posHTInfo or pHTInfoEle can't be null in HTConstructInfoElement()\n");
 		return;
 	}
 
@@ -416,8 +416,8 @@ void HTConstructRT2RTAggElement(struct rtllib_device *ieee, u8 *posRT2RTAgg,
 				u8 *len)
 {
 	if (posRT2RTAgg == NULL) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posRT2RTAgg can't be null in "
-			     "HTConstructRT2RTAggElement()\n");
+		RTLLIB_DEBUG(RTLLIB_DL_ERR,
+			     "posRT2RTAgg can't be null in HTConstructRT2RTAggElement()\n");
 		return;
 	}
 	memset(posRT2RTAgg, 0, *len);
@@ -440,8 +440,8 @@ static u8 HT_PickMCSRate(struct rtllib_device *ieee, u8 *pOperateMCS)
 	u8 i;
 
 	if (pOperateMCS == NULL) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "pOperateMCS can't be null"
-			     " in HT_PickMCSRate()\n");
+		RTLLIB_DEBUG(RTLLIB_DL_ERR,
+			     "pOperateMCS can't be null in HT_PickMCSRate()\n");
 		return false;
 	}
 
@@ -475,8 +475,8 @@ u8 HTGetHighestMCSRate(struct rtllib_device *ieee, u8 *pMCSRateSet,
 	u8		availableMcsRate[16];
 
 	if (pMCSRateSet == NULL || pMCSFilter == NULL) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "pMCSRateSet or pMCSFilter can't "
-			     "be null in HTGetHighestMCSRate()\n");
+		RTLLIB_DEBUG(RTLLIB_DL_ERR,
+			     "pMCSRateSet or pMCSFilter can't be null in HTGetHighestMCSRate()\n");
 		return false;
 	}
 	for (i = 0; i < 16; i++)
@@ -541,8 +541,8 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 	static u8 EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};
 
 	if (pHTInfo->bCurrentHTSupport == false) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "<=== HTOnAssocRsp(): "
-			     "HT_DISABLE\n");
+		RTLLIB_DEBUG(RTLLIB_DL_ERR,
+			     "<=== HTOnAssocRsp(): HT_DISABLE\n");
 		return;
 	}
 	RTLLIB_DEBUG(RTLLIB_DL_HT, "===> HTOnAssocRsp_wq(): HT_ENABLE\n");
@@ -843,8 +843,8 @@ u8 HTCCheck(struct rtllib_device *ieee, u8 *pFrame)
 {
 	if (ieee->pHTInfo->bCurrentHTSupport) {
 		if ((IsQoSDataFrame(pFrame) && Frame_Order(pFrame)) == 1) {
-			RTLLIB_DEBUG(RTLLIB_DL_HT, "HT CONTROL FILED "
-				     "EXIST!!\n");
+			RTLLIB_DEBUG(RTLLIB_DL_HT,
+				     "HT CONTROL FILED EXIST!!\n");
 			return true;
 		}
 	}

commit e623d0f3f92960a826ae30dc861165f21752cdc8
Author: Cristina Opriceana <cristina.opriceana@gmail.com>
Date:   Thu Mar 12 04:22:38 2015 +0200

    Staging: rtl8192e: Remove unnecessary variables
    
    This patch removes unnecessary intermediary variables in return lines
    and uses actual values.
    Found by coccinelle using this semantic patch:
    
    @@ type T; expression expr; identifier r; @@
    
    -T r = expr;
    ... when != r
        when strict
    -return r;
    +return expr;
    
    Signed-off-by: Cristina Opriceana <cristina.opriceana@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 6157536e404a..1af4191feb4f 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -232,9 +232,7 @@ static u8 HTIOTActIsDisableMCS14(struct rtllib_device *ieee, u8 *PeerMacAddr)
 
 static bool HTIOTActIsDisableMCS15(struct rtllib_device *ieee)
 {
-	bool retValue = false;
-
-	return retValue;
+	return false;
 }
 
 static bool HTIOTActIsDisableMCSTwoSpatialStream(struct rtllib_device *ieee)

commit d40b62babcaea44a5f4fc3ab44f495c9dde8eee2
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Tue Mar 10 15:14:58 2015 +0530

    staging: rtl8192e: remove unused functions
    
    removed some functions which were not being used anywhere.
    build tested and also verified by git grep that there is no other
    reference to these functions.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 165975ad4ce5..6157536e404a 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -117,160 +117,6 @@ void HTUpdateDefaultSetting(struct rtllib_device *ieee)
 	pHTInfo->RxReorderPendingTime = 30;
 }
 
-void HTDebugHTCapability(u8 *CapIE, u8 *TitleString)
-{
-
-	static u8	EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};
-	struct ht_capab_ele *pCapELE;
-
-	if (!memcmp(CapIE, EWC11NHTCap, sizeof(EWC11NHTCap))) {
-		RTLLIB_DEBUG(RTLLIB_DL_HT, "EWC IE in %s()\n", __func__);
-		pCapELE = (struct ht_capab_ele *)(&CapIE[4]);
-	} else
-		pCapELE = (struct ht_capab_ele *)(&CapIE[0]);
-
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "<Log HT Capability>. Called by %s\n",
-		     TitleString);
-
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupported Channel Width = %s\n",
-		     (pCapELE->ChlWidth) ? "20MHz" : "20/40MHz");
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport Short GI for 20M = %s\n",
-		     (pCapELE->ShortGI20Mhz) ? "YES" : "NO");
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport Short GI for 40M = %s\n",
-		     (pCapELE->ShortGI40Mhz) ? "YES" : "NO");
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport TX STBC = %s\n",
-		     (pCapELE->TxSTBC) ? "YES" : "NO");
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMax AMSDU Size = %s\n",
-		     (pCapELE->MaxAMSDUSize) ? "3839" : "7935");
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport CCK in 20/40 mode = %s\n",
-		     (pCapELE->DssCCk) ? "YES" : "NO");
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMax AMPDU Factor = %d\n",
-		     pCapELE->MaxRxAMPDUFactor);
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMPDU Density = %d\n",
-		     pCapELE->MPDUDensity);
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMCS Rate Set = [%x][%x][%x][%x][%x]\n",
-		     pCapELE->MCS[0], pCapELE->MCS[1], pCapELE->MCS[2],
-		     pCapELE->MCS[3], pCapELE->MCS[4]);
-	return;
-
-}
-
-void HTDebugHTInfo(u8 *InfoIE, u8 *TitleString)
-{
-
-	static u8	EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};
-	struct ht_info_ele *pHTInfoEle;
-
-	if (!memcmp(InfoIE, EWC11NHTInfo, sizeof(EWC11NHTInfo))) {
-		RTLLIB_DEBUG(RTLLIB_DL_HT, "EWC IE in %s()\n", __func__);
-		pHTInfoEle = (struct ht_info_ele *)(&InfoIE[4]);
-	} else
-		pHTInfoEle = (struct ht_info_ele *)(&InfoIE[0]);
-
-
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "<Log HT Information Element>. "
-		     "Called by %s\n", TitleString);
-
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tPrimary channel = %d\n",
-		     pHTInfoEle->ControlChl);
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tSenondary channel =");
-	switch (pHTInfoEle->ExtChlOffset) {
-	case 0:
-		RTLLIB_DEBUG(RTLLIB_DL_HT, "Not Present\n");
-		break;
-	case 1:
-		RTLLIB_DEBUG(RTLLIB_DL_HT, "Upper channel\n");
-		break;
-	case 2:
-		RTLLIB_DEBUG(RTLLIB_DL_HT, "Reserved. Eooro!!!\n");
-		break;
-	case 3:
-		RTLLIB_DEBUG(RTLLIB_DL_HT, "Lower Channel\n");
-		break;
-	}
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tRecommended channel width = %s\n",
-		     (pHTInfoEle->RecommemdedTxWidth) ? "20Mhz" : "40Mhz");
-
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tOperation mode for protection = ");
-	switch (pHTInfoEle->OptMode) {
-	case 0:
-		RTLLIB_DEBUG(RTLLIB_DL_HT, "No Protection\n");
-		break;
-	case 1:
-		RTLLIB_DEBUG(RTLLIB_DL_HT, "HT non-member protection mode\n");
-		break;
-	case 2:
-		RTLLIB_DEBUG(RTLLIB_DL_HT, "Suggest to open protection\n");
-		break;
-	case 3:
-		RTLLIB_DEBUG(RTLLIB_DL_HT, "HT mixed mode\n");
-		break;
-	}
-
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tBasic MCS Rate Set = [%x][%x][%x][%x]"
-		     "[%x]\n", pHTInfoEle->BasicMSC[0], pHTInfoEle->BasicMSC[1],
-		     pHTInfoEle->BasicMSC[2], pHTInfoEle->BasicMSC[3],
-		     pHTInfoEle->BasicMSC[4]);
-}
-
-static bool IsHTHalfNmode40Bandwidth(struct rtllib_device *ieee)
-{
-	bool			retValue = false;
-	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
-
-	if (pHTInfo->bCurrentHTSupport == false)
-		retValue = false;
-	else if (pHTInfo->bRegBW40MHz == false)
-		retValue = false;
-	else if (!ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
-		retValue = false;
-	else if (((struct ht_capab_ele *)(pHTInfo->PeerHTCapBuf))->ChlWidth)
-		retValue = true;
-	else
-		retValue = false;
-
-	return retValue;
-}
-
-static bool IsHTHalfNmodeSGI(struct rtllib_device *ieee, bool is40MHz)
-{
-	bool			retValue = false;
-	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
-
-	if (pHTInfo->bCurrentHTSupport == false)
-		retValue = false;
-	else if (!ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
-		retValue = false;
-	else if (is40MHz) {
-		if (((struct ht_capab_ele *)
-		    (pHTInfo->PeerHTCapBuf))->ShortGI40Mhz)
-			retValue = true;
-		else
-			retValue = false;
-	} else {
-		if (((struct ht_capab_ele *)
-		   (pHTInfo->PeerHTCapBuf))->ShortGI20Mhz)
-			retValue = true;
-		else
-			retValue = false;
-	}
-
-	return retValue;
-}
-
-u16 HTHalfMcsToDataRate(struct rtllib_device *ieee, u8 nMcsRate)
-{
-
-	u8	is40MHz;
-	u8	isShortGI;
-
-	is40MHz  =  (IsHTHalfNmode40Bandwidth(ieee)) ? 1 : 0;
-	isShortGI = (IsHTHalfNmodeSGI(ieee, is40MHz)) ? 1 : 0;
-
-	return MCS_DATA_RATE[is40MHz][isShortGI][(nMcsRate & 0x7f)];
-}
-
-
 u16 HTMcsToDataRate(struct rtllib_device *ieee, u8 nMcsRate)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;

commit be31fed4f917e67a504ef837486cef798fba0fd7
Author: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
Date:   Thu Feb 26 11:40:50 2015 +0200

    staging: rtl8192e: rewrite the right hand side of an assignment
    
    This patch rewrites the right hand side of an assignment for
    expressions of the form:
    a = (a <op> b);
    to be:
    a <op>= b;
    where <op> = << | >>.
    
    This issue was detected and resolved using the following
    coccinelle script:
    
    @@
    identifier i;
    expression e;
    @@
    
    -i = (i >> e);
    +i >>= e;
    
    @@
    identifier i;
    expression e;
    @@
    
    -i = (i << e);
    +i <<= e;
    
    Signed-off-by: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 1ea426b7b7ac..165975ad4ce5 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -654,7 +654,7 @@ u8 HTGetHighestMCSRate(struct rtllib_device *ieee, u8 *pMCSRateSet,
 					    HTMcsToDataRate(ieee, mcsRate))
 						mcsRate = (8*i+j);
 				}
-				bitMap = bitMap>>1;
+				bitMap >>= 1;
 			}
 		}
 	}

commit 31f1c464bd6e09a75c53efb13fc28b514d7be345
Author: Gangadhar Vukkesala <gangs.freelancer@gmail.com>
Date:   Sun Dec 21 08:23:59 2014 +0530

    staging: rtl8192e: fixed a space coding style issue
    
    Fixed a space coding style issue in 3-dimensional array initialization
    which was found when running checkpatch.pl script on rtl819x_HTProc.c.
    
    Signed-off-by: Gangadhar Vukkesala <gangs.freelancer@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index c7f45080061f..1ea426b7b7ac 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -34,13 +34,13 @@ u16 MCS_DATA_RATE[2][2][77] = {
 	 468, 520, 0, 78, 104, 130, 117, 156, 195, 104, 130, 130, 156, 182,
 	 182, 208, 156, 195, 195, 234, 273, 273, 312, 130, 156, 181, 156,
 	 181, 208, 234, 208, 234, 260, 260, 286, 195, 234, 273, 234, 273,
-	 312, 351, 312, 351, 390, 390, 429} ,
+	 312, 351, 312, 351, 390, 390, 429},
 	{14, 29, 43, 58, 87, 116, 130, 144, 29, 58, 87, 116, 173, 231, 260, 289,
 	 43, 87, 130, 173, 260, 347, 390, 433, 58, 116, 173, 231, 347, 462, 520,
 	 578, 0, 87, 116, 144, 130, 173, 217, 116, 144, 144, 173, 202, 202, 231,
 	 173, 217, 217, 260, 303, 303, 347, 144, 173, 202, 173, 202, 231, 260,
 	 231, 260, 289, 289, 318, 217, 260, 303, 260, 303, 347, 390, 347, 390,
-	 433, 433, 477} } ,
+	 433, 433, 477} },
 	{{27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486,
 	 540, 81, 162, 243, 324, 486, 648, 729, 810, 108, 216, 324, 432, 648,
 	 864, 972, 1080, 12, 162, 216, 270, 243, 324, 405, 216, 270, 270, 324,

commit 4dc5afdeffd16f1c8352aaf81a35562c62865e84
Author: Melike Yurtoglu <aysemelikeyurtoglu@gmail.com>
Date:   Tue Sep 30 22:08:18 2014 +0300

    staging: rtl8192e: Fix void function return statements style
    
    Fixes "void function return statements are not generally
    useful"checkpatch.pl warning in rtl819x_HTProc.c
    
    Signed-off-by: Melike Yurtoglu <aysemelikeyurtoglu@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index f11c1a22fb8d..c7f45080061f 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -211,7 +211,6 @@ void HTDebugHTInfo(u8 *InfoIE, u8 *TitleString)
 		     "[%x]\n", pHTInfoEle->BasicMSC[0], pHTInfoEle->BasicMSC[1],
 		     pHTInfoEle->BasicMSC[2], pHTInfoEle->BasicMSC[3],
 		     pHTInfoEle->BasicMSC[4]);
-	return;
 }
 
 static bool IsHTHalfNmode40Bandwidth(struct rtllib_device *ieee)
@@ -524,7 +523,6 @@ void HTConstructCapabilityElement(struct rtllib_device *ieee, u8 *posHTCap,
 			pCapELE->MCS[1] = 0;
 		}
 	}
-	return;
 }
 
 void HTConstructInfoElement(struct rtllib_device *ieee, u8 *posHTInfo,
@@ -568,7 +566,6 @@ void HTConstructInfoElement(struct rtllib_device *ieee, u8 *posHTInfo,
 	} else {
 		*len = 0;
 	}
-	return;
 }
 
 void HTConstructRT2RTAggElement(struct rtllib_device *ieee, u8 *posRT2RTAgg,
@@ -592,8 +589,6 @@ void HTConstructRT2RTAggElement(struct rtllib_device *ieee, u8 *posRT2RTAgg,
 		*posRT2RTAgg |= RT_HT_CAP_USE_WOW;
 
 	*len = 6 + 2;
-
-	return;
 }
 
 static u8 HT_PickMCSRate(struct rtllib_device *ieee, u8 *pOperateMCS)
@@ -998,7 +993,6 @@ void HTUseDefaultSetting(struct rtllib_device *ieee)
 	} else {
 		pHTInfo->bCurrentHTSupport = false;
 	}
-	return;
 }
 
 u8 HTCCheck(struct rtllib_device *ieee, u8 *pFrame)

commit 4344672830d8500eac97d82976b03e41580c3a04
Author: Mahati Chamarthy <mahati.chamarthy@gmail.com>
Date:   Sat Sep 20 02:40:43 2014 +0530

    Staging: rtl8192e: Fix printk style warning
    
    This fixes the following checkpatch.pl warnings:
    WARNING: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
    
    Signed-off-by: Mahati Chamarthy <mahati.chamarthy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index a6d861acf81f..f11c1a22fb8d 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -1054,7 +1054,7 @@ void HTSetConnectBwMode(struct rtllib_device *ieee,
 		Bandwidth = HT_CHANNEL_WIDTH_20;
 
 	if (pHTInfo->bSwBwInProgress) {
-		printk(KERN_INFO "%s: bSwBwInProgress!!\n", __func__);
+		pr_info("%s: bSwBwInProgress!!\n", __func__);
 		return;
 	}
 	if (Bandwidth == HT_CHANNEL_WIDTH_20_40) {
@@ -1074,7 +1074,7 @@ void HTSetConnectBwMode(struct rtllib_device *ieee,
 		pHTInfo->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;
 	}
 
-	printk(KERN_INFO "%s():pHTInfo->bCurBW40MHz:%x\n", __func__,
+	pr_info("%s():pHTInfo->bCurBW40MHz:%x\n", __func__,
 	       pHTInfo->bCurBW40MHz);
 
 	pHTInfo->bSwBwInProgress = true;

commit 3a6b70c3f3558a2e47d2ca82752f0aed0f3c33c6
Author: Matthew Casey <mdcasey@chabloom.com>
Date:   Fri Aug 22 06:27:52 2014 -0400

    staging: rtl8192e: fixed coding style issues
    
    Fixed missing blank line after declarations issues
    
    Signed-off-by: Matthew Casey <mdcasey@chabloom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 8b7412980ebb..a6d861acf81f 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -340,6 +340,7 @@ static void HTIOTPeerDetermine(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	struct rtllib_network *net = &ieee->current_network;
+
 	if (net->bssht.bdRT2RTAggregation) {
 		pHTInfo->IOTPeer = HT_IOT_PEER_REALTEK;
 		if (net->bssht.RT2RT_HT_Mode & RT_HT_CAP_USE_92SE)
@@ -425,6 +426,7 @@ static u8 HTIOTActIsCCDFsync(struct rtllib_device *ieee)
 static void HTIOTActDetermineRaFunc(struct rtllib_device *ieee, bool bPeerRx2ss)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
+
 	pHTInfo->IOTRaFunc &= HT_IOT_RAFUNC_DISABLE_ALL;
 
 	if (pHTInfo->IOTPeer == HT_IOT_PEER_RALINK && !bPeerRx2ss)
@@ -457,6 +459,7 @@ void HTConstructCapabilityElement(struct rtllib_device *ieee, u8 *posHTCap,
 
 	if ((bAssoc) && (pHT->ePeerHTSpecVer == HT_SPEC_VER_EWC)) {
 		u8	EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};
+
 		memcpy(posHTCap, EWC11NHTCap, sizeof(EWC11NHTCap));
 		pCapELE = (struct ht_capab_ele *)&(posHTCap[4]);
 		*len = 30 + 2;
@@ -529,6 +532,7 @@ void HTConstructInfoElement(struct rtllib_device *ieee, u8 *posHTInfo,
 {
 	struct rt_hi_throughput *pHT = ieee->pHTInfo;
 	struct ht_info_ele *pHTInfoEle = (struct ht_info_ele *)posHTInfo;
+
 	if ((posHTInfo == NULL) || (pHTInfoEle == NULL)) {
 		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posHTInfo or pHTInfoEle can't be "
 			     "null in HTConstructInfoElement()\n");
@@ -595,6 +599,7 @@ void HTConstructRT2RTAggElement(struct rtllib_device *ieee, u8 *posRT2RTAgg,
 static u8 HT_PickMCSRate(struct rtllib_device *ieee, u8 *pOperateMCS)
 {
 	u8 i;
+
 	if (pOperateMCS == NULL) {
 		RTLLIB_DEBUG(RTLLIB_DL_ERR, "pOperateMCS can't be null"
 			     " in HT_PickMCSRate()\n");
@@ -629,6 +634,7 @@ u8 HTGetHighestMCSRate(struct rtllib_device *ieee, u8 *pMCSRateSet,
 	u8		bitMap;
 	u8		mcsRate = 0;
 	u8		availableMcsRate[16];
+
 	if (pMCSRateSet == NULL || pMCSFilter == NULL) {
 		RTLLIB_DEBUG(RTLLIB_DL_ERR, "pMCSRateSet or pMCSFilter can't "
 			     "be null in HTGetHighestMCSRate()\n");
@@ -846,6 +852,7 @@ void HTInitializeHTInfo(struct rtllib_device *ieee)
 
 	{
 		u8 *RegHTSuppRateSets = &(ieee->RegHTSuppRateSet[0]);
+
 		RegHTSuppRateSets[0] = 0xFF;
 		RegHTSuppRateSets[1] = 0xFF;
 		RegHTSuppRateSets[4] = 0x01;

commit 976d534118219b04277fb6cfcdb71607b730746d
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Wed Nov 30 15:18:52 2011 -0500

    rtl8192e: Rename clashing symbols
    
    The "rtl8192e: Export symbols" patch exported three functions already
    exported by the rtl8192u driver. This patch renames the three functions:
      Dot11d_Init => dot11d_init
      HTUpdateSelfAndPeerSetting => HT_update_self_and_peer_setting
      IsLegalChannel => rtllib_legal_channel
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 59ac4507091b..8b7412980ebb 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -943,8 +943,8 @@ void HTResetSelfAndSavePeerSetting(struct rtllib_device *ieee,
 	}
 }
 
-void HTUpdateSelfAndPeerSetting(struct rtllib_device *ieee,
-				struct rtllib_network *pNetwork)
+void HT_update_self_and_peer_setting(struct rtllib_device *ieee,
+				     struct rtllib_network *pNetwork)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	struct ht_info_ele *pPeerHTInfo =
@@ -955,7 +955,7 @@ void HTUpdateSelfAndPeerSetting(struct rtllib_device *ieee,
 			pHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;
 	}
 }
-EXPORT_SYMBOL(HTUpdateSelfAndPeerSetting);
+EXPORT_SYMBOL(HT_update_self_and_peer_setting);
 
 void HTUseDefaultSetting(struct rtllib_device *ieee)
 {

commit 3b28499c5519e59fbe9c2dea49ece5a3665be787
Author: Sean MacLennan <seanm@seanm.ca>
Date:   Mon Nov 28 20:20:26 2011 -0500

    rtl8192e: Export symbols
    
    The rtl8192e driver had a natural split between the more generic
    rtllib code and the more specific rtl8192e code. This patch exports
    all the symbols needed by the r8192 specific code from the rtllib
    generic code.
    
    Signed-off-by: Sean MacLennan <seanm@seanm.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index b1c0c566882f..59ac4507091b 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -955,6 +955,7 @@ void HTUpdateSelfAndPeerSetting(struct rtllib_device *ieee,
 			pHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;
 	}
 }
+EXPORT_SYMBOL(HTUpdateSelfAndPeerSetting);
 
 void HTUseDefaultSetting(struct rtllib_device *ieee)
 {

commit ec0dc6beea5436c037707dc0f501cf07878a8e2a
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 14:07:04 2011 -0500

    staging: rtl8192e: Fix sparse (non-endian) messages - Part I
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index f8da913c47be..b1c0c566882f 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -214,7 +214,7 @@ void HTDebugHTInfo(u8 *InfoIE, u8 *TitleString)
 	return;
 }
 
-bool IsHTHalfNmode40Bandwidth(struct rtllib_device *ieee)
+static bool IsHTHalfNmode40Bandwidth(struct rtllib_device *ieee)
 {
 	bool			retValue = false;
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
@@ -233,7 +233,7 @@ bool IsHTHalfNmode40Bandwidth(struct rtllib_device *ieee)
 	return retValue;
 }
 
-bool IsHTHalfNmodeSGI(struct rtllib_device *ieee, bool is40MHz)
+static bool IsHTHalfNmodeSGI(struct rtllib_device *ieee, bool is40MHz)
 {
 	bool			retValue = false;
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
@@ -336,7 +336,7 @@ bool IsHTHalfNmodeAPs(struct rtllib_device *ieee)
 	return retValue;
 }
 
-void HTIOTPeerDetermine(struct rtllib_device *ieee)
+static void HTIOTPeerDetermine(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	struct rtllib_network *net = &ieee->current_network;
@@ -378,40 +378,31 @@ void HTIOTPeerDetermine(struct rtllib_device *ieee)
 		     pHTInfo->IOTPeer);
 }
 
-u8 HTIOTActIsDisableMCS14(struct rtllib_device *ieee, u8 *PeerMacAddr)
+static u8 HTIOTActIsDisableMCS14(struct rtllib_device *ieee, u8 *PeerMacAddr)
 {
 	return 0;
 }
 
 
-bool HTIOTActIsDisableMCS15(struct rtllib_device *ieee)
+static bool HTIOTActIsDisableMCS15(struct rtllib_device *ieee)
 {
 	bool retValue = false;
 
 	return retValue;
 }
 
-bool HTIOTActIsDisableMCSTwoSpatialStream(struct rtllib_device *ieee)
+static bool HTIOTActIsDisableMCSTwoSpatialStream(struct rtllib_device *ieee)
 {
 	return false;
 }
 
-u8 HTIOTActIsDisableEDCATurbo(struct rtllib_device *ieee, u8 *PeerMacAddr)
+static u8 HTIOTActIsDisableEDCATurbo(struct rtllib_device *ieee, u8 *PeerMacAddr)
 {
 	return false;
 }
 
-
-bool HTIOTActIsEnableBETxOPLimit(struct rtllib_device *ieee)
-{
-	bool	retValue = false;
-
-	return retValue;
-}
-
-
-u8 HTIOTActIsMgntUseCCK6M(struct rtllib_device *ieee,
-			  struct rtllib_network *network)
+static u8 HTIOTActIsMgntUseCCK6M(struct rtllib_device *ieee,
+				 struct rtllib_network *network)
 {
 	u8	retValue = 0;
 
@@ -422,60 +413,7 @@ u8 HTIOTActIsMgntUseCCK6M(struct rtllib_device *ieee,
 	return retValue;
 }
 
-u8 HTIOTActWAIOTBroadcom(struct rtllib_device *ieee)
-{
-	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
-	u8		retValue = false;
-	u8		boundary = 59;
-
-	pHTInfo->bWAIotBroadcom = false;
-	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM) {
-		if (ieee->current_network.bssht.bdBandWidth ==
-		    HT_CHANNEL_WIDTH_20_40) {
-			if (!(pHTInfo->bRegBW40MHz)) {
-				if (ieee->current_network.mode !=
-				    WIRELESS_MODE_B) {
-					pHTInfo->bWAIotBroadcom = true;
-
-					if (ieee->b_customer_lenovo_id)
-						boundary = 30;
-
-					if (ieee->current_network.RSSI >=
-					    boundary)
-						retValue = true;
-				}
-			}
-		}
-	}
-	return retValue;
-}
-
-u8 HTIOTActIsForcedCTS2Self(struct rtllib_device *ieee,
-			    struct rtllib_network *network)
-{
-	u8	retValue = 0;
-	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_MARVELL)
-		retValue = 1;
-
-	return retValue;
-}
-
-u8 HTIOTActIsForcedRTSCTS(struct rtllib_device *ieee,
-			  struct rtllib_network *network)
-{
-	u8	retValue = 0;
-	return retValue;
-}
-
-u8 HTIOTActIsForcedAMSDU8K(struct rtllib_device *ieee,
-			   struct rtllib_network *network)
-{
-	u8 retValue = 0;
-
-	return retValue;
-}
-
-u8 HTIOTActIsCCDFsync(struct rtllib_device *ieee)
+static u8 HTIOTActIsCCDFsync(struct rtllib_device *ieee)
 {
 	u8	retValue = 0;
 
@@ -484,42 +422,7 @@ u8 HTIOTActIsCCDFsync(struct rtllib_device *ieee)
 	return retValue;
 }
 
-u8 HTIOCActRejcectADDBARequest(struct rtllib_network *network)
-{
-	u8	retValue = 0;
-
-	return retValue;
-}
-
-u8 HTIOTActIsEDCABiasRx(struct rtllib_device *ieee,
-			struct rtllib_network *network)
-{
-	u8	retValue = 0;
-
-	return retValue;
-}
-
-u8 HTIOTActDisableShortGI(struct rtllib_device *ieee,
-			  struct rtllib_network *network)
-{
-	u8	retValue = 0;
-	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
-
-	if (pHTInfo->IOTPeer == HT_IOT_PEER_RALINK)
-			retValue = 1;
-
-	return retValue;
-}
-
-u8 HTIOTActDisableHighPower(struct rtllib_device *ieee,
-			    struct rtllib_network *network)
-{
-	u8	retValue = 0;
-
-	return retValue;
-}
-
-void HTIOTActDetermineRaFunc(struct rtllib_device *ieee, bool bPeerRx2ss)
+static void HTIOTActDetermineRaFunc(struct rtllib_device *ieee, bool bPeerRx2ss)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	pHTInfo->IOTRaFunc &= HT_IOT_RAFUNC_DISABLE_ALL;
@@ -532,52 +435,6 @@ void HTIOTActDetermineRaFunc(struct rtllib_device *ieee, bool bPeerRx2ss)
 
 }
 
-
-u8 HTIOTActIsDisableTx40MHz(struct rtllib_device *ieee,
-			    struct rtllib_network *network)
-{
-	u8	retValue = 0;
-
-	return retValue;
-}
-
-u8 HTIOTActIsTxNoAggregation(struct rtllib_device *ieee,
-			     struct rtllib_network *network)
-{
-	u8 retValue = 0;
-
-	return retValue;
-}
-
-u8 HTIOTActIsDisableTx2SS(struct rtllib_device *ieee,
-			  struct rtllib_network *network)
-{
-	u8	retValue = 0;
-
-	return retValue;
-}
-
-bool HTIOCActIsDisableCckRate(struct rtllib_device *ieee,
-			      struct rtllib_network *network)
-{
-	bool	retValue = false;
-	return retValue;
-}
-
-bool HTIOCActAllowPeerAggOnePacket(struct rtllib_device *ieee,
-				   struct rtllib_network *network)
-{
-	bool	retValue = false;
-	return retValue;
-}
-
-bool HTIOTActIsNullDataPowerSaving(struct rtllib_device *ieee,
-				   struct rtllib_network *network)
-{
-	bool	retValue = false;
-	return retValue;
-}
-
 void HTResetIOTSetting(struct rt_hi_throughput *pHTInfo)
 {
 	pHTInfo->IOTAction = 0;
@@ -735,7 +592,7 @@ void HTConstructRT2RTAggElement(struct rtllib_device *ieee, u8 *posRT2RTAgg,
 	return;
 }
 
-u8 HT_PickMCSRate(struct rtllib_device *ieee, u8 *pOperateMCS)
+static u8 HT_PickMCSRate(struct rtllib_device *ieee, u8 *pOperateMCS)
 {
 	u8 i;
 	if (pOperateMCS == NULL) {
@@ -1148,7 +1005,7 @@ u8 HTCCheck(struct rtllib_device *ieee, u8 *pFrame)
 	return false;
 }
 
-void HTSetConnectBwModeCallback(struct rtllib_device *ieee)
+static void HTSetConnectBwModeCallback(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 

commit 831cb9db38ccf3f21804ef1fa0510d4ed27e27f1
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Thu Aug 25 11:48:17 2011 -0500

    staging: rtl8192e: Cleanup checkpatch -f warnings and errors - Part V
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 825b90805b4b..f8da913c47be 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -18,53 +18,75 @@
 ******************************************************************************/
 #include "rtllib.h"
 #include "rtl819x_HT.h"
-u8 MCS_FILTER_ALL[16] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-
-u8 MCS_FILTER_1SS[16] = {0xff, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-
-u16 MCS_DATA_RATE[2][2][77] =
-	{	{	{13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78 ,104, 156, 208, 234, 260,
-			39, 78, 117, 234, 312, 351, 390, 52, 104, 156, 208, 312, 416, 468, 520,
-			0, 78, 104, 130, 117, 156, 195, 104, 130, 130, 156, 182, 182, 208, 156, 195,
-			195, 234, 273, 273, 312, 130, 156, 181, 156, 181, 208, 234, 208, 234, 260, 260,
-			286, 195, 234, 273, 234, 273, 312, 351, 312, 351, 390, 390, 429},
-			{14, 29, 43, 58, 87, 116, 130, 144, 29, 58, 87, 116, 173, 231, 260, 289,
-			43, 87, 130, 173, 260, 347, 390, 433, 58, 116, 173, 231, 347, 462, 520, 578,
-			0, 87, 116, 144, 130, 173, 217, 116, 144, 144, 173, 202, 202, 231, 173, 217,
-			217, 260, 303, 303, 347, 144, 173, 202, 173, 202, 231, 260, 231, 260, 289, 289,
-			318, 217, 260, 303, 260, 303, 347, 390, 347, 390, 433, 433, 477}	},
-		{	{27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540,
-			81, 162, 243, 324, 486, 648, 729, 810, 108, 216, 324, 432, 648, 864, 972, 1080,
-			12, 162, 216, 270, 243, 324, 405, 216, 270, 270, 324, 378, 378, 432, 324, 405,
-			405, 486, 567, 567, 648, 270, 324, 378, 324, 378, 432, 486, 432, 486, 540, 540,
-			594, 405, 486, 567, 486, 567, 648, 729, 648, 729, 810, 810, 891},
-			{30, 60, 90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600,
-			90, 180, 270, 360, 540, 720, 810, 900, 120, 240, 360, 480, 720, 960, 1080, 1200,
-			13, 180, 240, 300, 270, 360, 450, 240, 300, 300, 360, 420, 420, 480, 360, 450,
-			450, 540, 630, 630, 720, 300, 360, 420, 360, 420, 480, 540, 480, 540, 600, 600,
-			660, 450, 540, 630, 540, 630, 720, 810, 720, 810, 900, 900, 990}	}
-	};
+u8 MCS_FILTER_ALL[16] = {
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+u8 MCS_FILTER_1SS[16] = {
+	0xff, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
+;
+
+u16 MCS_DATA_RATE[2][2][77] = {
+	{{13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78, 104, 156, 208, 234,
+	 260, 39, 78, 117, 234, 312, 351, 390, 52, 104, 156, 208, 312, 416,
+	 468, 520, 0, 78, 104, 130, 117, 156, 195, 104, 130, 130, 156, 182,
+	 182, 208, 156, 195, 195, 234, 273, 273, 312, 130, 156, 181, 156,
+	 181, 208, 234, 208, 234, 260, 260, 286, 195, 234, 273, 234, 273,
+	 312, 351, 312, 351, 390, 390, 429} ,
+	{14, 29, 43, 58, 87, 116, 130, 144, 29, 58, 87, 116, 173, 231, 260, 289,
+	 43, 87, 130, 173, 260, 347, 390, 433, 58, 116, 173, 231, 347, 462, 520,
+	 578, 0, 87, 116, 144, 130, 173, 217, 116, 144, 144, 173, 202, 202, 231,
+	 173, 217, 217, 260, 303, 303, 347, 144, 173, 202, 173, 202, 231, 260,
+	 231, 260, 289, 289, 318, 217, 260, 303, 260, 303, 347, 390, 347, 390,
+	 433, 433, 477} } ,
+	{{27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486,
+	 540, 81, 162, 243, 324, 486, 648, 729, 810, 108, 216, 324, 432, 648,
+	 864, 972, 1080, 12, 162, 216, 270, 243, 324, 405, 216, 270, 270, 324,
+	 378, 378, 432, 324, 405, 405, 486, 567, 567, 648, 270, 324, 378, 324,
+	 378, 432, 486, 432, 486, 540, 540, 594, 405, 486, 567, 486, 567, 648,
+	 729, 648, 729, 810, 810, 891},
+	{30, 60, 90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540,
+	 600, 90, 180, 270, 360, 540, 720, 810, 900, 120, 240, 360, 480, 720,
+	 960, 1080, 1200, 13, 180, 240, 300, 270, 360, 450, 240, 300, 300, 360,
+	 420, 420, 480, 360, 450, 450, 540, 630, 630, 720, 300, 360, 420, 360,
+	 420, 480, 540, 480, 540, 600, 600, 660, 450, 540, 630, 540, 630, 720,
+	 810, 720, 810, 900, 900, 990} }
+};
 
 static u8 UNKNOWN_BORADCOM[3] = {0x00, 0x14, 0xbf};
+
 static u8 LINKSYSWRT330_LINKSYSWRT300_BROADCOM[3] = {0x00, 0x1a, 0x70};
+
 static u8 LINKSYSWRT350_LINKSYSWRT150_BROADCOM[3] = {0x00, 0x1d, 0x7e};
+
 static u8 BELKINF5D8233V1_RALINK[3] = {0x00, 0x17, 0x3f};
+
 static u8 BELKINF5D82334V3_RALINK[3] = {0x00, 0x1c, 0xdf};
+
 static u8 PCI_RALINK[3] = {0x00, 0x90, 0xcc};
+
 static u8 EDIMAX_RALINK[3] = {0x00, 0x0e, 0x2e};
+
 static u8 AIRLINK_RALINK[3] = {0x00, 0x18, 0x02};
+
 static u8 DLINK_ATHEROS_1[3] = {0x00, 0x1c, 0xf0};
+
 static u8 DLINK_ATHEROS_2[3] = {0x00, 0x21, 0x91};
+
 static u8 CISCO_BROADCOM[3] = {0x00, 0x17, 0x94};
+
 static u8 LINKSYS_MARVELL_4400N[3] = {0x00, 0x14, 0xa4};
-void HTUpdateDefaultSetting(struct rtllib_device* ieee)
+
+void HTUpdateDefaultSetting(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	pHTInfo->bAcceptAddbaReq = 1;
 
-	pHTInfo->bRegShortGI20MHz= 1;
-	pHTInfo->bRegShortGI40MHz= 1;
+	pHTInfo->bRegShortGI20MHz = 1;
+	pHTInfo->bRegShortGI40MHz = 1;
 
 	pHTInfo->bRegBW40MHz = 1;
 
@@ -94,97 +116,110 @@ void HTUpdateDefaultSetting(struct rtllib_device* ieee)
 	pHTInfo->RxReorderWinSize = 64;
 	pHTInfo->RxReorderPendingTime = 30;
 }
-void HTDebugHTCapability(u8* CapIE, u8* TitleString )
+
+void HTDebugHTCapability(u8 *CapIE, u8 *TitleString)
 {
 
 	static u8	EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};
 	struct ht_capab_ele *pCapELE;
 
-	if (!memcmp(CapIE, EWC11NHTCap, sizeof(EWC11NHTCap)))
-	{
+	if (!memcmp(CapIE, EWC11NHTCap, sizeof(EWC11NHTCap))) {
 		RTLLIB_DEBUG(RTLLIB_DL_HT, "EWC IE in %s()\n", __func__);
 		pCapELE = (struct ht_capab_ele *)(&CapIE[4]);
-	}else
+	} else
 		pCapELE = (struct ht_capab_ele *)(&CapIE[0]);
 
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "<Log HT Capability>. Called by %s\n", TitleString );
-
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupported Channel Width = %s\n", (pCapELE->ChlWidth)?"20MHz": "20/40MHz");
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport Short GI for 20M = %s\n", (pCapELE->ShortGI20Mhz)?"YES": "NO");
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport Short GI for 40M = %s\n", (pCapELE->ShortGI40Mhz)?"YES": "NO");
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport TX STBC = %s\n", (pCapELE->TxSTBC)?"YES": "NO");
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMax AMSDU Size = %s\n", (pCapELE->MaxAMSDUSize)?"3839": "7935");
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport CCK in 20/40 mode = %s\n", (pCapELE->DssCCk)?"YES": "NO");
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMax AMPDU Factor = %d\n", pCapELE->MaxRxAMPDUFactor);
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMPDU Density = %d\n", pCapELE->MPDUDensity);
-	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMCS Rate Set = [%x][%x][%x][%x][%x]\n", pCapELE->MCS[0],\
-				pCapELE->MCS[1], pCapELE->MCS[2], pCapELE->MCS[3], pCapELE->MCS[4]);
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "<Log HT Capability>. Called by %s\n",
+		     TitleString);
+
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupported Channel Width = %s\n",
+		     (pCapELE->ChlWidth) ? "20MHz" : "20/40MHz");
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport Short GI for 20M = %s\n",
+		     (pCapELE->ShortGI20Mhz) ? "YES" : "NO");
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport Short GI for 40M = %s\n",
+		     (pCapELE->ShortGI40Mhz) ? "YES" : "NO");
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport TX STBC = %s\n",
+		     (pCapELE->TxSTBC) ? "YES" : "NO");
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMax AMSDU Size = %s\n",
+		     (pCapELE->MaxAMSDUSize) ? "3839" : "7935");
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport CCK in 20/40 mode = %s\n",
+		     (pCapELE->DssCCk) ? "YES" : "NO");
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMax AMPDU Factor = %d\n",
+		     pCapELE->MaxRxAMPDUFactor);
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMPDU Density = %d\n",
+		     pCapELE->MPDUDensity);
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMCS Rate Set = [%x][%x][%x][%x][%x]\n",
+		     pCapELE->MCS[0], pCapELE->MCS[1], pCapELE->MCS[2],
+		     pCapELE->MCS[3], pCapELE->MCS[4]);
 	return;
 
 }
-void HTDebugHTInfo(u8*	InfoIE, u8* TitleString)
+
+void HTDebugHTInfo(u8 *InfoIE, u8 *TitleString)
 {
 
 	static u8	EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};
 	struct ht_info_ele *pHTInfoEle;
 
-	if (!memcmp(InfoIE, EWC11NHTInfo, sizeof(EWC11NHTInfo)))
-	{
+	if (!memcmp(InfoIE, EWC11NHTInfo, sizeof(EWC11NHTInfo))) {
 		RTLLIB_DEBUG(RTLLIB_DL_HT, "EWC IE in %s()\n", __func__);
 		pHTInfoEle = (struct ht_info_ele *)(&InfoIE[4]);
-	}else
+	} else
 		pHTInfoEle = (struct ht_info_ele *)(&InfoIE[0]);
 
 
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "<Log HT Information Element>. Called by %s\n", TitleString);
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "<Log HT Information Element>. "
+		     "Called by %s\n", TitleString);
 
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tPrimary channel = %d\n", pHTInfoEle->ControlChl);
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tPrimary channel = %d\n",
+		     pHTInfoEle->ControlChl);
 	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tSenondary channel =");
-	switch (pHTInfoEle->ExtChlOffset)
-	{
-		case 0:
-			RTLLIB_DEBUG(RTLLIB_DL_HT, "Not Present\n");
-			break;
-		case 1:
-			RTLLIB_DEBUG(RTLLIB_DL_HT, "Upper channel\n");
-			break;
-		case 2:
-			RTLLIB_DEBUG(RTLLIB_DL_HT, "Reserved. Eooro!!!\n");
-			break;
-		case 3:
-			RTLLIB_DEBUG(RTLLIB_DL_HT, "Lower Channel\n");
-			break;
+	switch (pHTInfoEle->ExtChlOffset) {
+	case 0:
+		RTLLIB_DEBUG(RTLLIB_DL_HT, "Not Present\n");
+		break;
+	case 1:
+		RTLLIB_DEBUG(RTLLIB_DL_HT, "Upper channel\n");
+		break;
+	case 2:
+		RTLLIB_DEBUG(RTLLIB_DL_HT, "Reserved. Eooro!!!\n");
+		break;
+	case 3:
+		RTLLIB_DEBUG(RTLLIB_DL_HT, "Lower Channel\n");
+		break;
 	}
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tRecommended channel width = %s\n", (pHTInfoEle->RecommemdedTxWidth)?"20Mhz": "40Mhz");
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tRecommended channel width = %s\n",
+		     (pHTInfoEle->RecommemdedTxWidth) ? "20Mhz" : "40Mhz");
 
 	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tOperation mode for protection = ");
-	switch (pHTInfoEle->OptMode)
-	{
-		case 0:
-			RTLLIB_DEBUG(RTLLIB_DL_HT, "No Protection\n");
-			break;
-		case 1:
-			RTLLIB_DEBUG(RTLLIB_DL_HT, "HT non-member protection mode\n");
-			break;
-		case 2:
-			RTLLIB_DEBUG(RTLLIB_DL_HT, "Suggest to open protection\n");
-			break;
-		case 3:
-			RTLLIB_DEBUG(RTLLIB_DL_HT, "HT mixed mode\n");
-			break;
+	switch (pHTInfoEle->OptMode) {
+	case 0:
+		RTLLIB_DEBUG(RTLLIB_DL_HT, "No Protection\n");
+		break;
+	case 1:
+		RTLLIB_DEBUG(RTLLIB_DL_HT, "HT non-member protection mode\n");
+		break;
+	case 2:
+		RTLLIB_DEBUG(RTLLIB_DL_HT, "Suggest to open protection\n");
+		break;
+	case 3:
+		RTLLIB_DEBUG(RTLLIB_DL_HT, "HT mixed mode\n");
+		break;
 	}
 
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tBasic MCS Rate Set = [%x][%x][%x][%x][%x]\n", pHTInfoEle->BasicMSC[0],\
-				pHTInfoEle->BasicMSC[1], pHTInfoEle->BasicMSC[2], pHTInfoEle->BasicMSC[3], pHTInfoEle->BasicMSC[4]);
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tBasic MCS Rate Set = [%x][%x][%x][%x]"
+		     "[%x]\n", pHTInfoEle->BasicMSC[0], pHTInfoEle->BasicMSC[1],
+		     pHTInfoEle->BasicMSC[2], pHTInfoEle->BasicMSC[3],
+		     pHTInfoEle->BasicMSC[4]);
 	return;
 }
 
-bool IsHTHalfNmode40Bandwidth(struct rtllib_device* ieee)
+bool IsHTHalfNmode40Bandwidth(struct rtllib_device *ieee)
 {
 	bool			retValue = false;
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
-	if (pHTInfo->bCurrentHTSupport == false )
+	if (pHTInfo->bCurrentHTSupport == false)
 		retValue = false;
 	else if (pHTInfo->bRegBW40MHz == false)
 		retValue = false;
@@ -198,25 +233,24 @@ bool IsHTHalfNmode40Bandwidth(struct rtllib_device* ieee)
 	return retValue;
 }
 
-bool IsHTHalfNmodeSGI(struct rtllib_device* ieee, bool is40MHz)
+bool IsHTHalfNmodeSGI(struct rtllib_device *ieee, bool is40MHz)
 {
 	bool			retValue = false;
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
-	if (pHTInfo->bCurrentHTSupport == false )
+	if (pHTInfo->bCurrentHTSupport == false)
 		retValue = false;
 	else if (!ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
 		retValue = false;
-	else if (is40MHz)
-	{
-		if (((struct ht_capab_ele *)(pHTInfo->PeerHTCapBuf))->ShortGI40Mhz)
+	else if (is40MHz) {
+		if (((struct ht_capab_ele *)
+		    (pHTInfo->PeerHTCapBuf))->ShortGI40Mhz)
 			retValue = true;
 		else
 			retValue = false;
-	}
-	else
-	{
-		if (((struct ht_capab_ele *)(pHTInfo->PeerHTCapBuf))->ShortGI20Mhz)
+	} else {
+		if (((struct ht_capab_ele *)
+		   (pHTInfo->PeerHTCapBuf))->ShortGI20Mhz)
 			retValue = true;
 		else
 			retValue = false;
@@ -225,89 +259,75 @@ bool IsHTHalfNmodeSGI(struct rtllib_device* ieee, bool is40MHz)
 	return retValue;
 }
 
-u16 HTHalfMcsToDataRate(struct rtllib_device* ieee,	u8	nMcsRate)
+u16 HTHalfMcsToDataRate(struct rtllib_device *ieee, u8 nMcsRate)
 {
 
 	u8	is40MHz;
 	u8	isShortGI;
 
-	is40MHz  =  (IsHTHalfNmode40Bandwidth(ieee))?1:0;
-	isShortGI = (IsHTHalfNmodeSGI(ieee, is40MHz))? 1:0;
+	is40MHz  =  (IsHTHalfNmode40Bandwidth(ieee)) ? 1 : 0;
+	isShortGI = (IsHTHalfNmodeSGI(ieee, is40MHz)) ? 1 : 0;
 
-	return MCS_DATA_RATE[is40MHz][isShortGI][(nMcsRate&0x7f)];
+	return MCS_DATA_RATE[is40MHz][isShortGI][(nMcsRate & 0x7f)];
 }
 
 
-u16 HTMcsToDataRate( struct rtllib_device* ieee, u8 nMcsRate)
+u16 HTMcsToDataRate(struct rtllib_device *ieee, u8 nMcsRate)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
-	u8	is40MHz = (pHTInfo->bCurBW40MHz)?1:0;
-	u8	isShortGI = (pHTInfo->bCurBW40MHz)?
-						((pHTInfo->bCurShortGI40MHz)?1:0):
-						((pHTInfo->bCurShortGI20MHz)?1:0);
-	return MCS_DATA_RATE[is40MHz][isShortGI][(nMcsRate&0x7f)];
+	u8	is40MHz = (pHTInfo->bCurBW40MHz) ? 1 : 0;
+	u8	isShortGI = (pHTInfo->bCurBW40MHz) ?
+			    ((pHTInfo->bCurShortGI40MHz) ? 1 : 0) :
+			    ((pHTInfo->bCurShortGI20MHz) ? 1 : 0);
+	return MCS_DATA_RATE[is40MHz][isShortGI][(nMcsRate & 0x7f)];
 }
 
-u16  TxCountToDataRate( struct rtllib_device* ieee, u8 nDataRate)
+u16  TxCountToDataRate(struct rtllib_device *ieee, u8 nDataRate)
 {
-	u16		CCKOFDMRate[12] = {0x02 , 0x04 , 0x0b , 0x16 , 0x0c , 0x12 , 0x18 , 0x24 , 0x30 , 0x48 , 0x60 , 0x6c};
+	u16	CCKOFDMRate[12] = {0x02, 0x04, 0x0b, 0x16, 0x0c, 0x12, 0x18,
+				   0x24, 0x30, 0x48, 0x60, 0x6c};
 	u8	is40MHz = 0;
 	u8	isShortGI = 0;
 
-	if (nDataRate < 12)
-	{
+	if (nDataRate < 12) {
 		return CCKOFDMRate[nDataRate];
-	}
-	else
-	{
-		if (nDataRate >= 0x10 && nDataRate <= 0x1f)
-		{
+	} else {
+		if (nDataRate >= 0x10 && nDataRate <= 0x1f) {
 			is40MHz = 0;
 			isShortGI = 0;
-
-		}
-		else if (nDataRate >=0x20  && nDataRate <= 0x2f )
-		{
+		} else if (nDataRate >= 0x20  && nDataRate <= 0x2f) {
 			is40MHz = 1;
 			isShortGI = 0;
 
-		}
-		else if (nDataRate >= 0x30  && nDataRate <= 0x3f )
-		{
+		} else if (nDataRate >= 0x30  && nDataRate <= 0x3f) {
 			is40MHz = 0;
 			isShortGI = 1;
-
-		}
-		else if (nDataRate >= 0x40  && nDataRate <= 0x4f )
-		{
+		} else if (nDataRate >= 0x40  && nDataRate <= 0x4f) {
 			is40MHz = 1;
 			isShortGI = 1;
-
 		}
 		return MCS_DATA_RATE[is40MHz][isShortGI][nDataRate&0xf];
 	}
 }
 
-
-
-bool IsHTHalfNmodeAPs(struct rtllib_device* ieee)
+bool IsHTHalfNmodeAPs(struct rtllib_device *ieee)
 {
 	bool			retValue = false;
-	struct rtllib_network* net = &ieee->current_network;
-
-	if ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3)==0) ||
-		     (memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3)==0) ||
-		     (memcmp(net->bssid, PCI_RALINK, 3)==0) ||
-		     (memcmp(net->bssid, EDIMAX_RALINK, 3)==0) ||
-		     (memcmp(net->bssid, AIRLINK_RALINK, 3)==0) ||
-		     (net->ralink_cap_exist))
+	struct rtllib_network *net = &ieee->current_network;
+
+	if ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3) == 0) ||
+	    (memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3) == 0) ||
+	    (memcmp(net->bssid, PCI_RALINK, 3) == 0) ||
+	    (memcmp(net->bssid, EDIMAX_RALINK, 3) == 0) ||
+	    (memcmp(net->bssid, AIRLINK_RALINK, 3) == 0) ||
+	    (net->ralink_cap_exist))
+		retValue = true;
+	else if (!memcmp(net->bssid, UNKNOWN_BORADCOM, 3) ||
+		!memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3) ||
+		!memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3) ||
+		(net->broadcom_cap_exist))
 		retValue = true;
-	else if ((memcmp(net->bssid, UNKNOWN_BORADCOM, 3)==0) ||
-		    (memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)||
-		    (memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3)==0)||
-		    (net->broadcom_cap_exist))
-		  retValue = true;
 	else if (net->bssht.bdRT2RTAggregation)
 		retValue = true;
 	else
@@ -316,38 +336,35 @@ bool IsHTHalfNmodeAPs(struct rtllib_device* ieee)
 	return retValue;
 }
 
-void HTIOTPeerDetermine(struct rtllib_device* ieee)
+void HTIOTPeerDetermine(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
-	struct rtllib_network* net = &ieee->current_network;
-	if (net->bssht.bdRT2RTAggregation){
+	struct rtllib_network *net = &ieee->current_network;
+	if (net->bssht.bdRT2RTAggregation) {
 		pHTInfo->IOTPeer = HT_IOT_PEER_REALTEK;
-		if (net->bssht.RT2RT_HT_Mode & RT_HT_CAP_USE_92SE){
+		if (net->bssht.RT2RT_HT_Mode & RT_HT_CAP_USE_92SE)
 			pHTInfo->IOTPeer = HT_IOT_PEER_REALTEK_92SE;
-		}
-		if (net->bssht.RT2RT_HT_Mode & RT_HT_CAP_USE_SOFTAP){
+		if (net->bssht.RT2RT_HT_Mode & RT_HT_CAP_USE_SOFTAP)
 			pHTInfo->IOTPeer = HT_IOT_PEER_92U_SOFTAP;
-		}
-	}
-	else if (net->broadcom_cap_exist)
+	} else if (net->broadcom_cap_exist)
 		pHTInfo->IOTPeer = HT_IOT_PEER_BROADCOM;
-	else if ((memcmp(net->bssid, UNKNOWN_BORADCOM, 3)==0) ||
-			(memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)||
-			(memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3)==0)/*||
-			(memcmp(net->bssid, NETGEAR834Bv2_BROADCOM, 3)==0) */)
+	else if (!memcmp(net->bssid, UNKNOWN_BORADCOM, 3) ||
+		 !memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3) ||
+		 !memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3))
 		pHTInfo->IOTPeer = HT_IOT_PEER_BROADCOM;
-	else if ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3)==0) ||
-			(memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3)==0) ||
-			(memcmp(net->bssid, PCI_RALINK, 3)==0) ||
-			(memcmp(net->bssid, EDIMAX_RALINK, 3)==0) ||
-			(memcmp(net->bssid, AIRLINK_RALINK, 3)==0) ||
-			 net->ralink_cap_exist)
+	else if ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3) == 0) ||
+		 (memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3) == 0) ||
+		 (memcmp(net->bssid, PCI_RALINK, 3) == 0) ||
+		 (memcmp(net->bssid, EDIMAX_RALINK, 3) == 0) ||
+		 (memcmp(net->bssid, AIRLINK_RALINK, 3) == 0) ||
+		  net->ralink_cap_exist)
 		pHTInfo->IOTPeer = HT_IOT_PEER_RALINK;
-	else if ((net->atheros_cap_exist )||
-		(memcmp(net->bssid, DLINK_ATHEROS_1, 3) == 0)||
+	else if ((net->atheros_cap_exist) ||
+		(memcmp(net->bssid, DLINK_ATHEROS_1, 3) == 0) ||
 		(memcmp(net->bssid, DLINK_ATHEROS_2, 3) == 0))
 		pHTInfo->IOTPeer = HT_IOT_PEER_ATHEROS;
-	else if ((memcmp(net->bssid, CISCO_BROADCOM, 3)==0)||net->cisco_cap_exist)
+	else if ((memcmp(net->bssid, CISCO_BROADCOM, 3) == 0) ||
+		  net->cisco_cap_exist)
 		pHTInfo->IOTPeer = HT_IOT_PEER_CISCO;
 	else if ((memcmp(net->bssid, LINKSYS_MARVELL_4400N, 3) == 0) ||
 		  net->marvell_cap_exist)
@@ -357,35 +374,35 @@ void HTIOTPeerDetermine(struct rtllib_device* ieee)
 	else
 		pHTInfo->IOTPeer = HT_IOT_PEER_UNKNOWN;
 
-	RTLLIB_DEBUG(RTLLIB_DL_IOT, "Joseph debug!! IOTPEER: %x\n", pHTInfo->IOTPeer);
+	RTLLIB_DEBUG(RTLLIB_DL_IOT, "Joseph debug!! IOTPEER: %x\n",
+		     pHTInfo->IOTPeer);
 }
 
-u8 HTIOTActIsDisableMCS14(struct rtllib_device* ieee, u8* PeerMacAddr)
+u8 HTIOTActIsDisableMCS14(struct rtllib_device *ieee, u8 *PeerMacAddr)
 {
 	return 0;
- }
+}
 
 
-bool HTIOTActIsDisableMCS15(struct rtllib_device* ieee)
+bool HTIOTActIsDisableMCS15(struct rtllib_device *ieee)
 {
 	bool retValue = false;
 
 	return retValue;
 }
 
-bool HTIOTActIsDisableMCSTwoSpatialStream(struct rtllib_device* ieee)
+bool HTIOTActIsDisableMCSTwoSpatialStream(struct rtllib_device *ieee)
 {
-	bool retValue = false;
-	return retValue;
+	return false;
 }
 
-u8 HTIOTActIsDisableEDCATurbo(struct rtllib_device*	ieee, u8* PeerMacAddr)
+u8 HTIOTActIsDisableEDCATurbo(struct rtllib_device *ieee, u8 *PeerMacAddr)
 {
 	return false;
 }
 
 
-bool HTIOTActIsEnableBETxOPLimit(struct rtllib_device* ieee)
+bool HTIOTActIsEnableBETxOPLimit(struct rtllib_device *ieee)
 {
 	bool	retValue = false;
 
@@ -393,70 +410,65 @@ bool HTIOTActIsEnableBETxOPLimit(struct rtllib_device* ieee)
 }
 
 
-u8 HTIOTActIsMgntUseCCK6M(struct rtllib_device* ieee,struct rtllib_network *network)
+u8 HTIOTActIsMgntUseCCK6M(struct rtllib_device *ieee,
+			  struct rtllib_network *network)
 {
 	u8	retValue = 0;
 
 
 	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
-	{
 		retValue = 1;
-	}
 
 	return retValue;
 }
 
-u8
-HTIOTActWAIOTBroadcom(struct rtllib_device* ieee)
+u8 HTIOTActWAIOTBroadcom(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	u8		retValue = false;
-	u8		boundary=59;
+	u8		boundary = 59;
 
 	pHTInfo->bWAIotBroadcom = false;
-	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
-	{
-		if (ieee->current_network.bssht.bdBandWidth == HT_CHANNEL_WIDTH_20_40)
-		{
-			if (!(pHTInfo->bRegBW40MHz))
-			{
-				if (ieee->current_network.mode != WIRELESS_MODE_B)
-				{
+	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM) {
+		if (ieee->current_network.bssht.bdBandWidth ==
+		    HT_CHANNEL_WIDTH_20_40) {
+			if (!(pHTInfo->bRegBW40MHz)) {
+				if (ieee->current_network.mode !=
+				    WIRELESS_MODE_B) {
 					pHTInfo->bWAIotBroadcom = true;
 
-					if (ieee->b_customer_lenovo_id == true)
+					if (ieee->b_customer_lenovo_id)
 						boundary = 30;
 
-					if ( ieee->current_network.RSSI >= boundary)
+					if (ieee->current_network.RSSI >=
+					    boundary)
 						retValue = true;
 				}
-			}else{
-				;
 			}
 		}
 	}
 	return retValue;
 }
 
-u8 HTIOTActIsForcedCTS2Self(struct rtllib_device *ieee, struct rtllib_network *network)
+u8 HTIOTActIsForcedCTS2Self(struct rtllib_device *ieee,
+			    struct rtllib_network *network)
 {
 	u8	retValue = 0;
 	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_MARVELL)
-	{
 		retValue = 1;
-	}
 
 	return retValue;
 }
 
-u8 HTIOTActIsForcedRTSCTS(struct rtllib_device *ieee, struct rtllib_network *network)
+u8 HTIOTActIsForcedRTSCTS(struct rtllib_device *ieee,
+			  struct rtllib_network *network)
 {
 	u8	retValue = 0;
 	return retValue;
 }
 
-u8
-HTIOTActIsForcedAMSDU8K(struct rtllib_device *ieee, struct rtllib_network *network)
+u8 HTIOTActIsForcedAMSDU8K(struct rtllib_device *ieee,
+			   struct rtllib_network *network)
 {
 	u8 retValue = 0;
 
@@ -466,54 +478,48 @@ HTIOTActIsForcedAMSDU8K(struct rtllib_device *ieee, struct rtllib_network *netwo
 u8 HTIOTActIsCCDFsync(struct rtllib_device *ieee)
 {
 	u8	retValue = 0;
+
 	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
-	{
 		retValue = 1;
-	}
 	return retValue;
 }
 
-u8
-HTIOCActRejcectADDBARequest(struct rtllib_network *network)
+u8 HTIOCActRejcectADDBARequest(struct rtllib_network *network)
 {
 	u8	retValue = 0;
 
 	return retValue;
-
 }
 
-u8
-  HTIOTActIsEDCABiasRx(struct rtllib_device* ieee,struct rtllib_network *network)
+u8 HTIOTActIsEDCABiasRx(struct rtllib_device *ieee,
+			struct rtllib_network *network)
 {
 	u8	retValue = 0;
 
 	return retValue;
 }
 
-u8
-HTIOTActDisableShortGI(struct rtllib_device* ieee,struct rtllib_network *network)
+u8 HTIOTActDisableShortGI(struct rtllib_device *ieee,
+			  struct rtllib_network *network)
 {
 	u8	retValue = 0;
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
-	if (pHTInfo->IOTPeer==HT_IOT_PEER_RALINK)
-	{
+	if (pHTInfo->IOTPeer == HT_IOT_PEER_RALINK)
 			retValue = 1;
-	}
 
 	return retValue;
 }
 
-u8
-HTIOTActDisableHighPower(struct rtllib_device* ieee,struct rtllib_network *network)
+u8 HTIOTActDisableHighPower(struct rtllib_device *ieee,
+			    struct rtllib_network *network)
 {
 	u8	retValue = 0;
 
 	return retValue;
 }
 
-void
-HTIOTActDetermineRaFunc(struct rtllib_device* ieee,	bool	bPeerRx2ss)
+void HTIOTActDetermineRaFunc(struct rtllib_device *ieee, bool bPeerRx2ss)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	pHTInfo->IOTRaFunc &= HT_IOT_RAFUNC_DISABLE_ALL;
@@ -527,81 +533,77 @@ HTIOTActDetermineRaFunc(struct rtllib_device* ieee,	bool	bPeerRx2ss)
 }
 
 
-u8
-HTIOTActIsDisableTx40MHz(struct rtllib_device* ieee,struct rtllib_network *network)
+u8 HTIOTActIsDisableTx40MHz(struct rtllib_device *ieee,
+			    struct rtllib_network *network)
 {
 	u8	retValue = 0;
 
 	return retValue;
 }
 
-u8
-HTIOTActIsTxNoAggregation(struct rtllib_device* ieee,struct rtllib_network *network)
+u8 HTIOTActIsTxNoAggregation(struct rtllib_device *ieee,
+			     struct rtllib_network *network)
 {
 	u8 retValue = 0;
 
 	return retValue;
 }
 
-
-u8
-HTIOTActIsDisableTx2SS(struct rtllib_device* ieee,struct rtllib_network *network)
+u8 HTIOTActIsDisableTx2SS(struct rtllib_device *ieee,
+			  struct rtllib_network *network)
 {
 	u8	retValue = 0;
 
 	return retValue;
 }
 
-
-bool HTIOCActIsDisableCckRate(struct rtllib_device* ieee,struct rtllib_network *network)
+bool HTIOCActIsDisableCckRate(struct rtllib_device *ieee,
+			      struct rtllib_network *network)
 {
 	bool	retValue = false;
 	return retValue;
 }
 
-bool HTIOCActAllowPeerAggOnePacket(struct rtllib_device* ieee,struct rtllib_network *network)
+bool HTIOCActAllowPeerAggOnePacket(struct rtllib_device *ieee,
+				   struct rtllib_network *network)
 {
 	bool	retValue = false;
 	return retValue;
 }
 
-bool
-HTIOTActIsNullDataPowerSaving(struct rtllib_device* ieee,struct rtllib_network *network)
+bool HTIOTActIsNullDataPowerSaving(struct rtllib_device *ieee,
+				   struct rtllib_network *network)
 {
 	bool	retValue = false;
 	return retValue;
 }
 
-void HTResetIOTSetting(
-	struct rt_hi_throughput *pHTInfo
-)
+void HTResetIOTSetting(struct rt_hi_throughput *pHTInfo)
 {
 	pHTInfo->IOTAction = 0;
 	pHTInfo->IOTPeer = HT_IOT_PEER_UNKNOWN;
 	pHTInfo->IOTRaFunc = 0;
 }
 
-
-void HTConstructCapabilityElement(struct rtllib_device* ieee, u8* posHTCap, u8* len, u8 IsEncrypt, bool bAssoc)
+void HTConstructCapabilityElement(struct rtllib_device *ieee, u8 *posHTCap,
+				  u8 *len, u8 IsEncrypt, bool bAssoc)
 {
 	struct rt_hi_throughput *pHT = ieee->pHTInfo;
 	struct ht_capab_ele *pCapELE = NULL;
 
-	if ((posHTCap == NULL) || (pHT == NULL))
-	{
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posHTCap or pHTInfo can't be null in HTConstructCapabilityElement()\n");
+	if ((posHTCap == NULL) || (pHT == NULL)) {
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posHTCap or pHTInfo can't be "
+			     "null in HTConstructCapabilityElement()\n");
 		return;
 	}
 	memset(posHTCap, 0, *len);
 
-	if ((bAssoc) && (pHT->ePeerHTSpecVer == HT_SPEC_VER_EWC))
-	{
+	if ((bAssoc) && (pHT->ePeerHTSpecVer == HT_SPEC_VER_EWC)) {
 		u8	EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};
 		memcpy(posHTCap, EWC11NHTCap, sizeof(EWC11NHTCap));
 		pCapELE = (struct ht_capab_ele *)&(posHTCap[4]);
 		*len = 30 + 2;
-	}else
-	{
+	} else {
 		pCapELE = (struct ht_capab_ele *)posHTCap;
 		*len = 26 + 2;
 	}
@@ -610,7 +612,7 @@ void HTConstructCapabilityElement(struct rtllib_device* ieee, u8* posHTCap, u8*
 	if (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
 		pCapELE->ChlWidth = 0;
 	else
-			pCapELE->ChlWidth = (pHT->bRegBW40MHz?1:0);
+		pCapELE->ChlWidth = (pHT->bRegBW40MHz ? 1 : 0);
 
 	pCapELE->MimoPwrSave		= pHT->SelfMimoPs;
 	pCapELE->GreenField		= 0;
@@ -620,21 +622,20 @@ void HTConstructCapabilityElement(struct rtllib_device* ieee, u8* posHTCap, u8*
 	pCapELE->TxSTBC			= 1;
 	pCapELE->RxSTBC			= 0;
 	pCapELE->DelayBA		= 0;
-	pCapELE->MaxAMSDUSize	= (MAX_RECEIVE_BUFFER_SIZE>=7935)?1:0;
-	pCapELE->DssCCk			= ((pHT->bRegBW40MHz)?(pHT->bRegSuppCCK?1:0):0);
-	pCapELE->PSMP			= 0;
-	pCapELE->LSigTxopProtect	= 0;
+	pCapELE->MaxAMSDUSize = (MAX_RECEIVE_BUFFER_SIZE >= 7935) ? 1 : 0;
+	pCapELE->DssCCk = ((pHT->bRegBW40MHz) ? (pHT->bRegSuppCCK ? 1 : 0) : 0);
+	pCapELE->PSMP = 0;
+	pCapELE->LSigTxopProtect = 0;
 
 
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "TX HT cap/info ele BW=%d MaxAMSDUSize:%d DssCCk:%d\n", pCapELE->ChlWidth, pCapELE->MaxAMSDUSize, pCapELE->DssCCk);
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "TX HT cap/info ele BW=%d MaxAMSDUSize:%d "
+		     "DssCCk:%d\n", pCapELE->ChlWidth, pCapELE->MaxAMSDUSize,
+		     pCapELE->DssCCk);
 
-	if ( IsEncrypt)
-	{
+	if (IsEncrypt) {
 		pCapELE->MPDUDensity	= 7;
 		pCapELE->MaxRxAMPDUFactor	= 2;
-	}
-	else
-	{
+	} else {
 		pCapELE->MaxRxAMPDUFactor	= 3;
 		pCapELE->MPDUDensity	= 0;
 	}
@@ -658,67 +659,63 @@ void HTConstructCapabilityElement(struct rtllib_device* ieee, u8* posHTCap, u8*
 		if (pHT->IOTAction & HT_IOT_ACT_DISABLE_RX_40MHZ_SHORT_GI)
 			pCapELE->ShortGI40Mhz		= 0;
 
-		if (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
-		{
+		if (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev)) {
 			pCapELE->ChlWidth = 0;
-
 			pCapELE->MCS[1] = 0;
 		}
 	}
-
-
-
-
-
 	return;
-
 }
-void HTConstructInfoElement(struct rtllib_device* ieee, u8* posHTInfo, u8* len, u8 IsEncrypt)
+
+void HTConstructInfoElement(struct rtllib_device *ieee, u8 *posHTInfo,
+			    u8 *len, u8 IsEncrypt)
 {
 	struct rt_hi_throughput *pHT = ieee->pHTInfo;
 	struct ht_info_ele *pHTInfoEle = (struct ht_info_ele *)posHTInfo;
-	if ((posHTInfo == NULL) || (pHTInfoEle == NULL))
-	{
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posHTInfo or pHTInfoEle can't be null in HTConstructInfoElement()\n");
+	if ((posHTInfo == NULL) || (pHTInfoEle == NULL)) {
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posHTInfo or pHTInfoEle can't be "
+			     "null in HTConstructInfoElement()\n");
 		return;
 	}
 
 	memset(posHTInfo, 0, *len);
-	if ( (ieee->iw_mode == IW_MODE_ADHOC) || (ieee->iw_mode == IW_MODE_MASTER))
-	{
+	if ((ieee->iw_mode == IW_MODE_ADHOC) ||
+	    (ieee->iw_mode == IW_MODE_MASTER)) {
 		pHTInfoEle->ControlChl	= ieee->current_network.channel;
-		pHTInfoEle->ExtChlOffset = ((pHT->bRegBW40MHz == false)?HT_EXTCHNL_OFFSET_NO_EXT:
-							(ieee->current_network.channel<=6)?
-							HT_EXTCHNL_OFFSET_UPPER:HT_EXTCHNL_OFFSET_LOWER);
+		pHTInfoEle->ExtChlOffset = ((pHT->bRegBW40MHz == false) ?
+					    HT_EXTCHNL_OFFSET_NO_EXT :
+					    (ieee->current_network.channel <= 6)
+					    ? HT_EXTCHNL_OFFSET_UPPER :
+					    HT_EXTCHNL_OFFSET_LOWER);
 		pHTInfoEle->RecommemdedTxWidth	= pHT->bRegBW40MHz;
-		pHTInfoEle->RIFS					= 0;
+		pHTInfoEle->RIFS			= 0;
 		pHTInfoEle->PSMPAccessOnly		= 0;
 		pHTInfoEle->SrvIntGranularity		= 0;
-		pHTInfoEle->OptMode				= pHT->CurrentOpMode;
+		pHTInfoEle->OptMode			= pHT->CurrentOpMode;
 		pHTInfoEle->NonGFDevPresent		= 0;
 		pHTInfoEle->DualBeacon			= 0;
 		pHTInfoEle->SecondaryBeacon		= 0;
 		pHTInfoEle->LSigTxopProtectFull		= 0;
-		pHTInfoEle->PcoActive				= 0;
-		pHTInfoEle->PcoPhase				= 0;
+		pHTInfoEle->PcoActive			= 0;
+		pHTInfoEle->PcoPhase			= 0;
 
 		memset(pHTInfoEle->BasicMSC, 0, 16);
 
 
 		*len = 22 + 2;
 
-	}
-	else
-	{
+	} else {
 		*len = 0;
 	}
 	return;
 }
 
-void HTConstructRT2RTAggElement(struct rtllib_device* ieee, u8* posRT2RTAgg, u8* len)
+void HTConstructRT2RTAggElement(struct rtllib_device *ieee, u8 *posRT2RTAgg,
+				u8 *len)
 {
 	if (posRT2RTAgg == NULL) {
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posRT2RTAgg can't be null in HTConstructRT2RTAggElement()\n");
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posRT2RTAgg can't be null in "
+			     "HTConstructRT2RTAggElement()\n");
 		return;
 	}
 	memset(posRT2RTAgg, 0, *len);
@@ -730,21 +727,20 @@ void HTConstructRT2RTAggElement(struct rtllib_device* ieee, u8* posRT2RTAgg, u8*
 
 	*posRT2RTAgg = 0x30;
 
-	if (ieee->bSupportRemoteWakeUp) {
+	if (ieee->bSupportRemoteWakeUp)
 		*posRT2RTAgg |= RT_HT_CAP_USE_WOW;
-	}
 
 	*len = 6 + 2;
 
 	return;
 }
 
-u8 HT_PickMCSRate(struct rtllib_device* ieee, u8* pOperateMCS)
+u8 HT_PickMCSRate(struct rtllib_device *ieee, u8 *pOperateMCS)
 {
-	u8					i;
-	if (pOperateMCS == NULL)
-	{
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "pOperateMCS can't be null in HT_PickMCSRate()\n");
+	u8 i;
+	if (pOperateMCS == NULL) {
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "pOperateMCS can't be null"
+			     " in HT_PickMCSRate()\n");
 		return false;
 	}
 
@@ -752,14 +748,14 @@ u8 HT_PickMCSRate(struct rtllib_device* ieee, u8* pOperateMCS)
 	case IEEE_A:
 	case IEEE_B:
 	case IEEE_G:
-		for (i=0;i<=15;i++)
-				pOperateMCS[i] = 0;
+		for (i = 0; i <= 15; i++)
+			pOperateMCS[i] = 0;
 		break;
 	case IEEE_N_24G:
 	case IEEE_N_5G:
-		pOperateMCS[0] &=RATE_ADPT_1SS_MASK;
-		pOperateMCS[1] &=RATE_ADPT_2SS_MASK;
-		pOperateMCS[3] &=RATE_ADPT_MCS32_MASK;
+		pOperateMCS[0] &= RATE_ADPT_1SS_MASK;
+		pOperateMCS[1] &= RATE_ADPT_2SS_MASK;
+		pOperateMCS[3] &= RATE_ADPT_MCS32_MASK;
 		break;
 	default:
 		break;
@@ -769,145 +765,151 @@ u8 HT_PickMCSRate(struct rtllib_device* ieee, u8* pOperateMCS)
 	return true;
 }
 
-u8 HTGetHighestMCSRate(struct rtllib_device* ieee, u8* pMCSRateSet, u8* pMCSFilter)
+u8 HTGetHighestMCSRate(struct rtllib_device *ieee, u8 *pMCSRateSet,
+		       u8 *pMCSFilter)
 {
 	u8		i, j;
 	u8		bitMap;
 	u8		mcsRate = 0;
 	u8		availableMcsRate[16];
-	if (pMCSRateSet == NULL || pMCSFilter == NULL)
-	{
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "pMCSRateSet or pMCSFilter can't be null in HTGetHighestMCSRate()\n");
+	if (pMCSRateSet == NULL || pMCSFilter == NULL) {
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "pMCSRateSet or pMCSFilter can't "
+			     "be null in HTGetHighestMCSRate()\n");
 		return false;
 	}
-	for (i=0; i<16; i++)
+	for (i = 0; i < 16; i++)
 		availableMcsRate[i] = pMCSRateSet[i] & pMCSFilter[i];
 
-	for (i = 0; i < 16; i++)
-	{
+	for (i = 0; i < 16; i++) {
 		if (availableMcsRate[i] != 0)
 			break;
 	}
 	if (i == 16)
 		return false;
 
-	for (i = 0; i < 16; i++)
-	{
-		if (availableMcsRate[i] != 0)
-		{
+	for (i = 0; i < 16; i++) {
+		if (availableMcsRate[i] != 0) {
 			bitMap = availableMcsRate[i];
-			for (j = 0; j < 8; j++)
-			{
-				if ((bitMap%2) != 0)
-				{
-					if (HTMcsToDataRate(ieee, (8*i+j)) > HTMcsToDataRate(ieee, mcsRate))
+			for (j = 0; j < 8; j++) {
+				if ((bitMap%2) != 0) {
+					if (HTMcsToDataRate(ieee, (8*i+j)) >
+					    HTMcsToDataRate(ieee, mcsRate))
 						mcsRate = (8*i+j);
 				}
 				bitMap = bitMap>>1;
 			}
 		}
 	}
-	return (mcsRate|0x80);
+	return mcsRate | 0x80;
 }
 
-u8 HTFilterMCSRate( struct rtllib_device* ieee, u8* pSupportMCS, u8* pOperateMCS)
+u8 HTFilterMCSRate(struct rtllib_device *ieee, u8 *pSupportMCS, u8 *pOperateMCS)
 {
 
-	u8 i=0;
-
-	for (i=0;i<=15;i++){
-		pOperateMCS[i] = ieee->Regdot11TxHTOperationalRateSet[i]&pSupportMCS[i];
-	}
-
+	u8 i;
 
+	for (i = 0; i <= 15; i++)
+		pOperateMCS[i] = ieee->Regdot11TxHTOperationalRateSet[i] &
+				 pSupportMCS[i];
 
 	HT_PickMCSRate(ieee, pOperateMCS);
 
 	if (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
 		pOperateMCS[1] = 0;
 
-	for (i=2; i<=15; i++)
+	for (i = 2; i <= 15; i++)
 		pOperateMCS[i] = 0;
 
 	return true;
 }
-void HTSetConnectBwMode(struct rtllib_device* ieee, enum ht_channel_width Bandwidth, enum ht_extchnl_offset Offset);
+
+void HTSetConnectBwMode(struct rtllib_device *ieee,
+			enum ht_channel_width Bandwidth,
+			enum ht_extchnl_offset Offset);
+
 void HTOnAssocRsp(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	struct ht_capab_ele *pPeerHTCap = NULL;
 	struct ht_info_ele *pPeerHTInfo = NULL;
-	u16	nMaxAMSDUSize = 0;
-	u8*	pMcsFilter = NULL;
+	u16 nMaxAMSDUSize = 0;
+	u8 *pMcsFilter = NULL;
 
-	static u8				EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};
-	static u8				EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};
+	static u8 EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};
+	static u8 EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};
 
-	if ( pHTInfo->bCurrentHTSupport == false )
-	{
-		RTLLIB_DEBUG(RTLLIB_DL_ERR, "<=== HTOnAssocRsp(): HT_DISABLE\n");
+	if (pHTInfo->bCurrentHTSupport == false) {
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "<=== HTOnAssocRsp(): "
+			     "HT_DISABLE\n");
 		return;
 	}
 	RTLLIB_DEBUG(RTLLIB_DL_HT, "===> HTOnAssocRsp_wq(): HT_ENABLE\n");
 
-	if (!memcmp(pHTInfo->PeerHTCapBuf,EWC11NHTCap, sizeof(EWC11NHTCap)))
+	if (!memcmp(pHTInfo->PeerHTCapBuf, EWC11NHTCap, sizeof(EWC11NHTCap)))
 		pPeerHTCap = (struct ht_capab_ele *)(&pHTInfo->PeerHTCapBuf[4]);
 	else
 		pPeerHTCap = (struct ht_capab_ele *)(pHTInfo->PeerHTCapBuf);
 
 	if (!memcmp(pHTInfo->PeerHTInfoBuf, EWC11NHTInfo, sizeof(EWC11NHTInfo)))
-		pPeerHTInfo = (struct ht_info_ele *)(&pHTInfo->PeerHTInfoBuf[4]);
+		pPeerHTInfo = (struct ht_info_ele *)
+			     (&pHTInfo->PeerHTInfoBuf[4]);
 	else
 		pPeerHTInfo = (struct ht_info_ele *)(pHTInfo->PeerHTInfoBuf);
 
-	RTLLIB_DEBUG_DATA(RTLLIB_DL_DATA|RTLLIB_DL_HT, pPeerHTCap, sizeof(struct ht_capab_ele));
-	HTSetConnectBwMode(ieee, (enum ht_channel_width)(pPeerHTCap->ChlWidth), (enum ht_extchnl_offset)(pPeerHTInfo->ExtChlOffset));
-	pHTInfo->bCurTxBW40MHz = ((pPeerHTInfo->RecommemdedTxWidth == 1)?true:false);
+	RTLLIB_DEBUG_DATA(RTLLIB_DL_DATA | RTLLIB_DL_HT, pPeerHTCap,
+			  sizeof(struct ht_capab_ele));
+	HTSetConnectBwMode(ieee, (enum ht_channel_width)(pPeerHTCap->ChlWidth),
+			  (enum ht_extchnl_offset)(pPeerHTInfo->ExtChlOffset));
+	pHTInfo->bCurTxBW40MHz = ((pPeerHTInfo->RecommemdedTxWidth == 1) ?
+				 true : false);
 
-	pHTInfo->bCurShortGI20MHz=
-		((pHTInfo->bRegShortGI20MHz)?((pPeerHTCap->ShortGI20Mhz==1)?true:false):false);
-	pHTInfo->bCurShortGI40MHz=
-		((pHTInfo->bRegShortGI40MHz)?((pPeerHTCap->ShortGI40Mhz==1)?true:false):false);
+	pHTInfo->bCurShortGI20MHz = ((pHTInfo->bRegShortGI20MHz) ?
+				    ((pPeerHTCap->ShortGI20Mhz == 1) ?
+				    true : false) : false);
+	pHTInfo->bCurShortGI40MHz = ((pHTInfo->bRegShortGI40MHz) ?
+				     ((pPeerHTCap->ShortGI40Mhz == 1) ?
+				     true : false) : false);
 
-	pHTInfo->bCurSuppCCK =
-		((pHTInfo->bRegSuppCCK)?((pPeerHTCap->DssCCk==1)?true:false):false);
+	pHTInfo->bCurSuppCCK = ((pHTInfo->bRegSuppCCK) ?
+			       ((pPeerHTCap->DssCCk == 1) ? true :
+			       false) : false);
 
 
 	pHTInfo->bCurrent_AMSDU_Support = pHTInfo->bAMSDU_Support;
 
-	nMaxAMSDUSize = (pPeerHTCap->MaxAMSDUSize==0)?3839:7935;
+	nMaxAMSDUSize = (pPeerHTCap->MaxAMSDUSize == 0) ? 3839 : 7935;
 
-	if (pHTInfo->nAMSDU_MaxSize > nMaxAMSDUSize )
+	if (pHTInfo->nAMSDU_MaxSize > nMaxAMSDUSize)
 		pHTInfo->nCurrent_AMSDU_MaxSize = nMaxAMSDUSize;
 	else
 		pHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;
 
 	pHTInfo->bCurrentAMPDUEnable = pHTInfo->bAMPDUEnable;
 	if (ieee->rtllib_ap_sec_type &&
-	   (ieee->rtllib_ap_sec_type(ieee)&(SEC_ALG_WEP|SEC_ALG_TKIP))){
-		if ( (pHTInfo->IOTPeer== HT_IOT_PEER_ATHEROS) ||
-				(pHTInfo->IOTPeer == HT_IOT_PEER_UNKNOWN) )
+	   (ieee->rtllib_ap_sec_type(ieee)&(SEC_ALG_WEP|SEC_ALG_TKIP))) {
+		if ((pHTInfo->IOTPeer == HT_IOT_PEER_ATHEROS) ||
+				(pHTInfo->IOTPeer == HT_IOT_PEER_UNKNOWN))
 			pHTInfo->bCurrentAMPDUEnable = false;
 	}
 
-	if (!pHTInfo->bRegRT2RTAggregation)
-	{
+	if (!pHTInfo->bRegRT2RTAggregation) {
 		if (pHTInfo->AMPDU_Factor > pPeerHTCap->MaxRxAMPDUFactor)
-			pHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;
+			pHTInfo->CurrentAMPDUFactor =
+						 pPeerHTCap->MaxRxAMPDUFactor;
 		else
 			pHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;
 
 	} else {
-		if (ieee->current_network.bssht.bdRT2RTAggregation)
-		{
-			if ( ieee->pairwise_key_type != KEY_TYPE_NA)
-				pHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;
+		if (ieee->current_network.bssht.bdRT2RTAggregation) {
+			if (ieee->pairwise_key_type != KEY_TYPE_NA)
+				pHTInfo->CurrentAMPDUFactor =
+						 pPeerHTCap->MaxRxAMPDUFactor;
 			else
 				pHTInfo->CurrentAMPDUFactor = HT_AGG_SIZE_64K;
-		}else
-		{
+		} else {
 			if (pPeerHTCap->MaxRxAMPDUFactor < HT_AGG_SIZE_32K)
-				pHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;
+				pHTInfo->CurrentAMPDUFactor =
+						 pPeerHTCap->MaxRxAMPDUFactor;
 			else
 				pHTInfo->CurrentAMPDUFactor = HT_AGG_SIZE_32K;
 		}
@@ -916,8 +918,7 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 		pHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;
 	else
 		pHTInfo->CurrentMPDUDensity = pPeerHTCap->MPDUDensity;
-	if (pHTInfo->IOTAction & HT_IOT_ACT_TX_USE_AMSDU_8K)
-	{
+	if (pHTInfo->IOTAction & HT_IOT_ACT_TX_USE_AMSDU_8K) {
 		pHTInfo->bCurrentAMPDUEnable = false;
 		pHTInfo->ForcedAMSDUMode = HT_AGG_FORCE_ENABLE;
 		pHTInfo->ForcedAMSDUMaxSize = 7935;
@@ -927,7 +928,7 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 	if (pPeerHTCap->MCS[0] == 0)
 		pPeerHTCap->MCS[0] = 0xff;
 
-	HTIOTActDetermineRaFunc(ieee, ((pPeerHTCap->MCS[1])!=0));
+	HTIOTActDetermineRaFunc(ieee, ((pPeerHTCap->MCS[1]) != 0));
 
 	HTFilterMCSRate(ieee, pPeerHTCap->MCS, ieee->dot11HTOperationalRateSet);
 
@@ -936,15 +937,14 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 		pMcsFilter = MCS_FILTER_1SS;
 	else
 		pMcsFilter = MCS_FILTER_ALL;
-	ieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee, ieee->dot11HTOperationalRateSet, pMcsFilter);
+	ieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee,
+				   ieee->dot11HTOperationalRateSet, pMcsFilter);
 	ieee->HTCurrentOperaRate = ieee->HTHighestOperaRate;
 
 	pHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;
-
 }
 
-void HTSetConnectBwModeCallback(struct rtllib_device* ieee);
-void HTInitializeHTInfo(struct rtllib_device* ieee)
+void HTInitializeHTInfo(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
@@ -965,10 +965,14 @@ void HTInitializeHTInfo(struct rtllib_device* ieee)
 	pHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;
 	pHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;
 
-	memset((void*)(&(pHTInfo->SelfHTCap)), 0, sizeof(pHTInfo->SelfHTCap));
-	memset((void*)(&(pHTInfo->SelfHTInfo)), 0, sizeof(pHTInfo->SelfHTInfo));
-	memset((void*)(&(pHTInfo->PeerHTCapBuf)), 0, sizeof(pHTInfo->PeerHTCapBuf));
-	memset((void*)(&(pHTInfo->PeerHTInfoBuf)), 0, sizeof(pHTInfo->PeerHTInfoBuf));
+	memset((void *)(&(pHTInfo->SelfHTCap)), 0,
+		sizeof(pHTInfo->SelfHTCap));
+	memset((void *)(&(pHTInfo->SelfHTInfo)), 0,
+		sizeof(pHTInfo->SelfHTInfo));
+	memset((void *)(&(pHTInfo->PeerHTCapBuf)), 0,
+		sizeof(pHTInfo->PeerHTCapBuf));
+	memset((void *)(&(pHTInfo->PeerHTInfoBuf)), 0,
+		sizeof(pHTInfo->PeerHTInfoBuf));
 
 	pHTInfo->bSwBwInProgress = false;
 	pHTInfo->ChnlOp = CHNLOP_NONE;
@@ -984,12 +988,13 @@ void HTInitializeHTInfo(struct rtllib_device* ieee)
 	pHTInfo->IOTRaFunc = 0;
 
 	{
-		u8* RegHTSuppRateSets = &(ieee->RegHTSuppRateSet[0]);
+		u8 *RegHTSuppRateSets = &(ieee->RegHTSuppRateSet[0]);
 		RegHTSuppRateSets[0] = 0xFF;
 		RegHTSuppRateSets[1] = 0xFF;
 		RegHTSuppRateSets[4] = 0x01;
 	}
 }
+
 void HTInitializeBssDesc(struct bss_ht *pBssHT)
 {
 
@@ -999,39 +1004,46 @@ void HTInitializeBssDesc(struct bss_ht *pBssHT)
 	memset(pBssHT->bdHTInfoBuf, 0, sizeof(pBssHT->bdHTInfoBuf));
 	pBssHT->bdHTInfoLen = 0;
 
-	pBssHT->bdHTSpecVer= HT_SPEC_VER_IEEE;
+	pBssHT->bdHTSpecVer = HT_SPEC_VER_IEEE;
 
 	pBssHT->bdRT2RTAggregation = false;
 	pBssHT->bdRT2RTLongSlotTime = false;
 	pBssHT->RT2RT_HT_Mode = (enum rt_ht_capability)0;
 }
 
-void HTResetSelfAndSavePeerSetting(struct rtllib_device* ieee,	struct rtllib_network * pNetwork)
+void HTResetSelfAndSavePeerSetting(struct rtllib_device *ieee,
+				   struct rtllib_network *pNetwork)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	u8	bIOTAction = 0;
 
 	RTLLIB_DEBUG(RTLLIB_DL_HT, "==============>%s()\n", __func__);
-	/*unmark bEnableHT flag here is the same reason why unmarked in function rtllib_softmac_new_net. WB 2008.09.10*/
-	if (pNetwork->bssht.bdSupportHT)
-	{
+	/* unmark bEnableHT flag here is the same reason why unmarked in
+	 * function rtllib_softmac_new_net. WB 2008.09.10*/
+	if (pNetwork->bssht.bdSupportHT) {
 		pHTInfo->bCurrentHTSupport = true;
 		pHTInfo->ePeerHTSpecVer = pNetwork->bssht.bdHTSpecVer;
 
-		if (pNetwork->bssht.bdHTCapLen > 0 &&	pNetwork->bssht.bdHTCapLen <= sizeof(pHTInfo->PeerHTCapBuf))
-			memcpy(pHTInfo->PeerHTCapBuf, pNetwork->bssht.bdHTCapBuf, pNetwork->bssht.bdHTCapLen);
-
-		if (pNetwork->bssht.bdHTInfoLen > 0 && pNetwork->bssht.bdHTInfoLen <= sizeof(pHTInfo->PeerHTInfoBuf))
-			memcpy(pHTInfo->PeerHTInfoBuf, pNetwork->bssht.bdHTInfoBuf, pNetwork->bssht.bdHTInfoLen);
-
-		if (pHTInfo->bRegRT2RTAggregation)
-		{
-			pHTInfo->bCurrentRT2RTAggregation = pNetwork->bssht.bdRT2RTAggregation;
-			pHTInfo->bCurrentRT2RTLongSlotTime = pNetwork->bssht.bdRT2RTLongSlotTime;
+		if (pNetwork->bssht.bdHTCapLen > 0 &&
+		    pNetwork->bssht.bdHTCapLen <= sizeof(pHTInfo->PeerHTCapBuf))
+			memcpy(pHTInfo->PeerHTCapBuf,
+			       pNetwork->bssht.bdHTCapBuf,
+			       pNetwork->bssht.bdHTCapLen);
+
+		if (pNetwork->bssht.bdHTInfoLen > 0 &&
+		    pNetwork->bssht.bdHTInfoLen <=
+		    sizeof(pHTInfo->PeerHTInfoBuf))
+			memcpy(pHTInfo->PeerHTInfoBuf,
+			       pNetwork->bssht.bdHTInfoBuf,
+			       pNetwork->bssht.bdHTInfoLen);
+
+		if (pHTInfo->bRegRT2RTAggregation) {
+			pHTInfo->bCurrentRT2RTAggregation =
+				 pNetwork->bssht.bdRT2RTAggregation;
+			pHTInfo->bCurrentRT2RTLongSlotTime =
+				 pNetwork->bssht.bdRT2RTLongSlotTime;
 			pHTInfo->RT2RT_HT_Mode = pNetwork->bssht.RT2RT_HT_Mode;
-		}
-		else
-		{
+		} else {
 			pHTInfo->bCurrentRT2RTAggregation = false;
 			pHTInfo->bCurrentRT2RTLongSlotTime = false;
 			pHTInfo->RT2RT_HT_Mode = (enum rt_ht_capability)0;
@@ -1057,7 +1069,7 @@ void HTResetSelfAndSavePeerSetting(struct rtllib_device* ieee,	struct rtllib_net
 		if (bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_EDCA_TURBO;
 
-		bIOTAction = HTIOTActIsMgntUseCCK6M(ieee,pNetwork);
+		bIOTAction = HTIOTActIsMgntUseCCK6M(ieee, pNetwork);
 		if (bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_MGNT_USE_CCK_6M;
 		bIOTAction = HTIOTActIsCCDFsync(ieee);
@@ -1072,23 +1084,22 @@ void HTResetSelfAndSavePeerSetting(struct rtllib_device* ieee,	struct rtllib_net
 		pHTInfo->IOTAction = 0;
 		pHTInfo->IOTRaFunc = 0;
 	}
-
 }
 
-void HTUpdateSelfAndPeerSetting(struct rtllib_device* ieee,	struct rtllib_network * pNetwork)
+void HTUpdateSelfAndPeerSetting(struct rtllib_device *ieee,
+				struct rtllib_network *pNetwork)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
-	struct ht_info_ele *pPeerHTInfo = (struct ht_info_ele *)pNetwork->bssht.bdHTInfoBuf;
+	struct ht_info_ele *pPeerHTInfo =
+		 (struct ht_info_ele *)pNetwork->bssht.bdHTInfoBuf;
 
-	if (pHTInfo->bCurrentHTSupport)
-	{
+	if (pHTInfo->bCurrentHTSupport) {
 		if (pNetwork->bssht.bdHTInfoLen != 0)
 			pHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;
-
 	}
 }
 
-void HTUseDefaultSetting(struct rtllib_device* ieee)
+void HTUseDefaultSetting(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
@@ -1097,14 +1108,13 @@ void HTUseDefaultSetting(struct rtllib_device* ieee)
 		pHTInfo->bCurSuppCCK = pHTInfo->bRegSuppCCK;
 
 		pHTInfo->bCurBW40MHz = pHTInfo->bRegBW40MHz;
-		pHTInfo->bCurShortGI20MHz= pHTInfo->bRegShortGI20MHz;
+		pHTInfo->bCurShortGI20MHz = pHTInfo->bRegShortGI20MHz;
 
-		pHTInfo->bCurShortGI40MHz= pHTInfo->bRegShortGI40MHz;
+		pHTInfo->bCurShortGI40MHz = pHTInfo->bRegShortGI40MHz;
 
 		if (ieee->iw_mode == IW_MODE_ADHOC)
-		{
-			ieee->current_network.qos_data.active = ieee->current_network.qos_data.supported;
-		}
+			ieee->current_network.qos_data.active =
+				 ieee->current_network.qos_data.supported;
 		pHTInfo->bCurrent_AMSDU_Support = pHTInfo->bAMSDU_Support;
 		pHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;
 
@@ -1113,9 +1123,11 @@ void HTUseDefaultSetting(struct rtllib_device* ieee)
 
 		pHTInfo->CurrentMPDUDensity = pHTInfo->CurrentMPDUDensity;
 
-
-		HTFilterMCSRate(ieee, ieee->Regdot11TxHTOperationalRateSet, ieee->dot11HTOperationalRateSet);
-		ieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee, ieee->dot11HTOperationalRateSet, MCS_FILTER_ALL);
+		HTFilterMCSRate(ieee, ieee->Regdot11TxHTOperationalRateSet,
+				ieee->dot11HTOperationalRateSet);
+		ieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee,
+					   ieee->dot11HTOperationalRateSet,
+					   MCS_FILTER_ALL);
 		ieee->HTCurrentOperaRate = ieee->HTHighestOperaRate;
 
 	} else {
@@ -1124,20 +1136,49 @@ void HTUseDefaultSetting(struct rtllib_device* ieee)
 	return;
 }
 
-u8 HTCCheck(struct rtllib_device* ieee, u8*	pFrame)
+u8 HTCCheck(struct rtllib_device *ieee, u8 *pFrame)
 {
-	if (ieee->pHTInfo->bCurrentHTSupport)
-	{
-		if ( (IsQoSDataFrame(pFrame) && Frame_Order(pFrame)) == 1)
-		{
-			RTLLIB_DEBUG(RTLLIB_DL_HT, "HT CONTROL FILED EXIST!!\n");
+	if (ieee->pHTInfo->bCurrentHTSupport) {
+		if ((IsQoSDataFrame(pFrame) && Frame_Order(pFrame)) == 1) {
+			RTLLIB_DEBUG(RTLLIB_DL_HT, "HT CONTROL FILED "
+				     "EXIST!!\n");
 			return true;
 		}
 	}
 	return false;
 }
 
-void HTSetConnectBwMode(struct rtllib_device* ieee, enum ht_channel_width Bandwidth, enum ht_extchnl_offset Offset)
+void HTSetConnectBwModeCallback(struct rtllib_device *ieee)
+{
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
+
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "======>%s()\n", __func__);
+	if (pHTInfo->bCurBW40MHz) {
+		if (pHTInfo->CurSTAExtChnlOffset == HT_EXTCHNL_OFFSET_UPPER)
+			ieee->set_chan(ieee->dev,
+				       ieee->current_network.channel + 2);
+		else if (pHTInfo->CurSTAExtChnlOffset ==
+			 HT_EXTCHNL_OFFSET_LOWER)
+			ieee->set_chan(ieee->dev,
+				       ieee->current_network.channel - 2);
+		else
+			ieee->set_chan(ieee->dev,
+				       ieee->current_network.channel);
+
+		ieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20_40,
+				       pHTInfo->CurSTAExtChnlOffset);
+	} else {
+		ieee->set_chan(ieee->dev, ieee->current_network.channel);
+		ieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20,
+				       HT_EXTCHNL_OFFSET_NO_EXT);
+	}
+
+	pHTInfo->bSwBwInProgress = false;
+}
+
+void HTSetConnectBwMode(struct rtllib_device *ieee,
+			enum ht_channel_width Bandwidth,
+			enum ht_extchnl_offset Offset)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
@@ -1145,18 +1186,18 @@ void HTSetConnectBwMode(struct rtllib_device* ieee, enum ht_channel_width Bandwi
 		return;
 
 	if (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
-		Bandwidth=HT_CHANNEL_WIDTH_20;
-
+		Bandwidth = HT_CHANNEL_WIDTH_20;
 
 	if (pHTInfo->bSwBwInProgress) {
-		printk("%s: bSwBwInProgress!!\n", __func__);
+		printk(KERN_INFO "%s: bSwBwInProgress!!\n", __func__);
 		return;
 	}
-	if (Bandwidth==HT_CHANNEL_WIDTH_20_40)
-	 {
-		if (ieee->current_network.channel<2 && Offset==HT_EXTCHNL_OFFSET_LOWER)
+	if (Bandwidth == HT_CHANNEL_WIDTH_20_40) {
+		if (ieee->current_network.channel < 2 &&
+		    Offset == HT_EXTCHNL_OFFSET_LOWER)
 			Offset = HT_EXTCHNL_OFFSET_NO_EXT;
-		if (Offset==HT_EXTCHNL_OFFSET_UPPER || Offset==HT_EXTCHNL_OFFSET_LOWER) {
+		if (Offset == HT_EXTCHNL_OFFSET_UPPER ||
+		    Offset == HT_EXTCHNL_OFFSET_LOWER) {
 			pHTInfo->bCurBW40MHz = true;
 			pHTInfo->CurSTAExtChnlOffset = Offset;
 		} else {
@@ -1168,33 +1209,10 @@ void HTSetConnectBwMode(struct rtllib_device* ieee, enum ht_channel_width Bandwi
 		pHTInfo->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;
 	}
 
-	printk("%s():pHTInfo->bCurBW40MHz:%x\n", __func__, pHTInfo->bCurBW40MHz);
+	printk(KERN_INFO "%s():pHTInfo->bCurBW40MHz:%x\n", __func__,
+	       pHTInfo->bCurBW40MHz);
 
 	pHTInfo->bSwBwInProgress = true;
 
 	HTSetConnectBwModeCallback(ieee);
-
-}
-
-void HTSetConnectBwModeCallback(struct rtllib_device* ieee)
-{
-	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
-
-	RTLLIB_DEBUG(RTLLIB_DL_HT, "======>%s()\n", __func__);
-	if (pHTInfo->bCurBW40MHz)
-	{
-		if (pHTInfo->CurSTAExtChnlOffset==HT_EXTCHNL_OFFSET_UPPER)
-			ieee->set_chan(ieee->dev, ieee->current_network.channel+2);
-		else if (pHTInfo->CurSTAExtChnlOffset==HT_EXTCHNL_OFFSET_LOWER)
-			ieee->set_chan(ieee->dev, ieee->current_network.channel-2);
-		else
-			ieee->set_chan(ieee->dev, ieee->current_network.channel);
-
-		ieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20_40, pHTInfo->CurSTAExtChnlOffset);
-	} else {
-		ieee->set_chan(ieee->dev, ieee->current_network.channel);
-		ieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
-	}
-
-	pHTInfo->bSwBwInProgress = false;
 }

commit bb9a7b3f239c0a7ab9b05690b8fa7df8eba16dfe
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 19 19:22:37 2011 -0500

    staging: rtl8192e: Convert typedef RT_HT_CAPBILITY to enum rt_ht_capability
    
    Remove typedef from enum.
    Rename enum.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index ed7a6b44591c..825b90805b4b 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -977,7 +977,7 @@ void HTInitializeHTInfo(struct rtllib_device* ieee)
 
 	pHTInfo->bCurrentRT2RTAggregation = false;
 	pHTInfo->bCurrentRT2RTLongSlotTime = false;
-	pHTInfo->RT2RT_HT_Mode = (RT_HT_CAPBILITY)0;
+	pHTInfo->RT2RT_HT_Mode = (enum rt_ht_capability)0;
 
 	pHTInfo->IOTPeer = 0;
 	pHTInfo->IOTAction = 0;
@@ -1003,7 +1003,7 @@ void HTInitializeBssDesc(struct bss_ht *pBssHT)
 
 	pBssHT->bdRT2RTAggregation = false;
 	pBssHT->bdRT2RTLongSlotTime = false;
-	pBssHT->RT2RT_HT_Mode = (RT_HT_CAPBILITY)0;
+	pBssHT->RT2RT_HT_Mode = (enum rt_ht_capability)0;
 }
 
 void HTResetSelfAndSavePeerSetting(struct rtllib_device* ieee,	struct rtllib_network * pNetwork)
@@ -1034,7 +1034,7 @@ void HTResetSelfAndSavePeerSetting(struct rtllib_device* ieee,	struct rtllib_net
 		{
 			pHTInfo->bCurrentRT2RTAggregation = false;
 			pHTInfo->bCurrentRT2RTLongSlotTime = false;
-			pHTInfo->RT2RT_HT_Mode = (RT_HT_CAPBILITY)0;
+			pHTInfo->RT2RT_HT_Mode = (enum rt_ht_capability)0;
 		}
 
 		HTIOTPeerDetermine(ieee);
@@ -1067,7 +1067,7 @@ void HTResetSelfAndSavePeerSetting(struct rtllib_device* ieee,	struct rtllib_net
 		pHTInfo->bCurrentHTSupport = false;
 		pHTInfo->bCurrentRT2RTAggregation = false;
 		pHTInfo->bCurrentRT2RTLongSlotTime = false;
-		pHTInfo->RT2RT_HT_Mode = (RT_HT_CAPBILITY)0;
+		pHTInfo->RT2RT_HT_Mode = (enum rt_ht_capability)0;
 
 		pHTInfo->IOTAction = 0;
 		pHTInfo->IOTRaFunc = 0;

commit b678bd1ff579f9e6233911fe5ce5fce31c5242e0
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 19 18:22:07 2011 -0500

    staging: rtl8192e: Convert typedef HT_EXTCHNL_OFFSET to enum ht_extchnl_offset
    
    Remove typedef from enum.
    Rename enum.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 2f6c223c79ba..ed7a6b44591c 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -831,7 +831,7 @@ u8 HTFilterMCSRate( struct rtllib_device* ieee, u8* pSupportMCS, u8* pOperateMCS
 
 	return true;
 }
-void HTSetConnectBwMode(struct rtllib_device* ieee, enum ht_channel_width Bandwidth, HT_EXTCHNL_OFFSET	Offset);
+void HTSetConnectBwMode(struct rtllib_device* ieee, enum ht_channel_width Bandwidth, enum ht_extchnl_offset Offset);
 void HTOnAssocRsp(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
@@ -861,7 +861,7 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 		pPeerHTInfo = (struct ht_info_ele *)(pHTInfo->PeerHTInfoBuf);
 
 	RTLLIB_DEBUG_DATA(RTLLIB_DL_DATA|RTLLIB_DL_HT, pPeerHTCap, sizeof(struct ht_capab_ele));
-	HTSetConnectBwMode(ieee, (enum ht_channel_width)(pPeerHTCap->ChlWidth), (HT_EXTCHNL_OFFSET)(pPeerHTInfo->ExtChlOffset));
+	HTSetConnectBwMode(ieee, (enum ht_channel_width)(pPeerHTCap->ChlWidth), (enum ht_extchnl_offset)(pPeerHTInfo->ExtChlOffset));
 	pHTInfo->bCurTxBW40MHz = ((pPeerHTInfo->RecommemdedTxWidth == 1)?true:false);
 
 	pHTInfo->bCurShortGI20MHz=
@@ -1137,7 +1137,7 @@ u8 HTCCheck(struct rtllib_device* ieee, u8*	pFrame)
 	return false;
 }
 
-void HTSetConnectBwMode(struct rtllib_device* ieee, enum ht_channel_width Bandwidth, HT_EXTCHNL_OFFSET	Offset)
+void HTSetConnectBwMode(struct rtllib_device* ieee, enum ht_channel_width Bandwidth, enum ht_extchnl_offset Offset)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 

commit 6e579119b104967e91e506de2c7ac7ec1ac4d213
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Jul 19 18:20:30 2011 -0500

    staging: rtl8192e: Convert typedef HT_CHANNEL_WIDTH to enum ht_channel_width
    
    Remove typedef from enum.
    Rename enum.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 10cce89b10e6..2f6c223c79ba 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -831,7 +831,7 @@ u8 HTFilterMCSRate( struct rtllib_device* ieee, u8* pSupportMCS, u8* pOperateMCS
 
 	return true;
 }
-void HTSetConnectBwMode(struct rtllib_device* ieee, HT_CHANNEL_WIDTH	Bandwidth, HT_EXTCHNL_OFFSET	Offset);
+void HTSetConnectBwMode(struct rtllib_device* ieee, enum ht_channel_width Bandwidth, HT_EXTCHNL_OFFSET	Offset);
 void HTOnAssocRsp(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
@@ -861,7 +861,7 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 		pPeerHTInfo = (struct ht_info_ele *)(pHTInfo->PeerHTInfoBuf);
 
 	RTLLIB_DEBUG_DATA(RTLLIB_DL_DATA|RTLLIB_DL_HT, pPeerHTCap, sizeof(struct ht_capab_ele));
-	HTSetConnectBwMode(ieee, (HT_CHANNEL_WIDTH)(pPeerHTCap->ChlWidth), (HT_EXTCHNL_OFFSET)(pPeerHTInfo->ExtChlOffset));
+	HTSetConnectBwMode(ieee, (enum ht_channel_width)(pPeerHTCap->ChlWidth), (HT_EXTCHNL_OFFSET)(pPeerHTInfo->ExtChlOffset));
 	pHTInfo->bCurTxBW40MHz = ((pPeerHTInfo->RecommemdedTxWidth == 1)?true:false);
 
 	pHTInfo->bCurShortGI20MHz=
@@ -1137,7 +1137,7 @@ u8 HTCCheck(struct rtllib_device* ieee, u8*	pFrame)
 	return false;
 }
 
-void HTSetConnectBwMode(struct rtllib_device* ieee, HT_CHANNEL_WIDTH	Bandwidth, HT_EXTCHNL_OFFSET	Offset)
+void HTSetConnectBwMode(struct rtllib_device* ieee, enum ht_channel_width Bandwidth, HT_EXTCHNL_OFFSET	Offset)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 

commit e92b71d571dfc08ae0ac792ffa463c0a601c32a5
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 20:34:19 2011 -0500

    staging: rtl8192e: Convert typedef HT_CAPABILITY_ELE to struct ht_capab_ele
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 3ac689171819..10cce89b10e6 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -98,14 +98,14 @@ void HTDebugHTCapability(u8* CapIE, u8* TitleString )
 {
 
 	static u8	EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};
-	PHT_CAPABILITY_ELE		pCapELE;
+	struct ht_capab_ele *pCapELE;
 
 	if (!memcmp(CapIE, EWC11NHTCap, sizeof(EWC11NHTCap)))
 	{
 		RTLLIB_DEBUG(RTLLIB_DL_HT, "EWC IE in %s()\n", __func__);
-		pCapELE = (PHT_CAPABILITY_ELE)(&CapIE[4]);
+		pCapELE = (struct ht_capab_ele *)(&CapIE[4]);
 	}else
-		pCapELE = (PHT_CAPABILITY_ELE)(&CapIE[0]);
+		pCapELE = (struct ht_capab_ele *)(&CapIE[0]);
 
 	RTLLIB_DEBUG(RTLLIB_DL_HT, "<Log HT Capability>. Called by %s\n", TitleString );
 
@@ -190,7 +190,7 @@ bool IsHTHalfNmode40Bandwidth(struct rtllib_device* ieee)
 		retValue = false;
 	else if (!ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
 		retValue = false;
-	else if (((PHT_CAPABILITY_ELE)(pHTInfo->PeerHTCapBuf))->ChlWidth)
+	else if (((struct ht_capab_ele *)(pHTInfo->PeerHTCapBuf))->ChlWidth)
 		retValue = true;
 	else
 		retValue = false;
@@ -209,14 +209,14 @@ bool IsHTHalfNmodeSGI(struct rtllib_device* ieee, bool is40MHz)
 		retValue = false;
 	else if (is40MHz)
 	{
-		if (((PHT_CAPABILITY_ELE)(pHTInfo->PeerHTCapBuf))->ShortGI40Mhz)
+		if (((struct ht_capab_ele *)(pHTInfo->PeerHTCapBuf))->ShortGI40Mhz)
 			retValue = true;
 		else
 			retValue = false;
 	}
 	else
 	{
-		if (((PHT_CAPABILITY_ELE)(pHTInfo->PeerHTCapBuf))->ShortGI20Mhz)
+		if (((struct ht_capab_ele *)(pHTInfo->PeerHTCapBuf))->ShortGI20Mhz)
 			retValue = true;
 		else
 			retValue = false;
@@ -585,7 +585,7 @@ void HTResetIOTSetting(
 void HTConstructCapabilityElement(struct rtllib_device* ieee, u8* posHTCap, u8* len, u8 IsEncrypt, bool bAssoc)
 {
 	struct rt_hi_throughput *pHT = ieee->pHTInfo;
-	PHT_CAPABILITY_ELE	pCapELE = NULL;
+	struct ht_capab_ele *pCapELE = NULL;
 
 	if ((posHTCap == NULL) || (pHT == NULL))
 	{
@@ -598,11 +598,11 @@ void HTConstructCapabilityElement(struct rtllib_device* ieee, u8* posHTCap, u8*
 	{
 		u8	EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};
 		memcpy(posHTCap, EWC11NHTCap, sizeof(EWC11NHTCap));
-		pCapELE = (PHT_CAPABILITY_ELE)&(posHTCap[4]);
+		pCapELE = (struct ht_capab_ele *)&(posHTCap[4]);
 		*len = 30 + 2;
 	}else
 	{
-		pCapELE = (PHT_CAPABILITY_ELE)posHTCap;
+		pCapELE = (struct ht_capab_ele *)posHTCap;
 		*len = 26 + 2;
 	}
 
@@ -835,7 +835,7 @@ void HTSetConnectBwMode(struct rtllib_device* ieee, HT_CHANNEL_WIDTH	Bandwidth,
 void HTOnAssocRsp(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
-	PHT_CAPABILITY_ELE		pPeerHTCap = NULL;
+	struct ht_capab_ele *pPeerHTCap = NULL;
 	struct ht_info_ele *pPeerHTInfo = NULL;
 	u16	nMaxAMSDUSize = 0;
 	u8*	pMcsFilter = NULL;
@@ -851,16 +851,16 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 	RTLLIB_DEBUG(RTLLIB_DL_HT, "===> HTOnAssocRsp_wq(): HT_ENABLE\n");
 
 	if (!memcmp(pHTInfo->PeerHTCapBuf,EWC11NHTCap, sizeof(EWC11NHTCap)))
-		pPeerHTCap = (PHT_CAPABILITY_ELE)(&pHTInfo->PeerHTCapBuf[4]);
+		pPeerHTCap = (struct ht_capab_ele *)(&pHTInfo->PeerHTCapBuf[4]);
 	else
-		pPeerHTCap = (PHT_CAPABILITY_ELE)(pHTInfo->PeerHTCapBuf);
+		pPeerHTCap = (struct ht_capab_ele *)(pHTInfo->PeerHTCapBuf);
 
 	if (!memcmp(pHTInfo->PeerHTInfoBuf, EWC11NHTInfo, sizeof(EWC11NHTInfo)))
 		pPeerHTInfo = (struct ht_info_ele *)(&pHTInfo->PeerHTInfoBuf[4]);
 	else
 		pPeerHTInfo = (struct ht_info_ele *)(pHTInfo->PeerHTInfoBuf);
 
-	RTLLIB_DEBUG_DATA(RTLLIB_DL_DATA|RTLLIB_DL_HT, pPeerHTCap, sizeof(HT_CAPABILITY_ELE));
+	RTLLIB_DEBUG_DATA(RTLLIB_DL_DATA|RTLLIB_DL_HT, pPeerHTCap, sizeof(struct ht_capab_ele));
 	HTSetConnectBwMode(ieee, (HT_CHANNEL_WIDTH)(pPeerHTCap->ChlWidth), (HT_EXTCHNL_OFFSET)(pPeerHTInfo->ExtChlOffset));
 	pHTInfo->bCurTxBW40MHz = ((pPeerHTInfo->RecommemdedTxWidth == 1)?true:false);
 

commit 407e998e593d379a30e32e71d10e4f589404d0f2
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 20:31:44 2011 -0500

    staging: rtl8192e: Convert typedef HT_INFORMATION_ELE to struct ht_info_ele
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index c319ad5c1bda..3ac689171819 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -126,14 +126,14 @@ void HTDebugHTInfo(u8*	InfoIE, u8* TitleString)
 {
 
 	static u8	EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};
-	PHT_INFORMATION_ELE		pHTInfoEle;
+	struct ht_info_ele *pHTInfoEle;
 
 	if (!memcmp(InfoIE, EWC11NHTInfo, sizeof(EWC11NHTInfo)))
 	{
 		RTLLIB_DEBUG(RTLLIB_DL_HT, "EWC IE in %s()\n", __func__);
-		pHTInfoEle = (PHT_INFORMATION_ELE)(&InfoIE[4]);
+		pHTInfoEle = (struct ht_info_ele *)(&InfoIE[4]);
 	}else
-		pHTInfoEle = (PHT_INFORMATION_ELE)(&InfoIE[0]);
+		pHTInfoEle = (struct ht_info_ele *)(&InfoIE[0]);
 
 
 	RTLLIB_DEBUG(RTLLIB_DL_HT, "<Log HT Information Element>. Called by %s\n", TitleString);
@@ -676,7 +676,7 @@ void HTConstructCapabilityElement(struct rtllib_device* ieee, u8* posHTCap, u8*
 void HTConstructInfoElement(struct rtllib_device* ieee, u8* posHTInfo, u8* len, u8 IsEncrypt)
 {
 	struct rt_hi_throughput *pHT = ieee->pHTInfo;
-	PHT_INFORMATION_ELE		pHTInfoEle = (PHT_INFORMATION_ELE)posHTInfo;
+	struct ht_info_ele *pHTInfoEle = (struct ht_info_ele *)posHTInfo;
 	if ((posHTInfo == NULL) || (pHTInfoEle == NULL))
 	{
 		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posHTInfo or pHTInfoEle can't be null in HTConstructInfoElement()\n");
@@ -836,7 +836,7 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	PHT_CAPABILITY_ELE		pPeerHTCap = NULL;
-	PHT_INFORMATION_ELE		pPeerHTInfo = NULL;
+	struct ht_info_ele *pPeerHTInfo = NULL;
 	u16	nMaxAMSDUSize = 0;
 	u8*	pMcsFilter = NULL;
 
@@ -856,9 +856,9 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 		pPeerHTCap = (PHT_CAPABILITY_ELE)(pHTInfo->PeerHTCapBuf);
 
 	if (!memcmp(pHTInfo->PeerHTInfoBuf, EWC11NHTInfo, sizeof(EWC11NHTInfo)))
-		pPeerHTInfo = (PHT_INFORMATION_ELE)(&pHTInfo->PeerHTInfoBuf[4]);
+		pPeerHTInfo = (struct ht_info_ele *)(&pHTInfo->PeerHTInfoBuf[4]);
 	else
-		pPeerHTInfo = (PHT_INFORMATION_ELE)(pHTInfo->PeerHTInfoBuf);
+		pPeerHTInfo = (struct ht_info_ele *)(pHTInfo->PeerHTInfoBuf);
 
 	RTLLIB_DEBUG_DATA(RTLLIB_DL_DATA|RTLLIB_DL_HT, pPeerHTCap, sizeof(HT_CAPABILITY_ELE));
 	HTSetConnectBwMode(ieee, (HT_CHANNEL_WIDTH)(pPeerHTCap->ChlWidth), (HT_EXTCHNL_OFFSET)(pPeerHTInfo->ExtChlOffset));
@@ -1078,7 +1078,7 @@ void HTResetSelfAndSavePeerSetting(struct rtllib_device* ieee,	struct rtllib_net
 void HTUpdateSelfAndPeerSetting(struct rtllib_device* ieee,	struct rtllib_network * pNetwork)
 {
 	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
-	PHT_INFORMATION_ELE		pPeerHTInfo = (PHT_INFORMATION_ELE)pNetwork->bssht.bdHTInfoBuf;
+	struct ht_info_ele *pPeerHTInfo = (struct ht_info_ele *)pNetwork->bssht.bdHTInfoBuf;
 
 	if (pHTInfo->bCurrentHTSupport)
 	{

commit a15e76ad063248ec1d06baee423881e7aa73066b
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 20:26:49 2011 -0500

    staging: rtl8192e: Convert typedef BSS_HT to struct bss_ht
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 94ec155c7ba4..c319ad5c1bda 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -990,7 +990,7 @@ void HTInitializeHTInfo(struct rtllib_device* ieee)
 		RegHTSuppRateSets[4] = 0x01;
 	}
 }
-void HTInitializeBssDesc(PBSS_HT pBssHT)
+void HTInitializeBssDesc(struct bss_ht *pBssHT)
 {
 
 	pBssHT->bdSupportHT = false;

commit 7796d93eae46054d5a3bb5411fde735801998dc5
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 18 20:22:19 2011 -0500

    staging: rtl8192e: Convert typedef RT_HIGH_THROUGHPUT to struct rt_hi_throughput
    
    Remove typedef from struct.
    Rename struct.
    Rename uses.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index a457e302abc2..94ec155c7ba4 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -59,7 +59,7 @@ static u8 CISCO_BROADCOM[3] = {0x00, 0x17, 0x94};
 static u8 LINKSYS_MARVELL_4400N[3] = {0x00, 0x14, 0xa4};
 void HTUpdateDefaultSetting(struct rtllib_device* ieee)
 {
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	pHTInfo->bAcceptAddbaReq = 1;
 
@@ -182,7 +182,7 @@ void HTDebugHTInfo(u8*	InfoIE, u8* TitleString)
 bool IsHTHalfNmode40Bandwidth(struct rtllib_device* ieee)
 {
 	bool			retValue = false;
-	PRT_HIGH_THROUGHPUT	 pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	if (pHTInfo->bCurrentHTSupport == false )
 		retValue = false;
@@ -201,7 +201,7 @@ bool IsHTHalfNmode40Bandwidth(struct rtllib_device* ieee)
 bool IsHTHalfNmodeSGI(struct rtllib_device* ieee, bool is40MHz)
 {
 	bool			retValue = false;
-	PRT_HIGH_THROUGHPUT	 pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	if (pHTInfo->bCurrentHTSupport == false )
 		retValue = false;
@@ -240,7 +240,7 @@ u16 HTHalfMcsToDataRate(struct rtllib_device* ieee,	u8	nMcsRate)
 
 u16 HTMcsToDataRate( struct rtllib_device* ieee, u8 nMcsRate)
 {
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	u8	is40MHz = (pHTInfo->bCurBW40MHz)?1:0;
 	u8	isShortGI = (pHTInfo->bCurBW40MHz)?
@@ -318,7 +318,7 @@ bool IsHTHalfNmodeAPs(struct rtllib_device* ieee)
 
 void HTIOTPeerDetermine(struct rtllib_device* ieee)
 {
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	struct rtllib_network* net = &ieee->current_network;
 	if (net->bssht.bdRT2RTAggregation){
 		pHTInfo->IOTPeer = HT_IOT_PEER_REALTEK;
@@ -409,7 +409,7 @@ u8 HTIOTActIsMgntUseCCK6M(struct rtllib_device* ieee,struct rtllib_network *netw
 u8
 HTIOTActWAIOTBroadcom(struct rtllib_device* ieee)
 {
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	u8		retValue = false;
 	u8		boundary=59;
 
@@ -494,7 +494,7 @@ u8
 HTIOTActDisableShortGI(struct rtllib_device* ieee,struct rtllib_network *network)
 {
 	u8	retValue = 0;
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	if (pHTInfo->IOTPeer==HT_IOT_PEER_RALINK)
 	{
@@ -515,7 +515,7 @@ HTIOTActDisableHighPower(struct rtllib_device* ieee,struct rtllib_network *netwo
 void
 HTIOTActDetermineRaFunc(struct rtllib_device* ieee,	bool	bPeerRx2ss)
 {
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	pHTInfo->IOTRaFunc &= HT_IOT_RAFUNC_DISABLE_ALL;
 
 	if (pHTInfo->IOTPeer == HT_IOT_PEER_RALINK && !bPeerRx2ss)
@@ -573,7 +573,7 @@ HTIOTActIsNullDataPowerSaving(struct rtllib_device* ieee,struct rtllib_network *
 }
 
 void HTResetIOTSetting(
-	PRT_HIGH_THROUGHPUT		pHTInfo
+	struct rt_hi_throughput *pHTInfo
 )
 {
 	pHTInfo->IOTAction = 0;
@@ -584,7 +584,7 @@ void HTResetIOTSetting(
 
 void HTConstructCapabilityElement(struct rtllib_device* ieee, u8* posHTCap, u8* len, u8 IsEncrypt, bool bAssoc)
 {
-	PRT_HIGH_THROUGHPUT	pHT = ieee->pHTInfo;
+	struct rt_hi_throughput *pHT = ieee->pHTInfo;
 	PHT_CAPABILITY_ELE	pCapELE = NULL;
 
 	if ((posHTCap == NULL) || (pHT == NULL))
@@ -675,7 +675,7 @@ void HTConstructCapabilityElement(struct rtllib_device* ieee, u8* posHTCap, u8*
 }
 void HTConstructInfoElement(struct rtllib_device* ieee, u8* posHTInfo, u8* len, u8 IsEncrypt)
 {
-	PRT_HIGH_THROUGHPUT	pHT = ieee->pHTInfo;
+	struct rt_hi_throughput *pHT = ieee->pHTInfo;
 	PHT_INFORMATION_ELE		pHTInfoEle = (PHT_INFORMATION_ELE)posHTInfo;
 	if ((posHTInfo == NULL) || (pHTInfoEle == NULL))
 	{
@@ -834,7 +834,7 @@ u8 HTFilterMCSRate( struct rtllib_device* ieee, u8* pSupportMCS, u8* pOperateMCS
 void HTSetConnectBwMode(struct rtllib_device* ieee, HT_CHANNEL_WIDTH	Bandwidth, HT_EXTCHNL_OFFSET	Offset);
 void HTOnAssocRsp(struct rtllib_device *ieee)
 {
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	PHT_CAPABILITY_ELE		pPeerHTCap = NULL;
 	PHT_INFORMATION_ELE		pPeerHTInfo = NULL;
 	u16	nMaxAMSDUSize = 0;
@@ -946,7 +946,7 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 void HTSetConnectBwModeCallback(struct rtllib_device* ieee);
 void HTInitializeHTInfo(struct rtllib_device* ieee)
 {
-	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	RTLLIB_DEBUG(RTLLIB_DL_HT, "===========>%s()\n", __func__);
 	pHTInfo->bCurrentHTSupport = false;
@@ -1008,7 +1008,7 @@ void HTInitializeBssDesc(PBSS_HT pBssHT)
 
 void HTResetSelfAndSavePeerSetting(struct rtllib_device* ieee,	struct rtllib_network * pNetwork)
 {
-	PRT_HIGH_THROUGHPUT		pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	u8	bIOTAction = 0;
 
 	RTLLIB_DEBUG(RTLLIB_DL_HT, "==============>%s()\n", __func__);
@@ -1077,7 +1077,7 @@ void HTResetSelfAndSavePeerSetting(struct rtllib_device* ieee,	struct rtllib_net
 
 void HTUpdateSelfAndPeerSetting(struct rtllib_device* ieee,	struct rtllib_network * pNetwork)
 {
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 	PHT_INFORMATION_ELE		pPeerHTInfo = (PHT_INFORMATION_ELE)pNetwork->bssht.bdHTInfoBuf;
 
 	if (pHTInfo->bCurrentHTSupport)
@@ -1090,7 +1090,7 @@ void HTUpdateSelfAndPeerSetting(struct rtllib_device* ieee,	struct rtllib_networ
 
 void HTUseDefaultSetting(struct rtllib_device* ieee)
 {
-	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	if (pHTInfo->bEnableHT) {
 		pHTInfo->bCurrentHTSupport = true;
@@ -1139,7 +1139,7 @@ u8 HTCCheck(struct rtllib_device* ieee, u8*	pFrame)
 
 void HTSetConnectBwMode(struct rtllib_device* ieee, HT_CHANNEL_WIDTH	Bandwidth, HT_EXTCHNL_OFFSET	Offset)
 {
-	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	if (pHTInfo->bRegBW40MHz == false)
 		return;
@@ -1178,7 +1178,7 @@ void HTSetConnectBwMode(struct rtllib_device* ieee, HT_CHANNEL_WIDTH	Bandwidth,
 
 void HTSetConnectBwModeCallback(struct rtllib_device* ieee)
 {
-	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
+	struct rt_hi_throughput *pHTInfo = ieee->pHTInfo;
 
 	RTLLIB_DEBUG(RTLLIB_DL_HT, "======>%s()\n", __func__);
 	if (pHTInfo->bCurBW40MHz)

commit bfb74db3e58c6362d877b299e5b68c512fc500db
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Wed Jul 13 18:54:50 2011 -0500

    staging: rtl8192e: Remove dead code associated with USB_RX_AGGREGATION_SUPPORT
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index cb144610489e..a457e302abc2 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -93,15 +93,6 @@ void HTUpdateDefaultSetting(struct rtllib_device* ieee)
 	pHTInfo->bRegRxReorderEnable = 1;
 	pHTInfo->RxReorderWinSize = 64;
 	pHTInfo->RxReorderPendingTime = 30;
-
-#ifdef USB_RX_AGGREGATION_SUPPORT
-	pHTInfo->UsbRxFwAggrEn = 1;
-	pHTInfo->UsbRxFwAggrPageNum = 24;
-	pHTInfo->UsbRxFwAggrPacketNum = 8;
-	pHTInfo->UsbRxFwAggrTimeout = 8;
-#endif
-
-
 }
 void HTDebugHTCapability(u8* CapIE, u8* TitleString )
 {

commit bf474281e98171b7491a8b759491f400bd6b1863
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Wed Jul 13 09:43:35 2011 -0500

    staging: rtl8192e: Remove dead code associated with USB_TX_DRIVER_AGGREGATION_ENABLE
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 0f5410c2c160..cb144610489e 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -94,9 +94,6 @@ void HTUpdateDefaultSetting(struct rtllib_device* ieee)
 	pHTInfo->RxReorderWinSize = 64;
 	pHTInfo->RxReorderPendingTime = 30;
 
-#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
-	pHTInfo->UsbTxAggrNum = 4;
-#endif
 #ifdef USB_RX_AGGREGATION_SUPPORT
 	pHTInfo->UsbRxFwAggrEn = 1;
 	pHTInfo->UsbRxFwAggrPageNum = 24;

commit eb378025999a336e9d2730a66ac924f9b91ed118
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 11 22:52:12 2011 -0500

    staging: rtl8192e: Remove dead code associated with RTL8192U
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 8bb51e215ded..0f5410c2c160 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -382,33 +382,12 @@ bool HTIOTActIsDisableMCS15(struct rtllib_device* ieee)
 {
 	bool retValue = false;
 
-#if defined(RTL8192U)
-	if (ieee->current_network.bssht.bdBandWidth == HT_CHANNEL_WIDTH_20_40)
-	retValue = true;
-	else
-		retValue = false;
-#endif
-
-
 	return retValue;
 }
 
 bool HTIOTActIsDisableMCSTwoSpatialStream(struct rtllib_device* ieee)
 {
 	bool retValue = false;
-#ifdef RTL8192U
-	struct rtllib_network* net = &ieee->current_network;
-
-	if ((ieee->pHTInfo->bCurrentHTSupport == true) && (ieee->pairwise_key_type == KEY_TYPE_CCMP))
-	{
-		if ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3)==0) ||
-				(memcmp(net->bssid, PCI_RALINK, 3)==0) ||
-				(memcmp(net->bssid, EDIMAX_RALINK, 3)==0))
-		{
-			retValue = false;
-		}
-	}
-#endif
 	return retValue;
 }
 

commit 8df91dae5d258ad72a666af32d54e20e29ead6fb
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 11 22:43:02 2011 -0500

    staging: rtl8192e: Remove dead code associated with RTL8192SU
    
    The vendor code will generate several different drivers.  Eliminate
    code used to generate code for the RTL8192SU devices.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 0e7f078c05c3..8bb51e215ded 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -56,9 +56,6 @@ static u8 AIRLINK_RALINK[3] = {0x00, 0x18, 0x02};
 static u8 DLINK_ATHEROS_1[3] = {0x00, 0x1c, 0xf0};
 static u8 DLINK_ATHEROS_2[3] = {0x00, 0x21, 0x91};
 static u8 CISCO_BROADCOM[3] = {0x00, 0x17, 0x94};
-#if defined(RTL8192SU)
-static u8 NETGEAR_BROADCOM[3] = {0x00, 0x1f, 0x33};
-#endif
 static u8 LINKSYS_MARVELL_4400N[3] = {0x00, 0x14, 0xa4};
 void HTUpdateDefaultSetting(struct rtllib_device* ieee)
 {
@@ -101,19 +98,11 @@ void HTUpdateDefaultSetting(struct rtllib_device* ieee)
 	pHTInfo->UsbTxAggrNum = 4;
 #endif
 #ifdef USB_RX_AGGREGATION_SUPPORT
-#ifdef RTL8192SU
-	pHTInfo->UsbRxFwAggrEn = 1;
-	pHTInfo->UsbRxFwAggrPageNum = 48;
-	pHTInfo->UsbRxFwAggrPacketNum = 8;
-	pHTInfo->UsbRxFwAggrTimeout = 4;
-	pHTInfo->UsbRxPageSize= 128;
-#else
 	pHTInfo->UsbRxFwAggrEn = 1;
 	pHTInfo->UsbRxFwAggrPageNum = 24;
 	pHTInfo->UsbRxFwAggrPacketNum = 8;
 	pHTInfo->UsbRxFwAggrTimeout = 8;
 #endif
-#endif
 
 
 }
@@ -433,11 +422,6 @@ bool HTIOTActIsEnableBETxOPLimit(struct rtllib_device* ieee)
 {
 	bool	retValue = false;
 
-#if defined RTL8192SU
-	if (ieee->mode == IEEE_G)
-		retValue = true;
-#endif
-
 	return retValue;
 }
 
@@ -535,16 +519,7 @@ u8
   HTIOTActIsEDCABiasRx(struct rtllib_device* ieee,struct rtllib_network *network)
 {
 	u8	retValue = 0;
-#ifdef RTL8192SU
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-	{
-		if (pHTInfo->IOTPeer==HT_IOT_PEER_ATHEROS ||
-		   pHTInfo->IOTPeer==HT_IOT_PEER_BROADCOM ||
-		   pHTInfo->IOTPeer==HT_IOT_PEER_RALINK)
-			return 1;
 
-	}
-#endif
 	return retValue;
 }
 
@@ -567,14 +542,6 @@ HTIOTActDisableHighPower(struct rtllib_device* ieee,struct rtllib_network *netwo
 {
 	u8	retValue = 0;
 
-#ifdef RTL8192SU
-	if (pHTInfo->IOTPeer==HT_IOT_PEER_RALINK ||
-		pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK ||
-		pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK_92SE)
-	{
-			retValue = 1;
-	}
-#endif
 	return retValue;
 }
 
@@ -622,15 +589,6 @@ HTIOTActIsDisableTx2SS(struct rtllib_device* ieee,struct rtllib_network *network
 bool HTIOCActIsDisableCckRate(struct rtllib_device* ieee,struct rtllib_network *network)
 {
 	bool	retValue = false;
-#if defined(RTL8192SU)
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-	if (pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
-	{
-		if ((memcmp(network->bssid, NETGEAR_BROADCOM, 3)==0)
-			&& (network->bssht.bdBandWidth == HT_CHANNEL_WIDTH_20_40))
-			return true;
-	}
-#endif
 	return retValue;
 }
 

commit b355c1d0bceee3276b406327c6f1765c73901ab0
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 11 22:37:27 2011 -0500

    staging: rtl8192e: Remove dead code associated with RTL8192CE
    
    The vendor code will generate several different drivers. As the RTL8192CE
    is covered by a mac80211 driver in mainline, eliminate that code here.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 62dd0976e44f..0e7f078c05c3 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -64,10 +64,6 @@ void HTUpdateDefaultSetting(struct rtllib_device* ieee)
 {
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 
-#ifdef RTL8192CE
-	pHTInfo->bRDGEnable = 0;
-#endif
-
 	pHTInfo->bAcceptAddbaReq = 1;
 
 	pHTInfo->bRegShortGI20MHz= 1;
@@ -423,19 +419,6 @@ bool HTIOTActIsDisableMCSTwoSpatialStream(struct rtllib_device* ieee)
 			retValue = false;
 		}
 	}
-#endif
-#if defined(RTL8192SU) || defined RTL8192CE
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-	if (ieee->rtllib_ap_sec_type &&
-		(ieee->rtllib_ap_sec_type(ieee)&(SEC_ALG_WEP|SEC_ALG_TKIP)))
-	{
-		if ( (pHTInfo->IOTPeer != HT_IOT_PEER_ATHEROS) &&
-			(pHTInfo->IOTPeer != HT_IOT_PEER_UNKNOWN) &&
-			(pHTInfo->IOTPeer != HT_IOT_PEER_MARVELL) &&
-			(pHTInfo->IOTPeer != HT_IOT_PEER_REALTEK_92SE) &&
-			(pHTInfo->IOTPeer != HT_IOT_PEER_RALINK) )
-			retValue = true;
-	}
 #endif
 	return retValue;
 }
@@ -453,10 +436,6 @@ bool HTIOTActIsEnableBETxOPLimit(struct rtllib_device* ieee)
 #if defined RTL8192SU
 	if (ieee->mode == IEEE_G)
 		retValue = true;
-#elif defined RTL8192CE
-	if (ieee->mode == IEEE_G ||
-		(ieee->rtllib_ap_sec_type(ieee)&(SEC_ALG_WEP|SEC_ALG_TKIP)))
-		retValue = true;
 #endif
 
 	return retValue;
@@ -564,14 +543,6 @@ u8
 		   pHTInfo->IOTPeer==HT_IOT_PEER_RALINK)
 			return 1;
 
-	}
-#elif defined RTL8192CE
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-	{
-		if (pHTInfo->IOTPeer==HT_IOT_PEER_ATHEROS ||
-		   pHTInfo->IOTPeer==HT_IOT_PEER_RALINK)
-			return 1;
-
 	}
 #endif
 	return retValue;
@@ -832,11 +803,7 @@ void HTConstructRT2RTAggElement(struct rtllib_device* ieee, u8* posRT2RTAgg, u8*
 	*posRT2RTAgg++ = 0x02;
 	*posRT2RTAgg++ = 0x01;
 
-#ifdef RTL8192CE
-	*posRT2RTAgg = 0x70;
-#else
 	*posRT2RTAgg = 0x30;
-#endif
 
 	if (ieee->bSupportRemoteWakeUp) {
 		*posRT2RTAgg |= RT_HT_CAP_USE_WOW;

commit 1e71e6d0cf764841cdf60dec4a40849ff41be75c
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 11 22:25:07 2011 -0500

    staging: rtl8192e: Remove dead code associated with RTL8192SE
    
    The vendor code will generate several different drivers. As the RTL8192SE
    is covered by a mac80211 driver in mainline, eliminate that code heere.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index a212a972ec6f..62dd0976e44f 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -436,14 +436,6 @@ bool HTIOTActIsDisableMCSTwoSpatialStream(struct rtllib_device* ieee)
 			(pHTInfo->IOTPeer != HT_IOT_PEER_RALINK) )
 			retValue = true;
 	}
-#elif defined(RTL8192SE)
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-	if (ieee->rtllib_ap_sec_type &&
-		(ieee->rtllib_ap_sec_type(ieee)&SEC_ALG_TKIP)) {
-			if (pHTInfo->IOTPeer == HT_IOT_PEER_RALINK){
-				retValue = true;
-			}
-		}
 #endif
 	return retValue;
 }
@@ -519,11 +511,7 @@ HTIOTActWAIOTBroadcom(struct rtllib_device* ieee)
 u8 HTIOTActIsForcedCTS2Self(struct rtllib_device *ieee, struct rtllib_network *network)
 {
 	u8	retValue = 0;
-#if (defined RTL8192SE || defined RTL8192SU || defined RTL8192CE)
-	if ((ieee->pHTInfo->IOTPeer == HT_IOT_PEER_MARVELL) ||(ieee->pHTInfo->IOTPeer == HT_IOT_PEER_ATHEROS) )
-#else
 	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_MARVELL)
-#endif
 	{
 		retValue = 1;
 	}
@@ -534,17 +522,6 @@ u8 HTIOTActIsForcedCTS2Self(struct rtllib_device *ieee, struct rtllib_network *n
 u8 HTIOTActIsForcedRTSCTS(struct rtllib_device *ieee, struct rtllib_network *network)
 {
 	u8	retValue = 0;
-#if defined(RTL8192SE) || defined(RTL8192SU)
-	if (ieee->pHTInfo->bCurrentHTSupport)
-	{
-		if ((ieee->pHTInfo->IOTPeer != HT_IOT_PEER_REALTEK)&&
-		   (ieee->pHTInfo->IOTPeer != HT_IOT_PEER_REALTEK_92SE))
-	{
-			if ((ieee->pHTInfo->IOTAction & HT_IOT_ACT_TX_NO_AGGREGATION) == 0)
-				retValue = 1;
-		}
-	}
-#endif
 	return retValue;
 }
 
@@ -570,12 +547,6 @@ u8
 HTIOCActRejcectADDBARequest(struct rtllib_network *network)
 {
 	u8	retValue = 0;
-#if (defined RTL8192SE || defined RTL8192SU || defined RTL8192CE)
-	{
-
-
-	}
-#endif
 
 	return retValue;
 
@@ -601,16 +572,6 @@ u8
 		   pHTInfo->IOTPeer==HT_IOT_PEER_RALINK)
 			return 1;
 
-	}
-#elif defined RTL8192SE
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-	{
-            if (ieee->rtllib_ap_sec_type != NULL)
-                if (ieee->rtllib_ap_sec_type(ieee) == SEC_ALG_CCMP)
-                    if (pHTInfo->IOTPeer==HT_IOT_PEER_RALINK){
-                        return 1;
-                    }
-
 	}
 #endif
 	return retValue;
@@ -634,9 +595,6 @@ u8
 HTIOTActDisableHighPower(struct rtllib_device* ieee,struct rtllib_network *network)
 {
 	u8	retValue = 0;
-#if (defined RTL8192SE || defined RTL8192SU || defined RTL8192CE)
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-#endif
 
 #ifdef RTL8192SU
 	if (pHTInfo->IOTPeer==HT_IOT_PEER_RALINK ||
@@ -645,12 +603,6 @@ HTIOTActDisableHighPower(struct rtllib_device* ieee,struct rtllib_network *netwo
 	{
 			retValue = 1;
 	}
-#elif defined RTL8192SE || defined RTL8192CE
-	if (pHTInfo->IOTPeer==HT_IOT_PEER_RALINK ||
-		pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK )
-	{
-			retValue = 1;
-	}
 #endif
 	return retValue;
 }
@@ -675,19 +627,6 @@ HTIOTActIsDisableTx40MHz(struct rtllib_device* ieee,struct rtllib_network *netwo
 {
 	u8	retValue = 0;
 
-#if (defined RTL8192SU || defined RTL8192SE || defined RTL8192CE)
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-	if (	(KEY_TYPE_WEP104 == ieee->pairwise_key_type) ||
-		(KEY_TYPE_WEP40 == ieee->pairwise_key_type) ||
-		(KEY_TYPE_WEP104 == ieee->group_key_type) ||
-		(KEY_TYPE_WEP40 == ieee->group_key_type) ||
-		(KEY_TYPE_TKIP == ieee->pairwise_key_type) )
-	{
-		if ((pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK) && (network->bssht.bdSupportHT))
-			retValue = 1;
-	}
-#endif
-
 	return retValue;
 }
 
@@ -696,19 +635,6 @@ HTIOTActIsTxNoAggregation(struct rtllib_device* ieee,struct rtllib_network *netw
 {
 	u8 retValue = 0;
 
-#if (defined RTL8192SU || defined RTL8192SE || defined RTL8192CE)
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-	if (	(KEY_TYPE_WEP104 == ieee->pairwise_key_type) ||
-		(KEY_TYPE_WEP40 == ieee->pairwise_key_type) ||
-		(KEY_TYPE_WEP104 == ieee->group_key_type) ||
-		(KEY_TYPE_WEP40 == ieee->group_key_type) ||
-		(KEY_TYPE_TKIP == ieee->pairwise_key_type) )
-	{
-		if (pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK)
-			retValue = 1;
-	}
-#endif
-
 	return retValue;
 }
 
@@ -718,19 +644,6 @@ HTIOTActIsDisableTx2SS(struct rtllib_device* ieee,struct rtllib_network *network
 {
 	u8	retValue = 0;
 
-#if (defined RTL8192SU || defined RTL8192SE || defined RTL8192CE)
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-	if (	(KEY_TYPE_WEP104 == ieee->pairwise_key_type) ||
-		(KEY_TYPE_WEP40 == ieee->pairwise_key_type) ||
-		(KEY_TYPE_WEP104 == ieee->group_key_type) ||
-		(KEY_TYPE_WEP40 == ieee->group_key_type) ||
-		(KEY_TYPE_TKIP == ieee->pairwise_key_type) )
-	{
-		if ((pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK) && (network->bssht.bdSupportHT))
-			retValue = 1;
-	}
-#endif
-
 	return retValue;
 }
 
@@ -753,15 +666,6 @@ bool HTIOCActIsDisableCckRate(struct rtllib_device* ieee,struct rtllib_network *
 bool HTIOCActAllowPeerAggOnePacket(struct rtllib_device* ieee,struct rtllib_network *network)
 {
 	bool	retValue = false;
-#if defined(RTL8192SE) || defined(RTL8192SU)
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-	{
-		if (ieee->VersionID<2)
-		if (pHTInfo->IOTPeer == HT_IOT_PEER_MARVELL)
-			return true;
-
-	}
-#endif
 	return retValue;
 }
 
@@ -769,14 +673,6 @@ bool
 HTIOTActIsNullDataPowerSaving(struct rtllib_device* ieee,struct rtllib_network *network)
 {
 	bool	retValue = false;
-#if defined(RTL8192SE) || defined(RTL8192SU)
-	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-	{
-		if (pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
-			return true;
-
-	}
-#endif
 	return retValue;
 }
 
@@ -826,9 +722,6 @@ void HTConstructCapabilityElement(struct rtllib_device* ieee, u8* posHTCap, u8*
 	pCapELE->ShortGI40Mhz		= 1;
 
 	pCapELE->TxSTBC			= 1;
-#if defined RTL8192SE || defined RTL8192CE
-	pCapELE->TxSTBC			= 0;
-#endif
 	pCapELE->RxSTBC			= 0;
 	pCapELE->DelayBA		= 0;
 	pCapELE->MaxAMSDUSize	= (MAX_RECEIVE_BUFFER_SIZE>=7935)?1:0;
@@ -1131,18 +1024,6 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
 		pHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;
 	else
 		pHTInfo->CurrentMPDUDensity = pPeerHTCap->MPDUDensity;
-#if (defined RTL8192SE || defined RTL8192SU || defined RTL8192CE)
-        if (ieee->SetHwRegHandler != NULL) {
-            ieee->SetHwRegHandler( ieee->dev, HW_VAR_SHORTGI_DENSITY,  (u8*)(&ieee->MaxMssDensity));
-            ieee->SetHwRegHandler(ieee->dev, HW_VAR_AMPDU_FACTOR, &pHTInfo->CurrentAMPDUFactor);
-            ieee->SetHwRegHandler(ieee->dev, HW_VAR_AMPDU_MIN_SPACE, &pHTInfo->CurrentMPDUDensity);
-        }
-#elif defined RTL8192CE
-        if (ieee->SetHwRegHandler != NULL) {
-            ieee->SetHwRegHandler(ieee->dev, HW_VAR_AMPDU_FACTOR, &pHTInfo->CurrentAMPDUFactor);
-            ieee->SetHwRegHandler(ieee->dev, HW_VAR_AMPDU_MIN_SPACE, &pHTInfo->CurrentMPDUDensity);
-        }
-#endif
 	if (pHTInfo->IOTAction & HT_IOT_ACT_TX_USE_AMSDU_8K)
 	{
 		pHTInfo->bCurrentAMPDUEnable = false;
@@ -1290,71 +1171,6 @@ void HTResetSelfAndSavePeerSetting(struct rtllib_device* ieee,	struct rtllib_net
 		bIOTAction = HTIOTActIsCCDFsync(ieee);
 		if (bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_CDD_FSYNC;
-#if defined(RTL8192SU) || defined(RTL8192SE) || defined RTL8192CE
-		bIOTAction = HTIOTActIsForcedCTS2Self(ieee,pNetwork);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_FORCED_CTS2SELF;
-
-
-		bIOTAction = HTIOTActIsEnableBETxOPLimit(ieee);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_FORCED_ENABLE_BE_TXOP;
-
-#if defined(RTL8192SU)
-		bIOTAction = HTIOCActRejcectADDBARequest(pNetwork);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_REJECT_ADDBA_REQ;
-#endif
-
-		bIOTAction = HTIOCActAllowPeerAggOnePacket(ieee, pNetwork);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_ALLOW_PEER_AGG_ONE_PKT;
-
-		bIOTAction = HTIOTActIsEDCABiasRx(ieee, pNetwork);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_EDCA_BIAS_ON_RX;
-
-#if defined(RTL8192SU)
-		bIOTAction = HTIOCActIsDisableCckRate(ieee, pNetwork);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_CCK_RATE;
-#endif
-		bIOTAction = HTIOTActDisableShortGI(ieee, pNetwork);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_SHORT_GI;
-
-		bIOTAction = HTIOTActDisableHighPower(ieee, pNetwork);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_HIGH_POWER;
-
-
-		bIOTAction = HTIOTActIsForcedAMSDU8K(ieee, pNetwork);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_TX_USE_AMSDU_8K;
-
-#if defined(RTL8192SU)
-		bIOTAction = HTIOTActIsTxNoAggregation(ieee, pNetwork);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_TX_NO_AGGREGATION;
-
-		bIOTAction = HTIOTActIsDisableTx40MHz(ieee, pNetwork);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_TX_40_MHZ;
-
-		bIOTAction = HTIOTActIsDisableTx2SS(ieee, pNetwork);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_TX_2SS;
-#endif
-
-		bIOTAction = HTIOTActIsForcedRTSCTS(ieee, pNetwork);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_FORCED_RTS;
-
-		bIOTAction = HTIOTActIsNullDataPowerSaving(ieee, pNetwork);
-		if (bIOTAction)
-			pHTInfo->IOTAction |= HT_IOT_ACT_NULL_DATA_POWER_SAVING;
-#endif
-
 	} else {
 		pHTInfo->bCurrentHTSupport = false;
 		pHTInfo->bCurrentRT2RTAggregation = false;

commit 175159c537312f95150508655256645c8daa86a0
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Mon Jul 11 18:34:09 2011 -0500

    staging: rtl8192e: Remove code dependent on RTL8190P
    
    The vendor code can conditionally generate drivers for a number of
    devices. Remove any code that depends on RTL8190P being set.
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index 1aa7d80e8de2..a212a972ec6f 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -476,14 +476,10 @@ u8 HTIOTActIsMgntUseCCK6M(struct rtllib_device* ieee,struct rtllib_network *netw
 	u8	retValue = 0;
 
 
-#if (defined RTL8192U || defined RTL8192E || defined RTL8190P)
-	{
 	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
 	{
 		retValue = 1;
 	}
-	}
-#endif
 
 	return retValue;
 }
@@ -563,12 +559,10 @@ HTIOTActIsForcedAMSDU8K(struct rtllib_device *ieee, struct rtllib_network *netwo
 u8 HTIOTActIsCCDFsync(struct rtllib_device *ieee)
 {
 	u8	retValue = 0;
-#if (defined RTL8190P || defined RTL8192U  || defined RTL8192SU)
 	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
 	{
 		retValue = 1;
 	}
-#endif
 	return retValue;
 }
 
@@ -1149,11 +1143,7 @@ void HTOnAssocRsp(struct rtllib_device *ieee)
             ieee->SetHwRegHandler(ieee->dev, HW_VAR_AMPDU_MIN_SPACE, &pHTInfo->CurrentMPDUDensity);
         }
 #endif
-#ifndef RTL8190P
 	if (pHTInfo->IOTAction & HT_IOT_ACT_TX_USE_AMSDU_8K)
-#else
-	if ( 0 )
-#endif
 	{
 		pHTInfo->bCurrentAMPDUEnable = false;
 		pHTInfo->ForcedAMSDUMode = HT_AGG_FORCE_ENABLE;
@@ -1294,17 +1284,9 @@ void HTResetSelfAndSavePeerSetting(struct rtllib_device* ieee,	struct rtllib_net
 		if (bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_EDCA_TURBO;
 
-#if defined(RTL8190P) || defined(RTL8192E) || defined(RTL8192U)
 		bIOTAction = HTIOTActIsMgntUseCCK6M(ieee,pNetwork);
 		if (bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_MGNT_USE_CCK_6M;
-#elif defined(RTL8192SE) || defined(RTL8192SU) || defined RTL8192CE
-		bIOTAction = HTIOTActWAIOTBroadcom(ieee);
-		if (bIOTAction)
-		{
-			pHTInfo->IOTAction |= HT_IOT_ACT_WA_IOT_Broadcom;
-		}
-#endif
 		bIOTAction = HTIOTActIsCCDFsync(ieee);
 		if (bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_CDD_FSYNC;

commit cb76215448947ddcc133c4b1c2ff2d4a77e851e0
Author: Mike McCormack <mikem@ring3k.org>
Date:   Mon Jul 11 08:56:20 2011 +0900

    rtl8192e: Remove extra ifdefs
    
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Mike McCormack <mikem@ring3k.org>

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
index eaf73676f952..1aa7d80e8de2 100644
--- a/drivers/staging/rtl8192e/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -958,14 +958,6 @@ void HTConstructRT2RTAggElement(struct rtllib_device* ieee, u8* posRT2RTAgg, u8*
 	*len = 6 + 2;
 
 	return;
-
-#ifdef TODO
-	posRT2RTAgg->Length = 6;
-#endif
-
-
-
-
 }
 
 u8 HT_PickMCSRate(struct rtllib_device* ieee, u8* pOperateMCS)
@@ -1410,8 +1402,7 @@ void HTUseDefaultSetting(struct rtllib_device* ieee)
 {
 	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
 
-	if (pHTInfo->bEnableHT)
-	{
+	if (pHTInfo->bEnableHT) {
 		pHTInfo->bCurrentHTSupport = true;
 		pHTInfo->bCurSuppCCK = pHTInfo->bRegSuppCCK;
 
@@ -1434,27 +1425,15 @@ void HTUseDefaultSetting(struct rtllib_device* ieee)
 
 
 		HTFilterMCSRate(ieee, ieee->Regdot11TxHTOperationalRateSet, ieee->dot11HTOperationalRateSet);
-#ifdef TODO
-		Adapter->HalFunc.InitHalRATRTableHandler( Adapter, &pMgntInfo->dot11OperationalRateSet, pMgntInfo->dot11HTOperationalRateSet);
-#endif
 		ieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee, ieee->dot11HTOperationalRateSet, MCS_FILTER_ALL);
 		ieee->HTCurrentOperaRate = ieee->HTHighestOperaRate;
 
-#if (defined RTL8192SE || defined RTL8192SU || defined RTL8192CE)
-		if (ieee->SetHwRegHandler != NULL) {
-			ieee->SetHwRegHandler( ieee->dev, HW_VAR_SHORTGI_DENSITY,  (u8*)(&ieee->MaxMssDensity));
-			ieee->SetHwRegHandler(ieee->dev, HW_VAR_AMPDU_FACTOR, &pHTInfo->CurrentAMPDUFactor);
-			ieee->SetHwRegHandler(ieee->dev, HW_VAR_AMPDU_MIN_SPACE, &pHTInfo->CurrentMPDUDensity);
-		}
-#endif
-
-	}
-	else
-	{
+	} else {
 		pHTInfo->bCurrentHTSupport = false;
 	}
 	return;
 }
+
 u8 HTCCheck(struct rtllib_device* ieee, u8*	pFrame)
 {
 	if (ieee->pHTInfo->bCurrentHTSupport)

commit 94a799425eee8225a1e3fbe5f473d2ef04002577
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Tue Aug 23 19:00:42 2011 -0500

    From: wlanfae <wlanfae@realtek.com>
    [PATCH 1/8] rtl8192e: Import new version of driver from realtek
    
    Signed-off-by: wlanfae <wlanfae@realtek.com>
    Signed-off-by: Mike McCormack <mikem@ring3k.org>
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    ---

diff --git a/drivers/staging/rtl8192e/rtl819x_HTProc.c b/drivers/staging/rtl8192e/rtl819x_HTProc.c
new file mode 100644
index 000000000000..eaf73676f952
--- /dev/null
+++ b/drivers/staging/rtl8192e/rtl819x_HTProc.c
@@ -0,0 +1,1531 @@
+/******************************************************************************
+ * Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+******************************************************************************/
+#include "rtllib.h"
+#include "rtl819x_HT.h"
+u8 MCS_FILTER_ALL[16] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+u8 MCS_FILTER_1SS[16] = {0xff, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+u16 MCS_DATA_RATE[2][2][77] =
+	{	{	{13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78 ,104, 156, 208, 234, 260,
+			39, 78, 117, 234, 312, 351, 390, 52, 104, 156, 208, 312, 416, 468, 520,
+			0, 78, 104, 130, 117, 156, 195, 104, 130, 130, 156, 182, 182, 208, 156, 195,
+			195, 234, 273, 273, 312, 130, 156, 181, 156, 181, 208, 234, 208, 234, 260, 260,
+			286, 195, 234, 273, 234, 273, 312, 351, 312, 351, 390, 390, 429},
+			{14, 29, 43, 58, 87, 116, 130, 144, 29, 58, 87, 116, 173, 231, 260, 289,
+			43, 87, 130, 173, 260, 347, 390, 433, 58, 116, 173, 231, 347, 462, 520, 578,
+			0, 87, 116, 144, 130, 173, 217, 116, 144, 144, 173, 202, 202, 231, 173, 217,
+			217, 260, 303, 303, 347, 144, 173, 202, 173, 202, 231, 260, 231, 260, 289, 289,
+			318, 217, 260, 303, 260, 303, 347, 390, 347, 390, 433, 433, 477}	},
+		{	{27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540,
+			81, 162, 243, 324, 486, 648, 729, 810, 108, 216, 324, 432, 648, 864, 972, 1080,
+			12, 162, 216, 270, 243, 324, 405, 216, 270, 270, 324, 378, 378, 432, 324, 405,
+			405, 486, 567, 567, 648, 270, 324, 378, 324, 378, 432, 486, 432, 486, 540, 540,
+			594, 405, 486, 567, 486, 567, 648, 729, 648, 729, 810, 810, 891},
+			{30, 60, 90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600,
+			90, 180, 270, 360, 540, 720, 810, 900, 120, 240, 360, 480, 720, 960, 1080, 1200,
+			13, 180, 240, 300, 270, 360, 450, 240, 300, 300, 360, 420, 420, 480, 360, 450,
+			450, 540, 630, 630, 720, 300, 360, 420, 360, 420, 480, 540, 480, 540, 600, 600,
+			660, 450, 540, 630, 540, 630, 720, 810, 720, 810, 900, 900, 990}	}
+	};
+
+static u8 UNKNOWN_BORADCOM[3] = {0x00, 0x14, 0xbf};
+static u8 LINKSYSWRT330_LINKSYSWRT300_BROADCOM[3] = {0x00, 0x1a, 0x70};
+static u8 LINKSYSWRT350_LINKSYSWRT150_BROADCOM[3] = {0x00, 0x1d, 0x7e};
+static u8 BELKINF5D8233V1_RALINK[3] = {0x00, 0x17, 0x3f};
+static u8 BELKINF5D82334V3_RALINK[3] = {0x00, 0x1c, 0xdf};
+static u8 PCI_RALINK[3] = {0x00, 0x90, 0xcc};
+static u8 EDIMAX_RALINK[3] = {0x00, 0x0e, 0x2e};
+static u8 AIRLINK_RALINK[3] = {0x00, 0x18, 0x02};
+static u8 DLINK_ATHEROS_1[3] = {0x00, 0x1c, 0xf0};
+static u8 DLINK_ATHEROS_2[3] = {0x00, 0x21, 0x91};
+static u8 CISCO_BROADCOM[3] = {0x00, 0x17, 0x94};
+#if defined(RTL8192SU)
+static u8 NETGEAR_BROADCOM[3] = {0x00, 0x1f, 0x33};
+#endif
+static u8 LINKSYS_MARVELL_4400N[3] = {0x00, 0x14, 0xa4};
+void HTUpdateDefaultSetting(struct rtllib_device* ieee)
+{
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+
+#ifdef RTL8192CE
+	pHTInfo->bRDGEnable = 0;
+#endif
+
+	pHTInfo->bAcceptAddbaReq = 1;
+
+	pHTInfo->bRegShortGI20MHz= 1;
+	pHTInfo->bRegShortGI40MHz= 1;
+
+	pHTInfo->bRegBW40MHz = 1;
+
+	if (pHTInfo->bRegBW40MHz)
+		pHTInfo->bRegSuppCCK = 1;
+	else
+		pHTInfo->bRegSuppCCK = true;
+
+	pHTInfo->nAMSDU_MaxSize = 7935UL;
+	pHTInfo->bAMSDU_Support = 0;
+
+	pHTInfo->bAMPDUEnable = 1;
+	pHTInfo->AMPDU_Factor = 2;
+	pHTInfo->MPDU_Density = 0;
+
+	pHTInfo->SelfMimoPs = 3;
+	if (pHTInfo->SelfMimoPs == 2)
+		pHTInfo->SelfMimoPs = 3;
+	ieee->bTxDisableRateFallBack = 0;
+	ieee->bTxUseDriverAssingedRate = 0;
+
+	ieee->bTxEnableFwCalcDur = 1;
+
+	pHTInfo->bRegRT2RTAggregation = 1;
+
+	pHTInfo->bRegRxReorderEnable = 1;
+	pHTInfo->RxReorderWinSize = 64;
+	pHTInfo->RxReorderPendingTime = 30;
+
+#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
+	pHTInfo->UsbTxAggrNum = 4;
+#endif
+#ifdef USB_RX_AGGREGATION_SUPPORT
+#ifdef RTL8192SU
+	pHTInfo->UsbRxFwAggrEn = 1;
+	pHTInfo->UsbRxFwAggrPageNum = 48;
+	pHTInfo->UsbRxFwAggrPacketNum = 8;
+	pHTInfo->UsbRxFwAggrTimeout = 4;
+	pHTInfo->UsbRxPageSize= 128;
+#else
+	pHTInfo->UsbRxFwAggrEn = 1;
+	pHTInfo->UsbRxFwAggrPageNum = 24;
+	pHTInfo->UsbRxFwAggrPacketNum = 8;
+	pHTInfo->UsbRxFwAggrTimeout = 8;
+#endif
+#endif
+
+
+}
+void HTDebugHTCapability(u8* CapIE, u8* TitleString )
+{
+
+	static u8	EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};
+	PHT_CAPABILITY_ELE		pCapELE;
+
+	if (!memcmp(CapIE, EWC11NHTCap, sizeof(EWC11NHTCap)))
+	{
+		RTLLIB_DEBUG(RTLLIB_DL_HT, "EWC IE in %s()\n", __func__);
+		pCapELE = (PHT_CAPABILITY_ELE)(&CapIE[4]);
+	}else
+		pCapELE = (PHT_CAPABILITY_ELE)(&CapIE[0]);
+
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "<Log HT Capability>. Called by %s\n", TitleString );
+
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupported Channel Width = %s\n", (pCapELE->ChlWidth)?"20MHz": "20/40MHz");
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport Short GI for 20M = %s\n", (pCapELE->ShortGI20Mhz)?"YES": "NO");
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport Short GI for 40M = %s\n", (pCapELE->ShortGI40Mhz)?"YES": "NO");
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport TX STBC = %s\n", (pCapELE->TxSTBC)?"YES": "NO");
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMax AMSDU Size = %s\n", (pCapELE->MaxAMSDUSize)?"3839": "7935");
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tSupport CCK in 20/40 mode = %s\n", (pCapELE->DssCCk)?"YES": "NO");
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMax AMPDU Factor = %d\n", pCapELE->MaxRxAMPDUFactor);
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMPDU Density = %d\n", pCapELE->MPDUDensity);
+	RTLLIB_DEBUG(RTLLIB_DL_HT,  "\tMCS Rate Set = [%x][%x][%x][%x][%x]\n", pCapELE->MCS[0],\
+				pCapELE->MCS[1], pCapELE->MCS[2], pCapELE->MCS[3], pCapELE->MCS[4]);
+	return;
+
+}
+void HTDebugHTInfo(u8*	InfoIE, u8* TitleString)
+{
+
+	static u8	EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};
+	PHT_INFORMATION_ELE		pHTInfoEle;
+
+	if (!memcmp(InfoIE, EWC11NHTInfo, sizeof(EWC11NHTInfo)))
+	{
+		RTLLIB_DEBUG(RTLLIB_DL_HT, "EWC IE in %s()\n", __func__);
+		pHTInfoEle = (PHT_INFORMATION_ELE)(&InfoIE[4]);
+	}else
+		pHTInfoEle = (PHT_INFORMATION_ELE)(&InfoIE[0]);
+
+
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "<Log HT Information Element>. Called by %s\n", TitleString);
+
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tPrimary channel = %d\n", pHTInfoEle->ControlChl);
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tSenondary channel =");
+	switch (pHTInfoEle->ExtChlOffset)
+	{
+		case 0:
+			RTLLIB_DEBUG(RTLLIB_DL_HT, "Not Present\n");
+			break;
+		case 1:
+			RTLLIB_DEBUG(RTLLIB_DL_HT, "Upper channel\n");
+			break;
+		case 2:
+			RTLLIB_DEBUG(RTLLIB_DL_HT, "Reserved. Eooro!!!\n");
+			break;
+		case 3:
+			RTLLIB_DEBUG(RTLLIB_DL_HT, "Lower Channel\n");
+			break;
+	}
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tRecommended channel width = %s\n", (pHTInfoEle->RecommemdedTxWidth)?"20Mhz": "40Mhz");
+
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tOperation mode for protection = ");
+	switch (pHTInfoEle->OptMode)
+	{
+		case 0:
+			RTLLIB_DEBUG(RTLLIB_DL_HT, "No Protection\n");
+			break;
+		case 1:
+			RTLLIB_DEBUG(RTLLIB_DL_HT, "HT non-member protection mode\n");
+			break;
+		case 2:
+			RTLLIB_DEBUG(RTLLIB_DL_HT, "Suggest to open protection\n");
+			break;
+		case 3:
+			RTLLIB_DEBUG(RTLLIB_DL_HT, "HT mixed mode\n");
+			break;
+	}
+
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "\tBasic MCS Rate Set = [%x][%x][%x][%x][%x]\n", pHTInfoEle->BasicMSC[0],\
+				pHTInfoEle->BasicMSC[1], pHTInfoEle->BasicMSC[2], pHTInfoEle->BasicMSC[3], pHTInfoEle->BasicMSC[4]);
+	return;
+}
+
+bool IsHTHalfNmode40Bandwidth(struct rtllib_device* ieee)
+{
+	bool			retValue = false;
+	PRT_HIGH_THROUGHPUT	 pHTInfo = ieee->pHTInfo;
+
+	if (pHTInfo->bCurrentHTSupport == false )
+		retValue = false;
+	else if (pHTInfo->bRegBW40MHz == false)
+		retValue = false;
+	else if (!ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
+		retValue = false;
+	else if (((PHT_CAPABILITY_ELE)(pHTInfo->PeerHTCapBuf))->ChlWidth)
+		retValue = true;
+	else
+		retValue = false;
+
+	return retValue;
+}
+
+bool IsHTHalfNmodeSGI(struct rtllib_device* ieee, bool is40MHz)
+{
+	bool			retValue = false;
+	PRT_HIGH_THROUGHPUT	 pHTInfo = ieee->pHTInfo;
+
+	if (pHTInfo->bCurrentHTSupport == false )
+		retValue = false;
+	else if (!ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
+		retValue = false;
+	else if (is40MHz)
+	{
+		if (((PHT_CAPABILITY_ELE)(pHTInfo->PeerHTCapBuf))->ShortGI40Mhz)
+			retValue = true;
+		else
+			retValue = false;
+	}
+	else
+	{
+		if (((PHT_CAPABILITY_ELE)(pHTInfo->PeerHTCapBuf))->ShortGI20Mhz)
+			retValue = true;
+		else
+			retValue = false;
+	}
+
+	return retValue;
+}
+
+u16 HTHalfMcsToDataRate(struct rtllib_device* ieee,	u8	nMcsRate)
+{
+
+	u8	is40MHz;
+	u8	isShortGI;
+
+	is40MHz  =  (IsHTHalfNmode40Bandwidth(ieee))?1:0;
+	isShortGI = (IsHTHalfNmodeSGI(ieee, is40MHz))? 1:0;
+
+	return MCS_DATA_RATE[is40MHz][isShortGI][(nMcsRate&0x7f)];
+}
+
+
+u16 HTMcsToDataRate( struct rtllib_device* ieee, u8 nMcsRate)
+{
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+
+	u8	is40MHz = (pHTInfo->bCurBW40MHz)?1:0;
+	u8	isShortGI = (pHTInfo->bCurBW40MHz)?
+						((pHTInfo->bCurShortGI40MHz)?1:0):
+						((pHTInfo->bCurShortGI20MHz)?1:0);
+	return MCS_DATA_RATE[is40MHz][isShortGI][(nMcsRate&0x7f)];
+}
+
+u16  TxCountToDataRate( struct rtllib_device* ieee, u8 nDataRate)
+{
+	u16		CCKOFDMRate[12] = {0x02 , 0x04 , 0x0b , 0x16 , 0x0c , 0x12 , 0x18 , 0x24 , 0x30 , 0x48 , 0x60 , 0x6c};
+	u8	is40MHz = 0;
+	u8	isShortGI = 0;
+
+	if (nDataRate < 12)
+	{
+		return CCKOFDMRate[nDataRate];
+	}
+	else
+	{
+		if (nDataRate >= 0x10 && nDataRate <= 0x1f)
+		{
+			is40MHz = 0;
+			isShortGI = 0;
+
+		}
+		else if (nDataRate >=0x20  && nDataRate <= 0x2f )
+		{
+			is40MHz = 1;
+			isShortGI = 0;
+
+		}
+		else if (nDataRate >= 0x30  && nDataRate <= 0x3f )
+		{
+			is40MHz = 0;
+			isShortGI = 1;
+
+		}
+		else if (nDataRate >= 0x40  && nDataRate <= 0x4f )
+		{
+			is40MHz = 1;
+			isShortGI = 1;
+
+		}
+		return MCS_DATA_RATE[is40MHz][isShortGI][nDataRate&0xf];
+	}
+}
+
+
+
+bool IsHTHalfNmodeAPs(struct rtllib_device* ieee)
+{
+	bool			retValue = false;
+	struct rtllib_network* net = &ieee->current_network;
+
+	if ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3)==0) ||
+		     (memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3)==0) ||
+		     (memcmp(net->bssid, PCI_RALINK, 3)==0) ||
+		     (memcmp(net->bssid, EDIMAX_RALINK, 3)==0) ||
+		     (memcmp(net->bssid, AIRLINK_RALINK, 3)==0) ||
+		     (net->ralink_cap_exist))
+		retValue = true;
+	else if ((memcmp(net->bssid, UNKNOWN_BORADCOM, 3)==0) ||
+		    (memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)||
+		    (memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3)==0)||
+		    (net->broadcom_cap_exist))
+		  retValue = true;
+	else if (net->bssht.bdRT2RTAggregation)
+		retValue = true;
+	else
+		retValue = false;
+
+	return retValue;
+}
+
+void HTIOTPeerDetermine(struct rtllib_device* ieee)
+{
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	struct rtllib_network* net = &ieee->current_network;
+	if (net->bssht.bdRT2RTAggregation){
+		pHTInfo->IOTPeer = HT_IOT_PEER_REALTEK;
+		if (net->bssht.RT2RT_HT_Mode & RT_HT_CAP_USE_92SE){
+			pHTInfo->IOTPeer = HT_IOT_PEER_REALTEK_92SE;
+		}
+		if (net->bssht.RT2RT_HT_Mode & RT_HT_CAP_USE_SOFTAP){
+			pHTInfo->IOTPeer = HT_IOT_PEER_92U_SOFTAP;
+		}
+	}
+	else if (net->broadcom_cap_exist)
+		pHTInfo->IOTPeer = HT_IOT_PEER_BROADCOM;
+	else if ((memcmp(net->bssid, UNKNOWN_BORADCOM, 3)==0) ||
+			(memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)||
+			(memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3)==0)/*||
+			(memcmp(net->bssid, NETGEAR834Bv2_BROADCOM, 3)==0) */)
+		pHTInfo->IOTPeer = HT_IOT_PEER_BROADCOM;
+	else if ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3)==0) ||
+			(memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3)==0) ||
+			(memcmp(net->bssid, PCI_RALINK, 3)==0) ||
+			(memcmp(net->bssid, EDIMAX_RALINK, 3)==0) ||
+			(memcmp(net->bssid, AIRLINK_RALINK, 3)==0) ||
+			 net->ralink_cap_exist)
+		pHTInfo->IOTPeer = HT_IOT_PEER_RALINK;
+	else if ((net->atheros_cap_exist )||
+		(memcmp(net->bssid, DLINK_ATHEROS_1, 3) == 0)||
+		(memcmp(net->bssid, DLINK_ATHEROS_2, 3) == 0))
+		pHTInfo->IOTPeer = HT_IOT_PEER_ATHEROS;
+	else if ((memcmp(net->bssid, CISCO_BROADCOM, 3)==0)||net->cisco_cap_exist)
+		pHTInfo->IOTPeer = HT_IOT_PEER_CISCO;
+	else if ((memcmp(net->bssid, LINKSYS_MARVELL_4400N, 3) == 0) ||
+		  net->marvell_cap_exist)
+		pHTInfo->IOTPeer = HT_IOT_PEER_MARVELL;
+	else if (net->airgo_cap_exist)
+		pHTInfo->IOTPeer = HT_IOT_PEER_AIRGO;
+	else
+		pHTInfo->IOTPeer = HT_IOT_PEER_UNKNOWN;
+
+	RTLLIB_DEBUG(RTLLIB_DL_IOT, "Joseph debug!! IOTPEER: %x\n", pHTInfo->IOTPeer);
+}
+
+u8 HTIOTActIsDisableMCS14(struct rtllib_device* ieee, u8* PeerMacAddr)
+{
+	return 0;
+ }
+
+
+bool HTIOTActIsDisableMCS15(struct rtllib_device* ieee)
+{
+	bool retValue = false;
+
+#if defined(RTL8192U)
+	if (ieee->current_network.bssht.bdBandWidth == HT_CHANNEL_WIDTH_20_40)
+	retValue = true;
+	else
+		retValue = false;
+#endif
+
+
+	return retValue;
+}
+
+bool HTIOTActIsDisableMCSTwoSpatialStream(struct rtllib_device* ieee)
+{
+	bool retValue = false;
+#ifdef RTL8192U
+	struct rtllib_network* net = &ieee->current_network;
+
+	if ((ieee->pHTInfo->bCurrentHTSupport == true) && (ieee->pairwise_key_type == KEY_TYPE_CCMP))
+	{
+		if ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3)==0) ||
+				(memcmp(net->bssid, PCI_RALINK, 3)==0) ||
+				(memcmp(net->bssid, EDIMAX_RALINK, 3)==0))
+		{
+			retValue = false;
+		}
+	}
+#endif
+#if defined(RTL8192SU) || defined RTL8192CE
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	if (ieee->rtllib_ap_sec_type &&
+		(ieee->rtllib_ap_sec_type(ieee)&(SEC_ALG_WEP|SEC_ALG_TKIP)))
+	{
+		if ( (pHTInfo->IOTPeer != HT_IOT_PEER_ATHEROS) &&
+			(pHTInfo->IOTPeer != HT_IOT_PEER_UNKNOWN) &&
+			(pHTInfo->IOTPeer != HT_IOT_PEER_MARVELL) &&
+			(pHTInfo->IOTPeer != HT_IOT_PEER_REALTEK_92SE) &&
+			(pHTInfo->IOTPeer != HT_IOT_PEER_RALINK) )
+			retValue = true;
+	}
+#elif defined(RTL8192SE)
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	if (ieee->rtllib_ap_sec_type &&
+		(ieee->rtllib_ap_sec_type(ieee)&SEC_ALG_TKIP)) {
+			if (pHTInfo->IOTPeer == HT_IOT_PEER_RALINK){
+				retValue = true;
+			}
+		}
+#endif
+	return retValue;
+}
+
+u8 HTIOTActIsDisableEDCATurbo(struct rtllib_device*	ieee, u8* PeerMacAddr)
+{
+	return false;
+}
+
+
+bool HTIOTActIsEnableBETxOPLimit(struct rtllib_device* ieee)
+{
+	bool	retValue = false;
+
+#if defined RTL8192SU
+	if (ieee->mode == IEEE_G)
+		retValue = true;
+#elif defined RTL8192CE
+	if (ieee->mode == IEEE_G ||
+		(ieee->rtllib_ap_sec_type(ieee)&(SEC_ALG_WEP|SEC_ALG_TKIP)))
+		retValue = true;
+#endif
+
+	return retValue;
+}
+
+
+u8 HTIOTActIsMgntUseCCK6M(struct rtllib_device* ieee,struct rtllib_network *network)
+{
+	u8	retValue = 0;
+
+
+#if (defined RTL8192U || defined RTL8192E || defined RTL8190P)
+	{
+	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
+	{
+		retValue = 1;
+	}
+	}
+#endif
+
+	return retValue;
+}
+
+u8
+HTIOTActWAIOTBroadcom(struct rtllib_device* ieee)
+{
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	u8		retValue = false;
+	u8		boundary=59;
+
+	pHTInfo->bWAIotBroadcom = false;
+	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
+	{
+		if (ieee->current_network.bssht.bdBandWidth == HT_CHANNEL_WIDTH_20_40)
+		{
+			if (!(pHTInfo->bRegBW40MHz))
+			{
+				if (ieee->current_network.mode != WIRELESS_MODE_B)
+				{
+					pHTInfo->bWAIotBroadcom = true;
+
+					if (ieee->b_customer_lenovo_id == true)
+						boundary = 30;
+
+					if ( ieee->current_network.RSSI >= boundary)
+						retValue = true;
+				}
+			}else{
+				;
+			}
+		}
+	}
+	return retValue;
+}
+
+u8 HTIOTActIsForcedCTS2Self(struct rtllib_device *ieee, struct rtllib_network *network)
+{
+	u8	retValue = 0;
+#if (defined RTL8192SE || defined RTL8192SU || defined RTL8192CE)
+	if ((ieee->pHTInfo->IOTPeer == HT_IOT_PEER_MARVELL) ||(ieee->pHTInfo->IOTPeer == HT_IOT_PEER_ATHEROS) )
+#else
+	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_MARVELL)
+#endif
+	{
+		retValue = 1;
+	}
+
+	return retValue;
+}
+
+u8 HTIOTActIsForcedRTSCTS(struct rtllib_device *ieee, struct rtllib_network *network)
+{
+	u8	retValue = 0;
+#if defined(RTL8192SE) || defined(RTL8192SU)
+	if (ieee->pHTInfo->bCurrentHTSupport)
+	{
+		if ((ieee->pHTInfo->IOTPeer != HT_IOT_PEER_REALTEK)&&
+		   (ieee->pHTInfo->IOTPeer != HT_IOT_PEER_REALTEK_92SE))
+	{
+			if ((ieee->pHTInfo->IOTAction & HT_IOT_ACT_TX_NO_AGGREGATION) == 0)
+				retValue = 1;
+		}
+	}
+#endif
+	return retValue;
+}
+
+u8
+HTIOTActIsForcedAMSDU8K(struct rtllib_device *ieee, struct rtllib_network *network)
+{
+	u8 retValue = 0;
+
+	return retValue;
+}
+
+u8 HTIOTActIsCCDFsync(struct rtllib_device *ieee)
+{
+	u8	retValue = 0;
+#if (defined RTL8190P || defined RTL8192U  || defined RTL8192SU)
+	if (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
+	{
+		retValue = 1;
+	}
+#endif
+	return retValue;
+}
+
+u8
+HTIOCActRejcectADDBARequest(struct rtllib_network *network)
+{
+	u8	retValue = 0;
+#if (defined RTL8192SE || defined RTL8192SU || defined RTL8192CE)
+	{
+
+
+	}
+#endif
+
+	return retValue;
+
+}
+
+u8
+  HTIOTActIsEDCABiasRx(struct rtllib_device* ieee,struct rtllib_network *network)
+{
+	u8	retValue = 0;
+#ifdef RTL8192SU
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	{
+		if (pHTInfo->IOTPeer==HT_IOT_PEER_ATHEROS ||
+		   pHTInfo->IOTPeer==HT_IOT_PEER_BROADCOM ||
+		   pHTInfo->IOTPeer==HT_IOT_PEER_RALINK)
+			return 1;
+
+	}
+#elif defined RTL8192CE
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	{
+		if (pHTInfo->IOTPeer==HT_IOT_PEER_ATHEROS ||
+		   pHTInfo->IOTPeer==HT_IOT_PEER_RALINK)
+			return 1;
+
+	}
+#elif defined RTL8192SE
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	{
+            if (ieee->rtllib_ap_sec_type != NULL)
+                if (ieee->rtllib_ap_sec_type(ieee) == SEC_ALG_CCMP)
+                    if (pHTInfo->IOTPeer==HT_IOT_PEER_RALINK){
+                        return 1;
+                    }
+
+	}
+#endif
+	return retValue;
+}
+
+u8
+HTIOTActDisableShortGI(struct rtllib_device* ieee,struct rtllib_network *network)
+{
+	u8	retValue = 0;
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+
+	if (pHTInfo->IOTPeer==HT_IOT_PEER_RALINK)
+	{
+			retValue = 1;
+	}
+
+	return retValue;
+}
+
+u8
+HTIOTActDisableHighPower(struct rtllib_device* ieee,struct rtllib_network *network)
+{
+	u8	retValue = 0;
+#if (defined RTL8192SE || defined RTL8192SU || defined RTL8192CE)
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+#endif
+
+#ifdef RTL8192SU
+	if (pHTInfo->IOTPeer==HT_IOT_PEER_RALINK ||
+		pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK ||
+		pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK_92SE)
+	{
+			retValue = 1;
+	}
+#elif defined RTL8192SE || defined RTL8192CE
+	if (pHTInfo->IOTPeer==HT_IOT_PEER_RALINK ||
+		pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK )
+	{
+			retValue = 1;
+	}
+#endif
+	return retValue;
+}
+
+void
+HTIOTActDetermineRaFunc(struct rtllib_device* ieee,	bool	bPeerRx2ss)
+{
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	pHTInfo->IOTRaFunc &= HT_IOT_RAFUNC_DISABLE_ALL;
+
+	if (pHTInfo->IOTPeer == HT_IOT_PEER_RALINK && !bPeerRx2ss)
+		pHTInfo->IOTRaFunc |= HT_IOT_RAFUNC_PEER_1R;
+
+	if (pHTInfo->IOTAction & HT_IOT_ACT_AMSDU_ENABLE)
+		pHTInfo->IOTRaFunc |= HT_IOT_RAFUNC_TX_AMSDU;
+
+}
+
+
+u8
+HTIOTActIsDisableTx40MHz(struct rtllib_device* ieee,struct rtllib_network *network)
+{
+	u8	retValue = 0;
+
+#if (defined RTL8192SU || defined RTL8192SE || defined RTL8192CE)
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	if (	(KEY_TYPE_WEP104 == ieee->pairwise_key_type) ||
+		(KEY_TYPE_WEP40 == ieee->pairwise_key_type) ||
+		(KEY_TYPE_WEP104 == ieee->group_key_type) ||
+		(KEY_TYPE_WEP40 == ieee->group_key_type) ||
+		(KEY_TYPE_TKIP == ieee->pairwise_key_type) )
+	{
+		if ((pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK) && (network->bssht.bdSupportHT))
+			retValue = 1;
+	}
+#endif
+
+	return retValue;
+}
+
+u8
+HTIOTActIsTxNoAggregation(struct rtllib_device* ieee,struct rtllib_network *network)
+{
+	u8 retValue = 0;
+
+#if (defined RTL8192SU || defined RTL8192SE || defined RTL8192CE)
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	if (	(KEY_TYPE_WEP104 == ieee->pairwise_key_type) ||
+		(KEY_TYPE_WEP40 == ieee->pairwise_key_type) ||
+		(KEY_TYPE_WEP104 == ieee->group_key_type) ||
+		(KEY_TYPE_WEP40 == ieee->group_key_type) ||
+		(KEY_TYPE_TKIP == ieee->pairwise_key_type) )
+	{
+		if (pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK)
+			retValue = 1;
+	}
+#endif
+
+	return retValue;
+}
+
+
+u8
+HTIOTActIsDisableTx2SS(struct rtllib_device* ieee,struct rtllib_network *network)
+{
+	u8	retValue = 0;
+
+#if (defined RTL8192SU || defined RTL8192SE || defined RTL8192CE)
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	if (	(KEY_TYPE_WEP104 == ieee->pairwise_key_type) ||
+		(KEY_TYPE_WEP40 == ieee->pairwise_key_type) ||
+		(KEY_TYPE_WEP104 == ieee->group_key_type) ||
+		(KEY_TYPE_WEP40 == ieee->group_key_type) ||
+		(KEY_TYPE_TKIP == ieee->pairwise_key_type) )
+	{
+		if ((pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK) && (network->bssht.bdSupportHT))
+			retValue = 1;
+	}
+#endif
+
+	return retValue;
+}
+
+
+bool HTIOCActIsDisableCckRate(struct rtllib_device* ieee,struct rtllib_network *network)
+{
+	bool	retValue = false;
+#if defined(RTL8192SU)
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	if (pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
+	{
+		if ((memcmp(network->bssid, NETGEAR_BROADCOM, 3)==0)
+			&& (network->bssht.bdBandWidth == HT_CHANNEL_WIDTH_20_40))
+			return true;
+	}
+#endif
+	return retValue;
+}
+
+bool HTIOCActAllowPeerAggOnePacket(struct rtllib_device* ieee,struct rtllib_network *network)
+{
+	bool	retValue = false;
+#if defined(RTL8192SE) || defined(RTL8192SU)
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	{
+		if (ieee->VersionID<2)
+		if (pHTInfo->IOTPeer == HT_IOT_PEER_MARVELL)
+			return true;
+
+	}
+#endif
+	return retValue;
+}
+
+bool
+HTIOTActIsNullDataPowerSaving(struct rtllib_device* ieee,struct rtllib_network *network)
+{
+	bool	retValue = false;
+#if defined(RTL8192SE) || defined(RTL8192SU)
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	{
+		if (pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
+			return true;
+
+	}
+#endif
+	return retValue;
+}
+
+void HTResetIOTSetting(
+	PRT_HIGH_THROUGHPUT		pHTInfo
+)
+{
+	pHTInfo->IOTAction = 0;
+	pHTInfo->IOTPeer = HT_IOT_PEER_UNKNOWN;
+	pHTInfo->IOTRaFunc = 0;
+}
+
+
+void HTConstructCapabilityElement(struct rtllib_device* ieee, u8* posHTCap, u8* len, u8 IsEncrypt, bool bAssoc)
+{
+	PRT_HIGH_THROUGHPUT	pHT = ieee->pHTInfo;
+	PHT_CAPABILITY_ELE	pCapELE = NULL;
+
+	if ((posHTCap == NULL) || (pHT == NULL))
+	{
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posHTCap or pHTInfo can't be null in HTConstructCapabilityElement()\n");
+		return;
+	}
+	memset(posHTCap, 0, *len);
+
+	if ((bAssoc) && (pHT->ePeerHTSpecVer == HT_SPEC_VER_EWC))
+	{
+		u8	EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};
+		memcpy(posHTCap, EWC11NHTCap, sizeof(EWC11NHTCap));
+		pCapELE = (PHT_CAPABILITY_ELE)&(posHTCap[4]);
+		*len = 30 + 2;
+	}else
+	{
+		pCapELE = (PHT_CAPABILITY_ELE)posHTCap;
+		*len = 26 + 2;
+	}
+
+	pCapELE->AdvCoding		= 0;
+	if (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
+		pCapELE->ChlWidth = 0;
+	else
+			pCapELE->ChlWidth = (pHT->bRegBW40MHz?1:0);
+
+	pCapELE->MimoPwrSave		= pHT->SelfMimoPs;
+	pCapELE->GreenField		= 0;
+	pCapELE->ShortGI20Mhz		= 1;
+	pCapELE->ShortGI40Mhz		= 1;
+
+	pCapELE->TxSTBC			= 1;
+#if defined RTL8192SE || defined RTL8192CE
+	pCapELE->TxSTBC			= 0;
+#endif
+	pCapELE->RxSTBC			= 0;
+	pCapELE->DelayBA		= 0;
+	pCapELE->MaxAMSDUSize	= (MAX_RECEIVE_BUFFER_SIZE>=7935)?1:0;
+	pCapELE->DssCCk			= ((pHT->bRegBW40MHz)?(pHT->bRegSuppCCK?1:0):0);
+	pCapELE->PSMP			= 0;
+	pCapELE->LSigTxopProtect	= 0;
+
+
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "TX HT cap/info ele BW=%d MaxAMSDUSize:%d DssCCk:%d\n", pCapELE->ChlWidth, pCapELE->MaxAMSDUSize, pCapELE->DssCCk);
+
+	if ( IsEncrypt)
+	{
+		pCapELE->MPDUDensity	= 7;
+		pCapELE->MaxRxAMPDUFactor	= 2;
+	}
+	else
+	{
+		pCapELE->MaxRxAMPDUFactor	= 3;
+		pCapELE->MPDUDensity	= 0;
+	}
+
+	memcpy(pCapELE->MCS, ieee->Regdot11HTOperationalRateSet, 16);
+	memset(&pCapELE->ExtHTCapInfo, 0, 2);
+	memset(pCapELE->TxBFCap, 0, 4);
+
+	pCapELE->ASCap = 0;
+
+	if (bAssoc) {
+		if (pHT->IOTAction & HT_IOT_ACT_DISABLE_MCS15)
+			pCapELE->MCS[1] &= 0x7f;
+
+		if (pHT->IOTAction & HT_IOT_ACT_DISABLE_MCS14)
+			pCapELE->MCS[1] &= 0xbf;
+
+		if (pHT->IOTAction & HT_IOT_ACT_DISABLE_ALL_2SS)
+			pCapELE->MCS[1] &= 0x00;
+
+		if (pHT->IOTAction & HT_IOT_ACT_DISABLE_RX_40MHZ_SHORT_GI)
+			pCapELE->ShortGI40Mhz		= 0;
+
+		if (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
+		{
+			pCapELE->ChlWidth = 0;
+
+			pCapELE->MCS[1] = 0;
+		}
+	}
+
+
+
+
+
+	return;
+
+}
+void HTConstructInfoElement(struct rtllib_device* ieee, u8* posHTInfo, u8* len, u8 IsEncrypt)
+{
+	PRT_HIGH_THROUGHPUT	pHT = ieee->pHTInfo;
+	PHT_INFORMATION_ELE		pHTInfoEle = (PHT_INFORMATION_ELE)posHTInfo;
+	if ((posHTInfo == NULL) || (pHTInfoEle == NULL))
+	{
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posHTInfo or pHTInfoEle can't be null in HTConstructInfoElement()\n");
+		return;
+	}
+
+	memset(posHTInfo, 0, *len);
+	if ( (ieee->iw_mode == IW_MODE_ADHOC) || (ieee->iw_mode == IW_MODE_MASTER))
+	{
+		pHTInfoEle->ControlChl	= ieee->current_network.channel;
+		pHTInfoEle->ExtChlOffset = ((pHT->bRegBW40MHz == false)?HT_EXTCHNL_OFFSET_NO_EXT:
+							(ieee->current_network.channel<=6)?
+							HT_EXTCHNL_OFFSET_UPPER:HT_EXTCHNL_OFFSET_LOWER);
+		pHTInfoEle->RecommemdedTxWidth	= pHT->bRegBW40MHz;
+		pHTInfoEle->RIFS					= 0;
+		pHTInfoEle->PSMPAccessOnly		= 0;
+		pHTInfoEle->SrvIntGranularity		= 0;
+		pHTInfoEle->OptMode				= pHT->CurrentOpMode;
+		pHTInfoEle->NonGFDevPresent		= 0;
+		pHTInfoEle->DualBeacon			= 0;
+		pHTInfoEle->SecondaryBeacon		= 0;
+		pHTInfoEle->LSigTxopProtectFull		= 0;
+		pHTInfoEle->PcoActive				= 0;
+		pHTInfoEle->PcoPhase				= 0;
+
+		memset(pHTInfoEle->BasicMSC, 0, 16);
+
+
+		*len = 22 + 2;
+
+	}
+	else
+	{
+		*len = 0;
+	}
+	return;
+}
+
+void HTConstructRT2RTAggElement(struct rtllib_device* ieee, u8* posRT2RTAgg, u8* len)
+{
+	if (posRT2RTAgg == NULL) {
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "posRT2RTAgg can't be null in HTConstructRT2RTAggElement()\n");
+		return;
+	}
+	memset(posRT2RTAgg, 0, *len);
+	*posRT2RTAgg++ = 0x00;
+	*posRT2RTAgg++ = 0xe0;
+	*posRT2RTAgg++ = 0x4c;
+	*posRT2RTAgg++ = 0x02;
+	*posRT2RTAgg++ = 0x01;
+
+#ifdef RTL8192CE
+	*posRT2RTAgg = 0x70;
+#else
+	*posRT2RTAgg = 0x30;
+#endif
+
+	if (ieee->bSupportRemoteWakeUp) {
+		*posRT2RTAgg |= RT_HT_CAP_USE_WOW;
+	}
+
+	*len = 6 + 2;
+
+	return;
+
+#ifdef TODO
+	posRT2RTAgg->Length = 6;
+#endif
+
+
+
+
+}
+
+u8 HT_PickMCSRate(struct rtllib_device* ieee, u8* pOperateMCS)
+{
+	u8					i;
+	if (pOperateMCS == NULL)
+	{
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "pOperateMCS can't be null in HT_PickMCSRate()\n");
+		return false;
+	}
+
+	switch (ieee->mode) {
+	case IEEE_A:
+	case IEEE_B:
+	case IEEE_G:
+		for (i=0;i<=15;i++)
+				pOperateMCS[i] = 0;
+		break;
+	case IEEE_N_24G:
+	case IEEE_N_5G:
+		pOperateMCS[0] &=RATE_ADPT_1SS_MASK;
+		pOperateMCS[1] &=RATE_ADPT_2SS_MASK;
+		pOperateMCS[3] &=RATE_ADPT_MCS32_MASK;
+		break;
+	default:
+		break;
+
+	}
+
+	return true;
+}
+
+u8 HTGetHighestMCSRate(struct rtllib_device* ieee, u8* pMCSRateSet, u8* pMCSFilter)
+{
+	u8		i, j;
+	u8		bitMap;
+	u8		mcsRate = 0;
+	u8		availableMcsRate[16];
+	if (pMCSRateSet == NULL || pMCSFilter == NULL)
+	{
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "pMCSRateSet or pMCSFilter can't be null in HTGetHighestMCSRate()\n");
+		return false;
+	}
+	for (i=0; i<16; i++)
+		availableMcsRate[i] = pMCSRateSet[i] & pMCSFilter[i];
+
+	for (i = 0; i < 16; i++)
+	{
+		if (availableMcsRate[i] != 0)
+			break;
+	}
+	if (i == 16)
+		return false;
+
+	for (i = 0; i < 16; i++)
+	{
+		if (availableMcsRate[i] != 0)
+		{
+			bitMap = availableMcsRate[i];
+			for (j = 0; j < 8; j++)
+			{
+				if ((bitMap%2) != 0)
+				{
+					if (HTMcsToDataRate(ieee, (8*i+j)) > HTMcsToDataRate(ieee, mcsRate))
+						mcsRate = (8*i+j);
+				}
+				bitMap = bitMap>>1;
+			}
+		}
+	}
+	return (mcsRate|0x80);
+}
+
+u8 HTFilterMCSRate( struct rtllib_device* ieee, u8* pSupportMCS, u8* pOperateMCS)
+{
+
+	u8 i=0;
+
+	for (i=0;i<=15;i++){
+		pOperateMCS[i] = ieee->Regdot11TxHTOperationalRateSet[i]&pSupportMCS[i];
+	}
+
+
+
+	HT_PickMCSRate(ieee, pOperateMCS);
+
+	if (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
+		pOperateMCS[1] = 0;
+
+	for (i=2; i<=15; i++)
+		pOperateMCS[i] = 0;
+
+	return true;
+}
+void HTSetConnectBwMode(struct rtllib_device* ieee, HT_CHANNEL_WIDTH	Bandwidth, HT_EXTCHNL_OFFSET	Offset);
+void HTOnAssocRsp(struct rtllib_device *ieee)
+{
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	PHT_CAPABILITY_ELE		pPeerHTCap = NULL;
+	PHT_INFORMATION_ELE		pPeerHTInfo = NULL;
+	u16	nMaxAMSDUSize = 0;
+	u8*	pMcsFilter = NULL;
+
+	static u8				EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};
+	static u8				EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};
+
+	if ( pHTInfo->bCurrentHTSupport == false )
+	{
+		RTLLIB_DEBUG(RTLLIB_DL_ERR, "<=== HTOnAssocRsp(): HT_DISABLE\n");
+		return;
+	}
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "===> HTOnAssocRsp_wq(): HT_ENABLE\n");
+
+	if (!memcmp(pHTInfo->PeerHTCapBuf,EWC11NHTCap, sizeof(EWC11NHTCap)))
+		pPeerHTCap = (PHT_CAPABILITY_ELE)(&pHTInfo->PeerHTCapBuf[4]);
+	else
+		pPeerHTCap = (PHT_CAPABILITY_ELE)(pHTInfo->PeerHTCapBuf);
+
+	if (!memcmp(pHTInfo->PeerHTInfoBuf, EWC11NHTInfo, sizeof(EWC11NHTInfo)))
+		pPeerHTInfo = (PHT_INFORMATION_ELE)(&pHTInfo->PeerHTInfoBuf[4]);
+	else
+		pPeerHTInfo = (PHT_INFORMATION_ELE)(pHTInfo->PeerHTInfoBuf);
+
+	RTLLIB_DEBUG_DATA(RTLLIB_DL_DATA|RTLLIB_DL_HT, pPeerHTCap, sizeof(HT_CAPABILITY_ELE));
+	HTSetConnectBwMode(ieee, (HT_CHANNEL_WIDTH)(pPeerHTCap->ChlWidth), (HT_EXTCHNL_OFFSET)(pPeerHTInfo->ExtChlOffset));
+	pHTInfo->bCurTxBW40MHz = ((pPeerHTInfo->RecommemdedTxWidth == 1)?true:false);
+
+	pHTInfo->bCurShortGI20MHz=
+		((pHTInfo->bRegShortGI20MHz)?((pPeerHTCap->ShortGI20Mhz==1)?true:false):false);
+	pHTInfo->bCurShortGI40MHz=
+		((pHTInfo->bRegShortGI40MHz)?((pPeerHTCap->ShortGI40Mhz==1)?true:false):false);
+
+	pHTInfo->bCurSuppCCK =
+		((pHTInfo->bRegSuppCCK)?((pPeerHTCap->DssCCk==1)?true:false):false);
+
+
+	pHTInfo->bCurrent_AMSDU_Support = pHTInfo->bAMSDU_Support;
+
+	nMaxAMSDUSize = (pPeerHTCap->MaxAMSDUSize==0)?3839:7935;
+
+	if (pHTInfo->nAMSDU_MaxSize > nMaxAMSDUSize )
+		pHTInfo->nCurrent_AMSDU_MaxSize = nMaxAMSDUSize;
+	else
+		pHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;
+
+	pHTInfo->bCurrentAMPDUEnable = pHTInfo->bAMPDUEnable;
+	if (ieee->rtllib_ap_sec_type &&
+	   (ieee->rtllib_ap_sec_type(ieee)&(SEC_ALG_WEP|SEC_ALG_TKIP))){
+		if ( (pHTInfo->IOTPeer== HT_IOT_PEER_ATHEROS) ||
+				(pHTInfo->IOTPeer == HT_IOT_PEER_UNKNOWN) )
+			pHTInfo->bCurrentAMPDUEnable = false;
+	}
+
+	if (!pHTInfo->bRegRT2RTAggregation)
+	{
+		if (pHTInfo->AMPDU_Factor > pPeerHTCap->MaxRxAMPDUFactor)
+			pHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;
+		else
+			pHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;
+
+	} else {
+		if (ieee->current_network.bssht.bdRT2RTAggregation)
+		{
+			if ( ieee->pairwise_key_type != KEY_TYPE_NA)
+				pHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;
+			else
+				pHTInfo->CurrentAMPDUFactor = HT_AGG_SIZE_64K;
+		}else
+		{
+			if (pPeerHTCap->MaxRxAMPDUFactor < HT_AGG_SIZE_32K)
+				pHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;
+			else
+				pHTInfo->CurrentAMPDUFactor = HT_AGG_SIZE_32K;
+		}
+	}
+	if (pHTInfo->MPDU_Density > pPeerHTCap->MPDUDensity)
+		pHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;
+	else
+		pHTInfo->CurrentMPDUDensity = pPeerHTCap->MPDUDensity;
+#if (defined RTL8192SE || defined RTL8192SU || defined RTL8192CE)
+        if (ieee->SetHwRegHandler != NULL) {
+            ieee->SetHwRegHandler( ieee->dev, HW_VAR_SHORTGI_DENSITY,  (u8*)(&ieee->MaxMssDensity));
+            ieee->SetHwRegHandler(ieee->dev, HW_VAR_AMPDU_FACTOR, &pHTInfo->CurrentAMPDUFactor);
+            ieee->SetHwRegHandler(ieee->dev, HW_VAR_AMPDU_MIN_SPACE, &pHTInfo->CurrentMPDUDensity);
+        }
+#elif defined RTL8192CE
+        if (ieee->SetHwRegHandler != NULL) {
+            ieee->SetHwRegHandler(ieee->dev, HW_VAR_AMPDU_FACTOR, &pHTInfo->CurrentAMPDUFactor);
+            ieee->SetHwRegHandler(ieee->dev, HW_VAR_AMPDU_MIN_SPACE, &pHTInfo->CurrentMPDUDensity);
+        }
+#endif
+#ifndef RTL8190P
+	if (pHTInfo->IOTAction & HT_IOT_ACT_TX_USE_AMSDU_8K)
+#else
+	if ( 0 )
+#endif
+	{
+		pHTInfo->bCurrentAMPDUEnable = false;
+		pHTInfo->ForcedAMSDUMode = HT_AGG_FORCE_ENABLE;
+		pHTInfo->ForcedAMSDUMaxSize = 7935;
+	}
+	pHTInfo->bCurRxReorderEnable = pHTInfo->bRegRxReorderEnable;
+
+	if (pPeerHTCap->MCS[0] == 0)
+		pPeerHTCap->MCS[0] = 0xff;
+
+	HTIOTActDetermineRaFunc(ieee, ((pPeerHTCap->MCS[1])!=0));
+
+	HTFilterMCSRate(ieee, pPeerHTCap->MCS, ieee->dot11HTOperationalRateSet);
+
+	pHTInfo->PeerMimoPs = pPeerHTCap->MimoPwrSave;
+	if (pHTInfo->PeerMimoPs == MIMO_PS_STATIC)
+		pMcsFilter = MCS_FILTER_1SS;
+	else
+		pMcsFilter = MCS_FILTER_ALL;
+	ieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee, ieee->dot11HTOperationalRateSet, pMcsFilter);
+	ieee->HTCurrentOperaRate = ieee->HTHighestOperaRate;
+
+	pHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;
+
+}
+
+void HTSetConnectBwModeCallback(struct rtllib_device* ieee);
+void HTInitializeHTInfo(struct rtllib_device* ieee)
+{
+	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
+
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "===========>%s()\n", __func__);
+	pHTInfo->bCurrentHTSupport = false;
+
+	pHTInfo->bCurBW40MHz = false;
+	pHTInfo->bCurTxBW40MHz = false;
+
+	pHTInfo->bCurShortGI20MHz = false;
+	pHTInfo->bCurShortGI40MHz = false;
+	pHTInfo->bForcedShortGI = false;
+
+	pHTInfo->bCurSuppCCK = true;
+
+	pHTInfo->bCurrent_AMSDU_Support = false;
+	pHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;
+	pHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;
+	pHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;
+
+	memset((void*)(&(pHTInfo->SelfHTCap)), 0, sizeof(pHTInfo->SelfHTCap));
+	memset((void*)(&(pHTInfo->SelfHTInfo)), 0, sizeof(pHTInfo->SelfHTInfo));
+	memset((void*)(&(pHTInfo->PeerHTCapBuf)), 0, sizeof(pHTInfo->PeerHTCapBuf));
+	memset((void*)(&(pHTInfo->PeerHTInfoBuf)), 0, sizeof(pHTInfo->PeerHTInfoBuf));
+
+	pHTInfo->bSwBwInProgress = false;
+	pHTInfo->ChnlOp = CHNLOP_NONE;
+
+	pHTInfo->ePeerHTSpecVer = HT_SPEC_VER_IEEE;
+
+	pHTInfo->bCurrentRT2RTAggregation = false;
+	pHTInfo->bCurrentRT2RTLongSlotTime = false;
+	pHTInfo->RT2RT_HT_Mode = (RT_HT_CAPBILITY)0;
+
+	pHTInfo->IOTPeer = 0;
+	pHTInfo->IOTAction = 0;
+	pHTInfo->IOTRaFunc = 0;
+
+	{
+		u8* RegHTSuppRateSets = &(ieee->RegHTSuppRateSet[0]);
+		RegHTSuppRateSets[0] = 0xFF;
+		RegHTSuppRateSets[1] = 0xFF;
+		RegHTSuppRateSets[4] = 0x01;
+	}
+}
+void HTInitializeBssDesc(PBSS_HT pBssHT)
+{
+
+	pBssHT->bdSupportHT = false;
+	memset(pBssHT->bdHTCapBuf, 0, sizeof(pBssHT->bdHTCapBuf));
+	pBssHT->bdHTCapLen = 0;
+	memset(pBssHT->bdHTInfoBuf, 0, sizeof(pBssHT->bdHTInfoBuf));
+	pBssHT->bdHTInfoLen = 0;
+
+	pBssHT->bdHTSpecVer= HT_SPEC_VER_IEEE;
+
+	pBssHT->bdRT2RTAggregation = false;
+	pBssHT->bdRT2RTLongSlotTime = false;
+	pBssHT->RT2RT_HT_Mode = (RT_HT_CAPBILITY)0;
+}
+
+void HTResetSelfAndSavePeerSetting(struct rtllib_device* ieee,	struct rtllib_network * pNetwork)
+{
+	PRT_HIGH_THROUGHPUT		pHTInfo = ieee->pHTInfo;
+	u8	bIOTAction = 0;
+
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "==============>%s()\n", __func__);
+	/*unmark bEnableHT flag here is the same reason why unmarked in function rtllib_softmac_new_net. WB 2008.09.10*/
+	if (pNetwork->bssht.bdSupportHT)
+	{
+		pHTInfo->bCurrentHTSupport = true;
+		pHTInfo->ePeerHTSpecVer = pNetwork->bssht.bdHTSpecVer;
+
+		if (pNetwork->bssht.bdHTCapLen > 0 &&	pNetwork->bssht.bdHTCapLen <= sizeof(pHTInfo->PeerHTCapBuf))
+			memcpy(pHTInfo->PeerHTCapBuf, pNetwork->bssht.bdHTCapBuf, pNetwork->bssht.bdHTCapLen);
+
+		if (pNetwork->bssht.bdHTInfoLen > 0 && pNetwork->bssht.bdHTInfoLen <= sizeof(pHTInfo->PeerHTInfoBuf))
+			memcpy(pHTInfo->PeerHTInfoBuf, pNetwork->bssht.bdHTInfoBuf, pNetwork->bssht.bdHTInfoLen);
+
+		if (pHTInfo->bRegRT2RTAggregation)
+		{
+			pHTInfo->bCurrentRT2RTAggregation = pNetwork->bssht.bdRT2RTAggregation;
+			pHTInfo->bCurrentRT2RTLongSlotTime = pNetwork->bssht.bdRT2RTLongSlotTime;
+			pHTInfo->RT2RT_HT_Mode = pNetwork->bssht.RT2RT_HT_Mode;
+		}
+		else
+		{
+			pHTInfo->bCurrentRT2RTAggregation = false;
+			pHTInfo->bCurrentRT2RTLongSlotTime = false;
+			pHTInfo->RT2RT_HT_Mode = (RT_HT_CAPBILITY)0;
+		}
+
+		HTIOTPeerDetermine(ieee);
+
+		pHTInfo->IOTAction = 0;
+		bIOTAction = HTIOTActIsDisableMCS14(ieee, pNetwork->bssid);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_MCS14;
+
+		bIOTAction = HTIOTActIsDisableMCS15(ieee);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_MCS15;
+
+		bIOTAction = HTIOTActIsDisableMCSTwoSpatialStream(ieee);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_ALL_2SS;
+
+
+		bIOTAction = HTIOTActIsDisableEDCATurbo(ieee, pNetwork->bssid);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_EDCA_TURBO;
+
+#if defined(RTL8190P) || defined(RTL8192E) || defined(RTL8192U)
+		bIOTAction = HTIOTActIsMgntUseCCK6M(ieee,pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_MGNT_USE_CCK_6M;
+#elif defined(RTL8192SE) || defined(RTL8192SU) || defined RTL8192CE
+		bIOTAction = HTIOTActWAIOTBroadcom(ieee);
+		if (bIOTAction)
+		{
+			pHTInfo->IOTAction |= HT_IOT_ACT_WA_IOT_Broadcom;
+		}
+#endif
+		bIOTAction = HTIOTActIsCCDFsync(ieee);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_CDD_FSYNC;
+#if defined(RTL8192SU) || defined(RTL8192SE) || defined RTL8192CE
+		bIOTAction = HTIOTActIsForcedCTS2Self(ieee,pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_FORCED_CTS2SELF;
+
+
+		bIOTAction = HTIOTActIsEnableBETxOPLimit(ieee);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_FORCED_ENABLE_BE_TXOP;
+
+#if defined(RTL8192SU)
+		bIOTAction = HTIOCActRejcectADDBARequest(pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_REJECT_ADDBA_REQ;
+#endif
+
+		bIOTAction = HTIOCActAllowPeerAggOnePacket(ieee, pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_ALLOW_PEER_AGG_ONE_PKT;
+
+		bIOTAction = HTIOTActIsEDCABiasRx(ieee, pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_EDCA_BIAS_ON_RX;
+
+#if defined(RTL8192SU)
+		bIOTAction = HTIOCActIsDisableCckRate(ieee, pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_CCK_RATE;
+#endif
+		bIOTAction = HTIOTActDisableShortGI(ieee, pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_SHORT_GI;
+
+		bIOTAction = HTIOTActDisableHighPower(ieee, pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_HIGH_POWER;
+
+
+		bIOTAction = HTIOTActIsForcedAMSDU8K(ieee, pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_TX_USE_AMSDU_8K;
+
+#if defined(RTL8192SU)
+		bIOTAction = HTIOTActIsTxNoAggregation(ieee, pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_TX_NO_AGGREGATION;
+
+		bIOTAction = HTIOTActIsDisableTx40MHz(ieee, pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_TX_40_MHZ;
+
+		bIOTAction = HTIOTActIsDisableTx2SS(ieee, pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_TX_2SS;
+#endif
+
+		bIOTAction = HTIOTActIsForcedRTSCTS(ieee, pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_FORCED_RTS;
+
+		bIOTAction = HTIOTActIsNullDataPowerSaving(ieee, pNetwork);
+		if (bIOTAction)
+			pHTInfo->IOTAction |= HT_IOT_ACT_NULL_DATA_POWER_SAVING;
+#endif
+
+	} else {
+		pHTInfo->bCurrentHTSupport = false;
+		pHTInfo->bCurrentRT2RTAggregation = false;
+		pHTInfo->bCurrentRT2RTLongSlotTime = false;
+		pHTInfo->RT2RT_HT_Mode = (RT_HT_CAPBILITY)0;
+
+		pHTInfo->IOTAction = 0;
+		pHTInfo->IOTRaFunc = 0;
+	}
+
+}
+
+void HTUpdateSelfAndPeerSetting(struct rtllib_device* ieee,	struct rtllib_network * pNetwork)
+{
+	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
+	PHT_INFORMATION_ELE		pPeerHTInfo = (PHT_INFORMATION_ELE)pNetwork->bssht.bdHTInfoBuf;
+
+	if (pHTInfo->bCurrentHTSupport)
+	{
+		if (pNetwork->bssht.bdHTInfoLen != 0)
+			pHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;
+
+	}
+}
+
+void HTUseDefaultSetting(struct rtllib_device* ieee)
+{
+	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
+
+	if (pHTInfo->bEnableHT)
+	{
+		pHTInfo->bCurrentHTSupport = true;
+		pHTInfo->bCurSuppCCK = pHTInfo->bRegSuppCCK;
+
+		pHTInfo->bCurBW40MHz = pHTInfo->bRegBW40MHz;
+		pHTInfo->bCurShortGI20MHz= pHTInfo->bRegShortGI20MHz;
+
+		pHTInfo->bCurShortGI40MHz= pHTInfo->bRegShortGI40MHz;
+
+		if (ieee->iw_mode == IW_MODE_ADHOC)
+		{
+			ieee->current_network.qos_data.active = ieee->current_network.qos_data.supported;
+		}
+		pHTInfo->bCurrent_AMSDU_Support = pHTInfo->bAMSDU_Support;
+		pHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;
+
+		pHTInfo->bCurrentAMPDUEnable = pHTInfo->bAMPDUEnable;
+		pHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;
+
+		pHTInfo->CurrentMPDUDensity = pHTInfo->CurrentMPDUDensity;
+
+
+		HTFilterMCSRate(ieee, ieee->Regdot11TxHTOperationalRateSet, ieee->dot11HTOperationalRateSet);
+#ifdef TODO
+		Adapter->HalFunc.InitHalRATRTableHandler( Adapter, &pMgntInfo->dot11OperationalRateSet, pMgntInfo->dot11HTOperationalRateSet);
+#endif
+		ieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee, ieee->dot11HTOperationalRateSet, MCS_FILTER_ALL);
+		ieee->HTCurrentOperaRate = ieee->HTHighestOperaRate;
+
+#if (defined RTL8192SE || defined RTL8192SU || defined RTL8192CE)
+		if (ieee->SetHwRegHandler != NULL) {
+			ieee->SetHwRegHandler( ieee->dev, HW_VAR_SHORTGI_DENSITY,  (u8*)(&ieee->MaxMssDensity));
+			ieee->SetHwRegHandler(ieee->dev, HW_VAR_AMPDU_FACTOR, &pHTInfo->CurrentAMPDUFactor);
+			ieee->SetHwRegHandler(ieee->dev, HW_VAR_AMPDU_MIN_SPACE, &pHTInfo->CurrentMPDUDensity);
+		}
+#endif
+
+	}
+	else
+	{
+		pHTInfo->bCurrentHTSupport = false;
+	}
+	return;
+}
+u8 HTCCheck(struct rtllib_device* ieee, u8*	pFrame)
+{
+	if (ieee->pHTInfo->bCurrentHTSupport)
+	{
+		if ( (IsQoSDataFrame(pFrame) && Frame_Order(pFrame)) == 1)
+		{
+			RTLLIB_DEBUG(RTLLIB_DL_HT, "HT CONTROL FILED EXIST!!\n");
+			return true;
+		}
+	}
+	return false;
+}
+
+void HTSetConnectBwMode(struct rtllib_device* ieee, HT_CHANNEL_WIDTH	Bandwidth, HT_EXTCHNL_OFFSET	Offset)
+{
+	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
+
+	if (pHTInfo->bRegBW40MHz == false)
+		return;
+
+	if (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
+		Bandwidth=HT_CHANNEL_WIDTH_20;
+
+
+	if (pHTInfo->bSwBwInProgress) {
+		printk("%s: bSwBwInProgress!!\n", __func__);
+		return;
+	}
+	if (Bandwidth==HT_CHANNEL_WIDTH_20_40)
+	 {
+		if (ieee->current_network.channel<2 && Offset==HT_EXTCHNL_OFFSET_LOWER)
+			Offset = HT_EXTCHNL_OFFSET_NO_EXT;
+		if (Offset==HT_EXTCHNL_OFFSET_UPPER || Offset==HT_EXTCHNL_OFFSET_LOWER) {
+			pHTInfo->bCurBW40MHz = true;
+			pHTInfo->CurSTAExtChnlOffset = Offset;
+		} else {
+			pHTInfo->bCurBW40MHz = false;
+			pHTInfo->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;
+		}
+	} else {
+		pHTInfo->bCurBW40MHz = false;
+		pHTInfo->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;
+	}
+
+	printk("%s():pHTInfo->bCurBW40MHz:%x\n", __func__, pHTInfo->bCurBW40MHz);
+
+	pHTInfo->bSwBwInProgress = true;
+
+	HTSetConnectBwModeCallback(ieee);
+
+}
+
+void HTSetConnectBwModeCallback(struct rtllib_device* ieee)
+{
+	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
+
+	RTLLIB_DEBUG(RTLLIB_DL_HT, "======>%s()\n", __func__);
+	if (pHTInfo->bCurBW40MHz)
+	{
+		if (pHTInfo->CurSTAExtChnlOffset==HT_EXTCHNL_OFFSET_UPPER)
+			ieee->set_chan(ieee->dev, ieee->current_network.channel+2);
+		else if (pHTInfo->CurSTAExtChnlOffset==HT_EXTCHNL_OFFSET_LOWER)
+			ieee->set_chan(ieee->dev, ieee->current_network.channel-2);
+		else
+			ieee->set_chan(ieee->dev, ieee->current_network.channel);
+
+		ieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20_40, pHTInfo->CurSTAExtChnlOffset);
+	} else {
+		ieee->set_chan(ieee->dev, ieee->current_network.channel);
+		ieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
+	}
+
+	pHTInfo->bSwBwInProgress = false;
+}
